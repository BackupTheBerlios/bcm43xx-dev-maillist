From hanbo00 at gmail.com  Mon Dec  1 05:04:24 2008
From: hanbo00 at gmail.com (Bo Han)
Date: Sun, 30 Nov 2008 20:04:24 -0800
Subject: Set CRC check in b43
Message-ID: <d0ad1e930811302004w567b0766v1c07bff54671810f@mail.gmail.com>

Hi there,

I am wondering whether we can set CRC check in b43 driver.
That is, whether we can configure the b43 driver to pass the
CRC error frames to higher layer.

Thanks,
-Bo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081130/30bb3177/attachment.html>

From markryde at gmail.com  Tue Dec  2 10:15:17 2008
From: markryde at gmail.com (Mark Ryden)
Date: Tue, 2 Dec 2008 11:15:17 +0200
Subject: Power saving mode in Bcm43 driver
Message-ID: <dac45060812020115m6eb2ae4bya5f3280d1db79bb6@mail.gmail.com>

Hello,

I have a question about Bcm43 driver: As far as I know, this driver
does support power saving mode. When the Bcm43 device enters power saving mode,
it should send a control frame (beacon) with power management bit set to 1, to
the access point it is associated with (I am talking about
infrastructure network).

When it exits power save mode, it should send PSPOLL frame to
retrieve the frames that the AP had buffered for it.

I am performing some tests with various wireless nics and an access point.

I tried to delve into the Bcm43 code and could not find the code
which handles entering power save mode. Grepping for "IEEE80211_FCTL_PM" in the
driver code did not find anything (IEEE80211_FCTL_PM is the power save
mode bit in a control
frame).

Where is the code that handles entering power save mode in this driver?

Regards,
Mark


From mb at bu3sch.de  Tue Dec  2 15:41:04 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 2 Dec 2008 15:41:04 +0100
Subject: Power saving mode in Bcm43 driver
In-Reply-To: <dac45060812020115m6eb2ae4bya5f3280d1db79bb6@mail.gmail.com>
References: <dac45060812020115m6eb2ae4bya5f3280d1db79bb6@mail.gmail.com>
Message-ID: <200812021541.04610.mb@bu3sch.de>

On Tuesday 02 December 2008 10:15:17 Mark Ryden wrote:
>  As far as I know, this driver
> does support power saving mode.
No


From wauhugo at yahoo.com  Tue Dec  2 19:59:56 2008
From: wauhugo at yahoo.com (wauhugo at yahoo.com)
Date: Tue, 02 Dec 2008 11:59:56 -0700
Subject: less power driver?
Message-ID: <493585AC.6090700@yahoo.com>

Using the b43 wireless LAN driver do I have to bring my notebook in a 
certain position and need good weather for to get a sometimes disrupted 
connection to the AP.

By chance have I noticed, that the connection works nearly everywhere in 
this building if I use ndiswrapper.


But I want to use the B43 driver rather.


I have noticed that # iwconfig

gives out Tx-Power: 32 dBm when ndiswrapper is running

and Tx-Power: 20 dBm when b43 is running


With the b43 driver have I not been able to increase Tx-power

# iwconfig wlan0 txpower 32

to that value, which is indicated when I run ndiswrapper.


Also the Link Quality (Signal to Noise Ratio) seems to be differently 
indicated - but this is probably a matter how it is calculated (by the 
different drivers?).


Is there a way, to achieve the same flexibility and about the same link 
quality without the need of many reconnects with b43?


(I am actually running Debian kernel 2.6.26 and I have tested 2.6.27.5 
with not more B43  connection success)


Thanks in advance.


Hugo Wau





From Larry.Finger at lwfinger.net  Tue Dec  2 22:32:06 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 02 Dec 2008 15:32:06 -0600
Subject: less power driver?
In-Reply-To: <493585AC.6090700@yahoo.com>
References: <493585AC.6090700@yahoo.com>
Message-ID: <4935A956.2080904@lwfinger.net>

cc the list

The short answer is you cannot. You might modify b43 to increase that number,
but your device might not last very long. The reason is that every Broadcom chip
contains an SPROM that contains the maximum power to be sent to the radio, among
other things. Assuming that Broadcom sacrificed a number of devices to learn a
safe value, increasing the power might damage your chip. You might have one that
can stand more power than most, but it might stand less. Are you willing to risk
your hardware?

In b43, the MAC layer sends a power of 27 dBm to b43, but the driver reduces the
value to maximum based on that chip's programming. The reduced number is what
iwconfig reports. I have no idea what the Windows driver is doing, but I doubt
that it is sending more than the SPROM max to the chip, no matter what it is
reporting.

Why does ndiswrapper get better results? First of all, ndiswrapper only converts
the Windows system calls to the Linux equivalent. It is the Windows driver that
does the work. Remember that Broadcom software personnel wrote that Windows
driver with full access to the device specifications. The code in b43 was
written from "specifications" deduced by disassembling Broadcom code. Any
mistakes in the disassembly, or errors in the original Broadcom code that have
since been corrected might hurt the performance of b43 on that device relative
to the Windows driver.

The performance of the Windows driver relative to b43 varies a lot depending on
the particular chip you have. The BCM4306 chips are the worst - the BCM4311's
are the best. What chip do you have?

There are some differences between 2.6.27 and 2.6.28 in the behavior of the MAC
layer. The newer code does much better at recovering from low signals. If you
want the best, then you should use the kernel from the wireless-testing git
tree. That code will not be in mainline until 2.6.29. Alternatively, you could
use the code from compat-wireless. It is the same as the wireless-testing tree.

Larry



From yuval at avramzon.net  Sun Dec  7 10:29:27 2008
From: yuval at avramzon.net (Yuval Hager)
Date: Sun, 7 Dec 2008 11:29:27 +0200
Subject: BCM4312 Fails when xdm is started
In-Reply-To: <20081125071818.9256.qmail@stuge.se>
References: <200811151801.02369.yuval@avramzon.net>
	<200811250745.22487.yuval@avramzon.net>
	<20081125071818.9256.qmail@stuge.se>
Message-ID: <200812071129.32113.yuval@avramzon.net>

On Tuesday 25 November 2008, Peter Stuge wrote:
> Yuval Hager wrote:
> > I played around with different video drivers and the results are:
> > * If using the 'via' driver, I lose the PCIe card immediately upon
> >   initialization
> > * Using the 'openchrome' (trunk version), It works well in the
> >   beginning.
> >   After first blanking the register reads are all 1's, and then
> >   when the screen is blank I get a different read (some registers
> >   are correct, some are wrong), and when the screen is unblanked, I
> >   get 0xff's again. Very consistent and predictabe (same read every
> >   time).
> > * Using the 'vesa' driver I could not recreate the problem. I could
> >   not get the screen to blank for some reason, but closing the lid,
> >   going on standby/hibernate, restarting X - all didn't matter much
> >   to the PCI and the wireless card kept on working.
>
> Good work! You have beyond any doubt established that the X graphics
> driver can cause this problem.
>

This issue has been tracked down to be at the openchrome driver. It appears 
that somehow it corrupted the PCI bus, and damaged the device right after the 
video card - the wireless card. 

The current workaround for this is here - 
http://wiki.openchrome.org/pipermail/openchrome-devel/2008-November/000139.html - 
but this is just a quick hack, not a fix, although it works great for me. The 
openchrome team is working on a patch based on this.

Thanks for all the help - I am a very happy HP2133 user, and a very happy 
community member. This was an amazing opensource support experience, which 
I'll remember for a long time. Thank you all!

Cheers,

-- 
Yuval Hager
[@] yuval at avramzon.net
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: This is a digitally signed message part.
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081207/9e62fc7d/attachment.pgp>

From Larry.Finger at lwfinger.net  Sun Dec  7 17:15:38 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 07 Dec 2008 10:15:38 -0600
Subject: BCM4312 Fails when xdm is started
In-Reply-To: <200812071129.32113.yuval@avramzon.net>
References: <200811151801.02369.yuval@avramzon.net>
	<200811250745.22487.yuval@avramzon.net>
	<20081125071818.9256.qmail@stuge.se>
	<200812071129.32113.yuval@avramzon.net>
Message-ID: <493BF6AA.7030602@lwfinger.net>

Yuval Hager wrote:
> 
> This issue has been tracked down to be at the openchrome driver. It appears 
> that somehow it corrupted the PCI bus, and damaged the device right after the 
> video card - the wireless card. 
> 
> The current workaround for this is here - 
> http://wiki.openchrome.org/pipermail/openchrome-devel/2008-November/000139.html - 
> but this is just a quick hack, not a fix, although it works great for me. The 
> openchrome team is working on a patch based on this.
> 
> Thanks for all the help - I am a very happy HP2133 user, and a very happy 
> community member. This was an amazing opensource support experience, which 
> I'll remember for a long time. Thank you all!

Thanks for the feedback. The community may struggle a bit on some problems, and
the approach to a solution may look like a drunken sailor's walk, but we usually
get there.

Larry



From Larry.Finger at lwfinger.net  Wed Dec 10 06:35:41 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 09 Dec 2008 23:35:41 -0600
Subject: [PATCH] b43legacy: Fix sparse warnings
Message-ID: <493f552d.zivnzjivWDMPej+O%Larry.Finger@lwfinger.net>

Sparse yields the following warnings for b43legacy:

  CHECK   drivers/net/wireless/b43legacy/phy.c
drivers/net/wireless/b43legacy/phy.c:1304:31: warning: potentially expensive pointer subtraction
drivers/net/wireless/b43legacy/phy.c:1304:31: warning: potentially expensive pointer subtraction
drivers/net/wireless/b43legacy/phy.c:1304:31: warning: potentially expensive pointer subtraction
  CHECK   drivers/net/wireless/b43legacy/debugfs.c
drivers/net/wireless/b43legacy/debugfs.c:243:9: warning: memset with byte count of 131072

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This is 2.6.29 material.

Larry
---

Index: wireless-testing/drivers/net/wireless/b43legacy/debugfs.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43legacy/debugfs.c
+++ wireless-testing/drivers/net/wireless/b43legacy/debugfs.c
@@ -211,7 +211,7 @@ static ssize_t b43legacy_debugfs_read(st
 	struct b43legacy_dfs_file *dfile;
 	ssize_t uninitialized_var(ret);
 	char *buf;
-	const size_t bufsize = 1024 * 128;
+	const size_t bufsize = 1024 * 16; /* 16 KiB buffer */
 	const size_t buforder = get_order(bufsize);
 	int err = 0;
 
Index: wireless-testing/drivers/net/wireless/b43legacy/phy.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43legacy/phy.c
+++ wireless-testing/drivers/net/wireless/b43legacy/phy.c
@@ -1296,12 +1296,10 @@ void b43legacy_lo_write(struct b43legacy
 	/* Sanity check. */
 	if (pair->low < -8 || pair->low > 8 ||
 	    pair->high < -8 || pair->high > 8) {
-		struct b43legacy_phy *phy = &dev->phy;
 		b43legacydbg(dev->wl,
 		       "WARNING: Writing invalid LOpair "
-		       "(low: %d, high: %d, index: %lu)\n",
-		       pair->low, pair->high,
-		       (unsigned long)(pair - phy->_lo_pairs));
+		       "(low: %d, high: %d)\n",
+		       pair->low, pair->high);
 		dump_stack();
 	}
 #endif


From mb at bu3sch.de  Wed Dec 10 11:33:53 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 10 Dec 2008 11:33:53 +0100
Subject: [PATCH] b43legacy: Fix sparse warnings
In-Reply-To: <493f552d.zivnzjivWDMPej+O%Larry.Finger@lwfinger.net>
References: <493f552d.zivnzjivWDMPej+O%Larry.Finger@lwfinger.net>
Message-ID: <200812101133.54173.mb@bu3sch.de>

On Wednesday 10 December 2008 06:35:41 Larry Finger wrote:
>   CHECK   drivers/net/wireless/b43legacy/debugfs.c
> drivers/net/wireless/b43legacy/debugfs.c:243:9: warning: memset with byte count of 131072

I know about this error and I think it's a damn stupid error.
There is a reason why the value was so high in b43. I don't know about b43legacy.
Did you check if all callbacks still work properly?

> Index: wireless-testing/drivers/net/wireless/b43legacy/debugfs.c
> ===================================================================
> --- wireless-testing.orig/drivers/net/wireless/b43legacy/debugfs.c
> +++ wireless-testing/drivers/net/wireless/b43legacy/debugfs.c
> @@ -211,7 +211,7 @@ static ssize_t b43legacy_debugfs_read(st
>  	struct b43legacy_dfs_file *dfile;
>  	ssize_t uninitialized_var(ret);
>  	char *buf;
> -	const size_t bufsize = 1024 * 128;
> +	const size_t bufsize = 1024 * 16; /* 16 KiB buffer */
>  	const size_t buforder = get_order(bufsize);
>  	int err = 0;

-- 
Greetings, Michael.


From mjg59 at srcf.ucam.org  Wed Dec 10 16:09:35 2008
From: mjg59 at srcf.ucam.org (Matthew Garrett)
Date: Wed, 10 Dec 2008 15:09:35 +0000
Subject: [RFC] b43: rework rfkill code
Message-ID: <20081210150935.GA10927@srcf.ucam.org>

I've reworked the rfkill code in b43. This ought to be more consistent 
with the other drivers and it seems to work on the machines I've tested 
it on here, but it'd be good to get some feedback.

Firstly, I've replaced the polled input device. It's just some delayed 
work now. It polls the hardware every second to determine whether the 
radio has been hardware killed or not. If it has, it sets the rfkill 
state to HARD_BLOCKED. If the radio is enabled and the previous state 
was HARD_BLOCKED, it resets the state to UNBLOCKED. If the radio is 
enabled and the previous state was SOFT_BLOCKED, it leaves the state as 
is.

I also removed some of the complexity from the rfkill toggle function, 
since the rfkill core will handle the case of the user requesting a 
change from HARD_BLOCKED without the driver needing to care.

The final change is that I removed the code for changing the wireless 
state in response to the txpower configuration in mac80211. Right now, I 
can't see any way for this to work correctly - if the user disables the 
radio via rfkill, mac80211 doesn't flag the radio as disabled. As a 
result, the next time the configuration callback is called, b43 
reenables the radio again, even though the user has explicitly disabled 
it. I don't think any of the other drivers handle this case, so I'm not 
really sure what the best way to handle this in future is. The current 
situation certainly seems broken.

How does this look to people?

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index c34c589..9231eea 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -3384,21 +3384,6 @@ static int b43_op_config(struct ieee80211_hw *hw, u32 changed)
 	    b43_is_mode(wl, NL80211_IFTYPE_MESH_POINT))
 		b43_set_beacon_int(dev, conf->beacon_int);
 
-	if (!!conf->radio_enabled != phy->radio_on) {
-		if (conf->radio_enabled) {
-			b43_software_rfkill(dev, RFKILL_STATE_UNBLOCKED);
-			b43info(dev->wl, "Radio turned on by software\n");
-			if (!dev->radio_hw_enable) {
-				b43info(dev->wl, "The hardware RF-kill button "
-					"still turns the radio physically off. "
-					"Press the button to turn it on.\n");
-			}
-		} else {
-			b43_software_rfkill(dev, RFKILL_STATE_SOFT_BLOCKED);
-			b43info(dev->wl, "Radio turned off by software\n");
-		}
-	}
-
 	spin_lock_irqsave(&wl->irq_lock, flags);
 	b43_interrupt_enable(dev, savedirqs);
 	mmiowb();
diff --git a/drivers/net/wireless/b43/rfkill.c b/drivers/net/wireless/b43/rfkill.c
index 7137537..4c2907f 100644
--- a/drivers/net/wireless/b43/rfkill.c
+++ b/drivers/net/wireless/b43/rfkill.c
@@ -28,7 +28,6 @@
 
 #include <linux/kmod.h>
 
-
 /* Returns TRUE, if the radio is enabled in hardware. */
 static bool b43_is_hw_radio_enabled(struct b43_wldev *dev)
 {
@@ -45,33 +44,43 @@ static bool b43_is_hw_radio_enabled(struct b43_wldev *dev)
 }
 
 /* The poll callback for the hardware button. */
-static void b43_rfkill_poll(struct input_polled_dev *poll_dev)
+static void b43_rfkill_poll(struct work_struct *work)
 {
-	struct b43_wldev *dev = poll_dev->private;
+	struct b43_rfkill *rfk = container_of(work, struct b43_rfkill,
+					      work.work);
+	struct b43_wldev *dev = rfk->rfkill->data;
 	struct b43_wl *wl = dev->wl;
 	bool enabled;
-	bool report_change = 0;
 
 	mutex_lock(&wl->mutex);
-	if (unlikely(b43_status(dev) < B43_STAT_INITIALIZED)) {
-		mutex_unlock(&wl->mutex);
-		return;
-	}
+
+	if (unlikely(b43_status(dev) < B43_STAT_INITIALIZED))
+		goto out_unlock;
+
 	enabled = b43_is_hw_radio_enabled(dev);
 	if (unlikely(enabled != dev->radio_hw_enable)) {
+		/*
+		 *  If the hardware is enabled and the state isn't
+		 *  hard blocked then we're soft blocked and shouldn't
+		 *  change the state
+		 */
+		if (enabled && rfk->rfkill->state != RFKILL_STATE_HARD_BLOCKED)
+			goto out_unlock;
+
 		dev->radio_hw_enable = enabled;
-		report_change = 1;
+
+		if (enabled)
+			rfkill_force_state(rfk->rfkill, RFKILL_STATE_UNBLOCKED);
+		else
+			rfkill_force_state(rfk->rfkill,
+					   RFKILL_STATE_HARD_BLOCKED);
+
 		b43info(wl, "Radio hardware status changed to %s\n",
 			enabled ? "ENABLED" : "DISABLED");
 	}
+out_unlock:
 	mutex_unlock(&wl->mutex);
-
-	/* send the radio switch event to the system - note both a key press
-	 * and a release are required */
-	if (unlikely(report_change)) {
-		input_report_key(poll_dev->input, KEY_WLAN, 1);
-		input_report_key(poll_dev->input, KEY_WLAN, 0);
-	}
+	schedule_delayed_work(&rfk->work, msecs_to_jiffies(1000));
 }
 
 /* Called when the RFKILL toggled in software. */
@@ -87,26 +96,9 @@ static int b43_rfkill_soft_toggle(void *data, enum rfkill_state state)
 	mutex_lock(&wl->mutex);
 	if (b43_status(dev) < B43_STAT_INITIALIZED)
 		goto out_unlock;
+
 	err = 0;
-	switch (state) {
-	case RFKILL_STATE_UNBLOCKED:
-		if (!dev->radio_hw_enable) {
-			/* No luck. We can't toggle the hardware RF-kill
-			 * button from software. */
-			err = -EBUSY;
-			goto out_unlock;
-		}
-		if (!dev->phy.radio_on)
-			b43_software_rfkill(dev, state);
-		break;
-	case RFKILL_STATE_SOFT_BLOCKED:
-		if (dev->phy.radio_on)
-			b43_software_rfkill(dev, state);
-		break;
-	default:
-		b43warn(wl, "Received unexpected rfkill state %d.\n", state);
-		break;
-	}
+	b43_software_rfkill(dev, state);
 out_unlock:
 	mutex_unlock(&wl->mutex);
 
@@ -141,52 +133,17 @@ void b43_rfkill_init(struct b43_wldev *dev)
 	rfk->rfkill->toggle_radio = b43_rfkill_soft_toggle;
 	rfk->rfkill->user_claim_unsupported = 1;
 
-	rfk->poll_dev = input_allocate_polled_device();
-	if (!rfk->poll_dev) {
-		rfkill_free(rfk->rfkill);
-		goto err_freed_rfk;
-	}
-
-	rfk->poll_dev->private = dev;
-	rfk->poll_dev->poll = b43_rfkill_poll;
-	rfk->poll_dev->poll_interval = 1000; /* msecs */
-
-	rfk->poll_dev->input->name = rfk->name;
-	rfk->poll_dev->input->id.bustype = BUS_HOST;
-	rfk->poll_dev->input->id.vendor = dev->dev->bus->boardinfo.vendor;
-	rfk->poll_dev->input->evbit[0] = BIT(EV_KEY);
-	set_bit(KEY_WLAN, rfk->poll_dev->input->keybit);
-
 	err = rfkill_register(rfk->rfkill);
-	if (err)
-		goto err_free_polldev;
 
-#ifdef CONFIG_RFKILL_INPUT_MODULE
-	/* B43 RF-kill isn't useful without the rfkill-input subsystem.
-	 * Try to load the module. */
-	err = request_module("rfkill-input");
 	if (err)
-		b43warn(wl, "Failed to load the rfkill-input module. "
-			"The built-in radio LED will not work.\n");
-#endif /* CONFIG_RFKILL_INPUT */
-
-#if !defined(CONFIG_RFKILL_INPUT) && !defined(CONFIG_RFKILL_INPUT_MODULE)
-	b43warn(wl, "The rfkill-input subsystem is not available. "
-		"The built-in radio LED will not work.\n");
-#endif
-
-	err = input_register_polled_device(rfk->poll_dev);
-	if (err)
-		goto err_unreg_rfk;
+		goto err_freed_rfk;
 
 	rfk->registered = 1;
 
+	INIT_DELAYED_WORK(&rfk->work, b43_rfkill_poll);
+	schedule_delayed_work(&rfk->work, msecs_to_jiffies(1000));
+
 	return;
-err_unreg_rfk:
-	rfkill_unregister(rfk->rfkill);
-err_free_polldev:
-	input_free_polled_device(rfk->poll_dev);
-	rfk->poll_dev = NULL;
 err_freed_rfk:
 	rfk->rfkill = NULL;
 out_error:
@@ -202,9 +159,8 @@ void b43_rfkill_exit(struct b43_wldev *dev)
 		return;
 	rfk->registered = 0;
 
-	input_unregister_polled_device(rfk->poll_dev);
+	cancel_delayed_work_sync(&rfk->work);
+
 	rfkill_unregister(rfk->rfkill);
-	input_free_polled_device(rfk->poll_dev);
-	rfk->poll_dev = NULL;
 	rfk->rfkill = NULL;
 }
diff --git a/drivers/net/wireless/b43/rfkill.h b/drivers/net/wireless/b43/rfkill.h
index adacf93..4efdb4a 100644
--- a/drivers/net/wireless/b43/rfkill.h
+++ b/drivers/net/wireless/b43/rfkill.h
@@ -13,8 +13,8 @@ struct b43_wldev;
 struct b43_rfkill {
 	/* The RFKILL subsystem data structure */
 	struct rfkill *rfkill;
-	/* The poll device for the RFKILL input button */
-	struct input_polled_dev *poll_dev;
+	/* The work queue for the RFKILL input button */
+	struct delayed_work work;
 	/* Did initialization succeed? Used for freeing. */
 	bool registered;
 	/* The unique name of this rfkill switch */


-- 
Matthew Garrett | mjg59 at srcf.ucam.org


From mb at bu3sch.de  Wed Dec 10 16:48:29 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 10 Dec 2008 16:48:29 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <20081210150935.GA10927@srcf.ucam.org>
References: <20081210150935.GA10927@srcf.ucam.org>
Message-ID: <200812101648.30161.mb@bu3sch.de>

On Wednesday 10 December 2008 16:09:35 Matthew Garrett wrote:
> I've reworked the rfkill code in b43. This ought to be more consistent 
...

I'm fine with this, as long as you take over the responsibility for the whole b43-rfkill code.
I'm not going to touch it anymore. I'm only going to fix it by either forwarding bugreports
to somebody else (you, in that case) or by reverting patches until it starts working again.

-- 
Greetings, Michael.


From johannes at sipsolutions.net  Wed Dec 10 16:29:57 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 10 Dec 2008 16:29:57 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <20081210150935.GA10927@srcf.ucam.org>
	(sfid-20081210_160955_698729_A777A57C)
References: <20081210150935.GA10927@srcf.ucam.org>
	(sfid-20081210_160955_698729_A777A57C)
Message-ID: <1228922997.15837.6.camel@johannes.berg>

On Wed, 2008-12-10 at 15:09 +0000, Matthew Garrett wrote:

> The final change is that I removed the code for changing the wireless 
> state in response to the txpower configuration in mac80211. Right now, I 
> can't see any way for this to work correctly - if the user disables the 
> radio via rfkill, mac80211 doesn't flag the radio as disabled. As a 
> result, the next time the configuration callback is called, b43 
> reenables the radio again, even though the user has explicitly disabled 
> it. I don't think any of the other drivers handle this case, so I'm not 
> really sure what the best way to handle this in future is. The current 
> situation certainly seems broken.

We're going to have to integrate rfkill with mac80211, but nobody cares.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081210/dc57d983/attachment.pgp>

From mjg59 at srcf.ucam.org  Wed Dec 10 17:12:59 2008
From: mjg59 at srcf.ucam.org (Matthew Garrett)
Date: Wed, 10 Dec 2008 16:12:59 +0000
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <200812101648.30161.mb@bu3sch.de>
References: <20081210150935.GA10927@srcf.ucam.org>
	<200812101648.30161.mb@bu3sch.de>
Message-ID: <20081210161259.GA12069@srcf.ucam.org>

On Wed, Dec 10, 2008 at 04:48:29PM +0100, Michael Buesch wrote:
> On Wednesday 10 December 2008 16:09:35 Matthew Garrett wrote:
> > I've reworked the rfkill code in b43. This ought to be more consistent 
> ...
> 
> I'm fine with this, as long as you take over the responsibility for the whole b43-rfkill code.
> I'm not going to touch it anymore. I'm only going to fix it by either forwarding bugreports
> to somebody else (you, in that case) or by reverting patches until it starts working again.

Works for me, though I'd appreciate it if people could give it a quick 
sanity test. The main thing I'm worried about is LED control, which I 
think /ought/ to still work but is dependent on everything in the rfkill 
core working properly.

-- 
Matthew Garrett | mjg59 at srcf.ucam.org


From Larry.Finger at lwfinger.net  Wed Dec 10 17:45:00 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 10 Dec 2008 10:45:00 -0600
Subject: [PATCH] b43legacy: Fix sparse warnings
In-Reply-To: <200812101133.54173.mb@bu3sch.de>
References: <493f552d.zivnzjivWDMPej+O%Larry.Finger@lwfinger.net>
	<200812101133.54173.mb@bu3sch.de>
Message-ID: <493FF20C.5070607@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 10 December 2008 06:35:41 Larry Finger wrote:
>>   CHECK   drivers/net/wireless/b43legacy/debugfs.c
>> drivers/net/wireless/b43legacy/debugfs.c:243:9: warning: memset with byte count of 131072
> 
> I know about this error and I think it's a damn stupid error.
> There is a reason why the value was so high in b43. I don't know about b43legacy.
> Did you check if all callbacks still work properly?

Yes. AFAIK, everything works correctly. BTW, I chose 16 KiB because that is the
number in b43, and I expected the two drivers to need about the same amount of
buffer space. Was that a bad assumption?

Larry


From johannes at sipsolutions.net  Wed Dec 10 18:18:49 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 10 Dec 2008 18:18:49 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <1228927898.19553.164.camel@violet.holtmann.net>
References: <20081210150935.GA10927@srcf.ucam.org>
	(sfid-20081210_160955_698729_A777A57C)
	<1228922997.15837.6.camel@johannes.berg>
	<1228927898.19553.164.camel@violet.holtmann.net>
Message-ID: <1228929529.15837.34.camel@johannes.berg>

[warning: this is going to be a long mail and will tell you why and how
I think rfkill needs to be rewritten]

On Wed, 2008-12-10 at 17:51 +0100, Marcel Holtmann wrote:

> if you figured out on how to do it the best way, then let me know,
> because I have to do the same thing for Bluetooth.

I'd suggest to start by rewriting rfkill to be not such a mess to use.

We really need to disentangle the state tracking rfkill does. People
have said this a million times before, but nobody cares: drivers need to
register hard-blocked and get soft-block states independently, not in a
single enum; API for drivers needs to be, above all, EASY to use.

For mac80211, we really need to register an rfkill structure for each
physical device that mac80211 knows about. Drivers would not be allowed
to get access to this structure, because the toggle_radio() callback is
assigned to a mac80211 function that calls the driver's ->config()
callback and, at some point, also disallows configuring interfaces that
belong to a device that is rfkilled.

To properly implement this, however, we need to disentangle rfkill
states and provide just a single API function to change the state:

rfkill_hw_kill(struct rfkill *rfkill, bool killed);

this would be shadowed by mac80211 with
	ieee80211_hw_rfkill(struct ieee80211_hw *hw, bool killed)
so mac80211 knows about hard-kills too, since they don't call
->toggle_radio() obviously.

I know what you're thinking at this point, but hear me out. This is
another thing where I think rfkill's design is fundamentally wrong. If
you're not thinking anything, hear me out anyway :)


Let's take a step back here and analyse what we really have and need:

 * we have devices with a plethora of rfkill setups:
   1) devices disappear from the bus (not handled here, not possible
      either)
   2) devices have hard kill button that just disables the radio
      (need to know about this so users aren't left in the dark)
   3) devices have soft kill buttons that just notify the driver
   4) soft kill switches that work through other input methods (ACPI
      comes to mind, but anything is possible)
 * we have various ways to kill the radio:
   1) like above
   2) through platform methods (toshiba ACPI I think?)
   3) through the driver only

The last two cases only differ in the radios that the button is supposed
to apply to, but this is more of a policy decision.

The point where I think rfkill's design is totally wrong is that it
intimately ties this software kill from case three to the rfkill
structure as well.

Instead, we should come to accept that this is just a button as well. A
button, however, that is *by default* tied to a particular radio.
Therefore, drivers for devices that provide such buttons, should, in my
opinion, register an rfkill button driver that
 a) by default is tied to their hardware by a pointer to the rfkill
    struct for the hardware, but this could be possible to override in
    sysfs like LEDs are, if you want the button to really kill all
    radios
 b) serves as input to the rfkill subsystem which will then look up the
    right rfkill struct(s) and ask them to kill the radio

This would add new API for a button, but again only a single function,
something like
	rfkill_button_update(struct rfkill_button *btn, bool killed)


Finally, rfkill-input will boil down to just registering a software
button that happens to control all radios by default, by setting the
controlled rfkill struct to NULL.


johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081210/19db8bec/attachment.pgp>

From johannes at sipsolutions.net  Wed Dec 10 18:23:40 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 10 Dec 2008 18:23:40 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <1228929529.15837.34.camel@johannes.berg>
	(sfid-20081210_181928_441073_38D73A3E)
References: <20081210150935.GA10927@srcf.ucam.org>
	(sfid-20081210_160955_698729_A777A57C)
	<1228922997.15837.6.camel@johannes.berg>
	<1228927898.19553.164.camel@violet.holtmann.net>
	<1228929529.15837.34.camel@johannes.berg>
	(sfid-20081210_181928_441073_38D73A3E)
Message-ID: <1228929820.15837.40.camel@johannes.berg>

On Wed, 2008-12-10 at 18:18 +0100, Johannes Berg wrote:

> We really need to disentangle the state tracking rfkill does. People
> have said this a million times before, but nobody cares: drivers need to
> register hard-blocked and get soft-block states independently, not in a
> single enum; API for drivers needs to be, above all, EASY to use.

Also, the rfkill struct itself is a mess. What's get_state() for? Why is
this not layered? How can get_state() work correctly, it doesn't poll
the device so it doesn't look like software will ever get a state
update.

Then there's user_claim_unsupported which is set by all drivers but
rt2x00, probably because they have hardware kill switches and thus they
have to set it even if it's not strictly true, because of the lacking
separation between these things (that I pointed out)

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081210/4e0e908e/attachment.pgp>

From johannes at sipsolutions.net  Wed Dec 10 18:28:03 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 10 Dec 2008 18:28:03 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <1228929820.15837.40.camel@johannes.berg>
	(sfid-20081210_182416_953060_7D937844)
References: <20081210150935.GA10927@srcf.ucam.org>
	(sfid-20081210_160955_698729_A777A57C)
	<1228922997.15837.6.camel@johannes.berg>
	<1228927898.19553.164.camel@violet.holtmann.net>
	<1228929529.15837.34.camel@johannes.berg>
	(sfid-20081210_181928_441073_38D73A3E)
	<1228929820.15837.40.camel@johannes.berg>
	(sfid-20081210_182416_953060_7D937844)
Message-ID: <1228930083.15837.44.camel@johannes.berg>

On Wed, 2008-12-10 at 18:23 +0100, Johannes Berg wrote:

> Then there's user_claim_unsupported which is set by all drivers but
> rt2x00, probably because they have hardware kill switches and thus they
> have to set it even if it's not strictly true, because of the lacking
> separation between these things (that I pointed out)

IOW, correct me if I'm wrong, it seems to me that user_claim_unsupported
really is a wrong name for "has hw kill", which could be avoided if sw
and hw kill were a different thing and the rfkill structure was only
used, as I'm proposing, for hw kill and sw kill _notifications_, but not
the sw kill operation itself.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081210/58c5d935/attachment.pgp>

From mb at bu3sch.de  Wed Dec 10 18:31:12 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 10 Dec 2008 18:31:12 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <1228929820.15837.40.camel@johannes.berg>
References: <20081210150935.GA10927@srcf.ucam.org>
	<1228929529.15837.34.camel@johannes.berg>
	<1228929820.15837.40.camel@johannes.berg>
Message-ID: <200812101831.13526.mb@bu3sch.de>

On Wednesday 10 December 2008 18:23:40 Johannes Berg wrote:
> Then there's user_claim_unsupported which is set by all drivers but
> rt2x00, probably because they have hardware kill switches and thus they
> have to set it even if it's not strictly true, because of the lacking
> separation between these things (that I pointed out)

I introduced it when I ported b43 to rfkill.
Well, a lot of semantical changes were made _after_ that.
When I added it there only were two rfkill states and b43 handled these wrt the
actual hardware state (and I still think that's the right thing to do. The sw-state intermix
is confusing).
So when I added the flag it meant:
user_claim_unsupported = True means user cannot change the hardware kill state.
So basically it means the device has two states. One software state and one hardware
state.
However, I don't know what the semantics for the flag are today. Lots of code changed.

-- 
Greetings, Michael.


From johannes at sipsolutions.net  Wed Dec 10 18:37:23 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 10 Dec 2008 18:37:23 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <200812101831.13526.mb@bu3sch.de>
References: <20081210150935.GA10927@srcf.ucam.org>
	<1228929529.15837.34.camel@johannes.berg>
	<1228929820.15837.40.camel@johannes.berg>
	<200812101831.13526.mb@bu3sch.de>
Message-ID: <1228930643.15837.48.camel@johannes.berg>

On Wed, 2008-12-10 at 18:31 +0100, Michael Buesch wrote:

> I introduced it when I ported b43 to rfkill.
> Well, a lot of semantical changes were made _after_ that.
> When I added it there only were two rfkill states and b43 handled these wrt the
> actual hardware state (and I still think that's the right thing to do. The sw-state intermix
> is confusing).

Right.

> So when I added the flag it meant:
> user_claim_unsupported = True means user cannot change the hardware kill state.

Yeah, but the assumption that software can change the "hardware kill
state" is rather stupid to start with, I think.

> So basically it means the device has two states. One software state and one hardware
> state.
> However, I don't know what the semantics for the flag are today. Lots of code changed.

Ok. I think the fundamental flaw here is assuming that there's just a
single state. There isn't. The device can be turned off in hardware (in
which case sw won't be able do anything about it, but we want to know)
or in software (which we want to handle). Pretending that there's just a
single state that's either hw-off, sw-off or on is plain wrong. The
device can be hw-off and sw-off at the same time, and then if you turn
off the hw-off button it won't turn on (however, unless your system
integrator totally screwed up, you won't have a hw and a sw button on
your system)

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081210/60cbfd87/attachment.pgp>

From mjg59 at srcf.ucam.org  Wed Dec 10 18:51:02 2008
From: mjg59 at srcf.ucam.org (Matthew Garrett)
Date: Wed, 10 Dec 2008 17:51:02 +0000
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <1228930643.15837.48.camel@johannes.berg>
References: <20081210150935.GA10927@srcf.ucam.org>
	<1228929529.15837.34.camel@johannes.berg>
	<1228929820.15837.40.camel@johannes.berg>
	<200812101831.13526.mb@bu3sch.de>
	<1228930643.15837.48.camel@johannes.berg>
Message-ID: <20081210175102.GA14282@srcf.ucam.org>

On Wed, Dec 10, 2008 at 06:37:23PM +0100, Johannes Berg wrote:

> Ok. I think the fundamental flaw here is assuming that there's just a
> single state. There isn't. The device can be turned off in hardware (in
> which case sw won't be able do anything about it, but we want to know)
> or in software (which we want to handle). Pretending that there's just a
> single state that's either hw-off, sw-off or on is plain wrong. The
> device can be hw-off and sw-off at the same time, and then if you turn
> off the hw-off button it won't turn on (however, unless your system
> integrator totally screwed up, you won't have a hw and a sw button on
> your system)

They may not be physical buttons, but we can often control this anyway. 
For instance, my HP has a button that will perform a hardware disable of 
the wifi card. However, I can control that button's state through 
software with the hp-wmi driver. The way we currently handle that (and, 
I think, the only way we *can* handle that) is to provide two separate 
rfkill interfaces - one tied to the wireless device, one tied to the 
platform device.

-- 
Matthew Garrett | mjg59 at srcf.ucam.org


From mb at bu3sch.de  Wed Dec 10 19:04:06 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 10 Dec 2008 19:04:06 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <20081210175102.GA14282@srcf.ucam.org>
References: <20081210150935.GA10927@srcf.ucam.org>
	<1228930643.15837.48.camel@johannes.berg>
	<20081210175102.GA14282@srcf.ucam.org>
Message-ID: <200812101904.07809.mb@bu3sch.de>

On Wednesday 10 December 2008 18:51:02 Matthew Garrett wrote:
> On Wed, Dec 10, 2008 at 06:37:23PM +0100, Johannes Berg wrote:
> 
> > Ok. I think the fundamental flaw here is assuming that there's just a
> > single state. There isn't. The device can be turned off in hardware (in
> > which case sw won't be able do anything about it, but we want to know)
> > or in software (which we want to handle). Pretending that there's just a
> > single state that's either hw-off, sw-off or on is plain wrong. The
> > device can be hw-off and sw-off at the same time, and then if you turn
> > off the hw-off button it won't turn on (however, unless your system
> > integrator totally screwed up, you won't have a hw and a sw button on
> > your system)
> 
> They may not be physical buttons, but we can often control this anyway. 

But we do not _want_ it.
If you can do it, keep it private to the driver. Do not export it to other layers.
If you need to to sw-rfkill through it, do it in the driver and multiplex
the hw-sw-states in the driver.

-- 
Greetings, Michael.


From johannes at sipsolutions.net  Wed Dec 10 19:05:43 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 10 Dec 2008 19:05:43 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <20081210175102.GA14282@srcf.ucam.org>
References: <20081210150935.GA10927@srcf.ucam.org>
	<1228929529.15837.34.camel@johannes.berg>
	<1228929820.15837.40.camel@johannes.berg>
	<200812101831.13526.mb@bu3sch.de>
	<1228930643.15837.48.camel@johannes.berg>
	<20081210175102.GA14282@srcf.ucam.org>
Message-ID: <1228932343.15837.57.camel@johannes.berg>

On Wed, 2008-12-10 at 17:51 +0000, Matthew Garrett wrote:

> They may not be physical buttons, but we can often control this anyway. 
> For instance, my HP has a button that will perform a hardware disable of 
> the wifi card. However, I can control that button's state through 
> software with the hp-wmi driver. 

That's indeed a complication I wasn't aware of.

> The way we currently handle that (and, 
> I think, the only way we *can* handle that) is to provide two separate 
> rfkill interfaces - one tied to the wireless device, one tied to the 
> platform device.

Yes, but how do we currently do this?

Does the wireless driver get the notification about this from the
hardware, like it would if this was a real physical switch? Then it's
probably pretty simple: provide a rfkill struct from the driver that
updates hard-kill and provide a second rfkill struct for the platform
device that doesn't get hard-killed, but also provide a soft-kill input
form the platform device. That way, you can toggle that button, but you
can also software-enable the platform rfkill device and that in turn
re-enables the wifi-rfkill "hw" switch device.

If we need to tie them together in software it gets more complicated
though.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081210/e57f62c9/attachment.pgp>

From mjg59 at srcf.ucam.org  Wed Dec 10 19:09:18 2008
From: mjg59 at srcf.ucam.org (Matthew Garrett)
Date: Wed, 10 Dec 2008 18:09:18 +0000
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <1228932343.15837.57.camel@johannes.berg>
References: <20081210150935.GA10927@srcf.ucam.org>
	<1228929529.15837.34.camel@johannes.berg>
	<1228929820.15837.40.camel@johannes.berg>
	<200812101831.13526.mb@bu3sch.de>
	<1228930643.15837.48.camel@johannes.berg>
	<20081210175102.GA14282@srcf.ucam.org>
	<1228932343.15837.57.camel@johannes.berg>
Message-ID: <20081210180918.GA14782@srcf.ucam.org>

On Wed, Dec 10, 2008 at 07:05:43PM +0100, Johannes Berg wrote:

> Does the wireless driver get the notification about this from the
> hardware, like it would if this was a real physical switch?

Yes.

> Then it's probably pretty simple: provide a rfkill struct from the 
> driver that updates hard-kill and provide a second rfkill struct for 
> the platform device that doesn't get hard-killed, but also provide a 
> soft-kill input form the platform device. That way, you can toggle 
> that button, but you can also software-enable the platform rfkill 
> device and that in turn re-enables the wifi-rfkill "hw" switch device.

Right. That's prety close to the current situation.
 
> If we need to tie them together in software it gets more complicated
> though.

I think we can avoid that, thankfully.

-- 
Matthew Garrett | mjg59 at srcf.ucam.org


From johannes at sipsolutions.net  Wed Dec 10 19:33:59 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 10 Dec 2008 19:33:59 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <1228933790.28590.29.camel@localhost.localdomain>
References: <20081210150935.GA10927@srcf.ucam.org>
	<1228929529.15837.34.camel@johannes.berg>
	<1228929820.15837.40.camel@johannes.berg>
	<200812101831.13526.mb@bu3sch.de>
	<1228930643.15837.48.camel@johannes.berg>
	<20081210175102.GA14282@srcf.ucam.org>
	<1228932343.15837.57.camel@johannes.berg>
	<1228933790.28590.29.camel@localhost.localdomain>
Message-ID: <1228934039.15837.59.camel@johannes.berg>

On Wed, 2008-12-10 at 13:29 -0500, Dan Williams wrote:

> > Does the wireless driver get the notification about this from the
> > hardware, like it would if this was a real physical switch? Then it's
> > probably pretty simple: provide a rfkill struct from the driver that
> > updates hard-kill and provide a second rfkill struct for the platform
> > device that doesn't get hard-killed, but also provide a soft-kill input
> > form the platform device. That way, you can toggle that button, but you
> > can also software-enable the platform rfkill device and that in turn
> > re-enables the wifi-rfkill "hw" switch device.
> 
> This sort of sucks for userspace, because we see the actual wifi card as
> hardblocked, but some other random button as softblocked.  There's no
> indication that changing the softblock one will affect the hardblocked
> one.  What are userspace processes supposed to do here, assume that if a
> non-radio-associated softblocked switch exists, that it can re-enable a
> hardblocked radio of some random wifi card?

The other question is whether we actually care? So what if the hardware
can only be enabled with the button, why does that matter?

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081210/9e160ee9/attachment.pgp>

From mb at bu3sch.de  Wed Dec 10 21:07:08 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 10 Dec 2008 21:07:08 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <1228933790.28590.29.camel@localhost.localdomain>
References: <20081210150935.GA10927@srcf.ucam.org>
	<1228932343.15837.57.camel@johannes.berg>
	<1228933790.28590.29.camel@localhost.localdomain>
Message-ID: <200812102107.09568.mb@bu3sch.de>

On Wednesday 10 December 2008 19:29:50 Dan Williams wrote:
> On Wed, 2008-12-10 at 19:05 +0100, Johannes Berg wrote:
> > On Wed, 2008-12-10 at 17:51 +0000, Matthew Garrett wrote:
> > 
> > > They may not be physical buttons, but we can often control this anyway. 
> > > For instance, my HP has a button that will perform a hardware disable of 
> > > the wifi card. However, I can control that button's state through 
> > > software with the hp-wmi driver. 
> > 
> > That's indeed a complication I wasn't aware of.
> > 
> > > The way we currently handle that (and, 
> > > I think, the only way we *can* handle that) is to provide two separate 
> > > rfkill interfaces - one tied to the wireless device, one tied to the 
> > > platform device.
> > 
> > Yes, but how do we currently do this?
> > 
> > Does the wireless driver get the notification about this from the
> > hardware, like it would if this was a real physical switch? Then it's
> > probably pretty simple: provide a rfkill struct from the driver that
> > updates hard-kill and provide a second rfkill struct for the platform
> > device that doesn't get hard-killed, but also provide a soft-kill input
> > form the platform device. That way, you can toggle that button, but you
> > can also software-enable the platform rfkill device and that in turn
> > re-enables the wifi-rfkill "hw" switch device.
> 
> This sort of sucks for userspace, because we see the actual wifi card as
> hardblocked, but some other random button as softblocked.  There's no
> indication that changing the softblock one will affect the hardblocked
> one.  What are userspace processes supposed to do here, assume that if a
> non-radio-associated softblocked switch exists, that it can re-enable a
> hardblocked radio of some random wifi card?

I don't see the problem.
If userspace wants to enable wifi, it should simply _try_ to do so:
Userspace sees hw-block and sw-block state:
- Unblock the sw state
- Re-fetch hw-block and sw-block state
- If either one is blocked, we can't enable the radio.
- Notify user.

-- 
Greetings, Michael.


From mb at bu3sch.de  Wed Dec 10 22:42:33 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 10 Dec 2008 22:42:33 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <20081210213334.GA7589@khazad-dum.debian.net>
References: <20081210150935.GA10927@srcf.ucam.org>
	<1228930083.15837.44.camel@johannes.berg>
	<20081210213334.GA7589@khazad-dum.debian.net>
Message-ID: <200812102242.35995.mb@bu3sch.de>

On Wednesday 10 December 2008 22:33:34 Henrique de Moraes Holschuh wrote:
> On Wed, 10 Dec 2008, Johannes Berg wrote:
> > On Wed, 2008-12-10 at 18:23 +0100, Johannes Berg wrote:
> > > Then there's user_claim_unsupported which is set by all drivers but
> > > rt2x00, probably because they have hardware kill switches and thus they
> > > have to set it even if it's not strictly true, because of the lacking
> > > separation between these things (that I pointed out)
> > 
> > IOW, correct me if I'm wrong, it seems to me that user_claim_unsupported
> > really is a wrong name for "has hw kill", which could be avoided if sw
> 
> I never understood what user_claim_unsupported is for.  I left it alone
> because of that, but it looks like some artifact of the old rfkill that did
> horrible things to the input layer.

No, as I just explained. It comes from a time when we didn't have all that input stuff at all.
It was a workaround. rfkill basically had a facility to change the hardware rfkill state from
userspace. As b43 does not support that, I introduced the flag.
Today we have three states (which is still broken, but you saw the rest of the thread...), so I guess
we can remove it again.
We cannot change the hardware state. That's what the flag is (was) for.

-- 
Greetings, Michael.


From mb at bu3sch.de  Thu Dec 11 02:27:25 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 11 Dec 2008 02:27:25 +0100
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <646765f40812101632u76847935l2405482aabe1c1f8@mail.gmail.com>
References: <20081210150935.GA10927@srcf.ucam.org>
	<1228922997.15837.6.camel@johannes.berg>
	<646765f40812101632u76847935l2405482aabe1c1f8@mail.gmail.com>
Message-ID: <200812110227.26909.mb@bu3sch.de>

On Thursday 11 December 2008 01:32:37 Julian Calaby wrote:
> On Thu, Dec 11, 2008 at 02:29, Johannes Berg <johannes at sipsolutions.net> wrote:
> > On Wed, 2008-12-10 at 15:09 +0000, Matthew Garrett wrote:
> >
> >> The final change is that I removed the code for changing the wireless
> >> state in response to the txpower configuration in mac80211. Right now, I
> >> can't see any way for this to work correctly - if the user disables the
> >> radio via rfkill, mac80211 doesn't flag the radio as disabled. As a
> >> result, the next time the configuration callback is called, b43
> >> reenables the radio again, even though the user has explicitly disabled
> >> it. I don't think any of the other drivers handle this case, so I'm not
> >> really sure what the best way to handle this in future is. The current
> >> situation certainly seems broken.
> >
> > We're going to have to integrate rfkill with mac80211, but nobody cares.
> 
> What strikes me, watching this from the outside - is that rfkill and
> power saving seem to be doing essentially the same thing: temporarily
> powering down the radio / card.

I think it's essentially a different thing.
rfkill means -> turn off the radio; no matter what.
PS means -> turn off the radio for whatever amount of microseconds and periodically
wake up to see what's up.
PS-core also takes place in the firmware of the device, where rfkill is a much higher layer thing.

-- 
Greetings, Michael.


From rooot at v-lo.krakow.pl  Thu Dec 11 18:17:32 2008
From: rooot at v-lo.krakow.pl (=?ISO-8859-1?Q?=3Fukasz_Marsza=3F?=)
Date: Thu, 11 Dec 2008 17:17:32 +0000
Subject: BCM4310 driver status
Message-ID: <49414B2C.7060909@v-lo.krakow.pl>

I want to ask about the status of b43 driver for BCM4310 chipset wifi
card. I read the message from this list, from September 2008, in which
it had been written, that you are "just finishing rervese-engeenering".
If the documentation is finished I can give you some support in
programming or betatesting new driver.

Sincerely,
Lukasz Marszal


From Larry.Finger at lwfinger.net  Thu Dec 11 17:29:48 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 11 Dec 2008 10:29:48 -0600
Subject: BCM4310 driver status
In-Reply-To: <49414B2C.7060909@v-lo.krakow.pl>
References: <49414B2C.7060909@v-lo.krakow.pl>
Message-ID: <49413FFC.3070808@lwfinger.net>

?ukasz Marsza? wrote:
> I want to ask about the status of b43 driver for BCM4310 chipset wifi
> card. I read the message from this list, from September 2008, in which
> it had been written, that you are "just finishing rervese-engeenering".
> If the documentation is finished I can give you some support in
> programming or betatesting new driver.

Unfortunately, I have not done much with the reverse engineering is the past few
months. We don't have the specs yet, and I don't know when it will happen. This
kind of decompilation is very tedious, and I have not been in the right frame of
mind for it.

Larry


From Larry.Finger at lwfinger.net  Thu Dec 11 17:55:42 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 11 Dec 2008 10:55:42 -0600
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <20081210150935.GA10927@srcf.ucam.org>
References: <20081210150935.GA10927@srcf.ucam.org>
Message-ID: <4941460E.9000506@lwfinger.net>

Matthew Garrett wrote:
> I've reworked the rfkill code in b43. This ought to be more consistent 
> with the other drivers and it seems to work on the machines I've tested 
> it on here, but it'd be good to get some feedback.
> 
> Firstly, I've replaced the polled input device. It's just some delayed 
> work now. It polls the hardware every second to determine whether the 
> radio has been hardware killed or not. If it has, it sets the rfkill 
> state to HARD_BLOCKED. If the radio is enabled and the previous state 
> was HARD_BLOCKED, it resets the state to UNBLOCKED. If the radio is 
> enabled and the previous state was SOFT_BLOCKED, it leaves the state as 
> is.
> 
> I also removed some of the complexity from the rfkill toggle function, 
> since the rfkill core will handle the case of the user requesting a 
> change from HARD_BLOCKED without the driver needing to care.
> 
> The final change is that I removed the code for changing the wireless 
> state in response to the txpower configuration in mac80211. Right now, I 
> can't see any way for this to work correctly - if the user disables the 
> radio via rfkill, mac80211 doesn't flag the radio as disabled. As a 
> result, the next time the configuration callback is called, b43 
> reenables the radio again, even though the user has explicitly disabled 
> it. I don't think any of the other drivers handle this case, so I'm not 
> really sure what the best way to handle this in future is. The current 
> situation certainly seems broken.
> 
> How does this look to people?

All this discussion about hard vs soft rfkill makes my head hurt and I have
stopped reading those posts.

With this patch, my b43 device and its LED still work.

Larry





From Larry.Finger at lwfinger.net  Fri Dec 12 05:28:19 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 11 Dec 2008 22:28:19 -0600
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <20081210150935.GA10927@srcf.ucam.org>
References: <20081210150935.GA10927@srcf.ucam.org>
Message-ID: <4941E863.50703@lwfinger.net>

Matthew Garrett wrote:
> I've reworked the rfkill code in b43. This ought to be more consistent 
> with the other drivers and it seems to work on the machines I've tested 
> it on here, but it'd be good to get some feedback.
> 
> Firstly, I've replaced the polled input device. It's just some delayed 
> work now. It polls the hardware every second to determine whether the 
> radio has been hardware killed or not. If it has, it sets the rfkill 
> state to HARD_BLOCKED. If the radio is enabled and the previous state 
> was HARD_BLOCKED, it resets the state to UNBLOCKED. If the radio is 
> enabled and the previous state was SOFT_BLOCKED, it leaves the state as 
> is.
> 
> I also removed some of the complexity from the rfkill toggle function, 
> since the rfkill core will handle the case of the user requesting a 
> change from HARD_BLOCKED without the driver needing to care.
> 
> The final change is that I removed the code for changing the wireless 
> state in response to the txpower configuration in mac80211. Right now, I 
> can't see any way for this to work correctly - if the user disables the 
> radio via rfkill, mac80211 doesn't flag the radio as disabled. As a 
> result, the next time the configuration callback is called, b43 
> reenables the radio again, even though the user has explicitly disabled 
> it. I don't think any of the other drivers handle this case, so I'm not 
> really sure what the best way to handle this in future is. The current 
> situation certainly seems broken.
> 
> How does this look to people?

All this discussion about hard vs soft rfkill makes my head hurt and I have
stopped reading those posts.

Correction to my earlier post. If the system is booted with the RF switch off,
the LED is on, whereas it should be off. The original code works correctly.

Larry






From mmazur at kernel.pl  Wed Dec 17 08:39:44 2008
From: mmazur at kernel.pl (Mariusz Mazur)
Date: Wed, 17 Dec 2008 08:39:44 +0100
Subject: 4311 drops outgoing traffic
In-Reply-To: <200811301354.28679.mmazur@kernel.pl>
References: <200811301354.28679.mmazur@kernel.pl>
Message-ID: <200812170839.45074.mmazur@kernel.pl>

---snip---

nohwcrypt=1 made the problem go away

-- 
Judge others by their intentions and yourself by your results.
                                                                 Guy Kawasaki
Education is an admirable thing, but it is well to remember from
time to time that nothing that is worth knowing can be taught.
                                                                  Oscar Wilde


From linville at tuxdriver.com  Wed Dec 17 16:48:01 2008
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 17 Dec 2008 10:48:01 -0500
Subject: [RFC] b43: rework rfkill code
In-Reply-To: <4941E863.50703@lwfinger.net>
References: <20081210150935.GA10927@srcf.ucam.org>
	<4941E863.50703@lwfinger.net>
Message-ID: <20081217154800.GA12679@tuxdriver.com>

On Thu, Dec 11, 2008 at 10:28:19PM -0600, Larry Finger wrote:
> Matthew Garrett wrote:
> > I've reworked the rfkill code in b43. This ought to be more consistent 
> > with the other drivers and it seems to work on the machines I've tested 
> > it on here, but it'd be good to get some feedback.

<snip>

> > How does this look to people?
> 
> All this discussion about hard vs soft rfkill makes my head hurt and I have
> stopped reading those posts.
> 
> Correction to my earlier post. If the system is booted with the RF switch off,
> the LED is on, whereas it should be off. The original code works correctly.

Based on the above, I'm dropping this patch.  Please submit a
non-regressing version! :-)

John
-- 
John W. Linville		Linux should be at the core
linville at tuxdriver.com			of your literate lifestyle.


From markryde at gmail.com  Thu Dec 18 16:11:46 2008
From: markryde at gmail.com (Mark Ryden)
Date: Thu, 18 Dec 2008 17:11:46 +0200
Subject: Power saving mode in Bcm43 driver
In-Reply-To: <200812021541.04610.mb@bu3sch.de>
References: <dac45060812020115m6eb2ae4bya5f3280d1db79bb6@mail.gmail.com>
	<200812021541.04610.mb@bu3sch.de>
Message-ID: <dac45060812180711r40f19b9et5137a77006d4e4f6@mail.gmail.com>

Hello,

Regarding on b43 drive:
As I understand, the b43 does not support power saving mode because of
some hw limitation.

Does anybody know: is there any attention to add
such a feature in hw in the near (or not so near) future ?
Rgs,
MarkR

On Tue, Dec 2, 2008 at 4:41 PM, Michael Buesch <mb at bu3sch.de> wrote:
> On Tuesday 02 December 2008 10:15:17 Mark Ryden wrote:
>>  As far as I know, this driver
>> does support power saving mode.
> No
>


From mb at bu3sch.de  Thu Dec 18 16:34:53 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 18 Dec 2008 16:34:53 +0100
Subject: Power saving mode in Bcm43 driver
In-Reply-To: <dac45060812180711r40f19b9et5137a77006d4e4f6@mail.gmail.com>
References: <dac45060812020115m6eb2ae4bya5f3280d1db79bb6@mail.gmail.com>
	<200812021541.04610.mb@bu3sch.de>
	<dac45060812180711r40f19b9et5137a77006d4e4f6@mail.gmail.com>
Message-ID: <200812181634.53698.mb@bu3sch.de>

On Thursday 18 December 2008 16:11:46 Mark Ryden wrote:
> Hello,
> 
> Regarding on b43 drive:
> As I understand, the b43 does not support power saving mode because of
> some hw limitation.

It's not implemented in the driver.

> Does anybody know: is there any attention to add
> such a feature in hw in the near (or not so near) future ?

not planned.

-- 
Greetings, Michael.


From markryde at gmail.com  Thu Dec 18 17:55:40 2008
From: markryde at gmail.com (Mark Ryden)
Date: Thu, 18 Dec 2008 18:55:40 +0200
Subject: Power saving mode in Bcm43 driver
In-Reply-To: <200812181634.53698.mb@bu3sch.de>
References: <dac45060812020115m6eb2ae4bya5f3280d1db79bb6@mail.gmail.com>
	<200812021541.04610.mb@bu3sch.de>
	<dac45060812180711r40f19b9et5137a77006d4e4f6@mail.gmail.com>
	<200812181634.53698.mb@bu3sch.de>
Message-ID: <dac45060812180855y26a9ce34g5957533cacf03253@mail.gmail.com>

Thanks,
>It's not implemented in the driver.
You mean It's not implemented in the driver firmware , as I understand
? (I suppose it cannot be implemented not in firmware in the driver)
Mark

On Thu, Dec 18, 2008 at 5:34 PM, Michael Buesch <mb at bu3sch.de> wrote:
> On Thursday 18 December 2008 16:11:46 Mark Ryden wrote:
>> Hello,
>>
>> Regarding on b43 drive:
>> As I understand, the b43 does not support power saving mode because of
>> some hw limitation.
>
> It's not implemented in the driver.
>
>> Does anybody know: is there any attention to add
>> such a feature in hw in the near (or not so near) future ?
>
> not planned.
>
> --
> Greetings, Michael.
>


From mb at bu3sch.de  Thu Dec 18 18:29:44 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 18 Dec 2008 18:29:44 +0100
Subject: Power saving mode in Bcm43 driver
In-Reply-To: <dac45060812180855y26a9ce34g5957533cacf03253@mail.gmail.com>
References: <dac45060812020115m6eb2ae4bya5f3280d1db79bb6@mail.gmail.com>
	<200812181634.53698.mb@bu3sch.de>
	<dac45060812180855y26a9ce34g5957533cacf03253@mail.gmail.com>
Message-ID: <200812181829.44814.mb@bu3sch.de>

On Thursday 18 December 2008 17:55:40 Mark Ryden wrote:
> >It's not implemented in the driver.
> You mean It's not implemented in the driver firmware , as I understand

It means what I wrote.

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Thu Dec 18 18:50:07 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 18 Dec 2008 11:50:07 -0600
Subject: Power saving mode in Bcm43 driver
In-Reply-To: <200812181829.44814.mb@bu3sch.de>
References: <dac45060812020115m6eb2ae4bya5f3280d1db79bb6@mail.gmail.com>	<200812181634.53698.mb@bu3sch.de>	<dac45060812180855y26a9ce34g5957533cacf03253@mail.gmail.com>
	<200812181829.44814.mb@bu3sch.de>
Message-ID: <494A8D4F.1080906@lwfinger.net>

Michael Buesch wrote:
> On Thursday 18 December 2008 17:55:40 Mark Ryden wrote:
>>> It's not implemented in the driver.
>> You mean It's not implemented in the driver firmware , as I understand
> 
> It means what I wrote.

Firmware is firmware.

Driver is driver.

Never forget that Michael knows the difference


From netrolller.3d at gmail.com  Thu Dec 18 18:57:18 2008
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?Stefanik_G=E1bor?=)
Date: Thu, 18 Dec 2008 18:57:18 +0100
Subject: Power saving mode in Bcm43 driver
In-Reply-To: <dac45060812180855y26a9ce34g5957533cacf03253@mail.gmail.com>
References: <dac45060812020115m6eb2ae4bya5f3280d1db79bb6@mail.gmail.com>
	<200812021541.04610.mb@bu3sch.de>
	<dac45060812180711r40f19b9et5137a77006d4e4f6@mail.gmail.com>
	<200812181634.53698.mb@bu3sch.de>
	<dac45060812180855y26a9ce34g5957533cacf03253@mail.gmail.com>
Message-ID: <69e28c910812180957r3f4bb0f1i21e09e7ca315aac@mail.gmail.com>

On Thu, Dec 18, 2008 at 5:55 PM, Mark Ryden <markryde at gmail.com> wrote:
> Thanks,
>>It's not implemented in the driver.
> You mean It's not implemented in the driver firmware , as I understand
> ? (I suppose it cannot be implemented not in firmware in the driver)
> Mark

It's not implemented in the driver, the open-source part of it (both
the hardware and the closed-source firmware have the necessary
features, just the driver doesn't make use of them). It could be, just
no one has done so yet,

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Thu Dec 18 22:13:39 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 18 Dec 2008 22:13:39 +0100
Subject: [PATCH] b43: Fix some MAC locking
Message-ID: <200812182213.39260.mb@bu3sch.de>

This fixes some locking w.r.t. the lower MAC (firmware).
It also removes a lot of ancient IRQ-locking that's not needed anymore.
We simply suspend the MAC. That's easier and causes less trouble.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

-- 

Stuff for the next feature release.


Index: wireless-testing/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/main.c	2008-11-05 23:02:57.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/main.c	2008-12-18 21:43:50.000000000 +0100
@@ -3321,41 +3321,30 @@ static int b43_op_config(struct ieee8021
 	struct b43_wldev *dev;
 	struct b43_phy *phy;
 	struct ieee80211_conf *conf = &hw->conf;
 	unsigned long flags;
 	int antenna;
 	int err = 0;
-	u32 savedirqs;
 
 	mutex_lock(&wl->mutex);
 
 	/* Switch the band (if necessary). This might change the active core. */
 	err = b43_switch_band(wl, conf->channel);
 	if (err)
 		goto out_unlock_mutex;
 	dev = wl->current_dev;
 	phy = &dev->phy;
 
+	b43_mac_suspend(dev);
+
 	if (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS)
 		b43_set_retry_limits(dev, conf->short_frame_max_tx_count,
 					  conf->long_frame_max_tx_count);
 	changed &= ~IEEE80211_CONF_CHANGE_RETRY_LIMITS;
 	if (!changed)
-		goto out_unlock_mutex;
-
-	/* Disable IRQs while reconfiguring the device.
-	 * This makes it possible to drop the spinlock throughout
-	 * the reconfiguration process. */
-	spin_lock_irqsave(&wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_STARTED) {
-		spin_unlock_irqrestore(&wl->irq_lock, flags);
-		goto out_unlock_mutex;
-	}
-	savedirqs = b43_interrupt_disable(dev, B43_IRQ_ALL);
-	spin_unlock_irqrestore(&wl->irq_lock, flags);
-	b43_synchronize_irq(dev);
+		goto out_mac_enable;
 
 	/* Switch to the requested channel.
 	 * The firmware takes care of races with the TX handler. */
 	if (conf->channel->hw_value != phy->channel)
 		b43_switch_channel(dev, conf->channel->hw_value);
 
@@ -3396,17 +3385,15 @@ static int b43_op_config(struct ieee8021
 		} else {
 			b43_software_rfkill(dev, RFKILL_STATE_SOFT_BLOCKED);
 			b43info(dev->wl, "Radio turned off by software\n");
 		}
 	}
 
-	spin_lock_irqsave(&wl->irq_lock, flags);
-	b43_interrupt_enable(dev, savedirqs);
-	mmiowb();
-	spin_unlock_irqrestore(&wl->irq_lock, flags);
-      out_unlock_mutex:
+out_mac_enable:
+	b43_mac_enable(dev);
+out_unlock_mutex:
 	mutex_unlock(&wl->mutex);
 
 	return err;
 }
 
 static void b43_update_basic_rates(struct b43_wldev *dev, u64 brates)
@@ -3458,33 +3445,18 @@ static void b43_op_bss_info_changed(stru
 				    struct ieee80211_vif *vif,
 				    struct ieee80211_bss_conf *conf,
 				    u32 changed)
 {
 	struct b43_wl *wl = hw_to_b43_wl(hw);
 	struct b43_wldev *dev;
-	struct b43_phy *phy;
-	unsigned long flags;
-	u32 savedirqs;
 
 	mutex_lock(&wl->mutex);
 
 	dev = wl->current_dev;
-	phy = &dev->phy;
-
-	/* Disable IRQs while reconfiguring the device.
-	 * This makes it possible to drop the spinlock throughout
-	 * the reconfiguration process. */
-	spin_lock_irqsave(&wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_STARTED) {
-		spin_unlock_irqrestore(&wl->irq_lock, flags);
+	if (!dev || b43_status(dev) < B43_STAT_STARTED)
 		goto out_unlock_mutex;
-	}
-	savedirqs = b43_interrupt_disable(dev, B43_IRQ_ALL);
-	spin_unlock_irqrestore(&wl->irq_lock, flags);
-	b43_synchronize_irq(dev);
-
 	b43_mac_suspend(dev);
 
 	if (changed & BSS_CHANGED_BASIC_RATES)
 		b43_update_basic_rates(dev, conf->basic_rates);
 
 	if (changed & BSS_CHANGED_ERP_SLOT) {
@@ -3492,19 +3464,13 @@ static void b43_op_bss_info_changed(stru
 			b43_short_slot_timing_enable(dev);
 		else
 			b43_short_slot_timing_disable(dev);
 	}
 
 	b43_mac_enable(dev);
-
-	spin_lock_irqsave(&wl->irq_lock, flags);
-	b43_interrupt_enable(dev, savedirqs);
-	/* XXX: why? */
-	mmiowb();
-	spin_unlock_irqrestore(&wl->irq_lock, flags);
- out_unlock_mutex:
+out_unlock_mutex:
 	mutex_unlock(&wl->mutex);
 
 	return;
 }
 
 static int b43_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
Index: wireless-testing/drivers/net/wireless/b43/phy_g.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_g.c	2008-09-26 22:51:28.000000000 +0200
+++ wireless-testing/drivers/net/wireless/b43/phy_g.c	2008-12-18 21:49:12.000000000 +0100
@@ -3044,12 +3044,14 @@ static void b43_gphy_op_adjust_txpower(s
 {
 	struct b43_phy *phy = &dev->phy;
 	struct b43_phy_g *gphy = phy->g;
 	int rfatt, bbatt;
 	u8 tx_control;
 
+	b43_mac_suspend(dev);
+
 	spin_lock_irq(&dev->wl->irq_lock);
 
 	/* Calculate the new attenuation values. */
 	bbatt = gphy->bbatt.att;
 	bbatt += gphy->bbatt_delta;
 	rfatt = gphy->rfatt.att;
@@ -3100,12 +3102,14 @@ static void b43_gphy_op_adjust_txpower(s
 	b43_phy_lock(dev);
 	b43_radio_lock(dev);
 	b43_set_txpower_g(dev, &gphy->bbatt, &gphy->rfatt,
 			  gphy->tx_control);
 	b43_radio_unlock(dev);
 	b43_phy_unlock(dev);
+
+	b43_mac_enable(dev);
 }
 
 static enum b43_txpwr_result b43_gphy_op_recalc_txpower(struct b43_wldev *dev,
 							bool ignore_tssi)
 {
 	struct b43_phy *phy = &dev->phy;
@@ -3212,30 +3216,30 @@ no_adjustment_needed:
 
 static void b43_gphy_op_pwork_15sec(struct b43_wldev *dev)
 {
 	struct b43_phy *phy = &dev->phy;
 	struct b43_phy_g *gphy = phy->g;
 
+	b43_mac_suspend(dev);
 	//TODO: update_aci_moving_average
 	if (gphy->aci_enable && gphy->aci_wlan_automatic) {
-		b43_mac_suspend(dev);
 		if (!gphy->aci_enable && 1 /*TODO: not scanning? */ ) {
 			if (0 /*TODO: bunch of conditions */ ) {
 				phy->ops->interf_mitigation(dev,
 					B43_INTERFMODE_MANUALWLAN);
 			}
 		} else if (0 /*TODO*/) {
 			   if (/*(aci_average > 1000) &&*/ !b43_gphy_aci_scan(dev))
 				phy->ops->interf_mitigation(dev, B43_INTERFMODE_NONE);
 		}
-		b43_mac_enable(dev);
 	} else if (gphy->interfmode == B43_INTERFMODE_NONWLAN &&
 		   phy->rev == 1) {
 		//TODO: implement rev1 workaround
 	}
 	b43_lo_g_maintanance_work(dev);
+	b43_mac_enable(dev);
 }
 
 static void b43_gphy_op_pwork_60sec(struct b43_wldev *dev)
 {
 	struct b43_phy *phy = &dev->phy;
 
Index: wireless-testing/drivers/net/wireless/b43/phy_common.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_common.c	2008-10-11 16:13:24.000000000 +0200
+++ wireless-testing/drivers/net/wireless/b43/phy_common.c	2008-12-18 21:52:28.000000000 +0100
@@ -175,19 +175,33 @@ void b43_phy_unlock(struct b43_wldev *de
 	B43_WARN_ON(dev->dev->id.revision < 3);
 
 	if (!b43_is_mode(dev->wl, NL80211_IFTYPE_AP))
 		b43_power_saving_ctl_bits(dev, 0);
 }
 
+static inline void assert_mac_suspended(struct b43_wldev *dev)
+{
+	if (!B43_DEBUG)
+		return;
+	if ((b43_status(dev) >= B43_STAT_INITIALIZED) &&
+	    (dev->mac_suspended <= 0)) {
+		b43dbg(dev->wl, "PHY/RADIO register access with "
+		       "enabled MAC.\n");
+		dump_stack();
+	}
+}
+
 u16 b43_radio_read(struct b43_wldev *dev, u16 reg)
 {
+	assert_mac_suspended(dev);
 	return dev->phy.ops->radio_read(dev, reg);
 }
 
 void b43_radio_write(struct b43_wldev *dev, u16 reg, u16 value)
 {
+	assert_mac_suspended(dev);
 	dev->phy.ops->radio_write(dev, reg, value);
 }
 
 void b43_radio_mask(struct b43_wldev *dev, u16 offset, u16 mask)
 {
 	b43_radio_write16(dev, offset,
@@ -205,17 +219,19 @@ void b43_radio_maskset(struct b43_wldev 
 	b43_radio_write16(dev, offset,
 			  (b43_radio_read16(dev, offset) & mask) | set);
 }
 
 u16 b43_phy_read(struct b43_wldev *dev, u16 reg)
 {
+	assert_mac_suspended(dev);
 	return dev->phy.ops->phy_read(dev, reg);
 }
 
 void b43_phy_write(struct b43_wldev *dev, u16 reg, u16 value)
 {
+	assert_mac_suspended(dev);
 	dev->phy.ops->phy_write(dev, reg, value);
 }
 
 void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
 {
 	b43_phy_write(dev, offset,

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Fri Dec 19 16:39:23 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 19 Dec 2008 09:39:23 -0600
Subject: [PATCH] b43: Fix some MAC locking
In-Reply-To: <200812182213.39260.mb@bu3sch.de>
References: <200812182213.39260.mb@bu3sch.de>
Message-ID: <494BC02B.4000906@lwfinger.net>

Michael Buesch wrote:
> This fixes some locking w.r.t. the lower MAC (firmware).
> It also removes a lot of ancient IRQ-locking that's not needed anymore.
> We simply suspend the MAC. That's easier and causes less trouble.

When booting with this patch and the RFKILL switch off, I got these b43dbg messages:

kernel: b43-phy0 debug: PHY/RADIO register access with enabled MAC.
kernel: Pid: 7, comm: events/0 Not tainted 2.6.28-rc8-wl #55
kernel: Call Trace:
kernel:  [<ffffffffa02d6b15>] b43_phy_read+0x33/0x46 [b43]
kernel:  [<ffffffffa02d8350>] b43_gphy_op_software_rfkill+0xde/0x131 [b43]
kernel:  [<ffffffffa02d66d8>] b43_software_rfkill+0x20/0x2d [b43]
kernel:  [<ffffffffa02e5609>] b43_rfkill_soft_toggle+0x71/0xa8 [b43]
kernel:  [<ffffffffa02c61c0>] rfkill_toggle_radio+0xc6/0x10e [rfkill]
kernel:  [<ffffffffa02c681d>] __rfkill_switch_all+0x6c/0xbb [rfkill]
kernel:  [<ffffffffa02c68e5>] rfkill_switch_all+0x2d/0x3e [rfkill]
kernel:  [<ffffffffa04bc165>] rfkill_task_handler+0x165/0x1ae [rfkill_input]
kernel:  [<ffffffff8024ac90>] run_workqueue+0x103/0x20a
kernel:  [<ffffffff8024ac3e>] ? run_workqueue+0xb1/0x20a
kernel:  [<ffffffffa04bc000>] ? rfkill_task_handler+0x0/0x1ae [rfkill_input]
kernel:  [<ffffffff8024ae77>] worker_thread+0xe0/0xf1
kernel:  [<ffffffff8024e9fc>] ? autoremove_wake_function+0x0/0x38
kernel:  [<ffffffff8024ad97>] ? worker_thread+0x0/0xf1
kernel:  [<ffffffff8024e6a0>] kthread+0x49/0x76
kernel:  [<ffffffff8020d0d9>] child_rip+0xa/0x11
kernel:  [<ffffffff80236bd4>] ? finish_task_switch+0x0/0xb9
kernel:  [<ffffffff8020c5f4>] ? restore_args+0x0/0x30


kernel: b43-phy0 debug: PHY/RADIO register access with enabled MAC.
kernel: Pid: 7, comm: events/0 Not tainted 2.6.28-rc8-wl #55
kernel: Call Trace:
kernel:  [<ffffffffa02d6f93>] ? b43_gphy_op_read+0x2b/0x2f [b43]
kernel:  [<ffffffffa02d6b15>] b43_phy_read+0x33/0x46 [b43]
kernel:  [<ffffffffa02d835f>] b43_gphy_op_software_rfkill+0xed/0x131 [b43]
kernel:  [<ffffffffa02d66d8>] b43_software_rfkill+0x20/0x2d [b43]
...

kernel: b43-phy0 debug: PHY/RADIO register access with enabled MAC.
kernel: Pid: 7, comm: events/0 Not tainted 2.6.28-rc8-wl #55
kernel: Call Trace:
kernel:  [<ffffffffa02d6ac8>] b43_phy_write+0x3c/0x56 [b43]
kernel:  [<ffffffffa02d8384>] b43_gphy_op_software_rfkill+0x112/0x131 [b43]
kernel:  [<ffffffffa02d66d8>] b43_software_rfkill+0x20/0x2d [b43]
...

kernel: b43-phy0 debug: PHY/RADIO register access with enabled MAC.
kernel: Pid: 7, comm: events/0 Not tainted 2.6.28-rc8-wl #55
kernel: Call Trace:
kernel:  [<ffffffffa02d6fc7>] ? b43_gphy_op_write+0x30/0x35 [b43]
kernel:  [<ffffffffa02d6ac8>] b43_phy_write+0x3c/0x56 [b43]
kernel:  [<ffffffffa02d839a>] b43_gphy_op_software_rfkill+0x128/0x131 [b43]
kernel:  [<ffffffffa02d66d8>] b43_software_rfkill+0x20/0x2d [b43]
...

These were on an x86_64 system running wireless testing that git-describe shows
as v2.6.28-rc8-8079-g3af3a24.

Larry


From mb at bu3sch.de  Fri Dec 19 16:40:07 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 19 Dec 2008 16:40:07 +0100
Subject: [PATCH] b43: Fix some MAC locking
In-Reply-To: <494BC02B.4000906@lwfinger.net>
References: <200812182213.39260.mb@bu3sch.de> <494BC02B.4000906@lwfinger.net>
Message-ID: <200812191640.07863.mb@bu3sch.de>

On Friday 19 December 2008 16:39:23 Larry Finger wrote:
> Michael Buesch wrote:
> > This fixes some locking w.r.t. the lower MAC (firmware).
> > It also removes a lot of ancient IRQ-locking that's not needed anymore.
> > We simply suspend the MAC. That's easier and causes less trouble.
> 
> When booting with this patch and the RFKILL switch off, I got these b43dbg messages:
> 
> kernel: b43-phy0 debug: PHY/RADIO register access with enabled MAC.
> kernel: Pid: 7, comm: events/0 Not tainted 2.6.28-rc8-wl #55
> kernel: Call Trace:
> kernel:  [<ffffffffa02d6b15>] b43_phy_read+0x33/0x46 [b43]
> kernel:  [<ffffffffa02d8350>] b43_gphy_op_software_rfkill+0xde/0x131 [b43]
> kernel:  [<ffffffffa02d66d8>] b43_software_rfkill+0x20/0x2d [b43]

Thanks.
I guess suspending MAC before killing RF is a good thing anyway. I'll do a patch.

-- 
Greetings, Michael.


From chris at ilovelinux.de  Fri Dec 19 17:05:00 2008
From: chris at ilovelinux.de (Christian Schmitt)
Date: Fri, 19 Dec 2008 17:05:00 +0100
Subject: bcm4312 tester needed?
Message-ID: <494BC62C.7010303@ilovelinux.de>

Hi,

I have a machine with a currently unsupported bcm4312 chipset here.
According to lspci it is the 14e4:4315 variant. Is there anything I can
do to help? I'm no programmer but there is surely other things to do.

Cheers
Chris


From mb at bu3sch.de  Fri Dec 19 18:40:00 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 19 Dec 2008 18:40:00 +0100
Subject: [PATCH] b43: Suspend MAC while killing the radio
Message-ID: <200812191840.00731.mb@bu3sch.de>

We should suspend the MAC, before we kill the radio. This gives
the MAC a chance to leave any TX/RX state and it avoids races on
the PHY/RADIO registers.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.29

Index: wireless-testing/drivers/net/wireless/b43/phy_common.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_common.c	2008-12-19 18:32:33.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_common.c	2008-12-19 18:35:49.000000000 +0100
@@ -293,14 +293,16 @@ void b43_software_rfkill(struct b43_wlde
 
 	if (state == RFKILL_STATE_HARD_BLOCKED) {
 		/* We cannot hardware-block the device */
 		state = RFKILL_STATE_SOFT_BLOCKED;
 	}
 
+	b43_mac_suspend(dev);
 	phy->ops->software_rfkill(dev, state);
 	phy->radio_on = (state == RFKILL_STATE_UNBLOCKED);
+	b43_mac_enable(dev);
 }
 
 /**
  * b43_phy_txpower_adjust_work - TX power workqueue.
  *
  * Workqueue for updating the TX power parameters in hardware.

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Fri Dec 19 19:14:21 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 19 Dec 2008 12:14:21 -0600
Subject: [PATCH] b43: Suspend MAC while killing the radio
In-Reply-To: <200812191840.00731.mb@bu3sch.de>
References: <200812191840.00731.mb@bu3sch.de>
Message-ID: <494BE47D.7050708@lwfinger.net>

Michael Buesch wrote:
> We should suspend the MAC, before we kill the radio. This gives
> the MAC a chance to leave any TX/RX state and it avoids races on
> the PHY/RADIO registers.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> ---
> 
> For 2.6.29

This patch removes the messages. ACK.

Larry



From mb at bu3sch.de  Fri Dec 19 20:24:30 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 19 Dec 2008 20:24:30 +0100
Subject: [PATCH] b43: Add key memory dumping
Message-ID: <200812192024.30700.mb@bu3sch.de>

This adds an option to dump all crypto related memory to
the kernel log.
Obviously, it should not be enabled on productive systems. ;)

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.29

Index: wireless-testing/drivers/net/wireless/b43/debugfs.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/debugfs.c	2008-08-30 02:13:22.000000000 +0200
+++ wireless-testing/drivers/net/wireless/b43/debugfs.c	2008-12-19 19:34:17.000000000 +0100
@@ -728,12 +728,13 @@ static void b43_add_dynamic_debug(struct
 	add_dyn_dbg("debug_dmaoverflow", B43_DBG_DMAOVERFLOW, 0);
 	add_dyn_dbg("debug_dmaverbose", B43_DBG_DMAVERBOSE, 0);
 	add_dyn_dbg("debug_pwork_fast", B43_DBG_PWORK_FAST, 0);
 	add_dyn_dbg("debug_pwork_stop", B43_DBG_PWORK_STOP, 0);
 	add_dyn_dbg("debug_lo", B43_DBG_LO, 0);
 	add_dyn_dbg("debug_firmware", B43_DBG_FIRMWARE, 0);
+	add_dyn_dbg("debug_keys", B43_DBG_KEYS, 0);
 
 #undef add_dyn_dbg
 }
 
 void b43_debugfs_add_device(struct b43_wldev *dev)
 {
Index: wireless-testing/drivers/net/wireless/b43/debugfs.h
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/debugfs.h	2008-08-28 18:38:15.000000000 +0200
+++ wireless-testing/drivers/net/wireless/b43/debugfs.h	2008-12-19 19:33:41.000000000 +0100
@@ -9,12 +9,13 @@ enum b43_dyndbg {		/* Dynamic debugging 
 	B43_DBG_DMAOVERFLOW,
 	B43_DBG_DMAVERBOSE,
 	B43_DBG_PWORK_FAST,
 	B43_DBG_PWORK_STOP,
 	B43_DBG_LO,
 	B43_DBG_FIRMWARE,
+	B43_DBG_KEYS,
 	__B43_NR_DYNDBG,
 };
 
 #ifdef CONFIG_B43_DEBUG
 
 struct dentry;
Index: wireless-testing/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/main.c	2008-12-19 18:32:33.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/main.c	2008-12-19 19:42:21.000000000 +0100
@@ -989,12 +989,58 @@ static void b43_clear_keys(struct b43_wl
 	int i;
 
 	for (i = 0; i < dev->max_nr_keys; i++)
 		b43_key_clear(dev, i);
 }
 
+static void b43_dump_keymemory(struct b43_wldev *dev)
+{
+	unsigned int i, index, offset;
+	DECLARE_MAC_BUF(macbuf);
+	u8 mac[ETH_ALEN];
+	u16 algo;
+	u32 rcmta0;
+	u16 rcmta1;
+	u64 hf;
+	struct b43_key *key;
+
+	if (!b43_debug(dev, B43_DBG_KEYS))
+		return;
+
+	hf = b43_hf_read(dev);
+	b43dbg(dev->wl, "Hardware key memory dump:  USEDEFKEYS=%u\n",
+	       !!(hf & B43_HF_USEDEFKEYS));
+	for (index = 0; index < dev->max_nr_keys; index++) {
+		key = &(dev->key[index]);
+		printk(KERN_DEBUG "Key slot %02u: %s",
+		       index, (key->keyconf == NULL) ? " " : "*");
+		offset = dev->ktp + (index * B43_SEC_KEYSIZE);
+		for (i = 0; i < B43_SEC_KEYSIZE; i += 2) {
+			u16 tmp = b43_shm_read16(dev, B43_SHM_SHARED, offset + i);
+			printk("%02X%02X", (tmp & 0xFF), ((tmp >> 8) & 0xFF));
+		}
+
+		algo = b43_shm_read16(dev, B43_SHM_SHARED,
+				      B43_SHM_SH_KEYIDXBLOCK + (index * 2));
+		printk("   Algo: %04X/%02X", algo, key->algorithm);
+
+		if (index >= 4) {
+			rcmta0 = b43_shm_read32(dev, B43_SHM_RCMTA,
+						((index - 4) * 2) + 0);
+			rcmta1 = b43_shm_read16(dev, B43_SHM_RCMTA,
+						((index - 4) * 2) + 1);
+			*((__le32 *)(&mac[0])) = cpu_to_le32(rcmta0);
+			*((__le16 *)(&mac[4])) = cpu_to_le16(rcmta1);
+			printk("   MAC: %s",
+			       print_mac(macbuf, mac));
+		} else
+			printk("   DEFAULT KEY");
+		printk("\n");
+	}
+}
+
 void b43_power_saving_ctl_bits(struct b43_wldev *dev, unsigned int ps_flags)
 {
 	u32 macctl;
 	u16 ucstat;
 	bool hwps;
 	bool awake;
@@ -3563,21 +3609,24 @@ static int b43_op_set_key(struct ieee802
 			goto out_unlock;
 		break;
 	}
 	default:
 		B43_WARN_ON(1);
 	}
+
 out_unlock:
-	spin_unlock_irqrestore(&wl->irq_lock, flags);
-	mutex_unlock(&wl->mutex);
 	if (!err) {
 		b43dbg(wl, "%s hardware based encryption for keyidx: %d, "
 		       "mac: %s\n",
 		       cmd == SET_KEY ? "Using" : "Disabling", key->keyidx,
 		       print_mac(mac, addr));
+		b43_dump_keymemory(dev);
 	}
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+	mutex_unlock(&wl->mutex);
+
 	return err;
 }
 
 static void b43_op_configure_filter(struct ieee80211_hw *hw,
 				    unsigned int changed, unsigned int *fflags,
 				    int mc_count, struct dev_addr_list *mc_list)

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Dec 19 21:30:52 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 19 Dec 2008 21:30:52 +0100
Subject: [PATCH] b43: Fixup set_key handling
Message-ID: <200812192130.52399.mb@bu3sch.de>

This fixes the key handling for mac80211's new key->flags.
It also adds TX locking to the set_key handler and adds a comment why this is required.
This doesn't fix any known bugs.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.29

Index: wireless-testing/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/main.c	2008-12-19 19:42:21.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/main.c	2008-12-19 21:17:44.000000000 +0100
@@ -934,27 +934,26 @@ static int b43_key_write(struct b43_wlde
 		return -EINVAL;
 	for (i = 0; i < dev->max_nr_keys; i++) {
 		/* Check that we don't already have this key. */
 		B43_WARN_ON(dev->key[i].keyconf == keyconf);
 	}
 	if (index < 0) {
-		/* Either pairwise key or address is 00:00:00:00:00:00
-		 * for transmit-only keys. Search the index. */
+		/* Pairwise key. Get an empty slot for the key. */
 		if (b43_new_kidx_api(dev))
 			sta_keys_start = 4;
 		else
 			sta_keys_start = 8;
 		for (i = sta_keys_start; i < dev->max_nr_keys; i++) {
 			if (!dev->key[i].keyconf) {
 				/* found empty */
 				index = i;
 				break;
 			}
 		}
 		if (index < 0) {
-			b43err(dev->wl, "Out of hardware key memory\n");
+			b43warn(dev->wl, "Out of hardware key memory\n");
 			return -ENOSPC;
 		}
 	} else
 		B43_WARN_ON(index > 3);
 
 	do_key_write(dev, index, algorithm, key, key_len, mac_addr);
@@ -3522,23 +3521,30 @@ out_unlock_mutex:
 static int b43_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
 			   const u8 *local_addr, const u8 *addr,
 			   struct ieee80211_key_conf *key)
 {
 	struct b43_wl *wl = hw_to_b43_wl(hw);
 	struct b43_wldev *dev;
-	unsigned long flags;
 	u8 algorithm;
 	u8 index;
 	int err;
 	DECLARE_MAC_BUF(mac);
 
 	if (modparam_nohwcrypt)
 		return -ENOSPC; /* User disabled HW-crypto */
 
 	mutex_lock(&wl->mutex);
-	spin_lock_irqsave(&wl->irq_lock, flags);
+	spin_lock_irq(&wl->irq_lock);
+	write_lock(&wl->tx_lock);
+	/* Why do we need all this locking here?
+	 * mutex     -> Every config operation must take it.
+	 * irq_lock  -> We modify the dev->key array, which is accessed
+	 *              in the IRQ handlers.
+	 * tx_lock   -> We modify the dev->key array, which is accessed
+	 *              in the TX handler.
+	 */
 
 	dev = wl->current_dev;
 	err = -ENODEV;
 	if (!dev || b43_status(dev) < B43_STAT_INITIALIZED)
 		goto out_unlock;
 
@@ -3549,13 +3555,13 @@ static int b43_op_set_key(struct ieee802
 		goto out_unlock;
 	}
 
 	err = -EINVAL;
 	switch (key->alg) {
 	case ALG_WEP:
-		if (key->keylen == 5)
+		if (key->keylen == LEN_WEP40)
 			algorithm = B43_SEC_ALGO_WEP40;
 		else
 			algorithm = B43_SEC_ALGO_WEP104;
 		break;
 	case ALG_TKIP:
 		algorithm = B43_SEC_ALGO_TKIP;
@@ -3576,23 +3582,20 @@ static int b43_op_set_key(struct ieee802
 		if (algorithm == B43_SEC_ALGO_TKIP) {
 			/* FIXME: No TKIP hardware encryption for now. */
 			err = -EOPNOTSUPP;
 			goto out_unlock;
 		}
 
-		if (is_broadcast_ether_addr(addr)) {
-			/* addr is FF:FF:FF:FF:FF:FF for default keys */
-			err = b43_key_write(dev, index, algorithm,
-					    key->key, key->keylen, NULL, key);
-		} else {
-			/*
-			 * either pairwise key or address is 00:00:00:00:00:00
-			 * for transmit-only keys
-			 */
+		if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {
+			/* Pairwise key with an assigned MAC address. */
 			err = b43_key_write(dev, -1, algorithm,
 					    key->key, key->keylen, addr, key);
+		} else {
+			/* Group key */
+			err = b43_key_write(dev, index, algorithm,
+					    key->key, key->keylen, NULL, key);
 		}
 		if (err)
 			goto out_unlock;
 
 		if (algorithm == B43_SEC_ALGO_WEP40 ||
 		    algorithm == B43_SEC_ALGO_WEP104) {
@@ -3618,13 +3621,14 @@ out_unlock:
 		b43dbg(wl, "%s hardware based encryption for keyidx: %d, "
 		       "mac: %s\n",
 		       cmd == SET_KEY ? "Using" : "Disabling", key->keyidx,
 		       print_mac(mac, addr));
 		b43_dump_keymemory(dev);
 	}
-	spin_unlock_irqrestore(&wl->irq_lock, flags);
+	write_unlock(&wl->tx_lock);
+	spin_unlock_irq(&wl->irq_lock);
 	mutex_unlock(&wl->mutex);
 
 	return err;
 }
 
 static void b43_op_configure_filter(struct ieee80211_hw *hw,

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Dec 19 22:51:57 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 19 Dec 2008 22:51:57 +0100
Subject: [PATCH] b43: Use 64bit atomic register access for TSF
Message-ID: <200812192251.57673.mb@bu3sch.de>

On modern b43 devices with core rev >=3, the hardware guarantees us an
atomic 64bit read/write of the TSF, if we access the lower 32bits first.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.29


Index: wireless-testing/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/main.c	2008-12-19 21:17:44.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/main.c	2008-12-19 22:19:22.000000000 +0100
@@ -523,58 +523,26 @@ void b43_hf_write(struct b43_wldev *dev,
 	hi = (value & 0xFFFF00000000ULL) >> 32;
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_HOSTFLO, lo);
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_HOSTFMI, mi);
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_HOSTFHI, hi);
 }
 
-void b43_tsf_read(struct b43_wldev *dev, u64 * tsf)
+void b43_tsf_read(struct b43_wldev *dev, u64 *tsf)
 {
-	/* We need to be careful. As we read the TSF from multiple
-	 * registers, we should take care of register overflows.
-	 * In theory, the whole tsf read process should be atomic.
-	 * We try to be atomic here, by restaring the read process,
-	 * if any of the high registers changed (overflew).
-	 */
-	if (dev->dev->id.revision >= 3) {
-		u32 low, high, high2;
+	u32 low, high;
 
-		do {
-			high = b43_read32(dev, B43_MMIO_REV3PLUS_TSF_HIGH);
-			low = b43_read32(dev, B43_MMIO_REV3PLUS_TSF_LOW);
-			high2 = b43_read32(dev, B43_MMIO_REV3PLUS_TSF_HIGH);
-		} while (unlikely(high != high2));
-
-		*tsf = high;
-		*tsf <<= 32;
-		*tsf |= low;
-	} else {
-		u64 tmp;
-		u16 v0, v1, v2, v3;
-		u16 test1, test2, test3;
-
-		do {
-			v3 = b43_read16(dev, B43_MMIO_TSF_3);
-			v2 = b43_read16(dev, B43_MMIO_TSF_2);
-			v1 = b43_read16(dev, B43_MMIO_TSF_1);
-			v0 = b43_read16(dev, B43_MMIO_TSF_0);
-
-			test3 = b43_read16(dev, B43_MMIO_TSF_3);
-			test2 = b43_read16(dev, B43_MMIO_TSF_2);
-			test1 = b43_read16(dev, B43_MMIO_TSF_1);
-		} while (v3 != test3 || v2 != test2 || v1 != test1);
-
-		*tsf = v3;
-		*tsf <<= 48;
-		tmp = v2;
-		tmp <<= 32;
-		*tsf |= tmp;
-		tmp = v1;
-		tmp <<= 16;
-		*tsf |= tmp;
-		*tsf |= v0;
-	}
+	B43_WARN_ON(dev->dev->id.revision < 3);
+
+	/* The hardware guarantees us an atomic read, if we
+	 * read the low register first. */
+	low = b43_read32(dev, B43_MMIO_REV3PLUS_TSF_LOW);
+	high = b43_read32(dev, B43_MMIO_REV3PLUS_TSF_HIGH);
+
+	*tsf = high;
+	*tsf <<= 32;
+	*tsf |= low;
 }
 
 static void b43_time_lock(struct b43_wldev *dev)
 {
 	u32 macctl;
 
@@ -595,41 +563,24 @@ static void b43_time_unlock(struct b43_w
 	/* Commit the write */
 	b43_read32(dev, B43_MMIO_MACCTL);
 }
 
 static void b43_tsf_write_locked(struct b43_wldev *dev, u64 tsf)
 {
-	/* Be careful with the in-progress timer.
-	 * First zero out the low register, so we have a full
-	 * register-overflow duration to complete the operation.
-	 */
-	if (dev->dev->id.revision >= 3) {
-		u32 lo = (tsf & 0x00000000FFFFFFFFULL);
-		u32 hi = (tsf & 0xFFFFFFFF00000000ULL) >> 32;
+	u32 low, high;
 
-		b43_write32(dev, B43_MMIO_REV3PLUS_TSF_LOW, 0);
-		mmiowb();
-		b43_write32(dev, B43_MMIO_REV3PLUS_TSF_HIGH, hi);
-		mmiowb();
-		b43_write32(dev, B43_MMIO_REV3PLUS_TSF_LOW, lo);
-	} else {
-		u16 v0 = (tsf & 0x000000000000FFFFULL);
-		u16 v1 = (tsf & 0x00000000FFFF0000ULL) >> 16;
-		u16 v2 = (tsf & 0x0000FFFF00000000ULL) >> 32;
-		u16 v3 = (tsf & 0xFFFF000000000000ULL) >> 48;
+	B43_WARN_ON(dev->dev->id.revision < 3);
 
-		b43_write16(dev, B43_MMIO_TSF_0, 0);
-		mmiowb();
-		b43_write16(dev, B43_MMIO_TSF_3, v3);
-		mmiowb();
-		b43_write16(dev, B43_MMIO_TSF_2, v2);
-		mmiowb();
-		b43_write16(dev, B43_MMIO_TSF_1, v1);
-		mmiowb();
-		b43_write16(dev, B43_MMIO_TSF_0, v0);
-	}
+	low = tsf;
+	high = (tsf >> 32);
+	/* The hardware guarantees us an atomic write, if we
+	 * write the low register first. */
+	b43_write32(dev, B43_MMIO_REV3PLUS_TSF_LOW, low);
+	mmiowb();
+	b43_write32(dev, B43_MMIO_REV3PLUS_TSF_HIGH, high);
+	mmiowb();
 }
 
 void b43_tsf_write(struct b43_wldev *dev, u64 tsf)
 {
 	b43_time_lock(dev);
 	b43_tsf_write_locked(dev, tsf);

-- 
Greetings, Michael.


From ulf.dambacher at web.de  Sat Dec 20 18:08:17 2008
From: ulf.dambacher at web.de (Ulf Dambacher)
Date: Sat, 20 Dec 2008 18:08:17 +0100
Subject: b43legacy: My laptop has no button for rfkill but the driver sais
	it has...
Message-ID: <494D2681.2050507@web.de>

Hi

I hav a dell inspiron 5100 and it has no hardware button device to 
toggle rfkill.
The broadcom bcm4301 card has this feature and the driver sees it and 
disables itself hard, wich can not be overwritten by software.

I tested a little bit with a hacked version always returning on on 
rfkill pollling and that worked (partly, see next post)

I propose a module parameter to ignore the rfkill button setting.
I think the polling routine should not be registered if the button is to 
be ignoerd.

If I want to send a patch for that, what would be better way to 
implement it:

- putting some extern declaration in one of the headers (bcm43legacy.h 
or main.h?) and test this directly within  b43legacy_rfkill_init
- put a new filed in the dev structure for disabling the rfkill button?
- use enum { disable,enable, ignore}  radio_hw_enable


bye
Ulf


From ulf.dambacher at web.de  Sat Dec 20 18:15:38 2008
From: ulf.dambacher at web.de (Ulf Dambacher)
Date: Sat, 20 Dec 2008 18:15:38 +0100
Subject: b43legacy can associate with ap but does not send any packets
Message-ID: <494D283A.7090609@web.de>

I have an dell ispiron 5100 with broadcom bcm4301 minipci card

dmesg:

Linux version 2.6.27.9-custom-ud3 (root at ulda) (gcc version 4.2.4 (Ubuntu 
4.2.4-1ubuntu3)) #1 Fri Dec 19 15:53:22 CET 2008

b43legacy-phy0: Broadcom 4301 WLAN found
b43legacy-phy0 debug: Found PHY: Analog 0, Type 1, Revision 4
b43legacy-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2053, Revision 2

After hacking rfkill (see other post) i was able to activate the card, 
to scan for my ap and to accociate with the ap

dmesg:

b43legacy-phy1 debug: Wireless interface stopped
b43legacy-phy1 debug: DMA-30 0x0260 (RX) max used slots: 1/64
b43legacy-phy1 debug: DMA-30 0x0200 (RX) max used slots: 1/64
b43legacy-phy1 debug: DMA-30 0x02A0 (TX) max used slots: 0/128
b43legacy-phy1 debug: DMA-30 0x0280 (TX) max used slots: 0/128
b43legacy-phy1 debug: DMA-30 0x0260 (TX) max used slots: 0/128
b43legacy-phy1 debug: DMA-30 0x0240 (TX) max used slots: 0/128
b43legacy-phy1 debug: DMA-30 0x0220 (TX) max used slots: 4/128
b43legacy-phy1 debug: DMA-30 0x0200 (TX) max used slots: 0/128
b43legacy-phy1 debug: Radio initialized
b43legacy-phy1 debug: Radio initialized
input: b43legacy-phy1 as /class/input/input13
b43legacy-phy1: Loading firmware version 0x127, patch level 14 
(2005-04-18 02:36:27)
b43legacy-phy1 debug: Chip initialized
b43legacy-phy1 debug: 30-bit DMA initialized
Registered led device: b43legacy-phy1:tx
Registered led device: b43legacy-phy1:rx
Registered led device: b43legacy-phy1:radio
b43legacy-phy1 debug: Wireless interface started
b43legacy-phy1 debug: Adding Interface type 2
ADDRCONF(NETDEV_UP): eth1: link is not ready
b44: eth0: powering down PHY
eth1: authenticate with AP 00:15:0c:0e:d2:73
eth1: authenticated
eth1: associate with AP 00:15:0c:0e:d2:73
eth1: RX AssocResp from 00:15:0c:0e:d2:73 (capab=0x451 status=0 aid=2)
eth1: associated
ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready
eth1: no IPv6 routers present

dhclient does not get any leases,
manually configured i used ping and it did not get any replies,
but whatever i did, i was not able to send any packets to the ap

I configured via iwconfig and ifconfig and i checked everything at least 
4 times - no success.

What to do next?

bye
Ulf



From Larry.Finger at lwfinger.net  Sat Dec 20 18:50:11 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 20 Dec 2008 11:50:11 -0600
Subject: b43legacy: My laptop has no button for rfkill but the driver
	sais	it has...
In-Reply-To: <494D2681.2050507@web.de>
References: <494D2681.2050507@web.de>
Message-ID: <494D3053.6080800@lwfinger.net>

Ulf Dambacher wrote:
> Hi
> 
> I hav a dell inspiron 5100 and it has no hardware button device to 
> toggle rfkill.
> The broadcom bcm4301 card has this feature and the driver sees it and 
> disables itself hard, wich can not be overwritten by software.
> 
> I tested a little bit with a hacked version always returning on on 
> rfkill pollling and that worked (partly, see next post)

As your next post shows, merely ignoring the RFKILL setting may do no good. If
the hardware sees that the radio is turned off by the "button", then there is
nothing the driver can do. The firmware will disable the radio. Accordingly,
your hack does no good.

If your laptop does not have an RFKILL button, I have no idea where the signal
to kill the radio is coming from. The BIOS in some computers has a setting that
lets Windows turn off the radio when the system hibernates. If you then boot
Linux, the radio will be off. Check if you have an option to override that
behavior in your system.

There is a facility called the Windows Management Interface (WMI) that is used
to control facilities like this. A rudimentary one for Dell laptops is floating
around, but not yet in the mainline kernels. The author is Matthew Garrett
<mjg59 at srcf.ucam.org>. Perhaps he knows more about the coding for Dell machines.

Larry


From ulf.dambacher at web.de  Sat Dec 20 20:11:28 2008
From: ulf.dambacher at web.de (Ulf Dambacher)
Date: Sat, 20 Dec 2008 20:11:28 +0100
Subject: b43legacy: My laptop has no button for rfkill but the driver
	sais	it has...
In-Reply-To: <494D3053.6080800@lwfinger.net>
References: <494D2681.2050507@web.de> <494D3053.6080800@lwfinger.net>
Message-ID: <494D4360.8070105@web.de>

Larry Finger schrieb:
> As your next post shows, merely ignoring the RFKILL setting may do no good. If
> the hardware sees that the radio is turned off by the "button", then there is
> nothing the driver can do. The firmware will disable the radio. Accordingly,
> your hack does no good.

Hi Larry

With the old bcm43xx driver, everything works well without me ever 
fiddling with the bios (btw. it sais enabled and software controls the 
card) If I bood to the old 2.6.23 kernel i don't have any problems.
If I bood to 2.6.27.9 nothing works anymore. So the problems are with 
the new driver version.

And if I can associate with the ap using the (rfkill-hacked) 
2.6.27.9-b43legacy driver this means that packets are indeed sent (or 
else my ap would not see my laptop)

This is why I posted two different problems.

bye
Ulf



From peter at stuge.se  Sat Dec 20 21:50:52 2008
From: peter at stuge.se (Peter Stuge)
Date: Sat, 20 Dec 2008 21:50:52 +0100
Subject: b43legacy: My laptop has no button for rfkill but the driver
	sais	it has...
In-Reply-To: <494D3053.6080800@lwfinger.net>
References: <494D2681.2050507@web.de> <494D3053.6080800@lwfinger.net>
Message-ID: <20081220205052.11117.qmail@stuge.se>

Larry Finger wrote:
> If your laptop does not have an RFKILL button, I have no idea where
> the signal to kill the radio is coming from.

It can be connected to just about any GPIO pin on any chip in the
system. The super IO, embedded controller and chipset all have IOs to
spare, some chips have a lot of them too.

Two designers at the Taiwanese ODM may know which pin controls it.

Reverse engineer it.


//Peter


From fourdan at gmail.com  Mon Dec 22 14:47:48 2008
From: fourdan at gmail.com (Olivier Fourdan)
Date: Mon, 22 Dec 2008 13:47:48 +0000
Subject: Very poor performances with bcm4306 rev. 3
Message-ID: <60f2b0dc0812220547x77fbba6fq1df5d0a2510c7f06@mail.gmail.com>

[Resent after subscribing to the ML, sorry if that makes it twice]
--
Hi,

I am experiencing very poor network performance using the b34 module
with a Broadcom BCM4306 revision 3 (the system is a Compaq HP R3000
laptop)

The download transfert rate goes from a few bytes to 20Kb/s at max
whereas it commonly reached 200Kb under Windows or on the other
laptops in the hose (using Intel chipset under Linux, for example).
The connection is so unstable that it's causing timeouts during wget
downloads, and makes that system under Linux basically umusable...

The problem is not exactly new and apparently been reported several
times on various forums (mostly Ubuntu) though the problem is not
distro specific (I switched from Ubuntu to Fedora, from x86_64 to i386
and the problem remains). I checked in the archives and found some
similar problems but no solution.

The connection is using basic WEP encryption, wpa_supplicant involved.
The router is a Netgear WGR614 v7.

 * uname -a
  Linux r3000 2.6.27.7-134.fc10.i686 #1 SMP Mon Dec 1 22:42:50 EST
2008 i686 athlon i386 GNU/Linux

 * lspci -vvn|grep 43 -A7
02:02.0 0280: 14e4:4320 (rev 03)
       Subsystem: 103c:12fa
       Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
Stepping- SERR+ FastB2B- DisINTx-
       Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort-
<TAbort- <MAbort- >SERR- <PERR- INTx-
       Latency: 64
       Interrupt: pin A routed to IRQ 17
       Region 0: Memory at e0104000 (32-bit, non-prefetchable) [size=8K]
       Kernel driver in use: b43-pci-bridge
       Kernel modules: ssb

02:04.0 0607: 104c:ac54 (rev 01)
       Subsystem: 103c:006d
       Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
Stepping- SERR- FastB2B- DisINTx-
       Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=medium >TAbort-
<TAbort- <MAbort- >SERR- <PERR- INTx-
       Latency: 168, Cache Line Size: 128 bytes

 * dmesg
  (attached)

Thanks in advance,
Olivier.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: dmesg.gz
Type: application/x-gzip
Size: 9203 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081222/a697a486/attachment.bin>

From mjg59 at srcf.ucam.org  Tue Dec 23 18:46:49 2008
From: mjg59 at srcf.ucam.org (Matthew Garrett)
Date: Tue, 23 Dec 2008 17:46:49 +0000
Subject: b43legacy: My laptop has no button for rfkill but the driver sais
	it has...
In-Reply-To: <494D2681.2050507@web.de>
References: <494D2681.2050507@web.de>
Message-ID: <20081223174649.GA17426@srcf.ucam.org>

On Sat, Dec 20, 2008 at 06:08:17PM +0100, Ulf Dambacher wrote:
> Hi
> 
> I hav a dell inspiron 5100 and it has no hardware button device to 
> toggle rfkill.
> The broadcom bcm4301 card has this feature and the driver sees it and 
> disables itself hard, wich can not be overwritten by software.

The dell-laptop driver is worth a go - it provides support for 
controlling the Dell-specific rfkill interface. It may (or may not) help 
here.

-- 
Matthew Garrett | mjg59 at srcf.ucam.org


From ulf.dambacher at web.de  Wed Dec 24 11:16:36 2008
From: ulf.dambacher at web.de (Ulf Dambacher)
Date: Wed, 24 Dec 2008 11:16:36 +0100
Subject: b43legacy: My laptop has no button for rfkill but the driver
	sais it has...
In-Reply-To: <20081223174649.GA17426@srcf.ucam.org>
References: <494D2681.2050507@web.de> <20081223174649.GA17426@srcf.ucam.org>
Message-ID: <49520C04.5010108@web.de>

Matthew Garrett schrieb:
> On Sat, Dec 20, 2008 at 06:08:17PM +0100, Ulf Dambacher wrote:
>> Hi
>>
>> I hav a dell inspiron 5100 and it has no hardware button device to 
>> toggle rfkill.
>> The broadcom bcm4301 card has this feature and the driver sees it and 
>> disables itself hard, wich can not be overwritten by software.
> 
> The dell-laptop driver is worth a go - it provides support for 
> controlling the Dell-specific rfkill interface. It may (or may not) help 
> here.
> 

Hi Matthew

I still don't think its a general problem, but a problem that b43legacy 
does miss something bcm43xx does to initialize my hardware to enable it.

Anyway, Larry Finger also pointed me to your patches. I searched them 
from lkml and applied them to a 2.6.27.9 kernel (with some hand-work)

When loading the module dell-laptop I get:

FATAL: Eroor inserting dell_laptop: No such device

Kernel dmesg sais:
dcbas dcbas: Dell Systems management base Driver (version 5.6.0-3.2)

So my system is not listed in your device_table?
Attached is the output of dmidecode.

And yes, i tested i8k (forced load) too without success.

merry xmas

Ulf


---------------------------8<------------------------------
> # dmidecode 2.9
> SMBIOS 2.3 present.
> 41 structures occupying 1507 bytes.
> Table at 0x000F9660.
> 
> Handle 0xDA00, DMI type 218, 53 bytes
> OEM-specific Type
> 	Header and Data:
> 		DA 35 00 DA B2 00 0D 1F 0F 37 40 7D 00 00 00 00
> 		00 7E 00 02 00 00 00 01 F0 01 F0 00 00 02 F0 02
> 		F0 00 00 03 F0 03 F0 00 00 04 F0 04 F0 00 00 FF
> 		FF 00 00 00 00
> 
> Handle 0x0000, DMI type 0, 20 bytes
> BIOS Information
> 	Vendor: Dell Computer Corporation
> 	Version: A32
> 	Release Date: 10/18/2004
> 	Address: 0xF0000
> 	Runtime Size: 64 kB
> 	ROM Size: 576 kB
> 	Characteristics:
> 		ISA is supported
> 		PCI is supported
> 		PC Card (PCMCIA) is supported
> 		PNP is supported
> 		APM is supported
> 		BIOS is upgradeable
> 		BIOS shadowing is allowed
> 		Boot from CD is supported
> 		Selectable boot is supported
> 		3.5"/720 KB floppy services are supported (int 13h)
> 		Print screen service is supported (int 5h)
> 		8042 keyboard services are supported (int 9h)
> 		Serial services are supported (int 14h)
> 		Printer services are supported (int 17h)
> 		CGA/mono video services are supported (int 10h)
> 		ACPI is supported
> 		USB legacy is supported
> 		AGP is supported
> 		Smart battery is supported
> 		BIOS boot specification is supported
> 		Function key-initiated network boot is supported
> 
> Handle 0x0100, DMI type 1, 25 bytes
> System Information
> 	Manufacturer: Dell Computer Corporation
> 	Product Name: Inspiron 5100                   
> 	Version: Not Specified
> 	Serial Number: 2QTMP0J
> 	UUID: 44454C4C-5100-1054-804D-B2C04F50304A
> 	Wake-up Type: Power Switch
> 
> Handle 0x0200, DMI type 2, 9 bytes
> Base Board Information
> 	Manufacturer: Dell Computer Corporation
> 	Product Name: 09U806
> 	Version:    
> 	Serial Number: .2QTMP0J.CN1296133C4728.
> 
> Handle 0x0300, DMI type 3, 13 bytes
> Chassis Information
> 	Manufacturer: Dell Computer Corporation
> 	Type: Portable
> 	Lock: Not Present
> 	Version: Not Specified
> 	Serial Number: 2QTMP0J
> 	Asset Tag: Not Specified
> 	Boot-up State: Safe
> 	Power Supply State: Safe
> 	Thermal State: Safe
> 	Security Status: None
> 
> Handle 0x0400, DMI type 4, 32 bytes
> Processor Information
> 	Socket Designation: Microprocessor
> 	Type: Central Processor
> 	Family: Pentium 4
> 	Manufacturer: Intel
> 	ID: 27 0F 00 00 FF F9 EB BF
> 	Signature: Type 0, Family 15, Model 2, Stepping 7
> 	Flags:
> 		FPU (Floating-point unit on-chip)
> 		VME (Virtual mode extension)
> 		DE (Debugging extension)
> 		PSE (Page size extension)
> 		TSC (Time stamp counter)
> 		MSR (Model specific registers)
> 		PAE (Physical address extension)
> 		MCE (Machine check exception)
> 		CX8 (CMPXCHG8 instruction supported)
> 		SEP (Fast system call)
> 		MTRR (Memory type range registers)
> 		PGE (Page global enable)
> 		MCA (Machine check architecture)
> 		CMOV (Conditional move instruction supported)
> 		PAT (Page attribute table)
> 		PSE-36 (36-bit page size extension)
> 		CLFSH (CLFLUSH instruction supported)
> 		DS (Debug store)
> 		ACPI (ACPI supported)
> 		MMX (MMX technology supported)
> 		FXSR (Fast floating-point save and restore)
> 		SSE (Streaming SIMD extensions)
> 		SSE2 (Streaming SIMD extensions 2)
> 		SS (Self-snoop)
> 		HTT (Hyper-threading technology)
> 		TM (Thermal monitor supported)
> 		PBE (Pending break enabled)
> 	Version: Not Specified
> 	Voltage: 3.3 V
> 	External Clock: 133 MHz
> 	Max Speed: 2800 MHz
> 	Current Speed: 2533 MHz
> 	Status: Populated, Enabled
> 	Upgrade: None
> 	L1 Cache Handle: 0x0700
> 	L2 Cache Handle: 0x0701
> 	L3 Cache Handle: Not Provided
> 
> Handle 0x0700, DMI type 7, 19 bytes
> Cache Information
> 	Socket Designation: Not Specified
> 	Configuration: Enabled, Not Socketed, Level 1
> 	Operational Mode: Write Back
> 	Location: Internal
> 	Installed Size: 8 KB
> 	Maximum Size: 8 KB
> 	Supported SRAM Types:
> 		Unknown
> 	Installed SRAM Type: Unknown
> 	Speed: Unknown
> 	Error Correction Type: None
> 	System Type: Data
> 	Associativity: 4-way Set-associative
> 
> Handle 0x0701, DMI type 7, 19 bytes
> Cache Information
> 	Socket Designation: Not Specified
> 	Configuration: Enabled, Not Socketed, Level 2
> 	Operational Mode: Varies With Memory Address
> 	Location: Internal
> 	Installed Size: 512 KB
> 	Maximum Size: 512 KB
> 	Supported SRAM Types:
> 		Pipeline Burst
> 	Installed SRAM Type: Pipeline Burst
> 	Speed: 15 ns
> 	Error Correction Type: None
> 	System Type: Unified
> 	Associativity: Other
> 
> Handle 0x0804, DMI type 8, 9 bytes
> Port Connector Information
> 	Internal Reference Designator: USB
> 	Internal Connector Type: None
> 	External Reference Designator: Not Specified
> 	External Connector Type: Access Bus (USB)
> 	Port Type: USB
> 
> Handle 0x0806, DMI type 8, 9 bytes
> Port Connector Information
> 	Internal Reference Designator: MONITOR
> 	Internal Connector Type: None
> 	External Reference Designator: Not Specified
> 	External Connector Type: DB-15 female
> 	Port Type: Video Port
> 
> Handle 0x080B, DMI type 8, 9 bytes
> Port Connector Information
> 	Internal Reference Designator: FireWire
> 	Internal Connector Type: None
> 	External Reference Designator: Not Specified
> 	External Connector Type: IEEE 1394
> 	Port Type: Firewire (IEEE P1394)
> 
> Handle 0x080C, DMI type 8, 9 bytes
> Port Connector Information
> 	Internal Reference Designator: Modem
> 	Internal Connector Type: None
> 	External Reference Designator: Not Specified
> 	External Connector Type: RJ-11
> 	Port Type: Modem Port
> 
> Handle 0x080D, DMI type 8, 9 bytes
> Port Connector Information
> 	Internal Reference Designator: Ethernet
> 	Internal Connector Type: None
> 	External Reference Designator: Not Specified
> 	External Connector Type: RJ-45
> 	Port Type: Network Port
> 
> Handle 0x0900, DMI type 9, 13 bytes
> System Slot Information
> 	Designation: PCMCIA 0
> 	Type: 32-bit PC Card (PCMCIA)
> 	Current Usage: Available
> 	Length: Other
> 	ID: Adapter 0, Socket 0
> 	Characteristics:
> 		5.0 V is provided
> 		3.3 V is provided
> 		PC Card-16 is supported
> 		Cardbus is supported
> 		Zoom Video is supported
> 		Modem ring resume is supported
> 
> Handle 0x0904, DMI type 9, 13 bytes
> System Slot Information
> 	Designation: MiniPCI
> 	Type: 32-bit Other
> 	Current Usage: Available
> 	Length: Other
> 	Characteristics:
> 		5.0 V is provided
> 		3.3 V is provided
> 		PME signal is supported
> 
> Handle 0x0A00, DMI type 10, 6 bytes
> On Board Device Information
> 	Type: Video
> 	Status: Enabled
> 	Description: ATI Radeon 7500       
> 
> Handle 0x0A01, DMI type 10, 6 bytes
> On Board Device Information
> 	Type: Sound
> 	Status: Enabled
> 	Description: Sigmatel 9750
> 
> Handle 0x0B00, DMI type 11, 5 bytes
> OEM Strings
> 	String 1: Dell System
> 	String 2: 5[0001]
> 
> Handle 0x0D00, DMI type 13, 22 bytes
> BIOS Language Information
> 	Installable Languages: 1
> 		en|US|iso8859-1
> 	Currently Installed Language: en|US|iso8859-1
> 
> Handle 0x1000, DMI type 16, 15 bytes
> Physical Memory Array
> 	Location: System Board Or Motherboard
> 	Use: System Memory
> 	Error Correction Type: None
> 	Maximum Capacity: 2 GB
> 	Error Information Handle: Not Provided
> 	Number Of Devices: 2
> 
> Handle 0x1100, DMI type 17, 27 bytes
> Memory Device
> 	Array Handle: 0x1000
> 	Error Information Handle: Not Provided
> 	Total Width: 64 bits
> 	Data Width: 64 bits
> 	Size: 256 MB
> 	Form Factor: DIMM
> 	Set: None
> 	Locator: DIMM_A
> 	Bank Locator: Not Specified
> 	Type: DDR
> 	Type Detail: Synchronous
> 	Speed: 266 MHz (3.8 ns)
> 	Manufacturer: Not Specified
> 	Serial Number: Not Specified
> 	Asset Tag: Not Specified
> 	Part Number:                 
> 
> Handle 0x1101, DMI type 17, 27 bytes
> Memory Device
> 	Array Handle: 0x1000
> 	Error Information Handle: Not Provided
> 	Total Width: 64 bits
> 	Data Width: 64 bits
> 	Size: 256 MB
> 	Form Factor: DIMM
> 	Set: None
> 	Locator: DIMM_B
> 	Bank Locator: Not Specified
> 	Type: DDR
> 	Type Detail: Synchronous
> 	Speed: 266 MHz (3.8 ns)
> 	Manufacturer: Not Specified
> 	Serial Number: Not Specified
> 	Asset Tag: Not Specified
> 	Part Number:                 
> 
> Handle 0x1300, DMI type 19, 15 bytes
> Memory Array Mapped Address
> 	Starting Address: 0x00000000000
> 	Ending Address: 0x0000009FFFF
> 	Range Size: 640 kB
> 	Physical Array Handle: 0x1000
> 	Partition Width: 0
> 
> Handle 0x1301, DMI type 19, 15 bytes
> Memory Array Mapped Address
> 	Starting Address: 0x00000100000
> 	Ending Address: 0x0001FFFFFFF
> 	Range Size: 511 MB
> 	Physical Array Handle: 0x1000
> 	Partition Width: 0
> 
> Handle 0x1400, DMI type 20, 19 bytes
> Memory Device Mapped Address
> 	Starting Address: 0x00000000000
> 	Ending Address: 0x0000009FFFF
> 	Range Size: 640 kB
> 	Physical Device Handle: 0x1100
> 	Memory Array Mapped Address Handle: 0x1300
> 	Partition Row Position: 1
> 
> Handle 0x1401, DMI type 20, 19 bytes
> Memory Device Mapped Address
> 	Starting Address: 0x00000100000
> 	Ending Address: 0x0000FFFFFFF
> 	Range Size: 255 MB
> 	Physical Device Handle: 0x1100
> 	Memory Array Mapped Address Handle: 0x1301
> 	Partition Row Position: 1
> 
> Handle 0x1402, DMI type 20, 19 bytes
> Memory Device Mapped Address
> 	Starting Address: 0x00010000000
> 	Ending Address: 0x0001FFFFFFF
> 	Range Size: 256 MB
> 	Physical Device Handle: 0x1101
> 	Memory Array Mapped Address Handle: 0x1301
> 	Partition Row Position: 1
> 
> Handle 0x1500, DMI type 21, 7 bytes
> Built-in Pointing Device
> 	Type: Touch Pad
> 	Interface: Bus Mouse
> 	Buttons: 2
> 
> Handle 0x1600, DMI type 22, 26 bytes
> Portable Battery
> 	Location: Sys. Battery Bay
> 	Manufacturer: Dell            
> 	Name: .DELL           
> 	Design Capacity: 66000 mWh
> 	Design Voltage: 14800 mV
> 	SBDS Version: 1.0
> 	Maximum Error: 9%
> 	SBDS Serial Number: 0001
> 	SBDS Manufacture Date: 2007-01-28
> 	SBDS Chemistry: LION            
> 	OEM-specific Information: 0x00000001
> 
> Handle 0x1B00, DMI type 27, 12 bytes
> Cooling Device
> 	Type: Fan
> 	Status: OK
> 	OEM-specific Information: 0x0000DD00
> 
> Handle 0x1C00, DMI type 28, 20 bytes
> Temperature Probe
> 	Description: CPU Internal Temperature
> 	Location: Processor
> 	Status: OK
> 	Maximum Value: 127.0 deg C
> 	Minimum Value 0.0 deg C
> 	Resolution: 1.000 deg C
> 	Tolerance: 0.5 deg C
> 	Accuracy: Unknown
> 	OEM-specific Information: 0x0000DC00
> 
> Handle 0x2000, DMI type 32, 11 bytes
> System Boot Information
> 	Status: No errors detected
> 
> Handle 0xD000, DMI type 208, 10 bytes
> OEM-specific Type
> 	Header and Data:
> 		D0 0A 00 D0 01 04 FE 00 49 01
> 
> Handle 0xD800, DMI type 216, 9 bytes
> OEM-specific Type
> 	Header and Data:
> 		D8 09 00 D8 01 03 01 F0 03
> 	Strings:
> 		ATI Technologies Inc.
> 		 
> 		008.000.008.005.000.007  
> 
> Handle 0xD900, DMI type 217, 8 bytes
> OEM-specific Type
> 	Header and Data:
> 		D9 08 00 D9 01 02 01 03
> 	Strings:
> 		US-101
> 		Proprietary
> 
> Handle 0xDC00, DMI type 220, 22 bytes
> OEM-specific Type
> 	Header and Data:
> 		DC 16 00 DC 01 F0 00 00 02 F0 00 00 00 00 03 F0
> 		04 F0 00 00 00 00
> 
> Handle 0xDD00, DMI type 221, 19 bytes
> OEM-specific Type
> 	Header and Data:
> 		DD 13 00 DD 00 00 00 00 00 00 00 00 00 00 00 00
> 		00 00 00
> 
> Handle 0xD400, DMI type 212, 122 bytes
> OEM-specific Type
> 	Header and Data:
> 		D4 7A 00 D4 70 00 71 00 00 10 2D 2E 5C 00 78 BF
> 		40 5D 00 78 BF 00 65 00 21 F7 00 66 00 21 F7 08
> 		28 00 23 F3 00 29 00 23 F3 04 2A 00 23 F3 08 2B
> 		00 58 00 00 2C 00 59 00 00 E7 00 1D F3 04 E6 00
> 		1D F3 00 0E 01 23 FD 00 0F 01 23 FD 02 9B 00 23
> 		EF 10 9C 00 23 EF 00 E8 00 23 DF 00 E9 00 23 DF
> 		20 12 01 34 FB 04 13 01 34 FB 00 08 00 1D DF 00
> 		03 00 1D DF 00 FF FF 00 00 00
> 
> Handle 0xD401, DMI type 212, 117 bytes
> OEM-specific Type
> 	Header and Data:
> 		D4 75 01 D4 70 00 71 00 03 40 49 4A 42 00 48 7F
> 		80 43 00 48 7F 00 55 00 47 BF 00 6D 00 47 BF 40
> 		0C 01 46 FB 04 0D 01 46 FB 00 14 01 46 E7 00 15
> 		01 46 E7 08 16 01 46 E7 10 0A 01 48 EF 10 0B 01
> 		48 EF 00 2D 00 48 DF 20 2E 00 48 DF 00 11 01 48
> 		BF 00 10 01 48 BF 40 F0 00 46 3F 20 ED 00 46 3F
> 		00 EA 00 67 F3 00 EB 00 67 F3 04 EC 00 67 F3 081
> 		FF FF 00 00 00
> 
> Handle 0xDE00, DMI type 222, 13 bytes
> OEM-specific Type
> 	Header and Data:
> 		DE 0D 00 DE 01 02 FF FF 00 00 00 00 00
> 
> Handle 0x7F00, DMI type 127, 4 bytes
> End Of Table
> 


From mb at bu3sch.de  Wed Dec 24 12:35:51 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 24 Dec 2008 12:35:51 +0100
Subject: b43legacy: My laptop has no button for rfkill but the driver sais
	it has...
In-Reply-To: <49520C04.5010108@web.de>
References: <494D2681.2050507@web.de> <20081223174649.GA17426@srcf.ucam.org>
	<49520C04.5010108@web.de>
Message-ID: <200812241235.51985.mb@bu3sch.de>

On Wednesday 24 December 2008 11:16:36 Ulf Dambacher wrote:
> Matthew Garrett schrieb:
> > On Sat, Dec 20, 2008 at 06:08:17PM +0100, Ulf Dambacher wrote:
> >> Hi
> >>
> >> I hav a dell inspiron 5100 and it has no hardware button device to 
> >> toggle rfkill.
> >> The broadcom bcm4301 card has this feature and the driver sees it and 
> >> disables itself hard, wich can not be overwritten by software.
> > 
> > The dell-laptop driver is worth a go - it provides support for 
> > controlling the Dell-specific rfkill interface. It may (or may not) help 
> > here.
> > 
> 
> Hi Matthew
> 
> I still don't think its a general problem, but a problem that b43legacy 
> does miss something bcm43xx does to initialize my hardware to enable it.

We cannot enable the radio from within the driver, if it's hardware disabled.
We cannot do this in b43legacy and we cannot do this in bcm43xx. Fullstop.

If it fails now and didn't fail earlier, it almost certainly is something
_else_ that disables the rf.
Please make sure _all_ dell related kernel modules are loaded
and all dell related kernel options are enabled (there are quite a few).
And try to use the dell-tool that was suggested earlier in the thread.

-- 
Greetings, Michael.


From gene.heskett at verizon.net  Wed Dec 24 16:58:14 2008
From: gene.heskett at verizon.net (Gene Heskett)
Date: Wed, 24 Dec 2008 10:58:14 -0500
Subject: b43legacy: My laptop has no button for rfkill but the driver sais
	it has...
In-Reply-To: <200812241235.51985.mb@bu3sch.de>
References: <494D2681.2050507@web.de> <49520C04.5010108@web.de>
	<200812241235.51985.mb@bu3sch.de>
Message-ID: <200812241058.14273.gene.heskett@verizon.net>

On Wednesday 24 December 2008, Michael Buesch wrote:
>On Wednesday 24 December 2008 11:16:36 Ulf Dambacher wrote:
>> Matthew Garrett schrieb:
>> > On Sat, Dec 20, 2008 at 06:08:17PM +0100, Ulf Dambacher wrote:
>> >> Hi
>> >>
>> >> I hav a dell inspiron 5100 and it has no hardware button device to
>> >> toggle rfkill.
>> >> The broadcom bcm4301 card has this feature and the driver sees it and
>> >> disables itself hard, wich can not be overwritten by software.
>> >
>> > The dell-laptop driver is worth a go - it provides support for
>> > controlling the Dell-specific rfkill interface. It may (or may not) help
>> > here.
>>
>> Hi Matthew
>>
>> I still don't think its a general problem, but a problem that b43legacy
>> does miss something bcm43xx does to initialize my hardware to enable it.
>
>We cannot enable the radio from within the driver, if it's hardware
> disabled. We cannot do this in b43legacy and we cannot do this in bcm43xx.
> Fullstop.
>
With all due respect Michael, if it has been disabled by the panel switch such 
as the one on my lappy, can it not be made to emit such an error message so 
that we know we have to toggle that pushbutton?  On my HP- dv5120us, there is 
no tactile feel, or any other means to determine the state of this switch, an 
apparently push-push switch.  The LED is no help cuz you can and do turn it 
on and off at will regardless of the state of the switch.  Having to push the 
button and reboot to see if that fixes it doesn't seem like a very productive 
way to spend an evening.  So I give up and plug in a cable, hundreds of times 
faster to get a network connection, or if on the road, to borrow a little 
dlink tranceiver from the motel.  That after all, is the target condition we 
are trying to achieve.

>If it fails now and didn't fail earlier, it almost certainly is something
>_else_ that disables the rf.
>Please make sure _all_ dell related kernel modules are loaded
>and all dell related kernel options are enabled (there are quite a few).
>And try to use the dell-tool that was suggested earlier in the thread.



-- 
Cheers, Gene
"There are four boxes to be used in defense of liberty:
 soap, ballot, jury, and ammo. Please use in that order."
-Ed Howdershelt (Author)
<Peaker> the difference between theory and practice is just a lot of work

	- from #offtopic (the offtopic chat channel of #kernelnewbies)


From mb at bu3sch.de  Wed Dec 24 17:08:35 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 24 Dec 2008 17:08:35 +0100
Subject: b43legacy: My laptop has no button for rfkill but the driver sais
	it has...
In-Reply-To: <200812241058.14273.gene.heskett@verizon.net>
References: <494D2681.2050507@web.de> <200812241235.51985.mb@bu3sch.de>
	<200812241058.14273.gene.heskett@verizon.net>
Message-ID: <200812241708.35948.mb@bu3sch.de>

On Wednesday 24 December 2008 16:58:14 Gene Heskett wrote:
> With all due respect Michael, if it has been disabled by the panel switch such 
> as the one on my lappy, can it not be made to emit such an error message so 
> that we know we have to toggle that pushbutton?

We emit a message that the radio is disabled.
The b43 driver has exactly one read-only bit to determine whether the radio
is on or off. It polls that bit every second and displays a message when it
got toggled.
That's all we can do from within the driver.

_If_ you can switch it by software, which is theoretically possible of course,
then _not_ through the broadcom wireless PCI device. It has to be done through
another device. So you must load the driver for that device and switch the signal.

> On my HP- dv5120us, there is  
> no tactile feel, or any other means to determine the state of this switch, an 
> apparently push-push switch.  The LED is no help cuz you can and do turn it 
> on and off at will regardless of the state of the switch.  Having to push the 
> button and reboot to see if that fixes it doesn't seem like a very productive 
> way to spend an evening.  So I give up and plug in a cable, hundreds of times 
> faster to get a network connection, or if on the road, to borrow a little 
> dlink tranceiver from the motel.  That after all, is the target condition we 
> are trying to achieve.

I think you should send this to HP.
I really can't do anything about it. All I have is one single read-only bit.

-- 
Greetings, Michael.


From ulf.dambacher at web.de  Wed Dec 24 18:16:20 2008
From: ulf.dambacher at web.de (Ulf Dambacher)
Date: Wed, 24 Dec 2008 18:16:20 +0100
Subject: =?iso-8859-15?Q?Re:_b43legacy:_My_laptop_has_no_button_for_rfkill_but_?=
	=?iso-8859-15?Q?the_driver_sais_it_has...?=
Message-ID: <496773631@web.de>

Hi together

To get it right:
- i have no rfkill hardware button anywhere on the laptop.
- Yesterday I opened it and there are no unused pins or connectors on the card or the motherboard.
- the computer does not run any m$ software wich could interfere here
- my dell bios (version A32) sais  the card is enabled and activated and can be switched  by software
- if I boot a kernel 2.6.22 and i use the bcm43xx driver it is happily transmitting wireless
- if i reboot to kernel 2.6.27.9 and use the b43legacy driver it warns me that i have turned the device on by software but a hardware button still turns it off
- i8k does not work
- dell-laptop  does not work
- Until now, I did not find switch in wmi, acpi,

Now the tricky part:
- if I hack the b43legacy driver to ignore the button settings IT IS ABLE TO ASCCOCIATE WITH MY AP
- get that again: it transmits some message that my ap obviously  can receive and it obviously receives a reply that it is associated.
- no ip packets can be received, it claims to have send some pings though.

If Michael Buesch sais the driver can not overwrite hardware rfkill,  I thake that for granted and  conclude that my card must be on but something else holds it from sending and/or receiving packets - rember, its associated with the ap...
This would be in line with the fact that the bcm43xx driver is indeed working.
And both drivers use exactly the same code to test for the rfkill button. one sais on the other sees off.

Im just reading code and  fiddling with all the dell options and wmi and smb options to get any hooks on where to find my button

merry xmas and bye
Ulf
____________________________________________________________________
Psssst! Schon vom neuen WEB.DE MultiMessenger geh?rt? 
Der kann`s mit allen: http://www.produkte.web.de/messenger/?did=3123



From david at identd.dyndns.org  Wed Dec 24 19:54:31 2008
From: david at identd.dyndns.org (David Ellingsworth)
Date: Wed, 24 Dec 2008 13:54:31 -0500
Subject: b43legacy: My laptop has no button for rfkill but the driver sais
	it has...
In-Reply-To: <496773631@web.de>
References: <496773631@web.de>
Message-ID: <30353c3d0812241054wc155bb1o5bd99ae37d7d3099@mail.gmail.com>

On Wed, Dec 24, 2008 at 12:16 PM, Ulf Dambacher <ulf.dambacher at web.de> wrote:
> Hi together
>
> To get it right:
> - i have no rfkill hardware button anywhere on the laptop.
> - Yesterday I opened it and there are no unused pins or connectors on the card or the motherboard.
> - the computer does not run any m$ software wich could interfere here
> - my dell bios (version A32) sais  the card is enabled and activated and can be switched  by software
> - if I boot a kernel 2.6.22 and i use the bcm43xx driver it is happily transmitting wireless
> - if i reboot to kernel 2.6.27.9 and use the b43legacy driver it warns me that i have turned the device on by software but a hardware button still turns it off
> - i8k does not work
> - dell-laptop  does not work
> - Until now, I did not find switch in wmi, acpi,
>
> Now the tricky part:
> - if I hack the b43legacy driver to ignore the button settings IT IS ABLE TO ASCCOCIATE WITH MY AP
> - get that again: it transmits some message that my ap obviously  can receive and it obviously receives a reply that it is associated.
> - no ip packets can be received, it claims to have send some pings though.
>
> If Michael Buesch sais the driver can not overwrite hardware rfkill,  I thake that for granted and  conclude that my card must be on but something else holds it from sending and/or receiving packets - rember, its associated with the ap...
> This would be in line with the fact that the bcm43xx driver is indeed working.
> And both drivers use exactly the same code to test for the rfkill button. one sais on the other sees off.
>
> Im just reading code and  fiddling with all the dell options and wmi and smb options to get any hooks on where to find my button
>
> merry xmas and bye
> Ulf

OK, just a few thoughts on this.. you obviously have some sort of
issue that's preventing you from using the new b43legacy driver.
Unfortunately, you've only tested the latest version of the driver and
nothing prior. Before blaming b43legacy as the cause, you should first
try to determine if the b43legacy driver ever worked on your system.
Doing a git bisect of the kernel tree should help you determine the
point at which it worked or didn't work and eventually find the commit
that caused the issue. If git bisect reveals the b43legacy driver
never worked on your system since it's inclusion into the kernel and
the last version of bcm43xx did work then you can blame the b43legacy
driver. Until then, like Michael, I am suspect to believe the
b43legacy driver is the cause of your issue.

Regards,

David Ellingsworth


From mb at bu3sch.de  Thu Dec 25 00:39:28 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 25 Dec 2008 00:39:28 +0100
Subject: [PATCH] b43/ssb: Add SPROM8 extraction and LP-PHY detection
Message-ID: <200812250039.28824.mb@bu3sch.de>

This adds detection code for the LP-PHY and SPROM
extraction code for version 8, which is needed by the LP-PHY and
newer N-PHY.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Please queue for 2.6.29


Index: wireless-testing/drivers/ssb/b43_pci_bridge.c
===================================================================
--- wireless-testing.orig/drivers/ssb/b43_pci_bridge.c
+++ wireless-testing/drivers/ssb/b43_pci_bridge.c
@@ -21,6 +21,7 @@ static const struct pci_device_id b43_pc
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4307) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4311) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4312) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4315) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4318) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4319) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4320) },
Index: wireless-testing/drivers/ssb/pci.c
===================================================================
--- wireless-testing.orig/drivers/ssb/pci.c
+++ wireless-testing/drivers/ssb/pci.c
@@ -467,6 +467,51 @@ static void sprom_extract_r45(struct ssb
 	/* TODO - get remaining rev 4 stuff needed */
 }
 
+static void sprom_extract_r8(struct ssb_sprom *out, const u16 *in)
+{
+	int i;
+	u16 v;
+
+	/* extract the MAC address */
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
+		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
+	}
+	SPEX(country_code, SSB_SPROM8_CCODE, 0xFFFF, 0);
+	SPEX(boardflags_lo, SSB_SPROM8_BFLLO, 0xFFFF, 0);
+	SPEX(boardflags_hi, SSB_SPROM8_BFLHI, 0xFFFF, 0);
+	SPEX(ant_available_a, SSB_SPROM8_ANTAVAIL, SSB_SPROM8_ANTAVAIL_A,
+	     SSB_SPROM8_ANTAVAIL_A_SHIFT);
+	SPEX(ant_available_bg, SSB_SPROM8_ANTAVAIL, SSB_SPROM8_ANTAVAIL_BG,
+	     SSB_SPROM8_ANTAVAIL_BG_SHIFT);
+	SPEX(maxpwr_bg, SSB_SPROM8_MAXP_BG, SSB_SPROM8_MAXP_BG_MASK, 0);
+	SPEX(itssi_bg, SSB_SPROM8_MAXP_BG, SSB_SPROM8_ITSSI_BG,
+	     SSB_SPROM8_ITSSI_BG_SHIFT);
+	SPEX(maxpwr_a, SSB_SPROM8_MAXP_A, SSB_SPROM8_MAXP_A_MASK, 0);
+	SPEX(itssi_a, SSB_SPROM8_MAXP_A, SSB_SPROM8_ITSSI_A,
+	     SSB_SPROM8_ITSSI_A_SHIFT);
+	SPEX(gpio0, SSB_SPROM8_GPIOA, SSB_SPROM8_GPIOA_P0, 0);
+	SPEX(gpio1, SSB_SPROM8_GPIOA, SSB_SPROM8_GPIOA_P1,
+	     SSB_SPROM8_GPIOA_P1_SHIFT);
+	SPEX(gpio2, SSB_SPROM8_GPIOB, SSB_SPROM8_GPIOB_P2, 0);
+	SPEX(gpio3, SSB_SPROM8_GPIOB, SSB_SPROM8_GPIOB_P3,
+	     SSB_SPROM8_GPIOB_P3_SHIFT);
+
+	/* Extract the antenna gain values. */
+	SPEX(antenna_gain.ghz24.a0, SSB_SPROM8_AGAIN01,
+	     SSB_SPROM8_AGAIN0, SSB_SPROM8_AGAIN0_SHIFT);
+	SPEX(antenna_gain.ghz24.a1, SSB_SPROM8_AGAIN01,
+	     SSB_SPROM8_AGAIN1, SSB_SPROM8_AGAIN1_SHIFT);
+	SPEX(antenna_gain.ghz24.a2, SSB_SPROM8_AGAIN23,
+	     SSB_SPROM8_AGAIN2, SSB_SPROM8_AGAIN2_SHIFT);
+	SPEX(antenna_gain.ghz24.a3, SSB_SPROM8_AGAIN23,
+	     SSB_SPROM8_AGAIN3, SSB_SPROM8_AGAIN3_SHIFT);
+	memcpy(&out->antenna_gain.ghz5, &out->antenna_gain.ghz24,
+	       sizeof(out->antenna_gain.ghz5));
+
+	/* TODO - get remaining rev 8 stuff needed */
+}
+
 static int sprom_extract(struct ssb_bus *bus, struct ssb_sprom *out,
 			 const u16 *in, u16 size)
 {
@@ -487,15 +532,25 @@ static int sprom_extract(struct ssb_bus
 		out->revision = 4;
 		sprom_extract_r45(out, in);
 	} else {
-		if (out->revision == 0)
-			goto unsupported;
-		if (out->revision >= 1 && out->revision <= 3) {
+		switch (out->revision) {
+		case 1:
+		case 2:
+		case 3:
 			sprom_extract_r123(out, in);
-		}
-		if (out->revision == 4 || out->revision == 5)
+			break;
+		case 4:
+		case 5:
 			sprom_extract_r45(out, in);
-		if (out->revision > 5)
-			goto unsupported;
+			break;
+		case 8:
+			sprom_extract_r8(out, in);
+			break;
+		default:
+			ssb_printk(KERN_WARNING PFX "Unsupported SPROM"
+				   "  revision %d detected. Will extract"
+				   " v1\n", out->revision);
+			sprom_extract_r123(out, in);
+		}
 	}
 
 	if (out->boardflags_lo == 0xFFFF)
@@ -504,11 +559,6 @@ static int sprom_extract(struct ssb_bus
 		out->boardflags_hi = 0;  /* per specs */
 
 	return 0;
-unsupported:
-	ssb_printk(KERN_WARNING PFX "Unsupported SPROM revision %d "
-		   "detected. Will extract v1\n", out->revision);
-	sprom_extract_r123(out, in);
-	return 0;
 }
 
 static int ssb_pci_sprom_get(struct ssb_bus *bus,
Index: wireless-testing/include/linux/ssb/ssb_regs.h
===================================================================
--- wireless-testing.orig/include/linux/ssb/ssb_regs.h
+++ wireless-testing/include/linux/ssb/ssb_regs.h
@@ -326,6 +326,42 @@
 #define  SSB_SPROM5_GPIOB_P3		0xFF00	/* Pin 3 */
 #define  SSB_SPROM5_GPIOB_P3_SHIFT	8
 
+/* SPROM Revision 8 */
+#define SSB_SPROM8_BFLLO		0x1084	/* Boardflags (low 16 bits) */
+#define SSB_SPROM8_BFLHI		0x1086	/* Boardflags Hi */
+#define SSB_SPROM8_IL0MAC		0x108C	/* 6 byte MAC address */
+#define SSB_SPROM8_CCODE		0x1092	/* 2 byte country code */
+#define SSB_SPROM8_ANTAVAIL		0x109C  /* Antenna available bitfields*/
+#define SSB_SPROM8_ANTAVAIL_A		0xFF00	/* A-PHY bitfield */
+#define SSB_SPROM8_ANTAVAIL_A_SHIFT	8
+#define SSB_SPROM8_ANTAVAIL_BG		0x00FF	/* B-PHY and G-PHY bitfield */
+#define SSB_SPROM8_ANTAVAIL_BG_SHIFT	0
+#define SSB_SPROM8_AGAIN01		0x109E	/* Antenna Gain (in dBm Q5.2) */
+#define  SSB_SPROM8_AGAIN0		0x00FF	/* Antenna 0 */
+#define  SSB_SPROM8_AGAIN0_SHIFT	0
+#define  SSB_SPROM8_AGAIN1		0xFF00	/* Antenna 1 */
+#define  SSB_SPROM8_AGAIN1_SHIFT	8
+#define SSB_SPROM8_AGAIN23		0x10A0
+#define  SSB_SPROM8_AGAIN2		0x00FF	/* Antenna 2 */
+#define  SSB_SPROM8_AGAIN2_SHIFT	0
+#define  SSB_SPROM8_AGAIN3		0xFF00	/* Antenna 3 */
+#define  SSB_SPROM8_AGAIN3_SHIFT	8
+#define SSB_SPROM8_GPIOA		0x1096	/*Gen. Purpose IO # 0 and 1 */
+#define  SSB_SPROM8_GPIOA_P0		0x00FF	/* Pin 0 */
+#define  SSB_SPROM8_GPIOA_P1		0xFF00	/* Pin 1 */
+#define  SSB_SPROM8_GPIOA_P1_SHIFT	8
+#define SSB_SPROM8_GPIOB		0x1098	/* Gen. Purpose IO # 2 and 3 */
+#define  SSB_SPROM8_GPIOB_P2		0x00FF	/* Pin 2 */
+#define  SSB_SPROM8_GPIOB_P3		0xFF00	/* Pin 3 */
+#define  SSB_SPROM8_GPIOB_P3_SHIFT	8
+#define SSB_SPROM8_MAXP_BG		0x10C0  /* Max Power BG in path 1 */
+#define  SSB_SPROM8_MAXP_BG_MASK	0x00FF  /* Mask for Max Power BG */
+#define  SSB_SPROM8_ITSSI_BG		0xFF00	/* Mask for path 1 itssi_bg */
+#define  SSB_SPROM8_ITSSI_BG_SHIFT	8
+#define SSB_SPROM8_MAXP_A		0x10C8  /* Max Power A in path 1 */
+#define  SSB_SPROM8_MAXP_A_MASK		0x00FF  /* Mask for Max Power A */
+#define  SSB_SPROM8_ITSSI_A		0xFF00	/* Mask for path 1 itssi_a */
+#define  SSB_SPROM8_ITSSI_A_SHIFT	8
 
 /* Values for SSB_SPROM1_BINF_CCODE */
 enum {
Index: wireless-testing/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/main.c
+++ wireless-testing/drivers/net/wireless/b43/main.c
@@ -97,6 +97,7 @@ static const struct ssb_device_id b43_ss
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 11),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 15),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 16),
 	SSB_DEVTABLE_END
 };
@@ -3757,6 +3758,12 @@ static int b43_phy_versioning(struct b43
 			unsupported = 1;
 		break;
 #endif
+#ifdef CONFIG_B43_PHY_LP
+	case B43_PHYTYPE_LP:
+		if (phy_rev > 1)
+			unsupported = 1;
+		break;
+#endif
 	default:
 		unsupported = 1;
 	};
@@ -3809,6 +3816,10 @@ static int b43_phy_versioning(struct b43
 		if (radio_ver != 0x2055 && radio_ver != 0x2056)
 			unsupported = 1;
 		break;
+	case B43_PHYTYPE_LP:
+		if (radio_ver != 0x2062)
+			unsupported = 1;
+		break;
 	default:
 		B43_WARN_ON(1);
 	}
@@ -4403,6 +4414,7 @@ static int b43_wireless_core_attach(stru
 			break;
 		case B43_PHYTYPE_G:
 		case B43_PHYTYPE_N:
+		case B43_PHYTYPE_LP:
 			have_2ghz_phy = 1;
 			break;
 		default:

-- 
Greetings, Michael.


From mb at bu3sch.de  Thu Dec 25 00:44:25 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 25 Dec 2008 00:44:25 +0100
Subject: b43legacy: My laptop has no button for rfkill but the driver sais
	it has...
In-Reply-To: <496773631@web.de>
References: <496773631@web.de>
Message-ID: <200812250044.25705.mb@bu3sch.de>

On Wednesday 24 December 2008 18:16:20 Ulf Dambacher wrote:
> And both drivers use exactly the same code to test for the rfkill button. one sais on the other sees off.

You must also honor the fact that you are running a completely different kernel.
It's _not_ that just "one driver works, but the other doesn't".
Something else in the kernel can be poking with the rfkill. Look at acpi and stuff like that.

-- 
Greetings, Michael.


From johannes at sipsolutions.net  Thu Dec 25 00:52:04 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 25 Dec 2008 00:52:04 +0100
Subject: [PATCH] b43/ssb: Add SPROM8 extraction and LP-PHY detection
In-Reply-To: <200812250039.28824.mb@bu3sch.de>
	(sfid-20081225_004044_707129_A1975627)
References: <200812250039.28824.mb@bu3sch.de>
	(sfid-20081225_004044_707129_A1975627)
Message-ID: <1230162724.3162.3.camel@johannes>

On Thu, 2008-12-25 at 00:39 +0100, Michael Buesch wrote:
> This adds detection code for the LP-PHY and SPROM
> extraction code for version 8, which is needed by the LP-PHY and
> newer N-PHY.

I still get mac address ff:ff:ff:ff:ff:ff with this, but it might just
be that we need to use a different address or something, will double
check. We can fix that, so don't take this as a nack, the patch lays the
foundation, and the devices aren't supported anyway.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081225/729ee3d9/attachment.pgp>

From johannes at sipsolutions.net  Thu Dec 25 01:05:30 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 25 Dec 2008 01:05:30 +0100
Subject: Broadcom 11n implementation
Message-ID: <1230163530.3162.10.camel@johannes>

Hey,

I hope those of you who got their presents today enjoyed that. Here's
one from me for the poor souls like myself who have a Broadcom 11n chip:

I've been publishing specifications for things we have reverse
engineered, is anyone interested in implementing this? If so, go wild,
but synchronise on the list if there are multiple people. John, I think
you had somebody who was interested, but I can't find the email right
now.

Michael has said that he might be able to help a bit (review maybe), but
won't implement the bulk of it. And I actually need this code ASAP since
I failed to replace the wireless card in my new MacBook (I couldn't even
find it).

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081225/a7bca2da/attachment.pgp>

From mb at bu3sch.de  Thu Dec 25 01:07:55 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 25 Dec 2008 01:07:55 +0100
Subject: [PATCH] b43/ssb: Add SPROM8 extraction and LP-PHY detection
In-Reply-To: <1230162724.3162.3.camel@johannes>
References: <200812250039.28824.mb@bu3sch.de>
	<1230162724.3162.3.camel@johannes>
Message-ID: <200812250107.55584.mb@bu3sch.de>

On Thursday 25 December 2008 00:52:04 Johannes Berg wrote:
> On Thu, 2008-12-25 at 00:39 +0100, Michael Buesch wrote:
> > This adds detection code for the LP-PHY and SPROM
> > extraction code for version 8, which is needed by the LP-PHY and
> > newer N-PHY.
> 
> I still get mac address ff:ff:ff:ff:ff:ff with this, but it might just
> be that we need to use a different address or something, will double
> check. We can fix that, so don't take this as a nack, the patch lays the
> foundation, and the devices aren't supported anyway.

Yep, this patch doesn't break anything that currently works.
So we can fix this later with another patch.

-- 
Greetings, Michael.


From mb at bu3sch.de  Thu Dec 25 01:15:45 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 25 Dec 2008 01:15:45 +0100
Subject: Broadcom 11n implementation
In-Reply-To: <1230163530.3162.10.camel@johannes>
References: <1230163530.3162.10.camel@johannes>
Message-ID: <200812250115.45283.mb@bu3sch.de>

On Thursday 25 December 2008 01:05:30 Johannes Berg wrote:
> Hey,
> 
> I hope those of you who got their presents today enjoyed that. Here's
> one from me for the poor souls like myself who have a Broadcom 11n chip:
> 
> I've been publishing specifications for things we have reverse
> engineered, is anyone interested in implementing this? If so, go wild,
> but synchronise on the list if there are multiple people. John, I think
> you had somebody who was interested, but I can't find the email right
> now.
> 
> Michael has said that he might be able to help a bit (review maybe), but
> won't implement the bulk of it. And I actually need this code ASAP since
> I failed to replace the wireless card in my new MacBook (I couldn't even
> find it).

Of course, I will always be available to give advise and help on the technical details.
With the recent merge of the PHY abstraction in b43 it shouldn't be that hard
anymore to understand the basics of the code. I think stuff is clearly modulised now
and fairly easy to understand, after you once understood the basics of the device.

So for implementing N-PHY, you'll basically work inside of the phy_n.c and
phy_n.h files only (maybe 98% of the work will be there).

So, you could probably look into phy_g.c to get an idea of how this could probably
look like.

Please contact us before you start writing patches, so we can give some additional
advise on coding conventions used in the driver.

-- 
Greetings, Michael.


From dreamfly281 at gmail.com  Thu Dec 25 03:35:31 2008
From: dreamfly281 at gmail.com (YanBo)
Date: Thu, 25 Dec 2008 10:35:31 +0800
Subject: Broadcom 11n implementation
In-Reply-To: <200812250115.45283.mb@bu3sch.de>
References: <1230163530.3162.10.camel@johannes>
	<200812250115.45283.mb@bu3sch.de>
Message-ID: <1197ff4c0812241835u70bb55e3i713103946148c2f1@mail.gmail.com>

On 12/25/08, Michael Buesch <mb at bu3sch.de> wrote:
> On Thursday 25 December 2008 01:05:30 Johannes Berg wrote:
>> Hey,
>>
>> I hope those of you who got their presents today enjoyed that. Here's
>> one from me for the poor souls like myself who have a Broadcom 11n chip:
>>
>> I've been publishing specifications for things we have reverse
>> engineered, is anyone interested in implementing this? If so, go wild,
>> but synchronise on the list if there are multiple people. John, I think
>> you had somebody who was interested, but I can't find the email right
>> now.
>>
>> Michael has said that he might be able to help a bit (review maybe), but
>> won't implement the bulk of it. And I actually need this code ASAP since
>> I failed to replace the wireless card in my new MacBook (I couldn't even
>> find it).
>
> Of course, I will always be available to give advise and help on the
> technical details.
> With the recent merge of the PHY abstraction in b43 it shouldn't be that
> hard
> anymore to understand the basics of the code. I think stuff is clearly
> modulised now
> and fairly easy to understand, after you once understood the basics of the
> device.
>
> So for implementing N-PHY, you'll basically work inside of the phy_n.c and
> phy_n.h files only (maybe 98% of the work will be there).
>
> So, you could probably look into phy_g.c to get an idea of how this could
> probably
> look like.
>
> Please contact us before you start writing patches, so we can give some
> additional
> advise on coding conventions used in the driver.
>
Consider the currently AGNX project in logjam cause lack of some RF
specs detail,  I think I have some time to do this. or with other guys
who also interesting with it.

Merry Christmas to everybody! :)

BR
Yanbo


From jihong.dong at gmail.com  Thu Dec 25 06:50:04 2008
From: jihong.dong at gmail.com (Jihong Dong)
Date: Wed, 24 Dec 2008 23:50:04 -0600
Subject: I am a student and want to do some research on my bcm4311 driver,
	what free kernel debugger can I use?
Message-ID: <264c53840812242150i4b543aefr4de6278fad5aeea9@mail.gmail.com>

Hello, everybody

My linux is kernel linux 2.6.27 ubuntu 8.10

I googled the internet and found out the kgdb and kdb can be used, but kgdb
only supports up to 2.6.15 and kdb, I can not download anything from its
website.

I downloaded linux2.6.15 and tried to compile it(make it), but there were
errors. OMG Any other resort? Thanks.

-Jessica
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081224/de0bbc3d/attachment.html>

From ulf.dambacher at web.de  Thu Dec 25 10:44:39 2008
From: ulf.dambacher at web.de (Ulf Dambacher)
Date: Thu, 25 Dec 2008 10:44:39 +0100
Subject: b43legacy: My laptop has no button for rfkill but the driver
	sais it has...
In-Reply-To: <200812250044.25705.mb@bu3sch.de>
References: <496773631@web.de> <200812250044.25705.mb@bu3sch.de>
Message-ID: <49535607.5070501@web.de>

Hi

Michael Buesch schrieb:
> On Wednesday 24 December 2008 18:16:20 Ulf Dambacher wrote:
>> And both drivers use exactly the same code to test for the rfkill button. one sais on the other sees off.
> 
> You must also honor the fact that you are running a completely different kernel.
> It's _not_ that just "one driver works, but the other doesn't".
> Something else in the kernel can be poking with the rfkill. Look at acpi and stuff like that.
> 
Yes, thats a point. I'll start with a 2.6.24.7 as this is a kernel with 
both drivers and I'll config it equally but for the drivers.
I'll try with minimum options first and if that works,  I'll start to 
activate all that gimmicks that fiddle with bios, acpi, dmi, smb, wms, 
i2c or dell laptops.

Hopefully I find something working. If only this system would compile 
faster ...

merry xmas and bye
Ulf


From gene.heskett at verizon.net  Thu Dec 25 11:31:26 2008
From: gene.heskett at verizon.net (Gene Heskett)
Date: Thu, 25 Dec 2008 05:31:26 -0500
Subject: b43legacy: My laptop has no button for rfkill but the
	=?iso-8859-1?q?driver=09sais_it?= has...
In-Reply-To: <49535607.5070501@web.de>
References: <496773631@web.de> <200812250044.25705.mb@bu3sch.de>
	<49535607.5070501@web.de>
Message-ID: <200812250531.26489.gene.heskett@verizon.net>

On Thursday 25 December 2008, Ulf Dambacher wrote:
>Hi
>
>Michael Buesch schrieb:
>> On Wednesday 24 December 2008 18:16:20 Ulf Dambacher wrote:
>>> And both drivers use exactly the same code to test for the rfkill button.
>>> one sais on the other sees off.
>>
>> You must also honor the fact that you are running a completely different
>> kernel. It's _not_ that just "one driver works, but the other doesn't".
>> Something else in the kernel can be poking with the rfkill. Look at acpi
>> and stuff like that.
>
>Yes, thats a point. I'll start with a 2.6.24.7 as this is a kernel with
>both drivers and I'll config it equally but for the drivers.
>I'll try with minimum options first and if that works,  I'll start to
>activate all that gimmicks that fiddle with bios, acpi, dmi, smb, wms,
>i2c or dell laptops.
>
>Hopefully I find something working. If only this system would compile
>faster ...

Look up 'ccache'.  It helps me build a new kernel in 2 to 4 minutes, depending 
on how much of it is really new.

>merry xmas and bye
>Ulf
>_______________________________________________
>Bcm43xx-dev mailing list
>Bcm43xx-dev at lists.berlios.de
>https://lists.berlios.de/mailman/listinfo/bcm43xx-dev



-- 
Cheers, Gene
"There are four boxes to be used in defense of liberty:
 soap, ballot, jury, and ammo. Please use in that order."
-Ed Howdershelt (Author)
Do nothing unless you must, and when you must act -- hesitate.


From ulf.dambacher at web.de  Fri Dec 26 21:54:53 2008
From: ulf.dambacher at web.de (Ulf Dambacher)
Date: Fri, 26 Dec 2008 21:54:53 +0100
Subject: b43legacy does not work
In-Reply-To: <49535607.5070501@web.de>
References: <496773631@web.de> <200812250044.25705.mb@bu3sch.de>
	<49535607.5070501@web.de>
Message-ID: <4955449D.70102@web.de>

Ulf Dambacher schrieb:
> Yes, thats a point. I'll start with a 2.6.24.7 as this is a kernel with 
> both drivers and I'll config it equally but for the drivers.
> I'll try with minimum options first and if that works,  I'll start to 
> activate all that gimmicks that fiddle with bios, acpi, dmi, smb, wms, 
> i2c or dell laptops.

Ok it works now, but dont ask why, Im just scrutinizing it
I need kernel 2.6.27.9 for b43legacy, 2.6.22 for bcm43xx, kernels in 
between just hang on loading the modules.

Multiple reboots and hangs later I think I have 3 different bugs to deal
with:

Bug#1: If I load the modules ( b43legacy or bcm43xx) togehter with b44
(my  network device sitting on the mainboard) the system hangs hard.
Unfortionatly this was done in the ubuntu ramdisk -until I disabled it

This happens after initializing ssb wich in tune autoloads the other
modules. Just after the  second module initializes even sysreq does not
show up anymore. I find this from  2.6.23 onward.
At manually inserting the b44 after b43legacy  I got following error 
message on console:
sbb: FATAL ERROR bus powered down while accessing PCI MMIO space
the message repeated infinitly until I hit poweroff - sysreq was not 
working.

I can get away from this for testing if I prevent modprobe from seeing
more than one  of bcm43xx.ko b43legacy.ko or b44.ko e.g. by renaming them.

tell me what information you need to track this one down...

Bug#2: something is disabling the rfkill line on my minipci card slot

@Michael Buesch: You were indeed right! Somewhere between 2.6.22 and
current the rfkill gets switched on on my laptop, I presume by some new
acpi or wmi initializing function.

The bcm4301 module is on a mini-pci card and pin 13 is the rfkill switch
input signal. The people of the madwifi project have some info about
this on their web site and they say "put selotape on this pin if nothing
else works". I did so and i could see rfkill/../state=0 with selotape 
and rfkill/../state=1 without.

BUT: in my current configurateion the UNMODIFIED driver is happy with it !!
At least did not bring the "hardware disabled" message anymore and is 
happily transmitting in either state.
I had them messages before, and I will look for what caused the 
difference in my configuration.

@Matthew Garret: I commented ou the vendor match of dell-laptop.c
(becaus my dmi sais "Dell Computer Corporation") and tried it, it loads,
but rfkill is not registered and toggeling the backlight has no effect. 
so I unloaded it.

But either the dbcbas patch or the wmi interface enabled my backlight 
toggling. Now I get fancy symbol messages on gnome if I hit the buttons 
of backlight and volume.

Bug#3:
I said I could associate but not send packets. No wonder if you get the 
web key wrong by just one digit. But there was not a single error 
message about it. just found it while diffing some command output. *GRR*

bye
Ulf



From mb at bu3sch.de  Fri Dec 26 22:25:22 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 26 Dec 2008 22:25:22 +0100
Subject: b43legacy does not work
In-Reply-To: <4955449D.70102@web.de>
References: <496773631@web.de> <49535607.5070501@web.de>
	<4955449D.70102@web.de>
Message-ID: <200812262225.22959.mb@bu3sch.de>

On Friday 26 December 2008 21:54:53 Ulf Dambacher wrote:
> At manually inserting the b44 after b43legacy  I got following error 
> message on console:
> sbb: FATAL ERROR bus powered down while accessing PCI MMIO space

I'd like to see the stackdump that follows the message.

go to drivers/ssb/pci.c and search this code:

573 static int ssb_pci_assert_buspower(struct ssb_bus *bus)
574 {
575         if (likely(bus->powered_up))
576                 return 0;
577 
578         printk(KERN_ERR PFX "FATAL ERROR: Bus powered down "
579                "while accessing PCI MMIO space\n");
580         if (bus->power_warn_count <= 10) {
581                 bus->power_warn_count++;
582                 dump_stack();
583         }
584 
585         return -ENODEV;
586 }

Add the following line just before the "return -ENODEV;":
	local_irq_disable(); while (1) cpu_relax();

Please catch the message with a digital photocamera.

-- 
Greetings, Michael.


From ulf.dambacher at web.de  Sat Dec 27 00:28:01 2008
From: ulf.dambacher at web.de (Ulf Dambacher)
Date: Sat, 27 Dec 2008 00:28:01 +0100
Subject: b43legacy does not work
In-Reply-To: <200812262225.22959.mb@bu3sch.de>
References: <496773631@web.de> <49535607.5070501@web.de>
	<4955449D.70102@web.de> <200812262225.22959.mb@bu3sch.de>
Message-ID: <49556881.9090007@web.de>

Hi Michael

I did like you wanted and wrote the following output from screen (no 
digicam at hand .-(

kernel 2.6.27.9 init=/bin/bash, no modules loaded so far

modprobe b43legacy:

ssb: Core 0 found: IEEE 802.11 (cc 0x812 rev 0x02 vendor 0x4243)
ssb: Core 1 found: PCMCIA (cc 0x80d rev 0x00 vendor 0x4243)
ssb: core 2 found: Fast Ethernet (cc 0x806 rev 0x02 vendor 0x4243)
ssb: core 3 found: V90 (cc 0x807 rev 0x01 vendor 0x4243)
ssb: core 4 found: PCI (cc 0x803 rev 0x03 vendor 0x4243)
ssb: sonics silicon backplane found on PCI device 0000:02:02.0
b43legacy-phy0: Broadcom4301 WLAN found
Broadcom 43xx-legacy driver loaded [features PLRID, Firmware-ID: FW10]

now insmod b44__.ko:

ACPI PCI INterrupt Link LNKB enabled at irq7
b44 0000:02:01.0: PCI INTA-> LNKB->GSI 7 (level,low) ->IRQ7
ssb: Core 0 found: Fast Ethernet(cc 0x806 rev 0x4 vendor 0x4243)
ssb: Core 1 found: V90 (cc 0x807 rev 0x01 vendor 0x4243)
ssb: core 2 found: PCI (cc 0x804 rev 0x02 vendor 0x4243)
ssb: sonics silicon backplane found on pci device 0000:02:01.0
b44.c: v2.0
b44: invalid mac address found in EEPROM
b44 ssb0:1: Problem fetching invariants of chip,abording
b44: Probe of ssb0:1 faild with error -22

then the system is unresponsible.

Now I did the same thing with an up and working wlan connection and
insmod b44__.ko:

...
b44 ssb0:1: Problem fetching invariants of chip,abording
b44: Probe of ssb0:1 faild with error -22
ssb: fatal error: bus powerd down while accessing PCI MMIO space
Pid:4 comm: events/0 not tainted 2.6.27.9-ud5#5
[<e0812e56>] ssb_pci_assert_buspower+0x40/0x42[ssb]
[<e08135a6>] ssb_pci_read32+0x11/0x3d [ssb]
[<e087f878>] b43legacy_interrupt_handler+0x1e/0x1f6 [b43legacy]
[<c013a25a>] handle_IRQ_event+0x25/0x4a
[<c010531a>] do_IRQ+0x44/0x78
[<c0103a3b>} common_interrupt+0x23/0x28
[<c011007b>] do_page_fault+0x2fa/0x65f
[<c0275580>] __linkwatch_run_queue+0x86/0x129
[<c0275623>] linkwatch_event+0x0/0x22
[<c0275640>] linkwatch_event+0x1d/0x22
[<c012365f>] run_workqueue+0x8b/0x103
              worker_thread
	     worker_thread
	     autoremove_wake_function
              worker_thread
              kthread
              kthread
              kernek_thread_helper
============================0


you see these are two different pci ids. maybe that's the problem?


good night and bye

Ulf

Michael Buesch schrieb:
> On Friday 26 December 2008 21:54:53 Ulf Dambacher wrote:
>> At manually inserting the b44 after b43legacy  I got following error 
>> message on console:
>> sbb: FATAL ERROR bus powered down while accessing PCI MMIO space
> 
> I'd like to see the stackdump that follows the message.
> 
> go to drivers/ssb/pci.c and search this code:
> 
> 573 static int ssb_pci_assert_buspower(struct ssb_bus *bus)
> 574 {
> 575         if (likely(bus->powered_up))
> 576                 return 0;
> 577 
> 578         printk(KERN_ERR PFX "FATAL ERROR: Bus powered down "
> 579                "while accessing PCI MMIO space\n");
> 580         if (bus->power_warn_count <= 10) {
> 581                 bus->power_warn_count++;
> 582                 dump_stack();
> 583         }
> 584 
> 585         return -ENODEV;
> 586 }
> 
> Add the following line just before the "return -ENODEV;":
> 	local_irq_disable(); while (1) cpu_relax();
> 
> Please catch the message with a digital photocamera.
> 



From mb at bu3sch.de  Sat Dec 27 00:48:20 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 27 Dec 2008 00:48:20 +0100
Subject: b43legacy does not work
In-Reply-To: <49556881.9090007@web.de>
References: <496773631@web.de> <200812262225.22959.mb@bu3sch.de>
	<49556881.9090007@web.de>
Message-ID: <200812270048.20701.mb@bu3sch.de>

On Saturday 27 December 2008 00:28:01 Ulf Dambacher wrote:
> Hi Michael
> 
> I did like you wanted and wrote the following output from screen (no 
> digicam at hand .-(
> 
> kernel 2.6.27.9 init=/bin/bash, no modules loaded so far
> 
> modprobe b43legacy:
> 
> ssb: Core 0 found: IEEE 802.11 (cc 0x812 rev 0x02 vendor 0x4243)
> ssb: Core 1 found: PCMCIA (cc 0x80d rev 0x00 vendor 0x4243)
> ssb: core 2 found: Fast Ethernet (cc 0x806 rev 0x02 vendor 0x4243)
> ssb: core 3 found: V90 (cc 0x807 rev 0x01 vendor 0x4243)
> ssb: core 4 found: PCI (cc 0x803 rev 0x03 vendor 0x4243)
> ssb: sonics silicon backplane found on PCI device 0000:02:02.0
> b43legacy-phy0: Broadcom4301 WLAN found
> Broadcom 43xx-legacy driver loaded [features PLRID, Firmware-ID: FW10]
> 
> now insmod b44__.ko:
> 
> ACPI PCI INterrupt Link LNKB enabled at irq7
> b44 0000:02:01.0: PCI INTA-> LNKB->GSI 7 (level,low) ->IRQ7
> ssb: Core 0 found: Fast Ethernet(cc 0x806 rev 0x4 vendor 0x4243)
> ssb: Core 1 found: V90 (cc 0x807 rev 0x01 vendor 0x4243)
> ssb: core 2 found: PCI (cc 0x804 rev 0x02 vendor 0x4243)
> ssb: sonics silicon backplane found on pci device 0000:02:01.0
> b44.c: v2.0
> b44: invalid mac address found in EEPROM
> b44 ssb0:1: Problem fetching invariants of chip,abording
> b44: Probe of ssb0:1 faild with error -22
> 
> then the system is unresponsible.
> 
> Now I did the same thing with an up and working wlan connection and
> insmod b44__.ko:
> 
> ...
> b44 ssb0:1: Problem fetching invariants of chip,abording
> b44: Probe of ssb0:1 faild with error -22
> ssb: fatal error: bus powerd down while accessing PCI MMIO space
> Pid:4 comm: events/0 not tainted 2.6.27.9-ud5#5
> [<e0812e56>] ssb_pci_assert_buspower+0x40/0x42[ssb]
> [<e08135a6>] ssb_pci_read32+0x11/0x3d [ssb]
> [<e087f878>] b43legacy_interrupt_handler+0x1e/0x1f6 [b43legacy]
> [<c013a25a>] handle_IRQ_event+0x25/0x4a
> [<c010531a>] do_IRQ+0x44/0x78
> [<c0103a3b>} common_interrupt+0x23/0x28
> [<c011007b>] do_page_fault+0x2fa/0x65f
> [<c0275580>] __linkwatch_run_queue+0x86/0x129
> [<c0275623>] linkwatch_event+0x0/0x22
> [<c0275640>] linkwatch_event+0x1d/0x22
> [<c012365f>] run_workqueue+0x8b/0x103
>               worker_thread
> 	     worker_thread
> 	     autoremove_wake_function
>               worker_thread
>               kthread
>               kthread
>               kernek_thread_helper
> ============================0
> 
> 
> you see these are two different pci ids. maybe that's the problem?

Ok thanks for catching the messages.
I think we have three different problems here.

1) We fail to fetch the MAC address from the ROM.
2) We crash in the MAC failure codepath.
3) We have an interrupt while the device is down.

2 and 3 are most likely trivial to fix, but 1 is a little bit strange...

Do you get other messages from ssb about the SPROM?
For example checksum-failed or something like that...

-- 
Greetings, Michael.


From mb at bu3sch.de  Sat Dec 27 00:59:34 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 27 Dec 2008 00:59:34 +0100
Subject: b43legacy does not work
In-Reply-To: <200812270048.20701.mb@bu3sch.de>
References: <496773631@web.de> <49556881.9090007@web.de>
	<200812270048.20701.mb@bu3sch.de>
Message-ID: <200812270059.35073.mb@bu3sch.de>

On Saturday 27 December 2008 00:48:20 Michael Buesch wrote:
> On Saturday 27 December 2008 00:28:01 Ulf Dambacher wrote:
> > Hi Michael
> > 
> > I did like you wanted and wrote the following output from screen (no 
> > digicam at hand .-(
> > 
> > kernel 2.6.27.9 init=/bin/bash, no modules loaded so far
> > 
> > modprobe b43legacy:
> > 
> > ssb: Core 0 found: IEEE 802.11 (cc 0x812 rev 0x02 vendor 0x4243)
> > ssb: Core 1 found: PCMCIA (cc 0x80d rev 0x00 vendor 0x4243)
> > ssb: core 2 found: Fast Ethernet (cc 0x806 rev 0x02 vendor 0x4243)
> > ssb: core 3 found: V90 (cc 0x807 rev 0x01 vendor 0x4243)
> > ssb: core 4 found: PCI (cc 0x803 rev 0x03 vendor 0x4243)
> > ssb: sonics silicon backplane found on PCI device 0000:02:02.0
> > b43legacy-phy0: Broadcom4301 WLAN found
> > Broadcom 43xx-legacy driver loaded [features PLRID, Firmware-ID: FW10]
> > 
> > now insmod b44__.ko:
> > 
> > ACPI PCI INterrupt Link LNKB enabled at irq7
> > b44 0000:02:01.0: PCI INTA-> LNKB->GSI 7 (level,low) ->IRQ7
> > ssb: Core 0 found: Fast Ethernet(cc 0x806 rev 0x4 vendor 0x4243)
> > ssb: Core 1 found: V90 (cc 0x807 rev 0x01 vendor 0x4243)
> > ssb: core 2 found: PCI (cc 0x804 rev 0x02 vendor 0x4243)
> > ssb: sonics silicon backplane found on pci device 0000:02:01.0
> > b44.c: v2.0
> > b44: invalid mac address found in EEPROM
> > b44 ssb0:1: Problem fetching invariants of chip,abording
> > b44: Probe of ssb0:1 faild with error -22
> > 
> > then the system is unresponsible.
> > 
> > Now I did the same thing with an up and working wlan connection and
> > insmod b44__.ko:
> > 
> > ...
> > b44 ssb0:1: Problem fetching invariants of chip,abording
> > b44: Probe of ssb0:1 faild with error -22
> > ssb: fatal error: bus powerd down while accessing PCI MMIO space
> > Pid:4 comm: events/0 not tainted 2.6.27.9-ud5#5
> > [<e0812e56>] ssb_pci_assert_buspower+0x40/0x42[ssb]
> > [<e08135a6>] ssb_pci_read32+0x11/0x3d [ssb]
> > [<e087f878>] b43legacy_interrupt_handler+0x1e/0x1f6 [b43legacy]
> > [<c013a25a>] handle_IRQ_event+0x25/0x4a
> > [<c010531a>] do_IRQ+0x44/0x78
> > [<c0103a3b>} common_interrupt+0x23/0x28
> > [<c011007b>] do_page_fault+0x2fa/0x65f
> > [<c0275580>] __linkwatch_run_queue+0x86/0x129
> > [<c0275623>] linkwatch_event+0x0/0x22
> > [<c0275640>] linkwatch_event+0x1d/0x22
> > [<c012365f>] run_workqueue+0x8b/0x103
> >               worker_thread
> > 	     worker_thread
> > 	     autoremove_wake_function
> >               worker_thread
> >               kthread
> >               kthread
> >               kernek_thread_helper
> > ============================0
> > 
> > 
> > you see these are two different pci ids. maybe that's the problem?
> 
> Ok thanks for catching the messages.
> I think we have three different problems here.
> 
> 1) We fail to fetch the MAC address from the ROM.
> 2) We crash in the MAC failure codepath.
> 3) We have an interrupt while the device is down.
> 
> 2 and 3 are most likely trivial to fix, but 1 is a little bit strange...
> 
> Do you get other messages from ssb about the SPROM?
> For example checksum-failed or something like that...

Are you using compat-wireless? If not, which kernel are you using excactly?
Can you also try a "make mrproper" and complete rebuild?
We have similiar things in the past due to mismatches in the data structures
when compat-wireless or some other external driver package was used.

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Sat Dec 27 03:05:25 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 26 Dec 2008 20:05:25 -0600
Subject: [PATCH] b43/ssb: Add SPROM8 extraction and LP-PHY detection
In-Reply-To: <1230162724.3162.3.camel@johannes>
References: <200812250039.28824.mb@bu3sch.de>	
	(sfid-20081225_004044_707129_A1975627)
	<1230162724.3162.3.camel@johannes>
Message-ID: <49558D65.1060008@lwfinger.net>

Johannes Berg wrote:
> On Thu, 2008-12-25 at 00:39 +0100, Michael Buesch wrote:
>> This adds detection code for the LP-PHY and SPROM
>> extraction code for version 8, which is needed by the LP-PHY and
>> newer N-PHY.
> 
> I still get mac address ff:ff:ff:ff:ff:ff with this, but it might just
> be that we need to use a different address or something, will double
> check. We can fix that, so don't take this as a nack, the patch lays the
> foundation, and the devices aren't supported anyway.

Johannes,

Could you extract the SPROM contents from /sys and send me the data? I'm nearly
completed with a pretty extensive rewrite of ssb-sprom, and I would like an
additional sample of a rev 8 device.

Thanks,

Larry


From ulf.dambacher at web.de  Sat Dec 27 09:54:36 2008
From: ulf.dambacher at web.de (Ulf Dambacher)
Date: Sat, 27 Dec 2008 09:54:36 +0100
Subject: b43legacy does not work
In-Reply-To: <200812270059.35073.mb@bu3sch.de>
References: <496773631@web.de> <49556881.9090007@web.de>
	<200812270048.20701.mb@bu3sch.de> <200812270059.35073.mb@bu3sch.de>
Message-ID: <4955ED4C.4040002@web.de>

Good morning Michael

Michael Buesch schrieb:
>>>
>>> you see these are two different pci ids. maybe that's the problem?
>> Ok thanks for catching the messages.
>> I think we have three different problems here.
>>
>> 1) We fail to fetch the MAC address from the ROM.
>> 2) We crash in the MAC failure codepath.
>> 3) We have an interrupt while the device is down.
>>
>> 2 and 3 are most likely trivial to fix, but 1 is a little bit strange...
>>
>> Do you get other messages from ssb about the SPROM?
>> For example checksum-failed or something like that...

I get this message every time I load b44 . No other messages.
Using kernel 2.6.22 and b44 version 1.01 there is no problem with the 
mac adress.
With newer kernels I sometimes saw this message, but networking 
continued to work. so maybe this is bug 2, too.

I just cheked it: booted 2.6.27.9 with init=/bin/bash
modprobe ssb (output like before)
don't load b43legacy.
modprobe mii
insmod b44.ko
hang with:

b44: invalid mac address found in EEPROM
b44 ssb0:1: Problem fetching invariants of chip,abording
b44: Probe of ssb0:1 faild with error -22

BTW: I think larry finger is on the mac problem:

> I'm nearly
> completed with a pretty extensive rewrite of ssb-sprom, and I would like an
> additional sample of a rev 8 device.


> 
> Are you using compat-wireless? If not, which kernel are you using excactly?
> Can you also try a "make mrproper" and complete rebuild?
> We have similiar things in the past due to mismatches in the data structures
> when compat-wireless or some other external driver package was used.
> 

I don't use compat-wireless - i sticked to unmodified kernels for better 
debugging.
It is a kernel 2.6.27.9 as downloaded from kernel.org
It is patched only with dell-laptop from matthew garret.
But I can do a clean compile.  What version do you like me to use? 
2.6.27.9 or 2.6.28?

bye
Ulf


From mb at bu3sch.de  Sat Dec 27 18:26:39 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 27 Dec 2008 18:26:39 +0100
Subject: [PATCH] b43: Change schedule for old-fw support removal
Message-ID: <200812271826.39910.mb@bu3sch.de>

The scheduled date for the removal of old fw support was in July 2008.
However, we're not going to remove the support unless it causes a major
headache. So change the schedule from "July 2008" to "when it causes headaches".

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Please queue for 2.6.29

Index: wireless-testing/Documentation/feature-removal-schedule.txt
===================================================================
--- wireless-testing.orig/Documentation/feature-removal-schedule.txt	2008-12-05 17:54:27.000000000 +0100
+++ wireless-testing/Documentation/feature-removal-schedule.txt	2008-12-27 15:06:55.000000000 +0100
@@ -233,13 +233,15 @@ When:	January 2009 or Linux 2.7.0, which
 Why:	Superseded by newer revisions or modules
 Who:	Jan Engelhardt <jengelh at computergmbh.de>
 
 ---------------------------
 
 What:	b43 support for firmware revision < 410
-When:	July 2008
+When:	The schedule was July 2008, but it was decided that we are going to keep the
+        code as long as there are no major maintanance headaches.
+	So it _could_ be removed _any_ time now, if it conflicts with something new.
 Why:	The support code for the old firmware hurts code readability/maintainability
 	and slightly hurts runtime performance. Bugfixes for the old firmware
 	are not provided by Broadcom anymore.
 Who:	Michael Buesch <mb at bu3sch.de>
 
 ---------------------------
Index: wireless-testing/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/main.c	2008-12-27 15:01:47.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/main.c	2008-12-27 15:10:48.000000000 +0100
@@ -1949,14 +1949,15 @@ static void b43_release_firmware(struct 
 
 static void b43_print_fw_helptext(struct b43_wl *wl, bool error)
 {
 	const char *text;
 
 	text = "You must go to "
-	       "http://linuxwireless.org/en/users/Drivers/b43#devicefirmware "
-	       "and download the latest firmware (version 4).\n";
+	       "http://wireless.kernel.org/en/users/Drivers/b43#devicefirmware "
+	       "and download the correct firmware for this driver version. "
+	       "Please carefully read all instructions on this website.\n";
 	if (error)
 		b43err(wl, text);
 	else
 		b43warn(wl, text);
 }
 
@@ -2266,14 +2267,17 @@ static int b43_upload_microcode(struct b
 				"Hardware accelerated cryptography is disabled.\n");
 			b43_print_fw_helptext(dev->wl, 0);
 		}
 	}
 
 	if (b43_is_old_txhdr_format(dev)) {
+		/* We're over the deadline, but we keep support for old fw
+		 * until it turns out to be in major conflict with something new. */
 		b43warn(dev->wl, "You are using an old firmware image. "
-			"Support for old firmware will be removed in July 2008.\n");
+			"Support for old firmware will be removed soon "
+			"(official deadline was July 2008).\n");
 		b43_print_fw_helptext(dev->wl, 0);
 	}
 
 	return 0;
 
 error:

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Sat Dec 27 19:36:16 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 27 Dec 2008 12:36:16 -0600
Subject: [PATCH] b43: Change schedule for old-fw support removal
In-Reply-To: <200812271826.39910.mb@bu3sch.de>
References: <200812271826.39910.mb@bu3sch.de>
Message-ID: <495675A0.4090602@lwfinger.net>

Michael Buesch wrote:
> The scheduled date for the removal of old fw support was in July 2008.
> However, we're not going to remove the support unless it causes a major
> headache. So change the schedule from "July 2008" to "when it causes headaches".
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

ACK.

Larry


From Larry.Finger at lwfinger.net  Mon Dec 29 16:47:40 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 29 Dec 2008 09:47:40 -0600
Subject: [PATCH] ssb-sprom: Put SPROM data in a master table and add Rev.
 8
Message-ID: <4958f11c.mP3NZnnSfHC3caXN%Larry.Finger@lwfinger.net>

Program ssb-sprom has gotten unwieldy as more versions of the SPROM have been
accommodated. As we now need to add Rev. 8 SPROMs for LP and N PHY devices, I
chose to rewrite the program now.

This patch converts the program to be driven by a table, which removes the need
for hard coding a number of revision-specific values. In fact, only two such
numbers are defined in the new header - the SPROM sizes for 128 and 440 byte
versions. Other changes include modifying the data order so that the variables
that are most likely to be changed are at the botton the list. I also removed
the SPROM revision from the list that could be modified. Changing this value
would BRICK the device. At the moment, only the first of the "per-path"
variables have been added for revisions 4, 5, and 8. As we gain more experience
with these variants, addition of new outputs may be necessary.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

 ssb_sprom.c | 1226 ++++++++++++++++++------------------------------------------
 ssb_sprom.h |   90 ++--
 2 files changed, 426 insertions(+), 890 deletions(-)

Index: ssb_sprom/ssb_sprom.c
===================================================================
--- ssb_sprom.orig/ssb_sprom.c
+++ ssb_sprom/ssb_sprom.c
@@ -3,6 +3,7 @@
   Broadcom Sonics Silicon Backplane bus SPROM data modification tool
 
   Copyright (c) 2006-2008 Michael Buesch <mb at bu3sch.de>
+  Copyright (c) 2008 Larry Finger <Larry.Finger at lwfinger.net>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -35,45 +36,237 @@ struct cmdline_args cmdargs;
 uint8_t sprom_rev;
 uint16_t sprom_size;
 
-static int value_length_map[] = { /* value to number of bits */
-	[VALUE_RAW] = 8,
-	[VALUE_SUBP] = 16,
-	[VALUE_SUBV] = 16,
-	[VALUE_PPID] = 16,
-	[VALUE_BFLHI] = 16,
-	[VALUE_BFL] = 16,
-	[VALUE_BGMAC] = -1,
-	[VALUE_ETMAC] = -1,
-	[VALUE_AMAC] = -1,
-	[VALUE_ET0PHY] = 8,
-	[VALUE_ET1PHY] = 8,
-	[VALUE_ET0MDC] = 1,
-	[VALUE_ET1MDC] = 1,
-	[VALUE_BREV] = 8,
-	[VALUE_LOC] = 4,
-	[VALUE_ANTA0] = 1,
-	[VALUE_ANTA1] = 1,
-	[VALUE_ANTBG0] = 1,
-	[VALUE_ANTBG1] = 1,
-	[VALUE_ANTGA] = 8,
-	[VALUE_ANTGBG] = 8,
-	[VALUE_PA0B0] = 16,
-	[VALUE_PA0B1] = 16,
-	[VALUE_PA0B2] = 16,
-	[VALUE_PA1B0] = 16,
-	[VALUE_PA1B1] = 16,
-	[VALUE_PA1B2] = 16,
-	[VALUE_WL0GPIO0] = 8,
-	[VALUE_WL0GPIO1] = 8,
-	[VALUE_WL0GPIO2] = 8,
-	[VALUE_WL0GPIO3] = 8,
-	[VALUE_MAXPA] = 8,
-	[VALUE_MAXPBG] = 8,
-	[VALUE_ITSSIA] = 8,
-	[VALUE_ITSSIBG] = 8,
-	[VALUE_SVER] = 8,
+/* SPROM layouts are described by the following table. The entries are as follows:
+ *
+ * uint16_t rev_mask	A bit mask of the sprom revisions that contain this data
+ * enum valuetype type	The type of datum represented by this table entry
+ * uint16_t length	The length of this datum in bits. A value of 34 means a MAC address.
+ *			A value of 33 means a 2 character country code.
+ * uint16_t offset	The offset (in bytes) from the start of the sprom.
+ * uint16_t mask	The mask needed to extract this datum from the 16-bit word.
+ * uint16_t shift	The shift needed to right align this datum.
+ * char *desc		The short character string used to describe this datum.
+ * char *label		The long character string that tells the function of this datum.
+ *
+ * The table is ended with a rev_mask of zero.
+ */
+
+static const struct var_entry sprom_table[] = {
+	{ MASK_1_8, VAL_SUBP,   16, 0x04, 0xFFFF, 0x00, "subp",    "Subsystem Product ID" },
+	{ MASK_1_8, VAL_SUBV,   16, 0x06, 0xFFFF, 0x00, "subv",    "Subsystem Vendor ID " },
+	{ MASK_1_8, VAL_PPID,   16, 0x08, 0xFFFF, 0x00, "ppid",    "PCI Product ID      " },
+	{ MASK_2_3, VAL_BFLHI,  16, 0x38, 0xFFFF, 0x00, "bflhi",   "High 16 bits of boardflags" },
+	{ MASK_4,   VAL_BFLHI,  16, 0x46, 0xFFFF, 0x00, "bflhi",   "High 16 bits of boardflags" },
+	{ MASK_5,   VAL_BFLHI,  16, 0x4C, 0xFFFF, 0x00, "bflhi",   "High 16 bits of boardflags" },
+	{ MASK_8,   VAL_BFLHI,  16, 0x86, 0xFFFF, 0x00, "bflhi",   "High 16 bits of boardflags" },
+	{ MASK_1_3, VAL_BFL,    16, 0x72, 0xFFFF, 0x00, "bfl",     "Low 16 bits of boardflags " },
+	{ MASK_4,   VAL_BFL,    16, 0x44, 0xFFFF, 0x00, "bfl",     "Low 16 bits of boardflags " },
+	{ MASK_5,   VAL_BFL,    16, 0x4A, 0xFFFF, 0x00, "bfl",     "Low 16 bits of boardflags " },
+	{ MASK_8,   VAL_BFL,    16, 0x84, 0xFFFF, 0x00, "bfl",     "Low 16 bits of boardflags " },
+	{ MASK_1_2, VAL_BGMAC,  34, 0x48, 0xFFFF, 0x00, "bgmac",   "MAC Address for 802.11b/g" },
+	{ MASK_3,   VAL_BGMAC,  34, 0x4A, 0xFFFF, 0x00, "bgmac",   "MAC Address for 802.11b/g" },
+	{ MASK_4,   VAL_BGMAC,  34, 0x4C, 0xFFFF, 0x00, "macadr",  "MAC Address" },
+	{ MASK_5,   VAL_BGMAC,  34, 0x52, 0xFFFF, 0x00, "macadr",  "MAC Address" },
+	{ MASK_8,   VAL_BGMAC,  34, 0x8C, 0xFFFF, 0x00, "macadr",  "MAC Address" },
+	{ MASK_1_2, VAL_ETMAC,  34, 0x4E, 0xFFFF, 0x00, "etmac",   "MAC Address for ethernet " },
+	{ MASK_1_2, VAL_AMAC,   34, 0x54, 0xFFFF, 0x00, "amac",    "MAC Address for 802.11a  " },
+	{ MASK_1_3, VAL_ET0PHY,  5, 0x5A, 0x001F, 0x00, "et0phy",  "Ethernet phy settings(0)" },
+	{ MASK_1_3, VAL_ET1PHY,  5, 0x5A, 0x03E0, 0x05, "et1phy",  "Ethernet phy settings(1)" },
+	{ MASK_1_3, VAL_ET0MDC,  1, 0x5A, 0x4000, 0x0E, "et0mdc",  "MDIO for ethernet 0" },
+	{ MASK_1_3, VAL_ET1MDC,  1, 0x5A, 0x8000, 0x0F, "et1mdc",  "MDIO for ethernet 1" },
+	{ MASK_1_3, VAL_BREV,    8, 0x5C, 0x00FF, 0x00, "brev",    "Board revision" },
+	{ MASK_4_5, VAL_BREV,    8, 0x42, 0x00FF, 0x00, "brev",    "Board revision" },
+	{ MASK_8,   VAL_BREV,    8, 0x82, 0x00FF, 0x00, "brev",    "Board revision" },
+	{ MASK_1_3, VAL_LOC,     4, 0x5C, 0x0300, 0x08, "loc",     "Locale / Country Code" },
+	{ MASK_4,   VAL_LOC,    33, 0x52, 0xFFFF, 0x00, "ccode",   "Country Code" },
+	{ MASK_5,   VAL_LOC,    33, 0x44, 0xFFFF, 0x00, "ccode",   "Country Code" },
+	{ MASK_8,   VAL_LOC,    33, 0x92, 0xFFFF, 0x00, "ccode",   "Country Code" },
+	{ MASK_4_5, VAL_REGREV, 16, 0x54, 0xFFFF, 0x00, "regrev",  "Regulatory revision" },
+	{ MASK_8,   VAL_REGREV, 16, 0x94, 0xFFFF, 0x00, "regrev",  "Regulatory revision" },
+	{ MASK_1_3, VAL_ANTBG0,  1, 0x5C, 0x1000, 0x0C, "antbg0",  "Antenna 0 available for B/G PHY" },
+	{ MASK_1_3, VAL_ANTBG1,  1, 0x5C, 0x2000, 0x0D, "antbg1",  "Antenna 1 available for B/G PHY" },
+	{ MASK_1_3, VAL_ANTA0,   1, 0x5C, 0x4000, 0x0E, "anta0",   "Antenna 0 available for A PHY" },
+	{ MASK_1_3, VAL_ANTA1,   1, 0x5C, 0x8000, 0x0F, "anta1",   "Antenna 1 available for A PHY" },
+	{ MASK_4_5, VAL_ANTBG0,  8, 0x5C, 0x00FF, 0x00, "antbg0",  "Available antenna bitmask for 2 GHz" },
+	{ MASK_8,   VAL_ANTBG0,  8, 0x9C, 0x00FF, 0x00, "antbg0",  "Available antenna bitmask for 2 GHz" },
+	{ MASK_4_5, VAL_ANTA0,   8, 0x5C, 0xFF00, 0x08, "anta0",   "Available antenna bitmask for 5 GHz" },
+	{ MASK_8,   VAL_ANTA0,   8, 0x9C, 0xFF00, 0x08, "anta0",   "Available antenna bitmask for 5 GHz" },
+	{ MASK_1_3, VAL_ANTGA,   8, 0x74, 0xFF00, 0x08, "antga" ,  "Antenna gain (5 GHz)" },
+	{ MASK_1_3, VAL_ANTGBG,  8, 0x74, 0x00FF, 0x00, "antgbg",  "Antenna gain (2 GHz)" },
+	{ MASK_4_5, VAL_ANTG0,   8, 0x5E, 0x00FF, 0x00, "antg0",   "Antenna 0 gain" },
+	{ MASK_4_5, VAL_ANTG1,   8, 0x5E, 0xFF00, 0x08, "antg1",   "Antenna 1 gain" },
+	{ MASK_4_5, VAL_ANTG2,   8, 0x60, 0x00FF, 0x00, "antg2",   "Antenna 2 gain" },
+	{ MASK_4_5, VAL_ANTG3,   8, 0x60, 0xFF00, 0x08, "antg3",   "Antenna 3 gain" },
+	{ MASK_8,   VAL_ANTG0,   8, 0x9E, 0x00FF, 0x00, "antg0",   "Antenna 0 gain" },
+	{ MASK_8,   VAL_ANTG1,   8, 0x9E, 0xFF00, 0x08, "antg1",   "Antenna 1 gain" },
+	{ MASK_8,   VAL_ANTG2,   8, 0xA0, 0x00FF, 0x00, "antg2",   "Antenna 2 gain" },
+	{ MASK_8,   VAL_ANTG3,   8, 0xA0, 0xFF00, 0x08, "antg3",   "Antenna 3 gain" },
+	{ MASK_1_3, VAL_PA0B0,  16, 0x5E, 0xFFFF, 0x00, "pa0b0",   "Power Amplifier W0 PAB0" },
+	{ MASK_1_3, VAL_PA0B1,  16, 0x60, 0xFFFF, 0x00, "pa0b1",   "Power Amplifier W0 PAB1" },
+	{ MASK_1_3, VAL_PA0B2,  16, 0x62, 0xFFFF, 0x00, "pa0b2",   "Power Amplifier W0 PAB2" },
+	{ MASK_1_3, VAL_PA1B0,  16, 0x6A, 0xFFFF, 0x00, "pa1b0",   "Power Amplifier W1 PAB0" },
+	{ MASK_1_3, VAL_PA1B1,  16, 0x6C, 0xFFFF, 0x00, "pa1b1",   "Power Amplifier W1 PAB1" },
+	{ MASK_1_3, VAL_PA1B2,  16, 0x6E, 0xFFFF, 0x00, "pa1b2",   "Power Amplifier W1 PAB2" },
+	{ MASK_1_3, VAL_LED0,    8, 0x64, 0x00FF, 0x00, "led0",    "LED 0 behavior" },
+	{ MASK_1_3, VAL_LED1,    8, 0x64, 0xFF00, 0x08, "led1",    "LED 1 behavior" },
+	{ MASK_1_3, VAL_LED2,    8, 0x66, 0x00FF, 0x00, "led2",    "LED 2 behavior" },
+	{ MASK_1_3, VAL_LED3,    8, 0x66, 0xFF00, 0x08, "led3",    "LED 3 behavior" },
+	{ MASK_4,   VAL_LED0,    8, 0x56, 0x00FF, 0x00, "led0",    "LED 0 behavior" },
+	{ MASK_4,   VAL_LED1,    8, 0x56, 0xFF00, 0x08, "led1",    "LED 1 behavior" },
+	{ MASK_4,   VAL_LED2,    8, 0x58, 0x00FF, 0x00, "led2",    "LED 2 behavior" },
+	{ MASK_4,   VAL_LED3,    8, 0x58, 0xFF00, 0x08, "led3",    "LED 3 behavior" },
+	{ MASK_5,   VAL_LED0,    8, 0x76, 0x00FF, 0x00, "led0",    "LED 0 behavior" },
+	{ MASK_5,   VAL_LED1,    8, 0x76, 0xFF00, 0x08, "led1",    "LED 1 behavior" },
+	{ MASK_5,   VAL_LED2,    8, 0x78, 0x00FF, 0x00, "led2",    "LED 2 behavior" },
+	{ MASK_5,   VAL_LED3,    8, 0x78, 0xFF00, 0x08, "led3",    "LED 3 behavior" },
+	{ MASK_1_3, VAL_MAXPBG,  8, 0x68, 0x00FF, 0x00, "maxpbg",  "B/G PHY max power out" },
+	{ MASK_4_5, VAL_MAXPBG,  8, 0x80, 0x00FF, 0x00, "maxpbg",  "Max power 2GHz - Path 1" },
+	{ MASK_8,   VAL_MAXPBG,  8, 0xC0, 0x00FF, 0x00, "maxpbg",  "Max power 2GHz - Path 1" },
+	{ MASK_1_3, VAL_MAXPA,   8, 0x68, 0xFF00, 0x08, "maxpa",   "A PHY max power out  " },
+	{ MASK_4_5, VAL_MAXPA,   8, 0x8A, 0x00FF, 0x00, "maxpa",   "Max power 5GHz - Path 1" },
+	{ MASK_8,   VAL_MAXPA,   8, 0xCA, 0xFF00, 0x08, "maxpa",   "Max power 5GHz - Path 1" },
+	{ MASK_1_3, VAL_ITSSIBG, 8, 0x70, 0x00FF, 0x00, "itssibg", "Idle TSSI target 2 GHz" },
+	{ MASK_1_3, VAL_ITSSIA,  8, 0x70, 0xFF00, 0x08, "itssia",  "Idle TSSI target 5 GHz" },
+	{ MASK_4_5, VAL_ITSSIBG, 8, 0x80, 0xFF00, 0x08, "itssibg", "Idle TSSI target 2 GHz - Path 1" },
+	{ MASK_4_5, VAL_ITSSIA,  8, 0x8A, 0xFF00, 0x08, "itssia",  "Idle TSSI target 5 GHz - Path 1" },
+	{ MASK_8,   VAL_ITSSIBG, 8, 0xC0, 0xFF00, 0x08, "itssibg", "Idle TSSI target 2 GHz - Path 1" },
+	{ MASK_8,   VAL_ITSSIA,  8, 0xCA, 0xFF00, 0x08, "itssia",  "Idle TSSI target 5 GHz - Path 1" },
+	{ MASK_8,   VAL_TPI2G0, 16, 0x62, 0xFFFF, 0x00, "tpi2g0",  "TX Power Index 2GHz" },
+	{ MASK_8,   VAL_TPI2G1, 16, 0x64, 0xFFFF, 0x00, "tpi2g1",  "TX Power Index 2GHz" },
+	{ MASK_8,   VAL_TPI5GM0,16, 0x66, 0xFFFF, 0x00, "tpi5gm0", "TX Power Index 5GHz middle subband" },
+	{ MASK_8,   VAL_TPI5GM1,16, 0x68, 0xFFFF, 0x00, "tpi5gm1", "TX Power Index 5GHz middle subband" },
+	{ MASK_8,   VAL_TPI5GL0,16, 0x6A, 0xFFFF, 0x00, "tpi5gl0", "TX Power Index 5GHz low subband   " },
+	{ MASK_8,   VAL_TPI5GL1,16, 0x6C, 0xFFFF, 0x00, "tpi5gl1", "TX Power Index 5GHz low subband   " },
+	{ MASK_8,   VAL_TPI5GH0,16, 0x6E, 0xFFFF, 0x00, "tpi5gh0", "TX Power Index 5GHz high subband  " },
+	{ MASK_8,   VAL_TPI5GH1,16, 0x70, 0xFFFF, 0x00, "tpi5gh1", "TX Power Index 5GHz high subband  " },
+	{ MASK_8,   VAL_2CCKPO, 16, 0x140,0xFFFF, 0x00, "cckpo2g", "2 GHz CCK power offset " },
+	{ MASK_8,   VAL_2OFDMPO,32, 0x142,0xFFFF, 0x00, "ofdm2g",  "2 GHz OFDM power offset" },
+	{ MASK_8,   VAL_5MPO,   32, 0x146,0xFFFF, 0x00, "ofdm5gm", "5 GHz OFDM middle subband power offset" },
+	{ MASK_8,   VAL_5LPO,   32, 0x14A,0xFFFF, 0x00, "ofdm5gl", "5 GHz OFDM low subband power offset   " },
+	{ MASK_8,   VAL_5HPO,   32, 0x14E,0xFFFF, 0x00, "ofdm5gh", "5 GHz OFDM high subband power offset  " },
+	{ MASK_8,   VAL_2MCSPO, 16, 0x152,0xFFFF, 0x00, "mcspo2",  "2 GHz MCS power offset" },
+	{ MASK_8,   VAL_5MMCSPO,16, 0x162,0xFFFF, 0x00, "mcspo5m", "5 GHz middle subband MCS power offset" },
+	{ MASK_8,   VAL_5LMCSPO,16, 0x172,0xFFFF, 0x00, "mcspo5l", "5 GHz low subband MCS power offset   " },
+	{ MASK_8,   VAL_5HMCSPO,16, 0x182,0xFFFF, 0x00, "mcspo5h", "5 GHz high subband MCS power offset  " },
+	{ MASK_8,   VAL_CCDPO,  16, 0x192,0xFFFF, 0x00, "ccdpo",   "CCD power offset  " },
+	{ MASK_8,   VAL_STBCPO, 16, 0x194,0xFFFF, 0x00, "stbcpo",  "STBC power offset " },
+	{ MASK_8,   VAL_BW40PO, 16, 0x196,0xFFFF, 0x00, "bw40po",  "BW40 power offset " },
+	{ MASK_8,   VAL_BWDUPPO,16, 0x198,0xFFFF, 0x00, "bwduppo", "BWDUP power offset" },
+	{ MASK_4_5, VAL_TPI2G0, 16, 0x62, 0xFFFF, 0x00, "tpi2g0",  "TX Power Index 2GHz" },
+	{ MASK_4_5, VAL_TPI2G1, 16, 0x64, 0xFFFF, 0x00, "tpi2g1",  "TX Power Index 2GHz" },
+	{ MASK_4_5, VAL_TPI5GM0,16, 0x66, 0xFFFF, 0x00, "tpi5gm0", "TX Power Index 5GHz middle subband" },
+	{ MASK_4_5, VAL_TPI5GM1,16, 0x68, 0xFFFF, 0x00, "tpi5gm1", "TX Power Index 5GHz middle subband" },
+	{ MASK_4_5, VAL_TPI5GL0,16, 0x6A, 0xFFFF, 0x00, "tpi5gl0", "TX Power Index 5GHz low subband   " },
+	{ MASK_4_5, VAL_TPI5GL1,16, 0x6C, 0xFFFF, 0x00, "tpi5gl1", "TX Power Index 5GHz low subband   " },
+	{ MASK_4_5, VAL_TPI5GH0,16, 0x6E, 0xFFFF, 0x00, "tpi5gh0", "TX Power Index 5GHz high subband  " },
+	{ MASK_4_5, VAL_TPI5GH1,16, 0x70, 0xFFFF, 0x00, "tpi5gh1", "TX Power Index 5GHz high subband  " },
+	{ MASK_4_5, VAL_2CCKPO, 16, 0x138,0xFFFF, 0x00, "cckpo2g", "2 GHz CCK power offset " },
+	{ MASK_4_5, VAL_2OFDMPO,32, 0x13A,0xFFFF, 0x00, "ofdm2g",  "2 GHz OFDM power offset" },
+	{ MASK_4_5, VAL_5MPO,   32, 0x13E,0xFFFF, 0x00, "ofdm5gm", "5 GHz OFDM middle subband power offset" },
+	{ MASK_4_5, VAL_5LPO,   32, 0x142,0xFFFF, 0x00, "ofdm5gl", "5 GHz OFDM low subband power offset   " },
+	{ MASK_4_5, VAL_5HPO,   32, 0x146,0xFFFF, 0x00, "ofdm5gh", "5 GHz OFDM high subband power offset  " },
+	{ MASK_4_5, VAL_2MCSPO, 16, 0x14A,0xFFFF, 0x00, "mcspo2",  "2 GHz MCS power offset" },
+	{ MASK_4_5, VAL_5MMCSPO,16, 0x15A,0xFFFF, 0x00, "mcspo5m", "5 GHz middle subband MCS power offset" },
+	{ MASK_4_5, VAL_5LMCSPO,16, 0x16A,0xFFFF, 0x00, "mcspo5l", "5 GHz low subband MCS power offset   " },
+	{ MASK_4_5, VAL_5HMCSPO,16, 0x17A,0xFFFF, 0x00, "mcspo5h", "5 GHz high subband MCS power offset  " },
+	{ MASK_4_5, VAL_CCDPO,  16, 0x18A,0xFFFF, 0x00, "ccdpo",   "CCD power offset  " },
+	{ MASK_4_5, VAL_STBCPO, 16, 0x18C,0xFFFF, 0x00, "stbcpo",  "STBC power offset " },
+	{ MASK_4_5, VAL_BW40PO, 16, 0x18E,0xFFFF, 0x00, "bw40po",  "BW40 power offset " },
+	{ MASK_4_5, VAL_BWDUPPO,16, 0x190,0xFFFF, 0x00, "bwduppo", "BWDUP power offset" },
+	/* per path variables are below here - only path 1 decoded for now */
+	{ MASK_4_5, VAL_PA0B0,  16, 0xC2, 0xFFFF, 0x00, "pa0b0",   "Path 1: Power Amplifier W0 PAB0" },
+	{ MASK_4_5, VAL_PA0B1,  16, 0xC4, 0xFFFF, 0x00, "pa0b1",   "Path 1: Power Amplifier W0 PAB1" },
+	{ MASK_4_5, VAL_PA0B2,  16, 0xC6, 0xFFFF, 0x00, "pa0b2",   "Path 1: Power Amplifier W0 PAB2" },
+	{ MASK_4_5, VAL_PA0B3,  16, 0xC8, 0xFFFF, 0x00, "pa0b3",   "Path 1: Power Amplifier W0 PAB3" },
+	{ MASK_4_5, VAL_PA1B0,   8, 0xCC, 0x00FF, 0x00, "pam5h",   "Path 1: 5 GHz high subband PAM " },
+	{ MASK_4_5, VAL_PA1B0,   8, 0xCC, 0xFF00, 0x08, "pam5l",   "Path 1: 5 GHz low subband PAM  " },
+	{ MASK_4_5, VAL_5MPA0,  16, 0xCE, 0xFFFF, 0x00, "pa5m0",   "Path 1: 5 GHz Power Amplifier middle 0" },
+	{ MASK_4_5, VAL_5MPA1,  16, 0xD0, 0xFFFF, 0x00, "pa5m1",   "Path 1: 5 GHz Power Amplifier middle 1" },
+	{ MASK_4_5, VAL_5MPA2,  16, 0xD2, 0xFFFF, 0x00, "pa5m2",   "Path 1: 5 GHz Power Amplifier middle 2" },
+	{ MASK_4_5, VAL_5MPA3,  16, 0xD4, 0xFFFF, 0x00, "pa5m3",   "Path 1: 5 GHz Power Amplifier middle 3" },
+	{ MASK_4_5, VAL_5LPA0,  16, 0xD6, 0xFFFF, 0x00, "pa5l0",   "Path 1: 5 GHz Power Amplifier low 0   " },
+	{ MASK_4_5, VAL_5LPA1,  16, 0xD8, 0xFFFF, 0x00, "pa5l1",   "Path 1: 5 GHz Power Amplifier low 1   " },
+	{ MASK_4_5, VAL_5LPA2,  16, 0xDA, 0xFFFF, 0x00, "pa5l2",   "Path 1: 5 GHz Power Amplifier low 2   " },
+	{ MASK_4_5, VAL_5LPA3,  16, 0xDC, 0xFFFF, 0x00, "pa5l3",   "Path 1: 5 GHz Power Amplifier low 3   " },
+	{ MASK_4_5, VAL_5HPA0,  16, 0xDE, 0xFFFF, 0x00, "pa5h0",   "Path 1: 5 GHz Power Amplifier high 0  " },
+	{ MASK_4_5, VAL_5HPA1,  16, 0xE0, 0xFFFF, 0x00, "pa5h1",   "Path 1: 5 GHz Power Amplifier high 1  " },
+	{ MASK_4_5, VAL_5HPA2,  16, 0xE2, 0xFFFF, 0x00, "pa5h2",   "Path 1: 5 GHz Power Amplifier high 2  " },
+	{ MASK_4_5, VAL_5HPA3,  16, 0xE4, 0xFFFF, 0x00, "pa5h3",   "Path 1: 5 GHz Power Amplifier high 3  " },
+	{ MASK_8,   VAL_PA0B0,  16, 0xC2, 0xFFFF, 0x00, "pa0b0",   "SISO (Path 1) Power Amplifier W0 PAB0" },
+	{ MASK_8,   VAL_PA0B1,  16, 0xC4, 0xFFFF, 0x00, "pa0b1",   "SISO (Path 1) Power Amplifier W0 PAB1" },
+	{ MASK_8,   VAL_PA0B2,  16, 0xC6, 0xFFFF, 0x00, "pa0b2",   "SISO (Path 1) Power Amplifier W0 PAB2" },
+	{ MASK_8,   VAL_PA1B0,  16, 0xCC, 0xFFFF, 0x00, "pa5m0",   "SISO (Path 1) 5 GHz Power Amplifier middle 0" },
+	{ MASK_8,   VAL_PA1B1,  16, 0xCE, 0xFFFF, 0x00, "pa5m1",   "SISO (Path 1) 5 GHz Power Amplifier middle 1" },
+	{ MASK_8,   VAL_PA1B2,  16, 0xD0, 0xFFFF, 0x00, "pa5m2",   "SISO (Path 1) 5 GHz Power Amplifier middle 2" },
+	{ MASK_8,   VAL_5MPA0,  16, 0xD2, 0xFFFF, 0x00, "pa5l0",   "SISO (Path 1) 5 GHz Power Amplifier low 0   " },
+	{ MASK_8,   VAL_5MPA1,  16, 0xD4, 0xFFFF, 0x00, "pa5l1",   "SISO (Path 1) 5 GHz Power Amplifier low 1   " },
+	{ MASK_8,   VAL_5MPA2,  16, 0xD6, 0xFFFF, 0x00, "pa5l2",   "SISO (Path 1) 5 GHz Power Amplifier low 2   " },
+	{ MASK_8,   VAL_5LPA0,  16, 0xD8, 0xFFFF, 0x00, "pa5h0",   "SISO (Path 1) 5 GHz Power Amplifier high 0  " },
+	{ MASK_8,   VAL_5LPA1,  16, 0xDA, 0xFFFF, 0x00, "pa5h1",   "SISO (Path 1) 5 GHz Power Amplifier high 1  " },
+	{ MASK_8,   VAL_5LPA2,  16, 0xDC, 0xFFFF, 0x00, "pa5h2",   "SISO (Path 1) 5 GHz Power Amplifier high 2  " },
+
+	{ 0, },
 };
 
+/* find an item in the table by sprom revision and short description
+ * returns length and type. The function value is -1 if the item is not
+ * found, otherwise 0.
+ */
+
+static int locate_item_by_desc(int rev, enum valuetype *type, uint16_t *length, char *desc)
+{
+	int i;
+
+	for (i = 0; ; i++) {
+		if (sprom_table[i].rev_mask == 0)
+			return -1;	/* end of table */
+		if ((sprom_table[i].rev_mask & rev) &&
+		     (!strcmp(sprom_table[i].desc, desc))) {
+		/* this is the record we want */
+			*length = sprom_table[i].length;
+			*type = sprom_table[i].type;
+			return 0;
+		}
+	}
+	return -1; /* flow cannot reach here, but this statement makes gcc happy */
+}
+
+/* find an item in the table by sprom revision and type
+ * return length, offset, mask, shift, desc, and label
+ * The function returns -1 if no item matches the request.
+ */
+
+static int locate_item_rev(int rev, enum valuetype type, uint16_t *length, uint16_t *offset,
+			   uint16_t *mask, uint16_t *shift, char *desc, char *label)
+{
+	int i;
+
+	for (i = 0; ; i++) {
+		if (sprom_table[i].rev_mask == 0)
+			return -1;	/* end of table */
+		if ((sprom_table[i].rev_mask & rev) &&
+		     (sprom_table[i].type == type)) {
+		/* this is the record we want */
+			*length = sprom_table[i].length;
+			*offset = sprom_table[i].offset;
+			*mask = sprom_table[i].mask;
+			*shift = sprom_table[i].shift;
+			strcpy(desc, sprom_table[i].desc);
+			strcpy(label, sprom_table[i].label);
+			return 0;
+		}
+	}
+	return -1; /* flow cannot reach here, but this statement makes gcc happy */
+}
+
+static int check_rev(uint16_t rev)
+{
+	if ((rev < 0) || (rev > 8) || (rev == 6) || (rev == 7)) {
+		prerror("\nIllegal value for sprom_rev\n");
+		return -1;
+	}
+	return 0;
+}
 
 static int hexdump_sprom(const uint8_t *sprom, char *buffer, size_t bsize)
 {
@@ -150,216 +343,56 @@ static int write_output(int fd, const ui
 static int modify_value(uint8_t *sprom,
 			struct cmdline_vparm *vparm)
 {
-	const uint16_t v = vparm->u.value;
+	const uint32_t v = vparm->u.value;
 	uint16_t tmp = 0;
 	uint16_t offset;
+	char desc[100];
+	char label[200];
+	uint16_t length;
+	uint16_t mask;
+	uint16_t shift;
+	uint16_t old_value;
+	uint32_t value = 0;
+
+	int rev_bit = BIT(sprom_rev);
 
-	switch (vparm->type) {
-	case VALUE_RAW:
+
+	if (vparm->type == VAL_RAW) {
 		sprom[vparm->u.raw.offset] = vparm->u.raw.value;
-		break;
-	case VALUE_SUBP:
-		if (sprom_rev == 4)
-			offset = SPROM4_SUBP;
-		else
-			offset = SPROM_SUBP;
-		sprom[offset + 0] = (v & 0x00FF);
-		sprom[offset + 1] = (v & 0xFF00) >> 8;
-		break;
-	case VALUE_SUBV:
-		sprom[SPROM_SUBV + 0] = (v & 0x00FF);
-		sprom[SPROM_SUBV + 1] = (v & 0xFF00) >> 8;
-		break;
-	case VALUE_PPID:
-		if (sprom_rev == 4)
-			offset = SPROM4_PPID;
-		else
-			offset = SPROM_PPID;
-		sprom[offset + 0] = (v & 0x00FF);
-		sprom[offset + 1] = (v & 0xFF00) >> 8;
-		break;
-	case VALUE_BFLHI:
-		sprom[SPROM_BFLHI + 0] = (v & 0x00FF);
-		sprom[SPROM_BFLHI + 1] = (v & 0xFF00) >> 8;
-		break;
-	case VALUE_BFL:
-		sprom[SPROM_BOARDFLAGS + 0] = (v & 0x00FF);
-		sprom[SPROM_BOARDFLAGS + 1] = (v & 0xFF00) >> 8;
-		break;
-	case VALUE_BGMAC:
-		if (sprom_rev == 3)
-			offset = SPROM3_IL0MACADDR;
-		else if (sprom_rev == 4)
-			offset = SPROM4_IL0MACADDR;
-		else
-			offset = SPROM_IL0MACADDR;
-		sprom[offset + 1] = vparm->u.mac[0];
-		sprom[offset + 0] = vparm->u.mac[1];
-		sprom[offset + 3] = vparm->u.mac[2];
-		sprom[offset + 2] = vparm->u.mac[3];
-		sprom[offset + 5] = vparm->u.mac[4];
-		sprom[offset + 4] = vparm->u.mac[5];
-		break;
-	case VALUE_ETMAC:
-		if (sprom_rev == 3)
-			offset = SPROM3_ET0MACADDR;
-		else if (sprom_rev == 4)
-			offset = SPROM4_ET0MACADDR;
-		else
-			offset = SPROM_ET0MACADDR;
-		sprom[offset + 1] = vparm->u.mac[0];
-		sprom[offset + 0] = vparm->u.mac[1];
-		sprom[offset + 3] = vparm->u.mac[2];
-		sprom[offset + 2] = vparm->u.mac[3];
-		sprom[offset + 5] = vparm->u.mac[4];
-		sprom[offset + 4] = vparm->u.mac[5];
-		break;
-	case VALUE_AMAC:
-		if (sprom_rev == 3)
-			offset = SPROM3_ET1MACADDR;
-		else if (sprom_rev == 4)
-			offset = SPROM4_ET1MACADDR;
-		else
-			offset = SPROM_ET1MACADDR;
+		return 0;
+	}
+	if (locate_item_rev(rev_bit, vparm->type, &length, &offset, &mask,
+			    &shift, desc, label))
+		return -1;
+
+	if (length < 32) {
+		old_value = sprom[offset + 0];
+		old_value |= sprom[offset + 1] << 8;
+		if (length < 16) {
+			tmp = v << shift;
+			value = (old_value & ~mask) | tmp;
+		} else
+			value = v;
+		sprom[offset + 0] = (value & 0x00FF);
+		sprom[offset + 1] = (value & 0xFF00) >> 8;
+	} else if (length == 32) {
+		value = v;
+		sprom[offset + 0] = (value & 0x00FF);
+		sprom[offset + 1] = (value >> 8) & 0xFF;
+		sprom[offset + 2] = (value >> 16) & 0xFF;
+		sprom[offset + 3] = (value >> 24) & 0xFF;
+	} else if (length == 34) { /* MAC address */
 		sprom[offset + 1] = vparm->u.mac[0];
 		sprom[offset + 0] = vparm->u.mac[1];
 		sprom[offset + 3] = vparm->u.mac[2];
 		sprom[offset + 2] = vparm->u.mac[3];
 		sprom[offset + 5] = vparm->u.mac[4];
 		sprom[offset + 4] = vparm->u.mac[5];
-		break;
-	case VALUE_ET0PHY:
-		tmp |= sprom[SPROM_ETHPHY + 0];
-		tmp |= sprom[SPROM_ETHPHY + 1] << 8;
-		tmp = ((tmp & 0x001F) | (v & 0x1F));
-		sprom[SPROM_ETHPHY + 0] = (tmp & 0x00FF);
-		sprom[SPROM_ETHPHY + 1] = (tmp & 0xFF00) >> 8;
-		break;
-	case VALUE_ET1PHY:
-		tmp |= sprom[SPROM_ETHPHY + 0];
-		tmp |= sprom[SPROM_ETHPHY + 1] << 8;
-		tmp = ((tmp & 0x03E0) | ((v & 0x1F) << 5));
-		sprom[SPROM_ETHPHY + 0] = (tmp & 0x00FF);
-		sprom[SPROM_ETHPHY + 1] = (tmp & 0xFF00) >> 8;
-		break;
-	case VALUE_ET0MDC:
-		sprom[SPROM_ETHPHY + 1] &= ~(1 << 6);
-		if (v)
-			sprom[SPROM_ETHPHY + 1] |= (1 << 6);
-		break;
-	case VALUE_ET1MDC:
-		sprom[SPROM_ETHPHY + 1] &= ~(1 << 7);
-		if (v)
-			sprom[SPROM_ETHPHY + 1] |= (1 << 7);
-		break;
-	case VALUE_BREV:
-		if (sprom_rev == 4)
-			sprom[SPROM4_BOARDREV + 0] = v;
-		else
-			sprom[SPROM_BOARDREV + 0] = v;
-		break;
-	case VALUE_LOC:
-		tmp = (sprom[SPROM_BOARDREV + 1] & 0xF0);
-		tmp |= (v & 0x0F);
-		sprom[SPROM_BOARDREV + 1] = (tmp & 0xFF);
-		break;
-	case VALUE_ANTA0:
-		if (sprom_rev == 4)
-			sprom[SPROM4_BOARDREV + 1] &= ~(1 << 6);
-		else
-			sprom[SPROM_BOARDREV + 1] &= ~(1 << 6);
-		if (v) {
-			if (sprom_rev == 4) {
-				if (sprom_rev == 4)
-					sprom[SPROM4_BOARDREV + 1] |= ~(1 << 6);
-				else
-					sprom[SPROM_BOARDREV + 1] |= (1 << 6);
-			}
-		}
-		break;
-	case VALUE_ANTA1:
-		sprom[SPROM_BOARDREV + 1] &= ~(1 << 7);
-		if (v)
-			sprom[SPROM_BOARDREV + 1] |= (1 << 7);
-		break;
-	case VALUE_ANTBG0:
-		sprom[SPROM_BOARDREV + 1] &= ~(1 << 4);
-		if (v)
-			sprom[SPROM_BOARDREV + 1] |= (1 << 4);
-		break;
-	case VALUE_ANTBG1:
-		sprom[SPROM_BOARDREV + 1] &= ~(1 << 5);
-		if (v)
-			sprom[SPROM_BOARDREV + 1] |= (1 << 5);
-		break;
-	case VALUE_ANTGA:
-		if (sprom_rev != 4)
-			sprom[SPROM_ANTENNA_GAIN + 1] = (v & 0xFF);
-		else
-			sprom[SPROM4_ANTENNA_GAIN + 1] = (v & 0xFF);
-		break;
-	case VALUE_ANTGBG:
-		if (sprom_rev != 4)
-			sprom[SPROM_ANTENNA_GAIN] = (v & 0xFF);
-		else
-			sprom[SPROM4_ANTENNA_GAIN] = (v & 0xFF);
-		break;
-	case VALUE_PA0B0:
-		sprom[SPROM_PA0B0 + 0] = (v & 0x00FF);
-		sprom[SPROM_PA0B0 + 1] = (v & 0xFF00) >> 8;
-		break;
-	case VALUE_PA0B1:
-		sprom[SPROM_PA0B1 + 0] = (v & 0x00FF);
-		sprom[SPROM_PA0B1 + 1] = (v & 0xFF00) >> 8;
-		break;
-	case VALUE_PA0B2:
-		sprom[SPROM_PA0B2 + 0] = (v & 0x00FF);
-		sprom[SPROM_PA0B2 + 1] = (v & 0xFF00) >> 8;
-		break;
-	case VALUE_PA1B0:
-		sprom[SPROM_PA1B0 + 0] = (v & 0x00FF);
-		sprom[SPROM_PA1B0 + 1] = (v & 0xFF00) >> 8;
-		break;
-	case VALUE_PA1B1:
-		sprom[SPROM_PA1B1 + 0] = (v & 0x00FF);
-		sprom[SPROM_PA1B1 + 1] = (v & 0xFF00) >> 8;
-		break;
-	case VALUE_PA1B2:
-		sprom[SPROM_PA1B2 + 0] = (v & 0x00FF);
-		sprom[SPROM_PA1B2 + 1] = (v & 0xFF00) >> 8;
-		break;
-	case VALUE_WL0GPIO0:
-		sprom[SPROM_WL0GPIO0 + 0] = (v & 0xFF);
-		break;
-	case VALUE_WL0GPIO1:
-		sprom[SPROM_WL0GPIO0 + 1] = (v & 0xFF);
-		break;
-	case VALUE_WL0GPIO2:
-		sprom[SPROM_WL0GPIO2 + 0] = (v & 0xFF);
-		break;
-	case VALUE_WL0GPIO3:
-		sprom[SPROM_WL0GPIO2 + 1] = (v & 0xFF);
-		break;
-	case VALUE_MAXPA:
-		sprom[SPROM_MAXPWR + 0] = (v & 0xFF);
-		break;
-	case VALUE_MAXPBG:
-		sprom[SPROM_MAXPWR + 1] = (v & 0xFF);
-		break;
-	case VALUE_ITSSIA:
-		sprom[SPROM_IDL_TSSI_TGT + 0] = (v & 0xFF);
-		break;
-	case VALUE_ITSSIBG:
-		sprom[SPROM_IDL_TSSI_TGT + 1] = (v & 0xFF);
-		break;
-	case VALUE_SVER:
-		if (sprom_rev != 4)
-			sprom[SPROM_VERSION + 0] = (v & 0xFF);
-		else
-			sprom[SPROM4_VERSION + 0] = (v & 0xFF);
-		break;
-	default:
-		prerror("vparm->type internal error (0)\n");
+	} else if (length == 33) { /* country code */
+		sprom[offset + 1] = vparm->u.ccode[0];
+		sprom[offset + 0] = vparm->u.ccode[1];
+	} else {
+		prerror("Incorrect value for length (%d)\n", length);
 		exit(1);
 	}
 
@@ -392,350 +425,68 @@ static int modify_sprom(uint8_t *sprom)
 static void display_value(const uint8_t *sprom,
 			  struct cmdline_vparm *vparm)
 {
-	const char *desc;
+	char desc[100];
+	char label[200];
+	char buffer[50];
+	char tbuf[2];
 	uint16_t offset;
-	uint16_t value;
-	uint16_t tmp;
+	uint16_t length;
+	uint16_t mask;
+	uint16_t shift;
+	uint32_t value = 0;
+	int rev_bit = BIT(sprom_rev);
+	const uint8_t *p;
+	int i;
 
-	switch (vparm->type) {
-	case VALUE_RAW:
-		desc = "RAW";
-		offset = vparm->u.raw.offset;
-		value = sprom[offset];
-		break;
-	case VALUE_SUBP:
-		desc = "Subsystem product ID";
-		if (sprom_rev == 4)
-			offset = SPROM4_SUBP;
-		else
-			offset = SPROM_SUBP;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] << 8;
-		break;
-	case VALUE_SUBV:
-		desc = "Subsystem vendor ID";
-		offset = SPROM_SUBV;
-		value = sprom[SPROM_SUBV + 0];
-		value |= sprom[SPROM_SUBV + 1] << 8;
-		break;
-	case VALUE_PPID:
-		desc = "PCI Product ID";
-		if (sprom_rev == 4)
-			offset = SPROM4_PPID;
-		else
-			offset = SPROM_PPID;
+	if (locate_item_rev(rev_bit, vparm->type, &length, &offset, &mask,
+			    &shift, desc, label))
+		return;
+	if (length < 32) {
 		value = sprom[offset + 0];
 		value |= sprom[offset + 1] << 8;
-		break;
-	case VALUE_BFLHI:
-		desc = "High 16 bits of Boardflags";
-		if (sprom_rev == 4)
-			offset = SPROM4_BOARDFLAGS + 2;
-		else
-			offset = SPROM_BFLHI;
+		value = (value & mask) >> shift;
+	} else if (length == 32) {
 		value = sprom[offset + 0];
 		value |= sprom[offset + 1] << 8;
-		break;
-	case VALUE_BFL:
-		desc = "Low 16 bits of Boardflags";
-		if (sprom_rev == 4)
-			offset = SPROM4_BOARDFLAGS;
-		else
-			offset = SPROM_BOARDFLAGS;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] << 8;
-		break;
-	case VALUE_BGMAC:
-		desc = "MAC address for 802.11b/g";
-		if (sprom_rev == 3)
-			offset = SPROM3_IL0MACADDR;
-		else if (sprom_rev == 4)
-			offset = SPROM4_IL0MACADDR;
-		else
-			offset = SPROM_IL0MACADDR;
-		value = 0;
-		break;
-	case VALUE_ETMAC:
-		desc = "MAC address for ethernet";
-		if (sprom_rev == 3)
-			offset = SPROM3_ET0MACADDR;
-		else if (sprom_rev == 4)
-			offset = SPROM4_ET0MACADDR;
-		else
-			offset = SPROM_ET0MACADDR;
-		value = 0;
-		break;
-	case VALUE_AMAC:
-		desc = "MAC address for 802.11a";
-		if (sprom_rev == 3)
-			offset = SPROM3_ET1MACADDR;
-		else if (sprom_rev == 4)
-			offset = SPROM4_ET1MACADDR;
-		else
-			offset = SPROM_ET1MACADDR;
-		value = 0;
-		break;
-	case VALUE_ET0PHY:
-		desc = "Ethernet phy settings (0)";
-		offset = SPROM_ETHPHY;
-		tmp = sprom[SPROM_ETHPHY + 0];
-		tmp |= sprom[SPROM_ETHPHY + 1] << 8;
-		value = (tmp & 0x001F);
-		break;
-	case VALUE_ET1PHY:
-		desc = "Ethernet phy settings (1)";
-		offset = SPROM_ETHPHY;
-		tmp = sprom[SPROM_ETHPHY + 0];
-		tmp |= sprom[SPROM_ETHPHY + 1] << 8;
-		value = (tmp & 0x03E0) >> 5;
-		break;
-	case VALUE_ET0MDC:
-		desc = "et0mdcport";
-		offset = SPROM_ETHPHY + 1;
-		value = 0;
-		if (sprom[SPROM_ETHPHY + 1] & (1 << 6))
-			value = 1;
-		break;
-	case VALUE_ET1MDC:
-		desc = "et1mdcport";
-		offset = SPROM_ETHPHY + 1;
-		value = 0;
-		if (sprom[SPROM_ETHPHY + 1] & (1 << 7))
-			value = 1;
-		break;
-	case VALUE_BREV:
-		desc = "Board revision";
-		if (sprom_rev == 4)
-			offset = SPROM4_BOARDREV;
-		else
-			offset = SPROM_BOARDREV;
-		value = sprom[offset + 0];
-		break;
-	case VALUE_LOC:
-		desc = "Locale / Country Code";
-		if (sprom_rev == 4) {
-			offset = SPROM4_COUNTRY;
-			value = sprom[offset] | (sprom[offset + 1] << 8);
-		} else {
-			offset = SPROM_BOARDREV;
-			value = (sprom[offset + 1] & 0x0F);
-		}
-		break;
-	case VALUE_ANTA0:
-		desc = "A PHY antenna 0 available";
-		value = 0;
-		if (sprom_rev == 4) {
-			offset = SPROM4_ANTAVAIL;
-			if (sprom[offset + 1] & 1)
-				value = 1;
-		} else {
-			offset = SPROM_BOARDREV;
-			value = 0;
-			if (sprom[offset + 2] & (1 << 6))
-				value = 1;
-		}
-		break;
-	case VALUE_ANTA1:
-		desc = "A PHY antenna 1 available";
-		value = 0;
-		if (sprom_rev == 4) {
-			offset = SPROM4_ANTAVAIL;
-			if (sprom[offset + 1] & 2)
-				value = 1;
-		} else {
-			offset = SPROM_BOARDREV;
-			value = 0;
-			if (sprom[offset + 2] & (1 << 7))
-				value = 1;
-		}
-		break;
-	case VALUE_ANTBG0:
-		desc = "B/G PHY antenna 0 available";
-		value = 0;
-		if (sprom_rev == 4) {
-			offset = SPROM4_ANTAVAIL;
-			if (sprom[offset] & 1)
-				value = 1;
-		} else {
-			offset = SPROM_BOARDREV;
-			value = 0;
-			if (sprom[offset + 2] & (1 << 4))
-				value = 1;
-		}
-		break;
-	case VALUE_ANTBG1:
-		desc = "B/G PHY antenna 1 available";
-		value = 0;
-		if (sprom_rev == 4) {
-			offset = SPROM4_ANTAVAIL;
-			if (sprom[offset] & 2)
-				value = 1;
-		} else {
-			offset = SPROM_BOARDREV;
-			value = 0;
-			if (sprom[offset + 2] & (1 << 5))
-				value = 1;
-		}
-		break;
-	case VALUE_ANTGA:
-		if (sprom_rev != 4) {
-			desc = "A PHY antenna gain";
-			offset = SPROM_ANTENNA_GAIN;
-		} else {
-			desc = "Antenna 1 Gain";
-			offset = SPROM4_ANTENNA_GAIN;
-		}
-		value = sprom[offset + 1];
-		break;
-	case VALUE_ANTGBG:
-		if (sprom_rev != 4) {
-			desc = "B/G PHY antenna gain";
-			offset = SPROM_ANTENNA_GAIN;
-		} else {
-			desc = "Antenna 0 Gain";
-			offset = SPROM4_ANTENNA_GAIN;
-		}
-		value = sprom[offset];
-		break;
-	case VALUE_PA0B0:
-		desc = "pa0b0";
-		offset = SPROM_PA0B0;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] << 8;
-		break;
-	case VALUE_PA0B1:
-		desc = "pa0b1";
-		offset = SPROM_PA0B1;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] << 8;
-		break;
-	case VALUE_PA0B2:
-		desc = "pa0b2";
-		offset = SPROM_PA0B2;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] << 8;
-		break;
-	case VALUE_PA1B0:
-		desc = "pa1b0";
-		offset = SPROM_PA1B0;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] << 8;
-		break;
-	case VALUE_PA1B1:
-		desc = "pa1b1";
-		offset = SPROM_PA1B1;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] << 8;
-		break;
-	case VALUE_PA1B2:
-		desc = "pa1b2";
-		offset = SPROM_PA1B2;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] << 8;
-		break;
-	case VALUE_WL0GPIO0:
-		desc = "LED 0 behaviour";
-		if (sprom_rev != 4)
-			offset = SPROM_WL0GPIO0 + 0;
-		else
-			offset = SPROM4_WL0GPIO0 + 0;
-		value = sprom[offset];
-		break;
-	case VALUE_WL0GPIO1:
-		desc = "LED 1 behaviour";
-		if (sprom_rev != 4)
-			offset = SPROM_WL0GPIO0 + 1;
-		else
-			offset = SPROM4_WL0GPIO0 + 1;
-		value = sprom[offset];
-		break;
-	case VALUE_WL0GPIO2:
-		desc = "LED 2 behaviour";
-		if (sprom_rev != 4)
-			offset = SPROM_WL0GPIO2 + 0;
-		else
-			offset = SPROM4_WL0GPIO2 + 0;
-		value = sprom[offset];
-		break;
-	case VALUE_WL0GPIO3:
-		desc = "LED 3 behaviour";
-		if (sprom_rev != 4)
-			offset = SPROM_WL0GPIO2 + 1;
-		else
-			offset = SPROM4_WL0GPIO2 + 1;
-		value = sprom[offset];
-		break;
-	case VALUE_MAXPA:
-		desc = "A PHY max powerout";
-		if (sprom_rev != 4)
-			offset = SPROM_MAXPWR + 1;
-		else
-			offset = SPROM4_MAXPWR + 1;
-		value = sprom[offset];
-		break;
-	case VALUE_MAXPBG:
-		desc = "B/G PHY max powerout";
-		if (sprom_rev != 4)
-			offset = SPROM_MAXPWR + 0;
-		else
-			offset = SPROM4_MAXPWR + 0;
-		value = sprom[offset];
-		break;
-	case VALUE_ITSSIA:
-		desc = "A PHY idle TSSI target";
-		if (sprom_rev != 4)
-			offset = SPROM_IDL_TSSI_TGT + 1;
-		else
-			offset = SPROM4_IDL_TSSI_TGT + 1;
-		value = sprom[offset];
-		break;
-	case VALUE_ITSSIBG:
-		desc = "B/G PHY idle TSSI target";
-		if (sprom_rev != 4)
-			offset = SPROM_IDL_TSSI_TGT + 0;
-		else
-			offset = SPROM4_IDL_TSSI_TGT + 0;
-		value = sprom[offset];
-		break;
-	case VALUE_SVER:
-		desc = "SPROM version";
-		if (sprom_rev != 4)
-			offset = SPROM_VERSION;
-		else
-			offset = SPROM4_VERSION;
-		value = sprom[offset];
-		break;
-	default:
-		prerror("vparm->type internal error (1)\n");
-		exit(1);
+		value |= sprom[offset + 2] << 16;
+		value |= sprom[offset + 3] << 24;
 	}
+	sprintf(buffer, "SPROM(0x%03X), %s,        ", offset, desc);
+	buffer[25] = '\0';
+	p = &(sprom[offset]);
 
-	switch (vparm->bits) {
+	switch (length) {
 	case 1:
-		prdata("SPROM(0x%02X, %s) = %s\n",
-		       offset, desc, value ? "ON" : "OFF");
+		prdata("%s%s = %s\n", buffer, label, value ? "ON" : "OFF");
 		break;
 	case 4:
-		prdata("SPROM(0x%02X, %s) = 0x%01X\n",
-		       offset, desc, (value & 0xF));
+		prdata("%s%s = 0x%01X\n", buffer, label, (value & 0xF));
+		break;
+	case 5:
+		prdata("%s%s = 0x%02X\n", buffer, label, (value & 0x1F));
 		break;
 	case 8:
-		prdata("SPROM(0x%02X, %s) = 0x%02X\n",
-		       offset, desc, (value & 0xFF));
+		prdata("%s%s = 0x%02X\n", buffer, label, (value & 0xFF));
 		break;
 	case 16:
-		prdata("SPROM(0x%02X, %s) = 0x%04X\n",
-		       offset, desc, (value & 0xFFFF));
+		prdata("%s%s = 0x%04X\n", buffer, label, value);
+		break;
+	case 32:
+		prdata("%s%s = 0x%08X\n", buffer, label, value);
+		break;
+	case 33: /* alphabetic country code */
+		for (i = 0; i < 2; i++) {
+			tbuf[i] = p[i];
+			if (!tbuf[i])	/* if not encoded, the value is zero */
+				tbuf[i] = ' ';
+		}
+		prdata("%s%s = \"%c%c\"\n", buffer, label, tbuf[1], tbuf[0]);
 		break;
-	case -1: {
+	case 34:
 		/* MAC address. */
-		const uint8_t *p = &(sprom[offset]);
-
-		prdata("SPROM(0x%02X, %s) = %02x:%02x:%02x:%02x:%02x:%02x\n",
-		       offset, desc,
-		       p[1], p[0], p[3], p[2], p[5], p[4]);
+		prdata("%s%s = %02x:%02x:%02x:%02x:%02x:%02x\n",
+		       buffer, label, p[1], p[0], p[3], p[2], p[5], p[4]);
 		break;
-	}
 	default:
 		prerror("vparm->bits internal error (%d)\n",
 			vparm->bits);
@@ -809,15 +560,16 @@ static int parse_input(uint8_t *sprom, c
 		parsed = strtoul(tmp, NULL, 16);
 		sprom[cnt] = parsed & 0xFF;
 	}
-	/* check for "magic" data for V4 SPROM */
-	if (sprom[0x40] == 0x72 && sprom[0x41] == 0x53) {
-		sprom_rev = sprom[SPROM4_VERSION];
+	/* check for 440 byte versions (V4 and higher) */
+	if (inlen > 300) {
+		sprom_rev = sprom[SPROM4_SIZE - 2];
 		sprom_size = SPROM4_SIZE;
 	} else {
-		sprom_rev = sprom[SPROM_VERSION];
+		sprom_rev = sprom[SPROM_SIZE - 2];
 		sprom_size = SPROM_SIZE;
 	}
-
+	if (check_rev(sprom_rev))
+		exit(1);
 	if (cmdargs.verbose) {
 		hexdump_sprom(sprom, tmp, sizeof(tmp));
 		prinfo("Raw input:  %s\n", tmp);
@@ -843,9 +595,9 @@ static int read_infile(int fd, char **bu
 	}
 	if (cmdargs.bin_mode) {
 		if (s.st_size != SPROM_SIZE && s.st_size != SPROM4_SIZE) {
-			prerror("The input data is no SPROM Binary data. "
+			prerror("The input data is not SPROM Binary data. "
 				"The size must be exactly %d (V1-3) "
-				"or %d (V4) bytes, "
+				"or %d (V4-8) bytes, "
 				"but it is %u bytes\n",
 				SPROM_SIZE, SPROM4_SIZE,
 				(unsigned int)(s.st_size));
@@ -932,6 +684,17 @@ static void print_banner(int forceprint)
 
 static void print_usage(int argc, char *argv[])
 {
+	int tmp;
+	enum valuetype loop;
+	char desc[100];
+	char label[200];
+	char buffer[200];
+	uint16_t offset;
+	uint16_t length;
+	uint16_t mask;
+	uint16_t shift;
+	int rev_bit;
+
 	print_banner(1);
 	prdata("\nUsage: %s [OPTION]\n", argv[0]);
 	prdata("  -i|--input FILE       Input file\n");
@@ -941,48 +704,63 @@ static void print_usage(int argc, char *
 	prdata("  -f|--force            Override error checks\n");
 	prdata("  -v|--version          Print version\n");
 	prdata("  -h|--help             Print this help\n");
-	prdata("\n");
-	prdata("Value Parameters:\n");
+	if (sprom_rev == 0) {
+		prdata("\nThe rest of this help depends on what SPROM version you are using\n\n");
+		prdata("Please enter it now: ");
+
+		fgets(label, 50, stdin);
+		sscanf(label, "%d", &tmp);
+		sprom_rev = tmp;
+	}
+	if (check_rev(sprom_rev))
+		exit(1);
+
+	rev_bit = BIT(sprom_rev);
+	prdata("\nValue Parameters:\n");
 	prdata("\n");
 	prdata("  -s|--rawset OFF,VAL   Set a VALue at a byte-OFFset\n");
 	prdata("  -g|--rawget OFF       Get a value at a byte-OFFset\n");
 	prdata("\n");
 	prdata("Predefined values (for displaying (GET) or modification):\n");
-	prdata("  --subp [0xFFFF]       Subsystem product ID for PCI\n");
-	prdata("  --subv [0xFFFF]       Subsystem vendor ID for PCI\n");
-	prdata("  --ppid [0xFFFF]       Product ID for PCI\n");
-	prdata("  --bflhi [0xFFFF]      High 16 bits of boardflags (only if spromversion > 1)\n");
-	prdata("  --bfl [0xFFFF]        Low 16 bits of boardflags\n");
-	prdata("  --bgmac [MAC-ADDR]    MAC address for 802.11b/g\n");
-	prdata("  --etmac [MAC-ADDR]    MAC address for ethernet, see b44 driver\n");
-	prdata("  --amac [MAC-ADDR]     Mac address for 802.11a\n");
-	prdata("  --et0phy [0xFF]\n");
-	prdata("  --et1phy [0xFF]\n");
-	prdata("  --et0mdc [BOOL]\n");
-	prdata("  --et1mdc [BOOL]\n");
-	prdata("  --brev [0xFF]         Board revision\n");
-	prdata("  --loc [0xF]           Country code\n");
-	prdata("  --anta0 [BOOL]        Antenna 0 available for A PHY\n");
-	prdata("  --anta1 [BOOL]        Antenna 1 available for A PHY\n");
-	prdata("  --antbg0 [BOOL]       Antenna 0 available for B/G PHY\n");
-	prdata("  --antbg1 [BOOL]       Antenna 1 available for B/G PHY\n");
-	prdata("  --antga [0xFF]        Antenna gain for A PHY\n");
-	prdata("  --antgbg [0xFF]       Antenna gain for B/G PHY\n");
-	prdata("  --pa0b0 [0xFFFF]\n");
-	prdata("  --pa0b1 [0xFFFF]\n");
-	prdata("  --pa0b2 [0xFFFF]\n");
-	prdata("  --pa1b0 [0xFFFF]\n");
-	prdata("  --pa1b1 [0xFFFF]\n");
-	prdata("  --pa1b2 [0xFFFF]\n");
-	prdata("  --wl0gpio0 [0xFF]     LED 0 behaviour\n");
-	prdata("  --wl0gpio1 [0xFF]     LED 1 behaviour\n");
-	prdata("  --wl0gpio2 [0xFF]     LED 2 behaviour\n");
-	prdata("  --wl0gpio3 [0xFF]     LED 3 behaviour\n");
-	prdata("  --maxpa [0xFF]        A PHY max power\n");
-	prdata("  --maxpbg [0xFF]       B/G PHY max power\n");
-	prdata("  --itssia [0xFF]       Idle tssi target for A PHY\n");
-	prdata("  --itssibg [0xFF]      Idle tssi target for B/G PHY\n");
-	prdata("  --sver [0xFF]         SPROM-version\n");
+
+	for (loop = 0; loop <= VAL_LAST; loop++) {
+		if (locate_item_rev(rev_bit, loop, &length, &offset, &mask,
+			    &shift, desc, label))
+			continue;
+
+		switch (length) {
+		case 34:
+			sprintf(buffer, "  --%s [MAC-ADDR]%30s", desc, " ");
+			break;
+		case 33:
+			sprintf(buffer, "  --%s [2 Char String]%30s", desc, " ");
+			break;
+		case 32:
+			sprintf(buffer, "  --%s [0xFFFFFFFF]%30s", desc, " ");
+			break;
+		case 16:
+			sprintf(buffer, "  --%s [0xFFFF]%30s", desc, " ");
+			break;
+		case 8:
+			sprintf(buffer, "  --%s [0xFF]%30s", desc, " ");
+			break;
+		case 5:
+			sprintf(buffer, "  --%s [0x1F]%30s", desc, " ");
+			break;
+		case 4:
+			sprintf(buffer, "  --%s [0xF]%30s", desc, " ");
+			break;
+		case 1:
+			sprintf(buffer, "  --%s [BOOL]%30s", desc, " ");
+			break;
+		default:
+			prerror("Program error: Incorrect value of item length (%d)\n", length);
+			exit(1);
+		}
+		buffer[28] = '\0';
+		prdata("%s%s\n", buffer, label);
+	}
+
 	prdata("\n");
 	prdata("  -P|--print-all        Display all values\n");
 	prdata("\n");
@@ -1084,12 +862,13 @@ static int parse_value(const char *str,
 	unsigned long v;
 	int i;
 
-	vparm->bits = value_length_map[vparm->type];
 	vparm->set = 1;
 	if (strcmp(str, "GET") == 0 || strcmp(str, "get") == 0) {
 		vparm->set = 0;
 		return 0;
 	}
+	if (vparm->bits > 32)
+		return 0;
 	if (vparm->bits == 1) {
 		/* This is a boolean value. */
 		if (strcmp(str, "0") == 0)
@@ -1141,6 +920,24 @@ error_bool:
 	return -1;
 }
 
+static int parse_ccode(const char *str,
+		       struct cmdline_vparm *vparm,
+		       const char *param)
+{
+	const char *in = str;
+	char *out = vparm->u.ccode;
+
+	vparm->bits = 33;
+	vparm->set = 1;
+	if (strcmp(str, "GET") == 0 || strcmp(str, "get") == 0) {
+		vparm->set = 0;
+		return 0;
+	}
+
+	memcpy(out, in, 2);
+	return 1;
+}
+
 static int parse_mac(const char *str,
 		     struct cmdline_vparm *vparm,
 		     const char *param)
@@ -1150,7 +947,7 @@ static int parse_mac(const char *str,
 	const char *in = str;
 	uint8_t *out = vparm->u.mac;
 
-	vparm->bits = -1;
+	vparm->bits = 34;
 	vparm->set = 1;
 	if (strcmp(str, "GET") == 0 || strcmp(str, "get") == 0) {
 		vparm->set = 0;
@@ -1187,7 +984,7 @@ static int parse_rawset(const char *str,
 	uint16_t offset;
 	int err;
 
-	vparm->type = VALUE_RAW;
+	vparm->type = VAL_RAW;
 
 	delim = strchr(str, ',');
 	if (!delim)
@@ -1224,7 +1021,7 @@ static int parse_rawget(const char *str,
 	int err;
 	uint16_t offset;
 
-	vparm->type = VALUE_RAW;
+	vparm->type = VAL_RAW;
 
 	err = parse_value(str, vparm, "--rawget");
 	if (err != 1)
@@ -1237,7 +1034,7 @@ static int parse_rawget(const char *str,
 	}
 
 	vparm->u.raw.offset = offset;
-	vparm->type = VALUE_RAW;
+	vparm->type = VAL_RAW;
 	vparm->set = 0;
 
 	return 0;
@@ -1245,31 +1042,38 @@ static int parse_rawget(const char *str,
 
 static int generate_printall(void)
 {
-	struct cmdline_vparm *vparm;
-	int count, i;
-	enum valuetype vt = VALUE_FIRST;
+	enum valuetype vt = 0;
+	int j;
 
-	count = VALUE_LAST - VALUE_FIRST + 1;
-	for (i = 0; i < count; i++, vt++) {
+	for (vt = 0; vt <= VAL_LAST; vt++) {
 		if (cmdargs.nr_vparm == MAX_VPARM) {
 			prerror("Too many value parameters.\n");
 			return -1;
 		}
-
-		vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-		vparm->type = vt;
-		vparm->set = 0;
-		vparm->bits = value_length_map[vt];
+		for (j = 0; ; j++) {
+			enum valuetype type = sprom_table[j].type;
+			short mask = sprom_table[j].rev_mask;
+
+			if (mask == 0)
+				break;
+			if ((mask & BIT(sprom_rev)) && (type == vt)) {
+				cmdargs.vparm[cmdargs.nr_vparm].type = vt;
+				cmdargs.vparm[cmdargs.nr_vparm].set = 0;
+				cmdargs.vparm[cmdargs.nr_vparm++].bits = sprom_table[j].length;
+			}
+		}
 	}
-
 	return 0;
 }
 
-static int parse_args(int argc, char *argv[])
+static int parse_args(int argc, char *argv[], int pass)
 {
 	struct cmdline_vparm *vparm;
 	int i, err;
 	char *param;
+	char *arg;
+	uint16_t length;
+	enum valuetype type;
 
 	parse_err = 0;
 	for (i = 1; i < argc; i++) {
@@ -1293,243 +1097,50 @@ static int parse_args(int argc, char *ar
 			cmdargs.force = 1;
 		} else if (arg_match(argv, &i, "--binmode", "-b", 0)) {
 			cmdargs.bin_mode = 1;
-
-
-		} else if (arg_match(argv, &i, "--rawset", "-s", &param)) {
+		} else if (pass == 2 && arg_match(argv, &i, "--rawset", "-s", &param)) {
 			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
 			err = parse_rawset(param, vparm);
 			if (err < 0)
 				goto error;
-		} else if (arg_match(argv, &i, "--rawget", "-g", &param)) {
+		} else if (pass == 2 && arg_match(argv, &i, "--rawget", "-g", &param)) {
 			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
 			err = parse_rawget(param, vparm);
 			if (err < 0)
 				goto error;
 
-
-		} else if (arg_match(argv, &i, "--subp", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_SUBP;
-			err = parse_value(param, vparm, "--subp");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--subv", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_SUBV;
-			err = parse_value(param, vparm, "--subv");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--ppid", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_PPID;
-			err = parse_value(param, vparm, "--ppid");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--bflhi", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_BFLHI;
-			err = parse_value(param, vparm, "--bflhi");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--bfl", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_BFL;
-			err = parse_value(param, vparm, "--bfl");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--bgmac", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_BGMAC;
-			err = parse_mac(param, vparm, "--bgmac");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--etmac", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ETMAC;
-			err = parse_mac(param, vparm, "--etmac");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--amac", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_AMAC;
-			err = parse_mac(param, vparm, "--amac");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--et0phy", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ET0PHY;
-			err = parse_value(param, vparm, "--et0phy");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--et1phy", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ET1PHY;
-			err = parse_value(param, vparm, "--et1phy");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--et0mdc", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ET0MDC;
-			err = parse_value(param, vparm, "--et0mdc");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--et1mdc", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ET1MDC;
-			err = parse_value(param, vparm, "--et1mdc");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--brev", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_BREV;
-			err = parse_value(param, vparm, "--brev");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--loc", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_LOC;
-			err = parse_value(param, vparm, "--loc");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--anta0", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ANTA0;
-			err = parse_value(param, vparm, "--anta0");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--anta1", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ANTA1;
-			err = parse_value(param, vparm, "--anta1");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--antbg0", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ANTBG0;
-			err = parse_value(param, vparm, "--antbg0");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--antbg1", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ANTBG1;
-			err = parse_value(param, vparm, "--antbg1");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--antga", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ANTGA;
-			err = parse_value(param, vparm, "--antga");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--antgbg", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ANTGBG;
-			err = parse_value(param, vparm, "--antgbg");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--pa0b0", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_PA0B0;
-			err = parse_value(param, vparm, "--pa0b0");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--pa0b1", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_PA0B1;
-			err = parse_value(param, vparm, "--pa0b1");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--pa0b2", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_PA0B2;
-			err = parse_value(param, vparm, "--pa0b2");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--pa1b0", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_PA1B0;
-			err = parse_value(param, vparm, "--pa1b0");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--pa1b1", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_PA1B1;
-			err = parse_value(param, vparm, "--pa1b1");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--pa1b2", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_PA1B2;
-			err = parse_value(param, vparm, "--pa1b2");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--wl0gpio0", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_WL0GPIO0;
-			err = parse_value(param, vparm, "--wl0gpio0");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--wl0gpio1", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_WL0GPIO1;
-			err = parse_value(param, vparm, "--wl0gpio1");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--wl0gpio2", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_WL0GPIO2;
-			err = parse_value(param, vparm, "--wl0gpio2");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--wl0gpio3", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_WL0GPIO3;
-			err = parse_value(param, vparm, "--wl0gpio3");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--maxpa", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_MAXPA;
-			err = parse_value(param, vparm, "--maxpa");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--maxpbg", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_MAXPBG;
-			err = parse_value(param, vparm, "--maxpbg");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--itssia", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ITSSIA;
-			err = parse_value(param, vparm, "--itssia");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--itssibg", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_ITSSIBG;
-			err = parse_value(param, vparm, "--itssibg");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--sver", 0, &param)) {
-			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm->type = VALUE_SVER;
-			err = parse_value(param, vparm, "--sver");
-			if (err < 0)
-				goto error;
-		} else if (arg_match(argv, &i, "--print-all", "-P", 0)) {
+		} else if (pass == 2 && arg_match(argv, &i, "--print-all", "-P", 0)) {
 			err = generate_printall();
 			if (err)
 				goto error;
-		} else {
-			if (!parse_err)
-				prerror("Unrecognized argument: %s\n", argv[i]);
-			goto out_usage;
+
+		} else if (pass == 2) {
+			arg = argv[i];
+			if (arg[0] != '-' || arg[1] != '-')
+				goto out_usage;		/* all must start with "--" */
+			if (locate_item_by_desc(BIT(sprom_rev), &type, &length, arg + 2))
+				goto out_usage;
+			arg_match(argv, &i, arg, NULL, &param);
+			vparm = &(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm->type = type;
+			vparm->bits = length;
+			err = parse_value(param, vparm, arg);
+			if (err < 0)
+				goto error;
+			if (length == 34) {
+				err = parse_mac(param, vparm, arg);
+				if (err < 0)
+					goto error;
+			}
+			if (length == 33) {
+				err = parse_ccode(param, vparm, arg);
+				if (err < 0)
+					goto error;
+			}
 		}
 		if (parse_err)
 			goto out_usage;
 	}
-	if (cmdargs.nr_vparm == 0) {
+	if (pass == 2 && cmdargs.nr_vparm == 0) {
 		prerror("No Value parameter given. See --help.\n");
 		return -1;
 	}
@@ -1550,7 +1161,14 @@ int main(int argc, char **argv)
 	char *buffer = NULL;
 	size_t buffer_size = 0;
 
-	err = parse_args(argc, argv);
+	/* Some arguments require that the revision of the sprom be known,
+	 * but that is not known until the sprom data are read. This difficulty
+	 * is handled by making two passes through the argument list. The first
+	 * only process those arguments that do not depend on sprom revision.
+	 *
+	 * Do the first pass through arguments
+	 */
+	err = parse_args(argc, argv, 1);
 	if (err == 1)
 		return 0;
 	else if (err != 0)
@@ -1575,6 +1193,13 @@ int main(int argc, char **argv)
 	if (err)
 		goto out;
 
+	/* do second pass through argument list */
+	err = parse_args(argc, argv, 2);
+	if (err == 1)
+		return 0;
+	else if (err != 0)
+		goto out;
+
 	err = display_sprom(sprom);
 	if (err)
 		goto out;
@@ -1591,6 +1216,7 @@ int main(int argc, char **argv)
 			goto out;
 		prinfo("SPROM modified.\n");
 	}
+	prdata("The input file is data from a revision %d SPROM.\n", sprom_rev);
 out:
 	return err;
 }
Index: ssb_sprom/ssb_sprom.h
===================================================================
--- ssb_sprom.orig/ssb_sprom.h
+++ ssb_sprom/ssb_sprom.h
@@ -30,97 +30,116 @@
 #define SPROM_SIZE		128 /* bytes */
 #define SPROM4_SIZE		440
 
-/* byte offsets */
-#define SPROM_SUBP		(0x02 * 2)
-#define SPROM4_SUBP		(0x02 * 2)
-#define SPROM_SUBV		(0x03 * 2)
-#define SPROM_PPID		(0x04 * 2)
-#define SPROM4_PPID		(0x04 * 2)
-#define SPROM_BFLHI		(0x1C * 2)
-#define SPROM_IL0MACADDR	(0x24 * 2)
-#define SPROM_ET0MACADDR	(0x27 * 2)
-#define SPROM_ET1MACADDR	(0x2a * 2)
-#define SPROM3_IL0MACADDR	(0x25 * 2)
-#define SPROM3_ET0MACADDR	(0x28 * 2)
-#define SPROM3_ET1MACADDR	(0x28 * 2)
-#define SPROM4_IL0MACADDR	(0x26 * 2)
-#define SPROM4_ET0MACADDR	(0x18 * 2)
-#define SPROM4_ET1MACADDR	(0x26 * 2)
-#define SPROM_ETHPHY		(0x2d * 2)
-#define SPROM_BOARDREV		(0x2e * 2)
-#define SPROM4_BOARDREV		(0x21 * 2)
-#define SPROM4_ANTAVAIL		(0x2e * 2)
-#define SPROM4_COUNTRY		(0x29 * 2)
-#define SPROM_PA0B0		(0x2f * 2)
-#define SPROM_PA0B1		(0x30 * 2)
-#define SPROM_PA0B2		(0x31 * 2)
-#define SPROM_WL0GPIO0		(0x32 * 2)
-#define SPROM_WL0GPIO2		(0x33 * 2)
-#define SPROM4_WL0GPIO0		(0x2b * 2)
-#define SPROM4_WL0GPIO2		(0x2c * 2)
-#define SPROM_MAXPWR		(0x34 * 2)
-#define SPROM4_MAXPWR		(0x45 * 2)
-#define SPROM_PA1B0		(0x35 * 2)
-#define SPROM_PA1B1		(0x36 * 2)
-#define SPROM_PA1B2		(0x37 * 2)
-#define SPROM_IDL_TSSI_TGT	(0x38 * 2)
-#define SPROM4_IDL_TSSI_TGT	(0x40 * 2)
-#define SPROM_BOARDFLAGS	(0x39 * 2)
-#define SPROM4_BOARDFLAGS	(0x22 * 2)
-#define SPROM_ANTENNA_GAIN	(0x3a * 2)
-#define SPROM4_ANTENNA_GAIN	(0x2f * 2)
-#define SPROM_VERSION		(0x3f * 2)
-#define SPROM4_VERSION		(0xdb * 2)
-
 enum valuetype {
-	VALUE_RAW,
+	VAL_RAW,
 
-	VALUE_SUBP,
- VALUE_FIRST = VALUE_SUBP,
-	VALUE_SUBV,
-	VALUE_PPID,
-	VALUE_BFLHI,
-	VALUE_BFL,
-	VALUE_BGMAC,
-	VALUE_ETMAC,
-	VALUE_AMAC,
-	VALUE_ET0PHY,
-	VALUE_ET1PHY,
-	VALUE_ET0MDC,
-	VALUE_ET1MDC,
-	VALUE_BREV,
-	VALUE_LOC,
-	VALUE_ANTBG0,
-	VALUE_ANTBG1,
-	VALUE_ANTA0,
-	VALUE_ANTA1,
-	VALUE_ANTGBG,
-	VALUE_ANTGA,
-	VALUE_PA0B0,
-	VALUE_PA0B1,
-	VALUE_PA0B2,
-	VALUE_PA1B0,
-	VALUE_PA1B1,
-	VALUE_PA1B2,
-	VALUE_WL0GPIO0,
-	VALUE_WL0GPIO1,
-	VALUE_WL0GPIO2,
-	VALUE_WL0GPIO3,
-	VALUE_MAXPBG,
-	VALUE_MAXPA,
-	VALUE_ITSSIBG,
-	VALUE_ITSSIA,
-	VALUE_SVER,
- VALUE_LAST = VALUE_SVER,
+	VAL_ET0PHY,
+	VAL_ET1PHY,
+	VAL_ET0MDC,
+	VAL_ET1MDC,
+	VAL_BREV,
+	VAL_ANTBG0,
+	VAL_ANTBG1,
+	VAL_ANTBG2,
+	VAL_ANTBG3,
+	VAL_ANTA0,
+	VAL_ANTA1,
+	VAL_ANTA2,
+	VAL_ANTA3,
+	VAL_ANTGBG,
+	VAL_ANTGA,
+	VAL_ANTG0,
+	VAL_ANTG1,
+	VAL_ANTG2,
+	VAL_ANTG3,
+	VAL_TPI2G0,
+	VAL_TPI2G1,
+	VAL_TPI5GM0,
+	VAL_TPI5GM1,
+	VAL_TPI5GL0,
+	VAL_TPI5GL1,
+	VAL_TPI5GH0,
+	VAL_TPI5GH1,
+	VAL_2CCKPO,
+	VAL_2OFDMPO,
+	VAL_5MPO,
+	VAL_5LPO,
+	VAL_5HPO,
+	VAL_2MCSPO,
+	VAL_5MMCSPO,
+	VAL_5LMCSPO,
+	VAL_5HMCSPO,
+	VAL_CCDPO,
+	VAL_STBCPO,
+	VAL_BW40PO,
+	VAL_BWDUPPO,
+	VAL_5HPAM,
+	VAL_5LPAM,
+	VAL_PA0B0,
+	VAL_PA0B1,
+	VAL_PA0B2,
+	VAL_PA0B3,
+	VAL_PA1B0,
+	VAL_PA1B1,
+	VAL_PA1B2,
+	VAL_PA1B3,
+	VAL_5MPA0,
+	VAL_5MPA1,
+	VAL_5MPA2,
+	VAL_5MPA3,
+	VAL_5LPA0,
+	VAL_5LPA1,
+	VAL_5LPA2,
+	VAL_5LPA3,
+	VAL_5HPA0,
+	VAL_5HPA1,
+	VAL_5HPA2,
+	VAL_5HPA3,
+	VAL_LED0,
+	VAL_LED1,
+	VAL_LED2,
+	VAL_LED3,
+	VAL_MAXPBG,
+	VAL_MAXPA,
+	VAL_ITSSIBG,
+	VAL_ITSSIA,
+	VAL_BGMAC,
+	VAL_ETMAC,
+	VAL_AMAC,
+	VAL_SUBP,
+	VAL_SUBV,
+	VAL_PPID,
+	VAL_BFLHI,
+	VAL_BFL,
+	VAL_REGREV,
+	VAL_LOC,
+ VAL_LAST = VAL_LOC,
 };
 
+#define BIT(i)  (1U << (i))
+
+#define MASK_1  BIT(1)
+#define MASK_2  BIT(2)
+#define MASK_3  BIT(3)
+#define MASK_4  BIT(4)
+#define MASK_5  BIT(5)
+#define MASK_8  BIT(8)
+
+#define MASK_1_2  MASK_1 | MASK_2	/* Revs 1 - 2 */
+#define MASK_1_3  MASK_1_2 | MASK_3	/* Revs 1 - 3 */
+#define MASK_2_3  MASK_2 | MASK_3	/* Revs 2 - 3 */
+#define MASK_4_5  MASK_4 | MASK_5	/* Revs 4 - 5 */
+#define MASK_1_5  MASK_1_3 | MASK_4_5	/* Revs 1 - 5 */
+#define MASK_1_8  MASK_1_5 | MASK_8	/* Revs 1 - 5, 8 */
+
 struct cmdline_vparm {
 	enum valuetype type;
 	int set;
 	int bits;
 	union {
-		uint16_t value;
+		uint32_t value;
 		uint8_t mac[6];
+		char ccode[2];
 		struct {
 			uint16_t value;
 			uint16_t offset;
@@ -139,6 +158,18 @@ struct cmdline_args {
 	struct cmdline_vparm vparm[MAX_VPARM];
 	int nr_vparm;
 };
+
+struct var_entry {
+	uint16_t rev_mask;
+	enum valuetype type;
+	uint16_t length;
+	uint16_t offset;
+	uint16_t mask;
+	uint16_t shift;
+	const char *desc;
+	const char *label;
+};
+
 extern struct cmdline_args cmdargs;
 
 #endif /* SSB_SPROMTOOL_H_ */


From mb at bu3sch.de  Mon Dec 29 17:06:42 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 29 Dec 2008 17:06:42 +0100
Subject: [PATCH] ssb-sprom: Put SPROM data in a master table and add Rev. 8
In-Reply-To: <4958f11c.mP3NZnnSfHC3caXN%Larry.Finger@lwfinger.net>
References: <4958f11c.mP3NZnnSfHC3caXN%Larry.Finger@lwfinger.net>
Message-ID: <200812291706.42476.mb@bu3sch.de>

On Monday 29 December 2008 16:47:40 Larry Finger wrote:
> Program ssb-sprom has gotten unwieldy as more versions of the SPROM have been
> accommodated. As we now need to add Rev. 8 SPROMs for LP and N PHY devices, I
> chose to rewrite the program now.
> 
> This patch converts the program to be driven by a table, which removes the need
> for hard coding a number of revision-specific values. In fact, only two such
> numbers are defined in the new header - the SPROM sizes for 128 and 440 byte
> versions. Other changes include modifying the data order so that the variables
> that are most likely to be changed are at the botton the list. I also removed
> the SPROM revision from the list that could be modified. Changing this value
> would BRICK the device. At the moment, only the first of the "per-path"
> variables have been added for revisions 4, 5, and 8. As we gain more experience
> with these variants, addition of new outputs may be necessary.

Thanks, I applied this.
Is it possible, however, to have ssb_sprom --help not ask for the version?
Simply print out _all_ options that apply to all versions.
It's kind of confusing to see a question about a file version, if we don't
have a file at all when just requesting commandline help.

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Mon Dec 29 17:23:56 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 29 Dec 2008 10:23:56 -0600
Subject: [PATCH] ssb-sprom: Put SPROM data in a master table and add Rev. 8
In-Reply-To: <200812291706.42476.mb@bu3sch.de>
References: <4958f11c.mP3NZnnSfHC3caXN%Larry.Finger@lwfinger.net>
	<200812291706.42476.mb@bu3sch.de>
Message-ID: <4958F99C.50309@lwfinger.net>

Michael Buesch wrote:
> Thanks, I applied this.
> Is it possible, however, to have ssb_sprom --help not ask for the version?
> Simply print out _all_ options that apply to all versions.
> It's kind of confusing to see a question about a file version, if we don't
> have a file at all when just requesting commandline help.

Sure. I'll just loop it through all the versions. Of course, that will generate
what is probably too much output for the console, thus I will direct it to a
file and list the name of the file, unless I hear that you want it all on the
console.

Patch forthcoming.

Larry




From johannes at sipsolutions.net  Mon Dec 29 17:27:45 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 29 Dec 2008 17:27:45 +0100
Subject: [PATCH] ssb-sprom: Put SPROM data in a master table and add Rev. 8
In-Reply-To: <4958F99C.50309@lwfinger.net>
References: <4958f11c.mP3NZnnSfHC3caXN%Larry.Finger@lwfinger.net>
	<200812291706.42476.mb@bu3sch.de>  <4958F99C.50309@lwfinger.net>
Message-ID: <1230568065.3116.60.camel@johannes>

On Mon, 2008-12-29 at 10:23 -0600, Larry Finger wrote:
> Michael Buesch wrote:
> > Thanks, I applied this.
> > Is it possible, however, to have ssb_sprom --help not ask for the version?
> > Simply print out _all_ options that apply to all versions.
> > It's kind of confusing to see a question about a file version, if we don't
> > have a file at all when just requesting commandline help.
> 
> Sure. I'll just loop it through all the versions. Of course, that will generate
> what is probably too much output for the console, thus I will direct it to a
> file and list the name of the file, unless I hear that you want it all on the
> console.

All on console please, people can add > /tmp/file or | less

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20081229/5f02dcf7/attachment.pgp>

From mb at bu3sch.de  Mon Dec 29 17:36:56 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 29 Dec 2008 17:36:56 +0100
Subject: [PATCH] ssb-sprom: Put SPROM data in a master table and add Rev. 8
In-Reply-To: <4958F99C.50309@lwfinger.net>
References: <4958f11c.mP3NZnnSfHC3caXN%Larry.Finger@lwfinger.net>
	<200812291706.42476.mb@bu3sch.de> <4958F99C.50309@lwfinger.net>
Message-ID: <200812291736.56988.mb@bu3sch.de>

On Monday 29 December 2008 17:23:56 Larry Finger wrote:
> Michael Buesch wrote:
> > Thanks, I applied this.
> > Is it possible, however, to have ssb_sprom --help not ask for the version?
> > Simply print out _all_ options that apply to all versions.
> > It's kind of confusing to see a question about a file version, if we don't
> > have a file at all when just requesting commandline help.
> 
> Sure. I'll just loop it through all the versions. Of course, that will generate
> what is probably too much output for the console, thus I will direct it to a
> file and list the name of the file, unless I hear that you want it all on the
> console.

Helptext is supposed to be on the console.
People know about less(1) ;)

Simply do something like
These are available for v1:
	fooo
And these for v2:
	baaar
...
and so on

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Mon Dec 29 18:11:10 2008
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 29 Dec 2008 11:11:10 -0600
Subject: [PATCH] ssb-sprom: Generate help for all variations
Message-ID: <495904ae.3Rs95hJIVvgsxoGY%Larry.Finger@lwfinger.net>

Revise ssb-sprom to generate the help data for all versions of the device.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: ssb_sprom/ssb_sprom.c
===================================================================
--- ssb_sprom.orig/ssb_sprom.c
+++ ssb_sprom/ssb_sprom.c
@@ -675,7 +675,8 @@ static void print_banner(int forceprint)
 			  "Copyright (C) Michael Buesch\n"
 			  "Licensed under the GNU/GPL version 2 or later\n"
 			  "\n"
-			  "DO NOT USE THIS TOOL. YOU WILL BRICK YOUR DEVICE.\n";
+			  "Be exceedingly careful with this tool. Improper"
+			  " usage WILL BRICK YOUR DEVICE.\n";
 	if (forceprint)
 		prdata(str);
 	else
@@ -684,7 +685,6 @@ static void print_banner(int forceprint)
 
 static void print_usage(int argc, char *argv[])
 {
-	int tmp;
 	enum valuetype loop;
 	char desc[100];
 	char label[200];
@@ -697,33 +697,29 @@ static void print_usage(int argc, char *
 
 	print_banner(1);
 	prdata("\nUsage: %s [OPTION]\n", argv[0]);
-	prdata("  -i|--input FILE       Input file\n");
-	prdata("  -o|--output FILE      Output file\n");
-	prdata("  -b|--binmode          The Input data is plain binary data and Output will be binary\n");
-	prdata("  -V|--verbose          Be verbose\n");
-	prdata("  -f|--force            Override error checks\n");
-	prdata("  -v|--version          Print version\n");
-	prdata("  -h|--help             Print this help\n");
-	if (sprom_rev == 0) {
-		prdata("\nThe rest of this help depends on what SPROM version you are using\n\n");
-		prdata("Please enter it now: ");
-
-		fgets(label, 50, stdin);
-		sscanf(label, "%d", &tmp);
-		sprom_rev = tmp;
-	}
-	if (check_rev(sprom_rev))
-		exit(1);
-
-	rev_bit = BIT(sprom_rev);
+	prdata("  -i|--input FILE           Input file\n");
+	prdata("  -o|--output FILE          Output file\n");
+	prdata("  -b|--binmode              The Input data is plain binary data and Output will be binary\n");
+	prdata("  -V|--verbose              Be verbose\n");
+	prdata("  -f|--force                Override error checks\n");
+	prdata("  -v|--version              Print version\n");
+	prdata("  -h|--help                 Print this help\n");
 	prdata("\nValue Parameters:\n");
 	prdata("\n");
-	prdata("  -s|--rawset OFF,VAL   Set a VALue at a byte-OFFset\n");
-	prdata("  -g|--rawget OFF       Get a value at a byte-OFFset\n");
+	prdata("  -s|--rawset OFF,VAL       Set a VALue at a byte-OFFset\n");
+	prdata("  -g|--rawget OFF           Get a value at a byte-OFFset\n");
 	prdata("\n");
-	prdata("Predefined values (for displaying (GET) or modification):\n");
 
-	for (loop = 0; loop <= VAL_LAST; loop++) {
+	for (sprom_rev = 1; sprom_rev < 9; sprom_rev++) {
+	    if (sprom_rev == 6 || sprom_rev == 7)
+		sprom_rev = 8;
+
+	    rev_bit = BIT(sprom_rev);
+	    prdata("\n================================================================\n"
+	           "Rev. %d: Predefined values (for displaying (GET) or modification)\n"
+	           "================================================================\n", sprom_rev);
+
+	    for (loop = 0; loop <= VAL_LAST; loop++) {
 		if (locate_item_rev(rev_bit, loop, &length, &offset, &mask,
 			    &shift, desc, label))
 			continue;
@@ -759,16 +755,19 @@ static void print_usage(int argc, char *
 		}
 		buffer[28] = '\0';
 		prdata("%s%s\n", buffer, label);
+	    }
 	}
 
 	prdata("\n");
-	prdata("  -P|--print-all        Display all values\n");
+	prdata("  -P|--print-all            Display all values\n");
 	prdata("\n");
 	prdata(" BOOL      is a boolean value. Either 0 or 1\n");
 	prdata(" 0xF..     is a hexadecimal value\n");
 	prdata(" MAC-ADDR  is a MAC address in the format 00:00:00:00:00:00\n");
 	prdata(" If the value parameter is \"GET\", the value will be printed;\n");
 	prdata(" otherwise it is modified.\n");
+	prdata("\nBe exceedingly careful with this tool. Improper"
+	       " usage WILL BRICK YOUR DEVICE.\n");
 }
 
 #define ARG_MATCH		0


From mb at bu3sch.de  Mon Dec 29 18:18:56 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 29 Dec 2008 18:18:56 +0100
Subject: [PATCH] ssb-sprom: Generate help for all variations
In-Reply-To: <495904ae.3Rs95hJIVvgsxoGY%Larry.Finger@lwfinger.net>
References: <495904ae.3Rs95hJIVvgsxoGY%Larry.Finger@lwfinger.net>
Message-ID: <200812291818.56509.mb@bu3sch.de>

On Monday 29 December 2008 18:11:10 Larry Finger wrote:
> Revise ssb-sprom to generate the help data for all versions of the device.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>

Thanks.

-- 
Greetings, Michael.


