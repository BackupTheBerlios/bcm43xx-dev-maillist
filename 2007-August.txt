From richie at coderworld.net  Wed Aug  1 01:18:46 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Wed, 1 Aug 2007 01:18:46 +0200
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	=?iso-8859-1?q?=09uses_mac80211_as_MAC?= layer)
In-Reply-To: <46AD41AD.2020800@lwfinger.net>
References: <46AB5B9F.7030601@lwfinger.net>
	<200707292353.24897.richie@coderworld.net>
	<46AD41AD.2020800@lwfinger.net>
Message-ID: <200708010118.46200.richie@coderworld.net>

I found the problem. I didn't have CONFIG_DEBUG_FS which seems to be needed.
IMHO it should be selected automatically when debug is selected.
With debug_fs enabled I can remove and insert the module, scan network and 
associate just fine.
When 0-4 meters away from AP I get a steady rate of 18.5Mbps with iperf. When 
walking further away the transmission stops completely. This is when module 
is loaded and interface brought up next to the AP. I then get 54Mbit 
connection.

When loading the module from 5 metres away I get 1Mbit connection which is not 
very stable, but still usable.

Rate doesn't seem to change when signal drops. If it were I'm sure bcm4301 
would be on par or better than the driver for that other os.

I feel it's very close with this driver. I've never got more than 500kbit TX 
speed with the bcm43xx driver.

Keep up the good work!


From mb at bu3sch.de  Wed Aug  1 01:24:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 01:24:58 +0200
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	=?iso-8859-1?q?=09uses_mac80211_as_MAC?= layer)
In-Reply-To: <200708010118.46200.richie@coderworld.net>
References: <46AB5B9F.7030601@lwfinger.net> <46AD41AD.2020800@lwfinger.net>
	<200708010118.46200.richie@coderworld.net>
Message-ID: <200708010124.58365.mb@bu3sch.de>

On Wednesday 01 August 2007 01:18:46 Richard Jonsson wrote:
> I found the problem. I didn't have CONFIG_DEBUG_FS which seems to be needed.
> IMHO it should be selected automatically when debug is selected.

Whoops, no. This is a biiig bug and it should _not_ be SELECTed ;) 

-- 
Greetings Michael.


From andrew.james.barr at gmail.com  Wed Aug  1 01:28:19 2007
From: andrew.james.barr at gmail.com (Andrew J. Barr)
Date: Tue, 31 Jul 2007 19:28:19 -0400
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <200708010118.46200.richie@coderworld.net>
References: <46AB5B9F.7030601@lwfinger.net>
	<200707292353.24897.richie@coderworld.net>
	<46AD41AD.2020800@lwfinger.net>
	<200708010118.46200.richie@coderworld.net>
Message-ID: <903e17bb0707311628q7952fc76yf33dda3567a6f5ea@mail.gmail.com>

On 7/31/07, Richard Jonsson <richie at coderworld.net> wrote:
> When 0-4 meters away from AP I get a steady rate of 18.5Mbps with iperf. When
> walking further away the transmission stops completely. This is when module
> is loaded and interface brought up next to the AP. I then get 54Mbit
> connection.
>
> When loading the module from 5 metres away I get 1Mbit connection which is not
> very stable, but still usable.
>
> Rate doesn't seem to change when signal drops. If it were I'm sure bcm4301
> would be on par or better than the driver for that other os.

Same here, BCM4306, Apple PowerBook G4 17".

It works great until I get more than a few yards away, then...nothing.

-- 
Andrew Barr

We matter more than pounds and pence,
your economic theory makes no sense...


From larry.finger at lwfinger.net  Wed Aug  1 01:29:36 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 31 Jul 2007 18:29:36 -0500
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <200708010124.58365.mb@bu3sch.de>
References: <46AB5B9F.7030601@lwfinger.net> <46AD41AD.2020800@lwfinger.net>
	<200708010118.46200.richie@coderworld.net>
	<200708010124.58365.mb@bu3sch.de>
Message-ID: <46AFC5E0.8000200@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 01 August 2007 01:18:46 Richard Jonsson wrote:
>> I found the problem. I didn't have CONFIG_DEBUG_FS which seems to be needed.
>> IMHO it should be selected automatically when debug is selected.
> 
> Whoops, no. This is a biiig bug and it should _not_ be SELECTed ;) 

Why? My system has CONFIG_DEBUG_FS selected.

Larry




From mb at bu3sch.de  Wed Aug  1 01:45:04 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 01:45:04 +0200
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <46AFC5E0.8000200@lwfinger.net>
References: <46AB5B9F.7030601@lwfinger.net> <200708010124.58365.mb@bu3sch.de>
	<46AFC5E0.8000200@lwfinger.net>
Message-ID: <200708010145.04565.mb@bu3sch.de>

On Wednesday 01 August 2007 01:29:36 Larry Finger wrote:
> Michael Buesch wrote:
> > On Wednesday 01 August 2007 01:18:46 Richard Jonsson wrote:
> >> I found the problem. I didn't have CONFIG_DEBUG_FS which seems to be needed.
> >> IMHO it should be selected automatically when debug is selected.
> > 
> > Whoops, no. This is a biiig bug and it should _not_ be SELECTed ;) 
> 
> Why? My system has CONFIG_DEBUG_FS selected.

With not SELECTed I mean the KConfig SELECT statement.
That shouldn't be used here. He was talking about "selected automatically",
which is what KConfig SELECT does. And I said that this was not desired here.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Wed Aug  1 03:13:06 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 31 Jul 2007 20:13:06 -0500
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <903e17bb0707311628q7952fc76yf33dda3567a6f5ea@mail.gmail.com>
References: <46AB5B9F.7030601@lwfinger.net>	
	<200707292353.24897.richie@coderworld.net>	
	<46AD41AD.2020800@lwfinger.net>	
	<200708010118.46200.richie@coderworld.net>
	<903e17bb0707311628q7952fc76yf33dda3567a6f5ea@mail.gmail.com>
Message-ID: <46AFDE22.7080501@lwfinger.net>

Andrew J. Barr wrote:
> On 7/31/07, Richard Jonsson <richie at coderworld.net> wrote:
>> When 0-4 meters away from AP I get a steady rate of 18.5Mbps with iperf. When
>> walking further away the transmission stops completely. This is when module
>> is loaded and interface brought up next to the AP. I then get 54Mbit
>> connection.
>>
>> When loading the module from 5 metres away I get 1Mbit connection which is not
>> very stable, but still usable.
>>
>> Rate doesn't seem to change when signal drops. If it were I'm sure bcm4301
>> would be on par or better than the driver for that other os.
> 
> Same here, BCM4306, Apple PowerBook G4 17".
> 
> It works great until I get more than a few yards away, then...nothing.
> 
Please enter the command 'echo 1 > /sys/kernel/debug/bcm43xx/phyX/debug_xmitpower', where X is the 
correct value. It will start at 0 when just booted and increase by 1 each time the modules is 
reloaded. Send me the TX power output from dmesg.

Larry



From Larry.Finger at lwfinger.net  Wed Aug  1 03:18:31 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 31 Jul 2007 20:18:31 -0500
Subject: /sys/kernel/debug/bcm43xx/phyX
Message-ID: <46AFDF67.1040505@lwfinger.net>

Michael,

Is it expected that X in the subject will increase by 1 each time the bcm43xx-mac80211 module is 
unloaded and reloaded?

Larry


From Larry.Finger at lwfinger.net  Wed Aug  1 06:49:01 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 31 Jul 2007 23:49:01 -0500
Subject: Reason for power problem with bcm43xx
Message-ID: <46B010BD.1020207@lwfinger.net>

Guys,

Tonight I was looking at the output from TXpower debug as I moved my computer away from the AP, and 
began to wonder why the "desired power" was not changing as I did so. After dumping the portion of 
shared memory used in the calculation, I found that addresses 0x0058, 0x005A, 0x0070 and 0x0072 
always contain 0x7F7F, which is supposed to be the indication that no transmissions have been sent. 
Somewhere we seem to have missed a signal to the firmware to update these TSSI values, and the 
desired power never changes. Suddenly, the low power and the lack of adaptability with distance are 
no longer a mystery.

Does this ring any bells in the reverse engineering camp?

Would making a ring buffer containing the last 4 RSSI values be a first approximation to the TSSI's?

Larry




From larry.finger at lwfinger.net  Wed Aug  1 07:28:22 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 00:28:22 -0500
Subject: Reason for power problem with bcm43xx
In-Reply-To: <46B010BD.1020207@lwfinger.net>
References: <46B010BD.1020207@lwfinger.net>
Message-ID: <46B019F6.9050301@lwfinger.net>

Larry Finger wrote:
> Guys,
> 
> Tonight I was looking at the output from TXpower debug as I moved my computer away from the AP, and 
> began to wonder why the "desired power" was not changing as I did so. After dumping the portion of 
> shared memory used in the calculation, I found that addresses 0x0058, 0x005A, 0x0070 and 0x0072 
> always contain 0x7F7F, which is supposed to be the indication that no transmissions have been sent. 
> Somewhere we seem to have missed a signal to the firmware to update these TSSI values, and the 
> desired power never changes. Suddenly, the low power and the lack of adaptability with distance are 
> no longer a mystery.

Never mind - I found the place where the TSSI values are reset. I still wonder why desired power 
isn't a function of received power.

Larry


From johannes at sipsolutions.net  Wed Aug  1 11:16:08 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 01 Aug 2007 11:16:08 +0200
Subject: /sys/kernel/debug/bcm43xx/phyX
In-Reply-To: <46AFDF67.1040505@lwfinger.net>
References: <46AFDF67.1040505@lwfinger.net>
Message-ID: <1185959768.4006.106.camel@johannes.berg>

On Tue, 2007-07-31 at 20:18 -0500, Larry Finger wrote:

> Is it expected that X in the subject will increase by 1 each time the bcm43xx-mac80211 module is 
> unloaded and reloaded?

Yes; the phy number is the internal number that cfg80211 assigns. You
can, using nl80211, rename the PHY to something like "bcmphy0" if you
wish, but bcm43xx-mac80211 isn't yet using cfg80211's debugfs
provisioning (/sys/kernel/debug/ieee80211/phyX) so you wouldn't have it
stable even then.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070801/d767be4b/attachment.pgp>

From mb at bu3sch.de  Wed Aug  1 11:29:39 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 11:29:39 +0200
Subject: Reason for power problem with bcm43xx
In-Reply-To: <46B010BD.1020207@lwfinger.net>
References: <46B010BD.1020207@lwfinger.net>
Message-ID: <200708011129.39596.mb@bu3sch.de>

On Wednesday 01 August 2007, Larry Finger wrote:
> Guys,
> 
> Tonight I was looking at the output from TXpower debug as I moved my computer away from the AP, and 
> began to wonder why the "desired power" was not changing as I did so. After dumping the portion of 
> shared memory used in the calculation, I found that addresses 0x0058, 0x005A, 0x0070 and 0x0072 
> always contain 0x7F7F, which is supposed to be the indication that no transmissions have been sent. 
> Somewhere we seem to have missed a signal to the firmware to update these TSSI values, and the 
> desired power never changes. Suddenly, the low power and the lack of adaptability with distance are 
> no longer a mystery.

No, the desired power, is the power value we get from mac80211.
So it hardly changes.
The value from the SHM is the estimated current output power.
And it correctly estimates it for me on the 4306.
However it does not seem to work on the 4318. It always returns
20db there, which is bogus. I _think_ that on the 4318 the value
is generated by one of the new lookup tables. So I think there's
a bug in the lookup tables that are written for hwpctl devices.


From mb at bu3sch.de  Wed Aug  1 11:33:36 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 11:33:36 +0200
Subject: [PATCH FINAL] Merge the Sonics Silicon Backplane subsystem
In-Reply-To: <20070731202648.e1a8c45f.akpm@linux-foundation.org>
References: <200707291324.58691.mb@bu3sch.de>
	<20070731202648.e1a8c45f.akpm@linux-foundation.org>
Message-ID: <200708011133.37214.mb@bu3sch.de>

On Wednesday 01 August 2007, Andrew Morton wrote:
> On Sun, 29 Jul 2007 13:24:54 +0200 Michael Buesch <mb at bu3sch.de> wrote:
> 
> > The Sonics Silicon Backplane is a mini-bus used on
> > various Broadcom chips and embedded devices.
> 
> Sigh.
> 
> s390:
> 
> drivers/ssb/main.c: In function 'ssb_ssb_read16':
> drivers/ssb/main.c:489: error: implicit declaration of function 'readw'
> drivers/ssb/main.c: In function 'ssb_ssb_read32':
> drivers/ssb/main.c:497: error: implicit declaration of function 'readl'
> drivers/ssb/main.c: In function 'ssb_ssb_write16':
> drivers/ssb/main.c:505: error: implicit declaration of function 'writew'
> drivers/ssb/main.c: In function 'ssb_ssb_write32':
> drivers/ssb/main.c:513: error: implicit declaration of function 'writel'        
> 
> we shouldn't be compiling SSB on s390, because:
> 
> config SSB
>         tristate "Sonics Silicon Backplane support"
>         depends on EXPERIMENTAL && HAS_IOMEM
> 
> and
> 
> akpm2:/usr/src/25> grep IOMEM .config 
> CONFIG_NO_IOMEM=y
> akpm2:/usr/src/25> 
> 
> but
> 
> akpm2:/usr/src/25> grep SSB .config 
> CONFIG_DCSSBLK=m
> CONFIG_SSB=m
> CONFIG_SSB_SILENT=y
> 
> well, how did that come about?
> 
> It _has_ to be `select'.  It's _always_ `select'.
> 
> yup, it's `select':
> 
> Selected by: B44 && NETDEVICES && NET_ETHERNET || BCM43XX_MAC80211 && NETDEVICES && !S390 && MAC80211 && WLAN_80211 && EXPERIMENTAL
> 
> 
> Look.  Kconfig's `select' Just.  Does.  Not.  Work.  If you find yourself
> contemplating using it, please, don sackcloth, take a cold shower and
> several analgesics, then have another go, OK?
> 
> ho hum.

Ah, yeah. Crap select not caring about dependencies...
The problem is that people will kill me, if they don't find
bcm43xx in the kconfig anymore, as they have to enable ssb
before that. Ya know the flame with Uwe Bugla going crazy
about that? :D
Same goes for b44. It was always there in kconfig without
additional deps, but now (when we merge the b44 port) we would
need ssb selected before we see b44.
Maybe default SSB to M?


From dwmw2 at infradead.org  Wed Aug  1 11:42:43 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Wed, 01 Aug 2007 10:42:43 +0100
Subject: [PATCH FINAL] Merge the Sonics Silicon Backplane subsystem
In-Reply-To: <20070731202648.e1a8c45f.akpm@linux-foundation.org>
References: <200707291324.58691.mb@bu3sch.de>
	<20070731202648.e1a8c45f.akpm@linux-foundation.org>
Message-ID: <1185961363.3083.130.camel@pmac.infradead.org>

On Tue, 2007-07-31 at 20:26 -0700, Andrew Morton wrote:
> Look.  Kconfig's `select' Just.  Does.  Not.  Work.  If you find
> yourself contemplating using it, please, don sackcloth, take a cold
> shower and several analgesics, then have another go, OK?

Amen.

-- 
dwmw2



From richie at coderworld.net  Wed Aug  1 12:17:59 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Wed, 1 Aug 2007 12:17:59 +0200
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <46AFDE22.7080501@lwfinger.net>
References: <46AB5B9F.7030601@lwfinger.net>
	<903e17bb0707311628q7952fc76yf33dda3567a6f5ea@mail.gmail.com>
	<46AFDE22.7080501@lwfinger.net>
Message-ID: <200708011217.59640.richie@coderworld.net>

> Please enter the command 'echo 1 >
> /sys/kernel/debug/bcm43xx/phyX/debug_xmitpower', where X is the correct
> value. It will start at 0 when just booted and increase by 1 each time the
> modules is reloaded. Send me the TX power output from dmesg.
>
> Larry

Just for reference:
For me /sys/kernel/debug was empty, although I had all required settings in 
the kernel. Turns out debugfs needs to be mounted, obvious to most, but not 
to me. Maybe this is handled automatically for most distros.

Run "mount debugfs -t debugfs /sys/kernel/debug" and it should work.


From larry.finger at lwfinger.net  Wed Aug  1 13:57:55 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 06:57:55 -0500
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <200708011217.59640.richie@coderworld.net>
References: <46AB5B9F.7030601@lwfinger.net>	<903e17bb0707311628q7952fc76yf33dda3567a6f5ea@mail.gmail.com>	<46AFDE22.7080501@lwfinger.net>
	<200708011217.59640.richie@coderworld.net>
Message-ID: <46B07543.802@lwfinger.net>

Richard Jonsson wrote:
>> Please enter the command 'echo 1 >
>> /sys/kernel/debug/bcm43xx/phyX/debug_xmitpower', where X is the correct
>> value. It will start at 0 when just booted and increase by 1 each time the
>> modules is reloaded. Send me the TX power output from dmesg.
>>
>> Larry
> 
> Just for reference:
> For me /sys/kernel/debug was empty, although I had all required settings in 
> the kernel. Turns out debugfs needs to be mounted, obvious to most, but not 
> to me. Maybe this is handled automatically for most distros.
> 
> Run "mount debugfs -t debugfs /sys/kernel/debug" and it should work.

Or add the line 'debugfs /sys/kernel/debug debugfs noauto 0 0' to /etc/fstab, which is how my system 
does it.

Larry


From larry.finger at lwfinger.net  Wed Aug  1 18:06:36 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 11:06:36 -0500
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <200708010118.46200.richie@coderworld.net>
References: <46AB5B9F.7030601@lwfinger.net>
	<200707292353.24897.richie@coderworld.net>
	<46AD41AD.2020800@lwfinger.net>
	<200708010118.46200.richie@coderworld.net>
Message-ID: <46B0AF8C.4090608@lwfinger.net>

Richard Jonsson wrote:
> I found the problem. I didn't have CONFIG_DEBUG_FS which seems to be needed.
> IMHO it should be selected automatically when debug is selected.
> With debug_fs enabled I can remove and insert the module, scan network and 
> associate just fine.
> When 0-4 meters away from AP I get a steady rate of 18.5Mbps with iperf. When 
> walking further away the transmission stops completely. This is when module 
> is loaded and interface brought up next to the AP. I then get 54Mbit 
> connection.
> 
> When loading the module from 5 metres away I get 1Mbit connection which is not 
> very stable, but still usable.
> 
> Rate doesn't seem to change when signal drops. If it were I'm sure bcm4301 
> would be on par or better than the driver for that other os.
> 
> I feel it's very close with this driver. I've never got more than 500kbit TX 
> speed with the bcm43xx driver.

I think there are two problems with the driver when walking away from the AP. The first is that the
driver has not been telling mac80211 that it is time to consider cutting the transfer rate. The
second is that we currently have no means of increasing the transmit power as we move further from
the AP.

A fix for problem #1 is attached. I think I have something for the second, but it needs more testing.

Larry



-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: rate_adjust
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070801/c71191ac/attachment.ksh>

From andrig.t.miller at gmail.com  Wed Aug  1 18:19:59 2007
From: andrig.t.miller at gmail.com (Andrig T. Miller)
Date: Wed, 1 Aug 2007 10:19:59 -0600
Subject: Report on BCM4318 under Fedora 7
Message-ID: <313c6e90708010919g61824599m852b425dd9e5c300@mail.gmail.com>

I have been playing with the bcm43xx driver since the beginning, and I
thought I would post what I now see under Fedora 7.

First, Fedora seems to only have the bcm43xx-mac80211 driver now, and so I
am using the v4 firmware from the link you guys have provided.

The driver loads, and here is what I get in dmesg:

ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x0D, vendor 0x4243)
ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x09, vendor 0x4243)
ssb: Core 2 found: PCI (cc 0x804, rev 0x0C, vendor 0x4243)
ssb: Core 3 found: PCMCIA (cc 0x80D, rev 0x07, vendor 0x4243)
ssb: Switching to ChipCommon core, index 0
ssb: Switching to PCI core, index 2
ssb: Sonics Silicon Backplane found on PCI device 0000:06:02.0
bcm43xx-phy0: Broadcom 4318 WLAN found
ssb: Switching to IEEE 802.11 core, index 1
bcm43xx-phy0 debug: Found PHY: Analog 3, Type 2, Revision 7
bcm43xx-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 8
bcm43xx-phy0 debug: Radio turned off
wmaster0: Selected rate control algorithm 'simple'

ifconfig reports the following:

wlan0     Link encap:Ethernet  HWaddr 00:14:A5:B2:AF:40
          inet addr:192.168.1.102  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::214:a5ff:feb2:af40/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1684 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1648 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:702701 (686.2 KiB)  TX bytes:395884 (386.6 KiB)

wmaster0  Link encap:UNSPEC  HWaddr
00-14-A5-B2-AF-40-00-00-00-00-00-00-00-00-00-00
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)

iwconfig reports the following:

wmaster0  no wireless extensions.

wlan0     IEEE 802.11g  ESSID:"NetGearAndrigAtHome"
          Mode:Managed  Frequency:2.462 GHz  Access Point:
00:09:5B:B8:BD:75
          Bit Rate=1 Mb/s
          Retry min limit:7   RTS thr:off   Fragment thr=2346 B
          Encryption
key:C61C-1152-BB6D-7512-45B7-F4FA-0165-E96D-8D7B-5920-B634-7DA7-B8EA-991C-14C2-193F
[2]
          Link Quality=106/100  Signal level=-38 dBm  Noise level=-73 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

iwlist wlan0 scanning reports:

Cell 02 - Address: 00:09:5B:B8:BD:75
                    ESSID:"NetGearAndrigAtHome"
                    Mode:Master
                    Channel:11
                    Frequency:2.462 GHz (Channel 11)
                    Quality=37/100  Signal level=-46 dBm  Noise level=-72
dBm
                    Encryption key:on
                    IE: WPA Version 1
                        Group Cipher : TKIP
                        Pairwise Ciphers (1) : TKIP
                        Authentication Suites (1) : PSK
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s
                              9 Mb/s; 12 Mb/s; 18 Mb/s; 24 Mb/s; 36 Mb/s
                              48 Mb/s; 54 Mb/s
                    Extra:tsf=000000000084cc27

I left out my neighbors access point, but this shows mine, and I am
successfully connnecting with WPA Personal.

The performance is very poor, as it is only connecting at 1 Mb/s, and the
signal strength varies wildly between around 30% to 100% at times.  Also,
NetworkManager reports that the driver is bcm43xx-pci, if you look at the
connection information.  Not sure what that means, but lsmod reports the
following:

lsmod | grep bcm
bcm43xx_mac80211      417697  0
ssb                    43461  1 bcm43xx_mac80211
mac80211              165705  2 rc80211_simple,bcm43xx_mac80211

So, in short the driver is working, but the bitrate is very low, and it
makes using it nearly impossible.  If there is other information I can
provide that would be helpful in improving this, please let me know, and I
will carve out some time to collect it for you.

By the way, thanks for all the hard work on the driver.  It is really
getting better, and if I can get the performance issue solved, I would be
using it instead of my additional PCMCIA card with the Atheros chip set.

Andy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070801/e451923c/attachment.html>

From mb at bu3sch.de  Wed Aug  1 20:20:36 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 20:20:36 +0200
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <46B0AF8C.4090608@lwfinger.net>
References: <46AB5B9F.7030601@lwfinger.net>
	<200708010118.46200.richie@coderworld.net>
	<46B0AF8C.4090608@lwfinger.net>
Message-ID: <200708012020.36282.mb@bu3sch.de>

On Wednesday 01 August 2007 18:06:36 Larry Finger wrote:
> Richard Jonsson wrote:
> > I found the problem. I didn't have CONFIG_DEBUG_FS which seems to be needed.
> > IMHO it should be selected automatically when debug is selected.
> > With debug_fs enabled I can remove and insert the module, scan network and 
> > associate just fine.
> > When 0-4 meters away from AP I get a steady rate of 18.5Mbps with iperf. When 
> > walking further away the transmission stops completely. This is when module 
> > is loaded and interface brought up next to the AP. I then get 54Mbit 
> > connection.
> > 
> > When loading the module from 5 metres away I get 1Mbit connection which is not 
> > very stable, but still usable.
> > 
> > Rate doesn't seem to change when signal drops. If it were I'm sure bcm4301 
> > would be on par or better than the driver for that other os.
> > 
> > I feel it's very close with this driver. I've never got more than 500kbit TX 
> > speed with the bcm43xx driver.
> 
> I think there are two problems with the driver when walking away from the AP. The first is that the
> driver has not been telling mac80211 that it is time to consider cutting the transfer rate. The
> second is that we currently have no means of increasing the transmit power as we move further from
> the AP.
> 
> A fix for problem #1 is attached. I think I have something for the second, but it needs more testing.

Hm, yes there might be a bug.
But I'm not convinced the attached patch was right.
I'm not sure what happens in the TX status reports for packets that don't
get acked. But I think it would just return not-acked and a retry count of 1.
So what we really want here is to check if the retry count is equal to maximum.
Well, what is maximum. See the other fixme in that code there where we check
the RTS retry count. The retry count is adjustable and currently we don't keep
track of it. And there's even a difference between short and long packets.
Look for short vs long retry limit.
Not that easy to fix, actually.
Anyway, I think we should configure the retry limits through cfg80211.

-- 
Greetings Michael.


From mb at bu3sch.de  Wed Aug  1 20:22:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 20:22:51 +0200
Subject: Report on BCM4318 under Fedora 7
In-Reply-To: <313c6e90708010919g61824599m852b425dd9e5c300@mail.gmail.com>
References: <313c6e90708010919g61824599m852b425dd9e5c300@mail.gmail.com>
Message-ID: <200708012022.52104.mb@bu3sch.de>

On Wednesday 01 August 2007 18:19:59 Andrig T. Miller wrote:
> I have been playing with the bcm43xx driver since the beginning, and I
> thought I would post what I now see under Fedora 7.
> 
> First, Fedora seems to only have the bcm43xx-mac80211 driver now, and so I
> am using the v4 firmware from the link you guys have provided.
> 
> The driver loads, and here is what I get in dmesg:
> 
> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x0D, vendor 0x4243)
> ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x09, vendor 0x4243)
> ssb: Core 2 found: PCI (cc 0x804, rev 0x0C, vendor 0x4243)
> ssb: Core 3 found: PCMCIA (cc 0x80D, rev 0x07, vendor 0x4243)
> ssb: Switching to ChipCommon core, index 0
> ssb: Switching to PCI core, index 2
> ssb: Sonics Silicon Backplane found on PCI device 0000:06:02.0
> bcm43xx-phy0: Broadcom 4318 WLAN found
> ssb: Switching to IEEE 802.11 core, index 1
> bcm43xx-phy0 debug: Found PHY: Analog 3, Type 2, Revision 7
> bcm43xx-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 8
> bcm43xx-phy0 debug: Radio turned off
> wmaster0: Selected rate control algorithm 'simple'
> 
> ifconfig reports the following:
> 
> wlan0     Link encap:Ethernet  HWaddr 00:14:A5:B2:AF:40
>           inet addr:192.168.1.102  Bcast:192.168.1.255  Mask:255.255.255.0
>           inet6 addr: fe80::214:a5ff:feb2:af40/64 Scope:Link
>           UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
>           RX packets:1684 errors:0 dropped:0 overruns:0 frame:0
>           TX packets:1648 errors:0 dropped:0 overruns:0 carrier:0
>           collisions:0 txqueuelen:1000
>           RX bytes:702701 (686.2 KiB)  TX bytes:395884 (386.6 KiB)
> 
> wmaster0  Link encap:UNSPEC  HWaddr
> 00-14-A5-B2-AF-40-00-00-00-00-00-00-00-00-00-00
>           UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
>           RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>           TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>           collisions:0 txqueuelen:1000
>           RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
> 
> iwconfig reports the following:
> 
> wmaster0  no wireless extensions.
> 
> wlan0     IEEE 802.11g  ESSID:"NetGearAndrigAtHome"
>           Mode:Managed  Frequency:2.462 GHz  Access Point:
> 00:09:5B:B8:BD:75
>           Bit Rate=1 Mb/s
>           Retry min limit:7   RTS thr:off   Fragment thr=2346 B
>           Encryption
> key:C61C-1152-BB6D-7512-45B7-F4FA-0165-E96D-8D7B-5920-B634-7DA7-B8EA-991C-14C2-193F
> [2]
>           Link Quality=106/100  Signal level=-38 dBm  Noise level=-73 dBm
>           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> 
> iwlist wlan0 scanning reports:
> 
> Cell 02 - Address: 00:09:5B:B8:BD:75
>                     ESSID:"NetGearAndrigAtHome"
>                     Mode:Master
>                     Channel:11
>                     Frequency:2.462 GHz (Channel 11)
>                     Quality=37/100  Signal level=-46 dBm  Noise level=-72
> dBm
>                     Encryption key:on
>                     IE: WPA Version 1
>                         Group Cipher : TKIP
>                         Pairwise Ciphers (1) : TKIP
>                         Authentication Suites (1) : PSK
>                     Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s
>                               9 Mb/s; 12 Mb/s; 18 Mb/s; 24 Mb/s; 36 Mb/s
>                               48 Mb/s; 54 Mb/s
>                     Extra:tsf=000000000084cc27
> 
> I left out my neighbors access point, but this shows mine, and I am
> successfully connnecting with WPA Personal.
> 
> The performance is very poor, as it is only connecting at 1 Mb/s, and the
> signal strength varies wildly between around 30% to 100% at times.  Also,
> NetworkManager reports that the driver is bcm43xx-pci, if you look at the
> connection information.  Not sure what that means, but lsmod reports the
> following:
> 
> lsmod | grep bcm
> bcm43xx_mac80211      417697  0
> ssb                    43461  1 bcm43xx_mac80211
> mac80211              165705  2 rc80211_simple,bcm43xx_mac80211
> 
> So, in short the driver is working, but the bitrate is very low, and it
> makes using it nearly impossible.  If there is other information I can
> provide that would be helpful in improving this, please let me know, and I
> will carve out some time to collect it for you.
> 
> By the way, thanks for all the hard work on the driver.  It is really
> getting better, and if I can get the performance issue solved, I would be
> using it instead of my additional PCMCIA card with the Atheros chip set.

That's a known bug and I am currently trying to find out why it
fails to tune the power to higher levels.
Even adjusting power manually doesn't have any effect. So it's not
a bug in the power scaling algorithm, but deeper in the attenuation adjustment.
Might be some broken table upload.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Wed Aug  1 20:34:21 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 13:34:21 -0500
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <200708012020.36282.mb@bu3sch.de>
References: <46AB5B9F.7030601@lwfinger.net>	<200708010118.46200.richie@coderworld.net>	<46B0AF8C.4090608@lwfinger.net>
	<200708012020.36282.mb@bu3sch.de>
Message-ID: <46B0D22D.5000604@lwfinger.net>

Michael Buesch wrote:
> 
> Hm, yes there might be a bug.
> But I'm not convinced the attached patch was right.
> I'm not sure what happens in the TX status reports for packets that don't
> get acked. But I think it would just return not-acked and a retry count of 1.
> So what we really want here is to check if the retry count is equal to maximum.
> Well, what is maximum. See the other fixme in that code there where we check
> the RTS retry count. The retry count is adjustable and currently we don't keep
> track of it. And there's even a difference between short and long packets.
> Look for short vs long retry limit.
> Not that easy to fix, actually.
> Anyway, I think we should configure the retry limits through cfg80211.

I thought the firmware did the retries without intervention and would only come back when those were 
exhausted. Why else would the retry count be stored in shared memory?

Larry





From larry.finger at lwfinger.net  Wed Aug  1 20:40:59 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 13:40:59 -0500
Subject: Report on BCM4318 under Fedora 7
In-Reply-To: <200708012022.52104.mb@bu3sch.de>
References: <313c6e90708010919g61824599m852b425dd9e5c300@mail.gmail.com>
	<200708012022.52104.mb@bu3sch.de>
Message-ID: <46B0D3BB.1040705@lwfinger.net>

Michael Buesch wrote:
> 
> That's a known bug and I am currently trying to find out why it
> fails to tune the power to higher levels.
> Even adjusting power manually doesn't have any effect. So it's not
> a bug in the power scaling algorithm, but deeper in the attenuation adjustment.
> Might be some broken table upload.
> 

It is something in the PHY initialization. I don't get sparking performance with a 4318 using the 
new port from softmac to mac80211, but I do get usable performance of at least 5 Mbs for all rates, 
even at 15-20 m from the AP. One thing is that the signal level from iwconfig is very low at -61 
dBm; whereas, the 4311 gives -37 at the same position relative to the AP. The noise values are both 
-72 dBm.

Larry



From mb at bu3sch.de  Wed Aug  1 20:44:14 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 20:44:14 +0200
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	=?iso-8859-1?q?=09uses_mac80211_as_MAC?= layer)
In-Reply-To: <46B0D22D.5000604@lwfinger.net>
References: <46AB5B9F.7030601@lwfinger.net> <200708012020.36282.mb@bu3sch.de>
	<46B0D22D.5000604@lwfinger.net>
Message-ID: <200708012044.14706.mb@bu3sch.de>

On Wednesday 01 August 2007 20:34:21 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > Hm, yes there might be a bug.
> > But I'm not convinced the attached patch was right.
> > I'm not sure what happens in the TX status reports for packets that don't
> > get acked. But I think it would just return not-acked and a retry count of 1.
> > So what we really want here is to check if the retry count is equal to maximum.
> > Well, what is maximum. See the other fixme in that code there where we check
> > the RTS retry count. The retry count is adjustable and currently we don't keep
> > track of it. And there's even a difference between short and long packets.
> > Look for short vs long retry limit.
> > Not that easy to fix, actually.
> > Anyway, I think we should configure the retry limits through cfg80211.
> 
> I thought the firmware did the retries without intervention and would only come back when those were 
> exhausted. Why else would the retry count be stored in shared memory?

The retry counts are not stored in SHM. They are stored in the TX status report.
(The counts in SHM are just debugging stuff)

-- 
Greetings Michael.


From mb at bu3sch.de  Wed Aug  1 20:54:47 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 20:54:47 +0200
Subject: Report on BCM4318 under Fedora 7
In-Reply-To: <46B0D3BB.1040705@lwfinger.net>
References: <313c6e90708010919g61824599m852b425dd9e5c300@mail.gmail.com>
	<200708012022.52104.mb@bu3sch.de> <46B0D3BB.1040705@lwfinger.net>
Message-ID: <200708012054.47368.mb@bu3sch.de>

On Wednesday 01 August 2007 20:40:59 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > That's a known bug and I am currently trying to find out why it
> > fails to tune the power to higher levels.
> > Even adjusting power manually doesn't have any effect. So it's not
> > a bug in the power scaling algorithm, but deeper in the attenuation adjustment.
> > Might be some broken table upload.
> > 
> 
> It is something in the PHY initialization. I don't get sparking performance with a 4318 using the 
> new port from softmac to mac80211, but I do get usable performance of at least 5 Mbs for all rates, 
> even at 15-20 m from the AP. One thing is that the signal level from iwconfig is very low at -61 
> dBm; whereas, the 4311 gives -37 at the same position relative to the AP. The noise values are both 
> -72 dBm.

Sure, you are absolutely right. If I define has_hardware_pctl() to
always be 0, I get better performance. So we somewhere blow up
the hwpctl init. I'm debugging this at the moment.

-- 
Greetings Michael.


From mb at bu3sch.de  Wed Aug  1 21:02:41 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 21:02:41 +0200
Subject: Report on BCM4318 under Fedora 7
In-Reply-To: <200708012054.47368.mb@bu3sch.de>
References: <313c6e90708010919g61824599m852b425dd9e5c300@mail.gmail.com>
	<46B0D3BB.1040705@lwfinger.net> <200708012054.47368.mb@bu3sch.de>
Message-ID: <200708012102.41240.mb@bu3sch.de>

On Wednesday 01 August 2007 20:54:47 Michael Buesch wrote:
> On Wednesday 01 August 2007 20:40:59 Larry Finger wrote:
> > Michael Buesch wrote:
> > > 
> > > That's a known bug and I am currently trying to find out why it
> > > fails to tune the power to higher levels.
> > > Even adjusting power manually doesn't have any effect. So it's not
> > > a bug in the power scaling algorithm, but deeper in the attenuation adjustment.
> > > Might be some broken table upload.
> > > 
> > 
> > It is something in the PHY initialization. I don't get sparking performance with a 4318 using the 
> > new port from softmac to mac80211, but I do get usable performance of at least 5 Mbs for all rates, 
> > even at 15-20 m from the AP. One thing is that the signal level from iwconfig is very low at -61 
> > dBm; whereas, the 4311 gives -37 at the same position relative to the AP. The noise values are both 
> > -72 dBm.
> 
> Sure, you are absolutely right. If I define has_hardware_pctl() to
> always be 0, I get better performance. So we somewhere blow up
> the hwpctl init. I'm debugging this at the moment.

No I don't. Hum.
But today I get rather good performance (well compared to yesterday)
from my tree. Seems to depend on the moonphase or something.

I hate benchmarking.

-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Wed Aug  1 21:55:42 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 14:55:42 -0500
Subject: [RFC] bcm43xx-mac80211: Provide information to allow transmission
	rate decreases
Message-ID: <46b0e53e.ouY931+cZsSSSmLK%Larry.Finger@lwfinger.net>

Michael,

This version saves the long- and short-retry limits in the phy struct
and only sets excessive retries when one or the other is reached.

Larry
---

In bcm43xx-mac80211, the mechanism for decreasing the transmit rate cannot
be triggered. This may be shown by walking away from the AP with a laptop.
At some distance, communications will be lost and never recovered because
the rate decreasing mechanism of rc80211_simple needs to see excessive_retries
set in the ieee80211_tx_status struct. With this patch, the transmit rate
will decrease until communications restart.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
@@ -1284,6 +1284,7 @@ void bcm43xx_dma_handle_txstatus(struct 
 	struct bcm43xx_dmaring *ring;
 	struct bcm43xx_dmadesc_generic *desc;
 	struct bcm43xx_dmadesc_meta *meta;
+	struct bcm43xx_phy *phy = &dev->phy;
 	int slot;
 
 	ring = parse_cookie(dev, status->cookie, &slot);
@@ -1311,6 +1312,10 @@ void bcm43xx_dma_handle_txstatus(struct 
 			 */
 			if (status->acked)
 				meta->txstat.flags |= IEEE80211_TX_STATUS_ACK;
+			else
+				if ((status->frame_count >= phy->lrlimit) ||
+				    (status->frame_count >= phy->srlimit))
+					meta->txstat.excessive_retries = 1;
 			meta->txstat.retry_count = status->frame_count - 1;
 			ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb, &(meta->txstat));
 			/* skb is freed by ieee80211_tx_status_irqsafe() */
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
@@ -562,6 +562,8 @@ struct bcm43xx_phy {
 	u16 lofcal;
 
 	u16 initval;//FIXME rename?
+	u8 srlimit;
+	u8 lrlimit;
 };
 
 /* Data structures for DMA transmission, per 80211 core. */
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -3333,10 +3333,12 @@ static int bcm43xx_wireless_core_init(st
 	tmp = limit_value(modparam_short_retry, 0, 0xF);
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
 			    BCM43xx_SHM_SC_SRLIMIT, tmp);
+	phy->srlimit = tmp;
 	tmp = limit_value(modparam_long_retry, 0, 0xF);
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
 			    BCM43xx_SHM_SC_LRLIMIT, tmp);
 
+	phy->lrlimit = tmp;
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
 			    BCM43xx_SHM_SH_SFFBLIM, 3);
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,


From mb at bu3sch.de  Wed Aug  1 22:05:16 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 22:05:16 +0200
Subject: [RFC] bcm43xx-mac80211: Provide information to allow transmission
	rate decreases
In-Reply-To: <46b0e53e.ouY931+cZsSSSmLK%Larry.Finger@lwfinger.net>
References: <46b0e53e.ouY931+cZsSSSmLK%Larry.Finger@lwfinger.net>
Message-ID: <200708012205.16529.mb@bu3sch.de>

On Wednesday 01 August 2007 21:55:42 Larry Finger wrote:
> Michael,
> 
> This version saves the long- and short-retry limits in the phy struct
> and only sets excessive retries when one or the other is reached.
> 
> Larry
> ---
> 
> In bcm43xx-mac80211, the mechanism for decreasing the transmit rate cannot
> be triggered. This may be shown by walking away from the AP with a laptop.
> At some distance, communications will be lost and never recovered because
> the rate decreasing mechanism of rc80211_simple needs to see excessive_retries
> set in the ieee80211_tx_status struct. With this patch, the transmit rate
> will decrease until communications restart.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> @@ -1284,6 +1284,7 @@ void bcm43xx_dma_handle_txstatus(struct 
>  	struct bcm43xx_dmaring *ring;
>  	struct bcm43xx_dmadesc_generic *desc;
>  	struct bcm43xx_dmadesc_meta *meta;
> +	struct bcm43xx_phy *phy = &dev->phy;
>  	int slot;
>  
>  	ring = parse_cookie(dev, status->cookie, &slot);
> @@ -1311,6 +1312,10 @@ void bcm43xx_dma_handle_txstatus(struct 
>  			 */
>  			if (status->acked)
>  				meta->txstat.flags |= IEEE80211_TX_STATUS_ACK;
> +			else
> +				if ((status->frame_count >= phy->lrlimit) ||
> +				    (status->frame_count >= phy->srlimit))
> +					meta->txstat.excessive_retries = 1;

No, you need something like

if (is long frame)
	if (cnt >= long_limit)
		foo;
else
	if (cnt >= short_limit)
		foo;

And please use variable names like
short_retry_limit or something like that. It's more to type but
soooooo much easier to read :)
You could probably shorten that by short_retr_lim.

And I think we should store the stuff in struct bcm43xx_wldev, as it's
a mac attribute.
bcm43xx_phy is more about the actual PHY hardware calibration and stuff.

We tell the FW whether it's a long or short frame in the TXheader generation.

>  			meta->txstat.retry_count = status->frame_count - 1;
>  			ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb, &(meta->txstat));
>  			/* skb is freed by ieee80211_tx_status_irqsafe() */
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> @@ -562,6 +562,8 @@ struct bcm43xx_phy {
>  	u16 lofcal;
>  
>  	u16 initval;//FIXME rename?
> +	u8 srlimit;
> +	u8 lrlimit;
>  };
>  
>  /* Data structures for DMA transmission, per 80211 core. */
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -3333,10 +3333,12 @@ static int bcm43xx_wireless_core_init(st
>  	tmp = limit_value(modparam_short_retry, 0, 0xF);
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
>  			    BCM43xx_SHM_SC_SRLIMIT, tmp);
> +	phy->srlimit = tmp;
>  	tmp = limit_value(modparam_long_retry, 0, 0xF);
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
>  			    BCM43xx_SHM_SC_LRLIMIT, tmp);
>  
> +	phy->lrlimit = tmp;
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
>  			    BCM43xx_SHM_SH_SFFBLIM, 3);
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,


-- 
Greetings Michael.


From larry.finger at lwfinger.net  Wed Aug  1 22:16:33 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 15:16:33 -0500
Subject: Report on BCM4318 under Fedora 7
In-Reply-To: <200708012102.41240.mb@bu3sch.de>
References: <313c6e90708010919g61824599m852b425dd9e5c300@mail.gmail.com>	<46B0D3BB.1040705@lwfinger.net>
	<200708012054.47368.mb@bu3sch.de> <200708012102.41240.mb@bu3sch.de>
Message-ID: <46B0EA21.6070509@lwfinger.net>

Michael Buesch wrote:
> 
> No I don't. Hum.
> But today I get rather good performance (well compared to yesterday)
> from my tree. Seems to depend on the moonphase or something.
> 
> I hate benchmarking.
> 

I know how you feel. Today, I dug out the frequency analyzer to see how the power looked. The 4311, 
which has the highest transfer numbers, has the lowest peak amplitude - about -70 dBm. The 4306 has 
amplitudes of -50 dBm, but the frequency spread is quite large and asymmetric. Although it is set 
for channel 1, there is a tail that extends to channel 7. The 4318 has even higher power - it 
saturates the detector as does the AP, which is at about the same distance as the laptops.

If I bump up the power from 6.75 to 8.75 dBm, the maximum throughput of the 4311 reaches over 20 
Mbs, which is higher than Windows gets for the same setup.

Larry



From comphappy at gmail.com  Wed Aug  1 22:19:21 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Wed, 1 Aug 2007 13:19:21 -0700
Subject: Report on BCM4318 under Fedora 7
In-Reply-To: <200708012102.41240.mb@bu3sch.de>
References: <313c6e90708010919g61824599m852b425dd9e5c300@mail.gmail.com>
	<46B0D3BB.1040705@lwfinger.net> <200708012054.47368.mb@bu3sch.de>
	<200708012102.41240.mb@bu3sch.de>
Message-ID: <b2d05de20708011319y5c5c2051k2dcc180664324e96@mail.gmail.com>

> No I don't. Hum.
> But today I get rather good performance (well compared to yesterday)
> from my tree. Seems to depend on the moonphase or something.
>
> I hate benchmarking.
>
I am willing to help with benchmarking, just tell me what you want.
Card: bcm4311
on the edge of lost signal
eth1      IEEE 802.11b/g  ESSID:"thishome"  Nickname:"Broadcom 4311"
          Mode:Managed  Frequency=2.437 GHz  Access Point: 00:12:17:AA:84:67
          Bit Rate=24 Mb/s   Tx-Power=18 dBm
          RTS thr:off   Fragment thr:off
          Encryption
key:FC73-2B97-E56C-128C-EA93-BCCF-37C0-F940-F79D-1CA0-AC32-A2A4-24B5-6E1A-B930-B64C
  Security mode:open
          Link Quality=58/100  Signal level=-69 dBm  Noise level=-69 dBm
          Rx invalid nwid:0  Rx invalid crypt:74  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From mb at bu3sch.de  Wed Aug  1 22:32:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 22:32:58 +0200
Subject: txpower adjustment bouncing
Message-ID: <200708012232.58299.mb@bu3sch.de>

I analyzed the bouncing of the estimated TX power
output versus the desired power.

Here's the hacky script to parse dmesg.
It takes a number as arg. It's the PHY number.
It requires printk times to be enabled in kconfig.

Looks pretty good. Though, it begins to bounce at the end.
Not sure what happened there.

-- 
Greetings Michael.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: txpower_on_4306.ods
Type: application/vnd.oasis.opendocument.spreadsheet
Size: 20593 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070801/07323f05/attachment.ods>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: txpower2csv.sh
Type: application/x-shellscript
Size: 449 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070801/07323f05/attachment.bin>

From mb at bu3sch.de  Wed Aug  1 22:24:13 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 1 Aug 2007 22:24:13 +0200
Subject: Report on BCM4318 under Fedora 7
In-Reply-To: <46B0EA21.6070509@lwfinger.net>
References: <313c6e90708010919g61824599m852b425dd9e5c300@mail.gmail.com>
	<200708012102.41240.mb@bu3sch.de> <46B0EA21.6070509@lwfinger.net>
Message-ID: <200708012224.13318.mb@bu3sch.de>

On Wednesday 01 August 2007 22:16:33 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > No I don't. Hum.
> > But today I get rather good performance (well compared to yesterday)
> > from my tree. Seems to depend on the moonphase or something.
> > 
> > I hate benchmarking.
> > 
> 
> I know how you feel. Today, I dug out the frequency analyzer to see how the power looked. The 4311, 
> which has the highest transfer numbers, has the lowest peak amplitude - about -70 dBm. The 4306 has 
> amplitudes of -50 dBm, but the frequency spread is quite large and asymmetric. Although it is set 
> for channel 1, there is a tail that extends to channel 7. The 4318 has even higher power - it 
> saturates the detector as does the AP, which is at about the same distance as the laptops.
> 
> If I bump up the power from 6.75 to 8.75 dBm, the maximum throughput of the 4311 reaches over 20 
> Mbs, which is higher than Windows gets for the same setup.

But not with my tree!?

-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Wed Aug  1 22:56:07 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 15:56:07 -0500
Subject: [RFC V2] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
Message-ID: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>

Michael,

I think I took care of your comments in the previous version.

Larry
---

In bcm43xx-mac80211, the mechanism for decreasing the transmit rate cannot
be triggered. This may be shown by walking away from the AP with a laptop.
At some distance, communications will be lost and never recovered because
the rate decreasing mechanism of rc80211_simple needs to see excessive_retries
set in the ieee80211_tx_status struct. With this patch, the transmit rate
will decrease until communications restart.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
@@ -1311,6 +1311,16 @@ void bcm43xx_dma_handle_txstatus(struct 
 			 */
 			if (status->acked)
 				meta->txstat.flags |= IEEE80211_TX_STATUS_ACK;
+			else
+				if (dev->short_preamble) {
+					if (status->frame_count >=
+					    dev->short_retry_limit)
+						meta->txstat.excessive_retries = 1;
+				} else {
+					if (status->frame_count >=
+					    dev->long_retry_limit)
+						meta->txstat.excessive_retries = 1;
+				}
 			meta->txstat.retry_count = status->frame_count - 1;
 			ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb, &(meta->txstat));
 			/* skb is freed by ieee80211_tx_status_irqsafe() */
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
@@ -707,6 +707,8 @@ struct bcm43xx_wldev {
 	bool short_preamble;		/* TRUE, if short preamble is enabled. */
 	bool short_slot;		/* TRUE, if short slot timing is enabled. */
 	bool radio_hw_enable;		/* saved state of radio hardware enabled state */
+	u8 short_retry_limit;
+	u8 long_retry_limit;
 
 	/* PHY/Radio device. */
 	struct bcm43xx_phy phy;
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -3333,10 +3333,12 @@ static int bcm43xx_wireless_core_init(st
 	tmp = limit_value(modparam_short_retry, 0, 0xF);
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
 			    BCM43xx_SHM_SC_SRLIMIT, tmp);
+	dev->short_retry_limit = tmp;
 	tmp = limit_value(modparam_long_retry, 0, 0xF);
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
 			    BCM43xx_SHM_SC_LRLIMIT, tmp);
 
+	dev->long_retry_limit = tmp;
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
 			    BCM43xx_SHM_SH_SFFBLIM, 3);
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,


From larry.finger at lwfinger.net  Wed Aug  1 23:24:13 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 16:24:13 -0500
Subject: Report on BCM4318 under Fedora 7
In-Reply-To: <200708012224.13318.mb@bu3sch.de>
References: <313c6e90708010919g61824599m852b425dd9e5c300@mail.gmail.com>
	<200708012102.41240.mb@bu3sch.de> <46B0EA21.6070509@lwfinger.net>
	<200708012224.13318.mb@bu3sch.de>
Message-ID: <46B0F9FD.9090207@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 01 August 2007 22:16:33 Larry Finger wrote:
>>>
>> I know how you feel. Today, I dug out the frequency analyzer to see how the power looked. The 4311, 
>> which has the highest transfer numbers, has the lowest peak amplitude - about -70 dBm. The 4306 has 
>> amplitudes of -50 dBm, but the frequency spread is quite large and asymmetric. Although it is set 
>> for channel 1, there is a tail that extends to channel 7. The 4318 has even higher power - it 
>> saturates the detector as does the AP, which is at about the same distance as the laptops.
>>
>> If I bump up the power from 6.75 to 8.75 dBm, the maximum throughput of the 4311 reaches over 20 
>> Mbs, which is higher than Windows gets for the same setup.
> 
> But not with my tree!?

Sadly, no. With your tree, the 4311 generates a spectrum that looks like my 4306 - the amplitude 
saturates the detector, but there is a high-frequency spread that goes at least to channel 5. The 
iperf rates are as follows:

Rate set	Transfer rate (t/r)

1 Mbs		0.85/2.84
2 Mbs		1.64/3.02
5.5 Mbs		3.84/1.55

It failed with the lowest of the OFDM rates (6 Mbs). I didn't try any higher rates. These tests were 
done with the standard power.

Larry




From larry.finger at lwfinger.net  Wed Aug  1 23:31:33 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 16:31:33 -0500
Subject: txpower adjustment bouncing
In-Reply-To: <200708012232.58299.mb@bu3sch.de>
References: <200708012232.58299.mb@bu3sch.de>
Message-ID: <46B0FBB5.6000407@lwfinger.net>

Michael Buesch wrote:
> I analyzed the bouncing of the estimated TX power
> output versus the desired power.
> 
> Here's the hacky script to parse dmesg.
> It takes a number as arg. It's the PHY number.
> It requires printk times to be enabled in kconfig.
> 
> Looks pretty good. Though, it begins to bounce at the end.
> Not sure what happened there.

I hadn't done any plots, but I see the same kind of steady values followed by a seeking that lasts 
quite a while. At first, I thought the convergence needed damping, but that only made it worse. That 
4:1 ratio in the effects of the two parameters is hard to track. The fluctuations at the end may be 
due to changes in the temperature of the chip, causing variations in the output power for a given 
set of attenuations.

Larry


From mb at bu3sch.de  Thu Aug  2 00:14:14 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 2 Aug 2007 00:14:14 +0200
Subject: [RFC V2] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
In-Reply-To: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
Message-ID: <200708020014.15072.mb@bu3sch.de>

On Wednesday 01 August 2007 22:56:07 Larry Finger wrote:
> Michael,
> 
> I think I took care of your comments in the previous version.
> 
> Larry
> ---
> 
> In bcm43xx-mac80211, the mechanism for decreasing the transmit rate cannot
> be triggered. This may be shown by walking away from the AP with a laptop.
> At some distance, communications will be lost and never recovered because
> the rate decreasing mechanism of rc80211_simple needs to see excessive_retries
> set in the ieee80211_tx_status struct. With this patch, the transmit rate
> will decrease until communications restart.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> @@ -1311,6 +1311,16 @@ void bcm43xx_dma_handle_txstatus(struct 
>  			 */
>  			if (status->acked)
>  				meta->txstat.flags |= IEEE80211_TX_STATUS_ACK;
> +			else
> +				if (dev->short_preamble) {

Short preamble is something different.
The thing I was talking about is
mac_ctl |= BCM43xx_TX4_MAC_LONGFRAME;
which we do in xmit.c:338.
We currently do it for frames sent with CTS or RTS.

Though, I have no idea how we can easily track the information for each
packet if it was sent with LONGFRAME bit or without.
It needs to be a per-frame-attribute.
I think the txstatus doesn't tell us (but I'm not sure).

> +					if (status->frame_count >=
> +					    dev->short_retry_limit)
> +						meta->txstat.excessive_retries = 1;
> +				} else {
> +					if (status->frame_count >=
> +					    dev->long_retry_limit)
> +						meta->txstat.excessive_retries = 1;
> +				}
>  			meta->txstat.retry_count = status->frame_count - 1;
>  			ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb, &(meta->txstat));
>  			/* skb is freed by ieee80211_tx_status_irqsafe() */
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> @@ -707,6 +707,8 @@ struct bcm43xx_wldev {
>  	bool short_preamble;		/* TRUE, if short preamble is enabled. */
>  	bool short_slot;		/* TRUE, if short slot timing is enabled. */
>  	bool radio_hw_enable;		/* saved state of radio hardware enabled state */
> +	u8 short_retry_limit;
> +	u8 long_retry_limit;
>  
>  	/* PHY/Radio device. */
>  	struct bcm43xx_phy phy;
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -3333,10 +3333,12 @@ static int bcm43xx_wireless_core_init(st
>  	tmp = limit_value(modparam_short_retry, 0, 0xF);
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
>  			    BCM43xx_SHM_SC_SRLIMIT, tmp);
> +	dev->short_retry_limit = tmp;
>  	tmp = limit_value(modparam_long_retry, 0, 0xF);
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
>  			    BCM43xx_SHM_SC_LRLIMIT, tmp);
>  
> +	dev->long_retry_limit = tmp;
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
>  			    BCM43xx_SHM_SH_SFFBLIM, 3);
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
> 
> 



-- 
Greetings Michael.


From rmckibbe at bellsouth.net  Thu Aug  2 00:48:05 2007
From: rmckibbe at bellsouth.net (rob m)
Date: Wed, 01 Aug 2007 17:48:05 -0500
Subject: [RFC V2] bcm43xx-mac80211: Provide information to
	allow	transmission rate decreases
In-Reply-To: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
Message-ID: <46B10DA5.7090502@bellsouth.net>

#1, 2, 3, and 4:

THANK YOU!!!  for all you are doing to make this card work. 

I wish I could help somehow.  I've been lurking on this mailing list for 
a while now, and most of the emails are way beyond my talents.

I am, at this very moment, using a broadcom "4306" as reported by 
iwconfig, on Debian Etch, installed in early July 2007.  My question:

        What software do you use to determine the quality of the 
connection to the AP? 

gkrellm says that I have a -253 "level".  I know enough about radio 
transmission to know that -253 db is useless, but this interface is 
working fairly well as long as I'm relatively close (up one floor, over 
one room).  I can't connect at the opposite end of my home, <100', which 
is where I want to hang out.

Thanks,

Rob

Larry Finger wrote:
> Michael,
>
>
>   



From mistamaila at gmail.com  Thu Aug  2 02:19:33 2007
From: mistamaila at gmail.com (John H.)
Date: Thu, 2 Aug 2007 03:19:33 +0300
Subject: 4311 works with fedora 7 but only at 1mb/s
Message-ID: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>

Please tell me I can get more than 1mb/s.  Otherwise I will have to
use ndiswrapper:(

 lsmod |grep bcm
bcm43xx_mac80211      400289  0
ssb                    34757  1 bcm43xx_mac80211
mac80211              147017  2 rc80211_simple,bcm43xx_mac80211


 uname -a
Linux laptop 2.6.22.1-41.fc7 #1 SMP Fri Jul 27 18:10:34 EDT 2007 i686
i686 i386 GNU/Linux

iwconfig shows
wlan0     IEEE 802.11g  ESSID:"notnetwurk"
          Mode:Managed  Frequency:2.437 GHz  Access Point: ??
Bit Rate=1 Mb/s


From larry.finger at lwfinger.net  Thu Aug  2 04:33:24 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 21:33:24 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
Message-ID: <46B14274.70108@lwfinger.net>

John H. wrote:
> Please tell me I can get more than 1mb/s.  Otherwise I will have to
> use ndiswrapper:(
> 
>  lsmod |grep bcm
> bcm43xx_mac80211      400289  0
> ssb                    34757  1 bcm43xx_mac80211
> mac80211              147017  2 rc80211_simple,bcm43xx_mac80211
> 
> 
>  uname -a
> Linux laptop 2.6.22.1-41.fc7 #1 SMP Fri Jul 27 18:10:34 EDT 2007 i686
> i686 i386 GNU/Linux
> 
> iwconfig shows
> wlan0     IEEE 802.11g  ESSID:"notnetwurk"
>           Mode:Managed  Frequency:2.437 GHz  Access Point: ??
> Bit Rate=1 Mb/s
>

On the Fedora Web site is information on how to use the older bcm43xx, not the bcm43xx-mac80211, 
driver with V3 firmware. That driver is capable of much greater throughput. Your alternative is to 
build your own kernel from source.

Larry



From larry.finger at lwfinger.net  Thu Aug  2 04:49:44 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 01 Aug 2007 21:49:44 -0500
Subject: [RFC V2] bcm43xx-mac80211: Provide information to
	allow	transmission rate decreases
In-Reply-To: <46B10DA5.7090502@bellsouth.net>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
	<46B10DA5.7090502@bellsouth.net>
Message-ID: <46B14648.9090301@lwfinger.net>

rob m wrote:
> #1, 2, 3, and 4:
> 
> THANK YOU!!!  for all you are doing to make this card work.
> I wish I could help somehow.  I've been lurking on this mailing list for 
> a while now, and most of the emails are way beyond my talents.
> 
> I am, at this very moment, using a broadcom "4306" as reported by 
> iwconfig, on Debian Etch, installed in early July 2007.  My question:
> 
>        What software do you use to determine the quality of the 
> connection to the AP?
> gkrellm says that I have a -253 "level".  I know enough about radio 
> transmission to know that -253 db is useless, but this interface is 
> working fairly well as long as I'm relatively close (up one floor, over 
> one room).  I can't connect at the opposite end of my home, <100', which 
> is where I want to hang out.

All of the 'quality' numbers from any program are rather useless. The only thing that matters is how 
much data one can stuff over the airwaves per unit time.

If you have another machine on your LAN, you can use the Iperf package. It comes as client and 
server for almost any machine. My server runs Linux, which makes it easy, but there is a server for 
Windows and OS X. This program transmits a random string of bits across the connection and reports 
the results. On my server at ftp://lwfinger.dynalias.org/patches are a couple of Perl scripts that 
test the link at different speeds. One uses an Iperf server, the other copies a file to a server and 
copies it back to get the transfer speed.

If you don't have another machine on your LAN, you are limited to the browser speed tests, whic in 
my case measure the speed of my broadband line - my link is much faster than the line.

On most of the BCM43xx cards that I have seen, the noise level is anywhere from -70 to -90 dBm, 
depending how close you are to the AP, and the general 2.4 GHz noise level of the room. The signal 
level varies from -30 to -60 dBm.

I hope this is clear. If not, please ask questions about the part that isn't.

Larry



From mistamaila at gmail.com  Thu Aug  2 10:28:21 2007
From: mistamaila at gmail.com (John H.)
Date: Thu, 2 Aug 2007 11:28:21 +0300
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46B14274.70108@lwfinger.net>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B14274.70108@lwfinger.net>
Message-ID: <5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>

I cannot find the site of which you speak.

I can't seem to get it to let me use only bcm43xx and not bcm43xx-mac80211.

Also, which firmware here is v3?

http://downloads.openwrt.org/sources/

On 8/2/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > Please tell me I can get more than 1mb/s.  Otherwise I will have to
> > use ndiswrapper:(
> >
> >  lsmod |grep bcm
> > bcm43xx_mac80211      400289  0
> > ssb                    34757  1 bcm43xx_mac80211
> > mac80211              147017  2 rc80211_simple,bcm43xx_mac80211
> >
> >
> >  uname -a
> > Linux laptop 2.6.22.1-41.fc7 #1 SMP Fri Jul 27 18:10:34 EDT 2007 i686
> > i686 i386 GNU/Linux
> >
> > iwconfig shows
> > wlan0     IEEE 802.11g  ESSID:"notnetwurk"
> >           Mode:Managed  Frequency:2.437 GHz  Access Point: ??
> > Bit Rate=1 Mb/s
> >
>
> On the Fedora Web site is information on how to use the older bcm43xx, not the bcm43xx-mac80211,
> driver with V3 firmware. That driver is capable of much greater throughput. Your alternative is to
> build your own kernel from source.
>
> Larry
>
>


From johannes at sipsolutions.net  Thu Aug  2 11:09:47 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 02 Aug 2007 11:09:47 +0200
Subject: [RFC V2] bcm43xx-mac80211: Provide information to allow 
	transmission rate decreases
In-Reply-To: <200708020014.15072.mb@bu3sch.de>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
	<200708020014.15072.mb@bu3sch.de>
Message-ID: <1186045787.24230.7.camel@johannes.berg>

On Thu, 2007-08-02 at 00:14 +0200, Michael Buesch wrote:

> Though, I have no idea how we can easily track the information for each
> packet if it was sent with LONGFRAME bit or without.
> It needs to be a per-frame-attribute.
> I think the txstatus doesn't tell us (but I'm not sure).

Why do you need to know when you get a tx status? Oh I see. Hm. Well,
mac80211 tells you how much to retry now (Daniel made a patch); you can
select long/short based on that and on tx status simply compare with
that number from the tx control struct.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070802/753da3c7/attachment.pgp>

From mb at bu3sch.de  Thu Aug  2 13:11:24 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 2 Aug 2007 13:11:24 +0200
Subject: [RFC V2] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
In-Reply-To: <1186045787.24230.7.camel@johannes.berg>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
	<200708020014.15072.mb@bu3sch.de>
	<1186045787.24230.7.camel@johannes.berg>
Message-ID: <200708021311.25033.mb@bu3sch.de>

On Thursday 02 August 2007 11:09:47 Johannes Berg wrote:
> On Thu, 2007-08-02 at 00:14 +0200, Michael Buesch wrote:
> 
> > Though, I have no idea how we can easily track the information for each
> > packet if it was sent with LONGFRAME bit or without.
> > It needs to be a per-frame-attribute.
> > I think the txstatus doesn't tell us (but I'm not sure).
> 
> Why do you need to know when you get a tx status? Oh I see. Hm. Well,
> mac80211 tells you how much to retry now (Daniel made a patch); you can
> select long/short based on that and on tx status simply compare with
> that number from the tx control struct.

We don't get a "I failed to transmit this" bit from the firmware,
so we must work around this my comparing the retries count to
the maximum possible retry count.
Of course, that's not an ideal solution. Especially because I think
When it succeed on the exact last retry, we take it as failure.
Though, that's very unlikely it fails 7 times give or take and then
suddenly succeeds.

-- 
Greetings Michael.


From johannes at sipsolutions.net  Thu Aug  2 13:18:17 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 02 Aug 2007 13:18:17 +0200
Subject: [RFC V2] bcm43xx-mac80211: Provide information to allow 
	transmission rate decreases
In-Reply-To: <200708021311.25033.mb@bu3sch.de>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
	<200708020014.15072.mb@bu3sch.de>
	<1186045787.24230.7.camel@johannes.berg>
	<200708021311.25033.mb@bu3sch.de>
Message-ID: <1186053497.24230.27.camel@johannes.berg>

On Thu, 2007-08-02 at 13:11 +0200, Michael Buesch wrote:

> We don't get a "I failed to transmit this" bit from the firmware,

Well, if you expect the frame to be acked then you do get a bit 'this
frame was ever acked'

> so we must work around this my comparing the retries count to
> the maximum possible retry count.
> Of course, that's not an ideal solution. Especially because I think
> When it succeed on the exact last retry, we take it as failure.
> Though, that's very unlikely it fails 7 times give or take and then
> suddenly succeeds.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070802/51b0f8e8/attachment.pgp>

From mb at bu3sch.de  Thu Aug  2 13:37:21 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 2 Aug 2007 13:37:21 +0200
Subject: [RFC V2] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
In-Reply-To: <1186053497.24230.27.camel@johannes.berg>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
	<200708021311.25033.mb@bu3sch.de>
	<1186053497.24230.27.camel@johannes.berg>
Message-ID: <200708021337.21285.mb@bu3sch.de>

On Thursday 02 August 2007 13:18:17 Johannes Berg wrote:
> On Thu, 2007-08-02 at 13:11 +0200, Michael Buesch wrote:
> 
> > We don't get a "I failed to transmit this" bit from the firmware,
> 
> Well, if you expect the frame to be acked then you do get a bit 'this
> frame was ever acked'

Yep, the problem is for frames that don't get acked.
If we just check the ack bit, rate control would throttle, just because
we sent unacked frames.
So if we didn't get an ack, we need to check if we failed, or if...
Oh, acutally. Why not simply check the noack bit in the tx_control... :)

-- 
Greetings Michael.


From johannes at sipsolutions.net  Thu Aug  2 13:48:39 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 02 Aug 2007 13:48:39 +0200
Subject: [RFC V2] bcm43xx-mac80211: Provide information to allow 
	transmission rate decreases
In-Reply-To: <200708021337.21285.mb@bu3sch.de>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
	<200708021311.25033.mb@bu3sch.de>
	<1186053497.24230.27.camel@johannes.berg>
	<200708021337.21285.mb@bu3sch.de>
Message-ID: <1186055319.24230.32.camel@johannes.berg>

On Thu, 2007-08-02 at 13:37 +0200, Michael Buesch wrote:

> If we just check the ack bit, rate control would throttle, just because
> we sent unacked frames.

Ah but rate control shouldn't actually care about frames that we never
expected an ACK for since there's no way to know for those anyway. So
IMHO the rate control algorithm shouldn't even be called for those
frames.

> So if we didn't get an ack, we need to check if we failed, or if...
> Oh, acutally. Why not simply check the noack bit in the tx_control... :)

Works too, but it seems mac80211 should do that.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070802/eb15602d/attachment.pgp>

From mb at bu3sch.de  Thu Aug  2 15:03:53 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 2 Aug 2007 15:03:53 +0200
Subject: [RFC V2] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
In-Reply-To: <1186055319.24230.32.camel@johannes.berg>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
	<200708021337.21285.mb@bu3sch.de>
	<1186055319.24230.32.camel@johannes.berg>
Message-ID: <200708021503.53982.mb@bu3sch.de>

On Thursday 02 August 2007 13:48:39 Johannes Berg wrote:
> On Thu, 2007-08-02 at 13:37 +0200, Michael Buesch wrote:
> 
> > If we just check the ack bit, rate control would throttle, just because
> > we sent unacked frames.
> 
> Ah but rate control shouldn't actually care about frames that we never
> expected an ACK for since there's no way to know for those anyway. So
> IMHO the rate control algorithm shouldn't even be called for those
> frames.
> 
> > So if we didn't get an ack, we need to check if we failed, or if...
> > Oh, acutally. Why not simply check the noack bit in the tx_control... :)
> 
> Works too, but it seems mac80211 should do that.

So, what's the point of this "excessive retries" field anyway?
We already have an "acked" bit. So if it's not set, but we expected an
ack, what's the point of setting excessive retries in the driver?
the rc algo sould know _anyway_, as it has the "acked" and the
"we wanted to have an ack" bits.

confused..

-- 
Greetings Michael.


From johannes at sipsolutions.net  Thu Aug  2 15:07:14 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 02 Aug 2007 15:07:14 +0200
Subject: [RFC V2] bcm43xx-mac80211: Provide information to allow 
	transmission rate decreases
In-Reply-To: <200708021503.53982.mb@bu3sch.de>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
	<200708021337.21285.mb@bu3sch.de>
	<1186055319.24230.32.camel@johannes.berg>
	<200708021503.53982.mb@bu3sch.de>
Message-ID: <1186060034.24230.48.camel@johannes.berg>

On Thu, 2007-08-02 at 15:03 +0200, Michael Buesch wrote:

> So, what's the point of this "excessive retries" field anyway?
> We already have an "acked" bit. So if it's not set, but we expected an
> ack, what's the point of setting excessive retries in the driver?
> the rc algo sould know _anyway_, as it has the "acked" and the
> "we wanted to have an ack" bits.

No idea. I guess you get to dig through the code and remove it ;)

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070802/02200e8d/attachment.pgp>

From mb at bu3sch.de  Thu Aug  2 16:24:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 2 Aug 2007 16:24:58 +0200
Subject: [PATCH] Merge the Sonics Silicon Backplane subsystem
In-Reply-To: <Pine.LNX.4.64.0708021557280.5150@anakin>
References: <200707271857.24162.mb@bu3sch.de>
	<Pine.LNX.4.64.0708021557280.5150@anakin>
Message-ID: <200708021624.59701.mb@bu3sch.de>

On Thursday 02 August 2007, Geert Uytterhoeven wrote:
> On Fri, 27 Jul 2007, Michael Buesch wrote:
> > The Sonics Silicon Backplane is a mini-bus used on
> > various Broadcom chips and embedded devices.
> > Devices using the SSB include b44, bcm43xx and various
> > Broadcom based wireless routers.
> > A b44 and bcm43xx port and a SSB based OHCI driver is available.
> 
> > --- a/drivers/Kconfig
> > +++ b/drivers/Kconfig
> > @@ -58,6 +58,8 @@ source "drivers/power/Kconfig"
> >  
> >  source "drivers/hwmon/Kconfig"
> >  
> > +source "drivers/ssb/Kconfig"
> > +
> >  source "drivers/mfd/Kconfig"
> >  
> >  source "drivers/media/Kconfig"
> 
> > --- /dev/null
> > +++ b/drivers/ssb/Kconfig
> > @@ -0,0 +1,92 @@
> > +menu "Sonics Silicon Backplane"
> > +
> > +config SSB
> > +	tristate "Sonics Silicon Backplane support"
> > +	depends on EXPERIMENTAL
> 
> Hence this will show up on all platforms?

So?


From larry.finger at lwfinger.net  Thu Aug  2 17:02:25 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:02:25 -0500
Subject: [RFC V2] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
In-Reply-To: <1186060034.24230.48.camel@johannes.berg>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>	
	<200708021337.21285.mb@bu3sch.de>
	<1186055319.24230.32.camel@johannes.berg>	
	<200708021503.53982.mb@bu3sch.de>
	<1186060034.24230.48.camel@johannes.berg>
Message-ID: <46B1F201.7060107@lwfinger.net>

Johannes Berg wrote:
> On Thu, 2007-08-02 at 15:03 +0200, Michael Buesch wrote:
> 
>> So, what's the point of this "excessive retries" field anyway?
>> We already have an "acked" bit. So if it's not set, but we expected an
>> ack, what's the point of setting excessive retries in the driver?
>> the rc algo sould know _anyway_, as it has the "acked" and the
>> "we wanted to have an ack" bits.
> 
> No idea. I guess you get to dig through the code and remove it ;)

When I first started investigating the problem of mac80211 not reducing the rate as I moved away 
from the AP, it seemed to me that the decision regarding excessive retries should be made in 
mac80211, not in the driver; however, I have had extreme difficulty in getting any changes into 
mac80211 on several occasions. Linville assures me that he has had private discussions about this 
problem; however, I needed a quick fix and couldn't stand any protracted discussion and/or review 
delays. I knew Michael would be tough, but that his comments would not be delayed.

At the moment, I have more pressing matters to resolve than fixing this problem in mac80211; 
however, I feel really good that the port of bcm43xx-softmac to mac80211 has this issue.

Larry



From larry.finger at lwfinger.net  Thu Aug  2 17:28:14 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:28:14 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>	<46B14274.70108@lwfinger.net>
	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>
Message-ID: <46B1F80E.2090301@lwfinger.net>

John H. wrote:
> I cannot find the site of which you speak.
> 
> I can't seem to get it to let me use only bcm43xx and not bcm43xx-mac80211.
> 
> Also, which firmware here is v3?

If you run this script by John Linville, your system will use bcm43xx. It will also download and 
install the V3 firmware.

Larry


=================================================
#!/bin/sh

BCM43XX_V3_FW="http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o"

wget $BCM43XX_V3_FW

bcm43xx-fwcutter -w /lib/firmware -p .v3 wl_apsta-3.130.20.0.o
echo 'blacklist bcm43xx-mac80211' >> /etc/modprobe.d/blacklist
echo 'options bcm43xx fwpostfix=.v3' >> /etc/modprobe.conf

modprobe -r bcm43xx-mac80211 # remove the new driver

echo 'modprobe bcm43xx' >> /etc/rc.local

BCM43XX_PCI_ID=`lspci -n | awk '$2 ~ "^0280" && $3 ~ "^14e4:43" { print $3 }' | sed -e 's/:/ /'`
echo 'echo "'$BCM43XX_PCI_ID'" > /sys/bus/pci/drivers/bcm43xx/new_id' \
         >> /etc/rc.local

/etc/rc.local

==============================




From Larry.Finger at lwfinger.net  Thu Aug  2 17:38:21 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:38:21 -0500
Subject: [RFC V3] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
Message-ID: <46b1fa6d.d4l4DujAaAR2ORZf%Larry.Finger@lwfinger.net>

Michael,

I couldn't find any long/short indication in the header, so I added a bool that
is set when the frame is sent.

Larry
---

In bcm43xx-mac80211, the mechanism for decreasing the transmit rate cannot
be triggered. This may be shown by walking away from the AP with a laptop.
At some distance, communications will be lost and never recovered because
the rate decreasing mechanism of rc80211_simple needs to see excessive_retries
set in the ieee80211_tx_status struct. With this patch, the transmit rate
will decrease until communications restart.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
@@ -1311,6 +1311,16 @@ void bcm43xx_dma_handle_txstatus(struct 
 			 */
 			if (status->acked)
 				meta->txstat.flags |= IEEE80211_TX_STATUS_ACK;
+			else
+				if (dev->last_frame_long) {
+					if (status->frame_count >=
+					    dev->long_retry_limit)
+						meta->txstat.excessive_retries = 1;
+				} else {
+					if (status->frame_count >=
+					    dev->short_retry_limit)
+						meta->txstat.excessive_retries = 1;
+				}
 			meta->txstat.retry_count = status->frame_count - 1;
 			ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb, &(meta->txstat));
 			/* skb is freed by ieee80211_tx_status_irqsafe() */
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
@@ -707,6 +707,9 @@ struct bcm43xx_wldev {
 	bool short_preamble;		/* TRUE, if short preamble is enabled. */
 	bool short_slot;		/* TRUE, if short slot timing is enabled. */
 	bool radio_hw_enable;		/* saved state of radio hardware enabled state */
+	bool last_frame_long;		/* true is last frame was long */
+	u8 short_retry_limit;
+	u8 long_retry_limit;
 
 	/* PHY/Radio device. */
 	struct bcm43xx_phy phy;
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -3333,10 +3333,12 @@ static int bcm43xx_wireless_core_init(st
 	tmp = limit_value(modparam_short_retry, 0, 0xF);
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
 			    BCM43xx_SHM_SC_SRLIMIT, tmp);
+	dev->short_retry_limit = tmp;
 	tmp = limit_value(modparam_long_retry, 0, 0xF);
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
 			    BCM43xx_SHM_SC_LRLIMIT, tmp);
 
+	dev->long_retry_limit = tmp;
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
 			    BCM43xx_SHM_SH_SFFBLIM, 3);
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
@@ -264,6 +264,7 @@ static void generate_txhdr_fw4(struct bc
 	 * is a 5Ghz packet.
 	 */
 	txhdr->chan_radio_code = phy->channel;
+	dev->last_frame_long = 0;
 
 	/* PHY TX Control word */
 	if (rate_ofdm)
@@ -336,6 +337,7 @@ static void generate_txhdr_fw4(struct bc
 		if (rts_rate_fb_ofdm)
 			extra_ft |= BCM43xx_TX4_EFT_RTSFBOFDM;
 		mac_ctl |= BCM43xx_TX4_MAC_LONGFRAME;
+		dev->last_frame_long = 1;
 	}
 
 	/* Magic cookie */


From mb at bu3sch.de  Thu Aug  2 17:48:07 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 02 Aug 2007 17:48:07 +0200
Subject: [patch 1/4] bcm43xx-mac80211: Save attenuation values for later use.
References: <20070802154806.853306000@bu3sch.de>>
Message-ID: <20070802154807.385080000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-save-attenuation-values-for-later-use.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070802/52baaccc/attachment.ksh>

From mb at bu3sch.de  Thu Aug  2 17:48:10 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 02 Aug 2007 17:48:10 +0200
Subject: [patch 4/4] ssb-chipcommon: Align case statement with switch statement
References: <20070802154806.853306000@bu3sch.de>>
Message-ID: <20070802154808.763174000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: ssb-chipcommon-add-function-to-get-processor-clock-fix.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070802/504e3485/attachment.ksh>

From mb at bu3sch.de  Thu Aug  2 17:48:06 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 02 Aug 2007 17:48:06 +0200
Subject: [patch 0/4] New patch series for merge
Message-ID: <20070802154806.853306000@bu3sch.de>>

Hi John,

This patch series catches wireless-dev up to my
current wireless-development patchset.

Please merge this into wireless-dev.

This is the first time I use my new patch managing scripts.
So if there are any problems, please complain (patch format, etc...)
In future I will drop my git tree and continue development through patch series
That's hopefully easier to manage and you can rebase your tree whenever
you want (well, you'd do that anyway :P)


--



From mb at bu3sch.de  Thu Aug  2 17:48:09 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 02 Aug 2007 17:48:09 +0200
Subject: [patch 3/4] ssb-chipcommon: Add function to get processor clock
References: <20070802154806.853306000@bu3sch.de>>
Message-ID: <20070802154808.293149000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: ssb-chipcommon-add-function-to-get-processor-clock.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070802/ec4549dc/attachment.ksh>

From mb at bu3sch.de  Thu Aug  2 17:48:08 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 02 Aug 2007 17:48:08 +0200
Subject: [patch 2/4] ssb/main.c needs dma-mapping.h
References: <20070802154806.853306000@bu3sch.de>>
Message-ID: <20070802154807.881392000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: ssb-main.c-needs-dma-mapping.h.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070802/c84295c5/attachment.ksh>

From Larry.Finger at lwfinger.net  Thu Aug  2 17:53:04 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:53:04 -0500
Subject: [RFC 0/10] Port of bcm43xx from softmac to mac80211
Message-ID: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>

Driver bcm43xx is being ported from using SoftMAC to mac80211. For rewiew,
this series of patches is being prepared; however, the final patch will be
a single entity so that compilation during bisection will not break.

The contents of the various pieces are as follows:

 1. Kconfig, Makefile and the main header file.
 2. bcm43xx_debugfs.c and bcm43xx_debugfs.h
 3. bcm43xx_dma.c and bcm43xx_dma.h
 4. bcm43xx_ilt.c, bcm43xx_ilt.h, bcm43xx_leds.c and bcm43xx_leds.h
 5. bcm43xx_main.c and bcm43xx_main.h
 6. bcm43xx_phy.c and bcm43xx_phy.h
 7. bcm43xx_pio.c and bcm43xx_pio.h
 8. bcm43xx_radio.c and bcm43xx_radio.h
 9. bcm43xx_sysfs.c and bcm43xx_sysfs.h
10: bcm43xx_xmit.c and bcm43xx_xmit.h

In general, this port consists of taking the files bcm43xx_phy and 
bcm43xx_radio from the softmac driver and converting them to work with
the files from the mac80211 version, which has been back-converted to 
use V3 firmware.

Larry



From Larry.Finger at lwfinger.net  Thu Aug  2 17:53:11 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:53:11 -0500
Subject: [RFC 1/10] Port of bcm43xx from softmac to mac80211
Message-ID: <46b1fde7.JR5zA75dJy7VnTEq%Larry.Finger@lwfinger.net>

This if file 1 of 10 of the port of the bcm43xx driver from softmac
to mac80211.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/Kconfig
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/Kconfig
+++ linux-2.6/drivers/net/wireless/bcm43xx/Kconfig
@@ -1,16 +1,18 @@
 config BCM43XX
-	tristate "Broadcom BCM43xx wireless support"
-	depends on PCI && IEEE80211 && IEEE80211_SOFTMAC && WLAN_80211 && EXPERIMENTAL
-	select WIRELESS_EXT
+	tristate "Broadcom BCM43xx wireless support (mac80211 stack)"
+	depends on MAC80211 && WLAN_80211 && EXPERIMENTAL && HAS_IOMEM
 	select FW_LOADER
+	select SSB
 	select HW_RANDOM
 	---help---
-	  This is an experimental driver for the Broadcom 43xx wireless chip,
+	  This is a port of the original driver for the Broadcom 43xx wireless
+	  chip from SoftMAC to the better mac80211 MAC layer. This device is
 	  found in the Apple Airport Extreme and various other devices.
 
 config BCM43XX_DEBUG
 	bool "Broadcom BCM43xx debugging (RECOMMENDED)"
 	depends on BCM43XX
+	select SSB_DEBUG if !SSB_SILENT
 	default y
 	---help---
 	  Broadcom 43xx debugging messages.
Index: linux-2.6/drivers/net/wireless/bcm43xx/Makefile
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/Makefile
+++ linux-2.6/drivers/net/wireless/bcm43xx/Makefile
@@ -4,9 +4,11 @@ bcm43xx-obj-$(CONFIG_BCM43XX_DEBUG) += b
 bcm43xx-obj-$(CONFIG_BCM43XX_DMA) += bcm43xx_dma.o
 bcm43xx-obj-$(CONFIG_BCM43XX_PIO) += bcm43xx_pio.o
 
-bcm43xx-objs := bcm43xx_main.o bcm43xx_ilt.o \
-		bcm43xx_radio.o bcm43xx_phy.o \
-		bcm43xx_power.o bcm43xx_wx.o \
-		bcm43xx_leds.o bcm43xx_ethtool.o \
-		bcm43xx_xmit.o bcm43xx_sysfs.o \
-		$(bcm43xx-obj-y)
+bcm43xx-objs := 	bcm43xx_main.o \
+			bcm43xx_ilt.o \
+			bcm43xx_leds.o \
+		        bcm43xx_phy.o \
+			bcm43xx_radio.o \
+	        	bcm43xx_sysfs.o \
+			bcm43xx_xmit.o \
+			$(bcm43xx-obj-y)
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
@@ -2,35 +2,29 @@
 #define BCM43xx_H_
 
 #include <linux/hw_random.h>
-#include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/stringify.h>
+#include <linux/netdevice.h>
 #include <linux/pci.h>
-#include <net/ieee80211.h>
-#include <net/ieee80211softmac.h>
 #include <asm/atomic.h>
 #include <asm/io.h>
 
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_driver_chipcommon.h>
+
+#include <linux/wireless.h>
+#include <net/mac80211.h>
 
 #include "bcm43xx_debugfs.h"
 #include "bcm43xx_leds.h"
+#include "bcm43xx_phy.h"
 
 
-#define PFX				KBUILD_MODNAME ": "
-
-#define BCM43xx_SWITCH_CORE_MAX_RETRIES	50
 #define BCM43xx_IRQWAIT_MAX_RETRIES	100
 
-#define BCM43xx_IO_SIZE			8192
-
-/* Active Core PCI Configuration Register. */
-#define BCM43xx_PCICFG_ACTIVE_CORE	0x80
-/* SPROM control register. */
-#define BCM43xx_PCICFG_SPROMCTL		0x88
-/* Interrupt Control PCI Configuration Register. (Only on PCI cores with rev >= 6) */
-#define BCM43xx_PCICFG_ICR		0x94
+#define BCM43xx_RX_MAX_SSI		60
 
 /* MMIO offsets */
 #define BCM43xx_MMIO_DMA0_REASON	0x20
@@ -45,6 +39,7 @@
 #define BCM43xx_MMIO_DMA4_IRQ_MASK	0x44
 #define BCM43xx_MMIO_DMA5_REASON	0x48
 #define BCM43xx_MMIO_DMA5_IRQ_MASK	0x4C
+#define BCM43xx_MMIO_MACCTL		0x120
 #define BCM43xx_MMIO_STATUS_BITFIELD	0x120
 #define BCM43xx_MMIO_STATUS2_BITFIELD	0x124
 #define BCM43xx_MMIO_GEN_IRQ_REASON	0x128
@@ -83,6 +78,7 @@
 
 #define BCM43xx_MMIO_PHY_VER		0x3E0
 #define BCM43xx_MMIO_PHY_RADIO		0x3E2
+#define BCM43xx_MMIO_PHY0		0x3E6
 #define BCM43xx_MMIO_ANTENNA		0x3E8
 #define BCM43xx_MMIO_CHANNEL		0x3F0
 #define BCM43xx_MMIO_CHANNEL_EXT	0x3F4
@@ -93,6 +89,7 @@
 #define BCM43xx_MMIO_PHY_DATA		0x3FE
 #define BCM43xx_MMIO_MACFILTER_CONTROL	0x420
 #define BCM43xx_MMIO_MACFILTER_DATA	0x422
+#define BCM43xx_MMIO_RCMTA_COUNT	0x43C
 #define BCM43xx_MMIO_RADIO_HWENABLED_LO	0x49A
 #define BCM43xx_MMIO_GPIO_CONTROL	0x49C
 #define BCM43xx_MMIO_GPIO_MASK		0x49E
@@ -103,214 +100,72 @@
 #define BCM43xx_MMIO_RNG		0x65A
 #define BCM43xx_MMIO_POWERUP_DELAY	0x6A8
 
-/* SPROM offsets. */
-#define BCM43xx_SPROM_BASE		0x1000
-#define BCM43xx_SPROM_BOARDFLAGS2	0x1c
-#define BCM43xx_SPROM_IL0MACADDR	0x24
-#define BCM43xx_SPROM_ET0MACADDR	0x27
-#define BCM43xx_SPROM_ET1MACADDR	0x2a
-#define BCM43xx_SPROM_ETHPHY		0x2d
-#define BCM43xx_SPROM_BOARDREV		0x2e
-#define BCM43xx_SPROM_PA0B0		0x2f
-#define BCM43xx_SPROM_PA0B1		0x30
-#define BCM43xx_SPROM_PA0B2		0x31
-#define BCM43xx_SPROM_WL0GPIO0		0x32
-#define BCM43xx_SPROM_WL0GPIO2		0x33
-#define BCM43xx_SPROM_MAXPWR		0x34
-#define BCM43xx_SPROM_PA1B0		0x35
-#define BCM43xx_SPROM_PA1B1		0x36
-#define BCM43xx_SPROM_PA1B2		0x37
-#define BCM43xx_SPROM_IDL_TSSI_TGT	0x38
-#define BCM43xx_SPROM_BOARDFLAGS	0x39
-#define BCM43xx_SPROM_ANTENNA_GAIN	0x3a
-#define BCM43xx_SPROM_VERSION		0x3f
-
-/* BCM43xx_SPROM_BOARDFLAGS values */
-#define BCM43xx_BFL_BTCOEXIST		0x0001 /* implements Bluetooth coexistance */
-#define BCM43xx_BFL_PACTRL		0x0002 /* GPIO 9 controlling the PA */
-#define BCM43xx_BFL_AIRLINEMODE		0x0004 /* implements GPIO 13 radio disable indication */
-#define BCM43xx_BFL_RSSI		0x0008 /* software calculates nrssi slope. */
-#define BCM43xx_BFL_ENETSPI		0x0010 /* has ephy roboswitch spi */
-#define BCM43xx_BFL_XTAL_NOSLOW		0x0020 /* no slow clock available */
-#define BCM43xx_BFL_CCKHIPWR		0x0040 /* can do high power CCK transmission */
-#define BCM43xx_BFL_ENETADM		0x0080 /* has ADMtek switch */
-#define BCM43xx_BFL_ENETVLAN		0x0100 /* can do vlan */
-#define BCM43xx_BFL_AFTERBURNER		0x0200 /* supports Afterburner mode */
-#define BCM43xx_BFL_NOPCI		0x0400 /* leaves PCI floating */
-#define BCM43xx_BFL_FEM			0x0800 /* supports the Front End Module */
-#define BCM43xx_BFL_EXTLNA		0x1000 /* has an external LNA */
-#define BCM43xx_BFL_HGPA		0x2000 /* had high gain PA */
-#define BCM43xx_BFL_BTCMOD		0x4000 /* BFL_BTCOEXIST is given in alternate GPIOs */
-#define BCM43xx_BFL_ALTIQ		0x8000 /* alternate I/Q settings */
+/* SPROM boardflags_lo values */
+#define BCM43xx_BFL_PACTRL		0x0002
+#define BCM43xx_BFL_RSSI		0x0008
+#define BCM43xx_BFL_EXTLNA		0x1000
 
 /* GPIO register offset, in both ChipCommon and PCI core. */
 #define BCM43xx_GPIO_CONTROL		0x6c
 
 /* SHM Routing */
-#define BCM43xx_SHM_SHARED		0x0001
-#define BCM43xx_SHM_WIRELESS		0x0002
-#define BCM43xx_SHM_PCM			0x0003
-#define BCM43xx_SHM_HWMAC		0x0004
-#define BCM43xx_SHM_UCODE		0x0300
-
-/* MacFilter offsets. */
-#define BCM43xx_MACFILTER_SELF		0x0000
-#define BCM43xx_MACFILTER_ASSOC		0x0003
+#define	BCM43xx_SHM_SHARED		0x0001
+#define	BCM43xx_SHM_WIRELESS		0x0002
+#define	BCM43xx_SHM_HW			0x0004
+#define	BCM43xx_SHM_UCODE		0x0300
+
+/* SHM Routing modifiers */
+#define BCM43xx_SHM_AUTOINC_R		0x0200 /* Read Auto-increment */
+#define BCM43xx_SHM_AUTOINC_W		0x0100 /* Write Auto-increment */
+#define BCM43xx_SHM_AUTOINC_RW		(BCM43xx_SHM_AUTOINC_R | \
+					 BCM43xx_SHM_AUTOINC_W)
+
+/* Misc SHM_SHARED offsets */
+#define BCM43xx_SHM_SH_WLCOREREV	0x0016 /* 802.11 core revision */
+#define BCM43xx_SHM_SH_HOSTFLO		0x005E /* Hostflags ucode opts (low) */
+#define BCM43xx_SHM_SH_HOSTFHI		0x0060 /* Hostflags ucode opts (high) */
+/* SHM_SHARED crypto engine */
+#define BCM43xx_SHM_SH_KEYIDXBLOCK	0x05D4 /* Key index/algorithm block */
+/* SHM_SHARED beacon variables */
+#define BCM43xx_SHM_SH_BEACPHYCTL	0x0054 /* Beacon PHY TX control word */
+/* SHM_SHARED ACK/CTS control */
+#define BCM43xx_SHM_SH_ACKCTSPHYCTL	0x0022 /* ACK/CTS PHY control word */
+/* SHM_SHARED probe response variables */
+#define BCM43xx_SHM_SH_PRPHYCTL		0x0188 /* Probe Resp PHY TX control */
+/* SHM_SHARED rate tables */
+/* SHM_SHARED microcode soft registers */
+#define BCM43xx_SHM_SH_UCODEREV		0x0000 /* Microcode revision */
+#define BCM43xx_SHM_SH_UCODEPATCH	0x0002 /* Microcode patchlevel */
+#define BCM43xx_SHM_SH_UCODEDATE	0x0004 /* Microcode date */
+#define BCM43xx_SHM_SH_UCODETIME	0x0006 /* Microcode time */
 
-/* Chipcommon registers. */
-#define BCM43xx_CHIPCOMMON_CAPABILITIES 	0x04
-#define BCM43xx_CHIPCOMMON_CTL			0x28
-#define BCM43xx_CHIPCOMMON_PLLONDELAY		0xB0
-#define BCM43xx_CHIPCOMMON_FREFSELDELAY		0xB4
-#define BCM43xx_CHIPCOMMON_SLOWCLKCTL		0xB8
-#define BCM43xx_CHIPCOMMON_SYSCLKCTL		0xC0
-
-/* PCI core specific registers. */
-#define BCM43xx_PCICORE_BCAST_ADDR	0x50
-#define BCM43xx_PCICORE_BCAST_DATA	0x54
-#define BCM43xx_PCICORE_SBTOPCI2	0x108
-
-/* SBTOPCI2 values. */
-#define BCM43xx_SBTOPCI2_PREFETCH	0x4
-#define BCM43xx_SBTOPCI2_BURST		0x8
-#define BCM43xx_SBTOPCI2_MEMREAD_MULTI	0x20
-
-/* PCI-E core registers. */
-#define BCM43xx_PCIECORE_REG_ADDR      0x0130
-#define BCM43xx_PCIECORE_REG_DATA      0x0134
-#define BCM43xx_PCIECORE_MDIO_CTL      0x0128
-#define BCM43xx_PCIECORE_MDIO_DATA     0x012C
-
-/* PCI-E registers. */
-#define BCM43xx_PCIE_TLP_WORKAROUND    0x0004
-#define BCM43xx_PCIE_DLLP_LINKCTL      0x0100
-
-/* PCI-E MDIO bits. */
-#define BCM43xx_PCIE_MDIO_ST   0x40000000
-#define BCM43xx_PCIE_MDIO_WT   0x10000000
-#define BCM43xx_PCIE_MDIO_DEV  22
-#define BCM43xx_PCIE_MDIO_REG  18
-#define BCM43xx_PCIE_MDIO_TA   0x00020000
-#define BCM43xx_PCIE_MDIO_TC   0x0100
-
-/* MDIO devices. */
-#define BCM43xx_MDIO_SERDES_RX	0x1F
-
-/* SERDES RX registers. */
-#define BCM43xx_SERDES_RXTIMER	0x2
-#define BCM43xx_SERDES_CDR	0x6
-#define BCM43xx_SERDES_CDR_BW	0x7
-
-/* Chipcommon capabilities. */
-#define BCM43xx_CAPABILITIES_PCTL		0x00040000
-#define BCM43xx_CAPABILITIES_PLLMASK		0x00030000
-#define BCM43xx_CAPABILITIES_PLLSHIFT		16
-#define BCM43xx_CAPABILITIES_FLASHMASK		0x00000700
-#define BCM43xx_CAPABILITIES_FLASHSHIFT		8
-#define BCM43xx_CAPABILITIES_EXTBUSPRESENT	0x00000040
-#define BCM43xx_CAPABILITIES_UARTGPIO		0x00000020
-#define BCM43xx_CAPABILITIES_UARTCLOCKMASK	0x00000018
-#define BCM43xx_CAPABILITIES_UARTCLOCKSHIFT	3
-#define BCM43xx_CAPABILITIES_MIPSBIGENDIAN	0x00000004
-#define BCM43xx_CAPABILITIES_NRUARTSMASK	0x00000003
-
-/* PowerControl */
-#define BCM43xx_PCTL_IN			0xB0
-#define BCM43xx_PCTL_OUT		0xB4
-#define BCM43xx_PCTL_OUTENABLE		0xB8
-#define BCM43xx_PCTL_XTAL_POWERUP	0x40
-#define BCM43xx_PCTL_PLL_POWERDOWN	0x80
-
-/* PowerControl Clock Modes */
-#define BCM43xx_PCTL_CLK_FAST		0x00
-#define BCM43xx_PCTL_CLK_SLOW		0x01
-#define BCM43xx_PCTL_CLK_DYNAMIC	0x02
-
-#define BCM43xx_PCTL_FORCE_SLOW		0x0800
-#define BCM43xx_PCTL_FORCE_PLL		0x1000
-#define BCM43xx_PCTL_DYN_XTAL		0x2000
-
-/* COREIDs */
-#define BCM43xx_COREID_CHIPCOMMON	0x800
-#define BCM43xx_COREID_ILINE20          0x801
-#define BCM43xx_COREID_SDRAM            0x803
-#define BCM43xx_COREID_PCI		0x804
-#define BCM43xx_COREID_MIPS             0x805
-#define BCM43xx_COREID_ETHERNET         0x806
-#define BCM43xx_COREID_V90		0x807
-#define BCM43xx_COREID_USB11_HOSTDEV    0x80a
-#define BCM43xx_COREID_IPSEC            0x80b
-#define BCM43xx_COREID_PCMCIA		0x80d
-#define BCM43xx_COREID_EXT_IF           0x80f
-#define BCM43xx_COREID_80211		0x812
-#define BCM43xx_COREID_MIPS_3302        0x816
-#define BCM43xx_COREID_USB11_HOST       0x817
-#define BCM43xx_COREID_USB11_DEV        0x818
-#define BCM43xx_COREID_USB20_HOST       0x819
-#define BCM43xx_COREID_USB20_DEV        0x81a
-#define BCM43xx_COREID_SDIO_HOST        0x81b
-#define BCM43xx_COREID_PCIE		0x820
+#define BCM43xx_UCODEFLAGS_OFFSET       0x005E
 
-/* Core Information Registers */
-#define BCM43xx_CIR_BASE		0xf00
-#define BCM43xx_CIR_SBTPSFLAG		(BCM43xx_CIR_BASE + 0x18)
-#define BCM43xx_CIR_SBIMSTATE		(BCM43xx_CIR_BASE + 0x90)
-#define BCM43xx_CIR_SBINTVEC		(BCM43xx_CIR_BASE + 0x94)
-#define BCM43xx_CIR_SBTMSTATELOW	(BCM43xx_CIR_BASE + 0x98)
-#define BCM43xx_CIR_SBTMSTATEHIGH	(BCM43xx_CIR_BASE + 0x9c)
-#define BCM43xx_CIR_SBIMCONFIGLOW	(BCM43xx_CIR_BASE + 0xa8)
-#define BCM43xx_CIR_SB_ID_HI		(BCM43xx_CIR_BASE + 0xfc)
-
-/* Mask to get the Backplane Flag Number from SBTPSFLAG. */
-#define BCM43xx_BACKPLANE_FLAG_NR_MASK	0x3f
-
-/* SBIMCONFIGLOW values/masks. */
-#define BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_MASK		0x00000007
-#define BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_SHIFT	0
-#define BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_MASK		0x00000070
-#define BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_SHIFT	4
-#define BCM43xx_SBIMCONFIGLOW_CONNID_MASK		0x00ff0000
-#define BCM43xx_SBIMCONFIGLOW_CONNID_SHIFT		16
-
-/* sbtmstatelow state flags */
-#define BCM43xx_SBTMSTATELOW_RESET		0x01
-#define BCM43xx_SBTMSTATELOW_REJECT		0x02
-#define BCM43xx_SBTMSTATELOW_CLOCK		0x10000
-#define BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK	0x20000
-#define BCM43xx_SBTMSTATELOW_G_MODE_ENABLE	0x20000000
+/* Hardware Radio Enable masks */
+#define BCM43xx_MMIO_RADIO_HWENABLED_HI_MASK (1 << 16)
+#define BCM43xx_MMIO_RADIO_HWENABLED_LO_MASK (1 << 4)
 
-/* sbtmstatehigh state flags */
-#define BCM43xx_SBTMSTATEHIGH_SERROR		0x00000001
-#define BCM43xx_SBTMSTATEHIGH_BUSY		0x00000004
-#define BCM43xx_SBTMSTATEHIGH_TIMEOUT		0x00000020
-#define BCM43xx_SBTMSTATEHIGH_G_PHY_AVAIL	0x00010000
-#define BCM43xx_SBTMSTATEHIGH_A_PHY_AVAIL	0x00020000
-#define BCM43xx_SBTMSTATEHIGH_COREFLAGS		0x1FFF0000
-#define BCM43xx_SBTMSTATEHIGH_DMA64BIT		0x10000000
-#define BCM43xx_SBTMSTATEHIGH_GATEDCLK		0x20000000
-#define BCM43xx_SBTMSTATEHIGH_BISTFAILED	0x40000000
-#define BCM43xx_SBTMSTATEHIGH_BISTCOMPLETE	0x80000000
+/* HostFlags. See bcm43xx_hf_read/write() */
+#define BCM43xx_HF_SYMW			0x00000002 /* G-PHY SYM workaround */
+#define BCM43xx_HF_GDCW			0x00000020 /* G-PHY DV cancel filter */
+#define BCM43xx_HF_OFDMPABOOST		0x00000040 /* Enable PA boost OFDM */
+#define BCM43xx_HF_EDCF			0x00000100 /* on if WME/MAC suspended */
 
-/* sbimstate flags */
-#define BCM43xx_SBIMSTATE_IB_ERROR		0x20000
-#define BCM43xx_SBIMSTATE_TIMEOUT		0x40000
+/* MacFilter offsets. */
+#define BCM43xx_MACFILTER_SELF		0x0000
+#define BCM43xx_MACFILTER_BSSID		0x0003
+#define BCM43xx_MACFILTER_MAC		0x0010
 
 /* PHYVersioning */
-#define BCM43xx_PHYTYPE_A		0x00
 #define BCM43xx_PHYTYPE_B		0x01
 #define BCM43xx_PHYTYPE_G		0x02
 
 /* PHYRegisters */
-#define BCM43xx_PHY_ILT_A_CTRL		0x0072
-#define BCM43xx_PHY_ILT_A_DATA1		0x0073
-#define BCM43xx_PHY_ILT_A_DATA2		0x0074
 #define BCM43xx_PHY_G_LO_CONTROL	0x0810
 #define BCM43xx_PHY_ILT_G_CTRL		0x0472
 #define BCM43xx_PHY_ILT_G_DATA1		0x0473
 #define BCM43xx_PHY_ILT_G_DATA2		0x0474
-#define BCM43xx_PHY_A_PCTL		0x007B
 #define BCM43xx_PHY_G_PCTL		0x0029
-#define BCM43xx_PHY_A_CRS		0x0029
 #define BCM43xx_PHY_RADIO_BITFIELD	0x0401
 #define BCM43xx_PHY_G_CRS		0x0429
 #define BCM43xx_PHY_NRSSILT_CTRL	0x0803
@@ -319,13 +174,20 @@
 /* RadioRegisters */
 #define BCM43xx_RADIOCTL_ID		0x01
 
+/* MAC Control bitfield */
+#define BCM43xx_MACCTL_IHR_ENABLED	0x00000400 /* IHR Region Enabled */
+#define BCM43xx_MACCTL_INFRA		0x00020000 /* Infrastructure mode */
+#define BCM43xx_MACCTL_AP		0x00040000 /* AccessPoint mode */
+#define BCM43xx_MACCTL_KEEP_BADPLCP	0x00200000 /* Keep bad PLCP frames */
+#define BCM43xx_MACCTL_KEEP_CTL		0x00400000 /* Keep control frames */
+#define BCM43xx_MACCTL_KEEP_BAD		0x00800000 /* Keep bad frames (FCS) */
+#define BCM43xx_MACCTL_PROMISC		0x01000000 /* Promiscuous mode */
+#define BCM43xx_MACCTL_GMODE		0x80000000 /* G Mode */
+
 /* StatusBitField */
 #define BCM43xx_SBF_MAC_ENABLED		0x00000001
-#define BCM43xx_SBF_2			0x00000002 /*FIXME: fix name*/
 #define BCM43xx_SBF_CORE_READY		0x00000004
 #define BCM43xx_SBF_400			0x00000400 /*FIXME: fix name*/
-#define BCM43xx_SBF_4000		0x00004000 /*FIXME: fix name*/
-#define BCM43xx_SBF_8000		0x00008000 /*FIXME: fix name*/
 #define BCM43xx_SBF_XFER_REG_BYTESWAP	0x00010000
 #define BCM43xx_SBF_MODE_NOTADHOC	0x00020000
 #define BCM43xx_SBF_MODE_AP		0x00040000
@@ -336,142 +198,146 @@
 #define BCM43xx_SBF_PS2			0x04000000
 #define BCM43xx_SBF_NO_SSID_BCAST	0x08000000
 #define BCM43xx_SBF_TIME_UPDATE		0x10000000
-#define BCM43xx_SBF_MODE_G		0x80000000
 
-/* Microcode */
-#define BCM43xx_UCODE_REVISION		0x0000
-#define BCM43xx_UCODE_PATCHLEVEL	0x0002
-#define BCM43xx_UCODE_DATE		0x0004
-#define BCM43xx_UCODE_TIME		0x0006
-#define BCM43xx_UCODE_STATUS		0x0040
-
-/* MicrocodeFlagsBitfield (addr + lo-word values?)*/
-#define BCM43xx_UCODEFLAGS_OFFSET	0x005E
-
-#define BCM43xx_UCODEFLAG_AUTODIV	0x0001
-#define BCM43xx_UCODEFLAG_UNKBGPHY	0x0002
-#define BCM43xx_UCODEFLAG_UNKBPHY	0x0004
-#define BCM43xx_UCODEFLAG_UNKGPHY	0x0020
-#define BCM43xx_UCODEFLAG_UNKPACTRL	0x0040
-#define BCM43xx_UCODEFLAG_JAPAN		0x0080
+/* 802.11 core specific TM State Low flags */
+#define BCM43xx_TMSLOW_GMODE		0x20000000 /* G Mode Enable */
+#define BCM43xx_TMSLOW_PLLREFSEL	0x00200000 /* PLL Freq Ref Select */
+#define BCM43xx_TMSLOW_MACPHYCLKEN	0x00100000 /* MAC PHY Clock Ctrl Enbl */
+#define BCM43xx_TMSLOW_PHYRESET		0x00080000 /* PHY Reset */
+#define BCM43xx_TMSLOW_PHYCLKEN		0x00040000 /* PHY Clock Enable */
+
+/* 802.11 core specific TM State High flags */
+#define BCM43xx_TMSHIGH_FCLOCK		0x00040000 /* Fast Clock Available */
+#define BCM43xx_TMSHIGH_GPHY		0x00010000 /* G-PHY avail (rev >= 5) */
 
-/* Hardware Radio Enable masks */
-#define BCM43xx_MMIO_RADIO_HWENABLED_HI_MASK (1 << 16)
-#define BCM43xx_MMIO_RADIO_HWENABLED_LO_MASK (1 << 4)
+#define BCM43xx_UCODEFLAG_AUTODIV        0x0001
 
 /* Generic-Interrupt reasons. */
-#define BCM43xx_IRQ_READY		(1 << 0)
-#define BCM43xx_IRQ_BEACON		(1 << 1)
-#define BCM43xx_IRQ_PS			(1 << 2)
-#define BCM43xx_IRQ_REG124		(1 << 5)
-#define BCM43xx_IRQ_PMQ			(1 << 6)
-#define BCM43xx_IRQ_PIO_WORKAROUND	(1 << 8)
-#define BCM43xx_IRQ_XMIT_ERROR		(1 << 11)
-#define BCM43xx_IRQ_RX			(1 << 15)
-#define BCM43xx_IRQ_SCAN		(1 << 16)
-#define BCM43xx_IRQ_NOISE		(1 << 18)
-#define BCM43xx_IRQ_XMIT_STATUS		(1 << 29)
-
-#define BCM43xx_IRQ_ALL			0xffffffff
-#define BCM43xx_IRQ_INITIAL		(BCM43xx_IRQ_PS |		\
-					 BCM43xx_IRQ_REG124 |		\
+#define BCM43xx_IRQ_MAC_SUSPENDED	0x00000001
+#define BCM43xx_IRQ_BEACON		0x00000002
+#define BCM43xx_IRQ_TBTT_INDI		0x00000004
+#define BCM43xx_IRQ_BEACON_TX_OK	0x00000008
+#define BCM43xx_IRQ_BEACON_CANCEL	0x00000010
+#define BCM43xx_IRQ_ATIM_END		0x00000020
+#define BCM43xx_IRQ_PMQ			0x00000040
+#define BCM43xx_IRQ_PIO_WORKAROUND	0x00000100
+#define BCM43xx_IRQ_MAC_TXERR		0x00000200
+#define BCM43xx_IRQ_PHY_TXERR		0x00000800
+#define BCM43xx_IRQ_PMEVENT		0x00001000
+#define BCM43xx_IRQ_TIMER0		0x00002000
+#define BCM43xx_IRQ_TIMER1		0x00004000
+#define BCM43xx_IRQ_DMA			0x00008000
+#define BCM43xx_IRQ_TXFIFO_FLUSH_OK	0x00010000
+#define BCM43xx_IRQ_CCA_MEASURE_OK	0x00020000
+#define BCM43xx_IRQ_NOISESAMPLE_OK	0x00040000
+#define BCM43xx_IRQ_UCODE_DEBUG		0x08000000
+#define BCM43xx_IRQ_RFKILL		0x10000000
+#define BCM43xx_IRQ_TX_OK		0x20000000
+#define BCM43xx_IRQ_PHY_G_CHANGED	0x40000000
+#define BCM43xx_IRQ_TIMEOUT		0x80000000
+
+#define BCM43xx_IRQ_ALL			0xFFFFFFFF
+#define BCM43xx_IRQ_MASKTEMPLATE	(BCM43xx_IRQ_MAC_SUSPENDED |	\
+					 BCM43xx_IRQ_BEACON |		\
+					 BCM43xx_IRQ_TBTT_INDI |	\
+					 BCM43xx_IRQ_ATIM_END |		\
 					 BCM43xx_IRQ_PMQ |		\
-					 BCM43xx_IRQ_XMIT_ERROR |	\
-					 BCM43xx_IRQ_RX |		\
-					 BCM43xx_IRQ_SCAN |		\
-					 BCM43xx_IRQ_NOISE |		\
-					 BCM43xx_IRQ_XMIT_STATUS)
-					 
-
-/* Initial default iw_mode */
-#define BCM43xx_INITIAL_IWMODE			IW_MODE_INFRA
-
-/* Bus type PCI. */
-#define BCM43xx_BUSTYPE_PCI	0
-/* Bus type Silicone Backplane Bus. */
-#define BCM43xx_BUSTYPE_SB	1
-/* Bus type PCMCIA. */
-#define BCM43xx_BUSTYPE_PCMCIA	2
-
-/* Threshold values. */
-#define BCM43xx_MIN_RTS_THRESHOLD		1U
-#define BCM43xx_MAX_RTS_THRESHOLD		2304U
-#define BCM43xx_DEFAULT_RTS_THRESHOLD		BCM43xx_MAX_RTS_THRESHOLD
+					 BCM43xx_IRQ_MAC_TXERR |	\
+					 BCM43xx_IRQ_PHY_TXERR |	\
+					 BCM43xx_IRQ_DMA |		\
+					 BCM43xx_IRQ_TXFIFO_FLUSH_OK |	\
+					 BCM43xx_IRQ_NOISESAMPLE_OK |	\
+					 BCM43xx_IRQ_UCODE_DEBUG |	\
+					 BCM43xx_IRQ_RFKILL |		\
+					 BCM43xx_IRQ_TX_OK)
+
+/* Device specific rate values.
+ * The actual values defined here are (rate_in_mbps * 2).
+ * Some code depends on this. Don't change it. */
+#define BCM43xx_CCK_RATE_1MB		2
+#define BCM43xx_CCK_RATE_2MB		4
+#define BCM43xx_CCK_RATE_5MB		11
+#define BCM43xx_CCK_RATE_11MB		22
+#define BCM43xx_OFDM_RATE_6MB		12
+#define BCM43xx_OFDM_RATE_9MB		18
+#define BCM43xx_OFDM_RATE_12MB		24
+#define BCM43xx_OFDM_RATE_18MB		36
+#define BCM43xx_OFDM_RATE_24MB		48
+#define BCM43xx_OFDM_RATE_36MB		72
+#define BCM43xx_OFDM_RATE_48MB		96
+#define BCM43xx_OFDM_RATE_54MB		108
+/* Convert a bcm43xx rate value to a rate in 100kbps */
+#define BCM43xx_RATE_TO_100KBPS(rate)	(((rate) * 10) / 2)
+
 
 #define BCM43xx_DEFAULT_SHORT_RETRY_LIMIT	7
 #define BCM43xx_DEFAULT_LONG_RETRY_LIMIT	4
 
-/* FIXME: the next line is a guess as to what the maximum RSSI value might be */
-#define RX_RSSI_MAX				60
-
 /* Max size of a security key */
 #define BCM43xx_SEC_KEYSIZE			16
 /* Security algorithms. */
 enum {
 	BCM43xx_SEC_ALGO_NONE = 0, /* unencrypted, as of TX header. */
-	BCM43xx_SEC_ALGO_WEP,
-	BCM43xx_SEC_ALGO_UNKNOWN,
+	BCM43xx_SEC_ALGO_WEP40,
+	BCM43xx_SEC_ALGO_TKIP,
 	BCM43xx_SEC_ALGO_AES,
 	BCM43xx_SEC_ALGO_WEP104,
-	BCM43xx_SEC_ALGO_TKIP,
+	BCM43xx_SEC_ALGO_AES_LEGACY,
 };
 
-#ifdef assert
-# undef assert
-#endif
-#ifdef CONFIG_BCM43XX_DEBUG
-#define assert(expr) \
-	do {									\
-		if (unlikely(!(expr))) {					\
-		printk(KERN_ERR PFX "ASSERTION FAILED (%s) at: %s:%d:%s()\n",	\
-			#expr, __FILE__, __LINE__, __FUNCTION__);		\
-		}								\
-	} while (0)
-#else
-#define assert(expr)	do { /* nothing */ } while (0)
-#endif
+/* Core Information Registers */
+#define BCM43xx_CIR_BASE                0xf00
+#define BCM43xx_CIR_SBTPSFLAG           (BCM43xx_CIR_BASE + 0x18)
+#define BCM43xx_CIR_SBIMSTATE           (BCM43xx_CIR_BASE + 0x90)
+#define BCM43xx_CIR_SBINTVEC            (BCM43xx_CIR_BASE + 0x94)
+#define BCM43xx_CIR_SBTMSTATELOW        (BCM43xx_CIR_BASE + 0x98)
+#define BCM43xx_CIR_SBTMSTATEHIGH       (BCM43xx_CIR_BASE + 0x9c)
+#define BCM43xx_CIR_SBIMCONFIGLOW       (BCM43xx_CIR_BASE + 0xa8)
+#define BCM43xx_CIR_SB_ID_HI            (BCM43xx_CIR_BASE + 0xfc)
 
-/* rate limited printk(). */
-#ifdef printkl
-# undef printkl
-#endif
-#define printkl(f, x...)  do { if (printk_ratelimit()) printk(f ,##x); } while (0)
-/* rate limited printk() for debugging */
-#ifdef dprintkl
-# undef dprintkl
-#endif
-#ifdef CONFIG_BCM43XX_DEBUG
-# define dprintkl		printkl
-#else
-# define dprintkl(f, x...)	do { /* nothing */ } while (0)
-#endif
+/* sbtmstatehigh state flags */
+#define BCM43xx_SBTMSTATEHIGH_SERROR		0x00000001
+#define BCM43xx_SBTMSTATEHIGH_BUSY		0x00000004
+#define BCM43xx_SBTMSTATEHIGH_TIMEOUT		0x00000020
+#define BCM43xx_SBTMSTATEHIGH_G_PHY_AVAIL	0x00010000
+#define BCM43xx_SBTMSTATEHIGH_COREFLAGS		0x1FFF0000
+#define BCM43xx_SBTMSTATEHIGH_DMA64BIT		0x10000000
+#define BCM43xx_SBTMSTATEHIGH_GATEDCLK		0x20000000
+#define BCM43xx_SBTMSTATEHIGH_BISTFAILED	0x40000000
+#define BCM43xx_SBTMSTATEHIGH_BISTCOMPLETE	0x80000000
 
-/* Helper macro for if branches.
- * An if branch marked with this macro is only taken in DEBUG mode.
- * Example:
- *	if (DEBUG_ONLY(foo == bar)) {
- *		do something
- *	}
- *	In DEBUG mode, the branch will be taken if (foo == bar).
- *	In non-DEBUG mode, the branch will never be taken.
- */
-#ifdef DEBUG_ONLY
-# undef DEBUG_ONLY
-#endif
-#ifdef CONFIG_BCM43XX_DEBUG
-# define DEBUG_ONLY(x)	(x)
-#else
-# define DEBUG_ONLY(x)	0
-#endif
+/* sbimstate flags */
+#define BCM43xx_SBIMSTATE_IB_ERROR		0x20000
+#define BCM43xx_SBIMSTATE_TIMEOUT		0x40000
 
-/* debugging printk() */
-#ifdef dprintk
-# undef dprintk
+#define PFX		KBUILD_MODNAME ": "
+#ifdef assert
+# undef assert
 #endif
 #ifdef CONFIG_BCM43XX_DEBUG
-# define dprintk(f, x...)  do { printk(f ,##x); } while (0)
+# define BCM43xx_WARN_ON(expr)						\
+	do {								\
+		if (unlikely((expr))) {					\
+			printk(KERN_INFO PFX "Test (%s) failed at:"	\
+					      " %s:%d:%s()\n",		\
+					      #expr, __FILE__,		\
+					      __LINE__, __FUNCTION__);	\
+			WARN_ON(expr);					\
+		}							\
+	} while (0)
+# define BCM43xx_BUG_ON(expr)						\
+	do {								\
+		if (unlikely((expr))) {				\
+			printk(KERN_INFO PFX "Test (%s) failed\n",	\
+					      #expr);			\
+			BUG_ON(expr);					\
+		}							\
+	} while (0)
+# define BCM43xx_DEBUG	1
 #else
-# define dprintk(f, x...)  do { /* nothing */ } while (0)
+# define BCM43xx_WARN_ON(x)	do { /* nothing */ } while (0)
+# define BCM43xx_BUG_ON(x)	do { /* nothing */ } while (0)
+# define BCM43xx_DEBUG	0
 #endif
 
 
@@ -486,52 +352,9 @@ struct bcm43xx_initval {
 	u32 value;
 } __attribute__((__packed__));
 
-/* Values for bcm430x_sprominfo.locale */
-enum {
-	BCM43xx_LOCALE_WORLD = 0,
-	BCM43xx_LOCALE_THAILAND,
-	BCM43xx_LOCALE_ISRAEL,
-	BCM43xx_LOCALE_JORDAN,
-	BCM43xx_LOCALE_CHINA,
-	BCM43xx_LOCALE_JAPAN,
-	BCM43xx_LOCALE_USA_CANADA_ANZ,
-	BCM43xx_LOCALE_EUROPE,
-	BCM43xx_LOCALE_USA_LOW,
-	BCM43xx_LOCALE_JAPAN_HIGH,
-	BCM43xx_LOCALE_ALL,
-	BCM43xx_LOCALE_NONE,
-};
-
-#define BCM43xx_SPROM_SIZE	64 /* in 16-bit words. */
-struct bcm43xx_sprominfo {
-	u16 boardflags2;
-	u8 il0macaddr[6];
-	u8 et0macaddr[6];
-	u8 et1macaddr[6];
-	u8 et0phyaddr:5;
-	u8 et1phyaddr:5;
-	u8 boardrev;
-	u8 locale:4;
-	u8 antennas_aphy:2;
-	u8 antennas_bgphy:2;
-	u16 pa0b0;
-	u16 pa0b1;
-	u16 pa0b2;
-	u8 wl0gpio0;
-	u8 wl0gpio1;
-	u8 wl0gpio2;
-	u8 wl0gpio3;
-	u8 maxpower_aphy;
-	u8 maxpower_bgphy;
-	u16 pa1b0;
-	u16 pa1b1;
-	u16 pa1b2;
-	u8 idle_tssi_tgt_aphy;
-	u8 idle_tssi_tgt_bgphy;
-	u16 boardflags;
-	u16 antennagain_aphy;
-	u16 antennagain_bgphy;
-};
+#define BCM43xx_PHYMODE(phytype)	(1 << (phytype))
+#define BCM43xx_PHYMODE_B		BCM43xx_PHYMODE(BCM43xx_PHYTYPE_B)
+#define BCM43xx_PHYMODE_G		BCM43xx_PHYMODE(BCM43xx_PHYTYPE_G)
 
 /* Value pair to measure the LocalOscillator. */
 struct bcm43xx_lopair {
@@ -541,67 +364,96 @@ struct bcm43xx_lopair {
 };
 #define BCM43xx_LO_COUNT	(14*4)
 
-struct bcm43xx_phyinfo {
-	/* Hardware Data */
+struct bcm43xx_phy {
+	/* Possible PHYMODEs on this PHY */
+	u8 possible_phymodes;
+	/* GMODE bit enabled? */
+	bool gmode;
+	/* Possible ieee80211 subsystem hwmodes for this PHY.
+	 * Which mode is selected, depends on thr GMODE enabled bit */
+#define BCM43xx_MAX_PHYHWMODES	2
+	struct ieee80211_hw_mode hwmodes[BCM43xx_MAX_PHYHWMODES];
+
+	/* Analog Type */
 	u8 analog;
+	/* BCM43xx_PHYTYPE_ */
 	u8 type;
+	/* PHY revision number. */
 	u8 rev;
+
 	u16 antenna_diversity;
 	u16 savedpctlreg;
+	/* Radio versioning */
+	u16 radio_manuf;	/* Radio manufacturer */
+	u16 radio_ver;		/* Radio version */
+	u8 calibrated:1;
+	u8 radio_rev;		/* Radio revision */
+
+	bool radio_on;		/* Radio switched on/off */
+	bool locked;		/* Only used in bcm43xx_phy_{un}lock() */
+	bool dyn_tssi_tbl;	/* tssi2dbm is kmalloc()ed. */
+
+	/* ACI (adjacent channel interference) flags. */
+	bool aci_enable;
+	bool aci_wlan_automatic;
+	bool aci_hw_rssi;
+
 	u16 minlowsig[2];
 	u16 minlowsigpos[2];
-	u8 connected:1,
-	   calibrated:1,
-	   is_locked:1, /* used in bcm43xx_phy_{un}lock() */
-	   dyn_tssi_tbl:1; /* used in bcm43xx_phy_init_tssi2dbm_table() */
+
 	/* LO Measurement Data.
 	 * Use bcm43xx_get_lopair() to get a value.
 	 */
 	struct bcm43xx_lopair *_lo_pairs;
-
 	/* TSSI to dBm table in use */
 	const s8 *tssi2dbm;
 	/* idle TSSI value */
 	s8 idle_tssi;
+	/* Target idle TSSI */
+	int tgt_idle_tssi;
+	/* Current idle TSSI */
+	int cur_idle_tssi;
 
+	/* LocalOscillator control values. */
+	struct bcm43xx_txpower_lo_control *lo_control;
 	/* Values from bcm43xx_calc_loopback_gain() */
-	u16 loopback_gain[2];
+	s16 max_lb_gain;	/* Maximum Loopback gain in hdB */
+	s16 trsw_rx_gain;	/* TRSW RX gain in hdB */
+	s16 lna_lod_gain;	/* LNA lod */
+	s16 lna_gain;		/* LNA */
+	s16 pga_gain;		/* PGA */
 
 	/* PHY lock for core.rev < 3
 	 * This lock is only used by bcm43xx_phy_{un}lock()
 	 */
 	spinlock_t lock;
 
-	/* Firmware. */
-	const struct firmware *ucode;
-	const struct firmware *pcm;
-	const struct firmware *initvals0;
-	const struct firmware *initvals1;
-};
-
+	/* Desired TX power level (in dBm).
+	 * This is set by the user and adjusted in bcm43xx_phy_xmitpower(). */
+	u8 power_level;
 
-struct bcm43xx_radioinfo {
-	u16 manufact;
-	u16 version;
-	u8 revision;
+	/* Values from bcm43xx_calc_loopback_gain() */
+	u16 loopback_gain[2];
 
-	/* Desired TX power in dBm Q5.2 */
-	u16 txpower_desired;
 	/* TX Power control values. */
-	union {
-		/* B/G PHY */
-		struct {
-			u16 baseband_atten;
-			u16 radio_atten;
-			u16 txctl1;
-			u16 txctl2;
-		};
-		/* A PHY */
-		struct {
-			u16 txpwr_offset;
-		};
+	/* B/G PHY */
+	struct {
+		/* Current Radio Attenuation for TXpower recalculation. */
+		u16 rfatt;
+		/* Current Baseband Attenuation for TXpower recalculation. */
+		u16 bbatt;
+		/* Current TXpower control value for TXpower recalculation. */
+		u16 txctl1;
+		u16 txctl2;
+	};
+	/* A PHY */
+	struct {
+		u16 txpwr_offset;
 	};
 
+#ifdef CONFIG_BCM43XX_DEBUG
+	bool manual_txpower_control; /* Manual TX-power control enabled? */
+#endif
 	/* Current Interference Mitigation mode */
 	int interfmode;
 	/* Stack of saved values from the Interference Mitigation code.
@@ -612,7 +464,7 @@ struct bcm43xx_radioinfo {
 	 * register ID is: 0x1 PHY, 0x2 Radio, 0x3 ILT
 	 */
 #define BCM43xx_INTERFSTACK_SIZE	26
-	u32 interfstack[BCM43xx_INTERFSTACK_SIZE];
+	u32 interfstack[BCM43xx_INTERFSTACK_SIZE];/* FIXME: use a data struct */
 
 	/* Saved values from the NRSSI Slope calculation */
 	s16 nrssi[2];
@@ -622,17 +474,10 @@ struct bcm43xx_radioinfo {
 
 	/* current channel */
 	u8 channel;
-	u8 initial_channel;
 
 	u16 lofcal;
 
 	u16 initval;
-
-	u8 enabled:1;
-	/* ACI (adjacent channel interference) flags. */
-	u8 aci_enable:1,
-	   aci_wlan_automatic:1,
-	   aci_hw_rssi:1;
 };
 
 /* Data structures for DMA transmission, per 80211 core. */
@@ -656,147 +501,145 @@ struct bcm43xx_pio {
 	struct bcm43xx_pioqueue *queue3;
 };
 
-#define BCM43xx_MAX_80211_CORES		2
-
-/* Generic information about a core. */
-struct bcm43xx_coreinfo {
-	u8 available:1,
-	   enabled:1,
-	   initialized:1;
-	/** core_rev revision number */
-	u8 rev;
-	/** Index number for _switch_core() */
-	u8 index;
-	/** core_id ID number */
-	u16 id;
-	/** Core-specific data. */
-	void *priv;
-};
-
-/* Additional information for each 80211 core. */
-struct bcm43xx_coreinfo_80211 {
-	/* PHY device. */
-	struct bcm43xx_phyinfo phy;
-	/* Radio device. */
-	struct bcm43xx_radioinfo radio;
-	union {
-		/* DMA context. */
-		struct bcm43xx_dma dma;
-		/* PIO context. */
-		struct bcm43xx_pio pio;
-	};
-};
-
 /* Context information for a noise calculation (Link Quality). */
 struct bcm43xx_noise_calculation {
-	struct bcm43xx_coreinfo *core_at_start;
 	u8 channel_at_start;
-	u8 calculation_running:1;
+	bool calculation_running;
 	u8 nr_samples;
 	s8 samples[8][4];
 };
 
 struct bcm43xx_stats {
-	u8 noise;
-	struct iw_statistics wstats;
+	u8 link_noise;
 	/* Store the last TX/RX times here for updating the leds. */
 	unsigned long last_tx;
 	unsigned long last_rx;
 };
 
 struct bcm43xx_key {
-	u8 enabled:1;
+	bool enabled;
 	u8 algorithm;
+	u8 address[6];
 };
 
-/* Driver initialization status. */
+struct bcm43xx_wldev;
+
+/* Data structure for the WLAN parts (802.11 cores) of the bcm43xx chip. */
+struct bcm43xx_wl {
+	/* Pointer to the active wireless device on this chip */
+	struct bcm43xx_wldev *current_dev;
+	/* Pointer to the ieee80211 hardware data structure */
+	struct ieee80211_hw *hw;
+
+	spinlock_t irq_lock;		/* locks IRQ */
+	struct mutex mutex;		/* locks ? */
+	spinlock_t leds_lock;		/* lock for leds */
+
+	/* We can only have one operating interface (802.11 core)
+	 * at a time. General information about this interface follows.
+	 */
+
+	/* Opaque ID of the operating interface (!= monitor
+	 * interface) from the ieee80211 subsystem.
+	 * Do not modify.
+	 */
+	int if_id;
+	/* MAC address (can be NULL). */
+	const u8 *mac_addr;
+	/* Current BSSID (can be NULL). */
+	const u8 *bssid;
+	/* Interface type. (IEEE80211_IF_TYPE_XXX) */
+	int if_type;
+	/* Counter of active monitor interfaces. */
+	int monitor;
+	/* Is the card operating in AP, STA or IBSS mode? */
+	bool operating;
+	/* Promisc mode active?
+	 * Note that (monitor != 0) implies promisc.
+	 */
+	bool promisc;
+	/* Stats about the wireless interface */
+	struct ieee80211_low_level_stats ieee_stats;
+
+	struct hwrng rng;
+	u8 rng_initialized;
+	char rng_name[30 + 1];
+
+	/* List of all wireless devices on this chip */
+	struct list_head devlist;
+	u8 nr_devs;
+};
+
+/* Pointers to the firmware data and meta information about it. */
+struct bcm43xx_firmware {
+	/* Microcode */
+	const struct firmware *ucode;
+	/* PCM code */
+	const struct firmware *pcm;
+	/* Initial MMIO values 0 */
+	const struct firmware *initvals0;
+	/* Initial MMIO values 1 */
+	const struct firmware *initvals1;
+	/* Firmware revision */
+	u16 rev;
+	/* Firmware patchlevel */
+	u16 patch;
+};
+
+/* Device (802.11 core) initialization status. */
 enum {
-	BCM43xx_STAT_UNINIT,		/* Uninitialized. */
-	BCM43xx_STAT_INITIALIZING,	/* init_board() in progress. */
-	BCM43xx_STAT_INITIALIZED,	/* Fully operational. */
-	BCM43xx_STAT_SHUTTINGDOWN,	/* free_board() in progress. */
-	BCM43xx_STAT_RESTARTING,	/* controller_restart() called. */
-};
-#define bcm43xx_status(bcm)		atomic_read(&(bcm)->init_status)
-#define bcm43xx_set_status(bcm, stat)	do {			\
-		atomic_set(&(bcm)->init_status, (stat));	\
+	BCM43xx_STAT_UNINIT		= 0, /* Uninitialized. */
+	BCM43xx_STAT_INITIALIZED	= 1, /* Initialized, not yet started */
+	BCM43xx_STAT_STARTED		= 2, /* Up and running. */
+};
+#define bcm43xx_status(wldev)		atomic_read(&(wldev)->__init_status)
+#define bcm43xx_set_status(wldev, stat)	do {			\
+		atomic_set(&(wldev)->__init_status, (stat));	\
 		smp_wmb();					\
 					} while (0)
 
-/*    *** THEORY OF LOCKING ***
+/* XXX---   HOW LOCKING WORKS IN BCM43xx   ---XXX
  *
- * We have two different locks in the bcm43xx driver.
- * => bcm->mutex:    General sleeping mutex. Protects struct bcm43xx_private
- *                   and the device registers. This mutex does _not_ protect
- *                   against concurrency from the IRQ handler.
- * => bcm->irq_lock: IRQ spinlock. Protects against IRQ handler concurrency.
- *
- * Please note that, if you only take the irq_lock, you are not protected
- * against concurrency from the periodic work handlers.
- * Most times you want to take _both_ locks.
+ * You should always acquire both, wl->mutex and wl->irq_lock unless:
+ * - You don't need to acquire wl->irq_lock, if the interface is stopped.
+ * - You don't need to acquire wl->mutex in the IRQ handler, IRQ tasklet
+ *   and packet TX path (and _ONLY_ there.)
  */
 
-struct bcm43xx_private {
-	struct ieee80211_device *ieee;
-	struct ieee80211softmac_device *softmac;
-
-	struct net_device *net_dev;
-	struct pci_dev *pci_dev;
-	unsigned int irq;
-
-	void __iomem *mmio_addr;
-
-	spinlock_t irq_lock;
-	struct mutex mutex;
-
-	/* Driver initialization status BCM43xx_STAT_*** */
-	atomic_t init_status;
-
-	u16 was_initialized:1,		/* for PCI suspend/resume. */
-	    __using_pio:1,		/* Internal, use bcm43xx_using_pio(). */
-	    bad_frames_preempt:1,	/* Use "Bad Frames Preemption" (default off) */
-	    reg124_set_0x4:1,		/* Some variable to keep track of IRQ stuff. */
-	    short_preamble:1,		/* TRUE, if short preamble is enabled. */
-	    firmware_norelease:1,	/* Do not release the firmware. Used on suspend. */
-	    radio_hw_enable:1;		/* TRUE if radio is hardware enabled */
-
-	struct bcm43xx_stats stats;
+/* Data structure for one wireless device (802.11 core) */
+struct bcm43xx_wldev {
+	struct ssb_device *dev;
+	struct bcm43xx_wl *wl;
+
+	/* The device initialization status.
+	 * Use bcm43xx_status() to query. */
+	atomic_t __init_status;
+	/* Saved init status for handling suspend. */
+	int suspend_init_status;
+
+	bool __using_pio;		/* iUse bcm43xx_using_pio(). */
+	bool bad_frames_preempt;	/* Use "Bad Frames Preemption" */
+	bool reg124_set_0x4;		/* Variable to keep track of IRQ */
+	bool short_preamble;		/* TRUE if short preamble enabled. */
+	bool short_slot;		/* TRUE if short slot timing enabled. */
+	bool radio_hw_enable;		/* state of radio hardware enable bit */
+	u8 short_retry_limit;
+	u8 long_retry_limit;
 
-	/* Bus type we are connected to.
-	 * This is currently always BCM43xx_BUSTYPE_PCI
-	 */
-	u8 bustype;
-	u64 dma_mask;
+	/* PHY/Radio device. */
+	struct bcm43xx_phy phy;
+	union {
+		/* DMA engines. */
+		struct bcm43xx_dma dma;
+		/* PIO engines. */
+		struct bcm43xx_pio pio;
+	};
 
-	u16 board_vendor;
-	u16 board_type;
-	u16 board_revision;
-
-	u16 chip_id;
-	u8 chip_rev;
-	u8 chip_package;
+	/* Various statistics about the physical device. */
+	struct bcm43xx_stats stats;
 
-	struct bcm43xx_sprominfo sprom;
 #define BCM43xx_NR_LEDS		4
 	struct bcm43xx_led leds[BCM43xx_NR_LEDS];
-	spinlock_t leds_lock;
-
-	/* The currently active core. */
-	struct bcm43xx_coreinfo *current_core;
-	struct bcm43xx_coreinfo *active_80211_core;
-	/* coreinfo structs for all possible cores follow.
-	 * Note that a core might not exist.
-	 * So check the coreinfo flags before using it.
-	 */
-	struct bcm43xx_coreinfo core_chipcommon;
-	struct bcm43xx_coreinfo core_pci;
-	struct bcm43xx_coreinfo core_80211[ BCM43xx_MAX_80211_CORES ];
-	/* Additional information, specific to the 80211 cores. */
-	struct bcm43xx_coreinfo_80211 core_80211_ext[ BCM43xx_MAX_80211_CORES ];
-	/* Number of available 80211 cores. */
-	int nr_80211_available;
-
-	u32 chipcommon_capabilities;
 
 	/* Reason code of the last interrupt. */
 	u32 irq_reason;
@@ -808,10 +651,6 @@ struct bcm43xx_private {
 	/* if > 0 MAC is suspended. if == 0 MAC is enabled. */
 	int mac_suspended;
 
-	/* Threshold values. */
-	//TODO: The RTS thr has to be _used_. Currently, it is only set via WX.
-	u32 rts_threshold;
-
 	/* Interrupt Service Routine tasklet (bottom-half) */
 	struct tasklet_struct isr_tasklet;
 
@@ -821,17 +660,19 @@ struct bcm43xx_private {
 
 	struct work_struct restart_work;
 
-	/* Informational stuff. */
-	char nick[IW_ESSID_MAX_SIZE + 1];
-
 	/* encryption/decryption */
-	u16 security_offset;
-	struct bcm43xx_key key[54];
-	u8 default_key_idx;
+	u16 ktp; /* Key table pointer */
+	u8 max_nr_keys;
+	struct bcm43xx_key key[58];
 
-	/* Random Number Generator. */
-	struct hwrng rng;
-	char rng_name[20 + 1];
+	/* Cached beacon template while uploading the template. */
+	struct sk_buff *cached_beacon;
+
+	/* Firmware data */
+	struct bcm43xx_firmware fw;
+
+	/* Devicelist in struct bcm43xx_wl (all 802.11 cores) */
+	struct list_head list;
 
 	/* Debugging stuff follows. */
 #ifdef CONFIG_BCM43XX_DEBUG
@@ -841,44 +682,29 @@ struct bcm43xx_private {
 
 
 static inline
-struct bcm43xx_private * bcm43xx_priv(struct net_device *dev)
-{
-	return ieee80211softmac_priv(dev);
-}
-
-struct device;
-
-static inline
-struct bcm43xx_private * dev_to_bcm(struct device *dev)
+struct bcm43xx_wl *hw_to_bcm43xx_wl(struct ieee80211_hw *hw)
 {
-	struct net_device *net_dev;
-	struct bcm43xx_private *bcm;
-
-	net_dev = dev_get_drvdata(dev);
-	bcm = bcm43xx_priv(net_dev);
-
-	return bcm;
+	return hw->priv;
 }
 
-
 /* Helper function, which returns a boolean.
  * TRUE, if PIO is used; FALSE, if DMA is used.
  */
 #if defined(CONFIG_BCM43XX_DMA) && defined(CONFIG_BCM43XX_PIO)
 static inline
-int bcm43xx_using_pio(struct bcm43xx_private *bcm)
+int bcm43xx_using_pio(struct bcm43xx_wldev *dev)
 {
-	return bcm->__using_pio;
+	return dev->__using_pio;
 }
 #elif defined(CONFIG_BCM43XX_DMA)
 static inline
-int bcm43xx_using_pio(struct bcm43xx_private *bcm)
+int bcm43xx_using_pio(struct bcm43xx_wldev *dev)
 {
 	return 0;
 }
 #elif defined(CONFIG_BCM43XX_PIO)
 static inline
-int bcm43xx_using_pio(struct bcm43xx_private *bcm)
+int bcm43xx_using_pio(struct bcm43xx_wldev *dev)
 {
 	return 1;
 }
@@ -886,97 +712,79 @@ int bcm43xx_using_pio(struct bcm43xx_pri
 # error "Using neither DMA nor PIO? Confused..."
 #endif
 
-/* Helper functions to access data structures private to the 80211 cores.
- * Note that we _must_ have an 80211 core mapped when calling
- * any of these functions.
- */
-static inline
-struct bcm43xx_coreinfo_80211 *
-bcm43xx_current_80211_priv(struct bcm43xx_private *bcm)
-{
-	assert(bcm->current_core->id == BCM43xx_COREID_80211);
-	return bcm->current_core->priv;
-}
-static inline
-struct bcm43xx_pio * bcm43xx_current_pio(struct bcm43xx_private *bcm)
-{
-	assert(bcm43xx_using_pio(bcm));
-	return &(bcm43xx_current_80211_priv(bcm)->pio);
-}
-static inline
-struct bcm43xx_dma * bcm43xx_current_dma(struct bcm43xx_private *bcm)
-{
-	assert(!bcm43xx_using_pio(bcm));
-	return &(bcm43xx_current_80211_priv(bcm)->dma);
-}
-static inline
-struct bcm43xx_phyinfo * bcm43xx_current_phy(struct bcm43xx_private *bcm)
-{
-	return &(bcm43xx_current_80211_priv(bcm)->phy);
-}
-static inline
-struct bcm43xx_radioinfo * bcm43xx_current_radio(struct bcm43xx_private *bcm)
-{
-	return &(bcm43xx_current_80211_priv(bcm)->radio);
-}
-
 
 static inline
-struct bcm43xx_lopair * bcm43xx_get_lopair(struct bcm43xx_phyinfo *phy,
-					   u16 radio_attenuation,
-					   u16 baseband_attenuation)
+struct bcm43xx_wldev *dev_to_bcm43xx_wldev(struct device *dev)
 {
-	return phy->_lo_pairs + (radio_attenuation + 14 * (baseband_attenuation / 2));
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	return ssb_get_drvdata(ssb_dev);
 }
 
-
+/* Is the device operating in a specified mode (IEEE80211_IF_TYPE_XXX). */
 static inline
-u16 bcm43xx_read16(struct bcm43xx_private *bcm, u16 offset)
+int bcm43xx_is_mode(struct bcm43xx_wl *wl, int type)
 {
-	return ioread16(bcm->mmio_addr + offset);
+	if (type == IEEE80211_IF_TYPE_MNTR)
+		return !!(wl->monitor);
+	return (wl->operating &&
+		wl->if_type == type);
 }
 
 static inline
-void bcm43xx_write16(struct bcm43xx_private *bcm, u16 offset, u16 value)
+bool is_bcm_board_vendor(struct bcm43xx_wldev *dev)
 {
-	iowrite16(value, bcm->mmio_addr + offset);
+	return  (dev->dev->bus->boardinfo.vendor == PCI_VENDOR_ID_BROADCOM);
 }
 
 static inline
-u32 bcm43xx_read32(struct bcm43xx_private *bcm, u16 offset)
+u16 bcm43xx_read16(struct bcm43xx_wldev *dev, u16 offset)
 {
-	return ioread32(bcm->mmio_addr + offset);
+	return ssb_read16(dev->dev, offset);
 }
 
 static inline
-void bcm43xx_write32(struct bcm43xx_private *bcm, u16 offset, u32 value)
+void bcm43xx_write16(struct bcm43xx_wldev *dev, u16 offset, u16 value)
 {
-	iowrite32(value, bcm->mmio_addr + offset);
+	ssb_write16(dev->dev, offset, value);
 }
 
 static inline
-int bcm43xx_pci_read_config16(struct bcm43xx_private *bcm, int offset, u16 *value)
+u32 bcm43xx_read32(struct bcm43xx_wldev *dev, u16 offset)
 {
-	return pci_read_config_word(bcm->pci_dev, offset, value);
+	return ssb_read32(dev->dev, offset);
 }
 
 static inline
-int bcm43xx_pci_read_config32(struct bcm43xx_private *bcm, int offset, u32 *value)
+void bcm43xx_write32(struct bcm43xx_wldev *dev, u16 offset, u32 value)
 {
-	return pci_read_config_dword(bcm->pci_dev, offset, value);
+	ssb_write32(dev->dev, offset, value);
 }
 
 static inline
-int bcm43xx_pci_write_config16(struct bcm43xx_private *bcm, int offset, u16 value)
+struct bcm43xx_lopair *bcm43xx_get_lopair(struct bcm43xx_phy *phy,
+					   u16 radio_attenuation,
+					   u16 baseband_attenuation)
 {
-	return pci_write_config_word(bcm->pci_dev, offset, value);
+	return phy->_lo_pairs + (radio_attenuation
+			+ 14 * (baseband_attenuation / 2));
 }
 
-static inline
-int bcm43xx_pci_write_config32(struct bcm43xx_private *bcm, int offset, u32 value)
-{
-	return pci_write_config_dword(bcm->pci_dev, offset, value);
-}
+
+
+/* Message printing */
+void bcminfo(struct bcm43xx_wl *wl, const char *fmt, ...)
+		__attribute__((format(printf, 2, 3)));
+void bcmerr(struct bcm43xx_wl *wl, const char *fmt, ...)
+		__attribute__((format(printf, 2, 3)));
+void bcmwarn(struct bcm43xx_wl *wl, const char *fmt, ...)
+		__attribute__((format(printf, 2, 3)));
+#if BCM43xx_DEBUG
+void bcmdbg(struct bcm43xx_wl *wl, const char *fmt, ...)
+		__attribute__((format(printf, 2, 3)));
+#else /* DEBUG */
+# define bcmdbg(wl, fmt...) do { /* nothing */ } while (0)
+#endif /* DEBUG */
+
 
 /** Limit a value between two limits */
 #ifdef limit_value
@@ -985,19 +793,17 @@ int bcm43xx_pci_write_config32(struct bc
 #define limit_value(value, min, max)  \
 	({						\
 		typeof(value) __value = (value);	\
-	 	typeof(value) __min = (min);		\
-	 	typeof(value) __max = (max);		\
-	 	if (__value < __min)			\
-	 		__value = __min;		\
-	 	else if (__value > __max)		\
-	 		__value = __max;		\
-	 	__value;				\
+		typeof(value) __min = (min);		\
+		typeof(value) __max = (max);		\
+		if (__value < __min)			\
+			__value = __min;		\
+		else if (__value > __max)		\
+			__value = __max;		\
+		__value;				\
 	})
 
-/** Helpers to print MAC addresses. */
-#define BCM43xx_MACFMT		"%02x:%02x:%02x:%02x:%02x:%02x"
-#define BCM43xx_MACARG(x)	((u8*)(x))[0], ((u8*)(x))[1], \
-				((u8*)(x))[2], ((u8*)(x))[3], \
-				((u8*)(x))[4], ((u8*)(x))[5]
+/* Macros for printing a value in Q5.2 format */
+#define Q52_FMT		"%u.%u"
+#define Q52_ARG(q52)	((q52) / 4), ((((q52) & 3) * 100) / 4)
 
 #endif /* BCM43xx_H_ */



From Larry.Finger at lwfinger.net  Thu Aug  2 17:53:17 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:53:17 -0500
Subject: [RFC 2/10] Port of bcm43xx from softmac to mac80211
Message-ID: <46b1fded.0g4ZHvU7XwSzeJVs%Larry.Finger@lwfinger.net>

This if file 2 of 10 of the port of the bcm43xx driver from softmac
to mac80211.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.c
@@ -4,7 +4,7 @@
 
   debugfs driver debugging code
 
-  Copyright (c) 2005 Michael Buesch <mbuesch at freenet.de>
+  Copyright (c) 2005 Michael Buesch <mb at bu3sch.de>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -30,7 +30,7 @@
 #include <linux/slab.h>
 #include <linux/netdevice.h>
 #include <linux/pci.h>
-#include <asm/io.h>
+#include <linux/mutex.h>
 
 #include "bcm43xx.h"
 #include "bcm43xx_main.h"
@@ -42,8 +42,8 @@
 #define REALLY_BIG_BUFFER_SIZE	(1024*256)
 
 static struct bcm43xx_debugfs fs;
-static char really_big_buffer[REALLY_BIG_BUFFER_SIZE];
-static DECLARE_MUTEX(big_buffer_sem);
+static char big_buffer[1024*256];
+static DEFINE_MUTEX(big_buffer_mutex);
 
 
 static ssize_t write_file_dummy(struct file *file, const char __user *buf,
@@ -60,440 +60,368 @@ static int open_file_generic(struct inod
 
 #define fappend(fmt, x...)	pos += snprintf(buf + pos, len - pos, fmt , ##x)
 
-static ssize_t devinfo_read_file(struct file *file, char __user *userbuf,
-				 size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	struct net_device *net_dev;
-	struct pci_dev *pci_dev;
-	unsigned long flags;
-	u16 tmp16;
-	int i;
-
-	down(&big_buffer_sem);
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
-	net_dev = bcm->net_dev;
-	pci_dev = bcm->pci_dev;
-
-	/* This is where the information is written to the "devinfo" file */
-	fappend("*** %s devinfo ***\n", net_dev->name);
-	fappend("vendor:           0x%04x   device:           0x%04x\n",
-		pci_dev->vendor, pci_dev->device);
-	fappend("subsystem_vendor: 0x%04x   subsystem_device: 0x%04x\n",
-		pci_dev->subsystem_vendor, pci_dev->subsystem_device);
-	fappend("IRQ: %d\n", bcm->irq);
-	fappend("mmio_addr: 0x%p\n", bcm->mmio_addr);
-	fappend("chip_id: 0x%04x   chip_rev: 0x%02x\n", bcm->chip_id, bcm->chip_rev);
-	if ((bcm->core_80211[0].rev >= 3) && (bcm43xx_read32(bcm, 0x0158) & (1 << 16)))
-		fappend("Radio disabled by hardware!\n");
-	if ((bcm->core_80211[0].rev < 3) && !(bcm43xx_read16(bcm, 0x049A) & (1 << 4)))
-		fappend("Radio disabled by hardware!\n");
-	fappend("board_vendor: 0x%04x   board_type: 0x%04x\n", bcm->board_vendor,
-	        bcm->board_type);
-
-	fappend("\nCores:\n");
-#define fappend_core(name, info) fappend("core \"" name "\" %s, %s, id: 0x%04x, "	\
-					 "rev: 0x%02x, index: 0x%02x\n",		\
-					 (info).available				\
-						? "available" : "nonavailable",		\
-					 (info).enabled					\
-						? "enabled" : "disabled",		\
-					 (info).id, (info).rev, (info).index)
-	fappend_core("CHIPCOMMON", bcm->core_chipcommon);
-	fappend_core("PCI", bcm->core_pci);
-	fappend_core("first 80211", bcm->core_80211[0]);
-	fappend_core("second 80211", bcm->core_80211[1]);
-#undef fappend_core
-	tmp16 = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
-	fappend("LEDs: ");
-	for (i = 0; i < BCM43xx_NR_LEDS; i++)
-		fappend("%d ", !!(tmp16 & (1 << i)));
-	fappend("\n");
-
-out:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&big_buffer_sem);
-	return res;
-}
-
 static ssize_t drvinfo_read_file(struct file *file, char __user *userbuf,
 				 size_t count, loff_t *ppos)
 {
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	char *buf = really_big_buffer;
+	const size_t len = ARRAY_SIZE(big_buffer);
+	char *buf = big_buffer;
 	size_t pos = 0;
 	ssize_t res;
 
-	down(&big_buffer_sem);
-
+	mutex_lock(&big_buffer_mutex);
 	/* This is where the information is written to the "driver" file */
 	fappend(KBUILD_MODNAME " driver\n");
 	fappend("Compiled at: %s %s\n", __DATE__, __TIME__);
-
 	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&big_buffer_sem);
-	return res;
-}
-
-static ssize_t spromdump_read_file(struct file *file, char __user *userbuf,
-				 size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
-
-	down(&big_buffer_sem);
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
+	mutex_unlock(&big_buffer_mutex);
 
-	/* This is where the information is written to the "sprom_dump" file */
-	fappend("boardflags: 0x%04x\n", bcm->sprom.boardflags);
-
-out:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&big_buffer_sem);
 	return res;
 }
 
 static ssize_t tsf_read_file(struct file *file, char __user *userbuf,
 			     size_t count, loff_t *ppos)
 {
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
+	struct bcm43xx_wldev *dev = file->private_data;
+	const size_t len = ARRAY_SIZE(big_buffer);
+	char *buf = big_buffer;
 	size_t pos = 0;
 	ssize_t res;
 	unsigned long flags;
 	u64 tsf;
 
-	down(&big_buffer_sem);
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
+	mutex_lock(&big_buffer_mutex);
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
 		fappend("Board not initialized.\n");
 		goto out;
 	}
-	bcm43xx_tsf_read(bcm, &tsf);
+	bcm43xx_tsf_read(dev, &tsf);
 	fappend("0x%08x%08x\n",
 		(unsigned int)((tsf & 0xFFFFFFFF00000000ULL) >> 32),
 		(unsigned int)(tsf & 0xFFFFFFFFULL));
 
 out:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
 	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&big_buffer_sem);
+	mutex_unlock(&big_buffer_mutex);
+
 	return res;
 }
 
 static ssize_t tsf_write_file(struct file *file, const char __user *user_buf,
 			      size_t count, loff_t *ppos)
 {
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
+	struct bcm43xx_wldev *dev = file->private_data;
+	char *buf = big_buffer;
 	ssize_t buf_size;
 	ssize_t res;
 	unsigned long flags;
 	u64 tsf;
 
-	buf_size = min(count, sizeof (really_big_buffer) - 1);
-	down(&big_buffer_sem);
+	mutex_lock(&big_buffer_mutex);
+	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
 	if (copy_from_user(buf, user_buf, buf_size)) {
 	        res = -EFAULT;
-		goto out_up;
+		goto out_unlock_bb;
 	}
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		printk(KERN_INFO PFX "debugfs: Board not initialized.\n");
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
+		bcmerr(dev->wl, "debugfs: Board not initialized.\n");
 		res = -EFAULT;
 		goto out_unlock;
 	}
-	if (sscanf(buf, "%lli", &tsf) != 1) {
-		printk(KERN_INFO PFX "debugfs: invalid values for \"tsf\"\n");
+	if (sscanf(buf, "%llu", (unsigned long long *)(&tsf)) != 1) {
+		bcmerr(dev->wl, "debugfs: invalid values for \"tsf\"\n");
 		res = -EINVAL;
 		goto out_unlock;
 	}
-	bcm43xx_tsf_write(bcm, tsf);
+	bcm43xx_tsf_write(dev, tsf);
 	mmiowb();
 	res = buf_size;
-	
+
 out_unlock:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-out_up:
-	up(&big_buffer_sem);
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+out_unlock_bb:
+	mutex_unlock(&big_buffer_mutex);
+
 	return res;
 }
 
 static ssize_t txstat_read_file(struct file *file, char __user *userbuf,
 				size_t count, loff_t *ppos)
 {
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
+	struct bcm43xx_wldev *dev = file->private_data;
+	struct bcm43xx_dfsentry *e = dev->dfsentry;
+	struct bcm43xx_txstatus_log *log = &e->txstatlog;
+	unsigned long flags;
+	char *buf = log->printbuf;
+	const size_t len = ARRAY_SIZE(log->printbuf);
 	size_t pos = 0;
 	ssize_t res;
-	unsigned long flags;
-	struct bcm43xx_dfsentry *e;
-	struct bcm43xx_xmitstatus *status;
-	int i, cnt, j = 0;
+	int i;
+	int idx;
+	struct bcm43xx_txstatus *stat;
 
-	down(&big_buffer_sem);
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-
-	fappend("Last %d logged xmitstatus blobs (Latest first):\n\n",
-		BCM43xx_NR_LOGGED_XMITSTATUS);
-	e = bcm->dfsentry;
-	if (e->xmitstatus_printing == 0) {
-		/* At the beginning, make a copy of all data to avoid
-		 * concurrency, as this function is called multiple
-		 * times for big logs. Without copying, the data might
-		 * change between reads. This would result in total trash.
-		 */
-		e->xmitstatus_printing = 1;
-		e->saved_xmitstatus_ptr = e->xmitstatus_ptr;
-		e->saved_xmitstatus_cnt = e->xmitstatus_cnt;
-		memcpy(e->xmitstatus_print_buffer, e->xmitstatus_buffer,
-		       BCM43xx_NR_LOGGED_XMITSTATUS * sizeof(*(e->xmitstatus_buffer)));
-	}
-	i = e->saved_xmitstatus_ptr - 1;
-	if (i < 0)
-		i = BCM43xx_NR_LOGGED_XMITSTATUS - 1;
-	cnt = e->saved_xmitstatus_cnt;
-	while (cnt) {
-		status = e->xmitstatus_print_buffer + i;
-		fappend("0x%02x:   cookie: 0x%04x,  flags: 0x%02x,  "
-			"cnt1: 0x%02x,  cnt2: 0x%02x,  seq: 0x%04x,  "
-			"unk: 0x%04x\n", j,
-			status->cookie, status->flags,
-			status->cnt1, status->cnt2, status->seq,
-			status->unknown);
-		j++;
-		cnt--;
-		i--;
-		if (i < 0)
-			i = BCM43xx_NR_LOGGED_XMITSTATUS - 1;
+	mutex_lock(&big_buffer_mutex);
+	spin_lock_irqsave(&log->lock, flags);
+	if (!log->printing) {
+		log->printing = 1;
+		fappend("bcm43xx TX status reports:\n\n"
+			"index | cookie | seq | phy_stat | frame_count | "
+			"rts_count | supp_reason | pm_indicated | "
+			"intermediate | for_ampdu | acked\n"
+			"---\n");
+		i = log->end + 1;
+		idx = 0;
+		while (1) {
+			if (i == BCM43xx_NR_LOGGED_TXSTATUS)
+				i = 0;
+			stat = &(log->log[i]);
+			if (stat->cookie) {
+				fappend("%03d | "
+					"0x%04X | 0x%04X | 0x%02X | "
+					"0x%X | 0x%X | "
+					"%u | %u | "
+					"%u | %u | %u\n",
+					idx,
+					stat->cookie, stat->seq, stat->phy_stat,
+					stat->frame_count, stat->rts_count,
+					stat->supp_reason, stat->pm_indicated,
+					stat->intermediate, stat->for_ampdu,
+					stat->acked);
+				idx++;
+			}
+			if (i == log->end)
+				break;
+			i++;
+		}
+		log->buf_avail = pos;
 	}
+	memcpy(big_buffer, buf,
+	       min(log->buf_avail, ARRAY_SIZE(big_buffer)));
+	spin_unlock_irqrestore(&log->lock, flags);
+
+	res = simple_read_from_buffer(userbuf, count, ppos,
+				      big_buffer,
+				      log->buf_avail);
+	if (*ppos == log->buf_avail) {
+		spin_lock_irqsave(&log->lock, flags);
+		log->printing = 0;
+		spin_unlock_irqrestore(&log->lock, flags);
+	}
+	mutex_unlock(&big_buffer_mutex);
 
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (*ppos == pos) {
-		/* Done. Drop the copied data. */
-		e->xmitstatus_printing = 0;
-	}
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-	up(&big_buffer_sem);
 	return res;
 }
 
 static ssize_t restart_write_file(struct file *file, const char __user *user_buf,
 				  size_t count, loff_t *ppos)
 {
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
+	struct bcm43xx_wldev *dev = file->private_data;
+	char *buf = big_buffer;
 	ssize_t buf_size;
 	ssize_t res;
 	unsigned long flags;
 
-	buf_size = min(count, sizeof (really_big_buffer) - 1);
-	down(&big_buffer_sem);
+	mutex_lock(&big_buffer_mutex);
+	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
 	if (copy_from_user(buf, user_buf, buf_size)) {
 	        res = -EFAULT;
-		goto out_up;
+		goto out_unlock_bb;
 	}
-	mutex_lock(&(bcm)->mutex);
-	spin_lock_irqsave(&(bcm)->irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		printk(KERN_INFO PFX "debugfs: Board not initialized.\n");
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED) {
+		bcmerr(dev->wl, "debugfs: Board not initialized.\n");
 		res = -EFAULT;
 		goto out_unlock;
 	}
 	if (count > 0 && buf[0] == '1') {
-		bcm43xx_controller_restart(bcm, "manually restarted");
+		bcm43xx_controller_restart(dev, "manually restarted");
 		res = count;
-	} else
+	} else {
 		res = -EINVAL;
+	}
 
 out_unlock:
-	spin_unlock_irqrestore(&(bcm)->irq_lock, flags);
-	mutex_unlock(&(bcm)->mutex);
-out_up:
-	up(&big_buffer_sem);
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+out_unlock_bb:
+	mutex_unlock(&big_buffer_mutex);
+
 	return res;
 }
 
 #undef fappend
 
 
-static const struct file_operations devinfo_fops = {
-	.read = devinfo_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
-
-static const struct file_operations spromdump_fops = {
-	.read = spromdump_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
-
-static const struct file_operations drvinfo_fops = {
+static struct file_operations drvinfo_fops = {
 	.read = drvinfo_read_file,
 	.write = write_file_dummy,
 	.open = open_file_generic,
 };
 
-static const struct file_operations tsf_fops = {
+static struct file_operations tsf_fops = {
 	.read = tsf_read_file,
 	.write = tsf_write_file,
 	.open = open_file_generic,
 };
 
-static const struct file_operations txstat_fops = {
+static struct file_operations txstat_fops = {
 	.read = txstat_read_file,
 	.write = write_file_dummy,
 	.open = open_file_generic,
 };
 
-static const struct file_operations restart_fops = {
+static struct file_operations restart_fops = {
 	.write = restart_write_file,
 	.open = open_file_generic,
 };
 
 
-void bcm43xx_debugfs_add_device(struct bcm43xx_private *bcm)
+int bcm43xx_debug(struct bcm43xx_wldev *dev, enum bcm43xx_dyndbg feature)
+{
+	return !!(dev->dfsentry->dyn_debug[feature]);
+}
+
+static void bcm43xx_remove_dynamic_debug(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_dfsentry *e = dev->dfsentry;
+	int i;
+
+	for (i = 0; i < __BCM43xx_NR_DYNDBG; i++)
+		debugfs_remove(e->dyn_debug_dentries[i]);
+}
+
+static void bcm43xx_add_dynamic_debug(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_dfsentry *e = dev->dfsentry;
+	struct dentry *d;
+
+#define add_dyn_dbg(name, id, initstate) do {		\
+	e->dyn_debug[id] = (initstate);			\
+	d = debugfs_create_bool(name, 0600, e->subdir,	\
+				&(e->dyn_debug[id]));	\
+	if (!IS_ERR(d))					\
+		e->dyn_debug_dentries[id] = d;		\
+				} while (0)
+
+	add_dyn_dbg("debug_xmitpower", BCM43xx_DBG_XMITPOWER, 0);
+	add_dyn_dbg("debug_dmaoverflow", BCM43xx_DBG_DMAOVERFLOW, 0);
+	add_dyn_dbg("debug_dmaverbose", BCM43xx_DBG_DMAVERBOSE, 0);
+	add_dyn_dbg("debug_pwork_fast", BCM43xx_DBG_PWORK_FAST, 0);
+	add_dyn_dbg("debug_pwork_stop", BCM43xx_DBG_PWORK_STOP, 0);
+
+#undef add_dyn_dbg
+}
+
+void bcm43xx_debugfs_add_device(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_dfsentry *e;
-	char devdir[IFNAMSIZ];
+	struct bcm43xx_txstatus_log *log;
+	char devdir[16];
 
-	assert(bcm);
+	BCM43xx_BUG_ON(!dev);
 	e = kzalloc(sizeof(*e), GFP_KERNEL);
 	if (!e) {
-		printk(KERN_ERR PFX "out of memory\n");
+		bcmerr(dev->wl, "debugfs: add device OOM\n");
 		return;
 	}
-	e->bcm = bcm;
-	e->xmitstatus_buffer = kzalloc(BCM43xx_NR_LOGGED_XMITSTATUS
-				       * sizeof(*(e->xmitstatus_buffer)),
-				       GFP_KERNEL);
-	if (!e->xmitstatus_buffer) {
-		printk(KERN_ERR PFX "out of memory\n");
+	e->dev = dev;
+	log = &e->txstatlog;
+	log->log = kcalloc(BCM43xx_NR_LOGGED_TXSTATUS,
+			   sizeof(struct bcm43xx_txstatus),
+			   GFP_KERNEL);
+	if (!log->log) {
+		bcmerr(dev->wl, "debugfs: add device txstatus OOM\n");
 		kfree(e);
 		return;
 	}
-	e->xmitstatus_print_buffer = kzalloc(BCM43xx_NR_LOGGED_XMITSTATUS
-					     * sizeof(*(e->xmitstatus_buffer)),
-					     GFP_KERNEL);
-	if (!e->xmitstatus_print_buffer) {
-		printk(KERN_ERR PFX "out of memory\n");
+	log->end = -1;
+	spin_lock_init(&log->lock);
+
+	dev->dfsentry = e;
+
+	snprintf(devdir, sizeof(devdir), "%s", wiphy_name(dev->wl->hw->wiphy));
+	e->subdir = debugfs_create_dir(devdir, fs.root);
+	if (!e->subdir || IS_ERR(e->subdir)) {
+		e->subdir = NULL;
+		kfree(log->log);
 		kfree(e);
 		return;
 	}
 
+	e->dentry_tsf = debugfs_create_file("tsf", 0600, e->subdir,
+					     dev, &tsf_fops);
+	if (IS_ERR(e->dentry_tsf))
+		e->dentry_tsf = NULL;
+	e->dentry_txstat = debugfs_create_file("tx_status", 0400, e->subdir,
+						dev, &txstat_fops);
+	if (IS_ERR(e->dentry_txstat))
+		e->dentry_txstat = NULL;
+	e->dentry_restart = debugfs_create_file("restart", 0200, e->subdir,
+						dev, &restart_fops);
+	if (IS_ERR(e->dentry_restart))
+		e->dentry_restart = NULL;
 
-	bcm->dfsentry = e;
-
-	strncpy(devdir, bcm->net_dev->name, ARRAY_SIZE(devdir));
-	e->subdir = debugfs_create_dir(devdir, fs.root);
-	e->dentry_devinfo = debugfs_create_file("devinfo", 0444, e->subdir,
-						bcm, &devinfo_fops);
-	if (!e->dentry_devinfo)
-		printk(KERN_ERR PFX "debugfs: creating \"devinfo\" for \"%s\" failed!\n", devdir);
-	e->dentry_spromdump = debugfs_create_file("sprom_dump", 0444, e->subdir,
-						  bcm, &spromdump_fops);
-	if (!e->dentry_spromdump)
-		printk(KERN_ERR PFX "debugfs: creating \"sprom_dump\" for \"%s\" failed!\n", devdir);
-	e->dentry_tsf = debugfs_create_file("tsf", 0666, e->subdir,
-	                                    bcm, &tsf_fops);
-	if (!e->dentry_tsf)
-		printk(KERN_ERR PFX "debugfs: creating \"tsf\" for \"%s\" failed!\n", devdir);
-	e->dentry_txstat = debugfs_create_file("tx_status", 0444, e->subdir,
-						bcm, &txstat_fops);
-	if (!e->dentry_txstat)
-		printk(KERN_ERR PFX "debugfs: creating \"tx_status\" for \"%s\" failed!\n", devdir);
-	e->dentry_restart = debugfs_create_file("restart", 0222, e->subdir,
-						bcm, &restart_fops);
-	if (!e->dentry_restart)
-		printk(KERN_ERR PFX "debugfs: creating \"restart\" for \"%s\" failed!\n", devdir);
+	bcm43xx_add_dynamic_debug(dev);
 }
 
-void bcm43xx_debugfs_remove_device(struct bcm43xx_private *bcm)
+void bcm43xx_debugfs_remove_device(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_dfsentry *e;
 
-	if (!bcm)
+	if (!dev)
 		return;
 
-	e = bcm->dfsentry;
-	assert(e);
-	debugfs_remove(e->dentry_spromdump);
-	debugfs_remove(e->dentry_devinfo);
+	e = dev->dfsentry;
+	if (!e)
+		return;
+	bcm43xx_remove_dynamic_debug(dev);
 	debugfs_remove(e->dentry_tsf);
 	debugfs_remove(e->dentry_txstat);
 	debugfs_remove(e->dentry_restart);
 	debugfs_remove(e->subdir);
-	kfree(e->xmitstatus_buffer);
-	kfree(e->xmitstatus_print_buffer);
+	kfree(e->txstatlog.log);
 	kfree(e);
 }
 
-void bcm43xx_debugfs_log_txstat(struct bcm43xx_private *bcm,
-				struct bcm43xx_xmitstatus *status)
+void bcm43xx_debugfs_log_txstat(struct bcm43xx_wldev *dev,
+				const struct bcm43xx_txstatus *status)
 {
-	struct bcm43xx_dfsentry *e;
-	struct bcm43xx_xmitstatus *savedstatus;
+	struct bcm43xx_dfsentry *e = dev->dfsentry;
+	struct bcm43xx_txstatus_log *log;
+	struct bcm43xx_txstatus *cur;
+	int i;
 
-	/* This is protected by bcm->_lock */
-	e = bcm->dfsentry;
-	assert(e);
-	savedstatus = e->xmitstatus_buffer + e->xmitstatus_ptr;
-	memcpy(savedstatus, status, sizeof(*status));
-	e->xmitstatus_ptr++;
-	if (e->xmitstatus_ptr >= BCM43xx_NR_LOGGED_XMITSTATUS)
-		e->xmitstatus_ptr = 0;
-	if (e->xmitstatus_cnt < BCM43xx_NR_LOGGED_XMITSTATUS)
-		e->xmitstatus_cnt++;
+	log = &e->txstatlog;
+	BCM43xx_WARN_ON(!irqs_disabled());
+	spin_lock(&log->lock);
+	i = log->end + 1;
+	if (i == BCM43xx_NR_LOGGED_TXSTATUS)
+		i = 0;
+	log->end = i;
+	cur = &(log->log[i]);
+	memcpy(cur, status, sizeof(*cur));
+	spin_unlock(&log->lock);
 }
 
 void bcm43xx_debugfs_init(void)
 {
 	memset(&fs, 0, sizeof(fs));
 	fs.root = debugfs_create_dir(KBUILD_MODNAME, NULL);
-	if (!fs.root)
-		printk(KERN_ERR PFX "debugfs: creating \"" KBUILD_MODNAME "\" subdir failed!\n");
-	fs.dentry_driverinfo = debugfs_create_file("driver", 0444, fs.root, NULL, &drvinfo_fops);
-	if (!fs.dentry_driverinfo)
-		printk(KERN_ERR PFX "debugfs: creating \"" KBUILD_MODNAME "/driver\" failed!\n");
+	if (!fs.root || IS_ERR(fs.root)) {
+		fs.root = NULL;
+		return;
+	}
+	fs.dentry_driverinfo = debugfs_create_file("driver", 0444, fs.root,
+						   NULL, &drvinfo_fops);
+	if (IS_ERR(fs.dentry_driverinfo))
+		fs.dentry_driverinfo = NULL;
 }
 
 void bcm43xx_debugfs_exit(void)
@@ -501,56 +429,3 @@ void bcm43xx_debugfs_exit(void)
 	debugfs_remove(fs.dentry_driverinfo);
 	debugfs_remove(fs.root);
 }
-
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description)
-{
-	size_t i;
-	char c;
-
-	printk(KERN_INFO PFX "Data dump (%s, %zd bytes):",
-	       description, size);
-	for (i = 0; i < size; i++) {
-		c = data[i];
-		if (i % 8 == 0)
-			printk("\n" KERN_INFO PFX "0x%08zx:  0x%02x, ", i, c & 0xff);
-		else
-			printk("0x%02x, ", c & 0xff);
-	}
-	printk("\n");
-}
-
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description)
-{
-	size_t i;
-	int j;
-	const unsigned char *d;
-
-	printk(KERN_INFO PFX "*** Bitdump (%s, %zd bytes, %s) ***",
-	       description, bytes, msb_to_lsb ? "MSB to LSB" : "LSB to MSB");
-	for (i = 0; i < bytes; i++) {
-		d = data + i;
-		if (i % 8 == 0)
-			printk("\n" KERN_INFO PFX "0x%08zx:  ", i);
-		if (msb_to_lsb) {
-			for (j = 7; j >= 0; j--) {
-				if (*d & (1 << j))
-					printk("1");
-				else
-					printk("0");
-			}
-		} else {
-			for (j = 0; j < 8; j++) {
-				if (*d & (1 << j))
-					printk("1");
-				else
-					printk("0");
-			}
-		}
-		printk(" ");
-	}
-	printk("\n");
-}
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.h
@@ -1,41 +1,48 @@
 #ifndef BCM43xx_DEBUGFS_H_
 #define BCM43xx_DEBUGFS_H_
 
-struct bcm43xx_private;
-struct bcm43xx_xmitstatus;
+struct bcm43xx_wldev;
+struct bcm43xx_txstatus;
 
-#ifdef CONFIG_BCM43XX_DEBUG
+enum bcm43xx_dyndbg { /* Dynamic debugging features */
+	BCM43xx_DBG_XMITPOWER,
+	BCM43xx_DBG_DMAOVERFLOW,
+	BCM43xx_DBG_DMAVERBOSE,
+	BCM43xx_DBG_PWORK_FAST,
+	BCM43xx_DBG_PWORK_STOP,
+	__BCM43xx_NR_DYNDBG,
+};
 
-#include <linux/list.h>
-#include <asm/semaphore.h>
+
+#ifdef CONFIG_BCM43XX_DEBUG
 
 struct dentry;
 
-/* limited by the size of the "really_big_buffer" */
-#define BCM43xx_NR_LOGGED_XMITSTATUS	100
+#define BCM43xx_NR_LOGGED_TXSTATUS	100
+
+struct bcm43xx_txstatus_log {
+	struct bcm43xx_txstatus *log;
+	int end;
+	int printing;
+	char printbuf[(BCM43xx_NR_LOGGED_TXSTATUS * 70) + 200];
+	size_t buf_avail;
+	spinlock_t lock;	/* lock for debugging */
+};
 
 struct bcm43xx_dfsentry {
 	struct dentry *subdir;
-	struct dentry *dentry_devinfo;
-	struct dentry *dentry_spromdump;
 	struct dentry *dentry_tsf;
 	struct dentry *dentry_txstat;
 	struct dentry *dentry_restart;
 
-	struct bcm43xx_private *bcm;
+	struct bcm43xx_wldev *dev;
+
+	struct bcm43xx_txstatus_log txstatlog;
 
-	/* saved xmitstatus. */
-	struct bcm43xx_xmitstatus *xmitstatus_buffer;
-	int xmitstatus_ptr;
-	int xmitstatus_cnt;
-	/* We need a seperate buffer while printing to avoid
-	 * concurrency issues. (New xmitstatus can arrive
-	 * while we are printing).
-	 */
-	struct bcm43xx_xmitstatus *xmitstatus_print_buffer;
-	int saved_xmitstatus_ptr;
-	int saved_xmitstatus_cnt;
-	int xmitstatus_printing;
+	/* Enabled/Disabled list for the dynamic debugging features. */
+	u32 dyn_debug[__BCM43xx_NR_DYNDBG];
+	/* Dentries for the dynamic debugging entries. */
+	struct dentry *dyn_debug_dentries[__BCM43xx_NR_DYNDBG];
 };
 
 struct bcm43xx_debugfs {
@@ -43,76 +50,35 @@ struct bcm43xx_debugfs {
 	struct dentry *dentry_driverinfo;
 };
 
+int bcm43xx_debug(struct bcm43xx_wldev *dev, enum bcm43xx_dyndbg feature);
+
 void bcm43xx_debugfs_init(void);
 void bcm43xx_debugfs_exit(void);
-void bcm43xx_debugfs_add_device(struct bcm43xx_private *bcm);
-void bcm43xx_debugfs_remove_device(struct bcm43xx_private *bcm);
-void bcm43xx_debugfs_log_txstat(struct bcm43xx_private *bcm,
-				struct bcm43xx_xmitstatus *status);
-
-/* Debug helper: Dump binary data through printk. */
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description);
-/* Debug helper: Dump bitwise binary data through printk. */
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description);
-#define bcm43xx_printk_bitdumpt(pointer, msb_to_lsb, description) \
-	do {									\
-		bcm43xx_printk_bitdump((const unsigned char *)(pointer),	\
-				       sizeof(*(pointer)),			\
-				       (msb_to_lsb),				\
-				       (description));				\
-	} while (0)
+void bcm43xx_debugfs_add_device(struct bcm43xx_wldev *dev);
+void bcm43xx_debugfs_remove_device(struct bcm43xx_wldev *dev);
+void bcm43xx_debugfs_log_txstat(struct bcm43xx_wldev *dev,
+				const struct bcm43xx_txstatus *status);
 
 #else /* CONFIG_BCM43XX_DEBUG*/
 
 static inline
+int bcm43xx_debug(struct bcm43xx_wldev *dev, enum bcm43xx_dyndbg feature)
+{
+	return 0;
+}
+
+static inline
 void bcm43xx_debugfs_init(void) { }
 static inline
 void bcm43xx_debugfs_exit(void) { }
 static inline
-void bcm43xx_debugfs_add_device(struct bcm43xx_private *bcm) { }
-static inline
-void bcm43xx_debugfs_remove_device(struct bcm43xx_private *bcm) { }
-static inline
-void bcm43xx_debugfs_log_txstat(struct bcm43xx_private *bcm,
-				struct bcm43xx_xmitstatus *status) { }
-
+void bcm43xx_debugfs_add_device(struct bcm43xx_wldev *dev) { }
 static inline
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description)
-{
-}
+void bcm43xx_debugfs_remove_device(struct bcm43xx_wldev *dev) { }
 static inline
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description)
-{
-}
-#define bcm43xx_printk_bitdumpt(pointer, msb_to_lsb, description)  do { /* nothing */ } while (0)
+void bcm43xx_debugfs_log_txstat(struct bcm43xx_wldev *dev,
+				const struct bcm43xx_txstatus *status) { }
 
 #endif /* CONFIG_BCM43XX_DEBUG*/
 
-/* Ugly helper macros to make incomplete code more verbose on runtime */
-#ifdef TODO
-# undef TODO
-#endif
-#define TODO()  \
-	do {										\
-		printk(KERN_INFO PFX "TODO: Incomplete code in %s() at %s:%d\n",	\
-		       __FUNCTION__, __FILE__, __LINE__);				\
-	} while (0)
-
-#ifdef FIXME
-# undef FIXME
-#endif
-#define FIXME()  \
-	do {										\
-		printk(KERN_INFO PFX "FIXME: Possibly broken code in %s() at %s:%d\n",	\
-		       __FUNCTION__, __FILE__, __LINE__);				\
-	} while (0)
-
 #endif /* BCM43xx_DEBUGFS_H_ */



From Larry.Finger at lwfinger.net  Thu Aug  2 17:53:30 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:53:30 -0500
Subject: [RFC 4/10] Port of bcm43xx from softmac to mac80211
Message-ID: <46b1fdfa.b23/SBAsflcopXZo%Larry.Finger@lwfinger.net>

This if file 4 of 10 of the port of the bcm43xx driver from softmac
to mac80211.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ilt.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_ilt.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ilt.c
@@ -312,41 +312,24 @@ const u16 bcm43xx_ilt_sigmasqr2[BCM43xx_
 
 /**** Helper functions to access the device Internal Lookup Tables ****/
 
-void bcm43xx_ilt_write(struct bcm43xx_private *bcm, u16 offset, u16 val)
+void bcm43xx_ilt_write(struct bcm43xx_wldev *dev, u16 offset, u16 val)
 {
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, val);
-	} else {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_DATA1, val);
-	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_ILT_G_CTRL, offset);
+	mmiowb();
+	bcm43xx_phy_write(dev, BCM43xx_PHY_ILT_G_DATA1, val);
 }
 
-void bcm43xx_ilt_write32(struct bcm43xx_private *bcm, u16 offset, u32 val)
+void bcm43xx_ilt_write32(struct bcm43xx_wldev *dev, u16 offset, u32 val)
 {
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA2, (val & 0xFFFF0000) >> 16);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, val & 0x0000FFFF);
-	} else {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_DATA2, (val & 0xFFFF0000) >> 16);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_DATA1, val & 0x0000FFFF);
-	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_ILT_G_CTRL, offset);
+	mmiowb();
+	bcm43xx_phy_write(dev, BCM43xx_PHY_ILT_G_DATA2, (val & 0xFFFF0000) >>
+			  16);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_ILT_G_DATA1, val & 0x0000FFFF);
 }
 
-u16 bcm43xx_ilt_read(struct bcm43xx_private *bcm, u16 offset)
+u16 bcm43xx_ilt_read(struct bcm43xx_wldev *dev, u16 offset)
 {
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, offset);
-		return bcm43xx_phy_read(bcm, BCM43xx_PHY_ILT_A_DATA1);
-	} else {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_CTRL, offset);
-		return bcm43xx_phy_read(bcm, BCM43xx_PHY_ILT_G_DATA1);
-	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_ILT_G_CTRL, offset);
+	return bcm43xx_phy_read(dev, BCM43xx_PHY_ILT_G_DATA1);
 }
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ilt.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_ilt.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ilt.h
@@ -26,8 +26,8 @@ extern const u16 bcm43xx_ilt_sigmasqr1[B
 extern const u16 bcm43xx_ilt_sigmasqr2[BCM43xx_ILT_SIGMASQR_SIZE];
 
 
-void bcm43xx_ilt_write(struct bcm43xx_private *bcm, u16 offset, u16 val);
-void bcm43xx_ilt_write32(struct bcm43xx_private *bcm, u16 offset, u32 val);
-u16 bcm43xx_ilt_read(struct bcm43xx_private *bcm, u16 offset);
+void bcm43xx_ilt_write(struct bcm43xx_wldev *dev, u16 offset, u16 val);
+void bcm43xx_ilt_write32(struct bcm43xx_wldev *dev, u16 offset, u32 val);
+u16 bcm43xx_ilt_read(struct bcm43xx_wldev *dev, u16 offset);
 
 #endif /* BCM43xx_ILT_H_ */
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_leds.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_leds.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_leds.c
@@ -3,10 +3,11 @@
   Broadcom BCM43xx wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
+		     Stefano Brivio <st3 at riseup.net>
+		     Michael Buesch <mb at bu3sch.de>
+		     Danny van Dyk <kugelfang at gentoo.org>
+		     Andreas Jaggi <andreas.jaggi at waterwave.ch>
+  Copyright (c) 2007 Larry Finger <Larry.Finger at lwfinger.net>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -26,38 +27,35 @@
 */
 
 #include "bcm43xx_leds.h"
-#include "bcm43xx_radio.h"
 #include "bcm43xx.h"
-
-#include <asm/bitops.h>
-
+#include "bcm43xx_main.h"
 
 static void bcm43xx_led_changestate(struct bcm43xx_led *led)
 {
-	struct bcm43xx_private *bcm = led->bcm;
+	struct bcm43xx_wldev *dev = led->dev;
 	const int index = bcm43xx_led_index(led);
 	const u16 mask = (1 << index);
 	u16 ledctl;
 
-	assert(index >= 0 && index < BCM43xx_NR_LEDS);
-	assert(led->blink_interval);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
+	BCM43xx_WARN_ON(!(index >= 0 && index < BCM43xx_NR_LEDS));
+	BCM43xx_WARN_ON(!led->blink_interval);
+	ledctl = bcm43xx_read16(dev, BCM43xx_MMIO_GPIO_CONTROL);
 	ledctl = (ledctl & mask) ? (ledctl & ~mask) : (ledctl | mask);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
+	bcm43xx_write16(dev, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
 }
 
 static void bcm43xx_led_blink(unsigned long d)
 {
 	struct bcm43xx_led *led = (struct bcm43xx_led *)d;
-	struct bcm43xx_private *bcm = led->bcm;
+	struct bcm43xx_wldev *dev = led->dev;
 	unsigned long flags;
 
-	spin_lock_irqsave(&bcm->leds_lock, flags);
+	spin_lock_irqsave(&dev->wl->leds_lock, flags);
 	if (led->blink_interval) {
 		bcm43xx_led_changestate(led);
 		mod_timer(&led->blink_timer, jiffies + led->blink_interval);
 	}
-	spin_unlock_irqrestore(&bcm->leds_lock, flags);
+	spin_unlock_irqrestore(&dev->wl->leds_lock, flags);
 }
 
 static void bcm43xx_led_blink_start(struct bcm43xx_led *led,
@@ -73,7 +71,7 @@ static void bcm43xx_led_blink_start(stru
 
 static void bcm43xx_led_blink_stop(struct bcm43xx_led *led, int sync)
 {
-	struct bcm43xx_private *bcm = led->bcm;
+	struct bcm43xx_wldev *dev = led->dev;
 	const int index = bcm43xx_led_index(led);
 	u16 ledctl;
 
@@ -86,19 +84,21 @@ static void bcm43xx_led_blink_stop(struc
 	led->blink_interval = 0;
 
 	/* Make sure the LED is turned off. */
-	assert(index >= 0 && index < BCM43xx_NR_LEDS);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
+	BCM43xx_WARN_ON(!(index >= 0 && index < BCM43xx_NR_LEDS));
+	ledctl = bcm43xx_read16(dev, BCM43xx_MMIO_GPIO_CONTROL);
 	if (led->activelow)
 		ledctl |= (1 << index);
 	else
 		ledctl &= ~(1 << index);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
+	bcm43xx_write16(dev, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
 }
 
-static void bcm43xx_led_init_hardcoded(struct bcm43xx_private *bcm,
+static void bcm43xx_led_init_hardcoded(struct bcm43xx_wldev *dev,
 				       struct bcm43xx_led *led,
 				       int led_index)
 {
+	struct ssb_bus *bus = dev->dev->bus;
+
 	/* This function is called, if the behaviour (and activelow)
 	 * information for a LED is missing in the SPROM.
 	 * We hardcode the behaviour values for various devices here.
@@ -110,12 +110,12 @@ static void bcm43xx_led_init_hardcoded(s
 	case 0:
 		led->behaviour = BCM43xx_LED_ACTIVITY;
 		led->activelow = 1;
-		if (bcm->board_vendor == PCI_VENDOR_ID_COMPAQ)
+		if (bus->boardinfo.vendor == PCI_VENDOR_ID_COMPAQ)
 			led->behaviour = BCM43xx_LED_RADIO_ALL;
 		break;
 	case 1:
 		led->behaviour = BCM43xx_LED_RADIO_B;
-		if (bcm->board_vendor == PCI_VENDOR_ID_ASUSTEK)
+		if (bus->boardinfo.vendor == PCI_VENDOR_ID_ASUSTEK)
 			led->behaviour = BCM43xx_LED_ASSOC;
 		break;
 	case 2:
@@ -125,30 +125,30 @@ static void bcm43xx_led_init_hardcoded(s
 		led->behaviour = BCM43xx_LED_OFF;
 		break;
 	default:
-		assert(0);
+		BCM43xx_BUG_ON(1);
 	}
 }
 
-int bcm43xx_leds_init(struct bcm43xx_private *bcm)
+int bcm43xx_leds_init(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_led *led;
 	u8 sprom[4];
 	int i;
 
-	sprom[0] = bcm->sprom.wl0gpio0;
-	sprom[1] = bcm->sprom.wl0gpio1;
-	sprom[2] = bcm->sprom.wl0gpio2;
-	sprom[3] = bcm->sprom.wl0gpio3;
+	sprom[0] = dev->dev->bus->sprom.r1.gpio0;
+	sprom[1] = dev->dev->bus->sprom.r1.gpio1;
+	sprom[2] = dev->dev->bus->sprom.r1.gpio2;
+	sprom[3] = dev->dev->bus->sprom.r1.gpio3;
 
 	for (i = 0; i < BCM43xx_NR_LEDS; i++) {
-		led = &(bcm->leds[i]);
-		led->bcm = bcm;
+		led = &(dev->leds[i]);
+		led->dev = dev;
 		setup_timer(&led->blink_timer,
 			    bcm43xx_led_blink,
 			    (unsigned long)led);
 
 		if (sprom[i] == 0xFF) {
-			bcm43xx_led_init_hardcoded(bcm, led, i);
+			bcm43xx_led_init_hardcoded(dev, led, i);
 		} else {
 			led->behaviour = sprom[i] & BCM43xx_LED_BEHAVIOUR;
 			led->activelow = !!(sprom[i] & BCM43xx_LED_ACTIVELOW);
@@ -158,84 +158,79 @@ int bcm43xx_leds_init(struct bcm43xx_pri
 	return 0;
 }
 
-void bcm43xx_leds_exit(struct bcm43xx_private *bcm)
+void bcm43xx_leds_exit(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_led *led;
 	int i;
 
 	for (i = 0; i < BCM43xx_NR_LEDS; i++) {
-		led = &(bcm->leds[i]);
+		led = &(dev->leds[i]);
 		bcm43xx_led_blink_stop(led, 1);
 	}
-	bcm43xx_leds_switch_all(bcm, 0);
+	bcm43xx_leds_switch_all(dev, 0);
 }
 
-void bcm43xx_leds_update(struct bcm43xx_private *bcm, int activity)
+void bcm43xx_leds_update(struct bcm43xx_wldev *dev, int activity)
 {
 	struct bcm43xx_led *led;
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	const int transferring = (jiffies - bcm->stats.last_tx) < BCM43xx_LED_XFER_THRES;
+	struct bcm43xx_phy *phy = &dev->phy;
+	const int transferring = (jiffies - dev->stats.last_tx)
+				  < BCM43xx_LED_XFER_THRES;
 	int i, turn_on;
 	unsigned long interval = 0;
 	u16 ledctl;
 	unsigned long flags;
 
-	spin_lock_irqsave(&bcm->leds_lock, flags);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
+	spin_lock_irqsave(&dev->wl->leds_lock, flags);
+	ledctl = bcm43xx_read16(dev, BCM43xx_MMIO_GPIO_CONTROL);
 	for (i = 0; i < BCM43xx_NR_LEDS; i++) {
-		led = &(bcm->leds[i]);
+		led = &(dev->leds[i]);
 
 		turn_on = 0;
 		switch (led->behaviour) {
 		case BCM43xx_LED_INACTIVE:
 			continue;
 		case BCM43xx_LED_OFF:
-		case BCM43xx_LED_BCM4303_3:
 			break;
 		case BCM43xx_LED_ON:
 			turn_on = 1;
 			break;
 		case BCM43xx_LED_ACTIVITY:
-		case BCM43xx_LED_BCM4303_0:
 			turn_on = activity;
 			break;
 		case BCM43xx_LED_RADIO_ALL:
-			turn_on = radio->enabled && bcm43xx_is_hw_radio_enabled(bcm);
+			turn_on = phy->radio_on &&
+				  bcm43xx_is_hw_radio_enabled(dev);
 			break;
 		case BCM43xx_LED_RADIO_A:
-		case BCM43xx_LED_BCM4303_2:
-			turn_on = (radio->enabled && bcm43xx_is_hw_radio_enabled(bcm) &&
-				   phy->type == BCM43xx_PHYTYPE_A);
 			break;
 		case BCM43xx_LED_RADIO_B:
-		case BCM43xx_LED_BCM4303_1:
-			turn_on = (radio->enabled && bcm43xx_is_hw_radio_enabled(bcm) &&
+			turn_on = (phy->radio_on &&
+				   bcm43xx_is_hw_radio_enabled(dev) &&
 				   (phy->type == BCM43xx_PHYTYPE_B ||
 				    phy->type == BCM43xx_PHYTYPE_G));
 			break;
 		case BCM43xx_LED_MODE_BG:
-			if (phy->type == BCM43xx_PHYTYPE_G && bcm43xx_is_hw_radio_enabled(bcm) &&
-			    1/*FIXME: using G rates.*/)
+			if (phy->type == BCM43xx_PHYTYPE_G &&
+			    bcm43xx_is_hw_radio_enabled(dev))
 				turn_on = 1;
 			break;
 		case BCM43xx_LED_TRANSFER:
 			if (transferring)
-				bcm43xx_led_blink_start(led, BCM43xx_LEDBLINK_MEDIUM);
+				bcm43xx_led_blink_start(led,
+						BCM43xx_LEDBLINK_MEDIUM);
 			else
 				bcm43xx_led_blink_stop(led, 0);
 			continue;
 		case BCM43xx_LED_APTRANSFER:
-			if (bcm->ieee->iw_mode == IW_MODE_MASTER) {
+			if (bcm43xx_is_mode(dev->wl, IEEE80211_IF_TYPE_AP)) {
 				if (transferring) {
 					interval = BCM43xx_LEDBLINK_FAST;
 					turn_on = 1;
 				}
 			} else {
 				turn_on = 1;
-				if (0/*TODO: not assoc*/)
-					interval = BCM43xx_LEDBLINK_SLOW;
-				else if (transferring)
+				if (transferring)
 					interval = BCM43xx_LEDBLINK_FAST;
 				else
 					turn_on = 0;
@@ -246,12 +241,9 @@ void bcm43xx_leds_update(struct bcm43xx_
 				bcm43xx_led_blink_stop(led, 0);
 			continue;
 		case BCM43xx_LED_WEIRD:
-			//TODO
 			break;
 		case BCM43xx_LED_ASSOC:
-			if (bcm->softmac->associnfo.associated)
-				turn_on = 1;
-			break;
+			turn_on = 1;
 #ifdef CONFIG_BCM43XX_DEBUG
 		case BCM43xx_LED_TEST_BLINKSLOW:
 			bcm43xx_led_blink_start(led, BCM43xx_LEDBLINK_SLOW);
@@ -264,8 +256,7 @@ void bcm43xx_leds_update(struct bcm43xx_
 			continue;
 #endif /* CONFIG_BCM43XX_DEBUG */
 		default:
-			dprintkl(KERN_INFO PFX "Bad value in leds_update,"
-				" led->behaviour: 0x%x\n", led->behaviour);
+			BCM43xx_BUG_ON(1);
 		};
 
 		if (led->activelow)
@@ -275,11 +266,11 @@ void bcm43xx_leds_update(struct bcm43xx_
 		else
 			ledctl &= ~(1 << i);
 	}
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
-	spin_unlock_irqrestore(&bcm->leds_lock, flags);
+	bcm43xx_write16(dev, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
+	spin_unlock_irqrestore(&dev->wl->leds_lock, flags);
 }
 
-void bcm43xx_leds_switch_all(struct bcm43xx_private *bcm, int on)
+void bcm43xx_leds_switch_all(struct bcm43xx_wldev *dev, int on)
 {
 	struct bcm43xx_led *led;
 	u16 ledctl;
@@ -287,10 +278,10 @@ void bcm43xx_leds_switch_all(struct bcm4
 	int bit_on;
 	unsigned long flags;
 
-	spin_lock_irqsave(&bcm->leds_lock, flags);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
+	spin_lock_irqsave(&dev->wl->leds_lock, flags);
+	ledctl = bcm43xx_read16(dev, BCM43xx_MMIO_GPIO_CONTROL);
 	for (i = 0; i < BCM43xx_NR_LEDS; i++) {
-		led = &(bcm->leds[i]);
+		led = &(dev->leds[i]);
 		if (led->behaviour == BCM43xx_LED_INACTIVE)
 			continue;
 		if (on)
@@ -302,6 +293,6 @@ void bcm43xx_leds_switch_all(struct bcm4
 		else
 			ledctl &= ~(1 << i);
 	}
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
-	spin_unlock_irqrestore(&bcm->leds_lock, flags);
+	bcm43xx_write16(dev, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
+	spin_unlock_irqrestore(&dev->wl->leds_lock, flags);
 }
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_leds.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_leds.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_leds.h
@@ -9,11 +9,11 @@ struct bcm43xx_led {
 	u8 behaviour:7;
 	u8 activelow:1;
 
-	struct bcm43xx_private *bcm;
+	struct bcm43xx_wldev *dev;
 	struct timer_list blink_timer;
 	unsigned long blink_interval;
 };
-#define bcm43xx_led_index(led)	((int)((led) - (led)->bcm->leds))
+#define bcm43xx_led_index(led)	((int)((led) - (led)->dev->leds))
 
 /* Delay between state changes when blinking in jiffies */
 #define BCM43xx_LEDBLINK_SLOW		(HZ / 1)
@@ -34,7 +34,7 @@ enum { /* LED behaviour values */
 	BCM43xx_LED_MODE_BG,
 	BCM43xx_LED_TRANSFER,
 	BCM43xx_LED_APTRANSFER,
-	BCM43xx_LED_WEIRD,//FIXME
+	BCM43xx_LED_WEIRD,
 	BCM43xx_LED_ASSOC,
 	BCM43xx_LED_INACTIVE,
 
@@ -46,17 +46,11 @@ enum { /* LED behaviour values */
 	BCM43xx_LED_TEST_BLINKSLOW,
 	BCM43xx_LED_TEST_BLINKMEDIUM,
 	BCM43xx_LED_TEST_BLINKFAST,
-
-	/* Misc values for BCM4303 */
-	BCM43xx_LED_BCM4303_0 = 0x2B,
-	BCM43xx_LED_BCM4303_1 = 0x78,
-	BCM43xx_LED_BCM4303_2 = 0x2E,
-	BCM43xx_LED_BCM4303_3 = 0x19,
 };
 
-int bcm43xx_leds_init(struct bcm43xx_private *bcm);
-void bcm43xx_leds_exit(struct bcm43xx_private *bcm);
-void bcm43xx_leds_update(struct bcm43xx_private *bcm, int activity);
-void bcm43xx_leds_switch_all(struct bcm43xx_private *bcm, int on);
+int bcm43xx_leds_init(struct bcm43xx_wldev *dev);
+void bcm43xx_leds_exit(struct bcm43xx_wldev *dev);
+void bcm43xx_leds_update(struct bcm43xx_wldev *dev, int activity);
+void bcm43xx_leds_switch_all(struct bcm43xx_wldev *dev, int on);
 
 #endif /* BCM43xx_LEDS_H_ */



From Larry.Finger at lwfinger.net  Thu Aug  2 17:53:23 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:53:23 -0500
Subject: [RFC 3/10] Port of bcm43xx from softmac to mac80211
Message-ID: <46b1fdf3.3PHik8B2qcQ78kAQ%Larry.Finger@lwfinger.net>

This if file 3 of 10 of the port of the bcm43xx driver from softmac
to mac80211.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_dma.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_dma.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_dma.c
@@ -4,7 +4,7 @@
 
   DMA ringbuffer and descriptor allocation/management
 
-  Copyright (c) 2005, 2006 Michael Buesch <mbuesch at freenet.de>
+  Copyright (c) 2005, 2006 Michael Buesch <mb at bu3sch.de>
 
   Some code in this file is derived from the b44.c driver
   Copyright (C) 2002 David S. Miller
@@ -31,13 +31,213 @@
 #include "bcm43xx_dma.h"
 #include "bcm43xx_main.h"
 #include "bcm43xx_debugfs.h"
-#include "bcm43xx_power.h"
 #include "bcm43xx_xmit.h"
 
 #include <linux/dma-mapping.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/skbuff.h>
+#include <net/dst.h>
+
+/* 32bit DMA ops. */
+static
+struct bcm43xx_dmadesc_generic *op32_idx2desc(struct bcm43xx_dmaring *ring,
+					     int slot,
+					     struct bcm43xx_dmadesc_meta **meta)
+{
+	struct bcm43xx_dmadesc32 *desc;
+
+	*meta = &(ring->meta[slot]);
+	desc = ring->descbase;
+	desc = &(desc[slot]);
+
+	return (struct bcm43xx_dmadesc_generic *)desc;
+}
+
+static void op32_fill_descriptor(struct bcm43xx_dmaring *ring,
+				 struct bcm43xx_dmadesc_generic *desc,
+				 dma_addr_t dmaaddr, u16 bufsize,
+				 int start, int end, int irq)
+{
+	struct bcm43xx_dmadesc32 *descbase = ring->descbase;
+	int slot;
+	u32 ctl;
+	u32 addr;
+	u32 addrext;
+
+	slot = (int)(&(desc->dma32) - descbase);
+	BCM43xx_WARN_ON(!(slot >= 0 && slot < ring->nr_slots));
+
+	addr = (u32)(dmaaddr & ~SSB_DMA_TRANSLATION_MASK);
+	addrext = (u32)(dmaaddr & SSB_DMA_TRANSLATION_MASK)
+		   >> SSB_DMA_TRANSLATION_SHIFT;
+	addr |= ssb_dma_translation(ring->dev->dev);
+	ctl = (bufsize - ring->frameoffset)
+	      & BCM43xx_DMA32_DCTL_BYTECNT;
+	if (slot == ring->nr_slots - 1)
+		ctl |= BCM43xx_DMA32_DCTL_DTABLEEND;
+	if (start)
+		ctl |= BCM43xx_DMA32_DCTL_FRAMESTART;
+	if (end)
+		ctl |= BCM43xx_DMA32_DCTL_FRAMEEND;
+	if (irq)
+		ctl |= BCM43xx_DMA32_DCTL_IRQ;
+	ctl |= (addrext << BCM43xx_DMA32_DCTL_ADDREXT_SHIFT)
+	       & BCM43xx_DMA32_DCTL_ADDREXT_MASK;
+
+	desc->dma32.control = cpu_to_le32(ctl);
+	desc->dma32.address = cpu_to_le32(addr);
+}
+
+static void op32_poke_tx(struct bcm43xx_dmaring *ring, int slot)
+{
+	bcm43xx_dma_write(ring, BCM43xx_DMA32_TXINDEX,
+			  (u32)(slot * sizeof(struct bcm43xx_dmadesc32)));
+}
+
+static void op32_tx_suspend(struct bcm43xx_dmaring *ring)
+{
+	bcm43xx_dma_write(ring, BCM43xx_DMA32_TXCTL,
+			  bcm43xx_dma_read(ring, BCM43xx_DMA32_TXCTL)
+			  | BCM43xx_DMA32_TXSUSPEND);
+}
+
+static void op32_tx_resume(struct bcm43xx_dmaring *ring)
+{
+	bcm43xx_dma_write(ring, BCM43xx_DMA32_TXCTL,
+			  bcm43xx_dma_read(ring, BCM43xx_DMA32_TXCTL)
+			  & ~BCM43xx_DMA32_TXSUSPEND);
+}
+
+static int op32_get_current_rxslot(struct bcm43xx_dmaring *ring)
+{
+	u32 val;
+
+	val = bcm43xx_dma_read(ring, BCM43xx_DMA32_RXSTATUS);
+	val &= BCM43xx_DMA32_RXDPTR;
+
+	return (val / sizeof(struct bcm43xx_dmadesc32));
+}
+
+static void op32_set_current_rxslot(struct bcm43xx_dmaring *ring,
+				    int slot)
+{
+	bcm43xx_dma_write(ring, BCM43xx_DMA32_RXINDEX,
+			  (u32)(slot * sizeof(struct bcm43xx_dmadesc32)));
+}
+
+static const struct bcm43xx_dma_ops dma32_ops = {
+	.idx2desc		= op32_idx2desc,
+	.fill_descriptor	= op32_fill_descriptor,
+	.poke_tx		= op32_poke_tx,
+	.tx_suspend		= op32_tx_suspend,
+	.tx_resume		= op32_tx_resume,
+	.get_current_rxslot	= op32_get_current_rxslot,
+	.set_current_rxslot	= op32_set_current_rxslot,
+};
+
+/* 64bit DMA ops. */
+static
+struct bcm43xx_dmadesc_generic *op64_idx2desc(struct bcm43xx_dmaring *ring,
+					       int slot,
+					       struct bcm43xx_dmadesc_meta
+					       **meta)
+{
+	struct bcm43xx_dmadesc64 *desc;
+
+	*meta = &(ring->meta[slot]);
+	desc = ring->descbase;
+	desc = &(desc[slot]);
+
+	return (struct bcm43xx_dmadesc_generic *)desc;
+}
+
+static void op64_fill_descriptor(struct bcm43xx_dmaring *ring,
+				 struct bcm43xx_dmadesc_generic *desc,
+				 dma_addr_t dmaaddr, u16 bufsize,
+				 int start, int end, int irq)
+{
+	struct bcm43xx_dmadesc64 *descbase = ring->descbase;
+	int slot;
+	u32 ctl0 = 0i;
+	u32 ctl1 = 0;
+	u32 addrlo;
+	u32 addrhi;
+	u32 addrext;
+
+	slot = (int)(&(desc->dma64) - descbase);
+	BCM43xx_WARN_ON(!(slot >= 0 && slot < ring->nr_slots));
+
+	addrlo = (u32)(dmaaddr & 0xFFFFFFFF);
+	addrhi = (((u64)dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
+	addrext = (((u64)dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
+		  >> SSB_DMA_TRANSLATION_SHIFT;
+	addrhi |= ssb_dma_translation(ring->dev->dev);
+	if (slot == ring->nr_slots - 1)
+		ctl0 |= BCM43xx_DMA64_DCTL0_DTABLEEND;
+	if (start)
+		ctl0 |= BCM43xx_DMA64_DCTL0_FRAMESTART;
+	if (end)
+		ctl0 |= BCM43xx_DMA64_DCTL0_FRAMEEND;
+	if (irq)
+		ctl0 |= BCM43xx_DMA64_DCTL0_IRQ;
+	ctl1 |= (bufsize - ring->frameoffset)
+		& BCM43xx_DMA64_DCTL1_BYTECNT;
+	ctl1 |= (addrext << BCM43xx_DMA64_DCTL1_ADDREXT_SHIFT)
+		& BCM43xx_DMA64_DCTL1_ADDREXT_MASK;
+
+	desc->dma64.control0 = cpu_to_le32(ctl0);
+	desc->dma64.control1 = cpu_to_le32(ctl1);
+	desc->dma64.address_low = cpu_to_le32(addrlo);
+	desc->dma64.address_high = cpu_to_le32(addrhi);
+}
+
+static void op64_poke_tx(struct bcm43xx_dmaring *ring, int slot)
+{
+	bcm43xx_dma_write(ring, BCM43xx_DMA64_TXINDEX,
+			  (u32)(slot * sizeof(struct bcm43xx_dmadesc64)));
+}
+
+static void op64_tx_suspend(struct bcm43xx_dmaring *ring)
+{
+	bcm43xx_dma_write(ring, BCM43xx_DMA64_TXCTL,
+			  bcm43xx_dma_read(ring, BCM43xx_DMA64_TXCTL)
+			  | BCM43xx_DMA64_TXSUSPEND);
+}
+
+static void op64_tx_resume(struct bcm43xx_dmaring *ring)
+{
+	bcm43xx_dma_write(ring, BCM43xx_DMA64_TXCTL,
+			  bcm43xx_dma_read(ring, BCM43xx_DMA64_TXCTL)
+			  & ~BCM43xx_DMA64_TXSUSPEND);
+}
+
+static int op64_get_current_rxslot(struct bcm43xx_dmaring *ring)
+{
+	u32 val;
+
+	val = bcm43xx_dma_read(ring, BCM43xx_DMA64_RXSTATUS);
+	val &= BCM43xx_DMA64_RXSTATDPTR;
+
+	return (val / sizeof(struct bcm43xx_dmadesc64));
+}
+
+static void op64_set_current_rxslot(struct bcm43xx_dmaring *ring,
+				    int slot)
+{
+	bcm43xx_dma_write(ring, BCM43xx_DMA64_RXINDEX,
+			  (u32)(slot * sizeof(struct bcm43xx_dmadesc64)));
+}
+
+static const struct bcm43xx_dma_ops dma64_ops = {
+	.idx2desc		= op64_idx2desc,
+	.fill_descriptor	= op64_fill_descriptor,
+	.poke_tx		= op64_poke_tx,
+	.tx_suspend		= op64_tx_suspend,
+	.tx_resume		= op64_tx_resume,
+	.get_current_rxslot	= op64_get_current_rxslot,
+	.set_current_rxslot	= op64_set_current_rxslot,
+};
 
 
 static inline int free_slots(struct bcm43xx_dmaring *ring)
@@ -47,7 +247,7 @@ static inline int free_slots(struct bcm4
 
 static inline int next_slot(struct bcm43xx_dmaring *ring, int slot)
 {
-	assert(slot >= -1 && slot <= ring->nr_slots - 1);
+	BCM43xx_WARN_ON(!(slot >= -1 && slot <= ring->nr_slots - 1));
 	if (slot == ring->nr_slots - 1)
 		return 0;
 	return slot + 1;
@@ -55,60 +255,102 @@ static inline int next_slot(struct bcm43
 
 static inline int prev_slot(struct bcm43xx_dmaring *ring, int slot)
 {
-	assert(slot >= 0 && slot <= ring->nr_slots - 1);
+	BCM43xx_WARN_ON(!(slot >= 0 && slot <= ring->nr_slots - 1));
 	if (slot == 0)
 		return ring->nr_slots - 1;
 	return slot - 1;
 }
 
+#ifdef CONFIG_BCM43XX_DEBUG
+static void update_max_used_slots(struct bcm43xx_dmaring *ring,
+				  int current_used_slots)
+{
+	if (current_used_slots <= ring->max_used_slots)
+		return;
+	ring->max_used_slots = current_used_slots;
+	if (bcm43xx_debug(ring->dev, BCM43xx_DBG_DMAVERBOSE))
+		bcmdbg(ring->dev->wl,
+		       "max_used_slots increased to %d on %s ring %d\n",
+		       ring->max_used_slots,
+		       ring->tx ? "TX" : "RX",
+		       ring->index);
+}
+#else
+static inline
+void update_max_used_slots(struct bcm43xx_dmaring *ring,
+			   int current_used_slots)
+{ }
+#endif /* DEBUG */
+
 /* Request a slot for usage. */
 static inline
 int request_slot(struct bcm43xx_dmaring *ring)
 {
 	int slot;
 
-	assert(ring->tx);
-	assert(!ring->suspended);
-	assert(free_slots(ring) != 0);
+	BCM43xx_WARN_ON(!ring->tx);
+	BCM43xx_WARN_ON(ring->stopped);
+	BCM43xx_WARN_ON(free_slots(ring) == 0);
 
 	slot = next_slot(ring, ring->current_slot);
 	ring->current_slot = slot;
 	ring->used_slots++;
 
-	/* Check the number of available slots and suspend TX,
-	 * if we are running low on free slots.
-	 */
-	if (unlikely(free_slots(ring) < ring->suspend_mark)) {
-		netif_stop_queue(ring->bcm->net_dev);
-		ring->suspended = 1;
-	}
-#ifdef CONFIG_BCM43XX_DEBUG
-	if (ring->used_slots > ring->max_used_slots)
-		ring->max_used_slots = ring->used_slots;
-#endif /* CONFIG_BCM43XX_DEBUG*/
+	update_max_used_slots(ring, ring->used_slots);
 
 	return slot;
 }
 
-/* Return a slot to the free slots. */
-static inline
-void return_slot(struct bcm43xx_dmaring *ring, int slot)
+/* Mac80211-queue to bcm43xx-ring mapping */
+static struct bcm43xx_dmaring *priority_to_txring(struct bcm43xx_wldev *dev,
+						   int queue_priority)
 {
-	assert(ring->tx);
+	struct bcm43xx_dmaring *ring;
 
-	ring->used_slots--;
+/*FIXME: For now we always run on TX-ring-1 */
+return dev->dma.tx_ring1;
 
-	/* Check if TX is suspended and check if we have
-	 * enough free slots to resume it again.
-	 */
-	if (unlikely(ring->suspended)) {
-		if (free_slots(ring) >= ring->resume_mark) {
-			ring->suspended = 0;
-			netif_wake_queue(ring->bcm->net_dev);
-		}
+	/* 0 = highest priority */
+	switch (queue_priority) {
+	default:
+		BCM43xx_WARN_ON(1);
+		/* fallthrough */
+	case 0:
+		ring = dev->dma.tx_ring3;
+		break;
+	case 1:
+		ring = dev->dma.tx_ring2;
+		break;
+	case 2:
+		ring = dev->dma.tx_ring1;
+		break;
+	case 3:
+		ring = dev->dma.tx_ring0;
+		break;
+	case 4:
+		ring = dev->dma.tx_ring4;
+		break;
+	case 5:
+		ring = dev->dma.tx_ring5;
+		break;
 	}
+
+	return ring;
 }
 
+/* Bcm4301-ring to mac80211-queue mapping */
+static inline int txring_to_priority(struct bcm43xx_dmaring *ring)
+{
+	static const u8 idx_to_prio[] =
+		{ 3, 2, 1, 0, 4, 5, };
+
+/*FIXME: have only one queue, for now */
+return 0;
+
+	return idx_to_prio[ring->index];
+}
+
+
 u16 bcm43xx_dmacontroller_base(int dma64bit, int controller_idx)
 {
 	static const u16 map64[] = {
@@ -129,12 +371,12 @@ u16 bcm43xx_dmacontroller_base(int dma64
 	};
 
 	if (dma64bit) {
-		assert(controller_idx >= 0 &&
-		       controller_idx < ARRAY_SIZE(map64));
+		BCM43xx_WARN_ON(!(controller_idx >= 0 &&
+		       controller_idx < ARRAY_SIZE(map64)));
 		return map64[controller_idx];
 	}
-	assert(controller_idx >= 0 &&
-	       controller_idx < ARRAY_SIZE(map32));
+	BCM43xx_WARN_ON(!(controller_idx >= 0 &&
+	       controller_idx < ARRAY_SIZE(map32)));
 	return map32[controller_idx];
 }
 
@@ -145,14 +387,15 @@ dma_addr_t map_descbuffer(struct bcm43xx
 			  int tx)
 {
 	dma_addr_t dmaaddr;
-	int direction = PCI_DMA_FROMDEVICE;
 
 	if (tx)
-		direction = PCI_DMA_TODEVICE;
-
-	dmaaddr = pci_map_single(ring->bcm->pci_dev,
+		dmaaddr = dma_map_single(ring->dev->dev->dev,
+					 buf, len,
+					 DMA_TO_DEVICE);
+	else
+		dmaaddr = dma_map_single(ring->dev->dev->dev,
 					 buf, len,
-					 direction);
+					 DMA_FROM_DEVICE);
 
 	return dmaaddr;
 }
@@ -164,13 +407,13 @@ void unmap_descbuffer(struct bcm43xx_dma
 		      int tx)
 {
 	if (tx) {
-		pci_unmap_single(ring->bcm->pci_dev,
+		dma_unmap_single(ring->dev->dev->dev,
 				 addr, len,
-				 PCI_DMA_TODEVICE);
+				 DMA_TO_DEVICE);
 	} else {
-		pci_unmap_single(ring->bcm->pci_dev,
+		dma_unmap_single(ring->dev->dev->dev,
 				 addr, len,
-				 PCI_DMA_FROMDEVICE);
+				 DMA_FROM_DEVICE);
 	}
 }
 
@@ -179,10 +422,10 @@ void sync_descbuffer_for_cpu(struct bcm4
 			     dma_addr_t addr,
 			     size_t len)
 {
-	assert(!ring->tx);
+	BCM43xx_WARN_ON(ring->tx);
 
-	pci_dma_sync_single_for_cpu(ring->bcm->pci_dev,
-				    addr, len, PCI_DMA_FROMDEVICE);
+	dma_sync_single_for_cpu(ring->dev->dev->dev,
+				addr, len, DMA_FROM_DEVICE);
 }
 
 static inline
@@ -190,98 +433,64 @@ void sync_descbuffer_for_device(struct b
 				dma_addr_t addr,
 				size_t len)
 {
-	assert(!ring->tx);
+	BCM43xx_WARN_ON(ring->tx);
 
-	pci_dma_sync_single_for_cpu(ring->bcm->pci_dev,
-				    addr, len, PCI_DMA_TODEVICE);
+	dma_sync_single_for_device(ring->dev->dev->dev,
+				   addr, len, DMA_FROM_DEVICE);
 }
 
-/* Unmap and free a descriptor buffer. */
 static inline
 void free_descriptor_buffer(struct bcm43xx_dmaring *ring,
 			    struct bcm43xx_dmadesc_meta *meta,
 			    int irq_context)
 {
-	assert(meta->skb);
-	if (irq_context)
-		dev_kfree_skb_irq(meta->skb);
-	else
-		dev_kfree_skb(meta->skb);
-	meta->skb = NULL;
+	if (meta->skb) {
+		if (irq_context)
+			dev_kfree_skb_irq(meta->skb);
+		else
+			dev_kfree_skb(meta->skb);
+		meta->skb = NULL;
+	}
 }
 
 static int alloc_ringmemory(struct bcm43xx_dmaring *ring)
 {
-	ring->descbase = pci_alloc_consistent(ring->bcm->pci_dev, BCM43xx_DMA_RINGMEMSIZE,
-					    &(ring->dmabase));
-	if (!ring->descbase) {
-		/* Allocation may have failed due to pci_alloc_consistent
-		   insisting on use of GFP_DMA, which is more restrictive
-		   than necessary...  */
-		struct dma_desc *rx_ring;
-		dma_addr_t rx_ring_dma;
-
-		rx_ring = kzalloc(BCM43xx_DMA_RINGMEMSIZE, GFP_KERNEL);
-		if (!rx_ring)
-			goto out_err;
-
-		rx_ring_dma = pci_map_single(ring->bcm->pci_dev, rx_ring,
-					     BCM43xx_DMA_RINGMEMSIZE,
-					     PCI_DMA_BIDIRECTIONAL);
-
-		if (pci_dma_mapping_error(rx_ring_dma) ||
-		    rx_ring_dma + BCM43xx_DMA_RINGMEMSIZE > ring->bcm->dma_mask) {
-			/* Sigh... */
-			if (!pci_dma_mapping_error(rx_ring_dma))
-				pci_unmap_single(ring->bcm->pci_dev,
-						 rx_ring_dma, BCM43xx_DMA_RINGMEMSIZE,
-						 PCI_DMA_BIDIRECTIONAL);
-			rx_ring_dma = pci_map_single(ring->bcm->pci_dev,
-						 rx_ring, BCM43xx_DMA_RINGMEMSIZE,
-						 PCI_DMA_BIDIRECTIONAL);
-			if (pci_dma_mapping_error(rx_ring_dma) ||
-			    rx_ring_dma + BCM43xx_DMA_RINGMEMSIZE > ring->bcm->dma_mask) {
-				assert(0);
-				if (!pci_dma_mapping_error(rx_ring_dma))
-					pci_unmap_single(ring->bcm->pci_dev,
-							 rx_ring_dma, BCM43xx_DMA_RINGMEMSIZE,
-							 PCI_DMA_BIDIRECTIONAL);
-				goto out_err;
-			}
-                }
+	struct device *dev = ring->dev->dev->dev;
 
-                ring->descbase = rx_ring;
-                ring->dmabase = rx_ring_dma;
+	ring->descbase = dma_alloc_coherent(dev, BCM43xx_DMA_RINGMEMSIZE,
+					    &(ring->dmabase), GFP_KERNEL);
+	if (!ring->descbase) {
+		bcmerr(ring->dev->wl, "DMA ringmemory allocation failed\n");
+		return -ENOMEM;
 	}
 	memset(ring->descbase, 0, BCM43xx_DMA_RINGMEMSIZE);
 
 	return 0;
-out_err:
-	printk(KERN_ERR PFX "DMA ringmemory allocation failed\n");
-	return -ENOMEM;
 }
 
 static void free_ringmemory(struct bcm43xx_dmaring *ring)
 {
-	struct device *dev = &(ring->bcm->pci_dev->dev);
+	struct device *dev = ring->dev->dev->dev;
 
 	dma_free_coherent(dev, BCM43xx_DMA_RINGMEMSIZE,
 			  ring->descbase, ring->dmabase);
 }
 
 /* Reset the RX DMA channel */
-int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_private *bcm,
+int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_wldev *dev,
 				   u16 mmio_base, int dma64)
 {
 	int i;
 	u32 value;
 	u16 offset;
 
+	might_sleep();
+
 	offset = dma64 ? BCM43xx_DMA64_RXCTL : BCM43xx_DMA32_RXCTL;
-	bcm43xx_write32(bcm, mmio_base + offset, 0);
-	for (i = 0; i < 1000; i++) {
+	bcm43xx_write32(dev, mmio_base + offset, 0);
+	for (i = 0; i < 10; i++) {
 		offset = dma64 ? BCM43xx_DMA64_RXSTATUS : BCM43xx_DMA32_RXSTATUS;
-		value = bcm43xx_read32(bcm, mmio_base + offset);
+		value = bcm43xx_read32(dev, mmio_base + offset);
 		if (dma64) {
 			value &= BCM43xx_DMA64_RXSTAT;
 			if (value == BCM43xx_DMA64_RXSTAT_DISABLED) {
@@ -295,10 +504,10 @@ int bcm43xx_dmacontroller_rx_reset(struc
 				break;
 			}
 		}
-		udelay(10);
+		msleep(1);
 	}
 	if (i != -1) {
-		printk(KERN_ERR PFX "Error: Wait on DMA RX status timed out.\n");
+		bcmerr(dev->wl, "DMA RX reset timed out\n");
 		return -ENODEV;
 	}
 
@@ -306,16 +515,18 @@ int bcm43xx_dmacontroller_rx_reset(struc
 }
 
 /* Reset the RX DMA channel */
-int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_private *bcm,
+int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_wldev *dev,
 				   u16 mmio_base, int dma64)
 {
 	int i;
 	u32 value;
 	u16 offset;
 
-	for (i = 0; i < 1000; i++) {
+	might_sleep();
+
+	for (i = 0; i < 10; i++) {
 		offset = dma64 ? BCM43xx_DMA64_TXSTATUS : BCM43xx_DMA32_TXSTATUS;
-		value = bcm43xx_read32(bcm, mmio_base + offset);
+		value = bcm43xx_read32(dev, mmio_base + offset);
 		if (dma64) {
 			value &= BCM43xx_DMA64_TXSTAT;
 			if (value == BCM43xx_DMA64_TXSTAT_DISABLED ||
@@ -329,13 +540,13 @@ int bcm43xx_dmacontroller_tx_reset(struc
 			    value == BCM43xx_DMA32_TXSTAT_STOPPED)
 				break;
 		}
-		udelay(10);
+		msleep(1);
 	}
 	offset = dma64 ? BCM43xx_DMA64_TXCTL : BCM43xx_DMA32_TXCTL;
-	bcm43xx_write32(bcm, mmio_base + offset, 0);
-	for (i = 0; i < 1000; i++) {
+	bcm43xx_write32(dev, mmio_base + offset, 0);
+	for (i = 0; i < 10; i++) {
 		offset = dma64 ? BCM43xx_DMA64_TXSTATUS : BCM43xx_DMA32_TXSTATUS;
-		value = bcm43xx_read32(bcm, mmio_base + offset);
+		value = bcm43xx_read32(dev, mmio_base + offset);
 		if (dma64) {
 			value &= BCM43xx_DMA64_TXSTAT;
 			if (value == BCM43xx_DMA64_TXSTAT_DISABLED) {
@@ -349,133 +560,62 @@ int bcm43xx_dmacontroller_tx_reset(struc
 				break;
 			}
 		}
-		udelay(10);
+		msleep(1);
 	}
 	if (i != -1) {
-		printk(KERN_ERR PFX "Error: Wait on DMA TX status timed out.\n");
+		bcmerr(dev->wl, "DMA TX reset timed out\n");
 		return -ENODEV;
 	}
 	/* ensure the reset is completed. */
-	udelay(300);
+	msleep(1);
 
 	return 0;
 }
 
-static void fill_descriptor(struct bcm43xx_dmaring *ring,
-			    struct bcm43xx_dmadesc_generic *desc,
-			    dma_addr_t dmaaddr,
-			    u16 bufsize,
-			    int start, int end, int irq)
-{
-	int slot;
-
-	slot = bcm43xx_dma_desc2idx(ring, desc);
-	assert(slot >= 0 && slot < ring->nr_slots);
-
-	if (ring->dma64) {
-		u32 ctl0 = 0, ctl1 = 0;
-		u32 addrlo, addrhi;
-		u32 addrext;
-
-		addrlo = (u32)(dmaaddr & 0xFFFFFFFF);
-		addrhi = (((u64)dmaaddr >> 32) & ~BCM43xx_DMA64_ROUTING);
-		addrext = (((u64)dmaaddr >> 32) >> BCM43xx_DMA64_ROUTING_SHIFT);
-		addrhi |= ring->routing;
-		if (slot == ring->nr_slots - 1)
-			ctl0 |= BCM43xx_DMA64_DCTL0_DTABLEEND;
-		if (start)
-			ctl0 |= BCM43xx_DMA64_DCTL0_FRAMESTART;
-		if (end)
-			ctl0 |= BCM43xx_DMA64_DCTL0_FRAMEEND;
-		if (irq)
-			ctl0 |= BCM43xx_DMA64_DCTL0_IRQ;
-		ctl1 |= (bufsize - ring->frameoffset)
-			& BCM43xx_DMA64_DCTL1_BYTECNT;
-		ctl1 |= (addrext << BCM43xx_DMA64_DCTL1_ADDREXT_SHIFT)
-			& BCM43xx_DMA64_DCTL1_ADDREXT_MASK;
-
-		desc->dma64.control0 = cpu_to_le32(ctl0);
-		desc->dma64.control1 = cpu_to_le32(ctl1);
-		desc->dma64.address_low = cpu_to_le32(addrlo);
-		desc->dma64.address_high = cpu_to_le32(addrhi);
-	} else {
-		u32 ctl;
-		u32 addr;
-		u32 addrext;
-
-		addr = (u32)(dmaaddr & ~BCM43xx_DMA32_ROUTING);
-		addrext = (u32)(dmaaddr & BCM43xx_DMA32_ROUTING)
-			   >> BCM43xx_DMA32_ROUTING_SHIFT;
-		addr |= ring->routing;
-		ctl = (bufsize - ring->frameoffset)
-		      & BCM43xx_DMA32_DCTL_BYTECNT;
-		if (slot == ring->nr_slots - 1)
-			ctl |= BCM43xx_DMA32_DCTL_DTABLEEND;
-		if (start)
-			ctl |= BCM43xx_DMA32_DCTL_FRAMESTART;
-		if (end)
-			ctl |= BCM43xx_DMA32_DCTL_FRAMEEND;
-		if (irq)
-			ctl |= BCM43xx_DMA32_DCTL_IRQ;
-		ctl |= (addrext << BCM43xx_DMA32_DCTL_ADDREXT_SHIFT)
-		       & BCM43xx_DMA32_DCTL_ADDREXT_MASK;
-
-		desc->dma32.control = cpu_to_le32(ctl);
-		desc->dma32.address = cpu_to_le32(addr);
-	}
-}
-
 static int setup_rx_descbuffer(struct bcm43xx_dmaring *ring,
 			       struct bcm43xx_dmadesc_generic *desc,
 			       struct bcm43xx_dmadesc_meta *meta,
 			       gfp_t gfp_flags)
 {
-	struct bcm43xx_rxhdr *rxhdr;
-	struct bcm43xx_hwxmitstatus *xmitstat;
+	struct bcm43xx_rxhdr_fw3 *rxhdr;
+	struct bcm43xx_hwtxstatus *txstat;
 	dma_addr_t dmaaddr;
 	struct sk_buff *skb;
 
-	assert(!ring->tx);
+	BCM43xx_WARN_ON(ring->tx);
 
 	skb = __dev_alloc_skb(ring->rx_buffersize, gfp_flags);
 	if (unlikely(!skb))
 		return -ENOMEM;
-	dmaaddr = map_descbuffer(ring, skb->data, ring->rx_buffersize, 0);
-	/* This hardware bug work-around adapted from the b44 driver.
-	   The chip may be unable to do PCI DMA to/from anything above 1GB */
-	if (pci_dma_mapping_error(dmaaddr) ||
-	    dmaaddr + ring->rx_buffersize > ring->bcm->dma_mask) {
-		/* This one has 30-bit addressing... */
-		if (!pci_dma_mapping_error(dmaaddr))
-			pci_unmap_single(ring->bcm->pci_dev,
-					 dmaaddr, ring->rx_buffersize,
-					 PCI_DMA_FROMDEVICE);
+	dmaaddr = map_descbuffer(ring, skb->data,
+				 ring->rx_buffersize, 0);
+	if (dma_mapping_error(dmaaddr)) {
+		/* ugh. try to realloc in zone_dma */
+		gfp_flags |= GFP_DMA;
+
 		dev_kfree_skb_any(skb);
-		skb = __dev_alloc_skb(ring->rx_buffersize,GFP_DMA);
-		if (skb == NULL)
-			return -ENOMEM;
-		dmaaddr = pci_map_single(ring->bcm->pci_dev,
-					 skb->data, ring->rx_buffersize,
-					 PCI_DMA_FROMDEVICE);
-		if (pci_dma_mapping_error(dmaaddr) ||
-		    dmaaddr + ring->rx_buffersize > ring->bcm->dma_mask) {
-			assert(0);
-			dev_kfree_skb_any(skb);
+
+		skb = __dev_alloc_skb(ring->rx_buffersize, gfp_flags);
+		if (unlikely(!skb))
 			return -ENOMEM;
-		}
+		dmaaddr = map_descbuffer(ring, skb->data,
+					 ring->rx_buffersize, 0);
 	}
+
+	if (dma_mapping_error(dmaaddr)) {
+		dev_kfree_skb_any(skb);
+		return -EIO;
+	}
+
 	meta->skb = skb;
 	meta->dmaaddr = dmaaddr;
-	skb->dev = ring->bcm->net_dev;
+	ring->ops->fill_descriptor(ring, desc, dmaaddr,
+				   ring->rx_buffersize, 0, 0, 0);
 
-	fill_descriptor(ring, desc, dmaaddr,
-			ring->rx_buffersize, 0, 0, 0);
-
-	rxhdr = (struct bcm43xx_rxhdr *)(skb->data);
-	rxhdr->frame_length = 0;
-	rxhdr->flags1 = 0;
-	xmitstat = (struct bcm43xx_hwxmitstatus *)(skb->data);
-	xmitstat->cookie = 0;
+	rxhdr = (struct bcm43xx_rxhdr_fw3 *)(skb->data);
+	rxhdr->frame_len = 0;
+	txstat = (struct bcm43xx_hwtxstatus *)(skb->data);
+	txstat->cookie = 0;
 
 	return 0;
 }
@@ -490,11 +630,14 @@ static int alloc_initial_descbuffers(str
 	struct bcm43xx_dmadesc_meta *meta;
 
 	for (i = 0; i < ring->nr_slots; i++) {
-		desc = bcm43xx_dma_idx2desc(ring, i, &meta);
+		desc = ring->ops->idx2desc(ring, i, &meta);
 
 		err = setup_rx_descbuffer(ring, desc, meta, GFP_KERNEL);
-		if (err)
+		if (err) {
+			bcmerr(ring->dev->wl,
+			       "Failed to allocate initial descbuffers\n");
 			goto err_unwind;
+		}
 	}
 	mb();
 	ring->used_slots = ring->nr_slots;
@@ -504,7 +647,7 @@ out:
 
 err_unwind:
 	for (i--; i >= 0; i--) {
-		desc = bcm43xx_dma_idx2desc(ring, i, &meta);
+		desc = ring->ops->idx2desc(ring, i, &meta);
 
 		unmap_descbuffer(ring, meta->dmaaddr, ring->rx_buffersize, 0);
 		dev_kfree_skb(meta->skb);
@@ -521,12 +664,14 @@ static int dmacontroller_setup(struct bc
 	int err = 0;
 	u32 value;
 	u32 addrext;
+	u32 trans = ssb_dma_translation(ring->dev->dev);
 
 	if (ring->tx) {
 		if (ring->dma64) {
 			u64 ringbase = (u64)(ring->dmabase);
 
-			addrext = ((ringbase >> 32) >> BCM43xx_DMA64_ROUTING_SHIFT);
+			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
+				  >> SSB_DMA_TRANSLATION_SHIFT;
 			value = BCM43xx_DMA64_TXENABLE;
 			value |= (addrext << BCM43xx_DMA64_TXADDREXT_SHIFT)
 				& BCM43xx_DMA64_TXADDREXT_MASK;
@@ -534,19 +679,21 @@ static int dmacontroller_setup(struct bc
 			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGLO,
 					(ringbase & 0xFFFFFFFF));
 			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGHI,
-					((ringbase >> 32) & ~BCM43xx_DMA64_ROUTING)
-					| ring->routing);
+					((ringbase >> 32)
+					& ~SSB_DMA_TRANSLATION_MASK)
+					| trans);
 		} else {
 			u32 ringbase = (u32)(ring->dmabase);
 
-			addrext = (ringbase >> BCM43xx_DMA32_ROUTING_SHIFT);
+			addrext = (ringbase & SSB_DMA_TRANSLATION_MASK)
+				  >> SSB_DMA_TRANSLATION_SHIFT;
 			value = BCM43xx_DMA32_TXENABLE;
 			value |= (addrext << BCM43xx_DMA32_TXADDREXT_SHIFT)
 				& BCM43xx_DMA32_TXADDREXT_MASK;
 			bcm43xx_dma_write(ring, BCM43xx_DMA32_TXCTL, value);
 			bcm43xx_dma_write(ring, BCM43xx_DMA32_TXRING,
-					(ringbase & ~BCM43xx_DMA32_ROUTING)
-					| ring->routing);
+					(ringbase & ~SSB_DMA_TRANSLATION_MASK)
+					| trans);
 		}
 	} else {
 		err = alloc_initial_descbuffers(ring);
@@ -555,7 +702,8 @@ static int dmacontroller_setup(struct bc
 		if (ring->dma64) {
 			u64 ringbase = (u64)(ring->dmabase);
 
-			addrext = ((ringbase >> 32) >> BCM43xx_DMA64_ROUTING_SHIFT);
+			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
+				  >> SSB_DMA_TRANSLATION_SHIFT;
 			value = (ring->frameoffset << BCM43xx_DMA64_RXFROFF_SHIFT);
 			value |= BCM43xx_DMA64_RXENABLE;
 			value |= (addrext << BCM43xx_DMA64_RXADDREXT_SHIFT)
@@ -564,21 +712,22 @@ static int dmacontroller_setup(struct bc
 			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGLO,
 					(ringbase & 0xFFFFFFFF));
 			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGHI,
-					((ringbase >> 32) & ~BCM43xx_DMA64_ROUTING)
-					| ring->routing);
+					((ringbase >> 32) &
+					~SSB_DMA_TRANSLATION_MASK) | trans);
 			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXINDEX, 200);
 		} else {
 			u32 ringbase = (u32)(ring->dmabase);
 
-			addrext = (ringbase >> BCM43xx_DMA32_ROUTING_SHIFT);
+			addrext = (ringbase & SSB_DMA_TRANSLATION_MASK)
+				  >> SSB_DMA_TRANSLATION_SHIFT;
 			value = (ring->frameoffset << BCM43xx_DMA32_RXFROFF_SHIFT);
 			value |= BCM43xx_DMA32_RXENABLE;
 			value |= (addrext << BCM43xx_DMA32_RXADDREXT_SHIFT)
 				& BCM43xx_DMA32_RXADDREXT_MASK;
 			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXCTL, value);
 			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXRING,
-					(ringbase & ~BCM43xx_DMA32_ROUTING)
-					| ring->routing);
+					(ringbase & ~SSB_DMA_TRANSLATION_MASK)
+					| trans);
 			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXINDEX, 200);
 		}
 	}
@@ -591,19 +740,23 @@ out:
 static void dmacontroller_cleanup(struct bcm43xx_dmaring *ring)
 {
 	if (ring->tx) {
-		bcm43xx_dmacontroller_tx_reset(ring->bcm, ring->mmio_base, ring->dma64);
+		bcm43xx_dmacontroller_tx_reset(ring->dev, ring->mmio_base,
+					       ring->dma64);
 		if (ring->dma64) {
 			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGLO, 0);
 			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGHI, 0);
-		} else
+		} else {
 			bcm43xx_dma_write(ring, BCM43xx_DMA32_TXRING, 0);
+		}
 	} else {
-		bcm43xx_dmacontroller_rx_reset(ring->bcm, ring->mmio_base, ring->dma64);
+		bcm43xx_dmacontroller_rx_reset(ring->dev, ring->mmio_base,
+					       ring->dma64);
 		if (ring->dma64) {
 			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGLO, 0);
 			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGHI, 0);
-		} else
+		} else {
 			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXRING, 0);
+		}
 	}
 }
 
@@ -616,10 +769,10 @@ static void free_all_descbuffers(struct 
 	if (!ring->used_slots)
 		return;
 	for (i = 0; i < ring->nr_slots; i++) {
-		desc = bcm43xx_dma_idx2desc(ring, i, &meta);
+		desc = ring->ops->idx2desc(ring, i, &meta);
 
 		if (!meta->skb) {
-			assert(ring->tx);
+			BCM43xx_WARN_ON(!ring->tx);
 			continue;
 		}
 		if (ring->tx) {
@@ -633,9 +786,29 @@ static void free_all_descbuffers(struct 
 	}
 }
 
+static u64 supported_dma_mask(struct bcm43xx_wldev *dev)
+{
+	u32 tmp;
+	u16 mmio_base;
+
+	tmp = bcm43xx_read32(dev, SSB_TMSHIGH);
+	if (tmp & SSB_TMSHIGH_DMA64)
+		return DMA_64BIT_MASK;
+	mmio_base = bcm43xx_dmacontroller_base(0, 0);
+	bcm43xx_write32(dev,
+			mmio_base + BCM43xx_DMA32_TXCTL,
+			BCM43xx_DMA32_TXADDREXT_MASK);
+	tmp = bcm43xx_read32(dev,
+			     mmio_base + BCM43xx_DMA32_TXCTL);
+	if (tmp & BCM43xx_DMA32_TXADDREXT_MASK)
+		return DMA_32BIT_MASK;
+
+	return DMA_30BIT_MASK;
+}
+
 /* Main initialization function. */
 static
-struct bcm43xx_dmaring * bcm43xx_setup_dmaring(struct bcm43xx_private *bcm,
+struct bcm43xx_dmaring *bcm43xx_setup_dmaring(struct bcm43xx_wldev *dev,
 					       int controller_index,
 					       int for_tx,
 					       int dma64)
@@ -643,6 +816,7 @@ struct bcm43xx_dmaring * bcm43xx_setup_d
 	struct bcm43xx_dmaring *ring;
 	int err;
 	int nr_slots;
+	dma_addr_t dma_test;
 
 	ring = kzalloc(sizeof(*ring), GFP_KERNEL);
 	if (!ring)
@@ -656,19 +830,51 @@ struct bcm43xx_dmaring * bcm43xx_setup_d
 			     GFP_KERNEL);
 	if (!ring->meta)
 		goto err_kfree_ring;
+	if (for_tx) {
+		ring->txhdr_cache = kcalloc(nr_slots,
+					    sizeof(struct bcm43xx_txhdr_fw3),
+					    GFP_KERNEL);
+		if (!ring->txhdr_cache)
+			goto err_kfree_meta;
+
+		/* test for ability to dma to txhdr_cache */
+		dma_test = dma_map_single(dev->dev->dev,
+				ring->txhdr_cache,
+				sizeof(struct bcm43xx_txhdr_fw3),
+				DMA_TO_DEVICE);
+
+		if (dma_mapping_error(dma_test)) {
+			/* ugh realloc */
+			kfree(ring->txhdr_cache);
+			ring->txhdr_cache = kcalloc(nr_slots,
+					sizeof(struct bcm43xx_txhdr_fw3),
+					GFP_KERNEL | GFP_DMA);
+			if (!ring->txhdr_cache)
+				goto err_kfree_meta;
+
+			dma_test = dma_map_single(dev->dev->dev,
+					ring->txhdr_cache,
+					sizeof(struct bcm43xx_txhdr_fw3),
+					DMA_TO_DEVICE);
 
-	ring->routing = BCM43xx_DMA32_CLIENTTRANS;
-	if (dma64)
-		ring->routing = BCM43xx_DMA64_CLIENTTRANS;
+			if (dma_mapping_error(dma_test))
+				goto err_kfree_txhdr_cache;
+		}
 
-	ring->bcm = bcm;
+		dma_unmap_single(dev->dev->dev,
+				dma_test, sizeof(struct bcm43xx_txhdr_fw3),
+				DMA_TO_DEVICE);
+	}
+
+	ring->dev = dev;
 	ring->nr_slots = nr_slots;
-	ring->suspend_mark = ring->nr_slots * BCM43xx_TXSUSPEND_PERCENT / 100;
-	ring->resume_mark = ring->nr_slots * BCM43xx_TXRESUME_PERCENT / 100;
-	assert(ring->suspend_mark < ring->resume_mark);
 	ring->mmio_base = bcm43xx_dmacontroller_base(dma64, controller_index);
 	ring->index = controller_index;
 	ring->dma64 = !!dma64;
+	if (dma64)
+		ring->ops = &dma64_ops;
+	else
+		ring->ops = &dma32_ops;
 	if (for_tx) {
 		ring->tx = 1;
 		ring->current_slot = -1;
@@ -679,24 +885,29 @@ struct bcm43xx_dmaring * bcm43xx_setup_d
 		} else if (ring->index == 3) {
 			ring->rx_buffersize = BCM43xx_DMA3_RX_BUFFERSIZE;
 			ring->frameoffset = BCM43xx_DMA3_RX_FRAMEOFFSET;
-		} else
-			assert(0);
+		} else {
+			BCM43xx_WARN_ON(1);
+		}
 	}
+	spin_lock_init(&ring->lock);
+#ifdef CONFIG_BCM43XX_DEBUG
+	ring->last_injected_overflow = jiffies;
+#endif
 
 	err = alloc_ringmemory(ring);
 	if (err)
-		goto err_kfree_meta;
+		goto err_kfree_txhdr_cache;
 	err = dmacontroller_setup(ring);
 	if (err)
 		goto err_free_ringmemory;
-	return ring;
 
 out:
-	printk(KERN_ERR PFX "Error in bcm43xx_setup_dmaring\n");
 	return ring;
 
 err_free_ringmemory:
 	free_ringmemory(ring);
+err_kfree_txhdr_cache:
+	kfree(ring->txhdr_cache);
 err_kfree_meta:
 	kfree(ring->meta);
 err_kfree_ring:
@@ -711,11 +922,11 @@ static void bcm43xx_destroy_dmaring(stru
 	if (!ring)
 		return;
 
-	dprintk(KERN_INFO PFX "DMA-%s 0x%04X (%s) max used slots: %d/%d\n",
-		(ring->dma64) ? "64" : "32",
-		ring->mmio_base,
-		(ring->tx) ? "TX" : "RX",
-		ring->max_used_slots, ring->nr_slots);
+	bcmdbg(ring->dev->wl, "DMA-%s 0x%04X (%s) max used slots: %d/%d\n",
+	       (ring->dma64) ? "64" : "32",
+	       ring->mmio_base,
+	       (ring->tx) ? "TX" : "RX",
+	       ring->max_used_slots, ring->nr_slots);
 	/* Device IRQs are disabled prior entering this function,
 	 * so no need to take care of concurrency with rx handler stuff.
 	 */
@@ -723,17 +934,18 @@ static void bcm43xx_destroy_dmaring(stru
 	free_all_descbuffers(ring);
 	free_ringmemory(ring);
 
+	kfree(ring->txhdr_cache);
 	kfree(ring->meta);
 	kfree(ring);
 }
 
-void bcm43xx_dma_free(struct bcm43xx_private *bcm)
+void bcm43xx_dma_free(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_dma *dma;
 
-	if (bcm43xx_using_pio(bcm))
+	if (bcm43xx_using_pio(dev))
 		return;
-	dma = bcm43xx_current_dma(bcm);
+	dma = &dev->dma;
 
 	bcm43xx_destroy_dmaring(dma->rx_ring3);
 	dma->rx_ring3 = NULL;
@@ -754,70 +966,80 @@ void bcm43xx_dma_free(struct bcm43xx_pri
 	dma->tx_ring0 = NULL;
 }
 
-int bcm43xx_dma_init(struct bcm43xx_private *bcm)
+int bcm43xx_dma_init(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_dma *dma = bcm43xx_current_dma(bcm);
+	struct bcm43xx_dma *dma = &dev->dma;
 	struct bcm43xx_dmaring *ring;
-	int err = -ENOMEM;
+	int err;
+	u64 dmamask;
 	int dma64 = 0;
 
-	bcm->dma_mask = bcm43xx_get_supported_dma_mask(bcm);
-	if (bcm->dma_mask == DMA_64BIT_MASK)
+	dmamask = supported_dma_mask(dev);
+	if (dmamask == DMA_64BIT_MASK)
 		dma64 = 1;
-	err = pci_set_dma_mask(bcm->pci_dev, bcm->dma_mask);
-	if (err)
-		goto no_dma;
-	err = pci_set_consistent_dma_mask(bcm->pci_dev, bcm->dma_mask);
-	if (err)
-		goto no_dma;
 
+	err = ssb_dma_set_mask(dev->dev, dmamask);
+	if (err) {
+#ifdef BCM43XX_PIO
+		bcmwarn(dev->wl, "DMA for this device not supported. "
+			"Falling back to PIO\n");
+		dev->__using_pio = 1;
+		return -EAGAIN;
+#else
+		bcmerr(dev->wl, "DMA for this device not supported and "
+		       "no PIO support compiled in\n");
+		return -EOPNOTSUPP;
+#endif
+	}
+
+	err = -ENOMEM;
 	/* setup TX DMA channels. */
-	ring = bcm43xx_setup_dmaring(bcm, 0, 1, dma64);
+	ring = bcm43xx_setup_dmaring(dev, 0, 1, dma64);
 	if (!ring)
 		goto out;
 	dma->tx_ring0 = ring;
 
-	ring = bcm43xx_setup_dmaring(bcm, 1, 1, dma64);
+	ring = bcm43xx_setup_dmaring(dev, 1, 1, dma64);
 	if (!ring)
 		goto err_destroy_tx0;
 	dma->tx_ring1 = ring;
 
-	ring = bcm43xx_setup_dmaring(bcm, 2, 1, dma64);
+	ring = bcm43xx_setup_dmaring(dev, 2, 1, dma64);
 	if (!ring)
 		goto err_destroy_tx1;
 	dma->tx_ring2 = ring;
 
-	ring = bcm43xx_setup_dmaring(bcm, 3, 1, dma64);
+	ring = bcm43xx_setup_dmaring(dev, 3, 1, dma64);
 	if (!ring)
 		goto err_destroy_tx2;
 	dma->tx_ring3 = ring;
 
-	ring = bcm43xx_setup_dmaring(bcm, 4, 1, dma64);
+	ring = bcm43xx_setup_dmaring(dev, 4, 1, dma64);
 	if (!ring)
 		goto err_destroy_tx3;
 	dma->tx_ring4 = ring;
 
-	ring = bcm43xx_setup_dmaring(bcm, 5, 1, dma64);
+	ring = bcm43xx_setup_dmaring(dev, 5, 1, dma64);
 	if (!ring)
 		goto err_destroy_tx4;
 	dma->tx_ring5 = ring;
 
 	/* setup RX DMA channels. */
-	ring = bcm43xx_setup_dmaring(bcm, 0, 0, dma64);
+	ring = bcm43xx_setup_dmaring(dev, 0, 0, dma64);
 	if (!ring)
 		goto err_destroy_tx5;
 	dma->rx_ring0 = ring;
 
-	if (bcm->current_core->rev < 5) {
-		ring = bcm43xx_setup_dmaring(bcm, 3, 0, dma64);
+	if (dev->dev->id.revision < 5) {
+		ring = bcm43xx_setup_dmaring(dev, 3, 0, dma64);
 		if (!ring)
 			goto err_destroy_rx0;
 		dma->rx_ring3 = ring;
 	}
 
-	dprintk(KERN_INFO PFX "%d-bit DMA initialized\n",
-		(bcm->dma_mask == DMA_64BIT_MASK) ? 64 :
-		(bcm->dma_mask == DMA_32BIT_MASK) ? 32 : 30);
+	bcmdbg(dev->wl, "%d-bit DMA initialized\n",
+	       (dmamask == DMA_64BIT_MASK) ? 64 :
+	       (dmamask == DMA_32BIT_MASK) ? 32 : 30);
 	err = 0;
 out:
 	return err;
@@ -843,17 +1065,7 @@ err_destroy_tx1:
 err_destroy_tx0:
 	bcm43xx_destroy_dmaring(dma->tx_ring0);
 	dma->tx_ring0 = NULL;
-no_dma:
-#ifdef CONFIG_BCM43XX_PIO
-	printk(KERN_WARNING PFX "DMA not supported on this device."
-				" Falling back to PIO.\n");
-	bcm->__using_pio = 1;
-	return -ENOSYS;
-#else
-	printk(KERN_ERR PFX "FATAL: DMA not supported and PIO not configured. "
-			    "Please recompile the driver with PIO support.\n");
-	return -ENODEV;
-#endif /* CONFIG_BCM43XX_PIO */
+	goto out;
 }
 
 /* Generate a cookie for the TX header. */
@@ -888,7 +1100,7 @@ static u16 generate_cookie(struct bcm43x
 		cookie = 0xF000;
 		break;
 	}
-	assert(((u16)slot & 0xF000) == 0x0000);
+	BCM43xx_WARN_ON(!(((u16)slot & 0xF000) == 0x0000));
 	cookie |= (u16)slot;
 
 	return cookie;
@@ -896,10 +1108,10 @@ static u16 generate_cookie(struct bcm43x
 
 /* Inspect a cookie and find out to which controller/slot it belongs. */
 static
-struct bcm43xx_dmaring * parse_cookie(struct bcm43xx_private *bcm,
+struct bcm43xx_dmaring *parse_cookie(struct bcm43xx_wldev *dev,
 				      u16 cookie, int *slot)
 {
-	struct bcm43xx_dma *dma = bcm43xx_current_dma(bcm);
+	struct bcm43xx_dma *dma = &dev->dma;
 	struct bcm43xx_dmaring *ring = NULL;
 
 	switch (cookie & 0xF000) {
@@ -922,219 +1134,300 @@ struct bcm43xx_dmaring * parse_cookie(st
 		ring = dma->tx_ring5;
 		break;
 	default:
-		assert(0);
+		BCM43xx_WARN_ON(1);
 	}
 	*slot = (cookie & 0x0FFF);
-	assert(*slot >= 0 && *slot < ring->nr_slots);
+	BCM43xx_WARN_ON(!(ring && *slot >= 0 && *slot < ring->nr_slots));
 
 	return ring;
 }
 
-static void dmacontroller_poke_tx(struct bcm43xx_dmaring *ring,
-				  int slot)
-{
-	u16 offset;
-	int descsize;
-
-	/* Everything is ready to start. Buffers are DMA mapped and
-	 * associated with slots.
-	 * "slot" is the last slot of the new frame we want to transmit.
-	 * Close your seat belts now, please.
-	 */
-	wmb();
-	slot = next_slot(ring, slot);
-	offset = (ring->dma64) ? BCM43xx_DMA64_TXINDEX : BCM43xx_DMA32_TXINDEX;
-	descsize = (ring->dma64) ? sizeof(struct bcm43xx_dmadesc64)
-		: sizeof(struct bcm43xx_dmadesc32);
-	bcm43xx_dma_write(ring, offset,
-			(u32)(slot * descsize));
-}
-
-static void dma_tx_fragment(struct bcm43xx_dmaring *ring,
+static int dma_tx_fragment(struct bcm43xx_dmaring *ring,
 			    struct sk_buff *skb,
-			    u8 cur_frag)
+			    struct ieee80211_tx_control *ctl)
 {
+	const struct bcm43xx_dma_ops *ops = ring->ops;
+	u8 *header;
 	int slot;
+	int err;
 	struct bcm43xx_dmadesc_generic *desc;
 	struct bcm43xx_dmadesc_meta *meta;
-	dma_addr_t dmaaddr;
+	struct bcm43xx_dmadesc_meta *meta_hdr;
 	struct sk_buff *bounce_skb;
 
-	assert(skb_shinfo(skb)->nr_frags == 0);
+#define SLOTS_PER_PACKET  2
+	BCM43xx_WARN_ON(skb_shinfo(skb)->nr_frags != 0);
 
+	/* Get a slot for the header. */
 	slot = request_slot(ring);
-	desc = bcm43xx_dma_idx2desc(ring, slot, &meta);
+	desc = ops->idx2desc(ring, slot, &meta_hdr);
+	memset(meta_hdr, 0, sizeof(*meta_hdr));
 
-	/* Add a device specific TX header. */
-	assert(skb_headroom(skb) >= sizeof(struct bcm43xx_txhdr));
-	/* Reserve enough headroom for the device tx header. */
-	__skb_push(skb, sizeof(struct bcm43xx_txhdr));
-	/* Now calculate and add the tx header.
-	 * The tx header includes the PLCP header.
-	 */
-	bcm43xx_generate_txhdr(ring->bcm,
-			       (struct bcm43xx_txhdr *)skb->data,
-			       skb->data + sizeof(struct bcm43xx_txhdr),
-			       skb->len - sizeof(struct bcm43xx_txhdr),
-			       (cur_frag == 0),
+	header = &(ring->txhdr_cache[slot * sizeof(struct bcm43xx_txhdr_fw3)]);
+	bcm43xx_generate_txhdr(ring->dev, header,
+			       skb->data, skb->len, ctl,
 			       generate_cookie(ring, slot));
-	dmaaddr = map_descbuffer(ring, skb->data, skb->len, 1);
-	if (dma_mapping_error(dmaaddr) || dmaaddr + skb->len > ring->bcm->dma_mask) {
-		/* chip cannot handle DMA to/from > 1GB, use bounce buffer (copied from b44 driver) */
-		if (!dma_mapping_error(dmaaddr))
-			unmap_descbuffer(ring, dmaaddr, skb->len, 1);
-		bounce_skb = __dev_alloc_skb(skb->len, GFP_ATOMIC|GFP_DMA);
-		if (!bounce_skb)
-			return;
-		dmaaddr = map_descbuffer(ring, bounce_skb->data, bounce_skb->len, 1);
-		if (dma_mapping_error(dmaaddr) || dmaaddr + skb->len > ring->bcm->dma_mask) {
-			if (!dma_mapping_error(dmaaddr))
-				unmap_descbuffer(ring, dmaaddr, skb->len, 1);
-			dev_kfree_skb_any(bounce_skb);
-			assert(0);
-			return;
+
+	meta_hdr->dmaaddr = map_descbuffer(ring, (unsigned char *)header,
+				       sizeof(struct bcm43xx_txhdr_fw3), 1);
+	if (dma_mapping_error(meta_hdr->dmaaddr))
+		return -EIO;
+	ops->fill_descriptor(ring, desc, meta_hdr->dmaaddr,
+			     sizeof(struct bcm43xx_txhdr_fw3), 1, 0, 0);
+
+	/* Get a slot for the payload. */
+	slot = request_slot(ring);
+	desc = ops->idx2desc(ring, slot, &meta);
+	memset(meta, 0, sizeof(*meta));
+
+	memcpy(&meta->txstat.control, ctl, sizeof(*ctl));
+	meta->skb = skb;
+	meta->is_last_fragment = 1;
+
+	meta->dmaaddr = map_descbuffer(ring, skb->data, skb->len, 1);
+	/* create a bounce buffer in zone_dma on mapping failure. */
+	if (dma_mapping_error(meta->dmaaddr)) {
+		bounce_skb = __dev_alloc_skb(skb->len, GFP_ATOMIC | GFP_DMA);
+		if (!bounce_skb) {
+			err = -ENOMEM;
+			goto out_unmap_hdr;
 		}
-		skb_copy_from_linear_data(skb, skb_put(bounce_skb, skb->len),
-					  skb->len);
+
+		memcpy(skb_put(bounce_skb, skb->len), skb->data, skb->len);
 		dev_kfree_skb_any(skb);
 		skb = bounce_skb;
+		meta->skb = skb;
+		meta->dmaaddr = map_descbuffer(ring, skb->data, skb->len, 1);
+		if (dma_mapping_error(meta->dmaaddr)) {
+			err = -EIO;
+			goto out_free_bounce;
+		}
 	}
 
-	meta->skb = skb;
-	meta->dmaaddr = dmaaddr;
-
-	fill_descriptor(ring, desc, dmaaddr,
-			skb->len, 1, 1, 1);
+	ops->fill_descriptor(ring, desc, meta->dmaaddr,
+			     skb->len, 0, 1, 1);
 
+	wmb();	/* previous stuff MUST be done */
 	/* Now transfer the whole frame. */
-	dmacontroller_poke_tx(ring, slot);
+	ops->poke_tx(ring, next_slot(ring, slot));
+	return 0;
+
+out_free_bounce:
+	dev_kfree_skb_any(skb);
+out_unmap_hdr:
+	unmap_descbuffer(ring, meta_hdr->dmaaddr,
+			sizeof(struct bcm43xx_txhdr_fw3), 1);
+	return err;
 }
 
-int bcm43xx_dma_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
+static inline
+int should_inject_overflow(struct bcm43xx_dmaring *ring)
 {
-	/* We just received a packet from the kernel network subsystem.
-	 * Add headers and DMA map the memory. Poke
-	 * the device to send the stuff.
-	 * Note that this is called from atomic context.
-	 */
-	struct bcm43xx_dmaring *ring = bcm43xx_current_dma(bcm)->tx_ring1;
-	u8 i;
-	struct sk_buff *skb;
-
-	assert(ring->tx);
-	if (unlikely(free_slots(ring) < txb->nr_frags)) {
-		/* The queue should be stopped,
-		 * if we are low on free slots.
-		 * If this ever triggers, we have to lower the suspend_mark.
-		 */
-		dprintkl(KERN_ERR PFX "Out of DMA descriptor slots!\n");
-		return -ENOMEM;
+#ifdef CONFIG_BCM43XX_DEBUG
+	if (unlikely(bcm43xx_debug(ring->dev, BCM43xx_DBG_DMAOVERFLOW))) {
+		/* Check if we should inject another ringbuffer overflow
+		 * to test handling of this situation in the stack. */
+		unsigned long next_overflow;
+
+		next_overflow = ring->last_injected_overflow + HZ;
+		if (time_after(jiffies, next_overflow)) {
+			ring->last_injected_overflow = jiffies;
+			bcmdbg(ring->dev->wl,
+			       "Injecting TX ring overflow on "
+			       "DMA controller %d\n", ring->index);
+			return 1;
+		}
 	}
+#endif /* CONFIG_BCM43XX_DEBUG */
+	return 0;
+}
+
+int bcm43xx_dma_tx(struct bcm43xx_wldev *dev,
+		   struct sk_buff *skb,
+		   struct ieee80211_tx_control *ctl)
+{
+	struct bcm43xx_dmaring *ring;
+	int err = 0;
+	unsigned long flags;
+
+	ring = priority_to_txring(dev, ctl->queue);
+	spin_lock_irqsave(&ring->lock, flags);
+	BCM43xx_WARN_ON(!ring->tx);
+	if (unlikely(free_slots(ring) < SLOTS_PER_PACKET)) {
+		bcmwarn(dev->wl, "DMA queue overflow\n");
+		err = -ENOSPC;
+		goto out_unlock;
+	}
+	/* Check if the queue was stopped in mac80211,
+	 * but we got called nevertheless.
+	 * That would be a mac80211 bug. */
+	BCM43xx_BUG_ON(ring->stopped);
 
-	for (i = 0; i < txb->nr_frags; i++) {
-		skb = txb->fragments[i];
-		/* Take skb from ieee80211_txb_free */
-		txb->fragments[i] = NULL;
-		dma_tx_fragment(ring, skb, i);
+	err = dma_tx_fragment(ring, skb, ctl);
+	if (unlikely(err)) {
+		bcmerr(dev->wl, "DMA tx mapping failure\n");
+		goto out_unlock;
+	}
+	ring->nr_tx_packets++;
+	if ((free_slots(ring) < SLOTS_PER_PACKET) ||
+	    should_inject_overflow(ring)) {
+		/* This TX ring is full. */
+		ieee80211_stop_queue(dev->wl->hw, txring_to_priority(ring));
+		ring->stopped = 1;
+		if (bcm43xx_debug(dev, BCM43xx_DBG_DMAVERBOSE))
+			bcmdbg(dev->wl, "Stopped TX ring %d\n",
+			       ring->index);
 	}
-	ieee80211_txb_free(txb);
+out_unlock:
+	spin_unlock_irqrestore(&ring->lock, flags);
 
-	return 0;
+	return err;
 }
 
-void bcm43xx_dma_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
+void bcm43xx_dma_handle_txstatus(struct bcm43xx_wldev *dev,
+				 const struct bcm43xx_txstatus *status)
 {
+	const struct bcm43xx_dma_ops *ops;
 	struct bcm43xx_dmaring *ring;
 	struct bcm43xx_dmadesc_generic *desc;
 	struct bcm43xx_dmadesc_meta *meta;
-	int is_last_fragment;
 	int slot;
-	u32 tmp;
 
-	ring = parse_cookie(bcm, status->cookie, &slot);
-	assert(ring);
-	assert(ring->tx);
+	ring = parse_cookie(dev, status->cookie, &slot);
+	if (unlikely(!ring))
+		return;
+	BCM43xx_WARN_ON(!irqs_disabled());
+	spin_lock(&ring->lock);
+
+	BCM43xx_WARN_ON(!ring->tx);
+	ops = ring->ops;
 	while (1) {
-		assert(slot >= 0 && slot < ring->nr_slots);
-		desc = bcm43xx_dma_idx2desc(ring, slot, &meta);
+		BCM43xx_WARN_ON(!(slot >= 0 && slot < ring->nr_slots));
+		desc = ops->idx2desc(ring, slot, &meta);
 
-		if (ring->dma64) {
-			tmp = le32_to_cpu(desc->dma64.control0);
-			is_last_fragment = !!(tmp & BCM43xx_DMA64_DCTL0_FRAMEEND);
+		if (meta->skb)
+			unmap_descbuffer(ring, meta->dmaaddr,
+					 meta->skb->len, 1);
+		else
+			unmap_descbuffer(ring, meta->dmaaddr,
+					 sizeof(struct bcm43xx_txhdr_fw3), 1);
+
+		if (meta->is_last_fragment) {
+			BCM43xx_WARN_ON(!meta->skb);
+			/* Call back to inform the ieee80211 subsystem about the
+			 * status of the transmission.
+			 * Some fields of txstat are already filled in dma_tx().
+			 */
+			if (status->acked)
+				meta->txstat.flags |= IEEE80211_TX_STATUS_ACK;
+			else
+				if (dev->short_preamble) {
+					if (status->frame_count >=
+					    dev->short_retry_limit)
+						meta->txstat.excessive_retries = 1;
+				} else {
+					if (status->frame_count >=
+					    dev->long_retry_limit)
+						meta->txstat.excessive_retries = 1;
+				}
+			meta->txstat.retry_count = status->frame_count - 1;
+			ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb,
+						    &(meta->txstat));
+			/* skb is freed by ieee80211_tx_status_irqsafe() */
+			meta->skb = NULL;
 		} else {
-			tmp = le32_to_cpu(desc->dma32.control);
-			is_last_fragment = !!(tmp & BCM43xx_DMA32_DCTL_FRAMEEND);
+			/* No need to call free_descriptor_buffer here, as
+			 * this is only the txhdr, which is not allocated.
+			 */
+			BCM43xx_WARN_ON(meta->skb != NULL);
 		}
-		unmap_descbuffer(ring, meta->dmaaddr, meta->skb->len, 1);
-		free_descriptor_buffer(ring, meta, 1);
-		/* Everything belonging to the slot is unmapped
-		 * and freed, so we can return it.
-		 */
-		return_slot(ring, slot);
 
-		if (is_last_fragment)
+		/* Everything unmapped and free'd. So it's not used anymore. */
+		ring->used_slots--;
+
+		if (meta->is_last_fragment)
 			break;
 		slot = next_slot(ring, slot);
 	}
-	bcm->stats.last_tx = jiffies;
+	dev->stats.last_tx = jiffies;
+	if (ring->stopped) {
+		BCM43xx_WARN_ON(free_slots(ring) < SLOTS_PER_PACKET);
+		ieee80211_wake_queue(dev->wl->hw, txring_to_priority(ring));
+		ring->stopped = 0;
+		if (bcm43xx_debug(dev, BCM43xx_DBG_DMAVERBOSE))
+			bcmdbg(dev->wl, "Woke up TX ring %d\n",
+			       ring->index);
+	}
+
+	spin_unlock(&ring->lock);
+}
+
+void bcm43xx_dma_get_tx_stats(struct bcm43xx_wldev *dev,
+			      struct ieee80211_tx_queue_stats *stats)
+{
+	const int nr_queues = dev->wl->hw->queues;
+	struct bcm43xx_dmaring *ring;
+	struct ieee80211_tx_queue_stats_data *data;
+	unsigned long flags;
+	int i;
+
+	for (i = 0; i < nr_queues; i++) {
+		data = &(stats->data[i]);
+		ring = priority_to_txring(dev, i);
+
+		spin_lock_irqsave(&ring->lock, flags);
+		data->len = ring->used_slots / SLOTS_PER_PACKET;
+		data->limit = ring->nr_slots / SLOTS_PER_PACKET;
+		data->count = ring->nr_tx_packets;
+		spin_unlock_irqrestore(&ring->lock, flags);
+	}
 }
 
 static void dma_rx(struct bcm43xx_dmaring *ring,
 		   int *slot)
 {
+	const struct bcm43xx_dma_ops *ops = ring->ops;
 	struct bcm43xx_dmadesc_generic *desc;
 	struct bcm43xx_dmadesc_meta *meta;
-	struct bcm43xx_rxhdr *rxhdr;
+	struct bcm43xx_rxhdr_fw3 *rxhdr;
 	struct sk_buff *skb;
 	u16 len;
 	int err;
 	dma_addr_t dmaaddr;
 
-	desc = bcm43xx_dma_idx2desc(ring, *slot, &meta);
+	desc = ops->idx2desc(ring, *slot, &meta);
 
 	sync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);
 	skb = meta->skb;
 
 	if (ring->index == 3) {
 		/* We received an xmit status. */
-		struct bcm43xx_hwxmitstatus *hw = (struct bcm43xx_hwxmitstatus *)skb->data;
-		struct bcm43xx_xmitstatus stat;
+		struct bcm43xx_hwtxstatus *hw =
+				(struct bcm43xx_hwtxstatus *)skb->data;
 		int i = 0;
 
-		stat.cookie = le16_to_cpu(hw->cookie);
-		while (stat.cookie == 0) {
-			if (unlikely(++i >= 10000)) {
-				assert(0);
+		while (hw->cookie == 0) {
+			if (i > 100)
 				break;
-			}
+			i++;
 			udelay(2);
 			barrier();
-			stat.cookie = le16_to_cpu(hw->cookie);
 		}
-		stat.flags = hw->flags;
-		stat.cnt1 = hw->cnt1;
-		stat.cnt2 = hw->cnt2;
-		stat.seq = le16_to_cpu(hw->seq);
-		stat.unknown = le16_to_cpu(hw->unknown);
-
-		bcm43xx_debugfs_log_txstat(ring->bcm, &stat);
-		bcm43xx_dma_handle_xmitstatus(ring->bcm, &stat);
+		bcm43xx_handle_hwtxstatus(ring->dev, hw);
 		/* recycle the descriptor buffer. */
 		sync_descbuffer_for_device(ring, meta->dmaaddr, ring->rx_buffersize);
 
 		return;
 	}
-	rxhdr = (struct bcm43xx_rxhdr *)skb->data;
-	len = le16_to_cpu(rxhdr->frame_length);
+	rxhdr = (struct bcm43xx_rxhdr_fw3 *)skb->data;
+	len = le16_to_cpu(rxhdr->frame_len);
 	if (len == 0) {
 		int i = 0;
 
 		do {
 			udelay(2);
 			barrier();
-			len = le16_to_cpu(rxhdr->frame_length);
+			len = le16_to_cpu(rxhdr->frame_len);
 		} while (len == 0 && i++ < 5);
 		if (unlikely(len == 0)) {
 			/* recycle the descriptor buffer. */
@@ -1153,7 +1446,7 @@ static void dma_rx(struct bcm43xx_dmarin
 		s32 tmp = len;
 
 		while (1) {
-			desc = bcm43xx_dma_idx2desc(ring, *slot, &meta);
+			desc = ops->idx2desc(ring, *slot, &meta);
 			/* recycle the descriptor buffer. */
 			sync_descbuffer_for_device(ring, meta->dmaaddr,
 						   ring->rx_buffersize);
@@ -1163,17 +1456,16 @@ static void dma_rx(struct bcm43xx_dmarin
 			if (tmp <= 0)
 				break;
 		}
-		printkl(KERN_ERR PFX "DMA RX buffer too small "
-			"(len: %u, buffer: %u, nr-dropped: %d)\n",
-			len, ring->rx_buffersize, cnt);
+		bcmerr(ring->dev->wl, "DMA RX buffer too small "
+		       "(len: %u, buffer: %u, nr-dropped: %d)\n",
+		       len, ring->rx_buffersize, cnt);
 		goto drop;
 	}
-	len -= IEEE80211_FCS_LEN;
 
 	dmaaddr = meta->dmaaddr;
 	err = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);
 	if (unlikely(err)) {
-		dprintkl(KERN_ERR PFX "DMA RX: setup_rx_descbuffer() failed\n");
+		bcmdbg(ring->dev->wl, "DMA RX: setup_rx_descbuffer() failed\n");
 		sync_descbuffer_for_device(ring, dmaaddr,
 					   ring->rx_buffersize);
 		goto drop;
@@ -1183,81 +1475,68 @@ static void dma_rx(struct bcm43xx_dmarin
 	skb_put(skb, len + ring->frameoffset);
 	skb_pull(skb, ring->frameoffset);
 
-	err = bcm43xx_rx(ring->bcm, skb, rxhdr);
-	if (err) {
-		dev_kfree_skb_irq(skb);
-		goto drop;
-	}
-
+	bcm43xx_rx(ring->dev, skb, rxhdr);
 drop:
 	return;
 }
 
 void bcm43xx_dma_rx(struct bcm43xx_dmaring *ring)
 {
-	u32 status;
-	u16 descptr;
+	const struct bcm43xx_dma_ops *ops = ring->ops;
 	int slot, current_slot;
-#ifdef CONFIG_BCM43XX_DEBUG
 	int used_slots = 0;
-#endif
 
-	assert(!ring->tx);
-	if (ring->dma64) {
-		status = bcm43xx_dma_read(ring, BCM43xx_DMA64_RXSTATUS);
-		descptr = (status & BCM43xx_DMA64_RXSTATDPTR);
-		current_slot = descptr / sizeof(struct bcm43xx_dmadesc64);
-	} else {
-		status = bcm43xx_dma_read(ring, BCM43xx_DMA32_RXSTATUS);
-		descptr = (status & BCM43xx_DMA32_RXDPTR);
-		current_slot = descptr / sizeof(struct bcm43xx_dmadesc32);
-	}
-	assert(current_slot >= 0 && current_slot < ring->nr_slots);
+	BCM43xx_WARN_ON(ring->tx);
+	current_slot = ops->get_current_rxslot(ring);
+	BCM43xx_WARN_ON(!(current_slot >= 0 && current_slot < ring->nr_slots));
 
 	slot = ring->current_slot;
 	for ( ; slot != current_slot; slot = next_slot(ring, slot)) {
 		dma_rx(ring, &slot);
-#ifdef CONFIG_BCM43XX_DEBUG
-		if (++used_slots > ring->max_used_slots)
-			ring->max_used_slots = used_slots;
-#endif
-	}
-	if (ring->dma64) {
-		bcm43xx_dma_write(ring, BCM43xx_DMA64_RXINDEX,
-				(u32)(slot * sizeof(struct bcm43xx_dmadesc64)));
-	} else {
-		bcm43xx_dma_write(ring, BCM43xx_DMA32_RXINDEX,
-				(u32)(slot * sizeof(struct bcm43xx_dmadesc32)));
+		update_max_used_slots(ring, ++used_slots);
 	}
+	ops->set_current_rxslot(ring, slot);
 	ring->current_slot = slot;
 }
 
-void bcm43xx_dma_tx_suspend(struct bcm43xx_dmaring *ring)
+static void bcm43xx_dma_tx_suspend_ring(struct bcm43xx_dmaring *ring)
 {
-	assert(ring->tx);
-	bcm43xx_power_saving_ctl_bits(ring->bcm, -1, 1);
-	if (ring->dma64) {
-		bcm43xx_dma_write(ring, BCM43xx_DMA64_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA64_TXCTL)
-				| BCM43xx_DMA64_TXSUSPEND);
-	} else {
-		bcm43xx_dma_write(ring, BCM43xx_DMA32_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA32_TXCTL)
-				| BCM43xx_DMA32_TXSUSPEND);
-	}
+	unsigned long flags;
+
+	spin_lock_irqsave(&ring->lock, flags);
+	BCM43xx_WARN_ON(!ring->tx);
+	ring->ops->tx_suspend(ring);
+	spin_unlock_irqrestore(&ring->lock, flags);
 }
 
-void bcm43xx_dma_tx_resume(struct bcm43xx_dmaring *ring)
+static void bcm43xx_dma_tx_resume_ring(struct bcm43xx_dmaring *ring)
 {
-	assert(ring->tx);
-	if (ring->dma64) {
-		bcm43xx_dma_write(ring, BCM43xx_DMA64_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA64_TXCTL)
-				& ~BCM43xx_DMA64_TXSUSPEND);
-	} else {
-		bcm43xx_dma_write(ring, BCM43xx_DMA32_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA32_TXCTL)
-				& ~BCM43xx_DMA32_TXSUSPEND);
-	}
-	bcm43xx_power_saving_ctl_bits(ring->bcm, -1, -1);
+	unsigned long flags;
+
+	spin_lock_irqsave(&ring->lock, flags);
+	BCM43xx_WARN_ON(!ring->tx);
+	ring->ops->tx_resume(ring);
+	spin_unlock_irqrestore(&ring->lock, flags);
+}
+
+void bcm43xx_dma_tx_suspend(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_power_saving_ctl_bits(dev, -1, 1);
+	bcm43xx_dma_tx_suspend_ring(dev->dma.tx_ring0);
+	bcm43xx_dma_tx_suspend_ring(dev->dma.tx_ring1);
+	bcm43xx_dma_tx_suspend_ring(dev->dma.tx_ring2);
+	bcm43xx_dma_tx_suspend_ring(dev->dma.tx_ring3);
+	bcm43xx_dma_tx_suspend_ring(dev->dma.tx_ring4);
+	bcm43xx_dma_tx_suspend_ring(dev->dma.tx_ring5);
+}
+
+void bcm43xx_dma_tx_resume(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_dma_tx_resume_ring(dev->dma.tx_ring5);
+	bcm43xx_dma_tx_resume_ring(dev->dma.tx_ring4);
+	bcm43xx_dma_tx_resume_ring(dev->dma.tx_ring3);
+	bcm43xx_dma_tx_resume_ring(dev->dma.tx_ring2);
+	bcm43xx_dma_tx_resume_ring(dev->dma.tx_ring1);
+	bcm43xx_dma_tx_resume_ring(dev->dma.tx_ring0);
+	bcm43xx_power_saving_ctl_bits(dev, -1, -1);
 }
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_dma.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_dma.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_dma.h
@@ -4,10 +4,11 @@
 #include <linux/list.h>
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
-#include <linux/dma-mapping.h>
 #include <linux/linkage.h>
 #include <asm/atomic.h>
 
+#include "bcm43xx.h"
+
 
 /* DMA-Interrupt reasons. */
 #define BCM43xx_DMAIRQ_FATALMASK	((1 << 10) | (1 << 11) | (1 << 12) \
@@ -80,12 +81,6 @@ struct bcm43xx_dmadesc32 {
 #define BCM43xx_DMA32_DCTL_FRAMEEND		0x40000000
 #define BCM43xx_DMA32_DCTL_FRAMESTART		0x80000000
 
-/* Address field Routing value. */
-#define BCM43xx_DMA32_ROUTING			0xC0000000
-#define BCM43xx_DMA32_ROUTING_SHIFT		30
-#define		BCM43xx_DMA32_NOTRANS		0x00000000
-#define		BCM43xx_DMA32_CLIENTTRANS	0x40000000
-
 
 
 /*** 64-bit DMA Engine. ***/
@@ -161,12 +156,6 @@ struct bcm43xx_dmadesc64 {
 #define BCM43xx_DMA64_DCTL1_ADDREXT_MASK	0x00030000
 #define BCM43xx_DMA64_DCTL1_ADDREXT_SHIFT	16
 
-/* Address field Routing value. */
-#define BCM43xx_DMA64_ROUTING			0xC0000000
-#define BCM43xx_DMA64_ROUTING_SHIFT		30
-#define		BCM43xx_DMA64_NOTRANS		0x00000000
-#define		BCM43xx_DMA64_CLIENTTRANS	0x80000000
-
 
 
 struct bcm43xx_dmadesc_generic {
@@ -184,14 +173,10 @@ struct bcm43xx_dmadesc_generic {
 
 
 /* DMA engine tuning knobs */
-#define BCM43xx_TXRING_SLOTS		512
+#define BCM43xx_TXRING_SLOTS		128
 #define BCM43xx_RXRING_SLOTS		64
 #define BCM43xx_DMA0_RX_BUFFERSIZE	(2304 + 100)
 #define BCM43xx_DMA3_RX_BUFFERSIZE	16
-/* Suspend the tx queue, if less than this percent slots are free. */
-#define BCM43xx_TXSUSPEND_PERCENT	20
-/* Resume the tx queue, if more than this percent slots are free. */
-#define BCM43xx_TXRESUME_PERCENT	50
 
 
 
@@ -200,7 +185,7 @@ struct bcm43xx_dmadesc_generic {
 
 struct sk_buff;
 struct bcm43xx_private;
-struct bcm43xx_xmitstatus;
+struct bcm43xx_txstatus;
 
 
 struct bcm43xx_dmadesc_meta {
@@ -208,15 +193,42 @@ struct bcm43xx_dmadesc_meta {
 	struct sk_buff *skb;
 	/* DMA base bus-address of the descriptor buffer. */
 	dma_addr_t dmaaddr;
+	/* ieee80211 TX status. Only used once per 802.11 frag. */
+	bool is_last_fragment;
+	struct ieee80211_tx_status txstat;
+};
+
+struct bcm43xx_dmaring;
+
+/* Lowlevel DMA operations that differ between 32bit and 64bit DMA. */
+struct bcm43xx_dma_ops {
+	struct bcm43xx_dmadesc_generic * (*idx2desc)
+					 (struct bcm43xx_dmaring *ring,
+					 int slot,
+					 struct bcm43xx_dmadesc_meta **meta);
+	void (*fill_descriptor)(struct bcm43xx_dmaring *ring,
+				struct bcm43xx_dmadesc_generic *desc,
+				dma_addr_t dmaaddr, u16 bufsize,
+				int start, int end, int irq);
+	void (*poke_tx)(struct bcm43xx_dmaring *ring, int slot);
+	void (*tx_suspend)(struct bcm43xx_dmaring *ring);
+	void (*tx_resume)(struct bcm43xx_dmaring *ring);
+	int (*get_current_rxslot)(struct bcm43xx_dmaring *ring);
+	void (*set_current_rxslot)(struct bcm43xx_dmaring *ring, int slot);
 };
 
 struct bcm43xx_dmaring {
+	/* Lowlevel DMA ops. */
+	const struct bcm43xx_dma_ops *ops;
 	/* Kernel virtual base address of the ring memory. */
 	void *descbase;
 	/* Meta data about all descriptors. */
 	struct bcm43xx_dmadesc_meta *meta;
-	/* DMA Routing value. */
-	u32 routing;
+	/* Cache of TX headers for each slot.
+	 * This is to avoid an allocation on each TX.
+	 * This is NULL for an RX ring.
+	 */
+	u8 *txhdr_cache;
 	/* (Unadjusted) DMA base bus-address of the ring memory. */
 	dma_addr_t dmabase;
 	/* Number of descriptor slots in the ring. */
@@ -225,9 +237,8 @@ struct bcm43xx_dmaring {
 	int used_slots;
 	/* Currently used slot in the ring. */
 	int current_slot;
-	/* Marks to suspend/resume the queue. */
-	int suspend_mark;
-	int resume_mark;
+	/* Total number of packets sent. Statistics only. */
+	unsigned int nr_tx_packets;
 	/* Frameoffset in octets. */
 	u32 frameoffset;
 	/* Descriptor buffer size. */
@@ -237,136 +248,105 @@ struct bcm43xx_dmaring {
 	/* DMA controller index number (0-5). */
 	int index;
 	/* Boolean. Is this a TX ring? */
-	u8 tx;
+	bool tx;
 	/* Boolean. 64bit DMA if true, 32bit DMA otherwise. */
-	u8 dma64;
-	/* Boolean. Are transfers suspended on this ring? */
-	u8 suspended;
-	struct bcm43xx_private *bcm;
+	bool dma64;
+	/* Boolean. Is this ring stopped at ieee80211 level? */
+	bool stopped;
+	/* Lock, only used for TX. */
+	spinlock_t lock;
+	struct bcm43xx_wldev *dev;
 #ifdef CONFIG_BCM43XX_DEBUG
 	/* Maximum number of used slots. */
 	int max_used_slots;
+	/* Last time we injected a ring overflow. */
+	unsigned long last_injected_overflow;
 #endif /* CONFIG_BCM43XX_DEBUG*/
 };
 
 
 static inline
-int bcm43xx_dma_desc2idx(struct bcm43xx_dmaring *ring,
-			 struct bcm43xx_dmadesc_generic *desc)
-{
-	if (ring->dma64) {
-		struct bcm43xx_dmadesc64 *dd64 = ring->descbase;
-		return (int)(&(desc->dma64) - dd64);
-	} else {
-		struct bcm43xx_dmadesc32 *dd32 = ring->descbase;
-		return (int)(&(desc->dma32) - dd32);
-	}
-}
-
-static inline
-struct bcm43xx_dmadesc_generic * bcm43xx_dma_idx2desc(struct bcm43xx_dmaring *ring,
-						      int slot,
-						      struct bcm43xx_dmadesc_meta **meta)
-{
-	*meta = &(ring->meta[slot]);
-	if (ring->dma64) {
-		struct bcm43xx_dmadesc64 *dd64 = ring->descbase;
-		return (struct bcm43xx_dmadesc_generic *)(&(dd64[slot]));
-	} else {
-		struct bcm43xx_dmadesc32 *dd32 = ring->descbase;
-		return (struct bcm43xx_dmadesc_generic *)(&(dd32[slot]));
-	}
-}
-
-static inline
 u32 bcm43xx_dma_read(struct bcm43xx_dmaring *ring,
 		     u16 offset)
 {
-	return bcm43xx_read32(ring->bcm, ring->mmio_base + offset);
+	return bcm43xx_read32(ring->dev, ring->mmio_base + offset);
 }
 
 static inline
 void bcm43xx_dma_write(struct bcm43xx_dmaring *ring,
 		       u16 offset, u32 value)
 {
-	bcm43xx_write32(ring->bcm, ring->mmio_base + offset, value);
+	bcm43xx_write32(ring->dev, ring->mmio_base + offset, value);
 }
 
 
-int bcm43xx_dma_init(struct bcm43xx_private *bcm);
-void bcm43xx_dma_free(struct bcm43xx_private *bcm);
+int bcm43xx_dma_init(struct bcm43xx_wldev *dev);
+void bcm43xx_dma_free(struct bcm43xx_wldev *dev);
 
-int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_private *bcm,
+int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_wldev *dev,
 				   u16 dmacontroller_mmio_base,
 				   int dma64);
-int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_private *bcm,
+int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_wldev *dev,
 				   u16 dmacontroller_mmio_base,
 				   int dma64);
 
 u16 bcm43xx_dmacontroller_base(int dma64bit, int dmacontroller_idx);
 
-void bcm43xx_dma_tx_suspend(struct bcm43xx_dmaring *ring);
-void bcm43xx_dma_tx_resume(struct bcm43xx_dmaring *ring);
+void bcm43xx_dma_tx_suspend(struct bcm43xx_wldev *dev);
+void bcm43xx_dma_tx_resume(struct bcm43xx_wldev *dev);
 
-void bcm43xx_dma_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status);
+void bcm43xx_dma_get_tx_stats(struct bcm43xx_wldev *dev,
+			      struct ieee80211_tx_queue_stats *stats);
 
-int bcm43xx_dma_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb);
-void bcm43xx_dma_rx(struct bcm43xx_dmaring *ring);
+int bcm43xx_dma_tx(struct bcm43xx_wldev *dev,
+		   struct sk_buff *skb,
+		   struct ieee80211_tx_control *ctl);
+void bcm43xx_dma_handle_txstatus(struct bcm43xx_wldev *dev,
+				 const struct bcm43xx_txstatus *status);
 
-/* Helper function that returns the dma mask for this device. */
-static inline
-u64 bcm43xx_get_supported_dma_mask(struct bcm43xx_private *bcm)
-{
-	int dma64 = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH) &
-				   BCM43xx_SBTMSTATEHIGH_DMA64BIT;
-	u16 mmio_base = bcm43xx_dmacontroller_base(dma64, 0);
-	u32 mask = BCM43xx_DMA32_TXADDREXT_MASK;
-
-	if (dma64)
-		return DMA_64BIT_MASK;
-	bcm43xx_write32(bcm, mmio_base + BCM43xx_DMA32_TXCTL, mask);
-	if (bcm43xx_read32(bcm, mmio_base + BCM43xx_DMA32_TXCTL) & mask)
-		return DMA_32BIT_MASK;
-	return DMA_30BIT_MASK;
-}
+void bcm43xx_dma_rx(struct bcm43xx_dmaring *ring);
 
 #else /* CONFIG_BCM43XX_DMA */
 
 
 static inline
-int bcm43xx_dma_init(struct bcm43xx_private *bcm)
+int bcm43xx_dma_init(struct bcm43xx_wldev *dev)
 {
 	return 0;
 }
 static inline
-void bcm43xx_dma_free(struct bcm43xx_private *bcm)
+void bcm43xx_dma_free(struct bcm43xx_wldev *dev)
 {
 }
 static inline
-int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_private *bcm,
+int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_wldev *dev,
 				   u16 dmacontroller_mmio_base,
 				   int dma64)
 {
 	return 0;
 }
 static inline
-int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_private *bcm,
+int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_wldev *dev,
 				   u16 dmacontroller_mmio_base,
 				   int dma64)
 {
 	return 0;
 }
 static inline
-int bcm43xx_dma_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
+void bcm43xx_dma_get_tx_stats(struct bcm43xx_wldev *dev,
+			      struct ieee80211_tx_queue_stats *stats)
+{
+}
+static inline
+int bcm43xx_dma_tx(struct bcm43xx_wldev *dev,
+		   struct sk_buff *skb,
+		   struct ieee80211_tx_control *ctl)
 {
 	return 0;
 }
 static inline
-void bcm43xx_dma_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
+void bcm43xx_dma_handle_txstatus(struct bcm43xx_wldev *dev,
+				 const struct bcm43xx_txstatus *status)
 {
 }
 static inline
@@ -374,11 +354,11 @@ void bcm43xx_dma_rx(struct bcm43xx_dmari
 {
 }
 static inline
-void bcm43xx_dma_tx_suspend(struct bcm43xx_dmaring *ring)
+void bcm43xx_dma_tx_suspend(struct bcm43xx_wldev *dev)
 {
 }
 static inline
-void bcm43xx_dma_tx_resume(struct bcm43xx_dmaring *ring)
+void bcm43xx_dma_tx_resume(struct bcm43xx_wldev *dev)
 {
 }
 



From Larry.Finger at lwfinger.net  Thu Aug  2 17:53:53 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:53:53 -0500
Subject: [RFC 7/10] Port of bcm43xx from softmac to mac80211
Message-ID: <46b1fe11.Gsl6cDeg5nKUtdi+%Larry.Finger@lwfinger.net>

This if file 7 of 10 of the port of the bcm43xx driver from softmac
to mac80211.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_pio.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_pio.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_pio.c
@@ -4,7 +4,7 @@
 
   PIO Transmission
 
-  Copyright (c) 2005 Michael Buesch <mbuesch at freenet.de>
+  Copyright (c) 2005 Michael Buesch <mb at bu3sch.de>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -27,7 +27,6 @@
 #include "bcm43xx_pio.h"
 #include "bcm43xx_main.h"
 #include "bcm43xx_xmit.h"
-#include "bcm43xx_power.h"
 
 #include <linux/delay.h>
 
@@ -54,19 +53,20 @@ static void tx_octet(struct bcm43xx_pioq
 	}
 }
 
-static u16 tx_get_next_word(struct bcm43xx_txhdr *txhdr,
+static u16 tx_get_next_word(const u8 *txhdr,
 			    const u8 *packet,
+			    size_t txhdr_size,
 			    unsigned int *pos)
 {
 	const u8 *source;
 	unsigned int i = *pos;
 	u16 ret;
 
-	if (i < sizeof(*txhdr)) {
-		source = (const u8 *)txhdr;
+	if (i < txhdr_size) {
+		source = txhdr;
 	} else {
 		source = packet;
-		i -= sizeof(*txhdr);
+		i -= txhdr_size;
 	}
 	ret = le16_to_cpu( *((u16 *)(source + i)) );
 	*pos += 2;
@@ -75,7 +75,7 @@ static u16 tx_get_next_word(struct bcm43
 }
 
 static void tx_data(struct bcm43xx_pioqueue *queue,
-		    struct bcm43xx_txhdr *txhdr,
+		    u8 *txhdr,
 		    const u8 *packet,
 		    unsigned int octets)
 {
@@ -83,18 +83,21 @@ static void tx_data(struct bcm43xx_pioqu
 	unsigned int i = 0;
 
 	if (queue->need_workarounds) {
-		data = tx_get_next_word(txhdr, packet, &i);
+		data = tx_get_next_word(txhdr, packet,
+					sizeof(struct bcm43xx_txhdr_fw3), &i);
 		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA, data);
 	}
 	bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
 			  BCM43xx_PIO_TXCTL_WRITELO |
 			  BCM43xx_PIO_TXCTL_WRITEHI);
 	while (i < octets - 1) {
-		data = tx_get_next_word(txhdr, packet, &i);
+		data = tx_get_next_word(txhdr, packet,
+					sizeof(struct bcm43xx_txhdr_fw3), &i);
 		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA, data);
 	}
 	if (octets % 2)
-		tx_octet(queue, packet[octets - sizeof(*txhdr) - 1]);
+		tx_octet(queue, packet[octets -
+			 sizeof(struct bcm43xx_txhdr_fw3) - 1]);
 }
 
 static void tx_complete(struct bcm43xx_pioqueue *queue,
@@ -135,21 +138,21 @@ static u16 generate_cookie(struct bcm43x
 		cookie = 0x3000;
 		break;
 	default:
-		assert(0);
+		BCM43xx_WARN_ON(1);
 	}
 	packetindex = pio_txpacket_getindex(packet);
-	assert(((u16)packetindex & 0xF000) == 0x0000);
+	BCM43xx_WARN_ON(!(((u16)packetindex & 0xF000) == 0x0000));
 	cookie |= (u16)packetindex;
 
 	return cookie;
 }
 
 static
-struct bcm43xx_pioqueue * parse_cookie(struct bcm43xx_private *bcm,
+struct bcm43xx_pioqueue *parse_cookie(struct bcm43xx_wldev *dev,
 				       u16 cookie,
 				       struct bcm43xx_pio_txpacket **packet)
 {
-	struct bcm43xx_pio *pio = bcm43xx_current_pio(bcm);
+	struct bcm43xx_pio *pio = &dev->pio;
 	struct bcm43xx_pioqueue *queue = NULL;
 	int packetindex;
 
@@ -167,33 +170,42 @@ struct bcm43xx_pioqueue * parse_cookie(s
 		queue = pio->queue3;
 		break;
 	default:
-		assert(0);
+		BCM43xx_WARN_ON(1);
 	}
 	packetindex = (cookie & 0x0FFF);
-	assert(packetindex >= 0 && packetindex < BCM43xx_PIO_MAXTXPACKETS);
+	BCM43xx_WARN_ON(!(packetindex >= 0 && packetindex
+			  < BCM43xx_PIO_MAXTXPACKETS));
 	*packet = &(queue->tx_packets_cache[packetindex]);
 
 	return queue;
 }
 
+union txhdr_union {
+	struct bcm43xx_txhdr_fw3 txhdr_fw3;
+};
+
 static void pio_tx_write_fragment(struct bcm43xx_pioqueue *queue,
 				  struct sk_buff *skb,
-				  struct bcm43xx_pio_txpacket *packet)
+				  struct bcm43xx_pio_txpacket *packet,
+				  size_t txhdr_size)
 {
-	struct bcm43xx_txhdr txhdr;
+	union txhdr_union txhdr_data;
+	u8 *txhdr = NULL;
 	unsigned int octets;
 
-	assert(skb_shinfo(skb)->nr_frags == 0);
-	bcm43xx_generate_txhdr(queue->bcm,
-			       &txhdr, skb->data, skb->len,
-			       (packet->xmitted_frags == 0),
+	txhdr = (u8 *)(&txhdr_data.txhdr_fw3);
+
+	BCM43xx_WARN_ON(skb_shinfo(skb)->nr_frags != 0);
+	bcm43xx_generate_txhdr(queue->dev,
+			       txhdr, skb->data, skb->len,
+			       &packet->txstat.control,
 			       generate_cookie(queue, packet));
 
 	tx_start(queue);
-	octets = skb->len + sizeof(txhdr);
+	octets = skb->len + txhdr_size;
 	if (queue->need_workarounds)
 		octets--;
-	tx_data(queue, &txhdr, (u8 *)skb->data, octets);
+	tx_data(queue, txhdr, (u8 *)skb->data, octets);
 	tx_complete(queue, skb);
 }
 
@@ -202,52 +214,53 @@ static void free_txpacket(struct bcm43xx
 {
 	struct bcm43xx_pioqueue *queue = packet->queue;
 
-	ieee80211_txb_free(packet->txb);
+	if (packet->skb) {
+		if (irq_context)
+			dev_kfree_skb_irq(packet->skb);
+		else
+			dev_kfree_skb(packet->skb);
+	}
 	list_move(&packet->list, &queue->txfree);
 	queue->nr_txfree++;
-
-	assert(queue->tx_devq_used >= packet->xmitted_octets);
-	assert(queue->tx_devq_packets >= packet->xmitted_frags);
-	queue->tx_devq_used -= packet->xmitted_octets;
-	queue->tx_devq_packets -= packet->xmitted_frags;
 }
 
 static int pio_tx_packet(struct bcm43xx_pio_txpacket *packet)
 {
 	struct bcm43xx_pioqueue *queue = packet->queue;
-	struct ieee80211_txb *txb = packet->txb;
-	struct sk_buff *skb;
+	struct sk_buff *skb = packet->skb;
 	u16 octets;
-	int i;
 
-	for (i = packet->xmitted_frags; i < txb->nr_frags; i++) {
-		skb = txb->fragments[i];
-
-		octets = (u16)skb->len + sizeof(struct bcm43xx_txhdr);
-		assert(queue->tx_devq_size >= octets);
-		assert(queue->tx_devq_packets <= BCM43xx_PIO_MAXTXDEVQPACKETS);
-		assert(queue->tx_devq_used <= queue->tx_devq_size);
-		/* Check if there is sufficient free space on the device
-		 * TX queue. If not, return and let the TX tasklet
-		 * retry later.
-		 */
-		if (queue->tx_devq_packets == BCM43xx_PIO_MAXTXDEVQPACKETS)
-			return -EBUSY;
-		if (queue->tx_devq_used + octets > queue->tx_devq_size)
-			return -EBUSY;
-		/* Now poke the device. */
-		pio_tx_write_fragment(queue, skb, packet);
+	octets = (u16)skb->len + sizeof(struct bcm43xx_txhdr_fw3);
+	if (queue->tx_devq_size < octets) {
+		bcmwarn(queue->dev->wl, "PIO queue too small. "
+			"Dropping packet.\n");
+		/* Drop it silently (return success) */
+		free_txpacket(packet, 1);
+		return 0;
+	}
+	BCM43xx_WARN_ON(queue->tx_devq_packets > BCM43xx_PIO_MAXTXDEVQPACKETS);
+	BCM43xx_WARN_ON(queue->tx_devq_used > queue->tx_devq_size);
+	/* Check if there is sufficient free space on the device
+	 * TX queue. If not, return and let the TX tasklet
+	 * retry later.
+	 */
+	if (queue->tx_devq_packets == BCM43xx_PIO_MAXTXDEVQPACKETS)
+		return -EBUSY;
+	if (queue->tx_devq_used + octets > queue->tx_devq_size)
+		return -EBUSY;
+	/* Now poke the device. */
+	pio_tx_write_fragment(queue, skb, packet,
+			      sizeof(struct bcm43xx_txhdr_fw3));
 
-		/* Account for the packet size.
-		 * (We must not overflow the device TX queue)
-		 */
-		queue->tx_devq_packets++;
-		queue->tx_devq_used += octets;
+	/* Account for the packet size.
+	 * (We must not overflow the device TX queue)
+	 */
+	queue->tx_devq_packets++;
+	queue->tx_devq_used += octets;
 
-		assert(packet->xmitted_frags < packet->txb->nr_frags);
-		packet->xmitted_frags++;
-		packet->xmitted_octets += octets;
-	}
+	/* Transmission started, everything ok, move the
+	 * packet to the txrunning list.
+	 */
 	list_move_tail(&packet->list, &queue->txrunning);
 
 	return 0;
@@ -256,14 +269,13 @@ static int pio_tx_packet(struct bcm43xx_
 static void tx_tasklet(unsigned long d)
 {
 	struct bcm43xx_pioqueue *queue = (struct bcm43xx_pioqueue *)d;
-	struct bcm43xx_private *bcm = queue->bcm;
+	struct bcm43xx_wldev *dev = queue->dev;
 	unsigned long flags;
 	struct bcm43xx_pio_txpacket *packet, *tmp_packet;
 	int err;
 	u16 txctl;
 
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
 	if (queue->tx_frozen)
 		goto out_unlock;
 	txctl = bcm43xx_pio_read(queue, BCM43xx_PIO_TXCTL);
@@ -271,36 +283,19 @@ static void tx_tasklet(unsigned long d)
 		goto out_unlock;
 
 	list_for_each_entry_safe(packet, tmp_packet, &queue->txqueue, list) {
-		assert(packet->xmitted_frags < packet->txb->nr_frags);
-		if (packet->xmitted_frags == 0) {
-			int i;
-			struct sk_buff *skb;
-
-			/* Check if the device queue is big
-			 * enough for every fragment. If not, drop the
-			 * whole packet.
-			 */
-			for (i = 0; i < packet->txb->nr_frags; i++) {
-				skb = packet->txb->fragments[i];
-				if (unlikely(skb->len > queue->tx_devq_size)) {
-					dprintkl(KERN_ERR PFX "PIO TX device queue too small. "
-							      "Dropping packet.\n");
-					free_txpacket(packet, 1);
-					goto next_packet;
-				}
-			}
-		}
-		/* Try to transmit the packet.
-		 * This may not completely succeed.
+		/* Try to transmit the packet. This can fail, if
+		 * the device queue is full. In case of failure, the
+		 * packet is left in the txqueue.
+		 * If transmission succeed, the packet is moved to txrunning.
+		 * If it is impossible to transmit the packet, it
+		 * is dropped.
 		 */
 		err = pio_tx_packet(packet);
 		if (err)
 			break;
-	next_packet:
-		continue;
 	}
 out_unlock:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
 }
 
 static void setup_txqueues(struct bcm43xx_pioqueue *queue)
@@ -320,7 +315,7 @@ static void setup_txqueues(struct bcm43x
 }
 
 static
-struct bcm43xx_pioqueue * bcm43xx_setup_pioqueue(struct bcm43xx_private *bcm,
+struct bcm43xx_pioqueue *bcm43xx_setup_pioqueue(struct bcm43xx_wldev *dev,
 						 u16 pio_mmio_base)
 {
 	struct bcm43xx_pioqueue *queue;
@@ -331,9 +326,9 @@ struct bcm43xx_pioqueue * bcm43xx_setup_
 	if (!queue)
 		goto out;
 
-	queue->bcm = bcm;
+	queue->dev = dev;
 	queue->mmio_base = pio_mmio_base;
-	queue->need_workarounds = (bcm->current_core->rev < 3);
+	queue->need_workarounds = (dev->dev->id.revision < 3);
 
 	INIT_LIST_HEAD(&queue->txfree);
 	INIT_LIST_HEAD(&queue->txqueue);
@@ -341,19 +336,19 @@ struct bcm43xx_pioqueue * bcm43xx_setup_
 	tasklet_init(&queue->txtask, tx_tasklet,
 		     (unsigned long)queue);
 
-	value = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
+	value = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 	value &= ~BCM43xx_SBF_XFER_REG_BYTESWAP;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, value);
 
-	qsize = bcm43xx_read16(bcm, queue->mmio_base + BCM43xx_PIO_TXQBUFSIZE);
+	qsize = bcm43xx_read16(dev, queue->mmio_base + BCM43xx_PIO_TXQBUFSIZE);
 	if (qsize == 0) {
-		printk(KERN_ERR PFX "ERROR: This card does not support PIO "
-				    "operation mode. Please use DMA mode "
-				    "(module parameter pio=0).\n");
+		bcmerr(dev->wl, "This card does not support PIO "
+		       "operation mode. Please use DMA mode "
+		       "(module parameter pio=0).\n");
 		goto err_freequeue;
 	}
 	if (qsize <= BCM43xx_PIO_TXQADJUST) {
-		printk(KERN_ERR PFX "PIO tx device-queue too small (%u)\n",
+		bcmerr(dev->wl, "PIO tx device-queue too small (%u)\n",
 		       qsize);
 		goto err_freequeue;
 	}
@@ -375,7 +370,6 @@ static void cancel_transfers(struct bcm4
 {
 	struct bcm43xx_pio_txpacket *packet, *tmp_packet;
 
-	netif_tx_disable(queue->bcm->net_dev);
 	tasklet_disable(&queue->txtask);
 
 	list_for_each_entry_safe(packet, tmp_packet, &queue->txrunning, list)
@@ -393,13 +387,13 @@ static void bcm43xx_destroy_pioqueue(str
 	kfree(queue);
 }
 
-void bcm43xx_pio_free(struct bcm43xx_private *bcm)
+void bcm43xx_pio_free(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_pio *pio;
 
-	if (!bcm43xx_using_pio(bcm))
+	if (!bcm43xx_using_pio(dev))
 		return;
-	pio = bcm43xx_current_pio(bcm);
+	pio = &dev->pio;
 
 	bcm43xx_destroy_pioqueue(pio->queue3);
 	pio->queue3 = NULL;
@@ -411,36 +405,36 @@ void bcm43xx_pio_free(struct bcm43xx_pri
 	pio->queue0 = NULL;
 }
 
-int bcm43xx_pio_init(struct bcm43xx_private *bcm)
+int bcm43xx_pio_init(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_pio *pio = bcm43xx_current_pio(bcm);
+	struct bcm43xx_pio *pio = &dev->pio;
 	struct bcm43xx_pioqueue *queue;
 	int err = -ENOMEM;
 
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO1_BASE);
+	queue = bcm43xx_setup_pioqueue(dev, BCM43xx_MMIO_PIO1_BASE);
 	if (!queue)
 		goto out;
 	pio->queue0 = queue;
 
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO2_BASE);
+	queue = bcm43xx_setup_pioqueue(dev, BCM43xx_MMIO_PIO2_BASE);
 	if (!queue)
 		goto err_destroy0;
 	pio->queue1 = queue;
 
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO3_BASE);
+	queue = bcm43xx_setup_pioqueue(dev, BCM43xx_MMIO_PIO3_BASE);
 	if (!queue)
 		goto err_destroy1;
 	pio->queue2 = queue;
 
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO4_BASE);
+	queue = bcm43xx_setup_pioqueue(dev, BCM43xx_MMIO_PIO4_BASE);
 	if (!queue)
 		goto err_destroy2;
 	pio->queue3 = queue;
 
-	if (bcm->current_core->rev < 3)
-		bcm->irq_savedstate |= BCM43xx_IRQ_PIO_WORKAROUND;
+	if (dev->dev->id.revision < 3)
+		dev->irq_savedstate |= BCM43xx_IRQ_PIO_WORKAROUND;
 
-	dprintk(KERN_INFO PFX "PIO initialized\n");
+	bcmdbg(dev->wl, "PIO initialized\n");
 	err = 0;
 out:
 	return err;
@@ -457,48 +451,53 @@ err_destroy0:
 	goto out;
 }
 
-int bcm43xx_pio_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
+int bcm43xx_pio_tx(struct bcm43xx_wldev *dev,
+		   struct sk_buff *skb,
+		   struct ieee80211_tx_control *ctl)
 {
-	struct bcm43xx_pioqueue *queue = bcm43xx_current_pio(bcm)->queue1;
+	struct bcm43xx_pioqueue *queue = dev->pio.queue1;
 	struct bcm43xx_pio_txpacket *packet;
 
-	assert(!queue->tx_suspended);
-	assert(!list_empty(&queue->txfree));
+	BCM43xx_WARN_ON(queue->tx_suspended);
+	BCM43xx_WARN_ON(list_empty(&queue->txfree));
 
 	packet = list_entry(queue->txfree.next, struct bcm43xx_pio_txpacket, list);
-	packet->txb = txb;
-	packet->xmitted_frags = 0;
-	packet->xmitted_octets = 0;
+	packet->skb = skb;
+
+	memset(&packet->txstat, 0, sizeof(packet->txstat));
+	memcpy(&packet->txstat.control, ctl, sizeof(*ctl));
+
 	list_move_tail(&packet->list, &queue->txqueue);
 	queue->nr_txfree--;
-	assert(queue->nr_txfree < BCM43xx_PIO_MAXTXPACKETS);
-
-	/* Suspend TX, if we are out of packets in the "free" queue. */
-	if (list_empty(&queue->txfree)) {
-		netif_stop_queue(queue->bcm->net_dev);
-		queue->tx_suspended = 1;
-	}
+	queue->nr_tx_packets++;
+	BCM43xx_WARN_ON(queue->nr_txfree >= BCM43xx_PIO_MAXTXPACKETS);
 
 	tasklet_schedule(&queue->txtask);
 
 	return 0;
 }
 
-void bcm43xx_pio_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
+void bcm43xx_pio_handle_txstatus(struct bcm43xx_wldev *dev,
+				 const struct bcm43xx_txstatus *status)
 {
 	struct bcm43xx_pioqueue *queue;
 	struct bcm43xx_pio_txpacket *packet;
 
-	queue = parse_cookie(bcm, status->cookie, &packet);
-	assert(queue);
+	queue = parse_cookie(dev, status->cookie, &packet);
+	BCM43xx_WARN_ON(!queue);
+
+	queue->tx_devq_packets--;
+	queue->tx_devq_used -= (packet->skb->len +
+				sizeof(struct bcm43xx_txhdr_fw3));
+
+	if (status->acked)
+		packet->txstat.flags |= IEEE80211_TX_STATUS_ACK;
+	packet->txstat.retry_count = status->frame_count - 1;
+	ieee80211_tx_status_irqsafe(dev->wl->hw, packet->skb,
+				    &(packet->txstat));
+	packet->skb = NULL;
 
 	free_txpacket(packet, 1);
-	if (queue->tx_suspended) {
-		queue->tx_suspended = 0;
-		netif_wake_queue(queue->bcm->net_dev);
-	}
 	/* If there are packets on the txqueue, poke the tasklet
 	 * to transmit them.
 	 */
@@ -506,17 +505,31 @@ void bcm43xx_pio_handle_xmitstatus(struc
 		tasklet_schedule(&queue->txtask);
 }
 
+void bcm43xx_pio_get_tx_stats(struct bcm43xx_wldev *dev,
+			      struct ieee80211_tx_queue_stats *stats)
+{
+	struct bcm43xx_pio *pio = &dev->pio;
+	struct bcm43xx_pioqueue *queue;
+	struct ieee80211_tx_queue_stats_data *data;
+
+	queue = pio->queue1;
+	data = &(stats->data[0]);
+	data->len = BCM43xx_PIO_MAXTXPACKETS - queue->nr_txfree;
+	data->limit = BCM43xx_PIO_MAXTXPACKETS;
+	data->count = queue->nr_tx_packets;
+}
+
 static void pio_rx_error(struct bcm43xx_pioqueue *queue,
 			 int clear_buffers,
 			 const char *error)
 {
 	int i;
 
-	printkl("PIO RX error: %s\n", error);
+	bcmerr(queue->dev->wl, "PIO RX error: %s\n", error);
 	bcm43xx_pio_write(queue, BCM43xx_PIO_RXCTL,
 			  BCM43xx_PIO_RXCTL_READY);
 	if (clear_buffers) {
-		assert(queue->mmio_base == BCM43xx_MMIO_PIO1_BASE);
+		BCM43xx_WARN_ON(queue->mmio_base != BCM43xx_MMIO_PIO1_BASE);
 		for (i = 0; i < 15; i++) {
 			/* Dummy read. */
 			bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
@@ -527,9 +540,12 @@ static void pio_rx_error(struct bcm43xx_
 void bcm43xx_pio_rx(struct bcm43xx_pioqueue *queue)
 {
 	u16 preamble[21] = { 0 };
-	struct bcm43xx_rxhdr *rxhdr;
-	u16 tmp, len, rxflags2;
-	int i, preamble_readwords;
+	struct bcm43xx_rxhdr_fw3 *rxhdr;
+	u16 tmp;
+	u16 len;
+	u16 macstat;
+	int i;
+	int preamble_readwords;
 	struct sk_buff *skb;
 
 	tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXCTL);
@@ -544,7 +560,7 @@ void bcm43xx_pio_rx(struct bcm43xx_pioqu
 			goto data_ready;
 		udelay(10);
 	}
-	dprintkl(KERN_ERR PFX "PIO RX timed out\n");
+	bcmdbg(queue->dev->wl, "PIO RX timed out\n");
 	return;
 data_ready:
 
@@ -566,29 +582,20 @@ data_ready:
 		tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
 		preamble[i + 1] = cpu_to_le16(tmp);
 	}
-	rxhdr = (struct bcm43xx_rxhdr *)preamble;
-	rxflags2 = le16_to_cpu(rxhdr->flags2);
-	if (unlikely(rxflags2 & BCM43xx_RXHDR_FLAGS2_INVALIDFRAME)) {
+	rxhdr = (struct bcm43xx_rxhdr_fw3 *)preamble;
+	macstat = le16_to_cpu(rxhdr->mac_status);
+	if (macstat & BCM43xx_RX_MAC_FCSERR) {
 		pio_rx_error(queue,
 			     (queue->mmio_base == BCM43xx_MMIO_PIO1_BASE),
-			     "invalid frame");
+			     "Frame FCS error");
 		return;
 	}
 	if (queue->mmio_base == BCM43xx_MMIO_PIO4_BASE) {
 		/* We received an xmit status. */
-		struct bcm43xx_hwxmitstatus *hw;
-		struct bcm43xx_xmitstatus stat;
-
-		hw = (struct bcm43xx_hwxmitstatus *)(preamble + 1);
-		stat.cookie = le16_to_cpu(hw->cookie);
-		stat.flags = hw->flags;
-		stat.cnt1 = hw->cnt1;
-		stat.cnt2 = hw->cnt2;
-		stat.seq = le16_to_cpu(hw->seq);
-		stat.unknown = le16_to_cpu(hw->unknown);
+		struct bcm43xx_hwtxstatus *hw;
 
-		bcm43xx_debugfs_log_txstat(queue->bcm, &stat);
-		bcm43xx_pio_handle_xmitstatus(queue->bcm, &stat);
+		hw = (struct bcm43xx_hwtxstatus *)(preamble + 1);
+		bcm43xx_handle_hwtxstatus(queue->dev, hw);
 
 		return;
 	}
@@ -606,24 +613,13 @@ data_ready:
 	if (len % 2) {
 		tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
 		skb->data[len - 1] = (tmp & 0x00FF);
-/* The specs say the following is required, but
- * it is wrong and corrupts the PLCP. If we don't do
- * this, the PLCP seems to be correct. So ifdef it out for now.
- */
-#if 0
-		if (rxflags2 & BCM43xx_RXHDR_FLAGS2_TYPE2FRAME)
-			skb->data[2] = (tmp & 0xFF00) >> 8;
-		else
-			skb->data[0] = (tmp & 0xFF00) >> 8;
-#endif
 	}
-	skb_trim(skb, len - IEEE80211_FCS_LEN);
-	bcm43xx_rx(queue->bcm, skb, rxhdr);
+	bcm43xx_rx(queue->dev, skb, rxhdr);
 }
 
 void bcm43xx_pio_tx_suspend(struct bcm43xx_pioqueue *queue)
 {
-	bcm43xx_power_saving_ctl_bits(queue->bcm, -1, 1);
+	bcm43xx_power_saving_ctl_bits(queue->dev, -1, 1);
 	bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
 			  bcm43xx_pio_read(queue, BCM43xx_PIO_TXCTL)
 			  | BCM43xx_PIO_TXCTL_SUSPEND);
@@ -634,29 +630,28 @@ void bcm43xx_pio_tx_resume(struct bcm43x
 	bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
 			  bcm43xx_pio_read(queue, BCM43xx_PIO_TXCTL)
 			  & ~BCM43xx_PIO_TXCTL_SUSPEND);
-	bcm43xx_power_saving_ctl_bits(queue->bcm, -1, -1);
-	if (!list_empty(&queue->txqueue))
-		tasklet_schedule(&queue->txtask);
+	bcm43xx_power_saving_ctl_bits(queue->dev, -1, -1);
+	tasklet_schedule(&queue->txtask);
 }
 
-void bcm43xx_pio_freeze_txqueues(struct bcm43xx_private *bcm)
+void bcm43xx_pio_freeze_txqueues(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_pio *pio;
 
-	assert(bcm43xx_using_pio(bcm));
-	pio = bcm43xx_current_pio(bcm);
+	BCM43xx_WARN_ON(!bcm43xx_using_pio(dev));
+	pio = &dev->pio;
 	pio->queue0->tx_frozen = 1;
 	pio->queue1->tx_frozen = 1;
 	pio->queue2->tx_frozen = 1;
 	pio->queue3->tx_frozen = 1;
 }
 
-void bcm43xx_pio_thaw_txqueues(struct bcm43xx_private *bcm)
+void bcm43xx_pio_thaw_txqueues(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_pio *pio;
 
-	assert(bcm43xx_using_pio(bcm));
-	pio = bcm43xx_current_pio(bcm);
+	BCM43xx_WARN_ON(!bcm43xx_using_pio(dev));
+	pio = &dev->pio;
 	pio->queue0->tx_frozen = 0;
 	pio->queue1->tx_frozen = 0;
 	pio->queue2->tx_frozen = 0;
@@ -670,5 +665,3 @@ void bcm43xx_pio_thaw_txqueues(struct bc
 	if (!list_empty(&pio->queue3->txqueue))
 		tasklet_schedule(&pio->queue3->txtask);
 }
-
-
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_pio.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_pio.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_pio.h
@@ -40,22 +40,21 @@ struct bcm43xx_xmitstatus;
 
 struct bcm43xx_pio_txpacket {
 	struct bcm43xx_pioqueue *queue;
-	struct ieee80211_txb *txb;
+	struct sk_buff *skb;
+	struct ieee80211_tx_status txstat;
 	struct list_head list;
-
-	u8 xmitted_frags;
-	u16 xmitted_octets;
 };
 
-#define pio_txpacket_getindex(packet) ((int)((packet) - (packet)->queue->tx_packets_cache)) 
+#define pio_txpacket_getindex(packet) ((int)((packet) - \
+			              (packet)->queue->tx_packets_cache))
 
 struct bcm43xx_pioqueue {
-	struct bcm43xx_private *bcm;
+	struct bcm43xx_wldev *dev;
 	u16 mmio_base;
 
-	u8 tx_suspended:1,
-	   tx_frozen:1,
-	   need_workarounds:1; /* Workarounds needed for core.rev < 3 */
+	bool tx_suspended;
+	bool tx_frozen;
+	bool need_workarounds; /* Workarounds needed for core.rev < 3 */
 
 	/* Adjusted size of the device internal TX buffer. */
 	u16 tx_devq_size;
@@ -88,54 +87,63 @@ static inline
 u16 bcm43xx_pio_read(struct bcm43xx_pioqueue *queue,
 		     u16 offset)
 {
-	return bcm43xx_read16(queue->bcm, queue->mmio_base + offset);
+	return bcm43xx_read16(queue->dev, queue->mmio_base + offset);
 }
 
 static inline
 void bcm43xx_pio_write(struct bcm43xx_pioqueue *queue,
 		       u16 offset, u16 value)
 {
-	bcm43xx_write16(queue->bcm, queue->mmio_base + offset, value);
+	bcm43xx_write16(queue->dev, queue->mmio_base + offset, value);
 	mmiowb();
 }
 
 
-int bcm43xx_pio_init(struct bcm43xx_private *bcm);
-void bcm43xx_pio_free(struct bcm43xx_private *bcm);
+int bcm43xx_pio_init(struct bcm43xx_wldev *dev);
+void bcm43xx_pio_free(struct bcm43xx_wldev *dev);
 
-int bcm43xx_pio_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb);
-void bcm43xx_pio_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status);
+int bcm43xx_pio_tx(struct bcm43xx_wldev *dev,
+		   struct sk_buff *skb,
+		   struct ieee80211_tx_control *ctl);
+void bcm43xx_pio_handle_txstatus(struct bcm43xx_wldev *dev,
+				 const struct bcm43xx_txstatus *status);
+void bcm43xx_pio_get_tx_stats(struct bcm43xx_wldev *dev,
+			      struct ieee80211_tx_queue_stats *stats);
 void bcm43xx_pio_rx(struct bcm43xx_pioqueue *queue);
 
-/* Suspend a TX queue on hardware level. */
+/* Suspend TX queue in hardware. */
 void bcm43xx_pio_tx_suspend(struct bcm43xx_pioqueue *queue);
 void bcm43xx_pio_tx_resume(struct bcm43xx_pioqueue *queue);
 /* Suspend (freeze) the TX tasklet (software level). */
-void bcm43xx_pio_freeze_txqueues(struct bcm43xx_private *bcm);
-void bcm43xx_pio_thaw_txqueues(struct bcm43xx_private *bcm);
+void bcm43xx_pio_freeze_txqueues(struct bcm43xx_wldev *dev);
+void bcm43xx_pio_thaw_txqueues(struct bcm43xx_wldev *dev);
 
 #else /* CONFIG_BCM43XX_PIO */
 
 static inline
-int bcm43xx_pio_init(struct bcm43xx_private *bcm)
+int bcm43xx_pio_init(struct bcm43xx_wldev *dev)
 {
 	return 0;
 }
 static inline
-void bcm43xx_pio_free(struct bcm43xx_private *bcm)
+void bcm43xx_pio_free(struct bcm43xx_wldev *dev)
 {
 }
 static inline
-int bcm43xx_pio_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
+int bcm43xx_pio_tx(struct bcm43xx_wldev *dev,
+		   struct sk_buff *skb,
+		   struct ieee80211_tx_control *ctl)
 {
 	return 0;
 }
 static inline
-void bcm43xx_pio_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
+void bcm43xx_pio_handle_txstatus(struct bcm43xx_wldev *dev,
+				 const struct bcm43xx_txstatus *status)
+{
+}
+static inline
+void bcm43xx_pio_get_tx_stats(struct bcm43xx_wldev *dev,
+			      struct ieee80211_tx_queue_stats *stats)
 {
 }
 static inline
@@ -151,11 +159,11 @@ void bcm43xx_pio_tx_resume(struct bcm43x
 {
 }
 static inline
-void bcm43xx_pio_freeze_txqueues(struct bcm43xx_private *bcm)
+void bcm43xx_pio_freeze_txqueues(struct bcm43xx_wldev *dev)
 {
 }
 static inline
-void bcm43xx_pio_thaw_txqueues(struct bcm43xx_private *bcm)
+void bcm43xx_pio_thaw_txqueues(struct bcm43xx_wldev *dev)
 {
 }
 



From Larry.Finger at lwfinger.net  Thu Aug  2 17:54:06 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:54:06 -0500
Subject: [RFC 9/10] Port of bcm43xx from softmac to mac80211
Message-ID: <46b1fe1e.H28hPO4t0GvvAOkC%Larry.Finger@lwfinger.net>

This if file 9 of 10 of the port of the bcm43xx driver from softmac
to mac80211.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
@@ -4,7 +4,7 @@
 
   SYSFS support routines
 
-  Copyright (c) 2006 Michael Buesch <mbuesch at freenet.de>
+  Copyright (c) 2006 Michael Buesch <mb at bu3sch.de>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -26,6 +26,7 @@
 #include "bcm43xx_sysfs.h"
 #include "bcm43xx.h"
 #include "bcm43xx_main.h"
+#include "bcm43xx_phy.h"
 #include "bcm43xx_radio.h"
 
 #include <linux/capability.h>
@@ -71,143 +72,42 @@ static int get_boolean(const char *buf, 
 	return -EINVAL;
 }
 
-static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len)
-{
-	int i, pos = 0;
-
-	for (i = 0; i < BCM43xx_SPROM_SIZE; i++) {
-		pos += snprintf(buf + pos, buf_len - pos - 1,
-				"%04X", swab16(sprom[i]) & 0xFFFF);
-	}
-	pos += snprintf(buf + pos, buf_len - pos - 1, "\n");
-
-	return pos + 1;
-}
-
-static int hex2sprom(u16 *sprom, const char *dump, size_t len)
-{
-	char tmp[5] = { 0 };
-	int cnt = 0;
-	unsigned long parsed;
-
-	if (len < BCM43xx_SPROM_SIZE * sizeof(u16) * 2)
-		return -EINVAL;
-
-	while (cnt < BCM43xx_SPROM_SIZE) {
-		memcpy(tmp, dump, 4);
-		dump += 4;
-		parsed = simple_strtoul(tmp, NULL, 16);
-		sprom[cnt++] = swab16((u16)parsed);
-	}
-
-	return 0;
-}
-
-static ssize_t bcm43xx_attr_sprom_show(struct device *dev,
-				       struct device_attribute *attr,
-				       char *buf)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	u16 *sprom;
-	unsigned long flags;
-	int err;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	assert(BCM43xx_SPROM_SIZE * sizeof(u16) <= PAGE_SIZE);
-	sprom = kmalloc(BCM43xx_SPROM_SIZE * sizeof(*sprom),
-			GFP_KERNEL);
-	if (!sprom)
-		return -ENOMEM;
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	err = bcm43xx_sprom_read(bcm, sprom);
-	if (!err)
-		err = sprom2hex(sprom, buf, PAGE_SIZE);
-	mmiowb();
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-	kfree(sprom);
-
-	return err;
-}
-
-static ssize_t bcm43xx_attr_sprom_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	u16 *sprom;
-	unsigned long flags;
-	int err;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	sprom = kmalloc(BCM43xx_SPROM_SIZE * sizeof(*sprom),
-			GFP_KERNEL);
-	if (!sprom)
-		return -ENOMEM;
-	err = hex2sprom(sprom, buf, count);
-	if (err)
-		goto out_kfree;
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	spin_lock(&bcm->leds_lock);
-	err = bcm43xx_sprom_write(bcm, sprom);
-	mmiowb();
-	spin_unlock(&bcm->leds_lock);
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-out_kfree:
-	kfree(sprom);
-
-	return err ? err : count;
-
-}
-
-static DEVICE_ATTR(sprom, 0600,
-		   bcm43xx_attr_sprom_show,
-		   bcm43xx_attr_sprom_store);
-
 static ssize_t bcm43xx_attr_interfmode_show(struct device *dev,
 					    struct device_attribute *attr,
 					    char *buf)
 {
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
+	struct bcm43xx_wldev *wldev = dev_to_bcm43xx_wldev(dev);
 	ssize_t count = 0;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	mutex_lock(&bcm->mutex);
+	mutex_lock(&wldev->wl->mutex);
 
-	switch (bcm43xx_current_radio(bcm)->interfmode) {
-	case BCM43xx_RADIO_INTERFMODE_NONE:
+	switch (wldev->phy.interfmode) {
+	case BCM43xx_INTERFMODE_NONE:
 		count = snprintf(buf, PAGE_SIZE, "0 (No Interference Mitigation)\n");
 		break;
-	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
+	case BCM43xx_INTERFMODE_NONWLAN:
 		count = snprintf(buf, PAGE_SIZE, "1 (Non-WLAN Interference Mitigation)\n");
 		break;
-	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
+	case BCM43xx_INTERFMODE_MANUALWLAN:
 		count = snprintf(buf, PAGE_SIZE, "2 (WLAN Interference Mitigation)\n");
 		break;
 	default:
-		assert(0);
+		BCM43xx_WARN_ON(1);
 	}
 
-	mutex_unlock(&bcm->mutex);
+	mutex_unlock(&wldev->wl->mutex);
 
 	return count;
-
 }
 
 static ssize_t bcm43xx_attr_interfmode_store(struct device *dev,
 					     struct device_attribute *attr,
 					     const char *buf, size_t count)
 {
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
+	struct bcm43xx_wldev *wldev = dev_to_bcm43xx_wldev(dev);
 	unsigned long flags;
 	int err;
 	int mode;
@@ -218,32 +118,32 @@ static ssize_t bcm43xx_attr_interfmode_s
 	mode = get_integer(buf, count);
 	switch (mode) {
 	case 0:
-		mode = BCM43xx_RADIO_INTERFMODE_NONE;
+		mode = BCM43xx_INTERFMODE_NONE;
 		break;
 	case 1:
-		mode = BCM43xx_RADIO_INTERFMODE_NONWLAN;
+		mode = BCM43xx_INTERFMODE_NONWLAN;
 		break;
 	case 2:
-		mode = BCM43xx_RADIO_INTERFMODE_MANUALWLAN;
+		mode = BCM43xx_INTERFMODE_MANUALWLAN;
 		break;
 	case 3:
-		mode = BCM43xx_RADIO_INTERFMODE_AUTOWLAN;
+		mode = BCM43xx_INTERFMODE_AUTOWLAN;
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
+	mutex_lock(&wldev->wl->mutex);
+	spin_lock_irqsave(&wldev->wl->irq_lock, flags);
 
-	err = bcm43xx_radio_set_interference_mitigation(bcm, mode);
+	err = bcm43xx_radio_set_interference_mitigation(wldev, mode);
 	if (err) {
-		printk(KERN_ERR PFX "Interference Mitigation not "
-				    "supported by device\n");
+		bcmerr(wldev->wl, "Interference Mitigation not "
+		       "supported by device\n");
 	}
 	mmiowb();
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
+	spin_unlock_irqrestore(&wldev->wl->irq_lock, flags);
+	mutex_unlock(&wldev->wl->mutex);
 
 	return err ? err : count;
 }
@@ -256,20 +156,20 @@ static ssize_t bcm43xx_attr_preamble_sho
 					  struct device_attribute *attr,
 					  char *buf)
 {
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
+	struct bcm43xx_wldev *wldev = dev_to_bcm43xx_wldev(dev);
 	ssize_t count;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	mutex_lock(&bcm->mutex);
+	mutex_lock(&wldev->wl->mutex);
 
-	if (bcm->short_preamble)
+	if (wldev->short_preamble)
 		count = snprintf(buf, PAGE_SIZE, "1 (Short Preamble enabled)\n");
 	else
 		count = snprintf(buf, PAGE_SIZE, "0 (Short Preamble disabled)\n");
 
-	mutex_unlock(&bcm->mutex);
+	mutex_unlock(&wldev->wl->mutex);
 
 	return count;
 }
@@ -278,7 +178,7 @@ static ssize_t bcm43xx_attr_preamble_sto
 					   struct device_attribute *attr,
 					   const char *buf, size_t count)
 {
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
+	struct bcm43xx_wldev *wldev = dev_to_bcm43xx_wldev(dev);
 	unsigned long flags;
 	int value;
 
@@ -288,13 +188,13 @@ static ssize_t bcm43xx_attr_preamble_sto
 	value = get_boolean(buf, count);
 	if (value < 0)
 		return value;
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
+	mutex_lock(&wldev->wl->mutex);
+	spin_lock_irqsave(&wldev->wl->irq_lock, flags);
 
-	bcm->short_preamble = !!value;
+	wldev->short_preamble = !!value;
 
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
+	spin_unlock_irqrestore(&wldev->wl->irq_lock, flags);
+	mutex_unlock(&wldev->wl->mutex);
 
 	return count;
 }
@@ -303,169 +203,31 @@ static DEVICE_ATTR(shortpreamble, 0644,
 		   bcm43xx_attr_preamble_show,
 		   bcm43xx_attr_preamble_store);
 
-static ssize_t bcm43xx_attr_phymode_store(struct device *dev,
-					  struct device_attribute *attr,
-					  const char *buf, size_t count)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	int phytype;
-	int err = -EINVAL;
-
-	if (count < 1)
-		goto out;
-	switch (buf[0]) {
-	case 'a':  case 'A':
-		phytype = BCM43xx_PHYTYPE_A;
-		break;
-	case 'b':  case 'B':
-		phytype = BCM43xx_PHYTYPE_B;
-		break;
-	case 'g':  case 'G':
-		phytype = BCM43xx_PHYTYPE_G;
-		break;
-	default:
-		goto out;
-	}
-
-	bcm43xx_periodic_tasks_delete(bcm);
-	mutex_lock(&(bcm)->mutex);
-	err = bcm43xx_select_wireless_core(bcm, phytype);
-	if (!err)
-		bcm43xx_periodic_tasks_setup(bcm);
-	mutex_unlock(&(bcm)->mutex);
-	if (err == -ESRCH)
-		err = -ENODEV;
-
-out:
-	return err ? err : count;
-}
-
-static ssize_t bcm43xx_attr_phymode_show(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf)
+int bcm43xx_sysfs_register(struct bcm43xx_wldev *wldev)
 {
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	ssize_t count = 0;
-
-	mutex_lock(&(bcm)->mutex);
-	switch (bcm43xx_current_phy(bcm)->type) {
-	case BCM43xx_PHYTYPE_A:
-		snprintf(buf, PAGE_SIZE, "A");
-		break;
-	case BCM43xx_PHYTYPE_B:
-		snprintf(buf, PAGE_SIZE, "B");
-		break;
-	case BCM43xx_PHYTYPE_G:
-		snprintf(buf, PAGE_SIZE, "G");
-		break;
-	default:
-		assert(0);
-	}
-	mutex_unlock(&(bcm)->mutex);
-
-	return count;
-}
-
-static DEVICE_ATTR(phymode, 0644,
-		   bcm43xx_attr_phymode_show,
-		   bcm43xx_attr_phymode_store);
-
-static ssize_t bcm43xx_attr_microcode_show(struct device *dev,
-					   struct device_attribute *attr,
-					   char *buf)
-{
-	unsigned long flags;
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	ssize_t count = 0;
-	u16 status;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	mutex_lock(&(bcm)->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	status = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODE_STATUS);
-
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&(bcm)->mutex);
-	switch (status) {
-	case 0x0000:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (invalid)\n",
-				 status);
-		break;
-	case 0x0001:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (init)\n",
-				 status);
-		break;
-	case 0x0002:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (active)\n",
-				 status);
-		break;
-	case 0x0003:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (suspended)\n",
-				 status);
-		break;
-	case 0x0004:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (asleep)\n",
-				 status);
-		break;
-	default:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (unknown)\n",
-				 status);
-		break;
-	}
-
-	return count;
-}
-
-static DEVICE_ATTR(microcodestatus, 0444,
-		   bcm43xx_attr_microcode_show,
-		   NULL);
-
-int bcm43xx_sysfs_register(struct bcm43xx_private *bcm)
-{
-	struct device *dev = &bcm->pci_dev->dev;
+	struct device *dev = wldev->dev->dev;
 	int err;
 
-	assert(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED);
+	BCM43xx_WARN_ON(bcm43xx_status(wldev) != BCM43xx_STAT_INITIALIZED);
 
-	err = device_create_file(dev, &dev_attr_sprom);
-	if (err)
-		goto out;
 	err = device_create_file(dev, &dev_attr_interference);
 	if (err)
-		goto err_remove_sprom;
+		goto out;
 	err = device_create_file(dev, &dev_attr_shortpreamble);
 	if (err)
 		goto err_remove_interfmode;
-	err = device_create_file(dev, &dev_attr_phymode);
-	if (err)
-		goto err_remove_shortpreamble;
-	err = device_create_file(dev, &dev_attr_microcodestatus);
-	if (err)
-		goto err_remove_phymode;
 
 out:
 	return err;
-err_remove_phymode:
-	device_remove_file(dev, &dev_attr_phymode);
-err_remove_shortpreamble:
-	device_remove_file(dev, &dev_attr_shortpreamble);
 err_remove_interfmode:
 	device_remove_file(dev, &dev_attr_interference);
-err_remove_sprom:
-	device_remove_file(dev, &dev_attr_sprom);
 	goto out;
 }
 
-void bcm43xx_sysfs_unregister(struct bcm43xx_private *bcm)
+void bcm43xx_sysfs_unregister(struct bcm43xx_wldev *wldev)
 {
-	struct device *dev = &bcm->pci_dev->dev;
+	struct device *dev = wldev->dev->dev;
 
-	device_remove_file(dev, &dev_attr_microcodestatus);
-	device_remove_file(dev, &dev_attr_phymode);
 	device_remove_file(dev, &dev_attr_shortpreamble);
 	device_remove_file(dev, &dev_attr_interference);
-	device_remove_file(dev, &dev_attr_sprom);
 }
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.h
@@ -1,9 +1,9 @@
 #ifndef BCM43xx_SYSFS_H_
 #define BCM43xx_SYSFS_H_
 
-struct bcm43xx_private;
+struct bcm43xx_wldev;
 
-int bcm43xx_sysfs_register(struct bcm43xx_private *bcm);
-void bcm43xx_sysfs_unregister(struct bcm43xx_private *bcm);
+int bcm43xx_sysfs_register(struct bcm43xx_wldev *dev);
+void bcm43xx_sysfs_unregister(struct bcm43xx_wldev *dev);
 
 #endif /* BCM43xx_SYSFS_H_ */



From Larry.Finger at lwfinger.net  Thu Aug  2 17:54:00 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:54:00 -0500
Subject: [RFC 8/10] Port of bcm43xx from softmac to mac80211
Message-ID: <46b1fe18.Od+Lq2jg88psezq0%Larry.Finger@lwfinger.net>

This if file 8 of 10 of the port of the bcm43xx driver from softmac
to mac80211.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_radio.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_radio.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_radio.c
@@ -7,6 +7,7 @@
                      Michael Buesch <mbuesch at freenet.de>
                      Danny van Dyk <kugelfang at gentoo.org>
                      Andreas Jaggi <andreas.jaggi at waterwave.ch>
+  Copyright (c) 2007 Larry Finger <Larry.Finger at lwfinger.net>
 
   Some parts of the code in this file are derived from the ipw2200
   driver  Copyright(c) 2003 - 2004 Intel Corporation.
@@ -52,7 +53,7 @@ static u16 flip_4bit(u16 value)
 {
 	u16 flipped = 0x0000;
 
-	assert((value & ~0x000F) == 0x0000);
+	BCM43xx_BUG_ON(!((value & ~0x000F) == 0x0000));
 
 	flipped |= (value & 0x0001) << 3;
 	flipped |= (value & 0x0002) << 1;
@@ -76,82 +77,77 @@ u16 channel2freq_bg(u8 channel)
 		72, 84,
 	};
 
-	assert(channel >= 1 && channel <= 14);
+	if (unlikely(channel < 1 || channel > 14)) {
+		printk(KERN_INFO "bcm43xx: Channel %d is out of range\n",
+				  channel);
+		dump_stack();
+		return 2412;
+	}
 
 	return frequencies_bg[channel - 1];
 }
 
-/* Get the freq, as it has to be written to the device. */
-static inline
-u16 channel2freq_a(u8 channel)
-{
-	assert(channel <= 200);
-
-	return (5000 + 5 * channel);
-}
-
-void bcm43xx_radio_lock(struct bcm43xx_private *bcm)
+void bcm43xx_radio_lock(struct bcm43xx_wldev *dev)
 {
 	u32 status;
 
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 	status |= BCM43xx_SBF_RADIOREG_LOCK;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, status);
 	mmiowb();
 	udelay(10);
 }
 
-void bcm43xx_radio_unlock(struct bcm43xx_private *bcm)
+void bcm43xx_radio_unlock(struct bcm43xx_wldev *dev)
 {
 	u32 status;
 
-	bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_VER); /* dummy read */
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
+	bcm43xx_read16(dev, BCM43xx_MMIO_PHY_VER); /* dummy read */
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 	status &= ~BCM43xx_SBF_RADIOREG_LOCK;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, status);
 	mmiowb();
 }
 
-u16 bcm43xx_radio_read16(struct bcm43xx_private *bcm, u16 offset)
+u16 bcm43xx_radio_read16(struct bcm43xx_wldev *dev, u16 offset)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 
 	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		offset |= 0x0040;
-		break;
 	case BCM43xx_PHYTYPE_B:
-		if (radio->version == 0x2053) {
+		if (phy->radio_ver == 0x2053) {
 			if (offset < 0x70)
 				offset += 0x80;
 			else if (offset < 0x80)
 				offset += 0x70;
-		} else if (radio->version == 0x2050) {
+		} else if (phy->radio_ver == 0x2050) {
 			offset |= 0x80;
-		} else
-			assert(0);
+		} else {
+			BCM43xx_WARN_ON(1);
+		}
 		break;
 	case BCM43xx_PHYTYPE_G:
 		offset |= 0x80;
 		break;
+	default:
+		BCM43xx_BUG_ON(1);
 	}
 
-	bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, offset);
-	return bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_DATA_LOW);
+	bcm43xx_write16(dev, BCM43xx_MMIO_RADIO_CONTROL, offset);
+	return bcm43xx_read16(dev, BCM43xx_MMIO_RADIO_DATA_LOW);
 }
 
-void bcm43xx_radio_write16(struct bcm43xx_private *bcm, u16 offset, u16 val)
+void bcm43xx_radio_write16(struct bcm43xx_wldev *dev, u16 offset, u16 val)
 {
-	bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, offset);
+	bcm43xx_write16(dev, BCM43xx_MMIO_RADIO_CONTROL, offset);
 	mmiowb();
-	bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_DATA_LOW, val);
+	bcm43xx_write16(dev, BCM43xx_MMIO_RADIO_DATA_LOW, val);
 }
 
-static void bcm43xx_set_all_gains(struct bcm43xx_private *bcm,
+static void bcm43xx_set_all_gains(struct bcm43xx_wldev *dev,
 				  s16 first, s16 second, s16 third)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 i;
 	u16 start = 0x08, end = 0x18;
 	u16 offset = 0x0400;
@@ -164,26 +160,29 @@ static void bcm43xx_set_all_gains(struct
 	}
 
 	for (i = 0; i < 4; i++)
-		bcm43xx_ilt_write(bcm, offset + i, first);
+		bcm43xx_ilt_write(dev, offset + i, first);
 
 	for (i = start; i < end; i++)
-		bcm43xx_ilt_write(bcm, offset + i, second);
+		bcm43xx_ilt_write(dev, offset + i, second);
 
 	if (third != -1) {
 		tmp = ((u16)third << 14) | ((u16)third << 6);
-		bcm43xx_phy_write(bcm, 0x04A0,
-		                  (bcm43xx_phy_read(bcm, 0x04A0) & 0xBFBF) | tmp);
-		bcm43xx_phy_write(bcm, 0x04A1,
-		                  (bcm43xx_phy_read(bcm, 0x04A1) & 0xBFBF) | tmp);
-		bcm43xx_phy_write(bcm, 0x04A2,
-		                  (bcm43xx_phy_read(bcm, 0x04A2) & 0xBFBF) | tmp);
+		bcm43xx_phy_write(dev, 0x04A0,
+				  (bcm43xx_phy_read(dev, 0x04A0) & 0xBFBF)
+				  | tmp);
+		bcm43xx_phy_write(dev, 0x04A1,
+				  (bcm43xx_phy_read(dev, 0x04A1) & 0xBFBF)
+				   | tmp);
+		bcm43xx_phy_write(dev, 0x04A2,
+				   (bcm43xx_phy_read(dev, 0x04A2) & 0xBFBF)
+				   | tmp);
 	}
-	bcm43xx_dummy_transmission(bcm);
+	bcm43xx_dummy_transmission(dev);
 }
 
-static void bcm43xx_set_original_gains(struct bcm43xx_private *bcm)
+static void bcm43xx_set_original_gains(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 i, tmp;
 	u16 offset = 0x0400;
 	u16 start = 0x0008, end = 0x0018;
@@ -199,62 +198,63 @@ static void bcm43xx_set_original_gains(s
 		tmp |= (i & 0x0001) << 1;
 		tmp |= (i & 0x0002) >> 1;
 
-		bcm43xx_ilt_write(bcm, offset + i, tmp);
+		bcm43xx_ilt_write(dev, offset + i, tmp);
 	}
 
 	for (i = start; i < end; i++)
-		bcm43xx_ilt_write(bcm, offset + i, i - start);
+		bcm43xx_ilt_write(dev, offset + i, i - start);
 
-	bcm43xx_phy_write(bcm, 0x04A0,
-	                  (bcm43xx_phy_read(bcm, 0x04A0) & 0xBFBF) | 0x4040);
-	bcm43xx_phy_write(bcm, 0x04A1,
-	                  (bcm43xx_phy_read(bcm, 0x04A1) & 0xBFBF) | 0x4040);
-	bcm43xx_phy_write(bcm, 0x04A2,
-	                  (bcm43xx_phy_read(bcm, 0x04A2) & 0xBFBF) | 0x4000);
-	bcm43xx_dummy_transmission(bcm);
+	bcm43xx_phy_write(dev, 0x04A0,
+			  (bcm43xx_phy_read(dev, 0x04A0) & 0xBFBF) | 0x4040);
+	bcm43xx_phy_write(dev, 0x04A1,
+			  (bcm43xx_phy_read(dev, 0x04A1) & 0xBFBF) | 0x4040);
+	bcm43xx_phy_write(dev, 0x04A2,
+			  (bcm43xx_phy_read(dev, 0x04A2) & 0xBFBF) | 0x4000);
+	bcm43xx_dummy_transmission(dev);
 }
 
 /* Synthetic PU workaround */
-static void bcm43xx_synth_pu_workaround(struct bcm43xx_private *bcm, u8 channel)
+static void bcm43xx_synth_pu_workaround(struct bcm43xx_wldev *dev, u8 channel)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	
-	if (radio->version != 0x2050 || radio->revision >= 6) {
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	might_sleep();
+
+	if (phy->radio_ver != 0x2050 || phy->radio_rev >= 6)
 		/* We do not need the workaround. */
 		return;
-	}
 
 	if (channel <= 10) {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
+		bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL,
 				channel2freq_bg(channel + 4));
 	} else {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
+		bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL,
 				channel2freq_bg(1));
 	}
-	udelay(100);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
+	msleep(1);
+	bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL,
 			channel2freq_bg(channel));
 }
 
-u8 bcm43xx_radio_aci_detect(struct bcm43xx_private *bcm, u8 channel)
+u8 bcm43xx_radio_aci_detect(struct bcm43xx_wldev *dev, u8 channel)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u8 ret = 0;
 	u16 saved, rssi, temp;
 	int i, j = 0;
 
-	saved = bcm43xx_phy_read(bcm, 0x0403);
-	bcm43xx_radio_selectchannel(bcm, channel, 0);
-	bcm43xx_phy_write(bcm, 0x0403, (saved & 0xFFF8) | 5);
-	if (radio->aci_hw_rssi)
-		rssi = bcm43xx_phy_read(bcm, 0x048A) & 0x3F;
+	saved = bcm43xx_phy_read(dev, 0x0403);
+	bcm43xx_radio_selectchannel(dev, channel, 0);
+	bcm43xx_phy_write(dev, 0x0403, (saved & 0xFFF8) | 5);
+	if (phy->aci_hw_rssi)
+		rssi = bcm43xx_phy_read(dev, 0x048A) & 0x3F;
 	else
 		rssi = saved & 0x3F;
 	/* clamp temp to signed 5bit */
 	if (rssi > 32)
 		rssi -= 64;
 	for (i = 0;i < 100; i++) {
-		temp = (bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x3F;
+		temp = (bcm43xx_phy_read(dev, 0x047F) >> 8) & 0x3F;
 		if (temp > 32)
 			temp -= 64;
 		if (temp < rssi)
@@ -262,46 +262,45 @@ u8 bcm43xx_radio_aci_detect(struct bcm43
 		if (j >= 20)
 			ret = 1;
 	}
-	bcm43xx_phy_write(bcm, 0x0403, saved);
+	bcm43xx_phy_write(dev, 0x0403, saved);
 
 	return ret;
 }
 
-u8 bcm43xx_radio_aci_scan(struct bcm43xx_private *bcm)
+u8 bcm43xx_radio_aci_scan(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u8 ret[13];
-	unsigned int channel = radio->channel;
+	unsigned int channel = phy->channel;
 	unsigned int i, j, start, end;
 	unsigned long phylock_flags;
 
 	if (!((phy->type == BCM43xx_PHYTYPE_G) && (phy->rev > 0)))
 		return 0;
 
-	bcm43xx_phy_lock(bcm, phylock_flags);
-	bcm43xx_radio_lock(bcm);
-	bcm43xx_phy_write(bcm, 0x0802,
-	                  bcm43xx_phy_read(bcm, 0x0802) & 0xFFFC);
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-	                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) & 0x7FFF);
-	bcm43xx_set_all_gains(bcm, 3, 8, 1);
+	bcm43xx_phy_lock(dev, phylock_flags);
+	bcm43xx_radio_lock(dev);
+	bcm43xx_phy_write(dev, 0x0802,
+			  bcm43xx_phy_read(dev, 0x0802) & 0xFFFC);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
+			  bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS) & 0x7FFF);
+	bcm43xx_set_all_gains(dev, 3, 8, 1);
 
 	start = (channel - 5 > 0) ? channel - 5 : 1;
 	end = (channel + 5 < 14) ? channel + 5 : 13;
 
 	for (i = start; i <= end; i++) {
 		if (abs(channel - i) > 2)
-			ret[i-1] = bcm43xx_radio_aci_detect(bcm, i);
+			ret[i-1] = bcm43xx_radio_aci_detect(dev, i);
 	}
-	bcm43xx_radio_selectchannel(bcm, channel, 0);
-	bcm43xx_phy_write(bcm, 0x0802,
-	                  (bcm43xx_phy_read(bcm, 0x0802) & 0xFFFC) | 0x0003);
-	bcm43xx_phy_write(bcm, 0x0403,
-	                  bcm43xx_phy_read(bcm, 0x0403) & 0xFFF8);
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-	                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x8000);
-	bcm43xx_set_original_gains(bcm);
+	bcm43xx_radio_selectchannel(dev, channel, 0);
+	bcm43xx_phy_write(dev, 0x0802,
+			  (bcm43xx_phy_read(dev, 0x0802) & 0xFFFC) | 0x0003);
+	bcm43xx_phy_write(dev, 0x0403,
+			  bcm43xx_phy_read(dev, 0x0403) & 0xFFF8);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
+			  bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS) | 0x8000);
+	bcm43xx_set_original_gains(dev);
 	for (i = 0; i < 13; i++) {
 		if (!ret[i])
 			continue;
@@ -309,130 +308,131 @@ u8 bcm43xx_radio_aci_scan(struct bcm43xx
 		for (j = i; j < end; j++)
 			ret[j] = 1;
 	}
-	bcm43xx_radio_unlock(bcm);
-	bcm43xx_phy_unlock(bcm, phylock_flags);
+	bcm43xx_radio_unlock(dev);
+	bcm43xx_phy_unlock(dev, phylock_flags);
 
 	return ret[channel - 1];
 }
 
 /* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
-void bcm43xx_nrssi_hw_write(struct bcm43xx_private *bcm, u16 offset, s16 val)
+void bcm43xx_nrssi_hw_write(struct bcm43xx_wldev *dev, u16 offset, s16 val)
 {
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_NRSSILT_CTRL, offset);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_NRSSILT_CTRL, offset);
 	mmiowb();
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_NRSSILT_DATA, (u16)val);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_NRSSILT_DATA, (u16)val);
 }
 
 /* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
-s16 bcm43xx_nrssi_hw_read(struct bcm43xx_private *bcm, u16 offset)
+s16 bcm43xx_nrssi_hw_read(struct bcm43xx_wldev *dev, u16 offset)
 {
 	u16 val;
 
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_NRSSILT_CTRL, offset);
-	val = bcm43xx_phy_read(bcm, BCM43xx_PHY_NRSSILT_DATA);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_NRSSILT_CTRL, offset);
+	val = bcm43xx_phy_read(dev, BCM43xx_PHY_NRSSILT_DATA);
 
 	return (s16)val;
 }
 
 /* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
-void bcm43xx_nrssi_hw_update(struct bcm43xx_private *bcm, u16 val)
+void bcm43xx_nrssi_hw_update(struct bcm43xx_wldev *dev, u16 val)
 {
 	u16 i;
 	s16 tmp;
 
 	for (i = 0; i < 64; i++) {
-		tmp = bcm43xx_nrssi_hw_read(bcm, i);
+		tmp = bcm43xx_nrssi_hw_read(dev, i);
 		tmp -= val;
 		tmp = limit_value(tmp, -32, 31);
-		bcm43xx_nrssi_hw_write(bcm, i, tmp);
+		bcm43xx_nrssi_hw_write(dev, i, tmp);
 	}
 }
 
 /* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
-void bcm43xx_nrssi_mem_update(struct bcm43xx_private *bcm)
+void bcm43xx_nrssi_mem_update(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	s16 i, delta;
 	s32 tmp;
 
-	delta = 0x1F - radio->nrssi[0];
+	delta = 0x1F - phy->nrssi[0];
 	for (i = 0; i < 64; i++) {
-		tmp = (i - delta) * radio->nrssislope;
+		tmp = (i - delta) * phy->nrssislope;
 		tmp /= 0x10000;
 		tmp += 0x3A;
 		tmp = limit_value(tmp, 0, 0x3F);
-		radio->nrssi_lt[i] = tmp;
+		phy->nrssi_lt[i] = tmp;
 	}
 }
 
-static void bcm43xx_calc_nrssi_offset(struct bcm43xx_private *bcm)
+static void bcm43xx_calc_nrssi_offset(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 backup[20] = { 0 };
 	s16 v47F;
 	u16 i;
 	u16 saved = 0xFFFF;
 
-	backup[0] = bcm43xx_phy_read(bcm, 0x0001);
-	backup[1] = bcm43xx_phy_read(bcm, 0x0811);
-	backup[2] = bcm43xx_phy_read(bcm, 0x0812);
-	backup[3] = bcm43xx_phy_read(bcm, 0x0814);
-	backup[4] = bcm43xx_phy_read(bcm, 0x0815);
-	backup[5] = bcm43xx_phy_read(bcm, 0x005A);
-	backup[6] = bcm43xx_phy_read(bcm, 0x0059);
-	backup[7] = bcm43xx_phy_read(bcm, 0x0058);
-	backup[8] = bcm43xx_phy_read(bcm, 0x000A);
-	backup[9] = bcm43xx_phy_read(bcm, 0x0003);
-	backup[10] = bcm43xx_radio_read16(bcm, 0x007A);
-	backup[11] = bcm43xx_radio_read16(bcm, 0x0043);
-
-	bcm43xx_phy_write(bcm, 0x0429,
-			  bcm43xx_phy_read(bcm, 0x0429) & 0x7FFF);
-	bcm43xx_phy_write(bcm, 0x0001,
-			  (bcm43xx_phy_read(bcm, 0x0001) & 0x3FFF) | 0x4000);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x000C);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  (bcm43xx_phy_read(bcm, 0x0812) & 0xFFF3) | 0x0004);
-	bcm43xx_phy_write(bcm, 0x0802,
-			  bcm43xx_phy_read(bcm, 0x0802) & ~(0x1 | 0x2));
+	backup[0] = bcm43xx_phy_read(dev, 0x0001);
+	backup[1] = bcm43xx_phy_read(dev, 0x0811);
+	backup[2] = bcm43xx_phy_read(dev, 0x0812);
+	backup[3] = bcm43xx_phy_read(dev, 0x0814);
+	backup[4] = bcm43xx_phy_read(dev, 0x0815);
+	backup[5] = bcm43xx_phy_read(dev, 0x005A);
+	backup[6] = bcm43xx_phy_read(dev, 0x0059);
+	backup[7] = bcm43xx_phy_read(dev, 0x0058);
+	backup[8] = bcm43xx_phy_read(dev, 0x000A);
+	backup[9] = bcm43xx_phy_read(dev, 0x0003);
+	backup[10] = bcm43xx_radio_read16(dev, 0x007A);
+	backup[11] = bcm43xx_radio_read16(dev, 0x0043);
+
+	bcm43xx_phy_write(dev, 0x0429,
+			  bcm43xx_phy_read(dev, 0x0429) & 0x7FFF);
+	bcm43xx_phy_write(dev, 0x0001,
+			  (bcm43xx_phy_read(dev, 0x0001) & 0x3FFF) | 0x4000);
+	bcm43xx_phy_write(dev, 0x0811,
+			  bcm43xx_phy_read(dev, 0x0811) | 0x000C);
+	bcm43xx_phy_write(dev, 0x0812,
+			  (bcm43xx_phy_read(dev, 0x0812) & 0xFFF3) | 0x0004);
+	bcm43xx_phy_write(dev, 0x0802,
+			  bcm43xx_phy_read(dev, 0x0802) & ~(0x1 | 0x2));
 	if (phy->rev >= 6) {
-		backup[12] = bcm43xx_phy_read(bcm, 0x002E);
-		backup[13] = bcm43xx_phy_read(bcm, 0x002F);
-		backup[14] = bcm43xx_phy_read(bcm, 0x080F);
-		backup[15] = bcm43xx_phy_read(bcm, 0x0810);
-		backup[16] = bcm43xx_phy_read(bcm, 0x0801);
-		backup[17] = bcm43xx_phy_read(bcm, 0x0060);
-		backup[18] = bcm43xx_phy_read(bcm, 0x0014);
-		backup[19] = bcm43xx_phy_read(bcm, 0x0478);
-
-		bcm43xx_phy_write(bcm, 0x002E, 0);
-		bcm43xx_phy_write(bcm, 0x002F, 0);
-		bcm43xx_phy_write(bcm, 0x080F, 0);
-		bcm43xx_phy_write(bcm, 0x0810, 0);
-		bcm43xx_phy_write(bcm, 0x0478,
-				  bcm43xx_phy_read(bcm, 0x0478) | 0x0100);
-		bcm43xx_phy_write(bcm, 0x0801,
-				  bcm43xx_phy_read(bcm, 0x0801) | 0x0040);
-		bcm43xx_phy_write(bcm, 0x0060,
-				  bcm43xx_phy_read(bcm, 0x0060) | 0x0040);
-		bcm43xx_phy_write(bcm, 0x0014,
-				  bcm43xx_phy_read(bcm, 0x0014) | 0x0200);
-	}
-	bcm43xx_radio_write16(bcm, 0x007A,
-			      bcm43xx_radio_read16(bcm, 0x007A) | 0x0070);
-	bcm43xx_radio_write16(bcm, 0x007A,
-			      bcm43xx_radio_read16(bcm, 0x007A) | 0x0080);
+		backup[12] = bcm43xx_phy_read(dev, 0x002E);
+		backup[13] = bcm43xx_phy_read(dev, 0x002F);
+		backup[14] = bcm43xx_phy_read(dev, 0x080F);
+		backup[15] = bcm43xx_phy_read(dev, 0x0810);
+		backup[16] = bcm43xx_phy_read(dev, 0x0801);
+		backup[17] = bcm43xx_phy_read(dev, 0x0060);
+		backup[18] = bcm43xx_phy_read(dev, 0x0014);
+		backup[19] = bcm43xx_phy_read(dev, 0x0478);
+
+		bcm43xx_phy_write(dev, 0x002E, 0);
+		bcm43xx_phy_write(dev, 0x002F, 0);
+		bcm43xx_phy_write(dev, 0x080F, 0);
+		bcm43xx_phy_write(dev, 0x0810, 0);
+		bcm43xx_phy_write(dev, 0x0478,
+				  bcm43xx_phy_read(dev, 0x0478) | 0x0100);
+		bcm43xx_phy_write(dev, 0x0801,
+				  bcm43xx_phy_read(dev, 0x0801) | 0x0040);
+		bcm43xx_phy_write(dev, 0x0060,
+				  bcm43xx_phy_read(dev, 0x0060) | 0x0040);
+		bcm43xx_phy_write(dev, 0x0014,
+				  bcm43xx_phy_read(dev, 0x0014) | 0x0200);
+	}
+	bcm43xx_radio_write16(dev, 0x007A,
+			      bcm43xx_radio_read16(dev, 0x007A) | 0x0070);
+	bcm43xx_radio_write16(dev, 0x007A,
+			      bcm43xx_radio_read16(dev, 0x007A) | 0x0080);
 	udelay(30);
 
-	v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
+	v47F = (s16)((bcm43xx_phy_read(dev, 0x047F) >> 8) & 0x003F);
 	if (v47F >= 0x20)
 		v47F -= 0x40;
 	if (v47F == 31) {
 		for (i = 7; i >= 4; i--) {
-			bcm43xx_radio_write16(bcm, 0x007B, i);
+			bcm43xx_radio_write16(dev, 0x007B, i);
 			udelay(20);
-			v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
+			v47F = (s16)((bcm43xx_phy_read(dev, 0x047F) >> 8)
+						       & 0x003F);
 			if (v47F >= 0x20)
 				v47F -= 0x40;
 			if (v47F < 31 && saved == 0xFFFF)
@@ -441,52 +441,56 @@ static void bcm43xx_calc_nrssi_offset(st
 		if (saved == 0xFFFF)
 			saved = 4;
 	} else {
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) & 0x007F);
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0001);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) & 0xFFFE);
-		bcm43xx_phy_write(bcm, 0x0811,
-				  bcm43xx_phy_read(bcm, 0x0811) | 0x000C);
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_phy_read(bcm, 0x0812) | 0x000C);
-		bcm43xx_phy_write(bcm, 0x0811,
-				  bcm43xx_phy_read(bcm, 0x0811) | 0x0030);
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_phy_read(bcm, 0x0812) | 0x0030);
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0x0810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
+		bcm43xx_radio_write16(dev, 0x007A,
+				      bcm43xx_radio_read16(dev, 0x007A)
+				      & 0x007F);
+		bcm43xx_phy_write(dev, 0x0814,
+				  bcm43xx_phy_read(dev, 0x0814) | 0x0001);
+		bcm43xx_phy_write(dev, 0x0815,
+				  bcm43xx_phy_read(dev, 0x0815) & 0xFFFE);
+		bcm43xx_phy_write(dev, 0x0811,
+				  bcm43xx_phy_read(dev, 0x0811) | 0x000C);
+		bcm43xx_phy_write(dev, 0x0812,
+				  bcm43xx_phy_read(dev, 0x0812) | 0x000C);
+		bcm43xx_phy_write(dev, 0x0811,
+				  bcm43xx_phy_read(dev, 0x0811) | 0x0030);
+		bcm43xx_phy_write(dev, 0x0812,
+				  bcm43xx_phy_read(dev, 0x0812) | 0x0030);
+		bcm43xx_phy_write(dev, 0x005A, 0x0480);
+		bcm43xx_phy_write(dev, 0x0059, 0x0810);
+		bcm43xx_phy_write(dev, 0x0058, 0x000D);
 		if (phy->analog == 0) {
-			bcm43xx_phy_write(bcm, 0x0003, 0x0122);
+			bcm43xx_phy_write(dev, 0x0003, 0x0122);
 		} else {
-			bcm43xx_phy_write(bcm, 0x000A,
-					  bcm43xx_phy_read(bcm, 0x000A)
+			bcm43xx_phy_write(dev, 0x000A,
+					  bcm43xx_phy_read(dev, 0x000A)
 					  | 0x2000);
 		}
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0004);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) & 0xFFFB);
-		bcm43xx_phy_write(bcm, 0x0003,
-				  (bcm43xx_phy_read(bcm, 0x0003) & 0xFF9F)
+		bcm43xx_phy_write(dev, 0x0814,
+				  bcm43xx_phy_read(dev, 0x0814) | 0x0004);
+		bcm43xx_phy_write(dev, 0x0815,
+				  bcm43xx_phy_read(dev, 0x0815) & 0xFFFB);
+		bcm43xx_phy_write(dev, 0x0003,
+				  (bcm43xx_phy_read(dev, 0x0003) & 0xFF9F)
 				  | 0x0040);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x000F);
-		bcm43xx_set_all_gains(bcm, 3, 0, 1);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      (bcm43xx_radio_read16(bcm, 0x0043)
+		bcm43xx_radio_write16(dev, 0x007A,
+				      bcm43xx_radio_read16(dev, 0x007A)
+							   | 0x000F);
+		bcm43xx_set_all_gains(dev, 3, 0, 1);
+		bcm43xx_radio_write16(dev, 0x0043,
+				      (bcm43xx_radio_read16(dev, 0x0043)
 				       & 0x00F0) | 0x000F);
 		udelay(30);
-		v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
+		v47F = (s16)((bcm43xx_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (v47F >= 0x20)
 			v47F -= 0x40;
 		if (v47F == -32) {
 			for (i = 0; i < 4; i++) {
-				bcm43xx_radio_write16(bcm, 0x007B, i);
+				bcm43xx_radio_write16(dev, 0x007B, i);
 				udelay(20);
-				v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
+				v47F = (s16)((bcm43xx_phy_read(dev,
+							       0x047F) >> 8)
+							       & 0x003F);
 				if (v47F >= 0x20)
 					v47F -= 0x40;
 				if (v47F > -31 && saved == 0xFFFF)
@@ -494,294 +498,312 @@ static void bcm43xx_calc_nrssi_offset(st
 			}
 			if (saved == 0xFFFF)
 				saved = 3;
-		} else
+		} else {
 			saved = 0;
+		}
 	}
-	bcm43xx_radio_write16(bcm, 0x007B, saved);
+	bcm43xx_radio_write16(dev, 0x007B, saved);
 
 	if (phy->rev >= 6) {
-		bcm43xx_phy_write(bcm, 0x002E, backup[12]);
-		bcm43xx_phy_write(bcm, 0x002F, backup[13]);
-		bcm43xx_phy_write(bcm, 0x080F, backup[14]);
-		bcm43xx_phy_write(bcm, 0x0810, backup[15]);
-	}
-	bcm43xx_phy_write(bcm, 0x0814, backup[3]);
-	bcm43xx_phy_write(bcm, 0x0815, backup[4]);
-	bcm43xx_phy_write(bcm, 0x005A, backup[5]);
-	bcm43xx_phy_write(bcm, 0x0059, backup[6]);
-	bcm43xx_phy_write(bcm, 0x0058, backup[7]);
-	bcm43xx_phy_write(bcm, 0x000A, backup[8]);
-	bcm43xx_phy_write(bcm, 0x0003, backup[9]);
-	bcm43xx_radio_write16(bcm, 0x0043, backup[11]);
-	bcm43xx_radio_write16(bcm, 0x007A, backup[10]);
-	bcm43xx_phy_write(bcm, 0x0802,
-			  bcm43xx_phy_read(bcm, 0x0802) | 0x1 | 0x2);
-	bcm43xx_phy_write(bcm, 0x0429,
-			  bcm43xx_phy_read(bcm, 0x0429) | 0x8000);
-	bcm43xx_set_original_gains(bcm);
+		bcm43xx_phy_write(dev, 0x002E, backup[12]);
+		bcm43xx_phy_write(dev, 0x002F, backup[13]);
+		bcm43xx_phy_write(dev, 0x080F, backup[14]);
+		bcm43xx_phy_write(dev, 0x0810, backup[15]);
+	}
+	bcm43xx_phy_write(dev, 0x0814, backup[3]);
+	bcm43xx_phy_write(dev, 0x0815, backup[4]);
+	bcm43xx_phy_write(dev, 0x005A, backup[5]);
+	bcm43xx_phy_write(dev, 0x0059, backup[6]);
+	bcm43xx_phy_write(dev, 0x0058, backup[7]);
+	bcm43xx_phy_write(dev, 0x000A, backup[8]);
+	bcm43xx_phy_write(dev, 0x0003, backup[9]);
+	bcm43xx_radio_write16(dev, 0x0043, backup[11]);
+	bcm43xx_radio_write16(dev, 0x007A, backup[10]);
+	bcm43xx_phy_write(dev, 0x0802,
+			  bcm43xx_phy_read(dev, 0x0802) | 0x1 | 0x2);
+	bcm43xx_phy_write(dev, 0x0429,
+			  bcm43xx_phy_read(dev, 0x0429) | 0x8000);
+	bcm43xx_set_original_gains(dev);
 	if (phy->rev >= 6) {
-		bcm43xx_phy_write(bcm, 0x0801, backup[16]);
-		bcm43xx_phy_write(bcm, 0x0060, backup[17]);
-		bcm43xx_phy_write(bcm, 0x0014, backup[18]);
-		bcm43xx_phy_write(bcm, 0x0478, backup[19]);
+		bcm43xx_phy_write(dev, 0x0801, backup[16]);
+		bcm43xx_phy_write(dev, 0x0060, backup[17]);
+		bcm43xx_phy_write(dev, 0x0014, backup[18]);
+		bcm43xx_phy_write(dev, 0x0478, backup[19]);
 	}
-	bcm43xx_phy_write(bcm, 0x0001, backup[0]);
-	bcm43xx_phy_write(bcm, 0x0812, backup[2]);
-	bcm43xx_phy_write(bcm, 0x0811, backup[1]);
+	bcm43xx_phy_write(dev, 0x0001, backup[0]);
+	bcm43xx_phy_write(dev, 0x0812, backup[2]);
+	bcm43xx_phy_write(dev, 0x0811, backup[1]);
 }
 
-void bcm43xx_calc_nrssi_slope(struct bcm43xx_private *bcm)
+void bcm43xx_calc_nrssi_slope(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 backup[18] = { 0 };
 	u16 tmp;
 	s16 nrssi0, nrssi1;
 
 	switch (phy->type) {
 	case BCM43xx_PHYTYPE_B:
-		backup[0] = bcm43xx_radio_read16(bcm, 0x007A);
-		backup[1] = bcm43xx_radio_read16(bcm, 0x0052);
-		backup[2] = bcm43xx_radio_read16(bcm, 0x0043);
-		backup[3] = bcm43xx_phy_read(bcm, 0x0030);
-		backup[4] = bcm43xx_phy_read(bcm, 0x0026);
-		backup[5] = bcm43xx_phy_read(bcm, 0x0015);
-		backup[6] = bcm43xx_phy_read(bcm, 0x002A);
-		backup[7] = bcm43xx_phy_read(bcm, 0x0020);
-		backup[8] = bcm43xx_phy_read(bcm, 0x005A);
-		backup[9] = bcm43xx_phy_read(bcm, 0x0059);
-		backup[10] = bcm43xx_phy_read(bcm, 0x0058);
-		backup[11] = bcm43xx_read16(bcm, 0x03E2);
-		backup[12] = bcm43xx_read16(bcm, 0x03E6);
-		backup[13] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
+		backup[0] = bcm43xx_radio_read16(dev, 0x007A);
+		backup[1] = bcm43xx_radio_read16(dev, 0x0052);
+		backup[2] = bcm43xx_radio_read16(dev, 0x0043);
+		backup[3] = bcm43xx_phy_read(dev, 0x0030);
+		backup[4] = bcm43xx_phy_read(dev, 0x0026);
+		backup[5] = bcm43xx_phy_read(dev, 0x0015);
+		backup[6] = bcm43xx_phy_read(dev, 0x002A);
+		backup[7] = bcm43xx_phy_read(dev, 0x0020);
+		backup[8] = bcm43xx_phy_read(dev, 0x005A);
+		backup[9] = bcm43xx_phy_read(dev, 0x0059);
+		backup[10] = bcm43xx_phy_read(dev, 0x0058);
+		backup[11] = bcm43xx_read16(dev, 0x03E2);
+		backup[12] = bcm43xx_read16(dev, 0x03E6);
+		backup[13] = bcm43xx_read16(dev, BCM43xx_MMIO_CHANNEL_EXT);
 
-		tmp  = bcm43xx_radio_read16(bcm, 0x007A);
+		tmp  = bcm43xx_radio_read16(dev, 0x007A);
 		tmp &= (phy->rev >= 5) ? 0x007F : 0x000F;
-		bcm43xx_radio_write16(bcm, 0x007A, tmp);
-		bcm43xx_phy_write(bcm, 0x0030, 0x00FF);
-		bcm43xx_write16(bcm, 0x03EC, 0x7F7F);
-		bcm43xx_phy_write(bcm, 0x0026, 0x0000);
-		bcm43xx_phy_write(bcm, 0x0015,
-				  bcm43xx_phy_read(bcm, 0x0015) | 0x0020);
-		bcm43xx_phy_write(bcm, 0x002A, 0x08A3);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x0080);
-
-		nrssi0 = (s16)bcm43xx_phy_read(bcm, 0x0027);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) & 0x007F);
+		bcm43xx_radio_write16(dev, 0x007A, tmp);
+		bcm43xx_phy_write(dev, 0x0030, 0x00FF);
+		bcm43xx_write16(dev, 0x03EC, 0x7F7F);
+		bcm43xx_phy_write(dev, 0x0026, 0x0000);
+		bcm43xx_phy_write(dev, 0x0015,
+				  bcm43xx_phy_read(dev, 0x0015) | 0x0020);
+		bcm43xx_phy_write(dev, 0x002A, 0x08A3);
+		bcm43xx_radio_write16(dev, 0x007A,
+				      bcm43xx_radio_read16(dev, 0x007A)
+				      | 0x0080);
+
+		nrssi0 = (s16)bcm43xx_phy_read(dev, 0x0027);
+		bcm43xx_radio_write16(dev, 0x007A,
+				      bcm43xx_radio_read16(dev, 0x007A)
+				      & 0x007F);
 		if (phy->analog >= 2) {
-			bcm43xx_write16(bcm, 0x03E6, 0x0040);
+			bcm43xx_write16(dev, 0x03E6, 0x0040);
 		} else if (phy->analog == 0) {
-			bcm43xx_write16(bcm, 0x03E6, 0x0122);
+			bcm43xx_write16(dev, 0x03E6, 0x0122);
 		} else {
-			bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-					bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT) & 0x2000);
-		}
-		bcm43xx_phy_write(bcm, 0x0020, 0x3F3F);
-		bcm43xx_phy_write(bcm, 0x0015, 0xF330);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0060);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      bcm43xx_radio_read16(bcm, 0x0043) & 0x00F0);
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0x0810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
+			bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL_EXT,
+					bcm43xx_read16(dev,
+					BCM43xx_MMIO_CHANNEL_EXT) & 0x2000);
+		}
+		bcm43xx_phy_write(dev, 0x0020, 0x3F3F);
+		bcm43xx_phy_write(dev, 0x0015, 0xF330);
+		bcm43xx_radio_write16(dev, 0x005A, 0x0060);
+		bcm43xx_radio_write16(dev, 0x0043,
+				      bcm43xx_radio_read16(dev, 0x0043)
+				      & 0x00F0);
+		bcm43xx_phy_write(dev, 0x005A, 0x0480);
+		bcm43xx_phy_write(dev, 0x0059, 0x0810);
+		bcm43xx_phy_write(dev, 0x0058, 0x000D);
 		udelay(20);
 
-		nrssi1 = (s16)bcm43xx_phy_read(bcm, 0x0027);
-		bcm43xx_phy_write(bcm, 0x0030, backup[3]);
-		bcm43xx_radio_write16(bcm, 0x007A, backup[0]);
-		bcm43xx_write16(bcm, 0x03E2, backup[11]);
-		bcm43xx_phy_write(bcm, 0x0026, backup[4]);
-		bcm43xx_phy_write(bcm, 0x0015, backup[5]);
-		bcm43xx_phy_write(bcm, 0x002A, backup[6]);
-		bcm43xx_synth_pu_workaround(bcm, radio->channel);
+		nrssi1 = (s16)bcm43xx_phy_read(dev, 0x0027);
+		bcm43xx_phy_write(dev, 0x0030, backup[3]);
+		bcm43xx_radio_write16(dev, 0x007A, backup[0]);
+		bcm43xx_write16(dev, 0x03E2, backup[11]);
+		bcm43xx_phy_write(dev, 0x0026, backup[4]);
+		bcm43xx_phy_write(dev, 0x0015, backup[5]);
+		bcm43xx_phy_write(dev, 0x002A, backup[6]);
+		bcm43xx_synth_pu_workaround(dev, phy->channel);
 		if (phy->analog != 0)
-			bcm43xx_write16(bcm, 0x03F4, backup[13]);
+			bcm43xx_write16(dev, 0x03F4, backup[13]);
 
-		bcm43xx_phy_write(bcm, 0x0020, backup[7]);
-		bcm43xx_phy_write(bcm, 0x005A, backup[8]);
-		bcm43xx_phy_write(bcm, 0x0059, backup[9]);
-		bcm43xx_phy_write(bcm, 0x0058, backup[10]);
-		bcm43xx_radio_write16(bcm, 0x0052, backup[1]);
-		bcm43xx_radio_write16(bcm, 0x0043, backup[2]);
+		bcm43xx_phy_write(dev, 0x0020, backup[7]);
+		bcm43xx_phy_write(dev, 0x005A, backup[8]);
+		bcm43xx_phy_write(dev, 0x0059, backup[9]);
+		bcm43xx_phy_write(dev, 0x0058, backup[10]);
+		bcm43xx_radio_write16(dev, 0x0052, backup[1]);
+		bcm43xx_radio_write16(dev, 0x0043, backup[2]);
 
 		if (nrssi0 == nrssi1)
-			radio->nrssislope = 0x00010000;
-		else 
-			radio->nrssislope = 0x00400000 / (nrssi0 - nrssi1);
+			phy->nrssislope = 0x00010000;
+		else
+			phy->nrssislope = 0x00400000 / (nrssi0 - nrssi1);
 
 		if (nrssi0 <= -4) {
-			radio->nrssi[0] = nrssi0;
-			radio->nrssi[1] = nrssi1;
+			phy->nrssi[0] = nrssi0;
+			phy->nrssi[1] = nrssi1;
 		}
 		break;
 	case BCM43xx_PHYTYPE_G:
-		if (radio->revision >= 9)
+		if (phy->radio_rev >= 9)
 			return;
-		if (radio->revision == 8)
-			bcm43xx_calc_nrssi_offset(bcm);
+		if (phy->radio_rev == 8)
+			bcm43xx_calc_nrssi_offset(dev);
 
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) & 0x7FFF);
-		bcm43xx_phy_write(bcm, 0x0802,
-				  bcm43xx_phy_read(bcm, 0x0802) & 0xFFFC);
-		backup[7] = bcm43xx_read16(bcm, 0x03E2);
-		bcm43xx_write16(bcm, 0x03E2,
-				bcm43xx_read16(bcm, 0x03E2) | 0x8000);
-		backup[0] = bcm43xx_radio_read16(bcm, 0x007A);
-		backup[1] = bcm43xx_radio_read16(bcm, 0x0052);
-		backup[2] = bcm43xx_radio_read16(bcm, 0x0043);
-		backup[3] = bcm43xx_phy_read(bcm, 0x0015);
-		backup[4] = bcm43xx_phy_read(bcm, 0x005A);
-		backup[5] = bcm43xx_phy_read(bcm, 0x0059);
-		backup[6] = bcm43xx_phy_read(bcm, 0x0058);
-		backup[8] = bcm43xx_read16(bcm, 0x03E6);
-		backup[9] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
+				  bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS)
+				  & 0x7FFF);
+		bcm43xx_phy_write(dev, 0x0802,
+				  bcm43xx_phy_read(dev, 0x0802) & 0xFFFC);
+		backup[7] = bcm43xx_read16(dev, 0x03E2);
+		bcm43xx_write16(dev, 0x03E2,
+				bcm43xx_read16(dev, 0x03E2) | 0x8000);
+		backup[0] = bcm43xx_radio_read16(dev, 0x007A);
+		backup[1] = bcm43xx_radio_read16(dev, 0x0052);
+		backup[2] = bcm43xx_radio_read16(dev, 0x0043);
+		backup[3] = bcm43xx_phy_read(dev, 0x0015);
+		backup[4] = bcm43xx_phy_read(dev, 0x005A);
+		backup[5] = bcm43xx_phy_read(dev, 0x0059);
+		backup[6] = bcm43xx_phy_read(dev, 0x0058);
+		backup[8] = bcm43xx_read16(dev, 0x03E6);
+		backup[9] = bcm43xx_read16(dev, BCM43xx_MMIO_CHANNEL_EXT);
 		if (phy->rev >= 3) {
-			backup[10] = bcm43xx_phy_read(bcm, 0x002E);
-			backup[11] = bcm43xx_phy_read(bcm, 0x002F);
-			backup[12] = bcm43xx_phy_read(bcm, 0x080F);
-			backup[13] = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_LO_CONTROL);
-			backup[14] = bcm43xx_phy_read(bcm, 0x0801);
-			backup[15] = bcm43xx_phy_read(bcm, 0x0060);
-			backup[16] = bcm43xx_phy_read(bcm, 0x0014);
-			backup[17] = bcm43xx_phy_read(bcm, 0x0478);
-			bcm43xx_phy_write(bcm, 0x002E, 0);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_LO_CONTROL, 0);
+			backup[10] = bcm43xx_phy_read(dev, 0x002E);
+			backup[11] = bcm43xx_phy_read(dev, 0x002F);
+			backup[12] = bcm43xx_phy_read(dev, 0x080F);
+			backup[13] = bcm43xx_phy_read(dev,
+						      BCM43xx_PHY_G_LO_CONTROL);
+			backup[14] = bcm43xx_phy_read(dev, 0x0801);
+			backup[15] = bcm43xx_phy_read(dev, 0x0060);
+			backup[16] = bcm43xx_phy_read(dev, 0x0014);
+			backup[17] = bcm43xx_phy_read(dev, 0x0478);
+			bcm43xx_phy_write(dev, 0x002E, 0);
+			bcm43xx_phy_write(dev, BCM43xx_PHY_G_LO_CONTROL, 0);
 			switch (phy->rev) {
 			case 4: case 6: case 7:
-				bcm43xx_phy_write(bcm, 0x0478,
-						  bcm43xx_phy_read(bcm, 0x0478)
+				bcm43xx_phy_write(dev, 0x0478,
+						  bcm43xx_phy_read(dev, 0x0478)
 						  | 0x0100);
-				bcm43xx_phy_write(bcm, 0x0801,
-						  bcm43xx_phy_read(bcm, 0x0801)
+				bcm43xx_phy_write(dev, 0x0801,
+						  bcm43xx_phy_read(dev, 0x0801)
 						  | 0x0040);
 				break;
 			case 3: case 5:
-				bcm43xx_phy_write(bcm, 0x0801,
-						  bcm43xx_phy_read(bcm, 0x0801)
+				bcm43xx_phy_write(dev, 0x0801,
+						  bcm43xx_phy_read(dev, 0x0801)
 						  & 0xFFBF);
 				break;
 			}
-			bcm43xx_phy_write(bcm, 0x0060,
-					  bcm43xx_phy_read(bcm, 0x0060)
+			bcm43xx_phy_write(dev, 0x0060,
+					  bcm43xx_phy_read(dev, 0x0060)
 					  | 0x0040);
-			bcm43xx_phy_write(bcm, 0x0014,
-					  bcm43xx_phy_read(bcm, 0x0014)
+			bcm43xx_phy_write(dev, 0x0014,
+					  bcm43xx_phy_read(dev, 0x0014)
 					  | 0x0200);
 		}
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x0070);
-		bcm43xx_set_all_gains(bcm, 0, 8, 0);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) & 0x00F7);
+		bcm43xx_radio_write16(dev, 0x007A,
+				      bcm43xx_radio_read16(dev, 0x007A)
+				      | 0x0070);
+		bcm43xx_set_all_gains(dev, 0, 8, 0);
+		bcm43xx_radio_write16(dev, 0x007A,
+				      bcm43xx_radio_read16(dev, 0x007A)
+				      & 0x00F7);
 		if (phy->rev >= 2) {
-			bcm43xx_phy_write(bcm, 0x0811,
-					  (bcm43xx_phy_read(bcm, 0x0811) & 0xFFCF) | 0x0030);
-			bcm43xx_phy_write(bcm, 0x0812,
-					  (bcm43xx_phy_read(bcm, 0x0812) & 0xFFCF) | 0x0010);
-		}
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x0080);
+			bcm43xx_phy_write(dev, 0x0811,
+					  (bcm43xx_phy_read(dev, 0x0811)
+					  & 0xFFCF) | 0x0030);
+			bcm43xx_phy_write(dev, 0x0812,
+					  (bcm43xx_phy_read(dev, 0x0812)
+					  & 0xFFCF) | 0x0010);
+		}
+		bcm43xx_radio_write16(dev, 0x007A,
+				      bcm43xx_radio_read16(dev, 0x007A)
+				      | 0x0080);
 		udelay(20);
 
-		nrssi0 = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
+		nrssi0 = (s16)((bcm43xx_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (nrssi0 >= 0x0020)
 			nrssi0 -= 0x0040;
 
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) & 0x007F);
+		bcm43xx_radio_write16(dev, 0x007A,
+				      bcm43xx_radio_read16(dev, 0x007A)
+				      & 0x007F);
 		if (phy->analog >= 2) {
-			bcm43xx_phy_write(bcm, 0x0003,
-					  (bcm43xx_phy_read(bcm, 0x0003)
+			bcm43xx_phy_write(dev, 0x0003,
+					  (bcm43xx_phy_read(dev, 0x0003)
 					   & 0xFF9F) | 0x0040);
 		}
 
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-				bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
+		bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL_EXT,
+				bcm43xx_read16(dev, BCM43xx_MMIO_CHANNEL_EXT)
 				| 0x2000);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x000F);
-		bcm43xx_phy_write(bcm, 0x0015, 0xF330);
+		bcm43xx_radio_write16(dev, 0x007A,
+				      bcm43xx_radio_read16(dev, 0x007A)
+				      | 0x000F);
+		bcm43xx_phy_write(dev, 0x0015, 0xF330);
 		if (phy->rev >= 2) {
-			bcm43xx_phy_write(bcm, 0x0812,
-					  (bcm43xx_phy_read(bcm, 0x0812) & 0xFFCF) | 0x0020);
-			bcm43xx_phy_write(bcm, 0x0811,
-					  (bcm43xx_phy_read(bcm, 0x0811) & 0xFFCF) | 0x0020);
+			bcm43xx_phy_write(dev, 0x0812,
+					  (bcm43xx_phy_read(dev, 0x0812)
+					  & 0xFFCF) | 0x0020);
+			bcm43xx_phy_write(dev, 0x0811,
+					  (bcm43xx_phy_read(dev, 0x0811)
+					  & 0xFFCF) | 0x0020);
 		}
 
-		bcm43xx_set_all_gains(bcm, 3, 0, 1);
-		if (radio->revision == 8) {
-			bcm43xx_radio_write16(bcm, 0x0043, 0x001F);
+		bcm43xx_set_all_gains(dev, 3, 0, 1);
+		if (phy->radio_rev == 8) {
+			bcm43xx_radio_write16(dev, 0x0043, 0x001F);
 		} else {
-			tmp = bcm43xx_radio_read16(bcm, 0x0052) & 0xFF0F;
-			bcm43xx_radio_write16(bcm, 0x0052, tmp | 0x0060);
-			tmp = bcm43xx_radio_read16(bcm, 0x0043) & 0xFFF0;
-			bcm43xx_radio_write16(bcm, 0x0043, tmp | 0x0009);
-		}
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0x0810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
+			tmp = bcm43xx_radio_read16(dev, 0x0052) & 0xFF0F;
+			bcm43xx_radio_write16(dev, 0x0052, tmp | 0x0060);
+			tmp = bcm43xx_radio_read16(dev, 0x0043) & 0xFFF0;
+			bcm43xx_radio_write16(dev, 0x0043, tmp | 0x0009);
+		}
+		bcm43xx_phy_write(dev, 0x005A, 0x0480);
+		bcm43xx_phy_write(dev, 0x0059, 0x0810);
+		bcm43xx_phy_write(dev, 0x0058, 0x000D);
 		udelay(20);
-		nrssi1 = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
+		nrssi1 = (s16)((bcm43xx_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (nrssi1 >= 0x0020)
 			nrssi1 -= 0x0040;
 		if (nrssi0 == nrssi1)
-			radio->nrssislope = 0x00010000;
+			phy->nrssislope = 0x00010000;
 		else
-			radio->nrssislope = 0x00400000 / (nrssi0 - nrssi1);
+			phy->nrssislope = 0x00400000 / (nrssi0 - nrssi1);
 		if (nrssi0 >= -4) {
-			radio->nrssi[0] = nrssi1;
-			radio->nrssi[1] = nrssi0;
+			phy->nrssi[0] = nrssi1;
+			phy->nrssi[1] = nrssi0;
 		}
 		if (phy->rev >= 3) {
-			bcm43xx_phy_write(bcm, 0x002E, backup[10]);
-			bcm43xx_phy_write(bcm, 0x002F, backup[11]);
-			bcm43xx_phy_write(bcm, 0x080F, backup[12]);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_LO_CONTROL, backup[13]);
+			bcm43xx_phy_write(dev, 0x002E, backup[10]);
+			bcm43xx_phy_write(dev, 0x002F, backup[11]);
+			bcm43xx_phy_write(dev, 0x080F, backup[12]);
+			bcm43xx_phy_write(dev, BCM43xx_PHY_G_LO_CONTROL,
+					  backup[13]);
 		}
 		if (phy->rev >= 2) {
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_phy_read(bcm, 0x0812) & 0xFFCF);
-			bcm43xx_phy_write(bcm, 0x0811,
-					  bcm43xx_phy_read(bcm, 0x0811) & 0xFFCF);
-		}
-
-		bcm43xx_radio_write16(bcm, 0x007A, backup[0]);
-		bcm43xx_radio_write16(bcm, 0x0052, backup[1]);
-		bcm43xx_radio_write16(bcm, 0x0043, backup[2]);
-		bcm43xx_write16(bcm, 0x03E2, backup[7]);
-		bcm43xx_write16(bcm, 0x03E6, backup[8]);
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, backup[9]);
-		bcm43xx_phy_write(bcm, 0x0015, backup[3]);
-		bcm43xx_phy_write(bcm, 0x005A, backup[4]);
-		bcm43xx_phy_write(bcm, 0x0059, backup[5]);
-		bcm43xx_phy_write(bcm, 0x0058, backup[6]);
-		bcm43xx_synth_pu_workaround(bcm, radio->channel);
-		bcm43xx_phy_write(bcm, 0x0802,
-				  bcm43xx_phy_read(bcm, 0x0802) | (0x0001 | 0x0002));
-		bcm43xx_set_original_gains(bcm);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x8000);
+			bcm43xx_phy_write(dev, 0x0812,
+					  bcm43xx_phy_read(dev, 0x0812)
+					  & 0xFFCF);
+			bcm43xx_phy_write(dev, 0x0811,
+					  bcm43xx_phy_read(dev, 0x0811)
+					  & 0xFFCF);
+		}
+
+		bcm43xx_radio_write16(dev, 0x007A, backup[0]);
+		bcm43xx_radio_write16(dev, 0x0052, backup[1]);
+		bcm43xx_radio_write16(dev, 0x0043, backup[2]);
+		bcm43xx_write16(dev, 0x03E2, backup[7]);
+		bcm43xx_write16(dev, 0x03E6, backup[8]);
+		bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL_EXT, backup[9]);
+		bcm43xx_phy_write(dev, 0x0015, backup[3]);
+		bcm43xx_phy_write(dev, 0x005A, backup[4]);
+		bcm43xx_phy_write(dev, 0x0059, backup[5]);
+		bcm43xx_phy_write(dev, 0x0058, backup[6]);
+		bcm43xx_synth_pu_workaround(dev, phy->channel);
+		bcm43xx_phy_write(dev, 0x0802,
+				  bcm43xx_phy_read(dev, 0x0802) | 0x0003);
+		bcm43xx_set_original_gains(dev);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
+				  bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS)
+				  | 0x8000);
 		if (phy->rev >= 3) {
-			bcm43xx_phy_write(bcm, 0x0801, backup[14]);
-			bcm43xx_phy_write(bcm, 0x0060, backup[15]);
-			bcm43xx_phy_write(bcm, 0x0014, backup[16]);
-			bcm43xx_phy_write(bcm, 0x0478, backup[17]);
+			bcm43xx_phy_write(dev, 0x0801, backup[14]);
+			bcm43xx_phy_write(dev, 0x0060, backup[15]);
+			bcm43xx_phy_write(dev, 0x0014, backup[16]);
+			bcm43xx_phy_write(dev, 0x0478, backup[17]);
 		}
-		bcm43xx_nrssi_mem_update(bcm);
-		bcm43xx_calc_nrssi_threshold(bcm);
+		bcm43xx_nrssi_mem_update(dev);
+		bcm43xx_calc_nrssi_threshold(dev);
 		break;
 	default:
-		assert(0);
+		BCM43xx_BUG_ON(1);
 	}
 }
 
-void bcm43xx_calc_nrssi_threshold(struct bcm43xx_private *bcm)
+void bcm43xx_calc_nrssi_threshold(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	s32 threshold;
 	s32 a, b;
 	s16 tmp16;
@@ -789,54 +811,59 @@ void bcm43xx_calc_nrssi_threshold(struct
 
 	switch (phy->type) {
 	case BCM43xx_PHYTYPE_B: {
-		if (radio->version != 0x2050)
+		if (phy->radio_ver != 0x2050)
 			return;
-		if (!(bcm->sprom.boardflags & BCM43xx_BFL_RSSI))
+		if (!(dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_RSSI))
 			return;
 
-		if (radio->revision >= 6) {
-			threshold = (radio->nrssi[1] - radio->nrssi[0]) * 32;
-			threshold += 20 * (radio->nrssi[0] + 1);
+		if (phy->radio_rev >= 6) {
+			threshold = (phy->nrssi[1] - phy->nrssi[0]) * 32;
+			threshold += 20 * (phy->nrssi[0] + 1);
 			threshold /= 40;
-		} else
-			threshold = radio->nrssi[1] - 5;
+		} else {
+			threshold = phy->nrssi[1] - 5;
+		}
 
 		threshold = limit_value(threshold, 0, 0x3E);
-		bcm43xx_phy_read(bcm, 0x0020); /* dummy read */
-		bcm43xx_phy_write(bcm, 0x0020, (((u16)threshold) << 8) | 0x001C);
-
-		if (radio->revision >= 6) {
-			bcm43xx_phy_write(bcm, 0x0087, 0x0E0D);
-			bcm43xx_phy_write(bcm, 0x0086, 0x0C0B);
-			bcm43xx_phy_write(bcm, 0x0085, 0x0A09);
-			bcm43xx_phy_write(bcm, 0x0084, 0x0808);
-			bcm43xx_phy_write(bcm, 0x0083, 0x0808);
-			bcm43xx_phy_write(bcm, 0x0082, 0x0604);
-			bcm43xx_phy_write(bcm, 0x0081, 0x0302);
-			bcm43xx_phy_write(bcm, 0x0080, 0x0100);
+		bcm43xx_phy_read(dev, 0x0020); /* dummy read */
+		bcm43xx_phy_write(dev, 0x0020, (((u16)threshold) << 8)
+				  | 0x001C);
+
+		if (phy->radio_rev >= 6) {
+			bcm43xx_phy_write(dev, 0x0087, 0x0E0D);
+			bcm43xx_phy_write(dev, 0x0086, 0x0C0B);
+			bcm43xx_phy_write(dev, 0x0085, 0x0A09);
+			bcm43xx_phy_write(dev, 0x0084, 0x0808);
+			bcm43xx_phy_write(dev, 0x0083, 0x0808);
+			bcm43xx_phy_write(dev, 0x0082, 0x0604);
+			bcm43xx_phy_write(dev, 0x0081, 0x0302);
+			bcm43xx_phy_write(dev, 0x0080, 0x0100);
 		}
 		break;
 	}
 	case BCM43xx_PHYTYPE_G:
-		if (!phy->connected ||
-		    !(bcm->sprom.boardflags & BCM43xx_BFL_RSSI)) {
-			tmp16 = bcm43xx_nrssi_hw_read(bcm, 0x20);
+		if (!phy->gmode ||
+		    !(dev->dev->bus->sprom.r1.boardflags_lo &
+		    BCM43xx_BFL_RSSI)) {
+			tmp16 = bcm43xx_nrssi_hw_read(dev, 0x20);
 			if (tmp16 >= 0x20)
 				tmp16 -= 0x40;
 			if (tmp16 < 3) {
-				bcm43xx_phy_write(bcm, 0x048A,
-						  (bcm43xx_phy_read(bcm, 0x048A)
+				bcm43xx_phy_write(dev, 0x048A,
+						  (bcm43xx_phy_read(dev, 0x048A)
 						   & 0xF000) | 0x09EB);
 			} else {
-				bcm43xx_phy_write(bcm, 0x048A,
-						  (bcm43xx_phy_read(bcm, 0x048A)
+				bcm43xx_phy_write(dev, 0x048A,
+						  (bcm43xx_phy_read(dev, 0x048A)
 						   & 0xF000) | 0x0AED);
 			}
 		} else {
-			if (radio->interfmode == BCM43xx_RADIO_INTERFMODE_NONWLAN) {
+			if (phy->interfmode ==
+			    BCM43xx_RADIO_INTERFMODE_NONWLAN) {
 				a = 0xE;
 				b = 0xA;
-			} else if (!radio->aci_wlan_automatic && radio->aci_enable) {
+			} else if (!phy->aci_wlan_automatic &&
+				    phy->aci_enable) {
 				a = 0x13;
 				b = 0x12;
 			} else {
@@ -844,8 +871,8 @@ void bcm43xx_calc_nrssi_threshold(struct
 				b = 0x11;
 			}
 
-			a = a * (radio->nrssi[1] - radio->nrssi[0]);
-			a += (radio->nrssi[0] << 6);
+			a = a * (phy->nrssi[1] - phy->nrssi[0]);
+			a += (phy->nrssi[0] << 6);
 			if (a < 32)
 				a += 31;
 			else
@@ -853,8 +880,8 @@ void bcm43xx_calc_nrssi_threshold(struct
 			a = a >> 6;
 			a = limit_value(a, -31, 31);
 
-			b = b * (radio->nrssi[1] - radio->nrssi[0]);
-			b += (radio->nrssi[0] << 6);
+			b = b * (phy->nrssi[1] - phy->nrssi[0]);
+			b += (phy->nrssi[0] << 6);
 			if (b < 32)
 				b += 31;
 			else
@@ -862,14 +889,14 @@ void bcm43xx_calc_nrssi_threshold(struct
 			b = b >> 6;
 			b = limit_value(b, -31, 31);
 
-			tmp_u16 = bcm43xx_phy_read(bcm, 0x048A) & 0xF000;
+			tmp_u16 = bcm43xx_phy_read(dev, 0x048A) & 0xF000;
 			tmp_u16 |= ((u32)b & 0x0000003F);
 			tmp_u16 |= (((u32)a & 0x0000003F) << 6);
-			bcm43xx_phy_write(bcm, 0x048A, tmp_u16);
+			bcm43xx_phy_write(dev, 0x048A, tmp_u16);
 		}
 		break;
 	default:
-		assert(0);
+		BCM43xx_BUG_ON(1);
 	}
 }
 
@@ -882,13 +909,13 @@ static void _stack_save(u32 *_stackptr, 
 {
 	u32 *stackptr = &(_stackptr[*stackidx]);
 
-	assert((offset & 0xE000) == 0x0000);
-	assert((id & 0xF8) == 0x00);
+	BCM43xx_WARN_ON(!((offset & 0xE000) == 0x0000));
+	BCM43xx_WARN_ON(!((id & 0xF8) == 0x00));
 	*stackptr = offset;
 	*stackptr |= ((u32)id) << 13;
 	*stackptr |= ((u32)value) << 16;
 	(*stackidx)++;
-	assert(*stackidx < BCM43xx_INTERFSTACK_SIZE);
+	BCM43xx_WARN_ON(!(*stackidx < BCM43xx_INTERFSTACK_SIZE));
 }
 
 static u16 _stack_restore(u32 *stackptr,
@@ -896,8 +923,8 @@ static u16 _stack_restore(u32 *stackptr,
 {
 	size_t i;
 
-	assert((offset & 0xE000) == 0x0000);
-	assert((id & 0xF8) == 0x00);
+	BCM43xx_WARN_ON(!((offset & 0xE000) == 0x0000));
+	BCM43xx_WARN_ON(!((id & 0xF8) == 0x00));
 	for (i = 0; i < BCM43xx_INTERFSTACK_SIZE; i++, stackptr++) {
 		if ((*stackptr & 0x00001FFF) != offset)
 			continue;
@@ -905,7 +932,7 @@ static u16 _stack_restore(u32 *stackptr,
 			continue;
 		return ((*stackptr & 0xFFFF0000) >> 16);
 	}
-	assert(0);
+	BCM43xx_BUG_ON(1);
 
 	return 0;
 }
@@ -913,59 +940,60 @@ static u16 _stack_restore(u32 *stackptr,
 #define phy_stacksave(offset)					\
 	do {							\
 		_stack_save(stack, &stackidx, 0x1, (offset),	\
-			    bcm43xx_phy_read(bcm, (offset)));	\
+			    bcm43xx_phy_read(dev, (offset)));	\
 	} while (0)
 #define phy_stackrestore(offset)				\
 	do {							\
-		bcm43xx_phy_write(bcm, (offset),		\
+		bcm43xx_phy_write(dev, (offset),		\
 				  _stack_restore(stack, 0x1,	\
 					  	 (offset)));	\
 	} while (0)
 #define radio_stacksave(offset)						\
 	do {								\
 		_stack_save(stack, &stackidx, 0x2, (offset),		\
-			    bcm43xx_radio_read16(bcm, (offset)));	\
+			    bcm43xx_radio_read16(dev, (offset)));	\
 	} while (0)
 #define radio_stackrestore(offset)					\
 	do {								\
-		bcm43xx_radio_write16(bcm, (offset),			\
+		bcm43xx_radio_write16(dev, (offset),			\
 				      _stack_restore(stack, 0x2,	\
 						     (offset)));	\
 	} while (0)
 #define ilt_stacksave(offset)					\
 	do {							\
 		_stack_save(stack, &stackidx, 0x3, (offset),	\
-			    bcm43xx_ilt_read(bcm, (offset)));	\
+			    bcm43xx_ilt_read(dev, (offset)));	\
 	} while (0)
 #define ilt_stackrestore(offset)				\
 	do {							\
-		bcm43xx_ilt_write(bcm, (offset),		\
+		bcm43xx_ilt_write(dev, (offset),		\
 				  _stack_restore(stack, 0x3,	\
 						 (offset)));	\
 	} while (0)
 
 static void
-bcm43xx_radio_interference_mitigation_enable(struct bcm43xx_private *bcm,
+bcm43xx_radio_interference_mitigation_enable(struct bcm43xx_wldev *dev,
 					     int mode)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 tmp, flipped;
 	u32 tmp32;
 	size_t stackidx = 0;
-	u32 *stack = radio->interfstack;
+	u32 *stack = phy->interfstack;
 
 	switch (mode) {
 	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
 		if (phy->rev != 1) {
-			bcm43xx_phy_write(bcm, 0x042B,
-			                  bcm43xx_phy_read(bcm, 0x042B) | 0x0800);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-			                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) & ~0x4000);
+			bcm43xx_phy_write(dev, 0x042B,
+					  bcm43xx_phy_read(dev, 0x042B)
+					  | 0x0800);
+			bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
+					  bcm43xx_phy_read(dev,
+					  BCM43xx_PHY_G_CRS) & ~0x4000);
 			break;
 		}
 		radio_stacksave(0x0078);
-		tmp = (bcm43xx_radio_read16(bcm, 0x0078) & 0x001E);
+		tmp = (bcm43xx_radio_read16(dev, 0x0078) & 0x001E);
 		flipped = flip_4bit(tmp);
 		if (flipped < 10 && flipped >= 8)
 			flipped = 7;
@@ -973,52 +1001,58 @@ bcm43xx_radio_interference_mitigation_en
 			flipped -= 3;
 		flipped = flip_4bit(flipped);
 		flipped = (flipped << 1) | 0x0020;
-		bcm43xx_radio_write16(bcm, 0x0078, flipped);
+		bcm43xx_radio_write16(dev, 0x0078, flipped);
 
-		bcm43xx_calc_nrssi_threshold(bcm);
+		bcm43xx_calc_nrssi_threshold(dev);
 
 		phy_stacksave(0x0406);
-		bcm43xx_phy_write(bcm, 0x0406, 0x7E28);
+		bcm43xx_phy_write(dev, 0x0406, 0x7E28);
 
-		bcm43xx_phy_write(bcm, 0x042B,
-		                  bcm43xx_phy_read(bcm, 0x042B) | 0x0800);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-		                  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD) | 0x1000);
+		bcm43xx_phy_write(dev, 0x042B,
+				  bcm43xx_phy_read(dev, 0x042B) | 0x0800);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_RADIO_BITFIELD,
+				  bcm43xx_phy_read(dev,
+				  BCM43xx_PHY_RADIO_BITFIELD) | 0x1000);
 
 		phy_stacksave(0x04A0);
-		bcm43xx_phy_write(bcm, 0x04A0,
-		                  (bcm43xx_phy_read(bcm, 0x04A0) & 0xC0C0) | 0x0008);
+		bcm43xx_phy_write(dev, 0x04A0,
+				  (bcm43xx_phy_read(dev, 0x04A0) & 0xC0C0)
+				  | 0x0008);
 		phy_stacksave(0x04A1);
-		bcm43xx_phy_write(bcm, 0x04A1,
-				  (bcm43xx_phy_read(bcm, 0x04A1) & 0xC0C0) | 0x0605);
+		bcm43xx_phy_write(dev, 0x04A1,
+				  (bcm43xx_phy_read(dev, 0x04A1) & 0xC0C0)
+				  | 0x0605);
 		phy_stacksave(0x04A2);
-		bcm43xx_phy_write(bcm, 0x04A2,
-				  (bcm43xx_phy_read(bcm, 0x04A2) & 0xC0C0) | 0x0204);
+		bcm43xx_phy_write(dev, 0x04A2,
+				  (bcm43xx_phy_read(dev, 0x04A2) & 0xC0C0)
+				  | 0x0204);
 		phy_stacksave(0x04A8);
-		bcm43xx_phy_write(bcm, 0x04A8,
-				  (bcm43xx_phy_read(bcm, 0x04A8) & 0xC0C0) | 0x0803);
+		bcm43xx_phy_write(dev, 0x04A8,
+				  (bcm43xx_phy_read(dev, 0x04A8) & 0xC0C0)
+				  | 0x0803);
 		phy_stacksave(0x04AB);
-		bcm43xx_phy_write(bcm, 0x04AB,
-				  (bcm43xx_phy_read(bcm, 0x04AB) & 0xC0C0) | 0x0605);
+		bcm43xx_phy_write(dev, 0x04AB,
+				  (bcm43xx_phy_read(dev, 0x04AB) & 0xC0C0)
+				  | 0x0605);
 
 		phy_stacksave(0x04A7);
-		bcm43xx_phy_write(bcm, 0x04A7, 0x0002);
+		bcm43xx_phy_write(dev, 0x04A7, 0x0002);
 		phy_stacksave(0x04A3);
-		bcm43xx_phy_write(bcm, 0x04A3, 0x287A);
+		bcm43xx_phy_write(dev, 0x04A3, 0x287A);
 		phy_stacksave(0x04A9);
-		bcm43xx_phy_write(bcm, 0x04A9, 0x2027);
+		bcm43xx_phy_write(dev, 0x04A9, 0x2027);
 		phy_stacksave(0x0493);
-		bcm43xx_phy_write(bcm, 0x0493, 0x32F5);
+		bcm43xx_phy_write(dev, 0x0493, 0x32F5);
 		phy_stacksave(0x04AA);
-		bcm43xx_phy_write(bcm, 0x04AA, 0x2027);
+		bcm43xx_phy_write(dev, 0x04AA, 0x2027);
 		phy_stacksave(0x04AC);
-		bcm43xx_phy_write(bcm, 0x04AC, 0x32F5);
+		bcm43xx_phy_write(dev, 0x04AC, 0x32F5);
 		break;
 	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		if (bcm43xx_phy_read(bcm, 0x0033) & 0x0800)
+		if (bcm43xx_phy_read(dev, 0x0033) & 0x0800)
 			break;
 
-		radio->aci_enable = 1;
+		phy->aci_enable = 1;
 
 		phy_stacksave(BCM43xx_PHY_RADIO_BITFIELD);
 		phy_stacksave(BCM43xx_PHY_G_CRS);
@@ -1055,163 +1089,165 @@ bcm43xx_radio_interference_mitigation_en
 		phy_stacksave(0x042B);
 		phy_stacksave(0x048C);
 
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD)
-				  & ~0x1000);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  (bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS)
+		bcm43xx_phy_write(dev, BCM43xx_PHY_RADIO_BITFIELD,
+				  bcm43xx_phy_read(dev,
+				  BCM43xx_PHY_RADIO_BITFIELD) & ~0x1000);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
+				  (bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS)
 				   & 0xFFFC) | 0x0002);
 
-		bcm43xx_phy_write(bcm, 0x0033, 0x0800);
-		bcm43xx_phy_write(bcm, 0x04A3, 0x2027);
-		bcm43xx_phy_write(bcm, 0x04A9, 0x1CA8);
-		bcm43xx_phy_write(bcm, 0x0493, 0x287A);
-		bcm43xx_phy_write(bcm, 0x04AA, 0x1CA8);
-		bcm43xx_phy_write(bcm, 0x04AC, 0x287A);
+		bcm43xx_phy_write(dev, 0x0033, 0x0800);
+		bcm43xx_phy_write(dev, 0x04A3, 0x2027);
+		bcm43xx_phy_write(dev, 0x04A9, 0x1CA8);
+		bcm43xx_phy_write(dev, 0x0493, 0x287A);
+		bcm43xx_phy_write(dev, 0x04AA, 0x1CA8);
+		bcm43xx_phy_write(dev, 0x04AC, 0x287A);
 
-		bcm43xx_phy_write(bcm, 0x04A0,
-				  (bcm43xx_phy_read(bcm, 0x04A0)
+		bcm43xx_phy_write(dev, 0x04A0,
+				  (bcm43xx_phy_read(dev, 0x04A0)
 				   & 0xFFC0) | 0x001A);
-		bcm43xx_phy_write(bcm, 0x04A7, 0x000D);
+		bcm43xx_phy_write(dev, 0x04A7, 0x000D);
 
 		if (phy->rev < 2) {
-			bcm43xx_phy_write(bcm, 0x0406, 0xFF0D);
+			bcm43xx_phy_write(dev, 0x0406, 0xFF0D);
 		} else if (phy->rev == 2) {
-			bcm43xx_phy_write(bcm, 0x04C0, 0xFFFF);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x00A9);
+			bcm43xx_phy_write(dev, 0x04C0, 0xFFFF);
+			bcm43xx_phy_write(dev, 0x04C1, 0x00A9);
 		} else {
-			bcm43xx_phy_write(bcm, 0x04C0, 0x00C1);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x0059);
+			bcm43xx_phy_write(dev, 0x04C0, 0x00C1);
+			bcm43xx_phy_write(dev, 0x04C1, 0x0059);
 		}
 
-		bcm43xx_phy_write(bcm, 0x04A1,
-		                  (bcm43xx_phy_read(bcm, 0x04A1)
-				   & 0xC0FF) | 0x1800);
-		bcm43xx_phy_write(bcm, 0x04A1,
-		                  (bcm43xx_phy_read(bcm, 0x04A1)
-				   & 0xFFC0) | 0x0015);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   & 0xCFFF) | 0x1000);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   & 0xF0FF) | 0x0A00);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   & 0xCFFF) | 0x1000);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   & 0xF0FF) | 0x0800);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   & 0xFFCF) | 0x0010);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   & 0xFFF0) | 0x0005);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   & 0xFFCF) | 0x0010);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   & 0xFFF0) | 0x0006);
-		bcm43xx_phy_write(bcm, 0x04A2,
-		                  (bcm43xx_phy_read(bcm, 0x04A2)
-				   & 0xF0FF) | 0x0800);
-		bcm43xx_phy_write(bcm, 0x04A0,
-				  (bcm43xx_phy_read(bcm, 0x04A0)
-				   & 0xF0FF) | 0x0500);
-		bcm43xx_phy_write(bcm, 0x04A2,
-				  (bcm43xx_phy_read(bcm, 0x04A2)
-				   & 0xFFF0) | 0x000B);
+		bcm43xx_phy_write(dev, 0x04A1,
+				  (bcm43xx_phy_read(dev, 0x04A1)
+				  & 0xC0FF) | 0x1800);
+		bcm43xx_phy_write(dev, 0x04A1,
+				  (bcm43xx_phy_read(dev, 0x04A1)
+				  & 0xFFC0) | 0x0015);
+		bcm43xx_phy_write(dev, 0x04A8,
+				  (bcm43xx_phy_read(dev, 0x04A8)
+				  & 0xCFFF) | 0x1000);
+		bcm43xx_phy_write(dev, 0x04A8,
+				  (bcm43xx_phy_read(dev, 0x04A8)
+				  & 0xF0FF) | 0x0A00);
+		bcm43xx_phy_write(dev, 0x04AB,
+				  (bcm43xx_phy_read(dev, 0x04AB)
+				  & 0xCFFF) | 0x1000);
+		bcm43xx_phy_write(dev, 0x04AB,
+				  (bcm43xx_phy_read(dev, 0x04AB)
+				  & 0xF0FF) | 0x0800);
+		bcm43xx_phy_write(dev, 0x04AB,
+				  (bcm43xx_phy_read(dev, 0x04AB)
+				  & 0xFFCF) | 0x0010);
+		bcm43xx_phy_write(dev, 0x04AB,
+				  (bcm43xx_phy_read(dev, 0x04AB)
+				  & 0xFFF0) | 0x0005);
+		bcm43xx_phy_write(dev, 0x04A8,
+				  (bcm43xx_phy_read(dev, 0x04A8)
+				  & 0xFFCF) | 0x0010);
+		bcm43xx_phy_write(dev, 0x04A8,
+				  (bcm43xx_phy_read(dev, 0x04A8)
+				  & 0xFFF0) | 0x0006);
+		bcm43xx_phy_write(dev, 0x04A2,
+				  (bcm43xx_phy_read(dev, 0x04A2)
+				  & 0xF0FF) | 0x0800);
+		bcm43xx_phy_write(dev, 0x04A0,
+				  (bcm43xx_phy_read(dev, 0x04A0)
+				  & 0xF0FF) | 0x0500);
+		bcm43xx_phy_write(dev, 0x04A2,
+				  (bcm43xx_phy_read(dev, 0x04A2)
+				  & 0xFFF0) | 0x000B);
 
 		if (phy->rev >= 3) {
-			bcm43xx_phy_write(bcm, 0x048A,
-					  bcm43xx_phy_read(bcm, 0x048A)
+			bcm43xx_phy_write(dev, 0x048A,
+					  bcm43xx_phy_read(dev, 0x048A)
 					  & ~0x8000);
-			bcm43xx_phy_write(bcm, 0x0415,
-					  (bcm43xx_phy_read(bcm, 0x0415)
+			bcm43xx_phy_write(dev, 0x0415,
+					  (bcm43xx_phy_read(dev, 0x0415)
 					   & 0x8000) | 0x36D8);
-			bcm43xx_phy_write(bcm, 0x0416,
-					  (bcm43xx_phy_read(bcm, 0x0416)
+			bcm43xx_phy_write(dev, 0x0416,
+					  (bcm43xx_phy_read(dev, 0x0416)
 					   & 0x8000) | 0x36D8);
-			bcm43xx_phy_write(bcm, 0x0417,
-					  (bcm43xx_phy_read(bcm, 0x0417)
+			bcm43xx_phy_write(dev, 0x0417,
+					  (bcm43xx_phy_read(dev, 0x0417)
 					   & 0xFE00) | 0x016D);
 		} else {
-			bcm43xx_phy_write(bcm, 0x048A,
-					  bcm43xx_phy_read(bcm, 0x048A)
+			bcm43xx_phy_write(dev, 0x048A,
+					  bcm43xx_phy_read(dev, 0x048A)
 					  | 0x1000);
-			bcm43xx_phy_write(bcm, 0x048A,
-					  (bcm43xx_phy_read(bcm, 0x048A)
+			bcm43xx_phy_write(dev, 0x048A,
+					  (bcm43xx_phy_read(dev, 0x048A)
 					   & 0x9FFF) | 0x2000);
-			tmp32 = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
+			tmp32 = bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED,
 						   BCM43xx_UCODEFLAGS_OFFSET);
 			if (!(tmp32 & 0x800)) {
 				tmp32 |= 0x800;
-				bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
+				bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED,
 						    BCM43xx_UCODEFLAGS_OFFSET,
 						    tmp32);
 			}
 		}
 		if (phy->rev >= 2) {
-			bcm43xx_phy_write(bcm, 0x042B,
-					  bcm43xx_phy_read(bcm, 0x042B)
+			bcm43xx_phy_write(dev, 0x042B,
+					  bcm43xx_phy_read(dev, 0x042B)
 					  | 0x0800);
 		}
-		bcm43xx_phy_write(bcm, 0x048C,
-				  (bcm43xx_phy_read(bcm, 0x048C)
+		bcm43xx_phy_write(dev, 0x048C,
+				  (bcm43xx_phy_read(dev, 0x048C)
 				   & 0xF0FF) | 0x0200);
 		if (phy->rev == 2) {
-			bcm43xx_phy_write(bcm, 0x04AE,
-					  (bcm43xx_phy_read(bcm, 0x04AE)
+			bcm43xx_phy_write(dev, 0x04AE,
+					  (bcm43xx_phy_read(dev, 0x04AE)
 					   & 0xFF00) | 0x007F);
-			bcm43xx_phy_write(bcm, 0x04AD,
-					  (bcm43xx_phy_read(bcm, 0x04AD)
+			bcm43xx_phy_write(dev, 0x04AD,
+					  (bcm43xx_phy_read(dev, 0x04AD)
 					   & 0x00FF) | 0x1300);
 		} else if (phy->rev >= 6) {
-			bcm43xx_ilt_write(bcm, 0x1A00 + 0x3, 0x007F);
-			bcm43xx_ilt_write(bcm, 0x1A00 + 0x2, 0x007F);
-			bcm43xx_phy_write(bcm, 0x04AD,
-					  bcm43xx_phy_read(bcm, 0x04AD)
+			bcm43xx_ilt_write(dev, 0x1A00 + 0x3, 0x007F);
+			bcm43xx_ilt_write(dev, 0x1A00 + 0x2, 0x007F);
+			bcm43xx_phy_write(dev, 0x04AD,
+					  bcm43xx_phy_read(dev, 0x04AD)
 					  & 0x00FF);
 		}
-		bcm43xx_calc_nrssi_slope(bcm);
+		bcm43xx_calc_nrssi_slope(dev);
 		break;
 	default:
-		assert(0);
+		BCM43xx_BUG_ON(1);
 	}
 }
 
 static void
-bcm43xx_radio_interference_mitigation_disable(struct bcm43xx_private *bcm,
+bcm43xx_radio_interference_mitigation_disable(struct bcm43xx_wldev *dev,
 					      int mode)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u32 tmp32;
-	u32 *stack = radio->interfstack;
+	u32 *stack = phy->interfstack;
 
 	switch (mode) {
 	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
 		if (phy->rev != 1) {
-			bcm43xx_phy_write(bcm, 0x042B,
-			                  bcm43xx_phy_read(bcm, 0x042B) & ~0x0800);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-			                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x4000);
+			bcm43xx_phy_write(dev, 0x042B,
+					  bcm43xx_phy_read(dev, 0x042B)
+					  & ~0x0800);
+			bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
+					  bcm43xx_phy_read(dev,
+					  BCM43xx_PHY_G_CRS) | 0x4000);
 			break;
 		}
 		phy_stackrestore(0x0078);
-		bcm43xx_calc_nrssi_threshold(bcm);
+		bcm43xx_calc_nrssi_threshold(dev);
 		phy_stackrestore(0x0406);
-		bcm43xx_phy_write(bcm, 0x042B,
-				  bcm43xx_phy_read(bcm, 0x042B) & ~0x0800);
-		if (!bcm->bad_frames_preempt) {
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-					  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD)
+		bcm43xx_phy_write(dev, 0x042B,
+				  bcm43xx_phy_read(dev, 0x042B) & ~0x0800);
+		if (!dev->bad_frames_preempt)
+			bcm43xx_phy_write(dev, BCM43xx_PHY_RADIO_BITFIELD,
+					  bcm43xx_phy_read(dev,
+					  BCM43xx_PHY_RADIO_BITFIELD)
 					  & ~(1 << 11));
-		}
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x4000);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
+				  bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS)
+				  | 0x4000);
 		phy_stackrestore(0x04A0);
 		phy_stackrestore(0x04A1);
 		phy_stackrestore(0x04A2);
@@ -1225,10 +1261,10 @@ bcm43xx_radio_interference_mitigation_di
 		phy_stackrestore(0x04AC);
 		break;
 	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		if (!(bcm43xx_phy_read(bcm, 0x0033) & 0x0800))
+		if (!(bcm43xx_phy_read(dev, 0x0033) & 0x0800))
 			break;
 
-		radio->aci_enable = 0;
+		phy->aci_enable = 0;
 
 		phy_stackrestore(BCM43xx_PHY_RADIO_BITFIELD);
 		phy_stackrestore(BCM43xx_PHY_G_CRS);
@@ -1243,8 +1279,9 @@ bcm43xx_radio_interference_mitigation_di
 		if (phy->rev >= 2) {
 			phy_stackrestore(0x04C0);
 			phy_stackrestore(0x04C1);
-		} else
+		} else {
 			phy_stackrestore(0x0406);
+		}
 		phy_stackrestore(0x04A1);
 		phy_stackrestore(0x04AB);
 		phy_stackrestore(0x04A8);
@@ -1263,18 +1300,18 @@ bcm43xx_radio_interference_mitigation_di
 		phy_stackrestore(0x04A8);
 		phy_stackrestore(0x042B);
 		phy_stackrestore(0x048C);
-		tmp32 = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
+		tmp32 = bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED,
 					   BCM43xx_UCODEFLAGS_OFFSET);
 		if (tmp32 & 0x800) {
 			tmp32 &= ~0x800;
-			bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
+			bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED,
 					    BCM43xx_UCODEFLAGS_OFFSET,
 					    tmp32);
 		}
-		bcm43xx_calc_nrssi_slope(bcm);
+		bcm43xx_calc_nrssi_slope(dev);
 		break;
 	default:
-		assert(0);
+		BCM43xx_BUG_ON(1);
 	}
 }
 
@@ -1285,23 +1322,22 @@ bcm43xx_radio_interference_mitigation_di
 #undef ilt_stacksave
 #undef ilt_stackrestore
 
-int bcm43xx_radio_set_interference_mitigation(struct bcm43xx_private *bcm,
+int bcm43xx_radio_set_interference_mitigation(struct bcm43xx_wldev *dev,
 					      int mode)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	int currentmode;
 
 	if ((phy->type != BCM43xx_PHYTYPE_G) ||
 	    (phy->rev == 0) ||
-	    (!phy->connected))
+	    (!phy->gmode))
 		return -ENODEV;
 
-	radio->aci_wlan_automatic = 0;
+	phy->aci_wlan_automatic = 0;
 	switch (mode) {
 	case BCM43xx_RADIO_INTERFMODE_AUTOWLAN:
-		radio->aci_wlan_automatic = 1;
-		if (radio->aci_enable)
+		phy->aci_wlan_automatic = 1;
+		if (phy->aci_enable)
 			mode = BCM43xx_RADIO_INTERFMODE_MANUALWLAN;
 		else
 			mode = BCM43xx_RADIO_INTERFMODE_NONE;
@@ -1314,27 +1350,28 @@ int bcm43xx_radio_set_interference_mitig
 		return -EINVAL;
 	}
 
-	currentmode = radio->interfmode;
+	currentmode = phy->interfmode;
 	if (currentmode == mode)
 		return 0;
 	if (currentmode != BCM43xx_RADIO_INTERFMODE_NONE)
-		bcm43xx_radio_interference_mitigation_disable(bcm, currentmode);
+		bcm43xx_radio_interference_mitigation_disable(dev, currentmode);
 
 	if (mode == BCM43xx_RADIO_INTERFMODE_NONE) {
-		radio->aci_enable = 0;
-		radio->aci_hw_rssi = 0;
-	} else
-		bcm43xx_radio_interference_mitigation_enable(bcm, mode);
-	radio->interfmode = mode;
+		phy->aci_enable = 0;
+		phy->aci_hw_rssi = 0;
+	} else {
+		bcm43xx_radio_interference_mitigation_enable(dev, mode);
+	}
+	phy->interfmode = mode;
 
 	return 0;
 }
 
-u16 bcm43xx_radio_calibrationvalue(struct bcm43xx_private *bcm)
+u16 bcm43xx_radio_calibrationvalue(struct bcm43xx_wldev *dev)
 {
 	u16 reg, index, ret;
 
-	reg = bcm43xx_radio_read16(bcm, 0x0060);
+	reg = bcm43xx_radio_read16(dev, 0x0060);
 	index = (reg & 0x001E) >> 1;
 	ret = rcc_table[index] << 1;
 	ret |= (reg & 0x0001);
@@ -1344,19 +1381,18 @@ u16 bcm43xx_radio_calibrationvalue(struc
 }
 
 #define LPD(L, P, D)    (((L) << 2) | ((P) << 1) | ((D) << 0))
-static u16 bcm43xx_get_812_value(struct bcm43xx_private *bcm, u8 lpd)
+static u16 bcm43xx_get_812_value(struct bcm43xx_wldev *dev, u8 lpd)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 loop_or = 0;
 	u16 adj_loopback_gain = phy->loopback_gain[0];
 	u8 loop;
 	u16 extern_lna_control;
 
-	if (!phy->connected)
+	if (!phy->gmode)
 		return 0;
 	if (!has_loopback_gain(phy)) {
-		if (phy->rev < 7 || !(bcm->sprom.boardflags
+		if (phy->rev < 7 || !(dev->dev->bus->sprom.r1.boardflags_lo
 		    & BCM43xx_BFL_EXTLNA)) {
 			switch (lpd) {
 			case LPD(0, 1, 1):
@@ -1368,7 +1404,7 @@ static u16 bcm43xx_get_812_value(struct 
 			case LPD(1, 0, 0):
 				return 0x30B3;
 			default:
-				assert(0);
+				BCM43xx_BUG_ON(1);
 			}
 		} else {
 			switch (lpd) {
@@ -1381,11 +1417,11 @@ static u16 bcm43xx_get_812_value(struct 
 			case LPD(1, 0, 0):
 				return 0x20B3;
 			default:
-				assert(0);
+				BCM43xx_BUG_ON(1);
 			}
 		}
 	} else {
-		if (radio->revision == 8)
+		if (phy->radio_rev == 8)
 			adj_loopback_gain += 0x003E;
 		else
 			adj_loopback_gain += 0x0026;
@@ -1409,7 +1445,7 @@ static u16 bcm43xx_get_812_value(struct 
 		}
 
 		loop_or = (loop << 8) | extern_lna_control;
-		if (phy->rev >= 7 && bcm->sprom.boardflags
+		if (phy->rev >= 7 && dev->dev->bus->sprom.r1.boardflags_lo
 		    & BCM43xx_BFL_EXTLNA) {
 			if (extern_lna_control)
 				loop_or |= 0x8000;
@@ -1423,7 +1459,7 @@ static u16 bcm43xx_get_812_value(struct 
 			case LPD(1, 0, 0):
 				return (0x2093 | loop_or);
 			default:
-				assert(0);
+				BCM43xx_BUG_ON(1);
 			}
 		} else {
 			switch (lpd) {
@@ -1435,183 +1471,195 @@ static u16 bcm43xx_get_812_value(struct 
 			case LPD(1, 0, 0):
 				return (0x0093 | loop_or);
 			default:
-				assert(0);
+				BCM43xx_BUG_ON(1);
 			}
 		}
 	}
 	return 0;
 }
 
-u16 bcm43xx_radio_init2050(struct bcm43xx_private *bcm)
+u16 bcm43xx_radio_init2050(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 backup[21] = { 0 };
 	u16 ret;
 	u16 i, j;
 	u32 tmp1 = 0, tmp2 = 0;
 
-	backup[0] = bcm43xx_radio_read16(bcm, 0x0043);
-	backup[14] = bcm43xx_radio_read16(bcm, 0x0051);
-	backup[15] = bcm43xx_radio_read16(bcm, 0x0052);
-	backup[1] = bcm43xx_phy_read(bcm, 0x0015);
-	backup[16] = bcm43xx_phy_read(bcm, 0x005A);
-	backup[17] = bcm43xx_phy_read(bcm, 0x0059);
-	backup[18] = bcm43xx_phy_read(bcm, 0x0058);
+	backup[0] = bcm43xx_radio_read16(dev, 0x0043);
+	backup[14] = bcm43xx_radio_read16(dev, 0x0051);
+	backup[15] = bcm43xx_radio_read16(dev, 0x0052);
+	backup[1] = bcm43xx_phy_read(dev, 0x0015);
+	backup[16] = bcm43xx_phy_read(dev, 0x005A);
+	backup[17] = bcm43xx_phy_read(dev, 0x0059);
+	backup[18] = bcm43xx_phy_read(dev, 0x0058);
 	if (phy->type == BCM43xx_PHYTYPE_B) {
-		backup[2] = bcm43xx_phy_read(bcm, 0x0030);
-		backup[3] = bcm43xx_read16(bcm, 0x03EC);
-		bcm43xx_phy_write(bcm, 0x0030, 0x00FF);
-		bcm43xx_write16(bcm, 0x03EC, 0x3F3F);
+		backup[2] = bcm43xx_phy_read(dev, 0x0030);
+		backup[3] = bcm43xx_read16(dev, 0x03EC);
+		bcm43xx_phy_write(dev, 0x0030, 0x00FF);
+		bcm43xx_write16(dev, 0x03EC, 0x3F3F);
 	} else {
-		if (phy->connected) {
-			backup[4] = bcm43xx_phy_read(bcm, 0x0811);
-			backup[5] = bcm43xx_phy_read(bcm, 0x0812);
-			backup[6] = bcm43xx_phy_read(bcm, 0x0814);
-			backup[7] = bcm43xx_phy_read(bcm, 0x0815);
-			backup[8] = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS);
-			backup[9] = bcm43xx_phy_read(bcm, 0x0802);
-			bcm43xx_phy_write(bcm, 0x0814,
-			                  (bcm43xx_phy_read(bcm, 0x0814)
+		if (phy->gmode) {
+			backup[4] = bcm43xx_phy_read(dev, 0x0811);
+			backup[5] = bcm43xx_phy_read(dev, 0x0812);
+			backup[6] = bcm43xx_phy_read(dev, 0x0814);
+			backup[7] = bcm43xx_phy_read(dev, 0x0815);
+			backup[8] = bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS);
+			backup[9] = bcm43xx_phy_read(dev, 0x0802);
+			bcm43xx_phy_write(dev, 0x0814,
+					  (bcm43xx_phy_read(dev, 0x0814)
 					  | 0x0003));
-			bcm43xx_phy_write(bcm, 0x0815,
-			                  (bcm43xx_phy_read(bcm, 0x0815)
+			bcm43xx_phy_write(dev, 0x0815,
+					  (bcm43xx_phy_read(dev, 0x0815)
 					  & 0xFFFC));
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-			                  (bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS)
-					  & 0x7FFF));
-			bcm43xx_phy_write(bcm, 0x0802,
-			                  (bcm43xx_phy_read(bcm, 0x0802) & 0xFFFC));
+			bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
+					  (bcm43xx_phy_read(dev,
+					  BCM43xx_PHY_G_CRS) & 0x7FFF));
+			bcm43xx_phy_write(dev, 0x0802,
+					  (bcm43xx_phy_read(dev, 0x0802)
+							    & 0xFFFC));
 			if (phy->rev > 1) { /* loopback gain enabled */
-				backup[19] = bcm43xx_phy_read(bcm, 0x080F);
-				backup[20] = bcm43xx_phy_read(bcm, 0x0810);
+				backup[19] = bcm43xx_phy_read(dev, 0x080F);
+				backup[20] = bcm43xx_phy_read(dev, 0x0810);
 				if (phy->rev >= 3)
-					bcm43xx_phy_write(bcm, 0x080F, 0xC020);
+					bcm43xx_phy_write(dev, 0x080F, 0xC020);
 				else
-					bcm43xx_phy_write(bcm, 0x080F, 0x8020);
-				bcm43xx_phy_write(bcm, 0x0810, 0x0000);
+					bcm43xx_phy_write(dev, 0x080F, 0x8020);
+				bcm43xx_phy_write(dev, 0x0810, 0x0000);
 			}
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(0, 1, 1)));
-			if (phy->rev < 7 || !(bcm->sprom.boardflags
+			bcm43xx_phy_write(dev, 0x0812,
+					  bcm43xx_get_812_value(dev,
+								LPD(0, 1, 1)));
+			if (phy->rev < 7 ||
+			    !(dev->dev->bus->sprom.r1.boardflags_lo
 			    & BCM43xx_BFL_EXTLNA))
-				bcm43xx_phy_write(bcm, 0x0811, 0x01B3);
+				bcm43xx_phy_write(dev, 0x0811, 0x01B3);
 			else
-				bcm43xx_phy_write(bcm, 0x0811, 0x09B3);
+				bcm43xx_phy_write(dev, 0x0811, 0x09B3);
 		}
 	}
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_RADIO,
-	                (bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_RADIO) | 0x8000));
-	backup[10] = bcm43xx_phy_read(bcm, 0x0035);
-	bcm43xx_phy_write(bcm, 0x0035,
-	                  (bcm43xx_phy_read(bcm, 0x0035) & 0xFF7F));
-	backup[11] = bcm43xx_read16(bcm, 0x03E6);
-	backup[12] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
+	bcm43xx_write16(dev, BCM43xx_MMIO_PHY_RADIO,
+			(bcm43xx_read16(dev, BCM43xx_MMIO_PHY_RADIO)
+					| 0x8000));
+	backup[10] = bcm43xx_phy_read(dev, 0x0035);
+	bcm43xx_phy_write(dev, 0x0035,
+			  (bcm43xx_phy_read(dev, 0x0035) & 0xFF7F));
+	backup[11] = bcm43xx_read16(dev, 0x03E6);
+	backup[12] = bcm43xx_read16(dev, BCM43xx_MMIO_CHANNEL_EXT);
 
-	// Initialization
+	/* Initialization */
 	if (phy->analog == 0) {
-		bcm43xx_write16(bcm, 0x03E6, 0x0122);
+		bcm43xx_write16(dev, 0x03E6, 0x0122);
 	} else {
 		if (phy->analog >= 2)
-			bcm43xx_phy_write(bcm, 0x0003,
-					  (bcm43xx_phy_read(bcm, 0x0003)
+			bcm43xx_phy_write(dev, 0x0003,
+					  (bcm43xx_phy_read(dev, 0x0003)
 					  & 0xFFBF) | 0x0040);
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-		                (bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
+		bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL_EXT,
+				(bcm43xx_read16(dev, BCM43xx_MMIO_CHANNEL_EXT)
 				| 0x2000));
 	}
 
-	ret = bcm43xx_radio_calibrationvalue(bcm);
+	ret = bcm43xx_radio_calibrationvalue(dev);
 
 	if (phy->type == BCM43xx_PHYTYPE_B)
-		bcm43xx_radio_write16(bcm, 0x0078, 0x0026);
+		bcm43xx_radio_write16(dev, 0x0078, 0x0026);
 
-	if (phy->connected)
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_get_812_value(bcm, LPD(0, 1, 1)));
-	bcm43xx_phy_write(bcm, 0x0015, 0xBFAF);
-	bcm43xx_phy_write(bcm, 0x002B, 0x1403);
-	if (phy->connected)
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_get_812_value(bcm, LPD(0, 0, 1)));
-	bcm43xx_phy_write(bcm, 0x0015, 0xBFA0);
-	bcm43xx_radio_write16(bcm, 0x0051,
-	                      (bcm43xx_radio_read16(bcm, 0x0051) | 0x0004));
-	if (radio->revision == 8)
-		bcm43xx_radio_write16(bcm, 0x0043, 0x001F);
-	else {
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      (bcm43xx_radio_read16(bcm, 0x0043) & 0xFFF0)
-				      | 0x0009);
+	if (phy->gmode)
+		bcm43xx_phy_write(dev, 0x0812,
+				  bcm43xx_get_812_value(dev,
+							LPD(0, 1, 1)));
+	bcm43xx_phy_write(dev, 0x0015, 0xBFAF);
+	bcm43xx_phy_write(dev, 0x002B, 0x1403);
+	if (phy->gmode)
+		bcm43xx_phy_write(dev, 0x0812,
+				  bcm43xx_get_812_value(dev,
+							LPD(0, 0, 1)));
+	bcm43xx_phy_write(dev, 0x0015, 0xBFA0);
+	bcm43xx_radio_write16(dev, 0x0051,
+			      (bcm43xx_radio_read16(dev, 0x0051)
+						    | 0x0004));
+	if (phy->radio_rev == 8) {
+		bcm43xx_radio_write16(dev, 0x0043, 0x001F);
+	} else {
+		bcm43xx_radio_write16(dev, 0x0052, 0x0000);
+		bcm43xx_radio_write16(dev, 0x0043,
+				      (bcm43xx_radio_read16(dev, 0x0043)
+							    & 0xFFF0)
+							    | 0x0009);
 	}
-	bcm43xx_phy_write(bcm, 0x0058, 0x0000);
+	bcm43xx_phy_write(dev, 0x0058, 0x0000);
 
 	for (i = 0; i < 16; i++) {
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0xC810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-		if (phy->connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 1)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
+		bcm43xx_phy_write(dev, 0x005A, 0x0480);
+		bcm43xx_phy_write(dev, 0x0059, 0xC810);
+		bcm43xx_phy_write(dev, 0x0058, 0x000D);
+		if (phy->gmode)
+			bcm43xx_phy_write(dev, 0x0812,
+					  bcm43xx_get_812_value(dev,
+								LPD(1, 0, 1)));
+		bcm43xx_phy_write(dev, 0x0015, 0xAFB0);
 		udelay(10);
-		if (phy->connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 1)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xEFB0);
+		if (phy->gmode)
+			bcm43xx_phy_write(dev, 0x0812,
+					  bcm43xx_get_812_value(dev,
+								LPD(1, 0, 1)));
+		bcm43xx_phy_write(dev, 0x0015, 0xEFB0);
 		udelay(10);
-		if (phy->connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 0)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xFFF0);
+		if (phy->gmode)
+			bcm43xx_phy_write(dev, 0x0812,
+					  bcm43xx_get_812_value(dev,
+								LPD(1, 0, 0)));
+		bcm43xx_phy_write(dev, 0x0015, 0xFFF0);
 		udelay(20);
-		tmp1 += bcm43xx_phy_read(bcm, 0x002D);
-		bcm43xx_phy_write(bcm, 0x0058, 0x0000);
-		if (phy->connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 1)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
+		tmp1 += bcm43xx_phy_read(dev, 0x002D);
+		bcm43xx_phy_write(dev, 0x0058, 0x0000);
+		if (phy->gmode)
+			bcm43xx_phy_write(dev, 0x0812,
+					  bcm43xx_get_812_value(dev,
+								LPD(1, 0, 1)));
+		bcm43xx_phy_write(dev, 0x0015, 0xAFB0);
 	}
 
 	tmp1++;
 	tmp1 >>= 9;
 	udelay(10);
-	bcm43xx_phy_write(bcm, 0x0058, 0x0000);
+	bcm43xx_phy_write(dev, 0x0058, 0x0000);
 
 	for (i = 0; i < 16; i++) {
-		bcm43xx_radio_write16(bcm, 0x0078, (flip_4bit(i) << 1) | 0x0020);
-		backup[13] = bcm43xx_radio_read16(bcm, 0x0078);
+		bcm43xx_radio_write16(dev, 0x0078, (flip_4bit(i) << 1)
+				      | 0x0020);
+		backup[13] = bcm43xx_radio_read16(dev, 0x0078);
 		udelay(10);
 		for (j = 0; j < 16; j++) {
-			bcm43xx_phy_write(bcm, 0x005A, 0x0D80);
-			bcm43xx_phy_write(bcm, 0x0059, 0xC810);
-			bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-			if (phy->connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
+			bcm43xx_phy_write(dev, 0x005A, 0x0D80);
+			bcm43xx_phy_write(dev, 0x0059, 0xC810);
+			bcm43xx_phy_write(dev, 0x0058, 0x000D);
+			if (phy->gmode)
+				bcm43xx_phy_write(dev, 0x0812,
+						  bcm43xx_get_812_value(dev,
 						  LPD(1, 0, 1)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
+			bcm43xx_phy_write(dev, 0x0015, 0xAFB0);
 			udelay(10);
-			if (phy->connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
+			if (phy->gmode)
+				bcm43xx_phy_write(dev, 0x0812,
+						  bcm43xx_get_812_value(dev,
 						  LPD(1, 0, 1)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xEFB0);
+			bcm43xx_phy_write(dev, 0x0015, 0xEFB0);
 			udelay(10);
-			if (phy->connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
+			if (phy->gmode)
+				bcm43xx_phy_write(dev, 0x0812,
+						  bcm43xx_get_812_value(dev,
 						  LPD(1, 0, 0)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xFFF0);
+			bcm43xx_phy_write(dev, 0x0015, 0xFFF0);
 			udelay(10);
-			tmp2 += bcm43xx_phy_read(bcm, 0x002D);
-			bcm43xx_phy_write(bcm, 0x0058, 0x0000);
-			if (phy->connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
+			tmp2 += bcm43xx_phy_read(dev, 0x002D);
+			bcm43xx_phy_write(dev, 0x0058, 0x0000);
+			if (phy->gmode)
+				bcm43xx_phy_write(dev, 0x0812,
+						  bcm43xx_get_812_value(dev,
 						  LPD(1, 0, 1)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
+			bcm43xx_phy_write(dev, 0x0015, 0xAFB0);
 		}
 		tmp2++;
 		tmp2 >>= 8;
@@ -1620,35 +1668,35 @@ u16 bcm43xx_radio_init2050(struct bcm43x
 	}
 
 	/* Restore the registers */
-	bcm43xx_phy_write(bcm, 0x0015, backup[1]);
-	bcm43xx_radio_write16(bcm, 0x0051, backup[14]);
-	bcm43xx_radio_write16(bcm, 0x0052, backup[15]);
-	bcm43xx_radio_write16(bcm, 0x0043, backup[0]);
-	bcm43xx_phy_write(bcm, 0x005A, backup[16]);
-	bcm43xx_phy_write(bcm, 0x0059, backup[17]);
-	bcm43xx_phy_write(bcm, 0x0058, backup[18]);
-	bcm43xx_write16(bcm, 0x03E6, backup[11]);
+	bcm43xx_phy_write(dev, 0x0015, backup[1]);
+	bcm43xx_radio_write16(dev, 0x0051, backup[14]);
+	bcm43xx_radio_write16(dev, 0x0052, backup[15]);
+	bcm43xx_radio_write16(dev, 0x0043, backup[0]);
+	bcm43xx_phy_write(dev, 0x005A, backup[16]);
+	bcm43xx_phy_write(dev, 0x0059, backup[17]);
+	bcm43xx_phy_write(dev, 0x0058, backup[18]);
+	bcm43xx_write16(dev, 0x03E6, backup[11]);
 	if (phy->analog != 0)
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, backup[12]);
-	bcm43xx_phy_write(bcm, 0x0035, backup[10]);
-	bcm43xx_radio_selectchannel(bcm, radio->channel, 1);
+		bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL_EXT, backup[12]);
+	bcm43xx_phy_write(dev, 0x0035, backup[10]);
+	bcm43xx_radio_selectchannel(dev, phy->channel, 1);
 	if (phy->type == BCM43xx_PHYTYPE_B) {
-		bcm43xx_phy_write(bcm, 0x0030, backup[2]);
-		bcm43xx_write16(bcm, 0x03EC, backup[3]);
+		bcm43xx_phy_write(dev, 0x0030, backup[2]);
+		bcm43xx_write16(dev, 0x03EC, backup[3]);
 	} else {
-		if (phy->connected) {
-			bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_RADIO,
-					(bcm43xx_read16(bcm,
+		if (phy->gmode) {
+			bcm43xx_write16(dev, BCM43xx_MMIO_PHY_RADIO,
+					(bcm43xx_read16(dev,
 					BCM43xx_MMIO_PHY_RADIO) & 0x7FFF));
-			bcm43xx_phy_write(bcm, 0x0811, backup[4]);
-			bcm43xx_phy_write(bcm, 0x0812, backup[5]);
-			bcm43xx_phy_write(bcm, 0x0814, backup[6]);
-			bcm43xx_phy_write(bcm, 0x0815, backup[7]);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, backup[8]);
-			bcm43xx_phy_write(bcm, 0x0802, backup[9]);
+			bcm43xx_phy_write(dev, 0x0811, backup[4]);
+			bcm43xx_phy_write(dev, 0x0812, backup[5]);
+			bcm43xx_phy_write(dev, 0x0814, backup[6]);
+			bcm43xx_phy_write(dev, 0x0815, backup[7]);
+			bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS, backup[8]);
+			bcm43xx_phy_write(dev, 0x0802, backup[9]);
 			if (phy->rev > 1) {
-				bcm43xx_phy_write(bcm, 0x080F, backup[19]);
-				bcm43xx_phy_write(bcm, 0x0810, backup[20]);
+				bcm43xx_phy_write(dev, 0x080F, backup[19]);
+				bcm43xx_phy_write(dev, 0x0810, backup[20]);
 			}
 		}
 	}
@@ -1658,43 +1706,60 @@ u16 bcm43xx_radio_init2050(struct bcm43x
 	return ret;
 }
 
-void bcm43xx_radio_init2060(struct bcm43xx_private *bcm)
+void bcm43xx_radio_init2060(struct bcm43xx_wldev *dev)
 {
 	int err;
 
-	bcm43xx_radio_write16(bcm, 0x0004, 0x00C0);
-	bcm43xx_radio_write16(bcm, 0x0005, 0x0008);
-	bcm43xx_radio_write16(bcm, 0x0009, 0x0040);
-	bcm43xx_radio_write16(bcm, 0x0005, 0x00AA);
-	bcm43xx_radio_write16(bcm, 0x0032, 0x008F);
-	bcm43xx_radio_write16(bcm, 0x0006, 0x008F);
-	bcm43xx_radio_write16(bcm, 0x0034, 0x008F);
-	bcm43xx_radio_write16(bcm, 0x002C, 0x0007);
-	bcm43xx_radio_write16(bcm, 0x0082, 0x0080);
-	bcm43xx_radio_write16(bcm, 0x0080, 0x0000);
-	bcm43xx_radio_write16(bcm, 0x003F, 0x00DA);
-	bcm43xx_radio_write16(bcm, 0x0005, bcm43xx_radio_read16(bcm, 0x0005) & ~0x0008);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) & ~0x0010);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) & ~0x0020);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) & ~0x0020);
-	udelay(400);
-
-	bcm43xx_radio_write16(bcm, 0x0081, (bcm43xx_radio_read16(bcm, 0x0081) & ~0x0020) | 0x0010);
-	udelay(400);
-
-	bcm43xx_radio_write16(bcm, 0x0005, (bcm43xx_radio_read16(bcm, 0x0005) & ~0x0008) | 0x0008);
-	bcm43xx_radio_write16(bcm, 0x0085, bcm43xx_radio_read16(bcm, 0x0085) & ~0x0010);
-	bcm43xx_radio_write16(bcm, 0x0005, bcm43xx_radio_read16(bcm, 0x0005) & ~0x0008);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) & ~0x0040);
-	bcm43xx_radio_write16(bcm, 0x0081, (bcm43xx_radio_read16(bcm, 0x0081) & ~0x0040) | 0x0040);
-	bcm43xx_radio_write16(bcm, 0x0005, (bcm43xx_radio_read16(bcm, 0x0081) & ~0x0008) | 0x0008);
-	bcm43xx_phy_write(bcm, 0x0063, 0xDDC6);
-	bcm43xx_phy_write(bcm, 0x0069, 0x07BE);
-	bcm43xx_phy_write(bcm, 0x006A, 0x0000);
-
-	err = bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_A, 0);
-	assert(err == 0);
-	udelay(1000);
+	bcm43xx_radio_write16(dev, 0x0004, 0x00C0);
+	bcm43xx_radio_write16(dev, 0x0005, 0x0008);
+	bcm43xx_radio_write16(dev, 0x0009, 0x0040);
+	bcm43xx_radio_write16(dev, 0x0005, 0x00AA);
+	bcm43xx_radio_write16(dev, 0x0032, 0x008F);
+	bcm43xx_radio_write16(dev, 0x0006, 0x008F);
+	bcm43xx_radio_write16(dev, 0x0034, 0x008F);
+	bcm43xx_radio_write16(dev, 0x002C, 0x0007);
+	bcm43xx_radio_write16(dev, 0x0082, 0x0080);
+	bcm43xx_radio_write16(dev, 0x0080, 0x0000);
+	bcm43xx_radio_write16(dev, 0x003F, 0x00DA);
+	bcm43xx_radio_write16(dev, 0x0005,
+			      bcm43xx_radio_read16(dev, 0x0005) & ~0x0008);
+	bcm43xx_radio_write16(dev, 0x0081,
+			      bcm43xx_radio_read16(dev, 0x0081) & ~0x0010);
+	bcm43xx_radio_write16(dev, 0x0081,
+			      bcm43xx_radio_read16(dev, 0x0081) & ~0x0020);
+	bcm43xx_radio_write16(dev, 0x0081,
+			      bcm43xx_radio_read16(dev, 0x0081) & ~0x0020);
+	msleep(1); /* udelay(400); */
+
+	bcm43xx_radio_write16(dev, 0x0081,
+			      (bcm43xx_radio_read16(dev, 0x0081) & ~0x0020)
+						    | 0x0010);
+	msleep(1); /* udelay(400); */
+
+	bcm43xx_radio_write16(dev, 0x0005,
+			      (bcm43xx_radio_read16(dev, 0x0005) & ~0x0008)
+						    | 0x0008);
+	bcm43xx_radio_write16(dev, 0x0085,
+			      bcm43xx_radio_read16(dev, 0x0085) & ~0x0010);
+	bcm43xx_radio_write16(dev, 0x0005,
+			      bcm43xx_radio_read16(dev, 0x0005) & ~0x0008);
+	bcm43xx_radio_write16(dev, 0x0081,
+			      bcm43xx_radio_read16(dev, 0x0081) & ~0x0040);
+	bcm43xx_radio_write16(dev, 0x0081,
+			      (bcm43xx_radio_read16(dev, 0x0081) & ~0x0040)
+			      | 0x0040);
+	bcm43xx_radio_write16(dev, 0x0005,
+			      (bcm43xx_radio_read16(dev, 0x0081) & ~0x0008) |
+						    0x0008);
+	bcm43xx_phy_write(dev, 0x0063, 0xDDC6);
+	bcm43xx_phy_write(dev, 0x0069, 0x07BE);
+	bcm43xx_phy_write(dev, 0x006A, 0x0000);
+
+	err = bcm43xx_radio_selectchannel(dev, BCM43xx_RADIO_DEFAULT_CHANNEL_A,
+					  0);
+	BCM43xx_WARN_ON(err != 0);
+
+	msleep(1);
 }
 
 static inline
@@ -1714,137 +1779,81 @@ u16 freq_r3A_value(u16 frequency)
 	return value;
 }
 
-void bcm43xx_radio_set_tx_iq(struct bcm43xx_private *bcm)
+void bcm43xx_radio_set_tx_iq(struct bcm43xx_wldev *dev)
 {
 	static const u8 data_high[5] = { 0x00, 0x40, 0x80, 0x90, 0xD0 };
 	static const u8 data_low[5]  = { 0x00, 0x01, 0x05, 0x06, 0x0A };
-	u16 tmp = bcm43xx_radio_read16(bcm, 0x001E);
-	int i, j;
-	
+	u16 tmp = bcm43xx_radio_read16(dev, 0x001E);
+	int i;
+	int j;
+
 	for (i = 0; i < 5; i++) {
 		for (j = 0; j < 5; j++) {
 			if (tmp == (data_high[i] | data_low[j])) {
-				bcm43xx_phy_write(bcm, 0x0069, (i - j) << 8 | 0x00C0);
+				bcm43xx_phy_write(dev, 0x0069, (i - j) << 8 |
+						  0x00C0);
 				return;
 			}
 		}
 	}
 }
 
-int bcm43xx_radio_selectchannel(struct bcm43xx_private *bcm,
+int bcm43xx_radio_selectchannel(struct bcm43xx_wldev *dev,
 				u8 channel,
 				int synthetic_pu_workaround)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 r8, tmp;
-	u16 freq;
+	struct bcm43xx_phy *phy = &dev->phy;
 
-	if (!ieee80211_is_valid_channel(bcm->ieee, channel))
-		return -EINVAL;
-	if ((radio->manufact == 0x17F) &&
-	    (radio->version == 0x2060) &&
-	    (radio->revision == 1)) {
-		freq = channel2freq_a(channel);
-
-		r8 = bcm43xx_radio_read16(bcm, 0x0008);
-		bcm43xx_write16(bcm, 0x03F0, freq);
-		bcm43xx_radio_write16(bcm, 0x0008, r8);
-
-		TODO();//TODO: write max channel TX power? to Radio 0x2D
-		tmp = bcm43xx_radio_read16(bcm, 0x002E);
-		tmp &= 0x0080;
-		TODO();//TODO: OR tmp with the Power out estimation for this channel?
-		bcm43xx_radio_write16(bcm, 0x002E, tmp);
-
-		if (freq >= 4920 && freq <= 5500) {
-			/* 
-			 * r8 = (((freq * 15 * 0xE1FC780F) >> 32) / 29) & 0x0F;
-			 *    = (freq * 0.025862069
-			 */
-			r8 = 3 * freq / 116; /* is equal to r8 = freq * 0.025862 */
-		}
-		bcm43xx_radio_write16(bcm, 0x0007, (r8 << 4) | r8);
-		bcm43xx_radio_write16(bcm, 0x0020, (r8 << 4) | r8);
-		bcm43xx_radio_write16(bcm, 0x0021, (r8 << 4) | r8);
-		bcm43xx_radio_write16(bcm, 0x0022,
-				      (bcm43xx_radio_read16(bcm, 0x0022)
-				       & 0x000F) | (r8 << 4));
-		bcm43xx_radio_write16(bcm, 0x002A, (r8 << 4));
-		bcm43xx_radio_write16(bcm, 0x002B, (r8 << 4));
-		bcm43xx_radio_write16(bcm, 0x0008,
-				      (bcm43xx_radio_read16(bcm, 0x0008)
-				       & 0x00F0) | (r8 << 4));
-		bcm43xx_radio_write16(bcm, 0x0029,
-				      (bcm43xx_radio_read16(bcm, 0x0029)
-				       & 0xFF0F) | 0x00B0);
-		bcm43xx_radio_write16(bcm, 0x0035, 0x00AA);
-		bcm43xx_radio_write16(bcm, 0x0036, 0x0085);
-		bcm43xx_radio_write16(bcm, 0x003A,
-				      (bcm43xx_radio_read16(bcm, 0x003A)
-				       & 0xFF20) | freq_r3A_value(freq));
-		bcm43xx_radio_write16(bcm, 0x003D,
-				      bcm43xx_radio_read16(bcm, 0x003D) & 0x00FF);
-		bcm43xx_radio_write16(bcm, 0x0081,
-				      (bcm43xx_radio_read16(bcm, 0x0081)
-				       & 0xFF7F) | 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0035,
-				      bcm43xx_radio_read16(bcm, 0x0035) & 0xFFEF);
-		bcm43xx_radio_write16(bcm, 0x0035,
-				      (bcm43xx_radio_read16(bcm, 0x0035)
-				       & 0xFFEF) | 0x0010);
-		bcm43xx_radio_set_tx_iq(bcm);
-		TODO();	//TODO:	TSSI2dbm workaround
-		bcm43xx_phy_xmitpower(bcm);//FIXME correct?
-	} else {
-		if (synthetic_pu_workaround)
-			bcm43xx_synth_pu_workaround(bcm, channel);
+/* TODO: Check if channel is valid - return -EINVAL if not */
+	if (synthetic_pu_workaround)
+		bcm43xx_synth_pu_workaround(dev, channel);
 
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
-				channel2freq_bg(channel));
+	bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL,
+			channel2freq_bg(channel));
 
-		if (channel == 14) {
-			if (bcm->sprom.locale == BCM43xx_LOCALE_JAPAN) {
-				bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-						    BCM43xx_UCODEFLAGS_OFFSET,
-						    bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-								       BCM43xx_UCODEFLAGS_OFFSET)
-						    & ~(1 << 7));
-			} else {
-				bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-						    BCM43xx_UCODEFLAGS_OFFSET,
-						    bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-								       BCM43xx_UCODEFLAGS_OFFSET)
-						    | (1 << 7));
-			}
-			bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-					bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
-					| (1 << 11));
-		} else {
-			bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-					bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
-					& 0xF7BF);
-		}
+	if (channel == 14) {
+		if (dev->dev->bus->sprom.r1.country_code == 5)   /* JAPAN) */
+			bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED,
+					    BCM43xx_UCODEFLAGS_OFFSET,
+					    bcm43xx_shm_read32(dev,
+					    BCM43xx_SHM_SHARED,
+					    BCM43xx_UCODEFLAGS_OFFSET)
+					    & ~(1 << 7));
+		else
+			bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED,
+					    BCM43xx_UCODEFLAGS_OFFSET,
+					    bcm43xx_shm_read32(dev,
+					    BCM43xx_SHM_SHARED,
+					    BCM43xx_UCODEFLAGS_OFFSET)
+					    | (1 << 7));
+		bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL_EXT,
+				bcm43xx_read16(dev, BCM43xx_MMIO_CHANNEL_EXT)
+				| (1 << 11));
+	} else {
+		bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL_EXT,
+				bcm43xx_read16(dev, BCM43xx_MMIO_CHANNEL_EXT)
+				& 0xF7BF);
 	}
 
-	radio->channel = channel;
-	//XXX: Using the longer of 2 timeouts (8000 vs 2000 usecs). Specs states
-	//     that 2000 usecs might suffice.
-	udelay(8000);
+	phy->channel = channel;
+	/*XXX: Using the longer of 2 timeouts (8000 vs 2000 usecs). Specs states
+	 *     that 2000 usecs might suffice. */
+	msleep(8);
 
 	return 0;
 }
 
-void bcm43xx_radio_set_txantenna(struct bcm43xx_private *bcm, u32 val)
+void bcm43xx_radio_set_txantenna(struct bcm43xx_wldev *dev, u32 val)
 {
 	u16 tmp;
 
 	val <<= 8;
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0022) & 0xFCFF;
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0022, tmp | val);
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x03A8) & 0xFCFF;
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x03A8, tmp | val);
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0054) & 0xFCFF;
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0054, tmp | val);
+	tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x0022) & 0xFCFF;
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0022, tmp | val);
+	tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x03A8) & 0xFCFF;
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x03A8, tmp | val);
+	tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x0054) & 0xFCFF;
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0054, tmp | val);
 }
 
 /* http://bcm-specs.sipsolutions.net/TX_Gain_Base_Band */
@@ -1852,7 +1861,7 @@ static u16 bcm43xx_get_txgain_base_band(
 {
 	u16 ret;
 
-	assert(txpower <= 63);
+	BCM43xx_WARN_ON(txpower > 63);
 
 	if (txpower >= 54)
 		ret = 2;
@@ -1871,7 +1880,7 @@ static u16 bcm43xx_get_txgain_freq_power
 {
 	u16 ret;
 
-	assert(txpower <= 63);
+	BCM43xx_WARN_ON(txpower > 63);
 
 	if (txpower >= 32)
 		ret = 0;
@@ -1892,7 +1901,7 @@ static u16 bcm43xx_get_txgain_dac(u16 tx
 {
 	u16 ret;
 
-	assert(txpower <= 63);
+	BCM43xx_WARN_ON(txpower > 63);
 
 	if (txpower >= 54)
 		ret = txpower - 53;
@@ -1914,9 +1923,9 @@ static u16 bcm43xx_get_txgain_dac(u16 tx
 	return ret;
 }
 
-void bcm43xx_radio_set_txpower_a(struct bcm43xx_private *bcm, u16 txpower)
+void bcm43xx_radio_set_txpower_a(struct bcm43xx_wldev *dev, u16 txpower)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 pamp, base, dac, ilt;
 
 	txpower = limit_value(txpower, 0, 63);
@@ -1924,110 +1933,103 @@ void bcm43xx_radio_set_txpower_a(struct 
 	pamp = bcm43xx_get_txgain_freq_power_amp(txpower);
 	pamp <<= 5;
 	pamp &= 0x00E0;
-	bcm43xx_phy_write(bcm, 0x0019, pamp);
+	bcm43xx_phy_write(dev, 0x0019, pamp);
 
 	base = bcm43xx_get_txgain_base_band(txpower);
 	base &= 0x000F;
-	bcm43xx_phy_write(bcm, 0x0017, base | 0x0020);
+	bcm43xx_phy_write(dev, 0x0017, base | 0x0020);
 
-	ilt = bcm43xx_ilt_read(bcm, 0x3001);
+	ilt = bcm43xx_ilt_read(dev, 0x3001);
 	ilt &= 0x0007;
 
 	dac = bcm43xx_get_txgain_dac(txpower);
 	dac <<= 3;
 	dac |= ilt;
 
-	bcm43xx_ilt_write(bcm, 0x3001, dac);
+	bcm43xx_ilt_write(dev, 0x3001, dac);
 
-	radio->txpwr_offset = txpower;
+	phy->txpwr_offset = txpower;
 
-	TODO();
-	//TODO: FuncPlaceholder (Adjust BB loft cancel)
+	/* TODO: FuncPlaceholder (Adjust BB loft cancel) */
 }
 
-void bcm43xx_radio_set_txpower_bg(struct bcm43xx_private *bcm,
+void bcm43xx_radio_set_txpower_bg(struct bcm43xx_wldev *dev,
                                  u16 baseband_attenuation, u16 radio_attenuation,
                                  u16 txpower)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 
 	if (baseband_attenuation == 0xFFFF)
-		baseband_attenuation = radio->baseband_atten;
+		baseband_attenuation = phy->bbatt;
 	if (radio_attenuation == 0xFFFF)
-		radio_attenuation = radio->radio_atten;
+		radio_attenuation = phy->rfatt;
 	if (txpower == 0xFFFF)
-		txpower = radio->txctl1;
-	radio->baseband_atten = baseband_attenuation;
-	radio->radio_atten = radio_attenuation;
-	radio->txctl1 = txpower;
-
-	assert(/*baseband_attenuation >= 0 &&*/ baseband_attenuation <= 11);
-	if (radio->revision < 6)
-		assert(/*radio_attenuation >= 0 &&*/ radio_attenuation <= 9);
+		txpower = phy->txctl1;
+	phy->bbatt = baseband_attenuation;
+	phy->rfatt = radio_attenuation;
+	phy->txctl1 = txpower;
+
+	BCM43xx_WARN_ON(baseband_attenuation > 11);
+	if (phy->radio_rev < 6)
+		BCM43xx_WARN_ON(radio_attenuation > 9);
 	else
-		assert(/* radio_attenuation >= 0 &&*/ radio_attenuation <= 31);
-	assert(/*txpower >= 0 &&*/ txpower <= 7);
+		BCM43xx_WARN_ON(radio_attenuation > 31);
+	BCM43xx_WARN_ON(txpower > 7);
 
-	bcm43xx_phy_set_baseband_attenuation(bcm, baseband_attenuation);
-	bcm43xx_radio_write16(bcm, 0x0043, radio_attenuation);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0064, radio_attenuation);
-	if (radio->version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0052,
-		                      (bcm43xx_radio_read16(bcm, 0x0052) & ~0x0070)
-				       | ((txpower << 4) & 0x0070));
-	}
-	//FIXME: The spec is very weird and unclear here.
+	bcm43xx_phy_set_baseband_attenuation(dev, baseband_attenuation);
+	bcm43xx_radio_write16(dev, 0x0043, radio_attenuation);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0064, radio_attenuation);
+	if (phy->radio_ver == 0x2050)
+		bcm43xx_radio_write16(dev, 0x0052,
+				      (bcm43xx_radio_read16(dev, 0x0052)
+				       & ~0x0070) | ((txpower << 4) & 0x0070));
+	/* FIXME: The spec is very weird and unclear here. */
 	if (phy->type == BCM43xx_PHYTYPE_G)
-		bcm43xx_phy_lo_adjust(bcm, 0);
+		bcm43xx_phy_lo_adjust(dev, 0);
 }
 
-u16 bcm43xx_default_baseband_attenuation(struct bcm43xx_private *bcm)
+u16 bcm43xx_default_baseband_attenuation(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 
-	if (radio->version == 0x2050 && radio->revision < 6)
+	if (phy->radio_ver == 0x2050 && phy->radio_rev < 6)
 		return 0;
 	return 2;
 }
 
-u16 bcm43xx_default_radio_attenuation(struct bcm43xx_private *bcm)
+u16 bcm43xx_default_radio_attenuation(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 att = 0xFFFF;
 
-	if (phy->type == BCM43xx_PHYTYPE_A)
-		return 0x60;
-
-	switch (radio->version) {
+	switch (phy->radio_ver) {
 	case 0x2053:
-		switch (radio->revision) {
+		switch (phy->radio_rev) {
 		case 1:
 			att = 6;
 			break;
 		}
 		break;
 	case 0x2050:
-		switch (radio->revision) {
+		switch (phy->radio_rev) {
 		case 0:
 			att = 5;
 			break;
 		case 1:
 			if (phy->type == BCM43xx_PHYTYPE_G) {
-				if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-				    bcm->board_type == 0x421 &&
-				    bcm->board_revision >= 30)
+				if (is_bcm_board_vendor(dev) &&
+				    dev->dev->bus->boardinfo.type == 0x421 &&
+				    dev->dev->bus->boardinfo.rev >= 30)
 					att = 3;
-				else if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-					 bcm->board_type == 0x416)
+				else if (is_bcm_board_vendor(dev) &&
+					 dev->dev->bus->boardinfo.type == 0x416)
 					att = 3;
 				else
 					att = 1;
 			} else {
-				if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-				    bcm->board_type == 0x421 &&
-				    bcm->board_revision >= 30)
+				if (is_bcm_board_vendor(dev) &&
+				    dev->dev->bus->boardinfo.type == 0x421 &&
+				    dev->dev->bus->boardinfo.rev >= 30)
 					att = 7;
 				else
 					att = 6;
@@ -2035,19 +2037,21 @@ u16 bcm43xx_default_radio_attenuation(st
 			break;
 		case 2:
 			if (phy->type == BCM43xx_PHYTYPE_G) {
-				if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-				    bcm->board_type == 0x421 &&
-				    bcm->board_revision >= 30)
+				if (is_bcm_board_vendor(dev) &&
+				    dev->dev->bus->boardinfo.type == 0x421 &&
+				    dev->dev->bus->boardinfo.rev >= 30)
 					att = 3;
-				else if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-					 bcm->board_type == 0x416)
+				else if (is_bcm_board_vendor(dev) &&
+					 dev->dev->bus->boardinfo.type ==
+					 0x416)
 					att = 5;
-				else if (bcm->chip_id == 0x4320)
+				else if (dev->dev->bus->chip_id == 0x4320)
 					att = 4;
 				else
 					att = 3;
-			} else
+			} else {
 				att = 6;
+			}
 			break;
 		case 3:
 			att = 5;
@@ -2068,11 +2072,11 @@ u16 bcm43xx_default_radio_attenuation(st
 			att = 5;
 		}
 	}
-	if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-	    bcm->board_type == 0x421) {
-		if (bcm->board_revision < 0x43)
+	if (is_bcm_board_vendor(dev) &&
+	    dev->dev->bus->boardinfo.type == 0x421) {
+		if (dev->dev->bus->boardinfo.rev < 0x43)
 			att = 2;
-		else if (bcm->board_revision < 0x51)
+		else if (dev->dev->bus->boardinfo.rev < 0x51)
 			att = 3;
 	}
 	if (att == 0xFFFF)
@@ -2081,90 +2085,77 @@ u16 bcm43xx_default_radio_attenuation(st
 	return att;
 }
 
-u16 bcm43xx_default_txctl1(struct bcm43xx_private *bcm)
+u16 bcm43xx_default_txctl1(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 
-	if (radio->version != 0x2050)
+	if (phy->radio_ver != 0x2050)
 		return 0;
-	if (radio->revision == 1)
+	if (phy->radio_rev == 1)
 		return 3;
-	if (radio->revision < 6)
+	if (phy->radio_rev < 6)
 		return 2;
-	if (radio->revision == 8)
+	if (phy->radio_rev == 8)
 		return 1;
 	return 0;
 }
 
-void bcm43xx_radio_turn_on(struct bcm43xx_private *bcm)
+void bcm43xx_radio_turn_on(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	int err;
 
-	if (radio->enabled)
+	might_sleep();
+
+	if (phy->radio_on)
 		return;
 
 	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		bcm43xx_radio_write16(bcm, 0x0004, 0x00C0);
-		bcm43xx_radio_write16(bcm, 0x0005, 0x0008);
-		bcm43xx_phy_write(bcm, 0x0010, bcm43xx_phy_read(bcm, 0x0010) & 0xFFF7);
-		bcm43xx_phy_write(bcm, 0x0011, bcm43xx_phy_read(bcm, 0x0011) & 0xFFF7);
-		bcm43xx_radio_init2060(bcm);	
-		break;
 	case BCM43xx_PHYTYPE_B:
 	case BCM43xx_PHYTYPE_G:
-		bcm43xx_phy_write(bcm, 0x0015, 0x8000);
-		bcm43xx_phy_write(bcm, 0x0015, 0xCC00);
-		bcm43xx_phy_write(bcm, 0x0015, (phy->connected ? 0x00C0 : 0x0000));
-		err = bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_BG, 1);
-		assert(err == 0);
+		bcm43xx_phy_write(dev, 0x0015, 0x8000);
+		bcm43xx_phy_write(dev, 0x0015, 0xCC00);
+		bcm43xx_phy_write(dev, 0x0015, (phy->gmode ? 0x00C0 : 0x0000));
+		err = bcm43xx_radio_selectchannel(dev,
+					  BCM43xx_RADIO_DEFAULT_CHANNEL_BG, 1);
+		BCM43xx_WARN_ON(err != 0);
 		break;
 	default:
-		assert(0);
+		BCM43xx_BUG_ON(1);
 	}
-	radio->enabled = 1;
-	dprintk(KERN_INFO PFX "Radio turned on\n");
-	bcm43xx_leds_update(bcm, 0);
+	phy->radio_on = 1;
+	bcmdbg(dev->wl, "Radio turned on\n");
+	bcm43xx_leds_update(dev, 0);
 }
-	
-void bcm43xx_radio_turn_off(struct bcm43xx_private *bcm)
+
+void bcm43xx_radio_turn_off(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_radio_write16(bcm, 0x0004, 0x00FF);
-		bcm43xx_radio_write16(bcm, 0x0005, 0x00FB);
-		bcm43xx_phy_write(bcm, 0x0010, bcm43xx_phy_read(bcm, 0x0010) | 0x0008);
-		bcm43xx_phy_write(bcm, 0x0011, bcm43xx_phy_read(bcm, 0x0011) | 0x0008);
+	if (phy->type == BCM43xx_PHYTYPE_G && dev->dev->id.revision >= 5) {
+		bcm43xx_phy_write(dev, 0x0811, bcm43xx_phy_read(dev, 0x0811) |
+				  0x008C);
+		bcm43xx_phy_write(dev, 0x0812, bcm43xx_phy_read(dev, 0x0812) &
+				  0xFF73);
+	} else {
+		bcm43xx_phy_write(dev, 0x0015, 0xAA00);
 	}
-	if (phy->type == BCM43xx_PHYTYPE_G && bcm->current_core->rev >= 5) {
-		bcm43xx_phy_write(bcm, 0x0811, bcm43xx_phy_read(bcm, 0x0811) | 0x008C);
-		bcm43xx_phy_write(bcm, 0x0812, bcm43xx_phy_read(bcm, 0x0812) & 0xFF73);
-	} else
-		bcm43xx_phy_write(bcm, 0x0015, 0xAA00);
-	radio->enabled = 0;
-	dprintk(KERN_INFO PFX "Radio turned off\n");
-	bcm43xx_leds_update(bcm, 0);
+	phy->radio_on = 0;
+	bcmdbg(dev->wl, "Radio turned off\n");
+	bcm43xx_leds_update(dev, 0);
 }
 
-void bcm43xx_radio_clear_tssi(struct bcm43xx_private *bcm)
+void bcm43xx_radio_clear_tssi(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 
 	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0068, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x006a, 0x7F7F);
-		break;
 	case BCM43xx_PHYTYPE_B:
 	case BCM43xx_PHYTYPE_G:
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0058, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x005a, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0070, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0072, 0x7F7F);
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0058, 0x7F7F);
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x005a, 0x7F7F);
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0070, 0x7F7F);
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0072, 0x7F7F);
 		break;
 	}
 }
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_radio.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_radio.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_radio.h
@@ -53,63 +53,48 @@
 #define BCM43xx_RADIO_INTERFMODE_AUTOWLAN	3
 
 
-void bcm43xx_radio_lock(struct bcm43xx_private *bcm);
-void bcm43xx_radio_unlock(struct bcm43xx_private *bcm);
+void bcm43xx_radio_lock(struct bcm43xx_wldev *dev);
+void bcm43xx_radio_unlock(struct bcm43xx_wldev *dev);
 
-u16 bcm43xx_radio_read16(struct bcm43xx_private *bcm, u16 offset);
-void bcm43xx_radio_write16(struct bcm43xx_private *bcm, u16 offset, u16 val);
+u16 bcm43xx_radio_read16(struct bcm43xx_wldev *dev, u16 offset);
+void bcm43xx_radio_write16(struct bcm43xx_wldev *dev, u16 offset, u16 val);
 
-u16 bcm43xx_radio_init2050(struct bcm43xx_private *bcm);
-void bcm43xx_radio_init2060(struct bcm43xx_private *bcm);
+u16 bcm43xx_radio_init2050(struct bcm43xx_wldev *dev);
+void bcm43xx_radio_init2060(struct bcm43xx_wldev *dev);
 
-void bcm43xx_radio_turn_on(struct bcm43xx_private *bcm);
-void bcm43xx_radio_turn_off(struct bcm43xx_private *bcm);
-
-static inline
-int bcm43xx_is_hw_radio_enabled(struct bcm43xx_private *bcm)
-{
-	/* function to return state of hardware enable of radio
-	 * returns 0 if radio disabled, 1 if radio enabled
-	 */
-	if (bcm->current_core->rev >= 3)
-		return ((bcm43xx_read32(bcm, BCM43xx_MMIO_RADIO_HWENABLED_HI)
-					& BCM43xx_MMIO_RADIO_HWENABLED_HI_MASK)
-					== 0) ? 1 : 0;
-	else
-		return ((bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_HWENABLED_LO)
-					& BCM43xx_MMIO_RADIO_HWENABLED_LO_MASK)
-					== 0) ? 0 : 1;
-}
+void bcm43xx_radio_turn_on(struct bcm43xx_wldev *dev);
+void bcm43xx_radio_turn_off(struct bcm43xx_wldev *dev);
 
-int bcm43xx_radio_selectchannel(struct bcm43xx_private *bcm, u8 channel,
+int bcm43xx_radio_selectchannel(struct bcm43xx_wldev *dev, u8 channel,
 				int synthetic_pu_workaround);
 
-void bcm43xx_radio_set_txpower_a(struct bcm43xx_private *bcm, u16 txpower);
-void bcm43xx_radio_set_txpower_bg(struct bcm43xx_private *bcm,
+void bcm43xx_radio_set_txpower_a(struct bcm43xx_wldev *dev, u16 txpower);
+void bcm43xx_radio_set_txpower_bg(struct bcm43xx_wldev *dev,
                                u16 baseband_attenuation, u16 attenuation,
 			       u16 txpower);
 
-u16 bcm43xx_default_baseband_attenuation(struct bcm43xx_private *bcm);
-u16 bcm43xx_default_radio_attenuation(struct bcm43xx_private *bcm);
-u16 bcm43xx_default_txctl1(struct bcm43xx_private *bcm);
+u16 bcm43xx_default_baseband_attenuation(struct bcm43xx_wldev *dev);
+u16 bcm43xx_default_radio_attenuation(struct bcm43xx_wldev *dev);
+u16 bcm43xx_default_txctl1(struct bcm43xx_wldev *dev);
 
-void bcm43xx_radio_set_txantenna(struct bcm43xx_private *bcm, u32 val);
+void bcm43xx_radio_set_txantenna(struct bcm43xx_wldev *dev, u32 val);
 
-void bcm43xx_radio_clear_tssi(struct bcm43xx_private *bcm);
+void bcm43xx_radio_clear_tssi(struct bcm43xx_wldev *dev);
 
-u8 bcm43xx_radio_aci_detect(struct bcm43xx_private *bcm, u8 channel);
-u8 bcm43xx_radio_aci_scan(struct bcm43xx_private *bcm);
+u8 bcm43xx_radio_aci_detect(struct bcm43xx_wldev *dev, u8 channel);
+u8 bcm43xx_radio_aci_scan(struct bcm43xx_wldev *dev);
 
-int bcm43xx_radio_set_interference_mitigation(struct bcm43xx_private *bcm, int mode);
+int bcm43xx_radio_set_interference_mitigation(struct bcm43xx_wldev *dev,
+					      int mode);
 
-void bcm43xx_calc_nrssi_slope(struct bcm43xx_private *bcm);
-void bcm43xx_calc_nrssi_threshold(struct bcm43xx_private *bcm);
-s16 bcm43xx_nrssi_hw_read(struct bcm43xx_private *bcm, u16 offset);
-void bcm43xx_nrssi_hw_write(struct bcm43xx_private *bcm, u16 offset, s16 val);
-void bcm43xx_nrssi_hw_update(struct bcm43xx_private *bcm, u16 val);
-void bcm43xx_nrssi_mem_update(struct bcm43xx_private *bcm);
+void bcm43xx_calc_nrssi_slope(struct bcm43xx_wldev *dev);
+void bcm43xx_calc_nrssi_threshold(struct bcm43xx_wldev *dev);
+s16 bcm43xx_nrssi_hw_read(struct bcm43xx_wldev *dev, u16 offset);
+void bcm43xx_nrssi_hw_write(struct bcm43xx_wldev *dev, u16 offset, s16 val);
+void bcm43xx_nrssi_hw_update(struct bcm43xx_wldev *dev, u16 val);
+void bcm43xx_nrssi_mem_update(struct bcm43xx_wldev *dev);
 
-void bcm43xx_radio_set_tx_iq(struct bcm43xx_private *bcm);
-u16 bcm43xx_radio_calibrationvalue(struct bcm43xx_private *bcm);
+void bcm43xx_radio_set_tx_iq(struct bcm43xx_wldev *dev);
+u16 bcm43xx_radio_calibrationvalue(struct bcm43xx_wldev *dev);
 
 #endif /* BCM43xx_RADIO_H_ */



From Larry.Finger at lwfinger.net  Thu Aug  2 17:53:47 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:53:47 -0500
Subject: [RFC 6/10] Port of bcm43xx from softmac to mac80211
Message-ID: <46b1fe0b.ma51PJwmVWdgDRFI%Larry.Finger@lwfinger.net>

This if file 6 of 10 of the port of the bcm43xx driver from softmac
to mac80211.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
@@ -7,6 +7,7 @@
                      Michael Buesch <mbuesch at freenet.de>
                      Danny van Dyk <kugelfang at gentoo.org>
                      Andreas Jaggi <andreas.jaggi at waterwave.ch>
+  Copyright (c) 2007 Larry Finger <Larry.Finger at lwfinger.net>
 
   Some parts of the code in this file are derived from the ipw2200
   driver  Copyright(c) 2003 - 2004 Intel Corporation.
@@ -37,7 +38,6 @@
 #include "bcm43xx_main.h"
 #include "bcm43xx_radio.h"
 #include "bcm43xx_ilt.h"
-#include "bcm43xx_power.h"
 
 
 static const s8 bcm43xx_tssi2dbm_b_table[] = {
@@ -78,911 +78,737 @@ static const s8 bcm43xx_tssi2dbm_g_table
 	-20, -20, -20, -20,
 };
 
-static void bcm43xx_phy_initg(struct bcm43xx_private *bcm);
+static void bcm43xx_phy_initg(struct bcm43xx_wldev *dev);
 
 
 static inline
 void bcm43xx_voluntary_preempt(void)
 {
-	assert(!in_atomic() && !in_irq() &&
-	       !in_interrupt() && !irqs_disabled());
+	BCM43xx_BUG_ON(!(!in_atomic() && !in_irq() &&
+			  !in_interrupt() && !irqs_disabled()));
 #ifndef CONFIG_PREEMPT
 	cond_resched();
 #endif /* CONFIG_PREEMPT */
 }
 
-void bcm43xx_raw_phy_lock(struct bcm43xx_private *bcm)
+void bcm43xx_raw_phy_lock(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 
-	assert(irqs_disabled());
-	if (bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD) == 0x00000000) {
-		phy->is_locked = 0;
+	BCM43xx_WARN_ON(!irqs_disabled());
+	if (bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD) == 0) {
+		phy->locked = 0;
 		return;
 	}
-	if (bcm->current_core->rev < 3) {
-		bcm43xx_mac_suspend(bcm);
+	if (dev->dev->id.revision < 3) {
+		bcm43xx_mac_suspend(dev);
 		spin_lock(&phy->lock);
 	} else {
-		if (bcm->ieee->iw_mode != IW_MODE_MASTER)
-			bcm43xx_power_saving_ctl_bits(bcm, -1, 1);
+		if (!bcm43xx_is_mode(dev->wl, IEEE80211_IF_TYPE_AP))
+			bcm43xx_power_saving_ctl_bits(dev, -1, 1);
 	}
-	phy->is_locked = 1;
+	phy->locked = 1;
 }
 
-void bcm43xx_raw_phy_unlock(struct bcm43xx_private *bcm)
+void bcm43xx_raw_phy_unlock(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 
-	assert(irqs_disabled());
-	if (bcm->current_core->rev < 3) {
-		if (phy->is_locked) {
+	BCM43xx_WARN_ON(!irqs_disabled());
+	if (dev->dev->id.revision < 3) {
+		if (phy->locked) {
 			spin_unlock(&phy->lock);
-			bcm43xx_mac_enable(bcm);
+			bcm43xx_mac_enable(dev);
 		}
 	} else {
-		if (bcm->ieee->iw_mode != IW_MODE_MASTER)
-			bcm43xx_power_saving_ctl_bits(bcm, -1, -1);
+		if (!bcm43xx_is_mode(dev->wl, IEEE80211_IF_TYPE_AP))
+			bcm43xx_power_saving_ctl_bits(dev, -1, -1);
 	}
-	phy->is_locked = 0;
+	phy->locked = 0;
 }
 
-u16 bcm43xx_phy_read(struct bcm43xx_private *bcm, u16 offset)
+u16 bcm43xx_phy_read(struct bcm43xx_wldev *dev, u16 offset)
 {
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_CONTROL, offset);
-	return bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_DATA);
+	bcm43xx_write16(dev, BCM43xx_MMIO_PHY_CONTROL, offset);
+	return bcm43xx_read16(dev, BCM43xx_MMIO_PHY_DATA);
 }
 
-void bcm43xx_phy_write(struct bcm43xx_private *bcm, u16 offset, u16 val)
+void bcm43xx_phy_write(struct bcm43xx_wldev *dev, u16 offset, u16 val)
 {
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_CONTROL, offset);
+	bcm43xx_write16(dev, BCM43xx_MMIO_PHY_CONTROL, offset);
 	mmiowb();
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_DATA, val);
+	bcm43xx_write16(dev, BCM43xx_MMIO_PHY_DATA, val);
 }
 
-void bcm43xx_phy_calibrate(struct bcm43xx_private *bcm)
+void bcm43xx_phy_calibrate(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 
-	bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD); /* Dummy read. */
+	bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD); /* Dummy read. */
 	if (phy->calibrated)
 		return;
 	if (phy->type == BCM43xx_PHYTYPE_G && phy->rev == 1) {
-		bcm43xx_wireless_core_reset(bcm, 0);
-		bcm43xx_phy_initg(bcm);
-		bcm43xx_wireless_core_reset(bcm, 1);
+		bcm43xx_wireless_core_reset(dev, 0);
+		bcm43xx_phy_initg(dev);
+		bcm43xx_wireless_core_reset(dev, BCM43xx_TMSLOW_GMODE);
 	}
 	phy->calibrated = 1;
 }
 
-/* Connect the PHY 
- * http://bcm-specs.sipsolutions.net/SetPHY
- */
-int bcm43xx_phy_connect(struct bcm43xx_private *bcm, int connect)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u32 flags;
-
-	if (bcm->current_core->rev < 5)
-		goto out;
-
-	flags = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-	if (connect) {
-		if (!(flags & BCM43xx_SBTMSTATEHIGH_G_PHY_AVAIL))
-			return -ENODEV;
-		flags = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-		flags |= BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, flags);
-	} else {
-		if (!(flags & BCM43xx_SBTMSTATEHIGH_A_PHY_AVAIL))
-			return -ENODEV;
-		flags = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-		flags &= ~BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, flags);
-	}
-out:
-	phy->connected = connect;
-	if (connect)
-		dprintk(KERN_INFO PFX "PHY connected\n");
-	else
-		dprintk(KERN_INFO PFX "PHY disconnected\n");
-
-	return 0;
-}
-
 /* intialize B PHY power control
  * as described in http://bcm-specs.sipsolutions.net/InitPowerControl
  */
-static void bcm43xx_phy_init_pctl(struct bcm43xx_private *bcm)
+static void bcm43xx_phy_init_pctl(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 saved_batt = 0, saved_ratt = 0, saved_txctl1 = 0;
 	int must_reset_txpower = 0;
 
-	assert(phy->type != BCM43xx_PHYTYPE_A);
-	if ((bcm->board_vendor == PCI_VENDOR_ID_BROADCOM) &&
-	    (bcm->board_type == 0x0416))
+	BCM43xx_BUG_ON(!(phy->type == BCM43xx_PHYTYPE_B ||
+			  phy->type == BCM43xx_PHYTYPE_G));
+	if (is_bcm_board_vendor(dev) &&
+	    (dev->dev->bus->boardinfo.type == 0x0416))
 		return;
 
-	bcm43xx_phy_write(bcm, 0x0028, 0x8018);
-	bcm43xx_write16(bcm, 0x03E6, bcm43xx_read16(bcm, 0x03E6) & 0xFFDF);
+	bcm43xx_phy_write(dev, 0x0028, 0x8018);
+	bcm43xx_write16(dev, 0x03E6, bcm43xx_read16(dev, 0x03E6) & 0xFFDF);
 
 	if (phy->type == BCM43xx_PHYTYPE_G) {
-		if (!phy->connected)
+		if (!phy->gmode)
 			return;
-		bcm43xx_phy_write(bcm, 0x047A, 0xC111);
+		bcm43xx_phy_write(dev, 0x047A, 0xC111);
 	}
 	if (phy->savedpctlreg != 0xFFFF)
 		return;
+#ifdef CONFIG_BCM43XX_DEBUG
+	if (phy->manual_txpower_control)
+		return;
+#endif
 
 	if (phy->type == BCM43xx_PHYTYPE_B &&
 	    phy->rev >= 2 &&
-	    radio->version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0076,
-				      bcm43xx_radio_read16(bcm, 0x0076) | 0x0084);
+	    phy->radio_ver == 0x2050) {
+		bcm43xx_radio_write16(dev, 0x0076,
+				      bcm43xx_radio_read16(dev, 0x0076)
+				      | 0x0084);
 	} else {
-		saved_batt = radio->baseband_atten;
-		saved_ratt = radio->radio_atten;
-		saved_txctl1 = radio->txctl1;
-		if ((radio->revision >= 6) && (radio->revision <= 8)
+		saved_batt = phy->bbatt;
+		saved_ratt = phy->rfatt;
+		saved_txctl1 = phy->txctl1;
+		if ((phy->radio_rev >= 6) && (phy->radio_rev <= 8)
 		    && /*FIXME: incomplete specs for 5 < revision < 9 */ 0)
-			bcm43xx_radio_set_txpower_bg(bcm, 0xB, 0x1F, 0);
+			bcm43xx_radio_set_txpower_bg(dev, 0xB, 0x1F, 0);
 		else
-			bcm43xx_radio_set_txpower_bg(bcm, 0xB, 9, 0);
+			bcm43xx_radio_set_txpower_bg(dev, 0xB, 9, 0);
 		must_reset_txpower = 1;
 	}
-	bcm43xx_dummy_transmission(bcm);
+	bcm43xx_dummy_transmission(dev);
 
-	phy->savedpctlreg = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_PCTL);
+	phy->savedpctlreg = bcm43xx_phy_read(dev, BCM43xx_PHY_G_PCTL);
 
 	if (must_reset_txpower)
-		bcm43xx_radio_set_txpower_bg(bcm, saved_batt, saved_ratt, saved_txctl1);
+		bcm43xx_radio_set_txpower_bg(dev, saved_batt, saved_ratt,
+					     saved_txctl1);
 	else
-		bcm43xx_radio_write16(bcm, 0x0076, bcm43xx_radio_read16(bcm, 0x0076) & 0xFF7B);
-	bcm43xx_radio_clear_tssi(bcm);
+		bcm43xx_radio_write16(dev, 0x0076, bcm43xx_radio_read16(dev,
+				      0x0076) & 0xFF7B);
+	bcm43xx_radio_clear_tssi(dev);
 }
 
-static void bcm43xx_phy_agcsetup(struct bcm43xx_private *bcm)
+static void bcm43xx_phy_agcsetup(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 offset = 0x0000;
 
 	if (phy->rev == 1)
 		offset = 0x4C00;
 
-	bcm43xx_ilt_write(bcm, offset, 0x00FE);
-	bcm43xx_ilt_write(bcm, offset + 1, 0x000D);
-	bcm43xx_ilt_write(bcm, offset + 2, 0x0013);
-	bcm43xx_ilt_write(bcm, offset + 3, 0x0019);
+	bcm43xx_ilt_write(dev, offset, 0x00FE);
+	bcm43xx_ilt_write(dev, offset + 1, 0x000D);
+	bcm43xx_ilt_write(dev, offset + 2, 0x0013);
+	bcm43xx_ilt_write(dev, offset + 3, 0x0019);
 
 	if (phy->rev == 1) {
-		bcm43xx_ilt_write(bcm, 0x1800, 0x2710);
-		bcm43xx_ilt_write(bcm, 0x1801, 0x9B83);
-		bcm43xx_ilt_write(bcm, 0x1802, 0x9B83);
-		bcm43xx_ilt_write(bcm, 0x1803, 0x0F8D);
-		bcm43xx_phy_write(bcm, 0x0455, 0x0004);
-	}
-
-	bcm43xx_phy_write(bcm, 0x04A5, (bcm43xx_phy_read(bcm, 0x04A5) & 0x00FF) | 0x5700);
-	bcm43xx_phy_write(bcm, 0x041A, (bcm43xx_phy_read(bcm, 0x041A) & 0xFF80) | 0x000F);
-	bcm43xx_phy_write(bcm, 0x041A, (bcm43xx_phy_read(bcm, 0x041A) & 0xC07F) | 0x2B80);
-	bcm43xx_phy_write(bcm, 0x048C, (bcm43xx_phy_read(bcm, 0x048C) & 0xF0FF) | 0x0300);
-
-	bcm43xx_radio_write16(bcm, 0x007A, bcm43xx_radio_read16(bcm, 0x007A) | 0x0008);
-
-	bcm43xx_phy_write(bcm, 0x04A0, (bcm43xx_phy_read(bcm, 0x04A0) & 0xFFF0) | 0x0008);
-	bcm43xx_phy_write(bcm, 0x04A1, (bcm43xx_phy_read(bcm, 0x04A1) & 0xF0FF) | 0x0600);
-	bcm43xx_phy_write(bcm, 0x04A2, (bcm43xx_phy_read(bcm, 0x04A2) & 0xF0FF) | 0x0700);
-	bcm43xx_phy_write(bcm, 0x04A0, (bcm43xx_phy_read(bcm, 0x04A0) & 0xF0FF) | 0x0100);
+		bcm43xx_ilt_write(dev, 0x1800, 0x2710);
+		bcm43xx_ilt_write(dev, 0x1801, 0x9B83);
+		bcm43xx_ilt_write(dev, 0x1802, 0x9B83);
+		bcm43xx_ilt_write(dev, 0x1803, 0x0F8D);
+		bcm43xx_phy_write(dev, 0x0455, 0x0004);
+	}
+
+	bcm43xx_phy_write(dev, 0x04A5, (bcm43xx_phy_read(dev, 0x04A5) & 0x00FF)
+					| 0x5700);
+	bcm43xx_phy_write(dev, 0x041A, (bcm43xx_phy_read(dev, 0x041A) & 0xFF80)
+					| 0x000F);
+	bcm43xx_phy_write(dev, 0x041A, (bcm43xx_phy_read(dev, 0x041A) & 0xC07F)
+					| 0x2B80);
+	bcm43xx_phy_write(dev, 0x048C, (bcm43xx_phy_read(dev, 0x048C) & 0xF0FF)
+					| 0x0300);
+
+	bcm43xx_radio_write16(dev, 0x007A, bcm43xx_radio_read16(dev, 0x007A)
+					   | 0x0008);
+
+	bcm43xx_phy_write(dev, 0x04A0, (bcm43xx_phy_read(dev, 0x04A0) & 0xFFF0)
+					| 0x0008);
+	bcm43xx_phy_write(dev, 0x04A1, (bcm43xx_phy_read(dev, 0x04A1) & 0xF0FF)
+					| 0x0600);
+	bcm43xx_phy_write(dev, 0x04A2, (bcm43xx_phy_read(dev, 0x04A2) & 0xF0FF)
+					| 0x0700);
+	bcm43xx_phy_write(dev, 0x04A0, (bcm43xx_phy_read(dev, 0x04A0) & 0xF0FF)
+					| 0x0100);
 
 	if (phy->rev == 1)
-		bcm43xx_phy_write(bcm, 0x04A2, (bcm43xx_phy_read(bcm, 0x04A2) & 0xFFF0) | 0x0007);
+		bcm43xx_phy_write(dev, 0x04A2, (bcm43xx_phy_read(dev, 0x04A2)
+				  & 0xFFF0) | 0x0007);
 
-	bcm43xx_phy_write(bcm, 0x0488, (bcm43xx_phy_read(bcm, 0x0488) & 0xFF00) | 0x001C);
-	bcm43xx_phy_write(bcm, 0x0488, (bcm43xx_phy_read(bcm, 0x0488) & 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(bcm, 0x0496, (bcm43xx_phy_read(bcm, 0x0496) & 0xFF00) | 0x001C);
-	bcm43xx_phy_write(bcm, 0x0489, (bcm43xx_phy_read(bcm, 0x0489) & 0xFF00) | 0x0020);
-	bcm43xx_phy_write(bcm, 0x0489, (bcm43xx_phy_read(bcm, 0x0489) & 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(bcm, 0x0482, (bcm43xx_phy_read(bcm, 0x0482) & 0xFF00) | 0x002E);
-	bcm43xx_phy_write(bcm, 0x0496, (bcm43xx_phy_read(bcm, 0x0496) & 0x00FF) | 0x1A00);
-	bcm43xx_phy_write(bcm, 0x0481, (bcm43xx_phy_read(bcm, 0x0481) & 0xFF00) | 0x0028);
-	bcm43xx_phy_write(bcm, 0x0481, (bcm43xx_phy_read(bcm, 0x0481) & 0x00FF) | 0x2C00);
+	bcm43xx_phy_write(dev, 0x0488, (bcm43xx_phy_read(dev, 0x0488) & 0xFF00)
+					| 0x001C);
+	bcm43xx_phy_write(dev, 0x0488, (bcm43xx_phy_read(dev, 0x0488) & 0xC0FF)
+					| 0x0200);
+	bcm43xx_phy_write(dev, 0x0496, (bcm43xx_phy_read(dev, 0x0496) & 0xFF00)
+					| 0x001C);
+	bcm43xx_phy_write(dev, 0x0489, (bcm43xx_phy_read(dev, 0x0489) & 0xFF00)
+					| 0x0020);
+	bcm43xx_phy_write(dev, 0x0489, (bcm43xx_phy_read(dev, 0x0489) & 0xC0FF)
+					| 0x0200);
+	bcm43xx_phy_write(dev, 0x0482, (bcm43xx_phy_read(dev, 0x0482) & 0xFF00)
+					| 0x002E);
+	bcm43xx_phy_write(dev, 0x0496, (bcm43xx_phy_read(dev, 0x0496) & 0x00FF)
+					| 0x1A00);
+	bcm43xx_phy_write(dev, 0x0481, (bcm43xx_phy_read(dev, 0x0481) & 0xFF00)
+					| 0x0028);
+	bcm43xx_phy_write(dev, 0x0481, (bcm43xx_phy_read(dev, 0x0481) & 0x00FF)
+					| 0x2C00);
 
 	if (phy->rev == 1) {
-		bcm43xx_phy_write(bcm, 0x0430, 0x092B);
-		bcm43xx_phy_write(bcm, 0x041B, (bcm43xx_phy_read(bcm, 0x041B) & 0xFFE1) | 0x0002);
+		bcm43xx_phy_write(dev, 0x0430, 0x092B);
+		bcm43xx_phy_write(dev, 0x041B, (bcm43xx_phy_read(dev, 0x041B)
+				  & 0xFFE1) | 0x0002);
 	} else {
-		bcm43xx_phy_write(bcm, 0x041B, bcm43xx_phy_read(bcm, 0x041B) & 0xFFE1);
-		bcm43xx_phy_write(bcm, 0x041F, 0x287A);
-		bcm43xx_phy_write(bcm, 0x0420, (bcm43xx_phy_read(bcm, 0x0420) & 0xFFF0) | 0x0004);
+		bcm43xx_phy_write(dev, 0x041B, bcm43xx_phy_read(dev, 0x041B)
+				  & 0xFFE1);
+		bcm43xx_phy_write(dev, 0x041F, 0x287A);
+		bcm43xx_phy_write(dev, 0x0420, (bcm43xx_phy_read(dev, 0x0420)
+				  & 0xFFF0) | 0x0004);
 	}
 
 	if (phy->rev > 2) {
-		bcm43xx_phy_write(bcm, 0x0422, 0x287A);
-		bcm43xx_phy_write(bcm, 0x0420, (bcm43xx_phy_read(bcm, 0x0420)
+		bcm43xx_phy_write(dev, 0x0422, 0x287A);
+		bcm43xx_phy_write(dev, 0x0420, (bcm43xx_phy_read(dev, 0x0420)
 				  & 0x0FFF) | 0x3000);
 	}
-		
-	bcm43xx_phy_write(bcm, 0x04A8, (bcm43xx_phy_read(bcm, 0x04A8) & 0x8080)
+
+	bcm43xx_phy_write(dev, 0x04A8, (bcm43xx_phy_read(dev, 0x04A8) & 0x8080)
 					| 0x7874);
-	bcm43xx_phy_write(bcm, 0x048E, 0x1C00);
+	bcm43xx_phy_write(dev, 0x048E, 0x1C00);
 
 	if (phy->rev == 1) {
-		bcm43xx_phy_write(bcm, 0x04AB, (bcm43xx_phy_read(bcm, 0x04AB)
+		bcm43xx_phy_write(dev, 0x04AB,
+				  (bcm43xx_phy_read(dev, 0x04AB)
 				  & 0xF0FF) | 0x0600);
-		bcm43xx_phy_write(bcm, 0x048B, 0x005E);
-		bcm43xx_phy_write(bcm, 0x048C, (bcm43xx_phy_read(bcm, 0x048C)
-				  & 0xFF00) | 0x001E);
-		bcm43xx_phy_write(bcm, 0x048D, 0x0002);
+		bcm43xx_phy_write(dev, 0x048B, 0x005E);
+		bcm43xx_phy_write(dev, 0x048C,
+				  (bcm43xx_phy_read(dev, 0x048C) & 0xFF00)
+				  | 0x001E);
+		bcm43xx_phy_write(dev, 0x048D, 0x0002);
 	}
 
-	bcm43xx_ilt_write(bcm, offset + 0x0800, 0);
-	bcm43xx_ilt_write(bcm, offset + 0x0801, 7);
-	bcm43xx_ilt_write(bcm, offset + 0x0802, 16);
-	bcm43xx_ilt_write(bcm, offset + 0x0803, 28);
+	bcm43xx_ilt_write(dev, offset + 0x0800, 0);
+	bcm43xx_ilt_write(dev, offset + 0x0801, 7);
+	bcm43xx_ilt_write(dev, offset + 0x0802, 16);
+	bcm43xx_ilt_write(dev, offset + 0x0803, 28);
 
 	if (phy->rev >= 6) {
-		bcm43xx_phy_write(bcm, 0x0426, (bcm43xx_phy_read(bcm, 0x0426)
-				  & 0xFFFC));
-		bcm43xx_phy_write(bcm, 0x0426, (bcm43xx_phy_read(bcm, 0x0426)
-				  & 0xEFFF));
+		bcm43xx_phy_write(dev, 0x0426,
+				  (bcm43xx_phy_read(dev, 0x0426) & 0xFFFC));
+		bcm43xx_phy_write(dev, 0x0426,
+				  (bcm43xx_phy_read(dev, 0x0426) & 0xEFFF));
 	}
 }
 
-static void bcm43xx_phy_setupg(struct bcm43xx_private *bcm)
+static void bcm43xx_phy_setupg(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 i;
 
-	assert(phy->type == BCM43xx_PHYTYPE_G);
+	BCM43xx_BUG_ON(phy->type != BCM43xx_PHYTYPE_G);
 	if (phy->rev == 1) {
-		bcm43xx_phy_write(bcm, 0x0406, 0x4F19);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  (bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS)
-				  & 0xFC3F) | 0x0340);
-		bcm43xx_phy_write(bcm, 0x042C, 0x005A);
-		bcm43xx_phy_write(bcm, 0x0427, 0x001A);
+		bcm43xx_phy_write(dev, 0x0406, 0x4F19);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
+				  (bcm43xx_phy_read(dev,
+				  BCM43xx_PHY_G_CRS) & 0xFC3F) | 0x0340);
+		bcm43xx_phy_write(dev, 0x042C, 0x005A);
+		bcm43xx_phy_write(dev, 0x0427, 0x001A);
 
 		for (i = 0; i < BCM43xx_ILT_FINEFREQG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5800 + i, bcm43xx_ilt_finefreqg[i]);
+			bcm43xx_ilt_write(dev, 0x5800 + i,
+					  bcm43xx_ilt_finefreqg[i]);
 		for (i = 0; i < BCM43xx_ILT_NOISEG1_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noiseg1[i]);
+			bcm43xx_ilt_write(dev, 0x1800 + i,
+					  bcm43xx_ilt_noiseg1[i]);
 		for (i = 0; i < BCM43xx_ILT_ROTOR_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2000 + i, bcm43xx_ilt_rotor[i]);
+			bcm43xx_ilt_write32(dev, 0x2000 + i,
+					    bcm43xx_ilt_rotor[i]);
 	} else {
-		/* nrssi values are signed 6-bit values. Not sure why we write 0x7654 here... */
-		bcm43xx_nrssi_hw_write(bcm, 0xBA98, (s16)0x7654);
+		/* nrssi values are signed 6-bit values. Why 0x7654 here? */
+		bcm43xx_nrssi_hw_write(dev, 0xBA98, (s16)0x7654);
 
 		if (phy->rev == 2) {
-			bcm43xx_phy_write(bcm, 0x04C0, 0x1861);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x0271);
+			bcm43xx_phy_write(dev, 0x04C0, 0x1861);
+			bcm43xx_phy_write(dev, 0x04C1, 0x0271);
 		} else if (phy->rev > 2) {
-			bcm43xx_phy_write(bcm, 0x04C0, 0x0098);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x0070);
-			bcm43xx_phy_write(bcm, 0x04C9, 0x0080);
+			bcm43xx_phy_write(dev, 0x04C0, 0x0098);
+			bcm43xx_phy_write(dev, 0x04C1, 0x0070);
+			bcm43xx_phy_write(dev, 0x04C9, 0x0080);
 		}
-		bcm43xx_phy_write(bcm, 0x042B, bcm43xx_phy_read(bcm, 0x042B) | 0x800);
+		bcm43xx_phy_write(dev, 0x042B, bcm43xx_phy_read(dev,
+				  0x042B) | 0x800);
 
 		for (i = 0; i < 64; i++)
-			bcm43xx_ilt_write(bcm, 0x4000 + i, i);
+			bcm43xx_ilt_write(dev, 0x4000 + i, i);
 		for (i = 0; i < BCM43xx_ILT_NOISEG2_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noiseg2[i]);
+			bcm43xx_ilt_write(dev, 0x1800 + i,
+					  bcm43xx_ilt_noiseg2[i]);
 	}
-	
+
 	if (phy->rev <= 2)
 		for (i = 0; i < BCM43xx_ILT_NOISESCALEG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1400 + i, bcm43xx_ilt_noisescaleg1[i]);
-	else if ((phy->rev >= 7) && (bcm43xx_phy_read(bcm, 0x0449) & 0x0200))
+			bcm43xx_ilt_write(dev, 0x1400 + i,
+					  bcm43xx_ilt_noisescaleg1[i]);
+	else if ((phy->rev >= 7) && (bcm43xx_phy_read(dev, 0x0449) & 0x0200))
 		for (i = 0; i < BCM43xx_ILT_NOISESCALEG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1400 + i, bcm43xx_ilt_noisescaleg3[i]);
+			bcm43xx_ilt_write(dev, 0x1400 + i,
+					  bcm43xx_ilt_noisescaleg3[i]);
 	else
 		for (i = 0; i < BCM43xx_ILT_NOISESCALEG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1400 + i, bcm43xx_ilt_noisescaleg2[i]);
-	
+			bcm43xx_ilt_write(dev, 0x1400 + i,
+					  bcm43xx_ilt_noisescaleg2[i]);
+
 	if (phy->rev == 2)
 		for (i = 0; i < BCM43xx_ILT_SIGMASQR_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5000 + i, bcm43xx_ilt_sigmasqr1[i]);
+			bcm43xx_ilt_write(dev, 0x5000 + i,
+					  bcm43xx_ilt_sigmasqr1[i]);
 	else if ((phy->rev > 2) && (phy->rev <= 8))
 		for (i = 0; i < BCM43xx_ILT_SIGMASQR_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5000 + i, bcm43xx_ilt_sigmasqr2[i]);
-	
+			bcm43xx_ilt_write(dev, 0x5000 + i,
+					  bcm43xx_ilt_sigmasqr2[i]);
+
 	if (phy->rev == 1) {
 		for (i = 0; i < BCM43xx_ILT_RETARD_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2400 + i, bcm43xx_ilt_retard[i]);
-		for (i = 0; i < 4; i++) {
-			bcm43xx_ilt_write(bcm, 0x5404 + i, 0x0020);
-			bcm43xx_ilt_write(bcm, 0x5408 + i, 0x0020);
-			bcm43xx_ilt_write(bcm, 0x540C + i, 0x0020);
-			bcm43xx_ilt_write(bcm, 0x5410 + i, 0x0020);
-		}
-		bcm43xx_phy_agcsetup(bcm);
-
-		if ((bcm->board_vendor == PCI_VENDOR_ID_BROADCOM) &&
-		    (bcm->board_type == 0x0416) &&
-		    (bcm->board_revision == 0x0017))
+			bcm43xx_ilt_write32(dev, 0x2400 + i,
+					    bcm43xx_ilt_retard[i]);
+		for (i = 4; i < 20; i++)
+			bcm43xx_ilt_write(dev, 0x5400 + i, 0x0020);
+		bcm43xx_phy_agcsetup(dev);
+
+		if (is_bcm_board_vendor(dev) &&
+		    (dev->dev->bus->boardinfo.type == 0x0416) &&
+		    (dev->dev->bus->boardinfo.rev == 0x0017))
 			return;
 
-		bcm43xx_ilt_write(bcm, 0x5001, 0x0002);
-		bcm43xx_ilt_write(bcm, 0x5002, 0x0001);
+		bcm43xx_ilt_write(dev, 0x5001, 0x0002);
+		bcm43xx_ilt_write(dev, 0x5002, 0x0001);
 	} else {
-		for (i = 0; i <= 0x2F; i++)
-			bcm43xx_ilt_write(bcm, 0x1000 + i, 0x0820);
-		bcm43xx_phy_agcsetup(bcm);
-		bcm43xx_phy_read(bcm, 0x0400); /* dummy read */
-		bcm43xx_phy_write(bcm, 0x0403, 0x1000);
-		bcm43xx_ilt_write(bcm, 0x3C02, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x3C03, 0x0014);
-
-		if ((bcm->board_vendor == PCI_VENDOR_ID_BROADCOM) &&
-		    (bcm->board_type == 0x0416) &&
-		    (bcm->board_revision == 0x0017))
+		for (i = 0; i <= 0x20; i++)
+			bcm43xx_ilt_write(dev, 0x1000 + i, 0x0820);
+		bcm43xx_phy_agcsetup(dev);
+		bcm43xx_phy_read(dev, 0x0400); /* dummy read */
+		bcm43xx_phy_write(dev, 0x0403, 0x1000);
+		bcm43xx_ilt_write(dev, 0x3C02, 0x000F);
+		bcm43xx_ilt_write(dev, 0x3C03, 0x0014);
+
+		if (is_bcm_board_vendor(dev) &&
+		    (dev->dev->bus->boardinfo.type == 0x0416) &&
+		    (dev->dev->bus->boardinfo.rev == 0x0017))
 			return;
 
-		bcm43xx_ilt_write(bcm, 0x0401, 0x0002);
-		bcm43xx_ilt_write(bcm, 0x0402, 0x0001);
+		bcm43xx_ilt_write(dev, 0x0401, 0x0002);
+		bcm43xx_ilt_write(dev, 0x0402, 0x0001);
 	}
 }
 
-/* Initialize the noisescaletable for APHY */
-static void bcm43xx_phy_init_noisescaletbl(struct bcm43xx_private *bcm)
+/* Initialize the APHY portion of a GPHY. */
+static void bcm43xx_phy_inita(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	int i;
-
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, 0x1400);
-	for (i = 0; i < 12; i++) {
-		if (phy->rev == 2)
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x6767);
-		else
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x2323);
-	}
-	if (phy->rev == 2)
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x6700);
-	else
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x2300);
-	for (i = 0; i < 11; i++) {
-		if (phy->rev == 2)
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x6767);
-		else
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x2323);
-	}
-	if (phy->rev == 2)
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x0067);
-	else
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x0023);
-}
 
-static void bcm43xx_phy_setupa(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 i;
+	might_sleep();
 
-	assert(phy->type == BCM43xx_PHYTYPE_A);
-	switch (phy->rev) {
-	case 2:
-		bcm43xx_phy_write(bcm, 0x008E, 0x3800);
-		bcm43xx_phy_write(bcm, 0x0035, 0x03FF);
-		bcm43xx_phy_write(bcm, 0x0036, 0x0400);
-
-		bcm43xx_ilt_write(bcm, 0x3807, 0x0051);
-
-		bcm43xx_phy_write(bcm, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(bcm, 0x0020, bcm43xx_phy_read(bcm, 0x0020) & 0xFF0F);
-		bcm43xx_ilt_write(bcm, 0x3C0C, 0x07BF);
-		bcm43xx_radio_write16(bcm, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(bcm, 0x0024, 0x4680);
-		bcm43xx_phy_write(bcm, 0x0020, 0x0003);
-		bcm43xx_phy_write(bcm, 0x001D, 0x0F40);
-		bcm43xx_phy_write(bcm, 0x001F, 0x1C00);
-
-		bcm43xx_phy_write(bcm, 0x002A, (bcm43xx_phy_read(bcm, 0x002A) & 0x00FF) | 0x0400);
-		bcm43xx_phy_write(bcm, 0x002B, bcm43xx_phy_read(bcm, 0x002B) & 0xFBFF);
-		bcm43xx_phy_write(bcm, 0x008E, 0x58C1);
-
-		bcm43xx_ilt_write(bcm, 0x0803, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x0804, 0x001F);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x002A);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x0030);
-		bcm43xx_ilt_write(bcm, 0x0807, 0x003A);
-
-		bcm43xx_ilt_write(bcm, 0x0000, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0001, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0002, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0003, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0004, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0005, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0006, 0x0019);
-
-		bcm43xx_ilt_write(bcm, 0x0404, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0405, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0406, 0x0007);
-
-		for (i = 0; i < 16; i++)
-			bcm43xx_ilt_write(bcm, 0x4000 + i, (0x8 + i) & 0x000F);
-
-		bcm43xx_ilt_write(bcm, 0x3003, 0x1044);
-		bcm43xx_ilt_write(bcm, 0x3004, 0x7201);
-		bcm43xx_ilt_write(bcm, 0x3006, 0x0040);
-		bcm43xx_ilt_write(bcm, 0x3001, (bcm43xx_ilt_read(bcm, 0x3001) & 0x0010) | 0x0008);
-
-		for (i = 0; i < BCM43xx_ILT_FINEFREQA_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5800 + i, bcm43xx_ilt_finefreqa[i]);
-		for (i = 0; i < BCM43xx_ILT_NOISEA2_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noisea2[i]);
-		for (i = 0; i < BCM43xx_ILT_ROTOR_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2000 + i, bcm43xx_ilt_rotor[i]);
-		bcm43xx_phy_init_noisescaletbl(bcm);
-		for (i = 0; i < BCM43xx_ILT_RETARD_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2400 + i, bcm43xx_ilt_retard[i]);
-		break;
-	case 3:
-		for (i = 0; i < 64; i++)
-			bcm43xx_ilt_write(bcm, 0x4000 + i, i);
-
-		bcm43xx_ilt_write(bcm, 0x3807, 0x0051);
-
-		bcm43xx_phy_write(bcm, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(bcm, 0x0020, bcm43xx_phy_read(bcm, 0x0020) & 0xFF0F);
-		bcm43xx_radio_write16(bcm, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(bcm, 0x0024, 0x4680);
-		bcm43xx_phy_write(bcm, 0x0020, 0x0003);
-		bcm43xx_phy_write(bcm, 0x001D, 0x0F40);
-		bcm43xx_phy_write(bcm, 0x001F, 0x1C00);
-		bcm43xx_phy_write(bcm, 0x002A, (bcm43xx_phy_read(bcm, 0x002A) & 0x00FF) | 0x0400);
-
-		bcm43xx_ilt_write(bcm, 0x3001, (bcm43xx_ilt_read(bcm, 0x3001) & 0x0010) | 0x0008);
-		for (i = 0; i < BCM43xx_ILT_NOISEA3_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noisea3[i]);
-		bcm43xx_phy_init_noisescaletbl(bcm);
-		for (i = 0; i < BCM43xx_ILT_SIGMASQR_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5000 + i, bcm43xx_ilt_sigmasqr1[i]);
-
-		bcm43xx_phy_write(bcm, 0x0003, 0x1808);
-
-		bcm43xx_ilt_write(bcm, 0x0803, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x0804, 0x001F);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x002A);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x0030);
-		bcm43xx_ilt_write(bcm, 0x0807, 0x003A);
-
-		bcm43xx_ilt_write(bcm, 0x0000, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0001, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0002, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0003, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0004, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0005, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0006, 0x0019);
-
-		bcm43xx_ilt_write(bcm, 0x0404, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0405, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0406, 0x0007);
-
-		bcm43xx_ilt_write(bcm, 0x3C02, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x3C03, 0x0014);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-/* Initialize APHY. This is also called for the GPHY in some cases. */
-static void bcm43xx_phy_inita(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 tval;
-
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_setupa(bcm);
-	} else {
-		bcm43xx_phy_setupg(bcm);
-		if (bcm->sprom.boardflags & BCM43xx_BFL_PACTRL)
-			bcm43xx_phy_write(bcm, 0x046E, 0x03CF);
-		return;
-	}
-
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_A_CRS,
-	                  (bcm43xx_phy_read(bcm, BCM43xx_PHY_A_CRS) & 0xF83C) | 0x0340);
-	bcm43xx_phy_write(bcm, 0x0034, 0x0001);
-
-	TODO();//TODO: RSSI AGC
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_A_CRS,
-	                  bcm43xx_phy_read(bcm, BCM43xx_PHY_A_CRS) | (1 << 14));
-	bcm43xx_radio_init2060(bcm);
-
-	if ((bcm->board_vendor == PCI_VENDOR_ID_BROADCOM)
-	    && ((bcm->board_type == 0x0416) || (bcm->board_type == 0x040A))) {
-		if (radio->lofcal == 0xFFFF) {
-			TODO();//TODO: LOF Cal
-			bcm43xx_radio_set_tx_iq(bcm);
-		} else
-			bcm43xx_radio_write16(bcm, 0x001E, radio->lofcal);
-	}
-
-	bcm43xx_phy_write(bcm, 0x007A, 0xF111);
-
-	if (phy->savedpctlreg == 0xFFFF) {
-		bcm43xx_radio_write16(bcm, 0x0019, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0017, 0x0020);
-
-		tval = bcm43xx_ilt_read(bcm, 0x3001);
-		if (phy->rev == 1) {
-			bcm43xx_ilt_write(bcm, 0x3001,
-					  (bcm43xx_ilt_read(bcm, 0x3001) & 0xFF87)
-					  | 0x0058);
-		} else {
-			bcm43xx_ilt_write(bcm, 0x3001,
-					  (bcm43xx_ilt_read(bcm, 0x3001) & 0xFFC3)
-					  | 0x002C);
-		}
-		bcm43xx_dummy_transmission(bcm);
-		phy->savedpctlreg = bcm43xx_phy_read(bcm, BCM43xx_PHY_A_PCTL);
-		bcm43xx_ilt_write(bcm, 0x3001, tval);
-
-		bcm43xx_radio_set_txpower_a(bcm, 0x0018);
-	}
-	bcm43xx_radio_clear_tssi(bcm);
+	bcm43xx_phy_setupg(dev);
+	if (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_PACTRL)
+		bcm43xx_phy_write(dev, 0x046E, 0x03CF);
 }
 
-static void bcm43xx_phy_initb2(struct bcm43xx_private *bcm)
+static void bcm43xx_phy_initb2(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 offset, val;
 
-	bcm43xx_write16(bcm, 0x03EC, 0x3F22);
-	bcm43xx_phy_write(bcm, 0x0020, 0x301C);
-	bcm43xx_phy_write(bcm, 0x0026, 0x0000);
-	bcm43xx_phy_write(bcm, 0x0030, 0x00C6);
-	bcm43xx_phy_write(bcm, 0x0088, 0x3E00);
+	bcm43xx_write16(dev, 0x03EC, 0x3F22);
+	bcm43xx_phy_write(dev, 0x0020, 0x301C);
+	bcm43xx_phy_write(dev, 0x0026, 0x0000);
+	bcm43xx_phy_write(dev, 0x0030, 0x00C6);
+	bcm43xx_phy_write(dev, 0x0088, 0x3E00);
 	val = 0x3C3D;
 	for (offset = 0x0089; offset < 0x00A7; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
+		bcm43xx_phy_write(dev, offset, val);
 		val -= 0x0202;
 	}
-	bcm43xx_phy_write(bcm, 0x03E4, 0x3000);
-	if (radio->channel == 0xFF)
-		bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_BG, 0);
+	bcm43xx_phy_write(dev, 0x03E4, 0x3000);
+	if (phy->channel == 0xFF)
+		bcm43xx_radio_selectchannel(dev,
+					    BCM43xx_RADIO_DEFAULT_CHANNEL_BG,
+					    0);
 	else
-		bcm43xx_radio_selectchannel(bcm, radio->channel, 0);
-	if (radio->version != 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0075, 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0079, 0x0081);
-	}
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
-	if (radio->version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
-		bcm43xx_radio_write16(bcm, 0x007A, 0x000F);
-		bcm43xx_phy_write(bcm, 0x0038, 0x0677);
-		bcm43xx_radio_init2050(bcm);
-	}
-	bcm43xx_phy_write(bcm, 0x0014, 0x0080);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CA);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CC);
-	bcm43xx_phy_write(bcm, 0x0035, 0x07C2);
-	bcm43xx_phy_lo_b_measure(bcm);
-	bcm43xx_phy_write(bcm, 0x0026, 0xCC00);
-	if (radio->version != 0x2050)
-		bcm43xx_phy_write(bcm, 0x0026, 0xCE00);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, 0x1000);
-	bcm43xx_phy_write(bcm, 0x002A, 0x88A3);
-	if (radio->version != 0x2050)
-		bcm43xx_phy_write(bcm, 0x002A, 0x88C2);
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
-	bcm43xx_phy_init_pctl(bcm);
+		bcm43xx_radio_selectchannel(dev, phy->channel, 0);
+	if (phy->radio_ver != 0x2050) {
+		bcm43xx_radio_write16(dev, 0x0075, 0x0080);
+		bcm43xx_radio_write16(dev, 0x0079, 0x0081);
+	}
+	bcm43xx_radio_write16(dev, 0x0050, 0x0020);
+	bcm43xx_radio_write16(dev, 0x0050, 0x0023);
+	if (phy->radio_ver == 0x2050) {
+		bcm43xx_radio_write16(dev, 0x0050, 0x0020);
+		bcm43xx_radio_write16(dev, 0x005A, 0x0070);
+		bcm43xx_radio_write16(dev, 0x005B, 0x007B);
+		bcm43xx_radio_write16(dev, 0x005C, 0x00B0);
+		bcm43xx_radio_write16(dev, 0x007A, 0x000F);
+		bcm43xx_phy_write(dev, 0x0038, 0x0677);
+		bcm43xx_radio_init2050(dev);
+	}
+	bcm43xx_phy_write(dev, 0x0014, 0x0080);
+	bcm43xx_phy_write(dev, 0x0032, 0x00CA);
+	bcm43xx_phy_write(dev, 0x0032, 0x00CC);
+	bcm43xx_phy_write(dev, 0x0035, 0x07C2);
+	bcm43xx_phy_lo_b_measure(dev);
+	bcm43xx_phy_write(dev, 0x0026, 0xCC00);
+	if (phy->radio_ver != 0x2050)
+		bcm43xx_phy_write(dev, 0x0026, 0xCE00);
+	bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL_EXT, 0x1000);
+	bcm43xx_phy_write(dev, 0x002A, 0x88A3);
+	if (phy->radio_ver != 0x2050)
+		bcm43xx_phy_write(dev, 0x002A, 0x88C2);
+	bcm43xx_radio_set_txpower_bg(dev, 0xFFFF, 0xFFFF, 0xFFFF);
+	bcm43xx_phy_init_pctl(dev);
 }
 
-static void bcm43xx_phy_initb4(struct bcm43xx_private *bcm)
+static void bcm43xx_phy_initb4(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 offset, val;
 
-	bcm43xx_write16(bcm, 0x03EC, 0x3F22);
-	bcm43xx_phy_write(bcm, 0x0020, 0x301C);
-	bcm43xx_phy_write(bcm, 0x0026, 0x0000);
-	bcm43xx_phy_write(bcm, 0x0030, 0x00C6);
-	bcm43xx_phy_write(bcm, 0x0088, 0x3E00);
+	bcm43xx_write16(dev, 0x03EC, 0x3F22);
+	bcm43xx_phy_write(dev, 0x0020, 0x301C);
+	bcm43xx_phy_write(dev, 0x0026, 0x0000);
+	bcm43xx_phy_write(dev, 0x0030, 0x00C6);
+	bcm43xx_phy_write(dev, 0x0088, 0x3E00);
 	val = 0x3C3D;
 	for (offset = 0x0089; offset < 0x00A7; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
+		bcm43xx_phy_write(dev, offset, val);
 		val -= 0x0202;
 	}
-	bcm43xx_phy_write(bcm, 0x03E4, 0x3000);
-	if (radio->channel == 0xFF)
-		bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_BG, 0);
+	bcm43xx_phy_write(dev, 0x03E4, 0x3000);
+	if (phy->channel == 0xFF)
+		bcm43xx_radio_selectchannel(dev,
+					    BCM43xx_RADIO_DEFAULT_CHANNEL_BG,
+					    0);
 	else
-		bcm43xx_radio_selectchannel(bcm, radio->channel, 0);
-	if (radio->version != 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0075, 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0079, 0x0081);
-	}
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
-	if (radio->version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
-		bcm43xx_radio_write16(bcm, 0x007A, 0x000F);
-		bcm43xx_phy_write(bcm, 0x0038, 0x0677);
-		bcm43xx_radio_init2050(bcm);
-	}
-	bcm43xx_phy_write(bcm, 0x0014, 0x0080);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CA);
-	if (radio->version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x0032, 0x00E0);
-	bcm43xx_phy_write(bcm, 0x0035, 0x07C2);
-
-	bcm43xx_phy_lo_b_measure(bcm);
-
-	bcm43xx_phy_write(bcm, 0x0026, 0xCC00);
-	if (radio->version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x0026, 0xCE00);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, 0x1100);
-	bcm43xx_phy_write(bcm, 0x002A, 0x88A3);
-	if (radio->version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x002A, 0x88C2);
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
-	if (bcm->sprom.boardflags & BCM43xx_BFL_RSSI) {
-		bcm43xx_calc_nrssi_slope(bcm);
-		bcm43xx_calc_nrssi_threshold(bcm);
+		bcm43xx_radio_selectchannel(dev, phy->channel, 0);
+	if (phy->radio_ver != 0x2050) {
+		bcm43xx_radio_write16(dev, 0x0075, 0x0080);
+		bcm43xx_radio_write16(dev, 0x0079, 0x0081);
+	}
+	bcm43xx_radio_write16(dev, 0x0050, 0x0020);
+	bcm43xx_radio_write16(dev, 0x0050, 0x0023);
+	if (phy->radio_ver == 0x2050) {
+		bcm43xx_radio_write16(dev, 0x0050, 0x0020);
+		bcm43xx_radio_write16(dev, 0x005A, 0x0070);
+		bcm43xx_radio_write16(dev, 0x005B, 0x007B);
+		bcm43xx_radio_write16(dev, 0x005C, 0x00B0);
+		bcm43xx_radio_write16(dev, 0x007A, 0x000F);
+		bcm43xx_phy_write(dev, 0x0038, 0x0677);
+		bcm43xx_radio_init2050(dev);
+	}
+	bcm43xx_phy_write(dev, 0x0014, 0x0080);
+	bcm43xx_phy_write(dev, 0x0032, 0x00CA);
+	if (phy->radio_ver == 0x2050)
+		bcm43xx_phy_write(dev, 0x0032, 0x00E0);
+	bcm43xx_phy_write(dev, 0x0035, 0x07C2);
+
+	bcm43xx_phy_lo_b_measure(dev);
+
+	bcm43xx_phy_write(dev, 0x0026, 0xCC00);
+	if (phy->radio_ver == 0x2050)
+		bcm43xx_phy_write(dev, 0x0026, 0xCE00);
+	bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL_EXT, 0x1100);
+	bcm43xx_phy_write(dev, 0x002A, 0x88A3);
+	if (phy->radio_ver == 0x2050)
+		bcm43xx_phy_write(dev, 0x002A, 0x88C2);
+	bcm43xx_radio_set_txpower_bg(dev, 0xFFFF, 0xFFFF, 0xFFFF);
+	if (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_RSSI) {
+		bcm43xx_calc_nrssi_slope(dev);
+		bcm43xx_calc_nrssi_threshold(dev);
 	}
-	bcm43xx_phy_init_pctl(bcm);
+	bcm43xx_phy_init_pctl(dev);
 }
 
-static void bcm43xx_phy_initb5(struct bcm43xx_private *bcm)
+static void bcm43xx_phy_initb5(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 offset;
 	u16 value;
 	u8 old_channel;
 
 	if (phy->analog == 1)
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A)
+		bcm43xx_radio_write16(dev, 0x007A,
+				      bcm43xx_radio_read16(dev, 0x007A)
 				      | 0x0050);
-	if ((bcm->board_vendor != PCI_VENDOR_ID_BROADCOM) &&
-	    (bcm->board_type != 0x0416)) {
+	if (!is_bcm_board_vendor(dev) &&
+	    (dev->dev->bus->boardinfo.type != 0x0416)) {
 		value = 0x2120;
 		for (offset = 0x00A8 ; offset < 0x00C7; offset++) {
-			bcm43xx_phy_write(bcm, offset, value);
+			bcm43xx_phy_write(dev, offset, value);
 			value += 0x0202;
 		}
 	}
-	bcm43xx_phy_write(bcm, 0x0035,
-			  (bcm43xx_phy_read(bcm, 0x0035) & 0xF0FF)
+	bcm43xx_phy_write(dev, 0x0035,
+			  (bcm43xx_phy_read(dev, 0x0035) & 0xF0FF)
 			  | 0x0700);
-	if (radio->version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x0038, 0x0667);
+	if (phy->radio_ver == 0x2050)
+		bcm43xx_phy_write(dev, 0x0038, 0x0667);
 
-	if (phy->connected) {
-		if (radio->version == 0x2050) {
-			bcm43xx_radio_write16(bcm, 0x007A,
-					      bcm43xx_radio_read16(bcm, 0x007A)
+	if (phy->gmode) {
+		if (phy->radio_ver == 0x2050) {
+			bcm43xx_radio_write16(dev, 0x007A,
+					      bcm43xx_radio_read16(dev, 0x007A)
 					      | 0x0020);
-			bcm43xx_radio_write16(bcm, 0x0051,
-					      bcm43xx_radio_read16(bcm, 0x0051)
+			bcm43xx_radio_write16(dev, 0x0051,
+					      bcm43xx_radio_read16(dev, 0x0051)
 					      | 0x0004);
 		}
-		bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_RADIO, 0x0000);
-
-		bcm43xx_phy_write(bcm, 0x0802, bcm43xx_phy_read(bcm, 0x0802) | 0x0100);
-		bcm43xx_phy_write(bcm, 0x042B, bcm43xx_phy_read(bcm, 0x042B) | 0x2000);
-
-		bcm43xx_phy_write(bcm, 0x001C, 0x186A);
+		bcm43xx_write16(dev, BCM43xx_MMIO_PHY_RADIO, 0x0000);
 
-		bcm43xx_phy_write(bcm, 0x0013, (bcm43xx_phy_read(bcm, 0x0013) & 0x00FF) | 0x1900);
-		bcm43xx_phy_write(bcm, 0x0035, (bcm43xx_phy_read(bcm, 0x0035) & 0xFFC0) | 0x0064);
-		bcm43xx_phy_write(bcm, 0x005D, (bcm43xx_phy_read(bcm, 0x005D) & 0xFF80) | 0x000A);
-	}
-
-	if (bcm->bad_frames_preempt) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD) | (1 << 11));
-	}
+		bcm43xx_phy_write(dev, 0x0802, bcm43xx_phy_read(dev, 0x0802) |
+				  0x0100);
+		bcm43xx_phy_write(dev, 0x042B, bcm43xx_phy_read(dev, 0x042B) |
+				  0x2000);
+
+		bcm43xx_phy_write(dev, 0x001C, 0x186A);
+
+		bcm43xx_phy_write(dev, 0x0013, (bcm43xx_phy_read(dev, 0x0013) &
+				  0x00FF) | 0x1900);
+		bcm43xx_phy_write(dev, 0x0035, (bcm43xx_phy_read(dev, 0x0035) &
+				  0xFFC0) | 0x0064);
+		bcm43xx_phy_write(dev, 0x005D, (bcm43xx_phy_read(dev, 0x005D) &
+				  0xFF80) | 0x000A);
+	}
+
+	if (dev->bad_frames_preempt)
+		bcm43xx_phy_write(dev, BCM43xx_PHY_RADIO_BITFIELD,
+				  bcm43xx_phy_read(dev,
+				  BCM43xx_PHY_RADIO_BITFIELD) | (1 << 11));
 
 	if (phy->analog == 1) {
-		bcm43xx_phy_write(bcm, 0x0026, 0xCE00);
-		bcm43xx_phy_write(bcm, 0x0021, 0x3763);
-		bcm43xx_phy_write(bcm, 0x0022, 0x1BC3);
-		bcm43xx_phy_write(bcm, 0x0023, 0x06F9);
-		bcm43xx_phy_write(bcm, 0x0024, 0x037E);
-	} else
-		bcm43xx_phy_write(bcm, 0x0026, 0xCC00);
-	bcm43xx_phy_write(bcm, 0x0030, 0x00C6);
-	bcm43xx_write16(bcm, 0x03EC, 0x3F22);
+		bcm43xx_phy_write(dev, 0x0026, 0xCE00);
+		bcm43xx_phy_write(dev, 0x0021, 0x3763);
+		bcm43xx_phy_write(dev, 0x0022, 0x1BC3);
+		bcm43xx_phy_write(dev, 0x0023, 0x06F9);
+		bcm43xx_phy_write(dev, 0x0024, 0x037E);
+	} else {
+		bcm43xx_phy_write(dev, 0x0026, 0xCC00);
+	}
+	bcm43xx_phy_write(dev, 0x0030, 0x00C6);
+	bcm43xx_write16(dev, 0x03EC, 0x3F22);
 
 	if (phy->analog == 1)
-		bcm43xx_phy_write(bcm, 0x0020, 0x3E1C);
+		bcm43xx_phy_write(dev, 0x0020, 0x3E1C);
 	else
-		bcm43xx_phy_write(bcm, 0x0020, 0x301C);
+		bcm43xx_phy_write(dev, 0x0020, 0x301C);
 
 	if (phy->analog == 0)
-		bcm43xx_write16(bcm, 0x03E4, 0x3000);
+		bcm43xx_write16(dev, 0x03E4, 0x3000);
 
-	old_channel = radio->channel;
+	old_channel = (phy->channel == 0xFF) ? 1 : phy->channel;
 	/* Force to channel 7, even if not supported. */
-	bcm43xx_radio_selectchannel(bcm, 7, 0);
+	bcm43xx_radio_selectchannel(dev, 7, 0);
 
-	if (radio->version != 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0075, 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0079, 0x0081);
+	if (phy->radio_ver != 0x2050) {
+		bcm43xx_radio_write16(dev, 0x0075, 0x0080);
+		bcm43xx_radio_write16(dev, 0x0079, 0x0081);
 	}
 
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
+	bcm43xx_radio_write16(dev, 0x0050, 0x0020);
+	bcm43xx_radio_write16(dev, 0x0050, 0x0023);
 
-	if (radio->version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
+	if (phy->radio_ver == 0x2050) {
+		bcm43xx_radio_write16(dev, 0x0050, 0x0020);
+		bcm43xx_radio_write16(dev, 0x005A, 0x0070);
 	}
 
-	bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-	bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
+	bcm43xx_radio_write16(dev, 0x005B, 0x007B);
+	bcm43xx_radio_write16(dev, 0x005C, 0x00B0);
 
-	bcm43xx_radio_write16(bcm, 0x007A, bcm43xx_radio_read16(bcm, 0x007A) | 0x0007);
+	bcm43xx_radio_write16(dev, 0x007A, bcm43xx_radio_read16(dev, 0x007A) |
+			      0x0007);
 
-	bcm43xx_radio_selectchannel(bcm, old_channel, 0);
+	bcm43xx_radio_selectchannel(dev, old_channel, 0);
 
-	bcm43xx_phy_write(bcm, 0x0014, 0x0080);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CA);
-	bcm43xx_phy_write(bcm, 0x002A, 0x88A3);
+	bcm43xx_phy_write(dev, 0x0014, 0x0080);
+	bcm43xx_phy_write(dev, 0x0032, 0x00CA);
+	bcm43xx_phy_write(dev, 0x002A, 0x88A3);
 
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
+	bcm43xx_radio_set_txpower_bg(dev, 0xFFFF, 0xFFFF, 0xFFFF);
 
-	if (radio->version == 0x2050)
-		bcm43xx_radio_write16(bcm, 0x005D, 0x000D);
+	if (phy->radio_ver == 0x2050)
+		bcm43xx_radio_write16(dev, 0x005D, 0x000D);
 
-	bcm43xx_write16(bcm, 0x03E4, (bcm43xx_read16(bcm, 0x03E4) & 0xFFC0) | 0x0004);
+	bcm43xx_write16(dev, 0x03E4, (bcm43xx_read16(dev, 0x03E4) & 0xFFC0) |
+			0x0004);
 }
 
-static void bcm43xx_phy_initb6(struct bcm43xx_private *bcm)
+static void bcm43xx_phy_initb6(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 offset, val;
 	u8 old_channel;
 
-	bcm43xx_phy_write(bcm, 0x003E, 0x817A);
-	bcm43xx_radio_write16(bcm, 0x007A,
-	                      (bcm43xx_radio_read16(bcm, 0x007A) | 0x0058));
-	if (radio->revision == 4 ||
-	     radio->revision == 5) {
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0037);
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x0053, 0x00B3);
-		bcm43xx_radio_write16(bcm, 0x0054, 0x009B);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005D, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005E, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x007D, 0x0088);
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
+	bcm43xx_phy_write(dev, 0x003E, 0x817A);
+	bcm43xx_radio_write16(dev, 0x007A,
+			      (bcm43xx_radio_read16(dev, 0x007A) | 0x0058));
+	if (phy->radio_rev == 4 ||
+	     phy->radio_rev == 5) {
+		bcm43xx_radio_write16(dev, 0x0051, 0x0037);
+		bcm43xx_radio_write16(dev, 0x0052, 0x0070);
+		bcm43xx_radio_write16(dev, 0x0053, 0x00B3);
+		bcm43xx_radio_write16(dev, 0x0054, 0x009B);
+		bcm43xx_radio_write16(dev, 0x005A, 0x0088);
+		bcm43xx_radio_write16(dev, 0x005B, 0x0088);
+		bcm43xx_radio_write16(dev, 0x005D, 0x0088);
+		bcm43xx_radio_write16(dev, 0x005E, 0x0088);
+		bcm43xx_radio_write16(dev, 0x007D, 0x0088);
+		bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED,
 				    BCM43xx_UCODEFLAGS_OFFSET,
-				    (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
+				    (bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED,
 				    BCM43xx_UCODEFLAGS_OFFSET)
 				    | 0x00000200));
 	}
-	if (radio->revision == 8) {
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0040);
-		bcm43xx_radio_write16(bcm, 0x0053, 0x00B7);
-		bcm43xx_radio_write16(bcm, 0x0054, 0x0098);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x006B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x000F);
-		if (bcm->sprom.boardflags & 0x8000) {
-			bcm43xx_radio_write16(bcm, 0x005D, 0x00FA);
-			bcm43xx_radio_write16(bcm, 0x005E, 0x00D8);
+	if (phy->radio_rev == 8) {
+		bcm43xx_radio_write16(dev, 0x0051, 0x0000);
+		bcm43xx_radio_write16(dev, 0x0052, 0x0040);
+		bcm43xx_radio_write16(dev, 0x0053, 0x00B7);
+		bcm43xx_radio_write16(dev, 0x0054, 0x0098);
+		bcm43xx_radio_write16(dev, 0x005A, 0x0088);
+		bcm43xx_radio_write16(dev, 0x005B, 0x006B);
+		bcm43xx_radio_write16(dev, 0x005C, 0x000F);
+		if (dev->dev->bus->sprom.r1.boardflags_lo & 0x8000) {
+			bcm43xx_radio_write16(dev, 0x005D, 0x00FA);
+			bcm43xx_radio_write16(dev, 0x005E, 0x00D8);
 		} else {
-			bcm43xx_radio_write16(bcm, 0x005D, 0x00F5);
-			bcm43xx_radio_write16(bcm, 0x005E, 0x00B8);
+			bcm43xx_radio_write16(dev, 0x005D, 0x00F5);
+			bcm43xx_radio_write16(dev, 0x005E, 0x00B8);
 		}
-		bcm43xx_radio_write16(bcm, 0x0073, 0x0003);
-		bcm43xx_radio_write16(bcm, 0x007D, 0x00A8);
-		bcm43xx_radio_write16(bcm, 0x007C, 0x0001);
-		bcm43xx_radio_write16(bcm, 0x007E, 0x0008);
+		bcm43xx_radio_write16(dev, 0x0073, 0x0003);
+		bcm43xx_radio_write16(dev, 0x007D, 0x00A8);
+		bcm43xx_radio_write16(dev, 0x007C, 0x0001);
+		bcm43xx_radio_write16(dev, 0x007E, 0x0008);
 	}
 	val = 0x1E1F;
 	for (offset = 0x0088; offset < 0x0098; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
+		bcm43xx_phy_write(dev, offset, val);
 		val -= 0x0202;
 	}
 	val = 0x3E3F;
 	for (offset = 0x0098; offset < 0x00A8; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
+		bcm43xx_phy_write(dev, offset, val);
 		val -= 0x0202;
 	}
 	val = 0x2120;
 	for (offset = 0x00A8; offset < 0x00C8; offset++) {
-		bcm43xx_phy_write(bcm, offset, (val & 0x3F3F));
+		bcm43xx_phy_write(dev, offset, (val & 0x3F3F));
 		val += 0x0202;
 	}
 	if (phy->type == BCM43xx_PHYTYPE_G) {
-		bcm43xx_radio_write16(bcm, 0x007A,
-		                      bcm43xx_radio_read16(bcm, 0x007A) | 0x0020);
-		bcm43xx_radio_write16(bcm, 0x0051,
-		                      bcm43xx_radio_read16(bcm, 0x0051) | 0x0004);
-		bcm43xx_phy_write(bcm, 0x0802,
-		                  bcm43xx_phy_read(bcm, 0x0802) | 0x0100);
-		bcm43xx_phy_write(bcm, 0x042B,
-		                  bcm43xx_phy_read(bcm, 0x042B) | 0x2000);
-		bcm43xx_phy_write(bcm, 0x5B, 0x0000);
-		bcm43xx_phy_write(bcm, 0x5C, 0x0000);
+		bcm43xx_radio_write16(dev, 0x007A,
+				      bcm43xx_radio_read16(dev, 0x007A) |
+				      0x0020);
+		bcm43xx_radio_write16(dev, 0x0051,
+				      bcm43xx_radio_read16(dev, 0x0051) |
+				      0x0004);
+		bcm43xx_phy_write(dev, 0x0802,
+				  bcm43xx_phy_read(dev, 0x0802) | 0x0100);
+		bcm43xx_phy_write(dev, 0x042B,
+				  bcm43xx_phy_read(dev, 0x042B) | 0x2000);
+		bcm43xx_phy_write(dev, 0x5B, 0x0000);
+		bcm43xx_phy_write(dev, 0x5C, 0x0000);
 	}
 
-	old_channel = radio->channel;
+	old_channel = phy->channel;
 	if (old_channel >= 8)
-		bcm43xx_radio_selectchannel(bcm, 1, 0);
+		bcm43xx_radio_selectchannel(dev, 1, 0);
 	else
-		bcm43xx_radio_selectchannel(bcm, 13, 0);
+		bcm43xx_radio_selectchannel(dev, 13, 0);
 
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
+	bcm43xx_radio_write16(dev, 0x0050, 0x0020);
+	bcm43xx_radio_write16(dev, 0x0050, 0x0023);
 	udelay(40);
-	if (radio->revision < 6 || radio-> revision == 8) {
-		bcm43xx_radio_write16(bcm, 0x007C, (bcm43xx_radio_read16(bcm, 0x007C)
+	if (phy->radio_rev < 6 || phy->radio_rev == 8) {
+		bcm43xx_radio_write16(dev, 0x007C,
+				      (bcm43xx_radio_read16(dev, 0x007C)
 				      | 0x0002));
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
+		bcm43xx_radio_write16(dev, 0x0050, 0x0020);
 	}
-	if (radio->revision <= 2) {
-		bcm43xx_radio_write16(bcm, 0x007C, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
-	}
-	bcm43xx_radio_write16(bcm, 0x007A,
-	                      (bcm43xx_radio_read16(bcm, 0x007A) & 0x00F8) | 0x0007);
-
-	bcm43xx_radio_selectchannel(bcm, old_channel, 0);
-
-	bcm43xx_phy_write(bcm, 0x0014, 0x0200);
-	if (radio->revision >= 6)
-		bcm43xx_phy_write(bcm, 0x002A, 0x88C2);
+	if (phy->radio_rev <= 2) {
+		bcm43xx_radio_write16(dev, 0x007C, 0x0020);
+		bcm43xx_radio_write16(dev, 0x005A, 0x0070);
+		bcm43xx_radio_write16(dev, 0x005B, 0x007B);
+		bcm43xx_radio_write16(dev, 0x005C, 0x00B0);
+	}
+	bcm43xx_radio_write16(dev, 0x007A,
+			      (bcm43xx_radio_read16(dev,
+			      0x007A) & 0x00F8) | 0x0007);
+
+	bcm43xx_radio_selectchannel(dev, old_channel, 0);
+
+	bcm43xx_phy_write(dev, 0x0014, 0x0200);
+	if (phy->radio_rev >= 6)
+		bcm43xx_phy_write(dev, 0x002A, 0x88C2);
 	else
-		bcm43xx_phy_write(bcm, 0x002A, 0x8AC0);
-	bcm43xx_phy_write(bcm, 0x0038, 0x0668);
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
-	if (radio->revision <= 5)
-		bcm43xx_phy_write(bcm, 0x005D, (bcm43xx_phy_read(bcm, 0x005D)
+		bcm43xx_phy_write(dev, 0x002A, 0x8AC0);
+	bcm43xx_phy_write(dev, 0x0038, 0x0668);
+	bcm43xx_radio_set_txpower_bg(dev, 0xFFFF, 0xFFFF, 0xFFFF);
+	if (phy->radio_rev <= 5)
+		bcm43xx_phy_write(dev, 0x005D, (bcm43xx_phy_read(dev, 0x005D)
 			          & 0xFF80) | 0x0003);
-	if (radio->revision <= 2)
-		bcm43xx_radio_write16(bcm, 0x005D, 0x000D);
-	
+	if (phy->radio_rev <= 2)
+		bcm43xx_radio_write16(dev, 0x005D, 0x000D);
+
 	if (phy->analog == 4){
-		bcm43xx_write16(bcm, 0x03E4, 0x0009);
-		bcm43xx_phy_write(bcm, 0x61, bcm43xx_phy_read(bcm, 0x61) & 0xFFF);
+		bcm43xx_write16(dev, 0x03E4, 0x0009);
+		bcm43xx_phy_write(dev, 0x61, bcm43xx_phy_read(dev, 0x61)
+				  & 0xFFF);
 	} else {
-		bcm43xx_phy_write(bcm, 0x0002, (bcm43xx_phy_read(bcm, 0x0002) & 0xFFC0) | 0x0004);
+		bcm43xx_phy_write(dev, 0x0002, (bcm43xx_phy_read(dev, 0x0002)
+				  & 0xFFC0) | 0x0004);
 	}
 	if (phy->type == BCM43xx_PHYTYPE_G)
-		bcm43xx_write16(bcm, 0x03E6, 0x0);
+		bcm43xx_write16(dev, 0x03E6, 0x0);
 	if (phy->type == BCM43xx_PHYTYPE_B) {
-		bcm43xx_write16(bcm, 0x03E6, 0x8140);
-		bcm43xx_phy_write(bcm, 0x0016, 0x0410);
-		bcm43xx_phy_write(bcm, 0x0017, 0x0820);
-		bcm43xx_phy_write(bcm, 0x0062, 0x0007);
-		bcm43xx_radio_init2050(bcm);
-		bcm43xx_phy_lo_g_measure(bcm);
-		if (bcm->sprom.boardflags & BCM43xx_BFL_RSSI) {
-			bcm43xx_calc_nrssi_slope(bcm);
-			bcm43xx_calc_nrssi_threshold(bcm);
+		bcm43xx_write16(dev, 0x03E6, 0x8140);
+		bcm43xx_phy_write(dev, 0x0016, 0x0410);
+		bcm43xx_phy_write(dev, 0x0017, 0x0820);
+		bcm43xx_phy_write(dev, 0x0062, 0x0007);
+		bcm43xx_radio_init2050(dev);
+		bcm43xx_phy_lo_g_measure(dev);
+		if (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_RSSI) {
+			bcm43xx_calc_nrssi_slope(dev);
+			bcm43xx_calc_nrssi_threshold(dev);
 		}
-		bcm43xx_phy_init_pctl(bcm);
+		bcm43xx_phy_init_pctl(dev);
 	}
 }
 
-static void bcm43xx_calc_loopback_gain(struct bcm43xx_private *bcm)
+static void bcm43xx_calc_loopback_gain(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 backup_phy[15] = {0};
 	u16 backup_radio[3];
 	u16 backup_bband;
@@ -990,139 +816,140 @@ static void bcm43xx_calc_loopback_gain(s
 	u16 loop1_cnt, loop1_done, loop1_omitted;
 	u16 loop2_done;
 
-	backup_phy[0] = bcm43xx_phy_read(bcm, 0x0429);
-	backup_phy[1] = bcm43xx_phy_read(bcm, 0x0001);
-	backup_phy[2] = bcm43xx_phy_read(bcm, 0x0811);
-	backup_phy[3] = bcm43xx_phy_read(bcm, 0x0812);
+	backup_phy[0] = bcm43xx_phy_read(dev, 0x0429);
+	backup_phy[1] = bcm43xx_phy_read(dev, 0x0001);
+	backup_phy[2] = bcm43xx_phy_read(dev, 0x0811);
+	backup_phy[3] = bcm43xx_phy_read(dev, 0x0812);
 	if (phy->rev != 1) {
-		backup_phy[4] = bcm43xx_phy_read(bcm, 0x0814);
-		backup_phy[5] = bcm43xx_phy_read(bcm, 0x0815);
+		backup_phy[4] = bcm43xx_phy_read(dev, 0x0814);
+		backup_phy[5] = bcm43xx_phy_read(dev, 0x0815);
 	}
-	backup_phy[6] = bcm43xx_phy_read(bcm, 0x005A);
-	backup_phy[7] = bcm43xx_phy_read(bcm, 0x0059);
-	backup_phy[8] = bcm43xx_phy_read(bcm, 0x0058);
-	backup_phy[9] = bcm43xx_phy_read(bcm, 0x000A);
-	backup_phy[10] = bcm43xx_phy_read(bcm, 0x0003);
-	backup_phy[11] = bcm43xx_phy_read(bcm, 0x080F);
-	backup_phy[12] = bcm43xx_phy_read(bcm, 0x0810);
-	backup_phy[13] = bcm43xx_phy_read(bcm, 0x002B);
-	backup_phy[14] = bcm43xx_phy_read(bcm, 0x0015);
-	bcm43xx_phy_read(bcm, 0x002D); /* dummy read */
-	backup_bband = radio->baseband_atten;
-	backup_radio[0] = bcm43xx_radio_read16(bcm, 0x0052);
-	backup_radio[1] = bcm43xx_radio_read16(bcm, 0x0043);
-	backup_radio[2] = bcm43xx_radio_read16(bcm, 0x007A);
-
-	bcm43xx_phy_write(bcm, 0x0429,
-			  bcm43xx_phy_read(bcm, 0x0429) & 0x3FFF);
-	bcm43xx_phy_write(bcm, 0x0001,
-			  bcm43xx_phy_read(bcm, 0x0001) & 0x8000);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x0002);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) & 0xFFFD);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x0001);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) & 0xFFFE);
+	backup_phy[6] = bcm43xx_phy_read(dev, 0x005A);
+	backup_phy[7] = bcm43xx_phy_read(dev, 0x0059);
+	backup_phy[8] = bcm43xx_phy_read(dev, 0x0058);
+	backup_phy[9] = bcm43xx_phy_read(dev, 0x000A);
+	backup_phy[10] = bcm43xx_phy_read(dev, 0x0003);
+	backup_phy[11] = bcm43xx_phy_read(dev, 0x080F);
+	backup_phy[12] = bcm43xx_phy_read(dev, 0x0810);
+	backup_phy[13] = bcm43xx_phy_read(dev, 0x002B);
+	backup_phy[14] = bcm43xx_phy_read(dev, 0x0015);
+	bcm43xx_phy_read(dev, 0x002D); /* dummy read */
+	backup_bband = phy->bbatt;
+	backup_radio[0] = bcm43xx_radio_read16(dev, 0x0052);
+	backup_radio[1] = bcm43xx_radio_read16(dev, 0x0043);
+	backup_radio[2] = bcm43xx_radio_read16(dev, 0x007A);
+
+	bcm43xx_phy_write(dev, 0x0429,
+			  bcm43xx_phy_read(dev, 0x0429) & 0x3FFF);
+	bcm43xx_phy_write(dev, 0x0001,
+			  bcm43xx_phy_read(dev, 0x0001) & 0x8000);
+	bcm43xx_phy_write(dev, 0x0811,
+			  bcm43xx_phy_read(dev, 0x0811) | 0x0002);
+	bcm43xx_phy_write(dev, 0x0812,
+			  bcm43xx_phy_read(dev, 0x0812) & 0xFFFD);
+	bcm43xx_phy_write(dev, 0x0811,
+			  bcm43xx_phy_read(dev, 0x0811) | 0x0001);
+	bcm43xx_phy_write(dev, 0x0812,
+			  bcm43xx_phy_read(dev, 0x0812) & 0xFFFE);
 	if (phy->rev != 1) {
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0001);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) & 0xFFFE);
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0002);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) & 0xFFFD);
-	}
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x000C);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) | 0x000C);
+		bcm43xx_phy_write(dev, 0x0814,
+				  bcm43xx_phy_read(dev, 0x0814) | 0x0001);
+		bcm43xx_phy_write(dev, 0x0815,
+				  bcm43xx_phy_read(dev, 0x0815) & 0xFFFE);
+		bcm43xx_phy_write(dev, 0x0814,
+				  bcm43xx_phy_read(dev, 0x0814) | 0x0002);
+		bcm43xx_phy_write(dev, 0x0815,
+				  bcm43xx_phy_read(dev, 0x0815) & 0xFFFD);
+	}
+	bcm43xx_phy_write(dev, 0x0811,
+			  bcm43xx_phy_read(dev, 0x0811) | 0x000C);
+	bcm43xx_phy_write(dev, 0x0812,
+			  bcm43xx_phy_read(dev, 0x0812) | 0x000C);
 
-	bcm43xx_phy_write(bcm, 0x0811,
-			  (bcm43xx_phy_read(bcm, 0x0811)
+	bcm43xx_phy_write(dev, 0x0811,
+			  (bcm43xx_phy_read(dev, 0x0811)
 			   & 0xFFCF) | 0x0030);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  (bcm43xx_phy_read(bcm, 0x0812)
+	bcm43xx_phy_write(dev, 0x0812,
+			  (bcm43xx_phy_read(dev, 0x0812)
 			   & 0xFFCF) | 0x0010);
 
-	bcm43xx_phy_write(bcm, 0x005A, 0x0780);
-	bcm43xx_phy_write(bcm, 0x0059, 0xC810);
-	bcm43xx_phy_write(bcm, 0x0058, 0x000D);
+	bcm43xx_phy_write(dev, 0x005A, 0x0780);
+	bcm43xx_phy_write(dev, 0x0059, 0xC810);
+	bcm43xx_phy_write(dev, 0x0058, 0x000D);
 	if (phy->analog == 0) {
-		bcm43xx_phy_write(bcm, 0x0003, 0x0122);
+		bcm43xx_phy_write(dev, 0x0003, 0x0122);
 	} else {
-		bcm43xx_phy_write(bcm, 0x000A,
-				  bcm43xx_phy_read(bcm, 0x000A)
+		bcm43xx_phy_write(dev, 0x000A,
+				  bcm43xx_phy_read(dev, 0x000A)
 				  | 0x2000);
 	}
 	if (phy->rev != 1) {
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0004);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) & 0xFFFB);
+		bcm43xx_phy_write(dev, 0x0814,
+				  bcm43xx_phy_read(dev, 0x0814) | 0x0004);
+		bcm43xx_phy_write(dev, 0x0815,
+				  bcm43xx_phy_read(dev, 0x0815) & 0xFFFB);
 	}
-	bcm43xx_phy_write(bcm, 0x0003,
-			  (bcm43xx_phy_read(bcm, 0x0003)
+	bcm43xx_phy_write(dev, 0x0003,
+			  (bcm43xx_phy_read(dev, 0x0003)
 			   & 0xFF9F) | 0x0040);
-	if (radio->version == 0x2050 && radio->revision == 2) {
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      (bcm43xx_radio_read16(bcm, 0x0043)
+	if (phy->radio_ver == 0x2050 && phy->radio_rev == 2) {
+		bcm43xx_radio_write16(dev, 0x0052, 0x0000);
+		bcm43xx_radio_write16(dev, 0x0043,
+				      (bcm43xx_radio_read16(dev, 0x0043)
 				       & 0xFFF0) | 0x0009);
 		loop1_cnt = 9;
-	} else if (radio->revision == 8) {
-		bcm43xx_radio_write16(bcm, 0x0043, 0x000F);
+	} else if (phy->radio_rev == 8) {
+		bcm43xx_radio_write16(dev, 0x0043, 0x000F);
 		loop1_cnt = 15;
-	} else
+	} else {
 		loop1_cnt = 0;
+	}
 
-	bcm43xx_phy_set_baseband_attenuation(bcm, 11);
+	bcm43xx_phy_set_baseband_attenuation(dev, 11);
 
 	if (phy->rev >= 3)
-		bcm43xx_phy_write(bcm, 0x080F, 0xC020);
+		bcm43xx_phy_write(dev, 0x080F, 0xC020);
 	else
-		bcm43xx_phy_write(bcm, 0x080F, 0x8020);
-	bcm43xx_phy_write(bcm, 0x0810, 0x0000);
+		bcm43xx_phy_write(dev, 0x080F, 0x8020);
+	bcm43xx_phy_write(dev, 0x0810, 0x0000);
 
-	bcm43xx_phy_write(bcm, 0x002B,
-			  (bcm43xx_phy_read(bcm, 0x002B)
+	bcm43xx_phy_write(dev, 0x002B,
+			  (bcm43xx_phy_read(dev, 0x002B)
 			   & 0xFFC0) | 0x0001);
-	bcm43xx_phy_write(bcm, 0x002B,
-			  (bcm43xx_phy_read(bcm, 0x002B)
+	bcm43xx_phy_write(dev, 0x002B,
+			  (bcm43xx_phy_read(dev, 0x002B)
 			   & 0xC0FF) | 0x0800);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x0100);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) & 0xCFFF);
-	if (bcm->sprom.boardflags & BCM43xx_BFL_EXTLNA) {
+	bcm43xx_phy_write(dev, 0x0811,
+			  bcm43xx_phy_read(dev, 0x0811) | 0x0100);
+	bcm43xx_phy_write(dev, 0x0812,
+			  bcm43xx_phy_read(dev, 0x0812) & 0xCFFF);
+	if (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_EXTLNA) {
 		if (phy->rev >= 7) {
-			bcm43xx_phy_write(bcm, 0x0811,
-					  bcm43xx_phy_read(bcm, 0x0811)
+			bcm43xx_phy_write(dev, 0x0811,
+					  bcm43xx_phy_read(dev, 0x0811)
 					  | 0x0800);
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_phy_read(bcm, 0x0812)
+			bcm43xx_phy_write(dev, 0x0812,
+					  bcm43xx_phy_read(dev, 0x0812)
 					  | 0x8000);
 		}
 	}
-	bcm43xx_radio_write16(bcm, 0x007A,
-			      bcm43xx_radio_read16(bcm, 0x007A)
+	bcm43xx_radio_write16(dev, 0x007A,
+			      bcm43xx_radio_read16(dev, 0x007A)
 			      & 0x00F7);
 
 	for (i = 0; i < loop1_cnt; i++) {
-		bcm43xx_radio_write16(bcm, 0x0043, loop1_cnt);
-		bcm43xx_phy_write(bcm, 0x0812,
-				  (bcm43xx_phy_read(bcm, 0x0812)
+		bcm43xx_radio_write16(dev, 0x0043, loop1_cnt);
+		bcm43xx_phy_write(dev, 0x0812,
+				  (bcm43xx_phy_read(dev, 0x0812)
 				   & 0xF0FF) | (i << 8));
-		bcm43xx_phy_write(bcm, 0x0015,
-				  (bcm43xx_phy_read(bcm, 0x0015)
+		bcm43xx_phy_write(dev, 0x0015,
+				  (bcm43xx_phy_read(dev, 0x0015)
 				   & 0x0FFF) | 0xA000);
-		bcm43xx_phy_write(bcm, 0x0015,
-				  (bcm43xx_phy_read(bcm, 0x0015)
+		bcm43xx_phy_write(dev, 0x0015,
+				  (bcm43xx_phy_read(dev, 0x0015)
 				   & 0x0FFF) | 0xF000);
 		udelay(20);
-		if (bcm43xx_phy_read(bcm, 0x002D) >= 0x0DFC)
+		if (bcm43xx_phy_read(dev, 0x002D) >= 0x0DFC)
 			break;
 	}
 	loop1_done = i;
@@ -1130,166 +957,167 @@ static void bcm43xx_calc_loopback_gain(s
 
 	loop2_done = 0;
 	if (loop1_done >= 8) {
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_phy_read(bcm, 0x0812)
+		bcm43xx_phy_write(dev, 0x0812,
+				  bcm43xx_phy_read(dev, 0x0812)
 				  | 0x0030);
 		for (i = loop1_done - 8; i < 16; i++) {
-			bcm43xx_phy_write(bcm, 0x0812,
-					  (bcm43xx_phy_read(bcm, 0x0812)
+			bcm43xx_phy_write(dev, 0x0812,
+					  (bcm43xx_phy_read(dev, 0x0812)
 					   & 0xF0FF) | (i << 8));
-			bcm43xx_phy_write(bcm, 0x0015,
-					  (bcm43xx_phy_read(bcm, 0x0015)
+			bcm43xx_phy_write(dev, 0x0015,
+					  (bcm43xx_phy_read(dev, 0x0015)
 					   & 0x0FFF) | 0xA000);
-			bcm43xx_phy_write(bcm, 0x0015,
-					  (bcm43xx_phy_read(bcm, 0x0015)
+			bcm43xx_phy_write(dev, 0x0015,
+					  (bcm43xx_phy_read(dev, 0x0015)
 					   & 0x0FFF) | 0xF000);
 			udelay(20);
-			if (bcm43xx_phy_read(bcm, 0x002D) >= 0x0DFC)
+			if (bcm43xx_phy_read(dev, 0x002D) >= 0x0DFC)
 				break;
 		}
 	}
 
 	if (phy->rev != 1) {
-		bcm43xx_phy_write(bcm, 0x0814, backup_phy[4]);
-		bcm43xx_phy_write(bcm, 0x0815, backup_phy[5]);
+		bcm43xx_phy_write(dev, 0x0814, backup_phy[4]);
+		bcm43xx_phy_write(dev, 0x0815, backup_phy[5]);
 	}
-	bcm43xx_phy_write(bcm, 0x005A, backup_phy[6]);
-	bcm43xx_phy_write(bcm, 0x0059, backup_phy[7]);
-	bcm43xx_phy_write(bcm, 0x0058, backup_phy[8]);
-	bcm43xx_phy_write(bcm, 0x000A, backup_phy[9]);
-	bcm43xx_phy_write(bcm, 0x0003, backup_phy[10]);
-	bcm43xx_phy_write(bcm, 0x080F, backup_phy[11]);
-	bcm43xx_phy_write(bcm, 0x0810, backup_phy[12]);
-	bcm43xx_phy_write(bcm, 0x002B, backup_phy[13]);
-	bcm43xx_phy_write(bcm, 0x0015, backup_phy[14]);
-
-	bcm43xx_phy_set_baseband_attenuation(bcm, backup_bband);
-
-	bcm43xx_radio_write16(bcm, 0x0052, backup_radio[0]);
-	bcm43xx_radio_write16(bcm, 0x0043, backup_radio[1]);
-	bcm43xx_radio_write16(bcm, 0x007A, backup_radio[2]);
+	bcm43xx_phy_write(dev, 0x005A, backup_phy[6]);
+	bcm43xx_phy_write(dev, 0x0059, backup_phy[7]);
+	bcm43xx_phy_write(dev, 0x0058, backup_phy[8]);
+	bcm43xx_phy_write(dev, 0x000A, backup_phy[9]);
+	bcm43xx_phy_write(dev, 0x0003, backup_phy[10]);
+	bcm43xx_phy_write(dev, 0x080F, backup_phy[11]);
+	bcm43xx_phy_write(dev, 0x0810, backup_phy[12]);
+	bcm43xx_phy_write(dev, 0x002B, backup_phy[13]);
+	bcm43xx_phy_write(dev, 0x0015, backup_phy[14]);
+
+	bcm43xx_phy_set_baseband_attenuation(dev, backup_bband);
+
+	bcm43xx_radio_write16(dev, 0x0052, backup_radio[0]);
+	bcm43xx_radio_write16(dev, 0x0043, backup_radio[1]);
+	bcm43xx_radio_write16(dev, 0x007A, backup_radio[2]);
 
-	bcm43xx_phy_write(bcm, 0x0811, backup_phy[2] | 0x0003);
+	bcm43xx_phy_write(dev, 0x0811, backup_phy[2] | 0x0003);
 	udelay(10);
-	bcm43xx_phy_write(bcm, 0x0811, backup_phy[2]);
-	bcm43xx_phy_write(bcm, 0x0812, backup_phy[3]);
-	bcm43xx_phy_write(bcm, 0x0429, backup_phy[0]);
-	bcm43xx_phy_write(bcm, 0x0001, backup_phy[1]);
+	bcm43xx_phy_write(dev, 0x0811, backup_phy[2]);
+	bcm43xx_phy_write(dev, 0x0812, backup_phy[3]);
+	bcm43xx_phy_write(dev, 0x0429, backup_phy[0]);
+	bcm43xx_phy_write(dev, 0x0001, backup_phy[1]);
 
 	phy->loopback_gain[0] = ((loop1_done * 6) - (loop1_omitted * 4)) - 11;
 	phy->loopback_gain[1] = (24 - (3 * loop2_done)) * 2;
 }
 
-static void bcm43xx_phy_initg(struct bcm43xx_private *bcm)
+static void bcm43xx_phy_initg(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 tmp;
 
 	if (phy->rev == 1)
-		bcm43xx_phy_initb5(bcm);
+		bcm43xx_phy_initb5(dev);
 	else
-		bcm43xx_phy_initb6(bcm);
-	if (phy->rev >= 2 || phy->connected)
-		bcm43xx_phy_inita(bcm);
+		bcm43xx_phy_initb6(dev);
+	if (phy->rev >= 2 || phy->gmode)
+		bcm43xx_phy_inita(dev);
 
 	if (phy->rev >= 2) {
-		bcm43xx_phy_write(bcm, 0x0814, 0x0000);
-		bcm43xx_phy_write(bcm, 0x0815, 0x0000);
+		bcm43xx_phy_write(dev, 0x0814, 0x0000);
+		bcm43xx_phy_write(dev, 0x0815, 0x0000);
 	}
 	if (phy->rev == 2) {
-		bcm43xx_phy_write(bcm, 0x0811, 0x0000);
-		bcm43xx_phy_write(bcm, 0x0015, 0x00C0);
+		bcm43xx_phy_write(dev, 0x0811, 0x0000);
+		bcm43xx_phy_write(dev, 0x0015, 0x00C0);
 	}
 	if (phy->rev > 5) {
-		bcm43xx_phy_write(bcm, 0x0811, 0x0400);
-		bcm43xx_phy_write(bcm, 0x0015, 0x00C0);
+		bcm43xx_phy_write(dev, 0x0811, 0x0400);
+		bcm43xx_phy_write(dev, 0x0015, 0x00C0);
 	}
-	if (phy->rev >= 2 && phy->connected) {
-		tmp = bcm43xx_phy_read(bcm, 0x0400) & 0xFF;
+	if (phy->rev >= 2 && phy->gmode) {
+		tmp = bcm43xx_phy_read(dev, 0x0400) & 0xFF;
 		if (tmp ==3 || tmp == 5) {
-			bcm43xx_phy_write(bcm, 0x04C2, 0x1816);
-			bcm43xx_phy_write(bcm, 0x04C3, 0x8006);
+			bcm43xx_phy_write(dev, 0x04C2, 0x1816);
+			bcm43xx_phy_write(dev, 0x04C3, 0x8006);
 			if (tmp == 5) {
-				bcm43xx_phy_write(bcm, 0x04CC,
-						  (bcm43xx_phy_read(bcm, 0x04CC)
+				bcm43xx_phy_write(dev, 0x04CC,
+						  (bcm43xx_phy_read(dev, 0x04CC)
 						   & 0x00FF) | 0x1F00);
 			}
 		}
-		bcm43xx_phy_write(bcm, 0x047E, 0x0078);
+		bcm43xx_phy_write(dev, 0x047E, 0x0078);
 	}
-	if (radio->revision == 8) {
-		bcm43xx_phy_write(bcm, 0x0801, bcm43xx_phy_read(bcm, 0x0801) | 0x0080);
-		bcm43xx_phy_write(bcm, 0x043E, bcm43xx_phy_read(bcm, 0x043E) | 0x0004);
-	}
-	if (phy->rev >= 2 && phy->connected)
-		bcm43xx_calc_loopback_gain(bcm);
-	if (radio->revision != 8) {
-		if (radio->initval == 0xFFFF)
-			radio->initval = bcm43xx_radio_init2050(bcm);
+	if (phy->radio_rev == 8) {
+		bcm43xx_phy_write(dev, 0x0801, bcm43xx_phy_read(dev, 0x0801)
+				  | 0x0080);
+		bcm43xx_phy_write(dev, 0x043E, bcm43xx_phy_read(dev, 0x043E)
+				  | 0x0004);
+	}
+	if (phy->rev >= 2 && phy->gmode)
+		bcm43xx_calc_loopback_gain(dev);
+	if (phy->radio_rev != 8) {
+		if (phy->initval == 0xFFFF)
+			phy->initval = bcm43xx_radio_init2050(dev);
 		else
-			bcm43xx_radio_write16(bcm, 0x0078, radio->initval);
+			bcm43xx_radio_write16(dev, 0x0078, phy->initval);
 	}
-	if (radio->txctl2 == 0xFFFF) {
-		bcm43xx_phy_lo_g_measure(bcm);
+	if (phy->txctl2 == 0xFFFF) {
+		bcm43xx_phy_lo_g_measure(dev);
 	} else {
-		if (radio->version == 0x2050 && radio->revision == 8) {
-			bcm43xx_radio_write16(bcm, 0x0052,
-					      (radio->txctl1 << 4) | radio->txctl2);
-		} else {
-			bcm43xx_radio_write16(bcm, 0x0052,
-					      (bcm43xx_radio_read16(bcm, 0x0052)
-					       & 0xFFF0) | radio->txctl1);
-		}
+		if (phy->radio_ver == 0x2050 && phy->radio_rev == 8)
+			bcm43xx_radio_write16(dev, 0x0052,
+					      (phy->txctl1 << 4) | phy->txctl2);
+		else
+			bcm43xx_radio_write16(dev, 0x0052,
+					      (bcm43xx_radio_read16(dev, 0x0052)
+					       & 0xFFF0) | phy->txctl1);
 		if (phy->rev >= 6) {
-			bcm43xx_phy_write(bcm, 0x0036,
-					  (bcm43xx_phy_read(bcm, 0x0036)
-					   & 0x0FFF) | (radio->txctl2 << 12));
+			bcm43xx_phy_write(dev, 0x0036,
+					  (bcm43xx_phy_read(dev, 0x0036)
+					   & 0x0FFF) | (phy->txctl2 << 12));
 		}
-		if (bcm->sprom.boardflags & BCM43xx_BFL_PACTRL)
-			bcm43xx_phy_write(bcm, 0x002E, 0x8075);
+		if (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_PACTRL)
+			bcm43xx_phy_write(dev, 0x002E, 0x8075);
 		else
-			bcm43xx_phy_write(bcm, 0x002E, 0x807F);
+			bcm43xx_phy_write(dev, 0x002E, 0x807F);
 		if (phy->rev < 2)
-			bcm43xx_phy_write(bcm, 0x002F, 0x0101);
+			bcm43xx_phy_write(dev, 0x002F, 0x0101);
 		else
-			bcm43xx_phy_write(bcm, 0x002F, 0x0202);
+			bcm43xx_phy_write(dev, 0x002F, 0x0202);
 	}
-	if (phy->connected || phy->rev >= 2) {
-		bcm43xx_phy_lo_adjust(bcm, 0);
-		bcm43xx_phy_write(bcm, 0x080F, 0x8078);
+	if (phy->gmode || phy->rev >= 2) {
+		bcm43xx_phy_lo_adjust(dev, 0);
+		bcm43xx_phy_write(dev, 0x080F, 0x8078);
 	}
 
-	if (!(bcm->sprom.boardflags & BCM43xx_BFL_RSSI)) {
+	if (!(dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_RSSI)) {
 		/* The specs state to update the NRSSI LT with
 		 * the value 0x7FFFFFFF here. I think that is some weird
 		 * compiler optimization in the original driver.
 		 * Essentially, what we do here is resetting all NRSSI LT
 		 * entries to -32 (see the limit_value() in nrssi_hw_update())
 		 */
-		bcm43xx_nrssi_hw_update(bcm, 0xFFFF);
-		bcm43xx_calc_nrssi_threshold(bcm);
-	} else if (phy->connected || phy->rev >= 2) {
-		if (radio->nrssi[0] == -1000) {
-			assert(radio->nrssi[1] == -1000);
-			bcm43xx_calc_nrssi_slope(bcm);
+		bcm43xx_nrssi_hw_update(dev, 0xFFFF);
+		bcm43xx_calc_nrssi_threshold(dev);
+	} else if (phy->gmode || phy->rev >= 2) {
+		if (phy->nrssi[0] == -1000) {
+			BCM43xx_WARN_ON(phy->nrssi[1] != -1000);
+			bcm43xx_calc_nrssi_slope(dev);
 		} else {
-			assert(radio->nrssi[1] != -1000);
-			bcm43xx_calc_nrssi_threshold(bcm);
+			BCM43xx_WARN_ON(phy->nrssi[1] == -1000);
+			bcm43xx_calc_nrssi_threshold(dev);
 		}
 	}
-	if (radio->revision == 8)
-		bcm43xx_phy_write(bcm, 0x0805, 0x3230);
-	bcm43xx_phy_init_pctl(bcm);
-	if (bcm->chip_id == 0x4306 && bcm->chip_package == 2) {
-		bcm43xx_phy_write(bcm, 0x0429,
-				  bcm43xx_phy_read(bcm, 0x0429) & 0xBFFF);
-		bcm43xx_phy_write(bcm, 0x04C3,
-				  bcm43xx_phy_read(bcm, 0x04C3) & 0x7FFF);
+	if (phy->radio_rev == 8)
+		bcm43xx_phy_write(dev, 0x0805, 0x3230);
+	bcm43xx_phy_init_pctl(dev);
+	if (dev->dev->bus->chip_id == 0x4306
+	    && dev->dev->bus->chip_package == 2) {
+		bcm43xx_phy_write(dev, 0x0429,
+				  bcm43xx_phy_read(dev, 0x0429) & 0xBFFF);
+		bcm43xx_phy_write(dev, 0x04C3,
+				  bcm43xx_phy_read(dev, 0x04C3) & 0x7FFF);
 	}
 }
 
-static u16 bcm43xx_phy_lo_b_r15_loop(struct bcm43xx_private *bcm)
+static u16 bcm43xx_phy_lo_b_r15_loop(struct bcm43xx_wldev *dev)
 {
 	int i;
 	u16 ret = 0;
@@ -1297,13 +1125,13 @@ static u16 bcm43xx_phy_lo_b_r15_loop(str
 
 	local_irq_save(flags);
 	for (i = 0; i < 10; i++){
-		bcm43xx_phy_write(bcm, 0x0015, 0xAFA0);
+		bcm43xx_phy_write(dev, 0x0015, 0xAFA0);
 		udelay(1);
-		bcm43xx_phy_write(bcm, 0x0015, 0xEFA0);
+		bcm43xx_phy_write(dev, 0x0015, 0xEFA0);
 		udelay(10);
-		bcm43xx_phy_write(bcm, 0x0015, 0xFFA0);
+		bcm43xx_phy_write(dev, 0x0015, 0xFFA0);
 		udelay(40);
-		ret += bcm43xx_phy_read(bcm, 0x002C);
+		ret += bcm43xx_phy_read(dev, 0x002C);
 	}
 	local_irq_restore(flags);
 	bcm43xx_voluntary_preempt();
@@ -1311,59 +1139,58 @@ static u16 bcm43xx_phy_lo_b_r15_loop(str
 	return ret;
 }
 
-void bcm43xx_phy_lo_b_measure(struct bcm43xx_private *bcm)
+void bcm43xx_phy_lo_b_measure(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 regstack[12] = { 0 };
 	u16 mls;
 	u16 fval;
 	int i, j;
 
-	regstack[0] = bcm43xx_phy_read(bcm, 0x0015);
-	regstack[1] = bcm43xx_radio_read16(bcm, 0x0052) & 0xFFF0;
+	regstack[0] = bcm43xx_phy_read(dev, 0x0015);
+	regstack[1] = bcm43xx_radio_read16(dev, 0x0052) & 0xFFF0;
 
-	if (radio->version == 0x2053) {
-		regstack[2] = bcm43xx_phy_read(bcm, 0x000A);
-		regstack[3] = bcm43xx_phy_read(bcm, 0x002A);
-		regstack[4] = bcm43xx_phy_read(bcm, 0x0035);
-		regstack[5] = bcm43xx_phy_read(bcm, 0x0003);
-		regstack[6] = bcm43xx_phy_read(bcm, 0x0001);
-		regstack[7] = bcm43xx_phy_read(bcm, 0x0030);
-
-		regstack[8] = bcm43xx_radio_read16(bcm, 0x0043);
-		regstack[9] = bcm43xx_radio_read16(bcm, 0x007A);
-		regstack[10] = bcm43xx_read16(bcm, 0x03EC);
-		regstack[11] = bcm43xx_radio_read16(bcm, 0x0052) & 0x00F0;
-
-		bcm43xx_phy_write(bcm, 0x0030, 0x00FF);
-		bcm43xx_write16(bcm, 0x03EC, 0x3F3F);
-		bcm43xx_phy_write(bcm, 0x0035, regstack[4] & 0xFF7F);
-		bcm43xx_radio_write16(bcm, 0x007A, regstack[9] & 0xFFF0);
-	}
-	bcm43xx_phy_write(bcm, 0x0015, 0xB000);
-	bcm43xx_phy_write(bcm, 0x002B, 0x0004);
-
-	if (radio->version == 0x2053) {
-		bcm43xx_phy_write(bcm, 0x002B, 0x0203);
-		bcm43xx_phy_write(bcm, 0x002A, 0x08A3);
+	if (phy->radio_ver == 0x2053) {
+		regstack[2] = bcm43xx_phy_read(dev, 0x000A);
+		regstack[3] = bcm43xx_phy_read(dev, 0x002A);
+		regstack[4] = bcm43xx_phy_read(dev, 0x0035);
+		regstack[5] = bcm43xx_phy_read(dev, 0x0003);
+		regstack[6] = bcm43xx_phy_read(dev, 0x0001);
+		regstack[7] = bcm43xx_phy_read(dev, 0x0030);
+
+		regstack[8] = bcm43xx_radio_read16(dev, 0x0043);
+		regstack[9] = bcm43xx_radio_read16(dev, 0x007A);
+		regstack[10] = bcm43xx_read16(dev, 0x03EC);
+		regstack[11] = bcm43xx_radio_read16(dev, 0x0052) & 0x00F0;
+
+		bcm43xx_phy_write(dev, 0x0030, 0x00FF);
+		bcm43xx_write16(dev, 0x03EC, 0x3F3F);
+		bcm43xx_phy_write(dev, 0x0035, regstack[4] & 0xFF7F);
+		bcm43xx_radio_write16(dev, 0x007A, regstack[9] & 0xFFF0);
+	}
+	bcm43xx_phy_write(dev, 0x0015, 0xB000);
+	bcm43xx_phy_write(dev, 0x002B, 0x0004);
+
+	if (phy->radio_ver == 0x2053) {
+		bcm43xx_phy_write(dev, 0x002B, 0x0203);
+		bcm43xx_phy_write(dev, 0x002A, 0x08A3);
 	}
 
 	phy->minlowsig[0] = 0xFFFF;
 
 	for (i = 0; i < 4; i++) {
-		bcm43xx_radio_write16(bcm, 0x0052, regstack[1] | i);
-		bcm43xx_phy_lo_b_r15_loop(bcm);
+		bcm43xx_radio_write16(dev, 0x0052, regstack[1] | i);
+		bcm43xx_phy_lo_b_r15_loop(dev);
 	}
 	for (i = 0; i < 10; i++) {
-		bcm43xx_radio_write16(bcm, 0x0052, regstack[1] | i);
-		mls = bcm43xx_phy_lo_b_r15_loop(bcm) / 10;
+		bcm43xx_radio_write16(dev, 0x0052, regstack[1] | i);
+		mls = bcm43xx_phy_lo_b_r15_loop(dev) / 10;
 		if (mls < phy->minlowsig[0]) {
 			phy->minlowsig[0] = mls;
 			phy->minlowsigpos[0] = i;
 		}
 	}
-	bcm43xx_radio_write16(bcm, 0x0052, regstack[1] | phy->minlowsigpos[0]);
+	bcm43xx_radio_write16(dev, 0x0052, regstack[1] | phy->minlowsigpos[0]);
 
 	phy->minlowsig[1] = 0xFFFF;
 
@@ -1373,8 +1200,8 @@ void bcm43xx_phy_lo_b_measure(struct bcm
 				fval = (0x0100 * i) + j + 0x0100;
 			else
 				fval = (0x0100 * i) + j;
-			bcm43xx_phy_write(bcm, 0x002F, fval);
-			mls = bcm43xx_phy_lo_b_r15_loop(bcm) / 10;
+			bcm43xx_phy_write(dev, 0x002F, fval);
+			mls = bcm43xx_phy_lo_b_r15_loop(dev) / 10;
 			if (mls < phy->minlowsig[1]) {
 				phy->minlowsig[1] = mls;
 				phy->minlowsigpos[1] = fval;
@@ -1383,75 +1210,76 @@ void bcm43xx_phy_lo_b_measure(struct bcm
 	}
 	phy->minlowsigpos[1] += 0x0101;
 
-	bcm43xx_phy_write(bcm, 0x002F, phy->minlowsigpos[1]);
-	if (radio->version == 0x2053) {
-		bcm43xx_phy_write(bcm, 0x000A, regstack[2]);
-		bcm43xx_phy_write(bcm, 0x002A, regstack[3]);
-		bcm43xx_phy_write(bcm, 0x0035, regstack[4]);
-		bcm43xx_phy_write(bcm, 0x0003, regstack[5]);
-		bcm43xx_phy_write(bcm, 0x0001, regstack[6]);
-		bcm43xx_phy_write(bcm, 0x0030, regstack[7]);
-
-		bcm43xx_radio_write16(bcm, 0x0043, regstack[8]);
-		bcm43xx_radio_write16(bcm, 0x007A, regstack[9]);
-
-		bcm43xx_radio_write16(bcm, 0x0052,
-		                      (bcm43xx_radio_read16(bcm, 0x0052) & 0x000F)
-				      | regstack[11]);
+	bcm43xx_phy_write(dev, 0x002F, phy->minlowsigpos[1]);
+	if (phy->radio_ver == 0x2053) {
+		bcm43xx_phy_write(dev, 0x000A, regstack[2]);
+		bcm43xx_phy_write(dev, 0x002A, regstack[3]);
+		bcm43xx_phy_write(dev, 0x0035, regstack[4]);
+		bcm43xx_phy_write(dev, 0x0003, regstack[5]);
+		bcm43xx_phy_write(dev, 0x0001, regstack[6]);
+		bcm43xx_phy_write(dev, 0x0030, regstack[7]);
+
+		bcm43xx_radio_write16(dev, 0x0043, regstack[8]);
+		bcm43xx_radio_write16(dev, 0x007A, regstack[9]);
+
+		bcm43xx_radio_write16(dev, 0x0052,
+				      (bcm43xx_radio_read16(dev, 0x0052)
+				      & 0x000F) | regstack[11]);
 
-		bcm43xx_write16(bcm, 0x03EC, regstack[10]);
+		bcm43xx_write16(dev, 0x03EC, regstack[10]);
 	}
-	bcm43xx_phy_write(bcm, 0x0015, regstack[0]);
+	bcm43xx_phy_write(dev, 0x0015, regstack[0]);
 }
 
 static inline
-u16 bcm43xx_phy_lo_g_deviation_subval(struct bcm43xx_private *bcm, u16 control)
+u16 bcm43xx_phy_lo_g_deviation_subval(struct bcm43xx_wldev *dev, u16 control)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 ret;
 	unsigned long flags;
 
 	local_irq_save(flags);
-	if (phy->connected) {
-		bcm43xx_phy_write(bcm, 0x15, 0xE300);
+	if (phy->gmode) {
+		bcm43xx_phy_write(dev, 0x15, 0xE300);
 		control <<= 8;
-		bcm43xx_phy_write(bcm, 0x0812, control | 0x00B0);
+		bcm43xx_phy_write(dev, 0x0812, control | 0x00B0);
 		udelay(5);
-		bcm43xx_phy_write(bcm, 0x0812, control | 0x00B2);
+		bcm43xx_phy_write(dev, 0x0812, control | 0x00B2);
 		udelay(2);
-		bcm43xx_phy_write(bcm, 0x0812, control | 0x00B3);
+		bcm43xx_phy_write(dev, 0x0812, control | 0x00B3);
 		udelay(4);
-		bcm43xx_phy_write(bcm, 0x0015, 0xF300);
+		bcm43xx_phy_write(dev, 0x0015, 0xF300);
 		udelay(8);
 	} else {
-		bcm43xx_phy_write(bcm, 0x0015, control | 0xEFA0);
+		bcm43xx_phy_write(dev, 0x0015, control | 0xEFA0);
 		udelay(2);
-		bcm43xx_phy_write(bcm, 0x0015, control | 0xEFE0);
+		bcm43xx_phy_write(dev, 0x0015, control | 0xEFE0);
 		udelay(4);
-		bcm43xx_phy_write(bcm, 0x0015, control | 0xFFE0);
+		bcm43xx_phy_write(dev, 0x0015, control | 0xFFE0);
 		udelay(8);
 	}
-	ret = bcm43xx_phy_read(bcm, 0x002D);
+	ret = bcm43xx_phy_read(dev, 0x002D);
 	local_irq_restore(flags);
 	bcm43xx_voluntary_preempt();
 
 	return ret;
 }
 
-static u32 bcm43xx_phy_lo_g_singledeviation(struct bcm43xx_private *bcm, u16 control)
+static u32 bcm43xx_phy_lo_g_singledeviation(struct bcm43xx_wldev *dev,
+					    u16 control)
 {
 	int i;
 	u32 ret = 0;
 
 	for (i = 0; i < 8; i++)
-		ret += bcm43xx_phy_lo_g_deviation_subval(bcm, control);
+		ret += bcm43xx_phy_lo_g_deviation_subval(dev, control);
 
 	return ret;
 }
 
 /* Write the LocalOscillator CONTROL */
 static inline
-void bcm43xx_lo_write(struct bcm43xx_private *bcm,
+void bcm43xx_lo_write(struct bcm43xx_wldev *dev,
 		      struct bcm43xx_lopair *pair)
 {
 	u16 value;
@@ -1463,30 +1291,31 @@ void bcm43xx_lo_write(struct bcm43xx_pri
 	/* Sanity check. */
 	if (pair->low < -8 || pair->low > 8 ||
 	    pair->high < -8 || pair->high > 8) {
-		printk(KERN_WARNING PFX
+		struct bcm43xx_phy *phy = &dev->phy;
+		bcmdbg(dev->wl,
 		       "WARNING: Writing invalid LOpair "
 		       "(low: %d, high: %d, index: %lu)\n",
 		       pair->low, pair->high,
-		       (unsigned long)(pair - bcm43xx_current_phy(bcm)->_lo_pairs));
+		       (unsigned long)(pair - phy->_lo_pairs));
 		dump_stack();
 	}
 #endif
 
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_G_LO_CONTROL, value);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_G_LO_CONTROL, value);
 }
 
 static inline
-struct bcm43xx_lopair * bcm43xx_find_lopair(struct bcm43xx_private *bcm,
+struct bcm43xx_lopair *bcm43xx_find_lopair(struct bcm43xx_wldev *dev,
 					    u16 baseband_attenuation,
 					    u16 radio_attenuation,
 					    u16 tx)
 {
 	static const u8 dict[10] = { 11, 10, 11, 12, 13, 12, 13, 12, 13, 12 };
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 
 	if (baseband_attenuation > 6)
 		baseband_attenuation = 6;
-	assert(radio_attenuation < 10);
+	BCM43xx_WARN_ON(radio_attenuation >= 10);
 
 	if (tx == 3) {
 		return bcm43xx_get_lopair(phy,
@@ -1497,52 +1326,53 @@ struct bcm43xx_lopair * bcm43xx_find_lop
 }
 
 static inline
-struct bcm43xx_lopair * bcm43xx_current_lopair(struct bcm43xx_private *bcm)
+struct bcm43xx_lopair *bcm43xx_current_lopair(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 
-	return bcm43xx_find_lopair(bcm,
-				   radio->baseband_atten,
-				   radio->radio_atten,
-				   radio->txctl1);
+	return bcm43xx_find_lopair(dev,
+				   phy->bbatt,
+				   phy->rfatt,
+				   phy->txctl1);
 }
 
 /* Adjust B/G LO */
-void bcm43xx_phy_lo_adjust(struct bcm43xx_private *bcm, int fixed)
+void bcm43xx_phy_lo_adjust(struct bcm43xx_wldev *dev, int fixed)
 {
 	struct bcm43xx_lopair *pair;
 
 	if (fixed) {
 		/* Use fixed values. Only for initialization. */
-		pair = bcm43xx_find_lopair(bcm, 2, 3, 0);
-	} else
-		pair = bcm43xx_current_lopair(bcm);
-	bcm43xx_lo_write(bcm, pair);
+		pair = bcm43xx_find_lopair(dev, 2, 3, 0);
+	} else {
+		pair = bcm43xx_current_lopair(dev);
+	}
+	bcm43xx_lo_write(dev, pair);
 }
 
-static void bcm43xx_phy_lo_g_measure_txctl2(struct bcm43xx_private *bcm)
+static void bcm43xx_phy_lo_g_measure_txctl2(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 txctl2 = 0, i;
 	u32 smallest, tmp;
 
-	bcm43xx_radio_write16(bcm, 0x0052, 0x0000);
+	bcm43xx_radio_write16(dev, 0x0052, 0x0000);
 	udelay(10);
-	smallest = bcm43xx_phy_lo_g_singledeviation(bcm, 0);
+	smallest = bcm43xx_phy_lo_g_singledeviation(dev, 0);
 	for (i = 0; i < 16; i++) {
-		bcm43xx_radio_write16(bcm, 0x0052, i);
+		bcm43xx_radio_write16(dev, 0x0052, i);
 		udelay(10);
-		tmp = bcm43xx_phy_lo_g_singledeviation(bcm, 0);
+		tmp = bcm43xx_phy_lo_g_singledeviation(dev, 0);
 		if (tmp < smallest) {
 			smallest = tmp;
 			txctl2 = i;
 		}
 	}
-	radio->txctl2 = txctl2;
+	phy->txctl2 = txctl2;
 }
 
 static
-void bcm43xx_phy_lo_g_state(struct bcm43xx_private *bcm,
+void bcm43xx_phy_lo_g_state(struct bcm43xx_wldev *dev,
 			    const struct bcm43xx_lopair *in_pair,
 			    struct bcm43xx_lopair *out_pair,
 			    u16 r27)
@@ -1572,11 +1402,11 @@ void bcm43xx_phy_lo_g_state(struct bcm43
 
 	/* Note that in_pair and out_pair can point to the same pair. Be careful. */
 
-	bcm43xx_lo_write(bcm, &lowest_transition);
-	lowest_deviation = bcm43xx_phy_lo_g_singledeviation(bcm, r27);
+	bcm43xx_lo_write(dev, &lowest_transition);
+	lowest_deviation = bcm43xx_phy_lo_g_singledeviation(dev, r27);
 	do {
 		found_lower = 0;
-		assert(state >= 0 && state <= 8);
+		BCM43xx_WARN_ON(!(state >= 0 && state <= 8));
 		if (state == 0) {
 			begin = 1;
 			end = 8;
@@ -1596,12 +1426,14 @@ void bcm43xx_phy_lo_g_state(struct bcm43
 		tmp_pair.high = lowest_transition.high;
 		tmp_pair.low = lowest_transition.low;
 		while (1) {
-			assert(j >= 1 && j <= 8);
+			BCM43xx_WARN_ON(!(j >= 1 && j <= 8));
 			transition.high = tmp_pair.high + transitions[j - 1].high;
 			transition.low = tmp_pair.low + transitions[j - 1].low;
-			if ((abs(transition.low) < 9) && (abs(transition.high) < 9)) {
-				bcm43xx_lo_write(bcm, &transition);
-				tmp = bcm43xx_phy_lo_g_singledeviation(bcm, r27);
+			if ((abs(transition.low) < 9)
+			     && (abs(transition.high) < 9)) {
+				bcm43xx_lo_write(dev, &transition);
+				tmp = bcm43xx_phy_lo_g_singledeviation(dev,
+								       r27);
 				if (tmp < lowest_deviation) {
 					lowest_deviation = tmp;
 					state = j;
@@ -1625,36 +1457,36 @@ void bcm43xx_phy_lo_g_state(struct bcm43
 }
 
 /* Set the baseband attenuation value on chip. */
-void bcm43xx_phy_set_baseband_attenuation(struct bcm43xx_private *bcm,
+void bcm43xx_phy_set_baseband_attenuation(struct bcm43xx_wldev *dev,
 					  u16 baseband_attenuation)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 value;
 
 	if (phy->analog == 0) {
-		value = (bcm43xx_read16(bcm, 0x03E6) & 0xFFF0);
+		value = (bcm43xx_read16(dev, 0x03E6) & 0xFFF0);
 		value |= (baseband_attenuation & 0x000F);
-		bcm43xx_write16(bcm, 0x03E6, value);
+		bcm43xx_write16(dev, 0x03E6, value);
 		return;
 	}
 
-	if (phy->analog == 1) {
-		value = bcm43xx_phy_read(bcm, 0x0060) & ~0x003C;
+	if (phy->analog > 1) {
+		value = bcm43xx_phy_read(dev, 0x0060) & ~0x003C;
 		value |= (baseband_attenuation << 2) & 0x003C;
 	} else {
-		value = bcm43xx_phy_read(bcm, 0x0060) & ~0x0078;
+		value = bcm43xx_phy_read(dev, 0x0060) & ~0x0078;
 		value |= (baseband_attenuation << 3) & 0x0078;
 	}
-	bcm43xx_phy_write(bcm, 0x0060, value);
+	bcm43xx_phy_write(dev, 0x0060, value);
 }
 
 /* http://bcm-specs.sipsolutions.net/LocalOscillator/Measure */
-void bcm43xx_phy_lo_g_measure(struct bcm43xx_private *bcm)
+void bcm43xx_phy_lo_g_measure(struct bcm43xx_wldev *dev)
 {
 	static const u8 pairorder[10] = { 3, 1, 5, 7, 9, 2, 0, 4, 6, 8 };
-	const int is_initializing = (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZING);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	const int is_initializing = (bcm43xx_status(dev)
+				     < BCM43xx_STAT_STARTED);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 h, i, oldi = 0, j;
 	struct bcm43xx_lopair control;
 	struct bcm43xx_lopair *tmp_control;
@@ -1662,59 +1494,59 @@ void bcm43xx_phy_lo_g_measure(struct bcm
 	u16 regstack[16] = { 0 };
 	u8 oldchannel;
 
-	//XXX: What are these?
+	/* XXX: What are these? */
 	u8 r27 = 0, r31;
 
-	oldchannel = radio->channel;
+	oldchannel = phy->channel;
 	/* Setup */
-	if (phy->connected) {
-		regstack[0] = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS);
-		regstack[1] = bcm43xx_phy_read(bcm, 0x0802);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, regstack[0] & 0x7FFF);
-		bcm43xx_phy_write(bcm, 0x0802, regstack[1] & 0xFFFC);
-	}
-	regstack[3] = bcm43xx_read16(bcm, 0x03E2);
-	bcm43xx_write16(bcm, 0x03E2, regstack[3] | 0x8000);
-	regstack[4] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
-	regstack[5] = bcm43xx_phy_read(bcm, 0x15);
-	regstack[6] = bcm43xx_phy_read(bcm, 0x2A);
-	regstack[7] = bcm43xx_phy_read(bcm, 0x35);
-	regstack[8] = bcm43xx_phy_read(bcm, 0x60);
-	regstack[9] = bcm43xx_radio_read16(bcm, 0x43);
-	regstack[10] = bcm43xx_radio_read16(bcm, 0x7A);
-	regstack[11] = bcm43xx_radio_read16(bcm, 0x52);
-	if (phy->connected) {
-		regstack[12] = bcm43xx_phy_read(bcm, 0x0811);
-		regstack[13] = bcm43xx_phy_read(bcm, 0x0812);
-		regstack[14] = bcm43xx_phy_read(bcm, 0x0814);
-		regstack[15] = bcm43xx_phy_read(bcm, 0x0815);
-	}
-	bcm43xx_radio_selectchannel(bcm, 6, 0);
-	if (phy->connected) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, regstack[0] & 0x7FFF);
-		bcm43xx_phy_write(bcm, 0x0802, regstack[1] & 0xFFFC);
-		bcm43xx_dummy_transmission(bcm);
-	}
-	bcm43xx_radio_write16(bcm, 0x0043, 0x0006);
-
-	bcm43xx_phy_set_baseband_attenuation(bcm, 2);
-
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, 0x0000);
-	bcm43xx_phy_write(bcm, 0x002E, 0x007F);
-	bcm43xx_phy_write(bcm, 0x080F, 0x0078);
-	bcm43xx_phy_write(bcm, 0x0035, regstack[7] & ~(1 << 7));
-	bcm43xx_radio_write16(bcm, 0x007A, regstack[10] & 0xFFF0);
-	bcm43xx_phy_write(bcm, 0x002B, 0x0203);
-	bcm43xx_phy_write(bcm, 0x002A, 0x08A3);
-	if (phy->connected) {
-		bcm43xx_phy_write(bcm, 0x0814, regstack[14] | 0x0003);
-		bcm43xx_phy_write(bcm, 0x0815, regstack[15] & 0xFFFC);
-		bcm43xx_phy_write(bcm, 0x0811, 0x01B3);
-		bcm43xx_phy_write(bcm, 0x0812, 0x00B2);
+	if (phy->gmode) {
+		regstack[0] = bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS);
+		regstack[1] = bcm43xx_phy_read(dev, 0x0802);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS, regstack[0] & 0x7FFF);
+		bcm43xx_phy_write(dev, 0x0802, regstack[1] & 0xFFFC);
+	}
+	regstack[3] = bcm43xx_read16(dev, 0x03E2);
+	bcm43xx_write16(dev, 0x03E2, regstack[3] | 0x8000);
+	regstack[4] = bcm43xx_read16(dev, BCM43xx_MMIO_CHANNEL_EXT);
+	regstack[5] = bcm43xx_phy_read(dev, 0x15);
+	regstack[6] = bcm43xx_phy_read(dev, 0x2A);
+	regstack[7] = bcm43xx_phy_read(dev, 0x35);
+	regstack[8] = bcm43xx_phy_read(dev, 0x60);
+	regstack[9] = bcm43xx_radio_read16(dev, 0x43);
+	regstack[10] = bcm43xx_radio_read16(dev, 0x7A);
+	regstack[11] = bcm43xx_radio_read16(dev, 0x52);
+	if (phy->gmode) {
+		regstack[12] = bcm43xx_phy_read(dev, 0x0811);
+		regstack[13] = bcm43xx_phy_read(dev, 0x0812);
+		regstack[14] = bcm43xx_phy_read(dev, 0x0814);
+		regstack[15] = bcm43xx_phy_read(dev, 0x0815);
+	}
+	bcm43xx_radio_selectchannel(dev, 6, 0);
+	if (phy->gmode) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS, regstack[0] & 0x7FFF);
+		bcm43xx_phy_write(dev, 0x0802, regstack[1] & 0xFFFC);
+		bcm43xx_dummy_transmission(dev);
+	}
+	bcm43xx_radio_write16(dev, 0x0043, 0x0006);
+
+	bcm43xx_phy_set_baseband_attenuation(dev, 2);
+
+	bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL_EXT, 0x0000);
+	bcm43xx_phy_write(dev, 0x002E, 0x007F);
+	bcm43xx_phy_write(dev, 0x080F, 0x0078);
+	bcm43xx_phy_write(dev, 0x0035, regstack[7] & ~(1 << 7));
+	bcm43xx_radio_write16(dev, 0x007A, regstack[10] & 0xFFF0);
+	bcm43xx_phy_write(dev, 0x002B, 0x0203);
+	bcm43xx_phy_write(dev, 0x002A, 0x08A3);
+	if (phy->gmode) {
+		bcm43xx_phy_write(dev, 0x0814, regstack[14] | 0x0003);
+		bcm43xx_phy_write(dev, 0x0815, regstack[15] & 0xFFFC);
+		bcm43xx_phy_write(dev, 0x0811, 0x01B3);
+		bcm43xx_phy_write(dev, 0x0812, 0x00B2);
 	}
 	if (is_initializing)
-		bcm43xx_phy_lo_g_measure_txctl2(bcm);
-	bcm43xx_phy_write(bcm, 0x080F, 0x8078);
+		bcm43xx_phy_lo_g_measure_txctl2(dev);
+	bcm43xx_phy_write(dev, 0x080F, 0x8078);
 
 	/* Measure */
 	control.low = 0;
@@ -1756,20 +1588,20 @@ void bcm43xx_phy_lo_g_measure(struct bcm
 				r27 = 3;
 				r31 = 0;
 			}
-			bcm43xx_radio_write16(bcm, 0x43, i);
-			bcm43xx_radio_write16(bcm, 0x52, radio->txctl2);
+			bcm43xx_radio_write16(dev, 0x43, i);
+			bcm43xx_radio_write16(dev, 0x52, phy->txctl2);
 			udelay(10);
 			bcm43xx_voluntary_preempt();
 
-			bcm43xx_phy_set_baseband_attenuation(bcm, j * 2);
+			bcm43xx_phy_set_baseband_attenuation(dev, j * 2);
 
 			tmp = (regstack[10] & 0xFFF0);
 			if (r31)
 				tmp |= 0x0008;
-			bcm43xx_radio_write16(bcm, 0x007A, tmp);
+			bcm43xx_radio_write16(dev, 0x007A, tmp);
 
 			tmp_control = bcm43xx_get_lopair(phy, i, j * 2);
-			bcm43xx_phy_lo_g_state(bcm, &control, tmp_control, r27);
+			bcm43xx_phy_lo_g_state(dev, &control, tmp_control, r27);
 		}
 		oldi = i;
 	}
@@ -1778,9 +1610,12 @@ void bcm43xx_phy_lo_g_measure(struct bcm
 		/* Loop over each possible BasebandAttenuation/2 */
 		for (j = 0; j < 4; j++) {
 			if (is_initializing) {
-				tmp_control = bcm43xx_get_lopair(phy, i - 9, j * 2);
+				tmp_control = bcm43xx_get_lopair(phy, i - 9,
+								 j * 2);
 				memcpy(&control, tmp_control, sizeof(control));
-				tmp = (i - 9) * 2 + j - 5;//FIXME: This is wrong, as the following if statement can never trigger.
+				/* FIXME: The next line is wrong, as the
+				 * following if statement can never trigger. */
+				tmp = (i - 9) * 2 + j - 5;
 				r27 = 0;
 				r31 = 0;
 				if (tmp > 14) {
@@ -1798,62 +1633,65 @@ void bcm43xx_phy_lo_g_measure(struct bcm
 				r27 = 3;
 				r31 = 0;
 			}
-			bcm43xx_radio_write16(bcm, 0x43, i - 9);
-			bcm43xx_radio_write16(bcm, 0x52,
-					      radio->txctl2
-					      | (3/*txctl1*/ << 4));//FIXME: shouldn't txctl1 be zero here and 3 in the loop above?
+			bcm43xx_radio_write16(dev, 0x43, i - 9);
+			/* FIXME: shouldn't txctl1 be zero in the next line
+			 * and 3 in the loop above? */
+			bcm43xx_radio_write16(dev, 0x52,
+					      phy->txctl2
+					      | (3/*txctl1*/ << 4));
 			udelay(10);
 			bcm43xx_voluntary_preempt();
 
-			bcm43xx_phy_set_baseband_attenuation(bcm, j * 2);
+			bcm43xx_phy_set_baseband_attenuation(dev, j * 2);
 
 			tmp = (regstack[10] & 0xFFF0);
 			if (r31)
 				tmp |= 0x0008;
-			bcm43xx_radio_write16(bcm, 0x7A, tmp);
+			bcm43xx_radio_write16(dev, 0x7A, tmp);
 
 			tmp_control = bcm43xx_get_lopair(phy, i, j * 2);
-			bcm43xx_phy_lo_g_state(bcm, &control, tmp_control, r27);
+			bcm43xx_phy_lo_g_state(dev, &control, tmp_control, r27);
 		}
 	}
 
 	/* Restoration */
-	if (phy->connected) {
-		bcm43xx_phy_write(bcm, 0x0015, 0xE300);
-		bcm43xx_phy_write(bcm, 0x0812, (r27 << 8) | 0xA0);
+	if (phy->gmode) {
+		bcm43xx_phy_write(dev, 0x0015, 0xE300);
+		bcm43xx_phy_write(dev, 0x0812, (r27 << 8) | 0xA0);
 		udelay(5);
-		bcm43xx_phy_write(bcm, 0x0812, (r27 << 8) | 0xA2);
+		bcm43xx_phy_write(dev, 0x0812, (r27 << 8) | 0xA2);
 		udelay(2);
-		bcm43xx_phy_write(bcm, 0x0812, (r27 << 8) | 0xA3);
+		bcm43xx_phy_write(dev, 0x0812, (r27 << 8) | 0xA3);
 		bcm43xx_voluntary_preempt();
-	} else
-		bcm43xx_phy_write(bcm, 0x0015, r27 | 0xEFA0);
-	bcm43xx_phy_lo_adjust(bcm, is_initializing);
-	bcm43xx_phy_write(bcm, 0x002E, 0x807F);
-	if (phy->connected)
-		bcm43xx_phy_write(bcm, 0x002F, 0x0202);
+	} else {
+		bcm43xx_phy_write(dev, 0x0015, r27 | 0xEFA0);
+	}
+	bcm43xx_phy_lo_adjust(dev, is_initializing);
+	bcm43xx_phy_write(dev, 0x002E, 0x807F);
+	if (phy->gmode)
+		bcm43xx_phy_write(dev, 0x002F, 0x0202);
 	else
-		bcm43xx_phy_write(bcm, 0x002F, 0x0101);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, regstack[4]);
-	bcm43xx_phy_write(bcm, 0x0015, regstack[5]);
-	bcm43xx_phy_write(bcm, 0x002A, regstack[6]);
-	bcm43xx_phy_write(bcm, 0x0035, regstack[7]);
-	bcm43xx_phy_write(bcm, 0x0060, regstack[8]);
-	bcm43xx_radio_write16(bcm, 0x0043, regstack[9]);
-	bcm43xx_radio_write16(bcm, 0x007A, regstack[10]);
+		bcm43xx_phy_write(dev, 0x002F, 0x0101);
+	bcm43xx_write16(dev, BCM43xx_MMIO_CHANNEL_EXT, regstack[4]);
+	bcm43xx_phy_write(dev, 0x0015, regstack[5]);
+	bcm43xx_phy_write(dev, 0x002A, regstack[6]);
+	bcm43xx_phy_write(dev, 0x0035, regstack[7]);
+	bcm43xx_phy_write(dev, 0x0060, regstack[8]);
+	bcm43xx_radio_write16(dev, 0x0043, regstack[9]);
+	bcm43xx_radio_write16(dev, 0x007A, regstack[10]);
 	regstack[11] &= 0x00F0;
-	regstack[11] |= (bcm43xx_radio_read16(bcm, 0x52) & 0x000F);
-	bcm43xx_radio_write16(bcm, 0x52, regstack[11]);
-	bcm43xx_write16(bcm, 0x03E2, regstack[3]);
-	if (phy->connected) {
-		bcm43xx_phy_write(bcm, 0x0811, regstack[12]);
-		bcm43xx_phy_write(bcm, 0x0812, regstack[13]);
-		bcm43xx_phy_write(bcm, 0x0814, regstack[14]);
-		bcm43xx_phy_write(bcm, 0x0815, regstack[15]);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, regstack[0]);
-		bcm43xx_phy_write(bcm, 0x0802, regstack[1]);
+	regstack[11] |= (bcm43xx_radio_read16(dev, 0x52) & 0x000F);
+	bcm43xx_radio_write16(dev, 0x52, regstack[11]);
+	bcm43xx_write16(dev, 0x03E2, regstack[3]);
+	if (phy->gmode) {
+		bcm43xx_phy_write(dev, 0x0811, regstack[12]);
+		bcm43xx_phy_write(dev, 0x0812, regstack[13]);
+		bcm43xx_phy_write(dev, 0x0814, regstack[14]);
+		bcm43xx_phy_write(dev, 0x0815, regstack[15]);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS, regstack[0]);
+		bcm43xx_phy_write(dev, 0x0802, regstack[1]);
 	}
-	bcm43xx_radio_selectchannel(bcm, oldchannel, 1);
+	bcm43xx_radio_selectchannel(dev, oldchannel, 1);
 
 #ifdef CONFIG_BCM43XX_DEBUG
 	{
@@ -1862,7 +1700,7 @@ void bcm43xx_phy_lo_g_measure(struct bcm
 			tmp_control = phy->_lo_pairs + i;
 			if (tmp_control->low < -8 || tmp_control->low > 8 ||
 			    tmp_control->high < -8 || tmp_control->high > 8) {
-				printk(KERN_WARNING PFX
+				bcmwarn(dev->wl,
 				       "WARNING: Invalid LOpair (low: %d, high: %d, index: %d)\n",
 				       tmp_control->low, tmp_control->high, i);
 			}
@@ -1872,17 +1710,17 @@ void bcm43xx_phy_lo_g_measure(struct bcm
 }
 
 static
-void bcm43xx_phy_lo_mark_current_used(struct bcm43xx_private *bcm)
+void bcm43xx_phy_lo_mark_current_used(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_lopair *pair;
 
-	pair = bcm43xx_current_lopair(bcm);
+	pair = bcm43xx_current_lopair(dev);
 	pair->used = 1;
 }
 
-void bcm43xx_phy_lo_mark_all_unused(struct bcm43xx_private *bcm)
+void bcm43xx_phy_lo_mark_all_unused(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	struct bcm43xx_lopair *pair;
 	int i;
 
@@ -1895,9 +1733,9 @@ void bcm43xx_phy_lo_mark_all_unused(stru
 /* http://bcm-specs.sipsolutions.net/EstimatePowerOut
  * This function converts a TSSI value to dBm in Q5.2
  */
-static s8 bcm43xx_phy_estimate_power_out(struct bcm43xx_private *bcm, s8 tssi)
+static s8 bcm43xx_phy_estimate_power_out(struct bcm43xx_wldev *dev, s8 tssi)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	s8 dbm = 0;
 	s32 tmp;
 
@@ -1906,174 +1744,189 @@ static s8 bcm43xx_phy_estimate_power_out
 	tmp -= phy->savedpctlreg;
 
 	switch (phy->type) {
-		case BCM43xx_PHYTYPE_A:
-			tmp += 0x80;
-			tmp = limit_value(tmp, 0x00, 0xFF);
-			dbm = phy->tssi2dbm[tmp];
-			TODO(); //TODO: There's a FIXME on the specs
-			break;
 		case BCM43xx_PHYTYPE_B:
 		case BCM43xx_PHYTYPE_G:
 			tmp = limit_value(tmp, 0x00, 0x3F);
 			dbm = phy->tssi2dbm[tmp];
 			break;
 		default:
-			assert(0);
+			BCM43xx_BUG_ON(1);
 	}
 
 	return dbm;
 }
 
 /* http://bcm-specs.sipsolutions.net/RecalculateTransmissionPower */
-void bcm43xx_phy_xmitpower(struct bcm43xx_private *bcm)
+void bcm43xx_phy_xmitpower(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	
+	struct bcm43xx_phy *phy = &dev->phy;
+	u16 tmp;
+	u16 txpower;
+	s8 v0;
+	s8 v1;
+	s8 v2;
+	s8 v3;
+	s8 average;
+	int max_pwr;
+	s16 desired_pwr;
+	s16 estimated_pwr;
+	s16 pwr_adjust;
+	s16 radio_att_delta;
+	s16 baseband_att_delta;
+	s16 radio_attenuation;
+	s16 baseband_attenuation;
+	unsigned long phylock_flags;
+
 	if (phy->savedpctlreg == 0xFFFF)
 		return;
-	if ((bcm->board_type == 0x0416) &&
-	    (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM))
+	if ((dev->dev->bus->boardinfo.type == 0x0416) &&
+	    is_bcm_board_vendor(dev))
 		return;
-	
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A: {
-
-		TODO(); //TODO: Nothing for A PHYs yet :-/
-
-		break;
-	}
-	case BCM43xx_PHYTYPE_B:
-	case BCM43xx_PHYTYPE_G: {
-		u16 tmp;
-		u16 txpower;
-		s8 v0, v1, v2, v3;
-		s8 average;
-		u8 max_pwr;
-		s16 desired_pwr, estimated_pwr, pwr_adjust;
-		s16 radio_att_delta, baseband_att_delta;
-		s16 radio_attenuation, baseband_attenuation;
-		unsigned long phylock_flags;
+#ifdef CONFIG_BCM43XX_DEBUG
+	if (phy->manual_txpower_control)
+		return;
+#endif
 
-		tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0058);
+	BCM43xx_BUG_ON(!(phy->type == BCM43xx_PHYTYPE_B ||
+			 phy->type == BCM43xx_PHYTYPE_G));
+	tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x0058);
+	v0 = (s8)(tmp & 0x00FF);
+	v1 = (s8)((tmp & 0xFF00) >> 8);
+	tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x005A);
+	v2 = (s8)(tmp & 0x00FF);
+	v3 = (s8)((tmp & 0xFF00) >> 8);
+	tmp = 0;
+
+	if (v0 == 0x7F || v1 == 0x7F || v2 == 0x7F || v3 == 0x7F) {
+		tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+					 0x0070);
 		v0 = (s8)(tmp & 0x00FF);
 		v1 = (s8)((tmp & 0xFF00) >> 8);
-		tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x005A);
+		tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+					 0x0072);
 		v2 = (s8)(tmp & 0x00FF);
 		v3 = (s8)((tmp & 0xFF00) >> 8);
-		tmp = 0;
-
-		if (v0 == 0x7F || v1 == 0x7F || v2 == 0x7F || v3 == 0x7F) {
-			tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0070);
-			v0 = (s8)(tmp & 0x00FF);
-			v1 = (s8)((tmp & 0xFF00) >> 8);
-			tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0072);
-			v2 = (s8)(tmp & 0x00FF);
-			v3 = (s8)((tmp & 0xFF00) >> 8);
-			if (v0 == 0x7F || v1 == 0x7F || v2 == 0x7F || v3 == 0x7F)
-				return;
-			v0 = (v0 + 0x20) & 0x3F;
-			v1 = (v1 + 0x20) & 0x3F;
-			v2 = (v2 + 0x20) & 0x3F;
-			v3 = (v3 + 0x20) & 0x3F;
-			tmp = 1;
-		}
-		bcm43xx_radio_clear_tssi(bcm);
-
-		average = (v0 + v1 + v2 + v3 + 2) / 4;
-
-		if (tmp && (bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x005E) & 0x8))
-			average -= 13;
-
-		estimated_pwr = bcm43xx_phy_estimate_power_out(bcm, average);
-
-		max_pwr = bcm->sprom.maxpower_bgphy;
-
-		if ((bcm->sprom.boardflags & BCM43xx_BFL_PACTRL) &&
-		    (phy->type == BCM43xx_PHYTYPE_G))
-			max_pwr -= 0x3;
-
-		/*TODO:
-		max_pwr = min(REG - bcm->sprom.antennagain_bgphy - 0x6, max_pwr)
-			where REG is the max power as per the regulatory domain
-		*/
-
-		desired_pwr = limit_value(radio->txpower_desired, 0, max_pwr);
-		/* Check if we need to adjust the current power. */
-		pwr_adjust = desired_pwr - estimated_pwr;
-		radio_att_delta = -(pwr_adjust + 7) >> 3;
-		baseband_att_delta = -(pwr_adjust >> 1) - (4 * radio_att_delta);
-		if ((radio_att_delta == 0) && (baseband_att_delta == 0)) {
-			bcm43xx_phy_lo_mark_current_used(bcm);
+		if (v0 == 0x7F || v1 == 0x7F || v2 == 0x7F || v3 == 0x7F)
 			return;
-		}
+		v0 = (v0 + 0x20) & 0x3F;
+		v1 = (v1 + 0x20) & 0x3F;
+		v2 = (v2 + 0x20) & 0x3F;
+		v3 = (v3 + 0x20) & 0x3F;
+		tmp = 1;
+	}
+	bcm43xx_radio_clear_tssi(dev);
+
+	average = (v0 + v1 + v2 + v3 + 2) / 4;
+
+	if (tmp && (bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x005E)
+	    & 0x8))
+		average -= 13;
+
+	estimated_pwr = bcm43xx_phy_estimate_power_out(dev, average);
+
+	max_pwr = dev->dev->bus->sprom.r1.maxpwr_bg;
+
+	if ((dev->dev->bus->sprom.r1.boardflags_lo
+	     & BCM43xx_BFL_PACTRL) &&
+	    (phy->type == BCM43xx_PHYTYPE_G))
+		max_pwr -= 0x3;
+	if (unlikely(max_pwr <= 0)) {
+		bcmwarn(dev->wl, "Invalid max-TX-power value in SPROM."
+			"\n");
+		max_pwr = 60; /* fake it */
+		dev->dev->bus->sprom.r1.maxpwr_bg = max_pwr;
+	}
+
+	/*TODO:
+	max_pwr = min(REG - dev->dev->bus->sprom.antennagain_bgphy
+		      - 0x6, max_pwr)
+		where REG is the max power as per the regulatory domain
+	*/
+
+	desired_pwr = limit_value(phy->power_level, 0, max_pwr);
+	if (bcm43xx_debug(dev, BCM43xx_DBG_XMITPOWER)) {
+		bcmdbg(dev->wl, "Current TX power output: " Q52_FMT
+		       " dBm, Desired TX power output: " Q52_FMT
+		       " dBm\n", Q52_ARG(estimated_pwr),
+		       Q52_ARG(desired_pwr));
+	}
+	/* Check if we need to adjust the current power. */
+	pwr_adjust = desired_pwr - estimated_pwr;
+	radio_att_delta = -(pwr_adjust + 7) >> 3;
+	baseband_att_delta = -(pwr_adjust >> 1) - (4 * radio_att_delta);
+	if ((radio_att_delta == 0) && (baseband_att_delta == 0)) {
+		bcm43xx_phy_lo_mark_current_used(dev);
+		return;
+	}
 
-		/* Calculate the new attenuation values. */
-		baseband_attenuation = radio->baseband_atten;
-		baseband_attenuation += baseband_att_delta;
-		radio_attenuation = radio->radio_atten;
-		radio_attenuation += radio_att_delta;
-
-		/* Get baseband and radio attenuation values into their permitted ranges.
-		 * baseband 0-11, radio 0-9.
-		 * Radio attenuation affects power level 4 times as much as baseband.
-		 */
-		if (radio_attenuation < 0) {
-			baseband_attenuation -= (4 * -radio_attenuation);
-			radio_attenuation = 0;
-		} else if (radio_attenuation > 9) {
-			baseband_attenuation += (4 * (radio_attenuation - 9));
-			radio_attenuation = 9;
-		} else {
-			while (baseband_attenuation < 0 && radio_attenuation > 0) {
-				baseband_attenuation += 4;
-				radio_attenuation--;
-			}
-			while (baseband_attenuation > 11 && radio_attenuation < 9) {
-				baseband_attenuation -= 4;
-				radio_attenuation++;
+	/* Calculate the new attenuation values. */
+	baseband_attenuation = phy->bbatt;
+	baseband_attenuation += baseband_att_delta;
+	radio_attenuation = phy->rfatt;
+	radio_attenuation += radio_att_delta;
+
+	/* Get baseband and radio attenuation values into permitted ranges.
+	 * baseband 0-11, radio 0-9.
+	 * Radio attenuation affects power level 4 times as much as baseband.
+	 */
+	if (radio_attenuation < 0) {
+		baseband_attenuation -= (4 * -radio_attenuation);
+		radio_attenuation = 0;
+	} else if (radio_attenuation > 9) {
+		baseband_attenuation += (4 * (radio_attenuation - 9));
+		radio_attenuation = 9;
+	} else {
+		while (baseband_attenuation < 0 && radio_attenuation > 0) {
+			baseband_attenuation += 4;
+			radio_attenuation--;
+		}
+		while (baseband_attenuation > 11 && radio_attenuation < 9) {
+			baseband_attenuation -= 4;
+			radio_attenuation++;
+		}
+	}
+	baseband_attenuation = limit_value(baseband_attenuation, 0, 11);
+
+	txpower = phy->txctl1;
+	if ((phy->radio_ver == 0x2050) && (phy->radio_rev == 2)) {
+		if (radio_attenuation <= 1) {
+			if (txpower == 0) {
+				txpower = 3;
+				radio_attenuation += 2;
+				baseband_attenuation += 2;
+			} else if (dev->dev->bus->sprom.r1.boardflags_lo
+				   & BCM43xx_BFL_PACTRL) {
+				baseband_attenuation += 4 *
+						     (radio_attenuation - 2);
+				radio_attenuation = 2;
 			}
-		}
-		baseband_attenuation = limit_value(baseband_attenuation, 0, 11);
-
-		txpower = radio->txctl1;
-		if ((radio->version == 0x2050) && (radio->revision == 2)) {
-			if (radio_attenuation <= 1) {
-				if (txpower == 0) {
-					txpower = 3;
-					radio_attenuation += 2;
-					baseband_attenuation += 2;
-				} else if (bcm->sprom.boardflags & BCM43xx_BFL_PACTRL) {
-					baseband_attenuation += 4 * (radio_attenuation - 2);
-					radio_attenuation = 2;
-				}
-			} else if (radio_attenuation > 4 && txpower != 0) {
-				txpower = 0;
-				if (baseband_attenuation < 3) {
-					radio_attenuation -= 3;
-					baseband_attenuation += 2;
-				} else {
-					radio_attenuation -= 2;
-					baseband_attenuation -= 2;
-				}
+		} else if (radio_attenuation > 4 && txpower != 0) {
+			txpower = 0;
+			if (baseband_attenuation < 3) {
+				radio_attenuation -= 3;
+				baseband_attenuation += 2;
+			} else {
+				radio_attenuation -= 2;
+				baseband_attenuation -= 2;
 			}
 		}
-		radio->txctl1 = txpower;
-		baseband_attenuation = limit_value(baseband_attenuation, 0, 11);
-		radio_attenuation = limit_value(radio_attenuation, 0, 9);
-
-		bcm43xx_phy_lock(bcm, phylock_flags);
-		bcm43xx_radio_lock(bcm);
-		bcm43xx_radio_set_txpower_bg(bcm, baseband_attenuation,
-					     radio_attenuation, txpower);
-		bcm43xx_phy_lo_mark_current_used(bcm);
-		bcm43xx_radio_unlock(bcm);
-		bcm43xx_phy_unlock(bcm, phylock_flags);
-		break;
-	}
-	default:
-		assert(0);
 	}
+	phy->txctl1 = txpower;
+	baseband_attenuation = limit_value(baseband_attenuation, 0, 11);
+	radio_attenuation = limit_value(radio_attenuation, 0, 9);
+
+	if (bcm43xx_debug(dev, BCM43xx_DBG_XMITPOWER)) {
+		bcmdbg(dev->wl, "Old and new values for bbatt: %d %d, "
+		       "Old and new values for rfatt: %d %d\n", phy->bbatt,
+		       baseband_attenuation, phy->rfatt, radio_attenuation);
+	}
+	bcm43xx_phy_lock(dev, phylock_flags);
+	bcm43xx_radio_lock(dev);
+	bcm43xx_radio_set_txpower_bg(dev, baseband_attenuation,
+				     radio_attenuation, txpower);
+	bcm43xx_phy_lo_mark_current_used(dev);
+	bcm43xx_radio_unlock(dev);
+	bcm43xx_phy_unlock(dev, phylock_flags);
 }
 
 static inline
@@ -2090,7 +1943,7 @@ s8 bcm43xx_tssi2dbm_entry(s8 entry [], u
 {
 	s32 m1, m2, f = 256, q, delta;
 	s8 i = 0;
-	
+
 	m1 = bcm43xx_tssi2dbm_ad(16 * pab0 + index * pab1, 32);
 	m2 = max(bcm43xx_tssi2dbm_ad(32768 + index * pab2, 256), 1);
 	do {
@@ -2107,25 +1960,20 @@ s8 bcm43xx_tssi2dbm_entry(s8 entry [], u
 }
 
 /* http://bcm-specs.sipsolutions.net/TSSI_to_DBM_Table */
-int bcm43xx_phy_init_tssi2dbm_table(struct bcm43xx_private *bcm)
+int bcm43xx_phy_init_tssi2dbm_table(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	s16 pab0, pab1, pab2;
 	u8 idx;
 	s8 *dyn_tssi2dbm;
-	
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		pab0 = (s16)(bcm->sprom.pa1b0);
-		pab1 = (s16)(bcm->sprom.pa1b1);
-		pab2 = (s16)(bcm->sprom.pa1b2);
-	} else {
-		pab0 = (s16)(bcm->sprom.pa0b0);
-		pab1 = (s16)(bcm->sprom.pa0b1);
-		pab2 = (s16)(bcm->sprom.pa0b2);
-	}
 
-	if ((bcm->chip_id == 0x4301) && (radio->version != 0x2050)) {
+	BCM43xx_WARN_ON(!(phy->type == BCM43xx_PHYTYPE_B ||
+			  phy->type == BCM43xx_PHYTYPE_G));
+	pab0 = (s16)(dev->dev->bus->sprom.r1.pa0b0);
+	pab1 = (s16)(dev->dev->bus->sprom.r1.pa0b1);
+	pab2 = (s16)(dev->dev->bus->sprom.r1.pa0b2);
+
+	if ((dev->dev->bus->chip_id == 0x4301) && (phy->radio_ver != 0x2050)) {
 		phy->idle_tssi = 0x34;
 		phy->tssi2dbm = bcm43xx_tssi2dbm_b_table;
 		return 0;
@@ -2134,30 +1982,22 @@ int bcm43xx_phy_init_tssi2dbm_table(stru
 	if (pab0 != 0 && pab1 != 0 && pab2 != 0 &&
 	    pab0 != -1 && pab1 != -1 && pab2 != -1) {
 		/* The pabX values are set in SPROM. Use them. */
-		if (phy->type == BCM43xx_PHYTYPE_A) {
-			if ((s8)bcm->sprom.idle_tssi_tgt_aphy != 0 &&
-			    (s8)bcm->sprom.idle_tssi_tgt_aphy != -1)
-				phy->idle_tssi = (s8)(bcm->sprom.idle_tssi_tgt_aphy);
-			else
-				phy->idle_tssi = 62;
-		} else {
-			if ((s8)bcm->sprom.idle_tssi_tgt_bgphy != 0 &&
-			    (s8)bcm->sprom.idle_tssi_tgt_bgphy != -1)
-				phy->idle_tssi = (s8)(bcm->sprom.idle_tssi_tgt_bgphy);
-			else
-				phy->idle_tssi = 62;
-		}
+		if ((s8)dev->dev->bus->sprom.r1.itssi_bg != 0 &&
+		    (s8)dev->dev->bus->sprom.r1.itssi_bg != -1)
+			phy->idle_tssi = (s8)(dev->dev->bus->sprom.r1.itssi_bg);
+		else
+			phy->idle_tssi = 62;
 		dyn_tssi2dbm = kmalloc(64, GFP_KERNEL);
 		if (dyn_tssi2dbm == NULL) {
-			printk(KERN_ERR PFX "Could not allocate memory"
-					    "for tssi2dbm table\n");
+			bcmerr(dev->wl, "Could not allocate memory"
+			       "for tssi2dbm table\n");
 			return -ENOMEM;
 		}
 		for (idx = 0; idx < 64; idx++)
 			if (bcm43xx_tssi2dbm_entry(dyn_tssi2dbm, idx, pab0, pab1, pab2)) {
 				phy->tssi2dbm = NULL;
-				printk(KERN_ERR PFX "Could not generate "
-						    "tssi2dBm table\n");
+				bcmerr(dev->wl, "Could not generate "
+				       "tssi2dBm table\n");
 				kfree(dyn_tssi2dbm);
 				return -ENODEV;
 			}
@@ -2166,12 +2006,6 @@ int bcm43xx_phy_init_tssi2dbm_table(stru
 	} else {
 		/* pabX values not set in SPROM. */
 		switch (phy->type) {
-		case BCM43xx_PHYTYPE_A:
-			/* APHY needs a generated table. */
-			phy->tssi2dbm = NULL;
-			printk(KERN_ERR PFX "Could not generate tssi2dBm "
-					    "table (wrong SPROM info)!\n");
-			return -ENODEV;
 		case BCM43xx_PHYTYPE_B:
 			phy->idle_tssi = 0x34;
 			phy->tssi2dbm = bcm43xx_tssi2dbm_b_table;
@@ -2186,52 +2020,46 @@ int bcm43xx_phy_init_tssi2dbm_table(stru
 	return 0;
 }
 
-int bcm43xx_phy_init(struct bcm43xx_private *bcm)
+int bcm43xx_phy_init(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	int err = -ENODEV;
 
 	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		if (phy->rev == 2 || phy->rev == 3) {
-			bcm43xx_phy_inita(bcm);
-			err = 0;
-		}
-		break;
 	case BCM43xx_PHYTYPE_B:
 		switch (phy->rev) {
 		case 2:
-			bcm43xx_phy_initb2(bcm);
+			bcm43xx_phy_initb2(dev);
 			err = 0;
 			break;
 		case 4:
-			bcm43xx_phy_initb4(bcm);
+			bcm43xx_phy_initb4(dev);
 			err = 0;
 			break;
 		case 5:
-			bcm43xx_phy_initb5(bcm);
+			bcm43xx_phy_initb5(dev);
 			err = 0;
 			break;
 		case 6:
-			bcm43xx_phy_initb6(bcm);
+			bcm43xx_phy_initb6(dev);
 			err = 0;
 			break;
 		}
 		break;
 	case BCM43xx_PHYTYPE_G:
-		bcm43xx_phy_initg(bcm);
+		bcm43xx_phy_initg(dev);
 		err = 0;
 		break;
 	}
 	if (err)
-		printk(KERN_WARNING PFX "Unknown PHYTYPE found!\n");
+		bcmerr(dev->wl, "Unknown PHYTYPE found\n");
 
 	return err;
 }
 
-void bcm43xx_phy_set_antenna_diversity(struct bcm43xx_private *bcm)
+void bcm43xx_phy_set_antenna_diversity(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 antennadiv;
 	u16 offset;
 	u16 value;
@@ -2241,28 +2069,24 @@ void bcm43xx_phy_set_antenna_diversity(s
 
 	if (antennadiv == 0xFFFF)
 		antennadiv = 3;
-	assert(antennadiv <= 3);
+	BCM43xx_WARN_ON(antennadiv > 3);
 
-	ucodeflags = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
+	ucodeflags = bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED,
 					BCM43xx_UCODEFLAGS_OFFSET);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
+	bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED,
 			    BCM43xx_UCODEFLAGS_OFFSET,
 			    ucodeflags & ~BCM43xx_UCODEFLAG_AUTODIV);
 
 	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
 	case BCM43xx_PHYTYPE_G:
-		if (phy->type == BCM43xx_PHYTYPE_A)
-			offset = 0x0000;
-		else
-			offset = 0x0400;
+		offset = 0x0400;
 
 		if (antennadiv == 2)
 			value = (3/*automatic*/ << 7);
 		else
 			value = (antennadiv << 7);
-		bcm43xx_phy_write(bcm, offset + 1,
-				  (bcm43xx_phy_read(bcm, offset + 1)
+		bcm43xx_phy_write(dev, offset + 1,
+				  (bcm43xx_phy_read(dev, offset + 1)
 				   & 0x7E7F) | value);
 
 		if (antennadiv >= 2) {
@@ -2270,77 +2094,124 @@ void bcm43xx_phy_set_antenna_diversity(s
 				value = (antennadiv << 7);
 			else
 				value = (0/*force0*/ << 7);
-			bcm43xx_phy_write(bcm, offset + 0x2B,
-					  (bcm43xx_phy_read(bcm, offset + 0x2B)
+			bcm43xx_phy_write(dev, offset + 0x2B,
+					  (bcm43xx_phy_read(dev, offset + 0x2B)
 					   & 0xFEFF) | value);
 		}
 
 		if (phy->type == BCM43xx_PHYTYPE_G) {
 			if (antennadiv >= 2)
-				bcm43xx_phy_write(bcm, 0x048C,
-						  bcm43xx_phy_read(bcm, 0x048C)
+				bcm43xx_phy_write(dev, 0x048C,
+						  bcm43xx_phy_read(dev, 0x048C)
 						   | 0x2000);
 			else
-				bcm43xx_phy_write(bcm, 0x048C,
-						  bcm43xx_phy_read(bcm, 0x048C)
+				bcm43xx_phy_write(dev, 0x048C,
+						  bcm43xx_phy_read(dev, 0x048C)
 						   & ~0x2000);
 			if (phy->rev >= 2) {
-				bcm43xx_phy_write(bcm, 0x0461,
-						  bcm43xx_phy_read(bcm, 0x0461)
+				bcm43xx_phy_write(dev, 0x0461,
+						  bcm43xx_phy_read(dev, 0x0461)
 						   | 0x0010);
-				bcm43xx_phy_write(bcm, 0x04AD,
-						  (bcm43xx_phy_read(bcm, 0x04AD)
+				bcm43xx_phy_write(dev, 0x04AD,
+						  (bcm43xx_phy_read(dev, 0x04AD)
 						   & 0x00FF) | 0x0015);
 				if (phy->rev == 2)
-					bcm43xx_phy_write(bcm, 0x0427, 0x0008);
+					bcm43xx_phy_write(dev, 0x0427, 0x0008);
 				else
-					bcm43xx_phy_write(bcm, 0x0427,
-						(bcm43xx_phy_read(bcm, 0x0427)
+					bcm43xx_phy_write(dev, 0x0427,
+						(bcm43xx_phy_read(dev, 0x0427)
 						 & 0x00FF) | 0x0008);
 			}
 			else if (phy->rev >= 6)
-				bcm43xx_phy_write(bcm, 0x049B, 0x00DC);
+				bcm43xx_phy_write(dev, 0x049B, 0x00DC);
 		} else {
-			if (phy->rev < 3)
-				bcm43xx_phy_write(bcm, 0x002B,
-						  (bcm43xx_phy_read(bcm, 0x002B)
+			if (phy->rev < 3) {
+				bcm43xx_phy_write(dev, 0x002B,
+						  (bcm43xx_phy_read(dev, 0x002B)
 						   & 0x00FF) | 0x0024);
-			else {
-				bcm43xx_phy_write(bcm, 0x0061,
-						  bcm43xx_phy_read(bcm, 0x0061)
+			} else {
+				bcm43xx_phy_write(dev, 0x0061,
+						  bcm43xx_phy_read(dev, 0x0061)
 						   | 0x0010);
 				if (phy->rev == 3) {
-					bcm43xx_phy_write(bcm, 0x0093, 0x001D);
-					bcm43xx_phy_write(bcm, 0x0027, 0x0008);
+					bcm43xx_phy_write(dev, 0x0093, 0x001D);
+					bcm43xx_phy_write(dev, 0x0027, 0x0008);
 				} else {
-					bcm43xx_phy_write(bcm, 0x0093, 0x003A);
-					bcm43xx_phy_write(bcm, 0x0027,
-						(bcm43xx_phy_read(bcm, 0x0027)
+					bcm43xx_phy_write(dev, 0x0093, 0x003A);
+					bcm43xx_phy_write(dev, 0x0027,
+						(bcm43xx_phy_read(dev, 0x0027)
 						 & 0x00FF) | 0x0008);
 				}
 			}
 		}
 		break;
 	case BCM43xx_PHYTYPE_B:
-		if (bcm->current_core->rev == 2)
+		if (dev->dev->id.revision == 2)
 			value = (3/*automatic*/ << 7);
 		else
 			value = (antennadiv << 7);
-		bcm43xx_phy_write(bcm, 0x03E2,
-				  (bcm43xx_phy_read(bcm, 0x03E2)
+		bcm43xx_phy_write(dev, 0x03E2,
+				  (bcm43xx_phy_read(dev, 0x03E2)
 				   & 0xFE7F) | value);
 		break;
 	default:
-		assert(0);
+		BCM43xx_WARN_ON(1);
 	}
 
 	if (antennadiv >= 2) {
-		ucodeflags = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
+		ucodeflags = bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED,
 						BCM43xx_UCODEFLAGS_OFFSET);
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
+		bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED,
 				    BCM43xx_UCODEFLAGS_OFFSET,
 				    ucodeflags | BCM43xx_UCODEFLAG_AUTODIV);
 	}
 
 	phy->antenna_diversity = antennadiv;
 }
+
+/* Set the PowerSavingControlBits.
+ * Bitvalues:
+ *   0  => unset the bit
+ *   1  => set the bit
+ *   -1 => calculate the bit
+ */
+void bcm43xx_power_saving_ctl_bits(struct bcm43xx_wldev *dev,
+				   int bit25, int bit26)
+{
+	int i;
+	u32 status;
+
+/* FIXME: Force 25 to off and 26 to on for now: */
+bit25 = 0;
+bit26 = 1;
+
+	if (bit25 == -1) {
+		/* TODO: If powersave is not off and FIXME is not set and we
+		 *	are not in adhoc and thus is not an AP and we arei
+		 *	associated, set bit 25 */
+	}
+	if (bit26 == -1) {
+		/* TODO: If the device is awake or this is an AP, or we are
+		 *	scanning, or FIXME, or we are associated, or FIXME,
+		 *	or the latest PS-Poll packet sent was successful,
+		 *	set bit26  */
+	}
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
+	if (bit25)
+		status |= BCM43xx_SBF_PS1;
+	else
+		status &= ~BCM43xx_SBF_PS1;
+	if (bit26)
+		status |= BCM43xx_SBF_PS2;
+	else
+		status &= ~BCM43xx_SBF_PS2;
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, status);
+	if (bit26 && dev->dev->id.revision >= 5) {
+		for (i = 0; i < 100; i++) {
+			if (bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED, 0x0040)
+			    != 4)
+				break;
+			udelay(10);
+		}
+	}
+}
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_phy.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.h
@@ -7,6 +7,7 @@
                      Michael Buesch <mbuesch at freenet.de>
                      Danny van Dyk <kugelfang at gentoo.org>
                      Andreas Jaggi <andreas.jaggi at waterwave.ch>
+  Copyright (c) 2007 Larry Finger <Larry.Finger at lwfinger.net>
 
   Some parts of the code in this file are derived from the ipw2200
   driver  Copyright(c) 2003 - 2004 Intel Corporation.
@@ -33,15 +34,148 @@
 
 #include <linux/types.h>
 
-struct bcm43xx_private;
+enum {
+	BCM43xx_ANTENNA0,	/* Antenna 0 */
+	BCM43xx_ANTENNA1,	/* Antenna 0 */
+	BCM43xx_ANTENNA_AUTO1,	/* Automatic, starting with antenna 1 */
+	BCM43xx_ANTENNA_AUTO0,	/* Automatic, starting with antenna 0 */
+
+	BCM43xx_ANTENNA_AUTO	= BCM43xx_ANTENNA_AUTO0,
+	BCM43xx_ANTENNA_DEFAULT = BCM43xx_ANTENNA_AUTO,
+};
+
+enum {
+	BCM43xx_INTERFMODE_NONE,
+	BCM43xx_INTERFMODE_NONWLAN,
+	BCM43xx_INTERFMODE_MANUALWLAN,
+	BCM43xx_INTERFMODE_AUTOWLAN,
+};
+
+/*** PHY Registers ***/
+
+/* Routing */
+#define BCM43xx_PHYROUTE_OFDM_GPHY	0x400
+#define BCM43xx_PHYROUTE_EXT_GPHY	0x800
+
+/* Base registers. */
+#define BCM43xx_PHY_BASE(reg)	(reg)
+/* OFDM (A) registers of a G-PHY */
+#define BCM43xx_PHY_OFDM(reg)	((reg) | BCM43xx_PHYROUTE_OFDM_GPHY)
+/* Extended G-PHY registers */
+#define BCM43xx_PHY_EXTG(reg)	((reg) | BCM43xx_PHYROUTE_EXT_GPHY)
+
+
+/* Extended G-PHY Registers */
+#define BCM43xx_PHY_CLASSCTL		BCM43xx_PHY_EXTG(0x02)	/* Classify control */
+#define BCM43xx_PHY_GTABCTL		BCM43xx_PHY_EXTG(0x03)	/* G-PHY table control (see below) */
+#define  BCM43xx_PHY_GTABOFF		0x03FF			/* G-PHY table offset (see below) */
+#define  BCM43xx_PHY_GTABNR		0xFC00			/* G-PHY table number (see below) */
+#define  BCM43xx_PHY_GTABNR_SHIFT	10
+#define BCM43xx_PHY_GTABDATA		BCM43xx_PHY_EXTG(0x04)	/* G-PHY table data */
+#define BCM43xx_PHY_LO_MASK		BCM43xx_PHY_EXTG(0x0F)	/* Local Oscillator control mask */
+#define BCM43xx_PHY_LO_CTL		BCM43xx_PHY_EXTG(0x10)	/* Local Oscillator control */
+#define BCM43xx_PHY_RFOVER		BCM43xx_PHY_EXTG(0x11)	/* RF override */
+#define BCM43xx_PHY_RFOVERVAL		BCM43xx_PHY_EXTG(0x12)	/* RF override value */
+/*** OFDM table numbers ***/
+#define BCM43xx_OFDMTAB(number, offset)	(((number) << BCM43xx_PHY_OTABLENR_SHIFT) | (offset))
+#define BCM43xx_OFDMTAB_AGC1		BCM43xx_OFDMTAB(0x00, 0)
+#define BCM43xx_OFDMTAB_GAIN0		BCM43xx_OFDMTAB(0x00, 0)
+#define BCM43xx_OFDMTAB_GAINX		BCM43xx_OFDMTAB(0x01, 0)
+#define BCM43xx_OFDMTAB_GAIN1		BCM43xx_OFDMTAB(0x01, 4)
+#define BCM43xx_OFDMTAB_AGC3		BCM43xx_OFDMTAB(0x02, 0)
+#define BCM43xx_OFDMTAB_GAIN2		BCM43xx_OFDMTAB(0x02, 3)
+#define BCM43xx_OFDMTAB_LNAHPFGAIN1	BCM43xx_OFDMTAB(0x03, 0)
+#define BCM43xx_OFDMTAB_WRSSI		BCM43xx_OFDMTAB(0x04, 0)
+#define BCM43xx_OFDMTAB_LNAHPFGAIN2	BCM43xx_OFDMTAB(0x04, 0)
+#define BCM43xx_OFDMTAB_NOISESCALE	BCM43xx_OFDMTAB(0x05, 0)
+#define BCM43xx_OFDMTAB_AGC2		BCM43xx_OFDMTAB(0x06, 0)
+#define BCM43xx_OFDMTAB_ROTOR		BCM43xx_OFDMTAB(0x08, 0)
+#define BCM43xx_OFDMTAB_ADVRETARD	BCM43xx_OFDMTAB(0x09, 0)
+#define BCM43xx_OFDMTAB_DAC		BCM43xx_OFDMTAB(0x0C, 0)
+#define BCM43xx_OFDMTAB_DC		BCM43xx_OFDMTAB(0x0E, 7)
+#define BCM43xx_OFDMTAB_PWRDYN2		BCM43xx_OFDMTAB(0x0E, 12)
+#define BCM43xx_OFDMTAB_LNAGAIN		BCM43xx_OFDMTAB(0x0E, 13)
+
+#define BCM43xx_OFDMTAB_LPFGAIN		BCM43xx_OFDMTAB(0x0F, 12)
+#define BCM43xx_OFDMTAB_RSSI		BCM43xx_OFDMTAB(0x10, 0)
+
+#define BCM43xx_OFDMTAB_AGC1_R1		BCM43xx_OFDMTAB(0x13, 0)
+#define BCM43xx_OFDMTAB_GAINX_R1	BCM43xx_OFDMTAB(0x14, 0)
+#define BCM43xx_OFDMTAB_MINSIGSQ	BCM43xx_OFDMTAB(0x14, 1)
+#define BCM43xx_OFDMTAB_AGC3_R1		BCM43xx_OFDMTAB(0x15, 0)
+#define BCM43xx_OFDMTAB_WRSSI_R1	BCM43xx_OFDMTAB(0x15, 4)
+#define BCM43xx_OFDMTAB_TSSI		BCM43xx_OFDMTAB(0x15, 0)
+#define BCM43xx_OFDMTAB_DACRFPABB	BCM43xx_OFDMTAB(0x16, 0)
+#define BCM43xx_OFDMTAB_DACOFF		BCM43xx_OFDMTAB(0x17, 0)
+#define BCM43xx_OFDMTAB_DCBIAS		BCM43xx_OFDMTAB(0x18, 0)
+
+void bcm43xx_put_attenuation_into_ranges(int *_bbatt, int *_rfatt);
+
+/* OFDM (A) PHY Registers */
+#define BCM43xx_PHY_VERSION_OFDM	BCM43xx_PHY_OFDM(0x00)	/* Versioning register for A-PHY */
+#define BCM43xx_PHY_BBANDCFG		BCM43xx_PHY_OFDM(0x01)	/* Baseband config */
+#define  BCM43xx_PHY_BBANDCFG_RXANT	0x180			/* RX Antenna selection */
+#define  BCM43xx_PHY_BBANDCFG_RXANT_SHIFT	7
+#define BCM43xx_PHY_PWRDOWN		BCM43xx_PHY_OFDM(0x03)	/* Powerdown */
+#define BCM43xx_PHY_CRSTHRES1		BCM43xx_PHY_OFDM(0x06)	/* CRS Threshold 1 */
+#define BCM43xx_PHY_LNAHPFCTL		BCM43xx_PHY_OFDM(0x1C)	/* LNA/HPF control */
+#define BCM43xx_PHY_ADIVRELATED		BCM43xx_PHY_OFDM(0x27)	/* FIXME rename */
+#define BCM43xx_PHY_CRS0		BCM43xx_PHY_OFDM(0x29)
+#define BCM43xx_PHY_ANTDWELL		BCM43xx_PHY_OFDM(0x2B)	/* Antenna dwell */
+#define  BCM43xx_PHY_ANTDWELL_AUTODIV1	0x0100			/* Automatic RX diversity start antenna */
+#define BCM43xx_PHY_ENCORE		BCM43xx_PHY_OFDM(0x49)	/* "Encore" (RangeMax / BroadRange) */
+#define  BCM43xx_PHY_ENCORE_EN		0x0200			/* Encore enable */
+#define BCM43xx_PHY_LMS			BCM43xx_PHY_OFDM(0x55)
+#define BCM43xx_PHY_OFDM61		BCM43xx_PHY_OFDM(0x61)	/* FIXME rename */
+#define  BCM43xx_PHY_OFDM61_10		0x0010			/* FIXME rename */
+#define BCM43xx_PHY_IQBAL		BCM43xx_PHY_OFDM(0x69)	/* I/Q balance */
+#define BCM43xx_PHY_OTABLECTL		BCM43xx_PHY_OFDM(0x72)	/* OFDM table control (see below) */
+#define  BCM43xx_PHY_OTABLEOFF		0x03FF			/* OFDM table offset (see below) */
+#define  BCM43xx_PHY_OTABLENR		0xFC00			/* OFDM table number (see below) */
+#define  BCM43xx_PHY_OTABLENR_SHIFT	10
+#define BCM43xx_PHY_OTABLEI		BCM43xx_PHY_OFDM(0x73)	/* OFDM table data I */
+#define BCM43xx_PHY_OTABLEQ		BCM43xx_PHY_OFDM(0x74)	/* OFDM table data Q */
+#define BCM43xx_PHY_HPWR_TSSICTL	BCM43xx_PHY_OFDM(0x78)	/* Hardware power TSSI control */
+#define BCM43xx_PHY_NRSSITHRES		BCM43xx_PHY_OFDM(0x8A)	/* NRSSI threshold */
+#define BCM43xx_PHY_ANTWRSETT		BCM43xx_PHY_OFDM(0x8C)	/* Antenna WR settle */
+#define  BCM43xx_PHY_ANTWRSETT_ARXDIV	0x2000			/* Automatic RX diversity enabled */
+#define BCM43xx_PHY_CLIPPWRDOWNT	BCM43xx_PHY_OFDM(0x93)	/* Clip powerdown threshold */
+#define BCM43xx_PHY_OFDM9B		BCM43xx_PHY_OFDM(0x9B)	/* FIXME rename */
+#define BCM43xx_PHY_N1P1GAIN		BCM43xx_PHY_OFDM(0xA0)
+#define BCM43xx_PHY_P1P2GAIN		BCM43xx_PHY_OFDM(0xA1)
+#define BCM43xx_PHY_N1N2GAIN		BCM43xx_PHY_OFDM(0xA2)
+#define BCM43xx_PHY_CLIPTHRES		BCM43xx_PHY_OFDM(0xA3)
+#define BCM43xx_PHY_CLIPN1P2THRES	BCM43xx_PHY_OFDM(0xA4)
+#define BCM43xx_PHY_DIVSRCHIDX		BCM43xx_PHY_OFDM(0xA8)	/* Divider search gain/index */
+#define BCM43xx_PHY_CLIPP2THRES		BCM43xx_PHY_OFDM(0xA9)
+#define BCM43xx_PHY_CLIPP3THRES		BCM43xx_PHY_OFDM(0xAA)
+#define BCM43xx_PHY_DIVP1P2GAIN		BCM43xx_PHY_OFDM(0xAB)
+#define BCM43xx_PHY_DIVSRCHGAINBACK	BCM43xx_PHY_OFDM(0xAD)	/* Divider search gain back */
+#define BCM43xx_PHY_DIVSRCHGAINCHNG	BCM43xx_PHY_OFDM(0xAE)	/* Divider search gain change */
+#define BCM43xx_PHY_CRSTHRES1_R1	BCM43xx_PHY_OFDM(0xC0)	/* CRS Threshold 1 (rev 1 only) */
+#define BCM43xx_PHY_CRSTHRES2_R1	BCM43xx_PHY_OFDM(0xC1)	/* CRS Threshold 2 (rev 1 only) */
+#define BCM43xx_PHY_TSSIP_LTBASE	BCM43xx_PHY_OFDM(0x380)	/* TSSI power lookup table base */
+#define BCM43xx_PHY_DC_LTBASE		BCM43xx_PHY_OFDM(0x3A0)	/* DC lookup table base */
+#define BCM43xx_PHY_GAIN_LTBASE		BCM43xx_PHY_OFDM(0x3C0)	/* Gain lookup table base */
+
+void bcm43xx_put_attenuation_into_ranges(int *_bbatt, int *_rfatt);
+
+/* Masks for the different PHY versioning registers. */
+#define BCM43xx_PHYVER_ANALOG		0xF000
+#define BCM43xx_PHYVER_ANALOG_SHIFT	12
+#define BCM43xx_PHYVER_TYPE		0x0F00
+#define BCM43xx_PHYVER_TYPE_SHIFT	8
+#define BCM43xx_PHYVER_VERSION		0x00FF
 
-void bcm43xx_raw_phy_lock(struct bcm43xx_private *bcm);
+struct bcm43xx_wldev;
+
+void bcm43xx_raw_phy_lock(struct bcm43xx_wldev *dev);
 #define bcm43xx_phy_lock(bcm, flags) \
 	do {					\
 		local_irq_save(flags);		\
 		bcm43xx_raw_phy_lock(bcm);	\
 	} while (0)
-void bcm43xx_raw_phy_unlock(struct bcm43xx_private *bcm);
+void bcm43xx_raw_phy_unlock(struct bcm43xx_wldev *dev);
 #define bcm43xx_phy_unlock(bcm, flags) \
 	do {					\
 		bcm43xx_raw_phy_unlock(bcm);	\
@@ -50,29 +184,34 @@ void bcm43xx_raw_phy_unlock(struct bcm43
 
 /* Card uses the loopback gain stuff */
 #define has_loopback_gain(phy) \
-        (((phy)->rev > 1) || ((phy)->connected))
+	(((phy)->rev > 1) || ((phy)->gmode))
+
+u16 bcm43xx_phy_read(struct bcm43xx_wldev *dev, u16 offset);
+void bcm43xx_phy_write(struct bcm43xx_wldev *dev, u16 offset, u16 val);
 
-u16 bcm43xx_phy_read(struct bcm43xx_private *bcm, u16 offset);
-void bcm43xx_phy_write(struct bcm43xx_private *bcm, u16 offset, u16 val);
+int bcm43xx_phy_init_tssi2dbm_table(struct bcm43xx_wldev *dev);
+int bcm43xx_phy_init(struct bcm43xx_wldev *dev);
 
-int bcm43xx_phy_init_tssi2dbm_table(struct bcm43xx_private *bcm);
-int bcm43xx_phy_init(struct bcm43xx_private *bcm);
+void bcm43xx_set_rx_antenna(struct bcm43xx_wldev *dev, int antenna);
 
-void bcm43xx_phy_set_antenna_diversity(struct bcm43xx_private *bcm);
-void bcm43xx_phy_calibrate(struct bcm43xx_private *bcm);
-int bcm43xx_phy_connect(struct bcm43xx_private *bcm, int connect);
+void bcm43xx_phy_set_antenna_diversity(struct bcm43xx_wldev *dev);
+void bcm43xx_phy_calibrate(struct bcm43xx_wldev *dev);
+int bcm43xx_phy_connect(struct bcm43xx_wldev *dev, int connect);
 
-void bcm43xx_phy_lo_b_measure(struct bcm43xx_private *bcm);
-void bcm43xx_phy_lo_g_measure(struct bcm43xx_private *bcm);
-void bcm43xx_phy_xmitpower(struct bcm43xx_private *bcm);
+void bcm43xx_phy_lo_b_measure(struct bcm43xx_wldev *dev);
+void bcm43xx_phy_lo_g_measure(struct bcm43xx_wldev *dev);
+void bcm43xx_phy_xmitpower(struct bcm43xx_wldev *dev);
 
 /* Adjust the LocalOscillator to the saved values.
  * "fixed" is only set to 1 once in initialization. Set to 0 otherwise.
  */
-void bcm43xx_phy_lo_adjust(struct bcm43xx_private *bcm, int fixed);
-void bcm43xx_phy_lo_mark_all_unused(struct bcm43xx_private *bcm);
+void bcm43xx_phy_lo_adjust(struct bcm43xx_wldev *dev, int fixed);
+void bcm43xx_phy_lo_mark_all_unused(struct bcm43xx_wldev *dev);
 
-void bcm43xx_phy_set_baseband_attenuation(struct bcm43xx_private *bcm,
+void bcm43xx_phy_set_baseband_attenuation(struct bcm43xx_wldev *dev,
 					  u16 baseband_attenuation);
 
+void bcm43xx_power_saving_ctl_bits(struct bcm43xx_wldev *dev,
+				   int bit25, int bit26);
+
 #endif /* BCM43xx_PHY_H_ */



From Larry.Finger at lwfinger.net  Thu Aug  2 17:53:40 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:53:40 -0500
Subject: [RFC 5/10] Port of bcm43xx from softmac to mac80211
Message-ID: <46b1fe04.IfveQgM5dSl8zU22%Larry.Finger@lwfinger.net>

This if file 5 of 10 of the port of the bcm43xx driver from softmac
to mac80211.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -1,32 +1,33 @@
 /*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
+ *
+ *  Broadcom BCM43xx wireless driver
+ *
+ *  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>
+ *  Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+ *  Copyright (c) 2005, 2006 Michael Buesch <mb at bu3sch.de>
+ *  Copyright (c) 2005 Danny van Dyk <kugelfang at gentoo.org>
+ *  Copyright (c) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+ *  Copyright (c) 2007 Larry Finger <Larry.Finger at lwfinger.net>
+ *
+ *  Some parts of the code in this file are derived from the ipw2200
+ *  driver  Copyright(c) 2003 - 2004 Intel Corporation.
+
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ *
+ */
 
 #include <linux/delay.h>
 #include <linux/init.h>
@@ -39,20 +40,17 @@
 #include <linux/workqueue.h>
 #include <linux/skbuff.h>
 #include <linux/dma-mapping.h>
-#include <net/iw_handler.h>
+#include <net/dst.h>
 
 #include "bcm43xx.h"
 #include "bcm43xx_main.h"
 #include "bcm43xx_debugfs.h"
-#include "bcm43xx_radio.h"
 #include "bcm43xx_phy.h"
 #include "bcm43xx_dma.h"
 #include "bcm43xx_pio.h"
-#include "bcm43xx_power.h"
-#include "bcm43xx_wx.h"
-#include "bcm43xx_ethtool.h"
-#include "bcm43xx_xmit.h"
 #include "bcm43xx_sysfs.h"
+#include "bcm43xx_xmit.h"
+#include "bcm43xx_radio.h"
 
 
 MODULE_DESCRIPTION("Broadcom BCM43xx wireless driver");
@@ -83,80 +81,177 @@ static int modparam_long_retry = BCM43xx
 module_param_named(long_retry, modparam_long_retry, int, 0444);
 MODULE_PARM_DESC(long_retry, "Long-Retry-Limit (0 - 15)");
 
-static int modparam_locale = -1;
-module_param_named(locale, modparam_locale, int, 0444);
-MODULE_PARM_DESC(country, "Select LocaleCode 0-11 (For travelers)");
-
 static int modparam_noleds;
 module_param_named(noleds, modparam_noleds, int, 0444);
 MODULE_PARM_DESC(noleds, "Turn off all LED activity");
 
-static char modparam_fwpostfix[64];
-module_param_string(fwpostfix, modparam_fwpostfix, 64, 0444);
-MODULE_PARM_DESC(fwpostfix, "Postfix for .fw files. Useful for using multiple firmware image versions.");
+static char modparam_fwpostfix[16] = {".fw3"};
+module_param_string(fwpostfix, modparam_fwpostfix, 16, 0444);
+MODULE_PARM_DESC(fwpostfix, "Postfix for the .fw files to load.");
+
+static int modparam_mon_keep_bad;
+module_param_named(mon_keep_bad, modparam_mon_keep_bad, int, 0444);
+MODULE_PARM_DESC(mon_keep_bad, "Keep bad frames in monitor mode");
+
+static int modparam_mon_keep_badplcp;
+module_param_named(mon_keep_badplcp, modparam_mon_keep_bad, int, 0444);
+MODULE_PARM_DESC(mon_keep_badplcp, "Keep frames with bad PLCP in monitor mode");
+
+
+static const struct ssb_device_id bcm43xx_ssb_tbl[] = {
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, SSB_ANY_REV),
+	SSB_DEVTABLE_END
+};
+MODULE_DEVICE_TABLE(ssb, bcm43xx_ssb_tbl);
 
 
-/* If you want to debug with just a single device, enable this,
- * where the string is the pci device ID (as given by the kernel's
- * pci_name function) of the device to be used.
- */
-//#define DEBUG_SINGLE_DEVICE_ONLY	"0001:11:00.0"
+/* Channel and ratetables are shared for all devices.
+ * They can't be const, because ieee80211 puts some precalculated
+ * data in there. This data is the same for all devices, so we don't
+ * get concurrency issues */
+#define RATETAB_ENT(_rateid, _flags) \
+	{							\
+		.rate	= BCM43xx_RATE_TO_100KBPS(_rateid),	\
+		.val	= (_rateid),				\
+		.val2	= (_rateid),				\
+		.flags	= (_flags),				\
+	}
+static struct ieee80211_rate __bcm43xx_ratetable[] = {
+	RATETAB_ENT(BCM43xx_CCK_RATE_1MB, IEEE80211_RATE_CCK),
+	RATETAB_ENT(BCM43xx_CCK_RATE_2MB, IEEE80211_RATE_CCK_2),
+	RATETAB_ENT(BCM43xx_CCK_RATE_5MB, IEEE80211_RATE_CCK_2),
+	RATETAB_ENT(BCM43xx_CCK_RATE_11MB, IEEE80211_RATE_CCK_2),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_6MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_9MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_12MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_18MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_24MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_36MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_48MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_54MB, IEEE80211_RATE_OFDM),
+};
+#define bcm43xx_a_ratetable		(__bcm43xx_ratetable + 4)
+#define bcm43xx_a_ratetable_size	8
+#define bcm43xx_b_ratetable		(__bcm43xx_ratetable + 0)
+#define bcm43xx_b_ratetable_size	4
+#define bcm43xx_g_ratetable		(__bcm43xx_ratetable + 0)
+#define bcm43xx_g_ratetable_size	12
+
+#define CHANTAB_ENT(_chanid, _freq) \
+	{							\
+		.chan	= (_chanid),				\
+		.freq	= (_freq),				\
+		.val	= (_chanid),				\
+		.flag	= IEEE80211_CHAN_W_SCAN |		\
+			  IEEE80211_CHAN_W_ACTIVE_SCAN |	\
+			  IEEE80211_CHAN_W_IBSS,		\
+		.power_level	= 0xFF,				\
+		.antenna_max	= 0xFF,				\
+	}
+static struct ieee80211_channel bcm43xx_bg_chantable[] = {
+	CHANTAB_ENT(1, 2412),
+	CHANTAB_ENT(2, 2417),
+	CHANTAB_ENT(3, 2422),
+	CHANTAB_ENT(4, 2427),
+	CHANTAB_ENT(5, 2432),
+	CHANTAB_ENT(6, 2437),
+	CHANTAB_ENT(7, 2442),
+	CHANTAB_ENT(8, 2447),
+	CHANTAB_ENT(9, 2452),
+	CHANTAB_ENT(10, 2457),
+	CHANTAB_ENT(11, 2462),
+	CHANTAB_ENT(12, 2467),
+	CHANTAB_ENT(13, 2472),
+	CHANTAB_ENT(14, 2484),
+};
+#define bcm43xx_bg_chantable_size	ARRAY_SIZE(bcm43xx_bg_chantable)
 
-/* If you want to enable printing of each MMIO access, enable this. */
-//#define DEBUG_ENABLE_MMIO_PRINT
+static void bcm43xx_wireless_core_exit(struct bcm43xx_wldev *dev);
+static int bcm43xx_wireless_core_init(struct bcm43xx_wldev *dev);
+static void bcm43xx_wireless_core_stop(struct bcm43xx_wldev *dev);
+static int bcm43xx_wireless_core_start(struct bcm43xx_wldev *dev);
 
-/* If you want to enable printing of MMIO access within
- * ucode/pcm upload, initvals write, enable this.
- */
-//#define DEBUG_ENABLE_UCODE_MMIO_PRINT
 
-/* If you want to enable printing of PCI Config Space access, enable this */
-//#define DEBUG_ENABLE_PCILOG
+static int bcm43xx_ratelimit(struct bcm43xx_wl *wl)
+{
+	if (!wl || !wl->current_dev)
+		return 1;
+	if (bcm43xx_status(wl->current_dev) < BCM43xx_STAT_STARTED)
+		return 1;
+	/* We are up and running.
+	 * Ratelimit the messages to avoid DoS over the net. */
+	return net_ratelimit();
+}
+
+void bcminfo(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
 
+	if (!bcm43xx_ratelimit(wl))
+		return;
+	va_start(args, fmt);
+	printk(KERN_INFO "bcm43xx-%s: ",
+	       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : "wlan");
+	vprintk(fmt, args);
+	va_end(args);
+}
 
-/* Detailed list maintained at:
- * http://openfacts.berlios.de/index-en.phtml?title=Bcm43xxDevices
- */
-	static struct pci_device_id bcm43xx_pci_tbl[] = {
-	/* Broadcom 4303 802.11b */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4301, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4307 802.11b */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4307, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4311 802.11(a)/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4311, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4312 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4312, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4318 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4318, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4319 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4319, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4306 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4320, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4306 802.11a */
-//	{ PCI_VENDOR_ID_BROADCOM, 0x4321, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4309 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4324, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 43XG 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4325, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ 0 },
-};
-MODULE_DEVICE_TABLE(pci, bcm43xx_pci_tbl);
+void bcmerr(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
+
+	if (!bcm43xx_ratelimit(wl))
+		return;
+	va_start(args, fmt);
+	printk(KERN_ERR "bcm43xx-%s ERROR: ",
+	       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : "wlan");
+	vprintk(fmt, args);
+	va_end(args);
+}
+
+void bcmwarn(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
+
+	if (!bcm43xx_ratelimit(wl))
+		return;
+	va_start(args, fmt);
+	printk(KERN_WARNING "bcm43xx-%s warning: ",
+	       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : "wlan");
+	vprintk(fmt, args);
+	va_end(args);
+}
+
+#if BCM43xx_DEBUG
+void bcmdbg(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	printk(KERN_DEBUG "bcm43xx-%s debug: ",
+	       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : "wlan");
+	vprintk(fmt, args);
+	va_end(args);
+}
+#endif /* DEBUG */
 
-static void bcm43xx_ram_write(struct bcm43xx_private *bcm, u16 offset, u32 val)
+static void bcm43xx_ram_write(struct bcm43xx_wldev *dev, u16 offset, u32 val)
 {
 	u32 status;
 
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	if (!(status & BCM43xx_SBF_XFER_REG_BYTESWAP))
+	BCM43xx_WARN_ON(offset % 4 != 0);
+
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
+	if (status & BCM43xx_SBF_XFER_REG_BYTESWAP)
 		val = swab32(val);
 
-	bcm43xx_write32(bcm, BCM43xx_MMIO_RAM_CONTROL, offset);
+	bcm43xx_write32(dev, BCM43xx_MMIO_RAM_CONTROL, offset);
 	mmiowb();
-	bcm43xx_write32(bcm, BCM43xx_MMIO_RAM_DATA, val);
+	bcm43xx_write32(dev, BCM43xx_MMIO_RAM_DATA, val);
 }
 
 static inline
-void bcm43xx_shm_control_word(struct bcm43xx_private *bcm,
+void bcm43xx_shm_control_word(struct bcm43xx_wldev *dev,
 			      u16 routing, u16 offset)
 {
 	u32 control;
@@ -166,100 +261,134 @@ void bcm43xx_shm_control_word(struct bcm
 	control = routing;
 	control <<= 16;
 	control |= offset;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_CONTROL, control);
+	bcm43xx_write32(dev, BCM43xx_MMIO_SHM_CONTROL, control);
 }
 
-u32 bcm43xx_shm_read32(struct bcm43xx_private *bcm,
+u32 bcm43xx_shm_read32(struct bcm43xx_wldev *dev,
 		       u16 routing, u16 offset)
 {
 	u32 ret;
 
 	if (routing == BCM43xx_SHM_SHARED) {
+		BCM43xx_WARN_ON((offset & 0x0001) != 0);
 		if (offset & 0x0003) {
 			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset >> 2);
-			ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED);
+			bcm43xx_shm_control_word(dev, routing, offset >> 2);
+			ret = bcm43xx_read16(dev,
+					     BCM43xx_MMIO_SHM_DATA_UNALIGNED);
 			ret <<= 16;
-			bcm43xx_shm_control_word(bcm, routing, (offset >> 2) + 1);
-			ret |= bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA);
+			bcm43xx_shm_control_word(dev, routing,
+						 (offset >> 2) + 1);
+			ret |= bcm43xx_read16(dev,
+					      BCM43xx_MMIO_SHM_DATA);
 
 			return ret;
 		}
 		offset >>= 2;
 	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	ret = bcm43xx_read32(bcm, BCM43xx_MMIO_SHM_DATA);
+	bcm43xx_shm_control_word(dev, routing, offset);
+	ret = bcm43xx_read32(dev, BCM43xx_MMIO_SHM_DATA);
 
 	return ret;
 }
 
-u16 bcm43xx_shm_read16(struct bcm43xx_private *bcm,
+u16 bcm43xx_shm_read16(struct bcm43xx_wldev *dev,
 		       u16 routing, u16 offset)
 {
 	u16 ret;
 
 	if (routing == BCM43xx_SHM_SHARED) {
+		BCM43xx_WARN_ON((offset & 0x0001) != 0);
 		if (offset & 0x0003) {
 			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset >> 2);
-			ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED);
+			bcm43xx_shm_control_word(dev, routing, offset >> 2);
+			ret = bcm43xx_read16(dev,
+					     BCM43xx_MMIO_SHM_DATA_UNALIGNED);
 
 			return ret;
 		}
 		offset >>= 2;
 	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA);
+	bcm43xx_shm_control_word(dev, routing, offset);
+	ret = bcm43xx_read16(dev, BCM43xx_MMIO_SHM_DATA);
 
 	return ret;
 }
 
-void bcm43xx_shm_write32(struct bcm43xx_private *bcm,
+void bcm43xx_shm_write32(struct bcm43xx_wldev *dev,
 			 u16 routing, u16 offset,
 			 u32 value)
 {
 	if (routing == BCM43xx_SHM_SHARED) {
+		BCM43xx_WARN_ON((offset & 0x0001) != 0);
 		if (offset & 0x0003) {
 			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset >> 2);
+			bcm43xx_shm_control_word(dev, routing, offset >> 2);
 			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
+			bcm43xx_write16(dev, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
 					(value >> 16) & 0xffff);
 			mmiowb();
-			bcm43xx_shm_control_word(bcm, routing, (offset >> 2) + 1);
+			bcm43xx_shm_control_word(dev, routing,
+						 (offset >> 2) + 1);
 			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA,
+			bcm43xx_write16(dev, BCM43xx_MMIO_SHM_DATA,
 					value & 0xffff);
 			return;
 		}
 		offset >>= 2;
 	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
+	bcm43xx_shm_control_word(dev, routing, offset);
 	mmiowb();
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA, value);
+	bcm43xx_write32(dev, BCM43xx_MMIO_SHM_DATA, value);
 }
 
-void bcm43xx_shm_write16(struct bcm43xx_private *bcm,
+void bcm43xx_shm_write16(struct bcm43xx_wldev *dev,
 			 u16 routing, u16 offset,
 			 u16 value)
 {
 	if (routing == BCM43xx_SHM_SHARED) {
+		BCM43xx_WARN_ON((offset & 0x0001) != 0);
 		if (offset & 0x0003) {
 			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset >> 2);
+			bcm43xx_shm_control_word(dev, routing, offset >> 2);
 			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
+			bcm43xx_write16(dev, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
 					value);
 			return;
 		}
 		offset >>= 2;
 	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
+	bcm43xx_shm_control_word(dev, routing, offset);
 	mmiowb();
-	bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA, value);
+	bcm43xx_write16(dev, BCM43xx_MMIO_SHM_DATA, value);
+}
+
+/* Read HostFlags */
+u32 bcm43xx_hf_read(struct bcm43xx_wldev *dev)
+{
+	u32 ret;
+
+	ret = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				 BCM43xx_SHM_SH_HOSTFHI);
+	ret <<= 16;
+	ret |= bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				  BCM43xx_SHM_SH_HOSTFLO);
+
+	return ret;
+}
+
+/* Write HostFlags */
+void bcm43xx_hf_write(struct bcm43xx_wldev *dev, u32 value)
+{
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_HOSTFLO,
+			    (value & 0x0000FFFF));
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_HOSTFHI,
+			    ((value & 0xFFFF0000) >> 16));
 }
 
-void bcm43xx_tsf_read(struct bcm43xx_private *bcm, u64 *tsf)
+void bcm43xx_tsf_read(struct bcm43xx_wldev *dev, u64 *tsf)
 {
 	/* We need to be careful. As we read the TSF from multiple
 	 * registers, we should take care of register overflows.
@@ -267,13 +396,16 @@ void bcm43xx_tsf_read(struct bcm43xx_pri
 	 * We try to be atomic here, by restaring the read process,
 	 * if any of the high registers changed (overflew).
 	 */
-	if (bcm->current_core->rev >= 3) {
+	if (dev->dev->id.revision >= 3) {
 		u32 low, high, high2;
 
 		do {
-			high = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
-			low = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW);
-			high2 = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
+			high = bcm43xx_read32(dev,
+					      BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
+			low = bcm43xx_read32(dev,
+					     BCM43xx_MMIO_REV3PLUS_TSF_LOW);
+			high2 = bcm43xx_read32(dev,
+					     BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
 		} while (unlikely(high != high2));
 
 		*tsf = high;
@@ -285,14 +417,14 @@ void bcm43xx_tsf_read(struct bcm43xx_pri
 		u16 test1, test2, test3;
 
 		do {
-			v3 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_3);
-			v2 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_2);
-			v1 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_1);
-			v0 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_0);
-
-			test3 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_3);
-			test2 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_2);
-			test1 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_1);
+			v3 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_3);
+			v2 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_2);
+			v1 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_1);
+			v0 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_0);
+
+			test3 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_3);
+			test2 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_2);
+			test1 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_1);
 		} while (v3 != test3 || v2 != test2 || v1 != test1);
 
 		*tsf = v3;
@@ -307,172 +439,159 @@ void bcm43xx_tsf_read(struct bcm43xx_pri
 	}
 }
 
-void bcm43xx_tsf_write(struct bcm43xx_private *bcm, u64 tsf)
+static void bcm43xx_time_lock(struct bcm43xx_wldev *dev)
 {
 	u32 status;
 
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 	status |= BCM43xx_SBF_TIME_UPDATE;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, status);
 	mmiowb();
+}
+
+static void bcm43xx_time_unlock(struct bcm43xx_wldev *dev)
+{
+	u32 status;
 
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
+	status &= ~BCM43xx_SBF_TIME_UPDATE;
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, status);
+}
+
+static void bcm43xx_tsf_write_locked(struct bcm43xx_wldev *dev, u64 tsf)
+{
 	/* Be careful with the in-progress timer.
 	 * First zero out the low register, so we have a full
 	 * register-overflow duration to complete the operation.
 	 */
-	if (bcm->current_core->rev >= 3) {
+	if (dev->dev->id.revision >= 3) {
 		u32 lo = (tsf & 0x00000000FFFFFFFFULL);
 		u32 hi = (tsf & 0xFFFFFFFF00000000ULL) >> 32;
 
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW, 0);
+		bcm43xx_write32(dev, BCM43xx_MMIO_REV3PLUS_TSF_LOW, 0);
 		mmiowb();
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH, hi);
+		bcm43xx_write32(dev, BCM43xx_MMIO_REV3PLUS_TSF_HIGH, hi);
 		mmiowb();
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW, lo);
+		bcm43xx_write32(dev, BCM43xx_MMIO_REV3PLUS_TSF_LOW, lo);
 	} else {
 		u16 v0 = (tsf & 0x000000000000FFFFULL);
 		u16 v1 = (tsf & 0x00000000FFFF0000ULL) >> 16;
 		u16 v2 = (tsf & 0x0000FFFF00000000ULL) >> 32;
 		u16 v3 = (tsf & 0xFFFF000000000000ULL) >> 48;
 
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_0, 0);
+		bcm43xx_write16(dev, BCM43xx_MMIO_TSF_0, 0);
 		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_3, v3);
+		bcm43xx_write16(dev, BCM43xx_MMIO_TSF_3, v3);
 		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_2, v2);
+		bcm43xx_write16(dev, BCM43xx_MMIO_TSF_2, v2);
 		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_1, v1);
+		bcm43xx_write16(dev, BCM43xx_MMIO_TSF_1, v1);
 		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_0, v0);
+		bcm43xx_write16(dev, BCM43xx_MMIO_TSF_0, v0);
 	}
+}
 
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	status &= ~BCM43xx_SBF_TIME_UPDATE;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
+void bcm43xx_tsf_write(struct bcm43xx_wldev *dev, u64 tsf)
+{
+	bcm43xx_time_lock(dev);
+	bcm43xx_tsf_write_locked(dev, tsf);
+	bcm43xx_time_unlock(dev);
 }
 
 static
-void bcm43xx_macfilter_set(struct bcm43xx_private *bcm,
+void bcm43xx_macfilter_set(struct bcm43xx_wldev *dev,
 			   u16 offset,
 			   const u8 *mac)
 {
+	static const u8 zero_addr[ETH_ALEN] = { 0 };
 	u16 data;
 
+	if (!mac)
+		mac = zero_addr;
+
 	offset |= 0x0020;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_CONTROL, offset);
+	bcm43xx_write16(dev, BCM43xx_MMIO_MACFILTER_CONTROL, offset);
 
 	data = mac[0];
 	data |= mac[1] << 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
+	bcm43xx_write16(dev, BCM43xx_MMIO_MACFILTER_DATA, data);
 	data = mac[2];
 	data |= mac[3] << 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
+	bcm43xx_write16(dev, BCM43xx_MMIO_MACFILTER_DATA, data);
 	data = mac[4];
 	data |= mac[5] << 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
-}
-
-static void bcm43xx_macfilter_clear(struct bcm43xx_private *bcm,
-				    u16 offset)
-{
-	const u8 zero_addr[ETH_ALEN] = { 0 };
-
-	bcm43xx_macfilter_set(bcm, offset, zero_addr);
+	bcm43xx_write16(dev, BCM43xx_MMIO_MACFILTER_DATA, data);
 }
 
-static void bcm43xx_write_mac_bssid_templates(struct bcm43xx_private *bcm)
+static void bcm43xx_write_mac_bssid_templates(struct bcm43xx_wldev *dev)
 {
-	const u8 *mac = (const u8 *)(bcm->net_dev->dev_addr);
-	const u8 *bssid = (const u8 *)(bcm->ieee->bssid);
+	static const u8 zero_addr[ETH_ALEN] = { 0 };
+	const u8 *mac = dev->wl->mac_addr;
+	const u8 *bssid = dev->wl->bssid;
 	u8 mac_bssid[ETH_ALEN * 2];
 	int i;
+	u32 tmp;
+
+	if (!bssid)
+		bssid = zero_addr;
+	if (!mac)
+		mac = zero_addr;
+
+	bcm43xx_macfilter_set(dev, BCM43xx_MACFILTER_BSSID, bssid);
 
 	memcpy(mac_bssid, mac, ETH_ALEN);
 	memcpy(mac_bssid + ETH_ALEN, bssid, ETH_ALEN);
 
 	/* Write our MAC address and BSSID to template ram */
-	for (i = 0; i < ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x20 + i, *((u32 *)(mac_bssid + i)));
-	for (i = 0; i < ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x78 + i, *((u32 *)(mac_bssid + i)));
-	for (i = 0; i < ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x478 + i, *((u32 *)(mac_bssid + i)));
-}
-
-//FIXME: Well, we should probably call them from somewhere.
-#if 0
-static void bcm43xx_set_slot_time(struct bcm43xx_private *bcm, u16 slot_time)
-{
-	/* slot_time is in usec. */
-	if (bcm43xx_current_phy(bcm)->type != BCM43xx_PHYTYPE_G)
-		return;
-	bcm43xx_write16(bcm, 0x684, 510 + slot_time);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0010, slot_time);
+	for (i = 0; i < ARRAY_SIZE(mac_bssid); i += sizeof(u32)) {
+		tmp =  (u32)(mac_bssid[i + 0]);
+		tmp |= (u32)(mac_bssid[i + 1]) << 8;
+		tmp |= (u32)(mac_bssid[i + 2]) << 16;
+		tmp |= (u32)(mac_bssid[i + 3]) << 24;
+		bcm43xx_ram_write(dev, 0x20 + i, tmp);
+		bcm43xx_ram_write(dev, 0x78 + i, tmp);
+		bcm43xx_ram_write(dev, 0x478 + i, tmp);
+	}
 }
 
-static void bcm43xx_short_slot_timing_enable(struct bcm43xx_private *bcm)
+static void bcm43xx_upload_card_macaddress(struct bcm43xx_wldev *dev,
+					   const u8 *mac_addr)
 {
-	bcm43xx_set_slot_time(bcm, 9);
+	dev->wl->mac_addr = mac_addr;
+	bcm43xx_write_mac_bssid_templates(dev);
+	bcm43xx_macfilter_set(dev, BCM43xx_MACFILTER_SELF, mac_addr);
 }
 
-static void bcm43xx_short_slot_timing_disable(struct bcm43xx_private *bcm)
+static void bcm43xx_set_slot_time(struct bcm43xx_wldev *dev, u16 slot_time)
 {
-	bcm43xx_set_slot_time(bcm, 20);
+	/* slot_time is in usec. */
+	if (dev->phy.type != BCM43xx_PHYTYPE_G)
+		return;
+	bcm43xx_write16(dev, 0x684, 510 + slot_time);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0010, slot_time);
 }
-#endif
 
-/* FIXME: To get the MAC-filter working, we need to implement the
- *        following functions (and rename them :)
- */
-#if 0
-static void bcm43xx_disassociate(struct bcm43xx_private *bcm)
+static void bcm43xx_short_slot_timing_enable(struct bcm43xx_wldev *dev)
 {
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_macfilter_clear(bcm, BCM43xx_MACFILTER_ASSOC);
-
-	bcm43xx_ram_write(bcm, 0x0026, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0028, 0x0000);
-	bcm43xx_ram_write(bcm, 0x007E, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0080, 0x0000);
-	bcm43xx_ram_write(bcm, 0x047E, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0480, 0x0000);
-
-	if (bcm->current_core->rev < 3) {
-		bcm43xx_write16(bcm, 0x0610, 0x8000);
-		bcm43xx_write16(bcm, 0x060E, 0x0000);
-	} else
-		bcm43xx_write32(bcm, 0x0188, 0x80000000);
-
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0004, 0x000003ff);
-
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_G &&
-	    ieee80211_is_ofdm_rate(bcm->softmac->txrates.default_rate))
-		bcm43xx_short_slot_timing_enable(bcm);
-
-	bcm43xx_mac_enable(bcm);
+	bcm43xx_set_slot_time(dev, 9);
+	dev->short_slot = 1;
 }
 
-static void bcm43xx_associate(struct bcm43xx_private *bcm,
-			      const u8 *mac)
+static void bcm43xx_short_slot_timing_disable(struct bcm43xx_wldev *dev)
 {
-	memcpy(bcm->ieee->bssid, mac, ETH_ALEN);
-
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_macfilter_set(bcm, BCM43xx_MACFILTER_ASSOC, mac);
-	bcm43xx_write_mac_bssid_templates(bcm);
-	bcm43xx_mac_enable(bcm);
+	bcm43xx_set_slot_time(dev, 20);
+	dev->short_slot = 0;
 }
-#endif
 
 /* Enable a Generic IRQ. "mask" is the mask of which IRQs to enable.
  * Returns the _previously_ enabled IRQ mask.
  */
-static inline u32 bcm43xx_interrupt_enable(struct bcm43xx_private *bcm, u32 mask)
+static inline u32 bcm43xx_interrupt_enable(struct bcm43xx_wldev *dev, u32 mask)
 {
 	u32 old_mask;
 
-	old_mask = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask | mask);
+	old_mask = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
+	bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask | mask);
 
 	return old_mask;
 }
@@ -480,12 +599,12 @@ static inline u32 bcm43xx_interrupt_enab
 /* Disable a Generic IRQ. "mask" is the mask of which IRQs to disable.
  * Returns the _previously_ enabled IRQ mask.
  */
-static inline u32 bcm43xx_interrupt_disable(struct bcm43xx_private *bcm, u32 mask)
+static inline u32 bcm43xx_interrupt_disable(struct bcm43xx_wldev *dev, u32 mask)
 {
 	u32 old_mask;
 
-	old_mask = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask & ~mask);
+	old_mask = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
+	bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask & ~mask);
 
 	return old_mask;
 }
@@ -494,982 +613,364 @@ static inline u32 bcm43xx_interrupt_disa
  * IRQs must be masked before calling this.
  * This must not be called with the irq_lock held.
  */
-static void bcm43xx_synchronize_irq(struct bcm43xx_private *bcm)
-{
-	synchronize_irq(bcm->irq);
-	tasklet_disable(&bcm->isr_tasklet);
-}
-
-/* Make sure we don't receive more data from the device. */
-static int bcm43xx_disable_interrupts_sync(struct bcm43xx_private *bcm)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (unlikely(bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)) {
-		spin_unlock_irqrestore(&bcm->irq_lock, flags);
-		return -EBUSY;
-	}
-	bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-	bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK); /* flush */
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	bcm43xx_synchronize_irq(bcm);
-
-	return 0;
-}
-
-static int bcm43xx_read_radioinfo(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u32 radio_id;
-	u16 manufact;
-	u16 version;
-	u8 revision;
-
-	if (bcm->chip_id == 0x4317) {
-		if (bcm->chip_rev == 0x00)
-			radio_id = 0x3205017F;
-		else if (bcm->chip_rev == 0x01)
-			radio_id = 0x4205017F;
-		else
-			radio_id = 0x5205017F;
-	} else {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, BCM43xx_RADIOCTL_ID);
-		radio_id = bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_DATA_HIGH);
-		radio_id <<= 16;
-		bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, BCM43xx_RADIOCTL_ID);
-		radio_id |= bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_DATA_LOW);
-	}
-
-	manufact = (radio_id & 0x00000FFF);
-	version = (radio_id & 0x0FFFF000) >> 12;
-	revision = (radio_id & 0xF0000000) >> 28;
-
-	dprintk(KERN_INFO PFX "Detected Radio: ID: %x (Manuf: %x Ver: %x Rev: %x)\n",
-		radio_id, manufact, version, revision);
-
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		if ((version != 0x2060) || (revision != 1) || (manufact != 0x17f))
-			goto err_unsupported_radio;
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if ((version & 0xFFF0) != 0x2050)
-			goto err_unsupported_radio;
-		break;
-	case BCM43xx_PHYTYPE_G:
-		if (version != 0x2050)
-			goto err_unsupported_radio;
-		break;
-	}
-
-	radio->manufact = manufact;
-	radio->version = version;
-	radio->revision = revision;
-
-	if (phy->type == BCM43xx_PHYTYPE_A)
-		radio->txpower_desired = bcm->sprom.maxpower_aphy;
-	else
-		radio->txpower_desired = bcm->sprom.maxpower_bgphy;
-
-	return 0;
-
-err_unsupported_radio:
-	printk(KERN_ERR PFX "Unsupported Radio connected to the PHY!\n");
-	return -ENODEV;
-}
-
-static const char * bcm43xx_locale_iso(u8 locale)
-{
-	/* ISO 3166-1 country codes.
-	 * Note that there aren't ISO 3166-1 codes for
-	 * all or locales. (Not all locales are countries)
-	 */
-	switch (locale) {
-	case BCM43xx_LOCALE_WORLD:
-	case BCM43xx_LOCALE_ALL:
-		return "XX";
-	case BCM43xx_LOCALE_THAILAND:
-		return "TH";
-	case BCM43xx_LOCALE_ISRAEL:
-		return "IL";
-	case BCM43xx_LOCALE_JORDAN:
-		return "JO";
-	case BCM43xx_LOCALE_CHINA:
-		return "CN";
-	case BCM43xx_LOCALE_JAPAN:
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		return "JP";
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-	case BCM43xx_LOCALE_USA_LOW:
-		return "US";
-	case BCM43xx_LOCALE_EUROPE:
-		return "EU";
-	case BCM43xx_LOCALE_NONE:
-		return "  ";
-	}
-	assert(0);
-	return "  ";
-}
-
-static const char * bcm43xx_locale_string(u8 locale)
-{
-	switch (locale) {
-	case BCM43xx_LOCALE_WORLD:
-		return "World";
-	case BCM43xx_LOCALE_THAILAND:
-		return "Thailand";
-	case BCM43xx_LOCALE_ISRAEL:
-		return "Israel";
-	case BCM43xx_LOCALE_JORDAN:
-		return "Jordan";
-	case BCM43xx_LOCALE_CHINA:
-		return "China";
-	case BCM43xx_LOCALE_JAPAN:
-		return "Japan";
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-		return "USA/Canada/ANZ";
-	case BCM43xx_LOCALE_EUROPE:
-		return "Europe";
-	case BCM43xx_LOCALE_USA_LOW:
-		return "USAlow";
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		return "JapanHigh";
-	case BCM43xx_LOCALE_ALL:
-		return "All";
-	case BCM43xx_LOCALE_NONE:
-		return "None";
-	}
-	assert(0);
-	return "";
-}
-
-static inline u8 bcm43xx_crc8(u8 crc, u8 data)
-{
-	static const u8 t[] = {
-		0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
-		0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
-		0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
-		0xDE, 0x29, 0x67, 0x90, 0xFB, 0x0C, 0x42, 0xB5,
-		0x7F, 0x88, 0xC6, 0x31, 0x5A, 0xAD, 0xE3, 0x14,
-		0x35, 0xC2, 0x8C, 0x7B, 0x10, 0xE7, 0xA9, 0x5E,
-		0xEB, 0x1C, 0x52, 0xA5, 0xCE, 0x39, 0x77, 0x80,
-		0xA1, 0x56, 0x18, 0xEF, 0x84, 0x73, 0x3D, 0xCA,
-		0xFE, 0x09, 0x47, 0xB0, 0xDB, 0x2C, 0x62, 0x95,
-		0xB4, 0x43, 0x0D, 0xFA, 0x91, 0x66, 0x28, 0xDF,
-		0x6A, 0x9D, 0xD3, 0x24, 0x4F, 0xB8, 0xF6, 0x01,
-		0x20, 0xD7, 0x99, 0x6E, 0x05, 0xF2, 0xBC, 0x4B,
-		0x81, 0x76, 0x38, 0xCF, 0xA4, 0x53, 0x1D, 0xEA,
-		0xCB, 0x3C, 0x72, 0x85, 0xEE, 0x19, 0x57, 0xA0,
-		0x15, 0xE2, 0xAC, 0x5B, 0x30, 0xC7, 0x89, 0x7E,
-		0x5F, 0xA8, 0xE6, 0x11, 0x7A, 0x8D, 0xC3, 0x34,
-		0xAB, 0x5C, 0x12, 0xE5, 0x8E, 0x79, 0x37, 0xC0,
-		0xE1, 0x16, 0x58, 0xAF, 0xC4, 0x33, 0x7D, 0x8A,
-		0x3F, 0xC8, 0x86, 0x71, 0x1A, 0xED, 0xA3, 0x54,
-		0x75, 0x82, 0xCC, 0x3B, 0x50, 0xA7, 0xE9, 0x1E,
-		0xD4, 0x23, 0x6D, 0x9A, 0xF1, 0x06, 0x48, 0xBF,
-		0x9E, 0x69, 0x27, 0xD0, 0xBB, 0x4C, 0x02, 0xF5,
-		0x40, 0xB7, 0xF9, 0x0E, 0x65, 0x92, 0xDC, 0x2B,
-		0x0A, 0xFD, 0xB3, 0x44, 0x2F, 0xD8, 0x96, 0x61,
-		0x55, 0xA2, 0xEC, 0x1B, 0x70, 0x87, 0xC9, 0x3E,
-		0x1F, 0xE8, 0xA6, 0x51, 0x3A, 0xCD, 0x83, 0x74,
-		0xC1, 0x36, 0x78, 0x8F, 0xE4, 0x13, 0x5D, 0xAA,
-		0x8B, 0x7C, 0x32, 0xC5, 0xAE, 0x59, 0x17, 0xE0,
-		0x2A, 0xDD, 0x93, 0x64, 0x0F, 0xF8, 0xB6, 0x41,
-		0x60, 0x97, 0xD9, 0x2E, 0x45, 0xB2, 0xFC, 0x0B,
-		0xBE, 0x49, 0x07, 0xF0, 0x9B, 0x6C, 0x22, 0xD5,
-		0xF4, 0x03, 0x4D, 0xBA, 0xD1, 0x26, 0x68, 0x9F,
-	};
-	return t[crc ^ data];
-}
-
-static u8 bcm43xx_sprom_crc(const u16 *sprom)
-{
-	int word;
-	u8 crc = 0xFF;
-
-	for (word = 0; word < BCM43xx_SPROM_SIZE - 1; word++) {
-		crc = bcm43xx_crc8(crc, sprom[word] & 0x00FF);
-		crc = bcm43xx_crc8(crc, (sprom[word] & 0xFF00) >> 8);
-	}
-	crc = bcm43xx_crc8(crc, sprom[BCM43xx_SPROM_VERSION] & 0x00FF);
-	crc ^= 0xFF;
-
-	return crc;
-}
-
-int bcm43xx_sprom_read(struct bcm43xx_private *bcm, u16 *sprom)
-{
-	int i;
-	u8 crc, expected_crc;
-
-	for (i = 0; i < BCM43xx_SPROM_SIZE; i++)
-		sprom[i] = bcm43xx_read16(bcm, BCM43xx_SPROM_BASE + (i * 2));
-	/* CRC-8 check. */
-	crc = bcm43xx_sprom_crc(sprom);
-	expected_crc = (sprom[BCM43xx_SPROM_VERSION] & 0xFF00) >> 8;
-	if (crc != expected_crc) {
-		printk(KERN_WARNING PFX "WARNING: Invalid SPROM checksum "
-					"(0x%02X, expected: 0x%02X)\n",
-		       crc, expected_crc);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int bcm43xx_sprom_write(struct bcm43xx_private *bcm, const u16 *sprom)
-{
-	int i, err;
-	u8 crc, expected_crc;
-	u32 spromctl;
-
-	/* CRC-8 validation of the input data. */
-	crc = bcm43xx_sprom_crc(sprom);
-	expected_crc = (sprom[BCM43xx_SPROM_VERSION] & 0xFF00) >> 8;
-	if (crc != expected_crc) {
-		printk(KERN_ERR PFX "SPROM input data: Invalid CRC\n");
-		return -EINVAL;
-	}
-
-	printk(KERN_INFO PFX "Writing SPROM. Do NOT turn off the power! Please stand by...\n");
-	err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_SPROMCTL, &spromctl);
-	if (err)
-		goto err_ctlreg;
-	spromctl |= 0x10; /* SPROM WRITE enable. */
-	err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_SPROMCTL, spromctl);
-	if (err)
-		goto err_ctlreg;
-	/* We must burn lots of CPU cycles here, but that does not
-	 * really matter as one does not write the SPROM every other minute...
-	 */
-	printk(KERN_INFO PFX "[ 0%%");
-	mdelay(500);
-	for (i = 0; i < BCM43xx_SPROM_SIZE; i++) {
-		if (i == 16)
-			printk("25%%");
-		else if (i == 32)
-			printk("50%%");
-		else if (i == 48)
-			printk("75%%");
-		else if (i % 2)
-			printk(".");
-		bcm43xx_write16(bcm, BCM43xx_SPROM_BASE + (i * 2), sprom[i]);
-		mmiowb();
-		mdelay(20);
-	}
-	spromctl &= ~0x10; /* SPROM WRITE enable. */
-	err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_SPROMCTL, spromctl);
-	if (err)
-		goto err_ctlreg;
-	mdelay(500);
-	printk("100%% ]\n");
-	printk(KERN_INFO PFX "SPROM written.\n");
-	bcm43xx_controller_restart(bcm, "SPROM update");
-
-	return 0;
-err_ctlreg:
-	printk(KERN_ERR PFX "Could not access SPROM control register.\n");
-	return -ENODEV;
-}
-
-static int bcm43xx_sprom_extract(struct bcm43xx_private *bcm)
-{
-	u16 value;
-	u16 *sprom;
-
-	sprom = kzalloc(BCM43xx_SPROM_SIZE * sizeof(u16),
-			GFP_KERNEL);
-	if (!sprom) {
-		printk(KERN_ERR PFX "sprom_extract OOM\n");
-		return -ENOMEM;
-	}
-	bcm43xx_sprom_read(bcm, sprom);
-
-	/* boardflags2 */
-	value = sprom[BCM43xx_SPROM_BOARDFLAGS2];
-	bcm->sprom.boardflags2 = value;
-
-	/* il0macaddr */
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 0];
-	*(((u16 *)bcm->sprom.il0macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 1];
-	*(((u16 *)bcm->sprom.il0macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 2];
-	*(((u16 *)bcm->sprom.il0macaddr) + 2) = cpu_to_be16(value);
-
-	/* et0macaddr */
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 0];
-	*(((u16 *)bcm->sprom.et0macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 1];
-	*(((u16 *)bcm->sprom.et0macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 2];
-	*(((u16 *)bcm->sprom.et0macaddr) + 2) = cpu_to_be16(value);
-
-	/* et1macaddr */
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 0];
-	*(((u16 *)bcm->sprom.et1macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 1];
-	*(((u16 *)bcm->sprom.et1macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 2];
-	*(((u16 *)bcm->sprom.et1macaddr) + 2) = cpu_to_be16(value);
-
-	/* ethernet phy settings */
-	value = sprom[BCM43xx_SPROM_ETHPHY];
-	bcm->sprom.et0phyaddr = (value & 0x001F);
-	bcm->sprom.et1phyaddr = (value & 0x03E0) >> 5;
-
-	/* boardrev, antennas, locale */
-	value = sprom[BCM43xx_SPROM_BOARDREV];
-	bcm->sprom.boardrev = (value & 0x00FF);
-	bcm->sprom.locale = (value & 0x0F00) >> 8;
-	bcm->sprom.antennas_aphy = (value & 0x3000) >> 12;
-	bcm->sprom.antennas_bgphy = (value & 0xC000) >> 14;
-	if (modparam_locale != -1) {
-		if (modparam_locale >= 0 && modparam_locale <= 11) {
-			bcm->sprom.locale = modparam_locale;
-			printk(KERN_WARNING PFX "Operating with modified "
-						"LocaleCode %u (%s)\n",
-			       bcm->sprom.locale,
-			       bcm43xx_locale_string(bcm->sprom.locale));
-		} else {
-			printk(KERN_WARNING PFX "Module parameter \"locale\" "
-						"invalid value. (0 - 11)\n");
-		}
-	}
-
-	/* pa0b* */
-	value = sprom[BCM43xx_SPROM_PA0B0];
-	bcm->sprom.pa0b0 = value;
-	value = sprom[BCM43xx_SPROM_PA0B1];
-	bcm->sprom.pa0b1 = value;
-	value = sprom[BCM43xx_SPROM_PA0B2];
-	bcm->sprom.pa0b2 = value;
-
-	/* wl0gpio* */
-	value = sprom[BCM43xx_SPROM_WL0GPIO0];
-	if (value == 0x0000)
-		value = 0xFFFF;
-	bcm->sprom.wl0gpio0 = value & 0x00FF;
-	bcm->sprom.wl0gpio1 = (value & 0xFF00) >> 8;
-	value = sprom[BCM43xx_SPROM_WL0GPIO2];
-	if (value == 0x0000)
-		value = 0xFFFF;
-	bcm->sprom.wl0gpio2 = value & 0x00FF;
-	bcm->sprom.wl0gpio3 = (value & 0xFF00) >> 8;
-
-	/* maxpower */
-	value = sprom[BCM43xx_SPROM_MAXPWR];
-	bcm->sprom.maxpower_aphy = (value & 0xFF00) >> 8;
-	bcm->sprom.maxpower_bgphy = value & 0x00FF;
-
-	/* pa1b* */
-	value = sprom[BCM43xx_SPROM_PA1B0];
-	bcm->sprom.pa1b0 = value;
-	value = sprom[BCM43xx_SPROM_PA1B1];
-	bcm->sprom.pa1b1 = value;
-	value = sprom[BCM43xx_SPROM_PA1B2];
-	bcm->sprom.pa1b2 = value;
-
-	/* idle tssi target */
-	value = sprom[BCM43xx_SPROM_IDL_TSSI_TGT];
-	bcm->sprom.idle_tssi_tgt_aphy = value & 0x00FF;
-	bcm->sprom.idle_tssi_tgt_bgphy = (value & 0xFF00) >> 8;
-
-	/* boardflags */
-	value = sprom[BCM43xx_SPROM_BOARDFLAGS];
-	if (value == 0xFFFF)
-		value = 0x0000;
-	bcm->sprom.boardflags = value;
-	/* boardflags workarounds */
-	if (bcm->board_vendor == PCI_VENDOR_ID_DELL &&
-	    bcm->chip_id == 0x4301 &&
-	    bcm->board_revision == 0x74)
-		bcm->sprom.boardflags |= BCM43xx_BFL_BTCOEXIST;
-	if (bcm->board_vendor == PCI_VENDOR_ID_APPLE &&
-	    bcm->board_type == 0x4E &&
-	    bcm->board_revision > 0x40)
-		bcm->sprom.boardflags |= BCM43xx_BFL_PACTRL;
-
-	/* antenna gain */
-	value = sprom[BCM43xx_SPROM_ANTENNA_GAIN];
-	if (value == 0x0000 || value == 0xFFFF)
-		value = 0x0202;
-	/* convert values to Q5.2 */
-	bcm->sprom.antennagain_aphy = ((value & 0xFF00) >> 8) * 4;
-	bcm->sprom.antennagain_bgphy = (value & 0x00FF) * 4;
-
-	kfree(sprom);
-
-	return 0;
-}
-
-static int bcm43xx_geo_init(struct bcm43xx_private *bcm)
+static void bcm43xx_synchronize_irq(struct bcm43xx_wldev *dev)
 {
-	struct ieee80211_geo *geo;
-	struct ieee80211_channel *chan;
-	int have_a = 0, have_bg = 0;
-	int i;
-	u8 channel;
-	struct bcm43xx_phyinfo *phy;
-	const char *iso_country;
-	u8 max_bg_channel;
-
-	geo = kzalloc(sizeof(*geo), GFP_KERNEL);
-	if (!geo)
-		return -ENOMEM;
-
-	for (i = 0; i < bcm->nr_80211_available; i++) {
-		phy = &(bcm->core_80211_ext[i].phy);
-		switch (phy->type) {
-		case BCM43xx_PHYTYPE_B:
-		case BCM43xx_PHYTYPE_G:
-			have_bg = 1;
-			break;
-		case BCM43xx_PHYTYPE_A:
-			have_a = 1;
-			break;
-		default:
-			assert(0);
-		}
-	}
-	iso_country = bcm43xx_locale_iso(bcm->sprom.locale);
-
-/* set the maximum channel based on locale set in sprom or witle locale option */
-	switch (bcm->sprom.locale) {
-	case BCM43xx_LOCALE_THAILAND:
-	case BCM43xx_LOCALE_ISRAEL:
-	case BCM43xx_LOCALE_JORDAN:
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-	case BCM43xx_LOCALE_USA_LOW:
-		max_bg_channel = 11;
-		break;
-	case BCM43xx_LOCALE_JAPAN:
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		max_bg_channel = 14;
-		break;
-	default:
-		max_bg_channel = 13;
-	}
-
- 	if (have_a) {
-		for (i = 0, channel = IEEE80211_52GHZ_MIN_CHANNEL;
-		      channel <= IEEE80211_52GHZ_MAX_CHANNEL; channel++) {
-			chan = &geo->a[i++];
-			chan->freq = bcm43xx_channel_to_freq_a(channel);
-			chan->channel = channel;
-		}
-		geo->a_channels = i;
-	}
-	if (have_bg) {
-		for (i = 0, channel = IEEE80211_24GHZ_MIN_CHANNEL;
-		      channel <= max_bg_channel; channel++) {
-			chan = &geo->bg[i++];
-			chan->freq = bcm43xx_channel_to_freq_bg(channel);
-			chan->channel = channel;
-		}
-		geo->bg_channels = i;
-	}
-	memcpy(geo->name, iso_country, 2);
-	if (0 /*TODO: Outdoor use only */)
-		geo->name[2] = 'O';
-	else if (0 /*TODO: Indoor use only */)
-		geo->name[2] = 'I';
-	else
-		geo->name[2] = ' ';
-	geo->name[3] = '\0';
-
-	ieee80211_set_geo(bcm->ieee, geo);
-	kfree(geo);
-
-	return 0;
+	synchronize_irq(dev->dev->irq);
+	tasklet_kill(&dev->isr_tasklet);
 }
 
-/* DummyTransmission function, as documented on 
+/* DummyTransmission function, as documented on
  * http://bcm-specs.sipsolutions.net/DummyTransmission
  */
-void bcm43xx_dummy_transmission(struct bcm43xx_private *bcm)
+void bcm43xx_dummy_transmission(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	unsigned int i, max_loop;
-	u16 value = 0;
+	u16 value;
 	u32 buffer[5] = {
 		0x00000000,
-		0x0000D400,
+		0x00D40000,
 		0x00000000,
-		0x00000001,
+		0x01000000,
 		0x00000000,
 	};
 
 	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		max_loop = 0x1E;
-		buffer[0] = 0xCC010200;
-		break;
 	case BCM43xx_PHYTYPE_B:
 	case BCM43xx_PHYTYPE_G:
 		max_loop = 0xFA;
-		buffer[0] = 0x6E840B00; 
+		buffer[0] = 0x000B846E;
 		break;
 	default:
-		assert(0);
+		BCM43xx_BUG_ON(1);
 		return;
 	}
 
 	for (i = 0; i < 5; i++)
-		bcm43xx_ram_write(bcm, i * 4, buffer[i]);
+		bcm43xx_ram_write(dev, i * 4, buffer[i]);
 
-	bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD); /* dummy read */
+	bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD); /* dummy read */
 
-	bcm43xx_write16(bcm, 0x0568, 0x0000);
-	bcm43xx_write16(bcm, 0x07C0, 0x0000);
-	bcm43xx_write16(bcm, 0x050C, ((phy->type == BCM43xx_PHYTYPE_A) ? 1 : 0));
-	bcm43xx_write16(bcm, 0x0508, 0x0000);
-	bcm43xx_write16(bcm, 0x050A, 0x0000);
-	bcm43xx_write16(bcm, 0x054C, 0x0000);
-	bcm43xx_write16(bcm, 0x056A, 0x0014);
-	bcm43xx_write16(bcm, 0x0568, 0x0826);
-	bcm43xx_write16(bcm, 0x0500, 0x0000);
-	bcm43xx_write16(bcm, 0x0502, 0x0030);
+	bcm43xx_write16(dev, 0x0568, 0x0000);
+	bcm43xx_write16(dev, 0x07C0, 0x0000);
+	bcm43xx_write16(dev, 0x050C, 0x0000);
+	bcm43xx_write16(dev, 0x0508, 0x0000);
+	bcm43xx_write16(dev, 0x050A, 0x0000);
+	bcm43xx_write16(dev, 0x054C, 0x0000);
+	bcm43xx_write16(dev, 0x056A, 0x0014);
+	bcm43xx_write16(dev, 0x0568, 0x0826);
+	bcm43xx_write16(dev, 0x0500, 0x0000);
+	bcm43xx_write16(dev, 0x0502, 0x0030);
 
-	if (radio->version == 0x2050 && radio->revision <= 0x5)
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0017);
+	if (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5)
+		bcm43xx_radio_write16(dev, 0x0051, 0x0017);
 	for (i = 0x00; i < max_loop; i++) {
-		value = bcm43xx_read16(bcm, 0x050E);
+		value = bcm43xx_read16(dev, 0x050E);
 		if (value & 0x0080)
 			break;
 		udelay(10);
 	}
 	for (i = 0x00; i < 0x0A; i++) {
-		value = bcm43xx_read16(bcm, 0x050E);
+		value = bcm43xx_read16(dev, 0x050E);
 		if (value & 0x0400)
 			break;
 		udelay(10);
 	}
 	for (i = 0x00; i < 0x0A; i++) {
-		value = bcm43xx_read16(bcm, 0x0690);
+		value = bcm43xx_read16(dev, 0x0690);
 		if (!(value & 0x0100))
 			break;
 		udelay(10);
 	}
-	if (radio->version == 0x2050 && radio->revision <= 0x5)
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0037);
+	if (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5)
+		bcm43xx_radio_write16(dev, 0x0051, 0x0037);
 }
 
-static void key_write(struct bcm43xx_private *bcm,
-		      u8 index, u8 algorithm, const u16 *key)
+static void key_write(struct bcm43xx_wldev *dev,
+		      u8 index, u8 algorithm, const u8 *key)
 {
-	unsigned int i, basic_wep = 0;
+	unsigned int i;
 	u32 offset;
 	u16 value;
- 
-	/* Write associated key information */
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x100 + (index * 2),
-			    ((index << 4) | (algorithm & 0x0F)));
- 
-	/* The first 4 WEP keys need extra love */
-	if (((algorithm == BCM43xx_SEC_ALGO_WEP) ||
-	    (algorithm == BCM43xx_SEC_ALGO_WEP104)) && (index < 4))
-		basic_wep = 1;
- 
-	/* Write key payload, 8 little endian words */
-	offset = bcm->security_offset + (index * BCM43xx_SEC_KEYSIZE);
-	for (i = 0; i < (BCM43xx_SEC_KEYSIZE / sizeof(u16)); i++) {
-		value = cpu_to_le16(key[i]);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    offset + (i * 2), value);
- 
-		if (!basic_wep)
-			continue;
- 
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    offset + (i * 2) + 4 * BCM43xx_SEC_KEYSIZE,
-				    value);
+	u16 kidx;
+
+	/* Key index/algo block */
+	kidx = bcm43xx_kidx_to_fw(dev, index);
+	value = ((kidx << 4) | algorithm);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_KEYIDXBLOCK +
+			    (kidx * 2), value);
+
+	/* Write the key to the Key Table Pointer offset */
+	offset = dev->ktp + (index * BCM43xx_SEC_KEYSIZE);
+	for (i = 0; i < BCM43xx_SEC_KEYSIZE; i += 2) {
+		value = key[i];
+		value |= (u16)(key[i + 1]) << 8;
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+				    offset + i, value);
 	}
 }
 
-static void keymac_write(struct bcm43xx_private *bcm,
-			 u8 index, const u32 *addr)
+static void keymac_write(struct bcm43xx_wldev *dev,
+			 u8 index, const u8 *addr)
 {
 	/* for keys 0-3 there is no associated mac address */
 	if (index < 4)
 		return;
 
 	index -= 4;
-	if (bcm->current_core->rev >= 5) {
-		bcm43xx_shm_write32(bcm,
-				    BCM43xx_SHM_HWMAC,
+	if (dev->dev->id.revision >= 5) {
+		bcm43xx_shm_write32(dev,
+				    BCM43xx_SHM_HW,
 				    index * 2,
 				    cpu_to_be32(*addr));
-		bcm43xx_shm_write16(bcm,
-				    BCM43xx_SHM_HWMAC,
+		bcm43xx_shm_write16(dev,
+				    BCM43xx_SHM_HW,
 				    (index * 2) + 1,
 				    cpu_to_be16(*((u16 *)(addr + 1))));
 	} else {
-		if (index < 8) {
-			TODO(); /* Put them in the macaddress filter */
+		if (index < 4) {
+			bcm43xx_macfilter_set(dev, BCM43xx_MACFILTER_MAC +
+					      index * 3, addr);
 		} else {
-			TODO();
 			/* Put them BCM43xx_SHM_SHARED, stating index 0x0120.
-			   Keep in mind to update the count of keymacs in 0x003E as well! */
+			   Update the count of keymacs in 0x003E as well */
+			bcm43xx_shm_write32(dev,
+					    BCM43xx_SHM_SHARED,
+					    (index - 4) * 6 + 0x120,
+					    cpu_to_be32(*addr));
+			bcm43xx_shm_write16(dev,
+					    BCM43xx_SHM_SHARED,
+					    (index - 4) * 6 + 0x124,
+					    cpu_to_be16(*((u16 *)(addr + 1))));
+			bcm43xx_shm_write32(dev,	/* update count */
+					    BCM43xx_SHM_SHARED, 0x003E,
+					    bcm43xx_shm_read32(dev,
+					    BCM43xx_SHM_SHARED, 0x003E) + 1);
 		}
 	}
 }
 
-static int bcm43xx_key_write(struct bcm43xx_private *bcm,
-			     u8 index, u8 algorithm,
-			     const u8 *_key, int key_len,
-			     const u8 *mac_addr)
+static void do_key_write(struct bcm43xx_wldev *dev,
+			 u8 index, u8 algorithm,
+			 const u8 *key, size_t key_len,
+			 const u8 *mac_addr)
+{
+	u8 buf[BCM43xx_SEC_KEYSIZE];
+
+	BCM43xx_WARN_ON(index >= dev->max_nr_keys);
+	BCM43xx_WARN_ON(key_len > BCM43xx_SEC_KEYSIZE);
+
+	memset(buf, 0, sizeof(buf));
+	if (index >= 8)
+		keymac_write(dev, index, buf); /* First zero out mac. */
+	memcpy(buf, key, key_len);
+	key_write(dev, index, algorithm, buf);
+	if (index >= 8)
+		keymac_write(dev, index, mac_addr);
+
+	dev->key[index].algorithm = algorithm;
+}
+
+static int bcm43xx_key_write(struct bcm43xx_wldev *dev,
+			     int index, u8 algorithm,
+			     const u8 *key, size_t key_len,
+			     const u8 *mac_addr,
+			     struct ieee80211_key_conf *keyconf)
 {
-	u8 key[BCM43xx_SEC_KEYSIZE] = { 0 };
+	int i;
+	int sta_keys_start;
 
-	if (index >= ARRAY_SIZE(bcm->key))
-		return -EINVAL;
-	if (key_len > ARRAY_SIZE(key))
-		return -EINVAL;
-	if (algorithm < 1 || algorithm > 5)
+	if (key_len > BCM43xx_SEC_KEYSIZE)
 		return -EINVAL;
+	if (index < 0) {
+		/* Per station key with associated MAC address.
+		 * Look if it already exists, if yes update, otherwise
+		 * allocate a new key.
+		 */
+		if (bcm43xx_new_kidx_api(dev))
+			sta_keys_start = 4;
+		else
+			sta_keys_start = 8;
+		for (i = sta_keys_start; i < dev->max_nr_keys; i++) {
+			if (compare_ether_addr(dev->key[i].address, mac_addr)
+			     == 0) {
+				/* found existing */
+				index = i;
+				break;
+			}
+		}
+		if (index < 0) {
+			for (i = sta_keys_start; i < dev->max_nr_keys; i++) {
+				if (!dev->key[i].enabled) {
+					/* found empty */
+					index = i;
+					break;
+				}
+			}
+		}
+		if (index < 0) {
+			bcmerr(dev->wl, "Out of hardware key memory\n");
+			return -ENOBUFS;
+		}
+	} else {
+		BCM43xx_WARN_ON(index > 3);
+	}
 
-	memcpy(key, _key, key_len);
-	key_write(bcm, index, algorithm, (const u16 *)key);
-	keymac_write(bcm, index, (const u32 *)mac_addr);
-
-	bcm->key[index].algorithm = algorithm;
+	do_key_write(dev, index, algorithm, key, key_len, mac_addr);
+	if ((index <= 3) && !bcm43xx_new_kidx_api(dev)) {
+		/* Default RX key */
+		BCM43xx_WARN_ON(mac_addr != NULL);
+		do_key_write(dev, index + 4, algorithm, key, key_len, NULL);
+	}
+	keyconf->hw_key_idx = index;
 
 	return 0;
 }
 
-static void bcm43xx_clear_keys(struct bcm43xx_private *bcm)
+static void bcm43xx_clear_keys(struct bcm43xx_wldev *dev)
 {
-	static const u32 zero_mac[2] = { 0 };
-	unsigned int i,j, nr_keys = 54;
-	u16 offset;
+	static const u8 zero[BCM43xx_SEC_KEYSIZE] = { 0 };
+	unsigned int i;
 
-	if (bcm->current_core->rev < 5)
-		nr_keys = 16;
-	assert(nr_keys <= ARRAY_SIZE(bcm->key));
-
-	for (i = 0; i < nr_keys; i++) {
-		bcm->key[i].enabled = 0;
-		/* returns for i < 4 immediately */
-		keymac_write(bcm, i, zero_mac);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    0x100 + (i * 2), 0x0000);
-		for (j = 0; j < 8; j++) {
-			offset = bcm->security_offset + (j * 4) + (i * BCM43xx_SEC_KEYSIZE);
-			bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-					    offset, 0x0000);
-		}
+	BUILD_BUG_ON(BCM43xx_SEC_KEYSIZE < ETH_ALEN);
+	for (i = 0; i < dev->max_nr_keys; i++) {
+		do_key_write(dev, i, BCM43xx_SEC_ALGO_NONE,
+			     zero, BCM43xx_SEC_KEYSIZE,
+			     zero);
+		dev->key[i].enabled = 0;
 	}
-	dprintk(KERN_INFO PFX "Keys cleared\n");
 }
 
-/* Lowlevel core-switch function. This is only to be used in
- * bcm43xx_switch_core() and bcm43xx_probe_cores()
- */
-static int _switch_core(struct bcm43xx_private *bcm, int core)
+/* Turn the Analog ON/OFF */
+static void bcm43xx_switch_analog(struct bcm43xx_wldev *dev, int on)
 {
-	int err;
-	int attempts = 0;
-	u32 current_core;
+	bcm43xx_write16(dev, BCM43xx_MMIO_PHY0, on ? 0 : 0xF4);
+}
 
-	assert(core >= 0);
-	while (1) {
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_ACTIVE_CORE,
-						 (core * 0x1000) + 0x18000000);
-		if (unlikely(err))
-			goto error;
-		err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_ACTIVE_CORE,
-						&current_core);
-		if (unlikely(err))
-			goto error;
-		current_core = (current_core - 0x18000000) / 0x1000;
-		if (current_core == core)
-			break;
+void bcm43xx_wireless_core_reset(struct bcm43xx_wldev *dev, u32 flags)
+{
+	u32 tmslow;
+	u32 macctl;
 
-		if (unlikely(attempts++ > BCM43xx_SWITCH_CORE_MAX_RETRIES))
-			goto error;
-		udelay(10);
-	}
+	flags |= BCM43xx_TMSLOW_PHYCLKEN;
+	flags |= BCM43xx_TMSLOW_PHYRESET;
+	ssb_device_enable(dev->dev, flags);
+	msleep(2); /* Wait for the PLL to turn on. */
 
-	return 0;
-error:
-	printk(KERN_ERR PFX "Failed to switch to core %d\n", core);
-	return -ENODEV;
+	/* Now take the PHY out of Reset again */
+	tmslow = ssb_read32(dev->dev, SSB_TMSLOW);
+	tmslow |= SSB_TMSLOW_FGC;
+	tmslow &= ~BCM43xx_TMSLOW_PHYRESET;
+	ssb_write32(dev->dev, SSB_TMSLOW, tmslow);
+	ssb_read32(dev->dev, SSB_TMSLOW); /* flush */
+	msleep(1);
+	tmslow &= ~SSB_TMSLOW_FGC;
+	ssb_write32(dev->dev, SSB_TMSLOW, tmslow);
+	ssb_read32(dev->dev, SSB_TMSLOW); /* flush */
+	msleep(1);
+
+	/* Turn Analog ON */
+	bcm43xx_switch_analog(dev, 1);
+
+	macctl = bcm43xx_read32(dev, BCM43xx_MMIO_MACCTL);
+	macctl &= ~BCM43xx_MACCTL_GMODE;
+	if (flags & BCM43xx_TMSLOW_GMODE)
+		macctl |= BCM43xx_MACCTL_GMODE;
+	macctl |= BCM43xx_MACCTL_IHR_ENABLED;
+	bcm43xx_write32(dev, BCM43xx_MMIO_MACCTL, macctl);
 }
 
-int bcm43xx_switch_core(struct bcm43xx_private *bcm, struct bcm43xx_coreinfo *new_core)
+static void handle_irq_transmit_status(struct bcm43xx_wldev *dev)
 {
-	int err;
+	u32 v0;
+	u32 v1;
+	u16 tmp;
+	struct bcm43xx_txstatus stat;
 
-	if (unlikely(!new_core))
-		return 0;
-	if (!new_core->available)
-		return -ENODEV;
-	if (bcm->current_core == new_core)
-		return 0;
-	err = _switch_core(bcm, new_core->index);
-	if (unlikely(err))
-		goto out;
+	while (1) {
+		v0 = bcm43xx_read32(dev, BCM43xx_MMIO_XMITSTAT_0);
+		if (!(v0 & 0x00000001))
+			break;
+		v1 = bcm43xx_read32(dev, BCM43xx_MMIO_XMITSTAT_1);
 
-	bcm->current_core = new_core;
-out:
-	return err;
+		stat.cookie = (v0 >> 16);
+		stat.seq = (v1 & 0x0000FFFF);
+		stat.phy_stat = ((v1 & 0x00FF0000) >> 16);
+		tmp = (v0 & 0x0000FFFF);
+		stat.frame_count = ((tmp & 0xF000) >> 12);
+		stat.rts_count = ((tmp & 0x0F00) >> 8);
+		stat.supp_reason = ((tmp & 0x001C) >> 2);
+		stat.pm_indicated = !!(tmp & 0x0080);
+		stat.intermediate = !!(tmp & 0x0040);
+		stat.for_ampdu = !!(tmp & 0x0020);
+		stat.acked = !!(tmp & 0x0002);
+
+		bcm43xx_handle_txstatus(dev, &stat);
+	}
 }
 
-static int bcm43xx_core_enabled(struct bcm43xx_private *bcm)
+static void drain_txstatus_queue(struct bcm43xx_wldev *dev)
 {
-	u32 value;
-
-	value = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	value &= BCM43xx_SBTMSTATELOW_CLOCK | BCM43xx_SBTMSTATELOW_RESET
-		 | BCM43xx_SBTMSTATELOW_REJECT;
+	u32 dummy;
 
-	return (value == BCM43xx_SBTMSTATELOW_CLOCK);
+	if (dev->dev->id.revision < 5)
+		return;
+	/* Read all entries from the microcode TXstatus FIFO
+	 * and throw them away.
+	 */
+	while (1) {
+		dummy = bcm43xx_read32(dev, BCM43xx_MMIO_XMITSTAT_0);
+		if (!(dummy & 0x00000001))
+			break;
+		dummy = bcm43xx_read32(dev, BCM43xx_MMIO_XMITSTAT_1);
+	}
 }
 
-/* disable current core */
-static int bcm43xx_core_disable(struct bcm43xx_private *bcm, u32 core_flags)
+static u32 bcm43xx_jssi_read(struct bcm43xx_wldev *dev)
 {
-	u32 sbtmstatelow;
-	u32 sbtmstatehigh;
-	int i;
-
-	/* fetch sbtmstatelow from core information registers */
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-
-	/* core is already in reset */
-	if (sbtmstatelow & BCM43xx_SBTMSTATELOW_RESET)
-		goto out;
-
-	if (sbtmstatelow & BCM43xx_SBTMSTATELOW_CLOCK) {
-		sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-			       BCM43xx_SBTMSTATELOW_REJECT;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-
-		for (i = 0; i < 1000; i++) {
-			sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-			if (sbtmstatelow & BCM43xx_SBTMSTATELOW_REJECT) {
-				i = -1;
-				break;
-			}
-			udelay(10);
-		}
-		if (i != -1) {
-			printk(KERN_ERR PFX "Error: core_disable() REJECT timeout!\n");
-			return -EBUSY;
-		}
-
-		for (i = 0; i < 1000; i++) {
-			sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-			if (!(sbtmstatehigh & BCM43xx_SBTMSTATEHIGH_BUSY)) {
-				i = -1;
-				break;
-			}
-			udelay(10);
-		}
-		if (i != -1) {
-			printk(KERN_ERR PFX "Error: core_disable() BUSY timeout!\n");
-			return -EBUSY;
-		}
-
-		sbtmstatelow = BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-			       BCM43xx_SBTMSTATELOW_REJECT |
-			       BCM43xx_SBTMSTATELOW_RESET |
-			       BCM43xx_SBTMSTATELOW_CLOCK |
-			       core_flags;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-		udelay(10);
-	}
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_RESET |
-		       BCM43xx_SBTMSTATELOW_REJECT |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-
-out:
-	bcm->current_core->enabled = 0;
-
-	return 0;
-}
-
-/* enable (reset) current core */
-static int bcm43xx_core_enable(struct bcm43xx_private *bcm, u32 core_flags)
-{
-	u32 sbtmstatelow;
-	u32 sbtmstatehigh;
-	u32 sbimstate;
-	int err;
-
-	err = bcm43xx_core_disable(bcm, core_flags);
-	if (err)
-		goto out;
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-		       BCM43xx_SBTMSTATELOW_RESET |
-		       BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-	if (sbtmstatehigh & BCM43xx_SBTMSTATEHIGH_SERROR) {
-		sbtmstatehigh = 0x00000000;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATEHIGH, sbtmstatehigh);
-	}
-
-	sbimstate = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMSTATE);
-	if (sbimstate & (BCM43xx_SBIMSTATE_IB_ERROR | BCM43xx_SBIMSTATE_TIMEOUT)) {
-		sbimstate &= ~(BCM43xx_SBIMSTATE_IB_ERROR | BCM43xx_SBIMSTATE_TIMEOUT);
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBIMSTATE, sbimstate);
-	}
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-		       BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK | core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	bcm->current_core->enabled = 1;
-	assert(err == 0);
-out:
-	return err;
-}
-
-/* http://bcm-specs.sipsolutions.net/80211CoreReset */
-void bcm43xx_wireless_core_reset(struct bcm43xx_private *bcm, int connect_phy)
-{
-	u32 flags = 0x00040000;
-
-	if ((bcm43xx_core_enabled(bcm)) &&
-	    !bcm43xx_using_pio(bcm)) {
-	}
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_SHUTTINGDOWN) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				& ~(BCM43xx_SBF_MAC_ENABLED | 0x00000002));
-	} else {
-		if (connect_phy)
-			flags |= BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_phy_connect(bcm, connect_phy);
-		bcm43xx_core_enable(bcm, flags);
-		bcm43xx_write16(bcm, 0x03E6, 0x0000);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-				bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				| BCM43xx_SBF_400);
-	}
-}
-
-static void bcm43xx_wireless_core_disable(struct bcm43xx_private *bcm)
-{
-	bcm43xx_radio_turn_off(bcm);
-	bcm43xx_write16(bcm, 0x03E6, 0x00F4);
-	bcm43xx_core_disable(bcm, 0);
-}
-
-/* Mark the current 80211 core inactive. */
-static void bcm43xx_wireless_core_mark_inactive(struct bcm43xx_private *bcm)
-{
-	u32 sbtmstatelow;
-
-	bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-	bcm43xx_radio_turn_off(bcm);
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	sbtmstatelow &= 0xDFF5FFFF;
-	sbtmstatelow |= 0x000A0000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	sbtmstatelow &= 0xFFF5FFFF;
-	sbtmstatelow |= 0x00080000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-}
+	u32 val = 0;
 
-static void handle_irq_transmit_status(struct bcm43xx_private *bcm)
-{
-	u32 v0, v1;
-	u16 tmp;
-	struct bcm43xx_xmitstatus stat;
-
-	while (1) {
-		v0 = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_0);
-		if (!v0)
-			break;
-		v1 = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_1);
-
-		stat.cookie = (v0 >> 16) & 0x0000FFFF;
-		tmp = (u16)((v0 & 0xFFF0) | ((v0 & 0xF) >> 1));
-		stat.flags = tmp & 0xFF;
-		stat.cnt1 = (tmp & 0x0F00) >> 8;
-		stat.cnt2 = (tmp & 0xF000) >> 12;
-		stat.seq = (u16)(v1 & 0xFFFF);
-		stat.unknown = (u16)((v1 >> 16) & 0xFF);
-
-		bcm43xx_debugfs_log_txstat(bcm, &stat);
-
-		if (stat.flags & BCM43xx_TXSTAT_FLAG_AMPDU)
-			continue;
-		if (stat.flags & BCM43xx_TXSTAT_FLAG_INTER)
-			continue;
+	val = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x40A);
+	val <<= 16;
+	val |= bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x408);
 
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_handle_xmitstatus(bcm, &stat);
-		else
-			bcm43xx_dma_handle_xmitstatus(bcm, &stat);
-	}
+	return val;
 }
 
-static void drain_txstatus_queue(struct bcm43xx_private *bcm)
+static void bcm43xx_jssi_write(struct bcm43xx_wldev *dev, u32 jssi)
 {
-	u32 dummy;
-
-	if (bcm->current_core->rev < 5)
-		return;
-	/* Read all entries from the microcode TXstatus FIFO
-	 * and throw them away.
-	 */
-	while (1) {
-		dummy = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_0);
-		if (!dummy)
-			break;
-		dummy = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_1);
-	}
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x408,
+			    (jssi & 0x0000FFFF));
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x40A,
+			    (jssi & 0xFFFF0000) >> 16);
 }
 
-static void bcm43xx_generate_noise_sample(struct bcm43xx_private *bcm)
+static void bcm43xx_generate_noise_sample(struct bcm43xx_wldev *dev)
 {
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x408, 0x7F7F);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x40A, 0x7F7F);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD) | (1 << 4));
-	assert(bcm->noisecalc.core_at_start == bcm->current_core);
-	assert(bcm->noisecalc.channel_at_start == bcm43xx_current_radio(bcm)->channel);
+	bcm43xx_jssi_write(dev, 0x7F7F7F7F);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS2_BITFIELD,
+			bcm43xx_read32(dev, BCM43xx_MMIO_STATUS2_BITFIELD)
+			| (1 << 4));
+	BCM43xx_WARN_ON(dev->noisecalc.channel_at_start != dev->phy.channel);
 }
 
-static void bcm43xx_calculate_link_quality(struct bcm43xx_private *bcm)
+static void bcm43xx_calculate_link_quality(struct bcm43xx_wldev *dev)
 {
 	/* Top half of Link Quality calculation. */
 
-	if (bcm->noisecalc.calculation_running)
+	if (dev->noisecalc.calculation_running)
 		return;
-	bcm->noisecalc.core_at_start = bcm->current_core;
-	bcm->noisecalc.channel_at_start = bcm43xx_current_radio(bcm)->channel;
-	bcm->noisecalc.calculation_running = 1;
-	bcm->noisecalc.nr_samples = 0;
+	dev->noisecalc.channel_at_start = dev->phy.channel;
+	dev->noisecalc.calculation_running = 1;
+	dev->noisecalc.nr_samples = 0;
 
-	bcm43xx_generate_noise_sample(bcm);
+	bcm43xx_generate_noise_sample(dev);
 }
 
-static void handle_irq_noise(struct bcm43xx_private *bcm)
+static void handle_irq_noise(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	u16 tmp;
 	u8 noise[4];
 	u8 i, j;
@@ -1477,45 +978,38 @@ static void handle_irq_noise(struct bcm4
 
 	/* Bottom half of Link Quality calculation. */
 
-	assert(bcm->noisecalc.calculation_running);
-	if (bcm->noisecalc.core_at_start != bcm->current_core ||
-	    bcm->noisecalc.channel_at_start != radio->channel)
+	BCM43xx_WARN_ON(!dev->noisecalc.calculation_running);
+	if (dev->noisecalc.channel_at_start != phy->channel)
 		goto drop_calculation;
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x408);
-	noise[0] = (tmp & 0x00FF);
-	noise[1] = (tmp & 0xFF00) >> 8;
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x40A);
-	noise[2] = (tmp & 0x00FF);
-	noise[3] = (tmp & 0xFF00) >> 8;
+	*((u32 *)noise) = cpu_to_le32(bcm43xx_jssi_read(dev));
 	if (noise[0] == 0x7F || noise[1] == 0x7F ||
 	    noise[2] == 0x7F || noise[3] == 0x7F)
 		goto generate_new;
 
 	/* Get the noise samples. */
-	assert(bcm->noisecalc.nr_samples < 8);
-	i = bcm->noisecalc.nr_samples;
-	noise[0] = limit_value(noise[0], 0, ARRAY_SIZE(radio->nrssi_lt) - 1);
-	noise[1] = limit_value(noise[1], 0, ARRAY_SIZE(radio->nrssi_lt) - 1);
-	noise[2] = limit_value(noise[2], 0, ARRAY_SIZE(radio->nrssi_lt) - 1);
-	noise[3] = limit_value(noise[3], 0, ARRAY_SIZE(radio->nrssi_lt) - 1);
-	bcm->noisecalc.samples[i][0] = radio->nrssi_lt[noise[0]];
-	bcm->noisecalc.samples[i][1] = radio->nrssi_lt[noise[1]];
-	bcm->noisecalc.samples[i][2] = radio->nrssi_lt[noise[2]];
-	bcm->noisecalc.samples[i][3] = radio->nrssi_lt[noise[3]];
-	bcm->noisecalc.nr_samples++;
-	if (bcm->noisecalc.nr_samples == 8) {
+	BCM43xx_WARN_ON(dev->noisecalc.nr_samples >= 8);
+	i = dev->noisecalc.nr_samples;
+	noise[0] = limit_value(noise[0], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);
+	noise[1] = limit_value(noise[1], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);
+	noise[2] = limit_value(noise[2], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);
+	noise[3] = limit_value(noise[3], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);
+	dev->noisecalc.samples[i][0] = phy->nrssi_lt[noise[0]];
+	dev->noisecalc.samples[i][1] = phy->nrssi_lt[noise[1]];
+	dev->noisecalc.samples[i][2] = phy->nrssi_lt[noise[2]];
+	dev->noisecalc.samples[i][3] = phy->nrssi_lt[noise[3]];
+	dev->noisecalc.nr_samples++;
+	if (dev->noisecalc.nr_samples == 8) {
 		/* Calculate the Link Quality by the noise samples. */
 		average = 0;
 		for (i = 0; i < 8; i++) {
 			for (j = 0; j < 4; j++)
-				average += bcm->noisecalc.samples[i][j];
+				average += dev->noisecalc.samples[i][j];
 		}
 		average /= (8 * 4);
 		average *= 125;
 		average += 64;
 		average /= 128;
-
-		tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x40C);
+		tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x40C);
 		tmp = (tmp / 128) & 0x1F;
 		if (tmp >= 8)
 			average += 2;
@@ -1526,403 +1020,575 @@ static void handle_irq_noise(struct bcm4
 		else
 			average -= 48;
 
-		bcm->stats.noise = average;
+		dev->stats.link_noise = average;
 drop_calculation:
-		bcm->noisecalc.calculation_running = 0;
+		dev->noisecalc.calculation_running = 0;
 		return;
 	}
 generate_new:
-	bcm43xx_generate_noise_sample(bcm);
+	bcm43xx_generate_noise_sample(dev);
 }
 
-static void handle_irq_ps(struct bcm43xx_private *bcm)
+static void handle_irq_tbtt_indication(struct bcm43xx_wldev *dev)
 {
-	if (bcm->ieee->iw_mode == IW_MODE_MASTER) {
-		///TODO: PS TBTT
+	if (bcm43xx_is_mode(dev->wl, IEEE80211_IF_TYPE_AP)) {
+		/* TODO: PS TBTT */
 	} else {
 		if (1/*FIXME: the last PSpoll frame was sent successfully */)
-			bcm43xx_power_saving_ctl_bits(bcm, -1, -1);
+			bcm43xx_power_saving_ctl_bits(dev, -1, -1);
 	}
-	if (bcm->ieee->iw_mode == IW_MODE_ADHOC)
-		bcm->reg124_set_0x4 = 1;
-	//FIXME else set to false?
+	dev->reg124_set_0x4 = 0;
+	if (bcm43xx_is_mode(dev->wl, IEEE80211_IF_TYPE_IBSS))
+		dev->reg124_set_0x4 = 1;
 }
 
-static void handle_irq_reg124(struct bcm43xx_private *bcm)
+static void handle_irq_atim_end(struct bcm43xx_wldev *dev)
 {
-	if (!bcm->reg124_set_0x4)
+	if (!dev->reg124_set_0x4 /*FIXME rename this variable*/)
 		return;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD)
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS2_BITFIELD,
+			bcm43xx_read32(dev, BCM43xx_MMIO_STATUS2_BITFIELD)
 			| 0x4);
-	//FIXME: reset reg124_set_0x4 to false?
 }
 
-static void handle_irq_pmq(struct bcm43xx_private *bcm)
+static void handle_irq_pmq(struct bcm43xx_wldev *dev)
 {
 	u32 tmp;
 
-	//TODO: AP mode.
+	/* TODO: AP mode. */
 
 	while (1) {
-		tmp = bcm43xx_read32(bcm, BCM43xx_MMIO_PS_STATUS);
+		tmp = bcm43xx_read32(dev, BCM43xx_MMIO_PS_STATUS);
 		if (!(tmp & 0x00000008))
 			break;
 	}
 	/* 16bit write is odd, but correct. */
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PS_STATUS, 0x0002);
+	bcm43xx_write16(dev, BCM43xx_MMIO_PS_STATUS, 0x0002);
 }
 
-static void bcm43xx_generate_beacon_template(struct bcm43xx_private *bcm,
-					     u16 ram_offset, u16 shm_size_offset)
+static void bcm43xx_write_template_common(struct bcm43xx_wldev *dev,
+					  const u8 *data, u16 size,
+					  u16 ram_offset,
+					  u16 shm_size_offset, u8 rate)
 {
-	u32 value;
-	u16 size = 0;
+	u32 i;
+	u32 tmp;
+	struct bcm43xx_plcp_hdr4 plcp;
+
+	plcp.data = 0;
+	bcm43xx_generate_plcp_hdr(&plcp, size + FCS_LEN, rate);
+	bcm43xx_ram_write(dev, ram_offset, le32_to_cpu(plcp.data));
+	ram_offset += sizeof(u32);
+	/* The PLCP is 6 bytes long, but we only wrote 4 bytes, yet.
+	 * So leave the first two bytes of the next write blank.
+	 */
+	tmp = (u32)(data[0]) << 16;
+	tmp |= (u32)(data[1]) << 24;
+	bcm43xx_ram_write(dev, ram_offset, tmp);
+	ram_offset += sizeof(u32);
+	for (i = 2; i < size; i += sizeof(u32)) {
+		tmp = (u32)(data[i + 0]);
+		if (i + 1 < size)
+			tmp |= (u32)(data[i + 1]) << 8;
+		if (i + 2 < size)
+			tmp |= (u32)(data[i + 2]) << 16;
+		if (i + 3 < size)
+			tmp |= (u32)(data[i + 3]) << 24;
+		bcm43xx_ram_write(dev, ram_offset + i - 2, tmp);
+	}
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, shm_size_offset,
+			    size + sizeof(struct bcm43xx_plcp_hdr6));
+}
+
+static void bcm43xx_write_beacon_template(struct bcm43xx_wldev *dev,
+					  u16 ram_offset,
+					  u16 shm_size_offset, u8 rate)
+{
+	int len;
+	const u8 *data;
+
+	BCM43xx_WARN_ON(!dev->cached_beacon);
+	len = min((size_t)dev->cached_beacon->len,
+		  0x200 - sizeof(struct bcm43xx_plcp_hdr6));
+	data = (const u8 *)(dev->cached_beacon->data);
+	bcm43xx_write_template_common(dev, data,
+				      len, ram_offset,
+				      shm_size_offset, rate);
+}
+
+static void bcm43xx_write_probe_resp_plcp(struct bcm43xx_wldev *dev,
+					  u16 shm_offset, u16 size, u8 rate)
+{
+	struct bcm43xx_plcp_hdr4 plcp;
+	u32 tmp;
+	__le16 dur;
+
+	plcp.data = 0;
+	bcm43xx_generate_plcp_hdr(&plcp, size + FCS_LEN, rate);
+	dur = ieee80211_generic_frame_duration(dev->wl->hw,
+					       size,
+					       BCM43xx_RATE_TO_100KBPS(rate));
+	/* Write PLCP in two parts and timing for packet transfer */
+	tmp = le32_to_cpu(plcp.data);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, shm_offset,
+			    tmp & 0xFFFF);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, shm_offset + 2,
+			    tmp >> 16);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, shm_offset + 6,
+			    le16_to_cpu(dur));
+}
+
+/* Instead of using custom probe response template, this function
+ * just patches custom beacon template by:
+ * 1) Changing packet type
+ * 2) Patching duration field
+ * 3) Stripping TIM
+ */
+static u8 *bcm43xx_generate_probe_resp(struct bcm43xx_wldev *dev,
+					u16 *dest_size, u8 rate)
+{
+	const u8 *src_data;
+	u8 *dest_data;
+	u16 src_size;
+	u16 elem_size;
+	u16 src_pos;
+	u16 dest_pos;
+	__le16 dur;
+	struct ieee80211_hdr *hdr;
+
+	BCM43xx_WARN_ON(!dev->cached_beacon);
+	src_size = dev->cached_beacon->len;
+	src_data = (const u8 *)dev->cached_beacon->data;
+
+	if (unlikely(src_size < 0x24)) {
+		bcmdbg(dev->wl, "bcm43xx_generate_probe_resp: "
+		       "invalid beacon\n");
+		return NULL;
+	}
+
+	dest_data = kmalloc(src_size, GFP_ATOMIC);
+	if (unlikely(!dest_data))
+		return NULL;
+
+	/* 0x24 is offset of first variable-len Information-Element
+	 * in beacon frame.
+	 */
+	memcpy(dest_data, src_data, 0x24);
+	src_pos = 0x24;
+	dest_pos = 0x24;
+	for ( ; src_pos < src_size - 2; src_pos += elem_size) {
+		elem_size = src_data[src_pos + 1] + 2;
+		if (src_data[src_pos] != 0x05) { /* TIM */
+			memcpy(dest_data + dest_pos, src_data + src_pos,
+			       elem_size);
+			dest_pos += elem_size;
+		}
+	}
+	*dest_size = dest_pos;
+	hdr = (struct ieee80211_hdr *)dest_data;
+
+	/* Set the frame control. */
+	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					 IEEE80211_STYPE_PROBE_RESP);
+	dur = ieee80211_generic_frame_duration(dev->wl->hw,
+					       *dest_size,
+					       BCM43xx_RATE_TO_100KBPS(rate));
+	hdr->duration_id = dur;
+
+	return dest_data;
+}
+
+static void bcm43xx_write_probe_resp_template(struct bcm43xx_wldev *dev,
+					      u16 ram_offset,
+					      u16 shm_size_offset, u8 rate)
+{
+	u8 *probe_resp_data;
+	u16 size;
+
+	BCM43xx_WARN_ON(!dev->cached_beacon);
+	size = dev->cached_beacon->len;
+	probe_resp_data = bcm43xx_generate_probe_resp(dev, &size, rate);
+	if (unlikely(!probe_resp_data))
+		return;
 
-	/* Timestamp. */
-	//FIXME: assumption: The chip sets the timestamp
-	value = 0;
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	size += 8;
+	/* Looks like PLCP headers plus packet timings are stored for
+	 * all possible basic rates
+	 */
+	bcm43xx_write_probe_resp_plcp(dev, 0x31A, size,
+				      BCM43xx_CCK_RATE_1MB);
+	bcm43xx_write_probe_resp_plcp(dev, 0x32C, size,
+				      BCM43xx_CCK_RATE_2MB);
+	bcm43xx_write_probe_resp_plcp(dev, 0x33E, size,
+				      BCM43xx_CCK_RATE_5MB);
+	bcm43xx_write_probe_resp_plcp(dev, 0x350, size,
+				      BCM43xx_CCK_RATE_11MB);
+
+	size = min((size_t)size,
+		   0x200 - sizeof(struct bcm43xx_plcp_hdr6));
+	bcm43xx_write_template_common(dev, probe_resp_data,
+				      size, ram_offset,
+				      shm_size_offset, rate);
+	kfree(probe_resp_data);
+}
+
+static int bcm43xx_refresh_cached_beacon(struct bcm43xx_wldev *dev,
+					 struct sk_buff *beacon)
+{
+	if (dev->cached_beacon)
+		kfree_skb(dev->cached_beacon);
+	dev->cached_beacon = beacon;
+
+	return 0;
+}
 
-	/* Beacon Interval / Capability Information */
-	value = 0x0000;//FIXME: Which interval?
-	value |= (1 << 0) << 16; /* ESS */
-	value |= (1 << 2) << 16; /* CF Pollable */	//FIXME?
-	value |= (1 << 3) << 16; /* CF Poll Request */	//FIXME?
-	if (!bcm->ieee->open_wep)
-		value |= (1 << 4) << 16; /* Privacy */
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	size += 4;
+static void bcm43xx_update_templates(struct bcm43xx_wldev *dev)
+{
+	u32 status;
 
-	/* SSID */
-	//TODO
+	BCM43xx_WARN_ON(!dev->cached_beacon);
 
-	/* FH Parameter Set */
-	//TODO
+	bcm43xx_write_beacon_template(dev, 0x68, 0x18,
+				      BCM43xx_CCK_RATE_1MB);
+	bcm43xx_write_beacon_template(dev, 0x468, 0x1A,
+				      BCM43xx_CCK_RATE_1MB);
+	bcm43xx_write_probe_resp_template(dev, 0x268, 0x4A,
+					  BCM43xx_CCK_RATE_11MB);
+
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS2_BITFIELD);
+	status |= 0x03;
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS2_BITFIELD, status);
+}
 
-	/* DS Parameter Set */
-	//TODO
+static void bcm43xx_refresh_templates(struct bcm43xx_wldev *dev,
+				      struct sk_buff *beacon)
+{
+	int err;
 
-	/* CF Parameter Set */
-	//TODO
+	err = bcm43xx_refresh_cached_beacon(dev, beacon);
+	if (unlikely(err))
+		return;
+	bcm43xx_update_templates(dev);
+}
 
-	/* TIM */
-	//TODO
+static void bcm43xx_set_ssid(struct bcm43xx_wldev *dev,
+			     const u8 *ssid, u8 ssid_len)
+{
+	u32 tmp;
+	u16 i;
+	u16 len;
 
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, shm_size_offset, size);
+	len = min((u16)ssid_len, (u16)0x100);
+	for (i = 0; i < len; i += sizeof(u32)) {
+		tmp = (u32)(ssid[i + 0]);
+		if (i + 1 < len)
+			tmp |= (u32)(ssid[i + 1]) << 8;
+		if (i + 2 < len)
+			tmp |= (u32)(ssid[i + 2]) << 16;
+		if (i + 3 < len)
+			tmp |= (u32)(ssid[i + 3]) << 24;
+		bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED,
+				    0x380 + i, tmp);
+	}
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    0x48, len);
+}
+
+static void bcm43xx_set_beacon_int(struct bcm43xx_wldev *dev, u16 beacon_int)
+{
+	bcm43xx_time_lock(dev);
+	if (dev->dev->id.revision >= 3) {
+		bcm43xx_write32(dev, 0x188, (beacon_int << 16));
+	} else {
+		bcm43xx_write16(dev, 0x606, (beacon_int >> 6));
+		bcm43xx_write16(dev, 0x610, beacon_int);
+	}
+	bcm43xx_time_unlock(dev);
 }
 
-static void handle_irq_beacon(struct bcm43xx_private *bcm)
+static void handle_irq_beacon(struct bcm43xx_wldev *dev)
 {
 	u32 status;
 
-	bcm->irq_savedstate &= ~BCM43xx_IRQ_BEACON;
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD);
+	if (!bcm43xx_is_mode(dev->wl, IEEE80211_IF_TYPE_AP))
+		return;
+
+	dev->irq_savedstate &= ~BCM43xx_IRQ_BEACON;
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS2_BITFIELD);
 
-	if ((status & 0x1) && (status & 0x2)) {
+	if (!dev->cached_beacon || ((status & 0x1) && (status & 0x2))) {
 		/* ACK beacon IRQ. */
-		bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON,
+		bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_REASON,
 				BCM43xx_IRQ_BEACON);
-		bcm->irq_savedstate |= BCM43xx_IRQ_BEACON;
+		dev->irq_savedstate |= BCM43xx_IRQ_BEACON;
+		if (dev->cached_beacon)
+			kfree_skb(dev->cached_beacon);
+		dev->cached_beacon = NULL;
 		return;
 	}
 	if (!(status & 0x1)) {
-		bcm43xx_generate_beacon_template(bcm, 0x68, 0x18);
+		bcm43xx_write_beacon_template(dev, 0x68, 0x18,
+					      BCM43xx_CCK_RATE_1MB);
 		status |= 0x1;
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD, status);
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS2_BITFIELD,
+				status);
 	}
 	if (!(status & 0x2)) {
-		bcm43xx_generate_beacon_template(bcm, 0x468, 0x1A);
+		bcm43xx_write_beacon_template(dev, 0x468, 0x1A,
+					      BCM43xx_CCK_RATE_1MB);
 		status |= 0x2;
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD, status);
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS2_BITFIELD,
+				status);
 	}
 }
 
+static void handle_irq_ucode_debug(struct bcm43xx_wldev *dev)
+{
+}
+
 /* Interrupt handler bottom-half */
-static void bcm43xx_interrupt_tasklet(struct bcm43xx_private *bcm)
+static void bcm43xx_interrupt_tasklet(struct bcm43xx_wldev *dev)
 {
 	u32 reason;
-	u32 dma_reason[6];
+	u32 dma_reason[ARRAY_SIZE(dev->dma_reason)];
 	u32 merged_dma_reason = 0;
 	int i, activity = 0;
 	unsigned long flags;
 
-#ifdef CONFIG_BCM43XX_DEBUG
-	u32 _handled = 0x00000000;
-# define bcmirq_handled(irq)	do { _handled |= (irq); } while (0)
-#else
-# define bcmirq_handled(irq)	do { /* nothing */ } while (0)
-#endif /* CONFIG_BCM43XX_DEBUG*/
-
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	reason = bcm->irq_reason;
-	for (i = 5; i >= 0; i--) {
-		dma_reason[i] = bcm->dma_reason[i];
-		merged_dma_reason |= dma_reason[i];
-	}
-
-	if (unlikely(reason & BCM43xx_IRQ_XMIT_ERROR)) {
-		/* TX error. We get this when Template Ram is written in wrong endianess
-		 * in dummy_tx(). We also get this if something is wrong with the TX header
-		 * on DMA or PIO queues.
-		 * Maybe we get this in other error conditions, too.
-		 */
-		printkl(KERN_ERR PFX "FATAL ERROR: BCM43xx_IRQ_XMIT_ERROR\n");
-		bcmirq_handled(BCM43xx_IRQ_XMIT_ERROR);
-	}
-	if (unlikely(merged_dma_reason & BCM43xx_DMAIRQ_FATALMASK)) {
-		printkl(KERN_ERR PFX "FATAL ERROR: Fatal DMA error: "
-				     "0x%08X, 0x%08X, 0x%08X, "
-				     "0x%08X, 0x%08X, 0x%08X\n",
-		        dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3],
-			dma_reason[4], dma_reason[5]);
-		bcm43xx_controller_restart(bcm, "DMA error");
-		mmiowb();
-		spin_unlock_irqrestore(&bcm->irq_lock, flags);
-		return;
-	}
-	if (unlikely(merged_dma_reason & BCM43xx_DMAIRQ_NONFATALMASK)) {
-		printkl(KERN_ERR PFX "DMA error: "
-				     "0x%08X, 0x%08X, 0x%08X, "
-				     "0x%08X, 0x%08X, 0x%08X\n",
-		        dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3],
-			dma_reason[4], dma_reason[5]);
-	}
-
-	if (reason & BCM43xx_IRQ_PS) {
-		handle_irq_ps(bcm);
-		bcmirq_handled(BCM43xx_IRQ_PS);
-	}
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
 
-	if (reason & BCM43xx_IRQ_REG124) {
-		handle_irq_reg124(bcm);
-		bcmirq_handled(BCM43xx_IRQ_REG124);
-	}
+	BCM43xx_WARN_ON(bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED);
 
-	if (reason & BCM43xx_IRQ_BEACON) {
-		if (bcm->ieee->iw_mode == IW_MODE_MASTER)
-			handle_irq_beacon(bcm);
-		bcmirq_handled(BCM43xx_IRQ_BEACON);
+	reason = dev->irq_reason;
+	for (i = 0; i < ARRAY_SIZE(dma_reason); i++) {
+		dma_reason[i] = dev->dma_reason[i];
+		merged_dma_reason |= dma_reason[i];
 	}
 
-	if (reason & BCM43xx_IRQ_PMQ) {
-		handle_irq_pmq(bcm);
-		bcmirq_handled(BCM43xx_IRQ_PMQ);
-	}
+	if (unlikely(reason & BCM43xx_IRQ_MAC_TXERR))
+		bcmerr(dev->wl, "MAC transmission error\n");
 
-	if (reason & BCM43xx_IRQ_SCAN) {
-		/*TODO*/
-		//bcmirq_handled(BCM43xx_IRQ_SCAN);
-	}
+	if (unlikely(reason & BCM43xx_IRQ_PHY_TXERR))
+		bcmerr(dev->wl, "PHY transmission error\n");
 
-	if (reason & BCM43xx_IRQ_NOISE) {
-		handle_irq_noise(bcm);
-		bcmirq_handled(BCM43xx_IRQ_NOISE);
-	}
+	if (unlikely(merged_dma_reason & (BCM43xx_DMAIRQ_FATALMASK |
+					  BCM43xx_DMAIRQ_NONFATALMASK))) {
+		if (merged_dma_reason & BCM43xx_DMAIRQ_FATALMASK) {
+			bcmerr(dev->wl, "Fatal DMA error: "
+			       "0x%08X, 0x%08X, 0x%08X, "
+			       "0x%08X, 0x%08X, 0x%08X\n",
+			       dma_reason[0], dma_reason[1],
+			       dma_reason[2], dma_reason[3],
+			       dma_reason[4], dma_reason[5]);
+			bcm43xx_controller_restart(dev, "DMA error");
+			mmiowb();
+			spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+			return;
+		}
+		if (merged_dma_reason & BCM43xx_DMAIRQ_NONFATALMASK)
+			bcmerr(dev->wl, "DMA error: "
+			       "0x%08X, 0x%08X, 0x%08X, "
+			       "0x%08X, 0x%08X, 0x%08X\n",
+			       dma_reason[0], dma_reason[1],
+			       dma_reason[2], dma_reason[3],
+			       dma_reason[4], dma_reason[5]);
+	}
+
+	if (unlikely(reason & BCM43xx_IRQ_UCODE_DEBUG))
+		handle_irq_ucode_debug(dev);
+	if (reason & BCM43xx_IRQ_TBTT_INDI)
+		handle_irq_tbtt_indication(dev);
+	if (reason & BCM43xx_IRQ_ATIM_END)
+		handle_irq_atim_end(dev);
+	if (reason & BCM43xx_IRQ_BEACON)
+		handle_irq_beacon(dev);
+	if (reason & BCM43xx_IRQ_PMQ)
+		handle_irq_pmq(dev);
+	if (reason & BCM43xx_IRQ_TXFIFO_FLUSH_OK)
+		;/*TODO*/
+	if (reason & BCM43xx_IRQ_NOISESAMPLE_OK)
+		handle_irq_noise(dev);
 
 	/* Check the DMA reason registers for received data. */
 	if (dma_reason[0] & BCM43xx_DMAIRQ_RX_DONE) {
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_rx(bcm43xx_current_pio(bcm)->queue0);
+		if (bcm43xx_using_pio(dev))
+			bcm43xx_pio_rx(dev->pio.queue0);
 		else
-			bcm43xx_dma_rx(bcm43xx_current_dma(bcm)->rx_ring0);
+			bcm43xx_dma_rx(dev->dma.rx_ring0);
 		/* We intentionally don't set "activity" to 1, here. */
 	}
-	assert(!(dma_reason[1] & BCM43xx_DMAIRQ_RX_DONE));
-	assert(!(dma_reason[2] & BCM43xx_DMAIRQ_RX_DONE));
+	BCM43xx_WARN_ON(dma_reason[1] & BCM43xx_DMAIRQ_RX_DONE);
+	BCM43xx_WARN_ON(dma_reason[2] & BCM43xx_DMAIRQ_RX_DONE);
 	if (dma_reason[3] & BCM43xx_DMAIRQ_RX_DONE) {
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_rx(bcm43xx_current_pio(bcm)->queue3);
+		if (bcm43xx_using_pio(dev))
+			bcm43xx_pio_rx(dev->pio.queue3);
 		else
-			bcm43xx_dma_rx(bcm43xx_current_dma(bcm)->rx_ring3);
+			bcm43xx_dma_rx(dev->dma.rx_ring3);
 		activity = 1;
 	}
-	assert(!(dma_reason[4] & BCM43xx_DMAIRQ_RX_DONE));
-	assert(!(dma_reason[5] & BCM43xx_DMAIRQ_RX_DONE));
-	bcmirq_handled(BCM43xx_IRQ_RX);
+	BCM43xx_WARN_ON(dma_reason[4] & BCM43xx_DMAIRQ_RX_DONE);
+	BCM43xx_WARN_ON(dma_reason[5] & BCM43xx_DMAIRQ_RX_DONE);
 
-	if (reason & BCM43xx_IRQ_XMIT_STATUS) {
-		handle_irq_transmit_status(bcm);
+	if (reason & BCM43xx_IRQ_TX_OK) {
+		handle_irq_transmit_status(dev);
 		activity = 1;
-		//TODO: In AP mode, this also causes sending of powersave responses.
-		bcmirq_handled(BCM43xx_IRQ_XMIT_STATUS);
+		/* TODO: In AP mode, this also causes sending of powersave
+			 responses. */
 	}
 
-	/* IRQ_PIO_WORKAROUND is handled in the top-half. */
-	bcmirq_handled(BCM43xx_IRQ_PIO_WORKAROUND);
-#ifdef CONFIG_BCM43XX_DEBUG
-	if (unlikely(reason & ~_handled)) {
-		printkl(KERN_WARNING PFX
-			"Unhandled IRQ! Reason: 0x%08x,  Unhandled: 0x%08x,  "
-			"DMA: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
-			reason, (reason & ~_handled),
-			dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3]);
-	}
-#endif
-#undef bcmirq_handled
-
 	if (!modparam_noleds)
-		bcm43xx_leds_update(bcm, activity);
-	bcm43xx_interrupt_enable(bcm, bcm->irq_savedstate);
+		bcm43xx_leds_update(dev, activity);
+	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
 	mmiowb();
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
 }
 
-static void pio_irq_workaround(struct bcm43xx_private *bcm,
+static void pio_irq_workaround(struct bcm43xx_wldev *dev,
 			       u16 base, int queueidx)
 {
 	u16 rxctl;
 
-	rxctl = bcm43xx_read16(bcm, base + BCM43xx_PIO_RXCTL);
+	rxctl = bcm43xx_read16(dev, base + BCM43xx_PIO_RXCTL);
 	if (rxctl & BCM43xx_PIO_RXCTL_DATAAVAILABLE)
-		bcm->dma_reason[queueidx] |= BCM43xx_DMAIRQ_RX_DONE;
+		dev->dma_reason[queueidx] |= BCM43xx_DMAIRQ_RX_DONE;
 	else
-		bcm->dma_reason[queueidx] &= ~BCM43xx_DMAIRQ_RX_DONE;
+		dev->dma_reason[queueidx] &= ~BCM43xx_DMAIRQ_RX_DONE;
 }
 
-static void bcm43xx_interrupt_ack(struct bcm43xx_private *bcm, u32 reason)
+static void bcm43xx_interrupt_ack(struct bcm43xx_wldev *dev, u32 reason)
 {
-	if (bcm43xx_using_pio(bcm) &&
-	    (bcm->current_core->rev < 3) &&
+	if (bcm43xx_using_pio(dev) &&
+	    (dev->dev->id.revision < 3) &&
 	    (!(reason & BCM43xx_IRQ_PIO_WORKAROUND))) {
 		/* Apply a PIO specific workaround to the dma_reasons */
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO1_BASE, 0);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO2_BASE, 1);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO3_BASE, 2);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO4_BASE, 3);
-	}
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, reason);
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA0_REASON,
-			bcm->dma_reason[0]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA1_REASON,
-			bcm->dma_reason[1]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA2_REASON,
-			bcm->dma_reason[2]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA3_REASON,
-			bcm->dma_reason[3]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA4_REASON,
-			bcm->dma_reason[4]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA5_REASON,
-			bcm->dma_reason[5]);
+		pio_irq_workaround(dev, BCM43xx_MMIO_PIO1_BASE, 0);
+		pio_irq_workaround(dev, BCM43xx_MMIO_PIO2_BASE, 1);
+		pio_irq_workaround(dev, BCM43xx_MMIO_PIO3_BASE, 2);
+		pio_irq_workaround(dev, BCM43xx_MMIO_PIO4_BASE, 3);
+	}
+
+	bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_REASON, reason);
+
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA0_REASON,
+			dev->dma_reason[0]);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA1_REASON,
+			dev->dma_reason[1]);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA2_REASON,
+			dev->dma_reason[2]);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA3_REASON,
+			dev->dma_reason[3]);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA4_REASON,
+			dev->dma_reason[4]);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA5_REASON,
+			dev->dma_reason[5]);
 }
 
 /* Interrupt handler top-half */
 static irqreturn_t bcm43xx_interrupt_handler(int irq, void *dev_id)
 {
 	irqreturn_t ret = IRQ_HANDLED;
-	struct bcm43xx_private *bcm = dev_id;
+	struct bcm43xx_wldev *dev = dev_id;
 	u32 reason;
 
-	if (!bcm)
+	if (!dev)
 		return IRQ_NONE;
 
-	spin_lock(&bcm->irq_lock);
+	spin_lock(&dev->wl->irq_lock);
 
-	reason = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-	if (reason == 0xffffffff) {
-		/* irq not for us (shared irq) */
-		ret = IRQ_NONE;
+	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED)
 		goto out;
-	}
-	reason &= bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
+	reason = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
+	if (reason == 0xffffffff) /* shared IRQ */
+		goto out;
+	reason &= bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
 	if (!reason)
 		goto out;
 
-	assert(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED);
-	assert(bcm->current_core->id == BCM43xx_COREID_80211);
+	BCM43xx_WARN_ON(bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED);
 
-	bcm->dma_reason[0] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA0_REASON)
+	dev->dma_reason[0] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA0_REASON)
 			     & 0x0001DC00;
-	bcm->dma_reason[1] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA1_REASON)
+	dev->dma_reason[1] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA1_REASON)
 			     & 0x0000DC00;
-	bcm->dma_reason[2] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA2_REASON)
+	dev->dma_reason[2] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA2_REASON)
 			     & 0x0000DC00;
-	bcm->dma_reason[3] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA3_REASON)
+	dev->dma_reason[3] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA3_REASON)
 			     & 0x0001DC00;
-	bcm->dma_reason[4] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA4_REASON)
+	dev->dma_reason[4] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA4_REASON)
 			     & 0x0000DC00;
-	bcm->dma_reason[5] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA5_REASON)
+	dev->dma_reason[5] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA5_REASON)
 			     & 0x0000DC00;
 
-	bcm43xx_interrupt_ack(bcm, reason);
-
+	bcm43xx_interrupt_ack(dev, reason);
 	/* disable all IRQs. They are enabled again in the bottom half. */
-	bcm->irq_savedstate = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
+	dev->irq_savedstate = bcm43xx_interrupt_disable(dev, BCM43xx_IRQ_ALL);
 	/* save the reason code and call our bottom half. */
-	bcm->irq_reason = reason;
-	tasklet_schedule(&bcm->isr_tasklet);
-
+	dev->irq_reason = reason;
+	tasklet_schedule(&dev->isr_tasklet);
 out:
 	mmiowb();
-	spin_unlock(&bcm->irq_lock);
+	spin_unlock(&dev->wl->irq_lock);
 
 	return ret;
 }
 
-static void bcm43xx_release_firmware(struct bcm43xx_private *bcm, int force)
+static void bcm43xx_release_firmware(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	if (bcm->firmware_norelease && !force)
-		return; /* Suspending or controller reset. */
-	release_firmware(phy->ucode);
-	phy->ucode = NULL;
-	release_firmware(phy->pcm);
-	phy->pcm = NULL;
-	release_firmware(phy->initvals0);
-	phy->initvals0 = NULL;
-	release_firmware(phy->initvals1);
-	phy->initvals1 = NULL;
+	release_firmware(dev->fw.ucode);
+	dev->fw.ucode = NULL;
+	release_firmware(dev->fw.pcm);
+	dev->fw.pcm = NULL;
+	release_firmware(dev->fw.initvals0);
+	dev->fw.initvals0 = NULL;
+	release_firmware(dev->fw.initvals1);
+	dev->fw.initvals1 = NULL;
 }
 
-static int bcm43xx_request_firmware(struct bcm43xx_private *bcm)
+static int bcm43xx_request_firmware(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u8 rev = bcm->current_core->rev;
+	u8 rev = dev->dev->id.revision;
 	int err = 0;
 	int nr;
 	char buf[22 + sizeof(modparam_fwpostfix) - 1] = { 0 };
 
-	if (!phy->ucode) {
+	if (!dev->fw.ucode) {
 		snprintf(buf, ARRAY_SIZE(buf), "bcm43xx_microcode%d%s.fw",
 			 (rev >= 5 ? 5 : rev),
 			 modparam_fwpostfix);
-		err = request_firmware(&phy->ucode, buf, &bcm->pci_dev->dev);
+		err = request_firmware(&dev->fw.ucode, buf, dev->dev->dev);
 		if (err) {
-			printk(KERN_ERR PFX 
-			       "Error: Microcode \"%s\" not available or load failed.\n",
-			        buf);
-			goto error;
+			snprintf(buf, ARRAY_SIZE(buf), "bcm43xx_microcode%d.fw",
+				 (rev >= 5 ? 5 : rev));
+			err = request_firmware(&dev->fw.ucode, buf,
+					       dev->dev->dev);
+			if (err) {
+				bcmerr(dev->wl, "Microcode \"%s\" not "
+				       "available or load failed.\n", buf);
+				goto error;
+			}
 		}
+		bcminfo(dev->wl, "bcm43xx: Microcode %s loaded\n", buf);
 	}
 
-	if (!phy->pcm) {
-		snprintf(buf, ARRAY_SIZE(buf),
-			 "bcm43xx_pcm%d%s.fw",
-			 (rev < 5 ? 4 : 5),
-			 modparam_fwpostfix);
-		err = request_firmware(&phy->pcm, buf, &bcm->pci_dev->dev);
+	if (!dev->fw.pcm) {
+		snprintf(buf, ARRAY_SIZE(buf), "bcm43xx_pcm%d%s.fw",
+			 (rev < 5 ? 4 : 5), modparam_fwpostfix);
+		err = request_firmware(&dev->fw.pcm, buf, dev->dev->dev);
 		if (err) {
-			printk(KERN_ERR PFX
-			       "Error: PCM \"%s\" not available or load failed.\n",
-			       buf);
-			goto error;
+			snprintf(buf, ARRAY_SIZE(buf), "bcm43xx_pcm%d.fw",
+				 (rev < 5 ? 4 : 5));
+			err = request_firmware(&dev->fw.pcm, buf,
+					       dev->dev->dev);
+			if (err) {
+				bcmerr(dev->wl, "PCM \"%s\" not available "
+				       "or load failed.\n", buf);
+				goto error;
+			}
 		}
 	}
 
-	if (!phy->initvals0) {
+	if (!dev->fw.initvals0) {
 		if (rev == 2 || rev == 4) {
-			switch (phy->type) {
-			case BCM43xx_PHYTYPE_A:
-				nr = 3;
-				break;
+			switch (dev->phy.type) {
 			case BCM43xx_PHYTYPE_B:
 			case BCM43xx_PHYTYPE_G:
 				nr = 1;
@@ -1930,12 +1596,9 @@ static int bcm43xx_request_firmware(stru
 			default:
 				goto err_noinitval;
 			}
-		
+
 		} else if (rev >= 5) {
-			switch (phy->type) {
-			case BCM43xx_PHYTYPE_A:
-				nr = 7;
-				break;
+			switch (dev->phy.type) {
 			case BCM43xx_PHYTYPE_B:
 			case BCM43xx_PHYTYPE_G:
 				nr = 5;
@@ -1943,36 +1606,34 @@ static int bcm43xx_request_firmware(stru
 			default:
 				goto err_noinitval;
 			}
-		} else
+		} else {
 			goto err_noinitval;
+		}
 		snprintf(buf, ARRAY_SIZE(buf), "bcm43xx_initval%02d%s.fw",
 			 nr, modparam_fwpostfix);
 
-		err = request_firmware(&phy->initvals0, buf, &bcm->pci_dev->dev);
+		err = request_firmware(&dev->fw.initvals0, buf, dev->dev->dev);
 		if (err) {
-			printk(KERN_ERR PFX 
-			       "Error: InitVals \"%s\" not available or load failed.\n",
-			        buf);
-			goto error;
+			snprintf(buf, ARRAY_SIZE(buf), "bcm43xx_initval%02d.fw",
+				 nr);
+
+			err = request_firmware(&dev->fw.initvals0, buf,
+					       dev->dev->dev);
+			if (err) {
+				bcmerr(dev->wl, "InitVals \"%s\" not available "
+				       "or load failed.\n", buf);
+				goto error;
+			}
 		}
-		if (phy->initvals0->size % sizeof(struct bcm43xx_initval)) {
-			printk(KERN_ERR PFX "InitVals fileformat error.\n");
+		if (dev->fw.initvals0->size % sizeof(struct bcm43xx_initval)) {
+			bcmerr(dev->wl, "InitVals fileformat error.\n");
 			goto error;
 		}
 	}
 
-	if (!phy->initvals1) {
+	if (!dev->fw.initvals1) {
 		if (rev >= 5) {
-			u32 sbtmstatehigh;
-
-			switch (phy->type) {
-			case BCM43xx_PHYTYPE_A:
-				sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-				if (sbtmstatehigh & 0x00010000)
-					nr = 9;
-				else
-					nr = 10;
-				break;
+			switch (dev->phy.type) {
 			case BCM43xx_PHYTYPE_B:
 			case BCM43xx_PHYTYPE_G:
 					nr = 6;
@@ -1980,18 +1641,28 @@ static int bcm43xx_request_firmware(stru
 			default:
 				goto err_noinitval;
 			}
-			snprintf(buf, ARRAY_SIZE(buf), "bcm43xx_initval%02d%s.fw",
+			snprintf(buf, ARRAY_SIZE(buf),
+				 "bcm43xx_initval%02d%s.fw",
 				 nr, modparam_fwpostfix);
 
-			err = request_firmware(&phy->initvals1, buf, &bcm->pci_dev->dev);
+			err = request_firmware(&dev->fw.initvals1, buf,
+					       dev->dev->dev);
 			if (err) {
-				printk(KERN_ERR PFX 
-				       "Error: InitVals \"%s\" not available or load failed.\n",
-			        	buf);
-				goto error;
+				snprintf(buf, ARRAY_SIZE(buf),
+					 "bcm43xx_initval%02d.fw", nr);
+
+				err = request_firmware(&dev->fw.initvals1, buf,
+						       dev->dev->dev);
+				if (err) {
+					bcmerr(dev->wl, "InitVals \"%s\" not "
+					       "available or load failed.\n",
+					       buf);
+					goto error;
+				}
 			}
-			if (phy->initvals1->size % sizeof(struct bcm43xx_initval)) {
-				printk(KERN_ERR PFX "InitVals fileformat error.\n");
+			if (dev->fw.initvals1->size
+				% sizeof(struct bcm43xx_initval)) {
+				bcmerr(dev->wl, "InitVals format error.\n");
 				goto error;
 			}
 		}
@@ -2000,44 +1671,102 @@ static int bcm43xx_request_firmware(stru
 out:
 	return err;
 error:
-	bcm43xx_release_firmware(bcm, 1);
+	bcm43xx_release_firmware(dev);
 	goto out;
 err_noinitval:
-	printk(KERN_ERR PFX "Error: No InitVals available!\n");
+	bcmerr(dev->wl, "No InitVals available\n");
 	err = -ENOENT;
 	goto error;
 }
 
-static void bcm43xx_upload_microcode(struct bcm43xx_private *bcm)
+static int bcm43xx_upload_microcode(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	const u32 *data;
-	unsigned int i, len;
+	const __be32 *data;
+	unsigned int i;
+	unsigned int len;
+	u16 fwrev;
+	u16 fwpatch;
+	u16 fwdate;
+	u16 fwtime;
+	u32 tmp;
+	int err = 0;
 
 	/* Upload Microcode. */
-	data = (u32 *)(phy->ucode->data);
-	len = phy->ucode->size / sizeof(u32);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_UCODE, 0x0000);
+	data = (__be32 *)(dev->fw.ucode->data);
+	len = dev->fw.ucode->size / sizeof(__be32);
+	bcm43xx_shm_control_word(dev,
+				 BCM43xx_SHM_UCODE | BCM43xx_SHM_AUTOINC_W,
+				 0x0000);
 	for (i = 0; i < len; i++) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA,
+		bcm43xx_write32(dev, BCM43xx_MMIO_SHM_DATA,
 				be32_to_cpu(data[i]));
 		udelay(10);
 	}
 
 	/* Upload PCM data. */
-	data = (u32 *)(phy->pcm->data);
-	len = phy->pcm->size / sizeof(u32);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_PCM, 0x01ea);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA, 0x00004000);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_PCM, 0x01eb);
+	data = (__be32 *)(dev->fw.pcm->data);
+	len = dev->fw.pcm->size / sizeof(__be32);
+	bcm43xx_shm_control_word(dev, BCM43xx_SHM_HW, 0x01EA);
+	bcm43xx_write32(dev, BCM43xx_MMIO_SHM_DATA, 0x00004000);
+	/* No need for autoinc bit in SHM_HW */
+	bcm43xx_shm_control_word(dev, BCM43xx_SHM_HW, 0x01EB);
 	for (i = 0; i < len; i++) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA,
+		bcm43xx_write32(dev, BCM43xx_MMIO_SHM_DATA,
 				be32_to_cpu(data[i]));
 		udelay(10);
 	}
+
+	bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_REASON, BCM43xx_IRQ_ALL);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, 0x00020402);
+
+	/* Wait for the microcode to load and respond */
+	i = 0;
+	while (1) {
+		tmp = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
+		if (tmp == BCM43xx_IRQ_MAC_SUSPENDED)
+			break;
+		i++;
+		if (i >= BCM43xx_IRQWAIT_MAX_RETRIES) {
+			bcmerr(dev->wl, "Microcode not responding\n");
+			err = -ENODEV;
+			goto out;
+		}
+		udelay(10);
+	}
+	bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
+
+	/* Get and check the revisions. */
+	fwrev = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				   BCM43xx_SHM_SH_UCODEREV);
+	fwpatch = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				     BCM43xx_SHM_SH_UCODEPATCH);
+	fwdate = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				    BCM43xx_SHM_SH_UCODEDATE);
+	fwtime = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				    BCM43xx_SHM_SH_UCODETIME);
+
+	if (fwrev > 0x128) {
+		bcmerr(dev->wl, "YOUR FIRMWARE IS TOO NEW. Only firmware "
+		       "from binary drivers version 3.x is supported. "
+		       "You must change your firmware files.\n");
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, 0);
+		err = -EOPNOTSUPP;
+		goto out;
+	}
+	bcmdbg(dev->wl, "Loading firmware version 0x%X, patch level %u "
+			      "(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\n",
+	       fwrev, fwpatch,
+	       (fwdate >> 12) & 0xF, (fwdate >> 8) & 0xF, fwdate & 0xFF,
+	       (fwtime >> 11) & 0x1F, (fwtime >> 5) & 0x3F, fwtime & 0x1F);
+
+	dev->fw.rev = fwrev;
+	dev->fw.patch = fwpatch;
+
+out:
+	return err;
 }
 
-static int bcm43xx_write_initvals(struct bcm43xx_private *bcm,
+static int bcm43xx_write_initvals(struct bcm43xx_wldev *dev,
 				  const struct bcm43xx_initval *data,
 				  const unsigned int len)
 {
@@ -2055,33 +1784,37 @@ static int bcm43xx_write_initvals(struct
 		if (size == 2) {
 			if (unlikely(value & 0xFFFF0000))
 				goto err_format;
-			bcm43xx_write16(bcm, offset, (u16)value);
+			bcm43xx_write16(dev, offset, (u16)value);
 		} else if (size == 4) {
-			bcm43xx_write32(bcm, offset, value);
-		} else
+			bcm43xx_write32(dev, offset, value);
+		} else {
 			goto err_format;
+		}
 	}
 
 	return 0;
 
 err_format:
-	printk(KERN_ERR PFX "InitVals (bcm43xx_initvalXX.fw) file-format error. "
-			    "Please fix your bcm43xx firmware files.\n");
+	bcmerr(dev->wl, "InitVals (bcm43xx_initvalXX.fw) file-format error. "
+	       "Please fix your bcm43xx firmware files.\n");
 	return -EPROTO;
 }
 
-static int bcm43xx_upload_initvals(struct bcm43xx_private *bcm)
+static int bcm43xx_upload_initvals(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
 	int err;
 
-	err = bcm43xx_write_initvals(bcm, (struct bcm43xx_initval *)phy->initvals0->data,
-				     phy->initvals0->size / sizeof(struct bcm43xx_initval));
+	err = bcm43xx_write_initvals(dev,
+			     (struct bcm43xx_initval *)dev->fw.initvals0->data,
+			     dev->fw.initvals0->size /
+			     sizeof(struct bcm43xx_initval));
 	if (err)
 		goto out;
-	if (phy->initvals1) {
-		err = bcm43xx_write_initvals(bcm, (struct bcm43xx_initval *)phy->initvals1->data,
-					     phy->initvals1->size / sizeof(struct bcm43xx_initval));
+	if (dev->fw.initvals1) {
+		err = bcm43xx_write_initvals(dev,
+			     (struct bcm43xx_initval *)dev->fw.initvals1->data,
+			     dev->fw.initvals1->size /
+			     sizeof(struct bcm43xx_initval));
 		if (err)
 			goto out;
 	}
@@ -2089,2180 +1822,2164 @@ out:
 	return err;
 }
 
-static int bcm43xx_initialize_irq(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	bcm->irq = bcm->pci_dev->irq;
-	err = request_irq(bcm->irq, bcm43xx_interrupt_handler,
-			  IRQF_SHARED, KBUILD_MODNAME, bcm);
-	if (err)
-		printk(KERN_ERR PFX "Cannot register IRQ%d\n", bcm->irq);
-
-	return err;
-}
-
-/* Switch to the core used to write the GPIO register.
- * This is either the ChipCommon, or the PCI core.
- */
-static int switch_to_gpio_core(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	/* Where to find the GPIO register depends on the chipset.
-	 * If it has a ChipCommon, its register at offset 0x6c is the GPIO
-	 * control register. Otherwise the register at offset 0x6c in the
-	 * PCI core is the GPIO control register.
-	 */
-	err = bcm43xx_switch_core(bcm, &bcm->core_chipcommon);
-	if (err == -ENODEV) {
-		err = bcm43xx_switch_core(bcm, &bcm->core_pci);
-		if (unlikely(err == -ENODEV)) {
-			printk(KERN_ERR PFX "gpio error: "
-			       "Neither ChipCommon nor PCI core available!\n");
-		}
-	}
-
-	return err;
-}
-
 /* Initialize the GPIOs
  * http://bcm-specs.sipsolutions.net/GPIO
  */
-static int bcm43xx_gpio_init(struct bcm43xx_private *bcm)
+static int bcm43xx_gpio_init(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_coreinfo *old_core;
-	int err;
+	struct ssb_bus *bus = dev->dev->bus;
+	struct ssb_device *gpiodev, *pcidev = NULL;
 	u32 mask, set;
 
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+			bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD)
 			& 0xFFFF3FFF);
 
-	bcm43xx_leds_switch_all(bcm, 0);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-			bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK) | 0x000F);
+	bcm43xx_leds_switch_all(dev, 0);
+	bcm43xx_write16(dev, BCM43xx_MMIO_GPIO_MASK,
+			bcm43xx_read16(dev, BCM43xx_MMIO_GPIO_MASK)
+			| 0x000F);
 
 	mask = 0x0000001F;
 	set = 0x0000000F;
-	if (bcm->chip_id == 0x4301) {
+	if (dev->dev->bus->chip_id == 0x4301) {
 		mask |= 0x0060;
 		set |= 0x0060;
 	}
 	if (0 /* FIXME: conditional unknown */) {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-				bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK)
+		bcm43xx_write16(dev, BCM43xx_MMIO_GPIO_MASK,
+				bcm43xx_read16(dev, BCM43xx_MMIO_GPIO_MASK)
 				| 0x0100);
 		mask |= 0x0180;
 		set |= 0x0180;
 	}
-	if (bcm->sprom.boardflags & BCM43xx_BFL_PACTRL) {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-				bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK)
+	if (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_PACTRL) {
+		bcm43xx_write16(dev, BCM43xx_MMIO_GPIO_MASK,
+				bcm43xx_read16(dev, BCM43xx_MMIO_GPIO_MASK)
 				| 0x0200);
 		mask |= 0x0200;
 		set |= 0x0200;
 	}
-	if (bcm->current_core->rev >= 2)
+	if (dev->dev->id.revision >= 2)
 		mask  |= 0x0010; /* FIXME: This is redundant. */
 
-	old_core = bcm->current_core;
-	err = switch_to_gpio_core(bcm);
-	if (err)
-		goto out;
-	bcm43xx_write32(bcm, BCM43xx_GPIO_CONTROL,
-	                (bcm43xx_read32(bcm, BCM43xx_GPIO_CONTROL) & mask) | set);
-	err = bcm43xx_switch_core(bcm, old_core);
-out:
-	return err;
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+	pcidev = bus->pcicore.dev;
+#endif
+	gpiodev = bus->chipco.dev ? : pcidev;
+	if (!gpiodev)
+		return 0;
+	ssb_write32(gpiodev, BCM43xx_GPIO_CONTROL,
+		    (ssb_read32(gpiodev, BCM43xx_GPIO_CONTROL)
+		     & mask) | set);
+
+	return 0;
 }
 
 /* Turn off all GPIO stuff. Call this on module unload, for example. */
-static int bcm43xx_gpio_cleanup(struct bcm43xx_private *bcm)
+static void bcm43xx_gpio_cleanup(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_coreinfo *old_core;
-	int err;
-
-	old_core = bcm->current_core;
-	err = switch_to_gpio_core(bcm);
-	if (err)
-		return err;
-	bcm43xx_write32(bcm, BCM43xx_GPIO_CONTROL, 0x00000000);
-	err = bcm43xx_switch_core(bcm, old_core);
-	assert(err == 0);
+	struct ssb_bus *bus = dev->dev->bus;
+	struct ssb_device *gpiodev, *pcidev = NULL;
 
-	return 0;
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+	pcidev = bus->pcicore.dev;
+#endif
+	gpiodev = bus->chipco.dev ? : pcidev;
+	if (!gpiodev)
+		return;
+	ssb_write32(gpiodev, BCM43xx_GPIO_CONTROL, 0);
 }
 
 /* http://bcm-specs.sipsolutions.net/EnableMac */
-void bcm43xx_mac_enable(struct bcm43xx_private *bcm)
+void bcm43xx_mac_enable(struct bcm43xx_wldev *dev)
 {
-	bcm->mac_suspended--;
-	assert(bcm->mac_suspended >= 0);
-	if (bcm->mac_suspended == 0) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
+	dev->mac_suspended--;
+	BCM43xx_WARN_ON(dev->mac_suspended < 0);
+	if (dev->mac_suspended == 0) {
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+				bcm43xx_read32(dev,
+				BCM43xx_MMIO_STATUS_BITFIELD)
 				| BCM43xx_SBF_MAC_ENABLED);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, BCM43xx_IRQ_READY);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD); /* dummy read */
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-		bcm43xx_power_saving_ctl_bits(bcm, -1, -1);
+		bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_REASON,
+				BCM43xx_IRQ_MAC_SUSPENDED);
+		/* the next two are dummy reads */
+		bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
+		bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
+		bcm43xx_power_saving_ctl_bits(dev, -1, -1);
 	}
 }
 
 /* http://bcm-specs.sipsolutions.net/SuspendMAC */
-void bcm43xx_mac_suspend(struct bcm43xx_private *bcm)
+void bcm43xx_mac_suspend(struct bcm43xx_wldev *dev)
 {
 	int i;
 	u32 tmp;
 
-	assert(bcm->mac_suspended >= 0);
-	if (bcm->mac_suspended == 0) {
-		bcm43xx_power_saving_ctl_bits(bcm, -1, 1);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
+	BCM43xx_WARN_ON(dev->mac_suspended < 0);
+	if (dev->mac_suspended == 0) {
+		bcm43xx_power_saving_ctl_bits(dev, -1, 1);
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+				bcm43xx_read32(dev,
+				BCM43xx_MMIO_STATUS_BITFIELD)
 				& ~BCM43xx_SBF_MAC_ENABLED);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
+		bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
 		for (i = 10000; i; i--) {
-			tmp = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-			if (tmp & BCM43xx_IRQ_READY)
+			tmp = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
+			if (tmp & BCM43xx_IRQ_MAC_SUSPENDED)
 				goto out;
 			udelay(1);
 		}
-		printkl(KERN_ERR PFX "MAC suspend failed\n");
+		bcmerr(dev->wl, "MAC suspend failed\n");
 	}
 out:
-	bcm->mac_suspended++;
+	dev->mac_suspended++;
 }
 
-void bcm43xx_set_iwmode(struct bcm43xx_private *bcm,
-			int iw_mode)
+static void bcm43xx_adjust_opmode(struct bcm43xx_wldev *dev)
 {
-	unsigned long flags;
-	struct net_device *net_dev = bcm->net_dev;
-	u32 status;
-	u16 value;
-
-	spin_lock_irqsave(&bcm->ieee->lock, flags);
-	bcm->ieee->iw_mode = iw_mode;
-	spin_unlock_irqrestore(&bcm->ieee->lock, flags);
-	if (iw_mode == IW_MODE_MONITOR)
-		net_dev->type = ARPHRD_IEEE80211;
-	else
-		net_dev->type = ARPHRD_ETHER;
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	/* Reset status to infrastructured mode */
-	status &= ~(BCM43xx_SBF_MODE_AP | BCM43xx_SBF_MODE_MONITOR);
-	status &= ~BCM43xx_SBF_MODE_PROMISC;
-	status |= BCM43xx_SBF_MODE_NOTADHOC;
-
-/* FIXME: Always enable promisc mode, until we get the MAC filters working correctly. */
-status |= BCM43xx_SBF_MODE_PROMISC;
-
-	switch (iw_mode) {
-	case IW_MODE_MONITOR:
-		status |= BCM43xx_SBF_MODE_MONITOR;
-		status |= BCM43xx_SBF_MODE_PROMISC;
-		break;
-	case IW_MODE_ADHOC:
-		status &= ~BCM43xx_SBF_MODE_NOTADHOC;
-		break;
-	case IW_MODE_MASTER:
-		status |= BCM43xx_SBF_MODE_AP;
-		break;
-	case IW_MODE_SECOND:
-	case IW_MODE_REPEAT:
-		TODO(); /* TODO */
-		break;
-	case IW_MODE_INFRA:
-		/* nothing to be done here... */
-		break;
-	default:
-		dprintk(KERN_ERR PFX "Unknown mode in set_iwmode: %d\n", iw_mode);
+	struct bcm43xx_wl *wl = dev->wl;
+	u32 ctl;
+	u16 cfp_pretbtt;
+
+	ctl = bcm43xx_read32(dev, BCM43xx_MMIO_MACCTL);
+	/* Reset status to STA infrastructure mode. */
+	ctl &= ~BCM43xx_MACCTL_AP;
+	ctl &= ~BCM43xx_MACCTL_KEEP_CTL;
+	ctl &= ~BCM43xx_MACCTL_KEEP_BADPLCP;
+	ctl &= ~BCM43xx_MACCTL_KEEP_BAD;
+	ctl &= ~BCM43xx_MACCTL_PROMISC;
+	ctl |= BCM43xx_MACCTL_INFRA;
+
+	if (wl->operating) {
+		switch (wl->if_type) {
+		case IEEE80211_IF_TYPE_AP:
+			ctl |= BCM43xx_MACCTL_AP;
+			break;
+		case IEEE80211_IF_TYPE_IBSS:
+			ctl &= ~BCM43xx_MACCTL_INFRA;
+			break;
+		case IEEE80211_IF_TYPE_STA:
+		case IEEE80211_IF_TYPE_MNTR:
+		case IEEE80211_IF_TYPE_WDS:
+			break;
+		default:
+			bcmerr(wl, "Improper value of %d for wl->if_type\n",
+			       wl->if_type);
+		}
 	}
-	if (net_dev->flags & IFF_PROMISC)
-		status |= BCM43xx_SBF_MODE_PROMISC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-
-	value = 0x0002;
-	if (iw_mode != IW_MODE_ADHOC && iw_mode != IW_MODE_MASTER) {
-		if (bcm->chip_id == 0x4306 && bcm->chip_rev == 3)
-			value = 0x0064;
+	if (wl->monitor) {
+		ctl |= BCM43xx_MACCTL_KEEP_CTL;
+		if (modparam_mon_keep_bad)
+			ctl |= BCM43xx_MACCTL_KEEP_BAD;
+		if (modparam_mon_keep_badplcp)
+			ctl |= BCM43xx_MACCTL_KEEP_BADPLCP;
+	}
+	if (wl->promisc)
+		ctl |= BCM43xx_MACCTL_PROMISC;
+	/* Workaround: On old hardware the HW-MAC-address-filter
+	 * doesn't work properly, so always run promisc in filter
+	 * it in software. */
+	if (dev->dev->id.revision <= 4)
+		ctl |= BCM43xx_MACCTL_PROMISC;
+
+	bcm43xx_write32(dev, BCM43xx_MMIO_MACCTL, ctl);
+
+	cfp_pretbtt = 2;
+	if ((ctl & BCM43xx_MACCTL_INFRA) &&
+	    !(ctl & BCM43xx_MACCTL_AP)) {
+		if (dev->dev->bus->chip_id == 0x4306 &&
+		    dev->dev->bus->chip_rev == 3)
+			cfp_pretbtt = 100;
 		else
-			value = 0x0032;
+			cfp_pretbtt = 50;
 	}
-	bcm43xx_write16(bcm, 0x0612, value);
+	bcm43xx_write16(dev, 0x612, cfp_pretbtt);
 }
 
-/* This is the opposite of bcm43xx_chip_init() */
-static void bcm43xx_chip_cleanup(struct bcm43xx_private *bcm)
+static void bcm43xx_rate_memory_write(struct bcm43xx_wldev *dev,
+				      u16 rate,
+				      int is_ofdm)
 {
-	bcm43xx_radio_turn_off(bcm);
-	if (!modparam_noleds)
-		bcm43xx_leds_exit(bcm);
-	bcm43xx_gpio_cleanup(bcm);
-	bcm43xx_release_firmware(bcm, 0);
+	u16 offset;
+
+	if (is_ofdm) {
+		offset = 0x480;
+		offset += (bcm43xx_plcp_get_ratecode_ofdm(rate) & 0x000F) * 2;
+	} else {
+		offset = 0x4C0;
+		offset += (bcm43xx_plcp_get_ratecode_cck(rate) & 0x000F) * 2;
+	}
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, offset + 0x20,
+			    bcm43xx_shm_read16(dev,
+			    BCM43xx_SHM_SHARED, offset));
 }
 
-/* Initialize the chip
- * http://bcm-specs.sipsolutions.net/ChipInit
- */
-static int bcm43xx_chip_init(struct bcm43xx_private *bcm)
+static void bcm43xx_rate_memory_init(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	int err;
-	int i, tmp;
-	u32 value32;
-	u16 value16;
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-			BCM43xx_SBF_CORE_READY
-			| BCM43xx_SBF_400);
-
-	err = bcm43xx_request_firmware(bcm);
-	if (err)
-		goto out;
-	bcm43xx_upload_microcode(bcm);
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, 0xFFFFFFFF);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, 0x00020402);
-	i = 0;
-	while (1) {
-		value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-		if (value32 == BCM43xx_IRQ_READY)
-			break;
-		i++;
-		if (i >= BCM43xx_IRQWAIT_MAX_RETRIES) {
-			printk(KERN_ERR PFX "IRQ_READY timeout\n");
-			err = -ENODEV;
-			goto err_release_fw;
-		}
-		udelay(10);
+	switch (dev->phy.type) {
+	case BCM43xx_PHYTYPE_G:
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_6MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_12MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_18MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_24MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_36MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_48MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_54MB, 1);
+		/* fallthrough */
+	case BCM43xx_PHYTYPE_B:
+		bcm43xx_rate_memory_write(dev, BCM43xx_CCK_RATE_1MB, 0);
+		bcm43xx_rate_memory_write(dev, BCM43xx_CCK_RATE_2MB, 0);
+		bcm43xx_rate_memory_write(dev, BCM43xx_CCK_RATE_5MB, 0);
+		bcm43xx_rate_memory_write(dev, BCM43xx_CCK_RATE_11MB, 0);
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
 	}
-	bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
+}
 
-	value16 = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				     BCM43xx_UCODE_REVISION);
+/* Set the TX-Antenna for management frames sent by firmware. */
+static void bcm43xx_mgmtframe_txantenna(struct bcm43xx_wldev *dev,
+					int antenna)
+{
+	u16 ant = 0;
+	u16 tmp;
 
-	dprintk(KERN_INFO PFX "Microcode rev 0x%x, pl 0x%x "
-		"(20%.2i-%.2i-%.2i  %.2i:%.2i:%.2i)\n", value16,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_PATCHLEVEL),
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODE_DATE) >> 12) & 0xf,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODE_DATE) >> 8) & 0xf,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_DATE) & 0xff,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) >> 11) & 0x1f,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) >> 5) & 0x3f,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) & 0x1f);
-
-	if ( value16 > 0x128 ) {
-		printk(KERN_ERR PFX
-			"Firmware: no support for microcode extracted "
-			"from version 4.x binary drivers.\n");
-		err = -EOPNOTSUPP;
-		goto err_release_fw;
+	switch (antenna) {
+	case BCM43xx_ANTENNA0:
+		ant |= BCM43xx_TX4_PHY_ANT0;
+		break;
+	case BCM43xx_ANTENNA1:
+		ant |= BCM43xx_TX4_PHY_ANT1;
+		break;
+	case BCM43xx_ANTENNA_AUTO:
+		ant |= BCM43xx_TX4_PHY_ANTLAST;
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
 	}
 
-	err = bcm43xx_gpio_init(bcm);
+	/* FIXME We also need to set the other flags of the PHY control
+	 * field somewhere. */
+
+	/* For Beacons */
+	tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				 BCM43xx_SHM_SH_BEACPHYCTL);
+	tmp = (tmp & ~BCM43xx_TX4_PHY_ANT) | ant;
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_BEACPHYCTL, tmp);
+	/* For ACK/CTS */
+	tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				 BCM43xx_SHM_SH_ACKCTSPHYCTL);
+	tmp = (tmp & ~BCM43xx_TX4_PHY_ANT) | ant;
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_ACKCTSPHYCTL, tmp);
+	/* For Probe Resposes */
+	tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				 BCM43xx_SHM_SH_PRPHYCTL);
+	tmp = (tmp & ~BCM43xx_TX4_PHY_ANT) | ant;
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_PRPHYCTL, tmp);
+}
+
+/* This is the opposite of bcm43xx_chip_init() */
+static void bcm43xx_chip_exit(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_radio_turn_off(dev);
+	if (!modparam_noleds)
+		bcm43xx_leds_exit(dev);
+	bcm43xx_gpio_cleanup(dev);
+	/* firmware is released later */
+}
+
+/* Initialize the chip
+ * http://bcm-specs.sipsolutions.net/ChipInit
+ */
+static int bcm43xx_chip_init(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+	int err;
+	int tmp;
+	u32 value32;
+	u16 value16;
+
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+			BCM43xx_SBF_CORE_READY
+			| BCM43xx_SBF_400);
+
+	err = bcm43xx_request_firmware(dev);
 	if (err)
-		goto err_release_fw;
+		goto out;
+	err = bcm43xx_upload_microcode(dev);
+	if (err)
+		goto out; /* firmware is released later */
 
-	err = bcm43xx_upload_initvals(bcm);
+	err = bcm43xx_gpio_init(dev);
+	if (err)
+		goto out; /* firmware is released later */
+	err = bcm43xx_upload_initvals(dev);
 	if (err)
 		goto err_gpio_cleanup;
-	bcm43xx_radio_turn_on(bcm);
-	bcm->radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
-	dprintk(KERN_INFO PFX "Radio %s by hardware\n",
-		(bcm->radio_hw_enable == 0) ? "disabled" : "enabled");
+	bcm43xx_radio_turn_on(dev);
+	dev->radio_hw_enable = bcm43xx_is_hw_radio_enabled(dev);
+	bcmdbg(dev->wl, "Radio %s by hardware\n",
+	       (dev->radio_hw_enable == 0) ? "disabled" : "enabled");
 
-	bcm43xx_write16(bcm, 0x03E6, 0x0000);
-	err = bcm43xx_phy_init(bcm);
+	bcm43xx_write16(dev, 0x03E6, 0x0000);
+	err = bcm43xx_phy_init(dev);
 	if (err)
 		goto err_radio_off;
 
 	/* Select initial Interference Mitigation. */
-	tmp = radio->interfmode;
-	radio->interfmode = BCM43xx_RADIO_INTERFMODE_NONE;
-	bcm43xx_radio_set_interference_mitigation(bcm, tmp);
+	tmp = phy->interfmode;
+	phy->interfmode = BCM43xx_INTERFMODE_NONE;
+	bcm43xx_radio_set_interference_mitigation(dev, tmp);
+
+	bcm43xx_phy_set_antenna_diversity(dev);
+	bcm43xx_mgmtframe_txantenna(dev, BCM43xx_ANTENNA_DEFAULT);
 
-	bcm43xx_phy_set_antenna_diversity(bcm);
-	bcm43xx_radio_set_txantenna(bcm, BCM43xx_RADIO_TXANTENNA_DEFAULT);
 	if (phy->type == BCM43xx_PHYTYPE_B) {
-		value16 = bcm43xx_read16(bcm, 0x005E);
+		value16 = bcm43xx_read16(dev, 0x005E);
 		value16 |= 0x0004;
-		bcm43xx_write16(bcm, 0x005E, value16);
+		bcm43xx_write16(dev, 0x005E, value16);
 	}
-	bcm43xx_write32(bcm, 0x0100, 0x01000000);
-	if (bcm->current_core->rev < 5)
-		bcm43xx_write32(bcm, 0x010C, 0x01000000);
+	bcm43xx_write32(dev, 0x0100, 0x01000000);
+	if (dev->dev->id.revision < 5)
+		bcm43xx_write32(dev, 0x010C, 0x01000000);
 
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
+	value32 = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 	value32 &= ~ BCM43xx_SBF_MODE_NOTADHOC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, value32);
+	value32 = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 	value32 |= BCM43xx_SBF_MODE_NOTADHOC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, value32);
 
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
+	value32 = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 	value32 |= 0x100000;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, value32);
 
-	if (bcm43xx_using_pio(bcm)) {
-		bcm43xx_write32(bcm, 0x0210, 0x00000100);
-		bcm43xx_write32(bcm, 0x0230, 0x00000100);
-		bcm43xx_write32(bcm, 0x0250, 0x00000100);
-		bcm43xx_write32(bcm, 0x0270, 0x00000100);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0034, 0x0000);
+	if (bcm43xx_using_pio(dev)) {
+		bcm43xx_write32(dev, 0x0210, 0x00000100);
+		bcm43xx_write32(dev, 0x0230, 0x00000100);
+		bcm43xx_write32(dev, 0x0250, 0x00000100);
+		bcm43xx_write32(dev, 0x0270, 0x00000100);
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0034, 0x0000);
 	}
 
 	/* Probe Response Timeout value */
 	/* FIXME: Default to 0, has to be set by ioctl probably... :-/ */
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0074, 0x0000);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0074, 0x0000);
 
 	/* Initially set the wireless operation mode. */
-	bcm43xx_set_iwmode(bcm, bcm->ieee->iw_mode);
+	bcm43xx_adjust_opmode(dev);
 
-	if (bcm->current_core->rev < 3) {
-		bcm43xx_write16(bcm, 0x060E, 0x0000);
-		bcm43xx_write16(bcm, 0x0610, 0x8000);
-		bcm43xx_write16(bcm, 0x0604, 0x0000);
-		bcm43xx_write16(bcm, 0x0606, 0x0200);
+	if (dev->dev->id.revision < 3) {
+		bcm43xx_write16(dev, 0x060E, 0x0000);
+		bcm43xx_write16(dev, 0x0610, 0x8000);
+		bcm43xx_write16(dev, 0x0604, 0x0000);
+		bcm43xx_write16(dev, 0x0606, 0x0200);
 	} else {
-		bcm43xx_write32(bcm, 0x0188, 0x80000000);
-		bcm43xx_write32(bcm, 0x018C, 0x02000000);
+		bcm43xx_write32(dev, 0x0188, 0x80000000);
+		bcm43xx_write32(dev, 0x018C, 0x02000000);
 	}
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, 0x00004000);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA0_IRQ_MASK, 0x0001DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA1_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA2_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA3_IRQ_MASK, 0x0001DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA4_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA5_IRQ_MASK, 0x0000DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_REASON, 0x00004000);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA0_IRQ_MASK, 0x0001DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA1_IRQ_MASK, 0x0000DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA2_IRQ_MASK, 0x0000DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA3_IRQ_MASK, 0x0001DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA4_IRQ_MASK, 0x0000DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA5_IRQ_MASK, 0x0000DC00);
 
-	value32 = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
+	value32 = ssb_read32(dev->dev, SSB_TMSLOW);
 	value32 |= 0x00100000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, value32);
+	ssb_write32(dev->dev, SSB_TMSLOW, value32);
 
-	bcm43xx_write16(bcm, BCM43xx_MMIO_POWERUP_DELAY, bcm43xx_pctl_powerup_delay(bcm));
+	bcm43xx_write16(dev, BCM43xx_MMIO_POWERUP_DELAY,
+			dev->dev->bus->chipco.fast_pwrup_delay);
 
-	assert(err == 0);
-	dprintk(KERN_INFO PFX "Chip initialized\n");
+	BCM43xx_WARN_ON(err != 0);
+	bcmdbg(dev->wl, "Chip initialized\n");
 out:
 	return err;
 
 err_radio_off:
-	bcm43xx_radio_turn_off(bcm);
+	bcm43xx_radio_turn_off(dev);
 err_gpio_cleanup:
-	bcm43xx_gpio_cleanup(bcm);
-err_release_fw:
-	bcm43xx_release_firmware(bcm, 1);
+	bcm43xx_gpio_cleanup(dev);
 	goto out;
 }
-	
-/* Validate chip access
- * http://bcm-specs.sipsolutions.net/ValidateChipAccess */
-static int bcm43xx_validate_chip(struct bcm43xx_private *bcm)
-{
-	u32 value;
-	u32 shm_backup;
-
-	shm_backup = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, 0xAA5555AA);
-	if (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000) != 0xAA5555AA)
-		goto error;
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, 0x55AAAA55);
-	if (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000) != 0x55AAAA55)
-		goto error;
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, shm_backup);
 
-	value = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	if ((value | 0x80000000) != 0x80000400)
-		goto error;
+static void bcm43xx_periodic_every120sec(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
 
-	value = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-	if (value != 0x00000000)
-		goto error;
+	if (phy->type != BCM43xx_PHYTYPE_G || phy->rev < 2)
+		return;
 
-	return 0;
-error:
-	printk(KERN_ERR PFX "Failed to validate the chipaccess\n");
-	return -ENODEV;
+	bcm43xx_mac_suspend(dev);
+	bcm43xx_phy_lo_g_measure(dev);
+	bcm43xx_mac_enable(dev);
 }
 
-static void bcm43xx_init_struct_phyinfo(struct bcm43xx_phyinfo *phy)
+static void bcm43xx_periodic_every60sec(struct bcm43xx_wldev *dev)
 {
-	/* Initialize a "phyinfo" structure. The structure is already
-	 * zeroed out.
-	 * This is called on insmod time to initialize members.
-	 */
-	phy->savedpctlreg = 0xFFFF;
-	spin_lock_init(&phy->lock);
+	bcm43xx_phy_lo_mark_all_unused(dev);
+	if (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_RSSI) {
+		bcm43xx_mac_suspend(dev);
+		bcm43xx_calc_nrssi_slope(dev);
+		bcm43xx_mac_enable(dev);
+	}
 }
 
-static void bcm43xx_init_struct_radioinfo(struct bcm43xx_radioinfo *radio)
+static void bcm43xx_periodic_every30sec(struct bcm43xx_wldev *dev)
 {
-	/* Initialize a "radioinfo" structure. The structure is already
-	 * zeroed out.
-	 * This is called on insmod time to initialize members.
-	 */
-	radio->interfmode = BCM43xx_RADIO_INTERFMODE_NONE;
-	radio->channel = 0xFF;
-	radio->initial_channel = 0xFF;
-}
-
-static int bcm43xx_probe_cores(struct bcm43xx_private *bcm)
-{
-	int err, i;
-	int current_core;
-	u32 core_vendor, core_id, core_rev;
-	u32 sb_id_hi, chip_id_32 = 0;
-	u16 pci_device, chip_id_16;
-	u8 core_count;
-
-	memset(&bcm->core_chipcommon, 0, sizeof(struct bcm43xx_coreinfo));
-	memset(&bcm->core_pci, 0, sizeof(struct bcm43xx_coreinfo));
-	memset(&bcm->core_80211, 0, sizeof(struct bcm43xx_coreinfo)
-				    * BCM43xx_MAX_80211_CORES);
-	memset(&bcm->core_80211_ext, 0, sizeof(struct bcm43xx_coreinfo_80211)
-					* BCM43xx_MAX_80211_CORES);
-	bcm->nr_80211_available = 0;
-	bcm->current_core = NULL;
-	bcm->active_80211_core = NULL;
-
-	/* map core 0 */
-	err = _switch_core(bcm, 0);
-	if (err)
-		goto out;
-
-	/* fetch sb_id_hi from core information registers */
-	sb_id_hi = bcm43xx_read32(bcm, BCM43xx_CIR_SB_ID_HI);
-
-	core_id = (sb_id_hi & 0x8FF0) >> 4;
-	core_rev = (sb_id_hi & 0x7000) >> 8;
-	core_rev |= (sb_id_hi & 0xF);
-	core_vendor = (sb_id_hi & 0xFFFF0000) >> 16;
-
-	/* if present, chipcommon is always core 0; read the chipid from it */
-	if (core_id == BCM43xx_COREID_CHIPCOMMON) {
-		chip_id_32 = bcm43xx_read32(bcm, 0);
-		chip_id_16 = chip_id_32 & 0xFFFF;
-		bcm->core_chipcommon.available = 1;
-		bcm->core_chipcommon.id = core_id;
-		bcm->core_chipcommon.rev = core_rev;
-		bcm->core_chipcommon.index = 0;
-		/* While we are at it, also read the capabilities. */
-		bcm->chipcommon_capabilities = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_CAPABILITIES);
-	} else {
-		/* without a chipCommon, use a hard coded table. */
-		pci_device = bcm->pci_dev->device;
-		if (pci_device == 0x4301)
-			chip_id_16 = 0x4301;
-		else if ((pci_device >= 0x4305) && (pci_device <= 0x4307))
-			chip_id_16 = 0x4307;
-		else if ((pci_device >= 0x4402) && (pci_device <= 0x4403))
-			chip_id_16 = 0x4402;
-		else if ((pci_device >= 0x4610) && (pci_device <= 0x4615))
-			chip_id_16 = 0x4610;
-		else if ((pci_device >= 0x4710) && (pci_device <= 0x4715))
-			chip_id_16 = 0x4710;
-		else {
-			printk(KERN_ERR PFX "Could not determine Chip ID\n");
-			return -ENODEV;
-		}
-	}
-
-	/* ChipCommon with Core Rev >=4 encodes number of cores,
-	 * otherwise consult hardcoded table */
-	if ((core_id == BCM43xx_COREID_CHIPCOMMON) && (core_rev >= 4)) {
-		core_count = (chip_id_32 & 0x0F000000) >> 24;
-	} else {
-		switch (chip_id_16) {
-			case 0x4610:
-			case 0x4704:
-			case 0x4710:
-				core_count = 9;
-				break;
-			case 0x4310:
-				core_count = 8;
-				break;
-			case 0x5365:
-				core_count = 7;
-				break;
-			case 0x4306:
-				core_count = 6;
-				break;
-			case 0x4301:
-			case 0x4307:
-				core_count = 5;
-				break;
-			case 0x4402:
-				core_count = 3;
-				break;
-			default:
-				/* SOL if we get here */
-				assert(0);
-				core_count = 1;
-		}
-	}
-
-	bcm->chip_id = chip_id_16;
-	bcm->chip_rev = (chip_id_32 & 0x000F0000) >> 16;
-	bcm->chip_package = (chip_id_32 & 0x00F00000) >> 20;
-
-	dprintk(KERN_INFO PFX "Chip ID 0x%x, rev 0x%x\n",
-		bcm->chip_id, bcm->chip_rev);
-	dprintk(KERN_INFO PFX "Number of cores: %d\n", core_count);
-	if (bcm->core_chipcommon.available) {
-		dprintk(KERN_INFO PFX "Core 0: ID 0x%x, rev 0x%x, vendor 0x%x\n",
-			core_id, core_rev, core_vendor);
-		current_core = 1;
-	} else
-		current_core = 0;
-	for ( ; current_core < core_count; current_core++) {
-		struct bcm43xx_coreinfo *core;
-		struct bcm43xx_coreinfo_80211 *ext_80211;
-
-		err = _switch_core(bcm, current_core);
-		if (err)
-			goto out;
-		/* Gather information */
-		/* fetch sb_id_hi from core information registers */
-		sb_id_hi = bcm43xx_read32(bcm, BCM43xx_CIR_SB_ID_HI);
-
-		/* extract core_id, core_rev, core_vendor */
-		core_id = (sb_id_hi & 0x8FF0) >> 4;
-		core_rev = ((sb_id_hi & 0xF) | ((sb_id_hi & 0x7000) >> 8));
-		core_vendor = (sb_id_hi & 0xFFFF0000) >> 16;
-
-		dprintk(KERN_INFO PFX "Core %d: ID 0x%x, rev 0x%x, vendor 0x%x\n",
-			current_core, core_id, core_rev, core_vendor);
-
-		core = NULL;
-		switch (core_id) {
-		case BCM43xx_COREID_PCI:
-		case BCM43xx_COREID_PCIE:
-			core = &bcm->core_pci;
-			if (core->available) {
-				printk(KERN_WARNING PFX "Multiple PCI cores found.\n");
-				continue;
-			}
-			break;
-		case BCM43xx_COREID_80211:
-			for (i = 0; i < BCM43xx_MAX_80211_CORES; i++) {
-				core = &(bcm->core_80211[i]);
-				ext_80211 = &(bcm->core_80211_ext[i]);
-				if (!core->available)
-					break;
-				core = NULL;
-			}
-			if (!core) {
-				printk(KERN_WARNING PFX "More than %d cores of type 802.11 found.\n",
-				       BCM43xx_MAX_80211_CORES);
-				continue;
-			}
-			if (i != 0) {
-				/* More than one 80211 core is only supported
-				 * by special chips.
-				 * There are chips with two 80211 cores, but with
-				 * dangling pins on the second core. Be careful
-				 * and ignore these cores here.
-				 */
-				if (1 /*bcm->pci_dev->device != 0x4324*/ ) {
-				/* TODO: A PHY */
-					dprintk(KERN_INFO PFX "Ignoring additional 802.11a core.\n");
-					continue;
-				}
-			}
-			switch (core_rev) {
-			case 2:
-			case 4:
-			case 5:
-			case 6:
-			case 7:
-			case 9:
-			case 10:
-				break;
-			default:
-				printk(KERN_WARNING PFX
-				       "Unsupported 80211 core revision %u\n",
-				       core_rev);
-			}
-			bcm->nr_80211_available++;
-			core->priv = ext_80211;
-			bcm43xx_init_struct_phyinfo(&ext_80211->phy);
-			bcm43xx_init_struct_radioinfo(&ext_80211->radio);
-			break;
-		case BCM43xx_COREID_CHIPCOMMON:
-			printk(KERN_WARNING PFX "Multiple CHIPCOMMON cores found.\n");
-			break;
-		}
-		if (core) {
-			core->available = 1;
-			core->id = core_id;
-			core->rev = core_rev;
-			core->index = current_core;
-		}
-	}
-
-	if (!bcm->core_80211[0].available) {
-		printk(KERN_ERR PFX "Error: No 80211 core found!\n");
-		err = -ENODEV;
-		goto out;
-	}
-
-	err = bcm43xx_switch_core(bcm, &bcm->core_80211[0]);
-
-	assert(err == 0);
-out:
-	return err;
+	/* Update device statistics. */
+	bcm43xx_calculate_link_quality(dev);
 }
 
-static void bcm43xx_gen_bssid(struct bcm43xx_private *bcm)
+static void bcm43xx_periodic_every15sec(struct bcm43xx_wldev *dev)
 {
-	const u8 *mac = (const u8*)(bcm->net_dev->dev_addr);
-	u8 *bssid = bcm->ieee->bssid;
-
-	switch (bcm->ieee->iw_mode) {
-	case IW_MODE_ADHOC:
-		random_ether_addr(bssid);
-		break;
-	case IW_MODE_MASTER:
-	case IW_MODE_INFRA:
-	case IW_MODE_REPEAT:
-	case IW_MODE_SECOND:
-	case IW_MODE_MONITOR:
-		memcpy(bssid, mac, ETH_ALEN);
-		break;
-	default:
-		assert(0);
-	}
+	bcm43xx_phy_xmitpower(dev); /* FIXME: unless scanning? */
 }
 
-static void bcm43xx_rate_memory_write(struct bcm43xx_private *bcm,
-				      u16 rate,
-				      int is_ofdm)
+static void bcm43xx_periodic_every1sec(struct bcm43xx_wldev *dev)
 {
-	u16 offset;
+	int radio_hw_enable;
 
-	if (is_ofdm) {
-		offset = 0x480;
-		offset += (bcm43xx_plcp_get_ratecode_ofdm(rate) & 0x000F) * 2;
-	}
-	else {
-		offset = 0x4C0;
-		offset += (bcm43xx_plcp_get_ratecode_cck(rate) & 0x000F) * 2;
+	/* check if radio hardware enabled status changed */
+	radio_hw_enable = bcm43xx_is_hw_radio_enabled(dev);
+	if (unlikely(dev->radio_hw_enable != radio_hw_enable)) {
+		dev->radio_hw_enable = radio_hw_enable;
+		bcmdbg(dev->wl, "Radio hardware status changed to %s\n",
+		       (radio_hw_enable == 0) ? "disabled" : "enabled");
+		bcm43xx_leds_update(dev, 0);
 	}
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, offset + 0x20,
-			    bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, offset));
 }
 
-static void bcm43xx_rate_memory_init(struct bcm43xx_private *bcm)
+static void do_periodic_work(struct bcm43xx_wldev *dev)
 {
-	switch (bcm43xx_current_phy(bcm)->type) {
-	case BCM43xx_PHYTYPE_A:
-	case BCM43xx_PHYTYPE_G:
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_6MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_12MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_18MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_24MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_36MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_48MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_54MB, 1);
-	case BCM43xx_PHYTYPE_B:
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_1MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_2MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_5MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_11MB, 0);
-		break;
-	default:
-		assert(0);
-	}
+	unsigned int state;
+
+	state = dev->periodic_state;
+	if (state % 120 == 0)
+		bcm43xx_periodic_every120sec(dev);
+	if (state % 60 == 0)
+		bcm43xx_periodic_every60sec(dev);
+	if (state % 30 == 0)
+		bcm43xx_periodic_every30sec(dev);
+	if (state % 15 == 0)
+		bcm43xx_periodic_every15sec(dev);
+	bcm43xx_periodic_every1sec(dev);
 }
 
-static void bcm43xx_wireless_core_cleanup(struct bcm43xx_private *bcm)
+/* Estimate a "Badness" value based on the periodic work
+ * state-machine state. "Badness" is worse (bigger), if the
+ * periodic work will take longer.
+ */
+static int estimate_periodic_work_badness(unsigned int state)
 {
-	bcm43xx_chip_cleanup(bcm);
-	bcm43xx_pio_free(bcm);
-	bcm43xx_dma_free(bcm);
+	int badness = 0;
+
+	if (state % 120 == 0) /* every 120 sec */
+		badness += 10;
+	if (state % 60 == 0) /* every 60 sec */
+		badness += 5;
+	if (state % 30 == 0) /* every 30 sec */
+		badness += 1;
+	if (state % 15 == 0) /* every 15 sec */
+		badness += 1;
 
-	bcm->current_core->initialized = 0;
+#define BADNESS_LIMIT	4
+	return badness;
 }
 
-/* http://bcm-specs.sipsolutions.net/80211Init */
-static int bcm43xx_wireless_core_init(struct bcm43xx_private *bcm,
-				      int active_wlcore)
+static void bcm43xx_periodic_work_handler(struct work_struct *work)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u32 ucodeflags;
-	int err;
-	u32 sbimconfiglow;
-	u8 limit;
+	struct bcm43xx_wldev *dev =
+		container_of(work, struct bcm43xx_wldev, periodic_work.work);
+	unsigned long flags;
+	unsigned long delay;
+	u32 savedirqs = 0;
+	int badness;
 
-	if (bcm->core_pci.rev <= 5 && bcm->core_pci.id != BCM43xx_COREID_PCIE) {
-		sbimconfiglow = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMCONFIGLOW);
-		sbimconfiglow &= ~ BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_MASK;
-		sbimconfiglow &= ~ BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_MASK;
-		if (bcm->bustype == BCM43xx_BUSTYPE_PCI)
-			sbimconfiglow |= 0x32;
-		else
-			sbimconfiglow |= 0x53;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBIMCONFIGLOW, sbimconfiglow);
-	}
+	mutex_lock(&dev->wl->mutex);
 
-	bcm43xx_phy_calibrate(bcm);
-	err = bcm43xx_chip_init(bcm);
-	if (err)
+	if (unlikely(bcm43xx_status(dev) != BCM43xx_STAT_STARTED))
 		goto out;
+	if (bcm43xx_debug(dev, BCM43xx_DBG_PWORK_STOP))
+		goto out_requeue;
 
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0016, bcm->current_core->rev);
-	ucodeflags = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, BCM43xx_UCODEFLAGS_OFFSET);
-
-	if (0 /*FIXME: which condition has to be used here? */)
-		ucodeflags |= 0x00000010;
+	badness = estimate_periodic_work_badness(dev->periodic_state);
+	if (badness > BADNESS_LIMIT) {
+		spin_lock_irqsave(&dev->wl->irq_lock, flags);
+		/* Suspend TX as we don't want to transmit packets while
+		 * we recalibrate the hardware. */
+		bcm43xx_tx_suspend(dev);
+		savedirqs = bcm43xx_interrupt_disable(dev, BCM43xx_IRQ_ALL);
+		/* Periodic work will take a long time, so we want it to
+		 * be preemtible and release the spinlock. */
+		spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+		bcm43xx_synchronize_irq(dev);
+
+		do_periodic_work(dev);
+
+		spin_lock_irqsave(&dev->wl->irq_lock, flags);
+		bcm43xx_interrupt_enable(dev, savedirqs);
+		bcm43xx_tx_resume(dev);
+		mmiowb();
+		spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	} else {
+		/* Take the global driver lock. This will lock any operation. */
+		spin_lock_irqsave(&dev->wl->irq_lock, flags);
 
-	/* HW decryption needs to be set now */
-	ucodeflags |= 0x40000000;
-	
-	if (phy->type == BCM43xx_PHYTYPE_G) {
-		ucodeflags |= BCM43xx_UCODEFLAG_UNKBGPHY;
-		if (phy->rev == 1)
-			ucodeflags |= BCM43xx_UCODEFLAG_UNKGPHY;
-		if (bcm->sprom.boardflags & BCM43xx_BFL_PACTRL)
-			ucodeflags |= BCM43xx_UCODEFLAG_UNKPACTRL;
-	} else if (phy->type == BCM43xx_PHYTYPE_B) {
-		ucodeflags |= BCM43xx_UCODEFLAG_UNKBGPHY;
-		if (phy->rev >= 2 && radio->version == 0x2050)
-			ucodeflags &= ~BCM43xx_UCODEFLAG_UNKGPHY;
-	}
+		do_periodic_work(dev);
 
-	if (ucodeflags != bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-					     BCM43xx_UCODEFLAGS_OFFSET)) {
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODEFLAGS_OFFSET, ucodeflags);
+		mmiowb();
+		spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
 	}
-
-	/* Short/Long Retry Limit.
-	 * The retry-limit is a 4-bit counter. Enforce this to avoid overflowing
-	 * the chip-internal counter.
-	 */
-	limit = limit_value(modparam_short_retry, 0, 0xF);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0006, limit);
-	limit = limit_value(modparam_long_retry, 0, 0xF);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0007, limit);
-
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0044, 3);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0046, 2);
-
-	bcm43xx_rate_memory_init(bcm);
-
-	/* Minimum Contention Window */
-	if (phy->type == BCM43xx_PHYTYPE_B)
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0003, 0x0000001f);
+	dev->periodic_state++;
+out_requeue:
+	if (bcm43xx_debug(dev, BCM43xx_DBG_PWORK_FAST))
+		delay = msecs_to_jiffies(50);
 	else
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0003, 0x0000000f);
-	/* Maximum Contention Window */
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0004, 0x000003ff);
-
-	bcm43xx_gen_bssid(bcm);
-	bcm43xx_write_mac_bssid_templates(bcm);
-
-	if (bcm->current_core->rev >= 5)
-		bcm43xx_write16(bcm, 0x043C, 0x000C);
-
-	if (active_wlcore) {
-		if (bcm43xx_using_pio(bcm)) {
-			err = bcm43xx_pio_init(bcm);
-		} else {
-			err = bcm43xx_dma_init(bcm);
-			if (err == -ENOSYS)
-				err = bcm43xx_pio_init(bcm);
-		}
-		if (err)
-			goto err_chip_cleanup;
-	}
-	bcm43xx_write16(bcm, 0x0612, 0x0050);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0416, 0x0050);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0414, 0x01F4);
-
-	if (active_wlcore) {
-		if (radio->initial_channel != 0xFF)
-			bcm43xx_radio_selectchannel(bcm, radio->initial_channel, 0);
-	}
-
-	/* Don't enable MAC/IRQ here, as it will race with the IRQ handler.
-	 * We enable it later.
-	 */
-	bcm->current_core->initialized = 1;
+		delay = round_jiffies(HZ);
+	queue_delayed_work(dev->wl->hw->workqueue,
+			   &dev->periodic_work, delay);
 out:
-	return err;
-
-err_chip_cleanup:
-	bcm43xx_chip_cleanup(bcm);
-	goto out;
+	mutex_unlock(&dev->wl->mutex);
 }
 
-static int bcm43xx_chipset_attach(struct bcm43xx_private *bcm)
+static void bcm43xx_periodic_tasks_delete(struct bcm43xx_wldev *dev)
 {
-	int err;
-	u16 pci_status;
-
-	err = bcm43xx_pctl_set_crystal(bcm, 1);
-	if (err)
-		goto out;
-	err = bcm43xx_pci_read_config16(bcm, PCI_STATUS, &pci_status);
-	if (err)
-		goto out;
-	err = bcm43xx_pci_write_config16(bcm, PCI_STATUS, pci_status & ~PCI_STATUS_SIG_TARGET_ABORT);
-
-out:
-	return err;
+	cancel_rearming_delayed_work(&dev->periodic_work);
 }
 
-static void bcm43xx_chipset_detach(struct bcm43xx_private *bcm)
+static void bcm43xx_periodic_tasks_setup(struct bcm43xx_wldev *dev)
 {
-	bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_SLOW);
-	bcm43xx_pctl_set_crystal(bcm, 0);
-}
+	struct delayed_work *work = &dev->periodic_work;
 
-static void bcm43xx_pcicore_broadcast_value(struct bcm43xx_private *bcm,
-					    u32 address,
-					    u32 data)
-{
-	bcm43xx_write32(bcm, BCM43xx_PCICORE_BCAST_ADDR, address);
-	bcm43xx_write32(bcm, BCM43xx_PCICORE_BCAST_DATA, data);
+	dev->periodic_state = 0;
+	INIT_DELAYED_WORK(work, bcm43xx_periodic_work_handler);
+	queue_delayed_work(dev->wl->hw->workqueue, work, 0);
 }
 
-static int bcm43xx_pcicore_commit_settings(struct bcm43xx_private *bcm)
+/* Validate access to the chip (SHM) */
+static int bcm43xx_validate_chipaccess(struct bcm43xx_wldev *dev)
 {
-	int err = 0;
-
-	bcm->irq_savedstate = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
+	u32 value;
+	u32 shm_backup;
 
-	if (bcm->core_chipcommon.available) {
-		err = bcm43xx_switch_core(bcm, &bcm->core_chipcommon);
-		if (err)
-			goto out;
+	shm_backup = bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED, 0);
+	bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED, 0, 0xAA5555AA);
+	if (bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED, 0) != 0xAA5555AA)
+		goto error;
+	bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED, 0, 0x55AAAA55);
+	if (bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED, 0) != 0x55AAAA55)
+		goto error;
+	bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED, 0, shm_backup);
 
-		bcm43xx_pcicore_broadcast_value(bcm, 0xfd8, 0x00000000);
+	value = bcm43xx_read32(dev, BCM43xx_MMIO_MACCTL);
+	if ((value | BCM43xx_MACCTL_GMODE) !=
+	    (BCM43xx_MACCTL_GMODE | BCM43xx_MACCTL_IHR_ENABLED))
+		goto error;
 
-		/* this function is always called when a PCI core is mapped */
-		err = bcm43xx_switch_core(bcm, &bcm->core_pci);
-		if (err)
-			goto out;
-	} else
-		bcm43xx_pcicore_broadcast_value(bcm, 0xfd8, 0x00000000);
+	value = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
+	if (value)
+		goto error;
 
-	bcm43xx_interrupt_enable(bcm, bcm->irq_savedstate);
+	return 0;
+error:
+	bcmerr(dev->wl, "Failed to validate the chipaccess\n");
+	return -ENODEV;
+}
 
-out:
-	return err;
+static void bcm43xx_security_init(struct bcm43xx_wldev *dev)
+{
+	dev->max_nr_keys = (dev->dev->id.revision >= 5) ? 58 : 20;
+	BCM43xx_WARN_ON(dev->max_nr_keys > ARRAY_SIZE(dev->key));
+	dev->ktp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				      0x0056);
+	/* KTP is a word address, but we address SHM bytewise.
+	 * So multiply by two.
+	 */
+	dev->ktp *= 2;
+	if (dev->dev->id.revision >= 5)
+		/* Number of RCMTA address slots */
+		bcm43xx_write16(dev, BCM43xx_MMIO_RCMTA_COUNT,
+				dev->max_nr_keys - 8);
+	bcm43xx_clear_keys(dev);
 }
 
-static u32 bcm43xx_pcie_reg_read(struct bcm43xx_private *bcm, u32 address)
+static int bcm43xx_rng_read(struct hwrng *rng, u32 *data)
 {
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_ADDR, address);
-	return bcm43xx_read32(bcm, BCM43xx_PCIECORE_REG_DATA);
+	struct bcm43xx_wl *wl = (struct bcm43xx_wl *)rng->priv;
+	unsigned long flags;
+
+	/* Don't take wl->mutex here, as it could deadlock with
+	 * hwrng internal locking. It's not needed to take
+	 * wl->mutex here, anyway. */
+
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	*data = bcm43xx_read16(wl->current_dev, BCM43xx_MMIO_RNG);
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+
+	return (sizeof(u16));
 }
 
-static void bcm43xx_pcie_reg_write(struct bcm43xx_private *bcm, u32 address,
-				    u32 data)
+static void bcm43xx_rng_exit(struct bcm43xx_wl *wl)
 {
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_ADDR, address);
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_DATA, data);
+	if (wl->rng_initialized)
+		hwrng_unregister(&wl->rng);
 }
 
-static void bcm43xx_pcie_mdio_write(struct bcm43xx_private *bcm, u8 dev, u8 reg,
-				    u16 data)
+static int bcm43xx_rng_init(struct bcm43xx_wl *wl)
 {
-	int i;
+	int err;
 
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_CTL, 0x0082);
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_DATA, BCM43xx_PCIE_MDIO_ST |
-			BCM43xx_PCIE_MDIO_WT | (dev << BCM43xx_PCIE_MDIO_DEV) |
-			(reg << BCM43xx_PCIE_MDIO_REG) | BCM43xx_PCIE_MDIO_TA |
-			data);
-	udelay(10);
-
-	for (i = 0; i < 10; i++) {
-		if (bcm43xx_read32(bcm, BCM43xx_PCIECORE_MDIO_CTL) &
-		    BCM43xx_PCIE_MDIO_TC)
-			break;
-		msleep(1);
+	snprintf(wl->rng_name, ARRAY_SIZE(wl->rng_name),
+		 "%s_%s", KBUILD_MODNAME, wiphy_name(wl->hw->wiphy));
+	wl->rng.name = wl->rng_name;
+	wl->rng.data_read = bcm43xx_rng_read;
+	wl->rng.priv = (unsigned long)wl;
+	wl->rng_initialized = 1;
+	err = hwrng_register(&wl->rng);
+	if (err) {
+		wl->rng_initialized = 0;
+		bcmerr(wl, "Failed to register the random "
+		       "number generator (%d)\n", err);
 	}
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_CTL, 0);
+
+	return err;
 }
 
-/* Make an I/O Core usable. "core_mask" is the bitmask of the cores to enable.
- * To enable core 0, pass a core_mask of 1<<0
- */
-static int bcm43xx_setup_backplane_pci_connection(struct bcm43xx_private *bcm,
-						  u32 core_mask)
+static int bcm43xx_tx(struct ieee80211_hw *hw,
+		      struct sk_buff *skb,
+		      struct ieee80211_tx_control *ctl)
 {
-	u32 backplane_flag_nr;
-	u32 value;
-	struct bcm43xx_coreinfo *old_core;
-	int err = 0;
-
-	value = bcm43xx_read32(bcm, BCM43xx_CIR_SBTPSFLAG);
-	backplane_flag_nr = value & BCM43xx_BACKPLANE_FLAG_NR_MASK;
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl->current_dev;
+	int err = -ENODEV;
+	unsigned long flags;
 
-	old_core = bcm->current_core;
-	err = bcm43xx_switch_core(bcm, &bcm->core_pci);
-	if (err)
+	if (unlikely(!dev))
 		goto out;
-
-	if (bcm->current_core->rev < 6 &&
-		bcm->current_core->id == BCM43xx_COREID_PCI) {
-		value = bcm43xx_read32(bcm, BCM43xx_CIR_SBINTVEC);
-		value |= (1 << backplane_flag_nr);
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBINTVEC, value);
+	if (unlikely(bcm43xx_status(dev) < BCM43xx_STAT_STARTED))
+		goto out;
+	/* DMA-TX is done without a global lock. */
+	if (bcm43xx_using_pio(dev)) {
+		spin_lock_irqsave(&wl->irq_lock, flags);
+		err = bcm43xx_pio_tx(dev, skb, ctl);
+		spin_unlock_irqrestore(&wl->irq_lock, flags);
 	} else {
-		err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_ICR, &value);
-		if (err) {
-			printk(KERN_ERR PFX "Error: ICR setup failure!\n");
-			goto out_switch_back;
-		}
-		value |= core_mask << 8;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_ICR, value);
-		if (err) {
-			printk(KERN_ERR PFX "Error: ICR setup failure!\n");
-			goto out_switch_back;
-		}
+		err = bcm43xx_dma_tx(dev, skb, ctl);
 	}
+out:
+	if (unlikely(err))
+		return NETDEV_TX_BUSY;
+	return NETDEV_TX_OK;
+}
 
-	if (bcm->current_core->id == BCM43xx_COREID_PCI) {
-		value = bcm43xx_read32(bcm, BCM43xx_PCICORE_SBTOPCI2);
-		value |= BCM43xx_SBTOPCI2_PREFETCH | BCM43xx_SBTOPCI2_BURST;
-		bcm43xx_write32(bcm, BCM43xx_PCICORE_SBTOPCI2, value);
-
-		if (bcm->current_core->rev < 5) {
-			value = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMCONFIGLOW);
-			value |= (2 << BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_SHIFT)
-				 & BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_MASK;
-			value |= (3 << BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_SHIFT)
-				 & BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_MASK;
-			bcm43xx_write32(bcm, BCM43xx_CIR_SBIMCONFIGLOW, value);
-			err = bcm43xx_pcicore_commit_settings(bcm);
-			assert(err == 0);
-		} else if (bcm->current_core->rev >= 11) {
-			value = bcm43xx_read32(bcm, BCM43xx_PCICORE_SBTOPCI2);
-			value |= BCM43xx_SBTOPCI2_MEMREAD_MULTI;
-			bcm43xx_write32(bcm, BCM43xx_PCICORE_SBTOPCI2, value);
-		}
-	} else {
-		if (bcm->current_core->rev == 0 || bcm->current_core->rev == 1) {
-			value = bcm43xx_pcie_reg_read(bcm, BCM43xx_PCIE_TLP_WORKAROUND);
-			value |= 0x8;
-			bcm43xx_pcie_reg_write(bcm, BCM43xx_PCIE_TLP_WORKAROUND,
-					       value);
-		}
-		if (bcm->current_core->rev == 0) {
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_RXTIMER, 0x8128);
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_CDR, 0x0100);
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_CDR_BW, 0x1466);
-		} else if (bcm->current_core->rev == 1) {
-			value = bcm43xx_pcie_reg_read(bcm, BCM43xx_PCIE_DLLP_LINKCTL);
-			value |= 0x40;
-			bcm43xx_pcie_reg_write(bcm, BCM43xx_PCIE_DLLP_LINKCTL,
-					       value);
-		}
+static int bcm43xx_conf_tx(struct ieee80211_hw *hw,
+			   int queue,
+			   const struct ieee80211_tx_queue_params *params)
+{
+	return 0;
+}
+
+static int bcm43xx_get_tx_stats(struct ieee80211_hw *hw,
+				struct ieee80211_tx_queue_stats *stats)
+{
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl->current_dev;
+	unsigned long flags;
+	int err = -ENODEV;
+
+	if (!dev)
+		goto out;
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	if (likely(bcm43xx_status(dev) >= BCM43xx_STAT_STARTED)) {
+		if (bcm43xx_using_pio(dev))
+			bcm43xx_pio_get_tx_stats(dev, stats);
+		else
+			bcm43xx_dma_get_tx_stats(dev, stats);
+		err = 0;
 	}
-out_switch_back:
-	err = bcm43xx_switch_core(bcm, old_core);
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
 out:
 	return err;
 }
 
-static void bcm43xx_periodic_every120sec(struct bcm43xx_private *bcm)
+static int bcm43xx_get_stats(struct ieee80211_hw *hw,
+			     struct ieee80211_low_level_stats *stats)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	unsigned long flags;
 
-	if (phy->type != BCM43xx_PHYTYPE_G || phy->rev < 2)
-		return;
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	memcpy(stats, &wl->ieee_stats, sizeof(*stats));
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
 
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_phy_lo_g_measure(bcm);
-	bcm43xx_mac_enable(bcm);
+	return 0;
 }
 
-static void bcm43xx_periodic_every60sec(struct bcm43xx_private *bcm)
+static int bcm43xx_dev_reset(struct ieee80211_hw *hw)
 {
-	bcm43xx_phy_lo_mark_all_unused(bcm);
-	if (bcm->sprom.boardflags & BCM43xx_BFL_RSSI) {
-		bcm43xx_mac_suspend(bcm);
-		bcm43xx_calc_nrssi_slope(bcm);
-		bcm43xx_mac_enable(bcm);
-	}
-}
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl->current_dev;
+	unsigned long flags;
 
-static void bcm43xx_periodic_every30sec(struct bcm43xx_private *bcm)
-{
-	/* Update device statistics. */
-	bcm43xx_calculate_link_quality(bcm);
+	if (!dev)
+		return -ENODEV;
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	bcm43xx_controller_restart(dev, "Reset by ieee80211 subsystem");
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+
+	return 0;
 }
 
-static void bcm43xx_periodic_every15sec(struct bcm43xx_private *bcm)
+static const char *phymode_to_string(unsigned int phymode)
 {
-	bcm43xx_phy_xmitpower(bcm); //FIXME: unless scanning?
-	//TODO for APHY (temperature?)
+	switch (phymode) {
+	case BCM43xx_PHYMODE_B:
+		return "B";
+	case BCM43xx_PHYMODE_G:
+		return "G";
+	default:
+		BCM43xx_BUG_ON(1);
+	}
+	return "";
 }
 
-static void bcm43xx_periodic_every1sec(struct bcm43xx_private *bcm)
+static int find_wldev_for_phymode(struct bcm43xx_wl *wl,
+				  unsigned int phymode,
+				  struct bcm43xx_wldev **dev,
+				  bool *gmode)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	int radio_hw_enable;
+	struct bcm43xx_wldev *d;
 
-	/* check if radio hardware enabled status changed */
-	radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
-	if (unlikely(bcm->radio_hw_enable != radio_hw_enable)) {
-		bcm->radio_hw_enable = radio_hw_enable;
-		dprintk(KERN_INFO PFX "Radio hardware status changed to %s\n",
-		       (radio_hw_enable == 0) ? "disabled" : "enabled");
-		bcm43xx_leds_update(bcm, 0);
-	}
-	if (phy->type == BCM43xx_PHYTYPE_G) {
-		//TODO: update_aci_moving_average
-		if (radio->aci_enable && radio->aci_wlan_automatic) {
-			bcm43xx_mac_suspend(bcm);
-			if (!radio->aci_enable && 1 /*TODO: not scanning? */) {
-				if (0 /*TODO: bunch of conditions*/) {
-					bcm43xx_radio_set_interference_mitigation(bcm,
-										  BCM43xx_RADIO_INTERFMODE_MANUALWLAN);
-				}
-			} else if (1/*TODO*/) {
-				/*
-				if ((aci_average > 1000) && !(bcm43xx_radio_aci_scan(bcm))) {
-					bcm43xx_radio_set_interference_mitigation(bcm,
-										  BCM43xx_RADIO_INTERFMODE_NONE);
-				}
-				*/
-			}
-			bcm43xx_mac_enable(bcm);
-		} else if (radio->interfmode == BCM43xx_RADIO_INTERFMODE_NONWLAN &&
-			   phy->rev == 1) {
-			//TODO: implement rev1 workaround
+	list_for_each_entry(d, &wl->devlist, list) {
+		if (d->phy.possible_phymodes & phymode) {
+			/* Ok, this device supports the PHY-mode.
+			 * Set the gmode bit. */
+			*gmode = 1;
+			*dev = d;
+
+			return 0;
 		}
 	}
+
+	return -ESRCH;
 }
 
-static void do_periodic_work(struct bcm43xx_private *bcm)
+static void bcm43xx_put_phy_into_reset(struct bcm43xx_wldev *dev)
 {
-	if (bcm->periodic_state % 120 == 0)
-		bcm43xx_periodic_every120sec(bcm);
-	if (bcm->periodic_state % 60 == 0)
-		bcm43xx_periodic_every60sec(bcm);
-	if (bcm->periodic_state % 30 == 0)
-		bcm43xx_periodic_every30sec(bcm);
-	if (bcm->periodic_state % 15 == 0)
-		bcm43xx_periodic_every15sec(bcm);
-	bcm43xx_periodic_every1sec(bcm);
+	struct ssb_device *sdev = dev->dev;
+	u32 tmslow;
 
-	schedule_delayed_work(&bcm->periodic_work, HZ);
+	tmslow = ssb_read32(sdev, SSB_TMSLOW);
+	tmslow &= ~BCM43xx_TMSLOW_GMODE;
+	tmslow |= BCM43xx_TMSLOW_PHYRESET;
+	tmslow |= SSB_TMSLOW_FGC;
+	ssb_write32(sdev, SSB_TMSLOW, tmslow);
+	msleep(1);
+
+	tmslow = ssb_read32(sdev, SSB_TMSLOW);
+	tmslow &= ~SSB_TMSLOW_FGC;
+	tmslow |= BCM43xx_TMSLOW_PHYRESET;
+	ssb_write32(sdev, SSB_TMSLOW, tmslow);
+	msleep(1);
 }
 
-static void bcm43xx_periodic_work_handler(struct work_struct *work)
+/* Expects wl->mutex locked */
+static int bcm43xx_switch_phymode(struct bcm43xx_wl *wl,
+				  unsigned int new_mode)
 {
-	struct bcm43xx_private *bcm =
-		container_of(work, struct bcm43xx_private, periodic_work.work);
-	struct net_device *net_dev = bcm->net_dev;
-	unsigned long flags;
-	u32 savedirqs = 0;
-	unsigned long orig_trans_start = 0;
-
-	mutex_lock(&bcm->mutex);
-	if (unlikely(bcm->periodic_state % 60 == 0)) {
-		/* Periodic work will take a long time, so we want it to
-		 * be preemtible.
-		 */
+	struct bcm43xx_wldev *up_dev;
+	struct bcm43xx_wldev *down_dev;
+	int err;
+	bool gmode = 0;
+	int prev_status;
 
-		netif_tx_lock_bh(net_dev);
-		/* We must fake a started transmission here, as we are going to
-		 * disable TX. If we wouldn't fake a TX, it would be possible to
-		 * trigger the netdev watchdog, if the last real TX is already
-		 * some time on the past (slightly less than 5secs)
-		 */
-		orig_trans_start = net_dev->trans_start;
-		net_dev->trans_start = jiffies;
-		netif_stop_queue(net_dev);
-		netif_tx_unlock_bh(net_dev);
-
-		spin_lock_irqsave(&bcm->irq_lock, flags);
-		bcm43xx_mac_suspend(bcm);
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_freeze_txqueues(bcm);
-		savedirqs = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-		spin_unlock_irqrestore(&bcm->irq_lock, flags);
-		bcm43xx_synchronize_irq(bcm);
-	} else {
-		/* Periodic work should take short time, so we want low
-		 * locking overhead.
-		 */
-		spin_lock_irqsave(&bcm->irq_lock, flags);
+	err = find_wldev_for_phymode(wl, new_mode, &up_dev, &gmode);
+	if (err) {
+		bcmerr(wl, "Could not find a device for %s-PHY mode\n",
+		       phymode_to_string(new_mode));
+		return err;
 	}
-
-	do_periodic_work(bcm);
-
-	if (unlikely(bcm->periodic_state % 60 == 0)) {
-		spin_lock_irqsave(&bcm->irq_lock, flags);
-		tasklet_enable(&bcm->isr_tasklet);
-		bcm43xx_interrupt_enable(bcm, savedirqs);
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_thaw_txqueues(bcm);
-		bcm43xx_mac_enable(bcm);
-		netif_wake_queue(bcm->net_dev);
-		net_dev->trans_start = orig_trans_start;
+	if ((up_dev == wl->current_dev) &&
+	    (!!wl->current_dev->phy.gmode == !!gmode))
+		/* This device is already running. */
+		return 0;
+	bcmdbg(wl, "Reconfiguring PHYmode to %s-PHY\n",
+	       phymode_to_string(new_mode));
+	down_dev = wl->current_dev;
+
+	prev_status = bcm43xx_status(down_dev);
+	/* Shutdown the currently running core. */
+	if (prev_status >= BCM43xx_STAT_STARTED)
+		bcm43xx_wireless_core_stop(down_dev);
+	if (prev_status >= BCM43xx_STAT_INITIALIZED)
+		bcm43xx_wireless_core_exit(down_dev);
+
+	if (down_dev != up_dev)
+		/* We switch to a different core, so we put PHY into
+		 * RESET on the old core. */
+		bcm43xx_put_phy_into_reset(down_dev);
+
+	/* Now start the new core. */
+	up_dev->phy.gmode = gmode;
+	if (prev_status >= BCM43xx_STAT_INITIALIZED) {
+		err = bcm43xx_wireless_core_init(up_dev);
+		if (err) {
+			bcmerr(wl, "Fatal: Could not initialize device for "
+			       "newly selected %s-PHY mode\n",
+			       phymode_to_string(new_mode));
+			goto init_failure;
+		}
 	}
-	mmiowb();
-	bcm->periodic_state++;
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-}
+	if (prev_status >= BCM43xx_STAT_STARTED) {
+		err = bcm43xx_wireless_core_start(up_dev);
+		if (err) {
+			bcmerr(wl, "Fatal: Coult not start device for "
+			       "newly selected %s-PHY mode\n",
+			       phymode_to_string(new_mode));
+			bcm43xx_wireless_core_exit(up_dev);
+			goto init_failure;
+		}
+	}
+	BCM43xx_WARN_ON(bcm43xx_status(up_dev) != prev_status);
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
-{
-	cancel_rearming_delayed_work(&bcm->periodic_work);
-}
+	bcm43xx_shm_write32(up_dev, BCM43xx_SHM_SHARED, 0x003E, 0);
 
-void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
-{
-	struct delayed_work *work = &bcm->periodic_work;
+	wl->current_dev = up_dev;
 
-	assert(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED);
-	INIT_DELAYED_WORK(work, bcm43xx_periodic_work_handler);
-	schedule_delayed_work(work, 0);
+	return 0;
+init_failure:
+	/* Whoops, failed to init the new core. No core is operating now. */
+	wl->current_dev = NULL;
+	return err;
 }
 
-static void bcm43xx_security_init(struct bcm43xx_private *bcm)
+static int bcm43xx_antenna_from_ieee80211(u8 antenna)
 {
-	bcm->security_offset = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-						  0x0056) * 2;
-	bcm43xx_clear_keys(bcm);
+	switch (antenna) {
+	case 0: /* default/diversity */
+		return BCM43xx_ANTENNA_DEFAULT;
+	case 1: /* Antenna 0 */
+		return BCM43xx_ANTENNA0;
+	case 2: /* Antenna 1 */
+		return BCM43xx_ANTENNA1;
+	default:
+		return BCM43xx_ANTENNA_DEFAULT;
+	}
 }
 
-static int bcm43xx_rng_read(struct hwrng *rng, u32 *data)
+static int bcm43xx_dev_config(struct ieee80211_hw *hw,
+			      struct ieee80211_conf *conf)
 {
-	struct bcm43xx_private *bcm = (struct bcm43xx_private *)rng->priv;
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev;
+	struct bcm43xx_phy *phy;
 	unsigned long flags;
+	unsigned int new_phymode = 0xFFFF;
+	int antenna_tx;
+	int antenna_rx;
+	int err = 0;
+	u32 savedirqs;
 
-	spin_lock_irqsave(&(bcm)->irq_lock, flags);
-	*data = bcm43xx_read16(bcm, BCM43xx_MMIO_RNG);
-	spin_unlock_irqrestore(&(bcm)->irq_lock, flags);
-
-	return (sizeof(u16));
-}
-
-static void bcm43xx_rng_exit(struct bcm43xx_private *bcm)
-{
-	hwrng_unregister(&bcm->rng);
-}
+	antenna_tx = bcm43xx_antenna_from_ieee80211(conf->antenna_sel_tx);
+	antenna_rx = bcm43xx_antenna_from_ieee80211(conf->antenna_sel_rx);
 
-static int bcm43xx_rng_init(struct bcm43xx_private *bcm)
-{
-	int err;
+	mutex_lock(&wl->mutex);
 
-	snprintf(bcm->rng_name, ARRAY_SIZE(bcm->rng_name),
-		 "%s_%s", KBUILD_MODNAME, bcm->net_dev->name);
-	bcm->rng.name = bcm->rng_name;
-	bcm->rng.data_read = bcm43xx_rng_read;
-	bcm->rng.priv = (unsigned long)bcm;
-	err = hwrng_register(&bcm->rng);
+	/* Switch the PHY mode (if necessary). */
+	switch (conf->phymode) {
+	case MODE_IEEE80211B:
+		new_phymode = BCM43xx_PHYMODE_B;
+		break;
+	case MODE_IEEE80211G:
+		new_phymode = BCM43xx_PHYMODE_G;
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
+	}
+	err = bcm43xx_switch_phymode(wl, new_phymode);
 	if (err)
-		printk(KERN_ERR PFX "RNG init failed (%d)\n", err);
-
-	return err;
-}
+		goto out_unlock_mutex;
+	dev = wl->current_dev;
+	phy = &dev->phy;
+
+	/* Disable IRQs while reconfiguring the device.
+	 * This makes it possible to drop the spinlock throughout
+	 * the reconfiguration process. */
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
+		spin_unlock_irqrestore(&wl->irq_lock, flags);
+		goto out_unlock_mutex;
+	}
+	savedirqs = bcm43xx_interrupt_disable(dev, BCM43xx_IRQ_ALL);
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+	bcm43xx_synchronize_irq(dev);
+
+	/* Switch to the requested channel.
+	 * The firmware takes care of races with the TX handler. */
+	if (conf->channel_val != phy->channel)
+		bcm43xx_radio_selectchannel(dev, conf->channel_val, 0);
+
+	/* Enable/Disable ShortSlot timing. */
+	if ((!!(conf->flags & IEEE80211_CONF_SHORT_SLOT_TIME))
+	     != dev->short_slot) {
+		BCM43xx_WARN_ON(phy->type != BCM43xx_PHYTYPE_G);
+		if (conf->flags & IEEE80211_CONF_SHORT_SLOT_TIME)
+			bcm43xx_short_slot_timing_enable(dev);
+		else
+			bcm43xx_short_slot_timing_disable(dev);
+	}
 
-static int bcm43xx_shutdown_all_wireless_cores(struct bcm43xx_private *bcm)
-{
-	int ret = 0;
-	int i, err;
-	struct bcm43xx_coreinfo *core;
-
-	bcm43xx_set_status(bcm, BCM43xx_STAT_SHUTTINGDOWN);
-	for (i = 0; i < bcm->nr_80211_available; i++) {
-		core = &(bcm->core_80211[i]);
-		assert(core->available);
-		if (!core->initialized)
-			continue;
-		err = bcm43xx_switch_core(bcm, core);
-		if (err) {
-			dprintk(KERN_ERR PFX "shutdown_all_wireless_cores "
-					     "switch_core failed (%d)\n", err);
-			ret = err;
-			continue;
+	/* Adjust the desired TX power level. */
+	if (conf->power_level != 0) {
+		if (conf->power_level != phy->power_level) {
+			phy->power_level = conf->power_level;
+			bcm43xx_phy_xmitpower(dev);
 		}
-		bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-		bcm43xx_wireless_core_cleanup(bcm);
-		if (core == bcm->active_80211_core)
-			bcm->active_80211_core = NULL;
 	}
-	free_irq(bcm->irq, bcm);
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
 
-	return ret;
-}
+	/* Hide/Show the SSID (AP mode only). */
+	if (conf->flags & IEEE80211_CONF_SSID_HIDDEN)
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+				bcm43xx_read32(dev,
+				BCM43xx_MMIO_STATUS_BITFIELD)
+				| BCM43xx_SBF_NO_SSID_BCAST);
+	else
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+				bcm43xx_read32(dev,
+				BCM43xx_MMIO_STATUS_BITFIELD)
+				& ~BCM43xx_SBF_NO_SSID_BCAST);
 
-/* This is the opposite of bcm43xx_init_board() */
-static void bcm43xx_free_board(struct bcm43xx_private *bcm)
-{
-	bcm43xx_rng_exit(bcm);
-	bcm43xx_sysfs_unregister(bcm);
-	bcm43xx_periodic_tasks_delete(bcm);
+	/* Antennas for RX and management frame TX. */
+	bcm43xx_mgmtframe_txantenna(dev, antenna_tx);
 
-	mutex_lock(&(bcm)->mutex);
-	bcm43xx_shutdown_all_wireless_cores(bcm);
-	bcm43xx_pctl_set_crystal(bcm, 0);
-	mutex_unlock(&(bcm)->mutex);
-}
+	/* Update templates for AP mode. */
+	if (bcm43xx_is_mode(wl, IEEE80211_IF_TYPE_AP))
+		bcm43xx_set_beacon_int(dev, conf->beacon_int);
 
-static void prepare_phydata_for_init(struct bcm43xx_phyinfo *phy)
-{
-	phy->antenna_diversity = 0xFFFF;
-	memset(phy->minlowsig, 0xFF, sizeof(phy->minlowsig));
-	memset(phy->minlowsigpos, 0, sizeof(phy->minlowsigpos));
 
-	/* Flags */
-	phy->calibrated = 0;
-	phy->is_locked = 0;
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	bcm43xx_interrupt_enable(dev, savedirqs);
+	mmiowb();
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+out_unlock_mutex:
+	mutex_unlock(&wl->mutex);
 
-	if (phy->_lo_pairs) {
-		memset(phy->_lo_pairs, 0,
-		       sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT);
-	}
-	memset(phy->loopback_gain, 0, sizeof(phy->loopback_gain));
+	return err;
 }
 
-static void prepare_radiodata_for_init(struct bcm43xx_private *bcm,
-				       struct bcm43xx_radioinfo *radio)
+static int bcm43xx_dev_set_key(struct ieee80211_hw *hw,
+			       set_key_cmd cmd,
+			       u8 *addr,
+			       struct ieee80211_key_conf *key,
+			       int aid)
 {
-	int i;
-
-	/* Set default attenuation values. */
-	radio->baseband_atten = bcm43xx_default_baseband_attenuation(bcm);
-	radio->radio_atten = bcm43xx_default_radio_attenuation(bcm);
-	radio->txctl1 = bcm43xx_default_txctl1(bcm);
-	radio->txctl2 = 0xFFFF;
-	radio->txpwr_offset = 0;
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl->current_dev;
+	unsigned long flags;
+	u8 algorithm;
+	u8 index;
+	int err = -EINVAL;
 
-	/* NRSSI */
-	radio->nrssislope = 0;
-	for (i = 0; i < ARRAY_SIZE(radio->nrssi); i++)
-		radio->nrssi[i] = -1000;
-	for (i = 0; i < ARRAY_SIZE(radio->nrssi_lt); i++)
-		radio->nrssi_lt[i] = i;
+	if (!dev)
+		return -ENODEV;
+	switch (key->alg) {
+	case ALG_NONE:
+	case ALG_NULL:
+		algorithm = BCM43xx_SEC_ALGO_NONE;
+		break;
+	case ALG_WEP:
+		if (key->keylen == 5)
+			algorithm = BCM43xx_SEC_ALGO_WEP40;
+		else
+			algorithm = BCM43xx_SEC_ALGO_WEP104;
+		break;
+	case ALG_TKIP:
+		algorithm = BCM43xx_SEC_ALGO_TKIP;
+		break;
+	case ALG_CCMP:
+		algorithm = BCM43xx_SEC_ALGO_AES;
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
+		goto out;
+	}
 
-	radio->lofcal = 0xFFFF;
-	radio->initval = 0xFFFF;
+	index = (u8)(key->keyidx);
+	if (index > 3)
+		goto out;
 
-	radio->aci_enable = 0;
-	radio->aci_wlan_automatic = 0;
-	radio->aci_hw_rssi = 0;
-}
+	mutex_lock(&wl->mutex);
+	spin_lock_irqsave(&wl->irq_lock, flags);
 
-static void prepare_priv_for_init(struct bcm43xx_private *bcm)
-{
-	int i;
-	struct bcm43xx_coreinfo *core;
-	struct bcm43xx_coreinfo_80211 *wlext;
+	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
+		err = -ENODEV;
+		goto out_unlock;
+	}
 
-	assert(!bcm->active_80211_core);
+	switch (cmd) {
+	case SET_KEY:
+		key->flags &= ~IEEE80211_KEY_FORCE_SW_ENCRYPT;
+
+		if (algorithm == BCM43xx_SEC_ALGO_TKIP)
+			/* FIXME: No TKIP hardware encryption for now. */
+			key->flags |= IEEE80211_KEY_FORCE_SW_ENCRYPT;
+
+		if (is_broadcast_ether_addr(addr))
+			/* addr is FF:FF:FF:FF:FF:FF for default keys */
+			err = bcm43xx_key_write(dev, index, algorithm,
+						key->key, key->keylen,
+						NULL, key);
+		else
+			err = bcm43xx_key_write(dev, -1, algorithm,
+						key->key, key->keylen,
+						addr, key);
+		if (err) {
+			key->flags |= IEEE80211_KEY_FORCE_SW_ENCRYPT;
+			goto out_unlock;
+		}
+		dev->key[key->hw_key_idx].enabled = 1;
 
-	bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZING);
+	case DISABLE_KEY: {
+		static const u8 zero[BCM43xx_SEC_KEYSIZE] = { 0 };
 
-	/* Flags */
-	bcm->was_initialized = 0;
-	bcm->reg124_set_0x4 = 0;
+		algorithm = BCM43xx_SEC_ALGO_NONE;
+		if (is_broadcast_ether_addr(addr))
+			err = bcm43xx_key_write(dev, index, algorithm,
+						zero, BCM43xx_SEC_KEYSIZE,
+						NULL, key);
+		else
+			err = bcm43xx_key_write(dev, -1, algorithm,
+						zero, BCM43xx_SEC_KEYSIZE,
+						addr, key);
+		dev->key[key->hw_key_idx].enabled = 0;
+		break;
+	}
+	case REMOVE_ALL_KEYS:
+		bcm43xx_clear_keys(dev);
+		err = 0;
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
+	}
+out_unlock:
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+	mutex_unlock(&wl->mutex);
+out:
+	if (!err)
+		bcmdbg(wl, "Using %s based encryption for keyidx: %d, "
+		       "mac: " MAC_FMT "\n",
+		       (key->flags & IEEE80211_KEY_FORCE_SW_ENCRYPT) ?
+		       "software" : "hardware",
+		       key->keyidx, MAC_ARG(addr));
+	return err;
+}
 
-	/* Stats */
-	memset(&bcm->stats, 0, sizeof(bcm->stats));
+static void bcm43xx_set_multicast_list(struct ieee80211_hw *hw,
+				       unsigned short netflags,
+				       int mc_count)
+{
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl->current_dev;
+	unsigned long flags;
 
-	/* Wireless core data */
-	for (i = 0; i < BCM43xx_MAX_80211_CORES; i++) {
-		core = &(bcm->core_80211[i]);
-		wlext = core->priv;
+	if (!dev)
+		return;
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	if (wl->promisc != !!(netflags & IFF_PROMISC)) {
+		wl->promisc = !!(netflags & IFF_PROMISC);
+		if (bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED)
+			bcm43xx_adjust_opmode(dev);
+	}
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+}
 
-		if (!core->available)
-			continue;
-		assert(wlext == &(bcm->core_80211_ext[i]));
+static int bcm43xx_config_interface(struct ieee80211_hw *hw,
+				    int if_id,
+				    struct ieee80211_if_conf *conf)
+{
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl->current_dev;
+	unsigned long flags;
 
-		prepare_phydata_for_init(&wlext->phy);
-		prepare_radiodata_for_init(bcm, &wlext->radio);
+	if (!dev)
+		return -ENODEV;
+	mutex_lock(&wl->mutex);
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	if (conf->type != IEEE80211_IF_TYPE_MNTR) {
+		BCM43xx_WARN_ON(wl->if_id != if_id);
+		wl->bssid = conf->bssid;
+		if (bcm43xx_is_mode(wl, IEEE80211_IF_TYPE_AP)) {
+			BCM43xx_WARN_ON(conf->type != IEEE80211_IF_TYPE_AP);
+			bcm43xx_set_ssid(dev, conf->ssid, conf->ssid_len);
+			if (conf->beacon)
+				bcm43xx_refresh_templates(dev, conf->beacon);
+		}
+		bcm43xx_write_mac_bssid_templates(dev);
 	}
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+	mutex_unlock(&wl->mutex);
 
-	/* IRQ related flags */
-	bcm->irq_reason = 0;
-	memset(bcm->dma_reason, 0, sizeof(bcm->dma_reason));
-	bcm->irq_savedstate = BCM43xx_IRQ_INITIAL;
+	return 0;
+}
 
-	bcm->mac_suspended = 1;
+/* Locking: wl->mutex */
+static void bcm43xx_wireless_core_stop(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_wl *wl = dev->wl;
+	unsigned long flags;
 
-	/* Noise calculation context */
-	memset(&bcm->noisecalc, 0, sizeof(bcm->noisecalc));
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED)
+		return;
+	bcm43xx_set_status(dev, BCM43xx_STAT_INITIALIZED);
 
-	/* Periodic work context */
-	bcm->periodic_state = 0;
+	mutex_unlock(&wl->mutex);
+	/* Must unlock as it would otherwise deadlock. No races here. */
+	bcm43xx_periodic_tasks_delete(dev);
+	flush_workqueue(dev->wl->hw->workqueue);
+	mutex_lock(&wl->mutex);
+
+	ieee80211_stop_queues(wl->hw); /* FIXME this could cause a deadlock */
+
+	/* Disable and sync interrupts. */
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	dev->irq_savedstate = bcm43xx_interrupt_disable(dev, BCM43xx_IRQ_ALL);
+	bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK); /* flush */
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+	bcm43xx_synchronize_irq(dev);
+
+	bcm43xx_mac_suspend(dev);
+	free_irq(dev->dev->irq, dev);
+	bcmdbg(wl, "Wireless interface stopped\n");
 }
 
-static int wireless_core_up(struct bcm43xx_private *bcm,
-			    int active_wlcore)
+/* Locking: wl->mutex */
+static int bcm43xx_wireless_core_start(struct bcm43xx_wldev *dev)
 {
 	int err;
 
-	if (!bcm43xx_core_enabled(bcm))
-		bcm43xx_wireless_core_reset(bcm, 1);
-	if (!active_wlcore)
-		bcm43xx_wireless_core_mark_inactive(bcm);
-	err = bcm43xx_wireless_core_init(bcm, active_wlcore);
-	if (err)
+	BCM43xx_WARN_ON(bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED);
+
+	drain_txstatus_queue(dev);
+	err = request_irq(dev->dev->irq, bcm43xx_interrupt_handler,
+			  IRQF_SHARED, KBUILD_MODNAME, dev);
+	if (err) {
+		bcmerr(dev->wl, "Cannot request IRQ-%d\n",
+		       dev->dev->irq);
 		goto out;
-	if (!active_wlcore)
-		bcm43xx_radio_turn_off(bcm);
+	}
+	bcm43xx_mac_enable(dev);
+
+	bcm43xx_periodic_tasks_setup(dev);
+
+	ieee80211_start_queues(dev->wl->hw);
+	bcm43xx_set_status(dev, BCM43xx_STAT_STARTED);
+	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
+	bcmdbg(dev->wl, "Wireless interface started\n");
 out:
 	return err;
 }
 
-/* Select and enable the "to be used" wireless core.
- * Locking: bcm->mutex must be aquired before calling this.
- *          bcm->irq_lock must not be aquired.
- */
-int bcm43xx_select_wireless_core(struct bcm43xx_private *bcm,
-				 int phytype)
+/* Get PHY and RADIO versioning numbers */
+static int bcm43xx_phy_versioning(struct bcm43xx_wldev *dev)
 {
-	int i, err;
-	struct bcm43xx_coreinfo *active_core = NULL;
-	struct bcm43xx_coreinfo_80211 *active_wlext = NULL;
-	struct bcm43xx_coreinfo *core;
-	struct bcm43xx_coreinfo_80211 *wlext;
-	int adjust_active_sbtmstatelow = 0;
-
-	might_sleep();
-
-	if (phytype < 0) {
-		/* If no phytype is requested, select the first core. */
-		assert(bcm->core_80211[0].available);
-		wlext = bcm->core_80211[0].priv;
-		phytype = wlext->phy.type;
-	}
-	/* Find the requested core. */
-	for (i = 0; i < bcm->nr_80211_available; i++) {
-		core = &(bcm->core_80211[i]);
-		wlext = core->priv;
-		if (wlext->phy.type == phytype) {
-			active_core = core;
-			active_wlext = wlext;
-			break;
-		}
+	struct bcm43xx_phy *phy = &dev->phy;
+	u32 tmp;
+	u8 analog_type;
+	u8 phy_type;
+	u8 phy_rev;
+	u16 radio_manuf;
+	u16 radio_ver;
+	u16 radio_rev;
+	int unsupported = 0;
+
+	/* Get PHY versioning */
+	tmp = bcm43xx_read16(dev, BCM43xx_MMIO_PHY_VER);
+	analog_type = (tmp & BCM43xx_PHYVER_ANALOG)
+		      >> BCM43xx_PHYVER_ANALOG_SHIFT;
+	phy_type = (tmp & BCM43xx_PHYVER_TYPE) >> BCM43xx_PHYVER_TYPE_SHIFT;
+	phy_rev = (tmp & BCM43xx_PHYVER_VERSION);
+	switch (phy_type) {
+	case BCM43xx_PHYTYPE_B:
+		if (phy_rev != 2 && phy_rev != 4
+		    && phy_rev != 6 && phy_rev != 7)
+			unsupported = 1;
+		break;
+	case BCM43xx_PHYTYPE_G:
+		if (phy_rev > 8)
+			unsupported = 1;
+		break;
+	default:
+		unsupported = 1;
+	};
+	if (unsupported) {
+		bcmerr(dev->wl, "FOUND UNSUPPORTED PHY "
+		       "(Analog %u, Type %u, Revision %u)\n",
+		       analog_type, phy_type, phy_rev);
+		return -EOPNOTSUPP;
+	}
+	bcmdbg(dev->wl, "Found PHY: Analog %u, Type %u, Revision %u\n",
+	       analog_type, phy_type, phy_rev);
+
+
+	/* Get RADIO versioning */
+	if (dev->dev->bus->chip_id == 0x4317) {
+		if (dev->dev->bus->chip_rev == 0)
+			tmp = 0x3205017F;
+		else if (dev->dev->bus->chip_rev == 1)
+			tmp = 0x4205017F;
+		else
+			tmp = 0x5205017F;
+	} else {
+		bcm43xx_write16(dev, BCM43xx_MMIO_RADIO_CONTROL,
+				BCM43xx_RADIOCTL_ID);
+		tmp = bcm43xx_read16(dev, BCM43xx_MMIO_RADIO_DATA_HIGH);
+		tmp <<= 16;
+		bcm43xx_write16(dev, BCM43xx_MMIO_RADIO_CONTROL,
+				BCM43xx_RADIOCTL_ID);
+		tmp |= bcm43xx_read16(dev, BCM43xx_MMIO_RADIO_DATA_LOW);
+	}
+	radio_manuf = (tmp & 0x00000FFF);
+	radio_ver = (tmp & 0x0FFFF000) >> 12;
+	radio_rev = (tmp & 0xF0000000) >> 28;
+	switch (phy_type) {
+	case BCM43xx_PHYTYPE_B:
+		if ((radio_ver & 0xFFF0) != 0x2050)
+			unsupported = 1;
+		break;
+	case BCM43xx_PHYTYPE_G:
+		if (radio_ver != 0x2050)
+			unsupported = 1;
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
 	}
-	if (!active_core)
-		return -ESRCH; /* No such PHYTYPE on this board. */
-
-	if (bcm->active_80211_core) {
-		/* We already selected a wl core in the past.
-		 * So first clean up everything.
-		 */
-		dprintk(KERN_INFO PFX "select_wireless_core: cleanup\n");
-		ieee80211softmac_stop(bcm->net_dev);
-		bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZED);
-		err = bcm43xx_disable_interrupts_sync(bcm);
-		assert(!err);
-		tasklet_enable(&bcm->isr_tasklet);
-		err = bcm43xx_shutdown_all_wireless_cores(bcm);
-		if (err)
-			goto error;
-		/* Ok, everything down, continue to re-initialize. */
-		bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZING);
+	if (unsupported) {
+		bcmerr(dev->wl, "FOUND UNSUPPORTED RADIO "
+		       "(Manuf 0x%X, Version 0x%X, Revision %u)\n",
+		       radio_manuf, radio_ver, radio_rev);
+		return -EOPNOTSUPP;
 	}
+	bcmdbg(dev->wl, "Found Radio: Manuf 0x%X, Version 0x%X, Revision %u\n",
+	       radio_manuf, radio_ver, radio_rev);
 
-	/* Reset all data structures. */
-	prepare_priv_for_init(bcm);
 
-	err = bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_FAST);
-	if (err)
-		goto error;
+	phy->radio_manuf = radio_manuf;
+	phy->radio_ver = radio_ver;
+	phy->radio_rev = radio_rev;
 
-	/* Mark all unused cores "inactive". */
-	for (i = 0; i < bcm->nr_80211_available; i++) {
-		core = &(bcm->core_80211[i]);
-		wlext = core->priv;
+	phy->analog = analog_type;
+	phy->type = phy_type;
+	phy->rev = phy_rev;
 
-		if (core == active_core)
-			continue;
-		err = bcm43xx_switch_core(bcm, core);
-		if (err) {
-			dprintk(KERN_ERR PFX "Could not switch to inactive "
-					     "802.11 core (%d)\n", err);
-			goto error;
-		}
-		err = wireless_core_up(bcm, 0);
-		if (err) {
-			dprintk(KERN_ERR PFX "core_up for inactive 802.11 core "
-					     "failed (%d)\n", err);
-			goto error;
-		}
-		adjust_active_sbtmstatelow = 1;
-	}
+	return 0;
+}
 
-	/* Now initialize the active 802.11 core. */
-	err = bcm43xx_switch_core(bcm, active_core);
-	if (err) {
-		dprintk(KERN_ERR PFX "Could not switch to active "
-				     "802.11 core (%d)\n", err);
-		goto error;
-	}
-	if (adjust_active_sbtmstatelow &&
-	    active_wlext->phy.type == BCM43xx_PHYTYPE_G) {
-		u32 sbtmstatelow;
-
-		sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-		sbtmstatelow |= BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	}
-	err = wireless_core_up(bcm, 1);
-	if (err) {
-		dprintk(KERN_ERR PFX "core_up for active 802.11 core "
-				     "failed (%d)\n", err);
-		goto error;
-	}
-	err = bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_DYNAMIC);
-	if (err)
-		goto error;
-	bcm->active_80211_core = active_core;
+static void setup_struct_phy_for_init(struct bcm43xx_wldev *dev,
+				      struct bcm43xx_phy *phy)
+{
+	struct bcm43xx_lopair *lo;
+	int i;
 
-	bcm43xx_macfilter_clear(bcm, BCM43xx_MACFILTER_ASSOC);
-	bcm43xx_macfilter_set(bcm, BCM43xx_MACFILTER_SELF, (u8 *)(bcm->net_dev->dev_addr));
-	bcm43xx_security_init(bcm);
-	drain_txstatus_queue(bcm);
-	ieee80211softmac_start(bcm->net_dev);
+	memset(phy->minlowsig, 0xFF, sizeof(phy->minlowsig));
+	memset(phy->minlowsigpos, 0, sizeof(phy->minlowsigpos));
 
-	/* Let's go! Be careful after enabling the IRQs.
-	 * Don't switch cores, for example.
-	 */
-	bcm43xx_mac_enable(bcm);
-	bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZED);
-	err = bcm43xx_initialize_irq(bcm);
-	if (err)
-		goto error;
-	bcm43xx_interrupt_enable(bcm, bcm->irq_savedstate);
+	/* Flags */
+	phy->locked = 0;
 
-	dprintk(KERN_INFO PFX "Selected 802.11 core (phytype %d)\n",
-		active_wlext->phy.type);
+	phy->savedpctlreg = 0xFFFF;
+	phy->aci_enable = 0;
+	phy->aci_wlan_automatic = 0;
+	phy->aci_hw_rssi = 0;
+
+	lo = phy->_lo_pairs;
+	if (lo)
+		memset(lo, 0, sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT);
+	phy->max_lb_gain = 0;
+	phy->trsw_rx_gain = 0;
 
-	return 0;
+	/* Set default attenuation values. */
+	phy->bbatt = bcm43xx_default_baseband_attenuation(dev);
+	phy->rfatt = bcm43xx_default_radio_attenuation(dev);
+	phy->txctl1 = bcm43xx_default_txctl1(dev);
+	phy->txpwr_offset = 0;
 
-error:
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-	bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_SLOW);
-	return err;
-}
+	/* NRSSI */
+	phy->nrssislope = 0;
+	for (i = 0; i < ARRAY_SIZE(phy->nrssi); i++)
+		phy->nrssi[i] = -1000;
+	for (i = 0; i < ARRAY_SIZE(phy->nrssi_lt); i++)
+		phy->nrssi_lt[i] = i;
 
-static int bcm43xx_init_board(struct bcm43xx_private *bcm)
-{
-	int err;
+	phy->lofcal = 0xFFFF;
+	phy->initval = 0xFFFF;
 
-	mutex_lock(&(bcm)->mutex);
+	spin_lock_init(&phy->lock);
+	phy->interfmode = BCM43xx_INTERFMODE_NONE;
+	phy->channel = 0xFF;
+}
 
-	tasklet_enable(&bcm->isr_tasklet);
-	err = bcm43xx_pctl_set_crystal(bcm, 1);
-	if (err)
-		goto err_tasklet;
-	err = bcm43xx_pctl_init(bcm);
-	if (err)
-		goto err_crystal_off;
-	err = bcm43xx_select_wireless_core(bcm, -1);
-	if (err)
-		goto err_crystal_off;
-	err = bcm43xx_sysfs_register(bcm);
-	if (err)
-		goto err_wlshutdown;
-	err = bcm43xx_rng_init(bcm);
-	if (err)
-		goto err_sysfs_unreg;
-	bcm43xx_periodic_tasks_setup(bcm);
+static void setup_struct_wldev_for_init(struct bcm43xx_wldev *dev)
+{
+	/* Flags */
+	dev->reg124_set_0x4 = 0;
 
-	/*FIXME: This should be handled by softmac instead. */
-	schedule_delayed_work(&bcm->softmac->associnfo.work, 0);
+	/* Stats */
+	memset(&dev->stats, 0, sizeof(dev->stats));
 
-out:
-	mutex_unlock(&(bcm)->mutex);
+	setup_struct_phy_for_init(dev, &dev->phy);
 
-	return err;
+	/* IRQ related flags */
+	dev->irq_reason = 0;
+	memset(dev->dma_reason, 0, sizeof(dev->dma_reason));
+	dev->irq_savedstate = BCM43xx_IRQ_MASKTEMPLATE;
 
-err_sysfs_unreg:
-	bcm43xx_sysfs_unregister(bcm);
-err_wlshutdown:
-	bcm43xx_shutdown_all_wireless_cores(bcm);
-err_crystal_off:
-	bcm43xx_pctl_set_crystal(bcm, 0);
-err_tasklet:
-	tasklet_disable(&bcm->isr_tasklet);
-	goto out;
+	dev->mac_suspended = 1;
+
+	/* Noise calculation context */
+	memset(&dev->noisecalc, 0, sizeof(dev->noisecalc));
 }
 
-static void bcm43xx_detach_board(struct bcm43xx_private *bcm)
+static void bcm43xx_imcfglo_timeouts_workaround(struct bcm43xx_wldev *dev)
 {
-	struct pci_dev *pci_dev = bcm->pci_dev;
-	int i;
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+	struct ssb_bus *bus = dev->dev->bus;
+	u32 tmp;
 
-	bcm43xx_chipset_detach(bcm);
-	/* Do _not_ access the chip, after it is detached. */
-	pci_iounmap(pci_dev, bcm->mmio_addr);
-	pci_release_regions(pci_dev);
-	pci_disable_device(pci_dev);
-
-	/* Free allocated structures/fields */
-	for (i = 0; i < BCM43xx_MAX_80211_CORES; i++) {
-		kfree(bcm->core_80211_ext[i].phy._lo_pairs);
-		if (bcm->core_80211_ext[i].phy.dyn_tssi_tbl)
-			kfree(bcm->core_80211_ext[i].phy.tssi2dbm);
+	if (bus->pcicore.dev &&
+	    bus->pcicore.dev->id.coreid == SSB_DEV_PCI &&
+	    bus->pcicore.dev->id.revision <= 5) {
+		/* IMCFGLO timeouts workaround. */
+		tmp = ssb_read32(dev->dev, SSB_IMCFGLO);
+		tmp &= ~SSB_IMCFGLO_REQTO;
+		tmp &= ~SSB_IMCFGLO_SERTO;
+		switch (bus->bustype) {
+		case SSB_BUSTYPE_PCI:
+		case SSB_BUSTYPE_PCMCIA:
+			tmp |= 0x32;
+			break;
+		case SSB_BUSTYPE_SSB:
+			tmp |= 0x53;
+			break;
+		}
+		ssb_write32(dev->dev, SSB_IMCFGLO, tmp);
 	}
-}	
+#endif /* CONFIG_SSB_DRIVER_PCICORE */
+}
 
-static int bcm43xx_read_phyinfo(struct bcm43xx_private *bcm)
+/* Shutdown a wireless core */
+static void bcm43xx_wireless_core_exit(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 value;
-	u8 phy_analog;
-	u8 phy_type;
-	u8 phy_rev;
-	int phy_rev_ok = 1;
-	void *p;
+	struct bcm43xx_phy *phy = &dev->phy;
 
-	value = bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_VER);
+	BCM43xx_WARN_ON(bcm43xx_status(dev) > BCM43xx_STAT_INITIALIZED);
+	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED)
+		return;
 
-	phy_analog = (value & 0xF000) >> 12;
-	phy_type = (value & 0x0F00) >> 8;
-	phy_rev = (value & 0x000F);
+	bcm43xx_rng_exit(dev->wl);
+	bcm43xx_pio_free(dev);
+	bcm43xx_dma_free(dev);
+	bcm43xx_chip_exit(dev);
+	bcm43xx_radio_turn_off(dev);
+	bcm43xx_switch_analog(dev, 0);
+	if (phy->dyn_tssi_tbl)
+		kfree(phy->tssi2dbm);
+	kfree(phy->lo_control);
+	phy->lo_control = NULL;
+	ssb_device_disable(dev->dev, 0);
+	ssb_bus_may_powerdown(dev->dev->bus);
+	bcm43xx_set_status(dev, BCM43xx_STAT_UNINIT);
+}
 
-	dprintk(KERN_INFO PFX "Detected PHY: Analog: %x, Type %x, Revision %x\n",
-		phy_analog, phy_type, phy_rev);
+static void prepare_phy_data_for_init(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+	int i;
 
-	switch (phy_type) {
-	case BCM43xx_PHYTYPE_A:
-		if (phy_rev >= 4)
-			phy_rev_ok = 0;
-		/*FIXME: We need to switch the ieee->modulation, etc.. flags,
-		 *       if we switch 80211 cores after init is done.
-		 *       As we do not implement on the fly switching between
-		 *       wireless cores, I will leave this as a future task.
-		 */
-		bcm->ieee->modulation = IEEE80211_OFDM_MODULATION;
-		bcm->ieee->mode = IEEE_A;
-		bcm->ieee->freq_band = IEEE80211_52GHZ_BAND |
-				       IEEE80211_24GHZ_BAND;
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if (phy_rev != 2 && phy_rev != 4 && phy_rev != 6 && phy_rev != 7)
-			phy_rev_ok = 0;
-		bcm->ieee->modulation = IEEE80211_CCK_MODULATION;
-		bcm->ieee->mode = IEEE_B;
-		bcm->ieee->freq_band = IEEE80211_24GHZ_BAND;
-		break;
-	case BCM43xx_PHYTYPE_G:
-		if (phy_rev > 8)
-			phy_rev_ok = 0;
-		bcm->ieee->modulation = IEEE80211_OFDM_MODULATION |
-					IEEE80211_CCK_MODULATION;
-		bcm->ieee->mode = IEEE_G;
-		bcm->ieee->freq_band = IEEE80211_24GHZ_BAND;
-		break;
-	default:
-		printk(KERN_ERR PFX "Error: Unknown PHY Type %x\n",
-		       phy_type);
-		return -ENODEV;
-	};
-	bcm->ieee->perfect_rssi = RX_RSSI_MAX;
-	bcm->ieee->worst_rssi = 0;
-	if (!phy_rev_ok) {
-		printk(KERN_WARNING PFX "Invalid PHY Revision %x\n",
-		       phy_rev);
-	}
+	/* Set default attenuation values. */
+	phy->bbatt = bcm43xx_default_baseband_attenuation(dev);
+	phy->rfatt = bcm43xx_default_radio_attenuation(dev);
+	phy->txctl1 = bcm43xx_default_txctl1(dev);
+	phy->txctl2 = 0xFFFF;
+	phy->txpwr_offset = 0;
 
-	phy->analog = phy_analog;
-	phy->type = phy_type;
-	phy->rev = phy_rev;
-	if ((phy_type == BCM43xx_PHYTYPE_B) || (phy_type == BCM43xx_PHYTYPE_G)) {
-		p = kzalloc(sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT,
-			    GFP_KERNEL);
-		if (!p)
-			return -ENOMEM;
-		phy->_lo_pairs = p;
-	}
+	/* NRSSI */
+	phy->nrssislope = 0;
+	for (i = 0; i < ARRAY_SIZE(phy->nrssi); i++)
+		phy->nrssi[i] = -1000;
+	for (i = 0; i < ARRAY_SIZE(phy->nrssi_lt); i++)
+		phy->nrssi_lt[i] = i;
+
+	phy->lofcal = 0xFFFF;
+	phy->initval = 0xFFFF;
+
+	phy->aci_enable = 0;
+	phy->aci_wlan_automatic = 0;
+	phy->aci_hw_rssi = 0;
 
-	return 0;
+	phy->antenna_diversity = 0xFFFF;
+	memset(phy->minlowsig, 0xFF, sizeof(phy->minlowsig));
+	memset(phy->minlowsigpos, 0, sizeof(phy->minlowsigpos));
+
+	/* Flags */
+	phy->calibrated = 0;
+	phy->locked = 0;
+
+	if (phy->_lo_pairs)
+		memset(phy->_lo_pairs, 0,
+		       sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT);
+	memset(phy->loopback_gain, 0, sizeof(phy->loopback_gain));
 }
 
-static int bcm43xx_attach_board(struct bcm43xx_private *bcm)
+/* Initialize a wireless core */
+static int bcm43xx_wireless_core_init(struct bcm43xx_wldev *dev)
 {
-	struct pci_dev *pci_dev = bcm->pci_dev;
-	struct net_device *net_dev = bcm->net_dev;
+	struct bcm43xx_wl *wl = dev->wl;
+	struct ssb_bus *bus = dev->dev->bus;
+	struct bcm43xx_phy *phy = &dev->phy;
+	struct ssb_sprom *sprom = &dev->dev->bus->sprom;
 	int err;
-	int i;
-	u32 coremask;
+	u32 hf;
+	u32 tmp;
 
-	err = pci_enable_device(pci_dev);
-	if (err) {
-		printk(KERN_ERR PFX "pci_enable_device() failed\n");
+	BCM43xx_WARN_ON(bcm43xx_status(dev) != BCM43xx_STAT_UNINIT);
+
+	err = ssb_bus_powerup(bus, 0);
+	if (err)
 		goto out;
+	if (!ssb_device_is_enabled(dev->dev)) {
+		tmp = phy->gmode ? BCM43xx_TMSLOW_GMODE : 0;
+		bcm43xx_wireless_core_reset(dev, tmp);
 	}
-	err = pci_request_regions(pci_dev, KBUILD_MODNAME);
-	if (err) {
-		printk(KERN_ERR PFX "pci_request_regions() failed\n");
-		goto err_pci_disable;
-	}
-	/* enable PCI bus-mastering */
-	pci_set_master(pci_dev);
-	bcm->mmio_addr = pci_iomap(pci_dev, 0, ~0UL);
-	if (!bcm->mmio_addr) {
-		printk(KERN_ERR PFX "pci_iomap() failed\n");
-		err = -EIO;
-		goto err_pci_release;
+
+	if ((phy->type == BCM43xx_PHYTYPE_B) ||
+	    (phy->type == BCM43xx_PHYTYPE_G)) {
+		phy->_lo_pairs = kzalloc(sizeof(struct bcm43xx_lopair)
+					 * BCM43xx_LO_COUNT,
+					 GFP_KERNEL);
+		if (!phy->_lo_pairs)
+			return -ENOMEM;
 	}
-	net_dev->base_addr = (unsigned long)bcm->mmio_addr;
+	setup_struct_wldev_for_init(dev);
 
-	err = bcm43xx_pci_read_config16(bcm, PCI_SUBSYSTEM_VENDOR_ID,
-	                          &bcm->board_vendor);
+	err = bcm43xx_phy_init_tssi2dbm_table(dev);
 	if (err)
-		goto err_iounmap;
-	err = bcm43xx_pci_read_config16(bcm, PCI_SUBSYSTEM_ID,
-	                          &bcm->board_type);
-	if (err)
-		goto err_iounmap;
+		goto err_kfree_lo_control;
 
-	bcm->board_revision = bcm->pci_dev->revision;
+	/* Enable IRQ routing to this device. */
+	ssb_pcicore_dev_irqvecs_enable(&bus->pcicore, dev->dev);
 
-	err = bcm43xx_chipset_attach(bcm);
-	if (err)
-		goto err_iounmap;
-	err = bcm43xx_pctl_init(bcm);
+	bcm43xx_imcfglo_timeouts_workaround(dev);
+	prepare_phy_data_for_init(dev);
+	bcm43xx_phy_calibrate(dev);
+	err = bcm43xx_chip_init(dev);
 	if (err)
-		goto err_chipset_detach;
-	err = bcm43xx_probe_cores(bcm);
-	if (err)
-		goto err_chipset_detach;
-	
-	/* Attach all IO cores to the backplane. */
-	coremask = 0;
-	for (i = 0; i < bcm->nr_80211_available; i++)
-		coremask |= (1 << bcm->core_80211[i].index);
-	//FIXME: Also attach some non80211 cores?
-	err = bcm43xx_setup_backplane_pci_connection(bcm, coremask);
-	if (err) {
-		printk(KERN_ERR PFX "Backplane->PCI connection failed!\n");
-		goto err_chipset_detach;
+		goto err_kfree_tssitbl;
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_WLCOREREV,
+			    dev->dev->id.revision);
+	hf = bcm43xx_hf_read(dev);
+	if (phy->type == BCM43xx_PHYTYPE_G) {
+		hf |= BCM43xx_HF_SYMW;
+		if (phy->rev == 1)
+			hf |= BCM43xx_HF_GDCW;
+		if (sprom->r1.boardflags_lo & BCM43xx_BFL_PACTRL)
+			hf |= BCM43xx_HF_OFDMPABOOST;
+	} else if (phy->type == BCM43xx_PHYTYPE_B) {
+		hf |= BCM43xx_HF_SYMW;
+		if (phy->rev >= 2 && phy->radio_ver == 0x2050)
+			hf &= ~BCM43xx_HF_GDCW;
 	}
+	bcm43xx_hf_write(dev, hf);
 
-	err = bcm43xx_sprom_extract(bcm);
-	if (err)
-		goto err_chipset_detach;
-	err = bcm43xx_leds_init(bcm);
-	if (err)
-		goto err_chipset_detach;
-
-	for (i = 0; i < bcm->nr_80211_available; i++) {
-		err = bcm43xx_switch_core(bcm, &bcm->core_80211[i]);
-		assert(err != -ENODEV);
-		if (err)
-			goto err_80211_unwind;
+	/* Short/Long Retry Limit.
+	 * The retry-limit is a 4-bit counter. Enforce this to avoid overflowing
+	 * the chip-internal counter.
+	 */
+	tmp = limit_value(modparam_short_retry, 0, 0xF);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_WIRELESS,
+			    0x0006, tmp);
+	dev->short_retry_limit = tmp;
+	tmp = limit_value(modparam_long_retry, 0, 0xF);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_WIRELESS,
+			    0x0007, tmp);
+	dev->long_retry_limit = tmp;
+
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    0x0044, 3);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    0x0046, 2);
 
-		/* Enable the selected wireless core.
-		 * Connect PHY only on the first core.
-		 */
-		bcm43xx_wireless_core_reset(bcm, (i == 0));
+	bcm43xx_rate_memory_init(dev);
 
-		err = bcm43xx_read_phyinfo(bcm);
-		if (err && (i == 0))
-			goto err_80211_unwind;
-
-		err = bcm43xx_read_radioinfo(bcm);
-		if (err && (i == 0))
-			goto err_80211_unwind;
-
-		err = bcm43xx_validate_chip(bcm);
-		if (err && (i == 0))
-			goto err_80211_unwind;
+	/* Minimum Contention Window */
+	if (phy->type == BCM43xx_PHYTYPE_B)
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_WIRELESS,
+				    0x0003, 31);
+	else
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_WIRELESS,
+				    0x0003, 15);
+	/* Maximum Contention Window */
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_WIRELESS,
+			    0x0004, 1023);
 
-		bcm43xx_radio_turn_off(bcm);
-		err = bcm43xx_phy_init_tssi2dbm_table(bcm);
-		if (err)
-			goto err_80211_unwind;
-		bcm43xx_wireless_core_disable(bcm);
-	}
-	err = bcm43xx_geo_init(bcm);
+	do {
+		if (bcm43xx_using_pio(dev)) {
+			err = bcm43xx_pio_init(dev);
+		} else {
+			err = bcm43xx_dma_init(dev);
+			if (!err)
+				bcm43xx_qos_init(dev);
+		}
+	} while (err == -EAGAIN);
 	if (err)
-		goto err_80211_unwind;
-	bcm43xx_pctl_set_crystal(bcm, 0);
+		goto err_chip_exit;
 
-	/* Set the MAC address in the networking subsystem */
-	if (is_valid_ether_addr(bcm->sprom.et1macaddr))
-		memcpy(bcm->net_dev->dev_addr, bcm->sprom.et1macaddr, 6);
-	else
-		memcpy(bcm->net_dev->dev_addr, bcm->sprom.il0macaddr, 6);
+	bcm43xx_write16(dev, 0x0612, 0x0050);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0416, 0x0050);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0414, 0x01F4);
+
+	ssb_bus_powerup(bus, 1); /* Enable dynamic PCTL */
+	wl->bssid = NULL;
+	bcm43xx_upload_card_macaddress(dev, NULL);
+	bcm43xx_security_init(dev);
+	bcm43xx_rng_init(wl);
 
-	snprintf(bcm->nick, IW_ESSID_MAX_SIZE,
-		 "Broadcom %04X", bcm->chip_id);
+	bcm43xx_set_status(dev, BCM43xx_STAT_INITIALIZED);
 
-	assert(err == 0);
 out:
 	return err;
 
-err_80211_unwind:
-	for (i = 0; i < BCM43xx_MAX_80211_CORES; i++) {
-		kfree(bcm->core_80211_ext[i].phy._lo_pairs);
-		if (bcm->core_80211_ext[i].phy.dyn_tssi_tbl)
-			kfree(bcm->core_80211_ext[i].phy.tssi2dbm);
-	}
-err_chipset_detach:
-	bcm43xx_chipset_detach(bcm);
-err_iounmap:
-	pci_iounmap(pci_dev, bcm->mmio_addr);
-err_pci_release:
-	pci_release_regions(pci_dev);
-err_pci_disable:
-	pci_disable_device(pci_dev);
-	printk(KERN_ERR PFX "Unable to attach board\n");
-	goto out;
+err_chip_exit:
+	bcm43xx_chip_exit(dev);
+err_kfree_tssitbl:
+	if (phy->dyn_tssi_tbl)
+		kfree(phy->tssi2dbm);
+err_kfree_lo_control:
+	kfree(phy->lo_control);
+	phy->lo_control = NULL;
+	ssb_bus_may_powerdown(bus);
+	BCM43xx_WARN_ON(bcm43xx_status(dev) != BCM43xx_STAT_UNINIT);
+	return err;
 }
 
-/* Do the Hardware IO operations to send the txb */
-static inline int bcm43xx_tx(struct bcm43xx_private *bcm,
-			     struct ieee80211_txb *txb)
+static int bcm43xx_add_interface(struct ieee80211_hw *hw,
+				 struct ieee80211_if_init_conf *conf)
 {
-	int err = -ENODEV;
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev;
+	unsigned long flags;
+	int err = -EOPNOTSUPP;
+	int did_init = 0;
 
-	if (bcm43xx_using_pio(bcm))
-		err = bcm43xx_pio_tx(bcm, txb);
-	else
-		err = bcm43xx_dma_tx(bcm, txb);
-	bcm->net_dev->trans_start = jiffies;
+	mutex_lock(&wl->mutex);
+	if ((conf->type != IEEE80211_IF_TYPE_MNTR) &&
+	    wl->operating)
+		goto out_mutex_unlock;
+
+	bcmdbg(wl, "Adding Interface type %d\n", conf->type);
+
+	dev = wl->current_dev;
+	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED) {
+		err = bcm43xx_wireless_core_init(dev);
+		if (err)
+			goto out_mutex_unlock;
+		did_init = 1;
+	}
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
+		err = bcm43xx_wireless_core_start(dev);
+		if (err) {
+			if (did_init)
+				bcm43xx_wireless_core_exit(dev);
+			goto out_mutex_unlock;
+		}
+	}
+
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	switch (conf->type) {
+	case IEEE80211_IF_TYPE_MNTR:
+		wl->monitor++;
+		break;
+	default:
+		wl->operating = 1;
+		wl->if_id = conf->if_id;
+		wl->if_type = conf->type;
+		bcm43xx_upload_card_macaddress(dev, conf->mac_addr);
+	}
+	bcm43xx_adjust_opmode(dev);
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+
+	err = 0;
+out_mutex_unlock:
+	mutex_unlock(&wl->mutex);
 
 	return err;
 }
 
-static void bcm43xx_ieee80211_set_chan(struct net_device *net_dev,
-				       u8 channel)
+static void bcm43xx_remove_interface(struct ieee80211_hw *hw,
+				     struct ieee80211_if_init_conf *conf)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct bcm43xx_radioinfo *radio;
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev;
 	unsigned long flags;
 
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm43xx_mac_suspend(bcm);
-		bcm43xx_radio_selectchannel(bcm, channel, 0);
-		bcm43xx_mac_enable(bcm);
+	bcmdbg(wl, "Removing Interface type %d\n", conf->type);
+
+	mutex_lock(&wl->mutex);
+	if (conf->type == IEEE80211_IF_TYPE_MNTR) {
+		wl->monitor--;
+		BCM43xx_WARN_ON(wl->monitor < 0);
 	} else {
-		radio = bcm43xx_current_radio(bcm);
-		radio->initial_channel = channel;
+		BCM43xx_WARN_ON(!wl->operating);
+		wl->operating = 0;
 	}
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
+
+	dev = wl->current_dev;
+	if (!wl->operating && wl->monitor == 0) {
+		/* No interface left. */
+		if (bcm43xx_status(dev) >= BCM43xx_STAT_STARTED)
+			bcm43xx_wireless_core_stop(dev);
+		bcm43xx_wireless_core_exit(dev);
+	} else {
+		/* Just monitor interfaces left. */
+		spin_lock_irqsave(&wl->irq_lock, flags);
+		bcm43xx_adjust_opmode(dev);
+		if (!wl->operating)
+			bcm43xx_upload_card_macaddress(dev, NULL);
+		spin_unlock_irqrestore(&wl->irq_lock, flags);
+	}
+	mutex_unlock(&wl->mutex);
 }
 
-/* set_security() callback in struct ieee80211_device */
-static void bcm43xx_ieee80211_set_security(struct net_device *net_dev,
-					   struct ieee80211_security *sec)
+
+static const struct ieee80211_ops bcm43xx_hw_ops = {
+	.tx = bcm43xx_tx,
+	.conf_tx = bcm43xx_conf_tx,
+	.add_interface = bcm43xx_add_interface,
+	.remove_interface = bcm43xx_remove_interface,
+	.reset = bcm43xx_dev_reset,
+	.config = bcm43xx_dev_config,
+	.config_interface = bcm43xx_config_interface,
+	.set_multicast_list = bcm43xx_set_multicast_list,
+	.set_key = bcm43xx_dev_set_key,
+	.get_stats = bcm43xx_get_stats,
+	.get_tx_stats = bcm43xx_get_tx_stats,
+};
+
+/* Hard-reset the chip. Do not call this directly.
+ * Use bcm43xx_controller_restart()
+ */
+static void bcm43xx_chip_reset(struct work_struct *work)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct ieee80211_security *secinfo = &bcm->ieee->sec;
-	unsigned long flags;
-	int keyidx;
-	
-	dprintk(KERN_INFO PFX "set security called");
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-
-	for (keyidx = 0; keyidx<WEP_KEYS; keyidx++)
-		if (sec->flags & (1<<keyidx)) {
-			secinfo->encode_alg[keyidx] = sec->encode_alg[keyidx];
-			secinfo->key_sizes[keyidx] = sec->key_sizes[keyidx];
-			memcpy(secinfo->keys[keyidx], sec->keys[keyidx], SCM_KEY_LEN);
+	struct bcm43xx_wldev *dev =
+		container_of(work, struct bcm43xx_wldev, restart_work);
+	struct bcm43xx_wl *wl = dev->wl;
+	int err = 0;
+	int prev_status;
+
+	mutex_lock(&wl->mutex);
+
+	prev_status = bcm43xx_status(dev);
+	/* Bring the device down... */
+	if (prev_status >= BCM43xx_STAT_STARTED)
+		bcm43xx_wireless_core_stop(dev);
+	if (prev_status >= BCM43xx_STAT_INITIALIZED)
+		bcm43xx_wireless_core_exit(dev);
+
+	/* ...and up again. */
+	if (prev_status >= BCM43xx_STAT_INITIALIZED) {
+		err = bcm43xx_wireless_core_init(dev);
+		if (err)
+			goto out;
+	}
+	if (prev_status >= BCM43xx_STAT_STARTED) {
+		err = bcm43xx_wireless_core_start(dev);
+		if (err) {
+			bcm43xx_wireless_core_exit(dev);
+			goto out;
 		}
-	
-	if (sec->flags & SEC_ACTIVE_KEY) {
-		secinfo->active_key = sec->active_key;
-		dprintk(", .active_key = %d", sec->active_key);
-	}
-	if (sec->flags & SEC_UNICAST_GROUP) {
-		secinfo->unicast_uses_group = sec->unicast_uses_group;
-		dprintk(", .unicast_uses_group = %d", sec->unicast_uses_group);
-	}
-	if (sec->flags & SEC_LEVEL) {
-		secinfo->level = sec->level;
-		dprintk(", .level = %d", sec->level);
-	}
-	if (sec->flags & SEC_ENABLED) {
-		secinfo->enabled = sec->enabled;
-		dprintk(", .enabled = %d", sec->enabled);
-	}
-	if (sec->flags & SEC_ENCRYPT) {
-		secinfo->encrypt = sec->encrypt;
-		dprintk(", .encrypt = %d", sec->encrypt);
-	}
-	if (sec->flags & SEC_AUTH_MODE) {
-		secinfo->auth_mode = sec->auth_mode;
-		dprintk(", .auth_mode = %d", sec->auth_mode);
-	}
-	dprintk("\n");
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED &&
-	    !bcm->ieee->host_encrypt) {
-		if (secinfo->enabled) {
-			/* upload WEP keys to hardware */
-			char null_address[6] = { 0 };
-			u8 algorithm = 0;
-			for (keyidx = 0; keyidx<WEP_KEYS; keyidx++) {
-				if (!(sec->flags & (1<<keyidx)))
-					continue;
-				switch (sec->encode_alg[keyidx]) {
-					case SEC_ALG_NONE: algorithm = BCM43xx_SEC_ALGO_NONE; break;
-					case SEC_ALG_WEP:
-						algorithm = BCM43xx_SEC_ALGO_WEP;
-						if (secinfo->key_sizes[keyidx] == 13)
-							algorithm = BCM43xx_SEC_ALGO_WEP104;
-						break;
-					case SEC_ALG_TKIP:
-						FIXME();
-						algorithm = BCM43xx_SEC_ALGO_TKIP;
-						break;
-					case SEC_ALG_CCMP:
-						FIXME();
-						algorithm = BCM43xx_SEC_ALGO_AES;
-						break;
-					default:
-						assert(0);
-						break;
-				}
-				bcm43xx_key_write(bcm, keyidx, algorithm, sec->keys[keyidx], secinfo->key_sizes[keyidx], &null_address[0]);
-				bcm->key[keyidx].enabled = 1;
-				bcm->key[keyidx].algorithm = algorithm;
-			}
-		} else
-				bcm43xx_clear_keys(bcm);
 	}
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
+out:
+	mutex_unlock(&wl->mutex);
+	if (err)
+		bcmerr(wl, "Controller restart FAILED\n");
+	else
+		bcminfo(wl, "Controller restarted\n");
 }
 
-/* hard_start_xmit() callback in struct ieee80211_device */
-static int bcm43xx_ieee80211_hard_start_xmit(struct ieee80211_txb *txb,
-					     struct net_device *net_dev,
-					     int pri)
+static int bcm43xx_setup_modes(struct bcm43xx_wldev *dev,
+			       int have_bphy,
+			       int have_gphy)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err = -ENODEV;
-	unsigned long flags;
+	struct ieee80211_hw *hw = dev->wl->hw;
+	struct ieee80211_hw_mode *mode;
+	struct bcm43xx_phy *phy = &dev->phy;
+	int cnt = 0;
+	int err;
 
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (likely(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED))
-		err = bcm43xx_tx(bcm, txb);
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
+	phy->possible_phymodes = 0;
+	for ( ; 1; cnt++) {
+		if (have_bphy) {
+			BCM43xx_WARN_ON(cnt >= BCM43xx_MAX_PHYHWMODES);
+			mode = &phy->hwmodes[cnt];
+
+			mode->mode = MODE_IEEE80211B;
+			mode->num_channels = bcm43xx_bg_chantable_size;
+			mode->channels = bcm43xx_bg_chantable;
+			mode->num_rates = bcm43xx_b_ratetable_size;
+			mode->rates = bcm43xx_b_ratetable;
+			err = ieee80211_register_hwmode(hw, mode);
+			if (err)
+				return err;
 
-	if (unlikely(err))
-		return NETDEV_TX_BUSY;
-	return NETDEV_TX_OK;
-}
+			phy->possible_phymodes |= BCM43xx_PHYMODE_B;
+			have_bphy = 0;
+			continue;
+		}
+		if (have_gphy) {
+			BCM43xx_WARN_ON(cnt >= BCM43xx_MAX_PHYHWMODES);
+			mode = &phy->hwmodes[cnt];
+
+			mode->mode = MODE_IEEE80211G;
+			mode->num_channels = bcm43xx_bg_chantable_size;
+			mode->channels = bcm43xx_bg_chantable;
+			mode->num_rates = bcm43xx_g_ratetable_size;
+			mode->rates = bcm43xx_g_ratetable;
+			err = ieee80211_register_hwmode(hw, mode);
+			if (err)
+				return err;
 
-static void bcm43xx_net_tx_timeout(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
+			phy->possible_phymodes |= BCM43xx_PHYMODE_G;
+			have_gphy = 0;
+			continue;
+		}
+		break;
+	}
 
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	bcm43xx_controller_restart(bcm, "TX timeout");
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
+	return 0;
 }
 
-#ifdef CONFIG_NET_POLL_CONTROLLER
-static void bcm43xx_net_poll_controller(struct net_device *net_dev)
+static void bcm43xx_wireless_core_detach(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-
-	local_irq_save(flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED)
-		bcm43xx_interrupt_handler(bcm->irq, bcm);
-	local_irq_restore(flags);
+	/* We release firmware that late to not be required to re-request
+	 * is all the time when we reinit the core. */
+	bcm43xx_release_firmware(dev);
 }
-#endif /* CONFIG_NET_POLL_CONTROLLER */
 
-static int bcm43xx_net_open(struct net_device *net_dev)
+static int bcm43xx_wireless_core_attach(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
+	struct bcm43xx_wl *wl = dev->wl;
+	struct ssb_bus *bus = dev->dev->bus;
+	struct pci_dev *pdev = bus->host_pci;
+	int err;
+	int have_bphy = 0;
+	int have_gphy = 0;
+	u32 tmp;
+
+	/* Do NOT do any device initialization here.
+	 * Do it in wireless_core_init() instead.
+	 * This function is for gathering basic information about the HW, only.
+	 * Also some structs may be set up here. But most likely you want to
+	 * have that in core_init(), too.
+	 */
+
+	/* Get the PHY type. */
+	if (dev->dev->id.revision >= 5) {
+		u32 tmshigh;
+
+		tmshigh = ssb_read32(dev->dev, SSB_TMSHIGH);
+		have_gphy = !!(tmshigh & BCM43xx_TMSHIGH_GPHY);
+		if (!have_gphy)
+			have_bphy = 1;
+	} else if (dev->dev->id.revision == 4) {
+		have_gphy = 1;
+	} else {
+		have_bphy = 1;
+	}
+
+	/* Initialize LEDs structs. */
+	err = bcm43xx_leds_init(dev);
+	if (err)
+		goto out;
+
+	dev->phy.gmode = (have_gphy || have_bphy);
+	tmp = dev->phy.gmode ? BCM43xx_TMSLOW_GMODE : 0;
+	bcm43xx_wireless_core_reset(dev, tmp);
+
+	err = bcm43xx_phy_versioning(dev);
+	if (err)
+		goto err_leds_exit;
+	/* Check if this device supports multiband. */
+	if (!pdev ||
+	    (pdev->device != 0x4312 &&
+	     pdev->device != 0x4319 &&
+	     pdev->device != 0x4324)) {
+		/* No multiband support. */
+		have_bphy = 0;
+		have_gphy = 0;
+		switch (dev->phy.type) {
+		case BCM43xx_PHYTYPE_B:
+			have_bphy = 1;
+			break;
+		case BCM43xx_PHYTYPE_G:
+			have_gphy = 1;
+			break;
+		default:
+			BCM43xx_BUG_ON(1);
+		}
+	}
+	dev->phy.gmode = (have_gphy || have_bphy);
+	tmp = dev->phy.gmode ? BCM43xx_TMSLOW_GMODE : 0;
+	bcm43xx_wireless_core_reset(dev, tmp);
+
+	err = bcm43xx_validate_chipaccess(dev);
+	if (err)
+		goto err_leds_exit;
+	err = bcm43xx_setup_modes(dev, have_bphy, have_gphy);
+	if (err)
+		goto err_leds_exit;
+
+	/* Now set some default "current_dev" */
+	if (!wl->current_dev)
+		wl->current_dev = dev;
+	INIT_WORK(&dev->restart_work, bcm43xx_chip_reset);
+
+	bcm43xx_radio_turn_off(dev);
+	bcm43xx_switch_analog(dev, 0);
+	ssb_device_disable(dev->dev, 0);
+	ssb_bus_may_powerdown(bus);
 
-	return bcm43xx_init_board(bcm);
+out:
+	return err;
+
+err_leds_exit:
+	bcm43xx_leds_exit(dev);
+	return err;
 }
 
-static int bcm43xx_net_stop(struct net_device *net_dev)
+static void bcm43xx_one_core_detach(struct ssb_device *dev)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
+	struct bcm43xx_wldev *wldev;
+	struct bcm43xx_wl *wl;
 
-	ieee80211softmac_stop(net_dev);
-	err = bcm43xx_disable_interrupts_sync(bcm);
-	assert(!err);
-	bcm43xx_free_board(bcm);
-	flush_scheduled_work();
+	wldev = ssb_get_drvdata(dev);
+	wl = wldev->wl;
+	bcm43xx_debugfs_remove_device(wldev);
+	bcm43xx_wireless_core_detach(wldev);
+	list_del(&wldev->list);
+	wl->nr_devs--;
+	ssb_set_drvdata(dev, NULL);
+	kfree(wldev);
+}
+
+static int bcm43xx_one_core_attach(struct ssb_device *dev,
+				   struct bcm43xx_wl *wl)
+{
+	struct bcm43xx_wldev *wldev;
+	struct pci_dev *pdev;
+	int err = -ENOMEM;
+
+	if (!list_empty(&wl->devlist)) {
+		/* We are not the first core on this chip. */
+		pdev = dev->bus->host_pci;
+		/* Only special chips support more than one wireless
+		 * core, although some of the other chips have more than
+		 * one wireless core as well. Check for this and
+		 * bail out early.
+		 */
+		if (!pdev ||
+		    ((pdev->device != 0x4321) &&
+		     (pdev->device != 0x4313) &&
+		     (pdev->device != 0x431A))) {
+			bcmdbg(wl, "Ignoring unconnected 802.11 core\n");
+			return -ENODEV;
+		}
+	}
 
-	return 0;
-}
+	wldev = kzalloc(sizeof(*wldev), GFP_KERNEL);
+	if (!wldev)
+		goto out;
 
-static int bcm43xx_init_private(struct bcm43xx_private *bcm,
-				struct net_device *net_dev,
-				struct pci_dev *pci_dev)
-{
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-	bcm->ieee = netdev_priv(net_dev);
-	bcm->softmac = ieee80211_priv(net_dev);
-	bcm->softmac->set_channel = bcm43xx_ieee80211_set_chan;
-
-	bcm->irq_savedstate = BCM43xx_IRQ_INITIAL;
-	bcm->mac_suspended = 1;
-	bcm->pci_dev = pci_dev;
-	bcm->net_dev = net_dev;
-	bcm->bad_frames_preempt = modparam_bad_frames_preempt;
-	spin_lock_init(&bcm->irq_lock);
-	spin_lock_init(&bcm->leds_lock);
-	mutex_init(&bcm->mutex);
-	tasklet_init(&bcm->isr_tasklet,
+	wldev->dev = dev;
+	wldev->wl = wl;
+	bcm43xx_set_status(wldev, BCM43xx_STAT_UNINIT);
+	wldev->bad_frames_preempt = modparam_bad_frames_preempt;
+	tasklet_init(&wldev->isr_tasklet,
 		     (void (*)(unsigned long))bcm43xx_interrupt_tasklet,
-		     (unsigned long)bcm);
-	tasklet_disable_nosync(&bcm->isr_tasklet);
+		     (unsigned long)wldev);
 	if (modparam_pio)
-		bcm->__using_pio = 1;
-	bcm->rts_threshold = BCM43xx_DEFAULT_RTS_THRESHOLD;
+		wldev->__using_pio = 1;
+	INIT_LIST_HEAD(&wldev->list);
 
-	/* default to sw encryption for now */
-	bcm->ieee->host_build_iv = 0;
-	bcm->ieee->host_encrypt = 1;
-	bcm->ieee->host_decrypt = 1;
-	
-	bcm->ieee->iw_mode = BCM43xx_INITIAL_IWMODE;
-	bcm->ieee->tx_headroom = sizeof(struct bcm43xx_txhdr);
-	bcm->ieee->set_security = bcm43xx_ieee80211_set_security;
-	bcm->ieee->hard_start_xmit = bcm43xx_ieee80211_hard_start_xmit;
+	err = bcm43xx_wireless_core_attach(wldev);
+	if (err)
+		goto err_kfree_wldev;
 
-	return 0;
+	list_add(&wldev->list, &wl->devlist);
+	wl->nr_devs++;
+	ssb_set_drvdata(dev, wldev);
+	bcm43xx_debugfs_add_device(wldev);
+out:
+	return err;
+
+err_kfree_wldev:
+	kfree(wldev);
+	return err;
 }
 
-static int __devinit bcm43xx_init_one(struct pci_dev *pdev,
-				      const struct pci_device_id *ent)
+static void bcm43xx_sprom_fixup(struct ssb_bus *bus)
 {
-	struct net_device *net_dev;
-	struct bcm43xx_private *bcm;
-	int err;
+	/* boardflags workarounds */
+	if (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE &&
+	    bus->boardinfo.type == 0x4E &&
+	    bus->boardinfo.rev > 0x40)
+		bus->sprom.r1.boardflags_lo |= BCM43xx_BFL_PACTRL;
 
-#ifdef DEBUG_SINGLE_DEVICE_ONLY
-	if (strcmp(pci_name(pdev), DEBUG_SINGLE_DEVICE_ONLY))
-		return -ENODEV;
-#endif
+	/* Convert Antennagain values to Q5.2 */
+	bus->sprom.r1.antenna_gain_bg <<= 2;
+}
 
-	net_dev = alloc_ieee80211softmac(sizeof(*bcm));
-	if (!net_dev) {
-		printk(KERN_ERR PFX
-		       "could not allocate ieee80211 device %s\n",
-		       pci_name(pdev));
-		err = -ENOMEM;
-		goto out;
-	}
-	/* initialize the net_device struct */
-	SET_MODULE_OWNER(net_dev);
-	SET_NETDEV_DEV(net_dev, &pdev->dev);
-
-	net_dev->open = bcm43xx_net_open;
-	net_dev->stop = bcm43xx_net_stop;
-	net_dev->tx_timeout = bcm43xx_net_tx_timeout;
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	net_dev->poll_controller = bcm43xx_net_poll_controller;
-#endif
-	net_dev->wireless_handlers = &bcm43xx_wx_handlers_def;
-	net_dev->irq = pdev->irq;
-	SET_ETHTOOL_OPS(net_dev, &bcm43xx_ethtool_ops);
-
-	/* initialize the bcm43xx_private struct */
-	bcm = bcm43xx_priv(net_dev);
-	memset(bcm, 0, sizeof(*bcm));
-	err = bcm43xx_init_private(bcm, net_dev, pdev);
-	if (err)
-		goto err_free_netdev;
+static void bcm43xx_wireless_exit(struct ssb_device *dev,
+				  struct bcm43xx_wl *wl)
+{
+	struct ieee80211_hw *hw = wl->hw;
 
-	pci_set_drvdata(pdev, net_dev);
+	ssb_set_devtypedata(dev, NULL);
+	ieee80211_free_hw(hw);
+}
 
-	err = bcm43xx_attach_board(bcm);
-	if (err)
-		goto err_free_netdev;
+static int bcm43xx_wireless_init(struct ssb_device *dev)
+{
+	struct ssb_sprom *sprom = &dev->bus->sprom;
+	struct ieee80211_hw *hw;
+	struct bcm43xx_wl *wl;
+	int err = -ENOMEM;
 
-	err = register_netdev(net_dev);
-	if (err) {
-		printk(KERN_ERR PFX "Cannot register net device, "
-		       "aborting.\n");
-		err = -ENOMEM;
-		goto err_detach_board;
+	bcm43xx_sprom_fixup(dev->bus);
+
+	hw = ieee80211_alloc_hw(sizeof(*wl), &bcm43xx_hw_ops);
+	if (!hw) {
+		bcmerr(NULL, "Could not allocate ieee80211 device\n");
+		goto out;
 	}
 
-	bcm43xx_debugfs_add_device(bcm);
+	/* fill hw info */
+	hw->flags = IEEE80211_HW_HOST_GEN_BEACON_TEMPLATE |
+		    IEEE80211_HW_MONITOR_DURING_OPER |
+		    IEEE80211_HW_DEVICE_HIDES_WEP |
+		    IEEE80211_HW_WEP_INCLUDE_IV;
+	hw->max_signal = 100;
+	hw->max_rssi = -110;
+	hw->max_noise = -110;
+	hw->queues = 1; /* FIXME: hardware has more queues */
+	SET_IEEE80211_DEV(hw, dev->dev);
+	if (is_valid_ether_addr(sprom->r1.et1mac))
+		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.et1mac);
+	else
+		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.il0mac);
 
-	assert(err == 0);
+	/* Get and initialize struct bcm43xx_wl */
+	wl = hw_to_bcm43xx_wl(hw);
+	memset(wl, 0, sizeof(*wl));
+	wl->hw = hw;
+	spin_lock_init(&wl->irq_lock);
+	spin_lock_init(&wl->leds_lock);
+	mutex_init(&wl->mutex);
+	INIT_LIST_HEAD(&wl->devlist);
+
+	ssb_set_devtypedata(dev, wl);
+	bcminfo(wl, "Broadcom %04X WLAN found\n", dev->bus->chip_id);
+	err = 0;
 out:
 	return err;
-
-err_detach_board:
-	bcm43xx_detach_board(bcm);
-err_free_netdev:
-	free_ieee80211softmac(net_dev);
-	goto out;
 }
 
-static void __devexit bcm43xx_remove_one(struct pci_dev *pdev)
+static int bcm43xx_probe(struct ssb_device *dev,
+			 const struct ssb_device_id *id)
 {
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
+	struct bcm43xx_wl *wl;
+	int err;
+	int first = 0;
+
+	wl = ssb_get_devtypedata(dev);
+	if (!wl) {
+		/* Probing the first core - setup common struct bcm43xx_wl */
+		first = 1;
+		err = bcm43xx_wireless_init(dev);
+		if (err)
+			goto out;
+		wl = ssb_get_devtypedata(dev);
+		BCM43xx_WARN_ON(!wl);
+	}
+	err = bcm43xx_one_core_attach(dev, wl);
+	if (err)
+		goto err_wireless_exit;
+
+	if (first) {
+		err = ieee80211_register_hw(wl->hw);
+		if (err)
+			goto err_one_core_detach;
+	}
+
+out:
+	return err;
 
-	bcm43xx_debugfs_remove_device(bcm);
-	unregister_netdev(net_dev);
-	bcm43xx_detach_board(bcm);
-	free_ieee80211softmac(net_dev);
+err_one_core_detach:
+	bcm43xx_one_core_detach(dev);
+err_wireless_exit:
+	if (first)
+		bcm43xx_wireless_exit(dev, wl);
+	return err;
 }
 
-/* Hard-reset the chip. Do not call this directly.
- * Use bcm43xx_controller_restart()
- */
-static void bcm43xx_chip_reset(struct work_struct *work)
+static void bcm43xx_remove(struct ssb_device *dev)
 {
-	struct bcm43xx_private *bcm =
-		container_of(work, struct bcm43xx_private, restart_work);
-	struct bcm43xx_phyinfo *phy;
-	int err = -ENODEV;
+	struct bcm43xx_wl *wl = ssb_get_devtypedata(dev);
+	struct bcm43xx_wldev *wldev = ssb_get_drvdata(dev);
 
-	mutex_lock(&(bcm)->mutex);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm43xx_periodic_tasks_delete(bcm);
-		phy = bcm43xx_current_phy(bcm);
-		err = bcm43xx_select_wireless_core(bcm, phy->type);
-		if (!err)
-			bcm43xx_periodic_tasks_setup(bcm);
-	}
-	mutex_unlock(&(bcm)->mutex);
+	BCM43xx_WARN_ON(!wl);
+	if (wl->current_dev == wldev)
+		ieee80211_unregister_hw(wl->hw);
 
-	printk(KERN_ERR PFX "Controller restart%s\n",
-	       (err == 0) ? "ed" : " failed");
+	bcm43xx_one_core_detach(dev);
+
+	if (list_empty(&wl->devlist))
+		/* Last core on the chip unregistered.
+		 * We can destroy common struct bcm43xx_wl.
+		 */
+		bcm43xx_wireless_exit(dev, wl);
 }
 
 /* Hard-reset the chip.
  * This can be called from interrupt or process context.
- * bcm->irq_lock must be locked.
+ * dev->irq_lock must be locked.
  */
-void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason)
+void bcm43xx_controller_restart(struct bcm43xx_wldev *dev, const char *reason)
 {
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)
+	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED)
 		return;
-	printk(KERN_ERR PFX "Controller RESET (%s) ...\n", reason);
-	INIT_WORK(&bcm->restart_work, bcm43xx_chip_reset);
-	schedule_work(&bcm->restart_work);
+	bcminfo(dev->wl, "Controller RESET (%s) ...\n", reason);
+	queue_work(dev->wl->hw->workqueue, &dev->restart_work);
 }
 
 #ifdef CONFIG_PM
 
-static int bcm43xx_suspend(struct pci_dev *pdev, pm_message_t state)
+static int bcm43xx_suspend(struct ssb_device *dev, pm_message_t state)
 {
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
-
-	dprintk(KERN_INFO PFX "Suspending...\n");
+	struct bcm43xx_wldev *wldev = ssb_get_drvdata(dev);
+	struct bcm43xx_wl *wl = wldev->wl;
 
-	netif_device_detach(net_dev);
-	bcm->was_initialized = 0;
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm->was_initialized = 1;
-		ieee80211softmac_stop(net_dev);
-		err = bcm43xx_disable_interrupts_sync(bcm);
-		if (unlikely(err)) {
-			dprintk(KERN_ERR PFX "Suspend failed.\n");
-			return -EAGAIN;
-		}
-		bcm->firmware_norelease = 1;
-		bcm43xx_free_board(bcm);
-		bcm->firmware_norelease = 0;
-	}
-	bcm43xx_chipset_detach(bcm);
+	bcmdbg(wl, "Suspending...\n");
 
-	pci_save_state(pdev);
-	pci_disable_device(pdev);
-	pci_set_power_state(pdev, pci_choose_state(pdev, state));
+	mutex_lock(&wl->mutex);
+	wldev->suspend_init_status = bcm43xx_status(wldev);
+	if (wldev->suspend_init_status >= BCM43xx_STAT_STARTED)
+		bcm43xx_wireless_core_stop(wldev);
+	if (wldev->suspend_init_status >= BCM43xx_STAT_INITIALIZED)
+		bcm43xx_wireless_core_exit(wldev);
+	mutex_unlock(&wl->mutex);
 
-	dprintk(KERN_INFO PFX "Device suspended.\n");
+	bcmdbg(wl, "Device suspended.\n");
 
 	return 0;
 }
 
-static int bcm43xx_resume(struct pci_dev *pdev)
+static int bcm43xx_resume(struct ssb_device *dev)
 {
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
+	struct bcm43xx_wldev *wldev = ssb_get_drvdata(dev);
+	struct bcm43xx_wl *wl = wldev->wl;
 	int err = 0;
 
-	dprintk(KERN_INFO PFX "Resuming...\n");
+	bcmdbg(wl, "Resuming...\n");
 
-	pci_set_power_state(pdev, 0);
-	err = pci_enable_device(pdev);
-	if (err) {
-		printk(KERN_ERR PFX "Failure with pci_enable_device!\n");
-		return err;
+	mutex_lock(&wl->mutex);
+	if (wldev->suspend_init_status >= BCM43xx_STAT_INITIALIZED) {
+		err = bcm43xx_wireless_core_init(wldev);
+		if (err) {
+			bcmerr(wl, "Resume failed at core init\n");
+			goto out;
+		}
 	}
-	pci_restore_state(pdev);
-
-	bcm43xx_chipset_attach(bcm);
-	if (bcm->was_initialized)
-		err = bcm43xx_init_board(bcm);
-	if (err) {
-		printk(KERN_ERR PFX "Resume failed!\n");
-		return err;
+	if (wldev->suspend_init_status >= BCM43xx_STAT_STARTED) {
+		err = bcm43xx_wireless_core_start(wldev);
+		if (err) {
+			bcm43xx_wireless_core_exit(wldev);
+			bcmerr(wl, "Resume failed at core start\n");
+			goto out;
+		}
 	}
-	netif_device_attach(net_dev);
-
-	dprintk(KERN_INFO PFX "Device resumed.\n");
+	mutex_unlock(&wl->mutex);
 
-	return 0;
+	bcmdbg(wl, "Device resumed.\n");
+out:
+	return err;
 }
 
-#endif				/* CONFIG_PM */
+#else	/* CONFIG_PM */
+# define bcm43xx_suspend	NULL
+# define bcm43xx_resume		NULL
+#endif	/* CONFIG_PM */
+
+static struct ssb_driver bcm43xx_ssb_driver = {
+	.name		= KBUILD_MODNAME,
+	.id_table	= bcm43xx_ssb_tbl,
+	.probe		= bcm43xx_probe,
+	.remove		= bcm43xx_remove,
+	.suspend	= bcm43xx_suspend,
+	.resume		= bcm43xx_resume,
+};
+
+/* The PCI frontend stub */
+static const struct pci_device_id bcm43xx_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4307) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4311) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4312) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4318) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4319) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4320) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4321) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4324) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4325) },
+	{ 0 },
+};
+MODULE_DEVICE_TABLE(pci, bcm43xx_pci_tbl);
 
 static struct pci_driver bcm43xx_pci_driver = {
-	.name = KBUILD_MODNAME,
-	.id_table = bcm43xx_pci_tbl,
-	.probe = bcm43xx_init_one,
-	.remove = __devexit_p(bcm43xx_remove_one),
-#ifdef CONFIG_PM
-	.suspend = bcm43xx_suspend,
-	.resume = bcm43xx_resume,
-#endif				/* CONFIG_PM */
+	.name		= "bcm43xx-pci",
+	.id_table	= bcm43xx_pci_tbl,
 };
 
 static int __init bcm43xx_init(void)
 {
-	printk(KERN_INFO KBUILD_MODNAME " driver\n");
+	int err;
+
 	bcm43xx_debugfs_init();
-	return pci_register_driver(&bcm43xx_pci_driver);
+	err = ssb_pcihost_register(&bcm43xx_pci_driver);
+	if (err)
+		goto err_dfs_exit;
+	err = ssb_driver_register(&bcm43xx_ssb_driver);
+	if (err)
+		goto err_pci_exit;
+
+	return err;
+
+err_pci_exit:
+	ssb_pcihost_unregister(&bcm43xx_pci_driver);
+err_dfs_exit:
+	bcm43xx_debugfs_exit();
+	return err;
 }
 
 static void __exit bcm43xx_exit(void)
 {
-	pci_unregister_driver(&bcm43xx_pci_driver);
+	ssb_driver_unregister(&bcm43xx_ssb_driver);
+	ssb_pcihost_unregister(&bcm43xx_pci_driver);
 	bcm43xx_debugfs_exit();
 }
 
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
@@ -3,10 +3,11 @@
   Broadcom BCM43xx wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
+  Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005, 2006 Michael Buesch <mb at bu3sch.de>
+  Copyright (c) 2005  Danny van Dyk <kugelfang at gentoo.org>
+  Copyright (c) 2005  Andreas Jaggi <andreas.jaggi at waterwave.ch>
+  Copyright (c) 2007  Larry Finger <Larry.Finger at lwfinger.net>
 
   Some parts of the code in this file are derived from the ipw2200
   driver  Copyright(c) 2003 - 2004 Intel Corporation.
@@ -33,6 +34,7 @@
 
 #include "bcm43xx.h"
 
+
 #define P4D_BYT3S(magic, nr_bytes)	u8 __p4dding##magic[nr_bytes]
 #define P4D_BYTES(line, nr_bytes)	P4D_BYT3S(line, nr_bytes)
 /* Magic helper macro to pad structures. Ignore those above. It's magic. */
@@ -41,11 +43,6 @@
 
 /* Lightweight function to convert a frequency (in Mhz) to a channel number. */
 static inline
-u8 bcm43xx_freq_to_channel_a(int freq)
-{
-	return ((freq - 5000) / 5);
-}
-static inline
 u8 bcm43xx_freq_to_channel_bg(int freq)
 {
 	u8 channel;
@@ -58,21 +55,14 @@ u8 bcm43xx_freq_to_channel_bg(int freq)
 	return channel;
 }
 static inline
-u8 bcm43xx_freq_to_channel(struct bcm43xx_private *bcm,
+u8 bcm43xx_freq_to_channel(struct bcm43xx_wldev *dev,
 			   int freq)
 {
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_A)
-		return bcm43xx_freq_to_channel_a(freq);
 	return bcm43xx_freq_to_channel_bg(freq);
 }
 
 /* Lightweight function to convert a channel number to a frequency (in Mhz). */
 static inline
-int bcm43xx_channel_to_freq_a(u8 channel)
-{
-	return (5000 + (5 * channel));
-}
-static inline
 int bcm43xx_channel_to_freq_bg(u8 channel)
 {
 	int freq;
@@ -84,50 +74,71 @@ int bcm43xx_channel_to_freq_bg(u8 channe
 
 	return freq;
 }
+
 static inline
-int bcm43xx_channel_to_freq(struct bcm43xx_private *bcm,
+int bcm43xx_channel_to_freq(struct bcm43xx_wldev *dev,
 			    u8 channel)
 {
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_A)
-		return bcm43xx_channel_to_freq_a(channel);
 	return bcm43xx_channel_to_freq_bg(channel);
 }
 
-void bcm43xx_tsf_read(struct bcm43xx_private *bcm, u64 *tsf);
-void bcm43xx_tsf_write(struct bcm43xx_private *bcm, u64 tsf);
+static inline
+int bcm43xx_is_cck_rate(int rate)
+{
+	return (rate == BCM43xx_CCK_RATE_1MB ||
+		rate == BCM43xx_CCK_RATE_2MB ||
+		rate == BCM43xx_CCK_RATE_5MB ||
+		rate == BCM43xx_CCK_RATE_11MB);
+}
+
+static inline
+int bcm43xx_is_ofdm_rate(int rate)
+{
+	return !bcm43xx_is_cck_rate(rate);
+}
+
+static inline
+int bcm43xx_is_hw_radio_enabled(struct bcm43xx_wldev *dev)
+{
+	/* function to return state of hardware enable of radio
+	 * returns 0 if radio disabled, 1 if radio enabled
+	 */
+	struct bcm43xx_phy *phy = &dev->phy;
 
-void bcm43xx_set_iwmode(struct bcm43xx_private *bcm,
-			int iw_mode);
+	if (phy->rev >= 3)
+		return ((bcm43xx_read32(dev, BCM43xx_MMIO_RADIO_HWENABLED_HI)
+					& BCM43xx_MMIO_RADIO_HWENABLED_HI_MASK)
+					== 0) ? 1 : 0;
+	else
+		return ((bcm43xx_read16(dev, BCM43xx_MMIO_RADIO_HWENABLED_LO)
+					& BCM43xx_MMIO_RADIO_HWENABLED_LO_MASK)
+					== 0) ? 0 : 1;
+}
+
+void bcm43xx_tsf_read(struct bcm43xx_wldev *dev, u64 *tsf);
+void bcm43xx_tsf_write(struct bcm43xx_wldev *dev, u64 tsf);
 
-u32 bcm43xx_shm_read32(struct bcm43xx_private *bcm,
+u32 bcm43xx_shm_read32(struct bcm43xx_wldev *dev,
 		       u16 routing, u16 offset);
-u16 bcm43xx_shm_read16(struct bcm43xx_private *bcm,
+u16 bcm43xx_shm_read16(struct bcm43xx_wldev *dev,
 		       u16 routing, u16 offset);
-void bcm43xx_shm_write32(struct bcm43xx_private *bcm,
+void bcm43xx_shm_write32(struct bcm43xx_wldev *dev,
 			 u16 routing, u16 offset,
 			 u32 value);
-void bcm43xx_shm_write16(struct bcm43xx_private *bcm,
+void bcm43xx_shm_write16(struct bcm43xx_wldev *dev,
 			 u16 routing, u16 offset,
 			 u16 value);
 
-void bcm43xx_dummy_transmission(struct bcm43xx_private *bcm);
-
-int bcm43xx_switch_core(struct bcm43xx_private *bcm, struct bcm43xx_coreinfo *new_core);
-
-int bcm43xx_select_wireless_core(struct bcm43xx_private *bcm,
-				 int phytype);
-
-void bcm43xx_wireless_core_reset(struct bcm43xx_private *bcm, int connect_phy);
+u32 bcm43xx_hf_read(struct bcm43xx_wldev *dev);
+void bcm43xx_hf_write(struct bcm43xx_wldev *dev, u32 value);
 
-void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
-void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
+void bcm43xx_dummy_transmission(struct bcm43xx_wldev *dev);
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
-void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
+void bcm43xx_wireless_core_reset(struct bcm43xx_wldev *dev, u32 flags);
 
-void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
+void bcm43xx_mac_suspend(struct bcm43xx_wldev *dev);
+void bcm43xx_mac_enable(struct bcm43xx_wldev *dev);
 
-int bcm43xx_sprom_read(struct bcm43xx_private *bcm, u16 *sprom);
-int bcm43xx_sprom_write(struct bcm43xx_private *bcm, const u16 *sprom);
+void bcm43xx_controller_restart(struct bcm43xx_wldev *dev, const char *reason);
 
 #endif /* BCM43xx_MAIN_H_ */



From Larry.Finger at lwfinger.net  Thu Aug  2 17:54:15 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 10:54:15 -0500
Subject: [RFC 10/10] Port of bcm43xx from softmac to mac80211
Message-ID: <46b1fe27.MRk0xYwy9bH5VrBA%Larry.Finger@lwfinger.net>

This if file 10 of 10 of the port of the bcm43xx driver from softmac
to mac80211.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_xmit.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_xmit.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_xmit.c
@@ -4,11 +4,12 @@
 
   Transmission (TX/RX) related functions.
 
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
+  Copyright (C) 2005 Martin Langer <martin-langer at gmx.de>
+  Copyright (C) 2005 Stefano Brivio <st3 at riseup.net>
+  Copyright (C) 2005, 2006 Michael Buesch <mb at bu3sch.de>
+  Copyright (C) 2005 Danny van Dyk <kugelfang at gentoo.org>
+  Copyright (C) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+  Copyright (C) 2007 Larry Finger <Larry.Finger at lwfinger.net>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -27,103 +28,105 @@
 
 */
 
-#include "bcm43xx_xmit.h"
+#include <net/dst.h>
 
-#include <linux/etherdevice.h>
+#include "bcm43xx_xmit.h"
+#include "bcm43xx_phy.h"
+#include "bcm43xx_dma.h"
+#include "bcm43xx_pio.h"
 
 
 /* Extract the bitrate out of a CCK PLCP header. */
-static u8 bcm43xx_plcp_get_bitrate_cck(struct bcm43xx_plcp_hdr4 *plcp)
+static u8 bcm43xx_plcp_get_bitrate_cck(struct bcm43xx_plcp_hdr6 *plcp)
 {
 	switch (plcp->raw[0]) {
 	case 0x0A:
-		return IEEE80211_CCK_RATE_1MB;
+		return BCM43xx_CCK_RATE_1MB;
 	case 0x14:
-		return IEEE80211_CCK_RATE_2MB;
+		return BCM43xx_CCK_RATE_2MB;
 	case 0x37:
-		return IEEE80211_CCK_RATE_5MB;
+		return BCM43xx_CCK_RATE_5MB;
 	case 0x6E:
-		return IEEE80211_CCK_RATE_11MB;
+		return BCM43xx_CCK_RATE_11MB;
 	}
-	assert(0);
+	BCM43xx_BUG_ON(1);
 	return 0;
 }
 
 /* Extract the bitrate out of an OFDM PLCP header. */
-static u8 bcm43xx_plcp_get_bitrate_ofdm(struct bcm43xx_plcp_hdr4 *plcp)
+static u8 bcm43xx_plcp_get_bitrate_ofdm(struct bcm43xx_plcp_hdr6 *plcp)
 {
 	switch (plcp->raw[0] & 0xF) {
 	case 0xB:
-		return IEEE80211_OFDM_RATE_6MB;
+		return BCM43xx_OFDM_RATE_6MB;
 	case 0xF:
-		return IEEE80211_OFDM_RATE_9MB;
+		return BCM43xx_OFDM_RATE_9MB;
 	case 0xA:
-		return IEEE80211_OFDM_RATE_12MB;
+		return BCM43xx_OFDM_RATE_12MB;
 	case 0xE:
-		return IEEE80211_OFDM_RATE_18MB;
+		return BCM43xx_OFDM_RATE_18MB;
 	case 0x9:
-		return IEEE80211_OFDM_RATE_24MB;
+		return BCM43xx_OFDM_RATE_24MB;
 	case 0xD:
-		return IEEE80211_OFDM_RATE_36MB;
+		return BCM43xx_OFDM_RATE_36MB;
 	case 0x8:
-		return IEEE80211_OFDM_RATE_48MB;
+		return BCM43xx_OFDM_RATE_48MB;
 	case 0xC:
-		return IEEE80211_OFDM_RATE_54MB;
+		return BCM43xx_OFDM_RATE_54MB;
 	}
-	assert(0);
+	BCM43xx_BUG_ON(1);
 	return 0;
 }
 
 u8 bcm43xx_plcp_get_ratecode_cck(const u8 bitrate)
 {
 	switch (bitrate) {
-	case IEEE80211_CCK_RATE_1MB:
+	case BCM43xx_CCK_RATE_1MB:
 		return 0x0A;
-	case IEEE80211_CCK_RATE_2MB:
+	case BCM43xx_CCK_RATE_2MB:
 		return 0x14;
-	case IEEE80211_CCK_RATE_5MB:
+	case BCM43xx_CCK_RATE_5MB:
 		return 0x37;
-	case IEEE80211_CCK_RATE_11MB:
+	case BCM43xx_CCK_RATE_11MB:
 		return 0x6E;
 	}
-	assert(0);
+	BCM43xx_BUG_ON(1);
 	return 0;
 }
 
 u8 bcm43xx_plcp_get_ratecode_ofdm(const u8 bitrate)
 {
 	switch (bitrate) {
-	case IEEE80211_OFDM_RATE_6MB:
+	case BCM43xx_OFDM_RATE_6MB:
 		return 0xB;
-	case IEEE80211_OFDM_RATE_9MB:
+	case BCM43xx_OFDM_RATE_9MB:
 		return 0xF;
-	case IEEE80211_OFDM_RATE_12MB:
+	case BCM43xx_OFDM_RATE_12MB:
 		return 0xA;
-	case IEEE80211_OFDM_RATE_18MB:
+	case BCM43xx_OFDM_RATE_18MB:
 		return 0xE;
-	case IEEE80211_OFDM_RATE_24MB:
+	case BCM43xx_OFDM_RATE_24MB:
 		return 0x9;
-	case IEEE80211_OFDM_RATE_36MB:
+	case BCM43xx_OFDM_RATE_36MB:
 		return 0xD;
-	case IEEE80211_OFDM_RATE_48MB:
+	case BCM43xx_OFDM_RATE_48MB:
 		return 0x8;
-	case IEEE80211_OFDM_RATE_54MB:
+	case BCM43xx_OFDM_RATE_54MB:
 		return 0xC;
 	}
-	assert(0);
+	BCM43xx_BUG_ON(1);
 	return 0;
 }
 
-static void bcm43xx_generate_plcp_hdr(struct bcm43xx_plcp_hdr4 *plcp,
-				      const u16 octets, const u8 bitrate,
-				      const int ofdm_modulation)
+void bcm43xx_generate_plcp_hdr(struct bcm43xx_plcp_hdr4 *plcp,
+			       const u16 octets, const u8 bitrate)
 {
 	__le32 *data = &(plcp->data);
 	__u8 *raw = plcp->raw;
 
-	if (ofdm_modulation) {
+	if (bcm43xx_is_ofdm_rate(bitrate)) {
 		*data = bcm43xx_plcp_get_ratecode_ofdm(bitrate);
-		assert(!(octets & 0xF000));
+		BCM43xx_WARN_ON(octets & 0xF000);
 		*data |= (octets << 5);
 		*data = cpu_to_le32(*data);
 	} else {
@@ -132,13 +135,14 @@ static void bcm43xx_generate_plcp_hdr(st
 		plen = octets * 16 / bitrate;
 		if ((octets * 16 % bitrate) > 0) {
 			plen++;
-			if ((bitrate == IEEE80211_CCK_RATE_11MB)
-			    && ((octets * 8 % 11) < 4)) {
+			if ((bitrate == BCM43xx_CCK_RATE_11MB)
+			    && ((octets * 8 % 11) < 4))
 				raw[1] = 0x84;
-			} else
+			else
 				raw[1] = 0x04;
-		} else
+		} else {
 			raw[1] = 0x04;
+		}
 		*data |= cpu_to_le32(plen << 16);
 		raw[0] = bcm43xx_plcp_get_ratecode_cck(bitrate);
 	}
@@ -147,249 +151,216 @@ static void bcm43xx_generate_plcp_hdr(st
 static u8 bcm43xx_calc_fallback_rate(u8 bitrate)
 {
 	switch (bitrate) {
-	case IEEE80211_CCK_RATE_1MB:
-		return IEEE80211_CCK_RATE_1MB;
-	case IEEE80211_CCK_RATE_2MB:
-		return IEEE80211_CCK_RATE_1MB;
-	case IEEE80211_CCK_RATE_5MB:
-		return IEEE80211_CCK_RATE_2MB;
-	case IEEE80211_CCK_RATE_11MB:
-		return IEEE80211_CCK_RATE_5MB;
-	case IEEE80211_OFDM_RATE_6MB:
-		return IEEE80211_CCK_RATE_5MB;
-	case IEEE80211_OFDM_RATE_9MB:
-		return IEEE80211_OFDM_RATE_6MB;
-	case IEEE80211_OFDM_RATE_12MB:
-		return IEEE80211_OFDM_RATE_9MB;
-	case IEEE80211_OFDM_RATE_18MB:
-		return IEEE80211_OFDM_RATE_12MB;
-	case IEEE80211_OFDM_RATE_24MB:
-		return IEEE80211_OFDM_RATE_18MB;
-	case IEEE80211_OFDM_RATE_36MB:
-		return IEEE80211_OFDM_RATE_24MB;
-	case IEEE80211_OFDM_RATE_48MB:
-		return IEEE80211_OFDM_RATE_36MB;
-	case IEEE80211_OFDM_RATE_54MB:
-		return IEEE80211_OFDM_RATE_48MB;
+	case BCM43xx_CCK_RATE_1MB:
+		return BCM43xx_CCK_RATE_1MB;
+	case BCM43xx_CCK_RATE_2MB:
+		return BCM43xx_CCK_RATE_1MB;
+	case BCM43xx_CCK_RATE_5MB:
+		return BCM43xx_CCK_RATE_2MB;
+	case BCM43xx_CCK_RATE_11MB:
+		return BCM43xx_CCK_RATE_5MB;
+	case BCM43xx_OFDM_RATE_6MB:
+		return BCM43xx_CCK_RATE_5MB;
+	case BCM43xx_OFDM_RATE_9MB:
+		return BCM43xx_OFDM_RATE_6MB;
+	case BCM43xx_OFDM_RATE_12MB:
+		return BCM43xx_OFDM_RATE_9MB;
+	case BCM43xx_OFDM_RATE_18MB:
+		return BCM43xx_OFDM_RATE_12MB;
+	case BCM43xx_OFDM_RATE_24MB:
+		return BCM43xx_OFDM_RATE_18MB;
+	case BCM43xx_OFDM_RATE_36MB:
+		return BCM43xx_OFDM_RATE_24MB;
+	case BCM43xx_OFDM_RATE_48MB:
+		return BCM43xx_OFDM_RATE_36MB;
+	case BCM43xx_OFDM_RATE_54MB:
+		return BCM43xx_OFDM_RATE_48MB;
 	}
-	assert(0);
+	BCM43xx_BUG_ON(1);
 	return 0;
 }
 
-static
-__le16 bcm43xx_calc_duration_id(const struct ieee80211_hdr *wireless_header,
-				u8 bitrate)
-{
-	const u16 frame_ctl = le16_to_cpu(wireless_header->frame_ctl);
-	__le16 duration_id = wireless_header->duration_id;
-
-	switch (WLAN_FC_GET_TYPE(frame_ctl)) {
-	case IEEE80211_FTYPE_DATA:
-	case IEEE80211_FTYPE_MGMT:
-		//TODO: Steal the code from ieee80211, once it is completed there.
-		break;
-	case IEEE80211_FTYPE_CTL:
-		/* Use the original duration/id. */
-		break;
-	default:
-		assert(0);
-	}
+static void generate_txhdr_fw3(struct bcm43xx_wldev *dev,
+			       struct bcm43xx_txhdr_fw3 *txhdr,
+			       const unsigned char *fragment_data,
+			       unsigned int fragment_len,
+			       const struct ieee80211_tx_control *txctl,
+			       u16 cookie)
+{
+	const struct ieee80211_hdr *wlhdr;
+	int use_encryption = ((!(txctl->flags & IEEE80211_TXCTL_DO_NOT_ENCRYPT))
+			      && (txctl->key_idx >= 0));
+	u16 fctl;
+	u8 rate;
+	u8 rate_fb;
+	int rate_ofdm;
+	int rate_fb_ofdm;
+	unsigned int plcp_fragment_len;
+	u32 mac_ctl = 0;
+	u16 phy_ctl = 0;
 
-	return duration_id;
-}
+	wlhdr = (const struct ieee80211_hdr *)fragment_data;
+	fctl = le16_to_cpu(wlhdr->frame_control);
 
-static inline
-u16 ceiling_div(u16 dividend, u16 divisor)
-{
-	return ((dividend + divisor - 1) / divisor);
-}
+	memset(txhdr, 0, sizeof(*txhdr));
 
-static void bcm43xx_generate_rts(const struct bcm43xx_phyinfo *phy,
-				 struct bcm43xx_txhdr *txhdr,
-				 u16 *flags,
-				 u8 bitrate,
-				 const struct ieee80211_hdr_4addr *wlhdr)
-{
-	u16 fctl;
-	u16 dur;
-	u8 fallback_bitrate;
-	int ofdm_modulation;
-	int fallback_ofdm_modulation;
-//	u8 *sa, *da;
-	u16 flen;
-
-//FIXME	sa = ieee80211_get_SA((struct ieee80211_hdr *)wlhdr);
-//FIXME	da = ieee80211_get_DA((struct ieee80211_hdr *)wlhdr);
-	fallback_bitrate = bcm43xx_calc_fallback_rate(bitrate);
-	ofdm_modulation = !(ieee80211_is_cck_rate(bitrate));
-	fallback_ofdm_modulation = !(ieee80211_is_cck_rate(fallback_bitrate));
-
-	flen = sizeof(u16) + sizeof(u16) + ETH_ALEN + ETH_ALEN + IEEE80211_FCS_LEN,
-	bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)(&txhdr->rts_cts_plcp),
-				  flen, bitrate,
-				  !ieee80211_is_cck_rate(bitrate));
-	bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)(&txhdr->rts_cts_fallback_plcp),
-				  flen, fallback_bitrate,
-				  !ieee80211_is_cck_rate(fallback_bitrate));
-	fctl = IEEE80211_FTYPE_CTL;
-	fctl |= IEEE80211_STYPE_RTS;
-	dur = le16_to_cpu(wlhdr->duration_id);
-/*FIXME: should we test for dur==0 here and let it unmodified in this case?
- *       The following assert checks for this case...
- */
-assert(dur);
-/*FIXME: The duration calculation is not really correct.
- *       I am not 100% sure which bitrate to use. We use the RTS rate here,
- *       but this is likely to be wrong.
- */
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		/* Three times SIFS */
-		dur += 16 * 3;
-		/* Add ACK duration. */
-		dur += ceiling_div((16 + 8 * (14 /*bytes*/) + 6) * 10,
-				   bitrate * 4);
-		/* Add CTS duration. */
-		dur += ceiling_div((16 + 8 * (14 /*bytes*/) + 6) * 10,
-				   bitrate * 4);
+	rate = txctl->tx_rate;
+	rate_ofdm = bcm43xx_is_ofdm_rate(rate);
+	rate_fb = (txctl->alt_retry_rate == -1) ? rate : txctl->alt_retry_rate;
+	rate_fb_ofdm = bcm43xx_is_ofdm_rate(rate_fb);
+
+	txhdr->mac_frame_ctl = wlhdr->frame_control;
+	memcpy(txhdr->tx_receiver, wlhdr->addr1, 6);
+
+	/* Calculate duration for fallback rate */
+	if ((rate_fb == rate) ||
+	    (wlhdr->duration_id & cpu_to_le16(0x8000)) ||
+	    (wlhdr->duration_id == cpu_to_le16(0))) {
+		/* If the fallback rate equals the normal rate or the
+		 * dur_id field contains an AID, CFP magic or 0,
+		 * use the original dur_id field. */
+		txhdr->dur_fb = wlhdr->duration_id;
 	} else {
-		/* Three times SIFS */
-		dur += 10 * 3;
-		/* Add ACK duration. */
-		dur += ceiling_div(8 * (14 /*bytes*/) * 10,
-				   bitrate);
-		/* Add CTS duration. */
-		dur += ceiling_div(8 * (14 /*bytes*/) * 10,
-				   bitrate);
-	}
-
-	txhdr->rts_cts_frame_control = cpu_to_le16(fctl);
-	txhdr->rts_cts_dur = cpu_to_le16(dur);
-//printk(BCM43xx_MACFMT "  " BCM43xx_MACFMT "  " BCM43xx_MACFMT "\n", BCM43xx_MACARG(wlhdr->addr1), BCM43xx_MACARG(wlhdr->addr2), BCM43xx_MACARG(wlhdr->addr3));
-//printk(BCM43xx_MACFMT "  " BCM43xx_MACFMT "\n", BCM43xx_MACARG(sa), BCM43xx_MACARG(da));
-	memcpy(txhdr->rts_cts_mac1, wlhdr->addr1, ETH_ALEN);//FIXME!
-//	memcpy(txhdr->rts_cts_mac2, sa, ETH_ALEN);
-
-	*flags |= BCM43xx_TXHDRFLAG_RTSCTS;
-	*flags |= BCM43xx_TXHDRFLAG_RTS;
-	if (ofdm_modulation)
-		*flags |= BCM43xx_TXHDRFLAG_RTSCTS_OFDM;
-	if (fallback_ofdm_modulation)
-		*flags |= BCM43xx_TXHDRFLAG_RTSCTSFALLBACK_OFDM;
-}
-				 
-void bcm43xx_generate_txhdr(struct bcm43xx_private *bcm,
-			    struct bcm43xx_txhdr *txhdr,
-			    const unsigned char *fragment_data,
-			    const unsigned int fragment_len,
-			    const int is_first_fragment,
-			    const u16 cookie)
-{
-	const struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	const struct ieee80211_hdr_4addr *wireless_header = (const struct ieee80211_hdr_4addr *)fragment_data;
-	const struct ieee80211_security *secinfo = &bcm->ieee->sec;
-	u8 bitrate;
-	u8 fallback_bitrate;
-	int ofdm_modulation;
-	int fallback_ofdm_modulation;
-	u16 plcp_fragment_len = fragment_len;
-	u16 flags = 0;
-	u16 control = 0;
-	u16 wsec_rate = 0;
-	u16 encrypt_frame;
-	const u16 ftype = WLAN_FC_GET_TYPE(le16_to_cpu(wireless_header->frame_ctl));
-	const int is_mgt = (ftype == IEEE80211_FTYPE_MGMT);
+		int fbrate_base100kbps = BCM43xx_RATE_TO_100KBPS(rate_fb);
+		txhdr->dur_fb = ieee80211_generic_frame_duration(dev->wl->hw,
+							 fragment_len,
+							 fbrate_base100kbps);
+	}
+
+	plcp_fragment_len = fragment_len + FCS_LEN;
+	if (use_encryption) {
+		u8 key_idx = (u16)(txctl->key_idx);
+		struct bcm43xx_key *key;
+		int wlhdr_len;
+		size_t iv_len;
+
+		BCM43xx_WARN_ON(key_idx >= dev->max_nr_keys);
+		key = &(dev->key[key_idx]);
+
+		if (key->enabled) {
+			/* Hardware appends ICV. */
+			plcp_fragment_len += txctl->icv_len;
+
+			key_idx = bcm43xx_kidx_to_fw(dev, key_idx);
+			mac_ctl |= (key_idx << BCM43xx_TX4_MAC_KEYIDX_SHIFT) &
+				   BCM43xx_TX4_MAC_KEYIDX;
+			mac_ctl |= (key->algorithm <<
+				   BCM43xx_TX4_MAC_KEYALG_SHIFT) &
+				   BCM43xx_TX4_MAC_KEYALG;
+			wlhdr_len = ieee80211_get_hdrlen(fctl);
+			iv_len = min((size_t)txctl->iv_len,
+				     ARRAY_SIZE(txhdr->iv));
+			memcpy(txhdr->iv, ((u8 *)wlhdr) + wlhdr_len, iv_len);
+		}
+	}
+	bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)(&txhdr->plcp),
+				  plcp_fragment_len, rate);
+	bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)(&txhdr->plcp_fb),
+				  plcp_fragment_len, rate_fb);
+
+	/* PHY TX Control word */
+	if (rate_ofdm)
+		phy_ctl |= BCM43xx_TX4_PHY_OFDM;
+	if (dev->short_preamble)
+		phy_ctl |= BCM43xx_TX4_PHY_SHORTPRMBL;
+	switch (txctl->antenna_sel_tx) {
+	case 0:
+		phy_ctl |= BCM43xx_TX4_PHY_ANTLAST;
+		break;
+	case 1:
+		phy_ctl |= BCM43xx_TX4_PHY_ANT0;
+		break;
+	case 2:
+		phy_ctl |= BCM43xx_TX4_PHY_ANT1;
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
+	}
 
-	/* Now construct the TX header. */
-	memset(txhdr, 0, sizeof(*txhdr));
+	/* MAC control */
+	if (!(txctl->flags & IEEE80211_TXCTL_NO_ACK))
+		mac_ctl |= BCM43xx_TX4_MAC_ACK;
+	if (!(((fctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_CTL) &&
+	      ((fctl & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_PSPOLL)))
+		mac_ctl |= BCM43xx_TX4_MAC_HWSEQ;
+	if (txctl->flags & IEEE80211_TXCTL_FIRST_FRAGMENT)
+		mac_ctl |= BCM43xx_TX4_MAC_STMSDU;
+	if (rate_fb_ofdm)
+		mac_ctl |= BCM43xx_TX4_MAC_FALLBACKOFDM;
+
+	/* Generate the RTS or CTS-to-self frame */
+	if ((txctl->flags & IEEE80211_TXCTL_USE_RTS_CTS) ||
+	    (txctl->flags & IEEE80211_TXCTL_USE_CTS_PROTECT)) {
+		unsigned int len;
+		struct ieee80211_hdr *hdr;
+		int rts_rate;
+		int rts_rate_fb;
+		int rts_rate_ofdm;
+		int rts_rate_fb_ofdm;
+
+		rts_rate = txctl->rts_cts_rate;
+		rts_rate_ofdm = bcm43xx_is_ofdm_rate(rts_rate);
+		rts_rate_fb = bcm43xx_calc_fallback_rate(rts_rate);
+		rts_rate_fb_ofdm = bcm43xx_is_ofdm_rate(rts_rate_fb);
+		if (rts_rate_fb_ofdm)
+			mac_ctl |= BCM43xx_TX4_MAC_CTSFALLBACKOFDM;
+
+		if (txctl->flags & IEEE80211_TXCTL_USE_CTS_PROTECT) {
+			ieee80211_ctstoself_get(dev->wl->hw,
+						fragment_data,
+						fragment_len, txctl,
+						(struct ieee80211_cts *)
+						(txhdr->rts_frame));
+			mac_ctl |= BCM43xx_TX4_MAC_SENDCTS;
+			len = sizeof(struct ieee80211_cts);
+		} else {
+			ieee80211_rts_get(dev->wl->hw,
+					  fragment_data, fragment_len, txctl,
+					  (struct ieee80211_rts *)
+					  (txhdr->rts_frame));
+			mac_ctl |= BCM43xx_TX4_MAC_SENDRTS;
+			len = sizeof(struct ieee80211_rts);
+		}
+		len += FCS_LEN;
+		bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)
+					  (&txhdr->rts_plcp),
+					  len, rts_rate);
+		bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)
+					  (&txhdr->rts_plcp_fb),
+					  len, rts_rate_fb);
+		hdr = (struct ieee80211_hdr *)(&txhdr->rts_frame);
+		txhdr->rts_dur_fb = hdr->duration_id;
+		mac_ctl |= BCM43xx_TX4_MAC_LONGFRAME;
+	}
 
-	bitrate = ieee80211softmac_suggest_txrate(bcm->softmac,
-		is_multicast_ether_addr(wireless_header->addr1), is_mgt);
-	ofdm_modulation = !(ieee80211_is_cck_rate(bitrate));
-	fallback_bitrate = bcm43xx_calc_fallback_rate(bitrate);
-	fallback_ofdm_modulation = !(ieee80211_is_cck_rate(fallback_bitrate));
-
-	/* Set Frame Control from 80211 header. */
-	txhdr->frame_control = wireless_header->frame_ctl;
-	/* Copy address1 from 80211 header. */
-	memcpy(txhdr->mac1, wireless_header->addr1, 6);
-	/* Set the fallback duration ID. */
-	txhdr->fallback_dur_id = bcm43xx_calc_duration_id((const struct ieee80211_hdr *)wireless_header,
-							  fallback_bitrate);
-	/* Set the cookie (used as driver internal ID for the frame) */
+	/* Magic cookie */
 	txhdr->cookie = cpu_to_le16(cookie);
 
-	/* Hardware appends FCS. */
-	plcp_fragment_len += IEEE80211_FCS_LEN;
-
-	/* Hardware encryption. */
-	encrypt_frame = le16_to_cpup(&wireless_header->frame_ctl) & IEEE80211_FCTL_PROTECTED;
-	if (encrypt_frame && !bcm->ieee->host_encrypt) {
-		const struct ieee80211_hdr_3addr *hdr = (struct ieee80211_hdr_3addr *)wireless_header;
-		memcpy(txhdr->wep_iv, hdr->payload, 4);
-		/* Hardware appends ICV. */
-		plcp_fragment_len += 4;
-
-		wsec_rate |= (bcm->key[secinfo->active_key].algorithm << BCM43xx_TXHDR_WSEC_ALGO_SHIFT)
-			     & BCM43xx_TXHDR_WSEC_ALGO_MASK;
-		wsec_rate |= (secinfo->active_key << BCM43xx_TXHDR_WSEC_KEYINDEX_SHIFT)
-			     & BCM43xx_TXHDR_WSEC_KEYINDEX_MASK;
-	}
+	/* Apply the bitfields */
+	txhdr->mac_ctl = cpu_to_le32(mac_ctl);
+	txhdr->phy_ctl = cpu_to_le16(phy_ctl);
+}
 
-	/* Generate the PLCP header and the fallback PLCP header. */
-	bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)(&txhdr->plcp),
-				  plcp_fragment_len,
-				  bitrate, ofdm_modulation);
-	bcm43xx_generate_plcp_hdr(&txhdr->fallback_plcp, plcp_fragment_len,
-				  fallback_bitrate, fallback_ofdm_modulation);
-
-	/* Set the CONTROL field */
-	if (ofdm_modulation)
-		control |= BCM43xx_TXHDRCTL_OFDM;
-	if (bcm->short_preamble) //FIXME: could be the other way around, please test
-		control |= BCM43xx_TXHDRCTL_SHORT_PREAMBLE;
-	control |= (phy->antenna_diversity << BCM43xx_TXHDRCTL_ANTENNADIV_SHIFT)
-		   & BCM43xx_TXHDRCTL_ANTENNADIV_MASK;
-
-	/* Set the FLAGS field */
-	if (!is_multicast_ether_addr(wireless_header->addr1) &&
-	    !is_broadcast_ether_addr(wireless_header->addr1))
-		flags |= BCM43xx_TXHDRFLAG_EXPECTACK;
-	if (1 /* FIXME: PS poll?? */)
-		flags |= 0x10; // FIXME: unknown meaning.
-	if (fallback_ofdm_modulation)
-		flags |= BCM43xx_TXHDRFLAG_FALLBACKOFDM;
-	if (is_first_fragment)
-		flags |= BCM43xx_TXHDRFLAG_FIRSTFRAGMENT;
-
-	/* Set WSEC/RATE field */
-	wsec_rate |= (txhdr->plcp.raw[0] << BCM43xx_TXHDR_RATE_SHIFT)
-		     & BCM43xx_TXHDR_RATE_MASK;
-
-	/* Generate the RTS/CTS packet, if required. */
-	/* FIXME: We should first try with CTS-to-self,
-	 *        if we are on 80211g. If we get too many
-	 *        failures (hidden nodes), we should switch back to RTS/CTS.
-	 */
-	if (0/*FIXME txctl->use_rts_cts*/) {
-		bcm43xx_generate_rts(phy, txhdr, &flags,
-				     0/*FIXME txctl->rts_cts_rate*/,
-				     wireless_header);
-	}
-
-	txhdr->flags = cpu_to_le16(flags);
-	txhdr->control = cpu_to_le16(control);
-	txhdr->wsec_rate = cpu_to_le16(wsec_rate);
+void bcm43xx_generate_txhdr(struct bcm43xx_wldev *dev,
+			    u8 *txhdr,
+			    const unsigned char *fragment_data,
+			    unsigned int fragment_len,
+			    const struct ieee80211_tx_control *txctl,
+			    u16 cookie)
+{
+	generate_txhdr_fw3(dev, (struct bcm43xx_txhdr_fw3 *)txhdr,
+			   fragment_data, fragment_len,
+			   txctl, cookie);
 }
 
-static s8 bcm43xx_rssi_postprocess(struct bcm43xx_private *bcm,
+static s8 bcm43xx_rssi_postprocess(struct bcm43xx_wldev *dev,
 				   u8 in_rssi, int ofdm,
 				   int adjust_2053, int adjust_2050)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_phy *phy = &dev->phy;
 	s32 tmp;
 
-	switch (radio->version) {
+	switch (phy->radio_ver) {
 	case 0x2050:
 		if (ofdm) {
 			tmp = in_rssi;
@@ -402,10 +373,11 @@ static s8 bcm43xx_rssi_postprocess(struc
 			else
 				tmp -= 3;
 		} else {
-			if (bcm->sprom.boardflags & BCM43xx_BFL_RSSI) {
+			if (dev->dev->bus->sprom.r1.boardflags_lo
+			    & BCM43xx_BFL_RSSI) {
 				if (in_rssi > 63)
 					in_rssi = 63;
-				tmp = radio->nrssi_lt[in_rssi];
+				tmp = phy->nrssi_lt[in_rssi];
 				tmp = 31 - tmp;
 				tmp *= -131;
 				tmp /= 128;
@@ -442,124 +414,221 @@ static s8 bcm43xx_rssi_postprocess(struc
 	return (s8)tmp;
 }
 
-//TODO
-#if 0
-static s8 bcm43xx_rssinoise_postprocess(struct bcm43xx_private *bcm,
-					u8 in_rssi)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	s8 ret;
-
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		//TODO: Incomplete specs.
-		ret = 0;
-	} else
-		ret = bcm43xx_rssi_postprocess(bcm, in_rssi, 0, 1, 1);
-
-	return ret;
-}
-#endif
-
-int bcm43xx_rx(struct bcm43xx_private *bcm,
-	       struct sk_buff *skb,
-	       struct bcm43xx_rxhdr *rxhdr)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_plcp_hdr4 *plcp;
-	struct ieee80211_rx_stats stats;
-	struct ieee80211_hdr_4addr *wlhdr;
-	u16 frame_ctl;
-	int is_packet_for_us = 0;
-	int err = -EINVAL;
-	const u16 rxflags1 = le16_to_cpu(rxhdr->flags1);
-	const u16 rxflags2 = le16_to_cpu(rxhdr->flags2);
-	const u16 rxflags3 = le16_to_cpu(rxhdr->flags3);
-	const int is_ofdm = !!(rxflags1 & BCM43xx_RXHDR_FLAGS1_OFDM);
-
-	if (rxflags2 & BCM43xx_RXHDR_FLAGS2_TYPE2FRAME) {
-		plcp = (struct bcm43xx_plcp_hdr4 *)(skb->data + 2);
-		/* Skip two unknown bytes and the PLCP header. */
-		skb_pull(skb, 2 + sizeof(struct bcm43xx_plcp_hdr6));
-	} else {
-		plcp = (struct bcm43xx_plcp_hdr4 *)(skb->data);
-		/* Skip the PLCP header. */
-		skb_pull(skb, sizeof(struct bcm43xx_plcp_hdr6));
-	}
-	/* The SKB contains the PAYLOAD (wireless header + data)
-	 * at this point. The FCS at the end is stripped.
-	 */
-
-	memset(&stats, 0, sizeof(stats));
-	stats.mac_time = le16_to_cpu(rxhdr->mactime);
-	stats.rssi = rxhdr->rssi;
-	stats.signal = bcm43xx_rssi_postprocess(bcm, rxhdr->rssi, is_ofdm,
-					      !!(rxflags1 & BCM43xx_RXHDR_FLAGS1_2053RSSIADJ),
-					      !!(rxflags3 & BCM43xx_RXHDR_FLAGS3_2050RSSIADJ));
-	stats.noise = bcm->stats.noise;
-	if (is_ofdm)
-		stats.rate = bcm43xx_plcp_get_bitrate_ofdm(plcp);
-	else
-		stats.rate = bcm43xx_plcp_get_bitrate_cck(plcp);
-	stats.received_channel = radio->channel;
-	stats.mask = IEEE80211_STATMASK_SIGNAL |
-		     IEEE80211_STATMASK_NOISE |
-		     IEEE80211_STATMASK_RATE |
-		     IEEE80211_STATMASK_RSSI;
-	if (phy->type == BCM43xx_PHYTYPE_A)
-		stats.freq = IEEE80211_52GHZ_BAND;
-	else
-		stats.freq = IEEE80211_24GHZ_BAND;
-	stats.len = skb->len;
+void bcm43xx_rx(struct bcm43xx_wldev *dev,
+		struct sk_buff *skb,
+		const void *_rxhdr)
+{
+	struct ieee80211_rx_status status;
+	struct bcm43xx_plcp_hdr6 *plcp;
+	struct ieee80211_hdr *wlhdr;
+	const struct bcm43xx_rxhdr_fw3 *rxhdr = _rxhdr;
+	u16 fctl;
+	u16 phystat0;
+	u16 phystat3;
+	u16 chanstat;
+	u16 mactime;
+	u32 macstat;
+	u16 chanid;
+	u8 jssi;
+	int padding;
+
+	memset(&status, 0, sizeof(status));
+
+	/* Get metadata about the frame from the header. */
+	phystat0 = le16_to_cpu(rxhdr->phy_status0);
+	phystat3 = le16_to_cpu(rxhdr->phy_status3);
+	jssi = rxhdr->jssi;
+	macstat = le32_to_cpu(rxhdr->mac_status);
+	mactime = le16_to_cpu(rxhdr->mac_time);
+	chanstat = le16_to_cpu(rxhdr->channel);
+
+	if (macstat & BCM43xx_RX_MAC_FCSERR)
+		dev->wl->ieee_stats.dot11FCSErrorCount++;
+
+	/* Skip PLCP and padding */
+	padding = (macstat & BCM43xx_RX_MAC_PADDING) ? 2 : 0;
+	if (unlikely(skb->len < (sizeof(struct bcm43xx_plcp_hdr6) + padding))) {
+		bcmdbg(dev->wl, "RX: Packet size underrun (1)\n");
+		goto drop;
+	}
+	plcp = (struct bcm43xx_plcp_hdr6 *)(skb->data + padding);
+	skb_pull(skb, sizeof(struct bcm43xx_plcp_hdr6) + padding);
+	/* The skb contains the Wireless Header + payload data now */
+	if (unlikely(skb->len < (2+2+6/*minimum hdr*/ + FCS_LEN))) {
+		bcmdbg(dev->wl, "RX: Packet size underrun (2)\n");
+		goto drop;
+	}
+	wlhdr = (struct ieee80211_hdr *)(skb->data);
+	fctl = le16_to_cpu(wlhdr->frame_control);
+	skb_trim(skb, skb->len - FCS_LEN);
+
+	if ((macstat & BCM43xx_RX_MAC_DEC) &&
+	    !(macstat & BCM43xx_RX_MAC_DECERR)) {
+		unsigned int keyidx;
+		int wlhdr_len;
+		int iv_len;
+		int icv_len;
+
+		keyidx = ((macstat & BCM43xx_RX_MAC_KEYIDX)
+			  >> BCM43xx_RX_MAC_KEYIDX_SHIFT);
+		/* We must adjust the key index here. We want the "physical"
+		 * key index, but the ucode passed it slightly different.
+		 */
+		keyidx = bcm43xx_kidx_to_raw(dev, keyidx);
+		BCM43xx_WARN_ON(keyidx >= dev->max_nr_keys);
+
+		if (dev->key[keyidx].algorithm != BCM43xx_SEC_ALGO_NONE) {
+			/* Remove PROTECTED flag to mark it as decrypted. */
+			BCM43xx_WARN_ON(!(fctl & IEEE80211_FCTL_PROTECTED));
+			fctl &= ~IEEE80211_FCTL_PROTECTED;
+			wlhdr->frame_control = cpu_to_le16(fctl);
+
+			wlhdr_len = ieee80211_get_hdrlen(fctl);
+			if (unlikely(skb->len < (wlhdr_len + 3))) {
+				bcmdbg(dev->wl, "RX: Packet size underrun3\n");
+				goto drop;
+			}
+			if (skb->data[wlhdr_len + 3] & (1 << 5)) {
+				/* The Ext-IV Bit is set in the "KeyID"
+				 * octet of the IV.
+				 */
+				iv_len = 8;
+				icv_len = 8;
+			} else {
+				iv_len = 4;
+				icv_len = 4;
+			}
+			if (unlikely(skb->len < (wlhdr_len + iv_len +
+			    icv_len))) {
+				bcmdbg(dev->wl, "RX: Packet size underrun4\n");
+				goto drop;
+			}
+			/* Remove the IV */
+			memmove(skb->data + iv_len, skb->data, wlhdr_len);
+			skb_pull(skb, iv_len);
+			/* Remove the ICV */
+			skb_trim(skb, skb->len - icv_len);
 
-	bcm->stats.last_rx = jiffies;
-	if (bcm->ieee->iw_mode == IW_MODE_MONITOR) {
-		err = ieee80211_rx(bcm->ieee, skb, &stats);
-		return (err == 0) ? -EINVAL : 0;
-	}
-
-	wlhdr = (struct ieee80211_hdr_4addr *)(skb->data);
-
-	switch (bcm->ieee->iw_mode) {
-	case IW_MODE_ADHOC:
-		if (memcmp(wlhdr->addr1, bcm->net_dev->dev_addr, ETH_ALEN) == 0 ||
-		    memcmp(wlhdr->addr3, bcm->ieee->bssid, ETH_ALEN) == 0 ||
-		    is_broadcast_ether_addr(wlhdr->addr1) ||
-		    is_multicast_ether_addr(wlhdr->addr1) ||
-		    bcm->net_dev->flags & IFF_PROMISC)
-			is_packet_for_us = 1;
-		break;
-	case IW_MODE_INFRA:
-	default:
-		/* When receiving multicast or broadcast packets, filter out
-		   the packets we send ourself; we shouldn't see those */
-		if (memcmp(wlhdr->addr3, bcm->ieee->bssid, ETH_ALEN) == 0 ||
-		    memcmp(wlhdr->addr1, bcm->net_dev->dev_addr, ETH_ALEN) == 0 ||
-		    (memcmp(wlhdr->addr3, bcm->net_dev->dev_addr, ETH_ALEN) &&
-		     (is_broadcast_ether_addr(wlhdr->addr1) ||
-		      is_multicast_ether_addr(wlhdr->addr1) ||
-		      bcm->net_dev->flags & IFF_PROMISC)))
-			is_packet_for_us = 1;
-		break;
+			status.flag |= RX_FLAG_DECRYPTED;
+		}
 	}
 
-	frame_ctl = le16_to_cpu(wlhdr->frame_ctl);
-	switch (WLAN_FC_GET_TYPE(frame_ctl)) {
-	case IEEE80211_FTYPE_MGMT:
-		ieee80211_rx_mgt(bcm->ieee, wlhdr, &stats);
-		break;
-	case IEEE80211_FTYPE_DATA:
-		if (is_packet_for_us) {
-			err = ieee80211_rx(bcm->ieee, skb, &stats);
-			err = (err == 0) ? -EINVAL : 0;
-		}
+	status.ssi = bcm43xx_rssi_postprocess(dev, jssi,
+				      (phystat0 & BCM43xx_RX_PHYST0_OFDM),
+				      (phystat0 & BCM43xx_RX_PHYST0_GAINCTL),
+				      (phystat3 & BCM43xx_RX_PHYST3_TRSTATE));
+	status.noise = dev->stats.link_noise;
+	status.signal = jssi * 100 / BCM43xx_RX_MAX_SSI;
+	if (phystat0 & BCM43xx_RX_PHYST0_OFDM)
+		status.rate = bcm43xx_plcp_get_bitrate_ofdm(plcp);
+	else
+		status.rate = bcm43xx_plcp_get_bitrate_cck(plcp);
+	status.antenna = !!(phystat0 & BCM43xx_RX_PHYST0_ANT);
+	status.mactime = mactime;
+
+	chanid = (chanstat & BCM43xx_RX_CHAN_ID) >> BCM43xx_RX_CHAN_ID_SHIFT;
+	switch (chanstat & BCM43xx_RX_CHAN_PHYTYPE) {
+	case BCM43xx_PHYTYPE_B:
+		status.phymode = MODE_IEEE80211B;
+		status.freq = chanid + 2400;
+		status.channel = bcm43xx_freq_to_channel_bg(chanid + 2400);
 		break;
-	case IEEE80211_FTYPE_CTL:
+	case BCM43xx_PHYTYPE_G:
+		status.phymode = MODE_IEEE80211G;
+		status.freq = chanid + 2400;
+		status.channel = bcm43xx_freq_to_channel_bg(chanid + 2400);
 		break;
 	default:
-		assert(0);
-		return -EINVAL;
+		bcmwarn(dev->wl, "Unexpected value for chanstat (0x%X)\n",
+		       chanstat);
+	}
+
+	dev->stats.last_rx = jiffies;
+	ieee80211_rx_irqsafe(dev->wl->hw, skb, &status);
+
+	return;
+drop:
+	bcmdbg(dev->wl, "RX: Packet dropped\n");
+	dev_kfree_skb_any(skb);
+}
+
+void bcm43xx_handle_txstatus(struct bcm43xx_wldev *dev,
+			     const struct bcm43xx_txstatus *status)
+{
+	bcm43xx_debugfs_log_txstat(dev, status);
+
+	if (status->intermediate)
+		return;
+	if (status->for_ampdu)
+		return;
+	if (!status->acked)
+		dev->wl->ieee_stats.dot11ACKFailureCount++;
+	if (status->rts_count) {
+		if (status->rts_count == 0xF) /* FIXME */
+			dev->wl->ieee_stats.dot11RTSFailureCount++;
+		else
+			dev->wl->ieee_stats.dot11RTSSuccessCount++;
 	}
 
-	return err;
+	if (bcm43xx_using_pio(dev))
+		bcm43xx_pio_handle_txstatus(dev, status);
+	else
+		bcm43xx_dma_handle_txstatus(dev, status);
+}
+
+/* Handle TX status report as received through DMA/PIO queues */
+void bcm43xx_handle_hwtxstatus(struct bcm43xx_wldev *dev,
+			       const struct bcm43xx_hwtxstatus *hw)
+{
+	struct bcm43xx_txstatus status;
+	u8 tmp;
+
+	status.cookie = le16_to_cpu(hw->cookie);
+	status.seq = le16_to_cpu(hw->seq);
+	status.phy_stat = hw->phy_stat;
+	tmp = hw->count;
+	status.frame_count = (tmp >> 4);
+	status.rts_count = (tmp & 0x0F);
+	tmp = hw->flags;
+	status.supp_reason = ((tmp & 0x1C) >> 2);
+	status.pm_indicated = !!(tmp & 0x80);
+	status.intermediate = !!(tmp & 0x40);
+	status.for_ampdu = !!(tmp & 0x20);
+	status.acked = !!(tmp & 0x02);
+
+	bcm43xx_handle_txstatus(dev, &status);
+}
+
+/* Stop any TX operation on the device (suspend the hardware queues) */
+void bcm43xx_tx_suspend(struct bcm43xx_wldev *dev)
+{
+	if (bcm43xx_using_pio(dev))
+		bcm43xx_pio_freeze_txqueues(dev);
+	else
+		bcm43xx_dma_tx_suspend(dev);
+}
+
+/* Resume any TX operation on the device (resume the hardware queues) */
+void bcm43xx_tx_resume(struct bcm43xx_wldev *dev)
+{
+	if (bcm43xx_using_pio(dev))
+		bcm43xx_pio_thaw_txqueues(dev);
+	else
+		bcm43xx_dma_tx_resume(dev);
+}
+
+/* Initialize the QoS parameters */
+void bcm43xx_qos_init(struct bcm43xx_wldev *dev)
+{
+	/* FIXME: This function must probably be called from the mac80211
+	 * config callback. */
+return;
+
+	bcm43xx_hf_write(dev, bcm43xx_hf_read(dev) | BCM43xx_HF_EDCF);
+	/* FIXME kill magic */
+	bcm43xx_write16(dev, 0x688,
+			bcm43xx_read16(dev, 0x688) | 0x4);
+
+
+	/*TODO: We might need some stack support here to get the values. */
 }
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_xmit.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_xmit.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_xmit.h
@@ -19,132 +19,240 @@ _bcm43xx_declare_plcp_hdr(6);
 
 #undef _bcm43xx_declare_plcp_hdr
 
-/* Device specific TX header. To be prepended to TX frames. */
-struct bcm43xx_txhdr {
-	union {
-		struct {
-			__le16 flags;
-			__le16 wsec_rate;
-			__le16 frame_control;
-			u16 unknown_zeroed_0;
-			__le16 control;
-			u8 wep_iv[10];
-			u8 unknown_wsec_tkip_data[3]; //FIXME
-			PAD_BYTES(3);
-			u8 mac1[6];
-			u16 unknown_zeroed_1;
-			struct bcm43xx_plcp_hdr4 rts_cts_fallback_plcp;
-			__le16 rts_cts_dur_fallback;
-			struct bcm43xx_plcp_hdr4 fallback_plcp;
-			__le16 fallback_dur_id;
-			PAD_BYTES(2);
-			__le16 cookie;
-			__le16 unknown_scb_stuff; //FIXME
-			struct bcm43xx_plcp_hdr6 rts_cts_plcp;
-			__le16 rts_cts_frame_control;
-			__le16 rts_cts_dur;
-			u8 rts_cts_mac1[6];
-			u8 rts_cts_mac2[6];
-			PAD_BYTES(2);
-			struct bcm43xx_plcp_hdr6 plcp;
-		} __attribute__((__packed__));
-		u8 raw[82];
-	} __attribute__((__packed__));
-} __attribute__((__packed__));
-
-/* Values/Masks for the device TX header */
-#define BCM43xx_TXHDRFLAG_EXPECTACK		0x0001
-#define BCM43xx_TXHDRFLAG_RTSCTS		0x0002
-#define BCM43xx_TXHDRFLAG_RTS			0x0004
-#define BCM43xx_TXHDRFLAG_FIRSTFRAGMENT		0x0008
-#define BCM43xx_TXHDRFLAG_DESTPSMODE		0x0020
-#define BCM43xx_TXHDRFLAG_RTSCTS_OFDM		0x0080
-#define BCM43xx_TXHDRFLAG_FALLBACKOFDM		0x0100
-#define BCM43xx_TXHDRFLAG_RTSCTSFALLBACK_OFDM	0x0200
-#define BCM43xx_TXHDRFLAG_CTS			0x0400
-#define BCM43xx_TXHDRFLAG_FRAMEBURST		0x0800
-
-#define BCM43xx_TXHDRCTL_OFDM			0x0001
-#define BCM43xx_TXHDRCTL_SHORT_PREAMBLE		0x0010
-#define BCM43xx_TXHDRCTL_ANTENNADIV_MASK	0x0030
-#define BCM43xx_TXHDRCTL_ANTENNADIV_SHIFT	8
-
-#define BCM43xx_TXHDR_RATE_MASK			0x0F00
-#define BCM43xx_TXHDR_RATE_SHIFT		8
-#define BCM43xx_TXHDR_RTSRATE_MASK		0xF000
-#define BCM43xx_TXHDR_RTSRATE_SHIFT		12
-#define BCM43xx_TXHDR_WSEC_KEYINDEX_MASK	0x00F0
-#define BCM43xx_TXHDR_WSEC_KEYINDEX_SHIFT	4
-#define BCM43xx_TXHDR_WSEC_ALGO_MASK		0x0003
-#define BCM43xx_TXHDR_WSEC_ALGO_SHIFT		0
 
-void bcm43xx_generate_txhdr(struct bcm43xx_private *bcm,
-			    struct bcm43xx_txhdr *txhdr,
-			    const unsigned char *fragment_data,
-			    const unsigned int fragment_len,
-			    const int is_first_fragment,
-			    const u16 cookie);
-
-/* RX header as received from the hardware. */
-struct bcm43xx_rxhdr {
-	/* Frame Length. Must be generated explicitely in PIO mode. */
-	__le16 frame_length;
+/* TX header for v3 firmware */
+struct bcm43xx_txhdr_fw3 {
+	__le32 mac_ctl;				/* MAC TX control */
+	__le16 mac_frame_ctl;			/* Copy of the FrameControl field */
+	__le16 tx_fes_time_norm;		/* TX FES Time Normal */
+	__le16 phy_ctl;				/* PHY TX control */
+	__u8 iv[16];				/* Encryption IV */
+	__u8 tx_receiver[6];			/* TX Frame Receiver address */
+	__le16 tx_fes_time_fb;			/* TX FES Time Fallback */
+	struct bcm43xx_plcp_hdr4 rts_plcp_fb;	/* RTS fallback PLCP */
+	__le16 rts_dur_fb;			/* RTS fallback duration */
+	struct bcm43xx_plcp_hdr4 plcp_fb;	/* Fallback PLCP */
+	__le16 dur_fb;				/* Fallback duration */
 	PAD_BYTES(2);
-	/* Flags field 1 */
-	__le16 flags1;
-	u8 rssi;
-	u8 signal_quality;
-	PAD_BYTES(2);
-	/* Flags field 3 */
-	__le16 flags3;
-	/* Flags field 2 */
-	__le16 flags2;
-	/* Lower 16bits of the TSF at the time the frame started. */
-	__le16 mactime;
-	PAD_BYTES(14);
+	__le16 cookie;
+	__le16 unknown_scb_stuff;
+	struct bcm43xx_plcp_hdr6 rts_plcp;	/* RTS PLCP */
+	__u8 rts_frame[18];			/* The RTS frame (if used) */
+	struct bcm43xx_plcp_hdr6 plcp;
 } __attribute__((__packed__));
 
-#define BCM43xx_RXHDR_FLAGS1_OFDM		(1 << 0)
-/*#define BCM43xx_RXHDR_FLAGS1_SIGNAL???	(1 << 3) FIXME */
-#define BCM43xx_RXHDR_FLAGS1_SHORTPREAMBLE	(1 << 7)
-#define BCM43xx_RXHDR_FLAGS1_2053RSSIADJ	(1 << 14)
-
-#define BCM43xx_RXHDR_FLAGS2_INVALIDFRAME	(1 << 0)
-#define BCM43xx_RXHDR_FLAGS2_TYPE2FRAME		(1 << 2)
-/*FIXME: WEP related flags */
+/* MAC TX control */
+#define BCM43xx_TX4_MAC_KEYIDX		0x0FF00000 /* Security key index */
+#define BCM43xx_TX4_MAC_KEYIDX_SHIFT	20
+#define BCM43xx_TX4_MAC_KEYALG		0x00070000 /* Security key algorithm */
+#define BCM43xx_TX4_MAC_KEYALG_SHIFT	16
+#define BCM43xx_TX4_MAC_LIFETIME	0x00001000
+#define BCM43xx_TX4_MAC_FRAMEBURST	0x00000800
+#define BCM43xx_TX4_MAC_SENDCTS		0x00000400
+#define BCM43xx_TX4_MAC_AMPDU		0x00000300
+#define BCM43xx_TX4_MAC_AMPDU_SHIFT	8
+#define BCM43xx_TX4_MAC_CTSFALLBACKOFDM	0x00000200
+#define BCM43xx_TX4_MAC_FALLBACKOFDM	0x00000100
+#define BCM43xx_TX4_MAC_5GHZ		0x00000080
+#define BCM43xx_TX4_MAC_IGNPMQ		0x00000020
+#define BCM43xx_TX4_MAC_HWSEQ		0x00000010 /* Use Hardware Seq No */
+#define BCM43xx_TX4_MAC_STMSDU		0x00000008 /* Start MSDU */
+#define BCM43xx_TX4_MAC_SENDRTS		0x00000004
+#define BCM43xx_TX4_MAC_LONGFRAME	0x00000002
+#define BCM43xx_TX4_MAC_ACK		0x00000001
+
+/* Extra Frame Types */
+#define BCM43xx_TX4_EFT_FBOFDM		0x0001 /* Data frame fb rate type */
+#define BCM43xx_TX4_EFT_RTSOFDM		0x0004 /* RTS/CTS rate type */
+#define BCM43xx_TX4_EFT_RTSFBOFDM	0x0010 /* RTS/CTS fallback rate type */
+
+/* PHY TX control word */
+#define BCM43xx_TX4_PHY_OFDM		0x0001 /* Data frame rate type */
+#define BCM43xx_TX4_PHY_SHORTPRMBL	0x0010 /* Use short preamble */
+#define BCM43xx_TX4_PHY_ANT		0x03C0 /* Antenna selection */
+#define  BCM43xx_TX4_PHY_ANT0		0x0000 /* Use antenna 0 */
+#define  BCM43xx_TX4_PHY_ANT1		0x0100 /* Use antenna 1 */
+#define  BCM43xx_TX4_PHY_ANTLAST	0x0300 /* Use last used antenna */
+
 
-#define BCM43xx_RXHDR_FLAGS3_2050RSSIADJ	(1 << 10)
 
-/* Transmit Status as received from the hardware. */
-struct bcm43xx_hwxmitstatus {
+void bcm43xx_generate_txhdr(struct bcm43xx_wldev *dev,
+			    u8 *txhdr,
+			    const unsigned char *fragment_data,
+			    unsigned int fragment_len,
+			    const struct ieee80211_tx_control *txctl,
+			    u16 cookie);
+
+
+/* Transmit Status */
+struct bcm43xx_txstatus {
+	u16 cookie;		/* The cookie from the txhdr */
+	u16 seq;		/* Sequence number */
+	u8 phy_stat;		/* PHY TX status */
+	u8 frame_count;		/* Frame transmit count */
+	u8 rts_count;		/* RTS transmit count */
+	u8 supp_reason;		/* Suppression reason */
+	/* flags */
+	u8 pm_indicated;	/* PM mode indicated to AP */
+	u8 intermediate;	/* Intermediate status notification */
+	u8 for_ampdu;		/* Status is for an AMPDU (afterburner) */
+	u8 acked;		/* Wireless ACK received */
+};
+
+/* txstatus supp_reason values */
+enum {
+	BCM43xx_TXST_SUPP_NONE,		/* Not suppressed */
+	BCM43xx_TXST_SUPP_PMQ,		/* Suppressed due to PMQ entry */
+	BCM43xx_TXST_SUPP_FLUSH,	/* Suppressed due to flush request */
+	BCM43xx_TXST_SUPP_PREV,		/* Previous fragment failed */
+	BCM43xx_TXST_SUPP_CHAN,		/* Channel mismatch */
+	BCM43xx_TXST_SUPP_LIFE,		/* Lifetime expired */
+	BCM43xx_TXST_SUPP_UNDER,	/* Buffer underflow */
+	BCM43xx_TXST_SUPP_ABNACK,	/* Afterburner NACK */
+};
+
+/* Transmit Status as received through DMA/PIO on old chips */
+struct bcm43xx_hwtxstatus {
 	PAD_BYTES(4);
 	__le16 cookie;
 	u8 flags;
-	u8 cnt1:4,
-	   cnt2:4;
+	u8 count;
 	PAD_BYTES(2);
 	__le16 seq;
-	__le16 unknown; //FIXME
+	u8 phy_stat;
+	PAD_BYTES(1);
 } __attribute__((__packed__));
 
-/* Transmit Status in CPU byteorder. */
-struct bcm43xx_xmitstatus {
-	u16 cookie;
-	u8 flags;
-	u8 cnt1:4,
-	   cnt2:4;
-	u16 seq;
-	u16 unknown; //FIXME
-};
 
-#define BCM43xx_TXSTAT_FLAG_AMPDU	0x10
-#define BCM43xx_TXSTAT_FLAG_INTER	0x20
+/* Receive header for v3 firmware. */
+struct bcm43xx_rxhdr_fw3 {
+	__le16 frame_len;	/* Frame length */
+	PAD_BYTES(2);
+	__le16 phy_status0;	/* PHY RX Status 0 */
+	__u8 jssi;		/* PHY RX Status 1: JSSI */
+	__u8 sig_qual;		/* PHY RX Status 1: Signal Quality */
+	PAD_BYTES(2);		/* PHY RX Status 2 */
+	__le16 phy_status3;	/* PHY RX Status 3 */
+	__le16 mac_status;	/* MAC RX status */
+	__le16 mac_time;
+	__le16 channel;
+} __attribute__((__packed__));
+
+
+/* PHY RX Status 0 */
+#define BCM43xx_RX_PHYST0_GAINCTL	0x4000 /* Gain Control */
+#define BCM43xx_RX_PHYST0_PLCPHCF	0x0200
+#define BCM43xx_RX_PHYST0_PLCPFV	0x0100
+#define BCM43xx_RX_PHYST0_SHORTPRMBL	0x0080 /* Recvd with Short Preamble */
+#define BCM43xx_RX_PHYST0_LCRS		0x0040
+#define BCM43xx_RX_PHYST0_ANT		0x0020 /* Antenna */
+#define BCM43xx_RX_PHYST0_UNSRATE	0x0010
+#define BCM43xx_RX_PHYST0_CLIP		0x000C
+#define BCM43xx_RX_PHYST0_CLIP_SHIFT	2
+#define BCM43xx_RX_PHYST0_FTYPE		0x0003 /* Frame type */
+#define  BCM43xx_RX_PHYST0_CCK		0x0000 /* Frame type: CCK */
+#define  BCM43xx_RX_PHYST0_OFDM		0x0001 /* Frame type: OFDM */
+#define  BCM43xx_RX_PHYST0_PRE_N	0x0002 /* Pre-standard N-PHY frame */
+#define  BCM43xx_RX_PHYST0_STD_N	0x0003 /* Standard N-PHY frame */
+
+/* PHY RX Status 2 */
+#define BCM43xx_RX_PHYST2_LNAG		0xC000 /* LNA Gain */
+#define BCM43xx_RX_PHYST2_LNAG_SHIFT	14
+#define BCM43xx_RX_PHYST2_PNAG		0x3C00 /* PNA Gain */
+#define BCM43xx_RX_PHYST2_PNAG_SHIFT	10
+#define BCM43xx_RX_PHYST2_FOFF		0x03FF /* F offset */
+
+/* PHY RX Status 3 */
+#define BCM43xx_RX_PHYST3_DIGG		0x1800 /* DIG Gain */
+#define BCM43xx_RX_PHYST3_DIGG_SHIFT	11
+#define BCM43xx_RX_PHYST3_TRSTATE	0x0400 /* TR state */
+
+/* MAC RX Status */
+#define BCM43xx_RX_MAC_BEACONSENT	0x00008000 /* Beacon send flag */
+#define BCM43xx_RX_MAC_KEYIDX		0x000007E0 /* Key index */
+#define BCM43xx_RX_MAC_KEYIDX_SHIFT	5
+#define BCM43xx_RX_MAC_DECERR		0x00000010 /* Decrypt error */
+#define BCM43xx_RX_MAC_DEC		0x00000008 /* Decryption attempted */
+#define BCM43xx_RX_MAC_PADDING		0x00000004 /* Pad bytes present */
+#define BCM43xx_RX_MAC_RESP		0x00000002 /* Response frame xmitted */
+#define BCM43xx_RX_MAC_FCSERR		0x00000001 /* FCS error */
+
+/* RX channel */
+#define BCM43xx_RX_CHAN_GAIN		0xFC00 /* Gain */
+#define BCM43xx_RX_CHAN_GAIN_SHIFT	10
+#define BCM43xx_RX_CHAN_ID		0x03FC /* Channel ID */
+#define BCM43xx_RX_CHAN_ID_SHIFT	2
+#define BCM43xx_RX_CHAN_PHYTYPE		0x0003 /* PHY type */
+
+
 
 u8 bcm43xx_plcp_get_ratecode_cck(const u8 bitrate);
 u8 bcm43xx_plcp_get_ratecode_ofdm(const u8 bitrate);
 
-int bcm43xx_rx(struct bcm43xx_private *bcm,
-	       struct sk_buff *skb,
-	       struct bcm43xx_rxhdr *rxhdr);
+void bcm43xx_generate_plcp_hdr(struct bcm43xx_plcp_hdr4 *plcp,
+			       const u16 octets, const u8 bitrate);
+
+void bcm43xx_rx(struct bcm43xx_wldev *dev,
+		struct sk_buff *skb,
+		const void *_rxhdr);
+
+void bcm43xx_handle_txstatus(struct bcm43xx_wldev *dev,
+			     const struct bcm43xx_txstatus *status);
+
+void bcm43xx_handle_hwtxstatus(struct bcm43xx_wldev *dev,
+			       const struct bcm43xx_hwtxstatus *hw);
+
+void bcm43xx_tx_suspend(struct bcm43xx_wldev *dev);
+void bcm43xx_tx_resume(struct bcm43xx_wldev *dev);
+
+
+#define BCM43xx_NR_QOSPARMS		22
+enum {
+	BCM43xx_QOSPARM_TXOP = 0,
+	BCM43xx_QOSPARM_CWMIN,
+	BCM43xx_QOSPARM_CWMAX,
+	BCM43xx_QOSPARM_CWCUR,
+	BCM43xx_QOSPARM_AIFS,
+	BCM43xx_QOSPARM_BSLOTS,
+	BCM43xx_QOSPARM_REGGAP,
+	BCM43xx_QOSPARM_STATUS,
+};
+void bcm43xx_qos_init(struct bcm43xx_wldev *dev);
+
+
+/* Helper functions for converting the key-table index from "firmware-format"
+ * to "raw-format" and back. The firmware API changed for this at some revision.
+ * We need to account for that here. */
+static inline
+int bcm43xx_new_kidx_api(struct bcm43xx_wldev *dev)
+{
+	/* FIXME: Not sure the change was at rev 351 */
+	return (dev->fw.rev >= 351);
+}
+static inline
+u8 bcm43xx_kidx_to_fw(struct bcm43xx_wldev *dev, u8 raw_kidx)
+{
+	u8 firmware_kidx;
+	if (bcm43xx_new_kidx_api(dev)) {
+		firmware_kidx = raw_kidx;
+	} else {
+		if (raw_kidx >= 4) /* Is per STA key? */
+			firmware_kidx = raw_kidx - 4;
+		else
+			firmware_kidx = raw_kidx; /* TX default key */
+	}
+	return firmware_kidx;
+}
+static inline
+u8 bcm43xx_kidx_to_raw(struct bcm43xx_wldev *dev, u8 firmware_kidx)
+{
+	u8 raw_kidx;
+	if (bcm43xx_new_kidx_api(dev))
+		raw_kidx = firmware_kidx;
+	else
+		/* RX default keys or per STA keys */
+		raw_kidx = firmware_kidx + 4;
+	return raw_kidx;
+}
 
 #endif /* BCM43xx_XMIT_H_ */


From mb at bu3sch.de  Thu Aug  2 18:05:16 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 2 Aug 2007 18:05:16 +0200
Subject: [RFC V3] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
In-Reply-To: <46b1fa6d.d4l4DujAaAR2ORZf%Larry.Finger@lwfinger.net>
References: <46b1fa6d.d4l4DujAaAR2ORZf%Larry.Finger@lwfinger.net>
Message-ID: <200708021805.17004.mb@bu3sch.de>

On Thursday 02 August 2007, Larry Finger wrote:
> Michael,
> 
> I couldn't find any long/short indication in the header, so I added a bool that
> is set when the frame is sent.

This is not going to work.

But we can do this differently.
You can do something like:

if (!status->acked && !tx_control->noack)
	excessive_retries = 1;

So we don't need to care about the retry count.

Anyway. I don't know why we need excessive_retries _at_ _all_.
The rc algorithm does already know if the frame succeed or failed
anyway.

/me shrugs

> Larry
> ---
> 
> In bcm43xx-mac80211, the mechanism for decreasing the transmit rate cannot
> be triggered. This may be shown by walking away from the AP with a laptop.
> At some distance, communications will be lost and never recovered because
> the rate decreasing mechanism of rc80211_simple needs to see excessive_retries
> set in the ieee80211_tx_status struct. With this patch, the transmit rate
> will decrease until communications restart.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> @@ -1311,6 +1311,16 @@ void bcm43xx_dma_handle_txstatus(struct 
>  			 */
>  			if (status->acked)
>  				meta->txstat.flags |= IEEE80211_TX_STATUS_ACK;
> +			else
> +				if (dev->last_frame_long) {
> +					if (status->frame_count >=
> +					    dev->long_retry_limit)
> +						meta->txstat.excessive_retries = 1;
> +				} else {
> +					if (status->frame_count >=
> +					    dev->short_retry_limit)
> +						meta->txstat.excessive_retries = 1;
> +				}
>  			meta->txstat.retry_count = status->frame_count - 1;
>  			ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb, &(meta->txstat));
>  			/* skb is freed by ieee80211_tx_status_irqsafe() */
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> @@ -707,6 +707,9 @@ struct bcm43xx_wldev {
>  	bool short_preamble;		/* TRUE, if short preamble is enabled. */
>  	bool short_slot;		/* TRUE, if short slot timing is enabled. */
>  	bool radio_hw_enable;		/* saved state of radio hardware enabled state */
> +	bool last_frame_long;		/* true is last frame was long */
> +	u8 short_retry_limit;
> +	u8 long_retry_limit;
>  
>  	/* PHY/Radio device. */
>  	struct bcm43xx_phy phy;
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -3333,10 +3333,12 @@ static int bcm43xx_wireless_core_init(st
>  	tmp = limit_value(modparam_short_retry, 0, 0xF);
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
>  			    BCM43xx_SHM_SC_SRLIMIT, tmp);
> +	dev->short_retry_limit = tmp;
>  	tmp = limit_value(modparam_long_retry, 0, 0xF);
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SCRATCH,
>  			    BCM43xx_SHM_SC_LRLIMIT, tmp);
>  
> +	dev->long_retry_limit = tmp;
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
>  			    BCM43xx_SHM_SH_SFFBLIM, 3);
>  	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> @@ -264,6 +264,7 @@ static void generate_txhdr_fw4(struct bc
>  	 * is a 5Ghz packet.
>  	 */
>  	txhdr->chan_radio_code = phy->channel;
> +	dev->last_frame_long = 0;
>  
>  	/* PHY TX Control word */
>  	if (rate_ofdm)
> @@ -336,6 +337,7 @@ static void generate_txhdr_fw4(struct bc
>  		if (rts_rate_fb_ofdm)
>  			extra_ft |= BCM43xx_TX4_EFT_RTSFBOFDM;
>  		mac_ctl |= BCM43xx_TX4_MAC_LONGFRAME;
> +		dev->last_frame_long = 1;
>  	}
>  
>  	/* Magic cookie */
> 
> 




From mb at bu3sch.de  Thu Aug  2 18:07:20 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 2 Aug 2007 18:07:20 +0200
Subject: [RFC 0/10] Port of bcm43xx from softmac to mac80211
In-Reply-To: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
Message-ID: <200708021807.20649.mb@bu3sch.de>

On Thursday 02 August 2007, Larry Finger wrote:
> Driver bcm43xx is being ported from using SoftMAC to mac80211. For rewiew,
> this series of patches is being prepared; however, the final patch will be
> a single entity so that compilation during bisection will not break.
> 
> The contents of the various pieces are as follows:
> 
>  1. Kconfig, Makefile and the main header file.
>  2. bcm43xx_debugfs.c and bcm43xx_debugfs.h
>  3. bcm43xx_dma.c and bcm43xx_dma.h
>  4. bcm43xx_ilt.c, bcm43xx_ilt.h, bcm43xx_leds.c and bcm43xx_leds.h
>  5. bcm43xx_main.c and bcm43xx_main.h
>  6. bcm43xx_phy.c and bcm43xx_phy.h
>  7. bcm43xx_pio.c and bcm43xx_pio.h
>  8. bcm43xx_radio.c and bcm43xx_radio.h
>  9. bcm43xx_sysfs.c and bcm43xx_sysfs.h
> 10: bcm43xx_xmit.c and bcm43xx_xmit.h
> 
> In general, this port consists of taking the files bcm43xx_phy and 
> bcm43xx_radio from the softmac driver and converting them to work with
> the files from the mac80211 version, which has been back-converted to 
> use V3 firmware.

I don't really want to review 10 huge patches that replace
X by Y. If the code works, fine. Go for it. You get my ACK, if it works
on the hardware where it matters. ;)



From mb at bu3sch.de  Thu Aug  2 18:18:57 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 2 Aug 2007 18:18:57 +0200
Subject: [PATCH] Merge the Sonics Silicon Backplane subsystem
In-Reply-To: <Pine.LNX.4.64.0708021812260.5150@anakin>
References: <200707271857.24162.mb@bu3sch.de> <200708021624.59701.mb@bu3sch.de>
	<Pine.LNX.4.64.0708021812260.5150@anakin>
Message-ID: <200708021818.58319.mb@bu3sch.de>

On Thursday 02 August 2007, Geert Uytterhoeven wrote:
> On Thu, 2 Aug 2007, Michael Buesch wrote:
> > On Thursday 02 August 2007, Geert Uytterhoeven wrote:
> > > On Fri, 27 Jul 2007, Michael Buesch wrote:
> > > > The Sonics Silicon Backplane is a mini-bus used on
> > > > various Broadcom chips and embedded devices.
> > > > Devices using the SSB include b44, bcm43xx and various
> > > > Broadcom based wireless routers.
> > > > A b44 and bcm43xx port and a SSB based OHCI driver is available.
> > > 
> > > > --- a/drivers/Kconfig
> > > > +++ b/drivers/Kconfig
> > > > @@ -58,6 +58,8 @@ source "drivers/power/Kconfig"
> > > >  
> > > >  source "drivers/hwmon/Kconfig"
> > > >  
> > > > +source "drivers/ssb/Kconfig"
> > > > +
> > > >  source "drivers/mfd/Kconfig"
> > > >  
> > > >  source "drivers/media/Kconfig"
> > > 
> > > > --- /dev/null
> > > > +++ b/drivers/ssb/Kconfig
> > > > @@ -0,0 +1,92 @@
> > > > +menu "Sonics Silicon Backplane"
> > > > +
> > > > +config SSB
> > > > +	tristate "Sonics Silicon Backplane support"
> > > > +	depends on EXPERIMENTAL
> > > 
> > > Hence this will show up on all platforms?
> > 
> > So?
> 
> Shouldn't you add a dependency for platforms where it make sense to have SSB?

Well, that's everything where you can stick a PCI, PCMCIA, PC-Card or CF-Card
into, plus the MIPS platform, where we have the embedded SSB.
That's basically everything, no? Except these strange !HAS_IOMEM platforms,
which we already take care of in a followup patch.


From larry.finger at lwfinger.net  Thu Aug  2 18:30:13 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 11:30:13 -0500
Subject: [RFC 0/10] Port of bcm43xx from softmac to mac80211
In-Reply-To: <200708021807.20649.mb@bu3sch.de>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<200708021807.20649.mb@bu3sch.de>
Message-ID: <46B20695.2080100@lwfinger.net>

Michael Buesch wrote:
> On Thursday 02 August 2007, Larry Finger wrote:
>> Driver bcm43xx is being ported from using SoftMAC to mac80211. For rewiew,
>> this series of patches is being prepared; however, the final patch will be
>> a single entity so that compilation during bisection will not break.
>>
>> The contents of the various pieces are as follows:
>>
>>  1. Kconfig, Makefile and the main header file.
>>  2. bcm43xx_debugfs.c and bcm43xx_debugfs.h
>>  3. bcm43xx_dma.c and bcm43xx_dma.h
>>  4. bcm43xx_ilt.c, bcm43xx_ilt.h, bcm43xx_leds.c and bcm43xx_leds.h
>>  5. bcm43xx_main.c and bcm43xx_main.h
>>  6. bcm43xx_phy.c and bcm43xx_phy.h
>>  7. bcm43xx_pio.c and bcm43xx_pio.h
>>  8. bcm43xx_radio.c and bcm43xx_radio.h
>>  9. bcm43xx_sysfs.c and bcm43xx_sysfs.h
>> 10: bcm43xx_xmit.c and bcm43xx_xmit.h
>>
>> In general, this port consists of taking the files bcm43xx_phy and 
>> bcm43xx_radio from the softmac driver and converting them to work with
>> the files from the mac80211 version, which has been back-converted to 
>> use V3 firmware.
> 
> I don't really want to review 10 huge patches that replace
> X by Y. If the code works, fine. Go for it. You get my ACK, if it works
> on the hardware where it matters. ;)

I was hoping this would be your response, but I had to make the effort. I'll wait for a couple of 
days to see if anyone else has any comments and send it on to Linville and hope it ends up in -mm 
fairly soon. It _DOES_ work on the hardware.

Larry


From larry.finger at lwfinger.net  Thu Aug  2 18:33:36 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 11:33:36 -0500
Subject: [RFC V3] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
In-Reply-To: <200708021805.17004.mb@bu3sch.de>
References: <46b1fa6d.d4l4DujAaAR2ORZf%Larry.Finger@lwfinger.net>
	<200708021805.17004.mb@bu3sch.de>
Message-ID: <46B20760.5000406@lwfinger.net>

Michael Buesch wrote:
> On Thursday 02 August 2007, Larry Finger wrote:
>> Michael,
>>
>> I couldn't find any long/short indication in the header, so I added a bool that
>> is set when the frame is sent.
> 
> This is not going to work.
> 
> But we can do this differently.
> You can do something like:
> 
> if (!status->acked && !tx_control->noack)
> 	excessive_retries = 1;
> 
> So we don't need to care about the retry count.
> 
> Anyway. I don't know why we need excessive_retries _at_ _all_.
> The rc algorithm does already know if the frame succeed or failed
> anyway.

Yes, it does, but it only looks at the potential for reduction if excessive retries is set. Why? 
Because it was coded that way! As I said earlier, I don't want to get involved there.

I'll try to implement it as above.

Larry



From mouw at nl.linux.org  Thu Aug  2 18:45:48 2007
From: mouw at nl.linux.org (Erik Mouw)
Date: Thu, 2 Aug 2007 18:45:48 +0200
Subject: [RFC 0/10] Port of bcm43xx from softmac to mac80211
In-Reply-To: <200708021807.20649.mb@bu3sch.de>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<200708021807.20649.mb@bu3sch.de>
Message-ID: <20070802164548.GF13704@gateway.home>

On Thu, Aug 02, 2007 at 06:07:20PM +0200, Michael Buesch wrote:
> On Thursday 02 August 2007, Larry Finger wrote:
> > Driver bcm43xx is being ported from using SoftMAC to mac80211. For rewiew,
> > this series of patches is being prepared; however, the final patch will be
> > a single entity so that compilation during bisection will not break.

[...]

> I don't really want to review 10 huge patches that replace
> X by Y. If the code works, fine. Go for it. You get my ACK, if it works
> on the hardware where it matters. ;)

It might be a good idea to have two drivers for the same hardware so
it's easier to figure out if something broke or not. My linksys bcm4318
cardbus card works nice with 2.6.22 and I wouldn't like to lose that
functionality.


Just my 0.02 EUR,

Erik

-- 
They're all fools. Don't worry. Darwin may be slow, but he'll
eventually get them. -- Matthew Lammers in alt.sysadmin.recovery
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070802/489b93d1/attachment.pgp>

From larry.finger at lwfinger.net  Thu Aug  2 19:25:55 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 12:25:55 -0500
Subject: [RFC 0/10] Port of bcm43xx from softmac to mac80211
In-Reply-To: <20070802164548.GF13704@gateway.home>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<200708021807.20649.mb@bu3sch.de>
	<20070802164548.GF13704@gateway.home>
Message-ID: <46B213A3.1040700@lwfinger.net>

Erik Mouw wrote:
> On Thu, Aug 02, 2007 at 06:07:20PM +0200, Michael Buesch wrote:
>> On Thursday 02 August 2007, Larry Finger wrote:
>>> Driver bcm43xx is being ported from using SoftMAC to mac80211. For rewiew,
>>> this series of patches is being prepared; however, the final patch will be
>>> a single entity so that compilation during bisection will not break.
> 
> [...]
> 
>> I don't really want to review 10 huge patches that replace
>> X by Y. If the code works, fine. Go for it. You get my ACK, if it works
>> on the hardware where it matters. ;)
> 
> It might be a good idea to have two drivers for the same hardware so
> it's easier to figure out if something broke or not. My linksys bcm4318
> cardbus card works nice with 2.6.22 and I wouldn't like to lose that
> functionality.
> 
> 
> Just my 0.02 EUR,

It turns out that the new port works as well as the current driver, has the ability to adjust the 
transmit rate depending on conditions, and is free of the locking bugs of SoftMAC. There are, of 
course, bugs in mac80211, but at least they will be fixed. There is very little maintenance on SoftMAC.

There will still be 2 drivers as Michael's version with V4 firmware will still be in the development 
tree, and it will be merged to mainstream when ready. As his version will not support 802.11b-only 
devices (no support in that firmware), this port will then be gutted of 802.11g devices. I can 
assure you that this will not happen until the V4 driver functions at least as well as bcm43xx does now.

Larry


From zajec5polish at gmail.com  Thu Aug  2 21:25:10 2007
From: zajec5polish at gmail.com (=?UTF-8?Q?Rafa=C5=82_Mi=C5=82ecki?=)
Date: Thu, 2 Aug 2007 21:25:10 +0200
Subject: PCI Interrupt 0000:06:05.0[A] -> GSI 21 (level, low) -> IRQ 21
Message-ID: <14b026160708021225k33b65ady1dcc8ab4513aec36@mail.gmail.com>

After hours of being connected, I was disconnected and was not able to
connect again. I was getting
> Interface doesn't support scanning : No such device

I use openSUSE 10.2 + additional kernel 2.6.22.1. Broadcom 4318.

Someone able to fix this?

-- 
Rafa? Mi?ecki
-------------- next part --------------
A non-text attachment was scrubbed...
Name: zajec.bcm43xx.log
Type: application/octet-stream
Size: 1577 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070802/26e8f19e/attachment.obj>

From larry.finger at lwfinger.net  Thu Aug  2 21:44:34 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 14:44:34 -0500
Subject: [RFC V3] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
In-Reply-To: <200708021805.17004.mb@bu3sch.de>
References: <46b1fa6d.d4l4DujAaAR2ORZf%Larry.Finger@lwfinger.net>
	<200708021805.17004.mb@bu3sch.de>
Message-ID: <46B23422.3050207@lwfinger.net>

Michael Buesch wrote:
> On Thursday 02 August 2007, Larry Finger wrote:
>> Michael,
>>
>> I couldn't find any long/short indication in the header, so I added a bool that
>> is set when the frame is sent.
> 
> This is not going to work.
> 
> But we can do this differently.
> You can do something like:
> 
> if (!status->acked && !tx_control->noack)
> 	excessive_retries = 1;
> 
> So we don't need to care about the retry count.
> 
> Anyway. I don't know why we need excessive_retries _at_ _all_.
> The rc algorithm does already know if the frame succeed or failed
> anyway.

Is this what you had in mind?

Larry


@@ -1311,6 +1311,9 @@ void bcm43xx_dma_handle_txstatus(struct
                          */
                         if (status->acked)
                                 meta->txstat.flags |= IEEE80211_TX_STATUS_ACK;
+                       else
+                               if (!(meta->txstat.flags & IEEE80211_TXCTL_NO_ACK))
+                                       meta->txstat.excessive_retries = 1;
                         meta->txstat.retry_count = status->frame_count - 1;
                         ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb, &(meta->txstat));
                         /* skb is freed by ieee80211_tx_status_irqsafe() */


From larry.finger at lwfinger.net  Thu Aug  2 21:50:38 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 14:50:38 -0500
Subject: PCI Interrupt 0000:06:05.0[A] -> GSI 21 (level, low) -> IRQ 21
In-Reply-To: <14b026160708021225k33b65ady1dcc8ab4513aec36@mail.gmail.com>
References: <14b026160708021225k33b65ady1dcc8ab4513aec36@mail.gmail.com>
Message-ID: <46B2358E.7040505@lwfinger.net>

Rafa? Mi?ecki wrote:
> After hours of being connected, I was disconnected and was not able to
> connect again. I was getting
>> Interface doesn't support scanning : No such device
> 
> I use openSUSE 10.2 + additional kernel 2.6.22.1. Broadcom 4318.
> 
> Someone able to fix this?

There isn't enough information to tell what happened, but it looks as if NetworkManager didn't bring 
the interface up. Sometimes the softmac version gets in a condition where NM tries and then 
immediately shuts down again. Sometimes a 'modprobe -rv bcm43xx' followed by a 'modprobe -v bcm43xx' 
will restore it. Sometimes it takes a reboot.

I can tell this situation on my 4311 because the LED is off.

Larry


From mb at bu3sch.de  Thu Aug  2 21:59:44 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 2 Aug 2007 21:59:44 +0200
Subject: [RFC V3] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
In-Reply-To: <46B23422.3050207@lwfinger.net>
References: <46b1fa6d.d4l4DujAaAR2ORZf%Larry.Finger@lwfinger.net>
	<200708021805.17004.mb@bu3sch.de> <46B23422.3050207@lwfinger.net>
Message-ID: <200708022159.44422.mb@bu3sch.de>

On Thursday 02 August 2007, Larry Finger wrote:
> Michael Buesch wrote:
> > On Thursday 02 August 2007, Larry Finger wrote:
> >> Michael,
> >>
> >> I couldn't find any long/short indication in the header, so I added a bool that
> >> is set when the frame is sent.
> > 
> > This is not going to work.
> > 
> > But we can do this differently.
> > You can do something like:
> > 
> > if (!status->acked && !tx_control->noack)
> > 	excessive_retries = 1;
> > 
> > So we don't need to care about the retry count.
> > 
> > Anyway. I don't know why we need excessive_retries _at_ _all_.
> > The rc algorithm does already know if the frame succeed or failed
> > anyway.
> 
> Is this what you had in mind?
> 
> Larry
> 
> 
> @@ -1311,6 +1311,9 @@ void bcm43xx_dma_handle_txstatus(struct
>                           */
>                          if (status->acked)
>                                  meta->txstat.flags |= IEEE80211_TX_STATUS_ACK;
> +                       else
> +                               if (!(meta->txstat.flags & IEEE80211_TXCTL_NO_ACK))
> +                                       meta->txstat.excessive_retries = 1;
>                          meta->txstat.retry_count = status->frame_count - 1;
>                          ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb, &(meta->txstat));
>                          /* skb is freed by ieee80211_tx_status_irqsafe() */


Yeah, looks good. If you correctly diff that up, I'll queue it up for
the next submission to John.


From mb at bu3sch.de  Thu Aug  2 22:47:30 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 2 Aug 2007 22:47:30 +0200
Subject: I will switch to quilt based development
Message-ID: <200708022247.30838.mb@bu3sch.de>

Hey guys,

I will drop my git tree and switch to much more
lightweight quilt based workflow.
My latest patchsets will be published at

http://bu3sch.de/patches/wireless-dev/

My scripts do upload the plain patchfiles (plus quilt series file)
and additionally a .tar.bz2 file.

Upstream submissions will be made by patchbombing John.

The advantage of all this is _much_ more lightweight
development. A lot more flexible workflow. And more
review for patch submissions.

If you have any suggestions or improvements, please tell me.

--mb


From Larry.Finger at lwfinger.net  Thu Aug  2 22:48:04 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 15:48:04 -0500
Subject: [PATCH] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
Message-ID: <46b24304.DLuGdus4YPRFspUn%Larry.Finger@lwfinger.net>

In bcm43xx-mac80211, the mechanism for decreasing the transmit rate cannot
be triggered. This may be shown by walking away from the AP with a laptop.
At some distance, communications will be lost and never recovered because
the rate decreasing mechanism of rc80211_simple needs to see excessive_retries
set in the ieee80211_tx_status struct. With this patch, the transmit rate
will decrease until communications restart.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John and Michael,

This is based on the wireless-dev tree.

Larry

 bcm43xx_dma.c |    3 +++
 1 file changed, 3 insertions(+)

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
@@ -1311,6 +1311,9 @@ void bcm43xx_dma_handle_txstatus(struct 
 			 */
 			if (status->acked)
 				meta->txstat.flags |= IEEE80211_TX_STATUS_ACK;
+			else
+				if (!(meta->txstat.flags & IEEE80211_TXCTL_NO_ACK))
+					meta->txstat.excessive_retries = 1;
 			meta->txstat.retry_count = status->frame_count - 1;
 			ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb, &(meta->txstat));
 			/* skb is freed by ieee80211_tx_status_irqsafe() */


From dwmw2 at infradead.org  Thu Aug  2 23:04:38 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Thu, 02 Aug 2007 22:04:38 +0100
Subject: [RFC 0/10] Port of bcm43xx from softmac to mac80211
In-Reply-To: <46B20695.2080100@lwfinger.net>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<200708021807.20649.mb@bu3sch.de>  <46B20695.2080100@lwfinger.net>
Message-ID: <1186088678.2931.10.camel@pmac.infradead.org>

On Thu, 2007-08-02 at 11:30 -0500, Larry Finger wrote:
> I was hoping this would be your response, but I had to make the
> effort. I'll wait for a couple of days to see if anyone else has any
> comments and send it on to Linville and hope it ends up in -mm  fairly
> soon. It _DOES_ work on the hardware.

My experience is that mac80211 is broken w.r.t IPv6 -- it receives its
own packets. It would be suboptimal for me if the softmac version of
bcm43xx were to go away before that got fixed.

-- 
dwmw2



From mb at bu3sch.de  Thu Aug  2 23:06:33 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 2 Aug 2007 23:06:33 +0200
Subject: [RFC 0/10] Port of bcm43xx from softmac to mac80211
In-Reply-To: <1186088678.2931.10.camel@pmac.infradead.org>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<46B20695.2080100@lwfinger.net>
	<1186088678.2931.10.camel@pmac.infradead.org>
Message-ID: <200708022306.34139.mb@bu3sch.de>

On Thursday 02 August 2007, David Woodhouse wrote:
> On Thu, 2007-08-02 at 11:30 -0500, Larry Finger wrote:
> > I was hoping this would be your response, but I had to make the
> > effort. I'll wait for a couple of days to see if anyone else has any
> > comments and send it on to Linville and hope it ends up in -mm  fairly
> > soon. It _DOES_ work on the hardware.
> 
> My experience is that mac80211 is broken w.r.t IPv6 -- it receives its
> own packets. It would be suboptimal for me if the softmac version of
> bcm43xx were to go away before that got fixed.
> 

We don't go _away_ from anything until there's no regression anymore.
This is a patchset which adds a driver. It does not remove something.



From mistamaila at gmail.com  Thu Aug  2 23:19:08 2007
From: mistamaila at gmail.com (John H.)
Date: Fri, 3 Aug 2007 00:19:08 +0300
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46B1F80E.2090301@lwfinger.net>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B14274.70108@lwfinger.net>
	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>
	<46B1F80E.2090301@lwfinger.net>
Message-ID: <5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>

I did what you suggested and just bcm43xx is loaded, but it does
nothing.  It creates no wireless interface.

dmesg
ieee80211_crypt: registered algorithm 'NULL'
ieee80211: 802.11 data/management/control stack, git-1.1.13
ieee80211: Copyright (C) 2004-2005 Intel Corporation
<jketreno at linux.intel.com>
bcm43xx driver
lsmod |grep bcm
bcm43xx               420705  0
ieee80211softmac       35265  1 bcm43xx
ieee80211              35593  2 bcm43xx,ieee80211softmac


You said that I could compile my own kernel to fix the bitrate issue
with bcm43xx-mac80211.  Is that to say as of kernel 2.6.23 or so the
bitrate issue will be fixed?

On 8/2/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > I cannot find the site of which you speak.
> >
> > I can't seem to get it to let me use only bcm43xx and not bcm43xx-mac80211.
> >
> > Also, which firmware here is v3?
>
> If you run this script by John Linville, your system will use bcm43xx. It will also download and
> install the V3 firmware.
>
> Larry
>
>
> =================================================
> #!/bin/sh
>
> BCM43XX_V3_FW="http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o"
>
> wget $BCM43XX_V3_FW
>
> bcm43xx-fwcutter -w /lib/firmware -p .v3 wl_apsta-3.130.20.0.o
> echo 'blacklist bcm43xx-mac80211' >> /etc/modprobe.d/blacklist
> echo 'options bcm43xx fwpostfix=.v3' >> /etc/modprobe.conf
>
> modprobe -r bcm43xx-mac80211 # remove the new driver
>
> echo 'modprobe bcm43xx' >> /etc/rc.local
>
> BCM43XX_PCI_ID=`lspci -n | awk '$2 ~ "^0280" && $3 ~ "^14e4:43" { print $3 }' | sed -e 's/:/ /'`
> echo 'echo "'$BCM43XX_PCI_ID'" > /sys/bus/pci/drivers/bcm43xx/new_id' \
>          >> /etc/rc.local
>
> /etc/rc.local
>
> ==============================
>
>
>


From larry.finger at lwfinger.net  Thu Aug  2 23:29:47 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 16:29:47 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>	<46B14274.70108@lwfinger.net>	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>	<46B1F80E.2090301@lwfinger.net>
	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>
Message-ID: <46B24CCB.7010609@lwfinger.net>

John H. wrote:
> I did what you suggested and just bcm43xx is loaded, but it does
> nothing.  It creates no wireless interface.
> 
> dmesg
> ieee80211_crypt: registered algorithm 'NULL'
> ieee80211: 802.11 data/management/control stack, git-1.1.13
> ieee80211: Copyright (C) 2004-2005 Intel Corporation
> <jketreno at linux.intel.com>
> bcm43xx driver
> lsmod |grep bcm
> bcm43xx               420705  0
> ieee80211softmac       35265  1 bcm43xx
> ieee80211              35593  2 bcm43xx,ieee80211softmac
> 
> 
> You said that I could compile my own kernel to fix the bitrate issue
> with bcm43xx-mac80211.  Is that to say as of kernel 2.6.23 or so the
> bitrate issue will be fixed?

It works with 2.6.22 or later.

What does 'dmesg | grep bcm43xx' show? I would also like to see the output of 'iwconfig' and 'ifconfig'.

Larry


From larry.finger at lwfinger.net  Thu Aug  2 23:31:57 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 16:31:57 -0500
Subject: [RFC 0/10] Port of bcm43xx from softmac to mac80211
In-Reply-To: <1186088678.2931.10.camel@pmac.infradead.org>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>	
	<200708021807.20649.mb@bu3sch.de> <46B20695.2080100@lwfinger.net>
	<1186088678.2931.10.camel@pmac.infradead.org>
Message-ID: <46B24D4D.5020904@lwfinger.net>

David Woodhouse wrote:
> On Thu, 2007-08-02 at 11:30 -0500, Larry Finger wrote:
>> I was hoping this would be your response, but I had to make the
>> effort. I'll wait for a couple of days to see if anyone else has any
>> comments and send it on to Linville and hope it ends up in -mm  fairly
>> soon. It _DOES_ work on the hardware.
> 
> My experience is that mac80211 is broken w.r.t IPv6 -- it receives its
> own packets. It would be suboptimal for me if the softmac version of
> bcm43xx were to go away before that got fixed.
> 

This will go into -mm. I hope that it gets plenty of testing, in fact, I hope you grab the patch set 
and make a trial of your own. If this driver is broken with IPv6, I want to know.

Larry



From mistamaila at gmail.com  Thu Aug  2 23:33:34 2007
From: mistamaila at gmail.com (John H.)
Date: Fri, 3 Aug 2007 00:33:34 +0300
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46B24CCB.7010609@lwfinger.net>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B14274.70108@lwfinger.net>
	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>
	<46B1F80E.2090301@lwfinger.net>
	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>
	<46B24CCB.7010609@lwfinger.net>
Message-ID: <5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>

I will send that in the next email.

I am confused.   I am using 2.6.22.  Are you saying bcm43xx-mac80211
should not be bitrate limited then?

 uname -a
Linux laptop 2.6.22.1-41.fc7 #1 SMP Fri Jul 27 18:10:34 EDT 2007 i686
i686 i386 GNU/Linux


On 8/3/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > I did what you suggested and just bcm43xx is loaded, but it does
> > nothing.  It creates no wireless interface.
> >
> > dmesg
> > ieee80211_crypt: registered algorithm 'NULL'
> > ieee80211: 802.11 data/management/control stack, git-1.1.13
> > ieee80211: Copyright (C) 2004-2005 Intel Corporation
> > <jketreno at linux.intel.com>
> > bcm43xx driver
> > lsmod |grep bcm
> > bcm43xx               420705  0
> > ieee80211softmac       35265  1 bcm43xx
> > ieee80211              35593  2 bcm43xx,ieee80211softmac
> >
> >
> > You said that I could compile my own kernel to fix the bitrate issue
> > with bcm43xx-mac80211.  Is that to say as of kernel 2.6.23 or so the
> > bitrate issue will be fixed?
>
> It works with 2.6.22 or later.
>
> What does 'dmesg | grep bcm43xx' show? I would also like to see the output of 'iwconfig' and 'ifconfig'.
>
> Larry
>


From mistamaila at gmail.com  Thu Aug  2 23:37:50 2007
From: mistamaila at gmail.com (John H.)
Date: Fri, 3 Aug 2007 00:37:50 +0300
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46B24CCB.7010609@lwfinger.net>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B14274.70108@lwfinger.net>
	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>
	<46B1F80E.2090301@lwfinger.net>
	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>
	<46B24CCB.7010609@lwfinger.net>
Message-ID: <5b9417770708021437n48e29590q7ea48b55df2313f3@mail.gmail.com>

bcm43xx driver


iwconfig says no wireless device, and ifconfig, even with ifconfig -a,
shows no wlan0.

On 8/3/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > I did what you suggested and just bcm43xx is loaded, but it does
> > nothing.  It creates no wireless interface.
> >
> > dmesg
> > ieee80211_crypt: registered algorithm 'NULL'
> > ieee80211: 802.11 data/management/control stack, git-1.1.13
> > ieee80211: Copyright (C) 2004-2005 Intel Corporation
> > <jketreno at linux.intel.com>
> > bcm43xx driver
> > lsmod |grep bcm
> > bcm43xx               420705  0
> > ieee80211softmac       35265  1 bcm43xx
> > ieee80211              35593  2 bcm43xx,ieee80211softmac
> >
> >
> > You said that I could compile my own kernel to fix the bitrate issue
> > with bcm43xx-mac80211.  Is that to say as of kernel 2.6.23 or so the
> > bitrate issue will be fixed?
>
> It works with 2.6.22 or later.
>
> What does 'dmesg | grep bcm43xx' show? I would also like to see the output of 'iwconfig' and 'ifconfig'.
>
> Larry
>


From larry.finger at lwfinger.net  Thu Aug  2 23:42:18 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 02 Aug 2007 16:42:18 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>	
	<46B14274.70108@lwfinger.net>	
	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>	
	<46B1F80E.2090301@lwfinger.net>	
	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>	
	<46B24CCB.7010609@lwfinger.net>
	<5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>
Message-ID: <46B24FBA.3030205@lwfinger.net>

John H. wrote:
> I will send that in the next email.
> 
> I am confused.   I am using 2.6.22.  Are you saying bcm43xx-mac80211
> should not be bitrate limited then?
> 
>  uname -a
> Linux laptop 2.6.22.1-41.fc7 #1 SMP Fri Jul 27 18:10:34 EDT 2007 i686
> i686 i386 GNU/Linux

No -bcm43xx-mac80211 does not work very well at the moment. If you had a real 2.6.22 distribution, 
it would work. What Fedora did was strip out the PCI ID's from bcm43xx for all the 
802.11g-compatible devices and force you to use bcm43xx-mac80211. If you get a new copy of the 
source, configure it for softmac and bcm43xx, it will work.

The script I sent you should have blacklisted bcm43xx-mac80211 and installed the PCI ID for your 
device. It seems that it didn't work.

Larry




From mistamaila at gmail.com  Thu Aug  2 23:47:13 2007
From: mistamaila at gmail.com (John H.)
Date: Fri, 3 Aug 2007 00:47:13 +0300
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46B24FBA.3030205@lwfinger.net>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B14274.70108@lwfinger.net>
	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>
	<46B1F80E.2090301@lwfinger.net>
	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>
	<46B24CCB.7010609@lwfinger.net>
	<5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>
	<46B24FBA.3030205@lwfinger.net>
Message-ID: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>

It blacklisted bcm43xx-mac80211 but it still loads anyway, and so does
ndiswrapper, despite being blacklisted.
so i renamed bcm43xx-mac80211.ko to bcm43xx-mac80211.bak and did the
same for ndiswrapper and pasted what I got as a result on boot.
Basically no wireless with just bcm43xx and softmac modules.

On 8/3/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > I will send that in the next email.
> >
> > I am confused.   I am using 2.6.22.  Are you saying bcm43xx-mac80211
> > should not be bitrate limited then?
> >
> >  uname -a
> > Linux laptop 2.6.22.1-41.fc7 #1 SMP Fri Jul 27 18:10:34 EDT 2007 i686
> > i686 i386 GNU/Linux
>
> No -bcm43xx-mac80211 does not work very well at the moment. If you had a real 2.6.22 distribution,
> it would work. What Fedora did was strip out the PCI ID's from bcm43xx for all the
> 802.11g-compatible devices and force you to use bcm43xx-mac80211. If you get a new copy of the
> source, configure it for softmac and bcm43xx, it will work.
>
> The script I sent you should have blacklisted bcm43xx-mac80211 and installed the PCI ID for your
> device. It seems that it didn't work.
>
> Larry
>
>
>


From richie at coderworld.net  Thu Aug  2 23:57:14 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Thu, 2 Aug 2007 23:57:14 +0200
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <46B0AF8C.4090608@lwfinger.net>
References: <46AB5B9F.7030601@lwfinger.net>
	<200708010118.46200.richie@coderworld.net>
	<46B0AF8C.4090608@lwfinger.net>
Message-ID: <200708022357.14486.richie@coderworld.net>

On Wednesday 01 August 2007 18:06:36 you wrote:
> I think there are two problems with the driver when walking away from the
> AP. The first is that the driver has not been telling mac80211 that it is
> time to consider cutting the transfer rate. The second is that we currently
> have no means of increasing the transmit power as we move further from the
> AP.
>
> A fix for problem #1 is attached. I think I have something for the second,
> but it needs more testing.
>
> Larry

Sorry for taking this long to respond.

I have now tested this patch and it keeps the connection alive, but it forces 
link rate to 1Mbit with occational 5.5Mbit spikes even when next to AP. 
iwconfig reports link quality ca 30/100 and signal -30dBm when next to AP. 
70/100 and signal -60 when 10 meters away.

Not sure if desired tx power should have changed, but it remains at 6.75dBm.

I will try the patch you provided for bcm43xx-mac80211 on the bcm4301 driver 
and see how it fares.


From mb at bu3sch.de  Fri Aug  3 00:06:34 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 3 Aug 2007 00:06:34 +0200
Subject: [PATCH] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
In-Reply-To: <46b24304.DLuGdus4YPRFspUn%Larry.Finger@lwfinger.net>
References: <46b24304.DLuGdus4YPRFspUn%Larry.Finger@lwfinger.net>
Message-ID: <200708030006.35112.mb@bu3sch.de>

Thanks, I fixed that and queued it up ;)
http://bu3sch.de/patches/wireless-dev/20070803-1186092135/patches/bcm43xx-mac80211-provide-information-to-allow-transmission-rate-decreases.patch

On Thursday 02 August 2007, Larry Finger wrote:
> In bcm43xx-mac80211, the mechanism for decreasing the transmit rate cannot
> be triggered. This may be shown by walking away from the AP with a laptop.
> At some distance, communications will be lost and never recovered because
> the rate decreasing mechanism of rc80211_simple needs to see excessive_retries
> set in the ieee80211_tx_status struct. With this patch, the transmit rate
> will decrease until communications restart.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John and Michael,
> 
> This is based on the wireless-dev tree.
> 
> Larry
> 
>  bcm43xx_dma.c |    3 +++
>  1 file changed, 3 insertions(+)
> 
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
> @@ -1311,6 +1311,9 @@ void bcm43xx_dma_handle_txstatus(struct 
>  			 */
>  			if (status->acked)
>  				meta->txstat.flags |= IEEE80211_TX_STATUS_ACK;
> +			else
> +				if (!(meta->txstat.flags & IEEE80211_TXCTL_NO_ACK))
> +					meta->txstat.excessive_retries = 1;
>  			meta->txstat.retry_count = status->frame_count - 1;
>  			ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb, &(meta->txstat));
>  			/* skb is freed by ieee80211_tx_status_irqsafe() */
> 
> 




From proski at gnu.org  Fri Aug  3 00:14:06 2007
From: proski at gnu.org (Pavel Roskin)
Date: Thu, 02 Aug 2007 18:14:06 -0400
Subject: I will switch to quilt based development
In-Reply-To: <200708022247.30838.mb@bu3sch.de>
References: <200708022247.30838.mb@bu3sch.de>
Message-ID: <1186092846.11269.18.camel@dv>

Hello, Michael!

On Thu, 2007-08-02 at 22:47 +0200, Michael Buesch wrote:
> Hey guys,
> 
> I will drop my git tree and switch to much more
> lightweight quilt based workflow.
> My latest patchsets will be published at
> 
> http://bu3sch.de/patches/wireless-dev/
> 
> My scripts do upload the plain patchfiles (plus quilt series file)
> and additionally a .tar.bz2 file.

Please consider StGIT (http://www.procode.org/stgit/), which works on
top of git.

I really like that StGIT makes it possible to go back to old patches and
adjust them.  And it works with qgit.  Patches can be exported and
published.

It should be possible to make a build system that would compile SSB and
bcm43xx_mac80211 outside the kernel tree.  The lightweight tree could
still use the usual path under drivers/ssb and drivers/net/wireless for
the drivers, so that the patches won't need to be adjusted.

If you have any specific problems with git, it would be great if you
report them to the git mailing list.

-- 
Regards,
Pavel Roskin



From mb at bu3sch.de  Fri Aug  3 00:22:29 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 3 Aug 2007 00:22:29 +0200
Subject: I will switch to quilt based development
In-Reply-To: <1186092846.11269.18.camel@dv>
References: <200708022247.30838.mb@bu3sch.de> <1186092846.11269.18.camel@dv>
Message-ID: <200708030022.30108.mb@bu3sch.de>

On Friday 03 August 2007, Pavel Roskin wrote:
> Hello, Michael!
> 
> On Thu, 2007-08-02 at 22:47 +0200, Michael Buesch wrote:
> > Hey guys,
> > 
> > I will drop my git tree and switch to much more
> > lightweight quilt based workflow.
> > My latest patchsets will be published at
> > 
> > http://bu3sch.de/patches/wireless-dev/
> > 
> > My scripts do upload the plain patchfiles (plus quilt series file)
> > and additionally a .tar.bz2 file.
> 
> Please consider StGIT (http://www.procode.org/stgit/), which works on
> top of git.
> 
> I really like that StGIT makes it possible to go back to old patches and
> adjust them.  And it works with qgit.  Patches can be exported and
> published.
> 
> It should be possible to make a build system that would compile SSB and
> bcm43xx_mac80211 outside the kernel tree.  The lightweight tree could
> still use the usual path under drivers/ssb and drivers/net/wireless for
> the drivers, so that the patches won't need to be adjusted.
> 
> If you have any specific problems with git, it would be great if you
> report them to the git mailing list.
> 

No, I don't want git.
It's too heavy. And it has major problems when John rebases his
tree upstream.
With quilt and my scripts I can easily push them upstream to linville,
easily publish them on my server. All a matter of typing one command.
Going back to old patches works perfect with quilt.
And I am not going to maintain out of tree stuff anyway.
:)

Yes, I looked at stgit before writing my own set of scripts on top
of quilt. And I found out that it doesn't quite fit my needs.

But thanks for the suggestion, anyway.


From mb at bu3sch.de  Fri Aug  3 00:36:12 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 3 Aug 2007 00:36:12 +0200
Subject: mac80211 IPv6 problems
In-Reply-To: <46B25B04.5020804@gentoo.org>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<1186088678.2931.10.camel@pmac.infradead.org>
	<46B25B04.5020804@gentoo.org>
Message-ID: <200708030036.13317.mb@bu3sch.de>

On Friday 03 August 2007, Daniel Drake wrote:
> David Woodhouse wrote:
> > My experience is that mac80211 is broken w.r.t IPv6 -- it receives its
> > own packets. It would be suboptimal for me if the softmac version of
> > bcm43xx were to go away before that got fixed.
> 
> This may be a stack-level issue. This is one of the issues holding back 
> zd1211rw-mac80211 going into mainline: we have a report that 
> zd1211rw-softmac works fine with IPv6 but mac80211 only works 
> occasionally with the same device on the same system.
> 
> Does anyone have any ideas?

This is certainly an issue in the packet filtering of mac80211.



From dwmw2 at infradead.org  Fri Aug  3 00:46:18 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Thu, 02 Aug 2007 23:46:18 +0100
Subject: mac80211 IPv6 problems
In-Reply-To: <46B25B04.5020804@gentoo.org>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<200708021807.20649.mb@bu3sch.de>  <46B20695.2080100@lwfinger.net>
	<1186088678.2931.10.camel@pmac.infradead.org>
	<46B25B04.5020804@gentoo.org>
Message-ID: <1186094778.6701.6.camel@shinybook.infradead.org>

On Thu, 2007-08-02 at 18:30 -0400, Daniel Drake wrote:
> This may be a stack-level issue. This is one of the issues holding back 
> zd1211rw-mac80211 going into mainline: we have a report that 
> zd1211rw-softmac works fine with IPv6 but mac80211 only works 
> occasionally with the same device on the same system.
> 
> Does anyone have any ideas?

It receives its own neighbour solicitation (multicast) packets when the
AP sends them back out again. These packets...

23:41:56.046939 00:0a:95:f3:99:92 > 33:33:ff:f3:99:92, ethertype IPv6
(0x86dd), length 78: :: > ff02::1:fff3:9992: ICMP6, neighbor
solicitation, who has fe80::20a:95ff:fef3:9992, length 24

You should be able to see this without _any_ IPv6 infrastructure -- and
you'll see the link-local IPv6 address remains 'tentative'.

Once you've fixed that, setting up a local route advertisement d?mon
(radvd) to give you site-local addresses is fairly trivial too -- and
then you can also check that Ethernet multicast is working properly.

-- 
dwmw2



From dsd at gentoo.org  Fri Aug  3 00:30:28 2007
From: dsd at gentoo.org (Daniel Drake)
Date: Thu, 02 Aug 2007 18:30:28 -0400
Subject: mac80211 IPv6 problems
In-Reply-To: <1186088678.2931.10.camel@pmac.infradead.org>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>	
	<200708021807.20649.mb@bu3sch.de> <46B20695.2080100@lwfinger.net>
	<1186088678.2931.10.camel@pmac.infradead.org>
Message-ID: <46B25B04.5020804@gentoo.org>

David Woodhouse wrote:
> My experience is that mac80211 is broken w.r.t IPv6 -- it receives its
> own packets. It would be suboptimal for me if the softmac version of
> bcm43xx were to go away before that got fixed.

This may be a stack-level issue. This is one of the issues holding back 
zd1211rw-mac80211 going into mainline: we have a report that 
zd1211rw-softmac works fine with IPv6 but mac80211 only works 
occasionally with the same device on the same system.

Does anyone have any ideas?

Thanks,
Daniel


From proski at gnu.org  Fri Aug  3 01:05:19 2007
From: proski at gnu.org (Pavel Roskin)
Date: Thu, 02 Aug 2007 19:05:19 -0400
Subject: I will switch to quilt based development
In-Reply-To: <200708030022.30108.mb@bu3sch.de>
References: <200708022247.30838.mb@bu3sch.de> <1186092846.11269.18.camel@dv>
	<200708030022.30108.mb@bu3sch.de>
Message-ID: <1186095919.11269.31.camel@dv>

On Fri, 2007-08-03 at 00:22 +0200, Michael Buesch wrote:

> No, I don't want git.
> It's too heavy. And it has major problems when John rebases his
> tree upstream.

I'm sure you can help git development if you post your observations to
the git list.

> With quilt and my scripts I can easily push them upstream to linville,
> easily publish them on my server. All a matter of typing one command.

stg export -np
stg mail --all

> Going back to old patches works perfect with quilt.

I see.  One thing I didn't like in quilt is that I have to decide what
I'm going to do before actually changing the sources.  And it's
impossible to revert changes made before the patch is created.

But I understand it's a question of habits, and everybody has different
preferences when it comes to the tools.

> And I am not going to maintain out of tree stuff anyway.
> :)

That's why I suggested the lightweight tree:

Makefile
drivers/
  ssb/
    ssb sources
  net/
    wireless/
      bcm43xx_mac80211/
        bcm43xx_mac80211 sources

The top-level Makefile finds the kernel sources and compiles against
them.  It can also have maintenance targets, such as "indent".

> Yes, I looked at stgit before writing my own set of scripts on top
> of quilt. And I found out that it doesn't quite fit my needs.

OK, it's getting off-topic, but if you need help with stgit, please feel
free to ask.

-- 
Regards,
Pavel Roskin



From comphappy at gmail.com  Fri Aug  3 01:49:13 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Thu, 2 Aug 2007 16:49:13 -0700
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B14274.70108@lwfinger.net>
	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>
	<46B1F80E.2090301@lwfinger.net>
	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>
	<46B24CCB.7010609@lwfinger.net>
	<5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>
	<46B24FBA.3030205@lwfinger.net>
	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
Message-ID: <b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>

On 8/2/07, John H. <mistamaila at gmail.com> wrote:
> It blacklisted bcm43xx-mac80211 but it still loads anyway, and so does
> ndiswrapper, despite being blacklisted.
> so i renamed bcm43xx-mac80211.ko to bcm43xx-mac80211.bak and did the
> same for ndiswrapper and pasted what I got as a result on boot.
> Basically no wireless with just bcm43xx and softmac modules.
>
> On 8/3/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> > John H. wrote:
> > > I will send that in the next email.
> > >
> > > I am confused.   I am using 2.6.22.  Are you saying bcm43xx-mac80211
> > > should not be bitrate limited then?
> > >
> > >  uname -a
> > > Linux laptop 2.6.22.1-41.fc7 #1 SMP Fri Jul 27 18:10:34 EDT 2007 i686
> > > i686 i386 GNU/Linux
> >
> > No -bcm43xx-mac80211 does not work very well at the moment. If you had a real 2.6.22 distribution,
> > it would work. What Fedora did was strip out the PCI ID's from bcm43xx for all the
> > 802.11g-compatible devices and force you to use bcm43xx-mac80211. If you get a new copy of the
> > source, configure it for softmac and bcm43xx, it will work.
> >
> > The script I sent you should have blacklisted bcm43xx-mac80211 and installed the PCI ID for your
> > device. It seems that it didn't work.
> >
> > Larry
> >
> >
> >
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
try what i have posted earlier,
http://lists.berlios.de/pipermail/bcm43xx-dev/2007-July/004985.html


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From richie at coderworld.net  Fri Aug  3 01:50:16 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Fri, 3 Aug 2007 01:50:16 +0200
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <200708022357.14486.richie@coderworld.net>
References: <46AB5B9F.7030601@lwfinger.net> <46B0AF8C.4090608@lwfinger.net>
	<200708022357.14486.richie@coderworld.net>
Message-ID: <200708030150.16772.richie@coderworld.net>

On Thursday 02 August 2007 23:57:14 Richard Jonsson wrote:

> I will try the patch you provided for bcm43xx-mac80211 on the bcm4301
> driver and see how it fares.

I can't tell the difference before and after this addition. It might have been 
slighly better, not sure.


From linville at tuxdriver.com  Fri Aug  3 02:55:18 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 2 Aug 2007 20:55:18 -0400
Subject: mac80211 IPv6 problems
In-Reply-To: <1186094778.6701.6.camel@shinybook.infradead.org>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<200708021807.20649.mb@bu3sch.de> <46B20695.2080100@lwfinger.net>
	<1186088678.2931.10.camel@pmac.infradead.org>
	<46B25B04.5020804@gentoo.org>
	<1186094778.6701.6.camel@shinybook.infradead.org>
Message-ID: <20070803005517.GA4261@tuxdriver.com>

On Thu, Aug 02, 2007 at 11:46:18PM +0100, David Woodhouse wrote:
> On Thu, 2007-08-02 at 18:30 -0400, Daniel Drake wrote:
> > This may be a stack-level issue. This is one of the issues holding back 
> > zd1211rw-mac80211 going into mainline: we have a report that 
> > zd1211rw-softmac works fine with IPv6 but mac80211 only works 
> > occasionally with the same device on the same system.
> > 
> > Does anyone have any ideas?
> 
> It receives its own neighbour solicitation (multicast) packets when the
> AP sends them back out again. These packets...
> 
> 23:41:56.046939 00:0a:95:f3:99:92 > 33:33:ff:f3:99:92, ethertype IPv6
> (0x86dd), length 78: :: > ff02::1:fff3:9992: ICMP6, neighbor
> solicitation, who has fe80::20a:95ff:fef3:9992, length 24
> 
> You should be able to see this without _any_ IPv6 infrastructure -- and
> you'll see the link-local IPv6 address remains 'tentative'.
> 
> Once you've fixed that, setting up a local route advertisement d?mon
> (radvd) to give you site-local addresses is fairly trivial too -- and
> then you can also check that Ethernet multicast is working properly.

I hacked-up the (untested) patch below -- thoughts?

---

From: John W. Linville <linville at tuxdriver.com>

[PATCH] mac80211: filter locally-originated multicast frames

In STA mode, the AP will echo our traffic.  This includes multicast
traffice.

Receiving these frames confuses some protocols and applications,
notably IPv6 Duplicate Address Detection.

Signed-off-by: John W. Linville <linville at tuxdriver.com>
---

 net/mac80211/ieee80211.c |    7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/net/mac80211/ieee80211.c b/net/mac80211/ieee80211.c
index a42e70e..6dc6451 100644
--- a/net/mac80211/ieee80211.c
+++ b/net/mac80211/ieee80211.c
@@ -4263,11 +4263,14 @@ void __ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb,
 					rx.u.rx.ra_match = 0;
 				} else if (!multicast &&
 					   compare_ether_addr(sdata->dev->dev_addr,
-							      hdr->addr1) != 0) {
+							      hdr->addr1)) {
 					if (!sdata->promisc)
 						continue;
 					rx.u.rx.ra_match = 0;
-				}
+				} else if (multicast &&
+					   !compare_ether_addr(sdata->dev->dev_addr,
+							       hdr->addr3))
+					rx.u.rx.ra_match = 0;
 				break;
 			case IEEE80211_IF_TYPE_IBSS:
 				if (!bssid)
-- 
John W. Linville
linville at tuxdriver.com


From mistamaila at gmail.com  Fri Aug  3 09:19:17 2007
From: mistamaila at gmail.com (John H.)
Date: Fri, 3 Aug 2007 10:19:17 +0300
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B14274.70108@lwfinger.net>
	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>
	<46B1F80E.2090301@lwfinger.net>
	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>
	<46B24CCB.7010609@lwfinger.net>
	<5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>
	<46B24FBA.3030205@lwfinger.net>
	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
Message-ID: <5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>

So there's no way to use bcm43xx while using an rpm kernel?

On 8/3/07, Brennan Ashton <comphappy at gmail.com> wrote:
> On 8/2/07, John H. <mistamaila at gmail.com> wrote:
> > It blacklisted bcm43xx-mac80211 but it still loads anyway, and so does
> > ndiswrapper, despite being blacklisted.
> > so i renamed bcm43xx-mac80211.ko to bcm43xx-mac80211.bak and did the
> > same for ndiswrapper and pasted what I got as a result on boot.
> > Basically no wireless with just bcm43xx and softmac modules.
> >
> > On 8/3/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> > > John H. wrote:
> > > > I will send that in the next email.
> > > >
> > > > I am confused.   I am using 2.6.22.  Are you saying bcm43xx-mac80211
> > > > should not be bitrate limited then?
> > > >
> > > >  uname -a
> > > > Linux laptop 2.6.22.1-41.fc7 #1 SMP Fri Jul 27 18:10:34 EDT 2007 i686
> > > > i686 i386 GNU/Linux
> > >
> > > No -bcm43xx-mac80211 does not work very well at the moment. If you had a real 2.6.22 distribution,
> > > it would work. What Fedora did was strip out the PCI ID's from bcm43xx for all the
> > > 802.11g-compatible devices and force you to use bcm43xx-mac80211. If you get a new copy of the
> > > source, configure it for softmac and bcm43xx, it will work.
> > >
> > > The script I sent you should have blacklisted bcm43xx-mac80211 and installed the PCI ID for your
> > > device. It seems that it didn't work.
> > >
> > > Larry
> > >
> > >
> > >
> > _______________________________________________
> > Bcm43xx-dev mailing list
> > Bcm43xx-dev at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
> >
> try what i have posted earlier,
> http://lists.berlios.de/pipermail/bcm43xx-dev/2007-July/004985.html
>
>
> --
> Brennan Ashton
> Bellingham, Washington
>
> "The box said, 'Requires Windows 98 or better'. So I installed Linux"
>


From hs4233 at mail.mn-solutions.de  Fri Aug  3 09:36:45 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Fri, 3 Aug 2007 09:36:45 +0200
Subject: I will switch to quilt based development
In-Reply-To: <1186095919.11269.31.camel@dv>
References: <200708022247.30838.mb@bu3sch.de> <200708030022.30108.mb@bu3sch.de>
	<1186095919.11269.31.camel@dv>
Message-ID: <200708030936.45214.hs4233@mail.mn-solutions.de>

> I see.  One thing I didn't like in quilt is that I have to
> decide what I'm going to do before actually changing the
> sources.

All I have to decide beforehand is the name of patch. In stgit 
this is the same. However, stg is worse, because there I even 
have to enter a description of what I'm about to do beforehand. 
*)

Sometimes, I just make patches in quilt, then I do "quilt 
refresh", "quilt pop -a", "cd patches" and modify the patches 
and series file manually, e.g. by moving one patch from one file 
into the other. The "cd ..", "quilt push -a" and off I am. That 
the "database" of quilt is in a known format and I can hack on 
it with an editor is a plus for me :-)

That said: once I'm finished with quilt-things, I'm using stg 
import to import this into git and use git to send it off to the 
mailing list. I'm not working with stg on the first place, 
because quilt is noticably faster than stg.



*) in stgit I can do "stg refresh -e" to edit the description 
afterwards


From johannes at sipsolutions.net  Fri Aug  3 11:40:01 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 03 Aug 2007 11:40:01 +0200
Subject: [RFC V2] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
In-Reply-To: <46B1F201.7060107@lwfinger.net>
References: <46b0f367.p35iGhSXwM+v4QLG%Larry.Finger@lwfinger.net>
	<200708021337.21285.mb@bu3sch.de>
	<1186055319.24230.32.camel@johannes.berg>
	<200708021503.53982.mb@bu3sch.de>
	<1186060034.24230.48.camel@johannes.berg>
	<46B1F201.7060107@lwfinger.net>
Message-ID: <1186134001.4647.15.camel@johannes.berg>

On Thu, 2007-08-02 at 10:02 -0500, Larry Finger wrote:

> When I first started investigating the problem of mac80211 not reducing the rate as I moved away 
> from the AP, it seemed to me that the decision regarding excessive retries should be made in 
> mac80211, not in the driver; however, I have had extreme difficulty in getting any changes into 
> mac80211 on several occasions. Linville assures me that he has had private discussions about this 
> problem; however, I needed a quick fix and couldn't stand any protracted discussion and/or review 
> delays. I knew Michael would be tough, but that his comments would not be delayed.

Agreed. There are definitely problems with getting things into mac80211
and I've complained about that in the past.

> At the moment, I have more pressing matters to resolve than fixing this problem in mac80211; 
> however, I feel really good that the port of bcm43xx-softmac to mac80211 has this issue.

I think that a great many other drivers will have this issue too.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/f4692081/attachment.pgp>

From mb at bu3sch.de  Fri Aug  3 12:17:53 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 3 Aug 2007 12:17:53 +0200
Subject: I will switch to quilt based development
In-Reply-To: <1186095919.11269.31.camel@dv>
References: <200708022247.30838.mb@bu3sch.de> <200708030022.30108.mb@bu3sch.de>
	<1186095919.11269.31.camel@dv>
Message-ID: <200708031217.54154.mb@bu3sch.de>

On Friday 03 August 2007 01:05:19 Pavel Roskin wrote:
> On Fri, 2007-08-03 at 00:22 +0200, Michael Buesch wrote:
> 
> > No, I don't want git.
> > It's too heavy. And it has major problems when John rebases his
> > tree upstream.
> 
> I'm sure you can help git development if you post your observations to
> the git list.

It's not a problem with git itself.
I use git for almost all of my projects and I'm so happy with this
great tool. :) But just in this case; the linux wireless development;
I think that patches work better, as there's not the issue of
"rebasing" stuff. Rebasing a patchset is easy (quilt push -a; quilt pop -a).
But rebasing something that has history in it (git) is more work.
We are in a phase of big movement at the moment, where big chunks of code
move to mainline. That's simply easier to handle with plain patches
that don't carry any history.

But I will consider stgit usage for other projects.

-- 
Greetings Michael.


From dwmw2 at infradead.org  Fri Aug  3 12:40:57 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 03 Aug 2007 11:40:57 +0100
Subject: mac80211 IPv6 problems
In-Reply-To: <20070803005517.GA4261@tuxdriver.com>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<200708021807.20649.mb@bu3sch.de> <46B20695.2080100@lwfinger.net>
	<1186088678.2931.10.camel@pmac.infradead.org>
	<46B25B04.5020804@gentoo.org>
	<1186094778.6701.6.camel@shinybook.infradead.org>
	<20070803005517.GA4261@tuxdriver.com>
Message-ID: <1186137657.2931.45.camel@pmac.infradead.org>

On Thu, 2007-08-02 at 20:55 -0400, John W. Linville wrote:
> I hacked-up the (untested) patch below -- thoughts? 

I tried to test it. Today, I get no connectivity with bcm43xx-mac80211
(from Fedora 7 + your patch).

It does manage to associate, but tcpdump shows it doesn't seem to
receive any packets correctly -- http://david.woodhou.se/bcm43xx-bad.txt

I tried taking the device down and back up, and setting the WEP key
again (I think I've seen it screw up before and have to be told the WEP
key again before it starts working), but that didn't help. Removing the
module left rmmod and ksoftirqd both eating CPU, so I had to reboot.

I don't have time to do any more right now; I might look at it again in
a couple of weeks when I get home. But all this ought to be
reproduceable elsewhere -- and if it isn't, I have a Cardbus card which
seems to be exactly the same rev 4306 as my shinybook's internal device.
Give me an address to ship it to :)

-- 
dwmw2



From dwmw2 at infradead.org  Fri Aug  3 12:43:06 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 03 Aug 2007 11:43:06 +0100
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B14274.70108@lwfinger.net>
	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>
	<46B1F80E.2090301@lwfinger.net>
	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>
	<46B24CCB.7010609@lwfinger.net>
	<5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>
	<46B24FBA.3030205@lwfinger.net>
	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
Message-ID: <1186137786.2931.48.camel@pmac.infradead.org>

On Fri, 2007-08-03 at 10:19 +0300, John H. wrote:
> So there's no way to use bcm43xx while using an rpm kernel?

Yes, of course there is. You just have to add the PCI ID of your own
card by echoing it to /sys/bus/pci/drivers/bcm43xx/new_id

I just have this in /etc/rc.local:
	/sbin/modprobe bcm43xx
	echo "14e4 4320" > /sys/bus/pci/drivers/bcm43xx/new_id

Failing that, you can just rebuild the bcm43xx module _without_ the PCI
IDs removed -- there's no reason for you to rebuild the whole kernel.

-- 
dwmw2



From martti.huttunen at mail.suomi.net  Fri Aug  3 12:49:41 2007
From: martti.huttunen at mail.suomi.net (Martti Huttunen)
Date: Fri, 03 Aug 2007 13:49:41 +0300
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B14274.70108@lwfinger.net>
	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>
	<46B1F80E.2090301@lwfinger.net>
	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>
	<46B24CCB.7010609@lwfinger.net>
	<5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>
	<46B24FBA.3030205@lwfinger.net>
	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
Message-ID: <46B30845.8010801@mail.suomi.net>

John H. wrote:
> So there's no way to use bcm43xx while using an rpm kernel?

There is a way to use any driver with the rpm kernel, as long as
it does not require some deeper patching of the kernel.
The old bcm43xx driver should compile just fine as a separate
directory (if bcm43xx-mac80211 could be applied like this,
I would surely test it as well).
You need the kernel-devel package for your kernel and replace
the stock module with your newly built one.

Not exact procedure of building a single module:
LINUXDIR=/usr/src/kernels/`uname -r` make SUBDIRS=my/module/path modules
(Don't have the exact details at hand just now,sorry)

What is the status of AP mode with the mac80211 driver?

-Martti.

> On 8/3/07, Brennan Ashton <comphappy at gmail.com> wrote:
>> try what i have posted earlier,
>> http://lists.berlios.de/pipermail/bcm43xx-dev/2007-July/004985.html
>> --
>> Brennan Ashton
>> Bellingham, Washington



From larry.finger at lwfinger.net  Fri Aug  3 14:50:42 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 03 Aug 2007 07:50:42 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>	
	<46B14274.70108@lwfinger.net>	
	<5b9417770708020128i3f6a69e7mc1e3a5841c6aff57@mail.gmail.com>	
	<46B1F80E.2090301@lwfinger.net>	
	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>	
	<46B24CCB.7010609@lwfinger.net>	
	<5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>	
	<46B24FBA.3030205@lwfinger.net>	
	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>	
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
Message-ID: <46B324A2.7020207@lwfinger.net>

John H. wrote:
> So there's no way to use bcm43xx while using an rpm kernel?

The script I sent you was supposed to make it possible. I'm not a Fedora user so I cannot help that 
much.

Larry


From mb at bu3sch.de  Fri Aug  3 16:00:25 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 3 Aug 2007 16:00:25 +0200
Subject: Reverse engineering of hwpctl table upload
Message-ID: <200708031600.26018.mb@bu3sch.de>

Does someone have some time to reverse engineer the
table upload functions (DC table, TSSI table and the other one
I don't remember). They are uploaded in the hwpctl setup.
I'm pretty sure there are bugs. If I omit this init on the
4318, I get halfway good looking values for the estimated
power output. If I let the tables upload and init, I always
get 20dbm, which is obviously wrong.

-- 
Greetings Michael.


From stefano.brivio at polimi.it  Fri Aug  3 16:38:36 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Fri, 3 Aug 2007 16:38:36 +0200
Subject: [RFC 2/10] Port of bcm43xx from softmac to mac80211
In-Reply-To: <46b1fded.0g4ZHvU7XwSzeJVs%Larry.Finger@lwfinger.net>
References: <46b1fded.0g4ZHvU7XwSzeJVs%Larry.Finger@lwfinger.net>
Message-ID: <20070803163836.7ef9622b@morte>

On Thu, 02 Aug 2007 10:53:17 -0500
Larry Finger <Larry.Finger at lwfinger.net> wrote:

> +static char big_buffer[1024*256];

static char big_buffer[1024 * 256];

> +		bcmerr(dev->wl, "debugfs: Board not initialized.\n");
>  		res = -EFAULT;
>  		goto out_unlock;
>  	}
> -	if (sscanf(buf, "%lli", &tsf) != 1) {
> -		printk(KERN_INFO PFX "debugfs: invalid values for
> \"tsf\"\n");
> +	if (sscanf(buf, "%llu", (unsigned long long *)(&tsf)) != 1) {
> +		bcmerr(dev->wl, "debugfs: invalid values for \"tsf\"\n");

"debugfs: Invalid values for TSF.\n"

> +	int i;
> +	int idx;

int i, idx;

> +void bcm43xx_debugfs_add_device(struct bcm43xx_wldev *dev)
>  {
>  	struct bcm43xx_dfsentry *e;
> -	char devdir[IFNAMSIZ];
> +	struct bcm43xx_txstatus_log *log;
> +	char devdir[16];
>  
> -	assert(bcm);
> +	BCM43xx_BUG_ON(!dev);
>  	e = kzalloc(sizeof(*e), GFP_KERNEL);
>  	if (!e) {
> -		printk(KERN_ERR PFX "out of memory\n");
> +		bcmerr(dev->wl, "debugfs: add device OOM\n");

"debugfs: OOM while adding device.\n"

> +		bcmerr(dev->wl, "debugfs: add device txstatus OOM\n");

"debugfs: OOM while adding device txstatus.\n"

And the same for all the debugfs messages, please be consistent.


-- 
Ciao
Stefano


From johannes at sipsolutions.net  Fri Aug  3 16:48:31 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 03 Aug 2007 16:48:31 +0200
Subject: Reverse engineering of hwpctl table upload
In-Reply-To: <200708031600.26018.mb@bu3sch.de>
References: <200708031600.26018.mb@bu3sch.de>
Message-ID: <1186152511.4647.44.camel@johannes.berg>

On Fri, 2007-08-03 at 16:00 +0200, Michael Buesch wrote:
> Does someone have some time to reverse engineer the
> table upload functions (DC table, TSSI table and the other one
> I don't remember). They are uploaded in the hwpctl setup.
> I'm pretty sure there are bugs. If I omit this init on the
> 4318, I get halfway good looking values for the estimated
> power output. If I let the tables upload and init, I always
> get 20dbm, which is obviously wrong.

Can you work without hwpctl for now? The original driver allows you to
switch off hardware power control so the other code *should* work too...

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/1a8be4fa/attachment.pgp>

From stefano.brivio at polimi.it  Fri Aug  3 16:30:44 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Fri, 3 Aug 2007 16:30:44 +0200
Subject: [RFC 1/10] Port of bcm43xx from softmac to mac80211
In-Reply-To: <46b1fde7.JR5zA75dJy7VnTEq%Larry.Finger@lwfinger.net>
References: <46b1fde7.JR5zA75dJy7VnTEq%Larry.Finger@lwfinger.net>
Message-ID: <20070803163044.3d0fff1b@morte>

[Just a quick review, mostly about coding style. If it works, I ACK this.]

On Thu, 02 Aug 2007 10:53:11 -0500
Larry Finger <Larry.Finger at lwfinger.net> wrote:

> +#define BCM43xx_RX_MAX_SSI		60

A comment here wouldn't hurt.

>  /* MMIO offsets */
>  #define BCM43xx_MMIO_DMA0_REASON	0x20
> @@ -45,6 +39,7 @@
>  #define BCM43xx_MMIO_DMA4_IRQ_MASK	0x44
>  #define BCM43xx_MMIO_DMA5_REASON	0x48
>  #define BCM43xx_MMIO_DMA5_IRQ_MASK	0x4C
> +#define BCM43xx_MMIO_MACCTL		0x120
>  #define BCM43xx_MMIO_STATUS_BITFIELD	0x120
>  #define BCM43xx_MMIO_STATUS2_BITFIELD	0x124
>  #define BCM43xx_MMIO_GEN_IRQ_REASON	0x128
> @@ -83,6 +78,7 @@
>  
>  #define BCM43xx_MMIO_PHY_VER		0x3E0
>  #define BCM43xx_MMIO_PHY_RADIO		0x3E2
> +#define BCM43xx_MMIO_PHY0		0x3E6
>  #define BCM43xx_MMIO_ANTENNA		0x3E8
>  #define BCM43xx_MMIO_CHANNEL		0x3F0
>  #define BCM43xx_MMIO_CHANNEL_EXT	0x3F4
> @@ -93,6 +89,7 @@
>  #define BCM43xx_MMIO_PHY_DATA		0x3FE
>  #define BCM43xx_MMIO_MACFILTER_CONTROL	0x420
>  #define BCM43xx_MMIO_MACFILTER_DATA	0x422
> +#define BCM43xx_MMIO_RCMTA_COUNT	0x43C

Ditto, the meaning of RCMTA isn't obvious.

>  /* PHYVersioning */
> -#define BCM43xx_PHYTYPE_A		0x00

So OK, let's remove support for A PHYs. I never got done with it and maybe it
had to be rewritten from scratch anyway.

> +#define BCM43xx_IRQ_TBTT_INDI		0x00000004

A comment here would be nice.

>  #define BCM43xx_INTERFSTACK_SIZE	26
> -	u32 interfstack[BCM43xx_INTERFSTACK_SIZE];
> +	u32 interfstack[BCM43xx_INTERFSTACK_SIZE];/* FIXME: use a data
> struct */

Why?

> +/* Data structure for the WLAN parts (802.11 cores) of the bcm43xx chip.
> */ +struct bcm43xx_wl {
> +	/* Pointer to the active wireless device on this chip */
> +	struct bcm43xx_wldev *current_dev;
> +	/* Pointer to the ieee80211 hardware data structure */
> +	struct ieee80211_hw *hw;
> +
> +	spinlock_t irq_lock;		/* locks IRQ */
> +	struct mutex mutex;		/* locks ? */

What?

> -		atomic_set(&(bcm)->init_status, (stat));	\
> +	BCM43xx_STAT_UNINIT		= 0, /* Uninitialized. */
> +	BCM43xx_STAT_INITIALIZED	= 1, /* Initialized, not yet
> started */

"Initialized, not yet started."

> -/*    *** THEORY OF LOCKING ***
> +/* XXX---   HOW LOCKING WORKS IN BCM43xx   ---XXX

I'd prefer "***" but this isn't relevant. :)

> +struct bcm43xx_wldev {
> +	struct ssb_device *dev;
> +	struct bcm43xx_wl *wl;
> +
> +	/* The device initialization status.
> +	 * Use bcm43xx_status() to query. */
> +	atomic_t __init_status;
> +	/* Saved init status for handling suspend. */
> +	int suspend_init_status;
> +
> +	bool __using_pio;		/* iUse bcm43xx_using_pio(). */

An evolution of the iRack? :P

> +	bool bad_frames_preempt;	/* Use "Bad Frames Preemption" */

Dot at the end.

> +	bool reg124_set_0x4;		/* Variable to keep track of
> IRQ */

Ditto.

> +	bool short_preamble;		/* TRUE if short preamble
> enabled. */

"True".

> +	bool short_slot;		/* TRUE if short slot timing
> enabled. */

Ditto.

> +	bool radio_hw_enable;		/* state of radio hardware
> enable bit */

"State of the radio hardware enable bit."

> +/* Macros for printing a value in Q5.2 format */
> +#define Q52_FMT		"%u.%u"
> +#define Q52_ARG(q52)	((q52) / 4), ((((q52) & 3) * 100) / 4)

#define Q52_ARG(q52) ((q52) / 4), (((q52) & 3) * 100 / 4)


--
Ciao
Stefano


-- 
Ciao
Stefano


From mb at bu3sch.de  Fri Aug  3 17:30:27 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 3 Aug 2007 17:30:27 +0200
Subject: [RFC 2/10] Port of bcm43xx from softmac to mac80211
In-Reply-To: <20070803163836.7ef9622b@morte>
References: <46b1fded.0g4ZHvU7XwSzeJVs%Larry.Finger@lwfinger.net>
	<20070803163836.7ef9622b@morte>
Message-ID: <200708031730.27767.mb@bu3sch.de>

On Friday 03 August 2007, Stefano Brivio wrote:
> On Thu, 02 Aug 2007 10:53:17 -0500
> Larry Finger <Larry.Finger at lwfinger.net> wrote:
> 
> > +static char big_buffer[1024*256];
> 
> static char big_buffer[1024 * 256];
> 
> > +		bcmerr(dev->wl, "debugfs: Board not initialized.\n");
> >  		res = -EFAULT;
> >  		goto out_unlock;
> >  	}
> > -	if (sscanf(buf, "%lli", &tsf) != 1) {
> > -		printk(KERN_INFO PFX "debugfs: invalid values for
> > \"tsf\"\n");
> > +	if (sscanf(buf, "%llu", (unsigned long long *)(&tsf)) != 1) {
> > +		bcmerr(dev->wl, "debugfs: invalid values for \"tsf\"\n");
> 
> "debugfs: Invalid values for TSF.\n"
> 
> > +	int i;
> > +	int idx;
> 
> int i, idx;

No, checkpatch complains about multiple variables per line.

> > +void bcm43xx_debugfs_add_device(struct bcm43xx_wldev *dev)
> >  {
> >  	struct bcm43xx_dfsentry *e;
> > -	char devdir[IFNAMSIZ];
> > +	struct bcm43xx_txstatus_log *log;
> > +	char devdir[16];
> >  
> > -	assert(bcm);
> > +	BCM43xx_BUG_ON(!dev);
> >  	e = kzalloc(sizeof(*e), GFP_KERNEL);
> >  	if (!e) {
> > -		printk(KERN_ERR PFX "out of memory\n");
> > +		bcmerr(dev->wl, "debugfs: add device OOM\n");
> 
> "debugfs: OOM while adding device.\n"
> 
> > +		bcmerr(dev->wl, "debugfs: add device txstatus OOM\n");
> 
> "debugfs: OOM while adding device txstatus.\n"
> 
> And the same for all the debugfs messages, please be consistent.
> 
> 

All your comments address code that's not written my larry, but me.
So if you want that fixed, please send patches.


From mb at bu3sch.de  Fri Aug  3 17:47:10 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 3 Aug 2007 17:47:10 +0200
Subject: Reverse engineering of hwpctl table upload
In-Reply-To: <1186152511.4647.44.camel@johannes.berg>
References: <200708031600.26018.mb@bu3sch.de>
	<1186152511.4647.44.camel@johannes.berg>
Message-ID: <200708031747.10773.mb@bu3sch.de>

On Friday 03 August 2007, Johannes Berg wrote:
> On Fri, 2007-08-03 at 16:00 +0200, Michael Buesch wrote:
> > Does someone have some time to reverse engineer the
> > table upload functions (DC table, TSSI table and the other one
> > I don't remember). They are uploaded in the hwpctl setup.
> > I'm pretty sure there are bugs. If I omit this init on the
> > 4318, I get halfway good looking values for the estimated
> > power output. If I let the tables upload and init, I always
> > get 20dbm, which is obviously wrong.
> 
> Can you work without hwpctl for now? The original driver allows you to
> switch off hardware power control so the other code *should* work too...

What do I have to do?
Switch off some hostflag?


From larry.finger at lwfinger.net  Fri Aug  3 18:13:08 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 03 Aug 2007 11:13:08 -0500
Subject: [RFC 1/10] Port of bcm43xx from softmac to mac80211
In-Reply-To: <20070803163044.3d0fff1b@morte>
References: <46b1fde7.JR5zA75dJy7VnTEq%Larry.Finger@lwfinger.net>
	<20070803163044.3d0fff1b@morte>
Message-ID: <46B35414.2030300@lwfinger.net>

Stefano,

Thanks for taking the time to review the patches. As Michael wrote, the bulk of the patch comes from 
his V4 code, but it's good to have it looked through.



Stefano Brivio wrote:

>>  /* PHYVersioning */
>> -#define BCM43xx_PHYTYPE_A		0x00
> 
> So OK, let's remove support for A PHYs. I never got done with it and maybe it
> had to be rewritten from scratch anyway.

This removal is _ONLY_ for the driver that uses V3 firmware. It will ultimately be limited to B PHYs 
and removal of the A PHY stuff will happen anyway. AFAIK, support of A PHYs will be implemented 
(eventually) in the V4 driver.

All suggestions implemented.

Larry



From proski at gnu.org  Fri Aug  3 18:53:41 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 03 Aug 2007 12:53:41 -0400
Subject: I will switch to quilt based development
In-Reply-To: <200708030936.45214.hs4233@mail.mn-solutions.de>
References: <200708022247.30838.mb@bu3sch.de>
	<200708030022.30108.mb@bu3sch.de> <1186095919.11269.31.camel@dv>
	<200708030936.45214.hs4233@mail.mn-solutions.de>
Message-ID: <1186160021.26110.22.camel@dv>

On Fri, 2007-08-03 at 09:36 +0200, Holger Schurig wrote:
> > I see.  One thing I didn't like in quilt is that I have to
> > decide what I'm going to do before actually changing the
> > sources.
> 
> All I have to decide beforehand is the name of patch. In stgit 
> this is the same. However, stg is worse, because there I even 
> have to enter a description of what I'm about to do beforehand. 
> *)

But unlike quilt, you don't have to do anything before editing the
sources.  You can create a patch after the changes are done.  Or you can
revert the changes.

Having to do anything before editing reeks of version control systems
predating CVS, where files had to be checked out for editing.

My complaint about stgit is that I have to write the description without
seeing the changes.  I just noticed "stg new -s", but it's broken.
Generally, stgit follows quilt too closely here.  "stg new" and "stg
refresh" should be merged, or one of them should be optional.

> Sometimes, I just make patches in quilt, then I do "quilt 
> refresh", "quilt pop -a", "cd patches" and modify the patches 
> and series file manually, e.g. by moving one patch from one file 
> into the other. The "cd ..", "quilt push -a" and off I am. That 
> the "database" of quilt is in a known format and I can hack on 
> it with an editor is a plus for me :-)

That's a very cool feature that stgit should learn.

> That said: once I'm finished with quilt-things, I'm using stg 
> import to import this into git and use git to send it off to the 
> mailing list. I'm not working with stg on the first place, 
> because quilt is noticably faster than stg.

Perhaps periodic repacking with git-gc could speed up things a bit.  But
the search for changed files is actually for your protection, and should
be appreciated IMHO.

> *) in stgit I can do "stg refresh -e" to edit the description 
> afterwards

"stg refresh -es" and "stg export -np" are my favorite commands.

I'm going to post all my ideas to the git list right now.

-- 
Regards,
Pavel Roskin



From comphappy at gmail.com  Fri Aug  3 19:00:58 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Fri, 3 Aug 2007 09:00:58 -0800
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <1186137786.2931.48.camel@pmac.infradead.org>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B1F80E.2090301@lwfinger.net>
	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>
	<46B24CCB.7010609@lwfinger.net>
	<5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>
	<46B24FBA.3030205@lwfinger.net>
	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
	<1186137786.2931.48.camel@pmac.infradead.org>
Message-ID: <b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>

> Failing that, you can just rebuild the bcm43xx module _without_ the PCI
> IDs removed -- there's no reason for you to rebuild the whole kernel.

Except to keep up with current patches in the whole wireless system,
and enable more debugging as this is still very much in development.
By rebuilding the whole thing, he can use bcm43xx_mac80211

-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From larry.finger at lwfinger.net  Fri Aug  3 19:11:41 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 03 Aug 2007 12:11:41 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>	<46B1F80E.2090301@lwfinger.net>	<5b9417770708021419g63f7794fp7a6ce96f275b1cc3@mail.gmail.com>	<46B24CCB.7010609@lwfinger.net>	<5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>	<46B24FBA.3030205@lwfinger.net>	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>	<1186137786.2931.48.camel@pmac.infradead.org>
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>
Message-ID: <46B361CD.8070705@lwfinger.net>

Brennan Ashton wrote:
>> Failing that, you can just rebuild the bcm43xx module _without_ the PCI
>> IDs removed -- there's no reason for you to rebuild the whole kernel.
> 
> Except to keep up with current patches in the whole wireless system,
> and enable more debugging as this is still very much in development.
> By rebuilding the whole thing, he can use bcm43xx_mac80211
> 

The OP's meaning of this thread, which is that bcm43xx_mac80211 doesn't work well enough for him, 
has been lost. He wants bcm43xx (softmac)!

One other option is to get the stand-alone version of bcm43xx from my FTP site 
(ftp://lwfinger.dynalias.org/patches/bcm43xx-softmac-sa.tar.bz2), and build that.

Larry




From comphappy at gmail.com  Fri Aug  3 19:24:25 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Fri, 3 Aug 2007 09:24:25 -0800
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46B361CD.8070705@lwfinger.net>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B24CCB.7010609@lwfinger.net>
	<5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>
	<46B24FBA.3030205@lwfinger.net>
	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
	<1186137786.2931.48.camel@pmac.infradead.org>
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>
	<46B361CD.8070705@lwfinger.net>
Message-ID: <b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>

> The OP's meaning of this thread, which is that bcm43xx_mac80211 doesn't work well enough for him,
> has been lost. He wants bcm43xx (softmac)!
>
> One other option is to get the stand-alone version of bcm43xx from my FTP site
> (ftp://lwfinger.dynalias.org/patches/bcm43xx-softmac-sa.tar.bz2), and build that.

which is what the directions that i posted do, with the new version of
bcm43xx_mac80211 it should work fine, that is what i have on F7 with
the same card, and i am getting speeds over 1mb/s.  This weekend, i
could write a script to automate the process if people are interested.

-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From josejx at gentoo.org  Fri Aug  3 20:33:58 2007
From: josejx at gentoo.org (Joseph Jezak)
Date: Fri, 03 Aug 2007 14:33:58 -0400
Subject: Reverse engineering of hwpctl table upload
In-Reply-To: <1186152511.4647.44.camel@johannes.berg>
References: <200708031600.26018.mb@bu3sch.de>
	<1186152511.4647.44.camel@johannes.berg>
Message-ID: <46B37516.7090502@gentoo.org>

Johannes Berg wrote:
> On Fri, 2007-08-03 at 16:00 +0200, Michael Buesch wrote:
>> Does someone have some time to reverse engineer the
>> table upload functions (DC table, TSSI table and the other one
>> I don't remember). They are uploaded in the hwpctl setup.
>> I'm pretty sure there are bugs. If I omit this init on the
>> 4318, I get halfway good looking values for the estimated
>> power output. If I let the tables upload and init, I always
>> get 20dbm, which is obviously wrong.
> 
> Can you work without hwpctl for now? The original driver allows you to
> switch off hardware power control so the other code *should* work too...

I'm not sure that we clearly defined the difference between revision 
checks and hardware power control checks.  If we did, then just 
making all of the hw power checks if (0) would be enough to turn off 
hw power control, it's just a matter of writing the correct values 
to registers.

As for the tables, I started looking at it a bit last week, but my 
time has been pretty limited.  In 2 weeks I'll be finished with my 
current project and will have some time to start working on this 
again if johannes hasn't already done it.

-Joe


From johannes at sipsolutions.net  Fri Aug  3 21:35:41 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 03 Aug 2007 21:35:41 +0200
Subject: Reverse engineering of hwpctl table upload
In-Reply-To: <200708031747.10773.mb@bu3sch.de>
References: <200708031600.26018.mb@bu3sch.de>
	<1186152511.4647.44.camel@johannes.berg>
	<200708031747.10773.mb@bu3sch.de>
Message-ID: <1186169741.4647.59.camel@johannes.berg>

On Fri, 2007-08-03 at 17:47 +0200, Michael Buesch wrote:
> On Friday 03 August 2007, Johannes Berg wrote:
> > On Fri, 2007-08-03 at 16:00 +0200, Michael Buesch wrote:
> > > Does someone have some time to reverse engineer the
> > > table upload functions (DC table, TSSI table and the other one
> > > I don't remember). They are uploaded in the hwpctl setup.
> > > I'm pretty sure there are bugs. If I omit this init on the
> > > 4318, I get halfway good looking values for the estimated
> > > power output. If I let the tables upload and init, I always
> > > get 20dbm, which is obviously wrong.
> > 
> > Can you work without hwpctl for now? The original driver allows you to
> > switch off hardware power control so the other code *should* work too...
> 
> What do I have to do?
> Switch off some hostflag?

I think it's enough to just not fill the hw power shared memory. Or
rather, set the length of the hw power table to 0 in shm, iirc from
disassembling the firmware.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/1acfac90/attachment.pgp>

From gavron at Wetwork.Net  Fri Aug  3 22:07:43 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 03 Aug 2007 13:07:43 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
Message-ID: <46B38B0F.20808@Wetwork.Net>

The bcm43xx_mac80211 code associates fine and has good signal strength.  
However, the stuff coming out of it on eth1 is not Ethernet...
The same setup worked in 2.6.22-wireless-dev.

A simple unload of the two modules, a reload of bcm43xx with v3 fw, and 
it all works...

You'll note I attached entire dmesg and not just "dmesg|grep bcm" so 
that you could also see:
bcm43xx-phy0 debug: bbatt(11) >= size of LO array

Call Trace:
 [<ffffffff88299ab0>] :bcm43xx_mac80211:bcm43xx_get_lo_g_ctl+0x65/0xa8
 [<ffffffff88299b29>] :bcm43xx_mac80211:bcm43xx_lo_g_ctl_current+0x36/0x3b
 [<ffffffff88299c0d>] :bcm43xx_mac80211:bcm43xx_lo_g_adjust+0x9/0x15
 [<ffffffff8829425b>] :bcm43xx_mac80211:bcm43xx_phy_init_pctl+0x338/0x6a6
 [<ffffffff8828eaf4>] :bcm43xx_mac80211:bcm43xx_phy_read+0x5c/0x63
 [<ffffffff88297528>] :bcm43xx_mac80211:bcm43xx_phy_initg+0xc85/0xd0a
 [<ffffffff88297d5b>] :bcm43xx_mac80211:bcm43xx_phy_init+0x582/0x5a7
 [<ffffffff8828bcce>] :bcm43xx_mac80211:bcm43xx_chip_init+0x68c/0x9a3
 [<ffffffff8828c26d>] 
:bcm43xx_mac80211:bcm43xx_wireless_core_init+0x288/0x73e
 [<ffffffff8828d2bb>] :bcm43xx_mac80211:bcm43xx_add_interface+0x5f/0xf4
 [<ffffffff882586b6>] :mac80211:ieee80211_open+0x21d/0x34d
 [<ffffffff803ddcec>] dev_open+0x2f/0x6e
 [<ffffffff803dbedb>] dev_change_flags+0xaa/0x168
 [<ffffffff80420c4b>] devinet_ioctl+0x235/0x597
 [<ffffffff803d1413>] sock_ioctl+0x1c8/0x1e5
 [<ffffffff8029d665>] do_ioctl+0x21/0x6b
 [<ffffffff8029d8f2>] vfs_ioctl+0x243/0x25c
 [<ffffffff8029d964>] sys_ioctl+0x59/0x79
 [<ffffffff8020bc8e>] system_call+0x7e/0x83

bcm43xx-phy0 debug: Chip initialized

See attached files.

Ehud
dmesg.afterboot   --- what dmesg shows after boot has completed
iwconfig.afterboot--- what iwconfig shows after boot (without my doing 
anything)
iwconfig.after_ifup--- now I've ifup eth1 'd
lsmod.afterboot -- quick module check for bcm and ndis to ensure no conflict
tcpdump.after_ifup_mac80211--- a tcpdump while trying the dhcp client 
(dhclient)

rmmod bcm43xx_mac80211
rmmod bcm43xx
modprobe bcm43xx fwpostfix=".fw3"

tcpdump.works_softmac --- it brought the interface up, associated, 
dhcp'd all before I could start tcpdump...


-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: dmesg.afterboot
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/57025d6e/attachment.ksh>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: dmesg.after_dhclient_failed_mac80211
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/57025d6e/attachment-0001.ksh>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: ifconfig.after_ifup
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/57025d6e/attachment-0002.ksh>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: iwconfig.afterboot
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/57025d6e/attachment-0003.ksh>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: iwconfig.after_ifup
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/57025d6e/attachment-0004.ksh>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: lsmod.afterboot
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/57025d6e/attachment-0005.ksh>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: tcpdump.after_ifup_mac80211
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/57025d6e/attachment-0006.ksh>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: tcpdump.works_softmac
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/57025d6e/attachment-0007.ksh>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070803/57025d6e/attachment.bin>

From Larry.Finger at lwfinger.net  Fri Aug  3 23:26:21 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 03 Aug 2007 16:26:21 -0500
Subject: [PATCH] bcm43xx-mac80211: Set antenna gains if not in sprom
Message-ID: <46b39d7d.4kGviB6QZBFl2jfv%Larry.Finger@lwfinger.net>

In the sprom for bcm43xx devices, any unprogrammed values are set to all ones.
In the case of antenna gains, the specs indicate that a gain of 2 dBm should
be set if no value is stored. This patch implements that provision.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -3805,6 +3805,12 @@ static void bcm43xx_sprom_fixup(struct s
 	    bus->boardinfo.rev > 0x40)
 		bus->sprom.r1.boardflags_lo |= BCM43xx_BFL_PACTRL;
 
+	/* Handle case when gain is not set in sprom */
+	if (bus->sprom.r1.antenna_gain_a == 0xFF)
+		bus->sprom.r1.antenna_gain_a = 2;
+	if (bus->sprom.r1.antenna_gain_bg == 0xFF)
+		bus->sprom.r1.antenna_gain_bg = 2;
+
 	/* Convert Antennagain values to Q5.2 */
 	bus->sprom.r1.antenna_gain_a <<= 2;
 	bus->sprom.r1.antenna_gain_bg <<= 2;


From mb at bu3sch.de  Fri Aug  3 23:38:43 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 3 Aug 2007 23:38:43 +0200
Subject: [PATCH] bcm43xx-mac80211: Set antenna gains if not in sprom
In-Reply-To: <46b39d7d.4kGviB6QZBFl2jfv%Larry.Finger@lwfinger.net>
References: <46b39d7d.4kGviB6QZBFl2jfv%Larry.Finger@lwfinger.net>
Message-ID: <200708032338.43593.mb@bu3sch.de>

On Friday 03 August 2007 23:26:21 Larry Finger wrote:
> In the sprom for bcm43xx devices, any unprogrammed values are set to all ones.
> In the case of antenna gains, the specs indicate that a gain of 2 dBm should
> be set if no value is stored. This patch implements that provision.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -3805,6 +3805,12 @@ static void bcm43xx_sprom_fixup(struct s
>  	    bus->boardinfo.rev > 0x40)
>  		bus->sprom.r1.boardflags_lo |= BCM43xx_BFL_PACTRL;
>  
> +	/* Handle case when gain is not set in sprom */
> +	if (bus->sprom.r1.antenna_gain_a == 0xFF)
> +		bus->sprom.r1.antenna_gain_a = 2;
> +	if (bus->sprom.r1.antenna_gain_bg == 0xFF)
> +		bus->sprom.r1.antenna_gain_bg = 2;
> +
>  	/* Convert Antennagain values to Q5.2 */
>  	bus->sprom.r1.antenna_gain_a <<= 2;
>  	bus->sprom.r1.antenna_gain_bg <<= 2;
> -
> To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
> the body of a message to majordomo at vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
> 
> 

Queued, thanks!

-- 
Greetings Michael.


From mistamaila at gmail.com  Sat Aug  4 00:16:56 2007
From: mistamaila at gmail.com (John H.)
Date: Sat, 4 Aug 2007 01:16:56 +0300
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<5b9417770708021433y22fd049fh8b6d6ce45498d6e1@mail.gmail.com>
	<46B24FBA.3030205@lwfinger.net>
	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
	<1186137786.2931.48.camel@pmac.infradead.org>
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>
	<46B361CD.8070705@lwfinger.net>
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>
Message-ID: <5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>

yes, please post such a script so I can use it and not need
ndiswrapper anymore:)

On 8/3/07, Brennan Ashton <comphappy at gmail.com> wrote:
> > The OP's meaning of this thread, which is that bcm43xx_mac80211 doesn't work well enough for him,
> > has been lost. He wants bcm43xx (softmac)!
> >
> > One other option is to get the stand-alone version of bcm43xx from my FTP site
> > (ftp://lwfinger.dynalias.org/patches/bcm43xx-softmac-sa.tar.bz2), and build that.
>
> which is what the directions that i posted do, with the new version of
> bcm43xx_mac80211 it should work fine, that is what i have on F7 with
> the same card, and i am getting speeds over 1mb/s.  This weekend, i
> could write a script to automate the process if people are interested.
>
> --
> Brennan Ashton
> Bellingham, Washington
>
> "The box said, 'Requires Windows 98 or better'. So I installed Linux"
>


From larry.finger at lwfinger.net  Sat Aug  4 03:46:16 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 03 Aug 2007 20:46:16 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46B38B0F.20808@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net>
Message-ID: <46B3DA68.7090407@lwfinger.net>

Ehud Gavron wrote:
> The bcm43xx_mac80211 code associates fine and has good signal strength.  
> However, the stuff coming out of it on eth1 is not Ethernet...
> The same setup worked in 2.6.22-wireless-dev.
> 
> A simple unload of the two modules, a reload of bcm43xx with v3 fw, and 
> it all works...
> 
> You'll note I attached entire dmesg and not just "dmesg|grep bcm" so 
> that you could also see:
> bcm43xx-phy0 debug: bbatt(11) >= size of LO array

The size of LO array message is not fatal.

I pulled the latest system from wireless-dev and built it. On my 4311, it connects just fine. The 
maximum transmit and receive rates are 2.2 and 3.2 Mbs, respectively.

I don't know what happened to your system.

Larry


From gavron at Wetwork.Net  Sat Aug  4 04:38:04 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 03 Aug 2007 19:38:04 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46B3DA68.7090407@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <46B3DA68.7090407@lwfinger.net>
Message-ID: <46B3E68C.6090101@Wetwork.Net>

I have received a private reply from another user with *exactly* the 
same symptoms.  That user also uses x86_64.

I just got the tree from scratch, built it, booted without any tainting 
modules (nvidia) and got _exactly_ the same results.

What am I doing wrong?  I've build these before... and I think I have 
the procedure right. 

Thanks,

Ehud
 1060  cd /usr/src
 1061  ls
 1062  rm -rf wireless-dev/
 1063  ./git.sh
 1064  sed -e "s/\(EXTRAVERSION.*\)/\1-wireless-dev-EG2/g" -i 
wireless-dev/Makefile
 1065  cd wireless-dev/
 1066  make mrproper
 1067  cp ../2.6.22-EG1/.config .
 1068  make oldconfig < /dev/null > /dev/null
 1069  grep -i bcm43xx .config
 1073  make                          <------------ finished WAY TOO SOON 
with error in asus_laptop.c
 1075  sed -e "s/CONFIG_ASUS_LAPTOP=\(.*\)/CONFIG_ASUS_LAPTOP=n/g" -i 
.config
 1076  make
 1077  time nice make modules_install
 1078  time nice make install
 1079  history
 1080  history > ~root/build_history.txt
(and here you have it)


Larry Finger wrote:
> Ehud Gavron wrote:
>   
>> The bcm43xx_mac80211 code associates fine and has good signal strength.  
>> However, the stuff coming out of it on eth1 is not Ethernet...
>> The same setup worked in 2.6.22-wireless-dev.
>>
>> A simple unload of the two modules, a reload of bcm43xx with v3 fw, and 
>> it all works...
>>
>> You'll note I attached entire dmesg and not just "dmesg|grep bcm" so 
>> that you could also see:
>> bcm43xx-phy0 debug: bbatt(11) >= size of LO array
>>     
>
> The size of LO array message is not fatal.
>
> I pulled the latest system from wireless-dev and built it. On my 4311, it connects just fine. The 
> maximum transmit and receive rates are 2.2 and 3.2 Mbs, respectively.
>
> I don't know what happened to your system.
>
> Larry
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   


From proski at gnu.org  Sat Aug  4 05:27:40 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 03 Aug 2007 23:27:40 -0400
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but
	Ethernet appears broken
In-Reply-To: <46B3DA68.7090407@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net>  <46B3DA68.7090407@lwfinger.net>
Message-ID: <1186198060.28481.6.camel@dv>

On Fri, 2007-08-03 at 20:46 -0500, Larry Finger wrote:

> The size of LO array message is not fatal.

I'll really appreciate if it's removed or at least the stack dump is
suppressed.  We know already that it's a problem, so why scare users
more than they need to?  We know where it happens, why show the stack?

I don't think we want to make users ignore stack traces in the kernel
logs, because we may not hear about unknown problems.

IMHO there are better places for TODO notes than innocent users' kernel
logs.

-- 
Regards,
Pavel Roskin



From larry.finger at lwfinger.net  Sat Aug  4 05:37:13 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 03 Aug 2007 22:37:13 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46B3E68C.6090101@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <46B3DA68.7090407@lwfinger.net>
	<46B3E68C.6090101@Wetwork.Net>
Message-ID: <46B3F469.8010109@lwfinger.net>

Ehud Gavron wrote:
> I have received a private reply from another user with *exactly* the 
> same symptoms.  That user also uses x86_64.
> 
> I just got the tree from scratch, built it, booted without any tainting 
> modules (nvidia) and got _exactly_ the same results.
> 
> What am I doing wrong?  I've build these before... and I think I have 
> the procedure right.
> Thanks,
> 
> Ehud
> 1060  cd /usr/src
> 1061  ls
> 1062  rm -rf wireless-dev/
> 1063  ./git.sh
> 1064  sed -e "s/\(EXTRAVERSION.*\)/\1-wireless-dev-EG2/g" -i 
> wireless-dev/Makefile
> 1065  cd wireless-dev/
> 1066  make mrproper
> 1067  cp ../2.6.22-EG1/.config .
> 1068  make oldconfig < /dev/null > /dev/null
> 1069  grep -i bcm43xx .config
> 1073  make                          <------------ finished WAY TOO SOON 
> with error in asus_laptop.c
> 1075  sed -e "s/CONFIG_ASUS_LAPTOP=\(.*\)/CONFIG_ASUS_LAPTOP=n/g" -i 
> .config
> 1076  make
> 1077  time nice make modules_install
> 1078  time nice make install
> 1079  history
> 1080  history > ~root/build_history.txt
> (and here you have it)

The commands look fine and I think you said the 2.6.22-EG1 config was OK.

When I looked at your dmesg, I noticed the following messages:

eth1: switched to short barker preamble (BSSID=00:0d:0b:11:5c:1b)
ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready
eth1: no IPv6 routers present
device eth1 entered promiscuous mode

What is that all about? On my system IPv6 is disabled. Will that make any difference for you?

Larry


From larry.finger at lwfinger.net  Sat Aug  4 05:43:15 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 03 Aug 2007 22:43:15 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but	Ethernet
	appears broken
In-Reply-To: <1186198060.28481.6.camel@dv>
References: <46B38B0F.20808@Wetwork.Net> <46B3DA68.7090407@lwfinger.net>
	<1186198060.28481.6.camel@dv>
Message-ID: <46B3F5D3.5090800@lwfinger.net>

Pavel Roskin wrote:
> On Fri, 2007-08-03 at 20:46 -0500, Larry Finger wrote:
> 
>> The size of LO array message is not fatal.
> 
> I'll really appreciate if it's removed or at least the stack dump is
> suppressed.  We know already that it's a problem, so why scare users
> more than they need to?  We know where it happens, why show the stack?
> 
> I don't think we want to make users ignore stack traces in the kernel
> logs, because we may not hear about unknown problems.
> 
> IMHO there are better places for TODO notes than innocent users' kernel
> logs.

I agree completely; however, I've had my "hands slapped" in the past for removing that kind of 
message. As a result, I leave them alone.

Larry


From comphappy at gmail.com  Sat Aug  4 07:12:46 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Fri, 3 Aug 2007 22:12:46 -0700
Subject: Odd network locking
Message-ID: <b2d05de20708032212j4f408935tac381077f50379a8@mail.gmail.com>

When the bcm43xx_mac80211 driver stops communicating, and needs to be
reset (this seems to happens when coming from strong to week to strong
signal area quickly) i have been rmmod and then modprobing it. this
works most of the time, but some times (~20%), it will lock up the
network with this error that repeats.

Message from syslogd at localhost at Fri Aug  3 00:55:41 2007 ...
localhost kernel: [19316.256549] unregister_netdevice: waiting for eth1 to becom
e free. Usage count = 5

usage count varies, but renders the system unusable (extremely slow,
like when localhost is not defined) until the laptop is turned off,
the system will hang during shutdown requiring a power interrupt.
This did not happen with the bcm43xx driver in 2.6.22-rc7.

Current Data
[root at localhost ~]# uname -r
2.6.23-rc1
[root at localhost ~]# lspci | grep Broadcom
03:00.0 Network controller: Broadcom Corporation Dell Wireless 1390
WLAN Mini-PCI Card (rev 01)

dmesg is over filled with TKIP decrypt info, so little info is there

[root at localhost ~]# iwlist eth1 scanning
Warning: Driver for device eth1 has been compiled with version 22
of Wireless Extension, while this program supports up to version 20.
Some things may be broken...

eth1      Scan completed :
          Cell 01 - Address: 00:12:17:AA:84:67
                    ESSID:"thishome"
                    Mode:Master
                    Channel:6
                    Frequency:2.437 GHz (Channel 6)
                    Quality=41/100  Signal level=-61 dBm  Noise level=-68 dBm
                    Encryption key:on
                    IE: WPA Version 1
                        Group Cipher : TKIP
                        Pairwise Ciphers (1) : TKIP
                        Authentication Suites (1) : PSK
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 18 Mb/s
                              24 Mb/s; 36 Mb/s; 54 Mb/s; 6 Mb/s; 9 Mb/s
                              12 Mb/s; 48 Mb/s
                    Extra:tsf=00000298702da2c8
          Cell 02 - Address: 00:18:3F:64:47:D9
                    ESSID:"2WIRE199"
                    Mode:Master
                    Channel:6
                    Frequency:2.437 GHz (Channel 6)
                    Quality=31/100  Signal level=-77 dBm  Noise level=-68 dBm
                    Encryption key:on
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s
                              9 Mb/s; 12 Mb/s; 18 Mb/s; 24 Mb/s; 36 Mb/s
                              48 Mb/s; 54 Mb/s
                    Extra:tsf=000000401364c181
          Cell 03 - Address: 00:03:52:C7:E3:B0
                    ESSID:"bbx"
                    Mode:Master
                    Channel:11
                    Frequency:2.462 GHz (Channel 11)
                    Quality=27/100  Signal level=-83 dBm  Noise level=-68 dBm
                    Encryption key:off
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
                    Extra:tsf=0000000002711d4b


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From johannes at sipsolutions.net  Sat Aug  4 08:51:17 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Sat, 04 Aug 2007 08:51:17 +0200
Subject: Odd network locking
In-Reply-To: <b2d05de20708032212j4f408935tac381077f50379a8@mail.gmail.com>
References: <b2d05de20708032212j4f408935tac381077f50379a8@mail.gmail.com>
Message-ID: <1186210277.20275.10.camel@johannes.berg>

On Fri, 2007-08-03 at 22:12 -0700, Brennan Ashton wrote:
> When the bcm43xx_mac80211 driver stops communicating, and needs to be
> reset (this seems to happens when coming from strong to week to strong
> signal area quickly) i have been rmmod and then modprobing it. this
> works most of the time, but some times (~20%), it will lock up the
> network with this error that repeats.
> 
> Message from syslogd at localhost at Fri Aug  3 00:55:41 2007 ...
> localhost kernel: [19316.256549] unregister_netdevice: waiting for eth1 to becom
> e free. Usage count = 5
> 
> usage count varies, but renders the system unusable (extremely slow,
> like when localhost is not defined) until the laptop is turned off,
> the system will hang during shutdown requiring a power interrupt.
> This did not happen with the bcm43xx driver in 2.6.22-rc7.

I was about to suggest it could be caused by the deadlock Michael just
found and fixed, but that happens under rtnl so it can't be.

Can you get a process dump? echo t > /proc/sysrq-trigger or just
pressing sysrq-t

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070804/b9d9e845/attachment.pgp>

From comphappy at gmail.com  Sat Aug  4 09:56:30 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sat, 4 Aug 2007 00:56:30 -0700
Subject: Odd network locking
In-Reply-To: <1186210277.20275.10.camel@johannes.berg>
References: <b2d05de20708032212j4f408935tac381077f50379a8@mail.gmail.com>
	<1186210277.20275.10.camel@johannes.berg>
Message-ID: <b2d05de20708040056o67c71868v17312a408e61120d@mail.gmail.com>

the trace overflows dmesg buffer, but here is what is left in the log:
4e3c 00000000 c1a04180 d8c94000
[ 2372.383209]        00000000 00000000 f721e660 f721e814 c19fb180
00000000 c0758e40 c1afec90
[ 2372.383224]        f715f480 00000086 00000000 c04225a5 f716fb7c
fffe0c1e f764a800 00000041
[ 2372.383239] Call Trace:
[ 2372.383268]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.383294]  [<c04788d6>] pipe_wait+0x51/0x6f
[ 2372.383305]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.383320]  [<c0478fbe>] pipe_read+0x2ad/0x31d
[ 2372.383354]  [<c04730c3>] do_sync_read+0xc7/0x10a
[ 2372.383384]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.383411]  [<c04042cb>] restore_sigcontext+0x162/0x1b3
[ 2372.383428]  [<c0472ffc>] do_sync_read+0x0/0x10a
[ 2372.383440]  [<c047396c>] vfs_read+0xa6/0x152
[ 2372.383456]  [<c0473dc5>] sys_read+0x41/0x67
[ 2372.383472]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.383504]  =======================
[ 2372.383508] metacity      S 00000039  2460  4311      1
[ 2372.383518]        d9149be4 00200082 8bafbaa5 00000039 d9149bc8
00000000 d9149bcc d9149000
[ 2372.383533]        59a2665d 00000228 f75e5300 f75e54b4 c1a04180
00000001 c0758e40 f778b300
[ 2372.383547]        f774a840 d9149bf4 d9149bd4 c0625f0f f7d02000
001f6358 00000000 00000000
[ 2372.383562] Call Trace:
[ 2372.383591]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.383616]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.383634]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.383647]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.383661]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.383682]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.383699]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.383716]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.383733]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.383751]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.383768]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.383785]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.383802]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.383818]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.383849]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.383869]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.383889]  [<c061d7a5>] unix_write_space+0x15/0x77
[ 2372.383903]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.383914]  [<c05bfa35>] __kfree_skb+0xa3/0xfa
[ 2372.383931]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.383976]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.384027]  [<c041fc73>] update_stats_wait_end+0xaf/0xda
[ 2372.384059]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.384072]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.384082]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.384094]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.384110]  [<c047da71>] vfs_ioctl+0x237/0x249
[ 2372.384131]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.384143]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.384176]  =======================
[ 2372.384181] gnome-panel   S 00000039  2152  4316      1
[ 2372.384190]        d88cbbe4 00200086 75202198 00000039 00200202
00000001 00000044 d88cb000
[ 2372.384205]        54119fde 00000226 f7d4d300 f7d4d4b4 c1a04180
00000001 c0758e40 00000001
[ 2372.384220]        c1b92ac0 000000d0 000000d0 00000000 c0720318
c045ad61 00000000 00000000
[ 2372.384235] Call Trace:
[ 2372.384265]  [<c045ad61>] __alloc_pages+0x64/0x2a9
[ 2372.384288]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.384306]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.384318]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.384333]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.384354]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.384371]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384388]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384406]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384423]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384440]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384458]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384475]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384492]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384509]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384526]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384544]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384561]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384578]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384595]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384613]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384630]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384647]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384664]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384681]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384698]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.384777]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.384793]  [<c047da71>] vfs_ioctl+0x237/0x249
[ 2372.384814]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.384826]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.384848]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.384867]  =======================
[ 2372.384872] nautilus      S 00000039  2272  4318      1
[ 2372.384881]        d9134be4 00000082 8ad5138f 00000039 d9134bc8
00000000 d9134bcc d9134000
[ 2372.384896]        00000001 00000226 f72a9930 f72a9ae4 c1a04180
00000001 c0758e40 f7d02000
[ 2372.384911]        e1b7e440 d9134bd4 c0625f0f f7d02000 c042fb7a
001f6580 00000286 00000286
[ 2372.384925] Call Trace:
[ 2372.384953]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.384964]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.384988]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.385005]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.385018]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.385037]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.385058]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.385074]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385092]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385109]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385127]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385144]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385161]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385179]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385196]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385213]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385230]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385248]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385265]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385282]  [<c061d7a5>] unix_write_space+0x15/0x77
[ 2372.385291]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.385311]  [<f8991b06>] ext3_get_acl+0x2b1/0x2bb [ext3]
[ 2372.385348]  [<c0481fd2>] __d_lookup+0xbc/0xee
[ 2372.385375]  [<c0485b5c>] mntput_no_expire+0x11/0x6e
[ 2372.385387]  [<c047b917>] __link_path_walk+0xbae/0xbd4
[ 2372.385405]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.385425]  [<c0485b5c>] mntput_no_expire+0x11/0x6e
[ 2372.385469]  [<c047bc80>] do_path_lookup+0x16a/0x1cf
[ 2372.385480]  [<c047aabe>] getname+0x59/0xad
[ 2372.385494]  [<c047c45d>] __user_walk_fd+0x38/0x40
[ 2372.385511]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.385524]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.385534]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.385547]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.385566]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.385583]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.385594]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.385616]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.385635]  =======================
[ 2372.385639] bonobo-activa S 00000004  2644  4322      1
[ 2372.385649]        d91f7be4 00200086 612c3a73 00000004 d91f7bc8
00000000 c04dce8c d91f7000
[ 2372.385663]        00000001 00000000 f72ab970 f72abb24 c1a04180
00000001 c0758e40 f7307070
[ 2372.385678]        f776c4c0 0000ffff f7307070 c0625efd c04de53b
fffe15ca f8840080 000000d0
[ 2372.385693] Call Trace:
[ 2372.385705]  [<c04dce8c>] blk_start_queueing+0x11/0x19
[ 2372.385730]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.385738]  [<c04de53b>] __make_request+0x4c0/0x506
[ 2372.385761]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.385771]  [<c048ec5d>] __find_get_block_slow+0x11b/0x125
[ 2372.385789]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.385802]  [<c0478174>] pipe_poll+0x24/0x7a
[ 2372.385815]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.385836]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.385853]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385870]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.385895]  [<f89846c2>] __ext3_get_inode_loc+0x10f/0x305 [ext3]
[ 2372.385929]  [<f898f866>] __ext3_journal_dirty_metadata+0x16/0x3a [ext3]
[ 2372.385957]  [<f886fbd3>] journal_get_write_access+0x21/0x26 [jbd]
[ 2372.385985]  [<c048efa1>] __find_get_block+0x141/0x14b
[ 2372.386005]  [<f898f866>] __ext3_journal_dirty_metadata+0x16/0x3a [ext3]
[ 2372.386057]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.386100]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.386120]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.386151]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.386172]  [<c042c1bd>] current_fs_time+0x41/0x46
[ 2372.386191]  [<c0478c87>] pipe_write+0x393/0x3ec
[ 2372.386212]  [<c047b9e6>] link_path_walk+0xa9/0xb3
[ 2372.386239]  [<f8991b06>] ext3_get_acl+0x2b1/0x2bb [ext3]
[ 2372.386286]  [<c048249a>] dput+0x31/0xdf
[ 2372.386302]  [<c0485b5c>] mntput_no_expire+0x11/0x6e
[ 2372.386325]  [<c047388c>] vfs_write+0x11a/0x154
[ 2372.386348]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.386360]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.386393]  =======================
[ 2372.386398] bonobo-activa S 0000000c  2460  4324      1
[ 2372.386407]        d91e7be4 00200086 161f28fe 0000000c 00200202
00000001 00000044 d91e7000
[ 2372.386422]        5ecb23fd 00000061 f721f8f0 f721faa4 c1a04180
00000001 c0758e40 cc3b18f0
[ 2372.386437]        f776c4c0 000000d0 000000d0 00000000 c0720318
c045ad61 00000000 00000000
[ 2372.386452] Call Trace:
[ 2372.386482]  [<c045ad61>] __alloc_pages+0x64/0x2a9
[ 2372.386505]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.386523]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.386536]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.386550]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.386571]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.386588]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386606]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386623]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386640]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386657]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386674]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386692]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386709]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386726]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386743]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386761]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386778]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386795]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386812]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386829]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386847]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386864]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386881]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386898]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386915]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.386999]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.387022]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.387034]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.387068]  =======================
[ 2372.387073] gnome-volume- S 00000033  2468  4323      1
[ 2372.387082]        d8a3cbe4 00200086 6fe1e005 00000033 c19f7b40
00000002 d8a3cbcc d8a3c000
[ 2372.387097]        122a78ad 00000222 f7c60d10 f7c60ec4 c19fb180
00000000 c043df12 f77d38f0
[ 2372.387111]        f70025c0 c1a00120 c1a00120 00200046 c0406f0f
0017dffd 0005aaf0 00000000
[ 2372.387126] Call Trace:
[ 2372.387149]  [<c043df12>] tick_handle_periodic+0x17/0x5d
[ 2372.387166]  [<c0406f0f>] do_IRQ+0xbd/0xd2
[ 2372.387189]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.387207]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.387220]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.387234]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.387255]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.387271]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.387289]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.387307]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.387324]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.387341]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.387358]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.387376]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.387393]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.387411]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.387428]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.387453]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.387472]  [<c061d7dd>] unix_write_space+0x4d/0x77
[ 2372.387493]  [<c05bf3f5>] skb_dequeue+0x39/0x3f
[ 2372.387506]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.387551]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.387567]  [<c045ac8a>] get_page_from_freelist+0x23e/0x2b1
[ 2372.387623]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.387643]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.387656]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.387666]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.387678]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.387694]  [<c047da71>] vfs_ioctl+0x237/0x249
[ 2372.387714]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.387726]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.387759]  =======================
[ 2372.387764] eggcups       S 00000033  2460  4326      1
[ 2372.387773]        d8bcdbe4 00200086 79e3a222 00000033 d8bcdbc8
00000000 d8bcdbcc d8bcd000
[ 2372.387788]        00000000 0000021b f7d4f340 f7d4f4f4 c19fb180
00000000 c0758e40 c0812e80
[ 2372.387803]        c1b924c0 d8bcdbd4 c0625f0f c0812e80 c042fb7a
001f0a9d 00200282 00200282
[ 2372.387817] Call Trace:
[ 2372.387845]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.387856]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.387880]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.387897]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.387910]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.387929]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.387949]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.387966]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.387984]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388001]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388018]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388036]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388053]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388070]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388088]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388105]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388122]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388146]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.388166]  [<c061d7a5>] unix_write_space+0x15/0x77
[ 2372.388180]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.388191]  [<c05bfa35>] __kfree_skb+0xa3/0xfa
[ 2372.388211]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.388253]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.388273]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.388314]  [<c041fc73>] update_stats_wait_end+0xaf/0xda
[ 2372.388345]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.388359]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.388369]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.388381]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.388400]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.388418]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.388429]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.388461]  =======================
[ 2372.388466] bluetooth-app S 00000037  2408  4328      1
[ 2372.388475]        d8bf4be4 00000082 fe2aba94 00000037 c1a00b40
00000002 d8bf4bcc d8bf4000
[ 2372.388490]        2660c758 00000214 f7f40660 f7f40814 c1a04180
00000001 c0758e40 d8149970
[ 2372.388505]        e1489a80 d8bf4bf4 d8bf4bd4 c0625f0f f7d02000
fffe3ea4 0005a1f5 00000000
[ 2372.388520] Call Trace:
[ 2372.388549]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.388574]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.388592]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.388605]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.388619]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.388640]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.388657]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388675]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388692]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388709]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388727]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388744]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388761]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388778]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.388808]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.388828]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.388848]  [<c061d7a5>] unix_write_space+0x15/0x77
[ 2372.388862]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.388872]  [<c05bfa35>] __kfree_skb+0xa3/0xfa
[ 2372.388890]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.388934]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.388950]  [<c045ac8a>] get_page_from_freelist+0x23e/0x2b1
[ 2372.389005]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.389025]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.389039]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.389049]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.389061]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.389076]  [<c047da71>] vfs_ioctl+0x237/0x249
[ 2372.389097]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.389109]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.389131]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.389150]  =======================
[ 2372.389155] gnome-vfs-dae S 00000033  2468  4330      1
[ 2372.389163]        d8e80be4 00000082 6fdf5190 00000033 00000000
000f4d7b c1a04180 d8e80000
[ 2372.389178]        1227ea73 00000222 f77d38f0 f77d3aa4 c19fb180
00000000 d8e80ba0 f72ee0b0
[ 2372.389193]        ed427340 00000001 c042934c c1a00120 00000046
c043df12 00036304 00000000
[ 2372.389208] Call Trace:
[ 2372.389236]  [<c042934c>] profile_tick+0x43/0x5e
[ 2372.389247]  [<c043df12>] tick_handle_periodic+0x17/0x5d
[ 2372.389271]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.389289]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.389302]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.389316]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.389337]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.389354]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.389372]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.389389]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.389406]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.389424]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.389441]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.389458]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.389475]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.389505]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.389525]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.389545]  [<c061d7dd>] unix_write_space+0x4d/0x77
[ 2372.389565]  [<c05bf3f5>] skb_dequeue+0x39/0x3f
[ 2372.389579]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.389624]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.389639]  [<c045ac8a>] get_page_from_freelist+0x23e/0x2b1
[ 2372.389695]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.389714]  [<c04243db>] scheduler_tick+0x14c/0x175
[ 2372.389744]  [<c0473980>] vfs_read+0xba/0x152
[ 2372.389766]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.389779]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.389801]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.389820]  =======================
[ 2372.389824] puplet        S 00000032  2460  4340      1
[ 2372.389833]        d8683be4 00000086 15aa8289 00000032 c19f7b40
00000002 d8683bcc d8683000
[ 2372.389848]        26136c7d 00000214 d8f3f930 d8f3fae4 c19fb180
00000000 c0758e40 f778b300
[ 2372.389863]        d9b9d900 d8683bf4 d8683bd4 c0625f0f d8683bc8
00000000 00000000 00000000
[ 2372.389878] Call Trace:
[ 2372.389906]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.389921]  [<c04ea20d>] __delay+0x6/0x7
[ 2372.389930]  [<c04ec3d7>] _raw_spin_lock+0x78/0xdc
[ 2372.389945]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.389963]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.389975]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.389989]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.390010]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.390027]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390044]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390061]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390078]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390095]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390112]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390129]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390147]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390176]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.390196]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.390216]  [<c061d7a5>] unix_write_space+0x15/0x77
[ 2372.390229]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.390240]  [<c05bfa35>] __kfree_skb+0xa3/0xfa
[ 2372.390257]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.390303]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.390365]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.390385]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.390398]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.390408]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.390421]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.390436]  [<c047da71>] vfs_ioctl+0x237/0x249
[ 2372.390457]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.390469]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.390502]  =======================
[ 2372.390507] nm-applet     S 00000039  2236  4344      1
[ 2372.390516]        d873fbe4 00000086 8ab44dab 00000039 d873fbc8
00000000 d873fbcc d873f000
[ 2372.390531]        00000001 00000227 f778a6a0 f778a854 c1a04180
00000001 c0758e40 f7d02000
[ 2372.390546]        f770edc0 d873fbd4 c0625f0f f7d02000 c042fb7a
001f646c 00000286 00000286
[ 2372.390560] Call Trace:
[ 2372.390588]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.390598]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.390623]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.390640]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.390652]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.390671]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.390692]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.390708]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390726]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390743]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390760]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390777]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390794]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390811]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390828]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.390848]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.390868]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.390900]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.390919]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.390938]  [<c05bdebc>] sock_def_readable+0x3c/0x66
[ 2372.390953]  [<c061d11c>] unix_stream_sendmsg+0x246/0x311
[ 2372.390987]  [<c05b9fed>] sock_aio_write+0xf6/0x102
[ 2372.391048]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.391068]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.391081]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.391091]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.391103]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.391122]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.391139]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.391150]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.391183]  =======================
[ 2372.391187] beagled       S 00000033  1892  4345      1
[ 2372.391196]        d87d2be4 00000086 e8135f51 00000033 d87d2bc8
00000000 d87d2bcc d87d2000
[ 2372.391211]        00000000 00000227 d8f3e070 d8f3e224 c19fb180
00000000 c0758e40 c0812e80
[ 2372.391225]        d9b9d300 d87d2bd4 c0625f0f c0812e80 c042fb7a
001f5ab4 00000282 00000282
[ 2372.391240] Call Trace:
[ 2372.391268]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.391279]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.391303]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.391320]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.391332]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.391351]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.391372]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.391389]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.391406]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.391423]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.391442]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.391459]  [<c04203b2>] balance_tasks+0xb2/0x13e
[ 2372.391477]  [<c04e5c08>] __next_cpu+0x12/0x21
[ 2372.391486]  [<c041f54f>] find_busiest_group+0x1c4/0x54c
[ 2372.391536]  [<c0403f9d>] __switch_to+0xfd/0x12c
[ 2372.391555]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.391563]  [<c062497c>] __sched_text_start+0x6bc/0x729
[ 2372.391597]  [<c043eb6c>] get_futex_key+0x6e/0x122
[ 2372.391611]  [<c043eae0>] unqueue_me+0x7c/0x84
[ 2372.391626]  [<c043f6ec>] futex_wait+0x242/0x2c8
[ 2372.391638]  [<c04091e1>] convert_fxsr_to_user+0x103/0x157
[ 2372.391672]  [<c046456f>] find_extend_vma+0x12/0x49
[ 2372.391699]  [<c043fa55>] futex_wake+0xa9/0xb3
[ 2372.391717]  [<c040901d>] convert_fxsr_from_user+0x2b/0xec
[ 2372.391739]  [<c0409466>] restore_i387+0x84/0xe7
[ 2372.391752]  [<c04042cb>] restore_sigcontext+0x162/0x1b3
[ 2372.391784]  [<c0404c86>] sys_sigreturn+0xc9/0x163
[ 2372.391801]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.391818]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.391830]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.391861]  =======================
[ 2372.391866] mono          S 00000039  3308  4367      1
[ 2372.391875]        d757af2c 00200086 8289e045 00000039 d757af10
00000000 00000008 d757a000
[ 2372.391890]        00000001 d757aef8 d8f3f300 d8f3f4b4 c1a04180
00000001 c0758e40 d757af4c
[ 2372.391905]        d9b9d300 00000000 00000000 c043a7f7 00200282
001f5a72 c1a011f8 c043acd9
[ 2372.391920] Call Trace:
[ 2372.391949]  [<c043a7f7>] enqueue_hrtimer+0x5a/0x62
[ 2372.391963]  [<c043acd9>] hrtimer_start+0xe4/0xee
[ 2372.391982]  [<c0625400>] do_nanosleep+0x41/0x6c
[ 2372.391997]  [<c043ad33>] hrtimer_nanosleep+0x50/0xf3
[ 2372.392015]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.392027]  [<c06253f5>] do_nanosleep+0x36/0x6c
[ 2372.392053]  [<c043ae1f>] sys_nanosleep+0x49/0x59
[ 2372.392067]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.392088]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.392108]  =======================
[ 2372.392112] mono          S 00000039  3036  4368      1
[ 2372.392122]        d7164e24 00200086 8b8b91d7 00000039 d7164e08
00000000 01e84800 d7164000
[ 2372.392137]        00000001 00000228 f7c1c6e0 f7c1c894 c1a04180
00000001 c0758e40 d7164e88
[ 2372.392152]        d9b9d300 00000000 00000000 c043a7f7 00200282
001f6810 c1a011f8 c043acd9
[ 2372.392167] Call Trace:
[ 2372.392195]  [<c043a7f7>] enqueue_hrtimer+0x5a/0x62
[ 2372.392209]  [<c043acd9>] hrtimer_start+0xe4/0xee
[ 2372.392229]  [<c043f6bd>] futex_wait+0x213/0x2c8
[ 2372.392273]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.392286]  [<c043f6ae>] futex_wait+0x204/0x2c8
[ 2372.392304]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.392323]  [<c043fac8>] do_futex+0x69/0x93b
[ 2372.392342]  [<c0409466>] restore_i387+0x84/0xe7
[ 2372.392355]  [<c04042cb>] restore_sigcontext+0x162/0x1b3
[ 2372.392371]  [<c043c017>] getnstimeofday+0x30/0xbd
[ 2372.392388]  [<c043ae70>] ktime_get_ts+0x16/0x44
[ 2372.392400]  [<c043aead>] ktime_get+0xf/0x2e
[ 2372.392416]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.392441]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.392473]  =======================
[ 2372.392478] beagled       S 00000033  3056  4387      1
[ 2372.392487]        d68d9e38 00200086 e8121996 00000033 d5ab7ab9
0000002d c0758dc0 d68d9000
[ 2372.392502]        99280609 00000227 d81486e0 d8148894 c19fb180
00000000 ffe4c286 d68d9e0c
[ 2372.392517]        d9b9d300 d67a1340 d81486e0 c19fb1dc d68d9e24
c04256db 000049b6 00000000
[ 2372.392532] Call Trace:
[ 2372.392564]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.392581]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.392596]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.392610]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.392631]  [<c04385f5>] prepare_to_wait_exclusive+0x27/0x42
[ 2372.392646]  [<c05c1c22>] skb_recv_datagram+0x13c/0x1b6
[ 2372.392660]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.392677]  [<c061c37c>] unix_accept+0x50/0xee
[ 2372.392693]  [<c05bbb32>] sys_accept+0xec/0x1d1
[ 2372.392710]  [<c040901d>] convert_fxsr_from_user+0x2b/0xec
[ 2372.392732]  [<c0409466>] restore_i387+0x84/0xe7
[ 2372.392745]  [<c04042cb>] restore_sigcontext+0x162/0x1b3
[ 2372.392779]  [<c05bbced>] sys_socketcall+0xd6/0x261
[ 2372.392795]  [<c0419d3a>] smp_apic_timer_interrupt+0x74/0x80
[ 2372.392816]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.392848]  =======================
[ 2372.392852] beagled       S 00000039  2292  4416      1
[ 2372.392861]        d5ad1e24 00200086 8b7783fd 00000039 d5ad1e08
00000000 c854e478 d5ad1000
[ 2372.392876]        00000001 00000228 d67a1340 d67a14f4 c1a04180
00000001 c0758e40 d5ad1e88
[ 2372.392891]        d9b9d300 00000000 00000000 c043a7f7 00200282
001f67d4 c1a011f8 c043acd9
[ 2372.392906] Call Trace:
[ 2372.392935]  [<c043a7f7>] enqueue_hrtimer+0x5a/0x62
[ 2372.392949]  [<c043acd9>] hrtimer_start+0xe4/0xee
[ 2372.392969]  [<c043f6bd>] futex_wait+0x213/0x2c8
[ 2372.393014]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.393026]  [<c043f6ae>] futex_wait+0x204/0x2c8
[ 2372.393044]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.393064]  [<c043fac8>] do_futex+0x69/0x93b
[ 2372.393085]  [<c047bc80>] do_path_lookup+0x16a/0x1cf
[ 2372.393096]  [<c047aabe>] getname+0x59/0xad
[ 2372.393111]  [<c043c017>] getnstimeofday+0x30/0xbd
[ 2372.393127]  [<c043ae70>] ktime_get_ts+0x16/0x44
[ 2372.393139]  [<c043aead>] ktime_get+0xf/0x2e
[ 2372.393155]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.393180]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.393212]  =======================
[ 2372.393216] beagled       S 00000033  2468  4417      1
[ 2372.393225]        d5ac5be4 00200086 e81c44fb 00000033 d5ac5bc8
00000000 d5ac5bcc d5ac5000
[ 2372.393241]        00000000 00000225 f7d50030 f7d501e4 c19fb180
00000000 c0758e40 d67a1340
[ 2372.393255]        d9b9d300 00000000 d5ac5bc0 00000000 c0453b7a
001f5b9f 00003d6a 00000000
[ 2372.393270] Call Trace:
[ 2372.393300]  [<c0453b7a>] handle_edge_irq+0x0/0xff
[ 2372.393324]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.393343]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.393357]  [<c0478174>] pipe_poll+0x24/0x7a
[ 2372.393370]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.393391]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.393408]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.393426]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.393439]  [<c041fa31>] enqueue_task+0x49/0x58
[ 2372.393455]  [<c0420113>] __check_preempt_curr_fair+0x20/0x3f
[ 2372.393471]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.393488]  [<c04203b2>] balance_tasks+0xb2/0x13e
[ 2372.393507]  [<c04e5c08>] __next_cpu+0x12/0x21
[ 2372.393516]  [<c041f54f>] find_busiest_group+0x1c4/0x54c
[ 2372.393532]  [<c041ff13>] update_curr+0x237/0x258
[ 2372.393559]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.393591]  [<c041fa31>] enqueue_task+0x49/0x58
[ 2372.393607]  [<c0420113>] __check_preempt_curr_fair+0x20/0x3f
[ 2372.393622]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.393639]  [<c04203b2>] balance_tasks+0xb2/0x13e
[ 2372.393659]  [<c0425b16>] load_balance_fair+0x10e/0x14a
[ 2372.393692]  [<c04256e1>] load_balance_start_fair+0x0/0x21
[ 2372.393702]  [<c0420709>] load_balance_next_fair+0x0/0x21
[ 2372.393716]  [<c041fc73>] update_stats_wait_end+0xaf/0xda
[ 2372.393726]  [<c041ef8a>] move_tasks+0x53/0x76
[ 2372.393752]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.393760]  [<c062497c>] __sched_text_start+0x6bc/0x729
[ 2372.393792]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.393801]  [<c043ab2c>] lock_hrtimer_base+0x15/0x2f
[ 2372.393815]  [<c043abd9>] hrtimer_try_to_cancel+0x5f/0x67
[ 2372.393832]  [<c043abeb>] hrtimer_cancel+0xa/0x14
[ 2372.393843]  [<c0625407>] do_nanosleep+0x48/0x6c
[ 2372.393856]  [<c043ad33>] hrtimer_nanosleep+0x50/0xf3
[ 2372.393874]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.393886]  [<c06253f5>] do_nanosleep+0x36/0x6c
[ 2372.393913]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.393925]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.393958]  =======================
[ 2372.393962] beagled       S 00000039  3036  4418      1
[ 2372.393972]        d5ac7e24 00200086 8b72df0c 00000039 c1a00b40
00000002 01e84800 d5ac7000
[ 2372.393987]        53c5087b 00000228 d67a1970 d67a1b24 c1a04180
00000001 c1a01200 d5ac7e88
[ 2372.394002]        d9b9d300 00000000 00000000 c043a7f7 00200282
00200282 00004e85 00000000
[ 2372.394017] Call Trace:
[ 2372.394045]  [<c043a7f7>] enqueue_hrtimer+0x5a/0x62
[ 2372.394071]  [<c043f6bd>] futex_wait+0x213/0x2c8
[ 2372.394115]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.394127]  [<c043f6ae>] futex_wait+0x204/0x2c8
[ 2372.394146]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.394165]  [<c043fac8>] do_futex+0x69/0x93b
[ 2372.394184]  [<c0409466>] restore_i387+0x84/0xe7
[ 2372.394197]  [<c04042cb>] restore_sigcontext+0x162/0x1b3
[ 2372.394214]  [<c043c017>] getnstimeofday+0x30/0xbd
[ 2372.394230]  [<c043ae70>] ktime_get_ts+0x16/0x44
[ 2372.394242]  [<c043aead>] ktime_get+0xf/0x2e
[ 2372.394257]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.394283]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.394315]  =======================
[ 2372.394319] beagled       S 00000005  2468  4514      1
[ 2372.394329]        ec6a6be4 00000086 cbbbdb4c 00000005 c1a00b40
00000002 ec6a6bcc ec6a6000
[ 2372.394344]        a05cddf8 0000003b d00526e0 d0052894 c1a04180
00000001 c0758e40 d0053970
[ 2372.394359]        d9b9d300 00000000 00000000 00000000 00000000
ffff165e 000101fb 00000000
[ 2372.394373] Call Trace:
[ 2372.394419]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.394439]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.394451]  [<c0478174>] pipe_poll+0x24/0x7a
[ 2372.394465]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.394485]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.394502]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.394527]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.394565]  [<c04e5c08>] __next_cpu+0x12/0x21
[ 2372.394574]  [<c041f54f>] find_busiest_group+0x1c4/0x54c
[ 2372.394635]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.394651]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.394692]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.394715]  [<c042c1bd>] current_fs_time+0x41/0x46
[ 2372.394735]  [<c0479022>] pipe_read+0x311/0x31d
[ 2372.394768]  [<c04730c3>] do_sync_read+0xc7/0x10a
[ 2372.394787]  [<c041fc73>] update_stats_wait_end+0xaf/0xda
[ 2372.394817]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.394825]  [<c062497c>] __sched_text_start+0x6bc/0x729
[ 2372.394855]  [<c04739de>] vfs_read+0x118/0x152
[ 2372.394878]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.394890]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.394923]  =======================
[ 2372.394927] beagled       S 00000005  2460  4526      1
[ 2372.394936]        d57a6be4 00000086 cbf8b791 00000005 d57a6bc8
00000000 d57a6bcc d57a6000
[ 2372.394951]        00000001 0000003b d018d8f0 d018daa4 c1a04180
00000001 c0758e40 d8f3e070
[ 2372.394966]        d9b9d300 00000000 c1a00120 c1a00120 00000000
ffff16b6 00000000 00000000
[ 2372.394981] Call Trace:
[ 2372.395026]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.395045]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.395057]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.395072]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.395093]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.395110]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.395127]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.395145]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.395162]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.395179]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.395196]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.395213]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.395231]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.395248]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.395269]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.395289]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.395308]  [<c061d7a5>] unix_write_space+0x15/0x77
[ 2372.395317]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.395331]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.395342]  [<c05bfa35>] __kfree_skb+0xa3/0xfa
[ 2372.395359]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.395404]  [<c042c1bd>] current_fs_time+0x41/0x46
[ 2372.395422]  [<c0478c87>] pipe_write+0x393/0x3ec
[ 2372.395475]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.395491]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.395499]  [<c062497c>] __sched_text_start+0x6bc/0x729
[ 2372.395530]  [<c047388c>] vfs_write+0x11a/0x154
[ 2372.395553]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.395565]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.395599]  =======================
[ 2372.395604] beagled       S 00000039  2764  4543      1
[ 2372.395613]        cfe3dd14 00200086 83bf05dd 00000039 c19f7b40
00000002 cfe3dcfc cfe3d000
[ 2372.395628]        9927b865 00000227 cfdda6e0 cfdda894 c1a04180
00000001 c0758e40 c0713380
[ 2372.395643]        d9b9d300 00000000 00000000 00200046 00000000
001eea53 00009617 00000000
[ 2372.395657] Call Trace:
[ 2372.395703]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.395716]  [<c04057eb>] common_interrupt+0x23/0x28
[ 2372.395736]  [<c043865f>] prepare_to_wait+0x24/0x3f
[ 2372.395750]  [<c061c03e>] unix_stream_recvmsg+0x1ef/0x4dd
[ 2372.395759]  [<c041ff13>] update_curr+0x237/0x258
[ 2372.395792]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.395812]  [<c05ba959>] sock_recvmsg+0xec/0x107
[ 2372.395843]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.395861]  [<c04091e1>] convert_fxsr_to_user+0x103/0x157
[ 2372.395894]  [<c046456f>] find_extend_vma+0x12/0x49
[ 2372.395907]  [<c043eb6c>] get_futex_key+0x6e/0x122
[ 2372.395924]  [<c05bb857>] sys_recvfrom+0xd7/0x12b
[ 2372.395937]  [<c043fa55>] futex_wake+0xa9/0xb3
[ 2372.395955]  [<c040901d>] convert_fxsr_from_user+0x2b/0xec
[ 2372.395977]  [<c0409466>] restore_i387+0x84/0xe7
[ 2372.395990]  [<c04042cb>] restore_sigcontext+0x162/0x1b3
[ 2372.396024]  [<c05bbde4>] sys_socketcall+0x1cd/0x261
[ 2372.396052]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.396084]  =======================
[ 2372.396088] gnome-power-m S 00000039  2244  4347      1
[ 2372.396097]        d80d6be4 00000082 8b86ed67 00000039 d80d6bc8
00000000 d80d6bcc d80d6000
[ 2372.396112]        00000001 00000228 d8149970 d8149b24 c1a04180
00000001 c0758e40 f7d02000
[ 2372.396127]        d80d7d40 d80d6bd4 c0625f0f f7d02000 c042fb7a
001f6804 00000286 00000286
[ 2372.396142] Call Trace:
[ 2372.396169]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.396179]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.396204]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.396221]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.396233]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.396252]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.396273]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.396289]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.396307]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.396324]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.396341]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.396359]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.396375]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.396393]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.396410]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.396434]  [<c0421b7a>] task_rq_lock+0x31/0x58
[ 2372.396449]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.396481]  [<c061d7a5>] unix_write_space+0x15/0x77
[ 2372.396489]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.396502]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.396513]  [<c05bfa35>] __kfree_skb+0xa3/0xfa
[ 2372.396531]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.396576]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.396590]  [<c0472eb5>] do_sync_readv_writev+0xc1/0xfe
[ 2372.396647]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.396667]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.396681]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.396691]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.396703]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.396722]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.396739]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.396750]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.396782]  =======================
[ 2372.396787] pam-panel-ico S 00000033  2460  4349      1
[ 2372.396796]        d8c35be4 00000082 dda3ed13 00000033 d8c35bc8
00000000 d8c35bcc d8c35000
[ 2372.396811]        00000000 0000021e d8149340 d81494f4 c19fb180
00000000 c0758e40 c0713380
[ 2372.396825]        d80d7b40 d81499a0 c1a041dc 00000046 c04206eb
001f4f3f 00000000 00000000
[ 2372.396840] Call Trace:
[ 2372.396870]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.396894]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.396914]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.396933]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.396954]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.396970]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.396988]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.397005]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.397037]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.397079]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.397099]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.397130]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.397150]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.397169]  [<c05bdebc>] sock_def_readable+0x3c/0x66
[ 2372.397184]  [<c061d11c>] unix_stream_sendmsg+0x246/0x311
[ 2372.397217]  [<c05b9fed>] sock_aio_write+0xf6/0x102
[ 2372.397256]  [<c0472fb9>] do_sync_write+0xc7/0x10a
[ 2372.397287]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.397307]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.397320]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.397330]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.397342]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.397357]  [<c047da71>] vfs_ioctl+0x237/0x249
[ 2372.397378]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.397390]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.397423]  =======================
[ 2372.397428] escd          S 00000004  2308  4356      1
[ 2372.397437]        d8717be4 00000086 5e0f79ae 00000004 c047dfb2
00000001 d87b6500 d8717000
[ 2372.397452]        5381486a 0000002c f7d4c070 f7d4c224 c1a04180
00000001 00738010 00000000
[ 2372.397467]        f70027c0 d8717e4c d8717e50 d8717e54 00000020
00000000 000437df 00000000
[ 2372.397481] Call Trace:
[ 2372.397491]  [<c047dfb2>] poll_freewait+0x18/0x4c
[ 2372.397535]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.397553]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.397566]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.397580]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.397601]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.397618]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.397640]  [<f898f866>] __ext3_journal_dirty_metadata+0x16/0x3a [ext3]
[ 2372.397674]  [<c041fc73>] update_stats_wait_end+0xaf/0xda
[ 2372.397703]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.397711]  [<c062497c>] __sched_text_start+0x6bc/0x729
[ 2372.397760]  [<c04247bc>] __cond_resched+0x25/0x3c
[ 2372.397771]  [<c0624a4f>] cond_resched+0x26/0x31
[ 2372.397781]  [<c04581f2>] generic_file_buffered_write+0x4dd/0x5e4
[ 2372.397826]  [<c05bf3f5>] skb_dequeue+0x39/0x3f
[ 2372.397839]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.397882]  [<c0625f04>] _read_unlock_irq+0x5/0x7
[ 2372.397890]  [<c0456f7f>] find_lock_page+0x7c/0x83
[ 2372.397903]  [<c0458e26>] filemap_fault+0x21a/0x379
[ 2372.397913]  [<c045884a>] generic_file_aio_write+0x61/0xb6
[ 2372.397939]  [<c0460c55>] __do_fault+0x2ea/0x315
[ 2372.397969]  [<c0462ab4>] handle_mm_fault+0x318/0x66c
[ 2372.398003]  [<c06275c4>] do_page_fault+0x272/0x594
[ 2372.398037]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.398048]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.398081]  =======================
[ 2372.398085] escd          S 00000039  2832  4363      1
[ 2372.398095]        d7bd3f2c 00000086 8b8b1bb4 00000039 d7bd3f10
00000000 c047bc80 d7bd3000
[ 2372.398110]        00000001 d7bd3ef8 d8f3e6a0 d8f3e854 c1a04180
00000001 c0758e40 d7bd3f4c
[ 2372.398125]        f70027c0 00000000 00000000 c043a7f7 00000282
001f6810 c1a011f8 c043acd9
[ 2372.398139] Call Trace:
[ 2372.398151]  [<c047bc80>] do_path_lookup+0x16a/0x1cf
[ 2372.398176]  [<c043a7f7>] enqueue_hrtimer+0x5a/0x62
[ 2372.398189]  [<c043acd9>] hrtimer_start+0xe4/0xee
[ 2372.398209]  [<c0625400>] do_nanosleep+0x41/0x6c
[ 2372.398223]  [<c043ad33>] hrtimer_nanosleep+0x50/0xf3
[ 2372.398241]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.398253]  [<c06253f5>] do_nanosleep+0x36/0x6c
[ 2372.398279]  [<c043ae1f>] sys_nanosleep+0x49/0x59
[ 2372.398293]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.398325]  =======================
[ 2372.398329] pam_timestamp S 00000039  2300  4358   4349
[ 2372.398338]        d86cdb44 00000086 7bb956dc 00000039 d86cdb28
00000000 d86cdb2c d86cd000
[ 2372.398353]        00000001 0000021e f77d32c0 f77d3474 c1a04180
00000001 c0758e40 f7d02000
[ 2372.398368]        d9b9d100 d86cdb34 c0625f0f f7d02000 c042fb7a
001f4ebc 00000286 00000286
[ 2372.398383] Call Trace:
[ 2372.398411]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.398421]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.398447]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.398463]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.398476]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.398495]  [<c047e6ad>] do_select+0x369/0x3c0
[ 2372.398528]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.398544]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.398577]  [<c048efe6>] __getblk+0x3b/0x29e
[ 2372.398590]  [<c048ec5d>] __find_get_block_slow+0x11b/0x125
[ 2372.398623]  [<f89855b3>] ext3_getblk+0x10b/0x25a [ext3]
[ 2372.398680]  [<f898961f>] ext3_find_entry+0x569/0x58d [ext3]
[ 2372.398710]  [<c0462dd8>] handle_mm_fault+0x63c/0x66c
[ 2372.398724]  [<c041ff13>] update_curr+0x237/0x258
[ 2372.398751]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.398763]  [<c047b9e6>] link_path_walk+0xa9/0xb3
[ 2372.398801]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.398822]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.398848]  [<c047e9d6>] core_sys_select+0x2d2/0x2f3
[ 2372.398862]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.398882]  [<c042c1bd>] current_fs_time+0x41/0x46
[ 2372.398901]  [<c0478c87>] pipe_write+0x393/0x3ec
[ 2372.398931]  [<c0472fb9>] do_sync_write+0xc7/0x10a
[ 2372.398962]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.398998]  [<c047ed52>] sys_select+0xa0/0x188
[ 2372.399015]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.399035]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.399067]  =======================
[ 2372.399072] netstat       ? 00000004  2912  4361   4356
[ 2372.399081]        d78c9f6c 00000046 5d18c274 00000004 c1a00b40
00000002 d78c9f54 d78c9000
[ 2372.399096]        4ef9e8d8 0000002c d8f3ecd0 d8f3ee84 c1a04180
00000001 d7a37358 d86de900
[ 2372.399111]        f70027c0 c0485b5c d86de900 d871c540 c0471a71
fffe1528 00001d0d 00000000
[ 2372.399126] Call Trace:
[ 2372.399152]  [<c0485b5c>] mntput_no_expire+0x11/0x6e
[ 2372.399165]  [<c0471a71>] filp_close+0x51/0x58
[ 2372.399187]  [<c042b205>] do_exit+0x767/0x76b
[ 2372.399199]  [<c047388c>] vfs_write+0x11a/0x154
[ 2372.399219]  [<c042b276>] sys_exit_group+0x0/0xd
[ 2372.399231]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.399252]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.399271]  =======================
[ 2372.399276] wnck-applet   S 00000039  2460  4394      1
[ 2372.399285]        d7ca6be4 00200082 8bb406d9 00000039 c19f7b40
00000002 d7ca6bcc d7ca6000
[ 2372.399300]        59a6b1f3 00000228 f7172cd0 f7172e84 c1a04180
00000001 c0758e40 f778b300
[ 2372.399315]        e1489c80 d7ca6bf4 d7ca6bd4 c0625f0f c0812e80
001f6295 0002596f 00000000
[ 2372.399330] Call Trace:
[ 2372.399358]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.399383]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.399401]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.399414]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.399428]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.399449]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.399465]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.399483]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.399500]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.399517]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.399534]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.399552]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.399569]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.399586]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.399603]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.399620]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.399645]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.399664]  [<c061d7dd>] unix_write_space+0x4d/0x77
[ 2372.399678]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.399689]  [<c05bfa35>] __kfree_skb+0xa3/0xfa
[ 2372.399706]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.399751]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.399765]  [<c0472eb5>] do_sync_readv_writev+0xc1/0xfe
[ 2372.399810]  [<c041fc73>] update_stats_wait_end+0xaf/0xda
[ 2372.399838]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.399846]  [<c062497c>] __sched_text_start+0x6bc/0x729
[ 2372.399879]  [<c047da71>] vfs_ioctl+0x237/0x249
[ 2372.399899]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.399911]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.399934]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.399953]  =======================
[ 2372.399957] mapping-daemo S 00000039  2468  4396      1
[ 2372.399966]        d69e1be4 00200086 89ef7dc6 00000039 d69e1bc8
00000000 d69e1bcc d69e1000
[ 2372.399981]        00000001 00000226 d8148d10 d8148ec4 c1a04180
00000001 c0758e40 f7d02000
[ 2372.399996]        d9b9d700 d69e1bd4 c0625f0f f7d02000 c042fb7a
001f62c8 00200286 00200286
[ 2372.400011] Call Trace:
[ 2372.400038]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.400048]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.400073]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.400090]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.400102]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.400121]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.400141]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.400158]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400175]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400191]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.400224]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.400241]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.400273]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.400293]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.400324]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.400344]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.400363]  [<c05bdebc>] sock_def_readable+0x3c/0x66
[ 2372.400378]  [<c061d11c>] unix_stream_sendmsg+0x246/0x311
[ 2372.400411]  [<c05b9fed>] sock_aio_write+0xf6/0x102
[ 2372.400425]  [<c045ac8a>] get_page_from_freelist+0x23e/0x2b1
[ 2372.400457]  [<c0472fb9>] do_sync_write+0xc7/0x10a
[ 2372.400488]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.400532]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.400549]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.400561]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.400592]  =======================
[ 2372.400597] trashapplet   S 00000032  2468  4401      1
[ 2372.400606]        d6483be4 00200082 904f27fa 00000032 d6483bc8
00000000 d6483bcc d6483000
[ 2372.400621]        00000000 0000021b d6a68030 d6a681e4 c19fb180
00000000 c0758e40 c0713380
[ 2372.400636]        ed427940 d6483bf4 d6483bd4 c0625f0f c0812e80
001e912b 0010fa2d 00000000
[ 2372.400650] Call Trace:
[ 2372.400679]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.400703]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.400721]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.400733]  [<c062525c>] mutex_lock+0x1a/0x29
[ 2372.400742]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.400756]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.400777]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.400794]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400811]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400829]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400846]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400863]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400880]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400897]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400914]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400931]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400948]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400965]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.400983]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401007]  [<c05c00b6>] __alloc_skb+0x49/0xf7
[ 2372.401024]  [<c05bc8fe>] sock_alloc_send_skb+0x74/0x1a5
[ 2372.401042]  [<c05bde95>] sock_def_readable+0x15/0x66
[ 2372.401051]  [<c05bf32b>] skb_queue_tail+0x11/0x2d
[ 2372.401065]  [<c061d11c>] unix_stream_sendmsg+0x246/0x311
[ 2372.401097]  [<c05b9fed>] sock_aio_write+0xf6/0x102
[ 2372.401112]  [<c045ac8a>] get_page_from_freelist+0x23e/0x2b1
[ 2372.401166]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.401186]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.401199]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.401209]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.401221]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.401236]  [<c047da71>] vfs_ioctl+0x237/0x249
[ 2372.401257]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.401269]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.401292]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.401310]  =======================
[ 2372.401315] timer-applet  S 00000033  2356  4403      1
[ 2372.401324]        d6481be4 00200086 efd5f752 00000033 d6481bc8
00000000 d6481bcc d6481000
[ 2372.401339]        00000000 00000228 d64cd930 d64cdae4 c19fb180
00000000 c0758e40 c0812e80
[ 2372.401353]        e144b4c0 d6481bd4 c0625f0f c0812e80 c042fb7a
001f6683 00200282 00200282
[ 2372.401368] Call Trace:
[ 2372.401396]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.401407]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.401432]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.401448]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.401460]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.401479]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.401500]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.401517]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401535]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401552]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401569]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401586]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401603]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401620]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401637]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401654]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401671]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401688]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.401701]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.401729]  [<c05c00b6>] __alloc_skb+0x49/0xf7
[ 2372.401746]  [<c05bc8fe>] sock_alloc_send_skb+0x74/0x1a5
[ 2372.401764]  [<c05bde95>] sock_def_readable+0x15/0x66
[ 2372.401773]  [<c05bf32b>] skb_queue_tail+0x11/0x2d
[ 2372.401786]  [<c061d11c>] unix_stream_sendmsg+0x246/0x311
[ 2372.401819]  [<c05b9fed>] sock_aio_write+0xf6/0x102
[ 2372.401833]  [<c045ac8a>] get_page_from_freelist+0x23e/0x2b1
[ 2372.401888]  [<c0406f0f>] do_IRQ+0xbd/0xd2
[ 2372.401907]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.401920]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.401930]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.401942]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.401961]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.401978]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.401989]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.402022]  =======================
[ 2372.402026] gam_server    S 00000033  2468  4415      1
[ 2372.402035]        d5d19be4 00000086 efffca85 00000033 d5d19bc8
00000000 d5d19bcc d5d19000
[ 2372.402050]        00000000 00000226 f778b930 f778bae4 c19fb180
00000000 c0758e40 c0812e80
[ 2372.402065]        f770e9c0 d5d19bd4 c0625f0f c0812e80 c042fb7a
001f67c3 00000282 00000282
[ 2372.402079] Call Trace:
[ 2372.402107]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.402117]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.402142]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.402159]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.402171]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.402190]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.402211]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.402228]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.402245]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.402262]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.402280]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.402297]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.402314]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.402327]  [<c048ec5d>] __find_get_block_slow+0x11b/0x125
[ 2372.402343]  [<f8984d35>] ext3_get_blocks_handle+0xbc/0x82f [ext3]
[ 2372.402377]  [<c048efa1>] __find_get_block+0x141/0x14b
[ 2372.402403]  [<f8991b06>] ext3_get_acl+0x2b1/0x2bb [ext3]
[ 2372.402440]  [<c0481fd2>] __d_lookup+0xbc/0xee
[ 2372.402453]  [<c0406f0f>] do_IRQ+0xbd/0xd2
[ 2372.402462]  [<c0406f0f>] do_IRQ+0xbd/0xd2
[ 2372.402476]  [<c04057eb>] common_interrupt+0x23/0x28
[ 2372.402488]  [<c0406f0f>] do_IRQ+0xbd/0xd2
[ 2372.402502]  [<f8991b06>] ext3_get_acl+0x2b1/0x2bb [ext3]
[ 2372.402538]  [<c0481fd2>] __d_lookup+0xbc/0xee
[ 2372.402564]  [<c0485b5c>] mntput_no_expire+0x11/0x6e
[ 2372.402577]  [<c047b917>] __link_path_walk+0xbae/0xbd4
[ 2372.402606]  [<c0485b5c>] mntput_no_expire+0x11/0x6e
[ 2372.402639]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.402659]  [<c047bc80>] do_path_lookup+0x16a/0x1cf
[ 2372.402669]  [<c047aabe>] getname+0x59/0xad
[ 2372.402683]  [<c047c45d>] __user_walk_fd+0x38/0x40
[ 2372.402699]  [<c047c5a1>] __user_walk+0x14/0x16
[ 2372.402709]  [<c0497113>] sys_inotify_add_watch+0x61/0x146
[ 2372.402741]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.402758]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.402770]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.402802]  =======================
[ 2372.402807] wpa_supplican S 00000039  2236  4425      1
[ 2372.402815]        d4386b44 00200086 8b678142 00000039 d4386b28
00000000 d4386b2c d4386000
[ 2372.402830]        00000001 00000228 d6a698f0 d6a69aa4 c1a04180
00000001 c0758e40 f7d02000
[ 2372.402845]        c1bc9900 d4386b34 c0625f0f f7d02000 c042fb7a
001f679c 00200286 00200286
[ 2372.402860] Call Trace:
[ 2372.402888]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.402899]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.402925]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.402942]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.402954]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.402973]  [<c047e6ad>] do_select+0x369/0x3c0
[ 2372.403006]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.403023]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403041]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403058]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403076]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403089]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.403107]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.403138]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.403157]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.403176]  [<c05bdebc>] sock_def_readable+0x3c/0x66
[ 2372.403191]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.403204]  [<c05c12a9>] memcpy_toiovec+0x27/0x4a
[ 2372.403227]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.403246]  [<c05d8f0c>] netlink_recvmsg+0x29e/0x2bd
[ 2372.403282]  [<c05ba959>] sock_recvmsg+0xec/0x107
[ 2372.403321]  [<c047e9d6>] core_sys_select+0x2d2/0x2f3
[ 2372.403346]  [<c0625f04>] _read_unlock_irq+0x5/0x7
[ 2372.403355]  [<c0456f7f>] find_lock_page+0x7c/0x83
[ 2372.403371]  [<c045ac8a>] get_page_from_freelist+0x23e/0x2b1
[ 2372.403383]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.403397]  [<c05bb598>] move_addr_to_user+0x50/0x68
[ 2372.403411]  [<c05bb888>] sys_recvfrom+0x108/0x12b
[ 2372.403428]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.403461]  [<c0420169>] __rq_clock+0x1c/0xab
[ 2372.403477]  [<c04243db>] scheduler_tick+0x14c/0x175
[ 2372.403504]  [<c047ed52>] sys_select+0xa0/0x188
[ 2372.403521]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.403542]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.403563]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.403582]  =======================
[ 2372.403586] notification- S 00000032  2460  4431      1
[ 2372.403595]        d3c5dbe4 00000086 904eacd3 00000032 d3c5dbc8
00000000 d3c5dbcc d3c5d000
[ 2372.403610]        00000000 0000021b f778acd0 f778ae84 c19fb180
00000000 c0758e40 c0713380
[ 2372.403625]        d9b9dd00 d3c5dbf4 d3c5dbd4 c0625f0f c0812e80
001e912b 00000000 00000000
[ 2372.403640] Call Trace:
[ 2372.403668]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.403693]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.403711]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.403723]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.403737]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.403758]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.403775]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403792]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403809]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403826]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403843]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403861]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403878]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403895]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403912]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403929]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.403952]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.403978]  [<c05c00b6>] __alloc_skb+0x49/0xf7
[ 2372.403996]  [<c05bc8fe>] sock_alloc_send_skb+0x74/0x1a5
[ 2372.404014]  [<c05bde95>] sock_def_readable+0x15/0x66
[ 2372.404023]  [<c05bf32b>] skb_queue_tail+0x11/0x2d
[ 2372.404037]  [<c061d11c>] unix_stream_sendmsg+0x246/0x311
[ 2372.404070]  [<c05b9fed>] sock_aio_write+0xf6/0x102
[ 2372.404083]  [<c0472eb5>] do_sync_readv_writev+0xc1/0xfe
[ 2372.404139]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.404159]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.404172]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.404182]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.404194]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.404209]  [<c047da71>] vfs_ioctl+0x237/0x249
[ 2372.404230]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.404242]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.404276]  =======================
[ 2372.404281] clock-applet  S 00000033  2468  4433      1
[ 2372.404290]        d3c95be4 00000082 81cb3fa9 00000033 d3c95bc8
00000000 d3c95bcc d3c95000
[ 2372.404305]        00000000 0000021b d6a68c90 d6a68e44 c19fb180
00000000 c0758e40 c0812e80
[ 2372.404319]        f715f880 d3c95bd4 c0625f0f c0812e80 c042fb7a
001f14a4 00000282 00000282
[ 2372.404334] Call Trace:
[ 2372.404362]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.404373]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.404398]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.404414]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.404427]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.404446]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.404467]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.404484]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.404502]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.404519]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.404536]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.404553]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.404570]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.404587]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.404604]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.404621]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.404638]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.404652]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.404684]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.404704]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.404723]  [<c05bdebc>] sock_def_readable+0x3c/0x66
[ 2372.404738]  [<c061d11c>] unix_stream_sendmsg+0x246/0x311
[ 2372.404762]  [<c0485b5c>] mntput_no_expire+0x11/0x6e
[ 2372.404779]  [<c05b9fed>] sock_aio_write+0xf6/0x102
[ 2372.404841]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.404861]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.404875]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.404885]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.404897]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.404916]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.404934]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.404945]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.404978]  =======================
[ 2372.404982] mixer_applet2 S 00000039  2176  4435      1
[ 2372.404991]        d3cd3be4 00000086 8b73b151 00000039 d3cd3bc8
00000000 d3cd3bcc d3cd3000
[ 2372.405006]        00000001 00000228 d67a06e0 d67a0894 c1a04180
00000001 c0758e40 f7d02000
[ 2372.405021]        e144b6c0 d3cd3bd4 c0625f0f f7d02000 c042fb7a
001f67d0 00000286 00000286
[ 2372.405036] Call Trace:
[ 2372.405063]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.405073]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.405098]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.405115]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.405128]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.405146]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.405167]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.405184]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405202]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405219]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405236]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405253]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405270]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405287]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405304]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405321]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405338]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405352]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.405371]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.405397]  [<c05c00b6>] __alloc_skb+0x49/0xf7
[ 2372.405414]  [<c05bc8fe>] sock_alloc_send_skb+0x74/0x1a5
[ 2372.405432]  [<c05bde95>] sock_def_readable+0x15/0x66
[ 2372.405441]  [<c05bf32b>] skb_queue_tail+0x11/0x2d
[ 2372.405455]  [<c061d11c>] unix_stream_sendmsg+0x246/0x311
[ 2372.405488]  [<c05b9fed>] sock_aio_write+0xf6/0x102
[ 2372.405501]  [<c0472eb5>] do_sync_readv_writev+0xc1/0xfe
[ 2372.405546]  [<f89e66bd>] snd_ctl_read+0x0/0x19f [snd]
[ 2372.405573]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.405582]  [<f89e683f>] snd_ctl_read+0x182/0x19f [snd]
[ 2372.405613]  [<c0406f0f>] do_IRQ+0xbd/0xd2
[ 2372.405631]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.405644]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.405654]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.405666]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.405684]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.405701]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.405712]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.405743]  =======================
[ 2372.405747] dhclient      S 00000031  2032  4438   3928
[ 2372.405757]        f49b8b44 00000086 f8bc0124 00000031 f49b8b28
00000000 f49b8b2c f49b8000
[ 2372.405772]        00000000 0000019a f71500b0 f7150264 c19fb180
00000000 c0758e40 c0812e80
[ 2372.405786]        c1bc9d00 f49b8b34 c0625f0f c0812e80 c042fb7a
001dfff9 00000282 00000282
[ 2372.405801] Call Trace:
[ 2372.405828]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.405838]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.405863]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.405879]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.405892]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.405910]  [<c047e6ad>] do_select+0x369/0x3c0
[ 2372.405941]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.405957]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405974]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.405996]  [<f886fb85>] do_get_write_access+0x494/0x4c1 [jbd]
[ 2372.406022]  [<f89846c2>] __ext3_get_inode_loc+0x10f/0x305 [ext3]
[ 2372.406059]  [<f89846c2>] __ext3_get_inode_loc+0x10f/0x305 [ext3]
[ 2372.406084]  [<c0456e39>] find_get_page+0x41/0x47
[ 2372.406098]  [<f898f866>] __ext3_journal_dirty_metadata+0x16/0x3a [ext3]
[ 2372.406128]  [<f886fbd3>] journal_get_write_access+0x21/0x26 [jbd]
[ 2372.406154]  [<f898454d>] ext3_mark_iloc_dirty+0x27f/0x2e5 [ext3]
[ 2372.406195]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.406217]  [<c05c00b6>] __alloc_skb+0x49/0xf7
[ 2372.406234]  [<c05bc8fe>] sock_alloc_send_skb+0x74/0x1a5
[ 2372.406252]  [<c05bde95>] sock_def_readable+0x15/0x66
[ 2372.406261]  [<c05bf32b>] skb_queue_tail+0x11/0x2d
[ 2372.406274]  [<c061bdcf>] unix_dgram_sendmsg+0x3f0/0x470
[ 2372.406308]  [<c05baa44>] sock_sendmsg+0xd0/0xeb
[ 2372.406319]  [<c0481fd2>] __d_lookup+0xbc/0xee
[ 2372.406342]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.406356]  [<c047b802>] __link_path_walk+0xa99/0xbd4
[ 2372.406373]  [<c047e9d6>] core_sys_select+0x2d2/0x2f3
[ 2372.406396]  [<c047b9e6>] link_path_walk+0xa9/0xb3
[ 2372.406421]  [<c05bb3a0>] sys_sendto+0x118/0x138
[ 2372.406442]  [<c047bc80>] do_path_lookup+0x16a/0x1cf
[ 2372.406454]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.406468]  [<c0475d48>] cp_new_stat64+0xfc/0x10e
[ 2372.406514]  [<c047ed52>] sys_select+0xa0/0x188
[ 2372.406530]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.406549]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.406570]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.406588]  =======================
[ 2372.406592] notification- S 00000039  2272  4458      1
[ 2372.406601]        d3988be4 00200086 8b980625 00000039 c1a00b40
00000002 d3988bcc d3988000
[ 2372.406616]        598ab174 00000228 d3f64c90 d3f64e44 c1a04180
00000001 c0758e40 f778b300
[ 2372.406631]        e144bac0 00000001 c042934c c1a00120 00200046
001f6273 00000000 00000000
[ 2372.406647] Call Trace:
[ 2372.406672]  [<c042934c>] profile_tick+0x43/0x5e
[ 2372.406696]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.406714]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.406726]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.406740]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.406759]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.406775]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.406792]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.406809]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.406826]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.406842]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.406859]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.406876]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.406891]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.406921]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.406940]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.406958]  [<c061d7a5>] unix_write_space+0x15/0x77
[ 2372.406972]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.406983]  [<c05bfa35>] __kfree_skb+0xa3/0xfa
[ 2372.407000]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.407041]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.407055]  [<c0472eb5>] do_sync_readv_writev+0xc1/0xfe
[ 2372.407108]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.407128]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.407140]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.407150]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.407162]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.407177]  [<c047da71>] vfs_ioctl+0x237/0x249
[ 2372.407196]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.407208]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.407239]  =======================
[ 2372.407244] firefox       S 00000004  2564  4460      1
[ 2372.407253]        d35b9f34 00000082 f53c6c89 00000004 d35b9f18
00000000 00000008 d35b9000
[ 2372.407268]        00000001 080fddf8 d64cc070 d64cc224 c1a04180
00000001 c0758e40 d35d4668
[ 2372.407283]        d35e4d80 d35973f4 d35d4668 c0462d87 d35973f4
fffe4ba2 00000246 f77adc88
[ 2372.407298] Call Trace:
[ 2372.407324]  [<c0462d87>] handle_mm_fault+0x5eb/0x66c
[ 2372.407348]  [<c042a8e3>] do_wait+0x918/0xa13
[ 2372.407372]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.407384]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.407401]  [<c042aa0f>] sys_wait4+0x31/0x34
[ 2372.407412]  [<c042aa39>] sys_waitpid+0x27/0x2b
[ 2372.407426]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.407456]  =======================
[ 2372.407460] run-mozilla.s S 00000004  2596  4484   4460
[ 2372.407469]        d3668f34 00000086 aea101e3 00000004 d3668f18
00000000 00000008 d3668000
[ 2372.407484]        00000000 080f6c78 d3f658f0 d3f65aa4 c19fb180
00000000 c0758e40 d35c2b54
[ 2372.407499]        c1bc9b00 d36813d8 d35c2b54 c0462d87 d36813d8
fffe4c2f 00000246 d3f56908
[ 2372.407514] Call Trace:
[ 2372.407540]  [<c0462d87>] handle_mm_fault+0x5eb/0x66c
[ 2372.407564]  [<c042a8e3>] do_wait+0x918/0xa13
[ 2372.407587]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.407599]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.407616]  [<c042aa0f>] sys_wait4+0x31/0x34
[ 2372.407627]  [<c042aa39>] sys_waitpid+0x27/0x2b
[ 2372.407640]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.407661]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.407679]  =======================
[ 2372.407683] firefox-bin   S 00000039  2148  4489   4484
[ 2372.407692]        d36bcbe4 00000086 8ba7f455 00000039 d36bcbc8
00000000 d36bcbcc d36bc000
[ 2372.407707]        599a9f7f 00000228 d64cccd0 d64cce84 c1a04180
00000001 00000286 f7d02000
[ 2372.407722]        e144bcc0 d36bcbd4 c0625f0f f7d02000 c042fb7a
d36bcbf4 00000000 00000000
[ 2372.407737] Call Trace:
[ 2372.407762]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.407772]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.407787]  [<c042fc91>] __mod_timer+0x9d/0xa7
[ 2372.407804]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.407820]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.407832]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.407850]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.407870]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.407886]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.407903]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.407919]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.407935]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.407952]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.407969]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.407985]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.408001]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.408020]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.408040]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.408069]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.408088]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.408106]  [<c05bdebc>] sock_def_readable+0x3c/0x66
[ 2372.408121]  [<c061d11c>] unix_stream_sendmsg+0x246/0x311
[ 2372.408153]  [<c05b9fed>] sock_aio_write+0xf6/0x102
[ 2372.408199]  [<c041fc73>] update_stats_wait_end+0xaf/0xda
[ 2372.408228]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.408241]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.408251]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.408263]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.408281]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.408298]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.408309]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.408339]  =======================
[ 2372.408343] firefox-bin   D 00000039  1784  4490   4484
[ 2372.408352]        d322cd18 00000086 2d7a326c 00000039 d322ccfc
00000000 00000000 d322c000
[ 2372.408367]        00000001 00000202 d64cd300 d64cd4b4 c1a04180
00000001 c0758e40 c05bf32b
[ 2372.408382]        e144bcc0 f768be00 ffffff97 c05d78ed 000000d0
001f179c f7fff080 c073e834
[ 2372.408397] Call Trace:
[ 2372.408419]  [<c05bf32b>] skb_queue_tail+0x11/0x2d
[ 2372.408433]  [<c05d78ed>] netlink_dump+0x77/0x164
[ 2372.408456]  [<c062538d>] __mutex_lock_slowpath+0x4d/0x7f
[ 2372.408474]  [<c0625268>] mutex_lock+0x26/0x29
[ 2372.408486]  [<c05c5e3d>] netdev_run_todo+0x10/0x1f9
[ 2372.408498]  [<c05d87b0>] netlink_run_queue+0xc7/0xdb
[ 2372.408506]  [<c05cbced>] rtnetlink_rcv_msg+0x0/0x1b9
[ 2372.408522]  [<c05cbcb8>] rtnetlink_rcv+0x34/0x3d
[ 2372.408534]  [<c05d8bcf>] netlink_data_ready+0x12/0x52
[ 2372.408546]  [<c05d7b4f>] netlink_sendskb+0x1c/0x33
[ 2372.408556]  [<c05d8bb1>] netlink_sendmsg+0x277/0x283
[ 2372.408585]  [<c05baa44>] sock_sendmsg+0xd0/0xeb
[ 2372.408614]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.408626]  [<c043f6ec>] futex_wait+0x242/0x2c8
[ 2372.408652]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.408671]  [<c05d7da1>] netlink_insert+0x104/0x10e
[ 2372.408683]  [<c04ea900>] copy_from_user+0x32/0x5e
[ 2372.408700]  [<c05bb3a0>] sys_sendto+0x118/0x138
[ 2372.408715]  [<c05bba35>] sys_getsockname+0x9f/0xb0
[ 2372.408732]  [<c04386d6>] init_waitqueue_head+0x12/0x20
[ 2372.408747]  [<c049686d>] inotify_d_instantiate+0x44/0x72
[ 2372.408763]  [<c04821ac>] d_instantiate+0x76/0x7a
[ 2372.408793]  [<c05bbd92>] sys_socketcall+0x17b/0x261
[ 2372.408820]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.408850]  =======================
[ 2372.408855] firefox-bin   S 00000033  3036  4491   4484
[ 2372.408865]        d2fd3e24 00000086 efcab449 00000033 d2fd3e08
00000000 c1a04180 d2fd3000
[ 2372.408879]        00000000 00000001 d2ffd930 d2ffdae4 c19fb180
00000000 c0758e40 d2fd3e88
[ 2372.408894]        e144bcc0 00000000 00000000 c043a7f7 00000282
001f6683 c19f81f8 c043acd9
[ 2372.408909] Call Trace:
[ 2372.408936]  [<c043a7f7>] enqueue_hrtimer+0x5a/0x62
[ 2372.408949]  [<c043acd9>] hrtimer_start+0xe4/0xee
[ 2372.408968]  [<c043f6bd>] futex_wait+0x213/0x2c8
[ 2372.409010]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.409022]  [<c043f6ae>] futex_wait+0x204/0x2c8
[ 2372.409040]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.409058]  [<c043fac8>] do_futex+0x69/0x93b
[ 2372.409078]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.409095]  [<c04243db>] scheduler_tick+0x14c/0x175
[ 2372.409104]  [<c043c017>] getnstimeofday+0x30/0xbd
[ 2372.409120]  [<c043ae70>] ktime_get_ts+0x16/0x44
[ 2372.409132]  [<c043aead>] ktime_get+0xf/0x2e
[ 2372.409147]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.409171]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.409202]  =======================
[ 2372.409206] firefox-bin   S 00000008  3288  4589   4484
[ 2372.409216]        cd48be24 00000086 df85ca80 00000008 00000000
00000000 00000000 cd48b000
[ 2372.409231]        e6efd4f5 00000050 d2ffc6a0 d2ffc854 c1a04180
00000001 b174ccec b174c000
[ 2372.409245]        e144bcc0 b174ccec b174c000 cd48be6c c043eb6c
00000000 00000000 00000000
[ 2372.409260] Call Trace:
[ 2372.409288]  [<c043eb6c>] get_futex_key+0x6e/0x122
[ 2372.409309]  [<c043f662>] futex_wait+0x1b8/0x2c8
[ 2372.409365]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.409383]  [<c043fac8>] do_futex+0x69/0x93b
[ 2372.409430]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.409446]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.409455]  [<c0424a5a>] schedule_tail+0x37/0x91
[ 2372.409471]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.409501]  =======================
[ 2372.409506] firefox-bin   S 00000039  3140  5170   4484
[ 2372.409515]        c468ce24 00000086 5a9c6cbe 00000039 c468ce08
00000000 f7b6ae00 c468c000
[ 2372.409530]        00000001 f7b6ac14 c5e94d10 c5e94ec4 c1a04180
00000001 c0758e40 c468ce88
[ 2372.409545]        e144bcc0 00000000 00000000 c043a7f7 00000282
001f368a c1a011f8 c043acd9
[ 2372.409560] Call Trace:
[ 2372.409587]  [<c043a7f7>] enqueue_hrtimer+0x5a/0x62
[ 2372.409600]  [<c043acd9>] hrtimer_start+0xe4/0xee
[ 2372.409619]  [<c043f6bd>] futex_wait+0x213/0x2c8
[ 2372.409660]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.409672]  [<c043f6ae>] futex_wait+0x204/0x2c8
[ 2372.409689]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.409708]  [<c043fac8>] do_futex+0x69/0x93b
[ 2372.409727]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.409746]  [<c043c017>] getnstimeofday+0x30/0xbd
[ 2372.409761]  [<c043ae70>] ktime_get_ts+0x16/0x44
[ 2372.409773]  [<c043aead>] ktime_get+0xf/0x2e
[ 2372.409788]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.409812]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.409842]  =======================
[ 2372.409846] gnome-screens S 00000039  2460  4498      1
[ 2372.409856]        d11f9be4 00000082 8b998403 00000039 c1a00b40
00000002 d11f9bcc d11f9000
[ 2372.409871]        598c2ffe 00000228 f71972c0 f7197474 c1a04180
00000001 00000286 f7d02000
[ 2372.409886]        d35e4580 d11f9bd4 c0625f0f f7d02000 c042fb7a
d11f9bf4 00007eca 00000000
[ 2372.409900] Call Trace:
[ 2372.409925]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.409936]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.409951]  [<c042fc91>] __mod_timer+0x9d/0xa7
[ 2372.409968]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.409984]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.409996]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.410014]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.410034]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.410050]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.410067]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.410084]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.410100]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.410117]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.410133]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.410150]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.410166]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.410185]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.410204]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.410233]  [<c061d7a5>] unix_write_space+0x15/0x77
[ 2372.410241]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.410254]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.410265]  [<c05bfa35>] __kfree_skb+0xa3/0xfa
[ 2372.410282]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.410323]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.410382]  [<c0420169>] __rq_clock+0x1c/0xab
[ 2372.410399]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.410412]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.410422]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.410434]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.410452]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.410470]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.410481]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.410511]  =======================
[ 2372.410515] evolution-dat S 00000005  2232  4518      1
[ 2372.410524]        d001fbe4 00000086 2218da69 00000005 d001fbc8
00000000 d001fbcc d001f000
[ 2372.410539]        a0ad243e 0000003b d0053970 d0053b24 c19fb180
00000000 c0758e40 d3f652c0
[ 2372.410554]        e144b0c0 f6942630 f641d780 d01a7ac4 d01a7b74
ffff16b1 00000000 00000000
[ 2372.410569] Call Trace:
[ 2372.410611]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.410630]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.410642]  [<c0478174>] pipe_poll+0x24/0x7a
[ 2372.410656]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.410675]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.410691]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.410708]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.410722]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.410736]  [<f898454d>] ext3_mark_iloc_dirty+0x27f/0x2e5 [ext3]
[ 2372.410779]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.410793]  [<c0420113>] __check_preempt_curr_fair+0x20/0x3f
[ 2372.410804]  [<c04200e4>] resched_task+0x55/0x58
[ 2372.410816]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.410833]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.410862]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.410881]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.410900]  [<c05bdebc>] sock_def_readable+0x3c/0x66
[ 2372.410915]  [<c061d11c>] unix_stream_sendmsg+0x246/0x311
[ 2372.410946]  [<c05b9fed>] sock_aio_write+0xf6/0x102
[ 2372.410981]  [<c0472eb5>] do_sync_readv_writev+0xc1/0xfe
[ 2372.411010]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.411029]  [<c043fadb>] do_futex+0x7c/0x93b
[ 2372.411052]  [<c04736db>] do_readv_writev+0x17d/0x187
[ 2372.411064]  [<c05b9ef7>] sock_aio_write+0x0/0x102
[ 2372.411097]  [<c0473722>] vfs_writev+0x3d/0x48
[ 2372.411114]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.411126]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.411158]  =======================
[ 2372.411162] evolution-dat S 00000005  2460  4519      1
[ 2372.411171]        d564fbe4 00000086 22192c6c 00000005 c19f7b40
00000002 d564fbcc d564f000
[ 2372.411186]        a0ad7595 0000003b d3f652c0 d3f65474 c19fb180
00000000 c0758e40 c0713380
[ 2372.411201]        e144b0c0 00000046 c043df12 00000000 00000000
ffff16b1 0000062a 00000000
[ 2372.411216] Call Trace:
[ 2372.411241]  [<c043df12>] tick_handle_periodic+0x17/0x5d
[ 2372.411268]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.411285]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.411297]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.411311]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.411331]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.411347]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.411364]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.411381]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.411397]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.411414]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.411430]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.411447]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.411463]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.411479]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.411493]  [<c041ff13>] update_curr+0x237/0x258
[ 2372.411519]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.411548]  [<c041fa31>] enqueue_task+0x49/0x58
[ 2372.411563]  [<c0420113>] __check_preempt_curr_fair+0x20/0x3f
[ 2372.411578]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.411594]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.411624]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.411670]  [<c041fc73>] update_stats_wait_end+0xaf/0xda
[ 2372.411697]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.411705]  [<c062497c>] __sched_text_start+0x6bc/0x729
[ 2372.411733]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.411754]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.411766]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.411797]  =======================
[ 2372.411802] evolution-dat S 00000005  2680  4530      1
[ 2372.411811]        d5049be4 00000086 cbd3c254 00000005 d5049bc8
00000000 00000000 d5049000
[ 2372.411826]        00000001 0000003b d018c660 d018c814 c1a04180
00000001 c0758e40 c0713380
[ 2372.411841]        e144b0c0 00000000 00000000 00000000 00000000
ffff16b6 00003bc5 00000000
[ 2372.411855] Call Trace:
[ 2372.411898]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.411917]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.411929]  [<c0478174>] pipe_poll+0x24/0x7a
[ 2372.411942]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.411962]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.411978]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.412000]  [<c041fa31>] enqueue_task+0x49/0x58
[ 2372.412016]  [<c0420113>] __check_preempt_curr_fair+0x20/0x3f
[ 2372.412031]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.412047]  [<c04203b2>] balance_tasks+0xb2/0x13e
[ 2372.412066]  [<c0425b16>] load_balance_fair+0x10e/0x14a
[ 2372.412098]  [<c04256e1>] load_balance_start_fair+0x0/0x21
[ 2372.412107]  [<c0420709>] load_balance_next_fair+0x0/0x21
[ 2372.412122]  [<c041fc73>] update_stats_wait_end+0xaf/0xda
[ 2372.412131]  [<c041ef8a>] move_tasks+0x53/0x76
[ 2372.412156]  [<c0625efd>] _spin_unlock_irq+0x5/0x7
[ 2372.412165]  [<c062497c>] __sched_text_start+0x6bc/0x729
[ 2372.412196]  [<c043eb6c>] get_futex_key+0x6e/0x122
[ 2372.412210]  [<c043eae0>] unqueue_me+0x7c/0x84
[ 2372.412225]  [<c043f6ec>] futex_wait+0x242/0x2c8
[ 2372.412259]  [<c046456f>] find_extend_vma+0x12/0x49
[ 2372.412286]  [<c043fa55>] futex_wake+0xa9/0xb3
[ 2372.412305]  [<c043fadb>] do_futex+0x7c/0x93b
[ 2372.412324]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.412360]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.412381]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.412393]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.412424]  =======================
[ 2372.412429] evolution-exc S 00000005  2232  4522      1
[ 2372.412438]        d01edbe4 00000086 22a7ab27 00000005 d01edbc8
00000000 f7e46800 d01ed000
[ 2372.412453]        00000000 00000287 d0052d10 d0052ec4 c19fb180
00000000 c0758e40 00000282
[ 2372.412467]        c1bc9500 d01edbf4 d01edbd4 c0625f0f c0812e80
ffff1931 d01edbf4 00000282
[ 2372.412482] Call Trace:
[ 2372.412509]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.412532]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.412550]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.412562]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.412576]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.412596]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.412612]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.412629]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.412646]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.412662]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.412692]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.412711]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.412740]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.412759]  [<c0420d24>] __wake_up+0x32/0x43
[ 2372.412778]  [<c061d7dd>] unix_write_space+0x4d/0x77
[ 2372.412792]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.412803]  [<c05bfa35>] __kfree_skb+0xa3/0xfa
[ 2372.412820]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.412860]  [<c0625f04>] _read_unlock_irq+0x5/0x7
[ 2372.412868]  [<c0456f7f>] find_lock_page+0x7c/0x83
[ 2372.412882]  [<c0458e26>] filemap_fault+0x21a/0x379
[ 2372.412892]  [<c046456f>] find_extend_vma+0x12/0x49
[ 2372.412916]  [<c0460c55>] __do_fault+0x2ea/0x315
[ 2372.412944]  [<c0462ab4>] handle_mm_fault+0x318/0x66c
[ 2372.412968]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.412981]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.412991]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.413003]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.413017]  [<c047da71>] vfs_ioctl+0x237/0x249
[ 2372.413037]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.413049]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.413080]  =======================
[ 2372.413085] evolution-exc S 00000005  2680  4525      1
[ 2372.413094]        d57a1be4 00000086 1f57d58b 00000005 d57a1bc8
00000000 00000000 d57a1000
[ 2372.413109]        903eeb11 0000003b d00520b0 d0052264 c19fb180
00000000 c0758e40 c0713380
[ 2372.413124]        c1bc9500 00000000 00000000 00000000 00000000
ffff1586 0000407f 00000000
[ 2372.413138] Call Trace:
[ 2372.413180]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.413199]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.413212]  [<c0478174>] pipe_poll+0x24/0x7a
[ 2372.413225]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.413244]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.413260]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.413277]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.413294]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.413310]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.413326]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.413343]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.413359]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.413375]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.413404]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.413417]  [<c041ff13>] update_curr+0x237/0x258
[ 2372.413443]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.413456]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.413481]  [<c041fa31>] enqueue_task+0x49/0x58
[ 2372.413496]  [<c0420113>] __check_preempt_curr_fair+0x20/0x3f
[ 2372.413511]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.413528]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.413577]  [<c043e98e>] wake_futex+0x3b/0x45
[ 2372.413588]  [<c04402e9>] do_futex+0x88a/0x93b
[ 2372.413635]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.413656]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.413668]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.413689]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.413708]  =======================
[ 2372.413712] beagled-helpe S 00000033  2460  4537      1
[ 2372.413721]        d0afdbe4 00000082 59e0b06a 00000033 d0afdbc8
00000000 c4d96792 d0afd000
[ 2372.413736]        140681d1 00000221 d018d2c0 d018d474 c19fb180
00000000 c0758e40 c5e95970
[ 2372.413751]        d35e4b80 c1a00120 00000046 c043df12 c0453b7a
001eec32 00000000 00000000
[ 2372.413766] Call Trace:
[ 2372.413792]  [<c043df12>] tick_handle_periodic+0x17/0x5d
[ 2372.413802]  [<c0453b7a>] handle_edge_irq+0x0/0xff
[ 2372.413826]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.413843]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.413856]  [<c061aff3>] unix_poll+0x17/0x98
[ 2372.413869]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.413889]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.413906]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.413923]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.413973]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.414002]  [<c041ff13>] update_curr+0x237/0x258
[ 2372.414028]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.414057]  [<c041fa31>] enqueue_task+0x49/0x58
[ 2372.414072]  [<c0420113>] __check_preempt_curr_fair+0x20/0x3f
[ 2372.414087]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.414103]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.414116]  [<c04091e1>] convert_fxsr_to_user+0x103/0x157
[ 2372.414148]  [<c046456f>] find_extend_vma+0x12/0x49
[ 2372.414174]  [<c043fa55>] futex_wake+0xa9/0xb3
[ 2372.414192]  [<c040901d>] convert_fxsr_from_user+0x2b/0xec
[ 2372.414213]  [<c0409466>] restore_i387+0x84/0xe7
[ 2372.414226]  [<c04042cb>] restore_sigcontext+0x162/0x1b3
[ 2372.414257]  [<c0404c86>] sys_sigreturn+0xc9/0x163
[ 2372.414267]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.414288]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.414300]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.414331]  =======================
[ 2372.414336] mono          S 00000033  3124  4538      1
[ 2372.414345]        d0ae8f2c 00000082 dc108991 00000033 d0ae8f10
00000000 00000008 d0ae8000
[ 2372.414360]        00000000 d0ae8ef8 d018c030 d018c1e4 c19fb180
00000000 c0758e40 d0ae8f4c
[ 2372.414374]        d35e4b80 00000000 00000000 c043a7f7 00000282
001f4c43 c19f81f8 c043acd9
[ 2372.414389] Call Trace:
[ 2372.414416]  [<c043a7f7>] enqueue_hrtimer+0x5a/0x62
[ 2372.414429]  [<c043acd9>] hrtimer_start+0xe4/0xee
[ 2372.414448]  [<c0625400>] do_nanosleep+0x41/0x6c
[ 2372.414462]  [<c043ad33>] hrtimer_nanosleep+0x50/0xf3
[ 2372.414480]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.414491]  [<c06253f5>] do_nanosleep+0x36/0x6c
[ 2372.414515]  [<c043ae1f>] sys_nanosleep+0x49/0x59
[ 2372.414529]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.414549]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.414567]  =======================
[ 2372.414572] mono          S 00000033  3036  4539      1
[ 2372.414581]        d0515e24 00000082 f01f5fe5 00000033 d0515e08
00000000 d0515e0c d0515000
[ 2372.414596]        00000000 00000228 d64cc6a0 d64cc854 c19fb180
00000000 c0758e40 d0515e88
[ 2372.414611]        d35e4b80 00000000 00000000 c043a7f7 00000282
001f6813 c19f81f8 c043acd9
[ 2372.414626] Call Trace:
[ 2372.414653]  [<c043a7f7>] enqueue_hrtimer+0x5a/0x62
[ 2372.414666]  [<c043acd9>] hrtimer_start+0xe4/0xee
[ 2372.414684]  [<c043f6bd>] futex_wait+0x213/0x2c8
[ 2372.414726]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.414738]  [<c043f6ae>] futex_wait+0x204/0x2c8
[ 2372.414755]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.414774]  [<c043fac8>] do_futex+0x69/0x93b
[ 2372.414791]  [<c0409466>] restore_i387+0x84/0xe7
[ 2372.414805]  [<c04042cb>] restore_sigcontext+0x162/0x1b3
[ 2372.414821]  [<c043c017>] getnstimeofday+0x30/0xbd
[ 2372.414837]  [<c043ae70>] ktime_get_ts+0x16/0x44
[ 2372.414848]  [<c043aead>] ktime_get+0xf/0x2e
[ 2372.414863]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.414887]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.414917]  =======================
[ 2372.414922] beagled-helpe S 00000033  3032  4540      1
[ 2372.414931]        cfdc6e38 00000082 59dfcfd4 00000033 c1a041dc
cfdc6e18 c04206eb cfdc6000
[ 2372.414946]        1405a149 00000221 cfddb970 cfddbb24 c19fb180
00000000 c19fb1dc c5e95970
[ 2372.414961]        d35e4b80 00000000 2786eb33 00000035 c0758dc0
d64cccd0 00000000 00000000
[ 2372.414976] Call Trace:
[ 2372.414987]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.415017]  [<c041fa31>] enqueue_task+0x49/0x58
[ 2372.415034]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.415059]  [<c04385f5>] prepare_to_wait_exclusive+0x27/0x42
[ 2372.415073]  [<c05c1c22>] skb_recv_datagram+0x13c/0x1b6
[ 2372.415087]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.415104]  [<c061c37c>] unix_accept+0x50/0xee
[ 2372.415119]  [<c05bbb32>] sys_accept+0xec/0x1d1
[ 2372.415135]  [<c040901d>] convert_fxsr_from_user+0x2b/0xec
[ 2372.415156]  [<c0409466>] restore_i387+0x84/0xe7
[ 2372.415169]  [<c04042cb>] restore_sigcontext+0x162/0x1b3
[ 2372.415201]  [<c05bbced>] sys_socketcall+0xd6/0x261
[ 2372.415227]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.415257]  =======================
[ 2372.415262] beagled-helpe S 00000039  3044  4541      1
[ 2372.415271]        cfdc8f2c 00000082 86e55cff 00000039 cfdc8f10
00000000 000001f6 cfdc8000
[ 2372.415286]        00000001 cfdc8ef8 cfddb340 cfddb4f4 c1a04180
00000001 c0758e40 cfdc8f4c
[ 2372.415301]        d35e4b80 00000000 00000000 c043a7f7 00000282
001f5fce c1a011f8 c043acd9
[ 2372.415316] Call Trace:
[ 2372.415342]  [<c043a7f7>] enqueue_hrtimer+0x5a/0x62
[ 2372.415355]  [<c043acd9>] hrtimer_start+0xe4/0xee
[ 2372.415374]  [<c0625400>] do_nanosleep+0x41/0x6c
[ 2372.415388]  [<c043ad33>] hrtimer_nanosleep+0x50/0xf3
[ 2372.415405]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.415417]  [<c06253f5>] do_nanosleep+0x36/0x6c
[ 2372.415441]  [<c043ae1f>] sys_nanosleep+0x49/0x59
[ 2372.415454]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.415484]  =======================
[ 2372.415489] beagled-helpe S 00000033  2460  4542      1
[ 2372.415498]        cfdcbbe4 00000082 efe1acf7 00000033 cfdcbbc8
00000000 cfdcbbcc cfdcb000
[ 2372.415513]        00000000 00000227 cfddad10 cfddaec4 c19fb180
00000000 c0758e40 c0812e80
[ 2372.415528]        d35e4b80 cfdcbbd4 c0625f0f c0812e80 c042fb7a
001f6683 00000282 00000282
[ 2372.415542] Call Trace:
[ 2372.415568]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.415578]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.415602]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.415618]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.415630]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.415648]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.415668]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.415684]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.415706]  [<c041fa31>] enqueue_task+0x49/0x58
[ 2372.415721]  [<c0420113>] __check_preempt_curr_fair+0x20/0x3f
[ 2372.415736]  [<c04256db>] check_preempt_curr_fair+0x8b/0x91
[ 2372.415753]  [<c04203b2>] balance_tasks+0xb2/0x13e
[ 2372.415772]  [<c0425b16>] load_balance_fair+0x10e/0x14a
[ 2372.415803]  [<c04256e1>] load_balance_start_fair+0x0/0x21
[ 2372.415817]  [<c041ff13>] update_curr+0x237/0x258
[ 2372.415835]  [<c04e83b4>] rb_insert_color+0x8c/0xad
[ 2372.415850]  [<c041ff13>] update_curr+0x237/0x258
[ 2372.415876]  [<c04206eb>] enqueue_entity+0x29f/0x2bd
[ 2372.415904]  [<c041fc73>] update_stats_wait_end+0xaf/0xda
[ 2372.415922]  [<c04091e1>] convert_fxsr_to_user+0x103/0x157
[ 2372.415953]  [<c046456f>] find_extend_vma+0x12/0x49
[ 2372.415979]  [<c043fa55>] futex_wake+0xa9/0xb3
[ 2372.415997]  [<c040901d>] convert_fxsr_from_user+0x2b/0xec
[ 2372.416018]  [<c0409466>] restore_i387+0x84/0xe7
[ 2372.416031]  [<c04042cb>] restore_sigcontext+0x162/0x1b3
[ 2372.416061]  [<c0404c86>] sys_sigreturn+0xc9/0x163
[ 2372.416072]  [<c0440483>] sys_futex+0xe9/0xfb
[ 2372.416086]  [<c043c017>] getnstimeofday+0x30/0xbd
[ 2372.416102]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.416113]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.416143]  =======================
[ 2372.416147] gnome-termina S 00000039  1888  4692      1
[ 2372.416156]        ca835be4 00200086 8bdd0f48 00000039 ca835bc8
00000000 ca835bcc ca835000
[ 2372.416171]        59cfbba6 00000228 cc3b18f0 cc3b1aa4 c1a04180
00000001 00200286 f7d02000
[ 2372.416186]        cc37abc0 ca835bd4 c0625f0f f7d02000 c042fb7a
ca835bf4 002ae216 00000000
[ 2372.416201] Call Trace:
[ 2372.416227]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.416237]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.416252]  [<c042fc91>] __mod_timer+0x9d/0xa7
[ 2372.416270]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.416286]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.416299]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.416317]  [<c047e23b>] do_sys_poll+0x255/0x327
[ 2372.416336]  [<c047ec06>] __pollwait+0x0/0xac
[ 2372.416353]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416370]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416386]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416403]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416419]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416436]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416452]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416469]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416485]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416502]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416519]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416535]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416552]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.416566]  [<c05be249>] sock_wfree+0x24/0x39
[ 2372.416577]  [<c05bfa35>] __kfree_skb+0xa3/0xfa
[ 2372.416594]  [<c061c20b>] unix_stream_recvmsg+0x3bc/0x4dd
[ 2372.416627]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.416645]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.416692]  [<c041fc73>] update_stats_wait_end+0xaf/0xda
[ 2372.416722]  [<c061b343>] unix_ioctl+0xa6/0xaf
[ 2372.416735]  [<c05ba3b3>] sock_ioctl+0x19f/0x1be
[ 2372.416744]  [<c05ba214>] sock_ioctl+0x0/0x1be
[ 2372.416756]  [<c047d7f7>] do_ioctl+0x1f/0x62
[ 2372.416775]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.416792]  [<c047e341>] sys_poll+0x34/0x37
[ 2372.416803]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.416834]  =======================
[ 2372.416839] gnome-termina S 0000000c  3336  4697      1
[ 2372.416849]        cb56de58 00000086 24108b58 0000000c 00000000
00000000 00000000 cb56d000
[ 2372.416863]        6cc1197e 00000061 cc3b0c90 cc3b0e44 c1a04180
00000001 00000000 00000000
[ 2372.416878]        cc37abc0 00000000 00000000 00000000 00000000
00000246 0050fe13 00000000
[ 2372.416893] Call Trace:
[ 2372.416928]  [<c043865f>] prepare_to_wait+0x24/0x3f
[ 2372.416942]  [<c04788d6>] pipe_wait+0x51/0x6f
[ 2372.416953]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.416967]  [<c0478fbe>] pipe_read+0x2ad/0x31d
[ 2372.416999]  [<c04730c3>] do_sync_read+0xc7/0x10a
[ 2372.417027]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.417061]  [<c0472ffc>] do_sync_read+0x0/0x10a
[ 2372.417072]  [<c047396c>] vfs_read+0xa6/0x152
[ 2372.417088]  [<c0473dc5>] sys_read+0x41/0x67
[ 2372.417103]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.417124]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.417142]  =======================
[ 2372.417146] gnome-pty-hel S 00000038  2528  4695   4692
[ 2372.417155]        cb8e7db0 00000086 7870dbf4 00000038 cb8e7d94
00000000 f7b5fb04 cb8e7000
[ 2372.417170]        00000001 00000480 cc3b0660 cc3b0814 c1a04180
00000001 c0758e40 00000180
[ 2372.417185]        cc37a3c0 c11c48a0 c04581f2 00000480 00000001
001ea316 00000001 00000480
[ 2372.417200] Call Trace:
[ 2372.417225]  [<c04581f2>] generic_file_buffered_write+0x4dd/0x5e4
[ 2372.417252]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.417275]  [<c043865f>] prepare_to_wait+0x24/0x3f
[ 2372.417289]  [<c061c03e>] unix_stream_recvmsg+0x1ef/0x4dd
[ 2372.417320]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.417339]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.417354]  [<c045884a>] generic_file_aio_write+0x61/0xb6
[ 2372.417385]  [<c04730c3>] do_sync_read+0xc7/0x10a
[ 2372.417396]  [<c047ceed>] fasync_helper+0xb6/0xbf
[ 2372.417422]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.417439]  [<c043a796>] __remove_hrtimer+0x20/0x27
[ 2372.417458]  [<c04824f4>] dput+0x8b/0xdf
[ 2372.417474]  [<c0473980>] vfs_read+0xba/0x152
[ 2372.417490]  [<c0473dc5>] sys_read+0x41/0x67
[ 2372.417505]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.417535]  =======================
[ 2372.417540] bash          S 0000000c  2452  4696   4692
[ 2372.417549]        cb511f34 00000082 4013c57a 0000000c cb511f18
00000000 00000008 cb511000
[ 2372.417564]        00000001 080fe3f8 cc3b0030 cc3b01e4 c1a04180
00000001 c0758e40 d56e1f98
[ 2372.417579]        d80d7140 cb5443f8 d56e1f98 c0462d87 cb5443f8
0001a86f 00000246 cbc35588
[ 2372.417593] Call Trace:
[ 2372.417620]  [<c0462d87>] handle_mm_fault+0x5eb/0x66c
[ 2372.417644]  [<c042a8e3>] do_wait+0x918/0xa13
[ 2372.417666]  [<c047d82b>] do_ioctl+0x53/0x62
[ 2372.417678]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.417696]  [<c042aa0f>] sys_wait4+0x31/0x34
[ 2372.417707]  [<c042aa39>] sys_waitpid+0x27/0x2b
[ 2372.417720]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.417751]  =======================
[ 2372.417755] su            S 0000000c  2380  4723   4696
[ 2372.417764]        cb644f34 00000082 43a67362 0000000c cb644f18
00000000 00000008 cb644000
[ 2372.417779]        00000001 8000683c cc3b12c0 cc3b1474 c1a04180
00000001 c0758e40 d576f614
[ 2372.417794]        d35e4980 cb65e018 d576f614 c0462d87 cb65e018
0001b07b 00000246 cbd74908
[ 2372.417809] Call Trace:
[ 2372.417835]  [<c0462d87>] handle_mm_fault+0x5eb/0x66c
[ 2372.417859]  [<c042a8e3>] do_wait+0x918/0xa13
[ 2372.417885]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.417903]  [<c042aa0f>] sys_wait4+0x31/0x34
[ 2372.417914]  [<c042aa39>] sys_waitpid+0x27/0x2b
[ 2372.417927]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.417947]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.417966]  =======================
[ 2372.417970] bash          S 00000037  2452  4726   4723
[ 2372.417979]        cee08f34 00000082 df10c382 00000037 c1a00b40
00000002 cee08f1c cee08000
[ 2372.417994]        e10ef7ea 00000212 d3f64660 d3f64814 c1a04180
00000001 cee08f24 c043852a
[ 2372.418009]        d80d7540 c62c5e60 d6930610 c041f072 00000000
001dff9f 00024ae9 00000000
[ 2372.418024] Call Trace:
[ 2372.418046]  [<c043852a>] autoremove_wake_function+0x15/0x35
[ 2372.418059]  [<c041f072>] __wake_up_common+0x32/0x55
[ 2372.418083]  [<c042a8e3>] do_wait+0x918/0xa13
[ 2372.418105]  [<c047d82b>] do_ioctl+0x53/0x62
[ 2372.418118]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.418135]  [<c042aa0f>] sys_wait4+0x31/0x34
[ 2372.418146]  [<c042aa39>] sys_waitpid+0x27/0x2b
[ 2372.418160]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.418180]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.418198]  =======================
[ 2372.418202] rmmod         D 00000033  2596  5007   4726
[ 2372.418212]        c62c5e60 00000082 eff1e4b6 00000033 c62c5e44
00000000 c04057eb c62c5000
[ 2372.418227]        00000000 0125d000 f778a070 f778a224 c19fb180
00000000 c0758e40 c0812e80
[ 2372.418241]        d80d7940 c62c5e50 c0625f0f c0812e80 c042fb7a
001f6783 00000282 00000282
[ 2372.418256] Call Trace:
[ 2372.418268]  [<c04057eb>] common_interrupt+0x23/0x28
[ 2372.418291]  [<c0625f0f>] _spin_lock_irqsave+0x9/0xd
[ 2372.418301]  [<c042fb7a>] lock_timer_base+0x19/0x35
[ 2372.418324]  [<c0625030>] schedule_timeout+0x70/0x8d
[ 2372.418340]  [<c042fa9c>] process_timeout+0x0/0x5
[ 2372.418352]  [<c062502b>] schedule_timeout+0x6b/0x8d
[ 2372.418371]  [<c042fca8>] msleep+0xd/0x12
[ 2372.418380]  [<c05c5f27>] netdev_run_todo+0xfa/0x1f9
[ 2372.418402]  [<f8a5ed4b>] ieee80211_unregister_hw+0xa8/0x1c7 [mac80211]
[ 2372.418450]  [<f8ca5043>] bcm43xx_remove+0x4a/0x75 [bcm43xx_mac80211]
[ 2372.418474]  [<c0624afe>] wait_for_completion+0x90/0x98
[ 2372.418497]  [<f8a36135>] ssb_device_remove+0x1d/0x28 [ssb]
[ 2372.418515]  [<c05585b0>] __device_release_driver+0x71/0x8e
[ 2372.418530]  [<c0558a40>] driver_detach+0x9e/0xde
[ 2372.418544]  [<c0558138>] bus_remove_driver+0x57/0x75
[ 2372.418559]  [<f8cb98ea>] bcm43xx_exit+0xa/0x27 [bcm43xx_mac80211]
[ 2372.418586]  [<c0444675>] sys_delete_module+0x185/0x1ac
[ 2372.418601]  [<c0464300>] unmap_region+0xc6/0xf8
[ 2372.418629]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.418650]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.418668]  =======================
[ 2372.418673] udevd         S 00000039  3284  5012    547
[ 2372.418683]        c5371f2c 00000082 8b8fb169 00000039 c5371f10
00000000 c5371f14 c5371000
[ 2372.418697]        00000001 c5371ef8 c4d77930 c4d77ae4 c1a04180
00000001 c0758e40 c5371f4c
[ 2372.418712]        d80d7340 00000000 00000000 c043a7f7 00000282
001f6824 c1a011f8 c043acd9
[ 2372.418727] Call Trace:
[ 2372.418754]  [<c043a7f7>] enqueue_hrtimer+0x5a/0x62
[ 2372.418767]  [<c043acd9>] hrtimer_start+0xe4/0xee
[ 2372.418786]  [<c0625400>] do_nanosleep+0x41/0x6c
[ 2372.418800]  [<c043ad33>] hrtimer_nanosleep+0x50/0xf3
[ 2372.418818]  [<c043a98a>] hrtimer_wakeup+0x0/0x18
[ 2372.418829]  [<c06253f5>] do_nanosleep+0x36/0x6c
[ 2372.418853]  [<c043ae1f>] sys_nanosleep+0x49/0x59
[ 2372.418867]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.418887]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.418905]  =======================
[ 2372.418910] ifdown-eth    S 00000032  2596  5032   5012
[ 2372.418919]        c54e6f34 00000086 0116ea16 00000032 c19f7b40
00000002 c54e6f1c c54e6000
[ 2372.418934]        fc7e3ea4 00000212 d81480b0 d8148264 c19fb180
00000000 c54e6f18 c949bb00
[ 2372.418949]        cc37adc0 c74cb404 c949bb00 c0462d87 c74cb404
001e0166 00000a09 00000000
[ 2372.418964] Call Trace:
[ 2372.418990]  [<c0462d87>] handle_mm_fault+0x5eb/0x66c
[ 2372.419014]  [<c042a8e3>] do_wait+0x918/0xa13
[ 2372.419037]  [<c04eab40>] copy_to_user+0x34/0x48
[ 2372.419050]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.419067]  [<c042aa0f>] sys_wait4+0x31/0x34
[ 2372.419078]  [<c042aa39>] sys_waitpid+0x27/0x2b
[ 2372.419091]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.419111]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.419130]  =======================
[ 2372.419134] ip            D 00000037  2776  5063   5032
[ 2372.419143]        c4c78d18 00000082 e725fa6a 00000037 c1a00b40
00000002 c4c78d00 c4c78000
[ 2372.419158]        fc7b2f93 00000212 d0053340 d00534f4 c1a04180
00000001 c05bde95 c05bf32b
[ 2372.419173]        c5ba8b40 f7693bc0 ffffff97 c05d78ed 000000d0
001e0164 0000090a 00000000
[ 2372.419188] Call Trace:
[ 2372.419209]  [<c05bde95>] sock_def_readable+0x15/0x66
[ 2372.419219]  [<c05bf32b>] skb_queue_tail+0x11/0x2d
[ 2372.419233]  [<c05d78ed>] netlink_dump+0x77/0x164
[ 2372.419256]  [<c062538d>] __mutex_lock_slowpath+0x4d/0x7f
[ 2372.419274]  [<c0625268>] mutex_lock+0x26/0x29
[ 2372.419286]  [<c05c5e3d>] netdev_run_todo+0x10/0x1f9
[ 2372.419298]  [<c05d87b0>] netlink_run_queue+0xc7/0xdb
[ 2372.419306]  [<c05cbced>] rtnetlink_rcv_msg+0x0/0x1b9
[ 2372.419323]  [<c05cbcb8>] rtnetlink_rcv+0x34/0x3d
[ 2372.419335]  [<c05d8bcf>] netlink_data_ready+0x12/0x52
[ 2372.419347]  [<c05d7b4f>] netlink_sendskb+0x1c/0x33
[ 2372.419358]  [<c05d8bb1>] netlink_sendmsg+0x277/0x283
[ 2372.419368]  [<c0420169>] __rq_clock+0x1c/0xab
[ 2372.419396]  [<c05baa44>] sock_sendmsg+0xd0/0xeb
[ 2372.419424]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.419439]  [<c04058a8>] apic_timer_interrupt+0x28/0x30
[ 2372.419463]  [<c0625f04>] _read_unlock_irq+0x5/0x7
[ 2372.419472]  [<c0456f7f>] find_lock_page+0x7c/0x83
[ 2372.419485]  [<c0458e26>] filemap_fault+0x21a/0x379
[ 2372.419502]  [<c04ea900>] copy_from_user+0x32/0x5e
[ 2372.419519]  [<c05bb3a0>] sys_sendto+0x118/0x138
[ 2372.419549]  [<c0462ab4>] handle_mm_fault+0x318/0x66c
[ 2372.419589]  [<c05bbd92>] sys_socketcall+0x17b/0x261
[ 2372.419616]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.419636]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.419654]  =======================
[ 2372.419659] grep          S 00000032  3068  5064   5032
[ 2372.419668]        c5443e58 00000086 012c776a 00000032 c5443e3c
00000000 21280374 c5443000
[ 2372.419683]        00000000 c042c1bd c4d766a0 c4d76854 c19fb180
00000000 c0758e40 fffffffe
[ 2372.419698]        c4ca1100 c0485b5c fffffffe c5443f30 c047b9e6
001e0166 d083ac00 00000041
[ 2372.419713] Call Trace:
[ 2372.419728]  [<c042c1bd>] current_fs_time+0x41/0x46
[ 2372.419746]  [<c0485b5c>] mntput_no_expire+0x11/0x6e
[ 2372.419759]  [<c047b9e6>] link_path_walk+0xa9/0xb3
[ 2372.419781]  [<c04788d6>] pipe_wait+0x51/0x6f
[ 2372.419792]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.419806]  [<c0478fbe>] pipe_read+0x2ad/0x31d
[ 2372.419837]  [<c04730c3>] do_sync_read+0xc7/0x10a
[ 2372.419866]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.419893]  [<c06275c4>] do_page_fault+0x272/0x594
[ 2372.419908]  [<c0472ffc>] do_sync_read+0x0/0x10a
[ 2372.419919]  [<c047396c>] vfs_read+0xa6/0x152
[ 2372.419935]  [<c0473dc5>] sys_read+0x41/0x67
[ 2372.419950]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.419970]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.419988]  =======================
[ 2372.419993] gnome-termina S 00000032  2468  5068      1
[ 2372.420002]        c4dffdb0 00000082 16a47cd4 00000032 c4dffd94
00000000 00000001 c4dff000
[ 2372.420017]        00000000 c0417bdf c5e940b0 c5e94264 c19fb180
00000000 c0758e40 c0713380
[ 2372.420032]        d80d7740 00000000 c04225a5 00008000 00000000
001e14fd f721ec90 00000001
[ 2372.420047] Call Trace:
[ 2372.420061]  [<c0417bdf>] native_smp_send_reschedule+0x56/0x5b
[ 2372.420081]  [<c04225a5>] try_to_wake_up+0x2da/0x2e4
[ 2372.420107]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.420130]  [<c043865f>] prepare_to_wait+0x24/0x3f
[ 2372.420144]  [<c061c03e>] unix_stream_recvmsg+0x1ef/0x4dd
[ 2372.420175]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.420194]  [<c05ba0f5>] sock_aio_read+0xfc/0x108
[ 2372.420231]  [<c04730c3>] do_sync_read+0xc7/0x10a
[ 2372.420242]  [<c045caf5>] release_pages+0x112/0x11a
[ 2372.420269]  [<c0438515>] autoremove_wake_function+0x0/0x35
[ 2372.420285]  [<c041d7a4>] pgd_dtor+0x0/0x3b
[ 2372.420298]  [<c041d7a2>] check_pgt_cache+0x1b/0x1d
[ 2372.420321]  [<c0473980>] vfs_read+0xba/0x152
[ 2372.420337]  [<c0473dc5>] sys_read+0x41/0x67
[ 2372.420352]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.420372]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.420390]  =======================
[ 2372.420395] bash          S 00000032  2876  5073   4061
[ 2372.420404]        c5847ec0 00000082 85173032 00000032 c5847ea4
00000000 00000007 c5847000
[ 2372.420419]        00000000 0000003c f7d50660 f7d50814 c19fb180
00000000 c0758e40 e332e000
[ 2372.420434]        ed427d40 c00b8fd2 00000001 ffffffff 00000000
001e8713 c0453b7a c0406f0f
[ 2372.420449] Call Trace:
[ 2372.420479]  [<c0453b7a>] handle_edge_irq+0x0/0xff
[ 2372.420488]  [<c0406f0f>] do_IRQ+0xbd/0xd2
[ 2372.420506]  [<c0624fd3>] schedule_timeout+0x13/0x8d
[ 2372.420530]  [<c0438696>] add_wait_queue+0x1c/0x28
[ 2372.420542]  [<c0538e49>] read_chan+0x319/0x594
[ 2372.420556]  [<c0536197>] tty_read+0x0/0xac
[ 2372.420572]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.420589]  [<c0538b30>] read_chan+0x0/0x594
[ 2372.420600]  [<c05361fb>] tty_read+0x64/0xac
[ 2372.420615]  [<c0536197>] tty_read+0x0/0xac
[ 2372.420626]  [<c047396c>] vfs_read+0xa6/0x152
[ 2372.420642]  [<c0473dc5>] sys_read+0x41/0x67
[ 2372.420657]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.420687]  =======================
[ 2372.420692] bash          S 00000038  2876  5110   4692
[ 2372.420701]        c4b6bf34 00200086 8412f1c1 00000038 c4b6bf18
00000000 00000008 c4b6b000
[ 2372.420716]        00000001 080fe3f8 d2ffc070 d2ffc224 c1a04180
00000001 c0758e40 c4a26320
[ 2372.420731]        c4ca1500 efe863f8 c4a26320 c0462d87 efe863f8
001eb211 00200246 d3f56208
[ 2372.420746] Call Trace:
[ 2372.420772]  [<c0462d87>] handle_mm_fault+0x5eb/0x66c
[ 2372.420797]  [<c042a8e3>] do_wait+0x918/0xa13
[ 2372.420819]  [<c047d82b>] do_ioctl+0x53/0x62
[ 2372.420831]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.420849]  [<c042aa0f>] sys_wait4+0x31/0x34
[ 2372.420860]  [<c042aa39>] sys_waitpid+0x27/0x2b
[ 2372.420873]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.420893]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.420911]  =======================
[ 2372.420916] su            S 00000032  2520  5135   5110
[ 2372.420925]        c4f0bf34 00200082 e6cb0b9b 00000032 c4f0bf18
00000000 00000008 c4f0b000
[ 2372.420940]        00000000 8000683c d67a0d10 d67a0ec4 c19fb180
00000000 c0758e40 c9790c50
[ 2372.420954]        c5ba8940 c4f83018 c9790c50 c0462d87 c4f83018
001eb840 00200246 d3f56048
[ 2372.420969] Call Trace:
[ 2372.420996]  [<c0462d87>] handle_mm_fault+0x5eb/0x66c
[ 2372.421020]  [<c042a8e3>] do_wait+0x918/0xa13
[ 2372.421046]  [<c04225af>] default_wake_function+0x0/0xc
[ 2372.421063]  [<c042aa0f>] sys_wait4+0x31/0x34
[ 2372.421074]  [<c042aa39>] sys_waitpid+0x27/0x2b
[ 2372.421088]  [<c0404dda>] sysenter_past_esp+0x5f/0x85
[ 2372.421108]  [<c0620000>] packet_getsockopt+0x30/0x103
[ 2372.421126]  =======================
[ 2372.421131] bash          R running   2920  5138   5135
[ 2372.421144] Sched Debug Version: v0.05, 2.6.23-rc1 #1
[ 2372.421149] now at 2358210732354 nsecs
[ 2372.421154]
[ 2372.421155] cpu#0, 1596.270 MHz
[ 2372.421160]   .nr_running                    : 1
[ 2372.421164]   .load                          : 1024
[ 2372.421168]   .ls.delta_fair                 : 0
[ 2372.421172]   .ls.delta_exec                 : 0
[ 2372.421177]   .nr_switches                   : 1246526
[ 2372.421181]   .nr_load_updates               : 2358285
[ 2372.421186]   .nr_uninterruptible            : 1145
[ 2372.421190]   .jiffies                       : 2058285
[ 2372.421194]   .next_balance                  : 2058287
[ 2372.421199]   .curr->pid                     : 5138
[ 2372.421203]   .clock                         : 223073018933
[ 2372.421208]   .prev_clock_raw                : 2372324250109
[ 2372.421213]   .clock_warps                   : 0
[ 2372.421217]   .clock_overflows               : 7
[ 2372.421221]   .clock_unstable_events         : 2824791
[ 2372.421225]   .clock_max_delta               : 1415351
[ 2372.421230]   .cpu_load[0]                   : 1150
[ 2372.421234]   .cpu_load[1]                   : 575
[ 2372.421238]   .cpu_load[2]                   : 289
[ 2372.421242]   .cpu_load[3]                   : 148
[ 2372.421246]   .cpu_load[4]                   : 79
[ 2372.421251]
[ 2372.421252] cfs_rq c19fb1dc
[ 2372.421256]   .fair_clock                    : 196978408697
[ 2372.421261]   .exec_clock                    : 202505106385
[ 2372.421266]   .wait_runtime                  : 5329605855
[ 2372.421270]   .wait_runtime_overruns         : 110133
[ 2372.421275]   .wait_runtime_underruns        : 18444
[ 2372.421279]   .sleeper_bonus                 : 11701
[ 2372.421284]   .wait_runtime_rq_sum           : 14846167
[ 2372.421292]
[ 2372.421293] runnable tasks:
[ 2372.421295]             task   PID        tree-key         delta
   waiting  switches  prio        sum-exec        sum-wait
sum-sleep    wait-overrun   wait-underrun
[ 2372.421301] ------------------------------------------------------------------------------------------------------------------------------------------------------------------
[ 2372.421359] R           bash  5138    196963554848     -14853849
  14846167       107   120        57724323        29068523
4558174455               4               0
[ 2372.421424]
[ 2372.421425] cpu#1, 1596.270 MHz
[ 2372.421430]   .nr_running                    : 7
[ 2372.421434]   .load                          : 7744
[ 2372.421439]   .ls.delta_fair                 : 0
[ 2372.421443]   .ls.delta_exec                 : 40113
[ 2372.421448]   .nr_switches                   : 1478396
[ 2372.421452]   .nr_load_updates               : 2358040
[ 2372.421457]   .nr_uninterruptible            : 4294966159
[ 2372.421461]   .jiffies                       : 2058286
[ 2372.421466]   .next_balance                  : 2058288
[ 2372.421470]   .curr->pid                     : 4539
[ 2372.421475]   .clock                         : 247167063825
[ 2372.421480]   .prev_clock_raw                : 2372421467862
[ 2372.421484]   .clock_warps                   : 0
[ 2372.421489]   .clock_overflows               : 3
[ 2372.421493]   .clock_unstable_events         : 4780494
[ 2372.421497]   .clock_max_delta               : 1826775
[ 2372.421502]   .cpu_load[0]                   : 2535
[ 2372.421506]   .cpu_load[1]                   : 1466
[ 2372.421510]   .cpu_load[2]                   : 785
[ 2372.421515]   .cpu_load[3]                   : 407
[ 2372.421519]   .cpu_load[4]                   : 211
[ 2372.421523]
[ 2372.421524] cfs_rq c1a041dc
[ 2372.421528]   .fair_clock                    : 230947113570
[ 2372.421533]   .exec_clock                    : 237778824653
[ 2372.421538]   .wait_runtime                  : 2735414765
[ 2372.421543]   .wait_runtime_overruns         : 113612
[ 2372.421547]   .wait_runtime_underruns        : 26123
[ 2372.421551]   .sleeper_bonus                 : 1569862
[ 2372.421557]   .wait_runtime_rq_sum           : 21639791
[ 2372.421564]
[ 2372.421566] runnable tasks:
[ 2372.421568]             task   PID        tree-key         delta
   waiting  switches  prio        sum-exec        sum-wait
sum-sleep    wait-overrun   wait-underrun
[ 2372.421573] ------------------------------------------------------------------------------------------------------------------------------------------------------------------
[ 2372.421586] R          pcscd  3449    230931100773     -16012797
  16000000      2256   120      1077050983      2588556261
215761900735             775               0
[ 2372.421604]             Xorg  4170    230957460982      10347412
 -10360209    288764   120    101109727889      4487659739
71142829733            2843            7427
[ 2372.421619]             mono  4368    230931100773     -16012797
  16000000     22498   120       438420468     20179334494
182320458067           11455               0
[ 2372.421637]
[ 2381.060210] unregister_netdevice: waiting for eth1 to become free.
Usage count = 1
[ 2391.132858] unregister_netdevice: waiting for eth1 to become free.
Usage count = 1


On 8/3/07, Johannes Berg <johannes at sipsolutions.net> wrote:
> On Fri, 2007-08-03 at 22:12 -0700, Brennan Ashton wrote:
> > When the bcm43xx_mac80211 driver stops communicating, and needs to be
> > reset (this seems to happens when coming from strong to week to strong
> > signal area quickly) i have been rmmod and then modprobing it. this
> > works most of the time, but some times (~20%), it will lock up the
> > network with this error that repeats.
> >
> > Message from syslogd at localhost at Fri Aug  3 00:55:41 2007 ...
> > localhost kernel: [19316.256549] unregister_netdevice: waiting for eth1 to becom
> > e free. Usage count = 5
> >
> > usage count varies, but renders the system unusable (extremely slow,
> > like when localhost is not defined) until the laptop is turned off,
> > the system will hang during shutdown requiring a power interrupt.
> > This did not happen with the bcm43xx driver in 2.6.22-rc7.
>
> I was about to suggest it could be caused by the deadlock Michael just
> found and fixed, but that happens under rtnl so it can't be.
>
> Can you get a process dump? echo t > /proc/sysrq-trigger or just
> pressing sysrq-t
>
> johannes
>
>


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From richie at coderworld.net  Sat Aug  4 11:41:24 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Sat, 4 Aug 2007 11:41:24 +0200
Subject: Odd network locking
In-Reply-To: <b2d05de20708032212j4f408935tac381077f50379a8@mail.gmail.com>
References: <b2d05de20708032212j4f408935tac381077f50379a8@mail.gmail.com>
Message-ID: <200708041141.24531.richie@coderworld.net>

On Saturday 04 August 2007 07:12:46 Brennan Ashton wrote:
> When the bcm43xx_mac80211 driver stops communicating, and needs to be
> reset (this seems to happens when coming from strong to week to strong
> signal area quickly) i have been rmmod and then modprobing it. this
> works most of the time, but some times (~20%), it will lock up the
> network with this error that repeats.
>
> Message from syslogd at localhost at Fri Aug  3 00:55:41 2007 ...
> localhost kernel: [19316.256549] unregister_netdevice: waiting for eth1 to
> becom e free. Usage count = 5
>
> usage count varies, but renders the system unusable (extremely slow,
> like when localhost is not defined) until the laptop is turned off,
> the system will hang during shutdown requiring a power interrupt.
> This did not happen with the bcm43xx driver in 2.6.22-rc7.
>

I've seen this while testing the 4301 driver (also mac80211).
I do not get it when booting into recovery mode, but is 100% reproducible when 
booting into X. A guess is that networkmanager is involved in it. I am also 
pretty sure that "Usage count" equals the number of times the driver has been 
reloaded. I can shut down fine when I've not reloaded the module.

My specs: 2.6.23-rc1+bcm4301 driver, 4311 hardware, kubuntu feisty.


From comphappy at gmail.com  Sat Aug  4 17:23:57 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sat, 4 Aug 2007 07:23:57 -0800
Subject: Odd network locking
In-Reply-To: <200708041141.24531.richie@coderworld.net>
References: <b2d05de20708032212j4f408935tac381077f50379a8@mail.gmail.com>
	<200708041141.24531.richie@coderworld.net>
Message-ID: <b2d05de20708040823i6ae16f8fkc8f5a4ba76578b31@mail.gmail.com>

> I've seen this while testing the 4301 driver (also mac80211).
> I do not get it when booting into recovery mode, but is 100% reproducible when
> booting into X. A guess is that networkmanager is involved in it. I am also
> pretty sure that "Usage count" equals the number of times the driver has been
> reloaded. I can shut down fine when I've not reloaded the module.
>
> My specs: 2.6.23-rc1+bcm4301 driver, 4311 hardware, kubuntu feisty.

I will do some tests to see if killing NM first will resolve this.
This is not the first NM bug with this driver that i have noticed. The
nice thing about this bug is that it is easy to reproduce. Also i have
notice that failure rate has risen to ~50%

PS
Sorry for the top post on that last message

-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From mb at bu3sch.de  Sat Aug  4 18:47:29 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 4 Aug 2007 18:47:29 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	=?iso-8859-1?q?but=09Ethernet_appears?= broken
In-Reply-To: <46B3F5D3.5090800@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <1186198060.28481.6.camel@dv>
	<46B3F5D3.5090800@lwfinger.net>
Message-ID: <200708041847.30250.mb@bu3sch.de>

On Saturday 04 August 2007, Larry Finger wrote:
> Pavel Roskin wrote:
> > On Fri, 2007-08-03 at 20:46 -0500, Larry Finger wrote:
> > 
> >> The size of LO array message is not fatal.
> > 
> > I'll really appreciate if it's removed or at least the stack dump is
> > suppressed.  We know already that it's a problem, so why scare users
> > more than they need to?  We know where it happens, why show the stack?
> > 
> > I don't think we want to make users ignore stack traces in the kernel
> > logs, because we may not hear about unknown problems.
> > 
> > IMHO there are better places for TODO notes than innocent users' kernel
> > logs.
> 
> I agree completely; however, I've had my "hands slapped" in the past for removing that kind of 
> message. As a result, I leave them alone.

Well, there are good reasons for not removing this.
The resons include that this message is only shown for the debug build.
So if you want it to shut up, don't compile a debug build.
It's the task of a debug build to show problems. If you don't care about
problems, disable it.
This message is not fatal in the sense that is prevents the device from
working, but it is very well fatal in the sense that the LO is not
adjusted properly. Which means you are probably radiating frequencies
that you are not licensed to.

Yeah, I'd like to get rid of this message, too. But by fixing the
bug and not by hiding it.

So any suggestions on how to fix this?
The problem is that I'm not sure why we calibrate the LO by these strange
tables. Maybe we can fix this by dropping the tables and simply
calibrate it for every possible attenuation.
These tables have some relation to the hardware power control.
So maybe we don't need to adjust the LO from the txpower routines
at all, when using hwpctl? (Only on demand of the power vector).


From will.dyson at gmail.com  Sat Aug  4 23:11:07 2007
From: will.dyson at gmail.com (Will Dyson)
Date: Sat, 4 Aug 2007 17:11:07 -0400
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <200708041847.30250.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net> <1186198060.28481.6.camel@dv>
	<46B3F5D3.5090800@lwfinger.net> <200708041847.30250.mb@bu3sch.de>
Message-ID: <8e6f94720708041411y194cfb37s959fa0938a38f34a@mail.gmail.com>

On 8/4/07, Michael Buesch <mb at bu3sch.de> wrote:

> So any suggestions on how to fix this?
> The problem is that I'm not sure why we calibrate the LO by these strange
> tables. Maybe we can fix this by dropping the tables and simply
> calibrate it for every possible attenuation.
> These tables have some relation to the hardware power control.
> So maybe we don't need to adjust the LO from the txpower routines
> at all, when using hwpctl? (Only on demand of the power vector).

I certainly can't claim to understand how the LO calibration is
supposed to work. I'm especially having a hard time understanding how
these LO tables (lo->with_padmix and lo->no_padmix) get built.

With that in mind, why can't we just make the table large enough for
an RFATT of 11?

It seems to work for me on a 4306....

Gmail-mangled patch follows (just to show what I'm talking about)

diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.h
b/drivers/net/wireless/bcm43xx-mac80211/b
index 377bda4..1d89fdd 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.h
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.h
@@ -26,7 +26,7 @@ struct bcm43xx_loctl {
  * Use bcm43xx_get_lo_g_ctl() to retrieve a value from the lists.
  */
 struct bcm43xx_txpower_lo_control {
-#define BCM43xx_NR_BB  9
+#define BCM43xx_NR_BB  12
 #define BCM43xx_NR_RF  16
        /* LO Control values, with PAD Mixer */
        struct bcm43xx_loctl with_padmix[ BCM43xx_NR_BB ][ BCM43xx_NR_RF ];
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
b/drivers/net/wireless/bcm43xx-mac80211/
index 4db7c5c..8f35d33 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
@@ -181,12 +181,15 @@ static void generate_bbatt_list(struct bcm43xx_wldev *dev,
                { .att = 6, },
                { .att = 7, },
                { .att = 8, },
+               { .att = 9, },
+               { .att = 10, },
+               { .att = 11, },
        };

        list->list = bbatt_0;
        list->len = ARRAY_SIZE(bbatt_0);
        list->min_val = 0;
-       list->max_val = 8;
+       list->max_val = 11;
 }

 static void bcm43xx_shm_clear_tssi(struct bcm43xx_wldev *dev)


-- 
Will Dyson


From Larry.Finger at lwfinger.net  Sun Aug  5 01:26:52 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 04 Aug 2007 18:26:52 -0500
Subject: Port of bcm43xx from softmac to mac80211 is available for testing
Message-ID: <46B50B3C.7000906@lwfinger.net>

The port of bcm43xx from softmac to mac80211 is available for testing. There are two patch sets that 
can be downloaded from ftp://lwfinger.dynalias.org/patches and be applied to kernel 2.6.23-rc1 or 
-rc2, the mainstream git tree (Linus's), and Linville's wireless-2.6 git tree.

The two files are ftp://lwfinger.dynalias.org/patches/SSB_Final, which installs the SSB driver, and 
ftp://lwfinger.dynalias.org/patches/port_to_mac80211, which has the changes for the bcm43xx driver. 
The resulting driver will use V3 firmware.

These patches are similar to the 4301 test driver that was circulated earlier. The major change is 
that the earlier version was trying to set the power too low. Once that was fixed, performance has 
become quite good, as shown below. I'm still working on the power setup, which may help the BCM4306.

Transker rates (xmit/recv in Mbs), obtained by using an Iperf server on my LAN

Bit Rate	BCM4311		BCM4318		BCM4306
set (Mbs)
1		1.17/8.66	1.22/9.39	1.22/3.73
2		1.96/11.2	1.98/12.5	1.90/4.98
5.5		4.15/17.7	4.19/17.7	3.98/5.09
6		4.86/17.3	4.86/19.9	2.66/4.94
9		6.58/17.7	6.56/19.9	3.26/5.01
11		6.57/14.2	6.54/18.5	6.07/5.20
18		10.7/19.6	10.7/20.2	4.74/5.05
24		12.6/19.6	12.8/20.0	4.12/5.34
36		16.2/20.1	15.9/20.1	4.76/4.90
48		17.9/20.0	15.1/19.6	3.70/4.18
54		19.0/19.8	15.1/20.0	1.83/2.64

These results look rather good for the later models - my BCM4306 has a PHY rev of 1. On this 
version, much more is required in the PHY setup, and we clearly have more work for that device.

Please let me know of any problems in applying the patches, or any oops's that occur.

Larry





From proski at gnu.org  Sun Aug  5 01:49:02 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 04 Aug 2007 19:49:02 -0400
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but	Ethernet appears broken
In-Reply-To: <200708041847.30250.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net> <1186198060.28481.6.camel@dv>
	<46B3F5D3.5090800@lwfinger.net>  <200708041847.30250.mb@bu3sch.de>
Message-ID: <1186271342.1948.10.camel@dv>

On Sat, 2007-08-04 at 18:47 +0200, Michael Buesch wrote:

> Yeah, I'd like to get rid of this message, too. But by fixing the
> bug and not by hiding it.
> 
> So any suggestions on how to fix this?

I think you could try to write a detailed explanation of the problem, in
particular, what those tables do, where the numbers come from, what
hardware is affected, what the driver does now, what it should do, and
how to find out the right solution from reverse engineering data.

After all, there are working drivers for the chipset, and they can be
reverse engineered.  It cannot be a problem with no solution.

Chances are that you will have some ideas before you finish writing the
message.  It happened to me many times.  But even if it doesn't happen,
you will make it easy for others to suggest solutions.  And you will
give the reverse engineering team some ideas what to look for.

-- 
Regards,
Pavel Roskin



From richie at coderworld.net  Sun Aug  5 03:12:14 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Sun, 5 Aug 2007 03:12:14 +0200
Subject: Odd network locking
In-Reply-To: <b2d05de20708040823i6ae16f8fkc8f5a4ba76578b31@mail.gmail.com>
References: <b2d05de20708032212j4f408935tac381077f50379a8@mail.gmail.com>
	<200708041141.24531.richie@coderworld.net>
	<b2d05de20708040823i6ae16f8fkc8f5a4ba76578b31@mail.gmail.com>
Message-ID: <200708050312.14190.richie@coderworld.net>

On Saturday 04 August 2007 17:23:57 you wrote:
> > I've seen this while testing the 4301 driver (also mac80211).
> > I do not get it when booting into recovery mode, but is 100% reproducible
> > when booting into X. A guess is that networkmanager is involved in it. I
> > am also pretty sure that "Usage count" equals the number of times the
> > driver has been reloaded. I can shut down fine when I've not reloaded the
> > module.
> >
> > My specs: 2.6.23-rc1+bcm4301 driver, 4311 hardware, kubuntu feisty.
>
> I will do some tests to see if killing NM first will resolve this.
> This is not the first NM bug with this driver that i have noticed. The
> nice thing about this bug is that it is easy to reproduce. Also i have
> notice that failure rate has risen to ~50%
>
> PS
> Sorry for the top post on that last message

I have tested a lot more now, but can't isolate what program causes this. I 
was wrong about the "Usage count" being the number of times the driver has 
been reloaded, at least for my setup.

After rmmod when modprobe'ing the module I get this message when in console 
(init 3):

net eth1: device_rename: sysfs_create_symlink failed (-17)

I will see if it goes away with Larrys new bcm43xx-mac80211 patch for my 
kernel, if not I will continue hunting.


From Larry.Finger at lwfinger.net  Sun Aug  5 08:23:36 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 05 Aug 2007 01:23:36 -0500
Subject: [PATCH] bcm43xx-mac80211: Rescale link quality output
Message-ID: <46b56ce8.MTc7K0Zquczk+/6h%Larry.Finger@lwfinger.net>

The link quality output from wireless extensions is too small by the ratio
of 100/BCM43xx_RX_MAX_SSI (60) for bcm43xx-mac80211. This patch puts the
quantity on the proper scale.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
@@ -537,7 +537,8 @@ void bcm43xx_rx(struct bcm43xx_wldev *de
 					      (phystat0 & BCM43xx_RX_PHYST0_GAINCTL),
 					      (phystat3 & BCM43xx_RX_PHYST3_TRSTATE));
 	status.noise = dev->stats.link_noise;
-	status.signal = jssi; /* this looks wrong, but is what mac80211 wants */
+	/* the next line looks wrong, but is what mac80211 wants */
+	status.signal = jssi * 100 / BCM43xx_RX_MAX_SSI;
 	if (phystat0 & BCM43xx_RX_PHYST0_OFDM)
 		status.rate = bcm43xx_plcp_get_bitrate_ofdm(plcp);
 	else


From Larry.Finger at lwfinger.net  Sun Aug  5 09:29:35 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 05 Aug 2007 02:29:35 -0500
Subject: [PATCH V2] bcm43xx-mac80211: Rescale link quality output
Message-ID: <46b57c5f.7s2ojiPQUXY5R3Qv%Larry.Finger@lwfinger.net>

The link quality output from wireless extensions is too small by the ratio
of 100/BCM43xx_RX_MAX_SSI (60) for bcm43xx-mac80211. This patch puts the
quantity on the proper scale.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
@@ -537,7 +537,8 @@ void bcm43xx_rx(struct bcm43xx_wldev *de
 					      (phystat0 & BCM43xx_RX_PHYST0_GAINCTL),
 					      (phystat3 & BCM43xx_RX_PHYST3_TRSTATE));
 	status.noise = dev->stats.link_noise;
-	status.signal = jssi; /* this looks wrong, but is what mac80211 wants */
+	/* the next line looks wrong, but is what mac80211 wants */
+	status.signal = (jssi * 100) / BCM43xx_RX_MAX_SSI;
 	if (phystat0 & BCM43xx_RX_PHYST0_OFDM)
 		status.rate = bcm43xx_plcp_get_bitrate_ofdm(plcp);
 	else


From mb at bu3sch.de  Sun Aug  5 12:16:11 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 5 Aug 2007 12:16:11 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <8e6f94720708041411y194cfb37s959fa0938a38f34a@mail.gmail.com>
References: <46B38B0F.20808@Wetwork.Net> <200708041847.30250.mb@bu3sch.de>
	<8e6f94720708041411y194cfb37s959fa0938a38f34a@mail.gmail.com>
Message-ID: <200708051216.11532.mb@bu3sch.de>

On Saturday 04 August 2007, Will Dyson wrote:
> On 8/4/07, Michael Buesch <mb at bu3sch.de> wrote:
> 
> > So any suggestions on how to fix this?
> > The problem is that I'm not sure why we calibrate the LO by these strange
> > tables. Maybe we can fix this by dropping the tables and simply
> > calibrate it for every possible attenuation.
> > These tables have some relation to the hardware power control.
> > So maybe we don't need to adjust the LO from the txpower routines
> > at all, when using hwpctl? (Only on demand of the power vector).
> 
> I certainly can't claim to understand how the LO calibration is
> supposed to work. I'm especially having a hard time understanding how
> these LO tables (lo->with_padmix and lo->no_padmix) get built.
> 
> With that in mind, why can't we just make the table large enough for
> an RFATT of 11?
> 
> It seems to work for me on a 4306....
> 
> Gmail-mangled patch follows (just to show what I'm talking about)
> 
> diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.h
> b/drivers/net/wireless/bcm43xx-mac80211/b
> index 377bda4..1d89fdd 100644
> --- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.h
> +++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.h
> @@ -26,7 +26,7 @@ struct bcm43xx_loctl {
>   * Use bcm43xx_get_lo_g_ctl() to retrieve a value from the lists.
>   */
>  struct bcm43xx_txpower_lo_control {
> -#define BCM43xx_NR_BB  9
> +#define BCM43xx_NR_BB  12
>  #define BCM43xx_NR_RF  16
>         /* LO Control values, with PAD Mixer */
>         struct bcm43xx_loctl with_padmix[ BCM43xx_NR_BB ][ BCM43xx_NR_RF ];
> diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> b/drivers/net/wireless/bcm43xx-mac80211/
> index 4db7c5c..8f35d33 100644
> --- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> +++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> @@ -181,12 +181,15 @@ static void generate_bbatt_list(struct bcm43xx_wldev *dev,
>                 { .att = 6, },
>                 { .att = 7, },
>                 { .att = 8, },
> +               { .att = 9, },
> +               { .att = 10, },
> +               { .att = 11, },
>         };
> 
>         list->list = bbatt_0;
>         list->len = ARRAY_SIZE(bbatt_0);
>         list->min_val = 0;
> -       list->max_val = 8;
> +       list->max_val = 11;
>  }
> 
>  static void bcm43xx_shm_clear_tssi(struct bcm43xx_wldev *dev)
> 
> 

Well, that's exactly the part I don't understand either.
It's can't be the case that we must extend the tables to get proper operation.
Except there's the same bug in the original driver, too, of course.



From mb at bu3sch.de  Sun Aug  5 12:18:19 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 5 Aug 2007 12:18:19 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	=?utf-8?q?but=09Ethernet_appears?= broken
In-Reply-To: <1186271342.1948.10.camel@dv>
References: <46B38B0F.20808@Wetwork.Net> <200708041847.30250.mb@bu3sch.de>
	<1186271342.1948.10.camel@dv>
Message-ID: <200708051218.20277.mb@bu3sch.de>

On Sunday 05 August 2007, Pavel Roskin wrote:
> On Sat, 2007-08-04 at 18:47 +0200, Michael Buesch wrote:
> 
> > Yeah, I'd like to get rid of this message, too. But by fixing the
> > bug and not by hiding it.
> > 
> > So any suggestions on how to fix this?
> 
> I think you could try to write a detailed explanation of the problem, in
> particular, what those tables do, where the numbers come from, what
> hardware is affected, what the driver does now, what it should do, and
> how to find out the right solution from reverse engineering data.

If I knew all these things, I would fix it.

> After all, there are working drivers for the chipset, and they can be
> reverse engineered.  It cannot be a problem with no solution.
> 
> Chances are that you will have some ideas before you finish writing the
> message.  It happened to me many times.  But even if it doesn't happen,
> you will make it easy for others to suggest solutions.  And you will
> give the reverse engineering team some ideas what to look for.

Well, it's not that easy. Current code just doesn't make any sense.
I do not understand how hardware power control works exactly, so I
can't write some detailed message or something.
That's probably a chicken and egg problem ;)


From mb at bu3sch.de  Sun Aug  5 14:57:11 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 5 Aug 2007 14:57:11 +0200
Subject: [PATCH V2] bcm43xx-mac80211: Rescale link quality output
In-Reply-To: <46b57c5f.7s2ojiPQUXY5R3Qv%Larry.Finger@lwfinger.net>
References: <46b57c5f.7s2ojiPQUXY5R3Qv%Larry.Finger@lwfinger.net>
Message-ID: <200708051457.11970.mb@bu3sch.de>

On Sunday 05 August 2007, Larry Finger wrote:
> The link quality output from wireless extensions is too small by the ratio
> of 100/BCM43xx_RX_MAX_SSI (60) for bcm43xx-mac80211. This patch puts the
> quantity on the proper scale.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> @@ -537,7 +537,8 @@ void bcm43xx_rx(struct bcm43xx_wldev *de
>  					      (phystat0 & BCM43xx_RX_PHYST0_GAINCTL),
>  					      (phystat3 & BCM43xx_RX_PHYST3_TRSTATE));
>  	status.noise = dev->stats.link_noise;
> -	status.signal = jssi; /* this looks wrong, but is what mac80211 wants */
> +	/* the next line looks wrong, but is what mac80211 wants */
> +	status.signal = (jssi * 100) / BCM43xx_RX_MAX_SSI;

So signal is in percent?
Where is this actually documented. I cannot find a hint on what
the values of all these things are supposed to be.


From larry.finger at lwfinger.net  Sun Aug  5 16:33:16 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 05 Aug 2007 09:33:16 -0500
Subject: [PATCH V2] bcm43xx-mac80211: Rescale link quality output
In-Reply-To: <200708051457.11970.mb@bu3sch.de>
References: <46b57c5f.7s2ojiPQUXY5R3Qv%Larry.Finger@lwfinger.net>
	<200708051457.11970.mb@bu3sch.de>
Message-ID: <46B5DFAC.9090600@lwfinger.net>

Michael Buesch wrote:
> On Sunday 05 August 2007, Larry Finger wrote:
>> The link quality output from wireless extensions is too small by the ratio
>> of 100/BCM43xx_RX_MAX_SSI (60) for bcm43xx-mac80211. This patch puts the
>> quantity on the proper scale.
>>
>> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
>> ---
>>
>> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
>> ===================================================================
>> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
>> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
>> @@ -537,7 +537,8 @@ void bcm43xx_rx(struct bcm43xx_wldev *de
>>  					      (phystat0 & BCM43xx_RX_PHYST0_GAINCTL),
>>  					      (phystat3 & BCM43xx_RX_PHYST3_TRSTATE));
>>  	status.noise = dev->stats.link_noise;
>> -	status.signal = jssi; /* this looks wrong, but is what mac80211 wants */
>> +	/* the next line looks wrong, but is what mac80211 wants */
>> +	status.signal = (jssi * 100) / BCM43xx_RX_MAX_SSI;
> 
> So signal is in percent?
> Where is this actually documented. I cannot find a hint on what
> the values of all these things are supposed to be.

Yes, it is clear as mud, with the additional complications of mac80211 mixing the definitions of 
signal and rssi (as far as I'm concerned). The scale is set by the following code snippet in 
bcm43xx_wireless_init.

         hw->max_signal = 100;
         hw->max_rssi = -110;
         hw->max_noise = -110;

In this code, "signal" is put on a scale of 0 to 100, and rssi and noise on a scale of -110 to 0 and 
are assumed to be dBm. Of course, rssi should be a positive number and signal should be in dBm, but 
my renaming of signal => quality and rssi => signal was shot down, so we are stuck.

An alternative to the patch above would be to set hw->max_signal = BCM43xx_RX_MAX_SSI. In that case, 
the line of iwconfig output that reads "Link Quality=83/100  Signal level=-34 dBm  Noise level=-71 
dBm" would have a "Link Quality" of 50/60 instead of 83/100.

The bottom line is that it is an arbitrary quantity on an arbitrary scale. Is it better for it to be 
  XX/100 than YY/60? I think so, but YMMV.

Larry


From mb at bu3sch.de  Sun Aug  5 16:43:30 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 5 Aug 2007 16:43:30 +0200
Subject: [PATCH V2] bcm43xx-mac80211: Rescale link quality output
In-Reply-To: <46B5DFAC.9090600@lwfinger.net>
References: <46b57c5f.7s2ojiPQUXY5R3Qv%Larry.Finger@lwfinger.net>
	<200708051457.11970.mb@bu3sch.de> <46B5DFAC.9090600@lwfinger.net>
Message-ID: <200708051643.30569.mb@bu3sch.de>

On Sunday 05 August 2007, Larry Finger wrote:
> Michael Buesch wrote:
> > On Sunday 05 August 2007, Larry Finger wrote:
> >> The link quality output from wireless extensions is too small by the ratio
> >> of 100/BCM43xx_RX_MAX_SSI (60) for bcm43xx-mac80211. This patch puts the
> >> quantity on the proper scale.
> >>
> >> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> >> ---
> >>
> >> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> >> ===================================================================
> >> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> >> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> >> @@ -537,7 +537,8 @@ void bcm43xx_rx(struct bcm43xx_wldev *de
> >>  					      (phystat0 & BCM43xx_RX_PHYST0_GAINCTL),
> >>  					      (phystat3 & BCM43xx_RX_PHYST3_TRSTATE));
> >>  	status.noise = dev->stats.link_noise;
> >> -	status.signal = jssi; /* this looks wrong, but is what mac80211 wants */
> >> +	/* the next line looks wrong, but is what mac80211 wants */
> >> +	status.signal = (jssi * 100) / BCM43xx_RX_MAX_SSI;
> > 
> > So signal is in percent?
> > Where is this actually documented. I cannot find a hint on what
> > the values of all these things are supposed to be.
> 
> Yes, it is clear as mud, with the additional complications of mac80211 mixing the definitions of 
> signal and rssi (as far as I'm concerned). The scale is set by the following code snippet in 
> bcm43xx_wireless_init.
> 
>          hw->max_signal = 100;
>          hw->max_rssi = -110;
>          hw->max_noise = -110;
> 
> In this code, "signal" is put on a scale of 0 to 100, and rssi and noise on a scale of -110 to 0 and 
> are assumed to be dBm. Of course, rssi should be a positive number and signal should be in dBm, but 
> my renaming of signal => quality and rssi => signal was shot down, so we are stuck.
> 
> An alternative to the patch above would be to set hw->max_signal = BCM43xx_RX_MAX_SSI. In that case, 
> the line of iwconfig output that reads "Link Quality=83/100  Signal level=-34 dBm  Noise level=-71 
> dBm" would have a "Link Quality" of 50/60 instead of 83/100.
> 
> The bottom line is that it is an arbitrary quantity on an arbitrary scale. Is it better for it to be 
>   XX/100 than YY/60? I think so, but YMMV.

Ah, I see. Kind of confusing. :)

Well, I would like to do
hw->max_signal = MAX_RSSI
but it seems to be an unwritten rule that signal scales to 100.
At least I never saw a different scale in a driver, yet.
So I think I will apply your patch.
Thanks!



From richie at coderworld.net  Sun Aug  5 21:15:51 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Sun, 5 Aug 2007 21:15:51 +0200
Subject: Port of bcm43xx from softmac to mac80211 is available for testing
In-Reply-To: <46B50B3C.7000906@lwfinger.net>
References: <46B50B3C.7000906@lwfinger.net>
Message-ID: <200708052115.51758.richie@coderworld.net>

On Sunday 05 August 2007 01:26:52 Larry Finger wrote:
> The port of bcm43xx from softmac to mac80211 is available for testing.
> There are two patch sets that can be downloaded from
> ftp://lwfinger.dynalias.org/patches and be applied to kernel 2.6.23-rc1 or
> -rc2, the mainstream git tree (Linus's), and Linville's wireless-2.6 git
> tree.
>
> The two files are ftp://lwfinger.dynalias.org/patches/SSB_Final, which
> installs the SSB driver, and
> ftp://lwfinger.dynalias.org/patches/port_to_mac80211, which has the changes
> for the bcm43xx driver. The resulting driver will use V3 firmware.
>
> These patches are similar to the 4301 test driver that was circulated
> earlier. The major change is that the earlier version was trying to set the
> power too low. Once that was fixed, performance has become quite good, as
> shown below. I'm still working on the power setup, which may help the
> BCM4306.
>
> Transker rates (xmit/recv in Mbs), obtained by using an Iperf server on my
> LAN
>
> Bit Rate	BCM4311		BCM4318		BCM4306
> set (Mbs)
> 1		1.17/8.66	1.22/9.39	1.22/3.73
> 2		1.96/11.2	1.98/12.5	1.90/4.98
> 5.5		4.15/17.7	4.19/17.7	3.98/5.09
> 6		4.86/17.3	4.86/19.9	2.66/4.94
> 9		6.58/17.7	6.56/19.9	3.26/5.01
> 11		6.57/14.2	6.54/18.5	6.07/5.20
> 18		10.7/19.6	10.7/20.2	4.74/5.05
> 24		12.6/19.6	12.8/20.0	4.12/5.34
> 36		16.2/20.1	15.9/20.1	4.76/4.90
> 48		17.9/20.0	15.1/19.6	3.70/4.18
> 54		19.0/19.8	15.1/20.0	1.83/2.64
>
> These results look rather good for the later models - my BCM4306 has a PHY
> rev of 1. On this version, much more is required in the PHY setup, and we
> clearly have more work for that device.
>
> Please let me know of any problems in applying the patches, or any oops's
> that occur.
>
> Larry

I have tried these patches on 2.6.23-rc2 and find perceived performance to be 
about the same as for the bcm4301 mac80211 driver. I use this script to 
stresstest the connection:

iperf -c 192.168.0.1 -t 3600 > /dev/null &
watch --interval .1 "dmesg|grep phy[0-9]|tail -n1 \
&& ifconfig eth1 \
&& iwconfig eth1 2>&1"

iwconfig:
eth1      IEEE 802.11g  ESSID:"NETGEAR"
          Mode:Managed  Frequency:2.442 GHz  Access Point: 00:0F:B5:3D:4B:E2
          Bit Rate=2 Mb/s
          Retry min limit:7   RTS thr:off   Fragment thr=2346 B
          Encryption key:off
          Link Quality=65/100  Signal level=-60 dBm  Noise level=-70 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

dmesg|grep "TX power"
[  755.816434] bcm43xx-phy0 debug: Current TX power output: 10.25 dBm, Desired 
TX power output: 10.0 dBm
[  763.339286] bcm43xx-phy0 debug: Current TX power output: 9.0 dBm, Desired 
TX power output: 10.0 dBm
[  770.840137] bcm43xx-phy0 debug: Current TX power output: 10.50 dBm, Desired 
TX power output: 10.0 dBm
[  778.343126] bcm43xx-phy0 debug: Current TX power output: 9.0 dBm, Desired 
TX power output: 10.0 dBm
[  785.842109] bcm43xx-phy0 debug: Current TX power output: 10.50 dBm, Desired 
TX power output: 10.0 dBm
[  793.347213] bcm43xx-phy0 debug: Current TX power output: 10.25 dBm, Desired 
TX power output: 10.0 dBm

Isn't Desired TX power supposed to adapt so that higher bitrates are possible, 
with Bit Rate going lower if that is not enough to keep a good connection?

When next to AP I get 54Mbps when connection is idle or has low utilisation, 
but when running iperf the Bit rate instantly changes to 1Mbps. While running 
iperf it jumps between 1, 2, 5.5 and 11Mbps. When manually setting it to 54M 
it will work with good thoughput. I think it fails at 11M and starts over 
from 1 again.

Performance next to AP	 (iperf -c 192.168.0.1):
1M	721K
2M	1.64M
5.5M	3.72M
6M	5.66M
9M	7.62M
11M	---
12M	9.28M
18M	11.9M
24M	14.0M
36M	17.2M
48M	18.5M
54M	18.4M
auto	451K

When 10 meters away from AP anything higher than 5.5 is unusable, often 5.5M 
too.

11M mode is unusable at all distances, 12M works fine. This probably breaks 
rate scaling for me.

"rmmod bcm43xx" when kde is running hangs rmmod and prevents a clean shutdown. 
I tried to find which program causes this while using bcm4301 driver, but so 
far no luck. System shuts down fine if I don't try to rmmod first. rmmod 
works fine from runlevel 3 aside from this message when inserting module 
again:
"net eth1: device_rename: sysfs_create_symlink failed (-17)"

Nitpicking:
When changing bitrate manually it will not show up with iwconfig before any 
traffic has occured.
Sometimes iwconfig link quality shows values in the whole 0-255 range.


From larry.finger at lwfinger.net  Sun Aug  5 23:11:33 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 05 Aug 2007 16:11:33 -0500
Subject: Port of bcm43xx from softmac to mac80211 is available for testing
In-Reply-To: <200708052115.51758.richie@coderworld.net>
References: <46B50B3C.7000906@lwfinger.net>
	<200708052115.51758.richie@coderworld.net>
Message-ID: <46B63D05.8040709@lwfinger.net>

Richard Jonsson wrote:
> 
> I have tried these patches on 2.6.23-rc2 and find perceived performance to be 
> about the same as for the bcm4301 mac80211 driver. I use this script to 
> stresstest the connection:
> 
> iperf -c 192.168.0.1 -t 3600 > /dev/null &
> watch --interval .1 "dmesg|grep phy[0-9]|tail -n1 \
> && ifconfig eth1 \
> && iwconfig eth1 2>&1"
> 
> iwconfig:
> eth1      IEEE 802.11g  ESSID:"NETGEAR"
>           Mode:Managed  Frequency:2.442 GHz  Access Point: 00:0F:B5:3D:4B:E2
>           Bit Rate=2 Mb/s
>           Retry min limit:7   RTS thr:off   Fragment thr=2346 B
>           Encryption key:off
>           Link Quality=65/100  Signal level=-60 dBm  Noise level=-70 dBm
>           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> 
> dmesg|grep "TX power"
> [  755.816434] bcm43xx-phy0 debug: Current TX power output: 10.25 dBm, Desired 
> TX power output: 10.0 dBm
> [  763.339286] bcm43xx-phy0 debug: Current TX power output: 9.0 dBm, Desired 
> TX power output: 10.0 dBm
> [  770.840137] bcm43xx-phy0 debug: Current TX power output: 10.50 dBm, Desired 
> TX power output: 10.0 dBm
> [  778.343126] bcm43xx-phy0 debug: Current TX power output: 9.0 dBm, Desired 
> TX power output: 10.0 dBm
> [  785.842109] bcm43xx-phy0 debug: Current TX power output: 10.50 dBm, Desired 
> TX power output: 10.0 dBm
> [  793.347213] bcm43xx-phy0 debug: Current TX power output: 10.25 dBm, Desired 
> TX power output: 10.0 dBm
> 
> Isn't Desired TX power supposed to adapt so that higher bitrates are possible, 
> with Bit Rate going lower if that is not enough to keep a good connection?

It should, but this feature is not yet implemented. I have some test code to do this, but it is not 
ready. When it is, I'll send you a trial patch. Check if your system has a file names 
/sys/kernel/debug/bcm43xx/phyX/power_level. If it does, you can write new values for the Desired 
power into it. Values up to 18 are allowed.

> When next to AP I get 54Mbps when connection is idle or has low utilisation, 
> but when running iperf the Bit rate instantly changes to 1Mbps. While running 
> iperf it jumps between 1, 2, 5.5 and 11Mbps. When manually setting it to 54M 
> it will work with good thoughput. I think it fails at 11M and starts over 
> from 1 again.
> 
> Performance next to AP	 (iperf -c 192.168.0.1):
> 1M	721K
> 2M	1.64M
> 5.5M	3.72M
> 6M	5.66M
> 9M	7.62M
> 11M	---
> 12M	9.28M
> 18M	11.9M
> 24M	14.0M
> 36M	17.2M
> 48M	18.5M
> 54M	18.4M
> auto	451K
> 
> When 10 meters away from AP anything higher than 5.5 is unusable, often 5.5M 
> too.
> 
> 11M mode is unusable at all distances, 12M works fine. This probably breaks 
> rate scaling for me.

Yes, it certainly would. My 4311 shows a little dip at 11 Mbs, but not as big as yours. Is your AP 
using b/g mode, or just g mode? What is the make and model of the AP?

> "rmmod bcm43xx" when kde is running hangs rmmod and prevents a clean shutdown. 
> I tried to find which program causes this while using bcm4301 driver, but so 
> far no luck. System shuts down fine if I don't try to rmmod first. rmmod 
> works fine from runlevel 3 aside from this message when inserting module 
> again:
> "net eth1: device_rename: sysfs_create_symlink failed (-17)"

On my system, I routinely unload the module using 'modprobe -r bcm43xx'. Sometimes, it happens 20 or 
30 times between reboots. These are always at runlevel 5. Only once or twice has it not completed. 
Are you using NetworkManager or using the traditional ifup/ifdown methods?
> 
> Nitpicking:
> When changing bitrate manually it will not show up with iwconfig before any 
> traffic has occured.

This is a mac80211 problem. My original version of the patch that implemented the "set rate" 
function loaded the new rate so that it would show up immediately, but that part was nixed. Complain 
on wireless-dev at vger.kernel.org.

> Sometimes iwconfig link quality shows values in the whole 0-255 range.

Do the Signal and Noise levels show -256 dBm at the same time? If so, mac80211 has not received any 
data.

Larry


From larry.finger at lwfinger.net  Mon Aug  6 01:08:17 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 05 Aug 2007 18:08:17 -0500
Subject: Port of bcm43xx from softmac to mac80211 is available for testing
In-Reply-To: <46B63D05.8040709@lwfinger.net>
References: <46B50B3C.7000906@lwfinger.net>	<200708052115.51758.richie@coderworld.net>
	<46B63D05.8040709@lwfinger.net>
Message-ID: <46B65861.6050502@lwfinger.net>

Richard Jonsson wrote:

> "rmmod bcm43xx" when kde is running hangs rmmod and prevents a clean shutdown. 
> I tried to find which program causes this while using bcm4301 driver, but so 
> far no luck. System shuts down fine if I don't try to rmmod first. rmmod 
> works fine from runlevel 3 aside from this message when inserting module 
> again:
> "net eth1: device_rename: sysfs_create_symlink failed (-17)"

I just got one of these during bootup, which prevented bcm43xx from starting correctly.

The logged sequence was:

kernel: bcm43xx-phy1: Broadcom 4311 WLAN found
kernel: ssb: Switching to IEEE 802.11 core, index 1
kernel: bcm43xx-phy1 debug: Found PHY: Analog 4, Type 2, Revision 8
kernel: bcm43xx-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
kernel: bcm43xx-phy1 debug: Radio turned off
kernel: wmaster0: Selected rate control algorithm 'simple'
ifup: Service network not started and mode 'auto' -> skipping
kernel: net eth1: device_rename: sysfs_create_symlink failed (-17)
ifup: Network interface is managed from NetworkManager
ifup: NetworkManager will be advised to set up eth1
ifup: but it cannot be assured from here.
kernel: bcm43xx-phy1 debug: Adding Interface type 2
kernel: ssb: Switching to PCI-E core, index 3
kernel: ssb: Switching to IEEE 802.11 core, index 1
kernel: bcm43xx-phy1: bcm43xx: Microcode bcm43xx_microcode5.fw3.fw loaded

The fix for this was to 'modprobe -r bcm43xx' followed by 'modprobe bcm43xx', which got everything 
started OK.

Larry


From larry.finger at lwfinger.net  Mon Aug  6 03:21:11 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 05 Aug 2007 20:21:11 -0500
Subject: Port of bcm43xx from softmac to mac80211 is available for testing
In-Reply-To: <200708052115.51758.richie@coderworld.net>
References: <46B50B3C.7000906@lwfinger.net>
	<200708052115.51758.richie@coderworld.net>
Message-ID: <46B67787.1080903@lwfinger.net>

Richard Jonsson wrote:
> 
> Isn't Desired TX power supposed to adapt so that higher bitrates are possible, 
> with Bit Rate going lower if that is not enough to keep a good connection?

Richard,

Please grab a new copy of the port_to_mac80211 patch, and try the patch below. It boosts the desired 
power by up to 5 dBm as signal - noise decreases from 20 to 0.

Larry


Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
@@ -622,6 +622,8 @@ struct bcm43xx_wldev {
  	bool short_preamble;	/* TRUE if using short preamble. */
  	bool short_slot;	/* TRUE if using short slot timing. */
  	bool radio_hw_enable;	/* State of radio hardware enable bit. */
+	u8 saved_signal_noise[4];
+	u8 signal_noise_index;

  	/* PHY/Radio device. */
  	struct bcm43xx_phy phy;
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -2862,6 +2862,8 @@ static void setup_struct_phy_for_init(st
  	phy->interfmode = BCM43xx_INTERFMODE_NONE;
  	phy->channel = 0xFF;
  	phy->power_level = 0;
+
+	dev->signal_noise_index = 0;
  }

  static void setup_struct_wldev_for_init(struct bcm43xx_wldev *dev)
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
@@ -1771,6 +1771,7 @@ void bcm43xx_phy_xmitpower(struct bcm43x
  	s16 desired_pwr;
  	s16 estimated_pwr;
  	s16 pwr_adjust;
+	s16 snadjust;
  	s16 radio_att_delta;
  	s16 baseband_att_delta;
  	s16 radio_attenuation;
@@ -1824,6 +1825,14 @@ void bcm43xx_phy_xmitpower(struct bcm43x

  	estimated_pwr = bcm43xx_phy_estimate_power_out(dev, average);

+	/* calculate any power boost from low S/N values */
+	snadjust = (dev->saved_signal_noise[0] + dev->saved_signal_noise[1] +
+		    dev->saved_signal_noise[2] + dev->saved_signal_noise[3] +
+		    2) / 4;
+	/* boost from 0 to 5 dBm as S/N decreases from 20 to 0 */
+	snadjust = limit_value(5 - snadjust/4, 0, 5);
+	snadjust *= 4; /* convert to Q5.2 format */
+
  	max_pwr = dev->dev->bus->sprom.r1.maxpwr_bg;

  	if ((dev->dev->bus->sprom.r1.boardflags_lo
@@ -1848,7 +1857,7 @@ void bcm43xx_phy_xmitpower(struct bcm43x
  		      - 0x6, max_pwr);

  	/* find the desired power in Q5.2 - power_level is in dBm */
-	desired_pwr = limit_value(phy->power_level << 2, 0, max_pwr);
+	desired_pwr = limit_value((phy->power_level << 2) + snadjust, 0, max_pwr);
  	if (bcm43xx_debug(dev, BCM43xx_DBG_XMITPOWER))
  		bcmdbg(dev->wl, "Current TX power output: " Q52_FMT
  		       " dBm, Desired TX power output: " Q52_FMT
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_xmit.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_xmit.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_xmit.c
@@ -526,6 +526,12 @@ void bcm43xx_rx(struct bcm43xx_wldev *de
  	status.antenna = !!(phystat0 & BCM43xx_RX_PHYST0_ANT);
  	status.mactime = mactime;

+	/* update S/N buffer */
+	dev->saved_signal_noise[dev->signal_noise_index++] =
+				status.ssi - status.noise;
+	if (dev->signal_noise_index >= 4)
+		dev->signal_noise_index = 0;
+
  	chanid = (chanstat & BCM43xx_RX_CHAN_ID) >> BCM43xx_RX_CHAN_ID_SHIFT;
  	switch (chanstat & BCM43xx_RX_CHAN_PHYTYPE) {
  	case BCM43xx_PHYTYPE_B:


-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: power_boost
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070805/2bf40f8c/attachment.ksh>

From Larry.Finger at lwfinger.net  Mon Aug  6 05:00:24 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 05 Aug 2007 22:00:24 -0500
Subject: [PATCH] bcm43xx-mac80211: Fix regression in interrupt handling
Message-ID: <46b68ec8.nObKM6TauxkzJMGV%Larry.Finger@lwfinger.net>

Since commit 85a83d26697dd2203ac4e5f33022951f2c3e6e33, "bcm43xx-mac80211:
Rewrite and simplify handling of the initialization status", some PCI
adapters have problems due to interrupts happening before the device status
reaches BCM43xx_STARTED. This patch delays the initial interrupt enable until
after the device status is set.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This patch fixes a regression since 2.6.23-rc1. Michael and I have discussed this
and he has agreed that this is the proper fix.

Larry

 bcm43xx_main.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -3014,13 +3014,13 @@ static int bcm43xx_wireless_core_start(s
 		       dev->dev->irq);
 		goto out;
 	}
-	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
 	bcm43xx_mac_enable(dev);
 
 	bcm43xx_periodic_tasks_setup(dev);
 
 	ieee80211_start_queues(dev->wl->hw);
 	bcm43xx_set_status(dev, BCM43xx_STAT_STARTED);
+	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
 	bcmdbg(dev->wl, "Wireless interface started\n");
 out:
 	return err;


From mb at bu3sch.de  Mon Aug  6 14:10:40 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 6 Aug 2007 14:10:40 +0200
Subject: [PATCH] bcm43xx-mac80211: Fix regression in interrupt handling
In-Reply-To: <46b68ec8.nObKM6TauxkzJMGV%Larry.Finger@lwfinger.net>
References: <46b68ec8.nObKM6TauxkzJMGV%Larry.Finger@lwfinger.net>
Message-ID: <200708061410.40506.mb@bu3sch.de>

On Monday 06 August 2007, Larry Finger wrote:
> Since commit 85a83d26697dd2203ac4e5f33022951f2c3e6e33, "bcm43xx-mac80211:
> Rewrite and simplify handling of the initialization status", some PCI
> adapters have problems due to interrupts happening before the device status
> reaches BCM43xx_STARTED. This patch delays the initial interrupt enable until
> after the device status is set.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John,
> 
> This patch fixes a regression since 2.6.23-rc1. Michael and I have discussed this
> and he has agreed that this is the proper fix.
> 
> Larry
> 
>  bcm43xx_main.c |    2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
> 
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -3014,13 +3014,13 @@ static int bcm43xx_wireless_core_start(s
>  		       dev->dev->irq);
>  		goto out;
>  	}
> -	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
>  	bcm43xx_mac_enable(dev);
>  
>  	bcm43xx_periodic_tasks_setup(dev);
>  
>  	ieee80211_start_queues(dev->wl->hw);
>  	bcm43xx_set_status(dev, BCM43xx_STAT_STARTED);
> +	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
>  	bcmdbg(dev->wl, "Wireless interface started\n");
>  out:
>  	return err;

Queued into my patch series, thanks.


From mb at bu3sch.de  Mon Aug  6 14:10:54 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 6 Aug 2007 14:10:54 +0200
Subject: [PATCH V2] bcm43xx-mac80211: Rescale link quality output
In-Reply-To: <46b57c5f.7s2ojiPQUXY5R3Qv%Larry.Finger@lwfinger.net>
References: <46b57c5f.7s2ojiPQUXY5R3Qv%Larry.Finger@lwfinger.net>
Message-ID: <200708061410.54552.mb@bu3sch.de>

On Sunday 05 August 2007, Larry Finger wrote:
> The link quality output from wireless extensions is too small by the ratio
> of 100/BCM43xx_RX_MAX_SSI (60) for bcm43xx-mac80211. This patch puts the
> quantity on the proper scale.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
> @@ -537,7 +537,8 @@ void bcm43xx_rx(struct bcm43xx_wldev *de
>  					      (phystat0 & BCM43xx_RX_PHYST0_GAINCTL),
>  					      (phystat3 & BCM43xx_RX_PHYST3_TRSTATE));
>  	status.noise = dev->stats.link_noise;
> -	status.signal = jssi; /* this looks wrong, but is what mac80211 wants */
> +	/* the next line looks wrong, but is what mac80211 wants */
> +	status.signal = (jssi * 100) / BCM43xx_RX_MAX_SSI;
>  	if (phystat0 & BCM43xx_RX_PHYST0_OFDM)
>  		status.rate = bcm43xx_plcp_get_bitrate_ofdm(plcp);
>  	else
> 
> 

Queued into my patch series, thanks.


From proski at gnu.org  Mon Aug  6 14:24:36 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 06 Aug 2007 08:24:36 -0400
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but	Ethernet appears broken
In-Reply-To: <200708051218.20277.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net> <200708041847.30250.mb@bu3sch.de>
	<1186271342.1948.10.camel@dv>  <200708051218.20277.mb@bu3sch.de>
Message-ID: <1186403076.10627.23.camel@dv>

On Sun, 2007-08-05 at 12:18 +0200, Michael Buesch wrote:

> Well, it's not that easy. Current code just doesn't make any sense.
> I do not understand how hardware power control works exactly, so I
> can't write some detailed message or something.
> That's probably a chicken and egg problem ;)

OK, the existing code complains that one number is larger than another.
You don't want to hide that message, but when I ask you to explain, you
say that the code makes no sense to you.

Somehow, it doesn't sound right.  Nobody knows the code better than you.
I think communication is essential for development.

-- 
Regards,
Pavel Roskin



From mb at bu3sch.de  Mon Aug  6 14:27:42 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 06 Aug 2007 14:27:42 +0200
Subject: [patch 4/5] bcm43xx-mac80211: Fix regression in interrupt handling
References: <20070806122738.693790000@bu3sch.de>>
Message-ID: <20070806122741.343256000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-fix-regression-in-interrupt-handling.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070806/5e39bdff/attachment.ksh>

From mb at bu3sch.de  Mon Aug  6 14:27:43 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 06 Aug 2007 14:27:43 +0200
Subject: [patch 5/5] bcm43xx-mac80211: Rescale link quality output
References: <20070806122738.693790000@bu3sch.de>>
Message-ID: <20070806122741.836108000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-rescale-link-quality-output.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070806/dfca7319/attachment.ksh>

From mb at bu3sch.de  Mon Aug  6 14:27:41 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 06 Aug 2007 14:27:41 +0200
Subject: [patch 3/5] bcm43xx-mac80211: Set antenna gains if not in sprom
References: <20070806122738.693790000@bu3sch.de>>
Message-ID: <20070806122740.903110000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-set-antenna-gains-if-not-in-sprom.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070806/c2ea7dca/attachment.ksh>

From mb at bu3sch.de  Mon Aug  6 14:27:38 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 06 Aug 2007 14:27:38 +0200
Subject: [patch 0/5] New patch series for merge
Message-ID: <20070806122738.693790000@bu3sch.de>>

Hi John,

This patch series catches wireless-dev up to my
current wireless-development patchset.

Please merge this into wireless-dev.


--



From mb at bu3sch.de  Mon Aug  6 14:27:39 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 06 Aug 2007 14:27:39 +0200
Subject: [patch 1/5] bcm43xx-mac80211: Provide information to allow
	transmission rate decreases
References: <20070806122738.693790000@bu3sch.de>>
Message-ID: <20070806122739.792391000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-provide-information-to-allow-transmission-rate-decreases.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070806/c2f4d5b5/attachment.ksh>

From mb at bu3sch.de  Mon Aug  6 14:27:40 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 06 Aug 2007 14:27:40 +0200
Subject: [patch 2/5] Always use dev_kfree_skb_any()
References: <20070806122738.693790000@bu3sch.de>>
Message-ID: <20070806122740.469265000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-use-dev-kfree-skb-any.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070806/8d28faa2/attachment.ksh>

From mb at bu3sch.de  Mon Aug  6 14:38:31 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 6 Aug 2007 14:38:31 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	=?utf-8?q?but=09Ethernet_appears?= broken
In-Reply-To: <1186403076.10627.23.camel@dv>
References: <46B38B0F.20808@Wetwork.Net> <200708051218.20277.mb@bu3sch.de>
	<1186403076.10627.23.camel@dv>
Message-ID: <200708061438.32222.mb@bu3sch.de>

On Monday 06 August 2007, Pavel Roskin wrote:
> On Sun, 2007-08-05 at 12:18 +0200, Michael Buesch wrote:
> 
> > Well, it's not that easy. Current code just doesn't make any sense.
> > I do not understand how hardware power control works exactly, so I
> > can't write some detailed message or something.
> > That's probably a chicken and egg problem ;)
> 
> OK, the existing code complains that one number is larger than another.
> You don't want to hide that message, but when I ask you to explain, you
> say that the code makes no sense to you.

So?

> Somehow, it doesn't sound right.  Nobody knows the code better than you.
> I think communication is essential for development.

I know that this is broken (So we don't hide the bug by removing the
message), but I don't know how to fix it. Is that such an unusual
condition? I simply don't understand how the hardware works.
Sure, we can simply hide the bug by changing the code so that it
doesn't complain anymore.
That's not the issue here. The problem is, that I don't know how
to fix this _correctly_.

So, that said, I'm not sure which lack of communication you are talking
about. I do _not_ know how that stuff works. So, if you want to try
understanding it, read the code and specs and try to make sense out
of it.

I am working on this stuff. I have limited time and I'm not Merlin
the magician. So I have to try understanding this stuff.


From josejx at gentoo.org  Mon Aug  6 14:42:39 2007
From: josejx at gentoo.org (Joseph Jezak)
Date: Mon, 06 Aug 2007 08:42:39 -0400
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but	Ethernet
	appears broken
In-Reply-To: <1186403076.10627.23.camel@dv>
References: <46B38B0F.20808@Wetwork.Net>
	<200708041847.30250.mb@bu3sch.de>	<1186271342.1948.10.camel@dv>
	<200708051218.20277.mb@bu3sch.de> <1186403076.10627.23.camel@dv>
Message-ID: <46B7173F.6000802@gentoo.org>

Pavel Roskin wrote:
> On Sun, 2007-08-05 at 12:18 +0200, Michael Buesch wrote:
> 
>> Well, it's not that easy. Current code just doesn't make any sense.
>> I do not understand how hardware power control works exactly, so I
>> can't write some detailed message or something.
>> That's probably a chicken and egg problem ;)
> 
> OK, the existing code complains that one number is larger than another.
> You don't want to hide that message, but when I ask you to explain, you
> say that the code makes no sense to you.
> 
> Somehow, it doesn't sound right.  Nobody knows the code better than you.
> I think communication is essential for development.
> 

Pavel,

The problem is that the reverse engineering team (myself and 
Johannes) don't understand the code in the original driver well 
enough. The power control code is certainly the most confusing and 
incomplete part of our specs.  While I'd love to spend the time 
figuring it out, I just can't spend that time right now.

-Joe


From proski at gnu.org  Mon Aug  6 14:56:53 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 06 Aug 2007 08:56:53 -0400
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211
	associates,	but	Ethernet appears broken
In-Reply-To: <46B7173F.6000802@gentoo.org>
References: <46B38B0F.20808@Wetwork.Net> <200708041847.30250.mb@bu3sch.de>
	<1186271342.1948.10.camel@dv>  <200708051218.20277.mb@bu3sch.de>
	<1186403076.10627.23.camel@dv>  <46B7173F.6000802@gentoo.org>
Message-ID: <1186405013.10627.34.camel@dv>

On Mon, 2007-08-06 at 08:42 -0400, Joseph Jezak wrote:

> The problem is that the reverse engineering team (myself and 
> Johannes) don't understand the code in the original driver well 
> enough. The power control code is certainly the most confusing and 
> incomplete part of our specs.  While I'd love to spend the time 
> figuring it out, I just can't spend that time right now.

Well, this reminds me "The Mad Hatter's Tea Party" with me being
Alice :)

Anyway, good luck with the driver work!

-- 
Regards,
Pavel Roskin



From linville at tuxdriver.com  Mon Aug  6 17:04:53 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Mon, 6 Aug 2007 11:04:53 -0400
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but?Ethernet appears broken
In-Reply-To: <200708041847.30250.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net> <1186198060.28481.6.camel@dv>
	<46B3F5D3.5090800@lwfinger.net> <200708041847.30250.mb@bu3sch.de>
Message-ID: <20070806150453.GC6442@tuxdriver.com>

On Sat, Aug 04, 2007 at 06:47:29PM +0200, Michael Buesch wrote:
> On Saturday 04 August 2007, Larry Finger wrote:
> > Pavel Roskin wrote:
> > > On Fri, 2007-08-03 at 20:46 -0500, Larry Finger wrote:
> > > 
> > >> The size of LO array message is not fatal.
> > > 
> > > I'll really appreciate if it's removed or at least the stack dump is
> > > suppressed.  We know already that it's a problem, so why scare users
> > > more than they need to?  We know where it happens, why show the stack?
> > > 
> > > I don't think we want to make users ignore stack traces in the kernel
> > > logs, because we may not hear about unknown problems.
> > > 
> > > IMHO there are better places for TODO notes than innocent users' kernel
> > > logs.
> > 
> > I agree completely; however, I've had my "hands slapped" in the past for removing that kind of 
> > message. As a result, I leave them alone.
> 
> Well, there are good reasons for not removing this.
> The resons include that this message is only shown for the debug build.
> So if you want it to shut up, don't compile a debug build.

Is there a real need for the call to dump_stack on err?  Isn't the
printk (bcmdbg) good enough?

John
-- 
John W. Linville
linville at tuxdriver.com


From mb at bu3sch.de  Mon Aug  6 17:55:00 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 6 Aug 2007 17:55:00 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but?Ethernet appears broken
In-Reply-To: <20070806150453.GC6442@tuxdriver.com>
References: <46B38B0F.20808@Wetwork.Net> <200708041847.30250.mb@bu3sch.de>
	<20070806150453.GC6442@tuxdriver.com>
Message-ID: <200708061755.00712.mb@bu3sch.de>

On Monday 06 August 2007, John W. Linville wrote:
> On Sat, Aug 04, 2007 at 06:47:29PM +0200, Michael Buesch wrote:
> > On Saturday 04 August 2007, Larry Finger wrote:
> > > Pavel Roskin wrote:
> > > > On Fri, 2007-08-03 at 20:46 -0500, Larry Finger wrote:
> > > > 
> > > >> The size of LO array message is not fatal.
> > > > 
> > > > I'll really appreciate if it's removed or at least the stack dump is
> > > > suppressed.  We know already that it's a problem, so why scare users
> > > > more than they need to?  We know where it happens, why show the stack?
> > > > 
> > > > I don't think we want to make users ignore stack traces in the kernel
> > > > logs, because we may not hear about unknown problems.
> > > > 
> > > > IMHO there are better places for TODO notes than innocent users' kernel
> > > > logs.
> > > 
> > > I agree completely; however, I've had my "hands slapped" in the past for removing that kind of 
> > > message. As a result, I leave them alone.
> > 
> > Well, there are good reasons for not removing this.
> > The resons include that this message is only shown for the debug build.
> > So if you want it to shut up, don't compile a debug build.
> 
> Is there a real need for the call to dump_stack on err?  Isn't the
> printk (bcmdbg) good enough?

Well, without a stacktrace you don't know who caused the error.
We can remove that. But I still don't know what we gain from
removing useful debug messages. If you don't care about bcm43xx bugs, simply
disable bcm43xx debugging.


From larry.finger at lwfinger.net  Mon Aug  6 18:59:33 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 06 Aug 2007 11:59:33 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but?Ethernet
	appears broken
In-Reply-To: <200708061755.00712.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net>
	<200708041847.30250.mb@bu3sch.de>	<20070806150453.GC6442@tuxdriver.com>
	<200708061755.00712.mb@bu3sch.de>
Message-ID: <46B75375.10008@lwfinger.net>

Michael Buesch wrote:
> 
> Well, without a stacktrace you don't know who caused the error.
> We can remove that. But I still don't know what we gain from
> removing useful debug messages. If you don't care about bcm43xx bugs, simply
> disable bcm43xx debugging.

Michael, I agree with you in general, but in this case we know that the line "bbatt.att = 11" in
bcm43xx_phy_init_pctl leads to this error message. Why don't we change it to 'bbatt.att = 8' to
eliminate this particular error message? That way the debugging info can stay in without polluting
everyone's log.

Larry

The patch is:


Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
@@ -725,7 +725,7 @@ static void bcm43xx_phy_init_pctl(struct
  			memcpy(&old_bbatt, &phy->bbatt, sizeof(old_bbatt));
  			old_tx_control = phy->tx_control;

-			bbatt.att = 11;
+			bbatt.att = 8;
  			if (phy->radio_rev == 8) {
  				rfatt.att = 15;
  				rfatt.with_padmix = 1;




From mb at bu3sch.de  Mon Aug  6 19:24:36 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 6 Aug 2007 19:24:36 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	=?iso-8859-1?q?=09but=3FEthernet_appears?= broken
In-Reply-To: <46B75375.10008@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <200708061755.00712.mb@bu3sch.de>
	<46B75375.10008@lwfinger.net>
Message-ID: <200708061924.36786.mb@bu3sch.de>

On Monday 06 August 2007, Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > Well, without a stacktrace you don't know who caused the error.
> > We can remove that. But I still don't know what we gain from
> > removing useful debug messages. If you don't care about bcm43xx bugs, simply
> > disable bcm43xx debugging.
> 
> Michael, I agree with you in general, but in this case we know that the line "bbatt.att = 11" in
> bcm43xx_phy_init_pctl leads to this error message. Why don't we change it to 'bbatt.att = 8' to
> eliminate this particular error message? That way the debugging info can stay in without polluting
> everyone's log.

Because that would simply be plain wrong.
The specs says we have to write 11. So we write 11 and not something else to
workaround bugs in other parts of the code.
I don't feel comfortable with introducing bugs to hide other bugs.
Someone must reverse engineer all that stuff again. But currently we have nobody
with enough time to do this.


From linville at tuxdriver.com  Mon Aug  6 19:05:00 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Mon, 6 Aug 2007 13:05:00 -0400
Subject: mac80211 IPv6 problems
In-Reply-To: <200708030102.17358.flamingice@sourmilk.net>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<1186094778.6701.6.camel@shinybook.infradead.org>
	<20070803005517.GA4261@tuxdriver.com>
	<200708030102.17358.flamingice@sourmilk.net>
Message-ID: <20070806170500.GE6442@tuxdriver.com>

On Fri, Aug 03, 2007 at 01:02:12AM -0700, Michael Wu wrote:

> This doesn't seem quite right. I think ieee80211_rx_h_data is a safer place 
> for this check (inside the IEEE80211_FCTL_FROMDS case), and allows various 
> statistics to be updated. ieee80211_rx_h_sta_process is another function that 
> might work though that would probably involve more code to add all the right 
> checks.

The patch below seems to work for me w/ an otherwise stock F-7 kernel
w/ iwl3945.  Thoughts?

From: John W. Linville <linville at tuxdriver.com>

[PATCH] mac80211: filter locally-originated multicast frames

In STA mode, the AP will echo our traffic.  This includes multicast
traffice.

Receiving these frames confuses some protocols and applications,
notably IPv6 Duplicate Address Detection.

Signed-off-by: John W. Linville <linville at tuxdriver.com>
---

 net/mac80211/ieee80211.c |    5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/net/mac80211/ieee80211.c b/net/mac80211/ieee80211.c
index a42e70e..0097b0a 100644
--- a/net/mac80211/ieee80211.c
+++ b/net/mac80211/ieee80211.c
@@ -3030,9 +3030,10 @@ ieee80211_rx_h_data(struct ieee80211_txrx_data *rx)
 		memcpy(dst, hdr->addr1, ETH_ALEN);
 		memcpy(src, hdr->addr3, ETH_ALEN);
 
-		if (sdata->type != IEEE80211_IF_TYPE_STA) {
+		if (sdata->type != IEEE80211_IF_TYPE_STA ||
+		    (is_multicast_ether_addr(dst) &&
+		     !compare_ether_addr(src, dev->dev_addr)))
 			return TXRX_DROP;
-		}
 		break;
 	case 0:
 		/* DA SA BSSID */


-- 
John W. Linville
linville at tuxdriver.com


From will.dyson at gmail.com  Mon Aug  6 21:45:13 2007
From: will.dyson at gmail.com (Will Dyson)
Date: Mon, 6 Aug 2007 15:45:13 -0400
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <1186403076.10627.23.camel@dv>
References: <46B38B0F.20808@Wetwork.Net> <200708041847.30250.mb@bu3sch.de>
	<1186271342.1948.10.camel@dv> <200708051218.20277.mb@bu3sch.de>
	<1186403076.10627.23.camel@dv>
Message-ID: <8e6f94720708061245r5e58898by70099468af76532c@mail.gmail.com>

On 8/6/07, Pavel Roskin <proski at gnu.org> wrote:
> On Sun, 2007-08-05 at 12:18 +0200, Michael Buesch wrote:
>
> > Well, it's not that easy. Current code just doesn't make any sense.
> > I do not understand how hardware power control works exactly, so I
> > can't write some detailed message or something.
> > That's probably a chicken and egg problem ;)
>
> OK, the existing code complains that one number is larger than another.
> You don't want to hide that message, but when I ask you to explain, you
> say that the code makes no sense to you.

I will attempt an explanation of the issue, since I've been trying to
wrap my own head around it lately. It boils down to a contradiction in
the specs.

For a G phy, the power control is set by 2 attenuation values. The
chip wants the values themselves, and also the results of  looking up
these values in the LO table (which we build at device init and
periodically refresh).

The specs tell us how to build the LO table by looping over a list of
values and measuring hardware parameters for each
(http://bcm-v4.sipsolutions.net/802.11/LO/GPHY/BuildingTheTable). The
list of values is supplied
(http://bcm-v4.sipsolutions.net/802.11/LO/Tables). We make the LO
lookup table large enough to hold all these values, but no larger than
that (since anything else should not be initialized according to
specs).

Then the specs tell us to initialize the power control by setting the
TX power variables to a known state and measuring power output
(http://bcm-v4.sipsolutions.net/802.11/PHY/G/Power_Control).

Here is the problem: One of the TX power values the spec tells us to
use for this  is larger than the max value used when building the LO
lookup table. To set the TX power, we need to index into the LO table
with these values.

The spec is telling us to lookup an invalid index in the LO table.

Currently, the driver deals with this by catching invalid LO table
indexes and returning the value at the zero index. But this cannot
possibly be the right thing to do; it merely avoids an oops in the
driver. When high-level code tells low-level code to do something
stupid, printing a warning seems appropriate (even if a stack trace is
not needed any more).

-- 
Will Dyson


From Larry.Finger at lwfinger.net  Mon Aug  6 22:22:14 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 06 Aug 2007 15:22:14 -0500
Subject: [RFC] bcm43xx-mac80211: Add TX power set file to debugfs
Message-ID: <46b782f6.XGqOxV2KvXubz5jy%Larry.Finger@lwfinger.net>

For testing purposes, this patch adds a file named "power_level" to the
debugfs for bcm43xx-mac80211. If this file is read, it returns the current
setting for the "Desired power level". Writing a number between 5 and 18
will set that value as the new value for the desired power setting.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
@@ -151,6 +151,74 @@ out_unlock_bb:
 	return res;
 }
 
+static ssize_t power_read_file(struct file *file, char __user *userbuf,
+			     size_t count, loff_t *ppos)
+{
+	struct bcm43xx_wldev *dev = file->private_data;
+	const size_t len = ARRAY_SIZE(big_buffer);
+	char *buf = big_buffer;
+	size_t pos = 0;
+	ssize_t res;
+	unsigned long flags;
+
+	mutex_lock(&big_buffer_mutex);
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
+		fappend("Board not initialized.\n");
+		goto out;
+	}
+	fappend("%d dBm\n",dev->phy.power_level);
+
+out:
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
+	mutex_unlock(&big_buffer_mutex);
+
+	return res;
+}
+
+static ssize_t power_write_file(struct file *file, const char __user *user_buf,
+			      size_t count, loff_t *ppos)
+{
+	struct bcm43xx_wldev *dev = file->private_data;
+	char *buf = big_buffer;
+	ssize_t buf_size;
+	ssize_t res;
+	unsigned long flags;
+	int power;
+
+	mutex_lock(&big_buffer_mutex);
+	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
+	if (copy_from_user(buf, user_buf, buf_size)) {
+	        res = -EFAULT;
+		goto out_unlock_bb;
+	}
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
+		bcmerr(dev->wl, "debugfs: Board not initialized.\n");
+		res = -EFAULT;
+		goto out_unlock;
+	}
+	if ((sscanf(buf, "%d", &power) != 1) || (power > 18 || power < 5)) {
+		bcmerr(dev->wl, "debugfs: Invalid values for power level\n");
+		res = -EINVAL;
+		goto out_unlock;
+	}
+	dev->phy.power_level = power;
+	res = buf_size;
+
+out_unlock:
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+out_unlock_bb:
+	mutex_unlock(&big_buffer_mutex);
+
+	return res;
+}
+
 static ssize_t txstat_read_file(struct file *file, char __user *userbuf,
 				size_t count, loff_t *ppos)
 {
@@ -405,6 +473,12 @@ static struct file_operations restart_fo
 	.open = open_file_generic,
 };
 
+static struct file_operations power_fops = {
+	.read = power_read_file,
+	.write = power_write_file,
+	.open = open_file_generic,
+};
+
 
 int bcm43xx_debug(struct bcm43xx_wldev *dev, enum bcm43xx_dyndbg feature)
 {
@@ -495,6 +569,11 @@ void bcm43xx_debugfs_add_device(struct b
 	if (IS_ERR(e->dentry_restart))
 		e->dentry_restart = NULL;
 
+	e->dentry_power = debugfs_create_file("power_level", 0600, e->subdir,
+					     dev, &power_fops);
+	if (IS_ERR(e->dentry_power))
+		e->dentry_power = NULL;
+
 	bcm43xx_add_dynamic_debug(dev);
 }
 
@@ -512,6 +591,7 @@ void bcm43xx_debugfs_remove_device(struc
 	debugfs_remove(e->dentry_txstat);
 	debugfs_remove(e->dentry_restart);
 	debugfs_remove(e->dentry_txpower_g);
+	debugfs_remove(e->dentry_power);
 	debugfs_remove(e->subdir);
 	kfree(e->txstatlog.log);
 	kfree(e);
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
@@ -35,6 +35,7 @@ struct bcm43xx_dfsentry {
 	struct dentry *dentry_txstat;
 	struct dentry *dentry_txpower_g;
 	struct dentry *dentry_restart;
+	struct dentry *dentry_power;
 
 	struct bcm43xx_wldev *dev;
 
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -2762,12 +2762,11 @@ static int bcm43xx_dev_config(struct iee
 	}
 
 	/* Adjust the desired TX power level. */
-	if (conf->power_level != 0) {
-		if (conf->power_level != phy->power_level) {
-			phy->power_level = conf->power_level;
-			bcm43xx_phy_xmitpower(dev);
-		}
-	}
+	if (conf->power_level != 0 && phy->power_level == 0) {
+		phy->power_level = conf->power_level;
+	} else
+		phy->power_level = 10;
+	bcm43xx_phy_xmitpower(dev);
 
 	/* Hide/Show the SSID (AP mode only). */
 	if (conf->flags & IEEE80211_CONF_SSID_HIDDEN) {


From mb at bu3sch.de  Mon Aug  6 22:25:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 6 Aug 2007 22:25:58 +0200
Subject: [RFC] bcm43xx-mac80211: Add TX power set file to debugfs
In-Reply-To: <46b782f6.XGqOxV2KvXubz5jy%Larry.Finger@lwfinger.net>
References: <46b782f6.XGqOxV2KvXubz5jy%Larry.Finger@lwfinger.net>
Message-ID: <200708062225.58737.mb@bu3sch.de>

On Monday 06 August 2007 22:22:14 Larry Finger wrote:
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -2762,12 +2762,11 @@ static int bcm43xx_dev_config(struct iee
>  	}
>  
>  	/* Adjust the desired TX power level. */
> -	if (conf->power_level != 0) {
> -		if (conf->power_level != phy->power_level) {
> -			phy->power_level = conf->power_level;
> -			bcm43xx_phy_xmitpower(dev);
> -		}
> -	}
> +	if (conf->power_level != 0 && phy->power_level == 0) {
> +		phy->power_level = conf->power_level;
> +	} else
> +		phy->power_level = 10;
> +	bcm43xx_phy_xmitpower(dev);

No, what's that? I disagree with that.
This breaks power adjustment.

>  
>  	/* Hide/Show the SSID (AP mode only). */
>  	if (conf->flags & IEEE80211_CONF_SSID_HIDDEN) {
> 
> 



-- 
Greetings Michael.


From larry.finger at lwfinger.net  Mon Aug  6 22:36:49 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 06 Aug 2007 15:36:49 -0500
Subject: [RFC] bcm43xx-mac80211: Add TX power set file to debugfs
In-Reply-To: <200708062225.58737.mb@bu3sch.de>
References: <46b782f6.XGqOxV2KvXubz5jy%Larry.Finger@lwfinger.net>
	<200708062225.58737.mb@bu3sch.de>
Message-ID: <46B78661.4050807@lwfinger.net>

Michael Buesch wrote:
> On Monday 06 August 2007 22:22:14 Larry Finger wrote:
>> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
>> ===================================================================
>> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
>> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
>> @@ -2762,12 +2762,11 @@ static int bcm43xx_dev_config(struct iee
>>  	}
>>  
>>  	/* Adjust the desired TX power level. */
>> -	if (conf->power_level != 0) {
>> -		if (conf->power_level != phy->power_level) {
>> -			phy->power_level = conf->power_level;
>> -			bcm43xx_phy_xmitpower(dev);
>> -		}
>> -	}
>> +	if (conf->power_level != 0 && phy->power_level == 0) {
>> +		phy->power_level = conf->power_level;
>> +	} else
>> +		phy->power_level = 10;
>> +	bcm43xx_phy_xmitpower(dev);
> 
> No, what's that? I disagree with that.
> This breaks power adjustment.
> 

I just discovered that it fails. When I find the problem, I'll resubmit. Is the debugfs part right?

Larry


From richie at coderworld.net  Mon Aug  6 22:39:11 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Mon, 6 Aug 2007 22:39:11 +0200
Subject: Port of bcm43xx from softmac to mac80211 is available for testing
In-Reply-To: <46B63D05.8040709@lwfinger.net>
References: <46B50B3C.7000906@lwfinger.net>
	<200708052115.51758.richie@coderworld.net>
	<46B63D05.8040709@lwfinger.net>
Message-ID: <200708062239.13256.richie@coderworld.net>

On Sunday 05 August 2007 23:11:33 you wrote:
> Richard Jonsson wrote:
> > Isn't Desired TX power supposed to adapt so that higher bitrates are
> > possible, with Bit Rate going lower if that is not enough to keep a good
> > connection?
>
> It should, but this feature is not yet implemented. I have some test code
> to do this, but it is not ready. When it is, I'll send you a trial patch.
> Check if your system has a file names
> /sys/kernel/debug/bcm43xx/phyX/power_level. If it does, you can write new
> values for the Desired power into it. Values up to 18 are allowed.
>
I see, and thank you for the tip. I thought power_level was read-only.

> > 11M mode is unusable at all distances, 12M works fine. This probably
> > breaks rate scaling for me.
>
> Yes, it certainly would. My 4311 shows a little dip at 11 Mbs, but not as
> big as yours. Is your AP using b/g mode, or just g mode? What is the make
> and model of the AP?
>
It's a netgear wgt634u, most recent "stable" firmware, configured for B/G.

> > "rmmod bcm43xx" when kde is running hangs rmmod and prevents a clean
> > shutdown. I tried to find which program causes this while using bcm4301
> > driver, but so far no luck. System shuts down fine if I don't try to
> > rmmod first. rmmod works fine from runlevel 3 aside from this message
> > when inserting module again:
> > "net eth1: device_rename: sysfs_create_symlink failed (-17)"
>
> On my system, I routinely unload the module using 'modprobe -r bcm43xx'.
> Sometimes, it happens 20 or 30 times between reboots. These are always at
> runlevel 5. Only once or twice has it not completed. Are you using
> NetworkManager or using the traditional ifup/ifdown methods?
>
Networkmanager+knetworkmanager. killing these before rmmod doesn't help.

> > Nitpicking:
> > When changing bitrate manually it will not show up with iwconfig before
> > any traffic has occured.
>
> This is a mac80211 problem. My original version of the patch that
> implemented the "set rate" function loaded the new rate so that it would
> show up immediately, but that part was nixed. Complain on
> wireless-dev at vger.kernel.org.
>
Maybe I will. It's not that big of an issue, but still confusing for those 
unknowing.

> > Sometimes iwconfig link quality shows values in the whole 0-255 range.
>
> Do the Signal and Noise levels show -256 dBm at the same time? If so,
> mac80211 has not received any data.
>
Sometimes signal fluctuates at the same time, noise is pretty much always 
around -70dBm. I can't recall I've seen it show -256 for this driver.

> Larry




From mb at bu3sch.de  Mon Aug  6 22:45:21 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 6 Aug 2007 22:45:21 +0200
Subject: [RFC] bcm43xx-mac80211: Add TX power set file to debugfs
In-Reply-To: <46B78661.4050807@lwfinger.net>
References: <46b782f6.XGqOxV2KvXubz5jy%Larry.Finger@lwfinger.net>
	<200708062225.58737.mb@bu3sch.de> <46B78661.4050807@lwfinger.net>
Message-ID: <200708062245.22117.mb@bu3sch.de>

On Monday 06 August 2007 22:36:49 Larry Finger wrote:
> Michael Buesch wrote:
> > On Monday 06 August 2007 22:22:14 Larry Finger wrote:
> >> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> >> ===================================================================
> >> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> >> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> >> @@ -2762,12 +2762,11 @@ static int bcm43xx_dev_config(struct iee
> >>  	}
> >>  
> >>  	/* Adjust the desired TX power level. */
> >> -	if (conf->power_level != 0) {
> >> -		if (conf->power_level != phy->power_level) {
> >> -			phy->power_level = conf->power_level;
> >> -			bcm43xx_phy_xmitpower(dev);
> >> -		}
> >> -	}
> >> +	if (conf->power_level != 0 && phy->power_level == 0) {
> >> +		phy->power_level = conf->power_level;
> >> +	} else
> >> +		phy->power_level = 10;
> >> +	bcm43xx_phy_xmitpower(dev);
> > 
> > No, what's that? I disagree with that.
> > This breaks power adjustment.
> > 
> 
> I just discovered that it fails. When I find the problem, I'll resubmit. Is the debugfs part right?

I think so.
Although, (I think you know that), it does not immediately
reconfigure the power, but waits for the next pwork with enough
tssi information.

-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Mon Aug  6 22:55:30 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 06 Aug 2007 15:55:30 -0500
Subject: [RFC V2] bcm43xx-mac80211: Add TX power set file to debugfs
Message-ID: <46b78ac2.M4X/XQ9LXYHUe/aO%Larry.Finger@lwfinger.net>

For testing purposes, this patch adds a file named "power_level" to the
debugfs for bcm43xx-mac80211. If this file is read, it returns the current
setting for the "Desired power level". Writing a number between 5 and 18
will set that value as the new value for the desired power setting.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Michael,

The error before is fixed in this version.

Larry

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
@@ -151,6 +151,74 @@ out_unlock_bb:
 	return res;
 }
 
+static ssize_t power_read_file(struct file *file, char __user *userbuf,
+			     size_t count, loff_t *ppos)
+{
+	struct bcm43xx_wldev *dev = file->private_data;
+	const size_t len = ARRAY_SIZE(big_buffer);
+	char *buf = big_buffer;
+	size_t pos = 0;
+	ssize_t res;
+	unsigned long flags;
+
+	mutex_lock(&big_buffer_mutex);
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
+		fappend("Board not initialized.\n");
+		goto out;
+	}
+	fappend("%d dBm\n",dev->phy.power_level);
+
+out:
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
+	mutex_unlock(&big_buffer_mutex);
+
+	return res;
+}
+
+static ssize_t power_write_file(struct file *file, const char __user *user_buf,
+			      size_t count, loff_t *ppos)
+{
+	struct bcm43xx_wldev *dev = file->private_data;
+	char *buf = big_buffer;
+	ssize_t buf_size;
+	ssize_t res;
+	unsigned long flags;
+	int power;
+
+	mutex_lock(&big_buffer_mutex);
+	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
+	if (copy_from_user(buf, user_buf, buf_size)) {
+	        res = -EFAULT;
+		goto out_unlock_bb;
+	}
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
+		bcmerr(dev->wl, "debugfs: Board not initialized.\n");
+		res = -EFAULT;
+		goto out_unlock;
+	}
+	if ((sscanf(buf, "%d", &power) != 1) || (power > 18 || power < 5)) {
+		bcmerr(dev->wl, "debugfs: Invalid values for power level\n");
+		res = -EINVAL;
+		goto out_unlock;
+	}
+	dev->phy.power_level = power;
+	res = buf_size;
+
+out_unlock:
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+out_unlock_bb:
+	mutex_unlock(&big_buffer_mutex);
+
+	return res;
+}
+
 static ssize_t txstat_read_file(struct file *file, char __user *userbuf,
 				size_t count, loff_t *ppos)
 {
@@ -405,6 +473,12 @@ static struct file_operations restart_fo
 	.open = open_file_generic,
 };
 
+static struct file_operations power_fops = {
+	.read = power_read_file,
+	.write = power_write_file,
+	.open = open_file_generic,
+};
+
 
 int bcm43xx_debug(struct bcm43xx_wldev *dev, enum bcm43xx_dyndbg feature)
 {
@@ -495,6 +569,11 @@ void bcm43xx_debugfs_add_device(struct b
 	if (IS_ERR(e->dentry_restart))
 		e->dentry_restart = NULL;
 
+	e->dentry_power = debugfs_create_file("power_level", 0600, e->subdir,
+					     dev, &power_fops);
+	if (IS_ERR(e->dentry_power))
+		e->dentry_power = NULL;
+
 	bcm43xx_add_dynamic_debug(dev);
 }
 
@@ -512,6 +591,7 @@ void bcm43xx_debugfs_remove_device(struc
 	debugfs_remove(e->dentry_txstat);
 	debugfs_remove(e->dentry_restart);
 	debugfs_remove(e->dentry_txpower_g);
+	debugfs_remove(e->dentry_power);
 	debugfs_remove(e->subdir);
 	kfree(e->txstatlog.log);
 	kfree(e);
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
@@ -35,6 +35,7 @@ struct bcm43xx_dfsentry {
 	struct dentry *dentry_txstat;
 	struct dentry *dentry_txpower_g;
 	struct dentry *dentry_restart;
+	struct dentry *dentry_power;
 
 	struct bcm43xx_wldev *dev;
 
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -2763,7 +2763,8 @@ static int bcm43xx_dev_config(struct iee
 
 	/* Adjust the desired TX power level. */
 	if (conf->power_level != 0) {
-		if (conf->power_level != phy->power_level) {
+		if (conf->power_level != phy->power_level &&
+		    phy->power_level == 0) {
 			phy->power_level = conf->power_level;
 			bcm43xx_phy_xmitpower(dev);
 		}


From mb at bu3sch.de  Mon Aug  6 23:07:40 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 6 Aug 2007 23:07:40 +0200
Subject: [RFC V2] bcm43xx-mac80211: Add TX power set file to debugfs
In-Reply-To: <46b78ac2.M4X/XQ9LXYHUe/aO%Larry.Finger@lwfinger.net>
References: <46b78ac2.M4X/XQ9LXYHUe/aO%Larry.Finger@lwfinger.net>
Message-ID: <200708062307.40590.mb@bu3sch.de>

On Monday 06 August 2007 22:55:30 Larry Finger wrote:
> For testing purposes, this patch adds a file named "power_level" to the
> debugfs for bcm43xx-mac80211. If this file is read, it returns the current
> setting for the "Desired power level". Writing a number between 5 and 18
> will set that value as the new value for the desired power setting.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Michael,
> 
> The error before is fixed in this version.
> 
> Larry
> 
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
> @@ -151,6 +151,74 @@ out_unlock_bb:
>  	return res;
>  }
>  
> +static ssize_t power_read_file(struct file *file, char __user *userbuf,
> +			     size_t count, loff_t *ppos)
> +{
> +	struct bcm43xx_wldev *dev = file->private_data;
> +	const size_t len = ARRAY_SIZE(big_buffer);
> +	char *buf = big_buffer;
> +	size_t pos = 0;
> +	ssize_t res;
> +	unsigned long flags;
> +
> +	mutex_lock(&big_buffer_mutex);
> +	mutex_lock(&dev->wl->mutex);
> +	spin_lock_irqsave(&dev->wl->irq_lock, flags);
> +	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
> +		fappend("Board not initialized.\n");
> +		goto out;
> +	}
> +	fappend("%d dBm\n",dev->phy.power_level);
> +
> +out:
> +	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
> +	mutex_unlock(&dev->wl->mutex);
> +	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
> +	mutex_unlock(&big_buffer_mutex);
> +
> +	return res;
> +}
> +
> +static ssize_t power_write_file(struct file *file, const char __user *user_buf,
> +			      size_t count, loff_t *ppos)
> +{
> +	struct bcm43xx_wldev *dev = file->private_data;
> +	char *buf = big_buffer;
> +	ssize_t buf_size;
> +	ssize_t res;
> +	unsigned long flags;
> +	int power;
> +
> +	mutex_lock(&big_buffer_mutex);
> +	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
> +	if (copy_from_user(buf, user_buf, buf_size)) {
> +	        res = -EFAULT;
> +		goto out_unlock_bb;
> +	}
> +	mutex_lock(&dev->wl->mutex);
> +	spin_lock_irqsave(&dev->wl->irq_lock, flags);
> +	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
> +		bcmerr(dev->wl, "debugfs: Board not initialized.\n");
> +		res = -EFAULT;
> +		goto out_unlock;
> +	}
> +	if ((sscanf(buf, "%d", &power) != 1) || (power > 18 || power < 5)) {
> +		bcmerr(dev->wl, "debugfs: Invalid values for power level\n");
> +		res = -EINVAL;
> +		goto out_unlock;
> +	}
> +	dev->phy.power_level = power;
> +	res = buf_size;
> +
> +out_unlock:
> +	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
> +	mutex_unlock(&dev->wl->mutex);
> +out_unlock_bb:
> +	mutex_unlock(&big_buffer_mutex);
> +
> +	return res;
> +}
> +
>  static ssize_t txstat_read_file(struct file *file, char __user *userbuf,
>  				size_t count, loff_t *ppos)
>  {
> @@ -405,6 +473,12 @@ static struct file_operations restart_fo
>  	.open = open_file_generic,
>  };
>  
> +static struct file_operations power_fops = {
> +	.read = power_read_file,
> +	.write = power_write_file,
> +	.open = open_file_generic,
> +};
> +
>  
>  int bcm43xx_debug(struct bcm43xx_wldev *dev, enum bcm43xx_dyndbg feature)
>  {
> @@ -495,6 +569,11 @@ void bcm43xx_debugfs_add_device(struct b
>  	if (IS_ERR(e->dentry_restart))
>  		e->dentry_restart = NULL;
>  
> +	e->dentry_power = debugfs_create_file("power_level", 0600, e->subdir,
> +					     dev, &power_fops);
> +	if (IS_ERR(e->dentry_power))
> +		e->dentry_power = NULL;
> +
>  	bcm43xx_add_dynamic_debug(dev);
>  }
>  
> @@ -512,6 +591,7 @@ void bcm43xx_debugfs_remove_device(struc
>  	debugfs_remove(e->dentry_txstat);
>  	debugfs_remove(e->dentry_restart);
>  	debugfs_remove(e->dentry_txpower_g);
> +	debugfs_remove(e->dentry_power);
>  	debugfs_remove(e->subdir);
>  	kfree(e->txstatlog.log);
>  	kfree(e);
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
> @@ -35,6 +35,7 @@ struct bcm43xx_dfsentry {
>  	struct dentry *dentry_txstat;
>  	struct dentry *dentry_txpower_g;
>  	struct dentry *dentry_restart;
> +	struct dentry *dentry_power;
>  
>  	struct bcm43xx_wldev *dev;
>  
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -2763,7 +2763,8 @@ static int bcm43xx_dev_config(struct iee
>  
>  	/* Adjust the desired TX power level. */
>  	if (conf->power_level != 0) {
> -		if (conf->power_level != phy->power_level) {
> +		if (conf->power_level != phy->power_level &&
> +		    phy->power_level == 0) {
>  			phy->power_level = conf->power_level;
>  			bcm43xx_phy_xmitpower(dev);
>  		}

No, why do you poke with this at all.
This completely breaks power adjustment from mac80211.
Simply don't touch bcm43xx_dev_config :)

-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Mon Aug  6 23:12:11 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 06 Aug 2007 16:12:11 -0500
Subject: [RFC] bcm43xx-mac80211: Hack to turn automatic pctl off
Message-ID: <46b78eab.GkVgzZjJwjJN76J8%Larry.Finger@lwfinger.net>

For testing purposes, this patch adds a file named "power_level" to the
debugfs for bcm43xx-mac80211. If this file is read, it returns the current
setting for the "Desired power level". Writing a number between 5 and 18
will set that value as the new value for the desired power setting.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Michael,

The error before is fixed in this version.

Larry

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
@@ -151,6 +151,74 @@ out_unlock_bb:
 	return res;
 }
 
+static ssize_t power_read_file(struct file *file, char __user *userbuf,
+			     size_t count, loff_t *ppos)
+{
+	struct bcm43xx_wldev *dev = file->private_data;
+	const size_t len = ARRAY_SIZE(big_buffer);
+	char *buf = big_buffer;
+	size_t pos = 0;
+	ssize_t res;
+	unsigned long flags;
+
+	mutex_lock(&big_buffer_mutex);
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
+		fappend("Board not initialized.\n");
+		goto out;
+	}
+	fappend("%d dBm\n",dev->phy.power_level);
+
+out:
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
+	mutex_unlock(&big_buffer_mutex);
+
+	return res;
+}
+
+static ssize_t power_write_file(struct file *file, const char __user *user_buf,
+			      size_t count, loff_t *ppos)
+{
+	struct bcm43xx_wldev *dev = file->private_data;
+	char *buf = big_buffer;
+	ssize_t buf_size;
+	ssize_t res;
+	unsigned long flags;
+	int power;
+
+	mutex_lock(&big_buffer_mutex);
+	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
+	if (copy_from_user(buf, user_buf, buf_size)) {
+	        res = -EFAULT;
+		goto out_unlock_bb;
+	}
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
+		bcmerr(dev->wl, "debugfs: Board not initialized.\n");
+		res = -EFAULT;
+		goto out_unlock;
+	}
+	if ((sscanf(buf, "%d", &power) != 1) || (power > 18 || power < 5)) {
+		bcmerr(dev->wl, "debugfs: Invalid values for power level\n");
+		res = -EINVAL;
+		goto out_unlock;
+	}
+	dev->phy.power_level = power;
+	res = buf_size;
+
+out_unlock:
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+out_unlock_bb:
+	mutex_unlock(&big_buffer_mutex);
+
+	return res;
+}
+
 static ssize_t txstat_read_file(struct file *file, char __user *userbuf,
 				size_t count, loff_t *ppos)
 {
@@ -405,6 +473,12 @@ static struct file_operations restart_fo
 	.open = open_file_generic,
 };
 
+static struct file_operations power_fops = {
+	.read = power_read_file,
+	.write = power_write_file,
+	.open = open_file_generic,
+};
+
 
 int bcm43xx_debug(struct bcm43xx_wldev *dev, enum bcm43xx_dyndbg feature)
 {
@@ -495,6 +569,11 @@ void bcm43xx_debugfs_add_device(struct b
 	if (IS_ERR(e->dentry_restart))
 		e->dentry_restart = NULL;
 
+	e->dentry_power = debugfs_create_file("power_level", 0600, e->subdir,
+					     dev, &power_fops);
+	if (IS_ERR(e->dentry_power))
+		e->dentry_power = NULL;
+
 	bcm43xx_add_dynamic_debug(dev);
 }
 
@@ -512,6 +591,7 @@ void bcm43xx_debugfs_remove_device(struc
 	debugfs_remove(e->dentry_txstat);
 	debugfs_remove(e->dentry_restart);
 	debugfs_remove(e->dentry_txpower_g);
+	debugfs_remove(e->dentry_power);
 	debugfs_remove(e->subdir);
 	kfree(e->txstatlog.log);
 	kfree(e);
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
@@ -35,6 +35,7 @@ struct bcm43xx_dfsentry {
 	struct dentry *dentry_txstat;
 	struct dentry *dentry_txpower_g;
 	struct dentry *dentry_restart;
+	struct dentry *dentry_power;
 
 	struct bcm43xx_wldev *dev;
 
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -2763,7 +2763,8 @@ static int bcm43xx_dev_config(struct iee
 
 	/* Adjust the desired TX power level. */
 	if (conf->power_level != 0) {
-		if (conf->power_level != phy->power_level) {
+		if (conf->power_level != phy->power_level &&
+		    phy->power_level == 0) {
 			phy->power_level = conf->power_level;
 			bcm43xx_phy_xmitpower(dev);
 		}


From larry.finger at lwfinger.net  Mon Aug  6 23:26:07 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 06 Aug 2007 16:26:07 -0500
Subject: [RFC V2] bcm43xx-mac80211: Add TX power set file to debugfs
In-Reply-To: <200708062307.40590.mb@bu3sch.de>
References: <46b78ac2.M4X/XQ9LXYHUe/aO%Larry.Finger@lwfinger.net>
	<200708062307.40590.mb@bu3sch.de>
Message-ID: <46B791EF.7000105@lwfinger.net>

Michael Buesch wrote:
> 
> No, why do you poke with this at all.
> This completely breaks power adjustment from mac80211.
> Simply don't touch bcm43xx_dev_config :)
> 

The problem is that mac80211 never seems to do any power adjustment. The funny 0x1b value for power 
level that I wondered about earlier is coming from a value of 27 dBm that is set in 
net/mac80211/regdomain.c, and conf->power_level doesn't get any information from anywhere else that 
I see.

Do you know how to get mac80211 to change what it is sending to us?

Larry



From Larry.Finger at lwfinger.net  Mon Aug  6 23:29:04 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 06 Aug 2007 16:29:04 -0500
Subject: [RFC] bcm43xx-mac80211: Hack to turn automatic pctl off
Message-ID: <46b792a0.FdNEyH1qMrUgo6oh%Larry.Finger@lwfinger.net>

Michael,

I sent the wrong message under this subject before.

This hack disabled hardware power control. With this installed and the
desired power set to 10 dBm using the previous patch, I get much, much
better performance from bcm43xx-mac80211 on my BCM4311. I have not yet
tested it on the BCM4306 or the BCM4318.

The new iperf readings for transmit/receive with the computer about 2 m
from the AP are as follows:

Bit Rate	xmit/receive (Mbs)

1M		1.11/8.70
2M		1.44/11.0
5.5M		4.15/13.3
6M		4.76/17.4
9M		6.55/18.2
11M		6.54/14.3
18M		10.7/18.5
24M		12.8/19.5
36M		16.1/19.7
48M		18.0/19.5
54M		18.6/19.0

These numbers are comparable with what I'm getting with the PHY port from
softmac. I don't understand the dip in received rate at 11M, but it is real.
On Richard Jonsson's 4311, he isn't able to measure the transfer rate at
11M.

With these settings, the rate adjustment proces bumps the rate to 54M
automatically.

Larry



Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
@@ -471,6 +471,7 @@ void bcm43xx_phy_early_init(struct bcm43
 	struct bcm43xx_phy *phy = &dev->phy;
 	struct bcm43xx_txpower_lo_control *lo = phy->lo_control;
 
+	phy->hw_pctl_off = 1;
 	default_baseband_attenuation(dev, &phy->bbatt);
 	default_radio_attenuation(dev, &phy->rfatt);
 	phy->tx_control = (default_tx_control(dev) << 4);
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
@@ -219,8 +219,9 @@ void bcm43xx_gphy_dc_lt_init(struct bcm4
 
 /* Returns the boolean whether the board has HardwarePowerControl */
 #define has_hardware_pctl(phy) \
+	(!((phy)->hw_pctl_off) &&				\
 	(((phy)->type == BCM43xx_PHYTYPE_A && (phy)->rev >= 5) ||	\
-	 ((phy)->type == BCM43xx_PHYTYPE_G && (phy)->rev >= 6))
+	 ((phy)->type == BCM43xx_PHYTYPE_G && (phy)->rev >= 6)))
 /* Returns the boolean whether "TX Magnification" is enabled. */
 #define has_tx_magnification(phy) \
 	(((phy)->rev >= 2) &&			\
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
@@ -534,6 +534,7 @@ struct bcm43xx_phy {
 	struct bcm43xx_bbatt bbatt;
 	struct bcm43xx_rfatt rfatt;
 	u8 tx_control; /* BCM43xx_TXCTL_XXX */
+	bool hw_pctl_off;
 #ifdef CONFIG_BCM43XX_MAC80211_DEBUG
 	bool manual_txpower_control; /* Manual TX-power control enabled? */
 #endif

---


From mb at bu3sch.de  Mon Aug  6 23:35:14 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 6 Aug 2007 23:35:14 +0200
Subject: [RFC V2] bcm43xx-mac80211: Add TX power set file to debugfs
In-Reply-To: <46B791EF.7000105@lwfinger.net>
References: <46b78ac2.M4X/XQ9LXYHUe/aO%Larry.Finger@lwfinger.net>
	<200708062307.40590.mb@bu3sch.de> <46B791EF.7000105@lwfinger.net>
Message-ID: <200708062335.14693.mb@bu3sch.de>

On Monday 06 August 2007 23:26:07 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > No, why do you poke with this at all.
> > This completely breaks power adjustment from mac80211.
> > Simply don't touch bcm43xx_dev_config :)
> > 
> 
> The problem is that mac80211 never seems to do any power adjustment. The funny 0x1b value for power 
> level that I wondered about earlier is coming from a value of 27 dBm that is set in 
> net/mac80211/regdomain.c, and conf->power_level doesn't get any information from anywhere else that 
> I see.
> 
> Do you know how to get mac80211 to change what it is sending to us?

I think we have an ioctl.
But it's probably the task of the rc algorithm to adjust power.

-- 
Greetings Michael.


From mb at bu3sch.de  Mon Aug  6 23:35:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 6 Aug 2007 23:35:48 +0200
Subject: [RFC] bcm43xx-mac80211: Hack to turn automatic pctl off
In-Reply-To: <46b792a0.FdNEyH1qMrUgo6oh%Larry.Finger@lwfinger.net>
References: <46b792a0.FdNEyH1qMrUgo6oh%Larry.Finger@lwfinger.net>
Message-ID: <200708062335.48546.mb@bu3sch.de>

On Monday 06 August 2007 23:29:04 Larry Finger wrote:
> Michael,
> 
> I sent the wrong message under this subject before.
> 
> This hack disabled hardware power control. With this installed and the
> desired power set to 10 dBm using the previous patch, I get much, much
> better performance from bcm43xx-mac80211 on my BCM4311. I have not yet
> tested it on the BCM4306 or the BCM4318.
> 
> The new iperf readings for transmit/receive with the computer about 2 m
> from the AP are as follows:
> 
> Bit Rate	xmit/receive (Mbs)
> 
> 1M		1.11/8.70
> 2M		1.44/11.0
> 5.5M		4.15/13.3
> 6M		4.76/17.4
> 9M		6.55/18.2
> 11M		6.54/14.3
> 18M		10.7/18.5
> 24M		12.8/19.5
> 36M		16.1/19.7
> 48M		18.0/19.5
> 54M		18.6/19.0
> 
> These numbers are comparable with what I'm getting with the PHY port from
> softmac. I don't understand the dip in received rate at 11M, but it is real.
> On Richard Jonsson's 4311, he isn't able to measure the transfer rate at
> 11M.
> 
> With these settings, the rate adjustment proces bumps the rate to 54M
> automatically.
> 
> Larry
> 
> 
> 
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> @@ -471,6 +471,7 @@ void bcm43xx_phy_early_init(struct bcm43
>  	struct bcm43xx_phy *phy = &dev->phy;
>  	struct bcm43xx_txpower_lo_control *lo = phy->lo_control;
>  
> +	phy->hw_pctl_off = 1;
>  	default_baseband_attenuation(dev, &phy->bbatt);
>  	default_radio_attenuation(dev, &phy->rfatt);
>  	phy->tx_control = (default_tx_control(dev) << 4);
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
> @@ -219,8 +219,9 @@ void bcm43xx_gphy_dc_lt_init(struct bcm4
>  
>  /* Returns the boolean whether the board has HardwarePowerControl */
>  #define has_hardware_pctl(phy) \
> +	(!((phy)->hw_pctl_off) &&				\
>  	(((phy)->type == BCM43xx_PHYTYPE_A && (phy)->rev >= 5) ||	\
> -	 ((phy)->type == BCM43xx_PHYTYPE_G && (phy)->rev >= 6))
> +	 ((phy)->type == BCM43xx_PHYTYPE_G && (phy)->rev >= 6)))
>  /* Returns the boolean whether "TX Magnification" is enabled. */
>  #define has_tx_magnification(phy) \
>  	(((phy)->rev >= 2) &&			\
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> @@ -534,6 +534,7 @@ struct bcm43xx_phy {
>  	struct bcm43xx_bbatt bbatt;
>  	struct bcm43xx_rfatt rfatt;
>  	u8 tx_control; /* BCM43xx_TXCTL_XXX */
> +	bool hw_pctl_off;
>  #ifdef CONFIG_BCM43XX_MAC80211_DEBUG
>  	bool manual_txpower_control; /* Manual TX-power control enabled? */
>  #endif
> 
> ---
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
> 
> 

I am currently doing a patch for this.

-- 
Greetings Michael.


From mb at bu3sch.de  Mon Aug  6 23:56:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 6 Aug 2007 23:56:58 +0200
Subject: [RFC] bcm43xx-mac80211: Hack to turn automatic pctl off
In-Reply-To: <200708062335.48546.mb@bu3sch.de>
References: <46b792a0.FdNEyH1qMrUgo6oh%Larry.Finger@lwfinger.net>
	<200708062335.48546.mb@bu3sch.de>
Message-ID: <200708062356.58782.mb@bu3sch.de>

On Monday 06 August 2007 23:35:48 Michael Buesch wrote:
> On Monday 06 August 2007 23:29:04 Larry Finger wrote:
> > Michael,
> > 
> > I sent the wrong message under this subject before.
> > 
> > This hack disabled hardware power control. With this installed and the
> > desired power set to 10 dBm using the previous patch, I get much, much
> > better performance from bcm43xx-mac80211 on my BCM4311. I have not yet
> > tested it on the BCM4306 or the BCM4318.
> > 
> > The new iperf readings for transmit/receive with the computer about 2 m
> > from the AP are as follows:
> > 
> > Bit Rate	xmit/receive (Mbs)
> > 
> > 1M		1.11/8.70
> > 2M		1.44/11.0
> > 5.5M		4.15/13.3
> > 6M		4.76/17.4
> > 9M		6.55/18.2
> > 11M		6.54/14.3
> > 18M		10.7/18.5
> > 24M		12.8/19.5
> > 36M		16.1/19.7
> > 48M		18.0/19.5
> > 54M		18.6/19.0
> > 
> > These numbers are comparable with what I'm getting with the PHY port from
> > softmac. I don't understand the dip in received rate at 11M, but it is real.
> > On Richard Jonsson's 4311, he isn't able to measure the transfer rate at
> > 11M.
> > 
> > With these settings, the rate adjustment proces bumps the rate to 54M
> > automatically.
> > 
> > Larry
> > 
> > 
> > 
> > Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> > ===================================================================
> > --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> > +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> > @@ -471,6 +471,7 @@ void bcm43xx_phy_early_init(struct bcm43
> >  	struct bcm43xx_phy *phy = &dev->phy;
> >  	struct bcm43xx_txpower_lo_control *lo = phy->lo_control;
> >  
> > +	phy->hw_pctl_off = 1;
> >  	default_baseband_attenuation(dev, &phy->bbatt);
> >  	default_radio_attenuation(dev, &phy->rfatt);
> >  	phy->tx_control = (default_tx_control(dev) << 4);
> > Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
> > ===================================================================
> > --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
> > +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
> > @@ -219,8 +219,9 @@ void bcm43xx_gphy_dc_lt_init(struct bcm4
> >  
> >  /* Returns the boolean whether the board has HardwarePowerControl */
> >  #define has_hardware_pctl(phy) \
> > +	(!((phy)->hw_pctl_off) &&				\
> >  	(((phy)->type == BCM43xx_PHYTYPE_A && (phy)->rev >= 5) ||	\
> > -	 ((phy)->type == BCM43xx_PHYTYPE_G && (phy)->rev >= 6))
> > +	 ((phy)->type == BCM43xx_PHYTYPE_G && (phy)->rev >= 6)))
> >  /* Returns the boolean whether "TX Magnification" is enabled. */
> >  #define has_tx_magnification(phy) \
> >  	(((phy)->rev >= 2) &&			\
> > Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> > ===================================================================
> > --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> > +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
> > @@ -534,6 +534,7 @@ struct bcm43xx_phy {
> >  	struct bcm43xx_bbatt bbatt;
> >  	struct bcm43xx_rfatt rfatt;
> >  	u8 tx_control; /* BCM43xx_TXCTL_XXX */
> > +	bool hw_pctl_off;
> >  #ifdef CONFIG_BCM43XX_MAC80211_DEBUG
> >  	bool manual_txpower_control; /* Manual TX-power control enabled? */
> >  #endif
> > 
> > ---
> > _______________________________________________
> > Bcm43xx-dev mailing list
> > Bcm43xx-dev at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
> > 
> > 
> 
> I am currently doing a patch for this.
> 

That's it
http://bu3sch.de/patches/wireless-dev/20070806-1186437386/patches/bcm43xx-mac80211-hwpctl-optional.patch

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Tue Aug  7 01:25:48 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 06 Aug 2007 18:25:48 -0500
Subject: [RFC] bcm43xx-mac80211: Hack to turn automatic pctl off
In-Reply-To: <200708062356.58782.mb@bu3sch.de>
References: <46b792a0.FdNEyH1qMrUgo6oh%Larry.Finger@lwfinger.net>
	<200708062335.48546.mb@bu3sch.de> <200708062356.58782.mb@bu3sch.de>
Message-ID: <46B7ADFC.3010005@lwfinger.net>

Michael Buesch wrote:
> On Monday 06 August 2007 23:35:48 Michael Buesch wrote:
>>
>> I am currently doing a patch for this.
>>
> 
> That's it
> http://bu3sch.de/patches/wireless-dev/20070806-1186437386/patches/bcm43xx-mac80211-hwpctl-optional.patch
>

It looks good. I'll test it later tonight.

I see where the ioctl to set txpower needs to be. It has not yet been coded, but I'll do that soon.

Larry





From larry.finger at lwfinger.net  Tue Aug  7 06:48:44 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 06 Aug 2007 23:48:44 -0500
Subject: [RFC] bcm43xx-mac80211: Hack to turn automatic pctl off
In-Reply-To: <200708062356.58782.mb@bu3sch.de>
References: <46b792a0.FdNEyH1qMrUgo6oh%Larry.Finger@lwfinger.net>
	<200708062335.48546.mb@bu3sch.de> <200708062356.58782.mb@bu3sch.de>
Message-ID: <46B7F9AC.10706@lwfinger.net>

Michael Buesch wrote:
> 
> That's it
> http://bu3sch.de/patches/wireless-dev/20070806-1186437386/patches/bcm43xx-mac80211-hwpctl-optional.patch
> 

This patch makes my BCM4311 positively hum even with the power set at the default 18.5 dBm. I get 
the same performance as was seen using the PHY code ported from softmac. Congratulations - you found 
the secret. Of course, the system will probably be even better when hardware power control is 
working, but we can now afford to wait until the reverse engineers have time.

I still have not tested with the BCM4318 and the BCM4306.

Larry



From johannes at sipsolutions.net  Tue Aug  7 11:51:48 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 07 Aug 2007 11:51:48 +0200
Subject: [RFC] bcm43xx-mac80211: Hack to turn automatic pctl off
In-Reply-To: <46B7F9AC.10706@lwfinger.net>
References: <46b792a0.FdNEyH1qMrUgo6oh%Larry.Finger@lwfinger.net>
	<200708062335.48546.mb@bu3sch.de> <200708062356.58782.mb@bu3sch.de>
	<46B7F9AC.10706@lwfinger.net>
Message-ID: <1186480308.4067.33.camel@johannes.berg>

On Mon, 2007-08-06 at 23:48 -0500, Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > That's it
> > http://bu3sch.de/patches/wireless-dev/20070806-1186437386/patches/bcm43xx-mac80211-hwpctl-optional.patch
> > 
> 
> This patch makes my BCM4311 positively hum even with the power set at the default 18.5 dBm. I get 
> the same performance as was seen using the PHY code ported from softmac. Congratulations - you found 
> the secret. Of course, the system will probably be even better when hardware power control is 
> working, but we can now afford to wait until the reverse engineers have time.

Cool stuff!

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070807/bb9aea33/attachment.pgp>

From mb at bu3sch.de  Tue Aug  7 12:51:46 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 7 Aug 2007 12:51:46 +0200
Subject: Corrupted frames with latest bcm43xx-mac80211?
Message-ID: <200708071251.46865.mb@bu3sch.de>

Hi,

(bringing this topic on list again)

I got a bugreport that latest bcm43xx-mac80211 generates
corrupted frames. So when doing tcpdump on the interface
just crap would come out.
I can not reproduce this. Does someone else see this behaviour?

The commit that introduced the bug was claimed to be
85a83d26697dd2203ac4e5f33022951f2c3e6e33
The patch is attached.

But I don't see how this patch could possibly break anything
in the TX or RX paths.

Someone any idea, or someone who can reproduce this and tell
me how to do?


diff --git a/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h b/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h
index 2802fc0..c5f9ef5 100644
--- a/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h
+++ b/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h
@@ -698,13 +698,13 @@ struct bcm43xx_firmware {
 
 /* Device (802.11 core) initialization status. */
 enum {
-	BCM43xx_STAT_UNINIT,		/* Uninitialized. */
-	BCM43xx_STAT_INITIALIZING,	/* bcm43xx_wireless_core_init() in progress. */
-	BCM43xx_STAT_INITIALIZED,	/* Initialized. Note that this doesn't mean it's started. */
+	BCM43xx_STAT_UNINIT		= 0, /* Uninitialized. */
+	BCM43xx_STAT_INITIALIZED	= 1, /* Initialized, but not started, yet. */
+	BCM43xx_STAT_STARTED		= 2, /* Up and running. */
 };
-#define bcm43xx_status(bcm)		atomic_read(&(bcm)->init_status)
-#define bcm43xx_set_status(bcm, stat)	do {			\
-		atomic_set(&(bcm)->init_status, (stat));	\
+#define bcm43xx_status(wldev)		atomic_read(&(wldev)->__init_status)
+#define bcm43xx_set_status(wldev, stat)	do {			\
+		atomic_set(&(wldev)->__init_status, (stat));	\
 		smp_wmb();					\
 					} while (0)
 
@@ -721,19 +721,18 @@ struct bcm43xx_wldev {
 	struct ssb_device *dev;
 	struct bcm43xx_wl *wl;
 
-	/* Driver initialization status BCM43xx_STAT_*** */
-	atomic_t init_status;
-	/* Interface started? (bcm43xx_wireless_core_start()) */
-	u8 started;
-
-	u16 was_initialized:1,		/* for suspend/resume. */
-	    was_started:1,		/* for suspend/resume. */
-	    __using_pio:1,		/* Internal, use bcm43xx_using_pio(). */
-	    bad_frames_preempt:1,	/* Use "Bad Frames Preemption" (default off) */
-	    reg124_set_0x4:1,		/* Some variable to keep track of IRQ stuff. */
-	    short_preamble:1,		/* TRUE, if short preamble is enabled. */
-	    short_slot:1,		/* TRUE, if short slot timing is enabled. */
-	    radio_hw_enable:1;          /* saved state of radio hardware enabled state */
+	/* The device initialization status.
+	 * Use bcm43xx_status() to query. */
+	atomic_t __init_status;
+	/* Saved init status for handling suspend. */
+	int suspend_init_status;
+
+	u8 __using_pio:1,		/* Internal, use bcm43xx_using_pio(). */
+	   bad_frames_preempt:1,	/* Use "Bad Frames Preemption" (default off) */
+	   reg124_set_0x4:1,		/* Some variable to keep track of IRQ stuff. */
+	   short_preamble:1,		/* TRUE, if short preamble is enabled. */
+	   short_slot:1,		/* TRUE, if short slot timing is enabled. */
+	   radio_hw_enable:1;          /* saved state of radio hardware enabled state */
 
 	/* PHY/Radio device. */
 	struct bcm43xx_phy phy;
diff --git a/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_debugfs.c b/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_debugfs.c
index e623cfd..8956199 100644
--- a/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_debugfs.c
+++ b/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_debugfs.c
@@ -92,7 +92,7 @@ static ssize_t tsf_read_file(struct file
 	mutex_lock(&big_buffer_mutex);
 	mutex_lock(&dev->wl->mutex);
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
 		fappend("Board not initialized.\n");
 		goto out;
 	}
@@ -128,7 +128,7 @@ static ssize_t tsf_write_file(struct fil
 	}
 	mutex_lock(&dev->wl->mutex);
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
 		printk(KERN_INFO PFX "debugfs: Board not initialized.\n");
 		res = -EFAULT;
 		goto out_unlock;
@@ -234,7 +234,7 @@ static ssize_t restart_write_file(struct
 	}
 	mutex_lock(&dev->wl->mutex);
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED) {
 		printk(KERN_INFO PFX "debugfs: Board not initialized.\n");
 		res = -EFAULT;
 		goto out_unlock;
@@ -267,8 +267,7 @@ static ssize_t txpower_g_read_file(struc
 	mutex_lock(&big_buffer_mutex);
 	mutex_lock(&dev->wl->mutex);
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if ((bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) ||
-	    !dev->started) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
 		fappend("Not initialized\n");
 		goto out;
 	}
@@ -322,8 +321,7 @@ static ssize_t txpower_g_write_file(stru
 	}
 	mutex_lock(&dev->wl->mutex);
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if ((bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) ||
-	    !dev->started) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
 		printk(KERN_INFO PFX "debugfs: Board not initialized.\n");
 		res = -ENODEV;
 		goto out_unlock;
diff --git a/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_lo.c b/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_lo.c
index aa1a298..f36ca80 100644
--- a/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_lo.c
+++ b/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_lo.c
@@ -1013,7 +1013,7 @@ #if BCM43xx_DEBUG
 static void do_validate_loctl(struct bcm43xx_wldev *dev,
 			      struct bcm43xx_loctl *control)
 {
-	const int is_initializing = (bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZING);
+	const int is_initializing = (bcm43xx_status(dev) == BCM43xx_STAT_UNINIT);
 
 	if (unlikely(abs(control->i) > 16 ||
 		     abs(control->q) > 16 ||
diff --git a/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c b/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
index e13c116..6f39cdf 100644
--- a/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
+++ b/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
@@ -1311,8 +1311,7 @@ static void bcm43xx_interrupt_tasklet(st
 
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
 
-	assert(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED);
-	assert(dev->started);
+	assert(bcm43xx_status(dev) == BCM43xx_STAT_STARTED);
 
 	reason = dev->irq_reason;
 	for (i = 0; i < ARRAY_SIZE(dma_reason); i++) {
@@ -1441,7 +1440,7 @@ static void bcm43xx_interrupt_ack(struct
 /* Interrupt handler top-half */
 static irqreturn_t bcm43xx_interrupt_handler(int irq, void *dev_id)
 {
-	irqreturn_t ret = IRQ_HANDLED;
+	irqreturn_t ret = IRQ_NONE;
 	struct bcm43xx_wldev *dev = dev_id;
 	u32 reason;
 
@@ -1450,18 +1449,17 @@ static irqreturn_t bcm43xx_interrupt_han
 
 	spin_lock(&dev->wl->irq_lock);
 
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED)
+		goto out;
 	reason = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
-	if (reason == 0xffffffff) {
-		/* irq not for us (shared irq) */
-		ret = IRQ_NONE;
+	if (reason == 0xffffffff) /* shared IRQ */
 		goto out;
-	}
+	ret = IRQ_HANDLED;
 	reason &= bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
 	if (!reason)
 		goto out;
 
-	assert(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED);
-	assert(dev->started);
+	assert(bcm43xx_status(dev) == BCM43xx_STAT_STARTED);
 
 	dev->dma_reason[0] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA0_REASON)
 			     & 0x0001DC00;
@@ -2258,9 +2256,7 @@ static void bcm43xx_periodic_work_handle
 
 	mutex_lock(&dev->wl->mutex);
 
-	if (unlikely(bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED))
-		goto out;
-	if (unlikely(!dev->started))
+	if (unlikely(bcm43xx_status(dev) != BCM43xx_STAT_STARTED))
 		goto out;
 	if (bcm43xx_debug(dev, BCM43xx_DBG_PWORK_STOP))
 		goto out_requeue;
@@ -2314,7 +2310,6 @@ static void bcm43xx_periodic_tasks_setup
 {
 	struct delayed_work *work = &dev->periodic_work;
 
-	assert(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED);
 	dev->periodic_state = 0;
 	INIT_DELAYED_WORK(work, bcm43xx_periodic_work_handler);
 	queue_delayed_work(dev->wl->hw->workqueue, work, 0);
@@ -2419,11 +2414,11 @@ static int bcm43xx_tx(struct ieee80211_h
 	int err = -ENODEV;
 	unsigned long flags;
 
-	/* DMA-TX is done without a global lock. */
 	if (unlikely(!dev))
 		goto out;
-	assert(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED);
-	assert(dev->started);
+	if (unlikely(bcm43xx_status(dev) < BCM43xx_STAT_STARTED))
+		goto out;
+	/* DMA-TX is done without a global lock. */
 	if (bcm43xx_using_pio(dev)) {
 		spin_lock_irqsave(&wl->irq_lock, flags);
 		err = bcm43xx_pio_tx(dev, skb, ctl);
@@ -2454,7 +2449,7 @@ static int bcm43xx_get_tx_stats(struct i
 	if (!dev)
 		goto out;
 	spin_lock_irqsave(&wl->irq_lock, flags);
-	if (likely(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED)) {
+	if (likely(bcm43xx_status(dev) >= BCM43xx_STAT_STARTED)) {
 		if (bcm43xx_using_pio(dev))
 			bcm43xx_pio_get_tx_stats(dev, stats);
 		else
@@ -2553,6 +2548,7 @@ static void bcm43xx_put_phy_into_reset(s
 	msleep(1);
 }
 
+/* Expects wl->mutex locked */
 static int bcm43xx_switch_phymode(struct bcm43xx_wl *wl,
 				  unsigned int new_mode)
 {
@@ -2560,8 +2556,7 @@ static int bcm43xx_switch_phymode(struct
 	struct bcm43xx_wldev *down_dev;
 	int err;
 	int gmode = -1;
-	int old_was_started = 0;
-	int old_was_inited = 0;
+	int prev_status;
 
 	err = find_wldev_for_phymode(wl, new_mode, &up_dev, &gmode);
 	if (err) {
@@ -2579,15 +2574,12 @@ static int bcm43xx_switch_phymode(struct
 		phymode_to_string(new_mode));
 	down_dev = wl->current_dev;
 
+	prev_status = bcm43xx_status(down_dev);
 	/* Shutdown the currently running core. */
-	if (down_dev->started) {
-		old_was_started = 1;
+	if (prev_status >= BCM43xx_STAT_STARTED)
 		bcm43xx_wireless_core_stop(down_dev);
-	}
-	if (bcm43xx_status(down_dev) == BCM43xx_STAT_INITIALIZED) {
-		old_was_inited = 1;
+	if (prev_status >= BCM43xx_STAT_INITIALIZED)
 		bcm43xx_wireless_core_exit(down_dev);
-	}
 
 	if (down_dev != up_dev) {
 		/* We switch to a different core, so we put PHY into
@@ -2597,30 +2589,34 @@ static int bcm43xx_switch_phymode(struct
 
 	/* Now start the new core. */
 	up_dev->phy.gmode = gmode;
-	if (old_was_inited) {
+	if (prev_status >= BCM43xx_STAT_INITIALIZED) {
 		err = bcm43xx_wireless_core_init(up_dev);
 		if (err) {
 			printk(KERN_INFO PFX "Fatal: Could not initialize device for "
-			       "new selected %s-PHY mode\n",
+			       "newly selected %s-PHY mode\n",
 			       phymode_to_string(new_mode));
-			return err;
+			goto init_failure;
 		}
 	}
-	if (old_was_started) {
-		assert(old_was_inited);
+	if (prev_status >= BCM43xx_STAT_STARTED) {
 		err = bcm43xx_wireless_core_start(up_dev);
 		if (err) {
 			printk(KERN_INFO PFX "Fatal: Coult not start device for "
-			       "new selected %s-PHY mode\n",
+			       "newly selected %s-PHY mode\n",
 			       phymode_to_string(new_mode));
 			bcm43xx_wireless_core_exit(up_dev);
-			return err;
+			goto init_failure;
 		}
 	}
+	assert(bcm43xx_status(up_dev) == prev_status);
 
 	wl->current_dev = up_dev;
 
 	return 0;
+init_failure:
+	/* Whoops, failed to init the new core. No core is operating now. */
+	wl->current_dev = NULL;
+	return err;
 }
 
 static int bcm43xx_antenna_from_ieee80211(u8 antenna)
@@ -2679,8 +2675,7 @@ static int bcm43xx_dev_config(struct iee
 	 * This makes it possible to drop the spinlock throughout
 	 * the reconfiguration process. */
 	spin_lock_irqsave(&wl->irq_lock, flags);
-	if ((bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) ||
-	    !dev->started) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
 		spin_unlock_irqrestore(&wl->irq_lock, flags);
 		goto out_unlock_mutex;
 	}
@@ -2916,9 +2911,9 @@ static void bcm43xx_wireless_core_stop(s
 	struct bcm43xx_wl *wl = dev->wl;
 	unsigned long flags;
 
-	if (!dev->started)
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED)
 		return;
-	dev->started = 0;
+	bcm43xx_set_status(dev, BCM43xx_STAT_INITIALIZED);
 
 	mutex_unlock(&wl->mutex);
 	/* Must unlock as it would otherwise deadlock. No races here. */
@@ -2943,10 +2938,9 @@ static void bcm43xx_wireless_core_stop(s
 /* Locking: wl->mutex */
 static int bcm43xx_wireless_core_start(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_wl *wl = dev->wl;
 	int err;
 
-	assert(!dev->started);
+	assert(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED);
 
 	drain_txstatus_queue(dev);
 	err = request_irq(dev->dev->irq, bcm43xx_interrupt_handler,
@@ -2956,12 +2950,13 @@ static int bcm43xx_wireless_core_start(s
 		       dev->dev->irq);
 		goto out;
 	}
-	dev->started = 1;
 	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
 	bcm43xx_mac_enable(dev);
 
-	ieee80211_start_queues(wl->hw);
 	bcm43xx_periodic_tasks_setup(dev);
+
+	ieee80211_start_queues(dev->wl->hw);
+	bcm43xx_set_status(dev, BCM43xx_STAT_STARTED);
 	dprintk(KERN_INFO PFX "Wireless interface started\n");
 out:
 	return err;
@@ -3189,6 +3184,7 @@ static void bcm43xx_wireless_core_exit(s
 {
 	struct bcm43xx_phy *phy = &dev->phy;
 
+	assert(bcm43xx_status(dev) <= BCM43xx_STAT_INITIALIZED);
 	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED)
 		return;
 
@@ -3218,7 +3214,6 @@ static int bcm43xx_wireless_core_init(st
 	u32 hf, tmp;
 
 	assert(bcm43xx_status(dev) == BCM43xx_STAT_UNINIT);
-	bcm43xx_set_status(dev, BCM43xx_STAT_INITIALIZING);
 
 	err = ssb_bus_powerup(bus, 0);
 	if (err)
@@ -3339,7 +3334,7 @@ err_kfree_lo_control:
 	phy->lo_control = NULL;
 err_busdown:
 	ssb_bus_may_powerdown(bus);
-	bcm43xx_set_status(dev, BCM43xx_STAT_UNINIT);
+	assert(bcm43xx_status(dev) == BCM43xx_STAT_UNINIT);
 	return err;
 }
 
@@ -3360,13 +3355,13 @@ static int bcm43xx_add_interface(struct 
 	dprintk(KERN_INFO PFX "Adding Interface type %d\n", conf->type);
 
 	dev = wl->current_dev;
-	if (bcm43xx_status(dev) == BCM43xx_STAT_UNINIT) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED) {
 		err = bcm43xx_wireless_core_init(dev);
 		if (err)
 			goto out_mutex_unlock;
 		did_init = 1;
 	}
-	if (!dev->started) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
 		err = bcm43xx_wireless_core_start(dev);
 		if (err) {
 			if (did_init)
@@ -3417,7 +3412,7 @@ static void bcm43xx_remove_interface(str
 	dev = wl->current_dev;
 	if (!wl->operating && wl->monitor == 0) {
 		/* No interface left. */
-		if (dev->started)
+		if (bcm43xx_status(dev) >= BCM43xx_STAT_STARTED)
 			bcm43xx_wireless_core_stop(dev);
 		bcm43xx_wireless_core_exit(dev);
 	} else {
@@ -3454,30 +3449,25 @@ static void bcm43xx_chip_reset(struct wo
 	struct bcm43xx_wldev *dev =
 		container_of(work, struct bcm43xx_wldev, restart_work);
 	struct bcm43xx_wl *wl = dev->wl;
-	int err;
-	int was_started = 0;
-	int was_inited = 0;
+	int err = 0;
+	int prev_status;
 
 	mutex_lock(&wl->mutex);
 
+	prev_status = bcm43xx_status(dev);
 	/* Bring the device down... */
-	if (dev->started) {
-		was_started = 1;
+	if (prev_status >= BCM43xx_STAT_STARTED)
 		bcm43xx_wireless_core_stop(dev);
-	}
-	if (bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED) {
-		was_inited = 1;
+	if (prev_status >= BCM43xx_STAT_INITIALIZED)
 		bcm43xx_wireless_core_exit(dev);
-	}
 
 	/* ...and up again. */
-	if (was_inited) {
+	if (prev_status >= BCM43xx_STAT_INITIALIZED) {
 		err = bcm43xx_wireless_core_init(dev);
 		if (err)
 			goto out;
 	}
-	if (was_started) {
-		assert(was_inited);
+	if (prev_status >= BCM43xx_STAT_STARTED) {
 		err = bcm43xx_wireless_core_start(dev);
 		if (err) {
 			bcm43xx_wireless_core_exit(dev);
@@ -3890,13 +3880,11 @@ static int bcm43xx_suspend(struct ssb_de
 	dprintk(KERN_INFO PFX "Suspending...\n");
 
 	mutex_lock(&wl->mutex);
-	wldev->was_started = !!wldev->started;
-	wldev->was_initialized = (bcm43xx_status(wldev) == BCM43xx_STAT_INITIALIZED);
-	if (wldev->started)
+	wldev->suspend_init_status = bcm43xx_status(wldev);
+	if (wldev->suspend_init_status >= BCM43xx_STAT_STARTED)
 		bcm43xx_wireless_core_stop(wldev);
-	if (bcm43xx_status(wldev) == BCM43xx_STAT_INITIALIZED)
+	if (wldev->suspend_init_status >= BCM43xx_STAT_INITIALIZED)
 		bcm43xx_wireless_core_exit(wldev);
-
 	mutex_unlock(&wl->mutex);
 
 	dprintk(KERN_INFO PFX "Device suspended.\n");
@@ -3907,25 +3895,28 @@ static int bcm43xx_suspend(struct ssb_de
 static int bcm43xx_resume(struct ssb_device *dev)
 {
 	struct bcm43xx_wldev *wldev = ssb_get_drvdata(dev);
+	struct bcm43xx_wl *wl = wldev->wl;
 	int err = 0;
 
 	dprintk(KERN_INFO PFX "Resuming...\n");
 
-	if (wldev->was_initialized) {
+	mutex_lock(&wl->mutex);
+	if (wldev->suspend_init_status >= BCM43xx_STAT_INITIALIZED) {
 		err = bcm43xx_wireless_core_init(wldev);
 		if (err) {
 			printk(KERN_ERR PFX "Resume failed at core init\n");
 			goto out;
 		}
 	}
-	if (wldev->was_started) {
-		assert(wldev->was_initialized);
+	if (wldev->suspend_init_status >= BCM43xx_STAT_STARTED) {
 		err = bcm43xx_wireless_core_start(wldev);
 		if (err) {
+			bcm43xx_wireless_core_exit(wldev);
 			printk(KERN_ERR PFX "Resume failed at core start\n");
 			goto out;
 		}
 	}
+	mutex_unlock(&wl->mutex);
 
 	dprintk(KERN_INFO PFX "Device resumed.\n");
 out:


-- 
Greetings Michael.


From rrl125 at gmail.com  Tue Aug  7 14:25:37 2007
From: rrl125 at gmail.com (Rob Lewis)
Date: Tue, 7 Aug 2007 08:25:37 -0400
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
Message-ID: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>

Hello,

I apologize if this has been covered already, but i have a few questions, as
i am lost as where to begin to get this driver to work.

I have a Dell 1390 Wireless card with bcm4311 chipset. I believe it is v4
firmware. I have been reading the lists and Larry mentioned that this driver
only works with v3.

How do i find out my firmware revision?
Will there be support for v4?
Can i flash the rom to v3 to get support for this driver, and in doing so,
will it affect the hardware functionality at all?
I did not see a bcm4311 driver in the kernel (.22 and .23rc1), do i need to
patch to get it?

Any response regarding answers to these questions would be appreciated. Any
information related to getting this card to work with the native driver
would also be greatly appreciated, as, i am lost as to where to start with
this.

Thank you!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070807/af069bed/attachment.html>

From proski at gnu.org  Tue Aug  7 16:19:45 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 07 Aug 2007 10:19:45 -0400
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
Message-ID: <1186496385.28595.8.camel@dv>

Hello!

On Tue, 2007-08-07 at 08:25 -0400, Rob Lewis wrote:

> I apologize if this has been covered already, but i have a few
> questions, as i am lost as where to begin to get this driver to work.
>  
> I have a Dell 1390 Wireless card with bcm4311 chipset. I believe it is
> v4 firmware. I have been reading the lists and Larry mentioned that
> this driver only works with v3.

As far as I know, the firmware is never stored in the device
permanently.  It is loaded by the driver into device RAM.  The firmware
has to be extracted by bcm43xx-fwcutter, which can process both v3 and
v4 firmware.
 
> How do i find out my firmware revision?

It will be reported by bcm43xx-fwcutter

> Will there be support for v4?

It is is a separate driver, bcm43xx_mac80211.  It's already supported.

> Can i flash the rom to v3 to get support for this driver, and in doing
> so, will it affect the hardware functionality at all?

As far as I know, you cannot flash ROM.

> I did not see a bcm4311 driver in the kernel (.22 and .23rc1), do i
> need to patch to get it?

If you mean bcm4301, yes, you need to patch the kernel.  But bcm43xx is
already in the driver, and it works with v3 firmware.
> 
-- 
Regards,
Pavel Roskin



From rrl125 at gmail.com  Tue Aug  7 16:41:17 2007
From: rrl125 at gmail.com (Rob Lewis)
Date: Tue, 7 Aug 2007 10:41:17 -0400
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <1186496385.28595.8.camel@dv>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
	<1186496385.28595.8.camel@dv>
Message-ID: <749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>

Pavel,

Thank you for your response.

As far as flashing ROM, apologies there, i meant something else!

As far as the steps i take to get the native driver to work,

1) Use fwcutter to find out firmware revision, if v4 patch kernel enable
4301, if v3 enable bcm4311 driver.
2) Use normally?

I will be looking for 'tutorials online' as to how to do this, though if you
can point me to something you can recommend, that would be great.

Again, thank you for the help,
  -Rob

On 8/7/07, Pavel Roskin <proski at gnu.org> wrote:
>
> Hello!
>
> On Tue, 2007-08-07 at 08:25 -0400, Rob Lewis wrote:
>
> > I apologize if this has been covered already, but i have a few
> > questions, as i am lost as where to begin to get this driver to work.
> >
> > I have a Dell 1390 Wireless card with bcm4311 chipset. I believe it is
> > v4 firmware. I have been reading the lists and Larry mentioned that
> > this driver only works with v3.
>
> As far as I know, the firmware is never stored in the device
> permanently.  It is loaded by the driver into device RAM.  The firmware
> has to be extracted by bcm43xx-fwcutter, which can process both v3 and
> v4 firmware.
>
> > How do i find out my firmware revision?
>
> It will be reported by bcm43xx-fwcutter
>
> > Will there be support for v4?
>
> It is is a separate driver, bcm43xx_mac80211.  It's already supported.
>
> > Can i flash the rom to v3 to get support for this driver, and in doing
> > so, will it affect the hardware functionality at all?
>
> As far as I know, you cannot flash ROM.
>
> > I did not see a bcm4311 driver in the kernel (.22 and .23rc1), do i
> > need to patch to get it?
>
> If you mean bcm4301, yes, you need to patch the kernel.  But bcm43xx is
> already in the driver, and it works with v3 firmware.
> >
> --
> Regards,
> Pavel Roskin
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070807/b163e4d0/attachment.html>

From larry.finger at lwfinger.net  Tue Aug  7 17:09:03 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 07 Aug 2007 10:09:03 -0500
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>	<1186496385.28595.8.camel@dv>
	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>
Message-ID: <46B88B0F.5040804@lwfinger.net>

Rob Lewis wrote:
> Pavel,
>  
> Thank you for your response.
>  
> As far as flashing ROM, apologies there, i meant something else!
>  
> As far as the steps i take to get the native driver to work,
>  
> 1) Use fwcutter to find out firmware revision, if v4 patch kernel enable 
> 4301, if v3 enable bcm4311 driver.
> 2) Use normally?
>  
> I will be looking for 'tutorials online' as to how to do this, though if 
> you can point me to something you can recommend, that would be great.
>  
> Again, thank you for the help,
>   -Rob

Unless you really want to go through the hassle of patching kernels, I would suggest using the 
bcm43xx driver in the mainstream kernel. To get V3 firmware, you should do the following:

1. Download the shell script from ftp://lwfinger.dynalias.org/patches/bcm43xx_get_firmware_V3.

2. Use the command 'which bcm43xx-fwcutter' to verify that you have this utility. If not, you need 
to use "emerge", "apt-get", or whatever means your distro employs.

3. Issue the command "sudo sh bcm43xx_get_firmware_V3". This script will download the file 
containing the firmware, unpack it and store it in /lib/firmware.

4. Configure your kernel for the ieee80211, ieee80211_softmac, and bcm43xx modules.

Larry



From rrl125 at gmail.com  Tue Aug  7 17:34:08 2007
From: rrl125 at gmail.com (Rob Lewis)
Date: Tue, 7 Aug 2007 11:34:08 -0400
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <46B88B0F.5040804@lwfinger.net>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
	<1186496385.28595.8.camel@dv>
	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>
	<46B88B0F.5040804@lwfinger.net>
Message-ID: <749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>

Larry,

Very helpful, i will give this a try after work and let you know how it
goes, though, im pretty sure you know it will work!

Hopefully this native driver will support Monitor mode, as the ndiswrapper
does not.

From mb at bu3sch.de  Tue Aug  7 17:33:11 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 7 Aug 2007 17:33:11 +0200
Subject: [PATCH] bcm43xx-mac80211: Make hwpctl optional (disabled by default)
Message-ID: <200708071733.11986.mb@bu3sch.de>

This patch makes hardware power control optional through
a module parameter, which is disabled by default.
Hardware power control is broken, so we will drive with software
based power control.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

--

John, please apply to wireless-dev.
With this patch we come into the region where we might consider
going into production with bcm43xx-mac80211.
The mac80211 rc algorithm is able to auto-scale up to 54M on
my 4306 and the 4318(!).
So the major TX problems seem mostly gone with this.

I am going to do more small patches that optimize software
power adjustment and so on later. But the major stuff should
be fixed.

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h	2007-08-06 23:58:17.000000000 +0200
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h	2007-08-07 00:06:42.000000000 +0200
@@ -537,6 +537,8 @@ struct bcm43xx_phy {
 #ifdef CONFIG_BCM43XX_MAC80211_DEBUG
 	bool manual_txpower_control; /* Manual TX-power control enabled? */
 #endif
+	/* Hardware Power Control enabled? */
+	bool hardware_power_control;
 
 	/* Current Interference Mitigation mode */
 	int interfmode;
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.c	2007-08-06 23:58:17.000000000 +0200
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.c	2007-08-07 00:06:42.000000000 +0200
@@ -589,7 +589,7 @@ static void lo_measure_setup(struct bcm4
 	struct bcm43xx_txpower_lo_control *lo = phy->lo_control;
 	u16 tmp;
 
-	if (has_hardware_pctl(phy)) {
+	if (bcm43xx_has_hardware_pctl(phy)) {
 		sav->phy_lo_mask = bcm43xx_phy_read(dev, BCM43xx_PHY_LO_MASK);
 		sav->phy_extg_01 = bcm43xx_phy_read(dev, BCM43xx_PHY_EXTG(0x01));
 		sav->phy_dacctl_hwpctl = bcm43xx_phy_read(dev, BCM43xx_PHY_DACCTL);
@@ -615,7 +615,7 @@ static void lo_measure_setup(struct bcm4
 		bcm43xx_phy_write(dev, BCM43xx_PHY_BASE(0x16), 0x410);
 		bcm43xx_phy_write(dev, BCM43xx_PHY_BASE(0x17), 0x820);
 	}
-	if (!lo->rebuild && has_hardware_pctl(phy))
+	if (!lo->rebuild && bcm43xx_has_hardware_pctl(phy))
 		lo_read_power_vector(dev);
 	if (phy->rev >= 2) {
 		sav->phy_analogover = bcm43xx_phy_read(dev, BCM43xx_PHY_ANALOGOVER);
@@ -730,7 +730,7 @@ static void lo_measure_restore(struct bc
 		tmp = (phy->pga_gain | 0xEFA0);
 		bcm43xx_phy_write(dev, BCM43xx_PHY_PGACTL, tmp);
 	}
-	if (has_hardware_pctl(phy)) {
+	if (bcm43xx_has_hardware_pctl(phy)) {
 		bcm43xx_gphy_dc_lt_init(dev);
 	} else {
 		if (lo->rebuild)
@@ -777,7 +777,7 @@ static void lo_measure_restore(struct bc
 		bcm43xx_phy_write(dev, BCM43xx_PHY_BASE(0x3E), sav->phy_base_3E);
 		bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0, sav->phy_crs0);
 	}
-	if (has_hardware_pctl(phy)) {
+	if (bcm43xx_has_hardware_pctl(phy)) {
 		tmp = (sav->phy_lo_mask & 0xBFFF);
 		bcm43xx_phy_write(dev, BCM43xx_PHY_LO_MASK, tmp);
 		bcm43xx_phy_write(dev, BCM43xx_PHY_EXTG(0x01), sav->phy_extg_01);
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c	2007-08-07 00:04:46.000000000 +0200
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c	2007-08-07 00:06:42.000000000 +0200
@@ -102,6 +102,10 @@ static int modparam_mon_keep_badplcp;
 module_param_named(mon_keep_badplcp, modparam_mon_keep_bad, int, 0444);
 MODULE_PARM_DESC(mon_keep_badplcp, "Keep frames with bad PLCP in monitor mode");
 
+static int modparam_hwpctl;
+module_param_named(hwpctl, modparam_hwpctl, int, 0444);
+MODULE_PARM_DESC(hwpctl, "Enable hardware-side power control (default off)");
+
 
 static const struct ssb_device_id bcm43xx_ssb_tbl[] = {
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, SSB_ANY_REV),
@@ -3170,6 +3174,8 @@ static void setup_struct_phy_for_init(st
 	spin_lock_init(&phy->lock);
 	phy->interfmode = BCM43xx_INTERFMODE_NONE;
 	phy->channel = 0xFF;
+
+	phy->hardware_power_control = !!modparam_hwpctl;
 }
 
 static void setup_struct_wldev_for_init(struct bcm43xx_wldev *dev)
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c	2007-08-06 23:58:17.000000000 +0200
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c	2007-08-07 00:06:42.000000000 +0200
@@ -189,6 +189,25 @@ static void generate_bbatt_list(struct b
 	list->max_val = 8;
 }
 
+bool bcm43xx_has_hardware_pctl(struct bcm43xx_phy *phy)
+{
+	if (!phy->hardware_power_control)
+		return 0;
+	switch (phy->type) {
+	case BCM43xx_PHYTYPE_A:
+		if (phy->rev >= 5)
+			return 1;
+		break;
+	case BCM43xx_PHYTYPE_G:
+		if (phy->rev >= 6)
+			return 1;
+		break;
+	default:
+		assert(0);
+	}
+	return 0;
+}
+
 static void bcm43xx_shm_clear_tssi(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_phy *phy = &dev->phy;
@@ -614,31 +633,38 @@ static void hardware_pctl_init_gphy(stru
 	bcm43xx_gphy_dc_lt_init(dev);
 }
 
-/* HardwarePowerControl for A and G PHY.
- * This does nothing, if the card does not have HW PCTL
- */
+/* HardwarePowerControl init for A and G PHY */
 static void bcm43xx_hardware_pctl_init(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_phy *phy = &dev->phy;
 
-	if (!has_hardware_pctl(phy))
-		return;
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		hardware_pctl_init_aphy(dev);
+	if (!bcm43xx_has_hardware_pctl(phy)) {
+		/* No hardware power control */
+		bcm43xx_hf_write(dev, bcm43xx_hf_read(dev) &
+				 ~BCM43xx_HF_HWPCTL);
 		return;
 	}
-	if (phy->type == BCM43xx_PHYTYPE_G) {
+	/* Init the hwpctl related hardware */
+	switch (phy->type) {
+	case BCM43xx_PHYTYPE_A:
+		hardware_pctl_init_aphy(dev);
+		break;
+	case BCM43xx_PHYTYPE_G:
 		hardware_pctl_init_gphy(dev);
-		return;
+		break;
+	default:
+		assert(0);
 	}
-	assert(0);
+	/* Enable hardware pctl in firmware. */
+	bcm43xx_hf_write(dev, bcm43xx_hf_read(dev) |
+			 BCM43xx_HF_HWPCTL);
 }
 
 static void bcm43xx_hardware_pctl_early_init(struct bcm43xx_wldev *dev)
 {
 	struct bcm43xx_phy *phy = &dev->phy;
 
-	if (!has_hardware_pctl(phy)) {
+	if (!bcm43xx_has_hardware_pctl(phy)) {
 		bcm43xx_phy_write(dev, 0x047A, 0xC111);
 		return;
 	}
Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h	2007-08-06 23:58:17.000000000 +0200
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h	2007-08-07 00:06:42.000000000 +0200
@@ -4,6 +4,7 @@
 #include <linux/types.h>
 
 struct bcm43xx_wldev;
+struct bcm43xx_phy;
 
 
 /*** PHY Registers ***/
@@ -218,9 +219,7 @@ void bcm43xx_phy_xmitpower(struct bcm43x
 void bcm43xx_gphy_dc_lt_init(struct bcm43xx_wldev *dev);
 
 /* Returns the boolean whether the board has HardwarePowerControl */
-#define has_hardware_pctl(phy) \
-	(((phy)->type == BCM43xx_PHYTYPE_A && (phy)->rev >= 5) ||	\
-	 ((phy)->type == BCM43xx_PHYTYPE_G && (phy)->rev >= 6))
+bool bcm43xx_has_hardware_pctl(struct bcm43xx_phy *phy);
 /* Returns the boolean whether "TX Magnification" is enabled. */
 #define has_tx_magnification(phy) \
 	(((phy)->rev >= 2) &&			\

-- 
Greetings Michael.


From proski at gnu.org  Tue Aug  7 17:40:21 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 07 Aug 2007 11:40:21 -0400
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
	<1186496385.28595.8.camel@dv>
	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>
Message-ID: <1186501221.29326.15.camel@dv>

On Tue, 2007-08-07 at 10:41 -0400, Rob Lewis wrote:

> 1) Use fwcutter to find out firmware revision, if v4 patch kernel
> enable 4301, if v3 enable bcm4311 driver.
> 2) Use normally?

You can use fwcutter to extract any firmware.  bcm43xx and bcm4301 use
v3 firmware.  bcm43xx_mac80211 uses v4 firmware.  There is no such thing
as bcm4311 driver.

When the interface is brought up, the driver will load the firmware.  If
the firmware version is wrong, there will be a message in the kernel
log, which can be seen with the "dmesg" command.
 
> I will be looking for 'tutorials online' as to how to do this, though
> if you can point me to something you can recommend, that would be
> great. 

I'm not aware of any tutorials.  bcm43xx-fwcutter can be found here:
http://developer.berlios.de/project/showfiles.php?group_id=4547
> 
-- 
Regards,
Pavel Roskin



From larry.finger at lwfinger.net  Tue Aug  7 17:47:40 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 07 Aug 2007 10:47:40 -0500
Subject: [PATCH] bcm43xx-mac80211: Make hwpctl optional (disabled by
	default)
In-Reply-To: <200708071733.11986.mb@bu3sch.de>
References: <200708071733.11986.mb@bu3sch.de>
Message-ID: <46B8941C.5020807@lwfinger.net>

Michael Buesch wrote:
> This patch makes hardware power control optional through
> a module parameter, which is disabled by default.
> Hardware power control is broken, so we will drive with software
> based power control.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

ACK: Larry Finger <Larry.Finger at lwfinger.net>
> 
> --
> 
> John, please apply to wireless-dev.
> With this patch we come into the region where we might consider
> going into production with bcm43xx-mac80211.
> The mac80211 rc algorithm is able to auto-scale up to 54M on
> my 4306 and the 4318(!).
> So the major TX problems seem mostly gone with this.
> 
> I am going to do more small patches that optimize software
> power adjustment and so on later. But the major stuff should
> be fixed.

I get auto-scaling to 54M on my 4311 as well. I agree that bcm43xx-mac80211 is now ready to start 
the process of getting it into mainstream in the 2.6.24 or -25 cycle. Any changes required by the 
reviewers will be mirrored in the bcm4301 code. It certainly looks as if we will be free of softmac 
very soon.

Larry


From proski at gnu.org  Tue Aug  7 17:57:47 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 07 Aug 2007 11:57:47 -0400
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
	<1186496385.28595.8.camel@dv>
	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>
	<46B88B0F.5040804@lwfinger.net>
	<749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>
Message-ID: <1186502267.29326.23.camel@dv>

On Tue, 2007-08-07 at 11:34 -0400, Rob Lewis wrote:

> Without broadcom releasing drivers or source, will we always have to
> use fwcutter?

All that's needed is to make it legal to copy the firmware, and most
distributions will be able to package it.  That's what Atmel and Intel
did.  They didn't release sources of the firmware.

The best thing Broadcom could do would be to release the detailed
specifications, but releasing the firmware under a free-to-copy license
would be helpful too, as it would allow using the existing Linux drivers
out-of-box.

-- 
Regards,
Pavel Roskin



From mb at bu3sch.de  Tue Aug  7 18:15:09 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 7 Aug 2007 18:15:09 +0200
Subject: [PATCH] bcm43xx-mac80211: Remove the stackdump in rfatt/bbatt
	assertion
Message-ID: <200708071815.09936.mb@bu3sch.de>

This removes the stackdump in the rfatt/bbatt assertion
to reduce verbosity, but it also increases the message log
level from "debug" to "error".

Signed-off-by: Michael Buesch <mb at bu3sch.de>


Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.c	2007-08-07 17:57:52.000000000 +0200
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.c	2007-08-07 18:11:04.000000000 +0200
@@ -62,28 +62,23 @@ static void bcm43xx_lo_write(struct bcm4
 	bcm43xx_phy_write(dev, reg, value);
 }
 
-static inline
-int assert_rfatt_and_bbatt(const struct bcm43xx_rfatt *rfatt,
-			   const struct bcm43xx_bbatt *bbatt,
-			   struct bcm43xx_wldev *dev)
+static int assert_rfatt_and_bbatt(const struct bcm43xx_rfatt *rfatt,
+				  const struct bcm43xx_bbatt *bbatt,
+				  struct bcm43xx_wldev *dev)
 {
 	int err = 0;
 
 	/* Check the attenuation values against the LO control array sizes. */
-#if BCM43xx_DEBUG
-	if (rfatt->att >= BCM43xx_NR_RF) {
-		bcmdbg(dev->wl, "rfatt(%u) >= size of LO array\n",
+	if (unlikely(rfatt->att >= BCM43xx_NR_RF)) {
+		bcmerr(dev->wl, "rfatt(%u) >= size of LO array\n",
 		       rfatt->att);
 		err = -EINVAL;
 	}
-	if (bbatt->att >= BCM43xx_NR_BB) {
-		bcmdbg(dev->wl, "bbatt(%u) >= size of LO array\n",
+	if (unlikely(bbatt->att >= BCM43xx_NR_BB)) {
+		bcmerr(dev->wl, "bbatt(%u) >= size of LO array\n",
 		       bbatt->att);
 		err = -EINVAL;
 	}
-	if (err)
-		dump_stack();
-#endif /* BCM43xx_DEBUG */
 
 	return err;
 }

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Tue Aug  7 20:01:22 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 07 Aug 2007 13:01:22 -0500
Subject: [PATCH] bcm43xx-mac80211: Remove the stackdump in rfatt/bbatt
	assertion
In-Reply-To: <200708071815.09936.mb@bu3sch.de>
References: <200708071815.09936.mb@bu3sch.de>
Message-ID: <46B8B372.3020709@lwfinger.net>

Michael Buesch wrote:
> This removes the stackdump in the rfatt/bbatt assertion
> to reduce verbosity, but it also increases the message log
> level from "debug" to "error".
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

ACK: Larry Finger <Larry.Finger at lwfinger.net>

Michael - thanks for this.

Larry



From rrl125 at gmail.com  Wed Aug  8 00:19:05 2007
From: rrl125 at gmail.com (Rob Lewis)
Date: Tue, 7 Aug 2007 18:19:05 -0400
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
	<1186496385.28595.8.camel@dv>
	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>
	<46B88B0F.5040804@lwfinger.net>
	<749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>
Message-ID: <749168790708071519y18a8557dqe383e27fbb5ab2fa@mail.gmail.com>

Hello again,

It seems the module loaded without a problem, though, iwlist eth1 scan
returns back:
eth1      Interface doesn't support scanning : No such device

The device exists, iwlist shows it. I did not get any problems or output
when modprobeing the bcm43xx driver.

Any help would be appreciated.

On 8/7/07, Rob Lewis <rrl125 at gmail.com> wrote:
>
> Larry,
>
> Very helpful, i will give this a try after work and let you know how it
> goes, though, im pretty sure you know it will work!
>
> Hopefully this native driver will support Monitor mode, as the ndiswrapper
> does not.
> From a development standpoint, im curious as to how this installation
> could be made easier in the future. Without broadcom releasing drivers or
> source, will we always have to use fwcutter?
>
> Again, thank you all your help, and i will reply if i have any problems
> with the installation steps you mentioned earlier.
>
> -Rob
>
>
> On 8/7/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> >
> > Rob Lewis wrote:
> > > Pavel,
> > >
> > > Thank you for your response.
> > >
> > > As far as flashing ROM, apologies there, i meant something else!
> > >
> > > As far as the steps i take to get the native driver to work,
> > >
> > > 1) Use fwcutter to find out firmware revision, if v4 patch kernel
> > enable
> > > 4301, if v3 enable bcm4311 driver.
> > > 2) Use normally?
> > >
> > > I will be looking for 'tutorials online' as to how to do this, though
> > if
> > > you can point me to something you can recommend, that would be great.
> > >
> > > Again, thank you for the help,
> > >   -Rob
> >
> > Unless you really want to go through the hassle of patching kernels, I
> > would suggest using the
> > bcm43xx driver in the mainstream kernel. To get V3 firmware, you should
> > do the following:
> >
> > 1. Download the shell script from
> > ftp://lwfinger.dynalias.org/patches/bcm43xx_get_firmware_V3.
> >
> > 2. Use the command 'which bcm43xx-fwcutter' to verify that you have this
> > utility. If not, you need
> > to use "emerge", "apt-get", or whatever means your distro employs.
> >
> > 3. Issue the command "sudo sh bcm43xx_get_firmware_V3". This script will
> > download the file
> > containing the firmware, unpack it and store it in /lib/firmware.
> >
> > 4. Configure your kernel for the ieee80211, ieee80211_softmac, and
> > bcm43xx modules.
> >
> > Larry
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070807/2d54d341/attachment.html>

From larry.finger at lwfinger.net  Wed Aug  8 00:29:52 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 07 Aug 2007 17:29:52 -0500
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <749168790708071519y18a8557dqe383e27fbb5ab2fa@mail.gmail.com>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>	<1186496385.28595.8.camel@dv>	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>	<46B88B0F.5040804@lwfinger.net>	<749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>
	<749168790708071519y18a8557dqe383e27fbb5ab2fa@mail.gmail.com>
Message-ID: <46B8F260.1000805@lwfinger.net>

Rob Lewis wrote:
> Hello again,
> 
> It seems the module loaded without a problem, though, iwlist eth1 scan 
> returns back:
> eth1      Interface doesn't support scanning : No such device
> 
> The device exists, iwlist shows it. I did not get any problems or output 
> when modprobeing the bcm43xx driver.

The first thing is that the driver does not turn the radio on until the interface is up. Check its 
status with ifconfig.

The other thing to check is the output of the command 'dmesg | grep bcm43xx'. We will go from there.

Larry



From rrl125 at gmail.com  Wed Aug  8 00:43:05 2007
From: rrl125 at gmail.com (Rob Lewis)
Date: Tue, 7 Aug 2007 18:43:05 -0400
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <46B8F260.1000805@lwfinger.net>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
	<1186496385.28595.8.camel@dv>
	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>
	<46B88B0F.5040804@lwfinger.net>
	<749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>
	<749168790708071519y18a8557dqe383e27fbb5ab2fa@mail.gmail.com>
	<46B8F260.1000805@lwfinger.net>
Message-ID: <749168790708071543t7194cc67hb445a2ec058d1459@mail.gmail.com>

(Apologies i did not send to the list)
Larry,

The device does not exist in ifconfig, as shown below:

% ifconfig
eth0      ....
lo        ....

% ifconfig

lo        no wireless extensions.

eth0      no wireless extensions.

sit0      no wireless extensions.

eth1      IEEE 802.11b/g  ESSID:off/any  Nickname:"Broadcom 4311"
          Mode:Managed  Access Point: Invalid
          RTS thr:off   Fragment thr:off
          Encryption key:off
          Link Quality=0/100  Signal level=0 dBm  Noise level=0 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0


and of course, dmesg after module load:
bcm43xx: Chip ID 0x4311, rev 0x1
bcm43xx: Number of cores: 4
bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
bcm43xx: PHY connected
bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
bcm43xx: Radio turned off
bcm43xx: Radio turned off
atkbd.c: Unknown key pressed (translated set 2, code 0x88 on
isa0060/serio0).
atkbd.c: Use 'setkeycodes e008 <keycode>' to make it known.
bcm43xx: PHY connected
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load
failed.
bcm43xx: core_up for active 802.11 core failed (-2)


Thanks,
 Rob

On 8/7/07, Larry Finger <larry.finger at lwfinger.net> wrote:
>
> Rob Lewis wrote:
> > Hello again,
> >
> > It seems the module loaded without a problem, though, iwlist eth1 scan
> > returns back:
> > eth1      Interface doesn't support scanning : No such device
> >
> > The device exists, iwlist shows it. I did not get any problems or output
> > when modprobeing the bcm43xx driver.
>
> The first thing is that the driver does not turn the radio on until the
> interface is up. Check its
> status with ifconfig.
>
> The other thing to check is the output of the command 'dmesg | grep
> bcm43xx'. We will go from there.
>
> Larry
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070807/6e566e53/attachment.html>

From proski at gnu.org  Wed Aug  8 01:02:09 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 07 Aug 2007 19:02:09 -0400
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <749168790708071543t7194cc67hb445a2ec058d1459@mail.gmail.com>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
	<1186496385.28595.8.camel@dv>
	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>
	<46B88B0F.5040804@lwfinger.net>
	<749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>
	<749168790708071519y18a8557dqe383e27fbb5ab2fa@mail.gmail.com>
	<46B8F260.1000805@lwfinger.net>
	<749168790708071543t7194cc67hb445a2ec058d1459@mail.gmail.com>
Message-ID: <1186527729.10825.5.camel@dv>

On Tue, 2007-08-07 at 18:43 -0400, Rob Lewis wrote:

> The device does not exist in ifconfig, as shown below:

If the device is down, it's only shown by "ifconfig -a"

> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or
> load failed.

I wrote about this already.  bcm43xx needs v3 firmware.

Make sure you have the firmware files produced by bcm43xx-fwcutter in
/lib/firmware.  In particular, bcm43xx_microcode5.fw should be there.

-- 
Regards,
Pavel Roskin



From rrl125 at gmail.com  Wed Aug  8 01:06:42 2007
From: rrl125 at gmail.com (Rob Lewis)
Date: Tue, 7 Aug 2007 19:06:42 -0400
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <749168790708071543t7194cc67hb445a2ec058d1459@mail.gmail.com>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
	<1186496385.28595.8.camel@dv>
	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>
	<46B88B0F.5040804@lwfinger.net>
	<749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>
	<749168790708071519y18a8557dqe383e27fbb5ab2fa@mail.gmail.com>
	<46B8F260.1000805@lwfinger.net>
	<749168790708071543t7194cc67hb445a2ec058d1459@mail.gmail.com>
Message-ID: <749168790708071606v3a95c13cja242e3788e378859@mail.gmail.com>

Larry,

Thanks for your help. The drivers you had provided on your site did not work
(file name was differnt, not sure if the fw's themselves where differnt).

I cut the firmware from the drivers located at
http://linuxwireless.org/en/users/Drivers/bcm43xx#devicefirmware, and, i can
now ifconfig eth up, and iwlist eth1 scan.

Thank you for your help!

On 8/7/07, Rob Lewis <rrl125 at gmail.com> wrote:
>
> (Apologies i did not send to the list)
> Larry,
>
> The device does not exist in ifconfig, as shown below:
>
> % ifconfig
> eth0      ....
> lo        ....
>
> % ifconfig
>
> lo        no wireless extensions.
>
> eth0      no wireless extensions.
>
> sit0      no wireless extensions.
>
> eth1      IEEE 802.11b/g  ESSID:off/any  Nickname:"Broadcom 4311"
>           Mode:Managed  Access Point: Invalid
>           RTS thr:off   Fragment thr:off
>           Encryption key:off
>           Link Quality=0/100  Signal level=0 dBm  Noise level=0 dBm
>           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
>
>
> and of course, dmesg after module load:
> bcm43xx: Chip ID 0x4311, rev 0x1
> bcm43xx: Number of cores: 4
> bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
> bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
> bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
> bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
> bcm43xx: PHY connected
> bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
> bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> bcm43xx: Radio turned off
> bcm43xx: Radio turned off
> atkbd.c: Unknown key pressed (translated set 2, code 0x88 on
> isa0060/serio0).
> atkbd.c: Use 'setkeycodes e008 <keycode>' to make it known.
> bcm43xx: PHY connected
> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load
> failed.
> bcm43xx: core_up for active 802.11 core failed (-2)
>
>
> Thanks,
>  Rob
>
> On 8/7/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> >
> > Rob Lewis wrote:
> > > Hello again,
> > >
> > > It seems the module loaded without a problem, though, iwlist eth1 scan
> > > returns back:
> > > eth1      Interface doesn't support scanning : No such device
> > >
> > > The device exists, iwlist shows it. I did not get any problems or
> > output
> > > when modprobeing the bcm43xx driver.
> >
> > The first thing is that the driver does not turn the radio on until the
> > interface is up. Check its
> > status with ifconfig.
> >
> > The other thing to check is the output of the command 'dmesg | grep
> > bcm43xx'. We will go from there.
> >
> > Larry
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070807/8892f7f0/attachment.html>

From larry.finger at lwfinger.net  Wed Aug  8 01:43:57 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 07 Aug 2007 18:43:57 -0500
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <749168790708071606v3a95c13cja242e3788e378859@mail.gmail.com>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>	
	<1186496385.28595.8.camel@dv>	
	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>	
	<46B88B0F.5040804@lwfinger.net>	
	<749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>	
	<749168790708071519y18a8557dqe383e27fbb5ab2fa@mail.gmail.com>	
	<46B8F260.1000805@lwfinger.net>	
	<749168790708071543t7194cc67hb445a2ec058d1459@mail.gmail.com>
	<749168790708071606v3a95c13cja242e3788e378859@mail.gmail.com>
Message-ID: <46B903BD.4080707@lwfinger.net>

Rob Lewis wrote:
> Larry,
> 
> Thanks for your help. The drivers you had provided on your site did not 
> work (file name was differnt, not sure if the fw's themselves where 
> differnt).

I do not, and cannot, provide drivers. The link I gave you was for a script that downloads the 
driver, cuts out the firmware, and writes it to the proper directory. If you had used it, all would 
have been good from the start.

Larry



From rrl125 at gmail.com  Wed Aug  8 01:52:53 2007
From: rrl125 at gmail.com (Rob Lewis)
Date: Tue, 7 Aug 2007 16:52:53 -0700
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <46B903BD.4080707@lwfinger.net>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
	<1186496385.28595.8.camel@dv>
	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>
	<46B88B0F.5040804@lwfinger.net>
	<749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>
	<749168790708071519y18a8557dqe383e27fbb5ab2fa@mail.gmail.com>
	<46B8F260.1000805@lwfinger.net>
	<749168790708071543t7194cc67hb445a2ec058d1459@mail.gmail.com>
	<749168790708071606v3a95c13cja242e3788e378859@mail.gmail.com>
	<46B903BD.4080707@lwfinger.net>
Message-ID: <749168790708071652i4a74fa6cuafdf1476261a5969@mail.gmail.com>

Larry,

> I do not, and cannot, provide drivers.
I understand this, i mean the link you had provided.

> The link I gave you was for a script that downloads the driver, cuts out
the firmware, and writes it to the proper directory.

Yes, i know.

> If you had used it, all would have been good from the start.

I had used it, and it did NOT work, and all would not have been good from
the start. It put the firmware in the /lib/firmware directory. Out of all
the fw files in the directory, none matched what the debug output of
modprobing bcm43xx wanted.

-Rob

Larry


On 8/7/07, Larry Finger <larry.finger at lwfinger.net> wrote:
>
> Rob Lewis wrote:
> > Larry,
> >
> > Thanks for your help. The drivers you had provided on your site did not
> > work (file name was differnt, not sure if the fw's themselves where
> > differnt).
>
> I do not, and cannot, provide drivers. The link I gave you was for a
> script that downloads the
> driver, cuts out the firmware, and writes it to the proper directory. If
> you had used it, all would
> have been good from the start.
>
> Larry
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070807/a88c8b6d/attachment.html>

From mistamaila at gmail.com  Wed Aug  8 02:14:47 2007
From: mistamaila at gmail.com (John H.)
Date: Tue, 7 Aug 2007 19:14:47 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<46B24FBA.3030205@lwfinger.net>
	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
	<1186137786.2931.48.camel@pmac.infradead.org>
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>
	<46B361CD.8070705@lwfinger.net>
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
Message-ID: <5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>

Did I misunderstand something?  I thought some script was available or
some easy way to use either bcm43xx or the new one.  brennan says he
has a script to just let you use the newer driver with higher mbps,
but I have never heard back from him.

On 8/3/07, John H. <mistamaila at gmail.com> wrote:
> yes, please post such a script so I can use it and not need
> ndiswrapper anymore:)
>
> On 8/3/07, Brennan Ashton <comphappy at gmail.com> wrote:
> > > The OP's meaning of this thread, which is that bcm43xx_mac80211 doesn't work well enough for him,
> > > has been lost. He wants bcm43xx (softmac)!
> > >
> > > One other option is to get the stand-alone version of bcm43xx from my FTP site
> > > (ftp://lwfinger.dynalias.org/patches/bcm43xx-softmac-sa.tar.bz2), and build that.
> >
> > which is what the directions that i posted do, with the new version of
> > bcm43xx_mac80211 it should work fine, that is what i have on F7 with
> > the same card, and i am getting speeds over 1mb/s.  This weekend, i
> > could write a script to automate the process if people are interested.
> >
> > --
> > Brennan Ashton
> > Bellingham, Washington
> >
> > "The box said, 'Requires Windows 98 or better'. So I installed Linux"
> >
>


From larry.finger at lwfinger.net  Wed Aug  8 02:18:27 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 07 Aug 2007 19:18:27 -0500
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <749168790708071652i4a74fa6cuafdf1476261a5969@mail.gmail.com>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>	
	<1186496385.28595.8.camel@dv>	
	<749168790708070741o2d6ceddes94620f842b2c398a@mail.gmail.com>	
	<46B88B0F.5040804@lwfinger.net>	
	<749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>	
	<749168790708071519y18a8557dqe383e27fbb5ab2fa@mail.gmail.com>	
	<46B8F260.1000805@lwfinger.net>	
	<749168790708071543t7194cc67hb445a2ec058d1459@mail.gmail.com>	
	<749168790708071606v3a95c13cja242e3788e378859@mail.gmail.com>	
	<46B903BD.4080707@lwfinger.net>
	<749168790708071652i4a74fa6cuafdf1476261a5969@mail.gmail.com>
Message-ID: <46B90BD3.6030303@lwfinger.net>

Rob Lewis wrote:
> Larry,
>  
>  > I do not, and cannot, provide drivers.
> I understand this, i mean the link you had provided.
>  
>  > The link I gave you was for a script that downloads the driver, cuts 
> out the firmware, and writes it to the proper directory.
>  
> Yes, i know.
>  
>  > If you had used it, all would have been good from the start.
>  
> I had used it, and it did NOT work, and all would not have been good 
> from the start. It put the firmware in the /lib/firmware directory. Out 
> of all the fw files in the directory, none matched what the debug output 
> of modprobing bcm43xx wanted.

What part didn't work? If there is a bug in my script, I want to fix it.

To help keep V3 and V4 firmware separate as you will eventually need V4, I suggest adding a postfix 
to the firmware, which is what my script is supposed to do. That way both V3 and V4 firmware can 
coexist with both bcm43xx and bcm43xx-mac80211 finding the proper set. Does /lib/firmware have a 
file named bcm43xx_microcode5.fw3.fw? Do you have files named /etc/modprobe.conf and 
/etc/modprobe.conf.local? If so, does /etc/modprobe.conf.local have a line that says 'options 
bcm43xx fwpostfix=.fw3'?

What distro are you using?

Larry



From rrl125 at gmail.com  Wed Aug  8 02:26:29 2007
From: rrl125 at gmail.com (Rob Lewis)
Date: Tue, 7 Aug 2007 20:26:29 -0400
Subject: Dell Inspirson 9400 with Dell 1390 wireless card
In-Reply-To: <46B90BD3.6030303@lwfinger.net>
References: <749168790708070525v417aa787gbb0d695334a088ef@mail.gmail.com>
	<46B88B0F.5040804@lwfinger.net>
	<749168790708070834i7ce751a6x288ca4fd954e5b26@mail.gmail.com>
	<749168790708071519y18a8557dqe383e27fbb5ab2fa@mail.gmail.com>
	<46B8F260.1000805@lwfinger.net>
	<749168790708071543t7194cc67hb445a2ec058d1459@mail.gmail.com>
	<749168790708071606v3a95c13cja242e3788e378859@mail.gmail.com>
	<46B903BD.4080707@lwfinger.net>
	<749168790708071652i4a74fa6cuafdf1476261a5969@mail.gmail.com>
	<46B90BD3.6030303@lwfinger.net>
Message-ID: <749168790708071726m463706e1v5fe77b1aa0312182@mail.gmail.com>

Larry,

Your script is not buggy, i just happened to miss the part about the
postfix.

-Rob

On 8/7/07, Larry Finger <larry.finger at lwfinger.net> wrote:
>
> Rob Lewis wrote:
> > Larry,
> >
> >  > I do not, and cannot, provide drivers.
> > I understand this, i mean the link you had provided.
> >
> >  > The link I gave you was for a script that downloads the driver, cuts
> > out the firmware, and writes it to the proper directory.
> >
> > Yes, i know.
> >
> >  > If you had used it, all would have been good from the start.
> >
> > I had used it, and it did NOT work, and all would not have been good
> > from the start. It put the firmware in the /lib/firmware directory. Out
> > of all the fw files in the directory, none matched what the debug output
> > of modprobing bcm43xx wanted.
>
> What part didn't work? If there is a bug in my script, I want to fix it.
>
> To help keep V3 and V4 firmware separate as you will eventually need V4, I
> suggest adding a postfix
> to the firmware, which is what my script is supposed to do. That way both
> V3 and V4 firmware can
> coexist with both bcm43xx and bcm43xx-mac80211 finding the proper set.
> Does /lib/firmware have a
> file named bcm43xx_microcode5.fw3.fw? Do you have files named
> /etc/modprobe.conf and
> /etc/modprobe.conf.local? If so, does /etc/modprobe.conf.local have a line
> that says 'options
> bcm43xx fwpostfix=.fw3'?
>
> What distro are you using?
>
> Larry
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070807/ca5a0fa4/attachment.html>

From larry.finger at lwfinger.net  Wed Aug  8 02:57:03 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 07 Aug 2007 19:57:03 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>	
	<46B24FBA.3030205@lwfinger.net>	
	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>	
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>	
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>	
	<1186137786.2931.48.camel@pmac.infradead.org>	
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>	
	<46B361CD.8070705@lwfinger.net>	
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>	
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
Message-ID: <46B914DF.4080101@lwfinger.net>

John H. wrote:
> Did I misunderstand something?  I thought some script was available or
> some easy way to use either bcm43xx or the new one.  brennan says he
> has a script to just let you use the newer driver with higher mbps,
> but I have never heard back from him.
> 

I have no idea what he is/was talking about. Until late yesterday, the best performance was with the 
unaltered bcm43xx, or the port of that driver to mac80211. Today, the changes now propagating 
through the system make bcm43xx-mac80211 into the preferred driver. You should ask Fedora how soon 
those will make it into their development kernels (called Rawhide?).

If you want to use this new code now, you will need to use git to get the contents of Linville's 
wireless-dev tree and get the patches from the mailing list, or I can post them on my FTP site. If 
you can wait a day or so, Linville should incorporate those patches. In either case, the new version 
auto-scales the rate to 54M for most cards. Even the BCM4318, which has been the most trouble, gets 
up to 19 Mbs receiving, and 12 transmitting. The BCM4311 gets 20 Mbs in both directions.

Larry


From mistamaila at gmail.com  Wed Aug  8 03:01:22 2007
From: mistamaila at gmail.com (John H.)
Date: Tue, 7 Aug 2007 20:01:22 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46B914DF.4080101@lwfinger.net>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
	<1186137786.2931.48.camel@pmac.infradead.org>
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>
	<46B361CD.8070705@lwfinger.net>
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net>
Message-ID: <5b9417770708071801i433f3e21qdfd947c595095773@mail.gmail.com>

I downloaded the source you linked and I get bitrate 24/mbs which I
assume should be fine for cable modem speed in the US?

bcm43xx is the driver being used.


/7/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > Did I misunderstand something?  I thought some script was available or
> > some easy way to use either bcm43xx or the new one.  brennan says he
> > has a script to just let you use the newer driver with higher mbps,
> > but I have never heard back from him.
> >
>
> I have no idea what he is/was talking about. Until late yesterday, the best performance was with the
> unaltered bcm43xx, or the port of that driver to mac80211. Today, the changes now propagating
> through the system make bcm43xx-mac80211 into the preferred driver. You should ask Fedora how soon
> those will make it into their development kernels (called Rawhide?).
>
> If you want to use this new code now, you will need to use git to get the contents of Linville's
> wireless-dev tree and get the patches from the mailing list, or I can post them on my FTP site. If
> you can wait a day or so, Linville should incorporate those patches. In either case, the new version
> auto-scales the rate to 54M for most cards. Even the BCM4318, which has been the most trouble, gets
> up to 19 Mbs receiving, and 12 transmitting. The BCM4311 gets 20 Mbs in both directions.
>
> Larry
>


From larry.finger at lwfinger.net  Wed Aug  8 03:15:41 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 07 Aug 2007 20:15:41 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708071801i433f3e21qdfd947c595095773@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>	
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>	
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>	
	<1186137786.2931.48.camel@pmac.infradead.org>	
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>	
	<46B361CD.8070705@lwfinger.net>	
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>	
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>	
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>	
	<46B914DF.4080101@lwfinger.net>
	<5b9417770708071801i433f3e21qdfd947c595095773@mail.gmail.com>
Message-ID: <46B9193D.9080402@lwfinger.net>

John H. wrote:
> I downloaded the source you linked and I get bitrate 24/mbs which I
> assume should be fine for cable modem speed in the US?
> 
> bcm43xx is the driver being used.

The rates I'm talking about are measured throughput between my notebooks and another computer on my 
LAN that has a wired connection to my router. With a Bit Rate of 24 Mbs set with iwconfig, you 
should get a transfer rate of about 12 Mbs. My cable runs at 8 Mbs download and 512 Kbs upload, and 
it is very easy for the wireless to go faster than the broadband connection.

Larry


From geekypenguin at gmail.com  Wed Aug  8 04:12:04 2007
From: geekypenguin at gmail.com (Jory A. Pratt)
Date: Tue, 07 Aug 2007 21:12:04 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46B914DF.4080101@lwfinger.net>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>		<46B24FBA.3030205@lwfinger.net>		<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>		<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>		<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>		<1186137786.2931.48.camel@pmac.infradead.org>		<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>		<46B361CD.8070705@lwfinger.net>		<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>		<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net>
Message-ID: <46B92674.4030809@gmail.com>

Larry Finger wrote:
> John H. wrote:
>   
>> Did I misunderstand something?  I thought some script was available or
>> some easy way to use either bcm43xx or the new one.  brennan says he
>> has a script to just let you use the newer driver with higher mbps,
>> but I have never heard back from him.
>>
>>     
>
> I have no idea what he is/was talking about. Until late yesterday, the best performance was with the 
> unaltered bcm43xx, or the port of that driver to mac80211. Today, the changes now propagating 
> through the system make bcm43xx-mac80211 into the preferred driver. You should ask Fedora how soon 
> those will make it into their development kernels (called Rawhide?).
>
> If you want to use this new code now, you will need to use git to get the contents of Linville's 
> wireless-dev tree and get the patches from the mailing list, or I can post them on my FTP site. If 
> you can wait a day or so, Linville should incorporate those patches. In either case, the new version 
> auto-scales the rate to 54M for most cards. Even the BCM4318, which has been the most trouble, gets 
> up to 19 Mbs receiving, and 12 transmitting. The BCM4311 gets 20 Mbs in both directions.
>
> Larry
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
>   
The initial 5 patches have been applied already by John. There are only 
two patches left to apply. These patches are in the following thread.

[PATCH] bcm43xx-mac80211: Make hwpctl optional (disabled by default)
[PATCH] bcm43xx-mac80211: Remove the stackdump in rfatt/bbatt    assertion

-Jory


From larry.finger at lwfinger.net  Wed Aug  8 04:43:57 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 07 Aug 2007 21:43:57 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46B92674.4030809@gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>		<46B24FBA.3030205@lwfinger.net>		<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>		<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>		<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>		<1186137786.2931.48.camel@pmac.infradead.org>		<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>		<46B361CD.8070705@lwfinger.net>		<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>		<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>	<46B914DF.4080101@lwfinger.net>
	<46B92674.4030809@gmail.com>
Message-ID: <46B92DED.3020505@lwfinger.net>

Jory A. Pratt wrote:
>>   
> The initial 5 patches have been applied already by John. There are only 
> two patches left to apply. These patches are in the following thread.
> 
> [PATCH] bcm43xx-mac80211: Make hwpctl optional (disabled by default)

This is the biggie!!!!

Larry



From rec3d at yahoo.com  Wed Aug  8 05:27:13 2007
From: rec3d at yahoo.com (Jhonie Walker)
Date: Tue, 7 Aug 2007 20:27:13 -0700 (PDT)
Subject: Usage of bcm43xx-sprom tool
Message-ID: <141949.54737.qm@web50609.mail.re2.yahoo.com>

Hello, I tried to use the tool with the drivers
working ok, but this is what I get in the console:
./sprommod.sh eth0
./sprommod.sh: line 31: bcm43xx-sprom: command not
found
Could not modify SPROM data (127)

I noticed that the file bcm43xx-sprom does not exist.
Instead it is a ssb-sprom binary file.
I installed the tool in Fedora 7 using the 'make
install' command. I was using the last version
available throug svn.

I think I need more information on how to use this
tool (i.e. a short tutorial).

Thanks!




       
____________________________________________________________________________________
Sick sense of humor? Visit Yahoo! TV's 
Comedy with an Edge to see what's on, when. 
http://tv.yahoo.com/collections/222


From proski at gnu.org  Wed Aug  8 07:17:10 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 08 Aug 2007 01:17:10 -0400
Subject: [PATCH] Fix handling of failure to create debugfs directory
Message-ID: <20070808051710.3902.43211.stgit@dv.roinet.com>

This can happen if CONFIG_BCM43XX_MAC80211_DEBUG is enabled, but
CONFIG_DEBUG_FS is not.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 .../wireless/bcm43xx-mac80211/bcm43xx_debugfs.c    |    8 ++++++--
 1 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
index 9ca4625..aded2b3 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
@@ -408,7 +408,7 @@ static struct file_operations restart_fops = {
 
 int bcm43xx_debug(struct bcm43xx_wldev *dev, enum bcm43xx_dyndbg feature)
 {
-	return !!(dev->dfsentry->dyn_debug[feature]);
+	return !!(dev->dfsentry && dev->dfsentry->dyn_debug[feature]);
 }
 
 static void bcm43xx_remove_dynamic_debug(struct bcm43xx_wldev *dev)
@@ -472,7 +472,9 @@ void bcm43xx_debugfs_add_device(struct bcm43xx_wldev *dev)
 	snprintf(devdir, sizeof(devdir), "%s", wiphy_name(dev->wl->hw->wiphy));
 	e->subdir = debugfs_create_dir(devdir, fs.root);
 	if (!e->subdir || IS_ERR(e->subdir)) {
-		e->subdir = NULL;
+		bcmerr(dev->wl, "debugfs: cannot create %s directory\n",
+		       devdir);
+		dev->dfsentry = NULL;
 		kfree(log->log);
 		kfree(e);
 		return;
@@ -525,6 +527,8 @@ void bcm43xx_debugfs_log_txstat(struct bcm43xx_wldev *dev,
 	struct bcm43xx_txstatus *cur;
 	int i;
 
+	if (!e)
+		return;
 	log = &e->txstatlog;
 	assert(irqs_disabled());
 	spin_lock(&log->lock);


From larry.finger at lwfinger.net  Wed Aug  8 07:52:21 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 00:52:21 -0500
Subject: [PATCH] Fix handling of failure to create debugfs directory
In-Reply-To: <20070808051710.3902.43211.stgit@dv.roinet.com>
References: <20070808051710.3902.43211.stgit@dv.roinet.com>
Message-ID: <46B95A15.1080202@lwfinger.net>

Pavel Roskin wrote:
> This can happen if CONFIG_BCM43XX_MAC80211_DEBUG is enabled, but
> CONFIG_DEBUG_FS is not.
> 
> Signed-off-by: Pavel Roskin <proski at gnu.org>
> ---
> 
With this patch installed, and the DEBUG configuration set as above, I get a kernel panic on an 
x86_64 SMP system. The reason for the panic scrolled off the screen, but the complete stack dump 
(hand copied) is as follows:

lock_acquire+0x85/0x31
bcm43xx_mac80211: bcm43xx_debugfs_log_txstat+0x5a/099
_spin_lock+0x25/0x31
bcm43xx_mac80211: bcm43xx_interrupt_tasklet+0x21/0x723
bcm43xx_mac80211: bcm43xx_debugfs_log_txstat+0x5a/0x99
bcm43xx_mac80211: bcm43xx_handle_txstatsus+0x12/0x72
bcm43xx_mac80211: bcm43xx_interrupt_tasklet+0x699/0x723
__lock_acquire+0xca2/0xcf0
bcm43xx_mac80211: bcm43xx_interrupt_handler+0x296/0x723
tasklet_action+0x5e/0xb2
__do_softirq+0x5f/0xe3
call_softirq+0x1c/0x28
do_softirq+0x39/0x9f
irq_exit+0x4e/0x50
do_IRQ+0xba/0xd8
default_idle+0x35/0x51
cpu_idle+0xce/0xf1
start_secondary+0x2e0/0x2f2

Larry




From larry.finger at lwfinger.net  Wed Aug  8 08:02:29 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 01:02:29 -0500
Subject: [PATCH] Fix handling of failure to create debugfs directory
In-Reply-To: <46B95A15.1080202@lwfinger.net>
References: <20070808051710.3902.43211.stgit@dv.roinet.com>
	<46B95A15.1080202@lwfinger.net>
Message-ID: <46B95C75.8060404@lwfinger.net>

Larry Finger wrote:
> Pavel Roskin wrote:
>> This can happen if CONFIG_BCM43XX_MAC80211_DEBUG is enabled, but
>> CONFIG_DEBUG_FS is not.
>>
>> Signed-off-by: Pavel Roskin <proski at gnu.org>
>> ---
>>
> With this patch installed, and the DEBUG configuration set as above, I get a kernel panic on an 
> x86_64 SMP system. The reason for the panic scrolled off the screen, but the complete stack dump 
> (hand copied) is as follows:
> 
> lock_acquire+0x85/0x31
> bcm43xx_mac80211: bcm43xx_debugfs_log_txstat+0x5a/099
> _spin_lock+0x25/0x31

Ignore the noise above. I had failed to get the right patch. The crash confirms the problem 
_without_ the patch. Getting it in properly fixes the problem

Acked-by: Larry Finger <Larry.Finger at lwfinger.net>

Larry



From comphappy at gmail.com  Wed Aug  8 08:53:06 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Tue, 7 Aug 2007 22:53:06 -0800
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
References: <5b9417770708011719v271731d7ibf2d313fa60d23a3@mail.gmail.com>
	<5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
	<1186137786.2931.48.camel@pmac.infradead.org>
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>
	<46B361CD.8070705@lwfinger.net>
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
Message-ID: <b2d05de20708072353l21d0aaeo5cb59c03e6316f36@mail.gmail.com>

Sorry work has been calling (very late nights from server migration),
I will try to get the script going soon, as i need to upgrade to the
new tree anyway.

On 8/7/07, John H. <mistamaila at gmail.com> wrote:
> Did I misunderstand something?  I thought some script was available or
> some easy way to use either bcm43xx or the new one.  brennan says he
> has a script to just let you use the newer driver with higher mbps,
> but I have never heard back from him.
>
> On 8/3/07, John H. <mistamaila at gmail.com> wrote:
> > yes, please post such a script so I can use it and not need
> > ndiswrapper anymore:)
> >
> > On 8/3/07, Brennan Ashton <comphappy at gmail.com> wrote:
> > > > The OP's meaning of this thread, which is that bcm43xx_mac80211 doesn't work well enough for him,
> > > > has been lost. He wants bcm43xx (softmac)!
> > > >
> > > > One other option is to get the stand-alone version of bcm43xx from my FTP site
> > > > (ftp://lwfinger.dynalias.org/patches/bcm43xx-softmac-sa.tar.bz2), and build that.
> > >
> > > which is what the directions that i posted do, with the new version of
> > > bcm43xx_mac80211 it should work fine, that is what i have on F7 with
> > > the same card, and i am getting speeds over 1mb/s.  This weekend, i
> > > could write a script to automate the process if people are interested.
> > >
> > > --
> > > Brennan Ashton
> > > Bellingham, Washington
> > >
> > > "The box said, 'Requires Windows 98 or better'. So I installed Linux"
> > >
> >
>


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From mb at bu3sch.de  Wed Aug  8 11:04:56 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 11:04:56 +0200
Subject: [PATCH] Fix handling of failure to create debugfs directory
In-Reply-To: <20070808051710.3902.43211.stgit@dv.roinet.com>
References: <20070808051710.3902.43211.stgit@dv.roinet.com>
Message-ID: <200708081104.56295.mb@bu3sch.de>

On Wednesday 08 August 2007 07:17:10 Pavel Roskin wrote:
> This can happen if CONFIG_BCM43XX_MAC80211_DEBUG is enabled, but
> CONFIG_DEBUG_FS is not.
> 
> Signed-off-by: Pavel Roskin <proski at gnu.org>
> ---

Thanks, queued.
Larry, this might also apply to bcm4301.

>  .../wireless/bcm43xx-mac80211/bcm43xx_debugfs.c    |    8 ++++++--
>  1 files changed, 6 insertions(+), 2 deletions(-)
> 
> diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
> index 9ca4625..aded2b3 100644
> --- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
> +++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
> @@ -408,7 +408,7 @@ static struct file_operations restart_fops = {
>  
>  int bcm43xx_debug(struct bcm43xx_wldev *dev, enum bcm43xx_dyndbg feature)
>  {
> -	return !!(dev->dfsentry->dyn_debug[feature]);
> +	return !!(dev->dfsentry && dev->dfsentry->dyn_debug[feature]);
>  }
>  
>  static void bcm43xx_remove_dynamic_debug(struct bcm43xx_wldev *dev)
> @@ -472,7 +472,9 @@ void bcm43xx_debugfs_add_device(struct bcm43xx_wldev *dev)
>  	snprintf(devdir, sizeof(devdir), "%s", wiphy_name(dev->wl->hw->wiphy));
>  	e->subdir = debugfs_create_dir(devdir, fs.root);
>  	if (!e->subdir || IS_ERR(e->subdir)) {
> -		e->subdir = NULL;
> +		bcmerr(dev->wl, "debugfs: cannot create %s directory\n",
> +		       devdir);
> +		dev->dfsentry = NULL;
>  		kfree(log->log);
>  		kfree(e);
>  		return;
> @@ -525,6 +527,8 @@ void bcm43xx_debugfs_log_txstat(struct bcm43xx_wldev *dev,
>  	struct bcm43xx_txstatus *cur;
>  	int i;
>  
> +	if (!e)
> +		return;
>  	log = &e->txstatlog;
>  	assert(irqs_disabled());
>  	spin_lock(&log->lock);

-- 
Greetings Michael.


From johannes at sipsolutions.net  Tue Aug  7 21:09:56 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 07 Aug 2007 21:09:56 +0200
Subject: Odd network locking
In-Reply-To: <b2d05de20708040056o67c71868v17312a408e61120d@mail.gmail.com>
References: <b2d05de20708032212j4f408935tac381077f50379a8@mail.gmail.com>
	<1186210277.20275.10.camel@johannes.berg>
	<b2d05de20708040056o67c71868v17312a408e61120d@mail.gmail.com>
Message-ID: <1186513796.4042.1.camel@johannes.berg>

On Sat, 2007-08-04 at 00:56 -0700, Brennan Ashton wrote:
> the trace overflows dmesg buffer, but here is what is left in the log:
> 
> [...]

Not very understandable unfortunately. Somewhere there must be a missing
dev_put but I can't pinpoint it.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070807/2bbd5e1e/attachment.pgp>

From mb at bu3sch.de  Wed Aug  8 12:38:02 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 12:38:02 +0200
Subject: [PATCH] Fix handling of failure to create debugfs directory
In-Reply-To: <46B95A15.1080202@lwfinger.net>
References: <20070808051710.3902.43211.stgit@dv.roinet.com>
	<46B95A15.1080202@lwfinger.net>
Message-ID: <200708081238.03216.mb@bu3sch.de>

On Wednesday 08 August 2007 07:52:21 Larry Finger wrote:
> Pavel Roskin wrote:
> > This can happen if CONFIG_BCM43XX_MAC80211_DEBUG is enabled, but
> > CONFIG_DEBUG_FS is not.
> > 
> > Signed-off-by: Pavel Roskin <proski at gnu.org>
> > ---
> > 
> With this patch installed, and the DEBUG configuration set as above, I get a kernel panic on an 
> x86_64 SMP system. The reason for the panic scrolled off the screen, but the complete stack dump 
> (hand copied) is as follows:
> 
> lock_acquire+0x85/0x31
> bcm43xx_mac80211: bcm43xx_debugfs_log_txstat+0x5a/099
> _spin_lock+0x25/0x31
> bcm43xx_mac80211: bcm43xx_interrupt_tasklet+0x21/0x723
> bcm43xx_mac80211: bcm43xx_debugfs_log_txstat+0x5a/0x99
> bcm43xx_mac80211: bcm43xx_handle_txstatsus+0x12/0x72
> bcm43xx_mac80211: bcm43xx_interrupt_tasklet+0x699/0x723
> __lock_acquire+0xca2/0xcf0
> bcm43xx_mac80211: bcm43xx_interrupt_handler+0x296/0x723
> tasklet_action+0x5e/0xb2
> __do_softirq+0x5f/0xe3
> call_softirq+0x1c/0x28
> do_softirq+0x39/0x9f
> irq_exit+0x4e/0x50
> do_IRQ+0xba/0xd8
> default_idle+0x35/0x51
> cpu_idle+0xce/0xf1
> start_secondary+0x2e0/0x2f2

Ah crap. I missed this. I'll do a patch.
But first some lunch :)

-- 
Greetings Michael.


From mb at bu3sch.de  Wed Aug  8 13:16:37 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 13:16:37 +0200
Subject: [PATCH] Fix handling of failure to create debugfs directory
In-Reply-To: <46B95C75.8060404@lwfinger.net>
References: <20070808051710.3902.43211.stgit@dv.roinet.com>
	<46B95A15.1080202@lwfinger.net> <46B95C75.8060404@lwfinger.net>
Message-ID: <200708081316.38183.mb@bu3sch.de>

On Wednesday 08 August 2007 08:02:29 Larry Finger wrote:
> Larry Finger wrote:
> > Pavel Roskin wrote:
> >> This can happen if CONFIG_BCM43XX_MAC80211_DEBUG is enabled, but
> >> CONFIG_DEBUG_FS is not.
> >>
> >> Signed-off-by: Pavel Roskin <proski at gnu.org>
> >> ---
> >>
> > With this patch installed, and the DEBUG configuration set as above, I get a kernel panic on an 
> > x86_64 SMP system. The reason for the panic scrolled off the screen, but the complete stack dump 
> > (hand copied) is as follows:
> > 
> > lock_acquire+0x85/0x31
> > bcm43xx_mac80211: bcm43xx_debugfs_log_txstat+0x5a/099
> > _spin_lock+0x25/0x31
> 
> Ignore the noise above. I had failed to get the right patch. The crash confirms the problem 
> _without_ the patch. Getting it in properly fixes the problem
> 
> Acked-by: Larry Finger <Larry.Finger at lwfinger.net>

Yeah, I just noticed that, too :)
So, I applied it to my queue and it will soon go upstream.
http://bu3sch.de/patches/wireless-dev/LATEST/patches/

-- 
Greetings Michael.


From mb at bu3sch.de  Wed Aug  8 13:21:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 13:21:48 +0200
Subject: Usage of bcm43xx-sprom tool
In-Reply-To: <141949.54737.qm@web50609.mail.re2.yahoo.com>
References: <141949.54737.qm@web50609.mail.re2.yahoo.com>
Message-ID: <200708081321.48890.mb@bu3sch.de>

On Wednesday 08 August 2007 05:27:13 Jhonie Walker wrote:
> Hello, I tried to use the tool with the drivers
> working ok, but this is what I get in the console:
> ./sprommod.sh eth0
> ./sprommod.sh: line 31: bcm43xx-sprom: command not
> found
> Could not modify SPROM data (127)
> 
> I noticed that the file bcm43xx-sprom does not exist.
> Instead it is a ssb-sprom binary file.

Ah, it was renamed.
That's a bug in that script.
I think I will simply remove that script, as it's just a
hack that only works on the old non-ssb based driver.

> I installed the tool in Fedora 7 using the 'make
> install' command. I was using the last version
> available throug svn.
> 
> I think I need more information on how to use this
> tool (i.e. a short tutorial).

In general you don't want to use it.
What are you trying to do?
Doing the wrong things with this tool can make it very
difficult to recover to a properly working device.

-- 
Greetings Michael.


From mb at bu3sch.de  Wed Aug  8 13:26:37 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 13:26:37 +0200
Subject: Odd network locking
In-Reply-To: <b2d05de20708032212j4f408935tac381077f50379a8@mail.gmail.com>
References: <b2d05de20708032212j4f408935tac381077f50379a8@mail.gmail.com>
Message-ID: <200708081326.37322.mb@bu3sch.de>

On Saturday 04 August 2007 07:12:46 Brennan Ashton wrote:
> When the bcm43xx_mac80211 driver stops communicating, and needs to be
> reset (this seems to happens when coming from strong to week to strong
> signal area quickly) i have been rmmod and then modprobing it. this

Can you test if you still have that "stop communication" problem, if you
pull latest wireless-dev and apply these patches on top of it?
http://bu3sch.de/patches/wireless-dev/LATEST/patches/

> works most of the time, but some times (~20%), it will lock up the
> network with this error that repeats.
> 
> Message from syslogd at localhost at Fri Aug  3 00:55:41 2007 ...
> localhost kernel: [19316.256549] unregister_netdevice: waiting for eth1 to becom
> e free. Usage count = 5

Most likely a bug in mac80211.
But it _could_ be related to the ieee80211_stop_queues() call we
do when stopping the wireless core. I think it's still not race free.
But I don't know if that can cause something like this.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Wed Aug  8 14:04:00 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 07:04:00 -0500
Subject: [PATCH] Fix handling of failure to create debugfs directory
In-Reply-To: <200708081104.56295.mb@bu3sch.de>
References: <20070808051710.3902.43211.stgit@dv.roinet.com>
	<200708081104.56295.mb@bu3sch.de>
Message-ID: <46B9B130.8090006@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 08 August 2007 07:17:10 Pavel Roskin wrote:
>> This can happen if CONFIG_BCM43XX_MAC80211_DEBUG is enabled, but
>> CONFIG_DEBUG_FS is not.
>>
>> Signed-off-by: Pavel Roskin <proski at gnu.org>
>> ---
> 
> Thanks, queued.
> Larry, this might also apply to bcm4301.

Yes it will. Thanks,

Larry



From linville at tuxdriver.com  Wed Aug  8 15:50:16 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 8 Aug 2007 09:50:16 -0400
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46B914DF.4080101@lwfinger.net>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708021649v1d1cba87sce553d8ac2cad233@mail.gmail.com>
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
	<1186137786.2931.48.camel@pmac.infradead.org>
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>
	<46B361CD.8070705@lwfinger.net>
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net>
Message-ID: <20070808135016.GB7335@tuxdriver.com>

On Tue, Aug 07, 2007 at 07:57:03PM -0500, Larry Finger wrote:
> John H. wrote:
> > Did I misunderstand something?  I thought some script was available or
> > some easy way to use either bcm43xx or the new one.  brennan says he
> > has a script to just let you use the newer driver with higher mbps,
> > but I have never heard back from him.
> > 
> 
> I have no idea what he is/was talking about. Until late yesterday, the best performance was with the 
> unaltered bcm43xx, or the port of that driver to mac80211. Today, the changes now propagating 
> through the system make bcm43xx-mac80211 into the preferred driver. You should ask Fedora how soon 
> those will make it into their development kernels (called Rawhide?).

Probably tonight.  Maybe earlier if you watch Koji.

John
-- 
John W. Linville
linville at tuxdriver.com


From proski at gnu.org  Wed Aug  8 16:48:57 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 08 Aug 2007 10:48:57 -0400
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but
	Ethernet appears broken
In-Reply-To: <8e6f94720708061245r5e58898by70099468af76532c@mail.gmail.com>
References: <46B38B0F.20808@Wetwork.Net> <200708041847.30250.mb@bu3sch.de>
	<1186271342.1948.10.camel@dv> <200708051218.20277.mb@bu3sch.de>
	<1186403076.10627.23.camel@dv>
	<8e6f94720708061245r5e58898by70099468af76532c@mail.gmail.com>
Message-ID: <1186584537.4824.10.camel@dv>

On Mon, 2007-08-06 at 15:45 -0400, Will Dyson wrote:

> The spec is telling us to lookup an invalid index in the LO table.

I see.  Thanks for your explanation!

I think the way to solve it would be to see how the table is used in the
proprietary driver.  Either the data from the extra entries is used, and
we need to find out where it comes from, or there is an algorithm to
limit the index to only access valid entries.

I hope the reverse engineering team knows that.  I wish them good luck.

-- 
Regards,
Pavel Roskin



From larry.finger at lwfinger.net  Wed Aug  8 17:12:45 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 10:12:45 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46B8B2F8.6090701@wetwork.net>
References: <46B38B0F.20808@Wetwork.Net> <200708071244.33871.mb@bu3sch.de>
	<46B892C8.4070002@lwfinger.net> <200708071803.16504.mb@bu3sch.de>
	<46B8B2F8.6090701@wetwork.net>
Message-ID: <46B9DD6D.1040200@lwfinger.net>

To the list: The beginnings of this thread were done off-list, but I want to let everyone know about
the problem, and to discover if anyone else has it. Since 2.6.23-rc1, Ehud has a problem in that the 
information his interface is transmitting is garbled. He did a bisection and discovered that the 
problem is involved with commit 85a83d26 "bcm43xx-mac80211: Rewrite and simplify handling of the 
initialization status.". Neither Michael nor I can reproduce the problem, nor is anything obviously 
wrong with the patch, other than this patch exposes an error in the location of the initial 
interrupt. I found this error on my old/slow notebook. Fixing that error did not resolve Ehud's 
problem. That fix is now in Linville's tree.

Ehud - please make your test tree current with a 'git checkout -f' command, and do a 'git pull' to
make certain you have the latest code. Then apply the trial patch below, which reverts a small part 
of Michael's patch, and see if it fixes the problem.

Larry


Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -1503,7 +1503,7 @@ static void bcm43xx_interrupt_ack(struct
  /* Interrupt handler top-half */
  static irqreturn_t bcm43xx_interrupt_handler(int irq, void *dev_id)
  {
-	irqreturn_t ret = IRQ_NONE;
+	irqreturn_t ret = IRQ_HANDLED;
  	struct bcm43xx_wldev *dev = dev_id;
  	u32 reason;

@@ -1512,12 +1512,11 @@ static irqreturn_t bcm43xx_interrupt_han

  	spin_lock(&dev->wl->irq_lock);

-	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED)
-		goto out;
  	reason = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
-	if (reason == 0xffffffff) /* shared IRQ */
+	if (reason == 0xffffffff) { /* shared IRQ */
+		ret = IRQ_NONE;
  		goto out;
-	ret = IRQ_HANDLED;
+	}
  	reason &= bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
  	if (!reason)
  		goto out;



From gavron at Wetwork.Net  Wed Aug  8 17:57:34 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Wed, 08 Aug 2007 08:57:34 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46B9DD6D.1040200@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <200708071244.33871.mb@bu3sch.de>
	<46B892C8.4070002@lwfinger.net> <200708071803.16504.mb@bu3sch.de>
	<46B8B2F8.6090701@wetwork.net> <46B9DD6D.1040200@lwfinger.net>
Message-ID: <46B9E7EE.5020902@Wetwork.Net>

I had hoped this would be the cure so I don't have to undo the 85a83d26 
commit patch by patch.

However, while this did not solve the problem it DID show a new error:
bcm43xx_mac80211: ASSERTION FAILED (bcm43xx_status(dev) == 
BCM43xx_STAT_STARTED) at: 
drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c:1377:bcm43xx_interrupt_tasklet()

Is that a clue to bigger things, or a problem with this patch? 
dmesg and tcpdump (of garbage) included along with a log of what I did 
with the git "test" tree to get there.

Ehud


Larry Finger wrote:
> To the list: The beginnings of this thread were done off-list, but I 
> want to let everyone know about
> the problem, and to discover if anyone else has it. Since 2.6.23-rc1, 
> Ehud has a problem in that the information his interface is 
> transmitting is garbled. He did a bisection and discovered that the 
> problem is involved with commit 85a83d26 "bcm43xx-mac80211: Rewrite 
> and simplify handling of the initialization status.". Neither Michael 
> nor I can reproduce the problem, nor is anything obviously wrong with 
> the patch, other than this patch exposes an error in the location of 
> the initial interrupt. I found this error on my old/slow notebook. 
> Fixing that error did not resolve Ehud's problem. That fix is now in 
> Linville's tree.
>
> Ehud - please make your test tree current with a 'git checkout -f' 
> command, and do a 'git pull' to
> make certain you have the latest code. Then apply the trial patch 
> below, which reverts a small part of Michael's patch, and see if it 
> fixes the problem.
>
> Larry
>
>
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> ===================================================================
> --- 
> wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -1503,7 +1503,7 @@ static void bcm43xx_interrupt_ack(struct
>  /* Interrupt handler top-half */
>  static irqreturn_t bcm43xx_interrupt_handler(int irq, void *dev_id)
>  {
> -    irqreturn_t ret = IRQ_NONE;
> +    irqreturn_t ret = IRQ_HANDLED;
>      struct bcm43xx_wldev *dev = dev_id;
>      u32 reason;
>
> @@ -1512,12 +1512,11 @@ static irqreturn_t bcm43xx_interrupt_han
>
>      spin_lock(&dev->wl->irq_lock);
>
> -    if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED)
> -        goto out;
>      reason = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
> -    if (reason == 0xffffffff) /* shared IRQ */
> +    if (reason == 0xffffffff) { /* shared IRQ */
> +        ret = IRQ_NONE;
>          goto out;
> -    ret = IRQ_HANDLED;
> +    }
>      reason &= bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
>      if (!reason)
>          goto out;
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: dmesg_grep_bcm_2007_08_07.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/308cf628/attachment.txt>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: tcpdump.2007_08_07
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/308cf628/attachment.ksh>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: larry-patch-2007-aug-08-log.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/308cf628/attachment-0001.txt>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/308cf628/attachment.bin>

From larry.finger at lwfinger.net  Wed Aug  8 18:11:03 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 11:11:03 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46B9E7EE.5020902@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <200708071244.33871.mb@bu3sch.de>
	<46B892C8.4070002@lwfinger.net> <200708071803.16504.mb@bu3sch.de>
	<46B8B2F8.6090701@wetwork.net> <46B9DD6D.1040200@lwfinger.net>
	<46B9E7EE.5020902@Wetwork.Net>
Message-ID: <46B9EB17.7020600@lwfinger.net>

Ehud Gavron wrote:
> I had hoped this would be the cure so I don't have to undo the 85a83d26 
> commit patch by patch.
> 
> However, while this did not solve the problem it DID show a new error:
> bcm43xx_mac80211: ASSERTION FAILED (bcm43xx_status(dev) == 
> BCM43xx_STAT_STARTED) at: 
> drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c:1377:bcm43xx_interrupt_tasklet() 
> 
> 
> Is that a clue to bigger things, or a problem with this patch? dmesg and 
> tcpdump (of garbage) included along with a log of what I did with the 
> git "test" tree to get there.
> 
> [root at egdell test]# git checkout -f
> [root at egdell test]# cat > patch-2007-aug-08-lfinger.txt
> --- wireless-dev.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -1503,7 +1503,7 @@ static void bcm43xx_interrupt_ack(struct
>  /* Interrupt handler top-half */
>  static irqreturn_t bcm43xx_interrupt_handler(int irq, void *dev_id)
>  {
> -    irqreturn_t ret = IRQ_NONE;
> +    irqreturn_t ret = IRQ_HANDLED;
>      struct bcm43xx_wldev *dev = dev_id;
>      u32 reason;
> 
> @@ -1512,12 +1512,11 @@ static irqreturn_t bcm43xx_interrupt_han
> 
>      spin_lock(&dev->wl->irq_lock);
> 
> -    if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED)
> -        goto out;
>      reason = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
> -    if (reason == 0xffffffff) /* shared IRQ */
> +    if (reason == 0xffffffff) { /* shared IRQ */
> +        ret = IRQ_NONE;
>          goto out;
> -    ret = IRQ_HANDLED;
> +    }
>      reason &= bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
>      if (!reason)
>          goto out; 
> [root at egdell test]# patch -p1 < patch-2007-aug-08-lfinger.txt 
> patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> Hunk #1 FAILED at 1503.
> Hunk #2 FAILED at 1512.
> 2 out of 2 hunks FAILED -- saving rejects to file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c.rej

The patch failed, but it shouldn't have. Have you done a 'git bisect reset' since we finished the 
bisecting? That would be a problem. Just in case, do the following:

git bisect reset
git checkout -f
git pull

Then apply the patch. If you get any REJECTS, please let me know. I'll hold off on analyzing those 
assertions until the code is in a known state.

Larry



From mb at bu3sch.de  Wed Aug  8 18:21:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 18:21:51 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46B9EB17.7020600@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <46B9E7EE.5020902@Wetwork.Net>
	<46B9EB17.7020600@lwfinger.net>
Message-ID: <200708081821.51405.mb@bu3sch.de>

On Wednesday 08 August 2007 18:11:03 Larry Finger wrote:
> > [root at egdell test]# patch -p1 < patch-2007-aug-08-lfinger.txt 
> > patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> > Hunk #1 FAILED at 1503.
> > Hunk #2 FAILED at 1512.
> > 2 out of 2 hunks FAILED -- saving rejects to file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c.rej
> 
> The patch failed, but it shouldn't have. Have you done a 'git bisect reset' since we finished the 
> bisecting? That would be a problem. Just in case, do the following:
> 
> git bisect reset
> git checkout -f
> git pull
> 
> Then apply the patch. If you get any REJECTS, please let me know. I'll hold off on analyzing those 
> assertions until the code is in a known state.

Yeah, your tree is still unclean.
After cleaning it you can verify if it's clean by inspecting
the output of
git status
and
git diff

status should _not_ talk about "modified" files
or something like that. diff should output nothing.
A clean tree looks like this:

mb at powermac:~/develop/git/wireless-dev$ git status
nothing to commit
mb at powermac:~/develop/git/wireless-dev$ git diff
mb at powermac:~/develop/git/wireless-dev$ 

-- 
Greetings Michael.


From gavron at Wetwork.Net  Wed Aug  8 18:24:14 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Wed, 08 Aug 2007 09:24:14 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <200708081821.51405.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net> <46B9E7EE.5020902@Wetwork.Net>
	<46B9EB17.7020600@lwfinger.net> <200708081821.51405.mb@bu3sch.de>
Message-ID: <46B9EE2E.9070608@Wetwork.Net>

[root at egdell test]# git status
# On branch master
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#       arch/x86_64/vdso/vdso.lds
nothing added to commit but untracked files present (use "git add" to track)
[root at egdell test]# git diff
[root at egdell test]#


Michael Buesch wrote:
> On Wednesday 08 August 2007 18:11:03 Larry Finger wrote:
>   
>>> [root at egdell test]# patch -p1 < patch-2007-aug-08-lfinger.txt 
>>> patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
>>> Hunk #1 FAILED at 1503.
>>> Hunk #2 FAILED at 1512.
>>> 2 out of 2 hunks FAILED -- saving rejects to file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c.rej
>>>       
>> The patch failed, but it shouldn't have. Have you done a 'git bisect reset' since we finished the 
>> bisecting? That would be a problem. Just in case, do the following:
>>
>> git bisect reset
>> git checkout -f
>> git pull
>>
>> Then apply the patch. If you get any REJECTS, please let me know. I'll hold off on analyzing those 
>> assertions until the code is in a known state.
>>     
>
> Yeah, your tree is still unclean.
> After cleaning it you can verify if it's clean by inspecting
> the output of
> git status
> and
> git diff
>
> status should _not_ talk about "modified" files
> or something like that. diff should output nothing.
> A clean tree looks like this:
>
> mb at powermac:~/develop/git/wireless-dev$ git status
> nothing to commit
> mb at powermac:~/develop/git/wireless-dev$ git diff
> mb at powermac:~/develop/git/wireless-dev$ 
>
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/e4caf850/attachment.bin>

From mb at bu3sch.de  Wed Aug  8 18:35:08 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 18:35:08 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46B9EE2E.9070608@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <200708081821.51405.mb@bu3sch.de>
	<46B9EE2E.9070608@Wetwork.Net>
Message-ID: <200708081835.09069.mb@bu3sch.de>

On Wednesday 08 August 2007 18:24:14 Ehud Gavron wrote:
> [root at egdell test]# git status
> # On branch master
> # Untracked files:
> #   (use "git add <file>..." to include in what will be committed)
> #
> #       arch/x86_64/vdso/vdso.lds
> nothing added to commit but untracked files present (use "git add" to track)
> [root at egdell test]# git diff
> [root at egdell test]#
> 


Larry, your patch is broken

mb at powermac:~/develop/git/wireless-dev$ patch -p1 <xxx.patch 
patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
Hunk #1 FAILED at 1503.
Hunk #2 FAILED at 1512.
2 out of 2 hunks FAILED -- saving rejects to file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c.rej

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Wed Aug  8 19:10:38 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 12:10:38 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <200708081835.09069.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net>
	<200708081821.51405.mb@bu3sch.de>	<46B9EE2E.9070608@Wetwork.Net>
	<200708081835.09069.mb@bu3sch.de>
Message-ID: <46B9F90E.5020606@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 08 August 2007 18:24:14 Ehud Gavron wrote:
>> [root at egdell test]# git status
>> # On branch master
>> # Untracked files:
>> #   (use "git add <file>..." to include in what will be committed)
>> #
>> #       arch/x86_64/vdso/vdso.lds
>> nothing added to commit but untracked files present (use "git add" to track)
>> [root at egdell test]# git diff
>> [root at egdell test]#
>>
> 
> 
> Larry, your patch is broken
> 
> mb at powermac:~/develop/git/wireless-dev$ patch -p1 <xxx.patch 
> patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> Hunk #1 FAILED at 1503.
> Hunk #2 FAILED at 1512.
> 2 out of 2 hunks FAILED -- saving rejects to file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c.rej
> 

The white space must have been garbled. When it didn't apply, Ehud contacted me privately and I sent 
him the patch file as an attachment. It has applied cleanly and is now compiling.

Larry


From gavron at Wetwork.Net  Wed Aug  8 19:46:33 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Wed, 08 Aug 2007 10:46:33 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46B9F90E.5020606@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <200708081821.51405.mb@bu3sch.de>
	<46B9EE2E.9070608@Wetwork.Net> <200708081835.09069.mb@bu3sch.de>
	<46B9F90E.5020606@lwfinger.net>
Message-ID: <46BA0179.1080700@Wetwork.Net>

The corrected patch shows the same results.  I have a 2.6.23-rc2 kernel 
where bcm43xx_mac80211 receives garbage.

Ehud

Larry Finger wrote:
> Michael Buesch wrote:
>> On Wednesday 08 August 2007 18:24:14 Ehud Gavron wrote:
>>> [root at egdell test]# git status
>>> # On branch master
>>> # Untracked files:
>>> #   (use "git add <file>..." to include in what will be committed)
>>> #
>>> #       arch/x86_64/vdso/vdso.lds
>>> nothing added to commit but untracked files present (use "git add" 
>>> to track)
>>> [root at egdell test]# git diff
>>> [root at egdell test]#
>>>
>>
>>
>> Larry, your patch is broken
>>
>> mb at powermac:~/develop/git/wireless-dev$ patch -p1 <xxx.patch patching 
>> file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
>> Hunk #1 FAILED at 1503.
>> Hunk #2 FAILED at 1512.
>> 2 out of 2 hunks FAILED -- saving rejects to file 
>> drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c.rej
>>
>
> The white space must have been garbled. When it didn't apply, Ehud 
> contacted me privately and I sent him the patch file as an attachment. 
> It has applied cleanly and is now compiling.
>
> Larry
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/2ab3e614/attachment.bin>

From larry.finger at lwfinger.net  Wed Aug  8 19:54:30 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 12:54:30 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46BA0179.1080700@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net>
	<200708081821.51405.mb@bu3sch.de>	<46B9EE2E.9070608@Wetwork.Net>
	<200708081835.09069.mb@bu3sch.de>	<46B9F90E.5020606@lwfinger.net>
	<46BA0179.1080700@Wetwork.Net>
Message-ID: <46BA0356.8040006@lwfinger.net>

Ehud Gavron wrote:
> The corrected patch shows the same results.  I have a 2.6.23-rc2 kernel 
> where bcm43xx_mac80211 receives garbage.

Mumble, mumble, swear words,.....

OK, back to the drawing board. Was this test with BCM43XX_DEBUG on or off?

Larry



From mb at bu3sch.de  Wed Aug  8 19:55:16 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 19:55:16 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BA0179.1080700@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <46B9F90E.5020606@lwfinger.net>
	<46BA0179.1080700@Wetwork.Net>
Message-ID: <200708081955.16533.mb@bu3sch.de>

On Wednesday 08 August 2007 19:46:33 Ehud Gavron wrote:
> The corrected patch shows the same results.  I have a 2.6.23-rc2 kernel 
> where bcm43xx_mac80211 receives garbage.

Please enable almost every option under "Kernel Hacking".
Especially those to detect memory corruption.
But also the lock debugging stuff.
When done, reproduce.

-- 
Greetings Michael.


From mb at bu3sch.de  Wed Aug  8 20:18:27 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 20:18:27 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	=?iso-8859-1?q?=09but_Ethernet_appears?= broken
In-Reply-To: <46BA0356.8040006@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <46BA0179.1080700@Wetwork.Net>
	<46BA0356.8040006@lwfinger.net>
Message-ID: <200708082018.27403.mb@bu3sch.de>

On Wednesday 08 August 2007 19:54:30 Larry Finger wrote:
> Ehud Gavron wrote:
> > The corrected patch shows the same results.  I have a 2.6.23-rc2 kernel 
> > where bcm43xx_mac80211 receives garbage.
> 
> Mumble, mumble, swear words,.....
> 
> OK, back to the drawing board. Was this test with BCM43XX_DEBUG on or off?

Ehud,

Can you try the following patch?
I have no idea how that could prevent data corruption,
but give it a try :)
It should apply with
Hunk #1 succeeded at 3014 (offset -72 lines).


http://bu3sch.de/patches/wireless-dev/20070808-1186596983/patches/bcm43xx-mac80211-start-queues-after-setting-status.patch


-- 
Greetings Michael.


From gavron at Wetwork.Net  Wed Aug  8 21:56:24 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Wed, 08 Aug 2007 12:56:24 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BA0356.8040006@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <200708081821.51405.mb@bu3sch.de>
	<46B9EE2E.9070608@Wetwork.Net> <200708081835.09069.mb@bu3sch.de>
	<46B9F90E.5020606@lwfinger.net> <46BA0179.1080700@Wetwork.Net>
	<46BA0356.8040006@lwfinger.net>
Message-ID: <46BA1FE8.3040200@Wetwork.Net>

Patch with debug on or off both fail.

I'm unable to apply Michael's patch to either a virgin test or virgin 
wireless-dev tree (I rm -rf'd both and re git clone'd them)

[root at egdell test]# patch -p1 < 
~gavron/bcm43xx-mac80211-fix-regression-in-interrupt-handling.patch
patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
Reversed (or previously applied) patch detected!  Assume -R? [n]
Apply anyway? [n] y
Hunk #1 FAILED at 3018.
1 out of 1 hunk FAILED -- saving rejects to file 
drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c.rej
[root at egdell test]# cd ../wireless-dev
[root at egdell wireless-dev]# patch -p1 < 
~gavron/bcm43xx-mac80211-fix-regression-in-interrupt-handling.patch
patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
Reversed (or previously applied) patch detected!  Assume -R? [n] n
Apply anyway? [n] y
Hunk #1 FAILED at 3018.
1 out of 1 hunk FAILED -- saving rejects to file 
drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c.rej

I can do this all day long.  It's much more fun than dissecting the 
original commit and doing it step by step.

Ehud

Larry Finger wrote:
> Ehud Gavron wrote:
>   
>> The corrected patch shows the same results.  I have a 2.6.23-rc2 kernel 
>> where bcm43xx_mac80211 receives garbage.
>>     
>
> Mumble, mumble, swear words,.....
>
> OK, back to the drawing board. Was this test with BCM43XX_DEBUG on or off?
>
> Larry
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/553aa2f8/attachment.bin>

From larry.finger at lwfinger.net  Wed Aug  8 22:06:26 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 15:06:26 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46BA1FE8.3040200@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <200708081821.51405.mb@bu3sch.de>
	<46B9EE2E.9070608@Wetwork.Net> <200708081835.09069.mb@bu3sch.de>
	<46B9F90E.5020606@lwfinger.net> <46BA0179.1080700@Wetwork.Net>
	<46BA0356.8040006@lwfinger.net> <46BA1FE8.3040200@Wetwork.Net>
Message-ID: <46BA2242.50409@lwfinger.net>

Ehud Gavron wrote:
> Patch with debug on or off both fail.
> 
> I'm unable to apply Michael's patch to either a virgin test or virgin 
> wireless-dev tree (I rm -rf'd both and re git clone'd them)

It works here. Again there must be a white-space problem with the patch. A working version is attached.

Larry

-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: ehud-test-2
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/06d21ada/attachment.ksh>

From mb at bu3sch.de  Wed Aug  8 22:07:22 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 22:07:22 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BA1FE8.3040200@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <46BA0356.8040006@lwfinger.net>
	<46BA1FE8.3040200@Wetwork.Net>
Message-ID: <200708082207.22198.mb@bu3sch.de>

On Wednesday 08 August 2007 21:56:24 Ehud Gavron wrote:
> Patch with debug on or off both fail.
> 
> I'm unable to apply Michael's patch to either a virgin test or virgin 
> wireless-dev tree (I rm -rf'd both and re git clone'd them)
> 
> [root at egdell test]# patch -p1 < 
> ~gavron/bcm43xx-mac80211-fix-regression-in-interrupt-handling.patch
> patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> Reversed (or previously applied) patch detected!  Assume -R? [n]

John just pushed the IRQ patch upstream.

Please try my patch that I just sent.
This one:
http://bu3sch.de/patches/wireless-dev/20070808-1186596983/patches/bcm43xx-mac80211-start-queues-after-setting-status.patch

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Wed Aug  8 22:09:34 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 15:09:34 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46BA1FE8.3040200@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <200708081821.51405.mb@bu3sch.de>
	<46B9EE2E.9070608@Wetwork.Net> <200708081835.09069.mb@bu3sch.de>
	<46B9F90E.5020606@lwfinger.net> <46BA0179.1080700@Wetwork.Net>
	<46BA0356.8040006@lwfinger.net> <46BA1FE8.3040200@Wetwork.Net>
Message-ID: <46BA22FE.4030304@lwfinger.net>

Ehud Gavron wrote:
> Patch with debug on or off both fail.
> 
> I'm unable to apply Michael's patch to either a virgin test or virgin 
> wireless-dev tree (I rm -rf'd both and re git clone'd them)
> 
> [root at egdell test]# patch -p1 < 
> ~gavron/bcm43xx-mac80211-fix-regression-in-interrupt-handling.patch
> patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> Reversed (or previously applied) patch detected!  Assume -R? [n]
> Apply anyway? [n] y
> Hunk #1 FAILED at 3018.
> 1 out of 1 hunk FAILED -- saving rejects to file 
> drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c.rej
> [root at egdell test]# cd ../wireless-dev
> [root at egdell wireless-dev]# patch -p1 < 
> ~gavron/bcm43xx-mac80211-fix-regression-in-interrupt-handling.patch
> patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c

No, you got the wrong patch. That one was previously applied, which is what the error message is 
saying. In any case, apply the one I just sent. BTW, it isn't necessart to repull the tree to get a 
clean version. That is what 'git checkout -f' does.

Larry



From gavron at Wetwork.Net  Wed Aug  8 22:16:29 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Wed, 08 Aug 2007 13:16:29 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BA22FE.4030304@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <200708081821.51405.mb@bu3sch.de>
	<46B9EE2E.9070608@Wetwork.Net> <200708081835.09069.mb@bu3sch.de>
	<46B9F90E.5020606@lwfinger.net> <46BA0179.1080700@Wetwork.Net>
	<46BA0356.8040006@lwfinger.net> <46BA1FE8.3040200@Wetwork.Net>
	<46BA22FE.4030304@lwfinger.net>
Message-ID: <46BA249D.2020200@Wetwork.Net>

Re git checkout -f... that's what I thought but when I kept getting the 
patch was previously applied... I figured I'd just clean it out.  Costs 
me 30 minutes of compile/link time, but it's nice'd out of the way.

The new patch (that was attached by you, and that Michael re-referenced) 
applied, and it is now building.  Should have results in 35m.

Thanks

Ehud

Larry Finger wrote:
> Ehud Gavron wrote:
>   
>> Patch with debug on or off both fail.
>>
>> I'm unable to apply Michael's patch to either a virgin test or virgin 
>> wireless-dev tree (I rm -rf'd both and re git clone'd them)
>>
>> [root at egdell test]# patch -p1 < 
>> ~gavron/bcm43xx-mac80211-fix-regression-in-interrupt-handling.patch
>> patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
>> Reversed (or previously applied) patch detected!  Assume -R? [n]
>> Apply anyway? [n] y
>> Hunk #1 FAILED at 3018.
>> 1 out of 1 hunk FAILED -- saving rejects to file 
>> drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c.rej
>> [root at egdell test]# cd ../wireless-dev
>> [root at egdell wireless-dev]# patch -p1 < 
>> ~gavron/bcm43xx-mac80211-fix-regression-in-interrupt-handling.patch
>> patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
>>     
>
> No, you got the wrong patch. That one was previously applied, which is what the error message is 
> saying. In any case, apply the one I just sent. BTW, it isn't necessart to repull the tree to get a 
> clean version. That is what 'git checkout -f' does.
>
> Larry
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/0fa86b83/attachment.bin>

From richie at coderworld.net  Wed Aug  8 22:19:19 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Wed, 8 Aug 2007 22:19:19 +0200
Subject: Port of bcm43xx from softmac to mac80211 is available for testing
In-Reply-To: <46B67787.1080903@lwfinger.net>
References: <46B50B3C.7000906@lwfinger.net>
	<200708052115.51758.richie@coderworld.net>
	<46B67787.1080903@lwfinger.net>
Message-ID: <200708082219.19600.richie@coderworld.net>

On Monday 06 August 2007 03:21:11 you wrote:
> Richard Jonsson wrote:
> > Isn't Desired TX power supposed to adapt so that higher bitrates are
> > possible, with Bit Rate going lower if that is not enough to keep a good
> > connection?
>
> Richard,
>
> Please grab a new copy of the port_to_mac80211 patch, and try the patch
> below. It boosts the desired power by up to 5 dBm as signal - noise
> decreases from 20 to 0.
>
> Larry

Hard to say if there is a difference. I've noticed that signal quality changes 
between reboots. When I first tried this patch I couldn't get above 36M even 
at the AP, so I loaded the version without the patch. Same thing.
So I rebooted and then all rates worked, even 11M. Even for the driver version 
that didn't work a few days ago.

New/updated observations:
Rate scaling seems to work, but if it gets down to 1M it will not rise again 
unless I force it to a higher bitrate and run iperf for a few seconds before 
setting it to auto. This is even when signal is -5dBm and noise is -80dBm. I 
get a feeling it's a bit to sensitive as it will drop quickly at a few meters 
away. At this distance forced 54M still works well.
Maybe this is due to small dips (0.5sec) in traffic flow?!

With the patch applied power is reported as 27dB in debugfs. With 
debug_xmitpower dmesg reports desired power to be 16.5 and actual 16.25. This 
is max when I manually set power through debugfs. After a while it's down to 
10dB, even though only 1M works where I sit.

Range seems to be higher for B-rates. Maybe this is just how things are, I 
lack experience.


From mb at bu3sch.de  Wed Aug  8 22:32:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 08 Aug 2007 22:32:51 +0200
Subject: [patch 0/9] New patch series for merge
Message-ID: <20070808203251.126698000@bu3sch.de>>

Hi John,

This patch series catches wireless-dev up to my
current wireless-development patchset.

Please merge this into wireless-dev.


--



From mb at bu3sch.de  Wed Aug  8 22:32:52 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 08 Aug 2007 22:32:52 +0200
Subject: [patch 1/9] bcm43xx-mac80211: Add comments to the attenuation value
	calculation
References: <20070808203251.126698000@bu3sch.de>>
Message-ID: <20070808203251.622261000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-pwr-delta-calc-comments.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/86196d01/attachment.ksh>

From mb at bu3sch.de  Wed Aug  8 22:32:53 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 08 Aug 2007 22:32:53 +0200
Subject: [patch 2/9] bcm43xx-mac80211: Fix handling of failure to create
	debugfs directory
References: <20070808203251.126698000@bu3sch.de>>
Message-ID: <20070808203252.062301000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-fix-handling-of-failure-to-create-debugfs-directory.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/60ba0ad6/attachment.ksh>

From mb at bu3sch.de  Wed Aug  8 22:32:59 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 08 Aug 2007 22:32:59 +0200
Subject: [patch 8/9] bcm43xx-mac80211: Reorder starting of wireless core.
References: <20070808203251.126698000@bu3sch.de>>
Message-ID: <20070808203254.835824000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-start-queues-after-setting-status.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/bb9cfb5b/attachment.ksh>

From mb at bu3sch.de  Wed Aug  8 22:32:55 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 08 Aug 2007 22:32:55 +0200
Subject: [patch 4/9] bcm43xx-mac80211: Remove assert() define and use WARN_ON()
References: <20070808203251.126698000@bu3sch.de>>
Message-ID: <20070808203252.997011000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-use-warn-on.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/cd31baab/attachment.ksh>

From mb at bu3sch.de  Wed Aug  8 22:32:57 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 08 Aug 2007 22:32:57 +0200
Subject: [patch 6/9] bcm43xx-mac80211: Remove unneeded stuff from bcm43xx.h
References: <20070808203251.126698000@bu3sch.de>>
Message-ID: <20070808203253.922178000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-cleanup.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/3ef7f75c/attachment.ksh>

From mb at bu3sch.de  Wed Aug  8 22:32:54 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 08 Aug 2007 22:32:54 +0200
Subject: [patch 3/9] bcm43xx-mac80211: Add more help text for firmware failure
References: <20070808203251.126698000@bu3sch.de>>
Message-ID: <20070808203252.531167000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-more-fw-help.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/e6f42c41/attachment.ksh>

From mb at bu3sch.de  Wed Aug  8 22:32:56 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 08 Aug 2007 22:32:56 +0200
Subject: [patch 5/9] ssb: Remove verbose coreswitch printk
References: <20070808203251.126698000@bu3sch.de>>
Message-ID: <20070808203253.420449000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: ssb-remove-verbose-coreswitch-debugging.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/3b1a893f/attachment.ksh>

From mb at bu3sch.de  Wed Aug  8 22:33:00 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 08 Aug 2007 22:33:00 +0200
Subject: [patch 9/9] bcm43xx-mac80211: Fix uninit-var warnings in lo.c
References: <20070808203251.126698000@bu3sch.de>>
Message-ID: <20070808203255.241828000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-fix-warning-in-lo-c.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/6e0245fe/attachment.ksh>

From mb at bu3sch.de  Wed Aug  8 22:32:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 08 Aug 2007 22:32:58 +0200
Subject: [patch 7/9] bcm43xx-mac80211: Remove power.c
References: <20070808203251.126698000@bu3sch.de>>
Message-ID: <20070808203254.346746000@bu3sch.de>>

An embedded and charset-unspecified text was scrubbed...
Name: bcm43xx-mac80211-get-rid-of-power-c.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/9776ac5f/attachment.ksh>

From larry.finger at lwfinger.net  Wed Aug  8 22:49:17 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 15:49:17 -0500
Subject: Port of bcm43xx from softmac to mac80211 is available for testing
In-Reply-To: <200708082219.19600.richie@coderworld.net>
References: <46B50B3C.7000906@lwfinger.net>	<200708052115.51758.richie@coderworld.net>	<46B67787.1080903@lwfinger.net>
	<200708082219.19600.richie@coderworld.net>
Message-ID: <46BA2C4D.4050605@lwfinger.net>

Richard Jonsson wrote:
> On Monday 06 August 2007 03:21:11 you wrote:
>> Richard Jonsson wrote:
>>> Isn't Desired TX power supposed to adapt so that higher bitrates are
>>> possible, with Bit Rate going lower if that is not enough to keep a good
>>> connection?
>> Richard,
>>
>> Please grab a new copy of the port_to_mac80211 patch, and try the patch
>> below. It boosts the desired power by up to 5 dBm as signal - noise
>> decreases from 20 to 0.
>>
>> Larry
> 
> Hard to say if there is a difference. I've noticed that signal quality changes 
> between reboots. When I first tried this patch I couldn't get above 36M even 
> at the AP, so I loaded the version without the patch. Same thing.
> So I rebooted and then all rates worked, even 11M. Even for the driver version 
> that didn't work a few days ago.

That is scary! That may mean that something is not being reset. The real question is whether warm 
reboots are intrinsically different than cold (power-off) reboots.

> New/updated observations:
> Rate scaling seems to work, but if it gets down to 1M it will not rise again 
> unless I force it to a higher bitrate and run iperf for a few seconds before 
> setting it to auto. This is even when signal is -5dBm and noise is -80dBm. I 
> get a feeling it's a bit to sensitive as it will drop quickly at a few meters 
> away. At this distance forced 54M still works well.
> Maybe this is due to small dips (0.5sec) in traffic flow?!

I'm surprised that you get signal values as high as -5 dBm. My maximum is about -35. I'm usually in 
the -40 range, even at 2 m from the AP.

> With the patch applied power is reported as 27dB in debugfs. With 
> debug_xmitpower dmesg reports desired power to be 16.5 and actual 16.25. This 
> is max when I manually set power through debugfs. After a while it's down to 
> 10dB, even though only 1M works where I sit.
> 
> Range seems to be higher for B-rates. Maybe this is just how things are, I 
> lack experience.

The CCCK (B) encoding is much different than OFDM (G) transmissions. I would not be surprised to 
learn that its range were longer.

The power setting that comes from mac80211 is 27 dBm, which is completely bogus for what is supposed 
to be the FCC table. The regulatory limit is 20 dBm EIRP (a fancy acronym that means take the 
antenna into account). I've sent a fix for comment, but as is the usual case for mac80211, it will 
take several days or weeks to get a response. The maximum power that a bcm43xx device can use is 
encoded in the sprom. For most of them that quantity is 18.5 dBm, corresponding to the regulatory 
limit of 20 minus a safety factor of 1.5. I think that is there to prevent setting the power too 
high and flunking the certification tests. The output that goes to the radio is thus 18.5 less the 
gain of the antenna, which is also in the sprom with a usual value of 2 dBm. That is why you see the 
code setting a Desired power of 16.5 dBm.

Initially, I thought that the performance of my BCM4311 fell off as the power increased; however, 
that no longer happens. As a result, we can push full power at all times and there seems to be no 
need to use the kind of algorithm that you were testing. Don't tell the FCC, but we could relax that 
upper power limit as we will never try to get the device certified, but then we would use extra 
power, and run the risk of burning out the radio. If you decide to do that, please tell me the power 
setting at which it fried!

With the patches that were pushed into wireless-dev a few minutes ago, I suggest that you try 
bcm43xx-mac80211. It is getting at least as good, if not better, performance than the BCM4301 or the 
softmac port to mac80211 drivers do. We would also appreciate as much testing as possible as it will 
help getting it merged into mainstream. That driver will require V4 firmware.

Thanks for your report,

Larry


From gavron at Wetwork.Net  Wed Aug  8 23:06:42 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Wed, 08 Aug 2007 14:06:42 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <200708082207.22198.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net> <46BA0356.8040006@lwfinger.net>
	<46BA1FE8.3040200@Wetwork.Net> <200708082207.22198.mb@bu3sch.de>
Message-ID: <46BA3062.9060807@Wetwork.Net>

It doesn't fix the problem, either with BCM43XX_MAC80211_DEBUG=y or n.

Ehud

Michael Buesch wrote:
> On Wednesday 08 August 2007 21:56:24 Ehud Gavron wrote:
>   
>> Patch with debug on or off both fail.
>>
>> I'm unable to apply Michael's patch to either a virgin test or virgin 
>> wireless-dev tree (I rm -rf'd both and re git clone'd them)
>>
>> [root at egdell test]# patch -p1 < 
>> ~gavron/bcm43xx-mac80211-fix-regression-in-interrupt-handling.patch
>> patching file drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
>> Reversed (or previously applied) patch detected!  Assume -R? [n]
>>     
>
> John just pushed the IRQ patch upstream.
>
> Please try my patch that I just sent.
> This one:
> http://bu3sch.de/patches/wireless-dev/20070808-1186596983/patches/bcm43xx-mac80211-start-queues-after-setting-status.patch
>
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/b17e11c7/attachment.bin>

From mb at bu3sch.de  Wed Aug  8 23:26:09 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 23:26:09 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BA3062.9060807@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <200708082207.22198.mb@bu3sch.de>
	<46BA3062.9060807@Wetwork.Net>
Message-ID: <200708082326.10162.mb@bu3sch.de>

On Wednesday 08 August 2007 23:06:42 Ehud Gavron wrote:
> It doesn't fix the problem, either with BCM43XX_MAC80211_DEBUG=y or n.

What about enabling the Kernel Hacking options I suggested?

-- 
Greetings Michael.


From mb at bu3sch.de  Wed Aug  8 23:36:42 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 23:36:42 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <200708082326.10162.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net> <46BA3062.9060807@Wetwork.Net>
	<200708082326.10162.mb@bu3sch.de>
Message-ID: <200708082336.42673.mb@bu3sch.de>

On Wednesday 08 August 2007 23:26:09 Michael Buesch wrote:
> On Wednesday 08 August 2007 23:06:42 Ehud Gavron wrote:
> > It doesn't fix the problem, either with BCM43XX_MAC80211_DEBUG=y or n.
> 
> What about enabling the Kernel Hacking options I suggested?

On IRC was suggested that this might be a compiler bug
generating corrupt code.
Which compiler do you use? Can you upgrade or downgrade?

-- 
Greetings Michael.


From mb at bu3sch.de  Wed Aug  8 23:37:03 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 8 Aug 2007 23:37:03 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <200708082326.10162.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net> <46BA3062.9060807@Wetwork.Net>
	<200708082326.10162.mb@bu3sch.de>
Message-ID: <200708082337.03625.mb@bu3sch.de>

On Wednesday 08 August 2007 23:26:09 Michael Buesch wrote:
> On Wednesday 08 August 2007 23:06:42 Ehud Gavron wrote:
> > It doesn't fix the problem, either with BCM43XX_MAC80211_DEBUG=y or n.
> 
> What about enabling the Kernel Hacking options I suggested?

On IRC was suggested that this might be a compiler bug
generating corrupt code.
Which compiler do you use? Can you upgrade or downgrade?

-- 
Greetings Michael.


From mistamaila at gmail.com  Thu Aug  9 00:00:39 2007
From: mistamaila at gmail.com (John H.)
Date: Wed, 8 Aug 2007 17:00:39 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <20070808135016.GB7335@tuxdriver.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>
	<1186137786.2931.48.camel@pmac.infradead.org>
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>
	<46B361CD.8070705@lwfinger.net>
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net> <20070808135016.GB7335@tuxdriver.com>
Message-ID: <5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>

I am using larry's .bz2 of bcm43xx and I get this ...

wlan0     IEEE 802.11b/g  ESSID:"Network4Home"  Nickname:"Broadcom 4311"
          Mode:Managed  Frequency=2.437 GHz  Access Point:blah
          Bit Rate=24 Mb/s   Tx-Power=18 dBm
          RTS thr:off   Fragment thr:off
          Link Quality=50/100  Signal level=-69 dBm  Noise level=-71 dBm
          Rx invalid nwid:0  Rx invalid crypt:11  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0


Is it possible to get 54mb/s?  Should I care if it's mainly for
residential cable modem right now?

On 8/8/07, John W. Linville <linville at tuxdriver.com> wrote:
> On Tue, Aug 07, 2007 at 07:57:03PM -0500, Larry Finger wrote:
> > John H. wrote:
> > > Did I misunderstand something?  I thought some script was available or
> > > some easy way to use either bcm43xx or the new one.  brennan says he
> > > has a script to just let you use the newer driver with higher mbps,
> > > but I have never heard back from him.
> > >
> >
> > I have no idea what he is/was talking about. Until late yesterday, the best performance was with the
> > unaltered bcm43xx, or the port of that driver to mac80211. Today, the changes now propagating
> > through the system make bcm43xx-mac80211 into the preferred driver. You should ask Fedora how soon
> > those will make it into their development kernels (called Rawhide?).
>
> Probably tonight.  Maybe earlier if you watch Koji.
>
> John
> --
> John W. Linville
> linville at tuxdriver.com
>


From gavron at Wetwork.Net  Thu Aug  9 02:06:35 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Wed, 08 Aug 2007 17:06:35 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <200708082326.10162.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net> <200708082207.22198.mb@bu3sch.de>
	<46BA3062.9060807@Wetwork.Net> <200708082326.10162.mb@bu3sch.de>
Message-ID: <46BA5A8B.1080006@Wetwork.Net>

They were *ALL* enabled, even the modules for testing that I didn't load.
They're still there in the built kernel... so if you want something from 
it, I can easily reboot into it and get it.

 From another message:
> n IRC was suggested that this might be a compiler bug
> generating corrupt code.
> Which compiler do you use? Can you upgrade or downgrade?
[root at egdell Download]# cc --version
cc (GCC) 4.1.2 20070502 (Red Hat 4.1.2-12)
Copyright (C) 2006 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

I use Yum with F7 Repos, but yes, if need be I can erase the RPM and 
install another.

Ehud

Michael Buesch wrote:
> On Wednesday 08 August 2007 23:06:42 Ehud Gavron wrote:
>   
>> It doesn't fix the problem, either with BCM43XX_MAC80211_DEBUG=y or n.
>>     
>
> What about enabling the Kernel Hacking options I suggested?
>
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/fa3ad4be/attachment.bin>

From josejx at gentoo.org  Thu Aug  9 04:08:34 2007
From: josejx at gentoo.org (Joseph Jezak)
Date: Wed, 08 Aug 2007 22:08:34 -0400
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but	Ethernet
	appears broken
In-Reply-To: <1186584537.4824.10.camel@dv>
References: <46B38B0F.20808@Wetwork.Net>
	<200708041847.30250.mb@bu3sch.de>	<1186271342.1948.10.camel@dv>
	<200708051218.20277.mb@bu3sch.de>	<1186403076.10627.23.camel@dv>	<8e6f94720708061245r5e58898by70099468af76532c@mail.gmail.com>
	<1186584537.4824.10.camel@dv>
Message-ID: <46BA7722.7070701@gentoo.org>

Pavel Roskin wrote:
> On Mon, 2007-08-06 at 15:45 -0400, Will Dyson wrote:
> 
>> The spec is telling us to lookup an invalid index in the LO table.
> 
> I see.  Thanks for your explanation!
> 
> I think the way to solve it would be to see how the table is used in the
> proprietary driver.  Either the data from the extra entries is used, and
> we need to find out where it comes from, or there is an algorithm to
> limit the index to only access valid entries.
> 
> I hope the reverse engineering team knows that.  I wish them good luck.
> 

Oh, we're aware of the problem.  It's like I said before, it's one 
of the most complex parts of the driver and it's tough to document 
properly without just copying code to the documentation.  We'll get 
to it, but my time is kind of limited right now.

Sorry,
-Joe


From larry.finger at lwfinger.net  Thu Aug  9 04:09:17 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 21:09:17 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>	
	<5b9417770708030019u33f04ebfp81d9646b71544186@mail.gmail.com>	
	<1186137786.2931.48.camel@pmac.infradead.org>	
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>	
	<46B361CD.8070705@lwfinger.net>	
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>	
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>	
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>	
	<46B914DF.4080101@lwfinger.net>
	<20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
Message-ID: <46BA774D.4080506@lwfinger.net>

John H. wrote:
> I am using larry's .bz2 of bcm43xx and I get this ...
> 
> wlan0     IEEE 802.11b/g  ESSID:"Network4Home"  Nickname:"Broadcom 4311"
>           Mode:Managed  Frequency=2.437 GHz  Access Point:blah
>           Bit Rate=24 Mb/s   Tx-Power=18 dBm
>           RTS thr:off   Fragment thr:off
>           Link Quality=50/100  Signal level=-69 dBm  Noise level=-71 dBm
>           Rx invalid nwid:0  Rx invalid crypt:11  Rx invalid frag:0
>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> 
> 
> Is it possible to get 54mb/s?  Should I care if it's mainly for
> residential cable modem right now?

To get a setting of 54M, look at 'man iwconfig'. To get throughput at 54M, you need a different 
driver, and much better signal to noise! The highest residential cable rates in my area are 8Mbs 
down and 512Kbs up. Business rates ate 10 Mbs down and 2 Mbs up, but that costs a lot more. Your 24M 
setting should give you something in the range of 12Mbs throughput. You do the math.

Larry



From larry.finger at lwfinger.net  Thu Aug  9 04:30:58 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 21:30:58 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46BA5A8B.1080006@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <200708082207.22198.mb@bu3sch.de>
	<46BA3062.9060807@Wetwork.Net> <200708082326.10162.mb@bu3sch.de>
	<46BA5A8B.1080006@Wetwork.Net>
Message-ID: <46BA7C62.4020000@lwfinger.net>

Ehud,

I was just reviewing the complete dmesg output that you sent earlier, which I think was for a "bad" 
case. I use WPA encryption, which cannot be done in hardware, and I have not seen messages that look 
like this:

bcm43xx-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
eth1: Initial auth_alg=0
eth1: authenticate with AP 00:0d:88:ac:b2:2a
eth1: RX authentication from 00:0d:88:ac:b2:2a (alg=0 transaction=2 status=0)
eth1: authenticated
eth1: associate with AP 00:0d:88:ac:b2:2a
eth1: RX AssocResp from 00:0d:88:ac:b2:2a (capab=0x431 status=0 aid=1)
eth1: associated
eth1: switched to short barker preamble (BSSID=00:0d:88:ac:b2:2a)
ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready

In particular, I mean the "hardware based encryption", and the "short barker preamble" messages.

Please boot a "good" kernel and save the dmesg output. Do the same for a "bad" kernel. Send the two 
sets of dmesg output, and iwconfig and ifconfig output for the bad one.

In the meantime, I'll configure my spare AP for WEP encryption and see what I get in my logs.

Thanks,

Larry


From gavron at Wetwork.Net  Thu Aug  9 04:50:31 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Wed, 08 Aug 2007 19:50:31 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BA7C62.4020000@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <200708082207.22198.mb@bu3sch.de>
	<46BA3062.9060807@Wetwork.Net> <200708082326.10162.mb@bu3sch.de>
	<46BA5A8B.1080006@Wetwork.Net> <46BA7C62.4020000@lwfinger.net>
Message-ID: <46BA80F7.1020905@Wetwork.Net>

good: rc1 "git test" tree with the commit in question reversed. Works fine.
bad: rc2 "git wireless-dev" tree with Michael's latest patch.  Does not 
work.

full dmesg, iwconfig, and ifconfigs included.

Like I said, I am happy to do this all day long so that I don't have to 
personally revert that long patch...

E

Larry Finger wrote:
> Ehud,
>
> I was just reviewing the complete dmesg output that you sent earlier, 
> which I think was for a "bad" case. I use WPA encryption, which cannot 
> be done in hardware, and I have not seen messages that look like this:
>
> bcm43xx-phy0 debug: Using hardware based encryption for keyidx: 0, 
> mac: ff:ff:ff:ff:ff:ff
> eth1: Initial auth_alg=0
> eth1: authenticate with AP 00:0d:88:ac:b2:2a
> eth1: RX authentication from 00:0d:88:ac:b2:2a (alg=0 transaction=2 
> status=0)
> eth1: authenticated
> eth1: associate with AP 00:0d:88:ac:b2:2a
> eth1: RX AssocResp from 00:0d:88:ac:b2:2a (capab=0x431 status=0 aid=1)
> eth1: associated
> eth1: switched to short barker preamble (BSSID=00:0d:88:ac:b2:2a)
> ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready
>
> In particular, I mean the "hardware based encryption", and the "short 
> barker preamble" messages.
>
> Please boot a "good" kernel and save the dmesg output. Do the same for 
> a "bad" kernel. Send the two sets of dmesg output, and iwconfig and 
> ifconfig output for the bad one.
>
> In the meantime, I'll configure my spare AP for WEP encryption and see 
> what I get in my logs.
>
> Thanks,
>
> Larry
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: dmesg_rc1_old_commit_reversed.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/c66b079a/attachment.txt>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: dmesg_rc2_michael_patch.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/c66b079a/attachment-0001.txt>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: ifconfig_rc1_good.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/c66b079a/attachment-0002.txt>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: ifconfig_rc2_bad.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/c66b079a/attachment-0003.txt>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: iwconfig_rc1_good.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/c66b079a/attachment-0004.txt>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: iwconfig_rc2_bad.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/c66b079a/attachment-0005.txt>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/c66b079a/attachment.bin>

From larry.finger at lwfinger.net  Thu Aug  9 05:25:22 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 08 Aug 2007 22:25:22 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46BA80F7.1020905@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <200708082207.22198.mb@bu3sch.de>
	<46BA3062.9060807@Wetwork.Net> <200708082326.10162.mb@bu3sch.de>
	<46BA5A8B.1080006@Wetwork.Net> <46BA7C62.4020000@lwfinger.net>
	<46BA80F7.1020905@Wetwork.Net>
Message-ID: <46BA8922.6030803@lwfinger.net>

Ehud Gavron wrote:
> good: rc1 "git test" tree with the commit in question reversed. Works fine.
> bad: rc2 "git wireless-dev" tree with Michael's latest patch.  Does not 
> work.
> 
> full dmesg, iwconfig, and ifconfigs included.
> 
> Like I said, I am happy to do this all day long so that I don't have to 
> personally revert that long patch.

With xconfig, select the "Kernel hacking" section, and turn off the "Show timing info on printks". 
In addition, turn off "Kobject debugging" in that section. The latter option generates a lot of 
messages and overflows the dmesg buffer. Do a 'make -j3' and 'sudo make modules_install install'. 
You do not need to clean out the object files, or any other make options. Boot that kernel and send 
me it's dmesg.

One further question - Are you trying to connect to the same AP in both cases? The reason I'm asking 
is that the MAC address of the AP is different for the two cases.

Larry




From gavron at Wetwork.Net  Thu Aug  9 05:55:39 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Wed, 08 Aug 2007 20:55:39 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BA8922.6030803@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <200708082207.22198.mb@bu3sch.de>
	<46BA3062.9060807@Wetwork.Net> <200708082326.10162.mb@bu3sch.de>
	<46BA5A8B.1080006@Wetwork.Net> <46BA7C62.4020000@lwfinger.net>
	<46BA80F7.1020905@Wetwork.Net> <46BA8922.6030803@lwfinger.net>
Message-ID: <46BA903B.2000109@Wetwork.Net>

Understood.  Files attached.  This time I set the channel so that 
bcm43xx_mac80211(noworkie) would associate with the same AP that 
bcm43xx_mac80211(workie) does.

For infrastructure reference there are two APs on the LAN, and one has a 
WDS with a third AP.  All are Buffalo Airstations 54G.  All work fine 
with bcm43xx & ndiswrapper with bcmwl5.

See attached.

Ehud

Larry Finger wrote:
> Ehud Gavron wrote:
>   
>> good: rc1 "git test" tree with the commit in question reversed. Works fine.
>> bad: rc2 "git wireless-dev" tree with Michael's latest patch.  Does not 
>> work.
>>
>> full dmesg, iwconfig, and ifconfigs included.
>>
>> Like I said, I am happy to do this all day long so that I don't have to 
>> personally revert that long patch.
>>     
>
> With xconfig, select the "Kernel hacking" section, and turn off the "Show timing info on printks". 
> In addition, turn off "Kobject debugging" in that section. The latter option generates a lot of 
> messages and overflows the dmesg buffer. Do a 'make -j3' and 'sudo make modules_install install'. 
> You do not need to clean out the object files, or any other make options. Boot that kernel and send 
> me it's dmesg.
>
> One further question - Are you trying to connect to the same AP in both cases? The reason I'm asking 
> is that the MAC address of the AP is different for the two cases.
>
> Larry
>
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: dmesg_rc2.3
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/ed8944cd/attachment.ksh>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: ifconfig_rc2.3
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/ed8944cd/attachment-0001.ksh>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: iwconfig_rc2.3
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/ed8944cd/attachment-0002.ksh>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070808/ed8944cd/attachment.bin>

From mb at bu3sch.de  Thu Aug  9 11:56:05 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 9 Aug 2007 11:56:05 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BA7C62.4020000@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <46BA5A8B.1080006@Wetwork.Net>
	<46BA7C62.4020000@lwfinger.net>
Message-ID: <200708091156.05952.mb@bu3sch.de>

On Thursday 09 August 2007 04:30:58 Larry Finger wrote:
> Ehud,
> 
> I was just reviewing the complete dmesg output that you sent earlier, which I think was for a "bad" 
> case. I use WPA encryption, which cannot be done in hardware, and I have not seen messages that look 

WPA works fine in hardware, except tkip.


-- 
Greetings Michael.


From mb at bu3sch.de  Thu Aug  9 14:23:09 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 9 Aug 2007 14:23:09 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BA5A8B.1080006@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <200708082326.10162.mb@bu3sch.de>
	<46BA5A8B.1080006@Wetwork.Net>
Message-ID: <200708091423.09558.mb@bu3sch.de>

On Thursday 09 August 2007 02:06:35 Ehud Gavron wrote:
> They were *ALL* enabled, even the modules for testing that I didn't load.
> They're still there in the built kernel... so if you want something from 
> it, I can easily reboot into it and get it.
> 
>  From another message:
> > n IRC was suggested that this might be a compiler bug
> > generating corrupt code.
> > Which compiler do you use? Can you upgrade or downgrade?
> [root at egdell Download]# cc --version
> cc (GCC) 4.1.2 20070502 (Red Hat 4.1.2-12)
> Copyright (C) 2006 Free Software Foundation, Inc.
> This is free software; see the source for copying conditions.  There is NO
> warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
> 
> I use Yum with F7 Repos, but yes, if need be I can erase the RPM and 
> install another.

Yes, please try with another compiler. You might also change the binutils
version.

-- 
Greetings Michael.


From johannes at sipsolutions.net  Thu Aug  9 15:42:52 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 09 Aug 2007 15:42:52 +0200
Subject: firmware versions?
Message-ID: <1186666972.11717.60.camel@johannes.berg>

Hi,

We were just discussing the negative effects of having too many
different firmwares (like the problem Andy ran into); if you're using
the version 4 driver and have a different firmware than
 * 343.126 (this is the currently recommended one)
 * 351.1092 (I'm using that)

could you reply with the version you're using? The driver prints
something like:

bcm43xx-phy0 debug: Loading firmware version 351.1092 (2006-05-13 03:13:11)

when it loads.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070809/a4bf316f/attachment.pgp>

From mb at bu3sch.de  Thu Aug  9 15:41:19 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 9 Aug 2007 15:41:19 +0200
Subject: bcm4301 -> bcm43xx-legacy
Message-ID: <200708091541.19570.mb@bu3sch.de>

It turns out that it's better to extend the device
support in bcm4301 due to more difficulties in reverse
engineering the newer bcm drivers.
Newer drivers don't contain support for wireless core ref < 5
anymore. So I suggest we support <5 devices with the legacy
driver using v3 firmware. And anything above with v4 firmware
with upstream bcm43xx-mac80211.
That's actually a nice cutoff point, as rev 5 is when they
started using the new microcode format.

So, that said, I want to rename all the drivers.
My plan was to rename "bcm43xx-mac80211" to "b43", so
you could probably rename bcm4301 to b43-legacy or something
shorter like b43-leg or maybe even b43-old.

Any comments?

-- 
Greetings Michael.


From proski at gnu.org  Thu Aug  9 16:00:47 2007
From: proski at gnu.org (Pavel Roskin)
Date: Thu, 09 Aug 2007 10:00:47 -0400
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <200708091541.19570.mb@bu3sch.de>
References: <200708091541.19570.mb@bu3sch.de>
Message-ID: <1186668047.31210.7.camel@dv>

On Thu, 2007-08-09 at 15:41 +0200, Michael Buesch wrote:

> So, that said, I want to rename all the drivers.
> My plan was to rename "bcm43xx-mac80211" to "b43", so
> you could probably rename bcm4301 to b43-legacy or something
> shorter like b43-leg or maybe even b43-old.

I think if bcm43xx will be replaced with its mac80211 port, it should
stay bcm43xx to preserve users' .config and fwpostfix settings.

If the softmac and the mac80211 drivers are going to coexist at least in
one released kernel, then b43old seems to be a good name for the new
driver.

-- 
Regards,
Pavel Roskin



From larry.finger at lwfinger.net  Thu Aug  9 16:03:22 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 09 Aug 2007 09:03:22 -0500
Subject: firmware versions?
In-Reply-To: <1186666972.11717.60.camel@johannes.berg>
References: <1186666972.11717.60.camel@johannes.berg>
Message-ID: <46BB1EAA.8060708@lwfinger.net>

Johannes Berg wrote:
> Hi,
> 
> We were just discussing the negative effects of having too many
> different firmwares (like the problem Andy ran into); if you're using
> the version 4 driver and have a different firmware than
>  * 343.126 (this is the currently recommended one)
>  * 351.1092 (I'm using that)
> 
> could you reply with the version you're using? The driver prints
> something like:
> 
> bcm43xx-phy0 debug: Loading firmware version 351.1092 (2006-05-13 03:13:11)
> 
> when it loads.

I'm using firmware version 351.126 (2006-07-29 05:54:02).

Larry




From richie at coderworld.net  Thu Aug  9 16:06:03 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Thu, 9 Aug 2007 16:06:03 +0200
Subject: Port of bcm43xx from softmac to mac80211 is available for testing
In-Reply-To: <46BA2C4D.4050605@lwfinger.net>
References: <46B50B3C.7000906@lwfinger.net>
	<200708082219.19600.richie@coderworld.net>
	<46BA2C4D.4050605@lwfinger.net>
Message-ID: <200708091606.03151.richie@coderworld.net>

On Wednesday 08 August 2007 22:49:17 you wrote:
> Richard Jonsson wrote:
> > On Monday 06 August 2007 03:21:11 you wrote:
> >> Richard Jonsson wrote:
> >>> Isn't Desired TX power supposed to adapt so that higher bitrates are
> >>> possible, with Bit Rate going lower if that is not enough to keep a
> >>> good connection?
> >>
> >> Richard,
> >>
> >> Please grab a new copy of the port_to_mac80211 patch, and try the patch
> >> below. It boosts the desired power by up to 5 dBm as signal - noise
> >> decreases from 20 to 0.
> >>
> >> Larry
> >
> > Hard to say if there is a difference. I've noticed that signal quality
> > changes between reboots. When I first tried this patch I couldn't get
> > above 36M even at the AP, so I loaded the version without the patch. Same
> > thing. So I rebooted and then all rates worked, even 11M. Even for the
> > driver version that didn't work a few days ago.
>
> That is scary! That may mean that something is not being reset. The real
> question is whether warm reboots are intrinsically different than cold
> (power-off) reboots.

I've power cycled between reboots, unsure if I would get the same results on a 
soft reset.
>
> > New/updated observations:
> > Rate scaling seems to work, but if it gets down to 1M it will not rise
> > again unless I force it to a higher bitrate and run iperf for a few
> > seconds before setting it to auto. This is even when signal is -5dBm and
> > noise is -80dBm. I get a feeling it's a bit to sensitive as it will drop
> > quickly at a few meters away. At this distance forced 54M still works
> > well.
> > Maybe this is due to small dips (0.5sec) in traffic flow?!
>
> I'm surprised that you get signal values as high as -5 dBm. My maximum is
> about -35. I'm usually in the -40 range, even at 2 m from the AP.
>
That -5dBm signal is best case when AP's antenna is a few cm from the 
computers lid. In this position it often reads between -15 - -20dBm. If I 
move just a cm further away it drops to -30dBm which gradually decreases with 
distance.

> > With the patch applied power is reported as 27dB in debugfs. With
> > debug_xmitpower dmesg reports desired power to be 16.5 and actual 16.25.
> > This is max when I manually set power through debugfs. After a while it's
> > down to 10dB, even though only 1M works where I sit.
> >
> > Range seems to be higher for B-rates. Maybe this is just how things are,
> > I lack experience.
>
> The CCCK (B) encoding is much different than OFDM (G) transmissions. I
> would not be surprised to learn that its range were longer.
>
> The power setting that comes from mac80211 is 27 dBm, which is completely
> bogus for what is supposed to be the FCC table. The regulatory limit is 20
> dBm EIRP (a fancy acronym that means take the antenna into account). I've
> sent a fix for comment, but as is the usual case for mac80211, it will take
> several days or weeks to get a response. The maximum power that a bcm43xx
> device can use is encoded in the sprom. For most of them that quantity is
> 18.5 dBm, corresponding to the regulatory limit of 20 minus a safety factor
> of 1.5. I think that is there to prevent setting the power too high and
> flunking the certification tests. The output that goes to the radio is thus
> 18.5 less the gain of the antenna, which is also in the sprom with a usual
> value of 2 dBm. That is why you see the code setting a Desired power of
> 16.5 dBm.

I see! I expected it to go to 18dBm.
>
> Initially, I thought that the performance of my BCM4311 fell off as the
> power increased; however, that no longer happens. As a result, we can push
> full power at all times and there seems to be no need to use the kind of
> algorithm that you were testing. Don't tell the FCC, but we could relax

IMHO there should eventually be some power scaling, as I understand wlan takes 
a fair amount of power. Ideally there should be different modes (powersave, 
performance) preferrably as an API common to all networking, at least 
wireless. Getting offtopic, just a thought.

> that upper power limit as we will never try to get the device certified,
> but then we would use extra power, and run the risk of burning out the
> radio. If you decide to do that, please tell me the power setting at which
> it fried!

Heh, I might have tried if it was a usb stick ;) Since it's usable and since I 
got 54M/36M rate under no/high load in winxp under the same circumstances I 
believe power output is sufficient.
>
> With the patches that were pushed into wireless-dev a few minutes ago, I
> suggest that you try bcm43xx-mac80211. It is getting at least as good, if
> not better, performance than the BCM4301 or the softmac port to mac80211
> drivers do. We would also appreciate as much testing as possible as it will
> help getting it merged into mainstream. That driver will require V4
> firmware.
>
> Thanks for your report,
>
> Larry

Sure, I'll do that. Where do I get a current source? By git?
(I forgot to add the mailinglist in the original mail, sorry)


From mb at bu3sch.de  Thu Aug  9 16:07:33 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 9 Aug 2007 16:07:33 +0200
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <1186668047.31210.7.camel@dv>
References: <200708091541.19570.mb@bu3sch.de> <1186668047.31210.7.camel@dv>
Message-ID: <200708091607.33309.mb@bu3sch.de>

On Thursday 09 August 2007 16:00:47 Pavel Roskin wrote:
> On Thu, 2007-08-09 at 15:41 +0200, Michael Buesch wrote:
> 
> > So, that said, I want to rename all the drivers.
> > My plan was to rename "bcm43xx-mac80211" to "b43", so
> > you could probably rename bcm4301 to b43-legacy or something
> > shorter like b43-leg or maybe even b43-old.
> 
> I think if bcm43xx will be replaced with its mac80211 port, it should
> stay bcm43xx to preserve users' .config and fwpostfix settings.

No it should not. bcm43xx-mac80211 requires different firmware.
We discussed that in huge discussions in the past.
If we have the same name, it will silently fail. If we rename it,
it will obviously fail.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Thu Aug  9 16:09:53 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 09 Aug 2007 09:09:53 -0500
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <200708091541.19570.mb@bu3sch.de>
References: <200708091541.19570.mb@bu3sch.de>
Message-ID: <46BB2031.7060701@lwfinger.net>

Michael Buesch wrote:
> It turns out that it's better to extend the device
> support in bcm4301 due to more difficulties in reverse
> engineering the newer bcm drivers.
> Newer drivers don't contain support for wireless core ref < 5
> anymore. So I suggest we support <5 devices with the legacy
> driver using v3 firmware. And anything above with v4 firmware
> with upstream bcm43xx-mac80211.
> That's actually a nice cutoff point, as rev 5 is when they
> started using the new microcode format.
> 
> So, that said, I want to rename all the drivers.
> My plan was to rename "bcm43xx-mac80211" to "b43", so
> you could probably rename bcm4301 to b43-legacy or something
> shorter like b43-leg or maybe even b43-old.
> 
> Any comments?
> 

I like the idea of b43 and b43-legacy. As a "senior citizen", I'm beginning to dislike the adjective 
"old", and "leg" isn't that descriptive.

What time frame do you envision this change taking place?

Larry



From mb at bu3sch.de  Thu Aug  9 16:15:13 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 9 Aug 2007 16:15:13 +0200
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <46BB2031.7060701@lwfinger.net>
References: <200708091541.19570.mb@bu3sch.de> <46BB2031.7060701@lwfinger.net>
Message-ID: <200708091615.13868.mb@bu3sch.de>

On Thursday 09 August 2007 16:09:53 Larry Finger wrote:
> I like the idea of b43 and b43-legacy. As a "senior citizen", I'm beginning to dislike the adjective 
> "old",
 
haha :P

> What time frame do you envision this change taking place?

I was planning to do it with my next patch.
Though, I see huge indention problems coming.. :)

-- 
Greetings Michael.


From proski at gnu.org  Thu Aug  9 16:21:09 2007
From: proski at gnu.org (Pavel Roskin)
Date: Thu, 09 Aug 2007 10:21:09 -0400
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <200708091607.33309.mb@bu3sch.de>
References: <200708091541.19570.mb@bu3sch.de> <1186668047.31210.7.camel@dv>
	<200708091607.33309.mb@bu3sch.de>
Message-ID: <1186669269.31394.3.camel@dv>

On Thu, 2007-08-09 at 16:07 +0200, Michael Buesch wrote:
> On Thursday 09 August 2007 16:00:47 Pavel Roskin wrote:
> > On Thu, 2007-08-09 at 15:41 +0200, Michael Buesch wrote:
> > 
> > > So, that said, I want to rename all the drivers.
> > > My plan was to rename "bcm43xx-mac80211" to "b43", so
> > > you could probably rename bcm4301 to b43-legacy or something
> > > shorter like b43-leg or maybe even b43-old.
> > 
> > I think if bcm43xx will be replaced with its mac80211 port, it should
> > stay bcm43xx to preserve users' .config and fwpostfix settings.
> 
> No it should not. bcm43xx-mac80211 requires different firmware.

I think you misread me.  "its mac80211 port" refers to bcm4301.  I just
tried to avoid the bcm4301 name because it wasn't exposed in Linux
releases yet.

Anyway, it's up to Larry, and he doesn't seem to dislike "legacy".

-- 
Regards,
Pavel Roskin



From mb at bu3sch.de  Thu Aug  9 16:33:37 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 9 Aug 2007 16:33:37 +0200
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <1186669269.31394.3.camel@dv>
References: <200708091541.19570.mb@bu3sch.de>
	<200708091607.33309.mb@bu3sch.de> <1186669269.31394.3.camel@dv>
Message-ID: <200708091633.37552.mb@bu3sch.de>

On Thursday 09 August 2007 16:21:09 Pavel Roskin wrote:
> On Thu, 2007-08-09 at 16:07 +0200, Michael Buesch wrote:
> > On Thursday 09 August 2007 16:00:47 Pavel Roskin wrote:
> > > On Thu, 2007-08-09 at 15:41 +0200, Michael Buesch wrote:
> > > 
> > > > So, that said, I want to rename all the drivers.
> > > > My plan was to rename "bcm43xx-mac80211" to "b43", so
> > > > you could probably rename bcm4301 to b43-legacy or something
> > > > shorter like b43-leg or maybe even b43-old.
> > > 
> > > I think if bcm43xx will be replaced with its mac80211 port, it should
> > > stay bcm43xx to preserve users' .config and fwpostfix settings.
> > 
> > No it should not. bcm43xx-mac80211 requires different firmware.
> 
> I think you misread me.  "its mac80211 port" refers to bcm4301.  I just
> tried to avoid the bcm4301 name because it wasn't exposed in Linux
> releases yet.
> 
> Anyway, it's up to Larry, and he doesn't seem to dislike "legacy".
> 

Better rename it now to make clear what the driver _really_ is
about, than having a bugreport each day that bcm43xx doesn't support
device X anymore.
There _will_ be a regression. That's the whole point of all this.
And we want to make it as clear as possible how to progress (which
driver to take in future).

-- 
Greetings Michael.


From mb at bu3sch.de  Thu Aug  9 16:35:53 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 9 Aug 2007 16:35:53 +0200
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <46BB2031.7060701@lwfinger.net>
References: <200708091541.19570.mb@bu3sch.de> <46BB2031.7060701@lwfinger.net>
Message-ID: <200708091635.53256.mb@bu3sch.de>

On Thursday 09 August 2007 16:09:53 Larry Finger wrote:
> Michael Buesch wrote:
> > It turns out that it's better to extend the device
> > support in bcm4301 due to more difficulties in reverse
> > engineering the newer bcm drivers.
> > Newer drivers don't contain support for wireless core ref < 5
> > anymore. So I suggest we support <5 devices with the legacy
> > driver using v3 firmware. And anything above with v4 firmware
> > with upstream bcm43xx-mac80211.
> > That's actually a nice cutoff point, as rev 5 is when they
> > started using the new microcode format.
> > 
> > So, that said, I want to rename all the drivers.
> > My plan was to rename "bcm43xx-mac80211" to "b43", so
> > you could probably rename bcm4301 to b43-legacy or something
> > shorter like b43-leg or maybe even b43-old.
> > 
> > Any comments?
> > 
> 
> I like the idea of b43 and b43-legacy. As a "senior citizen", I'm beginning to dislike the adjective 

Feel free to drop the -.
I think b43legacy is even better (to type, to read, it's shorter..)


-- 
Greetings Michael.


From larry.finger at lwfinger.net  Thu Aug  9 16:46:40 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 09 Aug 2007 09:46:40 -0500
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <200708091541.19570.mb@bu3sch.de>
References: <200708091541.19570.mb@bu3sch.de>
Message-ID: <46BB28D0.1060607@lwfinger.net>

Michael Buesch wrote:

> Newer drivers don't contain support for wireless core ref < 5
> anymore. So I suggest we support <5 devices with the legacy
> driver using v3 firmware. And anything above with v4 firmware
> with upstream bcm43xx-mac80211.
> That's actually a nice cutoff point, as rev 5 is when they
> started using the new microcode format.

A cutoff for wireless core rev < 5 means that bcm43-legacy will support BCM4301, BCM4303 and 
BCM4306/2. I have a BCM4301 and two BCM4306/2 cards, thus I'm in a good position to support that 
driver branch. There are no 4303's in the database - I'm not sure they exist in the wild. If anyone 
reading this has one, please report it through http://bcm-specs.sipsolutions.net/.

Larry




From mb at bu3sch.de  Thu Aug  9 16:52:45 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 9 Aug 2007 16:52:45 +0200
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <46BB28D0.1060607@lwfinger.net>
References: <200708091541.19570.mb@bu3sch.de> <46BB28D0.1060607@lwfinger.net>
Message-ID: <200708091652.45258.mb@bu3sch.de>

On Thursday 09 August 2007 16:46:40 Larry Finger wrote:
> Michael Buesch wrote:
> 
> > Newer drivers don't contain support for wireless core ref < 5
> > anymore. So I suggest we support <5 devices with the legacy
> > driver using v3 firmware. And anything above with v4 firmware
> > with upstream bcm43xx-mac80211.
> > That's actually a nice cutoff point, as rev 5 is when they
> > started using the new microcode format.
> 
> A cutoff for wireless core rev < 5 means that bcm43-legacy will support BCM4301, BCM4303 and 
> BCM4306/2. I have a BCM4301 and two BCM4306/2 cards, thus I'm in a good position to support that 
> driver branch. There are no 4303's in the database - I'm not sure they exist in the wild. If anyone 
> reading this has one, please report it through http://bcm-specs.sipsolutions.net/.

There will be a problem with the PCI IDs, though.
We can't see from the PCI ID if that's a v4 or v5 device. So
we have to make _one_ common ssb-pci wrapper and let us probe
from ssb, so that either b43 or b43legacy is loaded.
I'll take a look to figure out how that works. Shouldn't be
too hard. The probing is done through the ssb device table
in the driver, where you can put the supported core revs.

-- 
Greetings Michael.


From johannes at sipsolutions.net  Thu Aug  9 17:42:43 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 09 Aug 2007 17:42:43 +0200
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <46BB28D0.1060607@lwfinger.net>
References: <200708091541.19570.mb@bu3sch.de> <46BB28D0.1060607@lwfinger.net>
Message-ID: <1186674163.11717.66.camel@johannes.berg>

On Thu, 2007-08-09 at 09:46 -0500, Larry Finger wrote:
> If anyone 
> reading this has one, please report it through http://bcm-specs.sipsolutions.net/.

That interface doesn't actually work any more because the driver output
changed. I have a few submissions but haven't gotten around to putting
them into the database. I don't think there were any 4303s though.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070809/6566ef55/attachment.pgp>

From johannes at sipsolutions.net  Thu Aug  9 17:45:53 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 09 Aug 2007 17:45:53 +0200
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <200708091652.45258.mb@bu3sch.de>
References: <200708091541.19570.mb@bu3sch.de>
	<46BB28D0.1060607@lwfinger.net>  <200708091652.45258.mb@bu3sch.de>
Message-ID: <1186674353.11717.69.camel@johannes.berg>

On Thu, 2007-08-09 at 16:52 +0200, Michael Buesch wrote:

> There will be a problem with the PCI IDs, though.
> We can't see from the PCI ID if that's a v4 or v5 device. So
> we have to make _one_ common ssb-pci wrapper and let us probe
> from ssb, so that either b43 or b43legacy is loaded.
> I'll take a look to figure out how that works. Shouldn't be
> too hard. The probing is done through the ssb device table
> in the driver, where you can put the supported core revs.

For the benefit of those not on IRC, these two patches should be all
that's needed (untested!)

http://johannes.sipsolutions.net/patches/kernel/ssb-modalias.patch
http://johannes.sipsolutions.net/patches/kernel/ssb-uevent.patch

The idea will be to strip out the PCI info from both b43 and b43legacy
and then have those two as ssb-core drivers, put the pci IDs into a
bridge module that only registers the pci/ssb bridge and then the other
modules are auto-loaded based on the ssb info.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070809/4459a4bf/attachment.pgp>

From linville at tuxdriver.com  Thu Aug  9 18:07:24 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 9 Aug 2007 12:07:24 -0400
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <1186674353.11717.69.camel@johannes.berg>
References: <200708091541.19570.mb@bu3sch.de> <46BB28D0.1060607@lwfinger.net>
	<200708091652.45258.mb@bu3sch.de>
	<1186674353.11717.69.camel@johannes.berg>
Message-ID: <20070809160724.GF7811@tuxdriver.com>

On Thu, Aug 09, 2007 at 05:45:53PM +0200, Johannes Berg wrote:

> For the benefit of those not on IRC, these two patches should be all
> that's needed (untested!)
> 
> http://johannes.sipsolutions.net/patches/kernel/ssb-modalias.patch
> http://johannes.sipsolutions.net/patches/kernel/ssb-uevent.patch
> 
> The idea will be to strip out the PCI info from both b43 and b43legacy
> and then have those two as ssb-core drivers, put the pci IDs into a
> bridge module that only registers the pci/ssb bridge and then the other
> modules are auto-loaded based on the ssb info.

Excellent.  This definitely sounds like the right path to keeping the
drivers straight (or "properly sorted" as the limeys might say). :-)

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Thu Aug  9 18:41:27 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 09 Aug 2007 11:41:27 -0500
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <1186674353.11717.69.camel@johannes.berg>
References: <200708091541.19570.mb@bu3sch.de>	 <46BB28D0.1060607@lwfinger.net>
	<200708091652.45258.mb@bu3sch.de>
	<1186674353.11717.69.camel@johannes.berg>
Message-ID: <46BB43B7.9050303@lwfinger.net>

Johannes Berg wrote:
> On Thu, 2007-08-09 at 16:52 +0200, Michael Buesch wrote:
> 
>> There will be a problem with the PCI IDs, though.
>> We can't see from the PCI ID if that's a v4 or v5 device. So
>> we have to make _one_ common ssb-pci wrapper and let us probe
>> from ssb, so that either b43 or b43legacy is loaded.
>> I'll take a look to figure out how that works. Shouldn't be
>> too hard. The probing is done through the ssb device table
>> in the driver, where you can put the supported core revs.
> 
> For the benefit of those not on IRC, these two patches should be all
> that's needed (untested!)
> 
> http://johannes.sipsolutions.net/patches/kernel/ssb-modalias.patch
> http://johannes.sipsolutions.net/patches/kernel/ssb-uevent.patch
> 
> The idea will be to strip out the PCI info from both b43 and b43legacy
> and then have those two as ssb-core drivers, put the pci IDs into a
> bridge module that only registers the pci/ssb bridge and then the other
> modules are auto-loaded based on the ssb info.

Sounds good. I do believe we have a plan. Michael will convert bcm43xx-mac80211 into bcm43, and I'll 
change bcm4301 into bcm43legacy. We will have some patch conflicts over drivers/net/wireless/Kconfig 
and Makefile, so I'll wait for his submissions to propagate through before I push mine. That will 
also give me a chance to see how to use the ssb bridge modules.

Larry


From mb at bu3sch.de  Thu Aug  9 18:46:22 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 9 Aug 2007 18:46:22 +0200
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <46BB43B7.9050303@lwfinger.net>
References: <200708091541.19570.mb@bu3sch.de>
	<1186674353.11717.69.camel@johannes.berg>
	<46BB43B7.9050303@lwfinger.net>
Message-ID: <200708091846.23454.mb@bu3sch.de>

On Thursday 09 August 2007, Larry Finger wrote:
> Johannes Berg wrote:
> > On Thu, 2007-08-09 at 16:52 +0200, Michael Buesch wrote:
> > 
> >> There will be a problem with the PCI IDs, though.
> >> We can't see from the PCI ID if that's a v4 or v5 device. So
> >> we have to make _one_ common ssb-pci wrapper and let us probe
> >> from ssb, so that either b43 or b43legacy is loaded.
> >> I'll take a look to figure out how that works. Shouldn't be
> >> too hard. The probing is done through the ssb device table
> >> in the driver, where you can put the supported core revs.
> > 
> > For the benefit of those not on IRC, these two patches should be all
> > that's needed (untested!)
> > 
> > http://johannes.sipsolutions.net/patches/kernel/ssb-modalias.patch
> > http://johannes.sipsolutions.net/patches/kernel/ssb-uevent.patch
> > 
> > The idea will be to strip out the PCI info from both b43 and b43legacy
> > and then have those two as ssb-core drivers, put the pci IDs into a
> > bridge module that only registers the pci/ssb bridge and then the other
> > modules are auto-loaded based on the ssb info.
> 
> Sounds good. I do believe we have a plan. Michael will convert bcm43xx-mac80211 into bcm43, and I'll 
> change bcm4301 into bcm43legacy. We will have some patch conflicts over drivers/net/wireless/Kconfig 
> and Makefile, so I'll wait for his submissions to propagate through before I push mine. That will 
> also give me a chance to see how to use the ssb bridge modules.

Yeah, cool.
I'll send the patch later.


From martin-langer at gmx.de  Thu Aug  9 20:33:52 2007
From: martin-langer at gmx.de (Martin Langer)
Date: Thu, 9 Aug 2007 20:33:52 +0200
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <200708091635.53256.mb@bu3sch.de>
References: <200708091541.19570.mb@bu3sch.de> <46BB2031.7060701@lwfinger.net>
	<200708091635.53256.mb@bu3sch.de>
Message-ID: <20070809183352.GA3508@tuba>

On Thu, Aug 09, 2007 at 04:35:53PM +0200, Michael Buesch wrote:
> On Thursday 09 August 2007 16:09:53 Larry Finger wrote:
> > Michael Buesch wrote:
> > > It turns out that it's better to extend the device
> > > support in bcm4301 due to more difficulties in reverse
> > > engineering the newer bcm drivers.
> > > Newer drivers don't contain support for wireless core ref < 5
> > > anymore. So I suggest we support <5 devices with the legacy
> > > driver using v3 firmware. And anything above with v4 firmware
> > > with upstream bcm43xx-mac80211.
> > > That's actually a nice cutoff point, as rev 5 is when they
> > > started using the new microcode format.
> > > 
> > > So, that said, I want to rename all the drivers.
> > > My plan was to rename "bcm43xx-mac80211" to "b43", so
> > > you could probably rename bcm4301 to b43-legacy or something
> > > shorter like b43-leg or maybe even b43-old.
> > > 
> > > Any comments?
> > > 
> > 
> > I like the idea of b43 and b43-legacy. As a "senior citizen", I'm beginning to dislike the adjective 
> 
> Feel free to drop the -.
> I think b43legacy is even better (to type, to read, it's shorter..)

I wouldn't call it b43. Please add some letters here. 

BCM is still developing their bcm43xx platform. So it's possible that we 
will find another point in the future where we have to split b43 again. 
b43 is more a common name in my eyes and b43something would be better. 

I think b43legacy, b43something, b43nextgeneration,... as parts of the 
b43 family sounds much clearer to me. There should be a difference 
between the driver and the family.

But unfortunately I don't have a good idea for the right name. 

Just my $0.02
Martin


From identd_ at hotmail.com  Thu Aug  9 20:52:23 2007
From: identd_ at hotmail.com (David Ellingsworth)
Date: Thu, 9 Aug 2007 14:52:23 -0400
Subject: firmware versions?
Message-ID: <BAY128-W3018F770AEB2E5754F079A86E00@phx.gbl>


> Subject: firmware versions?
> From: johannes at sipsolutions.net
> To: bcm43xx-dev at lists.berlios.de
> Date: Thu, 9 Aug 2007 15:42:52 +0200
> 
> Hi,
> 
> We were just discussing the negative effects of having too many
> different firmwares (like the problem Andy ran into); if you're using
> the version 4 driver and have a different firmware than
>  * 343.126 (this is the currently recommended one)
>  * 351.1092 (I'm using that)
> 
> could you reply with the version you're using? The driver prints
> something like:
> 
> bcm43xx-phy0 debug: Loading firmware version 351.1092 (2006-05-13 03:13:11)
> 
> when it loads.
> 
> johannes

Johannes -

I'm currently using firmware version 351.126 (2006-07-29 05:54:02) which I obtained quite some time ago from www.linuxwireless.org.

I assume the difference in revisions probably explains the lack of performance that I am experiencing compared to others with a similar 4306 based card. At the moment I am able to associate with the AP but am unable to maintain a connection or consistently do dhcp. I will try one of the firmware revisions you have posted and see if I obtain better results. Unfortunately I don't have my own AP, and therefore its also hard for me to determine if the issues I see are range related as well.

Regards,

David Ellingsworth
_________________________________________________________________
Find a local pizza place, movie theater, and more?.then map the best route!
http://maps.live.com/default.aspx?v=2&ss=yp.bars~yp.pizza~yp.movie%20theater&cp=42.358996~-71.056691&style=r&lvl=13&tilt=-90&dir=0&alt=-1000&scene=950607&encType=1&FORM=MGAC01

From linville at tuxdriver.com  Thu Aug  9 20:51:56 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 9 Aug 2007 14:51:56 -0400
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <20070809183352.GA3508@tuba>
References: <200708091541.19570.mb@bu3sch.de> <46BB2031.7060701@lwfinger.net>
	<200708091635.53256.mb@bu3sch.de> <20070809183352.GA3508@tuba>
Message-ID: <20070809185156.GJ7811@tuxdriver.com>

On Thu, Aug 09, 2007 at 08:33:52PM +0200, Martin Langer wrote:

> I wouldn't call it b43. Please add some letters here. 
> 
> BCM is still developing their bcm43xx platform. So it's possible that we 
> will find another point in the future where we have to split b43 again. 
> b43 is more a common name in my eyes and b43something would be better. 

Premature optimization -- if something new shows-up, let it have the
longer name...

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Thu Aug  9 22:01:34 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 09 Aug 2007 15:01:34 -0500
Subject: firmware versions?
In-Reply-To: <BAY128-W3018F770AEB2E5754F079A86E00@phx.gbl>
References: <BAY128-W3018F770AEB2E5754F079A86E00@phx.gbl>
Message-ID: <46BB729E.6030908@lwfinger.net>

David Ellingsworth wrote:
>> Subject: firmware versions?
>> From: johannes at sipsolutions.net
>> To: bcm43xx-dev at lists.berlios.de
>> Date: Thu, 9 Aug 2007 15:42:52 +0200
>>
>> Hi,
>>
>> We were just discussing the negative effects of having too many
>> different firmwares (like the problem Andy ran into); if you're using
>> the version 4 driver and have a different firmware than
>>  * 343.126 (this is the currently recommended one)
>>  * 351.1092 (I'm using that)
>>
>> could you reply with the version you're using? The driver prints
>> something like:
>>
>> bcm43xx-phy0 debug: Loading firmware version 351.1092 (2006-05-13 03:13:11)
>>
>> when it loads.
>>
>> johannes
> 
> Johannes -
> 
> I'm currently using firmware version 351.126 (2006-07-29 05:54:02) which I obtained quite some time ago from www.linuxwireless.org.
> 
> I assume the difference in revisions probably explains the lack of performance that I am experiencing compared to others with a similar 4306 based card. At the moment I am able to associate with the AP but am unable to maintain a connection or consistently do dhcp. I will try one of the firmware revisions you have posted and see if I obtain better results. Unfortunately I don't have my own AP, and therefore its also hard for me to determine if the issues I see are range related as well.
> 
> Regards,
> 

It may not be firmware. Which BCM4306 do you have? My 4306/2 with a PHY rev of 1 doesn't work as 
well as the others, but that is the one that will be using bcm43legacy with V3 firmware.

Larry


Larry


From identd_ at hotmail.com  Thu Aug  9 23:47:58 2007
From: identd_ at hotmail.com (David Ellingsworth)
Date: Thu, 9 Aug 2007 17:47:58 -0400
Subject: firmware versions?
Message-ID: <BAY128-W7A76E07610F9A3591FFBF86E00@phx.gbl>


> Date: Thu, 9 Aug 2007 15:01:34 -0500
> From: larry.finger at lwfinger.net
> To: david at identd.dyndns.org
> CC: johannes at sipsolutions.net; bcm43xx-dev at lists.berlios.de
> Subject: Re: firmware versions?
> 
> David Ellingsworth wrote:
> >> Subject: firmware versions?
> >> From: johannes at sipsolutions.net
> >> To: bcm43xx-dev at lists.berlios.de
> >> Date: Thu, 9 Aug 2007 15:42:52 +0200
> >>
> >> Hi,
> >>
> >> We were just discussing the negative effects of having too many
> >> different firmwares (like the problem Andy ran into); if you're using
> >> the version 4 driver and have a different firmware than
> >>  * 343.126 (this is the currently recommended one)
> >>  * 351.1092 (I'm using that)
> >>
> >> could you reply with the version you're using? The driver prints
> >> something like:
> >>
> >> bcm43xx-phy0 debug: Loading firmware version 351.1092 (2006-05-13 03:13:11)
> >>
> >> when it loads.
> >>
> >> johannes
> > 
> > Johannes -
> > 
> > I'm currently using firmware version 351.126 (2006-07-29 05:54:02) which I obtained quite some time ago from www.linuxwireless.org.
> > 
> > I assume the difference in revisions probably explains the lack of performance that I am experiencing compared to others with a similar 4306 based card. At the moment I am able to associate with the AP but am unable to maintain a connection or consistently do dhcp. I will try one of the firmware revisions you have posted and see if I obtain better results. Unfortunately I don't have my own AP, and therefore its also hard for me to determine if the issues I see are range related as well.
> > 
> > Regards,
> > 
> 
> It may not be firmware. Which BCM4306 do you have? My 4306/2 with a PHY rev of 1 doesn't work as 
> well as the others, but that is the one that will be using bcm43legacy with V3 firmware.
> 
> Larry
> 
> 
> Larry

Here's a partial dump of from dmesg:

bcm43xx-phy0: Broadcom 4306 WLAN found
bcm43xx-phy0 debug: Found PHY: Analog 1, Type 2, Revision 1
bcm43xx-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
bcm43xx-phy0 debug: Radio turned off
bcm43xx-phy0 debug: Adding Interface type 2
bcm43xx-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
bcm43xx-phy0 debug: Radio turned on
bcm43xx-phy0 debug: Radio enabled by hardware
...

So it looks like I have a revision 1 PHY.

- David

_________________________________________________________________
Learn. Laugh. Share. Reallivemoms is right place!
http://www.reallivemoms.com?ocid=TXT_TAGHM&loc=us

From larry.finger at lwfinger.net  Fri Aug 10 00:49:01 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 09 Aug 2007 17:49:01 -0500
Subject: firmware versions?
In-Reply-To: <BAY128-W7A76E07610F9A3591FFBF86E00@phx.gbl>
References: <BAY128-W7A76E07610F9A3591FFBF86E00@phx.gbl>
Message-ID: <46BB99DD.3080505@lwfinger.net>

David Ellingsworth wrote:
> 
> bcm43xx-phy0: Broadcom 4306 WLAN found
> bcm43xx-phy0 debug: Found PHY: Analog 1, Type 2, Revision 1
> bcm43xx-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> bcm43xx-phy0 debug: Radio turned off
> bcm43xx-phy0 debug: Adding Interface type 2
> bcm43xx-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> bcm43xx-phy0 debug: Radio turned on
> bcm43xx-phy0 debug: Radio enabled by hardware
> ...
> 
> So it looks like I have a revision 1 PHY.

Yes, which is why it isn't working too well. My recollection is that the old PHY (V3 firmware) code 
works better than the V4 code does. Your card will be one of those that will use bcm43legacy, and 
will not be covered by bcm43. Watch this list for an announcement. The new drivers will be in the 
wireless-dev tree.

Larry


From identd_ at hotmail.com  Fri Aug 10 02:20:59 2007
From: identd_ at hotmail.com (David Ellingsworth)
Date: Thu, 9 Aug 2007 20:20:59 -0400
Subject: firmware versions?
Message-ID: <BAY128-W374D1762A3A22BFBB2E16786E10@phx.gbl>


> From: larry.finger at lwfinger.net
> To: david at identd.dyndns.org
> CC: bcm43xx-dev at lists.berlios.de
> Subject: Re: firmware versions?
> 
> David Ellingsworth wrote:
> > 
> > bcm43xx-phy0: Broadcom 4306 WLAN found
> > bcm43xx-phy0 debug: Found PHY: Analog 1, Type 2, Revision 1
> > bcm43xx-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> > bcm43xx-phy0 debug: Radio turned off
> > bcm43xx-phy0 debug: Adding Interface type 2
> > bcm43xx-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> > bcm43xx-phy0 debug: Radio turned on
> > bcm43xx-phy0 debug: Radio enabled by hardware
> > ...
> > 
> > So it looks like I have a revision 1 PHY.
> 
> Yes, which is why it isn't working too well. My recollection is that the old PHY (V3 firmware) code 
> works better than the V4 code does. Your card will be one of those that will use bcm43legacy, and 
> will not be covered by bcm43. Watch this list for an announcement. The new drivers will be in the 
> wireless-dev tree.
> 
> Larry


Ok good to know, but what exactly is the legacy version of the driver? Is it simply the old softmac version (aka bcm43xx atm.) or is it the port of that driver to mac80211 (via the patch that was on here a few days ago)? The current bcm43xx-mac80211 driver will be the one renamed to bcm43 correct?

- David
_________________________________________________________________
Find a local pizza place, movie theater, and more?.then map the best route!
http://maps.live.com/default.aspx?v=2&ss=yp.bars~yp.pizza~yp.movie%20theater&cp=42.358996~-71.056691&style=r&lvl=13&tilt=-90&dir=0&alt=-1000&scene=950607&encType=1&FORM=MGAC01

From larry.finger at lwfinger.net  Fri Aug 10 03:43:55 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 09 Aug 2007 20:43:55 -0500
Subject: firmware versions?
In-Reply-To: <BAY128-W374D1762A3A22BFBB2E16786E10@phx.gbl>
References: <BAY128-W374D1762A3A22BFBB2E16786E10@phx.gbl>
Message-ID: <46BBC2DB.3040108@lwfinger.net>

David Ellingsworth wrote:
> 
> 
> Ok good to know, but what exactly is the legacy version of the driver? Is it simply the 
> old softmac version (aka bcm43xx atm.) or is it the port of that driver to mac80211 (via
 > the patch that was on here a few days ago)? The current bcm43xx-mac80211 driver will be
 >  the one renamed to bcm43 correct?

The legacy driver will be similar to the patch that has been circulating and will use the PHY and 
radio code from the softmac driver with a mac80211 front end. The only devices supported with this 
driver will be those that are not covered by the latest Broadcom drivers. The bcm43xx-mac80211 will 
be renamed bcm43.

Larry



From johannes at sipsolutions.net  Fri Aug 10 11:37:09 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 10 Aug 2007 11:37:09 +0200
Subject: firmware versions?
In-Reply-To: <BAY128-W3018F770AEB2E5754F079A86E00@phx.gbl>
References: <BAY128-W3018F770AEB2E5754F079A86E00@phx.gbl>
Message-ID: <1186738629.9771.0.camel@johannes.berg>

On Thu, 2007-08-09 at 14:52 -0400, David Ellingsworth wrote:

> I assume the difference in revisions probably explains the lack of
> performance that I am experiencing compared to others with a similar
> 4306 based card.

No, that's very unlikely, the firmware is not involved in any PHY
things.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070810/eff2c067/attachment.pgp>

From johannes at sipsolutions.net  Fri Aug 10 11:40:56 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 10 Aug 2007 11:40:56 +0200
Subject: bcm4301 -> bcm43xx-legacy
In-Reply-To: <1186674353.11717.69.camel@johannes.berg>
References: <200708091541.19570.mb@bu3sch.de>
	<46BB28D0.1060607@lwfinger.net>  <200708091652.45258.mb@bu3sch.de>
	<1186674353.11717.69.camel@johannes.berg>
Message-ID: <1186738856.9771.3.camel@johannes.berg>

On Thu, 2007-08-09 at 17:45 +0200, Johannes Berg wrote:

> http://johannes.sipsolutions.net/patches/kernel/ssb-uevent.patch

Ok tested now and found a bug: i must be initialised to 0, patch
updated.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070810/38ff0f0d/attachment.pgp>

From mb at bu3sch.de  Fri Aug 10 11:59:09 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 10 Aug 2007 11:59:09 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BBCD15.4040804@Wetwork.Net>
References: <46B38B0F.20808@Wetwork.Net> <46B8B795.1040202@lwfinger.net>
	<46BBCD15.4040804@Wetwork.Net>
Message-ID: <200708101159.10112.mb@bu3sch.de>

On Friday 10 August 2007 04:27:33 Ehud Gavron wrote:
> I have spent eight hours on this today and I can't find a way to do a 
> subset of the patches. I haven't quite given up, but I'm reaching a 
> point where I could use some insight.  I didn't copy the list... but 
> feel free to if you think it of public value.
> 
> The only things that don't make obvious sense (TO ME) are
> 1. all the changes to bcm43xx_interrupt_handler   <---- I don't 
> understand what it NEEDS to be or why it WAS one way and IS another
> 2. @@ -2314,7 +2310,6 @@ static void bcm43xx_periodic_tasks_setup
>  {
>      struct delayed_work *work = &dev->periodic_work;
>  
> -    assert(bcm43xx_status(dev) == 
> BCM43xx_STAT_INITIALIZED);                <------------ this is a 
> removal with no insertion to replace it

It's an assertion. That doesn't generate code.

> 3. -    if (likely(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED)) {
> +    if (likely(bcm43xx_status(dev) >= BCM43xx_STAT_STARTED)) 
> {              <---------------------- shouldn't this be < 
> BCM43xx_STAT_STARTED ???

(That's in bcm43xx_get_tx_stats() right?)
No, we are checking for "Are we at least started here?".
So we need >=STARTED. ==STARTED would do it, too, but that's
the same with the current code. <STARTED would clearly be wrong.

> I have other questions, but the code is blurring in front of my eyes.

Yeah, well. I think it does for everybody. ;)

I'm pretty sure that it's a bug in the toolchain (gcc or binutils
or maybe something else) that's triggered by this patch.
So the toolchain generating bad code and corrupting the data.
The weird thing, however, is that you said you were able to associate,
but not able to send that packet (it was a ping, or something like that?).
From the driver point of view it doesn't matter if we TX/RX an
association packet or some other packet. The codepaths are _exactly_
the same.

That is all _very_ strange. I never had such a weird bug
in my whole life.

> Michael, I know you are busy. Could you please re-look at your patch, 
> and note the cases where you change
> bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED
> I think in the other cases you change them to
> bcm43xx_status(dev) < BCM43xx_STAT_STARTED
> which makes sense to me... so I can't understand #3 above.

The patch looks absolutely correct to me, except the tiny tiny
part in the core-starting, where I already sent a patch to
you (you said it wouldn't help).

> Any input would be appreciated. 

> PS No, I don't know this code.  No I've never written a Linux driver.  
> I'm a newbie.  I just happen to have a laptop that doesn't like the new 
> code and likes the old code for bcm43xx-mac80211.  I'm not the only 
> one.

Huh? Someone else able to reproduce it??

-- 
Greetings Michael.


From geekypenguin at gmail.com  Fri Aug 10 14:03:31 2007
From: geekypenguin at gmail.com (Jory A. Pratt)
Date: Fri, 10 Aug 2007 07:03:31 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <200708101159.10112.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net>
	<46B8B795.1040202@lwfinger.net>	<46BBCD15.4040804@Wetwork.Net>
	<200708101159.10112.mb@bu3sch.de>
Message-ID: <46BC5413.3080604@gmail.com>

Michael Buesch wrote:
> On Friday 10 August 2007 04:27:33 Ehud Gavron wrote:
>   
>> I have spent eight hours on this today and I can't find a way to do a 
>> subset of the patches. I haven't quite given up, but I'm reaching a 
>> point where I could use some insight.  I didn't copy the list... but 
>> feel free to if you think it of public value.
>>
>> The only things that don't make obvious sense (TO ME) are
>> 1. all the changes to bcm43xx_interrupt_handler   <---- I don't 
>> understand what it NEEDS to be or why it WAS one way and IS another
>> 2. @@ -2314,7 +2310,6 @@ static void bcm43xx_periodic_tasks_setup
>>  {
>>      struct delayed_work *work = &dev->periodic_work;
>>  
>> -    assert(bcm43xx_status(dev) == 
>> BCM43xx_STAT_INITIALIZED);                <------------ this is a 
>> removal with no insertion to replace it
>>     
>
> It's an assertion. That doesn't generate code.
>
>   
>> 3. -    if (likely(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED)) {
>> +    if (likely(bcm43xx_status(dev) >= BCM43xx_STAT_STARTED)) 
>> {              <---------------------- shouldn't this be < 
>> BCM43xx_STAT_STARTED ???
>>     
>
> (That's in bcm43xx_get_tx_stats() right?)
> No, we are checking for "Are we at least started here?".
> So we need >=STARTED. ==STARTED would do it, too, but that's
> the same with the current code. <STARTED would clearly be wrong.
>
>   
>> I have other questions, but the code is blurring in front of my eyes.
>>     
>
> Yeah, well. I think it does for everybody. ;)
>
> I'm pretty sure that it's a bug in the toolchain (gcc or binutils
> or maybe something else) that's triggered by this patch.
> So the toolchain generating bad code and corrupting the data.
> The weird thing, however, is that you said you were able to associate,
> but not able to send that packet (it was a ping, or something like that?).
> >From the driver point of view it doesn't matter if we TX/RX an
> association packet or some other packet. The codepaths are _exactly_
> the same.
>
> That is all _very_ strange. I never had such a weird bug
> in my whole life.
>
>   
>> Michael, I know you are busy. Could you please re-look at your patch, 
>> and note the cases where you change
>> bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED
>> I think in the other cases you change them to
>> bcm43xx_status(dev) < BCM43xx_STAT_STARTED
>> which makes sense to me... so I can't understand #3 above.
>>     
>
> The patch looks absolutely correct to me, except the tiny tiny
> part in the core-starting, where I already sent a patch to
> you (you said it wouldn't help).
>
>   
>> Any input would be appreciated. 
>>     
>
>   
>> PS No, I don't know this code.  No I've never written a Linux driver.  
>> I'm a newbie.  I just happen to have a laptop that doesn't like the new 
>> code and likes the old code for bcm43xx-mac80211.  I'm not the only 
>> one.
>>     
>
> Huh? Someone else able to reproduce it??
>
>   
Yes I am able to reproduce it. I have done upgraded and downgraded my 
enitre toolchain. exact same problem is present on my system when I try 
my 4306 and 4318.
-Jory


From mb at bu3sch.de  Fri Aug 10 14:06:50 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 10 Aug 2007 14:06:50 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	=?utf-8?q?=09but_Ethernet_appears?= broken
In-Reply-To: <46BC5413.3080604@gmail.com>
References: <46B38B0F.20808@Wetwork.Net> <200708101159.10112.mb@bu3sch.de>
	<46BC5413.3080604@gmail.com>
Message-ID: <200708101406.50546.mb@bu3sch.de>

On Friday 10 August 2007 14:03:31 Jory A. Pratt wrote:
> Yes I am able to reproduce it. I have done upgraded and downgraded my 
> enitre toolchain. exact same problem is present on my system when I try 
> my 4306 and 4318.

So, would you please debug it?

-- 
Greetings Michael.


From rec3d at yahoo.com  Fri Aug 10 15:32:30 2007
From: rec3d at yahoo.com (Jhonie Walker)
Date: Fri, 10 Aug 2007 06:32:30 -0700 (PDT)
Subject: Usage of bcm43xx-sprom tool
Message-ID: <326278.41657.qm@web50609.mail.re2.yahoo.com>


On Wednesday 08 August 2007 05:27:13 Jhonie Walker
wrote:
>> Hello, I tried to use the tool with the drivers
>> working ok, but this is what I get in the console:
>> ./sprommod.sh eth0
>> ./sprommod.sh: line 31: bcm43xx-sprom: command not
>> found
>> Could not modify SPROM data (127)
>> 
>> I noticed that the file bcm43xx-sprom does not
exist.
>> Instead it is a ssb-sprom binary file.




>Ah, it was renamed.
>That's a bug in that script.
>I think I will simply remove that script, as it's
just a
>hack that only works on the old non-ssb based driver.
> 
>
>In general you don't want to use it.
>What are you trying to do?
>Doing the wrong things with this tool can make it
very
>difficult to recover to a properly working device.
>
>-- 
>Greetings Michael.

I am trying to modify my card subsystem vendor ID and
subsystem product ID to make it usable in my hp compaq
nx6110 notebook.

My card has vendor id=0x1028 and it needs to be vendor
id=0x103C to make hp happy. Product id is 0x0005 and
it needs to be changed to 0x1356.

Thanks for your time and help.

Greetings.

Ricardo.





      ____________________________________________________________________________________
Luggage? GPS? Comic books? 
Check out fitting gifts for grads at Yahoo! Search
http://search.yahoo.com/search?fr=oni_on_mail&p=graduation+gifts&cs=bz


From larry.finger at lwfinger.net  Fri Aug 10 15:46:23 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 10 Aug 2007 08:46:23 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46BC5413.3080604@gmail.com>
References: <46B38B0F.20808@Wetwork.Net>	<46B8B795.1040202@lwfinger.net>	<46BBCD15.4040804@Wetwork.Net>	<200708101159.10112.mb@bu3sch.de>
	<46BC5413.3080604@gmail.com>
Message-ID: <46BC6C2F.10103@lwfinger.net>

Jory A. Pratt wrote:
>>   
> Yes I am able to reproduce it. I have done upgraded and downgraded my 
> enitre toolchain. exact same problem is present on my system when I try 
> my 4306 and 4318.

What encryption method are you using?

Larry


From geekypenguin at gmail.com  Fri Aug 10 16:24:32 2007
From: geekypenguin at gmail.com (Jory A. Pratt)
Date: Fri, 10 Aug 2007 09:24:32 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46BC6C2F.10103@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net>	<46B8B795.1040202@lwfinger.net>	<46BBCD15.4040804@Wetwork.Net>	<200708101159.10112.mb@bu3sch.de>
	<46BC5413.3080604@gmail.com> <46BC6C2F.10103@lwfinger.net>
Message-ID: <46BC7520.20409@gmail.com>

Larry Finger wrote:
> Jory A. Pratt wrote:
>>>   
>> Yes I am able to reproduce it. I have done upgraded and downgraded my 
>> enitre toolchain. exact same problem is present on my system when I 
>> try my 4306 and 4318.
>
> What encryption method are you using?
>
> Larry
>
I use wep encryption on a WRT54G V3 with dd-wrt. I will work on it later 
tonight and see what I can come up with.

-Jory


From larry.finger at lwfinger.net  Fri Aug 10 17:02:15 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 10 Aug 2007 10:02:15 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <46BC7520.20409@gmail.com>
References: <46B38B0F.20808@Wetwork.Net>	<46B8B795.1040202@lwfinger.net>	<46BBCD15.4040804@Wetwork.Net>	<200708101159.10112.mb@bu3sch.de>
	<46BC5413.3080604@gmail.com> <46BC6C2F.10103@lwfinger.net>
	<46BC7520.20409@gmail.com>
Message-ID: <46BC7DF7.3060600@lwfinger.net>

Jory A. Pratt wrote:
> Larry Finger wrote:
>>
>> What encryption method are you using?
>>
>> Larry
>>
> I use wep encryption on a WRT54G V3 with dd-wrt. I will work on it later 
> tonight and see what I can come up with.

Your answer confirms my latest result in which I have been able to reproduce the problem here.

I bisected the wireless-dev kernel to an arbitrary point before the change in status handling 
(commit 85a83d26). That version could connect successfully using WEP and WPA encryption. I then 
added the status-handling patch and tried again. This kernel could still do WPA encryption and it 
could authenticate and associate with the WEP-using AP, but it could not get an IP number using DHCP.

I then did a diff between the dmesg output for the driver that works (dmesg.good) and the one that 
does not (dmesg.bad). There are the usual number of differences due to slight timing difference, 
etc, but the following difference stands out:

--- dmesg.good  2007-08-10 09:40:23.000000000 -0500
+++ dmesg.bad   2007-08-10 09:41:23.000000000 -0500
..snip..
@@ -569,7 +569,6 @@
  bcm43xx_mac80211: 32-bit DMA initialized
  bcm43xx_mac80211: Wireless interface started
  NET: Registered protocol family 17
-bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
  eth1: Initial auth_alg=0
  eth1: authenticate with AP 00:1a:70:46:ba:b1
  eth1: RX authentication from 00:1a:70:46:ba:b1 (alg=0 transaction=2 status=0)


The good version is using hardware encryption, and the bad one is not. I have no idea why, but it 
seems to be the critical difference. I'm ready to test any trial patch.

Larry


From mb at bu3sch.de  Fri Aug 10 17:14:29 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 10 Aug 2007 17:14:29 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BC7DF7.3060600@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <46BC7520.20409@gmail.com>
	<46BC7DF7.3060600@lwfinger.net>
Message-ID: <200708101714.30099.mb@bu3sch.de>

On Friday 10 August 2007 17:02:15 Larry Finger wrote:
> Jory A. Pratt wrote:
> > Larry Finger wrote:
> >>
> >> What encryption method are you using?
> >>
> >> Larry
> >>
> > I use wep encryption on a WRT54G V3 with dd-wrt. I will work on it later 
> > tonight and see what I can come up with.
> 
> Your answer confirms my latest result in which I have been able to reproduce the problem here.
> 
> I bisected the wireless-dev kernel to an arbitrary point before the change in status handling 
> (commit 85a83d26). That version could connect successfully using WEP and WPA encryption. I then 
> added the status-handling patch and tried again. This kernel could still do WPA encryption and it 
> could authenticate and associate with the WEP-using AP, but it could not get an IP number using DHCP.
> 
> I then did a diff between the dmesg output for the driver that works (dmesg.good) and the one that 
> does not (dmesg.bad). There are the usual number of differences due to slight timing difference, 
> etc, but the following difference stands out:
> 
> --- dmesg.good  2007-08-10 09:40:23.000000000 -0500
> +++ dmesg.bad   2007-08-10 09:41:23.000000000 -0500
> ..snip..
> @@ -569,7 +569,6 @@
>   bcm43xx_mac80211: 32-bit DMA initialized
>   bcm43xx_mac80211: Wireless interface started
>   NET: Registered protocol family 17
> -bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
>   eth1: Initial auth_alg=0
>   eth1: authenticate with AP 00:1a:70:46:ba:b1
>   eth1: RX authentication from 00:1a:70:46:ba:b1 (alg=0 transaction=2 status=0)
> 
> 
> The good version is using hardware encryption, and the bad one is not. I have no idea why, but it 
> seems to be the critical difference. I'm ready to test any trial patch.
> 
> Larry
> 
> 

Ok, I see the bug in set_key.

	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
		err = -ENODEV;
		goto out_unlock;
	}

We didn't have a chance to spot the bug in the patch that introduced
it, because it did not touch this function.
This should be changed to

	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED) {
		err = -ENODEV;
		goto out_unlock;
	}

-- 
Greetings Michael.


From gavron at Wetwork.Net  Fri Aug 10 17:33:13 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 10 Aug 2007 08:33:13 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <200708101714.30099.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net> <46BC7520.20409@gmail.com>
	<46BC7DF7.3060600@lwfinger.net> <200708101714.30099.mb@bu3sch.de>
Message-ID: <46BC8539.2060207@Wetwork.Net>

Jory, thank you for helping convince Michael I was not hallucinating!

Larry, thank you for finding the difference in the kernel output!

Michael, thank you for finding the part of the code affected by the 
underlying changes caused by the patch but not changed by the patch!

It works.

I've got the latest wireless-dev tree (2.6.23-rc2, git checkout -f) with 
the change below IT WORKS!!!

Have I thanked everyone yet?  Because it sure as heck feels like I want to.

Ehud

Michael Buesch wrote:
> On Friday 10 August 2007 17:02:15 Larry Finger wrote:
>   
>> Jory A. Pratt wrote:
>>     
>>> Larry Finger wrote:
>>>       
>>>> What encryption method are you using?
>>>>
>>>> Larry
>>>>
>>>>         
>>> I use wep encryption on a WRT54G V3 with dd-wrt. I will work on it later 
>>> tonight and see what I can come up with.
>>>       
>> Your answer confirms my latest result in which I have been able to reproduce the problem here.
>>
>> I bisected the wireless-dev kernel to an arbitrary point before the change in status handling 
>> (commit 85a83d26). That version could connect successfully using WEP and WPA encryption. I then 
>> added the status-handling patch and tried again. This kernel could still do WPA encryption and it 
>> could authenticate and associate with the WEP-using AP, but it could not get an IP number using DHCP.
>>
>> I then did a diff between the dmesg output for the driver that works (dmesg.good) and the one that 
>> does not (dmesg.bad). There are the usual number of differences due to slight timing difference, 
>> etc, but the following difference stands out:
>>
>> --- dmesg.good  2007-08-10 09:40:23.000000000 -0500
>> +++ dmesg.bad   2007-08-10 09:41:23.000000000 -0500
>> ..snip..
>> @@ -569,7 +569,6 @@
>>   bcm43xx_mac80211: 32-bit DMA initialized
>>   bcm43xx_mac80211: Wireless interface started
>>   NET: Registered protocol family 17
>> -bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
>>   eth1: Initial auth_alg=0
>>   eth1: authenticate with AP 00:1a:70:46:ba:b1
>>   eth1: RX authentication from 00:1a:70:46:ba:b1 (alg=0 transaction=2 status=0)
>>
>>
>> The good version is using hardware encryption, and the bad one is not. I have no idea why, but it 
>> seems to be the critical difference. I'm ready to test any trial patch.
>>
>> Larry
>>
>>
>>     
>
> Ok, I see the bug in set_key.
>
> 	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
> 		err = -ENODEV;
> 		goto out_unlock;
> 	}
>
> We didn't have a chance to spot the bug in the patch that introduced
> it, because it did not touch this function.
> This should be changed to
>
> 	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED) {
> 		err = -ENODEV;
> 		goto out_unlock;
> 	}
>
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070810/c5a50b7f/attachment.bin>

From larry.finger at lwfinger.net  Fri Aug 10 17:35:03 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 10 Aug 2007 10:35:03 -0500
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates, but Ethernet
	appears broken
In-Reply-To: <200708101714.30099.mb@bu3sch.de>
References: <46B38B0F.20808@Wetwork.Net>
	<46BC7520.20409@gmail.com>	<46BC7DF7.3060600@lwfinger.net>
	<200708101714.30099.mb@bu3sch.de>
Message-ID: <46BC85A7.80804@lwfinger.net>

Michael Buesch wrote:
> On Friday 10 August 2007 17:02:15 Larry Finger wrote:
>> Jory A. Pratt wrote:
>>> Larry Finger wrote:
>>>> What encryption method are you using?
>>>>
>>>> Larry
>>>>
>>> I use wep encryption on a WRT54G V3 with dd-wrt. I will work on it later 
>>> tonight and see what I can come up with.
>> Your answer confirms my latest result in which I have been able to reproduce the problem here.
>>
>> I bisected the wireless-dev kernel to an arbitrary point before the change in status handling 
>> (commit 85a83d26). That version could connect successfully using WEP and WPA encryption. I then 
>> added the status-handling patch and tried again. This kernel could still do WPA encryption and it 
>> could authenticate and associate with the WEP-using AP, but it could not get an IP number using DHCP.
>>
>> I then did a diff between the dmesg output for the driver that works (dmesg.good) and the one that 
>> does not (dmesg.bad). There are the usual number of differences due to slight timing difference, 
>> etc, but the following difference stands out:
>>
>> --- dmesg.good  2007-08-10 09:40:23.000000000 -0500
>> +++ dmesg.bad   2007-08-10 09:41:23.000000000 -0500
>> ..snip..
>> @@ -569,7 +569,6 @@
>>   bcm43xx_mac80211: 32-bit DMA initialized
>>   bcm43xx_mac80211: Wireless interface started
>>   NET: Registered protocol family 17
>> -bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
>>   eth1: Initial auth_alg=0
>>   eth1: authenticate with AP 00:1a:70:46:ba:b1
>>   eth1: RX authentication from 00:1a:70:46:ba:b1 (alg=0 transaction=2 status=0)
>>
>>
>> The good version is using hardware encryption, and the bad one is not. I have no idea why, but it 
>> seems to be the critical difference. I'm ready to test any trial patch.
>>
>> Larry
>>
>>
> 
> Ok, I see the bug in set_key.
> 
> 	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
> 		err = -ENODEV;
> 		goto out_unlock;
> 	}
> 
> We didn't have a chance to spot the bug in the patch that introduced
> it, because it did not touch this function.
> This should be changed to
> 
> 	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED) {
> 		err = -ENODEV;
> 		goto out_unlock;
> 	}
> 

This part of set_multicast_list also was not touched by the patch

         if (wl->promisc != !!(netflags & IFF_PROMISC)) {
                 wl->promisc = !!(netflags & IFF_PROMISC);
                 if (bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED)
                         bcm43xx_adjust_opmode(dev);
         }

Is that correct? My thinking is that it should be >= BCM43xx_STAT_INITIALIZED.

Larry



From mb at bu3sch.de  Fri Aug 10 17:38:23 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 10 Aug 2007 17:38:23 +0200
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BC85A7.80804@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <200708101714.30099.mb@bu3sch.de>
	<46BC85A7.80804@lwfinger.net>
Message-ID: <200708101738.24100.mb@bu3sch.de>

On Friday 10 August 2007 17:35:03 Larry Finger wrote:
> Michael Buesch wrote:
> > On Friday 10 August 2007 17:02:15 Larry Finger wrote:
> >> Jory A. Pratt wrote:
> >>> Larry Finger wrote:
> >>>> What encryption method are you using?
> >>>>
> >>>> Larry
> >>>>
> >>> I use wep encryption on a WRT54G V3 with dd-wrt. I will work on it later 
> >>> tonight and see what I can come up with.
> >> Your answer confirms my latest result in which I have been able to reproduce the problem here.
> >>
> >> I bisected the wireless-dev kernel to an arbitrary point before the change in status handling 
> >> (commit 85a83d26). That version could connect successfully using WEP and WPA encryption. I then 
> >> added the status-handling patch and tried again. This kernel could still do WPA encryption and it 
> >> could authenticate and associate with the WEP-using AP, but it could not get an IP number using DHCP.
> >>
> >> I then did a diff between the dmesg output for the driver that works (dmesg.good) and the one that 
> >> does not (dmesg.bad). There are the usual number of differences due to slight timing difference, 
> >> etc, but the following difference stands out:
> >>
> >> --- dmesg.good  2007-08-10 09:40:23.000000000 -0500
> >> +++ dmesg.bad   2007-08-10 09:41:23.000000000 -0500
> >> ..snip..
> >> @@ -569,7 +569,6 @@
> >>   bcm43xx_mac80211: 32-bit DMA initialized
> >>   bcm43xx_mac80211: Wireless interface started
> >>   NET: Registered protocol family 17
> >> -bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
> >>   eth1: Initial auth_alg=0
> >>   eth1: authenticate with AP 00:1a:70:46:ba:b1
> >>   eth1: RX authentication from 00:1a:70:46:ba:b1 (alg=0 transaction=2 status=0)
> >>
> >>
> >> The good version is using hardware encryption, and the bad one is not. I have no idea why, but it 
> >> seems to be the critical difference. I'm ready to test any trial patch.
> >>
> >> Larry
> >>
> >>
> > 
> > Ok, I see the bug in set_key.
> > 
> > 	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
> > 		err = -ENODEV;
> > 		goto out_unlock;
> > 	}
> > 
> > We didn't have a chance to spot the bug in the patch that introduced
> > it, because it did not touch this function.
> > This should be changed to
> > 
> > 	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED) {
> > 		err = -ENODEV;
> > 		goto out_unlock;
> > 	}
> > 
> 
> This part of set_multicast_list also was not touched by the patch
> 
>          if (wl->promisc != !!(netflags & IFF_PROMISC)) {
>                  wl->promisc = !!(netflags & IFF_PROMISC);
>                  if (bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED)
>                          bcm43xx_adjust_opmode(dev);
>          }
> 
> Is that correct? My thinking is that it should be >= BCM43xx_STAT_INITIALIZED.

Yeah, you are right.
I will submit patches for this.

-- 
Greetings Michael.


From gavron at Wetwork.Net  Fri Aug 10 17:42:46 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 10 Aug 2007 08:42:46 -0700
Subject: 2.6.23-rc1-wireless-dev bcm43xx_mac80211 associates,
	but Ethernet appears broken
In-Reply-To: <46BC85A7.80804@lwfinger.net>
References: <46B38B0F.20808@Wetwork.Net> <46BC7520.20409@gmail.com>
	<46BC7DF7.3060600@lwfinger.net> <200708101714.30099.mb@bu3sch.de>
	<46BC85A7.80804@lwfinger.net>
Message-ID: <46BC8776.7090600@Wetwork.Net>

That change is already built on my kernel (now wireless-dev with two 
patches).  I'm assuming it's correct, but if you'd like to confirm it, 
please let me know which packet(s) to craft in order to test it.
Thanks again,
Ehud

Larry Finger wrote:
> Michael Buesch wrote:
>   
>> On Friday 10 August 2007 17:02:15 Larry Finger wrote:
>>     
>>> Jory A. Pratt wrote:
>>>       
>>>> Larry Finger wrote:
>>>>         
>>>>> What encryption method are you using?
>>>>>
>>>>> Larry
>>>>>
>>>>>           
>>>> I use wep encryption on a WRT54G V3 with dd-wrt. I will work on it later 
>>>> tonight and see what I can come up with.
>>>>         
>>> Your answer confirms my latest result in which I have been able to reproduce the problem here.
>>>
>>> I bisected the wireless-dev kernel to an arbitrary point before the change in status handling 
>>> (commit 85a83d26). That version could connect successfully using WEP and WPA encryption. I then 
>>> added the status-handling patch and tried again. This kernel could still do WPA encryption and it 
>>> could authenticate and associate with the WEP-using AP, but it could not get an IP number using DHCP.
>>>
>>> I then did a diff between the dmesg output for the driver that works (dmesg.good) and the one that 
>>> does not (dmesg.bad). There are the usual number of differences due to slight timing difference, 
>>> etc, but the following difference stands out:
>>>
>>> --- dmesg.good  2007-08-10 09:40:23.000000000 -0500
>>> +++ dmesg.bad   2007-08-10 09:41:23.000000000 -0500
>>> ..snip..
>>> @@ -569,7 +569,6 @@
>>>   bcm43xx_mac80211: 32-bit DMA initialized
>>>   bcm43xx_mac80211: Wireless interface started
>>>   NET: Registered protocol family 17
>>> -bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
>>>   eth1: Initial auth_alg=0
>>>   eth1: authenticate with AP 00:1a:70:46:ba:b1
>>>   eth1: RX authentication from 00:1a:70:46:ba:b1 (alg=0 transaction=2 status=0)
>>>
>>>
>>> The good version is using hardware encryption, and the bad one is not. I have no idea why, but it 
>>> seems to be the critical difference. I'm ready to test any trial patch.
>>>
>>> Larry
>>>
>>>
>>>       
>> Ok, I see the bug in set_key.
>>
>> 	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
>> 		err = -ENODEV;
>> 		goto out_unlock;
>> 	}
>>
>> We didn't have a chance to spot the bug in the patch that introduced
>> it, because it did not touch this function.
>> This should be changed to
>>
>> 	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED) {
>> 		err = -ENODEV;
>> 		goto out_unlock;
>> 	}
>>
>>     
>
> This part of set_multicast_list also was not touched by the patch
>
>          if (wl->promisc != !!(netflags & IFF_PROMISC)) {
>                  wl->promisc = !!(netflags & IFF_PROMISC);
>                  if (bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED)
>                          bcm43xx_adjust_opmode(dev);
>          }
>
> Is that correct? My thinking is that it should be >= BCM43xx_STAT_INITIALIZED.
>
> Larry
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070810/6c75fff0/attachment.bin>

From geekypenguin at gmail.com  Fri Aug 10 19:10:45 2007
From: geekypenguin at gmail.com (Jory A. Pratt)
Date: Fri, 10 Aug 2007 12:10:45 -0500
Subject: firmware versions?
In-Reply-To: <1186666972.11717.60.camel@johannes.berg>
References: <1186666972.11717.60.camel@johannes.berg>
Message-ID: <46BC9C15.2050606@gmail.com>

Johannes Berg wrote:
> Hi,
>
> We were just discussing the negative effects of having too many
> different firmwares (like the problem Andy ran into); if you're using
> the version 4 driver and have a different firmware than
>  * 343.126 (this is the currently recommended one)
>  * 351.1092 (I'm using that)
>
> could you reply with the version you're using? The driver prints
> something like:
>
> bcm43xx-phy0 debug: Loading firmware version 351.1092 (2006-05-13 03:13:11)
>
> when it loads.
>
> johannes
>   
> ------------------------------------------------------------------------
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
I am now able to use wireless-dev branch so I can post some info :)

bcm43xx-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
bcm43xx-phy0 debug: Found PHY: Analog 2, Type 2, Revision 2


This is a 4306 mini-pci I picked up for the lappy I will test the 4318 
later today as well :)


From mistamaila at gmail.com  Fri Aug 10 19:28:13 2007
From: mistamaila at gmail.com (John H.)
Date: Fri, 10 Aug 2007 12:28:13 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46BA774D.4080506@lwfinger.net>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>
	<46B361CD.8070705@lwfinger.net>
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net> <20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
Message-ID: <5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>

Larry, your driver seems to work pretty well, the bcm43xx one,
however, sometimes I have to reboot to get it working right again(I
just can't ping anything, etc).

I was wondering if that file you linked to is updated often?

On 8/8/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > I am using larry's .bz2 of bcm43xx and I get this ...
> >
> > wlan0     IEEE 802.11b/g  ESSID:"Network4Home"  Nickname:"Broadcom 4311"
> >           Mode:Managed  Frequency=2.437 GHz  Access Point:blah
> >           Bit Rate=24 Mb/s   Tx-Power=18 dBm
> >           RTS thr:off   Fragment thr:off
> >           Link Quality=50/100  Signal level=-69 dBm  Noise level=-71 dBm
> >           Rx invalid nwid:0  Rx invalid crypt:11  Rx invalid frag:0
> >           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> >
> >
> > Is it possible to get 54mb/s?  Should I care if it's mainly for
> > residential cable modem right now?
>
> To get a setting of 54M, look at 'man iwconfig'. To get throughput at 54M, you need a different
> driver, and much better signal to noise! The highest residential cable rates in my area are 8Mbs
> down and 512Kbs up. Business rates ate 10 Mbs down and 2 Mbs up, but that costs a lot more. Your 24M
> setting should give you something in the range of 12Mbs throughput. You do the math.
>
> Larry
>
>


From comphappy at gmail.com  Fri Aug 10 19:40:08 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Fri, 10 Aug 2007 09:40:08 -0800
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<46B361CD.8070705@lwfinger.net>
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net> <20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
Message-ID: <b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>

as root
modprobe -r bcm43xx
modprobe bcm43xx

then you dont need to reboot

On 8/10/07, John H. <mistamaila at gmail.com> wrote:
> Larry, your driver seems to work pretty well, the bcm43xx one,
> however, sometimes I have to reboot to get it working right again(I
> just can't ping anything, etc).
>
> I was wondering if that file you linked to is updated often?
>
> On 8/8/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> > John H. wrote:
> > > I am using larry's .bz2 of bcm43xx and I get this ...
> > >
> > > wlan0     IEEE 802.11b/g  ESSID:"Network4Home"  Nickname:"Broadcom 4311"
> > >           Mode:Managed  Frequency=2.437 GHz  Access Point:blah
> > >           Bit Rate=24 Mb/s   Tx-Power=18 dBm
> > >           RTS thr:off   Fragment thr:off
> > >           Link Quality=50/100  Signal level=-69 dBm  Noise level=-71 dBm
> > >           Rx invalid nwid:0  Rx invalid crypt:11  Rx invalid frag:0
> > >           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> > >
> > >
> > > Is it possible to get 54mb/s?  Should I care if it's mainly for
> > > residential cable modem right now?
> >
> > To get a setting of 54M, look at 'man iwconfig'. To get throughput at 54M, you need a different
> > driver, and much better signal to noise! The highest residential cable rates in my area are 8Mbs
> > down and 512Kbs up. Business rates ate 10 Mbs down and 2 Mbs up, but that costs a lot more. Your 24M
> > setting should give you something in the range of 12Mbs throughput. You do the math.
> >
> > Larry
> >
> >
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From Larry.Finger at lwfinger.net  Fri Aug 10 19:44:45 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 10 Aug 2007 12:44:45 -0500
Subject: [RFC] Proposed changes to fwcutter
Message-ID: <46bca40d.zEv6v3zA35+E39SQ%Larry.Finger@lwfinger.net>

This patch will convert fwcutter to generate firmware files with names
of bcm43_XXX.fw from V4 driver filess and bcm43legacy_XXX.fw from V3
driver files. It also changes the fwcutter version from 6 to 7 and
the name of the utility to bcm43-fwcutter.

Note: I stuck the new string that I needed in the cmdargs structure,
even though it has nothing to do with command arguments.

Larry


Index: bcm43xx-fwcutter-006/Makefile
===================================================================
--- bcm43xx-fwcutter-006.orig/Makefile
+++ bcm43xx-fwcutter-006/Makefile
@@ -1,4 +1,4 @@
-VERSION = 006
+VERSION = 007
 
 FIRMWARE_INSTALL_DIR ?= /lib/firmware
 
@@ -16,20 +16,20 @@ CFLAGS += -DFWCUTTER_VERSION_=$(VERSION)
 all: fwcutter
 
 fwcutter: $(OBJECTS)
-	$(CC) $(CFLAGS) -o bcm43xx-fwcutter $(OBJECTS) $(LDFLAGS)
+	$(CC) $(CFLAGS) -o bcm43-fwcutter $(OBJECTS) $(LDFLAGS)
 
 install: all
 	-install -d -o 0 -g 0 -m 755 $(PREFIX)/bin/
-	-install -o 0 -g 0 -m 755 bcm43xx-fwcutter $(PREFIX)/bin/
+	-install -o 0 -g 0 -m 755 bcm43-fwcutter $(PREFIX)/bin/
 	-install -d -o 0 -g 0 -m 755 $(PREFIX)/man/man1/
-	-install -o 0 -g 0 -m 644 bcm43xx-fwcutter.1 $(PREFIX)/man/man1/
+	-install -o 0 -g 0 -m 644 bcm43-fwcutter.1 $(PREFIX)/man/man1/
 
 clean:
-	-rm -f *~ *.o *.orig *.rej *.fw bcm43xx-fwcutter
+	-rm -f *~ *.o *.orig *.rej *.fw bcm43-fwcutter
 
 installfw:
 	-if ! [ -d $(FIRMWARE_INSTALL_DIR) ]; then mkdir -p $(FIRMWARE_INSTALL_DIR); fi
-	-install -o 0 -g 0 -m 600 bcm43xx_*.fw $(FIRMWARE_INSTALL_DIR)
+	-install -o 0 -g 0 -m 600 bcm43_*.fw $(FIRMWARE_INSTALL_DIR)
 
 # dependencies
 fwcutter.o: fwcutter.h md5.h fwcutter_list.h
Index: bcm43xx-fwcutter-006/fwcutter.c
===================================================================
--- bcm43xx-fwcutter-006.orig/fwcutter.c
+++ bcm43xx-fwcutter-006/fwcutter.c
@@ -111,8 +111,9 @@ static void write_iv(uint8_t flags, uint
 		}
 
 		snprintf(ivfilename, sizeof(ivfilename),
-			 "%s/bcm43xx_initval%02d%s.fw",
+			 "%s/bcm43%s_initval%02d%s.fw",
 			 cmdargs.target_dir,
+			 cmdargs.format,
 			 ivnum,
 			 cmdargs.postfix);
 
@@ -168,8 +169,8 @@ static void write_iv(uint8_t flags, uint
 			exit(1);
 		}
 
-		printf("extracting bcm43xx_initval%02d%s.fw ...\n", 
-		       ivnum,
+		printf("extracting bcm43%s_initval%02d%s.fw ...\n",
+		       cmdargs.format, ivnum,
 		       cmdargs.postfix);
 
 		while (1) {
@@ -289,16 +290,17 @@ static void extract_fw(uint8_t fwtype, u
 	case FIRMWARE_UCODE_5:
 	case FIRMWARE_UCODE_11:
 	case FIRMWARE_UCODE_13:
-		snprintf(outfile, sizeof(outfile), "bcm43xx_microcode%i%s.fw", 
-			 fwtype - FIRMWARE_UCODE_OFFSET, cmdargs.postfix);
+		snprintf(outfile, sizeof(outfile), "bcm43%s_microcode%i%s.fw",
+			 cmdargs.format, fwtype - FIRMWARE_UCODE_OFFSET,
+			 cmdargs.postfix);
 		break;
 	case FIRMWARE_PCM_4:
 	case FIRMWARE_PCM_5:
-		snprintf(outfile, sizeof(outfile), "bcm43xx_pcm%i%s.fw", 
-			 fwtype, cmdargs.postfix);
+		snprintf(outfile, sizeof(outfile), "bcm43%s_pcm%i%s.fw",
+			 cmdargs.format, fwtype, cmdargs.postfix);
 		break;
 	default:
-		snprintf(outfile, sizeof(outfile), "bcm43xx_unknown.fw");
+		snprintf(outfile, sizeof(outfile), "bcm43_unknown.fw");
 	}
 
 	if (length > 0) {
@@ -313,29 +315,29 @@ static void extract_fw(uint8_t fwtype, u
 		switch (fwtype) {
 		case FIRMWARE_UCODE_2:
 		case FIRMWARE_UCODE_4:
-			printf("WARNING! Therefore bcm43xx with 0x812 cores "
+			printf("WARNING! Therefore bcm43 with 0x812 cores "
 			       "rev 0x%x will not work.\n", 
 			       fwtype - FIRMWARE_UCODE_OFFSET);
 			break;
 		case FIRMWARE_UCODE_5:
-			printf("WARNING! Therefore bcm43xx with cores 0x812 "
+			printf("WARNING! Therefore bcm43 with cores 0x812 "
 			       "rev 0x5 up to 0xa will not work.\n");
 			break;
 		case FIRMWARE_UCODE_11:
-			printf("WARNING! Therefore bcm43xx with cores 0x812 "
+			printf("WARNING! Therefore bcm43 with cores 0x812 "
 			       "rev 0xb or 0xc will not work.\n");
 			break;
 		case FIRMWARE_UCODE_13:
-			printf("WARNING! Therefore bcm43xx with cores 0x812 "
+			printf("WARNING! Therefore bcm43 with cores 0x812 "
 			       "rev 0xd or greater will not work.\n");
 			break;
 		case FIRMWARE_PCM_4:
-			printf("WARNING! Therefore bcm43xx with cores 0x812 "
+			printf("WARNING! Therefore bcm43 with cores 0x812 "
 			       "rev 0x%x or smaller will not work.\n", 
 			       fwtype);
 			break;
 		case FIRMWARE_PCM_5:
-			printf("WARNING! Therefore bcm43xx with cores 0x812 "
+			printf("WARNING! Therefore bcm43 with cores 0x812 "
 			       "rev 0x%x or greater will not work.\n", 
 			       fwtype);
 			break;
@@ -484,7 +486,7 @@ static void get_ucode_info(const struct 
 
 static void print_banner(void)
 {
-	printf("bcm43xx-fwcutter version " FWCUTTER_VERSION "\n");
+	printf("bcm43-fwcutter version " FWCUTTER_VERSION "\n");
 }
 
 static void print_file(const struct file *file)
@@ -569,14 +571,13 @@ static const struct file * find_file(FIL
 				return 0;
 			}
 			if (files[i].flags & V4_FIRMWARE) {
-				printf("*** WARNING ***\n"
-				       "This file contains new version4 \n"
-				       "firmware. v4 firmware is _not_ supported by \n"
-				       "the driver in mainline kernels. For v4 firmware \n"
-				       "you need latest bcm43xx development version \n"
-				       "(wireless-dev kernel tree). If you don't know what \n"
-				       "this warning is about, use a 3.xx.xx.xx driver version \n"
-				       "instead to extract the firmware.\n");
+				strcpy(cmdargs.format, "");
+				printf( "This file contains version 4 "
+					" firmware for the bcm43 driver\n");
+			} else {
+				strcpy(cmdargs.format, "-legacy");
+				printf( "This file contains version 3 "
+					" firmware for the bcm43legacy driver\n");
 			}
 			printf("\n  filename   :  %s\n", files[i].name);
 			printf("  version    :  %s\n", files[i].version);
@@ -601,7 +602,7 @@ static const struct file * find_file(FIL
 		}
 	}
 	printf("Sorry, the input file is either wrong or "
-	       "not supported by bcm43xx-fwcutter.\n");
+	       "not supported by bcm43-fwcutter.\n");
 	printf("This file has an unknown MD5sum %s.\n", md5sig);
 
 	return 0;
@@ -637,7 +638,7 @@ static void print_usage(int argc, char *
 	printf("  -p|--postfix \".FOO\"   "
 	       "Postfix for firmware filenames (.FOO.fw)\n");
 	printf("  -v|--version          "
-	       "Print bcm43xx-fwcutter version\n");
+	       "Print bcm43-fwcutter version\n");
 	printf("  -h|--help             "
 	       "Print this help\n");
 	printf("\nExample: %s bcmwl5.sys\n"
Index: bcm43xx-fwcutter-006/bcm43-fwcutter.1
===================================================================
--- /dev/null
+++ bcm43xx-fwcutter-006/bcm43-fwcutter.1
@@ -0,0 +1,103 @@
+.\" Initially generated by help2man 1.36.
+.TH BCM43-FWCUTTER "1" "September 2006" "bcm43-fwcutter" "User Commands"
+.SH NAME
+bcm43-fwcutter \- manual page for bcm43-fwcutter
+.SH SYNOPSIS
+.B bcm43-fwcutter
+[\fIOPTION\fR] [\fIDRIVER\fR]
+.SH DESCRIPTION
+Bcm43xx-fwcutter can extract the firmware for your Broadcom 43xx hardware from different closed source drivers. The bcm43  and bcm43legacy drivers depend on this firmware files and can't work without them.
+.PP
+Currently bcm43-fwcutter supports Apple MacOS X, Microsoft Windows 98/ME/2000/XP and Linux drivers, but keep in mind that bcm43-fwcutter doesn't support all driver versions.
+.PP
+Example:
+.IP
+bcm43-fwcutter bcmwl5.sys
+.PP
+to cut the firmware out of bcmwl5.sys
+.SH OPTIONS
+.TP
+\fB\-l\fR|\-\-list
+List supported driver versions
+.TP
+\fB\-i\fR|\-\-identify
+Only identify the driver file (don't extract)
+.TP
+\fB\-w\fR|\-\-target\-dir DIR
+Extract and write firmware to DIR
+.TP
+\fB\-a\fR|\-\-alt\-iv
+Extract alternative initvals (only 3.10.x.x)
+.TP
+\fB\-p\fR|\-\-postfix ".FOO"
+Postfix for firmware filenames (.FOO.fw)
+.TP
+\fB\-v\fR|\-\-version
+Print bcm43-fwcutter version
+.TP
+\fB\-h\fR|\-\-help
+Print help information
+.SH DRIVERS
+.TP
+\fBAppleAirPort2\fR
+Apple MacOS 10.x driver file (ppc, x86)
+.TP
+\fBAppleAirPort3\fR
+Apple MacOS 10.x driver file (ppc)
+.TP
+\fBAppleAirPortBrcm4311\fR
+Apple MacOS 10.4 driver file (x86)
+.TP
+\fBbcmwl5.sys\fR
+Microsoft Windows driver file, 32bit (x86)
+.TP
+\fBbcmwl564.sys\fR
+Microsoft Windows driver file, 64bit (x86-64)
+.TP
+\fBbcmwl5a.sys\fR
+Microsoft Windows driver file, 32bit (x86)
+.TP
+\fBmn720-50.sys\fR
+This is a renamed bcmwl5.sys driver for Microsoft Wireless MN-720 Notebook Adapter
+and MN-730 PCI Adapter
+.TP
+\fBn54gnds.sys\fR
+This is a renamed bcmwl5.sys driver for Planex GW-NS54G 54Mbps Wireless LAN Cards
+.TP
+\fBwmp11v27.sys\fR
+This is a renamed bcmwl5.sys driver for Linksys WMP-11 802.11b PCI Cards
+.TP
+\fBwn511b.sys\fR
+This is a renamed bcmwl5.sys driver for Netgear WN511B Cards
+.TP
+\fBap_d11ucode.o\fR
+Linux 2.4.x driver file (mips)
+.TP
+\fBapsta_d11ucode.o\fR
+Linux 2.4.x driver file (mips)
+.TP
+\fBsta_d11ucode.o\fR
+Linux 2.4.x driver file (mips)
+.TP
+\fBwl.o\fR
+Linux 2.4.x driver file (mips)
+.TP
+\fBwl_ap.o\fR
+Linux 2.4.x driver file (mips)
+.TP
+\fBwl_apsta.o\fR
+Linux 2.4.x driver file (mips)
+.TP
+\fBwl_sta.o\fR
+Linux 2.4.x driver file (mips)
+.TP
+\fBwl96345GW.o_save\fR
+Linux 2.6.x driver file (mips, bcm6345)
+.TP
+\fBwl96348GW.o_save\fR
+Linux 2.6.x driver file (mips, bcm6348)
+.TP
+\fBwl96348GWV_DT.o_save\fR
+Linux 2.6.x driver file (mips, bcm6348)
+.SH AUTHORS
+BCM43xx development team, http://bcm43xx.berlios.de
Index: bcm43xx-fwcutter-006/fwcutter.h
===================================================================
--- bcm43xx-fwcutter-006.orig/fwcutter.h
+++ bcm43xx-fwcutter-006/fwcutter.h
@@ -59,6 +59,7 @@ struct cmdline_args {
 	const char *infile;
 	const char *postfix;
 	const char *target_dir;
+	char format[10];
 	int alt_iv;
 	int identify_only;
 };
Index: bcm43xx-fwcutter-006/bcm43xx-fwcutter.1
===================================================================
--- bcm43xx-fwcutter-006.orig/bcm43xx-fwcutter.1
+++ bcm43xx-fwcutter-006/bcm43xx-fwcutter.1
@@ -1,103 +1 @@
-.\" Initially generated by help2man 1.36.
-.TH BCM43XX-FWCUTTER "1" "September 2006" "bcm43xx-fwcutter" "User Commands"
-.SH NAME
-bcm43xx-fwcutter \- manual page for bcm43xx-fwcutter
-.SH SYNOPSIS
-.B bcm43xx-fwcutter
-[\fIOPTION\fR] [\fIDRIVER\fR]
-.SH DESCRIPTION
-Bcm43xx-fwcutter can extract the firmware for your Broadcom 43xx hardware from different closed source drivers. The bcm43xx driver depends on this firmware files and can't work without them.
-.PP
-Currently bcm43xx-fwcutter supports Apple MacOS X, Microsoft Windows 98/ME/2000/XP and Linux drivers, but keep in mind that bcm43xx-fwcutter doesn't support all driver versions.
-.PP
-Example:
-.IP
-bcm43xx-fwcutter bcmwl5.sys
-.PP
-to cut the firmware out of bcmwl5.sys
-.SH OPTIONS
-.TP
-\fB\-l\fR|\-\-list
-List supported driver versions
-.TP
-\fB\-i\fR|\-\-identify
-Only identify the driver file (don't extract)
-.TP
-\fB\-w\fR|\-\-target\-dir DIR
-Extract and write firmware to DIR
-.TP
-\fB\-a\fR|\-\-alt\-iv
-Extract alternative initvals (only 3.10.x.x)
-.TP
-\fB\-p\fR|\-\-postfix ".FOO"
-Postfix for firmware filenames (.FOO.fw)
-.TP
-\fB\-v\fR|\-\-version
-Print bcm43xx-fwcutter version
-.TP
-\fB\-h\fR|\-\-help
-Print help information
-.SH DRIVERS
-.TP
-\fBAppleAirPort2\fR
-Apple MacOS 10.x driver file (ppc, x86)
-.TP
-\fBAppleAirPort3\fR
-Apple MacOS 10.x driver file (ppc)
-.TP
-\fBAppleAirPortBrcm4311\fR
-Apple MacOS 10.4 driver file (x86)
-.TP
-\fBbcmwl5.sys\fR
-Microsoft Windows driver file, 32bit (x86)
-.TP
-\fBbcmwl564.sys\fR
-Microsoft Windows driver file, 64bit (x86-64)
-.TP
-\fBbcmwl5a.sys\fR
-Microsoft Windows driver file, 32bit (x86)
-.TP
-\fBmn720-50.sys\fR
-This is a renamed bcmwl5.sys driver for Microsoft Wireless MN-720 Notebook Adapter 
-and MN-730 PCI Adapter 
-.TP
-\fBn54gnds.sys\fR
-This is a renamed bcmwl5.sys driver for Planex GW-NS54G 54Mbps Wireless LAN Cards
-.TP
-\fBwmp11v27.sys\fR
-This is a renamed bcmwl5.sys driver for Linksys WMP-11 802.11b PCI Cards
-.TP
-\fBwn511b.sys\fR
-This is a renamed bcmwl5.sys driver for Netgear WN511B Cards
-.TP
-\fBap_d11ucode.o\fR
-Linux 2.4.x driver file (mips)
-.TP
-\fBapsta_d11ucode.o\fR
-Linux 2.4.x driver file (mips)
-.TP
-\fBsta_d11ucode.o\fR
-Linux 2.4.x driver file (mips)
-.TP
-\fBwl.o\fR
-Linux 2.4.x driver file (mips)
-.TP
-\fBwl_ap.o\fR
-Linux 2.4.x driver file (mips)
-.TP
-\fBwl_apsta.o\fR
-Linux 2.4.x driver file (mips)
-.TP
-\fBwl_sta.o\fR
-Linux 2.4.x driver file (mips)
-.TP
-\fBwl96345GW.o_save\fR
-Linux 2.6.x driver file (mips, bcm6345)
-.TP
-\fBwl96348GW.o_save\fR
-Linux 2.6.x driver file (mips, bcm6348)
-.TP
-\fBwl96348GWV_DT.o_save\fR
-Linux 2.6.x driver file (mips, bcm6348)
-.SH AUTHORS
-BCM43xx development team, http://bcm43xx.berlios.de
+


From larry.finger at lwfinger.net  Fri Aug 10 19:48:13 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 10 Aug 2007 12:48:13 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>	
	<b2d05de20708031000r1599bd93x54e04e24ca4b2be@mail.gmail.com>	
	<46B361CD.8070705@lwfinger.net>	
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>	
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>	
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>	
	<46B914DF.4080101@lwfinger.net>
	<20070808135016.GB7335@tuxdriver.com>	
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>	
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
Message-ID: <46BCA4DD.8020603@lwfinger.net>

John H. wrote:
> Larry, your driver seems to work pretty well, the bcm43xx one,
> however, sometimes I have to reboot to get it working right again(I
> just can't ping anything, etc).
> 
> I was wondering if that file you linked to is updated often?

It gets updated when there is a change in the bcm43xx driver in mainline. Such changes have been 
infrequent of late as developer effort has gone toward getting bcm43xx-mac80211 up to snuff.

It probably needs updating now as there have been some changes in softmac.

Larry


From mistamaila at gmail.com  Fri Aug 10 21:08:08 2007
From: mistamaila at gmail.com (John H.)
Date: Fri, 10 Aug 2007 14:08:08 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net> <20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>
Message-ID: <5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>

I tried that:(

Any chance of your script being out now so I can use the bcm43xx-mac80211?:)

On 8/10/07, Brennan Ashton <comphappy at gmail.com> wrote:
> as root
> modprobe -r bcm43xx
> modprobe bcm43xx
>
> then you dont need to reboot
>
> On 8/10/07, John H. <mistamaila at gmail.com> wrote:
> > Larry, your driver seems to work pretty well, the bcm43xx one,
> > however, sometimes I have to reboot to get it working right again(I
> > just can't ping anything, etc).
> >
> > I was wondering if that file you linked to is updated often?
> >
> > On 8/8/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> > > John H. wrote:
> > > > I am using larry's .bz2 of bcm43xx and I get this ...
> > > >
> > > > wlan0     IEEE 802.11b/g  ESSID:"Network4Home"  Nickname:"Broadcom 4311"
> > > >           Mode:Managed  Frequency=2.437 GHz  Access Point:blah
> > > >           Bit Rate=24 Mb/s   Tx-Power=18 dBm
> > > >           RTS thr:off   Fragment thr:off
> > > >           Link Quality=50/100  Signal level=-69 dBm  Noise level=-71 dBm
> > > >           Rx invalid nwid:0  Rx invalid crypt:11  Rx invalid frag:0
> > > >           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> > > >
> > > >
> > > > Is it possible to get 54mb/s?  Should I care if it's mainly for
> > > > residential cable modem right now?
> > >
> > > To get a setting of 54M, look at 'man iwconfig'. To get throughput at 54M, you need a different
> > > driver, and much better signal to noise! The highest residential cable rates in my area are 8Mbs
> > > down and 512Kbs up. Business rates ate 10 Mbs down and 2 Mbs up, but that costs a lot more. Your 24M
> > > setting should give you something in the range of 12Mbs throughput. You do the math.
> > >
> > > Larry
> > >
> > >
> > _______________________________________________
> > Bcm43xx-dev mailing list
> > Bcm43xx-dev at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
> >
>
>
> --
> Brennan Ashton
> Bellingham, Washington
>
> "The box said, 'Requires Windows 98 or better'. So I installed Linux"
>


From mistamaila at gmail.com  Fri Aug 10 21:08:27 2007
From: mistamaila at gmail.com (John H.)
Date: Fri, 10 Aug 2007 14:08:27 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46BCA4DD.8020603@lwfinger.net>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net> <20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
	<46BCA4DD.8020603@lwfinger.net>
Message-ID: <5b9417770708101208m6067e9eavdc6feccfb5fb131a@mail.gmail.com>

Is it from the same url, or what url to use to get the latest bcm43xx
code with those changes?

On 8/10/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > Larry, your driver seems to work pretty well, the bcm43xx one,
> > however, sometimes I have to reboot to get it working right again(I
> > just can't ping anything, etc).
> >
> > I was wondering if that file you linked to is updated often?
>
> It gets updated when there is a change in the bcm43xx driver in mainline. Such changes have been
> infrequent of late as developer effort has gone toward getting bcm43xx-mac80211 up to snuff.
>
> It probably needs updating now as there have been some changes in softmac.
>
> Larry
>


From johannes at sipsolutions.net  Fri Aug 10 21:13:57 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 10 Aug 2007 21:13:57 +0200
Subject: firmware versions?
In-Reply-To: <46BC9C15.2050606@gmail.com>
References: <1186666972.11717.60.camel@johannes.berg>
	<46BC9C15.2050606@gmail.com>
Message-ID: <1186773237.9771.26.camel@johannes.berg>

On Fri, 2007-08-10 at 12:10 -0500, Jory A. Pratt wrote:

> This is a 4306 mini-pci I picked up for the lappy I will test the 4318 
> later today as well :)

Don't bother. The firmware is loaded from your harddisk and won't be
different :)

And in fact, 351.126 is the recommended one, not sure what I was smoking
when I said 343.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070810/abf95afa/attachment.pgp>

From johannes at sipsolutions.net  Fri Aug 10 21:17:48 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 10 Aug 2007 21:17:48 +0200
Subject: [RFC] Proposed changes to fwcutter
In-Reply-To: <46bca40d.zEv6v3zA35+E39SQ%Larry.Finger@lwfinger.net>
References: <46bca40d.zEv6v3zA35+E39SQ%Larry.Finger@lwfinger.net>
Message-ID: <1186773468.9771.29.camel@johannes.berg>

On Fri, 2007-08-10 at 12:44 -0500, Larry Finger wrote:
> This patch will convert fwcutter to generate firmware files with names
> of bcm43_XXX.fw from V4 driver filess and bcm43legacy_XXX.fw from V3
> driver files. It also changes the fwcutter version from 6 to 7 and
> the name of the utility to bcm43-fwcutter.

Ah, damn. Double-development. Didn't think you'd pick that up this soon.
Sorry for not letting everybody know. I just did the same but used a
directory (bcm43/xx) instead of bcm43_XX. Also, I converted to use real
microcode names instead of the extremely confusing numbering system and
did various other improvements among which updating the partial
disassembler for firmware revision 15. Attached four patches.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 001-rename-b43-fwcutter.patch
Type: text/x-vhdl
Size: 10082 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070810/c0b2182e/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 002-remove-unsupported.patch
Type: text/x-vhdl
Size: 85330 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070810/c0b2182e/attachment-0001.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 003-kill-alternate-ivs.patch
Type: text/x-vhdl
Size: 2695 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070810/c0b2182e/attachment-0002.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 004-new-style-extraction.patch
Type: text/x-vhdl
Size: 51559 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070810/c0b2182e/attachment-0003.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070810/c0b2182e/attachment.pgp>

From mistamaila at gmail.com  Fri Aug 10 21:18:49 2007
From: mistamaila at gmail.com (John H.)
Date: Fri, 10 Aug 2007 14:18:49 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708101208m6067e9eavdc6feccfb5fb131a@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net> <20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
	<46BCA4DD.8020603@lwfinger.net>
	<5b9417770708101208m6067e9eavdc6feccfb5fb131a@mail.gmail.com>
Message-ID: <5b9417770708101218k3fef8fb7ufa9b6704784ef049@mail.gmail.com>

I guess I was asking..

ftp://lwfinger.dynalias.org/patches/bcm43xx-softmac-sa.tar.bz2

Do I just get that again?  It seems like it has not been updated for a
few months, so I would guess not.

I was just wondering if there's a bz2 file with the latest bcm43xx
driver that you'd recommend.

On 8/10/07, John H. <mistamaila at gmail.com> wrote:
> Is it from the same url, or what url to use to get the latest bcm43xx
> code with those changes?
>
> On 8/10/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> > John H. wrote:
> > > Larry, your driver seems to work pretty well, the bcm43xx one,
> > > however, sometimes I have to reboot to get it working right again(I
> > > just can't ping anything, etc).
> > >
> > > I was wondering if that file you linked to is updated often?
> >
> > It gets updated when there is a change in the bcm43xx driver in mainline. Such changes have been
> > infrequent of late as developer effort has gone toward getting bcm43xx-mac80211 up to snuff.
> >
> > It probably needs updating now as there have been some changes in softmac.
> >
> > Larry
> >
>


From comphappy at gmail.com  Fri Aug 10 23:25:33 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Fri, 10 Aug 2007 14:25:33 -0700
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net> <20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>
Message-ID: <b2d05de20708101425w453db4f6k538bedf99b4dde72@mail.gmail.com>

On 8/10/07, John H. <mistamaila at gmail.com> wrote:
> I tried that:(
>
> Any chance of your script being out now so I can use the bcm43xx-mac80211?:)
>
> On 8/10/07, Brennan Ashton <comphappy at gmail.com> wrote:
> > as root
> > modprobe -r bcm43xx
> > modprobe bcm43xx
> >
> > then you dont need to reboot
> >
> > On 8/10/07, John H. <mistamaila at gmail.com> wrote:
> > > Larry, your driver seems to work pretty well, the bcm43xx one,
> > > however, sometimes I have to reboot to get it working right again(I
> > > just can't ping anything, etc).
> > >
> > > I was wondering if that file you linked to is updated often?
> > >
> > > On 8/8/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> > > > John H. wrote:
> > > > > I am using larry's .bz2 of bcm43xx and I get this ...
> > > > >
> > > > > wlan0     IEEE 802.11b/g  ESSID:"Network4Home"  Nickname:"Broadcom 4311"
> > > > >           Mode:Managed  Frequency=2.437 GHz  Access Point:blah
> > > > >           Bit Rate=24 Mb/s   Tx-Power=18 dBm
> > > > >           RTS thr:off   Fragment thr:off
> > > > >           Link Quality=50/100  Signal level=-69 dBm  Noise level=-71 dBm
> > > > >           Rx invalid nwid:0  Rx invalid crypt:11  Rx invalid frag:0
> > > > >           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> > > > >
> > > > >
> > > > > Is it possible to get 54mb/s?  Should I care if it's mainly for
> > > > > residential cable modem right now?
> > > >
> > > > To get a setting of 54M, look at 'man iwconfig'. To get throughput at 54M, you need a different
> > > > driver, and much better signal to noise! The highest residential cable rates in my area are 8Mbs
> > > > down and 512Kbs up. Business rates ate 10 Mbs down and 2 Mbs up, but that costs a lot more. Your 24M
> > > > setting should give you something in the range of 12Mbs throughput. You do the math.
> > > >
> > > > Larry
> > > >
> > > >
> > > _______________________________________________
> > > Bcm43xx-dev mailing list
> > > Bcm43xx-dev at lists.berlios.de
> > > https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
> > >
> >
> >
> > --
> > Brennan Ashton
> > Bellingham, Washington
> >
> > "The box said, 'Requires Windows 98 or better'. So I installed Linux"
> >
>
The script that i was going to write is unnessisary, pull the latest
kernel from Fedoras koji, see Jogn Linville's post. The new patches
have been applied.
http://koji.fedoraproject.org/koji/buildinfo?buildID=13224 for the RPMS
That should work, otherwise pull the new wireless-dev kernel source.

-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From mistamaila at gmail.com  Fri Aug 10 23:36:30 2007
From: mistamaila at gmail.com (John H.)
Date: Fri, 10 Aug 2007 16:36:30 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <b2d05de20708101425w453db4f6k538bedf99b4dde72@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net> <20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>
	<b2d05de20708101425w453db4f6k538bedf99b4dde72@mail.gmail.com>
Message-ID: <5b9417770708101436i1aec52d1id184bb74d8b7a46f@mail.gmail.com>

doesn't that still require compiling another kernel?  That's what we
already discussed.  I was looking for a simple driver to download to
use the fedora kernels but a custom driver, like the bcm43xx i am
currently using from larry.

On 8/10/07, Brennan Ashton <comphappy at gmail.com> wrote:
> On 8/10/07, John H. <mistamaila at gmail.com> wrote:
> > I tried that:(
> >
> > Any chance of your script being out now so I can use the bcm43xx-mac80211?:)
> >
> > On 8/10/07, Brennan Ashton <comphappy at gmail.com> wrote:
> > > as root
> > > modprobe -r bcm43xx
> > > modprobe bcm43xx
> > >
> > > then you dont need to reboot
> > >
> > > On 8/10/07, John H. <mistamaila at gmail.com> wrote:
> > > > Larry, your driver seems to work pretty well, the bcm43xx one,
> > > > however, sometimes I have to reboot to get it working right again(I
> > > > just can't ping anything, etc).
> > > >
> > > > I was wondering if that file you linked to is updated often?
> > > >
> > > > On 8/8/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> > > > > John H. wrote:
> > > > > > I am using larry's .bz2 of bcm43xx and I get this ...
> > > > > >
> > > > > > wlan0     IEEE 802.11b/g  ESSID:"Network4Home"  Nickname:"Broadcom 4311"
> > > > > >           Mode:Managed  Frequency=2.437 GHz  Access Point:blah
> > > > > >           Bit Rate=24 Mb/s   Tx-Power=18 dBm
> > > > > >           RTS thr:off   Fragment thr:off
> > > > > >           Link Quality=50/100  Signal level=-69 dBm  Noise level=-71 dBm
> > > > > >           Rx invalid nwid:0  Rx invalid crypt:11  Rx invalid frag:0
> > > > > >           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> > > > > >
> > > > > >
> > > > > > Is it possible to get 54mb/s?  Should I care if it's mainly for
> > > > > > residential cable modem right now?
> > > > >
> > > > > To get a setting of 54M, look at 'man iwconfig'. To get throughput at 54M, you need a different
> > > > > driver, and much better signal to noise! The highest residential cable rates in my area are 8Mbs
> > > > > down and 512Kbs up. Business rates ate 10 Mbs down and 2 Mbs up, but that costs a lot more. Your 24M
> > > > > setting should give you something in the range of 12Mbs throughput. You do the math.
> > > > >
> > > > > Larry
> > > > >
> > > > >
> > > > _______________________________________________
> > > > Bcm43xx-dev mailing list
> > > > Bcm43xx-dev at lists.berlios.de
> > > > https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
> > > >
> > >
> > >
> > > --
> > > Brennan Ashton
> > > Bellingham, Washington
> > >
> > > "The box said, 'Requires Windows 98 or better'. So I installed Linux"
> > >
> >
> The script that i was going to write is unnessisary, pull the latest
> kernel from Fedoras koji, see Jogn Linville's post. The new patches
> have been applied.
> http://koji.fedoraproject.org/koji/buildinfo?buildID=13224 for the RPMS
> That should work, otherwise pull the new wireless-dev kernel source.
>
> --
> Brennan Ashton
> Bellingham, Washington
>
> "The box said, 'Requires Windows 98 or better'. So I installed Linux"
>


From sandain at hotmail.com  Fri Aug 10 23:42:03 2007
From: sandain at hotmail.com (Jason Wood)
Date: Fri, 10 Aug 2007 15:42:03 -0600
Subject: 4311 not working
Message-ID: <BAY117-F2719A048C74B55F0A39E6FB1E10@phx.gbl>

Sorry to drop this in the devel list..

I've been using this driver for a while now with great success.  Recently 
however, my system stopped recognizing the wireless card intermittently on 
boot.  I have a 4311 running Debian Lenny with the firmware downloaded by 
the bcm43xx-fwcutter package.  I've tried running this on 2.6.22.1 and 
2.6.21.4 kernels that I've compiled with the needed modules checked.  Does 
anybody have any suggestions on what to try next?  I'm beginning to wonder 
if I'm having a hardware issue..

..config:
CONFIG_WLAN_80211=y
CONFIG_BCM43XX=m
CONFIG_BCM43XX_DEBUG=y
CONFIG_BCM43XX_DMA=y
CONFIG_BCM43XX_PIO=y
CONFIG_BCM43XX_DMA_AND_PIO_MODE=y

modprobe bcm43xx
dmesg:
ieee80211_crypt: registered algorithm 'NULL'
ieee80211: 802.11 data/management/control stack, git-1.1.13
ieee80211: Copyright (C) 2004-2005 Intel Corporation 
<jketreno at linux.intel.com>
bcm43xx driver

Thanks in advance,
Jason Wood

_________________________________________________________________
Learn.Laugh.Share. Reallivemoms is right place! 
http://www.reallivemoms.com?ocid=TXT_TAGHM&loc=us



From comphappy at gmail.com  Fri Aug 10 23:47:06 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Fri, 10 Aug 2007 14:47:06 -0700
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708101436i1aec52d1id184bb74d8b7a46f@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net> <20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>
	<b2d05de20708101425w453db4f6k538bedf99b4dde72@mail.gmail.com>
	<5b9417770708101436i1aec52d1id184bb74d8b7a46f@mail.gmail.com>
Message-ID: <b2d05de20708101447i12c03f95j58ae1fcde7ce5aad@mail.gmail.com>

On 8/10/07, John H. <mistamaila at gmail.com> wrote:
> doesn't that still require compiling another kernel?  That's what we
> already discussed.  I was looking for a simple driver to download to
> use the fedora kernels but a custom driver, like the bcm43xx i am
> currently using from larry.
>
no, it is just like any other kernel update from fedora. It has
already been compiled, all you need to do is install the RPM
-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From mb at bu3sch.de  Sat Aug 11 01:01:21 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 11 Aug 2007 01:01:21 +0200
Subject: [PATCH] Huge bcm43xx (b43) patchset
Message-ID: <200708110101.22035.mb@bu3sch.de>

Hi John,

here's a HUGE bcm43xx patchset that updates/fixes
various things and renames bcm43xx to b43. It also
moves and renames all files.

The patch series is not attached to this mail, as it is
_really_ big.

The patches series can be downloaded here:
http://bu3sch.de/patches/wireless-dev/20070811-1186786487/patches/

A tarball containing all these patches is here:
http://bu3sch.de/patches/wireless-dev/20070811-1186786487/mb-wl-20070811-1186786487.tar.bz2

Please apply these patches to the b44 branch of wireless-dev.
(git has a quilt import, so that should be easy.)

Thanks.


From mb at bu3sch.de  Sat Aug 11 01:58:20 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 11 Aug 2007 01:58:20 +0200
Subject: [PATCH] Huge bcm43xx (b43) patchset
In-Reply-To: <200708110101.22035.mb@bu3sch.de>
References: <200708110101.22035.mb@bu3sch.de>
Message-ID: <200708110158.20606.mb@bu3sch.de>

On Saturday 11 August 2007 01:01:21 Michael Buesch wrote:
> Please apply these patches to the b44 branch of wireless-dev.

Of course the b43 branch ;)


-- 
Greetings Michael.


From mb at bu3sch.de  Sat Aug 11 02:03:56 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 11 Aug 2007 02:03:56 +0200
Subject: [patch 2/5] ssb: pci core driver fixes
References: <20070811000354.611868000@bu3sch.de>
Message-ID: <20070811000356.595396000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: ssb-pci-core-driver-fixes.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070811/35e9e3cc/attachment.ksh>

From mb at bu3sch.de  Sat Aug 11 02:03:57 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 11 Aug 2007 02:03:57 +0200
Subject: [patch 3/5] ssb: Read the UART divisor instead of setting it
References: <20070811000354.611868000@bu3sch.de>
Message-ID: <20070811000357.090532000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: ssb-read-the-UART-divisor-instead-of-setting-it.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070811/3f8e866e/attachment.ksh>

From mb at bu3sch.de  Sat Aug 11 02:05:34 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 11 Aug 2007 02:05:34 +0200
Subject: [patch 0/5] ssb: Update to latest ssb code
Message-ID: <200708110205.35258.mb@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070811/85aafef4/attachment.ksh>

From mb at bu3sch.de  Sat Aug 11 02:03:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 11 Aug 2007 02:03:58 +0200
Subject: [patch 4/5] ssb: Fix EXPERIMENTAL annotations
References: <20070811000354.611868000@bu3sch.de>
Message-ID: <20070811000357.633337000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: ssb-fix-experimental-annotations.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070811/312a9555/attachment.ksh>

From mb at bu3sch.de  Sat Aug 11 02:03:59 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 11 Aug 2007 02:03:59 +0200
Subject: [patch 5/5] ssb: Remove verbose coreswitch printk
References: <20070811000354.611868000@bu3sch.de>
Message-ID: <20070811000358.075558000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: ssb-remove-verbose-coreswitch-debugging.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070811/28a06bbc/attachment.ksh>

From mb at bu3sch.de  Sat Aug 11 02:03:55 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 11 Aug 2007 02:03:55 +0200
Subject: [patch 1/5] ssb: pcicore compile fix
References: <20070811000354.611868000@bu3sch.de>
Message-ID: <20070811000355.861811000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: ssb-pcicore-compile.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070811/8c71c710/attachment.ksh>

From larry.finger at lwfinger.net  Sat Aug 11 05:14:28 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 10 Aug 2007 22:14:28 -0500
Subject: [RFC] Proposed changes to fwcutter
In-Reply-To: <1186773468.9771.29.camel@johannes.berg>
References: <46bca40d.zEv6v3zA35+E39SQ%Larry.Finger@lwfinger.net>
	<1186773468.9771.29.camel@johannes.berg>
Message-ID: <46BD2994.8000705@lwfinger.net>

Johannes Berg wrote:
> On Fri, 2007-08-10 at 12:44 -0500, Larry Finger wrote:
>> This patch will convert fwcutter to generate firmware files with names
>> of bcm43_XXX.fw from V4 driver filess and bcm43legacy_XXX.fw from V3
>> driver files. It also changes the fwcutter version from 6 to 7 and
>> the name of the utility to bcm43-fwcutter.
> 
> Ah, damn. Double-development. Didn't think you'd pick that up this soon.
> Sorry for not letting everybody know. I just did the same but used a
> directory (bcm43/xx) instead of bcm43_XX. Also, I converted to use real
> microcode names instead of the extremely confusing numbering system and
> did various other improvements among which updating the partial
> disassembler for firmware revision 15. Attached four patches.

No harm done. I needed firmware for bcm43legacy, and it was a lot more interesting it not easier to 
modify fwcutter than to rename a standard set.

Larry



From larry.finger at lwfinger.net  Sat Aug 11 05:28:45 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 10 Aug 2007 22:28:45 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>	
	<b2d05de20708031024y3999ec68vbbe4dd3e8459c4ad@mail.gmail.com>	
	<5b9417770708031516x3ab141f4maa78ad6a37941ae3@mail.gmail.com>	
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>	
	<46B914DF.4080101@lwfinger.net>
	<20070808135016.GB7335@tuxdriver.com>	
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>	
	<46BA774D.4080506@lwfinger.net>	
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>	
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>
Message-ID: <46BD2CED.3050608@lwfinger.net>

John H. wrote:
> I tried that:(
> 
> Any chance of your script being out now so I can use the bcm43xx-mac80211?:)

Sorry I haven't answered before, but I was out for the day. As you have seen, there is no script. In 
addition, the .bz2 file, although somewhat old, is reasonably current. The most significant change 
is the mainstream bcm43xx code turned out to be a typo in the specs and had to be reverted.

As you learned, you need to get the Rawhide RPM and install it.

Larry


From larry.finger at lwfinger.net  Sat Aug 11 19:04:22 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 11 Aug 2007 12:04:22 -0500
Subject: 4311 not working
In-Reply-To: <BAY117-F2719A048C74B55F0A39E6FB1E10@phx.gbl>
References: <BAY117-F2719A048C74B55F0A39E6FB1E10@phx.gbl>
Message-ID: <46BDEC16.3060208@lwfinger.net>

Jason Wood wrote:
> Sorry to drop this in the devel list..
> 
> I've been using this driver for a while now with great success.  Recently 
> however, my system stopped recognizing the wireless card intermittently on 
> boot.  I have a 4311 running Debian Lenny with the firmware downloaded by 
> the bcm43xx-fwcutter package.  I've tried running this on 2.6.22.1 and 
> 2.6.21.4 kernels that I've compiled with the needed modules checked.  Does 
> anybody have any suggestions on what to try next?  I'm beginning to wonder 
> if I'm having a hardware issue..
> 
> ..config:
> CONFIG_WLAN_80211=y
> CONFIG_BCM43XX=m
> CONFIG_BCM43XX_DEBUG=y
> CONFIG_BCM43XX_DMA=y
> CONFIG_BCM43XX_PIO=y
> CONFIG_BCM43XX_DMA_AND_PIO_MODE=y
> 
> modprobe bcm43xx
> dmesg:
> ieee80211_crypt: registered algorithm 'NULL'
> ieee80211: 802.11 data/management/control stack, git-1.1.13
> ieee80211: Copyright (C) 2004-2005 Intel Corporation 
> <jketreno at linux.intel.com>
> bcm43xx driver

Please send the entire output of dmesg. Perhaps that will show where the problem is.

Larry


From sandain at hotmail.com  Sat Aug 11 23:35:04 2007
From: sandain at hotmail.com (Jason Wood)
Date: Sat, 11 Aug 2007 15:35:04 -0600
Subject: 4311 not working
Message-ID: <BAY117-F2646B9220D9B4197848303B1E20@phx.gbl>

>From: Larry Finger <larry.finger at lwfinger.net>
>Please send the entire output of dmesg. Perhaps that will show where the 
>problem is.
>
>Larry


I've attached 2 files, dmesg.2.6.21.4 after running modprobe bcm43xx, and 
dmesg.2.6.21.4.works where it decided to work.  I get similar results under 
2.6.22.1, when it works the module is loaded automatically, otherwise I get 
nothing.

Thanks,
Jason Wood

_________________________________________________________________
Puzzles, trivia teasers, word scrambles and more. Play for your chance to 
win! http://club.live.com/home.aspx?icid=CLUB_hotmailtextlink
-------------- next part --------------
A non-text attachment was scrubbed...
Name: dmesg.2.6.21.4
Type: application/octet-stream
Size: 30716 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070811/1c8f3a9a/attachment.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: dmesg.2.6.21.4.works
Type: application/octet-stream
Size: 30506 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070811/1c8f3a9a/attachment-0001.obj>

From larry.finger at lwfinger.net  Sun Aug 12 00:22:38 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 11 Aug 2007 17:22:38 -0500
Subject: 4311 not working
In-Reply-To: <BAY117-F2646B9220D9B4197848303B1E20@phx.gbl>
References: <BAY117-F2646B9220D9B4197848303B1E20@phx.gbl>
Message-ID: <46BE36AE.6010108@lwfinger.net>

Jason Wood wrote:
>> From: Larry Finger <larry.finger at lwfinger.net>
>> Please send the entire output of dmesg. Perhaps that will show where 
>> the problem is.
>>
>> Larry
> 
> 
> I've attached 2 files, dmesg.2.6.21.4 after running modprobe bcm43xx, 
> and dmesg.2.6.21.4.works where it decided to work.  I get similar 
> results under 2.6.22.1, when it works the module is loaded 
> automatically, otherwise I get nothing.

Analysis of the two dmesg outputs cannot be completed as your kernel is compiled with a very small 
log buffer and it is wrapping around; however, I see enough to suspect some kind of race condition 
in the bus setup. I see a device with different IRQ's between the good/bad boots. That shouldn't 
happen. I do not think you are having hardware problems, and I'm pretty sure it is not a bcm43xx 
problem.

Is it possible for you to upgrade to a 2.6.22 or 2.6.23-rc2 kernel? If so, please do. Whatever bug 
we are chasing may have already been fixed.

If it is not possible to upgrade, I would like you to add the option 'log_buf_len=262144' when you 
boot. That will increase the size of the log buffer so that we see everything. Then send me the 
dmesg output from a good and a bad boot.

Another thing to try is the boot option 'maxcpus=0'. That will run it as a unit processor system and 
eliminate a lot of potential problems with SMP. I'm particularly interested in knowing if it always 
works with this option, or if it also fails sometimes.

What is the make/model of your laptop? I probably have that info somewhere, but I'm lazy. In 
addition, are your running a 32- or 64-bit system?

Thanks,

Larry



From larry.finger at lwfinger.net  Sun Aug 12 03:14:26 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 11 Aug 2007 20:14:26 -0500
Subject: [RFC] Proposed changes to fwcutter
In-Reply-To: <1186773468.9771.29.camel@johannes.berg>
References: <46bca40d.zEv6v3zA35+E39SQ%Larry.Finger@lwfinger.net>
	<1186773468.9771.29.camel@johannes.berg>
Message-ID: <46BE5EF2.3020100@lwfinger.net>

Johannes Berg wrote:
> On Fri, 2007-08-10 at 12:44 -0500, Larry Finger wrote:
>> This patch will convert fwcutter to generate firmware files with names
>> of bcm43_XXX.fw from V4 driver filess and bcm43legacy_XXX.fw from V3
>> driver files. It also changes the fwcutter version from 6 to 7 and
>> the name of the utility to bcm43-fwcutter.
> 
> Ah, damn. Double-development. Didn't think you'd pick that up this soon.
> Sorry for not letting everybody know. I just did the same but used a
> directory (bcm43/xx) instead of bcm43_XX. Also, I converted to use real
> microcode names instead of the extremely confusing numbering system and
> did various other improvements among which updating the partial
> disassembler for firmware revision 15. Attached four patches.

Could you please give me a table of correspondence between the old and new names? Of course, the 
ucode and pcm correspondences are easy, but what about the initvals?

New Name		Old Name

d11ucodeN		microcodeN
d11pcmN			pcmN
a0g0bsinitvalsN		?
a0g0initvalsN		?
a0g1bsinitvalsN		?
a0g1initvalsN		?
b0g0bsinitvalsN		?
b0g0initvalsN		?

I know that I could look at the new vs old code and get this info, but ...

Thanks,

Larry


From mb at bu3sch.de  Sun Aug 12 20:47:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 12 Aug 2007 20:47:51 +0200
Subject: Port to a common pci bridge
Message-ID: <200708122047.52133.mb@bu3sch.de>

Here are some patches that port the pci bridge
code of b43 to ssb. So with these patches it is
possible to run b43 and your yet-to-be-ported
b43legacy in parallel. The bridge code in ssb
would always probe the correct driver.

http://bu3sch.de/patches/wireless-dev/20070812-1186943700/

You have to do something like the following in
b43legacy, too:
http://bu3sch.de/patches/wireless-dev/20070812-1186943700/patches/b43-remove-pci-bridge-code.patch

As you can see that completely removes any PCI probing code
from the driver, so it's a real SSB driver only.
But it also extends the ssb ID table to carry the exact
supported revision IDs of the 802.11 core.
You would add revs <5 there. I think it's 2 and 4. Maybe
something else, too.

There are also other patches, that apply to b43legacy, as well:

http://bu3sch.de/patches/wireless-dev/20070812-1186943700/patches/b43-fix-bus-powerup.patch
That fixes a crash under rare conditions.

http://bu3sch.de/patches/wireless-dev/20070812-1186943700/patches/b43-must-check-status-in-config-interface.patch
That fixes an illegal access to the device while shutdown.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sun Aug 12 22:39:08 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 12 Aug 2007 15:39:08 -0500
Subject: Port to a common pci bridge
In-Reply-To: <200708122047.52133.mb@bu3sch.de>
References: <200708122047.52133.mb@bu3sch.de>
Message-ID: <46BF6FEC.9070909@lwfinger.net>

Michael Buesch wrote:
> Here are some patches that port the pci bridge
> code of b43 to ssb. So with these patches it is
> possible to run b43 and your yet-to-be-ported
> b43legacy in parallel. The bridge code in ssb
> would always probe the correct driver.

Thanks for this code and the fixes for main. From the patches, I gather that you are naming the 
files in the b32 directory as main, phy, dma, etc. Should I do the same in b43legacy?

I'm operating with the bridge code with only one problem - the modules do not autoload. Once I 
modprobe b43legacy, all is well. Any suggestions?

Larry



From mb at bu3sch.de  Sun Aug 12 22:45:32 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 12 Aug 2007 22:45:32 +0200
Subject: Port to a common pci bridge
In-Reply-To: <46BF6FEC.9070909@lwfinger.net>
References: <200708122047.52133.mb@bu3sch.de> <46BF6FEC.9070909@lwfinger.net>
Message-ID: <200708122245.32695.mb@bu3sch.de>

On Sunday 12 August 2007 22:39:08 Larry Finger wrote:
> Michael Buesch wrote:
> > Here are some patches that port the pci bridge
> > code of b43 to ssb. So with these patches it is
> > possible to run b43 and your yet-to-be-ported
> > b43legacy in parallel. The bridge code in ssb
> > would always probe the correct driver.
> 
> Thanks for this code and the fixes for main. From the patches, I gather that you are naming the 
> files in the b32 directory as main, phy, dma, etc. Should I do the same in b43legacy?

The prefix is redundant. So, if you want, you can remove it.
You'd have to rename them anyway, so you could as well remove it.
The prefix removing was on my TODO since.. well.. ever? :)

> I'm operating with the bridge code with only one problem - the modules do not autoload. Once I 
> modprobe b43legacy, all is well. Any suggestions?

Do you have applied the required ssb patches?
http://bu3sch.de/patches/wireless-dev/20070812-1186950057/patches/ssb-uevent.patch
http://bu3sch.de/patches/wireless-dev/20070812-1186950057/patches/ssb-modalias.patch
And do you have a MODULE_DEVICE_TABLE(ssb, footable)
in the b43legacy module?

I suggest you first apply the whole patch series from here
http://bu3sch.de/patches/wireless-dev/20070812-1186950057/
and make your patches on top of this.
(Note that the URL above is different from the one in my
last mail. A ssb and b44 fix was added).

The patch series applies to wireless-dev branch "everything".

Have fun.

-- 
Greetings Michael.


From proski at gnu.org  Mon Aug 13 00:15:07 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sun, 12 Aug 2007 18:15:07 -0400
Subject: An idea about Kconfig issue
Message-ID: <20070812181507.47lqj6j46c4444gc@webmailbeta.spamcop.net>

Hello!

[I'm sorry I'm on vacation on a very slow connection, so I may not be  
able to reply soon, but I'll post anyway]

I think we could rename CONFIG_SSB to CONFIG_BROADCOM_SSB.  This way,  
everybody running "make oldconfig" will be asked whether to enable  
this option.  The help text could explain which devices need it.

I believe it's at least as good as the hacks that have been suggested so far.

-- 
Regards,
Pavel Roskin


From solca at guug.org  Mon Aug 13 03:51:58 2007
From: solca at guug.org (Otto Solares)
Date: Sun, 12 Aug 2007 19:51:58 -0600
Subject: Port to a common pci bridge
In-Reply-To: <200708122047.52133.mb@bu3sch.de>
References: <200708122047.52133.mb@bu3sch.de>
Message-ID: <20070813015158.GA6481@guug.org>

On Sun, Aug 12, 2007 at 08:47:51PM +0200, Michael Buesch wrote:
> Here are some patches that port the pci bridge
> code of b43 to ssb. So with these patches it is
> possible to run b43 and your yet-to-be-ported
> b43legacy in parallel. The bridge code in ssb
> would always probe the correct driver.

Hi!

Is the BCM4306 a b43 or b43legacy device?, I'm asking for
the WRT54GL which uses the SB bus.  Thanks!

-otto


From larry.finger at lwfinger.net  Mon Aug 13 04:29:33 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 12 Aug 2007 21:29:33 -0500
Subject: Port to a common pci bridge
In-Reply-To: <20070813015158.GA6481@guug.org>
References: <200708122047.52133.mb@bu3sch.de> <20070813015158.GA6481@guug.org>
Message-ID: <46BFC20D.9040202@lwfinger.net>

Otto Solares wrote:
> On Sun, Aug 12, 2007 at 08:47:51PM +0200, Michael Buesch wrote:
>> Here are some patches that port the pci bridge
>> code of b43 to ssb. So with these patches it is
>> possible to run b43 and your yet-to-be-ported
>> b43legacy in parallel. The bridge code in ssb
>> would always probe the correct driver.
> 
> Hi!
> 
> Is the BCM4306 a b43 or b43legacy device?, I'm asking for
> the WRT54GL which uses the SB bus.  Thanks!

Yes ;-). It depends on the revision. The BCM4306/2 has a PHY revision of 1 and an 802.11 core 
revision of 4 - it uses b43legacy. The newer BCM4306's use b43. The distinction is dependent on 
support in Broadcom V4 firmware.

Larry


From Larry.Finger at lwfinger.net  Mon Aug 13 05:10:23 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 12 Aug 2007 22:10:23 -0500
Subject: Curious output from sprom contents
Message-ID: <46BFCB9F.10506@lwfinger.net>

Michael,

I have been messing a little with ssb-sprom since your quick tutorial, and I've found something
interesting. When I do a -P dump, the following results:

SPROM(0x04, Subsytem product ID) = 0x1363
SPROM(0x06, Subsystem vendor ID) = 0x103C
SPROM(0x08, PCI Product ID) = 0x0008
SPROM(0x38, High 16 bits of Boardflags) = 0x0000
SPROM(0x72, Low 16 bits of Boardflags) = 0x4A49
SPROM(0x48, MAC address for 802.11b/g) = 00:1a:73:04:1d:e5
SPROM(0x4E, MAC address for ethernet) = ff:ff:ff:ff:ff:ff
SPROM(0x54, MAC address for 802.11a) = ff:ff:ff:ff:ff:ff
SPROM(0x5A, Ethernet phy settings (0)) = 0x1F
SPROM(0x5A, Ethernet phy settings (1)) = 0x1F
SPROM(0x5B, et0mdcport) = ON
SPROM(0x5B, et1mdcport) = ON
SPROM(0x5C, Board revision) = 0x39
SPROM(0x5D, Locale / Country Code) = 0x0
SPROM(0x5D, A PHY antenna 0 available) = ON
SPROM(0x5D, A PHY antenna 1 available) = ON
SPROM(0x5D, B/G PHY antenna 0 available) = OFF
SPROM(0x5D, B/G PHY antenna 1 available) = OFF
SPROM(0x74, A PHY antenna gain) = 0x02
SPROM(0x75, B/G PHY antenna gain) = 0xFF
SPROM(0x5E, pa0b0) = 0x153D
SPROM(0x60, pa0b1) = 0xFAA0
SPROM(0x62, pa0b2) = 0xFE79
SPROM(0x6A, pa1b0) = 0xFFFF
SPROM(0x6C, pa1b1) = 0xFFFF
SPROM(0x6E, pa1b2) = 0xFFFF
SPROM(0x64, LED 0 behaviour) = 0xFF
SPROM(0x65, LED 1 behaviour) = 0x83
SPROM(0x66, LED 2 behaviour) = 0xFF
SPROM(0x67, LED 3 behaviour) = 0xFF
SPROM(0x68, A PHY max powerout) = 0x4A
SPROM(0x69, B/G PHY max powerout) = 0xFF
SPROM(0x70, A PHY idle TSSI target) = 0x3E
SPROM(0x71, B/G PHY idle TSSI target) = 0xFF
SPROM(0x7E, SPROM version) = 0x02

The curious part is that the A PHY values are all set, but the B/G PHY values have not been, even 
though this is a B/G-only device. I had been surprised earlier that the antenna gain was not set, 
which is why I submitted the patch to supply the default values if the sprom had the unprogrammed value.

Is this an endian problem? It certainly looks as if the A vs B/G definitions are reversed except for 
MAC addresses.

Thanks,

Larry



From solca at guug.org  Mon Aug 13 06:24:48 2007
From: solca at guug.org (Otto Solares)
Date: Sun, 12 Aug 2007 22:24:48 -0600
Subject: Port to a common pci bridge
In-Reply-To: <46BFC20D.9040202@lwfinger.net>
References: <200708122047.52133.mb@bu3sch.de> <20070813015158.GA6481@guug.org>
	<46BFC20D.9040202@lwfinger.net>
Message-ID: <20070813042448.GB6481@guug.org>

On Sun, Aug 12, 2007 at 09:29:33PM -0500, Larry Finger wrote:
> Otto Solares wrote:
> >On Sun, Aug 12, 2007 at 08:47:51PM +0200, Michael Buesch wrote:
> >>Here are some patches that port the pci bridge
> >>code of b43 to ssb. So with these patches it is
> >>possible to run b43 and your yet-to-be-ported
> >>b43legacy in parallel. The bridge code in ssb
> >>would always probe the correct driver.
> >
> >Hi!
> >
> >Is the BCM4306 a b43 or b43legacy device?, I'm asking for
> >the WRT54GL which uses the SB bus.  Thanks!
> 
> Yes ;-). It depends on the revision. The BCM4306/2 has a PHY revision of 1 
> and an 802.11 core revision of 4 - it uses b43legacy. The newer BCM4306's 
> use b43. The distinction is dependent on support in Broadcom V4 firmware.

Hi!

How can I tell the revision number in the WRT54GL?

OpenWRT uses the propietary driver version 4.80.53.0, is that
a v4 firmware?  which b43 driver should I test (b43|b43legacy)?

-otto


From larry.finger at lwfinger.net  Mon Aug 13 07:11:07 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 13 Aug 2007 00:11:07 -0500
Subject: Port to a common pci bridge
In-Reply-To: <20070813042448.GB6481@guug.org>
References: <200708122047.52133.mb@bu3sch.de> <20070813015158.GA6481@guug.org>
	<46BFC20D.9040202@lwfinger.net> <20070813042448.GB6481@guug.org>
Message-ID: <46BFE7EB.4040706@lwfinger.net>

Otto Solares wrote:
> On Sun, Aug 12, 2007 at 09:29:33PM -0500, Larry Finger wrote:
>> Otto Solares wrote:
>>> On Sun, Aug 12, 2007 at 08:47:51PM +0200, Michael Buesch wrote:
>>>> Here are some patches that port the pci bridge
>>>> code of b43 to ssb. So with these patches it is
>>>> possible to run b43 and your yet-to-be-ported
>>>> b43legacy in parallel. The bridge code in ssb
>>>> would always probe the correct driver.
>>> Hi!
>>>
>>> Is the BCM4306 a b43 or b43legacy device?, I'm asking for
>>> the WRT54GL which uses the SB bus.  Thanks!
>> Yes ;-). It depends on the revision. The BCM4306/2 has a PHY revision of 1 
>> and an 802.11 core revision of 4 - it uses b43legacy. The newer BCM4306's 
>> use b43. The distinction is dependent on support in Broadcom V4 firmware.
> 
> Hi!
> 
> How can I tell the revision number in the WRT54GL?
> 
> OpenWRT uses the propietary driver version 4.80.53.0, is that
> a v4 firmware?  which b43 driver should I test (b43|b43legacy)?

The lead digit indicates that it is a V4 driver. You should use b43. The other way to tell would be 
from the logs, if there are any in OpenWRT. The key is in the details of the 802.11 core, which 
looks like "ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0A, vendor 0x4243)". If the rev is < 5, 
the device must use b43legacy.

Larry


Larry



From solca at guug.org  Mon Aug 13 07:29:29 2007
From: solca at guug.org (Otto Solares)
Date: Sun, 12 Aug 2007 23:29:29 -0600
Subject: Port to a common pci bridge
In-Reply-To: <46BFE7EB.4040706@lwfinger.net>
References: <200708122047.52133.mb@bu3sch.de> <20070813015158.GA6481@guug.org>
	<46BFC20D.9040202@lwfinger.net> <20070813042448.GB6481@guug.org>
	<46BFE7EB.4040706@lwfinger.net>
Message-ID: <20070813052929.GC6481@guug.org>

On Mon, Aug 13, 2007 at 12:11:07AM -0500, Larry Finger wrote:
> Otto Solares wrote:
> >On Sun, Aug 12, 2007 at 09:29:33PM -0500, Larry Finger wrote:
> >>Otto Solares wrote:
> >>>On Sun, Aug 12, 2007 at 08:47:51PM +0200, Michael Buesch wrote:
> >>>>Here are some patches that port the pci bridge
> >>>>code of b43 to ssb. So with these patches it is
> >>>>possible to run b43 and your yet-to-be-ported
> >>>>b43legacy in parallel. The bridge code in ssb
> >>>>would always probe the correct driver.
> >>>Hi!
> >>>
> >>>Is the BCM4306 a b43 or b43legacy device?, I'm asking for
> >>>the WRT54GL which uses the SB bus.  Thanks!
> >>Yes ;-). It depends on the revision. The BCM4306/2 has a PHY revision of 
> >>1 and an 802.11 core revision of 4 - it uses b43legacy. The newer 
> >>BCM4306's use b43. The distinction is dependent on support in Broadcom V4 
> >>firmware.
> >
> >Hi!
> >
> >How can I tell the revision number in the WRT54GL?
> >
> >OpenWRT uses the propietary driver version 4.80.53.0, is that
> >a v4 firmware?  which b43 driver should I test (b43|b43legacy)?
> 
> The lead digit indicates that it is a V4 driver. You should use b43. The 
> other way to tell would be from the logs, if there are any in OpenWRT. The 
> key is in the details of the 802.11 core, which looks like "ssb: Core 1 
> found: IEEE 802.11 (cc 0x812, rev 0x0A, vendor 0x4243)". If the rev is < 5, 
> the device must use b43legacy.

Ok, I run 'wl revinfo' in the WRT so I assume this is a rev 9 device
and must use the b43 driver? please correct me if I'm wrong:

root at wifi:~# wl revinfo
vendorid 0x14e4
deviceid 0x4320
radiorev 0x22050000
chipnum 0x5352
chiprev 0x0
corerev 0x9
boardid 0x467
boardvendor 0x14e4
boardrev 0x10
driverrev 0x4503500
ucoderev 0x15f007e
bus 0x0

-otto


From johannes at sipsolutions.net  Mon Aug 13 08:16:33 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 13 Aug 2007 08:16:33 +0200
Subject: turning off probe responses in bcm43xx
Message-ID: <1186985793.27916.3.camel@johannes.berg>

Hey,

After a bit of digging I figured out how it is possible to turn off
probe responses: the SHM contains BCM43xx_SHM_SH_PRMAXTIME which is, in
microseconds, the time after which probe requests are no longer answered
by the firmware. That is initialized to zero at card startup like the
whole memory and zero means infinite, but setting it to one microsecond
causes the firmware to stop responding to probe requests because they
all just time out---it doesn't have a chance to respond in one
microsecond because it's not fast enough.

Of course we aren't transmitting probe responses right now either due to
the PHY errors, but first having the firmware generate PHY errors and
then ignoring them doesn't seem such a hot idea.

With my driver patched to write 1 to BCM43xx_SHM_SH_PRMAXTIME during
core initialisation I no longer get PHY errors when running in master
mode.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/395972c7/attachment.pgp>

From johannes at sipsolutions.net  Mon Aug 13 08:35:33 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 13 Aug 2007 08:35:33 +0200
Subject: reading the tx_status file can hang system
Message-ID: <1186986933.27916.28.camel@johannes.berg>

Larry, I'm not sure if this bug applies to the b43legacy driver. If not,
please ignore.

If you read the tx_status file when you haven't sent any packets yet,
the system will hang because the driver disables interrupts and then
loops indefinitely due to the ring list handling going wrong.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/e32e242c/attachment.pgp>

From johannes at sipsolutions.net  Mon Aug 13 13:38:05 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 13 Aug 2007 13:38:05 +0200
Subject: turning off probe responses in bcm43xx
In-Reply-To: <1186985793.27916.3.camel@johannes.berg>
References: <1186985793.27916.3.camel@johannes.berg>
Message-ID: <1187005085.27916.99.camel@johannes.berg>

On Mon, 2007-08-13 at 08:16 +0200, Johannes Berg wrote:

> With my driver patched to write 1 to BCM43xx_SHM_SH_PRMAXTIME during
> core initialisation I no longer get PHY errors when running in master
> mode.

Wanted to attach it
http://johannes.sipsolutions.net/patches/kernel/all/2007-08-13-11:37/032-bcm43xx-disable-proberesp.patch

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/79758005/attachment.pgp>

From mb at bu3sch.de  Mon Aug 13 13:35:44 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 13 Aug 2007 13:35:44 +0200
Subject: Curious output from sprom contents
In-Reply-To: <46BFCB9F.10506@lwfinger.net>
References: <46BFCB9F.10506@lwfinger.net>
Message-ID: <200708131335.44469.mb@bu3sch.de>

On Monday 13 August 2007 05:10:23 Larry Finger wrote:
> The curious part is that the A PHY values are all set, but the B/G PHY values have not been, even 
> though this is a B/G-only device. I had been surprised earlier that the antenna gain was not set, 
> which is why I submitted the patch to supply the default values if the sprom had the unprogrammed value.

That's a bug in the specs. I already fixed it in ssb, but
not in the ssb-sprom tool.


-- 
Greetings Michael.


From mb at bu3sch.de  Mon Aug 13 13:36:26 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 13 Aug 2007 13:36:26 +0200
Subject: Port to a common pci bridge
In-Reply-To: <20070813042448.GB6481@guug.org>
References: <200708122047.52133.mb@bu3sch.de> <46BFC20D.9040202@lwfinger.net>
	<20070813042448.GB6481@guug.org>
Message-ID: <200708131336.26978.mb@bu3sch.de>

On Monday 13 August 2007 06:24:48 Otto Solares wrote:
> On Sun, Aug 12, 2007 at 09:29:33PM -0500, Larry Finger wrote:
> > Otto Solares wrote:
> > >On Sun, Aug 12, 2007 at 08:47:51PM +0200, Michael Buesch wrote:
> > >>Here are some patches that port the pci bridge
> > >>code of b43 to ssb. So with these patches it is
> > >>possible to run b43 and your yet-to-be-ported
> > >>b43legacy in parallel. The bridge code in ssb
> > >>would always probe the correct driver.
> > >
> > >Hi!
> > >
> > >Is the BCM4306 a b43 or b43legacy device?, I'm asking for
> > >the WRT54GL which uses the SB bus.  Thanks!
> > 
> > Yes ;-). It depends on the revision. The BCM4306/2 has a PHY revision of 1 
> > and an 802.11 core revision of 4 - it uses b43legacy. The newer BCM4306's 
> > use b43. The distinction is dependent on support in Broadcom V4 firmware.
> 
> Hi!
> 
> How can I tell the revision number in the WRT54GL?
> 
> OpenWRT uses the propietary driver version 4.80.53.0, is that
> a v4 firmware?  which b43 driver should I test (b43|b43legacy)?

Your device is almost certainly a >=rev5 core. So b43 applies.

-- 
Greetings Michael.


From johannes at sipsolutions.net  Mon Aug 13 13:55:24 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 13 Aug 2007 13:55:24 +0200
Subject: Port to a common pci bridge
In-Reply-To: <200708122047.52133.mb@bu3sch.de>
References: <200708122047.52133.mb@bu3sch.de>
Message-ID: <1187006124.27916.101.camel@johannes.berg>

On Sun, 2007-08-12 at 20:47 +0200, Michael Buesch wrote:
> Here are some patches that port the pci bridge
> code of b43 to ssb. So with these patches it is
> possible to run b43 and your yet-to-be-ported
> b43legacy in parallel. The bridge code in ssb
> would always probe the correct driver.
> 
> http://bu3sch.de/patches/wireless-dev/20070812-1186943700/

you need the attached script ;)

johannes
-------------- next part --------------
#!/bin/dash

digits=auto
mindigits=3

if [ "$digits" = "auto" ] ; then
  num=$(quilt series | wc -l)
  digits=$(expr length "$num")
fi

if [ $digits -le $mindigits ] ; then
  digits=$mindigits
fi

quilt series | (
num=0
while read pname ; do
num=$(expr $num + 1)
bpname=$(echo "$pname" | sed 's/^[0-9]\+-\(.*\)/\1/')
if [ $digits = 0 ] ; then
  npname="$bpname"
else
  npname="$(printf "%.${digits}d-%s" $num "$bpname")"
fi
if [ "$pname" != "$npname" ] ; then
  quilt rename -P "$pname" "$npname"
fi
done
)
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/99a7c68a/attachment.pgp>

From mb at bu3sch.de  Mon Aug 13 14:05:35 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 13 Aug 2007 14:05:35 +0200
Subject: Port to a common pci bridge
In-Reply-To: <1187006124.27916.101.camel@johannes.berg>
References: <200708122047.52133.mb@bu3sch.de>
	<1187006124.27916.101.camel@johannes.berg>
Message-ID: <200708131405.36048.mb@bu3sch.de>

On Monday 13 August 2007 13:55:24 Johannes Berg wrote:
> On Sun, 2007-08-12 at 20:47 +0200, Michael Buesch wrote:
> > Here are some patches that port the pci bridge
> > code of b43 to ssb. So with these patches it is
> > possible to run b43 and your yet-to-be-ported
> > b43legacy in parallel. The bridge code in ssb
> > would always probe the correct driver.
> > 
> > http://bu3sch.de/patches/wireless-dev/20070812-1186943700/
> 
> you need the attached script ;)

You are just too lazy to read the series file :P

-- 
Greetings Michael.


From johannes at sipsolutions.net  Mon Aug 13 14:23:47 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 13 Aug 2007 14:23:47 +0200
Subject: Port to a common pci bridge
In-Reply-To: <200708131405.36048.mb@bu3sch.de>
References: <200708122047.52133.mb@bu3sch.de>
	<1187006124.27916.101.camel@johannes.berg>
	<200708131405.36048.mb@bu3sch.de>
Message-ID: <1187007827.27916.105.camel@johannes.berg>

On Mon, 2007-08-13 at 14:05 +0200, Michael Buesch wrote:
> On Monday 13 August 2007 13:55:24 Johannes Berg wrote:
> > On Sun, 2007-08-12 at 20:47 +0200, Michael Buesch wrote:
> > > Here are some patches that port the pci bridge
> > > code of b43 to ssb. So with these patches it is
> > > possible to run b43 and your yet-to-be-ported
> > > b43legacy in parallel. The bridge code in ssb
> > > would always probe the correct driver.
> > > 
> > > http://bu3sch.de/patches/wireless-dev/20070812-1186943700/
> > 
> > you need the attached script ;)
> 
> You are just too lazy to read the series file :P

I know :)

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/07481b73/attachment.pgp>

From mb at bu3sch.de  Mon Aug 13 16:10:10 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 13 Aug 2007 16:10:10 +0200
Subject: New patches for b43legacy
Message-ID: <200708131610.10899.mb@bu3sch.de>

The following patches for b43 apply to b43legacy as well.

http://bu3sch.de/patches/wireless-dev/20070813-1187014012/patches/024-b43-suppress-fw-probe-responses.patch
http://bu3sch.de/patches/wireless-dev/20070813-1187014012/patches/025-b43-debugfs-fix-tx-status-crash.patch
http://bu3sch.de/patches/wireless-dev/20070813-1187014012/patches/026-b43-keep-retry-count-above-zero.patch

-- 
Greetings Michael.


From sandain at hotmail.com  Mon Aug 13 17:25:56 2007
From: sandain at hotmail.com (Jason Wood)
Date: Mon, 13 Aug 2007 09:25:56 -0600
Subject: 4311 not working
Message-ID: <BAY117-F122398D5A1A37CC03463A1B1DC0@phx.gbl>

>From: Larry Finger <larry.finger at lwfinger.net>
>
>Analysis of the two dmesg outputs cannot be completed as your kernel is 
>compiled with a very small log buffer and it is wrapping around; however, I 
>see enough to suspect some kind of race condition in the bus setup. I see a 
>device with different IRQ's between the good/bad boots. That shouldn't 
>happen. I do not think you are having hardware problems, and I'm pretty 
>sure it is not a bcm43xx problem.
>
>Is it possible for you to upgrade to a 2.6.22 or 2.6.23-rc2 kernel? If so, 
>please do. Whatever bug we are chasing may have already been fixed.
>
>If it is not possible to upgrade, I would like you to add the option 
>'log_buf_len=262144' when you boot. That will increase the size of the log 
>buffer so that we see everything. Then send me the dmesg output from a good 
>and a bad boot.
>
>Another thing to try is the boot option 'maxcpus=0'. That will run it as a 
>unit processor system and eliminate a lot of potential problems with SMP. 
>I'm particularly interested in knowing if it always works with this option, 
>or if it also fails sometimes.
>
>What is the make/model of your laptop? I probably have that info somewhere, 
>but I'm lazy. In addition, are your running a 32- or 64-bit system?
>
>Thanks,
>
>Larry
>

I'm using a HP Pavilion dv6000.  I'm currently trying to solve a separate 
issue that leads me to believe this may be a bios or hardware issue.  I 
intermittently get bios beep codes for the video on startup, forcing a power 
cycle.  And of course HP support is unwilling to work with me because of my 
OS choice.

Anyway, I have working and non-working dmesg output attached with the 
increased buffer limit set for kernel 2.6.22.1.  I also attempted booting 
with 'maxcpus=0' set, however the system hard locked at random points each 
time.  Line 278 of the dmesg.2.6.22.1.works file is where the device first 
gets detected (0000:03:00.0), and does not show up in the failed boot dmesg. 
  With this kernel, I'm having some SELinux errors I believe, but I don't 
think it affects the bcm43xx module.

I plan on trying to create a live Windows cd so that I can flash the bios to 
the latest version since Wine won't run the software.  Hopefully the new 
bios will fix both problems.

Jason Wood

_________________________________________________________________
More photos, more messages, more storage?get 2GB with Windows Live Hotmail. 
http://imagine-windowslive.com/hotmail/?locale=en-us&ocid=TXT_TAGHM_migration_HM_mini_2G_0507
-------------- next part --------------
A non-text attachment was scrubbed...
Name: dmesg.2.6.22.1
Type: application/octet-stream
Size: 67419 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/24cb6345/attachment.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: dmesg.2.6.22.1.works
Type: application/octet-stream
Size: 60404 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/24cb6345/attachment-0001.obj>

From larry.finger at lwfinger.net  Mon Aug 13 17:35:53 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 13 Aug 2007 10:35:53 -0500
Subject: 4311 not working
In-Reply-To: <BAY117-F122398D5A1A37CC03463A1B1DC0@phx.gbl>
References: <BAY117-F122398D5A1A37CC03463A1B1DC0@phx.gbl>
Message-ID: <46C07A59.2020909@lwfinger.net>

Jason Wood wrote:
> I plan on trying to create a live Windows cd so that I can flash the 
> bios to the latest version since Wine won't run the software.  Hopefully 
> the new bios will fix both problems.

Thanks for the data. I'll analyze it later.

Check for a CD called Bart's PE. (http://www.nu2.nu/pebuilder/). With your BIOS update code on a 
flash drive, you should be able to run it that way.

Larry


From mistamaila at gmail.com  Mon Aug 13 22:11:16 2007
From: mistamaila at gmail.com (John H.)
Date: Mon, 13 Aug 2007 15:11:16 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46BD2CED.3050608@lwfinger.net>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net> <20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>
	<46BD2CED.3050608@lwfinger.net>
Message-ID: <5b9417770708131311n7b1ab9a3k72218c6b24f85e14@mail.gmail.com>

I upgraded as brennan requested, but iwconfig still lists bit rate as 1 mb/s:(

On 8/10/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > I tried that:(
> >
> > Any chance of your script being out now so I can use the bcm43xx-mac80211?:)
>
> Sorry I haven't answered before, but I was out for the day. As you have seen, there is no script. In
> addition, the .bz2 file, although somewhat old, is reasonably current. The most significant change
> is the mainstream bcm43xx code turned out to be a typo in the specs and had to be reverted.
>
> As you learned, you need to get the Rawhide RPM and install it.
>
> Larry
>


From mistamaila at gmail.com  Mon Aug 13 22:19:31 2007
From: mistamaila at gmail.com (John H.)
Date: Mon, 13 Aug 2007 15:19:31 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708131311n7b1ab9a3k72218c6b24f85e14@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<46B914DF.4080101@lwfinger.net> <20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>
	<46BD2CED.3050608@lwfinger.net>
	<5b9417770708131311n7b1ab9a3k72218c6b24f85e14@mail.gmail.com>
Message-ID: <5b9417770708131319v6dd96756ob14ab21f4a7b1663@mail.gmail.com>

oh wait, the bitrate seems to fluctuate.  but a download of a file is
working like the other bcm43xx driver.

thanks

On 8/13/07, John H. <mistamaila at gmail.com> wrote:
> I upgraded as brennan requested, but iwconfig still lists bit rate as 1 mb/s:(
>
> On 8/10/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> > John H. wrote:
> > > I tried that:(
> > >
> > > Any chance of your script being out now so I can use the bcm43xx-mac80211?:)
> >
> > Sorry I haven't answered before, but I was out for the day. As you have seen, there is no script. In
> > addition, the .bz2 file, although somewhat old, is reasonably current. The most significant change
> > is the mainstream bcm43xx code turned out to be a typo in the specs and had to be reverted.
> >
> > As you learned, you need to get the Rawhide RPM and install it.
> >
> > Larry
> >
>


From martin-langer at gmx.de  Mon Aug 13 22:26:38 2007
From: martin-langer at gmx.de (Martin Langer)
Date: Mon, 13 Aug 2007 22:26:38 +0200
Subject: [RFC] Proposed changes to fwcutter
In-Reply-To: <46BE5EF2.3020100@lwfinger.net>
References: <46bca40d.zEv6v3zA35+E39SQ%Larry.Finger@lwfinger.net>
	<1186773468.9771.29.camel@johannes.berg>
	<46BE5EF2.3020100@lwfinger.net>
Message-ID: <20070813202638.GA3547@tuba>

On Sat, Aug 11, 2007 at 08:14:26PM -0500, Larry Finger wrote:

> Could you please give me a table of correspondence between the old and new names? Of course, the 
> ucode and pcm correspondences are easy, but what about the initvals?
> 
> New Name		Old Name
> 
> d11ucodeN		microcodeN
> d11pcmN			pcmN

I thought d11 means dot 11. But do we have any different firmware than 
802 dot 11 stuff. I guess ucodeN and pcmN should be fine as names.

> a0g0bsinitvalsN		?
> a0g0initvalsN		?
> a0g1bsinitvalsN		?
> a0g1initvalsN		?
> b0g0bsinitvalsN		?
> b0g0initvalsN		?

Hmm, it sounds as cryptic as before. But I'm not living in the re 
world ;)

Martin


From ddevore at duckhouse.us  Mon Aug 13 23:00:50 2007
From: ddevore at duckhouse.us (Dru Devore)
Date: Mon, 13 Aug 2007 14:00:50 -0700
Subject: Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card rev 02
Message-ID: <20070813140050.d93209e2c756a6ecfa0dc94b7784bf13.593c2acb43.wbe@email.secureserver.net>

An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/dc973957/attachment.html>

From larry.finger at lwfinger.net  Mon Aug 13 23:16:49 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 13 Aug 2007 16:16:49 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708131311n7b1ab9a3k72218c6b24f85e14@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>	
	<5b9417770708071714j70d906d5t88f30be69593105f@mail.gmail.com>	
	<46B914DF.4080101@lwfinger.net>
	<20070808135016.GB7335@tuxdriver.com>	
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>	
	<46BA774D.4080506@lwfinger.net>	
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>	
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>	
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>	
	<46BD2CED.3050608@lwfinger.net>
	<5b9417770708131311n7b1ab9a3k72218c6b24f85e14@mail.gmail.com>
Message-ID: <46C0CA41.1040806@lwfinger.net>

John H. wrote:
> I upgraded as brennan requested, but iwconfig still lists bit rate as 1 mb/s:(
If you are running bcm43xx-mac80211 from the Rawhide kernel, it will auto-scale the rate as best it 
can. Do you have interference?

Larry





From larry.finger at lwfinger.net  Mon Aug 13 23:20:27 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 13 Aug 2007 16:20:27 -0500
Subject: Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card rev 02
In-Reply-To: <20070813140050.d93209e2c756a6ecfa0dc94b7784bf13.593c2acb43.wbe@email.secureserver.net>
References: <20070813140050.d93209e2c756a6ecfa0dc94b7784bf13.593c2acb43.wbe@email.secureserver.net>
Message-ID: <46C0CB1B.8020004@lwfinger.net>

Dru Devore wrote:
> 
> I know this may not be the proper place for this request but the support 
> forum is timing out.
> 
> I have a new laptop with the Broadcom Corporation Dell Wireless 1390 
> WLAN Mini-PCI Card rev 02 card in it an nothing seems to be working. I 
> have tried to use the ndiswrapper and the computer locks up when using 
> wireless. So I have tried to go to the firmware version but I can't get 
> it to scan for networks. When I install the firmware I can get the light 
> to come on when using modprobe bcm43xx but it will not scan. I noticed 
> in the list of supported cards it includes rev 01 for this card. Is 
> there anything I can do to get someone to help me get this card working 
> and/or help with testing or anything else? I would just like it to work 
> without locking up my computer. I am a developer but have never written 
> drivers but will do anything I can to get this working if someone is 
> willing to put up with my driver inexperience.

At an absolute minimum, we need the output of 'dmesg | grep bcm' after you have modprobed bcm43xx.

No one here can or will help you with ndiswrapper. We have devoted much effort to wiping out the 
need for that abomination!!

Larry


From larry.finger at lwfinger.net  Mon Aug 13 23:22:41 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 13 Aug 2007 16:22:41 -0500
Subject: Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card rev 02
In-Reply-To: <46C0CB1B.8020004@lwfinger.net>
References: <20070813140050.d93209e2c756a6ecfa0dc94b7784bf13.593c2acb43.wbe@email.secureserver.net>
	<46C0CB1B.8020004@lwfinger.net>
Message-ID: <46C0CBA1.3090607@lwfinger.net>

Larry Finger wrote:
> Dru Devore wrote:
>> I know this may not be the proper place for this request but the support 
>> forum is timing out.
>>
>> I have a new laptop with the Broadcom Corporation Dell Wireless 1390 
>> WLAN Mini-PCI Card rev 02 card in it an nothing seems to be working. I 
>> have tried to use the ndiswrapper and the computer locks up when using 
>> wireless. So I have tried to go to the firmware version but I can't get 
>> it to scan for networks. When I install the firmware I can get the light 
>> to come on when using modprobe bcm43xx but it will not scan. I noticed 
>> in the list of supported cards it includes rev 01 for this card. Is 
>> there anything I can do to get someone to help me get this card working 
>> and/or help with testing or anything else? I would just like it to work 
>> without locking up my computer. I am a developer but have never written 
>> drivers but will do anything I can to get this working if someone is 
>> willing to put up with my driver inexperience.
> 
> At an absolute minimum, we need the output of 'dmesg | grep bcm' after you have modprobed bcm43xx.
> 
> No one here can or will help you with ndiswrapper. We have devoted much effort to wiping out the 
> need for that abomination!!

I forgot - we also need the results from 'uname -r'.

Larry


From ddevore at duckhouse.us  Tue Aug 14 00:20:10 2007
From: ddevore at duckhouse.us (Dru Devore)
Date: Mon, 13 Aug 2007 15:20:10 -0700
Subject: Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card rev 02
Message-ID: <20070813152010.d93209e2c756a6ecfa0dc94b7784bf13.c96601cc94.wbe@email.secureserver.net>

An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/6d7eb653/attachment.html>

From larry.finger at lwfinger.net  Tue Aug 14 00:48:49 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 13 Aug 2007 17:48:49 -0500
Subject: Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card rev 02
In-Reply-To: <20070813152010.d93209e2c756a6ecfa0dc94b7784bf13.c96601cc94.wbe@email.secureserver.net>
References: <20070813152010.d93209e2c756a6ecfa0dc94b7784bf13.c96601cc94.wbe@email.secureserver.net>
Message-ID: <46C0DFD1.7010305@lwfinger.net>

Dru Devore wrote:
> I am not wanting to use the ndiswrapper. I only included that 
> information in the chance that there might be some information from it 
> could be useful.
> 
> For the information you need and some more...
> Ubuntu 7.04
> HP dv9000
> AMD dual core thing.
> 
> This is from the firmware in the Ubuntu dist.
> dmsg | grep bcm
> [ 9122.176000] bcm43xx: no version for "struct_module" found: kernel 
> tainted.
> [ 9122.180000] bcm43xx driver
> [ 9122.188000] bcm43xx: Unsupported 80211 core revision 13
> [ 9122.192000] bcm43xx: Invalid PHY Revision 9

Are you sure Ubuntu distributed the firmware? Due to copyright restrictions, no one can distribute 
such firmware. What is allowed is distributing the program used to extract the firmware from a 
driver built for Windows or other operating systems. That driver may be the one installed when you 
bought the computer, or one downloaded from the webpile of a card vendor.

Your card is never going to work with bcm43xx. Those revisions of the 80211 core and PHY are not in 
the V3 firmware, which is what that driver uses. It supports up to 80211 core revision 10 and PHY 
revision 8.

Support for this unit will have to be in b43, which uses V4 firmware, but I don't think it is there 
yet. Our reverse-engineering group is down to two people and they are busy doing other things at the 
moment. If anyone reading this would like to help the bcm43xx project, that is where we need help. I 
would like to help there myself, but I'm contaminated because I'm working on the Linux driver.

Larry


From ddevore at duckhouse.us  Tue Aug 14 01:59:14 2007
From: ddevore at duckhouse.us (Dru Devore)
Date: Mon, 13 Aug 2007 16:59:14 -0700
Subject: Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card rev 02
Message-ID: <20070813165914.d93209e2c756a6ecfa0dc94b7784bf13.ac669a6ada.wbe@email.secureserver.net>

An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/d65e352a/attachment.html>

From larry.finger at lwfinger.net  Tue Aug 14 02:17:39 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 13 Aug 2007 19:17:39 -0500
Subject: Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card rev 02
In-Reply-To: <20070813165914.d93209e2c756a6ecfa0dc94b7784bf13.ac669a6ada.wbe@email.secureserver.net>
References: <20070813165914.d93209e2c756a6ecfa0dc94b7784bf13.ac669a6ada.wbe@email.secureserver.net>
Message-ID: <46C0F4A3.2050907@lwfinger.net>

Dru Devore wrote:
> I think the firmware was actually from another download site. It came 
> from the apt-get and I have all the available site enabled.
> 
> I also tried the bcm43xx-fwcutter on the drivers which "worked" with the 
> ndiswrapper that I downloaded from dell. I have not tried the ones that 
> came with the computer because they are vista drivers. Would it do any 
> good to try the vista drivers?
> 
> If the bcm43xx drivers won't work what has to be done get this thing 
> working and is there someone who has the time to get me up to speed on 
> the driver development so I can do it. Before answering this remember I 
> have no driver or Linux development experience. I am an enterprise 
> application developer who works in Java.
> 
> I will be willing to join the development of this project if I can get 
> some help getting started and if it will get my wireless working correctly.

As far as firmware is concerned, it usually doesn't matter whether the driver is for XP or Vista, 
only what version it is. That part of the driver is thrown away and replaced by the Linux driver. In 
fact, the firmware that I'm using came from the MIPS drivers used in OpenWRT. I like them because 
they are small, unlike those humongous Windows drivers, made even worse because you usually have to 
download all sorts of support software.

At the moment, we do not have any specifications on how to drive devices with your revision level. 
That is what the reverse engineers do. They take Broadcom drivers apart, deduce how they work and 
write the specifications. See http://bcm-v4.sipsolutions.net/Specification for examples. The bcm43xx 
developers take those web pages and turn them into code. We do not ever see the details of 
Broadcom's drivers. If we did, we would be open to lawsuits over theft of intellectual property. 
Similarly, the RE's don't touch the Linux-driver code.

If you would like to help with the RE activity, our RE's read this mailing list and will be 
contacting you.

Larry



From ddevore at duckhouse.us  Tue Aug 14 02:21:44 2007
From: ddevore at duckhouse.us (Dru Devore)
Date: Mon, 13 Aug 2007 17:21:44 -0700
Subject: Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card rev 02
Message-ID: <20070813172144.d93209e2c756a6ecfa0dc94b7784bf13.9553bd032c.wbe@email.secureserver.net>

An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/96384764/attachment.html>

From mistamaila at gmail.com  Tue Aug 14 05:17:46 2007
From: mistamaila at gmail.com (John H.)
Date: Mon, 13 Aug 2007 22:17:46 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46C0CA41.1040806@lwfinger.net>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<20070808135016.GB7335@tuxdriver.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>
	<46BD2CED.3050608@lwfinger.net>
	<5b9417770708131311n7b1ab9a3k72218c6b24f85e14@mail.gmail.com>
	<46C0CA41.1040806@lwfinger.net>
Message-ID: <5b9417770708132017n4155a062vac5f1407472b1a6d@mail.gmail.com>

I think it ended up working OK.  It seems to scale, I just didn't
notice that till later.
thx!:)

On 8/13/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > I upgraded as brennan requested, but iwconfig still lists bit rate as 1 mb/s:(
> If you are running bcm43xx-mac80211 from the Rawhide kernel, it will auto-scale the rate as best it
> can. Do you have interference?
>
> Larry
>
>
>
>


From gavron at Wetwork.Net  Tue Aug 14 05:24:53 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Mon, 13 Aug 2007 20:24:53 -0700
Subject: newbie question
Message-ID: <46C12085.70503@Wetwork.Net>

I've git clone'd the wireless-dev tree, and the test tree, and there 
ain't* not bcm43xx_mac80211 or b43 or b44 or anything similar in the 
.config.

1) How can I get access to update the berlios.de wiki?  I'd like to 
contribute, and I think I can help other newbies because I can relate 
(being one) but I can also talk technical to a point.
2) Where can I download the *latest* kernel with the *latest* changes?  
I want to help the development process, and while you guys are clear on 
the RE and the Driver Development teams.... you also need testers.  
Well.  I'm one :)

Ehud

* not a real word
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/1556e8bb/attachment.bin>

From larry.finger at lwfinger.net  Tue Aug 14 06:08:14 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 13 Aug 2007 23:08:14 -0500
Subject: newbie question
In-Reply-To: <46C12085.70503@Wetwork.Net>
References: <46C12085.70503@Wetwork.Net>
Message-ID: <46C12AAE.10500@lwfinger.net>

Ehud Gavron wrote:
> I've git clone'd the wireless-dev tree, and the test tree, and there 
> ain't* not bcm43xx_mac80211 or b43 or b44 or anything similar in the 
> .config.
> 
> 1) How can I get access to update the berlios.de wiki?  I'd like to 
> contribute, and I think I can help other newbies because I can relate 
> (being one) but I can also talk technical to a point.
> 2) Where can I download the *latest* kernel with the *latest* changes?  
> I want to help the development process, and while you guys are clear on 
> the RE and the Driver Development teams.... you also need testers.  
> Well.  I'm one :)

Linville reorganized his tree. The default clone gets you only a copy of Linus's tree on branch 
"master". I don't know how to get the rest - he is planning on sending an email about this.

Larry


From gavron at Wetwork.Net  Tue Aug 14 07:03:18 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Mon, 13 Aug 2007 22:03:18 -0700
Subject: newbie question
In-Reply-To: <46C12AAE.10500@lwfinger.net>
References: <46C12085.70503@Wetwork.Net> <46C12AAE.10500@lwfinger.net>
Message-ID: <46C13796.3000200@Wetwork.Net>

Off list... but your eventual reply may want to be there.

When John gets his tree so we [those of us who use this code] can test 
it, let us [same group] know.

Best regards,

Ehud
Tucson

Larry Finger wrote:
> Ehud Gavron wrote:
>> I've git clone'd the wireless-dev tree, and the test tree, and there 
>> ain't* not bcm43xx_mac80211 or b43 or b44 or anything similar in the 
>> .config.
>>
>> 1) How can I get access to update the berlios.de wiki?  I'd like to 
>> contribute, and I think I can help other newbies because I can relate 
>> (being one) but I can also talk technical to a point.
>> 2) Where can I download the *latest* kernel with the *latest* 
>> changes?  I want to help the development process, and while you guys 
>> are clear on the RE and the Driver Development teams.... you also 
>> need testers.  Well.  I'm one :)
>
> Linville reorganized his tree. The default clone gets you only a copy 
> of Linus's tree on branch "master". I don't know how to get the rest - 
> he is planning on sending an email about this.
>
> Larry
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070813/956092e1/attachment.bin>

From larry.finger at lwfinger.net  Tue Aug 14 07:05:25 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 14 Aug 2007 00:05:25 -0500
Subject: 4311 not working
In-Reply-To: <BAY117-F122398D5A1A37CC03463A1B1DC0@phx.gbl>
References: <BAY117-F122398D5A1A37CC03463A1B1DC0@phx.gbl>
Message-ID: <46C13815.7030302@lwfinger.net>

Jason Wood wrote:
>> From: Larry Finger <larry.finger at lwfinger.net>
>>
>> Analysis of the two dmesg outputs cannot be completed as your kernel 
>> is compiled with a very small log buffer and it is wrapping around; 
>> however, I see enough to suspect some kind of race condition in the 
>> bus setup. I see a device with different IRQ's between the good/bad 
>> boots. That shouldn't happen. I do not think you are having hardware 
>> problems, and I'm pretty sure it is not a bcm43xx problem.
>>
>> Is it possible for you to upgrade to a 2.6.22 or 2.6.23-rc2 kernel? If 
>> so, please do. Whatever bug we are chasing may have already been fixed.
>>
>> If it is not possible to upgrade, I would like you to add the option 
>> 'log_buf_len=262144' when you boot. That will increase the size of the 
>> log buffer so that we see everything. Then send me the dmesg output 
>> from a good and a bad boot.
>>
>> Another thing to try is the boot option 'maxcpus=0'. That will run it 
>> as a unit processor system and eliminate a lot of potential problems 
>> with SMP. I'm particularly interested in knowing if it always works 
>> with this option, or if it also fails sometimes.
>>
>> What is the make/model of your laptop? I probably have that info 
>> somewhere, but I'm lazy. In addition, are your running a 32- or 64-bit 
>> system?
>>
>> Thanks,
>>
>> Larry
>>
> 
> I'm using a HP Pavilion dv6000.  I'm currently trying to solve a 
> separate issue that leads me to believe this may be a bios or hardware 
> issue.  I intermittently get bios beep codes for the video on startup, 
> forcing a power cycle.  And of course HP support is unwilling to work 
> with me because of my OS choice.
> 
> Anyway, I have working and non-working dmesg output attached with the 
> increased buffer limit set for kernel 2.6.22.1.  I also attempted 
> booting with 'maxcpus=0' set, however the system hard locked at random 
> points each time.  Line 278 of the dmesg.2.6.22.1.works file is where 
> the device first gets detected (0000:03:00.0), and does not show up in 
> the failed boot dmesg.  With this kernel, I'm having some SELinux errors 
> I believe, but I don't think it affects the bcm43xx module.

The crucial difference between the two dmesg outputs is in the following difference, where the + 
indicates "good" and "-" means bad:

@@ -275,6 +275,7 @@ PM: Adding info for pci:0000:00:18.0
  PM: Adding info for pci:0000:00:18.1
  PM: Adding info for pci:0000:00:18.2
  PM: Adding info for pci:0000:00:18.3
+PM: Adding info for pci:0000:03:00.0
  PM: Adding info for pci:0000:05:00.0
  PM: Adding info for pci:0000:07:05.0
  PM: Adding info for pci:0000:07:05.1

In the bad case, the pci adapter with the wireless device is not being recognized. No bus == no adapter.

The dmesg output says 'ACPI: Please test with "acpi_osi=!Linux"'. Have you tried that?
The next line says 'Please send dmidecode to linux-acpi at vger.kernel.org'. That is the output of a 
dmidecode command, which has to be run as root.

Larry



From mistamaila at gmail.com  Tue Aug 14 07:26:24 2007
From: mistamaila at gmail.com (John H.)
Date: Tue, 14 Aug 2007 00:26:24 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708132017n4155a062vac5f1407472b1a6d@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>
	<46BA774D.4080506@lwfinger.net>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>
	<46BD2CED.3050608@lwfinger.net>
	<5b9417770708131311n7b1ab9a3k72218c6b24f85e14@mail.gmail.com>
	<46C0CA41.1040806@lwfinger.net>
	<5b9417770708132017n4155a062vac5f1407472b1a6d@mail.gmail.com>
Message-ID: <5b9417770708132226w6674b263y2a35c8ca61abdae0@mail.gmail.com>

I spoke too soon.  I just tried it again and it seemed stuck on 1 mb/s
and there was an obvious difference in network speed.  hmm.

On 8/13/07, John H. <mistamaila at gmail.com> wrote:
> I think it ended up working OK.  It seems to scale, I just didn't
> notice that till later.
> thx!:)
>
> On 8/13/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> > John H. wrote:
> > > I upgraded as brennan requested, but iwconfig still lists bit rate as 1 mb/s:(
> > If you are running bcm43xx-mac80211 from the Rawhide kernel, it will auto-scale the rate as best it
> > can. Do you have interference?
> >
> > Larry
> >
> >
> >
> >
>


From identd_ at hotmail.com  Tue Aug 14 07:34:27 2007
From: identd_ at hotmail.com (David Ellingsworth)
Date: Tue, 14 Aug 2007 01:34:27 -0400
Subject: newbie question
Message-ID: <BAY128-W1667A3F7EF110CE5BBB1EB86DD0@phx.gbl>


Larry Finger wrote:
> Ehud Gavron wrote:
> > I've git clone'd the wireless-dev tree, and the test tree, and there 
> > ain't* not bcm43xx_mac80211 or b43 or b44 or anything similar in the 
> > .config.
> > 
> > 1) How can I get access to update the berlios.de wiki?  I'd like to 
> > contribute, and I think I can help other newbies because I can relate 
> > (being one) but I can also talk technical to a point.
> > 2) Where can I download the *latest* kernel with the *latest* changes?  
> > I want to help the development process, and while you guys are clear on 
> > the RE and the Driver Development teams.... you also need testers.  
> > Well.  I'm one :)
> 
> Linville reorganized his tree. The default clone gets you only a copy of Linus's tree on branch 
> "master". I don't know how to get the rest - he is planning on sending an email about this.
> 
> Larry

After doing a bit of digging, I've figured out what needs to be done. If you have just cloned the wireless-dev branch you need to do the following:

git checkout --track -b  

where  will be the name used for the local branch
and  is one of the branches from git branch -r

For example:
git branch -r in the new wireless-dev clone shows the following:
  origin/HEAD
  origin/adm8211
  origin/b43
  origin/everything
  origin/iwlwifi
  origin/mac80211
  origin/master
  origin/merged-upstream
  origin/mm-master
  origin/p54
  origin/rt2x00
  origin/ssb
  origin/zd1211rw

Therefore we can create a local branch called everyting that contains everything from origin/everything by issuing the command:
    git checkout --track -b everything origin/everything

You should then be able to apply any b43 or mac80211 patches that have not yet been applied and subsequently build a new kernel.

-David
_________________________________________________________________
Learn. Laugh. Share. Reallivemoms is right place!
http://www.reallivemoms.com?ocid=TXT_TAGHM&loc=us

From identd_ at hotmail.com  Tue Aug 14 07:39:42 2007
From: identd_ at hotmail.com (David Ellingsworth)
Date: Tue, 14 Aug 2007 01:39:42 -0400
Subject: newbie question
Message-ID: <BAY128-W11DE77293F8CE350061B8486DD0@phx.gbl>


> From: identd_ at hotmail.com
> To: larry.finger at lwfinger.net
> Subject: RE: newbie question
> Date: Tue, 14 Aug 2007 01:34:27 -0400
> CC: bcm43xx-dev at lists.berlios.de
> 
> 
> Larry Finger wrote:
> > Ehud Gavron wrote:
> > > I've git clone'd the wireless-dev tree, and the test tree, and there 
> > > ain't* not bcm43xx_mac80211 or b43 or b44 or anything similar in the 
> > > .config.
> > > 
> > > 1) How can I get access to update the berlios.de wiki?  I'd like to 
> > > contribute, and I think I can help other newbies because I can relate 
> > > (being one) but I can also talk technical to a point.
> > > 2) Where can I download the *latest* kernel with the *latest* changes?  
> > > I want to help the development process, and while you guys are clear on 
> > > the RE and the Driver Development teams.... you also need testers.  
> > > Well.  I'm one :)
> > 
> > Linville reorganized his tree. The default clone gets you only a copy of Linus's tree on branch 
> > "master". I don't know how to get the rest - he is planning on sending an email about this.
> > 
> > Larry
> 
> After doing a bit of digging, I've figured out what needs to be done. If you have just cloned the wireless-dev branch you need to do the following:
> 
> git checkout --track -b  [dest branch] [desired branch]
> 
> where [dest branch] will be the name used for the local branch
> and [desired branch] is one of the branches from git branch -r
> 
> For example:
> git branch -r in the new wireless-dev clone shows the following:
>   origin/HEAD
>   origin/adm8211
>   origin/b43
>   origin/everything
>   origin/iwlwifi
>   origin/mac80211
>   origin/master
>   origin/merged-upstream
>   origin/mm-master
>   origin/p54
>   origin/rt2x00
>   origin/ssb
>   origin/zd1211rw
> 
> Therefore we can create a local branch called everyting that contains everything from origin/everything by issuing the command:
>     git checkout --track -b everything origin/everything
> 
> You should then be able to apply any b43 or mac80211 patches that have not yet been applied and subsequently build a new kernel.

My bad, should have know not to put stuff between a > and <

-David


_________________________________________________________________
Recharge--play some free games. Win cool prizes too!
http://club.live.com/home.aspx?icid=CLUB_wlmailtextlink

From sandain at hotmail.com  Tue Aug 14 08:44:56 2007
From: sandain at hotmail.com (Jason Wood)
Date: Tue, 14 Aug 2007 00:44:56 -0600
Subject: 4311 not working
In-Reply-To: <46C13815.7030302@lwfinger.net>
Message-ID: <BAY117-F3863EB9E020E82747F608BB1DD0@phx.gbl>

>From: Larry Finger <larry.finger at lwfinger.net>
>
>The crucial difference between the two dmesg outputs is in the following 
>difference, where the + indicates "good" and "-" means bad:
>
>@@ -275,6 +275,7 @@ PM: Adding info for pci:0000:00:18.0
>  PM: Adding info for pci:0000:00:18.1
>  PM: Adding info for pci:0000:00:18.2
>  PM: Adding info for pci:0000:00:18.3
>+PM: Adding info for pci:0000:03:00.0
>  PM: Adding info for pci:0000:05:00.0
>  PM: Adding info for pci:0000:07:05.0
>  PM: Adding info for pci:0000:07:05.1
>
>In the bad case, the pci adapter with the wireless device is not being 
>recognized. No bus == no adapter.
>
>The dmesg output says 'ACPI: Please test with "acpi_osi=!Linux"'. Have you 
>tried that?
>The next line says 'Please send dmidecode to linux-acpi at vger.kernel.org'. 
>That is the output of a dmidecode command, which has to be run as root.
>
>Larry
>

I didn't think it was a problem with this driver, my 4311 has been rock 
solid and getting progressively better with each new kernel.  The 
"acpi_osi=!Linux" boot option has made the boot process run much smoother, 
but unfortunately, it did not solve the current problem I am having.  I used 
to get random crashes prior to the Nvidia module being loaded, this boot 
option seems to have fixed that problem.  I used to use "noapic nolapic" to 
solve this problem when needed, but that caused the usb to fail.

I'm going to continue my efforts to update the bios to solve this problem, 
but getting a working Windows installation is harder than it should be.  
BartPE requires Windows to install (thankfully I had a spare PC), and fails 
in wine.  After finally creating a disk, the default settings for video 
don't seem to work with my laptop.

I do appreciate your help Larry, and I thank you for all your hard work on 
this driver.

Jason Wood

_________________________________________________________________
Puzzles, trivia teasers, word scrambles and more. Play for your chance to 
win! http://club.live.com/home.aspx?icid=CLUB_hotmailtextlink



From johannes at sipsolutions.net  Mon Aug 13 18:00:12 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 13 Aug 2007 18:00:12 +0200
Subject: Port to a common pci bridge
In-Reply-To: <200708122047.52133.mb@bu3sch.de>
References: <200708122047.52133.mb@bu3sch.de>
Message-ID: <1187020812.5271.1.camel@johannes.berg>

You forgot this:

--- wireless-dev.orig/drivers/ssb/b43_pci_bridge.c	2007-08-13 17:57:32.205589257 +0200
+++ wireless-dev/drivers/ssb/b43_pci_bridge.c	2007-08-13 17:57:49.915589257 +0200
@@ -27,6 +27,8 @@ static const struct pci_device_id b43_pc
 	{ 0, },
 };
 
+MODULE_DEVICE_TABLE(pci, b43_pci_bridge_tbl);
+
 static struct pci_driver b43_pci_bridge_driver = {
 	.name = "b43-pci-bridge",
 	.id_table = b43_pci_bridge_tbl,




From johannes at sipsolutions.net  Tue Aug 14 13:41:28 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 14 Aug 2007 13:41:28 +0200
Subject: [RFC] Proposed changes to fwcutter
In-Reply-To: <20070813202638.GA3547@tuba>
References: <46bca40d.zEv6v3zA35+E39SQ%Larry.Finger@lwfinger.net>
	<1186773468.9771.29.camel@johannes.berg>
	<46BE5EF2.3020100@lwfinger.net> <20070813202638.GA3547@tuba>
Message-ID: <1187091688.4069.3.camel@johannes.berg>

On Mon, 2007-08-13 at 22:26 +0200, Martin Langer wrote:

> > a0g0bsinitvalsN		?
> > a0g0initvalsN		?
> > a0g1bsinitvalsN		?
> > a0g1initvalsN		?
> > b0g0bsinitvalsN		?
> > b0g0initvalsN		?
> 
> Hmm, it sounds as cryptic as before. But I'm not living in the re 
> world ;)

Heh. Well, it's not too bad, I think I explained the scheme some time
ago. In any case, it makes it far easier for us to explain this area.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/c8092d33/attachment.pgp>

From mb at bu3sch.de  Tue Aug 14 15:26:04 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 15:26:04 +0200
Subject: Port to a common pci bridge
In-Reply-To: <1187020812.5271.1.camel@johannes.berg>
References: <200708122047.52133.mb@bu3sch.de>
	<1187020812.5271.1.camel@johannes.berg>
Message-ID: <200708141526.05248.mb@bu3sch.de>

On Monday 13 August 2007 18:00:12 Johannes Berg wrote:
> You forgot this:
> 
> --- wireless-dev.orig/drivers/ssb/b43_pci_bridge.c	2007-08-13 17:57:32.205589257 +0200
> +++ wireless-dev/drivers/ssb/b43_pci_bridge.c	2007-08-13 17:57:49.915589257 +0200
> @@ -27,6 +27,8 @@ static const struct pci_device_id b43_pc
>  	{ 0, },
>  };
>  
> +MODULE_DEVICE_TABLE(pci, b43_pci_bridge_tbl);
> +
>  static struct pci_driver b43_pci_bridge_driver = {
>  	.name = "b43-pci-bridge",
>  	.id_table = b43_pci_bridge_tbl,
> 
> 
> 
> 

I already updated my patches.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Tue Aug 14 16:00:36 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 14 Aug 2007 09:00:36 -0500
Subject: 4311 not working
In-Reply-To: <BAY117-F3863EB9E020E82747F608BB1DD0@phx.gbl>
References: <BAY117-F3863EB9E020E82747F608BB1DD0@phx.gbl>
Message-ID: <46C1B584.6080504@lwfinger.net>

Jason Wood wrote:
> 
> I'm going to continue my efforts to update the bios to solve this 
> problem, but getting a working Windows installation is harder than it 
> should be.  BartPE requires Windows to install (thankfully I had a spare 
> PC), and fails in wine.  After finally creating a disk, the default 
> settings for video don't seem to work with my laptop.
> 
> I do appreciate your help Larry, and I thank you for all your hard work 
> on this driver.

What is your Nvidea graphics adapter? Perhaps I can make a CD for you. I have a Geforce Go 6150 on 
my HP dv2125nr. I keep XP on my machine just in case of this sort of issue. Once I get the thing 
built, I'll post the iso file on my FTP site, and let you know where to find it.

Larry


From mejias.cavan at gmail.com  Tue Aug 14 17:10:32 2007
From: mejias.cavan at gmail.com (Cavan Mejias)
Date: Tue, 14 Aug 2007 11:10:32 -0400
Subject: debian etch wireless
Message-ID: <a60d15110708140810n1d9554f2od421b69668de28fb@mail.gmail.com>

I have a dell inspiron 1501 with debian etch installed. I installed
bcm43xx-fwcutter and downloaded the firmware. however my wireless light does
not come on at boot. lspci shows:                                      05:
00.0 Network controller: Broadcom Corporation Dell Wireless 1390 WLAN
Mini-PCI Card (rev 01)
08:00.0 Ethernet controller: Broadcom Corporation BCM4401-B0 100Base-TX (rev
02) .
everything else seems to function. Iwconfig doesn't list any wireless
extentions at all.

Any ideas. Thanks
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/d7934049/attachment.html>

From larry.finger at lwfinger.net  Tue Aug 14 17:57:39 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 14 Aug 2007 10:57:39 -0500
Subject: debian etch wireless
In-Reply-To: <a60d15110708140810n1d9554f2od421b69668de28fb@mail.gmail.com>
References: <a60d15110708140810n1d9554f2od421b69668de28fb@mail.gmail.com>
Message-ID: <46C1D0F3.1030908@lwfinger.net>

Cavan Mejias wrote:
> I have a dell inspiron 1501 with debian etch installed. I installed 
> bcm43xx-fwcutter and downloaded the firmware. however my wireless light 
> does not come on at boot. lspci 
> shows:                                      05:00.0 Network controller: 
> Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card (rev 01)
> 08:00.0 Ethernet controller: Broadcom Corporation BCM4401-B0 100Base-TX 
> (rev 02) .
> everything else seems to function. Iwconfig doesn't list any wireless 
> extentions at all.

Please send the output of 'dmesg | grep bcm'.

Larry


From larry.finger at lwfinger.net  Tue Aug 14 18:58:52 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 14 Aug 2007 11:58:52 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708132226w6674b263y2a35c8ca61abdae0@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>	
	<5b9417770708081500v5cfb6e9anb81e4fb5348d1e40@mail.gmail.com>	
	<46BA774D.4080506@lwfinger.net>	
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>	
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>	
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>	
	<46BD2CED.3050608@lwfinger.net>	
	<5b9417770708131311n7b1ab9a3k72218c6b24f85e14@mail.gmail.com>	
	<46C0CA41.1040806@lwfinger.net>	
	<5b9417770708132017n4155a062vac5f1407472b1a6d@mail.gmail.com>
	<5b9417770708132226w6674b263y2a35c8ca61abdae0@mail.gmail.com>
Message-ID: <46C1DF4C.7010204@lwfinger.net>

John H. wrote:
> I spoke too soon.  I just tried it again and it seemed stuck on 1 mb/s
> and there was an obvious difference in network speed.  hmm.

If you don't want the auto speed adjustment, or are unhappy with it, you can change the rate setting 
with the 'iwconfig eth1 rate Y' command. As your system seems not to auto-scale very well, I would 
try values for Y of 11M, 18M, 24M, 36M, 48M, and 54M (in that order). For each speed, try a ping 
flood against your AP (ping -f 192.168.1.1, or whatever address is shown as the gateway in a 'route 
-n' command). As long as you don't see a lot of dots from the flood, it is safe to try the next 
higher speed. Once you get a failure, you might want to back off one extra speed for safety.

Have you tried changing the AP's channel, if possible? You might find less interference with a 
different setting. Does your location have any other 2.4 GHz devices like portable telephones or 
baby monitors, etc. They could interfere.

Larry



From mb at bu3sch.de  Tue Aug 14 18:57:47 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 18:57:47 +0200
Subject: [patch 1/7] ssb: generate modaliases for modules
References: <20070814165746.863593000@bu3sch.de>
Message-ID: <20070814165747.381853000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 001-ssb-modalias.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/0f84c98a/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 18:57:49 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 18:57:49 +0200
Subject: [patch 3/7] ssb: Add GPIO support to Chip Common and PCI core drivers
References: <20070814165746.863593000@bu3sch.de>
Message-ID: <20070814165748.319144000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 003-ssb-add-GPIO-support-to-Chip-Common-and-PCI-core-drivers.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/06fba6f8/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 18:57:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 18:57:51 +0200
Subject: [patch 5/7] ssb: Add Broadcom 43xx PCI to SSB bridge
References: <20070814165746.863593000@bu3sch.de>
Message-ID: <20070814165749.227375000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 005-ssb-b43-pci-bridge.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/ca6c6ac2/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 19:00:30 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 19:00:30 +0200
Subject: [patch 0/7] SSB: New patch series for merge
Message-ID: <200708141900.31273.mb@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/6ed28e92/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 18:57:50 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 18:57:50 +0200
Subject: [patch 4/7] ssb: Fix a warning in PCI core driver
References: <20070814165746.863593000@bu3sch.de>
Message-ID: <20070814165748.759286000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 004-ssb-fix-a-warning-in-PCI-core-driver.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/aad0bf3c/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 18:57:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 18:57:48 +0200
Subject: [patch 2/7] ssb: include modalias in uevent for core
References: <20070814165746.863593000@bu3sch.de>
Message-ID: <20070814165747.821518000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 002-ssb-uevent.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/517cc700/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 18:57:52 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 18:57:52 +0200
Subject: [patch 6/7] ssb: Add debugging for buspower
References: <20070814165746.863593000@bu3sch.de>
Message-ID: <20070814165749.665285000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 006-ssb-add-buspower-debugging.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/9618557b/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 18:57:53 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 18:57:53 +0200
Subject: [patch 7/7] ssb: Add kconfig SELECT workaround
References: <20070814165746.863593000@bu3sch.de>
Message-ID: <20070814165750.102981000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 007-ssb-add-kconfig-possible-opts.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/f9da4dde/attachment.ksh>

From larry.finger at lwfinger.net  Tue Aug 14 19:34:08 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 14 Aug 2007 12:34:08 -0500
Subject: [patch 0/7] SSB: New patch series for merge
In-Reply-To: <200708141900.31273.mb@bu3sch.de>
References: <200708141900.31273.mb@bu3sch.de>
Message-ID: <46C1E790.3020807@lwfinger.net>

Michael Buesch wrote:
> Hi John,
> 
> This patch series catches SSB up to my
> current wireless-development patchset.
> 
> Please merge this into wireless-dev ssb branch.

I had a problem with #7. My copy of John's tree still has EXPERIMENTAL for ssb. Yours does not.

The differences are:

--- ../ssb_patch7_from_MB       2007-08-14 12:27:51.000000000 -0500
+++ patches/ssb_patch7_works  2007-08-14 12:26:31.000000000 -0500
@@ -15,7 +15,7 @@
  +
   config SSB
         tristate "Sonics Silicon Backplane support"
--      depends on HAS_IOMEM
+-      depends on EXPERIMENTAL && HAS_IOMEM
  +      depends on SSB_POSSIBLE
         help
  -        Support for the Sonics Silicon Backplane bus
@@ -50,12 +50,12 @@

  +config SSB_PCMCIAHOST_POSSIBLE
  +      bool
-+      depends on SSB && PCMCIA && EXPERIMENTAL
++      depends on SSB && PCMCIA
  +      default y
  +
   config SSB_PCMCIAHOST
-       bool "Support for SSB on PCMCIA-bus host (EXPERIMENTAL)"
--      depends on SSB && PCMCIA && EXPERIMENTAL
+       bool "Support for SSB on PCMCIA-bus host"
+-      depends on SSB && PCMCIA
  +      depends on SSB_PCMCIAHOST_POSSIBLE
         help
           Support for a Sonics Silicon Backplane on top


From mb at bu3sch.de  Tue Aug 14 19:38:33 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 19:38:33 +0200
Subject: [patch 0/7] SSB: New patch series for merge
In-Reply-To: <46C1E790.3020807@lwfinger.net>
References: <200708141900.31273.mb@bu3sch.de> <46C1E790.3020807@lwfinger.net>
Message-ID: <200708141938.33952.mb@bu3sch.de>

On Tuesday 14 August 2007 19:34:08 Larry Finger wrote:
> Michael Buesch wrote:
> > Hi John,
> > 
> > This patch series catches SSB up to my
> > current wireless-development patchset.
> > 
> > Please merge this into wireless-dev ssb branch.
> 
> I had a problem with #7. My copy of John's tree still has EXPERIMENTAL for ssb. Yours does not.

Are you sure you have latest wireless-dev? It has
been rebased again.

-- 
Greetings Michael.


From mb at bu3sch.de  Tue Aug 14 20:12:13 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 20:12:13 +0200
Subject: [patch 0/9] New patch series for merge
Message-ID: <20070814181213.135874000@bu3sch.de>

Hi John,

This patch series catches wireless-dev up to my
current wireless-development patchset.

Please merge this into wireless-dev.


-- 



From mb at bu3sch.de  Tue Aug 14 20:12:18 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 20:12:18 +0200
Subject: [patch 5/9] b43: Suppress sending of probe responses from firmware
References: <20070814181213.135874000@bu3sch.de>
Message-ID: <20070814181215.464099000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 005-b43-suppress-fw-probe-responses.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/40d692cd/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 20:12:19 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 20:12:19 +0200
Subject: [patch 6/9] b43: debugfs tx_status,
	Fix endless loop inside of spinlock
References: <20070814181213.135874000@bu3sch.de>
Message-ID: <20070814181215.971466000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 006-b43-debugfs-fix-tx-status-crash.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/2316d370/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 20:12:20 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 20:12:20 +0200
Subject: [patch 7/9] b43: Fix frame retry count for suppressed frames
References: <20070814181213.135874000@bu3sch.de>
Message-ID: <20070814181216.382473000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 007-b43-keep-retry-count-above-zero.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/6b7f87fb/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 20:12:17 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 20:12:17 +0200
Subject: [patch 4/9] b43: Check init status in b43_config_interface.
References: <20070814181213.135874000@bu3sch.de>
Message-ID: <20070814181215.023935000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 004-b43-must-check-status-in-config-interface.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/518e6fb2/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 20:12:14 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 20:12:14 +0200
Subject: [patch 1/9] b43: Add more LO debugging
References: <20070814181213.135874000@bu3sch.de>
Message-ID: <20070814181213.698038000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 001-b43-lo-fixes.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/85559fd3/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 20:12:22 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 20:12:22 +0200
Subject: [patch 9/9] b43: Rewrite kconfig to get rid of the advice hack.
References: <20070814181213.135874000@bu3sch.de>
Message-ID: <20070814181217.291720000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 009-b43-use-ssb-possible-kconfig-stuff.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/abbb7255/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 20:12:16 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 20:12:16 +0200
Subject: [patch 3/9] b43: Powerup the bus before accessing any MMIO
References: <20070814181213.135874000@bu3sch.de>
Message-ID: <20070814181214.599568000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 003-b43-fix-bus-powerup.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/95bf6d6e/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 20:12:15 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 20:12:15 +0200
Subject: [patch 2/9] b43: Remove PCI to SSB bridge code
References: <20070814181213.135874000@bu3sch.de>
Message-ID: <20070814181214.144680000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 002-b43-remove-pci-bridge-code.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/38e5a3de/attachment.ksh>

From mb at bu3sch.de  Tue Aug 14 20:12:21 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 14 Aug 2007 20:12:21 +0200
Subject: [patch 8/9] b43: Fix controller reset
References: <20070814181213.135874000@bu3sch.de>
Message-ID: <20070814181216.879252000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 008-b43-remove-status-check-on-controller-restart.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/0290f8ff/attachment.ksh>

From linville at tuxdriver.com  Tue Aug 14 21:43:52 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Tue, 14 Aug 2007 15:43:52 -0400
Subject: wireless-dev rebased, new rebasing policies
Message-ID: <20070814194352.GG7198@tuxdriver.com>

Greetings!

Some of you have already noticed that the wireless-dev tree has
been rebased.  I adopted the mac80211 work of Jiri Benc as a base,
then re-imported all of the mac80211 drivers (and the SSB stuff) from
wireless-dev into individual branches.  There is also an 'everything'
branch into which all the other branches get pulled, and an 'mm-master'
branch which has the sole purpose of feeding patches to akpm while
minimizing conflicts with the other networking trees.  The master
branch is a direct pull of something relatively recent from Linus,
usually an -rc or release tag.

Recent versions of git seem to hide remote branches by default when
cloning a tree, so by default you will just get my master branch.
Since this isn't very interesting for wireless development, you will
want to recreate one or more of my branches to work from as a base.

At a minimum, everyone from "early adopter" users to driver maintainers
will want the 'everything' branch, so I will illustrate recreating
that below.  Other branches are done similarly.

/home/linville/git/wireless-dev
[linville-t43.mobile]:> git branch
* master

/home/linville/git/wireless-dev
[linville-t43.mobile]:> git branch -r
  origin/HEAD
  origin/adm8211
  origin/b43
  origin/everything
  origin/iwlwifi
  origin/mac80211
  origin/master
  origin/merged-upstream
  origin/mm-master
  origin/p54
  origin/rt2x00
  origin/ssb
  origin/zd1211rw

/home/linville/git/wireless-dev
[linville-t43.mobile]:> git checkout -b everything origin/everything
Switched to a new branch "everything"

/home/linville/git/wireless-dev
[linville-t43.mobile]:> git branch
* everything
  master

Unlike the way wireless-dev was used in the past, I make no promises
about rebasing.  I intend to rebase most/all of the branches at least
as often as Linus produces an -rc or release tag, and I reserve the
right to rebase more often as I deem necessary.  I'm sorry, but as
you can see I have to manage a lot of patches.  Keeping them based
off a recent head is helpful to me.

I will entertain suggestions for how to minimize rebasing pain for
anyone following this tree.  However, the best suggestion I have
for anyone tracking wireless-dev is for them to get their favorite
driver(s) merged upstream.  Barring that, I understand that quilt
can be a good tool for tracking stacks of patches in development.
The git-format-patch, git-applymbox, and git-rebase commands are
handy as well.

Those simply following the tree should learn about the "--reference"
option to git-clone, and should use it often.  Keeping a backup of
previous git trees with any work in progress wouldn't hurt either.

Questions?  Complaints?  Comments?

Thanks,

John
-- 
John W. Linville
linville at tuxdriver.com


From a.mcguinness at ntlworld.com  Tue Aug 14 22:05:22 2007
From: a.mcguinness at ntlworld.com (Andrew McGuinness)
Date: Tue, 14 Aug 2007 20:05:22 +0000
Subject: Dell 1390 not detecting AP
Message-ID: <46C20B02.90003@ntlworld.com>

I'm not able to detect my AP with a Dell 1390 mini-pci using bcm43xx

I appreciate that the driver is under very heavy development at the
moment, and I'm willing to try the bcm43 if that will help.

Details follow:


The Acer Aspire 3680 contains the following (lspci -v)

03:00.0 Network controller: Broadcom Corporation Dell Wireless 1390 WLAN
Mini-PCI Card (rev 01)
	Subsystem: AMBIT Microsystem Corp. Unknown device 0422
	Flags: bus master, fast devsel, latency 0, IRQ 17
	Memory at 34100000 (32-bit, non-prefetchable) [size=16K]
	Capabilities: [40] Power Management version 2
	Capabilities: [58] Message Signalled Interrupts: Mask- 64bit- Queue=0/0
Enable-
	Capabilities: [d0] Express Legacy Endpoint IRQ 0
	Capabilities: [100] Advanced Error Reporting
	Capabilities: [13c] Virtual Channel

and from lspci -n

03:00.0 0280: 14e4:4311 (rev 01)


I built a 2.6.21 kernel from debian, with the combined_2.6.21.patch from
 lwfinger.dynalias.org

I got the v3 firmware wl_apsta-3.130.20.0.o and used fwcutter to create
the .fw files in /lib/firmware

$ dmesg | grep bcm

bcm43xx driver
bcm43xx: Chip ID 0x4311, rev 0x1
bcm43xx: Number of cores: 4
bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
bcm43xx: PHY connected
bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
bcm43xx: Radio turned off
bcm43xx: Radio turned off
bcm43xx: PHY connected
bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
bcm43xx: Radio turned on
bcm43xx: Radio disabled by hardware
bcm43xx: Chip initialized
bcm43xx: 32-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)
bcm43xx: set security called, .level = 0, .enabled = 0, .encrypt = 0

$ iwconfig eth1 essid arobeia

$ iwconfig eth1

Warning: Driver for device eth1 has been compiled with version 22
of Wireless Extension, while this program supports up to version 20.
Some things may be broken...

eth1      IEEE 802.11b/g  ESSID:"arobeia"  Nickname:"Broadcom 4311"
          Mode:Managed  Frequency=2.472 GHz  Access Point: Invalid
          Bit Rate=1 Mb/s   Tx-Power=18 dBm
          RTS thr:off   Fragment thr:off
          Encryption key:off
          Link Quality=0/100  Signal level=-256 dBm  Noise level=-256 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0



$ iwlist eth1 scan

eth1     no scan results

The "radio disabled by hardware" looks like a problem to me   ?


-- 
Andrew McGuinness



From gavron at Wetwork.Net  Tue Aug 14 22:22:36 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Tue, 14 Aug 2007 13:22:36 -0700
Subject: Dell 1390 not detecting AP
In-Reply-To: <46C20B02.90003@ntlworld.com>
References: <46C20B02.90003@ntlworld.com>
Message-ID: <46C20F0C.2030405@Wetwork.Net>

ifconfig eth1 up

E

Andrew McGuinness wrote:
> I'm not able to detect my AP with a Dell 1390 mini-pci using bcm43xx
>
> I appreciate that the driver is under very heavy development at the
> moment, and I'm willing to try the bcm43 if that will help.
>
> Details follow:
>
>
> The Acer Aspire 3680 contains the following (lspci -v)
>
> 03:00.0 Network controller: Broadcom Corporation Dell Wireless 1390 WLAN
> Mini-PCI Card (rev 01)
> 	Subsystem: AMBIT Microsystem Corp. Unknown device 0422
> 	Flags: bus master, fast devsel, latency 0, IRQ 17
> 	Memory at 34100000 (32-bit, non-prefetchable) [size=16K]
> 	Capabilities: [40] Power Management version 2
> 	Capabilities: [58] Message Signalled Interrupts: Mask- 64bit- Queue=0/0
> Enable-
> 	Capabilities: [d0] Express Legacy Endpoint IRQ 0
> 	Capabilities: [100] Advanced Error Reporting
> 	Capabilities: [13c] Virtual Channel
>
> and from lspci -n
>
> 03:00.0 0280: 14e4:4311 (rev 01)
>
>
> I built a 2.6.21 kernel from debian, with the combined_2.6.21.patch from
>  lwfinger.dynalias.org
>
> I got the v3 firmware wl_apsta-3.130.20.0.o and used fwcutter to create
> the .fw files in /lib/firmware
>
> $ dmesg | grep bcm
>
> bcm43xx driver
> bcm43xx: Chip ID 0x4311, rev 0x1
> bcm43xx: Number of cores: 4
> bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
> bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
> bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
> bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
> bcm43xx: PHY connected
> bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
> bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> bcm43xx: Radio turned off
> bcm43xx: Radio turned off
> bcm43xx: PHY connected
> bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
> bcm43xx: Radio turned on
> bcm43xx: Radio disabled by hardware
> bcm43xx: Chip initialized
> bcm43xx: 32-bit DMA initialized
> bcm43xx: Keys cleared
> bcm43xx: Selected 802.11 core (phytype 2)
> bcm43xx: set security called, .level = 0, .enabled = 0, .encrypt = 0
>
> $ iwconfig eth1 essid arobeia
>
> $ iwconfig eth1
>
> Warning: Driver for device eth1 has been compiled with version 22
> of Wireless Extension, while this program supports up to version 20.
> Some things may be broken...
>
> eth1      IEEE 802.11b/g  ESSID:"arobeia"  Nickname:"Broadcom 4311"
>           Mode:Managed  Frequency=2.472 GHz  Access Point: Invalid
>           Bit Rate=1 Mb/s   Tx-Power=18 dBm
>           RTS thr:off   Fragment thr:off
>           Encryption key:off
>           Link Quality=0/100  Signal level=-256 dBm  Noise level=-256 dBm
>           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
>
>
>
> $ iwlist eth1 scan
>
> eth1     no scan results
>
> The "radio disabled by hardware" looks like a problem to me   ?
>
>
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/c76fa00b/attachment.bin>

From a.mcguinness at ntlworld.com  Tue Aug 14 23:17:59 2007
From: a.mcguinness at ntlworld.com (Andrew McGuinness)
Date: Tue, 14 Aug 2007 21:17:59 +0000
Subject: Dell 1390 not detecting AP
In-Reply-To: <46C20F0C.2030405@Wetwork.Net>
References: <46C20B02.90003@ntlworld.com> <46C20F0C.2030405@Wetwork.Net>
Message-ID: <46C21C07.6000809@ntlworld.com>

Ehud Gavron wrote:
> ifconfig eth1 up
> 
> E
> 

No, I did that.  It didn't complain, but it didn't do anything either

$ ifconfig eth1 up
$ ifconfig eth1

eth1      Link encap:Ethernet  HWaddr 00:19:7E:41:C1:B4
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:611 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:25662 (25.0 KiB)
          Interrupt:11 Base address:0x8000

$ iwlist eth1 scan
Warning: Driver for device eth1 has been compiled with version 22
of Wireless Extension, while this program supports up to version 20.
Some things may be broken...

eth1     No scan results



> Andrew McGuinness wrote:
>> I'm not able to detect my AP with a Dell 1390 mini-pci using bcm43xx
>>
>> I appreciate that the driver is under very heavy development at the
>> moment, and I'm willing to try the bcm43 if that will help.
>>
>> Details follow:
>>
>>
>> The Acer Aspire 3680 contains the following (lspci -v)
>>
>> 03:00.0 Network controller: Broadcom Corporation Dell Wireless 1390 WLAN
>> Mini-PCI Card (rev 01)
>>     Subsystem: AMBIT Microsystem Corp. Unknown device 0422
>>     Flags: bus master, fast devsel, latency 0, IRQ 17
>>     Memory at 34100000 (32-bit, non-prefetchable) [size=16K]
>>     Capabilities: [40] Power Management version 2
>>     Capabilities: [58] Message Signalled Interrupts: Mask- 64bit-
>> Queue=0/0
>> Enable-
>>     Capabilities: [d0] Express Legacy Endpoint IRQ 0
>>     Capabilities: [100] Advanced Error Reporting
>>     Capabilities: [13c] Virtual Channel
>>
>> and from lspci -n
>>
>> 03:00.0 0280: 14e4:4311 (rev 01)
>>
>>
>> I built a 2.6.21 kernel from debian, with the combined_2.6.21.patch from
>>  lwfinger.dynalias.org
>>
>> I got the v3 firmware wl_apsta-3.130.20.0.o and used fwcutter to create
>> the .fw files in /lib/firmware
>>
>> $ dmesg | grep bcm
>>
>> bcm43xx driver
>> bcm43xx: Chip ID 0x4311, rev 0x1
>> bcm43xx: Number of cores: 4
>> bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
>> bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
>> bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
>> bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
>> bcm43xx: PHY connected
>> bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
>> bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
>> bcm43xx: Radio turned off
>> bcm43xx: Radio turned off
>> bcm43xx: PHY connected
>> bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
>> bcm43xx: Radio turned on
>> bcm43xx: Radio disabled by hardware
>> bcm43xx: Chip initialized
>> bcm43xx: 32-bit DMA initialized
>> bcm43xx: Keys cleared
>> bcm43xx: Selected 802.11 core (phytype 2)
>> bcm43xx: set security called, .level = 0, .enabled = 0, .encrypt = 0
>>
>> $ iwconfig eth1 essid arobeia
>>
>> $ iwconfig eth1
>>
>> Warning: Driver for device eth1 has been compiled with version 22
>> of Wireless Extension, while this program supports up to version 20.
>> Some things may be broken...
>>
>> eth1      IEEE 802.11b/g  ESSID:"arobeia"  Nickname:"Broadcom 4311"
>>           Mode:Managed  Frequency=2.472 GHz  Access Point: Invalid
>>           Bit Rate=1 Mb/s   Tx-Power=18 dBm
>>           RTS thr:off   Fragment thr:off
>>           Encryption key:off
>>           Link Quality=0/100  Signal level=-256 dBm  Noise level=-256 dBm
>>           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
>>
>>
>>
>> $ iwlist eth1 scan
>>
>> eth1     no scan results
>>
>> The "radio disabled by hardware" looks like a problem to me   ?
>>
>>
>>   



From larry.finger at lwfinger.net  Tue Aug 14 23:42:48 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 14 Aug 2007 16:42:48 -0500
Subject: Dell 1390 not detecting AP
In-Reply-To: <46C20B02.90003@ntlworld.com>
References: <46C20B02.90003@ntlworld.com>
Message-ID: <46C221D8.2000509@lwfinger.net>

Andrew McGuinness wrote:
> I'm not able to detect my AP with a Dell 1390 mini-pci using bcm43xx
> 
> I appreciate that the driver is under very heavy development at the
> moment, and I'm willing to try the bcm43 if that will help.
> 
> 
> The "radio disabled by hardware" looks like a problem to me   ?

That is a killer and usually means that the wireless device switch is off. So far, we have found no 
devices where that can be controlled by software.

What is the make/model of your laptop? What kind of switch does it have to enable the wireless?

Larry



From larry.finger at lwfinger.net  Wed Aug 15 00:18:35 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 14 Aug 2007 17:18:35 -0500
Subject: [patch 0/7] SSB: New patch series for merge
In-Reply-To: <200708141938.33952.mb@bu3sch.de>
References: <200708141900.31273.mb@bu3sch.de> <46C1E790.3020807@lwfinger.net>
	<200708141938.33952.mb@bu3sch.de>
Message-ID: <46C22A3B.1090802@lwfinger.net>

Michael Buesch wrote:
> On Tuesday 14 August 2007 19:34:08 Larry Finger wrote:
>> Michael Buesch wrote:
>>> Hi John,
>>>
>>> This patch series catches SSB up to my
>>> current wireless-development patchset.
>>>
>>> Please merge this into wireless-dev ssb branch.
>> I had a problem with #7. My copy of John's tree still has EXPERIMENTAL for ssb. Yours does not.
> 
> Are you sure you have latest wireless-dev? It has
> been rebased again.
> 

Indeed, that was the problem. Once I got John's email and learned how to handle the new rebase, you 
patch applied just fine.

Larry




From Larry.Finger at lwfinger.net  Wed Aug 15 01:35:54 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 14 Aug 2007 18:35:54 -0500
Subject: [PATCH] b43: Kconfig indentation not right
Message-ID: <46c23c5a.GL0z6zHroRzco6L+%Larry.Finger@lwfinger.net>

The indentation (dependencies) are not right for B43.

Signed-off-by: Larry Finger <Larry.Finger at lfinger.net>
---

Index: wireless-dev/drivers/net/wireless/b43/Kconfig
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/Kconfig
+++ wireless-dev/drivers/net/wireless/b43/Kconfig
@@ -11,14 +11,14 @@ config B43
 # Auto-select SSB PCI-HOST support, if possible
 config B43_PCI_AUTOSELECT
 	bool
-	depends on SSB_PCIHOST_POSSIBLE
+	depends on SSB_PCIHOST_POSSIBLE && B43
 	select SSB_PCIHOST
 	default y
 
 # Auto-select SSB PCICORE driver, if possible
 config B43_PCICORE_AUTOSELECT
 	bool
-	depends on SSB_DRIVER_PCICORE_POSSIBLE
+	depends on SSB_DRIVER_PCICORE_POSSIBLE && B43
 	select SSB_DRIVER_PCICORE
 	default y
 


From gavron at Wetwork.Net  Wed Aug 15 04:59:41 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Tue, 14 Aug 2007 19:59:41 -0700
Subject: Linksys N card (4329)... is this an RE project...
Message-ID: <46C26C1D.2060703@Wetwork.Net>

I have a Linksys PCMCIA N card which IDs as a BCM43XG, but unfortunately 
is model 0x4329 rev 01, which is not on the hardware list as a supported 
device.
Is this something that requires RE effort... and am I tainted because 
I've looked at the Linux driver (reverse tainted) or am I clear... but 
if I start doing RE I can never contribute to the driver code?

Thanks,

Ehud


Latest "everything" kernel.

dmesg with b43 and normal firmware: [nothing]
dmesg with b43 and firmware from the Linksys file that came with it: 
[nothing]
dmesg with bcm43xx fwpostfix=".fw3" (I didn't expect it to work, but 
tried for completeness": bcm43xx driver

uname -a: Linux techeg.login.com 2.6.23-rc3 #1 SMP Tue Aug 14 17:28:00 
MST 2007 1686 1686 i386 GNU/Linux

lspci: 06:00.0 0280: 14e4:4329 (rev 01)

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070814/c949980d/attachment.bin>

From larry.finger at lwfinger.net  Wed Aug 15 06:18:07 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 14 Aug 2007 23:18:07 -0500
Subject: Linksys N card (4329)... is this an RE project...
In-Reply-To: <46C26C1D.2060703@Wetwork.Net>
References: <46C26C1D.2060703@Wetwork.Net>
Message-ID: <46C27E7F.9000206@lwfinger.net>

Ehud Gavron wrote:
> I have a Linksys PCMCIA N card which IDs as a BCM43XG, but unfortunately 
> is model 0x4329 rev 01, which is not on the hardware list as a supported 
> device.
> Is this something that requires RE effort... and am I tainted because 
> I've looked at the Linux driver (reverse tainted) or am I clear... but 
> if I start doing RE I can never contribute to the driver code?

Unofficially, my opinion is as follows:

1. Your looking at the current driver does not taint you regarding Broadcom's intellectual property.

2. Once you have worked on the decompiled Broadcom drivers, you cannot contribute code to our 
driver. That would breach the clean-room isolation. You are still allowed to test and to report 
deficiencies, but not suggest fixes.

I have no knowledge of the status of the RE of the 802.11n devices. There is some info regarding 
these devices in the V4 specs, but AFAIK, none of these have been coded. We've been busy getting 
802.11g code working.

Larry



From mistamaila at gmail.com  Wed Aug 15 06:35:29 2007
From: mistamaila at gmail.com (John H.)
Date: Tue, 14 Aug 2007 23:35:29 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <46C1DF4C.7010204@lwfinger.net>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>
	<46BD2CED.3050608@lwfinger.net>
	<5b9417770708131311n7b1ab9a3k72218c6b24f85e14@mail.gmail.com>
	<46C0CA41.1040806@lwfinger.net>
	<5b9417770708132017n4155a062vac5f1407472b1a6d@mail.gmail.com>
	<5b9417770708132226w6674b263y2a35c8ca61abdae0@mail.gmail.com>
	<46C1DF4C.7010204@lwfinger.net>
Message-ID: <5b9417770708142135w3dc30800t32891578b1a5e7a3@mail.gmail.com>

It seemed it had a more difficult time changing at one location 1.5
hours away with a different AP than the one i am back on now.  right
now it is up to 48mb/s automatically.

Is it safe to assume future releases of f7 kernel rpm will have a
workable driver such as -50 from rawhide does?

On 8/14/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > I spoke too soon.  I just tried it again and it seemed stuck on 1 mb/s
> > and there was an obvious difference in network speed.  hmm.
>
> If you don't want the auto speed adjustment, or are unhappy with it, you can change the rate setting
> with the 'iwconfig eth1 rate Y' command. As your system seems not to auto-scale very well, I would
> try values for Y of 11M, 18M, 24M, 36M, 48M, and 54M (in that order). For each speed, try a ping
> flood against your AP (ping -f 192.168.1.1, or whatever address is shown as the gateway in a 'route
> -n' command). As long as you don't see a lot of dots from the flood, it is safe to try the next
> higher speed. Once you get a failure, you might want to back off one extra speed for safety.
>
> Have you tried changing the AP's channel, if possible? You might find less interference with a
> different setting. Does your location have any other 2.4 GHz devices like portable telephones or
> baby monitors, etc. They could interfere.
>
> Larry
>
>


From larry.finger at lwfinger.net  Wed Aug 15 06:50:46 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 14 Aug 2007 23:50:46 -0500
Subject: 4311 works with fedora 7 but only at 1mb/s
In-Reply-To: <5b9417770708142135w3dc30800t32891578b1a5e7a3@mail.gmail.com>
References: <5b9417770708021447x55047db6jcbd34e9501cd8890@mail.gmail.com>	
	<5b9417770708101028h3ddd7ff7m922455bd9e491899@mail.gmail.com>	
	<b2d05de20708101040r135f373j5e82cbbf427acf5f@mail.gmail.com>	
	<5b9417770708101208p177ac51ak3444dbdb483c890@mail.gmail.com>	
	<46BD2CED.3050608@lwfinger.net>	
	<5b9417770708131311n7b1ab9a3k72218c6b24f85e14@mail.gmail.com>	
	<46C0CA41.1040806@lwfinger.net>	
	<5b9417770708132017n4155a062vac5f1407472b1a6d@mail.gmail.com>	
	<5b9417770708132226w6674b263y2a35c8ca61abdae0@mail.gmail.com>	
	<46C1DF4C.7010204@lwfinger.net>
	<5b9417770708142135w3dc30800t32891578b1a5e7a3@mail.gmail.com>
Message-ID: <46C28626.8050100@lwfinger.net>

John H. wrote:
> It seemed it had a more difficult time changing at one location 1.5
> hours away with a different AP than the one i am back on now.  right
> now it is up to 48mb/s automatically.
> 
> Is it safe to assume future releases of f7 kernel rpm will have a
> workable driver such as -50 from rawhide does?

I cannot speak for Fedora's kernel update policy. The changes that have been incorporated into the 
Rawhide kernels are now in the wireless-dev tree, and will become part of mainline eventually. Those 
changes will certainly be a part of F8.

Larry



From mejias.cavan at gmail.com  Wed Aug 15 12:12:57 2007
From: mejias.cavan at gmail.com (Cavan Mejias)
Date: Wed, 15 Aug 2007 06:12:57 -0400
Subject: debian etch wireless
In-Reply-To: <46C1D0F3.1030908@lwfinger.net>
References: <a60d15110708140810n1d9554f2od421b69668de28fb@mail.gmail.com>
	<46C1D0F3.1030908@lwfinger.net>
Message-ID: <a60d15110708150312s5cf49b9ag7253b8780b68fee1@mail.gmail.com>

debian:~# dmesg | grep bcm
bcm43xx driver
debian:~#

Above is the result. I get an ok connection with the wired network and i
have build essential and kernel headers installed for kernel 2.6.18.
Is there any more information you need?


On 8/14/07, Larry Finger <larry.finger at lwfinger.net> wrote:
>
> Cavan Mejias wrote:
> > I have a dell inspiron 1501 with debian etch installed. I installed
> > bcm43xx-fwcutter and downloaded the firmware. however my wireless light
> > does not come on at boot. lspci
> > shows:                                      05:00.0 Network controller:
> > Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card (rev 01)
> > 08:00.0 Ethernet controller: Broadcom Corporation BCM4401-B0 100Base-TX
> > (rev 02) .
> > everything else seems to function. Iwconfig doesn't list any wireless
> > extentions at all.
>
> Please send the output of 'dmesg | grep bcm'.
>
> Larry
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070815/7c2b3518/attachment.html>

From ivan.majhen at vz.t-com.hr  Wed Aug 15 13:39:33 2007
From: ivan.majhen at vz.t-com.hr (Ivan Majhen)
Date: Wed, 15 Aug 2007 13:39:33 +0200
Subject: b43-phy2 ERROR: bbatt(11) >= size of LO array
Message-ID: <200708151339.33285.ivan.majhen@vz.t-com.hr>

Hi. I'm just testing new b43 branch, and there are a lot of progress made over 
softmac version.
I'm sharing network with my friend in building where signal is very weak. I 
couldn't connect with softmac version, but with mac80211 connection is good, 
no disconnections. It is little slower than ndiswrapper, and link quality 
sometimes goes above 100  and goes fast up and down in wavemon. Ndiswrapper 
shows max 10.

ACPI: PCI Interrupt 0000:06:02.0[A] -> GSI 22 (level, low) -> IRQ 21
ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x0D, vendor 0x4243)
ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x09, vendor 0x4243)
ssb: Core 2 found: PCI (cc 0x804, rev 0x0C, vendor 0x4243)
ssb: Core 3 found: PCMCIA (cc 0x80D, rev 0x07, vendor 0x4243)
ssb: Sonics Silicon Backplane found on PCI device 0000:06:02.0
b43-phy2: Broadcom 4318 WLAN found
b43-phy2 debug: Found PHY: Analog 3, Type 2, Revision 7
b43-phy2 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 8
b43-phy2 debug: Radio turned off
b43-phy2 debug: DebugFS (CONFIG_DEBUG_FS) not enabled in kernel config
wmaster0: Selected rate control algorithm 'simple'
b43-phy2 debug: Adding Interface type 2
b43-phy2 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy2 debug: Radio turned on
b43-phy2 debug: Radio enabled by hardware
b43-phy2 ERROR: bbatt(11) >= size of LO array
b43-phy2 debug: Chip initialized
b43-phy2 debug: 32-bit DMA initialized
b43-phy2 debug: Wireless interface started
HW CONFIG: channel=1 freq=2412 phymode=3
b43-phy2 debug: Removing Interface type 2
b43-phy2 debug: Wireless interface stopped
b43-phy2 debug: DMA-32 0x0200 (RX) max used slots: 0/64
b43-phy2 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
b43-phy2 debug: DMA-32 0x0280 (TX) max used slots: 0/128
b43-phy2 debug: DMA-32 0x0260 (TX) max used slots: 0/128
b43-phy2 debug: DMA-32 0x0240 (TX) max used slots: 0/128
b43-phy2 debug: DMA-32 0x0220 (TX) max used slots: 0/128
b43-phy2 debug: DMA-32 0x0200 (TX) max used slots: 0/128
b43-phy2 debug: Radio turned off
b43-phy2 debug: Radio turned off
b43-phy2 debug: Adding Interface type 2
b43-phy2 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy2 debug: Radio turned on
b43-phy2 debug: Radio enabled by hardware
b43-phy2 debug: Chip initialized
b43-phy2 debug: 32-bit DMA initialized
b43-phy2 debug: Wireless interface started
HW CONFIG: channel=1 freq=2412 phymode=3
HW CONFIG: channel=1 freq=2412 phymode=3

Is "b43-phy2 ERROR: bbatt(11) >= size of LO array" this error normal?


From larry.finger at lwfinger.net  Wed Aug 15 14:31:59 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 07:31:59 -0500
Subject: b43-phy2 ERROR: bbatt(11) >= size of LO array
In-Reply-To: <200708151339.33285.ivan.majhen@vz.t-com.hr>
References: <200708151339.33285.ivan.majhen@vz.t-com.hr>
Message-ID: <46C2F23F.9090303@lwfinger.net>

Ivan Majhen wrote:
> Hi. I'm just testing new b43 branch, and there are a lot of progress made over 
> softmac version.
> I'm sharing network with my friend in building where signal is very weak. I 
> couldn't connect with softmac version, but with mac80211 connection is good, 
> no disconnections. It is little slower than ndiswrapper, and link quality 
> sometimes goes above 100  and goes fast up and down in wavemon. Ndiswrapper 
> shows max 10.
> 
> ACPI: PCI Interrupt 0000:06:02.0[A] -> GSI 22 (level, low) -> IRQ 21
> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x0D, vendor 0x4243)
> ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x09, vendor 0x4243)
> ssb: Core 2 found: PCI (cc 0x804, rev 0x0C, vendor 0x4243)
> ssb: Core 3 found: PCMCIA (cc 0x80D, rev 0x07, vendor 0x4243)
> ssb: Sonics Silicon Backplane found on PCI device 0000:06:02.0
> b43-phy2: Broadcom 4318 WLAN found
> b43-phy2 debug: Found PHY: Analog 3, Type 2, Revision 7
> b43-phy2 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 8
> b43-phy2 debug: Radio turned off
> b43-phy2 debug: DebugFS (CONFIG_DEBUG_FS) not enabled in kernel config
> wmaster0: Selected rate control algorithm 'simple'
> b43-phy2 debug: Adding Interface type 2
> b43-phy2 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy2 debug: Radio turned on
> b43-phy2 debug: Radio enabled by hardware
> b43-phy2 ERROR: bbatt(11) >= size of LO array
> b43-phy2 debug: Chip initialized
> b43-phy2 debug: 32-bit DMA initialized
> b43-phy2 debug: Wireless interface started
> HW CONFIG: channel=1 freq=2412 phymode=3
> b43-phy2 debug: Removing Interface type 2
> b43-phy2 debug: Wireless interface stopped
> b43-phy2 debug: DMA-32 0x0200 (RX) max used slots: 0/64
> b43-phy2 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
> b43-phy2 debug: DMA-32 0x0280 (TX) max used slots: 0/128
> b43-phy2 debug: DMA-32 0x0260 (TX) max used slots: 0/128
> b43-phy2 debug: DMA-32 0x0240 (TX) max used slots: 0/128
> b43-phy2 debug: DMA-32 0x0220 (TX) max used slots: 0/128
> b43-phy2 debug: DMA-32 0x0200 (TX) max used slots: 0/128
> b43-phy2 debug: Radio turned off
> b43-phy2 debug: Radio turned off
> b43-phy2 debug: Adding Interface type 2
> b43-phy2 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy2 debug: Radio turned on
> b43-phy2 debug: Radio enabled by hardware
> b43-phy2 debug: Chip initialized
> b43-phy2 debug: 32-bit DMA initialized
> b43-phy2 debug: Wireless interface started
> HW CONFIG: channel=1 freq=2412 phymode=3
> HW CONFIG: channel=1 freq=2412 phymode=3
> 
> Is "b43-phy2 ERROR: bbatt(11) >= size of LO array" this error normal?

If you had bothered to look at the archives, you would know the answer to this question!

Larry


From larry.finger at lwfinger.net  Wed Aug 15 14:33:40 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 07:33:40 -0500
Subject: debian etch wireless
In-Reply-To: <a60d15110708150312s5cf49b9ag7253b8780b68fee1@mail.gmail.com>
References: <a60d15110708140810n1d9554f2od421b69668de28fb@mail.gmail.com>	
	<46C1D0F3.1030908@lwfinger.net>
	<a60d15110708150312s5cf49b9ag7253b8780b68fee1@mail.gmail.com>
Message-ID: <46C2F2A4.6080802@lwfinger.net>

Cavan Mejias wrote:
> 
> 
> debian:~# dmesg | grep bcm
> bcm43xx driver
> debian:~#
> 
> Above is the result. I get an ok connection with the wired network and i 
> have build essential and kernel headers installed for kernel 2.6.18.
> Is there any more information you need? 

No. We are no longer supporting kernels older than 2.6.20. Grab kernels 2.6.21 of 2.6.22 and your 
system will work.

Larry



From mb at bu3sch.de  Wed Aug 15 14:43:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 15 Aug 2007 14:43:51 +0200
Subject: [PATCH] b43: Kconfig indentation not right
In-Reply-To: <46c23c5a.GL0z6zHroRzco6L+%Larry.Finger@lwfinger.net>
References: <46c23c5a.GL0z6zHroRzco6L+%Larry.Finger@lwfinger.net>
Message-ID: <200708151443.52170.mb@bu3sch.de>

On Wednesday 15 August 2007 01:35:54 Larry Finger wrote:
> The indentation (dependencies) are not right for B43.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lfinger.net>

Yes I know. Thanks for this.

> 
> Index: wireless-dev/drivers/net/wireless/b43/Kconfig
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43/Kconfig
> +++ wireless-dev/drivers/net/wireless/b43/Kconfig
> @@ -11,14 +11,14 @@ config B43
>  # Auto-select SSB PCI-HOST support, if possible
>  config B43_PCI_AUTOSELECT
>  	bool
> -	depends on SSB_PCIHOST_POSSIBLE
> +	depends on SSB_PCIHOST_POSSIBLE && B43
>  	select SSB_PCIHOST
>  	default y
>  
>  # Auto-select SSB PCICORE driver, if possible
>  config B43_PCICORE_AUTOSELECT
>  	bool
> -	depends on SSB_DRIVER_PCICORE_POSSIBLE
> +	depends on SSB_DRIVER_PCICORE_POSSIBLE && B43
>  	select SSB_DRIVER_PCICORE
>  	default y
>  
> 
> 



-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Wed Aug 15 14:58:09 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 07:58:09 -0500
Subject: Update to ssb-sprom README
Message-ID: <46C2F861.5070602@lwfinger.net>

This patch adds a small tutorial to the README of ssb-sprom. There is a steep learning curve for
this tool - I hope this will help.

Larry

Index: sprom/README
===================================================================
--- sprom.orig/README
+++ sprom/README
@@ -13,3 +13,80 @@ Requirements
  ------------

  1)	C99 compatible compiler.
+
+Usage
+-----
+
+The contents of the sprom are exposed to the user in sysfs. This tool can, in
+principle, read and write the sprom in place; however, making a mistake during
+sprom writing could render your device unusable. For this reason, we recommend
+copying the sprom contents to disk as the first step. This copy can then be
+modified until it contains the desired new information. Only then and with
+caution should the sprom be rewritten. DO NOT MAKE ANY CHANGES UNLESS YOU KNOW
+WHAT YOU ARE DOING!!!! You have been warned!!!
+
+Obtaining a disk copy of the sprom contents
+-------------------------------------------
+
+This file name for the sprom contents depends on the bus layout of the specific
+computer being used and will be something cryptic like
+
+/sys/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb_sprom
+
+It is not recommended that you try to type the name. Instead, you should
+use the following commands to get the working copy:
+
+SSB_SPROM=`find /sys -name ssb_sprom`
+sudo cat $SSB_SPROM > ssb_sprom_copy
+
+Newbie Note: In the first line, those symbols are back ticks (usually found
+near the <ESC> key, not forward ticks usually found near the <CR> (enter) key.
+
+Modifying the contents of the working copy
+------------------------------------------
+
+You may now look at the contents of your sprom with the command
+
+ssb-sprom -i ssb_sprom_copy -P
+
+As an example, let us suppose that you have purchased a Dell mini-pci card to
+use in an HP laptop. The HP BIOS refuses to use the card when the pcivendor is
+Dell (code 0x1028), not HP (code 0x103C). From the dump above, we learn that the
+pcivendor code is a 16-bit quantity stored at 0x06. To change that code, we use
+the commands
+
+ssb-sprom -i ssb_sprom_copy -o ssb_sprom_copy -s 0x06,0x3C
+ssb-sprom -i ssb_sprom_copy -o ssb_sprom_copy -s 0x07.0x10
+
+to write the two bytes separately. The documentation implies that these data
+could be written as a single 16-bit quantity; however, that doesn't work at
+the moment.
+
+Once you think you have updated correctly, use
+
+ssb-sprom -i ssb_sprom_copy -P
+
+again to check the contents.
+
+Rewriting the sprom contents
+----------------------------
+
+Once the sprom contents are the way you want them, and presumably correct,
+you are ready to rewrite the file. If you have logged out since the working
+copy of the sprom contents was obtained, the symbol containing the location
+of the file in sysfs will have been lost. In any case, it is safe to reload
+that symbol again with
+
+SSB_SPROM=`find /sys -name ssb_sprom`
+
+You are then ready to rewrite the sprom with
+
+sudo cat ssb_sprom_copy > $SSB_SPROM
+
+Once again, you are urged to be absolutely certain of the contents of the
+working copy BEFORE taking this step. If your interface becomes unusable as a
+result of writing incorrect data into the sprom, the responsibility is YOURS.
+Once again, you have been warned.
+
+----------
+



From mejias.cavan at gmail.com  Wed Aug 15 15:08:51 2007
From: mejias.cavan at gmail.com (Cavan Mejias)
Date: Wed, 15 Aug 2007 09:08:51 -0400
Subject: debian etch wireless
In-Reply-To: <46C2F2A4.6080802@lwfinger.net>
References: <a60d15110708140810n1d9554f2od421b69668de28fb@mail.gmail.com>
	<46C1D0F3.1030908@lwfinger.net>
	<a60d15110708150312s5cf49b9ag7253b8780b68fee1@mail.gmail.com>
	<46C2F2A4.6080802@lwfinger.net>
Message-ID: <a60d15110708150608r5d274ea0g33fdb3d303b597b9@mail.gmail.com>

Ok, thanks.
        Cavan

On 8/15/07, Larry Finger <larry.finger at lwfinger.net> wrote:
>
> Cavan Mejias wrote:
> >
> >
> > debian:~# dmesg | grep bcm
> > bcm43xx driver
> > debian:~#
> >
> > Above is the result. I get an ok connection with the wired network and i
> > have build essential and kernel headers installed for kernel 2.6.18.
> > Is there any more information you need?
>
> No. We are no longer supporting kernels older than 2.6.20. Grab kernels
> 2.6.21 of 2.6.22 and your
> system will work.
>
> Larry
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070815/f5bc9264/attachment.html>

From schwab at suse.de  Wed Aug 15 15:20:38 2007
From: schwab at suse.de (Andreas Schwab)
Date: Wed, 15 Aug 2007 15:20:38 +0200
Subject: Update to ssb-sprom README
In-Reply-To: <46C2F861.5070602@lwfinger.net> (Larry Finger's message of "Wed\, 
	15 Aug 2007 07\:58\:09 -0500")
References: <46C2F861.5070602@lwfinger.net>
Message-ID: <je643hdjdl.fsf@sykes.suse.de>

Larry Finger <Larry.Finger at lwfinger.net> writes:

> +You are then ready to rewrite the sprom with
> +
> +sudo cat ssb_sprom_copy > $SSB_SPROM

This won't work as an unprivileged user who won't be able to open the
file for writing. You probably need to use cp instead.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From hs4233 at mail.mn-solutions.de  Wed Aug 15 15:26:49 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Wed, 15 Aug 2007 15:26:49 +0200
Subject: Update to ssb-sprom README
In-Reply-To: <je643hdjdl.fsf@sykes.suse.de>
References: <46C2F861.5070602@lwfinger.net> <je643hdjdl.fsf@sykes.suse.de>
Message-ID: <200708151526.49474.hs4233@mail.mn-solutions.de>

> > +sudo cat ssb_sprom_copy > $SSB_SPROM
>
> This won't work as an unprivileged user who won't be able to
> open the file for writing.

sudo "cat ssb_sprom_copy > $SSB_SPROM"

should do the trick.


From larry.finger at lwfinger.net  Wed Aug 15 15:37:51 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 08:37:51 -0500
Subject: Update to ssb-sprom README
In-Reply-To: <je643hdjdl.fsf@sykes.suse.de>
References: <46C2F861.5070602@lwfinger.net> <je643hdjdl.fsf@sykes.suse.de>
Message-ID: <46C301AF.4010307@lwfinger.net>

Andreas Schwab wrote:
> Larry Finger <Larry.Finger at lwfinger.net> writes:
> 
>> +You are then ready to rewrite the sprom with
>> +
>> +sudo cat ssb_sprom_copy > $SSB_SPROM
> 
> This won't work as an unprivileged user who won't be able to open the
> file for writing. You probably need to use cp instead.

Doesn't the sudo give the necessary privilege? I haven't tested writing the sprom, but it certainly 
does for the read, which I have tested. As the file has 600 as its permissions, I thought that read 
and write would be symmetric.

Larry


From Larry.Finger at lwfinger.net  Wed Aug 15 15:53:41 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 08:53:41 -0500
Subject: Error message from b43
Message-ID: <46C30565.7010208@lwfinger.net>

Michael,

Using the git version of b43 that was updated last night, I am getting the following error for my 
BCM4311:

b43-phy0 ERROR: Adjusting Local Oscillator to an uncalibrated control pair: rfatt=3,no-padmix bbatt=2
b43-phy0 debug: Invalid LO control pair (I: 111, Q: 111)
  [<ffffffff8855e4a2>] :b43:b43_lo_write+0x47/0x77
  [<ffffffff8855e53e>] :b43:b43_lo_g_adjust_to+0x6c/0x77
  [<ffffffff8855ea4f>] :b43:lo_measure_restore+0xdd/0x352
  [<ffffffff8855fcde>] :b43:b43_lo_g_measure+0x101a/0x1057
  [<ffffffff8854d7a3>] :b43:b43_shm_read16+0xaa/0xb6
  [<ffffffff8854f852>] :b43:do_periodic_work+0x44/0x181
  [<ffffffff8854de25>] :b43:b43_synchronize_irq+0x26/0x2a
  [<ffffffff885526ef>] :b43:b43_periodic_work_handler+0x10a/0x1e1
  [<ffffffff885525e5>] :b43:b43_periodic_work_handler+0x0/0x1e1

If you need any further information, please advise.

With this version, I am getting an autoload of module ssb; however, b43 and friends (mac80211, etc.) 
still have to be manually loaded with modprobe. From a test printk, I know that the init function 
for b43_pci_bridge_driver has been run, but I have no idea on how to debug any further.

Larry


From schwab at suse.de  Wed Aug 15 15:47:34 2007
From: schwab at suse.de (Andreas Schwab)
Date: Wed, 15 Aug 2007 15:47:34 +0200
Subject: Update to ssb-sprom README
In-Reply-To: <46C301AF.4010307@lwfinger.net> (Larry Finger's message of "Wed\, 
	15 Aug 2007 08\:37\:51 -0500")
References: <46C2F861.5070602@lwfinger.net> <je643hdjdl.fsf@sykes.suse.de>
	<46C301AF.4010307@lwfinger.net>
Message-ID: <jey7gcdi4p.fsf@sykes.suse.de>

Larry Finger <larry.finger at lwfinger.net> writes:

> Andreas Schwab wrote:
>> Larry Finger <Larry.Finger at lwfinger.net> writes:
>>
>>> +You are then ready to rewrite the sprom with
>>> +
>>> +sudo cat ssb_sprom_copy > $SSB_SPROM
>>
>> This won't work as an unprivileged user who won't be able to open the
>> file for writing. You probably need to use cp instead.
>
> Doesn't the sudo give the necessary privilege?

The redirection happens earlier.

> I haven't tested writing the sprom, but it certainly does for the
> read, which I have tested. As the file has 600 as its permissions, I
> thought that read and write would be symmetric.

Try this for symmetry: sudo cat < $SSB_SPROM

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From johannes at sipsolutions.net  Wed Aug 15 16:04:12 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 15 Aug 2007 16:04:12 +0200
Subject: Error message from b43
In-Reply-To: <46C30565.7010208@lwfinger.net>
References: <46C30565.7010208@lwfinger.net>
Message-ID: <1187186652.27608.7.camel@johannes.berg>

On Wed, 2007-08-15 at 08:53 -0500, Larry Finger wrote:

> From a test printk, I know that the init function 
> for b43_pci_bridge_driver has been run, but I have no idea on how to debug any further.

udevmonitor :)

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070815/649d18b8/attachment.pgp>

From johannes at sipsolutions.net  Wed Aug 15 16:04:51 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 15 Aug 2007 16:04:51 +0200
Subject: Update to ssb-sprom README
In-Reply-To: <46C301AF.4010307@lwfinger.net>
References: <46C2F861.5070602@lwfinger.net> <je643hdjdl.fsf@sykes.suse.de>
	<46C301AF.4010307@lwfinger.net>
Message-ID: <1187186691.27608.9.camel@johannes.berg>

On Wed, 2007-08-15 at 08:37 -0500, Larry Finger wrote:

> Doesn't the sudo give the necessary privilege? I haven't tested writing the sprom, but it certainly 
> does for the read, which I have tested. As the file has 600 as its permissions, I thought that read 
> and write would be symmetric.

In the example, the redirection to the file was done outside of the
privileged process, cf. the example Holger gave.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070815/2b469417/attachment.pgp>

From larry.finger at lwfinger.net  Wed Aug 15 16:02:34 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 09:02:34 -0500
Subject: Update to ssb-sprom README
In-Reply-To: <jey7gcdi4p.fsf@sykes.suse.de>
References: <46C2F861.5070602@lwfinger.net>
	<je643hdjdl.fsf@sykes.suse.de>	<46C301AF.4010307@lwfinger.net>
	<jey7gcdi4p.fsf@sykes.suse.de>
Message-ID: <46C3077A.3040600@lwfinger.net>

Andreas Schwab wrote:
> Larry Finger <larry.finger at lwfinger.net> writes:
> 
>> Andreas Schwab wrote:
>>> Larry Finger <Larry.Finger at lwfinger.net> writes:
>>>
>>>> +You are then ready to rewrite the sprom with
>>>> +
>>>> +sudo cat ssb_sprom_copy > $SSB_SPROM
>>> This won't work as an unprivileged user who won't be able to open the
>>> file for writing. You probably need to use cp instead.
>> Doesn't the sudo give the necessary privilege?
> 
> The redirection happens earlier.
> 
>> I haven't tested writing the sprom, but it certainly does for the
>> read, which I have tested. As the file has 600 as its permissions, I
>> thought that read and write would be symmetric.
> 
> Try this for symmetry: sudo cat < $SSB_SPROM

That one gets a message "bash: $SSB_PROM: ambiguous redirect".

I have modified the README to use cp as you suggested. Thanks for the tutorial on redirect. I've 
always been weak on that part of shell programming.

Larry


From mb at bu3sch.de  Wed Aug 15 16:03:32 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 15 Aug 2007 16:03:32 +0200
Subject: Error message from b43
In-Reply-To: <46C30565.7010208@lwfinger.net>
References: <46C30565.7010208@lwfinger.net>
Message-ID: <200708151603.32292.mb@bu3sch.de>

On Wednesday 15 August 2007 15:53:41 Larry Finger wrote:
> Michael,
> 
> Using the git version of b43 that was updated last night, I am getting the following error for my 
> BCM4311:
> 
> b43-phy0 ERROR: Adjusting Local Oscillator to an uncalibrated control pair: rfatt=3,no-padmix bbatt=2
> b43-phy0 debug: Invalid LO control pair (I: 111, Q: 111)
>   [<ffffffff8855e4a2>] :b43:b43_lo_write+0x47/0x77
>   [<ffffffff8855e53e>] :b43:b43_lo_g_adjust_to+0x6c/0x77
>   [<ffffffff8855ea4f>] :b43:lo_measure_restore+0xdd/0x352
>   [<ffffffff8855fcde>] :b43:b43_lo_g_measure+0x101a/0x1057
>   [<ffffffff8854d7a3>] :b43:b43_shm_read16+0xaa/0xb6
>   [<ffffffff8854f852>] :b43:do_periodic_work+0x44/0x181
>   [<ffffffff8854de25>] :b43:b43_synchronize_irq+0x26/0x2a
>   [<ffffffff885526ef>] :b43:b43_periodic_work_handler+0x10a/0x1e1
>   [<ffffffff885525e5>] :b43:b43_periodic_work_handler+0x0/0x1e1

Yeah, well. LO calibration is _still_ broken.


-- 
Greetings Michael.


From schwab at suse.de  Wed Aug 15 16:04:44 2007
From: schwab at suse.de (Andreas Schwab)
Date: Wed, 15 Aug 2007 16:04:44 +0200
Subject: Update to ssb-sprom README
In-Reply-To: <46C3077A.3040600@lwfinger.net> (Larry Finger's message of "Wed\, 
	15 Aug 2007 09\:02\:34 -0500")
References: <46C2F861.5070602@lwfinger.net> <je643hdjdl.fsf@sykes.suse.de>
	<46C301AF.4010307@lwfinger.net> <jey7gcdi4p.fsf@sykes.suse.de>
	<46C3077A.3040600@lwfinger.net>
Message-ID: <jetzr0dhc3.fsf@sykes.suse.de>

Larry Finger <larry.finger at lwfinger.net> writes:

> Andreas Schwab wrote:
>> Try this for symmetry: sudo cat < $SSB_SPROM
>
> That one gets a message "bash: $SSB_PROM: ambiguous redirect".

You'll have to set SSB_SPROM first, of course.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From mb at bu3sch.de  Wed Aug 15 16:04:52 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 15 Aug 2007 16:04:52 +0200
Subject: Update to ssb-sprom README
In-Reply-To: <46C2F861.5070602@lwfinger.net>
References: <46C2F861.5070602@lwfinger.net>
Message-ID: <200708151604.52162.mb@bu3sch.de>

On Wednesday 15 August 2007 14:58:09 Larry Finger wrote:
> +SSB_SPROM=`find /sys -name ssb_sprom`
> +sudo cat $SSB_SPROM > ssb_sprom_copy
> +
> +Newbie Note: In the first line, those symbols are back ticks (usually found
> +near the <ESC> key, not forward ticks usually found near the <CR> (enter) key.

In Bash you can avoid these ugly backticks by doing

SSB_SPROM=$(find /sys -name ssb_sprom)

-- 
Greetings Michael.


From schwab at suse.de  Wed Aug 15 16:19:55 2007
From: schwab at suse.de (Andreas Schwab)
Date: Wed, 15 Aug 2007 16:19:55 +0200
Subject: Update to ssb-sprom README
In-Reply-To: <200708151604.52162.mb@bu3sch.de> (Michael Buesch's message of
	"Wed\, 15 Aug 2007 16\:04\:52 +0200")
References: <46C2F861.5070602@lwfinger.net> <200708151604.52162.mb@bu3sch.de>
Message-ID: <jeps1odgms.fsf@sykes.suse.de>

Michael Buesch <mb at bu3sch.de> writes:

> In Bash you can avoid these ugly backticks by doing
>
> SSB_SPROM=$(find /sys -name ssb_sprom)

Actually every modern shell can do this.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From larry.finger at lwfinger.net  Wed Aug 15 16:48:27 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 09:48:27 -0500
Subject: Error message from b43
In-Reply-To: <1187186652.27608.7.camel@johannes.berg>
References: <46C30565.7010208@lwfinger.net>
	<1187186652.27608.7.camel@johannes.berg>
Message-ID: <46C3123B.3000402@lwfinger.net>

Johannes Berg wrote:
> On Wed, 2007-08-15 at 08:53 -0500, Larry Finger wrote:
> 
>> From a test printk, I know that the init function 
>> for b43_pci_bridge_driver has been run, but I have no idea on how to debug any further.
> 
> udevmonitor :)

First I unloaded ssb, then with a 'modprobe ssb', I get the following:

UEVENT[1187189016.185357] add@/module/ssb
UEVENT[1187189016.186371] add@/bus/ssb
UEVENT[1187189016.187641] add@/bus/pci/drivers/b43-pci-bridge
UDEV  [1187189016.225764] add@/module/ssb
UDEV  [1187189016.228773] add@/bus/pci/drivers/b43-pci-bridge
UDEV  [1187189016.230766] add@/bus/ssb
UEVENT[1187189016.266327] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
UEVENT[1187189016.268608] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
UDEV  [1187189016.302841] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
UDEV  [1187189016.303355] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1

With a 'modprobe b43', these additional messages are produced:

UEVENT[1187189085.996256] add@/module/cfg80211
UEVENT[1187189085.997389] add@/class/ieee80211
UDEV  [1187189086.031303] add@/module/cfg80211
UDEV  [1187189086.031575] add@/class/ieee80211
UEVENT[1187189086.056159] add@/module/mac80211
UDEV  [1187189086.077608] add@/module/mac80211
UEVENT[1187189086.092564] add@/module/b43
UEVENT[1187189086.094196] add@/bus/ssb/drivers/b43
UDEV  [1187189086.114966] add@/module/b43
UDEV  [1187189086.123717] add@/bus/ssb/drivers/b43
UEVENT[1187189086.172867] add@/class/ieee80211/phy0
UEVENT[1187189086.175896] add@/class/net/wmaster0
UDEV  [1187189086.208288] add@/class/ieee80211/phy0
UEVENT[1187189086.212998] add@/module/rc80211_simple
UDEV  [1187189086.234194] add@/module/rc80211_simple
UEVENT[1187189086.260406] add@/class/net/wlan0
UEVENT[1187189086.346887] move@/class/net/eth1
UDEV  [1187189086.461561] move@/class/net/eth1
UDEV  [1187189086.496711] add@/class/net/wmaster0
UDEV  [1187189086.607917] add@/class/net/wlan0
UEVENT[1187189086.683003] add@/class/firmware/ssb0:0
UEVENT[1187189086.826188] remove@/class/firmware/ssb0:0
UEVENT[1187189086.826945] add@/class/firmware/ssb0:0
UDEV  [1187189086.834036] add@/class/firmware/ssb0:0
UDEV  [1187189086.839719] remove@/class/firmware/ssb0:0
UEVENT[1187189086.871654] remove@/class/firmware/ssb0:0
UEVENT[1187189086.871721] add@/class/firmware/ssb0:0
UDEV  [1187189086.879235] add@/class/firmware/ssb0:0
UEVENT[1187189086.887354] remove@/class/firmware/ssb0:0
UEVENT[1187189086.887416] add@/class/firmware/ssb0:0
UDEV  [1187189086.892782] remove@/class/firmware/ssb0:0
UDEV  [1187189086.896807] add@/class/firmware/ssb0:0
UDEV  [1187189086.906557] remove@/class/firmware/ssb0:0
UEVENT[1187189086.916091] remove@/class/firmware/ssb0:0
UDEV  [1187189086.916091] remove@/class/firmware/ssb0:0
UDEV  [1187189086.924879] add@/class/firmware/ssb0:0
UEVENT[1187189087.271710] add@/class/misc/hw_random
UDEV  [1187189087.286379] add@/class/misc/hw_random
UEVENT[1187189099.819217] add@/module/nfs
UDEV  [1187189099.837340] add@/module/nfs

Larry


From mb at bu3sch.de  Wed Aug 15 16:52:09 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 15 Aug 2007 16:52:09 +0200
Subject: Error message from b43
In-Reply-To: <46C3123B.3000402@lwfinger.net>
References: <46C30565.7010208@lwfinger.net>
	<1187186652.27608.7.camel@johannes.berg>
	<46C3123B.3000402@lwfinger.net>
Message-ID: <200708151652.09973.mb@bu3sch.de>

On Wednesday 15 August 2007 16:48:27 Larry Finger wrote:
> Johannes Berg wrote:
> > On Wed, 2007-08-15 at 08:53 -0500, Larry Finger wrote:
> > 
> >> From a test printk, I know that the init function 
> >> for b43_pci_bridge_driver has been run, but I have no idea on how to debug any further.
> > 
> > udevmonitor :)
> 
> First I unloaded ssb, then with a 'modprobe ssb', I get the following:
> 
> UEVENT[1187189016.185357] add@/module/ssb
> UEVENT[1187189016.186371] add@/bus/ssb
> UEVENT[1187189016.187641] add@/bus/pci/drivers/b43-pci-bridge
> UDEV  [1187189016.225764] add@/module/ssb
> UDEV  [1187189016.228773] add@/bus/pci/drivers/b43-pci-bridge
> UDEV  [1187189016.230766] add@/bus/ssb
> UEVENT[1187189016.266327] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
> UEVENT[1187189016.268608] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
> UDEV  [1187189016.302841] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
> UDEV  [1187189016.303355] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
> 
> With a 'modprobe b43', these additional messages are produced:
> 
> UEVENT[1187189085.996256] add@/module/cfg80211
> UEVENT[1187189085.997389] add@/class/ieee80211
> UDEV  [1187189086.031303] add@/module/cfg80211
> UDEV  [1187189086.031575] add@/class/ieee80211
> UEVENT[1187189086.056159] add@/module/mac80211
> UDEV  [1187189086.077608] add@/module/mac80211
> UEVENT[1187189086.092564] add@/module/b43
> UEVENT[1187189086.094196] add@/bus/ssb/drivers/b43
> UDEV  [1187189086.114966] add@/module/b43
> UDEV  [1187189086.123717] add@/bus/ssb/drivers/b43
> UEVENT[1187189086.172867] add@/class/ieee80211/phy0
> UEVENT[1187189086.175896] add@/class/net/wmaster0
> UDEV  [1187189086.208288] add@/class/ieee80211/phy0
> UEVENT[1187189086.212998] add@/module/rc80211_simple
> UDEV  [1187189086.234194] add@/module/rc80211_simple
> UEVENT[1187189086.260406] add@/class/net/wlan0
> UEVENT[1187189086.346887] move@/class/net/eth1
> UDEV  [1187189086.461561] move@/class/net/eth1
> UDEV  [1187189086.496711] add@/class/net/wmaster0
> UDEV  [1187189086.607917] add@/class/net/wlan0
> UEVENT[1187189086.683003] add@/class/firmware/ssb0:0
> UEVENT[1187189086.826188] remove@/class/firmware/ssb0:0
> UEVENT[1187189086.826945] add@/class/firmware/ssb0:0
> UDEV  [1187189086.834036] add@/class/firmware/ssb0:0
> UDEV  [1187189086.839719] remove@/class/firmware/ssb0:0
> UEVENT[1187189086.871654] remove@/class/firmware/ssb0:0
> UEVENT[1187189086.871721] add@/class/firmware/ssb0:0
> UDEV  [1187189086.879235] add@/class/firmware/ssb0:0
> UEVENT[1187189086.887354] remove@/class/firmware/ssb0:0
> UEVENT[1187189086.887416] add@/class/firmware/ssb0:0
> UDEV  [1187189086.892782] remove@/class/firmware/ssb0:0
> UDEV  [1187189086.896807] add@/class/firmware/ssb0:0
> UDEV  [1187189086.906557] remove@/class/firmware/ssb0:0
> UEVENT[1187189086.916091] remove@/class/firmware/ssb0:0
> UDEV  [1187189086.916091] remove@/class/firmware/ssb0:0
> UDEV  [1187189086.924879] add@/class/firmware/ssb0:0
> UEVENT[1187189087.271710] add@/class/misc/hw_random
> UDEV  [1187189087.286379] add@/class/misc/hw_random
> UEVENT[1187189099.819217] add@/module/nfs
> UDEV  [1187189099.837340] add@/module/nfs
> 
> Larry
> 
> 

I have no idea what you are doing. It works for me.

-- 
Greetings Michael.


From johannes at sipsolutions.net  Wed Aug 15 17:01:49 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 15 Aug 2007 17:01:49 +0200
Subject: Error message from b43
In-Reply-To: <46C3123B.3000402@lwfinger.net>
References: <46C30565.7010208@lwfinger.net>
	<1187186652.27608.7.camel@johannes.berg>
	<46C3123B.3000402@lwfinger.net>
Message-ID: <1187190110.27608.13.camel@johannes.berg>

On Wed, 2007-08-15 at 09:48 -0500, Larry Finger wrote:

> First I unloaded ssb, then with a 'modprobe ssb', I get the following:
> 
> UEVENT[1187189016.185357] add@/module/ssb
> UEVENT[1187189016.186371] add@/bus/ssb
> UEVENT[1187189016.187641] add@/bus/pci/drivers/b43-pci-bridge
> UDEV  [1187189016.225764] add@/module/ssb
> UDEV  [1187189016.228773] add@/bus/pci/drivers/b43-pci-bridge
> UDEV  [1187189016.230766] add@/bus/ssb
> UEVENT[1187189016.266327] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
> UEVENT[1187189016.268608] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
> UDEV  [1187189016.302841] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
> UDEV  [1187189016.303355] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1

The latter events should have generated modaliases. Can you check with 

	/usr/sbin/udevmonitor --kernel --env

please?

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070815/deda13c8/attachment.pgp>

From larry.finger at lwfinger.net  Wed Aug 15 17:24:53 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 10:24:53 -0500
Subject: Error message from b43
In-Reply-To: <1187190110.27608.13.camel@johannes.berg>
References: <46C30565.7010208@lwfinger.net>	
	<1187186652.27608.7.camel@johannes.berg>
	<46C3123B.3000402@lwfinger.net>
	<1187190110.27608.13.camel@johannes.berg>
Message-ID: <46C31AC5.4010805@lwfinger.net>

Johannes Berg wrote:
>> UDEV  [1187189016.303355] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
> 
> The latter events should have generated modaliases. Can you check with 
> 
> 	/usr/sbin/udevmonitor --kernel --env
  My udevmonitir has no --kernel switch (V103-12), but the output following modprobe ssb is

UEVENT[1187191043.549443] add@/module/ssb
ACTION=add
DEVPATH=/module/ssb
SUBSYSTEM=module
SEQNUM=1754

UEVENT[1187191043.550830] add@/bus/ssb
ACTION=add
DEVPATH=/bus/ssb
SUBSYSTEM=bus
SEQNUM=1755

UEVENT[1187191043.552353] add@/bus/pci/drivers/b43-pci-bridge
ACTION=add
DEVPATH=/bus/pci/drivers/b43-pci-bridge
SUBSYSTEM=drivers
SEQNUM=1756

UDEV  [1187191043.557216] add@/module/ssb
UDEV_LOG=3
ACTION=add
DEVPATH=/module/ssb
SUBSYSTEM=module
SEQNUM=1754
UDEVD_EVENT=1

UDEV  [1187191043.562378] add@/bus/ssb
UDEV_LOG=3
ACTION=add
DEVPATH=/bus/ssb
SUBSYSTEM=bus
SEQNUM=1755
UDEVD_EVENT=1

UDEV  [1187191043.562761] add@/bus/pci/drivers/b43-pci-bridge
UDEV_LOG=3
ACTION=add
DEVPATH=/bus/pci/drivers/b43-pci-bridge
SUBSYSTEM=drivers
SEQNUM=1756
UDEVD_EVENT=1

UEVENT[1187191043.629313] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
ACTION=add
DEVPATH=/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
SUBSYSTEM=ssb
SEQNUM=1757
PHYSDEVBUS=ssb
MODALIAS=ssb:v4243id0812rev0a

UEVENT[1187191043.631184] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
ACTION=add
DEVPATH=/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
SUBSYSTEM=ssb
SEQNUM=1758
PHYSDEVBUS=ssb
MODALIAS=ssb:v4243id0817rev03

UDEV  [1187191043.642342] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
UDEV_LOG=3
ACTION=add
DEVPATH=/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
SUBSYSTEM=ssb
SEQNUM=1757
PHYSDEVBUS=ssb
MODALIAS=ssb:v4243id0812rev0a
UDEVD_EVENT=1

UDEV  [1187191043.648915] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
UDEV_LOG=3
ACTION=add
DEVPATH=/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
SUBSYSTEM=ssb
SEQNUM=1758
PHYSDEVBUS=ssb
MODALIAS=ssb:v4243id0817rev03
UDEVD_EVENT=1

The 812 core on my BCM4311 has rev 0xA. Is that 817 core interfering?

Larry




From johannes at sipsolutions.net  Wed Aug 15 17:36:27 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 15 Aug 2007 17:36:27 +0200
Subject: Error message from b43
In-Reply-To: <46C31AC5.4010805@lwfinger.net>
References: <46C30565.7010208@lwfinger.net>
	<1187186652.27608.7.camel@johannes.berg>
	<46C3123B.3000402@lwfinger.net>
	<1187190110.27608.13.camel@johannes.berg>
	<46C31AC5.4010805@lwfinger.net>
Message-ID: <1187192187.5141.3.camel@johannes.berg>

On Wed, 2007-08-15 at 10:24 -0500, Larry Finger wrote:

> MODALIAS=ssb:v4243id0812rev0a

Oh. I see. Somewhere case got confused, the modalias is this:

alias:          ssb:v4243id0812rev0A*

Apparently we have to use %.2X and not %.2x in the uevent generation
code. Michael, want a patch or can you just fix it?

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070815/8080718a/attachment.pgp>

From larry.finger at lwfinger.net  Wed Aug 15 18:05:23 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 11:05:23 -0500
Subject: Error message from b43
In-Reply-To: <1187192187.5141.3.camel@johannes.berg>
References: <46C30565.7010208@lwfinger.net>	
	<1187186652.27608.7.camel@johannes.berg>
	<46C3123B.3000402@lwfinger.net>	
	<1187190110.27608.13.camel@johannes.berg>
	<46C31AC5.4010805@lwfinger.net>
	<1187192187.5141.3.camel@johannes.berg>
Message-ID: <46C32443.1010601@lwfinger.net>

Johannes Berg wrote:
> On Wed, 2007-08-15 at 10:24 -0500, Larry Finger wrote:
> 
>> MODALIAS=ssb:v4243id0812rev0a
> 
> Oh. I see. Somewhere case got confused, the modalias is this:
> 
> alias:          ssb:v4243id0812rev0A*
> 
> Apparently we have to use %.2X and not %.2x in the uevent generation
> code. Michael, want a patch or can you just fix it?

This patch did not fix the problem:

Index: wireless-dev/drivers/ssb/main.c
===================================================================
--- wireless-dev.orig/drivers/ssb/main.c
+++ wireless-dev/drivers/ssb/main.c
@@ -331,7 +331,7 @@ static int ssb_device_uevent(struct devi

         ret = add_uevent_var(envp, num_envp, &i,
                              buffer, buffer_size, &length,
-                            "MODALIAS=ssb:v%.4xid%.4xrev%.2x",
+                            "MODALIAS=ssb:v%.4xid%.4xrev%.2X",
                              ssb_dev->id.vendor, ssb_dev->id.coreid,
                              ssb_dev->id.revision);
         envp[i] = NULL;

With this patch, the output of udevmonitor --env now is:

UEVENT[1187193083.069367] add@/module/ssb
ACTION=add
DEVPATH=/module/ssb
SUBSYSTEM=module
SEQNUM=1748

UEVENT[1187193083.070838] add@/bus/ssb
ACTION=add
DEVPATH=/bus/ssb
SUBSYSTEM=bus
SEQNUM=1749

UEVENT[1187193083.072529] add@/bus/pci/drivers/b43-pci-bridge
ACTION=add
DEVPATH=/bus/pci/drivers/b43-pci-bridge
SUBSYSTEM=drivers
SEQNUM=1750

UDEV  [1187193083.076531] add@/module/ssb
UDEV_LOG=3
ACTION=add
DEVPATH=/module/ssb
SUBSYSTEM=module
SEQNUM=1748
UDEVD_EVENT=1

UDEV  [1187193083.080356] add@/bus/ssb
UDEV_LOG=3
ACTION=add
DEVPATH=/bus/ssb
SUBSYSTEM=bus
SEQNUM=1749
UDEVD_EVENT=1

UDEV  [1187193083.083627] add@/bus/pci/drivers/b43-pci-bridge
UDEV_LOG=3
ACTION=add
DEVPATH=/bus/pci/drivers/b43-pci-bridge
SUBSYSTEM=drivers
SEQNUM=1750
UDEVD_EVENT=1

UEVENT[1187193083.148865] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
ACTION=add
DEVPATH=/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
SUBSYSTEM=ssb
SEQNUM=1751
PHYSDEVBUS=ssb
MODALIAS=ssb:v4243id0812rev0A

UEVENT[1187193083.150987] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
ACTION=add
DEVPATH=/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
SUBSYSTEM=ssb
SEQNUM=1752
PHYSDEVBUS=ssb
MODALIAS=ssb:v4243id0817rev03

UDEV  [1187193083.156997] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
UDEV_LOG=3
ACTION=add
DEVPATH=/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:1
SUBSYSTEM=ssb
SEQNUM=1752
PHYSDEVBUS=ssb
MODALIAS=ssb:v4243id0817rev03
UDEVD_EVENT=1

UDEV  [1187193083.162392] add@/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
UDEV_LOG=3
ACTION=add
DEVPATH=/devices/pci0000:00/0000:00:02.0/0000:01:00.0/ssb0:0
SUBSYSTEM=ssb
SEQNUM=1751
PHYSDEVBUS=ssb
MODALIAS=ssb:v4243id0812rev0A
UDEVD_EVENT=1

Am I correct in assuming that we don't need the PCIe core listed here because that driver is built 
into ssb?

Larry


From johannes at sipsolutions.net  Wed Aug 15 18:12:33 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 15 Aug 2007 18:12:33 +0200
Subject: Error message from b43
In-Reply-To: <46C32443.1010601@lwfinger.net>
References: <46C30565.7010208@lwfinger.net>
	<1187186652.27608.7.camel@johannes.berg>
	<46C3123B.3000402@lwfinger.net>
	<1187190110.27608.13.camel@johannes.berg>
	<46C31AC5.4010805@lwfinger.net>
	<1187192187.5141.3.camel@johannes.berg> <46C32443.1010601@lwfinger.net>
Message-ID: <1187194353.5141.8.camel@johannes.berg>

On Wed, 2007-08-15 at 11:05 -0500, Larry Finger wrote:

> > alias:          ssb:v4243id0812rev0A*

> --- wireless-dev.orig/drivers/ssb/main.c
> +++ wireless-dev/drivers/ssb/main.c
> @@ -331,7 +331,7 @@ static int ssb_device_uevent(struct devi
> 
>          ret = add_uevent_var(envp, num_envp, &i,
>                               buffer, buffer_size, &length,
> -                            "MODALIAS=ssb:v%.4xid%.4xrev%.2x",
> +                            "MODALIAS=ssb:v%.4xid%.4xrev%.2X",

That didn't fix it? Now I'm confused. Maybe it's not case-sensitive
after all and the problem is elsewhere.

> MODALIAS=ssb:v4243id0812rev0A

as expected. You're right that we don't want those cores listed that
we're already using or that are known to be useless.

What happens if you try by hand? Something like
modprobe "ssb:v4243id0812rev0A"

and what does "modalias b43 | grep ssb" show?

joahnnes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070815/d81f1f60/attachment.pgp>

From mb at bu3sch.de  Wed Aug 15 18:14:06 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 15 Aug 2007 18:14:06 +0200
Subject: Error message from b43
In-Reply-To: <1187194353.5141.8.camel@johannes.berg>
References: <46C30565.7010208@lwfinger.net> <46C32443.1010601@lwfinger.net>
	<1187194353.5141.8.camel@johannes.berg>
Message-ID: <200708151814.06868.mb@bu3sch.de>

On Wednesday 15 August 2007 18:12:33 Johannes Berg wrote:
> On Wed, 2007-08-15 at 11:05 -0500, Larry Finger wrote:
> 
> > > alias:          ssb:v4243id0812rev0A*
> 
> > --- wireless-dev.orig/drivers/ssb/main.c
> > +++ wireless-dev/drivers/ssb/main.c
> > @@ -331,7 +331,7 @@ static int ssb_device_uevent(struct devi
> > 
> >          ret = add_uevent_var(envp, num_envp, &i,
> >                               buffer, buffer_size, &length,
> > -                            "MODALIAS=ssb:v%.4xid%.4xrev%.2x",
> > +                            "MODALIAS=ssb:v%.4xid%.4xrev%.2X",
> 
> That didn't fix it? Now I'm confused. Maybe it's not case-sensitive
> after all and the problem is elsewhere.

Are you sure you reloaded the ssb module?
I sometimes forget that and wonder why changes don't work. :)

-- 
Greetings Michael.


From johannes at sipsolutions.net  Wed Aug 15 18:20:15 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 15 Aug 2007 18:20:15 +0200
Subject: Error message from b43
In-Reply-To: <200708151814.06868.mb@bu3sch.de>
References: <46C30565.7010208@lwfinger.net> <46C32443.1010601@lwfinger.net>
	<1187194353.5141.8.camel@johannes.berg>
	<200708151814.06868.mb@bu3sch.de>
Message-ID: <1187194815.5141.10.camel@johannes.berg>

On Wed, 2007-08-15 at 18:14 +0200, Michael Buesch wrote:

> Are you sure you reloaded the ssb module?
> I sometimes forget that and wonder why changes don't work. :)

Well, his output did show the uppercase letters "0A" :)

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070815/83cbcace/attachment.pgp>

From larry.finger at lwfinger.net  Wed Aug 15 18:29:38 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 11:29:38 -0500
Subject: Error message from b43
In-Reply-To: <200708151814.06868.mb@bu3sch.de>
References: <46C30565.7010208@lwfinger.net> <46C32443.1010601@lwfinger.net>
	<1187194353.5141.8.camel@johannes.berg>
	<200708151814.06868.mb@bu3sch.de>
Message-ID: <46C329F2.8050802@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 15 August 2007 18:12:33 Johannes Berg wrote:
>> On Wed, 2007-08-15 at 11:05 -0500, Larry Finger wrote:
>>
>>>> alias:          ssb:v4243id0812rev0A*
>>> --- wireless-dev.orig/drivers/ssb/main.c
>>> +++ wireless-dev/drivers/ssb/main.c
>>> @@ -331,7 +331,7 @@ static int ssb_device_uevent(struct devi
>>>
>>>          ret = add_uevent_var(envp, num_envp, &i,
>>>                               buffer, buffer_size, &length,
>>> -                            "MODALIAS=ssb:v%.4xid%.4xrev%.2x",
>>> +                            "MODALIAS=ssb:v%.4xid%.4xrev%.2X",
>> That didn't fix it? Now I'm confused. Maybe it's not case-sensitive
>> after all and the problem is elsewhere.
> 
> Are you sure you reloaded the ssb module?
> I sometimes forget that and wonder why changes don't work. :)
> 

Yes. My build generated a new kernel as I had done a git pull in the interim, thus I even had to reboot.

Larry



From larry.finger at lwfinger.net  Wed Aug 15 18:30:04 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 11:30:04 -0500
Subject: Error message from b43
In-Reply-To: <1187194353.5141.8.camel@johannes.berg>
References: <46C30565.7010208@lwfinger.net>	
	<1187186652.27608.7.camel@johannes.berg>
	<46C3123B.3000402@lwfinger.net>	
	<1187190110.27608.13.camel@johannes.berg>
	<46C31AC5.4010805@lwfinger.net>	
	<1187192187.5141.3.camel@johannes.berg>
	<46C32443.1010601@lwfinger.net>
	<1187194353.5141.8.camel@johannes.berg>
Message-ID: <46C32A0C.8030405@lwfinger.net>

Johannes Berg wrote:
> 
> That didn't fix it? Now I'm confused. Maybe it's not case-sensitive
> after all and the problem is elsewhere.
> 
>> MODALIAS=ssb:v4243id0812rev0A
> 
> as expected. You're right that we don't want those cores listed that
> we're already using or that are known to be useless.
> 
> What happens if you try by hand? Something like
> modprobe "ssb:v4243id0812rev0A"
> 
> and what does "modalias b43 | grep ssb" show?

It is case sensitive. Using 'modprobe "ssb:v4243id0812rev0A"' loads the module, whereas 'modprobe 
"ssb:v4243id0812rev0a"' yields 'FATAL: Module ssb:v4243id0812rev0a not found'. It is a multi-part 
problem.

My system doesn't have a modalias command. A grep for v4243 in the b43 directory yields:

drivers/net/wireless/b43/b43.mod.c:MODULE_ALIAS("ssb:v4243id0812rev05*");
drivers/net/wireless/b43/b43.mod.c:MODULE_ALIAS("ssb:v4243id0812rev06*");
drivers/net/wireless/b43/b43.mod.c:MODULE_ALIAS("ssb:v4243id0812rev07*");
drivers/net/wireless/b43/b43.mod.c:MODULE_ALIAS("ssb:v4243id0812rev09*");
drivers/net/wireless/b43/b43.mod.c:MODULE_ALIAS("ssb:v4243id0812rev0A*");

I hope that gives the same info.

Larry




From johannes at sipsolutions.net  Wed Aug 15 18:39:18 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 15 Aug 2007 18:39:18 +0200
Subject: Error message from b43
In-Reply-To: <46C32A0C.8030405@lwfinger.net>
References: <46C30565.7010208@lwfinger.net>
	<1187186652.27608.7.camel@johannes.berg>
	<46C3123B.3000402@lwfinger.net>
	<1187190110.27608.13.camel@johannes.berg>
	<46C31AC5.4010805@lwfinger.net>
	<1187192187.5141.3.camel@johannes.berg> <46C32443.1010601@lwfinger.net>
	<1187194353.5141.8.camel@johannes.berg> <46C32A0C.8030405@lwfinger.net>
Message-ID: <1187195958.5141.13.camel@johannes.berg>

On Wed, 2007-08-15 at 11:30 -0500, Larry Finger wrote:

> It is case sensitive. Using 'modprobe "ssb:v4243id0812rev0A"' loads the module, whereas 'modprobe 
> "ssb:v4243id0812rev0a"' yields 'FATAL: Module ssb:v4243id0812rev0a not found'. It is a multi-part 
> problem.

Yeah, I just tested that too.

> drivers/net/wireless/b43/b43.mod.c:MODULE_ALIAS("ssb:v4243id0812rev0A*");

So that is the right alias now though. I'm rather confused now as to why
udev isn't able to load the module then. Actually, what if you modprobe
with the asterisk? For me that works fine.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070815/646844f4/attachment.pgp>

From johannes at sipsolutions.net  Wed Aug 15 18:43:07 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 15 Aug 2007 18:43:07 +0200
Subject: Error message from b43
In-Reply-To: <1187195958.5141.13.camel@johannes.berg>
References: <46C30565.7010208@lwfinger.net>
	<1187186652.27608.7.camel@johannes.berg>
	<46C3123B.3000402@lwfinger.net>
	<1187190110.27608.13.camel@johannes.berg>
	<46C31AC5.4010805@lwfinger.net>
	<1187192187.5141.3.camel@johannes.berg> <46C32443.1010601@lwfinger.net>
	<1187194353.5141.8.camel@johannes.berg> <46C32A0C.8030405@lwfinger.net>
	<1187195958.5141.13.camel@johannes.berg>
Message-ID: <1187196187.5141.16.camel@johannes.berg>

On Wed, 2007-08-15 at 18:39 +0200, Johannes Berg wrote:
> Actually, what if you modprobe
> with the asterisk? For me that works fine.

scratch that, wrong way around

So, fact is:
 * if you load manually the module "ssb:v4243id0812rev0A" then it's
   loaded fine
 * if that exact same modalias is generated it doesn't load
   automatically

There must be something else wrong. The uppercase letter definitely was
a problem, but now it seems to be something else, possibly in your
udev/modprobe.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070815/9a80b4aa/attachment.pgp>

From larry.finger at lwfinger.net  Wed Aug 15 19:00:40 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 15 Aug 2007 12:00:40 -0500
Subject: Error message from b43
In-Reply-To: <1187196187.5141.16.camel@johannes.berg>
References: <46C30565.7010208@lwfinger.net>	
	<1187186652.27608.7.camel@johannes.berg>
	<46C3123B.3000402@lwfinger.net>	
	<1187190110.27608.13.camel@johannes.berg>
	<46C31AC5.4010805@lwfinger.net>	
	<1187192187.5141.3.camel@johannes.berg>
	<46C32443.1010601@lwfinger.net>	
	<1187194353.5141.8.camel@johannes.berg>
	<46C32A0C.8030405@lwfinger.net>	
	<1187195958.5141.13.camel@johannes.berg>
	<1187196187.5141.16.camel@johannes.berg>
Message-ID: <46C33138.8040709@lwfinger.net>

Johannes Berg wrote:
> On Wed, 2007-08-15 at 18:39 +0200, Johannes Berg wrote:
>> Actually, what if you modprobe
>> with the asterisk? For me that works fine.
> 
> scratch that, wrong way around
> 
> So, fact is:
>  * if you load manually the module "ssb:v4243id0812rev0A" then it's
>    loaded fine
>  * if that exact same modalias is generated it doesn't load
>    automatically
> 
> There must be something else wrong. The uppercase letter definitely was
> a problem, but now it seems to be something else, possibly in your
> udev/modprobe.

I have been planning a switch away from openSUSE for some time because they refuse to fix things 
like this. I filed a bug report on udev last week and got the response "it will be fixed in 10.3, 
but we won't do anything about 10.2". I already have the Fedora DVD ready, but that will take a 
while to do. I'll let you know when I'm back up.

At least we fixed one bug.

Larry


From hs4233 at mail.mn-solutions.de  Thu Aug 16 08:45:14 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Thu, 16 Aug 2007 08:45:14 +0200
Subject: Update to ssb-sprom README
In-Reply-To: <jeps1odgms.fsf@sykes.suse.de>
References: <46C2F861.5070602@lwfinger.net> <200708151604.52162.mb@bu3sch.de>
	<jeps1odgms.fsf@sykes.suse.de>
Message-ID: <200708160845.14970.hs4233@mail.mn-solutions.de>

> > SSB_SPROM=$(find /sys -name ssb_sprom)
>
> Actually every modern shell can do this.

And I cannot see why one is more ugly than the other version :-)


From Larry.Finger at lwfinger.net  Fri Aug 17 01:40:23 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 16 Aug 2007 18:40:23 -0500
Subject: Does auto-loading of b43 work for you?
Message-ID: <46C4E067.3060307@lwfinger.net>

Has anyone used the new driver variation known as b43 from that branch of wireless-dev and gotten 
auto-loading at bootup of the b43 module on i386 or x86_64 platforms. It still doesn't work here 
even after upgrading to the latest version of udev. Before I post to LKML regarding this problem, I 
would like to get an idea if is restricted to my system, or if it is a general problem with x86 
architectures. We know it works on PPC platforms. If your system is also failing, I would like to 
know your distro.

Thanks,

Larry


From geekypenguin at gmail.com  Fri Aug 17 01:54:42 2007
From: geekypenguin at gmail.com (Jory A. Pratt)
Date: Thu, 16 Aug 2007 18:54:42 -0500
Subject: Does auto-loading of b43 work for you?
In-Reply-To: <46C4E067.3060307@lwfinger.net>
References: <46C4E067.3060307@lwfinger.net>
Message-ID: <46C4E3C2.5040003@gmail.com>

Larry Finger wrote:
> Has anyone used the new driver variation known as b43 from that branch of wireless-dev and gotten 
> auto-loading at bootup of the b43 module on i386 or x86_64 platforms. It still doesn't work here 
> even after upgrading to the latest version of udev. Before I post to LKML regarding this problem, I 
> would like to get an idea if is restricted to my system, or if it is a general problem with x86 
> architectures. We know it works on PPC platforms. If your system is also failing, I would like to 
> know your distro.
>
> Thanks,
>
> Larry
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
>   


Works fine here on my x86_64 gentoo install :)

-Jory


From johannes at sipsolutions.net  Fri Aug 17 02:52:56 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 17 Aug 2007 02:52:56 +0200
Subject: mac80211 IPv6 problems
In-Reply-To: <20070806170500.GE6442@tuxdriver.com>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<1186094778.6701.6.camel@shinybook.infradead.org>
	<20070803005517.GA4261@tuxdriver.com>
	<200708030102.17358.flamingice@sourmilk.net>
	<20070806170500.GE6442@tuxdriver.com>
Message-ID: <1187311977.23489.93.camel@johannes.berg>

On Mon, 2007-08-06 at 13:05 -0400, John W. Linville wrote:

> --- a/net/mac80211/ieee80211.c
> +++ b/net/mac80211/ieee80211.c
> @@ -3030,9 +3030,10 @@ ieee80211_rx_h_data(struct ieee80211_txrx_data *rx)
>  		memcpy(dst, hdr->addr1, ETH_ALEN);
>  		memcpy(src, hdr->addr3, ETH_ALEN);
>  
> -		if (sdata->type != IEEE80211_IF_TYPE_STA) {
> +		if (sdata->type != IEEE80211_IF_TYPE_STA ||
> +		    (is_multicast_ether_addr(dst) &&
> +		     !compare_ether_addr(src, dev->dev_addr)))
>  			return TXRX_DROP;

I can confirm that this works (applies if you s/ieee80211.c/rx.c/) for
IPv6 link local addresses, and it's definitely the right thing to do
here.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070817/e2dded4f/attachment.pgp>

From linville at tuxdriver.com  Fri Aug 17 15:49:41 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Fri, 17 Aug 2007 09:49:41 -0400
Subject: mac80211 IPv6 problems
In-Reply-To: <1187311977.23489.93.camel@johannes.berg>
References: <46b1fde0.b+weBDN75J0SPe2a%Larry.Finger@lwfinger.net>
	<1186094778.6701.6.camel@shinybook.infradead.org>
	<20070803005517.GA4261@tuxdriver.com>
	<200708030102.17358.flamingice@sourmilk.net>
	<20070806170500.GE6442@tuxdriver.com>
	<1187311977.23489.93.camel@johannes.berg>
Message-ID: <20070817134941.GB6090@tuxdriver.com>

On Fri, Aug 17, 2007 at 02:52:56AM +0200, Johannes Berg wrote:
> On Mon, 2007-08-06 at 13:05 -0400, John W. Linville wrote:
> 
> > --- a/net/mac80211/ieee80211.c
> > +++ b/net/mac80211/ieee80211.c
> > @@ -3030,9 +3030,10 @@ ieee80211_rx_h_data(struct ieee80211_txrx_data *rx)
> >  		memcpy(dst, hdr->addr1, ETH_ALEN);
> >  		memcpy(src, hdr->addr3, ETH_ALEN);
> >  
> > -		if (sdata->type != IEEE80211_IF_TYPE_STA) {
> > +		if (sdata->type != IEEE80211_IF_TYPE_STA ||
> > +		    (is_multicast_ether_addr(dst) &&
> > +		     !compare_ether_addr(src, dev->dev_addr)))
> >  			return TXRX_DROP;
> 
> I can confirm that this works (applies if you s/ieee80211.c/rx.c/) for
> IPv6 link local addresses, and it's definitely the right thing to do
> here.

Yes, seems so.  FWIW, this patch is in later Fedora kernels.

Unfortunately (due to the ieee80211.c -> rx.c issue you mentioned)
applying this to 2.6.23 conflicts with patches already queued for
2.6.24.  Since my experiments show that git doesn't help much in this
instance, I'll need to work something out with Dave M. if we are to
get this into 2.6.23.

If nothing else, I suppose we can just wait for 2.6.23 and send this
patch to -stable.  Would that burn anyone's biscuits?

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Fri Aug 17 16:51:46 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 17 Aug 2007 09:51:46 -0500
Subject: Need help with modules loading
In-Reply-To: <3ae72650708170055p51846c6dp8d8e5b22138f627a@mail.gmail.com>
References: <46C50902.4000502@lwfinger.net>
	<3ae72650708170055p51846c6dp8d8e5b22138f627a@mail.gmail.com>
Message-ID: <46C5B602.2060706@lwfinger.net>

Kay Sievers wrote:
> On 8/17/07, Larry Finger <Larry.Finger at lwfinger.net> wrote:
>> A new driver for the Broadcom BCM43xx devices has been written that uses mac80211, rather than
>> softmac. The newest versions of the Broadcom firmware does not support all the BCM devices.
>> Accordingly, a separate driver is being prepared that will use an older version of the firmware and
>> support these legacy devices. Unfortunately, there is not a clean separation based on PCI id's;
>> however, the revision level of the 802.11 wireless core can be used to determine which driver should
>> be used. The scheme works on most systems, but not mine and I need some help to discover why.
> 
>> The 'MODALIAS=ssb:v4243id0812rev0A' line is correct for my device. In fact issuing a modprobe
>> "ssb:v4243id0812rev0A" command results in the loading of the module. For some reason, this does not
>> happen automatically.
>>
>> Initially, I suspected that my version of udev (103-13) was too old; however, upgrading to version
>> 114 did not help. My module-init-tools are V 3.2.2 and my distro is the x86_64 version of openSUSE 10.2.
> 
> openSUSE 10.2 used a whitelist of buses which trigger module loading.
> It's in the udev sysconfig. rules and /sbin/hwup.
> 
> The easiest is probably to add a rule for that bus:
>   ACTION=="add", SUBSYSTEM=="ssb", ENV{MODALIAS}=="?*",
> RUN+="/sbin/modprobe $env{MODALIAS}"
> 
> openSUSE 10.3 will call modprobe directly, the whitelist and the whole
> hwup logic is removed in the meantime.

Thanks for the help. A new rule in sysconfig.rules took care of the problem.

I added the bcm43xx developers mailing list to this reply. For their benefit, this is the patch that 
fixed my system:

Index: /etc/udev/rules.d/80-sysconfig.rules
===================================================================
--- /etc/udev/rules.d.orig/80-sysconfig.rules
+++ /etc/udev/rules.d/80-sysconfig.rules
@@ -15,5 +15,6 @@ SUBSYSTEM=="pnp", ACTION=="add", RUN+="/
  SUBSYSTEM=="ide", ACTION=="add", RUN+="/sbin/hwup ide-devpath-%p -o hotplug"
  SUBSYSTEM=="input", KERNEL=="input[0-9]*", ACTION=="add", RUN+="/sbin/hwup input-devpath-%p -o 
hotplug"
  SUBSYSTEM=="platform", ACTION=="add", RUN+="/sbin/hwup platform-devpath-%p -o hotplug"
+SUBSYSTEM=="ssb", ACTION=="add", ENV{MODALIAS}=="?*", RUN+="/sbin/modprobe $env{MODALIAS}"

  LABEL="sysconfig_end"


Larry


From linville at tuxdriver.com  Fri Aug 17 16:33:07 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Fri, 17 Aug 2007 10:33:07 -0400
Subject: Does auto-loading of b43 work for you?
In-Reply-To: <46C4E067.3060307@lwfinger.net>
References: <46C4E067.3060307@lwfinger.net>
Message-ID: <20070817143307.GC6090@tuxdriver.com>

On Thu, Aug 16, 2007 at 06:40:23PM -0500, Larry Finger wrote:
> Has anyone used the new driver variation known as b43 from that branch of wireless-dev and gotten 
> auto-loading at bootup of the b43 module on i386 or x86_64 platforms. It still doesn't work here 
> even after upgrading to the latest version of udev. Before I post to LKML regarding this problem, I 
> would like to get an idea if is restricted to my system, or if it is a general problem with x86 
> architectures. We know it works on PPC platforms. If your system is also failing, I would like to 
> know your distro.

Seems to work fine for me w/ latest wireless-dev built w/ mostly-stock
(had to change BCM43XX-MAC80211 to B43) F-7 kernel config on T41 w/ F-7.
Don't even have the "%X" patch.

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Fri Aug 17 17:59:59 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 17 Aug 2007 10:59:59 -0500
Subject: Does auto-loading of b43 work for you?
In-Reply-To: <20070817143307.GC6090@tuxdriver.com>
References: <46C4E067.3060307@lwfinger.net>
	<20070817143307.GC6090@tuxdriver.com>
Message-ID: <46C5C5FF.3030901@lwfinger.net>

John W. Linville wrote:
> On Thu, Aug 16, 2007 at 06:40:23PM -0500, Larry Finger wrote:
>> Has anyone used the new driver variation known as b43 from that branch of wireless-dev and gotten 
>> auto-loading at bootup of the b43 module on i386 or x86_64 platforms. It still doesn't work here 
>> even after upgrading to the latest version of udev. Before I post to LKML regarding this problem, I 
>> would like to get an idea if is restricted to my system, or if it is a general problem with x86 
>> architectures. We know it works on PPC platforms. If your system is also failing, I would like to 
>> know your distro.
> 
> Seems to work fine for me w/ latest wireless-dev built w/ mostly-stock
> (had to change BCM43XX-MAC80211 to B43) F-7 kernel config on T41 w/ F-7.
> Don't even have the "%X" patch.

After posting on LKML, I got the answer - it is a peculiarity of openSUSE 10.2. The "%X" patch is 
needed if you have a BCM4311, which has an 802.11 core with revision level 10. My systems are now 
working.

Larry


From Larry.Finger at lwfinger.net  Fri Aug 17 18:12:05 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 17 Aug 2007 11:12:05 -0500
Subject: [RFC] b43: New help text for Kconfig
Message-ID: <46C5C8D5.2050009@lwfinger.net>

Michael,

Now that I have solved the module loading problem on my openSUSE 10.2 systems, I'm nearly ready to 
push the b43legacy patch to John.

Is it your plan to stay with the current firmware naming scheme, or are you going to change to what 
Johannes proposed?

For the help text in b43's Kconfig, what do you think of the following?

Index: wireless-dev/drivers/net/wireless/b43/Kconfig
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/Kconfig
+++ wireless-dev/drivers/net/wireless/b43/Kconfig
@@ -6,7 +6,14 @@ config B43
         select HW_RANDOM
         ---help---
           This is an experimental driver for the Broadcom 43xx wireless chip,
-         found in the Apple Airport Extreme and various other devices.
+         found in the Apple Airport Extreme and various other devices. This
+         driver supports 802.11a and 802.11g, but not 802.11b. As a result,
+         BCM4301 and BCM4303 are not supported - use b43legacy instead.
+
+         This driver uses V4 firmware, which must be installed separately using
+         b43-fwcutter.
+
+         This driver can be built as a module (recommended) that will be called "b43".

  # Auto-select SSB PCI-HOST support, if possible
  config B43_PCI_AUTOSELECT

The corresponding text for b43legacy would be

+config B43LEGACY
+       tristate "Broadcom BCM43xx legacy wireless support (mac80211 stack)"
+       depends on SSB_POSSIBLE && MAC80211 && WLAN_80211 && EXPERIMENTAL
+       select SSB
+       select FW_LOADER
+       select HW_RANDOM
+       ---help---
+         This is a driver for 802.11b devices from Broadcom (BCM4301 and
+         BCM4303).  It is also the driver for early model 802.11g chips (BCM4306
+         Ver. 2) that were used in the Linksys WPC54G V1 PCMCIA devices. Newer
+         devices need b43. It is safe to include both b43legacy and b43 as the
+         ssb driver will load the correct version for your device.
+
+         This driver uses V3 firmware, which must be installed separately using
+         b43-fwcutter.
+
+         This driver can be compiled as a module (recommended) that will be
+         called "b43legacy".
+

Thanks,

Larry


From richie at coderworld.net  Fri Aug 17 19:06:31 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Fri, 17 Aug 2007 19:06:31 +0200
Subject: Does auto-loading of b43 work for you?
In-Reply-To: <46C4E067.3060307@lwfinger.net>
References: <46C4E067.3060307@lwfinger.net>
Message-ID: <200708171906.31227.richie@coderworld.net>

On Friday 17 August 2007 01:40:23 Larry Finger wrote:
> Has anyone used the new driver variation known as b43 from that branch of
> wireless-dev and gotten auto-loading at bootup of the b43 module on i386 or
> x86_64 platforms. It still doesn't work here even after upgrading to the
> latest version of udev. Before I post to LKML regarding this problem, I
> would like to get an idea if is restricted to my system, or if it is a
> general problem with x86 architectures. We know it works on PPC platforms.
> If your system is also failing, I would like to know your distro.
>
> Thanks,
>
> Larry

It does NOT load for me on ubuntu feisty (uptodate).

uname -a: 
Linux richie-laptop 2.6.23-rc3-wlgit-1 #1 SMP Thu Aug 16 18:26:42 CEST 2007 
x86_64 GNU/Linux

ssb is loaded though..


From larry.finger at lwfinger.net  Fri Aug 17 19:14:52 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 17 Aug 2007 12:14:52 -0500
Subject: Does auto-loading of b43 work for you?
In-Reply-To: <200708171906.31227.richie@coderworld.net>
References: <46C4E067.3060307@lwfinger.net>
	<200708171906.31227.richie@coderworld.net>
Message-ID: <46C5D78C.8090809@lwfinger.net>

Richard Jonsson wrote:
> On Friday 17 August 2007 01:40:23 Larry Finger wrote:
>> Has anyone used the new driver variation known as b43 from that branch of
>> wireless-dev and gotten auto-loading at bootup of the b43 module on i386 or
>> x86_64 platforms. It still doesn't work here even after upgrading to the
>> latest version of udev. Before I post to LKML regarding this problem, I
>> would like to get an idea if is restricted to my system, or if it is a
>> general problem with x86 architectures. We know it works on PPC platforms.
>> If your system is also failing, I would like to know your distro.
>>
>> Thanks,
>>
>> Larry
> 
> It does NOT load for me on ubuntu feisty (uptodate).
> 
> uname -a: 
> Linux richie-laptop 2.6.23-rc3-wlgit-1 #1 SMP Thu Aug 16 18:26:42 CEST 2007 
> x86_64 GNU/Linux
> 
> ssb is loaded though..

What files are in /etc/udev/rules.d in ubuntu? If there is something with sysconfig in its name, 
please send me a copy.

Thanks,

Larry


Larry


From mb at bu3sch.de  Fri Aug 17 19:28:25 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 17 Aug 2007 19:28:25 +0200
Subject: [RFC] b43: New help text for Kconfig
In-Reply-To: <46C5C8D5.2050009@lwfinger.net>
References: <46C5C8D5.2050009@lwfinger.net>
Message-ID: <200708171928.25288.mb@bu3sch.de>

On Friday 17 August 2007 18:12:05 Larry Finger wrote:
> Michael,
> 
> Now that I have solved the module loading problem on my openSUSE 10.2 systems, I'm nearly ready to 
> push the b43legacy patch to John.
> 
> Is it your plan to stay with the current firmware naming scheme, or are you going to change to what 
> Johannes proposed?

I am just changing that. I'm also changing the file format
to contain a header and a new IV file format to use less space.

> For the help text in b43's Kconfig, what do you think of the following?

Yeah, cool.
But add something like the following to b43, too:
> +         devices need b43. It is safe to include both b43legacy and b43 as the
> +         ssb driver will load the correct version for your device.

it's important to know that the two drivers can coexist.

> Index: wireless-dev/drivers/net/wireless/b43/Kconfig
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43/Kconfig
> +++ wireless-dev/drivers/net/wireless/b43/Kconfig
> @@ -6,7 +6,14 @@ config B43
>          select HW_RANDOM
>          ---help---
>            This is an experimental driver for the Broadcom 43xx wireless chip,
> -         found in the Apple Airport Extreme and various other devices.
> +         found in the Apple Airport Extreme and various other devices. This
> +         driver supports 802.11a and 802.11g, but not 802.11b. As a result,
> +         BCM4301 and BCM4303 are not supported - use b43legacy instead.
> +
> +         This driver uses V4 firmware, which must be installed separately using
> +         b43-fwcutter.
> +
> +         This driver can be built as a module (recommended) that will be called "b43".
> 
>   # Auto-select SSB PCI-HOST support, if possible
>   config B43_PCI_AUTOSELECT
> 
> The corresponding text for b43legacy would be
> 
> +config B43LEGACY
> +       tristate "Broadcom BCM43xx legacy wireless support (mac80211 stack)"
> +       depends on SSB_POSSIBLE && MAC80211 && WLAN_80211 && EXPERIMENTAL
> +       select SSB
> +       select FW_LOADER
> +       select HW_RANDOM
> +       ---help---
> +         This is a driver for 802.11b devices from Broadcom (BCM4301 and
> +         BCM4303).  It is also the driver for early model 802.11g chips (BCM4306
> +         Ver. 2) that were used in the Linksys WPC54G V1 PCMCIA devices. Newer
> +         devices need b43. It is safe to include both b43legacy and b43 as the
> +         ssb driver will load the correct version for your device.
> +
> +         This driver uses V3 firmware, which must be installed separately using
> +         b43-fwcutter.
> +
> +         This driver can be compiled as a module (recommended) that will be
> +         called "b43legacy".
> +
> 
> Thanks,
> 
> Larry
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
> 
> 



-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Fri Aug 17 20:11:23 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 17 Aug 2007 13:11:23 -0500
Subject: [PATCH] b32: Update Kconfig help text
Message-ID: <46c5e4cb./WY4fonkAsSkAYCK%Larry.Finger@lwfinger.net>

The help text in Kconfig for b43 is updated to indicate the devices that it
does not support and to note that it can coexist with b43legacy.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/drivers/net/wireless/b43/Kconfig
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/Kconfig
+++ wireless-dev/drivers/net/wireless/b43/Kconfig
@@ -6,7 +6,16 @@ config B43
 	select HW_RANDOM
 	---help---
 	  This is an experimental driver for the Broadcom 43xx wireless chip,
-	  found in the Apple Airport Extreme and various other devices.
+	  found in the Apple Airport Extreme and various other devices. This
+	  driver supports 802.11a and 802.11g, but not 802.11b. As a result,
+	  BCM4301 and BCM4303 are not supported - use b43legacy instead.
+	  It is safe to include both b43 and b43legacy as the ssb driver will
+	  load the correct version for your device.
+
+	  This driver uses V4 firmware, which must be installed separately using
+	  b43-fwcutter.
+
+	  This driver can be built as a module (recommended) that will be called "b43".
 
 # Auto-select SSB PCI-HOST support, if possible
 config B43_PCI_AUTOSELECT


From mb at bu3sch.de  Fri Aug 17 20:20:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 17 Aug 2007 20:20:48 +0200
Subject: [PATCH] b32: Update Kconfig help text
In-Reply-To: <46c5e4cb./WY4fonkAsSkAYCK%Larry.Finger@lwfinger.net>
References: <46c5e4cb./WY4fonkAsSkAYCK%Larry.Finger@lwfinger.net>
Message-ID: <200708172020.49102.mb@bu3sch.de>

On Friday 17 August 2007 20:11:23 Larry Finger wrote:
> The help text in Kconfig for b43 is updated to indicate the devices that it
> does not support and to note that it can coexist with b43legacy.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>

Queued, thanks!

-- 
Greetings Michael.


From gavron at Wetwork.Net  Fri Aug 17 22:55:49 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 17 Aug 2007 13:55:49 -0700
Subject: B43 deassociates a lot, especially after an ARP request
Message-ID: <46C60B55.4000100@Wetwork.Net>

Synopsis:
With "everything" tree and b43, loses AP association but then 
reassociates, usually on ARP request.

I realize there's a tcpdump in there and that doesn't really provide any 
useful info... the key is the iwevent and generating traffic.

Duplicating:
1. Use a 4311
2. Load b43 (autoloads on this kernel - Linux egdell.wetwork.net 
2.6.23-rc3 #1 SMP Tue Aug 14 14:00:46 MST 2007 x86_64 x86_64 x86_64 
GNU/Linux)
3. iwevent &
4. Ping a nonexistent local address (EG if your local network is 
192.168.1.1-254 just ping 192.168.1.X where X doesn't exist or isn't in 
the ARP table.)

Removing hardware and other factors:
1. I removed the other Buffalo Airstation 54G so that only one would be 
possibly in range with which to associate
2. After taking this log, I replaced the b43 driver with the bcmwl5.sys 
for testing purposes (yeah).  No such errors resulted.

One more thing:
In removing the W driver, I got MANY MORE association/deassociations 
than should be necessary.  That log is included LAST. 


Contents:
1. This summary
2. Following five octothorpes the first summary
3. Following five octothorpes, the "removal of the W driver, the 
insertion of B43 driver, and way too many assoc/deassocs."

Ehud
PS Michael, if you think my tree is unclean, kindly let me know which 
one you want me to build from scratch and I will.  Right now I'm using 
the "everything" git tree.


#####
[root at egdell ~]# lsmod | grep b43
b43                   121516  0
ssb                    40836  1 b43
mac80211              165512  2 rc80211_simple,b43
[root at egdell ~]# tcpdump -i eth1 &
[2] 3357
[root at egdell ~]# tcpdump: verbose output suppressed, use -v or -vv for 
full protocol decode
listening on eth1, link-type EN10MB (Ethernet), capture size 96 bytes
lsmod | grep b4313:40:26.965437 IP 4dtvpc.wetwork.net.fatpipe > 
239.255.255.250.ssdp: UDP, length 101
13:40:26.968671 IP 4dtvpc.wetwork.net.fatpipe > 239.255.255.250.ssdp: 
UDP, length 101
13:40:26.994962 IP 10.1.1.5.32780 > dns1.login.com.domain: 40335+ PTR? 
250.255.255.239.in-addr.arpa. (46)
13:40:27.046379 IP dns1.login.com.domain > 10.1.1.5.32780: 40335 
NXDomain 0/1/0 (103)
13:40:27.046657 IP 10.1.1.5.32780 > dns1.login.com.domain: 55638+ PTR? 
105.1.1.10.in-addr.arpa. (41)
13:40:27.070857 IP dns1.login.com.domain > 10.1.1.5.32780: 55638* 1/1/1 
PTR[|domain]
13:40:27.071169 IP 10.1.1.5.32780 > dns1.login.com.domain: 13656+ PTR? 
1.240.195.192.in-addr.arpa. (44)
13:40:27.090836 IP dns1.login.com.domain > 10.1.1.5.32780: 13656* 1/1/1 
(102)
13:40:27.091056 IP 10.1.1.5.32780 > dns1.login.com.domain: 30069+ PTR? 
5.1.1.10.in-addr.arpa. (39)
13:40:27.120824 IP dns1.login.com.domain > 10.1.1.5.32780: 30069 
NXDomain* 0/1/0 (88)
ping 10.1.1.15
PING 10.1.1.15 (10.1.1.15) 56(84) bytes of data.
13:40:30.966090 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:30.966252 IP 10.1.1.5.32780 > dns1.login.com.domain: 28088+ PTR? 
15.1.1.10.in-addr.arpa. (40)
13:40:30.982932 IP dns1.login.com.domain > 10.1.1.5.32780: 28088 
NXDomain* 0/1/0 (89)
13:40:31.061021 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:32.967744   eth1     New Access Point/Cell address:Not-Associated
 From 10.1.1.5 icmp_seq=2 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=3 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=4 Destination Host Unreachable
13:40:33.970465   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:40:33.970497   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
13:40:35.967199   eth1     New Access Point/Cell address:Not-Associated
13:40:36.970352   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:40:36.970386   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
 From 10.1.1.5 icmp_seq=6 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=7 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=8 Destination Host Unreachable
13:40:39.967917   eth1     New Access Point/Cell address:Not-Associated
13:40:40.971636   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:40:40.971675   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
13:40:31.266138 arp who-has 4dtvpc.wetwork.net tell gw.wetwork.net
13:40:31.266373 IP 10.1.1.5.32780 > dns1.login.com.domain: 20811+ PTR? 
1.1.1.10.in-addr.arpa. (39)
13:40:31.267087 arp who-has 4dtvpc.wetwork.net tell gw.wetwork.net
13:40:31.965991 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:31.981684 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:31.983505 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:32.965836 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:34.965529 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:35.054230 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:35.055199 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:35.965379 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:37.715857 IP wirns.wetwork.net.netbios-ns > 10.1.1.255.netbios-ns: 
NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
13:40:37.717163 IP wirns.wetwork.net.netbios-ns > 10.1.1.255.netbios-ns: 
NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
13:40:38.432594 IP wirns.wetwork.net.netbios-ns > 10.1.1.255.netbios-ns: 
NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
13:40:38.433903 IP wirns.wetwork.net.netbios-ns > 10.1.1.255.netbios-ns: 
NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
13:40:38.964921 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:39.046603 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:39.047590 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:39.149360 IP wirns.wetwork.net.netbios-ns > 10.1.1.255.netbios-ns: 
NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
13:40:39.150549 IP wirns.wetwork.net.netbios-ns > 10.1.1.255.netbios-ns: 
NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
13:40:39.964746 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:41.264614 IP 10.1.1.5.32780 > dns1.login.com.domain: 20811+ PTR? 
1.1.1.10.in-addr.arpa. (39)
13:40:41.281776 IP dns1.login.com.domain > 10.1.1.5.32780: 20811* 1/1/1 
PTR[|domain]
13:40:41.282201 IP 10.1.1.5.32781 > dns1.login.com.domain: 20920+ PTR? 
255.1.1.10.in-addr.arpa. (41)
13:40:41.299324 IP dns1.login.com.domain > 10.1.1.5.32781: 20920 
NXDomain* 0/1/0 (90)
13:40:41.299556 IP 10.1.1.5.32781 > dns1.login.com.domain: 52696+ PTR? 
110.1.1.10.in-addr.arpa. (41)
13:40:41.314314 IP dns1.login.com.domain > 10.1.1.5.32781: 52696* 2/1/1 
PTR[|domain]
 From 10.1.1.5 icmp_seq=10 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=11 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=12 Destination Host Unreachable
13:40:42.434874 IP 87.69.5.31.cable.012.net.il.6881 > 10.1.1.5.47895: P 
3599549068:3599549592(524) ack 4171871335 win 20568 <nop,nop,timestamp 
9610754 27956772>
13:40:42.434932 IP 10.1.1.5.47895 > 87.69.5.31.cable.012.net.il.6881: R 
4171871335:4171871335(0) win 0
13:40:42.436357 IP 10.1.1.5.32781 > dns1.login.com.domain: 54645+ PTR? 
31.5.69.87.in-addr.arpa. (41)
13:40:42.846894 IP dns1.login.com.domain > 10.1.1.5.32781: 54645 1/2/2 
PTR[|domain]
13:40:42.964286 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:43.040698 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:43.041728 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:43.964140 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:43.965964   eth1     New Access Point/Cell address:Not-Associated
13:40:44.968878   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:40:44.968914   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
 From 10.1.1.5 icmp_seq=14 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=15 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=16 Destination Host Unreachable
13:40:46.963703 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:47.032888 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:47.322971 IP 89.241.209.198.50155 > 10.1.1.5.42974: R 
866316561:866316561(0) win 0
13:40:47.323245 IP 10.1.1.5.32781 > dns1.login.com.domain: 8545+ PTR? 
198.209.241.89.in-addr.arpa. (45)
13:40:47.473705 IP dns1.login.com.domain > 10.1.1.5.32781: 8545 NXDomain 
0/1/0 (100)
13:40:47.963578 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:48.057633 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:48.501136 IP cpe-065-188-246-088.triad.res.rr.com.26196 > 
10.1.1.5.36232: FP 977493115:977493325(210) ack 212081105 win 16491 
<nop,nop,timestamp 1928161 27992124>
13:40:48.501190 IP 10.1.1.5.36232 > 
cpe-065-188-246-088.triad.res.rr.com.26196: R 212081105:212081105(0) win 0
13:40:48.501438 IP 10.1.1.5.32781 > dns1.login.com.domain: 63981+ PTR? 
88.246.188.65.in-addr.arpa. (44)
13:40:48.601054 IP dns1.login.com.domain > 10.1.1.5.32781: 63981 1/2/2 (186)
13:40:48.963396 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:48.979149 arp who-has 10.1.1.15 tell 10.1.1.5
 From 10.1.1.5 icmp_seq=18 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=19 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=20 Destination Host Unreachable
^@13:40:50.963091 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:51.027802 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:51.028808 arp who-has 10.1.1.15 tell 10.1.1.5
13:40:51.205973   eth1     New Access Point/Cell address:Not-Associated

--- 10.1.1.15 ping statistics ---
21 packets transmitted, 0 received, +15 errors, 100% packet loss, time 
19996ms
, pipe 3
[root at egdell ~]# 13:40:52.210881   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:40:52.210917   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
killall tcpdump
[root at egdell ~]# 13:40:55.577991   eth1     New Access Point/Cell 
address:Not-Associated
13:40:56.581245   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:40:56.581282   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
13:40:51.204330 IP 10.1.1.5.39888 > mail.login.com.imaps: P 
289257165:289257192(27) ack 3879624693 win 487 <nop,nop,timestamp 
4294905190 98929007>

66 packets captured
90 packets received by filter
0 packets dropped by kernel

[2]+  Done                    tcpdump -i eth1
[root at egdell ~]#
[root at egdell ~]# ping 10.1.1.111
PING 10.1.1.111 (10.1.1.111) 56(84) bytes of data.
64 bytes from 10.1.1.111: icmp_seq=1 ttl=64 time=71.3 ms
64 bytes from 10.1.1.111: icmp_seq=2 ttl=64 time=2.30 ms
64 bytes from 10.1.1.111: icmp_seq=3 ttl=64 time=2.78 ms
64 bytes from 10.1.1.111: icmp_seq=4 ttl=64 time=2.30 ms
64 bytes from 10.1.1.111: icmp_seq=5 ttl=64 time=2.45 ms
64 bytes from 10.1.1.111: icmp_seq=6 ttl=64 time=3.95 ms
64 bytes from 10.1.1.111: icmp_seq=7 ttl=64 time=2.23 ms
64 bytes from 10.1.1.111: icmp_seq=8 ttl=64 time=2.23 ms
64 bytes from 10.1.1.111: icmp_seq=9 ttl=64 time=2.25 ms

--- 10.1.1.111 ping statistics ---
9 packets transmitted, 9 received, 0% packet loss, time 7997ms
rtt min/avg/max/mdev = 2.237/10.210/71.350/21.622 ms
[root at egdell ~]# ping 10.1.1.11
PING 10.1.1.11 (10.1.1.11) 56(84) bytes of data.
13:43:21.044867   eth1     New Access Point/Cell address:Not-Associated
13:43:22.048544   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:43:22.048581   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
 From 10.1.1.5 icmp_seq=2 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=3 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=4 Destination Host Unreachable
64 bytes from 10.1.1.11: icmp_seq=5 ttl=64 time=7.02 ms
64 bytes from 10.1.1.11: icmp_seq=6 ttl=64 time=1.57 ms
64 bytes from 10.1.1.11: icmp_seq=7 ttl=64 time=1.58 ms
64 bytes from 10.1.1.11: icmp_seq=8 ttl=64 time=1.63 ms
64 bytes from 10.1.1.11: icmp_seq=9 ttl=64 time=1.25 ms
64 bytes from 10.1.1.11: icmp_seq=10 ttl=64 time=1.27 ms
64 bytes from 10.1.1.11: icmp_seq=11 ttl=64 time=1.29 ms
64 bytes from 10.1.1.11: icmp_seq=12 ttl=64 time=1.59 ms
64 bytes from 10.1.1.11: icmp_seq=13 ttl=64 time=1.29 ms

--- 10.1.1.11 ping statistics ---
13 packets transmitted, 9 received, +3 errors, 30% packet loss, time 11997ms
rtt min/avg/max/mdev = 1.250/2.059/7.020/1.760 ms, pipe 3
[root at egdell ~]# ping 10.1.1.15
PING 10.1.1.15 (10.1.1.15) 56(84) bytes of data.
13:43:36.908844   eth1     New Access Point/Cell address:Not-Associated
 From 10.1.1.5 icmp_seq=2 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=3 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=4 Destination Host Unreachable
13:43:37.912092   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:43:37.912128   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
13:43:39.156856   eth1     New Access Point/Cell address:Not-Associated
13:43:40.159815   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:43:40.159849   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
 From 10.1.1.5 icmp_seq=6 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=7 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=8 Destination Host Unreachable
13:43:43.156307   eth1     New Access Point/Cell address:Not-Associated
13:43:44.159338   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:43:44.159373   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
 From 10.1.1.5 icmp_seq=10 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=11 Destination Host Unreachable
 From 10.1.1.5 icmp_seq=12 Destination Host Unreachable

--- 10.1.1.15 ping statistics ---
14 packets transmitted, 0 received, +9 errors, 100% packet loss, time 
12997ms
, pipe 3
[root at egdell ~]# 13:43:48.155177   eth1     New Access Point/Cell 
address:Not-Associated
13:43:49.158529   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:43:49.158569   eth1     New Access Point/Cell address:00:07:40:9F:5B:52

[root at egdell ~]# rmmod b43



#####
eth1      IEEE 802.11g  ESSID:"wetwork"  Nickname:"egdell.wetwork.net"
          Mode:Managed  Frequency:2.462 GHz  Access Point: 
00:07:40:9F:5B:52  
          Bit Rate=54 Mb/s   Tx-Power:32 dBm  
          RTS thr:off   Fragment thr:off
          Encryption key:896A-0055-AE77-5E80-FD86-4E38-6B   Security 
mode:open
          Power Management:off
          Link Quality:48/100  Signal level:-65 dBm  Noise level:-96 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:10  Invalid misc:58   Missed beacon:0

[root at egdell ~]#
[root at egdell ~]# ifconfig eth1 down
[root at egdell ~]# rmmod ndiswrapper
[root at egdell ~]#
[root at egdell ~]# modprobe b43
[root at egdell ~]# 13:51:28.781799   eth1     Set Encryption 
key:****-****-****-****-****-****-**
13:51:28.782801   eth1     Set ESSID:"wetwork"
13:51:28.787143   eth1     Set Encryption 
key:****-****-****-****-****-****-**
13:51:28.788080   eth1     Set ESSID:"wetwork"
13:51:29.572345   eth1     Scan request completed
13:51:29.585152   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180103)
13:51:29.585182   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
13:51:29.594377   eth1     New Access Point/Cell address:Not-Associated
13:51:30.598109   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180102)
13:51:30.598156   eth1     New Access Point/Cell address:00:07:40:9F:5B:52

[root at egdell ~]# ifocn13:51:35.004427   eth1     New Access Point/Cell 
address:Not-Associated
13:51:36.007859   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180102)
13:51:36.007895   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
ifconfig eth1 up
[root at egdell ~]# 13:51:46.005021   eth1     New Access Point/Cell 
address:Not-Associated
13:51:47.008485   eth1     Custom driver 
event:ASSOCINFO(ReqIEs=0007776574776f726b010802040b160c12182432043048606c 
RespIEs=010c82848b8c929698a4b0c8e0ecdd050010180102)
13:51:47.008522   eth1     New Access Point/Cell address:00:07:40:9F:5B:52
iwconfig eth1
eth1      IEEE 802.11g  ESSID:"wetwork" 
          Mode:Managed  Frequency:2.462 GHz  Access Point: 
00:07:40:9F:5B:52  
          Bit Rate=1 Mb/s  
          Retry min limit:7   RTS thr:off   Fragment thr=2346 B  
          Encryption key:896A-0055-AE77-5E80-FD86-4E38-6B
          Link Quality=68/100  Signal level=-68 dBm  Noise level=-256 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070817/b5a846af/attachment.bin>

From Larry.Finger at lwfinger.net  Sat Aug 18 00:37:03 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 17 Aug 2007 17:37:03 -0500
Subject: [PATCH] ssb: Fix auto-load problem for devices with 802.11 core
	rev >= 10
Message-ID: <46c6230f.xC8MDU6Co5FWANra%Larry.Finger@lwfinger.net>

From: Johannes Berg <johannes at sipsolutions.net>

The auto-loading mechanism from ssb to b43 is case sensitive; however, the
present code is generating a lower-case "a" for the BCM4311, which has an
802.11 core with revision 10.

Signed-off-by: Johannes Berg <johannes at sipsolutions.net>
Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Michael,

Here is the "formal" patch for this buglet.

Larry



Index: wireless-dev/drivers/ssb/main.c
===================================================================
--- wireless-dev.orig/drivers/ssb/main.c
+++ wireless-dev/drivers/ssb/main.c
@@ -331,7 +331,7 @@ static int ssb_device_uevent(struct devi
 
 	ret = add_uevent_var(envp, num_envp, &i,
 			     buffer, buffer_size, &length,
-			     "MODALIAS=ssb:v%.4xid%.4xrev%.2x",
+			     "MODALIAS=ssb:v%.4xid%.4xrev%.2X",
 			     ssb_dev->id.vendor, ssb_dev->id.coreid,
 			     ssb_dev->id.revision);
 	envp[i] = NULL;


From johannes at sipsolutions.net  Sat Aug 18 01:26:08 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Sat, 18 Aug 2007 01:26:08 +0200
Subject: [PATCH] ssb: Fix auto-load problem for devices with 802.11
	core rev >= 10
In-Reply-To: <46c6230f.xC8MDU6Co5FWANra%Larry.Finger@lwfinger.net>
References: <46c6230f.xC8MDU6Co5FWANra%Larry.Finger@lwfinger.net>
Message-ID: <1187393168.6090.17.camel@johannes.berg>

On Fri, 2007-08-17 at 17:37 -0500, Larry Finger wrote:

>  
>  	ret = add_uevent_var(envp, num_envp, &i,
>  			     buffer, buffer_size, &length,
> -			     "MODALIAS=ssb:v%.4xid%.4xrev%.2x",
> +			     "MODALIAS=ssb:v%.4xid%.4xrev%.2X",
>  			     ssb_dev->id.vendor, ssb_dev->id.coreid,

I think Michael already has a patch for this that changes all of them,
who knows maybe at some point we need a core with ID that contains a-f
as hex digits.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070818/7bd8c196/attachment.pgp>

From mb at bu3sch.de  Sat Aug 18 16:45:07 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 18 Aug 2007 16:45:07 +0200
Subject: [PATCH] ssb: Fix auto-load problem for devices with 802.11 core
	rev >= 10
In-Reply-To: <46c6230f.xC8MDU6Co5FWANra%Larry.Finger@lwfinger.net>
References: <46c6230f.xC8MDU6Co5FWANra%Larry.Finger@lwfinger.net>
Message-ID: <200708181645.07808.mb@bu3sch.de>

On Saturday 18 August 2007 00:37:03 Larry Finger wrote:
> From: Johannes Berg <johannes at sipsolutions.net>
> 
> The auto-loading mechanism from ssb to b43 is case sensitive; however, the
> present code is generating a lower-case "a" for the BCM4311, which has an
> 802.11 core with revision 10.
> 
> Signed-off-by: Johannes Berg <johannes at sipsolutions.net>
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Michael,
> 
> Here is the "formal" patch for this buglet.
> 
> Larry
> 
> 
> 
> Index: wireless-dev/drivers/ssb/main.c
> ===================================================================
> --- wireless-dev.orig/drivers/ssb/main.c
> +++ wireless-dev/drivers/ssb/main.c
> @@ -331,7 +331,7 @@ static int ssb_device_uevent(struct devi
>  
>  	ret = add_uevent_var(envp, num_envp, &i,
>  			     buffer, buffer_size, &length,
> -			     "MODALIAS=ssb:v%.4xid%.4xrev%.2x",
> +			     "MODALIAS=ssb:v%.4xid%.4xrev%.2X",

I already queued the correct patch for this.


-- 
Greetings Michael.


From mb at bu3sch.de  Sat Aug 18 17:18:43 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 18 Aug 2007 17:18:43 +0200
Subject: B43 deassociates a lot, especially after an ARP request
In-Reply-To: <46C60B55.4000100@Wetwork.Net>
References: <46C60B55.4000100@Wetwork.Net>
Message-ID: <200708181718.43738.mb@bu3sch.de>

On Friday 17 August 2007 22:55:49 Ehud Gavron wrote:
> Synopsis:
> With "everything" tree and b43, loses AP association but then 
> reassociates, usually on ARP request.

How is an ARP request related to an association? That's
a different network layer.
Did you try with another AP?

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sat Aug 18 18:02:17 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 18 Aug 2007 11:02:17 -0500
Subject: [PATCH] ssb: Fix auto-load problem for devices with 802.11 core
	rev >= 10
In-Reply-To: <200708181645.07808.mb@bu3sch.de>
References: <46c6230f.xC8MDU6Co5FWANra%Larry.Finger@lwfinger.net>
	<200708181645.07808.mb@bu3sch.de>
Message-ID: <46C71809.5010209@lwfinger.net>

Michael Buesch wrote:
> On Saturday 18 August 2007 00:37:03 Larry Finger wrote:
>> From: Johannes Berg <johannes at sipsolutions.net>
>>
>> The auto-loading mechanism from ssb to b43 is case sensitive; however, the
>> present code is generating a lower-case "a" for the BCM4311, which has an
>> 802.11 core with revision 10.
>>
>> Signed-off-by: Johannes Berg <johannes at sipsolutions.net>
>> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
>> ---
>>
>> Michael,
>>
>> Here is the "formal" patch for this buglet.
>>
>> Larry
>>
>>
>>
>> Index: wireless-dev/drivers/ssb/main.c
>> ===================================================================
>> --- wireless-dev.orig/drivers/ssb/main.c
>> +++ wireless-dev/drivers/ssb/main.c
>> @@ -331,7 +331,7 @@ static int ssb_device_uevent(struct devi
>>  
>>  	ret = add_uevent_var(envp, num_envp, &i,
>>  			     buffer, buffer_size, &length,
>> -			     "MODALIAS=ssb:v%.4xid%.4xrev%.2x",
>> +			     "MODALIAS=ssb:v%.4xid%.4xrev%.2X",
> 
> I already queued the correct patch for this.

Good. I thought you might have, but I wanted to post it as some users missed the first set of emails 
among you, Johannes, and I regarding this problem. I hoped that another airing on the list would 
reinforce the idea that 4311 users would need to apply this one until it actually ends up in 
wireless-dev.

Larry


From freggy at gmail.com  Sat Aug 18 20:29:31 2007
From: freggy at gmail.com (Frederik)
Date: Sat, 18 Aug 2007 20:29:31 +0200
Subject: b43 module: failure to associate with AP (timeouts?)
Message-ID: <28d495d10708181129r7d0e07e2g8152dbc37e626363@mail.gmail.com>

I am using Linux 2.6.22.3 with recent git wireless-dev drivers
(updated a few days ago, actually it is Mandriva's kernel 2.6.22-6mdv
which includes this wireless-dev patch:
http://svn.mandriva.com/cgi-bin/viewvc.cgi/packages/cooker/kernel-2.6/releases/2.6.22/6mdv/PATCHES/patches/MC70_wireless-dev_drivers_updates.patch?view=log)

I have an Asus WL100g Deluxe PC card, which works perfectly fine with
the traditional bcm43xx drivers as included in the standard Linux
kernel. This is the device:
02:00.0 Network controller [0280]: Broadcom Corporation BCM4306
802.11b/g Wireless LAN Controller [14e4:4320] (rev 03)

However, with the new b43 driver, it fails to associate with my
WPA2-PSK (AES) secured AP. Here are some dmesg logs:

pccard: CardBus card inserted into slot 0
PCI: Enabling device 0000:02:00.0 (0000 -> 0002)
ACPI: PCI Interrupt 0000:02:00.0[A] -> Link [LNK2] -> GSI 10 (level,
low) -> IRQ 10
PCI: Setting latency timer of device 0000:02:00.0 to 64
ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x04, vendor 0x4243)
ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x05, vendor 0x4243)
ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x02, vendor 0x4243)
ssb: Core 3 found: V90 (cc 0x807, rev 0x02, vendor 0x4243)
ssb: Core 4 found: PCI (cc 0x804, rev 0x09, vendor 0x4243)
b43-phy9: Broadcom 4306 WLAN found
b43-phy9 debug: Found PHY: Analog 2, Type 2, Revision 2
b43-phy9 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
b43-phy9 debug: Radio turned off
wmaster0: Selected rate control algorithm 'simple'
ssb: Sonics Silicon Backplane found on PCI device 0000:02:00.0
udev: renamed network interface wlan0 to eth1
b43-phy9 debug: Adding Interface type 2
b43-phy9 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy9 debug: Radio turned on
b43-phy9 debug: Radio enabled by hardware
b43-phy9 ERROR: bbatt(11) >= size of LO array
b43-phy9 debug: Chip initialized
b43-phy9 debug: 30-bit DMA initialized
b43-phy9 debug: Wireless interface started
ADDRCONF(NETDEV_UP): eth1: link is not ready
b43-phy9 debug: Using hardware based encryption for keyidx: 0, mac:
ff:ff:ff:ff:ff:ff
b43-phy9 debug: Using software based encryption for keyidx: 0, mac:
ff:ff:ff:ff:ff:ff
eth1: Initial auth_alg=0
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: authentication with AP 00:15:f2:0a:ab:43 timed out
eth1: Initial auth_alg=0
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: Initial auth_alg=0
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: Initial auth_alg=0
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: authentication with AP 00:15:f2:0a:ab:43 timed out
eth1: Initial auth_alg=0
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: Initial auth_alg=0
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: Initial auth_alg=0
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: authenticate with AP 00:15:f2:0a:ab:43
eth1: authentication with AP 00:15:f2:0a:ab:43 timed out
[...]

When scanning it works and finds my AP:
# iwlist eth1 scan
Warning: Driver for device eth1 has been compiled with version 22
of Wireless Extension, while this program supports up to version 20.
Some things may be broken...

eth1      Scan completed :
          Cell 01 - Address: 00:15:F2:0A:AB:43
                    ESSID:"LinuxNet"
                    Mode:Master
                    Channel:13
                    Frequency:2.472 GHz
                    Quality=81/100  Signal level=-52 dBm  Noise level=-55 dBm
                    Encryption key:on
                    IE: IEEE 802.11i/WPA2 Version 1
                        Group Cipher : CCMP
                        Pairwise Ciphers (1) : CCMP
                        Authentication Suites (1) : PSK
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 18 Mb/s
                              24 Mb/s; 36 Mb/s; 54 Mb/s; 6 Mb/s; 9 Mb/s
                              12 Mb/s; 48 Mb/s
                    Extra:tsf=000004e0d14d04d4

Some wpa_supplicant debugging info:
# wpa_supplicant -dd -Dwext -ieth1 -c/etc/wpa_supplicant.conf
Initializing interface 'eth1' conf '/etc/wpa_supplicant.conf' driver
'wext' ctrl_interface 'N/A' bridge 'N/A'
Configuration file '/etc/wpa_supplicant.conf' -> '/etc/wpa_supplicant.conf'
Reading configuration file '/etc/wpa_supplicant.conf'
Line: 1 - start of a new network block
PSK (ASCII passphrase) - hexdump_ascii(len=19): [REMOVED]
scan_ssid=1 (0x1)
ssid - hexdump_ascii(len=8):
     4c 69 6e 75 78 4e 65 74                           LinuxNet
PSK (from passphrase) - hexdump(len=32): [REMOVED]
Priority group 0
   id=0 ssid='LinuxNet'
Initializing interface (2) 'eth1'
EAPOL: SUPP_PAE entering state DISCONNECTED
EAPOL: KEY_RX entering state NO_KEY_RECEIVE
EAPOL: SUPP_BE entering state INITIALIZE
EAP: EAP entering state DISABLED
EAPOL: External notification - portEnabled=0
EAPOL: External notification - portValid=0
SIOCGIWRANGE: WE(compiled)=22 WE(source)=21 enc_capa=0xf
  capabilities: key_mgmt 0xf enc 0xf
WEXT: Operstate: linkmode=1, operstate=5
Own MAC address: 00:15:f2:51:ca:f9
wpa_driver_wext_set_wpa
wpa_driver_wext_set_key: alg=0 key_idx=0 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=1 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=2 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=3 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_countermeasures
ioctl[SIOCSIWAUTH]: Operation not supported
WEXT auth param 4 value 0x0 - wpa_driver_wext_set_drop_unencrypted
ioctl[SIOCSIWAUTH]: Operation not supported
WEXT auth param 5 value 0x1 - Setting scan request: 0 sec 100000 usec
Added interface eth1
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
Wireless event: cmd=0x8b06 len=8
State: DISCONNECTED -> SCANNING
Starting AP scan (specific SSID)
Scan SSID - hexdump_ascii(len=8):
     4c 69 6e 75 78 4e 65 74                           LinuxNet
Trying to get current scan results first without requesting a new scan
to speed up initial association
Received 455 bytes of scan results (2 BSSes)
Scan results: 2
Selecting BSS from priority group 0
Try to find WPA-enabled AP
0: 00:15:f2:0a:ab:43 ssid='LinuxNet' wpa_ie_len=0 rsn_ie_len=22 caps=0x11
   selected based on RSN IE
   selected WPA AP 00:15:f2:0a:ab:43 ssid='LinuxNet'
Try to find non-WPA AP
Trying to associate with 00:15:f2:0a:ab:43 (SSID='LinuxNet' freq=2472 MHz)
Cancelling scan request
WPA: clearing own WPA/RSN IE
Automatic auth_alg selection: 0x1
RSN: using IEEE 802.11i/D9.0
WPA: Selected cipher suites: group 16 pairwise 16 key_mgmt 2 proto 2
WPA: clearing AP WPA IE
WPA: set AP RSN IE - hexdump(len=22): 30 14 01 00 00 0f ac 04 01 00 00
0f ac 04 01 00 00 0f ac 02 0c 00
WPA: using GTK CCMP
WPA: using PTK CCMP
WPA: using KEY_MGMT WPA-PSK
WPA: Set own WPA IE default - hexdump(len=22): 30 14 01 00 00 0f ac 04
01 00 00 0f ac 04 01 00 00 0f ac 02 00 00
No keys have been configured - skip key clearing
wpa_driver_wext_set_drop_unencrypted
ioctl[SIOCSIWAUTH]: Operation not supported
WEXT auth param 5 value 0x1 - State: SCANNING -> ASSOCIATING
wpa_driver_wext_set_operstate: operstate 0->0 (DORMANT)
WEXT: Operstate: linkmode=-1, operstate=5
wpa_driver_wext_associate
ioctl[SIOCSIWFREQ]: Invalid argument
Association request to the driver failed
Setting authentication timeout: 5 sec 0 usec
EAPOL: External notification - EAP success=0
EAPOL: External notification - EAP fail=0
EAPOL: External notification - portControl=Auto
RSN: Ignored PMKID candidate without preauth flag
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
Wireless event: cmd=0x8b06 len=8
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
Wireless event: cmd=0x8b1a len=16
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
Wireless event: cmd=0x8b19 len=8
Received 665 bytes of scan results (3 BSSes)
Scan results: 3
Selecting BSS from priority group 0
Try to find WPA-enabled AP
0: 00:15:f2:0a:ab:43 ssid='LinuxNet' wpa_ie_len=0 rsn_ie_len=22 caps=0x11
   selected based on RSN IE
   selected WPA AP 00:15:f2:0a:ab:43 ssid='LinuxNet'
Try to find non-WPA AP
Already associated with the selected AP.
RSN: Ignored PMKID candidate without preauth flag
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
Wireless event: cmd=0x8b06 len=8
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
Wireless event: cmd=0x8b1a len=16
Authentication with 00:00:00:00:00:00 timed out.
Added BSSID 00:15:f2:0a:ab:43 into blacklist
No keys have been configured - skip key clearing
State: ASSOCIATING -> DISCONNECTED
wpa_driver_wext_set_operstate: operstate 0->0 (DORMANT)
WEXT: Operstate: linkmode=-1, operstate=5
EAPOL: External notification - portEnabled=0
EAPOL: External notification - portValid=0
EAPOL: External notification - EAP success=0
Setting scan request: 0 sec 0 usec
State: DISCONNECTED -> SCANNING
Starting AP scan (broadcast SSID)
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
Wireless event: cmd=0x8b19 len=8
Received 665 bytes of scan results (3 BSSes)
Scan results: 3
Selecting BSS from priority group 0
Try to find WPA-enabled AP
0: 00:15:f2:0a:ab:43 ssid='LinuxNet' wpa_ie_len=0 rsn_ie_len=22 caps=0x11
   selected based on RSN IE
   selected WPA AP 00:15:f2:0a:ab:43 ssid='LinuxNet'
Try to find non-WPA AP
Trying to associate with 00:15:f2:0a:ab:43 (SSID='LinuxNet' freq=2472 MHz)
Cancelling scan request
WPA: clearing own WPA/RSN IE
Automatic auth_alg selection: 0x1
RSN: using IEEE 802.11i/D9.0
WPA: Selected cipher suites: group 16 pairwise 16 key_mgmt 2 proto 2
WPA: clearing AP WPA IE
WPA: set AP RSN IE - hexdump(len=22): 30 14 01 00 00 0f ac 04 01 00 00
0f ac 04 01 00 00 0f ac 02 0c 00
WPA: using GTK CCMP
WPA: using PTK CCMP
WPA: using KEY_MGMT WPA-PSK
WPA: Set own WPA IE default - hexdump(len=22): 30 14 01 00 00 0f ac 04
01 00 00 0f ac 04 01 00 00 0f ac 02 00 00
No keys have been configured - skip key clearing
wpa_driver_wext_set_drop_unencrypted
ioctl[SIOCSIWAUTH]: Operation not supported
WEXT auth param 5 value 0x1 - State: SCANNING -> ASSOCIATING
wpa_driver_wext_set_operstate: operstate 0->0 (DORMANT)
WEXT: Operstate: linkmode=-1, operstate=5
wpa_driver_wext_associate
ioctl[SIOCSIWFREQ]: Invalid argument
Association request to the driver failed
Setting authentication timeout: 5 sec 0 usec
EAPOL: External notification - EAP success=0
EAPOL: External notification - EAP fail=0
EAPOL: External notification - portControl=Auto
RSN: Ignored PMKID candidate without preauth flag
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
Wireless event: cmd=0x8b06 len=8
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
Wireless event: cmd=0x8b1a len=16
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
Wireless event: cmd=0x8b19 len=8
Received 665 bytes of scan results (3 BSSes)
[...]

What could be wrong?
-- 
Frederik


From johannes at sipsolutions.net  Sat Aug 18 21:01:12 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Sat, 18 Aug 2007 21:01:12 +0200
Subject: b43 module: failure to associate with AP (timeouts?)
In-Reply-To: <28d495d10708181129r7d0e07e2g8152dbc37e626363@mail.gmail.com>
References: <28d495d10708181129r7d0e07e2g8152dbc37e626363@mail.gmail.com>
Message-ID: <1187463673.6090.35.camel@johannes.berg>

On Sat, 2007-08-18 at 20:29 +0200, Frederik wrote:

> b43-phy9 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)

> b43-phy9 debug: Using hardware based encryption for keyidx: 0, mac:
> ff:ff:ff:ff:ff:ff
> b43-phy9 debug: Using software based encryption for keyidx: 0, mac:
> ff:ff:ff:ff:ff:ff

wasn't 351 the boundary case for the new key index thing? I forgot now,
you might want to check that.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070818/f3551b5a/attachment.pgp>

From mb at bu3sch.de  Sat Aug 18 21:06:15 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 18 Aug 2007 21:06:15 +0200
Subject: b43 module: failure to associate with AP (timeouts?)
In-Reply-To: <1187463673.6090.35.camel@johannes.berg>
References: <28d495d10708181129r7d0e07e2g8152dbc37e626363@mail.gmail.com>
	<1187463673.6090.35.camel@johannes.berg>
Message-ID: <200708182106.15892.mb@bu3sch.de>

On Saturday 18 August 2007 21:01:12 Johannes Berg wrote:
> On Sat, 2007-08-18 at 20:29 +0200, Frederik wrote:
> 
> > b43-phy9 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> 
> > b43-phy9 debug: Using hardware based encryption for keyidx: 0, mac:
> > ff:ff:ff:ff:ff:ff
> > b43-phy9 debug: Using software based encryption for keyidx: 0, mac:
> > ff:ff:ff:ff:ff:ff
> 
> wasn't 351 the boundary case for the new key index thing? I forgot now,
> you might want to check that.
> 
> johannes
> 

yes it was. 351.126 is the supported version.

-- 
Greetings Michael.


From richie at coderworld.net  Sat Aug 18 22:09:22 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Sat, 18 Aug 2007 22:09:22 +0200
Subject: b43 and knetworkmanager
Message-ID: <200708182209.22468.richie@coderworld.net>

Background:
I have this problem with mac80211 based drivers, but not with softmac drivers.
When unloading the module rmmod never quits and this message is repeated in 
dmesg:
"unregister_netdevice: waiting for eth1 to become free. Usage count = 1"
This only happens when logged in to kde, not in a runlevel3 terminal.


I have found that knetworkmanager has to do with this. If I have not 
associated to a network through knetworkmanager, unloading works fine. If I 
associate once, usage count in dmesg is reported as 1. If I associate 5 times 
then usage count=5, etc.

I believe knetworkmanager or some tool it uses doesn't release a handle, but 
that brings the question: why does it work with the softmac drivers?

Any suggestions how I can proceed to find the broken code? I don't even know 
if it's knetworkmanagers fault, mac80211, b43 or something else.


From larry.finger at lwfinger.net  Sat Aug 18 22:13:50 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 18 Aug 2007 15:13:50 -0500
Subject: [RFC] mac80211: fix software decryption with b43legacy
In-Reply-To: <1187453173.6090.33.camel@johannes.berg>
References: <1187346385.23489.157.camel@johannes.berg>	
	<46C5CC0D.2040609@lwfinger.net>
	<1187384230.6090.7.camel@johannes.berg>	
	<46C612E8.4020604@lwfinger.net>
	<1187387215.6090.13.camel@johannes.berg>	
	<46C64777.1000602@lwfinger.net>
	<1187453173.6090.33.camel@johannes.berg>
Message-ID: <46C752FE.4030706@lwfinger.net>

I have added the lists to this message.

I got b43legacy up and running with the software decryption modifications. It started OK with 
WPA-PSK TKIP encryption, but soon thereafter, I got this message:

eth1: No ProbeResp from current AP 00:1a:70:46:ba:b1 - assume out of range

I don't know why this happened. I didn't move away from the AP, or do anything that should have 
caused loss of a probe response; however, immediately after that, I got this GPF:

general protection fault: 0000 [1] SMP
CPU 0
Modules linked in: nfs af_packet snd_pcm_oss snd_mixer_oss snd_seq snd_seq_device vboxdrv
cpufreq_conservative cpufreq_ondemand cpufreq_userspace cpufreq_powersave powernow_k8 freq_table
thermal processor button battery ac nls_utf8 ntfs loop dm_mod nfsd exportfs lockd nfs_acl
auth_rpcgss sunrpc snd_hda_intel rc80211_simple snd_pcm snd_timer ohci_hcd snd ohci1394 ehci_hcd
ieee1394 soundcore b43legacy sdhci usbcore mmc_core mac80211 cfg80211 ide_cd cdrom forcedeth
snd_page_alloc i2c_nforce2 ssb ext3 mbcache jbd sg edd fan sata_nv libata amd74xx sd_mod scsi_mod
ide_disk ide_core
Pid: 2087, comm: b43legacy Not tainted 2.6.23-rc3-Ldev-gf5a42059-dirty #13
RIP: 0010:[<ffffffff803fe191>]  [<ffffffff803fe191>] __mutex_unlock_slowpath+0x6b/0x13a
RSP: 0018:ffff810056bd9b30  EFLAGS: 00010016
RAX: 0000000000007b64 RBX: ffff81005825e978 RCX: 0000000000000003
RDX: ffff810037f3d080 RSI: 0000000000000008 RDI: 6b6b6b6b6b6b6ba3
RBP: ffff810056bd9b50 R08: 0000000000000000 R09: ffff81005825e978
R10: ffff810056bd9b80 R11: ffff810037f3d080 R12: 6b6b6b6b6b6b6ba3
R13: 0000000000000246 R14: 6b6b6b6b6b6b6bab R15: ffff8100580564c0
FS:  00002b4afda060b0(0000) GS:ffffffff80539000(0000) knlGS:00000000f479eb90
CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
CR2: 00000000f4e88bd0 CR3: 0000000057aa2000 CR4: 00000000000006e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
Process b43legacy (pid: 2087, threadinfo ffff810056bd8000, task ffff810037f3d080)
Stack:  ffff81005825e978 ffff81005825c2f0 ffff8100580564c0 ffff81005825c2f0
  ffff810056bd9b60 ffffffff803fe269 ffff810056bd9b80 ffffffff8814d704
  ffff81005825c2f0 ffff810058056640 ffff810056bd9bb0 ffffffff8813cd4f
Call Trace:
  [<ffffffff803fe269>] mutex_unlock+0x9/0xb
  [<ffffffff8814d704>] :mac80211:ieee80211_key_free+0x33/0x37
  [<ffffffff8813cd4f>] :mac80211:sta_info_free+0x92/0xae
  [<ffffffff881427dc>] :mac80211:ieee80211_associated+0x100/0x1ec
  [<ffffffff88143646>] :mac80211:ieee80211_sta_work+0x0/0x182e

The rest of the call trace is available if needed. The crash occurred when ieee80211_key_free was
trying to unlock the mutex key_idx. I added printk's to dump the pointer to sdata at the point where 
that mutex is initialized and where the key is freed. The mutex that errs was inited.

Note: For this run, I did not have a set_key callback routine defined. I also tried it with a 
callback routine that immediately returns -ENOSPC. It didn't make any difference.

Please let me know what further debug info you need.

Larry




From mb at bu3sch.de  Sat Aug 18 22:17:22 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 18 Aug 2007 22:17:22 +0200
Subject: b43 and knetworkmanager
In-Reply-To: <200708182209.22468.richie@coderworld.net>
References: <200708182209.22468.richie@coderworld.net>
Message-ID: <200708182217.22995.mb@bu3sch.de>

On Saturday 18 August 2007 22:09:22 Richard Jonsson wrote:
> Background:
> I have this problem with mac80211 based drivers, but not with softmac drivers.
> When unloading the module rmmod never quits and this message is repeated in 
> dmesg:
> "unregister_netdevice: waiting for eth1 to become free. Usage count = 1"
> This only happens when logged in to kde, not in a runlevel3 terminal.
> 
> 
> I have found that knetworkmanager has to do with this. If I have not 
> associated to a network through knetworkmanager, unloading works fine. If I 
> associate once, usage count in dmesg is reported as 1. If I associate 5 times 
> then usage count=5, etc.
> 
> I believe knetworkmanager or some tool it uses doesn't release a handle, but 
> that brings the question: why does it work with the softmac drivers?
> 
> Any suggestions how I can proceed to find the broken code? I don't even know 
> if it's knetworkmanagers fault, mac80211, b43 or something else.


It's a bug in mac80211

-- 
Greetings Michael.


From richie at coderworld.net  Sat Aug 18 22:42:04 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Sat, 18 Aug 2007 22:42:04 +0200
Subject: b43 and knetworkmanager
In-Reply-To: <200708182217.22995.mb@bu3sch.de>
References: <200708182209.22468.richie@coderworld.net>
	<200708182217.22995.mb@bu3sch.de>
Message-ID: <200708182242.05096.richie@coderworld.net>

On Saturday 18 August 2007 22:17:22 you wrote:
>
> It's a bug in mac80211

Ok, is it a known bug, and is there a patch? Should I bother finding it?
And finally, is this the wrong list to ask these questions beeing a mac80211 
bug?

Thanks in advance,
Richard


From mb at bu3sch.de  Sat Aug 18 22:44:22 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 18 Aug 2007 22:44:22 +0200
Subject: b43 and knetworkmanager
In-Reply-To: <200708182242.05096.richie@coderworld.net>
References: <200708182209.22468.richie@coderworld.net>
	<200708182217.22995.mb@bu3sch.de>
	<200708182242.05096.richie@coderworld.net>
Message-ID: <200708182244.22704.mb@bu3sch.de>

On Saturday 18 August 2007 22:42:04 Richard Jonsson wrote:
> On Saturday 18 August 2007 22:17:22 you wrote:
> >
> > It's a bug in mac80211
> 
> Ok, is it a known bug, and is there a patch? Should I bother finding it?

It's unknown how it's triggered and there is no patch.

> And finally, is this the wrong list to ask these questions beeing a mac80211 
> bug?

linux-wireless at vger.kernel.org

-- 
Greetings Michael.


From freggy at gmail.com  Sat Aug 18 23:12:10 2007
From: freggy at gmail.com (Frederik)
Date: Sat, 18 Aug 2007 23:12:10 +0200
Subject: b43 module: failure to associate with AP (timeouts?)
In-Reply-To: <200708182106.15892.mb@bu3sch.de>
References: <28d495d10708181129r7d0e07e2g8152dbc37e626363@mail.gmail.com>
	<1187463673.6090.35.camel@johannes.berg>
	<200708182106.15892.mb@bu3sch.de>
Message-ID: <28d495d10708181412sb565a6ap6e799ac677e7da6f@mail.gmail.com>

On 8/18/07, Michael Buesch <mb at bu3sch.de> wrote:
> On Saturday 18 August 2007 21:01:12 Johannes Berg wrote:
> > On Sat, 2007-08-18 at 20:29 +0200, Frederik wrote:
> >
> > > b43-phy9 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> >
> > > b43-phy9 debug: Using hardware based encryption for keyidx: 0, mac:
> > > ff:ff:ff:ff:ff:ff
> > > b43-phy9 debug: Using software based encryption for keyidx: 0, mac:
> > > ff:ff:ff:ff:ff:ff
> >
> > wasn't 351 the boundary case for the new key index thing? I forgot now,
> > you might want to check that.
>
> yes it was. 351.126 is the supported version.

So the version of the firmware is fine? Any idea about what could be wrong then?

-- 
Frederik


From mb at bu3sch.de  Sat Aug 18 23:16:50 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 18 Aug 2007 23:16:50 +0200
Subject: b43 module: failure to associate with AP (timeouts?)
In-Reply-To: <28d495d10708181412sb565a6ap6e799ac677e7da6f@mail.gmail.com>
References: <28d495d10708181129r7d0e07e2g8152dbc37e626363@mail.gmail.com>
	<200708182106.15892.mb@bu3sch.de>
	<28d495d10708181412sb565a6ap6e799ac677e7da6f@mail.gmail.com>
Message-ID: <200708182316.50726.mb@bu3sch.de>

On Saturday 18 August 2007 23:12:10 Frederik wrote:
> On 8/18/07, Michael Buesch <mb at bu3sch.de> wrote:
> > On Saturday 18 August 2007 21:01:12 Johannes Berg wrote:
> > > On Sat, 2007-08-18 at 20:29 +0200, Frederik wrote:
> > >
> > > > b43-phy9 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> > >
> > > > b43-phy9 debug: Using hardware based encryption for keyidx: 0, mac:
> > > > ff:ff:ff:ff:ff:ff
> > > > b43-phy9 debug: Using software based encryption for keyidx: 0, mac:
> > > > ff:ff:ff:ff:ff:ff
> > >
> > > wasn't 351 the boundary case for the new key index thing? I forgot now,
> > > you might want to check that.
> >
> > yes it was. 351.126 is the supported version.
> 
> So the version of the firmware is fine? Any idea about what could be wrong then?
> 

Firmware is ok. I have no idea what's going on, as it works
fine for all of my cards.

-- 
Greetings Michael.


From mb at bu3sch.de  Sun Aug 19 01:48:33 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 19 Aug 2007 01:48:33 +0200
Subject: [patch 0/6] New patch series for merge
Message-ID: <20070818234833.623623000@bu3sch.de>

Hi John,

This patch series catches wireless-dev up to my
current wireless-development patchset.

Please merge this into wireless-dev.

IMPORTANT: Latest fwcutter from SVN and re-extracting the firmware is needed after applying this.


-- 



From mb at bu3sch.de  Sun Aug 19 01:48:36 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 19 Aug 2007 01:48:36 +0200
Subject: [patch 3/6] b43: Rename print functions to b43foobar
References: <20070818234833.623623000@bu3sch.de>
Message-ID: <20070818234835.034817000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 003-b43-rename-printing-funcs.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070819/9ffdfc4b/attachment.ksh>

From mb at bu3sch.de  Sun Aug 19 01:48:34 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 19 Aug 2007 01:48:34 +0200
Subject: [patch 1/6] b43: Fix kconfig, SSB autoselect must depend on b43
References: <20070818234833.623623000@bu3sch.de>
Message-ID: <20070818234834.124717000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 001-b43-fix-ssb-autoselect.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070819/6a8c541a/attachment.ksh>

From mb at bu3sch.de  Sun Aug 19 01:48:38 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 19 Aug 2007 01:48:38 +0200
Subject: [patch 5/6] b43: Use new firmware file naming scheme
References: <20070818234833.623623000@bu3sch.de>
Message-ID: <20070818234835.956854000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 005-b43-use-new-firmware-paths.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070819/3cd3fc63/attachment.ksh>

From mb at bu3sch.de  Sun Aug 19 01:48:37 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 19 Aug 2007 01:48:37 +0200
Subject: [patch 4/6] b43: Update Kconfig help text
References: <20070818234833.623623000@bu3sch.de>
Message-ID: <20070818234835.514400000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 004-b43-Update-Kconfig-help-text.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070819/e9b70d10/attachment.ksh>

From mb at bu3sch.de  Sun Aug 19 01:48:35 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 19 Aug 2007 01:48:35 +0200
Subject: [patch 2/6] ssb: Fix uevent MODALIAS string.
References: <20070818234833.623623000@bu3sch.de>
Message-ID: <20070818234834.595040000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 002-ssb-fix-uevent-modalias.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070819/9ef4a74c/attachment.ksh>

From mb at bu3sch.de  Sun Aug 19 01:48:39 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 19 Aug 2007 01:48:39 +0200
Subject: [patch 6/6] b43: New firmware file format
References: <20070818234833.623623000@bu3sch.de>
Message-ID: <20070818234836.401097000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 006-b43-new-firmware-format.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070819/860eff84/attachment.ksh>

From comphappy at gmail.com  Sun Aug 19 02:45:17 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sat, 18 Aug 2007 16:45:17 -0800
Subject: b43 and knetworkmanager
In-Reply-To: <200708182242.05096.richie@coderworld.net>
References: <200708182209.22468.richie@coderworld.net>
	<200708182217.22995.mb@bu3sch.de>
	<200708182242.05096.richie@coderworld.net>
Message-ID: <b2d05de20708181745o266cb218ve75658f34737b5d4@mail.gmail.com>

On 8/18/07, Richard Jonsson <richie at coderworld.net> wrote:
> On Saturday 18 August 2007 22:17:22 you wrote:
> >
> > It's a bug in mac80211
>
> Ok, is it a known bug, and is there a patch? Should I bother finding it?
> And finally, is this the wrong list to ask these questions beeing a mac80211
> bug?
>
> Thanks in advance,
> Richard
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
I also reported this a few weeks ago, you will note that it is not
knetworkmanager specific, also happens with GNOME.

-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From Larry.Finger at lwfinger.net  Sun Aug 19 06:45:00 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 18 Aug 2007 23:45:00 -0500
Subject: Lock problem with latest b43 patches
Message-ID: <46C7CACC.2000000@lwfinger.net>

Using the latest set of 6 patches posted about 5 hours ago, I get the following locking problem with 
a BCM4311 using WPA-PSK TKIP encryption controlled by NetworkManager:

b43-phy1 ERROR: Adjusting Local Oscillator to an uncalibrated control pair: rfatt=3,no-padmix bbatt=0
eth1: Initial auth_alg=0
eth1: authenticate with AP 00:1a:70:46:ba:b1
eth1: RX authentication from 00:1a:70:46:ba:b1 (alg=0 transaction=2 status=0)
eth1: authenticated
eth1: associate with AP 00:1a:70:46:ba:b1
eth1: RX AssocResp from 00:1a:70:46:ba:b1 (capab=0x431 status=0 aid=1)
eth1: associated
eth1: switched to short barker preamble (BSSID=00:1a:70:46:ba:b1)

=======================================================
[ INFO: possible circular locking dependency detected ]
2.6.23-rc3-Ldev-gf5a42059-dirty #16
-------------------------------------------------------
NetworkManager/4114 is trying to acquire lock:
  (&mm->mmap_sem){----}, at: [<ffffffff80224401>] do_page_fault+0x38e/0x835

but task is already holding lock:
  (&inode->i_mutex){--..}, at: [<ffffffff803fe515>] mutex_lock+0x2a/0x2e

which lock already depends on the new lock.


the existing dependency chain (in reverse order) is:

-> #1 (&inode->i_mutex){--..}:
        [<ffffffff80252d52>] __lock_acquire+0xad4/0xcf0
        [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
        [<ffffffff80252ff3>] lock_acquire+0x85/0xa9
        [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
        [<ffffffff803fe34a>] __mutex_lock_slowpath+0xef/0x290
        [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
        [<ffffffff88600d7d>] nfs_revalidate_mapping+0x6d/0xac [nfs]
        [<ffffffff885fe7e1>] nfs_file_mmap+0x4d/0x65 [nfs]
        [<ffffffff80284371>] mmap_region+0x222/0x431
        [<ffffffff803ff491>] __down_write_nested+0x1a/0xab
        [<ffffffff80284a67>] do_mmap_pgoff+0x2ce/0x333
        [<ffffffff802122eb>] sys_mmap+0x90/0x119
        [<ffffffff8020c07e>] system_call+0x7e/0x83
        [<ffffffffffffffff>] 0xffffffffffffffff

-> #0 (&mm->mmap_sem){----}:
        [<ffffffff80252c50>] __lock_acquire+0x9d2/0xcf0
        [<ffffffff802fecdc>] __down_read_trylock+0x16/0x46
        [<ffffffff80224401>] do_page_fault+0x38e/0x835
        [<ffffffff80252ff3>] lock_acquire+0x85/0xa9
        [<ffffffff80224401>] do_page_fault+0x38e/0x835
        [<ffffffff8024d161>] down_read+0x3e/0x4a
        [<ffffffff80224401>] do_page_fault+0x38e/0x835
        [<ffffffff80252f20>] __lock_acquire+0xca2/0xcf0
        [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
        [<ffffffff80251be9>] mark_held_locks+0x4a/0x6a
        [<ffffffff803fe4d2>] __mutex_lock_slowpath+0x277/0x290
        [<ffffffff804001fd>] error_exit+0x0/0x96
        [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
        [<ffffffff8029f7fc>] pipe_read+0x106/0x374
        [<ffffffff8029f7c3>] pipe_read+0xcd/0x374
        [<ffffffff80298c81>] do_sync_read+0xe2/0x126
        [<ffffffff8024a4e4>] autoremove_wake_function+0x0/0x38
        [<ffffffff802ce09e>] dnotify_parent+0x6b/0x73
        [<ffffffff802994c4>] vfs_read+0xcc/0x155
        [<ffffffff80299889>] sys_read+0x47/0x6f
        [<ffffffff8020c07e>] system_call+0x7e/0x83
        [<ffffffffffffffff>] 0xffffffffffffffff

other info that might help us debug this:

1 lock held by NetworkManager/4114:
  #0:  (&inode->i_mutex){--..}, at: [<ffffffff803fe515>] mutex_lock+0x2a/0x2e

stack backtrace:

Call Trace:
  [<ffffffff80251023>] print_circular_bug_tail+0x70/0x7b
  [<ffffffff80252c50>] __lock_acquire+0x9d2/0xcf0
  [<ffffffff802fecdc>] __down_read_trylock+0x16/0x46
  [<ffffffff80224401>] do_page_fault+0x38e/0x835
  [<ffffffff80252ff3>] lock_acquire+0x85/0xa9
  [<ffffffff80224401>] do_page_fault+0x38e/0x835
  [<ffffffff8024d161>] down_read+0x3e/0x4a
  [<ffffffff80224401>] do_page_fault+0x38e/0x835
  [<ffffffff80252f20>] __lock_acquire+0xca2/0xcf0
  [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
  [<ffffffff80251be9>] mark_held_locks+0x4a/0x6a
  [<ffffffff803fe4d2>] __mutex_lock_slowpath+0x277/0x290
  [<ffffffff804001fd>] error_exit+0x0/0x96
  [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
  [<ffffffff8029f7fc>] pipe_read+0x106/0x374
  [<ffffffff8029f7c3>] pipe_read+0xcd/0x374
  [<ffffffff80298c81>] do_sync_read+0xe2/0x126
  [<ffffffff8024a4e4>] autoremove_wake_function+0x0/0x38
  [<ffffffff802ce09e>] dnotify_parent+0x6b/0x73
  [<ffffffff802994c4>] vfs_read+0xcc/0x155
  [<ffffffff80299889>] sys_read+0x47/0x6f
  [<ffffffff8020c07e>] system_call+0x7e/0x83



From richie at coderworld.net  Sun Aug 19 11:36:52 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Sun, 19 Aug 2007 11:36:52 +0200
Subject: b43 and knetworkmanager
In-Reply-To: <b2d05de20708181745o266cb218ve75658f34737b5d4@mail.gmail.com>
References: <200708182209.22468.richie@coderworld.net>
	<200708182242.05096.richie@coderworld.net>
	<b2d05de20708181745o266cb218ve75658f34737b5d4@mail.gmail.com>
Message-ID: <200708191136.53147.richie@coderworld.net>

On Sunday 19 August 2007 02:45:17 you wrote:
> On 8/18/07, Richard Jonsson <richie at coderworld.net> wrote:
> > On Saturday 18 August 2007 22:17:22 you wrote:
> > > It's a bug in mac80211
> >
> > Ok, is it a known bug, and is there a patch? Should I bother finding it?
> > And finally, is this the wrong list to ask these questions beeing a
> > mac80211 bug?
> >
> > Thanks in advance,
> > Richard
> > _______________________________________________
> > Bcm43xx-dev mailing list
> > Bcm43xx-dev at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
> I also reported this a few weeks ago, you will note that it is not
> knetworkmanager specific, also happens with GNOME.


Yes I remember, do you know in what circumstances this happens for you? What 
distro are you using, and are you using a networkmanager?
I can poweroff my system properly if I don't attempt to unload the b43 module 
first.

I'm trying to track down where this happens, but I'm not that good, it may 
take some time.


From mb at bu3sch.de  Sun Aug 19 14:16:25 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 19 Aug 2007 14:16:25 +0200
Subject: Lock problem with latest b43 patches
In-Reply-To: <46C7CACC.2000000@lwfinger.net>
References: <46C7CACC.2000000@lwfinger.net>
Message-ID: <200708191416.26192.mb@bu3sch.de>

On Sunday 19 August 2007 06:45:00 Larry Finger wrote:
> Using the latest set of 6 patches posted about 5 hours ago, I get the following locking problem with 
> a BCM4311 using WPA-PSK TKIP encryption controlled by NetworkManager:

Are you sure this is caused by my patches? I don't see how that's possible.
How to reproduce?

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sun Aug 19 18:07:00 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 19 Aug 2007 11:07:00 -0500
Subject: Lock problem with latest b43 patches
In-Reply-To: <200708191416.26192.mb@bu3sch.de>
References: <46C7CACC.2000000@lwfinger.net> <200708191416.26192.mb@bu3sch.de>
Message-ID: <46C86AA4.1030303@lwfinger.net>

Michael Buesch wrote:
> On Sunday 19 August 2007 06:45:00 Larry Finger wrote:
>> Using the latest set of 6 patches posted about 5 hours ago, I get the following locking problem with 
>> a BCM4311 using WPA-PSK TKIP encryption controlled by NetworkManager:
> 
> Are you sure this is caused by my patches? I don't see how that's possible.
> How to reproduce?

It's probably not your patches, but some unusual locking interaction involving NetworkManager, 
wpa_supplicant, and mac80211. The involvement of b43 may be incidental. It must have accidentally 
triggered just after I installed your patches. I cannot reproduce it today. No doubt it will show up 
again.

Larry


From comphappy at gmail.com  Sun Aug 19 20:23:29 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sun, 19 Aug 2007 10:23:29 -0800
Subject: b43 and knetworkmanager
In-Reply-To: <200708191136.53147.richie@coderworld.net>
References: <200708182209.22468.richie@coderworld.net>
	<200708182242.05096.richie@coderworld.net>
	<b2d05de20708181745o266cb218ve75658f34737b5d4@mail.gmail.com>
	<200708191136.53147.richie@coderworld.net>
Message-ID: <b2d05de20708191123u4411ff8ap9c9102d12b566ce4@mail.gmail.com>

> Yes I remember, do you know in what circumstances this happens for you? What
> distro are you using, and are you using a networkmanager?
> I can poweroff my system properly if I don't attempt to unload the b43 module
> first.
>
> I'm trying to track down where this happens, but I'm not that good, it may
> take some time.
>
Fedora 6
kernel from wireless-dev 2.6.23-rc2
networkmanager

command to brake it:
rmmod bcm43xx_mac80211

it may take a few times, but it will happen. It does not matter if the
wireless was working at that time or not.

-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From Larry.Finger at lwfinger.net  Sun Aug 19 21:37:21 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 19 Aug 2007 14:37:21 -0500
Subject: ALERT: firmware change for b43
Message-ID: <46C89BF1.5060306@lwfinger.net>


Just in case you missed the details, the latest set of changes to b43 queued by Michael will require
a new version of fwcutter, now called b43-fwcutter, and a new extraction of your firmware.

There are several changes. Most notably, the firmware for b43 and b43legacy will reside in separate
directories under /lib/firmware, or whatever is appropriate for your distro. With the new directory
structure, there will be no name clashes for firmware for b43, b43legacy, and bcm43xx. The fwpostfix
option still exists, but it is no longer essential for operation. The firmware files have also been
renamed to reflect their usage. This is most obvious for the "initvals" files. A third change
restructures the firmware files to reduce their size.

It is recommended that you update fwcutter before these patches are merged. If your version of
fwcutter was obtained with subversion, a simple 'svn update' in the fwcutter directory will suffice.
If you are using a version provided by your distro, you will need to checkout the latest version
with the command 'svn checkout svn://svn.berlios.de/bcm43xx/trunk/fwcutter'. This will create the
directory fwcutter. You should 'cd fwcutter', followed by 'make'. You then use the newly made
b43-fwcutter to extract V4 firmware. If you have BCM4301 or BCM4306/2 devices, you should also use
b43-cutter to extract V3 firmware for b43legacy. The patch to include that driver in wireless-dev
will be submitted very soon.

Larry





From johannes at sipsolutions.net  Mon Aug 20 13:20:48 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 20 Aug 2007 13:20:48 +0200
Subject: [RFC] mac80211: fix software decryption with b43legacy
In-Reply-To: <46C752FE.4030706@lwfinger.net>
References: <1187346385.23489.157.camel@johannes.berg>
	<46C5CC0D.2040609@lwfinger.net> <1187384230.6090.7.camel@johannes.berg>
	<46C612E8.4020604@lwfinger.net>
	<1187387215.6090.13.camel@johannes.berg>
	<46C64777.1000602@lwfinger.net>
	<1187453173.6090.33.camel@johannes.berg>
	<46C752FE.4030706@lwfinger.net>
Message-ID: <1187608848.6090.84.camel@johannes.berg>

On Sat, 2007-08-18 at 15:13 -0500, Larry Finger wrote:

> eth1: No ProbeResp from current AP 00:1a:70:46:ba:b1 - assume out of range

odd.

> I don't know why this happened. I didn't move away from the AP, or do anything that should have 
> caused loss of a probe response; however, immediately after that, I got this GPF:

I'll look into it, thanks.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070820/83d5e313/attachment.pgp>

From johannes at sipsolutions.net  Mon Aug 20 13:26:42 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 20 Aug 2007 13:26:42 +0200
Subject: Lock problem with latest b43 patches
In-Reply-To: <46C7CACC.2000000@lwfinger.net>
References: <46C7CACC.2000000@lwfinger.net>
Message-ID: <1187609202.6090.93.camel@johannes.berg>

On Sat, 2007-08-18 at 23:45 -0500, Larry Finger wrote:

> -> #1 (&inode->i_mutex){--..}:
>         [<ffffffff80252d52>] __lock_acquire+0xad4/0xcf0
>         [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
>         [<ffffffff80252ff3>] lock_acquire+0x85/0xa9
>         [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
>         [<ffffffff803fe34a>] __mutex_lock_slowpath+0xef/0x290
>         [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
>         [<ffffffff88600d7d>] nfs_revalidate_mapping+0x6d/0xac [nfs]
>         [<ffffffff885fe7e1>] nfs_file_mmap+0x4d/0x65 [nfs]

Are you running on NFS? This is a bit weird but not related to wireless
at all, seems to be dnotify/NFS interaction.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070820/0a3e4a80/attachment.pgp>

From johannes at sipsolutions.net  Mon Aug 20 14:09:53 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 20 Aug 2007 14:09:53 +0200
Subject: [RFC] mac80211: fix software decryption with b43legacy
In-Reply-To: <46C752FE.4030706@lwfinger.net>
References: <1187346385.23489.157.camel@johannes.berg>
	<46C5CC0D.2040609@lwfinger.net> <1187384230.6090.7.camel@johannes.berg>
	<46C612E8.4020604@lwfinger.net>
	<1187387215.6090.13.camel@johannes.berg>
	<46C64777.1000602@lwfinger.net>
	<1187453173.6090.33.camel@johannes.berg>
	<46C752FE.4030706@lwfinger.net>
Message-ID: <1187611793.6090.102.camel@johannes.berg>

On Sat, 2007-08-18 at 15:13 -0500, Larry Finger wrote:

> The rest of the call trace is available if needed. The crash occurred when ieee80211_key_free was
> trying to unlock the mutex key_idx. I added printk's to dump the pointer to sdata at the point where 
> that mutex is initialized and where the key is freed. The mutex that errs was inited.

Ho humm, yes, I'm dumb, patch below but I'll fold it into my key patch.
Sorry about that, classic use-after-free condition here.

johannes

--- wireless-dev.orig/net/mac80211/key.c	2007-08-20 14:07:43.165963896 +0200
+++ wireless-dev/net/mac80211/key.c	2007-08-20 14:08:04.265963896 +0200
@@ -255,12 +255,16 @@ static void __ieee80211_key_free(struct 
 
 void ieee80211_key_free(struct ieee80211_key *key)
 {
+	struct ieee80211_sub_if_data *sdata;
+
 	if (!key)
 		return;
 
-	mutex_lock(&key->sdata->key_mtx);
+	sdata = key->sdata;
+
+	mutex_lock(&sdata->key_mtx);
 	__ieee80211_key_free(key);
-	mutex_unlock(&key->sdata->key_mtx);
+	mutex_unlock(&sdata->key_mtx);
 }
 
 void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx)




From larry.finger at lwfinger.net  Mon Aug 20 19:36:27 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 20 Aug 2007 12:36:27 -0500
Subject: [RFC] mac80211: fix software decryption with b43legacy
In-Reply-To: <1187611793.6090.102.camel@johannes.berg>
References: <1187346385.23489.157.camel@johannes.berg>	
	<46C5CC0D.2040609@lwfinger.net>
	<1187384230.6090.7.camel@johannes.berg>	
	<46C612E8.4020604@lwfinger.net>
	<1187387215.6090.13.camel@johannes.berg>	
	<46C64777.1000602@lwfinger.net>
	<1187453173.6090.33.camel@johannes.berg>	
	<46C752FE.4030706@lwfinger.net>
	<1187611793.6090.102.camel@johannes.berg>
Message-ID: <46C9D11B.4020001@lwfinger.net>

Johannes Berg wrote:
> On Sat, 2007-08-18 at 15:13 -0500, Larry Finger wrote:
> 
>> The rest of the call trace is available if needed. The crash occurred when ieee80211_key_free was
>> trying to unlock the mutex key_idx. I added printk's to dump the pointer to sdata at the point where 
>> that mutex is initialized and where the key is freed. The mutex that errs was inited.
> 
> Ho humm, yes, I'm dumb, patch below but I'll fold it into my key patch.
> Sorry about that, classic use-after-free condition here.

The patch fixed the crash. The reason for the "lost AP" is that WPA isn't working for b43legacy, 
with or without your patches. It used to work and I have no idea why it fails now.

Thanks,

Larry



From larry.finger at lwfinger.net  Mon Aug 20 19:48:38 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 20 Aug 2007 12:48:38 -0500
Subject: Lock problem with latest b43 patches
In-Reply-To: <1187609202.6090.93.camel@johannes.berg>
References: <46C7CACC.2000000@lwfinger.net>
	<1187609202.6090.93.camel@johannes.berg>
Message-ID: <46C9D3F6.7020306@lwfinger.net>

Johannes Berg wrote:
> On Sat, 2007-08-18 at 23:45 -0500, Larry Finger wrote:
> 
>> -> #1 (&inode->i_mutex){--..}:
>>         [<ffffffff80252d52>] __lock_acquire+0xad4/0xcf0
>>         [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
>>         [<ffffffff80252ff3>] lock_acquire+0x85/0xa9
>>         [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
>>         [<ffffffff803fe34a>] __mutex_lock_slowpath+0xef/0x290
>>         [<ffffffff803fe515>] mutex_lock+0x2a/0x2e
>>         [<ffffffff88600d7d>] nfs_revalidate_mapping+0x6d/0xac [nfs]
>>         [<ffffffff885fe7e1>] nfs_file_mmap+0x4d/0x65 [nfs]
> 
> Are you running on NFS? This is a bit weird but not related to wireless
> at all, seems to be dnotify/NFS interaction.

My / and /home partitions are local, but I do have mounted NFS partitions. Whatever happened here 
has been a one-time only event, at least so far. Until it happens again, I'll assume that an 
electron got crosswise somewhere. :)

Larry


From larry.finger at lwfinger.net  Tue Aug 21 02:18:03 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 20 Aug 2007 19:18:03 -0500
Subject: [RFC] mac80211: fix software decryption with b43legacy
In-Reply-To: <20070820224333.GA6363@deine-taler.de>
References: <1187346385.23489.157.camel@johannes.berg>
	<46C5CC0D.2040609@lwfinger.net>
	<1187384230.6090.7.camel@johannes.berg>
	<46C612E8.4020604@lwfinger.net>
	<1187387215.6090.13.camel@johannes.berg>
	<46C64777.1000602@lwfinger.net>
	<1187453173.6090.33.camel@johannes.berg>
	<46C752FE.4030706@lwfinger.net>
	<20070820224333.GA6363@deine-taler.de>
Message-ID: <46CA2F3B.1060500@lwfinger.net>

Ulrich Kunitz wrote:
> Larry Finger wrote:
> 
>> I have added the lists to this message.
>>
>> I got b43legacy up and running with the software decryption modifications. 
>> It started OK with WPA-PSK TKIP encryption, but soon thereafter, I got this 
>> message:
>>
>> eth1: No ProbeResp from current AP 00:1a:70:46:ba:b1 - assume out of range
>>
> 
> Since the git tree reorg wireless-dev branch created comparable
> problems for zd1211rw-mac80211 too. It might be related:
> 
> Aug 19 07:08:51 keks kernel: [   83.572628] wlan0: CCMP replay detected for RX frame from 00:04:0e:68:ad:70 (RX PN 00000000000c <= prev. PN 00000000000c)
> Aug 19 07:08:54 keks kernel: [   87.432010] usb 1-2: handle_regs_int() regs interrupt ignored
> Aug 19 07:08:55 keks kernel: [   87.898447] wlan0: No ProbeResp from current AP 00:04:0e:68:ad:70 - assume out of range
> Aug 19 07:08:55 keks kernel: [   87.899649] wmaster0: Removed STA 00:04:0e:68:ad:70
> Aug 19 07:08:55 keks kernel: [   87.901406] wlan0: set_encrypt - unknown addr 00:04:0e:68:ad:70
> 
> The first message might be a simple duplicate. The
> handle_regs_int() is absolutely suspicious and I cannot really
> explain it right now. The "No ProbeResp" might be a follow-up
> problem. The whole USB subsystem becomes absolutely instable to
> the point that I can't use keyboard and mouse anymore. 
> 
> I will try Johannes' patch tomorrow.
> 
> BTW the wireless-dev reorg makes it impossible to actually use
> git-bisect to find the patch, which caused the problem. 
> 
> BTW the current Linus tree following patch doesn't work with the
> current zd1211rw-mac80211. The offending patch is the following one:
> 
> commit b9bf1e60a294fc7795d5198f94a917290e52865b
> Author: John W. Linville <linville at tuxdriver.com>
> Date:   Tue Aug 7 16:33:15 2007 -0400
> 
>     [PATCH] mac80211: probe for hidden SSIDs in pre-auth scan
>     
>     Probe for hidden SSIDs if initiating pre-authentication scan and SSID
>     is set for STA interface.
>     
>     Signed-off-by: John W. Linville <linville at tuxdriver.com>
> 

This patch is not in my tree, but adding it breaks WEP. WPA fails with it in or out at the moment. 
I'm still looking at that problem.

Larry



From mistamaila at gmail.com  Tue Aug 21 05:18:41 2007
From: mistamaila at gmail.com (John H.)
Date: Mon, 20 Aug 2007 22:18:41 -0500
Subject: sometimes bcm43xx-mac80211 just stays on 1mb/s
Message-ID: <5b9417770708202018p182dbfeajcf526aa5cc9b683a@mail.gmail.com>

using 2.6.22.1-50 on f7.

Sometimes on some networks that are 54mb/s networks,. it seems the
driver just remains on 54mb/s.  On other ones, it correctly increases.
 Is this a bug in the driver, a configuration issue, or what?


From larry.finger at lwfinger.net  Tue Aug 21 05:53:16 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 20 Aug 2007 22:53:16 -0500
Subject: sometimes bcm43xx-mac80211 just stays on 1mb/s
In-Reply-To: <5b9417770708202018p182dbfeajcf526aa5cc9b683a@mail.gmail.com>
References: <5b9417770708202018p182dbfeajcf526aa5cc9b683a@mail.gmail.com>
Message-ID: <46CA61AC.6020402@lwfinger.net>

John H. wrote:
> using 2.6.22.1-50 on f7.
> 
> Sometimes on some networks that are 54mb/s networks,. it seems the
> driver just remains on 54mb/s.  On other ones, it correctly increases.
>  Is this a bug in the driver, a configuration issue, or what?

The driver and the configuration are OK. To increase the rate, there must be a sufficient number of 
successful transmissions with any retransmits or other errors. When the rate stays at 1 Mbs, there 
is probably some form of interference.

Larry



From mistamaila at gmail.com  Tue Aug 21 15:18:50 2007
From: mistamaila at gmail.com (John H.)
Date: Tue, 21 Aug 2007 08:18:50 -0500
Subject: sometimes bcm43xx-mac80211 just stays on 1mb/s
In-Reply-To: <46CA61AC.6020402@lwfinger.net>
References: <5b9417770708202018p182dbfeajcf526aa5cc9b683a@mail.gmail.com>
	<46CA61AC.6020402@lwfinger.net>
Message-ID: <5b9417770708210618g698cfcddr81638b2c8e06e35a@mail.gmail.com>

thanks for the reply.  the thing is, with other drivers or with xp at
same area i don't have the problem.  can i force a minimum rate, such
as 10mb/s or 5mb/s?

On 8/20/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > using 2.6.22.1-50 on f7.
> >
> > Sometimes on some networks that are 54mb/s networks,. it seems the
> > driver just remains on 54mb/s.  On other ones, it correctly increases.
> >  Is this a bug in the driver, a configuration issue, or what?
>
> The driver and the configuration are OK. To increase the rate, there must be a sufficient number of
> successful transmissions with any retransmits or other errors. When the rate stays at 1 Mbs, there
> is probably some form of interference.
>
> Larry
>
>


From larry.finger at lwfinger.net  Tue Aug 21 16:44:24 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 21 Aug 2007 09:44:24 -0500
Subject: sometimes bcm43xx-mac80211 just stays on 1mb/s
In-Reply-To: <5b9417770708210618g698cfcddr81638b2c8e06e35a@mail.gmail.com>
References: <5b9417770708202018p182dbfeajcf526aa5cc9b683a@mail.gmail.com>	
	<46CA61AC.6020402@lwfinger.net>
	<5b9417770708210618g698cfcddr81638b2c8e06e35a@mail.gmail.com>
Message-ID: <46CAFA48.4010607@lwfinger.net>

John H. wrote:
> thanks for the reply.  the thing is, with other drivers or with xp at
> same area i don't have the problem.  can i force a minimum rate, such
> as 10mb/s or 5mb/s?
> 

The algorithm for changing rates differs with the OS/driver.

I doubt that you want 10 or 5 mbs (Note the difference between m and M), but you can force any 
specific _supported_ rate. See 'man iwconfig'.

Larry



From johannes at sipsolutions.net  Tue Aug 21 17:46:40 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 21 Aug 2007 17:46:40 +0200
Subject: [patch 6/6] b43: New firmware file format
In-Reply-To: <20070818234836.401097000@bu3sch.de>
References: <20070818234833.623623000@bu3sch.de>
	<20070818234836.401097000@bu3sch.de>
Message-ID: <1187711200.4218.0.camel@johannes.berg>

On Sun, 2007-08-19 at 01:48 +0200, Michael Buesch wrote:

> @@ -1598,8 +1601,29 @@ static int do_request_fw(struct b43_wlde
>  		b43err(dev->wl, "Firmware file \"%s\" not found "
>  		       "or load failed.\n", path);

+		return err;

>  	}
> +	if ((*fw)->size < sizeof(struct b43_fw_header))
> +		goto err_format;

otherwise it oopses when the file can't be loaded.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070821/ea8507a0/attachment.pgp>

From linville at tuxdriver.com  Tue Aug 21 22:13:36 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Tue, 21 Aug 2007 16:13:36 -0400
Subject: [patch 6/6] b43: New firmware file format
In-Reply-To: <1187711200.4218.0.camel@johannes.berg>
References: <20070818234833.623623000@bu3sch.de>
	<20070818234836.401097000@bu3sch.de>
	<1187711200.4218.0.camel@johannes.berg>
Message-ID: <20070821201336.GA5313@tuxdriver.com>

On Tue, Aug 21, 2007 at 05:46:40PM +0200, Johannes Berg wrote:
> On Sun, 2007-08-19 at 01:48 +0200, Michael Buesch wrote:
> 
> > @@ -1598,8 +1601,29 @@ static int do_request_fw(struct b43_wlde
> >  		b43err(dev->wl, "Firmware file \"%s\" not found "
> >  		       "or load failed.\n", path);
> 
> +		return err;
> 
> >  	}
> > +	if ((*fw)->size < sizeof(struct b43_fw_header))
> > +		goto err_format;
> 
> otherwise it oopses when the file can't be loaded.

ACK...here is a patch, in case you are lazy... :-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index dcf7edc..d8693cf 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -1600,6 +1600,7 @@ static int do_request_fw(struct b43_wldev *dev,
 	if (err) {
 		b43err(dev->wl, "Firmware file \"%s\" not found "
 		       "or load failed.\n", path);
+		return err;
 	}
 	if ((*fw)->size < sizeof(struct b43_fw_header))
 		goto err_format;
-- 
John W. Linville
linville at tuxdriver.com


From mb at bu3sch.de  Tue Aug 21 23:58:39 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 21 Aug 2007 23:58:39 +0200
Subject: [patch 6/6] b43: New firmware file format
In-Reply-To: <20070821201336.GA5313@tuxdriver.com>
References: <20070818234833.623623000@bu3sch.de>
	<1187711200.4218.0.camel@johannes.berg>
	<20070821201336.GA5313@tuxdriver.com>
Message-ID: <200708212358.39762.mb@bu3sch.de>

On Tuesday 21 August 2007 22:13:36 John W. Linville wrote:
> On Tue, Aug 21, 2007 at 05:46:40PM +0200, Johannes Berg wrote:
> > On Sun, 2007-08-19 at 01:48 +0200, Michael Buesch wrote:
> > 
> > > @@ -1598,8 +1601,29 @@ static int do_request_fw(struct b43_wlde
> > >  		b43err(dev->wl, "Firmware file \"%s\" not found "
> > >  		       "or load failed.\n", path);
> > 
> > +		return err;
> > 
> > >  	}
> > > +	if ((*fw)->size < sizeof(struct b43_fw_header))
> > > +		goto err_format;
> > 
> > otherwise it oopses when the file can't be loaded.
> 
> ACK...here is a patch, in case you are lazy... :-)

Whoops, thanks :)

> diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
> index dcf7edc..d8693cf 100644
> --- a/drivers/net/wireless/b43/main.c
> +++ b/drivers/net/wireless/b43/main.c
> @@ -1600,6 +1600,7 @@ static int do_request_fw(struct b43_wldev *dev,
>  	if (err) {
>  		b43err(dev->wl, "Firmware file \"%s\" not found "
>  		       "or load failed.\n", path);
> +		return err;
>  	}
>  	if ((*fw)->size < sizeof(struct b43_fw_header))
>  		goto err_format;



-- 
Greetings Michael.


From mistamaila at gmail.com  Wed Aug 22 04:02:35 2007
From: mistamaila at gmail.com (John H.)
Date: Tue, 21 Aug 2007 21:02:35 -0500
Subject: sometimes bcm43xx-mac80211 just stays on 1mb/s
In-Reply-To: <46CAFA48.4010607@lwfinger.net>
References: <5b9417770708202018p182dbfeajcf526aa5cc9b683a@mail.gmail.com>
	<46CA61AC.6020402@lwfinger.net>
	<5b9417770708210618g698cfcddr81638b2c8e06e35a@mail.gmail.com>
	<46CAFA48.4010607@lwfinger.net>
Message-ID: <5b9417770708211902r40d3afcbs69f247f89fcbae50@mail.gmail.com>

right, but i was wondering something more regarding a module option,
as i use networkmanager and don't manually use iwconfig.


On 8/21/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John H. wrote:
> > thanks for the reply.  the thing is, with other drivers or with xp at
> > same area i don't have the problem.  can i force a minimum rate, such
> > as 10mb/s or 5mb/s?
> >
>
> The algorithm for changing rates differs with the OS/driver.
>
> I doubt that you want 10 or 5 mbs (Note the difference between m and M), but you can force any
> specific _supported_ rate. See 'man iwconfig'.
>
> Larry
>
>


From larry.finger at lwfinger.net  Wed Aug 22 04:48:52 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 21 Aug 2007 21:48:52 -0500
Subject: sometimes bcm43xx-mac80211 just stays on 1mb/s
In-Reply-To: <5b9417770708211902r40d3afcbs69f247f89fcbae50@mail.gmail.com>
References: <5b9417770708202018p182dbfeajcf526aa5cc9b683a@mail.gmail.com>	
	<46CA61AC.6020402@lwfinger.net>	
	<5b9417770708210618g698cfcddr81638b2c8e06e35a@mail.gmail.com>	
	<46CAFA48.4010607@lwfinger.net>
	<5b9417770708211902r40d3afcbs69f247f89fcbae50@mail.gmail.com>
Message-ID: <46CBA414.5050905@lwfinger.net>

John H. wrote:
> right, but i was wondering something more regarding a module option,
> as i use networkmanager and don't manually use iwconfig.
> 

It is a mac80211 function, not a driver one. There are no module options, only the wireless 
extensions calls. There probably is a GUI for this, but I don't know for sure.

Larry


From johannes at sipsolutions.net  Tue Aug 21 20:58:51 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 21 Aug 2007 20:58:51 +0200
Subject: Lock problem with latest b43 patches
In-Reply-To: <46C9D3F6.7020306@lwfinger.net>
References: <46C7CACC.2000000@lwfinger.net>
	<1187609202.6090.93.camel@johannes.berg>
	<46C9D3F6.7020306@lwfinger.net>
Message-ID: <1187722731.8435.0.camel@johannes.berg>

On Mon, 2007-08-20 at 12:48 -0500, Larry Finger wrote:

> My / and /home partitions are local, but I do have mounted NFS partitions. Whatever happened here 
> has been a one-time only event, at least so far. Until it happens again, I'll assume that an 
> electron got crosswise somewhere. :)

I suppose it's unlikely because it looks like there was a page fault of
a memory mapped file involved. It may be worth sending it to the NFS
maintainer anyway.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070821/b01ed711/attachment.pgp>

From johannes at sipsolutions.net  Wed Aug 22 10:10:23 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 22 Aug 2007 10:10:23 +0200
Subject: b43 key selection improvement
Message-ID: <1187770223.9267.15.camel@johannes.berg>

Hey,

Just noticed this bit of code:
        if (dev->dev->id.revision >= 5) {
                /* Number of RCMTA address slots */
                b43_write16(dev, B43_MMIO_RCMTA_COUNT, dev->max_nr_keys - 8);
        }

with a tiny bit of more code complexity, you should be able to set this
register to the number of the highest used slot (plus one, it's 0-based)
and save the hardware some effort when looking for a station address
that cannot be found.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070822/e1157db9/attachment.pgp>

From mb at bu3sch.de  Wed Aug 22 11:38:40 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 22 Aug 2007 11:38:40 +0200
Subject: b43 key selection improvement
In-Reply-To: <1187770223.9267.15.camel@johannes.berg>
References: <1187770223.9267.15.camel@johannes.berg>
Message-ID: <200708221138.40345.mb@bu3sch.de>

On Wednesday 22 August 2007 10:10:23 Johannes Berg wrote:
> Hey,
> 
> Just noticed this bit of code:
>         if (dev->dev->id.revision >= 5) {
>                 /* Number of RCMTA address slots */
>                 b43_write16(dev, B43_MMIO_RCMTA_COUNT, dev->max_nr_keys - 8);
>         }
> 
> with a tiny bit of more code complexity, you should be able to set this
> register to the number of the highest used slot (plus one, it's 0-based)
> and save the hardware some effort when looking for a station address
> that cannot be found.

Yes, I know about this. I just didn't care to fix this, yet.

-- 
Greetings Michael.


From mistamaila at gmail.com  Wed Aug 22 17:10:35 2007
From: mistamaila at gmail.com (John H.)
Date: Wed, 22 Aug 2007 10:10:35 -0500
Subject: bcm43xx-mac80211 problems with advanced wpa
Message-ID: <5b9417770708220810x5b3fb9f9ndbd97f9bdeca55d7@mail.gmail.com>

Hi, i just went back to school and they have a more advanced wpa
network that I was not able to get on with bcm43xx-mac80211 but I can
with ndiswrapper.

Here's the setup in wpa_supplicant.conf
network={
        ssid="schoolid"
        key_mgmt=WPA-EAP
        pairwise=TKIP
        group=TKIP
        scan_ssid=1
        eap=PEAP
        identity="user"
        password="pass"
#       ca_cert="/etc/cert/ca.pem"
#       phase1="peaplabel=1"
       phase2="auth=MSCHAPV2"
}


Here's the error with wpa


/etc/rc.d/init.d/wpa_supplicant start
Starting wpa_supplicant: ioctl[SIOCSIWAUTH]: Operation not supported
WEXT auth param 4 value 0x0 - ioctl[SIOCSIWAUTH]: Operation not
supported
WEXT auth param 5 value 0x1 -


As I said, it works fine with ndiswrapper.

what to do?  I'd prefer to stick with the bcm43xx-mac80211:)


From linville at tuxdriver.com  Wed Aug 22 16:52:57 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 22 Aug 2007 10:52:57 -0400
Subject: ALERT: firmware change for b43
In-Reply-To: <46C89BF1.5060306@lwfinger.net>
References: <46C89BF1.5060306@lwfinger.net>
Message-ID: <20070822145257.GA2926@tuxdriver.com>

On Sun, Aug 19, 2007 at 02:37:21PM -0500, Larry Finger wrote:
> 
> Just in case you missed the details, the latest set of changes to b43 queued by Michael will require
> a new version of fwcutter, now called b43-fwcutter, and a new extraction of your firmware.

Is there a tarball available for download, as with bcm43xx-fwcutter?
It would be handy for packaging.

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Wed Aug 22 17:25:28 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 22 Aug 2007 10:25:28 -0500
Subject: ALERT: firmware change for b43
In-Reply-To: <20070822145257.GA2926@tuxdriver.com>
References: <46C89BF1.5060306@lwfinger.net>
	<20070822145257.GA2926@tuxdriver.com>
Message-ID: <46CC5568.5000709@lwfinger.net>

John W. Linville wrote:
> On Sun, Aug 19, 2007 at 02:37:21PM -0500, Larry Finger wrote:
>> Just in case you missed the details, the latest set of changes to b43 queued by Michael will require
>> a new version of fwcutter, now called b43-fwcutter, and a new extraction of your firmware.
> 
> Is there a tarball available for download, as with bcm43xx-fwcutter?
> It would be handy for packaging.

The new code is in the svn repository; however, a tarball would not be a problem. Is source 
sufficient, or would you want an executable?

Larry


From rjw at sisk.pl  Wed Aug 22 18:33:58 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Wed, 22 Aug 2007 18:33:58 +0200
Subject: 2.6.23-rc3-mm1: fix b43 compilation
In-Reply-To: <20070822020648.5ea3a612.akpm@linux-foundation.org>
References: <20070822020648.5ea3a612.akpm@linux-foundation.org>
Message-ID: <200708221833.59375.rjw@sisk.pl>

On Wednesday, 22 August 2007 11:06, Andrew Morton wrote:
> 
> ftp://ftp.kernel.org/pub/linux/kernel/people/akpm/patches/2.6/2.6.23-rc3/2.6.23-rc3-mm1/
> 
> - git-ixgbe.patch got dropped - git-net.patch destroyed it
> 
> - then git-net got dropped as it doesn't work

Apparently, the b43 driver is expecting another version of mac80211.

This patch fixes the compilation, but I'm not sure what about the
functionality. ;-)

Signed-off-by: Rafael J. Wysocki <rjw at sisk.pl>
---
 drivers/net/wireless/b43/main.c |    6 ++----
 drivers/net/wireless/b43/xmit.c |   10 ++++------
 2 files changed, 6 insertions(+), 10 deletions(-)

Index: linux-2.6.23-rc3-mm1/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.23-rc3-mm1.orig/drivers/net/wireless/b43/main.c
+++ linux-2.6.23-rc3-mm1/drivers/net/wireless/b43/main.c
@@ -1189,8 +1189,7 @@ static void b43_write_probe_resp_plcp(st
 
 	plcp.data = 0;
 	b43_generate_plcp_hdr(&plcp, size + FCS_LEN, rate);
-	dur = ieee80211_generic_frame_duration(dev->wl->hw,
-					       dev->wl->if_id, size,
+	dur = ieee80211_generic_frame_duration(dev->wl->hw, size,
 					       B43_RATE_TO_BASE100KBPS(rate));
 	/* Write PLCP in two parts and timing for packet transfer */
 	tmp = le32_to_cpu(plcp.data);
@@ -1246,8 +1245,7 @@ static u8 *b43_generate_probe_resp(struc
 	/* Set the frame control. */
 	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
 					 IEEE80211_STYPE_PROBE_RESP);
-	dur = ieee80211_generic_frame_duration(dev->wl->hw,
-					       dev->wl->if_id, *dest_size,
+	dur = ieee80211_generic_frame_duration(dev->wl->hw, *dest_size,
 					       B43_RATE_TO_BASE100KBPS(rate));
 	hdr->duration_id = dur;
 
Index: linux-2.6.23-rc3-mm1/drivers/net/wireless/b43/xmit.c
===================================================================
--- linux-2.6.23-rc3-mm1.orig/drivers/net/wireless/b43/xmit.c
+++ linux-2.6.23-rc3-mm1/drivers/net/wireless/b43/xmit.c
@@ -220,7 +220,6 @@ static void generate_txhdr_fw4(struct b4
 	} else {
 		int fbrate_base100kbps = B43_RATE_TO_BASE100KBPS(rate_fb);
 		txhdr->dur_fb = ieee80211_generic_frame_duration(dev->wl->hw,
-								 dev->wl->if_id,
 								 fragment_len,
 								 fbrate_base100kbps);
 	}
@@ -311,16 +310,15 @@ static void generate_txhdr_fw4(struct b4
 		rts_rate_fb_ofdm = b43_is_ofdm_rate(rts_rate_fb);
 
 		if (txctl->flags & IEEE80211_TXCTL_USE_CTS_PROTECT) {
-			ieee80211_ctstoself_get(dev->wl->hw, dev->wl->if_id,
-						fragment_data, fragment_len,
-						txctl,
+			ieee80211_ctstoself_get(dev->wl->hw, fragment_data,
+						fragment_len, txctl,
 						(struct ieee80211_cts *)(txhdr->
 									 rts_frame));
 			mac_ctl |= B43_TX4_MAC_SENDCTS;
 			len = sizeof(struct ieee80211_cts);
 		} else {
-			ieee80211_rts_get(dev->wl->hw, dev->wl->if_id,
-					  fragment_data, fragment_len, txctl,
+			ieee80211_rts_get(dev->wl->hw, fragment_data,
+					  fragment_len, txctl,
 					  (struct ieee80211_rts *)(txhdr->
 								   rts_frame));
 			mac_ctl |= B43_TX4_MAC_SENDRTS;


From Larry.Finger at lwfinger.net  Wed Aug 22 19:41:46 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 22 Aug 2007 12:41:46 -0500
Subject: [PATCH] b43legacy: Initial port of new driver with bcm43xx PHY code
	and ssb/mac80211 front end
Message-ID: <46CC755A.5030109@lwfinger.net>

The following message was just sent to John Linville with the patch attached. Because of the patch's 
length, it is not being sent to the lists. If you would like to obtain a copy, it is at 
ftp://lwfinger.dynalias.org/patches/port_to_b43legacy.

Larry
=============================

This patch ports the PHY and radio handling code of the softmac driver
to the mac80211 front end from b43. The resulting driver is known as
b43legacy.

This driver uses V3 firmware and supports 802.11b-only devices (BCM4301
and BCM4303). It also supports the BCM4306/2 802.11g model. This driver
is needed as these units are not supported by the V4 firmware used with
driver b43. Module ssb has been modified to select between b43 and
b43legacy depending on the revision of the 802.11 wireless core. As a
result the two versions can coexist on a system. The scheme whereby
the firmware is split into separate directories precludes any problems
with firmware names. Compilation with both drivers built into the
kernel confirms that there are no namespace collisions between b43 and
b43legacy.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

Because of the size of this patch, I have not sent it to the lists.
If this is a problem, please let me know. It is meant to apply to the
b43 branch of wireless-dev after the series of 6 patches queued by
Michael Buesch on Aug. 18.

This patch has been run through scripts/checkpatch.pl, and is reasonably
free of the defects found by that script.

The problem with performance on the BCM4306/2 has been fixed. It still
needs improvement, but it now works as well as it ever has.

Thanks,

Larry



From linville at tuxdriver.com  Wed Aug 22 19:18:05 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 22 Aug 2007 13:18:05 -0400
Subject: ALERT: firmware change for b43
In-Reply-To: <46CC5568.5000709@lwfinger.net>
References: <46C89BF1.5060306@lwfinger.net>
	<20070822145257.GA2926@tuxdriver.com>
	<46CC5568.5000709@lwfinger.net>
Message-ID: <20070822171805.GD2926@tuxdriver.com>

On Wed, Aug 22, 2007 at 10:25:28AM -0500, Larry Finger wrote:
> John W. Linville wrote:
> >On Sun, Aug 19, 2007 at 02:37:21PM -0500, Larry Finger wrote:
> >>Just in case you missed the details, the latest set of changes to b43 
> >>queued by Michael will require
> >>a new version of fwcutter, now called b43-fwcutter, and a new extraction 
> >>of your firmware.
> >
> >Is there a tarball available for download, as with bcm43xx-fwcutter?
> >It would be handy for packaging.
> 
> The new code is in the svn repository; however, a tarball would not be a 
> problem. Is source sufficient, or would you want an executable?

Source would be fine, equivalent to what is here:

	http://download.berlios.de/bcm43xx/bcm43xx-fwcutter-006.tar.bz2

Thanks!

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Wed Aug 22 20:08:09 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 22 Aug 2007 13:08:09 -0500
Subject: ALERT: firmware change for b43
In-Reply-To: <20070822171805.GD2926@tuxdriver.com>
References: <46C89BF1.5060306@lwfinger.net>
	<20070822145257.GA2926@tuxdriver.com>
	<46CC5568.5000709@lwfinger.net>
	<20070822171805.GD2926@tuxdriver.com>
Message-ID: <46CC7B89.7090906@lwfinger.net>

John W. Linville wrote:
> On Wed, Aug 22, 2007 at 10:25:28AM -0500, Larry Finger wrote:
>> John W. Linville wrote:
>>> On Sun, Aug 19, 2007 at 02:37:21PM -0500, Larry Finger wrote:
>>>> Just in case you missed the details, the latest set of changes to b43 
>>>> queued by Michael will require
>>>> a new version of fwcutter, now called b43-fwcutter, and a new extraction 
>>>> of your firmware.
>>> Is there a tarball available for download, as with bcm43xx-fwcutter?
>>> It would be handy for packaging.
>> The new code is in the svn repository; however, a tarball would not be a 
>> problem. Is source sufficient, or would you want an executable?
> 
> Source would be fine, equivalent to what is here:
> 
> 	http://download.berlios.de/bcm43xx/bcm43xx-fwcutter-006.tar.bz2

I don't have nor want write access at berlios.de.  The file you want is:

ftp://lwfinger.dynalias.org/patches/b43-fwcutter-008.tar.bz2.

Larry


From mistamaila at gmail.com  Wed Aug 22 20:10:20 2007
From: mistamaila at gmail.com (John H.)
Date: Wed, 22 Aug 2007 13:10:20 -0500
Subject: ALERT: firmware change for b43
In-Reply-To: <46CC7B89.7090906@lwfinger.net>
References: <46C89BF1.5060306@lwfinger.net>
	<20070822145257.GA2926@tuxdriver.com> <46CC5568.5000709@lwfinger.net>
	<20070822171805.GD2926@tuxdriver.com> <46CC7B89.7090906@lwfinger.net>
Message-ID: <5b9417770708221110w4c6a7155u8f41e9ea5a0a4a85@mail.gmail.com>

I'm sorry, I am coming into this rather late.  is this the latest
firmware for bcm43xx devices at version 4?

On 8/22/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> John W. Linville wrote:
> > On Wed, Aug 22, 2007 at 10:25:28AM -0500, Larry Finger wrote:
> >> John W. Linville wrote:
> >>> On Sun, Aug 19, 2007 at 02:37:21PM -0500, Larry Finger wrote:
> >>>> Just in case you missed the details, the latest set of changes to b43
> >>>> queued by Michael will require
> >>>> a new version of fwcutter, now called b43-fwcutter, and a new extraction
> >>>> of your firmware.
> >>> Is there a tarball available for download, as with bcm43xx-fwcutter?
> >>> It would be handy for packaging.
> >> The new code is in the svn repository; however, a tarball would not be a
> >> problem. Is source sufficient, or would you want an executable?
> >
> > Source would be fine, equivalent to what is here:
> >
> >       http://download.berlios.de/bcm43xx/bcm43xx-fwcutter-006.tar.bz2
>
> I don't have nor want write access at berlios.de.  The file you want is:
>
> ftp://lwfinger.dynalias.org/patches/b43-fwcutter-008.tar.bz2.
>
> Larry
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>


From larry.finger at lwfinger.net  Wed Aug 22 20:20:40 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 22 Aug 2007 13:20:40 -0500
Subject: ALERT: firmware change for b43
In-Reply-To: <5b9417770708221110w4c6a7155u8f41e9ea5a0a4a85@mail.gmail.com>
References: <46C89BF1.5060306@lwfinger.net>	
	<20070822145257.GA2926@tuxdriver.com>
	<46CC5568.5000709@lwfinger.net>	
	<20070822171805.GD2926@tuxdriver.com>
	<46CC7B89.7090906@lwfinger.net>
	<5b9417770708221110w4c6a7155u8f41e9ea5a0a4a85@mail.gmail.com>
Message-ID: <46CC7E78.1050607@lwfinger.net>

John H. wrote:
> I'm sorry, I am coming into this rather late.  is this the latest
> firmware for bcm43xx devices at version 4?

This is the new version of fwcutter that extracts firmware with the file names and format needed for 
b43 and b43legacy. As usual, firmware is not being distributed. The README file in the distribution 
has a link to the recommended V3 and V4 drivers from which to extract firmware.

Larry


From mb at bu3sch.de  Wed Aug 22 23:56:43 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 22 Aug 2007 23:56:43 +0200
Subject: 2.6.23-rc3-mm1: fix b43 compilation
In-Reply-To: <200708221833.59375.rjw@sisk.pl>
References: <20070822020648.5ea3a612.akpm@linux-foundation.org>
	<200708221833.59375.rjw@sisk.pl>
Message-ID: <200708222356.44088.mb@bu3sch.de>

On Wednesday 22 August 2007 18:33:58 Rafael J. Wysocki wrote:
> On Wednesday, 22 August 2007 11:06, Andrew Morton wrote:
> > 
> > ftp://ftp.kernel.org/pub/linux/kernel/people/akpm/patches/2.6/2.6.23-rc3/2.6.23-rc3-mm1/
> > 
> > - git-ixgbe.patch got dropped - git-net.patch destroyed it
> > 
> > - then git-net got dropped as it doesn't work
> 
> Apparently, the b43 driver is expecting another version of mac80211.
> 
> This patch fixes the compilation, but I'm not sure what about the
> functionality. ;-)

There seems to be a screwup somehow.
These mac80211 API functions were recently changed to include
the additional parameter. So it seems you carry an old version of mac80211.

-- 
Greetings Michael.


From mb at bu3sch.de  Thu Aug 23 00:28:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 23 Aug 2007 00:28:48 +0200
Subject: ALERT: firmware change for b43
In-Reply-To: <46CC7B89.7090906@lwfinger.net>
References: <46C89BF1.5060306@lwfinger.net>
	<20070822171805.GD2926@tuxdriver.com>
	<46CC7B89.7090906@lwfinger.net>
Message-ID: <200708230028.48464.mb@bu3sch.de>

On Wednesday 22 August 2007 20:08:09 Larry Finger wrote:
> John W. Linville wrote:
> > On Wed, Aug 22, 2007 at 10:25:28AM -0500, Larry Finger wrote:
> >> John W. Linville wrote:
> >>> On Sun, Aug 19, 2007 at 02:37:21PM -0500, Larry Finger wrote:
> >>>> Just in case you missed the details, the latest set of changes to b43 
> >>>> queued by Michael will require
> >>>> a new version of fwcutter, now called b43-fwcutter, and a new extraction 
> >>>> of your firmware.
> >>> Is there a tarball available for download, as with bcm43xx-fwcutter?
> >>> It would be handy for packaging.
> >> The new code is in the svn repository; however, a tarball would not be a 
> >> problem. Is source sufficient, or would you want an executable?
> > 
> > Source would be fine, equivalent to what is here:
> > 
> > 	http://download.berlios.de/bcm43xx/bcm43xx-fwcutter-006.tar.bz2
> 
> I don't have nor want write access at berlios.de.  The file you want is:
> 
> ftp://lwfinger.dynalias.org/patches/b43-fwcutter-008.tar.bz2.
> 

http://prdownload.berlios.de/bcm43xx/b43-fwcutter-008.tar.bz2

Larry, please remove yours again, as it's not good to have multiple tarballs
with the same name/release version floating around

-- 
Greetings Michael.


From linville at tuxdriver.com  Thu Aug 23 04:56:15 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 22 Aug 2007 22:56:15 -0400
Subject: 2.6.23-rc3-mm1: fix b43 compilation
In-Reply-To: <200708222356.44088.mb@bu3sch.de>
References: <20070822020648.5ea3a612.akpm@linux-foundation.org>
	<200708221833.59375.rjw@sisk.pl> <200708222356.44088.mb@bu3sch.de>
Message-ID: <20070823025614.GA4855@tuxdriver.com>

On Wed, Aug 22, 2007 at 11:56:43PM +0200, Michael Buesch wrote:
> On Wednesday 22 August 2007 18:33:58 Rafael J. Wysocki wrote:
> > On Wednesday, 22 August 2007 11:06, Andrew Morton wrote:
> > > 
> > > ftp://ftp.kernel.org/pub/linux/kernel/people/akpm/patches/2.6/2.6.23-rc3/2.6.23-rc3-mm1/
> > > 
> > > - git-ixgbe.patch got dropped - git-net.patch destroyed it
> > > 
> > > - then git-net got dropped as it doesn't work
> > 
> > Apparently, the b43 driver is expecting another version of mac80211.
> > 
> > This patch fixes the compilation, but I'm not sure what about the
> > functionality. ;-)
> 
> There seems to be a screwup somehow.
> These mac80211 API functions were recently changed to include
> the additional parameter. So it seems you carry an old version of mac80211.

I think what happened is because Andrew dropped Dave M.'s net tree.
Since mac80211 has been getting merged through Dave M., crucial bits
are missing which then break the bits from wireless-dev.

Andrew, if you find that you need to drop git-net again then I'll be
happy to provide you with a wireless-dev patch that does not depend on
Dave's tree.  The mm-master branch in wireless-dev has dropped those
patches which have gone to Dave M. in the hopes of avoiding conflicts.
Dependencies are another matter... :-)

John
-- 
John W. Linville
linville at tuxdriver.com


From dwmw2 at infradead.org  Thu Aug 23 11:12:10 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Thu, 23 Aug 2007 10:12:10 +0100
Subject: ALERT: firmware change for b43
In-Reply-To: <46C89BF1.5060306@lwfinger.net>
References: <46C89BF1.5060306@lwfinger.net>
Message-ID: <1187860330.22432.139.camel@pmac.infradead.org>

On Sun, 2007-08-19 at 14:37 -0500, Larry Finger wrote:
> It is recommended that you update fwcutter before these patches are
> merged. If your version of fwcutter was obtained with subversion, a
> simple 'svn update' in the fwcutter directory will suffice.
> If you are using a version provided by your distro, you will need to
> checkout the latest version with the command 'svn checkout
> svn://svn.berlios.de/bcm43xx/trunk/fwcutter'. 

Ew, Subversion. Hasn't everyone abandoned that yet?

I've set up a script to mirror it into git hourly:
	http://git.infradead.org/?p=b43-fwcutter.git
	git://git.infradead.org/b43-fwcutter.git

-- 
dwmw2



From celejar at gmail.com  Thu Aug 23 21:29:45 2007
From: celejar at gmail.com (Celejar)
Date: Thu, 23 Aug 2007 15:29:45 -0400
Subject: Hidden essids
Message-ID: <20070823152945.0d8f9865.celejar@gmail.com>

Hi,

While troubleshooting, I encountered this thread [0] about various
users' experiences associating with APs with hidden essids.  My 4318
won't associate using bcm43xx (Debian Sid, 2.6.22) with an AP hiding
its essid by broadcasting nulls in place of the essid (e.g. "\000\000
\000\000"), but using ndiswrapper it works fine.  An Atheros card
driven by Madwifi also associates correctly.

Thanks for your work on bcm43xx!

[0] http://lists.berlios.de/pipermail/bcm43xx-dev/2007-March/004179.html

Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator



From mb at bu3sch.de  Thu Aug 23 22:57:41 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 23 Aug 2007 22:57:41 +0200
Subject: ALERT: firmware change for b43
In-Reply-To: <1187860330.22432.139.camel@pmac.infradead.org>
References: <46C89BF1.5060306@lwfinger.net>
	<1187860330.22432.139.camel@pmac.infradead.org>
Message-ID: <200708232257.42291.mb@bu3sch.de>

On Thursday 23 August 2007 11:12:10 David Woodhouse wrote:
> On Sun, 2007-08-19 at 14:37 -0500, Larry Finger wrote:
> > It is recommended that you update fwcutter before these patches are
> > merged. If your version of fwcutter was obtained with subversion, a
> > simple 'svn update' in the fwcutter directory will suffice.
> > If you are using a version provided by your distro, you will need to
> > checkout the latest version with the command 'svn checkout
> > svn://svn.berlios.de/bcm43xx/trunk/fwcutter'. 
> 
> Ew, Subversion. Hasn't everyone abandoned that yet?
> 
> I've set up a script to mirror it into git hourly:
> 	http://git.infradead.org/?p=b43-fwcutter.git
> 	git://git.infradead.org/b43-fwcutter.git
> 

Well, for most of my projects. But I didn't see a really good
reason to move fwcutter to git, yet.
Maybe I should move it to git, though, as git trees are easier to handle.

-- 
Greetings Michael.


From linville at tuxdriver.com  Thu Aug 23 22:51:41 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 23 Aug 2007 16:51:41 -0400
Subject: [PATCH]  b43legacy: Initial port of new driver with bcm43xx
	PHY code and ssb/mac80211 front end
In-Reply-To: <46CC755A.5030109@lwfinger.net>
References: <46CC755A.5030109@lwfinger.net>
Message-ID: <20070823205141.GG2989@tuxdriver.com>

On Wed, Aug 22, 2007 at 12:41:46PM -0500, Larry Finger wrote:

> This patch ports the PHY and radio handling code of the softmac driver
> to the mac80211 front end from b43. The resulting driver is known as
> b43legacy.

I have added this to the b43 branch of wireless-dev.  It is available
in 'everything' as well.

-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Fri Aug 24 00:12:06 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 23 Aug 2007 17:12:06 -0500
Subject: [PATCH]  b43legacy: Initial port of new driver with bcm43xx	PHY
	code and ssb/mac80211 front end
In-Reply-To: <20070823205141.GG2989@tuxdriver.com>
References: <46CC755A.5030109@lwfinger.net>
	<20070823205141.GG2989@tuxdriver.com>
Message-ID: <46CE0636.3020303@lwfinger.net>

John W. Linville wrote:
> On Wed, Aug 22, 2007 at 12:41:46PM -0500, Larry Finger wrote:
> 
>> This patch ports the PHY and radio handling code of the softmac driver
>> to the mac80211 front end from b43. The resulting driver is known as
>> b43legacy.
> 
> I have added this to the b43 branch of wireless-dev.  It is available
> in 'everything' as well.

Thanks,

Larry


From larry.finger at lwfinger.net  Fri Aug 24 00:16:55 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 23 Aug 2007 17:16:55 -0500
Subject: ALERT: firmware change for b43
In-Reply-To: <1187860330.22432.139.camel@pmac.infradead.org>
References: <46C89BF1.5060306@lwfinger.net>
	<1187860330.22432.139.camel@pmac.infradead.org>
Message-ID: <46CE0757.8000008@lwfinger.net>

David Woodhouse wrote:
> On Sun, 2007-08-19 at 14:37 -0500, Larry Finger wrote:
>> It is recommended that you update fwcutter before these patches are
>> merged. If your version of fwcutter was obtained with subversion, a
>> simple 'svn update' in the fwcutter directory will suffice.
>> If you are using a version provided by your distro, you will need to
>> checkout the latest version with the command 'svn checkout
>> svn://svn.berlios.de/bcm43xx/trunk/fwcutter'. 
> 
> Ew, Subversion. Hasn't everyone abandoned that yet?
> 
> I've set up a script to mirror it into git hourly:
> 	http://git.infradead.org/?p=b43-fwcutter.git
> 	git://git.infradead.org/b43-fwcutter.git
> 

Although git is clearly superior, it doesn't make that much difference for small projects. Where 
Subversion still has a place, however, is where the project is code used on multiple OS's. At least 
I haven't seen a port of git to Windows. OS X wouldn't be that much trouble, I guess.

Larry


From Larry.Finger at lwfinger.net  Fri Aug 24 00:26:22 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 23 Aug 2007 17:26:22 -0500
Subject: [PATCH] ssb: Add PCI id's for BCM4301
Message-ID: <46ce098e.v5WluND71zTOa4rF%Larry.Finger@lwfinger.net>

This patch adds the pci ids for BCM4301 and BCM4303 to the bridge
module included in ssb. These devices use b43legacy.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/drivers/ssb/b43_pci_bridge.c
===================================================================
--- wireless-dev.orig/drivers/ssb/b43_pci_bridge.c
+++ wireless-dev/drivers/ssb/b43_pci_bridge.c
@@ -15,6 +15,7 @@
 
 
 static const struct pci_device_id b43_pci_bridge_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4301) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4307) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4311) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4312) },


From mb at bu3sch.de  Fri Aug 24 00:21:55 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 00:21:55 +0200
Subject: [patch 2/7] b43: Fix oops when firmware not found
References: <20070823222153.073035000@bu3sch.de>
Message-ID: <20070823222154.849018000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 002-b43-fix-oops-fw-not-found.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/830df42b/attachment.ksh>

From mb at bu3sch.de  Fri Aug 24 00:21:56 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 00:21:56 +0200
Subject: [patch 3/7] b43: allow disabling hardware encryption
References: <20070823222153.073035000@bu3sch.de>
Message-ID: <20070823222155.268828000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 003-b43-allow-disabling-hwcrypto.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/bd2e4f03/attachment.ksh>

From mb at bu3sch.de  Fri Aug 24 00:21:57 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 00:21:57 +0200
Subject: [patch 4/7] b43: Add debugfs file to extract LO calibration data
References: <20070823222153.073035000@bu3sch.de>
Message-ID: <20070823222155.727360000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 004-b43-debugfs-loctl-status.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/b8ad18f5/attachment.ksh>

From mb at bu3sch.de  Fri Aug 24 00:21:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 00:21:58 +0200
Subject: [patch 5/7] b43: Fix hwcrypto keyidx for new firmware.
References: <20070823222153.073035000@bu3sch.de>
Message-ID: <20070823222156.169085000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 005-b43-fix-hwcrypto-new-keyidx.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/fd5eec09/attachment.ksh>

From mb at bu3sch.de  Fri Aug 24 00:22:00 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 00:22:00 +0200
Subject: [patch 7/7] b43: Fix and cleanup hwcrypto
References: <20070823222153.073035000@bu3sch.de>
Message-ID: <20070823222157.102919000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 007-b43-fix-hwcrypto-key-mgmt.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/716419da/attachment.ksh>

From mb at bu3sch.de  Fri Aug 24 00:21:53 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 00:21:53 +0200
Subject: [patch 0/7] New patch series for merge
Message-ID: <20070823222153.073035000@bu3sch.de>

Hi John,

This patch series catches wireless-dev up to my
current wireless-development patchset.

Please merge this into wireless-dev.


-- 



From mb at bu3sch.de  Fri Aug 24 00:21:54 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 00:21:54 +0200
Subject: [patch 1/7] b43: Change Kconfig help text
References: <20070823222153.073035000@bu3sch.de>
Message-ID: <20070823222154.137089000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 001-b43-change-kconfig-help.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/1cc9f6bb/attachment.ksh>

From mb at bu3sch.de  Fri Aug 24 00:21:59 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 00:21:59 +0200
Subject: [patch 6/7] b43: Add missing stuff to pwork
References: <20070823222153.073035000@bu3sch.de>
Message-ID: <20070823222156.637315000@bu3sch.de>

An embedded and charset-unspecified text was scrubbed...
Name: 006-b43-pwork-add-stuff.patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/3849851c/attachment.ksh>

From Larry.Finger at lwfinger.net  Fri Aug 24 01:05:40 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 23 Aug 2007 18:05:40 -0500
Subject: [PATCH] b43, b43legacy: Fix inconsistency between branches 'b43'
	and 'everything' in wireless-dev
Message-ID: <46ce12c4.2TC1IuG0LDupBuDr%Larry.Finger@lwfinger.net>

One of Johannes's 27 patches changed the definition of the set_key callback.
Because his change got applied to the 'everything' branch, and the changes in the
b43 drivers to the 'b43' branch, the drivers in that branch are out of synch and an
"initialization from incompatible pointer type" warning is generated. When this patch
is applied to branch 'b43', it is internally consistent.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

I'm not sure how to handle this. In it's present state, branch 'b43' cannot be used
to generate a working version of b43 or b43legacy. In addition,  the Kconfig and Makefile
from b43legacy are not included, thus it is not possible to build b43legacy
in that branch.

Larry

  
diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index 9a0cf2b..19e9cf1 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -2861,8 +2861,8 @@ static int b43_dev_config(struct ieee80211_hw *hw, struct ieee80211_conf *conf)
 }
 
 static int b43_dev_set_key(struct ieee80211_hw *hw,
-			   set_key_cmd cmd, const u8 *local_addr,
-			   const u8 *addr, struct ieee80211_key_conf *key)
+			   set_key_cmd cmd, u8 *addr,
+			   struct ieee80211_key_conf *key, int aid)
 {
 	struct b43_wl *wl = hw_to_b43_wl(hw);
 	struct b43_wldev *dev = wl->current_dev;
diff --git a/drivers/net/wireless/b43legacy/main.c b/drivers/net/wireless/b43legacy/main.c
index 980cb81..f9d6938 100644
--- a/drivers/net/wireless/b43legacy/main.c
+++ b/drivers/net/wireless/b43legacy/main.c
@@ -2686,9 +2686,8 @@ out_unlock_mutex:
 }
 
 static int b43legacy_dev_set_key(struct ieee80211_hw *hw,
-				 set_key_cmd cmd,
-				 const u8 *local_addr, const u8 *addr,
-				 struct ieee80211_key_conf *key)
+				 set_key_cmd cmd, u8 *addr,
+				 struct ieee80211_key_conf *key, int aid)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev = wl->current_dev;



From linville at tuxdriver.com  Fri Aug 24 01:43:33 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 23 Aug 2007 19:43:33 -0400
Subject: [PATCH] b43, b43legacy: Fix inconsistency between branches
	'b43' and 'everything' in wireless-dev
In-Reply-To: <46ce12c4.2TC1IuG0LDupBuDr%Larry.Finger@lwfinger.net>
References: <46ce12c4.2TC1IuG0LDupBuDr%Larry.Finger@lwfinger.net>
Message-ID: <20070823234333.GA3472@tuxdriver.com>

On Thu, Aug 23, 2007 at 06:05:40PM -0500, Larry Finger wrote:

> I'm not sure how to handle this. In it's present state, branch 'b43' cannot be used
> to generate a working version of b43 or b43legacy. In addition,  the Kconfig and Makefile
> from b43legacy are not included, thus it is not possible to build b43legacy
> in that branch.

I had neglected to pull the mac80211 updates into the branches that
depend on them (now most of the driver branches).  I have done that
now, and pushed the results.

Hth!

John

P.S.  FWIW, b43legacy seems to have Kconfig and Makefile in my tree.
I was able to build it just fine.  Yes, I checked to make sure I had
included them in git. :-)
-- 
John W. Linville
linville at tuxdriver.com


From johannes at sipsolutions.net  Thu Aug 23 22:49:46 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 23 Aug 2007 22:49:46 +0200
Subject: [patch 6/6] b43: New firmware file format
In-Reply-To: <20070821201336.GA5313@tuxdriver.com>
References: <20070818234833.623623000@bu3sch.de>
	<20070818234836.401097000@bu3sch.de>
	<1187711200.4218.0.camel@johannes.berg>
	<20070821201336.GA5313@tuxdriver.com>
Message-ID: <1187902186.8363.7.camel@johannes.berg>

On Tue, 2007-08-21 at 16:13 -0400, John W. Linville wrote:

> > otherwise it oopses when the file can't be loaded.
> 
> ACK...here is a patch, in case you are lazy... :-)

Any reason you didn't push this fix this along with the patch?

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070823/9c085b42/attachment.pgp>

From johannes at sipsolutions.net  Fri Aug 24 12:08:32 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 24 Aug 2007 12:08:32 +0200
Subject: [patch 7/7] b43: Fix and cleanup hwcrypto
In-Reply-To: <20070823222157.102919000@bu3sch.de>
References: <20070823222153.073035000@bu3sch.de>
	<20070823222157.102919000@bu3sch.de>
Message-ID: <1187950112.24933.3.camel@johannes.berg>

On Fri, 2007-08-24 at 00:22 +0200, Michael Buesch wrote:

>  struct b43_key {
> -	void *keyconf;
> -	bool enabled;
> +	/* If keyconf is NULL, this key is disabled.
> +	 * keyconf is a cookie. Don't derefenrence it outside of the set_key
> +	 * path, because b43 doesn't own it. */
> +	struct ieee80211_key_conf *keyconf;

Just for clarification, you're allowed to dereference it as well if you
wish but most things you can do with it (e.g. change hw key index) are
racy.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/872895e3/attachment.pgp>

From mb at bu3sch.de  Fri Aug 24 12:10:23 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 12:10:23 +0200
Subject: b43: Copy MAC address to local struct
Message-ID: <200708241210.23562.mb@bu3sch.de>

We must copy the MAC addresses to a local struct, as we
don't own the original pointer from mac80211 and don't
know how mac80211 might mess with it while we are using it.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>

Index: wireless-dev-new/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-dev-new.orig/drivers/net/wireless/b43/b43.h	2007-08-24 00:20:03.000000000 +0200
+++ wireless-dev-new/drivers/net/wireless/b43/b43.h	2007-08-24 11:56:28.000000000 +0200
@@ -600,10 +600,10 @@ struct b43_wl {
 	 * Do not modify.
 	 */
 	int if_id;
-	/* MAC address (can be NULL). */
-	const u8 *mac_addr;
-	/* Current BSSID (can be NULL). */
-	const u8 *bssid;
+	/* The MAC address of the operating interface. */
+	u8 mac_addr[ETH_ALEN];
+	/* Current BSSID */
+	u8 bssid[ETH_ALEN];
 	/* Interface type. (IEEE80211_IF_TYPE_XXX) */
 	int if_type;
 	/* Counter of active monitor interfaces. */
Index: wireless-dev-new/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev-new.orig/drivers/net/wireless/b43/main.c	2007-08-24 00:20:03.000000000 +0200
+++ wireless-dev-new/drivers/net/wireless/b43/main.c	2007-08-24 12:02:12.000000000 +0200
@@ -537,7 +537,6 @@ void b43_macfilter_set(struct b43_wldev 
 
 static void b43_write_mac_bssid_templates(struct b43_wldev *dev)
 {
-	static const u8 zero_addr[ETH_ALEN] = { 0 };
 	const u8 *mac;
 	const u8 *bssid;
 	u8 mac_bssid[ETH_ALEN * 2];
@@ -545,11 +544,7 @@ static void b43_write_mac_bssid_template
 	u32 tmp;
 
 	bssid = dev->wl->bssid;
-	if (!bssid)
-		bssid = zero_addr;
 	mac = dev->wl->mac_addr;
-	if (!mac)
-		mac = zero_addr;
 
 	b43_macfilter_set(dev, B43_MACFILTER_BSSID, bssid);
 
@@ -569,7 +564,10 @@ static void b43_write_mac_bssid_template
 static void b43_upload_card_macaddress(struct b43_wldev *dev,
 				       const u8 * mac_addr)
 {
-	dev->wl->mac_addr = mac_addr;
+	if (mac_addr)
+		memcpy(dev->wl->mac_addr, mac_addr, ETH_ALEN);
+	else
+		memset(dev->wl->mac_addr, 0, ETH_ALEN);
 	b43_write_mac_bssid_templates(dev);
 	b43_macfilter_set(dev, B43_MACFILTER_SELF, mac_addr);
 }
@@ -3026,7 +3024,10 @@ static int b43_config_interface(struct i
 	spin_lock_irqsave(&wl->irq_lock, flags);
 	if (conf->type != IEEE80211_IF_TYPE_MNTR) {
 		B43_WARN_ON(wl->if_id != if_id);
-		wl->bssid = conf->bssid;
+		if (conf->bssid)
+			memcpy(wl->bssid, conf->bssid, ETH_ALEN);
+		else
+			memset(wl->bssid, 0, ETH_ALEN);
 		if (b43_status(dev) >= B43_STAT_INITIALIZED) {
 			if (b43_is_mode(wl, IEEE80211_IF_TYPE_AP)) {
 				B43_WARN_ON(conf->type != IEEE80211_IF_TYPE_AP);
@@ -3454,7 +3455,7 @@ static int b43_wireless_core_init(struct
 	b43_bluetooth_coext_enable(dev);
 
 	ssb_bus_powerup(bus, 1);	/* Enable dynamic PCTL */
-	wl->bssid = NULL;
+	memset(wl->bssid, 0, ETH_ALEN);
 	b43_upload_card_macaddress(dev, NULL);
 	b43_security_init(dev);
 	b43_rng_init(wl);


From johannes at sipsolutions.net  Fri Aug 24 12:15:07 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 24 Aug 2007 12:15:07 +0200
Subject: Hidden essids
In-Reply-To: <20070823152945.0d8f9865.celejar@gmail.com>
References: <20070823152945.0d8f9865.celejar@gmail.com>
Message-ID: <1187950507.24933.11.camel@johannes.berg>

On Thu, 2007-08-23 at 15:29 -0400, Celejar wrote:

> While troubleshooting, I encountered this thread [0] about various
> users' experiences associating with APs with hidden essids.  My 4318
> won't associate using bcm43xx (Debian Sid, 2.6.22) with an AP hiding
> its essid by broadcasting nulls in place of the essid (e.g. "\000\000
> \000\000")

Sounds like a softmac bug and that means it won't get fixed. Try
b43(legacy)

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/57a4f172/attachment.pgp>

From mb at bu3sch.de  Fri Aug 24 12:16:50 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 12:16:50 +0200
Subject: [patch 7/7] b43: Fix and cleanup hwcrypto
In-Reply-To: <1187950112.24933.3.camel@johannes.berg>
References: <20070823222153.073035000@bu3sch.de>
	<20070823222157.102919000@bu3sch.de>
	<1187950112.24933.3.camel@johannes.berg>
Message-ID: <200708241216.50441.mb@bu3sch.de>

On Friday 24 August 2007 12:08:32 Johannes Berg wrote:
> On Fri, 2007-08-24 at 00:22 +0200, Michael Buesch wrote:
> 
> >  struct b43_key {
> > -	void *keyconf;
> > -	bool enabled;
> > +	/* If keyconf is NULL, this key is disabled.
> > +	 * keyconf is a cookie. Don't derefenrence it outside of the set_key
> > +	 * path, because b43 doesn't own it. */
> > +	struct ieee80211_key_conf *keyconf;
> 
> Just for clarification, you're allowed to dereference it as well if you
> wish but most things you can do with it (e.g. change hw key index) are
> racy.

That's what "because b43 doesn't own it" means. :)

-- 
Greetings Michael.


From mb at bu3sch.de  Fri Aug 24 12:17:21 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 12:17:21 +0200
Subject: [patch 6/6] b43: New firmware file format
In-Reply-To: <1187902186.8363.7.camel@johannes.berg>
References: <20070818234833.623623000@bu3sch.de>
	<20070821201336.GA5313@tuxdriver.com>
	<1187902186.8363.7.camel@johannes.berg>
Message-ID: <200708241217.22209.mb@bu3sch.de>

On Thursday 23 August 2007 22:49:46 Johannes Berg wrote:
> On Tue, 2007-08-21 at 16:13 -0400, John W. Linville wrote:
> 
> > > otherwise it oopses when the file can't be loaded.
> > 
> > ACK...here is a patch, in case you are lazy... :-)
> 
> Any reason you didn't push this fix this along with the patch?

Hm? This fix is on its way into the tree.


-- 
Greetings Michael.


From johannes at sipsolutions.net  Fri Aug 24 12:27:56 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 24 Aug 2007 12:27:56 +0200
Subject: [patch 7/7] b43: Fix and cleanup hwcrypto
In-Reply-To: <200708241216.50441.mb@bu3sch.de>
References: <20070823222153.073035000@bu3sch.de>
	<20070823222157.102919000@bu3sch.de>
	<1187950112.24933.3.camel@johannes.berg>
	<200708241216.50441.mb@bu3sch.de>
Message-ID: <1187951276.24933.13.camel@johannes.berg>

On Fri, 2007-08-24 at 12:16 +0200, Michael Buesch wrote:
> On Friday 24 August 2007 12:08:32 Johannes Berg wrote:
> > On Fri, 2007-08-24 at 00:22 +0200, Michael Buesch wrote:
> > 
> > >  struct b43_key {
> > > -	void *keyconf;
> > > -	bool enabled;
> > > +	/* If keyconf is NULL, this key is disabled.
> > > +	 * keyconf is a cookie. Don't derefenrence it outside of the set_key
> > > +	 * path, because b43 doesn't own it. */
> > > +	struct ieee80211_key_conf *keyconf;
> > 
> > Just for clarification, you're allowed to dereference it as well if you
> > wish but most things you can do with it (e.g. change hw key index) are
> > racy.
> 
> That's what "because b43 doesn't own it" means. :)

I missed the "outside of the set_key" part, sorry.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/71b9ac05/attachment.pgp>

From johannes at sipsolutions.net  Fri Aug 24 12:28:14 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 24 Aug 2007 12:28:14 +0200
Subject: [patch 6/6] b43: New firmware file format
In-Reply-To: <200708241217.22209.mb@bu3sch.de>
References: <20070818234833.623623000@bu3sch.de>
	<20070821201336.GA5313@tuxdriver.com>
	<1187902186.8363.7.camel@johannes.berg>
	<200708241217.22209.mb@bu3sch.de>
Message-ID: <1187951294.24933.15.camel@johannes.berg>

On Fri, 2007-08-24 at 12:17 +0200, Michael Buesch wrote:
> On Thursday 23 August 2007 22:49:46 Johannes Berg wrote:
> > On Tue, 2007-08-21 at 16:13 -0400, John W. Linville wrote:
> > 
> > > > otherwise it oopses when the file can't be loaded.
> > > 
> > > ACK...here is a patch, in case you are lazy... :-)
> > 
> > Any reason you didn't push this fix this along with the patch?
> 
> Hm? This fix is on its way into the tree.

Yeah, never mind.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/1ece1b97/attachment.pgp>

From johannes at sipsolutions.net  Fri Aug 24 13:01:50 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 24 Aug 2007 13:01:50 +0200
Subject: [PATCH] b43: include FCS at end of frames
Message-ID: <1187953310.24933.19.camel@johannes.berg>

This patch makes b43 include the FCS at the end of
received frames, useful for monitoring.

Signed-off-by: Johannes Berg <johannes at sipsolutions.net>

---
 drivers/net/wireless/b43/main.c |    3 ++-
 drivers/net/wireless/b43/xmit.c |    1 -
 2 files changed, 2 insertions(+), 2 deletions(-)

--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-08-24 12:57:04.949420431 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-08-24 13:00:08.989420431 +0200
@@ -3934,7 +3934,8 @@ static int b43_wireless_init(struct ssb_
 	}
 
 	/* fill hw info */
-	hw->flags = IEEE80211_HW_HOST_GEN_BEACON_TEMPLATE;
+	hw->flags = IEEE80211_HW_HOST_GEN_BEACON_TEMPLATE |
+		    IEEE80211_HW_RX_INCLUDES_FCS;
 	hw->max_signal = 100;
 	hw->max_rssi = -110;
 	hw->max_noise = -110;
--- wireless-dev.orig/drivers/net/wireless/b43/xmit.c	2007-08-24 12:57:04.959420431 +0200
+++ wireless-dev/drivers/net/wireless/b43/xmit.c	2007-08-24 13:00:08.999420431 +0200
@@ -481,7 +481,6 @@ void b43_rx(struct b43_wldev *dev, struc
 	}
 	wlhdr = (struct ieee80211_hdr *)(skb->data);
 	fctl = le16_to_cpu(wlhdr->frame_control);
-	skb_trim(skb, skb->len - FCS_LEN);
 
 	if ((macstat & B43_RX_MAC_DEC) && !(macstat & B43_RX_MAC_DECERR)) {
 		unsigned int keyidx;




From hs4233 at mail.mn-solutions.de  Fri Aug 24 15:12:44 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Fri, 24 Aug 2007 15:12:44 +0200
Subject: [PATCH] b43: include FCS at end of frames
In-Reply-To: <1187953310.24933.19.camel@johannes.berg>
References: <1187953310.24933.19.camel@johannes.berg>
Message-ID: <200708241512.44463.hs4233@mail.mn-solutions.de>

> b43_wireless_init(struct ssb_ }
>
>  	/* fill hw info */
> -	hw->flags = IEEE80211_HW_HOST_GEN_BEACON_TEMPLATE;
> +	hw->flags = IEEE80211_HW_HOST_GEN_BEACON_TEMPLATE |
> +		    IEEE80211_HW_RX_INCLUDES_FCS;
>  	hw->max_signal = 100;

You must have a very different tree to wireless-dev, branch everything.
According to git blame, since 2007-08-13 the piece of code there looks
like this:

hw->flags = IEEE80211_HW_HOST_GEN_BEACON_TEMPLATE |
            IEEE80211_HW_MONITOR_DURING_OPER |
            IEEE80211_HW_DEVICE_HIDES_WEP | IEEE80211_HW_WEP_INCLUDE_IV;

The patch subject in this mailing list was
"[RFC 5/10] Port of bcm43xx from softmac to mac80211"


From hs4233 at mail.mn-solutions.de  Fri Aug 24 16:16:56 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Fri, 24 Aug 2007 16:16:56 +0200
Subject: minor grips with b43
Message-ID: <200708241616.56746.hs4233@mail.mn-solutions.de>

I have a 2.6.22.5 kernel where I implanted

* ssb
* mac80211
* radiotab
* b43

from linux-wireless-dev, branch everything, commit 
0347a7c86f8406b1058870bb11f0c739dc2b9bf2. I also
put the firmware according to 
http://www.linuxwireless.org/en/users/Drivers/b43 into 
lib/firmware/b43.

When I power-up my device, I only see that ssb has been loaded. 
Not "b43.ko" as well. Is this expected?




# ifup eth1
Internet Systems Consortium DHCP Client V3.0.4
Copyright 2004-2006 Internet Systems Consortium.
All rights reserved.
For info, please visit http://www.isc.org/sw/dhcp/

wmaster0: unknown hardware address type 801
b32-phy0 ERROR: bbatt(11) >= size of LO array
...

Is this error serious?


I was able to connect to my AP, despite the error.


From celejar at gmail.com  Fri Aug 24 16:35:58 2007
From: celejar at gmail.com (Celejar)
Date: Fri, 24 Aug 2007 10:35:58 -0400
Subject: Hidden essids
In-Reply-To: <1187950507.24933.11.camel@johannes.berg>
References: <20070823152945.0d8f9865.celejar@gmail.com>
	<1187950507.24933.11.camel@johannes.berg>
Message-ID: <20070824103558.590d6fd4.celejar@gmail.com>

On Fri, 24 Aug 2007 12:15:07 +0200
Johannes Berg <johannes at sipsolutions.net> wrote:

> On Thu, 2007-08-23 at 15:29 -0400, Celejar wrote:
> 
> > While troubleshooting, I encountered this thread [0] about various
> > users' experiences associating with APs with hidden essids.  My 4318
> > won't associate using bcm43xx (Debian Sid, 2.6.22) with an AP hiding
> > its essid by broadcasting nulls in place of the essid (e.g. "\000\000
> > \000\000")
> 
> Sounds like a softmac bug and that means it won't get fixed. Try
> b43(legacy)

Sorry, I should've mentioned that it's apparently indeed a SoftMac
issue.  From the logs:

> Aug 24 09:54:19 lizzie kernel: SoftMAC: Associate: Scanning for networks first.
> Aug 24 09:54:20 lizzie kernel: SoftMAC: Scanning finished: scanned 13 channels starting with channel 1
> Aug 24 09:54:20 lizzie kernel: SoftMAC: Associate: Scanning for networks first.
> Aug 24 09:54:20 lizzie kernel: SoftMAC: Scanning finished: scanned 13 channels starting with channel 1
> Aug 24 09:54:20 lizzie kernel: SoftMAC: Associate: Scanning for networks first.
> Aug 24 09:54:20 lizzie dhclient: Listening on LPF/eth0/00:19:7d:06:a5:44
> Aug 24 09:54:20 lizzie dhclient: Sending on   LPF/eth0/00:19:7d:06:a5:44
> Aug 24 09:54:20 lizzie dhclient: Sending on   Socket/fallback
> Aug 24 09:54:20 lizzie kernel: SoftMAC: Scanning finished: scanned 13 channels starting with channel 1
> Aug 24 09:54:20 lizzie kernel: SoftMAC: Unable to find matching network after scan! 

> johannes

Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator


From Larry.Finger at lwfinger.net  Fri Aug 24 16:51:07 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 24 Aug 2007 09:51:07 -0500
Subject: [PATCH] b43legacy: include FCS at end of frames
Message-ID: <46cef05b.b4GMsfzDEIAHVQ2a%Larry.Finger@lwfinger.net>

From: Johannes Berg <johannes at sipsolutions.net>

This patch makes b43legacy include the FCS at the end of
received frames, useful for monitoring.

Signed-off-by: Johannes Berg <johannes at sipsolutions.net>
Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

 drivers/net/wireless/b43legacy/main.c |    3 ++-
 drivers/net/wireless/b43legacy/xmit.c |    1 -
 2 files changed, 2 insertions(+), 2 deletions(-)

Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -3623,7 +3623,8 @@ static int b43legacy_wireless_init(struc
 
 	/* fill hw info */
 	hw->flags = IEEE80211_HW_HOST_GEN_BEACON_TEMPLATE |
-		    IEEE80211_HW_WEP_INCLUDE_IV;
+		    IEEE80211_HW_WEP_INCLUDE_IV |
+		    IEEE80211_HW_RX_INCLUDES_FCS;
 	hw->max_signal = 100;
 	hw->max_rssi = -110;
 	hw->max_noise = -110;
Index: wireless-dev/drivers/net/wireless/b43legacy/xmit.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/xmit.c
+++ wireless-dev/drivers/net/wireless/b43legacy/xmit.c
@@ -465,7 +465,6 @@ void b43legacy_rx(struct b43legacy_wldev
 	}
 	wlhdr = (struct ieee80211_hdr *)(skb->data);
 	fctl = le16_to_cpu(wlhdr->frame_control);
-	skb_trim(skb, skb->len - FCS_LEN);
 
 	if ((macstat & B43legacy_RX_MAC_DEC) &&
 	    !(macstat & B43legacy_RX_MAC_DECERR)) {


From larry.finger at lwfinger.net  Fri Aug 24 17:03:58 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 24 Aug 2007 10:03:58 -0500
Subject: minor grips with b43
In-Reply-To: <200708241616.56746.hs4233@mail.mn-solutions.de>
References: <200708241616.56746.hs4233@mail.mn-solutions.de>
Message-ID: <46CEF35E.9050105@lwfinger.net>

Holger Schurig wrote:
> I have a 2.6.22.5 kernel where I implanted
> 
> * ssb
> * mac80211
> * radiotab
> * b43
> 
> from linux-wireless-dev, branch everything, commit 
> 0347a7c86f8406b1058870bb11f0c739dc2b9bf2. I also
> put the firmware according to 
> http://www.linuxwireless.org/en/users/Drivers/b43 into 
> lib/firmware/b43.
> 
> When I power-up my device, I only see that ssb has been loaded. 
> Not "b43.ko" as well. Is this expected?

Where were you looking? In dmesg, you should see something like:

ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x11, vendor 0x4243)
ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0A, vendor 0x4243)
ssb: Core 2 found: USB 1.1 Host (cc 0x817, rev 0x03, vendor 0x4243)
ssb: Core 3 found: PCI-E (cc 0x820, rev 0x01, vendor 0x4243)
ssb: Sonics Silicon Backplane found on PCI device 0000:01:00.0
b43-phy0: Broadcom 4311 WLAN found

There will not be any other b43 messages until the interface is brought up.

> wmaster0: unknown hardware address type 801
> b32-phy0 ERROR: bbatt(11) >= size of LO array
> ...
> 
> Is this error serious?
> 
> 
> I was able to connect to my AP, despite the error.

I assume that you meant b43 when you typed b32, but that error is not serious. It results from a 
problem with the specs. It will happen every time until the root cause is found. Depending on which 
BCM43xx model you have, you may also see errors like

b43-phy0 debug: Invalid LO control pair (I: 111, Q: 111)

and

b43-phy0 ERROR: Adjusting Local Oscillator to an uncalibrated control pair: rfatt=3,no-padmix bbatt=2

These are due to errors in the code and/or errors in the specs.

We are working on all these problems. What effect they have on the performance is unknown, but it 
cannot be too severe. Last night I had to boot into Windows (uugh!!) and happened to notice that the 
bit rate for my BCM4311 was toggling between 18 and 24M. With the same setup, b43 usually is at 
either 48 or 54M. Take that Broadcom!!!!!!!

Larry


From hs4233 at mail.mn-solutions.de  Fri Aug 24 17:42:39 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Fri, 24 Aug 2007 17:42:39 +0200
Subject: minor grips with b43
In-Reply-To: <46CEF35E.9050105@lwfinger.net>
References: <200708241616.56746.hs4233@mail.mn-solutions.de>
	<46CEF35E.9050105@lwfinger.net>
Message-ID: <200708241742.39388.hs4233@mail.mn-solutions.de>

> > When I power-up my device, I only see that ssb has been
> > loaded. Not "b43.ko" as well. Is this expected?
>
> Where were you looking?

If "b43.ko" has been loaded?  With lsmod:

# lsmod
Module                  Size  Used by
mousedev                5800  0
ssb                    19204  0
usbtouchscreen          3332  0

> In dmesg, you should see something 
> like:
>
> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x11, vendor 0x4243)
> ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0A, vendor 0x4243)
> ssb: Core 2 found: USB 1.1 Host (cc 0x817, rev 0x03, vendor 0x4243)
> ssb: Core 3 found: PCI-E (cc 0x820, rev 0x01, vendor 0x4243)
> ssb: Sonics Silicon Backplane found on PCI device 0000:01:00.0
> b43-phy0: Broadcom 4311 WLAN found 

My output here is:

ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x04, vendor 0x4243)
ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x05, vendor 0x4243)
ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x02, vendor 0x4243)
ssb: Core 3 found: V90 (cc 0x807, rev 0x02, vendor 0x4243)
ssb: Core 4 found: PCI (cc 0x804, rev 0x09, vendor 0x4243)
ssb: Sonics Silicon Backplane found on PCI device 0000:03:00.0

And, because b43.ko doesn't get auto-loaded, I don't have a
"b43-phy0"-line.




I'm not sure if the following is relevant, but here is the
output of "lspci -n":

03:00.0 0280: 14e4:4320 (rev 03)

And if I manually "modprobe b43", I get this:

b43-phy0: Broadcom 4306 WLAN found
b43-phy0 debug: Found PHY: Analog 2, Type 2, Revision 2
b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
b43-phy0 debug: Radio turned off
wmaster0: Selected rate control algorithm 'simple'

After "iwconfig eth1 essid XXXXX", "iwconfig eth1 key s:XXXXX"
and "ifconfig eth1 up", I get this:

b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Radio turned on
b43-phy0 debug: Radio enabled by hardware
b43-phy0 ERROR: bbatt(11) >= size of LO array
b43-phy0 debug: Chip initialized
b43-phy0 debug: 30-bit DMA initialized
b43-phy0 debug: Wireless interface started
HW CONFIG: channel=1 freq=2412 phymode=3
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff

But I'm pretty sure this is unrelated to auto-loading b43 :-)



> I assume that you meant b43 when you typed b32

Yes. That's why I did "dmesg >a" and "scp" for the texts above :-)



> you may also see errors like
> b43-phy0 debug: Invalid LO control pair (I: 111, Q: 111)
> and
> b43-phy0 ERROR: Adjusting Local Oscillator to an uncalibrated control pair: rfatt=3,no-padmix bbatt=2

Fortunately not in my case.



> the bit rate for my BCM4311 was toggling between 18 and 24M.
> With the same setup, b43 usually is at either 48 or 54M.
> Take that Broadcom!!!!!!! 

I don't care that much for bitrate, I'd rather have a very
long range, even when it's only 1 MB/s. My main application
is SSH :-)


From linville at tuxdriver.com  Fri Aug 24 17:26:29 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Fri, 24 Aug 2007 11:26:29 -0400
Subject: minor grips with b43
In-Reply-To: <46CEF35E.9050105@lwfinger.net>
References: <200708241616.56746.hs4233@mail.mn-solutions.de>
	<46CEF35E.9050105@lwfinger.net>
Message-ID: <20070824152629.GA3438@tuxdriver.com>

On Fri, Aug 24, 2007 at 10:03:58AM -0500, Larry Finger wrote:

> We are working on all these problems. What effect they have on the performance is unknown, but it 
> cannot be too severe. Last night I had to boot into Windows (uugh!!) and happened to notice that the 
> bit rate for my BCM4311 was toggling between 18 and 24M. With the same setup, b43 usually is at 
> either 48 or 54M. Take that Broadcom!!!!!!!

Hereby nominated for quote of the day, 2007-08-24... :-)

-- 
John W. Linville
linville at tuxdriver.com


From mistamaila at gmail.com  Fri Aug 24 18:05:30 2007
From: mistamaila at gmail.com (John H.)
Date: Fri, 24 Aug 2007 11:05:30 -0500
Subject: bcm43xx-mac80211 problems with advanced wpa
In-Reply-To: <5b9417770708220810x5b3fb9f9ndbd97f9bdeca55d7@mail.gmail.com>
References: <5b9417770708220810x5b3fb9f9ndbd97f9bdeca55d7@mail.gmail.com>
Message-ID: <5b9417770708240905j61e6e61ep965c8830edfcc76f@mail.gmail.com>

Hi, Larry responded to me and apparently didn't understand what I was
saying here.  This has nothing to do with NetworkManager.  I thought
this was clear by actually quoting my wpa_supplicant.conf, but
apparently not.

With wpa_supplicant and NOTHING to do with networkmanager, ndiswrapper
works with this network but bcm43xx-mac80211 does not, with the errors
mentioned.  Despite being told by Larry that I refused to change my
kernel, I upgraded, as was suggested by the list, to koji 2.6.22.1-50.
 I specifically explained this already.  bcm43xx-mac80211 works with
other networks, but not those such as this one.

What to do so I can using bcm43xx-mac80211 with this network?

On 8/22/07, John H. <mistamaila at gmail.com> wrote:
> Hi, i just went back to school and they have a more advanced wpa
> network that I was not able to get on with bcm43xx-mac80211 but I can
> with ndiswrapper.
>
> Here's the setup in wpa_supplicant.conf
> network={
>         ssid="schoolid"
>         key_mgmt=WPA-EAP
>         pairwise=TKIP
>         group=TKIP
>         scan_ssid=1
>         eap=PEAP
>         identity="user"
>         password="pass"
> #       ca_cert="/etc/cert/ca.pem"
> #       phase1="peaplabel=1"
>        phase2="auth=MSCHAPV2"
> }
>
>
> Here's the error with wpa
>
>
> /etc/rc.d/init.d/wpa_supplicant start
> Starting wpa_supplicant: ioctl[SIOCSIWAUTH]: Operation not supported
> WEXT auth param 4 value 0x0 - ioctl[SIOCSIWAUTH]: Operation not
> supported
> WEXT auth param 5 value 0x1 -
>
>
> As I said, it works fine with ndiswrapper.
>
> what to do?  I'd prefer to stick with the bcm43xx-mac80211:)
>


From larry.finger at lwfinger.net  Fri Aug 24 18:20:00 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 24 Aug 2007 11:20:00 -0500
Subject: minor grips with b43
In-Reply-To: <200708241742.39388.hs4233@mail.mn-solutions.de>
References: <200708241616.56746.hs4233@mail.mn-solutions.de>
	<46CEF35E.9050105@lwfinger.net>
	<200708241742.39388.hs4233@mail.mn-solutions.de>
Message-ID: <46CF0530.8000709@lwfinger.net>

Holger Schurig wrote:
>>> When I power-up my device, I only see that ssb has been
>>> loaded. Not "b43.ko" as well. Is this expected?
>> Where were you looking?
> 
> If "b43.ko" has been loaded?  With lsmod:
> 
> # lsmod
> Module                  Size  Used by
> mousedev                5800  0
> ssb                    19204  0
> usbtouchscreen          3332  0
> 
>> In dmesg, you should see something 
>> like:
>>
>> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x11, vendor 0x4243)
>> ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0A, vendor 0x4243)
>> ssb: Core 2 found: USB 1.1 Host (cc 0x817, rev 0x03, vendor 0x4243)
>> ssb: Core 3 found: PCI-E (cc 0x820, rev 0x01, vendor 0x4243)
>> ssb: Sonics Silicon Backplane found on PCI device 0000:01:00.0
>> b43-phy0: Broadcom 4311 WLAN found 
> 
> My output here is:
> 
> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x04, vendor 0x4243)
> ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x05, vendor 0x4243)
> ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x02, vendor 0x4243)
> ssb: Core 3 found: V90 (cc 0x807, rev 0x02, vendor 0x4243)
> ssb: Core 4 found: PCI (cc 0x804, rev 0x09, vendor 0x4243)
> ssb: Sonics Silicon Backplane found on PCI device 0000:03:00.0
> 
> And, because b43.ko doesn't get auto-loaded, I don't have a
> "b43-phy0"-line.
> 
> 
> 
> 
> I'm not sure if the following is relevant, but here is the
> output of "lspci -n":
> 
> 03:00.0 0280: 14e4:4320 (rev 03)
> 
> And if I manually "modprobe b43", I get this:
> 
> b43-phy0: Broadcom 4306 WLAN found
> b43-phy0 debug: Found PHY: Analog 2, Type 2, Revision 2
> b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> b43-phy0 debug: Radio turned off
> wmaster0: Selected rate control algorithm 'simple'
> 
> After "iwconfig eth1 essid XXXXX", "iwconfig eth1 key s:XXXXX"
> and "ifconfig eth1 up", I get this:
> 
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Radio turned on
> b43-phy0 debug: Radio enabled by hardware
> b43-phy0 ERROR: bbatt(11) >= size of LO array
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 30-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> HW CONFIG: channel=1 freq=2412 phymode=3
> b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
> 
> But I'm pretty sure this is unrelated to auto-loading b43 :-)
> 
> 
> 
>> I assume that you meant b43 when you typed b32
> 
> Yes. That's why I did "dmesg >a" and "scp" for the texts above :-)
> 
> 
> 
>> you may also see errors like
>> b43-phy0 debug: Invalid LO control pair (I: 111, Q: 111)
>> and
>> b43-phy0 ERROR: Adjusting Local Oscillator to an uncalibrated control pair: rfatt=3,no-padmix bbatt=2
> 
> Fortunately not in my case.

Are you using openSUSE 10.2? If so, you need to add the following rule to 
/etc/udev/rules.d/80-sysconfig.rules:

SUBSYSTEM=="ssb", ACTION=="add", ENV{MODALIAS}=="?*", RUN+="/sbin/modprobe $env{MODALIAS}"

If you are running a different distribution, the change will probably be different, but it will be 
caused by udev not processing ssb events.

Larry


From freggy at gmail.com  Fri Aug 24 22:31:59 2007
From: freggy at gmail.com (Frederik)
Date: Fri, 24 Aug 2007 22:31:59 +0200
Subject: bcm43xx-mac80211 problems with advanced wpa
In-Reply-To: <5b9417770708220810x5b3fb9f9ndbd97f9bdeca55d7@mail.gmail.com>
References: <5b9417770708220810x5b3fb9f9ndbd97f9bdeca55d7@mail.gmail.com>
Message-ID: <28d495d10708241331u4982c3b7u9d3a50bbb374a801@mail.gmail.com>

On 8/22/07, John H. <mistamaila at gmail.com> wrote:
> Hi, i just went back to school and they have a more advanced wpa
> network that I was not able to get on with bcm43xx-mac80211 but I can
> with ndiswrapper.
>
> Here's the setup in wpa_supplicant.conf
[snip]
> /etc/rc.d/init.d/wpa_supplicant start
> Starting wpa_supplicant: ioctl[SIOCSIWAUTH]: Operation not supported
> WEXT auth param 4 value 0x0 - ioctl[SIOCSIWAUTH]: Operation not
> supported
> WEXT auth param 5 value 0x1 -
>
> As I said, it works fine with ndiswrapper.

Last week I also posted a message of not being able to associate with
my WPA protected AP, while bcm43xx works without any problem. Maybe
try that driver. And also try to run wpa_supplicant with debbuging
information, and post dmesg output, like I didm maybe we'll have to
conclude this is the same problem?

-- 
Frederik


From hs4233 at mail.mn-solutions.de  Fri Aug 24 22:54:43 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Fri, 24 Aug 2007 22:54:43 +0200
Subject: minor grips with b43
In-Reply-To: <46CF0530.8000709@lwfinger.net>
References: <200708241616.56746.hs4233@mail.mn-solutions.de>
	<200708241742.39388.hs4233@mail.mn-solutions.de>
	<46CF0530.8000709@lwfinger.net>
Message-ID: <200708242254.44010.hs4233@mail.mn-solutions.de>

> Are you using openSUSE 10.2? If so, you need to add the following rule to 
> /etc/udev/rules.d/80-sysconfig.rules:
> 
> SUBSYSTEM=="ssb", ACTION=="add", ENV{MODALIAS}=="?*", RUN+="/sbin/modprobe $env{MODALIAS}"

Debian/Etch. Thanks for this tip, will try later.


From mb at bu3sch.de  Fri Aug 24 23:26:52 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 23:26:52 +0200
Subject: minor grips with b43
In-Reply-To: <46CEF35E.9050105@lwfinger.net>
References: <200708241616.56746.hs4233@mail.mn-solutions.de>
	<46CEF35E.9050105@lwfinger.net>
Message-ID: <200708242326.52877.mb@bu3sch.de>

On Friday 24 August 2007 17:03:58 Larry Finger wrote:
> I assume that you meant b43 when you typed b32, but that error is not serious. It results from a 
> problem with the specs. It will happen every time until the root cause is found. Depending on which 
> BCM43xx model you have, you may also see errors like
> 
> b43-phy0 debug: Invalid LO control pair (I: 111, Q: 111)
> 
> and
> 
> b43-phy0 ERROR: Adjusting Local Oscillator to an uncalibrated control pair: rfatt=3,no-padmix bbatt=2
> 
> These are due to errors in the code and/or errors in the specs.

I am going to submit a workaround for these, soon.
The workaround will always calibrate the whole LO table. That will
take some more time to calibrate then, but it should fix the actual bug.
I think that should be OK for now. Especially as the calibration is
preemptible, so the user shouldn't really notice it in userspace.
Though, it might cause a few less minutes of battery power. But I'm pretty
sure it won't be a lot.

-- 
Greetings Michael.


From mb at bu3sch.de  Fri Aug 24 23:30:02 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 23:30:02 +0200
Subject: [PATCH] b43legacy: include FCS at end of frames
In-Reply-To: <46cef05b.b4GMsfzDEIAHVQ2a%Larry.Finger@lwfinger.net>
References: <46cef05b.b4GMsfzDEIAHVQ2a%Larry.Finger@lwfinger.net>
Message-ID: <200708242330.02961.mb@bu3sch.de>

On Friday 24 August 2007 16:51:07 Larry Finger wrote:
> From: Johannes Berg <johannes at sipsolutions.net>
> 
> This patch makes b43legacy include the FCS at the end of
> received frames, useful for monitoring.

Did you test this with WEP, WPA/AES and without encryption?
There was a very good reason why I chose to strip and IV, ICV
and FCS of the end of frames. And it was crypto related.
Maybe that limitation was removed, so this patch might actually
be OK. But please test it on all crypto configs.

> Signed-off-by: Johannes Berg <johannes at sipsolutions.net>
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
>  drivers/net/wireless/b43legacy/main.c |    3 ++-
>  drivers/net/wireless/b43legacy/xmit.c |    1 -
>  2 files changed, 2 insertions(+), 2 deletions(-)
> 
> Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
> +++ wireless-dev/drivers/net/wireless/b43legacy/main.c
> @@ -3623,7 +3623,8 @@ static int b43legacy_wireless_init(struc
>  
>  	/* fill hw info */
>  	hw->flags = IEEE80211_HW_HOST_GEN_BEACON_TEMPLATE |
> -		    IEEE80211_HW_WEP_INCLUDE_IV;
> +		    IEEE80211_HW_WEP_INCLUDE_IV |
> +		    IEEE80211_HW_RX_INCLUDES_FCS;
>  	hw->max_signal = 100;
>  	hw->max_rssi = -110;
>  	hw->max_noise = -110;
> Index: wireless-dev/drivers/net/wireless/b43legacy/xmit.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/xmit.c
> +++ wireless-dev/drivers/net/wireless/b43legacy/xmit.c
> @@ -465,7 +465,6 @@ void b43legacy_rx(struct b43legacy_wldev
>  	}
>  	wlhdr = (struct ieee80211_hdr *)(skb->data);
>  	fctl = le16_to_cpu(wlhdr->frame_control);
> -	skb_trim(skb, skb->len - FCS_LEN);
>  
>  	if ((macstat & B43legacy_RX_MAC_DEC) &&
>  	    !(macstat & B43legacy_RX_MAC_DECERR)) {


-- 
Greetings Michael.


From mb at bu3sch.de  Fri Aug 24 23:37:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 24 Aug 2007 23:37:51 +0200
Subject: [PATCH] b43legacy: include FCS at end of frames
In-Reply-To: <200708242330.02961.mb@bu3sch.de>
References: <46cef05b.b4GMsfzDEIAHVQ2a%Larry.Finger@lwfinger.net>
	<200708242330.02961.mb@bu3sch.de>
Message-ID: <200708242337.51414.mb@bu3sch.de>

On Friday 24 August 2007 23:30:02 Michael Buesch wrote:
> On Friday 24 August 2007 16:51:07 Larry Finger wrote:
> > From: Johannes Berg <johannes at sipsolutions.net>
> > 
> > This patch makes b43legacy include the FCS at the end of
> > received frames, useful for monitoring.
> 
> Did you test this with WEP, WPA/AES and without encryption?
> There was a very good reason why I chose to strip and IV, ICV
> and FCS of the end of frames. And it was crypto related.
> Maybe that limitation was removed, so this patch might actually
> be OK. But please test it on all crypto configs.

Oh, forget it. b43legacy doesn't do hwcrypto. So this should be OK.


-- 
Greetings Michael.


From andrig.t.miller at gmail.com  Sat Aug 25 00:36:43 2007
From: andrig.t.miller at gmail.com (Andrig T. Miller)
Date: Fri, 24 Aug 2007 16:36:43 -0600
Subject: Updated Status on b43 driver and Fedora 7
Message-ID: <313c6e90708241536q6c22d23bnf892e3e6a5dbcb97@mail.gmail.com>

I booted a new Fedora kernel this morning, and it loaded the new b43 driver,
and I still had the v4 firmware in /lib/firmware.  The first time I
connected it connected at 2 Mb/s, versus the 1 Mb/s that it used to connect
at.  I had needed to reboot a second time for an unrelated reason, and when
it connected the next time I connected at 5 Mb/s, and I have been happily
using my internal Broadcom 4318 wireless networking all day, without issue.

Thanks for all the hard work, it is really paying off!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/8d98d02f/attachment.html>

From dostrow at gentoo.org  Sat Aug 25 00:49:25 2007
From: dostrow at gentoo.org (Daniel Ostrow)
Date: Fri, 24 Aug 2007 15:49:25 -0700
Subject: bcm43xx-mac80211 problems with advanced wpa
In-Reply-To: <5b9417770708220810x5b3fb9f9ndbd97f9bdeca55d7@mail.gmail.com>
References: <5b9417770708220810x5b3fb9f9ndbd97f9bdeca55d7@mail.gmail.com>
Message-ID: <1187995765.6290.19.camel@ashe.anyarch.net>

<snip>
> ioctl[SIOCSIWAUTH]: Operation not supported
> WEXT auth param 4 value 0x0 - 
> ioctl[SIOCSIWAUTH]: Operation not supported
> WEXT auth param 5 value 0x1 -
</snip>

For what it is worth I get the above messages from wpa_supplicant as
well using b43. They don't seem to inhibit the functionality of my setup
at all but I am including details below for whatever the information
will help with.

My system is a Dell Latitude D520, it has a 4311 in addition to a b44
wired nick, I have ssb, b44 and b43 compiled as modules (not by choice
but my machine panics if I build in ssb and b44 and leave b43 as a
module) from a pull of the #everything branch from Linville's
wireless-dev tree from yesterday. I am running Gentoo (as if the e-mail
address didn't give that away) with wpa_supplicant-0.5.8. I am
connecting to two different networks using wpa_supplicant one WPA-PSK
the other WPA2-PSK, the (edited) configs are below.

network={
	ssid="gatekeeper"
	key_mgmt=WPA-PSK
	psk="<pass-key>"
	priority=1
}

network={
	ssid="WSTMBLG2"
	proto=RSN
	key_mgmt=WPA-PSK
	pairwise=TKIP
	group=TKIP
	psk="<pass-key>"
	priority=2
}

I did not see these messages from wpa_supplicant before I moved to b43
from bcm43xx (softmac). As I said though...they don't seem to inhibit
anything, I associate and connect at very good rates, just thought I'd
pass along the anecdotal information. Kepp up the great work, the driver
works like a charm!

--Dan
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070824/f2622ce7/attachment.pgp>

From larry.finger at lwfinger.net  Sat Aug 25 00:50:12 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 24 Aug 2007 17:50:12 -0500
Subject: Updated Status on b43 driver and Fedora 7
In-Reply-To: <313c6e90708241536q6c22d23bnf892e3e6a5dbcb97@mail.gmail.com>
References: <313c6e90708241536q6c22d23bnf892e3e6a5dbcb97@mail.gmail.com>
Message-ID: <46CF60A4.7070705@lwfinger.net>

Andrig T. Miller wrote:
> I booted a new Fedora kernel this morning, and it loaded the new b43 
> driver, and I still had the v4 firmware in /lib/firmware.  The first 
> time I connected it connected at 2 Mb/s, versus the 1 Mb/s that it used 
> to connect at.  I had needed to reboot a second time for an unrelated 
> reason, and when it connected the next time I connected at 5 Mb/s, and I 
> have been happily using my internal Broadcom 4318 wireless networking 
> all day, without issue.
> 
> Thanks for all the hard work, it is really paying off!

It is connecting at 1 Mbs every time, the increases are the natural ramp-up of the rates. Why it 
differed from boot to boot is probably a matter of when you happened to check and how many 
transmissions happened before you looked.

If your V4 firmware is still in /lib/firmware, then the Fedora kernel is a little behind the 
wireless-dev tree. Once the code that uses the new naming scheme hits their kernel, your wireless 
will probably stop working. Be prepared.

Yes, the new driver is very solid.

Larry


From larry.finger at lwfinger.net  Sat Aug 25 00:56:16 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 24 Aug 2007 17:56:16 -0500
Subject: bcm43xx-mac80211 problems with advanced wpa
In-Reply-To: <1187995765.6290.19.camel@ashe.anyarch.net>
References: <5b9417770708220810x5b3fb9f9ndbd97f9bdeca55d7@mail.gmail.com>
	<1187995765.6290.19.camel@ashe.anyarch.net>
Message-ID: <46CF6210.5010705@lwfinger.net>

Daniel Ostrow wrote:
> <snip>
>> ioctl[SIOCSIWAUTH]: Operation not supported
>> WEXT auth param 4 value 0x0 - 
>> ioctl[SIOCSIWAUTH]: Operation not supported
>> WEXT auth param 5 value 0x1 -
> </snip>
> 
> For what it is worth I get the above messages from wpa_supplicant as
> well using b43. They don't seem to inhibit the functionality of my setup
> at all but I am including details below for whatever the information
> will help with.
> 
> My system is a Dell Latitude D520, it has a 4311 in addition to a b44
> wired nick, I have ssb, b44 and b43 compiled as modules (not by choice
> but my machine panics if I build in ssb and b44 and leave b43 as a
> module) from a pull of the #everything branch from Linville's
> wireless-dev tree from yesterday. I am running Gentoo (as if the e-mail
> address didn't give that away) with wpa_supplicant-0.5.8. I am
> connecting to two different networks using wpa_supplicant one WPA-PSK
> the other WPA2-PSK, the (edited) configs are below.
> 
> network={
> 	ssid="gatekeeper"
> 	key_mgmt=WPA-PSK
> 	psk="<pass-key>"
> 	priority=1
> }
> 
> network={
> 	ssid="WSTMBLG2"
> 	proto=RSN
> 	key_mgmt=WPA-PSK
> 	pairwise=TKIP
> 	group=TKIP
> 	psk="<pass-key>"
> 	priority=2
> }
> 
> I did not see these messages from wpa_supplicant before I moved to b43
> from bcm43xx (softmac). As I said though...they don't seem to inhibit
> anything, I associate and connect at very good rates, just thought I'd
> pass along the anecdotal information. Kepp up the great work, the driver
> works like a charm!

In bcm43xx, those IOCTL's were implemented. In mac80211, they are not as they are not needed. As you 
see, those messages are not fatal.

Larry


From mb at bu3sch.de  Sat Aug 25 02:01:44 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 25 Aug 2007 02:01:44 +0200
Subject: b43: Always calibrate all LO control values
Message-ID: <200708250201.44950.mb@bu3sch.de>

This is a workaround that (optionally) removes the broken
optimization to only calibrate "needed" control values.
With this applied, all possible control values are always
calibrated and some runtime warnings vanish.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-dev-new/drivers/net/wireless/b43/lo.h
===================================================================
--- wireless-dev-new.orig/drivers/net/wireless/b43/lo.h	2007-08-24 13:21:54.000000000 +0200
+++ wireless-dev-new/drivers/net/wireless/b43/lo.h	2007-08-25 01:01:32.000000000 +0200
@@ -55,7 +55,7 @@ static inline bool b43_loctl_is_calibrat
  * Use b43_get_lo_g_ctl() to retrieve a value from the lists.
  */
 struct b43_txpower_lo_control {
-#define B43_NR_BB	9
+#define B43_NR_BB	12
 #define B43_NR_RF	16
 	/* LO Control values, with PAD Mixer */
 	struct b43_loctl with_padmix[B43_NR_BB][B43_NR_RF];
Index: wireless-dev-new/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-dev-new.orig/drivers/net/wireless/b43/lo.c	2007-08-24 13:21:54.000000000 +0200
+++ wireless-dev-new/drivers/net/wireless/b43/lo.c	2007-08-25 01:42:55.000000000 +0200
@@ -35,6 +35,12 @@
 #include <linux/delay.h>
 #include <linux/sched.h>
 
+
+/* Define to 1 to always calibrate all possible LO control pairs.
+ * This is a workaround until we fix the partial LO calibration optimization. */
+#define B43_CALIB_ALL_LOCTLS	1
+
+
 /* Write the LocalOscillator Control (adjust) value-pair. */
 static void b43_lo_write(struct b43_wldev *dev, struct b43_loctl *control)
 {
@@ -77,6 +83,7 @@ static int assert_rfatt_and_bbatt(const 
 	return err;
 }
 
+#if !B43_CALIB_ALL_LOCTLS
 static
 struct b43_loctl *b43_get_lo_g_ctl_nopadmix(struct b43_wldev *dev,
 					    const struct b43_rfatt *rfatt,
@@ -89,6 +96,7 @@ struct b43_loctl *b43_get_lo_g_ctl_nopad
 		return &(lo->no_padmix[0][0]);	/* Just prevent a crash */
 	return &(lo->no_padmix[bbatt->att][rfatt->att]);
 }
+#endif /* !B43_CALIB_ALL_LOCTLS */
 
 struct b43_loctl *b43_get_lo_g_ctl(struct b43_wldev *dev,
 				   const struct b43_rfatt *rfatt,
@@ -936,6 +944,66 @@ static void lo_probe_loctls_statemachine
 	} while (++repeat_cnt < max_repeat);
 }
 
+#if B43_CALIB_ALL_LOCTLS
+static const struct b43_rfatt b43_full_rfatt_list_items[] = {
+	{ .att = 0, .with_padmix = 0, },
+	{ .att = 1, .with_padmix = 0, },
+	{ .att = 2, .with_padmix = 0, },
+	{ .att = 3, .with_padmix = 0, },
+	{ .att = 4, .with_padmix = 0, },
+	{ .att = 5, .with_padmix = 0, },
+	{ .att = 6, .with_padmix = 0, },
+	{ .att = 7, .with_padmix = 0, },
+	{ .att = 8, .with_padmix = 0, },
+	{ .att = 9, .with_padmix = 0, },
+	{ .att = 10, .with_padmix = 0, },
+	{ .att = 11, .with_padmix = 0, },
+	{ .att = 12, .with_padmix = 0, },
+	{ .att = 13, .with_padmix = 0, },
+	{ .att = 14, .with_padmix = 0, },
+	{ .att = 15, .with_padmix = 0, },
+	{ .att = 0, .with_padmix = 1, },
+	{ .att = 1, .with_padmix = 1, },
+	{ .att = 2, .with_padmix = 1, },
+	{ .att = 3, .with_padmix = 1, },
+	{ .att = 4, .with_padmix = 1, },
+	{ .att = 5, .with_padmix = 1, },
+	{ .att = 6, .with_padmix = 1, },
+	{ .att = 7, .with_padmix = 1, },
+	{ .att = 8, .with_padmix = 1, },
+	{ .att = 9, .with_padmix = 1, },
+	{ .att = 10, .with_padmix = 1, },
+	{ .att = 11, .with_padmix = 1, },
+	{ .att = 12, .with_padmix = 1, },
+	{ .att = 13, .with_padmix = 1, },
+	{ .att = 14, .with_padmix = 1, },
+	{ .att = 15, .with_padmix = 1, },
+};
+static const struct b43_rfatt_list b43_full_rfatt_list = {
+	.list		= b43_full_rfatt_list_items,
+	.len		= ARRAY_SIZE(b43_full_rfatt_list_items),
+};
+
+static const struct b43_bbatt b43_full_bbatt_list_items[] = {
+	{ .att = 0, },
+	{ .att = 1, },
+	{ .att = 2, },
+	{ .att = 3, },
+	{ .att = 4, },
+	{ .att = 5, },
+	{ .att = 6, },
+	{ .att = 7, },
+	{ .att = 8, },
+	{ .att = 9, },
+	{ .att = 10, },
+	{ .att = 11, },
+};
+static const struct b43_bbatt_list b43_full_bbatt_list = {
+	.list		= b43_full_bbatt_list_items,
+	.len		= ARRAY_SIZE(b43_full_bbatt_list_items),
+};
+#endif /* B43_CALIB_ALL_LOCTLS */
+
 static void lo_measure(struct b43_wldev *dev)
 {
 	struct b43_phy *phy = &dev->phy;
@@ -947,41 +1015,51 @@ static void lo_measure(struct b43_wldev 
 	struct b43_loctl *ploctl;
 	int max_rx_gain;
 	int rfidx, bbidx;
+	const struct b43_bbatt_list *bbatt_list;
+	const struct b43_rfatt_list *rfatt_list;
 
 	/* Values from the "TXCTL Register and Value Table" */
 	u16 txctl_reg;
 	u16 txctl_value;
 	u16 pad_mix_gain;
 
+	bbatt_list = &lo->bbatt_list;
+	rfatt_list = &lo->rfatt_list;
+#if B43_CALIB_ALL_LOCTLS
+	bbatt_list = &b43_full_bbatt_list;
+	rfatt_list = &b43_full_rfatt_list;
+#endif
+
 	txctl_reg = lo_txctl_register_table(dev, &txctl_value, &pad_mix_gain);
 
-	for (rfidx = 0; rfidx < lo->rfatt_list.len; rfidx++) {
+	for (rfidx = 0; rfidx < rfatt_list->len; rfidx++) {
 
 		b43_radio_write16(dev, 0x43, (b43_radio_read16(dev, 0x43)
-					      & 0xFFF0) | lo->rfatt_list.
-				  list[rfidx].att);
+					      & 0xFFF0) |
+				  rfatt_list->list[rfidx].att);
 		b43_radio_write16(dev, txctl_reg,
 				  (b43_radio_read16(dev, txctl_reg)
 				   & ~txctl_value)
-				  | (lo->rfatt_list.list[rfidx].
-				     with_padmix ? txctl_value : 0));
+				  | (rfatt_list->list[rfidx].with_padmix ?
+				     txctl_value : 0));
 
-		for (bbidx = 0; bbidx < lo->bbatt_list.len; bbidx++) {
+		for (bbidx = 0; bbidx < bbatt_list->len; bbidx++) {
 			if (lo->rebuild) {
+#if B43_CALIB_ALL_LOCTLS
+				ploctl = b43_get_lo_g_ctl(dev,
+							  &rfatt_list->list[rfidx],
+							  &bbatt_list->list[bbidx]);
+#else
 				ploctl = b43_get_lo_g_ctl_nopadmix(dev,
-								   &lo->
-								   rfatt_list.
+								   &rfatt_list->
 								   list[rfidx],
-								   &lo->
-								   bbatt_list.
+								   &bbatt_list->
 								   list[bbidx]);
+#endif
 			} else {
-				ploctl =
-				    b43_get_lo_g_ctl(dev,
-						     &lo->rfatt_list.
-						     list[rfidx],
-						     &lo->bbatt_list.
-						     list[bbidx]);
+				ploctl = b43_get_lo_g_ctl(dev,
+							  &rfatt_list->list[rfidx],
+							  &bbatt_list->list[bbidx]);
 				if (!ploctl->used)
 					continue;
 			}
@@ -989,9 +1067,9 @@ static void lo_measure(struct b43_wldev 
 			loctl.i = 0;
 			loctl.q = 0;
 
-			max_rx_gain = lo->rfatt_list.list[rfidx].att * 2;
-			max_rx_gain += lo->bbatt_list.list[bbidx].att / 2;
-			if (lo->rfatt_list.list[rfidx].with_padmix)
+			max_rx_gain = rfatt_list->list[rfidx].att * 2;
+			max_rx_gain += bbatt_list->list[bbidx].att / 2;
+			if (rfatt_list->list[rfidx].with_padmix)
 				max_rx_gain -= pad_mix_gain;
 			if (has_loopback_gain(phy))
 				max_rx_gain += phy->max_lb_gain;
@@ -999,8 +1077,7 @@ static void lo_measure(struct b43_wldev 
 					       has_loopback_gain(phy));
 
 			b43_phy_set_baseband_attenuation(dev,
-							 lo->bbatt_list.
-							 list[bbidx].att);
+							 bbatt_list->list[bbidx].att);
 			lo_probe_loctls_statemachine(dev, &loctl, &max_rx_gain);
 			if (phy->type == B43_PHYTYPE_B) {
 				loctl.i++;


From mb at bu3sch.de  Sat Aug 25 02:00:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 25 Aug 2007 02:00:51 +0200
Subject: b43: Copy MAC address to local struct
Message-ID: <200708250200.52650.mb@bu3sch.de>

We must copy the MAC addresses to a local struct, as we
don't own the original pointer from mac80211 and don't
know how mac80211 might mess with it while we are using it.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>

Index: wireless-dev-new/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-dev-new.orig/drivers/net/wireless/b43/b43.h	2007-08-25 01:55:33.000000000 +0200
+++ wireless-dev-new/drivers/net/wireless/b43/b43.h	2007-08-25 01:57:30.000000000 +0200
@@ -600,10 +600,10 @@ struct b43_wl {
 	 * Do not modify.
 	 */
 	int if_id;
-	/* MAC address (can be NULL). */
-	const u8 *mac_addr;
-	/* Current BSSID (can be NULL). */
-	const u8 *bssid;
+	/* The MAC address of the operating interface. */
+	u8 mac_addr[ETH_ALEN];
+	/* Current BSSID */
+	u8 bssid[ETH_ALEN];
 	/* Interface type. (IEEE80211_IF_TYPE_XXX) */
 	int if_type;
 	/* Counter of active monitor interfaces. */
Index: wireless-dev-new/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev-new.orig/drivers/net/wireless/b43/main.c	2007-08-25 01:56:13.000000000 +0200
+++ wireless-dev-new/drivers/net/wireless/b43/main.c	2007-08-25 01:57:30.000000000 +0200
@@ -537,7 +537,6 @@ void b43_macfilter_set(struct b43_wldev 
 
 static void b43_write_mac_bssid_templates(struct b43_wldev *dev)
 {
-	static const u8 zero_addr[ETH_ALEN] = { 0 };
 	const u8 *mac;
 	const u8 *bssid;
 	u8 mac_bssid[ETH_ALEN * 2];
@@ -545,11 +544,7 @@ static void b43_write_mac_bssid_template
 	u32 tmp;
 
 	bssid = dev->wl->bssid;
-	if (!bssid)
-		bssid = zero_addr;
 	mac = dev->wl->mac_addr;
-	if (!mac)
-		mac = zero_addr;
 
 	b43_macfilter_set(dev, B43_MACFILTER_BSSID, bssid);
 
@@ -569,7 +564,10 @@ static void b43_write_mac_bssid_template
 static void b43_upload_card_macaddress(struct b43_wldev *dev,
 				       const u8 * mac_addr)
 {
-	dev->wl->mac_addr = mac_addr;
+	if (mac_addr)
+		memcpy(dev->wl->mac_addr, mac_addr, ETH_ALEN);
+	else
+		memset(dev->wl->mac_addr, 0, ETH_ALEN);
 	b43_write_mac_bssid_templates(dev);
 	b43_macfilter_set(dev, B43_MACFILTER_SELF, mac_addr);
 }
@@ -3026,7 +3024,10 @@ static int b43_config_interface(struct i
 	spin_lock_irqsave(&wl->irq_lock, flags);
 	if (conf->type != IEEE80211_IF_TYPE_MNTR) {
 		B43_WARN_ON(wl->if_id != if_id);
-		wl->bssid = conf->bssid;
+		if (conf->bssid)
+			memcpy(wl->bssid, conf->bssid, ETH_ALEN);
+		else
+			memset(wl->bssid, 0, ETH_ALEN);
 		if (b43_status(dev) >= B43_STAT_INITIALIZED) {
 			if (b43_is_mode(wl, IEEE80211_IF_TYPE_AP)) {
 				B43_WARN_ON(conf->type != IEEE80211_IF_TYPE_AP);
@@ -3454,7 +3455,7 @@ static int b43_wireless_core_init(struct
 	b43_bluetooth_coext_enable(dev);
 
 	ssb_bus_powerup(bus, 1);	/* Enable dynamic PCTL */
-	wl->bssid = NULL;
+	memset(wl->bssid, 0, ETH_ALEN);
 	b43_upload_card_macaddress(dev, NULL);
 	b43_security_init(dev);
 	b43_rng_init(wl);


From mb at bu3sch.de  Sat Aug 25 02:03:29 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 25 Aug 2007 02:03:29 +0200
Subject: b43: Copy MAC address to local struct
In-Reply-To: <200708250200.52650.mb@bu3sch.de>
References: <200708250200.52650.mb@bu3sch.de>
Message-ID: <200708250203.30464.mb@bu3sch.de>

On Saturday 25 August 2007, Michael Buesch wrote:
> We must copy the MAC addresses to a local struct, as we
> don't own the original pointer from mac80211 and don't
> know how mac80211 might mess with it while we are using it.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>
> Cc: Larry Finger <larry.finger at lwfinger.net>

Whoops, seems I already sent this one yesterday. Sorry.



From johannes at sipsolutions.net  Sat Aug 25 09:58:22 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Sat, 25 Aug 2007 09:58:22 +0200
Subject: [PATCH] b43: include FCS at end of frames
In-Reply-To: <200708241512.44463.hs4233@mail.mn-solutions.de>
References: <1187953310.24933.19.camel@johannes.berg>
	<200708241512.44463.hs4233@mail.mn-solutions.de>
Message-ID: <1188028702.9529.9.camel@johannes.berg>

On Fri, 2007-08-24 at 15:12 +0200, Holger Schurig wrote:

> You must have a very different tree to wireless-dev, branch everything.
> According to git blame, since 2007-08-13 the piece of code there looks
> like this:

After my patches, yeah. I screwed up, shouldn't have posted this yet.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070825/952f8a01/attachment.pgp>

From johannes at sipsolutions.net  Sat Aug 25 10:05:59 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Sat, 25 Aug 2007 10:05:59 +0200
Subject: minor grips with b43
In-Reply-To: <200708241616.56746.hs4233@mail.mn-solutions.de>
References: <200708241616.56746.hs4233@mail.mn-solutions.de>
Message-ID: <1188029159.9529.17.camel@johannes.berg>

On Fri, 2007-08-24 at 16:16 +0200, Holger Schurig wrote:

> When I power-up my device, I only see that ssb has been loaded. 
> Not "b43.ko" as well. Is this expected?

Yes, you also need to transplant the ssb changes to scripts/file2alias.c

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070825/21cc066d/attachment.pgp>

From guillermo at geryon.com.ar  Sun Aug 26 23:12:46 2007
From: guillermo at geryon.com.ar (Guillermo Javier Nardoni)
Date: Sun, 26 Aug 2007 18:12:46 -0300
Subject: BCM4306 totally exausted
Message-ID: <20070826182330.C1DD818E805@mail.geryon.com.ar>

Hi everyone, this is my first time here so i'll give a brief introducing..
My name is Guillermo and i'm from Argentina, i am in a wireless team group
building wifi comunnities but... A few days ago we bought 
2 linksys wrt54gl v1.1 s/N: CL7B... Wich means it is a broadcom chipset
based.-
Well, we want to put openwrt with 2.6 kernel but it is doesn't have wireless
support yet due to Broadcom.
So, i have searched and readed and watch some tv show too but it is still
doesn't work.
Does anybody tried to compile the driver with linux 2.6 vanilla kernel and
work properlly?
De wrt54gl chipset revision is 02

Where can i find some addiotional information?

Thanks a lot.-


 
 
Atte.- 
Guillermo Javier Nardoni 
Grupo GERYON 
Montevideo 890 - Rosario 
Tel: 0341-156533929 
MSN: javier211981 at hotmail.com 
MAIL: guillermo at geryon.com.ar / gjnardoni at yahoo.com.ar 



From comphappy at gmail.com  Mon Aug 27 01:02:03 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sun, 26 Aug 2007 16:02:03 -0700
Subject: BCM4306 totally exausted
In-Reply-To: <20070826182330.C1DD818E805@mail.geryon.com.ar>
References: <20070826182330.C1DD818E805@mail.geryon.com.ar>
Message-ID: <b2d05de20708261602q6b20b2aeqf4b0bb7174f9f928@mail.gmail.com>

On 8/26/07, Guillermo Javier Nardoni <guillermo at geryon.com.ar> wrote:
> Hi everyone, this is my first time here so i'll give a brief introducing..
> My name is Guillermo and i'm from Argentina, i am in a wireless team group
> building wifi comunnities but... A few days ago we bought
> 2 linksys wrt54gl v1.1 s/N: CL7B... Wich means it is a broadcom chipset
> based.-
> Well, we want to put openwrt with 2.6 kernel but it is doesn't have wireless
> support yet due to Broadcom.
> So, i have searched and readed and watch some tv show too but it is still
> doesn't work.
> Does anybody tried to compile the driver with linux 2.6 vanilla kernel and
> work properlly?
> De wrt54gl chipset revision is 02

Could you post the result of

uname -r
ispci | grep Broadcom
dmesg | grep bcm

have you used fwcutter yet, if so what version

I believe for that revision you have to use b43-legacy or bcm43xx
depending on your kernel version, however i have been out of town
during most of the naming changes and am just catching up.

-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From larry.finger at lwfinger.net  Mon Aug 27 02:43:50 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 26 Aug 2007 19:43:50 -0500
Subject: BCM4306 totally exausted
In-Reply-To: <b2d05de20708261602q6b20b2aeqf4b0bb7174f9f928@mail.gmail.com>
References: <20070826182330.C1DD818E805@mail.geryon.com.ar>
	<b2d05de20708261602q6b20b2aeqf4b0bb7174f9f928@mail.gmail.com>
Message-ID: <46D21E46.1080003@lwfinger.net>

Brennan Ashton wrote:
> On 8/26/07, Guillermo Javier Nardoni <guillermo at geryon.com.ar> wrote:
>> Hi everyone, this is my first time here so i'll give a brief introducing..
>> My name is Guillermo and i'm from Argentina, i am in a wireless team group
>> building wifi comunnities but... A few days ago we bought
>> 2 linksys wrt54gl v1.1 s/N: CL7B... Wich means it is a broadcom chipset
>> based.-
>> Well, we want to put openwrt with 2.6 kernel but it is doesn't have wireless
>> support yet due to Broadcom.
>> So, i have searched and readed and watch some tv show too but it is still
>> doesn't work.
>> Does anybody tried to compile the driver with linux 2.6 vanilla kernel and
>> work properlly?
>> De wrt54gl chipset revision is 02
> 
> Could you post the result of
> 
> uname -r
> ispci | grep Broadcom
> dmesg | grep bcm
> 
> have you used fwcutter yet, if so what version
> 
> I believe for that revision you have to use b43-legacy or bcm43xx
> depending on your kernel version, however i have been out of town
> during most of the naming changes and am just catching up.

The WRT54GL is a wireless router, not a wireless card. Broadcom provides a binary-only driver for 
Linux 2.4, but not for 2.6.

I'm sure that using driver b43 with mac80211 from the wireless-dev tree will provide the software 
that you need. The critical thing is the revision of the 802.11 core. You use b43 for rev >= 5, 
b43legacy for rev < 5. I don't know how well it will work as an AP. On the WRT54G, the BCM4306 may 
not connected to the host via a PCI bus as it is in PC's. The b43 and ssb drivers have all the 
necessary glue code. By the way, b43legacy must have a PCI bus as the glue code was removed, but it 
could be added back if needed.

Larry


From s0238762 at sms.ed.ac.uk  Mon Aug 27 13:38:43 2007
From: s0238762 at sms.ed.ac.uk (Ioannis Nousias)
Date: Mon, 27 Aug 2007 12:38:43 +0100
Subject: Updated Status on b43 driver and Fedora 7
In-Reply-To: <46CF60A4.7070705@lwfinger.net>
References: <313c6e90708241536q6c22d23bnf892e3e6a5dbcb97@mail.gmail.com>
	<46CF60A4.7070705@lwfinger.net>
Message-ID: <46D2B7C3.9040206@sms.ed.ac.uk>

Larry Finger wrote:
> Andrig T. Miller wrote:
>   
>> I booted a new Fedora kernel this morning, and it loaded the new b43 
>> driver, and I still had the v4 firmware in /lib/firmware.  The first 
>> time I connected it connected at 2 Mb/s, versus the 1 Mb/s that it used 
>> to connect at.  I had needed to reboot a second time for an unrelated 
>> reason, and when it connected the next time I connected at 5 Mb/s, and I 
>> have been happily using my internal Broadcom 4318 wireless networking 
>> all day, without issue.
>>
>> Thanks for all the hard work, it is really paying off!
>>     
>
> It is connecting at 1 Mbs every time, the increases are the natural ramp-up of the rates. Why it 
> differed from boot to boot is probably a matter of when you happened to check and how many 
> transmissions happened before you looked.
>
> If your V4 firmware is still in /lib/firmware, then the Fedora kernel is a little behind the 
> wireless-dev tree. Once the code that uses the new naming scheme hits their kernel, your wireless 
> will probably stop working. Be prepared.
>
> Yes, the new driver is very solid.
>
> Larry
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
>
>   
It's not that 'solid' on my chipset, at least not the one present in the 
Fedora kernel. I have a BCM4309 14e4:4324 (rev 02) chipset and it drops 
connection from time to time with this driver.

It connects fine at 1Mbps, really quick link establishment, but maybe 
half an hour later it drops and reconnects again. There are lots of 
messages in the kernel log, I'm including here what I think is useful:

this is what I get when it first initialises:

b43-phy1: Broadcom 4306 WLAN found
b43-phy1 debug: Found PHY: Analog 1, Type 2, Revision 1
b43-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
b43-phy1 debug: Radio turned off
wmaster0: Selected rate control algorithm 'simple'
b43-phy1 debug: Ignoring unconnected 802.11 core
b43-phy1 debug: Adding Interface type 2
b43-phy1 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy1 debug: Radio turned on
b43-phy1 debug: Radio enabled by hardware
b43-phy1 ERROR: bbatt(11) >= size of LO array
b43-phy1 debug: Chip initialized
b43-phy1 debug: 30-bit DMA initialized
b43-wlan: TODO: Incomplete code in keymac_write() at 
drivers/net/wireless/b43/main
.c:753 *<---- repeated several times*
b43-phy1 debug: Wireless interface started
ADDRCONF(NETDEV_UP): wlan0: link is not ready
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:30:bd:fe:23:83
wlan0: RX authentication from 00:30:bd:fe:23:83 (alg=0 transaction=2 
status=0)
wlan0: authenticated
wlan0: associate with AP 00:30:bd:fe:23:83
wlan0: RX AssocResp from 00:30:bd:fe:23:83 (capab=0x411 status=0 aid=10)
wlan0: associated
wlan0: switched to short barker preamble (BSSID=00:30:bd:fe:23:83)
ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready

when it drops connection I get the following messages in dmesg:

wlan0: No ProbeResp from current AP 00:30:bd:fe:23:83 - assume out of range
b43-phy1 debug: Using software based encryption for keyidx: 0, mac: 
00:30:bd:fe:23
:83
wlan0: No STA entry for own AP 00:30:bd:fe:23:83
wlan0: No STA entry for own AP 00:30:bd:fe:23:83
wlan0: No STA entry for own AP 00:30:bd:fe:23:83
ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
b43-phy1 debug: Removing Interface type 2
b43-phy1 ERROR: MAC suspend failed
b43-phy1 debug: Wireless interface stopped
b43-phy1 debug: DMA-32 0x0260 (RX) max used slots: 1/64
b43-phy1 debug: DMA-32 0x0200 (RX) max used slots: 2/64
b43-phy1 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
b43-phy1 debug: DMA-32 0x0280 (TX) max used slots: 0/128
b43-phy1 debug: DMA-32 0x0260 (TX) max used slots: 0/128
b43-phy1 debug: DMA-32 0x0240 (TX) max used slots: 0/128
b43-phy1 debug: DMA-32 0x0220 (TX) max used slots: 92/128
b43-phy1 debug: DMA-32 0x0200 (TX) max used slots: 0/128
b43-phy1 debug: Radio turned off
b43-phy1 debug: Radio turned off
b43-phy1 debug: Adding Interface type 2

this is the link quality info:
Bit Rate=1 Mb/s
Retry min limit:7 RTS thr:off Fragment thr=2346 B
Link Quality=73/100 Signal level=-56 dBm Noise level=-41 dBm
Rx invalid nwid:0 Rx invalid crypt:0 Rx invalid frag:0
Tx excessive retries:0 Invalid misc:0 Missed beacon:0

is the SNR low? Is that why it drops the connection ? The router sits 3 
meters away from my laptop, direct sight.


thanks
-Ioannis





From linville at tuxdriver.com  Mon Aug 27 16:01:49 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Mon, 27 Aug 2007 10:01:49 -0400
Subject: Updated Status on b43 driver and Fedora 7
In-Reply-To: <46CF60A4.7070705@lwfinger.net>
References: <313c6e90708241536q6c22d23bnf892e3e6a5dbcb97@mail.gmail.com>
	<46CF60A4.7070705@lwfinger.net>
Message-ID: <20070827140149.GA9078@tuxdriver.com>

On Fri, Aug 24, 2007 at 05:50:12PM -0500, Larry Finger wrote:

> If your V4 firmware is still in /lib/firmware, then the Fedora kernel is a little behind the 
> wireless-dev tree. Once the code that uses the new naming scheme hits their kernel, your wireless 
> will probably stop working. Be prepared.

FWIW, this isn't quite true -- at least not in F7.  It is true in
rawhide, and I'm a bit surprised that no one has complained yet... :-)

In F7 I am carrying a patch to reverse the change to the new firmware
format.  I want to keep F7 near wireless-dev's head, but I didn't
want to break a bunch of existing configurations.  I haven't quite
figured-out how long I'm going to carry this in F7.  It will not be
in F8.

Just curious, what was the motivation for the new firmware format?
Can the new format be quickly described in high level terms?
I'm wondering if a tool could easily convert the old firmware format
to the new, so that we might add it as an upgrade tool for F8.

Thanks,

John
-- 
John W. Linville
linville at tuxdriver.com


From johannes at sipsolutions.net  Mon Aug 27 17:00:18 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 27 Aug 2007 17:00:18 +0200
Subject: Updated Status on b43 driver and Fedora 7
In-Reply-To: <20070827140149.GA9078@tuxdriver.com>
References: <313c6e90708241536q6c22d23bnf892e3e6a5dbcb97@mail.gmail.com>
	<46CF60A4.7070705@lwfinger.net> <20070827140149.GA9078@tuxdriver.com>
Message-ID: <1188226818.7837.47.camel@johannes.berg>

On Mon, 2007-08-27 at 10:01 -0400, John W. Linville wrote:

> Just curious, what was the motivation for the new firmware format?
> Can the new format be quickly described in high level terms?

There's no fundamental difference between the two formats, the naming is
most of the difference and the new initvals format is merely a
compression of the original format. The new format has a file header
that allows distinguishing versions if we should ever need to upgrade
the format again.

The main motivation for the rename and the incompatible change was
two-fold:
 1) nobody but Martin understood the old naming scheme and it was mostly
    coincidence that the right values were loaded, no way to easily
    bring this over for 802.11 N cards etc. The new naming is closer to
    what Broadcom uses internally allowing easier exchange between us
    (reverse engineering team) and the driver team.
 2) far too many different firmware were supported by the fwcutter which
    lead to weird quirks everywhere because Broadcom sometimes slightly
    changed the driver/firmware interface without us knowing until bugs
    happened, we now only support validated firmware images

> I'm wondering if a tool could easily convert the old firmware format
> to the new, so that we might add it as an upgrade tool for F8.

It is certainly not impossible, you can easily map the old to the new
names and write a script that renames them, adds the header and
compresses the initial values. However, since the old firmware cutter
supported many more firmware images, the converter will need to verify
that the image it finds is one of the (currently two) supported images
and abort otherwise.

Michael has also stated that he is unwilling to support anybody who used
such a tool because the tool could possibly lead to slightly changed
firmware images, I guess he may be convinced otherwise if you can
demonstrate that the converter will only convert files were extracted
from the same file as we now support and generates binary-identical
output to the new fwcutter.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070827/8649545e/attachment.pgp>

From john.j35 at gmail.com  Mon Aug 27 17:45:08 2007
From: john.j35 at gmail.com (John Pierce)
Date: Mon, 27 Aug 2007 10:45:08 -0500
Subject: Which module
Message-ID: <aa73b9a0708270845m649abb18i7d1f37b4888588d3@mail.gmail.com>

Ok, I have been trying to make heads or tails of it, which driver do I
need to use for the broadcom 4311 dell wlan 1390.

Is it b43 or bcm43xx?  I have just upgraded a fedora 7 installation to
2.6.22.4-65 and want to give the native driver a try again.

Thanks in advance for any assistance.
-- 
John
Registered Linux User 263680, get counted at
http://counter.li.org


From larry.finger at lwfinger.net  Mon Aug 27 17:56:47 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 27 Aug 2007 10:56:47 -0500
Subject: Which module
In-Reply-To: <aa73b9a0708270845m649abb18i7d1f37b4888588d3@mail.gmail.com>
References: <aa73b9a0708270845m649abb18i7d1f37b4888588d3@mail.gmail.com>
Message-ID: <46D2F43F.9010502@lwfinger.net>

John Pierce wrote:
> Ok, I have been trying to make heads or tails of it, which driver do I
> need to use for the broadcom 4311 dell wlan 1390.
> 
> Is it b43 or bcm43xx?  I have just upgraded a fedora 7 installation to
> 2.6.22.4-65 and want to give the native driver a try again.

You may use either one. The driver supported by mainstream kernels is bcm43xx, which uses SoftMAC as 
its MAC layer. The driver named b43, which uses mac80211 as its MAC layer, will be replacing bcm43xx 
in mainstream in the coming months. If that F7 kernel offers b43 as an option, use it. The 
performance of the two drivers is essentially the same; however, the stability and flexibility of 
mac80211 is a great improvement over SoftMAC.

For completeness, there is yet another driver for the BCM43xx chips that is named b43legacy. It is 
used for any 802.11b cards/chips and for one older variant of the BCM4306 802.11g chip. If you 
happen to see a reference to bcm43xx-mac80211, that is the old name for b43.

Larry


From larry.finger at lwfinger.net  Mon Aug 27 18:16:18 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 27 Aug 2007 11:16:18 -0500
Subject: Updated Status on b43 driver and Fedora 7
In-Reply-To: <46D2B7C3.9040206@sms.ed.ac.uk>
References: <313c6e90708241536q6c22d23bnf892e3e6a5dbcb97@mail.gmail.com>
	<46CF60A4.7070705@lwfinger.net> <46D2B7C3.9040206@sms.ed.ac.uk>
Message-ID: <46D2F8D2.4080405@lwfinger.net>

Ioannis Nousias wrote:
> Larry Finger wrote:
>> Andrig T. Miller wrote:
>>  
>>> I booted a new Fedora kernel this morning, and it loaded the new b43 
>>> driver, and I still had the v4 firmware in /lib/firmware.  The first 
>>> time I connected it connected at 2 Mb/s, versus the 1 Mb/s that it 
>>> used to connect at.  I had needed to reboot a second time for an 
>>> unrelated reason, and when it connected the next time I connected at 
>>> 5 Mb/s, and I have been happily using my internal Broadcom 4318 
>>> wireless networking all day, without issue.
>>>
>>> Thanks for all the hard work, it is really paying off!
>>>     
>>
>> It is connecting at 1 Mbs every time, the increases are the natural 
>> ramp-up of the rates. Why it differed from boot to boot is probably a 
>> matter of when you happened to check and how many transmissions 
>> happened before you looked.
>>
>> If your V4 firmware is still in /lib/firmware, then the Fedora kernel 
>> is a little behind the wireless-dev tree. Once the code that uses the 
>> new naming scheme hits their kernel, your wireless will probably stop 
>> working. Be prepared.
>>
>> Yes, the new driver is very solid.
>>
>> Larry
>> _______________________________________________
>> Bcm43xx-dev mailing list
>> Bcm43xx-dev at lists.berlios.de
>> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>>
>>
>>   
> It's not that 'solid' on my chipset, at least not the one present in the 
> Fedora kernel. I have a BCM4309 14e4:4324 (rev 02) chipset and it drops 
> connection from time to time with this driver.
> 
> It connects fine at 1Mbps, really quick link establishment, but maybe 
> half an hour later it drops and reconnects again. There are lots of 
> messages in the kernel log, I'm including here what I think is useful:
> 
> this is what I get when it first initialises:
> 
> b43-phy1: Broadcom 4306 WLAN found
> b43-phy1 debug: Found PHY: Analog 1, Type 2, Revision 1
> b43-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> b43-phy1 debug: Radio turned off
> wmaster0: Selected rate control algorithm 'simple'
> b43-phy1 debug: Ignoring unconnected 802.11 core
> b43-phy1 debug: Adding Interface type 2
> b43-phy1 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy1 debug: Radio turned on
> b43-phy1 debug: Radio enabled by hardware
> b43-phy1 ERROR: bbatt(11) >= size of LO array
> b43-phy1 debug: Chip initialized
> b43-phy1 debug: 30-bit DMA initialized
> b43-wlan: TODO: Incomplete code in keymac_write() at 
> drivers/net/wireless/b43/main
> .c:753 *<---- repeated several times*
> b43-phy1 debug: Wireless interface started
> ADDRCONF(NETDEV_UP): wlan0: link is not ready
> wlan0: Initial auth_alg=0
> wlan0: authenticate with AP 00:30:bd:fe:23:83
> wlan0: RX authentication from 00:30:bd:fe:23:83 (alg=0 transaction=2 
> status=0)
> wlan0: authenticated
> wlan0: associate with AP 00:30:bd:fe:23:83
> wlan0: RX AssocResp from 00:30:bd:fe:23:83 (capab=0x411 status=0 aid=10)
> wlan0: associated
> wlan0: switched to short barker preamble (BSSID=00:30:bd:fe:23:83)
> ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
> 
> when it drops connection I get the following messages in dmesg:
> 
> wlan0: No ProbeResp from current AP 00:30:bd:fe:23:83 - assume out of range
> b43-phy1 debug: Using software based encryption for keyidx: 0, mac: 
> 00:30:bd:fe:23
> :83
> wlan0: No STA entry for own AP 00:30:bd:fe:23:83
> wlan0: No STA entry for own AP 00:30:bd:fe:23:83
> wlan0: No STA entry for own AP 00:30:bd:fe:23:83
> ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
> b43-phy1 debug: Removing Interface type 2
> b43-phy1 ERROR: MAC suspend failed
> b43-phy1 debug: Wireless interface stopped
> b43-phy1 debug: DMA-32 0x0260 (RX) max used slots: 1/64
> b43-phy1 debug: DMA-32 0x0200 (RX) max used slots: 2/64
> b43-phy1 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
> b43-phy1 debug: DMA-32 0x0280 (TX) max used slots: 0/128
> b43-phy1 debug: DMA-32 0x0260 (TX) max used slots: 0/128
> b43-phy1 debug: DMA-32 0x0240 (TX) max used slots: 0/128
> b43-phy1 debug: DMA-32 0x0220 (TX) max used slots: 92/128
> b43-phy1 debug: DMA-32 0x0200 (TX) max used slots: 0/128
> b43-phy1 debug: Radio turned off
> b43-phy1 debug: Radio turned off
> b43-phy1 debug: Adding Interface type 2
> 
> this is the link quality info:
> Bit Rate=1 Mb/s
> Retry min limit:7 RTS thr:off Fragment thr=2346 B
> Link Quality=73/100 Signal level=-56 dBm Noise level=-41 dBm
> Rx invalid nwid:0 Rx invalid crypt:0 Rx invalid frag:0
> Tx excessive retries:0 Invalid misc:0 Missed beacon:0
> 
> is the SNR low? Is that why it drops the connection ? The router sits 3 
> meters away from my laptop, direct sight.

I'm a little surprised that that device works with b43. From the revisions that are in your mail, I 
would have expected it to use b43legacy. Please send the extract from the dmesg output that looks like

ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x11, vendor 0x4243)
ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0A, vendor 0x4243)
ssb: Core 2 found: USB 1.1 Host (cc 0x817, rev 0x03, vendor 0x4243)
ssb: Core 3 found: PCI-E (cc 0x820, rev 0x01, vendor 0x4243)

Your noise level is very high and the signal is low. At two meters from the AP, i get Signal 
level=-45 dBm  Noise level=-70 dBm.

The code for the Rev 1 PHY's has the most problems of all the chips. They require more setup by the 
host than do later revisions, and obviously something is wrong. I'm working with my BCM4306/2 to see 
what can be done.

Larry


From mb at bu3sch.de  Mon Aug 27 19:08:20 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 27 Aug 2007 19:08:20 +0200
Subject: Updated Status on b43 driver and Fedora 7
In-Reply-To: <1188226818.7837.47.camel@johannes.berg>
References: <313c6e90708241536q6c22d23bnf892e3e6a5dbcb97@mail.gmail.com>
	<20070827140149.GA9078@tuxdriver.com>
	<1188226818.7837.47.camel@johannes.berg>
Message-ID: <200708271908.20715.mb@bu3sch.de>

On Monday 27 August 2007 17:00:18 Johannes Berg wrote:
> It is certainly not impossible, you can easily map the old to the new
> names and write a script that renames them, adds the header and

In theory.
In practice not. How do you reliably map the random initvalsXX naming to
the new one?
I don't even know what initvals05 (for random example) is. Do you?

Why not simply start from a safe and clean point.
Auto-download the new firmware from your pre-install scripts and be
done with it. Network connectivity was always required for installing
the broadcom driver. Why should this change now?

-- 
Greetings Michael.


From dwmw2 at infradead.org  Mon Aug 27 20:23:01 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Mon, 27 Aug 2007 19:23:01 +0100
Subject: Which module
In-Reply-To: <46D2F43F.9010502@lwfinger.net>
References: <aa73b9a0708270845m649abb18i7d1f37b4888588d3@mail.gmail.com>
	<46D2F43F.9010502@lwfinger.net>
Message-ID: <1188238981.11679.178.camel@pmac.infradead.org>

On Mon, 2007-08-27 at 10:56 -0500, Larry Finger wrote:
> You may use either one. The driver supported by mainstream kernels is bcm43xx, which uses SoftMAC as 
> its MAC layer. The driver named b43, which uses mac80211 as its MAC layer, will be replacing bcm43xx 
> in mainstream in the coming months. If that F7 kernel offers b43 as an option, use it. The 
> performance of the two drivers is essentially the same; however, the stability and flexibility of 
> mac80211 is a great improvement over SoftMAC.

The F7 kernel should currently use bcm43xx-mac80211 by default.

If you fetch http://david.woodhou.se/bcm43xx-override and put it
in /etc/modprobe.d then you'll use the softmac bcm43xx driver instead.
That might be worth a try if you have problems with the mac80211
version.

Note that each of those require firmware extracted from different
versions of the 'official' drivers.

-- 
dwmw2



From ddevore at duckhouse.us  Mon Aug 27 22:39:31 2007
From: ddevore at duckhouse.us (Dru Devore)
Date: Mon, 27 Aug 2007 13:39:31 -0700
Subject: Problem with Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI
	Card rev 02
Message-ID: <20070827133931.d93209e2c756a6ecfa0dc94b7784bf13.1334d39c97.wbe@email.secureserver.net>

An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070827/aef5c395/attachment.html>

From larry.finger at lwfinger.net  Mon Aug 27 23:24:54 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 27 Aug 2007 16:24:54 -0500
Subject: Problem with Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI
	Card rev 02
In-Reply-To: <20070827133931.d93209e2c756a6ecfa0dc94b7784bf13.1334d39c97.wbe@email.secureserver.net>
References: <20070827133931.d93209e2c756a6ecfa0dc94b7784bf13.1334d39c97.wbe@email.secureserver.net>
Message-ID: <46D34126.8010808@lwfinger.net>

Dru Devore wrote:
> I wrote this group about this card, Broadcom Corporation Dell Wireless 
> 1390 WLAN Mini-PCI Card rev 02, a couple of weeks ago and got some 
> information from Larry, Thank you Larry.
> 
> I have been seeing a lot of messages lately about the b43 and was 
> wondering if it would possibly work with this chip. If not what can I do 
> to help the support for this card. Also, if anyone knows how to get this 
> card to work in any way without locking up the OS I would appreciate 
> that information also. I am currently using ndisswrapper and it is 
> freezing the whole OS. I need this to work so I can get back off 
> windows, vista, on this computer.

That chip is what I use with b43. It does not freeze the computer.

You need to get a mainstream kernel from kernel.org that is 2.6.21, or later. Those kernels use the 
bcm43xx driver. Alternatively, you can get the kernel from John Linville's wireless-dev git tree and 
build b43 for it. You will also need to install the supported firmware for your driver by 
downloading the appropriate version of wl_apstaXXX.o, installing fwcutter, and extracting the 
embedded codes. For bcm43xx, you will need V3 and use bcm43xx-fwcutter. For b43, you will need V4 
and b43-fwcutter. Don't blame us for the complications here. It is Broadcom's fault.

The archives of the mailing list and the bcm43xx site have a lot of explanation on how to do this. 
Alternatively, go to the forums of your distro.

Larry


From johannes at sipsolutions.net  Tue Aug 28 10:36:16 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 28 Aug 2007 10:36:16 +0200
Subject: Updated Status on b43 driver and Fedora 7
In-Reply-To: <200708271908.20715.mb@bu3sch.de>
References: <313c6e90708241536q6c22d23bnf892e3e6a5dbcb97@mail.gmail.com>
	<20070827140149.GA9078@tuxdriver.com>
	<1188226818.7837.47.camel@johannes.berg>
	<200708271908.20715.mb@bu3sch.de>
Message-ID: <1188290176.7837.51.camel@johannes.berg>

On Mon, 2007-08-27 at 19:08 +0200, Michael Buesch wrote:

> In theory.
> In practice not. How do you reliably map the random initvalsXX naming to
> the new one?
> I don't even know what initvals05 (for random example) is. Do you?

Not off the top of my head, but I have a patch floating around somewhere
that adds comments to bcm43xx with the new names so you should easily be
able to see the mapping.

> Why not simply start from a safe and clean point.
> Auto-download the new firmware from your pre-install scripts and be
> done with it. Network connectivity was always required for installing
> the broadcom driver. Why should this change now?

Dunno.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070828/e114a5ef/attachment.pgp>

From mb at bu3sch.de  Tue Aug 28 20:54:16 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 28 Aug 2007 20:54:16 +0200
Subject: [PATCH] b43: Fix cancelation of workqueues
Message-ID: <200708282054.16490.mb@bu3sch.de>

This correctly cancels all workqueues on shutdown.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger.lwfinger.net>

Index: wireless-dev-new/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev-new.orig/drivers/net/wireless/b43/main.c	2007-08-28 20:23:35.000000000 +0200
+++ wireless-dev-new/drivers/net/wireless/b43/main.c	2007-08-28 20:36:27.000000000 +0200
@@ -2474,11 +2474,6 @@ static void b43_periodic_work_handler(st
 	mutex_unlock(&dev->wl->mutex);
 }
 
-static void b43_periodic_tasks_delete(struct b43_wldev *dev)
-{
-	cancel_rearming_delayed_work(&dev->periodic_work);
-}
-
 static void b43_periodic_tasks_setup(struct b43_wldev *dev)
 {
 	struct delayed_work *work = &dev->periodic_work;
@@ -3055,9 +3050,9 @@ static void b43_wireless_core_stop(struc
 	b43_set_status(dev, B43_STAT_INITIALIZED);
 
 	mutex_unlock(&wl->mutex);
-	/* Must unlock as it would otherwise deadlock. No races here. */
-	b43_periodic_tasks_delete(dev);
-	flush_workqueue(dev->wl->hw->workqueue);
+	/* Must unlock as it would otherwise deadlock. No races here.
+	 * Cancel the possibly running self-rearming periodic work. */
+	cancel_delayed_work_sync(&dev->periodic_work);
 	mutex_lock(&wl->mutex);
 
 	ieee80211_stop_queues(wl->hw);	//FIXME this could cause a deadlock, as mac80211 seems buggy.
@@ -3322,13 +3317,22 @@ static void b43_imcfglo_timeouts_workaro
 }
 
 /* Shutdown a wireless core */
+/* Locking: wl->mutex */
 static void b43_wireless_core_exit(struct b43_wldev *dev)
 {
+	struct b43_wl *wl = dev->wl;
 	struct b43_phy *phy = &dev->phy;
 
 	B43_WARN_ON(b43_status(dev) > B43_STAT_INITIALIZED);
 	if (b43_status(dev) != B43_STAT_INITIALIZED)
 		return;
+	b43_set_status(dev, B43_STAT_UNINIT);
+
+	mutex_unlock(&wl->mutex);
+	/* Must unlock as it would otherwise deadlock. No races here.
+	 * Cancel possibly pending workqueues. */
+	cancel_work_sync(&dev->restart_work);
+	mutex_lock(&wl->mutex);
 
 	b43_rng_exit(dev->wl);
 	b43_pio_free(dev);
@@ -3342,7 +3346,6 @@ static void b43_wireless_core_exit(struc
 	phy->lo_control = NULL;
 	ssb_device_disable(dev->dev, 0);
 	ssb_bus_may_powerdown(dev->dev->bus);
-	b43_set_status(dev, B43_STAT_UNINIT);
 }
 
 /* Initialize a wireless core */
@@ -4001,6 +4004,9 @@ static void b43_remove(struct ssb_device
 /* Perform a hardware reset. This can be called from any context. */
 void b43_controller_restart(struct b43_wldev *dev, const char *reason)
 {
+	/* Must avoid requeueing, if we are in shutdown. */
+	if (b43_status(dev) < B43_STAT_INITIALIZED)
+		return;
 	b43info(dev->wl, "Controller RESET (%s) ...\n", reason);
 	queue_work(dev->wl->hw->workqueue, &dev->restart_work);
 }


From benoni29 at gmail.com  Tue Aug 28 23:16:22 2007
From: benoni29 at gmail.com (=?ISO-8859-1?Q?Beno=EEt_Liessens?=)
Date: Tue, 28 Aug 2007 23:16:22 +0200
Subject: new device
Message-ID: <378ca2f70708281416l41553585vd97f95daf5c5ffff@mail.gmail.com>

Hello,


It seems my Linksys 802.11g PCI device is not listed on the website.

Output of lspci -vn:
02:08.0 0280: 14e4:4320 (rev 03)
        Subsystem: 1737:0013
        Flags: bus master, fast devsel, latency 64, IRQ 20
        Memory at fcfde000 (32-bit, non-prefetchable) [size=8K]


Output of lspci -vv:
02:08.0 Network controller: Broadcom Corporation BCM4306 802.11b/g Wireless
LAN Controller (rev 03)
        Subsystem: Linksys Unknown device 0013
        Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
Stepping- SERR+ FastB2B-
        Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort-
<TAbort- <MAbort- >SERR- <PERR-
        Latency: 64
        Interrupt: pin A routed to IRQ 20
        Region 0: Memory at fcfde000 (32-bit, non-prefetchable) [size=8K]


This device works know and then. I've had many trouble with preemptive
kernels. For a couple of months it ran fine with debian kernel 2.6.21, 3
weeks ago I switched to a custom kernel based on Debians 2.6.21 and since
this week I experiencing trouble agian: the device isn't getting any IP
address through DHCP.

I'd be pleased to provide more information if needed ...

Kind Regards,


Beno?t
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070828/fbca26e0/attachment.html>

From celejar at gmail.com  Tue Aug 28 23:30:26 2007
From: celejar at gmail.com (Celejar)
Date: Tue, 28 Aug 2007 17:30:26 -0400
Subject: Acer 3690-2672 / Broadcom 4318 (rev 02)
Message-ID: <20070828173026.a7646238.celejar@gmail.com>

Hi,

My Acer 3690-2672 (not listed in the Acer list on the devices page) has
an internal 4318.

lspci -vn:

06:02.0 0280: 14e4:4318 (rev 02)
        Subsystem: 1468:0312
        Flags: bus master, fast devsel, latency 64, IRQ 10
        Memory at d0002000 (32-bit, non-prefetchable) [size=8K]

It works fairly well with bcm43xx from 2.6.22 (Debian Sid), although my
qualitative feeling is that performance and stability are better with
ndiswrapper.  Thanks for your work on OSS Broadcom drivers!

Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator



From mistamaila at gmail.com  Wed Aug 29 18:20:03 2007
From: mistamaila at gmail.com (John H.)
Date: Wed, 29 Aug 2007 11:20:03 -0500
Subject: bcm43xx-mac80211 problems with advanced wpa
In-Reply-To: <46CF6210.5010705@lwfinger.net>
References: <5b9417770708220810x5b3fb9f9ndbd97f9bdeca55d7@mail.gmail.com>
	<1187995765.6290.19.camel@ashe.anyarch.net>
	<46CF6210.5010705@lwfinger.net>
Message-ID: <5b9417770708290920y2e64b0bes78c5bf4b30329d58@mail.gmail.com>

I will confirm that this actually works on my school network.
2.6.22.4 with the b43 module does, that is.

However, it works if I manually do dhclient wlan0 as opposed to ifup
wlan0, which is strange as wlan0 is configured to use dhcp.

On 8/24/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> Daniel Ostrow wrote:
> > <snip>
> >> ioctl[SIOCSIWAUTH]: Operation not supported
> >> WEXT auth param 4 value 0x0 -
> >> ioctl[SIOCSIWAUTH]: Operation not supported
> >> WEXT auth param 5 value 0x1 -
> > </snip>
> >
> > For what it is worth I get the above messages from wpa_supplicant as
> > well using b43. They don't seem to inhibit the functionality of my setup
> > at all but I am including details below for whatever the information
> > will help with.
> >
> > My system is a Dell Latitude D520, it has a 4311 in addition to a b44
> > wired nick, I have ssb, b44 and b43 compiled as modules (not by choice
> > but my machine panics if I build in ssb and b44 and leave b43 as a
> > module) from a pull of the #everything branch from Linville's
> > wireless-dev tree from yesterday. I am running Gentoo (as if the e-mail
> > address didn't give that away) with wpa_supplicant-0.5.8. I am
> > connecting to two different networks using wpa_supplicant one WPA-PSK
> > the other WPA2-PSK, the (edited) configs are below.
> >
> > network={
> >       ssid="gatekeeper"
> >       key_mgmt=WPA-PSK
> >       psk="<pass-key>"
> >       priority=1
> > }
> >
> > network={
> >       ssid="WSTMBLG2"
> >       proto=RSN
> >       key_mgmt=WPA-PSK
> >       pairwise=TKIP
> >       group=TKIP
> >       psk="<pass-key>"
> >       priority=2
> > }
> >
> > I did not see these messages from wpa_supplicant before I moved to b43
> > from bcm43xx (softmac). As I said though...they don't seem to inhibit
> > anything, I associate and connect at very good rates, just thought I'd
> > pass along the anecdotal information. Kepp up the great work, the driver
> > works like a charm!
>
> In bcm43xx, those IOCTL's were implemented. In mac80211, they are not as they are not needed. As you
> see, those messages are not fatal.
>
> Larry
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>


From larry.finger at lwfinger.net  Wed Aug 29 18:38:31 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 29 Aug 2007 11:38:31 -0500
Subject: bcm43xx-mac80211 problems with advanced wpa
In-Reply-To: <5b9417770708290920y2e64b0bes78c5bf4b30329d58@mail.gmail.com>
References: <5b9417770708220810x5b3fb9f9ndbd97f9bdeca55d7@mail.gmail.com>	
	<1187995765.6290.19.camel@ashe.anyarch.net>	
	<46CF6210.5010705@lwfinger.net>
	<5b9417770708290920y2e64b0bes78c5bf4b30329d58@mail.gmail.com>
Message-ID: <46D5A107.7060605@lwfinger.net>

John H. wrote:
> I will confirm that this actually works on my school network.
> 2.6.22.4 with the b43 module does, that is.
> 
> However, it works if I manually do dhclient wlan0 as opposed to ifup
> wlan0, which is strange as wlan0 is configured to use dhcp.

Perhaps it is a timing problem.

Larry




From richie at coderworld.net  Wed Aug 29 19:34:58 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Wed, 29 Aug 2007 19:34:58 +0200
Subject: fetching wireless dev
Message-ID: <46D5AE42.4040602@coderworld.net>

I can't figure out how to keep up to date with the wireless dev tree.
I've set up as told by John W. Linville in a post here and use the 
"everything" branch.

When browsing the tree at kernel.org I see changes from 24'th of august, 
but my local copy is from 15'th (when I first fetched) even after "git 
fetch". What command am I supposed to use?

What is the best practice to apply patches not yet in Linvilles tree?

My purpose is to test patches from the list and will probably not do 
patches myself.

Richard


From schwab at suse.de  Wed Aug 29 19:54:15 2007
From: schwab at suse.de (Andreas Schwab)
Date: Wed, 29 Aug 2007 19:54:15 +0200
Subject: fetching wireless dev
In-Reply-To: <46D5AE42.4040602@coderworld.net> (Richard Jonsson's message of
	"Wed\, 29 Aug 2007 19\:34\:58 +0200")
References: <46D5AE42.4040602@coderworld.net>
Message-ID: <jeejhmns54.fsf@sykes.suse.de>

Richard Jonsson <richie at coderworld.net> writes:

> When browsing the tree at kernel.org I see changes from 24'th of august, 
> but my local copy is from 15'th (when I first fetched) even after "git 
> fetch". What command am I supposed to use?

Use "git pull" instead.  "git fetch" only fetches new objects, but does
not merge them.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From larry.finger at lwfinger.net  Wed Aug 29 20:01:04 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 29 Aug 2007 13:01:04 -0500
Subject: fetching wireless dev
In-Reply-To: <46D5AE42.4040602@coderworld.net>
References: <46D5AE42.4040602@coderworld.net>
Message-ID: <46D5B460.2020504@lwfinger.net>

Richard Jonsson wrote:
> I can't figure out how to keep up to date with the wireless dev tree.
> I've set up as told by John W. Linville in a post here and use the 
> "everything" branch.
> 
> When browsing the tree at kernel.org I see changes from 24'th of august, 
> but my local copy is from 15'th (when I first fetched) even after "git 
> fetch". What command am I supposed to use?

'git pull' will get any updates.

> What is the best practice to apply patches not yet in Linvilles tree?
> 
> My purpose is to test patches from the list and will probably not do 
> patches myself.

The "best" practice is probably in the eye of the user. What I do is to get the patch text into my 
wireless-dev tree by downloading or by saving the email containing the patch. If you do the latter, 
be careful about the white space. Too many mailers change tabs into spaces that kills the 
application of the patch.

To apply patches, I use quilt. With it, you can "quilt import" the file and apply the patch with 
"quilt push". To remove the patch, use the "quilt pop" command. In case you do want to write your 
own patches, start with the "quilt new" command, then modify the source using the "quilt edit" 
command, followed by "quilt refresh". You can find a description of quilt from 'man quilt' or on-line.

Larry



From linville at tuxdriver.com  Wed Aug 29 19:51:56 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 29 Aug 2007 13:51:56 -0400
Subject: fetching wireless dev
In-Reply-To: <46D5AE42.4040602@coderworld.net>
References: <46D5AE42.4040602@coderworld.net>
Message-ID: <20070829175156.GB4925@tuxdriver.com>

On Wed, Aug 29, 2007 at 07:34:58PM +0200, Richard Jonsson wrote:
> I can't figure out how to keep up to date with the wireless dev tree.
> I've set up as told by John W. Linville in a post here and use the 
> "everything" branch.
> 
> When browsing the tree at kernel.org I see changes from 24'th of august, 
> but my local copy is from 15'th (when I first fetched) even after "git 
> fetch". What command am I supposed to use?

I think 'git pull' is what you want.  But be warned that wireless-dev
will be rebased from time to time, and pulling won't work across
rebases.

> What is the best practice to apply patches not yet in Linvilles tree?
> 
> My purpose is to test patches from the list and will probably not do 
> patches myself.

The best practice would be to keep an up-to-date copy of Linus' tree
(i.e. linux-2.6) using 'git pull'.  Then when you want to experiment
w/ wireless-dev, you can create a lightweight clone (my terminology)
using a command like this:

   git clone --reference linux-2.6 git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-dev.git wireless-dev

Then create a working branch for yourself:

   git checkout -b work origin/everything

Then you can apply patch emails for testing.  Save the patch email
in mbox format, then use this command:

   git applymbox patch.mbox

Then, build-test-patch-repeat... :-)

Hth!

John
-- 
John W. Linville
linville at tuxdriver.com


From richie at coderworld.net  Wed Aug 29 20:40:30 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Wed, 29 Aug 2007 20:40:30 +0200
Subject: fetching wireless dev
In-Reply-To: <46D5B460.2020504@lwfinger.net>
References: <46D5AE42.4040602@coderworld.net> <46D5B460.2020504@lwfinger.net>
Message-ID: <46D5BD9E.6060809@coderworld.net>

Larry Finger skrev:
> Richard Jonsson wrote:
>> I can't figure out how to keep up to date with the wireless dev tree.
>> I've set up as told by John W. Linville in a post here and use the 
>> "everything" branch.
>>
>> When browsing the tree at kernel.org I see changes from 24'th of 
>> august, but my local copy is from 15'th (when I first fetched) even 
>> after "git fetch". What command am I supposed to use?
> 
> 'git pull' will get any updates.
> 
>> What is the best practice to apply patches not yet in Linvilles tree?
>>
>> My purpose is to test patches from the list and will probably not do 
>> patches myself.
> 
> The "best" practice is probably in the eye of the user. What I do is to 
> get the patch text into my wireless-dev tree by downloading or by saving 
> the email containing the patch. If you do the latter, be careful about 
> the white space. Too many mailers change tabs into spaces that kills the 
> application of the patch.
> 
> To apply patches, I use quilt. With it, you can "quilt import" the file 
> and apply the patch with "quilt push". To remove the patch, use the 
> "quilt pop" command. In case you do want to write your own patches, 
> start with the "quilt new" command, then modify the source using the 
> "quilt edit" command, followed by "quilt refresh". You can find a 
> description of quilt from 'man quilt' or on-line.
> 
> Larry
> 
Sorry Larry, I realised I sent you a private copy of this message.
---
Thank you both, but with "git pull" I get this instead:

$ git pull
Warning: No merge candidate found because value of config option
          "branch.everything.merge" does not match any remote branch 
fetched.

A google search turned up one relevant result, but it didn't help.



From larry.finger at lwfinger.net  Wed Aug 29 21:35:14 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 29 Aug 2007 14:35:14 -0500
Subject: fetching wireless dev
In-Reply-To: <46D5BD9E.6060809@coderworld.net>
References: <46D5AE42.4040602@coderworld.net> <46D5B460.2020504@lwfinger.net>
	<46D5BD9E.6060809@coderworld.net>
Message-ID: <46D5CA72.9030906@lwfinger.net>

Richard Jonsson wrote:
> ---
> Thank you both, but with "git pull" I get this instead:
> 
> $ git pull
> Warning: No merge candidate found because value of config option
>          "branch.everything.merge" does not match any remote branch 
> fetched.
> 
> A google search turned up one relevant result, but it didn't help

Did you do the steps that Linville outlined? I reproduce his notes below:


/home/linville/git/wireless-dev
[linville-t43.mobile]:> git branch
* master

/home/linville/git/wireless-dev
[linville-t43.mobile]:> git branch -r
   origin/HEAD
   origin/adm8211
   origin/b43
   origin/everything
   origin/iwlwifi
   origin/mac80211
   origin/master
   origin/merged-upstream
   origin/mm-master
   origin/p54
   origin/rt2x00
   origin/ssb
   origin/zd1211rw

/home/linville/git/wireless-dev
[linville-t43.mobile]:> git checkout -b everything origin/everything
Switched to a new branch "everything"

/home/linville/git/wireless-dev
[linville-t43.mobile]:> git branch
* everything
   master


Is this what you see with a 'git branch' command?

Larry


From richie at coderworld.net  Wed Aug 29 21:54:16 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Wed, 29 Aug 2007 21:54:16 +0200
Subject: fetching wireless dev
In-Reply-To: <46D5CA72.9030906@lwfinger.net>
References: <46D5AE42.4040602@coderworld.net> <46D5B460.2020504@lwfinger.net>
	<46D5BD9E.6060809@coderworld.net> <46D5CA72.9030906@lwfinger.net>
Message-ID: <46D5CEE8.9040201@coderworld.net>

Larry Finger skrev:
> Richard Jonsson wrote:
>> ---
>> Thank you both, but with "git pull" I get this instead:
>>
>> $ git pull
>> Warning: No merge candidate found because value of config option
>>          "branch.everything.merge" does not match any remote branch 
>> fetched.
>>
>> A google search turned up one relevant result, but it didn't help
> 
> Did you do the steps that Linville outlined? I reproduce his notes below:
> 
> 
> /home/linville/git/wireless-dev
> [linville-t43.mobile]:> git branch
> * master
> 
> /home/linville/git/wireless-dev
> [linville-t43.mobile]:> git branch -r
>   origin/HEAD
>   origin/adm8211
>   origin/b43
>   origin/everything
>   origin/iwlwifi
>   origin/mac80211
>   origin/master
>   origin/merged-upstream
>   origin/mm-master
>   origin/p54
>   origin/rt2x00
>   origin/ssb
>   origin/zd1211rw
> 
> /home/linville/git/wireless-dev
> [linville-t43.mobile]:> git checkout -b everything origin/everything
> Switched to a new branch "everything"
> 
> /home/linville/git/wireless-dev
> [linville-t43.mobile]:> git branch
> * everything
>   master
> 
> 
> Is this what you see with a 'git branch' command?
> 
> Larry

Yes, that's exactly what I see. Just started over with a fresh tree by 
following Linvilles instructions in this topic/thread. I also typed the 
additional commands you said, and got the exact same output, reproduced 
below:

richie at richie-laptop:/usr/src/git$ rm -rf wireless-dev/
richie at richie-laptop:/usr/src/git$ git clone --reference linux-2.6 
git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-dev.git 
wireless-dev
Initialized empty Git repository in /usr/src/git/wireless-dev/.git/
remote: Generating pack...
remote: Done counting 3229 objects.
remote: Deltifying 3229 objects...
remote:  100% (3229/3229) done
Indexing 3229 objects...
remote: Total 3229 (delta 2651), reused 3098 (delta 2614)
  100% (3229/3229) done
Resolving 2651 deltas...
  100% (2651/2651) done
Checking 22461 files out...
  100% (22461/22461) done
richie at richie-laptop:/usr/src/git$ cd wireless-dev/
richie at richie-laptop:/usr/src/git/wireless-dev$ git branch
* master
richie at richie-laptop:/usr/src/git/wireless-dev$ git branch -r
   origin/HEAD
   origin/adm8211
   origin/at76
   origin/ath5k
   origin/b43
   origin/everything
   origin/iwlwifi
   origin/mac80211
   origin/master
   origin/merged-upstream
   origin/mm-master
   origin/p54
   origin/pending-upstream
   origin/rt2x00
   origin/ssb
   origin/zd1211rw
richie at richie-laptop:/usr/src/git/wireless-dev$ git checkout -b 
everything origin/everything
Switched to a new branch "everything"
richie at richie-laptop:/usr/src/git/wireless-dev$ git branch
* everything
   master
richie at richie-laptop:/usr/src/git/wireless-dev$ git pull
Warning: No merge candidate found because value of config option
          "branch.everything.merge" does not match any remote branch 
fetched.
No changes.
richie at richie-laptop:/usr/src/git/wireless-dev$


From linville at tuxdriver.com  Wed Aug 29 22:02:12 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 29 Aug 2007 16:02:12 -0400
Subject: fetching wireless dev
In-Reply-To: <46D5CEE8.9040201@coderworld.net>
References: <46D5AE42.4040602@coderworld.net> <46D5B460.2020504@lwfinger.net>
	<46D5BD9E.6060809@coderworld.net> <46D5CA72.9030906@lwfinger.net>
	<46D5CEE8.9040201@coderworld.net>
Message-ID: <20070829200212.GC4925@tuxdriver.com>

On Wed, Aug 29, 2007 at 09:54:16PM +0200, Richard Jonsson wrote:

> richie at richie-laptop:/usr/src/git/wireless-dev$ git checkout -b 
> everything origin/everything
> Switched to a new branch "everything"
> richie at richie-laptop:/usr/src/git/wireless-dev$ git branch
> * everything
>    master
> richie at richie-laptop:/usr/src/git/wireless-dev$ git pull
> Warning: No merge candidate found because value of config option
>           "branch.everything.merge" does not match any remote branch 
> fetched.
> No changes.

Well, you did just clone the repository -- no new changes since
your clone...

John
-- 
John W. Linville
linville at tuxdriver.com


From sanderson2 at RADFORD.EDU  Thu Aug 30 06:36:00 2007
From: sanderson2 at RADFORD.EDU (Anderson, Scott)
Date: Thu, 30 Aug 2007 00:36:00 -0400
Subject: Speed issues with Broadcom 4311
Message-ID: <E449A7309983564A87A493BFD0EE4DE7AACABB@exchstu.RADFORD.EDU>

Hello,

I wanted to report that I'm experiencing extremely slow speeds (20k) down or less using my Broadcom 4311 and the newer b43 driver. Pages have a very hard time loading. I'm currently running Fedora7 with the 2.6.22.4-65.fc7 kernel. My access point is an old Linksys wireless B router with wep encryption.

Lspci Shows: 01:00.0 Network controller: Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card (rev 01)



Iwconfig Shows:

wlan0     IEEE 802.11g  ESSID:"atlst"  
          Mode:Managed  Frequency:2.412 GHz  Access Point: 00:0C:41:6F:1F:6A   
          Bit Rate=5.5 Mb/s   
          Retry min limit:7   RTS thr:off   Fragment thr=2346 B   
          Encryption key:F5CC-E107-D3
          Link Quality=73/100  Signal level=-57 dBm  Noise level=-63 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

Dmesg Shows: ATTACHED


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070830/1f7ed42a/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Dmesg
Type: application/octet-stream
Size: 21295 bytes
Desc: Dmesg
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070830/1f7ed42a/attachment.obj>

From larry.finger at lwfinger.net  Thu Aug 30 07:57:59 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 30 Aug 2007 00:57:59 -0500
Subject: Speed issues with Broadcom 4311
In-Reply-To: <E449A7309983564A87A493BFD0EE4DE7AACABB@exchstu.RADFORD.EDU>
References: <E449A7309983564A87A493BFD0EE4DE7AACABB@exchstu.RADFORD.EDU>
Message-ID: <46D65C67.4030606@lwfinger.net>

Anderson, Scott wrote:
> Hello,
> 
> I wanted to report that I'm experiencing extremely slow speeds (20k) 
> down or less using my Broadcom 4311 and the newer b43 driver. Pages have 
> a very hard time loading. I'm currently running Fedora7 with the 
> 2.6.22.4-65.fc7 kernel. My access point is an old Linksys wireless B 
> router with wep encryption.
> 
> Lspci Shows: 01:00.0 Network controller: Broadcom Corporation Dell 
> Wireless 1390 WLAN Mini-PCI Card (rev 01)
> 
> 
> 
> Iwconfig Shows:
> 
> wlan0     IEEE 802.11g  ESSID:"atlst" 
>           Mode:Managed  Frequency:2.412 GHz  Access Point: 
> 00:0C:41:6F:1F:6A  
>           Bit Rate=5.5 Mb/s  
>           Retry min limit:7   RTS thr:off   Fragment thr=2346 B  
>           Encryption key:F5CC-E107-D3
>           Link Quality=73/100  Signal level=-57 dBm  Noise level=-63 dBm
>           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0

Have you had experiences with other bcm43xx drivers with this card and AP? Some people have reported
poor performance at 11Mb/s, but others have no problems.

I just tested my BCM4311 with b43 from wireless-dev, WEP encryption, and an AP set for b-only 
operation. It's speed adjusted to 11 Mbs fairly quickly and yielded about 4 Mbs uploads using iperf. 
Due to my network configuration, I couldn't measure download speed.

BTW, when you send iwconfig output to the list, please obscure the encryption key. You have just
published it to the whole world.

Larry




From johannes at sipsolutions.net  Thu Aug 30 14:57:16 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 30 Aug 2007 14:57:16 +0200
Subject: [FYI] b43 vulnerable to CCMP replay attacks
Message-ID: <1188478636.2963.26.camel@johannes.berg>

b43 contains the following code (with - because I copied it from a patch
I have that removes it):

-                       if (skb->data[wlhdr_len + 3] & (1 << 5)) {
-                               /* The Ext-IV Bit is set in the "KeyID"
-                                * octet of the IV.
-                                */
-                               iv_len = 8;
-                               icv_len = 8;
-                       } else {
-                               iv_len = 4;
-                               icv_len = 4;
-                       }
-                       if (unlikely(skb->len < (wlhdr_len + iv_len + icv_len))) {
-                               b43dbg(dev->wl,
-                                      "RX: Packet size underrun (4)\n");
-                               goto drop;
-                       }
-                       /* Remove the IV */
-                       memmove(skb->data + iv_len, skb->data, wlhdr_len);
-                       skb_pull(skb, iv_len);
-                       /* Remove the ICV */
-                       skb_trim(skb, skb->len - icv_len);

This means that it is vulnerable to CCMP replay attacks when hardware
crypto is used because the hardware doesn't verify the CCMP PN and
mac80211 cannot.

The patch quoted above fixes this but does a bunch of changes in
mac80211 too and needs to get some review. I hope we can get to that
before 2.6.24 so that b43 can finally go mainline.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070830/b301e2d6/attachment.pgp>

From johannes at sipsolutions.net  Thu Aug 30 15:05:44 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 30 Aug 2007 15:05:44 +0200
Subject: [PATCH] b43 drivers: remove IEEE80211_CONF_SSID_HIDDEN
Message-ID: <1188479144.2963.30.camel@johannes.berg>

The IEEE80211_CONF_SSID_HIDDEN setting is unclear but does not
match the "closed net" flag b43 hardware has; the flag influences
only the sending of probe responses which is disabled anyway.
>From looking at the microcode, I can see that if the flag is set
then probe requests are required to be directed to the BSSID of
the AP to be answered by the microcode, but this not interesting
because we don't support probe request offload anyway.

This patch removes the IEEE80211_CONF_SSID_HIDDEN use from
both b43 drivers.

Cc: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>

---
I've also clarified the specs, please queue the change to your
respective drivers.

 drivers/net/wireless/b43/main.c       |   11 -----------
 drivers/net/wireless/b43legacy/main.c |   12 ------------
 2 files changed, 23 deletions(-)

--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-08-30 14:35:57.512051253 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-08-30 14:36:01.002051253 +0200
@@ -2836,17 +2836,6 @@ static int b43_dev_config(struct ieee802
 		}
 	}
 
-	/* Hide/Show the SSID (AP mode only). */
-	if (conf->flags & IEEE80211_CONF_SSID_HIDDEN) {
-		b43_write32(dev, B43_MMIO_MACCTL,
-			    b43_read32(dev, B43_MMIO_MACCTL)
-			    | B43_MACCTL_CLOSEDNET);
-	} else {
-		b43_write32(dev, B43_MMIO_MACCTL,
-			    b43_read32(dev, B43_MMIO_MACCTL)
-			    & ~B43_MACCTL_CLOSEDNET);
-	}
-
 	/* Antennas for RX and management frame TX. */
 	b43_mgmtframe_txantenna(dev, antenna_tx);
 	b43_set_rx_antenna(dev, antenna_rx);
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c	2007-08-30 14:35:05.962051253 +0200
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c	2007-08-30 14:36:01.022051253 +0200
@@ -2655,18 +2655,6 @@ static int b43legacy_dev_config(struct i
 		}
 	}
 
-	/* Hide/Show the SSID (AP mode only). */
-	if (conf->flags & IEEE80211_CONF_SSID_HIDDEN)
-		b43legacy_write32(dev, B43legacy_MMIO_STATUS_BITFIELD,
-				  b43legacy_read32(dev,
-				  B43legacy_MMIO_STATUS_BITFIELD)
-				  | B43legacy_SBF_NO_SSID_BCAST);
-	else
-		b43legacy_write32(dev, B43legacy_MMIO_STATUS_BITFIELD,
-				  b43legacy_read32(dev,
-				  B43legacy_MMIO_STATUS_BITFIELD)
-				  & ~B43legacy_SBF_NO_SSID_BCAST);
-
 	/* Antennas for RX and management frame TX. */
 	b43legacy_mgmtframe_txantenna(dev, antenna_tx);
 




From Larry.Finger at lwfinger.net  Thu Aug 30 17:51:32 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 30 Aug 2007 10:51:32 -0500
Subject: [PATCH] b43legacy: Fix cancellation of work queues
Message-ID: <46d6e784.rmn2RTWa4thtSUqA%Larry.Finger@lwfinger.net>

From: Michael Buesch <mb at bu3sch.de>
This correctly cancels all workqueues on shutdown.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Signed-off-by: Larry Finger <larry.finger.lwfinger.net>
---

Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -2275,11 +2275,6 @@ out:
 	mutex_unlock(&dev->wl->mutex);
 }
 
-static void b43legacy_periodic_tasks_delete(struct b43legacy_wldev *dev)
-{
-	cancel_rearming_delayed_work(&dev->periodic_work);
-}
-
 static void b43legacy_periodic_tasks_setup(struct b43legacy_wldev *dev)
 {
 	struct delayed_work *work = &dev->periodic_work;
@@ -2774,9 +2769,9 @@ static void b43legacy_wireless_core_stop
 	b43legacy_set_status(dev, B43legacy_STAT_INITIALIZED);
 
 	mutex_unlock(&wl->mutex);
-	/* Must unlock as it would otherwise deadlock. No races here. */
-	b43legacy_periodic_tasks_delete(dev);
-	flush_workqueue(dev->wl->hw->workqueue);
+	/* Must unlock as it would otherwise deadlock. No races here.
+	 * Cancel the possibly running self-rearming periodic work. */
+	cancel_delayed_work_sync(&dev->periodic_work);
 	mutex_lock(&wl->mutex);
 
 	ieee80211_stop_queues(wl->hw); /* FIXME this could cause a deadlock */
@@ -3014,13 +3009,22 @@ static void b43legacy_imcfglo_timeouts_w
 }
 
 /* Shutdown a wireless core */
+/* Locking: wl->mutex */
 static void b43legacy_wireless_core_exit(struct b43legacy_wldev *dev)
 {
+	struct b43legacy_wl *wl = dev->wl;
 	struct b43legacy_phy *phy = &dev->phy;
 
 	B43legacy_WARN_ON(b43legacy_status(dev) > B43legacy_STAT_INITIALIZED);
 	if (b43legacy_status(dev) != B43legacy_STAT_INITIALIZED)
 		return;
+	b43legacy_set_status(dev, B43legacy_STAT_UNINIT);
+
+	mutex_unlock(&wl->mutex);
+	/* Must unlock as it would otherwise deadlock. No races here.
+	 * Cancel possibly pending workqueues. */
+	cancel_work_sync(&dev->restart_work);
+	mutex_lock(&wl->mutex);
 
 	b43legacy_rng_exit(dev->wl);
 	b43legacy_pio_free(dev);
@@ -3034,7 +3038,6 @@ static void b43legacy_wireless_core_exit
 	phy->lo_control = NULL;
 	ssb_device_disable(dev->dev, 0);
 	ssb_bus_may_powerdown(dev->dev->bus);
-	b43legacy_set_status(dev, B43legacy_STAT_UNINIT);
 }
 
 static void prepare_phy_data_for_init(struct b43legacy_wldev *dev)
@@ -3711,6 +3714,9 @@ static void b43legacy_remove(struct ssb_
 void b43legacy_controller_restart(struct b43legacy_wldev *dev,
 				  const char *reason)
 {
+	/* Must avoid requeueing, if we are in shutdown. */
+	if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED)
+		return;
 	b43legacyinfo(dev->wl, "Controller RESET (%s) ...\n", reason);
 	queue_work(dev->wl->hw->workqueue, &dev->restart_work);
 }


From larry.finger at lwfinger.net  Thu Aug 30 18:49:54 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 30 Aug 2007 11:49:54 -0500
Subject: Speed issues with Broadcom 4311
In-Reply-To: <E449A7309983564A87A493BFD0EE4DE7AACABC@exchstu.RADFORD.EDU>
References: <E449A7309983564A87A493BFD0EE4DE7AACABB@exchstu.RADFORD.EDU>
	<46D65C67.4030606@lwfinger.net>
	<E449A7309983564A87A493BFD0EE4DE7AACABC@exchstu.RADFORD.EDU>
Message-ID: <46D6F532.6050304@lwfinger.net>

Anderson, Scott wrote:
> 
> 
> 
> -----Original Message-----
> From: Larry Finger [mailto:larry.finger at lwfinger.net]
> Sent: Thu 8/30/2007 1:57 AM
> To: Anderson, Scott
> Cc: bcm43xx-dev at lists.berlios.de
> Subject: Re: Speed issues with Broadcom 4311
> 
> Anderson, Scott wrote:
>  > Hello,
>  >
>  > I wanted to report that I'm experiencing extremely slow speeds (20k)
>  > down or less using my Broadcom 4311 and the newer b43 driver. Pages have
>  > a very hard time loading. I'm currently running Fedora7 with the
>  > 2.6.22.4-65.fc7 kernel. My access point is an old Linksys wireless B
>  > router with wep encryption.
>  >
>  > Lspci Shows: 01:00.0 Network controller: Broadcom Corporation Dell
>  > Wireless 1390 WLAN Mini-PCI Card (rev 01)
>  >
>  >
>  >
>  > Iwconfig Shows:
>  >
>  > wlan0     IEEE 802.11g  ESSID:"atlst"
>  >           Mode:Managed  Frequency:2.412 GHz  Access Point:
>  > ******
>  >           Bit Rate=5.5 Mb/s 
>  >           Retry min limit:7   RTS thr:off   Fragment thr=2346 B 
>  >           Encryption key:*****
>  >           Link Quality=73/100  Signal level=-57 dBm  Noise level=-63 dBm
>  >           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>  >           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> 
> Have you had experiences with other bcm43xx drivers with this card and 
> AP? Some people have reported
> poor performance at 11Mb/s, but others have no problems.
> 
> I just tested my BCM4311 with b43 from wireless-dev, WEP encryption, and 
> an AP set for b-only
> operation. It's speed adjusted to 11 Mbs fairly quickly and yielded 
> about 4 Mbs uploads using iperf.
> Due to my network configuration, I couldn't measure download speed.
> 
> BTW, when you send iwconfig output to the list, please obscure the 
> encryption key. You have just
> published it to the whole world.
> 
> Larry
> 
> 
> I have had experience using the older bcm43xx softmac driver since the 
> .19 kernel. Originally I had speed issues with this driver but that has 
> been fixed since February. I would really like to use the newer b43 
> driver as it seems to hold connection a lot better, plus it allows me to 
> reconnect something that had a lot of trouble doing before. Just seems 
> much better overall, minus of course the speed issues I seem to be 
> having. Any reason why iwconfig is showing that my wireless B is a G 
> network from my original post. Might not be related but just re-read my 
> original post and thought that looked a little out of place. If you 
> would like me to test anything else or change settings on my router I 
> can. I also have access to a wireless n/b/g i could try out if needed.

Please keep the CC's unless you have something private to convey.

I reviewed the change notices associated with the release of that Fedora kernel. It has the broken 
power control code. I'm sure there is a newer one. If not, do you have the source or just a binary? 
With source, I could send you a patch to fix that part.

Larry


From richie at coderworld.net  Thu Aug 30 18:52:55 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Thu, 30 Aug 2007 18:52:55 +0200
Subject: fetching wireless dev
In-Reply-To: <20070829200212.GC4925@tuxdriver.com>
References: <46D5AE42.4040602@coderworld.net> <46D5B460.2020504@lwfinger.net>
	<46D5BD9E.6060809@coderworld.net> <46D5CA72.9030906@lwfinger.net>
	<46D5CEE8.9040201@coderworld.net>
	<20070829200212.GC4925@tuxdriver.com>
Message-ID: <46D6F5E7.9060509@coderworld.net>

John W. Linville skrev:
> On Wed, Aug 29, 2007 at 09:54:16PM +0200, Richard Jonsson wrote:
> 
>> richie at richie-laptop:/usr/src/git/wireless-dev$ git checkout -b 
>> everything origin/everything
>> Switched to a new branch "everything"
>> richie at richie-laptop:/usr/src/git/wireless-dev$ git branch
>> * everything
>>    master
>> richie at richie-laptop:/usr/src/git/wireless-dev$ git pull
>> Warning: No merge candidate found because value of config option
>>           "branch.everything.merge" does not match any remote branch 
>> fetched.
>> No changes.
> 
> Well, you did just clone the repository -- no new changes since
> your clone...
> 
> John
Makes sense I guess, but I got this exact message with my cloned tree 
that was not up to date, including the "No changes." part.

Anyway, it works now, but the message is still there at the end of the 
pull command.

Thank you for getting me on track.


From Larry.Finger at lwfinger.net  Thu Aug 30 19:01:19 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 30 Aug 2007 12:01:19 -0500
Subject: [PATCH] b43legacy: Remove IEEE80211_CONF_SSID_HIDDEN
Message-ID: <46d6f7df.FLItjm2Dtkoq15Jl%Larry.Finger@lwfinger.net>

From: Johannes Berg <johannes at sipsolutions.net>

The IEEE80211_CONF_SSID_HIDDEN setting is unclear but does not
match the "closed net" flag b43 hardware has; the flag influences
only the sending of probe responses which is disabled anyway.

From mb at bu3sch.de  Thu Aug 30 19:26:32 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 30 Aug 2007 19:26:32 +0200
Subject: [PATCH] b43 drivers: remove IEEE80211_CONF_SSID_HIDDEN
Message-ID: <200708301926.32594.mb@bu3sch.de>

From: Johannes Berg <johannes at sipsolutions.net>

The IEEE80211_CONF_SSID_HIDDEN setting is unclear but does not
match the "closed net" flag b43 hardware has; the flag influences
only the sending of probe responses which is disabled anyway.
>From looking at the microcode, I can see that if the flag is set
then probe requests are required to be directed to the BSSID of
the AP to be answered by the microcode, but this not interesting
because we don't support probe request offload anyway.

This patch removes the IEEE80211_CONF_SSID_HIDDEN use from
both b43 drivers.

Cc: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>
Signed-off-by: Michael Buesch <mb at bu3sch.de>

---
I've also clarified the specs, please queue the change to your
respective drivers.

 drivers/net/wireless/b43/main.c       |   11 -----------
 drivers/net/wireless/b43legacy/main.c |   12 ------------
 2 files changed, 23 deletions(-)

--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-08-30 14:35:57.512051253 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-08-30 14:36:01.002051253 +0200
@@ -2836,17 +2836,6 @@ static int b43_dev_config(struct ieee802
 		}
 	}
 
-	/* Hide/Show the SSID (AP mode only). */
-	if (conf->flags & IEEE80211_CONF_SSID_HIDDEN) {
-		b43_write32(dev, B43_MMIO_MACCTL,
-			    b43_read32(dev, B43_MMIO_MACCTL)
-			    | B43_MACCTL_CLOSEDNET);
-	} else {
-		b43_write32(dev, B43_MMIO_MACCTL,
-			    b43_read32(dev, B43_MMIO_MACCTL)
-			    & ~B43_MACCTL_CLOSEDNET);
-	}
-
 	/* Antennas for RX and management frame TX. */
 	b43_mgmtframe_txantenna(dev, antenna_tx);
 	b43_set_rx_antenna(dev, antenna_rx);
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c	2007-08-30 14:35:05.962051253 +0200
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c	2007-08-30 14:36:01.022051253 +0200
@@ -2655,18 +2655,6 @@ static int b43legacy_dev_config(struct i
 		}
 	}
 
-	/* Hide/Show the SSID (AP mode only). */
-	if (conf->flags & IEEE80211_CONF_SSID_HIDDEN)
-		b43legacy_write32(dev, B43legacy_MMIO_STATUS_BITFIELD,
-				  b43legacy_read32(dev,
-				  B43legacy_MMIO_STATUS_BITFIELD)
-				  | B43legacy_SBF_NO_SSID_BCAST);
-	else
-		b43legacy_write32(dev, B43legacy_MMIO_STATUS_BITFIELD,
-				  b43legacy_read32(dev,
-				  B43legacy_MMIO_STATUS_BITFIELD)
-				  & ~B43legacy_SBF_NO_SSID_BCAST);
-
 	/* Antennas for RX and management frame TX. */
 	b43legacy_mgmtframe_txantenna(dev, antenna_tx);
 

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Thu Aug 30 19:47:50 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 30 Aug 2007 12:47:50 -0500
Subject: Broadcom 4311 WLAN card...
In-Reply-To: <20070830174257.GA20134@sdg.at>
References: <20070823092853.GA10527@sdg.at> <46CDA2C7.6040609@lwfinger.net>
	<20070824181435.GA19617@sdg.at> <46CF2490.2030809@lwfinger.net>
	<20070827063206.GA25531@sdg.at> <46D2DE63.6070100@lwfinger.net>
	<20070830174257.GA20134@sdg.at>
Message-ID: <46D702C6.605@lwfinger.net>

Dr. techn. Alexander K. Seewald wrote:
> Hi Larry,
> 
> When resuming from suspend-to-disk, I get the following message
> --
> Aug 30 18:22:41 localhost kernel: b43 ssb0:0: resuming
> Aug 30 18:22:41 localhost kernel: b43-phy0 ERROR: Microcode not
> responding
> Aug 30 18:22:41 localhost kernel: b43-phy0 ERROR: You must go to
> http://linuxwireless.org/en/users/Drivers/bcm43xx#devicefirmware and
> download the correct firmware (version 4).
> Aug 30 18:22:41 localhost kernel: b43-phy0 ERROR: Resume failed at
> core init
> --
> 
> Would this be easy to fix, e.g. by re-uploading the firmware in
> b43_resume? This does not seem to be done or it does not work
> correctly.

Michael,

Have you done any tests with suspend/resume? I have not.

Larry


From gavron at wetwork.net  Thu Aug 30 19:52:14 2007
From: gavron at wetwork.net (Ehud Gavron)
Date: Thu, 30 Aug 2007 10:52:14 -0700
Subject: Broadcom 4311 WLAN card...
In-Reply-To: <46D702C6.605@lwfinger.net>
References: <20070823092853.GA10527@sdg.at> <46CDA2C7.6040609@lwfinger.net>
	<20070824181435.GA19617@sdg.at> <46CF2490.2030809@lwfinger.net>
	<20070827063206.GA25531@sdg.at> <46D2DE63.6070100@lwfinger.net>
	<20070830174257.GA20134@sdg.at> <46D702C6.605@lwfinger.net>
Message-ID: <46D703CE.1010601@wetwork.net>

FYI Suspend/Resume is iffy.  Sometimes it works, sometimes it does not. 
When it does not, sometimes it unloads fine, sometimes it says it's 
waiting for a reference (or 3) to be cleared before unloading.  Only a 
reboot will cure that one... as the message repeats but the reference 
count never decreases.

In all cases the unload is preceded by an ifconfig eth1 down
unload = "rmmod b43"

Ehud
dell 1390 (4311) 2.6.23-rc3 (wireless dev everything 29-aug-2007)

Larry Finger wrote:
> Dr. techn. Alexander K. Seewald wrote:
>   
>> Hi Larry,
>>
>> When resuming from suspend-to-disk, I get the following message
>> --
>> Aug 30 18:22:41 localhost kernel: b43 ssb0:0: resuming
>> Aug 30 18:22:41 localhost kernel: b43-phy0 ERROR: Microcode not
>> responding
>> Aug 30 18:22:41 localhost kernel: b43-phy0 ERROR: You must go to
>> http://linuxwireless.org/en/users/Drivers/bcm43xx#devicefirmware and
>> download the correct firmware (version 4).
>> Aug 30 18:22:41 localhost kernel: b43-phy0 ERROR: Resume failed at
>> core init
>> --
>>
>> Would this be easy to fix, e.g. by re-uploading the firmware in
>> b43_resume? This does not seem to be done or it does not work
>> correctly.
>>     
>
> Michael,
>
> Have you done any tests with suspend/resume? I have not.
>
> Larry
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070830/ca372703/attachment.bin>

From mb at bu3sch.de  Thu Aug 30 19:52:17 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 30 Aug 2007 19:52:17 +0200
Subject: Broadcom 4311 WLAN card...
In-Reply-To: <46D702C6.605@lwfinger.net>
References: <20070823092853.GA10527@sdg.at> <20070830174257.GA20134@sdg.at>
	<46D702C6.605@lwfinger.net>
Message-ID: <200708301952.17397.mb@bu3sch.de>

On Thursday 30 August 2007 19:47:50 Larry Finger wrote:
> Dr. techn. Alexander K. Seewald wrote:
> > Hi Larry,
> > 
> > When resuming from suspend-to-disk, I get the following message
> > --
> > Aug 30 18:22:41 localhost kernel: b43 ssb0:0: resuming
> > Aug 30 18:22:41 localhost kernel: b43-phy0 ERROR: Microcode not
> > responding
> > Aug 30 18:22:41 localhost kernel: b43-phy0 ERROR: You must go to
> > http://linuxwireless.org/en/users/Drivers/bcm43xx#devicefirmware and
> > download the correct firmware (version 4).
> > Aug 30 18:22:41 localhost kernel: b43-phy0 ERROR: Resume failed at
> > core init
> > --
> > 
> > Would this be easy to fix, e.g. by re-uploading the firmware in
> > b43_resume? This does not seem to be done or it does not work
> > correctly.
> 
> Michael,
> 
> Have you done any tests with suspend/resume? I have not.

Works fine for me, except that mac80211 doesn't support it.
So we don't reassoc and don't upload the correct keys anymore.

-- 
Greetings Michael.


From sanderson2 at RADFORD.EDU  Thu Aug 30 20:20:28 2007
From: sanderson2 at RADFORD.EDU (Anderson, Scott)
Date: Thu, 30 Aug 2007 14:20:28 -0400
Subject: Speed issues with Broadcom 4311
References: <E449A7309983564A87A493BFD0EE4DE7AACABB@exchstu.RADFORD.EDU>
	<46D65C67.4030606@lwfinger.net>
Message-ID: <E449A7309983564A87A493BFD0EE4DE7AACABF@exchstu.RADFORD.EDU>




-----Original Message-----
From: Larry Finger [mailto:larry.finger at lwfinger.net]
Sent: Thu 8/30/2007 1:57 AM
To: Anderson, Scott
Cc: bcm43xx-dev at lists.berlios.de
Subject: Re: Speed issues with Broadcom 4311
 
Anderson, Scott wrote:
> Hello,
> 
> I wanted to report that I'm experiencing extremely slow speeds (20k) 
> down or less using my Broadcom 4311 and the newer b43 driver. Pages have 
> a very hard time loading. I'm currently running Fedora7 with the 
> 2.6.22.4-65.fc7 kernel. My access point is an old Linksys wireless B 
> router with wep encryption.
> 
> Lspci Shows: 01:00.0 Network controller: Broadcom Corporation Dell 
> Wireless 1390 WLAN Mini-PCI Card (rev 01)
> 
> 
> 
> Iwconfig Shows:
> 
> wlan0     IEEE 802.11g  ESSID:"atlst" 
>           Mode:Managed  Frequency:2.412 GHz  Access Point: 
> 00:0C:41:6F:1F:6A  
>           Bit Rate=5.5 Mb/s  
>           Retry min limit:7   RTS thr:off   Fragment thr=2346 B  
>           Encryption key:F5CC-E107-D3
>           Link Quality=73/100  Signal level=-57 dBm  Noise level=-63 dBm
>           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0

Have you had experiences with other bcm43xx drivers with this card and AP? Some people have reported
poor performance at 11Mb/s, but others have no problems.

I just tested my BCM4311 with b43 from wireless-dev, WEP encryption, and an AP set for b-only 
operation. It's speed adjusted to 11 Mbs fairly quickly and yielded about 4 Mbs uploads using iperf. 
Due to my network configuration, I couldn't measure download speed.

BTW, when you send iwconfig output to the list, please obscure the encryption key. You have just
published it to the whole world.

Larry


*used the older message you sent so that it would have the CCs. 


Currently I'm using just the binary, although I will get a new kernel from source right now if you want to go ahead and send that patch over. It would be most appreciated.




-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070830/7bb9ae29/attachment.html>

From mb at bu3sch.de  Thu Aug 30 20:31:01 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 30 Aug 2007 20:31:01 +0200
Subject: Speed issues with Broadcom 4311
In-Reply-To: <E449A7309983564A87A493BFD0EE4DE7AACABF@exchstu.RADFORD.EDU>
References: <E449A7309983564A87A493BFD0EE4DE7AACABB@exchstu.RADFORD.EDU>
	<46D65C67.4030606@lwfinger.net>
	<E449A7309983564A87A493BFD0EE4DE7AACABF@exchstu.RADFORD.EDU>
Message-ID: <200708302031.01854.mb@bu3sch.de>

On Thursday 30 August 2007 20:20:28 Anderson, Scott wrote:
> I just tested my BCM4311 with b43 from wireless-dev, WEP encryption, and an AP set for b-only 
> operation. It's speed adjusted to 11 Mbs fairly quickly and yielded about 4 Mbs uploads using iperf. 
> Due to my network configuration, I couldn't measure download speed.
> 
> BTW, when you send iwconfig output to the list, please obscure the encryption key. You have just
> published it to the whole world.

With WEP you do that anyway. :P
A modern machine can find the WEP password within a few minutes.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Thu Aug 30 20:36:42 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 30 Aug 2007 13:36:42 -0500
Subject: Speed issues with Broadcom 4311
In-Reply-To: <200708302031.01854.mb@bu3sch.de>
References: <E449A7309983564A87A493BFD0EE4DE7AACABB@exchstu.RADFORD.EDU>	<46D65C67.4030606@lwfinger.net>	<E449A7309983564A87A493BFD0EE4DE7AACABF@exchstu.RADFORD.EDU>
	<200708302031.01854.mb@bu3sch.de>
Message-ID: <46D70E3A.9030602@lwfinger.net>

Michael Buesch wrote:
>> BTW, when you send iwconfig output to the list, please obscure the encryption key. You have just
>> published it to the whole world.
> 
> With WEP you do that anyway. :P
> A modern machine can find the WEP password within a few minutes.

My warning was mostly for the list. I get WPA keys sent in the same way.

Larry


From larry.finger at lwfinger.net  Thu Aug 30 20:39:41 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 30 Aug 2007 13:39:41 -0500
Subject: Speed issues with Broadcom 4311
In-Reply-To: <E449A7309983564A87A493BFD0EE4DE7AACABF@exchstu.RADFORD.EDU>
References: <E449A7309983564A87A493BFD0EE4DE7AACABB@exchstu.RADFORD.EDU>
	<46D65C67.4030606@lwfinger.net>
	<E449A7309983564A87A493BFD0EE4DE7AACABF@exchstu.RADFORD.EDU>
Message-ID: <46D70EED.8010606@lwfinger.net>

Anderson, Scott wrote:
> 
> 
> 
> -----Original Message-----
> From: Larry Finger [mailto:larry.finger at lwfinger.net]
> Sent: Thu 8/30/2007 1:57 AM
> To: Anderson, Scott
> Cc: bcm43xx-dev at lists.berlios.de
> Subject: Re: Speed issues with Broadcom 4311
> 
> Anderson, Scott wrote:
>  > Hello,
>  >
>  > I wanted to report that I'm experiencing extremely slow speeds (20k)
>  > down or less using my Broadcom 4311 and the newer b43 driver. Pages have
>  > a very hard time loading. I'm currently running Fedora7 with the
>  > 2.6.22.4-65.fc7 kernel. My access point is an old Linksys wireless B
>  > router with wep encryption.
>  >
>  > Lspci Shows: 01:00.0 Network controller: Broadcom Corporation Dell
>  > Wireless 1390 WLAN Mini-PCI Card (rev 01)
>  >
>  >
>  >
>  > Iwconfig Shows:
>  >
>  > wlan0     IEEE 802.11g  ESSID:"atlst"
>  >           Mode:Managed  Frequency:2.412 GHz  Access Point:
>  > 00:0C:41:6F:1F:6A 
>  >           Bit Rate=5.5 Mb/s 
>  >           Retry min limit:7   RTS thr:off   Fragment thr=2346 B 
>  >           Encryption key:F5CC-E107-D3
>  >           Link Quality=73/100  Signal level=-57 dBm  Noise level=-63 dBm
>  >           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>  >           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> 
> Have you had experiences with other bcm43xx drivers with this card and 
> AP? Some people have reported
> poor performance at 11Mb/s, but others have no problems.
> 
> I just tested my BCM4311 with b43 from wireless-dev, WEP encryption, and 
> an AP set for b-only
> operation. It's speed adjusted to 11 Mbs fairly quickly and yielded 
> about 4 Mbs uploads using iperf.
> Due to my network configuration, I couldn't measure download speed.
> 
> BTW, when you send iwconfig output to the list, please obscure the 
> encryption key. You have just
> published it to the whole world.
> 
> Larry
> 
> 
> *used the older message you sent so that it would have the CCs.
> 
> 
> Currently I'm using just the binary, although I will get a new kernel 
> from source right now if you want to go ahead and send that patch over. 
> It would be most appreciated.

If possible, could you grab the source from wireless-git and build from it? That way, if you still 
have the problem, we will know it is current, not something from the past.

Larry


From Larry.Finger at lwfinger.net  Fri Aug 31 01:05:11 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 30 Aug 2007 18:05:11 -0500
Subject: [PATCH] b43legacy: Change Kconfig help text to match b43
Message-ID: <46d74d27.t9Eit/LAinpbIKhk%Larry.Finger@lwfinger.net>

This patch updates the b43legacy Kconfig text to match the latest
b43 version.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

 1 file changed, 14 insertions(+), 11 deletions(-)
finger at larrylap:/home/finger/wireless-dev>

Index: wireless-dev/drivers/net/wireless/b43legacy/Kconfig
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/Kconfig
+++ wireless-dev/drivers/net/wireless/b43legacy/Kconfig
@@ -1,21 +1,24 @@
 config B43LEGACY
-	tristate "Broadcom BCM43xx legacy wireless support (mac80211 stack)"
-	depends on SSB_POSSIBLE && MAC80211 && WLAN_80211 && EXPERIMENTAL
+	tristate "Broadcom 43xx-legacy wireless support (mac80211 stack)"
+	depends on SSB_POSSIBLE && MAC80211 && WLAN_80211
 	select SSB
 	select FW_LOADER
 	select HW_RANDOM
 	---help---
-	  This is a driver for 802.11b devices from Broadcom (BCM4301 and
-	  BCM4303).  It is also the driver for early model 802.11g chips (BCM4306
-	  Ver. 2) that were used in the Linksys WPC54G V1 PCMCIA devices. Newer
-	  devices need b43. It is safe to include both b43legacy and b43 as the
-	  ssb driver will select the correct version for your hardware.
+	  b43legacy is a driver for 802.11b devices from Broadcom (BCM4301 and
+	  BCM4303) and early model 802.11g chips (BCM4306 Ver. 2) used in the
+	  Linksys WPC54G V1 PCMCIA devices.
+
+	  Newer 802.11g and 802.11a devices need b43.
+
+	  It is safe to include both b43 and b43legacy as the underlying glue
+	  layer will automatically load the correct version for your device.
 
 	  This driver uses V3 firmware, which must be installed separately using
 	  b43-fwcutter.
 
-	  This driver can be compiled as a module (recommended) that will be
-	  called "b43legacy".
+	  This driver can be built as a module (recommended) that will be
+	  called "b43legacy". If unsure, say M.
 
 # Auto-select SSB PCI-HOST support, if possible
 config B43LEGACY_PCI_AUTOSELECT
@@ -32,7 +35,7 @@ config B43LEGACY_PCICORE_AUTOSELECT
 	default y
 
 config B43LEGACY_DEBUG
-	bool "Broadcom B43legacy debugging (RECOMMENDED)"
+	bool "Broadcom 43xx-legacy debugging"
 	depends on B43LEGACY
 	default y
 	---help---
@@ -48,7 +51,7 @@ config B43LEGACY_PIO
 	depends on B43LEGACY
 
 choice
-	prompt "B43LEGACY data transfer mode"
+	prompt "Broadcom 43xx-legacy data transfer mode"
 	depends on B43LEGACY
 	default B43LEGACY_DMA_AND_PIO_MODE
 


From bcm.jw.0708 at edavies.nildram.co.uk  Fri Aug 31 18:38:56 2007
From: bcm.jw.0708 at edavies.nildram.co.uk (Ed Davies)
Date: Fri, 31 Aug 2007 17:38:56 +0100
Subject: Broadcom 4311 on HP 350 laptop
Message-ID: <46D84420.8000909@edavies.nildram.co.uk>

Hi,

I've been unable to get a Dell Wireless 1390 card working on
an HP 350 laptop.  It's running Ubuntu Feisty.  Originally
it had the standard 2.6.20 kernel but today I tried upgrading
to the 2.5.22-10 kernel of Gutsy to no avail so thought it
was time to ask for help.

I hope the following console log at least tells enough of
the story that somebody can suggest what I should try
next.  From what I've seen of other messages and web
pages I should at least be getting more messages in the
dmesg output - lines with things like "PHY" in them.

I've noticed the messages from iwconfig and iwlist about
incompatible versions but think I should be getting further
with the driver startup irrespective of any such problem.

Thanks for any advice.

Ed Davies.


edavies at bill:~$ dmesg | grep bcm
[   19.640000] bcm43xx driver

edavies at bill:~$ uname -a
Linux bill 2.6.22-10-generic #1 SMP Wed Aug 22 08:11:52 GMT 2007 i686 GNU/Linux

edavies at bill:~$ lspci
00:00.0 Host bridge: Intel Corporation Mobile 945GM/PM/GMS/940GML and 945GT Express Memory Controller Hub (rev 03)
00:02.0 VGA compatible controller: Intel Corporation Mobile 945GM/GMS/940GML Express Integrated Graphics Controller (rev 03)
00:02.1 Display controller: Intel Corporation Mobile 945GM/GMS/940GML Express Integrated Graphics Controller (rev 03)
00:1b.0 Audio device: Intel Corporation 82801G (ICH7 Family) High Definition Audio Controller (rev 01)
00:1c.0 PCI bridge: Intel Corporation 82801G (ICH7 Family) PCI Express Port 1 (rev 01)
00:1c.1 PCI bridge: Intel Corporation 82801G (ICH7 Family) PCI Express Port 2 (rev 01)
00:1d.0 USB Controller: Intel Corporation 82801G (ICH7 Family) USB UHCI #1 (rev 01)
00:1d.7 USB Controller: Intel Corporation 82801G (ICH7 Family) USB2 EHCI Controller (rev 01)
00:1e.0 PCI bridge: Intel Corporation 82801 Mobile PCI Bridge (rev e1)
00:1f.0 ISA bridge: Intel Corporation 82801GBM (ICH7-M) LPC Interface Bridge (rev 01)
00:1f.1 IDE interface: Intel Corporation 82801G (ICH7 Family) IDE Controller (rev 01)
00:1f.2 SATA controller: Intel Corporation 82801GBM/GHM (ICH7 Family) Serial ATA Storage Controller AHCI (rev 01)
02:06.0 CardBus bridge: ENE Technology Inc CB1410 Cardbus Controller (rev 01)
02:08.0 Ethernet controller: Intel Corporation 82562ET/EZ/GT/GZ - PRO/100 VE (LOM) Ethernet Controller Mobile (rev 01)
10:00.0 Network controller: Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card (rev 01)

edavies at bill:~$ sudo lspci -vs 10:00.0
Password:
10:00.0 Network controller: Broadcom Corporation Dell Wireless 1390 WLAN Mini-PCI Card (rev 01)
         Subsystem: Hewlett-Packard Company Unknown device 1364
         Flags: bus master, fast devsel, latency 0, IRQ 17
         Memory at f0000000 (32-bit, non-prefetchable) [size=16K]
         Capabilities: [40] Power Management version 2
         Capabilities: [58] Message Signalled Interrupts: Mask- 64bit- Queue=0/0 Enable-
         Capabilities: [d0] Express Legacy Endpoint IRQ 0

edavies at bill:~$ lspci -ns 10:00.0
10:00.0 0280: 14e4:4311 (rev 01)

edavies at bill:~$ sudo modprobe -vr bcm43xx
rmmod /lib/modules/2.6.22-10-generic/kernel/drivers/net/wireless/bcm43xx/bcm43xx.ko
rmmod /lib/modules/2.6.22-10-generic/kernel/net/ieee80211/softmac/ieee80211softmac.ko
rmmod /lib/modules/2.6.22-10-generic/kernel/net/ieee80211/ieee80211.ko
rmmod /lib/modules/2.6.22-10-generic/kernel/net/ieee80211/ieee80211_crypt.ko

edavies at bill:~$ sudo modprobe -v bcm43xx
insmod /lib/modules/2.6.22-10-generic/kernel/net/ieee80211/ieee80211_crypt.ko
insmod /lib/modules/2.6.22-10-generic/kernel/net/ieee80211/ieee80211.ko
insmod /lib/modules/2.6.22-10-generic/kernel/net/ieee80211/softmac/ieee80211softmac.ko
insmod /lib/modules/2.6.22-10-generic/kernel/drivers/net/wireless/bcm43xx/bcm43xx.ko

edavies at bill:~$ iwconfig
lo        no wireless extensions.

eth0      no wireless extensions.

Warning: Driver for device eth1 has been compiled with version 22
of Wireless Extension, while this program supports up to version 20.
Some things may be broken...

eth1      IEEE 802.11b/g  ESSID:off/any  Nickname:"Broadcom 4311"
           Mode:Managed  Access Point: Invalid
           RTS thr:off   Fragment thr:off
           Link Quality=0/100  Signal level=-256 dBm  Noise level=-256 dBm
           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
           Tx excessive retries:0  Invalid misc:0   Missed beacon:0

edavies at bill:~$ sudo ifconfig eth1 up

edavies at bill:~$ dmesg | tail
[   32.864000] Bluetooth: RFCOMM ver 1.8
[  181.832000] ACPI: PCI interrupt for device 0000:10:00.0 disabled
[  181.840000] ieee80211_crypt: unregistered algorithm 'NULL'
[  196.524000] ieee80211_crypt: registered algorithm 'NULL'
[  196.528000] ieee80211: 802.11 data/management/control stack, git-1.1.13
[  196.528000] ieee80211: Copyright (C) 2004-2005 Intel Corporation <jketreno at linux.intel.com>
[  196.532000] bcm43xx driver
[  196.536000] ACPI: PCI Interrupt 0000:10:00.0[A] -> GSI 17 (level, low) -> IRQ 17
[  196.536000] PCI: Setting latency timer of device 0000:10:00.0 to 64
[  229.124000] ADDRCONF(NETDEV_UP): eth1: link is not ready

edavies at bill:~$ sudo iwlist eth1 scan
Warning: Driver for device eth1 has been compiled with version 22
of Wireless Extension, while this program supports up to version 20.
Some things may be broken...

eth1      No scan results

edavies at bill:~$ cd /lib/firmware

edavies at bill:/lib/firmware$ ls
2.6.20-15-generic     bcm43xx_initval02.fw  bcm43xx_initval06.fw  bcm43xx_initval10.fw    bcm43xx_microcode5.fw
2.6.20-16-generic     bcm43xx_initval03.fw  bcm43xx_initval07.fw  bcm43xx_microcode11.fw  bcm43xx_pcm4.fw
2.6.22-10-generic     bcm43xx_initval04.fw  bcm43xx_initval08.fw  bcm43xx_microcode2.fw   bcm43xx_pcm5.fw
bcm43xx_initval01.fw  bcm43xx_initval05.fw  bcm43xx_initval09.fw  bcm43xx_microcode4.fw

edavies at bill:/lib/firmware$ sudo mv bcm43xx_microcode5.fw bcm43xx_microcode5.fwXXX

edavies at bill:/lib/firmware$ sudo modprobe -r bcm43xx

edavies at bill:/lib/firmware$ sudo modprobe -v bcm43xx
insmod /lib/modules/2.6.22-10-generic/kernel/net/ieee80211/ieee80211_crypt.ko
insmod /lib/modules/2.6.22-10-generic/kernel/net/ieee80211/ieee80211.ko
insmod /lib/modules/2.6.22-10-generic/kernel/net/ieee80211/softmac/ieee80211softmac.ko
insmod /lib/modules/2.6.22-10-generic/kernel/drivers/net/wireless/bcm43xx/bcm43xx.ko

edavies at bill:/lib/firmware$ sudo ifconfig eth1 up
SIOCSIFFLAGS: No such file or directory

edavies at bill:/lib/firmware$ dmesg | tail
[  229.124000] ADDRCONF(NETDEV_UP): eth1: link is not ready
[  377.880000] ACPI: PCI interrupt for device 0000:10:00.0 disabled
[  377.880000] ieee80211_crypt: unregistered algorithm 'NULL'
[  390.464000] ieee80211_crypt: registered algorithm 'NULL'
[  390.468000] ieee80211: 802.11 data/management/control stack, git-1.1.13
[  390.468000] ieee80211: Copyright (C) 2004-2005 Intel Corporation <jketreno at linux.intel.com>
[  390.492000] bcm43xx driver
[  390.492000] ACPI: PCI Interrupt 0000:10:00.0[A] -> GSI 17 (level, low) -> IRQ 17
[  390.492000] PCI: Setting latency timer of device 0000:10:00.0 to 64
[  401.060000] bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load failed.

edavies at bill:/lib/firmware$ sudo mv bcm43xx_microcode5.fwXXX bcm43xx_microcode5.fw

edavies at bill:/lib/firmware$ sudo modprobe -r bcm43xx

edavies at bill:/lib/firmware$ sudo modprobe bcm43xx

edavies at bill:/lib/firmware$ sudo ifconfig eth1 up

edavies at bill:/lib/firmware$ dmesg | tail
[  401.060000] bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load failed.
[  456.476000] ACPI: PCI interrupt for device 0000:10:00.0 disabled
[  456.476000] ieee80211_crypt: unregistered algorithm 'NULL'
[  467.168000] ieee80211_crypt: registered algorithm 'NULL'
[  467.172000] ieee80211: 802.11 data/management/control stack, git-1.1.13
[  467.172000] ieee80211: Copyright (C) 2004-2005 Intel Corporation <jketreno at linux.intel.com>
[  467.176000] bcm43xx driver
[  467.176000] ACPI: PCI Interrupt 0000:10:00.0[A] -> GSI 17 (level, low) -> IRQ 17
[  467.176000] PCI: Setting latency timer of device 0000:10:00.0 to 64
[  476.348000] ADDRCONF(NETDEV_UP): eth1: link is not ready

edavies at bill:/lib/firmware$



From dwmw2 at infradead.org  Fri Aug 31 19:05:29 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 31 Aug 2007 18:05:29 +0100
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <46D84420.8000909@edavies.nildram.co.uk>
References: <46D84420.8000909@edavies.nildram.co.uk>
Message-ID: <1188579929.985.213.camel@pmac.infradead.org>

On Fri, 2007-08-31 at 17:38 +0100, Ed Davies wrote:
> [  401.060000] bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not
> available or load failed.

Did you use bcm43xx-fwcutter to extract firmware from one of the
official drivers, and install it in /lib/firmware? I suspect not.

-- 
dwmw2



From Larry.Finger at lwfinger.net  Fri Aug 31 19:15:39 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 31 Aug 2007 12:15:39 -0500
Subject: RFC bcm43xx: Fix potential race in shutdown of work queses
Message-ID: <46d84cbb.FOFfgaTFNALi9I3F%Larry.Finger@lwfinger.net>

This patch fixes a problem with work queues during shutdown. The bug
seems to be responsible for the boot-time crashes reported in
http://bugzilla.kernel.org/show_bug.cgi?id=8937.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -3174,6 +3174,9 @@ static void bcm43xx_periodic_every1sec(s
 
 static void do_periodic_work(struct bcm43xx_private *bcm)
 {
+	/* keep from rearming periodic work if shutting down */
+	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
+		return;
 	if (bcm->periodic_state % 120 == 0)
 		bcm43xx_periodic_every120sec(bcm);
 	if (bcm->periodic_state % 60 == 0)
@@ -3245,11 +3248,6 @@ static void bcm43xx_periodic_work_handle
 	mutex_unlock(&bcm->mutex);
 }
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
-{
-	cancel_rearming_delayed_work(&bcm->periodic_work);
-}
-
 void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
 {
 	struct delayed_work *work = &bcm->periodic_work;
@@ -3335,9 +3333,14 @@ static void bcm43xx_free_board(struct bc
 {
 	bcm43xx_rng_exit(bcm);
 	bcm43xx_sysfs_unregister(bcm);
-	bcm43xx_periodic_tasks_delete(bcm);
+
+	/* next 2 steps must be unlocked, else they may deadlock */
+	cancel_work_sync(&bcm->restart_work);
+	cancel_delayed_work_sync(&bcm->periodic_work);
 
 	mutex_lock(&(bcm)->mutex);
+	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
+
 	bcm43xx_shutdown_all_wireless_cores(bcm);
 	bcm43xx_pctl_set_crystal(bcm, 0);
 	mutex_unlock(&(bcm)->mutex);
@@ -4030,7 +4033,6 @@ static int bcm43xx_net_stop(struct net_d
 	err = bcm43xx_disable_interrupts_sync(bcm);
 	assert(!err);
 	bcm43xx_free_board(bcm);
-	flush_scheduled_work();
 
 	return 0;
 }
@@ -4164,7 +4166,6 @@ static void bcm43xx_chip_reset(struct wo
 
 	mutex_lock(&(bcm)->mutex);
 	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm43xx_periodic_tasks_delete(bcm);
 		phy = bcm43xx_current_phy(bcm);
 		err = bcm43xx_select_wireless_core(bcm, phy->type);
 		if (!err)
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
@@ -122,7 +122,6 @@ void bcm43xx_wireless_core_reset(struct 
 void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
 void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
 void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
 
 void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
@@ -327,7 +327,6 @@ static ssize_t bcm43xx_attr_phymode_stor
 		goto out;
 	}
 
-	bcm43xx_periodic_tasks_delete(bcm);
 	mutex_lock(&(bcm)->mutex);
 	err = bcm43xx_select_wireless_core(bcm, phytype);
 	if (!err)


From bcm.jw.0708 at edavies.nildram.co.uk  Fri Aug 31 19:25:23 2007
From: bcm.jw.0708 at edavies.nildram.co.uk (Ed Davies)
Date: Fri, 31 Aug 2007 18:25:23 +0100
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <1188579929.985.213.camel@pmac.infradead.org>
References: <46D84420.8000909@edavies.nildram.co.uk>
	<1188579929.985.213.camel@pmac.infradead.org>
Message-ID: <46D84F03.1070205@edavies.nildram.co.uk>

David Woodhouse wrote:
> On Fri, 2007-08-31 at 17:38 +0100, Ed Davies wrote:
>> [  401.060000] bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not
>> available or load failed.
> 
> Did you use bcm43xx-fwcutter to extract firmware from one of the
> official drivers, and install it in /lib/firmware? I suspect not.

Yes, I did use fwcutter.  The snippet you quoted was
part of a sequence where I deliberately renamed one of
the firmware files to show that the firmware was normally
being found OK.

The packaging of fwcutter in Ubuntu (Feisty, at least)
has a problem in that the installation process attempts
to download a driver from a location where it isn't
(or isn't anymore).  The installation process therefore
fails, but the bcm43xx_fwcutter program is installed.

I tried a couple of drivers, finishing up with the
openwrt driver from:

   http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o

and expanded it using fwcutter:

edavies at bill:~/downloads/bcm43xx/openwrt$ bcm43xx-fwcutter wl_apsta-3.130.20.0.o

   filename   :  wl_apsta.o
   version    :  3.130.20.0
   MD5        :  e08665c5c5b66beb9c3b2dd54aa80cb3
   microcodes :  2 4 5 11
   pcms       :  4 5

   microcode  :  2
   revision   :  0x0127
   patchlevel :  0x000e
   date       :  2005-04-18
   time       :  02:36:27

   microcode  :  4
   revision   :  0x0127
   patchlevel :  0x000e
   date       :  2005-04-18
   time       :  02:36:27

   microcode  :  5
   revision   :  0x0127
   patchlevel :  0x000e
   date       :  2005-04-18
   time       :  02:36:27

   microcode  :  11
   revision   :  0x0127
   patchlevel :  0x000e
   date       :  2005-04-18
   time       :  02:36:27

extracting bcm43xx_microcode2.fw ...
extracting bcm43xx_microcode4.fw ...
extracting bcm43xx_microcode5.fw ...
extracting bcm43xx_microcode11.fw ...
extracting bcm43xx_pcm4.fw ...
extracting bcm43xx_pcm5.fw ...
extracting bcm43xx_initval01.fw ...
extracting bcm43xx_initval02.fw ...
extracting bcm43xx_initval03.fw ...
extracting bcm43xx_initval04.fw ...
extracting bcm43xx_initval05.fw ...
extracting bcm43xx_initval06.fw ...
extracting bcm43xx_initval07.fw ...
extracting bcm43xx_initval08.fw ...
extracting bcm43xx_initval09.fw ...
extracting bcm43xx_initval10.fw ...

Resulting in the files I copied to /lib/firmware.  Just to
check:

edavies at bill:~/downloads/bcm43xx/openwrt$ diff -qr . /lib/firmware
Only in /lib/firmware: 2.6.20-15-generic
Only in /lib/firmware: 2.6.20-16-generic
Only in /lib/firmware: 2.6.22-10-generic
Only in .: source
Only in .: wl_apsta-3.130.20.0.o

"source" just contains my note of the web address I downloaded
from.

Regards,

Ed Davies.



From larry.finger at lwfinger.net  Fri Aug 31 19:27:17 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 31 Aug 2007 12:27:17 -0500
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <1188579929.985.213.camel@pmac.infradead.org>
References: <46D84420.8000909@edavies.nildram.co.uk>
	<1188579929.985.213.camel@pmac.infradead.org>
Message-ID: <46D84F75.4000402@lwfinger.net>

David Woodhouse wrote:
> On Fri, 2007-08-31 at 17:38 +0100, Ed Davies wrote:
>> [  401.060000] bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not
>> available or load failed.
> 
> Did you use bcm43xx-fwcutter to extract firmware from one of the
> official drivers, and install it in /lib/firmware? I suspect not.
> 

For Feisty, the firmware needs to be installed in the '/lib/firmware/`uname -r` directory. Note the 
back ticks around the uname command.

Larry



From dwmw2 at infradead.org  Fri Aug 31 19:32:22 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 31 Aug 2007 18:32:22 +0100
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <46D84F03.1070205@edavies.nildram.co.uk>
References: <46D84420.8000909@edavies.nildram.co.uk>
	<1188579929.985.213.camel@pmac.infradead.org>
	<46D84F03.1070205@edavies.nildram.co.uk>
Message-ID: <1188581542.985.215.camel@pmac.infradead.org>

On Fri, 2007-08-31 at 18:25 +0100, Ed Davies wrote:
> Yes, I did use fwcutter.  The snippet you quoted was
> part of a sequence where I deliberately renamed one of
> the firmware files to show that the firmware was normally
> being found OK. 

Oops, so it was. Sorry.

-- 
dwmw2



From mb at bu3sch.de  Fri Aug 31 19:43:16 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 31 Aug 2007 19:43:16 +0200
Subject: RFC bcm43xx: Fix potential race in shutdown of work queses
In-Reply-To: <46d84cbb.FOFfgaTFNALi9I3F%Larry.Finger@lwfinger.net>
References: <46d84cbb.FOFfgaTFNALi9I3F%Larry.Finger@lwfinger.net>
Message-ID: <200708311943.16751.mb@bu3sch.de>

On Friday 31 August 2007, Larry Finger wrote:
> This patch fixes a problem with work queues during shutdown. The bug
> seems to be responsible for the boot-time crashes reported in
> http://bugzilla.kernel.org/show_bug.cgi?id=8937.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> ===================================================================
> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> @@ -3174,6 +3174,9 @@ static void bcm43xx_periodic_every1sec(s
>  
>  static void do_periodic_work(struct bcm43xx_private *bcm)
>  {
> +	/* keep from rearming periodic work if shutting down */
> +	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
> +		return;

I think this should be put at the beginning of bcm43xx_periodic_work_handler()
after the mutex locking.

>  	if (bcm->periodic_state % 120 == 0)
>  		bcm43xx_periodic_every120sec(bcm);
>  	if (bcm->periodic_state % 60 == 0)
> @@ -3245,11 +3248,6 @@ static void bcm43xx_periodic_work_handle
>  	mutex_unlock(&bcm->mutex);
>  }
>  
> -void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
> -{
> -	cancel_rearming_delayed_work(&bcm->periodic_work);
> -}
> -
>  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
>  {
>  	struct delayed_work *work = &bcm->periodic_work;
> @@ -3335,9 +3333,14 @@ static void bcm43xx_free_board(struct bc
>  {
>  	bcm43xx_rng_exit(bcm);
>  	bcm43xx_sysfs_unregister(bcm);
> -	bcm43xx_periodic_tasks_delete(bcm);
> +
> +	/* next 2 steps must be unlocked, else they may deadlock */
> +	cancel_work_sync(&bcm->restart_work);
> +	cancel_delayed_work_sync(&bcm->periodic_work);



>  	mutex_lock(&(bcm)->mutex);
> +	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
> +

This status change must be moved above the cancel calls.

>  	bcm43xx_shutdown_all_wireless_cores(bcm);
>  	bcm43xx_pctl_set_crystal(bcm, 0);
>  	mutex_unlock(&(bcm)->mutex);
> @@ -4030,7 +4033,6 @@ static int bcm43xx_net_stop(struct net_d
>  	err = bcm43xx_disable_interrupts_sync(bcm);
>  	assert(!err);
>  	bcm43xx_free_board(bcm);
> -	flush_scheduled_work();
>  
>  	return 0;
>  }
> @@ -4164,7 +4166,6 @@ static void bcm43xx_chip_reset(struct wo
>  
>  	mutex_lock(&(bcm)->mutex);
>  	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
> -		bcm43xx_periodic_tasks_delete(bcm);

Look at the comment below. That also applies here.

>  		phy = bcm43xx_current_phy(bcm);
>  		err = bcm43xx_select_wireless_core(bcm, phy->type);
>  		if (!err)
> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
> ===================================================================
> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
> @@ -122,7 +122,6 @@ void bcm43xx_wireless_core_reset(struct 
>  void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
>  void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
>  
> -void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
>  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
>  
>  void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> ===================================================================
> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> @@ -327,7 +327,6 @@ static ssize_t bcm43xx_attr_phymode_stor
>  		goto out;
>  	}
>  
> -	bcm43xx_periodic_tasks_delete(bcm);

Well, this is tricky crap code.
This breaks it.
Look at the !err case below. We re-enable pwork there.
We only do it for !err. So when core select failed, we
end up without pwork, which is what we want.
I think it might be OK to simply remove the delete _and_
the setup below, as select core sets status to UNINIT when
it failed. So pwork will bail out early (if you change your
patch above as I suggested).

>  	mutex_lock(&(bcm)->mutex);
>  	err = bcm43xx_select_wireless_core(bcm, phytype);
>  	if (!err)
> 
> 


PS: Yes, this is crap code. :) All these cornercases.


From larry.finger at lwfinger.net  Fri Aug 31 20:05:50 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 31 Aug 2007 13:05:50 -0500
Subject: RFC bcm43xx: Fix potential race in shutdown of work queses
In-Reply-To: <200708311943.16751.mb@bu3sch.de>
References: <46d84cbb.FOFfgaTFNALi9I3F%Larry.Finger@lwfinger.net>
	<200708311943.16751.mb@bu3sch.de>
Message-ID: <46D8587E.9080303@lwfinger.net>

Michael Buesch wrote:
> On Friday 31 August 2007, Larry Finger wrote:
>> This patch fixes a problem with work queues during shutdown. The bug
>> seems to be responsible for the boot-time crashes reported in
>> http://bugzilla.kernel.org/show_bug.cgi?id=8937.
>>
>> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
>> ---
>>
>> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
>> ===================================================================
>> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
>> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
>> @@ -3174,6 +3174,9 @@ static void bcm43xx_periodic_every1sec(s
>>  
>>  static void do_periodic_work(struct bcm43xx_private *bcm)
>>  {
>> +	/* keep from rearming periodic work if shutting down */
>> +	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
>> +		return;
> 
> I think this should be put at the beginning of bcm43xx_periodic_work_handler()
> after the mutex locking.
> 
>>  	if (bcm->periodic_state % 120 == 0)
>>  		bcm43xx_periodic_every120sec(bcm);
>>  	if (bcm->periodic_state % 60 == 0)
>> @@ -3245,11 +3248,6 @@ static void bcm43xx_periodic_work_handle
>>  	mutex_unlock(&bcm->mutex);
>>  }
>>  
>> -void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
>> -{
>> -	cancel_rearming_delayed_work(&bcm->periodic_work);
>> -}
>> -
>>  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
>>  {
>>  	struct delayed_work *work = &bcm->periodic_work;
>> @@ -3335,9 +3333,14 @@ static void bcm43xx_free_board(struct bc
>>  {
>>  	bcm43xx_rng_exit(bcm);
>>  	bcm43xx_sysfs_unregister(bcm);
>> -	bcm43xx_periodic_tasks_delete(bcm);
>> +
>> +	/* next 2 steps must be unlocked, else they may deadlock */
>> +	cancel_work_sync(&bcm->restart_work);
>> +	cancel_delayed_work_sync(&bcm->periodic_work);
> 
> 
> 
>>  	mutex_lock(&(bcm)->mutex);
>> +	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
>> +
> 
> This status change must be moved above the cancel calls.
> 
>>  	bcm43xx_shutdown_all_wireless_cores(bcm);
>>  	bcm43xx_pctl_set_crystal(bcm, 0);
>>  	mutex_unlock(&(bcm)->mutex);
>> @@ -4030,7 +4033,6 @@ static int bcm43xx_net_stop(struct net_d
>>  	err = bcm43xx_disable_interrupts_sync(bcm);
>>  	assert(!err);
>>  	bcm43xx_free_board(bcm);
>> -	flush_scheduled_work();
>>  
>>  	return 0;
>>  }
>> @@ -4164,7 +4166,6 @@ static void bcm43xx_chip_reset(struct wo
>>  
>>  	mutex_lock(&(bcm)->mutex);
>>  	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
>> -		bcm43xx_periodic_tasks_delete(bcm);
> 
> Look at the comment below. That also applies here.
> 
>>  		phy = bcm43xx_current_phy(bcm);
>>  		err = bcm43xx_select_wireless_core(bcm, phy->type);
>>  		if (!err)
>> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
>> ===================================================================
>> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
>> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
>> @@ -122,7 +122,6 @@ void bcm43xx_wireless_core_reset(struct 
>>  void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
>>  void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
>>  
>> -void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
>>  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
>>  
>>  void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
>> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
>> ===================================================================
>> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
>> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
>> @@ -327,7 +327,6 @@ static ssize_t bcm43xx_attr_phymode_stor
>>  		goto out;
>>  	}
>>  
>> -	bcm43xx_periodic_tasks_delete(bcm);
> 
> Well, this is tricky crap code.
> This breaks it.
> Look at the !err case below. We re-enable pwork there.
> We only do it for !err. So when core select failed, we
> end up without pwork, which is what we want.
> I think it might be OK to simply remove the delete _and_
> the setup below, as select core sets status to UNINIT when
> it failed. So pwork will bail out early (if you change your
> patch above as I suggested).
> 
>>  	mutex_lock(&(bcm)->mutex);
>>  	err = bcm43xx_select_wireless_core(bcm, phytype);
>>  	if (!err)
>>
>>
> 
> 
> PS: Yes, this is crap code. :) All these cornercases.
> 

I think I understood your comments. The revised patch is as follows:

Larry

------

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -3197,6 +3197,9 @@ static void bcm43xx_periodic_work_handle
  	unsigned long orig_trans_start = 0;

  	mutex_lock(&bcm->mutex);
+	/* keep from doing and rearming periodic work if shutting down */
+	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
+		goto unlock_mutex;
  	if (unlikely(bcm->periodic_state % 60 == 0)) {
  		/* Periodic work will take a long time, so we want it to
  		 * be preemtible.
@@ -3242,14 +3245,10 @@ static void bcm43xx_periodic_work_handle
  	mmiowb();
  	bcm->periodic_state++;
  	spin_unlock_irqrestore(&bcm->irq_lock, flags);
+unlock_mutex:
  	mutex_unlock(&bcm->mutex);
  }

-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
-{
-	cancel_rearming_delayed_work(&bcm->periodic_work);
-}
-
  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
  {
  	struct delayed_work *work = &bcm->periodic_work;
@@ -3335,7 +3334,15 @@ static void bcm43xx_free_board(struct bc
  {
  	bcm43xx_rng_exit(bcm);
  	bcm43xx_sysfs_unregister(bcm);
-	bcm43xx_periodic_tasks_delete(bcm);
+
+	mutex_lock(&(bcm)->mutex);
+	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
+	mutex_unlock(&(bcm)->mutex);
+
+	/* next 2 steps must be unlocked, else they may deadlock */
+	cancel_work_sync(&bcm->restart_work);
+	cancel_delayed_work_sync(&bcm->periodic_work);
+

  	mutex_lock(&(bcm)->mutex);
  	bcm43xx_shutdown_all_wireless_cores(bcm);
@@ -4030,7 +4037,6 @@ static int bcm43xx_net_stop(struct net_d
  	err = bcm43xx_disable_interrupts_sync(bcm);
  	assert(!err);
  	bcm43xx_free_board(bcm);
-	flush_scheduled_work();

  	return 0;
  }
@@ -4164,11 +4170,8 @@ static void bcm43xx_chip_reset(struct wo

  	mutex_lock(&(bcm)->mutex);
  	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm43xx_periodic_tasks_delete(bcm);
  		phy = bcm43xx_current_phy(bcm);
  		err = bcm43xx_select_wireless_core(bcm, phy->type);
-		if (!err)
-			bcm43xx_periodic_tasks_setup(bcm);
  	}
  	mutex_unlock(&(bcm)->mutex);

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
@@ -122,7 +122,6 @@ void bcm43xx_wireless_core_reset(struct
  void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
  void bcm43xx_mac_enable(struct bcm43xx_private *bcm);

-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);

  void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
@@ -327,11 +327,8 @@ static ssize_t bcm43xx_attr_phymode_stor
  		goto out;
  	}
  -	bcm43xx_periodic_tasks_delete(bcm);
  	mutex_lock(&(bcm)->mutex);
  	err = bcm43xx_select_wireless_core(bcm, phytype);
-	if (!err)
-		bcm43xx_periodic_tasks_setup(bcm);
  	mutex_unlock(&(bcm)->mutex);
  	if (err == -ESRCH)
  		err = -ENODEV;




From mb at bu3sch.de  Fri Aug 31 20:29:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 31 Aug 2007 20:29:58 +0200
Subject: RFC bcm43xx: Fix potential race in shutdown of work queses
In-Reply-To: <46D8587E.9080303@lwfinger.net>
References: <46d84cbb.FOFfgaTFNALi9I3F%Larry.Finger@lwfinger.net>
	<200708311943.16751.mb@bu3sch.de> <46D8587E.9080303@lwfinger.net>
Message-ID: <200708312029.58948.mb@bu3sch.de>

On Friday 31 August 2007, Larry Finger wrote:
> -void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
> -{
> -	cancel_rearming_delayed_work(&bcm->periodic_work);
> -}
> -
>   void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
>   {
>   	struct delayed_work *work = &bcm->periodic_work;
> @@ -3335,7 +3334,15 @@ static void bcm43xx_free_board(struct bc
>   {
>   	bcm43xx_rng_exit(bcm);
>   	bcm43xx_sysfs_unregister(bcm);
> -	bcm43xx_periodic_tasks_delete(bcm);
> +
> +	mutex_lock(&(bcm)->mutex);
> +	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
> +	mutex_unlock(&(bcm)->mutex);

lock might not be needed, but I think it doesn't hurt.

You get my ACK.

PS: I hate this damn berlios list so much. It always randomly strips
some CCs.


From bcm.jw.0708 at edavies.nildram.co.uk  Fri Aug 31 20:41:53 2007
From: bcm.jw.0708 at edavies.nildram.co.uk (Ed Davies)
Date: Fri, 31 Aug 2007 19:41:53 +0100
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <46D84F75.4000402@lwfinger.net>
References: <46D84420.8000909@edavies.nildram.co.uk>
	<1188579929.985.213.camel@pmac.infradead.org>
	<46D84F75.4000402@lwfinger.net>
Message-ID: <46D860F1.5040809@edavies.nildram.co.uk>

Larry Finger wrote:
> For Feisty, the firmware needs to be installed in the '/lib/firmware/`uname -r` directory. Note the 
> back ticks around the uname command.

Thanks.

I moved the bcm* files from /lib/firmware to /lib/firmware/2.6.22-10-generic
(the Gutsy kernel) and tried again with no effect.

I then copied them to the Feisty directory, /lib/firmware/2.6.20-16-generic,
and rebooted to that kernel.  Also no effect:

> edavies at bill:~$ uname -r
> 2.6.20-16-generic

> edavies at bill:~$ ls /lib/firmware
> 2.6.20-15-generic  2.6.20-16-generic  2.6.22-10-generic

> edavies at bill:~$ ls /lib/firmware/2.6.20-16-generic/
> acx                                 bcm43xx_initval04.fw        ipw2100-1.3-p.fw
> aic94xx-seq.fw                      bcm43xx_initval05.fw        ipw2200-bss.fw
> atmel_at76c502_3com.bin             bcm43xx_initval06.fw        ipw2200-ibss.fw
> atmel_at76c502_3com-wpa.bin         bcm43xx_initval07.fw        ipw2200-sniffer.fw
> atmel_at76c502.bin                  bcm43xx_initval08.fw        ipw3945.ucode
> atmel_at76c502d.bin                 bcm43xx_initval09.fw        isl3877
> atmel_at76c502d-wpa.bin             bcm43xx_initval10.fw        isl3886
> atmel_at76c502e.bin                 bcm43xx_microcode11.fw      isl3887usb_bare
> atmel_at76c502e-wpa.bin             bcm43xx_microcode2.fw       isl3890
> atmel_at76c502-wpa.bin              bcm43xx_microcode4.fw       isl3890usb
> atmel_at76c503-i3861.bin            bcm43xx_microcode5.fw       iwlwifi-3945.ucode
> atmel_at76c503-i3863.bin            bcm43xx_pcm4.fw             ql2100_fw.bin
> atmel_at76c503-rfmd-0.90.2-140.bin  bcm43xx_pcm5.fw             ql2200_fw.bin
> atmel_at76c503-rfmd-acc.bin         dvb-fe-or51132-qam.fw       ql2300_fw.bin
> atmel_at76c503-rfmd.bin             dvb-fe-or51132-vsb.fw       ql2322_fw.bin
> atmel_at76c504_2958-wpa.bin         dvb-fe-or51211.fw           ql2400_fw.bin
> atmel_at76c504a_2958-wpa.bin        dvb-ttpci-01.fw             rt2561.bin
> atmel_at76c504.bin                  dvb-usb-avertv-a800-02.fw   rt2561s.bin
> atmel_at76c504c-wpa.bin             dvb-usb-dibusb-5.0.0.11.fw  rt2661.bin
> atmel_at76c505a-rfmd2958.bin        dvb-usb-dibusb-6.0.0.8.fw   rt73.bin
> atmel_at76c505-rfmd2958.bin         dvb-usb-dtt200u-01.fw       v4l-cx2341x-dec.fw
> atmel_at76c505-rfmd.bin             dvb-usb-umt-010-02.fw       v4l-cx2341x-enc.fw
> atmel_at76c506.bin                  dvb-usb-vp702x-01.fw        v4l-cx2341x-init.mpg
> atmel_at76c506-wpa.bin              dvb-usb-vp7045-01.fw        v4l-cx25840.fw
> bcm43xx_initval01.fw                dvb-usb-wt220u-01.fw        v4l-pvrusb2-24xxx-01.fw
> bcm43xx_initval02.fw                ipw2100-1.3.fw              v4l-pvrusb2-29xxx-01.fw
> bcm43xx_initval03.fw                ipw2100-1.3-i.fw            zd1211

> edavies at bill:~$ sudo modprobe -r bcm43xx
> Password:

> edavies at bill:~$ sudo modprobe bcm43xx

> edavies at bill:~$ sudo ifconfig eth1 up

> edavies at bill:~$ dmesg | tail
> [  135.956000] ACPI: PCI interrupt for device 0000:10:00.0 disabled
> [  135.972000] ieee80211_crypt: unregistered algorithm 'NULL'
> [  152.716000] ieee80211_crypt: registered algorithm 'NULL'
> [  152.720000] ieee80211: 802.11 data/management/control stack, git-1.1.13
> [  152.720000] ieee80211: Copyright (C) 2004-2005 Intel Corporation <jketreno at linux.intel.com>
> [  152.732000] bcm43xx driver
> [  152.736000] ACPI: PCI Interrupt 0000:10:00.0[A] -> GSI 17 (level, low) -> IRQ 17
> [  152.736000] PCI: Setting latency timer of device 0000:10:00.0 to 64
> [  156.748000] usb 1-2: reset low speed USB device using uhci_hcd and address 3
> [  162.772000] ADDRCONF(NETDEV_UP): eth1: link is not ready

Just to be sure that the driver really was finding the firmware there,
I then played the file renaming trick again:

> edavies at bill:~$ cd /lib/firmware/2.6.20-16-generic/

> edavies at bill:/lib/firmware/2.6.20-16-generic$ sudo mv bcm43xx_
> bcm43xx_initval01.fw    bcm43xx_initval05.fw    bcm43xx_initval09.fw    bcm43xx_microcode4.fw   
> bcm43xx_initval02.fw    bcm43xx_initval06.fw    bcm43xx_initval10.fw    bcm43xx_microcode5.fw   
> bcm43xx_initval03.fw    bcm43xx_initval07.fw    bcm43xx_microcode11.fw  bcm43xx_pcm4.fw         
> bcm43xx_initval04.fw    bcm43xx_initval08.fw    bcm43xx_microcode2.fw   bcm43xx_pcm5.fw         

> edavies at bill:/lib/firmware/2.6.20-16-generic$ sudo mv bcm43xx_microcode5.fw bcm43xx_microcode5.fwXXX

> edavies at bill:/lib/firmware/2.6.20-16-generic$ sudo modprobe -r bcm43xx

> edavies at bill:/lib/firmware/2.6.20-16-generic$ sudo modprobe -v bcm43xx
> insmod /lib/modules/2.6.20-16-generic/kernel/net/ieee80211/ieee80211_crypt.ko 
> insmod /lib/modules/2.6.20-16-generic/kernel/net/ieee80211/ieee80211.ko 
> insmod /lib/modules/2.6.20-16-generic/kernel/net/ieee80211/softmac/ieee80211softmac.ko 
> insmod /lib/modules/2.6.20-16-generic/kernel/drivers/net/wireless/bcm43xx/bcm43xx.ko 

> edavies at bill:/lib/firmware/2.6.20-16-generic$ dmesg | tail
> [  708.444000] usb 1-2: reset low speed USB device using uhci_hcd and address 3
> [  710.876000] ACPI: PCI interrupt for device 0000:10:00.0 disabled
> [  710.880000] ieee80211_crypt: unregistered algorithm 'NULL'
> [  723.884000] usb 1-2: reset low speed USB device using uhci_hcd and address 3
> [  727.380000] ieee80211_crypt: registered algorithm 'NULL'
> [  727.380000] ieee80211: 802.11 data/management/control stack, git-1.1.13
> [  727.380000] ieee80211: Copyright (C) 2004-2005 Intel Corporation <jketreno at linux.intel.com>
> [  727.388000] bcm43xx driver
> [  727.388000] ACPI: PCI Interrupt 0000:10:00.0[A] -> GSI 17 (level, low) -> IRQ 17
> [  727.388000] PCI: Setting latency timer of device 0000:10:00.0 to 64

> edavies at bill:/lib/firmware/2.6.20-16-generic$ sudo ifconfig eth1 up
> SIOCSIFFLAGS: No such file or directory

> edavies at bill:/lib/firmware/2.6.20-16-generic$ dmesg | tail
> [  710.880000] ieee80211_crypt: unregistered algorithm 'NULL'
> [  723.884000] usb 1-2: reset low speed USB device using uhci_hcd and address 3
> [  727.380000] ieee80211_crypt: registered algorithm 'NULL'
> [  727.380000] ieee80211: 802.11 data/management/control stack, git-1.1.13
> [  727.380000] ieee80211: Copyright (C) 2004-2005 Intel Corporation <jketreno at linux.intel.com>
> [  727.388000] bcm43xx driver
> [  727.388000] ACPI: PCI Interrupt 0000:10:00.0[A] -> GSI 17 (level, low) -> IRQ 17
> [  727.388000] PCI: Setting latency timer of device 0000:10:00.0 to 64
> [  763.836000] usb 1-2: reset low speed USB device using uhci_hcd and address 3
> [  768.012000] bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load failed.
> edavies at bill:/lib/firmware/2.6.20-16-generic$ 

Seems it is.

Thanks for your help so far.  Any other ideas?

Ed.



From larry.finger at lwfinger.net  Fri Aug 31 21:12:56 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 31 Aug 2007 14:12:56 -0500
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <46D860F1.5040809@edavies.nildram.co.uk>
References: <46D84420.8000909@edavies.nildram.co.uk>
	<1188579929.985.213.camel@pmac.infradead.org>
	<46D84F75.4000402@lwfinger.net>
	<46D860F1.5040809@edavies.nildram.co.uk>
Message-ID: <46D86838.2050101@lwfinger.net>

Ed Davies wrote:
> 
> Seems it is.
> 
> Thanks for your help so far.  Any other ideas?

/start_rant

It is pretty stupid of Ubuntu to move the firmware into this kind of folder. Do they expect the 
firmware to change the same as modules? If openSUSE did this, I would have to be unpacking or 
copying my firmware several times a day. I have already run 3 new kernels today.

They also have not done us any favors by turning off the debug messages from bcm43xx.

/end_rant

If I followed your renaming, it certainly looks as if the firmware is being properly loaded. The 
debug messages would have told us for sure. The next step is to run the four commands 'ifconfig eth1 
up', 'iwconfig', 'ifconfig', and 'iwlist scan' and send us the output that they produce.

Does your laptop have a wireless on/off switch or button? Is it on, and is the wireless enabled 
light on?

Larry





From Larry.Finger at lwfinger.net  Fri Aug 31 21:23:34 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 31 Aug 2007 14:23:34 -0500
Subject: [PATCH] bcm43xx: Change radio hardware switch status printk from
	debug to regular
Message-ID: <46d86ab6.O689o6H7QjCOyAyx%Larry.Finger@lwfinger.net>

Some distros ship bcm43xx with debugging printout disabled. For those
BCM43xx devices with radio on/off switches, this makes it impossible
to know if the radio is on or off. This patch changes a pair of debug
printk's into ordinary printk's.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

I know this is late in the cycle, but I hope this can make it into 2.6.23.

Thanks,

Larry

 bcm43xx_main.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -2394,7 +2394,7 @@ static int bcm43xx_chip_init(struct bcm4
 		goto err_gpio_cleanup;
 	bcm43xx_radio_turn_on(bcm);
 	bcm->radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
-	dprintk(KERN_INFO PFX "Radio %s by hardware\n",
+	printk(KERN_INFO PFX "Radio %s by hardware\n",
 		(bcm->radio_hw_enable == 0) ? "disabled" : "enabled");
 
 	bcm43xx_write16(bcm, 0x03E6, 0x0000);
@@ -3143,7 +3143,7 @@ static void bcm43xx_periodic_every1sec(s
 	radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
 	if (unlikely(bcm->radio_hw_enable != radio_hw_enable)) {
 		bcm->radio_hw_enable = radio_hw_enable;
-		dprintk(KERN_INFO PFX "Radio hardware status changed to %s\n",
+		printk(KERN_INFO PFX "Radio hardware status changed to %s\n",
 		       (radio_hw_enable == 0) ? "disabled" : "enabled");
 		bcm43xx_leds_update(bcm, 0);
 	}


From richie at coderworld.net  Fri Aug 31 21:31:23 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Fri, 31 Aug 2007 21:31:23 +0200
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <46D84F75.4000402@lwfinger.net>
References: <46D84420.8000909@edavies.nildram.co.uk>	<1188579929.985.213.camel@pmac.infradead.org>
	<46D84F75.4000402@lwfinger.net>
Message-ID: <46D86C8B.5020709@coderworld.net>

Larry Finger skrev:
> David Woodhouse wrote:
>> On Fri, 2007-08-31 at 17:38 +0100, Ed Davies wrote:
>>> [  401.060000] bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not
>>> available or load failed.
>> Did you use bcm43xx-fwcutter to extract firmware from one of the
>> official drivers, and install it in /lib/firmware? I suspect not.
>>
> 
> For Feisty, the firmware needs to be installed in the '/lib/firmware/`uname -r` directory. Note the 
> back ticks around the uname command.
> 
> Larry
> 
I'm using feisty (upgraded from edgy), and have never had any problems 
with firmware being directly under /lib/firmware. Tested with 
2.6.20-15-generic and a whole bunch of custom kernels built with make-kpkg.


From larry.finger at lwfinger.net  Fri Aug 31 21:36:00 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 31 Aug 2007 14:36:00 -0500
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <46D86C8B.5020709@coderworld.net>
References: <46D84420.8000909@edavies.nildram.co.uk>	<1188579929.985.213.camel@pmac.infradead.org>	<46D84F75.4000402@lwfinger.net>
	<46D86C8B.5020709@coderworld.net>
Message-ID: <46D86DA0.30105@lwfinger.net>

Richard Jonsson wrote:
> Larry Finger skrev:
>> David Woodhouse wrote:
>>> On Fri, 2007-08-31 at 17:38 +0100, Ed Davies wrote:
>>>> [  401.060000] bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not
>>>> available or load failed.
>>> Did you use bcm43xx-fwcutter to extract firmware from one of the
>>> official drivers, and install it in /lib/firmware? I suspect not.
>>>
>> For Feisty, the firmware needs to be installed in the '/lib/firmware/`uname -r` directory. Note the 
>> back ticks around the uname command.
>>
>> Larry
>>
> I'm using feisty (upgraded from edgy), and have never had any problems 
> with firmware being directly under /lib/firmware. Tested with 
> 2.6.20-15-generic and a whole bunch of custom kernels built with make-kpkg.

Maybe it is the upgrade, but the OP certainly needed to move his firmware. Be prepared to have to do 
this some day.

Larry


From Larry.Finger at lwfinger.net  Fri Aug 31 21:38:31 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 31 Aug 2007 14:38:31 -0500
Subject: [PATCH] b43legacy: Change radio hardware switch printk from debug to
	regular
Message-ID: <46d86e37.3WD2x/BxsTzY/pZ3%Larry.Finger@lwfinger.net>

This patch changes the printouts of the initial state of the
radio on/off switch from debug to normal mode. The change is
needed because some distros have debug disabled in their precompiled
drivers, which complicates the initial troubleshooting.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
CC: Michael Buesch <mb at bu3sch.de>
---

 main.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -2046,7 +2046,7 @@ static int b43legacy_chip_init(struct b4
 		goto err_gpio_cleanup;
 	b43legacy_radio_turn_on(dev);
 	dev->radio_hw_enable = b43legacy_is_hw_radio_enabled(dev);
-	b43legacydbg(dev->wl, "Radio %s by hardware\n",
+	b43legacyinfo(dev->wl, "Radio %s by hardware\n",
 	       (dev->radio_hw_enable == 0) ? "disabled" : "enabled");
 
 	b43legacy_write16(dev, 0x03E6, 0x0000);
@@ -2175,7 +2175,7 @@ static void b43legacy_periodic_every1sec
 	radio_hw_enable = b43legacy_is_hw_radio_enabled(dev);
 	if (unlikely(dev->radio_hw_enable != radio_hw_enable)) {
 		dev->radio_hw_enable = radio_hw_enable;
-		b43legacydbg(dev->wl, "Radio hardware status changed to %s\n",
+		b43legacyinfo(dev->wl, "Radio hardware status changed to %s\n",
 		       (radio_hw_enable == 0) ? "disabled" : "enabled");
 		b43legacy_leds_update(dev, 0);
 	}


From bcm.jw.0708 at edavies.nildram.co.uk  Fri Aug 31 22:34:00 2007
From: bcm.jw.0708 at edavies.nildram.co.uk (Ed Davies)
Date: Fri, 31 Aug 2007 21:34:00 +0100
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <46D86838.2050101@lwfinger.net>
References: <46D84420.8000909@edavies.nildram.co.uk>
	<1188579929.985.213.camel@pmac.infradead.org>
	<46D84F75.4000402@lwfinger.net>
	<46D860F1.5040809@edavies.nildram.co.uk>
	<46D86838.2050101@lwfinger.net>
Message-ID: <46D87B38.6080809@edavies.nildram.co.uk>

Larry Finger wrote:
> They also have not done us any favors by turning off the debug messages from bcm43xx.

Indeed, a few more debug messages would help a lot.  I see
you've just submitted a patch to give some more even when
debug is switched off.  That seems like a really good idea.

> .... 
> Does your laptop have a wireless on/off switch or button? Is it on, and is the wireless enabled 
> light on?

It has both, combined.  Unfortunately it's a push on/push off type
button and you can't see if it's on or off.  I just pushed it
and the light did, indeed, come on and I can now iwlist scan to
see my router and can ping it with the wired network unplugged.

I'm not sure if I should feel really stupid for not trying this
before.  I did try when I started playing with this about a fort-
night ago but in all the messing around it went out of my mind,
particularly as I wasn't sure if it was a real hardware switch
or something that got interpretted by Windows to do the equivalent
of ifconfig up/down or whatever.

It's all not very obvious as you have to have done both an
ifconfig eth1 up and pressed the button to the right state
before you get a blue light.

Anyway, seems to be all working at the driver level.  Thanks
for your help.

Regards,

Ed Davies.




From larry.finger at lwfinger.net  Fri Aug 31 22:56:03 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 31 Aug 2007 15:56:03 -0500
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <46D87B38.6080809@edavies.nildram.co.uk>
References: <46D84420.8000909@edavies.nildram.co.uk>
	<1188579929.985.213.camel@pmac.infradead.org>
	<46D84F75.4000402@lwfinger.net>
	<46D860F1.5040809@edavies.nildram.co.uk>
	<46D86838.2050101@lwfinger.net>
	<46D87B38.6080809@edavies.nildram.co.uk>
Message-ID: <46D88063.4010707@lwfinger.net>

Ed Davies wrote:
> 
> It has both, combined.  Unfortunately it's a push on/push off type
> button and you can't see if it's on or off.  I just pushed it
> and the light did, indeed, come on and I can now iwlist scan to
> see my router and can ping it with the wired network unplugged.
> 
> I'm not sure if I should feel really stupid for not trying this
> before.  I did try when I started playing with this about a fort-
> night ago but in all the messing around it went out of my mind,
> particularly as I wasn't sure if it was a real hardware switch
> or something that got interpretted by Windows to do the equivalent
> of ifconfig up/down or whatever.
> 
> It's all not very obvious as you have to have done both an
> ifconfig eth1 up and pressed the button to the right state
> before you get a blue light.

Software can read the state of that switch, but not change it. That is why you have to turn it on. 
The light will be on if the switch is on, and the interface is up. Both steps must be completed.

I'm glad it is working now.

Larry


From identd_ at hotmail.com  Fri Aug 31 22:57:53 2007
From: identd_ at hotmail.com (David Ellingsworth)
Date: Fri, 31 Aug 2007 16:57:53 -0400
Subject: b43legacy woes
Message-ID: <BAY128-W312E506592CDC1EF65AF0C86CE0@phx.gbl>


I've been using the b43legacy driver since it was first posted to this list. The driver has been relatively stable, but my wireless connection has not. In an environment with approximately 26 wireless access points, I experience frequent disconnects and reconnects with the rate stuck at 1Mb/s. The ranges for signal and noise reported under these conditions were (-53db, -59db) and (-93db, -89db) respectively, with an average difference between the two around 20db. The Windows driver under these conditions quickly scaled to 54Mb/s and maintained a connection. In an environment with a single AP, the b43legacy driver performs very similar to the results above where the rate is limited at 1Mb/s and the Windows driver scales significantly higher.

Here is the output of a few common commands:

$lspci -n -v
00:09.0 0280: 14e4:4320 (rev 02)
        Subsystem: 0e11:00e7
        Flags: bus master, fast devsel, latency 64, IRQ 10
        Memory at d0000000 (32-bit, non-prefetchable) [size=8K]
        Capabilities: [40] Power Management version 2

$dmesg | grep ssb
ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x02, vendor 0x4243)
ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x04, vendor 0x4243)
ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x01, vendor 0x4243)
ssb: Core 3 found: V90 (cc 0x807, rev 0x01, vendor 0x4243)
ssb: Core 4 found: PCI (cc 0x804, rev 0x07, vendor 0x4243)
ssb: Core 5 found: IEEE 802.11 (cc 0x812, rev 0x04, vendor 0x4243)
ssb: Ignoring additional 802.11 core
ssb: Sonics Silicon Backplane found on PCI device 0000:00:09.0

$dmesg | grep b43legacy
b43legacy-phy0: Broadcom 4306 WLAN found
b43legacy-phy0 debug: Found PHY: Analog 1, Type 2, Revision 1
b43legacy-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
b43legacy-phy0 debug: Radio turned off
b43legacy-phy0 debug: Adding Interface type 2
b43legacy-phy0 debug: Loading firmware version 0x127, patch level 14 (2005-04-18 02:36:27)
b43legacy-phy0 debug: Radio turned on
b43legacy-phy0 debug: Radio enabled by hardware
b43legacy-phy0 debug: Chip initialized
b43legacy-phy0 debug: 30-bit DMA initialized
b43legacy-phy0 debug: Wireless interface started

$uname -r
2.6.23-rc4

$cat wpa_supplicant.conf
ctrl_interface=/var/run/wpa_supplicant
ctrl_interface_group=20
update_config=1

network={
        ssid="my_ssid"
        scan_ssid=1
        key_mgmt=IEEE8021X
        auth_alg=OPEN
        eap=PEAP
        identity="username"
        password="password"
}

Regards,

David Ellingsworth
_________________________________________________________________
Explore the seven wonders of the world
http://search.msn.com/results.aspx?q=7+wonders+world&mkt=en-US&form=QBRE

