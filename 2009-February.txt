From pietia.gr at gmail.com  Sun Feb  1 00:51:54 2009
From: pietia.gr at gmail.com (pietia)
Date: Sun, 01 Feb 2009 00:51:54 +0100
Subject: [PATCH] b43: Add LP 2062 radio init
In-Reply-To: <200901311934.53766.mb@bu3sch.de>
References: <200901311934.53766.mb@bu3sch.de>
Message-ID: <4984E41A.3030406@gmail.com>

Michael Buesch pisze:
> This adds initialization code for the 2062 radio.
>
> Signed-off-by: Michael Buesch <mb at bu3sch.de>
>
> ---
>
> Index: wireless-testing/drivers/net/wireless/b43/phy_lp.c
> ===================================================================
> --- wireless-testing.orig/drivers/net/wireless/b43/phy_lp.c	2009-01-31 17:19:22.000000000 +0100
> +++ wireless-testing/drivers/net/wireless/b43/phy_lp.c	2009-01-31 19:24:28.000000000 +0100
> @@ -91,7 +91,7 @@ static void lpphy_baseband_rev2plus_init
>  	b43_phy_set(dev, B43_PHY_OFDM(0x10A), 0x1);
>  	b43_phy_maskset(dev, B43_LPPHY_CCKLMSSTEPSIZE, 0xFF01, 0x10);
>  	b43_phy_maskset(dev, B43_PHY_OFDM(0xDF), 0xFF00, 0xF4);
> -	b43_phy_maskset(dev, B43_PHY_OFDM(0xDF), 0x00FF, 0xF100);//FIXME specs are different
> +	b43_phy_maskset(dev, B43_PHY_OFDM(0xDF), 0x00FF, 0xF100);
>  	b43_phy_write(dev, B43_LPPHY_CLIPTHRESH, 0x48);
>  	b43_phy_maskset(dev, B43_LPPHY_HIGAINDB, 0xFF00, 0x46);
>  	b43_phy_maskset(dev, B43_PHY_OFDM(0xE4), 0xFF00, 0x10);
> @@ -155,11 +155,114 @@ static void lpphy_baseband_init(struct b
>  		lpphy_baseband_rev0_1_init(dev);
>  }
>  
> -static void lpphy_radio_init(struct b43_wldev *dev)
> +struct b2062_freqdata {
> +	u16 freq;
> +	u8 data[6];
> +};
> +
> +/* Initialize the 2062 radio. */
> +static void lpphy_2062_init(struct b43_wldev *dev)
> +{
> +	u32 crystalfreq, pdiv, tmp, ref;
> +	unsigned int i;
> +	const struct b2062_freqdata *fd = NULL;
> +
> +	static const struct b2062_freqdata freqdata_tab[] = {
> +		{ .freq = 12000, .data[0] =  6, .data[1] =  6, .data[2] =  6,
> +				 .data[3] =  6, .data[4] = 10, .data[5] =  6, },
> +		{ .freq = 13000, .data[0] =  4, .data[1] =  4, .data[2] =  4,
> +				 .data[3] =  4, .data[4] = 11, .data[5] =  7, },
> +		{ .freq = 14400, .data[0] =  3, .data[1] =  3, .data[2] =  3,
> +				 .data[3] =  3, .data[4] = 12, .data[5] =  7, },
> +		{ .freq = 16200, .data[0] =  3, .data[1] =  3, .data[2] =  3,
> +				 .data[3] =  3, .data[4] = 13, .data[5] =  8, },
> +		{ .freq = 18000, .data[0] =  2, .data[1] =  2, .data[2] =  2,
> +				 .data[3] =  2, .data[4] = 14, .data[5] =  8, },
> +		{ .freq = 19200, .data[0] =  1, .data[1] =  1, .data[2] =  1,
> +				 .data[3] =  1, .data[4] = 14, .data[5] =  9, },
> +	};
> +
> +	b2062_upload_init_table(dev);
> +
> +	b43_radio_write(dev, B2062_N_TX_CTL3, 0);
> +	b43_radio_write(dev, B2062_N_TX_CTL4, 0);
> +	b43_radio_write(dev, B2062_N_TX_CTL5, 0);
> +	b43_radio_write(dev, B2062_N_PDN_CTL0, 0x40);
> +	b43_radio_write(dev, B2062_N_PDN_CTL0, 0);
> +	b43_radio_write(dev, B2062_N_CALIB_TS, 0x10);
> +	b43_radio_write(dev, B2062_N_CALIB_TS, 0);
> +	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
> +		b43_radio_set(dev, B2062_N_TSSI_CTL0, 0x1);
> +	else
> +		b43_radio_mask(dev, B2062_N_TSSI_CTL0, ~0x1);
> +
> +	crystalfreq = 0;//FIXME
> +
> +	if (crystalfreq >= 30000000) {
> +		pdiv = 1;
> +		b43_radio_mask(dev, B2062_S_RFPLL_CTL1, 0xFFFB);
> +	} else {
> +		pdiv = 2;
> +		b43_radio_set(dev, B2062_S_RFPLL_CTL1, 0x4);
> +	}
> +
> +	tmp = (800000000 * pdiv + crystalfreq) / (32000000 * pdiv);
> +	tmp = (tmp - 1) & 0xFF;
> +	b43_radio_write(dev, B2062_S_RFPLL_CTL18, tmp);
> +
> +	tmp = (2 * crystalfreq + 1000000 * pdiv) / (2000000 * pdiv);
> +	tmp = ((tmp & 0xFF) - 1) & 0xFFFF;
> +	b43_radio_write(dev, B2062_S_RFPLL_CTL19, tmp);
> +
> +	ref = (1000 * pdiv + 2 * crystalfreq) / (2000 * pdiv);
> +	ref &= 0xFFFF;
> +	for (i = 0; i < ARRAY_SIZE(freqdata_tab); i++) {
> +		if (ref < freqdata_tab[i].freq) {
> +			fd = &freqdata_tab[i];
> +			break;
> +		}
> +	}
> +	if (B43_WARN_ON(!fd))
> +		return;
> +
> +	b43_radio_write(dev, B2062_S_RFPLL_CTL8,
> +			((u16)(fd->data[1]) << 4) | fd->data[0]);
> +	b43_radio_write(dev, B2062_S_RFPLL_CTL9,
> +			((u16)(fd->data[3]) << 4) | fd->data[2]);//FIXME specs are different
> +	b43_radio_write(dev, B2062_S_RFPLL_CTL10, fd->data[4]);
> +	b43_radio_write(dev, B2062_S_RFPLL_CTL11, fd->data[5]);
> +}
> +
> +/* Initialize the 2063 radio. */
> +static void lpphy_2063_init(struct b43_wldev *dev)
>  {
>  	//TODO
>  }
>  
> +static void lpphy_sync_stx(struct b43_wldev *dev)
> +{
> +	//TODO
> +}
> +
> +static void lpphy_radio_init(struct b43_wldev *dev)
> +{
> +	/* The radio is attached through the 4wire bus. */
> +	b43_phy_set(dev, B43_LPPHY_FOURWIRE_CTL, 0x2);
> +	udelay(1);
> +	b43_phy_mask(dev, B43_LPPHY_FOURWIRE_CTL, 0xFFFD);
> +	udelay(1);
> +
> +	if (dev->phy.rev < 2) {
> +		lpphy_2062_init(dev);
> +	} else {
> +		lpphy_2063_init(dev);
> +		lpphy_sync_stx(dev);
> +		b43_phy_write(dev, B43_PHY_OFDM(0xF0), 0x5F80);
> +		b43_phy_write(dev, B43_PHY_OFDM(0xF1), 0);
> +		//TODO Do something on the backplane
> +	}
> +}
> +
>  static int b43_lpphy_op_init(struct b43_wldev *dev)
>  {
>  	/* TODO: band SPROM */
> @@ -222,7 +325,9 @@ static int b43_lpphy_op_switch_channel(s
>  
>  static unsigned int b43_lpphy_op_get_default_chan(struct b43_wldev *dev)
>  {
> -	return 1; /* Default to channel 1 */
> +	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
> +		return 1;
> +	return 36;
>  }
>  
>  static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
> Index: wireless-testing/drivers/net/wireless/b43/tables_lpphy.c
> ===================================================================
> --- wireless-testing.orig/drivers/net/wireless/b43/tables_lpphy.c	2009-01-31 17:32:13.000000000 +0100
> +++ wireless-testing/drivers/net/wireless/b43/tables_lpphy.c	2009-01-31 18:45:04.000000000 +0100
> @@ -28,6 +28,250 @@
>  #include "phy_lp.h"
>  
>  
> +/* Entry of the 2062 radio init table */
> +struct b2062_init_tab_entry {
> +	u16 offset;
> +	u16 value_a;
> +	u16 value_g;
> +	u8 flags;
> +};
> +#define B2062_FLAG_A	0x01 /* Flag: Init in A mode */
> +#define B2062_FLAG_G	0x02 /* Flag: Init in G mode */
> +
> +static const struct b2062_init_tab_entry b2062_init_tab[] = {
> +	/* { .offset = B2062_N_COMM1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = 0x0001, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_N_COMM4, .value_a = 0x0001, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_N_COMM5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM7, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM8, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM9, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM10, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM11, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM12, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM13, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM14, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_COMM15, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_PDN_CTL0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_N_PDN_CTL1, .value_a = 0x0000, .value_g = 0x00CA, .flags = B2062_FLAG_G, },
> +	/* { .offset = B2062_N_PDN_CTL2, .value_a = 0x0018, .value_g = 0x0018, .flags = 0, }, */
> +	{ .offset = B2062_N_PDN_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_N_PDN_CTL4, .value_a = 0x0015, .value_g = 0x002A, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_N_GEN_CTL0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_IQ_CALIB, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
> +	{ .offset = B2062_N_LGENC, .value_a = 0x00DB, .value_g = 0x00FF, .flags = B2062_FLAG_A, },
> +	/* { .offset = B2062_N_LGENA_LPF, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
> +	/* { .offset = B2062_N_LGENA_BIAS0, .value_a = 0x0041, .value_g = 0x0041, .flags = 0, }, */
> +	/* { .offset = B2062_N_LGNEA_BIAS1, .value_a = 0x0002, .value_g = 0x0002, .flags = 0, }, */
> +	/* { .offset = B2062_N_LGENA_CTL0, .value_a = 0x0032, .value_g = 0x0032, .flags = 0, }, */
> +	/* { .offset = B2062_N_LGENA_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_LGENA_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_N_LGENA_TUNE0, .value_a = 0x00DD, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_N_LGENA_TUNE1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_N_LGENA_TUNE2, .value_a = 0x00DD, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_N_LGENA_TUNE3, .value_a = 0x0077, .value_g = 0x00B5, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_N_LGENA_CTL3, .value_a = 0x0000, .value_g = 0x00FF, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_N_LGENA_CTL4, .value_a = 0x001F, .value_g = 0x001F, .flags = 0, }, */
> +	/* { .offset = B2062_N_LGENA_CTL5, .value_a = 0x0032, .value_g = 0x0032, .flags = 0, }, */
> +	/* { .offset = B2062_N_LGENA_CTL6, .value_a = 0x0032, .value_g = 0x0032, .flags = 0, }, */
> +	{ .offset = B2062_N_LGENA_CTL7, .value_a = 0x0033, .value_g = 0x0033, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_N_RXA_CTL0, .value_a = 0x0009, .value_g = 0x0009, .flags = 0, }, */
> +	{ .offset = B2062_N_RXA_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = B2062_FLAG_G, },
> +	/* { .offset = B2062_N_RXA_CTL2, .value_a = 0x0018, .value_g = 0x0018, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXA_CTL3, .value_a = 0x0027, .value_g = 0x0027, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXA_CTL4, .value_a = 0x0028, .value_g = 0x0028, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXA_CTL5, .value_a = 0x0007, .value_g = 0x0007, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXA_CTL6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXA_CTL7, .value_a = 0x0008, .value_g = 0x0008, .flags = 0, }, */
> +	{ .offset = B2062_N_RXBB_CTL0, .value_a = 0x0082, .value_g = 0x0080, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_N_RXBB_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_GAIN0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_N_RXBB_GAIN1, .value_a = 0x0004, .value_g = 0x0004, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_N_RXBB_GAIN2, .value_a = 0x0000, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_N_RXBB_GAIN3, .value_a = 0x0011, .value_g = 0x0011, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_RSSI0, .value_a = 0x0043, .value_g = 0x0043, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_RSSI1, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_CALIB0, .value_a = 0x0010, .value_g = 0x0010, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_CALIB1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_CALIB2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_BIAS0, .value_a = 0x0006, .value_g = 0x0006, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_BIAS1, .value_a = 0x002A, .value_g = 0x002A, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_BIAS2, .value_a = 0x00AA, .value_g = 0x00AA, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_BIAS3, .value_a = 0x0021, .value_g = 0x0021, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_BIAS4, .value_a = 0x00AA, .value_g = 0x00AA, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_BIAS5, .value_a = 0x0022, .value_g = 0x0022, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_RSSI2, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_RSSI3, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_RSSI4, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
> +	/* { .offset = B2062_N_RXBB_RSSI5, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_CTL0, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_CTL2, .value_a = 0x0084, .value_g = 0x0084, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_N_TX_CTL4, .value_a = 0x0003, .value_g = 0x0003, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_N_TX_CTL5, .value_a = 0x0002, .value_g = 0x0002, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_N_TX_CTL6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_CTL7, .value_a = 0x0058, .value_g = 0x0058, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_CTL8, .value_a = 0x0082, .value_g = 0x0082, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_CTL9, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_CTL_A, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_GC2G, .value_a = 0x00FF, .value_g = 0x00FF, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_GC5G, .value_a = 0x00FF, .value_g = 0x00FF, .flags = 0, }, */
> +	{ .offset = B2062_N_TX_TUNE, .value_a = 0x0088, .value_g = 0x001B, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_N_TX_PAD, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_PGA, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_PADAUX, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
> +	/* { .offset = B2062_N_TX_PGAAUX, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
> +	/* { .offset = B2062_N_TSSI_CTL0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_TSSI_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_TSSI_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_IQ_CALIB_CTL0, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
> +	/* { .offset = B2062_N_IQ_CALIB_CTL1, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
> +	/* { .offset = B2062_N_IQ_CALIB_CTL2, .value_a = 0x0032, .value_g = 0x0032, .flags = 0, }, */
> +	/* { .offset = B2062_N_CALIB_TS, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_CALIB_CTL0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_CALIB_CTL1, .value_a = 0x0015, .value_g = 0x0015, .flags = 0, }, */
> +	/* { .offset = B2062_N_CALIB_CTL2, .value_a = 0x000F, .value_g = 0x000F, .flags = 0, }, */
> +	/* { .offset = B2062_N_CALIB_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_CALIB_CTL4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_CALIB_DBG0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_CALIB_DBG1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_CALIB_DBG2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_CALIB_DBG3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_PSENSE_CTL0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_PSENSE_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_PSENSE_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_N_TEST_BUF0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RADIO_ID_CODE, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_S_COMM4, .value_a = 0x0001, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_S_COMM5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM7, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM8, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM9, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM10, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM11, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM12, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM13, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM14, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_COMM15, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_S_PDS_CTL0, .value_a = 0x00FF, .value_g = 0x00FF, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_S_PDS_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_PDS_CTL2, .value_a = 0x008E, .value_g = 0x008E, .flags = 0, }, */
> +	/* { .offset = B2062_S_PDS_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_BG_CTL0, .value_a = 0x0006, .value_g = 0x0006, .flags = 0, }, */
> +	/* { .offset = B2062_S_BG_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_BG_CTL2, .value_a = 0x0011, .value_g = 0x0011, .flags = 0, }, */
> +	{ .offset = B2062_S_LGENG_CTL0, .value_a = 0x00F8, .value_g = 0x00D8, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_LGENG_CTL1, .value_a = 0x003C, .value_g = 0x0024, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_S_LGENG_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_LGENG_CTL3, .value_a = 0x0041, .value_g = 0x0041, .flags = 0, }, */
> +	/* { .offset = B2062_S_LGENG_CTL4, .value_a = 0x0002, .value_g = 0x0002, .flags = 0, }, */
> +	/* { .offset = B2062_S_LGENG_CTL5, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
> +	/* { .offset = B2062_S_LGENG_CTL6, .value_a = 0x0022, .value_g = 0x0022, .flags = 0, }, */
> +	/* { .offset = B2062_S_LGENG_CTL7, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_S_LGENG_CTL8, .value_a = 0x0088, .value_g = 0x0080, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_S_LGENG_CTL9, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
> +	{ .offset = B2062_S_LGENG_CTL10, .value_a = 0x0088, .value_g = 0x0080, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_S_LGENG_CTL11, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL1, .value_a = 0x0007, .value_g = 0x0007, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL2, .value_a = 0x00AF, .value_g = 0x00AF, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL3, .value_a = 0x0012, .value_g = 0x0012, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL4, .value_a = 0x000B, .value_g = 0x000B, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL5, .value_a = 0x005F, .value_g = 0x005F, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL7, .value_a = 0x0040, .value_g = 0x0040, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL8, .value_a = 0x0052, .value_g = 0x0052, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL9, .value_a = 0x0026, .value_g = 0x0026, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL10, .value_a = 0x0003, .value_g = 0x0003, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL11, .value_a = 0x0036, .value_g = 0x0036, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL12, .value_a = 0x0057, .value_g = 0x0057, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL13, .value_a = 0x0011, .value_g = 0x0011, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL14, .value_a = 0x0075, .value_g = 0x0075, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL15, .value_a = 0x00B4, .value_g = 0x00B4, .flags = 0, }, */
> +	/* { .offset = B2062_S_REFPLL_CTL16, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_S_RFPLL_CTL0, .value_a = 0x0098, .value_g = 0x0098, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL1, .value_a = 0x0010, .value_g = 0x0010, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_S_RFPLL_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RFPLL_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RFPLL_CTL4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_S_RFPLL_CTL5, .value_a = 0x0043, .value_g = 0x0043, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL6, .value_a = 0x0047, .value_g = 0x0047, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL7, .value_a = 0x000C, .value_g = 0x000C, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL8, .value_a = 0x0011, .value_g = 0x0011, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL9, .value_a = 0x0011, .value_g = 0x0011, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL10, .value_a = 0x000E, .value_g = 0x000E, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL11, .value_a = 0x0008, .value_g = 0x0008, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL12, .value_a = 0x0033, .value_g = 0x0033, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL13, .value_a = 0x000A, .value_g = 0x000A, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL14, .value_a = 0x0006, .value_g = 0x0006, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_S_RFPLL_CTL15, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RFPLL_CTL16, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RFPLL_CTL17, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_S_RFPLL_CTL18, .value_a = 0x003E, .value_g = 0x003E, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL19, .value_a = 0x0013, .value_g = 0x0013, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_S_RFPLL_CTL20, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_S_RFPLL_CTL21, .value_a = 0x0062, .value_g = 0x0062, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL22, .value_a = 0x0007, .value_g = 0x0007, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL23, .value_a = 0x0016, .value_g = 0x0016, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL24, .value_a = 0x005C, .value_g = 0x005C, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL25, .value_a = 0x0095, .value_g = 0x0095, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_S_RFPLL_CTL26, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RFPLL_CTL27, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RFPLL_CTL28, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RFPLL_CTL29, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_S_RFPLL_CTL30, .value_a = 0x00A0, .value_g = 0x00A0, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL31, .value_a = 0x0004, .value_g = 0x0004, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_S_RFPLL_CTL32, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	{ .offset = B2062_S_RFPLL_CTL33, .value_a = 0x00CC, .value_g = 0x00CC, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	{ .offset = B2062_S_RFPLL_CTL34, .value_a = 0x0007, .value_g = 0x0007, .flags = B2062_FLAG_A | B2062_FLAG_G, },
> +	/* { .offset = B2062_S_RXG_CNT0, .value_a = 0x0010, .value_g = 0x0010, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT5, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT6, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT7, .value_a = 0x0005, .value_g = 0x0005, .flags = 0, }, */
> +	{ .offset = B2062_S_RXG_CNT8, .value_a = 0x000F, .value_g = 0x000F, .flags = B2062_FLAG_A, },
> +	/* { .offset = B2062_S_RXG_CNT9, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT10, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT11, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT12, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT13, .value_a = 0x0044, .value_g = 0x0044, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT14, .value_a = 0x00A0, .value_g = 0x00A0, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT15, .value_a = 0x0004, .value_g = 0x0004, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT16, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
> +	/* { .offset = B2062_S_RXG_CNT17, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
> +};
> +
> +void b2062_upload_init_table(struct b43_wldev *dev)
> +{
> +	const struct b2062_init_tab_entry *e;
> +	unsigned int i;
> +
> +	for (i = 0; i < ARRAY_SIZE(b2062_init_tab); i++) {
> +		e = &b2062_init_tab[i];
> +		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
> +			if (!(e->flags & B2062_FLAG_G))
> +				continue;
> +			b43_radio_write(dev, e->offset, e->value_g);
> +		} else {
> +			if (!(e->flags & B2062_FLAG_A))
> +				continue;
> +			b43_radio_write(dev, e->offset, e->value_a);
> +		}
> +	}
> +}
> +
>  u32 b43_lptab_read(struct b43_wldev *dev, u32 offset)
>  {
>  	u32 type, value;
> Index: wireless-testing/drivers/net/wireless/b43/tables_lpphy.h
> ===================================================================
> --- wireless-testing.orig/drivers/net/wireless/b43/tables_lpphy.h	2009-01-31 17:44:33.000000000 +0100
> +++ wireless-testing/drivers/net/wireless/b43/tables_lpphy.h	2009-01-31 17:44:53.000000000 +0100
> @@ -17,5 +17,7 @@
>  u32 b43_lptab_read(struct b43_wldev *dev, u32 offset);
>  void b43_lptab_write(struct b43_wldev *dev, u32 offset, u32 value);
>  
> +void b2062_upload_init_table(struct b43_wldev *dev);
> +
>  
>  #endif /* B43_TABLES_LPPHY_H_ */
> Index: wireless-testing/drivers/net/wireless/b43/phy_lp.h
> ===================================================================
> --- wireless-testing.orig/drivers/net/wireless/b43/phy_lp.h	2009-01-31 17:21:13.000000000 +0100
> +++ wireless-testing/drivers/net/wireless/b43/phy_lp.h	2009-01-31 17:51:39.000000000 +0100
> @@ -273,7 +273,7 @@
>  #define B43_LPPHY_TRLOOKUP4			B43_PHY_OFDM(0xBC) /* TRLookup4 */
>  #define B43_LPPHY_RADAR_FIFO_STAT		B43_PHY_OFDM(0xBD) /* Radar FIFO Status */
>  #define B43_LPPHY_GPIO_OUTEN			B43_PHY_OFDM(0xBE) /* GPIO Out enable */
> -#define B43_LPPHY_GPOI_SELECT			B43_PHY_OFDM(0xBF) /* GPOI Select */
> +#define B43_LPPHY_GPIO_SELECT			B43_PHY_OFDM(0xBF) /* GPIO Select */
>  #define B43_LPPHY_GPIO_OUT			B43_PHY_OFDM(0xC0) /* GPIO Out */
>  
>  
>
>   
Sorry, how can i unsuscribe ? Looks like it doesn't work


From francesco.gringoli at ing.unibs.it  Sun Feb  1 00:35:01 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Sun, 1 Feb 2009 00:35:01 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <200901302259.53251.mb@bu3sch.de>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<200901301146.46653.mb@bu3sch.de>
	<41960ccf0901300522i6ba65311j4c94c73ea900b501@mail.gmail.com>
	<200901302259.53251.mb@bu3sch.de>
Message-ID: <55609C65-F0FE-4793-98E0-615141FE8A39@ing.unibs.it>

On Jan 30, 2009, at 10:59 PM, Michael Buesch wrote:

> On Friday 30 January 2009 14:22:35 Lorenzo Nava wrote:
>>> I think that's rather unlikely, however. The DMA code is basically  
>>> unchanged
>>> for months and especially the slot handling hasn't changed in years.
>>>
>>
>> Yes, but I didn't mean that the code has some bug. Let's say, for
>> example, that all the DMA slots were filled; when the firmware will
>> try to report a tx status it will send the informations to the DMA.
>> The DMA won't have enough space to store it and so it will drop the
>> message. In your opinion is it possible that something like that
>> happened?
>
> No. TX status isn't passed through DMA in >=rev5 cores.
> It's passed through MMIO registers which access an internal hardware  
> queue.
Michael,

sorry, I have a question, there is a piece of code I do not  
understand. I see from specs that this queue (that is filled by the  
firmware to report status to host) _seems_ to be 16 positions long. I  
would say that this value should be taken as an upper limit in the  
number of frames sent on the dma and still not acked (positively or  
not, depending on tx success) by the firmware. Is this correct? I did  
some tests and I saw that the number of frames sent through   
op32_poke_tx before corresponding status being reported greatly  
exceeds 16.

What am I missing?

Many thanks,
Cheers,
-FG

>
>
>> What looks strange to me is that, if the error is somewhere in the
>> tx_header definition, every transmission will result in an error from
>> the b43_dma_handle_txstatus. If a field is not in the correct
>> position, it is always wrong: it can't be sometimes right and
>> sometimes wrong, don't you agree?
>> I had similar problem beacause of the wrong header offsets
>> definitions, but that made every transmission generate a BUG  
>> report...
>> I don't understand how it is possible that almost always things went
>> fine and sometimes report status was not correct...
>
> Well, you should probably patch the driver to print the cookie when  
> the WARN_ON happens
> and reproduce.
>
>> Please Michael, if you can, can you please check shm.inc header  
>> definition?
>
> Not yet. Maybe later.
>
>
> -- 
> Greetings, Michael.



From mb at bu3sch.de  Sun Feb  1 00:47:35 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 1 Feb 2009 00:47:35 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <55609C65-F0FE-4793-98E0-615141FE8A39@ing.unibs.it>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<200901302259.53251.mb@bu3sch.de>
	<55609C65-F0FE-4793-98E0-615141FE8A39@ing.unibs.it>
Message-ID: <200902010047.35274.mb@bu3sch.de>

On Sunday 01 February 2009 00:35:01 Francesco Gringoli wrote:
> On Jan 30, 2009, at 10:59 PM, Michael Buesch wrote:
> 
> > On Friday 30 January 2009 14:22:35 Lorenzo Nava wrote:
> >>> I think that's rather unlikely, however. The DMA code is basically  
> >>> unchanged
> >>> for months and especially the slot handling hasn't changed in years.
> >>>
> >>
> >> Yes, but I didn't mean that the code has some bug. Let's say, for
> >> example, that all the DMA slots were filled; when the firmware will
> >> try to report a tx status it will send the informations to the DMA.
> >> The DMA won't have enough space to store it and so it will drop the
> >> message. In your opinion is it possible that something like that
> >> happened?
> >
> > No. TX status isn't passed through DMA in >=rev5 cores.
> > It's passed through MMIO registers which access an internal hardware  
> > queue.
> Michael,
> 
> sorry, I have a question, there is a piece of code I do not  
> understand. I see from specs that this queue (that is filled by the  
> firmware to report status to host) _seems_ to be 16 positions long. I  
> would say that this value should be taken as an upper limit in the  
> number of frames sent on the dma and still not acked (positively or  
> not, depending on tx success) by the firmware. Is this correct? I did  
> some tests and I saw that the number of frames sent through   
> op32_poke_tx before corresponding status being reported greatly  
> exceeds 16.

The driver just puts the stuff into the DMA ring. It can put as much stuff
into the ring as it wants, as it allocated the ring.

The _firmware_ must make sure to accept new packets from dma _only_ if
its buffers are not filled. That includes the tx status report buffer.

-- 
Greetings, Michael.


From mb at bu3sch.de  Sun Feb  1 00:49:51 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 1 Feb 2009 00:49:51 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <200902010047.35274.mb@bu3sch.de>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<55609C65-F0FE-4793-98E0-615141FE8A39@ing.unibs.it>
	<200902010047.35274.mb@bu3sch.de>
Message-ID: <200902010049.51773.mb@bu3sch.de>

On Sunday 01 February 2009 00:47:35 Michael Buesch wrote:
> On Sunday 01 February 2009 00:35:01 Francesco Gringoli wrote:
> > On Jan 30, 2009, at 10:59 PM, Michael Buesch wrote:
> > 
> > > On Friday 30 January 2009 14:22:35 Lorenzo Nava wrote:
> > >>> I think that's rather unlikely, however. The DMA code is basically  
> > >>> unchanged
> > >>> for months and especially the slot handling hasn't changed in years.
> > >>>
> > >>
> > >> Yes, but I didn't mean that the code has some bug. Let's say, for
> > >> example, that all the DMA slots were filled; when the firmware will
> > >> try to report a tx status it will send the informations to the DMA.
> > >> The DMA won't have enough space to store it and so it will drop the
> > >> message. In your opinion is it possible that something like that
> > >> happened?
> > >
> > > No. TX status isn't passed through DMA in >=rev5 cores.
> > > It's passed through MMIO registers which access an internal hardware  
> > > queue.
> > Michael,
> > 
> > sorry, I have a question, there is a piece of code I do not  
> > understand. I see from specs that this queue (that is filled by the  
> > firmware to report status to host) _seems_ to be 16 positions long. I  
> > would say that this value should be taken as an upper limit in the  
> > number of frames sent on the dma and still not acked (positively or  
> > not, depending on tx success) by the firmware. Is this correct? I did  
> > some tests and I saw that the number of frames sent through   
> > op32_poke_tx before corresponding status being reported greatly  
> > exceeds 16.
> 
> The driver just puts the stuff into the DMA ring. It can put as much stuff
> into the ring as it wants, as it allocated the ring.
> 
> The _firmware_ must make sure to accept new packets from dma _only_ if
> its buffers are not filled. That includes the tx status report buffer.

The tx-status-queue-full condition most likely is an external condition
in the firmware. Don't ask me which one, however.

-- 
Greetings, Michael.


From francesco.gringoli at ing.unibs.it  Sun Feb  1 02:01:24 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Sun, 1 Feb 2009 02:01:24 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <200902010049.51773.mb@bu3sch.de>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<55609C65-F0FE-4793-98E0-615141FE8A39@ing.unibs.it>
	<200902010047.35274.mb@bu3sch.de> <200902010049.51773.mb@bu3sch.de>
Message-ID: <161B4C74-B976-44AF-BF20-9012F3060EFB@ing.unibs.it>


On Feb 1, 2009, at 12:49 AM, Michael Buesch wrote:

> On Sunday 01 February 2009 00:47:35 Michael Buesch wrote:
>> On Sunday 01 February 2009 00:35:01 Francesco Gringoli wrote:
>>> On Jan 30, 2009, at 10:59 PM, Michael Buesch wrote:
>>>
>>>> On Friday 30 January 2009 14:22:35 Lorenzo Nava wrote:
>>>>>> I think that's rather unlikely, however. The DMA code is  
>>>>>> basically
>>>>>> unchanged
>>>>>> for months and especially the slot handling hasn't changed in  
>>>>>> years.
>>>>>>
>>>>>
>>>>> Yes, but I didn't mean that the code has some bug. Let's say, for
>>>>> example, that all the DMA slots were filled; when the firmware  
>>>>> will
>>>>> try to report a tx status it will send the informations to the  
>>>>> DMA.
>>>>> The DMA won't have enough space to store it and so it will drop  
>>>>> the
>>>>> message. In your opinion is it possible that something like that
>>>>> happened?
>>>>
>>>> No. TX status isn't passed through DMA in >=rev5 cores.
>>>> It's passed through MMIO registers which access an internal  
>>>> hardware
>>>> queue.
>>> Michael,
>>>
>>> sorry, I have a question, there is a piece of code I do not
>>> understand. I see from specs that this queue (that is filled by the
>>> firmware to report status to host) _seems_ to be 16 positions  
>>> long. I
>>> would say that this value should be taken as an upper limit in the
>>> number of frames sent on the dma and still not acked (positively or
>>> not, depending on tx success) by the firmware. Is this correct? I  
>>> did
>>> some tests and I saw that the number of frames sent through
>>> op32_poke_tx before corresponding status being reported greatly
>>> exceeds 16.
>>
>> The driver just puts the stuff into the DMA ring. It can put as  
>> much stuff
>> into the ring as it wants, as it allocated the ring.
>>
>> The _firmware_ must make sure to accept new packets from dma _only_  
>> if
>> its buffers are not filled. That includes the tx status report  
>> buffer.
>
> The tx-status-queue-full condition most likely is an external  
> condition
> in the firmware. Don't ask me which one, however.
Ok, this could be a problem. Will check next days how to solve. I  
suppose now that the length of that report_tx_status queue is very  
device dependent as mine can grow it more than one hundred elements  
and status continues to be correctly reported.

Cheers,
-FG


>
>
> -- 
> Greetings, Michael.

-------

Francesco Gringoli, PhD - Assistant Professor
Dept. of Electrical Engineering for Automation
University of Brescia
via Branze, 38
25123 Brescia
ITALY

Ph:  ++39.030.3715843
FAX: ++39.030.380014
WWW: http://www.ing.unibs.it/~gringoli






From mb at bu3sch.de  Sun Feb  1 11:16:29 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 1 Feb 2009 11:16:29 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <161B4C74-B976-44AF-BF20-9012F3060EFB@ing.unibs.it>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<200902010049.51773.mb@bu3sch.de>
	<161B4C74-B976-44AF-BF20-9012F3060EFB@ing.unibs.it>
Message-ID: <200902011116.29609.mb@bu3sch.de>

On Sunday 01 February 2009 02:01:24 Francesco Gringoli wrote:

> Ok, this could be a problem. Will check next days how to solve. I  
> suppose now that the length of that report_tx_status queue is very  
> device dependent as mine can grow it more than one hundred elements  
> and status continues to be correctly reported.

I think you still probably didn't get it.
The TX status queue has _nothing_ to do with the DMA queues/rings/slots
or the PIO queues. These are _completely_ independent queues.
Just _completely_ forget about DMA and PIO when dealing with TX status.

The TX status queue is only about 16 elements (give or take a couple) on all
devices. I'm not sure if it's possible to read the queue size from somewhere.
It probably isn't. I think the overflow protection works through external conditions
in the firmware. So there is some external condition that flags "tx status queue is full"
and the firmware will neither try to queue the status report, nor try to transmit yet
another frame. It will simply wait for the driver to fetch at least one entry from
the queue. The external condition will flip and the firmware goes on.
(However, I think the firmware probably can receive new frames while waiting for
the tx status queue to get one free entry.)

-- 
Greetings, Michael.


From mb at bu3sch.de  Sun Feb  1 11:25:24 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 1 Feb 2009 11:25:24 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <200902011116.29609.mb@bu3sch.de>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<161B4C74-B976-44AF-BF20-9012F3060EFB@ing.unibs.it>
	<200902011116.29609.mb@bu3sch.de>
Message-ID: <200902011125.24680.mb@bu3sch.de>

On Sunday 01 February 2009 11:16:29 Michael Buesch wrote:
> On Sunday 01 February 2009 02:01:24 Francesco Gringoli wrote:
> 
> > Ok, this could be a problem. Will check next days how to solve. I  
> > suppose now that the length of that report_tx_status queue is very  
> > device dependent as mine can grow it more than one hundred elements  
> > and status continues to be correctly reported.
> 
> I think you still probably didn't get it.
> The TX status queue has _nothing_ to do with the DMA queues/rings/slots
> or the PIO queues. These are _completely_ independent queues.
> Just _completely_ forget about DMA and PIO when dealing with TX status.
> 
> The TX status queue is only about 16 elements (give or take a couple) on all
> devices. I'm not sure if it's possible to read the queue size from somewhere.
> It probably isn't. I think the overflow protection works through external conditions
> in the firmware. So there is some external condition that flags "tx status queue is full"
> and the firmware will neither try to queue the status report, nor try to transmit yet
> another frame. It will simply wait for the driver to fetch at least one entry from
> the queue. The external condition will flip and the firmware goes on.
> (However, I think the firmware probably can receive new frames while waiting for
> the tx status queue to get one free entry.)

If it's not an external condition, it could possibly also be a bit in the TXE or something
like that. I'm not completely sure on that one. But external condition would be my
first bet, as we have lots of other external conditions for other overflow conditions.

-- 
Greetings, Michael.


From francesco.gringoli at ing.unibs.it  Sun Feb  1 12:24:23 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Sun, 1 Feb 2009 12:24:23 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <200902011125.24680.mb@bu3sch.de>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<161B4C74-B976-44AF-BF20-9012F3060EFB@ing.unibs.it>
	<200902011116.29609.mb@bu3sch.de> <200902011125.24680.mb@bu3sch.de>
Message-ID: <9D933A8E-72E8-4C4D-B6F6-BB0287EB37F9@ing.unibs.it>


On Feb 1, 2009, at 11:25 AM, Michael Buesch wrote:

> On Sunday 01 February 2009 11:16:29 Michael Buesch wrote:
>
> If it's not an external condition, it could possibly also be a bit  
> in the TXE or something
> like that. I'm not completely sure on that one. But external  
> condition would be my
> first bet, as we have lots of other external conditions for other  
> overflow conditions.
Well, the handler that reports status to host waits for a couple of  
external conditions, looping until they are satisfied: we left that  
about crypto because all times we removed something about crypto  
everything went bad, even if it seemed useless, do not consider it  
now. The other condition, instead, is the same that is checked before  
sending a received frame to host through _dma_, isn't it strange?  
There is no conditioning instead that prevents the IRQ about tx status  
reporting to be raised once we entered the reporting handler, and we  
jump into it after each sending. So each time we enter the report  
status handler, the IRQ is raised. So I think that the conditions you  
are talking can only be those two I said here above, no other bit is  
checked, and your bet was right :)

Cheers,
-FG


From francesco.gringoli at ing.unibs.it  Sun Feb  1 12:25:20 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Sun, 1 Feb 2009 12:25:20 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <200902011125.24680.mb@bu3sch.de>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<161B4C74-B976-44AF-BF20-9012F3060EFB@ing.unibs.it>
	<200902011116.29609.mb@bu3sch.de> <200902011125.24680.mb@bu3sch.de>
Message-ID: <2F0B8ED4-BF06-491F-98E6-CA27A104C237@ing.unibs.it>


On Feb 1, 2009, at 11:25 AM, Michael Buesch wrote:

> On Sunday 01 February 2009 11:16:29 Michael Buesch wrote:
>
> If it's not an external condition, it could possibly also be a bit  
> in the TXE or something
> like that. I'm not completely sure on that one. But external  
> condition would be my
> first bet, as we have lots of other external conditions for other  
> overflow conditions.

For my understanding of what's going on with Larry's adapter, may I  
kindly ask you if the following picture is correct?

I simply put a printk just at the top of op32_poke_tx and another in  
handle_irq_transmit_status. I injected as mush traffic as I can by  
sending UDP style frames through a raw socket to the wireless  
interface, I send ten thousands packets so to enter a "regime"  
condition: after the first  hundreds packets are sent, I see from  
dmesg a op32_poke_tx line followed by a handle_irq_transmit_status  
line, these two couple of lines repeated thousands times. More  
interesting is what happens at the end when I stop sending packets on  
the raw socket: the kernel stops filling the queue, and in dmesg we  
can see only handle_irq_transmit_status lines corresponding to frames  
still in the tx fifo. The firmware is removing these last packets and  
for each of them it will send a IRQ after sending. It always turn out  
that the queue had 64 packets inside, I always see 64 consecutive  
lines about handle_irq_transmit_stats. Is this number (64) due to the  
definition

#define B43_TXRING_SLOTS                128

in dma.h? For what I understand a slot is used for tx header, the  
other for the actual packet, isn'it? So we have half of 128 slots for  
64 packets.

If this is correct, the condition observed by Larry could be due to  
some packets being lost during their travel in the fifo run by the dma  
system? It seems that the firmware is reporting status for not all  
packets that have been sent through the dma, but we know that the  
firmware always reports status _unless_ the mac ctl register is set to  
skip status reporting. Could we investigate on this or I'm completely  
wrong?

Cheers,
-Francesco


From mb at bu3sch.de  Sun Feb  1 12:41:56 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 1 Feb 2009 12:41:56 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <2F0B8ED4-BF06-491F-98E6-CA27A104C237@ing.unibs.it>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<200902011125.24680.mb@bu3sch.de>
	<2F0B8ED4-BF06-491F-98E6-CA27A104C237@ing.unibs.it>
Message-ID: <200902011241.56229.mb@bu3sch.de>

On Sunday 01 February 2009 12:25:20 Francesco Gringoli wrote:
> 
> On Feb 1, 2009, at 11:25 AM, Michael Buesch wrote:
> 
> > On Sunday 01 February 2009 11:16:29 Michael Buesch wrote:
> >
> > If it's not an external condition, it could possibly also be a bit  
> > in the TXE or something
> > like that. I'm not completely sure on that one. But external  
> > condition would be my
> > first bet, as we have lots of other external conditions for other  
> > overflow conditions.
> 
> For my understanding of what's going on with Larry's adapter, may I  
> kindly ask you if the following picture is correct?
> 
> I simply put a printk just at the top of op32_poke_tx and another in  
> handle_irq_transmit_status. I injected as mush traffic as I can by  
> sending UDP style frames through a raw socket to the wireless  
> interface, I send ten thousands packets so to enter a "regime"  
> condition: after the first  hundreds packets are sent, I see from  
> dmesg a op32_poke_tx line followed by a handle_irq_transmit_status  
> line, these two couple of lines repeated thousands times. More  
> interesting is what happens at the end when I stop sending packets on  
> the raw socket: the kernel stops filling the queue, and in dmesg we  
> can see only handle_irq_transmit_status lines corresponding to frames  
> still in the tx fifo. The firmware is removing these last packets and  
> for each of them it will send a IRQ after sending. It always turn out  
> that the queue had 64 packets inside, I always see 64 consecutive  
> lines about handle_irq_transmit_stats. Is this number (64) due to the  
> definition

Yes it is. You need two slots per data packet.

> If this is correct, the condition observed by Larry could be due to  
> some packets being lost during their travel in the fifo run by the dma  
> system?

Well I'm not completely sure what's going on exactly. I only know that we
get bad cookies that the driver doesn't expect.

> It seems that the firmware is reporting status for not all   
> packets that have been sent through the dma,

Whoopsy, it is _required_ to report status for every single packet.
That's a basic assumption that must not be violated, as it's used for
freeing the DMA memory in the driver.

However, it should not corrupt anything. It will just grind
the DMA to a halt 64 packets after a status report was missed.
I never tried this, however.

-- 
Greetings, Michael.


From mb at bu3sch.de  Sun Feb  1 12:49:45 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 1 Feb 2009 12:49:45 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <9D933A8E-72E8-4C4D-B6F6-BB0287EB37F9@ing.unibs.it>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<200902011125.24680.mb@bu3sch.de>
	<9D933A8E-72E8-4C4D-B6F6-BB0287EB37F9@ing.unibs.it>
Message-ID: <200902011249.46023.mb@bu3sch.de>

On Sunday 01 February 2009 12:24:23 Francesco Gringoli wrote:
> 
> On Feb 1, 2009, at 11:25 AM, Michael Buesch wrote:
> 
> > On Sunday 01 February 2009 11:16:29 Michael Buesch wrote:
> >
> > If it's not an external condition, it could possibly also be a bit  
> > in the TXE or something
> > like that. I'm not completely sure on that one. But external  
> > condition would be my
> > first bet, as we have lots of other external conditions for other  
> > overflow conditions.
> Well, the handler that reports status to host waits for a couple of  
> external conditions, looping until they are satisfied: we left that  
> about crypto because all times we removed something about crypto  
> everything went bad, even if it seemed useless, do not consider it  
> now. The other condition, instead, is the same that is checked before  
> sending a received frame to host through _dma_, isn't it strange?  
> There is no conditioning instead that prevents the IRQ about tx status  
> reporting to be raised once we entered the reporting handler, and we  
> jump into it after each sending. So each time we enter the report  
> status handler, the IRQ is raised. So I think that the conditions you  
> are talking can only be those two I said here above, no other bit is  
> checked, and your bet was right :)

I think you're looking at the wrong place.
The check for the tx status queue must be a _lot_ earlier. It must be
even before we route the frame from the DMA engine to the TXE.
I bet it's one of the very first conditions that start the TX operation.

The basic idea is that we must check all buffers, including the tx status report
buffer, before we start the TX operation. Because if we started it and we notice
right in the middle of the operation that we lack bufferspace somewhere, we're
screwed.

That's my theory. I cannot back it up with facts, but it sounds sane to me.


But, why do we talk about this, actually? Do we actually know what went wrong, yet?
Larry, did you dump a cookie of a frame that would trigger the crash? What does the
ring memory allocation look like at the time the crash would trigger? Are there holes
in the ring memory? What does the crashing cookie point to? The end of the ring (aprox)
or somewhere completely different.
printk printk printk printk... :)

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Sun Feb  1 16:58:33 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 01 Feb 2009 09:58:33 -0600
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <200902011249.46023.mb@bu3sch.de>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<200902011125.24680.mb@bu3sch.de>
	<9D933A8E-72E8-4C4D-B6F6-BB0287EB37F9@ing.unibs.it>
	<200902011249.46023.mb@bu3sch.de>
Message-ID: <4985C6A9.8020806@lwfinger.net>

Michael Buesch wrote:
> 
> But, why do we talk about this, actually? Do we actually know what went wrong, yet?
> Larry, did you dump a cookie of a frame that would trigger the crash? What does the
> ring memory allocation look like at the time the crash would trigger? Are there holes
> in the ring memory? What does the crashing cookie point to? The end of the ring (aprox)
> or somewhere completely different.
> printk printk printk printk... :)
> 

Now that I'm not crashing Linux when it happens, I know a little more
about what happens. My last test with 5.1 firmware ran nearly 7 hours
before it died. At that point, ifconfig reported 25,407,000 packets
received for a total of 1,944 MB, and 36,843,000 packets transmitted
for a total of 596 MB. Those numbers for the MB transferred are not
what I expected - the flood ping should TX and RX equal numbers of
small packets, and the tcpperf run should TX large packets and RX only
ACKs.

In my latest run, I froze the TX queue when the first error occurred.
When that happened, there were still 6 more entries in the TX queue.
The cookies were all in the same sequence: 0x204A, 0x204E, 0x2050,
0x2052, 0x2054, 0x2056, and 0x205A. What happened to 0x2058?

I'm pretty busy today with the "Super Bowl", but I'm going to start a
long run with 5.0 firmware. My last run showed that the failure can
take a long time and that my previous tests may have missed an error.

Larry



From Larry.Finger at lwfinger.net  Sun Feb  1 17:19:29 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 01 Feb 2009 10:19:29 -0600
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <200902011249.46023.mb@bu3sch.de>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<200902011125.24680.mb@bu3sch.de>
	<9D933A8E-72E8-4C4D-B6F6-BB0287EB37F9@ing.unibs.it>
	<200902011249.46023.mb@bu3sch.de>
Message-ID: <4985CB91.9080208@lwfinger.net>

The problem also exists in the 5.0 firmware. My test this morning died
within 10 minutes. This time, there were only two transmits queued.
The cookies were 0x2048 and 0x204A.

Larry



From mb at bu3sch.de  Sun Feb  1 17:23:24 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 1 Feb 2009 17:23:24 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <4985C6A9.8020806@lwfinger.net>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<200902011249.46023.mb@bu3sch.de> <4985C6A9.8020806@lwfinger.net>
Message-ID: <200902011723.24851.mb@bu3sch.de>

On Sunday 01 February 2009 16:58:33 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > But, why do we talk about this, actually? Do we actually know what went wrong, yet?
> > Larry, did you dump a cookie of a frame that would trigger the crash? What does the
> > ring memory allocation look like at the time the crash would trigger? Are there holes
> > in the ring memory? What does the crashing cookie point to? The end of the ring (aprox)
> > or somewhere completely different.
> > printk printk printk printk... :)
> > 
> 
> Now that I'm not crashing Linux when it happens, I know a little more
> about what happens. My last test with 5.1 firmware ran nearly 7 hours
> before it died. At that point, ifconfig reported 25,407,000 packets
> received for a total of 1,944 MB, and 36,843,000 packets transmitted
> for a total of 596 MB. Those numbers for the MB transferred are not
> what I expected - the flood ping should TX and RX equal numbers of
> small packets, and the tcpperf run should TX large packets and RX only
> ACKs.
> 
> In my latest run, I froze the TX queue when the first error occurred.
> When that happened, there were still 6 more entries in the TX queue.
> The cookies were all in the same sequence: 0x204A, 0x204E, 0x2050,
> 0x2052, 0x2054, 0x2056, and 0x205A. What happened to 0x2058?

And 4C
The DMA implementation requires slots on one DMA queue to be reported in
the correct sequencial order. And it also requires them all to be reported.

Otherwise the slot counts (used_slots, current_slot) go wrong.

If you don't keep the strict order it will result in memory leaks and/or double-frees.
The double-free is detected by the BUG_ON in question.
There's no leak detection, so it will silently leak.

-- 
Greetings, Michael.


From francesco.gringoli at ing.unibs.it  Sun Feb  1 17:26:26 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Sun, 1 Feb 2009 17:26:26 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <4985CB91.9080208@lwfinger.net>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<200902011125.24680.mb@bu3sch.de>
	<9D933A8E-72E8-4C4D-B6F6-BB0287EB37F9@ing.unibs.it>
	<200902011249.46023.mb@bu3sch.de> <4985CB91.9080208@lwfinger.net>
Message-ID: <D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>


On Feb 1, 2009, at 5:19 PM, Larry Finger wrote:

> The problem also exists in the 5.0 firmware. My test this morning died
> within 10 minutes. This time, there were only two transmits queued.
> The cookies were 0x2048 and 0x204A.
>
> Larry
>
I'm happier now... though this means very hard debugging. It would be  
great if you can crash the original firmware too ;-) If it happens  
tell us...

Cheers,
-FG



From mb at bu3sch.de  Sun Feb  1 17:32:16 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 1 Feb 2009 17:32:16 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<4985CB91.9080208@lwfinger.net>
	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>
Message-ID: <200902011732.16495.mb@bu3sch.de>

On Sunday 01 February 2009 17:26:26 Francesco Gringoli wrote:
> 
> On Feb 1, 2009, at 5:19 PM, Larry Finger wrote:
> 
> > The problem also exists in the 5.0 firmware. My test this morning died
> > within 10 minutes. This time, there were only two transmits queued.
> > The cookies were 0x2048 and 0x204A.
> >
> > Larry
> >
> I'm happier now... though this means very hard debugging. It would be  
> great if you can crash the original firmware too ;-) If it happens  
> tell us...

Don't you think this is a bit unlikely? We're using the proprietary firmware
since, well,... ever? This particular version is in use since about a year.
We didn't have a single report of this.

-- 
Greetings, Michael.


From francesco.gringoli at ing.unibs.it  Sun Feb  1 17:40:24 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Sun, 1 Feb 2009 17:40:24 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <200902011732.16495.mb@bu3sch.de>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<4985CB91.9080208@lwfinger.net>
	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>
	<200902011732.16495.mb@bu3sch.de>
Message-ID: <75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>


On Feb 1, 2009, at 5:32 PM, Michael Buesch wrote:

> On Sunday 01 February 2009 17:26:26 Francesco Gringoli wrote:
>>
>> On Feb 1, 2009, at 5:19 PM, Larry Finger wrote:
>>
>>> The problem also exists in the 5.0 firmware. My test this morning  
>>> died
>>> within 10 minutes. This time, there were only two transmits queued.
>>> The cookies were 0x2048 and 0x204A.
>>>
>>> Larry
>>>
>> I'm happier now... though this means very hard debugging. It would be
>> great if you can crash the original firmware too ;-) If it happens
>> tell us...
>
> Don't you think this is a bit unlikely? We're using the proprietary  
> firmware
> since, well,... ever? This particular version is in use since about  
> a year.
> We didn't have a single report of this.
>
In fact, I was joking! However if it happens...

Jokes apart, I must reproduce this condition to debug it. Larry, would  
you mind loading up a modified firmware with a small kernel patch to  
report a cookie miss without crashing the system?

Cheers,
-FG

>
> -- 
> Greetings, Michael.

-------

Francesco Gringoli, PhD - Assistant Professor
Dept. of Electrical Engineering for Automation
University of Brescia
via Branze, 38
25123 Brescia
ITALY

Ph:  ++39.030.3715843
FAX: ++39.030.380014
WWW: http://www.ing.unibs.it/~gringoli






From Larry.Finger at lwfinger.net  Sun Feb  1 18:10:05 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 01 Feb 2009 11:10:05 -0600
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>	<4985CB91.9080208@lwfinger.net>	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>	<200902011732.16495.mb@bu3sch.de>
	<75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>
Message-ID: <4985D76D.9090109@lwfinger.net>

Francesco Gringoli wrote:
> In fact, I was joking! However if it happens...
> 
> Jokes apart, I must reproduce this condition to debug it. Larry, would  
> you mind loading up a modified firmware with a small kernel patch to  
> report a cookie miss without crashing the system?

I don't mind. Just to clarify your question. Will you be sending me
both new firmware and a kernel patch?

BTW, I realized I missed an earlier question of yours. My BCM4318 is
CardBus, i.e. 32 bit.

Larry



From francesco.gringoli at ing.unibs.it  Sun Feb  1 18:16:31 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Sun, 1 Feb 2009 18:16:31 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <4985D76D.9090109@lwfinger.net>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>	<4985CB91.9080208@lwfinger.net>	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>	<200902011732.16495.mb@bu3sch.de>
	<75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>
	<4985D76D.9090109@lwfinger.net>
Message-ID: <C79BD8C7-4CFD-4053-AA37-18C73F2264B2@ing.unibs.it>

On Feb 1, 2009, at 6:10 PM, Larry Finger wrote:

> Francesco Gringoli wrote:
>> In fact, I was joking! However if it happens...
>>
>> Jokes apart, I must reproduce this condition to debug it. Larry,  
>> would
>> you mind loading up a modified firmware with a small kernel patch to
>> report a cookie miss without crashing the system?
>
> I don't mind. Just to clarify your question. Will you be sending me
> both new firmware and a kernel patch?
Many thanks. I'm preparing them, I will send them ASAP.

> BTW, I realized I missed an earlier question of yours. My BCM4318 is
> CardBus, i.e. 32 bit.
>
> Larry
>




From Larry.Finger at lwfinger.net  Mon Feb  2 04:23:28 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 01 Feb 2009 21:23:28 -0600
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <C79BD8C7-4CFD-4053-AA37-18C73F2264B2@ing.unibs.it>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>	<4985CB91.9080208@lwfinger.net>	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>	<200902011732.16495.mb@bu3sch.de>
	<75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>
	<4985D76D.9090109@lwfinger.net>
	<C79BD8C7-4CFD-4053-AA37-18C73F2264B2@ing.unibs.it>
Message-ID: <49866730.40809@lwfinger.net>

I was able to crash the 5.0 firmware again today after a 7 hour run
This time I had the following patch applied:


Index: wireless-testing/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/dma.c
+++ wireless-testing/drivers/net/wireless/b43/dma.c
@@ -40,6 +40,7 @@
 #include <linux/etherdevice.h>
 #include <asm/div64.h>

+static int b43_freeze = 0;

 /* 32bit DMA ops. */
 static
@@ -1292,6 +1293,8 @@ int b43_dma_tx(struct b43_wldev *dev, st
 	unsigned long flags;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);

+	if (b43_freeze)
+		return -ENOMEM;
 	hdr = (struct ieee80211_hdr *)skb->data;
 	if (info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) {
 		/* The multicast ring will be sent after the DTIM */
@@ -1372,7 +1375,11 @@ void b43_dma_handle_txstatus(struct b43_
 	while (1) {
 		B43_WARN_ON(!(slot >= 0 && slot < ring->nr_slots));
 		desc = ops->idx2desc(ring, slot, &meta);
-
+		if (meta->skb == 0x6b6b6b6b) {
+			printk(KERN_INFO "b43: Double call of b43_dma_handle_"
+			       "txstatus for cookie 0x%X\n", status->cookie);
+			meta->skb = NULL;
+		}
 		if (meta->skb)
 			unmap_descbuffer(ring, meta->dmaaddr, meta->skb->len,
 					 1);
@@ -1383,7 +1390,13 @@ void b43_dma_handle_txstatus(struct b43_
 		if (meta->is_last_fragment) {
 			struct ieee80211_tx_info *info;

-			BUG_ON(!meta->skb);
+			if (!meta->skb) {
+				printk(KERN_INFO "b43: Cookie is 0x%X for bad skb\n",
status->cookie);
+				printk(KERN_INFO "b43: DMA Output is frozen\n");
+				b43_freeze = 1;
+				B43_WARN_ON(1);
+				return;
+			}

 			info = IEEE80211_SKB_CB(meta->skb);

@@ -1402,7 +1415,7 @@ void b43_dma_handle_txstatus(struct b43_
 			ieee80211_tx_status_irqsafe(dev->wl->hw, meta->skb);

 			/* skb is freed by ieee80211_tx_status_irqsafe() */
-			meta->skb = NULL;
+			meta->skb = 0x6b6b6b6b;
 		} else {
 			/* No need to call free_descriptor_buffer here, as
 			 * this is only the txhdr, which is not allocated.

Besides freezing TX when an error occurs, I also "poisoned" meta->skb rather than making
it NULL after the call to ieee80211_tx_status_irqsafe(). I could then detect a double call
with the same cookie, which is exactly what happened.

I will now have time to code a dump of shared memory when the error occurs, but we do know
what the mistake is.

Larry



From francesco.gringoli at ing.unibs.it  Mon Feb  2 16:40:37 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Mon, 2 Feb 2009 16:40:37 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <49866730.40809@lwfinger.net>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>	<4985CB91.9080208@lwfinger.net>	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>	<200902011732.16495.mb@bu3sch.de>
	<75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>
	<4985D76D.9090109@lwfinger.net>
	<C79BD8C7-4CFD-4053-AA37-18C73F2264B2@ing.unibs.it>
	<49866730.40809@lwfinger.net>
Message-ID: <74057D6E-702D-43D4-BBD9-927B8910699B@ing.unibs.it>


On Feb 2, 2009, at 4:23 AM, Larry Finger wrote:

> I was able to crash the 5.0 firmware again today after a 7 hour run
> This time I had the following patch applied:
>
Finally I got my equipment, a rev 3 4306 Broadcom cardbus adapter, to  
crash too. What is strange is that during the weekend I did several  
tests and everything was fine.

Today, instead, I brought both laptop and cardbus adapter into the lab  
and each time I begin to download even very small files, it crashes.  
This happens with both openfwwf and original Broadcom firmware. I  
tested another cardbus adapter (though I believe they are the same,  
both Belkin) and it crashes too. Switching back to internal mini-pci,  
instead, I have no problems.

Unfortunately I do not observe any message from console, I set /proc/ 
sys/kernel/printk to log everything but the system simply hangs and I  
have to switch it off.

The only difference between the lab and my home networks is that here  
(lab) we have several SSIDs broadcasted, I can clearly observe tens of  
APs on the same channel and a lot of background traffic.

Note that the PC is rock solid, it never crashes in other conditions.  
The same situation appears with two cardbus adapters so I can't  
believe they are both broken and independently of the cardbus slot I  
plug the network adapter into.

Has anyone knowledge about incompatibility between b43/bcm adapters  
and this kind of CardBus bridge (as reported by lspci)

CardBus bridge: ENE Technology Inc CB-720/2/4 Cardbus Controller (rev  
01)

I always believed it was 32-bit (isn't it?) and I used it without  
problems for a long time with an Atheros controller so I believe it is  
not broken.

Cheers
-FG


From Larry.Finger at lwfinger.net  Mon Feb  2 17:07:10 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 02 Feb 2009 10:07:10 -0600
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <74057D6E-702D-43D4-BBD9-927B8910699B@ing.unibs.it>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>	<4985CB91.9080208@lwfinger.net>	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>	<200902011732.16495.mb@bu3sch.de>
	<75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>
	<4985D76D.9090109@lwfinger.net>
	<C79BD8C7-4CFD-4053-AA37-18C73F2264B2@ing.unibs.it>
	<49866730.40809@lwfinger.net>
	<74057D6E-702D-43D4-BBD9-927B8910699B@ing.unibs.it>
Message-ID: <49871A2E.2060701@lwfinger.net>

Francesco Gringoli wrote:
> Has anyone knowledge about incompatibility between b43/bcm adapters and
> this kind of CardBus bridge (as reported by lspci)
> 
> CardBus bridge: ENE Technology Inc CB-720/2/4 Cardbus Controller (rev 01)

Does that bridge use Yenta as its driver? From lspci, my bridges are

O2 Micro, Inc. OZ6832/6833 Cardbus Controller (rev 34)

Yenta_socket is definitely the module used by this device.
> 
> I always believed it was 32-bit (isn't it?) and I used it without
> problems for a long time with an Atheros controller so I believe it is
> not broken.

If lspci sees the card as well as the bridge, it is 32 bit.

I'm about to start my test using my BCM4318 and the proprietary
firmware. I don't expect any failure, but I'll let it run for at least
14 hours, which is twice as long as the longest successful run with
the open firmware.

Larry



From johannes at sipsolutions.net  Tue Feb  3 14:05:19 2009
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 03 Feb 2009 14:05:19 +0100
Subject: Cardbus wireless cards
Message-ID: <1233666319.3957.1.camel@johannes.local>

Hi,

Some of you know that I got a new laptop, and it doesn't have a cardbus
slot any more. I still have my powerbook, and it's still working fine,
but I'm not using it any more, it hasn't even booted in a month. I could
test on my powerbook, but given my regular time budget it seems unlikely
that I ever will.

Hence, I'm offering my collection of cardbus/pcmcia wireless test cards
to anyone I can afford shipping to.

* Broadcom PCMCIA (not cardbus, in cardbus slot adapter)
  requires external single antenna (u.fl, have one if I can find it)
* Airgo-based Belkin F5D8010 ("true MIMO")
* rt61pci (Conceptronic)
* Broadcom 11n (4321)
* acx111 based card (D-Link AirPlus XTreme G+)

I also have a Broadcom 11g (4306 I think, might be 4318) PCI card
somewhere that I will most likely never again have a use for.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20090203/bd504ef1/attachment.pgp>

From netrolller.3d at gmail.com  Tue Feb  3 19:17:53 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Tue, 3 Feb 2009 19:17:53 +0100
Subject: Cardbus wireless cards
In-Reply-To: <1233666319.3957.1.camel@johannes.local>
References: <1233666319.3957.1.camel@johannes.local>
Message-ID: <69e28c910902031017j5eb7b702jd818cdf3765ea1f1@mail.gmail.com>

On Tue, Feb 3, 2009 at 2:05 PM, Johannes Berg <johannes at sipsolutions.net> wrote:
> Hi,
>
> Some of you know that I got a new laptop, and it doesn't have a cardbus
> slot any more. I still have my powerbook, and it's still working fine,
> but I'm not using it any more, it hasn't even booted in a month. I could
> test on my powerbook, but given my regular time budget it seems unlikely
> that I ever will.
>
> Hence, I'm offering my collection of cardbus/pcmcia wireless test cards
> to anyone I can afford shipping to.
>
> * Broadcom PCMCIA (not cardbus, in cardbus slot adapter)
>  requires external single antenna (u.fl, have one if I can find it)
> * Airgo-based Belkin F5D8010 ("true MIMO")
> * rt61pci (Conceptronic)
> * Broadcom 11n (4321)
> * acx111 based card (D-Link AirPlus XTreme G+)
>
> I also have a Broadcom 11g (4306 I think, might be 4318) PCI card
> somewhere that I will most likely never again have a use for.
>
> johannes
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
>

If Hungary does not fall outside the "anyone I can afford shipping
to", then I am interested in the acx111 card. Acx-based cards are
pretty hard to find in Hungary.

G?bor
-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Tue Feb  3 19:23:18 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 3 Feb 2009 19:23:18 +0100
Subject: [PATCH] ssb: Add PMU support
Message-ID: <200902031923.18571.mb@bu3sch.de>

This adds support for the SSB PMU.
A PMU is found on Low-Power devices.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, please queue for the next round of features.

Index: wireless-testing/drivers/ssb/Makefile
===================================================================
--- wireless-testing.orig/drivers/ssb/Makefile	2008-12-26 22:47:35.000000000 +0100
+++ wireless-testing/drivers/ssb/Makefile	2009-02-03 19:19:37.000000000 +0100
@@ -9,6 +9,7 @@ ssb-$(CONFIG_SSB_PCMCIAHOST)		+= pcmcia.
 
 # built-in drivers
 ssb-y					+= driver_chipcommon.o
+ssb-y					+= driver_chipcommon_pmu.o
 ssb-$(CONFIG_SSB_DRIVER_MIPS)		+= driver_mipscore.o
 ssb-$(CONFIG_SSB_DRIVER_EXTIF)		+= driver_extif.o
 ssb-$(CONFIG_SSB_DRIVER_PCICORE)	+= driver_pcicore.o
Index: wireless-testing/drivers/ssb/driver_chipcommon_pmu.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ wireless-testing/drivers/ssb/driver_chipcommon_pmu.c	2009-02-03 19:19:37.000000000 +0100
@@ -0,0 +1,508 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom ChipCommon Power Management Unit driver
+ *
+ * Copyright 2009, Michael Buesch <mb at bu3sch.de>
+ * Copyright 2007, Broadcom Corporation
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+#include <linux/ssb/ssb_driver_chipcommon.h>
+#include <linux/delay.h>
+
+#include "ssb_private.h"
+
+static u32 ssb_chipco_pll_read(struct ssb_chipcommon *cc, u32 offset)
+{
+	chipco_write32(cc, SSB_CHIPCO_PLLCTL_ADDR, offset);
+	return chipco_read32(cc, SSB_CHIPCO_PLLCTL_DATA);
+}
+
+static void ssb_chipco_pll_write(struct ssb_chipcommon *cc,
+				 u32 offset, u32 value)
+{
+	chipco_write32(cc, SSB_CHIPCO_PLLCTL_ADDR, offset);
+	chipco_write32(cc, SSB_CHIPCO_PLLCTL_DATA, value);
+}
+
+struct pmu0_plltab_entry {
+	u16 freq;	/* Crystal frequency in kHz.*/
+	u8 xf;		/* Crystal frequency value for PMU control */
+	u8 wb_int;
+	u32 wb_frac;
+};
+
+static const struct pmu0_plltab_entry pmu0_plltab[] = {
+	{ .freq = 12000, .xf =  1, .wb_int = 73, .wb_frac = 349525, },
+	{ .freq = 13000, .xf =  2, .wb_int = 67, .wb_frac = 725937, },
+	{ .freq = 14400, .xf =  3, .wb_int = 61, .wb_frac = 116508, },
+	{ .freq = 15360, .xf =  4, .wb_int = 57, .wb_frac = 305834, },
+	{ .freq = 16200, .xf =  5, .wb_int = 54, .wb_frac = 336579, },
+	{ .freq = 16800, .xf =  6, .wb_int = 52, .wb_frac = 399457, },
+	{ .freq = 19200, .xf =  7, .wb_int = 45, .wb_frac = 873813, },
+	{ .freq = 19800, .xf =  8, .wb_int = 44, .wb_frac = 466033, },
+	{ .freq = 20000, .xf =  9, .wb_int = 44, .wb_frac = 0,      },
+	{ .freq = 25000, .xf = 10, .wb_int = 70, .wb_frac = 419430, },
+	{ .freq = 26000, .xf = 11, .wb_int = 67, .wb_frac = 725937, },
+	{ .freq = 30000, .xf = 12, .wb_int = 58, .wb_frac = 699050, },
+	{ .freq = 38400, .xf = 13, .wb_int = 45, .wb_frac = 873813, },
+	{ .freq = 40000, .xf = 14, .wb_int = 45, .wb_frac = 0,      },
+};
+#define SSB_PMU0_DEFAULT_XTALFREQ	20000
+
+static const struct pmu0_plltab_entry * pmu0_plltab_find_entry(u32 crystalfreq)
+{
+	const struct pmu0_plltab_entry *e;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(pmu0_plltab); i++) {
+		e = &pmu0_plltab[i];
+		if (e->freq == crystalfreq)
+			return e;
+	}
+
+	return NULL;
+}
+
+/* Tune the PLL to the crystal speed. crystalfreq is in kHz. */
+static void ssb_pmu0_pllinit_r0(struct ssb_chipcommon *cc,
+				u32 crystalfreq)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	const struct pmu0_plltab_entry *e = NULL;
+	u32 pmuctl, tmp, pllctl;
+	unsigned int i;
+
+	if ((bus->chip_id == 0x5354) && !crystalfreq) {
+		/* The 5354 crystal freq is 25MHz */
+		crystalfreq = 25000;
+	}
+	if (crystalfreq)
+		e = pmu0_plltab_find_entry(crystalfreq);
+	if (!e)
+		e = pmu0_plltab_find_entry(SSB_PMU0_DEFAULT_XTALFREQ);
+	BUG_ON(!e);
+	crystalfreq = e->freq;
+	cc->pmu.crystalfreq = e->freq;
+
+	/* Check if the PLL already is programmed to this frequency. */
+	pmuctl = chipco_read32(cc, SSB_CHIPCO_PMU_CTL);
+	if (((pmuctl & SSB_CHIPCO_PMU_CTL_XTALFREQ) >> SSB_CHIPCO_PMU_CTL_XTALFREQ_SHIFT) == e->xf) {
+		/* We're already there... */
+		return;
+	}
+
+	ssb_printk(KERN_INFO PFX "Programming PLL to %u.%03u MHz\n",
+		   (crystalfreq / 1000), (crystalfreq % 1000));
+
+	/* First turn the PLL off. */
+	switch (bus->chip_id) {
+	case 0x4328:
+		chipco_mask32(cc, SSB_CHIPCO_PMU_MINRES_MSK,
+			      ~(1 << SSB_PMURES_4328_BB_PLL_PU));
+		chipco_mask32(cc, SSB_CHIPCO_PMU_MAXRES_MSK,
+			      ~(1 << SSB_PMURES_4328_BB_PLL_PU));
+		break;
+	case 0x5354:
+		chipco_mask32(cc, SSB_CHIPCO_PMU_MINRES_MSK,
+			      ~(1 << SSB_PMURES_5354_BB_PLL_PU));
+		chipco_mask32(cc, SSB_CHIPCO_PMU_MAXRES_MSK,
+			      ~(1 << SSB_PMURES_5354_BB_PLL_PU));
+		break;
+	default:
+		SSB_WARN_ON(1);
+	}
+	for (i = 1500; i; i--) {
+		tmp = chipco_read32(cc, SSB_CHIPCO_CLKCTLST);
+		if (!(tmp & SSB_CHIPCO_CLKCTLST_HAVEHT))
+			break;
+		udelay(10);
+	}
+	tmp = chipco_read32(cc, SSB_CHIPCO_CLKCTLST);
+	if (tmp & SSB_CHIPCO_CLKCTLST_HAVEHT)
+		ssb_printk(KERN_EMERG PFX "Failed to turn the PLL off!\n");
+
+	/* Set PDIV in PLL control 0. */
+	pllctl = ssb_chipco_pll_read(cc, SSB_PMU0_PLLCTL0);
+	if (crystalfreq >= SSB_PMU0_PLLCTL0_PDIV_FREQ)
+		pllctl |= SSB_PMU0_PLLCTL0_PDIV_MSK;
+	else
+		pllctl &= ~SSB_PMU0_PLLCTL0_PDIV_MSK;
+	ssb_chipco_pll_write(cc, SSB_PMU0_PLLCTL0, pllctl);
+
+	/* Set WILD in PLL control 1. */
+	pllctl = ssb_chipco_pll_read(cc, SSB_PMU0_PLLCTL1);
+	pllctl &= ~SSB_PMU0_PLLCTL1_STOPMOD;
+	pllctl &= ~(SSB_PMU0_PLLCTL1_WILD_IMSK | SSB_PMU0_PLLCTL1_WILD_FMSK);
+	pllctl |= ((u32)e->wb_int << SSB_PMU0_PLLCTL1_WILD_IMSK_SHIFT) & SSB_PMU0_PLLCTL1_WILD_IMSK;
+	pllctl |= ((u32)e->wb_frac << SSB_PMU0_PLLCTL1_WILD_FMSK_SHIFT) & SSB_PMU0_PLLCTL1_WILD_FMSK;
+	if (e->wb_frac == 0)
+		pllctl |= SSB_PMU0_PLLCTL1_STOPMOD;
+	ssb_chipco_pll_write(cc, SSB_PMU0_PLLCTL1, pllctl);
+
+	/* Set WILD in PLL control 2. */
+	pllctl = ssb_chipco_pll_read(cc, SSB_PMU0_PLLCTL2);
+	pllctl &= ~SSB_PMU0_PLLCTL2_WILD_IMSKHI;
+	pllctl |= (((u32)e->wb_int >> 4) << SSB_PMU0_PLLCTL2_WILD_IMSKHI_SHIFT) & SSB_PMU0_PLLCTL2_WILD_IMSKHI;
+	ssb_chipco_pll_write(cc, SSB_PMU0_PLLCTL2, pllctl);
+
+	/* Set the crystalfrequency and the divisor. */
+	pmuctl = chipco_read32(cc, SSB_CHIPCO_PMU_CTL);
+	pmuctl &= ~SSB_CHIPCO_PMU_CTL_ILP_DIV;
+	pmuctl |= (((crystalfreq + 127) / 128 - 1) << SSB_CHIPCO_PMU_CTL_ILP_DIV_SHIFT)
+			& SSB_CHIPCO_PMU_CTL_ILP_DIV;
+	pmuctl &= ~SSB_CHIPCO_PMU_CTL_XTALFREQ;
+	pmuctl |= ((u32)e->xf << SSB_CHIPCO_PMU_CTL_XTALFREQ_SHIFT) & SSB_CHIPCO_PMU_CTL_XTALFREQ;
+	chipco_write32(cc, SSB_CHIPCO_PMU_CTL, pmuctl);
+}
+
+struct pmu1_plltab_entry {
+	u16 freq;	/* Crystal frequency in kHz.*/
+	u8 xf;		/* Crystal frequency value for PMU control */
+	u8 ndiv_int;
+	u32 ndiv_frac;
+	u8 p1div;
+	u8 p2div;
+};
+
+static const struct pmu1_plltab_entry pmu1_plltab[] = {
+	{ .freq = 12000, .xf =  1, .p1div = 3, .p2div = 22, .ndiv_int =  0x9, .ndiv_frac = 0xFFFFEF, },
+	{ .freq = 13000, .xf =  2, .p1div = 1, .p2div =  6, .ndiv_int =  0xb, .ndiv_frac = 0x483483, },
+	{ .freq = 14400, .xf =  3, .p1div = 1, .p2div = 10, .ndiv_int =  0xa, .ndiv_frac = 0x1C71C7, },
+	{ .freq = 15360, .xf =  4, .p1div = 1, .p2div =  5, .ndiv_int =  0xb, .ndiv_frac = 0x755555, },
+	{ .freq = 16200, .xf =  5, .p1div = 1, .p2div = 10, .ndiv_int =  0x5, .ndiv_frac = 0x6E9E06, },
+	{ .freq = 16800, .xf =  6, .p1div = 1, .p2div = 10, .ndiv_int =  0x5, .ndiv_frac = 0x3CF3CF, },
+	{ .freq = 19200, .xf =  7, .p1div = 1, .p2div =  9, .ndiv_int =  0x5, .ndiv_frac = 0x17B425, },
+	{ .freq = 19800, .xf =  8, .p1div = 1, .p2div = 11, .ndiv_int =  0x4, .ndiv_frac = 0xA57EB,  },
+	{ .freq = 20000, .xf =  9, .p1div = 1, .p2div = 11, .ndiv_int =  0x4, .ndiv_frac = 0,        },
+	{ .freq = 24000, .xf = 10, .p1div = 3, .p2div = 11, .ndiv_int =  0xa, .ndiv_frac = 0,        },
+	{ .freq = 25000, .xf = 11, .p1div = 5, .p2div = 16, .ndiv_int =  0xb, .ndiv_frac = 0,        },
+	{ .freq = 26000, .xf = 12, .p1div = 1, .p2div =  2, .ndiv_int = 0x10, .ndiv_frac = 0xEC4EC4, },
+	{ .freq = 30000, .xf = 13, .p1div = 3, .p2div =  8, .ndiv_int =  0xb, .ndiv_frac = 0,        },
+	{ .freq = 38400, .xf = 14, .p1div = 1, .p2div =  5, .ndiv_int =  0x4, .ndiv_frac = 0x955555, },
+	{ .freq = 40000, .xf = 15, .p1div = 1, .p2div =  2, .ndiv_int =  0xb, .ndiv_frac = 0,        },
+};
+
+#define SSB_PMU1_DEFAULT_XTALFREQ	15360
+
+static const struct pmu1_plltab_entry * pmu1_plltab_find_entry(u32 crystalfreq)
+{
+	const struct pmu1_plltab_entry *e;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(pmu1_plltab); i++) {
+		e = &pmu1_plltab[i];
+		if (e->freq == crystalfreq)
+			return e;
+	}
+
+	return NULL;
+}
+
+/* Tune the PLL to the crystal speed. crystalfreq is in kHz. */
+static void ssb_pmu1_pllinit_r0(struct ssb_chipcommon *cc,
+				u32 crystalfreq)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	const struct pmu1_plltab_entry *e = NULL;
+	u32 buffer_strength = 0;
+	u32 tmp, pllctl, pmuctl;
+	unsigned int i;
+
+	if (bus->chip_id == 0x4312) {
+		/* We do not touch the BCM4312 PLL and assume
+		 * the default crystal settings work out-of-the-box. */
+		cc->pmu.crystalfreq = 20000;
+		return;
+	}
+
+	if (crystalfreq)
+		e = pmu1_plltab_find_entry(crystalfreq);
+	if (!e)
+		e = pmu1_plltab_find_entry(SSB_PMU1_DEFAULT_XTALFREQ);
+	BUG_ON(!e);
+	crystalfreq = e->freq;
+	cc->pmu.crystalfreq = e->freq;
+
+	/* Check if the PLL already is programmed to this frequency. */
+	pmuctl = chipco_read32(cc, SSB_CHIPCO_PMU_CTL);
+	if (((pmuctl & SSB_CHIPCO_PMU_CTL_XTALFREQ) >> SSB_CHIPCO_PMU_CTL_XTALFREQ_SHIFT) == e->xf) {
+		/* We're already there... */
+		return;
+	}
+
+	ssb_printk(KERN_INFO PFX "Programming PLL to %u.%03u MHz\n",
+		   (crystalfreq / 1000), (crystalfreq % 1000));
+
+	/* First turn the PLL off. */
+	switch (bus->chip_id) {
+	case 0x4325:
+		chipco_mask32(cc, SSB_CHIPCO_PMU_MINRES_MSK,
+			      ~((1 << SSB_PMURES_4325_BBPLL_PWRSW_PU) |
+				(1 << SSB_PMURES_4325_HT_AVAIL)));
+		chipco_mask32(cc, SSB_CHIPCO_PMU_MAXRES_MSK,
+			      ~((1 << SSB_PMURES_4325_BBPLL_PWRSW_PU) |
+				(1 << SSB_PMURES_4325_HT_AVAIL)));
+		/* Adjust the BBPLL to 2 on all channels later. */
+		buffer_strength = 0x222222;
+		break;
+	default:
+		SSB_WARN_ON(1);
+	}
+	for (i = 1500; i; i--) {
+		tmp = chipco_read32(cc, SSB_CHIPCO_CLKCTLST);
+		if (!(tmp & SSB_CHIPCO_CLKCTLST_HAVEHT))
+			break;
+		udelay(10);
+	}
+	tmp = chipco_read32(cc, SSB_CHIPCO_CLKCTLST);
+	if (tmp & SSB_CHIPCO_CLKCTLST_HAVEHT)
+		ssb_printk(KERN_EMERG PFX "Failed to turn the PLL off!\n");
+
+	/* Set p1div and p2div. */
+	pllctl = ssb_chipco_pll_read(cc, SSB_PMU1_PLLCTL0);
+	pllctl &= ~(SSB_PMU1_PLLCTL0_P1DIV | SSB_PMU1_PLLCTL0_P2DIV);
+	pllctl |= ((u32)e->p1div << SSB_PMU1_PLLCTL0_P1DIV_SHIFT) & SSB_PMU1_PLLCTL0_P1DIV;
+	pllctl |= ((u32)e->p2div << SSB_PMU1_PLLCTL0_P2DIV_SHIFT) & SSB_PMU1_PLLCTL0_P2DIV;
+	ssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL0, pllctl);
+
+	/* Set ndiv int and ndiv mode */
+	pllctl = ssb_chipco_pll_read(cc, SSB_PMU1_PLLCTL2);
+	pllctl &= ~(SSB_PMU1_PLLCTL2_NDIVINT | SSB_PMU1_PLLCTL2_NDIVMODE);
+	pllctl |= ((u32)e->ndiv_int << SSB_PMU1_PLLCTL2_NDIVINT_SHIFT) & SSB_PMU1_PLLCTL2_NDIVINT;
+	pllctl |= (1 << SSB_PMU1_PLLCTL2_NDIVMODE_SHIFT) & SSB_PMU1_PLLCTL2_NDIVMODE;
+	ssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL2, pllctl);
+
+	/* Set ndiv frac */
+	pllctl = ssb_chipco_pll_read(cc, SSB_PMU1_PLLCTL3);
+	pllctl &= ~SSB_PMU1_PLLCTL3_NDIVFRAC;
+	pllctl |= ((u32)e->ndiv_frac << SSB_PMU1_PLLCTL3_NDIVFRAC_SHIFT) & SSB_PMU1_PLLCTL3_NDIVFRAC;
+	ssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL3, pllctl);
+
+	/* Change the drive strength, if required. */
+	if (buffer_strength) {
+		pllctl = ssb_chipco_pll_read(cc, SSB_PMU1_PLLCTL5);
+		pllctl &= ~SSB_PMU1_PLLCTL5_CLKDRV;
+		pllctl |= (buffer_strength << SSB_PMU1_PLLCTL5_CLKDRV_SHIFT) & SSB_PMU1_PLLCTL5_CLKDRV;
+		ssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL5, pllctl);
+	}
+
+	/* Tune the crystalfreq and the divisor. */
+	pmuctl = chipco_read32(cc, SSB_CHIPCO_PMU_CTL);
+	pmuctl &= ~(SSB_CHIPCO_PMU_CTL_ILP_DIV | SSB_CHIPCO_PMU_CTL_XTALFREQ);
+	pmuctl |= ((((u32)e->freq + 127) / 128 - 1) << SSB_CHIPCO_PMU_CTL_ILP_DIV_SHIFT)
+			& SSB_CHIPCO_PMU_CTL_ILP_DIV;
+	pmuctl |= ((u32)e->xf << SSB_CHIPCO_PMU_CTL_XTALFREQ_SHIFT) & SSB_CHIPCO_PMU_CTL_XTALFREQ;
+	chipco_write32(cc, SSB_CHIPCO_PMU_CTL, pmuctl);
+}
+
+static void ssb_pmu_pll_init(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	u32 crystalfreq = 0; /* in kHz. 0 = keep default freq. */
+
+	if (bus->bustype == SSB_BUSTYPE_SSB) {
+		/* TODO: The user may override the crystal frequency. */
+	}
+
+	switch (bus->chip_id) {
+	case 0x4312:
+	case 0x4325:
+		ssb_pmu1_pllinit_r0(cc, crystalfreq);
+		break;
+	case 0x4328:
+	case 0x5354:
+		ssb_pmu0_pllinit_r0(cc, crystalfreq);
+		break;
+	default:
+		ssb_printk(KERN_ERR PFX
+			   "ERROR: PLL init unknown for device %04X\n",
+			   bus->chip_id);
+	}
+}
+
+struct pmu_res_updown_tab_entry {
+	u8 resource;	/* The resource number */
+	u16 updown;	/* The updown value */
+};
+
+enum pmu_res_depend_tab_task {
+	PMU_RES_DEP_SET = 1,
+	PMU_RES_DEP_ADD,
+	PMU_RES_DEP_REMOVE,
+};
+
+struct pmu_res_depend_tab_entry {
+	u8 resource;	/* The resource number */
+	u8 task;	/* SET | ADD | REMOVE */
+	u32 depend;	/* The depend mask */
+};
+
+static const struct pmu_res_updown_tab_entry pmu_res_updown_tab_4328a0[] = {
+	{ .resource = SSB_PMURES_4328_EXT_SWITCHER_PWM,		.updown = 0x0101, },
+	{ .resource = SSB_PMURES_4328_BB_SWITCHER_PWM,		.updown = 0x1F01, },
+	{ .resource = SSB_PMURES_4328_BB_SWITCHER_BURST,	.updown = 0x010F, },
+	{ .resource = SSB_PMURES_4328_BB_EXT_SWITCHER_BURST,	.updown = 0x0101, },
+	{ .resource = SSB_PMURES_4328_ILP_REQUEST,		.updown = 0x0202, },
+	{ .resource = SSB_PMURES_4328_RADIO_SWITCHER_PWM,	.updown = 0x0F01, },
+	{ .resource = SSB_PMURES_4328_RADIO_SWITCHER_BURST,	.updown = 0x0F01, },
+	{ .resource = SSB_PMURES_4328_ROM_SWITCH,		.updown = 0x0101, },
+	{ .resource = SSB_PMURES_4328_PA_REF_LDO,		.updown = 0x0F01, },
+	{ .resource = SSB_PMURES_4328_RADIO_LDO,		.updown = 0x0F01, },
+	{ .resource = SSB_PMURES_4328_AFE_LDO,			.updown = 0x0F01, },
+	{ .resource = SSB_PMURES_4328_PLL_LDO,			.updown = 0x0F01, },
+	{ .resource = SSB_PMURES_4328_BG_FILTBYP,		.updown = 0x0101, },
+	{ .resource = SSB_PMURES_4328_TX_FILTBYP,		.updown = 0x0101, },
+	{ .resource = SSB_PMURES_4328_RX_FILTBYP,		.updown = 0x0101, },
+	{ .resource = SSB_PMURES_4328_XTAL_PU,			.updown = 0x0101, },
+	{ .resource = SSB_PMURES_4328_XTAL_EN,			.updown = 0xA001, },
+	{ .resource = SSB_PMURES_4328_BB_PLL_FILTBYP,		.updown = 0x0101, },
+	{ .resource = SSB_PMURES_4328_RF_PLL_FILTBYP,		.updown = 0x0101, },
+	{ .resource = SSB_PMURES_4328_BB_PLL_PU,		.updown = 0x0701, },
+};
+
+static const struct pmu_res_depend_tab_entry pmu_res_depend_tab_4328a0[] = {
+	{
+		/* Adjust ILP Request to avoid forcing EXT/BB into burst mode. */
+		.resource = SSB_PMURES_4328_ILP_REQUEST,
+		.task = PMU_RES_DEP_SET,
+		.depend = ((1 << SSB_PMURES_4328_EXT_SWITCHER_PWM) |
+			   (1 << SSB_PMURES_4328_BB_SWITCHER_PWM)),
+	},
+};
+
+static const struct pmu_res_updown_tab_entry pmu_res_updown_tab_4325a0[] = {
+	{ .resource = SSB_PMURES_4325_XTAL_PU,			.updown = 0x1501, },
+};
+
+static const struct pmu_res_depend_tab_entry pmu_res_depend_tab_4325a0[] = {
+	{
+		/* Adjust HT-Available dependencies. */
+		.resource = SSB_PMURES_4325_HT_AVAIL,
+		.task = PMU_RES_DEP_ADD,
+		.depend = ((1 << SSB_PMURES_4325_RX_PWRSW_PU) |
+			   (1 << SSB_PMURES_4325_TX_PWRSW_PU) |
+			   (1 << SSB_PMURES_4325_LOGEN_PWRSW_PU) |
+			   (1 << SSB_PMURES_4325_AFE_PWRSW_PU)),
+	},
+};
+
+static void ssb_pmu_resources_init(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	u32 min_msk = 0, max_msk = 0;
+	unsigned int i;
+	const struct pmu_res_updown_tab_entry *updown_tab = NULL;
+	unsigned int updown_tab_size;
+	const struct pmu_res_depend_tab_entry *depend_tab = NULL;
+	unsigned int depend_tab_size;
+
+	switch (bus->chip_id) {
+	case 0x4312:
+		/* We keep the default settings:
+		 * min_msk = 0xCBB
+		 * max_msk = 0x7FFFF
+		 */
+		break;
+	case 0x4325:
+		/* Power OTP down later. */
+		min_msk = (1 << SSB_PMURES_4325_CBUCK_BURST) |
+			  (1 << SSB_PMURES_4325_LNLDO2_PU);
+		if (chipco_read32(cc, SSB_CHIPCO_CHIPSTAT) &
+		    SSB_CHIPCO_CHST_4325_PMUTOP_2B)
+			min_msk |= (1 << SSB_PMURES_4325_CLDO_CBUCK_BURST);
+		/* The PLL may turn on, if it decides so. */
+		max_msk = 0xFFFFF;
+		updown_tab = pmu_res_updown_tab_4325a0;
+		updown_tab_size = ARRAY_SIZE(pmu_res_updown_tab_4325a0);
+		depend_tab = pmu_res_depend_tab_4325a0;
+		depend_tab_size = ARRAY_SIZE(pmu_res_depend_tab_4325a0);
+		break;
+	case 0x4328:
+		min_msk = (1 << SSB_PMURES_4328_EXT_SWITCHER_PWM) |
+			  (1 << SSB_PMURES_4328_BB_SWITCHER_PWM) |
+			  (1 << SSB_PMURES_4328_XTAL_EN);
+		/* The PLL may turn on, if it decides so. */
+		max_msk = 0xFFFFF;
+		updown_tab = pmu_res_updown_tab_4328a0;
+		updown_tab_size = ARRAY_SIZE(pmu_res_updown_tab_4328a0);
+		depend_tab = pmu_res_depend_tab_4328a0;
+		depend_tab_size = ARRAY_SIZE(pmu_res_depend_tab_4328a0);
+		break;
+	case 0x5354:
+		/* The PLL may turn on, if it decides so. */
+		max_msk = 0xFFFFF;
+		break;
+	default:
+		ssb_printk(KERN_ERR PFX
+			   "ERROR: PMU resource config unknown for device %04X\n",
+			   bus->chip_id);
+	}
+
+	if (updown_tab) {
+		for (i = 0; i < updown_tab_size; i++) {
+			chipco_write32(cc, SSB_CHIPCO_PMU_RES_TABSEL,
+				       updown_tab[i].resource);
+			chipco_write32(cc, SSB_CHIPCO_PMU_RES_UPDNTM,
+				       updown_tab[i].updown);
+		}
+	}
+	if (depend_tab) {
+		for (i = 0; i < depend_tab_size; i++) {
+			chipco_write32(cc, SSB_CHIPCO_PMU_RES_TABSEL,
+				       depend_tab[i].resource);
+			switch (depend_tab[i].task) {
+			case PMU_RES_DEP_SET:
+				chipco_write32(cc, SSB_CHIPCO_PMU_RES_DEPMSK,
+					       depend_tab[i].depend);
+				break;
+			case PMU_RES_DEP_ADD:
+				chipco_set32(cc, SSB_CHIPCO_PMU_RES_DEPMSK,
+					     depend_tab[i].depend);
+				break;
+			case PMU_RES_DEP_REMOVE:
+				chipco_mask32(cc, SSB_CHIPCO_PMU_RES_DEPMSK,
+					      ~(depend_tab[i].depend));
+				break;
+			default:
+				SSB_WARN_ON(1);
+			}
+		}
+	}
+
+	/* Set the resource masks. */
+	if (min_msk)
+		chipco_write32(cc, SSB_CHIPCO_PMU_MINRES_MSK, min_msk);
+	if (max_msk)
+		chipco_write32(cc, SSB_CHIPCO_PMU_MAXRES_MSK, max_msk);
+}
+
+void ssb_pmu_init(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	u32 pmucap;
+
+	if (!(cc->capabilities & SSB_CHIPCO_CAP_PMU))
+		return;
+
+	pmucap = chipco_read32(cc, SSB_CHIPCO_PMU_CAP);
+	cc->pmu.rev = (pmucap & SSB_CHIPCO_PMU_CAP_REVISION);
+
+	ssb_dprintk(KERN_DEBUG PFX "Found rev %u PMU (capabilities 0x%08X)\n",
+		    cc->pmu.rev, pmucap);
+
+	if (cc->pmu.rev >= 1) {
+		if ((bus->chip_id == 0x4325) && (bus->chip_rev < 2)) {
+			chipco_mask32(cc, SSB_CHIPCO_PMU_CTL,
+				      ~SSB_CHIPCO_PMU_CTL_NOILPONW);
+		} else {
+			chipco_set32(cc, SSB_CHIPCO_PMU_CTL,
+				     SSB_CHIPCO_PMU_CTL_NOILPONW);
+		}
+	}
+	ssb_pmu_pll_init(cc);
+	ssb_pmu_resources_init(cc);
+}
Index: wireless-testing/drivers/ssb/driver_chipcommon.c
===================================================================
--- wireless-testing.orig/drivers/ssb/driver_chipcommon.c	2008-12-26 22:47:35.000000000 +0100
+++ wireless-testing/drivers/ssb/driver_chipcommon.c	2009-02-03 19:19:37.000000000 +0100
@@ -26,19 +26,6 @@ enum ssb_clksrc {
 };
 
 
-static inline u32 chipco_read32(struct ssb_chipcommon *cc,
-				u16 offset)
-{
-	return ssb_read32(cc->dev, offset);
-}
-
-static inline void chipco_write32(struct ssb_chipcommon *cc,
-				  u16 offset,
-				  u32 value)
-{
-	ssb_write32(cc->dev, offset, value);
-}
-
 static inline u32 chipco_write32_masked(struct ssb_chipcommon *cc, u16 offset,
 					u32 mask, u32 value)
 {
@@ -246,6 +233,7 @@ void ssb_chipcommon_init(struct ssb_chip
 {
 	if (!cc->dev)
 		return; /* We don't have a ChipCommon */
+	ssb_pmu_init(cc);
 	chipco_powercontrol_init(cc);
 	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_FAST);
 	calc_fast_powerup_delay(cc);
Index: wireless-testing/include/linux/ssb/ssb_driver_chipcommon.h
===================================================================
--- wireless-testing.orig/include/linux/ssb/ssb_driver_chipcommon.h	2008-12-26 22:47:44.000000000 +0100
+++ wireless-testing/include/linux/ssb/ssb_driver_chipcommon.h	2009-02-03 19:19:37.000000000 +0100
@@ -181,6 +181,16 @@
 #define SSB_CHIPCO_PROG_WAITCNT		0x0124
 #define SSB_CHIPCO_FLASH_CFG		0x0128
 #define SSB_CHIPCO_FLASH_WAITCNT	0x012C
+#define SSB_CHIPCO_CLKCTLST		0x01E0 /* Clock control and status (rev >= 20) */
+#define  SSB_CHIPCO_CLKCTLST_FORCEALP	0x00000001 /* Force ALP request */
+#define  SSB_CHIPCO_CLKCTLST_FORCEHT	0x00000002 /* Force HT request */
+#define  SSB_CHIPCO_CLKCTLST_FORCEILP	0x00000004 /* Force ILP request */
+#define  SSB_CHIPCO_CLKCTLST_HAVEALPREQ	0x00000008 /* ALP available request */
+#define  SSB_CHIPCO_CLKCTLST_HAVEHTREQ	0x00000010 /* HT available request */
+#define  SSB_CHIPCO_CLKCTLST_HWCROFF	0x00000020 /* Force HW clock request off */
+#define  SSB_CHIPCO_CLKCTLST_HAVEHT	0x00010000 /* HT available */
+#define  SSB_CHIPCO_CLKCTLST_HAVEALP	0x00020000 /* APL available */
+#define SSB_CHIPCO_HW_WORKAROUND	0x01E4 /* Hardware workaround (rev >= 20) */
 #define SSB_CHIPCO_UART0_DATA		0x0300
 #define SSB_CHIPCO_UART0_IMR		0x0304
 #define SSB_CHIPCO_UART0_FCR		0x0308
@@ -197,6 +207,196 @@
 #define SSB_CHIPCO_UART1_LSR		0x0414
 #define SSB_CHIPCO_UART1_MSR		0x0418
 #define SSB_CHIPCO_UART1_SCRATCH	0x041C
+/* PMU registers (rev >= 20) */
+#define SSB_CHIPCO_PMU_CTL			0x0600 /* PMU control */
+#define  SSB_CHIPCO_PMU_CTL_ILP_DIV		0xFFFF0000 /* ILP div mask */
+#define  SSB_CHIPCO_PMU_CTL_ILP_DIV_SHIFT	16
+#define  SSB_CHIPCO_PMU_CTL_NOILPONW		0x00000200 /* No ILP on wait */
+#define  SSB_CHIPCO_PMU_CTL_HTREQEN		0x00000100 /* HT req enable */
+#define  SSB_CHIPCO_PMU_CTL_ALPREQEN		0x00000080 /* ALP req enable */
+#define  SSB_CHIPCO_PMU_CTL_XTALFREQ		0x0000007C /* Crystal freq */
+#define  SSB_CHIPCO_PMU_CTL_XTALFREQ_SHIFT	2
+#define  SSB_CHIPCO_PMU_CTL_ILPDIVEN		0x00000002 /* ILP div enable */
+#define  SSB_CHIPCO_PMU_CTL_LPOSEL		0x00000001 /* LPO sel */
+#define SSB_CHIPCO_PMU_CAP			0x0604 /* PMU capabilities */
+#define  SSB_CHIPCO_PMU_CAP_REVISION		0x000000FF /* Revision mask */
+#define SSB_CHIPCO_PMU_STAT			0x0608 /* PMU status */
+#define  SSB_CHIPCO_PMU_STAT_INTPEND		0x00000040 /* Interrupt pending */
+#define  SSB_CHIPCO_PMU_STAT_SBCLKST		0x00000030 /* Backplane clock status? */
+#define  SSB_CHIPCO_PMU_STAT_HAVEALP		0x00000008 /* ALP available */
+#define  SSB_CHIPCO_PMU_STAT_HAVEHT		0x00000004 /* HT available */
+#define  SSB_CHIPCO_PMU_STAT_RESINIT		0x00000003 /* Res init */
+#define SSB_CHIPCO_PMU_RES_STAT			0x060C /* PMU res status */
+#define SSB_CHIPCO_PMU_RES_PEND			0x0610 /* PMU res pending */
+#define SSB_CHIPCO_PMU_TIMER			0x0614 /* PMU timer */
+#define SSB_CHIPCO_PMU_MINRES_MSK		0x0618 /* PMU min res mask */
+#define SSB_CHIPCO_PMU_MAXRES_MSK		0x061C /* PMU max res mask */
+#define SSB_CHIPCO_PMU_RES_TABSEL		0x0620 /* PMU res table sel */
+#define SSB_CHIPCO_PMU_RES_DEPMSK		0x0624 /* PMU res dep mask */
+#define SSB_CHIPCO_PMU_RES_UPDNTM		0x0628 /* PMU res updown timer */
+#define SSB_CHIPCO_PMU_RES_TIMER		0x062C /* PMU res timer */
+#define SSB_CHIPCO_PMU_CLKSTRETCH		0x0630 /* PMU clockstretch */
+#define SSB_CHIPCO_PMU_WATCHDOG			0x0634 /* PMU watchdog */
+#define SSB_CHIPCO_PMU_RES_REQTS		0x0640 /* PMU res req timer sel */
+#define SSB_CHIPCO_PMU_RES_REQT			0x0644 /* PMU res req timer */
+#define SSB_CHIPCO_PMU_RES_REQM			0x0648 /* PMU res req mask */
+#define SSB_CHIPCO_CHIPCTL_ADDR			0x0650
+#define SSB_CHIPCO_CHIPCTL_DATA			0x0654
+#define SSB_CHIPCO_REGCTL_ADDR			0x0658
+#define SSB_CHIPCO_REGCTL_DATA			0x065C
+#define SSB_CHIPCO_PLLCTL_ADDR			0x0660
+#define SSB_CHIPCO_PLLCTL_DATA			0x0664
+
+
+
+/** PMU PLL registers */
+
+/* PMU rev 0 PLL registers */
+#define SSB_PMU0_PLLCTL0			0
+#define  SSB_PMU0_PLLCTL0_PDIV_MSK		0x00000001
+#define  SSB_PMU0_PLLCTL0_PDIV_FREQ		25000 /* kHz */
+#define SSB_PMU0_PLLCTL1			1
+#define  SSB_PMU0_PLLCTL1_WILD_IMSK		0xF0000000 /* Wild int mask (low nibble) */
+#define  SSB_PMU0_PLLCTL1_WILD_IMSK_SHIFT	28
+#define  SSB_PMU0_PLLCTL1_WILD_FMSK		0x0FFFFF00 /* Wild frac mask */
+#define  SSB_PMU0_PLLCTL1_WILD_FMSK_SHIFT	8
+#define  SSB_PMU0_PLLCTL1_STOPMOD		0x00000040 /* Stop mod */
+#define SSB_PMU0_PLLCTL2			2
+#define  SSB_PMU0_PLLCTL2_WILD_IMSKHI		0x0000000F /* Wild int mask (high nibble) */
+#define  SSB_PMU0_PLLCTL2_WILD_IMSKHI_SHIFT	0
+
+/* PMU rev 1 PLL registers */
+#define SSB_PMU1_PLLCTL0			0
+#define  SSB_PMU1_PLLCTL0_P1DIV			0x00F00000 /* P1 div */
+#define  SSB_PMU1_PLLCTL0_P1DIV_SHIFT		20
+#define  SSB_PMU1_PLLCTL0_P2DIV			0x0F000000 /* P2 div */
+#define  SSB_PMU1_PLLCTL0_P2DIV_SHIFT		24
+#define SSB_PMU1_PLLCTL1			1
+#define  SSB_PMU1_PLLCTL1_M1DIV			0x000000FF /* M1 div */
+#define  SSB_PMU1_PLLCTL1_M1DIV_SHIFT		0
+#define  SSB_PMU1_PLLCTL1_M2DIV			0x0000FF00 /* M2 div */
+#define  SSB_PMU1_PLLCTL1_M2DIV_SHIFT		8
+#define  SSB_PMU1_PLLCTL1_M3DIV			0x00FF0000 /* M3 div */
+#define  SSB_PMU1_PLLCTL1_M3DIV_SHIFT		16
+#define  SSB_PMU1_PLLCTL1_M4DIV			0xFF000000 /* M4 div */
+#define  SSB_PMU1_PLLCTL1_M4DIV_SHIFT		24
+#define SSB_PMU1_PLLCTL2			2
+#define  SSB_PMU1_PLLCTL2_M5DIV			0x000000FF /* M5 div */
+#define  SSB_PMU1_PLLCTL2_M5DIV_SHIFT		0
+#define  SSB_PMU1_PLLCTL2_M6DIV			0x0000FF00 /* M6 div */
+#define  SSB_PMU1_PLLCTL2_M6DIV_SHIFT		8
+#define  SSB_PMU1_PLLCTL2_NDIVMODE		0x000E0000 /* NDIV mode */
+#define  SSB_PMU1_PLLCTL2_NDIVMODE_SHIFT	17
+#define  SSB_PMU1_PLLCTL2_NDIVINT		0x1FF00000 /* NDIV int */
+#define  SSB_PMU1_PLLCTL2_NDIVINT_SHIFT		20
+#define SSB_PMU1_PLLCTL3			3
+#define  SSB_PMU1_PLLCTL3_NDIVFRAC		0x00FFFFFF /* NDIV frac */
+#define  SSB_PMU1_PLLCTL3_NDIVFRAC_SHIFT	0
+#define SSB_PMU1_PLLCTL4			4
+#define SSB_PMU1_PLLCTL5			5
+#define  SSB_PMU1_PLLCTL5_CLKDRV		0xFFFFFF00 /* clk drv */
+#define  SSB_PMU1_PLLCTL5_CLKDRV_SHIFT		8
+
+/* BCM4312 PLL resource numbers. */
+#define SSB_PMURES_4312_SWITCHER_BURST		0
+#define SSB_PMURES_4312_SWITCHER_PWM    	1
+#define SSB_PMURES_4312_PA_REF_LDO		2
+#define SSB_PMURES_4312_CORE_LDO_BURST		3
+#define SSB_PMURES_4312_CORE_LDO_PWM		4
+#define SSB_PMURES_4312_RADIO_LDO		5
+#define SSB_PMURES_4312_ILP_REQUEST		6
+#define SSB_PMURES_4312_BG_FILTBYP		7
+#define SSB_PMURES_4312_TX_FILTBYP		8
+#define SSB_PMURES_4312_RX_FILTBYP		9
+#define SSB_PMURES_4312_XTAL_PU			10
+#define SSB_PMURES_4312_ALP_AVAIL		11
+#define SSB_PMURES_4312_BB_PLL_FILTBYP		12
+#define SSB_PMURES_4312_RF_PLL_FILTBYP		13
+#define SSB_PMURES_4312_HT_AVAIL		14
+
+/* BCM4325 PLL resource numbers. */
+#define SSB_PMURES_4325_BUCK_BOOST_BURST	0
+#define SSB_PMURES_4325_CBUCK_BURST		1
+#define SSB_PMURES_4325_CBUCK_PWM		2
+#define SSB_PMURES_4325_CLDO_CBUCK_BURST	3
+#define SSB_PMURES_4325_CLDO_CBUCK_PWM		4
+#define SSB_PMURES_4325_BUCK_BOOST_PWM		5
+#define SSB_PMURES_4325_ILP_REQUEST		6
+#define SSB_PMURES_4325_ABUCK_BURST		7
+#define SSB_PMURES_4325_ABUCK_PWM		8
+#define SSB_PMURES_4325_LNLDO1_PU		9
+#define SSB_PMURES_4325_LNLDO2_PU		10
+#define SSB_PMURES_4325_LNLDO3_PU		11
+#define SSB_PMURES_4325_LNLDO4_PU		12
+#define SSB_PMURES_4325_XTAL_PU			13
+#define SSB_PMURES_4325_ALP_AVAIL		14
+#define SSB_PMURES_4325_RX_PWRSW_PU		15
+#define SSB_PMURES_4325_TX_PWRSW_PU		16
+#define SSB_PMURES_4325_RFPLL_PWRSW_PU		17
+#define SSB_PMURES_4325_LOGEN_PWRSW_PU		18
+#define SSB_PMURES_4325_AFE_PWRSW_PU		19
+#define SSB_PMURES_4325_BBPLL_PWRSW_PU		20
+#define SSB_PMURES_4325_HT_AVAIL		21
+
+/* BCM4328 PLL resource numbers. */
+#define SSB_PMURES_4328_EXT_SWITCHER_PWM	0
+#define SSB_PMURES_4328_BB_SWITCHER_PWM		1
+#define SSB_PMURES_4328_BB_SWITCHER_BURST	2
+#define SSB_PMURES_4328_BB_EXT_SWITCHER_BURST	3
+#define SSB_PMURES_4328_ILP_REQUEST		4
+#define SSB_PMURES_4328_RADIO_SWITCHER_PWM	5
+#define SSB_PMURES_4328_RADIO_SWITCHER_BURST	6
+#define SSB_PMURES_4328_ROM_SWITCH		7
+#define SSB_PMURES_4328_PA_REF_LDO		8
+#define SSB_PMURES_4328_RADIO_LDO		9
+#define SSB_PMURES_4328_AFE_LDO			10
+#define SSB_PMURES_4328_PLL_LDO			11
+#define SSB_PMURES_4328_BG_FILTBYP		12
+#define SSB_PMURES_4328_TX_FILTBYP		13
+#define SSB_PMURES_4328_RX_FILTBYP		14
+#define SSB_PMURES_4328_XTAL_PU			15
+#define SSB_PMURES_4328_XTAL_EN			16
+#define SSB_PMURES_4328_BB_PLL_FILTBYP		17
+#define SSB_PMURES_4328_RF_PLL_FILTBYP		18
+#define SSB_PMURES_4328_BB_PLL_PU		19
+
+/* BCM5354 PLL resource numbers. */
+#define SSB_PMURES_5354_EXT_SWITCHER_PWM	0
+#define SSB_PMURES_5354_BB_SWITCHER_PWM		1
+#define SSB_PMURES_5354_BB_SWITCHER_BURST	2
+#define SSB_PMURES_5354_BB_EXT_SWITCHER_BURST	3
+#define SSB_PMURES_5354_ILP_REQUEST		4
+#define SSB_PMURES_5354_RADIO_SWITCHER_PWM	5
+#define SSB_PMURES_5354_RADIO_SWITCHER_BURST	6
+#define SSB_PMURES_5354_ROM_SWITCH		7
+#define SSB_PMURES_5354_PA_REF_LDO		8
+#define SSB_PMURES_5354_RADIO_LDO		9
+#define SSB_PMURES_5354_AFE_LDO			10
+#define SSB_PMURES_5354_PLL_LDO			11
+#define SSB_PMURES_5354_BG_FILTBYP		12
+#define SSB_PMURES_5354_TX_FILTBYP		13
+#define SSB_PMURES_5354_RX_FILTBYP		14
+#define SSB_PMURES_5354_XTAL_PU			15
+#define SSB_PMURES_5354_XTAL_EN			16
+#define SSB_PMURES_5354_BB_PLL_FILTBYP		17
+#define SSB_PMURES_5354_RF_PLL_FILTBYP		18
+#define SSB_PMURES_5354_BB_PLL_PU		19
+
+
+
+/** Chip specific Chip-Status register contents. */
+#define SSB_CHIPCO_CHST_4325_SPROM_OTP_SEL	0x00000003
+#define SSB_CHIPCO_CHST_4325_DEFCIS_SEL		0 /* OTP is powered up, use def. CIS, no SPROM */
+#define SSB_CHIPCO_CHST_4325_SPROM_SEL		1 /* OTP is powered up, SPROM is present */
+#define SSB_CHIPCO_CHST_4325_OTP_SEL		2 /* OTP is powered up, no SPROM */
+#define SSB_CHIPCO_CHST_4325_OTP_PWRDN		3 /* OTP is powered down, SPROM is present */
+#define SSB_CHIPCO_CHST_4325_SDIO_USB_MODE	0x00000004
+#define SSB_CHIPCO_CHST_4325_SDIO_USB_MODE_SHIFT  2
+#define SSB_CHIPCO_CHST_4325_RCAL_VALID		0x00000008
+#define SSB_CHIPCO_CHST_4325_RCAL_VALID_SHIFT	3
+#define SSB_CHIPCO_CHST_4325_RCAL_VALUE		0x000001F0
+#define SSB_CHIPCO_CHST_4325_RCAL_VALUE_SHIFT	4
+#define SSB_CHIPCO_CHST_4325_PMUTOP_2B 		0x00000200 /* 1 for 2b, 0 for to 2a */
 
 
 
@@ -353,11 +553,20 @@
 struct ssb_device;
 struct ssb_serial_port;
 
+/* Data for the PMU, if available.
+ * Check availability with ((struct ssb_chipcommon)->capabilities & SSB_CHIPCO_CAP_PMU)
+ */
+struct ssb_chipcommon_pmu {
+	u8 rev;			/* PMU revision */
+	u32 crystalfreq;	/* The active crystal frequency (in kHz) */
+};
+
 struct ssb_chipcommon {
 	struct ssb_device *dev;
 	u32 capabilities;
 	/* Fast Powerup Delay constant */
 	u16 fast_pwrup_delay;
+	struct ssb_chipcommon_pmu pmu;
 };
 
 static inline bool ssb_chipco_available(struct ssb_chipcommon *cc)
@@ -365,6 +574,17 @@ static inline bool ssb_chipco_available(
 	return (cc->dev != NULL);
 }
 
+/* Register access */
+#define chipco_read32(cc, offset)	ssb_read32((cc)->dev, offset)
+#define chipco_write32(cc, offset, val)	ssb_write32((cc)->dev, offset, val)
+
+#define chipco_mask32(cc, offset, mask) \
+		chipco_write32(cc, offset, chipco_read32(cc, offset) & (mask))
+#define chipco_set32(cc, offset, set) \
+		chipco_write32(cc, offset, chipco_read32(cc, offset) | (set))
+#define chipco_maskset32(cc, offset, mask, set) \
+		chipco_write32(cc, offset, (chipco_read32(cc, offset) & (mask)) | (set))
+
 extern void ssb_chipcommon_init(struct ssb_chipcommon *cc);
 
 extern void ssb_chipco_suspend(struct ssb_chipcommon *cc);
@@ -406,4 +626,8 @@ extern int ssb_chipco_serial_init(struct
 				  struct ssb_serial_port *ports);
 #endif /* CONFIG_SSB_SERIAL */
 
+/* PMU support */
+extern void ssb_pmu_init(struct ssb_chipcommon *cc);
+
+
 #endif /* LINUX_SSB_CHIPCO_H_ */

-- 
Greetings, Michael.


From mb at bu3sch.de  Tue Feb  3 19:36:45 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 3 Feb 2009 19:36:45 +0100
Subject: [PATCH] b43: Port spec bugfixes for the LP baseband init
Message-ID: <200902031936.45439.mb@bu3sch.de>

A few bugs were fixed in the LP baseband init specs.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Please queue on top of the other LP-PHY patches.

Index: wireless-testing/drivers/net/wireless/b43/phy_lp.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_lp.c	2009-02-03 19:30:33.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_lp.c	2009-02-03 19:33:18.000000000 +0100
@@ -70,6 +70,7 @@ static void lpphy_baseband_rev0_1_init(s
 
 static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 {
+	struct ssb_bus *bus = dev->dev->bus;
 	struct b43_phy_lp *lpphy = dev->phy.lp;
 
 	b43_phy_write(dev, B43_LPPHY_AFE_DAC_CTL, 0x50);
@@ -89,7 +90,7 @@ static void lpphy_baseband_rev2plus_init
 	b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, ~0x4000);
 	b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, ~0x2000);
 	b43_phy_set(dev, B43_PHY_OFDM(0x10A), 0x1);
-	b43_phy_maskset(dev, B43_LPPHY_CCKLMSSTEPSIZE, 0xFF01, 0x10);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x10A), 0xFF01, 0x10);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0xDF), 0xFF00, 0xF4);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0xDF), 0x00FF, 0xF100);
 	b43_phy_write(dev, B43_LPPHY_CLIPTHRESH, 0x48);
@@ -101,8 +102,13 @@ static void lpphy_baseband_rev2plus_init
 	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xF81F, 0xA0);
 	b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xE0FF, 0x300);
 	b43_phy_maskset(dev, B43_LPPHY_HIGAINDB, 0x00FF, 0x2A00);
-	b43_phy_maskset(dev, B43_LPPHY_LOWGAINDB, 0x00FF, 0x1E00);
-	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0xFF00, 0xD);
+	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 0)) {
+		b43_phy_maskset(dev, B43_LPPHY_LOWGAINDB, 0x00FF, 0x2100);
+		b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0xFF00, 0xA);
+	} else {
+		b43_phy_maskset(dev, B43_LPPHY_LOWGAINDB, 0x00FF, 0x1E00);
+		b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0xFF00, 0xD);
+	}
 	b43_phy_maskset(dev, B43_PHY_OFDM(0xFE), 0xFFE0, 0x1F);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0xFF), 0xFFE0, 0xC);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x100), 0xFF00, 0x19);
@@ -114,17 +120,8 @@ static void lpphy_baseband_rev2plus_init
 	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x12);
 	b43_phy_maskset(dev, B43_LPPHY_GAINMISMATCH, 0x0FFF, 0x9000);
 
-	if (dev->phy.rev < 2) {
-		//FIXME this will never execute.
-
-		//FIXME 32bit?
-		b43_lptab_write(dev, B43_LPTAB32(0x11, 0x14), 0);
-		b43_lptab_write(dev, B43_LPTAB32(0x08, 0x12), 0x40);
-	} else {
-		//FIXME 32bit?
-		b43_lptab_write(dev, B43_LPTAB32(0x08, 0x14), 0);
-		b43_lptab_write(dev, B43_LPTAB32(0x08, 0x12), 0x40);
-	}
+	b43_lptab_write(dev, B43_LPTAB16(0x08, 0x14), 0);
+	b43_lptab_write(dev, B43_LPTAB16(0x08, 0x12), 0x40);
 
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
 		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x40);

-- 
Greetings, Michael.


From johannes at sipsolutions.net  Tue Feb  3 19:55:41 2009
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 03 Feb 2009 19:55:41 +0100
Subject: Cardbus wireless cards
In-Reply-To: <69e28c910902031017j5eb7b702jd818cdf3765ea1f1@mail.gmail.com>
	(sfid-20090203_191754_828026_9EF5403E)
References: <1233666319.3957.1.camel@johannes.local>
	<69e28c910902031017j5eb7b702jd818cdf3765ea1f1@mail.gmail.com>
	(sfid-20090203_191754_828026_9EF5403E)
Message-ID: <1233687341.4070.6.camel@johannes.local>

On Tue, 2009-02-03 at 19:17 +0100, G?bor Stefanik wrote:

> If Hungary does not fall outside the "anyone I can afford shipping
> to", then I am interested in the acx111 card. Acx-based cards are
> pretty hard to find in Hungary.

Heh, should be fine, send me your address in private.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20090203/f7ee76a3/attachment.pgp>

From mb at bu3sch.de  Tue Feb  3 20:06:14 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 3 Feb 2009 20:06:14 +0100
Subject: [PATCH] b43: (b2062) Fix crystal frequency calculations
Message-ID: <200902032006.14373.mb@bu3sch.de>

This fixes the crystal frequency calculations in the b2062 init code.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

This patch depends on the SSB PMU code.


Index: wireless-testing/drivers/net/wireless/b43/phy_lp.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_lp.c	2009-02-03 19:43:31.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_lp.c	2009-02-03 20:04:26.000000000 +0100
@@ -160,6 +160,7 @@ struct b2062_freqdata {
 /* Initialize the 2062 radio. */
 static void lpphy_2062_init(struct b43_wldev *dev)
 {
+	struct ssb_bus *bus = dev->dev->bus;
 	u32 crystalfreq, pdiv, tmp, ref;
 	unsigned int i;
 	const struct b2062_freqdata *fd = NULL;
@@ -193,7 +194,11 @@ static void lpphy_2062_init(struct b43_w
 	else
 		b43_radio_mask(dev, B2062_N_TSSI_CTL0, ~0x1);
 
-	crystalfreq = 0;//FIXME
+	/* Get the crystal freq, in Hz. */
+	crystalfreq = bus->chipco.pmu.crystalfreq * 1000;
+
+	B43_WARN_ON(!(bus->chipco.capabilities & SSB_CHIPCO_CAP_PMU));
+	B43_WARN_ON(crystalfreq == 0);
 
 	if (crystalfreq >= 30000000) {
 		pdiv = 1;
@@ -219,13 +224,15 @@ static void lpphy_2062_init(struct b43_w
 			break;
 		}
 	}
-	if (B43_WARN_ON(!fd))
-		return;
+	if (!fd)
+		fd = &freqdata_tab[ARRAY_SIZE(freqdata_tab) - 1];
+	b43dbg(dev->wl, "b2062: Using crystal tab entry %u kHz.\n",
+	       fd->freq); /* FIXME: Keep this printk until the code is fully debugged. */
 
 	b43_radio_write(dev, B2062_S_RFPLL_CTL8,
 			((u16)(fd->data[1]) << 4) | fd->data[0]);
 	b43_radio_write(dev, B2062_S_RFPLL_CTL9,
-			((u16)(fd->data[3]) << 4) | fd->data[2]);//FIXME specs are different
+			((u16)(fd->data[3]) << 4) | fd->data[2]);
 	b43_radio_write(dev, B2062_S_RFPLL_CTL10, fd->data[4]);
 	b43_radio_write(dev, B2062_S_RFPLL_CTL11, fd->data[5]);
 }

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Wed Feb  4 04:12:46 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 03 Feb 2009 21:12:46 -0600
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <74057D6E-702D-43D4-BBD9-927B8910699B@ing.unibs.it>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>	<4985CB91.9080208@lwfinger.net>	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>	<200902011732.16495.mb@bu3sch.de>
	<75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>
	<4985D76D.9090109@lwfinger.net>
	<C79BD8C7-4CFD-4053-AA37-18C73F2264B2@ing.unibs.it>
	<49866730.40809@lwfinger.net>
	<74057D6E-702D-43D4-BBD9-927B8910699B@ing.unibs.it>
Message-ID: <498907AE.4040101@lwfinger.net>

Francesco,

I have coded b43 to dump the microcode PSM when
b43_dma_handle_txstatus is called for an skb that has already been
processed and deleted. This dump is for V5.0 of the open firmware and
includes everything but the PC and condition codes.

I think these data are correct; however, the dump code has not been
debugged. Please let me know if any of these data are not correct.

Larry

==============================================================

b43: b43_dma_handle_txstatus called for deleted skb caused by a double
call for cookie 0x206C

b43: Link Registers:  lr0 0x03E5 lr1 0x0436 lr2 0x0049 lr3 0x0467

b43: Offset Registers:  off0 0x042C off1 0x0508 off2 0x0374
                        off3 0x0374 off4 0x00EC off5 0x00EC
                        off6 0xEF9F

b43: General Registers:

r00 0x0001  r01 0x0000  r02 0x0004  r03 0x0002  r04 0x0002  r05 0x0002
r06 0x001F  r07 0x03FF  r08 0x001F  r09 0x0000  r10 0x007E  r11 0xE7B4
r12 0x5C36  r13 0x0001  r14 0x0007  r15 0x0000  r16 0x0000  r17 0xAAC2
r18 0x0000  r19 0x0000  r20 0x0000  r21 0x0000  r22 0x0000  r23 0x0000
r24 0x0035  r25 0x4C1D  r26 0x0000  r27 0x000C  r28 0x0001  r29 0x0003
r30 0x0001  r31 0x5714  r32 0x0006  r33 0x013F  r34 0x13C6  r35 0x042C
r36 0x0008  r37 0x0000  r38 0x0002  r39 0x0000  r40 0x0000  r41 0x0000
r42 0x0000  r43 0x0000  r44 0x0000  r45 0x0000  r46 0x0000  r47 0x0000
r48 0x0000  r49 0x0000  r50 0x0000  r51 0x0000  r52 0x0000  r53 0x0000
r54 0x0000  r55 0x0000  r56 0x0000  r57 0x0000  r58 0x0000  r59 0x0000
r60 0x0000  r61 0x0000  r62 0x0000  r63 0x0000

b43: Shared Memory:

0x0000:   0x015F 0x007E 0xFFFF 0x2EC2 0x0000 0x0000 0x0014 0x000A
0x0010:   0x0009 0x0000 0x0080 0x0009 0x0047 0x0047 0x0183 0x0064
0x0020:   0x0930 0xFCC0 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0030:   0x0100 0x0000 0x0002 0x0002 0x0001 0x0004 0x001E 0x0000
0x0040:   0x0002 0x0000 0x0003 0x0002 0x000E 0x0047 0x2800 0x0000
0x0050:   0x0007 0x0002 0xFCC0 0x0582 0x110D 0x7F7F 0x000A 0x0103
0x0060:   0x0000 0x0000 0x0003 0x0000 0x0000 0x0000 0x0000 0x0011
0x0070:   0xF1F1 0xF1F1 0x0001 0x0000 0x0000 0x007E 0xE7B3 0x944F
0x0080:   0x0006 0x2710 0x0000 0x0000 0x1012 0x0F10 0x000C 0x0207
0x0090:   0x0000 0x0000 0x0960 0x00FA 0x0D09 0x080A 0x010D 0x0000
0x00A0:   0x0001 0x0000 0x0000 0x013F 0xFFFF 0x0000 0x0000 0x0000
0x00B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x00C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x00D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x00E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x00F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0100:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0110:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0120:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0130:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0140:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0150:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0160:   0x5242 0x4D43 0x545F 0x5345 0x5F54 0x5353 0x4449 0x0000
0x0170:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0180:   0x0000 0x0000 0x0000 0x0000 0xFCC0 0x0000 0x0000 0x0000
0x0190:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x01A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x01B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x01C0:   0x032E 0x032E 0x032E 0x032E 0x032E 0x032E 0x032E 0x032E
0x01D0:   0x036A 0x0356 0x0342 0x032E 0x0374 0x0360 0x034C 0x0338
0x01E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x01F0:   0x036A 0x0356 0x0342 0x032E 0x036A 0x0356 0x0342 0x0338
0x0200:   0x037E 0x037E 0x037E 0x037E 0x0389 0x037E 0x037E 0x0394
0x0210:   0x037E 0x037E 0x037E 0x037E 0x037E 0x037E 0x039F 0x037E
0x0220:   0x0000 0x0000 0x0000 0x0000 0x0389 0x0000 0x0000 0x0394
0x0230:   0x0000 0x0000 0x037E 0x0000 0x0000 0x0000 0x037E 0x0000
0x0240:   0x0000 0x0001 0x03FF 0x0001 0x0007 0x0001 0x0008 0x0100
0x0250:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0260:   0x0000 0x001F 0x03FF 0x001F 0x0003 0x0013 0x0016 0x0300
0x0270:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0280:   0x0000 0x0001 0x0001 0x0001 0x0002 0x0000 0x0002 0x0100
0x0290:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x02A0:   0x0000 0x000F 0x03FF 0x000F 0x0002 0x000E 0x0010 0x0100
0x02B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x02C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x02D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0002 0x0000
0x02E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x02F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0300:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0310:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0320:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0330:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0340:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0350:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0360:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0370:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0380:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0390:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x03A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x03B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x03C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x03D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x03E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x03F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0400:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0410:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0420:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0430:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0440:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0450:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0460:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0470:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0480:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0490:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x04A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x04B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x04C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x04D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x04E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x04F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0500:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0510:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0520:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0530:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0540:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0550:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0560:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0570:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0580:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0590:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x05A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x05B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x05C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x05D0:   0x0000 0x0000 0x0000 0x0010 0x0020 0x0030 0x0040 0x0050
0x05E0:   0x0060 0x0070 0x0080 0x0090 0x00A0 0x00B0 0x00C0 0x00D0
0x05F0:   0x00E0 0x00F0 0x0100 0x0110 0x0120 0x0130 0x0140 0x0150
0x0600:   0x0160 0x0170 0x0180 0x0190 0x01A0 0x01B0 0x01C0 0x01D0
0x0610:   0x01E0 0x01F0 0x0200 0x0210 0x0220 0x0230 0x0240 0x0250
0x0620:   0x0260 0x0270 0x0280 0x0290 0x02A0 0x02B0 0x02C0 0x02D0
0x0630:   0x02E0 0x02F0 0x0300 0x0310 0x0320 0x0330 0x0340 0x0350
0x0640:   0x0360 0x0370 0x0380 0x0390 0x0000 0x0000 0x0000 0x0000
0x0650:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0020 0x01CB
0x0660:   0x0000 0x0000 0x003C 0x08AB 0x0000 0x0410 0x0084 0x0000
0x0670:   0x0014 0x01CF 0x0002 0x0000 0x0034 0x08AF 0x0002 0x0410
0x0680:   0x0064 0x0000 0x0010 0x01CA 0x0002 0x0000 0x0030 0x08AA
0x0690:   0x0002 0x0410 0x0054 0x0000 0x0008 0x01CE 0x0000 0x0000
0x06A0:   0x002C 0x08AE 0x0000 0x0410 0x0044 0x0000 0x0008 0x01C9
0x06B0:   0x0002 0x0000 0x002C 0x08A9 0x0002 0x0410 0x003C 0x0000
0x06C0:   0x0004 0x01CD 0x0000 0x0000 0x0028 0x08AD 0x0000 0x0410
0x06D0:   0x0034 0x0000 0x0004 0x01C8 0x0000 0x0000 0x0028 0x08A8
0x06E0:   0x0000 0x0410 0x0030 0x0000 0x0000 0x01CC 0x0002 0x0000
0x06F0:   0x0028 0x08AC 0x0002 0x0410 0x0030 0x0000 0x00C0 0x040A
0x0700:   0x0070 0x0000 0x013A 0x040A 0x0228 0xC02C 0x02F2 0x0000
0x0710:   0x0000 0x0060 0x0414 0x0038 0x0000 0x0102 0x0414 0x0114
0x0720:   0xC02C 0x01DE 0x0000 0x0000 0x0022 0x0437 0x0015 0x0000
0x0730:   0x00DF 0x0437 0x0065 0xC02C 0x012E 0x0000 0x0000 0x0011
0x0740:   0x846E 0x000B 0x0000 0x00D4 0x846E 0x0033 0xC02C 0x00FC
0x0750:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0760:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0770:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0780:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0790:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x07A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x07B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x07C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x07D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x07E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x07F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0001 0x0000
0x0800:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0810:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0820:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0830:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0840:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0850:   0x0000 0x0000 0x0000 0x0000 0x0019 0x0000 0x4108 0x0000
0x0860:   0x00C1 0x0000 0x0000 0x0000 0x0000 0x000C 0x0100 0x0000
0x0870:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x1A00
0x0880:   0x4670 0xB1BA 0x0000 0x0000 0x0000 0x0000 0x0000 0x040A
0x0890:   0x3080 0x0000 0x30EA 0x0000 0x0000 0x0000 0x0000 0x0000
0x08A0:   0x200C 0x0000 0x5AA1 0x0AC2 0x0000 0xDCCC 0x0002 0x0004
0x08B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x08C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x08D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x08E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x08F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0900:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0910:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0920:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0930:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0940:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0950:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0960:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0970:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0980:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0990:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x09A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x09B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x09C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x09D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x09E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x09F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0A00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0A10:   0x0D0D 0x0000 0x0000 0x4A08 0x002C 0x1800 0x5E39 0xF990
0x0A20:   0x1A00 0x4670 0xB1BA 0xA000 0x00B0 0xDA0B 0x1C10 0x0963
0x0A30:   0x2000 0x0080 0x0000 0x7EFB 0x086F 0xB1E7 0x6B56 0xDDF7
0x0A40:   0x2171 0x449F 0x1801 0x63EF 0x74AF 0x0613 0xAE21 0x5508
0x0A50:   0xC4F3 0x485C 0xE43D 0xA449 0x7343 0x3B06 0x456D 0xD749
0x0A60:   0xE8C0 0xE0D5 0x6A67 0x24AD 0xF336 0x2BF1 0x8D40 0xC824
0x0A70:   0xCCD6 0x323A 0x3993 0x7147 0xE60D 0x4E89 0xDC20 0x6C27
0x0A80:   0xDE4F 0x2A04 0x196C 0x1642 0xEBCB 0x56E1 0xA6AB 0x7804
0x0A90:   0x006E 0x0000 0x0005 0xDDCC 0xC800 0x0001 0x0002 0x0000
0x0AA0:   0x5C35 0x0062 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0AB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0AC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0AD0:   0x0000 0x0000 0x0000 0x0000 0xE7B3 0x5C70 0x0000 0x0000
0x0AE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0AF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0B00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0B10:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0B20:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0B30:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0B40:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0B50:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0B60:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0B70:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0B80:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0B90:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0BA0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0BB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0BC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0BD0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0BE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0BF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0C00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0C10:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0C20:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0C30:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0C40:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0C50:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0C60:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0C70:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0C80:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0C90:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0CA0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0CB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0CC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0CD0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0CE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0CF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0D00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0D10:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0D20:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0D30:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0D40:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0D50:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0D60:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0D70:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0D80:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0D90:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0DA0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0DB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0DC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0DD0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0DE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0DF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0E00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0E10:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0E20:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0E30:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0E40:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0E50:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0E60:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0E70:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0E80:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0E90:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0EA0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0EB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0EC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0ED0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0EE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0EF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0F00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0F10:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0F20:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0F30:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0F40:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0F50:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0F60:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0F70:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0F80:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0F90:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0FA0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0FB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0FC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0FD0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0FE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
0x0FF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000



From navalorenx at gmail.com  Wed Feb  4 10:22:53 2009
From: navalorenx at gmail.com (Lorenzo Nava)
Date: Wed, 4 Feb 2009 10:22:53 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <498907AE.4040101@lwfinger.net>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>	<4985CB91.9080208@lwfinger.net>	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>	<200902011732.16495.mb@bu3sch.de>
	<75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>
	<4985D76D.9090109@lwfinger.net>
	<C79BD8C7-4CFD-4053-AA37-18C73F2264B2@ing.unibs.it>
	<49866730.40809@lwfinger.net>
	<74057D6E-702D-43D4-BBD9-927B8910699B@ing.unibs.it>
	<498907AE.4040101@lwfinger.net>
Message-ID: <323F97B1-FEDF-47E4-A200-ABFFFB495857@gmail.com>


On Feb 4, 2009, at 4:12 AM, Larry Finger wrote:

> Francesco,
>
> I have coded b43 to dump the microcode PSM when
> b43_dma_handle_txstatus is called for an skb that has already been
> processed and deleted. This dump is for V5.0 of the open firmware and
> includes everything but the PC and condition codes.
>
> I think these data are correct; however, the dump code has not been
> debugged. Please let me know if any of these data are not correct.
>

Hi Larry,

All the registers values look correct: rate tables seems ok, general  
purpose registers ok, rx and tx headers are fine too. The only thing  
that I noticed is that SHM reports a TX header which cookie value is  
0x200C (at 0x08A0). So this means that the dump of the SHM is relative  
to a frame that is different with respect to the one that causes the  
warning.

Where are 0x206C-0x200A frames?

Larry, this problem is presenting only when you stress the device, or  
it always causes crashes the card?

Thank you.

Lorenzo.

> Larry
>
> ==============================================================
>
> b43: b43_dma_handle_txstatus called for deleted skb caused by a double
> call for cookie 0x206C
>
> b43: Link Registers:  lr0 0x03E5 lr1 0x0436 lr2 0x0049 lr3 0x0467
>
> b43: Offset Registers:  off0 0x042C off1 0x0508 off2 0x0374
>                        off3 0x0374 off4 0x00EC off5 0x00EC
>                        off6 0xEF9F
>
> b43: General Registers:
>
> r00 0x0001  r01 0x0000  r02 0x0004  r03 0x0002  r04 0x0002  r05 0x0002
> r06 0x001F  r07 0x03FF  r08 0x001F  r09 0x0000  r10 0x007E  r11 0xE7B4
> r12 0x5C36  r13 0x0001  r14 0x0007  r15 0x0000  r16 0x0000  r17 0xAAC2
> r18 0x0000  r19 0x0000  r20 0x0000  r21 0x0000  r22 0x0000  r23 0x0000
> r24 0x0035  r25 0x4C1D  r26 0x0000  r27 0x000C  r28 0x0001  r29 0x0003
> r30 0x0001  r31 0x5714  r32 0x0006  r33 0x013F  r34 0x13C6  r35 0x042C
> r36 0x0008  r37 0x0000  r38 0x0002  r39 0x0000  r40 0x0000  r41 0x0000
> r42 0x0000  r43 0x0000  r44 0x0000  r45 0x0000  r46 0x0000  r47 0x0000
> r48 0x0000  r49 0x0000  r50 0x0000  r51 0x0000  r52 0x0000  r53 0x0000
> r54 0x0000  r55 0x0000  r56 0x0000  r57 0x0000  r58 0x0000  r59 0x0000
> r60 0x0000  r61 0x0000  r62 0x0000  r63 0x0000
>
> b43: Shared Memory:
>
> 0x0000:   0x015F 0x007E 0xFFFF 0x2EC2 0x0000 0x0000 0x0014 0x000A
> 0x0010:   0x0009 0x0000 0x0080 0x0009 0x0047 0x0047 0x0183 0x0064
> 0x0020:   0x0930 0xFCC0 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0030:   0x0100 0x0000 0x0002 0x0002 0x0001 0x0004 0x001E 0x0000
> 0x0040:   0x0002 0x0000 0x0003 0x0002 0x000E 0x0047 0x2800 0x0000
> 0x0050:   0x0007 0x0002 0xFCC0 0x0582 0x110D 0x7F7F 0x000A 0x0103
> 0x0060:   0x0000 0x0000 0x0003 0x0000 0x0000 0x0000 0x0000 0x0011
> 0x0070:   0xF1F1 0xF1F1 0x0001 0x0000 0x0000 0x007E 0xE7B3 0x944F
> 0x0080:   0x0006 0x2710 0x0000 0x0000 0x1012 0x0F10 0x000C 0x0207
> 0x0090:   0x0000 0x0000 0x0960 0x00FA 0x0D09 0x080A 0x010D 0x0000
> 0x00A0:   0x0001 0x0000 0x0000 0x013F 0xFFFF 0x0000 0x0000 0x0000
> 0x00B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x00C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x00D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x00E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x00F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0100:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0110:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0120:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0130:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0140:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0150:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0160:   0x5242 0x4D43 0x545F 0x5345 0x5F54 0x5353 0x4449 0x0000
> 0x0170:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0180:   0x0000 0x0000 0x0000 0x0000 0xFCC0 0x0000 0x0000 0x0000
> 0x0190:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x01A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x01B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x01C0:   0x032E 0x032E 0x032E 0x032E 0x032E 0x032E 0x032E 0x032E
> 0x01D0:   0x036A 0x0356 0x0342 0x032E 0x0374 0x0360 0x034C 0x0338
> 0x01E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x01F0:   0x036A 0x0356 0x0342 0x032E 0x036A 0x0356 0x0342 0x0338
> 0x0200:   0x037E 0x037E 0x037E 0x037E 0x0389 0x037E 0x037E 0x0394
> 0x0210:   0x037E 0x037E 0x037E 0x037E 0x037E 0x037E 0x039F 0x037E
> 0x0220:   0x0000 0x0000 0x0000 0x0000 0x0389 0x0000 0x0000 0x0394
> 0x0230:   0x0000 0x0000 0x037E 0x0000 0x0000 0x0000 0x037E 0x0000
> 0x0240:   0x0000 0x0001 0x03FF 0x0001 0x0007 0x0001 0x0008 0x0100
> 0x0250:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0260:   0x0000 0x001F 0x03FF 0x001F 0x0003 0x0013 0x0016 0x0300
> 0x0270:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0280:   0x0000 0x0001 0x0001 0x0001 0x0002 0x0000 0x0002 0x0100
> 0x0290:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x02A0:   0x0000 0x000F 0x03FF 0x000F 0x0002 0x000E 0x0010 0x0100
> 0x02B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x02C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x02D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0002 0x0000
> 0x02E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x02F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0300:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0310:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0320:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0330:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0340:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0350:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0360:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0370:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0380:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0390:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x03A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x03B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x03C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x03D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x03E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x03F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0400:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0410:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0420:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0430:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0440:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0450:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0460:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0470:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0480:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0490:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x04A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x04B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x04C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x04D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x04E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x04F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0500:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0510:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0520:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0530:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0540:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0550:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0560:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0570:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0580:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0590:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x05A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x05B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x05C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x05D0:   0x0000 0x0000 0x0000 0x0010 0x0020 0x0030 0x0040 0x0050
> 0x05E0:   0x0060 0x0070 0x0080 0x0090 0x00A0 0x00B0 0x00C0 0x00D0
> 0x05F0:   0x00E0 0x00F0 0x0100 0x0110 0x0120 0x0130 0x0140 0x0150
> 0x0600:   0x0160 0x0170 0x0180 0x0190 0x01A0 0x01B0 0x01C0 0x01D0
> 0x0610:   0x01E0 0x01F0 0x0200 0x0210 0x0220 0x0230 0x0240 0x0250
> 0x0620:   0x0260 0x0270 0x0280 0x0290 0x02A0 0x02B0 0x02C0 0x02D0
> 0x0630:   0x02E0 0x02F0 0x0300 0x0310 0x0320 0x0330 0x0340 0x0350
> 0x0640:   0x0360 0x0370 0x0380 0x0390 0x0000 0x0000 0x0000 0x0000
> 0x0650:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0020 0x01CB
> 0x0660:   0x0000 0x0000 0x003C 0x08AB 0x0000 0x0410 0x0084 0x0000
> 0x0670:   0x0014 0x01CF 0x0002 0x0000 0x0034 0x08AF 0x0002 0x0410
> 0x0680:   0x0064 0x0000 0x0010 0x01CA 0x0002 0x0000 0x0030 0x08AA
> 0x0690:   0x0002 0x0410 0x0054 0x0000 0x0008 0x01CE 0x0000 0x0000
> 0x06A0:   0x002C 0x08AE 0x0000 0x0410 0x0044 0x0000 0x0008 0x01C9
> 0x06B0:   0x0002 0x0000 0x002C 0x08A9 0x0002 0x0410 0x003C 0x0000
> 0x06C0:   0x0004 0x01CD 0x0000 0x0000 0x0028 0x08AD 0x0000 0x0410
> 0x06D0:   0x0034 0x0000 0x0004 0x01C8 0x0000 0x0000 0x0028 0x08A8
> 0x06E0:   0x0000 0x0410 0x0030 0x0000 0x0000 0x01CC 0x0002 0x0000
> 0x06F0:   0x0028 0x08AC 0x0002 0x0410 0x0030 0x0000 0x00C0 0x040A
> 0x0700:   0x0070 0x0000 0x013A 0x040A 0x0228 0xC02C 0x02F2 0x0000
> 0x0710:   0x0000 0x0060 0x0414 0x0038 0x0000 0x0102 0x0414 0x0114
> 0x0720:   0xC02C 0x01DE 0x0000 0x0000 0x0022 0x0437 0x0015 0x0000
> 0x0730:   0x00DF 0x0437 0x0065 0xC02C 0x012E 0x0000 0x0000 0x0011
> 0x0740:   0x846E 0x000B 0x0000 0x00D4 0x846E 0x0033 0xC02C 0x00FC
> 0x0750:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0760:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0770:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0780:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0790:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x07A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x07B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x07C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x07D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x07E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x07F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0001 0x0000
> 0x0800:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0810:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0820:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0830:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0840:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0850:   0x0000 0x0000 0x0000 0x0000 0x0019 0x0000 0x4108 0x0000
> 0x0860:   0x00C1 0x0000 0x0000 0x0000 0x0000 0x000C 0x0100 0x0000
> 0x0870:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x1A00
> 0x0880:   0x4670 0xB1BA 0x0000 0x0000 0x0000 0x0000 0x0000 0x040A
> 0x0890:   0x3080 0x0000 0x30EA 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x08A0:   0x200C 0x0000 0x5AA1 0x0AC2 0x0000 0xDCCC 0x0002 0x0004
> 0x08B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x08C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x08D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x08E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x08F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0900:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0910:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0920:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0930:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0940:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0950:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0960:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0970:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0980:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0990:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x09A0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x09B0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x09C0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x09D0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x09E0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x09F0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0A00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0A10:   0x0D0D 0x0000 0x0000 0x4A08 0x002C 0x1800 0x5E39 0xF990
> 0x0A20:   0x1A00 0x4670 0xB1BA 0xA000 0x00B0 0xDA0B 0x1C10 0x0963
> 0x0A30:   0x2000 0x0080 0x0000 0x7EFB 0x086F 0xB1E7 0x6B56 0xDDF7
> 0x0A40:   0x2171 0x449F 0x1801 0x63EF 0x74AF 0x0613 0xAE21 0x5508
> 0x0A50:   0xC4F3 0x485C 0xE43D 0xA449 0x7343 0x3B06 0x456D 0xD749
> 0x0A60:   0xE8C0 0xE0D5 0x6A67 0x24AD 0xF336 0x2BF1 0x8D40 0xC824
> 0x0A70:   0xCCD6 0x323A 0x3993 0x7147 0xE60D 0x4E89 0xDC20 0x6C27
> 0x0A80:   0xDE4F 0x2A04 0x196C 0x1642 0xEBCB 0x56E1 0xA6AB 0x7804
> 0x0A90:   0x006E 0x0000 0x0005 0xDDCC 0xC800 0x0001 0x0002 0x0000
> 0x0AA0:   0x5C35 0x0062 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0AB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0AC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0AD0:   0x0000 0x0000 0x0000 0x0000 0xE7B3 0x5C70 0x0000 0x0000
> 0x0AE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0AF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0B00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0B10:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0B20:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0B30:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0B40:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0B50:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0B60:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0B70:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0B80:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0B90:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0BA0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0BB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0BC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0BD0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0BE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0BF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0C00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0C10:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0C20:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0C30:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0C40:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0C50:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0C60:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0C70:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0C80:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0C90:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0CA0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0CB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0CC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0CD0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0CE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0CF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0D00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0D10:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0D20:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0D30:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0D40:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0D50:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0D60:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0D70:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0D80:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0D90:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0DA0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0DB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0DC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0DD0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0DE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0DF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0E00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0E10:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0E20:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0E30:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0E40:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0E50:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0E60:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0E70:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0E80:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0E90:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0EA0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0EB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0EC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0ED0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0EE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0EF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0F00:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0F10:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0F20:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0F30:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0F40:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0F50:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0F60:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0F70:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0F80:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0F90:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0FA0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0FB0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0FC0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0FD0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0FE0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
> 0x0FF0:   0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev



From Larry.Finger at lwfinger.net  Wed Feb  4 16:00:14 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 04 Feb 2009 09:00:14 -0600
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <323F97B1-FEDF-47E4-A200-ABFFFB495857@gmail.com>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>	<4985CB91.9080208@lwfinger.net>	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>	<200902011732.16495.mb@bu3sch.de>
	<75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>
	<4985D76D.9090109@lwfinger.net>
	<C79BD8C7-4CFD-4053-AA37-18C73F2264B2@ing.unibs.it>
	<49866730.40809@lwfinger.net>
	<74057D6E-702D-43D4-BBD9-927B8910699B@ing.unibs.it>
	<498907AE.4040101@lwfinger.net>
	<323F97B1-FEDF-47E4-A200-ABFFFB495857@gmail.com>
Message-ID: <4989AD7E.3010402@lwfinger.net>

Lorenzo Nava wrote:
> All the registers values look correct: rate tables seems ok, general
> purpose registers ok, rx and tx headers are fine too. The only thing
> that I noticed is that SHM reports a TX header which cookie value is
> 0x200C (at 0x08A0). So this means that the dump of the SHM is relative
> to a frame that is different with respect to the one that causes the
> warning.
> 
> Where are 0x206C-0x200A frames?
> 
> Larry, this problem is presenting only when you stress the device, or it
> always causes crashes the card?

In previous crashes, there has always been a number of queued
tx_status responses. Perhaps the missing cookies were there. This time
I stopped the microcode CPU and never restarted it, but now that it
looks as if the dump is OK, I will start it again right after the dump.

So far, I have only seen these crashes when I stress the device using
two transmit streams - one with small packets (a flood ping) and one
with large packets (the tcpperf test). Even then, it has taken as long
as 7 hours to cause the crash. On other occasions, it takes just
minutes. The bug must have only a narrow window to trigger. In
addition, these tests were the first ones I tried.

FWIW, the proprietary firmware ran my test for 12 hours without failing.

Do you suggest any additional checks in the tx_status routine? Could I
compare the received cookie with some part of SHM?

Larry


From mb at bu3sch.de  Wed Feb  4 17:08:01 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 4 Feb 2009 17:08:01 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <498907AE.4040101@lwfinger.net>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<74057D6E-702D-43D4-BBD9-927B8910699B@ing.unibs.it>
	<498907AE.4040101@lwfinger.net>
Message-ID: <200902041708.01403.mb@bu3sch.de>

On Wednesday 04 February 2009 04:12:46 Larry Finger wrote:
> Francesco,
> 
> I have coded b43 to dump the microcode PSM when
> b43_dma_handle_txstatus is called for an skb that has already been
> processed and deleted. This dump is for V5.0 of the open firmware and
> includes everything but the PC and condition codes.

You can get the PC from the debug register. However, this stuff is asynchronous
wrt to the firmware. So the PC would have absolutely no meaning.
The interrupt takes a few microseconds to trigger and the bottom half
probably takes up to a few milliseconds. So the firmware will have advanced a lot
until you dump the state.

For this reason I introduced the synchronous debug-irq. With this IRQ it's
possible to synchronously send events to the driver and dump some state in
a consistent way. However, it requires firmware support, of course.

We cannot read the conditions without help of the firmware. Or at least, we don't
know how to, if it's possible somehow.

-- 
Greetings, Michael.


From mb at bu3sch.de  Wed Feb  4 17:09:48 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 4 Feb 2009 17:09:48 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <323F97B1-FEDF-47E4-A200-ABFFFB495857@gmail.com>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>
	<498907AE.4040101@lwfinger.net>
	<323F97B1-FEDF-47E4-A200-ABFFFB495857@gmail.com>
Message-ID: <200902041709.48448.mb@bu3sch.de>

On Wednesday 04 February 2009 10:22:53 Lorenzo Nava wrote:
> 
> On Feb 4, 2009, at 4:12 AM, Larry Finger wrote:
> 
> > Francesco,
> >
> > I have coded b43 to dump the microcode PSM when
> > b43_dma_handle_txstatus is called for an skb that has already been
> > processed and deleted. This dump is for V5.0 of the open firmware and
> > includes everything but the PC and condition codes.
> >
> > I think these data are correct; however, the dump code has not been
> > debugged. Please let me know if any of these data are not correct.
> >
> 
> Hi Larry,
> 
> All the registers values look correct: rate tables seems ok, general  
> purpose registers ok, rx and tx headers are fine too. The only thing  
> that I noticed is that SHM reports a TX header which cookie value is  
> 0x200C (at 0x08A0). So this means that the dump of the SHM is relative  
> to a frame that is different with respect to the one that causes the  
> warning.
> 
> Where are 0x206C-0x200A frames?

Note that the dump is asynchronous wrt to the bug. The firmware will have advanced
to the next frame(s) when the interrupt reaches the CPU.

-- 
Greetings, Michael.


From mb at bu3sch.de  Wed Feb  4 19:55:22 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 4 Feb 2009 19:55:22 +0100
Subject: [PATCH] b43: Add parts of LP-PHY TX power control
Message-ID: <200902041955.22517.mb@bu3sch.de>

This adds the initial parts of the LP-PHY TX power control.
This also adds helper functions for bulk access of LP tables.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---


Index: wireless-testing/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/b43.h	2009-02-04 19:45:13.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/b43.h	2009-02-04 19:47:39.000000000 +0100
@@ -120,6 +120,9 @@
 #define B43_MMIO_IFSCTL			0x688 /* Interframe space control */
 #define  B43_MMIO_IFSCTL_USE_EDCF	0x0004
 #define B43_MMIO_POWERUP_DELAY		0x6A8
+#define B43_MMIO_BTCOEX_CTL		0x6B4 /* Bluetooth Coexistence Control */
+#define B43_MMIO_BTCOEX_STAT		0x6B6 /* Bluetooth Coexistence Status */
+#define B43_MMIO_BTCOEX_TXCTL		0x6B8 /* Bluetooth Coexistence Transmit Control */
 
 /* SPROM boardflags_lo values */
 #define B43_BFL_BTCOEXIST		0x0001	/* implements Bluetooth coexistance */
Index: wireless-testing/drivers/net/wireless/b43/phy_lp.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_lp.c	2009-02-04 19:45:13.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_lp.c	2009-02-04 19:47:39.000000000 +0100
@@ -23,6 +23,7 @@
 */
 
 #include "b43.h"
+#include "main.h"
 #include "phy_lp.h"
 #include "phy_common.h"
 #include "tables_lpphy.h"
@@ -267,13 +268,185 @@ static void lpphy_radio_init(struct b43_
 	}
 }
 
+/* Read the TX power control mode from hardware. */
+static void lpphy_read_tx_pctl_mode_from_hardware(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	u16 ctl;
+
+	ctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD);
+	switch (ctl & B43_LPPHY_TX_PWR_CTL_CMD_MODE) {
+	case B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF:
+		lpphy->txpctl_mode = B43_LPPHY_TXPCTL_OFF;
+		break;
+	case B43_LPPHY_TX_PWR_CTL_CMD_MODE_SW:
+		lpphy->txpctl_mode = B43_LPPHY_TXPCTL_SW;
+		break;
+	case B43_LPPHY_TX_PWR_CTL_CMD_MODE_HW:
+		lpphy->txpctl_mode = B43_LPPHY_TXPCTL_HW;
+		break;
+	default:
+		lpphy->txpctl_mode = B43_LPPHY_TXPCTL_UNKNOWN;
+		B43_WARN_ON(1);
+		break;
+	}
+}
+
+/* Set the TX power control mode in hardware. */
+static void lpphy_write_tx_pctl_mode_to_hardware(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	u16 ctl;
+
+	switch (lpphy->txpctl_mode) {
+	case B43_LPPHY_TXPCTL_OFF:
+		ctl = B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF;
+		break;
+	case B43_LPPHY_TXPCTL_HW:
+		ctl = B43_LPPHY_TX_PWR_CTL_CMD_MODE_HW;
+		break;
+	case B43_LPPHY_TXPCTL_SW:
+		ctl = B43_LPPHY_TX_PWR_CTL_CMD_MODE_SW;
+		break;
+	default:
+		ctl = 0;
+		B43_WARN_ON(1);
+	}
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_CMD,
+			(u16)~B43_LPPHY_TX_PWR_CTL_CMD_MODE, ctl);
+}
+
+static void lpphy_set_tx_power_control(struct b43_wldev *dev,
+				       enum b43_lpphy_txpctl_mode mode)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	enum b43_lpphy_txpctl_mode oldmode;
+
+	oldmode = lpphy->txpctl_mode;
+	lpphy_read_tx_pctl_mode_from_hardware(dev);
+	if (lpphy->txpctl_mode == mode)
+		return;
+	lpphy->txpctl_mode = mode;
+
+	if (oldmode == B43_LPPHY_TXPCTL_HW) {
+		//TODO Update TX Power NPT
+		//TODO Clear all TX Power offsets
+	} else {
+		if (mode == B43_LPPHY_TXPCTL_HW) {
+			//TODO Recalculate target TX power
+			b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_CMD,
+					0xFF80, lpphy->tssi_idx);
+			b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_NNUM,
+					0x8FFF, ((u16)lpphy->tssi_npt << 16));
+			//TODO Set "TSSI Transmit Count" variable to total transmitted frame count
+			//TODO Disable TX gain override
+			lpphy->tx_pwr_idx_over = -1;
+		}
+	}
+	if (dev->phy.rev >= 2) {
+		if (mode == B43_LPPHY_TXPCTL_HW)
+			b43_phy_maskset(dev, B43_PHY_OFDM(0xD0), 0xFD, 0x2);
+		else
+			b43_phy_maskset(dev, B43_PHY_OFDM(0xD0), 0xFD, 0);
+	}
+	lpphy_write_tx_pctl_mode_to_hardware(dev);
+}
+
+static void lpphy_set_tx_power_by_index(struct b43_wldev *dev, u8 index)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+
+	lpphy->tx_pwr_idx_over = index;
+	if (lpphy->txpctl_mode != B43_LPPHY_TXPCTL_OFF)
+		lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_SW);
+
+	//TODO
+}
+
+static void lpphy_btcoex_override(struct b43_wldev *dev)
+{
+	b43_write16(dev, B43_MMIO_BTCOEX_CTL, 0x3);
+	b43_write16(dev, B43_MMIO_BTCOEX_TXCTL, 0xFF);
+}
+
+static void lpphy_pr41573_workaround(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	u32 *saved_tab;
+	const unsigned int saved_tab_size = 256;
+	enum b43_lpphy_txpctl_mode txpctl_mode;
+	s8 tx_pwr_idx_over;
+	u16 tssi_npt, tssi_idx;
+
+	saved_tab = kcalloc(saved_tab_size, sizeof(saved_tab[0]), GFP_KERNEL);
+	if (!saved_tab) {
+		b43err(dev->wl, "PR41573 failed. Out of memory!\n");
+		return;
+	}
+
+	lpphy_read_tx_pctl_mode_from_hardware(dev);
+	txpctl_mode = lpphy->txpctl_mode;
+	tx_pwr_idx_over = lpphy->tx_pwr_idx_over;
+	tssi_npt = lpphy->tssi_npt;
+	tssi_idx = lpphy->tssi_idx;
+
+	if (dev->phy.rev < 2) {
+		b43_lptab_read_bulk(dev, B43_LPTAB32(10, 0x140),
+				    saved_tab_size, saved_tab);
+	} else {
+		b43_lptab_read_bulk(dev, B43_LPTAB32(7, 0x140),
+				    saved_tab_size, saved_tab);
+	}
+	//TODO
+
+	kfree(saved_tab);
+}
+
+static void lpphy_calibration(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	enum b43_lpphy_txpctl_mode saved_pctl_mode;
+
+	b43_mac_suspend(dev);
+
+	lpphy_btcoex_override(dev);
+	lpphy_read_tx_pctl_mode_from_hardware(dev);
+	saved_pctl_mode = lpphy->txpctl_mode;
+	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
+	//TODO Perform transmit power table I/Q LO calibration
+	if ((dev->phy.rev == 0) && (saved_pctl_mode != B43_LPPHY_TXPCTL_OFF))
+		lpphy_pr41573_workaround(dev);
+	//TODO If a full calibration has not been performed on this channel yet, perform PAPD TX-power calibration
+	lpphy_set_tx_power_control(dev, saved_pctl_mode);
+	//TODO Perform I/Q calibration with a single control value set
+
+	b43_mac_enable(dev);
+}
+
+/* Initialize TX power control */
+static void lpphy_tx_pctl_init(struct b43_wldev *dev)
+{
+	if (0/*FIXME HWPCTL capable */) {
+		//TODO
+	} else { /* This device is only software TX power control capable. */
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+			//TODO
+		} else {
+			//TODO
+		}
+		//TODO set BB multiplier to 0x0096
+	}
+}
+
 static int b43_lpphy_op_init(struct b43_wldev *dev)
 {
 	/* TODO: band SPROM */
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
-
-	//TODO
+	//TODO calibrate RC
+	//TODO set channel
+	lpphy_tx_pctl_init(dev);
+	//TODO full calib
 
 	return 0;
 }
Index: wireless-testing/drivers/net/wireless/b43/phy_lp.h
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_lp.h	2009-02-04 19:45:13.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_lp.h	2009-02-04 19:47:39.000000000 +0100
@@ -247,6 +247,10 @@
 #define B43_LPPHY_FOURWIRE_CTL			B43_PHY_OFDM(0xA2) /* fourwire Control */
 #define B43_LPPHY_CPA_TAILCOUNT_VAL		B43_PHY_OFDM(0xA3) /* CPA TailCount Value */
 #define B43_LPPHY_TX_PWR_CTL_CMD		B43_PHY_OFDM(0xA4) /* TX Power Control Cmd */
+#define  B43_LPPHY_TX_PWR_CTL_CMD_MODE		0xE000 /* TX power control mode mask */
+#define   B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF	0x0000 /* TX power control is OFF */
+#define   B43_LPPHY_TX_PWR_CTL_CMD_MODE_SW	0x8000 /* TX power control is SOFTWARE */
+#define   B43_LPPHY_TX_PWR_CTL_CMD_MODE_HW	0xE000 /* TX power control is HARDWARE */
 #define B43_LPPHY_TX_PWR_CTL_NNUM		B43_PHY_OFDM(0xA5) /* TX Power Control Nnum */
 #define B43_LPPHY_TX_PWR_CTL_IDLETSSI		B43_PHY_OFDM(0xA6) /* TX Power Control IdleTssi */
 #define B43_LPPHY_TX_PWR_CTL_TARGETPWR		B43_PHY_OFDM(0xA7) /* TX Power Control TargetPower */
@@ -802,7 +806,17 @@
 
 
 
+enum b43_lpphy_txpctl_mode {
+	B43_LPPHY_TXPCTL_UNKNOWN = 0,
+	B43_LPPHY_TXPCTL_OFF,	/* TX power control is OFF */
+	B43_LPPHY_TXPCTL_SW,	/* TX power control is set to Software */
+	B43_LPPHY_TXPCTL_HW,	/* TX power control is set to Hardware */
+};
+
 struct b43_phy_lp {
+	/* Current TX power control mode. */
+	enum b43_lpphy_txpctl_mode txpctl_mode;
+
 	/* Transmit isolation medium band */
 	u8 tx_isolation_med_band; /* FIXME initial value? */
 	/* Transmit isolation low band */
@@ -814,7 +828,7 @@ struct b43_phy_lp {
 	u8 rx_pwr_offset; /* FIXME initial value? */
 
 	/* TSSI transmit count */
-	u16 tssi_tx_count; /* FIXME initial value? */
+	u16 tssi_tx_count;
 	/* TSSI index */
 	u16 tssi_idx; /* FIXME initial value? */
 	/* TSSI npt */
Index: wireless-testing/drivers/net/wireless/b43/tables_lpphy.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/tables_lpphy.c	2009-02-04 19:45:13.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/tables_lpphy.c	2009-02-04 19:47:39.000000000 +0100
@@ -303,6 +303,36 @@ u32 b43_lptab_read(struct b43_wldev *dev
 	return value;
 }
 
+void b43_lptab_read_bulk(struct b43_wldev *dev, u32 offset,
+			 unsigned int nr_elements, void *_data)
+{
+	u32 type, value;
+	u8 *data = _data;
+	unsigned int i;
+
+	type = offset & B43_LPTAB_TYPEMASK;
+	for (i = 0; i < nr_elements; i++) {
+		value = b43_lptab_read(dev, offset);
+		switch (type) {
+		case B43_LPTAB_8BIT:
+			*data = value;
+			data++;
+			break;
+		case B43_LPTAB_16BIT:
+			*((u16 *)data) = value;
+			data += 2;
+			break;
+		case B43_LPTAB_32BIT:
+			*((u32 *)data) = value;
+			data += 4;
+			break;
+		default:
+			B43_WARN_ON(1);
+		}
+		offset++;
+	}
+}
+
 void b43_lptab_write(struct b43_wldev *dev, u32 offset, u32 value)
 {
 	u32 type;
@@ -331,3 +361,34 @@ void b43_lptab_write(struct b43_wldev *d
 		B43_WARN_ON(1);
 	}
 }
+
+void b43_lptab_write_bulk(struct b43_wldev *dev, u32 offset,
+			  unsigned int nr_elements, const void *_data)
+{
+	u32 type, value;
+	const u8 *data = _data;
+	unsigned int i;
+
+	type = offset & B43_LPTAB_TYPEMASK;
+	for (i = 0; i < nr_elements; i++) {
+		switch (type) {
+		case B43_LPTAB_8BIT:
+			value = *data;
+			data++;
+			break;
+		case B43_LPTAB_16BIT:
+			value = *((u16 *)data);
+			data += 2;
+			break;
+		case B43_LPTAB_32BIT:
+			value = *((u32 *)data);
+			data += 4;
+			break;
+		default:
+			B43_WARN_ON(1);
+			value = 0;
+		}
+		b43_lptab_write(dev, offset, value);
+		offset++;
+	}
+}
Index: wireless-testing/drivers/net/wireless/b43/tables_lpphy.h
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/tables_lpphy.h	2009-02-04 19:45:13.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/tables_lpphy.h	2009-02-04 19:47:39.000000000 +0100
@@ -17,6 +17,14 @@
 u32 b43_lptab_read(struct b43_wldev *dev, u32 offset);
 void b43_lptab_write(struct b43_wldev *dev, u32 offset, u32 value);
 
+/* Bulk table access. Note that these functions return the bulk data in
+ * host endianness! The returned data is _not_ a bytearray, but an array
+ * consisting of nr_elements of the data type. */
+void b43_lptab_read_bulk(struct b43_wldev *dev, u32 offset,
+			 unsigned int nr_elements, void *data);
+void b43_lptab_write_bulk(struct b43_wldev *dev, u32 offset,
+			  unsigned int nr_elements, const void *data);
+
 void b2062_upload_init_table(struct b43_wldev *dev);
 
 

-- 
Greetings, Michael.


From ccmcphe at verizon.net  Thu Feb  5 22:17:48 2009
From: ccmcphe at verizon.net (Tex)
Date: Thu, 05 Feb 2009 16:17:48 -0500
Subject: Cardbus wireless cards
In-Reply-To: <1233666319.3957.1.camel@johannes.local>
References: <1233666319.3957.1.camel@johannes.local>
Message-ID: <498B577C.8050803@verizon.net>

Johannes Berg wrote:
> Hi,
>
> Some of you know that I got a new laptop, and it doesn't have a cardbus
> slot any more. I still have my powerbook, and it's still working fine,
> but I'm not using it any more, it hasn't even booted in a month. I could
> test on my powerbook, but given my regular time budget it seems unlikely
> that I ever will.
>
> Hence, I'm offering my collection of cardbus/pcmcia wireless test cards
> to anyone I can afford shipping to.
>
> * Broadcom PCMCIA (not cardbus, in cardbus slot adapter)
>   requires external single antenna (u.fl, have one if I can find it)
> * Airgo-based Belkin F5D8010 ("true MIMO")
> * rt61pci (Conceptronic)
> * Broadcom 11n (4321)
> * acx111 based card (D-Link AirPlus XTreme G+)
>
> I also have a Broadcom 11g (4306 I think, might be 4318) PCI card
> somewhere that I will most likely never again have a use for.
>
> johannes
>   
> ------------------------------------------------------------------------
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
If the US is inside the afford area, I would be interested in the 
Broadcom 4321.

-Tex




From Larry.Finger at lwfinger.net  Tue Feb 10 21:59:38 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 10 Feb 2009 14:59:38 -0600
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <C79BD8C7-4CFD-4053-AA37-18C73F2264B2@ing.unibs.it>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>	<4985CB91.9080208@lwfinger.net>	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>	<200902011732.16495.mb@bu3sch.de>
	<75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>
	<4985D76D.9090109@lwfinger.net>
	<C79BD8C7-4CFD-4053-AA37-18C73F2264B2@ing.unibs.it>
Message-ID: <4991EABA.3040403@lwfinger.net>

Francesco and Lorenzo,

I now know a little more about my firmware crash. This time I captured the
tx_status from each call just before the callback into mac80211. When the
routine was called with the deleted/poisoned skb, I dumped the current status
and the saved one. The results were:

b43_dma_handle_txstatus called for deleted cookie 0x2004

Parameter  saved_status  status
cookie      0x2022       0x2004
seq         0x151        0x142
phy_stat    0x0          0x0
frame_count 0x1          0x1
rts_count   0x0          0x0
supp_reason 0x0          0x0
pm_indicat  0x0          0x0
for_ampdu   0x0          0x0
acked       0x1          0x1

Clearly quite a few transaction took place between the time that the skb with
cookie 0x2004 was deleted and the erroring callback. The cookie count increased
by 30 and the sequence by 15. I'm pretty sure that this means 15 total packets
were handled in the interim.

Unless this report results in an immediate "light bulb" moment, I plan to buffer
at least 32 status values so that we can see the details of all transactions
between the first and second calls with the cookie associated with the deleted
skb. Are there any other parameters I should also buffer?

Larry


From navalorenx at gmail.com  Wed Feb 11 09:51:59 2009
From: navalorenx at gmail.com (Lorenzo Nava)
Date: Wed, 11 Feb 2009 09:51:59 +0100
Subject: opensource firmware now accept version 410 frames
In-Reply-To: <4991EABA.3040403@lwfinger.net>
References: <4F39B4BD-5067-40B8-975E-465931E1409E@ing.unibs.it>	<4985CB91.9080208@lwfinger.net>	<D4387503-A0A3-4C5F-890E-01C63C888EC1@ing.unibs.it>	<200902011732.16495.mb@bu3sch.de>
	<75E1EA3E-F148-4D65-AC4B-D62BB3899B96@ing.unibs.it>
	<4985D76D.9090109@lwfinger.net>
	<C79BD8C7-4CFD-4053-AA37-18C73F2264B2@ing.unibs.it>
	<4991EABA.3040403@lwfinger.net>
Message-ID: <3153348B-4B4E-46DB-AF11-0129C59D6711@gmail.com>


On Feb 10, 2009, at 9:59 PM, Larry Finger wrote:

> Francesco and Lorenzo,
>
> I now know a little more about my firmware crash. This time I  
> captured the
> tx_status from each call just before the callback into mac80211.  
> When the
> routine was called with the deleted/poisoned skb, I dumped the  
> current status
> and the saved one. The results were:
>
> b43_dma_handle_txstatus called for deleted cookie 0x2004
>
> Parameter  saved_status  status
> cookie      0x2022       0x2004
> seq         0x151        0x142
> phy_stat    0x0          0x0
> frame_count 0x1          0x1
> rts_count   0x0          0x0
> supp_reason 0x0          0x0
> pm_indicat  0x0          0x0
> for_ampdu   0x0          0x0
> acked       0x1          0x1
>
> Clearly quite a few transaction took place between the time that the  
> skb with
> cookie 0x2004 was deleted and the erroring callback. The cookie  
> count increased
> by 30 and the sequence by 15. I'm pretty sure that this means 15  
> total packets
> were handled in the interim.

Yes it is correct.

>
>
> Unless this report results in an immediate "light bulb" moment, I  
> plan to buffer
> at least 32 status values so that we can see the details of all  
> transactions
> between the first and second calls with the cookie associated with  
> the deleted
> skb. Are there any other parameters I should also buffer?
>

Let's start with these parameters and see what happen.

Thank you

cheers

Lorenzo

> Larry



From alukardx at gmail.com  Fri Feb 13 23:35:22 2009
From: alukardx at gmail.com ( tR3nt R32n0r )
Date: Fri, 13 Feb 2009 23:35:22 +0100
Subject: Problems sniffing custom frames with b43
Message-ID: <7a8182770902131435i3fb6194r1712d5a1ffb9b96@mail.gmail.com>

Hi all,

I'm using an Asus card WL-138G v2 PCI with b43 driver and a 2.6.27 kernel
version. Tryng to sniff packets with this card set in monitor mode I found
that every packet in the air was recognized via Wireshark except the ones I
made and sent with pcap library tools froma another peer. The packets are
really sent because they can be read from the media with another cards such
as D-link 11n usb or Atheros mini PCI, but it seems like there is somewhere
where the incomming packets are filtered. I don't know how to solve this
problem. Maybe it is because the driver only recognizes "standard" frames
such as the ones made for management, but I don't know it for sure. My
frames include the 802.11 header describing the frame as management frame
type, using a non defined subtype. Can anybody help me?

Thanks!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20090213/1e6c0870/attachment.html>

From francesco.gringoli at ing.unibs.it  Sat Feb 14 00:55:05 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Sat, 14 Feb 2009 00:55:05 +0100
Subject: Problems sniffing custom frames with b43
In-Reply-To: <7a8182770902131435i3fb6194r1712d5a1ffb9b96@mail.gmail.com>
References: <7a8182770902131435i3fb6194r1712d5a1ffb9b96@mail.gmail.com>
Message-ID: <0CD076C1-4E74-4E4A-8DAF-8ADE49AD19F9@ing.unibs.it>

On Feb 13, 2009, at 11:35 PM, [ tR3nt R32n0r ] wrote:

> Hi all,
>
> I'm using an Asus card WL-138G v2 PCI with b43 driver and a 2.6.27  
> kernel version. Tryng to sniff packets with this card set in monitor  
> mode I found that every packet in the air was recognized via  
> Wireshark except the ones I made and sent with pcap library tools  
> froma another peer. The packets are really sent because they can be  
> read from the media with another cards such as D-link 11n usb or  
> Atheros mini PCI, but it seems like there is somewhere where the  
> incomming packets are filtered. I don't know how to solve this  
> problem. Maybe it is because the driver only recognizes "standard"  
> frames such as the ones made for management, but I don't know it for  
> sure. My frames include the 802.11 header describing the frame as  
> management frame type, using a non defined subtype. Can anybody help  
> me?
Hi,

could you please attach the wireshark dump of the packet as received  
by the atheros board? Start from the 802.11 header.

Cheers,
-FG
>
>
> Thanks!
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20090214/e64f78a6/attachment.html>

From alukardx at gmail.com  Sat Feb 14 11:02:31 2009
From: alukardx at gmail.com ( tR3nt R32n0r )
Date: Sat, 14 Feb 2009 11:02:31 +0100
Subject: Problems sniffing custom frames with b43
In-Reply-To: <0CD076C1-4E74-4E4A-8DAF-8ADE49AD19F9@ing.unibs.it>
References: <7a8182770902131435i3fb6194r1712d5a1ffb9b96@mail.gmail.com>
	<0CD076C1-4E74-4E4A-8DAF-8ADE49AD19F9@ing.unibs.it>
Message-ID: <7a8182770902140202l36271a41m3dabfdf6c692e640@mail.gmail.com>

Hello,

The capture starting from 802.11 header (radiotap header omitted) with
Atheros AR5001X+ Wireless Network Adapter (rev 01) and D-Link System DWA-140
802.11n Adapter [ralink rt2870] (except sequence number):

0000   70 01 00 00 ff ff ff ff ff ff 11 11 11 11 11 11  p...............
0010   00 22 15 61 86 e1 10 86                          .".a....

IEEE 802.11 Unrecognized (Reserved frame), Flags: .......T
    Type/Subtype: Unknown (0x07)
    Frame Control: 0x0170 (Normal)
        Version: 0
        Type: Management frame (0)
        Subtype: 7
    Flags: 0x1
        DS status: Frame from STA to DS via an AP (To DS: 1 From DS: 0)
(0x01)
        .... .0.. = More Fragments: This is the last fragment
        .... 0... = Retry: Frame is not being retransmitted
        ...0 .... = PWR MGT: STA will stay up
        ..0. .... = More Data: No data buffered
        .0.. .... = Protected flag: Data is not protected
        0... .... = Order flag: Not strictly ordered
    Duration: 0
    Destination address: Broadcast (ff:ff:ff:ff:ff:ff)
    Source address: 11:11:11:11:11:11 (11:11:11:11:11:11)
    BSS Id: AsustekC_61:86:e1 (00:22:15:61:86:e1)
    Fragment number: 0
    Sequence number: 2145

The padding into 802.11 protocol has been custimized by me. It is about
another non existing protocol (not yet :P).

IEEE 802.11 wireless LAN management frame:
0000   12 00 01 14 00 00 79 00 01 0d 0c 72 75 62 65 6e  ......y....ruben
0010   40 6d 6e 2e 6e 65 74 02 01 00 09 2d 02 13 01 00  @mn.net....-....
0020   00 00 00 00 00 00 00 00 00 00 06 00 06 00 02 6f  ...............o
0030   2f 05 7f 13 01 00 00 00 00 00 00 00 00 00 00 00  /...............
0040   06 00 06 00 02 6f 2f 05 7f 05 04 0f 00 00 00 06  .....o/.........
0050   04 18 00 00 00 07 08 00 00 00 00 00 00 00 00 08  ................
0060   02 03 00 0a 1c 01 13 01 00 00 00 00 00 00 00 00  ................
0070   00 00 00 13 01 00 00 00 00 00 00 00 00 00 00 00  ................
0080   01                                               .

I hope it helps.

2009/2/14 Francesco Gringoli <francesco.gringoli at ing.unibs.it>

> On Feb 13, 2009, at 11:35 PM, [ tR3nt R32n0r ] wrote:
>
> Hi all,
>
> I'm using an Asus card WL-138G v2 PCI with b43 driver and a 2.6.27 kernel
> version. Tryng to sniff packets with this card set in monitor mode I found
> that every packet in the air was recognized via Wireshark except the ones I
> made and sent with pcap library tools froma another peer. The packets are
> really sent because they can be read from the media with another cards such
> as D-link 11n usb or Atheros mini PCI, but it seems like there is somewhere
> where the incomming packets are filtered. I don't know how to solve this
> problem. Maybe it is because the driver only recognizes "standard" frames
> such as the ones made for management, but I don't know it for sure. My
> frames include the 802.11 header describing the frame as management frame
> type, using a non defined subtype. Can anybody help me?
>
> Hi,
>
> could you please attach the wireshark dump of the packet as received by the
> atheros board? Start from the 802.11 header.
>
> Cheers,
> -FG
>
>
>
> Thanks!
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20090214/3259b59d/attachment.html>

From mb at bu3sch.de  Sat Feb 14 16:22:47 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 14 Feb 2009 16:22:47 +0100
Subject: Problems sniffing custom frames with b43
In-Reply-To: <7a8182770902140202l36271a41m3dabfdf6c692e640@mail.gmail.com>
References: <7a8182770902131435i3fb6194r1712d5a1ffb9b96@mail.gmail.com>
	<0CD076C1-4E74-4E4A-8DAF-8ADE49AD19F9@ing.unibs.it>
	<7a8182770902140202l36271a41m3dabfdf6c692e640@mail.gmail.com>
Message-ID: <200902141622.47841.mb@bu3sch.de>

On Saturday 14 February 2009 11:02:31 [ tR3nt R32n0r ] wrote:
> Hello,
> 
> The capture starting from 802.11 header (radiotap header omitted) with
> Atheros AR5001X+ Wireless Network Adapter (rev 01) and D-Link System DWA-140
> 802.11n Adapter [ralink rt2870] (except sequence number):
> 
> 0000   70 01 00 00 ff ff ff ff ff ff 11 11 11 11 11 11  p...............
         ^
I think the firmware drops everthing that's not control, management or data.
(It also drops everything that has a frame control protocol version != 0. But it's
0 in this case here)

You should easily be able to hack the opensource firmware. (Well, even the closed
fw should be trivial to patch).

-- 
Greetings, Michael.


From mb at bu3sch.de  Sat Feb 14 16:25:11 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 14 Feb 2009 16:25:11 +0100
Subject: Problems sniffing custom frames with b43
In-Reply-To: <200902141622.47841.mb@bu3sch.de>
References: <7a8182770902131435i3fb6194r1712d5a1ffb9b96@mail.gmail.com>
	<7a8182770902140202l36271a41m3dabfdf6c692e640@mail.gmail.com>
	<200902141622.47841.mb@bu3sch.de>
Message-ID: <200902141625.11887.mb@bu3sch.de>

On Saturday 14 February 2009 16:22:47 Michael Buesch wrote:
> On Saturday 14 February 2009 11:02:31 [ tR3nt R32n0r ] wrote:
> > Hello,
> > 
> > The capture starting from 802.11 header (radiotap header omitted) with
> > Atheros AR5001X+ Wireless Network Adapter (rev 01) and D-Link System DWA-140
> > 802.11n Adapter [ralink rt2870] (except sequence number):
> > 
> > 0000   70 01 00 00 ff ff ff ff ff ff 11 11 11 11 11 11  p...............
>          ^
> I think the firmware drops everthing that's not control, management or data.
> (It also drops everything that has a frame control protocol version != 0. But it's
> 0 in this case here)
> 
> You should easily be able to hack the opensource firmware. (Well, even the closed
> fw should be trivial to patch).

Oh wait, I think it's probably not needed to modify the firmware.
It has a knob to pass "bad frames" up to the driver. It should pass these frames then.

-- 
Greetings, Michael.


From mb at bu3sch.de  Sun Feb 15 18:02:39 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 15 Feb 2009 18:02:39 +0100
Subject: [PATCH] b43: Fix LO calibration txctl reg value
Message-ID: <200902151802.39970.mb@bu3sch.de>

From: Roel Kluin <roel.kluin at gmail.com>

This patch expands the parenthesis in the txctl reg write
of the LO calibration to enforce precedence rules.

Signed-off-by: Roel Kluin <roel.kluin at gmail.com>
Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, please apply this bugfix.

diff --git a/drivers/net/wireless/b43/lo.c b/drivers/net/wireless/b43/lo.c
index 6a18a14..88ed75f 100644
--- a/drivers/net/wireless/b43/lo.c
+++ b/drivers/net/wireless/b43/lo.c
@@ -783,7 +783,7 @@ struct b43_lo_calib * b43_calibrate_lo_setting(struct b43_wldev *dev,
 			  | rfatt->att);
 	b43_radio_write16(dev, txctl_reg,
 			  (b43_radio_read16(dev, txctl_reg) & ~txctl_value)
-			  | (rfatt->with_padmix) ? txctl_value : 0);
+			  | (rfatt->with_padmix ? txctl_value : 0));
 
 	max_rx_gain = rfatt->att * 2;
 	max_rx_gain += bbatt->att / 2;

-- 
Greetings, Michael.


From hs4233 at mail.mn-solutions.de  Mon Feb 16 09:33:54 2009
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Mon, 16 Feb 2009 09:33:54 +0100
Subject: Problems sniffing custom frames with b43
In-Reply-To: <200902141625.11887.mb@bu3sch.de>
References: <7a8182770902131435i3fb6194r1712d5a1ffb9b96@mail.gmail.com>
	<200902141622.47841.mb@bu3sch.de> <200902141625.11887.mb@bu3sch.de>
Message-ID: <200902160933.54420.hs4233@mail.mn-solutions.de>

> Oh wait, I think it's probably not needed to modify the
> firmware. It has a knob to pass "bad frames" up to the driver.
> It should pass these frames then.

Shouldn't the monitor mode then turn on this knob by default?


From heinrich.schmitzberger at jku.at  Mon Feb 16 10:31:34 2009
From: heinrich.schmitzberger at jku.at (Heinrich Schmitzberger)
Date: Mon, 16 Feb 2009 10:31:34 +0100
Subject: BCM4322 and b43 driver
Message-ID: <49993276.7000603@jku.at>

Hi people!

Is there a way to use the BCM4322 chip (PCI-ID 0x432B) in b/g mode
ignoring 11n functionality? As linuxwireless' b43 page says: "BCM 4322
802.11a/b/g/n (Has PCI-ID 0x432B) - This device has an N Phy. There is
no support for any Draft 802.11n features..."  Does this mean that b43
(or bcm43xx respectively) is capable of supporting the b/g functionality
somehow? If so, would it be achievable to turn the driver into rfmon mode?
Thanks in advance.

Best regards,
heinrich



From mb at bu3sch.de  Mon Feb 16 12:40:22 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 16 Feb 2009 12:40:22 +0100
Subject: Problems sniffing custom frames with b43
In-Reply-To: <200902160933.54420.hs4233@mail.mn-solutions.de>
References: <7a8182770902131435i3fb6194r1712d5a1ffb9b96@mail.gmail.com>
	<200902141625.11887.mb@bu3sch.de>
	<200902160933.54420.hs4233@mail.mn-solutions.de>
Message-ID: <200902161240.22734.mb@bu3sch.de>

On Monday 16 February 2009 09:33:54 Holger Schurig wrote:
> > Oh wait, I think it's probably not needed to modify the
> > firmware. It has a knob to pass "bad frames" up to the driver.
> > It should pass these frames then.
> 
> Shouldn't the monitor mode then turn on this knob by default?

No. We're talking about corrupted frames, from the IEEE 802.11 point of view.
The firmware will drop any corrupted frames or frames that don't match the IEEE 802.11
version number unless the flags to pass these frames are set.
You can set this via the mac80211 filter flags.

There are two flags. One flag to pass frames that don't match the IEEE 802.11 specs
and one flag to pass frames that even failed the PLCP checksum. However, the passing
of PLCP failed packets will also enable your microwave oven as a valid packet transmitter. ;)
So you don't want to enable that one.

-- 
Greetings, Michael.


From mb at bu3sch.de  Mon Feb 16 12:41:33 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 16 Feb 2009 12:41:33 +0100
Subject: BCM4322 and b43 driver
In-Reply-To: <49993276.7000603@jku.at>
References: <49993276.7000603@jku.at>
Message-ID: <200902161241.33159.mb@bu3sch.de>

On Monday 16 February 2009 10:31:34 Heinrich Schmitzberger wrote:
> Hi people!
> 
> Is there a way to use the BCM4322 chip (PCI-ID 0x432B) in b/g mode
> ignoring 11n functionality?

No

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Mon Feb 16 17:11:58 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 16 Feb 2009 10:11:58 -0600
Subject: BCM4322 and b43 driver
In-Reply-To: <200902161241.33159.mb@bu3sch.de>
References: <49993276.7000603@jku.at> <200902161241.33159.mb@bu3sch.de>
Message-ID: <4999904E.9050006@lwfinger.net>

Michael Buesch wrote:
> On Monday 16 February 2009 10:31:34 Heinrich Schmitzberger wrote:
>> Hi people!
>>
>> Is there a way to use the BCM4322 chip (PCI-ID 0x432B) in b/g mode
>> ignoring 11n functionality?
> 
> No

To elaborate a bit, the reverse engineers have found that the newest Broadcom
chips use a completely different way to interact with the PHY than older
versions. This is true even for the LP PHY's, which are b/g only.

We are making progress. The last bits of the specs for the LP version were added
to the specs last week, and the next RE push will be on the N PHY code.

Larry



From zajec5polish at gmail.com  Tue Feb 17 09:37:11 2009
From: zajec5polish at gmail.com (=?UTF-8?B?UmFmYcWCIE1pxYJlY2tp?=)
Date: Tue, 17 Feb 2009 09:37:11 +0100
Subject: BCM4322 and b43 driver
In-Reply-To: <4999904E.9050006@lwfinger.net>
References: <49993276.7000603@jku.at> <200902161241.33159.mb@bu3sch.de>
	<4999904E.9050006@lwfinger.net>
Message-ID: <14b026160902170037s63355273ye30d4ca9dbddc8bd@mail.gmail.com>

2009/2/16 Larry Finger <Larry.Finger at lwfinger.net>:
> We are making progress. The last bits of the specs for the LP version were added
> to the specs last week, and the next RE push will be on the N PHY code.

Do I understand right? Specification for LP PHY is 100% complete now??

Wow, that sounds great, why didn't you make any announcement on
bcm43xx-dev!? :) Congratulations for that whole work! :)

-- 
Rafa? Mi?ecki


From Larry.Finger at lwfinger.net  Tue Feb 17 18:35:16 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 17 Feb 2009 11:35:16 -0600
Subject: BCM4322 and b43 driver
In-Reply-To: <14b026160902170037s63355273ye30d4ca9dbddc8bd@mail.gmail.com>
References: <49993276.7000603@jku.at> <200902161241.33159.mb@bu3sch.de>	
	<4999904E.9050006@lwfinger.net>
	<14b026160902170037s63355273ye30d4ca9dbddc8bd@mail.gmail.com>
Message-ID: <499AF554.10704@lwfinger.net>

Rafa? Mi?ecki wrote:
> 2009/2/16 Larry Finger <Larry.Finger at lwfinger.net>:
>> We are making progress. The last bits of the specs for the LP version were added
>> to the specs last week, and the next RE push will be on the N PHY code.
> 
> Do I understand right? Specification for LP PHY is 100% complete now??
> 
> Wow, that sounds great, why didn't you make any announcement on
> bcm43xx-dev!? :) Congratulations for that whole work! :)

I guess I should have. I did announce that I had finished to Michael Buesch, who
is the only one working on converting specs to code.

Now that the LP specs are done, I have started working on the specs for the N PHY.

Larry


From hanbo00 at gmail.com  Tue Feb 17 23:05:51 2009
From: hanbo00 at gmail.com (Bo Han)
Date: Tue, 17 Feb 2009 17:05:51 -0500
Subject: Capturing FCS error frames using b43 driver
Message-ID: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>

Hi,

I am interested in capturing FCS error frames using b43 driver.  My hardware
information is as follows.

b43-phy9: Broadcom 4318 WLAN found
b43-phy9 debug: Found PHY: Analog 3, Type 2, Revision 7
b43-phy9 debuf: Found Radio: Manuf 0x17f, Version 0x2050, Revision 8

I am using firmware version 410.2160 with linux kernel version 2.6.27.10.  I
told the firmware to keep the bad frames by setting ctl |=
B43_MACCTL_KEEP_BAD just before b43_write32(dev, b43_MMIO_MACCTL, ctl) in
b43_adjust_mode(...) in main.c.

From hanbo00 at gmail.com  Tue Feb 17 23:28:55 2009
From: hanbo00 at gmail.com (Bo Han)
Date: Tue, 17 Feb 2009 17:28:55 -0500
Subject: Capturing FCS error frames using b43 driver
Message-ID: <d0ad1e930902171428h197ce340s44dd2602a687f039@mail.gmail.com>

Hi,

(It seems that my last email was incomplete.)

I am interested in capturing FCS error frames using b43 driver.  My hardware
information is as follows.

b43-phy9: Broadcom 4318 WLAN found
b43-phy9 debug: Found PHY: Analog 3, Type 2, Revision 7
b43-phy9 debuf: Found Radio: Manuf 0x17f, Version 0x2050, Revision 8

I am using firmware version 410.2160 with linux kernel version 2.6.27.10.  I
told the firmware to keep the bad frames by setting ctl |=
B43_MACCTL_KEEP_BAD just before b43_write32(dev, b43_MMIO_MACCTL, ctl) in
b43_adjust_mode(...) in main.c.

From mb at bu3sch.de  Tue Feb 17 23:54:31 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 17 Feb 2009 23:54:31 +0100
Subject: Capturing FCS error frames using b43 driver
In-Reply-To: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>
References: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>
Message-ID: <200902172354.32152.mb@bu3sch.de>

Please read the code. There are lots of sanity checks in b43 and mac80211
that make it impossible to receive completely corrupted frames.

On Tuesday 17 February 2009 23:05:51 Bo Han wrote:
> Hi,
> 
> I am interested in capturing FCS error frames using b43 driver.  My hardware
> information is as follows.
> 
> b43-phy9: Broadcom 4318 WLAN found
> b43-phy9 debug: Found PHY: Analog 3, Type 2, Revision 7
> b43-phy9 debuf: Found Radio: Manuf 0x17f, Version 0x2050, Revision 8
> 
> I am using firmware version 410.2160 with linux kernel version 2.6.27.10.  I
> told the firmware to keep the bad frames by setting ctl |=
> B43_MACCTL_KEEP_BAD just before b43_write32(dev, b43_MMIO_MACCTL, ctl) in
> b43_adjust_mode(...) in main.c.
> From b43_rx(...) in xmit.c, I can only see packets dropped because their
> rate_idx == -1.  The length of all the dropped packets is 80 bytes and they
> look like the following:
> 
> 8fae 0308 0000 0b01 0085 0000 1500 482c
> 50b3 0b01 0085 0000 5fa0 1500 482c 50b3
> aaaa 0003 850b cdcc 1b00 1d00 b945 c0cd
> b905 630a 5e10 0101 0601 0b06 000b 07d6
> bab9 addb 35fd 33e8 cd8f 8eaa 6f77 b9e8
> 
> However, there is still no packet received with macstat B43_RX_MAC_FCSERR.
> I also tried the 351 firmware for which I saw several FCS error frames in
> PIO mode.  But the sniffing tools like Wireshark cannot get any packets.
> including the correct ones, when using that firmware.
> 
> Am I missing something?
> 
> Thanks,
> -Bo
> 



-- 
Greetings, Michael.


From hanbo00 at gmail.com  Wed Feb 18 00:07:56 2009
From: hanbo00 at gmail.com (Bo Han)
Date: Tue, 17 Feb 2009 18:07:56 -0500
Subject: Capturing FCS error frames using b43 driver
In-Reply-To: <200902172354.32152.mb@bu3sch.de>
References: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>
	<200902172354.32152.mb@bu3sch.de>
Message-ID: <d0ad1e930902171507y44cf18ecs3e4be9b1fdb30fc7@mail.gmail.com>

I think I am working on the first sanity check in the driver, but still
cannot see any FCS error frames.  Is setting B43_MACCTL_KEEP_BAD the only
thing we need to do for the firmware?

Thanks,
-Bo

On Tue, Feb 17, 2009 at 5:54 PM, Michael Buesch <mb at bu3sch.de> wrote:

> Please read the code. There are lots of sanity checks in b43 and mac80211
> that make it impossible to receive completely corrupted frames.
>
> On Tuesday 17 February 2009 23:05:51 Bo Han wrote:
> > Hi,
> >
> > I am interested in capturing FCS error frames using b43 driver.  My
> hardware
> > information is as follows.
> >
> > b43-phy9: Broadcom 4318 WLAN found
> > b43-phy9 debug: Found PHY: Analog 3, Type 2, Revision 7
> > b43-phy9 debuf: Found Radio: Manuf 0x17f, Version 0x2050, Revision 8
> >
> > I am using firmware version 410.2160 with linux kernel version 2.6.27.10.
>  I
> > told the firmware to keep the bad frames by setting ctl |=
> > B43_MACCTL_KEEP_BAD just before b43_write32(dev, b43_MMIO_MACCTL, ctl) in
> > b43_adjust_mode(...) in main.c.
> > From b43_rx(...) in xmit.c, I can only see packets dropped because their
> > rate_idx == -1.  The length of all the dropped packets is 80 bytes and
> they
> > look like the following:
> >
> > 8fae 0308 0000 0b01 0085 0000 1500 482c
> > 50b3 0b01 0085 0000 5fa0 1500 482c 50b3
> > aaaa 0003 850b cdcc 1b00 1d00 b945 c0cd
> > b905 630a 5e10 0101 0601 0b06 000b 07d6
> > bab9 addb 35fd 33e8 cd8f 8eaa 6f77 b9e8
> >
> > However, there is still no packet received with macstat
> B43_RX_MAC_FCSERR.
> > I also tried the 351 firmware for which I saw several FCS error frames in
> > PIO mode.  But the sniffing tools like Wireshark cannot get any packets.
> > including the correct ones, when using that firmware.
> >
> > Am I missing something?
> >
> > Thanks,
> > -Bo
> >
>
>
>
> --
> Greetings, Michael.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20090217/bfa2005d/attachment.html>

From mb at bu3sch.de  Wed Feb 18 00:23:00 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 18 Feb 2009 00:23:00 +0100
Subject: Capturing FCS error frames using b43 driver
In-Reply-To: <d0ad1e930902171507y44cf18ecs3e4be9b1fdb30fc7@mail.gmail.com>
References: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>
	<200902172354.32152.mb@bu3sch.de>
	<d0ad1e930902171507y44cf18ecs3e4be9b1fdb30fc7@mail.gmail.com>
Message-ID: <200902180023.01128.mb@bu3sch.de>

On Wednesday 18 February 2009 00:07:56 Bo Han wrote:
> I think I am working on the first sanity check in the driver, but still
> cannot see any FCS error frames.  Is setting B43_MACCTL_KEEP_BAD the only
> thing we need to do for the firmware?

No. I suggest you don't touch that flag anyway and change the corresponding
mac80211 filter flag. You most likely can do that through cfg80211/nl80211/iw.
It will take care to set the b43 flag.

-- 
Greetings, Michael.


From francesco.gringoli at ing.unibs.it  Wed Feb 18 03:33:01 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Wed, 18 Feb 2009 03:33:01 +0100
Subject: Capturing FCS error frames using b43 driver
In-Reply-To: <200902180023.01128.mb@bu3sch.de>
References: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>
	<200902172354.32152.mb@bu3sch.de>
	<d0ad1e930902171507y44cf18ecs3e4be9b1fdb30fc7@mail.gmail.com>
	<200902180023.01128.mb@bu3sch.de>
Message-ID: <BED723AA-2638-4E17-88ED-5B0ECD8AD2A6@ing.unibs.it>

On Feb 18, 2009, at 12:23 AM, Michael Buesch wrote:

> On Wednesday 18 February 2009 00:07:56 Bo Han wrote:
>> I think I am working on the first sanity check in the driver, but  
>> still
>> cannot see any FCS error frames.  Is setting B43_MACCTL_KEEP_BAD  
>> the only
>> thing we need to do for the firmware?
>
> No. I suggest you don't touch that flag anyway and change the  
> corresponding
> mac80211 filter flag. You most likely can do that through cfg80211/ 
> nl80211/iw.
> It will take care to set the b43 flag.

Michael is right, the new iw interface eases all this stuff.

There are however a few points that should be discussed

- why b43_rx(...) (in xmit.c) does not mark the status with  
RX_FLAG_FAILED_FCS_CRC when the firmware reports a B43_RX_MAC_FCSERR:  
IMHO this should be done to prevent mac80211 to be corrupted and crash  
the pc when a _very_ noisy frame arrives

- is that correct to have status.rate_idx filled by functions  
b43_plcp_get_bitrate_idx_ofdm and b43_plcp_get_bitrate_idx_cck that  
compute those values reading the plcp? When a frame is ok, values are  
correct and mac80211 uses them without problems. If instead the frame  
is not ok, then mac80211 can warn a lot of message because values are  
out of range. Should not we parse these values when FCS is bad and  
sanitize them if out of range so that dmesg does not get filled with  
warnings? Or probably there is another method to get those values,  
e.g., the firmware can provide them reading from the radio instead of  
computing them reading fields from the plcp?

- I noticed that when in monitor mode and when set up to keep bad  
frames, the radiotap header is not reporting FCS wrong for malformed  
or corrupted frame as it should be, is that correct? Should not the  
radiotap header be built on the status filled by first the driver then  
mac80211?

Cheers,
-FG



>
>
> -- 
> Greetings, Michael.
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev

-------

Francesco Gringoli, PhD - Assistant Professor
Dept. of Electrical Engineering for Automation
University of Brescia
via Branze, 38
25123 Brescia
ITALY

Ph:  ++39.030.3715843
FAX: ++39.030.380014
WWW: http://www.ing.unibs.it/~gringoli






From celejar at gmail.com  Wed Feb 18 03:40:24 2009
From: celejar at gmail.com (Celejar)
Date: Tue, 17 Feb 2009 21:40:24 -0500
Subject: BCM4322 and b43 driver
In-Reply-To: <499AF554.10704@lwfinger.net>
References: <49993276.7000603@jku.at> <200902161241.33159.mb@bu3sch.de>
	<4999904E.9050006@lwfinger.net>
	<14b026160902170037s63355273ye30d4ca9dbddc8bd@mail.gmail.com>
	<499AF554.10704@lwfinger.net>
Message-ID: <20090217214024.e0404aec.celejar@gmail.com>

On Tue, 17 Feb 2009 11:35:16 -0600
Larry Finger <Larry.Finger at lwfinger.net> wrote:

> Rafa? Mi?ecki wrote:
> > 2009/2/16 Larry Finger <Larry.Finger at lwfinger.net>:
> >> We are making progress. The last bits of the specs for the LP version were added
> >> to the specs last week, and the next RE push will be on the N PHY code.
> > 
> > Do I understand right? Specification for LP PHY is 100% complete now??
> > 
> > Wow, that sounds great, why didn't you make any announcement on
> > bcm43xx-dev!? :) Congratulations for that whole work! :)
> 
> I guess I should have. I did announce that I had finished to Michael Buesch, who
> is the only one working on converting specs to code.

Thanks very much!  I'm looking forward to finally getting OpenWrt with
2.6 working on my Asus 520gu.  If there's any testing I can do when
Michael starts releasing code, I'll certainly be glad to do it.

Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator



From mb at bu3sch.de  Wed Feb 18 11:15:33 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 18 Feb 2009 11:15:33 +0100
Subject: Capturing FCS error frames using b43 driver
In-Reply-To: <BED723AA-2638-4E17-88ED-5B0ECD8AD2A6@ing.unibs.it>
References: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>
	<200902180023.01128.mb@bu3sch.de>
	<BED723AA-2638-4E17-88ED-5B0ECD8AD2A6@ing.unibs.it>
Message-ID: <200902181115.33196.mb@bu3sch.de>

On Wednesday 18 February 2009 03:33:01 Francesco Gringoli wrote:
> On Feb 18, 2009, at 12:23 AM, Michael Buesch wrote:
> 
> > On Wednesday 18 February 2009 00:07:56 Bo Han wrote:
> >> I think I am working on the first sanity check in the driver, but  
> >> still
> >> cannot see any FCS error frames.  Is setting B43_MACCTL_KEEP_BAD  
> >> the only
> >> thing we need to do for the firmware?
> >
> > No. I suggest you don't touch that flag anyway and change the  
> > corresponding
> > mac80211 filter flag. You most likely can do that through cfg80211/ 
> > nl80211/iw.
> > It will take care to set the b43 flag.
> 
> Michael is right, the new iw interface eases all this stuff.
> 
> There are however a few points that should be discussed
> 
> - why b43_rx(...) (in xmit.c) does not mark the status with  
> RX_FLAG_FAILED_FCS_CRC when the firmware reports a B43_RX_MAC_FCSERR:  
> IMHO this should be done to prevent mac80211 to be corrupted and crash  
> the pc when a _very_ noisy frame arrives

Well, I think the mac80211 flag was invented afterwards. Remember that b43
was the first mac80211 driver ever and quite a few things didn't exist when
I ported the stuff.

So do you care to send a patch?

Anyway, could you elaborate why you think it would _crash_? I think it shouldn't
crash in any case.

> - is that correct to have status.rate_idx filled by functions  
> b43_plcp_get_bitrate_idx_ofdm and b43_plcp_get_bitrate_idx_cck that  
> compute those values reading the plcp?

Yes I think so. This seems to be the best way to do it.

> When a frame is ok, values are   
> correct and mac80211 uses them without problems. If instead the frame  
> is not ok, then mac80211 can warn a lot of message because values are  
> out of range.

If the PLCP header is corrupt you're completely fucked anyway.
It is a basic and safe assumption that the PLCP header is correct.
But it shouldn't _crash_ if it's not correct. But I think it doesn't.

So if you crank up the flags to pass PLCP corrupted frames it's kind of
expected that they are dropped somewhere in the driver, because we cannot
trust the contents of the frame anyway.
How do we know the PLCP length field is still correct for a corrupted PLCP?
So we don't even know if the frame would have the correct length.

> Should not we parse these values when FCS is bad and   
> sanitize them if out of range so that dmesg does not get filled with  
> warnings?

These warnings were removed some time ago. Please update your kernel.

> Or probably there is another method to get those values,   
> e.g., the firmware can provide them reading from the radio instead of  
> computing them reading fields from the plcp?

I don't see why this is necessary and how it would be possible.

> - I noticed that when in monitor mode and when set up to keep bad  
> frames, the radiotap header is not reporting FCS wrong for malformed  
> or corrupted frame as it should be, is that correct? Should not the  
> radiotap header be built on the status filled by first the driver then  
> mac80211?

I neither know nor care. If you do, please send patches.

-- 
Greetings, Michael.


From mb at bu3sch.de  Wed Feb 18 11:19:53 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 18 Feb 2009 11:19:53 +0100
Subject: BCM4322 and b43 driver
In-Reply-To: <20090217214024.e0404aec.celejar@gmail.com>
References: <49993276.7000603@jku.at> <499AF554.10704@lwfinger.net>
	<20090217214024.e0404aec.celejar@gmail.com>
Message-ID: <200902181119.53210.mb@bu3sch.de>

On Wednesday 18 February 2009 03:40:24 Celejar wrote:
> On Tue, 17 Feb 2009 11:35:16 -0600
> Larry Finger <Larry.Finger at lwfinger.net> wrote:
> 
> > Rafa? Mi?ecki wrote:
> > > 2009/2/16 Larry Finger <Larry.Finger at lwfinger.net>:
> > >> We are making progress. The last bits of the specs for the LP version were added
> > >> to the specs last week, and the next RE push will be on the N PHY code.
> > > 
> > > Do I understand right? Specification for LP PHY is 100% complete now??
> > > 
> > > Wow, that sounds great, why didn't you make any announcement on
> > > bcm43xx-dev!? :) Congratulations for that whole work! :)
> > 
> > I guess I should have. I did announce that I had finished to Michael Buesch, who
> > is the only one working on converting specs to code.
> 
> Thanks very much!  I'm looking forward to finally getting OpenWrt with
> 2.6 working on my Asus 520gu.  If there's any testing I can do when
> Michael starts releasing code, I'll certainly be glad to do it.

I am releasing the code as I write it. I'll never pile up patches locally.
So wireless-testing will contain tip LP code.
Of course, there's nothing to test, yet. I'll announce on the list when people
can start testing.

-- 
Greetings, Michael.


From francesco.gringoli at ing.unibs.it  Wed Feb 18 12:51:13 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Wed, 18 Feb 2009 12:51:13 +0100
Subject: Capturing FCS error frames using b43 driver
In-Reply-To: <200902181115.33196.mb@bu3sch.de>
References: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>
	<200902180023.01128.mb@bu3sch.de>
	<BED723AA-2638-4E17-88ED-5B0ECD8AD2A6@ing.unibs.it>
	<200902181115.33196.mb@bu3sch.de>
Message-ID: <FB1F780D-A225-45B8-A231-C7016AD35E5F@ing.unibs.it>


On Feb 18, 2009, at 11:15 AM, Michael Buesch wrote:

> On Wednesday 18 February 2009 03:33:01 Francesco Gringoli wrote:
>> On Feb 18, 2009, at 12:23 AM, Michael Buesch wrote:
>>
>>> On Wednesday 18 February 2009 00:07:56 Bo Han wrote:
>>>> I think I am working on the first sanity check in the driver, but
>>>> still
>>>> cannot see any FCS error frames.  Is setting B43_MACCTL_KEEP_BAD
>>>> the only
>>>> thing we need to do for the firmware?
>>>
>>> No. I suggest you don't touch that flag anyway and change the
>>> corresponding
>>> mac80211 filter flag. You most likely can do that through cfg80211/
>>> nl80211/iw.
>>> It will take care to set the b43 flag.
>>
>> Michael is right, the new iw interface eases all this stuff.
>>
>> There are however a few points that should be discussed
>>
>> - why b43_rx(...) (in xmit.c) does not mark the status with
>> RX_FLAG_FAILED_FCS_CRC when the firmware reports a B43_RX_MAC_FCSERR:
>> IMHO this should be done to prevent mac80211 to be corrupted and  
>> crash
>> the pc when a _very_ noisy frame arrives
>
> Well, I think the mac80211 flag was invented afterwards. Remember  
> that b43
> was the first mac80211 driver ever and quite a few things didn't  
> exist when
> I ported the stuff.
>
> So do you care to send a patch?
ok, I will send.
>
>
> Anyway, could you elaborate why you think it would _crash_? I think  
> it shouldn't
> crash in any case.
No. But I have to analyze more because I think there is a problem with  
the firmware too (all firmwares) that not always sets up correctly the  
corrupted frame flag when the KEEP_BAD_FRAME bit is activated. I will  
check this and what happens when KEEP_BAD_FRAME is set and we have a  
mistake even at the plcp sublayer (see below).

However, if RX_FLAG_FAILED_FCS_CRC is not set up in the status field,  
mac80211 will process this frame: should not be something related to  
the skb, probably somewhere it is shortened without checking its  
actual size, as mac80211 trusts the driver that should already had  
checked that the skb size correspond to something written in some  
header, well, just speculating, I'm confused about.

>> - is that correct to have status.rate_idx filled by functions
>> b43_plcp_get_bitrate_idx_ofdm and b43_plcp_get_bitrate_idx_cck that
>> compute those values reading the plcp?
>
> Yes I think so. This seems to be the best way to do it.
After some thoughts I'm wondering how these fields could be wrong  
since the PLCP is protected on its own by another checksum external to  
MPDU. Probably the firmware keep also frames whose PLCP is wrong,  
while b43_rx only check for FCS problems within the MPDU. Will  
investigate.
>
>
>> When a frame is ok, values are
>> correct and mac80211 uses them without problems. If instead the frame
>> is not ok, then mac80211 can warn a lot of message because values are
>> out of range.
>
> If the PLCP header is corrupt you're completely fucked anyway.
> It is a basic and safe assumption that the PLCP header is correct.
> But it shouldn't _crash_ if it's not correct. But I think it doesn't.
Well, I think that capturing noisy frames is interesting for all those  
guys willing to use data for research purposes without buying a  
network analyzer that basically do the same...

> So if you crank up the flags to pass PLCP corrupted frames it's kind  
> of
> expected that they are dropped somewhere in the driver, because we  
> cannot
> trust the contents of the frame anyway.
> How do we know the PLCP length field is still correct for a  
> corrupted PLCP?
> So we don't even know if the frame would have the correct length.
>
>> Should not we parse these values when FCS is bad and
>> sanitize them if out of range so that dmesg does not get filled with
>> warnings?
>
> These warnings were removed some time ago. Please update your kernel.
Uhm... I updated it before writing this mail to check about this  
possibility but I believed these warns were still there

[taken from __ieee80211_rx() pulled from git yesterday night]
         if (status->flag & RX_FLAG_HT) {
                 /* rate_idx is MCS index */
                 if (WARN_ON(status->rate_idx < 0 ||
                             status->rate_idx >= 76))
                         return;
                 /* HT rates are not in the table - use the highest  
legacy rate
                  * for now since other parts of mac80211 may not yet  
be fully
                  * MCS aware. */
                 rate = &sband->bitrates[sband->n_bitrates - 1];
         } else {
                 if (WARN_ON(status->rate_idx < 0 ||
                             status->rate_idx >= sband->n_bitrates))
                         return;
                 rate = &sband->bitrates[status->rate_idx];
         }

>
>
>> Or probably there is another method to get those values,
>> e.g., the firmware can provide them reading from the radio instead of
>> computing them reading fields from the plcp?
>
> I don't see why this is necessary and how it would be possible.
You are right, we have simply to trash real noise (frames whose plcp  
was corrupted) so to avoid to decode the Microwave Owen as you were  
saying a few days ago :-)
>
>
>> - I noticed that when in monitor mode and when set up to keep bad
>> frames, the radiotap header is not reporting FCS wrong for malformed
>> or corrupted frame as it should be, is that correct? Should not the
>> radiotap header be built on the status filled by first the driver  
>> then
>> mac80211?
>
> I neither know nor care. If you do, please send patches.
Ok.

Cheers,
-FG

>
>
> -- 
> Greetings, Michael.

-------

Francesco Gringoli, PhD - Assistant Professor
Dept. of Electrical Engineering for Automation
University of Brescia
via Branze, 38
25123 Brescia
ITALY

Ph:  ++39.030.3715843
FAX: ++39.030.380014
WWW: http://www.ing.unibs.it/~gringoli






From mb at bu3sch.de  Wed Feb 18 13:00:14 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 18 Feb 2009 13:00:14 +0100
Subject: Capturing FCS error frames using b43 driver
In-Reply-To: <FB1F780D-A225-45B8-A231-C7016AD35E5F@ing.unibs.it>
References: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>
	<200902181115.33196.mb@bu3sch.de>
	<FB1F780D-A225-45B8-A231-C7016AD35E5F@ing.unibs.it>
Message-ID: <200902181300.14222.mb@bu3sch.de>

On Wednesday 18 February 2009 12:51:13 Francesco Gringoli wrote:
> >> - is that correct to have status.rate_idx filled by functions
> >> b43_plcp_get_bitrate_idx_ofdm and b43_plcp_get_bitrate_idx_cck that
> >> compute those values reading the plcp?
> >
> > Yes I think so. This seems to be the best way to do it.
> After some thoughts I'm wondering how these fields could be wrong  
> since the PLCP is protected on its own by another checksum external to  
> MPDU.

Yes you're right.

> Probably the firmware keep also frames whose PLCP is wrong,   
> while b43_rx only check for FCS problems within the MPDU. Will  
> investigate.

Well, there is a bug that misaligned frames are sometimes passed up to the driver.
It happens with any firmware and any driver (including open fw).
So it might be a silicon bug in the DMA. I'm not sure yet.

So you'll hit the rate_idx failure from time to time. That's expected and nonfatal.
It just happens for one packet of say 1000. I don't really know.

> > If the PLCP header is corrupt you're completely fucked anyway.
> > It is a basic and safe assumption that the PLCP header is correct.
> > But it shouldn't _crash_ if it's not correct. But I think it doesn't.
> Well, I think that capturing noisy frames is interesting for all those  
> guys willing to use data for research purposes without buying a  
> network analyzer that basically do the same...

Note that the PLCP is casted into hardware. You cannot change it or else
you will corrupt basic assumptions in the radio silicon.
So you better not touch it or buy a radio analyzer.
That's simply a limitation of the consumer hardware.

> > These warnings were removed some time ago. Please update your kernel.
> Uhm... I updated it before writing this mail to check about this  
> possibility but I believed these warns were still there
> 
> [taken from __ieee80211_rx() pulled from git yesterday night]
>          if (status->flag & RX_FLAG_HT) {
>                  /* rate_idx is MCS index */
>                  if (WARN_ON(status->rate_idx < 0 ||
>                              status->rate_idx >= 76))
>                          return;
>                  /* HT rates are not in the table - use the highest  
> legacy rate
>                   * for now since other parts of mac80211 may not yet  
> be fully
>                   * MCS aware. */
>                  rate = &sband->bitrates[sband->n_bitrates - 1];
>          } else {
>                  if (WARN_ON(status->rate_idx < 0 ||
>                              status->rate_idx >= sband->n_bitrates))
>                          return;
>                  rate = &sband->bitrates[status->rate_idx];
>          }

Ok, well. I don't know about mac80211. But the warnings in b43 were removed
(also some warnings were removed in mac80211).

I think these warnings should also be removed. You can do patches and send
them to Johannes.

-- 
Greetings, Michael.


From alukardx at gmail.com  Thu Feb 19 12:08:28 2009
From: alukardx at gmail.com ( tR3nt R32n0r )
Date: Thu, 19 Feb 2009 12:08:28 +0100
Subject: Problems sniffing custom frames with b43
In-Reply-To: <200902161240.22734.mb@bu3sch.de>
References: <7a8182770902131435i3fb6194r1712d5a1ffb9b96@mail.gmail.com>
	<200902141625.11887.mb@bu3sch.de>
	<200902160933.54420.hs4233@mail.mn-solutions.de>
	<200902161240.22734.mb@bu3sch.de>
Message-ID: <7a8182770902190308i1ea5b4fcu62fa2137cfae83c4@mail.gmail.com>

Hey!

I've been tying to enable the admission of other no IEEE 802.11 frames but
it hasn't been possible. I've managed the flags defined for monitor mode in
nl80211.h in Hostapd git code (driver_nl80211.c, line 1023) replacing:
NLA_PUT_FLAG(flags, NL80211_MNTR_FLAG_COOK_FRAMES);
for:
NLA_PUT_FLAG(flags, NL80211_MNTR_FLAG_FCSFAIL | NL80211_MNTR_FLAG_PLCPFAIL |
NL80211_MNTR_FLAG_CONTROL | NL80211_MNTR_FLAG_OTHER_BSS |
__NL80211_MNTR_FLAG_INVALID );
And yes, I've been able to see more frames than the ones seen from the
monitor interface created when running Hostapd (such as mon.wlan0), but I
can't still see my custom frames. I don't know if these flags are the ones
you referred, but enabling NL80211_MNTR_FLAG_PLCPFAIL doesn't make Wireshark
sniff what I wanted.

Are these flags the ones you suggested? Any idea?


/**
 * enum nl80211_mntr_flags - monitor configuration flags
 *
 * Monitor configuration flags.
*
 * @__NL80211_MNTR_FLAG_INVALID: reserved
 *
 * @NL80211_MNTR_FLAG_FCSFAIL: pass frames with bad FCS
 * @NL80211_MNTR_FLAG_PLCPFAIL: pass frames with bad PLCP
 * @NL80211_MNTR_FLAG_CONTROL: pass control frames
 * @NL80211_MNTR_FLAG_OTHER_BSS: disable BSSID filtering
 * @NL80211_MNTR_FLAG_COOK_FRAMES: report frames after processing.
 *    overrides all other flags.
 *
 * @__NL80211_MNTR_FLAG_AFTER_LAST: internal use
 * @NL80211_MNTR_FLAG_MAX: highest possible monitor flag
 */
enum nl80211_mntr_flags {
    __NL80211_MNTR_FLAG_INVALID,
    NL80211_MNTR_FLAG_FCSFAIL,
    NL80211_MNTR_FLAG_PLCPFAIL,
    NL80211_MNTR_FLAG_CONTROL,
    NL80211_MNTR_FLAG_OTHER_BSS,
    NL80211_MNTR_FLAG_COOK_FRAMES,

    /* keep last */
    __NL80211_MNTR_FLAG_AFTER_LAST,
    NL80211_MNTR_FLAG_MAX = __NL80211_MNTR_FLAG_AFTER_LAST - 1
};

2009/2/16 Michael Buesch <mb at bu3sch.de>

> On Monday 16 February 2009 09:33:54 Holger Schurig wrote:
> > > Oh wait, I think it's probably not needed to modify the
> > > firmware. It has a knob to pass "bad frames" up to the driver.
> > > It should pass these frames then.
> >
> > Shouldn't the monitor mode then turn on this knob by default?
>
> No. We're talking about corrupted frames, from the IEEE 802.11 point of
> view.
> The firmware will drop any corrupted frames or frames that don't match the
> IEEE 802.11
> version number unless the flags to pass these frames are set.
> You can set this via the mac80211 filter flags.
>
> There are two flags. One flag to pass frames that don't match the IEEE
> 802.11 specs
> and one flag to pass frames that even failed the PLCP checksum. However,
> the passing
> of PLCP failed packets will also enable your microwave oven as a valid
> packet transmitter. ;)
> So you don't want to enable that one.
>
> --
> Greetings, Michael.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20090219/360a6213/attachment.html>

From alukardx at gmail.com  Thu Feb 19 19:01:29 2009
From: alukardx at gmail.com ( tR3nt R32n0r )
Date: Thu, 19 Feb 2009 19:01:29 +0100
Subject: Problems sniffing custom frames with b43
In-Reply-To: <7a8182770902190308i1ea5b4fcu62fa2137cfae83c4@mail.gmail.com>
References: <7a8182770902131435i3fb6194r1712d5a1ffb9b96@mail.gmail.com>
	<200902141625.11887.mb@bu3sch.de>
	<200902160933.54420.hs4233@mail.mn-solutions.de>
	<200902161240.22734.mb@bu3sch.de>
	<7a8182770902190308i1ea5b4fcu62fa2137cfae83c4@mail.gmail.com>
Message-ID: <7a8182770902191001u273dd403w281ccd0f6c7a23be@mail.gmail.com>

Well,

I've tried doing something different. I've changed the type field on 802.11
MAC header. I was using management frames type (with reserved subtype) and I
turned it into data frame type (with ToDS and FromDS flags set to false)
because it is allowed to recieve this type of frames in state 1, it is,
being unautenticated and unasociated. So problems with no working flags now
have disappeared. I didn't really care about frame's type, I only wanted
these frames to be recieved. But thank you all anyway.

Best regards,

R.



2009/2/19 [ tR3nt R32n0r ] <alukardx at gmail.com>

> Hey!
>
> I've been tying to enable the admission of other no IEEE 802.11 frames but
> it hasn't been possible. I've managed the flags defined for monitor mode in
> nl80211.h in Hostapd git code (driver_nl80211.c, line 1023) replacing:
> NLA_PUT_FLAG(flags, NL80211_MNTR_FLAG_COOK_FRAMES);
> for:
> NLA_PUT_FLAG(flags, NL80211_MNTR_FLAG_FCSFAIL | NL80211_MNTR_FLAG_PLCPFAIL
> | NL80211_MNTR_FLAG_CONTROL | NL80211_MNTR_FLAG_OTHER_BSS |
> __NL80211_MNTR_FLAG_INVALID );
> And yes, I've been able to see more frames than the ones seen from the
> monitor interface created when running Hostapd (such as mon.wlan0), but I
> can't still see my custom frames. I don't know if these flags are the ones
> you referred, but enabling NL80211_MNTR_FLAG_PLCPFAIL doesn't make Wireshark
> sniff what I wanted.
>
> Are these flags the ones you suggested? Any idea?
>
>
> /**
>  * enum nl80211_mntr_flags - monitor configuration flags
>  *
>  * Monitor configuration flags.
> *
>  * @__NL80211_MNTR_FLAG_INVALID: reserved
>  *
>  * @NL80211_MNTR_FLAG_FCSFAIL: pass frames with bad FCS
>  * @NL80211_MNTR_FLAG_PLCPFAIL: pass frames with bad PLCP
>  * @NL80211_MNTR_FLAG_CONTROL: pass control frames
>  * @NL80211_MNTR_FLAG_OTHER_BSS: disable BSSID filtering
>  * @NL80211_MNTR_FLAG_COOK_FRAMES: report frames after processing.
>  *    overrides all other flags.
>  *
>  * @__NL80211_MNTR_FLAG_AFTER_LAST: internal use
>  * @NL80211_MNTR_FLAG_MAX: highest possible monitor flag
>  */
> enum nl80211_mntr_flags {
>     __NL80211_MNTR_FLAG_INVALID,
>     NL80211_MNTR_FLAG_FCSFAIL,
>     NL80211_MNTR_FLAG_PLCPFAIL,
>     NL80211_MNTR_FLAG_CONTROL,
>     NL80211_MNTR_FLAG_OTHER_BSS,
>     NL80211_MNTR_FLAG_COOK_FRAMES,
>
>     /* keep last */
>     __NL80211_MNTR_FLAG_AFTER_LAST,
>     NL80211_MNTR_FLAG_MAX = __NL80211_MNTR_FLAG_AFTER_LAST - 1
> };
>
> 2009/2/16 Michael Buesch <mb at bu3sch.de>
>
> On Monday 16 February 2009 09:33:54 Holger Schurig wrote:
>> > > Oh wait, I think it's probably not needed to modify the
>> > > firmware. It has a knob to pass "bad frames" up to the driver.
>> > > It should pass these frames then.
>> >
>> > Shouldn't the monitor mode then turn on this knob by default?
>>
>> No. We're talking about corrupted frames, from the IEEE 802.11 point of
>> view.
>> The firmware will drop any corrupted frames or frames that don't match the
>> IEEE 802.11
>> version number unless the flags to pass these frames are set.
>> You can set this via the mac80211 filter flags.
>>
>> There are two flags. One flag to pass frames that don't match the IEEE
>> 802.11 specs
>> and one flag to pass frames that even failed the PLCP checksum. However,
>> the passing
>> of PLCP failed packets will also enable your microwave oven as a valid
>> packet transmitter. ;)
>> So you don't want to enable that one.
>>
>> --
>> Greetings, Michael.
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20090219/46fe2432/attachment.html>

From marcandre.moreau at gmail.com  Thu Feb 19 19:10:02 2009
From: marcandre.moreau at gmail.com (=?ISO-8859-1?Q?Marc=2DAndr=E9_Moreau?=)
Date: Thu, 19 Feb 2009 13:10:02 -0500
Subject: BCM43XG
Message-ID: <a905f5230902191010x2e6d628cof1c41639d496afbf@mail.gmail.com>

Hi, I have a Linksys WPC300N V1 with a BCM43XG chipset, which seems to be
unsupported for the moment. I would like to know the current status of the
development for 802.11N and for BCM43XG, and what I could do to help. If
there are any resources available that would help me write a driver for it,
I'd like to know.

Thanks,

-Marc-Andre
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20090219/65c687cb/attachment.html>

From Larry.Finger at lwfinger.net  Thu Feb 19 19:33:50 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 19 Feb 2009 12:33:50 -0600
Subject: BCM43XG
In-Reply-To: <a905f5230902191010x2e6d628cof1c41639d496afbf@mail.gmail.com>
References: <a905f5230902191010x2e6d628cof1c41639d496afbf@mail.gmail.com>
Message-ID: <499DA60E.5020103@lwfinger.net>

Marc-Andr? Moreau wrote:
> Hi, I have a Linksys WPC300N V1 with a BCM43XG chipset, which seems to
> be unsupported for the moment. I would like to know the current status
> of the development for 802.11N and for BCM43XG, and what I could do to
> help. If there are any resources available that would help me write a
> driver for it, I'd like to know.

The reverse engineers are currently writing the specs for the Broadcom 802.11n
devices. Once that task is done, then b43 will be extended to handle those
units. If your unit has a PCI ID of 4328, 4329, or 432b, it will be handled.

As to when 802.11n units will be incorporated -- I don't know?
Larry


From mb at bu3sch.de  Thu Feb 19 20:17:36 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 19 Feb 2009 20:17:36 +0100
Subject: [PATCH] b43: Move DMA stop sanity check
Message-ID: <200902192017.36403.mb@bu3sch.de>

Move the DMA stop sanity check up a few lines, so it's actually
theoretically possible to trigger. (But it still shouldn't trigger, of course).

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---


Index: wireless-testing/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/dma.c	2008-12-26 22:47:29.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/dma.c	2009-02-19 20:14:56.000000000 +0100
@@ -1306,16 +1306,18 @@ int b43_dma_tx(struct b43_wldev *dev, st
 	}
 
 	spin_lock_irqsave(&ring->lock, flags);
+
 	B43_WARN_ON(!ring->tx);
+	/* Check if the queue was stopped in mac80211,
+	 * but we got called nevertheless.
+	 * That would be a mac80211 bug. */
+	B43_WARN_ON(ring->stopped);
+
 	if (unlikely(free_slots(ring) < SLOTS_PER_PACKET)) {
 		b43warn(dev->wl, "DMA queue overflow\n");
 		err = -ENOSPC;
 		goto out_unlock;
 	}
-	/* Check if the queue was stopped in mac80211,
-	 * but we got called nevertheless.
-	 * That would be a mac80211 bug. */
-	B43_WARN_ON(ring->stopped);
 
 	/* Assign the queue number to the ring (if not already done before)
 	 * so TX status handling can use it. The queue to ring mapping is

-- 
Greetings, Michael.


From mb at bu3sch.de  Thu Feb 19 23:39:26 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 19 Feb 2009 23:39:26 +0100
Subject: [PATCH] b43: Fix DMA buffer size handling
Message-ID: <200902192339.27295.mb@bu3sch.de>

This fixes hidden bugs in the size handling of the DMA buffers.
This sets the RX buffer size to the theoretical max packet size and
fixes passing of the size values to the device (must not subtract the header offset).

These bugs are hidden and don't actually trigger due to the magic +100
offset for the buffer size.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, no need to push this as bugfix. Just push it with the next round of
features. This bug has always been there and it's hidden. So it doesn't
trigger for anybody.


Index: wireless-testing/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/dma.c	2009-01-25 15:29:55.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/dma.c	2009-02-19 22:30:16.000000000 +0100
@@ -71,14 +71,13 @@ static void op32_fill_descriptor(struct 
 	B43_WARN_ON(!(slot >= 0 && slot < ring->nr_slots));
 
 	addr = (u32) (dmaaddr & ~SSB_DMA_TRANSLATION_MASK);
 	addrext = (u32) (dmaaddr & SSB_DMA_TRANSLATION_MASK)
 	    >> SSB_DMA_TRANSLATION_SHIFT;
 	addr |= ssb_dma_translation(ring->dev->dev);
-	ctl = (bufsize - ring->frameoffset)
-	    & B43_DMA32_DCTL_BYTECNT;
+	ctl = bufsize & B43_DMA32_DCTL_BYTECNT;
 	if (slot == ring->nr_slots - 1)
 		ctl |= B43_DMA32_DCTL_DTABLEEND;
 	if (start)
 		ctl |= B43_DMA32_DCTL_FRAMESTART;
 	if (end)
 		ctl |= B43_DMA32_DCTL_FRAMEEND;
@@ -174,14 +173,13 @@ static void op64_fill_descriptor(struct 
 	if (start)
 		ctl0 |= B43_DMA64_DCTL0_FRAMESTART;
 	if (end)
 		ctl0 |= B43_DMA64_DCTL0_FRAMEEND;
 	if (irq)
 		ctl0 |= B43_DMA64_DCTL0_IRQ;
-	ctl1 |= (bufsize - ring->frameoffset)
-	    & B43_DMA64_DCTL1_BYTECNT;
+	ctl1 |= bufsize & B43_DMA64_DCTL1_BYTECNT;
 	ctl1 |= (addrext << B43_DMA64_DCTL1_ADDREXT_SHIFT)
 	    & B43_DMA64_DCTL1_ADDREXT_MASK;
 
 	desc->dma64.control0 = cpu_to_le32(ctl0);
 	desc->dma64.control1 = cpu_to_le32(ctl1);
 	desc->dma64.address_low = cpu_to_le32(addrlo);
@@ -827,15 +825,12 @@ struct b43_dmaring *b43_setup_dmaring(st
 		ring->tx = 1;
 		ring->current_slot = -1;
 	} else {
 		if (ring->index == 0) {
 			ring->rx_buffersize = B43_DMA0_RX_BUFFERSIZE;
 			ring->frameoffset = B43_DMA0_RX_FRAMEOFFSET;
-		} else if (ring->index == 3) {
-			ring->rx_buffersize = B43_DMA3_RX_BUFFERSIZE;
-			ring->frameoffset = B43_DMA3_RX_FRAMEOFFSET;
 		} else
 			B43_WARN_ON(1);
 	}
 	spin_lock_init(&ring->lock);
 #ifdef CONFIG_B43_DEBUG
 	ring->last_injected_overflow = jiffies;
Index: wireless-testing/drivers/net/wireless/b43/dma.h
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/dma.h	2008-05-23 23:41:06.000000000 +0200
+++ wireless-testing/drivers/net/wireless/b43/dma.h	2009-02-19 22:32:21.000000000 +0100
@@ -1,17 +1,15 @@
 #ifndef B43_DMA_H_
 #define B43_DMA_H_
 
-#include <linux/list.h>
+#include <linux/ieee80211.h>
 #include <linux/spinlock.h>
-#include <linux/workqueue.h>
-#include <linux/linkage.h>
-#include <asm/atomic.h>
 
 #include "b43.h"
 
+
 /* DMA-Interrupt reasons. */
 #define B43_DMAIRQ_FATALMASK	((1 << 10) | (1 << 11) | (1 << 12) \
 					 | (1 << 14) | (1 << 15))
 #define B43_DMAIRQ_NONFATALMASK	(1 << 13)
 #define B43_DMAIRQ_RX_DONE		(1 << 16)
 
@@ -158,20 +156,19 @@ struct b43_dmadesc_generic {
 		struct b43_dmadesc64 dma64;
 	} __attribute__ ((__packed__));
 } __attribute__ ((__packed__));
 
 /* Misc DMA constants */
 #define B43_DMA_RINGMEMSIZE		PAGE_SIZE
-#define B43_DMA0_RX_FRAMEOFFSET	30
-#define B43_DMA3_RX_FRAMEOFFSET	0
+#define B43_DMA0_RX_FRAMEOFFSET		30
 
 /* DMA engine tuning knobs */
 #define B43_TXRING_SLOTS		128
 #define B43_RXRING_SLOTS		64
-#define B43_DMA0_RX_BUFFERSIZE	(2304 + 100)
-#define B43_DMA3_RX_BUFFERSIZE	16
+#define B43_DMA0_RX_BUFFERSIZE		IEEE80211_MAX_FRAME_LEN
+
 
 struct sk_buff;
 struct b43_private;
 struct b43_txstatus;
 
 struct b43_dmadesc_meta {

-- 
Greetings, Michael.


From mb at bu3sch.de  Thu Feb 19 23:45:43 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 19 Feb 2009 23:45:43 +0100
Subject: [PATCH] b43: Optimize DMA buffers
Message-ID: <200902192345.44141.mb@bu3sch.de>

In the old days we used one slot per frame. But when we changed that to 2,
we didn't raise the overall slot count. Which resulted in an effective
division of two to the number of slots.

Double the number of TX slots, so we have an effective hardware queue
of 128 frames per QoS queue.

Also optimize the TX header cache handling. We don't need a cached TX header
for slots that will never carry an actual header.
So we reduce the memory consumption of the cache by 50%.

So as a net result we end up with more or less the same memory usage before
and after this patch (except a few tiny meta structures), but have twice
the number of TX slots available.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Please queue for the next round of features.


Index: wireless-testing/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/dma.c	2009-02-19 22:30:16.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/dma.c	2009-02-19 22:49:06.000000000 +0100
@@ -38,12 +38,18 @@
 #include <linux/delay.h>
 #include <linux/skbuff.h>
 #include <linux/etherdevice.h>
 #include <asm/div64.h>
 
 
+/* Required number of TX DMA slots per TX frame.
+ * This currently is 2, because we put the header and the ieee80211 frame
+ * into separate slots. */
+#define TX_SLOTS_PER_FRAME	2
+
+
 /* 32bit DMA ops. */
 static
 struct b43_dmadesc_generic *op32_idx2desc(struct b43_dmaring *ring,
 					  int slot,
 					  struct b43_dmadesc_meta **meta)
 {
@@ -571,18 +577,17 @@ static int setup_rx_descbuffer(struct b4
 
 		skb = __dev_alloc_skb(ring->rx_buffersize, gfp_flags);
 		if (unlikely(!skb))
 			return -ENOMEM;
 		dmaaddr = map_descbuffer(ring, skb->data,
 					 ring->rx_buffersize, 0);
-	}
-
-	if (b43_dma_mapping_error(ring, dmaaddr, ring->rx_buffersize, 0)) {
-		b43err(ring->dev->wl, "RX DMA buffer allocation failed\n");
-		dev_kfree_skb_any(skb);
-		return -EIO;
+		if (b43_dma_mapping_error(ring, dmaaddr, ring->rx_buffersize, 0)) {
+			b43err(ring->dev->wl, "RX DMA buffer allocation failed\n");
+			dev_kfree_skb_any(skb);
+			return -EIO;
+		}
 	}
 
 	meta->skb = skb;
 	meta->dmaaddr = dmaaddr;
 	ring->ops->fill_descriptor(ring, desc, dmaaddr,
 				   ring->rx_buffersize, 0, 0, 0);
@@ -834,13 +839,13 @@ struct b43_dmaring *b43_setup_dmaring(st
 	spin_lock_init(&ring->lock);
 #ifdef CONFIG_B43_DEBUG
 	ring->last_injected_overflow = jiffies;
 #endif
 
 	if (for_tx) {
-		ring->txhdr_cache = kcalloc(ring->nr_slots,
+		ring->txhdr_cache = kcalloc(ring->nr_slots / TX_SLOTS_PER_FRAME,
 					    b43_txhdr_size(dev),
 					    GFP_KERNEL);
 		if (!ring->txhdr_cache)
 			goto err_kfree_meta;
 
 		/* test for ability to dma to txhdr_cache */
@@ -850,13 +855,13 @@ struct b43_dmaring *b43_setup_dmaring(st
 					      DMA_TO_DEVICE);
 
 		if (b43_dma_mapping_error(ring, dma_test,
 					  b43_txhdr_size(dev), 1)) {
 			/* ugh realloc */
 			kfree(ring->txhdr_cache);
-			ring->txhdr_cache = kcalloc(ring->nr_slots,
+			ring->txhdr_cache = kcalloc(ring->nr_slots / TX_SLOTS_PER_FRAME,
 						    b43_txhdr_size(dev),
 						    GFP_KERNEL | GFP_DMA);
 			if (!ring->txhdr_cache)
 				goto err_kfree_meta;
 
 			dma_test = ssb_dma_map_single(dev->dev,
@@ -1141,23 +1146,26 @@ static int dma_tx_fragment(struct b43_dm
 	struct b43_dmadesc_meta *meta;
 	struct b43_dmadesc_meta *meta_hdr;
 	struct sk_buff *bounce_skb;
 	u16 cookie;
 	size_t hdrsize = b43_txhdr_size(ring->dev);
 
-#define SLOTS_PER_PACKET  2
+	/* Important note: If the number of used DMA slots per TX frame
+	 * is changed here, the TX_SLOTS_PER_FRAME definition at the top of
+	 * the file has to be updated, too!
+	 */
 
 	old_top_slot = ring->current_slot;
 	old_used_slots = ring->used_slots;
 
 	/* Get a slot for the header. */
 	slot = request_slot(ring);
 	desc = ops->idx2desc(ring, slot, &meta_hdr);
 	memset(meta_hdr, 0, sizeof(*meta_hdr));
 
-	header = &(ring->txhdr_cache[slot * hdrsize]);
+	header = &(ring->txhdr_cache[(slot / TX_SLOTS_PER_FRAME) * hdrsize]);
 	cookie = generate_cookie(ring, slot);
 	err = b43_generate_txhdr(ring->dev, header,
 				 skb->data, skb->len, info, cookie);
 	if (unlikely(err)) {
 		ring->current_slot = old_top_slot;
 		ring->used_slots = old_used_slots;
@@ -1299,13 +1307,13 @@ int b43_dma_tx(struct b43_wldev *dev, st
 		ring = select_ring_by_priority(
 			dev, skb_get_queue_mapping(skb));
 	}
 
 	spin_lock_irqsave(&ring->lock, flags);
 	B43_WARN_ON(!ring->tx);
-	if (unlikely(free_slots(ring) < SLOTS_PER_PACKET)) {
+	if (unlikely(free_slots(ring) < TX_SLOTS_PER_FRAME)) {
 		b43warn(dev->wl, "DMA queue overflow\n");
 		err = -ENOSPC;
 		goto out_unlock;
 	}
 	/* Check if the queue was stopped in mac80211,
 	 * but we got called nevertheless.
@@ -1327,13 +1335,13 @@ int b43_dma_tx(struct b43_wldev *dev, st
 	}
 	if (unlikely(err)) {
 		b43err(dev->wl, "DMA tx mapping failure\n");
 		goto out_unlock;
 	}
 	ring->nr_tx_packets++;
-	if ((free_slots(ring) < SLOTS_PER_PACKET) ||
+	if ((free_slots(ring) < TX_SLOTS_PER_FRAME) ||
 	    should_inject_overflow(ring)) {
 		/* This TX ring is full. */
 		ieee80211_stop_queue(dev->wl->hw, skb_get_queue_mapping(skb));
 		ring->stopped = 1;
 		if (b43_debug(dev, B43_DBG_DMAVERBOSE)) {
 			b43dbg(dev->wl, "Stopped TX ring %d\n", ring->index);
@@ -1411,13 +1419,13 @@ void b43_dma_handle_txstatus(struct b43_
 		if (meta->is_last_fragment)
 			break;
 		slot = next_slot(ring, slot);
 	}
 	dev->stats.last_tx = jiffies;
 	if (ring->stopped) {
-		B43_WARN_ON(free_slots(ring) < SLOTS_PER_PACKET);
+		B43_WARN_ON(free_slots(ring) < TX_SLOTS_PER_FRAME);
 		ieee80211_wake_queue(dev->wl->hw, ring->queue_prio);
 		ring->stopped = 0;
 		if (b43_debug(dev, B43_DBG_DMAVERBOSE)) {
 			b43dbg(dev->wl, "Woke up TX ring %d\n", ring->index);
 		}
 	}
@@ -1434,14 +1442,14 @@ void b43_dma_get_tx_stats(struct b43_wld
 	int i;
 
 	for (i = 0; i < nr_queues; i++) {
 		ring = select_ring_by_priority(dev, i);
 
 		spin_lock_irqsave(&ring->lock, flags);
-		stats[i].len = ring->used_slots / SLOTS_PER_PACKET;
-		stats[i].limit = ring->nr_slots / SLOTS_PER_PACKET;
+		stats[i].len = ring->used_slots / TX_SLOTS_PER_FRAME;
+		stats[i].limit = ring->nr_slots / TX_SLOTS_PER_FRAME;
 		stats[i].count = ring->nr_tx_packets;
 		spin_unlock_irqrestore(&ring->lock, flags);
 	}
 }
 
 static void dma_rx(struct b43_dmaring *ring, int *slot)
Index: wireless-testing/drivers/net/wireless/b43/dma.h
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/dma.h	2009-02-19 22:32:21.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/dma.h	2009-02-19 22:46:14.000000000 +0100
@@ -159,13 +159,13 @@ struct b43_dmadesc_generic {
 
 /* Misc DMA constants */
 #define B43_DMA_RINGMEMSIZE		PAGE_SIZE
 #define B43_DMA0_RX_FRAMEOFFSET		30
 
 /* DMA engine tuning knobs */
-#define B43_TXRING_SLOTS		128
+#define B43_TXRING_SLOTS		256
 #define B43_RXRING_SLOTS		64
 #define B43_DMA0_RX_BUFFERSIZE		IEEE80211_MAX_FRAME_LEN
 
 
 struct sk_buff;
 struct b43_private;
@@ -209,13 +209,13 @@ struct b43_dmaring {
 	/* Lowlevel DMA ops. */
 	const struct b43_dma_ops *ops;
 	/* Kernel virtual base address of the ring memory. */
 	void *descbase;
 	/* Meta data about all descriptors. */
 	struct b43_dmadesc_meta *meta;
-	/* Cache of TX headers for each slot.
+	/* Cache of TX headers for each TX frame.
 	 * This is to avoid an allocation on each TX.
 	 * This is NULL for an RX ring.
 	 */
 	u8 *txhdr_cache;
 	/* (Unadjusted) DMA base bus-address of the ring memory. */
 	dma_addr_t dmabase;

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 00:09:42 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 00:09:42 +0100
Subject: [PATCH] b43: Add slot count compiletime assertion
Message-ID: <200902200009.42967.mb@bu3sch.de>

This adds a compiletime assertion for a recently introduced
assumption on the slot counts.
The tx header cache handling code assumes that the TX slot count
can be divided evenly by the number of TX slots per frame.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Please queue on top of the DMA optimizations.


Index: wireless-testing/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/dma.c	2009-02-19 23:34:25.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/dma.c	2009-02-20 00:03:30.000000000 +0100
@@ -839,12 +839,16 @@ struct b43_dmaring *b43_setup_dmaring(st
 	spin_lock_init(&ring->lock);
 #ifdef CONFIG_B43_DEBUG
 	ring->last_injected_overflow = jiffies;
 #endif
 
 	if (for_tx) {
+		/* Assumption: B43_TXRING_SLOTS can be divided by TX_SLOTS_PER_FRAME */
+		BUILD_BUG_ON((B43_TXRING_SLOTS * 1000000) / TX_SLOTS_PER_FRAME !=
+			     (B43_TXRING_SLOTS / TX_SLOTS_PER_FRAME) * 1000000);
+
 		ring->txhdr_cache = kcalloc(ring->nr_slots / TX_SLOTS_PER_FRAME,
 					    b43_txhdr_size(dev),
 					    GFP_KERNEL);
 		if (!ring->txhdr_cache)
 			goto err_kfree_meta;
 

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 11:32:55 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 11:32:55 +0100
Subject: [PATCH] b43: Add slot count compiletime assertion
In-Reply-To: <200902200009.42967.mb@bu3sch.de>
References: <200902200009.42967.mb@bu3sch.de>
Message-ID: <200902201132.55783.mb@bu3sch.de>

On Friday 20 February 2009 00:09:42 Michael Buesch wrote:
> This adds a compiletime assertion for a recently introduced
> assumption on the slot counts.
> The tx header cache handling code assumes that the TX slot count
> can be divided evenly by the number of TX slots per frame.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> ---
> 
> Please queue on top of the DMA optimizations.

I wonder what I was smoking when doing this patch, yesterday.

I'll immediately get a brown paper bag and redo a sane version of this... :)


-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 12:24:52 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 12:24:52 +0100
Subject: [PATCH v2] b43: Add slot count compiletime assertion
Message-ID: <200902201224.52705.mb@bu3sch.de>

This adds a compiletime assertion for a recently introduced
assumption on the slot counts.
The tx header cache handling code assumes that the TX slot count
can be divided evenly by the number of TX slots per frame.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Coded with a brown paper bad on the head.
Please queue on top of the DMA optimizations.


Index: wireless-testing/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/dma.c	2009-02-19 23:34:25.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/dma.c	2009-02-20 12:20:37.000000000 +0100
@@ -839,12 +839,15 @@ struct b43_dmaring *b43_setup_dmaring(st
 	spin_lock_init(&ring->lock);
 #ifdef CONFIG_B43_DEBUG
 	ring->last_injected_overflow = jiffies;
 #endif
 
 	if (for_tx) {
+		/* Assumption: B43_TXRING_SLOTS can be divided by TX_SLOTS_PER_FRAME */
+		BUILD_BUG_ON(B43_TXRING_SLOTS % TX_SLOTS_PER_FRAME != 0);
+
 		ring->txhdr_cache = kcalloc(ring->nr_slots / TX_SLOTS_PER_FRAME,
 					    b43_txhdr_size(dev),
 					    GFP_KERNEL);
 		if (!ring->txhdr_cache)
 			goto err_kfree_meta;
 


-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 14:27:15 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 14:27:15 +0100
Subject: [PATCH] b43: Fix radio host flags
Message-ID: <200902201427.15652.mb@bu3sch.de>

This fixes initialization of some radio related hostflags.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, this doesn't fix a known bug. Please queue for the next feature release.


Index: wireless-testing/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/main.c	2009-02-20 12:34:52.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/main.c	2009-02-20 12:34:53.000000000 +0100
@@ -4178,16 +4178,18 @@ static int b43_wireless_core_init(struct
 	if (phy->type == B43_PHYTYPE_G) {
 		hf |= B43_HF_SYMW;
 		if (phy->rev == 1)
 			hf |= B43_HF_GDCW;
 		if (sprom->boardflags_lo & B43_BFL_PACTRL)
 			hf |= B43_HF_OFDMPABOOST;
-	} else if (phy->type == B43_PHYTYPE_B) {
-		hf |= B43_HF_SYMW;
-		if (phy->rev >= 2 && phy->radio_ver == 0x2050)
-			hf &= ~B43_HF_GDCW;
+	}
+	if (phy->radio_ver == 0x2050) {
+		if (phy->radio_rev == 6)
+			hf |= B43_HF_4318TSSI;
+		if (phy->radio_rev < 6)
+			hf |= B43_HF_VCORECALC;
 	}
 	b43_hf_write(dev, hf);
 
 	b43_set_retry_limits(dev, B43_DEFAULT_SHORT_RETRY_LIMIT,
 			     B43_DEFAULT_LONG_RETRY_LIMIT);
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_SFFBLIM, 3);

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 14:47:56 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 14:47:56 +0100
Subject: [PATCH] b43: Honor the no-slow-clock boardflag
Message-ID: <200902201447.57019.mb@bu3sch.de>

Do not turn off the crystal, if the boardflags tell us so.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, this doesn't fix known bugs. Please queue for the next feature release.


Index: wireless-testing/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/main.c	2009-02-20 12:34:53.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/main.c	2009-02-20 14:41:53.000000000 +0100
@@ -4185,12 +4185,14 @@ static int b43_wireless_core_init(struct
 	if (phy->radio_ver == 0x2050) {
 		if (phy->radio_rev == 6)
 			hf |= B43_HF_4318TSSI;
 		if (phy->radio_rev < 6)
 			hf |= B43_HF_VCORECALC;
 	}
+	if (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW)
+		hf |= B43_HF_DSCRQ; /* Disable slowclock requests from ucode. */
 	b43_hf_write(dev, hf);
 
 	b43_set_retry_limits(dev, B43_DEFAULT_SHORT_RETRY_LIMIT,
 			     B43_DEFAULT_LONG_RETRY_LIMIT);
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_SFFBLIM, 3);
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_LFFBLIM, 2);
@@ -4223,13 +4225,13 @@ static int b43_wireless_core_init(struct
 	if (err)
 		goto err_chip_exit;
 	b43_qos_init(dev);
 	b43_set_synth_pu_delay(dev, 1);
 	b43_bluetooth_coext_enable(dev);
 
-	ssb_bus_powerup(bus, 1);	/* Enable dynamic PCTL */
+	ssb_bus_powerup(bus, !(sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW));
 	b43_upload_card_macaddress(dev);
 	b43_security_init(dev);
 	if (!dev->suspend_in_progress)
 		b43_rng_init(wl);
 
 	b43_set_status(dev, B43_STAT_INITIALIZED);

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 14:58:59 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 14:58:59 +0100
Subject: [PATCH] b43: Enable PCI slow clock workaround, if needed.
Message-ID: <200902201458.59759.mb@bu3sch.de>

Enable the PCI slow clock workaround, if we're running a PCI core rev <= 10.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, this doesn't fix know bugs. Please queue for the next feature release.


Index: wireless-testing/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/main.c	2009-02-20 14:41:53.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/main.c	2009-02-20 14:53:23.000000000 +0100
@@ -4187,12 +4187,15 @@ static int b43_wireless_core_init(struct
 			hf |= B43_HF_4318TSSI;
 		if (phy->radio_rev < 6)
 			hf |= B43_HF_VCORECALC;
 	}
 	if (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW)
 		hf |= B43_HF_DSCRQ; /* Disable slowclock requests from ucode. */
+	if ((bus->bustype == SSB_BUSTYPE_PCI) &&
+	    (bus->pcicore.dev->id.revision <= 10))
+		hf |= B43_HF_PCISCW; /* PCI slow clock workaround. */
 	b43_hf_write(dev, hf);
 
 	b43_set_retry_limits(dev, B43_DEFAULT_SHORT_RETRY_LIMIT,
 			     B43_DEFAULT_LONG_RETRY_LIMIT);
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_SFFBLIM, 3);
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_LFFBLIM, 2);

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 15:39:21 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 15:39:21 +0100
Subject: [PATCH] b43: Implement sw scan callbacks
Message-ID: <200902201539.21888.mb@bu3sch.de>

This implements the new sw scan callbacks in b43.
They are currently used to turn CFP update in the microcode off while scanning.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, please put on top of the mac80211 sw scan notifier patch.


Index: wireless-testing/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/main.c	2009-02-20 14:53:23.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/main.c	2009-02-20 15:34:41.000000000 +0100
@@ -4190,12 +4190,13 @@ static int b43_wireless_core_init(struct
 	}
 	if (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW)
 		hf |= B43_HF_DSCRQ; /* Disable slowclock requests from ucode. */
 	if ((bus->bustype == SSB_BUSTYPE_PCI) &&
 	    (bus->pcicore.dev->id.revision <= 10))
 		hf |= B43_HF_PCISCW; /* PCI slow clock workaround. */
+	hf &= ~B43_HF_SKCFPUP;
 	b43_hf_write(dev, hf);
 
 	b43_set_retry_limits(dev, B43_DEFAULT_SHORT_RETRY_LIMIT,
 			     B43_DEFAULT_LONG_RETRY_LIMIT);
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_SFFBLIM, 3);
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_LFFBLIM, 2);
@@ -4412,12 +4413,40 @@ static void b43_op_sta_notify(struct iee
 {
 	struct b43_wl *wl = hw_to_b43_wl(hw);
 
 	B43_WARN_ON(!vif || wl->vif != vif);
 }
 
+static void b43_op_sw_scan_start_notifier(struct ieee80211_hw *hw)
+{
+	struct b43_wl *wl = hw_to_b43_wl(hw);
+	struct b43_wldev *dev;
+
+	mutex_lock(&wl->mutex);
+	dev = wl->current_dev;
+	if (dev && (b43_status(dev) >= B43_STAT_INITIALIZED)) {
+		/* Disable CFP update during scan on other channels. */
+		b43_hf_write(dev, b43_hf_read(dev) | B43_HF_SKCFPUP);
+	}
+	mutex_unlock(&wl->mutex);
+}
+
+static void b43_op_sw_scan_complete_notifier(struct ieee80211_hw *hw)
+{
+	struct b43_wl *wl = hw_to_b43_wl(hw);
+	struct b43_wldev *dev;
+
+	mutex_lock(&wl->mutex);
+	dev = wl->current_dev;
+	if (dev && (b43_status(dev) >= B43_STAT_INITIALIZED)) {
+		/* Re-enable CFP update. */
+		b43_hf_write(dev, b43_hf_read(dev) & ~B43_HF_SKCFPUP);
+	}
+	mutex_unlock(&wl->mutex);
+}
+
 static const struct ieee80211_ops b43_hw_ops = {
 	.tx			= b43_op_tx,
 	.conf_tx		= b43_op_conf_tx,
 	.add_interface		= b43_op_add_interface,
 	.remove_interface	= b43_op_remove_interface,
 	.config			= b43_op_config,
@@ -4430,12 +4459,14 @@ static const struct ieee80211_ops b43_hw
 	.get_tsf		= b43_op_get_tsf,
 	.set_tsf		= b43_op_set_tsf,
 	.start			= b43_op_start,
 	.stop			= b43_op_stop,
 	.set_tim		= b43_op_beacon_set_tim,
 	.sta_notify		= b43_op_sta_notify,
+	.sw_scan_start		= b43_op_sw_scan_start_notifier,
+	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
 };
 
 /* Hard-reset the chip. Do not call this directly.
  * Use b43_controller_restart()
  */
 static void b43_chip_reset(struct work_struct *work)

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 19:19:15 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 19:19:15 +0100
Subject: [PATCH 0/6] b43: Use spatch to convert register accesses
Message-ID: <200902201854.22114.mb@bu3sch.de>

Some time ago I rejected a bunch of patches that converted the
PHY/radio register accesses to the new API. That was due to the patches
being created manually. This introduces a huge potential to add new bugs.

However, this is an excellent task for coccinelle/spatch.
So here's a series of patches, to convert the API usage, that were generated
with spatch. This should keep the chances of breaking something as low as possible.

This reduces the .ko size by about 6 kiB.

The used semantic patches will be included in the patch headers.

John, please queue these patches for the next feature release.

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 19:25:05 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 19:25:05 +0100
Subject: [PATCH 2/6] b43: Convert usage of b43_phy_mask()
Message-ID: <20090220183555.5A08616E777@mail.berlios.de>

This patch converts code to use the new b43_phy_mask() API.

The semantic patch that makes this change is as follows:

// <smpl>
@@
expression dev, addr, mask;
@@

-b43_phy_write(dev, addr, b43_phy_read(dev, addr) & mask);
+b43_phy_mask(dev, addr, mask);
// </smpl>

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Index: wireless-testing/drivers/net/wireless/b43/phy_a.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_a.c	2009-02-20 19:04:18.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_a.c	2009-02-20 19:05:38.000000000 +0100
@@ -221,14 +221,13 @@ static void b43_phy_rssiagc(struct b43_w
 
 static void b43_phy_ww(struct b43_wldev *dev)
 {
 	u16 b, curr_s, best_s = 0xFFFF;
 	int i;
 
-	b43_phy_write(dev, B43_PHY_CRS0,
-		b43_phy_read(dev, B43_PHY_CRS0) & ~B43_PHY_CRS0_EN);
+	b43_phy_mask(dev, B43_PHY_CRS0, ~B43_PHY_CRS0_EN);
 	b43_phy_set(dev, B43_PHY_OFDM(0x1B), 0x1000);
 	b43_phy_write(dev, B43_PHY_OFDM(0x82),
 		(b43_phy_read(dev, B43_PHY_OFDM(0x82)) & 0xF0FF) | 0x0300);
 	b43_radio_write16(dev, 0x0009,
 		b43_radio_read16(dev, 0x0009) | 0x0080);
 	b43_radio_write16(dev, 0x0012,
@@ -295,19 +294,17 @@ void b43_phy_inita(struct b43_wldev *dev
 		    (phy->type != B43_PHYTYPE_G));
 
 	might_sleep();
 
 	if (phy->rev >= 6) {
 		if (phy->type == B43_PHYTYPE_A)
-			b43_phy_write(dev, B43_PHY_OFDM(0x1B),
-				b43_phy_read(dev, B43_PHY_OFDM(0x1B)) & ~0x1000);
+			b43_phy_mask(dev, B43_PHY_OFDM(0x1B), ~0x1000);
 		if (b43_phy_read(dev, B43_PHY_ENCORE) & B43_PHY_ENCORE_EN)
 			b43_phy_set(dev, B43_PHY_ENCORE, 0x0010);
 		else
-			b43_phy_write(dev, B43_PHY_ENCORE,
-				b43_phy_read(dev, B43_PHY_ENCORE) & ~0x1010);
+			b43_phy_mask(dev, B43_PHY_ENCORE, ~0x1010);
 	}
 
 	b43_wa_all(dev);
 
 	if (phy->type == B43_PHYTYPE_A) {
 		if (phy->gmode && (phy->rev < 3))
@@ -512,14 +509,14 @@ static void b43_aphy_op_software_rfkill(
 
 	if (state == RFKILL_STATE_UNBLOCKED) {
 		if (phy->radio_on)
 			return;
 		b43_radio_write16(dev, 0x0004, 0x00C0);
 		b43_radio_write16(dev, 0x0005, 0x0008);
-		b43_phy_write(dev, 0x0010, b43_phy_read(dev, 0x0010) & 0xFFF7);
-		b43_phy_write(dev, 0x0011, b43_phy_read(dev, 0x0011) & 0xFFF7);
+		b43_phy_mask(dev, 0x0010, 0xFFF7);
+		b43_phy_mask(dev, 0x0011, 0xFFF7);
 		b43_radio_init2060(dev);
 	} else {
 		b43_radio_write16(dev, 0x0004, 0x00FF);
 		b43_radio_write16(dev, 0x0005, 0x00FB);
 		b43_phy_set(dev, 0x0010, 0x0008);
 		b43_phy_set(dev, 0x0011, 0x0008);
Index: wireless-testing/drivers/net/wireless/b43/phy_g.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_g.c	2009-02-20 19:04:18.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_g.c	2009-02-20 19:05:38.000000000 +0100
@@ -451,19 +451,19 @@ static void b43_calc_nrssi_offset(struct
 	backup[7] = b43_phy_read(dev, 0x0058);
 	backup[8] = b43_phy_read(dev, 0x000A);
 	backup[9] = b43_phy_read(dev, 0x0003);
 	backup[10] = b43_radio_read16(dev, 0x007A);
 	backup[11] = b43_radio_read16(dev, 0x0043);
 
-	b43_phy_write(dev, 0x0429, b43_phy_read(dev, 0x0429) & 0x7FFF);
+	b43_phy_mask(dev, 0x0429, 0x7FFF);
 	b43_phy_write(dev, 0x0001,
 		      (b43_phy_read(dev, 0x0001) & 0x3FFF) | 0x4000);
 	b43_phy_set(dev, 0x0811, 0x000C);
 	b43_phy_write(dev, 0x0812,
 		      (b43_phy_read(dev, 0x0812) & 0xFFF3) | 0x0004);
-	b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & ~(0x1 | 0x2));
+	b43_phy_mask(dev, 0x0802, ~(0x1 | 0x2));
 	if (phy->rev >= 6) {
 		backup[12] = b43_phy_read(dev, 0x002E);
 		backup[13] = b43_phy_read(dev, 0x002F);
 		backup[14] = b43_phy_read(dev, 0x080F);
 		backup[15] = b43_phy_read(dev, 0x0810);
 		backup[16] = b43_phy_read(dev, 0x0801);
@@ -502,14 +502,13 @@ static void b43_calc_nrssi_offset(struct
 			saved = 4;
 	} else {
 		b43_radio_write16(dev, 0x007A,
 				  b43_radio_read16(dev, 0x007A) & 0x007F);
 		if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
 			b43_phy_set(dev, 0x0814, 0x0001);
-			b43_phy_write(dev, 0x0815,
-				      b43_phy_read(dev, 0x0815) & 0xFFFE);
+			b43_phy_mask(dev, 0x0815, 0xFFFE);
 		}
 		b43_phy_set(dev, 0x0811, 0x000C);
 		b43_phy_set(dev, 0x0812, 0x000C);
 		b43_phy_set(dev, 0x0811, 0x0030);
 		b43_phy_set(dev, 0x0812, 0x0030);
 		b43_phy_write(dev, 0x005A, 0x0480);
@@ -519,14 +518,13 @@ static void b43_calc_nrssi_offset(struct
 			b43_phy_write(dev, 0x0003, 0x0122);
 		} else {
 			b43_phy_set(dev, 0x000A, 0x2000);
 		}
 		if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
 			b43_phy_set(dev, 0x0814, 0x0004);
-			b43_phy_write(dev, 0x0815,
-				      b43_phy_read(dev, 0x0815) & 0xFFFB);
+			b43_phy_mask(dev, 0x0815, 0xFFFB);
 		}
 		b43_phy_write(dev, 0x0003, (b43_phy_read(dev, 0x0003) & 0xFF9F)
 			      | 0x0040);
 		b43_radio_write16(dev, 0x007A,
 				  b43_radio_read16(dev, 0x007A) | 0x000F);
 		b43_set_all_gains(dev, 3, 0, 1);
@@ -598,15 +596,14 @@ static void b43_calc_nrssi_slope(struct 
 
 	if (phy->radio_rev >= 9)
 		return;
 	if (phy->radio_rev == 8)
 		b43_calc_nrssi_offset(dev);
 
-	b43_phy_write(dev, B43_PHY_G_CRS,
-		      b43_phy_read(dev, B43_PHY_G_CRS) & 0x7FFF);
-	b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & 0xFFFC);
+	b43_phy_mask(dev, B43_PHY_G_CRS, 0x7FFF);
+	b43_phy_mask(dev, 0x0802, 0xFFFC);
 	backup[7] = b43_read16(dev, 0x03E2);
 	b43_write16(dev, 0x03E2, b43_read16(dev, 0x03E2) | 0x8000);
 	backup[0] = b43_radio_read16(dev, 0x007A);
 	backup[1] = b43_radio_read16(dev, 0x0052);
 	backup[2] = b43_radio_read16(dev, 0x0043);
 	backup[3] = b43_phy_read(dev, 0x0015);
@@ -632,15 +629,13 @@ static void b43_calc_nrssi_slope(struct 
 		case 7:
 			b43_phy_set(dev, 0x0478, 0x0100);
 			b43_phy_set(dev, 0x0801, 0x0040);
 			break;
 		case 3:
 		case 5:
-			b43_phy_write(dev, 0x0801,
-				      b43_phy_read(dev, 0x0801)
-				      & 0xFFBF);
+			b43_phy_mask(dev, 0x0801, 0xFFBF);
 			break;
 		}
 		b43_phy_set(dev, 0x0060, 0x0040);
 		b43_phy_set(dev, 0x0014, 0x0200);
 	}
 	b43_radio_write16(dev, 0x007A,
@@ -714,16 +709,14 @@ static void b43_calc_nrssi_slope(struct 
 		b43_phy_write(dev, 0x002E, backup[10]);
 		b43_phy_write(dev, 0x002F, backup[11]);
 		b43_phy_write(dev, 0x080F, backup[12]);
 		b43_phy_write(dev, B43_PHY_G_LO_CONTROL, backup[13]);
 	}
 	if (phy->rev >= 2) {
-		b43_phy_write(dev, 0x0812,
-			      b43_phy_read(dev, 0x0812) & 0xFFCF);
-		b43_phy_write(dev, 0x0811,
-			      b43_phy_read(dev, 0x0811) & 0xFFCF);
+		b43_phy_mask(dev, 0x0812, 0xFFCF);
+		b43_phy_mask(dev, 0x0811, 0xFFCF);
 	}
 
 	b43_radio_write16(dev, 0x007A, backup[0]);
 	b43_radio_write16(dev, 0x0052, backup[1]);
 	b43_radio_write16(dev, 0x0043, backup[2]);
 	b43_write16(dev, 0x03E2, backup[7]);
@@ -888,15 +881,13 @@ b43_radio_interference_mitigation_enable
 	u32 *stack = gphy->interfstack;
 
 	switch (mode) {
 	case B43_INTERFMODE_NONWLAN:
 		if (phy->rev != 1) {
 			b43_phy_set(dev, 0x042B, 0x0800);
-			b43_phy_write(dev, B43_PHY_G_CRS,
-				      b43_phy_read(dev,
-						   B43_PHY_G_CRS) & ~0x4000);
+			b43_phy_mask(dev, B43_PHY_G_CRS, ~0x4000);
 			break;
 		}
 		radio_stacksave(0x0078);
 		tmp = (b43_radio_read16(dev, 0x0078) & 0x001E);
 		B43_WARN_ON(tmp > 15);
 		flipped = bitrev4(tmp);
@@ -982,15 +973,13 @@ b43_radio_interference_mitigation_enable
 			ofdmtab_stacksave(0x1A00, 0x2);
 			ofdmtab_stacksave(0x1A00, 0x3);
 		}
 		phy_stacksave(0x042B);
 		phy_stacksave(0x048C);
 
-		b43_phy_write(dev, B43_PHY_RADIO_BITFIELD,
-			      b43_phy_read(dev, B43_PHY_RADIO_BITFIELD)
-			      & ~0x1000);
+		b43_phy_mask(dev, B43_PHY_RADIO_BITFIELD, ~0x1000);
 		b43_phy_write(dev, B43_PHY_G_CRS,
 			      (b43_phy_read(dev, B43_PHY_G_CRS)
 			       & 0xFFFC) | 0x0002);
 
 		b43_phy_write(dev, 0x0033, 0x0800);
 		b43_phy_write(dev, 0x04A3, 0x2027);
@@ -1038,14 +1027,13 @@ b43_radio_interference_mitigation_enable
 		b43_phy_write(dev, 0x04A0, (b43_phy_read(dev, 0x04A0)
 					    & 0xF0FF) | 0x0500);
 		b43_phy_write(dev, 0x04A2, (b43_phy_read(dev, 0x04A2)
 					    & 0xFFF0) | 0x000B);
 
 		if (phy->rev >= 3) {
-			b43_phy_write(dev, 0x048A, b43_phy_read(dev, 0x048A)
-				      & ~0x8000);
+			b43_phy_mask(dev, 0x048A, ~0x8000);
 			b43_phy_write(dev, 0x0415, (b43_phy_read(dev, 0x0415)
 						    & 0x8000) | 0x36D8);
 			b43_phy_write(dev, 0x0416, (b43_phy_read(dev, 0x0416)
 						    & 0x8000) | 0x36D8);
 			b43_phy_write(dev, 0x0417, (b43_phy_read(dev, 0x0417)
 						    & 0xFE00) | 0x016D);
@@ -1065,14 +1053,13 @@ b43_radio_interference_mitigation_enable
 						    & 0xFF00) | 0x007F);
 			b43_phy_write(dev, 0x04AD, (b43_phy_read(dev, 0x04AD)
 						    & 0x00FF) | 0x1300);
 		} else if (phy->rev >= 6) {
 			b43_ofdmtab_write16(dev, 0x1A00, 0x3, 0x007F);
 			b43_ofdmtab_write16(dev, 0x1A00, 0x2, 0x007F);
-			b43_phy_write(dev, 0x04AD, b43_phy_read(dev, 0x04AD)
-				      & 0x00FF);
+			b43_phy_mask(dev, 0x04AD, 0x00FF);
 		}
 		b43_calc_nrssi_slope(dev);
 		break;
 	default:
 		B43_WARN_ON(1);
 	}
@@ -1085,25 +1072,22 @@ b43_radio_interference_mitigation_disabl
 	struct b43_phy_g *gphy = phy->g;
 	u32 *stack = gphy->interfstack;
 
 	switch (mode) {
 	case B43_INTERFMODE_NONWLAN:
 		if (phy->rev != 1) {
-			b43_phy_write(dev, 0x042B,
-				      b43_phy_read(dev, 0x042B) & ~0x0800);
+			b43_phy_mask(dev, 0x042B, ~0x0800);
 			b43_phy_set(dev, B43_PHY_G_CRS, 0x4000);
 			break;
 		}
 		radio_stackrestore(0x0078);
 		b43_calc_nrssi_threshold(dev);
 		phy_stackrestore(0x0406);
-		b43_phy_write(dev, 0x042B, b43_phy_read(dev, 0x042B) & ~0x0800);
+		b43_phy_mask(dev, 0x042B, ~0x0800);
 		if (!dev->bad_frames_preempt) {
-			b43_phy_write(dev, B43_PHY_RADIO_BITFIELD,
-				      b43_phy_read(dev, B43_PHY_RADIO_BITFIELD)
-				      & ~(1 << 11));
+			b43_phy_mask(dev, B43_PHY_RADIO_BITFIELD, ~(1 << 11));
 		}
 		b43_phy_set(dev, B43_PHY_G_CRS, 0x4000);
 		phy_stackrestore(0x04A0);
 		phy_stackrestore(0x04A1);
 		phy_stackrestore(0x04A2);
 		phy_stackrestore(0x04A8);
@@ -1368,20 +1352,15 @@ static u16 b43_radio_init2050(struct b43
 		sav.phy_analogoverval =
 		    b43_phy_read(dev, B43_PHY_ANALOGOVERVAL);
 		sav.phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);
 		sav.phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);
 
 		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0003);
-		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
-			      b43_phy_read(dev, B43_PHY_ANALOGOVERVAL)
-			      & 0xFFFC);
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0x7FFF);
-		b43_phy_write(dev, B43_PHY_CLASSCTL,
-			      b43_phy_read(dev, B43_PHY_CLASSCTL)
-			      & 0xFFFC);
+		b43_phy_mask(dev, B43_PHY_ANALOGOVERVAL, 0xFFFC);
+		b43_phy_mask(dev, B43_PHY_CRS0, 0x7FFF);
+		b43_phy_mask(dev, B43_PHY_CLASSCTL, 0xFFFC);
 		if (has_loopback_gain(phy)) {
 			sav.phy_lo_mask = b43_phy_read(dev, B43_PHY_LO_MASK);
 			sav.phy_lo_ctl = b43_phy_read(dev, B43_PHY_LO_CTL);
 
 			if (phy->rev >= 3)
 				b43_phy_write(dev, B43_PHY_LO_MASK, 0xC020);
@@ -1396,14 +1375,13 @@ static u16 b43_radio_init2050(struct b43
 		b43_phy_write(dev, B43_PHY_RFOVER,
 			      radio2050_rfover_val(dev, B43_PHY_RFOVER, 0));
 	}
 	b43_write16(dev, 0x3E2, b43_read16(dev, 0x3E2) | 0x8000);
 
 	sav.phy_syncctl = b43_phy_read(dev, B43_PHY_SYNCCTL);
-	b43_phy_write(dev, B43_PHY_SYNCCTL, b43_phy_read(dev, B43_PHY_SYNCCTL)
-		      & 0xFF7F);
+	b43_phy_mask(dev, B43_PHY_SYNCCTL, 0xFF7F);
 	sav.reg_3E6 = b43_read16(dev, 0x3E6);
 	sav.reg_3F4 = b43_read16(dev, 0x3F4);
 
 	if (phy->analog == 0) {
 		b43_write16(dev, 0x03E6, 0x0122);
 	} else {
@@ -1796,14 +1774,13 @@ static void b43_phy_initb6(struct b43_wl
 	}
 	if (phy->radio_rev <= 2)
 		b43_radio_write16(dev, 0x005D, 0x000D);
 
 	if (phy->analog == 4) {
 		b43_write16(dev, 0x3E4, 9);
-		b43_phy_write(dev, 0x61, b43_phy_read(dev, 0x61)
-			      & 0x0FFF);
+		b43_phy_mask(dev, 0x61, 0x0FFF);
 	} else {
 		b43_phy_write(dev, 0x0002, (b43_phy_read(dev, 0x0002) & 0xFFC0)
 			      | 0x0004);
 	}
 	if (phy->type == B43_PHYTYPE_B)
 		B43_WARN_ON(1);
@@ -1842,30 +1819,23 @@ static void b43_calc_loopback_gain(struc
 	backup_phy[15] = b43_phy_read(dev, B43_PHY_LO_LEAKAGE);
 	backup_bband = gphy->bbatt.att;
 	backup_radio[0] = b43_radio_read16(dev, 0x52);
 	backup_radio[1] = b43_radio_read16(dev, 0x43);
 	backup_radio[2] = b43_radio_read16(dev, 0x7A);
 
-	b43_phy_write(dev, B43_PHY_CRS0,
-		      b43_phy_read(dev, B43_PHY_CRS0) & 0x3FFF);
+	b43_phy_mask(dev, B43_PHY_CRS0, 0x3FFF);
 	b43_phy_set(dev, B43_PHY_CCKBBANDCFG, 0x8000);
 	b43_phy_set(dev, B43_PHY_RFOVER, 0x0002);
-	b43_phy_write(dev, B43_PHY_RFOVERVAL,
-		      b43_phy_read(dev, B43_PHY_RFOVERVAL) & 0xFFFD);
+	b43_phy_mask(dev, B43_PHY_RFOVERVAL, 0xFFFD);
 	b43_phy_set(dev, B43_PHY_RFOVER, 0x0001);
-	b43_phy_write(dev, B43_PHY_RFOVERVAL,
-		      b43_phy_read(dev, B43_PHY_RFOVERVAL) & 0xFFFE);
+	b43_phy_mask(dev, B43_PHY_RFOVERVAL, 0xFFFE);
 	if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
 		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0001);
-		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
-			      b43_phy_read(dev,
-					   B43_PHY_ANALOGOVERVAL) & 0xFFFE);
+		b43_phy_mask(dev, B43_PHY_ANALOGOVERVAL, 0xFFFE);
 		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0002);
-		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
-			      b43_phy_read(dev,
-					   B43_PHY_ANALOGOVERVAL) & 0xFFFD);
+		b43_phy_mask(dev, B43_PHY_ANALOGOVERVAL, 0xFFFD);
 	}
 	b43_phy_set(dev, B43_PHY_RFOVER, 0x000C);
 	b43_phy_set(dev, B43_PHY_RFOVERVAL, 0x000C);
 	b43_phy_set(dev, B43_PHY_RFOVER, 0x0030);
 	b43_phy_write(dev, B43_PHY_RFOVERVAL,
 		      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
@@ -1875,15 +1845,13 @@ static void b43_calc_loopback_gain(struc
 	b43_phy_write(dev, B43_PHY_CCK(0x59), 0xC810);
 	b43_phy_write(dev, B43_PHY_CCK(0x58), 0x000D);
 
 	b43_phy_set(dev, B43_PHY_CCK(0x0A), 0x2000);
 	if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
 		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0004);
-		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
-			      b43_phy_read(dev,
-					   B43_PHY_ANALOGOVERVAL) & 0xFFFB);
+		b43_phy_mask(dev, B43_PHY_ANALOGOVERVAL, 0xFFFB);
 	}
 	b43_phy_write(dev, B43_PHY_CCK(0x03),
 		      (b43_phy_read(dev, B43_PHY_CCK(0x03))
 		       & 0xFF9F) | 0x40);
 
 	if (phy->radio_rev == 8) {
@@ -1906,14 +1874,13 @@ static void b43_calc_loopback_gain(struc
 		       & 0xFFC0) | 0x01);
 	b43_phy_write(dev, B43_PHY_CCK(0x2B),
 		      (b43_phy_read(dev, B43_PHY_CCK(0x2B))
 		       & 0xC0FF) | 0x800);
 
 	b43_phy_set(dev, B43_PHY_RFOVER, 0x0100);
-	b43_phy_write(dev, B43_PHY_RFOVERVAL,
-		      b43_phy_read(dev, B43_PHY_RFOVERVAL) & 0xCFFF);
+	b43_phy_mask(dev, B43_PHY_RFOVERVAL, 0xCFFF);
 
 	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_EXTLNA) {
 		if (phy->rev >= 7) {
 			b43_phy_set(dev, B43_PHY_RFOVER, 0x0800);
 			b43_phy_set(dev, B43_PHY_RFOVERVAL, 0x8000);
 		}
@@ -1999,13 +1966,13 @@ static void b43_hardware_pctl_early_init
 
 	if (!b43_has_hardware_pctl(dev)) {
 		b43_phy_write(dev, 0x047A, 0xC111);
 		return;
 	}
 
-	b43_phy_write(dev, 0x0036, b43_phy_read(dev, 0x0036) & 0xFEFF);
+	b43_phy_mask(dev, 0x0036, 0xFEFF);
 	b43_phy_write(dev, 0x002F, 0x0202);
 	b43_phy_set(dev, 0x047C, 0x0002);
 	b43_phy_set(dev, 0x047A, 0xF000);
 	if (phy->radio_ver == 0x2050 && phy->radio_rev == 8) {
 		b43_phy_write(dev, 0x047A, (b43_phy_read(dev, 0x047A)
 					    & 0xFF0F) | 0x0010);
@@ -2014,16 +1981,14 @@ static void b43_hardware_pctl_early_init
 					    & 0xFFC0) | 0x0010);
 		b43_phy_write(dev, 0x002E, 0xC07F);
 		b43_phy_set(dev, 0x0036, 0x0400);
 	} else {
 		b43_phy_set(dev, 0x0036, 0x0200);
 		b43_phy_set(dev, 0x0036, 0x0400);
-		b43_phy_write(dev, 0x005D, b43_phy_read(dev, 0x005D)
-			      & 0x7FFF);
-		b43_phy_write(dev, 0x004F, b43_phy_read(dev, 0x004F)
-			      & 0xFFFE);
+		b43_phy_mask(dev, 0x005D, 0x7FFF);
+		b43_phy_mask(dev, 0x004F, 0xFFFE);
 		b43_phy_write(dev, 0x004E, (b43_phy_read(dev, 0x004E)
 					    & 0xFFC0) | 0x0010);
 		b43_phy_write(dev, 0x002E, 0xC07F);
 		b43_phy_write(dev, 0x047A, (b43_phy_read(dev, 0x047A)
 					    & 0xFF0F) | 0x0010);
 	}
@@ -2044,21 +2009,19 @@ static void b43_hardware_pctl_init_gphy(
 	b43_phy_write(dev, 0x0036, (b43_phy_read(dev, 0x0036) & 0xFFC0)
 		      | (gphy->tgt_idle_tssi - gphy->cur_idle_tssi));
 	b43_phy_write(dev, 0x0478, (b43_phy_read(dev, 0x0478) & 0xFF00)
 		      | (gphy->tgt_idle_tssi - gphy->cur_idle_tssi));
 	b43_gphy_tssi_power_lt_init(dev);
 	b43_gphy_gain_lt_init(dev);
-	b43_phy_write(dev, 0x0060, b43_phy_read(dev, 0x0060) & 0xFFBF);
+	b43_phy_mask(dev, 0x0060, 0xFFBF);
 	b43_phy_write(dev, 0x0014, 0x0000);
 
 	B43_WARN_ON(phy->rev < 6);
 	b43_phy_set(dev, 0x0478, 0x0800);
-	b43_phy_write(dev, 0x0478, b43_phy_read(dev, 0x0478)
-		      & 0xFEFF);
-	b43_phy_write(dev, 0x0801, b43_phy_read(dev, 0x0801)
-		      & 0xFFBF);
+	b43_phy_mask(dev, 0x0478, 0xFEFF);
+	b43_phy_mask(dev, 0x0801, 0xFFBF);
 
 	b43_gphy_dc_lt_init(dev, 1);
 
 	/* Enable hardware pctl in firmware. */
 	b43_hf_write(dev, b43_hf_read(dev) | B43_HF_HWPCTL);
 }
@@ -2242,17 +2205,14 @@ static void b43_phy_initg(struct b43_wld
 	b43_phy_init_pctl(dev);
 	/* FIXME: The spec says in the following if, the 0 should be replaced
 	   'if OFDM may not be used in the current locale'
 	   but OFDM is legal everywhere */
 	if ((dev->dev->bus->chip_id == 0x4306
 	     && dev->dev->bus->chip_package == 2) || 0) {
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0xBFFF);
-		b43_phy_write(dev, B43_PHY_OFDM(0xC3),
-			      b43_phy_read(dev, B43_PHY_OFDM(0xC3))
-			      & 0x7FFF);
+		b43_phy_mask(dev, B43_PHY_CRS0, 0xBFFF);
+		b43_phy_mask(dev, B43_PHY_OFDM(0xC3), 0x7FFF);
 	}
 }
 
 void b43_gphy_channel_switch(struct b43_wldev *dev,
 			     unsigned int channel,
 			     bool synthetic_pu_workaround)
@@ -2448,28 +2408,27 @@ static u8 b43_gphy_aci_scan(struct b43_w
 
 	if (!((phy->type == B43_PHYTYPE_G) && (phy->rev > 0)))
 		return 0;
 
 	b43_phy_lock(dev);
 	b43_radio_lock(dev);
-	b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & 0xFFFC);
-	b43_phy_write(dev, B43_PHY_G_CRS,
-		      b43_phy_read(dev, B43_PHY_G_CRS) & 0x7FFF);
+	b43_phy_mask(dev, 0x0802, 0xFFFC);
+	b43_phy_mask(dev, B43_PHY_G_CRS, 0x7FFF);
 	b43_set_all_gains(dev, 3, 8, 1);
 
 	start = (channel - 5 > 0) ? channel - 5 : 1;
 	end = (channel + 5 < 14) ? channel + 5 : 13;
 
 	for (i = start; i <= end; i++) {
 		if (abs(channel - i) > 2)
 			ret[i - 1] = b43_gphy_aci_detect(dev, i);
 	}
 	b43_switch_channel(dev, channel);
 	b43_phy_write(dev, 0x0802,
 		      (b43_phy_read(dev, 0x0802) & 0xFFFC) | 0x0003);
-	b43_phy_write(dev, 0x0403, b43_phy_read(dev, 0x0403) & 0xFFF8);
+	b43_phy_mask(dev, 0x0403, 0xFFF8);
 	b43_phy_set(dev, B43_PHY_G_CRS, 0x8000);
 	b43_set_original_gains(dev);
 	for (i = 0; i < 13; i++) {
 		if (!ret[i])
 			continue;
 		end = (i + 5 < 13) ? i + 5 : 13;
Index: wireless-testing/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/lo.c	2009-02-20 19:05:21.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/lo.c	2009-02-20 19:06:05.000000000 +0100
@@ -423,21 +423,16 @@ static void lo_measure_setup(struct b43_
 		sav->phy_rfover = b43_phy_read(dev, B43_PHY_RFOVER);
 		sav->phy_rfoverval = b43_phy_read(dev, B43_PHY_RFOVERVAL);
 		sav->phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);
 		sav->phy_cck_3E = b43_phy_read(dev, B43_PHY_CCK(0x3E));
 		sav->phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);
 
-		b43_phy_write(dev, B43_PHY_CLASSCTL,
-			      b43_phy_read(dev, B43_PHY_CLASSCTL)
-			      & 0xFFFC);
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0x7FFF);
+		b43_phy_mask(dev, B43_PHY_CLASSCTL, 0xFFFC);
+		b43_phy_mask(dev, B43_PHY_CRS0, 0x7FFF);
 		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0003);
-		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
-			      b43_phy_read(dev, B43_PHY_ANALOGOVERVAL)
-			      & 0xFFFC);
+		b43_phy_mask(dev, B43_PHY_ANALOGOVERVAL, 0xFFFC);
 		if (phy->type == B43_PHYTYPE_G) {
 			if ((phy->rev >= 7) &&
 			    (sprom->boardflags_lo & B43_BFL_EXTLNA)) {
 				b43_phy_write(dev, B43_PHY_RFOVER, 0x933);
 			} else {
 				b43_phy_write(dev, B43_PHY_RFOVER, 0x133);
Index: wireless-testing/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/wa.c	2009-02-20 19:05:28.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/wa.c	2009-02-20 19:06:00.000000000 +0100
@@ -59,14 +59,13 @@ static void b43_wa_txdc_offset(struct b4
 
 void b43_wa_initgains(struct b43_wldev *dev)
 {
 	struct b43_phy *phy = &dev->phy;
 
 	b43_phy_write(dev, B43_PHY_LNAHPFCTL, 0x1FF9);
-	b43_phy_write(dev, B43_PHY_LPFGAINCTL,
-		b43_phy_read(dev, B43_PHY_LPFGAINCTL) & 0xFF0F);
+	b43_phy_mask(dev, B43_PHY_LPFGAINCTL, 0xFF0F);
 	if (phy->rev <= 2)
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_LPFGAIN, 0, 0x1FBF);
 	b43_radio_write16(dev, 0x0002, 0x1FBF);
 
 	b43_phy_write(dev, 0x0024, 0x4680);
 	b43_phy_write(dev, 0x0020, 0x0003);
@@ -83,13 +82,13 @@ void b43_wa_initgains(struct b43_wldev *
 	if (phy->rev >= 3)
 		b43_phy_write(dev, 0x00BA, 0x3ED5);
 }
 
 static void b43_wa_divider(struct b43_wldev *dev)
 {
-	b43_phy_write(dev, 0x002B, b43_phy_read(dev, 0x002B) & ~0x0100);
+	b43_phy_mask(dev, 0x002B, ~0x0100);
 	b43_phy_write(dev, 0x008E, 0x58C1);
 }
 
 static void b43_wa_gt(struct b43_wldev *dev) /* Gain table. */
 {
 	if (dev->phy.rev <= 2) {
@@ -430,14 +429,13 @@ static void b43_wa_altagc(struct b43_wld
 		(b43_phy_read(dev, B43_PHY_OFDM(0x81)) & ~0xFF00) | 0x2C00);
 	if (phy->rev == 1) {
 		b43_phy_write(dev, B43_PHY_PEAK_COUNT, 0x092B);
 		b43_phy_write(dev, B43_PHY_OFDM(0x1B),
 			(b43_phy_read(dev, B43_PHY_OFDM(0x1B)) & ~0x001E) | 0x0002);
 	} else {
-		b43_phy_write(dev, B43_PHY_OFDM(0x1B),
-			b43_phy_read(dev, B43_PHY_OFDM(0x1B)) & ~0x001E);
+		b43_phy_mask(dev, B43_PHY_OFDM(0x1B), ~0x001E);
 		b43_phy_write(dev, B43_PHY_OFDM(0x1F), 0x287A);
 		b43_phy_write(dev, B43_PHY_LPFGAINCTL,
 			(b43_phy_read(dev, B43_PHY_LPFGAINCTL) & ~0x000F) | 0x0004);
 		if (phy->rev >= 6) {
 			b43_phy_write(dev, B43_PHY_OFDM(0x22), 0x287A);
 			b43_phy_write(dev, B43_PHY_LPFGAINCTL,
@@ -462,16 +460,14 @@ static void b43_wa_altagc(struct b43_wld
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 0, 0);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 1, 7);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 2, 16);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 3, 28);
 	}
 	if (phy->rev >= 6) {
-		b43_phy_write(dev, B43_PHY_OFDM(0x26),
-			b43_phy_read(dev, B43_PHY_OFDM(0x26)) & ~0x0003);
-		b43_phy_write(dev, B43_PHY_OFDM(0x26),
-			b43_phy_read(dev, B43_PHY_OFDM(0x26)) & ~0x1000);
+		b43_phy_mask(dev, B43_PHY_OFDM(0x26), ~0x0003);
+		b43_phy_mask(dev, B43_PHY_OFDM(0x26), ~0x1000);
 	}
 	b43_phy_read(dev, B43_PHY_VERSION_OFDM); /* Dummy read */
 }
 
 static void b43_wa_tr_ltov(struct b43_wldev *dev) /* TR Lookup Table Original Values */
 {
@@ -531,14 +527,13 @@ static void b43_wa_boards_g(struct b43_w
 			b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX_R1, 2, 0x0001);
 		} else {
 			b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 1, 0x0002);
 			b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 2, 0x0001);
 			if ((bus->sprom.boardflags_lo & B43_BFL_EXTLNA) &&
 			    (phy->rev >= 7)) {
-				b43_phy_write(dev, B43_PHY_EXTG(0x11),
-					b43_phy_read(dev, B43_PHY_EXTG(0x11)) & 0xF7FF);
+				b43_phy_mask(dev, B43_PHY_EXTG(0x11), 0xF7FF);
 				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0020, 0x0001);
 				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0021, 0x0001);
 				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0022, 0x0001);
 				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0023, 0x0000);
 				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0000, 0x0000);
 				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0003, 0x0002);

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 19:22:36 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 19:22:36 +0100
Subject: [PATCH 1/6] b43: Convert usage of b43_phy_set()
Message-ID: <20090220183555.825E3172143@mail.berlios.de>

This patch converts code to use the new b43_phy_set() API.

The semantic patch that makes this change is as follows:

// <smpl>
@@
expression dev, addr, set;
@@

-b43_phy_write(dev, addr, b43_phy_read(dev, addr) | set);
+b43_phy_set(dev, addr, set);
// </smpl>

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Index: wireless-testing/drivers/net/wireless/b43/phy_a.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_a.c	2009-01-23 19:18:42.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_a.c	2009-02-20 19:04:18.000000000 +0100
@@ -223,14 +223,13 @@ static void b43_phy_ww(struct b43_wldev 
 {
 	u16 b, curr_s, best_s = 0xFFFF;
 	int i;
 
 	b43_phy_write(dev, B43_PHY_CRS0,
 		b43_phy_read(dev, B43_PHY_CRS0) & ~B43_PHY_CRS0_EN);
-	b43_phy_write(dev, B43_PHY_OFDM(0x1B),
-		b43_phy_read(dev, B43_PHY_OFDM(0x1B)) | 0x1000);
+	b43_phy_set(dev, B43_PHY_OFDM(0x1B), 0x1000);
 	b43_phy_write(dev, B43_PHY_OFDM(0x82),
 		(b43_phy_read(dev, B43_PHY_OFDM(0x82)) & 0xF0FF) | 0x0300);
 	b43_radio_write16(dev, 0x0009,
 		b43_radio_read16(dev, 0x0009) | 0x0080);
 	b43_radio_write16(dev, 0x0012,
 		(b43_radio_read16(dev, 0x0012) & 0xFFFC) | 0x0002);
@@ -273,14 +272,13 @@ static void b43_phy_ww(struct b43_wldev 
 	for (i = 0; i < 6; i++)
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, i, 0x000F);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0D, 0x000E);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0E, 0x0011);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0F, 0x0013);
 	b43_phy_write(dev, B43_PHY_OFDM(0x33), 0x5030);
-	b43_phy_write(dev, B43_PHY_CRS0,
-		b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
+	b43_phy_set(dev, B43_PHY_CRS0, B43_PHY_CRS0_EN);
 }
 
 static void hardware_pctl_init_aphy(struct b43_wldev *dev)
 {
 	//TODO
 }
@@ -300,29 +298,26 @@ void b43_phy_inita(struct b43_wldev *dev
 
 	if (phy->rev >= 6) {
 		if (phy->type == B43_PHYTYPE_A)
 			b43_phy_write(dev, B43_PHY_OFDM(0x1B),
 				b43_phy_read(dev, B43_PHY_OFDM(0x1B)) & ~0x1000);
 		if (b43_phy_read(dev, B43_PHY_ENCORE) & B43_PHY_ENCORE_EN)
-			b43_phy_write(dev, B43_PHY_ENCORE,
-				b43_phy_read(dev, B43_PHY_ENCORE) | 0x0010);
+			b43_phy_set(dev, B43_PHY_ENCORE, 0x0010);
 		else
 			b43_phy_write(dev, B43_PHY_ENCORE,
 				b43_phy_read(dev, B43_PHY_ENCORE) & ~0x1010);
 	}
 
 	b43_wa_all(dev);
 
 	if (phy->type == B43_PHYTYPE_A) {
 		if (phy->gmode && (phy->rev < 3))
-			b43_phy_write(dev, 0x0034,
-				b43_phy_read(dev, 0x0034) | 0x0001);
+			b43_phy_set(dev, 0x0034, 0x0001);
 		b43_phy_rssiagc(dev, 0);
 
-		b43_phy_write(dev, B43_PHY_CRS0,
-			b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
+		b43_phy_set(dev, B43_PHY_CRS0, B43_PHY_CRS0_EN);
 
 		b43_radio_init2060(dev);
 
 		if ((bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM) &&
 		    ((bus->boardinfo.type == SSB_BOARD_BU4306) ||
 		     (bus->boardinfo.type == SSB_BOARD_BU4309))) {
@@ -523,14 +518,14 @@ static void b43_aphy_op_software_rfkill(
 		b43_phy_write(dev, 0x0010, b43_phy_read(dev, 0x0010) & 0xFFF7);
 		b43_phy_write(dev, 0x0011, b43_phy_read(dev, 0x0011) & 0xFFF7);
 		b43_radio_init2060(dev);
 	} else {
 		b43_radio_write16(dev, 0x0004, 0x00FF);
 		b43_radio_write16(dev, 0x0005, 0x00FB);
-		b43_phy_write(dev, 0x0010, b43_phy_read(dev, 0x0010) | 0x0008);
-		b43_phy_write(dev, 0x0011, b43_phy_read(dev, 0x0011) | 0x0008);
+		b43_phy_set(dev, 0x0010, 0x0008);
+		b43_phy_set(dev, 0x0011, 0x0008);
 	}
 }
 
 static int b43_aphy_op_switch_channel(struct b43_wldev *dev,
 				      unsigned int new_channel)
 {
Index: wireless-testing/drivers/net/wireless/b43/phy_g.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_g.c	2009-02-20 14:33:18.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_g.c	2009-02-20 19:04:18.000000000 +0100
@@ -454,13 +454,13 @@ static void b43_calc_nrssi_offset(struct
 	backup[10] = b43_radio_read16(dev, 0x007A);
 	backup[11] = b43_radio_read16(dev, 0x0043);
 
 	b43_phy_write(dev, 0x0429, b43_phy_read(dev, 0x0429) & 0x7FFF);
 	b43_phy_write(dev, 0x0001,
 		      (b43_phy_read(dev, 0x0001) & 0x3FFF) | 0x4000);
-	b43_phy_write(dev, 0x0811, b43_phy_read(dev, 0x0811) | 0x000C);
+	b43_phy_set(dev, 0x0811, 0x000C);
 	b43_phy_write(dev, 0x0812,
 		      (b43_phy_read(dev, 0x0812) & 0xFFF3) | 0x0004);
 	b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & ~(0x1 | 0x2));
 	if (phy->rev >= 6) {
 		backup[12] = b43_phy_read(dev, 0x002E);
 		backup[13] = b43_phy_read(dev, 0x002F);
@@ -472,16 +472,16 @@ static void b43_calc_nrssi_offset(struct
 		backup[19] = b43_phy_read(dev, 0x0478);
 
 		b43_phy_write(dev, 0x002E, 0);
 		b43_phy_write(dev, 0x002F, 0);
 		b43_phy_write(dev, 0x080F, 0);
 		b43_phy_write(dev, 0x0810, 0);
-		b43_phy_write(dev, 0x0478, b43_phy_read(dev, 0x0478) | 0x0100);
-		b43_phy_write(dev, 0x0801, b43_phy_read(dev, 0x0801) | 0x0040);
-		b43_phy_write(dev, 0x0060, b43_phy_read(dev, 0x0060) | 0x0040);
-		b43_phy_write(dev, 0x0014, b43_phy_read(dev, 0x0014) | 0x0200);
+		b43_phy_set(dev, 0x0478, 0x0100);
+		b43_phy_set(dev, 0x0801, 0x0040);
+		b43_phy_set(dev, 0x0060, 0x0040);
+		b43_phy_set(dev, 0x0014, 0x0200);
 	}
 	b43_radio_write16(dev, 0x007A, b43_radio_read16(dev, 0x007A) | 0x0070);
 	b43_radio_write16(dev, 0x007A, b43_radio_read16(dev, 0x007A) | 0x0080);
 	udelay(30);
 
 	v47F = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
@@ -501,33 +501,30 @@ static void b43_calc_nrssi_offset(struct
 		if (saved == 0xFFFF)
 			saved = 4;
 	} else {
 		b43_radio_write16(dev, 0x007A,
 				  b43_radio_read16(dev, 0x007A) & 0x007F);
 		if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
-			b43_phy_write(dev, 0x0814,
-				      b43_phy_read(dev, 0x0814) | 0x0001);
+			b43_phy_set(dev, 0x0814, 0x0001);
 			b43_phy_write(dev, 0x0815,
 				      b43_phy_read(dev, 0x0815) & 0xFFFE);
 		}
-		b43_phy_write(dev, 0x0811, b43_phy_read(dev, 0x0811) | 0x000C);
-		b43_phy_write(dev, 0x0812, b43_phy_read(dev, 0x0812) | 0x000C);
-		b43_phy_write(dev, 0x0811, b43_phy_read(dev, 0x0811) | 0x0030);
-		b43_phy_write(dev, 0x0812, b43_phy_read(dev, 0x0812) | 0x0030);
+		b43_phy_set(dev, 0x0811, 0x000C);
+		b43_phy_set(dev, 0x0812, 0x000C);
+		b43_phy_set(dev, 0x0811, 0x0030);
+		b43_phy_set(dev, 0x0812, 0x0030);
 		b43_phy_write(dev, 0x005A, 0x0480);
 		b43_phy_write(dev, 0x0059, 0x0810);
 		b43_phy_write(dev, 0x0058, 0x000D);
 		if (phy->rev == 0) {
 			b43_phy_write(dev, 0x0003, 0x0122);
 		} else {
-			b43_phy_write(dev, 0x000A, b43_phy_read(dev, 0x000A)
-				      | 0x2000);
+			b43_phy_set(dev, 0x000A, 0x2000);
 		}
 		if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
-			b43_phy_write(dev, 0x0814,
-				      b43_phy_read(dev, 0x0814) | 0x0004);
+			b43_phy_set(dev, 0x0814, 0x0004);
 			b43_phy_write(dev, 0x0815,
 				      b43_phy_read(dev, 0x0815) & 0xFFFB);
 		}
 		b43_phy_write(dev, 0x0003, (b43_phy_read(dev, 0x0003) & 0xFF9F)
 			      | 0x0040);
 		b43_radio_write16(dev, 0x007A,
@@ -573,13 +570,13 @@ static void b43_calc_nrssi_offset(struct
 	b43_phy_write(dev, 0x0058, backup[7]);
 	b43_phy_write(dev, 0x000A, backup[8]);
 	b43_phy_write(dev, 0x0003, backup[9]);
 	b43_radio_write16(dev, 0x0043, backup[11]);
 	b43_radio_write16(dev, 0x007A, backup[10]);
 	b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) | 0x1 | 0x2);
-	b43_phy_write(dev, 0x0429, b43_phy_read(dev, 0x0429) | 0x8000);
+	b43_phy_set(dev, 0x0429, 0x8000);
 	b43_set_original_gains(dev);
 	if (phy->rev >= 6) {
 		b43_phy_write(dev, 0x0801, backup[16]);
 		b43_phy_write(dev, 0x0060, backup[17]);
 		b43_phy_write(dev, 0x0014, backup[18]);
 		b43_phy_write(dev, 0x0478, backup[19]);
@@ -630,30 +627,24 @@ static void b43_calc_nrssi_slope(struct 
 		b43_phy_write(dev, 0x002E, 0);
 		b43_phy_write(dev, B43_PHY_G_LO_CONTROL, 0);
 		switch (phy->rev) {
 		case 4:
 		case 6:
 		case 7:
-			b43_phy_write(dev, 0x0478,
-				      b43_phy_read(dev, 0x0478)
-				      | 0x0100);
-			b43_phy_write(dev, 0x0801,
-				      b43_phy_read(dev, 0x0801)
-				      | 0x0040);
+			b43_phy_set(dev, 0x0478, 0x0100);
+			b43_phy_set(dev, 0x0801, 0x0040);
 			break;
 		case 3:
 		case 5:
 			b43_phy_write(dev, 0x0801,
 				      b43_phy_read(dev, 0x0801)
 				      & 0xFFBF);
 			break;
 		}
-		b43_phy_write(dev, 0x0060, b43_phy_read(dev, 0x0060)
-			      | 0x0040);
-		b43_phy_write(dev, 0x0014, b43_phy_read(dev, 0x0014)
-			      | 0x0200);
+		b43_phy_set(dev, 0x0060, 0x0040);
+		b43_phy_set(dev, 0x0014, 0x0200);
 	}
 	b43_radio_write16(dev, 0x007A,
 			  b43_radio_read16(dev, 0x007A) | 0x0070);
 	b43_set_all_gains(dev, 0, 8, 0);
 	b43_radio_write16(dev, 0x007A,
 			  b43_radio_read16(dev, 0x007A) & 0x00F7);
@@ -740,17 +731,15 @@ static void b43_calc_nrssi_slope(struct 
 	b43_write16(dev, B43_MMIO_CHANNEL_EXT, backup[9]);
 	b43_phy_write(dev, 0x0015, backup[3]);
 	b43_phy_write(dev, 0x005A, backup[4]);
 	b43_phy_write(dev, 0x0059, backup[5]);
 	b43_phy_write(dev, 0x0058, backup[6]);
 	b43_synth_pu_workaround(dev, phy->channel);
-	b43_phy_write(dev, 0x0802,
-		      b43_phy_read(dev, 0x0802) | (0x0001 | 0x0002));
+	b43_phy_set(dev, 0x0802, (0x0001 | 0x0002));
 	b43_set_original_gains(dev);
-	b43_phy_write(dev, B43_PHY_G_CRS,
-		      b43_phy_read(dev, B43_PHY_G_CRS) | 0x8000);
+	b43_phy_set(dev, B43_PHY_G_CRS, 0x8000);
 	if (phy->rev >= 3) {
 		b43_phy_write(dev, 0x0801, backup[14]);
 		b43_phy_write(dev, 0x0060, backup[15]);
 		b43_phy_write(dev, 0x0014, backup[16]);
 		b43_phy_write(dev, 0x0478, backup[17]);
 	}
@@ -898,14 +887,13 @@ b43_radio_interference_mitigation_enable
 	size_t stackidx = 0;
 	u32 *stack = gphy->interfstack;
 
 	switch (mode) {
 	case B43_INTERFMODE_NONWLAN:
 		if (phy->rev != 1) {
-			b43_phy_write(dev, 0x042B,
-				      b43_phy_read(dev, 0x042B) | 0x0800);
+			b43_phy_set(dev, 0x042B, 0x0800);
 			b43_phy_write(dev, B43_PHY_G_CRS,
 				      b43_phy_read(dev,
 						   B43_PHY_G_CRS) & ~0x4000);
 			break;
 		}
 		radio_stacksave(0x0078);
@@ -921,16 +909,14 @@ b43_radio_interference_mitigation_enable
 
 		b43_calc_nrssi_threshold(dev);
 
 		phy_stacksave(0x0406);
 		b43_phy_write(dev, 0x0406, 0x7E28);
 
-		b43_phy_write(dev, 0x042B, b43_phy_read(dev, 0x042B) | 0x0800);
-		b43_phy_write(dev, B43_PHY_RADIO_BITFIELD,
-			      b43_phy_read(dev,
-					   B43_PHY_RADIO_BITFIELD) | 0x1000);
+		b43_phy_set(dev, 0x042B, 0x0800);
+		b43_phy_set(dev, B43_PHY_RADIO_BITFIELD, 0x1000);
 
 		phy_stacksave(0x04A0);
 		b43_phy_write(dev, 0x04A0,
 			      (b43_phy_read(dev, 0x04A0) & 0xC0C0) | 0x0008);
 		phy_stacksave(0x04A1);
 		b43_phy_write(dev, 0x04A1,
@@ -1061,21 +1047,19 @@ b43_radio_interference_mitigation_enable
 						    & 0x8000) | 0x36D8);
 			b43_phy_write(dev, 0x0416, (b43_phy_read(dev, 0x0416)
 						    & 0x8000) | 0x36D8);
 			b43_phy_write(dev, 0x0417, (b43_phy_read(dev, 0x0417)
 						    & 0xFE00) | 0x016D);
 		} else {
-			b43_phy_write(dev, 0x048A, b43_phy_read(dev, 0x048A)
-				      | 0x1000);
+			b43_phy_set(dev, 0x048A, 0x1000);
 			b43_phy_write(dev, 0x048A, (b43_phy_read(dev, 0x048A)
 						    & 0x9FFF) | 0x2000);
 			b43_hf_write(dev, b43_hf_read(dev) | B43_HF_ACIW);
 		}
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x042B, b43_phy_read(dev, 0x042B)
-				      | 0x0800);
+			b43_phy_set(dev, 0x042B, 0x0800);
 		}
 		b43_phy_write(dev, 0x048C, (b43_phy_read(dev, 0x048C)
 					    & 0xF0FF) | 0x0200);
 		if (phy->rev == 2) {
 			b43_phy_write(dev, 0x04AE, (b43_phy_read(dev, 0x04AE)
 						    & 0xFF00) | 0x007F);
@@ -1103,28 +1087,25 @@ b43_radio_interference_mitigation_disabl
 
 	switch (mode) {
 	case B43_INTERFMODE_NONWLAN:
 		if (phy->rev != 1) {
 			b43_phy_write(dev, 0x042B,
 				      b43_phy_read(dev, 0x042B) & ~0x0800);
-			b43_phy_write(dev, B43_PHY_G_CRS,
-				      b43_phy_read(dev,
-						   B43_PHY_G_CRS) | 0x4000);
+			b43_phy_set(dev, B43_PHY_G_CRS, 0x4000);
 			break;
 		}
 		radio_stackrestore(0x0078);
 		b43_calc_nrssi_threshold(dev);
 		phy_stackrestore(0x0406);
 		b43_phy_write(dev, 0x042B, b43_phy_read(dev, 0x042B) & ~0x0800);
 		if (!dev->bad_frames_preempt) {
 			b43_phy_write(dev, B43_PHY_RADIO_BITFIELD,
 				      b43_phy_read(dev, B43_PHY_RADIO_BITFIELD)
 				      & ~(1 << 11));
 		}
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      b43_phy_read(dev, B43_PHY_G_CRS) | 0x4000);
+		b43_phy_set(dev, B43_PHY_G_CRS, 0x4000);
 		phy_stackrestore(0x04A0);
 		phy_stackrestore(0x04A1);
 		phy_stackrestore(0x04A2);
 		phy_stackrestore(0x04A8);
 		phy_stackrestore(0x04AB);
 		phy_stackrestore(0x04A7);
@@ -1386,15 +1367,13 @@ static u16 b43_radio_init2050(struct b43
 		sav.phy_analogover = b43_phy_read(dev, B43_PHY_ANALOGOVER);
 		sav.phy_analogoverval =
 		    b43_phy_read(dev, B43_PHY_ANALOGOVERVAL);
 		sav.phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);
 		sav.phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);
 
-		b43_phy_write(dev, B43_PHY_ANALOGOVER,
-			      b43_phy_read(dev, B43_PHY_ANALOGOVER)
-			      | 0x0003);
+		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0003);
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      b43_phy_read(dev, B43_PHY_ANALOGOVERVAL)
 			      & 0xFFFC);
 		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
 			      & 0x7FFF);
 		b43_phy_write(dev, B43_PHY_CLASSCTL,
@@ -1634,29 +1613,27 @@ static void b43_phy_initb5(struct b43_wl
 			b43_radio_write16(dev, 0x0051,
 					  b43_radio_read16(dev, 0x0051)
 					  | 0x0004);
 		}
 		b43_write16(dev, B43_MMIO_PHY_RADIO, 0x0000);
 
-		b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) | 0x0100);
-		b43_phy_write(dev, 0x042B, b43_phy_read(dev, 0x042B) | 0x2000);
+		b43_phy_set(dev, 0x0802, 0x0100);
+		b43_phy_set(dev, 0x042B, 0x2000);
 
 		b43_phy_write(dev, 0x001C, 0x186A);
 
 		b43_phy_write(dev, 0x0013,
 			      (b43_phy_read(dev, 0x0013) & 0x00FF) | 0x1900);
 		b43_phy_write(dev, 0x0035,
 			      (b43_phy_read(dev, 0x0035) & 0xFFC0) | 0x0064);
 		b43_phy_write(dev, 0x005D,
 			      (b43_phy_read(dev, 0x005D) & 0xFF80) | 0x000A);
 	}
 
 	if (dev->bad_frames_preempt) {
-		b43_phy_write(dev, B43_PHY_RADIO_BITFIELD,
-			      b43_phy_read(dev,
-					   B43_PHY_RADIO_BITFIELD) | (1 << 11));
+		b43_phy_set(dev, B43_PHY_RADIO_BITFIELD, (1 << 11));
 	}
 
 	if (phy->analog == 1) {
 		b43_phy_write(dev, 0x0026, 0xCE00);
 		b43_phy_write(dev, 0x0021, 0x3763);
 		b43_phy_write(dev, 0x0022, 0x1BC3);
@@ -1772,14 +1749,14 @@ static void b43_phy_initb6(struct b43_wl
 	}
 	if (phy->type == B43_PHYTYPE_G) {
 		b43_radio_write16(dev, 0x007A,
 				  b43_radio_read16(dev, 0x007A) | 0x0020);
 		b43_radio_write16(dev, 0x0051,
 				  b43_radio_read16(dev, 0x0051) | 0x0004);
-		b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) | 0x0100);
-		b43_phy_write(dev, 0x042B, b43_phy_read(dev, 0x042B) | 0x2000);
+		b43_phy_set(dev, 0x0802, 0x0100);
+		b43_phy_set(dev, 0x042B, 0x2000);
 		b43_phy_write(dev, 0x5B, 0);
 		b43_phy_write(dev, 0x5C, 0);
 	}
 
 	old_channel = phy->channel;
 	if (old_channel >= 8)
@@ -1867,53 +1844,43 @@ static void b43_calc_loopback_gain(struc
 	backup_radio[0] = b43_radio_read16(dev, 0x52);
 	backup_radio[1] = b43_radio_read16(dev, 0x43);
 	backup_radio[2] = b43_radio_read16(dev, 0x7A);
 
 	b43_phy_write(dev, B43_PHY_CRS0,
 		      b43_phy_read(dev, B43_PHY_CRS0) & 0x3FFF);
-	b43_phy_write(dev, B43_PHY_CCKBBANDCFG,
-		      b43_phy_read(dev, B43_PHY_CCKBBANDCFG) | 0x8000);
-	b43_phy_write(dev, B43_PHY_RFOVER,
-		      b43_phy_read(dev, B43_PHY_RFOVER) | 0x0002);
+	b43_phy_set(dev, B43_PHY_CCKBBANDCFG, 0x8000);
+	b43_phy_set(dev, B43_PHY_RFOVER, 0x0002);
 	b43_phy_write(dev, B43_PHY_RFOVERVAL,
 		      b43_phy_read(dev, B43_PHY_RFOVERVAL) & 0xFFFD);
-	b43_phy_write(dev, B43_PHY_RFOVER,
-		      b43_phy_read(dev, B43_PHY_RFOVER) | 0x0001);
+	b43_phy_set(dev, B43_PHY_RFOVER, 0x0001);
 	b43_phy_write(dev, B43_PHY_RFOVERVAL,
 		      b43_phy_read(dev, B43_PHY_RFOVERVAL) & 0xFFFE);
 	if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
-		b43_phy_write(dev, B43_PHY_ANALOGOVER,
-			      b43_phy_read(dev, B43_PHY_ANALOGOVER) | 0x0001);
+		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0001);
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      b43_phy_read(dev,
 					   B43_PHY_ANALOGOVERVAL) & 0xFFFE);
-		b43_phy_write(dev, B43_PHY_ANALOGOVER,
-			      b43_phy_read(dev, B43_PHY_ANALOGOVER) | 0x0002);
+		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0002);
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      b43_phy_read(dev,
 					   B43_PHY_ANALOGOVERVAL) & 0xFFFD);
 	}
-	b43_phy_write(dev, B43_PHY_RFOVER,
-		      b43_phy_read(dev, B43_PHY_RFOVER) | 0x000C);
-	b43_phy_write(dev, B43_PHY_RFOVERVAL,
-		      b43_phy_read(dev, B43_PHY_RFOVERVAL) | 0x000C);
-	b43_phy_write(dev, B43_PHY_RFOVER,
-		      b43_phy_read(dev, B43_PHY_RFOVER) | 0x0030);
+	b43_phy_set(dev, B43_PHY_RFOVER, 0x000C);
+	b43_phy_set(dev, B43_PHY_RFOVERVAL, 0x000C);
+	b43_phy_set(dev, B43_PHY_RFOVER, 0x0030);
 	b43_phy_write(dev, B43_PHY_RFOVERVAL,
 		      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
 		       & 0xFFCF) | 0x10);
 
 	b43_phy_write(dev, B43_PHY_CCK(0x5A), 0x0780);
 	b43_phy_write(dev, B43_PHY_CCK(0x59), 0xC810);
 	b43_phy_write(dev, B43_PHY_CCK(0x58), 0x000D);
 
-	b43_phy_write(dev, B43_PHY_CCK(0x0A),
-		      b43_phy_read(dev, B43_PHY_CCK(0x0A)) | 0x2000);
+	b43_phy_set(dev, B43_PHY_CCK(0x0A), 0x2000);
 	if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
-		b43_phy_write(dev, B43_PHY_ANALOGOVER,
-			      b43_phy_read(dev, B43_PHY_ANALOGOVER) | 0x0004);
+		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0004);
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      b43_phy_read(dev,
 					   B43_PHY_ANALOGOVERVAL) & 0xFFFB);
 	}
 	b43_phy_write(dev, B43_PHY_CCK(0x03),
 		      (b43_phy_read(dev, B43_PHY_CCK(0x03))
@@ -1938,25 +1905,20 @@ static void b43_calc_loopback_gain(struc
 		      (b43_phy_read(dev, B43_PHY_CCK(0x2B))
 		       & 0xFFC0) | 0x01);
 	b43_phy_write(dev, B43_PHY_CCK(0x2B),
 		      (b43_phy_read(dev, B43_PHY_CCK(0x2B))
 		       & 0xC0FF) | 0x800);
 
-	b43_phy_write(dev, B43_PHY_RFOVER,
-		      b43_phy_read(dev, B43_PHY_RFOVER) | 0x0100);
+	b43_phy_set(dev, B43_PHY_RFOVER, 0x0100);
 	b43_phy_write(dev, B43_PHY_RFOVERVAL,
 		      b43_phy_read(dev, B43_PHY_RFOVERVAL) & 0xCFFF);
 
 	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_EXTLNA) {
 		if (phy->rev >= 7) {
-			b43_phy_write(dev, B43_PHY_RFOVER,
-				      b43_phy_read(dev, B43_PHY_RFOVER)
-				      | 0x0800);
-			b43_phy_write(dev, B43_PHY_RFOVERVAL,
-				      b43_phy_read(dev, B43_PHY_RFOVERVAL)
-				      | 0x8000);
+			b43_phy_set(dev, B43_PHY_RFOVER, 0x0800);
+			b43_phy_set(dev, B43_PHY_RFOVERVAL, 0x8000);
 		}
 	}
 	b43_radio_write16(dev, 0x7A, b43_radio_read16(dev, 0x7A)
 			  & 0x00F7);
 
 	j = 0;
@@ -1967,38 +1929,32 @@ static void b43_calc_loopback_gain(struc
 			b43_phy_write(dev, B43_PHY_RFOVERVAL,
 				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
 				       & 0xF0FF) | (j << 8));
 			b43_phy_write(dev, B43_PHY_PGACTL,
 				      (b43_phy_read(dev, B43_PHY_PGACTL)
 				       & 0x0FFF) | 0xA000);
-			b43_phy_write(dev, B43_PHY_PGACTL,
-				      b43_phy_read(dev, B43_PHY_PGACTL)
-				      | 0xF000);
+			b43_phy_set(dev, B43_PHY_PGACTL, 0xF000);
 			udelay(20);
 			if (b43_phy_read(dev, B43_PHY_LO_LEAKAGE) >= 0xDFC)
 				goto exit_loop1;
 		}
 	}
       exit_loop1:
 	loop1_outer_done = i;
 	loop1_inner_done = j;
 	if (j >= 8) {
-		b43_phy_write(dev, B43_PHY_RFOVERVAL,
-			      b43_phy_read(dev, B43_PHY_RFOVERVAL)
-			      | 0x30);
+		b43_phy_set(dev, B43_PHY_RFOVERVAL, 0x30);
 		trsw_rx = 0x1B;
 		for (j = j - 8; j < 16; j++) {
 			b43_phy_write(dev, B43_PHY_RFOVERVAL,
 				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
 				       & 0xF0FF) | (j << 8));
 			b43_phy_write(dev, B43_PHY_PGACTL,
 				      (b43_phy_read(dev, B43_PHY_PGACTL)
 				       & 0x0FFF) | 0xA000);
-			b43_phy_write(dev, B43_PHY_PGACTL,
-				      b43_phy_read(dev, B43_PHY_PGACTL)
-				      | 0xF000);
+			b43_phy_set(dev, B43_PHY_PGACTL, 0xF000);
 			udelay(20);
 			trsw_rx -= 3;
 			if (b43_phy_read(dev, B43_PHY_LO_LEAKAGE) >= 0xDFC)
 				goto exit_loop2;
 		}
 	} else
@@ -2045,29 +2001,25 @@ static void b43_hardware_pctl_early_init
 		b43_phy_write(dev, 0x047A, 0xC111);
 		return;
 	}
 
 	b43_phy_write(dev, 0x0036, b43_phy_read(dev, 0x0036) & 0xFEFF);
 	b43_phy_write(dev, 0x002F, 0x0202);
-	b43_phy_write(dev, 0x047C, b43_phy_read(dev, 0x047C) | 0x0002);
-	b43_phy_write(dev, 0x047A, b43_phy_read(dev, 0x047A) | 0xF000);
+	b43_phy_set(dev, 0x047C, 0x0002);
+	b43_phy_set(dev, 0x047A, 0xF000);
 	if (phy->radio_ver == 0x2050 && phy->radio_rev == 8) {
 		b43_phy_write(dev, 0x047A, (b43_phy_read(dev, 0x047A)
 					    & 0xFF0F) | 0x0010);
-		b43_phy_write(dev, 0x005D, b43_phy_read(dev, 0x005D)
-			      | 0x8000);
+		b43_phy_set(dev, 0x005D, 0x8000);
 		b43_phy_write(dev, 0x004E, (b43_phy_read(dev, 0x004E)
 					    & 0xFFC0) | 0x0010);
 		b43_phy_write(dev, 0x002E, 0xC07F);
-		b43_phy_write(dev, 0x0036, b43_phy_read(dev, 0x0036)
-			      | 0x0400);
+		b43_phy_set(dev, 0x0036, 0x0400);
 	} else {
-		b43_phy_write(dev, 0x0036, b43_phy_read(dev, 0x0036)
-			      | 0x0200);
-		b43_phy_write(dev, 0x0036, b43_phy_read(dev, 0x0036)
-			      | 0x0400);
+		b43_phy_set(dev, 0x0036, 0x0200);
+		b43_phy_set(dev, 0x0036, 0x0400);
 		b43_phy_write(dev, 0x005D, b43_phy_read(dev, 0x005D)
 			      & 0x7FFF);
 		b43_phy_write(dev, 0x004F, b43_phy_read(dev, 0x004F)
 			      & 0xFFFE);
 		b43_phy_write(dev, 0x004E, (b43_phy_read(dev, 0x004E)
 					    & 0xFFC0) | 0x0010);
@@ -2096,14 +2048,13 @@ static void b43_hardware_pctl_init_gphy(
 	b43_gphy_tssi_power_lt_init(dev);
 	b43_gphy_gain_lt_init(dev);
 	b43_phy_write(dev, 0x0060, b43_phy_read(dev, 0x0060) & 0xFFBF);
 	b43_phy_write(dev, 0x0014, 0x0000);
 
 	B43_WARN_ON(phy->rev < 6);
-	b43_phy_write(dev, 0x0478, b43_phy_read(dev, 0x0478)
-		      | 0x0800);
+	b43_phy_set(dev, 0x0478, 0x0800);
 	b43_phy_write(dev, 0x0478, b43_phy_read(dev, 0x0478)
 		      & 0xFEFF);
 	b43_phy_write(dev, 0x0801, b43_phy_read(dev, 0x0801)
 		      & 0xFFBF);
 
 	b43_gphy_dc_lt_init(dev, 1);
@@ -2225,18 +2176,14 @@ static void b43_phy_initg(struct b43_wld
 				       & 0x00FF) | 0x1F00);
 		}
 	}
 	if ((phy->rev <= 2 && phy->gmode) || phy->rev >= 2)
 		b43_phy_write(dev, B43_PHY_OFDM(0x7E), 0x78);
 	if (phy->radio_rev == 8) {
-		b43_phy_write(dev, B43_PHY_EXTG(0x01),
-			      b43_phy_read(dev, B43_PHY_EXTG(0x01))
-			      | 0x80);
-		b43_phy_write(dev, B43_PHY_OFDM(0x3E),
-			      b43_phy_read(dev, B43_PHY_OFDM(0x3E))
-			      | 0x4);
+		b43_phy_set(dev, B43_PHY_EXTG(0x01), 0x80);
+		b43_phy_set(dev, B43_PHY_OFDM(0x3E), 0x4);
 	}
 	if (has_loopback_gain(phy))
 		b43_calc_loopback_gain(dev);
 
 	if (phy->radio_rev != 8) {
 		if (gphy->initval == 0xFFFF)
@@ -2517,14 +2464,13 @@ static u8 b43_gphy_aci_scan(struct b43_w
 			ret[i - 1] = b43_gphy_aci_detect(dev, i);
 	}
 	b43_switch_channel(dev, channel);
 	b43_phy_write(dev, 0x0802,
 		      (b43_phy_read(dev, 0x0802) & 0xFFFC) | 0x0003);
 	b43_phy_write(dev, 0x0403, b43_phy_read(dev, 0x0403) & 0xFFF8);
-	b43_phy_write(dev, B43_PHY_G_CRS,
-		      b43_phy_read(dev, B43_PHY_G_CRS) | 0x8000);
+	b43_phy_set(dev, B43_PHY_G_CRS, 0x8000);
 	b43_set_original_gains(dev);
 	for (i = 0; i < 13; i++) {
 		if (!ret[i])
 			continue;
 		end = (i + 5 < 13) ? i + 5 : 13;
 		for (j = i; j < end; j++)
Index: wireless-testing/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/lo.c	2009-02-19 22:20:24.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/lo.c	2009-02-20 19:05:21.000000000 +0100
@@ -403,24 +403,16 @@ static void lo_measure_setup(struct b43_
 		sav->phy_lo_mask = b43_phy_read(dev, B43_PHY_LO_MASK);
 		sav->phy_extg_01 = b43_phy_read(dev, B43_PHY_EXTG(0x01));
 		sav->phy_dacctl_hwpctl = b43_phy_read(dev, B43_PHY_DACCTL);
 		sav->phy_cck_14 = b43_phy_read(dev, B43_PHY_CCK(0x14));
 		sav->phy_hpwr_tssictl = b43_phy_read(dev, B43_PHY_HPWR_TSSICTL);
 
-		b43_phy_write(dev, B43_PHY_HPWR_TSSICTL,
-			      b43_phy_read(dev, B43_PHY_HPWR_TSSICTL)
-			      | 0x100);
-		b43_phy_write(dev, B43_PHY_EXTG(0x01),
-			      b43_phy_read(dev, B43_PHY_EXTG(0x01))
-			      | 0x40);
-		b43_phy_write(dev, B43_PHY_DACCTL,
-			      b43_phy_read(dev, B43_PHY_DACCTL)
-			      | 0x40);
-		b43_phy_write(dev, B43_PHY_CCK(0x14),
-			      b43_phy_read(dev, B43_PHY_CCK(0x14))
-			      | 0x200);
+		b43_phy_set(dev, B43_PHY_HPWR_TSSICTL, 0x100);
+		b43_phy_set(dev, B43_PHY_EXTG(0x01), 0x40);
+		b43_phy_set(dev, B43_PHY_DACCTL, 0x40);
+		b43_phy_set(dev, B43_PHY_CCK(0x14), 0x200);
 	}
 	if (phy->type == B43_PHYTYPE_B &&
 	    phy->radio_ver == 0x2050 && phy->radio_rev < 6) {
 		b43_phy_write(dev, B43_PHY_CCK(0x16), 0x410);
 		b43_phy_write(dev, B43_PHY_CCK(0x17), 0x820);
 	}
@@ -436,15 +428,13 @@ static void lo_measure_setup(struct b43_
 
 		b43_phy_write(dev, B43_PHY_CLASSCTL,
 			      b43_phy_read(dev, B43_PHY_CLASSCTL)
 			      & 0xFFFC);
 		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
 			      & 0x7FFF);
-		b43_phy_write(dev, B43_PHY_ANALOGOVER,
-			      b43_phy_read(dev, B43_PHY_ANALOGOVER)
-			      | 0x0003);
+		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0003);
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      b43_phy_read(dev, B43_PHY_ANALOGOVERVAL)
 			      & 0xFFFC);
 		if (phy->type == B43_PHYTYPE_G) {
 			if ((phy->rev >= 7) &&
 			    (sprom->boardflags_lo & B43_BFL_EXTLNA)) {
Index: wireless-testing/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/wa.c	2008-08-30 02:13:22.000000000 +0200
+++ wireless-testing/drivers/net/wireless/b43/wa.c	2009-02-20 19:05:28.000000000 +0100
@@ -315,22 +315,18 @@ static void b43_wa_crs_ed(struct b43_wld
 
 	if (phy->rev == 1) {
 		b43_phy_write(dev, B43_PHY_CRSTHRES1_R1, 0x4F19);
 	} else if (phy->rev == 2) {
 		b43_phy_write(dev, B43_PHY_CRSTHRES1, 0x1861);
 		b43_phy_write(dev, B43_PHY_CRSTHRES2, 0x0271);
-		b43_phy_write(dev, B43_PHY_ANTDWELL,
-				  b43_phy_read(dev, B43_PHY_ANTDWELL)
-				  | 0x0800);
+		b43_phy_set(dev, B43_PHY_ANTDWELL, 0x0800);
 	} else {
 		b43_phy_write(dev, B43_PHY_CRSTHRES1, 0x0098);
 		b43_phy_write(dev, B43_PHY_CRSTHRES2, 0x0070);
 		b43_phy_write(dev, B43_PHY_OFDM(0xC9), 0x0080);
-		b43_phy_write(dev, B43_PHY_ANTDWELL,
-				  b43_phy_read(dev, B43_PHY_ANTDWELL)
-				  | 0x0800);
+		b43_phy_set(dev, B43_PHY_ANTDWELL, 0x0800);
 	}
 }
 
 static void b43_wa_crs_thr(struct b43_wldev *dev)
 {
 	b43_phy_write(dev, B43_PHY_CRS0,

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 19:26:27 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 19:26:27 +0100
Subject: [PATCH 3/6] b43: Convert usage of b43_phy_maskset()
Message-ID: <20090220183555.AD0141724D9@mail.berlios.de>

This patch converts code to use the new b43_phy_maskset() API.

The semantic patch that makes this change is as follows:

// <smpl>
@@
expression dev, addr, mask, set;
@@

-b43_phy_write(dev, addr, (b43_phy_read(dev, addr) & mask) | set);
+b43_phy_maskset(dev, addr, mask, set);
// </smpl>

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Index: wireless-testing/drivers/net/wireless/b43/phy_a.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_a.c	2009-02-20 19:05:38.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_a.c	2009-02-20 19:06:09.000000000 +0100
@@ -223,14 +223,13 @@ static void b43_phy_ww(struct b43_wldev 
 {
 	u16 b, curr_s, best_s = 0xFFFF;
 	int i;
 
 	b43_phy_mask(dev, B43_PHY_CRS0, ~B43_PHY_CRS0_EN);
 	b43_phy_set(dev, B43_PHY_OFDM(0x1B), 0x1000);
-	b43_phy_write(dev, B43_PHY_OFDM(0x82),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x82)) & 0xF0FF) | 0x0300);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x82), 0xF0FF, 0x0300);
 	b43_radio_write16(dev, 0x0009,
 		b43_radio_read16(dev, 0x0009) | 0x0080);
 	b43_radio_write16(dev, 0x0012,
 		(b43_radio_read16(dev, 0x0012) & 0xFFFC) | 0x0002);
 	b43_wa_initgains(dev);
 	b43_phy_write(dev, B43_PHY_OFDM(0xBA), 0x3ED5);
@@ -256,20 +255,16 @@ static void b43_phy_ww(struct b43_wldev 
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 0, 0xFFEC);
 	b43_phy_write(dev, B43_PHY_OFDM(0xB7), 0x1E80);
 	b43_phy_write(dev, B43_PHY_OFDM(0xB6), 0x1C00);
 	b43_phy_write(dev, B43_PHY_OFDM(0xB5), 0x0EC0);
 	b43_phy_write(dev, B43_PHY_OFDM(0xB2), 0x00C0);
 	b43_phy_write(dev, B43_PHY_OFDM(0xB9), 0x1FFF);
-	b43_phy_write(dev, B43_PHY_OFDM(0xBB),
-		(b43_phy_read(dev, B43_PHY_OFDM(0xBB)) & 0xF000) | 0x0053);
-	b43_phy_write(dev, B43_PHY_OFDM61,
-		(b43_phy_read(dev, B43_PHY_OFDM61) & 0xFE1F) | 0x0120);
-	b43_phy_write(dev, B43_PHY_OFDM(0x13),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x13)) & 0x0FFF) | 0x3000);
-	b43_phy_write(dev, B43_PHY_OFDM(0x14),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x14)) & 0x0FFF) | 0x3000);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0xBB), 0xF000, 0x0053);
+	b43_phy_maskset(dev, B43_PHY_OFDM61, 0xFE1F, 0x0120);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x13), 0x0FFF, 0x3000);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x14), 0x0FFF, 0x3000);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 6, 0x0017);
 	for (i = 0; i < 6; i++)
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, i, 0x000F);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0D, 0x000E);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0E, 0x0011);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0F, 0x0013);
@@ -328,15 +323,13 @@ void b43_phy_inita(struct b43_wldev *dev
 
 		//TODO: radar detection
 	}
 
 	if ((phy->type == B43_PHYTYPE_G) &&
 	    (dev->dev->bus->sprom.boardflags_lo & B43_BFL_PACTRL)) {
-		b43_phy_write(dev, B43_PHY_OFDM(0x6E),
-				  (b43_phy_read(dev, B43_PHY_OFDM(0x6E))
-				   & 0xE000) | 0x3CF);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x6E), 0xE000, 0x3CF);
 	}
 }
 
 /* Initialise the TSSI->dBm lookup table */
 static int b43_aphy_init_tssi2dbm_table(struct b43_wldev *dev)
 {
Index: wireless-testing/drivers/net/wireless/b43/phy_g.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_g.c	2009-02-20 19:05:38.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_g.c	2009-02-20 19:06:09.000000000 +0100
@@ -201,19 +201,15 @@ void b43_gphy_set_baseband_attenuation(s
 
 	if (phy->analog == 0) {
 		b43_write16(dev, B43_MMIO_PHY0, (b43_read16(dev, B43_MMIO_PHY0)
 						 & 0xFFF0) |
 			    baseband_attenuation);
 	} else if (phy->analog > 1) {
-		b43_phy_write(dev, B43_PHY_DACCTL,
-			      (b43_phy_read(dev, B43_PHY_DACCTL)
-			       & 0xFFC3) | (baseband_attenuation << 2));
+		b43_phy_maskset(dev, B43_PHY_DACCTL, 0xFFC3, (baseband_attenuation << 2));
 	} else {
-		b43_phy_write(dev, B43_PHY_DACCTL,
-			      (b43_phy_read(dev, B43_PHY_DACCTL)
-			       & 0xFF87) | (baseband_attenuation << 3));
+		b43_phy_maskset(dev, B43_PHY_DACCTL, 0xFF87, (baseband_attenuation << 3));
 	}
 }
 
 /* Adjust the transmission power output (G-PHY) */
 static void b43_set_txpower_g(struct b43_wldev *dev,
 			      const struct b43_bbatt *bbatt,
@@ -334,18 +330,15 @@ static void b43_set_all_gains(struct b43
 
 	for (i = start; i < end; i++)
 		b43_ofdmtab_write16(dev, table, i, second);
 
 	if (third != -1) {
 		tmp = ((u16) third << 14) | ((u16) third << 6);
-		b43_phy_write(dev, 0x04A0,
-			      (b43_phy_read(dev, 0x04A0) & 0xBFBF) | tmp);
-		b43_phy_write(dev, 0x04A1,
-			      (b43_phy_read(dev, 0x04A1) & 0xBFBF) | tmp);
-		b43_phy_write(dev, 0x04A2,
-			      (b43_phy_read(dev, 0x04A2) & 0xBFBF) | tmp);
+		b43_phy_maskset(dev, 0x04A0, 0xBFBF, tmp);
+		b43_phy_maskset(dev, 0x04A1, 0xBFBF, tmp);
+		b43_phy_maskset(dev, 0x04A2, 0xBFBF, tmp);
 	}
 	b43_dummy_transmission(dev);
 }
 
 static void b43_set_original_gains(struct b43_wldev *dev)
 {
@@ -370,18 +363,15 @@ static void b43_set_original_gains(struc
 		b43_ofdmtab_write16(dev, table, i, tmp);
 	}
 
 	for (i = start; i < end; i++)
 		b43_ofdmtab_write16(dev, table, i, i - start);
 
-	b43_phy_write(dev, 0x04A0,
-		      (b43_phy_read(dev, 0x04A0) & 0xBFBF) | 0x4040);
-	b43_phy_write(dev, 0x04A1,
-		      (b43_phy_read(dev, 0x04A1) & 0xBFBF) | 0x4040);
-	b43_phy_write(dev, 0x04A2,
-		      (b43_phy_read(dev, 0x04A2) & 0xBFBF) | 0x4000);
+	b43_phy_maskset(dev, 0x04A0, 0xBFBF, 0x4040);
+	b43_phy_maskset(dev, 0x04A1, 0xBFBF, 0x4040);
+	b43_phy_maskset(dev, 0x04A2, 0xBFBF, 0x4000);
 	b43_dummy_transmission(dev);
 }
 
 /* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
 static void b43_nrssi_hw_write(struct b43_wldev *dev, u16 offset, s16 val)
 {
@@ -452,17 +442,15 @@ static void b43_calc_nrssi_offset(struct
 	backup[8] = b43_phy_read(dev, 0x000A);
 	backup[9] = b43_phy_read(dev, 0x0003);
 	backup[10] = b43_radio_read16(dev, 0x007A);
 	backup[11] = b43_radio_read16(dev, 0x0043);
 
 	b43_phy_mask(dev, 0x0429, 0x7FFF);
-	b43_phy_write(dev, 0x0001,
-		      (b43_phy_read(dev, 0x0001) & 0x3FFF) | 0x4000);
+	b43_phy_maskset(dev, 0x0001, 0x3FFF, 0x4000);
 	b43_phy_set(dev, 0x0811, 0x000C);
-	b43_phy_write(dev, 0x0812,
-		      (b43_phy_read(dev, 0x0812) & 0xFFF3) | 0x0004);
+	b43_phy_maskset(dev, 0x0812, 0xFFF3, 0x0004);
 	b43_phy_mask(dev, 0x0802, ~(0x1 | 0x2));
 	if (phy->rev >= 6) {
 		backup[12] = b43_phy_read(dev, 0x002E);
 		backup[13] = b43_phy_read(dev, 0x002F);
 		backup[14] = b43_phy_read(dev, 0x080F);
 		backup[15] = b43_phy_read(dev, 0x0810);
@@ -520,14 +508,13 @@ static void b43_calc_nrssi_offset(struct
 			b43_phy_set(dev, 0x000A, 0x2000);
 		}
 		if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
 			b43_phy_set(dev, 0x0814, 0x0004);
 			b43_phy_mask(dev, 0x0815, 0xFFFB);
 		}
-		b43_phy_write(dev, 0x0003, (b43_phy_read(dev, 0x0003) & 0xFF9F)
-			      | 0x0040);
+		b43_phy_maskset(dev, 0x0003, 0xFF9F, 0x0040);
 		b43_radio_write16(dev, 0x007A,
 				  b43_radio_read16(dev, 0x007A) | 0x000F);
 		b43_set_all_gains(dev, 3, 0, 1);
 		b43_radio_write16(dev, 0x0043, (b43_radio_read16(dev, 0x0043)
 						& 0x00F0) | 0x000F);
 		udelay(30);
@@ -641,47 +628,38 @@ static void b43_calc_nrssi_slope(struct 
 	b43_radio_write16(dev, 0x007A,
 			  b43_radio_read16(dev, 0x007A) | 0x0070);
 	b43_set_all_gains(dev, 0, 8, 0);
 	b43_radio_write16(dev, 0x007A,
 			  b43_radio_read16(dev, 0x007A) & 0x00F7);
 	if (phy->rev >= 2) {
-		b43_phy_write(dev, 0x0811,
-			      (b43_phy_read(dev, 0x0811) & 0xFFCF) |
-			      0x0030);
-		b43_phy_write(dev, 0x0812,
-			      (b43_phy_read(dev, 0x0812) & 0xFFCF) |
-			      0x0010);
+		b43_phy_maskset(dev, 0x0811, 0xFFCF, 0x0030);
+		b43_phy_maskset(dev, 0x0812, 0xFFCF, 0x0010);
 	}
 	b43_radio_write16(dev, 0x007A,
 			  b43_radio_read16(dev, 0x007A) | 0x0080);
 	udelay(20);
 
 	nrssi0 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 	if (nrssi0 >= 0x0020)
 		nrssi0 -= 0x0040;
 
 	b43_radio_write16(dev, 0x007A,
 			  b43_radio_read16(dev, 0x007A) & 0x007F);
 	if (phy->rev >= 2) {
-		b43_phy_write(dev, 0x0003, (b43_phy_read(dev, 0x0003)
-					    & 0xFF9F) | 0x0040);
+		b43_phy_maskset(dev, 0x0003, 0xFF9F, 0x0040);
 	}
 
 	b43_write16(dev, B43_MMIO_CHANNEL_EXT,
 		    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
 		    | 0x2000);
 	b43_radio_write16(dev, 0x007A,
 			  b43_radio_read16(dev, 0x007A) | 0x000F);
 	b43_phy_write(dev, 0x0015, 0xF330);
 	if (phy->rev >= 2) {
-		b43_phy_write(dev, 0x0812,
-			      (b43_phy_read(dev, 0x0812) & 0xFFCF) |
-			      0x0020);
-		b43_phy_write(dev, 0x0811,
-			      (b43_phy_read(dev, 0x0811) & 0xFFCF) |
-			      0x0020);
+		b43_phy_maskset(dev, 0x0812, 0xFFCF, 0x0020);
+		b43_phy_maskset(dev, 0x0811, 0xFFCF, 0x0020);
 	}
 
 	b43_set_all_gains(dev, 3, 0, 1);
 	if (phy->radio_rev == 8) {
 		b43_radio_write16(dev, 0x0043, 0x001F);
 	} else {
@@ -753,19 +731,15 @@ static void b43_calc_nrssi_threshold(str
 	if (!phy->gmode ||
 	    !(dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI)) {
 		tmp16 = b43_nrssi_hw_read(dev, 0x20);
 		if (tmp16 >= 0x20)
 			tmp16 -= 0x40;
 		if (tmp16 < 3) {
-			b43_phy_write(dev, 0x048A,
-				      (b43_phy_read(dev, 0x048A)
-				       & 0xF000) | 0x09EB);
+			b43_phy_maskset(dev, 0x048A, 0xF000, 0x09EB);
 		} else {
-			b43_phy_write(dev, 0x048A,
-				      (b43_phy_read(dev, 0x048A)
-				       & 0xF000) | 0x0AED);
+			b43_phy_maskset(dev, 0x048A, 0xF000, 0x0AED);
 		}
 	} else {
 		if (gphy->interfmode == B43_INTERFMODE_NONWLAN) {
 			a = 0xE;
 			b = 0xA;
 		} else if (!gphy->aci_wlan_automatic && gphy->aci_enable) {
@@ -904,26 +878,21 @@ b43_radio_interference_mitigation_enable
 		b43_phy_write(dev, 0x0406, 0x7E28);
 
 		b43_phy_set(dev, 0x042B, 0x0800);
 		b43_phy_set(dev, B43_PHY_RADIO_BITFIELD, 0x1000);
 
 		phy_stacksave(0x04A0);
-		b43_phy_write(dev, 0x04A0,
-			      (b43_phy_read(dev, 0x04A0) & 0xC0C0) | 0x0008);
+		b43_phy_maskset(dev, 0x04A0, 0xC0C0, 0x0008);
 		phy_stacksave(0x04A1);
-		b43_phy_write(dev, 0x04A1,
-			      (b43_phy_read(dev, 0x04A1) & 0xC0C0) | 0x0605);
+		b43_phy_maskset(dev, 0x04A1, 0xC0C0, 0x0605);
 		phy_stacksave(0x04A2);
-		b43_phy_write(dev, 0x04A2,
-			      (b43_phy_read(dev, 0x04A2) & 0xC0C0) | 0x0204);
+		b43_phy_maskset(dev, 0x04A2, 0xC0C0, 0x0204);
 		phy_stacksave(0x04A8);
-		b43_phy_write(dev, 0x04A8,
-			      (b43_phy_read(dev, 0x04A8) & 0xC0C0) | 0x0803);
+		b43_phy_maskset(dev, 0x04A8, 0xC0C0, 0x0803);
 		phy_stacksave(0x04AB);
-		b43_phy_write(dev, 0x04AB,
-			      (b43_phy_read(dev, 0x04AB) & 0xC0C0) | 0x0605);
+		b43_phy_maskset(dev, 0x04AB, 0xC0C0, 0x0605);
 
 		phy_stacksave(0x04A7);
 		b43_phy_write(dev, 0x04A7, 0x0002);
 		phy_stacksave(0x04A3);
 		b43_phy_write(dev, 0x04A3, 0x287A);
 		phy_stacksave(0x04A9);
@@ -974,88 +943,65 @@ b43_radio_interference_mitigation_enable
 			ofdmtab_stacksave(0x1A00, 0x3);
 		}
 		phy_stacksave(0x042B);
 		phy_stacksave(0x048C);
 
 		b43_phy_mask(dev, B43_PHY_RADIO_BITFIELD, ~0x1000);
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      (b43_phy_read(dev, B43_PHY_G_CRS)
-			       & 0xFFFC) | 0x0002);
+		b43_phy_maskset(dev, B43_PHY_G_CRS, 0xFFFC, 0x0002);
 
 		b43_phy_write(dev, 0x0033, 0x0800);
 		b43_phy_write(dev, 0x04A3, 0x2027);
 		b43_phy_write(dev, 0x04A9, 0x1CA8);
 		b43_phy_write(dev, 0x0493, 0x287A);
 		b43_phy_write(dev, 0x04AA, 0x1CA8);
 		b43_phy_write(dev, 0x04AC, 0x287A);
 
-		b43_phy_write(dev, 0x04A0, (b43_phy_read(dev, 0x04A0)
-					    & 0xFFC0) | 0x001A);
+		b43_phy_maskset(dev, 0x04A0, 0xFFC0, 0x001A);
 		b43_phy_write(dev, 0x04A7, 0x000D);
 
 		if (phy->rev < 2) {
 			b43_phy_write(dev, 0x0406, 0xFF0D);
 		} else if (phy->rev == 2) {
 			b43_phy_write(dev, 0x04C0, 0xFFFF);
 			b43_phy_write(dev, 0x04C1, 0x00A9);
 		} else {
 			b43_phy_write(dev, 0x04C0, 0x00C1);
 			b43_phy_write(dev, 0x04C1, 0x0059);
 		}
 
-		b43_phy_write(dev, 0x04A1, (b43_phy_read(dev, 0x04A1)
-					    & 0xC0FF) | 0x1800);
-		b43_phy_write(dev, 0x04A1, (b43_phy_read(dev, 0x04A1)
-					    & 0xFFC0) | 0x0015);
-		b43_phy_write(dev, 0x04A8, (b43_phy_read(dev, 0x04A8)
-					    & 0xCFFF) | 0x1000);
-		b43_phy_write(dev, 0x04A8, (b43_phy_read(dev, 0x04A8)
-					    & 0xF0FF) | 0x0A00);
-		b43_phy_write(dev, 0x04AB, (b43_phy_read(dev, 0x04AB)
-					    & 0xCFFF) | 0x1000);
-		b43_phy_write(dev, 0x04AB, (b43_phy_read(dev, 0x04AB)
-					    & 0xF0FF) | 0x0800);
-		b43_phy_write(dev, 0x04AB, (b43_phy_read(dev, 0x04AB)
-					    & 0xFFCF) | 0x0010);
-		b43_phy_write(dev, 0x04AB, (b43_phy_read(dev, 0x04AB)
-					    & 0xFFF0) | 0x0005);
-		b43_phy_write(dev, 0x04A8, (b43_phy_read(dev, 0x04A8)
-					    & 0xFFCF) | 0x0010);
-		b43_phy_write(dev, 0x04A8, (b43_phy_read(dev, 0x04A8)
-					    & 0xFFF0) | 0x0006);
-		b43_phy_write(dev, 0x04A2, (b43_phy_read(dev, 0x04A2)
-					    & 0xF0FF) | 0x0800);
-		b43_phy_write(dev, 0x04A0, (b43_phy_read(dev, 0x04A0)
-					    & 0xF0FF) | 0x0500);
-		b43_phy_write(dev, 0x04A2, (b43_phy_read(dev, 0x04A2)
-					    & 0xFFF0) | 0x000B);
+		b43_phy_maskset(dev, 0x04A1, 0xC0FF, 0x1800);
+		b43_phy_maskset(dev, 0x04A1, 0xFFC0, 0x0015);
+		b43_phy_maskset(dev, 0x04A8, 0xCFFF, 0x1000);
+		b43_phy_maskset(dev, 0x04A8, 0xF0FF, 0x0A00);
+		b43_phy_maskset(dev, 0x04AB, 0xCFFF, 0x1000);
+		b43_phy_maskset(dev, 0x04AB, 0xF0FF, 0x0800);
+		b43_phy_maskset(dev, 0x04AB, 0xFFCF, 0x0010);
+		b43_phy_maskset(dev, 0x04AB, 0xFFF0, 0x0005);
+		b43_phy_maskset(dev, 0x04A8, 0xFFCF, 0x0010);
+		b43_phy_maskset(dev, 0x04A8, 0xFFF0, 0x0006);
+		b43_phy_maskset(dev, 0x04A2, 0xF0FF, 0x0800);
+		b43_phy_maskset(dev, 0x04A0, 0xF0FF, 0x0500);
+		b43_phy_maskset(dev, 0x04A2, 0xFFF0, 0x000B);
 
 		if (phy->rev >= 3) {
 			b43_phy_mask(dev, 0x048A, ~0x8000);
-			b43_phy_write(dev, 0x0415, (b43_phy_read(dev, 0x0415)
-						    & 0x8000) | 0x36D8);
-			b43_phy_write(dev, 0x0416, (b43_phy_read(dev, 0x0416)
-						    & 0x8000) | 0x36D8);
-			b43_phy_write(dev, 0x0417, (b43_phy_read(dev, 0x0417)
-						    & 0xFE00) | 0x016D);
+			b43_phy_maskset(dev, 0x0415, 0x8000, 0x36D8);
+			b43_phy_maskset(dev, 0x0416, 0x8000, 0x36D8);
+			b43_phy_maskset(dev, 0x0417, 0xFE00, 0x016D);
 		} else {
 			b43_phy_set(dev, 0x048A, 0x1000);
-			b43_phy_write(dev, 0x048A, (b43_phy_read(dev, 0x048A)
-						    & 0x9FFF) | 0x2000);
+			b43_phy_maskset(dev, 0x048A, 0x9FFF, 0x2000);
 			b43_hf_write(dev, b43_hf_read(dev) | B43_HF_ACIW);
 		}
 		if (phy->rev >= 2) {
 			b43_phy_set(dev, 0x042B, 0x0800);
 		}
-		b43_phy_write(dev, 0x048C, (b43_phy_read(dev, 0x048C)
-					    & 0xF0FF) | 0x0200);
+		b43_phy_maskset(dev, 0x048C, 0xF0FF, 0x0200);
 		if (phy->rev == 2) {
-			b43_phy_write(dev, 0x04AE, (b43_phy_read(dev, 0x04AE)
-						    & 0xFF00) | 0x007F);
-			b43_phy_write(dev, 0x04AD, (b43_phy_read(dev, 0x04AD)
-						    & 0x00FF) | 0x1300);
+			b43_phy_maskset(dev, 0x04AE, 0xFF00, 0x007F);
+			b43_phy_maskset(dev, 0x04AD, 0x00FF, 0x1300);
 		} else if (phy->rev >= 6) {
 			b43_ofdmtab_write16(dev, 0x1A00, 0x3, 0x007F);
 			b43_ofdmtab_write16(dev, 0x1A00, 0x2, 0x007F);
 			b43_phy_mask(dev, 0x04AD, 0x00FF);
 		}
 		b43_calc_nrssi_slope(dev);
@@ -1383,15 +1329,13 @@ static u16 b43_radio_init2050(struct b43
 	sav.reg_3F4 = b43_read16(dev, 0x3F4);
 
 	if (phy->analog == 0) {
 		b43_write16(dev, 0x03E6, 0x0122);
 	} else {
 		if (phy->analog >= 2) {
-			b43_phy_write(dev, B43_PHY_CCK(0x03),
-				      (b43_phy_read(dev, B43_PHY_CCK(0x03))
-				       & 0xFFBF) | 0x40);
+			b43_phy_maskset(dev, B43_PHY_CCK(0x03), 0xFFBF, 0x40);
 		}
 		b43_write16(dev, B43_MMIO_CHANNEL_EXT,
 			    (b43_read16(dev, B43_MMIO_CHANNEL_EXT) | 0x2000));
 	}
 
 	rcc = b43_radio_core_calibration_value(dev);
@@ -1575,14 +1519,13 @@ static void b43_phy_initb5(struct b43_wl
 		value = 0x2120;
 		for (offset = 0x00A8; offset < 0x00C7; offset++) {
 			b43_phy_write(dev, offset, value);
 			value += 0x202;
 		}
 	}
-	b43_phy_write(dev, 0x0035, (b43_phy_read(dev, 0x0035) & 0xF0FF)
-		      | 0x0700);
+	b43_phy_maskset(dev, 0x0035, 0xF0FF, 0x0700);
 	if (phy->radio_ver == 0x2050)
 		b43_phy_write(dev, 0x0038, 0x0667);
 
 	if (phy->gmode || phy->rev >= 2) {
 		if (phy->radio_ver == 0x2050) {
 			b43_radio_write16(dev, 0x007A,
@@ -1596,18 +1539,15 @@ static void b43_phy_initb5(struct b43_wl
 
 		b43_phy_set(dev, 0x0802, 0x0100);
 		b43_phy_set(dev, 0x042B, 0x2000);
 
 		b43_phy_write(dev, 0x001C, 0x186A);
 
-		b43_phy_write(dev, 0x0013,
-			      (b43_phy_read(dev, 0x0013) & 0x00FF) | 0x1900);
-		b43_phy_write(dev, 0x0035,
-			      (b43_phy_read(dev, 0x0035) & 0xFFC0) | 0x0064);
-		b43_phy_write(dev, 0x005D,
-			      (b43_phy_read(dev, 0x005D) & 0xFF80) | 0x000A);
+		b43_phy_maskset(dev, 0x0013, 0x00FF, 0x1900);
+		b43_phy_maskset(dev, 0x0035, 0xFFC0, 0x0064);
+		b43_phy_maskset(dev, 0x005D, 0xFF80, 0x000A);
 	}
 
 	if (dev->bad_frames_preempt) {
 		b43_phy_set(dev, B43_PHY_RADIO_BITFIELD, (1 << 11));
 	}
 
@@ -1766,24 +1706,22 @@ static void b43_phy_initb6(struct b43_wl
 		b43_phy_write(dev, 0x2A, 0x88C2);
 	else
 		b43_phy_write(dev, 0x2A, 0x8AC0);
 	b43_phy_write(dev, 0x0038, 0x0668);
 	b43_set_txpower_g(dev, &gphy->bbatt, &gphy->rfatt, gphy->tx_control);
 	if (phy->radio_rev <= 5) {
-		b43_phy_write(dev, 0x5D, (b43_phy_read(dev, 0x5D)
-					  & 0xFF80) | 0x0003);
+		b43_phy_maskset(dev, 0x5D, 0xFF80, 0x0003);
 	}
 	if (phy->radio_rev <= 2)
 		b43_radio_write16(dev, 0x005D, 0x000D);
 
 	if (phy->analog == 4) {
 		b43_write16(dev, 0x3E4, 9);
 		b43_phy_mask(dev, 0x61, 0x0FFF);
 	} else {
-		b43_phy_write(dev, 0x0002, (b43_phy_read(dev, 0x0002) & 0xFFC0)
-			      | 0x0004);
+		b43_phy_maskset(dev, 0x0002, 0xFFC0, 0x0004);
 	}
 	if (phy->type == B43_PHYTYPE_B)
 		B43_WARN_ON(1);
 	else if (phy->type == B43_PHYTYPE_G)
 		b43_write16(dev, 0x03E6, 0x0);
 }
@@ -1834,28 +1772,24 @@ static void b43_calc_loopback_gain(struc
 		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0002);
 		b43_phy_mask(dev, B43_PHY_ANALOGOVERVAL, 0xFFFD);
 	}
 	b43_phy_set(dev, B43_PHY_RFOVER, 0x000C);
 	b43_phy_set(dev, B43_PHY_RFOVERVAL, 0x000C);
 	b43_phy_set(dev, B43_PHY_RFOVER, 0x0030);
-	b43_phy_write(dev, B43_PHY_RFOVERVAL,
-		      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
-		       & 0xFFCF) | 0x10);
+	b43_phy_maskset(dev, B43_PHY_RFOVERVAL, 0xFFCF, 0x10);
 
 	b43_phy_write(dev, B43_PHY_CCK(0x5A), 0x0780);
 	b43_phy_write(dev, B43_PHY_CCK(0x59), 0xC810);
 	b43_phy_write(dev, B43_PHY_CCK(0x58), 0x000D);
 
 	b43_phy_set(dev, B43_PHY_CCK(0x0A), 0x2000);
 	if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
 		b43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0004);
 		b43_phy_mask(dev, B43_PHY_ANALOGOVERVAL, 0xFFFB);
 	}
-	b43_phy_write(dev, B43_PHY_CCK(0x03),
-		      (b43_phy_read(dev, B43_PHY_CCK(0x03))
-		       & 0xFF9F) | 0x40);
+	b43_phy_maskset(dev, B43_PHY_CCK(0x03), 0xFF9F, 0x40);
 
 	if (phy->radio_rev == 8) {
 		b43_radio_write16(dev, 0x43, 0x000F);
 	} else {
 		b43_radio_write16(dev, 0x52, 0);
 		b43_radio_write16(dev, 0x43, (b43_radio_read16(dev, 0x43)
@@ -1866,18 +1800,14 @@ static void b43_calc_loopback_gain(struc
 	if (phy->rev >= 3)
 		b43_phy_write(dev, B43_PHY_LO_MASK, 0xC020);
 	else
 		b43_phy_write(dev, B43_PHY_LO_MASK, 0x8020);
 	b43_phy_write(dev, B43_PHY_LO_CTL, 0);
 
-	b43_phy_write(dev, B43_PHY_CCK(0x2B),
-		      (b43_phy_read(dev, B43_PHY_CCK(0x2B))
-		       & 0xFFC0) | 0x01);
-	b43_phy_write(dev, B43_PHY_CCK(0x2B),
-		      (b43_phy_read(dev, B43_PHY_CCK(0x2B))
-		       & 0xC0FF) | 0x800);
+	b43_phy_maskset(dev, B43_PHY_CCK(0x2B), 0xFFC0, 0x01);
+	b43_phy_maskset(dev, B43_PHY_CCK(0x2B), 0xC0FF, 0x800);
 
 	b43_phy_set(dev, B43_PHY_RFOVER, 0x0100);
 	b43_phy_mask(dev, B43_PHY_RFOVERVAL, 0xCFFF);
 
 	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_EXTLNA) {
 		if (phy->rev >= 7) {
@@ -1890,18 +1820,14 @@ static void b43_calc_loopback_gain(struc
 
 	j = 0;
 	loop_i_max = (phy->radio_rev == 8) ? 15 : 9;
 	for (i = 0; i < loop_i_max; i++) {
 		for (j = 0; j < 16; j++) {
 			b43_radio_write16(dev, 0x43, i);
-			b43_phy_write(dev, B43_PHY_RFOVERVAL,
-				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
-				       & 0xF0FF) | (j << 8));
-			b43_phy_write(dev, B43_PHY_PGACTL,
-				      (b43_phy_read(dev, B43_PHY_PGACTL)
-				       & 0x0FFF) | 0xA000);
+			b43_phy_maskset(dev, B43_PHY_RFOVERVAL, 0xF0FF, (j << 8));
+			b43_phy_maskset(dev, B43_PHY_PGACTL, 0x0FFF, 0xA000);
 			b43_phy_set(dev, B43_PHY_PGACTL, 0xF000);
 			udelay(20);
 			if (b43_phy_read(dev, B43_PHY_LO_LEAKAGE) >= 0xDFC)
 				goto exit_loop1;
 		}
 	}
@@ -1909,18 +1835,14 @@ static void b43_calc_loopback_gain(struc
 	loop1_outer_done = i;
 	loop1_inner_done = j;
 	if (j >= 8) {
 		b43_phy_set(dev, B43_PHY_RFOVERVAL, 0x30);
 		trsw_rx = 0x1B;
 		for (j = j - 8; j < 16; j++) {
-			b43_phy_write(dev, B43_PHY_RFOVERVAL,
-				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
-				       & 0xF0FF) | (j << 8));
-			b43_phy_write(dev, B43_PHY_PGACTL,
-				      (b43_phy_read(dev, B43_PHY_PGACTL)
-				       & 0x0FFF) | 0xA000);
+			b43_phy_maskset(dev, B43_PHY_RFOVERVAL, 0xF0FF, (j << 8));
+			b43_phy_maskset(dev, B43_PHY_PGACTL, 0x0FFF, 0xA000);
 			b43_phy_set(dev, B43_PHY_PGACTL, 0xF000);
 			udelay(20);
 			trsw_rx -= 3;
 			if (b43_phy_read(dev, B43_PHY_LO_LEAKAGE) >= 0xDFC)
 				goto exit_loop2;
 		}
@@ -1971,29 +1893,25 @@ static void b43_hardware_pctl_early_init
 
 	b43_phy_mask(dev, 0x0036, 0xFEFF);
 	b43_phy_write(dev, 0x002F, 0x0202);
 	b43_phy_set(dev, 0x047C, 0x0002);
 	b43_phy_set(dev, 0x047A, 0xF000);
 	if (phy->radio_ver == 0x2050 && phy->radio_rev == 8) {
-		b43_phy_write(dev, 0x047A, (b43_phy_read(dev, 0x047A)
-					    & 0xFF0F) | 0x0010);
+		b43_phy_maskset(dev, 0x047A, 0xFF0F, 0x0010);
 		b43_phy_set(dev, 0x005D, 0x8000);
-		b43_phy_write(dev, 0x004E, (b43_phy_read(dev, 0x004E)
-					    & 0xFFC0) | 0x0010);
+		b43_phy_maskset(dev, 0x004E, 0xFFC0, 0x0010);
 		b43_phy_write(dev, 0x002E, 0xC07F);
 		b43_phy_set(dev, 0x0036, 0x0400);
 	} else {
 		b43_phy_set(dev, 0x0036, 0x0200);
 		b43_phy_set(dev, 0x0036, 0x0400);
 		b43_phy_mask(dev, 0x005D, 0x7FFF);
 		b43_phy_mask(dev, 0x004F, 0xFFFE);
-		b43_phy_write(dev, 0x004E, (b43_phy_read(dev, 0x004E)
-					    & 0xFFC0) | 0x0010);
+		b43_phy_maskset(dev, 0x004E, 0xFFC0, 0x0010);
 		b43_phy_write(dev, 0x002E, 0xC07F);
-		b43_phy_write(dev, 0x047A, (b43_phy_read(dev, 0x047A)
-					    & 0xFF0F) | 0x0010);
+		b43_phy_maskset(dev, 0x047A, 0xFF0F, 0x0010);
 	}
 }
 
 /* Hardware power control for G-PHY */
 static void b43_hardware_pctl_init_gphy(struct b43_wldev *dev)
 {
@@ -2003,16 +1921,14 @@ static void b43_hardware_pctl_init_gphy(
 	if (!b43_has_hardware_pctl(dev)) {
 		/* No hardware power control */
 		b43_hf_write(dev, b43_hf_read(dev) & ~B43_HF_HWPCTL);
 		return;
 	}
 
-	b43_phy_write(dev, 0x0036, (b43_phy_read(dev, 0x0036) & 0xFFC0)
-		      | (gphy->tgt_idle_tssi - gphy->cur_idle_tssi));
-	b43_phy_write(dev, 0x0478, (b43_phy_read(dev, 0x0478) & 0xFF00)
-		      | (gphy->tgt_idle_tssi - gphy->cur_idle_tssi));
+	b43_phy_maskset(dev, 0x0036, 0xFFC0, (gphy->tgt_idle_tssi - gphy->cur_idle_tssi));
+	b43_phy_maskset(dev, 0x0478, 0xFF00, (gphy->tgt_idle_tssi - gphy->cur_idle_tssi));
 	b43_gphy_tssi_power_lt_init(dev);
 	b43_gphy_gain_lt_init(dev);
 	b43_phy_mask(dev, 0x0060, 0xFFBF);
 	b43_phy_write(dev, 0x0014, 0x0000);
 
 	B43_WARN_ON(phy->rev < 6);
@@ -2131,15 +2047,13 @@ static void b43_phy_initg(struct b43_wld
 		tmp &= B43_PHYVER_VERSION;
 		if (tmp == 3 || tmp == 5) {
 			b43_phy_write(dev, B43_PHY_OFDM(0xC2), 0x1816);
 			b43_phy_write(dev, B43_PHY_OFDM(0xC3), 0x8006);
 		}
 		if (tmp == 5) {
-			b43_phy_write(dev, B43_PHY_OFDM(0xCC),
-				      (b43_phy_read(dev, B43_PHY_OFDM(0xCC))
-				       & 0x00FF) | 0x1F00);
+			b43_phy_maskset(dev, B43_PHY_OFDM(0xCC), 0x00FF, 0x1F00);
 		}
 	}
 	if ((phy->rev <= 2 && phy->gmode) || phy->rev >= 2)
 		b43_phy_write(dev, B43_PHY_OFDM(0x7E), 0x78);
 	if (phy->radio_rev == 8) {
 		b43_phy_set(dev, B43_PHY_EXTG(0x01), 0x80);
@@ -2163,16 +2077,13 @@ static void b43_phy_initg(struct b43_wld
 	} else {
 		b43_radio_write16(dev, 0x52,
 				  (b43_radio_read16(dev, 0x52) & 0xFFF0)
 				  | gphy->lo_control->tx_bias);
 	}
 	if (phy->rev >= 6) {
-		b43_phy_write(dev, B43_PHY_CCK(0x36),
-			      (b43_phy_read(dev, B43_PHY_CCK(0x36))
-			       & 0x0FFF) | (gphy->lo_control->
-					    tx_bias << 12));
+		b43_phy_maskset(dev, B43_PHY_CCK(0x36), 0x0FFF, (gphy->lo_control->tx_bias << 12));
 	}
 	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_PACTRL)
 		b43_phy_write(dev, B43_PHY_CCK(0x2E), 0x8075);
 	else
 		b43_phy_write(dev, B43_PHY_CCK(0x2E), 0x807F);
 	if (phy->rev < 2)
@@ -2420,14 +2331,13 @@ static u8 b43_gphy_aci_scan(struct b43_w
 
 	for (i = start; i <= end; i++) {
 		if (abs(channel - i) > 2)
 			ret[i - 1] = b43_gphy_aci_detect(dev, i);
 	}
 	b43_switch_channel(dev, channel);
-	b43_phy_write(dev, 0x0802,
-		      (b43_phy_read(dev, 0x0802) & 0xFFFC) | 0x0003);
+	b43_phy_maskset(dev, 0x0802, 0xFFFC, 0x0003);
 	b43_phy_mask(dev, 0x0403, 0xFFF8);
 	b43_phy_set(dev, B43_PHY_G_CRS, 0x8000);
 	b43_set_original_gains(dev);
 	for (i = 0; i < 13; i++) {
 		if (!ret[i])
 			continue;
Index: wireless-testing/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/wa.c	2009-02-20 19:06:00.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/wa.c	2009-02-20 19:06:39.000000000 +0100
@@ -69,17 +69,15 @@ void b43_wa_initgains(struct b43_wldev *
 
 	b43_phy_write(dev, 0x0024, 0x4680);
 	b43_phy_write(dev, 0x0020, 0x0003);
 	b43_phy_write(dev, 0x001D, 0x0F40);
 	b43_phy_write(dev, 0x001F, 0x1C00);
 	if (phy->rev <= 3)
-		b43_phy_write(dev, 0x002A,
-			(b43_phy_read(dev, 0x002A) & 0x00FF) | 0x0400);
+		b43_phy_maskset(dev, 0x002A, 0x00FF, 0x0400);
 	else if (phy->rev == 5) {
-		b43_phy_write(dev, 0x002A,
-			(b43_phy_read(dev, 0x002A) & 0x00FF) | 0x1A00);
+		b43_phy_maskset(dev, 0x002A, 0x00FF, 0x1A00);
 		b43_phy_write(dev, 0x00CC, 0x2121);
 	}
 	if (phy->rev >= 3)
 		b43_phy_write(dev, 0x00BA, 0x3ED5);
 }
 
@@ -268,14 +266,13 @@ static void b43_wa_2060txlna_gain(struct
 	b43_hf_write(dev, b43_hf_read(dev) |
 			 B43_HF_2060W);
 }
 
 static void b43_wa_lms(struct b43_wldev *dev)
 {
-	b43_phy_write(dev, 0x0055,
-		(b43_phy_read(dev, 0x0055) & 0xFFC0) | 0x0004);
+	b43_phy_maskset(dev, 0x0055, 0xFFC0, 0x0004);
 }
 
 static void b43_wa_mixedsignal(struct b43_wldev *dev)
 {
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 1, 3);
 }
@@ -325,14 +322,13 @@ static void b43_wa_crs_ed(struct b43_wld
 		b43_phy_set(dev, B43_PHY_ANTDWELL, 0x0800);
 	}
 }
 
 static void b43_wa_crs_thr(struct b43_wldev *dev)
 {
-	b43_phy_write(dev, B43_PHY_CRS0,
-			(b43_phy_read(dev, B43_PHY_CRS0) & ~0x03C0) | 0xD000);
+	b43_phy_maskset(dev, B43_PHY_CRS0, ~0x03C0, 0xD000);
 }
 
 static void b43_wa_crs_blank(struct b43_wldev *dev)
 {
 	b43_phy_write(dev, B43_PHY_OFDM(0x2C), 0x005A);
 }
@@ -383,77 +379,52 @@ static void b43_wa_altagc(struct b43_wld
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0, 254);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 1, 13);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 2, 19);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 3, 25);
 	}
 
-	b43_phy_write(dev, B43_PHY_CCKSHIFTBITS_WA,
-		(b43_phy_read(dev, B43_PHY_CCKSHIFTBITS_WA) & ~0xFF00) | 0x5700);
-	b43_phy_write(dev, B43_PHY_OFDM(0x1A),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x1A)) & ~0x007F) | 0x000F);
-	b43_phy_write(dev, B43_PHY_OFDM(0x1A),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x1A)) & ~0x3F80) | 0x2B80);
-	b43_phy_write(dev, B43_PHY_ANTWRSETT,
-		(b43_phy_read(dev, B43_PHY_ANTWRSETT) & 0xF0FF) | 0x0300);
+	b43_phy_maskset(dev, B43_PHY_CCKSHIFTBITS_WA, ~0xFF00, 0x5700);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x1A), ~0x007F, 0x000F);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x1A), ~0x3F80, 0x2B80);
+	b43_phy_maskset(dev, B43_PHY_ANTWRSETT, 0xF0FF, 0x0300);
 	b43_radio_write16(dev, 0x7A,
 		b43_radio_read16(dev, 0x7A) | 0x0008);
-	b43_phy_write(dev, B43_PHY_N1P1GAIN,
-		(b43_phy_read(dev, B43_PHY_N1P1GAIN) & ~0x000F) | 0x0008);
-	b43_phy_write(dev, B43_PHY_P1P2GAIN,
-		(b43_phy_read(dev, B43_PHY_P1P2GAIN) & ~0x0F00) | 0x0600);
-	b43_phy_write(dev, B43_PHY_N1N2GAIN,
-		(b43_phy_read(dev, B43_PHY_N1N2GAIN) & ~0x0F00) | 0x0700);
-	b43_phy_write(dev, B43_PHY_N1P1GAIN,
-		(b43_phy_read(dev, B43_PHY_N1P1GAIN) & ~0x0F00) | 0x0100);
+	b43_phy_maskset(dev, B43_PHY_N1P1GAIN, ~0x000F, 0x0008);
+	b43_phy_maskset(dev, B43_PHY_P1P2GAIN, ~0x0F00, 0x0600);
+	b43_phy_maskset(dev, B43_PHY_N1N2GAIN, ~0x0F00, 0x0700);
+	b43_phy_maskset(dev, B43_PHY_N1P1GAIN, ~0x0F00, 0x0100);
 	if (phy->rev == 1) {
-		b43_phy_write(dev, B43_PHY_N1N2GAIN,
-				  (b43_phy_read(dev, B43_PHY_N1N2GAIN)
-				   & ~0x000F) | 0x0007);
-	}
-	b43_phy_write(dev, B43_PHY_OFDM(0x88),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x88)) & ~0x00FF) | 0x001C);
-	b43_phy_write(dev, B43_PHY_OFDM(0x88),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x88)) & ~0x3F00) | 0x0200);
-	b43_phy_write(dev, B43_PHY_OFDM(0x96),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x96)) & ~0x00FF) | 0x001C);
-	b43_phy_write(dev, B43_PHY_OFDM(0x89),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x89)) & ~0x00FF) | 0x0020);
-	b43_phy_write(dev, B43_PHY_OFDM(0x89),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x89)) & ~0x3F00) | 0x0200);
-	b43_phy_write(dev, B43_PHY_OFDM(0x82),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x82)) & ~0x00FF) | 0x002E);
-	b43_phy_write(dev, B43_PHY_OFDM(0x96),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x96)) & ~0xFF00) | 0x1A00);
-	b43_phy_write(dev, B43_PHY_OFDM(0x81),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x81)) & ~0x00FF) | 0x0028);
-	b43_phy_write(dev, B43_PHY_OFDM(0x81),
-		(b43_phy_read(dev, B43_PHY_OFDM(0x81)) & ~0xFF00) | 0x2C00);
+		b43_phy_maskset(dev, B43_PHY_N1N2GAIN, ~0x000F, 0x0007);
+	}
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x88), ~0x00FF, 0x001C);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x88), ~0x3F00, 0x0200);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x96), ~0x00FF, 0x001C);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x89), ~0x00FF, 0x0020);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x89), ~0x3F00, 0x0200);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x82), ~0x00FF, 0x002E);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x96), ~0xFF00, 0x1A00);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x81), ~0x00FF, 0x0028);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x81), ~0xFF00, 0x2C00);
 	if (phy->rev == 1) {
 		b43_phy_write(dev, B43_PHY_PEAK_COUNT, 0x092B);
-		b43_phy_write(dev, B43_PHY_OFDM(0x1B),
-			(b43_phy_read(dev, B43_PHY_OFDM(0x1B)) & ~0x001E) | 0x0002);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x1B), ~0x001E, 0x0002);
 	} else {
 		b43_phy_mask(dev, B43_PHY_OFDM(0x1B), ~0x001E);
 		b43_phy_write(dev, B43_PHY_OFDM(0x1F), 0x287A);
-		b43_phy_write(dev, B43_PHY_LPFGAINCTL,
-			(b43_phy_read(dev, B43_PHY_LPFGAINCTL) & ~0x000F) | 0x0004);
+		b43_phy_maskset(dev, B43_PHY_LPFGAINCTL, ~0x000F, 0x0004);
 		if (phy->rev >= 6) {
 			b43_phy_write(dev, B43_PHY_OFDM(0x22), 0x287A);
-			b43_phy_write(dev, B43_PHY_LPFGAINCTL,
-				(b43_phy_read(dev, B43_PHY_LPFGAINCTL) & ~0xF000) | 0x3000);
+			b43_phy_maskset(dev, B43_PHY_LPFGAINCTL, ~0xF000, 0x3000);
 		}
 	}
-	b43_phy_write(dev, B43_PHY_DIVSRCHIDX,
-		(b43_phy_read(dev, B43_PHY_DIVSRCHIDX) & 0x8080) | 0x7874);
+	b43_phy_maskset(dev, B43_PHY_DIVSRCHIDX, 0x8080, 0x7874);
 	b43_phy_write(dev, B43_PHY_OFDM(0x8E), 0x1C00);
 	if (phy->rev == 1) {
-		b43_phy_write(dev, B43_PHY_DIVP1P2GAIN,
-			(b43_phy_read(dev, B43_PHY_DIVP1P2GAIN) & ~0x0F00) | 0x0600);
+		b43_phy_maskset(dev, B43_PHY_DIVP1P2GAIN, ~0x0F00, 0x0600);
 		b43_phy_write(dev, B43_PHY_OFDM(0x8B), 0x005E);
-		b43_phy_write(dev, B43_PHY_ANTWRSETT,
-			(b43_phy_read(dev, B43_PHY_ANTWRSETT) & ~0x00FF) | 0x001E);
+		b43_phy_maskset(dev, B43_PHY_ANTWRSETT, ~0x00FF, 0x001E);
 		b43_phy_write(dev, B43_PHY_OFDM(0x8D), 0x0002);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 0, 0);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 1, 7);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 2, 16);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 3, 28);
 	} else {

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 19:28:14 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 19:28:14 +0100
Subject: [PATCH 4/6] b43: Convert usage of b43_radio_set()
Message-ID: <20090220183555.BE43B172583@mail.berlios.de>

This patch converts code to use the new b43_radio_set() API.

The semantic patch that makes this change is as follows:

// <smpl>
@@
expression dev, addr, set;
@@

-b43_radio_write16(dev, addr, b43_radio_read16(dev, addr) | set);
+b43_radio_set(dev, addr, set);
// </smpl>

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Index: wireless-testing/drivers/net/wireless/b43/phy_a.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_a.c	2009-02-20 19:06:09.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_a.c	2009-02-20 19:07:38.000000000 +0100
@@ -224,22 +224,20 @@ static void b43_phy_ww(struct b43_wldev 
 	u16 b, curr_s, best_s = 0xFFFF;
 	int i;
 
 	b43_phy_mask(dev, B43_PHY_CRS0, ~B43_PHY_CRS0_EN);
 	b43_phy_set(dev, B43_PHY_OFDM(0x1B), 0x1000);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x82), 0xF0FF, 0x0300);
-	b43_radio_write16(dev, 0x0009,
-		b43_radio_read16(dev, 0x0009) | 0x0080);
+	b43_radio_set(dev, 0x0009, 0x0080);
 	b43_radio_write16(dev, 0x0012,
 		(b43_radio_read16(dev, 0x0012) & 0xFFFC) | 0x0002);
 	b43_wa_initgains(dev);
 	b43_phy_write(dev, B43_PHY_OFDM(0xBA), 0x3ED5);
 	b = b43_phy_read(dev, B43_PHY_PWRDOWN);
 	b43_phy_write(dev, B43_PHY_PWRDOWN, (b & 0xFFF8) | 0x0005);
-	b43_radio_write16(dev, 0x0004,
-		b43_radio_read16(dev, 0x0004) | 0x0004);
+	b43_radio_set(dev, 0x0004, 0x0004);
 	for (i = 0x10; i <= 0x20; i++) {
 		b43_radio_write16(dev, 0x0013, i);
 		curr_s = b43_phy_read(dev, B43_PHY_OTABLEQ) & 0x00FF;
 		if (!curr_s) {
 			best_s = 0x0000;
 			break;
Index: wireless-testing/drivers/net/wireless/b43/phy_g.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_g.c	2009-02-20 19:06:09.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_g.c	2009-02-20 19:07:35.000000000 +0100
@@ -465,14 +465,14 @@ static void b43_calc_nrssi_offset(struct
 		b43_phy_write(dev, 0x0810, 0);
 		b43_phy_set(dev, 0x0478, 0x0100);
 		b43_phy_set(dev, 0x0801, 0x0040);
 		b43_phy_set(dev, 0x0060, 0x0040);
 		b43_phy_set(dev, 0x0014, 0x0200);
 	}
-	b43_radio_write16(dev, 0x007A, b43_radio_read16(dev, 0x007A) | 0x0070);
-	b43_radio_write16(dev, 0x007A, b43_radio_read16(dev, 0x007A) | 0x0080);
+	b43_radio_set(dev, 0x007A, 0x0070);
+	b43_radio_set(dev, 0x007A, 0x0080);
 	udelay(30);
 
 	v47F = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 	if (v47F >= 0x20)
 		v47F -= 0x40;
 	if (v47F == 31) {
@@ -509,14 +509,13 @@ static void b43_calc_nrssi_offset(struct
 		}
 		if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
 			b43_phy_set(dev, 0x0814, 0x0004);
 			b43_phy_mask(dev, 0x0815, 0xFFFB);
 		}
 		b43_phy_maskset(dev, 0x0003, 0xFF9F, 0x0040);
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x000F);
+		b43_radio_set(dev, 0x007A, 0x000F);
 		b43_set_all_gains(dev, 3, 0, 1);
 		b43_radio_write16(dev, 0x0043, (b43_radio_read16(dev, 0x0043)
 						& 0x00F0) | 0x000F);
 		udelay(30);
 		v47F = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (v47F >= 0x20)
@@ -622,23 +621,21 @@ static void b43_calc_nrssi_slope(struct 
 			b43_phy_mask(dev, 0x0801, 0xFFBF);
 			break;
 		}
 		b43_phy_set(dev, 0x0060, 0x0040);
 		b43_phy_set(dev, 0x0014, 0x0200);
 	}
-	b43_radio_write16(dev, 0x007A,
-			  b43_radio_read16(dev, 0x007A) | 0x0070);
+	b43_radio_set(dev, 0x007A, 0x0070);
 	b43_set_all_gains(dev, 0, 8, 0);
 	b43_radio_write16(dev, 0x007A,
 			  b43_radio_read16(dev, 0x007A) & 0x00F7);
 	if (phy->rev >= 2) {
 		b43_phy_maskset(dev, 0x0811, 0xFFCF, 0x0030);
 		b43_phy_maskset(dev, 0x0812, 0xFFCF, 0x0010);
 	}
-	b43_radio_write16(dev, 0x007A,
-			  b43_radio_read16(dev, 0x007A) | 0x0080);
+	b43_radio_set(dev, 0x007A, 0x0080);
 	udelay(20);
 
 	nrssi0 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 	if (nrssi0 >= 0x0020)
 		nrssi0 -= 0x0040;
 
@@ -648,14 +645,13 @@ static void b43_calc_nrssi_slope(struct 
 		b43_phy_maskset(dev, 0x0003, 0xFF9F, 0x0040);
 	}
 
 	b43_write16(dev, B43_MMIO_CHANNEL_EXT,
 		    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
 		    | 0x2000);
-	b43_radio_write16(dev, 0x007A,
-			  b43_radio_read16(dev, 0x007A) | 0x000F);
+	b43_radio_set(dev, 0x007A, 0x000F);
 	b43_phy_write(dev, 0x0015, 0xF330);
 	if (phy->rev >= 2) {
 		b43_phy_maskset(dev, 0x0812, 0xFFCF, 0x0020);
 		b43_phy_maskset(dev, 0x0811, 0xFFCF, 0x0020);
 	}
 
@@ -1352,14 +1348,13 @@ static u16 b43_radio_init2050(struct b43
 	if (phy->gmode || phy->rev >= 2) {
 		b43_phy_write(dev, B43_PHY_RFOVERVAL,
 			      radio2050_rfover_val(dev, B43_PHY_RFOVERVAL,
 						   LPD(0, 0, 1)));
 	}
 	b43_phy_write(dev, B43_PHY_PGACTL, 0xBFA0);
-	b43_radio_write16(dev, 0x51, b43_radio_read16(dev, 0x51)
-			  | 0x0004);
+	b43_radio_set(dev, 0x51, 0x0004);
 	if (phy->radio_rev == 8) {
 		b43_radio_write16(dev, 0x43, 0x1F);
 	} else {
 		b43_radio_write16(dev, 0x52, 0);
 		b43_radio_write16(dev, 0x43, (b43_radio_read16(dev, 0x43)
 					      & 0xFFF0) | 0x0009);
@@ -1508,14 +1503,13 @@ static void b43_phy_initb5(struct b43_wl
 	struct b43_phy *phy = &dev->phy;
 	struct b43_phy_g *gphy = phy->g;
 	u16 offset, value;
 	u8 old_channel;
 
 	if (phy->analog == 1) {
-		b43_radio_write16(dev, 0x007A, b43_radio_read16(dev, 0x007A)
-				  | 0x0050);
+		b43_radio_set(dev, 0x007A, 0x0050);
 	}
 	if ((bus->boardinfo.vendor != SSB_BOARDVENDOR_BCM) &&
 	    (bus->boardinfo.type != SSB_BOARD_BU4306)) {
 		value = 0x2120;
 		for (offset = 0x00A8; offset < 0x00C7; offset++) {
 			b43_phy_write(dev, offset, value);
@@ -1525,18 +1519,14 @@ static void b43_phy_initb5(struct b43_wl
 	b43_phy_maskset(dev, 0x0035, 0xF0FF, 0x0700);
 	if (phy->radio_ver == 0x2050)
 		b43_phy_write(dev, 0x0038, 0x0667);
 
 	if (phy->gmode || phy->rev >= 2) {
 		if (phy->radio_ver == 0x2050) {
-			b43_radio_write16(dev, 0x007A,
-					  b43_radio_read16(dev, 0x007A)
-					  | 0x0020);
-			b43_radio_write16(dev, 0x0051,
-					  b43_radio_read16(dev, 0x0051)
-					  | 0x0004);
+			b43_radio_set(dev, 0x007A, 0x0020);
+			b43_radio_set(dev, 0x0051, 0x0004);
 		}
 		b43_write16(dev, B43_MMIO_PHY_RADIO, 0x0000);
 
 		b43_phy_set(dev, 0x0802, 0x0100);
 		b43_phy_set(dev, 0x042B, 0x2000);
 
@@ -1587,13 +1577,13 @@ static void b43_phy_initb5(struct b43_wl
 		b43_radio_write16(dev, 0x005A, 0x0070);
 	}
 
 	b43_radio_write16(dev, 0x005B, 0x007B);
 	b43_radio_write16(dev, 0x005C, 0x00B0);
 
-	b43_radio_write16(dev, 0x007A, b43_radio_read16(dev, 0x007A) | 0x0007);
+	b43_radio_set(dev, 0x007A, 0x0007);
 
 	b43_gphy_channel_switch(dev, old_channel, 0);
 
 	b43_phy_write(dev, 0x0014, 0x0080);
 	b43_phy_write(dev, 0x0032, 0x00CA);
 	b43_phy_write(dev, 0x002A, 0x88A3);
@@ -1663,16 +1653,14 @@ static void b43_phy_initb6(struct b43_wl
 	val = 0x2120;
 	for (offset = 0x00A8; offset < 0x00C8; offset++) {
 		b43_phy_write(dev, offset, (val & 0x3F3F));
 		val += 0x0202;
 	}
 	if (phy->type == B43_PHYTYPE_G) {
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x0020);
-		b43_radio_write16(dev, 0x0051,
-				  b43_radio_read16(dev, 0x0051) | 0x0004);
+		b43_radio_set(dev, 0x007A, 0x0020);
+		b43_radio_set(dev, 0x0051, 0x0004);
 		b43_phy_set(dev, 0x0802, 0x0100);
 		b43_phy_set(dev, 0x042B, 0x2000);
 		b43_phy_write(dev, 0x5B, 0);
 		b43_phy_write(dev, 0x5C, 0);
 	}
 
Index: wireless-testing/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/wa.c	2009-02-20 19:06:39.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/wa.c	2009-02-20 19:07:51.000000000 +0100
@@ -383,14 +383,13 @@ static void b43_wa_altagc(struct b43_wld
 	}
 
 	b43_phy_maskset(dev, B43_PHY_CCKSHIFTBITS_WA, ~0xFF00, 0x5700);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x1A), ~0x007F, 0x000F);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x1A), ~0x3F80, 0x2B80);
 	b43_phy_maskset(dev, B43_PHY_ANTWRSETT, 0xF0FF, 0x0300);
-	b43_radio_write16(dev, 0x7A,
-		b43_radio_read16(dev, 0x7A) | 0x0008);
+	b43_radio_set(dev, 0x7A, 0x0008);
 	b43_phy_maskset(dev, B43_PHY_N1P1GAIN, ~0x000F, 0x0008);
 	b43_phy_maskset(dev, B43_PHY_P1P2GAIN, ~0x0F00, 0x0600);
 	b43_phy_maskset(dev, B43_PHY_N1N2GAIN, ~0x0F00, 0x0700);
 	b43_phy_maskset(dev, B43_PHY_N1P1GAIN, ~0x0F00, 0x0100);
 	if (phy->rev == 1) {
 		b43_phy_maskset(dev, B43_PHY_N1N2GAIN, ~0x000F, 0x0007);

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 19:31:21 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 19:31:21 +0100
Subject: [PATCH 6/6] b43: Convert usage of b43_radio_maskset()
Message-ID: <20090220183557.26AB6170D46@mail.berlios.de>

This patch converts code to use the new b43_radio_maskset() API.

The semantic patch that makes this change is as follows:

// <smpl>
@@
expression dev, addr, mask, set;
@@

-b43_radio_write16(dev, addr, (b43_radio_read16(dev, addr) & mask) | set);
+b43_radio_maskset(dev, addr, mask, set);
// </smpl>

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Index: wireless-testing/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/lo.c	2009-02-20 19:14:48.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/lo.c	2009-02-20 19:15:06.000000000 +0100
@@ -222,14 +222,13 @@ static void lo_measure_txctl_values(stru
 			if (tmp >= cmp_val)
 				radio_pctl_reg = cmp_val;
 			else
 				radio_pctl_reg = tmp;
 		}
 	}
-	b43_radio_write16(dev, 0x43, (b43_radio_read16(dev, 0x43)
-				      & 0xFFF0) | radio_pctl_reg);
+	b43_radio_maskset(dev, 0x43, 0xFFF0, radio_pctl_reg);
 	b43_gphy_set_baseband_attenuation(dev, 2);
 
 	reg = lo_txctl_register_table(dev, &mask, NULL);
 	mask = ~mask;
 	b43_radio_mask(dev, reg, mask);
 
@@ -238,20 +237,16 @@ static void lo_measure_txctl_values(stru
 		int feedthrough;
 		int min_feedth = 0xFFFF;
 		u8 tx_magn, tx_bias;
 
 		for (i = 0; i < ARRAY_SIZE(tx_magn_values); i++) {
 			tx_magn = tx_magn_values[i];
-			b43_radio_write16(dev, 0x52,
-					  (b43_radio_read16(dev, 0x52)
-					   & 0xFF0F) | tx_magn);
+			b43_radio_maskset(dev, 0x52, 0xFF0F, tx_magn);
 			for (j = 0; j < ARRAY_SIZE(tx_bias_values); j++) {
 				tx_bias = tx_bias_values[j];
-				b43_radio_write16(dev, 0x52,
-						  (b43_radio_read16(dev, 0x52)
-						   & 0xFFF0) | tx_bias);
+				b43_radio_maskset(dev, 0x52, 0xFFF0, tx_bias);
 				feedthrough =
 				    lo_measure_feedthrough(dev, 0, pga,
 							   trsw_rx);
 				if (feedthrough < min_feedth) {
 					lo->tx_bias = tx_bias;
 					lo->tx_magn = tx_magn;
@@ -538,14 +533,13 @@ static void lo_measure_restore(struct b4
 	b43_phy_write(dev, B43_PHY_SYNCCTL, sav->phy_syncctl);
 	b43_phy_write(dev, B43_PHY_DACCTL, sav->phy_dacctl);
 	b43_radio_write16(dev, 0x43, sav->radio_43);
 	b43_radio_write16(dev, 0x7A, sav->radio_7A);
 	if (!has_tx_magnification(phy)) {
 		tmp = sav->radio_52;
-		b43_radio_write16(dev, 0x52, (b43_radio_read16(dev, 0x52)
-					      & 0xFF0F) | tmp);
+		b43_radio_maskset(dev, 0x52, 0xFF0F, tmp);
 	}
 	b43_write16(dev, 0x3E2, sav->reg_3E2);
 	if (phy->type == B43_PHYTYPE_B &&
 	    phy->radio_ver == 0x2050 && phy->radio_rev <= 5) {
 		b43_phy_write(dev, B43_PHY_CCK(0x30), sav->phy_cck_30);
 		b43_phy_write(dev, B43_PHY_CCK(0x06), sav->phy_cck_06);
@@ -758,18 +752,14 @@ struct b43_lo_calib * b43_calibrate_lo_s
 	saved_regs.old_channel = phy->channel;
 	b43_mac_suspend(dev);
 	lo_measure_setup(dev, &saved_regs);
 
 	txctl_reg = lo_txctl_register_table(dev, &txctl_value, &pad_mix_gain);
 
-	b43_radio_write16(dev, 0x43,
-			  (b43_radio_read16(dev, 0x43) & 0xFFF0)
-			  | rfatt->att);
-	b43_radio_write16(dev, txctl_reg,
-			  (b43_radio_read16(dev, txctl_reg) & ~txctl_value)
-			  | (rfatt->with_padmix ? txctl_value : 0));
+	b43_radio_maskset(dev, 0x43, 0xFFF0, rfatt->att);
+	b43_radio_maskset(dev, txctl_reg, ~txctl_value, (rfatt->with_padmix ? txctl_value :0));
 
 	max_rx_gain = rfatt->att * 2;
 	max_rx_gain += bbatt->att / 2;
 	if (rfatt->with_padmix)
 		max_rx_gain -= pad_mix_gain;
 	if (has_loopback_gain(phy))
Index: wireless-testing/drivers/net/wireless/b43/phy_a.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_a.c	2009-02-20 19:14:48.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_a.c	2009-02-20 19:15:06.000000000 +0100
@@ -118,31 +118,24 @@ static void aphy_channel_switch(struct b
 		 */
 		r8 = 3 * freq / 116;	/* is equal to r8 = freq * 0.025862 */
 	}
 	b43_radio_write16(dev, 0x0007, (r8 << 4) | r8);
 	b43_radio_write16(dev, 0x0020, (r8 << 4) | r8);
 	b43_radio_write16(dev, 0x0021, (r8 << 4) | r8);
-	b43_radio_write16(dev, 0x0022, (b43_radio_read16(dev, 0x0022)
-					& 0x000F) | (r8 << 4));
+	b43_radio_maskset(dev, 0x0022, 0x000F, (r8 << 4));
 	b43_radio_write16(dev, 0x002A, (r8 << 4));
 	b43_radio_write16(dev, 0x002B, (r8 << 4));
-	b43_radio_write16(dev, 0x0008, (b43_radio_read16(dev, 0x0008)
-					& 0x00F0) | (r8 << 4));
-	b43_radio_write16(dev, 0x0029, (b43_radio_read16(dev, 0x0029)
-					& 0xFF0F) | 0x00B0);
+	b43_radio_maskset(dev, 0x0008, 0x00F0, (r8 << 4));
+	b43_radio_maskset(dev, 0x0029, 0xFF0F, 0x00B0);
 	b43_radio_write16(dev, 0x0035, 0x00AA);
 	b43_radio_write16(dev, 0x0036, 0x0085);
-	b43_radio_write16(dev, 0x003A, (b43_radio_read16(dev, 0x003A)
-					& 0xFF20) |
-			  freq_r3A_value(freq));
+	b43_radio_maskset(dev, 0x003A, 0xFF20, freq_r3A_value(freq));
 	b43_radio_mask(dev, 0x003D, 0x00FF);
-	b43_radio_write16(dev, 0x0081, (b43_radio_read16(dev, 0x0081)
-					& 0xFF7F) | 0x0080);
+	b43_radio_maskset(dev, 0x0081, 0xFF7F, 0x0080);
 	b43_radio_mask(dev, 0x0035, 0xFFEF);
-	b43_radio_write16(dev, 0x0035, (b43_radio_read16(dev, 0x0035)
-					& 0xFFEF) | 0x0010);
+	b43_radio_maskset(dev, 0x0035, 0xFFEF, 0x0010);
 	b43_radio_set_tx_iq(dev);
 	//TODO: TSSI2dbm workaround
 //FIXME	b43_phy_xmitpower(dev);
 }
 
 static void b43_radio_init2060(struct b43_wldev *dev)
@@ -161,23 +154,20 @@ static void b43_radio_init2060(struct b4
 	b43_radio_mask(dev, 0x0005, ~0x0008);
 	b43_radio_mask(dev, 0x0081, ~0x0010);
 	b43_radio_mask(dev, 0x0081, ~0x0020);
 	b43_radio_mask(dev, 0x0081, ~0x0020);
 	msleep(1);		/* delay 400usec */
 
-	b43_radio_write16(dev, 0x0081,
-			  (b43_radio_read16(dev, 0x0081) & ~0x0020) | 0x0010);
+	b43_radio_maskset(dev, 0x0081, ~0x0020, 0x0010);
 	msleep(1);		/* delay 400usec */
 
-	b43_radio_write16(dev, 0x0005,
-			  (b43_radio_read16(dev, 0x0005) & ~0x0008) | 0x0008);
+	b43_radio_maskset(dev, 0x0005, ~0x0008, 0x0008);
 	b43_radio_mask(dev, 0x0085, ~0x0010);
 	b43_radio_mask(dev, 0x0005, ~0x0008);
 	b43_radio_mask(dev, 0x0081, ~0x0040);
-	b43_radio_write16(dev, 0x0081,
-			  (b43_radio_read16(dev, 0x0081) & ~0x0040) | 0x0040);
+	b43_radio_maskset(dev, 0x0081, ~0x0040, 0x0040);
 	b43_radio_write16(dev, 0x0005,
 			  (b43_radio_read16(dev, 0x0081) & ~0x0008) | 0x0008);
 	b43_phy_write(dev, 0x0063, 0xDDC6);
 	b43_phy_write(dev, 0x0069, 0x07BE);
 	b43_phy_write(dev, 0x006A, 0x0000);
 
@@ -223,14 +213,13 @@ static void b43_phy_ww(struct b43_wldev 
 	int i;
 
 	b43_phy_mask(dev, B43_PHY_CRS0, ~B43_PHY_CRS0_EN);
 	b43_phy_set(dev, B43_PHY_OFDM(0x1B), 0x1000);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x82), 0xF0FF, 0x0300);
 	b43_radio_set(dev, 0x0009, 0x0080);
-	b43_radio_write16(dev, 0x0012,
-		(b43_radio_read16(dev, 0x0012) & 0xFFFC) | 0x0002);
+	b43_radio_maskset(dev, 0x0012, 0xFFFC, 0x0002);
 	b43_wa_initgains(dev);
 	b43_phy_write(dev, B43_PHY_OFDM(0xBA), 0x3ED5);
 	b = b43_phy_read(dev, B43_PHY_PWRDOWN);
 	b43_phy_write(dev, B43_PHY_PWRDOWN, (b & 0xFFF8) | 0x0005);
 	b43_radio_set(dev, 0x0004, 0x0004);
 	for (i = 0x10; i <= 0x20; i++) {
Index: wireless-testing/drivers/net/wireless/b43/phy_g.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_g.c	2009-02-20 19:14:48.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_g.c	2009-02-20 19:15:06.000000000 +0100
@@ -245,23 +245,19 @@ static void b43_set_txpower_g(struct b43
 	b43_gphy_set_baseband_attenuation(dev, bb);
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_RFATT, rf);
 	if (phy->radio_ver == 0x2050 && phy->radio_rev == 8) {
 		b43_radio_write16(dev, 0x43,
 				  (rf & 0x000F) | (tx_control & 0x0070));
 	} else {
-		b43_radio_write16(dev, 0x43, (b43_radio_read16(dev, 0x43)
-					      & 0xFFF0) | (rf & 0x000F));
-		b43_radio_write16(dev, 0x52, (b43_radio_read16(dev, 0x52)
-					      & ~0x0070) | (tx_control &
-							    0x0070));
+		b43_radio_maskset(dev, 0x43, 0xFFF0, (rf & 0x000F));
+		b43_radio_maskset(dev, 0x52, ~0x0070, (tx_control & 0x0070));
 	}
 	if (has_tx_magnification(phy)) {
 		b43_radio_write16(dev, 0x52, tx_magn | tx_bias);
 	} else {
-		b43_radio_write16(dev, 0x52, (b43_radio_read16(dev, 0x52)
-					      & 0xFFF0) | (tx_bias & 0x000F));
+		b43_radio_maskset(dev, 0x52, 0xFFF0, (tx_bias & 0x000F));
 	}
 	b43_lo_g_adjust(dev);
 }
 
 /* GPHY_TSSI_Power_Lookup_Table_Init */
 static void b43_gphy_tssi_power_lt_init(struct b43_wldev *dev)
@@ -510,14 +506,13 @@ static void b43_calc_nrssi_offset(struct
 			b43_phy_set(dev, 0x0814, 0x0004);
 			b43_phy_mask(dev, 0x0815, 0xFFFB);
 		}
 		b43_phy_maskset(dev, 0x0003, 0xFF9F, 0x0040);
 		b43_radio_set(dev, 0x007A, 0x000F);
 		b43_set_all_gains(dev, 3, 0, 1);
-		b43_radio_write16(dev, 0x0043, (b43_radio_read16(dev, 0x0043)
-						& 0x00F0) | 0x000F);
+		b43_radio_maskset(dev, 0x0043, 0x00F0, 0x000F);
 		udelay(30);
 		v47F = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (v47F >= 0x20)
 			v47F -= 0x40;
 		if (v47F == -32) {
 			for (i = 0; i < 4; i++) {
@@ -1350,14 +1345,13 @@ static u16 b43_radio_init2050(struct b43
 	b43_phy_write(dev, B43_PHY_PGACTL, 0xBFA0);
 	b43_radio_set(dev, 0x51, 0x0004);
 	if (phy->radio_rev == 8) {
 		b43_radio_write16(dev, 0x43, 0x1F);
 	} else {
 		b43_radio_write16(dev, 0x52, 0);
-		b43_radio_write16(dev, 0x43, (b43_radio_read16(dev, 0x43)
-					      & 0xFFF0) | 0x0009);
+		b43_radio_maskset(dev, 0x43, 0xFFF0, 0x0009);
 	}
 	b43_phy_write(dev, B43_PHY_CCK(0x58), 0);
 
 	for (i = 0; i < 16; i++) {
 		b43_phy_write(dev, B43_PHY_CCK(0x5A), 0x0480);
 		b43_phy_write(dev, B43_PHY_CCK(0x59), 0xC810);
@@ -1678,14 +1672,13 @@ static void b43_phy_initb6(struct b43_wl
 	if (phy->radio_rev <= 2) {
 		b43_radio_write16(dev, 0x7C, 0x20);
 		b43_radio_write16(dev, 0x5A, 0x70);
 		b43_radio_write16(dev, 0x5B, 0x7B);
 		b43_radio_write16(dev, 0x5C, 0xB0);
 	}
-	b43_radio_write16(dev, 0x007A,
-			  (b43_radio_read16(dev, 0x007A) & 0x00F8) | 0x0007);
+	b43_radio_maskset(dev, 0x007A, 0x00F8, 0x0007);
 
 	b43_gphy_channel_switch(dev, old_channel, 0);
 
 	b43_phy_write(dev, 0x0014, 0x0200);
 	if (phy->radio_rev >= 6)
 		b43_phy_write(dev, 0x2A, 0x88C2);
@@ -1774,14 +1767,13 @@ static void b43_calc_loopback_gain(struc
 	b43_phy_maskset(dev, B43_PHY_CCK(0x03), 0xFF9F, 0x40);
 
 	if (phy->radio_rev == 8) {
 		b43_radio_write16(dev, 0x43, 0x000F);
 	} else {
 		b43_radio_write16(dev, 0x52, 0);
-		b43_radio_write16(dev, 0x43, (b43_radio_read16(dev, 0x43)
-					      & 0xFFF0) | 0x9);
+		b43_radio_maskset(dev, 0x43, 0xFFF0, 0x9);
 	}
 	b43_gphy_set_baseband_attenuation(dev, 11);
 
 	if (phy->rev >= 3)
 		b43_phy_write(dev, B43_PHY_LO_MASK, 0xC020);
 	else
@@ -1950,15 +1942,13 @@ static void b43_phy_init_pctl(struct b43
 
 	if (!phy->gmode)
 		return;
 	b43_hardware_pctl_early_init(dev);
 	if (gphy->cur_idle_tssi == 0) {
 		if (phy->radio_ver == 0x2050 && phy->analog == 0) {
-			b43_radio_write16(dev, 0x0076,
-					  (b43_radio_read16(dev, 0x0076)
-					   & 0x00F7) | 0x0084);
+			b43_radio_maskset(dev, 0x0076, 0x00F7, 0x0084);
 		} else {
 			struct b43_rfatt rfatt;
 			struct b43_bbatt bbatt;
 
 			memcpy(&old_rfatt, &gphy->rfatt, sizeof(old_rfatt));
 			memcpy(&old_bbatt, &gphy->bbatt, sizeof(old_bbatt));
@@ -2054,15 +2044,13 @@ static void b43_phy_initg(struct b43_wld
 	if (has_tx_magnification(phy)) {
 		b43_radio_write16(dev, 0x52,
 				  (b43_radio_read16(dev, 0x52) & 0xFF00)
 				  | gphy->lo_control->tx_bias | gphy->
 				  lo_control->tx_magn);
 	} else {
-		b43_radio_write16(dev, 0x52,
-				  (b43_radio_read16(dev, 0x52) & 0xFFF0)
-				  | gphy->lo_control->tx_bias);
+		b43_radio_maskset(dev, 0x52, 0xFFF0, gphy->lo_control->tx_bias);
 	}
 	if (phy->rev >= 6) {
 		b43_phy_maskset(dev, B43_PHY_CCK(0x36), 0x0FFF, (gphy->lo_control->tx_bias << 12));
 	}
 	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_PACTRL)
 		b43_phy_write(dev, B43_PHY_CCK(0x2E), 0x8075);

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 19:30:10 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 19:30:10 +0100
Subject: [PATCH 5/6] b43: Convert usage of b43_radio_mask()
Message-ID: <20090220183556.4913B172584@mail.berlios.de>

This patch converts code to use the new b43_radio_mask() API.

The semantic patch that makes this change is as follows:

// <smpl>
@@
expression dev, addr, mask;
@@

-b43_radio_write16(dev, addr, b43_radio_read16(dev, addr) & mask);
+b43_radio_mask(dev, addr, mask);
// </smpl>

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Index: wireless-testing/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/lo.c	2009-02-20 19:07:11.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/lo.c	2009-02-20 19:08:49.000000000 +0100
@@ -228,14 +228,13 @@ static void lo_measure_txctl_values(stru
 	b43_radio_write16(dev, 0x43, (b43_radio_read16(dev, 0x43)
 				      & 0xFFF0) | radio_pctl_reg);
 	b43_gphy_set_baseband_attenuation(dev, 2);
 
 	reg = lo_txctl_register_table(dev, &mask, NULL);
 	mask = ~mask;
-	b43_radio_write16(dev, reg, b43_radio_read16(dev, reg)
-			  & mask);
+	b43_radio_mask(dev, reg, mask);
 
 	if (has_tx_magnification(phy)) {
 		int i, j;
 		int feedthrough;
 		int min_feedth = 0xFFFF;
 		u8 tx_magn, tx_bias;
@@ -266,14 +265,13 @@ static void lo_measure_txctl_values(stru
 					   & 0xFF00) | lo->tx_bias | lo->
 					  tx_magn);
 		}
 	} else {
 		lo->tx_magn = 0;
 		lo->tx_bias = 0;
-		b43_radio_write16(dev, 0x52, b43_radio_read16(dev, 0x52)
-				  & 0xFFF0);	/* TX bias == 0 */
+		b43_radio_mask(dev, 0x52, 0xFFF0);	/* TX bias == 0 */
 	}
 	lo->txctl_measured_time = jiffies;
 }
 
 static void lo_read_power_vector(struct b43_wldev *dev)
 {
Index: wireless-testing/drivers/net/wireless/b43/phy_a.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_a.c	2009-02-20 19:07:38.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_a.c	2009-02-20 19:08:44.000000000 +0100
@@ -131,18 +131,16 @@ static void aphy_channel_switch(struct b
 					& 0xFF0F) | 0x00B0);
 	b43_radio_write16(dev, 0x0035, 0x00AA);
 	b43_radio_write16(dev, 0x0036, 0x0085);
 	b43_radio_write16(dev, 0x003A, (b43_radio_read16(dev, 0x003A)
 					& 0xFF20) |
 			  freq_r3A_value(freq));
-	b43_radio_write16(dev, 0x003D,
-			  b43_radio_read16(dev, 0x003D) & 0x00FF);
+	b43_radio_mask(dev, 0x003D, 0x00FF);
 	b43_radio_write16(dev, 0x0081, (b43_radio_read16(dev, 0x0081)
 					& 0xFF7F) | 0x0080);
-	b43_radio_write16(dev, 0x0035,
-			  b43_radio_read16(dev, 0x0035) & 0xFFEF);
+	b43_radio_mask(dev, 0x0035, 0xFFEF);
 	b43_radio_write16(dev, 0x0035, (b43_radio_read16(dev, 0x0035)
 					& 0xFFEF) | 0x0010);
 	b43_radio_set_tx_iq(dev);
 	//TODO: TSSI2dbm workaround
 //FIXME	b43_phy_xmitpower(dev);
 }
@@ -157,27 +155,27 @@ static void b43_radio_init2060(struct b4
 	b43_radio_write16(dev, 0x0006, 0x008F);
 	b43_radio_write16(dev, 0x0034, 0x008F);
 	b43_radio_write16(dev, 0x002C, 0x0007);
 	b43_radio_write16(dev, 0x0082, 0x0080);
 	b43_radio_write16(dev, 0x0080, 0x0000);
 	b43_radio_write16(dev, 0x003F, 0x00DA);
-	b43_radio_write16(dev, 0x0005, b43_radio_read16(dev, 0x0005) & ~0x0008);
-	b43_radio_write16(dev, 0x0081, b43_radio_read16(dev, 0x0081) & ~0x0010);
-	b43_radio_write16(dev, 0x0081, b43_radio_read16(dev, 0x0081) & ~0x0020);
-	b43_radio_write16(dev, 0x0081, b43_radio_read16(dev, 0x0081) & ~0x0020);
+	b43_radio_mask(dev, 0x0005, ~0x0008);
+	b43_radio_mask(dev, 0x0081, ~0x0010);
+	b43_radio_mask(dev, 0x0081, ~0x0020);
+	b43_radio_mask(dev, 0x0081, ~0x0020);
 	msleep(1);		/* delay 400usec */
 
 	b43_radio_write16(dev, 0x0081,
 			  (b43_radio_read16(dev, 0x0081) & ~0x0020) | 0x0010);
 	msleep(1);		/* delay 400usec */
 
 	b43_radio_write16(dev, 0x0005,
 			  (b43_radio_read16(dev, 0x0005) & ~0x0008) | 0x0008);
-	b43_radio_write16(dev, 0x0085, b43_radio_read16(dev, 0x0085) & ~0x0010);
-	b43_radio_write16(dev, 0x0005, b43_radio_read16(dev, 0x0005) & ~0x0008);
-	b43_radio_write16(dev, 0x0081, b43_radio_read16(dev, 0x0081) & ~0x0040);
+	b43_radio_mask(dev, 0x0085, ~0x0010);
+	b43_radio_mask(dev, 0x0005, ~0x0008);
+	b43_radio_mask(dev, 0x0081, ~0x0040);
 	b43_radio_write16(dev, 0x0081,
 			  (b43_radio_read16(dev, 0x0081) & ~0x0040) | 0x0040);
 	b43_radio_write16(dev, 0x0005,
 			  (b43_radio_read16(dev, 0x0081) & ~0x0008) | 0x0008);
 	b43_phy_write(dev, 0x0063, 0xDDC6);
 	b43_phy_write(dev, 0x0069, 0x07BE);
@@ -244,14 +242,13 @@ static void b43_phy_ww(struct b43_wldev 
 		} else if (curr_s >= 0x0080)
 			curr_s = 0x0100 - curr_s;
 		if (curr_s < best_s)
 			best_s = curr_s;
 	}
 	b43_phy_write(dev, B43_PHY_PWRDOWN, b);
-	b43_radio_write16(dev, 0x0004,
-		b43_radio_read16(dev, 0x0004) & 0xFFFB);
+	b43_radio_mask(dev, 0x0004, 0xFFFB);
 	b43_radio_write16(dev, 0x0013, best_s);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 0, 0xFFEC);
 	b43_phy_write(dev, B43_PHY_OFDM(0xB7), 0x1E80);
 	b43_phy_write(dev, B43_PHY_OFDM(0xB6), 0x1C00);
 	b43_phy_write(dev, B43_PHY_OFDM(0xB5), 0x0EC0);
 	b43_phy_write(dev, B43_PHY_OFDM(0xB2), 0x00C0);
Index: wireless-testing/drivers/net/wireless/b43/phy_g.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_g.c	2009-02-20 19:07:35.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_g.c	2009-02-20 19:08:40.000000000 +0100
@@ -486,14 +486,13 @@ static void b43_calc_nrssi_offset(struct
 			if (v47F < 31 && saved == 0xFFFF)
 				saved = i;
 		}
 		if (saved == 0xFFFF)
 			saved = 4;
 	} else {
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) & 0x007F);
+		b43_radio_mask(dev, 0x007A, 0x007F);
 		if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
 			b43_phy_set(dev, 0x0814, 0x0001);
 			b43_phy_mask(dev, 0x0815, 0xFFFE);
 		}
 		b43_phy_set(dev, 0x0811, 0x000C);
 		b43_phy_set(dev, 0x0812, 0x000C);
@@ -623,27 +622,25 @@ static void b43_calc_nrssi_slope(struct 
 		}
 		b43_phy_set(dev, 0x0060, 0x0040);
 		b43_phy_set(dev, 0x0014, 0x0200);
 	}
 	b43_radio_set(dev, 0x007A, 0x0070);
 	b43_set_all_gains(dev, 0, 8, 0);
-	b43_radio_write16(dev, 0x007A,
-			  b43_radio_read16(dev, 0x007A) & 0x00F7);
+	b43_radio_mask(dev, 0x007A, 0x00F7);
 	if (phy->rev >= 2) {
 		b43_phy_maskset(dev, 0x0811, 0xFFCF, 0x0030);
 		b43_phy_maskset(dev, 0x0812, 0xFFCF, 0x0010);
 	}
 	b43_radio_set(dev, 0x007A, 0x0080);
 	udelay(20);
 
 	nrssi0 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 	if (nrssi0 >= 0x0020)
 		nrssi0 -= 0x0040;
 
-	b43_radio_write16(dev, 0x007A,
-			  b43_radio_read16(dev, 0x007A) & 0x007F);
+	b43_radio_mask(dev, 0x007A, 0x007F);
 	if (phy->rev >= 2) {
 		b43_phy_maskset(dev, 0x0003, 0xFF9F, 0x0040);
 	}
 
 	b43_write16(dev, B43_MMIO_CHANNEL_EXT,
 		    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
@@ -1800,14 +1797,13 @@ static void b43_calc_loopback_gain(struc
 	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_EXTLNA) {
 		if (phy->rev >= 7) {
 			b43_phy_set(dev, B43_PHY_RFOVER, 0x0800);
 			b43_phy_set(dev, B43_PHY_RFOVERVAL, 0x8000);
 		}
 	}
-	b43_radio_write16(dev, 0x7A, b43_radio_read16(dev, 0x7A)
-			  & 0x00F7);
+	b43_radio_mask(dev, 0x7A, 0x00F7);
 
 	j = 0;
 	loop_i_max = (phy->radio_rev == 8) ? 15 : 9;
 	for (i = 0; i < loop_i_max; i++) {
 		for (j = 0; j < 16; j++) {
 			b43_radio_write16(dev, 0x43, i);
@@ -1989,15 +1985,13 @@ static void b43_phy_init_pctl(struct b43
 				       "adjustment.\n", gphy->cur_idle_tssi,
 				       gphy->tgt_idle_tssi);
 				gphy->cur_idle_tssi = 0;
 			}
 		}
 		if (phy->radio_ver == 0x2050 && phy->analog == 0) {
-			b43_radio_write16(dev, 0x0076,
-					  b43_radio_read16(dev, 0x0076)
-					  & 0xFF7B);
+			b43_radio_mask(dev, 0x0076, 0xFF7B);
 		} else {
 			b43_set_txpower_g(dev, &old_bbatt,
 					  &old_rfatt, old_tx_control);
 		}
 	}
 	b43_hardware_pctl_init_gphy(dev);

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Feb 20 20:10:23 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 20:10:23 +0100
Subject: [PATCH 0/6] b43: Use spatch to convert register accesses
In-Reply-To: <200902201854.22114.mb@bu3sch.de>
References: <200902201854.22114.mb@bu3sch.de>
Message-ID: <200902202010.23916.mb@bu3sch.de>

On Friday 20 February 2009 19:19:15 Michael Buesch wrote:
> Some time ago I rejected a bunch of patches that converted the
> PHY/radio register accesses to the new API. That was due to the patches
> being created manually. This introduces a huge potential to add new bugs.
> 
> However, this is an excellent task for coccinelle/spatch.
> So here's a series of patches, to convert the API usage, that were generated
> with spatch. This should keep the chances of breaking something as low as possible.
> 
> This reduces the .ko size by about 6 kiB.
> 
> The used semantic patches will be included in the patch headers.
> 
> John, please queue these patches for the next feature release.
> 

Hm, the patches didn't get through linux-wireless. Possibly due to their size.
You can find them here:

https://lists.berlios.de/pipermail/bcm43xx-dev/2009-February/008696.html
https://lists.berlios.de/pipermail/bcm43xx-dev/2009-February/008695.html
https://lists.berlios.de/pipermail/bcm43xx-dev/2009-February/008697.html
https://lists.berlios.de/pipermail/bcm43xx-dev/2009-February/008698.html
https://lists.berlios.de/pipermail/bcm43xx-dev/2009-February/008700.html
https://lists.berlios.de/pipermail/bcm43xx-dev/2009-February/008699.html

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Fri Feb 20 21:10:13 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 20 Feb 2009 14:10:13 -0600
Subject: [PATCH 0/6] b43: Use spatch to convert register accesses
In-Reply-To: <200902201854.22114.mb@bu3sch.de>
References: <200902201854.22114.mb@bu3sch.de>
Message-ID: <499F0E25.6030405@lwfinger.net>

Michael Buesch wrote:
> Some time ago I rejected a bunch of patches that converted the
> PHY/radio register accesses to the new API. That was due to the patches
> being created manually. This introduces a huge potential to add new bugs.
> 
> However, this is an excellent task for coccinelle/spatch.
> So here's a series of patches, to convert the API usage, that were generated
> with spatch. This should keep the chances of breaking something as low as possible.
> 
> This reduces the .ko size by about 6 kiB.
> 
> The used semantic patches will be included in the patch headers.
> 
> John, please queue these patches for the next feature release.

Michael,

With those patches applied on an x86_64 system, I get the following warnings:


============================
  CC [M]  drivers/net/wireless/b43/phy_a.o
drivers/net/wireless/b43/phy_g.c: In function
?b43_radio_interference_mitigation_enable?:
drivers/net/wireless/b43/phy_g.c:974: warning: large integer implicitly
truncated to unsigned type
  CC [M]  drivers/net/wireless/b43/wa.o
drivers/net/wireless/b43/wa.c: In function ?b43_wa_altagc?:
drivers/net/wireless/b43/wa.c:391: warning: large integer implicitly truncated
to unsigned type
drivers/net/wireless/b43/wa.c:409: warning: large integer implicitly truncated
to unsigned type
drivers/net/wireless/b43/wa.c:411: warning: large integer implicitly truncated
to unsigned type
drivers/net/wireless/b43/wa.c:421: warning: large integer implicitly truncated
to unsigned type
============================

All of these occur where there is a constant of the form ~0xYXXX with Y in the
range 8-F. To get rid of the warning, either use a u16 cast, or manually
complement the constant.

Larry


From mb at bu3sch.de  Fri Feb 20 21:12:44 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 20 Feb 2009 21:12:44 +0100
Subject: [PATCH 0/6] b43: Use spatch to convert register accesses
In-Reply-To: <499F0E25.6030405@lwfinger.net>
References: <200902201854.22114.mb@bu3sch.de> <499F0E25.6030405@lwfinger.net>
Message-ID: <200902202112.44885.mb@bu3sch.de>

On Friday 20 February 2009 21:10:13 Larry Finger wrote:
> Michael Buesch wrote:
> > Some time ago I rejected a bunch of patches that converted the
> > PHY/radio register accesses to the new API. That was due to the patches
> > being created manually. This introduces a huge potential to add new bugs.
> > 
> > However, this is an excellent task for coccinelle/spatch.
> > So here's a series of patches, to convert the API usage, that were generated
> > with spatch. This should keep the chances of breaking something as low as possible.
> > 
> > This reduces the .ko size by about 6 kiB.
> > 
> > The used semantic patches will be included in the patch headers.
> > 
> > John, please queue these patches for the next feature release.
> 
> Michael,
> 
> With those patches applied on an x86_64 system, I get the following warnings:
> 
> 
> ============================
>   CC [M]  drivers/net/wireless/b43/phy_a.o
> drivers/net/wireless/b43/phy_g.c: In function
> ?b43_radio_interference_mitigation_enable?:
> drivers/net/wireless/b43/phy_g.c:974: warning: large integer implicitly
> truncated to unsigned type
>   CC [M]  drivers/net/wireless/b43/wa.o
> drivers/net/wireless/b43/wa.c: In function ?b43_wa_altagc?:
> drivers/net/wireless/b43/wa.c:391: warning: large integer implicitly truncated
> to unsigned type
> drivers/net/wireless/b43/wa.c:409: warning: large integer implicitly truncated
> to unsigned type
> drivers/net/wireless/b43/wa.c:411: warning: large integer implicitly truncated
> to unsigned type
> drivers/net/wireless/b43/wa.c:421: warning: large integer implicitly truncated
> to unsigned type
> ============================
> 
> All of these occur where there is a constant of the form ~0xYXXX with Y in the
> range 8-F. To get rid of the warning, either use a u16 cast, or manually
> complement the constant.

Yes I know this. These warnings are harmless and I'll fix it in a separate patch.
These patches were supposed to be computer-generated to reduce the possibility of random breakage.


-- 
Greetings, Michael.


From mtcstle at yahoo.com  Sat Feb 21 05:20:40 2009
From: mtcstle at yahoo.com (John Mountcastle)
Date: Fri, 20 Feb 2009 20:20:40 -0800 (PST)
Subject: I need some help stabaizing b43 for a 4306
Message-ID: <785047.31485.qm@web65411.mail.ac4.yahoo.com>


I've got an HP pavilion ze4904us. This device has a Broadcom 4306 which worked perfectly under Suse 10.3 with the bcm43xx module. Under Suse 11.1 with b43, it loads the module starts the nic and works just fine for ten to twenty minutes. After that, the signal strength appears to deteriorate, disurbing messages begin to appear in dmesg, and finally the connection dies. Sometimes I can get it to come back by reactivateing the connection through NetworkManager, sometimes not.

I'm including uname, lspci, and dmesg, as suggested. Any help or advice is appreciated. I can't be the only person to have had this problem, the 4306 is not an uncommon device. Maybe it's already been fixed. Can someone point me at the latest stable, or even not so stable, code?

sybill:~ # uname -a
Linux sybill 2.6.27.7-9-default #1 SMP 2008-12-04 18:10:04 +0100 i686 i686 i386 GNU/Linux

sybill:~ # lspci -vvn |grep 43 -A7
02:06.0 0280: 14e4:4320 (rev 03)
    Subsystem: 103c:12f4
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx-
    Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- INTx-
    Latency: 64
    Interrupt: pin A routed to IRQ 11
    Region 0: Memory at e0200000 (32-bit, non-prefetchable) [size=8K]
    Kernel driver in use: b43-pci-bridge
    Kernel modules: ssb

sybill:~ # dmesg
Checking 'hlt' instruction... OK.
SMP alternatives: switching to UP code
Freeing SMP alternatives: 12k freed
ACPI: Core revision 20080609
ACPI: Checking initramfs for custom DSDT
Parsing all Control Methods:
Table [DSDT](id 0001) - 709 Objects with 58 Devices 210 Methods 16 Regions
Parsing all Control Methods:
Table [SSDT](id 0002) - 1 Objects with 0 Devices 1 Methods 0 Regions
 tbxface-0596 [00] tb_load_namespace     : ACPI Tables successfully acquired
ACPI: setting ELCR to 0200 (from 0c20)
evxfevnt-0091 [00] enable                : Transition to ACPI mode successful
weird, boot CPU (#0) not listedby the BIOS.
SMP motherboard not detected.
Local APIC not detected. Using dummy APIC emulation.
SMP disabled
Brought up 1 CPUs
Total of 1 processors activated (2597.78 BogoMIPS).
CPU0 attaching NULL sched-domain.
net_namespace: 1044 bytes
Booting paravirtualized kernel on bare hardware
NET: Registered protocol family 16
ACPI: bus type pci registered
PCI: PCI BIOS revision 2.10 entry at 0xfd9a2, last bus=2
PCI: Using configuration type 1 for base access
evgpeblk-0957 [00] ev_create_gpe_block   : GPE 00 to 1F [_GPE] 4 regs on int 0x9
ACPI: EC: Look up EC in DSDT
Completing Region/Field/Buffer/Package initialization:........................................................
Initialized 14/16 Regions 0/0 Fields 22/22 Buffers 20/20 Packages (719 nodes)
Initializing Device/Processor/Thermal objects by executing _INI methods:.
Executed 1 _INI methods requiring 0 _STA executions (examined 62 objects)
evgpeblk-1054 [00] ev_initialize_gpe_bloc: Found 5 Wake, Enabled 0 Runtime GPEs in this block
ACPI: Interpreter enabled
ACPI: (supports S0 S3 S4 S5)
ACPI: Using PIC for interrupt routing
ACPI: EC: non-query interrupt received, switching to interrupt mode
ACPI: EC: GPE = 0x1d, I/O: command/status = 0x66, data = 0x62
ACPI: EC: driver started in interrupt mode
ACPI: PCI Root Bridge [PCI0] (0000:00)
PCI: 0000:00:02.0 reg 10 32bit mmio: [e8000000, efffffff]
PCI: 0000:00:02.0 reg 14 32bit mmio: [e0000000, e007ffff]
PCI: 0000:00:02.0 reg 18 io port: [1800, 1807]
pci 0000:00:02.0: supports D1
PCI: 0000:00:02.1 reg 10 32bit mmio: [f0000000, f7ffffff]
PCI: 0000:00:02.1 reg 14 32bit mmio: [e0080000, e00fffff]
pci 0000:00:02.1: supports D1
PCI: 0000:00:1d.0 reg 20 io port: [1820, 183f]
PCI: 0000:00:1d.1 reg 20 io port: [1840, 185f]
PCI: 0000:00:1d.2 reg 20 io port: [1860, 187f]
PCI: 0000:00:1d.7 reg 10 32bit mmio: [e0100000, e01003ff]
pci 0000:00:1d.7: PME# supported from D0 D3hot D3cold
pci 0000:00:1d.7: PME# disabled
HPET not enabled in BIOS. You might try hpet=force boot option
pci 0000:00:1f.0: quirk: region 1000-107f claimed by ICH4 ACPI/GPIO/TCO
pci 0000:00:1f.0: quirk: region 1180-11bf claimed by ICH4 GPIO
PCI: 0000:00:1f.1 reg 10 io port: [0, 7]
PCI: 0000:00:1f.1 reg 14 io port: [0, 3]
PCI: 0000:00:1f.1 reg 18 io port: [0, 7]
PCI: 0000:00:1f.1 reg 1c io port: [0, 3]
PCI: 0000:00:1f.1 reg 20 io port: [1810, 181f]
PCI: 0000:00:1f.1 reg 24 32bit mmio: [0, 3ff]
PCI: 0000:00:1f.3 reg 20 io port: [1880, 189f]
PCI: 0000:00:1f.5 reg 10 io port: [1c00, 1cff]
PCI: 0000:00:1f.5 reg 14 io port: [18c0, 18ff]
PCI: 0000:00:1f.5 reg 18 32bit mmio: [e0100c00, e0100dff]
PCI: 0000:00:1f.5 reg 1c 32bit mmio: [e0100800, e01008ff]
pci 0000:00:1f.5: PME# supported from D0 D3hot D3cold
pci 0000:00:1f.5: PME# disabled
PCI: 0000:00:1f.6 reg 10 io port: [2400, 24ff]
PCI: 0000:00:1f.6 reg 14 io port: [2000, 207f]
pci 0000:00:1f.6: PME# supported from D0 D3hot D3cold
pci 0000:00:1f.6: PME# disabled
PCI: 0000:02:00.0 reg 10 io port: [3000, 30ff]
PCI: 0000:02:00.0 reg 14 32bit mmio: [e0202000, e02020ff]
pci 0000:02:00.0: supports D1
pci 0000:02:00.0: supports D2
pci 0000:02:00.0: PME# supported from D1 D2 D3hot D3cold
pci 0000:02:00.0: PME# disabled
PCI: 0000:02:05.0 reg 10 32bit mmio: [0, fff]
pci 0000:02:05.0: supports D1
pci 0000:02:05.0: supports D2
pci 0000:02:05.0: PME# supported from D0 D1 D2 D3hot D3cold
pci 0000:02:05.0: PME# disabled
PCI: 0000:02:06.0 reg 10 32bit mmio: [e0200000, e0201fff]
pci 0000:00:1e.0: transparent bridge
PCI: bridge 0000:00:1e.0 io port: [3000, 3fff]
PCI: bridge 0000:00:1e.0 32bit mmio: [e0200000, e02fffff]
bus 00 -> node 0
ACPI: PCI Interrupt Routing Table [\_SB_.PCI0._PRT]
ACPI: PCI Interrupt Routing Table [\_SB_.PCI0.PCIB._PRT]
ACPI: PCI Interrupt Link [LNKA] (IRQs *10)
ACPI: PCI Interrupt Link [LNKB] (IRQs *5)
ACPI: PCI Interrupt Link [LNKC] (IRQs *11)
ACPI: PCI Interrupt Link [LNKD] (IRQs *11)
ACPI: PCI Interrupt Link [LNKE] (IRQs 11) *0, disabled.
ACPI: PCI Interrupt Link [LNKF] (IRQs 11) *0, disabled.
ACPI: PCI Interrupt Link [LNKG] (IRQs 11) *0, disabled.
ACPI: PCI Interrupt Link [LNKH] (IRQs *11)
Linux Plug and Play Support v0.97 (c) Adam Belay
pnp: PnP ACPI init
ACPI: bus type pnp registered
pnp: PnP ACPI: found 7 devices
ACPI: ACPI bus type pnp unregistered
PnPBIOS: Disabled by ACPI PNP
PCI: Using ACPI for IRQ routing
AppArmor: AppArmor Filesystem Enabled
ACPI: RTC can wake from S4
system 00:04: ioport range 0x600-0x60f has been reserved
system 00:04: ioport range 0x800-0x80f has been reserved
system 00:04: ioport range 0x1000-0x107f has been reserved
system 00:04: ioport range 0x1180-0x11bf has been reserved
system 00:04: iomem range 0xfec10000-0xfec1ffff has been reserved
pci 0000:02:05.0: CardBus bridge, secondary bus 0000:03
pci 0000:02:05.0:   IO window: 0x003400-0x0034ff
pci 0000:02:05.0:   IO window: 0x003800-0x0038ff
pci 0000:02:05.0:   PREFETCH window: 0x50000000-0x53ffffff
pci 0000:02:05.0:   MEM window: 0x58000000-0x5bffffff
pci 0000:00:1e.0: PCI bridge, secondary bus 0000:02
pci 0000:00:1e.0:   IO window: 0x3000-0x3fff
pci 0000:00:1e.0:   MEM window: 0xe0200000-0xe02fffff
pci 0000:00:1e.0:   PREFETCH window: 0x00000050000000-0x00000053ffffff
pci 0000:00:1e.0: setting latency timer to 64
ACPI: PCI Interrupt Link [LNKE] enabled at IRQ 11
vendor=8086 device=2448
PCI: setting IRQ 11 as level-triggered
pci 0000:02:05.0: PCI INT A -> Link[LNKE] -> GSI 11 (level, low) -> IRQ 11
bus: 00 index 0 io port: [0, ffff]
bus: 00 index 1 mmio: [0, ffffffff]
bus: 02 index 0 io port: [3000, 3fff]
bus: 02 index 1 mmio: [e0200000, e02fffff]
bus: 02 index 2 mmio: [50000000, 53ffffff]
bus: 02 index 3 io port: [0, ffff]
bus: 02 index 4 mmio: [0, ffffffff]
bus: 03 index 0 io port: [3400, 34ff]
bus: 03 index 1 io port: [3800, 38ff]
bus: 03 index 2 mmio: [50000000, 53ffffff]
bus: 03 index 3 mmio: [58000000, 5bffffff]
NET: Registered protocol family 2
IP route cache hash table entries: 32768 (order: 5, 131072 bytes)
TCP established hash table entries: 131072 (order: 8, 1048576 bytes)
TCP bind hash table entries: 65536 (order: 7, 524288 bytes)
TCP: Hash tables configured (established 131072 bind 65536)
TCP reno registered
NET: Registered protocol family 1
Unpacking initramfs... done
Freeing initrd memory: 5713k freed
Simple Boot Flag at 0x36 set to 0x1
Machine check exception polling timer started.
audit: initializing netlink socket (disabled)
type=2000 audit(1235066728.772:1): initialized
highmem bounce pool size: 64 pages
HugeTLB registered 4 MB page size, pre-allocated 0 pages
VFS: Disk quotas dquot_6.5.1
Dquot-cache hash table entries: 1024 (order 0, 4096 bytes)
msgmni has been set to 440
Block layer SCSI generic (bsg) driver version 0.4 loaded (major 254)
io scheduler noop registered
io scheduler anticipatory registered
io scheduler deadline registered
io scheduler cfq registered (default)
pci 0000:00:02.0: Boot video device
vesafb: framebuffer at 0xe8000000, mapped to 0xf8880000, using 6144k, total 32576k
vesafb: mode is 1024x768x16, linelength=2048, pages=20
vesafb: scrolling: redraw
vesafb: Truecolor: size=0:5:6:5, shift=0:11:5:0
bootsplash 3.1.6-2004/03/31: looking for picture...
bootsplash: silentjpeg size 100719 bytes
bootsplash: ...found (1024x768, 38691 bytes, v3).
Console: switching to colour frame buffer device 124x44
Switched to high resolution mode on CPU 0
fb0: VESA VGA frame buffer device
isapnp: Scanning for PnP cards...
isapnp: No Plug & Play device found
Serial: 8250/16550 driver8 ports, IRQ sharing enabled
ACPI: PCI Interrupt Link [LNKB] enabled at IRQ 5
PCI: setting IRQ 5 as level-triggered
serial 0000:00:1f.6: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
serial 0000:00:1f.6: PCI INT B disabled
PNP: PS/2 Controller [PNP0303:PS2K,PNP0f13:PSM1] at 0x60,0x64 irq 1,12
serio: i8042 KBD port at 0x60,0x64 irq 1
serio: i8042 AUX port at 0x60,0x64 irq 12
mice: PS/2 mouse device common for all mice
cpuidle: using governor ladder
cpuidle: using governor menu
TCP cubic registered
Using IPI No-Shortcut mode
registered taskstats version 1
Freeing unused kernel memory: 316k freed
Write protecting the kernel text: 2344k
Write protecting the kernel read-only data: 1768k
input: AT Translated Set 2 keyboard as /devices/platform/i8042/serio0/input/input0
ACPI: CPU0 (power states: C1[C1] C2[C2])
processor ACPI_CPU:00: registered as cooling_device0
Marking TSC unstable due to TSC halts in idle
thermal LNXTHERM:01: registered as thermal_zone0
ACPI: Thermal Zone [THRM] (24 C)
ACPI: No dock devices found.
SCSI subsystem initialized
libata version 3.00 loaded.
ata_piix 0000:00:1f.1: version 2.12
ata_piix 0000:00:1f.1: enabling device (0005 -> 0007)
ACPI: PCI Interrupt Link [LNKC] enabled at IRQ 11
ata_piix 0000:00:1f.1: PCI INT A -> Link[LNKC] -> GSI 11 (level, low) -> IRQ 11
ata_piix 0000:00:1f.1: setting latency timer to 64
scsi0 : ata_piix
scsi1 : ata_piix
ata1: PATA max UDMA/100 cmd 0x1f0 ctl 0x3f6 bmdma 0x1810 irq 14
ata2: PATA max UDMA/100 cmd 0x170 ctl 0x376 bmdma 0x1818 irq 15
ata1: clearing spurious IRQ
ata1.00: ATA-8: TS32GSSD25-M, V0826, max UDMA/100
ata1.00: 62586880 sectors, multi 0: LBA 
ata1: clearing spurious IRQ
ata1: clearing spurious IRQ
ata1.00: configured for UDMA/100
ata2: clearing spurious IRQ
ata2.00: ATAPI: PHILIPS CD-RW/DVD-ROM CDD5263, UH89, max MWDMA2
ata2: clearing spurious IRQ
ata2: clearing spurious IRQ
ata2.00: configured for MWDMA2
scsi 0:0:0:0: Direct-Access     ATA      TS32GSSD25-M     V082 PQ: 0 ANSI: 5
scsi 1:0:0:0: CD-ROM            PHILIPS  CDRW/DVD CDD5263 UH89 PQ: 0 ANSI: 5
Uniform Multi-Platform E-IDE driver
BIOS EDD facility v0.16 2004-Jun-25, 1 devices found
Synaptics Touchpad, model: 1, fw: 5.9, id: 0x236eb3, caps: 0x904713/0x10008
udevd version 128 started
input: SynPS/2 Synaptics TouchPad as /devices/platform/i8042/serio1/input/input1
usbcore: registered new interface driver usbfs
usbcore: registered new interface driver hub
usbcore: registered new device driver usb
USB Universal Host Controller Interface driver v3.0
ACPI: PCI Interrupt Link [LNKA] enabled at IRQ 10
PCI: setting IRQ 10 as level-triggered
uhci_hcd 0000:00:1d.0: PCI INT A -> Link[LNKA] -> GSI 10 (level, low) -> IRQ 10
uhci_hcd 0000:00:1d.0: setting latency timer to 64
uhci_hcd 0000:00:1d.0: UHCI Host Controller
uhci_hcd 0000:00:1d.0: new USB bus registered, assigned bus number 1
uhci_hcd 0000:00:1d.0: irq 10, io base 0x00001820
usb usb1: configuration #1 chosen from 1 choice
hub 1-0:1.0: USB hub found
hub 1-0:1.0: 2 ports detected
Warning! ehci_hcd should always be loaded before uhci_hcd and ohci_hcd, not after
sd 0:0:0:0: [sda] 62586880 512-byte hardware sectors: (32.0GB/29.8GiB)
sd 0:0:0:0: [sda] Write Protect is off
sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn't support DPO or FUA
sd 0:0:0:0: [sda] 62586880 512-byte hardware sectors: (32.0GB/29.8GiB)
sd 0:0:0:0: [sda] Write Protect is off
sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn't support DPO or FUA
 sda: sda1 sda2 < sda5 sda6 sda7 >
sd 0:0:0:0: [sda] Attached SCSI disk
usb usb1: New USB device found, idVendor=1d6b, idProduct=0001
usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb1: Product: UHCI Host Controller
usb usb1: Manufacturer: Linux 2.6.27.7-9-default uhci_hcd
usb usb1: SerialNumber: 0000:00:1d.0
ACPI: PCI Interrupt Link [LNKD] enabled at IRQ 11
uhci_hcd 0000:00:1d.1: PCI INT B -> Link[LNKD] -> GSI 11 (level, low) -> IRQ 11
uhci_hcd 0000:00:1d.1: setting latency timer to 64
uhci_hcd 0000:00:1d.1: UHCI Host Controller
uhci_hcd 0000:00:1d.1: new USB bus registered, assigned bus number 2
uhci_hcd 0000:00:1d.1: irq 11, io base 0x00001840
usb usb2: configuration #1 chosen from 1 choice
hub 2-0:1.0: USB hub found
hub 2-0:1.0: 2 ports detected
usb usb2: New USB device found, idVendor=1d6b, idProduct=0001
usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb2: Product: UHCI Host Controller
usb usb2: Manufacturer: Linux 2.6.27.7-9-default uhci_hcd
usb usb2: SerialNumber: 0000:00:1d.1
uhci_hcd 0000:00:1d.2: PCI INT C -> Link[LNKC] -> GSI 11 (level, low) -> IRQ 11
uhci_hcd 0000:00:1d.2: setting latency timer to 64
uhci_hcd 0000:00:1d.2: UHCI Host Controller
uhci_hcd 0000:00:1d.2: new USB bus registered, assigned bus number 3
uhci_hcd 0000:00:1d.2: irq 11, io base 0x00001860
usb usb3: configuration #1 chosen from 1 choice
hub 3-0:1.0: USB hub found
hub 3-0:1.0: 2 ports detected
usb usb3: New USB device found, idVendor=1d6b, idProduct=0001
usb usb3: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb3: Product: UHCI Host Controller
usb usb3: Manufacturer: Linux 2.6.27.7-9-default uhci_hcd
usb usb3: SerialNumber: 0000:00:1d.2
ACPI: PCI Interrupt Link [LNKH] enabled at IRQ 11
ehci_hcd 0000:00:1d.7: PCI INT D -> Link[LNKH] -> GSI 11 (level, low) -> IRQ 11
ehci_hcd 0000:00:1d.7: setting latency timer to 64
ehci_hcd 0000:00:1d.7: EHCI Host Controller
ehci_hcd 0000:00:1d.7: new USB bus registered, assigned bus number 4
ehci_hcd 0000:00:1d.7: debug port 1
ehci_hcd 0000:00:1d.7: cache line size of 32 is not supported
ehci_hcd 0000:00:1d.7: irq 11, io mem 0xe0100000
ehci_hcd 0000:00:1d.7: USB 2.0 started, EHCI 1.00, driver 10 Dec 2004
usb usb4: configuration #1 chosen from 1 choice
hub 4-0:1.0: USB hub found
hub 4-0:1.0: 6 ports detected
usb usb4: New USB device found, idVendor=1d6b, idProduct=0002
usb usb4: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb4: Product: EHCI Host Controller
usb usb4: Manufacturer: Linux 2.6.27.7-9-default ehci_hcd
usb usb4: SerialNumber: 0000:00:1d.7
PM: Starting manual resume from disk
kjournald starting.  Commit interval 5 seconds
EXT3 FS on sda6, internal journal
EXT3-fs: mounted filesystem with ordered data mode.
udevd version 128 started
Linux agpgart interface v0.103
agpgart-intel 0000:00:00.0: Intel 855GM Chipset
agpgart-intel 0000:00:00.0: detected 32636K stolen memory
agpgart-intel 0000:00:00.0: AGP aperture is 128M @ 0xe8000000
input: Power Button (FF) as /devices/LNXSYSTM:00/LNXPWRBN:00/input/input2
ACPI: Power Button (FF) [PWRF]
input: Lid Switch as /devices/LNXSYSTM:00/device:00/PNP0C0D:00/input/input3
ACPI: Lid Switch [LID0]
input: Power Button (CM) as /devices/LNXSYSTM:00/device:00/PNP0C0C:00/input/input4
ACPI: Power Button (CM) [PWRB]
ACPI: AC Adapter [ACAD] (off-line)
ACPI: Battery Slot [BAT0] (battery present)
ACPI: WMI: Mapper loaded
acpi device:05: registered as cooling_device1
input: Video Bus as /devices/LNXSYSTM:00/device:00/PNP0A03:00/device:02/input/input5
ACPI: Video Device [GFX0] (multi-head: yes  rom: yes  post: no)
pci_hotplug: PCI Hot Plug PCI Core version: 0.5
shpchp: Standard Hot Plug PCI Controller Driver version: 0.4
intel_rng: FWH not detected
iTCO_vendor_support: vendor-support=0
iTCO_wdt: Intel TCO WatchDog Timer Driver v1.03 (30-Apr-2008)
iTCO_wdt: Found a ICH4-M TCO device (Version=1, TCOBASE=0x1060)
iTCO_wdt: initialized. heartbeat=30 sec (nowayout=0)
8139cp: 10/100 PCI Ethernet driver v1.3 (Mar 22, 2004)
8139cp 0000:02:00.0: This (id 10ec:8139 rev 10) is not an 8139C+ compatible chip
8139cp 0000:02:00.0: Try the "8139too" driver instead.
sd 0:0:0:0: Attached scsi generic sg0 type 0
scsi 1:0:0:0: Attached scsi generic sg1 type 5
Yenta: CardBus bridge found at 0000:02:05.0 [103c:3084]
Yenta: Using CSCINT to route CSC interrupts to PCI
Yenta: Routing CardBus interrupts to PCI
Yenta TI: socket 0000:02:05.0, mfunc 0x01111112, devctl 0x64
8139too Fast Ethernet driver 0.9.28
sr0: scsi3-mmc drive: 1x/24x writer cd/rw xa/form2 cdda tray
Uniform CD-ROM driver Revision: 3.20
sr 1:0:0:0: Attached scsi CD-ROM sr0
Yenta: ISA IRQ mask 0x00d8, PCI irq 11
Socket status: 30000006
Yenta: Raising subordinate bus# of parent bus (#02) from #02 to #06
pcmcia: parent PCI bridge I/O window: 0x3000 - 0x3fff
cs: IO port probe 0x3000-0x3fff: clean.
pcmcia: parent PCI bridge Memory window: 0xe0200000 - 0xe02fffff
pcmcia: parent PCI bridge Memory window: 0x50000000 - 0x53ffffff
input: PC Speaker as /devices/platform/pcspkr/input/input6
vendor=8086 device=2448
b43-pci-bridge 0000:02:06.0: PCI INT A -> Link[LNKC] -> GSI 11 (level, low) -> IRQ 11
ssb: Sonics Silicon Backplane found on PCI device 0000:02:06.0
i801_smbus 0000:00:1f.3: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
Intel ICH 0000:00:1f.5: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
Intel ICH 0000:00:1f.5: setting latency timer to 64
intel8x0_measure_ac97_clock: measured 53964 usecs
intel8x0: clocking to 48000
vendor=8086 device=2448
8139too 0000:02:00.0: PCI INT A -> Link[LNKA] -> GSI 10 (level, low) -> IRQ 10
eth0: RealTek RTL8139 at 0xf90de000, 00:c0:9f:51:32:d1, IRQ 10
eth0:  Identified 8139 chip type 'RTL-8100B/8139D'
Intel ICH Modem 0000:00:1f.6: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
Intel ICH Modem 0000:00:1f.6: setting latency timer to 64
rtc_cmos 00:01: rtc core: registered rtc_cmos as rtc0
rtc0: alarms up to one month, y3k
ALSA sound/pci/ac97/ac97_codec.c:2154: MC'97 0 converters and GPIO not ready (0x1)
cs: IO port probe 0x100-0x3af: clean.
cs: IO port probe 0x3e0-0x4ff: excluding 0x4d0-0x4d7
cs: IO port probe 0x820-0x8ff: clean.
cs: IO port probe 0xc00-0xcf7: clean.
cs: IO port probe 0xa00-0xaff: clean.
b43-phy0: Broadcom 4306 WLAN found
phy0: Selected rate control algorithm 'pid'
Broadcom 43xx driver loaded [ Features: PMLR, Firmware-ID: FW13 ]
Adding 1502004k swap on /dev/sda5.  Priority:-1 extents:1 across:1502004k
device-mapper: uevent: version 1.0.3
device-mapper: ioctl: 4.14.0-ioctl (2008-04-23) initialised: dm-devel at redhat.com
loop: module loaded
kjournald starting.  Commit interval 5 seconds
EXT3 FS on sda7, internal journal
EXT3-fs: mounted filesystem with ordered data mode.
fuse init (API version 7.9)
type=1505 audit(1235084738.541:2): operation="profile_load" name="/bin/ping" name2="default" pid=1609
type=1505 audit(1235084738.677:3): operation="profile_load" name="/sbin/klogd" name2="default" pid=1632
type=1505 audit(1235084738.925:4): operation="profile_load" name="/sbin/syslog-ng" name2="default" pid=1646
type=1505 audit(1235084739.165:5): operation="profile_load" name="/sbin/syslogd" name2="default" pid=1684
type=1505 audit(1235084739.401:6): operation="profile_load" name="/usr/sbin/avahi-daemon" name2="default" pid=1699
type=1505 audit(1235084739.593:7): operation="profile_load" name="/usr/sbin/identd" name2="default" pid=1714
type=1505 audit(1235084739.781:8): operation="profile_load" name="/usr/sbin/mdnsd" name2="default" pid=1731
type=1505 audit(1235084740.033:9): operation="profile_load" name="/usr/sbin/nscd" name2="default" pid=1745
type=1505 audit(1235084740.293:10): operation="profile_load" name="/usr/sbin/ntpd" name2="default" pid=1762
type=1505 audit(1235084740.433:11): operation="profile_load" name="/usr/sbin/traceroute" name2="default" pid=1766
powernow: This module only works with AMD K7 CPUs
NET: Registered protocol family 10
lo: Disabled Privacy Extensions
ip6_tables: (C) 2000-2006 Netfilter Core Team
ip_tables: (C) 2000-2006 Netfilter Core Team
nf_conntrack version 0.5.0 (16384 buckets, 65536 max)
CONFIG_NF_CT_ACCT is deprecated and will be removed soon. Plase use
nf_conntrack.acct=1 kernel paramater, acct=1 nf_conntrack module option or
sysctl net.netfilter.nf_conntrack_acct=1 to enable it.
IA-32 Microcode Update Driver: v1.14a <tigran at aivazian.fsnet.co.uk>
firmware: requesting intel-ucode/06-09-05
microcode: CPU0 updated from revision 0x45 to 0x47, date = 11092004 
[drm] Initialized drm 1.1.0 20060810
pci 0000:00:02.0: PCI INT A -> Link[LNKA] -> GSI 10 (level, low) -> IRQ 10
pci 0000:00:02.0: setting latency timer to 64
[drm] Initialized i915 1.6.0 20060119 on minor 0
pci 0000:00:02.1: setting latency timer to 64
[drm] Initialized i915 1.6.0 20060119 on minor 1
[drm:i915_getparam] *ERROR* Unknown parameter 5
[drm:i915_getparam] *ERROR* Unknown parameter 5
bootsplash: status on console 0 changed to on
eth0: link down
ADDRCONF(NETDEV_UP): eth0: link is not ready
input: b43-phy0 as /devices/virtual/input/input7
firmware: requesting b43/ucode5.fw
firmware: requesting b43/pcm5.fw
firmware: requesting b43/b0g0initvals5.fw
firmware: requesting b43/b0g0bsinitvals5.fw
b43-phy0: Loading firmware version 410.2160 (2007-05-26 15:32:10)
Registered led device: b43-phy0::tx
Registered led device: b43-phy0::rx
Registered led device: b43-phy0::radio
ADDRCONF(NETDEV_UP): wlan0: link is not ready
NET: Registered protocol family 17
wlan0: authenticate with AP 00:1c:10:c6:85:4b
wlan0: authenticated
wlan0: associate with AP 00:1c:10:c6:85:4b
wlan0: RX AssocResp from 00:1c:10:c6:85:4b (capab=0x401 status=0 aid=2)
wlan0: associated
wlan0: disassociating by local choice (reason=3)
wlan0: No ProbeResp from current AP 00:1c:10:c6:85:4b - assume out of range
[drm:i915_getparam] *ERROR* Unknown parameter 5
Bluetooth: Core ver 2.13
NET: Registered protocol family 31
Bluetooth: HCI device and connection manager initialized
Bluetooth: HCI socket layer initialized
Bluetooth: L2CAP ver 2.11
Bluetooth: L2CAP socket layer initialized
Bluetooth: RFCOMM socket layer initialized
Bluetooth: RFCOMM TTY layer initialized
Bluetooth: RFCOMM ver 1.10
Bluetooth: SCO (Voice Link) ver 0.6
Bluetooth: SCO socket layer initialized
Bluetooth: BNEP (Ethernet Emulation) ver 1.3
Bluetooth: BNEP filters: protocol multicast
Bridge firewalling registered
pan0: Dropping NETIF_F_UFO since no NETIF_F_HW_CSUM feature.
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=5)
wlan0: associated
ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=248 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=228 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
wlan0: no IPv6 routers present
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
b43-phy0 ERROR: PHY transmission error
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authentication with AP 00:30:44:02:76:d2 timed out
mtcstle at sybill:~/Desktop> 

Many thanks

John Mountcastle



From Larry.Finger at lwfinger.net  Sat Feb 21 19:53:47 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 21 Feb 2009 12:53:47 -0600
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
Message-ID: <49A04DBB.1030703@lwfinger.net>

John Mountcastle wrote:
> ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
> martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
> ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
> martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
> ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=248 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=228 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
> wlan0: no IPv6 routers present
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> b43-phy0 ERROR: PHY transmission error
> wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
> wlan0: authenticate with AP 00:30:44:02:76:d2
> wlan0: authenticate with AP 00:30:44:02:76:d2
> wlan0: authenticate with AP 00:30:44:02:76:d2
> wlan0: authenticate with AP 00:30:44:02:76:d2
> wlan0: authentication with AP 00:30:44:02:76:d2 timed out

You can get the latest code from compat-wireless
(http://linuxwireless.org/en/users/Download).

I don't see any "disturbing" messages in your log. The martian source lines
arise because you have IPV6 enabled. The DROP-DEFLT messages come from your
firewall. An occasional PHY transmission error can be ignored.

Larry



From mtcstle at yahoo.com  Sat Feb 21 20:17:53 2009
From: mtcstle at yahoo.com (John Mountcastle)
Date: Sat, 21 Feb 2009 11:17:53 -0800 (PST)
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <49A04DBB.1030703@lwfinger.net>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<49A04DBB.1030703@lwfinger.net>
Message-ID: <742759.94826.qm@web65415.mail.ac4.yahoo.com>


Thanks Larry, what about the part right there at the endwher it says assume out of range when nothing has moved. It's like the receeption begins to drop of until it can no longer support the connection.

SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
b43-phy0 ERROR: PHY transmission error
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authentication with AP 00:30:44:02:76:d2 timed out
mtcstle at sybill:~/Desktop> 

That shows up right before the link drops?

You know, it has occurred to me that it might not be b43 that's causing the problem. It might be the firmware.
On a whim, I tried to cut firmware out of bcmwl5.sys, the driver that has always worked with this device and b43-fwcutter wouldn't cut it. As I remember, the version that worked with bcm43xx had about a dozen firmwares it would use, the new one only has about four. What do you suppose might happen if I massaged teh code for bw43-fwcutter to accept teh firmware I want to use?

Regards

John



----- Original Message ----
From: Larry Finger <Larry.Finger at lwfinger.net>
To: John Mountcastle <mtcstle at yahoo.com>
Cc: bcm43xx-dev at lists.berlios.de
Sent: Saturday, February 21, 2009 1:53:47 PM
Subject: Re: I need some help stabaizing b43 for a 4306nks 

John Mountcastle wrote:
> ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
> martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
> ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
> martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
> ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=248 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=228 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
> wlan0: no IPv6 routers present
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.189 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
> b43-phy0 ERROR: PHY transmission error
> wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
> wlan0: authenticate with AP 00:30:44:02:76:d2
> wlan0: authenticate with AP 00:30:44:02:76:d2
> wlan0: authenticate with AP 00:30:44:02:76:d2
> wlan0: authenticate with AP 00:30:44:02:76:d2
> wlan0: authentication with AP 00:30:44:02:76:d2 timed out

You can get the latest code from compat-wireless
(http://linuxwireless.org/en/users/Download).

I don't see any "disturbing" messages in your log. The martian source lines
arise because you have IPV6 enabled. The DROP-DEFLT messages come from your
firewall. An occasional PHY transmission error can be ignored.

Larry


From Larry.Finger at lwfinger.net  Sat Feb 21 20:33:12 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 21 Feb 2009 13:33:12 -0600
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <742759.94826.qm@web65415.mail.ac4.yahoo.com>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<49A04DBB.1030703@lwfinger.net>
	<742759.94826.qm@web65415.mail.ac4.yahoo.com>
Message-ID: <49A056F8.90609@lwfinger.net>

The latest versions of mac80211 are better at recovering from loss of contact
with the AP. You would get the latest with compat-wireless.

As to getting firmware from bcmwl5.sys, I doubt that it would make a difference.

From mb at bu3sch.de  Sat Feb 21 20:40:45 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 21 Feb 2009 20:40:45 +0100
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <742759.94826.qm@web65415.mail.ac4.yahoo.com>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<49A04DBB.1030703@lwfinger.net>
	<742759.94826.qm@web65415.mail.ac4.yahoo.com>
Message-ID: <200902212040.45689.mb@bu3sch.de>

On Saturday 21 February 2009 20:17:53 John Mountcastle wrote:
> 
> Thanks Larry, what about the part right there at the endwher it says assume out of range when nothing has moved. It's like the receeption begins to drop of until it can no longer support the connection.

Please turn on b43 debugging in the kernel config, mount debugfs to /sys/kernel/debug
and enable xmit debugging with this knob:
echo 1 > /sys/kernel/debug/b43/phy*/debug_xmitpower

Then see if the kernel tells you something interesting.

-- 
Greetings, Michael.


From francesco.gringoli at ing.unibs.it  Sun Feb 22 13:22:10 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Sun, 22 Feb 2009 13:22:10 +0100
Subject: Capturing FCS error frames using b43 driver
In-Reply-To: <200902172354.32152.mb@bu3sch.de>
References: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>
	<200902172354.32152.mb@bu3sch.de>
Message-ID: <F82A7401-1B9B-4848-830F-3DC36A158C82@ing.unibs.it>

On Feb 17, 2009, at 11:54 PM, Michael Buesch wrote:

> Please read the code. There are lots of sanity checks in b43 and  
> mac80211
> that make it impossible to receive completely corrupted frames.
I reconsidered this message because I too did some tests in capturing  
frames with proprietary firmware. As Bo said, we can capture corrupted  
frames with R351 but we can't with R410. The reason is that this  
firmware seems to not even check whether or not bit  
B43_MACCTL_KEEP_BAD is set so I believe no kernel patch could correct  
this problem, because it is on the firmware side.

Cheers,
-FG


>
>
> On Tuesday 17 February 2009 23:05:51 Bo Han wrote:
>> Hi,
>>
>> I am interested in capturing FCS error frames using b43 driver.  My  
>> hardware
>> information is as follows.
>>
>> b43-phy9: Broadcom 4318 WLAN found
>> b43-phy9 debug: Found PHY: Analog 3, Type 2, Revision 7
>> b43-phy9 debuf: Found Radio: Manuf 0x17f, Version 0x2050, Revision 8
>>
>> I am using firmware version 410.2160 with linux kernel version  
>> 2.6.27.10.  I
>> told the firmware to keep the bad frames by setting ctl |=
>> B43_MACCTL_KEEP_BAD just before b43_write32(dev, b43_MMIO_MACCTL,  
>> ctl) in
>> b43_adjust_mode(...) in main.c.
>> From b43_rx(...) in xmit.c, I can only see packets dropped because  
>> their
>> rate_idx == -1.  The length of all the dropped packets is 80 bytes  
>> and they
>> look like the following:
>>
>> 8fae 0308 0000 0b01 0085 0000 1500 482c
>> 50b3 0b01 0085 0000 5fa0 1500 482c 50b3
>> aaaa 0003 850b cdcc 1b00 1d00 b945 c0cd
>> b905 630a 5e10 0101 0601 0b06 000b 07d6
>> bab9 addb 35fd 33e8 cd8f 8eaa 6f77 b9e8
>>
>> However, there is still no packet received with macstat  
>> B43_RX_MAC_FCSERR.
>> I also tried the 351 firmware for which I saw several FCS error  
>> frames in
>> PIO mode.  But the sniffing tools like Wireshark cannot get any  
>> packets.
>> including the correct ones, when using that firmware.
>>
>> Am I missing something?
>>
>> Thanks,
>> -Bo
>>
>
>
>
> -- 
> Greetings, Michael.
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev

-------

Francesco Gringoli, PhD - Assistant Professor
Dept. of Electrical Engineering for Automation
University of Brescia
via Branze, 38
25123 Brescia
ITALY

Ph:  ++39.030.3715843
FAX: ++39.030.380014
WWW: http://www.ing.unibs.it/~gringoli






From netrolller.3d at gmail.com  Sun Feb 22 14:42:41 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Sun, 22 Feb 2009 14:42:41 +0100
Subject: Capturing FCS error frames using b43 driver
In-Reply-To: <F82A7401-1B9B-4848-830F-3DC36A158C82@ing.unibs.it>
References: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>
	<200902172354.32152.mb@bu3sch.de>
	<F82A7401-1B9B-4848-830F-3DC36A158C82@ing.unibs.it>
Message-ID: <69e28c910902220542j2e20c5d9p8f51f13b6a0034a4@mail.gmail.com>

On Sun, Feb 22, 2009 at 1:22 PM, Francesco Gringoli
<francesco.gringoli at ing.unibs.it> wrote:
> On Feb 17, 2009, at 11:54 PM, Michael Buesch wrote:
>
>> Please read the code. There are lots of sanity checks in b43 and
>> mac80211
>> that make it impossible to receive completely corrupted frames.
> I reconsidered this message because I too did some tests in capturing
> frames with proprietary firmware. As Bo said, we can capture corrupted
> frames with R351 but we can't with R410. The reason is that this
> firmware seems to not even check whether or not bit
> B43_MACCTL_KEEP_BAD is set so I believe no kernel patch could correct
> this problem, because it is on the firmware side.
>
> Cheers,
> -FG
>

Does OpenFWWF or Michael's openfw honor KEEP_BAD?

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From francesco.gringoli at ing.unibs.it  Sun Feb 22 15:14:41 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Sun, 22 Feb 2009 15:14:41 +0100
Subject: Capturing FCS error frames using b43 driver
In-Reply-To: <69e28c910902220542j2e20c5d9p8f51f13b6a0034a4@mail.gmail.com>
References: <d0ad1e930902171405i1257927aw3ab3bd5070a8f838@mail.gmail.com>
	<200902172354.32152.mb@bu3sch.de>
	<F82A7401-1B9B-4848-830F-3DC36A158C82@ing.unibs.it>
	<69e28c910902220542j2e20c5d9p8f51f13b6a0034a4@mail.gmail.com>
Message-ID: <28B287E6-C039-445C-B593-945BEDCC5385@ing.unibs.it>


On Feb 22, 2009, at 2:42 PM, G?bor Stefanik wrote:

> On Sun, Feb 22, 2009 at 1:22 PM, Francesco Gringoli
> <francesco.gringoli at ing.unibs.it> wrote:
>> On Feb 17, 2009, at 11:54 PM, Michael Buesch wrote:
>>
>>> Please read the code. There are lots of sanity checks in b43 and
>>> mac80211
>>> that make it impossible to receive completely corrupted frames.
>> I reconsidered this message because I too did some tests in capturing
>> frames with proprietary firmware. As Bo said, we can capture  
>> corrupted
>> frames with R351 but we can't with R410. The reason is that this
>> firmware seems to not even check whether or not bit
>> B43_MACCTL_KEEP_BAD is set so I believe no kernel patch could correct
>> this problem, because it is on the firmware side.
>>
>> Cheers,
>> -FG
>>
>
> Does OpenFWWF or Michael's openfw honor KEEP_BAD?
openfwwf does honor the bit.

Cheers,
-FG

>
>
> -- 
> Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)

-------

Francesco Gringoli, PhD - Assistant Professor
Dept. of Electrical Engineering for Automation
University of Brescia
via Branze, 38
25123 Brescia
ITALY

Ph:  ++39.030.3715843
FAX: ++39.030.380014
WWW: http://www.ing.unibs.it/~gringoli






From mtcstle at yahoo.com  Sun Feb 22 21:45:44 2009
From: mtcstle at yahoo.com (John Mountcastle)
Date: Sun, 22 Feb 2009 12:45:44 -0800 (PST)
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <200902212040.45689.mb@bu3sch.de>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<49A04DBB.1030703@lwfinger.net>
	<742759.94826.qm@web65415.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
Message-ID: <27179.70560.qm@web65414.mail.ac4.yahoo.com>


Michael, configuring a new kernel was a real blast from the past. I haven't  done that in several years but I think I got it done. Funny thing, when I booted the debug kernel, the interface was rock solid for almost an hour, not one single error, then it went sour again. I switched on br43 debugging as you suggested, about half way through the capture. You can see the Tx-mit power messages start. About 60% into the capture I unloaded b43 (rmmod/insmod) and reloaded it in order to get the interface to come back up.

I hope you can tell me something about what if anything this capture tells us? Or, the net step in debuggging

All the best

John
.
Initializing cgroup subsys cpuset
Initializing cgroup subsys cpu
Linux version 2.6.27.7-9-default (geeko at buildhost) (gcc version 4.3.2 [gcc-4_3-branch revision 141291] (SUSE Linux) ) #1 SMP Sun Feb 22 04:09:53 EST 2009
PAT WC disabled due to known CPU erratum.
BIOS-provided physical RAM map:
 BIOS-e820: 0000000000000000 - 000000000009f800 (usable)
 BIOS-e820: 000000000009f800 - 00000000000a0000 (reserved)
 BIOS-e820: 00000000000ce000 - 00000000000d0000 (reserved)
 BIOS-e820: 00000000000dc000 - 0000000000100000 (reserved)
 BIOS-e820: 0000000000100000 - 000000003dee0000 (usable)
 BIOS-e820: 000000003dee0000 - 000000003deec000 (ACPI data)
 BIOS-e820: 000000003deec000 - 000000003df00000 (ACPI NVS)
 BIOS-e820: 000000003df00000 - 0000000040000000 (reserved)
 BIOS-e820: 00000000ff800000 - 00000000ffc00000 (reserved)
 BIOS-e820: 00000000fffffc00 - 0000000100000000 (reserved)
DMI present.
last_pfn = 0x3dee0 max_arch_pfn = 0x100000
kernel direct mapping tables up to 38000000 @ 7000-c000
RAMDISK: 37515000 - 37fefa13
ACPI: RSDP 000F6560, 0014 (r0 HP    )
ACPI: RSDT 3DEE674D, 0030 (r1 HP     3084      6040000  LTP        0)
ACPI: FACP 3DEEBED2, 0074 (r1 HP     3084      6040000 PTL        50)
ACPI: DSDT 3DEE6C96, 523C (r1 HP     3084      6040000 MSFT  100000E)
ACPI: FACS 3DEFCFC0, 0040
ACPI: BOOT 3DEEBFD8, 0028 (r1 HP     3084      6040000  LTP        1)
ACPI: SSDT 3DEE6B84, 010A (r1 HP     3084            1 INTL 20030224)
ACPI: DMI detected: Hewlett-Packard
94MB HIGHMEM available.
896MB LOWMEM available.
  mapped low ram: 0 - 38000000
  low ram: 00000000 - 38000000
  bootmap 00009000 - 00010000
(9 early reservations) ==> bootmem [0000000000 - 0038000000]
  #0 [0000000000 - 0000001000]   BIOS data page ==> [0000000000 - 0000001000]
  #1 [0000001000 - 0000002000]    EX TRAMPOLINE ==> [0000001000 - 0000002000]
  #2 [0000006000 - 0000007000]       TRAMPOLINE ==> [0000006000 - 0000007000]
  #3 [0000100000 - 00006449dc]    TEXT DATA BSS ==> [0000100000 - 00006449dc]
  #4 [0037515000 - 0037fefa13]          RAMDISK ==> [0037515000 - 0037fefa13]
  #5 [0000645000 - 0000648000]    INIT_PG_TABLE ==> [0000645000 - 0000648000]
  #6 [000009f800 - 0000100000]    BIOS reserved ==> [000009f800 - 0000100000]
  #7 [0000007000 - 0000009000]          PGTABLE ==> [0000007000 - 0000009000]
  #8 [0000009000 - 0000010000]          BOOTMAP ==> [0000009000 - 0000010000]
Zone PFN ranges:
  DMA      0x00000000 -> 0x00001000
  Normal   0x00001000 -> 0x00038000
  HighMem  0x00038000 -> 0x0003dee0
Movable zone start PFN for each node
early_node_map[2] active PFN ranges
    0: 0x00000000 -> 0x0000009f
    0: 0x00000100 -> 0x0003dee0
On node 0 totalpages: 253567
free_area_init_node: node 0, pgdat c0512c00, node_mem_map c1000000
  DMA zone: 3963 pages, LIFO batch:0
  Normal zone: 223300 pages, LIFO batch:31
  HighMem zone: 24074 pages, LIFO batch:3
Using APIC driver default
ACPI: PM-Timer IO Port: 0x1008
SMP: Allowing 1 CPUs, 0 hotplug CPUs
Local APIC disabled by BIOS -- you can enable it with "lapic"
mapped APIC to ffffb000 (018bc000)
PM: Registered nosave memory: 000000000009f000 - 00000000000a0000
PM: Registered nosave memory: 00000000000a0000 - 00000000000ce000
PM: Registered nosave memory: 00000000000ce000 - 00000000000d0000
PM: Registered nosave memory: 00000000000d0000 - 00000000000dc000
PM: Registered nosave memory: 00000000000dc000 - 0000000000100000
Allocating PCI resources starting at 50000000 (gap: 40000000:bf800000)
PERCPU: Allocating 39068 bytes of per cpu data
NR_CPUS: 32, nr_cpu_ids: 1, nr_node_ids 1
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 251337
Kernel command line: root=/dev/disk/by-id/ata-TS32GSSD25-M_00229828003E-part6 resume=/dev/disk/by-id/ata-TS32GSSD25-M_00229828003E-part5 splash=silent vga=0x317
bootsplash: silent mode.
Enabling fast FPU save and restore... done.
Enabling unmasked SIMD FPU exception support... done.
Initializing CPU#0
PID hash table entries: 4096 (order: 12, 16384 bytes)
TSC: PIT calibration confirmed by PMTIMER.
TSC: using PIT calibration value
Detected 1298.892 MHz processor.
Console: colour dummy device 80x25
console [tty0] enabled
Dentry cache hash table entries: 131072 (order: 7, 524288 bytes)
Inode-cache hash table entries: 65536 (order: 6, 262144 bytes)
Memory: 987640k/1014656k available (2334k kernel code, 26340k reserved, 1920k data, 316k init, 97152k highmem)
virtual kernel memory layout:
    fixmap  : 0xffdf6000 - 0xfffff000   (2084 kB)
    pkmap   : 0xff400000 - 0xff800000   (4096 kB)
    vmalloc : 0xf8800000 - 0xff3fe000   ( 107 MB)
    lowmem  : 0xc0000000 - 0xf8000000   ( 896 MB)
      .init : 0xc052e000 - 0xc057d000   ( 316 kB)
      .data : 0xc034785b - 0xc0527a90   (1920 kB)
      .text : 0xc0100000 - 0xc034785b   (2334 kB)
Checking if this processor honours the WP bit even in supervisor mode...Ok.
CPA: page pool initialized 1 of 1 pages preallocated
Calibrating delay loop (skipped), value calculated using timer frequency.. 2597.78 BogoMIPS (lpj=5195568)
kdb version 4.4 by Keith Owens, Scott Lurndal. Copyright SGI, All Rights Reserved
Security Framework initialized
SELinux:  Disabled at boot.
AppArmor: AppArmor initialized
Mount-cache hash table entries: 512
Initializing cgroup subsys ns
Initializing cgroup subsys cpuacct
Initializing cgroup subsys memory
Initializing cgroup subsys devices
Initializing cgroup subsys freezer
CPU: L1 I cache: 32K, L1 D cache: 32K
CPU: L2 cache: 512K
Intel machine check architecture supported.
Intel machine check reporting enabled on CPU#0.
Checking 'hlt' instruction... OK.
SMP alternatives: switching to UP code
Freeing SMP alternatives: 12k freed
ACPI: Core revision 20080609
ACPI: Checking initramfs for custom DSDT
Parsing all Control Methods:
Table [DSDT](id 0001) - 709 Objects with 58 Devices 210 Methods 16 Regions
Parsing all Control Methods:
Table [SSDT](id 0002) - 1 Objects with 0 Devices 1 Methods 0 Regions
 tbxface-0596 [00] tb_load_namespace     : ACPI Tables successfully acquired
ACPI: setting ELCR to 0200 (from 0c20)
evxfevnt-0091 [00] enable                : Transition to ACPI mode successful
weird, boot CPU (#0) not listedby the BIOS.
SMP motherboard not detected.
Local APIC not detected. Using dummy APIC emulation.
SMP disabled
Brought up 1 CPUs
Total of 1 processors activated (2597.78 BogoMIPS).
CPU0 attaching NULL sched-domain.
net_namespace: 1044 bytes
Booting paravirtualized kernel on bare hardware
NET: Registered protocol family 16
ACPI: bus type pci registered
PCI: PCI BIOS revision 2.10 entry at 0xfd9a2, last bus=2
PCI: Using configuration type 1 for base access
evgpeblk-0957 [00] ev_create_gpe_block   : GPE 00 to 1F [_GPE] 4 regs on int 0x9
ACPI: EC: Look up EC in DSDT
Completing Region/Field/Buffer/Package initialization:........................................................
Initialized 14/16 Regions 0/0 Fields 22/22 Buffers 20/20 Packages (719 nodes)
Initializing Device/Processor/Thermal objects by executing _INI methods:.
Executed 1 _INI methods requiring 0 _STA executions (examined 62 objects)
evgpeblk-1054 [00] ev_initialize_gpe_bloc: Found 5 Wake, Enabled 0 Runtime GPEs in this block
ACPI: Interpreter enabled
ACPI: (supports S0 S3 S4 S5)
ACPI: Using PIC for interrupt routing
ACPI: EC: non-query interrupt received, switching to interrupt mode
ACPI: EC: GPE = 0x1d, I/O: command/status = 0x66, data = 0x62
ACPI: EC: driver started in interrupt mode
ACPI: PCI Root Bridge [PCI0] (0000:00)
PCI: 0000:00:02.0 reg 10 32bit mmio: [e8000000, efffffff]
PCI: 0000:00:02.0 reg 14 32bit mmio: [e0000000, e007ffff]
PCI: 0000:00:02.0 reg 18 io port: [1800, 1807]
pci 0000:00:02.0: supports D1
PCI: 0000:00:02.1 reg 10 32bit mmio: [f0000000, f7ffffff]
PCI: 0000:00:02.1 reg 14 32bit mmio: [e0080000, e00fffff]
pci 0000:00:02.1: supports D1
PCI: 0000:00:1d.0 reg 20 io port: [1820, 183f]
PCI: 0000:00:1d.1 reg 20 io port: [1840, 185f]
PCI: 0000:00:1d.2 reg 20 io port: [1860, 187f]
PCI: 0000:00:1d.7 reg 10 32bit mmio: [e0100000, e01003ff]
pci 0000:00:1d.7: PME# supported from D0 D3hot D3cold
pci 0000:00:1d.7: PME# disabled
HPET not enabled in BIOS. You might try hpet=force boot option
pci 0000:00:1f.0: quirk: region 1000-107f claimed by ICH4 ACPI/GPIO/TCO
pci 0000:00:1f.0: quirk: region 1180-11bf claimed by ICH4 GPIO
PCI: 0000:00:1f.1 reg 10 io port: [0, 7]
PCI: 0000:00:1f.1 reg 14 io port: [0, 3]
PCI: 0000:00:1f.1 reg 18 io port: [0, 7]
PCI: 0000:00:1f.1 reg 1c io port: [0, 3]
PCI: 0000:00:1f.1 reg 20 io port: [1810, 181f]
PCI: 0000:00:1f.1 reg 24 32bit mmio: [0, 3ff]
PCI: 0000:00:1f.3 reg 20 io port: [1880, 189f]
PCI: 0000:00:1f.5 reg 10 io port: [1c00, 1cff]
PCI: 0000:00:1f.5 reg 14 io port: [18c0, 18ff]
PCI: 0000:00:1f.5 reg 18 32bit mmio: [e0100c00, e0100dff]
PCI: 0000:00:1f.5 reg 1c 32bit mmio: [e0100800, e01008ff]
pci 0000:00:1f.5: PME# supported from D0 D3hot D3cold
pci 0000:00:1f.5: PME# disabled
PCI: 0000:00:1f.6 reg 10 io port: [2400, 24ff]
PCI: 0000:00:1f.6 reg 14 io port: [2000, 207f]
pci 0000:00:1f.6: PME# supported from D0 D3hot D3cold
pci 0000:00:1f.6: PME# disabled
PCI: 0000:02:00.0 reg 10 io port: [3000, 30ff]
PCI: 0000:02:00.0 reg 14 32bit mmio: [e0202000, e02020ff]
pci 0000:02:00.0: supports D1
pci 0000:02:00.0: supports D2
pci 0000:02:00.0: PME# supported from D1 D2 D3hot D3cold
pci 0000:02:00.0: PME# disabled
PCI: 0000:02:05.0 reg 10 32bit mmio: [0, fff]
pci 0000:02:05.0: supports D1
pci 0000:02:05.0: supports D2
pci 0000:02:05.0: PME# supported from D0 D1 D2 D3hot D3cold
pci 0000:02:05.0: PME# disabled
PCI: 0000:02:06.0 reg 10 32bit mmio: [e0200000, e0201fff]
pci 0000:00:1e.0: transparent bridge
PCI: bridge 0000:00:1e.0 io port: [3000, 3fff]
PCI: bridge 0000:00:1e.0 32bit mmio: [e0200000, e02fffff]
bus 00 -> node 0
ACPI: PCI Interrupt Routing Table [\_SB_.PCI0._PRT]
ACPI: PCI Interrupt Routing Table [\_SB_.PCI0.PCIB._PRT]
ACPI: PCI Interrupt Link [LNKA] (IRQs *10)
ACPI: PCI Interrupt Link [LNKB] (IRQs *5)
ACPI: PCI Interrupt Link [LNKC] (IRQs *11)
ACPI: PCI Interrupt Link [LNKD] (IRQs *11)
ACPI: PCI Interrupt Link [LNKE] (IRQs 11) *0, disabled.
ACPI: PCI Interrupt Link [LNKF] (IRQs 11) *0, disabled.
ACPI: PCI Interrupt Link [LNKG] (IRQs 11) *0, disabled.
ACPI: PCI Interrupt Link [LNKH] (IRQs *11)
Linux Plug and Play Support v0.97 (c) Adam Belay
pnp: PnP ACPI init
ACPI: bus type pnp registered
pnp: PnP ACPI: found 7 devices
ACPI: ACPI bus type pnp unregistered
PnPBIOS: Disabled by ACPI PNP
PCI: Using ACPI for IRQ routing
AppArmor: AppArmor Filesystem Enabled
ACPI: RTC can wake from S4
system 00:04: ioport range 0x600-0x60f has been reserved
system 00:04: ioport range 0x800-0x80f has been reserved
system 00:04: ioport range 0x1000-0x107f has been reserved
system 00:04: ioport range 0x1180-0x11bf has been reserved
system 00:04: iomem range 0xfec10000-0xfec1ffff has been reserved
pci 0000:02:05.0: CardBus bridge, secondary bus 0000:03
pci 0000:02:05.0:   IO window: 0x003400-0x0034ff
pci 0000:02:05.0:   IO window: 0x003800-0x0038ff
pci 0000:02:05.0:   PREFETCH window: 0x50000000-0x53ffffff
pci 0000:02:05.0:   MEM window: 0x58000000-0x5bffffff
pci 0000:00:1e.0: PCI bridge, secondary bus 0000:02
pci 0000:00:1e.0:   IO window: 0x3000-0x3fff
pci 0000:00:1e.0:   MEM window: 0xe0200000-0xe02fffff
pci 0000:00:1e.0:   PREFETCH window: 0x00000050000000-0x00000053ffffff
pci 0000:00:1e.0: setting latency timer to 64
ACPI: PCI Interrupt Link [LNKE] enabled at IRQ 11
vendor=8086 device=2448
PCI: setting IRQ 11 as level-triggered
pci 0000:02:05.0: PCI INT A -> Link[LNKE] -> GSI 11 (level, low) -> IRQ 11
bus: 00 index 0 io port: [0, ffff]
bus: 00 index 1 mmio: [0, ffffffff]
bus: 02 index 0 io port: [3000, 3fff]
bus: 02 index 1 mmio: [e0200000, e02fffff]
bus: 02 index 2 mmio: [50000000, 53ffffff]
bus: 02 index 3 io port: [0, ffff]
bus: 02 index 4 mmio: [0, ffffffff]
bus: 03 index 0 io port: [3400, 34ff]
bus: 03 index 1 io port: [3800, 38ff]
bus: 03 index 2 mmio: [50000000, 53ffffff]
bus: 03 index 3 mmio: [58000000, 5bffffff]
NET: Registered protocol family 2
IP route cache hash table entries: 32768 (order: 5, 131072 bytes)
TCP established hash table entries: 131072 (order: 8, 1048576 bytes)
TCP bind hash table entries: 65536 (order: 7, 524288 bytes)
TCP: Hash tables configured (established 131072 bind 65536)
TCP reno registered
NET: Registered protocol family 1
Unpacking initramfs...<7>Switched to high resolution mode on CPU 0
 done
Freeing initrd memory: 11114k freed
Simple Boot Flag at 0x36 set to 0x1
Machine check exception polling timer started.
audit: initializing netlink socket (disabled)
type=2000 audit(1235296501.524:1): initialized
highmem bounce pool size: 64 pages
HugeTLB registered 4 MB page size, pre-allocated 0 pages
VFS: Disk quotas dquot_6.5.1
Dquot-cache hash table entries: 1024 (order 0, 4096 bytes)
msgmni has been set to 440
Block layer SCSI generic (bsg) driver version 0.4 loaded (major 254)
io scheduler noop registered
io scheduler anticipatory registered
io scheduler deadline registered
io scheduler cfq registered (default)
pci 0000:00:02.0: Boot video device
vesafb: framebuffer at 0xe8000000, mapped to 0xf8880000, using 6144k, total 32576k
vesafb: mode is 1024x768x16, linelength=2048, pages=20
vesafb: scrolling: redraw
vesafb: Truecolor: size=0:5:6:5, shift=0:11:5:0
bootsplash 3.1.6-2004/03/31: looking for picture...
bootsplash: silentjpeg size 100719 bytes
bootsplash: ...found (1024x768, 38691 bytes, v3).
Console: switching to colour frame buffer device 124x44
fb0: VESA VGA frame buffer device
isapnp: Scanning for PnP cards...
isapnp: No Plug & Play device found
Serial: 8250/16550 driver8 ports, IRQ sharing enabled
ACPI: PCI Interrupt Link [LNKB] enabled at IRQ 5
PCI: setting IRQ 5 as level-triggered
serial 0000:00:1f.6: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
serial 0000:00:1f.6: PCI INT B disabled
PNP: PS/2 Controller [PNP0303:PS2K,PNP0f13:PSM1] at 0x60,0x64 irq 1,12
serio: i8042 KBD port at 0x60,0x64 irq 1
serio: i8042 AUX port at 0x60,0x64 irq 12
mice: PS/2 mouse device common for all mice
cpuidle: using governor ladder
cpuidle: using governor menu
TCP cubic registered
Using IPI No-Shortcut mode
registered taskstats version 1
Freeing unused kernel memory: 316k freed
Write protecting the kernel text: 2336k
Write protecting the kernel read-only data: 1728k
input: AT Translated Set 2 keyboard as /devices/platform/i8042/serio0/input/input0
ACPI: CPU0 (power states: C1[C1] C2[C2])
processor ACPI_CPU:00: registered as cooling_device0
Marking TSC unstable due to TSC halts in idle
thermal LNXTHERM:01: registered as thermal_zone0
ACPI: Thermal Zone [THRM] (54 C)
ACPI: No dock devices found.
SCSI subsystem initialized
libata version 3.00 loaded.
ata_piix 0000:00:1f.1: version 2.12
ata_piix 0000:00:1f.1: enabling device (0005 -> 0007)
ACPI: PCI Interrupt Link [LNKC] enabled at IRQ 11
ata_piix 0000:00:1f.1: PCI INT A -> Link[LNKC] -> GSI 11 (level, low) -> IRQ 11
ata_piix 0000:00:1f.1: setting latency timer to 64
scsi0 : ata_piix
scsi1 : ata_piix
ata1: PATA max UDMA/100 cmd 0x1f0 ctl 0x3f6 bmdma 0x1810 irq 14
ata2: PATA max UDMA/100 cmd 0x170 ctl 0x376 bmdma 0x1818 irq 15
ata1: clearing spurious IRQ
ata1.00: ATA-8: TS32GSSD25-M, V0826, max UDMA/100
ata1.00: 62586880 sectors, multi 0: LBA 
ata1: clearing spurious IRQ
ata1: clearing spurious IRQ
ata1.00: configured for UDMA/100
ata2: clearing spurious IRQ
ata2.00: ATAPI: PHILIPS CD-RW/DVD-ROM CDD5263, UH89, max MWDMA2
ata2: clearing spurious IRQ
ata2: clearing spurious IRQ
ata2.00: configured for MWDMA2
scsi 0:0:0:0: Direct-Access     ATA      TS32GSSD25-M     V082 PQ: 0 ANSI: 5
scsi 1:0:0:0: CD-ROM            PHILIPS  CDRW/DVD CDD5263 UH89 PQ: 0 ANSI: 5
Uniform Multi-Platform E-IDE driver
BIOS EDD facility v0.16 2004-Jun-25, 1 devices found
udevd version 128 started
Synaptics Touchpad, model: 1, fw: 5.9, id: 0x236eb3, caps: 0x904713/0x10008
input: SynPS/2 Synaptics TouchPad as /devices/platform/i8042/serio1/input/input1
usbcore: registered new interface driver usbfs
usbcore: registered new interface driver hub
usbcore: registered new device driver usb
ACPI: PCI Interrupt Link [LNKH] enabled at IRQ 11
ehci_hcd 0000:00:1d.7: PCI INT D -> Link[LNKH] -> GSI 11 (level, low) -> IRQ 11
ehci_hcd 0000:00:1d.7: setting latency timer to 64
ehci_hcd 0000:00:1d.7: EHCI Host Controller
ehci_hcd 0000:00:1d.7: new USB bus registered, assigned bus number 1
ehci_hcd 0000:00:1d.7: debug port 1
ehci_hcd 0000:00:1d.7: cache line size of 32 is not supported
ehci_hcd 0000:00:1d.7: irq 11, io mem 0xe0100000
USB Universal Host Controller Interface driver v3.0
ehci_hcd 0000:00:1d.7: USB 2.0 started, EHCI 1.00, driver 10 Dec 2004
usb usb1: configuration #1 chosen from 1 choice
hub 1-0:1.0: USB hub found
hub 1-0:1.0: 6 ports detected
sd 0:0:0:0: [sda] 62586880 512-byte hardware sectors: (32.0GB/29.8GiB)
sd 0:0:0:0: [sda] Write Protect is off
sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn't support DPO or FUA
sd 0:0:0:0: [sda] 62586880 512-byte hardware sectors: (32.0GB/29.8GiB)
sd 0:0:0:0: [sda] Write Protect is off
sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn't support DPO or FUA
 sda: sda1 sda2 < sda5 sda6 sda7 >
sd 0:0:0:0: [sda] Attached SCSI disk
usb usb1: New USB device found, idVendor=1d6b, idProduct=0002
usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb1: Product: EHCI Host Controller
usb usb1: Manufacturer: Linux 2.6.27.7-9-default ehci_hcd
usb usb1: SerialNumber: 0000:00:1d.7
ACPI: PCI Interrupt Link [LNKA] enabled at IRQ 10
PCI: setting IRQ 10 as level-triggered
uhci_hcd 0000:00:1d.0: PCI INT A -> Link[LNKA] -> GSI 10 (level, low) -> IRQ 10
uhci_hcd 0000:00:1d.0: setting latency timer to 64
uhci_hcd 0000:00:1d.0: UHCI Host Controller
uhci_hcd 0000:00:1d.0: new USB bus registered, assigned bus number 2
uhci_hcd 0000:00:1d.0: irq 10, io base 0x00001820
usb usb2: configuration #1 chosen from 1 choice
hub 2-0:1.0: USB hub found
hub 2-0:1.0: 2 ports detected
usb usb2: New USB device found, idVendor=1d6b, idProduct=0001
usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb2: Product: UHCI Host Controller
usb usb2: Manufacturer: Linux 2.6.27.7-9-default uhci_hcd
usb usb2: SerialNumber: 0000:00:1d.0
ACPI: PCI Interrupt Link [LNKD] enabled at IRQ 11
uhci_hcd 0000:00:1d.1: PCI INT B -> Link[LNKD] -> GSI 11 (level, low) -> IRQ 11
uhci_hcd 0000:00:1d.1: setting latency timer to 64
uhci_hcd 0000:00:1d.1: UHCI Host Controller
uhci_hcd 0000:00:1d.1: new USB bus registered, assigned bus number 3
uhci_hcd 0000:00:1d.1: irq 11, io base 0x00001840
usb usb3: configuration #1 chosen from 1 choice
hub 3-0:1.0: USB hub found
hub 3-0:1.0: 2 ports detected
usb usb3: New USB device found, idVendor=1d6b, idProduct=0001
usb usb3: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb3: Product: UHCI Host Controller
usb usb3: Manufacturer: Linux 2.6.27.7-9-default uhci_hcd
usb usb3: SerialNumber: 0000:00:1d.1
uhci_hcd 0000:00:1d.2: PCI INT C -> Link[LNKC] -> GSI 11 (level, low) -> IRQ 11
uhci_hcd 0000:00:1d.2: setting latency timer to 64
uhci_hcd 0000:00:1d.2: UHCI Host Controller
uhci_hcd 0000:00:1d.2: new USB bus registered, assigned bus number 4
uhci_hcd 0000:00:1d.2: irq 11, io base 0x00001860
usb usb4: configuration #1 chosen from 1 choice
hub 4-0:1.0: USB hub found
hub 4-0:1.0: 2 ports detected
usb usb4: New USB device found, idVendor=1d6b, idProduct=0001
usb usb4: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb4: Product: UHCI Host Controller
usb usb4: Manufacturer: Linux 2.6.27.7-9-default uhci_hcd
usb usb4: SerialNumber: 0000:00:1d.2
PM: Starting manual resume from disk
kjournald starting.  Commit interval 5 seconds
EXT3 FS on sda6, internal journal
EXT3-fs: mounted filesystem with ordered data mode.
udevd version 128 started
Linux agpgart interface v0.103
agpgart-intel 0000:00:00.0: Intel 855GM Chipset
agpgart-intel 0000:00:00.0: detected 32636K stolen memory
agpgart-intel 0000:00:00.0: AGP aperture is 128M @ 0xe8000000
input: Power Button (FF) as /devices/LNXSYSTM:00/LNXPWRBN:00/input/input2
ACPI: Power Button (FF) [PWRF]
input: Lid Switch as /devices/LNXSYSTM:00/device:00/PNP0C0D:00/input/input3
ACPI: Lid Switch [LID0]
input: Power Button (CM) as /devices/LNXSYSTM:00/device:00/PNP0C0C:00/input/input4
ACPI: Power Button (CM) [PWRB]
ACPI: AC Adapter [ACAD] (on-line)
ACPI: Battery Slot [BAT0] (battery present)
ACPI: WMI: Mapper loaded
acpi device:05: registered as cooling_device1
input: Video Bus as /devices/LNXSYSTM:00/device:00/PNP0A03:00/device:02/input/input5
ACPI: Video Device [GFX0] (multi-head: yes  rom: yes  post: no)
intel_rng: FWH not detected
pci_hotplug: PCI Hot Plug PCI Core version: 0.5
sd 0:0:0:0: Attached scsi generic sg0 type 0
scsi 1:0:0:0: Attached scsi generic sg1 type 5
iTCO_vendor_support: vendor-support=0
sr0: scsi3-mmc drive: 1x/24x writer cd/rw xa/form2 cdda tray
Uniform CD-ROM driver Revision: 3.20
sr 1:0:0:0: Attached scsi CD-ROM sr0
i801_smbus 0000:00:1f.3: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
shpchp: Standard Hot Plug PCI Controller Driver version: 0.4
iTCO_wdt: Intel TCO WatchDog Timer Driver v1.03 (30-Apr-2008)
iTCO_wdt: Found a ICH4-M TCO device (Version=1, TCOBASE=0x1060)
iTCO_wdt: initialized. heartbeat=30 sec (nowayout=0)
8139cp: 10/100 PCI Ethernet driver v1.3 (Mar 22, 2004)
8139cp 0000:02:00.0: This (id 10ec:8139 rev 10) is not an 8139C+ compatible chip
8139cp 0000:02:00.0: Try the "8139too" driver instead.
Intel ICH Modem 0000:00:1f.6: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
Intel ICH Modem 0000:00:1f.6: setting latency timer to 64
8139too Fast Ethernet driver 0.9.28
input: PC Speaker as /devices/platform/pcspkr/input/input6
ALSA /usr/src/linux-2.6.27.7-9/sound/pci/ac97/ac97_codec.c:2154: MC'97 0 converters and GPIO not ready (0x1)
Intel ICH 0000:00:1f.5: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
Intel ICH 0000:00:1f.5: setting latency timer to 64
rtc_cmos 00:01: rtc core: registered rtc_cmos as rtc0
rtc0: alarms up to one month, y3k
intel8x0_measure_ac97_clock: measured 53954 usecs
intel8x0: clocking to 48000
vendor=8086 device=2448
8139too 0000:02:00.0: PCI INT A -> Link[LNKA] -> GSI 10 (level, low) -> IRQ 10
eth0: RealTek RTL8139 at 0xf91d6000, 00:c0:9f:51:32:d1, IRQ 10
eth0:  Identified 8139 chip type 'RTL-8100B/8139D'
Yenta: CardBus bridge found at 0000:02:05.0 [103c:3084]
Yenta: Using CSCINT to route CSC interrupts to PCI
Yenta: Routing CardBus interrupts to PCI
Yenta TI: socket 0000:02:05.0, mfunc 0x01111112, devctl 0x64
Yenta: ISA IRQ mask 0x00d8, PCI irq 11
Socket status: 30000006
Yenta: Raising subordinate bus# of parent bus (#02) from #02 to #06
pcmcia: parent PCI bridge I/O window: 0x3000 - 0x3fff
cs: IO port probe 0x3000-0x3fff: clean.
pcmcia: parent PCI bridge Memory window: 0xe0200000 - 0xe02fffff
pcmcia: parent PCI bridge Memory window: 0x50000000 - 0x53ffffff
vendor=8086 device=2448
b43-pci-bridge 0000:02:06.0: PCI INT A -> Link[LNKC] -> GSI 11 (level, low) -> IRQ 11
ssb: Sonics Silicon Backplane found on PCI device 0000:02:06.0
cs: IO port probe 0x100-0x3af: clean.
cs: IO port probe 0x3e0-0x4ff: excluding 0x4d0-0x4d7
cs: IO port probe 0x820-0x8ff: clean.
cs: IO port probe 0xc00-0xcf7: clean.
cs: IO port probe 0xa00-0xaff: clean.
b43-phy0: Broadcom 4306 WLAN found
b43-phy0 debug: Found PHY: Analog 2, Type 2, Revision 2
b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
phy0: Selected rate control algorithm 'pid'
Broadcom 43xx driver loaded [ Features: PMLR, Firmware-ID: FW13 ]
Adding 1502004k swap on /dev/sda5.  Priority:-1 extents:1 across:1502004k
device-mapper: uevent: version 1.0.3
device-mapper: ioctl: 4.14.0-ioctl (2008-04-23) initialised: dm-devel at redhat.com
loop: module loaded
kjournald starting.  Commit interval 5 seconds
EXT3 FS on sda7, internal journal
EXT3-fs: mounted filesystem with ordered data mode.
fuse init (API version 7.9)
type=1505 audit(1235314512.690:2): operation="profile_load" name="/bin/ping" name2="default" pid=1591
type=1505 audit(1235314512.798:3): operation="profile_load" name="/sbin/klogd" name2="default" pid=1592
type=1505 audit(1235314513.082:4): operation="profile_load" name="/sbin/syslog-ng" name2="default" pid=1606
type=1505 audit(1235314513.294:5): operation="profile_load" name="/sbin/syslogd" name2="default" pid=1648
type=1505 audit(1235314513.474:6): operation="profile_load" name="/usr/sbin/avahi-daemon" name2="default" pid=1659
type=1505 audit(1235314513.638:7): operation="profile_load" name="/usr/sbin/identd" name2="default" pid=1673
type=1505 audit(1235314513.858:8): operation="profile_load" name="/usr/sbin/mdnsd" name2="default" pid=1685
type=1505 audit(1235314514.058:9): operation="profile_load" name="/usr/sbin/nscd" name2="default" pid=1698
type=1505 audit(1235314514.370:10): operation="profile_load" name="/usr/sbin/ntpd" name2="default" pid=1711
type=1505 audit(1235314514.550:11): operation="profile_load" name="/usr/sbin/traceroute" name2="default" pid=1735
powernow: This module only works with AMD K7 CPUs
IA-32 Microcode Update Driver: v1.14a <tigran at aivazian.fsnet.co.uk>
firmware: requesting intel-ucode/06-09-05
microcode: CPU0 updated from revision 0x45 to 0x47, date = 11092004 
NET: Registered protocol family 10
lo: Disabled Privacy Extensions
ip6_tables: (C) 2000-2006 Netfilter Core Team
ip_tables: (C) 2000-2006 Netfilter Core Team
nf_conntrack version 0.5.0 (16384 buckets, 65536 max)
CONFIG_NF_CT_ACCT is deprecated and will be removed soon. Plase use
nf_conntrack.acct=1 kernel paramater, acct=1 nf_conntrack module option or
sysctl net.netfilter.nf_conntrack_acct=1 to enable it.
[drm] Initialized drm 1.1.0 20060810
pci 0000:00:02.0: PCI INT A -> Link[LNKA] -> GSI 10 (level, low) -> IRQ 10
pci 0000:00:02.0: setting latency timer to 64
[drm] Initialized i915 1.6.0 20060119 on minor 0
pci 0000:00:02.1: setting latency timer to 64
[drm] Initialized i915 1.6.0 20060119 on minor 1
[drm:i915_getparam] *ERROR* Unknown parameter 5
[drm:i915_getparam] *ERROR* Unknown parameter 5
eth0: link down
ADDRCONF(NETDEV_UP): eth0: link is not ready
input: b43-phy0 as /devices/virtual/input/input7
firmware: requesting b43/ucode5.fw
firmware: requesting b43/pcm5.fw
firmware: requesting b43/b0g0initvals5.fw
firmware: requesting b43/b0g0bsinitvals5.fw
b43-phy0: Loading firmware version 410.2160 (2007-05-26 15:32:10)
b43-phy0 debug: Chip initialized
b43-phy0 debug: PIO initialized
Registered led device: b43-phy0::tx
Registered led device: b43-phy0::rx
Registered led device: b43-phy0::radio
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Adding Interface type 2
ADDRCONF(NETDEV_UP): wlan0: link is not ready
NET: Registered protocol family 17
[drm:i915_getparam] *ERROR* Unknown parameter 5
Bluetooth: Core ver 2.13
NET: Registered protocol family 31
Bluetooth: HCI device and connection manager initialized
Bluetooth: HCI socket layer initialized
Bluetooth: L2CAP ver 2.11
Bluetooth: L2CAP socket layer initialized
Bluetooth: RFCOMM socket layer initialized
Bluetooth: RFCOMM TTY layer initialized
Bluetooth: RFCOMM ver 1.10
Bluetooth: SCO (Voice Link) ver 0.6
Bluetooth: SCO socket layer initialized
Bluetooth: BNEP (Ethernet Emulation) ver 1.3
Bluetooth: BNEP filters: protocol multicast
Bridge firewalling registered
pan0: Dropping NETIF_F_UFO since no NETIF_F_HW_CSUM feature.
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=248 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=228 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
wlan0: no IPv6 routers present
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
st: Version 20080504, fixed bufsize 32768, s/g segs 256
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=63.245.209.93 DST=192.168.0.197 LEN=699 TOS=0x00 PREC=0x00 TTL=51 ID=19235 DF PROTO=TCP SPT=80 DPT=35677 WINDOW=7073 RES=0x00 ACK PSH FIN URGP=0 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=63.245.209.93 DST=192.168.0.197 LEN=699 TOS=0x00 PREC=0x00 TTL=51 ID=19236 DF PROTO=TCP SPT=80 DPT=35677 WINDOW=7073 RES=0x00 ACK PSH FIN URGP=0 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:08:00 SRC=192.168.0.196 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0d:88:c7:87:51:08:00 SRC=192.168.0.198 DST=224.0.0.251 LEN=83 TOS=0x00 PREC=0x00 TTL=255 ID=13 PROTO=UDP SPT=5353 DPT=5353 LEN=63 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0d:88:c7:87:51:08:00 SRC=192.168.0.198 DST=224.0.0.251 LEN=101 TOS=0x00 PREC=0x00 TTL=255 ID=14 PROTO=UDP SPT=5353 DPT=5353 LEN=81 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0d:88:c7:87:51:08:00 SRC=192.168.0.198 DST=224.0.0.251 LEN=83 TOS=0x00 PREC=0x00 TTL=255 ID=15 PROTO=UDP SPT=5353 DPT=5353 LEN=63 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0d:88:c7:87:51:08:00 SRC=192.168.0.198 DST=224.0.0.251 LEN=83 TOS=0x00 PREC=0x00 TTL=255 ID=16 PROTO=UDP SPT=5353 DPT=5353 LEN=63 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0d:88:c7:87:51:08:00 SRC=192.168.0.198 DST=224.0.0.251 LEN=77 TOS=0x00 PREC=0x00 TTL=255 ID=18 PROTO=UDP SPT=5353 DPT=5353 LEN=57 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0d:88:c7:87:51:08:00 SRC=192.168.0.198 DST=224.0.0.251 LEN=117 TOS=0x00 PREC=0x00 TTL=255 ID=199 PROTO=UDP SPT=5353 DPT=5353 LEN=97 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0d:88:c7:87:51:08:00 SRC=192.168.0.198 DST=224.0.0.251 LEN=117 TOS=0x00 PREC=0x00 TTL=255 ID=329 PROTO=UDP SPT=5353 DPT=5353 LEN=97 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:86:dd SRC=fe80:0000:0000:0000:020b:cdff:fe8e:3664 DST=ff02:0000:0000:0000:0000:0000:0000:0001 LEN=586 TC=0 HOPLIMIT=64 FLOWLBL=0 PROTO=UDP SPT=34213 DPT=67 LEN=546 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:86:dd SRC=fe80:0000:0000:0000:020b:cdff:fe8e:3664 DST=ff02:0000:0000:0000:0000:0000:0000:0001 LEN=586 TC=0 HOPLIMIT=64 FLOWLBL=0 PROTO=UDP SPT=34214 DPT=67 LEN=546 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:86:dd SRC=fe80:0000:0000:0000:020b:cdff:fe8e:3664 DST=ff02:0000:0000:0000:0000:0000:0000:0001 LEN=586 TC=0 HOPLIMIT=64 FLOWLBL=0 PROTO=UDP SPT=34215 DPT=67 LEN=546 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:86:dd SRC=fe80:0000:0000:0000:020b:cdff:fe8e:3664 DST=ff02:0000:0000:0000:0000:0000:0000:0001 LEN=586 TC=0 HOPLIMIT=64 FLOWLBL=0 PROTO=UDP SPT=34216 DPT=67 LEN=546 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:86:dd SRC=fe80:0000:0000:0000:020b:cdff:fe8e:3664 DST=ff02:0000:0000:0000:0000:0000:0000:0001 LEN=586 TC=0 HOPLIMIT=64 FLOWLBL=0 PROTO=UDP SPT=34217 DPT=67 LEN=546 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:86:dd SRC=fe80:0000:0000:0000:020b:cdff:fe8e:3664 DST=ff02:0000:0000:0000:0000:0000:0000:0001 LEN=586 TC=0 HOPLIMIT=64 FLOWLBL=0 PROTO=UDP SPT=34235 DPT=67 LEN=546 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:86:dd SRC=fe80:0000:0000:0000:020b:cdff:fe8e:3664 DST=ff02:0000:0000:0000:0000:0000:0000:0001 LEN=586 TC=0 HOPLIMIT=64 FLOWLBL=0 PROTO=UDP SPT=34235 DPT=67 LEN=546 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:86:dd SRC=fe80:0000:0000:0000:020b:cdff:fe8e:3664 DST=ff02:0000:0000:0000:0000:0000:0000:0001 LEN=586 TC=0 HOPLIMIT=64 FLOWLBL=0 PROTO=UDP SPT=34235 DPT=67 LEN=546 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=63.245.209.93 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=242 ID=16708 PROTO=TCP SPT=80 DPT=35677 WINDOW=5840 RES=0x00 RST URGP=0 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:08:00 SRC=192.168.0.196 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:08:00 SRC=192.168.0.196 DST=224.0.0.251 LEN=559 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=539 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
b43-phy0 ERROR: PHY transmission error
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=216.252.124.207 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=23486 DF PROTO=TCP SPT=53047 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A002281210D1992B2) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=216.252.124.207 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=23487 DF PROTO=TCP SPT=53047 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A0022D0210D1992B2) 
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authentication with AP 00:30:44:02:76:d2 timed out
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=248 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=228 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=436 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=416 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=74.125.19.100 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=2327 DF PROTO=TCP SPT=32804 DPT=80 WINDOW=135 RES=0x00 ACK FIN URGP=0 OPT (0101080A00248B849143F3D0) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=63.245.209.93 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=35254 DF PROTO=TCP SPT=35677 DPT=80 WINDOW=5840 RES=0x00 ACK PSH FIN URGP=0 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=63.245.209.93 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=10746 PROTO=TCP SPT=80 DPT=35677 WINDOW=0 RES=0x00 ACK RST URGP=0 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=63.245.209.93 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=35255 DF PROTO=TCP SPT=35677 DPT=80 WINDOW=5840 RES=0x00 ACK PSH FIN URGP=0 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=63.245.209.93 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=10747 PROTO=TCP SPT=80 DPT=35677 WINDOW=0 RES=0x00 ACK RST URGP=0 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=63.245.209.93 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=35256 DF PROTO=TCP SPT=35677 DPT=80 WINDOW=5840 RES=0x00 ACK PSH FIN URGP=0 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=63.245.209.93 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=35257 DF PROTO=TCP SPT=35677 DPT=80 WINDOW=5840 RES=0x00 ACK PSH FIN URGP=0 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=63.245.209.93 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=10749 PROTO=TCP SPT=80 DPT=35677 WINDOW=0 RES=0x00 ACK RST URGP=0 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=63.245.209.93 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=35258 DF PROTO=TCP SPT=35677 DPT=80 WINDOW=5840 RES=0x00 ACK PSH FIN URGP=0 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=63.245.209.93 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=10750 PROTO=TCP SPT=80 DPT=35677 WINDOW=0 RES=0x00 ACK RST URGP=0 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=63.245.209.93 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=10751 PROTO=TCP SPT=80 DPT=35677 WINDOW=0 RES=0x00 ACK RST URGP=0 
b43-phy0 ERROR: PHY transmission error
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=63.245.209.93 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=35260 DF PROTO=TCP SPT=35677 DPT=80 WINDOW=5840 RES=0x00 ACK PSH FIN URGP=0 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=63.245.209.93 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=10752 PROTO=TCP SPT=80 DPT=35677 WINDOW=0 RES=0x00 ACK RST URGP=0 
b43-phy0 ERROR: PHY transmission error
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=74.125.19.100 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=2328 DF PROTO=TCP SPT=32804 DPT=80 WINDOW=135 RES=0x00 ACK FIN URGP=0 OPT (0101080A0024EB049143F3D0) 
b43-phy0 ERROR: PHY transmission error
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=63.245.209.93 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=35261 DF PROTO=TCP SPT=35677 DPT=80 WINDOW=5840 RES=0x00 ACK PSH FIN URGP=0 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=63.245.209.93 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=10753 PROTO=TCP SPT=80 DPT=35677 WINDOW=0 RES=0x00 ACK RST URGP=0 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=63.245.209.93 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=35262 DF PROTO=TCP SPT=35677 DPT=80 WINDOW=5840 RES=0x00 ACK PSH FIN URGP=0 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=209.73.187.189 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=14427 DF PROTO=TCP SPT=58482 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A00258B82A0E6369B) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=206.190.52.34 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=46601 DF PROTO=TCP SPT=53323 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A00272F45C92065DA) 
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=216.252.108.50 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=60818 DF PROTO=TCP SPT=55463 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A0028985C171B9534) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=216.252.124.207 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=24438 DF PROTO=TCP SPT=50790 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A0028C3510D1C1487) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=216.252.108.50 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=60819 DF PROTO=TCP SPT=55463 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A0028D65C171B9534) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=216.252.124.207 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=24439 DF PROTO=TCP SPT=50790 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A00290FD10D1C1487) 
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=216.252.124.207 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=8837 DF PROTO=TCP SPT=38564 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A002D99230D1DFE15) 
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=216.252.124.207 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=8838 DF PROTO=TCP SPT=38564 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A002DF3A30D1DFE15) 
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=206.190.52.34 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=41344 DF PROTO=TCP SPT=45413 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A0030BA21F6670A57) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=206.190.52.34 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=41345 DF PROTO=TCP SPT=45413 DPT=80 WINDOW=108 RES=0x00 ACK FIN URGP=0 OPT (0101080A00310229F6670A57) 
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
wlan0: disassociating by local choice (reason=3)
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: disassociating by local choice (reason=3)
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=4)
wlan0: associated
wlan0: disassociating by local choice (reason=3)
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authentication with AP 00:30:44:02:76:d2 timed out
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: disassociating by local choice (reason=3)
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
wlan0: disassociating by local choice (reason=3)
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy0 ERROR: PHY transmission error
wlan0: disassociating by local choice (reason=3)
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
wlan0: disassociating by local choice (reason=3)
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
wlan0: disassociating by local choice (reason=3)
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: association with AP 00:30:44:02:76:d2 timed out
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Removing Interface type 2
b43-phy0 debug: Wireless interface stopped
b43-phy1: Broadcom 4306 WLAN found
b43-phy1 debug: Found PHY: Analog 2, Type 2, Revision 2
b43-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
phy1: Selected rate control algorithm 'pid'
Broadcom 43xx driver loaded [ Features: PMLR, Firmware-ID: FW13 ]
input: b43-phy1 as /devices/virtual/input/input8
firmware: requesting b43/ucode5.fw
firmware: requesting b43/pcm5.fw
firmware: requesting b43/b0g0initvals5.fw
firmware: requesting b43/b0g0bsinitvals5.fw
b43-phy1: Loading firmware version 410.2160 (2007-05-26 15:32:10)
b43-phy1 debug: Chip initialized
b43-phy1 debug: PIO initialized
Registered led device: b43-phy1::tx
Registered led device: b43-phy1::rx
Registered led device: b43-phy1::radio
b43-phy1 debug: Wireless interface started
b43-phy1 debug: Adding Interface type 2
ADDRCONF(NETDEV_UP): wlan0: link is not ready
b43-phy1 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=248 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=228 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=436 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=416 
wlan0: no IPv6 routers present
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:0b:cd:8e:36:64:08:00 SRC=192.168.0.196 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=192.168.0.1 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=11476 PROTO=TCP SPT=80 DPT=41915 WINDOW=4096 RES=0x00 RST URGP=0 
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy1 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy1 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy1 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy1 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy1 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy1 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authentication with AP 00:30:44:02:76:d2 timed out
b43-phy1 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy1 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy1 ERROR: PHY transmission error
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=248 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=228 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=436 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=416 
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy1 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy1 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authentication with AP 00:30:44:02:76:d2 timed out
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy1 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
b43-phy1 ERROR: PHY transmission error
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=248 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=228 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=436 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=416 
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy1 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy1 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authentication with AP 00:30:44:02:76:d2 timed out
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy1 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy1 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy1 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 ERROR: PHY transmission error
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)


----- Original Message ----
From: Michael Buesch <mb at bu3sch.de>
To: bcm43xx-dev at lists.berlios.de
Cc: John Mountcastle <mtcstle at yahoo.com>; Larry Finger <Larry.Finger at lwfinger.net>
Sent: Saturday, February 21, 2009 2:40:45 PM
Subject: Re: I need some help stabaizing b43 for a 4306

On Saturday 21 February 2009 20:17:53 John Mountcastle wrote:
> 
> Thanks Larry, what about the part right there at the endwher it says assume out of range when nothing has moved. It's like the receeption begins to drop of until it can no longer support the connection.

Please turn on b43 debugging in the kernel config, mount debugfs to /sys/kernel/debug
and enable xmit debugging with this knob:
echo 1 > /sys/kernel/debug/b43/phy*/debug_xmitpower

Then see if the kernel tells you something interesting.

-- 
Greetings, Michael.



From mb at bu3sch.de  Sun Feb 22 21:58:21 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 22 Feb 2009 21:58:21 +0100
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <27179.70560.qm@web65414.mail.ac4.yahoo.com>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
	<27179.70560.qm@web65414.mail.ac4.yahoo.com>
Message-ID: <200902222158.21603.mb@bu3sch.de>

On Sunday 22 February 2009 21:45:44 John Mountcastle wrote:
> 
> Michael, configuring a new kernel was a real blast from the past. I haven't  done that in several years but I think I got it done. Funny thing, when I booted the debug kernel, the interface was rock solid for almost an hour, not one single error, then it went sour again. I switched on br43 debugging as you suggested, about half way through the capture. You can see the Tx-mit power messages start. About 60% into the capture I unloaded b43 (rmmod/insmod) and reloaded it in order to get the interface to come back up.
> 
> I hope you can tell me something about what if anything this capture tells us? Or, the net step in debuggging
> 


> b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
> b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)

The first thing I notice, of course, is the very low TX power output of 15dBm.
Can you check iwconfig to check which TX power was selected?
It should write something like this:
wlan0     IEEE 802.11bg  ESSID:"XXXX"  
          Mode:Managed  Frequency:2.XXXX GHz  Access Point: XXXXXXXXX
          Bit Rate=XX Mb/s   Tx-Power=20 dBm  
          .....


So if there's a higher value than 15, please tell me so.
If the value is 15 there, too. Try manually setting the TX power:
 iwconfig wlan0 txpower 20

This might be a bug in the card's PROM or possibly the code reading it. I also have a card
where it incorrectly reads the TX power value (but it's 19dBm for me, so it doesn't matter that much for me...).


Besides that, please tell me exactly at which point in the log messages it starts to break.
That's essential information for me.

Also, moving to latest b43 development code might help, too. It has improved TX power
control code which might scale a bit better on your device.
You can do so by downloading compat-wireless: http://wireless.kernel.org/en/users/Download

-- 
Greetings, Michael.


From francesco.gringoli at ing.unibs.it  Sun Feb 22 23:26:24 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Sun, 22 Feb 2009 23:26:24 +0100
Subject: More data on open-source firmware crash
In-Reply-To: <49A1A331.9080205@lwfinger.net>
References: <49A1A331.9080205@lwfinger.net>
Message-ID: <A4655DBE-9711-4DA0-A160-135A8359FF0F@ing.unibs.it>


On Feb 22, 2009, at 8:10 PM, Larry Finger wrote:

> Francesco and Lorenzo,
>
> I modified my driver source to dump the firmware machine state  
> whenever the
> b43_dma_handle_txstatus routine was called with an out-of-order  
> cookie. With
> proprietary firmware, the test of a flood ping in one job and  
> repeated tcpperf
> transmissions in a second ran for 10 hours without a single  
> "failure". With the
> open-source firmware it failed after about 2 hours.
>
> Below are the saved status data. Listed for each item are the  
> cookie, the
> sequence number, and the skb length. The 0x84 length values come  
> from the ping.
> All of the out-of-order items come from tcpperf - is it significant  
> that they
> are from the longer set? Note that a number of cookie/sequence pairs  
> are
> missing, namely: 2064/9C1, 2066/9C2, 2068/9C3, 206A/9C4, 206C/9C5,  
> 2072/9C7,
> 2076/9C9, and 207A/9CB. Cookie 206E is missing, but the next  
> sequence (9C6) was
> attached to cookie 2070.
>
>
Larry,

do you mind testing this firmware? It's not the solution, but can help  
us understanding if we should follow this way. Download at http://www.ing.unibs.it/~gringoli/fwtest.tar.gz

Before using this firmware please recompile b43 changing these two  
definitions in b43.h

#define B43_MARKER_ID_REG               52
#define B43_MARKER_LINE_REG             53

I coded the firmware so that it will raise a B43_DEBUGIRQ_MARKER with  
id 10, line 100 if the condition I'm thinking to is true. You will see  
(I hope) in dmesg.

Thanks,
bye
-FG


From mtcstle at yahoo.com  Mon Feb 23 03:40:01 2009
From: mtcstle at yahoo.com (John Mountcastle)
Date: Sun, 22 Feb 2009 18:40:01 -0800 (PST)
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <200902222158.21603.mb@bu3sch.de>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
	<27179.70560.qm@web65414.mail.ac4.yahoo.com>
	<200902222158.21603.mb@bu3sch.de>
Message-ID: <753586.44085.qm@web65414.mail.ac4.yahoo.com>


Here is a little snippet of dmesg, just after I brought the link up.

b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=146.6.54.21 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=16037 DF PROTO=TCP SPT=57570 DPT=80 WINDOW=227 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B6F416FD3DC29) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=146.137.96.7 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=10146 DF PROTO=TCP SPT=39841 DPT=80 WINDOW=589 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B77F70FA3EE62) 
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm

Here is iwconfig wlan0

mtcstle at sybill:~/Desktop> sudo /usr/sbin/iwconfig wlan0
wlan0     IEEE 802.11bg  ESSID:"MBR-6d2"  
          Mode:Managed  Frequency:2.417 GHz  Access Point: 00:30:44:02:76:D2   
          Bit Rate=1 Mb/s   Tx-Power=27 dBm   
          Retry min limit:7   RTS thr:off   Fragment thr=2352 B   
          Encryption key:7761-7465-7266-616C-6C30-3030-30   Security mode:open
          Power Management:off
          Link Quality=51/100  Signal level:-5 dBm  Noise level=-17 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

Note that while b43-phy0 debug says desired output is 15.0dBm, iwconfig says it's askigng for 27. 

Next I went about doing other things and when I saw the interface go down (NetworkManager) I shot off another dmesg. So, the very end of this message was within seconds of the interface going down.

I may have to reinstalll frm scratch, I seem to have screwed up my kernel sources, I can't compile a new 'default' kernel. Let me know what you think of my little problem and what i should try next.

Regards

John

Initializing cgroup subsys cpuset
Initializing cgroup subsys cpu
Linux version 2.6.27.7-9-debug (geeko at buildhost) (gcc version 4.3.2 [gcc-4_3-branch revision 141291] (SUSE Linux) ) #2 SMP Sun Feb 22 16:55:19 EST 2009
PAT WC disabled due to known CPU erratum.
BIOS-provided physical RAM map:
 BIOS-e820: 0000000000000000 - 000000000009f800 (usable)
 BIOS-e820: 000000000009f800 - 00000000000a0000 (reserved)
 BIOS-e820: 00000000000ce000 - 00000000000d0000 (reserved)
 BIOS-e820: 00000000000dc000 - 0000000000100000 (reserved)
 BIOS-e820: 0000000000100000 - 000000003dee0000 (usable)
 BIOS-e820: 000000003dee0000 - 000000003deec000 (ACPI data)
 BIOS-e820: 000000003deec000 - 000000003df00000 (ACPI NVS)
 BIOS-e820: 000000003df00000 - 0000000040000000 (reserved)
 BIOS-e820: 00000000ff800000 - 00000000ffc00000 (reserved)
 BIOS-e820: 00000000fffffc00 - 0000000100000000 (reserved)
DMI present.
last_pfn = 0x3dee0 max_arch_pfn = 0x100000
kernel direct mapping tables up to 38000000 @ 7000-c000
RAMDISK: 37515000 - 37fefc04
ACPI: RSDP 000F6560, 0014 (r0 HP    )
ACPI: RSDT 3DEE674D, 0030 (r1 HP     3084      6040000  LTP        0)
ACPI: FACP 3DEEBED2, 0074 (r1 HP     3084      6040000 PTL        50)
ACPI: DSDT 3DEE6C96, 523C (r1 HP     3084      6040000 MSFT  100000E)
ACPI: FACS 3DEFCFC0, 0040
ACPI: BOOT 3DEEBFD8, 0028 (r1 HP     3084      6040000  LTP        1)
ACPI: SSDT 3DEE6B84, 010A (r1 HP     3084            1 INTL 20030224)
ACPI: DMI detected: Hewlett-Packard
94MB HIGHMEM available.
896MB LOWMEM available.
  mapped low ram: 0 - 38000000
  low ram: 00000000 - 38000000
  bootmap 00009000 - 00010000
(9 early reservations) ==> bootmem [0000000000 - 0038000000]
  #0 [0000000000 - 0000001000]   BIOS data page ==> [0000000000 - 0000001000]
  #1 [0000001000 - 0000002000]    EX TRAMPOLINE ==> [0000001000 - 0000002000]
  #2 [0000006000 - 0000007000]       TRAMPOLINE ==> [0000006000 - 0000007000]
  #3 [0000100000 - 00006449dc]    TEXT DATA BSS ==> [0000100000 - 00006449dc]
  #4 [0037515000 - 0037fefc04]          RAMDISK ==> [0037515000 - 0037fefc04]
  #5 [0000645000 - 0000648000]    INIT_PG_TABLE ==> [0000645000 - 0000648000]
  #6 [000009f800 - 0000100000]    BIOS reserved ==> [000009f800 - 0000100000]
  #7 [0000007000 - 0000009000]          PGTABLE ==> [0000007000 - 0000009000]
  #8 [0000009000 - 0000010000]          BOOTMAP ==> [0000009000 - 0000010000]
Zone PFN ranges:
  DMA      0x00000000 -> 0x00001000
  Normal   0x00001000 -> 0x00038000
  HighMem  0x00038000 -> 0x0003dee0
Movable zone start PFN for each node
early_node_map[2] active PFN ranges
    0: 0x00000000 -> 0x0000009f
    0: 0x00000100 -> 0x0003dee0
On node 0 totalpages: 253567
free_area_init_node: node 0, pgdat c0512c00, node_mem_map c1000000
  DMA zone: 3963 pages, LIFO batch:0
  Normal zone: 223300 pages, LIFO batch:31
  HighMem zone: 24074 pages, LIFO batch:3
Using APIC driver default
ACPI: PM-Timer IO Port: 0x1008
SMP: Allowing 1 CPUs, 0 hotplug CPUs
Local APIC disabled by BIOS -- you can enable it with "lapic"
mapped APIC to ffffb000 (018bc000)
PM: Registered nosave memory: 000000000009f000 - 00000000000a0000
PM: Registered nosave memory: 00000000000a0000 - 00000000000ce000
PM: Registered nosave memory: 00000000000ce000 - 00000000000d0000
PM: Registered nosave memory: 00000000000d0000 - 00000000000dc000
PM: Registered nosave memory: 00000000000dc000 - 0000000000100000
Allocating PCI resources starting at 50000000 (gap: 40000000:bf800000)
PERCPU: Allocating 39068 bytes of per cpu data
NR_CPUS: 32, nr_cpu_ids: 1, nr_node_ids 1
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 251337
Kernel command line: root=/dev/disk/by-id/ata-TS32GSSD25-M_00229828003E-part6 resume=/dev/disk/by-id/ata-TS32GSSD25-M_00229828003E-part5 splash=silent vga=0x317
bootsplash: silent mode.
Enabling fast FPU save and restore... done.
Enabling unmasked SIMD FPU exception support... done.
Initializing CPU#0
PID hash table entries: 4096 (order: 12, 16384 bytes)
TSC: PIT calibration confirmed by PMTIMER.
TSC: using PMTIMER calibration value
Detected 1298.892 MHz processor.
Console: colour dummy device 80x25
console [tty0] enabled
Dentry cache hash table entries: 131072 (order: 7, 524288 bytes)
Inode-cache hash table entries: 65536 (order: 6, 262144 bytes)
Memory: 987640k/1014656k available (2334k kernel code, 26340k reserved, 1920k data, 316k init, 97152k highmem)
virtual kernel memory layout:
    fixmap  : 0xffdf6000 - 0xfffff000   (2084 kB)
    pkmap   : 0xff400000 - 0xff800000   (4096 kB)
    vmalloc : 0xf8800000 - 0xff3fe000   ( 107 MB)
    lowmem  : 0xc0000000 - 0xf8000000   ( 896 MB)
      .init : 0xc052e000 - 0xc057d000   ( 316 kB)
      .data : 0xc034785b - 0xc0527a90   (1920 kB)
      .text : 0xc0100000 - 0xc034785b   (2334 kB)
Checking if this processor honours the WP bit even in supervisor mode...Ok.
CPA: page pool initialized 1 of 1 pages preallocated
Calibrating delay loop (skipped), value calculated using timer frequency.. 2597.78 BogoMIPS (lpj=5195568)
kdb version 4.4 by Keith Owens, Scott Lurndal. Copyright SGI, All Rights Reserved
Security Framework initialized
SELinux:  Disabled at boot.
AppArmor: AppArmor initialized
Mount-cache hash table entries: 512
Initializing cgroup subsys ns
Initializing cgroup subsys cpuacct
Initializing cgroup subsys memory
Initializing cgroup subsys devices
Initializing cgroup subsys freezer
CPU: L1 I cache: 32K, L1 D cache: 32K
CPU: L2 cache: 512K
Intel machine check architecture supported.
Intel machine check reporting enabled on CPU#0.
Checking 'hlt' instruction... OK.
SMP alternatives: switching to UP code
Freeing SMP alternatives: 12k freed
ACPI: Core revision 20080609
ACPI: Checking initramfs for custom DSDT
Parsing all Control Methods:
Table [DSDT](id 0001) - 709 Objects with 58 Devices 210 Methods 16 Regions
Parsing all Control Methods:
Table [SSDT](id 0002) - 1 Objects with 0 Devices 1 Methods 0 Regions
 tbxface-0596 [00] tb_load_namespace     : ACPI Tables successfully acquired
ACPI: setting ELCR to 0200 (from 0c20)
evxfevnt-0091 [00] enable                : Transition to ACPI mode successful
weird, boot CPU (#0) not listedby the BIOS.
SMP motherboard not detected.
Local APIC not detected. Using dummy APIC emulation.
SMP disabled
Brought up 1 CPUs
Total of 1 processors activated (2597.78 BogoMIPS).
CPU0 attaching NULL sched-domain.
net_namespace: 1044 bytes
Booting paravirtualized kernel on bare hardware
NET: Registered protocol family 16
ACPI: bus type pci registered
PCI: PCI BIOS revision 2.10 entry at 0xfd9a2, last bus=2
PCI: Using configuration type 1 for base access
evgpeblk-0957 [00] ev_create_gpe_block   : GPE 00 to 1F [_GPE] 4 regs on int 0x9
ACPI: EC: Look up EC in DSDT
Completing Region/Field/Buffer/Package initialization:........................................................
Initialized 14/16 Regions 0/0 Fields 22/22 Buffers 20/20 Packages (719 nodes)
Initializing Device/Processor/Thermal objects by executing _INI methods:.
Executed 1 _INI methods requiring 0 _STA executions (examined 62 objects)
evgpeblk-1054 [00] ev_initialize_gpe_bloc: Found 5 Wake, Enabled 0 Runtime GPEs in this block
ACPI: Interpreter enabled
ACPI: (supports S0 S3 S4 S5)
ACPI: Using PIC for interrupt routing
ACPI: EC: non-query interrupt received, switching to interrupt mode
ACPI: EC: GPE = 0x1d, I/O: command/status = 0x66, data = 0x62
ACPI: EC: driver started in interrupt mode
ACPI: PCI Root Bridge [PCI0] (0000:00)
PCI: 0000:00:02.0 reg 10 32bit mmio: [e8000000, efffffff]
PCI: 0000:00:02.0 reg 14 32bit mmio: [e0000000, e007ffff]
PCI: 0000:00:02.0 reg 18 io port: [1800, 1807]
pci 0000:00:02.0: supports D1
PCI: 0000:00:02.1 reg 10 32bit mmio: [f0000000, f7ffffff]
PCI: 0000:00:02.1 reg 14 32bit mmio: [e0080000, e00fffff]
pci 0000:00:02.1: supports D1
PCI: 0000:00:1d.0 reg 20 io port: [1820, 183f]
PCI: 0000:00:1d.1 reg 20 io port: [1840, 185f]
PCI: 0000:00:1d.2 reg 20 io port: [1860, 187f]
PCI: 0000:00:1d.7 reg 10 32bit mmio: [e0100000, e01003ff]
pci 0000:00:1d.7: PME# supported from D0 D3hot D3cold
pci 0000:00:1d.7: PME# disabled
HPET not enabled in BIOS. You might try hpet=force boot option
pci 0000:00:1f.0: quirk: region 1000-107f claimed by ICH4 ACPI/GPIO/TCO
pci 0000:00:1f.0: quirk: region 1180-11bf claimed by ICH4 GPIO
PCI: 0000:00:1f.1 reg 10 io port: [0, 7]
PCI: 0000:00:1f.1 reg 14 io port: [0, 3]
PCI: 0000:00:1f.1 reg 18 io port: [0, 7]
PCI: 0000:00:1f.1 reg 1c io port: [0, 3]
PCI: 0000:00:1f.1 reg 20 io port: [1810, 181f]
PCI: 0000:00:1f.1 reg 24 32bit mmio: [0, 3ff]
PCI: 0000:00:1f.3 reg 20 io port: [1880, 189f]
PCI: 0000:00:1f.5 reg 10 io port: [1c00, 1cff]
PCI: 0000:00:1f.5 reg 14 io port: [18c0, 18ff]
PCI: 0000:00:1f.5 reg 18 32bit mmio: [e0100c00, e0100dff]
PCI: 0000:00:1f.5 reg 1c 32bit mmio: [e0100800, e01008ff]
pci 0000:00:1f.5: PME# supported from D0 D3hot D3cold
pci 0000:00:1f.5: PME# disabled
PCI: 0000:00:1f.6 reg 10 io port: [2400, 24ff]
PCI: 0000:00:1f.6 reg 14 io port: [2000, 207f]
pci 0000:00:1f.6: PME# supported from D0 D3hot D3cold
pci 0000:00:1f.6: PME# disabled
PCI: 0000:02:00.0 reg 10 io port: [3000, 30ff]
PCI: 0000:02:00.0 reg 14 32bit mmio: [e0202000, e02020ff]
pci 0000:02:00.0: supports D1
pci 0000:02:00.0: supports D2
pci 0000:02:00.0: PME# supported from D1 D2 D3hot D3cold
pci 0000:02:00.0: PME# disabled
PCI: 0000:02:05.0 reg 10 32bit mmio: [0, fff]
pci 0000:02:05.0: supports D1
pci 0000:02:05.0: supports D2
pci 0000:02:05.0: PME# supported from D0 D1 D2 D3hot D3cold
pci 0000:02:05.0: PME# disabled
PCI: 0000:02:06.0 reg 10 32bit mmio: [e0200000, e0201fff]
pci 0000:00:1e.0: transparent bridge
PCI: bridge 0000:00:1e.0 io port: [3000, 3fff]
PCI: bridge 0000:00:1e.0 32bit mmio: [e0200000, e02fffff]
bus 00 -> node 0
ACPI: PCI Interrupt Routing Table [\_SB_.PCI0._PRT]
ACPI: PCI Interrupt Routing Table [\_SB_.PCI0.PCIB._PRT]
ACPI: PCI Interrupt Link [LNKA] (IRQs *10)
ACPI: PCI Interrupt Link [LNKB] (IRQs *5)
ACPI: PCI Interrupt Link [LNKC] (IRQs *11)
ACPI: PCI Interrupt Link [LNKD] (IRQs *11)
ACPI: PCI Interrupt Link [LNKE] (IRQs 11) *0, disabled.
ACPI: PCI Interrupt Link [LNKF] (IRQs 11) *0, disabled.
ACPI: PCI Interrupt Link [LNKG] (IRQs 11) *0, disabled.
ACPI: PCI Interrupt Link [LNKH] (IRQs *11)
Linux Plug and Play Support v0.97 (c) Adam Belay
pnp: PnP ACPI init
ACPI: bus type pnp registered
pnp: PnP ACPI: found 7 devices
ACPI: ACPI bus type pnp unregistered
PnPBIOS: Disabled by ACPI PNP
PCI: Using ACPI for IRQ routing
AppArmor: AppArmor Filesystem Enabled
ACPI: RTC can wake from S4
system 00:04: ioport range 0x600-0x60f has been reserved
system 00:04: ioport range 0x800-0x80f has been reserved
system 00:04: ioport range 0x1000-0x107f has been reserved
system 00:04: ioport range 0x1180-0x11bf has been reserved
system 00:04: iomem range 0xfec10000-0xfec1ffff has been reserved
pci 0000:02:05.0: CardBus bridge, secondary bus 0000:03
pci 0000:02:05.0:   IO window: 0x003400-0x0034ff
pci 0000:02:05.0:   IO window: 0x003800-0x0038ff
pci 0000:02:05.0:   PREFETCH window: 0x50000000-0x53ffffff
pci 0000:02:05.0:   MEM window: 0x58000000-0x5bffffff
pci 0000:00:1e.0: PCI bridge, secondary bus 0000:02
pci 0000:00:1e.0:   IO window: 0x3000-0x3fff
pci 0000:00:1e.0:   MEM window: 0xe0200000-0xe02fffff
pci 0000:00:1e.0:   PREFETCH window: 0x00000050000000-0x00000053ffffff
pci 0000:00:1e.0: setting latency timer to 64
ACPI: PCI Interrupt Link [LNKE] enabled at IRQ 11
vendor=8086 device=2448
PCI: setting IRQ 11 as level-triggered
pci 0000:02:05.0: PCI INT A -> Link[LNKE] -> GSI 11 (level, low) -> IRQ 11
bus: 00 index 0 io port: [0, ffff]
bus: 00 index 1 mmio: [0, ffffffff]
bus: 02 index 0 io port: [3000, 3fff]
bus: 02 index 1 mmio: [e0200000, e02fffff]
bus: 02 index 2 mmio: [50000000, 53ffffff]
bus: 02 index 3 io port: [0, ffff]
bus: 02 index 4 mmio: [0, ffffffff]
bus: 03 index 0 io port: [3400, 34ff]
bus: 03 index 1 io port: [3800, 38ff]
bus: 03 index 2 mmio: [50000000, 53ffffff]
bus: 03 index 3 mmio: [58000000, 5bffffff]
NET: Registered protocol family 2
IP route cache hash table entries: 32768 (order: 5, 131072 bytes)
TCP established hash table entries: 131072 (order: 8, 1048576 bytes)
TCP bind hash table entries: 65536 (order: 7, 524288 bytes)
TCP: Hash tables configured (established 131072 bind 65536)
TCP reno registered
NET: Registered protocol family 1
Unpacking initramfs...<7>Switched to high resolution mode on CPU 0
 done
Freeing initrd memory: 11115k freed
Simple Boot Flag at 0x36 set to 0x1
Machine check exception polling timer started.
audit: initializing netlink socket (disabled)
type=2000 audit(1235324133.524:1): initialized
highmem bounce pool size: 64 pages
HugeTLB registered 4 MB page size, pre-allocated 0 pages
VFS: Disk quotas dquot_6.5.1
Dquot-cache hash table entries: 1024 (order 0, 4096 bytes)
msgmni has been set to 440
Block layer SCSI generic (bsg) driver version 0.4 loaded (major 254)
io scheduler noop registered
io scheduler anticipatory registered
io scheduler deadline registered
io scheduler cfq registered (default)
pci 0000:00:02.0: Boot video device
vesafb: framebuffer at 0xe8000000, mapped to 0xf8880000, using 6144k, total 32576k
vesafb: mode is 1024x768x16, linelength=2048, pages=20
vesafb: scrolling: redraw
vesafb: Truecolor: size=0:5:6:5, shift=0:11:5:0
bootsplash 3.1.6-2004/03/31: looking for picture...
bootsplash: silentjpeg size 100719 bytes
bootsplash: ...found (1024x768, 38691 bytes, v3).
Console: switching to colour frame buffer device 124x44
fb0: VESA VGA frame buffer device
isapnp: Scanning for PnP cards...
isapnp: No Plug & Play device found
Serial: 8250/16550 driver8 ports, IRQ sharing enabled
ACPI: PCI Interrupt Link [LNKB] enabled at IRQ 5
PCI: setting IRQ 5 as level-triggered
serial 0000:00:1f.6: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
serial 0000:00:1f.6: PCI INT B disabled
PNP: PS/2 Controller [PNP0303:PS2K,PNP0f13:PSM1] at 0x60,0x64 irq 1,12
serio: i8042 KBD port at 0x60,0x64 irq 1
serio: i8042 AUX port at 0x60,0x64 irq 12
mice: PS/2 mouse device common for all mice
cpuidle: using governor ladder
cpuidle: using governor menu
TCP cubic registered
Using IPI No-Shortcut mode
registered taskstats version 1
Freeing unused kernel memory: 316k freed
Write protecting the kernel text: 2336k
Write protecting the kernel read-only data: 1728k
input: AT Translated Set 2 keyboard as /devices/platform/i8042/serio0/input/input0
ACPI: CPU0 (power states: C1[C1] C2[C2])
processor ACPI_CPU:00: registered as cooling_device0
Marking TSC unstable due to TSC halts in idle
thermal LNXTHERM:01: registered as thermal_zone0
ACPI: Thermal Zone [THRM] (53 C)
ACPI: No dock devices found.
SCSI subsystem initialized
libata version 3.00 loaded.
ata_piix 0000:00:1f.1: version 2.12
ata_piix 0000:00:1f.1: enabling device (0005 -> 0007)
ACPI: PCI Interrupt Link [LNKC] enabled at IRQ 11
ata_piix 0000:00:1f.1: PCI INT A -> Link[LNKC] -> GSI 11 (level, low) -> IRQ 11
ata_piix 0000:00:1f.1: setting latency timer to 64
scsi0 : ata_piix
scsi1 : ata_piix
ata1: PATA max UDMA/100 cmd 0x1f0 ctl 0x3f6 bmdma 0x1810 irq 14
ata2: PATA max UDMA/100 cmd 0x170 ctl 0x376 bmdma 0x1818 irq 15
ata1: clearing spurious IRQ
ata1.00: ATA-8: TS32GSSD25-M, V0826, max UDMA/100
ata1.00: 62586880 sectors, multi 0: LBA 
ata1: clearing spurious IRQ
ata1: clearing spurious IRQ
ata1.00: configured for UDMA/100
ata2: clearing spurious IRQ
ata2.00: ATAPI: PHILIPS CD-RW/DVD-ROM CDD5263, UH89, max MWDMA2
ata2: clearing spurious IRQ
ata2: clearing spurious IRQ
ata2.00: configured for MWDMA2
Synaptics Touchpad, model: 1, fw: 5.9, id: 0x236eb3, caps: 0x904713/0x10008
scsi 0:0:0:0: Direct-Access     ATA      TS32GSSD25-M     V082 PQ: 0 ANSI: 5
scsi 1:0:0:0: CD-ROM            PHILIPS  CDRW/DVD CDD5263 UH89 PQ: 0 ANSI: 5
Uniform Multi-Platform E-IDE driver
BIOS EDD facility v0.16 2004-Jun-25, 1 devices found
udevd version 128 started
input: SynPS/2 Synaptics TouchPad as /devices/platform/i8042/serio1/input/input1
usbcore: registered new interface driver usbfs
usbcore: registered new interface driver hub
usbcore: registered new device driver usb
ACPI: PCI Interrupt Link [LNKH] enabled at IRQ 11
ehci_hcd 0000:00:1d.7: PCI INT D -> Link[LNKH] -> GSI 11 (level, low) -> IRQ 11
ehci_hcd 0000:00:1d.7: setting latency timer to 64
ehci_hcd 0000:00:1d.7: EHCI Host Controller
ehci_hcd 0000:00:1d.7: new USB bus registered, assigned bus number 1
ehci_hcd 0000:00:1d.7: debug port 1
ehci_hcd 0000:00:1d.7: cache line size of 32 is not supported
ehci_hcd 0000:00:1d.7: irq 11, io mem 0xe0100000
USB Universal Host Controller Interface driver v3.0
ehci_hcd 0000:00:1d.7: USB 2.0 started, EHCI 1.00, driver 10 Dec 2004
usb usb1: configuration #1 chosen from 1 choice
hub 1-0:1.0: USB hub found
hub 1-0:1.0: 6 ports detected
sd 0:0:0:0: [sda] 62586880 512-byte hardware sectors: (32.0GB/29.8GiB)
sd 0:0:0:0: [sda] Write Protect is off
sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn't support DPO or FUA
sd 0:0:0:0: [sda] 62586880 512-byte hardware sectors: (32.0GB/29.8GiB)
sd 0:0:0:0: [sda] Write Protect is off
sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn't support DPO or FUA
 sda: sda1 sda2 < sda5 sda6 sda7 >
sd 0:0:0:0: [sda] Attached SCSI disk
usb usb1: New USB device found, idVendor=1d6b, idProduct=0002
usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb1: Product: EHCI Host Controller
usb usb1: Manufacturer: Linux 2.6.27.7-9-debug ehci_hcd
usb usb1: SerialNumber: 0000:00:1d.7
ACPI: PCI Interrupt Link [LNKA] enabled at IRQ 10
PCI: setting IRQ 10 as level-triggered
uhci_hcd 0000:00:1d.0: PCI INT A -> Link[LNKA] -> GSI 10 (level, low) -> IRQ 10
uhci_hcd 0000:00:1d.0: setting latency timer to 64
uhci_hcd 0000:00:1d.0: UHCI Host Controller
uhci_hcd 0000:00:1d.0: new USB bus registered, assigned bus number 2
uhci_hcd 0000:00:1d.0: irq 10, io base 0x00001820
usb usb2: configuration #1 chosen from 1 choice
hub 2-0:1.0: USB hub found
hub 2-0:1.0: 2 ports detected
usb usb2: New USB device found, idVendor=1d6b, idProduct=0001
usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb2: Product: UHCI Host Controller
usb usb2: Manufacturer: Linux 2.6.27.7-9-debug uhci_hcd
usb usb2: SerialNumber: 0000:00:1d.0
ACPI: PCI Interrupt Link [LNKD] enabled at IRQ 11
uhci_hcd 0000:00:1d.1: PCI INT B -> Link[LNKD] -> GSI 11 (level, low) -> IRQ 11
uhci_hcd 0000:00:1d.1: setting latency timer to 64
uhci_hcd 0000:00:1d.1: UHCI Host Controller
uhci_hcd 0000:00:1d.1: new USB bus registered, assigned bus number 3
uhci_hcd 0000:00:1d.1: irq 11, io base 0x00001840
usb usb3: configuration #1 chosen from 1 choice
hub 3-0:1.0: USB hub found
hub 3-0:1.0: 2 ports detected
usb usb3: New USB device found, idVendor=1d6b, idProduct=0001
usb usb3: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb3: Product: UHCI Host Controller
usb usb3: Manufacturer: Linux 2.6.27.7-9-debug uhci_hcd
usb usb3: SerialNumber: 0000:00:1d.1
uhci_hcd 0000:00:1d.2: PCI INT C -> Link[LNKC] -> GSI 11 (level, low) -> IRQ 11
uhci_hcd 0000:00:1d.2: setting latency timer to 64
uhci_hcd 0000:00:1d.2: UHCI Host Controller
uhci_hcd 0000:00:1d.2: new USB bus registered, assigned bus number 4
uhci_hcd 0000:00:1d.2: irq 11, io base 0x00001860
usb usb4: configuration #1 chosen from 1 choice
hub 4-0:1.0: USB hub found
hub 4-0:1.0: 2 ports detected
usb usb4: New USB device found, idVendor=1d6b, idProduct=0001
usb usb4: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb4: Product: UHCI Host Controller
usb usb4: Manufacturer: Linux 2.6.27.7-9-debug uhci_hcd
usb usb4: SerialNumber: 0000:00:1d.2
PM: Starting manual resume from disk
kjournald starting.  Commit interval 5 seconds
EXT3 FS on sda6, internal journal
EXT3-fs: mounted filesystem with ordered data mode.
udevd version 128 started
Linux agpgart interface v0.103
agpgart-intel 0000:00:00.0: Intel 855GM Chipset
agpgart-intel 0000:00:00.0: detected 32636K stolen memory
agpgart-intel 0000:00:00.0: AGP aperture is 128M @ 0xe8000000
input: Power Button (FF) as /devices/LNXSYSTM:00/LNXPWRBN:00/input/input2
ACPI: Power Button (FF) [PWRF]
input: Lid Switch as /devices/LNXSYSTM:00/device:00/PNP0C0D:00/input/input3
ACPI: Lid Switch [LID0]
input: Power Button (CM) as /devices/LNXSYSTM:00/device:00/PNP0C0C:00/input/input4
ACPI: Power Button (CM) [PWRB]
ACPI: AC Adapter [ACAD] (on-line)
ACPI: Battery Slot [BAT0] (battery present)
ACPI: WMI: Mapper loaded
acpi device:05: registered as cooling_device1
input: Video Bus as /devices/LNXSYSTM:00/device:00/PNP0A03:00/device:02/input/input5
ACPI: Video Device [GFX0] (multi-head: yes  rom: yes  post: no)
pci_hotplug: PCI Hot Plug PCI Core version: 0.5
intel_rng: FWH not detected
shpchp: Standard Hot Plug PCI Controller Driver version: 0.4
sd 0:0:0:0: Attached scsi generic sg0 type 0
scsi 1:0:0:0: Attached scsi generic sg1 type 5
iTCO_vendor_support: vendor-support=0
iTCO_wdt: Intel TCO WatchDog Timer Driver v1.03 (30-Apr-2008)
iTCO_wdt: Found a ICH4-M TCO device (Version=1, TCOBASE=0x1060)
iTCO_wdt: initialized. heartbeat=30 sec (nowayout=0)
8139cp: 10/100 PCI Ethernet driver v1.3 (Mar 22, 2004)
8139cp 0000:02:00.0: This (id 10ec:8139 rev 10) is not an 8139C+ compatible chip
8139cp 0000:02:00.0: Try the "8139too" driver instead.
Yenta: CardBus bridge found at 0000:02:05.0 [103c:3084]
Yenta: Using CSCINT to route CSC interrupts to PCI
Yenta: Routing CardBus interrupts to PCI
Yenta TI: socket 0000:02:05.0, mfunc 0x01111112, devctl 0x64
8139too Fast Ethernet driver 0.9.28
sr0: scsi3-mmc drive: 1x/24x writer cd/rw xa/form2 cdda tray
Uniform CD-ROM driver Revision: 3.20
sr 1:0:0:0: Attached scsi CD-ROM sr0
Yenta: ISA IRQ mask 0x00d8, PCI irq 11
Socket status: 30000006
Yenta: Raising subordinate bus# of parent bus (#02) from #02 to #06
pcmcia: parent PCI bridge I/O window: 0x3000 - 0x3fff
cs: IO port probe 0x3000-0x3fff: clean.
pcmcia: parent PCI bridge Memory window: 0xe0200000 - 0xe02fffff
pcmcia: parent PCI bridge Memory window: 0x50000000 - 0x53ffffff
input: PC Speaker as /devices/platform/pcspkr/input/input6
vendor=8086 device=2448
8139too 0000:02:00.0: PCI INT A -> Link[LNKA] -> GSI 10 (level, low) -> IRQ 10
eth0: RealTek RTL8139 at 0xf91be000, 00:c0:9f:51:32:d1, IRQ 10
eth0:  Identified 8139 chip type 'RTL-8100B/8139D'
i801_smbus 0000:00:1f.3: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
Intel ICH 0000:00:1f.5: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
Intel ICH 0000:00:1f.5: setting latency timer to 64
rtc_cmos 00:01: rtc core: registered rtc_cmos as rtc0
rtc0: alarms up to one month, y3k
intel8x0_measure_ac97_clock: measured 53963 usecs
intel8x0: clocking to 48000
vendor=8086 device=2448
b43-pci-bridge 0000:02:06.0: PCI INT A -> Link[LNKC] -> GSI 11 (level, low) -> IRQ 11
ssb: Sonics Silicon Backplane found on PCI device 0000:02:06.0
Intel ICH Modem 0000:00:1f.6: PCI INT B -> Link[LNKB] -> GSI 5 (level, low) -> IRQ 5
Intel ICH Modem 0000:00:1f.6: setting latency timer to 64
ALSA /usr/src/linux-2.6.27.7-9/sound/pci/ac97/ac97_codec.c:2154: MC'97 0 converters and GPIO not ready (0x1)
cs: IO port probe 0x100-0x3af: clean.
cs: IO port probe 0x3e0-0x4ff: excluding 0x4d0-0x4d7
cs: IO port probe 0x820-0x8ff: clean.
cs: IO port probe 0xc00-0xcf7: clean.
cs: IO port probe 0xa00-0xaff: clean.
b43-phy0: Broadcom 4306 WLAN found
b43-phy0 debug: Found PHY: Analog 2, Type 2, Revision 2
b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
phy0: Selected rate control algorithm 'pid'
Broadcom 43xx driver loaded [ Features: PMLR, Firmware-ID: FW13 ]
Adding 1502004k swap on /dev/sda5.  Priority:-1 extents:1 across:1502004k
device-mapper: uevent: version 1.0.3
device-mapper: ioctl: 4.14.0-ioctl (2008-04-23) initialised: dm-devel at redhat.com
loop: module loaded
kjournald starting.  Commit interval 5 seconds
EXT3 FS on sda7, internal journal
EXT3-fs: mounted filesystem with ordered data mode.
fuse init (API version 7.9)
type=1505 audit(1235342144.707:2): operation="profile_load" name="/bin/ping" name2="default" pid=1596
type=1505 audit(1235342144.843:3): operation="profile_load" name="/sbin/klogd" name2="default" pid=1623
type=1505 audit(1235342145.087:4): operation="profile_load" name="/sbin/syslog-ng" name2="default" pid=1636
type=1505 audit(1235342145.359:5): operation="profile_load" name="/sbin/syslogd" name2="default" pid=1677
type=1505 audit(1235342145.547:6): operation="profile_load" name="/usr/sbin/avahi-daemon" name2="default" pid=1701
type=1505 audit(1235342145.771:7): operation="profile_load" name="/usr/sbin/identd" name2="default" pid=1712
type=1505 audit(1235342145.963:8): operation="profile_load" name="/usr/sbin/mdnsd" name2="default" pid=1729
type=1505 audit(1235342146.855:9): operation="profile_load" name="/usr/sbin/nscd" name2="default" pid=1747
type=1505 audit(1235342147.123:10): operation="profile_load" name="/usr/sbin/ntpd" name2="default" pid=1757
type=1505 audit(1235342147.359:11): operation="profile_load" name="/usr/sbin/traceroute" name2="default" pid=1767
powernow: This module only works with AMD K7 CPUs
NET: Registered protocol family 10
lo: Disabled Privacy Extensions
ip6_tables: (C) 2000-2006 Netfilter Core Team
ip_tables: (C) 2000-2006 Netfilter Core Team
nf_conntrack version 0.5.0 (16384 buckets, 65536 max)
CONFIG_NF_CT_ACCT is deprecated and will be removed soon. Plase use
nf_conntrack.acct=1 kernel paramater, acct=1 nf_conntrack module option or
sysctl net.netfilter.nf_conntrack_acct=1 to enable it.
[drm] Initialized drm 1.1.0 20060810
pci 0000:00:02.0: PCI INT A -> Link[LNKA] -> GSI 10 (level, low) -> IRQ 10
pci 0000:00:02.0: setting latency timer to 64
[drm] Initialized i915 1.6.0 20060119 on minor 0
pci 0000:00:02.1: setting latency timer to 64
[drm] Initialized i915 1.6.0 20060119 on minor 1
[drm:i915_getparam] *ERROR* Unknown parameter 5
IA-32 Microcode Update Driver: v1.14a <tigran at aivazian.fsnet.co.uk>
firmware: requesting intel-ucode/06-09-05
microcode: CPU0 updated from revision 0x45 to 0x47, date = 11092004 
[drm:i915_getparam] *ERROR* Unknown parameter 5
bootsplash: status on console 0 changed to on
eth0: link down
ADDRCONF(NETDEV_UP): eth0: link is not ready
input: b43-phy0 as /devices/virtual/input/input7
firmware: requesting b43/ucode5.fw
firmware: requesting b43/pcm5.fw
firmware: requesting b43/b0g0initvals5.fw
firmware: requesting b43/b0g0bsinitvals5.fw
b43-phy0: Loading firmware version 410.2160 (2007-05-26 15:32:10)
b43-phy0 debug: Chip initialized
b43-phy0 debug: PIO initialized
Registered led device: b43-phy0::tx
Registered led device: b43-phy0::rx
Registered led device: b43-phy0::radio
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Adding Interface type 2
ADDRCONF(NETDEV_UP): wlan0: link is not ready
NET: Registered protocol family 17
[drm:i915_getparam] *ERROR* Unknown parameter 5
Bluetooth: Core ver 2.13
NET: Registered protocol family 31
Bluetooth: HCI device and connection manager initialized
Bluetooth: HCI socket layer initialized
Bluetooth: L2CAP ver 2.11
Bluetooth: L2CAP socket layer initialized
Bluetooth: RFCOMM socket layer initialized
Bluetooth: RFCOMM TTY layer initialized
Bluetooth: RFCOMM ver 1.10
Bluetooth: SCO (Voice Link) ver 0.6
Bluetooth: SCO socket layer initialized
Bluetooth: BNEP (Ethernet Emulation) ver 1.3
Bluetooth: BNEP filters: protocol multicast
Bridge firewalling registered
pan0: Dropping NETIF_F_UFO since no NETIF_F_HW_CSUM feature.
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=248 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=228 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
wlan0: no IPv6 routers present
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
st: Version 20080504, fixed bufsize 32768, s/g segs 256
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=64 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=44 
wlan0: disassociating by local choice (reason=3)
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
[drm:i915_getparam] *ERROR* Unknown parameter 5
[drm:i915_getparam] *ERROR* Unknown parameter 5
[drm:i915_getparam] *ERROR* Unknown parameter 5
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=248 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=228 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=472 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=452 
SFW2-INext-DROP-DEFLT IN=wlan0 OUT= MAC= SRC=192.168.0.197 DST=224.0.0.251 LEN=436 TOS=0x00 PREC=0x00 TTL=255 ID=0 DF PROTO=UDP SPT=5353 DPT=5353 LEN=416 
ISO 9660 Extensions: Microsoft Joliet Level 3
ISO 9660 Extensions: RRIP_1991A
b43-phy0 ERROR: PHY transmission error
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=146.137.96.7 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=10138 DF PROTO=TCP SPT=39841 DPT=80 WINDOW=589 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B254A0FA3EE62) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=146.6.54.21 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=16034 DF PROTO=TCP SPT=57570 DPT=80 WINDOW=227 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B254A6FD3DC29) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=204.152.186.174 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=58517 DF PROTO=TCP SPT=49825 DPT=80 WINDOW=3394 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B254A25E48C16) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=195.135.221.130 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=45786 DF PROTO=TCP SPT=53541 DPT=80 WINDOW=115 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B254A5ECF5DE5) 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=146.137.96.7 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=47 ID=0 DF PROTO=TCP SPT=80 DPT=39841 WINDOW=0 RES=0x00 RST URGP=0 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=146.137.96.7 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=10139 DF PROTO=TCP SPT=39841 DPT=80 WINDOW=589 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B259D0FA3EE62) 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=146.6.54.21 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=49 ID=0 DF PROTO=TCP SPT=80 DPT=57570 WINDOW=0 RES=0x00 RST URGP=0 
SFW2-INext-DROP-DEFLT-INV IN=wlan0 OUT= MAC=00:90:4b:94:2c:a6:00:30:44:02:76:d2:08:00 SRC=204.152.186.174 DST=192.168.0.197 LEN=40 TOS=0x00 PREC=0x00 TTL=251 ID=0 PROTO=TCP SPT=80 DPT=49825 WINDOW=0 RES=0x00 RST URGP=0 
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=146.137.96.7 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=10144 DF PROTO=TCP SPT=39841 DPT=80 WINDOW=589 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B39B70FA3EE62) 
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=146.137.96.7 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=10145 DF PROTO=TCP SPT=39841 DPT=80 WINDOW=589 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B4E770FA3EE62) 
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=146.6.54.21 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=16037 DF PROTO=TCP SPT=57570 DPT=80 WINDOW=227 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B6F416FD3DC29) 
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=146.137.96.7 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=10146 DF PROTO=TCP SPT=39841 DPT=80 WINDOW=589 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B77F70FA3EE62) 
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=204.152.186.174 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=58524 DF PROTO=TCP SPT=49825 DPT=80 WINDOW=3394 RES=0x00 ACK FIN URGP=0 OPT (0101080A002B8DF725E48C16) 
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX ReassocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=146.6.54.21 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=16038 DF PROTO=TCP SPT=57570 DPT=80 WINDOW=227 RES=0x00 ACK FIN URGP=0 OPT (0101080A002BC3C96FD3DC29) 
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
SFW2-OUT-ERROR IN= OUT=wlan0 SRC=192.168.0.197 DST=195.135.221.130 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=45790 DF PROTO=TCP SPT=53541 DPT=80 WINDOW=115 RES=0x00 ACK FIN URGP=0 OPT (0101080A002BCA0F5ECF5DE5) 
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 ERROR: PHY transmission error
wlan0: No ProbeResp from current AP 00:30:44:02:76:d2 - assume out of range
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authentication with AP 00:30:44:02:76:d2 timed out
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticate with AP 00:30:44:02:76:d2
wlan0: authenticated
wlan0: associate with AP 00:30:44:02:76:d2
wlan0: RX AssocResp from 00:30:44:02:76:d2 (capab=0x431 status=0 aid=2)
wlan0: associated
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
b43-phy0 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
b43-phy0 ERROR: PHY transmission error
b43-phy0 ERROR: PHY transmission error
martian source 255.255.255.255 from 192.168.0.1, on dev wlan0
ll header: ff:ff:ff:ff:ff:ff:00:30:44:02:76:d2:08:00
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm
b43-phy0 debug: Current TX power output: 15.0 dBm, Desired TX power output: 15.0 dBm


----- Original Message ----
From: Michael Buesch <mb at bu3sch.de>
To: John Mountcastle <mtcstle at yahoo.com>
Cc: bcm43xx-dev at lists.berlios.de
Sent: Sunday, February 22, 2009 3:58:21 PM
Subject: Re: I need some help stabaizing b43 for a 4306

On Sunday 22 February 2009 21:45:44 John Mountcastle wrote:
> 
> Michael, configuring a new kernel was a real blast from the past. I haven't  done that in several years but I think I got it done. Funny thing, when I booted the debug kernel, the interface was rock solid for almost an hour, not one single error, then it went sour again. I switched on br43 debugging as you suggested, about half way through the capture. You can see the Tx-mit power messages start. About 60% into the capture I unloaded b43 (rmmod/insmod) and reloaded it in order to get the interface to come back up.
> 
> I hope you can tell me something about what if anything this capture tells us? Or, the net step in debuggging
> 


> b43-phy1 debug: Current TX power output: 14.75 dBm, Desired TX power output: 15.0 dBm
> b43-phy1 debug: Tuning TX-power to bbatt(5), rfatt(4), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)

The first thing I notice, of course, is the very low TX power output of 15dBm.
Can you check iwconfig to check which TX power was selected?
It should write something like this:
wlan0     IEEE 802.11bg  ESSID:"XXXX"  
          Mode:Managed  Frequency:2.XXXX GHz  Access Point: XXXXXXXXX
          Bit Rate=XX Mb/s   Tx-Power=20 dBm  
          .....


So if there's a higher value than 15, please tell me so.
If the value is 15 there, too. Try manually setting the TX power:
iwconfig wlan0 txpower 20

This might be a bug in the card's PROM or possibly the code reading it. I also have a card
where it incorrectly reads the TX power value (but it's 19dBm for me, so it doesn't matter that much for me...).


Besides that, please tell me exactly at which point in the log messages it starts to break.
That's essential information for me.

Also, moving to latest b43 development code might help, too. It has improved TX power
control code which might scale a bit better on your device.
You can do so by downloading compat-wireless: http://wireless.kernel.org/en/users/Download

-- 
Greetings, Michael.



From Larry.Finger at lwfinger.net  Mon Feb 23 07:30:13 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 23 Feb 2009 00:30:13 -0600
Subject: More data on open-source firmware crash
In-Reply-To: <A4655DBE-9711-4DA0-A160-135A8359FF0F@ing.unibs.it>
References: <49A1A331.9080205@lwfinger.net>
	<A4655DBE-9711-4DA0-A160-135A8359FF0F@ing.unibs.it>
Message-ID: <49A24275.7060604@lwfinger.net>

Francesco Gringoli wrote:
> 
> do you mind testing this firmware? It's not the solution, but can help
> us understanding if we should follow this way. Download at
> http://www.ing.unibs.it/~gringoli/fwtest.tar.gz
> 
> Before using this firmware please recompile b43 changing these two
> definitions in b43.h
> 
> #define B43_MARKER_ID_REG               52
> #define B43_MARKER_LINE_REG             53
> 
> I coded the firmware so that it will raise a B43_DEBUGIRQ_MARKER with id
> 10, line 100 if the condition I'm thinking to is true. You will see (I
> hope) in dmesg.

I ran the test firmware until there was a failure. The B43_DEBUGIRQ_MARKER was
not present in the dmesg output.

I also did as Michael suggested and preserved the depth of the tx_status queue,
as well as the maximum depth observed. The latter value is 16; therefore, it is
possible that the queue is being overrun. It is certainly full if the limit
really is 16. I still need to look at the detailed data from the last run, but
it is late here today.

Larry



From mb at bu3sch.de  Mon Feb 23 12:15:54 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 23 Feb 2009 12:15:54 +0100
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <753586.44085.qm@web65414.mail.ac4.yahoo.com>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902222158.21603.mb@bu3sch.de>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
Message-ID: <200902231215.54272.mb@bu3sch.de>

On Monday 23 February 2009 03:40:01 John Mountcastle wrote:
> mtcstle at sybill:~/Desktop> sudo /usr/sbin/iwconfig wlan0
> wlan0     IEEE 802.11bg  ESSID:"MBR-6d2"  
>           Mode:Managed  Frequency:2.417 GHz  Access Point: 00:30:44:02:76:D2   
>           Bit Rate=1 Mb/s   Tx-Power=27 dBm   
>           Retry min limit:7   RTS thr:off   Fragment thr=2352 B   
>           Encryption key:7761-7465-7266-616C-6C30-3030-30   Security mode:open
>           Power Management:off
>           Link Quality=51/100  Signal level:-5 dBm  Noise level=-17 dBm
>           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> 
> Note that while b43-phy0 debug says desired output is 15.0dBm, iwconfig says it's askigng for 27. 

Right, that's what I suspected.

Can you try wireless-compat? It prints additional debugging info for this.
compat is easy to install, usually. Just download it and do make; make install in the
extracted source tree. You don't need to change your kernel for this. You can run it
on a standard distribution kernel, usually.

-- 
Greetings, Michael.


From mb at bu3sch.de  Mon Feb 23 12:18:25 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 23 Feb 2009 12:18:25 +0100
Subject: More data on open-source firmware crash
In-Reply-To: <49A24275.7060604@lwfinger.net>
References: <49A1A331.9080205@lwfinger.net>
	<A4655DBE-9711-4DA0-A160-135A8359FF0F@ing.unibs.it>
	<49A24275.7060604@lwfinger.net>
Message-ID: <200902231218.25215.mb@bu3sch.de>

On Monday 23 February 2009 07:30:13 Larry Finger wrote:
> Francesco Gringoli wrote:
> > 
> > do you mind testing this firmware? It's not the solution, but can help
> > us understanding if we should follow this way. Download at
> > http://www.ing.unibs.it/~gringoli/fwtest.tar.gz
> > 
> > Before using this firmware please recompile b43 changing these two
> > definitions in b43.h
> > 
> > #define B43_MARKER_ID_REG               52
> > #define B43_MARKER_LINE_REG             53
> > 
> > I coded the firmware so that it will raise a B43_DEBUGIRQ_MARKER with id
> > 10, line 100 if the condition I'm thinking to is true. You will see (I
> > hope) in dmesg.
> 
> I ran the test firmware until there was a failure. The B43_DEBUGIRQ_MARKER was
> not present in the dmesg output.
> 
> I also did as Michael suggested and preserved the depth of the tx_status queue,
> as well as the maximum depth observed. The latter value is 16; therefore, it is
> possible that the queue is being overrun. It is certainly full if the limit
> really is 16. I still need to look at the detailed data from the last run, but
> it is late here today.

Note again that I expect the "tx status queue is full" check at the _start_ of the TX
processing in firmware. Because if we started TX and later figure out the status queue
is full, we can't really do anything about it. So we'd have to check that before even
fetching the frame from the DMA.

-- 
Greetings, Michael.


From mb at bu3sch.de  Mon Feb 23 13:25:36 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 23 Feb 2009 13:25:36 +0100
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <200902231215.54272.mb@bu3sch.de>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
	<200902231215.54272.mb@bu3sch.de>
Message-ID: <200902231325.36602.mb@bu3sch.de>

On Monday 23 February 2009 12:15:54 Michael Buesch wrote:
> On Monday 23 February 2009 03:40:01 John Mountcastle wrote:
> > mtcstle at sybill:~/Desktop> sudo /usr/sbin/iwconfig wlan0
> > wlan0     IEEE 802.11bg  ESSID:"MBR-6d2"  
> >           Mode:Managed  Frequency:2.417 GHz  Access Point: 00:30:44:02:76:D2   
> >           Bit Rate=1 Mb/s   Tx-Power=27 dBm   
> >           Retry min limit:7   RTS thr:off   Fragment thr=2352 B   
> >           Encryption key:7761-7465-7266-616C-6C30-3030-30   Security mode:open
> >           Power Management:off
> >           Link Quality=51/100  Signal level:-5 dBm  Noise level=-17 dBm
> >           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
> >           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> > 
> > Note that while b43-phy0 debug says desired output is 15.0dBm, iwconfig says it's askigng for 27. 
> 
> Right, that's what I suspected.
> 
> Can you try wireless-compat? It prints additional debugging info for this.
> compat is easy to install, usually. Just download it and do make; make install in the
> extracted source tree. You don't need to change your kernel for this. You can run it
> on a standard distribution kernel, usually.
> 

I made a patch which fixes up a possible PROM screwup:
http://bu3sch.de/patches/wireless-testing/20090223-1324/patches/018-b43-txpwr-sprom-fixes.patch

You can apply that to compat-wireless:
	cd compat-wireless-2009-02-XX
	patch -p1 < 018-b43-txpwr-sprom-fixes.patch

-- 
Greetings, Michael.


From mb at bu3sch.de  Mon Feb 23 13:31:05 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 23 Feb 2009 13:31:05 +0100
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <200902231325.36602.mb@bu3sch.de>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902231215.54272.mb@bu3sch.de> <200902231325.36602.mb@bu3sch.de>
Message-ID: <200902231331.05180.mb@bu3sch.de>

On Monday 23 February 2009 13:25:36 Michael Buesch wrote:
> On Monday 23 February 2009 12:15:54 Michael Buesch wrote:
> > On Monday 23 February 2009 03:40:01 John Mountcastle wrote:
> > > mtcstle at sybill:~/Desktop> sudo /usr/sbin/iwconfig wlan0
> > > wlan0     IEEE 802.11bg  ESSID:"MBR-6d2"  
> > >           Mode:Managed  Frequency:2.417 GHz  Access Point: 00:30:44:02:76:D2   
> > >           Bit Rate=1 Mb/s   Tx-Power=27 dBm   
> > >           Retry min limit:7   RTS thr:off   Fragment thr=2352 B   
> > >           Encryption key:7761-7465-7266-616C-6C30-3030-30   Security mode:open
> > >           Power Management:off
> > >           Link Quality=51/100  Signal level:-5 dBm  Noise level=-17 dBm
> > >           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
> > >           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> > > 
> > > Note that while b43-phy0 debug says desired output is 15.0dBm, iwconfig says it's askigng for 27. 
> > 
> > Right, that's what I suspected.
> > 
> > Can you try wireless-compat? It prints additional debugging info for this.
> > compat is easy to install, usually. Just download it and do make; make install in the
> > extracted source tree. You don't need to change your kernel for this. You can run it
> > on a standard distribution kernel, usually.
> > 
> 
> I made a patch which fixes up a possible PROM screwup:
> http://bu3sch.de/patches/wireless-testing/20090223-1324/patches/018-b43-txpwr-sprom-fixes.patch
> 
> You can apply that to compat-wireless:
> 	cd compat-wireless-2009-02-XX
> 	patch -p1 < 018-b43-txpwr-sprom-fixes.patch
> 

Ok, seems this doesn't apply to compat-wireless.
Use this one, which was diffed against today's compat-wireless:
http://bu3sch.de/patches/misc/018-b43-txpwr-sprom-fixes.patch

-- 
Greetings, Michael.


From mtcstle at yahoo.com  Mon Feb 23 13:52:04 2009
From: mtcstle at yahoo.com (mtcstle at yahoo.com)
Date: Mon, 23 Feb 2009 12:52:04 +0000
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <200902231331.05180.mb@bu3sch.de>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com><200902231215.54272.mb@bu3sch.de>
	<200902231325.36602.mb@bu3sch.de><200902231331.05180.mb@bu3sch.de>
Message-ID: <542871928-1235393617-cardhu_decombobulator_blackberry.rim.net-471349595-@bxe1290.bisx.prod.on.blackberry>

Good morning Michael. So, to be sure I've got it right; I want the second patch and not the first. I need to apply it to this morning's compat sources, not two days ago?

Cheers

John
Sent via BlackBerry by AT&T

-----Original Message-----
From: Michael Buesch <mb at bu3sch.de>

Date: Mon, 23 Feb 2009 13:31:05 
To: <bcm43xx-dev at lists.berlios.de>
Subject: Re: I need some help stabaizing b43 for a 4306


On Monday 23 February 2009 13:25:36 Michael Buesch wrote:
> On Monday 23 February 2009 12:15:54 Michael Buesch wrote:
> > On Monday 23 February 2009 03:40:01 John Mountcastle wrote:
> > > mtcstle at sybill:~/Desktop> sudo /usr/sbin/iwconfig wlan0
> > > wlan0     IEEE 802.11bg  ESSID:"MBR-6d2"  
> > >           Mode:Managed  Frequency:2.417 GHz  Access Point: 00:30:44:02:76:D2   
> > >           Bit Rate=1 Mb/s   Tx-Power=27 dBm   
> > >           Retry min limit:7   RTS thr:off   Fragment thr=2352 B   
> > >           Encryption key:7761-7465-7266-616C-6C30-3030-30   Security mode:open
> > >           Power Management:off
> > >           Link Quality=51/100  Signal level:-5 dBm  Noise level=-17 dBm
> > >           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
> > >           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> > > 
> > > Note that while b43-phy0 debug says desired output is 15.0dBm, iwconfig says it's askigng for 27. 
> > 
> > Right, that's what I suspected.
> > 
> > Can you try wireless-compat? It prints additional debugging info for this.
> > compat is easy to install, usually. Just download it and do make; make install in the
> > extracted source tree. You don't need to change your kernel for this. You can run it
> > on a standard distribution kernel, usually.
> > 
> 
> I made a patch which fixes up a possible PROM screwup:
> http://bu3sch.de/patches/wireless-testing/20090223-1324/patches/018-b43-txpwr-sprom-fixes.patch
> 
> You can apply that to compat-wireless:
> 	cd compat-wireless-2009-02-XX
> 	patch -p1 < 018-b43-txpwr-sprom-fixes.patch
> 

Ok, seems this doesn't apply to compat-wireless.
Use this one, which was diffed against today's compat-wireless:
http://bu3sch.de/patches/misc/018-b43-txpwr-sprom-fixes.patch

-- 
Greetings, Michael.
_______________________________________________
Bcm43xx-dev mailing list
Bcm43xx-dev at lists.berlios.de
https://lists.berlios.de/mailman/listinfo/bcm43xx-dev

From mb at bu3sch.de  Mon Feb 23 13:58:59 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 23 Feb 2009 13:58:59 +0100
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <542871928-1235393617-cardhu_decombobulator_blackberry.rim.net-471349595-@bxe1290.bisx.prod.on.blackberry>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902231331.05180.mb@bu3sch.de>
	<542871928-1235393617-cardhu_decombobulator_blackberry.rim.net-471349595-@bxe1290.bisx.prod.on.blackberry>
Message-ID: <200902231358.59980.mb@bu3sch.de>

On Monday 23 February 2009 13:52:04 mtcstle at yahoo.com wrote:
> Good morning Michael. So, to be sure I've got it right; I want the second patch and not the first. I need to apply it to this morning's compat sources, not two days ago?

right.

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Mon Feb 23 16:31:05 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 23 Feb 2009 09:31:05 -0600
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <753586.44085.qm@web65414.mail.ac4.yahoo.com>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>	<200902212040.45689.mb@bu3sch.de>	<27179.70560.qm@web65414.mail.ac4.yahoo.com>	<200902222158.21603.mb@bu3sch.de>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
Message-ID: <49A2C139.6020308@lwfinger.net>

John,

I would like to see what is in your SPROM concerning the power settings. Please
run the following commands:

SPROM=$(find /sys -name ssb_sprom)
echo $SPROM
sudo cat $SPROM

and post the output.

Thanks,

Larry



From mtcstle at yahoo.com  Mon Feb 23 17:59:29 2009
From: mtcstle at yahoo.com (John Mountcastle)
Date: Mon, 23 Feb 2009 08:59:29 -0800 (PST)
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <49A2C139.6020308@lwfinger.net>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
	<27179.70560.qm@web65414.mail.ac4.yahoo.com>
	<200902222158.21603.mb@bu3sch.de>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
	<49A2C139.6020308@lwfinger.net>
Message-ID: <734161.62938.qm@web65412.mail.ac4.yahoo.com>


Here's a thought, every time I unload b43 and reload it, my indicated signal strength (NetworkManager) is 85%. Shortly it drops off to 65%, then 51%. then it usually fails. I ad to go find a wire because I couldn't keep the 4306 up, long enough to reach yahoo.

Michael, I applied you patch and compiled. I'll install and load the ne drivers and let you know what TXmit power indicates.

Larry, here's the SPROM you wanted.

Password: 
sybill:~ # SPROM=$(find /sys -name ssb_sprom)
sybill:~ # echo $SPROM
/sys/devices/pci0000:00/0000:00:1e.0/0000:02:06.0/ssb_sprom
sybill:~ # cat $SPROM
01400000F4123C1020430080020002000010001800000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9000944BA62CFFFFFFFFFFFFFFFFFFFFFFFFFFFF60369A1193FBA5FEFFFFFFFF3C000000000000003E000D00FFFF00000000000000000152
sybill:~ # 




----- Original Message ----
From: Larry Finger <Larry.Finger at lwfinger.net>
To: John Mountcastle <mtcstle at yahoo.com>
Cc: Michael Buesch <mb at bu3sch.de>; bcm43xx-dev at lists.berlios.de
Sent: Monday, February 23, 2009 10:31:05 AM
Subject: Re: I need some help stabaizing b43 for a 4306

John,

I would like to see what is in your SPROM concerning the power settings. Please
run the following commands:

SPROM=$(find /sys -name ssb_sprom)
echo $SPROM
sudo cat $SPROM

and post the output.

Thanks,

Larry


From Larry.Finger at lwfinger.net  Mon Feb 23 18:16:05 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 23 Feb 2009 11:16:05 -0600
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <734161.62938.qm@web65412.mail.ac4.yahoo.com>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
	<27179.70560.qm@web65414.mail.ac4.yahoo.com>
	<200902222158.21603.mb@bu3sch.de>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
	<49A2C139.6020308@lwfinger.net>
	<734161.62938.qm@web65412.mail.ac4.yahoo.com>
Message-ID: <49A2D9D5.6070802@lwfinger.net>

John Mountcastle wrote:
> Here's a thought, every time I unload b43 and reload it, my indicated signal strength (NetworkManager) is 85%. Shortly it drops off to 65%, then 51%. then it usually fails. I ad to go find a wire because I couldn't keep the 4306 up, long enough to reach yahoo.
> 
> Michael, I applied you patch and compiled. I'll install and load the ne drivers and let you know what TXmit power indicates.
> 
> Larry, here's the SPROM you wanted.

Your SPROM contains a maxpbg value of 0x3C, which translates to 15 dBm - exactly
what the program is trying to maintain.

I have data for a number of BCM4306 SPROM's due to my fixing of the Bluetooth
coexistence problem for Ubuntu users. Every one of them that I looked at has
that same value for maxpbg, which probably explains the poor performance.

Larry



From Larry.Finger at lwfinger.net  Mon Feb 23 18:36:12 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 23 Feb 2009 11:36:12 -0600
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <734161.62938.qm@web65412.mail.ac4.yahoo.com>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
	<27179.70560.qm@web65414.mail.ac4.yahoo.com>
	<200902222158.21603.mb@bu3sch.de>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
	<49A2C139.6020308@lwfinger.net>
	<734161.62938.qm@web65412.mail.ac4.yahoo.com>
Message-ID: <49A2DE8C.5010304@lwfinger.net>

More food for thought:

My BCM4306/2 in a Cardbus format has a maxpbg value that translates to 10 dBm.
It routinely transmits at 5-6 Mb/s in my normal setting. When I reprogrammed the
SPROM to 20 dBm, it would start out at the above rate, then rapidly drop to 1
Mb/s. It looked as if the radio was overheating. It is possible that the patch
of today will make things worse, not better.

Larry



From mtcstle at yahoo.com  Mon Feb 23 19:02:49 2009
From: mtcstle at yahoo.com (John Mountcastle)
Date: Mon, 23 Feb 2009 10:02:49 -0800 (PST)
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <49A2DE8C.5010304@lwfinger.net>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
	<27179.70560.qm@web65414.mail.ac4.yahoo.com>
	<200902222158.21603.mb@bu3sch.de>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
	<49A2C139.6020308@lwfinger.net>
	<734161.62938.qm@web65412.mail.ac4.yahoo.com>
	<49A2DE8C.5010304@lwfinger.net>
Message-ID: <309276.55542.qm@web65416.mail.ac4.yahoo.com>


Yes, I'd say results are mixed. B43 now says it wants 20dBm and it's getting 16.75 but iwconfig says rate is only 1Mb/s and I can't keep the link up long enough to be usefull.

If the SPROM was wrong all along, why does it work fine with bcm43xx?

Incidentally, when I rebooted and while the 4306 was still connected, NetworkManager said he saw 100%.

b43-phy0 debug: [TX power]  current = 16.75 dBm,  desired = 20.0 dBm,  max = 20.0
b43-phy0 debug: [TX power deltas]  3.25 dBm   =>   bbatt-delta = 2,  rfatt-delta = -2
b43-phy0 debug: Adjusting TX power
b43-phy0 debug: Tuning TX-power to bbatt(2), rfatt(0), tx_control(0x30), tx_bias(0x00), tx_magn(0x00)
sybill:~ # iwconfig wlan0
wlan0     IEEE 802.11bg  ESSID:"MBR-6d2"  
          Mode:Managed  Frequency:2.417 GHz  Access Point: 00:30:44:02:76:D2   
          Bit Rate=1 Mb/s   Tx-Power=27 dBm   
          Retry min limit:7   RTS thr:off   Fragment thr=2352 B   
          Encryption key:7761-7465-7266-616C-6C30-3030-30   Security mode:open
          Power Management:off
          Link Quality=85/70  Signal level:-45 dBm  Noise level=-68 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0


Regards

John

----- Original Message ----
From: Larry Finger <Larry.Finger at lwfinger.net>
To: John Mountcastle <mtcstle at yahoo.com>
Cc: Michael Buesch <mb at bu3sch.de>; bcm43xx-dev at lists.berlios.de
Sent: Monday, February 23, 2009 12:36:12 PM
Subject: Re: I need some help stabaizing b43 for a 4306

More food for thought:

My BCM4306/2 in a Cardbus format has a maxpbg value that translates to 10 dBm.
It routinely transmits at 5-6 Mb/s in my normal setting. When I reprogrammed the
SPROM to 20 dBm, it would start out at the above rate, then rapidly drop to 1
Mb/s. It looked as if the radio was overheating. It is possible that the patch
of today will make things worse, not better.

Larry


From mb at bu3sch.de  Mon Feb 23 19:47:39 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 23 Feb 2009 19:47:39 +0100
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <49A2DE8C.5010304@lwfinger.net>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<734161.62938.qm@web65412.mail.ac4.yahoo.com>
	<49A2DE8C.5010304@lwfinger.net>
Message-ID: <200902231947.40065.mb@bu3sch.de>

On Monday 23 February 2009 18:36:12 Larry Finger wrote:
> More food for thought:
> 
> My BCM4306/2 in a Cardbus format has a maxpbg value that translates to 10 dBm.
> It routinely transmits at 5-6 Mb/s in my normal setting. When I reprogrammed the
> SPROM to 20 dBm, it would start out at the above rate, then rapidly drop to 1
> Mb/s. It looked as if the radio was overheating.

This has nothing to do with overheating, so let's reduce FUD a bit. ;)

The attenuation is not linear. There's a certain threshold where it inverts.
Let's explain it in simple numbers. Let's say the attenuation A is from 0-9.
The actual power output O would looke something like this:

A=   0  1  2  3  4  5  6  7  8  9
O=   0  1  2  3  4  4  3  2  1  0

This is true for broadcom cards and some atheros cards.
So as we decrease attennuation, there's a point where output power is inverted.
In this simple example we must not go below an A value of 5.

The actual threshold is different for each device and you're pretty much likely
hitting it. The control algorithm is unaware of this threshold and it will scale
the attenuation down which results in lower power which will result in scaling down...


So John, back to your problem. I think you're pretty much lost with it. Like thousands
of other people (including me) are lost with crappy broadcom devices.
I suggest you go and buy something sane instead.

I cannot help you anymore with this.

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Mon Feb 23 19:54:54 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 23 Feb 2009 12:54:54 -0600
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <309276.55542.qm@web65416.mail.ac4.yahoo.com>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
	<27179.70560.qm@web65414.mail.ac4.yahoo.com>
	<200902222158.21603.mb@bu3sch.de>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
	<49A2C139.6020308@lwfinger.net>
	<734161.62938.qm@web65412.mail.ac4.yahoo.com>
	<49A2DE8C.5010304@lwfinger.net>
	<309276.55542.qm@web65416.mail.ac4.yahoo.com>
Message-ID: <49A2F0FE.10908@lwfinger.net>

John Mountcastle wrote:
> Yes, I'd say results are mixed. B43 now says it wants 20dBm and it's getting 16.75 but iwconfig says rate is only 1Mb/s and I can't keep the link up long enough to be usefull.
> 
> If the SPROM was wrong all along, why does it work fine with bcm43xx?

Many parts of the power control have undergone major changes. For most
interfaces, these changes made them work better; however, yours may be different.

If you want to try what happens with lower power, you can change the line in
Michaels patch that looks like

+		max_pwr = INT_TO_Q52(20);

You started with the equivalent of "INT_TO_Q52(15)" - what happens if the 20 is
replaced by 12 or 10?

Larry


From mtcstle at yahoo.com  Mon Feb 23 20:16:24 2009
From: mtcstle at yahoo.com (John Mountcastle)
Date: Mon, 23 Feb 2009 11:16:24 -0800 (PST)
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <200902231947.40065.mb@bu3sch.de>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<734161.62938.qm@web65412.mail.ac4.yahoo.com>
	<49A2DE8C.5010304@lwfinger.net> <200902231947.40065.mb@bu3sch.de>
Message-ID: <934397.87362.qm@web65402.mail.ac4.yahoo.com>


OK, it sounds like a pretty tough nut to crack. I'm not sure if I can get a new card as it's kinda built into this laptop, or, maybe I'm wrong. Do you think I might be able to crack this thing open and put in a replacement device?

Anyway, thanks a lot for your help. I learned a little in the bargain so I won't call the adventure a total loss.

Probably my best move is just to go back to openSUSE 10.3 with the bcm43xx driver. Or I might try blacklisting b43 and usng ndiswrapper. I've used it before with excellent results.

Regards

John


----- Original Message ----
From: Michael Buesch <mb at bu3sch.de>
To: Larry Finger <Larry.Finger at lwfinger.net>
Cc: John Mountcastle <mtcstle at yahoo.com>; bcm43xx-dev at lists.berlios.de
Sent: Monday, February 23, 2009 1:47:39 PM
Subject: Re: I need some help stabaizing b43 for a 4306

On Monday 23 February 2009 18:36:12 Larry Finger wrote:
> More food for thought:
> 
> My BCM4306/2 in a Cardbus format has a maxpbg value that translates to 10 dBm.
> It routinely transmits at 5-6 Mb/s in my normal setting. When I reprogrammed the
> SPROM to 20 dBm, it would start out at the above rate, then rapidly drop to 1
> Mb/s. It looked as if the radio was overheating.

This has nothing to do with overheating, so let's reduce FUD a bit. ;)

The attenuation is not linear. There's a certain threshold where it inverts.
Let's explain it in simple numbers. Let's say the attenuation A is from 0-9.
The actual power output O would looke something like this:

A=   0  1  2  3  4  5  6  7  8  9
O=   0  1  2  3  4  4  3  2  1  0

This is true for broadcom cards and some atheros cards.
So as we decrease attennuation, there's a point where output power is inverted.
In this simple example we must not go below an A value of 5.

The actual threshold is different for each device and you're pretty much likely
hitting it. The control algorithm is unaware of this threshold and it will scale
the attenuation down which results in lower power which will result in scaling down...


So John, back to your problem. I think you're pretty much lost with it. Like thousands
of other people (including me) are lost with crappy broadcom devices.
I suggest you go and buy something sane instead.

I cannot help you anymore with this.

-- 
Greetings, Michael.



From mtcstle at yahoo.com  Mon Feb 23 20:22:28 2009
From: mtcstle at yahoo.com (John Mountcastle)
Date: Mon, 23 Feb 2009 11:22:28 -0800 (PST)
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <49A2F0FE.10908@lwfinger.net>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
	<27179.70560.qm@web65414.mail.ac4.yahoo.com>
	<200902222158.21603.mb@bu3sch.de>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
	<49A2C139.6020308@lwfinger.net>
	<734161.62938.qm@web65412.mail.ac4.yahoo.com>
	<49A2DE8C.5010304@lwfinger.net>
	<309276.55542.qm@web65416.mail.ac4.yahoo.com>
	<49A2F0FE.10908@lwfinger.net>
Message-ID: <111919.18043.qm@web65416.mail.ac4.yahoo.com>


Can I just edit Michael's patch and apply it again just like I did the first time:

cd $(COMPAT_SRC_DIR)
patch -p1 < $(PATCH_FILE)

Regards

John


----- Original Message ----
From: Larry Finger <Larry.Finger at lwfinger.net>
To: John Mountcastle <mtcstle at yahoo.com>
Cc: Michael Buesch <mb at bu3sch.de>; bcm43xx-dev at lists.berlios.de
Sent: Monday, February 23, 2009 1:54:54 PM
Subject: Re: I need some help stabaizing b43 for a 4306

John Mountcastle wrote:
> Yes, I'd say results are mixed. B43 now says it wants 20dBm and it's getting 16.75 but iwconfig says rate is only 1Mb/s and I can't keep the link up long enough to be usefull.
> 
> If the SPROM was wrong all along, why does it work fine with bcm43xx?

Many parts of the power control have undergone major changes. For most
interfaces, these changes made them work better; however, yours may be different.

If you want to try what happens with lower power, you can change the line in
Michaels patch that looks like

+        max_pwr = INT_TO_Q52(20);

You started with the equivalent of "INT_TO_Q52(15)" - what happens if the 20 is
replaced by 12 or 10?

Larry



From Larry.Finger at lwfinger.net  Mon Feb 23 20:30:05 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 23 Feb 2009 13:30:05 -0600
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <111919.18043.qm@web65416.mail.ac4.yahoo.com>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
	<27179.70560.qm@web65414.mail.ac4.yahoo.com>
	<200902222158.21603.mb@bu3sch.de>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
	<49A2C139.6020308@lwfinger.net>
	<734161.62938.qm@web65412.mail.ac4.yahoo.com>
	<49A2DE8C.5010304@lwfinger.net>
	<309276.55542.qm@web65416.mail.ac4.yahoo.com>
	<49A2F0FE.10908@lwfinger.net>
	<111919.18043.qm@web65416.mail.ac4.yahoo.com>
Message-ID: <49A2F93D.5080509@lwfinger.net>

John Mountcastle wrote:
> Can I just edit Michael's patch and apply it again just like I did the first time:
> 
> cd $(COMPAT_SRC_DIR)
> patch -p1 < $(PATCH_FILE)
> 
> Regards
> 
> John

Yes.

Larry



From mb at bu3sch.de  Mon Feb 23 22:52:26 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 23 Feb 2009 22:52:26 +0100
Subject: [PATCH] b43: Remove bogus integer truncation warnings
Message-ID: <200902232252.26991.mb@bu3sch.de>

"warning: large integer implicitly truncated to unsigned type"

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Virtual fists were already shaked, so I need to hurry up to fixup my crap. :P


Index: wireless-testing/drivers/net/wireless/b43/phy_g.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_g.c	2009-02-23 22:38:56.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/phy_g.c	2009-02-23 22:41:28.000000000 +0100
@@ -968,13 +968,13 @@ b43_radio_interference_mitigation_enable
 		b43_phy_maskset(dev, 0x04A8, 0xFFF0, 0x0006);
 		b43_phy_maskset(dev, 0x04A2, 0xF0FF, 0x0800);
 		b43_phy_maskset(dev, 0x04A0, 0xF0FF, 0x0500);
 		b43_phy_maskset(dev, 0x04A2, 0xFFF0, 0x000B);
 
 		if (phy->rev >= 3) {
-			b43_phy_mask(dev, 0x048A, ~0x8000);
+			b43_phy_mask(dev, 0x048A, (u16)~0x8000);
 			b43_phy_maskset(dev, 0x0415, 0x8000, 0x36D8);
 			b43_phy_maskset(dev, 0x0416, 0x8000, 0x36D8);
 			b43_phy_maskset(dev, 0x0417, 0xFE00, 0x016D);
 		} else {
 			b43_phy_set(dev, 0x048A, 0x1000);
 			b43_phy_maskset(dev, 0x048A, 0x9FFF, 0x2000);
Index: wireless-testing/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/wa.c	2009-02-23 18:26:03.000000000 +0100
+++ wireless-testing/drivers/net/wireless/b43/wa.c	2009-02-23 22:43:00.000000000 +0100
@@ -379,13 +379,13 @@ static void b43_wa_altagc(struct b43_wld
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0, 254);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 1, 13);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 2, 19);
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 3, 25);
 	}
 
-	b43_phy_maskset(dev, B43_PHY_CCKSHIFTBITS_WA, ~0xFF00, 0x5700);
+	b43_phy_maskset(dev, B43_PHY_CCKSHIFTBITS_WA, (u16)~0xFF00, 0x5700);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x1A), ~0x007F, 0x000F);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x1A), ~0x3F80, 0x2B80);
 	b43_phy_maskset(dev, B43_PHY_ANTWRSETT, 0xF0FF, 0x0300);
 	b43_radio_set(dev, 0x7A, 0x0008);
 	b43_phy_maskset(dev, B43_PHY_N1P1GAIN, ~0x000F, 0x0008);
 	b43_phy_maskset(dev, B43_PHY_P1P2GAIN, ~0x0F00, 0x0600);
@@ -397,25 +397,25 @@ static void b43_wa_altagc(struct b43_wld
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x88), ~0x00FF, 0x001C);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x88), ~0x3F00, 0x0200);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x96), ~0x00FF, 0x001C);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x89), ~0x00FF, 0x0020);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x89), ~0x3F00, 0x0200);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x82), ~0x00FF, 0x002E);
-	b43_phy_maskset(dev, B43_PHY_OFDM(0x96), ~0xFF00, 0x1A00);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x96), (u16)~0xFF00, 0x1A00);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x81), ~0x00FF, 0x0028);
-	b43_phy_maskset(dev, B43_PHY_OFDM(0x81), ~0xFF00, 0x2C00);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x81), (u16)~0xFF00, 0x2C00);
 	if (phy->rev == 1) {
 		b43_phy_write(dev, B43_PHY_PEAK_COUNT, 0x092B);
 		b43_phy_maskset(dev, B43_PHY_OFDM(0x1B), ~0x001E, 0x0002);
 	} else {
 		b43_phy_mask(dev, B43_PHY_OFDM(0x1B), ~0x001E);
 		b43_phy_write(dev, B43_PHY_OFDM(0x1F), 0x287A);
 		b43_phy_maskset(dev, B43_PHY_LPFGAINCTL, ~0x000F, 0x0004);
 		if (phy->rev >= 6) {
 			b43_phy_write(dev, B43_PHY_OFDM(0x22), 0x287A);
-			b43_phy_maskset(dev, B43_PHY_LPFGAINCTL, ~0xF000, 0x3000);
+			b43_phy_maskset(dev, B43_PHY_LPFGAINCTL, (u16)~0xF000, 0x3000);
 		}
 	}
 	b43_phy_maskset(dev, B43_PHY_DIVSRCHIDX, 0x8080, 0x7874);
 	b43_phy_write(dev, B43_PHY_OFDM(0x8E), 0x1C00);
 	if (phy->rev == 1) {
 		b43_phy_maskset(dev, B43_PHY_DIVP1P2GAIN, ~0x0F00, 0x0600);

-- 
Greetings, Michael.


From francesco.gringoli at ing.unibs.it  Wed Feb 25 18:33:38 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Wed, 25 Feb 2009 18:33:38 +0100
Subject: b43 on via cpu
Message-ID: <F3D220F3-FF05-475C-BD09-194115F02551@ing.unibs.it>

Hello everyone,

I tried without success to run b43 on a via (cpu) pc and I got a very  
strange behavior. Everything seems to work fine for a random time  
going from 60s to a multiple of 60s. Then dmesg reports that a direct  
probe failed and that b43 lost the connection to the AP.

I tried both ubuntu and slackware (thinking it could be due to ubuntu  
network manager) and always with kernel 2.6.29-rc2-wl, the same I'm  
using on all my development platforms (and I never got problems with).  
I had the same problem with a number of BCM adapters so it was not due  
to the wifi adapters.

I took the same hardware and same kernel to other platforms not via  
based and the problem disappeared: the only difference was the VIA cpu  
instead of anyone else not VIA.

If it can worth I can report more details on the VIA architecture I  
was using, but I don't know if there is anyone who cares about :-)

Cheers,
-FG



From mb at bu3sch.de  Wed Feb 25 18:43:37 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 25 Feb 2009 18:43:37 +0100
Subject: b43 on via cpu
In-Reply-To: <F3D220F3-FF05-475C-BD09-194115F02551@ing.unibs.it>
References: <F3D220F3-FF05-475C-BD09-194115F02551@ing.unibs.it>
Message-ID: <200902251843.37278.mb@bu3sch.de>

On Wednesday 25 February 2009 18:33:38 Francesco Gringoli wrote:
> but I don't know if there is anyone who cares about :-)

Well, indeed. ;)

You should throw your broken hw away, if it causes harmful interference.
It's as simple as that. Problem solved. :)

Hardware simply often _is_ crap and causes harmful interference.
One example being an S3 video card which caused a parport extender card
to output extremely crappy signals. I simply bought a new video adapter
and all interference problems disappeared.
Often such interference doesn't matter. I bet the parport adapter still
worked with most common parport devices. But I had a milling machine connected
to it which moved a tiny bit on each interference storm. So I could move the joints
with glxgears. ;)

So I can certainly imagine that interference can break a wireless adapter
completely. In fact, I do own a motherboard where 90% of broadcom wireless NICs
fail to work on. It clearly is caused by interference, because they work fine
if I put a shielding extender between the board and the NIC.

-- 
Greetings, Michael.


From mtcstle at yahoo.com  Sat Feb 28 19:56:38 2009
From: mtcstle at yahoo.com (John Mountcastle)
Date: Sat, 28 Feb 2009 10:56:38 -0800 (PST)
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <49A2F93D.5080509@lwfinger.net>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
	<27179.70560.qm@web65414.mail.ac4.yahoo.com>
	<200902222158.21603.mb@bu3sch.de>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
	<49A2C139.6020308@lwfinger.net>
	<734161.62938.qm@web65412.mail.ac4.yahoo.com>
	<49A2DE8C.5010304@lwfinger.net>
	<309276.55542.qm@web65416.mail.ac4.yahoo.com>
	<49A2F0FE.10908@lwfinger.net>
	<111919.18043.qm@web65416.mail.ac4.yahoo.com>
	<49A2F93D.5080509@lwfinger.net>
Message-ID: <331871.9365.qm@web65415.mail.ac4.yahoo.com>


I want to thank you guys once again for your advice, last week on my BCM4306 problem. I've tried 20dBm, 15, 12, and 10dBm, with varying degrees of success. Which, is just a fancy way of saying, no real success.

I'm going back to the unpatched, 2-23 sources of last week to get to a known state and will try the open source firmware which is reported to work with b43.

If it doesn't, and frankly, I'm not hopefull, is there any way of going back to bcm43xx. It'd be a shame to abandon a card which worked perfectly well, before, even if it's not as open as we'd like. A lot of us are stuck with this device in otherwise perfectly good laptops.

One more question and i hope you don't mind, it's off topic but it's related to my quest. I hadven't done any C programming in 10 years but when I used to do a lot of it, if I patche a source file and ran 'make', it figured out what needed to be done and just recompiled and liknked the changed bits. Over the last week, every time I changed phy_g.c, make calmly repied, 'nothing to be done.'  What am I forgetting?

All the best,

John



----- Original Message ----
From: Larry Finger <Larry.Finger at lwfinger.net>
To: John Mountcastle <mtcstle at yahoo.com>
Cc: Michael Buesch <mb at bu3sch.de>; bcm43xx-dev at lists.berlios.de
Sent: Monday, February 23, 2009 2:30:05 PM
Subject: Re: I need some help stabaizing b43 for a 4306

John Mountcastle wrote:
> Can I just edit Michael's patch and apply it again just like I did the first time:
> 
> cd $(COMPAT_SRC_DIR)
> patch -p1 < $(PATCH_FILE)
> 
> Regards
> 
> John

Yes.

Larry


From Larry.Finger at lwfinger.net  Sat Feb 28 21:07:41 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 28 Feb 2009 14:07:41 -0600
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <331871.9365.qm@web65415.mail.ac4.yahoo.com>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<200902212040.45689.mb@bu3sch.de>
	<27179.70560.qm@web65414.mail.ac4.yahoo.com>
	<200902222158.21603.mb@bu3sch.de>
	<753586.44085.qm@web65414.mail.ac4.yahoo.com>
	<49A2C139.6020308@lwfinger.net>
	<734161.62938.qm@web65412.mail.ac4.yahoo.com>
	<49A2DE8C.5010304@lwfinger.net>
	<309276.55542.qm@web65416.mail.ac4.yahoo.com>
	<49A2F0FE.10908@lwfinger.net>
	<111919.18043.qm@web65416.mail.ac4.yahoo.com>
	<49A2F93D.5080509@lwfinger.net>
	<331871.9365.qm@web65415.mail.ac4.yahoo.com>
Message-ID: <49A9998D.4040801@lwfinger.net>

John Mountcastle wrote:
> I want to thank you guys once again for your advice, last week on my BCM4306 problem. I've tried 20dBm, 15, 12, and 10dBm, with varying degrees of success. Which, is just a fancy way of saying, no real success.
> 
> I'm going back to the unpatched, 2-23 sources of last week to get to a known state and will try the open source firmware which is reported to work with b43.

Getting open-source firmware won't make a difference as firmware is not your
problem. The main advantage is that the new firmware will have a GPL license and
can be included with the distros. No one is expecting it to be better than  the
proprietary firmware.

> If it doesn't, and frankly, I'm not hopefull, is there any way of going back to bcm43xx. It'd be a shame to abandon a card which worked perfectly well, before, even if it's not as open as we'd like. A lot of us are stuck with this device in otherwise perfectly good laptops.

The short answer is "No". With bcm43xx, the MAC layer was controlled by
something called SoftMAC. It was buggy and limited, which is why it was replaced
by mac80211. It would require a great deal of work to get SoftMAC to work with
modern kernels. You could modify bcm43xx to work with mac80211, but then you
would have the equivalent of b43 as that is essentially how b43 and b43legacy
were produced.

What I would suggest is that you build a 2.6.23 kernel and test bcm43xx that way
to see if something changed in your hardware, or if it really is b43 that fails
with your device.

> One more question and i hope you don't mind, it's off topic but it's related to my quest. I hadven't done any C programming in 10 years but when I used to do a lot of it, if I patche a source file and ran 'make', it figured out what needed to be done and just recompiled and liknked the changed bits. Over the last week, every time I changed phy_g.c, make calmly repied, 'nothing to be done.'  What am I forgetting?

That would indicate that your Makefile doesn't have a dependency on phy_g.c.

Larry



From mb at bu3sch.de  Sat Feb 28 21:57:21 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 28 Feb 2009 21:57:21 +0100
Subject: I need some help stabaizing b43 for a 4306
In-Reply-To: <49A9998D.4040801@lwfinger.net>
References: <785047.31485.qm@web65411.mail.ac4.yahoo.com>
	<331871.9365.qm@web65415.mail.ac4.yahoo.com>
	<49A9998D.4040801@lwfinger.net>
Message-ID: <200902282157.21398.mb@bu3sch.de>

On Saturday 28 February 2009 21:07:41 Larry Finger wrote:
> > One more question and i hope you don't mind, it's off topic but it's related to my quest. I hadven't done any C programming in 10 years but when I used to do a lot of it, if I patche a source file and ran 'make', it figured out what needed to be done and just recompiled and liknked the changed bits. Over the last week, every time I changed phy_g.c, make calmly repied, 'nothing to be done.'  What am I forgetting?
> 
> That would indicate that your Makefile doesn't have a dependency on phy_g.c.

No dependencies don't work in compat wireless. You need to make clean first.

-- 
Greetings, Michael.


