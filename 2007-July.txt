From smenard at dranem.org  Sun Jul  1 15:06:12 2007
From: smenard at dranem.org (steve menard)
Date: Sun, 01 Jul 2007 10:06:12 -0300
Subject: bcm43xx ubuntu 704 acer 5020
Message-ID: <4687A6C4.2030502@dranem.org>

Wanted to say thanks all for writing bcm43xx

I am able to use 4318 on Acer 5024 turion34 with Ubuntu 7.04. live cd

All  I need to do is grab the firmware.   ;-)  since it usually isn't
available with distributions
usual rmmod / modprobe dance with softmac version and
cannot forget the
modprobe acerhk
echo on > /proc/drivers/acerhk/wirelesslan  [or somesuch thanks
tab-auto-finish] ;-)
 to turn it on

Again I wated to THANK everyone for their great work getting this to work

[long overdue thanks] since I have used bcm43xx for about a year or
longer ;-)
very much appreciated all the hard work

steve menard



From larry.finger at lwfinger.net  Sun Jul  1 17:16:45 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 01 Jul 2007 10:16:45 -0500
Subject: bcm43xx ubuntu 704 acer 5020
In-Reply-To: <4687A6C4.2030502@dranem.org>
References: <4687A6C4.2030502@dranem.org>
Message-ID: <4687C55D.7080001@lwfinger.net>

steve menard wrote:
> Wanted to say thanks all for writing bcm43xx
> 
> I am able to use 4318 on Acer 5024 turion34 with Ubuntu 7.04. live cd
> 
> All  I need to do is grab the firmware.   ;-)  since it usually isn't
> available with distributions

Due to intellectual property issues, and the lack of cooperation by Broadcom, the firmware can never 
be part of Linux distributions. The most we can do is publish the locations of drivers for other 
OS's and keep fwcutter current so that the firmware can be extracted.

> usual rmmod / modprobe dance with softmac version and
> cannot forget the
> modprobe acerhk
> echo on > /proc/drivers/acerhk/wirelesslan  [or somesuch thanks
> tab-auto-finish] ;-)
>  to turn it on
> 
> Again I wated to THANK everyone for their great work getting this to work
> 
> [long overdue thanks] since I have used bcm43xx for about a year or
> longer ;-)
> very much appreciated all the hard work

On behalf of everyone that has worked on the bcm43xx project, you are welcome. Both versions of the 
driver have their flaws, but they work pretty well given the difficulty of reverse engineering such 
complicated devices.

Larry



From badmuthahubbard at gmail.com  Mon Jul  2 00:15:36 2007
From: badmuthahubbard at gmail.com (Chuckk Hubbard)
Date: Sun, 1 Jul 2007 18:15:36 -0400
Subject: [bcm43xx-users] 4311 still not receiving
In-Reply-To: <467D47BE.6010209@lwfinger.net>
References: <8200bab70706212154j35430a5fyf9b822042d5c98e3@mail.gmail.com>
	<1182493086.24958.61.camel@dv>
	<8200bab70706220106w54fe05d3wa9224c57016628b3@mail.gmail.com>
	<467BE1A4.2080406@lwfinger.net>
	<8200bab70706221507m4a8c9aa1rfa6306e40ea03aa1@mail.gmail.com>
	<467C89D4.60603@lwfinger.net>
	<8200bab70706230818m4fa5da0ax6186d9e40e970a00@mail.gmail.com>
	<467D47BE.6010209@lwfinger.net>
Message-ID: <8200bab70707011515g4932fde6iffd1758434038095@mail.gmail.com>

On 6/23/07, Larry Finger <larry.finger at lwfinger.net> wrote:
>
> Chuckk Hubbard wrote:
> > Larry, I think I forgot to mention something... might the fact that it's
> > a 64-bit machine and a 64-bit distro possibly make it not work?
>
> No, it shouldn't matter. I use a 64-bit distro on an AMD 64 X2 cpu.
>
> I just looked to see what Synaptic is. As it messed up your wired network
> as well as wireless,
> something must have gotten destroyed in the networking section. Does your
> distro have a "repair"
> option? If so, try it.



I haven't found a repair option; it is not possible to downgrade is what I
was told.  I have gone through this process several times since then-
reinstalling, compiling a 2.6.22 kernel, having wireless, doing some
updates, losing the wireless.  I noticed a couple of things...
I believe the package that is updating that is killing my wireless is the
linux-image-2.6.18 etc. package.
Also, a message I kept getting said that the driver I had was version 22,
and the program (iwconfig) only supported up to 20.

I've now reinstalled and put a hold on the linux image package, although I
haven't compiled my new kernel just yet.
I also tried buying an Intel mini PCI express wireless card that I saw
highly recommended for Linux, but my BIOS is configured to reject it.
Never buy Gateway.

-Chuckk

-- 
http://www.badmuthahubbard.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070701/1b50b2ac/attachment.html>

From larry.finger at lwfinger.net  Mon Jul  2 01:33:02 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 01 Jul 2007 18:33:02 -0500
Subject: [bcm43xx-users] 4311 still not receiving
In-Reply-To: <8200bab70707011515g4932fde6iffd1758434038095@mail.gmail.com>
References: <8200bab70706212154j35430a5fyf9b822042d5c98e3@mail.gmail.com>	
	<1182493086.24958.61.camel@dv>	
	<8200bab70706220106w54fe05d3wa9224c57016628b3@mail.gmail.com>	
	<467BE1A4.2080406@lwfinger.net>	
	<8200bab70706221507m4a8c9aa1rfa6306e40ea03aa1@mail.gmail.com>	
	<467C89D4.60603@lwfinger.net>	
	<8200bab70706230818m4fa5da0ax6186d9e40e970a00@mail.gmail.com>	
	<467D47BE.6010209@lwfinger.net>
	<8200bab70707011515g4932fde6iffd1758434038095@mail.gmail.com>
Message-ID: <468839AE.7090401@lwfinger.net>

Chuckk Hubbard wrote:
> On 6/23/07, *Larry Finger* <larry.finger at lwfinger.net 
> <mailto:larry.finger at lwfinger.net>> wrote:
> 
>     Chuckk Hubbard wrote:
>      > Larry, I think I forgot to mention something... might the fact
>     that it's
>      > a 64-bit machine and a 64-bit distro possibly make it not work?
> 
>     No, it shouldn't matter. I use a 64-bit distro on an AMD 64 X2 cpu.
> 
>     I just looked to see what Synaptic is. As it messed up your wired
>     network as well as wireless,
>     something must have gotten destroyed in the networking section. Does
>     your distro have a "repair"
>     option? If so, try it. 
> 
> 
> 
> I haven't found a repair option; it is not possible to downgrade is what 
> I was told.  I have gone through this process several times since then- 
> reinstalling, compiling a 2.6.22 kernel, having wireless, doing some 
> updates, losing the wireless.  I noticed a couple of things...
> I believe the package that is updating that is killing my wireless is 
> the linux-image-2.6.18 etc. package.
> Also, a message I kept getting said that the driver I had was version 
> 22, and the program (iwconfig) only supported up to 20.
> 
> I've now reinstalled and put a hold on the linux image package, although 
> I haven't compiled my new kernel just yet.
> I also tried buying an Intel mini PCI express wireless card that I saw 
> highly recommended for Linux, but my BIOS is configured to reject it.
> Never buy Gateway.

Download and install the 64-bit version of openSUSE 10.2. Then upgrade the kernel to 2.6.21 and all 
will be well. You will find NetworkManager to be a very nice way to connect.

Larry


From comphappy at gmail.com  Mon Jul  2 03:58:11 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sun, 1 Jul 2007 18:58:11 -0700
Subject: [bcm43xx-users] 4311 still not receiving
In-Reply-To: <468839AE.7090401@lwfinger.net>
References: <8200bab70706212154j35430a5fyf9b822042d5c98e3@mail.gmail.com>
	<1182493086.24958.61.camel@dv>
	<8200bab70706220106w54fe05d3wa9224c57016628b3@mail.gmail.com>
	<467BE1A4.2080406@lwfinger.net>
	<8200bab70706221507m4a8c9aa1rfa6306e40ea03aa1@mail.gmail.com>
	<467C89D4.60603@lwfinger.net>
	<8200bab70706230818m4fa5da0ax6186d9e40e970a00@mail.gmail.com>
	<467D47BE.6010209@lwfinger.net>
	<8200bab70707011515g4932fde6iffd1758434038095@mail.gmail.com>
	<468839AE.7090401@lwfinger.net>
Message-ID: <b2d05de20707011858o159a8ddcl61be6b806ee70574@mail.gmail.com>

On 7/1/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> Chuckk Hubbard wrote:
> > On 6/23/07, *Larry Finger* <larry.finger at lwfinger.net
> > <mailto:larry.finger at lwfinger.net>> wrote:
> >
> >     Chuckk Hubbard wrote:
> >      > Larry, I think I forgot to mention something... might the fact
> >     that it's
> >      > a 64-bit machine and a 64-bit distro possibly make it not work?
> >
> >     No, it shouldn't matter. I use a 64-bit distro on an AMD 64 X2 cpu.
> >
> >     I just looked to see what Synaptic is. As it messed up your wired
> >     network as well as wireless,
> >     something must have gotten destroyed in the networking section. Does
> >     your distro have a "repair"
> >     option? If so, try it.
> >
> >
> >
> > I haven't found a repair option; it is not possible to downgrade is what
> > I was told.  I have gone through this process several times since then-
> > reinstalling, compiling a 2.6.22 kernel, having wireless, doing some
> > updates, losing the wireless.  I noticed a couple of things...
> > I believe the package that is updating that is killing my wireless is
> > the linux-image-2.6.18 etc. package.
> > Also, a message I kept getting said that the driver I had was version
> > 22, and the program (iwconfig) only supported up to 20.
> >
> > I've now reinstalled and put a hold on the linux image package, although
> > I haven't compiled my new kernel just yet.
> > I also tried buying an Intel mini PCI express wireless card that I saw
> > highly recommended for Linux, but my BIOS is configured to reject it.
> > Never buy Gateway.
>
> Download and install the 64-bit version of openSUSE 10.2. Then upgrade the kernel to 2.6.21 and all
> will be well. You will find NetworkManager to be a very nice way to connect.
>
> Larry
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
I have done the same thing with Fedora with a gateway with 4311 every
so often i have to restart the computer and the wireless access point,
but other than that it works fine.

-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From Eyes-Killer at gmx.de  Tue Jul  3 21:05:00 2007
From: Eyes-Killer at gmx.de (Florian Erfurth)
Date: Tue, 03 Jul 2007 21:05:00 +0200
Subject: F7 with newer kernel
Message-ID: <468A9DDC.3060701@gmx.de>

David Woodhouse wrote:

 > On Thu, 2007-06-28 at 13:30 -0700, Ehud Gavron wrote:
 >> [SNIP]
 >
 > You shouldn't need to rebuild the whole kernel. Just make sure
 > kernel-devel is installed and build the drivers you want.
 >
 > sudo yum install kernel-devel
 > cd
 > git-clone
 > 
git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-dev.git cd
 > wireless-dev/drivers/net/wireless/mac80211/bcm43xx make -C
 > /lib/modules/`uname -r`/build SUBDIRS=`pwd` modules sudo rmmod
 > bcm43xx-mac80211 \; insmod ./bcm43xx-mac80211.ko
 >
Hi, I've tried that. Unfortunatelly replacing bcm43xx-mac80211.ko doesn't
help. I've got the same problem. :(
Idea?

cu Floh


From rec3d at yahoo.com  Thu Jul  5 01:40:27 2007
From: rec3d at yahoo.com (Jhonie Walker)
Date: Wed, 4 Jul 2007 16:40:27 -0700 (PDT)
Subject: Unauthorized Network card (ERROR 104) HP Notebook
Message-ID: <623358.90700.qm@web50602.mail.re2.yahoo.com>




       
____________________________________________________________________________________
Get the Yahoo! toolbar and be alerted to new email wherever you're surfing.
http://new.toolbar.yahoo.com/toolbar/features/mail/index.php


From rec3d at yahoo.com  Thu Jul  5 01:49:21 2007
From: rec3d at yahoo.com (Jhonie Walker)
Date: Wed, 4 Jul 2007 16:49:21 -0700 (PDT)
Subject: Unauthorized Network card (ERROR 104)
Message-ID: <680556.79575.qm@web50601.mail.re2.yahoo.com>

Hello, I tell you my situation:

I have an hp nx6110 notebook, it came with no "wifi"
card. I have got a mini pci card from a Dell notebook
(Dell P/N Y8029 DW1370) it is a broadcom 4318, so I
decided to put it in the mini pci slot of the hp. The
result was the "104-Unauthorized Network device..." at
bootup.

I decided trying to change the device subsystem id to
somewhat that hp likes (i.e 103c:099c)using sprom tool
(ssprom-mod) in a knoppix 5.0 booteable environment.
To do so I inserted the minipci card after bootup
(with the machine turned on) so linux booted and
detected it, and the BIOS never saw it inserted).

I always checked that the symbol # was present at the
console in all the attempts but but no luck.

Whathever I tried it didn't gave any results. "no
value", etc.

The driver for the card I was using was the one
included with knoppix 5.0.

I also tried to get data with ethtool (v.3 and v.5)
but it says it cannot read EEPROM data.

This is the info listed with lspci -n and lspci -nv
for the wifi card.

0000:02:04.0 Network controller: Broadcom Corporation
BCM4318 [AirForce One 54g] 802.11g Wireless LAN
Controller (rev 02)
        Subsystem: Dell: Unknown device 0005
        Flags: bus master, fast devsel, latency 64,
IRQ 22
        Memory at d0002000 (32-bit, non-prefetchable)
[size=8K]
0000:02:04.0 0280: 14e4:4318 (rev 02)
        Subsystem: 1028:0005
        Flags: bus master, fast devsel, latency 64,
IRQ 22
        Memory at d0002000 (32-bit, non-prefetchable)
[size=8K]


I hope someone can help me. Maybe I am using the tool
in a wrong way.


Thanks in advance! 


P.S.: Sorry for my english.




      ____________________________________________________________________________________
Fussy? Opinionated? Impossible to please? Perfect.  Join Yahoo!'s user panel and lay it on us. http://surveylink.yahoo.com/gmrs/yahoo_panel_invite.asp?a=7 



From proski at gnu.org  Thu Jul  5 06:59:22 2007
From: proski at gnu.org (Pavel Roskin)
Date: Thu, 05 Jul 2007 00:59:22 -0400
Subject: Unauthorized Network card (ERROR 104)
In-Reply-To: <680556.79575.qm@web50601.mail.re2.yahoo.com>
References: <680556.79575.qm@web50601.mail.re2.yahoo.com>
Message-ID: <1183611562.5202.6.camel@dv>

On Wed, 2007-07-04 at 16:49 -0700, Jhonie Walker wrote:

> Whathever I tried it didn't gave any results. "no
> value", etc.
[skip]
> I hope someone can help me. Maybe I am using the tool
> in a wrong way.

Then maybe you should give the exact command line and the exact error
messages?

-- 
Regards,
Pavel Roskin



From rdeaster at wbs.edu  Thu Jul  5 07:44:23 2007
From: rdeaster at wbs.edu (Robert Easter)
Date: Thu, 05 Jul 2007 00:44:23 -0500
Subject: bcm4312 on again, off again
In-Reply-To: <mailman.59.1183543281.11773.bcm43xx-dev@lists.berlios.de>
References: <mailman.59.1183543281.11773.bcm43xx-dev@lists.berlios.de>
Message-ID: <468C8537.9030302@wbs.edu>

It took a BS programmer over five hours, but he got my bcm4318 chip 
talking to my computer with the NDISWrapper and a kernel build.  Before 
that the wireless was showing on the laptop's wifi switch light but not 
making up to the computer to actually use the signal.  Now, after six 
days, it suddenly stops.  Give it a few days, and it's on again.  Any clues?




From gavron at Wetwork.Net  Thu Jul  5 08:10:00 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Wed, 04 Jul 2007 23:10:00 -0700
Subject: bcm4312 on again, off again
In-Reply-To: <468C8537.9030302@wbs.edu>
References: <mailman.59.1183543281.11773.bcm43xx-dev@lists.berlios.de>
	<468C8537.9030302@wbs.edu>
Message-ID: <468C8B38.20607@Wetwork.Net>

You know, people read this list TO HELP PEOPLE.  That's right.  I'm up 
at 2307 my time hoping that I can provide some information that will 
help you get your bcm43xx device functional, or that failing that I can 
help you provide information so the folks that work between the 
firmware, the reverse-engineered speficiations, and the driver can make 
it work.

NOTHING would please me more than to see your device work.
I feel I would not be happy if it were not to work.
And yet, unfortunately, in this imperfect world I must work with some 
imperfections... like....

Zero diagnostic information.

Ndiswrapper typically works in about 5 seconds, so not only no 
diagnostic information, but your "BS programmer" is 4 hours 59 minutes 
and 55 seconds full of "BS".

You don't mention your kernel version.

You don't include a uname -a  or a dmesg | grep bcm43

Now let's talk English
"chip talking" -- meaningless
"a kernel build" -- meaningless
"wireless was showing" -- meaningless
"wifi switch light" -- meaningless
"not making up to" -- meaningless
"actually use the signal" -- meaningless
"it suddenly stops" -- almost meaningless.  SOmething that might have 
been previously defined (but wasn't) no longer words.
"it's on again" -- same comment as above
"Any clues" -- no, you don't have any

SO... I'd say "good luck" but it looks like you don't have any of that 
either.

Ehud


Robert Easter wrote:
> It took a BS programmer over five hours, but he got my bcm4318 chip 
> talking to my computer with the NDISWrapper and a kernel build.  Before 
> that the wireless was showing on the laptop's wifi switch light but not 
> making up to the computer to actually use the signal.  Now, after six 
> days, it suddenly stops.  Give it a few days, and it's on again.  Any clues?
>
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070704/3b801056/attachment.bin>

From mouw at nl.linux.org  Thu Jul  5 10:14:36 2007
From: mouw at nl.linux.org (Erik Mouw)
Date: Thu, 5 Jul 2007 10:14:36 +0200
Subject: bcm4312 on again, off again
In-Reply-To: <468C8537.9030302@wbs.edu>
References: <mailman.59.1183543281.11773.bcm43xx-dev@lists.berlios.de>
	<468C8537.9030302@wbs.edu>
Message-ID: <20070705081436.GE30803@gateway.home>

On Thu, Jul 05, 2007 at 12:44:23AM -0500, Robert Easter wrote:
> It took a BS programmer over five hours, but he got my bcm4318 chip 
> talking to my computer with the NDISWrapper and a kernel build.

It should have taken him only one kernel build to get the 4318 working
with the open source driver bcm43xx driver shipped with the latest -rc
kernel.

>  Before 
> that the wireless was showing on the laptop's wifi switch light but not 
> making up to the computer to actually use the signal.  Now, after six 
> days, it suddenly stops.  Give it a few days, and it's on again.  Any clues?

Eh yeah. No driver loaded means no working network device. Hardly a
surprise, I'd say.

If you're using ndiswrapper right now, you're at the vendor's whim. We
don't have the source of the Windows driver you loaded, so we can't
help you. You *might* try talking to your vendor, but I don't think
they consider Linux + ndiswrapper as a supported configuration for
their driver. They joys of proprietary software...

If you want people over here to be able to help you, use the open
source driver.

Oh, and please be precise: your subject says you're using a bcm4312,
but in the body you talk about a bcm4318.


Erik
[using a 4318 with stock linux-2.6.22-rc7]

-- 
They're all fools. Don't worry. Darwin may be slow, but he'll
eventually get them. -- Matthew Lammers in alt.sysadmin.recovery
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070705/1a2e09d1/attachment.pgp>

From johannes at sipsolutions.net  Thu Jul  5 10:39:26 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 05 Jul 2007 10:39:26 +0200
Subject: Unauthorized Network card (ERROR 104)
In-Reply-To: <680556.79575.qm@web50601.mail.re2.yahoo.com>
References: <680556.79575.qm@web50601.mail.re2.yahoo.com>
Message-ID: <1183624767.3818.4.camel@johannes.berg>

On Wed, 2007-07-04 at 16:49 -0700, Jhonie Walker wrote:

> I decided trying to change the device subsystem id to
> somewhat that hp likes (i.e 103c:099c)using sprom tool
> (ssprom-mod) in a knoppix 5.0 booteable environment.

That's not going to help since the BIOS blocks all access to the card;
you need to modify the card in a different computer that accepts it.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070705/72396f0e/attachment.pgp>

From mistamaila at gmail.com  Thu Jul  5 10:51:56 2007
From: mistamaila at gmail.com (John H.)
Date: Thu, 5 Jul 2007 11:51:56 +0300
Subject: dell e1505 bcm43xx driver, bcm4311 chipset?
Message-ID: <5b9417770707050151t3209ec4cpc0e2bb10d038e0b9@mail.gmail.com>

I was wondering if, on fedora 7 now with 2.6.21 kernel, it is possible
to use bcm43xx driver with this device and get 54mb/s and wpa support?

I have the firmware installed, etc.

I just had many problems last time, as it wouldn't get 54mb/s, etc.


From jennytharayil at gmail.com  Thu Jul  5 17:03:23 2007
From: jennytharayil at gmail.com (jenny tc)
Date: Thu, 5 Jul 2007 20:33:23 +0530
Subject: broadcom corporation dell wireless 1390 WLAN mini PCI card not
	working with bcm43xx driver
Message-ID: <47b5508f0707050803g6e6674f5v327c2271b3438388@mail.gmail.com>

hai all,

 I have a compaq presario v6000  laptop
The lspci displays the nic as "Broadcom Corporation Dell Wireless 1390  WLAN
Mini-PCI Card (rev 01)" . I'm able to load the driver , can do iwlist,
iwconf . I ran wpa supplicant as  " /usr/sbin/wpa_supplicant  -c
wireless.con -i eth0 -D wext -B" . It's not reporting any error. But i'm not
able to ping. How can i make my network card up ?
any suggestion is appreciated

-Jenny
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070705/cf22a059/attachment.html>

From tony at vroon.org  Thu Jul  5 17:09:25 2007
From: tony at vroon.org (Tony Vroon)
Date: Thu, 05 Jul 2007 16:09:25 +0100
Subject: broadcom corporation dell wireless 1390 WLAN mini PCI card not
	working with bcm43xx driver
In-Reply-To: <47b5508f0707050803g6e6674f5v327c2271b3438388@mail.gmail.com>
References: <47b5508f0707050803g6e6674f5v327c2271b3438388@mail.gmail.com>
Message-ID: <468D09A5.7080305@vroon.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

jenny tc wrote:
I ran wpa supplicant as  " /usr/sbin/wpa_supplicant  -c
> wireless.con -i eth0 -D wext -B" . It's not reporting any error.

Could you try adding -dd to the command line in order to get some
debugging output? Perhaps pipe all that output into a file using &>
wpa_supplicant.output.txt and then attach that to your follow-up mail.

That will show us whether you association is timing out, or whether the
key setup is failing because you don't have the necessary key handling
in SoftMAC. (Or perhaps something else is going wrong, but those two
seem most common)

Regards,
Tony V.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.4 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGjQmlp5vW4rUFj5oRCJ8vAKCJ0kCdYiAAzuEcAo+2ISNOg9HgJgCePYI8
GXP0siBuTi4eIB6HwrBdXpg=
=6Cb0
-----END PGP SIGNATURE-----


From jennytharayil at gmail.com  Thu Jul  5 17:36:15 2007
From: jennytharayil at gmail.com (jenny tc)
Date: Thu, 5 Jul 2007 21:06:15 +0530
Subject: broadcom corporation dell wireless 1390 WLAN mini PCI card not
	working with bcm43xx driver
In-Reply-To: <468D09A5.7080305@vroon.org>
References: <47b5508f0707050803g6e6674f5v327c2271b3438388@mail.gmail.com>
	<468D09A5.7080305@vroon.org>
Message-ID: <47b5508f0707050836v7400e341jc6da301757e3511@mail.gmail.com>

Hai ,

as requested i'm attaching the dmesg output

the sequence of commands that producde this output are
#/sbin/modprobe bcm43xx
#/sbin/ifconfig eth0 192.168.2.102/22
#/sbin/iwconfig eth0 essid HCAC
#/sbin/iwlist scanning
#/usr/sbin/wpa_supplicant  -c wireless.conf  -i eth0  -D wext  -B
#ping 192.168.1.5

From tony at vroon.org  Thu Jul  5 17:43:37 2007
From: tony at vroon.org (Tony Vroon)
Date: Thu, 05 Jul 2007 16:43:37 +0100
Subject: broadcom corporation dell wireless 1390 WLAN mini PCI card not
	working with bcm43xx driver
In-Reply-To: <47b5508f0707050803g6e6674f5v327c2271b3438388@mail.gmail.com>
References: <47b5508f0707050803g6e6674f5v327c2271b3438388@mail.gmail.com>
Message-ID: <468D11A9.9080508@vroon.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

jenny tc wrote:
I ran wpa supplicant as  " /usr/sbin/wpa_supplicant  -c
> wireless.con -i eth0 -D wext -B" . It's not reporting any error.

I will clarify, could you run the following command:

wpa_supplicant -c wireless.con -i eth0 -Dwext -B -dd &>
wpa_supplicant.output.txt

While your dmesg output is handy to have, it doesn't tell the complete
story and I'd like to hear wpa_supplicant's side of things.

Regards,
Tony V.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.4 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGjRGpp5vW4rUFj5oRCFY/AJ9m0Qwm0TrFtvEXTl6UsVjvl8pu1gCgl9ki
X/yF/5yJ3EQAIr0gHD2EmWo=
=0GVw
-----END PGP SIGNATURE-----


From rec3d at yahoo.com  Thu Jul  5 20:07:38 2007
From: rec3d at yahoo.com (Jhonie Walker)
Date: Thu, 5 Jul 2007 11:07:38 -0700 (PDT)
Subject: Unauthorized Network card (ERROR 104)
In-Reply-To: <1183611562.5202.6.camel@dv>
Message-ID: <56075.52323.qm@web50610.mail.re2.yahoo.com>


--- Pavel Roskin <proski at gnu.org> wrote:

> On Wed, 2007-07-04 at 16:49 -0700, Jhonie Walker
> wrote:
> 
> > Whathever I tried it didn't gave any results. "no
> > value", etc.
> [skip]
> > I hope someone can help me. Maybe I am using the
> tool
> > in a wrong way.
> 
> Then maybe you should give the exact command line
> and the exact error
> messages?
> 
> -- 
> Regards,
> Pavel Roskin
> 
> 
Here is a copy of the command lines I used and its
results:

root at 1[sprom]# ethtool -i eth1
driver: bcm43xx
version: 2.6.17
firmware-version:
bus-info: 0000:02:04.0

root at 1[sprom]# ./ssb-sprom --subp GET
No input data

root at 1[sprom]# ./sprommod.sh eth1
Interface doesn't accept private ioctl...
read_sprom (8BE7): No such device
Could not read SPROM (255)

root at 1[sprom]# ethtool -e eth1
Cannot get EEPROM data: Operation not supported

root at 1[sprom]# ./ssb-sprom -v
Broadcom-SSB SPROM data modification tool version 001



I also noticed during knoppix startup that in the
"text mode screen" where all the info of the
initialization is shown appears a message 

related to this hardware, this is the message:
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not
available or load failed.

I wonder if it has something to do with the above
results.

I tried loading the .fw with the fwcutter tool,
everything goes ok, but I believe that the system must
be restarted in order to apply changes 

(Thing very difficult to do with a Knoppix and a non
authorized mini pci card inserted in the system).

Thanks for your help!

Greetings.


 
____________________________________________________________________________________
Bored stiff? Loosen up... 
Download and play hundreds of games for free on Yahoo! Games.
http://games.yahoo.com/games/front


From comphappy at gmail.com  Fri Jul  6 02:51:21 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Thu, 5 Jul 2007 16:51:21 -0800
Subject: bcm4312 on again, off again
In-Reply-To: <468C8537.9030302@wbs.edu>
References: <mailman.59.1183543281.11773.bcm43xx-dev@lists.berlios.de>
	<468C8537.9030302@wbs.edu>
Message-ID: <b2d05de20707051751h390de390p20523b9b7f35094f@mail.gmail.com>

On 7/4/07, Robert Easter <rdeaster at wbs.edu> wrote:
> It took a BS programmer over five hours, but he got my bcm4318 chip
> talking to my computer with the NDISWrapper and a kernel build.  Before
> that the wireless was showing on the laptop's wifi switch light but not
> making up to the computer to actually use the signal.  Now, after six
> days, it suddenly stops.  Give it a few days, and it's on again.  Any clues?

Ok i am going to try to be nice, as i myself have been chewed out by
this forum before (improper email reply edict), and as i had a similar
problem i think, but as has been explained before its hard to tell.
First there is a transmit power problem that has been hard to fix
(correct me if i have misunderstood some of the other emails that flow
though here) this is going to make connecting to some networks very
flaky if not impossible when you are father away.

As for the ability to connect sometimes and not others, it is
something called i need to use the new kernel.  Or use rmmod bcm43xx a
lot.  If you are using a distros kernel, it is very likely that it
wont work, so i direct your attention toward www.kernel.org.  At the
time that my system was exhibiting that behavior, i applied this patch
and it went away
https://lists.berlios.de/pipermail/bcm43xx-dev/2007-February/003819.html
.  With the newer kernels, it should not be a problem. I still have
problems when i am to far away from my AP, but in a reasonable range,
it is very functional.

a uname -a would be helpful
lspci | grep Broadcom
dmesg | grep bcm43xx

Also that tidbit about the light was completely useless, it is
hardware not software (the filament in your ceiling light does not
effect whether or not the wall switch opens and closes)

If wont use the bcm43xx driver you are not going to find what people
say here very useful.

Well that is my best guess at what you were trying to say.
-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From comphappy at gmail.com  Fri Jul  6 04:00:14 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Thu, 5 Jul 2007 18:00:14 -0800
Subject: bcm4312 on again, off again
In-Reply-To: <468D980B.8070004@wbs.edu>
References: <mailman.59.1183543281.11773.bcm43xx-dev@lists.berlios.de>
	<468C8537.9030302@wbs.edu>
	<b2d05de20707051751h390de390p20523b9b7f35094f@mail.gmail.com>
	<468D980B.8070004@wbs.edu>
Message-ID: <b2d05de20707051900s54b4edd6t1aa12dd4a4f2ae04@mail.gmail.com>

On 7/5/07, Robert Easter <rdeaster at wbs.edu> wrote:
> Thanks, man-  Just after I decided to make a display of my native
> asininity the thing came back on, but I am keeping this letter as a
> first try for next time it craps out.
>
> Brennan Ashton wrote:
> >
> > First there is a transmit power problem that has been hard to fix
> > (correct me if i have misunderstood some of the other emails that flow
> > though here) this is going to make connecting to some networks very
> > flaky if not impossible when you are father away.
> I guess that would explain the light-related problem, especially if it's
> a power indicator and not a tx/rx detector...

I would guess that the like is a link tx/rx indicator. There is
usually a light that tells you if the wireless is turned on.

> >
> > As for the ability to connect sometimes and not others, it is
> > something called i need to use the new kernel.
> He pulled in the latest kernel last week off kernel.org, so I would at

I wonder if he got 2.6.21.4 or 2.6.22.rc7 there is a big difference.
run uname -a
that will tell us

> least hope it will be top kernel for a while before the next F7 build
> comes out, & even then there's at least the hope that the new one will
> adapt... (No?)
> > Or use rmmod bcm43xx a
> > lot.
> I'll have to check that out & see what it is.

it is a command.

> > If you are using a distros kernel, it is very likely that it
> > won't work, so i direct your attention toward www.kernel.org.  At the
> > time that my system was exhibiting that behavior, i applied this patch
> > and it went away
> > https://lists.berlios.de/pipermail/bcm43xx-dev/2007-February/003819.html
> I will hang on to that link- thanx!

wont work on the newer kernels

>
> > .  With the newer kernels, it should not be a problem. I still have
> > problems when i am to far away from my AP, but in a reasonable range,
> > it is very functional.
> >
> > a uname -a would be helpful
> > lspci | grep Broadcom
> > dmesg | grep bcm43xx
> What do these mean / do, by the way?

it is a | not a / it is the shift \ looks like a colon, it is known as
a pipe, and allows you to "pipe" the output of one command to another.
Grep is used to search the result for a string (as well as other
things).

> >
> > Also that tidbit about the light was completely useless, it is
> > hardware not software (the filament in your ceiling light does not
> > effect whether or not the wall switch opens and closes)
> Yeah, but when the wifi was available again, the light started
> flashing.  When it had quit, so had the light.  Maybe there's a hardware
> issue I need to look into?

doubt it, suggests that it is a link light.

> >
> > If wont use the bcm43xx driver you are not going to find what people
> > say here very useful.
> Well, what else is there?

you said that you were using ndiswrapper you need to use that
opensource driver bcm43xx with a firmware cutter. you will need to
remove the ndiswrapper stuff, extract the firmware and load the
modules (bcm43xx-mac80211).  I believe once you have delt with
ndiswrapper (cant help you there) you need to do somthing like this:

wget http://downloads.openwrt.org/sources/broadcom-wl-4.80.9.2.tar.bz2
tar -xjvf broadcom-wl-4.80.9.2.tar.bz2
bcm43xx-fwcutter -w /lib/firmware/ broadcom-wl-4.80.9.2/kmod/wl_apsta.o
echo 'blacklist bcm43xx' >> /etc/modprobe.d/blacklist   (not positive
about this)
when you set up ndiswrapper you may have blacklisted bcm43xx-mac80211
if so you need to remove it.
modprobe bcm43xx-mac80211

I think that is all correct.

> >
> > Well that is my best guess at what you were trying to say.
> Sounds like you're a good guesser.  I guess!
>
> Blessings on ya!
>
> r.e.
>
>
>


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From larry.finger at lwfinger.net  Fri Jul  6 19:53:42 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 06 Jul 2007 12:53:42 -0500
Subject: bcm4312 on again, off again
In-Reply-To: <b2d05de20707051751h390de390p20523b9b7f35094f@mail.gmail.com>
References: <mailman.59.1183543281.11773.bcm43xx-dev@lists.berlios.de>	<468C8537.9030302@wbs.edu>
	<b2d05de20707051751h390de390p20523b9b7f35094f@mail.gmail.com>
Message-ID: <468E81A6.1090404@lwfinger.net>

Brennan Ashton wrote:
> On 7/4/07, Robert Easter <rdeaster at wbs.edu> wrote:
>> It took a BS programmer over five hours, but he got my bcm4318 chip
>> talking to my computer with the NDISWrapper and a kernel build.  Before
>> that the wireless was showing on the laptop's wifi switch light but not
>> making up to the computer to actually use the signal.  Now, after six
>> days, it suddenly stops.  Give it a few days, and it's on again.  Any clues?

What does BS mean in this context?

> Ok i am going to try to be nice, as i myself have been chewed out by
> this forum before (improper email reply edict), and as i had a similar
> problem i think, but as has been explained before its hard to tell.
> First there is a transmit power problem that has been hard to fix
> (correct me if i have misunderstood some of the other emails that flow
> though here) this is going to make connecting to some networks very
> flaky if not impossible when you are father away.

Several of us try very hard to make this forum helpful, and not chew out the OP, but it is very hard 
to diagnose a problem when crucial information is missing. Suppose I asked for help in diagnosing my 
Ford truck and I didn't tell you that it is a diesel, and I didn't even say whether it started, or 
not. For the record, diagnosis of problems require the kernel version (uname -r), any patches that 
have been applied, the results from the command 'dmesg | grep bcm43xx', information about encryption 
on the access point, and any additional software being used to connect (NetworkManager, etc.). As 
stated below, if you want to use ndiswrapper, go elsewhere. We have done a lot of work to avoid that!!

> As for the ability to connect sometimes and not others, it is
> something called i need to use the new kernel.  Or use rmmod bcm43xx a
> lot.  If you are using a distros kernel, it is very likely that it
> wont work, so i direct your attention toward www.kernel.org.  At the
> time that my system was exhibiting that behavior, i applied this patch
> and it went away
> https://lists.berlios.de/pipermail/bcm43xx-dev/2007-February/003819.html
> .  With the newer kernels, it should not be a problem. I still have
> problems when i am to far away from my AP, but in a reasonable range,
> it is very functional.
> 
> a uname -a would be helpful
> lspci | grep Broadcom
> dmesg | grep bcm43xx
> 
> Also that tidbit about the light was completely useless, it is
> hardware not software (the filament in your ceiling light does not
> effect whether or not the wall switch opens and closes)
> 
> If wont use the bcm43xx driver you are not going to find what people
> say here very useful.
> 
> Well that is my best guess at what you were trying to say.


Larry


From larry.finger at lwfinger.net  Fri Jul  6 20:00:24 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 06 Jul 2007 13:00:24 -0500
Subject: dell e1505 bcm43xx driver, bcm4311 chipset?
In-Reply-To: <5b9417770707050151t3209ec4cpc0e2bb10d038e0b9@mail.gmail.com>
References: <5b9417770707050151t3209ec4cpc0e2bb10d038e0b9@mail.gmail.com>
Message-ID: <468E8338.9080007@lwfinger.net>

John H. wrote:
> I was wondering if, on fedora 7 now with 2.6.21 kernel, it is possible
> to use bcm43xx driver with this device and get 54mb/s and wpa support?
> 
> I have the firmware installed, etc.
> 
> I just had many problems last time, as it wouldn't get 54mb/s, etc.

With 2.6.21 or later kernels, the bcm43xx driver works quite well without any patching. It still 
doesn't do 54 Mbs, but my 4311 gets an Iperf throughput of over 15 Mbs. FYI, Windows using exactly 
the same configuration and hardware gets 19 Mbs, thus we are close.

Larry


From proski at gnu.org  Fri Jul  6 20:35:34 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 06 Jul 2007 14:35:34 -0400
Subject: dell e1505 bcm43xx driver, bcm4311 chipset?
In-Reply-To: <468E8338.9080007@lwfinger.net>
References: <5b9417770707050151t3209ec4cpc0e2bb10d038e0b9@mail.gmail.com>
	<468E8338.9080007@lwfinger.net>
Message-ID: <1183746934.24381.7.camel@dv>

On Fri, 2007-07-06 at 13:00 -0500, Larry Finger wrote:
> John H. wrote:
> > I was wondering if, on fedora 7 now with 2.6.21 kernel, it is possible
> > to use bcm43xx driver with this device and get 54mb/s and wpa support?
> > 
> > I have the firmware installed, etc.
> > 
> > I just had many problems last time, as it wouldn't get 54mb/s, etc.
> 
> With 2.6.21 or later kernels, the bcm43xx driver works quite well without any patching. It still 
> doesn't do 54 Mbs, but my 4311 gets an Iperf throughput of over 15 Mbs. FYI, Windows using exactly 
> the same configuration and hardware gets 19 Mbs, thus we are close.

Actually, bcm43xx seems to be patched in the stock Fedora kernel to only
support 4301.  At least it fails to pick 4318 on my desktop machine.
See "alias" below:

$ modinfo bcm43xx
filename:       /lib/modules/2.6.21-1.3228.fc7/kernel/drivers/net/wireless/bcm43xx/bcm43xx.ko
license:        GPL
author:         Michael Buesch
author:         Stefano Brivio
author:         Martin Langer
description:    Broadcom BCM43xx wireless driver
srcversion:     F29014CCD786A001B1A577A
alias:          pci:v000014E4d00004301sv*sd*bc*sc*i*
depends:        ieee80211,ieee80211softmac
...

The standalone version from ftp://lwfinger.dynalias.org/patches compiles
fine though and has a whole bunch of aliases.

-- 
Regards,
Pavel Roskin



From larry.finger at lwfinger.net  Fri Jul  6 20:56:12 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 06 Jul 2007 13:56:12 -0500
Subject: dell e1505 bcm43xx driver, bcm4311 chipset?
In-Reply-To: <1183746934.24381.7.camel@dv>
References: <5b9417770707050151t3209ec4cpc0e2bb10d038e0b9@mail.gmail.com>	
	<468E8338.9080007@lwfinger.net> <1183746934.24381.7.camel@dv>
Message-ID: <468E904C.8070101@lwfinger.net>

Pavel Roskin wrote:
> On Fri, 2007-07-06 at 13:00 -0500, Larry Finger wrote:
>> John H. wrote:
>>> I was wondering if, on fedora 7 now with 2.6.21 kernel, it is possible
>>> to use bcm43xx driver with this device and get 54mb/s and wpa support?
>>>
>>> I have the firmware installed, etc.
>>>
>>> I just had many problems last time, as it wouldn't get 54mb/s, etc.
>> With 2.6.21 or later kernels, the bcm43xx driver works quite well without any patching. It still 
>> doesn't do 54 Mbs, but my 4311 gets an Iperf throughput of over 15 Mbs. FYI, Windows using exactly 
>> the same configuration and hardware gets 19 Mbs, thus we are close.
> 
> Actually, bcm43xx seems to be patched in the stock Fedora kernel to only
> support 4301.  At least it fails to pick 4318 on my desktop machine.
> See "alias" below:
> 
> $ modinfo bcm43xx
> filename:       /lib/modules/2.6.21-1.3228.fc7/kernel/drivers/net/wireless/bcm43xx/bcm43xx.ko
> license:        GPL
> author:         Michael Buesch
> author:         Stefano Brivio
> author:         Martin Langer
> description:    Broadcom BCM43xx wireless driver
> srcversion:     F29014CCD786A001B1A577A
> alias:          pci:v000014E4d00004301sv*sd*bc*sc*i*
> depends:        ieee80211,ieee80211softmac
> ...
> 
> The standalone version from ftp://lwfinger.dynalias.org/patches compiles
> fine though and has a whole bunch of aliases.

That is John Linville's attempt to get people to use bcm43xx-mac80211, rather than softmac. That is 
a Fedora-only modification. Stock kernels support all bcm43xx versions without any changes. The 
stand-alone code exactly matches a "standard" kernel.

Larry


From andrew.james.barr at gmail.com  Sat Jul  7 05:54:15 2007
From: andrew.james.barr at gmail.com (Andrew J. Barr)
Date: Fri, 6 Jul 2007 23:54:15 -0400
Subject: Access Point: Invalid
Message-ID: <20070706235415.2f7ab007@powerbook.oakcourt.dyndns.org>

Hello, I am at a hotel and I am experiencing a strange issue with my
BCM4306 in my PowerBook G4--after some time the access point will
become "invalid", meaning the output of iwconfig will no longer list
the MAC address of the AP and will say "Invalid" instead, and I lose my
connection. Simply re-issuing the command "iwconfig wlan0 essid
<network name>" will allow the connection to resume.

This is with Linux 2.6.22-rc7 and the softmac driver.

-- 
Andrew J. Barr

We matter more than pounds and pence
Your economic theory makes no sense...


From andipeer at gmx.net  Sat Jul  7 10:21:17 2007
From: andipeer at gmx.net (Andreas Peer)
Date: Sat, 07 Jul 2007 10:21:17 +0200
Subject: Ferrari 3400 device?
Message-ID: <468F4CFD.1050604@gmx.net>

I don't know if this matters, but I have a Acer Ferrari 3400 notebook, 
and according to the device list on the web site, the wireless chip 
should be the following:
- chip id: 4318
- product id: 0x4318
- subsystem vendor id: 0x1468
- subsystem product id 0x0312,
but instead lspci shows me that the notebook contains a chip with
- chip id: 4306
- product id: 0x4320
- subsystem vendor id: 0x185f
- subsystem product id 0x1220.
It is to original chip that was contained when I bought the notebook. 
Maybe the information on the device site is not accurate, or Acer put 
different chips inside their Ferrari 3400 notebooks?

Another question: The driver works, but it has a much lower range than 
the Windows driver, i.e. I am not able to get a connection in places 
where on Windows I can connect with 36 MB/s and a good signal quality. 
Is this a known limitation? I think some time ago I read that bcm43xx 
uses firmware version 2.x, while the Windows drivers are already using 
version 3.x. Is that the problem, and is there a hope that the receiving 
quality will improve in the future?

Last, but not least I want to say that i appreciate your work and I want 
to thank you for what you have than for the Open Source community!

Andreas


From gavron at Wetwork.Net  Sat Jul  7 10:30:17 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Sat, 07 Jul 2007 01:30:17 -0700
Subject: Ferrari 3400 device?
In-Reply-To: <468F4CFD.1050604@gmx.net>
References: <468F4CFD.1050604@gmx.net>
Message-ID: <468F4F19.3030203@Wetwork.Net>

Note: I am not a developer, just a user with different sleeping habits, 
and so responded first.  Don't take the FIRST response as the BEST 
response, just the first.

First, the 4306 is an older car and certainly is well supported by the 
bcm43xx code, much better so than the 4318.

Second, the original bcm43xx code uses v.3 of the virmware.  Thew new 
bcm43xx_mac80211 code (default in F7) uses v.4 of the firmware.
The original works best in kernel 2.6.21-rc3 or better (other than F7).  
The new works best in the wireless-dev tree available via git.

Lastly, there is a known POWER problem, which results in better 
transmission if the transmission rates are reduced.

Please include:
1.  root#  uname -a
2.  root#  dmesg | grep bcm
3.  root#  iwconfig
and if you're not actually connected it sometimes helps to add
4.  root#  iwlist eth1 scan   (or iwlist wlan0 scan or whatever your 
interface is called)

I hope this information has helped rather than hurt,

Kind regards,

Ehud Gavron
Tucson AZ USA
Toronto: Paul Tracy.  Silverstone: Lewis Hamilton:  Lime Rock: 
McNish/Capello or Pirro/Werner  Daytone: JPM   IndyOvalDoodle: WTFC

Andreas Peer wrote:
> I don't know if this matters, but I have a Acer Ferrari 3400 notebook, 
> and according to the device list on the web site, the wireless chip 
> should be the following:
> - chip id: 4318
> - product id: 0x4318
> - subsystem vendor id: 0x1468
> - subsystem product id 0x0312,
> but instead lspci shows me that the notebook contains a chip with
> - chip id: 4306
> - product id: 0x4320
> - subsystem vendor id: 0x185f
> - subsystem product id 0x1220.
> It is to original chip that was contained when I bought the notebook. 
> Maybe the information on the device site is not accurate, or Acer put 
> different chips inside their Ferrari 3400 notebooks?
>
> Another question: The driver works, but it has a much lower range than 
> the Windows driver, i.e. I am not able to get a connection in places 
> where on Windows I can connect with 36 MB/s and a good signal quality. 
> Is this a known limitation? I think some time ago I read that bcm43xx 
> uses firmware version 2.x, while the Windows drivers are already using 
> version 3.x. Is that the problem, and is there a hope that the receiving 
> quality will improve in the future?
>
> Last, but not least I want to say that i appreciate your work and I want 
> to thank you for what you have than for the Open Source community!
>
> Andreas
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   


From andipeer at gmx.net  Sat Jul  7 10:55:33 2007
From: andipeer at gmx.net (Andreas Peer)
Date: Sat, 07 Jul 2007 10:55:33 +0200
Subject: Ferrari 3400 device?
In-Reply-To: <468F4F19.3030203@Wetwork.Net>
References: <468F4CFD.1050604@gmx.net> <468F4F19.3030203@Wetwork.Net>
Message-ID: <468F5505.9050207@gmx.net>

Thanks for your response!

Well, I'm running Ubuntu 7.04 64-Bit version

- "uname -a" gives: Linux laptopandi 2.6.20-16-generic #2 SMP Thu Jun 7 
19:00:28 UTC 2007 x86_64 GNU/Linux

- "dmesg" offers no meaningful messages ([    2.262297] bcm43xx driver)

- iwconfig:  eth0
          IEEE 802.11b/g  ESSID:"aj2lta1"  Nickname:"Broadcom 4306"
          Mode:Managed  Frequency=2.472 GHz  Access Point: 
00:0F:66:D3:04:13  
          Bit Rate=24 Mb/s   Tx-Power=15 dBm  
          RTS thr:off   Fragment thr:off
          Link Quality=75/100  Signal level=-57 dBm  Noise level=-72 dBm
          Rx invalid nwid:0  Rx invalid crypt:57  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

- iwlist eth0 scan:
          Cell 01 - Address: 00:0F:66:D3:04:13
                    ESSID:"aj2lta1"
                    Protocol:IEEE 802.11bg
                    Mode:Master
                    Channel:13
                    Encryption key:on
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 6 Mb/s; 9 Mb/s
                              11 Mb/s; 12 Mb/s; 18 Mb/s; 24 Mb/s; 36 Mb/s
                              48 Mb/s; 54 Mb/s
                    Quality=93/100  Signal level=-54 dBm  Noise 
level=-69 dBm
                    IE: WPA Version 1
                        Group Cipher : TKIP
                        Pairwise Ciphers (1) : TKIP
                        Authentication Suites (1) : PSK 
                    Extra: Last beacon: 40ms ago

I have to add that I am sitting just in front of the wireless router. 
The distance between router and notebook is at max half a meter. I find 
it also interesting, that iwlist and iwconfig show different quality 
percentages.

Kind regards,
Andreas

> Note: I am not a developer, just a user with different sleeping 
> habits, and so responded first.  Don't take the FIRST response as the 
> BEST response, just the first.
>
> First, the 4306 is an older car and certainly is well supported by the 
> bcm43xx code, much better so than the 4318.
>
> Second, the original bcm43xx code uses v.3 of the virmware.  Thew new 
> bcm43xx_mac80211 code (default in F7) uses v.4 of the firmware.
> The original works best in kernel 2.6.21-rc3 or better (other than 
> F7).  The new works best in the wireless-dev tree available via git.
>
> Lastly, there is a known POWER problem, which results in better 
> transmission if the transmission rates are reduced.
>
> Please include:
> 1.  root#  uname -a
> 2.  root#  dmesg | grep bcm
> 3.  root#  iwconfig
> and if you're not actually connected it sometimes helps to add
> 4.  root#  iwlist eth1 scan   (or iwlist wlan0 scan or whatever your 
> interface is called)
>
> I hope this information has helped rather than hurt,
>
> Kind regards,
>
> Ehud Gavron
> Tucson AZ USA
> Toronto: Paul Tracy.  Silverstone: Lewis Hamilton:  Lime Rock: 
> McNish/Capello or Pirro/Werner  Daytone: JPM   IndyOvalDoodle: WTFC
>
> Andreas Peer wrote:
>> I don't know if this matters, but I have a Acer Ferrari 3400 
>> notebook, and according to the device list on the web site, the 
>> wireless chip should be the following:
>> - chip id: 4318
>> - product id: 0x4318
>> - subsystem vendor id: 0x1468
>> - subsystem product id 0x0312,
>> but instead lspci shows me that the notebook contains a chip with
>> - chip id: 4306
>> - product id: 0x4320
>> - subsystem vendor id: 0x185f
>> - subsystem product id 0x1220.
>> It is to original chip that was contained when I bought the notebook. 
>> Maybe the information on the device site is not accurate, or Acer put 
>> different chips inside their Ferrari 3400 notebooks?
>>
>> Another question: The driver works, but it has a much lower range 
>> than the Windows driver, i.e. I am not able to get a connection in 
>> places where on Windows I can connect with 36 MB/s and a good signal 
>> quality. Is this a known limitation? I think some time ago I read 
>> that bcm43xx uses firmware version 2.x, while the Windows drivers are 
>> already using version 3.x. Is that the problem, and is there a hope 
>> that the receiving quality will improve in the future?
>>
>> Last, but not least I want to say that i appreciate your work and I 
>> want to thank you for what you have than for the Open Source community!
>>
>> Andreas
>> _______________________________________________
>> Bcm43xx-dev mailing list
>> Bcm43xx-dev at lists.berlios.de
>> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>>   
>



From gavron at Wetwork.Net  Sat Jul  7 11:20:28 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Sat, 07 Jul 2007 02:20:28 -0700
Subject: Ferrari 3400 device?
In-Reply-To: <468F5505.9050207@gmx.net>
References: <468F4CFD.1050604@gmx.net> <468F4F19.3030203@Wetwork.Net>
	<468F5505.9050207@gmx.net>
Message-ID: <468F5ADC.7000704@Wetwork.Net>

Yes the difference in power calculations is eventually closer and closer 
the further advanced the code becomes.

2.6.20 is definitely too old.  You will either want to check out the 
wireless-dev tree for newer bcm43xx code, or use a newer kernel 
entirely.  I posted the procedure for a new kernel a few days ago... 
someone posted the procedure for JUST upgrading the bcm43xx stuff one or 
two days ago.  Search the list archives.

"dmesg offers no meaningful messages" is interesting... it means 
probably that BCM43XX_DEBUG options are not set in that kernel, or 
bcm43xx would be spitting out the version of firmware it's loading as 
well as its issues in associating with the access point. 

Again I'd recommend a NEWER kernel and making sure all the BCM43XX debug 
stuff is set to Y.

As for sitting right across from the access point... with 2.6.22-rc6 
(wireless-dev) I can sit 1meter from the AP and with bcm43xx_mac80211 
(F7) can associate but can't get DHCP to work... and with bcm43xx can 
sit 20meters away and not only associate but DHCP works... and with 
2.6.20 I couldn't get DHCP working with either at 1M... so progress is 
being made :)

Ehud
PS I'm running 64-bit F7 with custom kernel from the wireless-dev tree 
(I think it's John Linville's).  The output of my uname -a and 
dmesg|grep bcm are included below
[root at egdell ~]# uname -a
Linux egdell.wetwork.net 2.6.22-rc6 #1 SMP Tue Jun 26 16:41:36 MST 2007 
x86_64 x86_64 x86_64 GNU/Linux
[root at egdell ~]# dmesg | grep bcm
bcm43xx_mac80211: Broadcom 4311 WLAN found
bcm43xx_mac80211: Found PHY: Analog 4, Type 2, Revision 8
bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
bcm43xx_mac80211: Radio turned off
bcm43xx driver
bcm43xx_mac80211: Adding Interface type 2
bcm43xx_mac80211: Loading firmware version 371.1061 (2006-10-04 21:02:04)
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: !WARNING! Idle-TSSI phy->cur_idle_tssi measuring 
failed. (cur=32, tgt=62). Disabling TX power adjustment.
bcm43xx_mac80211: Chip initialized
bcm43xx_mac80211: 32-bit DMA initialized
bcm43xx_mac80211: Wireless interface started
bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
bcm43xx_mac80211: Removing Interface type 2
bcm43xx_mac80211: Wireless interface stopped
bcm43xx_mac80211: DMA-32 0x0200 (RX) max used slots: 1/64
bcm43xx_mac80211: DMA-32 0x02A0 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0280 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0260 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0240 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0220 (TX) max used slots: 88/128
bcm43xx_mac80211: DMA-32 0x0200 (TX) max used slots: 0/128
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Radio turned off
bcm43xx driver
bcm43xx: Chip ID 0x4311, rev 0x1
bcm43xx: Number of cores: 4
bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
bcm43xx: PHY connected
bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
bcm43xx: Radio turned off
bcm43xx: Radio turned off
bcm43xx: PHY connected
bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
bcm43xx: Radio turned on
bcm43xx: Radio enabled by hardware
bcm43xx: Chip initialized
bcm43xx: 32-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)
bcm43xx: Radio turned off
bcm43xx: DMA-32 0x0200 (RX) max used slots: 0/64
bcm43xx: DMA-32 0x02A0 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0280 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0260 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0240 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0220 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0200 (TX) max used slots: 0/512
bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
bcm43xx: Radio turned on
bcm43xx: Radio enabled by hardware
bcm43xx: Chip initialized
bcm43xx: 32-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1, .auth_mode = 0
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1, .auth_mode = 0
bcm43xx: Radio turned off
bcm43xx: DMA-32 0x0200 (RX) max used slots: 3/64
bcm43xx: DMA-32 0x02A0 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0280 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0260 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0240 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0220 (TX) max used slots: 129/512
bcm43xx: DMA-32 0x0200 (TX) max used slots: 0/512
bcm43xx driver
bcm43xx: Chip ID 0x4311, rev 0x1
bcm43xx: Number of cores: 4
bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
bcm43xx: PHY connected
bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
bcm43xx: Radio turned off
bcm43xx: Radio turned off
bcm43xx: PHY connected
bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
bcm43xx: Radio turned on
bcm43xx: Radio enabled by hardware
bcm43xx: Chip initialized
bcm43xx: 32-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)
bcm43xx: Radio turned off
bcm43xx: DMA-32 0x0200 (RX) max used slots: 1/64
bcm43xx: DMA-32 0x02A0 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0280 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0260 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0240 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0220 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0200 (TX) max used slots: 0/512
bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
bcm43xx: Radio turned on
bcm43xx: Radio enabled by hardware
bcm43xx: Chip initialized
bcm43xx: 32-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1, .auth_mode = 0
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1, .auth_mode = 0
bcm43xx: Radio turned off
bcm43xx: DMA-32 0x0200 (RX) max used slots: 5/64
bcm43xx: DMA-32 0x02A0 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0280 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0260 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0240 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0220 (TX) max used slots: 136/512
bcm43xx: DMA-32 0x0200 (TX) max used slots: 0/512
bcm43xx driver
bcm43xx: Chip ID 0x4311, rev 0x1
bcm43xx: Number of cores: 4
bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
bcm43xx: PHY connected
bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
bcm43xx: Radio turned off
bcm43xx: Radio turned off
bcm43xx: PHY connected
bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
bcm43xx: Radio turned on
bcm43xx: Radio enabled by hardware
bcm43xx: Chip initialized
bcm43xx: 32-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)
bcm43xx: Radio turned off
bcm43xx: DMA-32 0x0200 (RX) max used slots: 1/64
bcm43xx: DMA-32 0x02A0 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0280 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0260 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0240 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0220 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0200 (TX) max used slots: 0/512
bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
bcm43xx: Radio turned on
bcm43xx: Radio enabled by hardware
bcm43xx: Chip initialized
bcm43xx: 32-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1, .auth_mode = 0
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1, .auth_mode = 0


Andreas Peer wrote:
> Thanks for your response!
>
> Well, I'm running Ubuntu 7.04 64-Bit version
>
> - "uname -a" gives: Linux laptopandi 2.6.20-16-generic #2 SMP Thu Jun 7 
> 19:00:28 UTC 2007 x86_64 GNU/Linux
>
> - "dmesg" offers no meaningful messages ([    2.262297] bcm43xx driver)
>
> - iwconfig:  eth0
>           IEEE 802.11b/g  ESSID:"aj2lta1"  Nickname:"Broadcom 4306"
>           Mode:Managed  Frequency=2.472 GHz  Access Point: 
> 00:0F:66:D3:04:13  
>           Bit Rate=24 Mb/s   Tx-Power=15 dBm  
>           RTS thr:off   Fragment thr:off
>           Link Quality=75/100  Signal level=-57 dBm  Noise level=-72 dBm
>           Rx invalid nwid:0  Rx invalid crypt:57  Rx invalid frag:0
>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
>
> - iwlist eth0 scan:
>           Cell 01 - Address: 00:0F:66:D3:04:13
>                     ESSID:"aj2lta1"
>                     Protocol:IEEE 802.11bg
>                     Mode:Master
>                     Channel:13
>                     Encryption key:on
>                     Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 6 Mb/s; 9 Mb/s
>                               11 Mb/s; 12 Mb/s; 18 Mb/s; 24 Mb/s; 36 Mb/s
>                               48 Mb/s; 54 Mb/s
>                     Quality=93/100  Signal level=-54 dBm  Noise 
> level=-69 dBm
>                     IE: WPA Version 1
>                         Group Cipher : TKIP
>                         Pairwise Ciphers (1) : TKIP
>                         Authentication Suites (1) : PSK 
>                     Extra: Last beacon: 40ms ago
>
> I have to add that I am sitting just in front of the wireless router. 
> The distance between router and notebook is at max half a meter. I find 
> it also interesting, that iwlist and iwconfig show different quality 
> percentages.
>
> Kind regards,
> Andreas
>
>   
>> Note: I am not a developer, just a user with different sleeping 
>> habits, and so responded first.  Don't take the FIRST response as the 
>> BEST response, just the first.
>>
>> First, the 4306 is an older car and certainly is well supported by the 
>> bcm43xx code, much better so than the 4318.
>>
>> Second, the original bcm43xx code uses v.3 of the virmware.  Thew new 
>> bcm43xx_mac80211 code (default in F7) uses v.4 of the firmware.
>> The original works best in kernel 2.6.21-rc3 or better (other than 
>> F7).  The new works best in the wireless-dev tree available via git.
>>
>> Lastly, there is a known POWER problem, which results in better 
>> transmission if the transmission rates are reduced.
>>
>> Please include:
>> 1.  root#  uname -a
>> 2.  root#  dmesg | grep bcm
>> 3.  root#  iwconfig
>> and if you're not actually connected it sometimes helps to add
>> 4.  root#  iwlist eth1 scan   (or iwlist wlan0 scan or whatever your 
>> interface is called)
>>
>> I hope this information has helped rather than hurt,
>>
>> Kind regards,
>>
>> Ehud Gavron
>> Tucson AZ USA
>> Toronto: Paul Tracy.  Silverstone: Lewis Hamilton:  Lime Rock: 
>> McNish/Capello or Pirro/Werner  Daytone: JPM   IndyOvalDoodle: WTFC
>>
>> Andreas Peer wrote:
>>     
>>> I don't know if this matters, but I have a Acer Ferrari 3400 
>>> notebook, and according to the device list on the web site, the 
>>> wireless chip should be the following:
>>> - chip id: 4318
>>> - product id: 0x4318
>>> - subsystem vendor id: 0x1468
>>> - subsystem product id 0x0312,
>>> but instead lspci shows me that the notebook contains a chip with
>>> - chip id: 4306
>>> - product id: 0x4320
>>> - subsystem vendor id: 0x185f
>>> - subsystem product id 0x1220.
>>> It is to original chip that was contained when I bought the notebook. 
>>> Maybe the information on the device site is not accurate, or Acer put 
>>> different chips inside their Ferrari 3400 notebooks?
>>>
>>> Another question: The driver works, but it has a much lower range 
>>> than the Windows driver, i.e. I am not able to get a connection in 
>>> places where on Windows I can connect with 36 MB/s and a good signal 
>>> quality. Is this a known limitation? I think some time ago I read 
>>> that bcm43xx uses firmware version 2.x, while the Windows drivers are 
>>> already using version 3.x. Is that the problem, and is there a hope 
>>> that the receiving quality will improve in the future?
>>>
>>> Last, but not least I want to say that i appreciate your work and I 
>>> want to thank you for what you have than for the Open Source community!
>>>
>>> Andreas
>>> _______________________________________________
>>> Bcm43xx-dev mailing list
>>> Bcm43xx-dev at lists.berlios.de
>>> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>>>   
>>>       
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   


From andrew.james.barr at gmail.com  Sat Jul  7 17:48:10 2007
From: andrew.james.barr at gmail.com (Andrew J. Barr)
Date: Sat, 7 Jul 2007 11:48:10 -0400
Subject: Ferrari 3400 device?
In-Reply-To: <468F5505.9050207@gmx.net>
References: <468F4CFD.1050604@gmx.net> <468F4F19.3030203@Wetwork.Net>
	<468F5505.9050207@gmx.net>
Message-ID: <20070707114810.38cfd0e5@powerbook.oakcourt.dyndns.org>

On Sat, 07 Jul 2007 10:55:33 +0200
Andreas Peer <andipeer at gmx.net> wrote:
> - iwconfig:  eth0
>           IEEE 802.11b/g  ESSID:"aj2lta1"  Nickname:"Broadcom 4306"
>           Mode:Managed  Frequency=2.472 GHz  Access Point: 
> 00:0F:66:D3:04:13  
>           Bit Rate=24 Mb/s   Tx-Power=15 dBm  
>           RTS thr:off   Fragment thr:off
>           Link Quality=75/100  Signal level=-57 dBm  Noise level=-72
> dBm Rx invalid nwid:0  Rx invalid crypt:57  Rx invalid frag:0
>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0

If you are going to stick with the softmac version of the driver (the
version in mainline kernels), I would search the list archives for a
one-liner patch that makes the softmac default rate 11mbs instead of
24mbs. This helps me quite a lot...

-- 
Andrew J. Barr

We matter more than pounds and pence
Your economic theory makes no sense...


From richie at coderworld.net  Sat Jul  7 21:50:26 2007
From: richie at coderworld.net (Richard)
Date: Sat, 7 Jul 2007 21:50:26 +0200
Subject: Access Point: Invalid
In-Reply-To: <20070706235415.2f7ab007@powerbook.oakcourt.dyndns.org>
References: <20070706235415.2f7ab007@powerbook.oakcourt.dyndns.org>
Message-ID: <200707072150.27071.richie@coderworld.net>

On Saturday 07 July 2007 05:54:15 Andrew J. Barr wrote:
> Hello, I am at a hotel and I am experiencing a strange issue with my
> BCM4306 in my PowerBook G4--after some time the access point will
> become "invalid", meaning the output of iwconfig will no longer list
> the MAC address of the AP and will say "Invalid" instead, and I lose my
> connection. Simply re-issuing the command "iwconfig wlan0 essid
> <network name>" will allow the connection to resume.
>
> This is with Linux 2.6.22-rc7 and the softmac driver.

I have the same issue, and since kNetworkManager gets confused by this I have 
solved this with a script that continuosly checks the availability of the 
connection.

It's not perfect and requires manual configuration for the desired AP. I 
provide it "AS IS" as public domain, hope it comes to use, don't expect 
updates or refinements, although it might happen..

What it does:
* pings the AP once per second, after three failures it attempts to 
reassociate
* after three failed associations it downs the interface and reloads bcm43xx 
module.

Solves the connection persistency issues for me, but is a bit slow with 
reconnect due to its lack of intelligence
-------------- next part --------------
A non-text attachment was scrubbed...
Name: netalive.sh
Type: application/x-shellscript
Size: 2780 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070707/7eb03ebd/attachment.bin>

From Eyes-Killer at gmx.de  Sat Jul  7 23:09:44 2007
From: Eyes-Killer at gmx.de (Florian Erfurth)
Date: Sat, 07 Jul 2007 23:09:44 +0200
Subject: Ferrari 3400 device?
In-Reply-To: <468F4F19.3030203@Wetwork.Net>
References: <468F4CFD.1050604@gmx.net> <468F4F19.3030203@Wetwork.Net>
Message-ID: <46900118.2070705@gmx.de>

Ehud Gavron schrieb:
> Lastly, there is a known POWER problem, which results in better 
> transmission if the transmission rates are reduced.
>   
Do you mean this issue?
bcm43xx_mac80211: !WARNING! Idle-TSSI phy->cur_id
le_tssi measuring failed. (cur=0, tgt=62). Disabling TX power adjustment.

cu Floh


From larry.finger at lwfinger.net  Sat Jul  7 23:24:47 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 07 Jul 2007 16:24:47 -0500
Subject: Ferrari 3400 device?
In-Reply-To: <46900118.2070705@gmx.de>
References: <468F4CFD.1050604@gmx.net> <468F4F19.3030203@Wetwork.Net>
	<46900118.2070705@gmx.de>
Message-ID: <4690049F.7040208@lwfinger.net>

Florian Erfurth wrote:
> Ehud Gavron schrieb:
>> Lastly, there is a known POWER problem, which results in better 
>> transmission if the transmission rates are reduced.
>>   
> Do you mean this issue?
> bcm43xx_mac80211: !WARNING! Idle-TSSI phy->cur_id
> le_tssi measuring failed. (cur=0, tgt=62). Disabling TX power adjustment.

That is one part of the power problem, but there are others that don't print any warnings.

One word of caution: When I use the bcm43xx-mac80211 driver that you are now trying, I get a maximum 
throughput of 1-2 Mbs. With the bcm43xx (softmac) driver in kernels 2.6.21 or later, I get maximum 
throughput of 15 Mbs under identical conditions.

Larry


From rdeaster at wbs.edu  Sun Jul  8 02:25:25 2007
From: rdeaster at wbs.edu (Robert Easter)
Date: Sat, 07 Jul 2007 19:25:25 -0500
Subject: bcm4318 on again, off again (Larry Finger)
In-Reply-To: <mailman.22309.1183800046.5173.bcm43xx-dev@lists.berlios.de>
References: <mailman.22309.1183800046.5173.bcm43xx-dev@lists.berlios.de>
Message-ID: <46902EF5.7000000@wbs.edu>


>
> Message: 1
> Date: Fri, 06 Jul 2007 12:53:42 -0500
> From: Larry Finger <larry.finger at lwfinger.net>
> Subject: Re: bcm4312 on again, off again
> To: Brennan Ashton <comphappy at gmail.com>
> Cc: rdeaster at wbs.edu, bcm43xx-dev at lists.berlios.de
> Message-ID: <468E81A6.1090404 at lwfinger.net>
> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
>
> Brennan Ashton wrote:
>   
>> On 7/4/07, Robert Easter <rdeaster at wbs.edu> wrote:
>>     
>>> It took a BS programmer over five hours, ...
>>>       
>
> What does BS mean in this context? 
>   
A B.S. Computer Science  degree..  In other words somebody certified 
smart, as in in much better shape for this than Yours Truly.
>   
> Several of us try very hard to make this forum helpful, and not chew out the OP, but it is very hard 
> to diagnose a problem when crucial information is missing. Suppose I asked for help in diagnosing my 
> Ford truck and I didn't tell you that it is a diesel, and I didn't even say whether it started, or 
> not.
And that is the reason I hope to find help from folks that have the 
chops to make this stuff work.  Coding details are difficult enough, I 
imagine, for people that use them every day, what with the various 
languages, shells, routines,...  I can't justify the time right now just 
to learn bash.  For all I know I'd feed that diesel with gasoline and 
blow us all up!
>  For the record, diagnosis of problems require the kernel version (uname -r), any patches that 
> have been applied, the results from the command 'dmesg | grep bcm43xx', information about encryption 
> on the access point, and any additional software being used to connect (NetworkManager, etc.). As 
> stated below,
I make a note of it, thank you.
>  if you want to use ndiswrapper, go elsewhere. We have done a lot of work to avoid that!!
>   
See?  For all I knew the two worked together, either the wrapper or the 
cutter, and until last week I didn't know that it was either/or.  With 
your mate's help, I have put in a few hours trying to make the system 
run with the cutter, and Joe tried to make it work as well, before going 
with the wrapper approach.
>   
>> As for the ability to connect sometimes and not others, it is
>> something called i need to use the new kernel.  Or use rmmod bcm43xx a
>> lot.  If you are using a distros kernel, it is very likely that it
>> wont work, so i direct your attention toward www.kernel.org.  At the
>> time that my system was exhibiting that behavior, i applied this patch
>> and it went away
>> https://lists.berlios.de/pipermail/bcm43xx-dev/2007-February/003819.html
>> .  With the newer kernels, it should not be a problem. I still have
>> problems when i am to far away from my AP, but in a reasonable range,
>> it is very functional.
>>     
Yes, that's basically what Joe did:  downloaded a fresh kernel and 
compiled / built it to work with the driver, and still needed the 
wrapper.  I don't know why, or for that matter how, when, where, or who.
>> a uname -a would be helpful
>> lspci | grep Broadcom
>> dmesg | grep bcm43xx
>>
>> Also that tidbit about the light was completely useless, it is
>> hardware not software (the filament in your ceiling light does not
>> effect whether or not the wall switch opens and closes)
>>     
When the wireless stopped working the light on the switch at the near 
edge of the notebook stopped working also.  I tried several times but 
could not start the wireless channel in Network Manager.  Then I saw the 
light working again, opened N.M., and was able to start the service.  
Maybe in this case that light is on a power detector and there was an 
open switch at or ahead of  the ct/diode/transistor...
>> If wont use the bcm43xx driver you are not going to find what people
>> say here very useful.
>>
>>     
So what it looks like then is that until I have learned enough linux-ese 
to be able to access the technical pages, understand the difference (??) 
between a native driver and a bcm43xx driver, and why there's a notice 
in the F7 installation startup that there is no Broadcom support 
available when in fact there is (or is there)  and know off-hand the 
meanings of the several hundred commands, conditions, and switches in 
bash, sh, ssh,...  I should just go back to Windows?  Surely there's a 
third option somewhere!
>> Well that is my best guess at what you were trying to say.
>>     
Larry, what I'm saying is that I am real grateful you guys run lists 
like this.  I am busy enough at my end dealing with the technical 
language of my own line of work, trying to discern between ousia and 
hypostasis, nous and logos, form-, text-, and historical-critical 
arguments to take the few hundred hours it would take to start to get a 
short handle on the tech-speak of working out what it will take to make 
this notebook cooperate.  Either I get a smart person's help when 
needed, or I'm back to pencils and paper, and I scribble even worse than 
I type.

Thanks.

Robert

For the record,

[root at localhost ~]# uname -a
Linux localhost.localdomain 2.6.21-1.3228.fc7 #1 SMP Thu Jun 28 16:42:25 
CDT 2007 i686 i686 i386 GNU/Linux
[root at localhost ~]# lspci | grep Broadcom
0a:03.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 
54g] 802.11g Wireless LAN Controller (rev 02)
[root at localhost ~]# dmesg | grep bcm43xx
[root at localhost ~]#




From comphappy at gmail.com  Sun Jul  8 04:07:33 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sat, 7 Jul 2007 19:07:33 -0700
Subject: bcm4318 on again, off again (Larry Finger)
In-Reply-To: <46902EF5.7000000@wbs.edu>
References: <mailman.22309.1183800046.5173.bcm43xx-dev@lists.berlios.de>
	<46902EF5.7000000@wbs.edu>
Message-ID: <b2d05de20707071907u3d8aafdag36010d7c0fed8f8d@mail.gmail.com>

>>SNIP<<
> [root at localhost ~]# uname -a
> Linux localhost.localdomain 2.6.21-1.3228.fc7 #1 SMP Thu Jun 28 16:42:25
> CDT 2007 i686 i686 i386 GNU/Linux
> [root at localhost ~]# lspci | grep Broadcom
> 0a:03.0 Network controller: Broadcom Corporation BCM4318 [AirForce One
> 54g] 802.11g Wireless LAN Controller (rev 02)
> [root at localhost ~]# dmesg | grep bcm43xx
> [root at localhost ~]#
>
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
The fact that dmesg had nothing to say means you are not using the
bcm4xx driver.
you are not using a kernel from kernel.org or wireless-dev you need to
get one of them,
Linux localhost.localdomain 2.6.21-1.3228.fc7
that - with a number after it is a dead give away.  You want uname -r
to give 2.6.22-rc7
try this:
su -
yum install bcm43xx-fwcutter
wget http://downloads.openwrt.org/sources/broadcom-wl-4.80.9.2.tar.bz2
tar -xjvf broadcom-wl-4.80.9.2.tar.bz2
bcm43xx-fwcutter -w /lib/firmware/ broadcom-wl-4.80.9.2/kmod/wl_apsta.o
when you set up ndiswrapper you may have blacklisted bcm43xx
if so you need to remove it (edit /etc/modprobe.d/blacklist)

cd /usr/src
yum install git
git-clone git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-dev.git
cd wireless-dev
cp /boot/config-`uname -r` ./.config
make mrproper
make menuconfig
select load alternative config file, it should sugest .config select yes
then navigate to:
device-drivers-->Network-device-support-->Wireless-LAN-->press space
when broadcom BCM43xx is selected (an M should appear next to it, if
not hit space a few more times) do the same for broadcom BCM43xx
mac80211 stack.  you may want to enable some debugging in the same
location.
press esc a few times, it will say do you want to save, select yes
then on the command line again (this part will take a while):
make all
make modules_install
make install
now reboot
select the new kernel at boot when grub comes up
command line again:
su -
modprobe bcm43xx

That should get u up and running, or at least to a state in which we
can help. I don't know what other damage ndiswrapper may have done
that you need to remove maybe someone else can way in on that.  If it
works, you can change /boot/grub/menu.lst so that the new kernel is
default.
-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From comphappy at gmail.com  Sun Jul  8 04:38:42 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sat, 7 Jul 2007 19:38:42 -0700
Subject: bcm4318 on again, off again (Larry Finger)
In-Reply-To: <b2d05de20707071907u3d8aafdag36010d7c0fed8f8d@mail.gmail.com>
References: <mailman.22309.1183800046.5173.bcm43xx-dev@lists.berlios.de>
	<46902EF5.7000000@wbs.edu>
	<b2d05de20707071907u3d8aafdag36010d7c0fed8f8d@mail.gmail.com>
Message-ID: <b2d05de20707071938l33e736efhdb476e6de0cd1ad0@mail.gmail.com>

Made a type-o

On 7/7/07, Brennan Ashton <comphappy at gmail.com> wrote:
> >>SNIP<<
> > [root at localhost ~]# uname -a
> > Linux localhost.localdomain 2.6.21-1.3228.fc7 #1 SMP Thu Jun 28 16:42:25
> > CDT 2007 i686 i686 i386 GNU/Linux
> > [root at localhost ~]# lspci | grep Broadcom
> > 0a:03.0 Network controller: Broadcom Corporation BCM4318 [AirForce One
> > 54g] 802.11g Wireless LAN Controller (rev 02)
> > [root at localhost ~]# dmesg | grep bcm43xx
> > [root at localhost ~]#
> >
> >
> > _______________________________________________
> > Bcm43xx-dev mailing list
> > Bcm43xx-dev at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
> >
> The fact that dmesg had nothing to say means you are not using the
> bcm4xx driver.
> you are not using a kernel from kernel.org or wireless-dev you need to
> get one of them,
> Linux localhost.localdomain 2.6.21-1.3228.fc7
> that - with a number after it is a dead give away.  You want uname -r
> to give 2.6.22-rc7
> try this:
> su -
> yum install bcm43xx-fwcutter
> wget http://downloads.openwrt.org/sources/broadcom-wl-4.80.9.2.tar.bz2
> tar -xjvf broadcom-wl-4.80.9.2.tar.bz2
> bcm43xx-fwcutter -w /lib/firmware/ broadcom-wl-4.80.9.2/kmod/wl_apsta.o
> when you set up ndiswrapper you may have blacklisted bcm43xx
> if so you need to remove it (edit /etc/modprobe.d/blacklist)
>
> cd /usr/src
> yum install git
> git-clone git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-dev.git
> cd wireless-dev
here this

> cp /boot/config-`uname -r` ./.config
> make mrproper

should be this

make mrproper
cp /boot/config-`uname -r` ./.config

> make menuconfig
> select load alternative config file, it should sugest .config select yes
> then navigate to:
> device-drivers-->Network-device-support-->Wireless-LAN-->press space
> when broadcom BCM43xx is selected (an M should appear next to it, if
> not hit space a few more times) do the same for broadcom BCM43xx
> mac80211 stack.  you may want to enable some debugging in the same
> location.
> press esc a few times, it will say do you want to save, select yes
> then on the command line again (this part will take a while):
> make all
> make modules_install
> make install
> now reboot
> select the new kernel at boot when grub comes up
> command line again:
> su -
> modprobe bcm43xx
>
> That should get u up and running, or at least to a state in which we
> can help. I don't know what other damage ndiswrapper may have done
> that you need to remove maybe someone else can way in on that.  If it
> works, you can change /boot/grub/menu.lst so that the new kernel is
> default.
> --
> Brennan Ashton
> Bellingham, Washington
>
> "The box said, 'Requires Windows 98 or better'. So I installed Linux"
>


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From jennytharayil at gmail.com  Sun Jul  8 06:36:53 2007
From: jennytharayil at gmail.com (jenny tc)
Date: Sun, 8 Jul 2007 10:06:53 +0530
Subject: broadcom corporation dell wireless 1390 WLAN mini PCI card not
	working with bcm43xx driver
In-Reply-To: <47b5508f0707060014p2992a8d0p5ff19f02cb04cb7f@mail.gmail.com>
References: <47b5508f0707050803g6e6674f5v327c2271b3438388@mail.gmail.com>
	<468D11A9.9080508@vroon.org>
	<47b5508f0707060014p2992a8d0p5ff19f02cb04cb7f@mail.gmail.com>
Message-ID: <47b5508f0707072136u35e1f235sb4d4f59437d4d6de@mail.gmail.com>

On 7/6/07, jenny tc <jennytharayil at gmail.com> wrote:
>
> hai,
> I,m attaching wpa_supplicant output file..pls have a look
>
> /usr/sbin/wpa_supplicant -c wireless.conf -i eth0 -Dwext -B -dd &>
> wpa_supplicant.output.txt




wpa_supplicant output---------
---------------------------------
Initializing interface 'eth0' conf 'wireless.conf' driver 'wext'
ctrl_interface 'N/A'
Configuration file 'wireless.conf' -> '/home/jenny_tc/wireless.conf'
Reading configuration file '/home/jenny_tc/wireless.conf'
ctrl_interface='/var/run/wpa_supplicant'
Line: 3 - start of a new network block
ssid - hexdump_ascii(len=4):
     48 43 41 43                                       HCAC
scan_ssid=1 (0x1)
key_mgmt: 0x2
proto: 0x1
pairwise: 0x10
group: 0x10
PSK (ASCII passphrase) - hexdump_ascii(len=10): [REMOVED]
PSK (from passphrase) - hexdump(len=32): [REMOVED]
Priority group 0
   id=0 ssid='HCAC'
Initializing interface (2) 'eth0'
EAPOL: SUPP_PAE entering state DISCONNECTED
EAPOL: KEY_RX entering state NO_KEY_RECEIVE
EAPOL: SUPP_BE entering state INITIALIZE
EAP: EAP entering state DISABLED
EAPOL: External notification - portEnabled=0
EAPOL: External notification - portValid=0
SIOCGIWRANGE: WE(compiled)=21 WE(source)=18 enc_capa=0xf
  capabilities: key_mgmt 0xf enc 0xf
Own MAC address: 00:1a:73:5c:41:89
wpa_driver_wext_set_wpa
wpa_driver_wext_set_key: alg=0 key_idx=0 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=1 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=2 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=3 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_countermeasures
wpa_driver_wext_set_drop_unencrypted
Setting scan request: 0 sec 100000 usec
Added interface eth0
Daemonize..


-Jenny
>
>
> On 7/5/07, Tony Vroon <tony at vroon.org> wrote:
> >
> > -----BEGIN PGP SIGNED MESSAGE-----
> > Hash: SHA256
> >
> > jenny tc wrote:
> > I ran wpa supplicant as  " /usr/sbin/wpa_supplicant  -c
> > > wireless.con -i eth0 -D wext -B" . It's not reporting any error.
> >
> > I will clarify, could you run the following command:
> >
> > wpa_supplicant -c wireless.con -i eth0 -Dwext -B -dd &>
> > wpa_supplicant.output.txt
> >
> > While your dmesg output is handy to have, it doesn't tell the complete
> > story and I'd like to hear wpa_supplicant's side of things.
> >
> > Regards,
> > Tony V.
> > -----BEGIN PGP SIGNATURE-----
> > Version: GnuPG v2.0.4 (GNU/Linux)
> > Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org
> >
> > iD8DBQFGjRGpp5vW4rUFj5oRCFY/AJ9m0Qwm0TrFtvEXTl6UsVjvl8pu1gCgl9ki
> > X/yF/5yJ3EQAIr0gHD2EmWo=
> > =0GVw
> > -----END PGP SIGNATURE-----
> >
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070708/6f605231/attachment.html>

From larry.finger at lwfinger.net  Sun Jul  8 06:52:15 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 07 Jul 2007 23:52:15 -0500
Subject: broadcom corporation dell wireless 1390 WLAN mini PCI card not
	working with bcm43xx driver
In-Reply-To: <47b5508f0707072136u35e1f235sb4d4f59437d4d6de@mail.gmail.com>
References: <47b5508f0707050803g6e6674f5v327c2271b3438388@mail.gmail.com>	<468D11A9.9080508@vroon.org>	<47b5508f0707060014p2992a8d0p5ff19f02cb04cb7f@mail.gmail.com>
	<47b5508f0707072136u35e1f235sb4d4f59437d4d6de@mail.gmail.com>
Message-ID: <46906D7F.2020903@lwfinger.net>

jenny tc wrote:
> 
> 
> On 7/6/07, *jenny tc* <jennytharayil at gmail.com 
> <mailto:jennytharayil at gmail.com>> wrote:
> 
>     hai,
>     I,m attaching wpa_supplicant output file..pls have a look
> 
>     /usr/sbin/wpa_supplicant -c wireless.conf -i eth0 -Dwext -B -dd &>
>     wpa_supplicant.output.txt
> 
>  
>  
>  
> wpa_supplicant output---------
> ---------------------------------
> Initializing interface 'eth0' conf 'wireless.conf' driver 'wext' 
> ctrl_interface 'N/A'
> Configuration file 'wireless.conf' -> '/home/jenny_tc/wireless.conf'
> Reading configuration file '/home/jenny_tc/wireless.conf'
> ctrl_interface='/var/run/wpa_supplicant'
> Line: 3 - start of a new network block
> ssid - hexdump_ascii(len=4):
>      48 43 41 43                                       HCAC           
> scan_ssid=1 (0x1)
> key_mgmt: 0x2
> proto: 0x1
> pairwise: 0x10
> group: 0x10
> PSK (ASCII passphrase) - hexdump_ascii(len=10): [REMOVED]
> PSK (from passphrase) - hexdump(len=32): [REMOVED]
> Priority group 0
>    id=0 ssid='HCAC'
> Initializing interface (2) 'eth0'
> EAPOL: SUPP_PAE entering state DISCONNECTED
> EAPOL: KEY_RX entering state NO_KEY_RECEIVE
> EAPOL: SUPP_BE entering state INITIALIZE
> EAP: EAP entering state DISABLED
> EAPOL: External notification - portEnabled=0
> EAPOL: External notification - portValid=0
> SIOCGIWRANGE: WE(compiled)=21 WE(source)=18 enc_capa=0xf
>   capabilities: key_mgmt 0xf enc 0xf
> Own MAC address: 00:1a:73:5c:41:89
> wpa_driver_wext_set_wpa
> wpa_driver_wext_set_key: alg=0 key_idx=0 set_tx=0 seq_len=0 key_len=0
> wpa_driver_wext_set_key: alg=0 key_idx=1 set_tx=0 seq_len=0 key_len=0
> wpa_driver_wext_set_key: alg=0 key_idx=2 set_tx=0 seq_len=0 key_len=0
> wpa_driver_wext_set_key: alg=0 key_idx=3 set_tx=0 seq_len=0 key_len=0
> wpa_driver_wext_set_countermeasures
> wpa_driver_wext_set_drop_unencrypted
> Setting scan request: 0 sec 100000 usec
> Added interface eth0
> Daemonize..

To keep wpa_supplicant from becoming a daemon, do not use the -B switch. In addition, you should 
change the -dd to a -ddd, which results in further diagnostics. To reiterate, your command should be

/usr/sbin/wpa_supplicant -c wireless.conf -i eth0 -Dwext -ddd &> wpa_supplicant.output.txt

Larry


From Eyes-Killer at gmx.de  Mon Jul  9 09:16:58 2007
From: Eyes-Killer at gmx.de (Florian Erfurth)
Date: Mon, 09 Jul 2007 09:16:58 +0200
Subject: Ferrari 3400 device?
In-Reply-To: <4690049F.7040208@lwfinger.net>
References: <468F4CFD.1050604@gmx.net>
	<468F4F19.3030203@Wetwork.Net>	<46900118.2070705@gmx.de>
	<4690049F.7040208@lwfinger.net>
Message-ID: <4691E0EA.1040504@gmx.de>

Larry Finger schrieb:
> Florian Erfurth wrote:
>   
>> Ehud Gavron schrieb:
>>     
>>> Lastly, there is a known POWER problem, which results in better 
>>> transmission if the transmission rates are reduced.
>>>       
>> Do you mean this issue?
>> bcm43xx_mac80211: !WARNING! Idle-TSSI phy->cur_id
>> le_tssi measuring failed. (cur=0, tgt=62). Disabling TX power adjustment.
>>     
>
> That is one part of the power problem, but there are others that don't print any warnings.
>
> One word of caution: When I use the bcm43xx-mac80211 driver that you are now trying, I get a maximum 
> throughput of 1-2 Mbs. With the bcm43xx (softmac) driver in kernels 2.6.21 or later, I get maximum 
> throughput of 15 Mbs under identical conditions.
>   
Only 15Mbs? At home I get the best connection (about 4m away from 
accesspoint).
 >>>
[root at Turion ~]# iwconfig
wlan0 IEEE 802.11b/g ESSID:"homeworld" Nickname:"Turion"
Mode:Managed Frequency=2.462 GHz Access Point: XX:XX:XX:XX:XX:XX
Bit Rate=24 Mb/s Tx-Power=19 dBm
RTS thr:off Fragment thr:off
Encryption key:XXXX-XXXX-XXXX-XXXX-XXXX-XXXX-XX Security mode:open
Link Quality=65/100 Signal level=-45 dBm Noise level=-73 dBm
Rx invalid nwid:0 Rx invalid crypt:0 Rx invalid frag:0
Tx excessive retries:0 Invalid misc:0 Missed beacon:0
<<<

I'm using 2.6.22-rc6 with bcm43xx (with Firmware V3). With 
bcm43xx-mac80211 the connection is not reliable, unfortunatelly.

Another question... the patches in 2.6.22-rc6 will be in official kernel 
2.6.22? I mean, if Fedora bring out 2.6.22-X kernel-package then it 
contains the patches?

cu Floh


From larry.finger at lwfinger.net  Mon Jul  9 17:23:39 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 09 Jul 2007 10:23:39 -0500
Subject: Ferrari 3400 device?
In-Reply-To: <4691E0EA.1040504@gmx.de>
References: <468F4CFD.1050604@gmx.net>
	<468F4F19.3030203@Wetwork.Net>	<46900118.2070705@gmx.de>
	<4690049F.7040208@lwfinger.net> <4691E0EA.1040504@gmx.de>
Message-ID: <469252FB.4000106@lwfinger.net>

Florian Erfurth wrote:
> Larry Finger schrieb:
> Only 15Mbs? At home I get the best connection (about 4m away from 
> accesspoint).
>  >>>
> [root at Turion ~]# iwconfig
> wlan0 IEEE 802.11b/g ESSID:"homeworld" Nickname:"Turion"
> Mode:Managed Frequency=2.462 GHz Access Point: XX:XX:XX:XX:XX:XX
> Bit Rate=24 Mb/s Tx-Power=19 dBm
> RTS thr:off Fragment thr:off
> Encryption key:XXXX-XXXX-XXXX-XXXX-XXXX-XXXX-XX Security mode:open
> Link Quality=65/100 Signal level=-45 dBm Noise level=-73 dBm
> Rx invalid nwid:0 Rx invalid crypt:0 Rx invalid frag:0
> Tx excessive retries:0 Invalid misc:0 Missed beacon:0
> <<<
> 
> I'm using 2.6.22-rc6 with bcm43xx (with Firmware V3). With 
> bcm43xx-mac80211 the connection is not reliable, unfortunatelly.
> 
> Another question... the patches in 2.6.22-rc6 will be in official kernel 
> 2.6.22? I mean, if Fedora bring out 2.6.22-X kernel-package then it 
> contains the patches?

I was not talking about the "Bit Rate" reported by iwconfig. My numbers were _MEASURED_ using Iperf 
and by file transfer to a server on my LAN. FYI, the maximum rate for Windows XP under the same 
conditions is 19 Mbs, and it reports a bit rate of 54 Mbs.

AFAIK, all Fedora kernels in the future will contain a bcm43xx driver with a restricted PCI ID list. 
To use bcm43xx, rather than bcm43xx-mac80211, you should copy and paste the script below to a file, 
use chmod to make it executable, and run it as root.

========================

#!/bin/sh

echo 'blacklist bcm43xx-mac80211' >> /etc/modprobe.d/blacklist

modprobe -r bcm43xx-mac80211 # remove the new driver

echo 'modprobe bcm43xx' >> /etc/rc.local

BCM43XX_PCI_ID=`lspci -n | grep 14e4 | awk '{ print $3 }' | sed -e 's/:/ /'`
echo 'echo "'$BCM43XX_PCI_ID'" > /sys/bus/pci/drivers/bcm43xx/new_id' \
	>> /etc/rc.local

================
After this script is run once, you should do a '/etc/rc.local' command (as root). BTW, this script 
is adapted from one posted by John Linville.

Larry


From andipeer at gmx.net  Mon Jul  9 19:14:05 2007
From: andipeer at gmx.net (Andreas Peer)
Date: Mon, 09 Jul 2007 19:14:05 +0200
Subject: Ferrari 3400 device?
In-Reply-To: <468F5ADC.7000704@Wetwork.Net>
References: <468F4CFD.1050604@gmx.net> <468F4F19.3030203@Wetwork.Net>
	<468F5505.9050207@gmx.net> <468F5ADC.7000704@Wetwork.Net>
Message-ID: <46926CDD.2070606@gmx.net>

Now I checked out & compiled the kernel from the wireless-dev tree 
(2.6.22-rc7), and the bcm43xx_mac80211 module rocks! Well, the 
throughput is not the best (1-5MBs), but that is not such a problem. The 
main thing is that I can connect to the network wherever I can on Windows.

Thank you all for your help!!


From eddyzhum at gmail.com  Tue Jul 10 08:18:26 2007
From: eddyzhum at gmail.com (Eddy Zhu)
Date: Mon, 9 Jul 2007 23:18:26 -0700
Subject: trouble installing driver for bcm4318
Message-ID: <d14ceb2b0707092318g338b69cau201ff5ee23924fd7@mail.gmail.com>

Hi

I am a newbie to Linux world.  I have successfully installed Fedora 6.0 in
my compaq presario laptop.  But my wireless card doesn't seem to work.  I
have already spent hours researched online but I can't get a complete
instructions step by step on installing a driver for bcm4318.

Please kindly post a complete step by step installation instruction on how
to download and install the bcm43xx driver in Fedora 6.0 O.S.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070709/a159c508/attachment.html>

From larry.finger at lwfinger.net  Tue Jul 10 17:08:23 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 10 Jul 2007 10:08:23 -0500
Subject: trouble installing driver for bcm4318
In-Reply-To: <d14ceb2b0707092318g338b69cau201ff5ee23924fd7@mail.gmail.com>
References: <d14ceb2b0707092318g338b69cau201ff5ee23924fd7@mail.gmail.com>
Message-ID: <4693A0E7.1050108@lwfinger.net>

Eddy Zhu wrote:
> Hi
> 
> I am a newbie to Linux world.  I have successfully installed Fedora 6.0 
> in my compaq presario laptop.  But my wireless card doesn't seem to 
> work.  I have already spent hours researched online but I can't get a 
> complete instructions step by step on installing a driver for bcm4318. 
> 
> Please kindly post a complete step by step installation instruction on 
> how to download and install the bcm43xx driver in Fedora 6.0 O.S.

Under Linux, it is important to list your kernel version in addition to your distro version for two 
reasons. Firstly, there are so many distros that one cannot remember what each one includes. 
Secondly, the kernel may have been updated independently of the distro. For example, I'm running the 
x86-64 version of openSUSE 10.2 for which the standard kernel is 2.6.18; however, I'm running kernel 
2.6.22. You use the command 'uname -r' (without the quotes) to get the kernel version.

As stated above, I'm not a Fedora user and I may get some of the following wrong.

Have you installed the firmware for your bcm43xx card? If not, you will need to do the following as 
root:

Find your Windows driver. It will likely be named bcmwl5.sys.

Issue the following commands:

yum install bcm43xx-fwcutter
bcm43xx-fwcutter -w /lib/firmware XXXXXX.sys

where XXXXXX is replaced by the path and name of your Windows driver.

If you send your kernel version, we will be able to get you the rest of the way.

Larry



From gavron at Wetwork.Net  Wed Jul 11 05:29:30 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Tue, 10 Jul 2007 20:29:30 -0700
Subject: 2.6.22(linville git) bcm4306 unhappy with "bbat(11)"...
Message-ID: <46944E9A.1030702@Wetwork.Net>

Interestingly neither bcm43xx nor bcm43xx_mac80211 automatically load.  
However, when I modprobe bcm43xx_mac80211 the following happens.  I 
would love to know how to fix the "module won't load automatically" 
issue. However, here ya go:
....
bcm43xx_mac80211: Adding Interface type 2
bcm43xx_mac80211: Loading firmware version 371.1061 (2006-10-04 21:02:04)
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: ERROR: bbatt(11) >= size of LO array
[<e4a50cf4>] bcm43xx_get_lo_g_ctl+0x51/0x8d [bcm43xx_mac80211]
[<e4a50d6b>] bcm43xx_lo_g_ctl_current+0x3b/0x3e [bcm43xx_mac80211]
[<e4a50e4f>] bcm43xx_lo_g_adjust+0x8/0x12 [bcm43xx_mac80211]
[<e4a4b97a>] bcm43xx_phy_init_pctl+0x2ed/0x5fc [bcm43xx_mac80211]
[<e4a466f0>] bcm43xx_phy_write+0x5c/0x64 [bcm43xx_mac80211]
[<e4a4e998>] bcm43xx_phy_initg+0xbe2/0xc44 [bcm43xx_mac80211]
[<e4a4f125>] bcm43xx_phy_init+0x518/0x534 [bcm43xx_mac80211]
[<e4a4254b>] bcm43xx_chip_init+0x639/0x904 [bcm43xx_mac80211]
[<e4a43509>] bcm43xx_wireless_core_init+0x21e/0x67a [bcm43xx_mac80211]
[<e4a44cd1>] bcm43xx_add_interface+0x56/0xe1 [bcm43xx_mac80211]
bcm43xx_mac80211: Chip initialized
bcm43xx_mac80211: 30-bit DMA initialized
bcm43xx_mac80211: Wireless interface started


....
06:00.0 Network controller: Broadcom Corporation BCM4306 802.11b/g 
Wireless LAN Controller (rev 03)
       Subsystem: Linksys WPC54G
       Flags: bus master, fast devsel, latency 64, IRQ 11
       Memory at 3c000000 (32-bit, non-prefetchable) [size=8K]
       Capabilities: [40] Power Management version 2
....
[root at techeg ~]# lspci -n
00:00.0 0600: 8086:7190 (rev 03)
00:01.0 0604: 8086:7191 (rev 03)
00:04.0 0607: 104c:ac1b (rev 03)
00:04.1 0607: 104c:ac1b (rev 03)
00:07.0 0680: 8086:7110 (rev 02)
00:07.1 0101: 8086:7111 (rev 01)
00:07.2 0c03: 8086:7112 (rev 01)
00:07.3 0680: 8086:7113 (rev 03)
00:08.0 0401: 125d:1978 (rev 10)
00:09.0 0200: 8086:1229 (rev 09)
00:09.1 0700: 11c1:0445
01:00.0 0300: 1002:4c4d (rev 64)
06:00.0 0280: 14e4:4320 (rev 03)
....
[root at techeg ~]# uname -a
Linux techeg.login.com 2.6.22 #1 SMP Tue Jul 10 15:27:15 MST 2007 i686 
i686 i386 GNU/Linux
....
[root at techeg ~]# dmesg | grep bcm
bcm43xx_mac80211: Broadcom 4306 WLAN found
bcm43xx_mac80211: Found PHY: Analog 2, Type 2, Revision 2
bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
bcm43xx_mac80211: Radio turned off
bcm43xx driver
bcm43xx driver
bcm43xx driver
bcm43xx driver
bcm43xx_mac80211: Adding Interface type 2
bcm43xx_mac80211: Loading firmware version 371.1061 (2006-10-04 21:02:04)
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: ERROR: bbatt(11) >= size of LO array
[<e4a50cf4>] bcm43xx_get_lo_g_ctl+0x51/0x8d [bcm43xx_mac80211]
[<e4a50d6b>] bcm43xx_lo_g_ctl_current+0x3b/0x3e [bcm43xx_mac80211]
[<e4a50e4f>] bcm43xx_lo_g_adjust+0x8/0x12 [bcm43xx_mac80211]
[<e4a4b97a>] bcm43xx_phy_init_pctl+0x2ed/0x5fc [bcm43xx_mac80211]
[<e4a466f0>] bcm43xx_phy_write+0x5c/0x64 [bcm43xx_mac80211]
[<e4a4e998>] bcm43xx_phy_initg+0xbe2/0xc44 [bcm43xx_mac80211]
[<e4a4f125>] bcm43xx_phy_init+0x518/0x534 [bcm43xx_mac80211]
[<e4a4254b>] bcm43xx_chip_init+0x639/0x904 [bcm43xx_mac80211]
[<e4a43509>] bcm43xx_wireless_core_init+0x21e/0x67a [bcm43xx_mac80211]
[<e4a44cd1>] bcm43xx_add_interface+0x56/0xe1 [bcm43xx_mac80211]
bcm43xx_mac80211: Chip initialized
bcm43xx_mac80211: 30-bit DMA initialized
bcm43xx_mac80211: Wireless interface started
bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
bcm43xx_mac80211: Removing Interface type 2
bcm43xx_mac80211: Wireless interface stopped
bcm43xx_mac80211: DMA-32 0x0200 (RX) max used slots: 1/64
bcm43xx_mac80211: DMA-32 0x02A0 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0280 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0260 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0240 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0220 (TX) max used slots: 2/128
bcm43xx_mac80211: DMA-32 0x0200 (TX) max used slots: 0/128
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Adding Interface type 2
bcm43xx_mac80211: Loading firmware version 371.1061 (2006-10-04 21:02:04)
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: Chip initialized
bcm43xx_mac80211: 30-bit DMA initialized
bcm43xx_mac80211: Wireless interface started
bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
bcm43xx_mac80211: Removing Interface type 2
bcm43xx_mac80211: Wireless interface stopped
bcm43xx_mac80211: DMA-32 0x0200 (RX) max used slots: 1/64
bcm43xx_mac80211: DMA-32 0x02A0 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0280 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0260 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0240 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0220 (TX) max used slots: 2/128
bcm43xx_mac80211: DMA-32 0x0200 (TX) max used slots: 0/128
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Broadcom 4306 WLAN found
bcm43xx_mac80211: Found PHY: Analog 2, Type 2, Revision 2
bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
bcm43xx_mac80211: Radio turned off
bcm43xx driver
bcm43xx_mac80211: Adding Interface type 2
bcm43xx_mac80211: Loading firmware version 371.1061 (2006-10-04 21:02:04)
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: ERROR: bbatt(11) >= size of LO array
[<e4a50cf4>] bcm43xx_get_lo_g_ctl+0x51/0x8d [bcm43xx_mac80211]
[<e4a50d6b>] bcm43xx_lo_g_ctl_current+0x3b/0x3e [bcm43xx_mac80211]
[<e4a50e4f>] bcm43xx_lo_g_adjust+0x8/0x12 [bcm43xx_mac80211]
[<e4a4b97a>] bcm43xx_phy_init_pctl+0x2ed/0x5fc [bcm43xx_mac80211]
[<e4a466f0>] bcm43xx_phy_write+0x5c/0x64 [bcm43xx_mac80211]
[<e4a4e998>] bcm43xx_phy_initg+0xbe2/0xc44 [bcm43xx_mac80211]
[<e4a4f125>] bcm43xx_phy_init+0x518/0x534 [bcm43xx_mac80211]
[<e4a4254b>] bcm43xx_chip_init+0x639/0x904 [bcm43xx_mac80211]
[<e4a43509>] bcm43xx_wireless_core_init+0x21e/0x67a [bcm43xx_mac80211]
[<e4a44cd1>] bcm43xx_add_interface+0x56/0xe1 [bcm43xx_mac80211]
bcm43xx_mac80211: Chip initialized
bcm43xx_mac80211: 30-bit DMA initialized
bcm43xx_mac80211: Wireless interface started
bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
bcm43xx_mac80211: Removing Interface type 2
bcm43xx_mac80211: Wireless interface stopped
bcm43xx_mac80211: DMA-32 0x0200 (RX) max used slots: 1/64
bcm43xx_mac80211: DMA-32 0x02A0 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0280 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0260 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0240 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0220 (TX) max used slots: 2/128
bcm43xx_mac80211: DMA-32 0x0200 (TX) max used slots: 0/128
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Adding Interface type 2
bcm43xx_mac80211: Loading firmware version 371.1061 (2006-10-04 21:02:04)
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: Chip initialized
bcm43xx_mac80211: 30-bit DMA initialized
bcm43xx_mac80211: Wireless interface started
bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
bcm43xx_mac80211: Removing Interface type 2
bcm43xx_mac80211: Wireless interface stopped
bcm43xx_mac80211: DMA-32 0x0200 (RX) max used slots: 1/64
bcm43xx_mac80211: DMA-32 0x02A0 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0280 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0260 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0240 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0220 (TX) max used slots: 4/128
bcm43xx_mac80211: DMA-32 0x0200 (TX) max used slots: 0/128
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Adding Interface type 2
bcm43xx_mac80211: Loading firmware version 371.1061 (2006-10-04 21:02:04)
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: Chip initialized
bcm43xx_mac80211: 30-bit DMA initialized
bcm43xx_mac80211: Wireless interface started
bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
....

1001  lsmod  | grep bcm                    <--- no such modules, no 
wireless interfaces
1002  modprobe bcm43xx_mac80211            <--- no errors
1003  lsmod | grep bcm                     <--- loaded
1004  iwconfig                             <--- all there
1005  dmesg                                <--- hmmm, error to send to 
the list later
1008  iwconfig wlan0 essid wetwork key key-went-here open   <-- that worked
1009  iwconfig                             <--- not associated yet
1010  iwconfig                             <--- now we are
1011  dhclient wlan0                       <--- try running the dhcp client
1012  ifconfig wlan0                       <--- rx/tx incrementing
1013  ifconfig wlan0                       <--- rx isn't.  damn network 
manager. 1014  killall NetworkManager               <--- that problem is 
done
1015  killall dhclient                     <--- let's try again
1016  dhclient wlan0                       <--- dhcp ok now?
1017  ifconfig wlan0                       <--- check rx/tx counters
1018  ifconfig wlan0                       <--- hmmm... that isn't it 
yet...
1019  iwconfig                             <--- yeah seems ok
1020  iwconfig wlan0                       <--- oh no, networkmanager 
scrozzled it before it left
1021  iwconfig wlan0 essid wetwork key key-went-here open  <--- last try
1022  dmesg                                <--- same error.  definitely 
send to the list.
1023  tail /var/log/messages               <--- association succeeded
1024  iwconfig                             <--- link quality good
1025  ifconfig                             <--- rx/tx incrementing?
1026  ifconfig wlan0                       <--- rx is... good enough....
1027  dhclient wlan0                       <--- now let's try DHCP
1028  dmesg | grep bcm | more              <--- and get the errors for 
the list...
1029  lspci -n                             <--- and the rest of the diags
1030  lspci -v
1031  lspci -n
1032  uname -a
1033  dmesg | grep bcm
1034  history
...
[root at techeg ~]# iwconfig
lo        no wireless extensions.

eth0      no wireless extensions.

irda0     no wireless extensions.

wmaster0  no wireless extensions.

wlan0     IEEE 802.11g  ESSID:"wetwork"          Mode:Managed  
Frequency:2.462 GHz  Access Point: 00:07:40:9F:5B:52           Bit 
Rate=54 Mb/s           Retry min limit:7   RTS thr:off   Fragment 
thr=2346 B           Encryption key:key-goes-here
         Link Quality=43/100  Signal level=-48 dBm  Noise level=-80 dBm
         Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
         Tx excessive retries:0  Invalid misc:0   Missed beacon:0

[root at techeg ~]# iwlist wlan0 scan
wlan0     Scan completed :
         Cell 01 - Address: 00:0D:0B:11:5C:1B
                   ESSID:"wetwork"
                   Mode:Master
                   Channel:6
                   Frequency:2.437 GHz
                   Quality=41/100  Signal level=-63 dBm  Noise level=-67 
dBm
                   Encryption key:on
                   Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s
                             9 Mb/s; 12 Mb/s; 18 Mb/s; 24 Mb/s; 36 Mb/s
                             48 Mb/s; 54 Mb/s
                   Extra:tsf=0000016c9c09e258
         Cell 02 - Address: 00:07:40:9F:5B:52
                   ESSID:"wetwork"
                   Mode:Master
                   Channel:11
                   Frequency:2.462 GHz
                   Quality=46/100  Signal level=-55 dBm  Noise level=-67 
dBm
                   Encryption key:on
                   Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 6 Mb/s; 9 Mb/s
                             11 Mb/s; 12 Mb/s; 18 Mb/s; 24 Mb/s; 36 Mb/s
                             48 Mb/s; 54 Mb/s
                   Extra:tsf=00000bf4fa5557fe
....
and I know it's not ipperf... but speedtest.net shows 5Mbps+ with 
bcm43xx_mac80211 on this 4306.  I only get 400Kbps on my 4311...
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070710/e0a5a00d/attachment.bin>

From Larry.Finger at lwfinger.net  Thu Jul 12 16:34:55 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 12 Jul 2007 09:34:55 -0500
Subject: bcm4301: A mac80211 driver using V3 firmware
Message-ID: <46963C0F.3080104@lwfinger.net>

John and Michael,

I have good news regarding the driver mentioned in the subject. It is now working on my BCM4311 with 
performance that is nearly as good as for the softmac driver.

My approach has been to take the PHY and radio parts of the softmac driver and use them with as much 
of the bcm43xx-mac80211 code as possible. It therefore uses the SSB driver as part of the front end.

My plan is to clean up the code, check it with my BCM4306 and BCM4318 devices, and then make it 
available as a patch against the mainline source for more general testing. At the same time, I will 
publish the results of my performance testing of all 3 models. Once it is shown to be reliable, a 
decision can be made regarding its inclusion in mainline and if it should support B and G devices, 
or be restricted to B-only devices. The A-PHY code has been stripped out.

Larry



From dwmw2 at infradead.org  Fri Jul 13 01:24:22 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 13 Jul 2007 00:24:22 +0100
Subject: Multicast RX and TX both broken
In-Reply-To: <1184282128.3136.12.camel@shinybook.infradead.org>
References: <1184282128.3136.12.camel@shinybook.infradead.org>
Message-ID: <1184282663.2785.0.camel@shinybook.infradead.org>

On Fri, 2007-07-13 at 00:15 +0100, David Woodhouse wrote:
> I'm going back to the softmac driver for now. Although I might follow up
> with a report of the crash which happens when I the remove
> bcm43xx-mac80211 module. 

Hm, I'm sure it locked the entire machine last time, but this time when
I did it from a console it 'only' did this...

bcm43xx_mac80211: Radio turned off
unregister_netdevice: waiting for eth1 to become free. Usage count = 5
unregister_netdevice: waiting for eth1 to become free. Usage count = 5

-- 
dwmw2



From dwmw2 at infradead.org  Fri Jul 13 01:15:28 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 13 Jul 2007 00:15:28 +0100
Subject: Multicast RX and TX both broken
Message-ID: <1184282128.3136.12.camel@shinybook.infradead.org>

Multicast receive is not working in bcm43xx-mac80211 (BCM4306 on
PowerBook G4); Fedora rawhide's 2.6.22-rc7-git3 kernel.

When I bring up the interface, tcpdump shows me these packets...

00:00:42.937394 00:0a:95:f3:99:92 > 33:33:ff:f3:99:92, ethertype IPv6 (0x86dd), length 78: :: > ff02::1:fff3:9992: ICMP6, neighbor solicitation, who has fe80::20a:95ff:fef3:9992, length 24
00:00:43.091015 00:0a:95:f3:99:92 > 33:33:ff:f3:99:92, ethertype IPv6 (0x86dd), length 78: :: > ff02::1:fff3:9992: ICMP6, neighbor solicitation, who has fe80::20a:95ff:fef3:9992, length 24
00:00:44.951285 00:40:f4:28:95:9d > 33:33:00:00:00:01, ethertype IPv6 (0x86dd), length 118: fe80::240:f4ff:fe28:959d > ff02::1: ICMP6, router advertisement, length 64
00:00:44.989337 00:0a:95:f3:99:92 > 33:33:ff:f3:99:92, ethertype IPv6 (0x86dd), length 78: :: > ff02::1:fff3:9992: ICMP6, neighbor solicitation, who has 2001:8b0:10b:1:20a:95ff:fef3:9992, length 24

If I run 'tcpdump -p' to refrain from putting it in promiscuous mode, I
don't see the RA packet to 33:33:00:00:00:01. And IPv6 autoconfiguration
doesn't work.

It _does_, however, see its own outgoing neighbour solicitation packet
as if it came from another host on the network, leading to messages
saying 'eth1: duplicate address detected!' and the IPv6 link-local
address being marked as 'tentative' and never actually working (until I
remove it and add it again manually, after which the reception of RA
packets _still_ doesn't work).

You can test this by just building with IPv6 support, and observing the
output of 'ip -6 addr list'. When it's seeing its own packets, it looks
like this:

5: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qlen 1000
    inet6 fe80::20a:95ff:fef3:9992/64 scope link tentative 

When it's working properly, that 'tentative' isn't there.

You can test multicast RX by running radvd on the network -- you don't
need proper IPv6 connectivity; you can do it with site-local addresses
with a configuration like the following (run this on _another_ machine
on the network; either on the wireless or bridged to it):

interface eth1
{
        AdvSendAdvert on;
        MinRtrAdvInterval 30;
        MaxRtrAdvInterval 100;
        prefix fec0::/64
        {
                AdvOnLink on;
                AdvAutonomous on;
                AdvRouterAddr off;
        };

};

I'm going back to the softmac driver for now. Although I might follow up
with a report of the crash which happens when I the remove
bcm43xx-mac80211 module.

-- 
dwmw2



From news at tecnicaict.com  Fri Jul 13 12:09:52 2007
From: news at tecnicaict.com (tICT)
Date: Fri, 13 Jul 2007 12:09:52 +0200
Subject: Bcm43xx-dev Digest, Vol 13, Issue 13
In-Reply-To: <mailman.72.1184320866.17418.bcm43xx-dev@lists.berlios.de>
References: <mailman.72.1184320866.17418.bcm43xx-dev@lists.berlios.de>
Message-ID: <46974F70.90103@tecnicaict.com>

bcm43xx-dev-request at lists.berlios.de ha scritto:
> Date: Thu, 12 Jul 2007 09:34:55 -0500
> From: Larry Finger <Larry.Finger at lwfinger.net>
> Subject: bcm4301: A mac80211 driver using V3 firmware
> Message-ID: <46963C0F.3080104 at lwfinger.net>
>
> John and Michael,
>
> I have good news regarding the driver mentioned in the subject. It is now working on my BCM4311 with 
> performance that is nearly as good as for the softmac driver.
>
> My approach has been to take the PHY and radio parts of the softmac driver and use them with as much 
> of the bcm43xx-mac80211 code as possible. It therefore uses the SSB driver as part of the front end.
>
> My plan is to clean up the code, check it with my BCM4306 and BCM4318 devices, and then make it 
> available as a patch against the mainline source for more general testing. At the same time, I will 
> publish the results of my performance testing of all 3 models. Once it is shown to be reliable, a 
> decision can be made regarding its inclusion in mainline and if it should support B and G devices, 
> or be restricted to B-only devices. The A-PHY code has been stripped out.
>
> Larry
>
>   


Great job Larry.
Thanks for your support!

Michele


From mb at bu3sch.de  Fri Jul 13 12:37:28 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 13 Jul 2007 12:37:28 +0200
Subject: Multicast RX and TX both broken
In-Reply-To: <1184282128.3136.12.camel@shinybook.infradead.org>
References: <1184282128.3136.12.camel@shinybook.infradead.org>
Message-ID: <200707131237.28718.mb@bu3sch.de>

On Friday 13 July 2007 01:15:28 David Woodhouse wrote:
> If I run 'tcpdump -p' to refrain from putting it in promiscuous mode, I
> don't see the RA packet to 33:33:00:00:00:01. And IPv6 autoconfiguration
> doesn't work.

So, what if you run promisc?

-- 
Greetings Michael.


From dwmw2 at infradead.org  Fri Jul 13 12:48:27 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 13 Jul 2007 11:48:27 +0100
Subject: Multicast RX and TX both broken
In-Reply-To: <200707131237.28718.mb@bu3sch.de>
References: <1184282128.3136.12.camel@shinybook.infradead.org>
	<200707131237.28718.mb@bu3sch.de>
Message-ID: <1184323707.2785.24.camel@shinybook.infradead.org>

On Fri, 2007-07-13 at 12:37 +0200, Michael Buesch wrote:
> On Friday 13 July 2007 01:15:28 David Woodhouse wrote:
> > If I run 'tcpdump -p' to refrain from putting it in promiscuous mode, I
> > don't see the RA packet to 33:33:00:00:00:01. And IPv6 autoconfiguration
> > doesn't work.
> 
> So, what if you run promisc?

Then tcpdump sees it, as I showed, but the kernel still doesn't actually
pick up the address it's advertising.

-- 
dwmw2



From comphappy at gmail.com  Fri Jul 13 17:20:40 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Fri, 13 Jul 2007 07:20:40 -0800
Subject: trouble installing driver for bcm4318
In-Reply-To: <4693A0E7.1050108@lwfinger.net>
References: <d14ceb2b0707092318g338b69cau201ff5ee23924fd7@mail.gmail.com>
	<4693A0E7.1050108@lwfinger.net>
Message-ID: <b2d05de20707130820u1acc7275s27b73ef254b9bbf2@mail.gmail.com>

look back in the archive a little, you will find a detailed list of
instructions that i posted.
here it is i think
http://lists.berlios.de/pipermail/bcm43xx-dev/2007-July/004985.html

On 7/10/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> Eddy Zhu wrote:
> > Hi
> >
> > I am a newbie to Linux world.  I have successfully installed Fedora 6.0
> > in my compaq presario laptop.  But my wireless card doesn't seem to
> > work.  I have already spent hours researched online but I can't get a
> > complete instructions step by step on installing a driver for bcm4318.
> >
> > Please kindly post a complete step by step installation instruction on
> > how to download and install the bcm43xx driver in Fedora 6.0 O.S.
>
> Under Linux, it is important to list your kernel version in addition to your distro version for two
> reasons. Firstly, there are so many distros that one cannot remember what each one includes.
> Secondly, the kernel may have been updated independently of the distro. For example, I'm running the
> x86-64 version of openSUSE 10.2 for which the standard kernel is 2.6.18; however, I'm running kernel
> 2.6.22. You use the command 'uname -r' (without the quotes) to get the kernel version.
>
> As stated above, I'm not a Fedora user and I may get some of the following wrong.
>
> Have you installed the firmware for your bcm43xx card? If not, you will need to do the following as
> root:
>
> Find your Windows driver. It will likely be named bcmwl5.sys.
>
> Issue the following commands:
>
> yum install bcm43xx-fwcutter
> bcm43xx-fwcutter -w /lib/firmware XXXXXX.sys
>
> where XXXXXX is replaced by the path and name of your Windows driver.
>
> If you send your kernel version, we will be able to get you the rest of the way.
>
> Larry
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows 98 or better'. So I installed Linux"


From dwmw2 at infradead.org  Fri Jul 13 19:25:23 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 13 Jul 2007 18:25:23 +0100
Subject: Multicast RX and TX both broken
In-Reply-To: <1184323707.2785.24.camel@shinybook.infradead.org>
References: <1184282128.3136.12.camel@shinybook.infradead.org>
	<200707131237.28718.mb@bu3sch.de>
	<1184323707.2785.24.camel@shinybook.infradead.org>
Message-ID: <1184347523.2785.32.camel@shinybook.infradead.org>

On Fri, 2007-07-13 at 11:48 +0100, David Woodhouse wrote:
> On Fri, 2007-07-13 at 12:37 +0200, Michael Buesch wrote:
> > On Friday 13 July 2007 01:15:28 David Woodhouse wrote:
> > > If I run 'tcpdump -p' to refrain from putting it in promiscuous mode, I
> > > don't see the RA packet to 33:33:00:00:00:01. And IPv6 autoconfiguration
> > > doesn't work.
> > 
> > So, what if you run promisc?
> 
> Then tcpdump sees it, as I showed, but the kernel still doesn't actually
> pick up the address it's advertising.

[11:55] <mb__> Where do you think the packet is rejected? At HW, driver or stack level?

I'm not sure. Perhaps the macfilter filters it out when the device isn't
in promiscuous mode?

[11:56] <mb__> Ah, tcpdump sees the packet.

When the device is in promiscuous mode, yes. But not otherwise.

So it's not being correctly delivered from mac80211 to the host stack.
Maybe because the macfilter eats it, or maybe bcm43xx does receive it
and mac80211 assigns it type PACKET_OTHERHOST so it gets ignored. But
there's definitely _something_ wrong here.

-- 
dwmw2



From dwmw2 at infradead.org  Sun Jul 15 10:42:55 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Sun, 15 Jul 2007 09:42:55 +0100
Subject: Multicast RX and TX both broken
In-Reply-To: <1184282663.2785.0.camel@shinybook.infradead.org>
References: <1184282128.3136.12.camel@shinybook.infradead.org>
	<1184282663.2785.0.camel@shinybook.infradead.org>
Message-ID: <1184488975.487.9.camel@pmac.infradead.org>

On Fri, 2007-07-13 at 00:24 +0100, David Woodhouse wrote:
> On Fri, 2007-07-13 at 00:15 +0100, David Woodhouse wrote:
> > I'm going back to the softmac driver for now. Although I might follow up
> > with a report of the crash which happens when I the remove
> > bcm43xx-mac80211 module. 
> 
> Hm, I'm sure it locked the entire machine last time, but this time when
> I did it from a console it 'only' did this...
> 
> bcm43xx_mac80211: Radio turned off
> unregister_netdevice: waiting for eth1 to become free. Usage count = 5
> unregister_netdevice: waiting for eth1 to become free. Usage count = 5

Accompanied by a bunch of complaints like this...

Slab corruption (Not tainted): size-192 start=d8a21b88, len=192
Redzone: 0x9f911029d74e35b/0x9f911029d74e35b.
Last user: [<f2ce5428>](inet6_ifa_finish_destroy+0x10c/0x120 [ipv6])
020: 6b 6b 6b 6b 6b 6b 6b 6a 6b 6b 6b 6b 6b 6b 6b 6b

-- 
dwmw2



From 167_ at libero.it  Sun Jul 15 17:01:44 2007
From: 167_ at libero.it (167)
Date: Sun, 15 Jul 2007 15:01:44 +0000
Subject: can I contribute to the project ?
Message-ID: <469A36D8.6080106@libero.it>

Hello. i'm a programmer that owns an HP pavilion which has a bcm 4319
wireless card .
Here is the output of lspci -n  :
> 06:02.0 0280: 14e4:4319 (rev 02)
i see in the "status" page that the driver for this card is under
development. I've written some programs in c under linux and i took some
courses about digital electronics at the university ,so i was asking
myself if kernel programming in linux is that hard and if i can
contribute to the project and help fixing the driver or help reverse
engineering the specs  . If so , where do i start ? do you know some
good (free) book on kernel programming ?

( p.s: sorry for the silly email adress, but i hate spammers ..  )


From larry.finger at lwfinger.net  Sun Jul 15 20:03:41 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 15 Jul 2007 13:03:41 -0500
Subject: can I contribute to the project ?
In-Reply-To: <469A36D8.6080106@libero.it>
References: <469A36D8.6080106@libero.it>
Message-ID: <469A617D.1070605@lwfinger.net>

167 wrote:
> Hello. i'm a programmer that owns an HP pavilion which has a bcm 4319
> wireless card .
> Here is the output of lspci -n  :
>> 06:02.0 0280: 14e4:4319 (rev 02)
> i see in the "status" page that the driver for this card is under
> development. I've written some programs in c under linux and i took some
> courses about digital electronics at the university ,so i was asking
> myself if kernel programming in linux is that hard and if i can
> contribute to the project and help fixing the driver or help reverse
> engineering the specs  . If so , where do i start ? do you know some
> good (free) book on kernel programming ?

Any kernel 2.6.21 or later should support the 4319, at least in B/G mode. I think that chip also 
supports 802.11a, but the driver does not.

We are always happy for more help with fixes. The Documentation directory in the Linux source 
contains a good many files that describe parts of the kernel and how to submit patches. There is 
also a new facility (scripts/checkpatch.pl) that will check for problems in a patch. For information 
about kernel driver programming, see http://www.kernel.org/pub/linux/kernel/people/gregkh/ddk/ for 
ISO images.

To check for obvious problems keeping your driver from working, you should follow this checklist:

1. Is your kernel new enough? The output of 'uname -r' will tell you. If your kernel fails to match 
the criterion above, type the following two commands:

  wwget ftp://lwfinger.dynalias.org/patches/bcm43xx_get_driver
  sh ./bcm43xx_get_driver

As long as you have the kernel headers and gcc installed, this will download and build the necessary 
drivers.

2. Is the firmware installed? You didn't say what Linux distro you use, but you need to install 
bcm43xx-fwcutter by using 'emerge', 'yum', 'YaST', or whatever is appropriate. Next you should

       wget ftp://lwfinger.dynalias.org/patches/bcm43xx_get_firmware
       sh ./bcm43xx_get_firmware

Once those two steps are done, the driver should load and work. If you have problems, any further 
postings should include the output from a 'dmesg | grep bcm43xx' command.

Larry


From mb at bu3sch.de  Mon Jul 16 00:55:04 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 16 Jul 2007 00:55:04 +0200
Subject: can I contribute to the project ?
In-Reply-To: <469A36D8.6080106@libero.it>
References: <469A36D8.6080106@libero.it>
Message-ID: <200707160055.04982.mb@bu3sch.de>

On Sunday 15 July 2007 17:01:44 167 wrote:
> Hello. i'm a programmer that owns an HP pavilion which has a bcm 4319
> wireless card .
> Here is the output of lspci -n  :
> > 06:02.0 0280: 14e4:4319 (rev 02)
> i see in the "status" page that the driver for this card is under
> development. I've written some programs in c under linux and i took some
> courses about digital electronics at the university ,so i was asking
> myself if kernel programming in linux is that hard and if i can
> contribute to the project and help fixing the driver or help reverse
> engineering the specs  . If so , where do i start ? do you know some
> good (free) book on kernel programming ?

I would be happy, if you'd join the reverse engineering team.
Currently there's kind of a bottleneck, as our two active people
are busy with other things.

-- 
Greetings Michael.


From hs4233 at mail.mn-solutions.de  Mon Jul 16 08:54:46 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Mon, 16 Jul 2007 08:54:46 +0200
Subject: can I contribute to the project ?
In-Reply-To: <200707160055.04982.mb@bu3sch.de>
References: <469A36D8.6080106@libero.it> <200707160055.04982.mb@bu3sch.de>
Message-ID: <200707160854.46235.hs4233@mail.mn-solutions.de>

> I would be happy, if you'd join the reverse engineering team.
> Currently there's kind of a bottleneck, as our two active
> people are busy with other things.

Is there some page there they describe the used method and 
methodology for the reverse-engeneering?


From johannes at sipsolutions.net  Mon Jul 16 11:38:17 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 16 Jul 2007 11:38:17 +0200
Subject: can I contribute to the project ?
In-Reply-To: <200707160854.46235.hs4233@mail.mn-solutions.de>
References: <469A36D8.6080106@libero.it> <200707160055.04982.mb@bu3sch.de>
	<200707160854.46235.hs4233@mail.mn-solutions.de>
Message-ID: <1184578697.3773.2.camel@johannes.berg>

On Mon, 2007-07-16 at 08:54 +0200, Holger Schurig wrote:
> > I would be happy, if you'd join the reverse engineering team.
> > Currently there's kind of a bottleneck, as our two active
> > people are busy with other things.
> 
> Is there some page there they describe the used method and 
> methodology for the reverse-engeneering?

http://bcm-specs.sipsolutions.net/ReverseEngineeringProcess

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070716/1b881185/attachment.pgp>

From hs4233 at mail.mn-solutions.de  Mon Jul 16 12:10:13 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Mon, 16 Jul 2007 12:10:13 +0200
Subject: can I contribute to the project ?
In-Reply-To: <1184578697.3773.2.camel@johannes.berg>
References: <469A36D8.6080106@libero.it>
	<200707160854.46235.hs4233@mail.mn-solutions.de>
	<1184578697.3773.2.camel@johannes.berg>
Message-ID: <200707161210.13584.hs4233@mail.mn-solutions.de>

> http://bcm-specs.sipsolutions.net/ReverseEngineeringProcess

"creative Mac-On-Linux hack" ... where is the URL?  Obviously 
this is used to create traces of memory accesses. Where are the 
traces, so that other people can have a look at them and run 
them throught their own tools?

That page just says "we carefully analysing disassembled code", 
with what?  IDA Pro, objdump? What tools to you have to add 
annotations, names to functions or jump targets?  Where are the 
perl/python/ruby scripts that you use in correlating memory 
access traces with your disassembly?

Later it says "Translate assembly to C". Which de-compiler are 
you using?

I saw this pages some months ago, but it made me no wiser on how 
to do this reverse-engeneering :-)



Hmm, some weeks ago I saw something about a PCI proxy, that was 
either for QEMU or for Linux itself. With it, one could, at 
kernel/emulator level, log any access to a PCI memory address 
range.


From johannes at sipsolutions.net  Mon Jul 16 12:15:36 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 16 Jul 2007 12:15:36 +0200
Subject: can I contribute to the project ?
In-Reply-To: <200707161210.13584.hs4233@mail.mn-solutions.de>
References: <469A36D8.6080106@libero.it>
	<200707160854.46235.hs4233@mail.mn-solutions.de>
	<1184578697.3773.2.camel@johannes.berg>
	<200707161210.13584.hs4233@mail.mn-solutions.de>
Message-ID: <1184580936.3773.13.camel@johannes.berg>

On Mon, 2007-07-16 at 12:10 +0200, Holger Schurig wrote:

> "creative Mac-On-Linux hack" ... where is the URL?

It's part of the mac on linux sources. enable pci proxy.

> Obviously 
> this is used to create traces of memory accesses. Where are the 
> traces, so that other people can have a look at them and run 
> them throught their own tools?

None available right now, but it's not useful either at this point.

> That page just says "we carefully analysing disassembled code", 
> with what?  IDA Pro, objdump? What tools to you have to add 
> annotations, names to functions or jump targets?  Where are the 
> perl/python/ruby scripts that you use in correlating memory 
> access traces with your disassembly?

IDA pro, but I personally use objdump together with my mips assembly
scripts (on git.sipsolutions.net)

> Later it says "Translate assembly to C". Which de-compiler are 
> you using?

Our heads.

> Hmm, some weeks ago I saw something about a PCI proxy, that was 
> either for QEMU or for Linux itself. With it, one could, at 
> kernel/emulator level, log any access to a PCI memory address 
> range.

Yeah, there's one for qemu but the whole idea is fairly useless with
this chipset.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070716/17c4fb4d/attachment.pgp>

From will.dyson at gmail.com  Mon Jul 16 17:28:18 2007
From: will.dyson at gmail.com (Will Dyson)
Date: Mon, 16 Jul 2007 11:28:18 -0400
Subject: [PATCH] Actually set TX power parameters.
Message-ID: <11845996981719-git-send-email-will.dyson@gmail.com>

When calculating transmission power for boards without hardware power
control, we fail to set the phy parameters to the new values we have
calculated.

Signed-off-by: Will Dyson <will.dyson at gmail.com>

diff --git a/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c b/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
index 24855d6..f246cab 100644
--- a/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
+++ b/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
@@ -2121,6 +2121,9 @@ void bcm43xx_phy_xmitpower(struct bcm43xx_wldev *dev)
 		phy->tx_control = tx_control;
 		bcm43xx_put_attenuation_into_ranges(dev, &bbatt, &rfatt);
 
+		phy->bbatt.att = bbatt;
+		phy->rfatt.att = rfatt;
+
 		bcm43xx_phy_lock(dev, phylock_flags);
 		bcm43xx_radio_lock(dev);
 		bcm43xx_set_txpower_g(dev, &phy->bbatt, &phy->rfatt, phy->tx_control);
-- 
1.5.2.4



From will.dyson at gmail.com  Tue Jul 17 21:06:27 2007
From: will.dyson at gmail.com (Will Dyson)
Date: Tue, 17 Jul 2007 15:06:27 -0400
Subject: [PATCH] Actually set TX power parameters.
In-Reply-To: <11845996981719-git-send-email-will.dyson@gmail.com>
References: <11845996981719-git-send-email-will.dyson@gmail.com>
Message-ID: <8e6f94720707171206n3bf09d15h860fe2c42f5c620a@mail.gmail.com>

On 7/16/07, Will Dyson <will.dyson at gmail.com> wrote:
> When calculating transmission power for boards without hardware power
> control, we fail to set the phy parameters to the new values we have
> calculated.

I've been running my box with this patch for the last 24 hours or so,
on top of Michael's git tree + wireless-dev.

Unfortunately, it does not seem to result in any real improvement to
wireless performance. Using the txpower debugging support from
Michael's tree, I see the measured TX power bouncing all over the
place. The target TX power is 14.25 dBm, but my logs show it wandering
from 4ish dBm all the way up to 17 dBm. It never stays at or above the
target power long enough to complete the WPA handshake.

Even when it does get near the target value, the next recalculation
always seems to send it to one extreme or the other.

On the plus side, when I set the attenuation values manually to

Baseband: 3
RF: 5
tx_control: 0x30

I get a measured power output of 17dBm, which allows me to associate
and stay associated (with performance about as good as the softmac
driver).

Hopefully, some tweaking of the start values and adjustment algorithm
will make this driver usable for the majority of people currently
using softmac.

-- 
Will Dyson


From petero2 at telia.com  Wed Jul 18 02:20:34 2007
From: petero2 at telia.com (Peter Osterlund)
Date: 18 Jul 2007 02:20:34 +0200
Subject: Occational lockups during boot with post 2.6.22 kernels
Message-ID: <m3sl7mk1f1.fsf@telia.com>

Current -git kernels sometimes lock up on my computer during boot. I
guess it happens about 10-20% of the time. I first saw this maybe a
week ago, but never with kernels <= 2.6.22.

The last reported info on the console is that named is started.
SysRq-T still works and reports the non-sleeping tasks below.

My guess is that wpa_supplicant and events/0 deadlock and later the
named thread also hangs when it needs a deadlocked resource.

I'm using the bcm43xx driver.
 
No lockdep errors are reported before the lockup. Earlier during boot
the kernel reports:

  Good, all 218 testcases passed! |

SysRq-T output:

   =======================
  events/0      D 00000001     0     5      2
         dfe0fe64 00000092 935ee27c 00000001 c0345e48 935ee27c 00000001 c0462fc0
         00000001 dcab5040 dcd44de4 dcd44da4 00000246 dfe0cb90 dfe0fea0 c0345df6
         00000000 00000002 c0346026 00000000 dcd44dd0 dcd44dd0 dcd44dd0 dfe0cb90
  Call Trace:
   [<c0345df6>] __mutex_lock_slowpath+0xb2/0x2c6
   [<c0346026>] mutex_lock+0x1c/0x1f
   [<e08b6bab>] ieee80211softmac_assoc_work+0x24/0x51b [ieee80211softmac]
   [<e08b70b5>] ieee80211softmac_assoc_notify_scan+0x13/0x15 [ieee80211softmac]
   [<e08b7653>] ieee80211softmac_notify_callback+0x41/0x7a [ieee80211softmac]
   [<c012a80c>] run_workqueue+0xbb/0x13d
   [<c012b0b1>] worker_thread+0x9a/0xf9
   [<c012d84e>] kthread+0x36/0x58
   [<c0104b87>] kernel_thread_helper+0x7/0x10
 
   =======================
  klogd         R running      0  2771      1
  wpa_supplican D 00000001     0  2806      1
         dc309d7c 00200082 935ecce6 00000001 c0138e84 935ecce6 00000001 00200046
         dc309dbc dcab5040 dc309db8 dc309dbc dc309db8 dcd44fd4 dc309da0 c0344f98
         00000001 dcfdd350 c01186cc dc309de4 dc309de4 dff61740 dcd44fd4 dc309df0
  Call Trace:
   [<c0344f98>] wait_for_completion+0x91/0xc8
   [<c012a98b>] flush_cpu_workqueue+0x47/0x6f
   [<c012ae46>] flush_workqueue+0x1c/0x1f
   [<c012ae56>] flush_scheduled_work+0xd/0xf
   [<e08b699c>] ieee80211softmac_wx_set_essid+0x144/0x188 [ieee80211softmac]
   [<c0343811>] ioctl_standard_call+0x16b/0x350
   [<c0343d51>] wext_handle_ioctl+0x35b/0x3e5
   [<c02e4ea2>] dev_ioctl+0x322/0x33d
   [<c02d8587>] sock_ioctl+0xba/0x1d8
   [<c0171d02>] do_ioctl+0x22/0x71
   [<c0171da6>] vfs_ioctl+0x55/0x28a
   [<c017200e>] sys_ioctl+0x33/0x51
   [<c0103f36>] sysenter_past_esp+0x5f/0x99
 
   =======================
  named         D 00000001     0  2836   2834
         dbdc5e70 00200082 960324f3 00000001 c0345e48 960324f3 00000001 c0462fc0
         00000001 dd0d6300 c0454e20 c0454de0 00200246 c1694fd0 dbdc5eac c0345df6
         00000000 00000002 c0346026 00000000 c0454e0c c0454e0c c0454e0c c1694fd0
  Call Trace:
   [<c0345df6>] __mutex_lock_slowpath+0xb2/0x2c6
   [<c0346026>] mutex_lock+0x1c/0x1f
   [<c02ec08c>] rtnl_lock+0xd/0xf
   [<c02e4c32>] dev_ioctl+0xb2/0x33d
   [<c02d8587>] sock_ioctl+0xba/0x1d8
   [<c0171d02>] do_ioctl+0x22/0x71
   [<c0171da6>] vfs_ioctl+0x55/0x28a
   [<c017200e>] sys_ioctl+0x33/0x51
   [<c0103f36>] sysenter_past_esp+0x5f/0x99

-- 
Peter Osterlund - petero2 at telia.com
http://web.telia.com/~u89404340


From johannes at sipsolutions.net  Wed Jul 18 17:51:10 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 18 Jul 2007 17:51:10 +0200
Subject: Occational lockups during boot with post 2.6.22 kernels
In-Reply-To: <469E2AAB.2010408@redhat.com>
References: <m3sl7mk1f1.fsf@telia.com>  <469E2AAB.2010408@redhat.com>
Message-ID: <1184773870.4002.8.camel@johannes.berg>

On Wed, 2007-07-18 at 10:58 -0400, Chuck Ebbert wrote:
> On 07/17/2007 08:20 PM, Peter Osterlund wrote:
> > Current -git kernels sometimes lock up on my computer during boot. I
> > guess it happens about 10-20% of the time. I first saw this maybe a
> > week ago, but never with kernels <= 2.6.22.
> > 
> > The last reported info on the console is that named is started.
> > SysRq-T still works and reports the non-sleeping tasks below.
> > 
> > My guess is that wpa_supplicant and events/0 deadlock and later the
> > named thread also hangs when it needs a deadlocked resource.
> > 
> > I'm using the bcm43xx driver.
> >  
> > No lockdep errors are reported before the lockup. Earlier during boot
> > the kernel reports:
> > 
> >   Good, all 218 testcases passed! |
> 
> Try this, it should at least detect the problem:
> 
> http://lkml.org/lkml/2007/7/17/202
> http://lkml.org/lkml/2007/7/17/204
> http://lkml.org/lkml/2007/7/17/203
> 
> It's a known bug in wireless/80211, not sure when it will be fixed.

Heh, yes, that's the patchset that came from this bug :)
A patch for this is available but due to process issues hasn't
percolated up yet. See
http://thread.gmane.org/gmane.linux.kernel.wireless.general/3315/focus=3319

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070718/78cfc6be/attachment.pgp>

From johannes at sipsolutions.net  Wed Jul 18 17:51:10 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 18 Jul 2007 17:51:10 +0200
Subject: Occational lockups during boot with post 2.6.22 kernels
In-Reply-To: <469E2AAB.2010408@redhat.com>
References: <m3sl7mk1f1.fsf@telia.com>  <469E2AAB.2010408@redhat.com>
Message-ID: <1184773870.4002.8.camel@johannes.berg>

On Wed, 2007-07-18 at 10:58 -0400, Chuck Ebbert wrote:
> On 07/17/2007 08:20 PM, Peter Osterlund wrote:
> > Current -git kernels sometimes lock up on my computer during boot. I
> > guess it happens about 10-20% of the time. I first saw this maybe a
> > week ago, but never with kernels <= 2.6.22.
> > 
> > The last reported info on the console is that named is started.
> > SysRq-T still works and reports the non-sleeping tasks below.
> > 
> > My guess is that wpa_supplicant and events/0 deadlock and later the
> > named thread also hangs when it needs a deadlocked resource.
> > 
> > I'm using the bcm43xx driver.
> >  
> > No lockdep errors are reported before the lockup. Earlier during boot
> > the kernel reports:
> > 
> >   Good, all 218 testcases passed! |
> 
> Try this, it should at least detect the problem:
> 
> http://lkml.org/lkml/2007/7/17/202
> http://lkml.org/lkml/2007/7/17/204
> http://lkml.org/lkml/2007/7/17/203
> 
> It's a known bug in wireless/80211, not sure when it will be fixed.

Heh, yes, that's the patchset that came from this bug :)
A patch for this is available but due to process issues hasn't
percolated up yet. See
http://thread.gmane.org/gmane.linux.kernel.wireless.general/3315/focus=3319

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070718/78cfc6be/attachment-0001.pgp>

From johannes at sipsolutions.net  Fri Jul 20 00:26:34 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 20 Jul 2007 00:26:34 +0200
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <20070719215801.GB12449@tuxdriver.com>
References: <46963C0F.3080104@lwfinger.net>
	<20070719215801.GB12449@tuxdriver.com>
Message-ID: <1184883994.17966.14.camel@johannes.berg>

On Thu, 2007-07-19 at 17:58 -0400, John W. Linville wrote:

> Regarding hardware support, I have begun to lean towards having
> the v3 driver continue to support all the hardware it does now.

I agree, until we can sort out the issues with that.

> What exactly do we gain from using the v4 firmware?

We get crypto hardware working, for example, and other things I might
not remember :)

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070720/854b2a27/attachment.pgp>

From linville at tuxdriver.com  Thu Jul 19 23:58:01 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 19 Jul 2007 17:58:01 -0400
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <46963C0F.3080104@lwfinger.net>
References: <46963C0F.3080104@lwfinger.net>
Message-ID: <20070719215801.GB12449@tuxdriver.com>

On Thu, Jul 12, 2007 at 09:34:55AM -0500, Larry Finger wrote:

> My plan is to clean up the code, check it with my BCM4306 and BCM4318 
> devices, and then make it available as a patch against the mainline source 
> for more general testing. At the same time, I will publish the results of 
> my performance testing of all 3 models. Once it is shown to be reliable, a 
> decision can be made regarding its inclusion in mainline and if it should 
> support B and G devices, or be restricted to B-only devices. The A-PHY code 
> has been stripped out.

This sounds great.  Perhaps this can be the migration vehicle for
current bcm43xx users to come to mac80211?  Especially for those with
hardware not supported by the current bcm43xx-mac80211 driver.

Are you proposing to add a third driver and deprecate the softmac
driver?  Or can we treat this as a port of the existing driver
to mac80211?  I think that might be better for users and distros,
and might let us get rid of the softmac component that much sooner.

As for the name, if we treat this as a port of the current driver to
mac80211 then perhaps we should just continue using the "bcm43xx" name?
If so, we need a new name for the v4-based driver -- "bcm43xxtoo"? :-)

Regarding hardware support, I have begun to lean towards having
the v3 driver continue to support all the hardware it does now.
I'm certainly prepared to hear the downside of that position. :-)
What exactly do we gain from using the v4 firmware?

Anyway, I'm glad to hear we are making progress on this front.
Good job, Larry!

John
-- 
John W. Linville
linville at tuxdriver.com


From stefano.brivio at polimi.it  Fri Jul 20 01:27:14 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Fri, 20 Jul 2007 01:27:14 +0200
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <20070719215801.GB12449@tuxdriver.com>
References: <46963C0F.3080104@lwfinger.net>
	<20070719215801.GB12449@tuxdriver.com>
Message-ID: <20070720012714.0dc0298a@morte>

On Thu, 19 Jul 2007 17:58:01 -0400
"John W. Linville" <linville at tuxdriver.com> wrote:

> Are you proposing to add a third driver and deprecate the softmac
> driver?  Or can we treat this as a port of the existing driver
> to mac80211?  I think that might be better for users and distros,
> and might let us get rid of the softmac component that much sooner.

I agree. Let's treat this as a port, as soon as it's stable. By the way, I
hope I'll be able to contribute again starting on July, 25.
 
> As for the name, if we treat this as a port of the current driver to
> mac80211 then perhaps we should just continue using the "bcm43xx" name?
> If so, we need a new name for the v4-based driver -- "bcm43xxtoo"? :-)

Should the ported driver support 802.11g devices as well, it should be
called bcm43xx, IMHO. Else, IIRC, we already discussed that and it should
be called bcm4301. bcm43xx-mac80211 could be renamed to "bcm43xx-v4", it
would be more meaningful than "bcm43xtoo", maybe.

> Regarding hardware support, I have begun to lean towards having
> the v3 driver continue to support all the hardware it does now.

I agree. But I would wait a little more time, I mean, when the ported driver
is stable, then let's consider the status of "bcm43xx-v4". Michael is
actually making some progress, even if - sadly - he's alone right now. 

The final plan should be something like this:
1) bcm43xx gets stable and merged;
2) bcm43xx-mac80211 is renamed to bcm43xx-v4 and doesn't get merged;
3) when bcm43xx-v4 gets stable, the PCI IDs list of bcm43xx gets stripped
down and it is renamed to bcm4301, while bcm43xx-v4 is renamed to bcm43xx.

This could lead to some troubles. The other possible plan:
1) bcm43xx-mac80211 gets stable and merged, while bcm43xx is renamed to
bcm4301 and its PCI IDs list stripped down;
would sound a lot simpler. Even if the first plan could be better for users
and distributions. So I'd say, let's have a stable driver at least, before
to take a decision.

> What exactly do we gain from using the v4 firmware?

Other than crypto hardware, support for 802.11n devices, and maybe 802.11a
devices too (I started working on that but I'm not doing that right now).

> Anyway, I'm glad to hear we are making progress on this front.
> Good job, Larry!

Me too! Good job!


-- 
Ciao
Stefano


From larry.finger at lwfinger.net  Fri Jul 20 03:38:17 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 19 Jul 2007 20:38:17 -0500
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <20070720012714.0dc0298a@morte>
References: <46963C0F.3080104@lwfinger.net>	<20070719215801.GB12449@tuxdriver.com>
	<20070720012714.0dc0298a@morte>
Message-ID: <46A01209.4030200@lwfinger.net>

Stefano Brivio wrote:
> On Thu, 19 Jul 2007 17:58:01 -0400
> "John W. Linville" <linville at tuxdriver.com> wrote:
> 
>> Are you proposing to add a third driver and deprecate the softmac
>> driver?  Or can we treat this as a port of the existing driver
>> to mac80211?  I think that might be better for users and distros,
>> and might let us get rid of the softmac component that much sooner.
> 
> I agree. Let's treat this as a port, as soon as it's stable. By the way, I
> hope I'll be able to contribute again starting on July, 25.

For the initial tests, it will be a third driver called bcm4301; however, it is a port and should be 
presented as such.

>> As for the name, if we treat this as a port of the current driver to
>> mac80211 then perhaps we should just continue using the "bcm43xx" name?
>> If so, we need a new name for the v4-based driver -- "bcm43xxtoo"? :-)
> 
> Should the ported driver support 802.11g devices as well, it should be
> called bcm43xx, IMHO. Else, IIRC, we already discussed that and it should
> be called bcm4301. bcm43xx-mac80211 could be renamed to "bcm43xx-v4", it
> would be more meaningful than "bcm43xtoo", maybe.
> 
>> Regarding hardware support, I have begun to lean towards having
>> the v3 driver continue to support all the hardware it does now.
> 
> I agree. But I would wait a little more time, I mean, when the ported driver
> is stable, then let's consider the status of "bcm43xx-v4". Michael is
> actually making some progress, even if - sadly - he's alone right now.

I wish I could be of more help, but I've gotten all that I can from the specs.

> The final plan should be something like this:
> 1) bcm43xx gets stable and merged;
> 2) bcm43xx-mac80211 is renamed to bcm43xx-v4 and doesn't get merged;
> 3) when bcm43xx-v4 gets stable, the PCI IDs list of bcm43xx gets stripped
> down and it is renamed to bcm4301, while bcm43xx-v4 is renamed to bcm43xx.
> 
> This could lead to some troubles. The other possible plan:
> 1) bcm43xx-mac80211 gets stable and merged, while bcm43xx is renamed to
> bcm4301 and its PCI IDs list stripped down;
> would sound a lot simpler. Even if the first plan could be better for users
> and distributions. So I'd say, let's have a stable driver at least, before
> to take a decision.
> 
>> What exactly do we gain from using the v4 firmware?
> 
> Other than crypto hardware, support for 802.11n devices, and maybe 802.11a
> devices too (I started working on that but I'm not doing that right now).
> 
>> Anyway, I'm glad to hear we are making progress on this front.
>> Good job, Larry!
> 
> Me too! Good job!

Thanks guys for your comments and compliments.

My preferred plan is as follows:

1. For more general testing, I'll distribute my driver as a patch to be applied to wireless-dev as 
it needs ssb, which is not yet in mainline. If we are still in testing when ssb is merged, I'll 
change to making patches against mainline.

2. Once the problems have been cleared and ssb is in -mm, it gets sent there as a port from softmac 
to mac80211 for the current bcm43xx. An additional consideration is that a port from softmac to 
mac80211 will be more easily merged than if it looks like a new driver.

3. If the port of softmac to mac80211 is merged before Michael's driver, it will be known as bcm43xx 
with bcm43xx-mac80211 remaining in wireless-dev.

4. Once bcm43xx-mac80211 gets merged to mainline, then Michael's driver should become bcm43xx and my 
driver gets its PCI IDs stripped to the 802.11b-only devices and once again becomes bcm4301. This 
name change for Michael's driver would cause some disruption for current users as their firmware 
would have the wrong name/version. That might be too much of a problem.

I think this is a path that always has a stable driver with at least moderate performance in 
mainline throughout the entire transformation. When either driver gets merged, that will be one more 
nail in softmac's coffin!

Larry


From stefano.brivio at polimi.it  Fri Jul 20 05:09:32 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Fri, 20 Jul 2007 05:09:32 +0200
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <46A01209.4030200@lwfinger.net>
References: <46963C0F.3080104@lwfinger.net>
	<20070719215801.GB12449@tuxdriver.com>
	<20070720012714.0dc0298a@morte> <46A01209.4030200@lwfinger.net>
Message-ID: <20070720050932.5052468c@morte>

On Thu, 19 Jul 2007 20:38:17 -0500
Larry Finger <larry.finger at lwfinger.net> wrote:

> 4. Once bcm43xx-mac80211 gets merged to mainline, then Michael's driver
> should become bcm43xx and my driver gets its PCI IDs stripped to the
> 802.11b-only devices and once again becomes bcm4301. This name change for
> Michael's driver would cause some disruption for current users as their
> firmware would have the wrong name/version. That might be too much of a
> problem.

No, as long as we preserve the current firmware naming scheme. Some
distributions are already shipping both the softmac and the mac80211 based
drivers, with fwcutter installation scripts meant for dealing with this.
Some clear printk's in both drivers should do the rest.


-- 
Ciao
Stefano


From proski at gnu.org  Fri Jul 20 06:43:16 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 20 Jul 2007 00:43:16 -0400
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <46A01209.4030200@lwfinger.net>
References: <46963C0F.3080104@lwfinger.net>
	<20070719215801.GB12449@tuxdriver.com> <20070720012714.0dc0298a@morte>
	<46A01209.4030200@lwfinger.net>
Message-ID: <1184906596.9511.42.camel@dv>

Hello, Larry!

First of all, many thanks for porting the v3 driver to mac80211!

On Thu, 2007-07-19 at 20:38 -0500, Larry Finger wrote:

> 1. For more general testing, I'll distribute my driver as a patch to
> be applied to wireless-dev as 
> it needs ssb, which is not yet in mainline. If we are still in testing when ssb is merged, I'll 
> change to making patches against mainline.

Sounds good.

> 2. Once the problems have been cleared and ssb is in -mm, it gets sent there as a port from softmac 
> to mac80211 for the current bcm43xx. An additional consideration is that a port from softmac to 
> mac80211 will be more easily merged than if it looks like a new driver.

I would prefer if the name stayed the same, but it shouldn't be a big
deal.

> 3. If the port of softmac to mac80211 is merged before Michael's driver, it will be known as bcm43xx 
> with bcm43xx-mac80211 remaining in wireless-dev.

Yes, that's what I mean, keep it "bcm43xx" unless renaming it is the
condition for acceptance.

> 4. Once bcm43xx-mac80211 gets merged to mainline, then Michael's driver should become bcm43xx and my 
> driver gets its PCI IDs stripped to the 802.11b-only devices and once again becomes bcm4301. This 
> name change for Michael's driver would cause some disruption for current users as their firmware 
> would have the wrong name/version. That might be too much of a problem.

Actually, the common practice is that the new driver that doesn't
supplant the old driver immediately and for the whole range of hardware
gets a new name.  Think CONFIG_IDE vs CONFIG_ATA and eepro100 vs e100.

Also, we could introduce a kernel option to enable support for new
devices in your driver.

> I think this is a path that always has a stable driver with at least moderate performance in 
> mainline throughout the entire transformation.

That's a very good goal.

I would also consider the option to use different names for v3 and v4
firmware.  I have a file /etc/modprobe.d/bcm43xx that reads

options bcm43xx fwpostfix=.3
options bcm43xx_mac80211 fwpostfix=.4

but we cannot expect every distro (let alone every user) to take care of
the naming conflict.  Users don't expect the need to rename firmware,
and we shouldn't create a problem for them.

-- 
Regards,
Pavel Roskin



From zajec5polish at gmail.com  Fri Jul 20 08:35:45 2007
From: zajec5polish at gmail.com (=?UTF-8?Q?Rafa=C5=82_Mi=C5=82ecki?=)
Date: Fri, 20 Jul 2007 08:35:45 +0200
Subject: [2.6.22.1] ASSERTION FAILED ; Writing invalid LOpair
Message-ID: <14b026160707192335oebd1cdcw7458b852ecf615fc@mail.gmail.com>

zajec at acer:~> uname -r
2.6.22.1-45-default

Before my bcm4318 connects, I get a few "ASSERTION FAILES" errors. I
attach my /var/log/messages

-- 
Rafa? Mi?ecki
-------------- next part --------------
A non-text attachment was scrubbed...
Name: zajec.writing.invalid.lopair.log
Type: application/octet-stream
Size: 28663 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070720/96f9b00e/attachment.obj>

From hs4233 at mail.mn-solutions.de  Fri Jul 20 13:30:59 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Fri, 20 Jul 2007 13:30:59 +0200
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <46A01209.4030200@lwfinger.net>
References: <46963C0F.3080104@lwfinger.net> <20070720012714.0dc0298a@morte>
	<46A01209.4030200@lwfinger.net>
Message-ID: <200707201330.59293.hs4233@mail.mn-solutions.de>

> 3. If the port of softmac to mac80211 is merged before
> Michael's driver, it will be known as bcm43xx with
> bcm43xx-mac80211 remaining in wireless-dev.

Renaming a driver always creates madness. For example, even now 
people and projects (e.g. Kismet) refer to "madwifi-ng", but 
there is no madwifi-ng anymore, because this beast has been 
renamed to madwifi.

If possible, use names that can stay. Peoples grey cells, 
projects, and webpages don't then suffer from bitrott.

>
> 4. Once bcm43xx-mac80211 gets merged to mainline, then
> Michael's driver should become bcm43xx and my driver gets its
> PCI IDs stripped to the 802.11b-only devices and once again
> becomes bcm4301. This name change for Michael's driver would
> cause some disruption for current users as their firmware
> would have the wrong name/version. That might be too much of a
> problem.

A gread, even more renames :-(


From dwmw2 at infradead.org  Fri Jul 20 14:12:04 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 20 Jul 2007 13:12:04 +0100
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <1184906596.9511.42.camel@dv>
References: <46963C0F.3080104@lwfinger.net>
	<20070719215801.GB12449@tuxdriver.com> <20070720012714.0dc0298a@morte>
	<46A01209.4030200@lwfinger.net>  <1184906596.9511.42.camel@dv>
Message-ID: <1184933524.14697.119.camel@pmac.infradead.org>

On Fri, 2007-07-20 at 00:43 -0400, Pavel Roskin wrote:
> 
> That's a very good goal.
> 
> I would also consider the option to use different names for v3 and v4
> firmware.  I have a file /etc/modprobe.d/bcm43xx that reads
> 
> options bcm43xx fwpostfix=.3
> options bcm43xx_mac80211 fwpostfix=.4
> 
> but we cannot expect every distro (let alone every user) to take care
> of the naming conflict.  Users don't expect the need to rename
> firmware, and we shouldn't create a problem for them.

Yes. Please use a suitable postfix for v3 and v4 firmware so that they
can coexist. You can always make each driver fall back to the old
filename if it doesn't find the firmware with the postfix.

We can make the fwcutter write out files with appropriate names too.

-- 
dwmw2



From linville at tuxdriver.com  Fri Jul 20 15:44:25 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Fri, 20 Jul 2007 09:44:25 -0400
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <1184906596.9511.42.camel@dv>
References: <46963C0F.3080104@lwfinger.net>
	<20070719215801.GB12449@tuxdriver.com>
	<20070720012714.0dc0298a@morte> <46A01209.4030200@lwfinger.net>
	<1184906596.9511.42.camel@dv>
Message-ID: <20070720134425.GC7428@tuxdriver.com>

On Fri, Jul 20, 2007 at 12:43:16AM -0400, Pavel Roskin wrote:
> On Thu, 2007-07-19 at 20:38 -0500, Larry Finger wrote:

> > 4. Once bcm43xx-mac80211 gets merged to mainline, then Michael's driver should become bcm43xx and my 
> > driver gets its PCI IDs stripped to the 802.11b-only devices and once again becomes bcm4301. This 
> > name change for Michael's driver would cause some disruption for current users as their firmware 
> > would have the wrong name/version. That might be too much of a problem.
> 
> Actually, the common practice is that the new driver that doesn't
> supplant the old driver immediately and for the whole range of hardware
> gets a new name.  Think CONFIG_IDE vs CONFIG_ATA and eepro100 vs e100.
 
Yes, this preserves stability for happy bcm43xx users.  Still taking
suggestions for the new name for bcm43xx-mac80211... :-)

> Also, we could introduce a kernel option to enable support for new
> devices in your driver.
 
Yes, this is probably worthwhile for those wishing to avoid PCI ID
conflicts between the drivers.  I have also been speculating that
perhaps we need an option for a secondary PCI ID table, so that a
driver could support a large range of PCI IDs but then gracefully
bow-out if another driver had a certain ID in its primary table.
Does that make any sense?  It would seem to be applicable to a number
of drivers in the kernel.

> I would also consider the option to use different names for v3 and v4
> firmware.  I have a file /etc/modprobe.d/bcm43xx that reads
> 
> options bcm43xx fwpostfix=.3
> options bcm43xx_mac80211 fwpostfix=.4
> 
> but we cannot expect every distro (let alone every user) to take care of
> the naming conflict.  Users don't expect the need to rename firmware,
> and we shouldn't create a problem for them.

Yes, we should probably start using a default value for fwpostfix.
As dwmw2 suggested, it would also be nice to fall back to an empty
fwpostfix if the firmware is not found w/ the default extension.

John
-- 
John W. Linville
linville at tuxdriver.com


From proski at gnu.org  Fri Jul 20 18:05:21 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 20 Jul 2007 12:05:21 -0400
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <20070720134425.GC7428@tuxdriver.com>
References: <46963C0F.3080104@lwfinger.net>
	<20070719215801.GB12449@tuxdriver.com> <20070720012714.0dc0298a@morte>
	<46A01209.4030200@lwfinger.net> <1184906596.9511.42.camel@dv>
	<20070720134425.GC7428@tuxdriver.com>
Message-ID: <1184947521.1962.15.camel@dv>

On Fri, 2007-07-20 at 09:44 -0400, John W. Linville wrote:
> On Fri, Jul 20, 2007 at 12:43:16AM -0400, Pavel Roskin wrote:
> > Actually, the common practice is that the new driver that doesn't
> > supplant the old driver immediately and for the whole range of hardware
> > gets a new name.  Think CONFIG_IDE vs CONFIG_ATA and eepro100 vs e100.
>  
> Yes, this preserves stability for happy bcm43xx users.  Still taking
> suggestions for the new name for bcm43xx-mac80211... :-)

b43
bcm43
bcm4k3
bcmwifi
bcmwlan
bcm80211
brcm43xx
broadcom

I really like the minimalism of b43, which plays well with b44 and
p54 :)

> > Also, we could introduce a kernel option to enable support for new
> > devices in your driver.
>  
> Yes, this is probably worthwhile for those wishing to avoid PCI ID
> conflicts between the drivers.  I have also been speculating that
> perhaps we need an option for a secondary PCI ID table, so that a
> driver could support a large range of PCI IDs but then gracefully
> bow-out if another driver had a certain ID in its primary table.
> Does that make any sense?  It would seem to be applicable to a number
> of drivers in the kernel.

Yes, I used to hearing complains that orinoco steals IDs from hostap.
Then it became popular to blacklist orinoco modules.  Quite a disgrace
for the driver!  Having "weak" IDs for Prism based cards would have
avoided it.

But please realize that the problem goes far beyond PCI.  Perhaps you
have heard of CONFIG_USB_LIBUSUAL, which selects the best driver for USB
storage devices, either the slow but reliable ub, or the SCSI based
usb-storage, which it too fast for some cheap sticks.

It even has a parameter called "bias", which allows to control how
conservative the algorithm should be.  That would be hard to emulate
with "weak entries", but I hope that "bias" is an overkill.

> Yes, we should probably start using a default value for fwpostfix.
> As dwmw2 suggested, it would also be nice to fall back to an empty
> fwpostfix if the firmware is not found w/ the default extension.

Yes, that sounds good.

-- 
Regards,
Pavel Roskin



From gavron at Wetwork.Net  Fri Jul 20 18:33:54 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 20 Jul 2007 09:33:54 -0700
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <1184947521.1962.15.camel@dv>
References: <46963C0F.3080104@lwfinger.net>
	<20070719215801.GB12449@tuxdriver.com> <20070720012714.0dc0298a@morte>
	<46A01209.4030200@lwfinger.net> <1184906596.9511.42.camel@dv>
	<20070720134425.GC7428@tuxdriver.com> <1184947521.1962.15.camel@dv>
Message-ID: <46A0E3F2.5080209@Wetwork.Net>

Not a developer, just a tester, and not a very good one... but I am a 
_USER_ so here's my take.

The USERs don't want to know what card they have or what driver they 
need or PCI IDs.  That's all stuff that makes them say "Linux Bad, 
*****s good." (Yeah I know, there's the whole driver moreass there and 
PCI VENs too) but anyway...

The driver should have a name that reflects its use and capabilities.

For example, bcm43xx is a reasonable name.  I don't like it personally 
because the google links to the site (berlios.de) that tell me that's 
why I need took a while to find but that's just semantics.

bcm43xx_mac80211 is a less reasonable name.  With respect to the coders 
who have put time into making this usable on by 4306 and almost usable 
on my 4311 I can say that I appreciate the effort... but the name needs 
work.

If I was king of driver package naming, the driver that works with v3 
and v4 firmware and supports crypto functions would be... 
broadcom80211bg or bcm80211g
The driver that only works with v3 (aka bcm43xx) broadcomv3
The driver that only works with v4 (aka bcm43xx_mac80211) broadcomv4

As time advances and bcb43xx_mac80211/broadcomv4 is brought to spec so 
it works great... its code would be integrated into 
broadcom80211g/bcm80211g.

That's my thinking.  As a USER.  As a linux advocate and zealot.

I can tell you there are three things that are the #1 hindrance to 
massive Linux adoption
1. proprietary video cards
2. proprietary network cards
3. the various sundry and astonishingly in-the-way and annoying 
network-managers.

If you can solve #2... you've eliminated 33% of the problem and maybe 
even helped with #3.

Go Lewis Hamilton @ Nurbugring
Go Paul Tracy @ Edmonton

Ehud

Pavel Roskin wrote:
> On Fri, 2007-07-20 at 09:44 -0400, John W. Linville wrote:
>   
>> On Fri, Jul 20, 2007 at 12:43:16AM -0400, Pavel Roskin wrote:
>>     
>>> Actually, the common practice is that the new driver that doesn't
>>> supplant the old driver immediately and for the whole range of hardware
>>> gets a new name.  Think CONFIG_IDE vs CONFIG_ATA and eepro100 vs e100.
>>>       
>>  
>> Yes, this preserves stability for happy bcm43xx users.  Still taking
>> suggestions for the new name for bcm43xx-mac80211... :-)
>>     
>
> b43
> bcm43
> bcm4k3
> bcmwifi
> bcmwlan
> bcm80211
> brcm43xx
> broadcom
>
> I really like the minimalism of b43, which plays well with b44 and
> p54 :)
>
>   
>>> Also, we could introduce a kernel option to enable support for new
>>> devices in your driver.
>>>       
>>  
>> Yes, this is probably worthwhile for those wishing to avoid PCI ID
>> conflicts between the drivers.  I have also been speculating that
>> perhaps we need an option for a secondary PCI ID table, so that a
>> driver could support a large range of PCI IDs but then gracefully
>> bow-out if another driver had a certain ID in its primary table.
>> Does that make any sense?  It would seem to be applicable to a number
>> of drivers in the kernel.
>>     
>
> Yes, I used to hearing complains that orinoco steals IDs from hostap.
> Then it became popular to blacklist orinoco modules.  Quite a disgrace
> for the driver!  Having "weak" IDs for Prism based cards would have
> avoided it.
>
> But please realize that the problem goes far beyond PCI.  Perhaps you
> have heard of CONFIG_USB_LIBUSUAL, which selects the best driver for USB
> storage devices, either the slow but reliable ub, or the SCSI based
> usb-storage, which it too fast for some cheap sticks.
>
> It even has a parameter called "bias", which allows to control how
> conservative the algorithm should be.  That would be hard to emulate
> with "weak entries", but I hope that "bias" is an overkill.
>
>   
>> Yes, we should probably start using a default value for fwpostfix.
>> As dwmw2 suggested, it would also be nice to fall back to an empty
>> fwpostfix if the firmware is not found w/ the default extension.
>>     
>
> Yes, that sounds good.
>
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070720/4f6315f5/attachment.bin>

From proski at gnu.org  Fri Jul 20 19:57:48 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 20 Jul 2007 13:57:48 -0400
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <46A0E3F2.5080209@Wetwork.Net>
References: <46963C0F.3080104@lwfinger.net>
	<20070719215801.GB12449@tuxdriver.com> <20070720012714.0dc0298a@morte>
	<46A01209.4030200@lwfinger.net> <1184906596.9511.42.camel@dv>
	<20070720134425.GC7428@tuxdriver.com> <1184947521.1962.15.camel@dv>
	<46A0E3F2.5080209@Wetwork.Net>
Message-ID: <1184954268.1962.43.camel@dv>

Hello, Ehud!

On Fri, 2007-07-20 at 09:33 -0700, Ehud Gavron wrote:

> The USERs don't want to know what card they have or what driver they 
> need or PCI IDs.  That's all stuff that makes them say "Linux Bad, 
> *****s good." (Yeah I know, there's the whole driver moreass there and 
> PCI VENs too) but anyway...

Agreed.

> The driver should have a name that reflects its use and capabilities.

Not necessarily.  End users should be shielded from such details by
distributions.  Do you know the name of the Windows driver for your
network card?  Does it reflect "its use and capabilities"?

Now, if we are talking about power users, who can occasionally recompile
the kernel or install a program not from the distribution, they would be
helped by reasonable names of the drivers.

Also, distribution maintainers would feel better if the drivers are not
renamed, so that /etc/modprobe.d/ doesn't need to be scanned for the old
names on kernel upgrade.

> For example, bcm43xx is a reasonable name.  I don't like it personally 
> because the google links to the site (berlios.de) that tell me that's 
> why I need took a while to find but that's just semantics.

That's not a problem with the name.  If the first hit on Google was some
vomit inducing picture, then maybe.

> bcm43xx_mac80211 is a less reasonable name.  With respect to the coders 
> who have put time into making this usable on by 4306 and almost usable 
> on my 4311 I can say that I appreciate the effort... but the name needs 
> work.
> 
> If I was king of driver package naming, the driver that works with v3 
> and v4 firmware and supports crypto functions would be... 
> broadcom80211bg or bcm80211g
> The driver that only works with v3 (aka bcm43xx) broadcomv3
> The driver that only works with v4 (aka bcm43xx_mac80211) broadcomv4

You take just one aspect (firmware version) and put it into the name.
The original name was also taking just one aspect (802.11 stack).  I
fail to see why your approach it better.  I don't know any other Linux
(or _any_) driver that puts the firmware version into its name.

I believe you are implying that the firmware selection will be a
problem, so you prefer a name that would make it easy to solve that
problem.  But then you are not writing as a user, you are writing as
somebody who has been exposed to some internals.  Ask a random user if
the firmware version should be part of the driver name, and you'll get a
blank stare.

By the way, more information could be put into the module description,
which is shown by modinfo.

> As time advances and bcb43xx_mac80211/broadcomv4 is brought to spec so 
> it works great... its code would be integrated into 
> broadcom80211g/bcm80211g.

Now you put the name of the protocol into the driver, which is again
inconsistent with the existing naming and doesn't scale.  Suppose
802.11a support is fixed, would we need to rename the driver again?  And
that if the driver supports only 802.11b on some card?  Would not the
"80211g" part be misleading?

> That's my thinking.  As a USER.  As a linux advocate and zealot.

See above.  Users should not care about driver names.  If they do, we
have a bigger problem.

-- 
Regards,
Pavel Roskin



From linville at tuxdriver.com  Fri Jul 20 20:05:58 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Fri, 20 Jul 2007 14:05:58 -0400
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <1184954268.1962.43.camel@dv>
References: <46963C0F.3080104@lwfinger.net>
	<20070719215801.GB12449@tuxdriver.com>
	<20070720012714.0dc0298a@morte> <46A01209.4030200@lwfinger.net>
	<1184906596.9511.42.camel@dv> <20070720134425.GC7428@tuxdriver.com>
	<1184947521.1962.15.camel@dv> <46A0E3F2.5080209@Wetwork.Net>
	<1184954268.1962.43.camel@dv>
Message-ID: <20070720180558.GG7428@tuxdriver.com>

On Fri, Jul 20, 2007 at 01:57:48PM -0400, Pavel Roskin wrote:

> On Fri, 2007-07-20 at 09:33 -0700, Ehud Gavron wrote:

> > The driver should have a name that reflects its use and capabilities.
> 
> Not necessarily.  End users should be shielded from such details by
> distributions.  Do you know the name of the Windows driver for your
> network card?  Does it reflect "its use and capabilities"?
> 
> Now, if we are talking about power users, who can occasionally recompile
> the kernel or install a program not from the distribution, they would be
> helped by reasonable names of the drivers.
> 
> Also, distribution maintainers would feel better if the drivers are not
> renamed, so that /etc/modprobe.d/ doesn't need to be scanned for the old
> names on kernel upgrade.

ACK...fwiw, I like the "b43" name suggestion.  I wonder if that is
too prone to confusion w/ "b44"?  Probably no worse than "ixgb" vs
"cxgb3" or "e100" vs "e1000" I suppose.

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Fri Jul 20 22:41:24 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 20 Jul 2007 15:41:24 -0500
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <20070720180558.GG7428@tuxdriver.com>
References: <46963C0F.3080104@lwfinger.net>
	<20070719215801.GB12449@tuxdriver.com>
	<20070720012714.0dc0298a@morte> <46A01209.4030200@lwfinger.net>
	<1184906596.9511.42.camel@dv> <20070720134425.GC7428@tuxdriver.com>
	<1184947521.1962.15.camel@dv> <46A0E3F2.5080209@Wetwork.Net>
	<1184954268.1962.43.camel@dv> <20070720180558.GG7428@tuxdriver.com>
Message-ID: <46A11DF4.5090307@lwfinger.net>

John W. Linville wrote:
> 
> ACK...fwiw, I like the "b43" name suggestion.  I wonder if that is
> too prone to confusion w/ "b44"?  Probably no worse than "ixgb" vs
> "cxgb3" or "e100" vs "e1000" I suppose.

Today's discussion was very useful for me - I picked up two suggestions that I have or will be 
putting into the code.

1. The drivers that use V3 firmware will get a default fwpostfix value of ".fw3". If the resulting 
name fails, it will fallback to a blank value for fwpostfix. Of course, if a value is supplied, it 
will override the default.

2. Any b-only driver will contain an alternate PCI ID table that can be selected by using the 
appropriate module option (not yet named). If that option is selected, the driver will load a 
combined b/g table of ID's. This way, it will be easy to supply a work-around for any user that 
cannot get the default 802.11g driver to work. In addition, this fix will not require mucking with 
rc.local.

Larry



From mb at bu3sch.de  Sat Jul 21 14:50:09 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 21 Jul 2007 14:50:09 +0200
Subject: bcm4301: A mac80211 driver using V3 firmware
In-Reply-To: <46A11DF4.5090307@lwfinger.net>
References: <46963C0F.3080104@lwfinger.net>
	<20070720180558.GG7428@tuxdriver.com>
	<46A11DF4.5090307@lwfinger.net>
Message-ID: <200707211450.10270.mb@bu3sch.de>

On Friday 20 July 2007 22:41, Larry Finger wrote:
> John W. Linville wrote:
> > 
> > ACK...fwiw, I like the "b43" name suggestion.  I wonder if that is
> > too prone to confusion w/ "b44"?  Probably no worse than "ixgb" vs
> > "cxgb3" or "e100" vs "e1000" I suppose.
> 
> Today's discussion was very useful for me - I picked up two suggestions that I have or will be 
> putting into the code.
> 
> 1. The drivers that use V3 firmware will get a default fwpostfix value of ".fw3". If the resulting 
> name fails, it will fallback to a blank value for fwpostfix. Of course, if a value is supplied, it 
> will override the default.
> 
> 2. Any b-only driver will contain an alternate PCI ID table that can be selected by using the 
> appropriate module option (not yet named). If that option is selected, the driver will load a 
> combined b/g table of ID's. This way, it will be easy to supply a work-around for any user that 
> cannot get the default 802.11g driver to work. In addition, this fix will not require mucking with 
> rc.local.

No, don't go the way to make the PCI table selectable by a Kconfig
or even worse a dynamic module option.
That is _really_ confusing and I really hope everyone upstream
rejects such patches.
Either a driver does support some hardware, or it doesn't. There
is no step inbetween.
If bcm43xx-mac80211 for G is not ready for merge, yet, don't strip
the IDs from bcm43xx. If bcm43xx-mac80211 for G is ready for production,
remove them.


From geekypenguin at gmail.com  Mon Jul 23 16:20:10 2007
From: geekypenguin at gmail.com (Jory A. Pratt)
Date: Mon, 23 Jul 2007 09:20:10 -0500
Subject: current mac80211 mb tree broken
Message-ID: <46A4B91A.5050606@gmail.com>

drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c: In function 
'bcm43xx_write_probe_resp_plcp':
drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:1152: error: too 
few arguments to function 'ieee80211_generic_frame_duration'
drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c: In function 
'bcm43xx_generate_probe_resp':
drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:1213: error: too 
few arguments to function 'ieee80211_generic_frame_duration'
make[5]: *** [drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.o] Error 1

-Jory


From gavron at Wetwork.Net  Wed Jul 25 07:56:21 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Tue, 24 Jul 2007 22:56:21 -0700
Subject: bcm43xx_mac80211 unhappy
Message-ID: <46A6E605.6020902@Wetwork.Net>

I'm bored, and I don't leave for the Champ Car Grand Prix of San Jose 
until Thursday.  Developers - if there's something you need from my 
system, ask away.

Ehud

bcm43xx_mac80211: Adding Interface type 2
ssb: Switching to PCI-E core, index 3
ssb: Switching to IEEE 802.11 core, index 1
bcm43xx_mac80211: Loading firmware version 371.1061 (2006-10-04 21:02:04)
ssb: Switching to ChipCommon core, index 0
ssb: Switching to IEEE 802.11 core, index 1
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: ERROR: bbatt(11) >= size of LO array

Call Trace:
 [<ffffffff8824883a>] :bcm43xx_mac80211:bcm43xx_get_lo_g_ctl+0x54/0x93
 [<ffffffff882488af>] :bcm43xx_mac80211:bcm43xx_lo_g_ctl_current+0x36/0x3b
 [<ffffffff8824898a>] :bcm43xx_mac80211:bcm43xx_lo_g_adjust+0x9/0x15
 [<ffffffff882430c3>] :bcm43xx_mac80211:bcm43xx_phy_init_pctl+0x338/0x6a2
 [<ffffffff8823dc29>] :bcm43xx_mac80211:bcm43xx_phy_read+0x58/0x60
 [<ffffffff88246367>] :bcm43xx_mac80211:bcm43xx_phy_initg+0xc85/0xd0a
 [<ffffffff88246b9a>] :bcm43xx_mac80211:bcm43xx_phy_init+0x582/0x5a3
 [<ffffffff88239105>] :bcm43xx_mac80211:bcm43xx_chip_init+0x675/0x984
 [<ffffffff8823a7a1>] 
:bcm43xx_mac80211:bcm43xx_wireless_core_init+0x27d/0x70a
 [<ffffffff8823bfff>] :bcm43xx_mac80211:bcm43xx_add_interface+0x5c/0xf1
 [<ffffffff881f65c6>] :mac80211:ieee80211_open+0x222/0x34c
 [<ffffffff811e05bb>] dev_open+0x2f/0x6e
 [<ffffffff811de783>] dev_change_flags+0x5a/0x118
 [<ffffffff8122284b>] devinet_ioctl+0x235/0x597
 [<ffffffff8124be1e>] do_page_fault+0x476/0x7b4
 [<ffffffff811d415f>] sock_ioctl+0x1c8/0x1e5
 [<ffffffff8109f87b>] do_ioctl+0x2b/0xb6
 [<ffffffff8109fb49>] vfs_ioctl+0x243/0x25c
 [<ffffffff8109fbbb>] sys_ioctl+0x59/0x7a
 [<ffffffff81009b5e>] system_call+0x7e/0x83

[root at egdell ~]# uname -a
Linux egdell.wetwork.net 2.6.22.1-27.fc7 #1 SMP Tue Jul 17 17:19:58 EDT 
2007 x86_64 x86_64 x86_64 GNU/Linux
[root at egdell ~]# lsmod | grep bcm
bcm43xx_mac80211      418849  0
ssb                    43461  1 bcm43xx_mac80211
mac80211              164809  2 rc80211_simple,bcm43xx_mac80211
[root at egdell ~]# iwconfig
lo        no wireless extensions.

eth0      no wireless extensions.

wmaster0  no wireless extensions.

eth1      IEEE 802.11g  ESSID:"wetwork" 
          Mode:Managed  Frequency:2.437 GHz  Access Point: 
00:0D:0B:11:5C:1B  
          Bit Rate=1 Mb/s  
          Retry min limit:7   RTS thr:off   Fragment thr=2346 B  
          Encryption key:wep-key-goes-here
          Link Quality=43/100  Signal level=-55 dBm  Noise level=-85 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0
....

 1000  iwconfig
eth1 is there... but not connected  (ONBOOT=NO in 
/etc/sysconfig/network-scripts/ifup-eth1)
 1001  dmesg
the firmware WAS loaded, cores detected, etc.
 1002  lsmod | grep bcm
yup, the bcm stuff is there
 1003  lsmod | grep ndis
no, no wrapper
 1004  iwconfig
not associated
 1006  iwlist eth1 scan
can't list while it's not up
 1007  ifconfig eth1 up
 1008  iwlist eth1 scan
now I get a list
 1009  iwconfig
not associated tho... let's let ifup do it...
 1010  ifup eth1
there we go... no errors
 1011  ifconfig eth1
it's got an address
 1012  ping 10.1.1.1
it can ping the gateway
 1013  lsmod | grep bcm
 1014  lsmod | grep ndis
yes one one and no on two
 1015  dmesg
weird error.
 1016  uname -a
 1017  lsmod | grep bcm
 1018  iwconfig
 1019  history

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070724/7f5c2dc8/attachment.bin>

From dwmw2 at infradead.org  Wed Jul 25 14:26:23 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Wed, 25 Jul 2007 13:26:23 +0100
Subject: [PATCH] bcm43xx: Fix deviation from specifications in
	set_baseband_attenuation
In-Reply-To: <200707092259.l69MxVRc007980@hera.kernel.org>
References: <200707092259.l69MxVRc007980@hera.kernel.org>
Message-ID: <1185366383.14697.372.camel@pmac.infradead.org>

On Mon, 2007-07-09 at 22:59 +0000, Linux Kernel Mailing List wrote:
> Gitweb:     http://git.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=77548f58070894cf5970a110981e511ffe793369
> Commit:     77548f58070894cf5970a110981e511ffe793369
> Parent:     aaf83d4fc4a596929306c894d341e17fbdfba758
> Author:     Larry Finger <Larry.Finger at lwfinger.net>
> AuthorDate: Sat May 26 22:21:29 2007 -0500
> Committer:  Jeff Garzik <jeff at garzik.org>
> CommitDate: Sun Jul 8 22:16:37 2007 -0400
> 
>     [PATCH] bcm43xx: Fix deviation from specifications in set_baseband_attenuation
>     
>     A disagreement between the specifications and the bcm43xx code has just
>     been discovered and is hereby fixed.
>     
>     Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
>     Signed-off-by: John W. Linville <linville at tuxdriver.com>
> ---
>  drivers/net/wireless/bcm43xx/bcm43xx_phy.c |    2 +-
>  1 files changed, 1 insertions(+), 1 deletions(-)
> 
> diff --git a/drivers/net/wireless/bcm43xx/bcm43xx_phy.c b/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
> index b37f1e3..d779199 100644
> --- a/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
> +++ b/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
> @@ -1638,7 +1638,7 @@ void bcm43xx_phy_set_baseband_attenuation(struct bcm43xx_private *bcm,
>  		return;
>  	}
>  
> -	if (phy->analog > 1) {
> +	if (phy->analog == 1) {
>  		value = bcm43xx_phy_read(bcm, 0x0060) & ~0x003C;
>  		value |= (baseband_attenuation << 2) & 0x003C;
>  	} else {
> -

This broke my shinybook. I seem to get absolutely _no_ outgoing packets,
although I can receive OK.

bcm43xx: Chip ID 0x4306, rev 0x2
bcm43xx: Number of cores: 6
bcm43xx: Core 0: ID 0x800, rev 0x2, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0x4, vendor 0x4243
bcm43xx: Core 2: ID 0x80d, rev 0x1, vendor 0x4243
bcm43xx: Core 3: ID 0x807, rev 0x1, vendor 0x4243
bcm43xx: Core 4: ID 0x804, rev 0x7, vendor 0x4243
bcm43xx: Core 5: ID 0x812, rev 0x4, vendor 0x4243

bcm43xx: Detected PHY: Analog: 1, Type 2, Revision 1
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)

bcm43xx: Microcode rev 0x122, pl 0x99 (2005-01-22  22:40:08)


-- 
dwmw2



From larry.finger at lwfinger.net  Wed Jul 25 16:42:35 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 25 Jul 2007 09:42:35 -0500
Subject: [PATCH] bcm43xx: Fix deviation from specifications
	in	set_baseband_attenuation
In-Reply-To: <1185366383.14697.372.camel@pmac.infradead.org>
References: <200707092259.l69MxVRc007980@hera.kernel.org>
	<1185366383.14697.372.camel@pmac.infradead.org>
Message-ID: <46A7615B.5010003@lwfinger.net>

David Woodhouse wrote:
> On Mon, 2007-07-09 at 22:59 +0000, Linux Kernel Mailing List wrote:
>> Gitweb:     http://git.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=77548f58070894cf5970a110981e511ffe793369
>> Commit:     77548f58070894cf5970a110981e511ffe793369
>> Parent:     aaf83d4fc4a596929306c894d341e17fbdfba758
>> Author:     Larry Finger <Larry.Finger at lwfinger.net>
>> AuthorDate: Sat May 26 22:21:29 2007 -0500
>> Committer:  Jeff Garzik <jeff at garzik.org>
>> CommitDate: Sun Jul 8 22:16:37 2007 -0400
>>
>>     [PATCH] bcm43xx: Fix deviation from specifications in set_baseband_attenuation
>>     
>>     A disagreement between the specifications and the bcm43xx code has just
>>     been discovered and is hereby fixed.
>>     
>>     Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
>>     Signed-off-by: John W. Linville <linville at tuxdriver.com>
>> ---
>>  drivers/net/wireless/bcm43xx/bcm43xx_phy.c |    2 +-
>>  1 files changed, 1 insertions(+), 1 deletions(-)
>>
>> diff --git a/drivers/net/wireless/bcm43xx/bcm43xx_phy.c b/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
>> index b37f1e3..d779199 100644
>> --- a/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
>> +++ b/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
>> @@ -1638,7 +1638,7 @@ void bcm43xx_phy_set_baseband_attenuation(struct bcm43xx_private *bcm,
>>  		return;
>>  	}
>>  
>> -	if (phy->analog > 1) {
>> +	if (phy->analog == 1) {
>>  		value = bcm43xx_phy_read(bcm, 0x0060) & ~0x003C;
>>  		value |= (baseband_attenuation << 2) & 0x003C;
>>  	} else {
>> -
> 
> This broke my shinybook. I seem to get absolutely _no_ outgoing packets,
> although I can receive OK.
> 
> bcm43xx: Chip ID 0x4306, rev 0x2
> bcm43xx: Number of cores: 6
> bcm43xx: Core 0: ID 0x800, rev 0x2, vendor 0x4243
> bcm43xx: Core 1: ID 0x812, rev 0x4, vendor 0x4243
> bcm43xx: Core 2: ID 0x80d, rev 0x1, vendor 0x4243
> bcm43xx: Core 3: ID 0x807, rev 0x1, vendor 0x4243
> bcm43xx: Core 4: ID 0x804, rev 0x7, vendor 0x4243
> bcm43xx: Core 5: ID 0x812, rev 0x4, vendor 0x4243
> 
> bcm43xx: Detected PHY: Analog: 1, Type 2, Revision 1
> bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> 
> bcm43xx: Microcode rev 0x122, pl 0x99 (2005-01-22  22:40:08)

David,

Thanks for your report. This section obviously needs additional investigation.

John,

Please revert this patch. Should I push the reversion upstream, or will you?

Thanks,

Larry




From mika.sundland at gmail.com  Wed Jul 25 22:41:16 2007
From: mika.sundland at gmail.com (Mika Sundland)
Date: Wed, 25 Jul 2007 22:41:16 +0200
Subject: An entry for the device list
Message-ID: <cc7c2b300707251341m57129094w8744218ac5b40de1@mail.gmail.com>

Hello,

I got an HP Pavilion dv9074ea with a wireless network card that uses
the bcm43xx module. It's not listed in the device list, so I thought I
might submit some info about it.

lspci -vvv:

03:00.0 Network controller: Broadcom Corporation BCM4312 802.11a/b/g (rev 01)
        Subsystem: Hewlett-Packard Company Unknown device 1361
        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop-
ParErr- Stepping- SERR+ FastB2B-
        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort-
<TAbort- <MAbort- >SERR- <PERR-
        Latency: 0, Cache Line Size: 64 bytes
        Interrupt: pin A routed to IRQ 9
        Region 0: Memory at c4000000 (32-bit, non-prefetchable) [size=16K]
        Capabilities: [40] Power Management version 2
                Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=375mA
PME(D0-,D1-,D2-,D3hot-,D3cold-)
                Status: D0 PME-Enable- DSel=0 DScale=2 PME-
        Capabilities: [58] Message Signalled Interrupts: Mask- 64bit-
Queue=0/0 Enable-
                Address: 00000000  Data: 0000
        Capabilities: [d0] Express Legacy Endpoint IRQ 0
                Device: Supported: MaxPayload 128 bytes, PhantFunc 0, ExtTag+
                Device: Latency L0s <4us, L1 unlimited
                Device: AtnBtn- AtnInd- PwrInd-
                Device: Errors: Correctable- Non-Fatal- Fatal- Unsupported-
                Device: RlxdOrd- ExtTag- PhantFunc- AuxPwr- NoSnoop-
                Device: MaxPayload 128 bytes, MaxReadReq 128 bytes
                Link: Supported Speed 2.5Gb/s, Width x1, ASPM L0s, Port 0
                Link: Latency L0s <4us, L1 <64us
                Link: ASPM Disabled RCB 64 bytes CommClk- ExtSynch-
                Link: Speed 2.5Gb/s, Width x1
        Capabilities: [100] Advanced Error Reporting
        Capabilities: [13c] Virtual Channel

iwconfig:

eth1      IEEE 802.11b/g  ESSID:"linksys A"  Nickname:"Broadcom 4311"
          Mode:Managed  Frequency=2.462 GHz  Access Point: 00:18:39:1A:D1:07
          Bit Rate=24 Mb/s   Tx-Power=18 dBm
          RTS thr:off   Fragment thr:off
          Encryption
key:9C20-0BEE-3336-DC23-4576-15C2-A925-008E-0759-4319-E827-E93F-37B7-83BA-C10A-B4C6
  Security mode:open
          Link Quality=73/100  Signal level=-52 dBm  Noise level=-71 dBm
          Rx invalid nwid:0  Rx invalid crypt:892  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0


From larry.finger at lwfinger.net  Wed Jul 25 22:53:29 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 25 Jul 2007 15:53:29 -0500
Subject: An entry for the device list
In-Reply-To: <cc7c2b300707251341m57129094w8744218ac5b40de1@mail.gmail.com>
References: <cc7c2b300707251341m57129094w8744218ac5b40de1@mail.gmail.com>
Message-ID: <46A7B849.603@lwfinger.net>

Mika Sundland wrote:
> Hello,
> 
> I got an HP Pavilion dv9074ea with a wireless network card that uses
> the bcm43xx module. It's not listed in the device list, so I thought I
> might submit some info about it.

The BCM4312 has been supported for some time. Whick list do you refer to?

> lspci -vvv:
> 
> 03:00.0 Network controller: Broadcom Corporation BCM4312 802.11a/b/g (rev 01)
>         Subsystem: Hewlett-Packard Company Unknown device 1361
>         Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop-

--snip--

> eth1      IEEE 802.11b/g  ESSID:"linksys A"  Nickname:"Broadcom 4311"
>           Mode:Managed  Frequency=2.462 GHz  Access Point: 00:18:39:1A:D1:07
>           Bit Rate=24 Mb/s   Tx-Power=18 dBm
>           RTS thr:off   Fragment thr:off
>           Encryption
> key:9C20-0BEE-3336-DC23-4576-15C2-A925-008E-0759-4319-E827-E93F-37B7-83BA-C10A-B4C6
>   Security mode:open

You just published the key for your WPA encryption to a public list. You should change your 
passphrase now.

Larry



From mika.sundland at gmail.com  Wed Jul 25 22:59:41 2007
From: mika.sundland at gmail.com (Mika Sundland)
Date: Wed, 25 Jul 2007 22:59:41 +0200
Subject: An entry for the device list
In-Reply-To: <cc7c2b300707251357g1715315avbc846aa6860ab913@mail.gmail.com>
References: <cc7c2b300707251341m57129094w8744218ac5b40de1@mail.gmail.com>
	<46A7B849.603@lwfinger.net>
	<cc7c2b300707251357g1715315avbc846aa6860ab913@mail.gmail.com>
Message-ID: <cc7c2b300707251359o1c132555ufa169d0e30571e22@mail.gmail.com>

On 7/25/07, Mika Sundland <mika.sundland at gmail.com> wrote:
> On 7/25/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> > Mika Sundland wrote:
> > > Hello,
> > >
> > > I got an HP Pavilion dv9074ea with a wireless network card that uses
> > > the bcm43xx module. It's not listed in the device list, so I thought I
> > > might submit some info about it.
> >
> > The BCM4312 has been supported for some time. Whick list do you refer to?
> >
> > > lspci -vvv:
> > >
> > > 03:00.0 Network controller: Broadcom Corporation BCM4312 802.11a/b/g (rev 01)
> > >         Subsystem: Hewlett-Packard Company Unknown device 1361
> > >         Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop-
> >
> > --snip--
> >
> > > eth1      IEEE 802.11b/g  ESSID:"linksys A"  Nickname:"Broadcom 4311"
> > >           Mode:Managed  Frequency=2.462 GHz  Access Point: 00:18:39:1A:D1:07
> > >           Bit Rate=24 Mb/s   Tx-Power=18 dBm
> > >           RTS thr:off   Fragment thr:off
> > >           Encryption
> > > key:9C20-0BEE-3336-DC23-4576-15C2-A925-008E-0759-4319-E827-E93F-37B7-83BA-C10A-B4C6
> > >   Security mode:open
> >
> > You just published the key for your WPA encryption to a public list. You should change your
> > passphrase now.
> >
> > Larry
> >
> >
> The access point is only used for testing now and then, so no worries.
>


From will.dyson at gmail.com  Thu Jul 26 07:17:04 2007
From: will.dyson at gmail.com (Will Dyson)
Date: Thu, 26 Jul 2007 01:17:04 -0400
Subject: [PATCH] [bcm43xx-mac80211] Fix pci flush in bcm43xx_mac_suspend
Message-ID: <1185427024671-git-send-email-will.dyson@gmail.com>

Fix bcm43xx_mac_suspend to flush the status register that we wrote to,
instead of the register where the result will appear. Improve the comment.

I was getting many mac suspend failures, now it only happens occasionally.

Signed-off-by: Will Dyson <will.dyson at gmail.com>
---
 .../net/wireless/bcm43xx-mac80211/bcm43xx_main.c   |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
index eefc536..4cf671a 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -1875,7 +1875,8 @@ void bcm43xx_mac_suspend(struct bcm43xx_wldev *dev)
 		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
 		                bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD)
 				& ~BCM43xx_SBF_MAC_ENABLED);
-		bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
+		/* force pci to flush the write */
+		bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 		for (i = 10000; i; i--) {
 			tmp = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
 			if (tmp & BCM43xx_IRQ_MAC_SUSPENDED)
-- 
1.5.2.4



From GNUtoo at no-log.org  Thu Jul 26 17:04:49 2007
From: GNUtoo at no-log.org (GNUtoo at no-log.org)
Date: Thu, 26 Jul 2007 17:04:49 +0200 (CEST)
Subject: BCM4318 ap problems
Message-ID: <36154.AQdWDl5SDH8=.1185462289.squirrel@webmail.no-log.org>

hello, i have some problem with the ap mode:
first i have a problem compiling hostapd 0.6.0 against the curent
wireless-dev kernel:

i686-pc-linux-gnu-gcc -O2 -march=pentium-m -pipe -DHOSTAPD_DUMP_STATE
-I../src -I../src/crypto -I../src/utils -I../src/common
-I/usr/include/madwifi -I"/usr/src/linux"/net/mac80211 -DCONFIG_CTRL_IFACE
-DCONFIG_CTRL_IFACE_UNIX -DCONFIG_IAPP -DCONFIG_RSN_PREAUTH
-DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R
-DCONFIG_DRIVER_HOSTAP -DCONFIG_DRIVER_WIRED -DCONFIG_DRIVER_MADWIFI
-DCONFIG_DRIVER_PRISM54 -DCONFIG_DRIVER_DEVICESCAPE -DEAP_MD5 -DEAP_TLS
-DEAP_PEAP -DEAP_TTLS -DEAP_MSCHAPv2 -DEAP_GTC -DEAP_SIM -DEAP_AKA
-DEAP_PAX -DEAP_PSK -DEAP_SAKE -DEAP_GPSK -DEAP_GPSK_SHA256 -DEAP_TLV
-DEAP_SERVER -DEAP_TLS_FUNCS -DPKCS12_FUNCS -DINTERNAL_SHA256
-DRADIUS_SERVER -DCONFIG_IPV6   -c -o ../src/l2_packet/l2_packet_linux.o
../src/l2_packet/l2_packet_linux.c
driver_devicescape.c: In function 'i802_if_update':
driver_devicescape.c:1032: error: 'PRISM2_HOSTAPD_UPDATE_IF' undeclared
(first use in this function)
driver_devicescape.c:1032: error: (Each undeclared identifier is reported
only once
driver_devicescape.c:1032: error: for each function it appears in.)
driver_devicescape.c: In function 'handle_frame':
driver_devicescape.c:1358: error: 'ieee80211_msg_set_aid_for_sta'
undeclared (first use in this function)
driver_devicescape.c:1416: error: 'ieee80211_msg_passive_scan' undeclared
(first use in this function)
make: *** [driver_devicescape.o] Error 1
make: *** Waiting for unfinished jobs....

!!! ERROR: net-wireless/hostapd-0.6.0 failed.
Call stack:
  ebuild.sh, line 1621:   Called dyn_compile
  ebuild.sh, line 973:   Called qa_call 'src_compile'
  ebuild.sh, line 44:   Called src_compile
  hostapd-0.6.0.ebuild, line 97:   Called die

!!! emake failed
!!! If you need support, post the topmost build error, and the call stack
if relevant.

so i used the linux-2.6.22-rc3-mm1 kernel with the bcm43xx mac80211 stack
that are inside the kernel
here's my card:
07:00.0 Network controller: Broadcom Corporation BCM4318 [AirForce One
54g] 802.11g Wireless LAN Controller (rev 02)
so i bring my interface up and iwlist from another card gives me that:
          Cell 04 - Address: 00:10:18:F1:F2:F3
                    ESSID:"BRCM_TEST_SSID"
                    Protocol:IEEE 802.11b
                    Mode:Master
                    Channel:1
                    Frequency:2.412 GHz (Channel 1)
                    Encryption key:off
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
                    Quality=79/100  Signal level=-50 dBm
                    Extra: Last beacon: 155ms ago
evry eddid i put gives me BRCM_TEST_SSID
so i have added it to both config files(from my script to put my card up
and from hostapd.conf)
and here the result of running hostapd:
# hostapd /etc/hostapd/hostapd.conf
Configuration file: /etc/hostapd/hostapd.conf
Opening raw packet socket for ifindex 16
BSS count 1, BSSID mask ff:ff:ff:ff:ff:ff (0 bits)
Hardware does not support configured mode
wlan0: IEEE 802.11 Hardware does not support configured mode (2)
Could not select hw_mode and channel. (-1)
rmdir[ctrl_interface]: No such file or directory
ELOOP: remaining socket: sock=4 eloop_data=0x80b3450 user_data=(nil)
handler=0x8080b70

what should i do in order to:
->debug the thing
->make a simple and open acess point work with my card



From Larry.Finger at lwfinger.net  Thu Jul 26 18:33:01 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 26 Jul 2007 11:33:01 -0500
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
Message-ID: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>

A typo in the specs interchanges the branches in an if statement, which
breaks operations for a BCM4306/rev 2 that has phy->analog == 1.

Signed-off-by: Larry Finger<Larry.Finger at lwfinger.net>
---

John and Michael,

This patch is made for the wireless-dev tree after the bcm43xx-mac80211
directory has been moved into drivers/net/wireless, but it needs to be
applied to the wireless-mb tree as well.

Larry

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
===================================================================
--- wireless-dev/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
@@ -1895,7 +1895,7 @@ void bcm43xx_phy_set_baseband_attenuatio
 		bcm43xx_write16(dev, BCM43xx_MMIO_PHY0,
 				(bcm43xx_read16(dev, BCM43xx_MMIO_PHY0)
 				 & 0xFFF0) | baseband_attenuation);
-	} else if (phy->analog == 1) {
+	} else if (phy->analog != 1) {
 		bcm43xx_phy_write(dev, BCM43xx_PHY_DACCTL,
 				  (bcm43xx_phy_read(dev, BCM43xx_PHY_DACCTL)
 				   & 0xFFC3) | (baseband_attenuation << 2));


From mb at bu3sch.de  Thu Jul 26 19:31:41 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 26 Jul 2007 19:31:41 +0200
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
In-Reply-To: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
References: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
Message-ID: <200707261931.41448.mb@bu3sch.de>

On Thursday 26 July 2007 18:33:01 Larry Finger wrote:
> A typo in the specs interchanges the branches in an if statement, which
> breaks operations for a BCM4306/rev 2 that has phy->analog == 1.
> 
> Signed-off-by: Larry Finger<Larry.Finger at lwfinger.net>
> ---
> 
> John and Michael,
> 
> This patch is made for the wireless-dev tree after the bcm43xx-mac80211
> directory has been moved into drivers/net/wireless, but it needs to be
> applied to the wireless-mb tree as well.
> 
> Larry
> 
> Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> ===================================================================
> --- wireless-dev/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> +++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
> @@ -1895,7 +1895,7 @@ void bcm43xx_phy_set_baseband_attenuatio
>  		bcm43xx_write16(dev, BCM43xx_MMIO_PHY0,
>  				(bcm43xx_read16(dev, BCM43xx_MMIO_PHY0)
>  				 & 0xFFF0) | baseband_attenuation);
> -	} else if (phy->analog == 1) {
> +	} else if (phy->analog != 1) {
>  		bcm43xx_phy_write(dev, BCM43xx_PHY_DACCTL,
>  				  (bcm43xx_phy_read(dev, BCM43xx_PHY_DACCTL)
>  				   & 0xFFC3) | (baseband_attenuation << 2));
> 
> 

Last time I checked this code it matched the specs. And that's not too
long ago.
Did the specs change?

-- 
Greetings Michael.


From linville at tuxdriver.com  Thu Jul 26 19:21:38 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 26 Jul 2007 13:21:38 -0400
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
In-Reply-To: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
References: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
Message-ID: <20070726172138.GA6068@tuxdriver.com>

On Thu, Jul 26, 2007 at 11:33:01AM -0500, Larry Finger wrote:
> A typo in the specs interchanges the branches in an if statement, which
> breaks operations for a BCM4306/rev 2 that has phy->analog == 1.

> @@ -1895,7 +1895,7 @@ void bcm43xx_phy_set_baseband_attenuatio
>  		bcm43xx_write16(dev, BCM43xx_MMIO_PHY0,
>  				(bcm43xx_read16(dev, BCM43xx_MMIO_PHY0)
>  				 & 0xFFF0) | baseband_attenuation);
> -	} else if (phy->analog == 1) {
> +	} else if (phy->analog != 1) {
>  		bcm43xx_phy_write(dev, BCM43xx_PHY_DACCTL,
>  				  (bcm43xx_phy_read(dev, BCM43xx_PHY_DACCTL)
>  				   & 0xFFC3) | (baseband_attenuation << 2));

Larry,

How does this relate to the bcm43xx patch you asked me to revert
(and has been reverted in F-7)?  That one change "==" to ">", while
this one changes "==" to "!=".  Instead of reverting the other,
should it do the same thing as this?

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Thu Jul 26 19:56:20 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 26 Jul 2007 12:56:20 -0500
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
In-Reply-To: <20070726172138.GA6068@tuxdriver.com>
References: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
	<20070726172138.GA6068@tuxdriver.com>
Message-ID: <46A8E044.6080206@lwfinger.net>

John W. Linville wrote:
> On Thu, Jul 26, 2007 at 11:33:01AM -0500, Larry Finger wrote:
>> A typo in the specs interchanges the branches in an if statement, which
>> breaks operations for a BCM4306/rev 2 that has phy->analog == 1.
> 
>> @@ -1895,7 +1895,7 @@ void bcm43xx_phy_set_baseband_attenuatio
>>  		bcm43xx_write16(dev, BCM43xx_MMIO_PHY0,
>>  				(bcm43xx_read16(dev, BCM43xx_MMIO_PHY0)
>>  				 & 0xFFF0) | baseband_attenuation);
>> -	} else if (phy->analog == 1) {
>> +	} else if (phy->analog != 1) {
>>  		bcm43xx_phy_write(dev, BCM43xx_PHY_DACCTL,
>>  				  (bcm43xx_phy_read(dev, BCM43xx_PHY_DACCTL)
>>  				   & 0xFFC3) | (baseband_attenuation << 2));
> 
> Larry,
> 
> How does this relate to the bcm43xx patch you asked me to revert
> (and has been reverted in F-7)?  That one change "==" to ">", while
> this one changes "==" to "!=".  Instead of reverting the other,
> should it do the same thing as this?

It really doesn't matter whether one uses ">" or "!=" here. The number in question is >= 0 and the 
test for for zero occurs earlier in the routine and ends with a return. Now that you mention it, it 
would be best to make bcm43xx nad bcm43xx-mac80211 look the same. I'll modify and resubmit the patch.

Larry




From larry.finger at lwfinger.net  Thu Jul 26 20:03:04 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 26 Jul 2007 13:03:04 -0500
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
In-Reply-To: <200707261931.41448.mb@bu3sch.de>
References: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
	<200707261931.41448.mb@bu3sch.de>
Message-ID: <46A8E1D8.5040301@lwfinger.net>

Michael Buesch wrote:
> 
> Last time I checked this code it matched the specs. And that's not too
> long ago.
> Did the specs change?

We had a complaint that a change in the V3 specs broke a BCM4306/rev 2 card using bcm43xx - it 
received but did not transmit. I verified the breakage and found that reverting a patch fixed the 
problem. I contacted Joseph, who found that he had mixed the branches when doing the specs.

This morning, I found that bcm43xx-mac80211 has the same problem. I have not yet asked Joseph to 
recheck the specs; however, the patch I submitted allows my phy->rev == 1 card to work. Without it, 
it does not. I think there is an error in the specs in that place.

Larry




From mb at bu3sch.de  Thu Jul 26 20:11:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 26 Jul 2007 20:11:48 +0200
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
In-Reply-To: <46A8E1D8.5040301@lwfinger.net>
References: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
	<200707261931.41448.mb@bu3sch.de> <46A8E1D8.5040301@lwfinger.net>
Message-ID: <200707262011.48527.mb@bu3sch.de>

On Thursday 26 July 2007 20:03:04 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > Last time I checked this code it matched the specs. And that's not too
> > long ago.
> > Did the specs change?
> 
> We had a complaint that a change in the V3 specs broke a BCM4306/rev 2 card using bcm43xx - it 
> received but did not transmit. I verified the breakage and found that reverting a patch fixed the 
> problem. I contacted Joseph, who found that he had mixed the branches when doing the specs.
> 
> This morning, I found that bcm43xx-mac80211 has the same problem. I have not yet asked Joseph to 
> recheck the specs; however, the patch I submitted allows my phy->rev == 1 card to work. Without it, 
> it does not. I think there is an error in the specs in that place.

Ok, nice.
I always like some nice explanation like this for this kind of patches.
Because changing code based on "Specs changed, dunno why, so let's change this too"
are always hairy and broke stuff in the past. :)

I'll test and merge this as soon as you resubmitted it.

-- 
Greetings Michael.


From linville at tuxdriver.com  Thu Jul 26 20:13:34 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 26 Jul 2007 14:13:34 -0400
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
In-Reply-To: <46A8E044.6080206@lwfinger.net>
References: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
	<20070726172138.GA6068@tuxdriver.com>
	<46A8E044.6080206@lwfinger.net>
Message-ID: <20070726181334.GB6068@tuxdriver.com>

On Thu, Jul 26, 2007 at 12:56:20PM -0500, Larry Finger wrote:
> John W. Linville wrote:
> >On Thu, Jul 26, 2007 at 11:33:01AM -0500, Larry Finger wrote:
> >>A typo in the specs interchanges the branches in an if statement, which
> >>breaks operations for a BCM4306/rev 2 that has phy->analog == 1.
> >
> >>@@ -1895,7 +1895,7 @@ void bcm43xx_phy_set_baseband_attenuatio
> >> 		bcm43xx_write16(dev, BCM43xx_MMIO_PHY0,
> >> 				(bcm43xx_read16(dev, BCM43xx_MMIO_PHY0)
> >> 				 & 0xFFF0) | baseband_attenuation);
> >>-	} else if (phy->analog == 1) {
> >>+	} else if (phy->analog != 1) {
> >> 		bcm43xx_phy_write(dev, BCM43xx_PHY_DACCTL,
> >> 				  (bcm43xx_phy_read(dev, BCM43xx_PHY_DACCTL)
> >> 				   & 0xFFC3) | (baseband_attenuation << 2));
> >
> >Larry,
> >
> >How does this relate to the bcm43xx patch you asked me to revert
> >(and has been reverted in F-7)?  That one change "==" to ">", while
> >this one changes "==" to "!=".  Instead of reverting the other,
> >should it do the same thing as this?
> 
> It really doesn't matter whether one uses ">" or "!=" here. The number in 
> question is >= 0 and the test for for zero occurs earlier in the routine 
> and ends with a return. Now that you mention it, it would be best to make 
> bcm43xx nad bcm43xx-mac80211 look the same. I'll modify and resubmit the 
> patch.

Hmmm...well, if you asked to revert it on bcm43xx, why is it appropriate here?

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Thu Jul 26 20:49:58 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 26 Jul 2007 13:49:58 -0500
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
In-Reply-To: <20070726181334.GB6068@tuxdriver.com>
References: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
	<20070726172138.GA6068@tuxdriver.com>
	<46A8E044.6080206@lwfinger.net>
	<20070726181334.GB6068@tuxdriver.com>
Message-ID: <46A8ECD6.30204@lwfinger.net>

John W. Linville wrote:
> 
> Hmmm...well, if you asked to revert it on bcm43xx, why is it appropriate here?

AFAIK, the V4 specs have always had the typo, thus there was no patch introducing this error - it is 
original. On the other hand, the V3 specs were modified fairly late in the process, which led to the 
bcm43xx patch that needed to be reverted. I suspect that the V3 changes may have been the result of 
making them match the V4 specs. If that is the case, it made both of them wrong.

No matter, the change is needed to make some older cards work. Now I know why bcm43xx-mac80211 never 
worked on my BCM4306 until today.

Larry


From Larry.Finger at lwfinger.net  Thu Jul 26 21:03:24 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 26 Jul 2007 14:03:24 -0500
Subject: [PATCH V2] bcm43xx-mac80211: Fix specs typo for baseband attenuation
Message-ID: <46a8effc.li9IcZcHQyQEe/l3%Larry.Finger@lwfinger.net>

A typo in the specs interchanges the branches in an if statement, which
breaks operations for a BCM4306/rev 2 that has phy->analog == 1.

Signed-off-by: Larry Finger<Larry.Finger at lwfinger.net>
---

John and Michael,

This patch is made for the wireless-dev tree after the bcm43xx-mac80211
directory has been moved into drivers/net/wireless, but it needs to be
applied to the wireless-mb tree as well.

Larry

Index: wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
===================================================================
--- wireless-dev/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
+++ wireless-dev/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
@@ -1895,7 +1895,7 @@ void bcm43xx_phy_set_baseband_attenuatio
 		bcm43xx_write16(dev, BCM43xx_MMIO_PHY0,
 				(bcm43xx_read16(dev, BCM43xx_MMIO_PHY0)
 				 & 0xFFF0) | baseband_attenuation);
-	} else if (phy->analog == 1) {
+	} else if (phy->analog > 1) {
 		bcm43xx_phy_write(dev, BCM43xx_PHY_DACCTL,
 				  (bcm43xx_phy_read(dev, BCM43xx_PHY_DACCTL)
 				   & 0xFFC3) | (baseband_attenuation << 2));


From linville at tuxdriver.com  Thu Jul 26 21:26:01 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 26 Jul 2007 15:26:01 -0400
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
In-Reply-To: <46A8ECD6.30204@lwfinger.net>
References: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
	<20070726172138.GA6068@tuxdriver.com>
	<46A8E044.6080206@lwfinger.net>
	<20070726181334.GB6068@tuxdriver.com> <46A8ECD6.30204@lwfinger.net>
Message-ID: <20070726192601.GD6068@tuxdriver.com>

On Thu, Jul 26, 2007 at 01:49:58PM -0500, Larry Finger wrote:
> John W. Linville wrote:
> >
> >Hmmm...well, if you asked to revert it on bcm43xx, why is it appropriate 
> >here?
> 
> AFAIK, the V4 specs have always had the typo, thus there was no patch 
> introducing this error - it is original. On the other hand, the V3 specs 
> were modified fairly late in the process, which led to the bcm43xx patch 
> that needed to be reverted. I suspect that the V3 changes may have been the 
> result of making them match the V4 specs. If that is the case, it made both 
> of them wrong.
> 
> No matter, the change is needed to make some older cards work. Now I know 
> why bcm43xx-mac80211 never worked on my BCM4306 until today.

OK, I get it...I was looking at the patch dwmw2 slipped into F-7 and
then in my head reverting that (i.e. reversing the reverse patch) --
my bad!

Michael, unless you plan to push soon I'll just apply the new patch
to wireless-dev more-or-less immediately?

John
-- 
John W. Linville
linville at tuxdriver.com


From mb at bu3sch.de  Thu Jul 26 21:38:37 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 26 Jul 2007 21:38:37 +0200
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
In-Reply-To: <20070726192601.GD6068@tuxdriver.com>
References: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
	<46A8ECD6.30204@lwfinger.net> <20070726192601.GD6068@tuxdriver.com>
Message-ID: <200707262138.38171.mb@bu3sch.de>

On Thursday 26 July 2007 21:26:01 John W. Linville wrote:
> On Thu, Jul 26, 2007 at 01:49:58PM -0500, Larry Finger wrote:
> > John W. Linville wrote:
> > >
> > >Hmmm...well, if you asked to revert it on bcm43xx, why is it appropriate 
> > >here?
> > 
> > AFAIK, the V4 specs have always had the typo, thus there was no patch 
> > introducing this error - it is original. On the other hand, the V3 specs 
> > were modified fairly late in the process, which led to the bcm43xx patch 
> > that needed to be reverted. I suspect that the V3 changes may have been the 
> > result of making them match the V4 specs. If that is the case, it made both 
> > of them wrong.
> > 
> > No matter, the change is needed to make some older cards work. Now I know 
> > why bcm43xx-mac80211 never worked on my BCM4306 until today.
> 
> OK, I get it...I was looking at the patch dwmw2 slipped into F-7 and
> then in my head reverting that (i.e. reversing the reverse patch) --
> my bad!
> 
> Michael, unless you plan to push soon I'll just apply the new patch
> to wireless-dev more-or-less immediately?

Ok, please apply.

-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Thu Jul 26 22:13:54 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 26 Jul 2007 15:13:54 -0500
Subject: A problem with shared interrupts
Message-ID: <46a90082./TQABjOfVYW1o6lY%Larry.Finger@lwfinger.net>

Michael,

When I try the -mb tree on my old i386 notebook, I get an "irq 11: nobody cared"
message and interrupts for the bcm43xx-mac80211 device are not initialized. The
code in Linville's tree works. The only difference that seems to be important
is the code returned when a shared interrupt not intended for us is received.
By making the changes shown below, both trees now work.

I recall you having a discussion with someone over some aspect of shared IRQ's,
but I don't remember the details and I'm too busy (lazy) to go back and look.

Thanks,

Larry
----

Index: wireless-mb/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
===================================================================
--- wireless-mb.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
+++ wireless-mb/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
@@ -1503,7 +1503,7 @@ static void bcm43xx_interrupt_ack(struct
 /* Interrupt handler top-half */
 static irqreturn_t bcm43xx_interrupt_handler(int irq, void *dev_id)
 {
-	irqreturn_t ret = IRQ_NONE;
+	irqreturn_t ret = IRQ_HANDLED;
 	struct bcm43xx_wldev *dev = dev_id;
 	u32 reason;
 
@@ -1517,7 +1517,6 @@ static irqreturn_t bcm43xx_interrupt_han
 	reason = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
 	if (reason == 0xffffffff) /* shared IRQ */
 		goto out;
-	ret = IRQ_HANDLED;
 	reason &= bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
 	if (!reason)
 		goto out;


From mb at bu3sch.de  Fri Jul 27 00:42:27 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 27 Jul 2007 00:42:27 +0200
Subject: A problem with shared interrupts
In-Reply-To: <46a90082./TQABjOfVYW1o6lY%Larry.Finger@lwfinger.net>
References: <46a90082./TQABjOfVYW1o6lY%Larry.Finger@lwfinger.net>
Message-ID: <200707270042.27917.mb@bu3sch.de>

On Thursday 26 July 2007 22:13:54 Larry Finger wrote:
> Michael,
> 
> When I try the -mb tree on my old i386 notebook, I get an "irq 11: nobody cared"
> message and interrupts for the bcm43xx-mac80211 device are not initialized. The
> code in Linville's tree works. The only difference that seems to be important
> is the code returned when a shared interrupt not intended for us is received.
> By making the changes shown below, both trees now work.
> 
> I recall you having a discussion with someone over some aspect of shared IRQ's,
> but I don't remember the details and I'm too busy (lazy) to go back and look.
> 
> Thanks,
> 
> Larry
> ----
> 
> Index: wireless-mb/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
> ===================================================================
> --- wireless-mb.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
> +++ wireless-mb/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
> @@ -1503,7 +1503,7 @@ static void bcm43xx_interrupt_ack(struct
>  /* Interrupt handler top-half */
>  static irqreturn_t bcm43xx_interrupt_handler(int irq, void *dev_id)
>  {
> -	irqreturn_t ret = IRQ_NONE;
> +	irqreturn_t ret = IRQ_HANDLED;
>  	struct bcm43xx_wldev *dev = dev_id;
>  	u32 reason;
>  
> @@ -1517,7 +1517,6 @@ static irqreturn_t bcm43xx_interrupt_han
>  	reason = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
>  	if (reason == 0xffffffff) /* shared IRQ */
>  		goto out;
> -	ret = IRQ_HANDLED;
>  	reason &= bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
>  	if (!reason)
>  		goto out;
> 
> 

I neither think this is the correct solution, nor do I think that this
is the way bcm43xx-softmac does it. This would always return HANDLED, right?
regardless if the IRQ was for bcm43xx or not. I _do_ think that the bug is
in the driver sharing the IRQ with bcm43xx.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Fri Jul 27 02:04:37 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 26 Jul 2007 19:04:37 -0500
Subject: A problem with shared interrupts
In-Reply-To: <200707270042.27917.mb@bu3sch.de>
References: <46a90082./TQABjOfVYW1o6lY%Larry.Finger@lwfinger.net>
	<200707270042.27917.mb@bu3sch.de>
Message-ID: <46A93695.3060909@lwfinger.net>

Michael Buesch wrote:
> 
> I neither think this is the correct solution, nor do I think that this
> is the way bcm43xx-softmac does it. This would always return HANDLED, right?
> regardless if the IRQ was for bcm43xx or not. I _do_ think that the bug is
> in the driver sharing the IRQ with bcm43xx.
> 

I misread the bcm43xx-mac80211 code from Linville's tree. clearly my patch is wrong. I'll have to 
find the differences between the two trees in drivers that share that IRQ. Fortunately, it is only 
yenta and bcm4301.

Larry




From dwmw2 at infradead.org  Fri Jul 27 11:18:52 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 27 Jul 2007 10:18:52 +0100
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
In-Reply-To: <46A8ECD6.30204@lwfinger.net>
References: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
	<20070726172138.GA6068@tuxdriver.com> <46A8E044.6080206@lwfinger.net>
	<20070726181334.GB6068@tuxdriver.com>  <46A8ECD6.30204@lwfinger.net>
Message-ID: <1185527932.14697.535.camel@pmac.infradead.org>

On Thu, 2007-07-26 at 13:49 -0500, Larry Finger wrote:
> No matter, the change is needed to make some older cards work. Now I
> know why bcm43xx-mac80211 never worked on my BCM4306 until today. 

Hm, it has worked for me in the past, and your patch fixes it so it
works again (at least as well as it ever did).

I still get constant complaints of 'eth1: duplicate address detected'
due to the fact that it sees its own outgoing packets, and IPv6 doesn't
work.

Then when unloading the module I get...

bcm43xx_mac80211: Radio turned off
Freeing alive inet6 address c1cefc80
unregister_netdevice: waiting for eth1 to become free. Usage count = 2


... and I have to reboot before anything related to networking works
again. When I unload the module from X rather than from a vt, the
machine sometimes locks up hard -- which I suspect is a different
problem, but I have no clue what.

-- 
dwmw2



From mb at bu3sch.de  Fri Jul 27 11:20:13 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 27 Jul 2007 11:20:13 +0200
Subject: [PATCH] bcm43xx-mac80211: Fix specs typo for baseband attenuation
In-Reply-To: <1185527932.14697.535.camel@pmac.infradead.org>
References: <46a8ccbd.wNQamvQ9e0RJ0XZK%Larry.Finger@lwfinger.net>
	<46A8ECD6.30204@lwfinger.net>
	<1185527932.14697.535.camel@pmac.infradead.org>
Message-ID: <200707271120.13723.mb@bu3sch.de>

On Friday 27 July 2007 11:18:52 David Woodhouse wrote:
> I still get constant complaints of 'eth1: duplicate address detected'
> due to the fact that it sees its own outgoing packets, and IPv6 doesn't
> work.
> 
> Then when unloading the module I get...
> 
> bcm43xx_mac80211: Radio turned off
> Freeing alive inet6 address c1cefc80
> unregister_netdevice: waiting for eth1 to become free. Usage count = 2

Sounds like mac80211 problems.
Jiri, Michael?


-- 
Greetings Michael.


From johannes at sipsolutions.net  Fri Jul 27 11:54:30 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 27 Jul 2007 11:54:30 +0200
Subject: A problem with shared interrupts
In-Reply-To: <46a90082./TQABjOfVYW1o6lY%Larry.Finger@lwfinger.net>
References: <46a90082./TQABjOfVYW1o6lY%Larry.Finger@lwfinger.net>
Message-ID: <1185530070.4006.46.camel@johannes.berg>

On Thu, 2007-07-26 at 15:13 -0500, Larry Finger wrote:
> Michael,
> 
> When I try the -mb tree on my old i386 notebook, I get an "irq 11: nobody cared"
> message and interrupts for the bcm43xx-mac80211 device are not initialized.

Hm. Just a thought about something related: do you have 'debug shared
interrupts' on?

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070727/92f36eb4/attachment.pgp>

From mb at bu3sch.de  Fri Jul 27 14:15:24 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 27 Jul 2007 14:15:24 +0200
Subject: Please pull latest bcm43xx-mac80211 + ssb
Message-ID: <200707271415.25087.mb@bu3sch.de>

The following changes since commit 78d7c152a3a8880b7daab8a1be1f24199f9d80b9:
  John W. Linville:
        Merge branch 'upstream' of git://git.kernel.org/.../ivd/rt2x00

are found in the git repository at:

  http://bu3sch.de/git/wireless-dev.git/ for-linville

Larry Finger:
      bcm43xx-mac80211: Fix deviations from OFDM table specs

Michael Buesch:
      bcm43xx-mac80211: Fix build for PCI-less systems.
      bcm43xx-mac80211: Use round_jiffies() to round pwork interval.
      ssb: Zero out invariants before pulling them.
      ssb: Rename nr_buses variable to next_busnumber
      bcm43xx-mac80211: Add optional verbose DMA debugging.
      bcm43xx-mac80211: Use ieee80211_generic_frame_duration() to calculate durations.
      bcm43xx-mac80211: Add sanity checks for the packet length in the RX handler.
      bcm43xx-mac80211: Rewrite and simplify handling of the initialization status.
      bcm43xx-mac80211: Rewrite message logging to associate logmessages to the wiphy.
      bcm43xx-mac80211: Get rid of all stupid bitfields and use bool.
      bcm43xx-mac80211: Fix nondebug build.
      Merge branch 'master' of git://git.kernel.org/.../linville/wireless-dev
      Merge branch 'master' of git://git.kernel.org/.../linville/wireless-dev
      ssb: Fix typo in EXTIF_BASE define.
      ssb: Address Andrew Morton's comments.
      bcm43xx-mac80211: Always run promisc on old devices with broken MAC addr filter.
      ssb: Remove ifdef __KERNEL__
      ssb: A few fixes
      ssb: Cleanup Makefile and Kconfig.
      ssb: Add more comments.
      Merge branch 'master' of git://git.kernel.org/.../linville/wireless-dev
      bcm43xx-mac80211: Fix compilation, pass if_id to ieee80211_generic_frame_duration()

 drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h    |  113 +++---
 .../wireless/bcm43xx-mac80211/bcm43xx_debugfs.c    |   83 +----
 .../wireless/bcm43xx-mac80211/bcm43xx_debugfs.h    |   43 --
 .../net/wireless/bcm43xx-mac80211/bcm43xx_dma.c    |  108 ++++--
 .../net/wireless/bcm43xx-mac80211/bcm43xx_dma.h    |    8 
 drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.c |   27 +
 drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.h |    4 
 .../net/wireless/bcm43xx-mac80211/bcm43xx_main.c   |  400 +++++++++++++----------
 .../net/wireless/bcm43xx-mac80211/bcm43xx_phy.c    |   64 ++--
 .../net/wireless/bcm43xx-mac80211/bcm43xx_phy.h    |    4 
 .../net/wireless/bcm43xx-mac80211/bcm43xx_pio.c    |   18 +
 .../net/wireless/bcm43xx-mac80211/bcm43xx_pio.h    |    6 
 .../net/wireless/bcm43xx-mac80211/bcm43xx_sysfs.c  |    4 
 .../net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c   |   23 +
 drivers/ssb/Kconfig                                |    1 
 drivers/ssb/Makefile                               |   18 +
 drivers/ssb/driver_chipcommon.c                    |   28 +
 drivers/ssb/driver_mipscore.c                      |   38 +-
 drivers/ssb/driver_pcicore.c                       |   30 +-
 drivers/ssb/main.c                                 |   90 ++---
 drivers/ssb/pci.c                                  |    4 
 drivers/ssb/pcmcia.c                               |   11 -
 drivers/ssb/scan.c                                 |   20 +
 drivers/ssb/ssb_private.h                          |   26 -
 include/linux/ssb/ssb.h                            |   29 +
 include/linux/ssb/ssb_driver_chipcommon.h          |    2 
 include/linux/ssb/ssb_driver_extif.h               |    3 
 include/linux/ssb/ssb_driver_mips.h                |    3 
 include/linux/ssb/ssb_driver_pci.h                 |    2 
 include/linux/ssb/ssb_regs.h                       |   12 -
 30 files changed, 593 insertions(+), 629 deletions(-)


diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
index 2802fc0..49b471a 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx.h
@@ -23,8 +23,6 @@ #include "bcm43xx_lo.h"
 #include "bcm43xx_phy.h"
 
 
-#define PFX				KBUILD_MODNAME ": "
-
 #define BCM43xx_IRQWAIT_MAX_RETRIES	50
 
 #define BCM43xx_IO_SIZE			8192
@@ -441,11 +439,12 @@ # undef assert
 #endif
 #ifdef CONFIG_BCM43XX_MAC80211_DEBUG
 # define assert(expr) \
-	do {									\
-		if (unlikely(!(expr))) {					\
-		printk(KERN_ERR PFX "ASSERTION FAILED (%s) at: %s:%d:%s()\n",	\
-			#expr, __FILE__, __LINE__, __FUNCTION__);		\
-		}								\
+	do {								\
+		if (unlikely(!(expr))) {				\
+		printk(KERN_ERR KBUILD_MODNAME ": "			\
+		       "ASSERTION FAILED (%s) at: %s:%d:%s()\n",	\
+			#expr, __FILE__, __LINE__, __FUNCTION__);	\
+		}							\
 	} while (0)
 # define BCM43xx_DEBUG	1
 #else
@@ -453,31 +452,6 @@ # define assert(expr)	do { /* nothing */
 # define BCM43xx_DEBUG	0
 #endif
 
-/* rate limited printk(). */
-#ifdef printkl
-# undef printkl
-#endif
-#define printkl(f, x...)  do { if (printk_ratelimit()) printk(f ,##x); } while (0)
-/* rate limited printk() for debugging */
-#ifdef dprintkl
-# undef dprintkl
-#endif
-#ifdef CONFIG_BCM43XX_MAC80211_DEBUG
-# define dprintkl		printkl
-#else
-# define dprintkl(f, x...)	do { /* nothing */ } while (0)
-#endif
-
-/* debugging printk() */
-#ifdef dprintk
-# undef dprintk
-#endif
-#ifdef CONFIG_BCM43XX_MAC80211_DEBUG
-# define dprintk(f, x...)  do { printk(f ,##x); } while (0)
-#else
-# define dprintk(f, x...)  do { /* nothing */ } while (0)
-#endif
-
 
 struct net_device;
 struct pci_dev;
@@ -499,7 +473,7 @@ struct bcm43xx_phy {
 	/* Possible PHYMODEs on this PHY */
 	u8 possible_phymodes;
 	/* GMODE bit enabled? */
-	u8 gmode;
+	bool gmode;
 	/* Possible ieee80211 subsystem hwmodes for this PHY.
 	 * Which mode is selected, depends on thr GMODE enabled bit */
 #define BCM43xx_MAX_PHYHWMODES	2
@@ -517,14 +491,14 @@ #define BCM43xx_MAX_PHYHWMODES	2
 	u16 radio_ver;		/* Radio version */
 	u8 radio_rev;		/* Radio revision */
 
-	u8 radio_on:1;		/* Radio switched on/off */
-	u8 locked:1;		/* Only used in bcm43xx_phy_{un}lock() */
-	u8 dyn_tssi_tbl:1;	/* tssi2dbm is kmalloc()ed. */
+	bool radio_on;		/* Radio switched on/off */
+	bool locked;		/* Only used in bcm43xx_phy_{un}lock() */
+	bool dyn_tssi_tbl;	/* tssi2dbm is kmalloc()ed. */
 
 	/* ACI (adjacent channel interference) flags. */
-	u8 aci_enable:1;
-	u8 aci_wlan_automatic:1;
-	u8 aci_hw_rssi:1;
+	bool aci_enable;
+	bool aci_wlan_automatic;
+	bool aci_hw_rssi;
 
 	u16 minlowsig[2];
 	u16 minlowsigpos[2];
@@ -561,7 +535,7 @@ #define BCM43xx_MAX_PHYHWMODES	2
 	struct bcm43xx_rfatt rfatt;
 	u8 tx_control; /* BCM43xx_TXCTL_XXX */
 #ifdef CONFIG_BCM43XX_MAC80211_DEBUG
-	u8 manual_txpower_control; /* Manual TX-power control enabled? */
+	bool manual_txpower_control; /* Manual TX-power control enabled? */
 #endif
 
 	/* Current Interference Mitigation mode */
@@ -614,7 +588,7 @@ struct bcm43xx_pio {
 /* Context information for a noise calculation (Link Quality). */
 struct bcm43xx_noise_calculation {
 	u8 channel_at_start;
-	u8 calculation_running:1;
+	bool calculation_running;
 	u8 nr_samples;
 	s8 samples[8][4];
 };
@@ -627,7 +601,7 @@ struct bcm43xx_stats {
 };
 
 struct bcm43xx_key {
-	u8 enabled;
+	bool enabled;
 	u8 algorithm;
 	u8 address[6];
 };
@@ -663,11 +637,11 @@ struct bcm43xx_wl {
 	/* Counter of active monitor interfaces. */
 	int monitor;
 	/* Is the card operating in AP, STA or IBSS mode? */
-	unsigned int operating:1;
+	bool operating;
 	/* Promisc mode active?
 	 * Note that (monitor != 0) implies promisc.
 	 */
-	unsigned int promisc:1;
+	bool promisc;
 	/* Stats about the wireless interface */
 	struct ieee80211_low_level_stats ieee_stats;
 
@@ -698,13 +672,13 @@ struct bcm43xx_firmware {
 
 /* Device (802.11 core) initialization status. */
 enum {
-	BCM43xx_STAT_UNINIT,		/* Uninitialized. */
-	BCM43xx_STAT_INITIALIZING,	/* bcm43xx_wireless_core_init() in progress. */
-	BCM43xx_STAT_INITIALIZED,	/* Initialized. Note that this doesn't mean it's started. */
+	BCM43xx_STAT_UNINIT		= 0, /* Uninitialized. */
+	BCM43xx_STAT_INITIALIZED	= 1, /* Initialized, but not started, yet. */
+	BCM43xx_STAT_STARTED		= 2, /* Up and running. */
 };
-#define bcm43xx_status(bcm)		atomic_read(&(bcm)->init_status)
-#define bcm43xx_set_status(bcm, stat)	do {			\
-		atomic_set(&(bcm)->init_status, (stat));	\
+#define bcm43xx_status(wldev)		atomic_read(&(wldev)->__init_status)
+#define bcm43xx_set_status(wldev, stat)	do {			\
+		atomic_set(&(wldev)->__init_status, (stat));	\
 		smp_wmb();					\
 					} while (0)
 
@@ -721,19 +695,18 @@ struct bcm43xx_wldev {
 	struct ssb_device *dev;
 	struct bcm43xx_wl *wl;
 
-	/* Driver initialization status BCM43xx_STAT_*** */
-	atomic_t init_status;
-	/* Interface started? (bcm43xx_wireless_core_start()) */
-	u8 started;
+	/* The device initialization status.
+	 * Use bcm43xx_status() to query. */
+	atomic_t __init_status;
+	/* Saved init status for handling suspend. */
+	int suspend_init_status;
 
-	u16 was_initialized:1,		/* for suspend/resume. */
-	    was_started:1,		/* for suspend/resume. */
-	    __using_pio:1,		/* Internal, use bcm43xx_using_pio(). */
-	    bad_frames_preempt:1,	/* Use "Bad Frames Preemption" (default off) */
-	    reg124_set_0x4:1,		/* Some variable to keep track of IRQ stuff. */
-	    short_preamble:1,		/* TRUE, if short preamble is enabled. */
-	    short_slot:1,		/* TRUE, if short slot timing is enabled. */
-	    radio_hw_enable:1;          /* saved state of radio hardware enabled state */
+	bool __using_pio;		/* Internal, use bcm43xx_using_pio(). */
+	bool bad_frames_preempt;	/* Use "Bad Frames Preemption" (default off) */
+	bool reg124_set_0x4;		/* Some variable to keep track of IRQ stuff. */
+	bool short_preamble;		/* TRUE, if short preamble is enabled. */
+	bool short_slot;		/* TRUE, if short slot timing is enabled. */
+	bool radio_hw_enable;		/* saved state of radio hardware enabled state */
 
 	/* PHY/Radio device. */
 	struct bcm43xx_phy phy;
@@ -863,6 +836,22 @@ void bcm43xx_write32(struct bcm43xx_wlde
 	ssb_write32(dev->dev, offset, value);
 }
 
+
+/* Message printing */
+void bcminfo(struct bcm43xx_wl *wl, const char *fmt, ...)
+		__attribute__((format(printf, 2, 3)));
+void bcmerr(struct bcm43xx_wl *wl, const char *fmt, ...)
+		__attribute__((format(printf, 2, 3)));
+void bcmwarn(struct bcm43xx_wl *wl, const char *fmt, ...)
+		__attribute__((format(printf, 2, 3)));
+#if BCM43xx_DEBUG
+void bcmdbg(struct bcm43xx_wl *wl, const char *fmt, ...)
+		__attribute__((format(printf, 2, 3)));
+#else /* DEBUG */
+# define bcmdbg(wl, fmt...) do { /* nothing */ } while (0)
+#endif /* DEBUG */
+
+
 /** Limit a value between two limits */
 #ifdef limit_value
 # undef limit_value
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
index 3ea9d08..9ca4625 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.c
@@ -92,7 +92,7 @@ static ssize_t tsf_read_file(struct file
 	mutex_lock(&big_buffer_mutex);
 	mutex_lock(&dev->wl->mutex);
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
 		fappend("Board not initialized.\n");
 		goto out;
 	}
@@ -128,13 +128,13 @@ static ssize_t tsf_write_file(struct fil
 	}
 	mutex_lock(&dev->wl->mutex);
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
-		printk(KERN_INFO PFX "debugfs: Board not initialized.\n");
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
+		bcmerr(dev->wl, "debugfs: Board not initialized.\n");
 		res = -EFAULT;
 		goto out_unlock;
 	}
 	if (sscanf(buf, "%llu", (unsigned long long *)(&tsf)) != 1) {
-		printk(KERN_INFO PFX "debugfs: invalid values for \"tsf\"\n");
+		bcmerr(dev->wl, "debugfs: invalid values for \"tsf\"\n");
 		res = -EINVAL;
 		goto out_unlock;
 	}
@@ -234,8 +234,8 @@ static ssize_t restart_write_file(struct
 	}
 	mutex_lock(&dev->wl->mutex);
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
-		printk(KERN_INFO PFX "debugfs: Board not initialized.\n");
+	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED) {
+		bcmerr(dev->wl, "debugfs: Board not initialized.\n");
 		res = -EFAULT;
 		goto out_unlock;
 	}
@@ -267,8 +267,7 @@ static ssize_t txpower_g_read_file(struc
 	mutex_lock(&big_buffer_mutex);
 	mutex_lock(&dev->wl->mutex);
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if ((bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) ||
-	    !dev->started) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
 		fappend("Not initialized\n");
 		goto out;
 	}
@@ -322,14 +321,13 @@ static ssize_t txpower_g_write_file(stru
 	}
 	mutex_lock(&dev->wl->mutex);
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if ((bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) ||
-	    !dev->started) {
-		printk(KERN_INFO PFX "debugfs: Board not initialized.\n");
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
+		bcmerr(dev->wl, "debugfs: Board not initialized.\n");
 		res = -ENODEV;
 		goto out_unlock;
 	}
 	if (dev->phy.type != BCM43xx_PHYTYPE_G) {
-		printk(KERN_ERR PFX "debugfs: Device is not a G-PHY\n");
+		bcmerr(dev->wl, "debugfs: Device is not a G-PHY\n");
 		res = -ENODEV;
 		goto out_unlock;
 	}
@@ -342,7 +340,7 @@ static ssize_t txpower_g_write_file(stru
 		/* Manual control */
 		if (sscanf(buf, "%d %d %d %d %d", &bbatt, &rfatt,
 			   &txmix, &pa2db, &pa3db) != 5) {
-			printk(KERN_INFO PFX "debugfs: invalid value for \"tx_power_g\"\n");
+			bcmerr(dev->wl, "debugfs: invalid value for \"tx_power_g\"\n");
 			res = -EINVAL;
 			goto out_unlock;
 		}
@@ -437,6 +435,7 @@ #define add_dyn_dbg(name, id, initstate)
 
 	add_dyn_dbg("debug_xmitpower", BCM43xx_DBG_XMITPOWER, 0);
 	add_dyn_dbg("debug_dmaoverflow", BCM43xx_DBG_DMAOVERFLOW, 0);
+	add_dyn_dbg("debug_dmaverbose", BCM43xx_DBG_DMAVERBOSE, 0);
 	add_dyn_dbg("debug_pwork_fast", BCM43xx_DBG_PWORK_FAST, 0);
 	add_dyn_dbg("debug_pwork_stop", BCM43xx_DBG_PWORK_STOP, 0);
 
@@ -452,7 +451,7 @@ void bcm43xx_debugfs_add_device(struct b
 	assert(dev);
 	e = kzalloc(sizeof(*e), GFP_KERNEL);
 	if (!e) {
-		printk(KERN_ERR PFX "debugfs: add device OOM\n");
+		bcmerr(dev->wl, "debugfs: add device OOM\n");
 		return;
 	}
 	e->dev = dev;
@@ -461,7 +460,7 @@ void bcm43xx_debugfs_add_device(struct b
 			   sizeof(struct bcm43xx_txstatus),
 			   GFP_KERNEL);
 	if (!log->log) {
-		printk(KERN_ERR PFX "debugfs: add device txstatus OOM\n");
+		bcmerr(dev->wl, "debugfs: add device txstatus OOM\n");
 		kfree(e);
 		return;
 	}
@@ -557,57 +556,3 @@ void bcm43xx_debugfs_exit(void)
 	debugfs_remove(fs.dentry_driverinfo);
 	debugfs_remove(fs.root);
 }
-
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description)
-{
-	unsigned int i;
-	char c;
-
-	printk(KERN_INFO PFX "Data dump (%s, %lu bytes):",
-	       description, (unsigned long)size);
-	for (i = 0; i < size; i++) {
-		c = data[i];
-		if (i % 8 == 0)
-			printk("\n" KERN_INFO PFX "0x%08x:  0x%02x, ", i, c & 0xff);
-		else
-			printk("0x%02x, ", c & 0xff);
-	}
-	printk("\n");
-}
-
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description)
-{
-	unsigned int i;
-	int j;
-	const unsigned char *d;
-
-	printk(KERN_INFO PFX "*** Bitdump (%s, %lu bytes, %s) ***",
-	       description, (unsigned long)bytes,
-	       msb_to_lsb ? "MSB to LSB" : "LSB to MSB");
-	for (i = 0; i < bytes; i++) {
-		d = data + i;
-		if (i % 8 == 0)
-			printk("\n" KERN_INFO PFX "0x%08x:  ", i);
-		if (msb_to_lsb) {
-			for (j = 7; j >= 0; j--) {
-				if (*d & (1 << j))
-					printk("1");
-				else
-					printk("0");
-			}
-		} else {
-			for (j = 0; j < 8; j++) {
-				if (*d & (1 << j))
-					printk("1");
-				else
-					printk("0");
-			}
-		}
-		printk(" ");
-	}
-	printk("\n");
-}
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
index 892299d..65f6b1f 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_debugfs.h
@@ -7,6 +7,7 @@ struct bcm43xx_txstatus;
 enum bcm43xx_dyndbg { /* Dynamic debugging features */
 	BCM43xx_DBG_XMITPOWER,
 	BCM43xx_DBG_DMAOVERFLOW,
+	BCM43xx_DBG_DMAVERBOSE,
 	BCM43xx_DBG_PWORK_FAST,
 	BCM43xx_DBG_PWORK_STOP,
 	__BCM43xx_NR_DYNDBG,
@@ -59,22 +60,6 @@ void bcm43xx_debugfs_remove_device(struc
 void bcm43xx_debugfs_log_txstat(struct bcm43xx_wldev *dev,
 				const struct bcm43xx_txstatus *status);
 
-/* Debug helper: Dump binary data through printk. */
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description);
-/* Debug helper: Dump bitwise binary data through printk. */
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description);
-#define bcm43xx_printk_bitdumpt(pointer, msb_to_lsb, description) \
-	do {									\
-		bcm43xx_printk_bitdump((const unsigned char *)(pointer),	\
-				       sizeof(*(pointer)),			\
-				       (msb_to_lsb),				\
-				       (description));				\
-	} while (0)
-
 #else /* CONFIG_BCM43XX_MAC80211_DEBUG*/
 
 static inline
@@ -95,20 +80,6 @@ static inline
 void bcm43xx_debugfs_log_txstat(struct bcm43xx_wldev *dev,
 				const struct bcm43xx_txstatus *status) { }
 
-static inline
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description)
-{
-}
-static inline
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description)
-{
-}
-#define bcm43xx_printk_bitdumpt(pointer, msb_to_lsb, description)  do { /* nothing */ } while (0)
-
 #endif /* CONFIG_BCM43XX_MAC80211_DEBUG*/
 
 /* Ugly helper macros to make incomplete code more verbose on runtime */
@@ -116,18 +87,18 @@ #ifdef TODO
 # undef TODO
 #endif
 #define TODO()  \
-	do {										\
-		printk(KERN_INFO PFX "TODO: Incomplete code in %s() at %s:%d\n",	\
-		       __FUNCTION__, __FILE__, __LINE__);				\
+	do {									\
+		bcminfo(NULL, "TODO: Incomplete code in %s() at %s:%d\n",	\
+			__FUNCTION__, __FILE__, __LINE__);			\
 	} while (0)
 
 #ifdef FIXME
 # undef FIXME
 #endif
 #define FIXME()  \
-	do {										\
-		printk(KERN_INFO PFX "FIXME: Possibly broken code in %s() at %s:%d\n",	\
-		       __FUNCTION__, __FILE__, __LINE__);				\
+	do {									\
+		bcminfo(NULL, "FIXME: Possibly broken code in %s() at %s:%d\n",	\
+			__FUNCTION__, __FILE__, __LINE__);			\
 	} while (0)
 
 #endif /* BCM43xx_DEBUGFS_H_ */
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
index c8b5cdd..5476250 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.c
@@ -259,6 +259,28 @@ static inline int prev_slot(struct bcm43
 	return slot - 1;
 }
 
+#ifdef CONFIG_BCM43XX_MAC80211_DEBUG
+static void update_max_used_slots(struct bcm43xx_dmaring *ring,
+				  int current_used_slots)
+{
+	if (current_used_slots <= ring->max_used_slots)
+		return;
+	ring->max_used_slots = current_used_slots;
+	if (bcm43xx_debug(ring->dev, BCM43xx_DBG_DMAVERBOSE)) {
+		bcmdbg(ring->dev->wl,
+		       "max_used_slots increased to %d on %s ring %d\n",
+		       ring->max_used_slots,
+		       ring->tx ? "TX" : "RX",
+		       ring->index);
+	}
+}
+#else
+static inline
+void update_max_used_slots(struct bcm43xx_dmaring *ring,
+			   int current_used_slots)
+{ }
+#endif /* DEBUG */
+
 /* Request a slot for usage. */
 static inline
 int request_slot(struct bcm43xx_dmaring *ring)
@@ -273,23 +295,11 @@ int request_slot(struct bcm43xx_dmaring 
 	ring->current_slot = slot;
 	ring->used_slots++;
 
-#ifdef CONFIG_BCM43XX_MAC80211_DEBUG
-	if (ring->used_slots > ring->max_used_slots)
-		ring->max_used_slots = ring->used_slots;
-#endif /* CONFIG_BCM43XX_MAC80211_DEBUG*/
+	update_max_used_slots(ring, ring->used_slots);
 
 	return slot;
 }
 
-/* Return a slot to the free slots. */
-static inline
-void return_slot(struct bcm43xx_dmaring *ring, int slot)
-{
-	assert(ring->tx);
-
-	ring->used_slots--;
-}
-
 /* Mac80211-queue to bcm43xx-ring mapping */
 static struct bcm43xx_dmaring * priority_to_txring(struct bcm43xx_wldev *dev,
 						   int queue_priority)
@@ -450,7 +460,7 @@ static int alloc_ringmemory(struct bcm43
 	ring->descbase = dma_alloc_coherent(dev, BCM43xx_DMA_RINGMEMSIZE,
 					    &(ring->dmabase), GFP_KERNEL);
 	if (!ring->descbase) {
-		printk(KERN_ERR PFX "DMA ringmemory allocation failed\n");
+		bcmerr(ring->dev->wl, "DMA ringmemory allocation failed\n");
 		return -ENOMEM;
 	}
 	memset(ring->descbase, 0, BCM43xx_DMA_RINGMEMSIZE);
@@ -497,7 +507,7 @@ int bcm43xx_dmacontroller_rx_reset(struc
 		msleep(1);
 	}
 	if (i != -1) {
-		printk(KERN_ERR PFX "ERROR: DMA RX reset timed out\n");
+		bcmerr(dev->wl, "DMA RX reset timed out\n");
 		return -ENODEV;
 	}
 
@@ -553,7 +563,7 @@ int bcm43xx_dmacontroller_tx_reset(struc
 		msleep(1);
 	}
 	if (i != -1) {
-		printk(KERN_ERR PFX "ERROR: DMA TX reset timed out\n");
+		bcmerr(dev->wl, "DMA TX reset timed out\n");
 		return -ENODEV;
 	}
 	/* ensure the reset is completed. */
@@ -624,7 +634,8 @@ static int alloc_initial_descbuffers(str
 
 		err = setup_rx_descbuffer(ring, desc, meta, GFP_KERNEL);
 		if (err) {
-			printk(KERN_ERR PFX "Failed to allocate initial descbuffers\n");
+			bcmerr(ring->dev->wl,
+			       "Failed to allocate initial descbuffers\n");
 			goto err_unwind;
 		}
 	}
@@ -903,11 +914,11 @@ static void bcm43xx_destroy_dmaring(stru
 	if (!ring)
 		return;
 
-	dprintk(KERN_INFO PFX "DMA-%s 0x%04X (%s) max used slots: %d/%d\n",
-		(ring->dma64) ? "64" : "32",
-		ring->mmio_base,
-		(ring->tx) ? "TX" : "RX",
-		ring->max_used_slots, ring->nr_slots);
+	bcmdbg(ring->dev->wl, "DMA-%s 0x%04X (%s) max used slots: %d/%d\n",
+	       (ring->dma64) ? "64" : "32",
+	       ring->mmio_base,
+	       (ring->tx) ? "TX" : "RX",
+	       ring->max_used_slots, ring->nr_slots);
 	/* Device IRQs are disabled prior entering this function,
 	 * so no need to take care of concurrency with rx handler stuff.
 	 */
@@ -962,13 +973,13 @@ int bcm43xx_dma_init(struct bcm43xx_wlde
 	err = ssb_dma_set_mask(dev->dev, dmamask);
 	if (err) {
 #ifdef BCM43XX_MAC80211_PIO
-		printk(KERN_WARNING PFX "DMA for this device not supported. "
-					"Falling back to PIO\n");
+		bcmwarn(dev->wl, "DMA for this device not supported. "
+			"Falling back to PIO\n");
 		dev->__using_pio = 1;
 		return -EAGAIN;
 #else
-		printk(KERN_ERR PFX "DMA for this device not supported and "
-				    "no PIO support compiled in\n");
+		bcmerr(dev->wl, "DMA for this device not supported and "
+		       "no PIO support compiled in\n");
 		return -EOPNOTSUPP;
 #endif
 	}
@@ -1018,9 +1029,9 @@ #endif
 		dma->rx_ring3 = ring;
 	}
 
-	dprintk(KERN_INFO PFX "%d-bit DMA initialized\n",
-		(dmamask == DMA_64BIT_MASK) ? 64 :
-		(dmamask == DMA_32BIT_MASK) ? 32 : 30);
+	bcmdbg(dev->wl, "%d-bit DMA initialized\n",
+	       (dmamask == DMA_64BIT_MASK) ? 64 :
+	       (dmamask == DMA_32BIT_MASK) ? 32 : 30);
 	err = 0;
 out:
 	return err;
@@ -1213,8 +1224,9 @@ #ifdef CONFIG_BCM43XX_MAC80211_DEBUG
 		next_overflow = ring->last_injected_overflow + HZ;
 		if (time_after(jiffies, next_overflow)) {
 			ring->last_injected_overflow = jiffies;
-			dprintk(KERN_DEBUG PFX "Injecting TX ring overflow on "
-				"DMA controller %d\n", ring->index);
+			bcmdbg(ring->dev->wl,
+			       "Injecting TX ring overflow on "
+			       "DMA controller %d\n", ring->index);
 			return 1;
 		}
 	}
@@ -1234,7 +1246,7 @@ int bcm43xx_dma_tx(struct bcm43xx_wldev 
 	spin_lock_irqsave(&ring->lock, flags);
 	assert(ring->tx);
 	if (unlikely(free_slots(ring) < SLOTS_PER_PACKET)) {
-		printkl(KERN_ERR PFX "DMA queue overflow\n");
+		bcmwarn(dev->wl, "DMA queue overflow\n");
 		err = -ENOSPC;
 		goto out_unlock;
 	}
@@ -1245,7 +1257,7 @@ int bcm43xx_dma_tx(struct bcm43xx_wldev 
 
 	err = dma_tx_fragment(ring, skb, ctl);
 	if (unlikely(err)) {
-		printkl(KERN_ERR PFX "DMA tx mapping failure\n");
+		bcmerr(dev->wl, "DMA tx mapping failure\n");
 		goto out_unlock;
 	}
 	ring->nr_tx_packets++;
@@ -1254,6 +1266,10 @@ int bcm43xx_dma_tx(struct bcm43xx_wldev 
 		/* This TX ring is full. */
 		ieee80211_stop_queue(dev->wl->hw, txring_to_priority(ring));
 		ring->stopped = 1;
+		if (bcm43xx_debug(dev, BCM43xx_DBG_DMAVERBOSE)) {
+			bcmdbg(dev->wl, "Stopped TX ring %d\n",
+			       ring->index);
+		}
 	}
 out_unlock:
 	spin_unlock_irqrestore(&ring->lock, flags);
@@ -1305,10 +1321,9 @@ void bcm43xx_dma_handle_txstatus(struct 
 			 */
 			assert(meta->skb == NULL);
 		}
-		/* Everything belonging to the slot is unmapped
-		 * and freed, so we can return it.
-		 */
-		return_slot(ring, slot);
+
+		/* Everything unmapped and free'd. So it's not used anymore. */
+		ring->used_slots--;
 
 		if (meta->is_last_fragment)
 			break;
@@ -1319,6 +1334,10 @@ void bcm43xx_dma_handle_txstatus(struct 
 		assert(free_slots(ring) >= SLOTS_PER_PACKET);
 		ieee80211_wake_queue(dev->wl->hw, txring_to_priority(ring));
 		ring->stopped = 0;
+		if (bcm43xx_debug(dev, BCM43xx_DBG_DMAVERBOSE)) {
+			bcmdbg(dev->wl, "Woke up TX ring %d\n",
+			       ring->index);
+		}
 	}
 
 	spin_unlock(&ring->lock);
@@ -1417,16 +1436,16 @@ static void dma_rx(struct bcm43xx_dmarin
 			if (tmp <= 0)
 				break;
 		}
-		printkl(KERN_ERR PFX "DMA RX buffer too small "
-			"(len: %u, buffer: %u, nr-dropped: %d)\n",
-			len, ring->rx_buffersize, cnt);
+		bcmerr(ring->dev->wl, "DMA RX buffer too small "
+		       "(len: %u, buffer: %u, nr-dropped: %d)\n",
+		       len, ring->rx_buffersize, cnt);
 		goto drop;
 	}
 
 	dmaaddr = meta->dmaaddr;
 	err = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);
 	if (unlikely(err)) {
-		dprintkl(KERN_ERR PFX "DMA RX: setup_rx_descbuffer() failed\n");
+		bcmdbg(ring->dev->wl, "DMA RX: setup_rx_descbuffer() failed\n");
 		sync_descbuffer_for_device(ring, dmaaddr,
 					   ring->rx_buffersize);
 		goto drop;
@@ -1445,9 +1464,7 @@ void bcm43xx_dma_rx(struct bcm43xx_dmari
 {
 	const struct bcm43xx_dma_ops *ops = ring->ops;
 	int slot, current_slot;
-#ifdef CONFIG_BCM43XX_MAC80211_DEBUG
 	int used_slots = 0;
-#endif
 
 	assert(!ring->tx);
 	current_slot = ops->get_current_rxslot(ring);
@@ -1456,10 +1473,7 @@ #endif
 	slot = ring->current_slot;
 	for ( ; slot != current_slot; slot = next_slot(ring, slot)) {
 		dma_rx(ring, &slot);
-#ifdef CONFIG_BCM43XX_MAC80211_DEBUG
-		if (++used_slots > ring->max_used_slots)
-			ring->max_used_slots = used_slots;
-#endif
+		update_max_used_slots(ring, ++used_slots);
 	}
 	ops->set_current_rxslot(ring, slot);
 	ring->current_slot = slot;
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.h b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.h
index 3d109b1..baabeed 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.h
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_dma.h
@@ -194,7 +194,7 @@ struct bcm43xx_dmadesc_meta {
 	/* DMA base bus-address of the descriptor buffer. */
 	dma_addr_t dmaaddr;
 	/* ieee80211 TX status. Only used once per 802.11 frag. */
-	u8 is_last_fragment;
+	bool is_last_fragment;
 	struct ieee80211_tx_status txstat;
 };
 
@@ -247,11 +247,11 @@ struct bcm43xx_dmaring {
 	/* DMA controller index number (0-5). */
 	int index;
 	/* Boolean. Is this a TX ring? */
-	u8 tx;
+	bool tx;
 	/* Boolean. 64bit DMA if true, 32bit DMA otherwise. */
-	u8 dma64;
+	bool dma64;
 	/* Boolean. Is this ring stopped at ieee80211 level? */
-	u8 stopped;
+	bool stopped;
 	/* Lock, only used for TX. */
 	spinlock_t lock;
 	struct bcm43xx_wldev *dev;
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.c
index aa1a298..b405779 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.c
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.c
@@ -47,8 +47,8 @@ static void bcm43xx_lo_write(struct bcm4
 	if (BCM43xx_DEBUG) {
 		if (unlikely(abs(control->i) > 16 ||
 			     abs(control->q) > 16)) {
-			printk(KERN_ERR PFX "ERROR: Invalid LO control pair "
-					    "(I: %d, Q: %d)\n",
+			bcmdbg(dev->wl, "Invalid LO control pair "
+			       "(I: %d, Q: %d)\n",
 			       control->i, control->q);
 			dump_stack();
 			return;
@@ -64,22 +64,21 @@ static void bcm43xx_lo_write(struct bcm4
 
 static inline
 int assert_rfatt_and_bbatt(const struct bcm43xx_rfatt *rfatt,
-			   const struct bcm43xx_bbatt *bbatt)
+			   const struct bcm43xx_bbatt *bbatt,
+			   struct bcm43xx_wldev *dev)
 {
 	int err = 0;
 
 	/* Check the attenuation values against the LO control array sizes. */
 #if BCM43xx_DEBUG
 	if (rfatt->att >= BCM43xx_NR_RF) {
-		dprintk(KERN_ERR PFX
-			"ERROR: rfatt(%u) >= size of LO array\n",
-			rfatt->att);
+		bcmdbg(dev->wl, "rfatt(%u) >= size of LO array\n",
+		       rfatt->att);
 		err = -EINVAL;
 	}
 	if (bbatt->att >= BCM43xx_NR_BB) {
-		dprintk(KERN_ERR PFX
-			"ERROR: bbatt(%u) >= size of LO array\n",
-			bbatt->att);
+		bcmdbg(dev->wl, "bbatt(%u) >= size of LO array\n",
+		       bbatt->att);
 		err = -EINVAL;
 	}
 	if (err)
@@ -97,7 +96,7 @@ struct bcm43xx_loctl * bcm43xx_get_lo_g_
 	struct bcm43xx_phy *phy = &dev->phy;
 	struct bcm43xx_txpower_lo_control *lo = phy->lo_control;
 
-	if (assert_rfatt_and_bbatt(rfatt, bbatt))
+	if (assert_rfatt_and_bbatt(rfatt, bbatt, dev))
 		return &(lo->no_padmix[0][0]); /* Just prevent a crash */
 	return &(lo->no_padmix[bbatt->att][rfatt->att]);
 }
@@ -109,7 +108,7 @@ struct bcm43xx_loctl * bcm43xx_get_lo_g_
 	struct bcm43xx_phy *phy = &dev->phy;
 	struct bcm43xx_txpower_lo_control *lo = phy->lo_control;
 
-	if (assert_rfatt_and_bbatt(rfatt, bbatt))
+	if (assert_rfatt_and_bbatt(rfatt, bbatt, dev))
 		return &(lo->no_padmix[0][0]); /* Just prevent a crash */
 	if (rfatt->with_padmix)
 		return &(lo->with_padmix[bbatt->att][rfatt->att]);
@@ -1013,13 +1012,13 @@ #if BCM43xx_DEBUG
 static void do_validate_loctl(struct bcm43xx_wldev *dev,
 			      struct bcm43xx_loctl *control)
 {
-	const int is_initializing = (bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZING);
+	const int is_initializing = (bcm43xx_status(dev) == BCM43xx_STAT_UNINIT);
 
 	if (unlikely(abs(control->i) > 16 ||
 		     abs(control->q) > 16 ||
 		     (is_initializing && control->used))) {
-		printk(KERN_ERR PFX "ERROR: LO control pair validation failed "
-				    "(first: %d, second: %d, used %u)\n",
+		bcmdbg(dev->wl, "ERROR: LO control pair validation failed "
+		       "(first: %d, second: %d, used %u)\n",
 		       control->i, control->q, control->used);
 	}
 }
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.h b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.h
index 71fbe3e..377bda4 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.h
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_lo.h
@@ -35,7 +35,7 @@ #define BCM43xx_NR_RF	16
 
 	/* Flag to indicate a complete rebuild of the two tables above
 	 * to the LO measuring code. */
-	u8 rebuild;
+	bool rebuild;
 
 	/* Lists of valid RF and BB attenuation values for this device. */
 	struct bcm43xx_rfatt_list rfatt_list;
@@ -47,7 +47,7 @@ #define BCM43xx_NR_RF	16
 	u8 tx_magn;
 
 	/* GPHY LO is measured. */
-	u8 lo_measured;
+	bool lo_measured;
 
 	/* Saved device PowerVector */
 	u64 power_vector;
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
index eefc536..7a9dd02 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -194,6 +194,69 @@ static void bcm43xx_wireless_core_stop(s
 static int bcm43xx_wireless_core_start(struct bcm43xx_wldev *dev);
 
 
+static int bcm43xx_ratelimit(struct bcm43xx_wl *wl)
+{
+	if (!wl || !wl->current_dev)
+		return 1;
+	if (bcm43xx_status(wl->current_dev) < BCM43xx_STAT_STARTED)
+		return 1;
+	/* We are up and running.
+	 * Ratelimit the messages to avoid DoS over the net. */
+	return net_ratelimit();
+}
+
+void bcminfo(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
+
+	if (!bcm43xx_ratelimit(wl))
+		return;
+	va_start(args, fmt);
+	printk(KERN_INFO "bcm43xx-%s: ",
+	       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : "wlan");
+	vprintk(fmt, args);
+	va_end(args);
+}
+
+void bcmerr(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
+
+	if (!bcm43xx_ratelimit(wl))
+		return;
+	va_start(args, fmt);
+	printk(KERN_ERR "bcm43xx-%s ERROR: ",
+	       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : "wlan");
+	vprintk(fmt, args);
+	va_end(args);
+}
+
+void bcmwarn(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
+
+	if (!bcm43xx_ratelimit(wl))
+		return;
+	va_start(args, fmt);
+	printk(KERN_WARNING "bcm43xx-%s warning: ",
+	       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : "wlan");
+	vprintk(fmt, args);
+	va_end(args);
+}
+
+#if BCM43xx_DEBUG
+void bcmdbg(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	printk(KERN_DEBUG "bcm43xx-%s debug: ",
+	       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : "wlan");
+	vprintk(fmt, args);
+	va_end(args);
+}
+#endif /* DEBUG */
+
 static void bcm43xx_ram_write(struct bcm43xx_wldev *dev, u16 offset, u32 val)
 {
 	u32 status;
@@ -772,7 +835,7 @@ static int bcm43xx_key_write(struct bcm4
 			}
 		}
 		if (index < 0) {
-			dprintk(KERN_ERR PFX "Out of hw key memory\n");
+			bcmerr(dev->wl, "Out of hardware key memory\n");
 			return -ENOBUFS;
 		}
 	} else
@@ -1080,21 +1143,13 @@ static void bcm43xx_write_probe_resp_plc
 {
 	struct bcm43xx_plcp_hdr4 plcp;
 	u32 tmp;
-	u16 packet_time;
+	__le16 dur;
 
 	plcp.data = 0;
 	bcm43xx_generate_plcp_hdr(&plcp, size + FCS_LEN, rate);
-	/*
-	 * 144 + 48 + 10 = preamble + PLCP + SIFS,
-	 * taken from mac80211 timings calculation.
-	 *
-	 * FIXME: long preamble assumed!
-	 *
-	 */
-	packet_time = 202 + (size + FCS_LEN) * 16 / rate;
-	if ((size + FCS_LEN) * 16 % rate >= rate / 2)
-		++packet_time;
-
+	dur = ieee80211_generic_frame_duration(dev->wl->hw,
+					       dev->wl->if_id, size,
+					       BCM43xx_RATE_TO_BASE100KBPS(rate));
 	/* Write PLCP in two parts and timing for packet transfer */
 	tmp = le32_to_cpu(plcp.data);
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, shm_offset,
@@ -1102,7 +1157,7 @@ static void bcm43xx_write_probe_resp_plc
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, shm_offset + 2,
 			    tmp >> 16);
 	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, shm_offset + 6,
-			    packet_time);
+			    le16_to_cpu(dur));
 }
 
 /* Instead of using custom probe response template, this function
@@ -1116,15 +1171,17 @@ static u8 * bcm43xx_generate_probe_resp(
 {
 	const u8 *src_data;
 	u8 *dest_data;
-	u16 src_size, elem_size, src_pos, dest_pos, tmp;
+	u16 src_size, elem_size, src_pos, dest_pos;
+	__le16 dur;
+	struct ieee80211_hdr *hdr;
 
 	assert(dev->cached_beacon);
 	src_size = dev->cached_beacon->len;
 	src_data = (const u8*)dev->cached_beacon->data;
 
 	if (unlikely(src_size < 0x24)) {
-		dprintk(KERN_ERR PFX "bcm43xx_generate_probe_resp: "
-				     "invalid beacon\n");
+		bcmdbg(dev->wl, "bcm43xx_generate_probe_resp: "
+		       "invalid beacon\n");
 		return NULL;
 	}
 
@@ -1146,26 +1203,15 @@ static u8 * bcm43xx_generate_probe_resp(
 		}
 	}
 	*dest_size = dest_pos;
+	hdr = (struct ieee80211_hdr *)dest_data;
 
 	/* Set the frame control. */
-	dest_data[0] = (IEEE80211_FTYPE_MGMT |
-			IEEE80211_STYPE_PROBE_RESP);
-	dest_data[1] = 0;
-
-	/* Set the duration field.
-	 *
-	 * 144 + 48 + 10 = preamble + PLCP + SIFS,
-	 * taken from mac80211 timings calculation.
-	 *
-	 * FIXME: long preamble assumed!
-	 *
-	 */
-	tmp = 202 + (14 + FCS_LEN) * 16 / rate;
-	if ((14 + FCS_LEN) * 16 % rate >= rate / 2)
-		++tmp;
-
-	dest_data[2] = tmp & 0xFF;
-	dest_data[3] = (tmp >> 8) & 0xFF;
+	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					 IEEE80211_STYPE_PROBE_RESP);
+	dur = ieee80211_generic_frame_duration(dev->wl->hw,
+					       dev->wl->if_id, *dest_size,
+					       BCM43xx_RATE_TO_BASE100KBPS(rate));
+	hdr->duration_id = dur;
 
 	return dest_data;
 }
@@ -1328,8 +1374,7 @@ static void bcm43xx_interrupt_tasklet(st
 
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
 
-	assert(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED);
-	assert(dev->started);
+	assert(bcm43xx_status(dev) == BCM43xx_STAT_STARTED);
 
 	reason = dev->irq_reason;
 	for (i = 0; i < ARRAY_SIZE(dma_reason); i++) {
@@ -1338,32 +1383,32 @@ static void bcm43xx_interrupt_tasklet(st
 	}
 
 	if (unlikely(reason & BCM43xx_IRQ_MAC_TXERR))
-		printkl(KERN_ERR PFX "MAC transmission error\n");
+		bcmerr(dev->wl, "MAC transmission error\n");
 
 	if (unlikely(reason & BCM43xx_IRQ_PHY_TXERR))
-		printkl(KERN_ERR PFX "PHY transmission error\n");
+		bcmerr(dev->wl, "PHY transmission error\n");
 
 	if (unlikely(merged_dma_reason & (BCM43xx_DMAIRQ_FATALMASK |
 					  BCM43xx_DMAIRQ_NONFATALMASK))) {
 		if (merged_dma_reason & BCM43xx_DMAIRQ_FATALMASK) {
-			printkl(KERN_ERR PFX "FATAL ERROR: Fatal DMA error: "
-					     "0x%08X, 0x%08X, 0x%08X, "
-					     "0x%08X, 0x%08X, 0x%08X\n",
-			        dma_reason[0], dma_reason[1],
-				dma_reason[2], dma_reason[3],
-				dma_reason[4], dma_reason[5]);
+			bcmerr(dev->wl, "Fatal DMA error: "
+			       "0x%08X, 0x%08X, 0x%08X, "
+			       "0x%08X, 0x%08X, 0x%08X\n",
+			       dma_reason[0], dma_reason[1],
+			       dma_reason[2], dma_reason[3],
+			       dma_reason[4], dma_reason[5]);
 			bcm43xx_controller_restart(dev, "DMA error");
 			mmiowb();
 			spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
 			return;
 		}
 		if (merged_dma_reason & BCM43xx_DMAIRQ_NONFATALMASK) {
-			printkl(KERN_ERR PFX "DMA error: "
-					     "0x%08X, 0x%08X, 0x%08X, "
-					     "0x%08X, 0x%08X, 0x%08X\n",
-			        dma_reason[0], dma_reason[1],
-				dma_reason[2], dma_reason[3],
-				dma_reason[4], dma_reason[5]);
+			bcmerr(dev->wl, "DMA error: "
+			       "0x%08X, 0x%08X, 0x%08X, "
+			       "0x%08X, 0x%08X, 0x%08X\n",
+			       dma_reason[0], dma_reason[1],
+			       dma_reason[2], dma_reason[3],
+			       dma_reason[4], dma_reason[5]);
 		}
 	}
 
@@ -1458,7 +1503,7 @@ static void bcm43xx_interrupt_ack(struct
 /* Interrupt handler top-half */
 static irqreturn_t bcm43xx_interrupt_handler(int irq, void *dev_id)
 {
-	irqreturn_t ret = IRQ_HANDLED;
+	irqreturn_t ret = IRQ_NONE;
 	struct bcm43xx_wldev *dev = dev_id;
 	u32 reason;
 
@@ -1467,18 +1512,17 @@ static irqreturn_t bcm43xx_interrupt_han
 
 	spin_lock(&dev->wl->irq_lock);
 
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED)
+		goto out;
 	reason = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
-	if (reason == 0xffffffff) {
-		/* irq not for us (shared irq) */
-		ret = IRQ_NONE;
+	if (reason == 0xffffffff) /* shared IRQ */
 		goto out;
-	}
+	ret = IRQ_HANDLED;
 	reason &= bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
 	if (!reason)
 		goto out;
 
-	assert(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED);
-	assert(dev->started);
+	assert(bcm43xx_status(dev) == BCM43xx_STAT_STARTED);
 
 	dev->dma_reason[0] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA0_REASON)
 			     & 0x0001DC00;
@@ -1531,9 +1575,8 @@ static int bcm43xx_request_firmware(stru
 			 modparam_fwpostfix);
 		err = request_firmware(&dev->fw.ucode, buf, dev->dev->dev);
 		if (err) {
-			printk(KERN_ERR PFX
-			       "Error: Microcode \"%s\" not available or load failed.\n",
-			        buf);
+			bcmerr(dev->wl, "Microcode \"%s\" not "
+			       "available or load failed.\n", buf);
 			goto error;
 		}
 	}
@@ -1545,9 +1588,8 @@ static int bcm43xx_request_firmware(stru
 			 modparam_fwpostfix);
 		err = request_firmware(&dev->fw.pcm, buf, dev->dev->dev);
 		if (err) {
-			printk(KERN_ERR PFX
-			       "Error: PCM \"%s\" not available or load failed.\n",
-			       buf);
+			bcmerr(dev->wl, "PCM \"%s\" not available "
+			       "or load failed.\n", buf);
 			goto error;
 		}
 	}
@@ -1585,13 +1627,12 @@ static int bcm43xx_request_firmware(stru
 
 		err = request_firmware(&dev->fw.initvals0, buf, dev->dev->dev);
 		if (err) {
-			printk(KERN_ERR PFX
-			       "Error: InitVals \"%s\" not available or load failed.\n",
-			        buf);
+			bcmerr(dev->wl, "InitVals \"%s\" not available "
+			       "or load failed.\n", buf);
 			goto error;
 		}
 		if (dev->fw.initvals0->size % sizeof(struct bcm43xx_initval)) {
-			printk(KERN_ERR PFX "InitVals fileformat error.\n");
+			bcmerr(dev->wl, "InitVals fileformat error.\n");
 			goto error;
 		}
 	}
@@ -1620,13 +1661,12 @@ static int bcm43xx_request_firmware(stru
 
 			err = request_firmware(&dev->fw.initvals1, buf, dev->dev->dev);
 			if (err) {
-				printk(KERN_ERR PFX
-				       "Error: InitVals \"%s\" not available or load failed.\n",
-					buf);
+				bcmerr(dev->wl, "InitVals \"%s\" not available "
+				       "or load failed.\n", buf);
 				goto error;
 			}
 			if (dev->fw.initvals1->size % sizeof(struct bcm43xx_initval)) {
-				printk(KERN_ERR PFX "InitVals fileformat error.\n");
+				bcmerr(dev->wl, "InitVals fileformat error.\n");
 				goto error;
 			}
 		}
@@ -1638,7 +1678,7 @@ error:
 	bcm43xx_release_firmware(dev);
 	goto out;
 err_noinitval:
-	printk(KERN_ERR PFX "Error: No InitVals available!\n");
+	bcmerr(dev->wl, "No InitVals available\n");
 	err = -ENOENT;
 	goto error;
 }
@@ -1687,7 +1727,7 @@ static int bcm43xx_upload_microcode(stru
 			break;
 		i++;
 		if (i >= BCM43xx_IRQWAIT_MAX_RETRIES) {
-			printk(KERN_ERR PFX "Microcode not responding\n");
+			bcmerr(dev->wl, "Microcode not responding\n");
 			err = -ENODEV;
 			goto out;
 		}
@@ -1706,15 +1746,15 @@ static int bcm43xx_upload_microcode(stru
 				    BCM43xx_SHM_SH_UCODETIME);
 
 	if (fwrev <= 0x128) {
-		printk(KERN_ERR PFX "YOUR FIRMWARE IS TOO OLD. Firmware from "
+		bcmerr(dev->wl, "YOUR FIRMWARE IS TOO OLD. Firmware from "
 		       "binary drivers older than version 4.x is unsupported. "
 		       "You must upgrade your firmware files.\n");
 		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, 0);
 		err = -EOPNOTSUPP;
 		goto out;
 	}
-	printk(KERN_DEBUG PFX "Loading firmware version %u.%u "
-			      "(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\n",
+	bcmdbg(dev->wl, "Loading firmware version %u.%u "
+	       "(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\n",
 	       fwrev, fwpatch,
 	       (fwdate >> 12) & 0xF, (fwdate >> 8) & 0xF, fwdate & 0xFF,
 	       (fwtime >> 11) & 0x1F, (fwtime >> 5) & 0x3F, fwtime & 0x1F);
@@ -1754,8 +1794,8 @@ static int bcm43xx_write_initvals(struct
 	return 0;
 
 err_format:
-	printk(KERN_ERR PFX "InitVals (bcm43xx_initvalXX.fw) file-format error. "
-			    "Please fix your bcm43xx firmware files.\n");
+	bcmerr(dev->wl, "InitVals (bcm43xx_initvalXX.fw) file-format error. "
+	       "Please fix your bcm43xx firmware files.\n");
 	return -EPROTO;
 }
 
@@ -1882,7 +1922,7 @@ void bcm43xx_mac_suspend(struct bcm43xx_
 				goto out;
 			udelay(1);
 		}
-		printkl(KERN_ERR PFX "MAC suspend failed\n");
+		bcmerr(dev->wl, "MAC suspend failed\n");
 	}
 out:
 	dev->mac_suspended++;
@@ -1928,6 +1968,11 @@ static void bcm43xx_adjust_opmode(struct
 	}
 	if (wl->promisc)
 		ctl |= BCM43xx_MACCTL_PROMISC;
+	/* Workaround: On old hardware the HW-MAC-address-filter
+	 * doesn't work properly, so always run promisc in filter
+	 * it in software. */
+	if (dev->dev->id.revision <= 4)
+		ctl |= BCM43xx_MACCTL_PROMISC;
 
 	bcm43xx_write32(dev, BCM43xx_MMIO_MACCTL, ctl);
 
@@ -2068,8 +2113,8 @@ static int bcm43xx_chip_init(struct bcm4
 		goto err_gpio_cleanup;
 	bcm43xx_radio_turn_on(dev);
 	dev->radio_hw_enable = bcm43xx_is_hw_radio_enabled(dev);
-	dprintk(KERN_INFO PFX "Radio %s by hardware\n",
-		(dev->radio_hw_enable == 0) ? "disabled" : "enabled");
+	bcmdbg(dev->wl, "Radio %s by hardware\n",
+	       (dev->radio_hw_enable == 0) ? "disabled" : "enabled");
 
 	bcm43xx_write16(dev, 0x03E6, 0x0000);
 	err = bcm43xx_phy_init(dev);
@@ -2144,7 +2189,7 @@ static int bcm43xx_chip_init(struct bcm4
 			dev->dev->bus->chipco.fast_pwrup_delay);
 
 	assert(err == 0);
-	dprintk(KERN_INFO PFX "Chip initialized\n");
+	bcmdbg(dev->wl, "Chip initialized\n");
 out:
 	return err;
 
@@ -2222,8 +2267,8 @@ static void bcm43xx_periodic_every1sec(s
 	radio_hw_enable = bcm43xx_is_hw_radio_enabled(dev);
 	if (unlikely(dev->radio_hw_enable != radio_hw_enable)) {
 		dev->radio_hw_enable = radio_hw_enable;
-		dprintk(KERN_INFO PFX "Radio hardware status changed to %s\n",
-			(radio_hw_enable == 0) ? "disabled" : "enabled");
+		bcmdbg(dev->wl, "Radio hardware status changed to %s\n",
+		       (radio_hw_enable == 0) ? "disabled" : "enabled");
 		bcm43xx_leds_update(dev, 0);
 	}
 }
@@ -2275,9 +2320,7 @@ static void bcm43xx_periodic_work_handle
 
 	mutex_lock(&dev->wl->mutex);
 
-	if (unlikely(bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED))
-		goto out;
-	if (unlikely(!dev->started))
+	if (unlikely(bcm43xx_status(dev) != BCM43xx_STAT_STARTED))
 		goto out;
 	if (bcm43xx_debug(dev, BCM43xx_DBG_PWORK_STOP))
 		goto out_requeue;
@@ -2312,9 +2355,10 @@ static void bcm43xx_periodic_work_handle
 	}
 	dev->periodic_state++;
 out_requeue:
-	delay = HZ;
 	if (bcm43xx_debug(dev, BCM43xx_DBG_PWORK_FAST))
 		delay = msecs_to_jiffies(50);
+	else
+		delay = round_jiffies(HZ);
 	queue_delayed_work(dev->wl->hw->workqueue,
 			   &dev->periodic_work, delay);
 out:
@@ -2330,7 +2374,6 @@ static void bcm43xx_periodic_tasks_setup
 {
 	struct delayed_work *work = &dev->periodic_work;
 
-	assert(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED);
 	dev->periodic_state = 0;
 	INIT_DELAYED_WORK(work, bcm43xx_periodic_work_handler);
 	queue_delayed_work(dev->wl->hw->workqueue, work, 0);
@@ -2362,7 +2405,7 @@ static int bcm43xx_validate_chipaccess(s
 
 	return 0;
 error:
-	printk(KERN_ERR PFX "Failed to validate the chipaccess\n");
+	bcmerr(dev->wl, "Failed to validate the chipaccess\n");
 	return -ENODEV;
 }
 
@@ -2419,7 +2462,7 @@ static int bcm43xx_rng_init(struct bcm43
 	err = hwrng_register(&wl->rng);
 	if (err) {
 		wl->rng_initialized = 0;
-		printk(KERN_ERR PFX "Failed to register the random "
+		bcmerr(wl, "Failed to register the random "
 		       "number generator (%d)\n", err);
 	}
 
@@ -2435,11 +2478,11 @@ static int bcm43xx_tx(struct ieee80211_h
 	int err = -ENODEV;
 	unsigned long flags;
 
-	/* DMA-TX is done without a global lock. */
 	if (unlikely(!dev))
 		goto out;
-	assert(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED);
-	assert(dev->started);
+	if (unlikely(bcm43xx_status(dev) < BCM43xx_STAT_STARTED))
+		goto out;
+	/* DMA-TX is done without a global lock. */
 	if (bcm43xx_using_pio(dev)) {
 		spin_lock_irqsave(&wl->irq_lock, flags);
 		err = bcm43xx_pio_tx(dev, skb, ctl);
@@ -2470,7 +2513,7 @@ static int bcm43xx_get_tx_stats(struct i
 	if (!dev)
 		goto out;
 	spin_lock_irqsave(&wl->irq_lock, flags);
-	if (likely(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED)) {
+	if (likely(bcm43xx_status(dev) >= BCM43xx_STAT_STARTED)) {
 		if (bcm43xx_using_pio(dev))
 			bcm43xx_pio_get_tx_stats(dev, stats);
 		else
@@ -2528,7 +2571,7 @@ static const char * phymode_to_string(un
 static int find_wldev_for_phymode(struct bcm43xx_wl *wl,
 				  unsigned int phymode,
 				  struct bcm43xx_wldev **dev,
-				  int *gmode)
+				  bool *gmode)
 {
 	struct bcm43xx_wldev *d;
 
@@ -2569,41 +2612,37 @@ static void bcm43xx_put_phy_into_reset(s
 	msleep(1);
 }
 
+/* Expects wl->mutex locked */
 static int bcm43xx_switch_phymode(struct bcm43xx_wl *wl,
 				  unsigned int new_mode)
 {
 	struct bcm43xx_wldev *up_dev;
 	struct bcm43xx_wldev *down_dev;
 	int err;
-	int gmode = -1;
-	int old_was_started = 0;
-	int old_was_inited = 0;
+	bool gmode = 0;
+	int prev_status;
 
 	err = find_wldev_for_phymode(wl, new_mode, &up_dev, &gmode);
 	if (err) {
-		printk(KERN_INFO PFX "Could not find a device for %s-PHY mode\n",
+		bcmerr(wl, "Could not find a device for %s-PHY mode\n",
 		       phymode_to_string(new_mode));
 		return err;
 	}
-	assert(gmode == 0 || gmode == 1);
 	if ((up_dev == wl->current_dev) &&
-	    (wl->current_dev->phy.gmode == gmode)) {
+	    (!!wl->current_dev->phy.gmode == !!gmode)) {
 		/* This device is already running. */
 		return 0;
 	}
-	dprintk(KERN_INFO PFX "Reconfiguring PHYmode to %s-PHY\n",
-		phymode_to_string(new_mode));
+	bcmdbg(wl, "Reconfiguring PHYmode to %s-PHY\n",
+	       phymode_to_string(new_mode));
 	down_dev = wl->current_dev;
 
+	prev_status = bcm43xx_status(down_dev);
 	/* Shutdown the currently running core. */
-	if (down_dev->started) {
-		old_was_started = 1;
+	if (prev_status >= BCM43xx_STAT_STARTED)
 		bcm43xx_wireless_core_stop(down_dev);
-	}
-	if (bcm43xx_status(down_dev) == BCM43xx_STAT_INITIALIZED) {
-		old_was_inited = 1;
+	if (prev_status >= BCM43xx_STAT_INITIALIZED)
 		bcm43xx_wireless_core_exit(down_dev);
-	}
 
 	if (down_dev != up_dev) {
 		/* We switch to a different core, so we put PHY into
@@ -2613,30 +2652,34 @@ static int bcm43xx_switch_phymode(struct
 
 	/* Now start the new core. */
 	up_dev->phy.gmode = gmode;
-	if (old_was_inited) {
+	if (prev_status >= BCM43xx_STAT_INITIALIZED) {
 		err = bcm43xx_wireless_core_init(up_dev);
 		if (err) {
-			printk(KERN_INFO PFX "Fatal: Could not initialize device for "
-			       "new selected %s-PHY mode\n",
+			bcmerr(wl, "Fatal: Could not initialize device for "
+			       "newly selected %s-PHY mode\n",
 			       phymode_to_string(new_mode));
-			return err;
+			goto init_failure;
 		}
 	}
-	if (old_was_started) {
-		assert(old_was_inited);
+	if (prev_status >= BCM43xx_STAT_STARTED) {
 		err = bcm43xx_wireless_core_start(up_dev);
 		if (err) {
-			printk(KERN_INFO PFX "Fatal: Coult not start device for "
-			       "new selected %s-PHY mode\n",
+			bcmerr(wl, "Fatal: Coult not start device for "
+			       "newly selected %s-PHY mode\n",
 			       phymode_to_string(new_mode));
 			bcm43xx_wireless_core_exit(up_dev);
-			return err;
+			goto init_failure;
 		}
 	}
+	assert(bcm43xx_status(up_dev) == prev_status);
 
 	wl->current_dev = up_dev;
 
 	return 0;
+init_failure:
+	/* Whoops, failed to init the new core. No core is operating now. */
+	wl->current_dev = NULL;
+	return err;
 }
 
 static int bcm43xx_antenna_from_ieee80211(u8 antenna)
@@ -2695,8 +2738,7 @@ static int bcm43xx_dev_config(struct iee
 	 * This makes it possible to drop the spinlock throughout
 	 * the reconfiguration process. */
 	spin_lock_irqsave(&wl->irq_lock, flags);
-	if ((bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) ||
-	    !dev->started) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
 		spin_unlock_irqrestore(&wl->irq_lock, flags);
 		goto out_unlock_mutex;
 	}
@@ -2869,11 +2911,11 @@ out_unlock:
 	mutex_unlock(&wl->mutex);
 out:
 	if (!err) {
-		dprintk(KERN_DEBUG PFX "Using %s based encryption for keyidx: %d, "
-			"mac: " MAC_FMT "\n",
-			(key->flags & IEEE80211_KEY_FORCE_SW_ENCRYPT) ?
-			"software" : "hardware",
-			key->keyidx, MAC_ARG(addr));
+		bcmdbg(wl, "Using %s based encryption for keyidx: %d, "
+		       "mac: " MAC_FMT "\n",
+		       (key->flags & IEEE80211_KEY_FORCE_SW_ENCRYPT) ?
+		       "software" : "hardware",
+		       key->keyidx, MAC_ARG(addr));
 	}
 	return err;
 }
@@ -2932,9 +2974,9 @@ static void bcm43xx_wireless_core_stop(s
 	struct bcm43xx_wl *wl = dev->wl;
 	unsigned long flags;
 
-	if (!dev->started)
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED)
 		return;
-	dev->started = 0;
+	bcm43xx_set_status(dev, BCM43xx_STAT_INITIALIZED);
 
 	mutex_unlock(&wl->mutex);
 	/* Must unlock as it would otherwise deadlock. No races here. */
@@ -2953,32 +2995,32 @@ static void bcm43xx_wireless_core_stop(s
 
 	bcm43xx_mac_suspend(dev);
 	free_irq(dev->dev->irq, dev);
-	dprintk(KERN_INFO PFX "Wireless interface stopped\n");
+	bcmdbg(wl, "Wireless interface stopped\n");
 }
 
 /* Locking: wl->mutex */
 static int bcm43xx_wireless_core_start(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_wl *wl = dev->wl;
 	int err;
 
-	assert(!dev->started);
+	assert(bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED);
 
 	drain_txstatus_queue(dev);
 	err = request_irq(dev->dev->irq, bcm43xx_interrupt_handler,
 			  IRQF_SHARED, KBUILD_MODNAME, dev);
 	if (err) {
-		printk(KERN_ERR PFX "Cannot request IRQ-%d\n",
+		bcmerr(dev->wl, "Cannot request IRQ-%d\n",
 		       dev->dev->irq);
 		goto out;
 	}
-	dev->started = 1;
 	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
 	bcm43xx_mac_enable(dev);
 
-	ieee80211_start_queues(wl->hw);
 	bcm43xx_periodic_tasks_setup(dev);
-	dprintk(KERN_INFO PFX "Wireless interface started\n");
+
+	ieee80211_start_queues(dev->wl->hw);
+	bcm43xx_set_status(dev, BCM43xx_STAT_STARTED);
+	bcmdbg(dev->wl, "Wireless interface started\n");
 out:
 	return err;
 }
@@ -3018,13 +3060,13 @@ static int bcm43xx_phy_versioning(struct
 		unsupported = 1;
 	};
 	if (unsupported) {
-		printk(KERN_ERR PFX "FOUND UNSUPPORTED PHY "
+		bcmerr(dev->wl, "FOUND UNSUPPORTED PHY "
 		       "(Analog %u, Type %u, Revision %u)\n",
 		       analog_type, phy_type, phy_rev);
 		return -EOPNOTSUPP;
 	}
-	dprintk(KERN_INFO PFX "Found PHY: Analog %u, Type %u, Revision %u\n",
-		analog_type, phy_type, phy_rev);
+	bcmdbg(dev->wl, "Found PHY: Analog %u, Type %u, Revision %u\n",
+	       analog_type, phy_type, phy_rev);
 
 
 	/* Get RADIO versioning */
@@ -3068,13 +3110,13 @@ static int bcm43xx_phy_versioning(struct
 		assert(0);
 	}
 	if (unsupported) {
-		printk(KERN_ERR PFX "FOUND UNSUPPORTED RADIO "
+		bcmerr(dev->wl, "FOUND UNSUPPORTED RADIO "
 		       "(Manuf 0x%X, Version 0x%X, Revision %u)\n",
 		       radio_manuf, radio_ver, radio_rev);
 		return -EOPNOTSUPP;
 	}
-	dprintk(KERN_INFO PFX "Found Radio: Manuf 0x%X, Version 0x%X, Revision %u\n",
-		radio_manuf, radio_ver, radio_rev);
+	bcmdbg(dev->wl, "Found Radio: Manuf 0x%X, Version 0x%X, Revision %u\n",
+	       radio_manuf, radio_ver, radio_rev);
 
 
 	phy->radio_manuf = radio_manuf;
@@ -3205,6 +3247,7 @@ static void bcm43xx_wireless_core_exit(s
 {
 	struct bcm43xx_phy *phy = &dev->phy;
 
+	assert(bcm43xx_status(dev) <= BCM43xx_STAT_INITIALIZED);
 	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED)
 		return;
 
@@ -3234,7 +3277,6 @@ static int bcm43xx_wireless_core_init(st
 	u32 hf, tmp;
 
 	assert(bcm43xx_status(dev) == BCM43xx_STAT_UNINIT);
-	bcm43xx_set_status(dev, BCM43xx_STAT_INITIALIZING);
 
 	err = ssb_bus_powerup(bus, 0);
 	if (err)
@@ -3355,7 +3397,7 @@ err_kfree_lo_control:
 	phy->lo_control = NULL;
 err_busdown:
 	ssb_bus_may_powerdown(bus);
-	bcm43xx_set_status(dev, BCM43xx_STAT_UNINIT);
+	assert(bcm43xx_status(dev) == BCM43xx_STAT_UNINIT);
 	return err;
 }
 
@@ -3373,16 +3415,16 @@ static int bcm43xx_add_interface(struct 
 	    wl->operating)
 		goto out_mutex_unlock;
 
-	dprintk(KERN_INFO PFX "Adding Interface type %d\n", conf->type);
+	bcmdbg(wl, "Adding Interface type %d\n", conf->type);
 
 	dev = wl->current_dev;
-	if (bcm43xx_status(dev) == BCM43xx_STAT_UNINIT) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED) {
 		err = bcm43xx_wireless_core_init(dev);
 		if (err)
 			goto out_mutex_unlock;
 		did_init = 1;
 	}
-	if (!dev->started) {
+	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED) {
 		err = bcm43xx_wireless_core_start(dev);
 		if (err) {
 			if (did_init)
@@ -3419,7 +3461,7 @@ static void bcm43xx_remove_interface(str
 	struct bcm43xx_wldev *dev;
 	unsigned long flags;
 
-	dprintk(KERN_INFO PFX "Removing Interface type %d\n", conf->type);
+	bcmdbg(wl, "Removing Interface type %d\n", conf->type);
 
 	mutex_lock(&wl->mutex);
 	if (conf->type == IEEE80211_IF_TYPE_MNTR) {
@@ -3433,7 +3475,7 @@ static void bcm43xx_remove_interface(str
 	dev = wl->current_dev;
 	if (!wl->operating && wl->monitor == 0) {
 		/* No interface left. */
-		if (dev->started)
+		if (bcm43xx_status(dev) >= BCM43xx_STAT_STARTED)
 			bcm43xx_wireless_core_stop(dev);
 		bcm43xx_wireless_core_exit(dev);
 	} else {
@@ -3470,30 +3512,25 @@ static void bcm43xx_chip_reset(struct wo
 	struct bcm43xx_wldev *dev =
 		container_of(work, struct bcm43xx_wldev, restart_work);
 	struct bcm43xx_wl *wl = dev->wl;
-	int err;
-	int was_started = 0;
-	int was_inited = 0;
+	int err = 0;
+	int prev_status;
 
 	mutex_lock(&wl->mutex);
 
+	prev_status = bcm43xx_status(dev);
 	/* Bring the device down... */
-	if (dev->started) {
-		was_started = 1;
+	if (prev_status >= BCM43xx_STAT_STARTED)
 		bcm43xx_wireless_core_stop(dev);
-	}
-	if (bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED) {
-		was_inited = 1;
+	if (prev_status >= BCM43xx_STAT_INITIALIZED)
 		bcm43xx_wireless_core_exit(dev);
-	}
 
 	/* ...and up again. */
-	if (was_inited) {
+	if (prev_status >= BCM43xx_STAT_INITIALIZED) {
 		err = bcm43xx_wireless_core_init(dev);
 		if (err)
 			goto out;
 	}
-	if (was_started) {
-		assert(was_inited);
+	if (prev_status >= BCM43xx_STAT_STARTED) {
 		err = bcm43xx_wireless_core_start(dev);
 		if (err) {
 			bcm43xx_wireless_core_exit(dev);
@@ -3503,9 +3540,9 @@ static void bcm43xx_chip_reset(struct wo
 out:
 	mutex_unlock(&wl->mutex);
 	if (err)
-		printk(KERN_ERR PFX "Controller restart FAILED\n");
+		bcmerr(wl, "Controller restart FAILED\n");
 	else
-		printk(KERN_INFO PFX "Controller restarted\n");
+		bcminfo(wl, "Controller restarted\n");
 }
 
 static int bcm43xx_setup_modes(struct bcm43xx_wldev *dev,
@@ -3718,7 +3755,7 @@ static int bcm43xx_one_core_attach(struc
 		    ((pdev->device != 0x4321) &&
 		     (pdev->device != 0x4313) &&
 		     (pdev->device != 0x431A))) {
-			dprintk(KERN_INFO PFX "Ignoring unconnected 802.11 core\n");
+			bcmdbg(wl, "Ignoring unconnected 802.11 core\n");
 			return -ENODEV;
 		}
 	}
@@ -3792,7 +3829,7 @@ static int bcm43xx_wireless_init(struct 
 
 	hw = ieee80211_alloc_hw(sizeof(*wl), &bcm43xx_hw_ops);
 	if (!hw) {
-		printk(KERN_ERR PFX "Could not allocate ieee80211 device\n");
+		bcmerr(NULL, "Could not allocate ieee80211 device\n");
 		goto out;
 	}
 
@@ -3821,7 +3858,7 @@ static int bcm43xx_wireless_init(struct 
 	INIT_LIST_HEAD(&wl->devlist);
 
 	ssb_set_devtypedata(dev, wl);
-	printk(KERN_INFO PFX "Broadcom %04X WLAN found\n", dev->bus->chip_id);
+	bcminfo(wl, "Broadcom %04X WLAN found\n", dev->bus->chip_id);
 	err = 0;
 out:
 	return err;
@@ -3892,7 +3929,7 @@ void bcm43xx_controller_restart(struct b
 {
 	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED)
 		return;
-	printk(KERN_ERR PFX "Controller RESET (%s) ...\n", reason);
+	bcminfo(dev->wl, "Controller RESET (%s) ...\n", reason);
 	queue_work(dev->wl->hw->workqueue, &dev->restart_work);
 }
 
@@ -3903,19 +3940,17 @@ static int bcm43xx_suspend(struct ssb_de
 	struct bcm43xx_wldev *wldev = ssb_get_drvdata(dev);
 	struct bcm43xx_wl *wl = wldev->wl;
 
-	dprintk(KERN_INFO PFX "Suspending...\n");
+	bcmdbg(wl, "Suspending...\n");
 
 	mutex_lock(&wl->mutex);
-	wldev->was_started = !!wldev->started;
-	wldev->was_initialized = (bcm43xx_status(wldev) == BCM43xx_STAT_INITIALIZED);
-	if (wldev->started)
+	wldev->suspend_init_status = bcm43xx_status(wldev);
+	if (wldev->suspend_init_status >= BCM43xx_STAT_STARTED)
 		bcm43xx_wireless_core_stop(wldev);
-	if (bcm43xx_status(wldev) == BCM43xx_STAT_INITIALIZED)
+	if (wldev->suspend_init_status >= BCM43xx_STAT_INITIALIZED)
 		bcm43xx_wireless_core_exit(wldev);
-
 	mutex_unlock(&wl->mutex);
 
-	dprintk(KERN_INFO PFX "Device suspended.\n");
+	bcmdbg(wl, "Device suspended.\n");
 
 	return 0;
 }
@@ -3923,27 +3958,30 @@ static int bcm43xx_suspend(struct ssb_de
 static int bcm43xx_resume(struct ssb_device *dev)
 {
 	struct bcm43xx_wldev *wldev = ssb_get_drvdata(dev);
+	struct bcm43xx_wl *wl = wldev->wl;
 	int err = 0;
 
-	dprintk(KERN_INFO PFX "Resuming...\n");
+	bcmdbg(wl, "Resuming...\n");
 
-	if (wldev->was_initialized) {
+	mutex_lock(&wl->mutex);
+	if (wldev->suspend_init_status >= BCM43xx_STAT_INITIALIZED) {
 		err = bcm43xx_wireless_core_init(wldev);
 		if (err) {
-			printk(KERN_ERR PFX "Resume failed at core init\n");
+			bcmerr(wl, "Resume failed at core init\n");
 			goto out;
 		}
 	}
-	if (wldev->was_started) {
-		assert(wldev->was_initialized);
+	if (wldev->suspend_init_status >= BCM43xx_STAT_STARTED) {
 		err = bcm43xx_wireless_core_start(wldev);
 		if (err) {
-			printk(KERN_ERR PFX "Resume failed at core start\n");
+			bcm43xx_wireless_core_exit(wldev);
+			bcmerr(wl, "Resume failed at core start\n");
 			goto out;
 		}
 	}
+	mutex_unlock(&wl->mutex);
 
-	dprintk(KERN_INFO PFX "Device resumed.\n");
+	bcmdbg(wl, "Device resumed.\n");
 out:
 	return err;
 }
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
index 53a34f6..24855d6 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.c
@@ -248,7 +248,8 @@ void bcm43xx_raw_phy_unlock(struct bcm43
  * This adjusts (and does sanity checks on) the routing flags.
  */
 static inline u16 adjust_phyreg_for_phytype(struct bcm43xx_phy *phy,
-					    u16 offset)
+					    u16 offset,
+					    struct bcm43xx_wldev *dev)
 {
 	if (phy->type == BCM43xx_PHYTYPE_A) {
 		/* OFDM registers are base-registers for the A-PHY. */
@@ -257,9 +258,9 @@ static inline u16 adjust_phyreg_for_phyt
 	if (offset & BCM43xx_PHYROUTE_EXT_GPHY) {
 		/* Ext-G registers are only available on G-PHYs */
 		if (phy->type != BCM43xx_PHYTYPE_G) {
-			dprintk(KERN_ERR PFX "EXT-G PHY access at "
-				"0x%04X on %u type PHY\n",
-				offset, phy->type);
+			bcmdbg(dev->wl, "EXT-G PHY access at "
+			       "0x%04X on %u type PHY\n",
+			       offset, phy->type);
 		}
 	}
 
@@ -270,7 +271,7 @@ u16 bcm43xx_phy_read(struct bcm43xx_wlde
 {
 	struct bcm43xx_phy *phy = &dev->phy;
 
-	offset = adjust_phyreg_for_phytype(phy, offset);
+	offset = adjust_phyreg_for_phytype(phy, offset, dev);
 	bcm43xx_write16(dev, BCM43xx_MMIO_PHY_CONTROL, offset);
 	return bcm43xx_read16(dev, BCM43xx_MMIO_PHY_DATA);
 }
@@ -279,7 +280,7 @@ void bcm43xx_phy_write(struct bcm43xx_wl
 {
 	struct bcm43xx_phy *phy = &dev->phy;
 
-	offset = adjust_phyreg_for_phytype(phy, offset);
+	offset = adjust_phyreg_for_phytype(phy, offset, dev);
 	bcm43xx_write16(dev, BCM43xx_MMIO_PHY_CONTROL, offset);
 	mmiowb();
 	bcm43xx_write16(dev, BCM43xx_MMIO_PHY_DATA, val);
@@ -311,10 +312,10 @@ void bcm43xx_set_txpower_g(struct bcm43x
 	memcpy(&phy->bbatt, bbatt, sizeof(*bbatt));
 
 	if (bcm43xx_debug(dev, BCM43xx_DBG_XMITPOWER)) {
-		dprintk(KERN_DEBUG PFX "Tuning TX-power to bbatt(%u), "
-			"rfatt(%u), tx_control(0x%02X), "
-			"tx_bias(0x%02X), tx_magn(0x%02X)\n",
-			bb, rf, tx_control, tx_bias, tx_magn);
+		bcmdbg(dev->wl, "Tuning TX-power to bbatt(%u), "
+		       "rfatt(%u), tx_control(0x%02X), "
+		       "tx_bias(0x%02X), tx_magn(0x%02X)\n",
+		       bb, rf, tx_control, tx_bias, tx_magn);
 	}
 
 	bcm43xx_phy_set_baseband_attenuation(dev, bb);
@@ -739,9 +740,9 @@ static void bcm43xx_phy_init_pctl(struct
 		if (BCM43xx_DEBUG) {
 			/* Current-Idle-TSSI sanity check. */
 			if (abs(phy->cur_idle_tssi - phy->tgt_idle_tssi) >= 20) {
-				dprintk(KERN_ERR PFX "!WARNING! Idle-TSSI phy->cur_idle_tssi "
-					"measuring failed. (cur=%d, tgt=%d). Disabling TX power "
-					"adjustment.\n", phy->cur_idle_tssi, phy->tgt_idle_tssi);
+				bcmdbg(dev->wl, "!WARNING! Idle-TSSI phy->cur_idle_tssi "
+				       "measuring failed. (cur=%d, tgt=%d). Disabling TX power "
+				       "adjustment.\n", phy->cur_idle_tssi, phy->tgt_idle_tssi);
 				phy->cur_idle_tssi = 0;
 			}
 		}
@@ -957,12 +958,8 @@ static void bcm43xx_phy_setupg(struct bc
 	if (phy->rev == 1) {
 		for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
 			bcm43xx_ofdmtab_write32(dev, 0x2400, i, bcm43xx_tab_retard[i]);
-		for (i = 0; i < 4; i++) {
-			bcm43xx_ofdmtab_write16(dev, 0x5404, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x5408, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x540C, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x5410, i, 0x0020);
-		}
+		for (i = 4; i < 20; i++)
+			bcm43xx_ofdmtab_write16(dev, 0x5400, i, 0x0020);
 		bcm43xx_phy_agcsetup(dev);
 
 		if ((bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM) &&
@@ -973,7 +970,7 @@ static void bcm43xx_phy_setupg(struct bc
 		bcm43xx_ofdmtab_write16(dev, 0x5001, 0, 0x0002);
 		bcm43xx_ofdmtab_write16(dev, 0x5002, 0, 0x0001);
 	} else {
-		for (i = 0; i <= 0x2F; i++)
+		for (i = 0; i < 0x20; i++)
 			bcm43xx_ofdmtab_write16(dev, 0x1000, i, 0x0820);
 		bcm43xx_phy_agcsetup(dev);
 		bcm43xx_phy_read(dev, 0x0400); /* dummy read */
@@ -2065,7 +2062,7 @@ #endif
 		    (phy->type == BCM43xx_PHYTYPE_G))
 			max_pwr -= 0x3;
 		if (unlikely(max_pwr <= 0)) {
-			printk(KERN_ERR PFX "Invalid max-TX-power value in SPROM.\n");
+			bcmwarn(dev->wl, "Invalid max-TX-power value in SPROM.\n");
 			max_pwr = 60; /* fake it */
 			dev->dev->bus->sprom.r1.maxpwr_bg = max_pwr;
 		}
@@ -2079,10 +2076,9 @@ #endif
 		/* Convert the desired_pwr to Q5.2 and limit it. */
 		desired_pwr = limit_value((desired_pwr << 2), 0, max_pwr);
 		if (bcm43xx_debug(dev, BCM43xx_DBG_XMITPOWER)) {
-			dprintk(KERN_DEBUG PFX
-				"Current TX power output: " Q52_FMT " dBm, "
-				"Desired TX power output: " Q52_FMT " dBm\n",
-				Q52_ARG(estimated_pwr), Q52_ARG(desired_pwr));
+			bcmdbg(dev->wl, "Current TX power output: " Q52_FMT " dBm, "
+			       "Desired TX power output: " Q52_FMT " dBm\n",
+			       Q52_ARG(estimated_pwr), Q52_ARG(desired_pwr));
 		}
 
 		pwr_adjust = desired_pwr - estimated_pwr;
@@ -2210,15 +2206,15 @@ int bcm43xx_phy_init_tssi2dbm_table(stru
 		}
 		dyn_tssi2dbm = kmalloc(64, GFP_KERNEL);
 		if (dyn_tssi2dbm == NULL) {
-			printk(KERN_ERR PFX "Could not allocate memory"
-					    "for tssi2dbm table\n");
+			bcmerr(dev->wl, "Could not allocate memory"
+			       "for tssi2dbm table\n");
 			return -ENOMEM;
 		}
 		for (idx = 0; idx < 64; idx++)
 			if (bcm43xx_tssi2dbm_entry(dyn_tssi2dbm, idx, pab0, pab1, pab2)) {
 				phy->tssi2dbm = NULL;
-				printk(KERN_ERR PFX "Could not generate "
-						    "tssi2dBm table\n");
+				bcmerr(dev->wl, "Could not generate "
+				       "tssi2dBm table\n");
 				kfree(dyn_tssi2dbm);
 				return -ENODEV;
 			}
@@ -2230,8 +2226,8 @@ int bcm43xx_phy_init_tssi2dbm_table(stru
 		case BCM43xx_PHYTYPE_A:
 			/* APHY needs a generated table. */
 			phy->tssi2dbm = NULL;
-			printk(KERN_ERR PFX "Could not generate tssi2dBm "
-					    "table (wrong SPROM info)!\n");
+			bcmerr(dev->wl, "Could not generate tssi2dBm "
+			       "table (wrong SPROM info)!\n");
 			return -ENODEV;
 		case BCM43xx_PHYTYPE_B:
 			phy->tgt_idle_tssi = 0x34;
@@ -2285,7 +2281,7 @@ int bcm43xx_phy_init(struct bcm43xx_wlde
 		break;
 	}
 	if (err)
-		printk(KERN_WARNING PFX "Unknown PHYTYPE found!\n");
+		bcmerr(dev->wl, "Unknown PHYTYPE found\n");
 
 	return err;
 }
@@ -4342,7 +4338,7 @@ void bcm43xx_radio_turn_on(struct bcm43x
 		assert(0);
 	}
 	phy->radio_on = 1;
-	dprintk(KERN_INFO PFX "Radio turned on\n");
+	bcmdbg(dev->wl, "Radio turned on\n");
 }
 
 void bcm43xx_radio_turn_off(struct bcm43xx_wldev *dev)
@@ -4361,5 +4357,5 @@ void bcm43xx_radio_turn_off(struct bcm43
 	} else
 		bcm43xx_phy_write(dev, 0x0015, 0xAA00);
 	phy->radio_on = 0;
-	dprintk(KERN_INFO PFX "Radio turned off\n");
+	bcmdbg(dev->wl, "Radio turned off\n");
 }
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
index 75cea5a..8660103 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_phy.h
@@ -232,8 +232,8 @@ #define has_loopback_gain(phy) \
 
 /* Radio Attenuation (RF Attenuation) */
 struct bcm43xx_rfatt {
-	u8 att;		/* Attenuation value */
-	u8 with_padmix;	/* Flag, PAD Mixer enabled. */
+	u8 att;			/* Attenuation value */
+	bool with_padmix;	/* Flag, PAD Mixer enabled. */
 };
 struct bcm43xx_rfatt_list {
 	/* Attenuation values list */
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_pio.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_pio.c
index 3ae5ef5..16779c2 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_pio.c
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_pio.c
@@ -231,8 +231,8 @@ static int pio_tx_packet(struct bcm43xx_
 
 	octets = (u16)skb->len + sizeof(struct bcm43xx_txhdr_fw4);
 	if (queue->tx_devq_size < octets) {
-		printkl(KERN_WARNING PFX "PIO queue too small. "
-					 "Dropping packet.\n");
+		bcmwarn(queue->dev->wl, "PIO queue too small. "
+			"Dropping packet.\n");
 		/* Drop it silently (return success) */
 		free_txpacket(packet, 1);
 		return 0;
@@ -340,13 +340,13 @@ struct bcm43xx_pioqueue * bcm43xx_setup_
 
 	qsize = bcm43xx_read16(dev, queue->mmio_base + BCM43xx_PIO_TXQBUFSIZE);
 	if (qsize == 0) {
-		printk(KERN_ERR PFX "ERROR: This card does not support PIO "
-				    "operation mode. Please use DMA mode "
-				    "(module parameter pio=0).\n");
+		bcmerr(dev->wl, "This card does not support PIO "
+		       "operation mode. Please use DMA mode "
+		       "(module parameter pio=0).\n");
 		goto err_freequeue;
 	}
 	if (qsize <= BCM43xx_PIO_TXQADJUST) {
-		printk(KERN_ERR PFX "PIO tx device-queue too small (%u)\n",
+		bcmerr(dev->wl, "PIO tx device-queue too small (%u)\n",
 		       qsize);
 		goto err_freequeue;
 	}
@@ -432,7 +432,7 @@ int bcm43xx_pio_init(struct bcm43xx_wlde
 	if (dev->dev->id.revision < 3)
 		dev->irq_savedstate |= BCM43xx_IRQ_PIO_WORKAROUND;
 
-	dprintk(KERN_INFO PFX "PIO initialized\n");
+	bcmdbg(dev->wl, "PIO initialized\n");
 	err = 0;
 out:
 	return err;
@@ -522,7 +522,7 @@ static void pio_rx_error(struct bcm43xx_
 {
 	int i;
 
-	printkl("PIO RX error: %s\n", error);
+	bcmerr(queue->dev->wl, "PIO RX error: %s\n", error);
 	bcm43xx_pio_write(queue, BCM43xx_PIO_RXCTL,
 			  BCM43xx_PIO_RXCTL_READY);
 	if (clear_buffers) {
@@ -554,7 +554,7 @@ void bcm43xx_pio_rx(struct bcm43xx_pioqu
 			goto data_ready;
 		udelay(10);
 	}
-	dprintkl(KERN_ERR PFX "PIO RX timed out\n");
+	bcmdbg(queue->dev->wl, "PIO RX timed out\n");
 	return;
 data_ready:
 
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_pio.h b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_pio.h
index b9d919b..9d112f0 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_pio.h
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_pio.h
@@ -51,9 +51,9 @@ struct bcm43xx_pioqueue {
 	struct bcm43xx_wldev *dev;
 	u16 mmio_base;
 
-	u8 tx_suspended:1,
-	   tx_frozen:1,
-	   need_workarounds:1; /* Workarounds needed for core.rev < 3 */
+	bool tx_suspended;
+	bool tx_frozen;
+	bool need_workarounds; /* Workarounds needed for core.rev < 3 */
 
 	/* Adjusted size of the device internal TX buffer. */
 	u16 tx_devq_size;
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_sysfs.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_sysfs.c
index eed688f..611f688 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_sysfs.c
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_sysfs.c
@@ -137,8 +137,8 @@ static ssize_t bcm43xx_attr_interfmode_s
 
 	err = bcm43xx_radio_set_interference_mitigation(wldev, mode);
 	if (err) {
-		printk(KERN_ERR PFX "Interference Mitigation not "
-				    "supported by device\n");
+		bcmerr(wldev->wl, "Interference Mitigation not "
+		       "supported by device\n");
 	}
 	mmiowb();
 	spin_unlock_irqrestore(&wldev->wl->irq_lock, flags);
diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
index 469c9e0..8ca35d2 100644
--- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
+++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_xmit.c
@@ -467,12 +467,19 @@ void bcm43xx_rx(struct bcm43xx_wldev *de
 
 	/* Skip PLCP and padding */
 	padding = (macstat & BCM43xx_RX_MAC_PADDING) ? 2 : 0;
+	if (unlikely(skb->len < (sizeof(struct bcm43xx_plcp_hdr6) + padding))) {
+		bcmdbg(dev->wl, "RX: Packet size underrun (1)\n");
+		goto drop;
+	}
 	plcp = (struct bcm43xx_plcp_hdr6 *)(skb->data + padding);
 	skb_pull(skb, sizeof(struct bcm43xx_plcp_hdr6) + padding);
 	/* The skb contains the Wireless Header + payload data now */
+	if (unlikely(skb->len < (2+2+6/*minimum hdr*/ + FCS_LEN))) {
+		bcmdbg(dev->wl, "RX: Packet size underrun (2)\n");
+		goto drop;
+	}
 	wlhdr = (struct ieee80211_hdr *)(skb->data);
 	fctl = le16_to_cpu(wlhdr->frame_control);
-
 	skb_trim(skb, skb->len - FCS_LEN);
 
 	if ((macstat & BCM43xx_RX_MAC_DEC) &&
@@ -497,6 +504,10 @@ void bcm43xx_rx(struct bcm43xx_wldev *de
 			wlhdr->frame_control = cpu_to_le16(fctl);
 
 			wlhdr_len = ieee80211_get_hdrlen(fctl);
+			if (unlikely(skb->len < (wlhdr_len + 3))) {
+				bcmdbg(dev->wl, "RX: Packet size underrun (3)\n");
+				goto drop;
+			}
 			if (skb->data[wlhdr_len + 3] & (1 << 5)) {
 				/* The Ext-IV Bit is set in the "KeyID"
 				 * octet of the IV.
@@ -507,7 +518,10 @@ void bcm43xx_rx(struct bcm43xx_wldev *de
 				iv_len = 4;
 				icv_len = 4;
 			}
-
+			if (unlikely(skb->len < (wlhdr_len + iv_len + icv_len))) {
+				bcmdbg(dev->wl, "RX: Packet size underrun (4)\n");
+				goto drop;
+			}
 			/* Remove the IV */
 			memmove(skb->data + iv_len, skb->data, wlhdr_len);
 			skb_pull(skb, iv_len);
@@ -554,6 +568,11 @@ void bcm43xx_rx(struct bcm43xx_wldev *de
 
 	dev->stats.last_rx = jiffies;
 	ieee80211_rx_irqsafe(dev->wl->hw, skb, &status);
+
+	return;
+drop:
+	bcmdbg(dev->wl, "RX: Packet dropped\n");
+	dev_kfree_skb_any(skb);
 }
 
 void bcm43xx_handle_txstatus(struct bcm43xx_wldev *dev,
diff --git a/drivers/ssb/Kconfig b/drivers/ssb/Kconfig
index 03c4945..34a9411 100644
--- a/drivers/ssb/Kconfig
+++ b/drivers/ssb/Kconfig
@@ -58,7 +58,6 @@ config SSB_SERIAL
 config SSB_DRIVER_PCICORE
 	bool "SSB PCI core driver"
 	depends on SSB && SSB_PCIHOST
-	default y
 	help
 	  Driver for the Sonics Silicon Backplane attached
 	  Broadcom PCI core.
diff --git a/drivers/ssb/Makefile b/drivers/ssb/Makefile
index 9a2b379..045aff0 100644
--- a/drivers/ssb/Makefile
+++ b/drivers/ssb/Makefile
@@ -1,11 +1,13 @@
-ssb-builtin-drivers-y					+= driver_chipcommon.o
-ssb-builtin-drivers-$(CONFIG_SSB_DRIVER_MIPS)		+= driver_mipscore.o
-ssb-builtin-drivers-$(CONFIG_SSB_DRIVER_PCICORE)	+= driver_pcicore.o
+# core
+ssb-y					+= main.o scan.o
 
-ssb-hostsupport-$(CONFIG_SSB_PCIHOST)			+= pci.o pcihost_wrapper.o
-ssb-hostsupport-$(CONFIG_SSB_PCMCIAHOST)		+= pcmcia.o
+# host support
+ssb-$(CONFIG_SSB_PCIHOST)		+= pci.o pcihost_wrapper.o
+ssb-$(CONFIG_SSB_PCMCIAHOST)		+= pcmcia.o
 
-obj-$(CONFIG_SSB) += ssb.o
+# built-in drivers
+ssb-y					+= driver_chipcommon.o
+ssb-$(CONFIG_SSB_DRIVER_MIPS)		+= driver_mipscore.o
+ssb-$(CONFIG_SSB_DRIVER_PCICORE)	+= driver_pcicore.o
 
-ssb-objs	:= main.o scan.o \
-		   $(ssb-hostsupport-y) $(ssb-builtin-drivers-y)
+obj-$(CONFIG_SSB)			+= ssb.o
diff --git a/drivers/ssb/driver_chipcommon.c b/drivers/ssb/driver_chipcommon.c
index a283de9..8e5491c 100644
--- a/drivers/ssb/driver_chipcommon.c
+++ b/drivers/ssb/driver_chipcommon.c
@@ -16,7 +16,7 @@ #include "ssb_private.h"
 
 
 /* Clock sources */
-enum {
+enum ssb_clksrc {
 	/* PCI clock */
 	SSB_CHIPCO_CLKSRC_PCI,
 	/* Crystal slow clock oscillator */
@@ -85,15 +85,15 @@ void ssb_chipco_set_clockmode(struct ssb
 			ssb_pci_xtal(bus, SSB_GPIO_XTAL, 0);
 		break;
 	default:
-		assert(0);
+		SSB_WARN_ON(1);
 	}
 }
 
 /* Get the Slow Clock Source */
-static int chipco_pctl_get_slowclksrc(struct ssb_chipcommon *cc)
+static enum ssb_clksrc chipco_pctl_get_slowclksrc(struct ssb_chipcommon *cc)
 {
 	struct ssb_bus *bus = cc->dev->bus;
-	u32 tmp = 0;
+	u32 uninitialized_var(tmp);
 
 	if (cc->dev->id.revision < 6) {
 		if (bus->bustype == SSB_BUSTYPE_SSB ||
@@ -123,9 +123,9 @@ static int chipco_pctl_get_slowclksrc(st
 /* Get maximum or minimum (depending on get_max flag) slowclock frequency. */
 static int chipco_pctl_clockfreqlimit(struct ssb_chipcommon *cc, int get_max)
 {
-	int limit;
-	int clocksrc;
-	int divisor;
+	int uninitialized_var(limit);
+	enum ssb_clksrc clocksrc;
+	int divisor = 1;
 	u32 tmp;
 
 	clocksrc = chipco_pctl_get_slowclksrc(cc);
@@ -138,13 +138,11 @@ static int chipco_pctl_clockfreqlimit(st
 			divisor = 32;
 			break;
 		default:
-			assert(0);
-			divisor = 1;
+			SSB_WARN_ON(1);
 		}
 	} else if (cc->dev->id.revision < 10) {
 		switch (clocksrc) {
 		case SSB_CHIPCO_CLKSRC_LOPWROS:
-			divisor = 1;
 			break;
 		case SSB_CHIPCO_CLKSRC_XTALOS:
 		case SSB_CHIPCO_CLKSRC_PCI:
@@ -152,9 +150,6 @@ static int chipco_pctl_clockfreqlimit(st
 			divisor = (tmp >> 16) + 1;
 			divisor *= 4;
 			break;
-		default:
-			assert(0);
-			divisor = 1;
 		}
 	} else {
 		tmp = chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL);
@@ -181,9 +176,6 @@ static int chipco_pctl_clockfreqlimit(st
 		else
 			limit = 25000000;
 		break;
-	default:
-		assert(0);
-		limit = 0;
 	}
 	limit /= divisor;
 
@@ -235,7 +227,7 @@ static void calc_fast_powerup_delay(stru
 	minfreq = chipco_pctl_clockfreqlimit(cc, 0);
 	pll_on_delay = chipco_read32(cc, SSB_CHIPCO_PLLONDELAY);
 	tmp = (((pll_on_delay + 2) * 1000000) + (minfreq - 1)) / minfreq;
-	assert((tmp & ~0xFFFF) == 0);
+	SSB_WARN_ON(tmp & ~0xFFFF);
 
 	cc->fast_pwrup_delay = tmp;
 }
@@ -355,7 +347,7 @@ int ssb_chipco_serial_init(struct ssb_ch
 			div = 2; /* Minimum divisor */
 			chipco_write32(cc, SSB_CHIPCO_CLKDIV,
 				       (chipco_read32(cc, SSB_CHIPCO_CLKDIV)
-				        & ~SSB_CHIPCO_CLKDIV_UART) | div);
+					& ~SSB_CHIPCO_CLKDIV_UART) | div);
 		} else {
 			/* Fixed internal backplane clock */
 			baud_base = 88000000;
diff --git a/drivers/ssb/driver_mipscore.c b/drivers/ssb/driver_mipscore.c
index 67d1017..3f09598 100644
--- a/drivers/ssb/driver_mipscore.c
+++ b/drivers/ssb/driver_mipscore.c
@@ -13,7 +13,7 @@ #include <linux/ssb/ssb.h>
 #include <linux/serial.h>
 #include <linux/serial_core.h>
 #include <linux/serial_reg.h>
-#include <asm/time.h>
+#include <linux/time.h>
 
 #include "ssb_private.h"
 
@@ -224,7 +224,6 @@ #if 0
 		tmp = tmp | CEIL(120, ns);		/* W0 = 120nS */
 		W_REG(&eir->prog_waitcount, tmp);
 	}
-	else... chipcommon
 #endif
 	if (bus->chipco.dev)
 		ssb_chipco_timing_init(&bus->chipco, ns);
@@ -233,23 +232,24 @@ #endif
 	for (irq = 2, i = 0; i < bus->nr_devices; i++) {
 		dev = &(bus->devices[i]);
 		dev->irq = ssb_mips_irq(dev) + 2;
-		switch(dev->id.coreid) {
-			case SSB_DEV_USB11_HOST:
-				/* shouldn't need a separate irq line for non-4710, most of them have a proper
-				 * external usb controller on the pci */
-				if ((bus->chip_id == 0x4710) && (irq <= 4)) {
-					set_irq(dev, irq++);
-					break;
-				}
-			case SSB_DEV_PCI:
-			case SSB_DEV_ETHERNET:
-			case SSB_DEV_80211:
-			case SSB_DEV_USB20_HOST:
-				/* These devices get their own IRQ line if available, the rest goes on IRQ0 */
-				if (irq <= 4) {
-					set_irq(dev, irq++);
-					break;
-				}
+		switch (dev->id.coreid) {
+		case SSB_DEV_USB11_HOST:
+			/* shouldn't need a separate irq line for non-4710, most of them have a proper
+			 * external usb controller on the pci */
+			if ((bus->chip_id == 0x4710) && (irq <= 4)) {
+				set_irq(dev, irq++);
+				break;
+			}
+			/* fallthrough */
+		case SSB_DEV_PCI:
+		case SSB_DEV_ETHERNET:
+		case SSB_DEV_80211:
+		case SSB_DEV_USB20_HOST:
+			/* These devices get their own IRQ line if available, the rest goes on IRQ0 */
+			if (irq <= 4) {
+				set_irq(dev, irq++);
+				break;
+			}
 		}
 	}
 
diff --git a/drivers/ssb/driver_pcicore.c b/drivers/ssb/driver_pcicore.c
index 841847b..76a9a51 100644
--- a/drivers/ssb/driver_pcicore.c
+++ b/drivers/ssb/driver_pcicore.c
@@ -34,8 +34,10 @@ void pcicore_write32(struct ssb_pcicore 
 #ifdef CONFIG_SSB_PCICORE_HOSTMODE
 
 #include <asm/paccess.h>
-/* Read the bus and catch bus exceptions. This is MIPS specific. */
-#define mips_busprobe(val, addr)	get_dbe((val), (addr))
+/* Probe a 32bit value on the bus and catch bus exceptions.
+ * Returns nonzero on a bus exception.
+ * This is MIPS specific */
+#define mips_busprobe32(val, addr)	get_dbe((val), ((u32 *)(addr)))
 
 /* Assume one-hot slot wiring */
 #define SSB_PCI_SLOT_MAX	16
@@ -54,7 +56,8 @@ int pcibios_plat_dev_init(struct pci_dev
 	int pos, size;
 	u32 *base;
 
-	printk("PCI: Fixing up device %s\n", pci_name(d));
+	ssb_printk(KERN_INFO "PCI: Fixing up device %s\n",
+		   pci_name(d));
 
 	/* Fix up resource bases */
 	for (pos = 0; pos < 6; pos++) {
@@ -85,7 +88,7 @@ static void __init ssb_fixup_pcibridge(s
 	if (dev->bus->number != 0 || PCI_SLOT(dev->devfn) != 0)
 		return;
 
-	printk("PCI: fixing up bridge\n");
+	ssb_printk(KERN_INFO "PCI: fixing up bridge\n");
 
 	/* Enable PCI bridge bus mastering and memory space */
 	pci_set_master(dev);
@@ -147,7 +150,7 @@ static int ssb_extpci_read_config(struct
 	u32 addr, val;
 	void __iomem *mmio;
 
-	assert(pc->hostmode);
+	SSB_WARN_ON(!pc->hostmode);
 	if (unlikely(len != 1 && len != 2 && len != 4))
 		goto out;
 	addr = get_cfgspace_addr(pc, bus, dev, func, off);
@@ -158,7 +161,7 @@ static int ssb_extpci_read_config(struct
 	if (!mmio)
 		goto out;
 
-	if (mips_busprobe(val, (u32 *) mmio)) {
+	if (mips_busprobe32(val, mmio)) {
 		val = 0xffffffff;
 		goto unmap;
 	}
@@ -193,7 +196,7 @@ static int ssb_extpci_write_config(struc
 	u32 addr, val = 0;
 	void __iomem *mmio;
 
-	assert(pc->hostmode);
+	SSB_WARN_ON(!pc->hostmode);
 	if (unlikely(len != 1 && len != 2 && len != 4))
 		goto out;
 	addr = get_cfgspace_addr(pc, bus, dev, func, off);
@@ -204,7 +207,7 @@ static int ssb_extpci_write_config(struc
 	if (!mmio)
 		goto out;
 
-	if (mips_busprobe(val, (u32 *) mmio)) {
+	if (mips_busprobe32(val, mmio)) {
 		val = 0xffffffff;
 		goto unmap;
 	}
@@ -291,10 +294,8 @@ static void ssb_pcicore_init_hostmode(st
 {
 	u32 val;
 
-	if (extpci_core) {
-		WARN_ON(1);
+	if (WARN_ON(extpci_core))
 		return;
-	}
 	extpci_core = pc;
 
 	ssb_dprintk(KERN_INFO PFX "PCIcore in host mode found\n");
@@ -364,7 +365,7 @@ static int pcicore_is_in_hostmode(struct
 	if (bus->chip_id == 0x5350)
 		return 0;
 
-	return !mips_busprobe(tmp, (u32 *) (bus->mmio + (pc->dev->core_index * SSB_CORE_SIZE)));
+	return !mips_busprobe32(tmp, (bus->mmio + (pc->dev->core_index * SSB_CORE_SIZE)));
 }
 #endif /* CONFIG_SSB_PCICORE_HOSTMODE */
 
@@ -458,7 +459,8 @@ static void ssb_commit_settings(struct s
 	struct ssb_device *dev;
 
 	dev = bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev;
-	assert(dev);
+	if (WARN_ON(!dev))
+		return;
 	/* This forces an update of the cached registers. */
 	ssb_broadcast_value(dev, 0xFD8, 0);
 }
@@ -531,7 +533,7 @@ int ssb_pcicore_dev_irqvecs_enable(struc
 			pcicore_write32(pc, SSB_PCICORE_SBTOPCI2, tmp);
 		}
 	} else {
-		assert(pdev->id.coreid == SSB_DEV_PCIE);
+		WARN_ON(pdev->id.coreid != SSB_DEV_PCIE);
 		//TODO: Better make defines for all these magic PCIE values.
 		if ((pdev->id.revision == 0) || (pdev->id.revision == 1)) {
 			/* TLP Workaround register. */
diff --git a/drivers/ssb/main.c b/drivers/ssb/main.c
index f84ee37..9cc4985 100644
--- a/drivers/ssb/main.c
+++ b/drivers/ssb/main.c
@@ -14,27 +14,36 @@ #include <linux/delay.h>
 #include <linux/ssb/ssb.h>
 #include <linux/ssb/ssb_regs.h>
 
-#ifdef CONFIG_SSB_PCIHOST
-# include <linux/pci.h>
-#endif
+#include <linux/pci.h>
 
-#ifdef CONFIG_SSB_PCMCIAHOST
-# include <pcmcia/cs_types.h>
-# include <pcmcia/cs.h>
-# include <pcmcia/cistpl.h>
-# include <pcmcia/ds.h>
-#endif
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
 
 
 MODULE_DESCRIPTION("Sonics Silicon Backplane driver");
 MODULE_LICENSE("GPL");
 
 
+/* Temporary list of yet-to-be-attached buses */
 static LIST_HEAD(attach_queue);
+/* List if running buses */
 static LIST_HEAD(buses);
-static int nr_buses;
+/* Software ID counter */
+static unsigned int next_busnumber;
+/* buses_mutes locks the two buslists and the next_busnumber.
+ * Don't lock this directly, but use ssb_buses_[un]lock() below. */
 static DEFINE_MUTEX(buses_mutex);
 
+/* There are differences in the codeflow, if the bus is
+ * initialized from early boot, as various needed services
+ * are not available early. This is a mechanism to delay
+ * these initializations to after early boot has finished.
+ * It's also used to avoid mutex locking, as that's not
+ * available and needed early. */
+static bool ssb_is_early_boot = 1;
+
 static void ssb_buses_lock(void);
 static void ssb_buses_unlock(void);
 
@@ -272,7 +281,7 @@ static int ssb_bus_match(struct device *
 }
 
 static struct bus_type ssb_bustype = {
-	.name		= NULL, /* Intentionally NULL to indicate early boot */
+	.name		= "ssb",
 	.match		= ssb_bus_match,
 	.probe		= ssb_device_probe,
 	.remove		= ssb_device_remove,
@@ -281,17 +290,15 @@ static struct bus_type ssb_bustype = {
 	.resume		= ssb_device_resume,
 };
 
-#define is_early_boot()		(ssb_bustype.name == NULL)
-
 static void ssb_buses_lock(void)
 {
-	if (!is_early_boot())
+	if (!ssb_is_early_boot)
 		mutex_lock(&buses_mutex);
 }
 
 static void ssb_buses_unlock(void)
 {
-	if (!is_early_boot())
+	if (!ssb_is_early_boot)
 		mutex_unlock(&buses_mutex);
 }
 
@@ -365,7 +372,7 @@ static int ssb_devices_register(struct s
 		dev->release = ssb_release_dev;
 		dev->bus = &ssb_bustype;
 		snprintf(dev->bus_id, sizeof(dev->bus_id),
-			 "ssb%d:%d", bus->busnumber, dev_idx);
+			 "ssb%u:%d", bus->busnumber, dev_idx);
 
 		switch (bus->bustype) {
 		case SSB_BUSTYPE_PCI:
@@ -467,6 +474,7 @@ static void ssb_ssb_write32(struct ssb_d
 	writel(value, bus->mmio + offset);
 }
 
+/* Ops for the plain SSB bus without a host-device (no PCI or PCMCIA). */
 static const struct ssb_bus_ops ssb_ssb_ops = {
 	.read16		= ssb_ssb_read16,
 	.read32		= ssb_ssb_read32,
@@ -475,12 +483,12 @@ static const struct ssb_bus_ops ssb_ssb_
 };
 
 static int ssb_fetch_invariants(struct ssb_bus *bus,
-				int (*get_invariants)(struct ssb_bus *bus,
-						      struct ssb_init_invariants *iv))
+				ssb_invariants_func_t get_invariants)
 {
 	struct ssb_init_invariants iv;
 	int err;
 
+	memset(&iv, 0, sizeof(iv));
 	err = get_invariants(bus, &iv);
 	if (err)
 		goto out;
@@ -491,8 +499,7 @@ out:
 }
 
 static int ssb_bus_register(struct ssb_bus *bus,
-			    int (*get_invariants)(struct ssb_bus *bus,
-			    			  struct ssb_init_invariants *iv),
+			    ssb_invariants_func_t get_invariants,
 			    unsigned long baseaddr)
 {
 	int err;
@@ -505,7 +512,7 @@ static int ssb_bus_register(struct ssb_b
 	if (err)
 		goto out;
 	ssb_buses_lock();
-	bus->busnumber = nr_buses;
+	bus->busnumber = next_busnumber;
 	/* Scan for devices (cores) */
 	err = ssb_bus_scan(bus, baseaddr);
 	if (err)
@@ -529,13 +536,13 @@ static int ssb_bus_register(struct ssb_b
 
 	/* Queue it for attach */
 	list_add_tail(&bus->list, &attach_queue);
-	if (!is_early_boot()) {
+	if (!ssb_is_early_boot) {
 		/* This is not early boot, so we must attach the bus now */
 		err = ssb_attach_queued_buses();
 		if (err)
 			goto err_dequeue;
 	}
-	nr_buses++;
+	next_busnumber++;
 	ssb_buses_unlock();
 
 out:
@@ -600,8 +607,7 @@ #endif /* CONFIG_SSB_PCMCIAHOST */
 
 int ssb_bus_ssbbus_register(struct ssb_bus *bus,
 			    unsigned long baseaddr,
-			    int (*get_invariants)(struct ssb_bus *bus,
-			    			  struct ssb_init_invariants *iv))
+			    ssb_invariants_func_t get_invariants)
 {
 	int err;
 
@@ -694,13 +700,13 @@ u32 ssb_calc_clock_rate(u32 plltype, u32
 	case SSB_PLLTYPE_2: /* 48Mhz, 4 dividers */
 		n1 += SSB_CHIPCO_CLK_T2_BIAS;
 		n2 += SSB_CHIPCO_CLK_T2_BIAS;
-		assert((n1 >= 2) && (n1 <= 7));
-		assert((n2 >= 5) && (n2 <= 23));
+		SSB_WARN_ON(!((n1 >= 2) && (n1 <= 7)));
+		SSB_WARN_ON(!((n2 >= 5) && (n2 <= 23)));
 		break;
 	case SSB_PLLTYPE_5: /* 25Mhz, 4 dividers */
 		return 100000000;
 	default:
-		assert(0);
+		SSB_WARN_ON(1);
 	}
 
 	switch (plltype) {
@@ -749,9 +755,9 @@ u32 ssb_calc_clock_rate(u32 plltype, u32
 		m1 += SSB_CHIPCO_CLK_T2_BIAS;
 		m2 += SSB_CHIPCO_CLK_T2M2_BIAS;
 		m3 += SSB_CHIPCO_CLK_T2_BIAS;
-		assert((m1 >= 2) && (m1 <= 7));
-		assert((m2 >= 3) && (m2 <= 10));
-		assert((m3 >= 2) && (m3 <= 7));
+		SSB_WARN_ON(!((m1 >= 2) && (m1 <= 7)));
+		SSB_WARN_ON(!((m2 >= 3) && (m2 <= 10)));
+		SSB_WARN_ON(!((m3 >= 2) && (m3 <= 7)));
 
 		if (!(mc & SSB_CHIPCO_CLK_T2MC_M1BYP))
 			clock /= m1;
@@ -761,7 +767,7 @@ u32 ssb_calc_clock_rate(u32 plltype, u32
 			clock /= m3;
 		return clock;
 	default:
-		assert(0);
+		SSB_WARN_ON(1);
 	}
 	return 0;
 }
@@ -803,7 +809,7 @@ static u32 ssb_tmslow_reject_bitmask(str
 	case SSB_IDLOW_SSBREV_23:
 		return SSB_TMSLOW_REJECT_23;
 	default:
-		assert(0);
+		WARN_ON(1);
 	}
 	return (SSB_TMSLOW_REJECT_22 | SSB_TMSLOW_REJECT_23);
 }
@@ -912,7 +918,7 @@ EXPORT_SYMBOL(ssb_device_disable);
 
 u32 ssb_dma_translation(struct ssb_device *dev)
 {
-	switch(dev->bus->bustype) {
+	switch (dev->bus->bustype) {
 	case SSB_BUSTYPE_SSB:
 		return 0;
 	case SSB_BUSTYPE_PCI:
@@ -963,7 +969,7 @@ error:
 }
 EXPORT_SYMBOL(ssb_bus_may_powerdown);
 
-int ssb_bus_powerup(struct ssb_bus *bus, int dynamic_pctl)
+int ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl)
 {
 	struct ssb_chipcommon *cc;
 	int err;
@@ -992,15 +998,15 @@ u32 ssb_admatch_base(u32 adm)
 		base = (adm & SSB_ADM_BASE0);
 		break;
 	case SSB_ADM_TYPE1:
-		assert(!(adm & SSB_ADM_NEG)); /* unsupported */
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
 		base = (adm & SSB_ADM_BASE1);
 		break;
 	case SSB_ADM_TYPE2:
-		assert(!(adm & SSB_ADM_NEG)); /* unsupported */
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
 		base = (adm & SSB_ADM_BASE2);
 		break;
 	default:
-		assert(0);
+		SSB_WARN_ON(1);
 	}
 
 	return base;
@@ -1016,15 +1022,15 @@ u32 ssb_admatch_size(u32 adm)
 		size = ((adm & SSB_ADM_SZ0) >> SSB_ADM_SZ0_SHIFT);
 		break;
 	case SSB_ADM_TYPE1:
-		assert(!(adm & SSB_ADM_NEG)); /* unsupported */
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
 		size = ((adm & SSB_ADM_SZ1) >> SSB_ADM_SZ1_SHIFT);
 		break;
 	case SSB_ADM_TYPE2:
-		assert(!(adm & SSB_ADM_NEG)); /* unsupported */
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
 		size = ((adm & SSB_ADM_SZ2) >> SSB_ADM_SZ2_SHIFT);
 		break;
 	default:
-		assert(0);
+		SSB_WARN_ON(1);
 	}
 	size = (1 << (size + 1));
 
@@ -1036,7 +1042,7 @@ static int __init ssb_modinit(void)
 {
 	int err;
 
-	ssb_bustype.name = "ssb";
+	ssb_is_early_boot = 0;
 	err = bus_register(&ssb_bustype);
 	if (err)
 		return err;
diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
index f9dc28f..6767fd2 100644
--- a/drivers/ssb/pci.c
+++ b/drivers/ssb/pci.c
@@ -23,6 +23,7 @@ #include <linux/delay.h>
 #include "ssb_private.h"
 
 
+/* Lowlevel coreswitching */
 int ssb_pci_switch_coreidx(struct ssb_bus *bus, u8 coreidx)
 {
 	int err;
@@ -74,6 +75,7 @@ int ssb_pci_switch_core(struct ssb_bus *
 	return err;
 }
 
+/* Enable/disable the on board crystal oscillator and/or PLL. */
 int ssb_pci_xtal(struct ssb_bus *bus, u32 what, int turn_on)
 {
 	int err;
@@ -158,7 +160,9 @@ err_pci:
 	goto out;
 }
 
+/* Get the word-offset for a SSB_SPROM_XXX define. */
 #define SPOFF(offset)	(((offset) - SSB_SPROM_BASE) / sizeof(u16))
+/* Helper to extract some _offset, which is one of the SSB_SPROM_XXX defines. */
 #define SPEX(_outvar, _offset, _mask, _shift)	\
 	out->_outvar = ((in[SPOFF(_offset)] & (_mask)) >> (_shift))
 
diff --git a/drivers/ssb/pcmcia.c b/drivers/ssb/pcmcia.c
index b908563..f72afd8 100644
--- a/drivers/ssb/pcmcia.c
+++ b/drivers/ssb/pcmcia.c
@@ -112,7 +112,7 @@ int ssb_pcmcia_switch_segment(struct ssb
 	conf_reg_t reg;
 	int res, err = 0;
 
-	assert(seg == 0 || seg == 1);
+	SSB_WARN_ON((seg != 0) && (seg != 1));
 	reg.Offset = 0x34;
 	reg.Function = 0;
 	spin_lock_irqsave(&bus->bar_lock, flags);
@@ -145,6 +145,9 @@ error:
 	goto out_unlock;
 }
 
+/* These are the main device register access functions.
+ * do_select_core is inline to have the likely hotpath inline.
+ * All unlikely codepaths are out-of-line. */
 static inline int do_select_core(struct ssb_bus *bus,
 				 struct ssb_device *dev,
 				 u16 *offset)
@@ -176,7 +179,7 @@ static u16 ssb_pcmcia_read16(struct ssb_
 	if (unlikely(do_select_core(bus, dev, &offset)))
 		return 0xFFFF;
 	x = readw(bus->mmio + offset);
-//printk("R16 0x%04X, 0x%04X\n", offset, x);
+
 	return x;
 }
 
@@ -188,7 +191,7 @@ static u32 ssb_pcmcia_read32(struct ssb_
 	if (unlikely(do_select_core(bus, dev, &offset)))
 		return 0xFFFFFFFF;
 	x = readl(bus->mmio + offset);
-//printk("R32 0x%04X, 0x%08X\n", offset, x);
+
 	return x;
 }
 
@@ -198,7 +201,6 @@ static void ssb_pcmcia_write16(struct ss
 
 	if (unlikely(do_select_core(bus, dev, &offset)))
 		return;
-//printk("W16 0x%04X, 0x%04X\n", offset, value);
 	writew(value, bus->mmio + offset);
 }
 
@@ -208,7 +210,6 @@ static void ssb_pcmcia_write32(struct ss
 
 	if (unlikely(do_select_core(bus, dev, &offset)))
 		return;
-//printk("W32 0x%04X, 0x%08X\n", offset, value);
 	readw(bus->mmio + offset);
 	writew(value >> 16, bus->mmio + offset + 2);
 	readw(bus->mmio + offset);
diff --git a/drivers/ssb/scan.c b/drivers/ssb/scan.c
index feaf1e5..9c33425 100644
--- a/drivers/ssb/scan.c
+++ b/drivers/ssb/scan.c
@@ -15,14 +15,12 @@
 #include <linux/ssb/ssb.h>
 #include <linux/ssb/ssb_regs.h>
 #include <linux/pci.h>
-#include <asm/io.h>
+#include <linux/io.h>
 
-#ifdef CONFIG_SSB_PCMCIAHOST
-# include <pcmcia/cs_types.h>
-# include <pcmcia/cs.h>
-# include <pcmcia/cistpl.h>
-# include <pcmcia/ds.h>
-#endif
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
 
 #include "ssb_private.h"
 
@@ -202,7 +200,11 @@ void ssb_iounmap(struct ssb_bus *bus)
 		iounmap(bus->mmio);
 		break;
 	case SSB_BUSTYPE_PCI:
+#ifdef CONFIG_SSB_PCIHOST
 		pci_iounmap(bus->host_pci, bus->mmio);
+#else
+		SSB_BUG_ON(1); /* Can't reach this code. */
+#endif
 		break;
 	}
 	bus->mmio = NULL;
@@ -222,7 +224,11 @@ static void __iomem * ssb_ioremap(struct
 		mmio = ioremap(baseaddr, SSB_CORE_SIZE);
 		break;
 	case SSB_BUSTYPE_PCI:
+#ifdef CONFIG_SSB_PCIHOST
 		mmio = pci_iomap(bus->host_pci, 0, ~0UL);
+#else
+		SSB_BUG_ON(1); /* Can't reach this code. */
+#endif
 		break;
 	}
 
diff --git a/drivers/ssb/ssb_private.h b/drivers/ssb/ssb_private.h
index d00d186..8e2e310 100644
--- a/drivers/ssb/ssb_private.h
+++ b/drivers/ssb/ssb_private.h
@@ -3,7 +3,6 @@ #define LINUX_SSB_PRIVATE_H_
 
 #include <linux/ssb/ssb.h>
 #include <linux/types.h>
-#include <asm/io.h>
 
 
 #define PFX	"ssb: "
@@ -16,32 +15,19 @@ #endif /* CONFIG_SSB_SILENT */
 
 /* dprintk: Debugging printk; vanishes for non-debug compilation */
 #ifdef CONFIG_SSB_DEBUG
-# define ssb_dprintk(fmt, x...)	ssb_printk(fmt ,##x)
+# define ssb_dprintk(fmt, x...)	ssb_printk(fmt , ##x)
 #else
 # define ssb_dprintk(fmt, x...)	do { /* nothing */ } while (0)
 #endif
 
-/* printkl: Rate limited printk */
-#define ssb_printkl(fmt, x...)	do {		\
-	if (printk_ratelimit())			\
-		ssb_printk(fmt ,##x);		\
-				} while (0)
-
-/* dprintkl: Rate limited debugging printk */
 #ifdef CONFIG_SSB_DEBUG
-# define ssb_dprintkl			ssb_printkl
+# define SSB_WARN_ON(x)		WARN_ON(x)
+# define SSB_BUG_ON(x)		BUG_ON(x)
 #else
-# define ssb_dprintkl(fmt, x...)	do { /* nothing */ } while (0)
+# define SSB_WARN_ON(x)		do { /* nothing */ } while (0)
+# define SSB_BUG_ON(x)		do { /* nothing */ } while (0)
 #endif
 
-#define assert(cond)	do {						\
-	if (unlikely(!(cond))) {					\
-		ssb_dprintk(KERN_ERR PFX "BUG: Assertion failed (%s) "	\
-			    "at: %s:%d:%s()\n",				\
-			    #cond, __FILE__, __LINE__, __func__);	\
-	}								\
-		       } while (0)
-
 
 /* pci.c */
 #ifdef CONFIG_SSB_PCIHOST
@@ -128,10 +114,8 @@ extern void ssb_iounmap(struct ssb_bus *
 
 /* core.c */
 extern u32 ssb_calc_clock_rate(u32 plltype, u32 n, u32 m);
-#ifdef CONFIG_SSB_PCIHOST
 extern int ssb_devices_freeze(struct ssb_bus *bus);
 extern int ssb_devices_thaw(struct ssb_bus *bus);
 extern struct ssb_bus * ssb_pci_dev_to_bus(struct pci_dev *pdev);
-#endif /* CONFIG_SSB_PCIHOST */
 
 #endif /* LINUX_SSB_PRIVATE_H_ */
diff --git a/include/linux/ssb/ssb.h b/include/linux/ssb/ssb.h
index 709e2fa..a3c63ae 100644
--- a/include/linux/ssb/ssb.h
+++ b/include/linux/ssb/ssb.h
@@ -1,14 +1,11 @@
 #ifndef LINUX_SSB_H_
 #define LINUX_SSB_H_
-#ifdef __KERNEL__
 
 #include <linux/device.h>
 #include <linux/list.h>
 #include <linux/types.h>
 #include <linux/spinlock.h>
-#ifdef CONFIG_SSB_PCIHOST
-# include <linux/pci.h>
-#endif
+#include <linux/pci.h>
 
 #include <linux/ssb/ssb_regs.h>
 
@@ -296,6 +293,7 @@ struct ssb_bus {
 	struct pcmcia_device *host_pcmcia;
 
 #ifdef CONFIG_SSB_PCIHOST
+	/* Mutex to protect the SPROM writing. */
 	struct mutex pci_sprom_mutex;
 #endif
 
@@ -312,7 +310,7 @@ #endif
 	u8 suspend_cnt;
 
 	/* Software ID number for this bus. */
-	int busnumber;
+	unsigned int busnumber;
 
 	/* The ChipCommon device (if available). */
 	struct ssb_chipcommon chipco;
@@ -342,6 +340,9 @@ struct ssb_init_invariants {
 	struct ssb_boardinfo boardinfo;
 	struct ssb_sprom sprom;
 };
+/* Type of function to fetch the invariants. */
+typedef int (*ssb_invariants_func_t)(struct ssb_bus *bus,
+				     struct ssb_init_invariants *iv);
 
 /* Register a SSB system bus. get_invariants() is called after the
  * basic system devices are initialized.
@@ -349,8 +350,7 @@ struct ssb_init_invariants {
  * Put the invariants into the struct pointed to by iv. */
 extern int ssb_bus_ssbbus_register(struct ssb_bus *bus,
 				   unsigned long baseaddr,
-				   int (*get_invariants)(struct ssb_bus *bus,
-				   			 struct ssb_init_invariants *iv));
+				   ssb_invariants_func_t get_invariants);
 #ifdef CONFIG_SSB_PCIHOST
 extern int ssb_bus_pcibus_register(struct ssb_bus *bus,
 				   struct pci_dev *host_pci);
@@ -365,8 +365,12 @@ extern void ssb_bus_unregister(struct ss
 
 extern u32 ssb_clockspeed(struct ssb_bus *bus);
 
+/* Is the device enabled in hardware? */
 int ssb_device_is_enabled(struct ssb_device *dev);
+/* Enable a device and pass device-specific SSB_TMSLOW flags.
+ * If no device-specific flags are available, use 0. */
 void ssb_device_enable(struct ssb_device *dev, u32 core_specific_flags);
+/* Disable a device in hardware and pass SSB_TMSLOW flags (if any). */
 void ssb_device_disable(struct ssb_device *dev, u32 core_specific_flags);
 
 
@@ -408,9 +412,15 @@ static inline void ssb_pcihost_unregiste
 #endif /* CONFIG_SSB_PCIHOST */
 
 
-/* Bus-Power handling functions. */
+/* If a driver is shutdown or suspended, call this to signal
+ * that the bus may be completely powered down. SSB will decide,
+ * if it's really time to power down the bus, based on if there
+ * are other devices that want to run. */
 extern int ssb_bus_may_powerdown(struct ssb_bus *bus);
-extern int ssb_bus_powerup(struct ssb_bus *bus, int dynamic_pctl);
+/* Before initializing and enabling a device, call this to power-up the bus.
+ * If you want to allow use of dynamic-power-control, pass the flag.
+ * Otherwise static always-on powercontrol will be used. */
+extern int ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl);
 
 
 /* Various helper functions */
@@ -418,5 +428,4 @@ extern u32 ssb_admatch_base(u32 adm);
 extern u32 ssb_admatch_size(u32 adm);
 
 
-#endif /* __KERNEL__ */
 #endif /* LINUX_SSB_H_ */
diff --git a/include/linux/ssb/ssb_driver_chipcommon.h b/include/linux/ssb/ssb_driver_chipcommon.h
index 8856590..d58c24b 100644
--- a/include/linux/ssb/ssb_driver_chipcommon.h
+++ b/include/linux/ssb/ssb_driver_chipcommon.h
@@ -12,7 +12,6 @@ #define LINUX_SSB_CHIPCO_H_
  *
  * Licensed under the GPL version 2. See COPYING for details.
  */
-#ifdef __KERNEL__
 
 /** ChipCommon core registers. **/
 
@@ -383,5 +382,4 @@ extern int ssb_chipco_serial_init(struct
 				  struct ssb_serial_port *ports);
 #endif /* CONFIG_SSB_SERIAL */
 
-#endif /* __KERNEL__ */
 #endif /* LINUX_SSB_CHIPCO_H_ */
diff --git a/include/linux/ssb/ssb_driver_extif.h b/include/linux/ssb/ssb_driver_extif.h
index 278a637..00de749 100644
--- a/include/linux/ssb/ssb_driver_extif.h
+++ b/include/linux/ssb/ssb_driver_extif.h
@@ -20,8 +20,6 @@
 #ifndef LINUX_SSB_EXTIFCORE_H_
 #define LINUX_SSB_EXTIFCORE_H_
 
-#ifdef __KERNEL__
-
 struct ssb_extif {
 	struct ssb_device *dev;
 };
@@ -159,5 +157,4 @@ #define	SSB_FLASH_WCNT_3_SHIFT		24
 #define SSB_EXTIF_WATCHDOG_CLK		48000000	/* Hz */
 
 
-#endif /* __KERNEL__ */
 #endif /* LINUX_SSB_EXTIFCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_mips.h b/include/linux/ssb/ssb_driver_mips.h
index 91f2373..cdbb985 100644
--- a/include/linux/ssb/ssb_driver_mips.h
+++ b/include/linux/ssb/ssb_driver_mips.h
@@ -1,8 +1,6 @@
 #ifndef LINUX_SSB_MIPSCORE_H_
 #define LINUX_SSB_MIPSCORE_H_
 
-#ifdef __KERNEL__
-
 #ifdef CONFIG_SSB_DRIVER_MIPS
 
 struct ssb_device;
@@ -43,5 +41,4 @@ void ssb_mipscore_init(struct ssb_mipsco
 
 #endif /* CONFIG_SSB_DRIVER_MIPS */
 
-#endif /* __KERNEL__ */
 #endif /* LINUX_SSB_MIPSCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_pci.h b/include/linux/ssb/ssb_driver_pci.h
index 5132f26..9cfffb7 100644
--- a/include/linux/ssb/ssb_driver_pci.h
+++ b/include/linux/ssb/ssb_driver_pci.h
@@ -1,6 +1,5 @@
 #ifndef LINUX_SSB_PCICORE_H_
 #define LINUX_SSB_PCICORE_H_
-#ifdef __KERNEL__
 
 #ifdef CONFIG_SSB_DRIVER_PCICORE
 
@@ -104,5 +103,4 @@ int ssb_pcicore_dev_irqvecs_enable(struc
 }
 
 #endif /* CONFIG_SSB_DRIVER_PCICORE */
-#endif /* __KERNEL__ */
 #endif /* LINUX_SSB_PCICORE_H_ */
diff --git a/include/linux/ssb/ssb_regs.h b/include/linux/ssb/ssb_regs.h
index 1fa4bf8..66751a6 100644
--- a/include/linux/ssb/ssb_regs.h
+++ b/include/linux/ssb/ssb_regs.h
@@ -1,6 +1,5 @@
 #ifndef LINUX_SSB_REGS_H_
 #define LINUX_SSB_REGS_H_
-#ifdef __KERNEL__
 
 
 /* SiliconBackplane Address Map.
@@ -22,10 +21,10 @@ #define	SSB_FLASH1_SZ		0x00400000	/* Siz
 
 #define SSB_PCI_DMA		0x40000000	/* Client Mode sb2pcitranslation2 (1 GB) */
 #define SSB_PCI_DMA_SZ		0x40000000	/* Client Mode sb2pcitranslation2 size in bytes */
-#define SSB_PCIE_DMA_L32		0x00000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), low 32 bits */
-#define SSB_PCIE_DMA_H32		0x80000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), high 32 bits */
-#define	SSB_EUART		(SB_EXTIF_BASE + 0x00800000)
-#define	SSB_LED			(SB_EXTIF_BASE + 0x00900000)
+#define SSB_PCIE_DMA_L32	0x00000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), low 32 bits */
+#define SSB_PCIE_DMA_H32	0x80000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), high 32 bits */
+#define	SSB_EUART		(SSB_EXTIF_BASE + 0x00800000)
+#define	SSB_LED			(SSB_EXTIF_BASE + 0x00900000)
 
 
 /* Enumeration space constants */
@@ -268,7 +267,7 @@ enum {
 	SSB_SPROM1CCODE_NONE,
 };
 
-/* Address-Match values and masks (SSB_ADMATCH?) */
+/* Address-Match values and masks (SSB_ADMATCHxxx) */
 #define SSB_ADM_TYPE			0x00000003	/* Address type */
 #define  SSB_ADM_TYPE0			0
 #define  SSB_ADM_TYPE1			1
@@ -290,5 +289,4 @@ #define SSB_ADM_BASE2			0xFFFF0000	/* Ty
 #define SSB_ADM_BASE2_SHIFT		16
 
 
-#endif /* __KERNEL__ */
 #endif /* LINUX_SSB_REGS_H_ */

-- 
Greetings Michael.


From mb at bu3sch.de  Fri Jul 27 15:10:52 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 27 Jul 2007 15:10:52 +0200
Subject: [PATCH] [bcm43xx-mac80211] Fix pci flush in bcm43xx_mac_suspend
In-Reply-To: <1185427024671-git-send-email-will.dyson@gmail.com>
References: <1185427024671-git-send-email-will.dyson@gmail.com>
Message-ID: <200707271510.52196.mb@bu3sch.de>

On Thursday 26 July 2007 07:17:04 Will Dyson wrote:
> Fix bcm43xx_mac_suspend to flush the status register that we wrote to,
> instead of the register where the result will appear. Improve the comment.
> 
> I was getting many mac suspend failures, now it only happens occasionally.
> 
> Signed-off-by: Will Dyson <will.dyson at gmail.com>
> ---
>  .../net/wireless/bcm43xx-mac80211/bcm43xx_main.c   |    3 ++-
>  1 files changed, 2 insertions(+), 1 deletions(-)
> 
> diff --git a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> index eefc536..4cf671a 100644
> --- a/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ b/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -1875,7 +1875,8 @@ void bcm43xx_mac_suspend(struct bcm43xx_wldev *dev)
>  		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
>  		                bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD)
>  				& ~BCM43xx_SBF_MAC_ENABLED);
> -		bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
> +		/* force pci to flush the write */
> +		bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
>  		for (i = 10000; i; i--) {
>  			tmp = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
>  			if (tmp & BCM43xx_IRQ_MAC_SUSPENDED)

merged, thanks.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Fri Jul 27 16:36:47 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 27 Jul 2007 09:36:47 -0500
Subject: A problem with shared interrupts
In-Reply-To: <1185530070.4006.46.camel@johannes.berg>
References: <46a90082./TQABjOfVYW1o6lY%Larry.Finger@lwfinger.net>
	<1185530070.4006.46.camel@johannes.berg>
Message-ID: <46AA02FF.5020401@lwfinger.net>

Johannes Berg wrote:
> On Thu, 2007-07-26 at 15:13 -0500, Larry Finger wrote:
>> Michael,
>>
>> When I try the -mb tree on my old i386 notebook, I get an "irq 11: nobody cared"
>> message and interrupts for the bcm43xx-mac80211 device are not initialized.
> 
> Hm. Just a thought about something related: do you have 'debug shared
> interrupts' on?

No I didn't. Thanks for the suggestion.

Larry


From mb at bu3sch.de  Fri Jul 27 18:57:20 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 27 Jul 2007 18:57:20 +0200
Subject: [PATCH] Merge the Sonics Silicon Backplane subsystem
Message-ID: <200707271857.24162.mb@bu3sch.de>

The Sonics Silicon Backplane is a mini-bus used on
various Broadcom chips and embedded devices.
Devices using the SSB include b44, bcm43xx and various
Broadcom based wireless routers.
A b44 and bcm43xx port and a SSB based OHCI driver is available.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

diff --git a/drivers/Makefile b/drivers/Makefile
index a9e4c5f..2b079ed 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -87,3 +87,4 @@ obj-$(CONFIG_DMA_ENGINE)	+= dma/
 obj-$(CONFIG_HID)		+= hid/
 obj-$(CONFIG_PPC_PS3)		+= ps3/
 obj-$(CONFIG_OF)		+= of/
+obj-$(CONFIG_SSB)		+= ssb/
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 3e1c442..7bdae47 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -58,6 +58,8 @@ source "drivers/power/Kconfig"
 
 source "drivers/hwmon/Kconfig"
 
+source "drivers/ssb/Kconfig"
+
 source "drivers/mfd/Kconfig"
 
 source "drivers/media/Kconfig"
diff --git a/drivers/ssb/Makefile b/drivers/ssb/Makefile
new file mode 100644
index 0000000..045aff0
--- /dev/null
+++ b/drivers/ssb/Makefile
@@ -0,0 +1,13 @@
+# core
+ssb-y					+= main.o scan.o
+
+# host support
+ssb-$(CONFIG_SSB_PCIHOST)		+= pci.o pcihost_wrapper.o
+ssb-$(CONFIG_SSB_PCMCIAHOST)		+= pcmcia.o
+
+# built-in drivers
+ssb-y					+= driver_chipcommon.o
+ssb-$(CONFIG_SSB_DRIVER_MIPS)		+= driver_mipscore.o
+ssb-$(CONFIG_SSB_DRIVER_PCICORE)	+= driver_pcicore.o
+
+obj-$(CONFIG_SSB)			+= ssb.o
diff --git a/drivers/ssb/Kconfig b/drivers/ssb/Kconfig
new file mode 100644
index 0000000..34a9411
--- /dev/null
+++ b/drivers/ssb/Kconfig
@@ -0,0 +1,92 @@
+menu "Sonics Silicon Backplane"
+
+config SSB
+	tristate "Sonics Silicon Backplane support"
+	depends on EXPERIMENTAL
+	help
+	  Support for the Sonics Silicon Backplane bus
+
+	  The module will be called ssb
+
+	  If unsure, say M
+
+config SSB_PCIHOST
+	bool "Support for SSB on PCI-bus host"
+	depends on SSB && PCI
+	default y
+	help
+	  Support for a Sonics Silicon Backplane on top
+	  of a PCI device.
+
+	  If unsure, say Y
+
+config SSB_PCMCIAHOST
+	bool "Support for SSB on PCMCIA-bus host"
+	depends on SSB && PCMCIA
+	help
+	  Support for a Sonics Silicon Backplane on top
+	  of a PCMCIA device.
+
+	  If unsure, say N
+
+config SSB_SILENT
+	bool "No SSB kernel messages"
+	depends on SSB
+	help
+	  This option turns off all Sonics Silicon Backplane printks.
+	  Note that you won't be able to identify problems, once
+	  messages are turned off.
+	  This might only be desired for production kernels on
+	  embedded devices to reduce the kernel size.
+
+	  Say N
+
+config SSB_DEBUG
+	bool "SSB debugging"
+	depends on SSB && !SSB_SILENT
+	help
+	  This turns on additional runtime checks and debugging
+	  messages. Turn this on for SSB troubleshooting.
+
+	  If unsure, say N
+
+config SSB_SERIAL
+	bool
+	depends on SSB
+	# ChipCommon and ExtIf serial support routines.
+
+config SSB_DRIVER_PCICORE
+	bool "SSB PCI core driver"
+	depends on SSB && SSB_PCIHOST
+	help
+	  Driver for the Sonics Silicon Backplane attached
+	  Broadcom PCI core.
+
+	  If unsure, say Y
+
+config SSB_PCICORE_HOSTMODE
+	bool "Hostmode support for SSB PCI core"
+	depends on SSB_DRIVER_PCICORE && SSB_DRIVER_MIPS
+	help
+	  PCIcore hostmode operation (external PCI bus).
+
+config SSB_DRIVER_MIPS
+	bool "SSB Broadcom MIPS core driver"
+	depends on SSB && MIPS
+	select SSB_SERIAL
+	help
+	  Driver for the Sonics Silicon Backplane attached
+	  Broadcom MIPS core.
+
+	  If unsure, say N
+
+config SSB_DRIVER_EXTIF
+	bool "SSB Broadcom EXTIF core driver"
+	depends on SSB_DRIVER_MIPS
+	help
+	  Driver for the Sonics Silicon Backplane attached
+	  Broadcom EXTIF core.
+
+	  If unsure, say N
+
+endmenu
diff --git a/drivers/ssb/driver_chipcommon.c b/drivers/ssb/driver_chipcommon.c
new file mode 100644
index 0000000..8e5491c
--- /dev/null
+++ b/drivers/ssb/driver_chipcommon.c
@@ -0,0 +1,394 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom ChipCommon core driver
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+#include <linux/pci.h>
+
+#include "ssb_private.h"
+
+
+/* Clock sources */
+enum ssb_clksrc {
+	/* PCI clock */
+	SSB_CHIPCO_CLKSRC_PCI,
+	/* Crystal slow clock oscillator */
+	SSB_CHIPCO_CLKSRC_XTALOS,
+	/* Low power oscillator */
+	SSB_CHIPCO_CLKSRC_LOPWROS,
+};
+
+
+static inline u32 chipco_read32(struct ssb_chipcommon *cc,
+				u16 offset)
+{
+	return ssb_read32(cc->dev, offset);
+}
+
+static inline void chipco_write32(struct ssb_chipcommon *cc,
+				  u16 offset,
+				  u32 value)
+{
+	ssb_write32(cc->dev, offset, value);
+}
+
+void ssb_chipco_set_clockmode(struct ssb_chipcommon *cc,
+			      enum ssb_clkmode mode)
+{
+	struct ssb_device *ccdev = cc->dev;
+	struct ssb_bus *bus;
+	u32 tmp;
+
+	if (!ccdev)
+		return;
+	bus = ccdev->bus;
+	/* chipcommon cores prior to rev6 don't support dynamic clock control */
+	if (ccdev->id.revision < 6)
+		return;
+	/* chipcommon cores rev10 are a whole new ball game */
+	if (ccdev->id.revision >= 10)
+		return;
+	if (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))
+		return;
+
+	switch (mode) {
+	case SSB_CLKMODE_SLOW:
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp |= SSB_CHIPCO_SLOWCLKCTL_FSLOW;
+		chipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);
+		break;
+	case SSB_CLKMODE_FAST:
+		ssb_pci_xtal(bus, SSB_GPIO_XTAL, 1); /* Force crystal on */
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_FSLOW;
+		tmp |= SSB_CHIPCO_SLOWCLKCTL_IPLL;
+		chipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);
+		break;
+	case SSB_CLKMODE_DYNAMIC:
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_FSLOW;
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_IPLL;
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_ENXTAL;
+		if ((tmp & SSB_CHIPCO_SLOWCLKCTL_SRC) != SSB_CHIPCO_SLOWCLKCTL_SRC_XTAL)
+			tmp |= SSB_CHIPCO_SLOWCLKCTL_ENXTAL;
+		chipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);
+
+		/* for dynamic control, we have to release our xtal_pu "force on" */
+		if (tmp & SSB_CHIPCO_SLOWCLKCTL_ENXTAL)
+			ssb_pci_xtal(bus, SSB_GPIO_XTAL, 0);
+		break;
+	default:
+		SSB_WARN_ON(1);
+	}
+}
+
+/* Get the Slow Clock Source */
+static enum ssb_clksrc chipco_pctl_get_slowclksrc(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	u32 uninitialized_var(tmp);
+
+	if (cc->dev->id.revision < 6) {
+		if (bus->bustype == SSB_BUSTYPE_SSB ||
+		    bus->bustype == SSB_BUSTYPE_PCMCIA)
+			return SSB_CHIPCO_CLKSRC_XTALOS;
+		if (bus->bustype == SSB_BUSTYPE_PCI) {
+			pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT, &tmp);
+			if (tmp & 0x10)
+				return SSB_CHIPCO_CLKSRC_PCI;
+			return SSB_CHIPCO_CLKSRC_XTALOS;
+		}
+	}
+	if (cc->dev->id.revision < 10) {
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp &= 0x7;
+		if (tmp == 0)
+			return SSB_CHIPCO_CLKSRC_LOPWROS;
+		if (tmp == 1)
+			return SSB_CHIPCO_CLKSRC_XTALOS;
+		if (tmp == 2)
+			return SSB_CHIPCO_CLKSRC_PCI;
+	}
+
+	return SSB_CHIPCO_CLKSRC_XTALOS;
+}
+
+/* Get maximum or minimum (depending on get_max flag) slowclock frequency. */
+static int chipco_pctl_clockfreqlimit(struct ssb_chipcommon *cc, int get_max)
+{
+	int uninitialized_var(limit);
+	enum ssb_clksrc clocksrc;
+	int divisor = 1;
+	u32 tmp;
+
+	clocksrc = chipco_pctl_get_slowclksrc(cc);
+	if (cc->dev->id.revision < 6) {
+		switch (clocksrc) {
+		case SSB_CHIPCO_CLKSRC_PCI:
+			divisor = 64;
+			break;
+		case SSB_CHIPCO_CLKSRC_XTALOS:
+			divisor = 32;
+			break;
+		default:
+			SSB_WARN_ON(1);
+		}
+	} else if (cc->dev->id.revision < 10) {
+		switch (clocksrc) {
+		case SSB_CHIPCO_CLKSRC_LOPWROS:
+			break;
+		case SSB_CHIPCO_CLKSRC_XTALOS:
+		case SSB_CHIPCO_CLKSRC_PCI:
+			tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+			divisor = (tmp >> 16) + 1;
+			divisor *= 4;
+			break;
+		}
+	} else {
+		tmp = chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL);
+		divisor = (tmp >> 16) + 1;
+		divisor *= 4;
+	}
+
+	switch (clocksrc) {
+	case SSB_CHIPCO_CLKSRC_LOPWROS:
+		if (get_max)
+			limit = 43000;
+		else
+			limit = 25000;
+		break;
+	case SSB_CHIPCO_CLKSRC_XTALOS:
+		if (get_max)
+			limit = 20200000;
+		else
+			limit = 19800000;
+		break;
+	case SSB_CHIPCO_CLKSRC_PCI:
+		if (get_max)
+			limit = 34000000;
+		else
+			limit = 25000000;
+		break;
+	}
+	limit /= divisor;
+
+	return limit;
+}
+
+static void chipco_powercontrol_init(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+
+	if (bus->chip_id == 0x4321) {
+		if (bus->chip_rev == 0)
+			chipco_write32(cc, SSB_CHIPCO_CHIPCTL, 0x3A4);
+		else if (bus->chip_rev == 1)
+			chipco_write32(cc, SSB_CHIPCO_CHIPCTL, 0xA4);
+	}
+
+	if (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))
+		return;
+
+	if (cc->dev->id.revision >= 10) {
+		/* Set Idle Power clock rate to 1Mhz */
+		chipco_write32(cc, SSB_CHIPCO_SYSCLKCTL,
+			       (chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL) &
+				0x0000FFFF) | 0x00040000);
+	} else {
+		int maxfreq;
+
+		maxfreq = chipco_pctl_clockfreqlimit(cc, 1);
+		chipco_write32(cc, SSB_CHIPCO_PLLONDELAY,
+			       (maxfreq * 150 + 999999) / 1000000);
+		chipco_write32(cc, SSB_CHIPCO_FREFSELDELAY,
+			       (maxfreq * 15 + 999999) / 1000000);
+	}
+}
+
+static void calc_fast_powerup_delay(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	int minfreq;
+	unsigned int tmp;
+	u32 pll_on_delay;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return;
+	if (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))
+		return;
+
+	minfreq = chipco_pctl_clockfreqlimit(cc, 0);
+	pll_on_delay = chipco_read32(cc, SSB_CHIPCO_PLLONDELAY);
+	tmp = (((pll_on_delay + 2) * 1000000) + (minfreq - 1)) / minfreq;
+	SSB_WARN_ON(tmp & ~0xFFFF);
+
+	cc->fast_pwrup_delay = tmp;
+}
+
+void ssb_chipcommon_init(struct ssb_chipcommon *cc)
+{
+	if (!cc->dev)
+		return; /* We don't have a ChipCommon */
+	chipco_powercontrol_init(cc);
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_FAST);
+	calc_fast_powerup_delay(cc);
+}
+
+void ssb_chipco_suspend(struct ssb_chipcommon *cc, pm_message_t state)
+{
+	if (!cc->dev)
+		return;
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_SLOW);
+}
+
+void ssb_chipco_resume(struct ssb_chipcommon *cc)
+{
+	if (!cc->dev)
+		return;
+	chipco_powercontrol_init(cc);
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_FAST);
+}
+
+void ssb_chipco_get_clockcontrol(struct ssb_chipcommon *cc,
+				 u32 *plltype, u32 *n, u32 *m)
+{
+	*n = chipco_read32(cc, SSB_CHIPCO_CLOCK_N);
+	*plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);
+	switch (*plltype) {
+	case SSB_PLLTYPE_6: /* 100/200 or 120/240 only */
+		*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_MIPS);
+		break;
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+		if (cc->dev->bus->chip_id != 0x5365) {
+			*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_M2);
+			break;
+		}
+		/* Fallthough */
+	default:
+		*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_SB);
+	}
+}
+
+void ssb_chipco_timing_init(struct ssb_chipcommon *cc,
+			    unsigned long ns)
+{
+	struct ssb_device *dev = cc->dev;
+	struct ssb_bus *bus = dev->bus;
+	u32 tmp;
+
+	/* set register for external IO to control LED. */
+	chipco_write32(cc, SSB_CHIPCO_PROG_CFG, 0x11);
+	tmp = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;		/* Waitcount-3 = 10ns */
+	tmp |= DIV_ROUND_UP(40, ns) << SSB_PROG_WCNT_1_SHIFT;	/* Waitcount-1 = 40ns */
+	tmp |= DIV_ROUND_UP(240, ns);				/* Waitcount-0 = 240ns */
+	chipco_write32(cc, SSB_CHIPCO_PROG_WAITCNT, tmp);	/* 0x01020a0c for a 100Mhz clock */
+
+	/* Set timing for the flash */
+	tmp = DIV_ROUND_UP(10, ns) << SSB_FLASH_WCNT_3_SHIFT;	/* Waitcount-3 = 10nS */
+	tmp |= DIV_ROUND_UP(10, ns) << SSB_FLASH_WCNT_1_SHIFT;	/* Waitcount-1 = 10nS */
+	tmp |= DIV_ROUND_UP(120, ns);				/* Waitcount-0 = 120nS */
+	if ((bus->chip_id == 0x5365) ||
+	    (dev->id.revision < 9))
+		chipco_write32(cc, SSB_CHIPCO_FLASH_WAITCNT, tmp);
+	if ((bus->chip_id == 0x5365) ||
+	    (dev->id.revision < 9) ||
+	    ((bus->chip_id == 0x5350) && (bus->chip_rev == 0)))
+		chipco_write32(cc, SSB_CHIPCO_PCMCIA_MEMWAIT, tmp);
+
+	if (bus->chip_id == 0x5350) {
+		/* Enable EXTIF */
+		tmp = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;	  /* Waitcount-3 = 10ns */
+		tmp |= DIV_ROUND_UP(20, ns) << SSB_PROG_WCNT_2_SHIFT;  /* Waitcount-2 = 20ns */
+		tmp |= DIV_ROUND_UP(100, ns) << SSB_PROG_WCNT_1_SHIFT; /* Waitcount-1 = 100ns */
+		tmp |= DIV_ROUND_UP(120, ns);			  /* Waitcount-0 = 120ns */
+		chipco_write32(cc, SSB_CHIPCO_PROG_WAITCNT, tmp); /* 0x01020a0c for a 100Mhz clock */
+	}
+}
+
+
+#ifdef CONFIG_SSB_SERIAL
+int ssb_chipco_serial_init(struct ssb_chipcommon *cc,
+			   struct ssb_serial_port *ports)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	int nr_ports = 0;
+	u32 plltype;
+	unsigned int irq;
+	u32 baud_base, div;
+	u32 i, n;
+
+	plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);
+	irq = ssb_mips_irq(cc->dev);
+
+	if (plltype == SSB_PLLTYPE_1) {
+		/* PLL clock */
+		baud_base = ssb_calc_clock_rate(plltype,
+						chipco_read32(cc, SSB_CHIPCO_CLOCK_N),
+						chipco_read32(cc, SSB_CHIPCO_CLOCK_M2));
+		div = 1;
+	} else {
+		if (cc->dev->id.revision >= 11) {
+			/* Fixed ALP clock */
+			baud_base = 20000000;
+			div = 1;
+			/* Set the override bit so we don't divide it */
+			chipco_write32(cc, SSB_CHIPCO_CORECTL,
+				       SSB_CHIPCO_CORECTL_UARTCLK0);
+		} else if (cc->dev->id.revision >= 3) {
+			/* Internal backplane clock */
+			baud_base = ssb_clockspeed(bus);
+			div = 2; /* Minimum divisor */
+			chipco_write32(cc, SSB_CHIPCO_CLKDIV,
+				       (chipco_read32(cc, SSB_CHIPCO_CLKDIV)
+					& ~SSB_CHIPCO_CLKDIV_UART) | div);
+		} else {
+			/* Fixed internal backplane clock */
+			baud_base = 88000000;
+			div = 48;
+		}
+
+		/* Clock source depends on strapping if UartClkOverride is unset */
+		if ((cc->dev->id.revision > 0) &&
+		    !(chipco_read32(cc, SSB_CHIPCO_CORECTL) & SSB_CHIPCO_CORECTL_UARTCLK0)) {
+			if ((cc->capabilities & SSB_CHIPCO_CAP_UARTCLK) ==
+			    SSB_CHIPCO_CAP_UARTCLK_INT) {
+				/* Internal divided backplane clock */
+				baud_base /= div;
+			} else {
+				/* Assume external clock of 1.8432 MHz */
+				baud_base = 1843200;
+			}
+		}
+	}
+
+	/* Determine the registers of the UARTs */
+	n = (cc->capabilities & SSB_CHIPCO_CAP_NRUART);
+	for (i = 0; i < n; i++) {
+		void __iomem *cc_mmio;
+		void __iomem *uart_regs;
+
+		cc_mmio = cc->dev->bus->mmio + (cc->dev->core_index * SSB_CORE_SIZE);
+		uart_regs = cc_mmio + SSB_CHIPCO_UART0_DATA;
+		/* Offset changed at after rev 0 */
+		if (cc->dev->id.revision == 0)
+			uart_regs += (i * 8);
+		else
+			uart_regs += (i * 256);
+
+		nr_ports++;
+		ports[i].regs = uart_regs;
+		ports[i].irq = irq;
+		ports[i].baud_base = baud_base;
+		ports[i].reg_shift = 0;
+	}
+
+	return nr_ports;
+}
+#endif /* CONFIG_SSB_SERIAL */
diff --git a/drivers/ssb/driver_mipscore.c b/drivers/ssb/driver_mipscore.c
new file mode 100644
index 0000000..3f09598
--- /dev/null
+++ b/drivers/ssb/driver_mipscore.c
@@ -0,0 +1,258 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom MIPS core driver
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+#include <linux/time.h>
+
+#include "ssb_private.h"
+
+
+static inline u32 mips_read32(struct ssb_mipscore *mcore,
+			      u16 offset)
+{
+	return ssb_read32(mcore->dev, offset);
+}
+
+static inline void mips_write32(struct ssb_mipscore *mcore,
+				u16 offset,
+				u32 value)
+{
+	ssb_write32(mcore->dev, offset, value);
+}
+
+static const u32 ipsflag_irq_mask[] = {
+	0,
+	SSB_IPSFLAG_IRQ1,
+	SSB_IPSFLAG_IRQ2,
+	SSB_IPSFLAG_IRQ3,
+	SSB_IPSFLAG_IRQ4,
+};
+
+static const u32 ipsflag_irq_shift[] = {
+	0,
+	SSB_IPSFLAG_IRQ1_SHIFT,
+	SSB_IPSFLAG_IRQ2_SHIFT,
+	SSB_IPSFLAG_IRQ3_SHIFT,
+	SSB_IPSFLAG_IRQ4_SHIFT,
+};
+
+static inline u32 ssb_irqflag(struct ssb_device *dev)
+{
+	return ssb_read32(dev, SSB_TPSFLAG) & SSB_TPSFLAG_BPFLAG;
+}
+
+/* Get the MIPS IRQ assignment for a specified device.
+ * If unassigned, 0 is returned.
+ */
+unsigned int ssb_mips_irq(struct ssb_device *dev)
+{
+	struct ssb_bus *bus = dev->bus;
+	u32 irqflag;
+	u32 ipsflag;
+	u32 tmp;
+	unsigned int irq;
+
+	irqflag = ssb_irqflag(dev);
+	ipsflag = ssb_read32(bus->mipscore.dev, SSB_IPSFLAG);
+	for (irq = 1; irq <= 4; irq++) {
+		tmp = ((ipsflag & ipsflag_irq_mask[irq]) >> ipsflag_irq_shift[irq]);
+		if (tmp == irqflag)
+			break;
+	}
+	if (irq	== 5)
+		irq = 0;
+
+	return irq;
+}
+
+static void clear_irq(struct ssb_bus *bus, unsigned int irq)
+{
+	struct ssb_device *dev = bus->mipscore.dev;
+
+	/* Clear the IRQ in the MIPScore backplane registers */
+	if (irq == 0) {
+		ssb_write32(dev, SSB_INTVEC, 0);
+	} else {
+		ssb_write32(dev, SSB_IPSFLAG,
+			    ssb_read32(dev, SSB_IPSFLAG) |
+			    ipsflag_irq_mask[irq]);
+	}
+}
+
+static void set_irq(struct ssb_device *dev, unsigned int irq)
+{
+	unsigned int oldirq = ssb_mips_irq(dev);
+	struct ssb_bus *bus = dev->bus;
+	struct ssb_device *mdev = bus->mipscore.dev;
+	u32 irqflag = ssb_irqflag(dev);
+
+	dev->irq = irq + 2;
+
+	ssb_dprintk(KERN_INFO PFX
+		    "set_irq: core 0x%04x, irq %d => %d\n",
+		    dev->id.coreid, oldirq, irq);
+	/* clear the old irq */
+	if (oldirq == 0)
+		ssb_write32(mdev, SSB_INTVEC, (~(1 << irqflag) & ssb_read32(mdev, SSB_INTVEC)));
+	else
+		clear_irq(bus, oldirq);
+
+	/* assign the new one */
+	if (irq == 0)
+		ssb_write32(mdev, SSB_INTVEC, ((1 << irqflag) & ssb_read32(mdev, SSB_INTVEC)));
+
+	irqflag <<= ipsflag_irq_shift[irq];
+	irqflag |= (ssb_read32(mdev, SSB_IPSFLAG) & ~ipsflag_irq_mask[irq]);
+	ssb_write32(mdev, SSB_IPSFLAG, irqflag);
+}
+
+/* XXX: leave here or move into separate extif driver? */
+static int ssb_extif_serial_init(struct ssb_device *dev, struct ssb_serial_ports *ports)
+{
+
+}
+
+
+static void ssb_mips_serial_init(struct ssb_mipscore *mcore)
+{
+	struct ssb_bus *bus = mcore->dev->bus;
+
+	//TODO if (EXTIF available
+#if 0
+		extifregs_t *eir = (extifregs_t *) regs;
+		sbconfig_t *sb;
+
+		/* Determine external UART register base */
+		sb = (sbconfig_t *)((ulong) eir + SBCONFIGOFF);
+		base = EXTIF_CFGIF_BASE(sb_base(R_REG(&sb->sbadmatch1)));
+
+		/* Determine IRQ */
+		irq = sb_irq(sbh);
+
+		/* Disable GPIO interrupt initially */
+		W_REG(&eir->gpiointpolarity, 0);
+		W_REG(&eir->gpiointmask, 0);
+
+		/* Search for external UARTs */
+		n = 2;
+		for (i = 0; i < 2; i++) {
+			regs = (void *) REG_MAP(base + (i * 8), 8);
+			if (BCMINIT(serial_exists)(regs)) {
+				/* Set GPIO 1 to be the external UART IRQ */
+				W_REG(&eir->gpiointmask, 2);
+				if (add)
+					add(regs, irq, 13500000, 0);
+			}
+		}
+
+		/* Add internal UART if enabled */
+		if (R_REG(&eir->corecontrol) & CC_UE)
+			if (add)
+				add((void *) &eir->uartdata, irq, sb_clock(sbh), 2);
+
+#endif
+	if (bus->extif.dev)
+		mcore->nr_serial_ports = ssb_extif_serial_init(&bus->extif, mcore->serial_ports);
+	else if (bus->chipco.dev)
+		mcore->nr_serial_ports = ssb_chipco_serial_init(&bus->chipco, mcore->serial_ports);
+	else
+		mcore->nr_serial_ports = 0;
+}
+
+static void ssb_mips_flash_detect(struct ssb_mipscore *mcore)
+{
+	struct ssb_bus *bus = mcore->dev->bus;
+
+	if (bus->chipco.dev) {
+		mcore->flash_window = 0x1c000000;
+		mcore->flash_window_size = 0x800000;
+	} else {
+		mcore->flash_window = 0x1fc00000;
+		mcore->flash_window_size = 0x400000;
+	}
+}
+
+
+static void ssb_cpu_clock(struct ssb_mipscore *mcore)
+{
+}
+
+void ssb_mipscore_init(struct ssb_mipscore *mcore)
+{
+	struct ssb_bus *bus = mcore->dev->bus;
+	struct ssb_device *dev;
+	unsigned long hz, ns;
+	unsigned int irq, i;
+
+	if (!mcore->dev)
+		return; /* We don't have a MIPS core */
+
+	ssb_dprintk(KERN_INFO PFX "Initializing MIPS core...\n");
+
+	hz = ssb_clockspeed(bus);
+	if (!hz)
+		hz = 100000000;
+	ns = 1000000000 / hz;
+
+//TODO
+#if 0
+	if (have EXTIF) {
+		/* Initialize extif so we can get to the LEDs and external UART */
+		W_REG(&eir->prog_config, CF_EN);
+
+		/* Set timing for the flash */
+		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
+		tmp = tmp | (CEIL(40, ns) << FW_W1_SHIFT); /* W1 = 40nS */
+		tmp = tmp | CEIL(120, ns);		/* W0 = 120nS */
+		W_REG(&eir->prog_waitcount, tmp);	/* 0x01020a0c for a 100Mhz clock */
+
+		/* Set programmable interface timing for external uart */
+		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
+		tmp = tmp | (CEIL(20, ns) << FW_W2_SHIFT); /* W2 = 20nS */
+		tmp = tmp | (CEIL(100, ns) << FW_W1_SHIFT); /* W1 = 100nS */
+		tmp = tmp | CEIL(120, ns);		/* W0 = 120nS */
+		W_REG(&eir->prog_waitcount, tmp);
+	}
+#endif
+	if (bus->chipco.dev)
+		ssb_chipco_timing_init(&bus->chipco, ns);
+
+	/* Assign IRQs to all cores on the bus, start with irq line 2, because serial usually takes 1 */
+	for (irq = 2, i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		dev->irq = ssb_mips_irq(dev) + 2;
+		switch (dev->id.coreid) {
+		case SSB_DEV_USB11_HOST:
+			/* shouldn't need a separate irq line for non-4710, most of them have a proper
+			 * external usb controller on the pci */
+			if ((bus->chip_id == 0x4710) && (irq <= 4)) {
+				set_irq(dev, irq++);
+				break;
+			}
+			/* fallthrough */
+		case SSB_DEV_PCI:
+		case SSB_DEV_ETHERNET:
+		case SSB_DEV_80211:
+		case SSB_DEV_USB20_HOST:
+			/* These devices get their own IRQ line if available, the rest goes on IRQ0 */
+			if (irq <= 4) {
+				set_irq(dev, irq++);
+				break;
+			}
+		}
+	}
+
+	ssb_mips_serial_init(mcore);
+	ssb_mips_flash_detect(mcore);
+}
diff --git a/drivers/ssb/driver_pcicore.c b/drivers/ssb/driver_pcicore.c
new file mode 100644
index 0000000..76a9a51
--- /dev/null
+++ b/drivers/ssb/driver_pcicore.c
@@ -0,0 +1,564 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom PCI-core driver
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include "ssb_private.h"
+
+
+static inline
+u32 pcicore_read32(struct ssb_pcicore *pc, u16 offset)
+{
+	return ssb_read32(pc->dev, offset);
+}
+
+static inline
+void pcicore_write32(struct ssb_pcicore *pc, u16 offset, u32 value)
+{
+	ssb_write32(pc->dev, offset, value);
+}
+
+/**************************************************
+ * Code for hostmode operation.
+ **************************************************/
+
+#ifdef CONFIG_SSB_PCICORE_HOSTMODE
+
+#include <asm/paccess.h>
+/* Probe a 32bit value on the bus and catch bus exceptions.
+ * Returns nonzero on a bus exception.
+ * This is MIPS specific */
+#define mips_busprobe32(val, addr)	get_dbe((val), ((u32 *)(addr)))
+
+/* Assume one-hot slot wiring */
+#define SSB_PCI_SLOT_MAX	16
+
+/* Global lock is OK, as we won't have more than one extpci anyway. */
+static DEFINE_SPINLOCK(cfgspace_lock);
+/* Core to access the external PCI config space. Can only have one. */
+static struct ssb_pcicore *extpci_core;
+
+u32 pci_iobase = 0x100;
+u32 pci_membase = SSB_PCI_DMA;
+
+int pcibios_plat_dev_init(struct pci_dev *d)
+{
+	struct resource *res;
+	int pos, size;
+	u32 *base;
+
+	ssb_printk(KERN_INFO "PCI: Fixing up device %s\n",
+		   pci_name(d));
+
+	/* Fix up resource bases */
+	for (pos = 0; pos < 6; pos++) {
+		res = &d->resource[pos];
+		base = ((res->flags & IORESOURCE_IO) ? &pci_iobase : &pci_membase);
+		if (res->end) {
+			size = res->end - res->start + 1;
+			if (*base & (size - 1))
+				*base = (*base + size) & ~(size - 1);
+			res->start = *base;
+			res->end = res->start + size - 1;
+			*base += size;
+			pci_write_config_dword(d, PCI_BASE_ADDRESS_0 + (pos << 2), res->start);
+		}
+		/* Fix up PCI bridge BAR0 only */
+		if (d->bus->number == 0 && PCI_SLOT(d->devfn) == 0)
+			break;
+	}
+	/* Fix up interrupt lines */
+	d->irq = ssb_mips_irq(extpci_core->dev) + 2;
+	pci_write_config_byte(d, PCI_INTERRUPT_LINE, d->irq);
+
+	return 0;
+}
+
+static void __init ssb_fixup_pcibridge(struct pci_dev *dev)
+{
+	if (dev->bus->number != 0 || PCI_SLOT(dev->devfn) != 0)
+		return;
+
+	ssb_printk(KERN_INFO "PCI: fixing up bridge\n");
+
+	/* Enable PCI bridge bus mastering and memory space */
+	pci_set_master(dev);
+	pcibios_enable_device(dev, ~0);
+
+	/* Enable PCI bridge BAR1 prefetch and burst */
+	pci_write_config_dword(dev, SSB_BAR1_CONTROL, 3);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, ssb_fixup_pcibridge);
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return ssb_mips_irq(extpci_core->dev) + 2;
+}
+
+static u32 get_cfgspace_addr(struct ssb_pcicore *pc,
+			     unsigned int bus, unsigned int dev,
+			     unsigned int func, unsigned int off)
+{
+	u32 addr = 0;
+	u32 tmp;
+
+	if (unlikely(pc->cardbusmode && dev > 1))
+		goto out;
+	if (bus == 0) {
+		/* Type 0 transaction */
+		if (unlikely(dev >= SSB_PCI_SLOT_MAX))
+			goto out;
+		/* Slide the window */
+		tmp = SSB_PCICORE_SBTOPCI_CFG0;
+		tmp |= ((1 << (dev + 16)) & SSB_PCICORE_SBTOPCI1_MASK);
+		pcicore_write32(pc, SSB_PCICORE_SBTOPCI1, tmp);
+		/* Calculate the address */
+		addr = SSB_PCI_CFG;
+		addr |= ((1 << (dev + 16)) & ~SSB_PCICORE_SBTOPCI1_MASK);
+		addr |= (func << 8);
+		addr |= (off & ~3);
+	} else {
+		/* Type 1 transaction */
+		pcicore_write32(pc, SSB_PCICORE_SBTOPCI1,
+				SSB_PCICORE_SBTOPCI_CFG1);
+		/* Calculate the address */
+		addr = SSB_PCI_CFG;
+		addr |= (bus << 16);
+		addr |= (dev << 11);
+		addr |= (func << 8);
+		addr |= (off & ~3);
+	}
+out:
+	return addr;
+}
+
+static int ssb_extpci_read_config(struct ssb_pcicore *pc,
+				  unsigned int bus, unsigned int dev,
+				  unsigned int func, unsigned int off,
+				  void *buf, int len)
+{
+	int err = -EINVAL;
+	u32 addr, val;
+	void __iomem *mmio;
+
+	SSB_WARN_ON(!pc->hostmode);
+	if (unlikely(len != 1 && len != 2 && len != 4))
+		goto out;
+	addr = get_cfgspace_addr(pc, bus, dev, func, off);
+	if (unlikely(!addr))
+		goto out;
+	err = -ENOMEM;
+	mmio = ioremap_nocache(addr, len);
+	if (!mmio)
+		goto out;
+
+	if (mips_busprobe32(val, mmio)) {
+		val = 0xffffffff;
+		goto unmap;
+	}
+
+	val = readl(mmio);
+	val >>= (8 * (off & 3));
+
+	switch (len) {
+	case 1:
+		*((u8 *)buf) = (u8)val;
+		break;
+	case 2:
+		*((u16 *)buf) = (u16)val;
+		break;
+	case 4:
+		*((u32 *)buf) = (u32)val;
+		break;
+	}
+	err = 0;
+unmap:
+	iounmap(mmio);
+out:
+	return err;
+}
+
+static int ssb_extpci_write_config(struct ssb_pcicore *pc,
+				   unsigned int bus, unsigned int dev,
+				   unsigned int func, unsigned int off,
+				   const void *buf, int len)
+{
+	int err = -EINVAL;
+	u32 addr, val = 0;
+	void __iomem *mmio;
+
+	SSB_WARN_ON(!pc->hostmode);
+	if (unlikely(len != 1 && len != 2 && len != 4))
+		goto out;
+	addr = get_cfgspace_addr(pc, bus, dev, func, off);
+	if (unlikely(!addr))
+		goto out;
+	err = -ENOMEM;
+	mmio = ioremap_nocache(addr, len);
+	if (!mmio)
+		goto out;
+
+	if (mips_busprobe32(val, mmio)) {
+		val = 0xffffffff;
+		goto unmap;
+	}
+
+	switch (len) {
+	case 1:
+		val = readl(mmio);
+		val &= ~(0xFF << (8 * (off & 3)));
+		val |= *((const u8 *)buf) << (8 * (off & 3));
+		break;
+	case 2:
+		val = readl(mmio);
+		val &= ~(0xFFFF << (8 * (off & 3)));
+		val |= *((const u16 *)buf) << (8 * (off & 3));
+		break;
+	case 4:
+		val = *((const u32 *)buf);
+		break;
+	}
+	writel(*((const u32 *)buf), mmio);
+
+	err = 0;
+unmap:
+	iounmap(mmio);
+out:
+	return err;
+}
+
+static int ssb_pcicore_read_config(struct pci_bus *bus, unsigned int devfn,
+				   int reg, int size, u32 *val)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&cfgspace_lock, flags);
+	err = ssb_extpci_read_config(extpci_core, bus->number, PCI_SLOT(devfn),
+				     PCI_FUNC(devfn), reg, val, size);
+	spin_unlock_irqrestore(&cfgspace_lock, flags);
+
+	return err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+}
+
+static int ssb_pcicore_write_config(struct pci_bus *bus, unsigned int devfn,
+				    int reg, int size, u32 val)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&cfgspace_lock, flags);
+	err = ssb_extpci_write_config(extpci_core, bus->number, PCI_SLOT(devfn),
+				      PCI_FUNC(devfn), reg, &val, size);
+	spin_unlock_irqrestore(&cfgspace_lock, flags);
+
+	return err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops ssb_pcicore_pciops = {
+	.read	= ssb_pcicore_read_config,
+	.write	= ssb_pcicore_write_config,
+};
+
+static struct resource ssb_pcicore_mem_resource = {
+	.name	= "SSB PCIcore external memory",
+	.start	= SSB_PCI_DMA,
+	.end	= (u32)SSB_PCI_DMA + (u32)SSB_PCI_DMA_SZ - 1,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct resource ssb_pcicore_io_resource = {
+	.name	= "SSB PCIcore external I/O",
+	.start	= 0x100,
+	.end	= 0x7FF,
+	.flags	= IORESOURCE_IO,
+};
+
+static struct pci_controller ssb_pcicore_controller = {
+	.pci_ops	= &ssb_pcicore_pciops,
+	.io_resource	= &ssb_pcicore_io_resource,
+	.mem_resource	= &ssb_pcicore_mem_resource,
+	.mem_offset	= 0x24000000,
+};
+
+static void ssb_pcicore_init_hostmode(struct ssb_pcicore *pc)
+{
+	u32 val;
+
+	if (WARN_ON(extpci_core))
+		return;
+	extpci_core = pc;
+
+	ssb_dprintk(KERN_INFO PFX "PCIcore in host mode found\n");
+	/* Reset devices on the external PCI bus */
+	val = SSB_PCICORE_CTL_RST_OE;
+	val |= SSB_PCICORE_CTL_CLK_OE;
+	pcicore_write32(pc, SSB_PCICORE_CTL, val);
+	val |= SSB_PCICORE_CTL_CLK; /* Clock on */
+	pcicore_write32(pc, SSB_PCICORE_CTL, val);
+	udelay(150);
+	val |= SSB_PCICORE_CTL_RST; /* Deassert RST# */
+	pcicore_write32(pc, SSB_PCICORE_CTL, val);
+	udelay(1);
+
+	//TODO cardbus mode
+
+	/* 64MB I/O window */
+	pcicore_write32(pc, SSB_PCICORE_SBTOPCI0,
+			SSB_PCICORE_SBTOPCI_IO);
+	/* 64MB config space */
+	pcicore_write32(pc, SSB_PCICORE_SBTOPCI1,
+			SSB_PCICORE_SBTOPCI_CFG0);
+	/* 1GB memory window */
+	pcicore_write32(pc, SSB_PCICORE_SBTOPCI2,
+			SSB_PCICORE_SBTOPCI_MEM | SSB_PCI_DMA);
+
+	/* Enable PCI bridge BAR0 prefetch and burst */
+	val = PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	ssb_extpci_write_config(pc, 0, 0, 0, PCI_COMMAND, &val, 2);
+	/* Clear error conditions */
+	val = 0;
+	ssb_extpci_write_config(pc, 0, 0, 0, PCI_STATUS, &val, 2);
+
+	/* Enable PCI interrupts */
+	pcicore_write32(pc, SSB_PCICORE_IMASK,
+			SSB_PCICORE_IMASK_INTA);
+
+	/* Ok, ready to run, register it to the system.
+	 * The following needs change, if we want to port hostmode
+	 * to non-MIPS platform. */
+	set_io_port_base((unsigned long)ioremap_nocache(SSB_PCI_MEM, 0x04000000));
+	register_pci_controller(&ssb_pcicore_controller);
+}
+
+static int pcicore_is_in_hostmode(struct ssb_pcicore *pc)
+{
+	struct ssb_bus *bus = pc->dev->bus;
+	u16 chipid_top;
+	u32 tmp;
+
+	chipid_top = (bus->chip_id & 0xFF00);
+	if (chipid_top != 0x4700 &&
+	    chipid_top != 0x5300)
+		return 0;
+
+	if (bus->sprom.r1.boardflags_lo & SSB_PCICORE_BFL_NOPCI)
+		return 0;
+
+	/* The 200-pin BCM4712 package does not bond out PCI. Even when
+	 * PCI is bonded out, some boards may leave the pins floating. */
+	if (bus->chip_id == 0x4712) {
+		if (bus->chip_package == SSB_CHIPPACK_BCM4712S)
+			return 0;
+		if (bus->chip_package == SSB_CHIPPACK_BCM4712M)
+			return 0;
+	}
+	if (bus->chip_id == 0x5350)
+		return 0;
+
+	return !mips_busprobe32(tmp, (bus->mmio + (pc->dev->core_index * SSB_CORE_SIZE)));
+}
+#endif /* CONFIG_SSB_PCICORE_HOSTMODE */
+
+
+/**************************************************
+ * Generic and Clientmode operation code.
+ **************************************************/
+
+static void ssb_pcicore_init_clientmode(struct ssb_pcicore *pc)
+{
+	/* Disable PCI interrupts. */
+	ssb_write32(pc->dev, SSB_INTVEC, 0);
+}
+
+void ssb_pcicore_init(struct ssb_pcicore *pc)
+{
+	struct ssb_device *dev = pc->dev;
+	struct ssb_bus *bus;
+
+	if (!dev)
+		return;
+	bus = dev->bus;
+	if (!ssb_device_is_enabled(dev))
+		ssb_device_enable(dev, 0);
+
+#ifdef CONFIG_SSB_PCICORE_HOSTMODE
+	pc->hostmode = pcicore_is_in_hostmode(pc);
+	if (pc->hostmode)
+		ssb_pcicore_init_hostmode(pc);
+#endif /* CONFIG_SSB_PCICORE_HOSTMODE */
+	if (!pc->hostmode)
+		ssb_pcicore_init_clientmode(pc);
+}
+
+static u32 ssb_pcie_read(struct ssb_pcicore *pc, u32 address)
+{
+	pcicore_write32(pc, 0x130, address);
+	return pcicore_read32(pc, 0x134);
+}
+
+static void ssb_pcie_write(struct ssb_pcicore *pc, u32 address, u32 data)
+{
+	pcicore_write32(pc, 0x130, address);
+	pcicore_write32(pc, 0x134, data);
+}
+
+static void ssb_pcie_mdio_write(struct ssb_pcicore *pc, u8 device,
+				u8 address, u16 data)
+{
+	const u16 mdio_control = 0x128;
+	const u16 mdio_data = 0x12C;
+	u32 v;
+	int i;
+
+	v = 0x80; /* Enable Preamble Sequence */
+	v |= 0x2; /* MDIO Clock Divisor */
+	pcicore_write32(pc, mdio_control, v);
+
+	v = (1 << 30); /* Start of Transaction */
+	v |= (1 << 28); /* Write Transaction */
+	v |= (1 << 17); /* Turnaround */
+	v |= (u32)device << 22;
+	v |= (u32)address << 18;
+	v |= data;
+	pcicore_write32(pc, mdio_data, v);
+	udelay(10);
+	for (i = 0; i < 10; i++) {
+		v = pcicore_read32(pc, mdio_control);
+		if (v & 0x100 /* Trans complete */)
+			break;
+		msleep(1);
+	}
+	pcicore_write32(pc, mdio_control, 0);
+}
+
+static void ssb_broadcast_value(struct ssb_device *dev,
+				u32 address, u32 data)
+{
+	/* This is used for both, PCI and ChipCommon core, so be careful. */
+	BUILD_BUG_ON(SSB_PCICORE_BCAST_ADDR != SSB_CHIPCO_BCAST_ADDR);
+	BUILD_BUG_ON(SSB_PCICORE_BCAST_DATA != SSB_CHIPCO_BCAST_DATA);
+
+	ssb_write32(dev, SSB_PCICORE_BCAST_ADDR, address);
+	ssb_read32(dev, SSB_PCICORE_BCAST_ADDR); /* flush */
+	ssb_write32(dev, SSB_PCICORE_BCAST_DATA, data);
+	ssb_read32(dev, SSB_PCICORE_BCAST_DATA); /* flush */
+}
+
+static void ssb_commit_settings(struct ssb_bus *bus)
+{
+	struct ssb_device *dev;
+
+	dev = bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev;
+	if (WARN_ON(!dev))
+		return;
+	/* This forces an update of the cached registers. */
+	ssb_broadcast_value(dev, 0xFD8, 0);
+}
+
+int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
+				   struct ssb_device *dev)
+{
+	struct ssb_device *pdev = pc->dev;
+	struct ssb_bus *bus;
+	int err = 0;
+	u32 tmp;
+
+	might_sleep();
+
+	if (!pdev)
+		goto out;
+	bus = pdev->bus;
+
+	/* Enable interrupts for this device. */
+	if (bus->host_pci &&
+	    ((pdev->id.revision >= 6) || (pdev->id.coreid == SSB_DEV_PCIE))) {
+		u32 coremask;
+
+		/* Calculate the "coremask" for the device. */
+		coremask = (1 << dev->core_index);
+
+		err = pci_read_config_dword(bus->host_pci, SSB_PCI_IRQMASK, &tmp);
+		if (err)
+			goto out;
+		tmp |= coremask << 8;
+		err = pci_write_config_dword(bus->host_pci, SSB_PCI_IRQMASK, tmp);
+		if (err)
+			goto out;
+	} else {
+		u32 intvec;
+
+		intvec = ssb_read32(pdev, SSB_INTVEC);
+		if ((bus->chip_id & 0xFF00) == 0x4400) {
+			/* Workaround: On the BCM44XX the BPFLAG routing
+			 * bit is wrong. Use a hardcoded constant. */
+			intvec |= 0x00000002;
+		} else {
+			tmp = ssb_read32(dev, SSB_TPSFLAG);
+			tmp &= SSB_TPSFLAG_BPFLAG;
+			intvec |= tmp;
+		}
+		ssb_write32(pdev, SSB_INTVEC, intvec);
+	}
+
+	/* Setup PCIcore operation. */
+	if (pc->setup_done)
+		goto out;
+	if (pdev->id.coreid == SSB_DEV_PCI) {
+		tmp = pcicore_read32(pc, SSB_PCICORE_SBTOPCI2);
+		tmp |= SSB_PCICORE_SBTOPCI_PREF;
+		tmp |= SSB_PCICORE_SBTOPCI_BURST;
+		pcicore_write32(pc, SSB_PCICORE_SBTOPCI2, tmp);
+
+		if (pdev->id.revision < 5) {
+			tmp = ssb_read32(pdev, SSB_IMCFGLO);
+			tmp &= ~SSB_IMCFGLO_SERTO;
+			tmp |= 2;
+			tmp &= ~SSB_IMCFGLO_REQTO;
+			tmp |= 3 << SSB_IMCFGLO_REQTO_SHIFT;
+			ssb_write32(pdev, SSB_IMCFGLO, tmp);
+			ssb_commit_settings(bus);
+		} else if (pdev->id.revision >= 11) {
+			tmp = pcicore_read32(pc, SSB_PCICORE_SBTOPCI2);
+			tmp |= SSB_PCICORE_SBTOPCI_MRM;
+			pcicore_write32(pc, SSB_PCICORE_SBTOPCI2, tmp);
+		}
+	} else {
+		WARN_ON(pdev->id.coreid != SSB_DEV_PCIE);
+		//TODO: Better make defines for all these magic PCIE values.
+		if ((pdev->id.revision == 0) || (pdev->id.revision == 1)) {
+			/* TLP Workaround register. */
+			tmp = ssb_pcie_read(pc, 0x4);
+			tmp |= 0x8;
+			ssb_pcie_write(pc, 0x4, tmp);
+		}
+		if (pdev->id.revision == 0) {
+			const u8 serdes_rx_device = 0x1F;
+
+			ssb_pcie_mdio_write(pc, serdes_rx_device,
+					    2 /* Timer */, 0x8128);
+			ssb_pcie_mdio_write(pc, serdes_rx_device,
+					    6 /* CDR */, 0x0100);
+			ssb_pcie_mdio_write(pc, serdes_rx_device,
+					    7 /* CDR BW */, 0x1466);
+		} else if (pdev->id.revision == 1) {
+			/* DLLP Link Control register. */
+			tmp = ssb_pcie_read(pc, 0x100);
+			tmp |= 0x40;
+			ssb_pcie_write(pc, 0x100, tmp);
+		}
+	}
+	pc->setup_done = 1;
+out:
+	return err;
+}
+EXPORT_SYMBOL(ssb_pcicore_dev_irqvecs_enable);
diff --git a/drivers/ssb/main.c b/drivers/ssb/main.c
new file mode 100644
index 0000000..faa4a48
--- /dev/null
+++ b/drivers/ssb/main.c
@@ -0,0 +1,1104 @@
+/*
+ * Sonics Silicon Backplane
+ * Subsystem core
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include "ssb_private.h"
+
+#include <linux/delay.h>
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+
+#include <linux/pci.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+
+
+MODULE_DESCRIPTION("Sonics Silicon Backplane driver");
+MODULE_LICENSE("GPL");
+
+
+/* Temporary list of yet-to-be-attached buses */
+static LIST_HEAD(attach_queue);
+/* List if running buses */
+static LIST_HEAD(buses);
+/* Software ID counter */
+static unsigned int next_busnumber;
+/* buses_mutes locks the two buslists and the next_busnumber.
+ * Don't lock this directly, but use ssb_buses_[un]lock() below. */
+static DEFINE_MUTEX(buses_mutex);
+
+/* There are differences in the codeflow, if the bus is
+ * initialized from early boot, as various needed services
+ * are not available early. This is a mechanism to delay
+ * these initializations to after early boot has finished.
+ * It's also used to avoid mutex locking, as that's not
+ * available and needed early. */
+static bool ssb_is_early_boot = 1;
+
+static void ssb_buses_lock(void);
+static void ssb_buses_unlock(void);
+
+
+#ifdef CONFIG_SSB_PCIHOST
+struct ssb_bus * ssb_pci_dev_to_bus(struct pci_dev *pdev)
+{
+	struct ssb_bus *bus;
+
+	ssb_buses_lock();
+	list_for_each_entry(bus, &buses, list) {
+		if (bus->bustype == SSB_BUSTYPE_PCI &&
+		    bus->host_pci == pdev)
+			goto found;
+	}
+	bus = NULL;
+found:
+	ssb_buses_unlock();
+
+	return bus;
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+static struct ssb_device * ssb_device_get(struct ssb_device *dev)
+{
+	if (dev)
+		get_device(dev->dev);
+	return dev;
+}
+
+static void ssb_device_put(struct ssb_device *dev)
+{
+	if (dev)
+		put_device(dev->dev);
+}
+
+static int ssb_bus_resume(struct ssb_bus *bus)
+{
+	int err;
+
+	ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 1);
+	err = ssb_pcmcia_init(bus);
+	if (err) {
+		/* No need to disable XTAL, as we don't have one on PCMCIA. */
+		return err;
+	}
+	ssb_chipco_resume(&bus->chipco);
+
+	return 0;
+}
+
+static int ssb_device_resume(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv;
+	struct ssb_bus *bus;
+	int err = 0;
+
+	bus = ssb_dev->bus;
+	if (bus->suspend_cnt == bus->nr_devices) {
+		err = ssb_bus_resume(bus);
+		if (err)
+			return err;
+	}
+	bus->suspend_cnt--;
+	if (dev->driver) {
+		ssb_drv = drv_to_ssb_drv(dev->driver);
+		if (ssb_drv && ssb_drv->resume)
+			err = ssb_drv->resume(ssb_dev);
+		if (err)
+			goto out;
+	}
+out:
+	return err;
+}
+
+static void ssb_bus_suspend(struct ssb_bus *bus, pm_message_t state)
+{
+	ssb_chipco_suspend(&bus->chipco, state);
+	ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);
+
+	/* Reset HW state information in memory, so that HW is
+	 * completely reinitialized on resume. */
+	bus->mapped_device = NULL;
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+	bus->pcicore.setup_done = 0;
+#endif
+}
+
+static int ssb_device_suspend(struct device *dev, pm_message_t state)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv;
+	struct ssb_bus *bus;
+	int err = 0;
+
+	if (dev->driver) {
+		ssb_drv = drv_to_ssb_drv(dev->driver);
+		if (ssb_drv && ssb_drv->suspend)
+			err = ssb_drv->suspend(ssb_dev, state);
+		if (err)
+			goto out;
+	}
+
+	bus = ssb_dev->bus;
+	bus->suspend_cnt++;
+	if (bus->suspend_cnt == bus->nr_devices) {
+		/* All devices suspended. Shutdown the bus. */
+		ssb_bus_suspend(bus, state);
+	}
+
+out:
+	return err;
+}
+
+#ifdef CONFIG_SSB_PCIHOST
+int ssb_devices_freeze(struct ssb_bus *bus)
+{
+	struct ssb_device *dev;
+	struct ssb_driver *drv;
+	int err = 0;
+	int i;
+	pm_message_t state = PMSG_FREEZE;
+
+	/* First check that we are capable to freeze all devices. */
+	for (i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		if (!drv->suspend) {
+			/* Nope, can't suspend this one. */
+			return -EOPNOTSUPP;
+		}
+	}
+	/* Now suspend all devices */
+	for (i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		err = drv->suspend(dev, state);
+		if (err) {
+			ssb_printk(KERN_ERR PFX "Failed to freeze device %s\n",
+				   dev->dev->bus_id);
+			goto err_unwind;
+		}
+	}
+
+	return 0;
+err_unwind:
+	for (i--; i >= 0; i--) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		if (drv->resume)
+			drv->resume(dev);
+	}
+	return err;
+}
+
+int ssb_devices_thaw(struct ssb_bus *bus)
+{
+	struct ssb_device *dev;
+	struct ssb_driver *drv;
+	int err;
+	int i;
+
+	for (i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		if (SSB_WARN_ON(!drv->resume))
+			continue;
+		err = drv->resume(dev);
+		if (err) {
+			ssb_printk(KERN_ERR PFX "Failed to thaw device %s\n",
+				   dev->dev->bus_id);
+		}
+	}
+
+	return 0;
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+static void ssb_device_shutdown(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv;
+
+	if (!dev->driver)
+		return;
+	ssb_drv = drv_to_ssb_drv(dev->driver);
+	if (ssb_drv && ssb_drv->shutdown)
+		ssb_drv->shutdown(ssb_dev);
+}
+
+static int ssb_device_remove(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv = drv_to_ssb_drv(dev->driver);
+
+	if (ssb_drv && ssb_drv->remove)
+		ssb_drv->remove(ssb_dev);
+	ssb_device_put(ssb_dev);
+
+	return 0;
+}
+
+static int ssb_device_probe(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv = drv_to_ssb_drv(dev->driver);
+	int err = 0;
+
+	ssb_device_get(ssb_dev);
+	if (ssb_drv && ssb_drv->probe)
+		err = ssb_drv->probe(ssb_dev, &ssb_dev->id);
+	if (err)
+		ssb_device_put(ssb_dev);
+
+	return err;
+}
+
+static int ssb_match_devid(const struct ssb_device_id *tabid,
+			   const struct ssb_device_id *devid)
+{
+	if ((tabid->vendor != devid->vendor) &&
+	    tabid->vendor != SSB_ANY_VENDOR)
+		return 0;
+	if ((tabid->coreid != devid->coreid) &&
+	    tabid->coreid != SSB_ANY_ID)
+		return 0;
+	if ((tabid->revision != devid->revision) &&
+	    tabid->revision != SSB_ANY_REV)
+		return 0;
+	return 1;
+}
+
+static int ssb_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv = drv_to_ssb_drv(drv);
+	const struct ssb_device_id *id;
+
+	for (id = ssb_drv->id_table;
+	     id->vendor || id->coreid || id->revision;
+	     id++) {
+		if (ssb_match_devid(id, &ssb_dev->id))
+			return 1; /* found */
+	}
+
+	return 0;
+}
+
+static struct bus_type ssb_bustype = {
+	.name		= "ssb",
+	.match		= ssb_bus_match,
+	.probe		= ssb_device_probe,
+	.remove		= ssb_device_remove,
+	.shutdown	= ssb_device_shutdown,
+	.suspend	= ssb_device_suspend,
+	.resume		= ssb_device_resume,
+};
+
+static void ssb_buses_lock(void)
+{
+	if (!ssb_is_early_boot)
+		mutex_lock(&buses_mutex);
+}
+
+static void ssb_buses_unlock(void)
+{
+	if (!ssb_is_early_boot)
+		mutex_unlock(&buses_mutex);
+}
+
+static void ssb_devices_unregister(struct ssb_bus *bus)
+{
+	struct ssb_device *sdev;
+	int i;
+
+	for (i = bus->nr_devices - 1; i >= 0; i--) {
+		sdev = &(bus->devices[i]);
+		if (sdev->dev)
+			device_unregister(sdev->dev);
+	}
+}
+
+void ssb_bus_unregister(struct ssb_bus *bus)
+{
+	ssb_buses_lock();
+	ssb_devices_unregister(bus);
+	list_del(&bus->list);
+	ssb_buses_unlock();
+
+	/* ssb_pcmcia_exit(bus); */
+	ssb_pci_exit(bus);
+	ssb_iounmap(bus);
+}
+EXPORT_SYMBOL(ssb_bus_unregister);
+
+static void ssb_release_dev(struct device *dev)
+{
+	struct __ssb_dev_wrapper *devwrap;
+
+	devwrap = container_of(dev, struct __ssb_dev_wrapper, dev);
+	kfree(devwrap);
+}
+
+static int ssb_devices_register(struct ssb_bus *bus)
+{
+	struct ssb_device *sdev;
+	struct device *dev;
+	struct __ssb_dev_wrapper *devwrap;
+	int i, err = 0;
+	int dev_idx = 0;
+
+	for (i = 0; i < bus->nr_devices; i++) {
+		sdev = &(bus->devices[i]);
+
+		/* We don't register SSB-system devices to the kernel,
+		 * as the drivers for them are built into SSB. */
+		switch (sdev->id.coreid) {
+		case SSB_DEV_CHIPCOMMON:
+		case SSB_DEV_PCI:
+		case SSB_DEV_PCIE:
+		case SSB_DEV_PCMCIA:
+		case SSB_DEV_MIPS:
+		case SSB_DEV_MIPS_3302:
+		case SSB_DEV_EXTIF:
+			continue;
+		}
+
+		devwrap = kzalloc(sizeof(*devwrap), GFP_KERNEL);
+		if (!devwrap) {
+			ssb_printk(KERN_ERR PFX
+				   "Could not allocate device\n");
+			err = -ENOMEM;
+			goto error;
+		}
+		dev = &devwrap->dev;
+		devwrap->sdev = sdev;
+
+		dev->release = ssb_release_dev;
+		dev->bus = &ssb_bustype;
+		snprintf(dev->bus_id, sizeof(dev->bus_id),
+			 "ssb%u:%d", bus->busnumber, dev_idx);
+
+		switch (bus->bustype) {
+		case SSB_BUSTYPE_PCI:
+#ifdef CONFIG_SSB_PCIHOST
+			sdev->irq = bus->host_pci->irq;
+			dev->parent = &bus->host_pci->dev;
+#endif
+			break;
+		case SSB_BUSTYPE_PCMCIA:
+#ifdef CONFIG_SSB_PCMCIAHOST
+			dev->parent = &bus->host_pcmcia->dev;
+#endif
+			break;
+		case SSB_BUSTYPE_SSB:
+			break;
+		}
+
+		sdev->dev = dev;
+		err = device_register(dev);
+		if (err) {
+			ssb_printk(KERN_ERR PFX
+				   "Could not register %s\n",
+				   dev->bus_id);
+			/* Set dev to NULL to not unregister
+			 * dev on error unwinding. */
+			sdev->dev = NULL;
+			kfree(devwrap);
+			goto error;
+		}
+		dev_idx++;
+	}
+
+	return 0;
+error:
+	/* Unwind the already registered devices. */
+	ssb_devices_unregister(bus);
+	return err;
+}
+
+/* Needs ssb_buses_lock() */
+static int ssb_attach_queued_buses(void)
+{
+	struct ssb_bus *bus, *n;
+	int err = 0;
+	int drop_them_all = 0;
+
+	list_for_each_entry_safe(bus, n, &attach_queue, list) {
+		if (drop_them_all) {
+			list_del(&bus->list);
+			continue;
+		}
+		/* Can't init the PCIcore in ssb_bus_register(), as that
+		 * is too early in boot for embedded systems
+		 * (no udelay() available). So do it here in attach stage.
+		 */
+		ssb_pcicore_init(&bus->pcicore);
+
+		err = ssb_devices_register(bus);
+		if (err) {
+			drop_them_all = 1;
+			list_del(&bus->list);
+			continue;
+		}
+		list_move_tail(&bus->list, &buses);
+	}
+
+	return err;
+}
+
+static u16 ssb_ssb_read16(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	return readw(bus->mmio + offset);
+}
+
+static u32 ssb_ssb_read32(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	return readl(bus->mmio + offset);
+}
+
+static void ssb_ssb_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	writew(value, bus->mmio + offset);
+}
+
+static void ssb_ssb_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	writel(value, bus->mmio + offset);
+}
+
+/* Ops for the plain SSB bus without a host-device (no PCI or PCMCIA). */
+static const struct ssb_bus_ops ssb_ssb_ops = {
+	.read16		= ssb_ssb_read16,
+	.read32		= ssb_ssb_read32,
+	.write16	= ssb_ssb_write16,
+	.write32	= ssb_ssb_write32,
+};
+
+static int ssb_fetch_invariants(struct ssb_bus *bus,
+				ssb_invariants_func_t get_invariants)
+{
+	struct ssb_init_invariants iv;
+	int err;
+
+	memset(&iv, 0, sizeof(iv));
+	err = get_invariants(bus, &iv);
+	if (err)
+		goto out;
+	memcpy(&bus->boardinfo, &iv.boardinfo, sizeof(iv.boardinfo));
+	memcpy(&bus->sprom, &iv.sprom, sizeof(iv.sprom));
+out:
+	return err;
+}
+
+static int ssb_bus_register(struct ssb_bus *bus,
+			    ssb_invariants_func_t get_invariants,
+			    unsigned long baseaddr)
+{
+	int err;
+
+	spin_lock_init(&bus->bar_lock);
+	INIT_LIST_HEAD(&bus->list);
+
+	/* Powerup the bus */
+	err = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 1);
+	if (err)
+		goto out;
+	ssb_buses_lock();
+	bus->busnumber = next_busnumber;
+	/* Scan for devices (cores) */
+	err = ssb_bus_scan(bus, baseaddr);
+	if (err)
+		goto err_disable_xtal;
+
+	/* Init PCI-host device (if any) */
+	err = ssb_pci_init(bus);
+	if (err)
+		goto err_unmap;
+	/* Init PCMCIA-host device (if any) */
+	err = ssb_pcmcia_init(bus);
+	if (err)
+		goto err_pci_exit;
+
+	/* Initialize basic system devices (if available) */
+	ssb_chipcommon_init(&bus->chipco);
+	ssb_mipscore_init(&bus->mipscore);
+	err = ssb_fetch_invariants(bus, get_invariants);
+	if (err)
+		goto err_pcmcia_exit;
+
+	/* Queue it for attach */
+	list_add_tail(&bus->list, &attach_queue);
+	if (!ssb_is_early_boot) {
+		/* This is not early boot, so we must attach the bus now */
+		err = ssb_attach_queued_buses();
+		if (err)
+			goto err_dequeue;
+	}
+	next_busnumber++;
+	ssb_buses_unlock();
+
+out:
+	return err;
+
+err_dequeue:
+	list_del(&bus->list);
+err_pcmcia_exit:
+/*	ssb_pcmcia_exit(bus); */
+err_pci_exit:
+	ssb_pci_exit(bus);
+err_unmap:
+	ssb_iounmap(bus);
+err_disable_xtal:
+	ssb_buses_unlock();
+	ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);
+	return err;
+}
+
+#ifdef CONFIG_SSB_PCIHOST
+int ssb_bus_pcibus_register(struct ssb_bus *bus,
+			    struct pci_dev *host_pci)
+{
+	int err;
+
+	bus->bustype = SSB_BUSTYPE_PCI;
+	bus->host_pci = host_pci;
+	bus->ops = &ssb_pci_ops;
+
+	err = ssb_bus_register(bus, ssb_pci_get_invariants, 0);
+	if (!err) {
+		ssb_printk(KERN_INFO PFX "Sonics Silicon Backplane found on "
+			   "PCI device %s\n", host_pci->dev.bus_id);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_pcibus_register);
+#endif /* CONFIG_SSB_PCIHOST */
+
+#ifdef CONFIG_SSB_PCMCIAHOST
+int ssb_bus_pcmciabus_register(struct ssb_bus *bus,
+			       struct pcmcia_device *pcmcia_dev,
+			       unsigned long baseaddr)
+{
+	int err;
+
+	bus->bustype = SSB_BUSTYPE_PCMCIA;
+	bus->host_pcmcia = pcmcia_dev;
+	bus->ops = &ssb_pcmcia_ops;
+
+	err = ssb_bus_register(bus, ssb_pcmcia_get_invariants, baseaddr);
+	if (!err) {
+		ssb_printk(KERN_INFO PFX "Sonics Silicon Backplane found on "
+			   "PCMCIA device %s\n", pcmcia_dev->devname);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_pcmciabus_register);
+#endif /* CONFIG_SSB_PCMCIAHOST */
+
+int ssb_bus_ssbbus_register(struct ssb_bus *bus,
+			    unsigned long baseaddr,
+			    ssb_invariants_func_t get_invariants)
+{
+	int err;
+
+	bus->bustype = SSB_BUSTYPE_SSB;
+	bus->ops = &ssb_ssb_ops;
+
+	err = ssb_bus_register(bus, get_invariants, baseaddr);
+	if (!err) {
+		ssb_printk(KERN_INFO PFX "Sonics Silicon Backplane found at "
+			   "address 0x%08lX\n", baseaddr);
+	}
+
+	return err;
+}
+
+int __ssb_driver_register(struct ssb_driver *drv, struct module *owner)
+{
+	drv->drv.name = drv->name;
+	drv->drv.bus = &ssb_bustype;
+	drv->drv.owner = owner;
+
+	return driver_register(&drv->drv);
+}
+EXPORT_SYMBOL(__ssb_driver_register);
+
+void ssb_driver_unregister(struct ssb_driver *drv)
+{
+	driver_unregister(&drv->drv);
+}
+EXPORT_SYMBOL(ssb_driver_unregister);
+
+void ssb_set_devtypedata(struct ssb_device *dev, void *data)
+{
+	struct ssb_bus *bus = dev->bus;
+	struct ssb_device *ent;
+	int i;
+
+	for (i = 0; i < bus->nr_devices; i++) {
+		ent = &(bus->devices[i]);
+		if (ent->id.vendor != dev->id.vendor)
+			continue;
+		if (ent->id.coreid != dev->id.coreid)
+			continue;
+
+		ent->devtypedata = data;
+	}
+}
+EXPORT_SYMBOL(ssb_set_devtypedata);
+
+static u32 clkfactor_f6_resolve(u32 v)
+{
+	/* map the magic values */
+	switch (v) {
+	case SSB_CHIPCO_CLK_F6_2:
+		return 2;
+	case SSB_CHIPCO_CLK_F6_3:
+		return 3;
+	case SSB_CHIPCO_CLK_F6_4:
+		return 4;
+	case SSB_CHIPCO_CLK_F6_5:
+		return 5;
+	case SSB_CHIPCO_CLK_F6_6:
+		return 6;
+	case SSB_CHIPCO_CLK_F6_7:
+		return 7;
+	}
+	return 0;
+}
+
+/* Calculate the speed the backplane would run at a given set of clockcontrol values */
+u32 ssb_calc_clock_rate(u32 plltype, u32 n, u32 m)
+{
+	u32 n1, n2, clock, m1, m2, m3, mc;
+
+	n1 = (n & SSB_CHIPCO_CLK_N1);
+	n2 = ((n & SSB_CHIPCO_CLK_N2) >> SSB_CHIPCO_CLK_N2_SHIFT);
+
+	switch (plltype) {
+	case SSB_PLLTYPE_6: /* 100/200 or 120/240 only */
+		if (m & SSB_CHIPCO_CLK_T6_MMASK)
+			return SSB_CHIPCO_CLK_T6_M0;
+		return SSB_CHIPCO_CLK_T6_M1;
+	case SSB_PLLTYPE_1: /* 48Mhz base, 3 dividers */
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+	case SSB_PLLTYPE_4: /* 48Mhz, 4 dividers */
+	case SSB_PLLTYPE_7: /* 25Mhz, 4 dividers */
+		n1 = clkfactor_f6_resolve(n1);
+		n2 += SSB_CHIPCO_CLK_F5_BIAS;
+		break;
+	case SSB_PLLTYPE_2: /* 48Mhz, 4 dividers */
+		n1 += SSB_CHIPCO_CLK_T2_BIAS;
+		n2 += SSB_CHIPCO_CLK_T2_BIAS;
+		SSB_WARN_ON(!((n1 >= 2) && (n1 <= 7)));
+		SSB_WARN_ON(!((n2 >= 5) && (n2 <= 23)));
+		break;
+	case SSB_PLLTYPE_5: /* 25Mhz, 4 dividers */
+		return 100000000;
+	default:
+		SSB_WARN_ON(1);
+	}
+
+	switch (plltype) {
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+	case SSB_PLLTYPE_7: /* 25Mhz, 4 dividers */
+		clock = SSB_CHIPCO_CLK_BASE2 * n1 * n2;
+		break;
+	default:
+		clock = SSB_CHIPCO_CLK_BASE1 * n1 * n2;
+	}
+	if (!clock)
+		return 0;
+
+	m1 = (m & SSB_CHIPCO_CLK_M1);
+	m2 = ((m & SSB_CHIPCO_CLK_M2) >> SSB_CHIPCO_CLK_M2_SHIFT);
+	m3 = ((m & SSB_CHIPCO_CLK_M3) >> SSB_CHIPCO_CLK_M3_SHIFT);
+	mc = ((m & SSB_CHIPCO_CLK_MC) >> SSB_CHIPCO_CLK_MC_SHIFT);
+
+	switch (plltype) {
+	case SSB_PLLTYPE_1: /* 48Mhz base, 3 dividers */
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+	case SSB_PLLTYPE_4: /* 48Mhz, 4 dividers */
+	case SSB_PLLTYPE_7: /* 25Mhz, 4 dividers */
+		m1 = clkfactor_f6_resolve(m1);
+		if ((plltype == SSB_PLLTYPE_1) ||
+		    (plltype == SSB_PLLTYPE_3))
+			m2 += SSB_CHIPCO_CLK_F5_BIAS;
+		else
+			m2 = clkfactor_f6_resolve(m2);
+		m3 = clkfactor_f6_resolve(m3);
+
+		switch (mc) {
+		case SSB_CHIPCO_CLK_MC_BYPASS:
+			return clock;
+		case SSB_CHIPCO_CLK_MC_M1:
+			return (clock / m1);
+		case SSB_CHIPCO_CLK_MC_M1M2:
+			return (clock / (m1 * m2));
+		case SSB_CHIPCO_CLK_MC_M1M2M3:
+			return (clock / (m1 * m2 * m3));
+		case SSB_CHIPCO_CLK_MC_M1M3:
+			return (clock / (m1 * m3));
+		}
+		return 0;
+	case SSB_PLLTYPE_2:
+		m1 += SSB_CHIPCO_CLK_T2_BIAS;
+		m2 += SSB_CHIPCO_CLK_T2M2_BIAS;
+		m3 += SSB_CHIPCO_CLK_T2_BIAS;
+		SSB_WARN_ON(!((m1 >= 2) && (m1 <= 7)));
+		SSB_WARN_ON(!((m2 >= 3) && (m2 <= 10)));
+		SSB_WARN_ON(!((m3 >= 2) && (m3 <= 7)));
+
+		if (!(mc & SSB_CHIPCO_CLK_T2MC_M1BYP))
+			clock /= m1;
+		if (!(mc & SSB_CHIPCO_CLK_T2MC_M2BYP))
+			clock /= m2;
+		if (!(mc & SSB_CHIPCO_CLK_T2MC_M3BYP))
+			clock /= m3;
+		return clock;
+	default:
+		SSB_WARN_ON(1);
+	}
+	return 0;
+}
+
+/* Get the current speed the backplane is running at */
+u32 ssb_clockspeed(struct ssb_bus *bus)
+{
+	u32 rate;
+	u32 plltype;
+	u32 clkctl_n, clkctl_m;
+
+	//TODO if EXTIF: PLLTYPE == 1, read n from clockcontrol_n, m from clockcontrol_sb
+
+	if (bus->chipco.dev) {
+		ssb_chipco_get_clockcontrol(&bus->chipco, &plltype,
+					    &clkctl_n, &clkctl_m);
+	} else
+		return 0;
+
+	if (bus->chip_id == 0x5365) {
+		rate = 100000000;
+	} else {
+		rate = ssb_calc_clock_rate(plltype, clkctl_n, clkctl_m);
+		if (plltype == SSB_PLLTYPE_3) /* 25Mhz, 2 dividers */
+			rate /= 2;
+	}
+
+	return rate;
+}
+EXPORT_SYMBOL(ssb_clockspeed);
+
+static u32 ssb_tmslow_reject_bitmask(struct ssb_device *dev)
+{
+	/* The REJECT bit changed position in TMSLOW between
+	 * Backplane revisions. */
+	switch (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV) {
+	case SSB_IDLOW_SSBREV_22:
+		return SSB_TMSLOW_REJECT_22;
+	case SSB_IDLOW_SSBREV_23:
+		return SSB_TMSLOW_REJECT_23;
+	default:
+		WARN_ON(1);
+	}
+	return (SSB_TMSLOW_REJECT_22 | SSB_TMSLOW_REJECT_23);
+}
+
+int ssb_device_is_enabled(struct ssb_device *dev)
+{
+	u32 val;
+	u32 reject;
+
+	reject = ssb_tmslow_reject_bitmask(dev);
+	val = ssb_read32(dev, SSB_TMSLOW);
+	val &= SSB_TMSLOW_CLOCK | SSB_TMSLOW_RESET | reject;
+
+	return (val == SSB_TMSLOW_CLOCK);
+}
+EXPORT_SYMBOL(ssb_device_is_enabled);
+
+void ssb_device_enable(struct ssb_device *dev, u32 core_specific_flags)
+{
+	u32 val;
+
+	ssb_device_disable(dev, core_specific_flags);
+	ssb_write32(dev, SSB_TMSLOW,
+		    SSB_TMSLOW_RESET | SSB_TMSLOW_CLOCK |
+		    SSB_TMSLOW_FGC | core_specific_flags);
+	/* flush */
+	ssb_read32(dev, SSB_TMSLOW);
+	udelay(1);
+
+	/* Clear SERR if set. This is a hw bug workaround. */
+	if (ssb_read32(dev, SSB_TMSHIGH) & SSB_TMSHIGH_SERR)
+		ssb_write32(dev, SSB_TMSHIGH, 0);
+
+	val = ssb_read32(dev, SSB_IMSTATE);
+	if (val & (SSB_IMSTATE_IBE | SSB_IMSTATE_TO)) {
+		val &= ~(SSB_IMSTATE_IBE | SSB_IMSTATE_TO);
+		ssb_write32(dev, SSB_IMSTATE, val);
+	}
+
+	ssb_write32(dev, SSB_TMSLOW,
+		    SSB_TMSLOW_CLOCK | SSB_TMSLOW_FGC |
+		    core_specific_flags);
+	/* flush */
+	ssb_read32(dev, SSB_TMSLOW);
+	udelay(1);
+
+	ssb_write32(dev, SSB_TMSLOW, SSB_TMSLOW_CLOCK |
+		    core_specific_flags);
+	/* flush */
+	ssb_read32(dev, SSB_TMSLOW);
+	udelay(1);
+}
+EXPORT_SYMBOL(ssb_device_enable);
+
+static int ssb_wait_bit(struct ssb_device *dev, u16 reg, u32 bitmask,
+			int timeout, int set)
+{
+	int i;
+	u32 val;
+
+	for (i = 0; i < timeout; i++) {
+		val = ssb_read32(dev, reg);
+		if (set) {
+			if (val & bitmask)
+				return 0;
+		} else {
+			if (!(val & bitmask))
+				return 0;
+		}
+		udelay(10);
+	}
+	printk(KERN_ERR PFX "Timeout waiting for bitmask %08X on "
+			    "register %04X to %s.\n",
+	       bitmask, reg, (set ? "set" : "clear"));
+
+	return -ETIMEDOUT;
+}
+
+void ssb_device_disable(struct ssb_device *dev, u32 core_specific_flags)
+{
+	u32 reject;
+
+	if (ssb_read32(dev, SSB_TMSLOW) & SSB_TMSLOW_RESET)
+		return;
+
+	reject = ssb_tmslow_reject_bitmask(dev);
+	ssb_write32(dev, SSB_TMSLOW, reject | SSB_TMSLOW_CLOCK);
+	ssb_wait_bit(dev, SSB_TMSLOW, reject, 1000, 1);
+	ssb_wait_bit(dev, SSB_TMSHIGH, SSB_TMSHIGH_BUSY, 1000, 0);
+	ssb_write32(dev, SSB_TMSLOW,
+		    SSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK |
+		    reject | SSB_TMSLOW_RESET |
+		    core_specific_flags);
+	/* flush */
+	ssb_read32(dev, SSB_TMSLOW);
+	udelay(1);
+
+	ssb_write32(dev, SSB_TMSLOW,
+		    reject | SSB_TMSLOW_RESET |
+		    core_specific_flags);
+	/* flush */
+	ssb_read32(dev, SSB_TMSLOW);
+	udelay(1);
+}
+EXPORT_SYMBOL(ssb_device_disable);
+
+u32 ssb_dma_translation(struct ssb_device *dev)
+{
+	switch (dev->bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		return 0;
+	case SSB_BUSTYPE_PCI:
+	case SSB_BUSTYPE_PCMCIA:
+		return SSB_PCI_DMA;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ssb_dma_translation);
+
+int ssb_dma_set_mask(struct ssb_device *ssb_dev, u64 mask)
+{
+	struct device *dev = ssb_dev->dev;
+
+#ifdef CONFIG_SSB_PCIHOST
+	if (ssb_dev->bus->bustype == SSB_BUSTYPE_PCI &&
+	    !dma_supported(dev, mask))
+		return -EIO;
+#endif
+	dev->coherent_dma_mask = mask;
+	dev->dma_mask = &dev->coherent_dma_mask;
+
+	return 0;
+}
+EXPORT_SYMBOL(ssb_dma_set_mask);
+
+int ssb_bus_may_powerdown(struct ssb_bus *bus)
+{
+	struct ssb_chipcommon *cc;
+	int err;
+
+	/* On buses where more than one core may be working
+	 * at a time, we must not powerdown stuff if there are
+	 * still cores that may want to run. */
+	if (bus->bustype == SSB_BUSTYPE_SSB)
+		return 0;
+
+	cc = &bus->chipco;
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_SLOW);
+	err = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);
+	if (err)
+		goto error;
+
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Bus powerdown failed\n");
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_may_powerdown);
+
+int ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl)
+{
+	struct ssb_chipcommon *cc;
+	int err;
+	enum ssb_clkmode mode;
+
+	err = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 1);
+	if (err)
+		goto error;
+	cc = &bus->chipco;
+	mode = dynamic_pctl ? SSB_CLKMODE_DYNAMIC : SSB_CLKMODE_FAST;
+	ssb_chipco_set_clockmode(cc, mode);
+
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Bus powerup failed\n");
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_powerup);
+
+u32 ssb_admatch_base(u32 adm)
+{
+	u32 base = 0;
+
+	switch (adm & SSB_ADM_TYPE) {
+	case SSB_ADM_TYPE0:
+		base = (adm & SSB_ADM_BASE0);
+		break;
+	case SSB_ADM_TYPE1:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		base = (adm & SSB_ADM_BASE1);
+		break;
+	case SSB_ADM_TYPE2:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		base = (adm & SSB_ADM_BASE2);
+		break;
+	default:
+		SSB_WARN_ON(1);
+	}
+
+	return base;
+}
+EXPORT_SYMBOL(ssb_admatch_base);
+
+u32 ssb_admatch_size(u32 adm)
+{
+	u32 size = 0;
+
+	switch (adm & SSB_ADM_TYPE) {
+	case SSB_ADM_TYPE0:
+		size = ((adm & SSB_ADM_SZ0) >> SSB_ADM_SZ0_SHIFT);
+		break;
+	case SSB_ADM_TYPE1:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		size = ((adm & SSB_ADM_SZ1) >> SSB_ADM_SZ1_SHIFT);
+		break;
+	case SSB_ADM_TYPE2:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		size = ((adm & SSB_ADM_SZ2) >> SSB_ADM_SZ2_SHIFT);
+		break;
+	default:
+		SSB_WARN_ON(1);
+	}
+	size = (1 << (size + 1));
+
+	return size;
+}
+EXPORT_SYMBOL(ssb_admatch_size);
+
+static int __init ssb_modinit(void)
+{
+	int err;
+
+	ssb_is_early_boot = 0;
+	err = bus_register(&ssb_bustype);
+	if (err)
+		return err;
+
+	/* Maybe we already registered some buses at early boot.
+	 * Check for this and attach them
+	 */
+	ssb_buses_lock();
+	err = ssb_attach_queued_buses();
+	ssb_buses_unlock();
+	if (err)
+		bus_unregister(&ssb_bustype);
+
+	return err;
+}
+subsys_initcall(ssb_modinit);
+
+static void __exit ssb_modexit(void)
+{
+	bus_unregister(&ssb_bustype);
+}
+module_exit(ssb_modexit)
diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
new file mode 100644
index 0000000..5891783
--- /dev/null
+++ b/drivers/ssb/pci.c
@@ -0,0 +1,697 @@
+/*
+ * Sonics Silicon Backplane PCI-Hostbus related functions.
+ *
+ * Copyright (C) 2005-2006 Michael Buesch <mb at bu3sch.de>
+ * Copyright (C) 2005 Martin Langer <martin-langer at gmx.de>
+ * Copyright (C) 2005 Stefano Brivio <st3 at riseup.net>
+ * Copyright (C) 2005 Danny van Dyk <kugelfang at gentoo.org>
+ * Copyright (C) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+ *
+ * Derived from the Broadcom 4400 device driver.
+ * Copyright (C) 2002 David S. Miller (davem at redhat.com)
+ * Fixed by Pekka Pietikainen (pp at ee.oulu.fi)
+ * Copyright (C) 2006 Broadcom Corporation.
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include "ssb_private.h"
+
+
+/* Lowlevel coreswitching */
+int ssb_pci_switch_coreidx(struct ssb_bus *bus, u8 coreidx)
+{
+	int err;
+	int attempts = 0;
+	u32 cur_core;
+
+	while (1) {
+		err = pci_write_config_dword(bus->host_pci, SSB_BAR0_WIN,
+					     (coreidx * SSB_CORE_SIZE)
+					     + SSB_ENUM_BASE);
+		if (err)
+			goto error;
+		err = pci_read_config_dword(bus->host_pci, SSB_BAR0_WIN,
+					    &cur_core);
+		if (err)
+			goto error;
+		cur_core = (cur_core - SSB_ENUM_BASE)
+			   / SSB_CORE_SIZE;
+		if (cur_core == coreidx)
+			break;
+
+		if (attempts++ > SSB_BAR0_MAX_RETRIES)
+			goto error;
+		udelay(10);
+	}
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Failed to switch to core %u\n", coreidx);
+	return -ENODEV;
+}
+
+int ssb_pci_switch_core(struct ssb_bus *bus,
+			struct ssb_device *dev)
+{
+	int err;
+	unsigned long flags;
+
+	ssb_dprintk(KERN_INFO PFX
+		    "Switching to %s core, index %d\n",
+		    ssb_core_name(dev->id.coreid),
+		    dev->core_index);
+
+	spin_lock_irqsave(&bus->bar_lock, flags);
+	err = ssb_pci_switch_coreidx(bus, dev->core_index);
+	if (!err)
+		bus->mapped_device = dev;
+	spin_unlock_irqrestore(&bus->bar_lock, flags);
+
+	return err;
+}
+
+/* Enable/disable the on board crystal oscillator and/or PLL. */
+int ssb_pci_xtal(struct ssb_bus *bus, u32 what, int turn_on)
+{
+	int err;
+	u32 in, out, outenable;
+	u16 pci_status;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return 0;
+
+	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_IN, &in);
+	if (err)
+		goto err_pci;
+	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT, &out);
+	if (err)
+		goto err_pci;
+	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE, &outenable);
+	if (err)
+		goto err_pci;
+
+	outenable |= what;
+
+	if (turn_on) {
+		/* Avoid glitching the clock if GPRS is already using it.
+		 * We can't actually read the state of the PLLPD so we infer it
+		 * by the value of XTAL_PU which *is* readable via gpioin.
+		 */
+		if (!(in & SSB_GPIO_XTAL)) {
+			if (what & SSB_GPIO_XTAL) {
+				/* Turn the crystal on */
+				out |= SSB_GPIO_XTAL;
+				if (what & SSB_GPIO_PLL)
+					out |= SSB_GPIO_PLL;
+				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
+				if (err)
+					goto err_pci;
+				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE,
+							     outenable);
+				if (err)
+					goto err_pci;
+				msleep(1);
+			}
+			if (what & SSB_GPIO_PLL) {
+				/* Turn the PLL on */
+				out &= ~SSB_GPIO_PLL;
+				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
+				if (err)
+					goto err_pci;
+				msleep(5);
+			}
+		}
+
+		err = pci_read_config_word(bus->host_pci, PCI_STATUS, &pci_status);
+		if (err)
+			goto err_pci;
+		pci_status &= ~PCI_STATUS_SIG_TARGET_ABORT;
+		err = pci_write_config_word(bus->host_pci, PCI_STATUS, pci_status);
+		if (err)
+			goto err_pci;
+	} else {
+		if (what & SSB_GPIO_XTAL) {
+			/* Turn the crystal off */
+			out &= ~SSB_GPIO_XTAL;
+		}
+		if (what & SSB_GPIO_PLL) {
+			/* Turn the PLL off */
+			out |= SSB_GPIO_PLL;
+		}
+		err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
+		if (err)
+			goto err_pci;
+		err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE, outenable);
+		if (err)
+			goto err_pci;
+	}
+
+out:
+	return err;
+
+err_pci:
+	printk(KERN_ERR PFX "Error: ssb_pci_xtal() could not access PCI config space!\n");
+	err = -EBUSY;
+	goto out;
+}
+
+/* Get the word-offset for a SSB_SPROM_XXX define. */
+#define SPOFF(offset)	(((offset) - SSB_SPROM_BASE) / sizeof(u16))
+/* Helper to extract some _offset, which is one of the SSB_SPROM_XXX defines. */
+#define SPEX(_outvar, _offset, _mask, _shift)	\
+	out->_outvar = ((in[SPOFF(_offset)] & (_mask)) >> (_shift))
+
+static inline u8 ssb_crc8(u8 crc, u8 data)
+{
+	/* Polynomial:   x^8 + x^7 + x^6 + x^4 + x^2 + 1   */
+	static const u8 t[] = {
+		0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
+		0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
+		0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
+		0xDE, 0x29, 0x67, 0x90, 0xFB, 0x0C, 0x42, 0xB5,
+		0x7F, 0x88, 0xC6, 0x31, 0x5A, 0xAD, 0xE3, 0x14,
+		0x35, 0xC2, 0x8C, 0x7B, 0x10, 0xE7, 0xA9, 0x5E,
+		0xEB, 0x1C, 0x52, 0xA5, 0xCE, 0x39, 0x77, 0x80,
+		0xA1, 0x56, 0x18, 0xEF, 0x84, 0x73, 0x3D, 0xCA,
+		0xFE, 0x09, 0x47, 0xB0, 0xDB, 0x2C, 0x62, 0x95,
+		0xB4, 0x43, 0x0D, 0xFA, 0x91, 0x66, 0x28, 0xDF,
+		0x6A, 0x9D, 0xD3, 0x24, 0x4F, 0xB8, 0xF6, 0x01,
+		0x20, 0xD7, 0x99, 0x6E, 0x05, 0xF2, 0xBC, 0x4B,
+		0x81, 0x76, 0x38, 0xCF, 0xA4, 0x53, 0x1D, 0xEA,
+		0xCB, 0x3C, 0x72, 0x85, 0xEE, 0x19, 0x57, 0xA0,
+		0x15, 0xE2, 0xAC, 0x5B, 0x30, 0xC7, 0x89, 0x7E,
+		0x5F, 0xA8, 0xE6, 0x11, 0x7A, 0x8D, 0xC3, 0x34,
+		0xAB, 0x5C, 0x12, 0xE5, 0x8E, 0x79, 0x37, 0xC0,
+		0xE1, 0x16, 0x58, 0xAF, 0xC4, 0x33, 0x7D, 0x8A,
+		0x3F, 0xC8, 0x86, 0x71, 0x1A, 0xED, 0xA3, 0x54,
+		0x75, 0x82, 0xCC, 0x3B, 0x50, 0xA7, 0xE9, 0x1E,
+		0xD4, 0x23, 0x6D, 0x9A, 0xF1, 0x06, 0x48, 0xBF,
+		0x9E, 0x69, 0x27, 0xD0, 0xBB, 0x4C, 0x02, 0xF5,
+		0x40, 0xB7, 0xF9, 0x0E, 0x65, 0x92, 0xDC, 0x2B,
+		0x0A, 0xFD, 0xB3, 0x44, 0x2F, 0xD8, 0x96, 0x61,
+		0x55, 0xA2, 0xEC, 0x1B, 0x70, 0x87, 0xC9, 0x3E,
+		0x1F, 0xE8, 0xA6, 0x51, 0x3A, 0xCD, 0x83, 0x74,
+		0xC1, 0x36, 0x78, 0x8F, 0xE4, 0x13, 0x5D, 0xAA,
+		0x8B, 0x7C, 0x32, 0xC5, 0xAE, 0x59, 0x17, 0xE0,
+		0x2A, 0xDD, 0x93, 0x64, 0x0F, 0xF8, 0xB6, 0x41,
+		0x60, 0x97, 0xD9, 0x2E, 0x45, 0xB2, 0xFC, 0x0B,
+		0xBE, 0x49, 0x07, 0xF0, 0x9B, 0x6C, 0x22, 0xD5,
+		0xF4, 0x03, 0x4D, 0xBA, 0xD1, 0x26, 0x68, 0x9F,
+	};
+	return t[crc ^ data];
+}
+
+static u8 ssb_sprom_crc(const u16 *sprom)
+{
+	int word;
+	u8 crc = 0xFF;
+
+	for (word = 0; word < SSB_SPROMSIZE_WORDS - 1; word++) {
+		crc = ssb_crc8(crc, sprom[word] & 0x00FF);
+		crc = ssb_crc8(crc, (sprom[word] & 0xFF00) >> 8);
+	}
+	crc = ssb_crc8(crc, sprom[SPOFF(SSB_SPROM_REVISION)] & 0x00FF);
+	crc ^= 0xFF;
+
+	return crc;
+}
+
+static int sprom_check_crc(const u16 *sprom)
+{
+	u8 crc;
+	u8 expected_crc;
+	u16 tmp;
+
+	crc = ssb_sprom_crc(sprom);
+	tmp = sprom[SPOFF(SSB_SPROM_REVISION)] & SSB_SPROM_REVISION_CRC;
+	expected_crc = tmp >> SSB_SPROM_REVISION_CRC_SHIFT;
+	if (crc != expected_crc)
+		return -EPROTO;
+
+	return 0;
+}
+
+static void sprom_do_read(struct ssb_bus *bus, u16 *sprom)
+{
+	int i;
+
+	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++)
+		sprom[i] = readw(bus->mmio + SSB_SPROM_BASE + (i * 2));
+}
+
+static int sprom_do_write(struct ssb_bus *bus, const u16 *sprom)
+{
+	struct pci_dev *pdev = bus->host_pci;
+	int i, err;
+	u32 spromctl;
+
+	ssb_printk(KERN_NOTICE PFX "Writing SPROM. Do NOT turn off the power! Please stand by...\n");
+	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
+	if (err)
+		goto err_ctlreg;
+	spromctl |= SSB_SPROMCTL_WE;
+	err = pci_write_config_dword(pdev, SSB_SPROMCTL, spromctl);
+	if (err)
+		goto err_ctlreg;
+	ssb_printk(KERN_NOTICE PFX "[ 0%%");
+	msleep(500);
+	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
+		if (i == SSB_SPROMSIZE_WORDS / 4)
+			ssb_printk("25%%");
+		else if (i == SSB_SPROMSIZE_WORDS / 2)
+			ssb_printk("50%%");
+		else if (i == (SSB_SPROMSIZE_WORDS / 4) * 3)
+			ssb_printk("75%%");
+		else if (i % 2)
+			ssb_printk(".");
+		writew(sprom[i], bus->mmio + SSB_SPROM_BASE + (i * 2));
+		mmiowb();
+		msleep(20);
+	}
+	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
+	if (err)
+		goto err_ctlreg;
+	spromctl &= ~SSB_SPROMCTL_WE;
+	err = pci_write_config_dword(pdev, SSB_SPROMCTL, spromctl);
+	if (err)
+		goto err_ctlreg;
+	msleep(500);
+	ssb_printk("100%% ]\n");
+	ssb_printk(KERN_NOTICE PFX "SPROM written.\n");
+
+	return 0;
+err_ctlreg:
+	ssb_printk(KERN_ERR PFX "Could not access SPROM control register.\n");
+	return err;
+}
+
+static void sprom_extract_r1(struct ssb_sprom_r1 *out, const u16 *in)
+{
+	int i;
+	u16 v;
+
+	SPEX(pci_spid, SSB_SPROM1_SPID, 0xFFFF, 0);
+	SPEX(pci_svid, SSB_SPROM1_SVID, 0xFFFF, 0);
+	SPEX(pci_pid, SSB_SPROM1_PID, 0xFFFF, 0);
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
+		*(((u16 *)out->il0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_ET0MAC) + i];
+		*(((u16 *)out->et0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_ET1MAC) + i];
+		*(((u16 *)out->et1mac) + i) = cpu_to_be16(v);
+	}
+	SPEX(et0phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0A, 0);
+	SPEX(et1phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1A,
+	     SSB_SPROM1_ETHPHY_ET1A_SHIFT);
+	SPEX(et0mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0M, 14);
+	SPEX(et1mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1M, 15);
+	SPEX(board_rev, SSB_SPROM1_BINF, SSB_SPROM1_BINF_BREV, 0);
+	SPEX(country_code, SSB_SPROM1_BINF, SSB_SPROM1_BINF_CCODE,
+	     SSB_SPROM1_BINF_CCODE_SHIFT);
+	SPEX(antenna_a, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTA,
+	     SSB_SPROM1_BINF_ANTA_SHIFT);
+	SPEX(antenna_bg, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTBG,
+	     SSB_SPROM1_BINF_ANTBG_SHIFT);
+	SPEX(pa0b0, SSB_SPROM1_PA0B0, 0xFFFF, 0);
+	SPEX(pa0b1, SSB_SPROM1_PA0B1, 0xFFFF, 0);
+	SPEX(pa0b2, SSB_SPROM1_PA0B2, 0xFFFF, 0);
+	SPEX(pa1b0, SSB_SPROM1_PA1B0, 0xFFFF, 0);
+	SPEX(pa1b1, SSB_SPROM1_PA1B1, 0xFFFF, 0);
+	SPEX(pa1b2, SSB_SPROM1_PA1B2, 0xFFFF, 0);
+	SPEX(gpio0, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P0, 0);
+	SPEX(gpio1, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P1,
+	     SSB_SPROM1_GPIOA_P1_SHIFT);
+	SPEX(gpio2, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P2, 0);
+	SPEX(gpio3, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P3,
+	     SSB_SPROM1_GPIOB_P3_SHIFT);
+	SPEX(maxpwr_a, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_A,
+	     SSB_SPROM1_MAXPWR_A_SHIFT);
+	SPEX(maxpwr_bg, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_BG, 0);
+	SPEX(itssi_a, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_A,
+	     SSB_SPROM1_ITSSI_A_SHIFT);
+	SPEX(itssi_bg, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_BG, 0);
+	SPEX(boardflags_lo, SSB_SPROM1_BFLLO, 0xFFFF, 0);
+	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
+	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
+	     SSB_SPROM1_AGAIN_BG_SHIFT);
+	for (i = 0; i < 4; i++) {
+		v = in[SPOFF(SSB_SPROM1_OEM) + i];
+		*(((u16 *)out->oem) + i) = cpu_to_le16(v);
+	}
+}
+
+static void sprom_extract_r2(struct ssb_sprom_r2 *out, const u16 *in)
+{
+	int i;
+	u16 v;
+
+	SPEX(boardflags_hi, SSB_SPROM2_BFLHI,  0xFFFF, 0);
+	SPEX(maxpwr_a_hi, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_HI, 0);
+	SPEX(maxpwr_a_lo, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_LO,
+	     SSB_SPROM2_MAXP_A_LO_SHIFT);
+	SPEX(pa1lob0, SSB_SPROM2_PA1LOB0, 0xFFFF, 0);
+	SPEX(pa1lob1, SSB_SPROM2_PA1LOB1, 0xFFFF, 0);
+	SPEX(pa1lob2, SSB_SPROM2_PA1LOB2, 0xFFFF, 0);
+	SPEX(pa1hib0, SSB_SPROM2_PA1HIB0, 0xFFFF, 0);
+	SPEX(pa1hib1, SSB_SPROM2_PA1HIB1, 0xFFFF, 0);
+	SPEX(pa1hib2, SSB_SPROM2_PA1HIB2, 0xFFFF, 0);
+	SPEX(ofdm_pwr_off, SSB_SPROM2_OPO, SSB_SPROM2_OPO_VALUE, 0);
+	for (i = 0; i < 4; i++) {
+		v = in[SPOFF(SSB_SPROM2_CCODE) + i];
+		*(((u16 *)out->country_str) + i) = cpu_to_le16(v);
+	}
+}
+
+static void sprom_extract_r3(struct ssb_sprom_r3 *out, const u16 *in)
+{
+	out->ofdmapo  = (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0xFF00) >> 8;
+	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0x00FF) << 8;
+	out->ofdmapo <<= 16;
+	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0xFF00) >> 8;
+	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0x00FF) << 8;
+
+	out->ofdmalpo  = (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0xFF00) >> 8;
+	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0x00FF) << 8;
+	out->ofdmalpo <<= 16;
+	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0xFF00) >> 8;
+	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0x00FF) << 8;
+
+	out->ofdmahpo  = (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0xFF00) >> 8;
+	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0x00FF) << 8;
+	out->ofdmahpo <<= 16;
+	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0xFF00) >> 8;
+	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0x00FF) << 8;
+
+	SPEX(gpioldc_on_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_ON,
+	     SSB_SPROM3_GPIOLDC_ON_SHIFT);
+	SPEX(gpioldc_off_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_OFF,
+	     SSB_SPROM3_GPIOLDC_OFF_SHIFT);
+	SPEX(cckpo_1M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_1M, 0);
+	SPEX(cckpo_2M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_2M,
+	     SSB_SPROM3_CCKPO_2M_SHIFT);
+	SPEX(cckpo_55M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_55M,
+	     SSB_SPROM3_CCKPO_55M_SHIFT);
+	SPEX(cckpo_11M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_11M,
+	     SSB_SPROM3_CCKPO_11M_SHIFT);
+
+	out->ofdmgpo  = (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0xFF00) >> 8;
+	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0x00FF) << 8;
+	out->ofdmgpo <<= 16;
+	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0xFF00) >> 8;
+	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0x00FF) << 8;
+}
+
+static int sprom_extract(struct ssb_bus *bus,
+			 struct ssb_sprom *out, const u16 *in)
+{
+	memset(out, 0, sizeof(*out));
+
+	SPEX(revision, SSB_SPROM_REVISION, SSB_SPROM_REVISION_REV, 0);
+	SPEX(crc, SSB_SPROM_REVISION, SSB_SPROM_REVISION_CRC,
+	     SSB_SPROM_REVISION_CRC_SHIFT);
+
+	if ((bus->chip_id & 0xFF00) == 0x4400) {
+		/* Workaround: The BCM44XX chip has a stupid revision
+		 * number stored in the SPROM.
+		 * Always extract r1. */
+		sprom_extract_r1(&out->r1, in);
+	} else {
+		if (out->revision == 0)
+			goto unsupported;
+		if (out->revision >= 1 && out->revision <= 3)
+			sprom_extract_r1(&out->r1, in);
+		if (out->revision >= 2 && out->revision <= 3)
+			sprom_extract_r2(&out->r2, in);
+		if (out->revision == 3)
+			sprom_extract_r3(&out->r3, in);
+		if (out->revision >= 4)
+			goto unsupported;
+	}
+
+	return 0;
+unsupported:
+	ssb_printk(KERN_WARNING PFX "Unsupported SPROM revision %d "
+		   "detected. Will extract v1\n", out->revision);
+	sprom_extract_r1(&out->r1, in);
+	return 0;
+}
+
+static int ssb_pci_sprom_get(struct ssb_bus *bus,
+			     struct ssb_sprom *sprom)
+{
+	int err = -ENOMEM;
+	u16 *buf;
+
+	buf = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	if (!buf)
+		goto out;
+	sprom_do_read(bus, buf);
+	err = sprom_check_crc(buf);
+	if (err) {
+		ssb_printk(KERN_WARNING PFX
+			   "WARNING: Invalid SPROM CRC (corrupt SPROM)\n");
+	}
+	err = sprom_extract(bus, sprom, buf);
+
+	kfree(buf);
+out:
+	return err;
+}
+
+static void ssb_pci_get_boardinfo(struct ssb_bus *bus,
+				  struct ssb_boardinfo *bi)
+{
+	pci_read_config_word(bus->host_pci, PCI_SUBSYSTEM_VENDOR_ID,
+			     &bi->vendor);
+	pci_read_config_word(bus->host_pci, PCI_SUBSYSTEM_ID,
+			     &bi->type);
+	pci_read_config_word(bus->host_pci, PCI_REVISION_ID,
+			     &bi->rev);
+}
+
+int ssb_pci_get_invariants(struct ssb_bus *bus,
+			   struct ssb_init_invariants *iv)
+{
+	int err;
+
+	err = ssb_pci_sprom_get(bus, &iv->sprom);
+	if (err)
+		goto out;
+	ssb_pci_get_boardinfo(bus, &iv->boardinfo);
+
+out:
+	return err;
+}
+
+static u16 ssb_pci_read16(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return 0xFFFF;
+	}
+	return readw(bus->mmio + offset);
+}
+
+static u32 ssb_pci_read32(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return 0xFFFFFFFF;
+	}
+	return readl(bus->mmio + offset);
+}
+
+static void ssb_pci_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return;
+	}
+	writew(value, bus->mmio + offset);
+}
+
+static void ssb_pci_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return;
+	}
+	writel(value, bus->mmio + offset);
+}
+
+const struct ssb_bus_ops ssb_pci_ops = {
+	.read16		= ssb_pci_read16,
+	.read32		= ssb_pci_read32,
+	.write16	= ssb_pci_write16,
+	.write32	= ssb_pci_write32,
+};
+
+static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len)
+{
+	int i, pos = 0;
+
+	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
+		pos += snprintf(buf + pos, buf_len - pos - 1,
+				"%04X", swab16(sprom[i]) & 0xFFFF);
+	}
+	pos += snprintf(buf + pos, buf_len - pos - 1, "\n");
+
+	return pos + 1;
+}
+
+static int hex2sprom(u16 *sprom, const char *dump, size_t len)
+{
+	char tmp[5] = { 0 };
+	int cnt = 0;
+	unsigned long parsed;
+
+	if (len < SSB_SPROMSIZE_BYTES * 2)
+		return -EINVAL;
+
+	while (cnt < SSB_SPROMSIZE_WORDS) {
+		memcpy(tmp, dump, 4);
+		dump += 4;
+		parsed = simple_strtoul(tmp, NULL, 16);
+		sprom[cnt++] = swab16((u16)parsed);
+	}
+
+	return 0;
+}
+
+static ssize_t ssb_pci_attr_sprom_show(struct device *pcidev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	struct pci_dev *pdev = container_of(pcidev, struct pci_dev, dev);
+	struct ssb_bus *bus;
+	u16 *sprom;
+	int err = -ENODEV;
+	ssize_t count = 0;
+
+	bus = ssb_pci_dev_to_bus(pdev);
+	if (!bus)
+		goto out;
+	err = -ENOMEM;
+	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	if (!sprom)
+		goto out;
+
+	err = -ERESTARTSYS;
+	if (mutex_lock_interruptible(&bus->pci_sprom_mutex))
+		goto out_kfree;
+	sprom_do_read(bus, sprom);
+	mutex_unlock(&bus->pci_sprom_mutex);
+
+	count = sprom2hex(sprom, buf, PAGE_SIZE);
+	err = 0;
+
+out_kfree:
+	kfree(sprom);
+out:
+	return err ? err : count;
+}
+
+static ssize_t ssb_pci_attr_sprom_store(struct device *pcidev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct pci_dev *pdev = container_of(pcidev, struct pci_dev, dev);
+	struct ssb_bus *bus;
+	u16 *sprom;
+	int res = 0, err = -ENODEV;
+
+	bus = ssb_pci_dev_to_bus(pdev);
+	if (!bus)
+		goto out;
+	err = -ENOMEM;
+	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	if (!sprom)
+		goto out;
+	err = hex2sprom(sprom, buf, count);
+	if (err) {
+		err = -EINVAL;
+		goto out_kfree;
+	}
+	err = sprom_check_crc(sprom);
+	if (err) {
+		err = -EINVAL;
+		goto out_kfree;
+	}
+
+	err = -ERESTARTSYS;
+	if (mutex_lock_interruptible(&bus->pci_sprom_mutex))
+		goto out_kfree;
+	err = ssb_devices_freeze(bus);
+	if (err == -EOPNOTSUPP) {
+		ssb_printk(KERN_ERR PFX "SPROM write: Could not freeze devices. "
+			   "No suspend support. Is CONFIG_PM enabled?\n");
+		goto out_unlock;
+	}
+	if (err) {
+		ssb_printk(KERN_ERR PFX "SPROM write: Could not freeze all devices\n");
+		goto out_unlock;
+	}
+	res = sprom_do_write(bus, sprom);
+	err = ssb_devices_thaw(bus);
+	if (err)
+		ssb_printk(KERN_ERR PFX "SPROM write: Could not thaw all devices\n");
+out_unlock:
+	mutex_unlock(&bus->pci_sprom_mutex);
+out_kfree:
+	kfree(sprom);
+out:
+	if (res)
+		return res;
+	return err ? err : count;
+}
+
+static DEVICE_ATTR(ssb_sprom, 0600,
+		   ssb_pci_attr_sprom_show,
+		   ssb_pci_attr_sprom_store);
+
+void ssb_pci_exit(struct ssb_bus *bus)
+{
+	struct pci_dev *pdev;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return;
+
+	pdev = bus->host_pci;
+	device_remove_file(&pdev->dev, &dev_attr_ssb_sprom);
+}
+
+int ssb_pci_init(struct ssb_bus *bus)
+{
+	struct pci_dev *pdev;
+	int err;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return 0;
+
+	pdev = bus->host_pci;
+	mutex_init(&bus->pci_sprom_mutex);
+	err = device_create_file(&pdev->dev, &dev_attr_ssb_sprom);
+	if (err)
+		goto out;
+
+out:
+	return err;
+}
diff --git a/drivers/ssb/pcihost_wrapper.c b/drivers/ssb/pcihost_wrapper.c
new file mode 100644
index 0000000..82a10ab
--- /dev/null
+++ b/drivers/ssb/pcihost_wrapper.c
@@ -0,0 +1,104 @@
+/*
+ * Sonics Silicon Backplane
+ * PCI Hostdevice wrapper
+ *
+ * Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>
+ * Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+ * Copyright (c) 2005 Danny van Dyk <kugelfang at gentoo.org>
+ * Copyright (c) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+ * Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/pci.h>
+#include <linux/ssb/ssb.h>
+
+
+#ifdef CONFIG_PM
+static int ssb_pcihost_suspend(struct pci_dev *dev, pm_message_t state)
+{
+	pci_save_state(dev);
+	pci_disable_device(dev);
+	pci_set_power_state(dev, pci_choose_state(dev, state));
+
+	return 0;
+}
+
+static int ssb_pcihost_resume(struct pci_dev *dev)
+{
+	int err;
+
+	pci_set_power_state(dev, 0);
+	err = pci_enable_device(dev);
+	if (err)
+		return err;
+	pci_restore_state(dev);
+
+	return 0;
+}
+#else /* CONFIG_PM */
+# define ssb_pcihost_suspend	NULL
+# define ssb_pcihost_resume	NULL
+#endif /* CONFIG_PM */
+
+static int ssb_pcihost_probe(struct pci_dev *dev,
+			     const struct pci_device_id *id)
+{
+	struct ssb_bus *ssb;
+	int err = -ENOMEM;
+	const char *name;
+
+	ssb = kzalloc(sizeof(*ssb), GFP_KERNEL);
+	if (!ssb)
+		goto out;
+	err = pci_enable_device(dev);
+	if (err)
+		goto err_kfree_ssb;
+	name = dev->dev.bus_id;
+	if (dev->driver && dev->driver->name)
+		name = dev->driver->name;
+	err = pci_request_regions(dev, name);
+	if (err)
+		goto err_pci_disable;
+	pci_set_master(dev);
+
+	err = ssb_bus_pcibus_register(ssb, dev);
+	if (err)
+		goto err_pci_release_regions;
+
+	pci_set_drvdata(dev, ssb);
+
+out:
+	return err;
+
+err_pci_release_regions:
+	pci_release_regions(dev);
+err_pci_disable:
+	pci_disable_device(dev);
+err_kfree_ssb:
+	kfree(ssb);
+	return err;
+}
+
+static void ssb_pcihost_remove(struct pci_dev *dev)
+{
+	struct ssb_bus *ssb = pci_get_drvdata(dev);
+
+	ssb_bus_unregister(ssb);
+	pci_release_regions(dev);
+	pci_disable_device(dev);
+	kfree(ssb);
+	pci_set_drvdata(dev, NULL);
+}
+
+int ssb_pcihost_register(struct pci_driver *driver)
+{
+	driver->probe = ssb_pcihost_probe;
+	driver->remove = ssb_pcihost_remove;
+	driver->suspend = ssb_pcihost_suspend;
+	driver->resume = ssb_pcihost_resume;
+
+	return pci_register_driver(driver);
+}
+EXPORT_SYMBOL(ssb_pcihost_register);
diff --git a/drivers/ssb/pcmcia.c b/drivers/ssb/pcmcia.c
new file mode 100644
index 0000000..f72afd8
--- /dev/null
+++ b/drivers/ssb/pcmcia.c
@@ -0,0 +1,264 @@
+/*
+ * Sonics Silicon Backplane
+ * PCMCIA-Hostbus related functions
+ *
+ * Copyright 2006 Johannes Berg <johannes at sipsolutions.net>
+ * Copyright 2007 Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/delay.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ciscode.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/cisreg.h>
+
+#include "ssb_private.h"
+
+
+int ssb_pcmcia_switch_coreidx(struct ssb_bus *bus,
+			      u8 coreidx)
+{
+	struct pcmcia_device *pdev = bus->host_pcmcia;
+	int err;
+	int attempts = 0;
+	u32 cur_core;
+	conf_reg_t reg;
+	u32 addr;
+	u32 read_addr;
+
+	addr = (coreidx * SSB_CORE_SIZE) + SSB_ENUM_BASE;
+	while (1) {
+		reg.Action = CS_WRITE;
+		reg.Offset = 0x2E;
+		reg.Value = (addr & 0x0000F000) >> 12;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		reg.Offset = 0x30;
+		reg.Value = (addr & 0x00FF0000) >> 16;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		reg.Offset = 0x32;
+		reg.Value = (addr & 0xFF000000) >> 24;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+
+		read_addr = 0;
+
+		reg.Action = CS_READ;
+		reg.Offset = 0x2E;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		read_addr |= (reg.Value & 0xF) << 12;
+		reg.Offset = 0x30;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		read_addr |= reg.Value << 16;
+		reg.Offset = 0x32;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		read_addr |= reg.Value << 24;
+
+		cur_core = (read_addr - SSB_ENUM_BASE) / SSB_CORE_SIZE;
+		if (cur_core == coreidx)
+			break;
+
+		if (attempts++ > SSB_BAR0_MAX_RETRIES)
+			goto error;
+		udelay(10);
+	}
+
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Failed to switch to core %u\n", coreidx);
+	return -ENODEV;
+}
+
+int ssb_pcmcia_switch_core(struct ssb_bus *bus,
+			   struct ssb_device *dev)
+{
+	int err;
+	unsigned long flags;
+
+	ssb_dprintk(KERN_INFO PFX
+		    "Switching to %s core, index %d\n",
+		    ssb_core_name(dev->id.coreid),
+		    dev->core_index);
+
+	spin_lock_irqsave(&bus->bar_lock, flags);
+	err = ssb_pcmcia_switch_coreidx(bus, dev->core_index);
+	if (!err)
+		bus->mapped_device = dev;
+	spin_unlock_irqrestore(&bus->bar_lock, flags);
+
+	return err;
+}
+
+int ssb_pcmcia_switch_segment(struct ssb_bus *bus, u8 seg)
+{
+	int attempts = 0;
+	unsigned long flags;
+	conf_reg_t reg;
+	int res, err = 0;
+
+	SSB_WARN_ON((seg != 0) && (seg != 1));
+	reg.Offset = 0x34;
+	reg.Function = 0;
+	spin_lock_irqsave(&bus->bar_lock, flags);
+	while (1) {
+		reg.Action = CS_WRITE;
+		reg.Value = seg;
+		res = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+		if (unlikely(res != CS_SUCCESS))
+			goto error;
+		reg.Value = 0xFF;
+		reg.Action = CS_READ;
+		res = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+		if (unlikely(res != CS_SUCCESS))
+			goto error;
+
+		if (reg.Value == seg)
+			break;
+
+		if (unlikely(attempts++ > SSB_BAR0_MAX_RETRIES))
+			goto error;
+		udelay(10);
+	}
+	bus->mapped_pcmcia_seg = seg;
+out_unlock:
+	spin_unlock_irqrestore(&bus->bar_lock, flags);
+	return err;
+error:
+	ssb_printk(KERN_ERR PFX "Failed to switch pcmcia segment\n");
+	err = -ENODEV;
+	goto out_unlock;
+}
+
+/* These are the main device register access functions.
+ * do_select_core is inline to have the likely hotpath inline.
+ * All unlikely codepaths are out-of-line. */
+static inline int do_select_core(struct ssb_bus *bus,
+				 struct ssb_device *dev,
+				 u16 *offset)
+{
+	int err;
+	u8 need_seg = (*offset >= 0x800) ? 1 : 0;
+
+	if (unlikely(dev != bus->mapped_device)) {
+		err = ssb_pcmcia_switch_core(bus, dev);
+		if (unlikely(err))
+			return err;
+	}
+	if (unlikely(need_seg != bus->mapped_pcmcia_seg)) {
+		err = ssb_pcmcia_switch_segment(bus, need_seg);
+		if (unlikely(err))
+			return err;
+	}
+	if (need_seg == 1)
+		*offset -= 0x800;
+
+	return 0;
+}
+
+static u16 ssb_pcmcia_read16(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+	u16 x;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return 0xFFFF;
+	x = readw(bus->mmio + offset);
+
+	return x;
+}
+
+static u32 ssb_pcmcia_read32(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+	u32 x;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return 0xFFFFFFFF;
+	x = readl(bus->mmio + offset);
+
+	return x;
+}
+
+static void ssb_pcmcia_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return;
+	writew(value, bus->mmio + offset);
+}
+
+static void ssb_pcmcia_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return;
+	readw(bus->mmio + offset);
+	writew(value >> 16, bus->mmio + offset + 2);
+	readw(bus->mmio + offset);
+	writew(value, bus->mmio + offset);
+}
+
+const struct ssb_bus_ops ssb_pcmcia_ops = {
+	.read16		= ssb_pcmcia_read16,
+	.read32		= ssb_pcmcia_read32,
+	.write16	= ssb_pcmcia_write16,
+	.write32	= ssb_pcmcia_write32,
+};
+
+int ssb_pcmcia_get_invariants(struct ssb_bus *bus,
+			      struct ssb_init_invariants *iv)
+{
+	//TODO
+	return 0;
+}
+
+int ssb_pcmcia_init(struct ssb_bus *bus)
+{
+	conf_reg_t reg;
+	int err;
+
+	if (bus->bustype != SSB_BUSTYPE_PCMCIA)
+		return 0;
+
+	/* Switch segment to a known state and sync
+	 * bus->mapped_pcmcia_seg with hardware state. */
+	ssb_pcmcia_switch_segment(bus, 0);
+
+	/* Init IRQ routing */
+	reg.Action = CS_READ;
+	reg.Function = 0;
+	if (bus->chip_id == 0x4306)
+		reg.Offset = 0x00;
+	else
+		reg.Offset = 0x80;
+	err = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+	if (err != CS_SUCCESS)
+		goto error;
+	reg.Action = CS_WRITE;
+	reg.Value |= 0x04 | 0x01;
+	err = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+	if (err != CS_SUCCESS)
+		goto error;
+
+	return 0;
+error:
+	return -ENODEV;
+}
diff --git a/drivers/ssb/scan.c b/drivers/ssb/scan.c
new file mode 100644
index 0000000..9c33425
--- /dev/null
+++ b/drivers/ssb/scan.c
@@ -0,0 +1,413 @@
+/*
+ * Sonics Silicon Backplane
+ * Bus scanning
+ *
+ * Copyright (C) 2005-2007 Michael Buesch <mb at bu3sch.de>
+ * Copyright (C) 2005 Martin Langer <martin-langer at gmx.de>
+ * Copyright (C) 2005 Stefano Brivio <st3 at riseup.net>
+ * Copyright (C) 2005 Danny van Dyk <kugelfang at gentoo.org>
+ * Copyright (C) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+ * Copyright (C) 2006 Broadcom Corporation.
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+#include <linux/pci.h>
+#include <linux/io.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+
+#include "ssb_private.h"
+
+
+const char * ssb_core_name(u16 coreid)
+{
+	switch (coreid) {
+	case SSB_DEV_CHIPCOMMON:
+		return "ChipCommon";
+	case SSB_DEV_ILINE20:
+		return "ILine 20";
+	case SSB_DEV_SDRAM:
+		return "SDRAM";
+	case SSB_DEV_PCI:
+		return "PCI";
+	case SSB_DEV_MIPS:
+		return "MIPS";
+	case SSB_DEV_ETHERNET:
+		return "Fast Ethernet";
+	case SSB_DEV_V90:
+		return "V90";
+	case SSB_DEV_USB11_HOSTDEV:
+		return "USB 1.1 Hostdev";
+	case SSB_DEV_ADSL:
+		return "ADSL";
+	case SSB_DEV_ILINE100:
+		return "ILine 100";
+	case SSB_DEV_IPSEC:
+		return "IPSEC";
+	case SSB_DEV_PCMCIA:
+		return "PCMCIA";
+	case SSB_DEV_INTERNAL_MEM:
+		return "Internal Memory";
+	case SSB_DEV_MEMC_SDRAM:
+		return "MEMC SDRAM";
+	case SSB_DEV_EXTIF:
+		return "EXTIF";
+	case SSB_DEV_80211:
+		return "IEEE 802.11";
+	case SSB_DEV_MIPS_3302:
+		return "MIPS 3302";
+	case SSB_DEV_USB11_HOST:
+		return "USB 1.1 Host";
+	case SSB_DEV_USB11_DEV:
+		return "USB 1.1 Device";
+	case SSB_DEV_USB20_HOST:
+		return "USB 2.0 Host";
+	case SSB_DEV_USB20_DEV:
+		return "USB 2.0 Device";
+	case SSB_DEV_SDIO_HOST:
+		return "SDIO Host";
+	case SSB_DEV_ROBOSWITCH:
+		return "Roboswitch";
+	case SSB_DEV_PARA_ATA:
+		return "PATA";
+	case SSB_DEV_SATA_XORDMA:
+		return "SATA XOR-DMA";
+	case SSB_DEV_ETHERNET_GBIT:
+		return "GBit Ethernet";
+	case SSB_DEV_PCIE:
+		return "PCI-E";
+	case SSB_DEV_MIMO_PHY:
+		return "MIMO PHY";
+	case SSB_DEV_SRAM_CTRLR:
+		return "SRAM Controller";
+	case SSB_DEV_MINI_MACPHY:
+		return "Mini MACPHY";
+	case SSB_DEV_ARM_1176:
+		return "ARM 1176";
+	case SSB_DEV_ARM_7TDMI:
+		return "ARM 7TDMI";
+	}
+	return "UNKNOWN";
+}
+
+static u16 pcidev_to_chipid(struct pci_dev *pci_dev)
+{
+	u16 chipid_fallback = 0;
+
+	switch (pci_dev->device) {
+	case 0x4301:
+		chipid_fallback = 0x4301;
+		break;
+	case 0x4305 ... 0x4307:
+		chipid_fallback = 0x4307;
+		break;
+	case 0x4403:
+		chipid_fallback = 0x4402;
+		break;
+	case 0x4610 ... 0x4615:
+		chipid_fallback = 0x4610;
+		break;
+	case 0x4710 ... 0x4715:
+		chipid_fallback = 0x4710;
+		break;
+	case 0x4320 ... 0x4325:
+		chipid_fallback = 0x4309;
+		break;
+	case PCI_DEVICE_ID_BCM4401:
+	case PCI_DEVICE_ID_BCM4401B0:
+	case PCI_DEVICE_ID_BCM4401B1:
+		chipid_fallback = 0x4401;
+		break;
+	default:
+		ssb_printk(KERN_ERR PFX
+			   "PCI-ID not in fallback list\n");
+	}
+
+	return chipid_fallback;
+}
+
+static u8 chipid_to_nrcores(u16 chipid)
+{
+	switch (chipid) {
+	case 0x5365:
+		return 7;
+	case 0x4306:
+		return 6;
+	case 0x4310:
+		return 8;
+	case 0x4307:
+	case 0x4301:
+		return 5;
+	case 0x4401:
+	case 0x4402:
+		return 3;
+	case 0x4710:
+	case 0x4610:
+	case 0x4704:
+		return 9;
+	default:
+		ssb_printk(KERN_ERR PFX
+			   "CHIPID not in nrcores fallback list\n");
+	}
+
+	return 1;
+}
+
+static u32 scan_read32(struct ssb_bus *bus, u8 current_coreidx,
+		       u16 offset)
+{
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		offset += current_coreidx * SSB_CORE_SIZE;
+		break;
+	case SSB_BUSTYPE_PCI:
+		break;
+	case SSB_BUSTYPE_PCMCIA:
+		if (offset >= 0x800) {
+			ssb_pcmcia_switch_segment(bus, 1);
+			offset -= 0x800;
+		} else
+			ssb_pcmcia_switch_segment(bus, 0);
+		break;
+	}
+	return readl(bus->mmio + offset);
+}
+
+static int scan_switchcore(struct ssb_bus *bus, u8 coreidx)
+{
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		break;
+	case SSB_BUSTYPE_PCI:
+		return ssb_pci_switch_coreidx(bus, coreidx);
+	case SSB_BUSTYPE_PCMCIA:
+		return ssb_pcmcia_switch_coreidx(bus, coreidx);
+	}
+	return 0;
+}
+
+void ssb_iounmap(struct ssb_bus *bus)
+{
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+	case SSB_BUSTYPE_PCMCIA:
+		iounmap(bus->mmio);
+		break;
+	case SSB_BUSTYPE_PCI:
+#ifdef CONFIG_SSB_PCIHOST
+		pci_iounmap(bus->host_pci, bus->mmio);
+#else
+		SSB_BUG_ON(1); /* Can't reach this code. */
+#endif
+		break;
+	}
+	bus->mmio = NULL;
+	bus->mapped_device = NULL;
+}
+
+static void __iomem * ssb_ioremap(struct ssb_bus *bus,
+				  unsigned long baseaddr)
+{
+	void __iomem *mmio = NULL;
+
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		/* Only map the first core for now. */
+		/* fallthrough... */
+	case SSB_BUSTYPE_PCMCIA:
+		mmio = ioremap(baseaddr, SSB_CORE_SIZE);
+		break;
+	case SSB_BUSTYPE_PCI:
+#ifdef CONFIG_SSB_PCIHOST
+		mmio = pci_iomap(bus->host_pci, 0, ~0UL);
+#else
+		SSB_BUG_ON(1); /* Can't reach this code. */
+#endif
+		break;
+	}
+
+	return mmio;
+}
+
+static int we_support_multiple_80211_cores(struct ssb_bus *bus)
+{
+	/* More than one 802.11 core is only supported by special chips.
+	 * There are chips with two 802.11 cores, but with dangling
+	 * pins on the second core. Be careful and reject them here.
+	 */
+
+#ifdef CONFIG_SSB_PCIHOST
+	if (bus->bustype == SSB_BUSTYPE_PCI) {
+		if (bus->host_pci->vendor == PCI_VENDOR_ID_BROADCOM &&
+		    bus->host_pci->device == 0x4324)
+			return 1;
+	}
+#endif /* CONFIG_SSB_PCIHOST */
+	return 0;
+}
+
+int ssb_bus_scan(struct ssb_bus *bus,
+		 unsigned long baseaddr)
+{
+	int err = -ENOMEM;
+	void __iomem *mmio;
+	u32 idhi, cc, rev, tmp;
+	int dev_i, i;
+	struct ssb_device *dev;
+	int nr_80211_cores = 0;
+
+	mmio = ssb_ioremap(bus, baseaddr);
+	if (!mmio)
+		goto out;
+	bus->mmio = mmio;
+
+	err = scan_switchcore(bus, 0); /* Switch to first core */
+	if (err)
+		goto err_unmap;
+
+	idhi = scan_read32(bus, 0, SSB_IDHIGH);
+	cc = (idhi & SSB_IDHIGH_CC) >> SSB_IDHIGH_CC_SHIFT;
+	rev = (idhi & SSB_IDHIGH_RCLO);
+	rev |= (idhi & SSB_IDHIGH_RCHI) >> SSB_IDHIGH_RCHI_SHIFT;
+
+	bus->nr_devices = 0;
+	if (cc == SSB_DEV_CHIPCOMMON) {
+		tmp = scan_read32(bus, 0, SSB_CHIPCO_CHIPID);
+
+		bus->chip_id = (tmp & SSB_CHIPCO_IDMASK);
+		bus->chip_rev = (tmp & SSB_CHIPCO_REVMASK) >>
+				SSB_CHIPCO_REVSHIFT;
+		bus->chip_package = (tmp & SSB_CHIPCO_PACKMASK) >>
+				    SSB_CHIPCO_PACKSHIFT;
+		if (rev >= 4) {
+			bus->nr_devices = (tmp & SSB_CHIPCO_NRCORESMASK) >>
+					  SSB_CHIPCO_NRCORESSHIFT;
+		}
+		tmp = scan_read32(bus, 0, SSB_CHIPCO_CAP);
+		bus->chipco.capabilities = tmp;
+	} else {
+		if (bus->bustype == SSB_BUSTYPE_PCI) {
+			bus->chip_id = pcidev_to_chipid(bus->host_pci);
+			pci_read_config_word(bus->host_pci, PCI_REVISION_ID,
+					     &bus->chip_rev);
+			bus->chip_package = 0;
+		} else {
+			bus->chip_id = 0x4710;
+			bus->chip_rev = 0;
+			bus->chip_package = 0;
+		}
+	}
+	if (!bus->nr_devices)
+		bus->nr_devices = chipid_to_nrcores(bus->chip_id);
+	if (bus->nr_devices > ARRAY_SIZE(bus->devices)) {
+		ssb_printk(KERN_ERR PFX
+			   "More than %d ssb cores found (%d)\n",
+			   SSB_MAX_NR_CORES, bus->nr_devices);
+		goto err_unmap;
+	}
+	if (bus->bustype == SSB_BUSTYPE_SSB) {
+		/* Now that we know the number of cores,
+		 * remap the whole IO space for all cores.
+		 */
+		err = -ENOMEM;
+		iounmap(mmio);
+		mmio = ioremap(baseaddr, SSB_CORE_SIZE * bus->nr_devices);
+		if (!mmio)
+			goto out;
+		bus->mmio = mmio;
+	}
+
+	/* Fetch basic information about each core/device */
+	for (i = 0, dev_i = 0; i < bus->nr_devices; i++) {
+		err = scan_switchcore(bus, i);
+		if (err)
+			goto err_unmap;
+		dev = &(bus->devices[dev_i]);
+
+		idhi = scan_read32(bus, i, SSB_IDHIGH);
+		dev->id.coreid = (idhi & SSB_IDHIGH_CC) >> SSB_IDHIGH_CC_SHIFT;
+		dev->id.revision = (idhi & SSB_IDHIGH_RCLO);
+		dev->id.revision |= (idhi & SSB_IDHIGH_RCHI) >> SSB_IDHIGH_RCHI_SHIFT;
+		dev->id.vendor = (idhi & SSB_IDHIGH_VC) >> SSB_IDHIGH_VC_SHIFT;
+		dev->core_index = i;
+		dev->bus = bus;
+		dev->ops = bus->ops;
+
+		ssb_dprintk(KERN_INFO PFX
+			    "Core %d found: %s "
+			    "(cc 0x%03X, rev 0x%02X, vendor 0x%04X)\n",
+			    i, ssb_core_name(dev->id.coreid),
+			    dev->id.coreid, dev->id.revision, dev->id.vendor);
+
+		switch (dev->id.coreid) {
+		case SSB_DEV_80211:
+			nr_80211_cores++;
+			if (nr_80211_cores > 1) {
+				if (!we_support_multiple_80211_cores(bus)) {
+					ssb_dprintk(KERN_INFO PFX "Ignoring additional "
+						    "802.11 core\n");
+					continue;
+				}
+			}
+			break;
+		case SSB_DEV_EXTIF:
+#ifdef CONFIG_SSB_DRIVER_EXTIF
+			if (bus->extif.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple EXTIFs found\n");
+				break;
+			}
+			bus->extif.dev = dev;
+#endif /* CONFIG_SSB_DRIVER_EXTIF */
+			break;
+		case SSB_DEV_CHIPCOMMON:
+			if (bus->chipco.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple ChipCommon found\n");
+				break;
+			}
+			bus->chipco.dev = dev;
+			break;
+		case SSB_DEV_MIPS:
+		case SSB_DEV_MIPS_3302:
+#ifdef CONFIG_SSB_DRIVER_MIPS
+			if (bus->mipscore.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple MIPS cores found\n");
+				break;
+			}
+			bus->mipscore.dev = dev;
+#endif /* CONFIG_SSB_DRIVER_MIPS */
+			break;
+		case SSB_DEV_PCI:
+		case SSB_DEV_PCIE:
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+			if (bus->pcicore.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple PCI(E) cores found\n");
+				break;
+			}
+			bus->pcicore.dev = dev;
+#endif /* CONFIG_SSB_DRIVER_PCICORE */
+			break;
+		default:
+			break;
+		}
+
+		dev_i++;
+	}
+	bus->nr_devices = dev_i;
+
+	err = 0;
+out:
+	return err;
+err_unmap:
+	ssb_iounmap(bus);
+	goto out;
+}
diff --git a/drivers/ssb/ssb_private.h b/drivers/ssb/ssb_private.h
new file mode 100644
index 0000000..8e2e310
--- /dev/null
+++ b/drivers/ssb/ssb_private.h
@@ -0,0 +1,121 @@
+#ifndef LINUX_SSB_PRIVATE_H_
+#define LINUX_SSB_PRIVATE_H_
+
+#include <linux/ssb/ssb.h>
+#include <linux/types.h>
+
+
+#define PFX	"ssb: "
+
+#ifdef CONFIG_SSB_SILENT
+# define ssb_printk(fmt, x...)	do { /* nothing */ } while (0)
+#else
+# define ssb_printk		printk
+#endif /* CONFIG_SSB_SILENT */
+
+/* dprintk: Debugging printk; vanishes for non-debug compilation */
+#ifdef CONFIG_SSB_DEBUG
+# define ssb_dprintk(fmt, x...)	ssb_printk(fmt , ##x)
+#else
+# define ssb_dprintk(fmt, x...)	do { /* nothing */ } while (0)
+#endif
+
+#ifdef CONFIG_SSB_DEBUG
+# define SSB_WARN_ON(x)		WARN_ON(x)
+# define SSB_BUG_ON(x)		BUG_ON(x)
+#else
+# define SSB_WARN_ON(x)		do { /* nothing */ } while (0)
+# define SSB_BUG_ON(x)		do { /* nothing */ } while (0)
+#endif
+
+
+/* pci.c */
+#ifdef CONFIG_SSB_PCIHOST
+extern int ssb_pci_switch_core(struct ssb_bus *bus,
+			       struct ssb_device *dev);
+extern int ssb_pci_switch_coreidx(struct ssb_bus *bus,
+				  u8 coreidx);
+extern int ssb_pci_xtal(struct ssb_bus *bus, u32 what,
+			int turn_on);
+extern int ssb_pci_get_invariants(struct ssb_bus *bus,
+				  struct ssb_init_invariants *iv);
+extern void ssb_pci_exit(struct ssb_bus *bus);
+extern int ssb_pci_init(struct ssb_bus *bus);
+extern const struct ssb_bus_ops ssb_pci_ops;
+
+#else /* CONFIG_SSB_PCIHOST */
+
+static inline int ssb_pci_switch_core(struct ssb_bus *bus,
+				      struct ssb_device *dev)
+{
+	return 0;
+}
+static inline int ssb_pci_switch_coreidx(struct ssb_bus *bus,
+					 u8 coreidx)
+{
+	return 0;
+}
+static inline int ssb_pci_xtal(struct ssb_bus *bus, u32 what,
+			       int turn_on)
+{
+	return 0;
+}
+static inline void ssb_pci_exit(struct ssb_bus *bus)
+{
+}
+static inline int ssb_pci_init(struct ssb_bus *bus)
+{
+	return 0;
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+
+/* pcmcia.c */
+#ifdef CONFIG_SSB_PCMCIAHOST
+extern int ssb_pcmcia_switch_core(struct ssb_bus *bus,
+				  struct ssb_device *dev);
+extern int ssb_pcmcia_switch_coreidx(struct ssb_bus *bus,
+				     u8 coreidx);
+extern int ssb_pcmcia_switch_segment(struct ssb_bus *bus,
+				     u8 seg);
+extern int ssb_pcmcia_get_invariants(struct ssb_bus *bus,
+				     struct ssb_init_invariants *iv);
+extern int ssb_pcmcia_init(struct ssb_bus *bus);
+extern const struct ssb_bus_ops ssb_pcmcia_ops;
+#else /* CONFIG_SSB_PCMCIAHOST */
+static inline int ssb_pcmcia_switch_core(struct ssb_bus *bus,
+					 struct ssb_device *dev)
+{
+	return 0;
+}
+static inline int ssb_pcmcia_switch_coreidx(struct ssb_bus *bus,
+					    u8 coreidx)
+{
+	return 0;
+}
+static inline int ssb_pcmcia_switch_segment(struct ssb_bus *bus,
+					    u8 seg)
+{
+	return 0;
+}
+static inline int ssb_pcmcia_init(struct ssb_bus *bus)
+{
+	return 0;
+}
+#endif /* CONFIG_SSB_PCMCIAHOST */
+
+
+/* scan.c */
+extern const char * ssb_core_name(u16 coreid);
+extern int ssb_bus_scan(struct ssb_bus *bus,
+			unsigned long baseaddr);
+extern void ssb_iounmap(struct ssb_bus *ssb);
+
+
+/* core.c */
+extern u32 ssb_calc_clock_rate(u32 plltype, u32 n, u32 m);
+extern int ssb_devices_freeze(struct ssb_bus *bus);
+extern int ssb_devices_thaw(struct ssb_bus *bus);
+extern struct ssb_bus * ssb_pci_dev_to_bus(struct pci_dev *pdev);
+
+#endif /* LINUX_SSB_PRIVATE_H_ */
diff --git a/include/linux/ssb/ssb_driver_chipcommon.h b/include/linux/ssb/ssb_driver_chipcommon.h
new file mode 100644
index 0000000..d58c24b
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_chipcommon.h
@@ -0,0 +1,385 @@
+#ifndef LINUX_SSB_CHIPCO_H_
+#define LINUX_SSB_CHIPCO_H_
+
+/* SonicsSiliconBackplane CHIPCOMMON core hardware definitions
+ *
+ * The chipcommon core provides chip identification, SB control,
+ * jtag, 0/1/2 uarts, clock frequency control, a watchdog interrupt timer,
+ * gpio interface, extbus, and support for serial and parallel flashes.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GPL version 2. See COPYING for details.
+ */
+
+/** ChipCommon core registers. **/
+
+#define SSB_CHIPCO_CHIPID		0x0000
+#define  SSB_CHIPCO_IDMASK		0x0000FFFF
+#define  SSB_CHIPCO_REVMASK		0x000F0000
+#define  SSB_CHIPCO_REVSHIFT		16
+#define  SSB_CHIPCO_PACKMASK		0x00F00000
+#define  SSB_CHIPCO_PACKSHIFT		20
+#define  SSB_CHIPCO_NRCORESMASK		0x0F000000
+#define  SSB_CHIPCO_NRCORESSHIFT	24
+#define SSB_CHIPCO_CAP	 		0x0004		/* Capabilities */
+#define  SSB_CHIPCO_CAP_NRUART		0x00000003	/* # of UARTs */
+#define  SSB_CHIPCO_CAP_MIPSEB		0x00000004	/* MIPS in BigEndian Mode */
+#define  SSB_CHIPCO_CAP_UARTCLK		0x00000018	/* UART clock select */
+#define   SSB_CHIPCO_CAP_UARTCLK_INT	0x00000008	/* UARTs are driven by internal divided clock */
+#define  SSB_CHIPCO_CAP_UARTGPIO	0x00000020	/* UARTs on GPIO 15-12 */
+#define  SSB_CHIPCO_CAP_EXTBUS		0x000000C0	/* External buses present */
+#define  SSB_CHIPCO_CAP_FLASHT		0x00000700	/* Flash Type */
+#define   SSB_CHIPCO_FLASHT_NONE	0x00000000	/* No flash */
+#define   SSB_CHIPCO_FLASHT_STSER	0x00000100	/* ST serial flash */
+#define   SSB_CHIPCO_FLASHT_ATSER	0x00000200	/* Atmel serial flash */
+#define	  SSB_CHIPCO_FLASHT_PARA	0x00000700	/* Parallel flash */
+#define  SSB_CHIPCO_CAP_PLLT		0x00038000	/* PLL Type */
+#define   SSB_PLLTYPE_NONE		0x00000000
+#define   SSB_PLLTYPE_1			0x00010000	/* 48Mhz base, 3 dividers */
+#define   SSB_PLLTYPE_2			0x00020000	/* 48Mhz, 4 dividers */
+#define   SSB_PLLTYPE_3			0x00030000	/* 25Mhz, 2 dividers */
+#define   SSB_PLLTYPE_4			0x00008000	/* 48Mhz, 4 dividers */
+#define   SSB_PLLTYPE_5			0x00018000	/* 25Mhz, 4 dividers */
+#define   SSB_PLLTYPE_6			0x00028000	/* 100/200 or 120/240 only */
+#define   SSB_PLLTYPE_7			0x00038000	/* 25Mhz, 4 dividers */
+#define  SSB_CHIPCO_CAP_PCTL		0x00040000	/* Power Control */
+#define  SSB_CHIPCO_CAP_OTPS		0x00380000	/* OTP size */
+#define  SSB_CHIPCO_CAP_OTPS_SHIFT	19
+#define  SSB_CHIPCO_CAP_OTPS_BASE	5
+#define  SSB_CHIPCO_CAP_JTAGM		0x00400000	/* JTAG master present */
+#define  SSB_CHIPCO_CAP_BROM		0x00800000	/* Internal boot ROM active */
+#define  SSB_CHIPCO_CAP_64BIT		0x08000000	/* 64-bit Backplane */
+#define SSB_CHIPCO_CORECTL		0x0008
+#define  SSB_CHIPCO_CORECTL_UARTCLK0	0x00000001	/* Drive UART with internal clock */
+#define	 SSB_CHIPCO_CORECTL_SE		0x00000002	/* sync clk out enable (corerev >= 3) */
+#define SSB_CHIPCO_BIST			0x000C
+#define SSB_CHIPCO_OTPS			0x0010		/* OTP status */
+#define	 SSB_CHIPCO_OTPS_PROGFAIL	0x80000000
+#define	 SSB_CHIPCO_OTPS_PROTECT	0x00000007
+#define	 SSB_CHIPCO_OTPS_HW_PROTECT	0x00000001
+#define	 SSB_CHIPCO_OTPS_SW_PROTECT	0x00000002
+#define	 SSB_CHIPCO_OTPS_CID_PROTECT	0x00000004
+#define SSB_CHIPCO_OTPC			0x0014		/* OTP control */
+#define	 SSB_CHIPCO_OTPC_RECWAIT	0xFF000000
+#define	 SSB_CHIPCO_OTPC_PROGWAIT	0x00FFFF00
+#define	 SSB_CHIPCO_OTPC_PRW_SHIFT	8
+#define	 SSB_CHIPCO_OTPC_MAXFAIL	0x00000038
+#define	 SSB_CHIPCO_OTPC_VSEL		0x00000006
+#define	 SSB_CHIPCO_OTPC_SELVL		0x00000001
+#define SSB_CHIPCO_OTPP			0x0018		/* OTP prog */
+#define	 SSB_CHIPCO_OTPP_COL		0x000000FF
+#define	 SSB_CHIPCO_OTPP_ROW		0x0000FF00
+#define	 SSB_CHIPCO_OTPP_ROW_SHIFT	8
+#define	 SSB_CHIPCO_OTPP_READERR	0x10000000
+#define	 SSB_CHIPCO_OTPP_VALUE		0x20000000
+#define	 SSB_CHIPCO_OTPP_READ		0x40000000
+#define	 SSB_CHIPCO_OTPP_START		0x80000000
+#define	 SSB_CHIPCO_OTPP_BUSY		0x80000000
+#define SSB_CHIPCO_IRQSTAT		0x0020
+#define SSB_CHIPCO_IRQMASK		0x0024
+#define	 SSB_CHIPCO_IRQ_GPIO		0x00000001	/* gpio intr */
+#define	 SSB_CHIPCO_IRQ_EXT		0x00000002	/* ro: ext intr pin (corerev >= 3) */
+#define	 SSB_CHIPCO_IRQ_WDRESET		0x80000000	/* watchdog reset occurred */
+#define SSB_CHIPCO_CHIPCTL		0x0028		/* Rev >= 11 only */
+#define SSB_CHIPCO_CHIPSTAT		0x002C		/* Rev >= 11 only */
+#define SSB_CHIPCO_JCMD			0x0030		/* Rev >= 10 only */
+#define  SSB_CHIPCO_JCMD_START		0x80000000
+#define  SSB_CHIPCO_JCMD_BUSY		0x80000000
+#define  SSB_CHIPCO_JCMD_PAUSE		0x40000000
+#define  SSB_CHIPCO_JCMD0_ACC_MASK	0x0000F000
+#define  SSB_CHIPCO_JCMD0_ACC_IRDR	0x00000000
+#define  SSB_CHIPCO_JCMD0_ACC_DR	0x00001000
+#define  SSB_CHIPCO_JCMD0_ACC_IR	0x00002000
+#define  SSB_CHIPCO_JCMD0_ACC_RESET	0x00003000
+#define  SSB_CHIPCO_JCMD0_ACC_IRPDR	0x00004000
+#define  SSB_CHIPCO_JCMD0_ACC_PDR	0x00005000
+#define  SSB_CHIPCO_JCMD0_IRW_MASK	0x00000F00
+#define  SSB_CHIPCO_JCMD_ACC_MASK	0x000F0000	/* Changes for corerev 11 */
+#define  SSB_CHIPCO_JCMD_ACC_IRDR	0x00000000
+#define  SSB_CHIPCO_JCMD_ACC_DR		0x00010000
+#define  SSB_CHIPCO_JCMD_ACC_IR		0x00020000
+#define  SSB_CHIPCO_JCMD_ACC_RESET	0x00030000
+#define  SSB_CHIPCO_JCMD_ACC_IRPDR	0x00040000
+#define  SSB_CHIPCO_JCMD_ACC_PDR	0x00050000
+#define  SSB_CHIPCO_JCMD_IRW_MASK	0x00001F00
+#define  SSB_CHIPCO_JCMD_IRW_SHIFT	8
+#define  SSB_CHIPCO_JCMD_DRW_MASK	0x0000003F
+#define SSB_CHIPCO_JIR			0x0034		/* Rev >= 10 only */
+#define SSB_CHIPCO_JDR			0x0038		/* Rev >= 10 only */
+#define SSB_CHIPCO_JCTL			0x003C		/* Rev >= 10 only */
+#define  SSB_CHIPCO_JCTL_FORCE_CLK	4		/* Force clock */
+#define  SSB_CHIPCO_JCTL_EXT_EN		2		/* Enable external targets */
+#define  SSB_CHIPCO_JCTL_EN		1		/* Enable Jtag master */
+#define SSB_CHIPCO_FLASHCTL		0x0040
+#define  SSB_CHIPCO_FLASHCTL_START	0x80000000
+#define  SSB_CHIPCO_FLASHCTL_BUSY	SSB_CHIPCO_FLASHCTL_START
+#define SSB_CHIPCO_FLASHADDR		0x0044
+#define SSB_CHIPCO_FLASHDATA		0x0048
+#define SSB_CHIPCO_BCAST_ADDR		0x0050
+#define SSB_CHIPCO_BCAST_DATA		0x0054
+#define SSB_CHIPCO_GPIOIN		0x0060
+#define SSB_CHIPCO_GPIOOUT		0x0064
+#define SSB_CHIPCO_GPIOOUTEN		0x0068
+#define SSB_CHIPCO_GPIOCTL		0x006C
+#define SSB_CHIPCO_GPIOPOL		0x0070
+#define SSB_CHIPCO_GPIOIRQ		0x0074
+#define SSB_CHIPCO_WATCHDOG		0x0080
+#define SSB_CHIPCO_GPIOTIMER		0x0088		/* LED powersave (corerev >= 16) */
+#define  SSB_CHIPCO_GPIOTIMER_ONTIME_SHIFT	16
+#define SSB_CHIPCO_GPIOTOUTM		0x008C		/* LED powersave (corerev >= 16) */
+#define SSB_CHIPCO_CLOCK_N		0x0090
+#define SSB_CHIPCO_CLOCK_SB		0x0094
+#define SSB_CHIPCO_CLOCK_PCI		0x0098
+#define SSB_CHIPCO_CLOCK_M2		0x009C
+#define SSB_CHIPCO_CLOCK_MIPS		0x00A0
+#define SSB_CHIPCO_CLKDIV		0x00A4		/* Rev >= 3 only */
+#define	 SSB_CHIPCO_CLKDIV_SFLASH	0x0F000000
+#define	 SSB_CHIPCO_CLKDIV_SFLASH_SHIFT	24
+#define	 SSB_CHIPCO_CLKDIV_OTP		0x000F0000
+#define	 SSB_CHIPCO_CLKDIV_OTP_SHIFT	16
+#define	 SSB_CHIPCO_CLKDIV_JTAG		0x00000F00
+#define	 SSB_CHIPCO_CLKDIV_JTAG_SHIFT	8
+#define	 SSB_CHIPCO_CLKDIV_UART		0x000000FF
+#define SSB_CHIPCO_PLLONDELAY		0x00B0		/* Rev >= 4 only */
+#define SSB_CHIPCO_FREFSELDELAY		0x00B4		/* Rev >= 4 only */
+#define SSB_CHIPCO_SLOWCLKCTL		0x00B8		/* 6 <= Rev <= 9 only */
+#define  SSB_CHIPCO_SLOWCLKCTL_SRC	0x00000007	/* slow clock source mask */
+#define	  SSB_CHIPCO_SLOWCLKCTL_SRC_LPO		0x00000000	/* source of slow clock is LPO */
+#define   SSB_CHIPCO_SLOWCLKCTL_SRC_XTAL	0x00000001	/* source of slow clock is crystal */
+#define	  SSB_CHIPCO_SLOECLKCTL_SRC_PCI		0x00000002	/* source of slow clock is PCI */
+#define  SSB_CHIPCO_SLOWCLKCTL_LPOFREQ	0x00000200	/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
+#define  SSB_CHIPCO_SLOWCLKCTL_LPOPD	0x00000400	/* LPOPowerDown, 1: LPO is disabled, 0: LPO is enabled */
+#define  SSB_CHIPCO_SLOWCLKCTL_FSLOW	0x00000800	/* ForceSlowClk, 1: sb/cores running on slow clock, 0: power logic control */
+#define  SSB_CHIPCO_SLOWCLKCTL_IPLL	0x00001000	/* IgnorePllOffReq, 1/0: power logic ignores/honors PLL clock disable requests from core */
+#define  SSB_CHIPCO_SLOWCLKCTL_ENXTAL	0x00002000	/* XtalControlEn, 1/0: power logic does/doesn't disable crystal when appropriate */
+#define  SSB_CHIPCO_SLOWCLKCTL_XTALPU	0x00004000	/* XtalPU (RO), 1/0: crystal running/disabled */
+#define  SSB_CHIPCO_SLOWCLKCTL_CLKDIV	0xFFFF0000	/* ClockDivider (SlowClk = 1/(4+divisor)) */
+#define  SSB_CHIPCO_SLOWCLKCTL_CLKDIV_SHIFT	16
+#define SSB_CHIPCO_SYSCLKCTL		0x00C0		/* Rev >= 3 only */
+#define	 SSB_CHIPCO_SYSCLKCTL_IDLPEN	0x00000001	/* ILPen: Enable Idle Low Power */
+#define	 SSB_CHIPCO_SYSCLKCTL_ALPEN	0x00000002	/* ALPen: Enable Active Low Power */
+#define	 SSB_CHIPCO_SYSCLKCTL_PLLEN	0x00000004	/* ForcePLLOn */
+#define	 SSB_CHIPCO_SYSCLKCTL_FORCEALP	0x00000008	/* Force ALP (or HT if ALPen is not set */
+#define	 SSB_CHIPCO_SYSCLKCTL_FORCEHT	0x00000010	/* Force HT */
+#define  SSB_CHIPCO_SYSCLKCTL_CLKDIV	0xFFFF0000	/* ClkDiv  (ILP = 1/(4+divisor)) */
+#define  SSB_CHIPCO_SYSCLKCTL_CLKDIV_SHIFT	16
+#define SSB_CHIPCO_CLKSTSTR		0x00C4		/* Rev >= 3 only */
+#define SSB_CHIPCO_PCMCIA_CFG		0x0100
+#define SSB_CHIPCO_PCMCIA_MEMWAIT	0x0104
+#define SSB_CHIPCO_PCMCIA_ATTRWAIT	0x0108
+#define SSB_CHIPCO_PCMCIA_IOWAIT	0x010C
+#define SSB_CHIPCO_IDE_CFG		0x0110
+#define SSB_CHIPCO_IDE_MEMWAIT		0x0114
+#define SSB_CHIPCO_IDE_ATTRWAIT		0x0118
+#define SSB_CHIPCO_IDE_IOWAIT		0x011C
+#define SSB_CHIPCO_PROG_CFG		0x0120
+#define SSB_CHIPCO_PROG_WAITCNT		0x0124
+#define SSB_CHIPCO_FLASH_CFG		0x0128
+#define SSB_CHIPCO_FLASH_WAITCNT	0x012C
+#define SSB_CHIPCO_UART0_DATA		0x0300
+#define SSB_CHIPCO_UART0_IMR		0x0304
+#define SSB_CHIPCO_UART0_FCR		0x0308
+#define SSB_CHIPCO_UART0_LCR		0x030C
+#define SSB_CHIPCO_UART0_MCR		0x0310
+#define SSB_CHIPCO_UART0_LSR		0x0314
+#define SSB_CHIPCO_UART0_MSR		0x0318
+#define SSB_CHIPCO_UART0_SCRATCH	0x031C
+#define SSB_CHIPCO_UART1_DATA		0x0400
+#define SSB_CHIPCO_UART1_IMR		0x0404
+#define SSB_CHIPCO_UART1_FCR		0x0408
+#define SSB_CHIPCO_UART1_LCR		0x040C
+#define SSB_CHIPCO_UART1_MCR		0x0410
+#define SSB_CHIPCO_UART1_LSR		0x0414
+#define SSB_CHIPCO_UART1_MSR		0x0418
+#define SSB_CHIPCO_UART1_SCRATCH	0x041C
+
+
+
+/** Clockcontrol masks and values **/
+
+/* SSB_CHIPCO_CLOCK_N */
+#define	SSB_CHIPCO_CLK_N1		0x0000003F	/* n1 control */
+#define	SSB_CHIPCO_CLK_N2		0x00003F00	/* n2 control */
+#define	SSB_CHIPCO_CLK_N2_SHIFT		8
+#define	SSB_CHIPCO_CLK_PLLC		0x000F0000	/* pll control */
+#define	SSB_CHIPCO_CLK_PLLC_SHIFT	16
+
+/* SSB_CHIPCO_CLOCK_SB/PCI/UART */
+#define	SSB_CHIPCO_CLK_M1		0x0000003F	/* m1 control */
+#define	SSB_CHIPCO_CLK_M2		0x00003F00	/* m2 control */
+#define	SSB_CHIPCO_CLK_M2_SHIFT		8
+#define	SSB_CHIPCO_CLK_M3		0x003F0000	/* m3 control */
+#define	SSB_CHIPCO_CLK_M3_SHIFT		16
+#define	SSB_CHIPCO_CLK_MC		0x1F000000	/* mux control */
+#define	SSB_CHIPCO_CLK_MC_SHIFT		24
+
+/* N3M Clock control magic field values */
+#define	SSB_CHIPCO_CLK_F6_2		0x02		/* A factor of 2 in */
+#define	SSB_CHIPCO_CLK_F6_3		0x03		/* 6-bit fields like */
+#define	SSB_CHIPCO_CLK_F6_4		0x05		/* N1, M1 or M3 */
+#define	SSB_CHIPCO_CLK_F6_5		0x09
+#define	SSB_CHIPCO_CLK_F6_6		0x11
+#define	SSB_CHIPCO_CLK_F6_7		0x21
+
+#define	SSB_CHIPCO_CLK_F5_BIAS		5		/* 5-bit fields get this added */
+
+#define	SSB_CHIPCO_CLK_MC_BYPASS	0x08
+#define	SSB_CHIPCO_CLK_MC_M1		0x04
+#define	SSB_CHIPCO_CLK_MC_M1M2		0x02
+#define	SSB_CHIPCO_CLK_MC_M1M2M3	0x01
+#define	SSB_CHIPCO_CLK_MC_M1M3		0x11
+
+/* Type 2 Clock control magic field values */
+#define	SSB_CHIPCO_CLK_T2_BIAS		2		/* n1, n2, m1 & m3 bias */
+#define	SSB_CHIPCO_CLK_T2M2_BIAS	3		/* m2 bias */
+
+#define	SSB_CHIPCO_CLK_T2MC_M1BYP	1
+#define	SSB_CHIPCO_CLK_T2MC_M2BYP	2
+#define	SSB_CHIPCO_CLK_T2MC_M3BYP	4
+
+/* Type 6 Clock control magic field values */
+#define	SSB_CHIPCO_CLK_T6_MMASK		1		/* bits of interest in m */
+#define	SSB_CHIPCO_CLK_T6_M0		120000000	/* sb clock for m = 0 */
+#define	SSB_CHIPCO_CLK_T6_M1		100000000	/* sb clock for m = 1 */
+#define	SSB_CHIPCO_CLK_SB2MIPS_T6(sb)	(2 * (sb))
+
+/* Common clock base */
+#define	SSB_CHIPCO_CLK_BASE1		24000000	/* Half the clock freq */
+#define SSB_CHIPCO_CLK_BASE2		12500000	/* Alternate crystal on some PLL's */
+
+/* Clock control values for 200Mhz in 5350 */
+#define	SSB_CHIPCO_CLK_5350_N		0x0311
+#define	SSB_CHIPCO_CLK_5350_M		0x04020009
+
+
+/** Bits in the config registers **/
+
+#define	SSB_CHIPCO_CFG_EN		0x0001		/* Enable */
+#define	SSB_CHIPCO_CFG_EXTM		0x000E		/* Extif Mode */
+#define	 SSB_CHIPCO_CFG_EXTM_ASYNC	0x0002		/* Async/Parallel flash */
+#define	 SSB_CHIPCO_CFG_EXTM_SYNC	0x0004		/* Synchronous */
+#define	 SSB_CHIPCO_CFG_EXTM_PCMCIA	0x0008		/* PCMCIA */
+#define	 SSB_CHIPCO_CFG_EXTM_IDE	0x000A		/* IDE */
+#define	SSB_CHIPCO_CFG_DS16		0x0010		/* Data size, 0=8bit, 1=16bit */
+#define	SSB_CHIPCO_CFG_CLKDIV		0x0060		/* Sync: Clock divisor */
+#define	SSB_CHIPCO_CFG_CLKEN		0x0080		/* Sync: Clock enable */
+#define	SSB_CHIPCO_CFG_BSTRO		0x0100		/* Sync: Size/Bytestrobe */
+
+
+/** Flash-specific control/status values */
+
+/* flashcontrol opcodes for ST flashes */
+#define SSB_CHIPCO_FLASHCTL_ST_WREN	0x0006		/* Write Enable */
+#define SSB_CHIPCO_FLASHCTL_ST_WRDIS	0x0004		/* Write Disable */
+#define SSB_CHIPCO_FLASHCTL_ST_RDSR	0x0105		/* Read Status Register */
+#define SSB_CHIPCO_FLASHCTL_ST_WRSR	0x0101		/* Write Status Register */
+#define SSB_CHIPCO_FLASHCTL_ST_READ	0x0303		/* Read Data Bytes */
+#define SSB_CHIPCO_FLASHCTL_ST_PP	0x0302		/* Page Program */
+#define SSB_CHIPCO_FLASHCTL_ST_SE	0x02D8		/* Sector Erase */
+#define SSB_CHIPCO_FLASHCTL_ST_BE	0x00C7		/* Bulk Erase */
+#define SSB_CHIPCO_FLASHCTL_ST_DP	0x00B9		/* Deep Power-down */
+#define SSB_CHIPCO_FLASHCTL_ST_RSIG	0x03AB		/* Read Electronic Signature */
+
+/* Status register bits for ST flashes */
+#define SSB_CHIPCO_FLASHSTA_ST_WIP	0x01		/* Write In Progress */
+#define SSB_CHIPCO_FLASHSTA_ST_WEL	0x02		/* Write Enable Latch */
+#define SSB_CHIPCO_FLASHSTA_ST_BP	0x1C		/* Block Protect */
+#define SSB_CHIPCO_FLASHSTA_ST_BP_SHIFT	2
+#define SSB_CHIPCO_FLASHSTA_ST_SRWD	0x80		/* Status Register Write Disable */
+
+/* flashcontrol opcodes for Atmel flashes */
+#define SSB_CHIPCO_FLASHCTL_AT_READ		0x07E8
+#define SSB_CHIPCO_FLASHCTL_AT_PAGE_READ	0x07D2
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_READ	/* FIXME */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_READ	/* FIXME */
+#define SSB_CHIPCO_FLASHCTL_AT_STATUS		0x01D7
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_WRITE	0x0384
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_WRITE	0x0387
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_ERASE_PRGM	0x0283	/* Erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_ERASE_PRGM	0x0286	/* Erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_PROGRAM	0x0288
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_PROGRAM	0x0289
+#define SSB_CHIPCO_FLASHCTL_AT_PAGE_ERASE	0x0281
+#define SSB_CHIPCO_FLASHCTL_AT_BLOCK_ERASE	0x0250
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_WRER_PRGM	0x0382	/* Write erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_WRER_PRGM	0x0385	/* Write erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_LOAD	0x0253
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_LOAD	0x0255
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_COMPARE	0x0260
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_COMPARE	0x0261
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_REPROGRAM	0x0258
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_REPROGRAM	0x0259
+
+/* Status register bits for Atmel flashes */
+#define SSB_CHIPCO_FLASHSTA_AT_READY	0x80
+#define SSB_CHIPCO_FLASHSTA_AT_MISMATCH	0x40
+#define SSB_CHIPCO_FLASHSTA_AT_ID	0x38
+#define SSB_CHIPCO_FLASHSTA_AT_ID_SHIFT	3
+
+
+/** OTP **/
+
+/* OTP regions */
+#define	SSB_CHIPCO_OTP_HW_REGION	SSB_CHIPCO_OTPS_HW_PROTECT
+#define	SSB_CHIPCO_OTP_SW_REGION	SSB_CHIPCO_OTPS_SW_PROTECT
+#define	SSB_CHIPCO_OTP_CID_REGION	SSB_CHIPCO_OTPS_CID_PROTECT
+
+/* OTP regions (Byte offsets from otp size) */
+#define	SSB_CHIPCO_OTP_SWLIM_OFF	(-8)
+#define	SSB_CHIPCO_OTP_CIDBASE_OFF	0
+#define	SSB_CHIPCO_OTP_CIDLIM_OFF	8
+
+/* Predefined OTP words (Word offset from otp size) */
+#define	SSB_CHIPCO_OTP_BOUNDARY_OFF	(-4)
+#define	SSB_CHIPCO_OTP_HWSIGN_OFF	(-3)
+#define	SSB_CHIPCO_OTP_SWSIGN_OFF	(-2)
+#define	SSB_CHIPCO_OTP_CIDSIGN_OFF	(-1)
+
+#define	SSB_CHIPCO_OTP_CID_OFF		0
+#define	SSB_CHIPCO_OTP_PKG_OFF		1
+#define	SSB_CHIPCO_OTP_FID_OFF		2
+#define	SSB_CHIPCO_OTP_RSV_OFF		3
+#define	SSB_CHIPCO_OTP_LIM_OFF		4
+
+#define	SSB_CHIPCO_OTP_SIGNATURE	0x578A
+#define	SSB_CHIPCO_OTP_MAGIC		0x4E56
+
+
+struct ssb_device;
+struct ssb_serial_port;
+
+struct ssb_chipcommon {
+	struct ssb_device *dev;
+	u32 capabilities;
+	/* Fast Powerup Delay constant */
+	u16 fast_pwrup_delay;
+};
+
+extern void ssb_chipcommon_init(struct ssb_chipcommon *cc);
+
+#include <linux/pm.h>
+extern void ssb_chipco_suspend(struct ssb_chipcommon *cc, pm_message_t state);
+extern void ssb_chipco_resume(struct ssb_chipcommon *cc);
+
+extern void ssb_chipco_get_clockcontrol(struct ssb_chipcommon *cc,
+					u32 *plltype, u32 *n, u32 *m);
+extern void ssb_chipco_timing_init(struct ssb_chipcommon *cc,
+				   unsigned long ns_per_cycle);
+
+enum ssb_clkmode {
+	SSB_CLKMODE_SLOW,
+	SSB_CLKMODE_FAST,
+	SSB_CLKMODE_DYNAMIC,
+};
+
+extern void ssb_chipco_set_clockmode(struct ssb_chipcommon *cc,
+				     enum ssb_clkmode mode);
+
+#ifdef CONFIG_SSB_SERIAL
+extern int ssb_chipco_serial_init(struct ssb_chipcommon *cc,
+				  struct ssb_serial_port *ports);
+#endif /* CONFIG_SSB_SERIAL */
+
+#endif /* LINUX_SSB_CHIPCO_H_ */
diff --git a/include/linux/ssb/ssb_driver_extif.h b/include/linux/ssb/ssb_driver_extif.h
new file mode 100644
index 0000000..00de749
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_extif.h
@@ -0,0 +1,160 @@
+/*
+ * Hardware-specific External Interface I/O core definitions
+ * for the BCM47xx family of SiliconBackplane-based chips.
+ *
+ * The External Interface core supports a total of three external chip selects
+ * supporting external interfaces. One of the external chip selects is
+ * used for Flash, one is used for PCMCIA, and the other may be
+ * programmed to support either a synchronous interface or an
+ * asynchronous interface. The asynchronous interface can be used to
+ * support external devices such as UARTs and the BCM2019 Bluetooth
+ * baseband processor.
+ * The external interface core also contains 2 on-chip 16550 UARTs, clock
+ * frequency control, a watchdog interrupt timer, and a GPIO interface.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, Michael Buesch
+ *
+ * Licensed under the GPL version 2. See COPYING for details.
+ */
+#ifndef LINUX_SSB_EXTIFCORE_H_
+#define LINUX_SSB_EXTIFCORE_H_
+
+struct ssb_extif {
+	struct ssb_device *dev;
+};
+
+/* external interface address space */
+#define	SSB_EXTIF_PCMCIA_MEMBASE(x)	(x)
+#define	SSB_EXTIF_PCMCIA_IOBASE(x)	((x) + 0x100000)
+#define	SSB_EXTIF_PCMCIA_CFGBASE(x)	((x) + 0x200000)
+#define	SSB_EXTIF_CFGIF_BASE(x)		((x) + 0x800000)
+#define	SSB_EXTIF_FLASH_BASE(x)		((x) + 0xc00000)
+
+#define SSB_EXTIF_NR_GPIOOUT		5
+/* GPIO NOTE:
+ * The multiple instances of output and output enable registers
+ * are present to allow driver software for multiple cores to control
+ * gpio outputs without needing to share a single register pair.
+ * Use the following helper macro to get a register offset value.
+ */
+#define SSB_EXTIF_GPIO_OUT(index)	({		\
+	BUILD_BUG_ON(index >= SSB_EXTIF_NR_GPIOOUT);	\
+	SSB_EXTIF_GPIO_OUT_BASE + ((index) * 8);	\
+					})
+#define SSB_EXTIF_GPIO_OUTEN(index)	({		\
+	BUILD_BUG_ON(index >= SSB_EXTIF_NR_GPIOOUT);	\
+	SSB_EXTIF_GPIO_OUTEN_BASE + ((index) * 8);	\
+					})
+
+/** EXTIF core registers **/
+
+#define SSB_EXTIF_CTL			0x0000
+#define  SSB_EXTIF_CTL_UARTEN		(1 << 0) /* UART enable */
+#define SSB_EXTIF_EXTSTAT		0x0004
+#define  SSB_EXTIF_EXTSTAT_EMODE	(1 << 0) /* Endian mode (ro) */
+#define  SSB_EXTIF_EXTSTAT_EIRQPIN	(1 << 1) /* External interrupt pin (ro) */
+#define  SSB_EXTIF_EXTSTAT_GPIOIRQPIN	(1 << 2) /* GPIO interrupt pin (ro) */
+#define SSB_EXTIF_PCMCIA_CFG		0x0010
+#define SSB_EXTIF_PCMCIA_MEMWAIT	0x0014
+#define SSB_EXTIF_PCMCIA_ATTRWAIT	0x0018
+#define SSB_EXTIF_PCMCIA_IOWAIT		0x001C
+#define SSB_EXTIF_PROG_CFG		0x0020
+#define SSB_EXTIF_PROG_WAITCNT		0x0024
+#define SSB_EXTIF_FLASH_CFG		0x0028
+#define SSB_EXTIF_FLASH_WAITCNT		0x002C
+#define SSB_EXTIF_WATCHDOG		0x0040
+#define SSB_EXTIF_CLOCK_N		0x0044
+#define SSB_EXTIF_CLOCK_SB		0x0048
+#define SSB_EXTIF_CLOCK_PCI		0x004C
+#define SSB_EXTIF_CLOCK_MII		0x0050
+#define SSB_EXTIF_GPIO_IN		0x0060
+#define SSB_EXTIF_GPIO_OUT_BASE		0x0064
+#define SSB_EXTIF_GPIO_OUTEN_BASE	0x0068
+#define SSB_EXTIF_EJTAG_OUTEN		0x0090
+#define SSB_EXTIF_GPIO_INTPOL		0x0094
+#define SSB_EXTIF_GPIO_INTMASK		0x0098
+#define SSB_EXTIF_UART_DATA		0x0300
+#define SSB_EXTIF_UART_TIMER		0x0310
+#define SSB_EXTIF_UART_FCR		0x0320
+#define SSB_EXTIF_UART_LCR		0x0330
+#define SSB_EXTIF_UART_MCR		0x0340
+#define SSB_EXTIF_UART_LSR		0x0350
+#define SSB_EXTIF_UART_MSR		0x0360
+#define SSB_EXTIF_UART_SCRATCH		0x0370
+
+
+
+
+/* pcmcia/prog/flash_config */
+#define	SSB_EXTCFG_EN			(1 << 0)	/* enable */
+#define	SSB_EXTCFG_MODE			0xE		/* mode */
+#define	SSB_EXTCFG_MODE_SHIFT		1
+#define	 SSB_EXTCFG_MODE_FLASH		0x0		/* flash/asynchronous mode */
+#define	 SSB_EXTCFG_MODE_SYNC		0x2		/* synchronous mode */
+#define	 SSB_EXTCFG_MODE_PCMCIA		0x4		/* pcmcia mode */
+#define	SSB_EXTCFG_DS16			(1 << 4)	/* destsize:  0=8bit, 1=16bit */
+#define	SSB_EXTCFG_BSWAP		(1 << 5)	/* byteswap */
+#define	SSB_EXTCFG_CLKDIV		0xC0		/* clock divider */
+#define	SSB_EXTCFG_CLKDIV_SHIFT		6
+#define	 SSB_EXTCFG_CLKDIV_2		0x0		/* backplane/2 */
+#define	 SSB_EXTCFG_CLKDIV_3		0x40		/* backplane/3 */
+#define	 SSB_EXTCFG_CLKDIV_4		0x80		/* backplane/4 */
+#define	SSB_EXTCFG_CLKEN		(1 << 8)	/* clock enable */
+#define	SSB_EXTCFG_STROBE		(1 << 9)	/* size/bytestrobe (synch only) */
+
+/* pcmcia_memwait */
+#define	SSB_PCMCIA_MEMW_0		0x0000003F	/* waitcount0 */
+#define	SSB_PCMCIA_MEMW_1		0x00001F00	/* waitcount1 */
+#define	SSB_PCMCIA_MEMW_1_SHIFT		8
+#define	SSB_PCMCIA_MEMW_2		0x001F0000	/* waitcount2 */
+#define	SSB_PCMCIA_MEMW_2_SHIFT		16
+#define	SSB_PCMCIA_MEMW_3		0x1F000000	/* waitcount3 */
+#define	SSB_PCMCIA_MEMW_3_SHIFT		24
+
+/* pcmcia_attrwait */
+#define	SSB_PCMCIA_ATTW_0		0x0000003F	/* waitcount0 */
+#define	SSB_PCMCIA_ATTW_1		0x00001F00	/* waitcount1 */
+#define	SSB_PCMCIA_ATTW_1_SHIFT		8
+#define	SSB_PCMCIA_ATTW_2		0x001F0000	/* waitcount2 */
+#define	SSB_PCMCIA_ATTW_2_SHIFT		16
+#define	SSB_PCMCIA_ATTW_3		0x1F000000	/* waitcount3 */
+#define	SSB_PCMCIA_ATTW_3_SHIFT		24
+
+/* pcmcia_iowait */
+#define	SSB_PCMCIA_IOW_0		0x0000003F	/* waitcount0 */
+#define	SSB_PCMCIA_IOW_1		0x00001F00	/* waitcount1 */
+#define	SSB_PCMCIA_IOW_1_SHIFT		8
+#define	SSB_PCMCIA_IOW_2		0x001F0000	/* waitcount2 */
+#define	SSB_PCMCIA_IOW_2_SHIFT		16
+#define	SSB_PCMCIA_IOW_3		0x1F000000	/* waitcount3 */
+#define	SSB_PCMCIA_IOW_3_SHIFT		24
+
+/* prog_waitcount */
+#define	SSB_PROG_WCNT_0			0x0000001F	/* waitcount0 */
+#define	SSB_PROG_WCNT_1			0x00001F00	/* waitcount1 */
+#define	SSB_PROG_WCNT_1_SHIFT		8
+#define	SSB_PROG_WCNT_2			0x001F0000	/* waitcount2 */
+#define	SSB_PROG_WCNT_2_SHIFT		16
+#define	SSB_PROG_WCNT_3			0x1F000000	/* waitcount3 */
+#define	SSB_PROG_WCNT_3_SHIFT		24
+
+#define SSB_PROG_W0			0x0000000C
+#define SSB_PROG_W1			0x00000A00
+#define SSB_PROG_W2			0x00020000
+#define SSB_PROG_W3			0x01000000
+
+/* flash_waitcount */
+#define	SSB_FLASH_WCNT_0		0x0000001F	/* waitcount0 */
+#define	SSB_FLASH_WCNT_1		0x00001F00	/* waitcount1 */
+#define	SSB_FLASH_WCNT_1_SHIFT		8
+#define	SSB_FLASH_WCNT_2		0x001F0000	/* waitcount2 */
+#define	SSB_FLASH_WCNT_2_SHIFT		16
+#define	SSB_FLASH_WCNT_3		0x1F000000	/* waitcount3 */
+#define	SSB_FLASH_WCNT_3_SHIFT		24
+
+/* watchdog */
+#define SSB_EXTIF_WATCHDOG_CLK		48000000	/* Hz */
+
+
+#endif /* LINUX_SSB_EXTIFCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_mips.h b/include/linux/ssb/ssb_driver_mips.h
new file mode 100644
index 0000000..cdbb985
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_mips.h
@@ -0,0 +1,44 @@
+#ifndef LINUX_SSB_MIPSCORE_H_
+#define LINUX_SSB_MIPSCORE_H_
+
+#ifdef CONFIG_SSB_DRIVER_MIPS
+
+struct ssb_device;
+
+struct ssb_serial_port {
+	void *regs;
+	unsigned long clockspeed;
+	unsigned int irq;
+	unsigned int baud_base;
+	unsigned int reg_shift;
+};
+
+
+struct ssb_mipscore {
+	struct ssb_device *dev;
+
+	int nr_serial_ports;
+	struct ssb_serial_port serial_ports[4];
+
+	u32 flash_window;
+	u32 flash_window_size;
+};
+
+extern void ssb_mipscore_init(struct ssb_mipscore *mcore);
+
+extern unsigned int ssb_mips_irq(struct ssb_device *dev);
+
+
+#else /* CONFIG_SSB_DRIVER_MIPS */
+
+struct ssb_mipscore {
+};
+
+static inline
+void ssb_mipscore_init(struct ssb_mipscore *mcore)
+{
+}
+
+#endif /* CONFIG_SSB_DRIVER_MIPS */
+
+#endif /* LINUX_SSB_MIPSCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_pci.h b/include/linux/ssb/ssb_driver_pci.h
new file mode 100644
index 0000000..9cfffb7
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_pci.h
@@ -0,0 +1,106 @@
+#ifndef LINUX_SSB_PCICORE_H_
+#define LINUX_SSB_PCICORE_H_
+
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+
+/* PCI core registers. */
+#define SSB_PCICORE_CTL			0x0000	/* PCI Control */
+#define  SSB_PCICORE_CTL_RST_OE		0x00000001 /* PCI_RESET Output Enable */
+#define  SSB_PCICORE_CTL_RST		0x00000002 /* PCI_RESET driven out to pin */
+#define  SSB_PCICORE_CTL_CLK_OE		0x00000004 /* Clock gate Output Enable */
+#define  SSB_PCICORE_CTL_CLK		0x00000008 /* Gate for clock driven out to pin */
+#define SSB_PCICORE_ARBCTL		0x0010	/* PCI Arbiter Control */
+#define  SSB_PCICORE_ARBCTL_INTERN	0x00000001 /* Use internal arbiter */
+#define  SSB_PCICORE_ARBCTL_EXTERN	0x00000002 /* Use external arbiter */
+#define  SSB_PCICORE_ARBCTL_PARKID	0x00000006 /* Mask, selects which agent is parked on an idle bus */
+#define   SSB_PCICORE_ARBCTL_PARKID_LAST	0x00000000 /* Last requestor */
+#define   SSB_PCICORE_ARBCTL_PARKID_4710	0x00000002 /* 4710 */
+#define   SSB_PCICORE_ARBCTL_PARKID_EXT0	0x00000004 /* External requestor 0 */
+#define   SSB_PCICORE_ARBCTL_PARKID_EXT1	0x00000006 /* External requestor 1 */
+#define SSB_PCICORE_ISTAT		0x0020	/* Interrupt status */
+#define  SSB_PCICORE_ISTAT_INTA		0x00000001 /* PCI INTA# */
+#define  SSB_PCICORE_ISTAT_INTB		0x00000002 /* PCI INTB# */
+#define  SSB_PCICORE_ISTAT_SERR		0x00000004 /* PCI SERR# (write to clear) */
+#define  SSB_PCICORE_ISTAT_PERR		0x00000008 /* PCI PERR# (write to clear) */
+#define  SSB_PCICORE_ISTAT_PME		0x00000010 /* PCI PME# */
+#define SSB_PCICORE_IMASK		0x0024	/* Interrupt mask */
+#define  SSB_PCICORE_IMASK_INTA		0x00000001 /* PCI INTA# */
+#define  SSB_PCICORE_IMASK_INTB		0x00000002 /* PCI INTB# */
+#define  SSB_PCICORE_IMASK_SERR		0x00000004 /* PCI SERR# */
+#define  SSB_PCICORE_IMASK_PERR		0x00000008 /* PCI PERR# */
+#define  SSB_PCICORE_IMASK_PME		0x00000010 /* PCI PME# */
+#define SSB_PCICORE_MBOX		0x0028	/* Backplane to PCI Mailbox */
+#define  SSB_PCICORE_MBOX_F0_0		0x00000100 /* PCI function 0, INT 0 */
+#define  SSB_PCICORE_MBOX_F0_1		0x00000200 /* PCI function 0, INT 1 */
+#define  SSB_PCICORE_MBOX_F1_0		0x00000400 /* PCI function 1, INT 0 */
+#define  SSB_PCICORE_MBOX_F1_1		0x00000800 /* PCI function 1, INT 1 */
+#define  SSB_PCICORE_MBOX_F2_0		0x00001000 /* PCI function 2, INT 0 */
+#define  SSB_PCICORE_MBOX_F2_1		0x00002000 /* PCI function 2, INT 1 */
+#define  SSB_PCICORE_MBOX_F3_0		0x00004000 /* PCI function 3, INT 0 */
+#define  SSB_PCICORE_MBOX_F3_1		0x00008000 /* PCI function 3, INT 1 */
+#define SSB_PCICORE_BCAST_ADDR		0x0050	/* Backplane Broadcast Address */
+#define  SSB_PCICORE_BCAST_ADDR_MASK	0x000000FF
+#define SSB_PCICORE_BCAST_DATA		0x0054	/* Backplane Broadcast Data */
+#define SSB_PCICORE_GPIO_IN		0x0060	/* rev >= 2 only */
+#define SSB_PCICORE_GPIO_OUT		0x0064	/* rev >= 2 only */
+#define SSB_PCICORE_GPIO_ENABLE		0x0068	/* rev >= 2 only */
+#define SSB_PCICORE_GPIO_CTL		0x006C	/* rev >= 2 only */
+#define SSB_PCICORE_SBTOPCI0		0x0100	/* Backplane to PCI translation 0 (sbtopci0) */
+#define  SSB_PCICORE_SBTOPCI0_MASK	0xFC000000
+#define SSB_PCICORE_SBTOPCI1		0x0104	/* Backplane to PCI translation 1 (sbtopci1) */
+#define  SSB_PCICORE_SBTOPCI1_MASK	0xFC000000
+#define SSB_PCICORE_SBTOPCI2		0x0108	/* Backplane to PCI translation 2 (sbtopci2) */
+#define  SSB_PCICORE_SBTOPCI2_MASK	0xC0000000
+
+/* SBtoPCIx */
+#define SSB_PCICORE_SBTOPCI_MEM		0x00000000
+#define SSB_PCICORE_SBTOPCI_IO		0x00000001
+#define SSB_PCICORE_SBTOPCI_CFG0	0x00000002
+#define SSB_PCICORE_SBTOPCI_CFG1	0x00000003
+#define SSB_PCICORE_SBTOPCI_PREF	0x00000004 /* Prefetch enable */
+#define SSB_PCICORE_SBTOPCI_BURST	0x00000008 /* Burst enable */
+#define SSB_PCICORE_SBTOPCI_MRM		0x00000020 /* Memory Read Multiple */
+#define SSB_PCICORE_SBTOPCI_RC		0x00000030 /* Read Command mask (rev >= 11) */
+#define  SSB_PCICORE_SBTOPCI_RC_READ	0x00000000 /* Memory read */
+#define  SSB_PCICORE_SBTOPCI_RC_READL	0x00000010 /* Memory read line */
+#define  SSB_PCICORE_SBTOPCI_RC_READM	0x00000020 /* Memory read multiple */
+
+
+/* PCIcore specific boardflags */
+#define SSB_PCICORE_BFL_NOPCI		0x00000400 /* Board leaves PCI floating */
+
+
+struct ssb_pcicore {
+	struct ssb_device *dev;
+	u8 setup_done:1;
+	u8 hostmode:1;
+	u8 cardbusmode:1;
+};
+
+extern void ssb_pcicore_init(struct ssb_pcicore *pc);
+
+/* Enable IRQ routing for a specific device */
+extern int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
+					  struct ssb_device *dev);
+
+
+#else /* CONFIG_SSB_DRIVER_PCICORE */
+
+
+struct ssb_pcicore {
+};
+
+static inline
+void ssb_pcicore_init(struct ssb_pcicore *pc)
+{
+}
+
+static inline
+int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
+				   struct ssb_device *dev)
+{
+	return 0;
+}
+
+#endif /* CONFIG_SSB_DRIVER_PCICORE */
+#endif /* LINUX_SSB_PCICORE_H_ */
diff --git a/include/linux/ssb/ssb.h b/include/linux/ssb/ssb.h
new file mode 100644
index 0000000..a3c63ae
--- /dev/null
+++ b/include/linux/ssb/ssb.h
@@ -0,0 +1,431 @@
+#ifndef LINUX_SSB_H_
+#define LINUX_SSB_H_
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+
+#include <linux/ssb/ssb_regs.h>
+
+
+struct pcmcia_device;
+struct ssb_bus;
+struct ssb_driver;
+
+
+struct ssb_sprom_r1 {
+	u16 pci_spid;		/* Subsystem Product ID for PCI */
+	u16 pci_svid;		/* Subsystem Vendor ID for PCI */
+	u16 pci_pid;		/* Product ID for PCI */
+	u8 il0mac[6];		/* MAC address for 802.11b/g */
+	u8 et0mac[6];		/* MAC address for Ethernet */
+	u8 et1mac[6];		/* MAC address for 802.11a */
+	u8 et0phyaddr:5;	/* MII address for enet0 */
+	u8 et1phyaddr:5;	/* MII address for enet1 */
+	u8 et0mdcport:1;	/* MDIO for enet0 */
+	u8 et1mdcport:1;	/* MDIO for enet1 */
+	u8 board_rev;		/* Board revision */
+	u8 country_code:4;	/* Country Code */
+	u8 antenna_a:2;		/* Antenna 0/1 available for A-PHY */
+	u8 antenna_bg:2;	/* Antenna 0/1 available for B-PHY and G-PHY */
+	u16 pa0b0;
+	u16 pa0b1;
+	u16 pa0b2;
+	u16 pa1b0;
+	u16 pa1b1;
+	u16 pa1b2;
+	u8 gpio0;		/* GPIO pin 0 */
+	u8 gpio1;		/* GPIO pin 1 */
+	u8 gpio2;		/* GPIO pin 2 */
+	u8 gpio3;		/* GPIO pin 3 */
+	u16 maxpwr_a;		/* A-PHY Power Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_bg;		/* B/G-PHY Power Amplifier Max Power (in dBm Q5.2) */
+	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
+	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
+	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
+	u8 antenna_gain_a;	/* A-PHY Antenna gain (in dBm Q5.2) */
+	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
+	u8 oem[8];		/* OEM string (rev 1 only) */
+};
+
+struct ssb_sprom_r2 {
+	u16 boardflags_hi;	/* Boardflags (high 16 bits) */
+	u8 maxpwr_a_lo;		/* A-PHY Max Power Low */
+	u8 maxpwr_a_hi;		/* A-PHY Max Power High */
+	u16 pa1lob0;		/* A-PHY PA Low Settings */
+	u16 pa1lob1;		/* A-PHY PA Low Settings */
+	u16 pa1lob2;		/* A-PHY PA Low Settings */
+	u16 pa1hib0;		/* A-PHY PA High Settings */
+	u16 pa1hib1;		/* A-PHY PA High Settings */
+	u16 pa1hib2;		/* A-PHY PA High Settings */
+	u8 ofdm_pwr_off;	/* OFDM Power Offset from CCK Level */
+	u8 country_str[2];	/* Two char Country Code */
+};
+
+struct ssb_sprom_r3 {
+	u32 ofdmapo;		/* A-PHY OFDM Mid Power Offset */
+	u32 ofdmalpo;		/* A-PHY OFDM Low Power Offset */
+	u32 ofdmahpo;		/* A-PHY OFDM High Power Offset */
+	u8 gpioldc_on_cnt;	/* GPIO LED Powersave Duty Cycle ON count */
+	u8 gpioldc_off_cnt;	/* GPIO LED Powersave Duty Cycle OFF count */
+	u8 cckpo_1M:4;		/* CCK Power Offset for Rate 1M */
+	u8 cckpo_2M:4;		/* CCK Power Offset for Rate 2M */
+	u8 cckpo_55M:4;		/* CCK Power Offset for Rate 5.5M */
+	u8 cckpo_11M:4;		/* CCK Power Offset for Rate 11M */
+	u32 ofdmgpo;		/* G-PHY OFDM Power Offset */
+};
+
+struct ssb_sprom_r4 {
+	/* TODO */
+};
+
+struct ssb_sprom {
+	u8 revision;
+	u8 crc;
+	/* The valid r# fields are selected by the "revision".
+	 * Revision 3 and lower inherit from lower revisions.
+	 */
+	union {
+		struct {
+			struct ssb_sprom_r1 r1;
+			struct ssb_sprom_r2 r2;
+			struct ssb_sprom_r3 r3;
+		};
+		struct ssb_sprom_r4 r4;
+	};
+};
+
+/* Information about the PCB the circuitry is soldered on. */
+struct ssb_boardinfo {
+	u16 vendor;
+	u16 type;
+	u16 rev;
+};
+
+
+struct ssb_device;
+/* Lowlevel read/write operations on the device MMIO.
+ * Internal, don't use that outside of ssb. */
+struct ssb_bus_ops {
+	u16 (*read16)(struct ssb_device *dev, u16 offset);
+	u32 (*read32)(struct ssb_device *dev, u16 offset);
+	void (*write16)(struct ssb_device *dev, u16 offset, u16 value);
+	void (*write32)(struct ssb_device *dev, u16 offset, u32 value);
+};
+
+
+/* Core-ID values. */
+#define SSB_DEV_CHIPCOMMON	0x800
+#define SSB_DEV_ILINE20		0x801
+#define SSB_DEV_SDRAM		0x803
+#define SSB_DEV_PCI		0x804
+#define SSB_DEV_MIPS		0x805
+#define SSB_DEV_ETHERNET	0x806
+#define SSB_DEV_V90		0x807
+#define SSB_DEV_USB11_HOSTDEV	0x808
+#define SSB_DEV_ADSL		0x809
+#define SSB_DEV_ILINE100	0x80A
+#define SSB_DEV_IPSEC		0x80B
+#define SSB_DEV_PCMCIA		0x80D
+#define SSB_DEV_INTERNAL_MEM	0x80E
+#define SSB_DEV_MEMC_SDRAM	0x80F
+#define SSB_DEV_EXTIF		0x811
+#define SSB_DEV_80211		0x812
+#define SSB_DEV_MIPS_3302	0x816
+#define SSB_DEV_USB11_HOST	0x817
+#define SSB_DEV_USB11_DEV	0x818
+#define SSB_DEV_USB20_HOST	0x819
+#define SSB_DEV_USB20_DEV	0x81A
+#define SSB_DEV_SDIO_HOST	0x81B
+#define SSB_DEV_ROBOSWITCH	0x81C
+#define SSB_DEV_PARA_ATA	0x81D
+#define SSB_DEV_SATA_XORDMA	0x81E
+#define SSB_DEV_ETHERNET_GBIT	0x81F
+#define SSB_DEV_PCIE		0x820
+#define SSB_DEV_MIMO_PHY	0x821
+#define SSB_DEV_SRAM_CTRLR	0x822
+#define SSB_DEV_MINI_MACPHY	0x823
+#define SSB_DEV_ARM_1176	0x824
+#define SSB_DEV_ARM_7TDMI	0x825
+
+/* Vendor-ID values */
+#define SSB_VENDOR_BROADCOM	0x4243
+
+struct ssb_device_id {
+	u16 vendor;
+	u16 coreid;
+	u8 revision;
+};
+#define SSB_DEVICE(_vendor, _coreid, _revision)  \
+	{ .vendor = _vendor, .coreid = _coreid, .revision = _revision, }
+#define SSB_DEVTABLE_END  \
+	{ 0, },
+
+#define SSB_ANY_VENDOR		0xFFFF
+#define SSB_ANY_ID		0xFFFF
+#define SSB_ANY_REV		0xFF
+
+/* Some kernel subsystems poke with dev->drvdata, so we must use the
+ * following ugly workaround to get from struct device to struct ssb_device */
+struct __ssb_dev_wrapper {
+	struct device dev;
+	struct ssb_device *sdev;
+};
+
+struct ssb_device {
+	/* Having a copy of the ops pointer in each dev struct
+	 * is an optimization. */
+	const struct ssb_bus_ops *ops;
+
+	struct device *dev;
+	struct ssb_bus *bus;
+	struct ssb_device_id id;
+
+	u8 core_index;
+	unsigned int irq;
+
+	/* Internal-only stuff follows. */
+	void *drvdata;		/* Per-device data */
+	void *devtypedata;	/* Per-devicetype (eg 802.11) data */
+};
+
+/* Go from struct device to struct ssb_device. */
+static inline
+struct ssb_device * dev_to_ssb_dev(struct device *dev)
+{
+	struct __ssb_dev_wrapper *wrap = container_of(dev, struct __ssb_dev_wrapper, dev);
+	return wrap->sdev;
+}
+
+/* Device specific user data */
+static inline
+void ssb_set_drvdata(struct ssb_device *dev, void *data)
+{
+	dev->drvdata = data;
+}
+static inline
+void * ssb_get_drvdata(struct ssb_device *dev)
+{
+	return dev->drvdata;
+}
+
+/* Devicetype specific user data. This is per device-type (not per device) */
+void ssb_set_devtypedata(struct ssb_device *dev, void *data);
+static inline
+void * ssb_get_devtypedata(struct ssb_device *dev)
+{
+	return dev->devtypedata;
+}
+
+
+struct ssb_driver {
+	const char *name;
+	const struct ssb_device_id *id_table;
+
+	int (*probe)(struct ssb_device *dev, const struct ssb_device_id *id);
+	void (*remove)(struct ssb_device *dev);
+	int (*suspend)(struct ssb_device *dev, pm_message_t state);
+	int (*resume)(struct ssb_device *dev);
+	void (*shutdown)(struct ssb_device *dev);
+
+	struct device_driver drv;
+};
+#define drv_to_ssb_drv(_drv) container_of(_drv, struct ssb_driver, drv)
+
+extern int __ssb_driver_register(struct ssb_driver *drv, struct module *owner);
+static inline int ssb_driver_register(struct ssb_driver *drv)
+{
+	return __ssb_driver_register(drv, THIS_MODULE);
+}
+extern void ssb_driver_unregister(struct ssb_driver *drv);
+
+
+
+
+enum ssb_bustype {
+	SSB_BUSTYPE_SSB,	/* This SSB bus is the system bus */
+	SSB_BUSTYPE_PCI,	/* SSB is connected to PCI bus */
+	SSB_BUSTYPE_PCMCIA,	/* SSB is connected to PCMCIA bus */
+};
+
+/* board_vendor */
+#define SSB_BOARDVENDOR_BCM	0x14E4	/* Broadcom */
+#define SSB_BOARDVENDOR_DELL	0x1028	/* Dell */
+#define SSB_BOARDVENDOR_HP	0x0E11	/* HP */
+/* board_type */
+#define SSB_BOARD_BCM94306MP	0x0418
+#define SSB_BOARD_BCM4309G	0x0421
+#define SSB_BOARD_BCM4306CB	0x0417
+#define SSB_BOARD_BCM4309MP	0x040C
+#define SSB_BOARD_MP4318	0x044A
+#define SSB_BOARD_BU4306	0x0416
+#define SSB_BOARD_BU4309	0x040A
+/* chip_package */
+#define SSB_CHIPPACK_BCM4712S	1	/* Small 200pin 4712 */
+#define SSB_CHIPPACK_BCM4712M	2	/* Medium 225pin 4712 */
+#define SSB_CHIPPACK_BCM4712L	0	/* Large 340pin 4712 */
+
+#include <linux/ssb/ssb_driver_chipcommon.h>
+#include <linux/ssb/ssb_driver_mips.h>
+#include <linux/ssb/ssb_driver_extif.h>
+#include <linux/ssb/ssb_driver_pci.h>
+
+struct ssb_bus {
+	/* The MMIO area. */
+	void __iomem *mmio;
+
+	const struct ssb_bus_ops *ops;
+
+	/* The core in the basic address register window. (PCI bus only) */
+	struct ssb_device *mapped_device;
+	/* Currently mapped PCMCIA segment. (bustype == SSB_BUSTYPE_PCMCIA only) */
+	u8 mapped_pcmcia_seg;
+	/* Lock for core and segment switching. */
+	spinlock_t bar_lock;
+
+	/* The bus this backplane is running on. */
+	enum ssb_bustype bustype;
+	/* Pointer to the PCI bus (only valid if bustype == SSB_BUSTYPE_PCI). */
+	struct pci_dev *host_pci;
+	/* Pointer to the PCMCIA device (only if bustype == SSB_BUSTYPE_PCMCIA). */
+	struct pcmcia_device *host_pcmcia;
+
+#ifdef CONFIG_SSB_PCIHOST
+	/* Mutex to protect the SPROM writing. */
+	struct mutex pci_sprom_mutex;
+#endif
+
+	/* ID information about the Chip. */
+	u16 chip_id;
+	u16 chip_rev;
+	u8 chip_package;
+
+	/* List of devices (cores) on the backplane. */
+	struct ssb_device devices[SSB_MAX_NR_CORES];
+	u8 nr_devices;
+
+	/* Reference count. Number of suspended devices. */
+	u8 suspend_cnt;
+
+	/* Software ID number for this bus. */
+	unsigned int busnumber;
+
+	/* The ChipCommon device (if available). */
+	struct ssb_chipcommon chipco;
+	/* The PCI-core device (if available). */
+	struct ssb_pcicore pcicore;
+	/* The MIPS-core device (if available). */
+	struct ssb_mipscore mipscore;
+	/* The EXTif-core device (if available). */
+	struct ssb_extif extif;
+
+	/* The following structure elements are not available in early
+	 * SSB initialization. Though, they are available for regular
+	 * registered drivers at any stage. So be careful when
+	 * using them in the ssb core code. */
+
+	/* ID information about the PCB. */
+	struct ssb_boardinfo boardinfo;
+	/* Contents of the SPROM. */
+	struct ssb_sprom sprom;
+
+	/* Internal. */
+	struct list_head list;
+};
+
+/* The initialization-invariants. */
+struct ssb_init_invariants {
+	struct ssb_boardinfo boardinfo;
+	struct ssb_sprom sprom;
+};
+/* Type of function to fetch the invariants. */
+typedef int (*ssb_invariants_func_t)(struct ssb_bus *bus,
+				     struct ssb_init_invariants *iv);
+
+/* Register a SSB system bus. get_invariants() is called after the
+ * basic system devices are initialized.
+ * The invariants are usually fetched from some NVRAM.
+ * Put the invariants into the struct pointed to by iv. */
+extern int ssb_bus_ssbbus_register(struct ssb_bus *bus,
+				   unsigned long baseaddr,
+				   ssb_invariants_func_t get_invariants);
+#ifdef CONFIG_SSB_PCIHOST
+extern int ssb_bus_pcibus_register(struct ssb_bus *bus,
+				   struct pci_dev *host_pci);
+#endif /* CONFIG_SSB_PCIHOST */
+#ifdef CONFIG_SSB_PCMCIAHOST
+extern int ssb_bus_pcmciabus_register(struct ssb_bus *bus,
+				      struct pcmcia_device *pcmcia_dev,
+				      unsigned long baseaddr);
+#endif /* CONFIG_SSB_PCMCIAHOST */
+
+extern void ssb_bus_unregister(struct ssb_bus *bus);
+
+extern u32 ssb_clockspeed(struct ssb_bus *bus);
+
+/* Is the device enabled in hardware? */
+int ssb_device_is_enabled(struct ssb_device *dev);
+/* Enable a device and pass device-specific SSB_TMSLOW flags.
+ * If no device-specific flags are available, use 0. */
+void ssb_device_enable(struct ssb_device *dev, u32 core_specific_flags);
+/* Disable a device in hardware and pass SSB_TMSLOW flags (if any). */
+void ssb_device_disable(struct ssb_device *dev, u32 core_specific_flags);
+
+
+/* Device MMIO register read/write functions. */
+static inline u16 ssb_read16(struct ssb_device *dev, u16 offset)
+{
+	return dev->ops->read16(dev, offset);
+}
+static inline u32 ssb_read32(struct ssb_device *dev, u16 offset)
+{
+	return dev->ops->read32(dev, offset);
+}
+static inline void ssb_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	dev->ops->write16(dev, offset, value);
+}
+static inline void ssb_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	dev->ops->write32(dev, offset, value);
+}
+
+
+/* Translation (routing) bits that need to be ORed to DMA
+ * addresses before they are given to a device. */
+extern u32 ssb_dma_translation(struct ssb_device *dev);
+#define SSB_DMA_TRANSLATION_MASK	0xC0000000
+#define SSB_DMA_TRANSLATION_SHIFT	30
+
+extern int ssb_dma_set_mask(struct ssb_device *ssb_dev, u64 mask);
+
+
+#ifdef CONFIG_SSB_PCIHOST
+/* PCI-host wrapper driver */
+extern int ssb_pcihost_register(struct pci_driver *driver);
+static inline void ssb_pcihost_unregister(struct pci_driver *driver)
+{
+	pci_unregister_driver(driver);
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+
+/* If a driver is shutdown or suspended, call this to signal
+ * that the bus may be completely powered down. SSB will decide,
+ * if it's really time to power down the bus, based on if there
+ * are other devices that want to run. */
+extern int ssb_bus_may_powerdown(struct ssb_bus *bus);
+/* Before initializing and enabling a device, call this to power-up the bus.
+ * If you want to allow use of dynamic-power-control, pass the flag.
+ * Otherwise static always-on powercontrol will be used. */
+extern int ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl);
+
+
+/* Various helper functions */
+extern u32 ssb_admatch_base(u32 adm);
+extern u32 ssb_admatch_size(u32 adm);
+
+
+#endif /* LINUX_SSB_H_ */
diff --git a/include/linux/ssb/ssb_regs.h b/include/linux/ssb/ssb_regs.h
new file mode 100644
index 0000000..66751a6
--- /dev/null
+++ b/include/linux/ssb/ssb_regs.h
@@ -0,0 +1,292 @@
+#ifndef LINUX_SSB_REGS_H_
+#define LINUX_SSB_REGS_H_
+
+
+/* SiliconBackplane Address Map.
+ * All regions may not exist on all chips.
+ */
+#define SSB_SDRAM_BASE		0x00000000	/* Physical SDRAM */
+#define SSB_PCI_MEM		0x08000000	/* Host Mode sb2pcitranslation0 (64 MB) */
+#define SSB_PCI_CFG		0x0c000000	/* Host Mode sb2pcitranslation1 (64 MB) */
+#define	SSB_SDRAM_SWAPPED	0x10000000	/* Byteswapped Physical SDRAM */
+#define SSB_ENUM_BASE    	0x18000000	/* Enumeration space base */
+#define	SSB_ENUM_LIMIT		0x18010000	/* Enumeration space limit */
+
+#define	SSB_FLASH2		0x1c000000	/* Flash Region 2 (region 1 shadowed here) */
+#define	SSB_FLASH2_SZ		0x02000000	/* Size of Flash Region 2 */
+
+#define	SSB_EXTIF_BASE		0x1f000000	/* External Interface region base address */
+#define	SSB_FLASH1		0x1fc00000	/* Flash Region 1 */
+#define	SSB_FLASH1_SZ		0x00400000	/* Size of Flash Region 1 */
+
+#define SSB_PCI_DMA		0x40000000	/* Client Mode sb2pcitranslation2 (1 GB) */
+#define SSB_PCI_DMA_SZ		0x40000000	/* Client Mode sb2pcitranslation2 size in bytes */
+#define SSB_PCIE_DMA_L32	0x00000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), low 32 bits */
+#define SSB_PCIE_DMA_H32	0x80000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), high 32 bits */
+#define	SSB_EUART		(SSB_EXTIF_BASE + 0x00800000)
+#define	SSB_LED			(SSB_EXTIF_BASE + 0x00900000)
+
+
+/* Enumeration space constants */
+#define SSB_CORE_SIZE		0x1000	/* Size of a core MMIO area */
+#define SSB_MAX_NR_CORES	((SSB_ENUM_LIMIT - SSB_ENUM_BASE) / SSB_CORE_SIZE)
+
+
+/* mips address */
+#define	SSB_EJTAG		0xff200000	/* MIPS EJTAG space (2M) */
+
+
+/* SSB PCI config space registers. */
+#define SSB_PMCSR		0x44
+#define  SSB_PE			0x100
+#define	SSB_BAR0_WIN		0x80	/* Backplane address space 0 */
+#define	SSB_BAR1_WIN		0x84	/* Backplane address space 1 */
+#define	SSB_SPROMCTL		0x88	/* SPROM control */
+#define  SSB_SPROMCTL_WE	0x10	/* SPROM write enable */
+#define	SSB_BAR1_CONTROL	0x8c	/* Address space 1 burst control */
+#define SSB_PCI_IRQS		0x90	/* PCI interrupts */
+#define SSB_PCI_IRQMASK		0x94	/* PCI IRQ control and mask (pcirev >= 6 only) */
+#define SSB_BACKPLANE_IRQS	0x98	/* Backplane Interrupts */
+#define SSB_GPIO_IN		0xB0	/* GPIO Input (pcirev >= 3 only) */
+#define SSB_GPIO_OUT		0xB4	/* GPIO Output (pcirev >= 3 only) */
+#define SSB_GPIO_OUT_ENABLE	0xB8	/* GPIO Output Enable/Disable (pcirev >= 3 only) */
+#define  SSB_GPIO_SCS		0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
+#define  SSB_GPIO_HWRAD		0x20	/* PCI config space GPIO 13 for hw radio disable */
+#define  SSB_GPIO_XTAL		0x40	/* PCI config space GPIO 14 for Xtal powerup */
+#define  SSB_GPIO_PLL		0x80	/* PCI config space GPIO 15 for PLL powerdown */
+
+
+#define SSB_BAR0_MAX_RETRIES	50
+
+/* Silicon backplane configuration register definitions */
+#define SSB_IPSFLAG		0x0F08
+#define	 SSB_IPSFLAG_IRQ1	0x0000003F /* which sbflags get routed to mips interrupt 1 */
+#define	 SSB_IPSFLAG_IRQ1_SHIFT	0
+#define	 SSB_IPSFLAG_IRQ2	0x00003F00 /* which sbflags get routed to mips interrupt 2 */
+#define	 SSB_IPSFLAG_IRQ2_SHIFT	8
+#define	 SSB_IPSFLAG_IRQ3	0x003F0000 /* which sbflags get routed to mips interrupt 3 */
+#define	 SSB_IPSFLAG_IRQ3_SHIFT	16
+#define	 SSB_IPSFLAG_IRQ4	0x3F000000 /* which sbflags get routed to mips interrupt 4 */
+#define	 SSB_IPSFLAG_IRQ4_SHIFT	24
+#define SSB_TPSFLAG		0x0F18
+#define  SSB_TPSFLAG_BPFLAG	0x0000003F /* Backplane flag # */
+#define  SSB_TPSFLAG_ALWAYSIRQ	0x00000040 /* IRQ is always sent on the Backplane */
+#define SSB_TMERRLOGA		0x0F48
+#define SSB_TMERRLOG		0x0F50
+#define SSB_ADMATCH3		0x0F60
+#define SSB_ADMATCH2		0x0F68
+#define SSB_ADMATCH1		0x0F70
+#define SSB_IMSTATE		0x0F90     /* SB Initiator Agent State */
+#define  SSB_IMSTATE_PC		0x0000000f /* Pipe Count */
+#define  SSB_IMSTATE_AP_MASK	0x00000030 /* Arbitration Priority */
+#define  SSB_IMSTATE_AP_BOTH	0x00000000 /* Use both timeslices and token */
+#define  SSB_IMSTATE_AP_TS	0x00000010 /* Use timeslices only */
+#define  SSB_IMSTATE_AP_TK	0x00000020 /* Use token only */
+#define  SSB_IMSTATE_AP_RSV	0x00000030 /* Reserved */
+#define  SSB_IMSTATE_IBE	0x00020000 /* In Band Error */
+#define  SSB_IMSTATE_TO		0x00040000 /* Timeout */
+#define SSB_INTVEC		0x0F94     /* SB Interrupt Mask */
+#define  SSB_INTVEC_PCI		0x00000001 /* Enable interrupts for PCI */
+#define  SSB_INTVEC_ENET0	0x00000002 /* Enable interrupts for enet 0 */
+#define  SSB_INTVEC_ILINE20	0x00000004 /* Enable interrupts for iline20 */
+#define  SSB_INTVEC_CODEC	0x00000008 /* Enable interrupts for v90 codec */
+#define  SSB_INTVEC_USB		0x00000010 /* Enable interrupts for usb */
+#define  SSB_INTVEC_EXTIF	0x00000020 /* Enable interrupts for external i/f */
+#define  SSB_INTVEC_ENET1	0x00000040 /* Enable interrupts for enet 1 */
+#define SSB_TMSLOW		0x0F98     /* SB Target State Low */
+#define  SSB_TMSLOW_RESET	0x00000001 /* Reset */
+#define  SSB_TMSLOW_REJECT_22	0x00000002 /* Reject (Backplane rev 2.2) */
+#define  SSB_TMSLOW_REJECT_23	0x00000004 /* Reject (Backplane rev 2.3) */
+#define  SSB_TMSLOW_CLOCK	0x00010000 /* Clock Enable */
+#define  SSB_TMSLOW_FGC		0x00020000 /* Force Gated Clocks On */
+#define  SSB_TMSLOW_PE		0x40000000 /* Power Management Enable */
+#define  SSB_TMSLOW_BE		0x80000000 /* BIST Enable */
+#define SSB_TMSHIGH		0x0F9C     /* SB Target State High */
+#define  SSB_TMSHIGH_SERR	0x00000001 /* S-error */
+#define  SSB_TMSHIGH_INT	0x00000002 /* Interrupt */
+#define  SSB_TMSHIGH_BUSY	0x00000004 /* Busy */
+#define  SSB_TMSHIGH_TO		0x00000020 /* Timeout. Backplane rev >= 2.3 only */
+#define  SSB_TMSHIGH_COREFL	0x1FFF0000 /* Core specific flags */
+#define  SSB_TMSHIGH_COREFL_SHIFT	16
+#define  SSB_TMSHIGH_DMA64	0x10000000 /* 64bit DMA supported */
+#define  SSB_TMSHIGH_GCR	0x20000000 /* Gated Clock Request */
+#define  SSB_TMSHIGH_BISTF	0x40000000 /* BIST Failed */
+#define  SSB_TMSHIGH_BISTD	0x80000000 /* BIST Done */
+#define SSB_BWA0		0x0FA0
+#define SSB_IMCFGLO		0x0FA8
+#define  SSB_IMCFGLO_SERTO	0x00000007 /* Service timeout */
+#define  SSB_IMCFGLO_REQTO	0x00000070 /* Request timeout */
+#define  SSB_IMCFGLO_REQTO_SHIFT	4
+#define  SSB_IMCFGLO_CONNID	0x00FF0000 /* Connection ID */
+#define  SSB_IMCFGLO_CONNID_SHIFT	16
+#define SSB_IMCFGHI		0x0FAC
+#define SSB_ADMATCH0		0x0FB0
+#define SSB_TMCFGLO		0x0FB8
+#define SSB_TMCFGHI		0x0FBC
+#define SSB_BCONFIG		0x0FC0
+#define SSB_BSTATE		0x0FC8
+#define SSB_ACTCFG		0x0FD8
+#define SSB_FLAGST		0x0FE8
+#define SSB_IDLOW		0x0FF8
+#define  SSB_IDLOW_CFGSP	0x00000003 /* Config Space */
+#define  SSB_IDLOW_ADDRNGE	0x00000038 /* Address Ranges supported */
+#define  SSB_IDLOW_ADDRNGE_SHIFT	3
+#define  SSB_IDLOW_SYNC		0x00000040
+#define  SSB_IDLOW_INITIATOR	0x00000080
+#define  SSB_IDLOW_MIBL		0x00000F00 /* Minimum Backplane latency */
+#define  SSB_IDLOW_MIBL_SHIFT	8
+#define  SSB_IDLOW_MABL		0x0000F000 /* Maximum Backplane latency */
+#define  SSB_IDLOW_MABL_SHIFT	12
+#define  SSB_IDLOW_TIF		0x00010000 /* This Initiator is first */
+#define  SSB_IDLOW_CCW		0x000C0000 /* Cycle counter width */
+#define  SSB_IDLOW_CCW_SHIFT	18
+#define  SSB_IDLOW_TPT		0x00F00000 /* Target ports */
+#define  SSB_IDLOW_TPT_SHIFT	20
+#define  SSB_IDLOW_INITP	0x0F000000 /* Initiator ports */
+#define  SSB_IDLOW_INITP_SHIFT	24
+#define  SSB_IDLOW_SSBREV	0xF0000000 /* Sonics Backplane Revision code */
+#define  SSB_IDLOW_SSBREV_22	0x00000000 /* <= 2.2 */
+#define  SSB_IDLOW_SSBREV_23	0x10000000 /* 2.3 */
+#define SSB_IDHIGH		0x0FFC     /* SB Identification High */
+#define  SSB_IDHIGH_RCLO	0x0000000F /* Revision Code (low part) */
+#define  SSB_IDHIGH_CC		0x00008FF0 /* Core Code */
+#define  SSB_IDHIGH_CC_SHIFT	4
+#define  SSB_IDHIGH_RCHI	0x00007000 /* Revision Code (high part) */
+#define  SSB_IDHIGH_RCHI_SHIFT	8	   /* yes, shift 8 is right */
+#define  SSB_IDHIGH_VC		0xFFFF0000 /* Vendor Code */
+#define  SSB_IDHIGH_VC_SHIFT	16
+
+/* SPROM shadow area. If not otherwise noted, fields are
+ * two bytes wide. Note that the SPROM can _only_ be read
+ * in two-byte quantinies.
+ */
+#define SSB_SPROMSIZE_WORDS		64
+#define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
+#define SSB_SPROM_BASE			0x1000
+#define SSB_SPROM_REVISION		0x107E
+#define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
+#define  SSB_SPROM_REVISION_CRC		0xFF00	/* SPROM CRC8 value */
+#define  SSB_SPROM_REVISION_CRC_SHIFT	8
+/* SPROM Revision 1 */
+#define SSB_SPROM1_SPID			0x1004	/* Subsystem Product ID for PCI */
+#define SSB_SPROM1_SVID			0x1006	/* Subsystem Vendor ID for PCI */
+#define SSB_SPROM1_PID			0x1008	/* Product ID for PCI */
+#define SSB_SPROM1_IL0MAC		0x1048	/* 6 bytes MAC address for 802.11b/g */
+#define SSB_SPROM1_ET0MAC		0x104E	/* 6 bytes MAC address for Ethernet */
+#define SSB_SPROM1_ET1MAC		0x1054	/* 6 bytes MAC address for 802.11a */
+#define SSB_SPROM1_ETHPHY		0x105A	/* Ethernet PHY settings */
+#define  SSB_SPROM1_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
+#define  SSB_SPROM1_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
+#define  SSB_SPROM1_ETHPHY_ET1A_SHIFT	5
+#define  SSB_SPROM1_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
+#define  SSB_SPROM1_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
+#define SSB_SPROM1_BINF			0x105C	/* Board info */
+#define  SSB_SPROM1_BINF_BREV		0x00FF	/* Board Revision */
+#define  SSB_SPROM1_BINF_CCODE		0x0F00	/* Country Code */
+#define  SSB_SPROM1_BINF_CCODE_SHIFT	8
+#define  SSB_SPROM1_BINF_ANTA		0x3000	/* Available A-PHY antennas */
+#define  SSB_SPROM1_BINF_ANTA_SHIFT	12
+#define  SSB_SPROM1_BINF_ANTBG		0xC000	/* Available B-PHY antennas */
+#define  SSB_SPROM1_BINF_ANTBG_SHIFT	14
+#define SSB_SPROM1_PA0B0		0x105E
+#define SSB_SPROM1_PA0B1		0x1060
+#define SSB_SPROM1_PA0B2		0x1062
+#define SSB_SPROM1_GPIOA		0x1064	/* General Purpose IO pins 0 and 1 */
+#define  SSB_SPROM1_GPIOA_P0		0x00FF	/* Pin 0 */
+#define  SSB_SPROM1_GPIOA_P1		0xFF00	/* Pin 1 */
+#define  SSB_SPROM1_GPIOA_P1_SHIFT	8
+#define SSB_SPROM1_GPIOB		0x1066	/* General Purpuse IO pins 2 and 3 */
+#define  SSB_SPROM1_GPIOB_P2		0x00FF	/* Pin 2 */
+#define  SSB_SPROM1_GPIOB_P3		0xFF00	/* Pin 3 */
+#define  SSB_SPROM1_GPIOB_P3_SHIFT	8
+#define SSB_SPROM1_MAXPWR		0x1068	/* Power Amplifier Max Power */
+#define  SSB_SPROM1_MAXPWR_BG		0x00FF	/* B-PHY and G-PHY (in dBm Q5.2) */
+#define  SSB_SPROM1_MAXPWR_A		0xFF00	/* A-PHY (in dBm Q5.2) */
+#define  SSB_SPROM1_MAXPWR_A_SHIFT	8
+#define SSB_SPROM1_PA1B0		0x106A
+#define SSB_SPROM1_PA1B1		0x106C
+#define SSB_SPROM1_PA1B2		0x106E
+#define SSB_SPROM1_ITSSI		0x1070	/* Idle TSSI Target */
+#define  SSB_SPROM1_ITSSI_BG		0x00FF	/* B-PHY and G-PHY*/
+#define  SSB_SPROM1_ITSSI_A		0xFF00	/* A-PHY */
+#define  SSB_SPROM1_ITSSI_A_SHIFT	8
+#define SSB_SPROM1_BFLLO		0x1072	/* Boardflags (low 16 bits) */
+#define SSB_SPROM1_AGAIN		0x1074	/* Antenna Gain (in dBm Q5.2) */
+#define  SSB_SPROM1_AGAIN_A		0x00FF	/* A-PHY */
+#define  SSB_SPROM1_AGAIN_BG		0xFF00	/* B-PHY and G-PHY */
+#define  SSB_SPROM1_AGAIN_BG_SHIFT	8
+#define SSB_SPROM1_OEM			0x1076	/* 8 bytes OEM string (rev 1 only) */
+/* SPROM Revision 2 (inherits from rev 1) */
+#define SSB_SPROM2_BFLHI		0x1038	/* Boardflags (high 16 bits) */
+#define SSB_SPROM2_MAXP_A		0x103A	/* A-PHY Max Power */
+#define  SSB_SPROM2_MAXP_A_HI		0x00FF	/* Max Power High */
+#define  SSB_SPROM2_MAXP_A_LO		0xFF00	/* Max Power Low */
+#define  SSB_SPROM2_MAXP_A_LO_SHIFT	8
+#define SSB_SPROM2_PA1LOB0		0x103C	/* A-PHY PowerAmplifier Low Settings */
+#define SSB_SPROM2_PA1LOB1		0x103E	/* A-PHY PowerAmplifier Low Settings */
+#define SSB_SPROM2_PA1LOB2		0x1040	/* A-PHY PowerAmplifier Low Settings */
+#define SSB_SPROM2_PA1HIB0		0x1042	/* A-PHY PowerAmplifier High Settings */
+#define SSB_SPROM2_PA1HIB1		0x1044	/* A-PHY PowerAmplifier High Settings */
+#define SSB_SPROM2_PA1HIB2		0x1046	/* A-PHY PowerAmplifier High Settings */
+#define SSB_SPROM2_OPO			0x1078	/* OFDM Power Offset from CCK Level */
+#define  SSB_SPROM2_OPO_VALUE		0x00FF
+#define  SSB_SPROM2_OPO_UNUSED		0xFF00
+#define SSB_SPROM2_CCODE		0x107C	/* Two char Country Code */
+/* SPROM Revision 3 (inherits from rev 2) */
+#define SSB_SPROM3_OFDMAPO		0x102C	/* A-PHY OFDM Mid Power Offset (4 bytes, BigEndian) */
+#define SSB_SPROM3_OFDMALPO		0x1030	/* A-PHY OFDM Low Power Offset (4 bytes, BigEndian) */
+#define SSB_SPROM3_OFDMAHPO		0x1034	/* A-PHY OFDM High Power Offset (4 bytes, BigEndian) */
+#define SSB_SPROM3_GPIOLDC		0x1042	/* GPIO LED Powersave Duty Cycle (4 bytes, BigEndian) */
+#define  SSB_SPROM3_GPIOLDC_OFF		0x0000FF00	/* Off Count */
+#define  SSB_SPROM3_GPIOLDC_OFF_SHIFT	8
+#define  SSB_SPROM3_GPIOLDC_ON		0x00FF0000	/* On Count */
+#define  SSB_SPROM3_GPIOLDC_ON_SHIFT	16
+#define SSB_SPROM3_CCKPO		0x1078	/* CCK Power Offset */
+#define  SSB_SPROM3_CCKPO_1M		0x000F	/* 1M Rate PO */
+#define  SSB_SPROM3_CCKPO_2M		0x00F0	/* 2M Rate PO */
+#define  SSB_SPROM3_CCKPO_2M_SHIFT	4
+#define  SSB_SPROM3_CCKPO_55M		0x0F00	/* 5.5M Rate PO */
+#define  SSB_SPROM3_CCKPO_55M_SHIFT	8
+#define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
+#define  SSB_SPROM3_CCKPO_11M_SHIFT	12
+#define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
+
+/* Values for SSB_SPROM1_BINF_CCODE */
+enum {
+	SSB_SPROM1CCODE_WORLD = 0,
+	SSB_SPROM1CCODE_THAILAND,
+	SSB_SPROM1CCODE_ISRAEL,
+	SSB_SPROM1CCODE_JORDAN,
+	SSB_SPROM1CCODE_CHINA,
+	SSB_SPROM1CCODE_JAPAN,
+	SSB_SPROM1CCODE_USA_CANADA_ANZ,
+	SSB_SPROM1CCODE_EUROPE,
+	SSB_SPROM1CCODE_USA_LOW,
+	SSB_SPROM1CCODE_JAPAN_HIGH,
+	SSB_SPROM1CCODE_ALL,
+	SSB_SPROM1CCODE_NONE,
+};
+
+/* Address-Match values and masks (SSB_ADMATCHxxx) */
+#define SSB_ADM_TYPE			0x00000003	/* Address type */
+#define  SSB_ADM_TYPE0			0
+#define  SSB_ADM_TYPE1			1
+#define  SSB_ADM_TYPE2			2
+#define SSB_ADM_AD64			0x00000004
+#define SSB_ADM_SZ0			0x000000F8	/* Type0 size */
+#define SSB_ADM_SZ0_SHIFT		3
+#define SSB_ADM_SZ1			0x000001F8	/* Type1 size */
+#define SSB_ADM_SZ1_SHIFT		3
+#define SSB_ADM_SZ2			0x000001F8	/* Type2 size */
+#define SSB_ADM_SZ2_SHIFT		3
+#define SSB_ADM_EN			0x00000400	/* Enable */
+#define SSB_ADM_NEG			0x00000800	/* Negative decode */
+#define SSB_ADM_BASE0			0xFFFFFF00	/* Type0 base address */
+#define SSB_ADM_BASE0_SHIFT		8
+#define SSB_ADM_BASE1			0xFFFFF000	/* Type1 base address for the core */
+#define SSB_ADM_BASE1_SHIFT		12
+#define SSB_ADM_BASE2			0xFFFF0000	/* Type2 base address for the core */
+#define SSB_ADM_BASE2_SHIFT		16
+
+
+#endif /* LINUX_SSB_REGS_H_ */
diff --git a/MAINTAINERS b/MAINTAINERS
index 845fbf4..aee5182 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -3298,6 +3347,12 @@
 L:	netdev at vger.kernel.org
 S:	Maintained
 
+SONICS SILICON BACKPLANE DRIVER (SSB)
+P:	Michael Buesch
+M:	mb at bu3sch.de
+L:	netdev at vger.kernel.org
+S:	Maintained
+
 SONY VAIO CONTROL DEVICE DRIVER
 P:	Mattia Dongili
 M:	malattia at linux.it


From mb at bu3sch.de  Fri Jul 27 21:30:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 27 Jul 2007 21:30:48 +0200
Subject: [PATCH] Merge the Sonics Silicon Backplane subsystem
In-Reply-To: <20070727120318.54d18cfc.akpm@linux-foundation.org>
References: <200707271857.24162.mb@bu3sch.de>
	<20070727120318.54d18cfc.akpm@linux-foundation.org>
Message-ID: <200707272130.48973.mb@bu3sch.de>

On Friday 27 July 2007 21:03:18 Andrew Morton wrote:
> On Fri, 27 Jul 2007 18:57:20 +0200
> Michael Buesch <mb at bu3sch.de> wrote:
> 
> > The Sonics Silicon Backplane is a mini-bus used on
> > various Broadcom chips and embedded devices.
> > Devices using the SSB include b44, bcm43xx and various
> > Broadcom based wireless routers.
> > A b44 and bcm43xx port and a SSB based OHCI driver is available.
> > 
> 
> hm, slim pickings for me here.  Nice looking code.
> 
> checkpatch finds a few coding style glitches.  Lots of 80-col violations
> which you might choose ignore (comments on #defines in headers are
> especially hard) but these guys:

I tried to fix most of the checkpatch warning, except these 80col
warnings.
I don't think it's worth the work to fix the 80col stuff, yet.
I develop kernel code in the real console, and I have no problems
with this. Though, I use a wider console than 80col.
Let's better fix the worst 80col violations over time and not now.

> ERROR: "foo * bar" should be "foo *bar"
> #4156: FILE: drivers/ssb/ssb_private.h:119:
> +extern struct ssb_bus * ssb_pci_dev_to_bus(struct pci_dev *pdev);
> 
> are worth addressing.

Well, I intentionally wrote that this way, as in my opinion
it it easier to read. I only use this additional space for
functions returning a pointer.

struct foo * function(int a, int b);

vs:

struct foo *function(int a, int b);

But I can change that, if that's really an issue and a
style violation.

> > ...
> >
> > --- /dev/null
> > +++ b/drivers/ssb/driver_pcicore.c
> > @@ -0,0 +1,564 @@
> >
> > ...
> >
> > +u32 pci_iobase = 0x100;
> > +u32 pci_membase = SSB_PCI_DMA;
> 
> These are quite poor names for global symbols.

Agreed. I will change this.

> > +static struct resource ssb_pcicore_mem_resource = {
> > +	.name	= "SSB PCIcore external memory",
> > +	.start	= SSB_PCI_DMA,
> > +	.end	= (u32)SSB_PCI_DMA + (u32)SSB_PCI_DMA_SZ - 1,
> > +	.flags	= IORESOURCE_MEM,
> > +};
> 
> start and end here are resource_size_t.  Forcing them to u32 seems
> inappropriate.

You're right. I'll fix that.

> > +void ssb_pcicore_init(struct ssb_pcicore *pc)
> 
> Please check that all newly-added global symbols do indeed need global scope.

ok.

> > +static void ssb_pcie_mdio_write(struct ssb_pcicore *pc, u8 device,
> > +				u8 address, u16 data)
> > +{
> > +	const u16 mdio_control = 0x128;
> > +	const u16 mdio_data = 0x12C;
> > +	u32 v;
> > +	int i;
> > +
> > +	v = 0x80; /* Enable Preamble Sequence */
> > +	v |= 0x2; /* MDIO Clock Divisor */
> > +	pcicore_write32(pc, mdio_control, v);
> > +
> > +	v = (1 << 30); /* Start of Transaction */
> > +	v |= (1 << 28); /* Write Transaction */
> > +	v |= (1 << 17); /* Turnaround */
> > +	v |= (u32)device << 22;
> > +	v |= (u32)address << 18;
> > +	v |= data;
> > +	pcicore_write32(pc, mdio_data, v);
> > +	udelay(10);
> 
> mystery udelays are usually worth a comment.

Sure.

> > +static void ssb_buses_lock(void)
> > +{
> > +	if (!ssb_is_early_boot)
> > +		mutex_lock(&buses_mutex);
> > +}
> > +
> > +static void ssb_buses_unlock(void)
> > +{
> > +	if (!ssb_is_early_boot)
> > +		mutex_unlock(&buses_mutex);
> > +}
> 
> Some comments are neeeded here to explain why we're jumping through this
> hoop.

I added a comment at the declaration of ssb_is_early_boot,
which tries to explain this in detail.

> It's normally OK to take a mutex early in boot, so one wonders 
> what's happening.

Hm, I tried that. There were problems. I don't remember this in detail, though.
This is called _really_ early in boot.

> > +EXPORT_SYMBOL(ssb_clockspeed);
> 
> Please check that all newly-added exports really need to be exported (I'm
> sure they do, but..)
> 
> > +static int ssb_wait_bit(struct ssb_device *dev, u16 reg, u32 bitmask,
> > +			int timeout, int set)
> > +{
> > +	int i;
> > +	u32 val;
> > +
> > +	for (i = 0; i < timeout; i++) {
> > +		val = ssb_read32(dev, reg);
> > +		if (set) {
> > +			if (val & bitmask)
> > +				return 0;
> > +		} else {
> > +			if (!(val & bitmask))
> > +				return 0;
> > +		}
> > +		udelay(10);
> > +	}
> > +	printk(KERN_ERR PFX "Timeout waiting for bitmask %08X on "
> > +			    "register %04X to %s.\n",
> > +	       bitmask, reg, (set ? "set" : "clear"));
> > +
> > +	return -ETIMEDOUT;
> > +}
> 
> So `timeout' is in units of ten-microseconds.  Unusual.
> 
> > +void ssb_device_disable(struct ssb_device *dev, u32 core_specific_flags)
> > +{
> > +	u32 reject;
> > +
> > +	if (ssb_read32(dev, SSB_TMSLOW) & SSB_TMSLOW_RESET)
> > +		return;
> > +
> > +	reject = ssb_tmslow_reject_bitmask(dev);
> > +	ssb_write32(dev, SSB_TMSLOW, reject | SSB_TMSLOW_CLOCK);
> > +	ssb_wait_bit(dev, SSB_TMSLOW, reject, 1000, 1);
> > +	ssb_wait_bit(dev, SSB_TMSHIGH, SSB_TMSHIGH_BUSY, 1000, 0);
> > +	ssb_write32(dev, SSB_TMSLOW,
> > +		    SSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK |
> > +		    reject | SSB_TMSLOW_RESET |
> > +		    core_specific_flags);
> > +	/* flush */
> > +	ssb_read32(dev, SSB_TMSLOW);
> > +	udelay(1);
> > +
> > +	ssb_write32(dev, SSB_TMSLOW,
> > +		    reject | SSB_TMSLOW_RESET |
> > +		    core_specific_flags);
> > +	/* flush */
> > +	ssb_read32(dev, SSB_TMSLOW);
> > +	udelay(1);
> 
> mystery udelay.

Well, /* flush */ :)
It simply waits and makes really sure the device is done.
This is a really critical place and we must make 100% sure
or we risk running into a machine check exception.

> > +}
> > +EXPORT_SYMBOL(ssb_device_disable);
> >
> > ...
> >
> > +const struct ssb_bus_ops ssb_pci_ops = {
> > +	.read16		= ssb_pci_read16,
> > +	.read32		= ssb_pci_read32,
> > +	.write16	= ssb_pci_write16,
> > +	.write32	= ssb_pci_write32,
> > +};
> 
> static?

Yeah, think so. Good catch.

> > +static ssize_t ssb_pci_attr_sprom_show(struct device *pcidev,
> > +				       struct device_attribute *attr,
> > +				       char *buf)
> > +{
> > +	struct pci_dev *pdev = container_of(pcidev, struct pci_dev, dev);
> > +	struct ssb_bus *bus;
> > +	u16 *sprom;
> > +	int err = -ENODEV;
> > +	ssize_t count = 0;
> > +
> > +	bus = ssb_pci_dev_to_bus(pdev);
> > +	if (!bus)
> > +		goto out;
> > +	err = -ENOMEM;
> > +	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
> > +	if (!sprom)
> > +		goto out;
> > +
> > +	err = -ERESTARTSYS;
> > +	if (mutex_lock_interruptible(&bus->pci_sprom_mutex))
> > +		goto out_kfree;
> > +	sprom_do_read(bus, sprom);
> > +	mutex_unlock(&bus->pci_sprom_mutex);
> > +
> > +	count = sprom2hex(sprom, buf, PAGE_SIZE);
> > +	err = 0;
> > +
> > +out_kfree:
> > +	kfree(sprom);
> > +out:
> > +	return err ? err : count;
> > +}
> 
> The mutex_lock_interruptible() looks fishy.  Some commented explanation of
> what it's doing would be good here.  It's quite unobvious to this reader. 
> Cheesy deadlock avoidance?  Hope not.

No, it's simply to avoid writing the SPROM concurrently.
SPROM writing is hairy and we must make sure here that
we are the only one accessing the whole bus. We do that
by suspending all devices and taking a lock to protect
the SPROM from write concurrency.

> > +
> > +/* These are the main device register access functions.
> > + * do_select_core is inline to have the likely hotpath inline.
> > + * All unlikely codepaths are out-of-line. */
> > +static inline int do_select_core(struct ssb_bus *bus,
> > +				 struct ssb_device *dev,
> > +				 u16 *offset)
> > +{
> > +	int err;
> > +	u8 need_seg = (*offset >= 0x800) ? 1 : 0;
> > +
> > +	if (unlikely(dev != bus->mapped_device)) {
> > +		err = ssb_pcmcia_switch_core(bus, dev);
> > +		if (unlikely(err))
> > +			return err;
> > +	}
> > +	if (unlikely(need_seg != bus->mapped_pcmcia_seg)) {
> > +		err = ssb_pcmcia_switch_segment(bus, need_seg);
> > +		if (unlikely(err))
> > +			return err;
> > +	}
> > +	if (need_seg == 1)
> > +		*offset -= 0x800;
> > +
> > +	return 0;
> > +}
> 
> Looks too large for inlining.

Well, as I already explained in a previous submission,
this is the hottest path in the SSB code. It's called with
every MMIO access. I intentionally did this inline to have
the likely path inline and all the unlikely paths out of
line. See the unlikely() branches, which are out of line.

> > +const struct ssb_bus_ops ssb_pcmcia_ops = {
> > +	.read16		= ssb_pcmcia_read16,
> > +	.read32		= ssb_pcmcia_read32,
> > +	.write16	= ssb_pcmcia_write16,
> > +	.write32	= ssb_pcmcia_write32,
> > +};
> 
> static?

Yep.


-- 
Greetings Michael.


From linville at tuxdriver.com  Fri Jul 27 21:21:20 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Fri, 27 Jul 2007 15:21:20 -0400
Subject: [PATCH] Merge the Sonics Silicon Backplane subsystem
In-Reply-To: <200707271857.24162.mb@bu3sch.de>
References: <200707271857.24162.mb@bu3sch.de>
Message-ID: <20070727192120.GB7572@tuxdriver.com>

On Fri, Jul 27, 2007 at 06:57:20PM +0200, Michael Buesch wrote:
> The Sonics Silicon Backplane is a mini-bus used on
> various Broadcom chips and embedded devices.
> Devices using the SSB include b44, bcm43xx and various
> Broadcom based wireless routers.
> A b44 and bcm43xx port and a SSB based OHCI driver is available.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

At first glance it looks like there might be some tab/space issues
in some of the #define blocks toward the end of the patch, although
those might be intentional.

Aside from whatever other style issues that might be identified, I'll
state that this code has been carried in wireless-dev for months and
thereby also spent a lot of time in -mm as well as Fedora (rawhide
and F-7).  The code has proven to be reasonably stable and reliable.

Acked-by: John W. Linville <linville at tuxdriver.com>

-- 
John W. Linville
linville at tuxdriver.com


From mb at bu3sch.de  Fri Jul 27 21:39:45 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 27 Jul 2007 21:39:45 +0200
Subject: [PATCH] Merge the Sonics Silicon Backplane subsystem
In-Reply-To: <20070727192120.GB7572@tuxdriver.com>
References: <200707271857.24162.mb@bu3sch.de>
	<20070727192120.GB7572@tuxdriver.com>
Message-ID: <200707272139.45629.mb@bu3sch.de>

On Friday 27 July 2007 21:21:20 John W. Linville wrote:
> On Fri, Jul 27, 2007 at 06:57:20PM +0200, Michael Buesch wrote:
> > The Sonics Silicon Backplane is a mini-bus used on
> > various Broadcom chips and embedded devices.
> > Devices using the SSB include b44, bcm43xx and various
> > Broadcom based wireless routers.
> > A b44 and bcm43xx port and a SSB based OHCI driver is available.
> > 
> > Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> At first glance it looks like there might be some tab/space issues
> in some of the #define blocks toward the end of the patch, although
> those might be intentional.

They are intentional. It's something like this:

#define SSB_REGISTER_XX			0xF88
#define  SSB_VALUE_FOR_REGISTER_XX	0x0001
#define  SSB_MASK_FOR_REGISTER_XX	0xFF00
#define SSB_REGISTER_YY			0xF99
...

> Aside from whatever other style issues that might be identified, I'll
> state that this code has been carried in wireless-dev for months and
> thereby also spent a lot of time in -mm as well as Fedora (rawhide
> and F-7).  The code has proven to be reasonably stable and reliable.

And it's in the OpenWRT trunk since quite some time.

-- 
Greetings Michael.


From mb at bu3sch.de  Fri Jul 27 21:43:59 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 27 Jul 2007 21:43:59 +0200
Subject: [PATCH] Merge the Sonics Silicon Backplane subsystem
In-Reply-To: <20070727123853.d16e875c.akpm@linux-foundation.org>
References: <200707271857.24162.mb@bu3sch.de> <200707272130.48973.mb@bu3sch.de>
	<20070727123853.d16e875c.akpm@linux-foundation.org>
Message-ID: <200707272143.59551.mb@bu3sch.de>

On Friday 27 July 2007 21:38:53 Andrew Morton wrote:
> > > > +static ssize_t ssb_pci_attr_sprom_show(struct device *pcidev,
> > > > +				       struct device_attribute *attr,
> > > > +				       char *buf)
> > > > +{
> > > > +	struct pci_dev *pdev = container_of(pcidev, struct pci_dev, dev);
> > > > +	struct ssb_bus *bus;
> > > > +	u16 *sprom;
> > > > +	int err = -ENODEV;
> > > > +	ssize_t count = 0;
> > > > +
> > > > +	bus = ssb_pci_dev_to_bus(pdev);
> > > > +	if (!bus)
> > > > +		goto out;
> > > > +	err = -ENOMEM;
> > > > +	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
> > > > +	if (!sprom)
> > > > +		goto out;
> > > > +
> > > > +	err = -ERESTARTSYS;
> > > > +	if (mutex_lock_interruptible(&bus->pci_sprom_mutex))
> > > > +		goto out_kfree;
> > > > +	sprom_do_read(bus, sprom);
> > > > +	mutex_unlock(&bus->pci_sprom_mutex);
> > > > +
> > > > +	count = sprom2hex(sprom, buf, PAGE_SIZE);
> > > > +	err = 0;
> > > > +
> > > > +out_kfree:
> > > > +	kfree(sprom);
> > > > +out:
> > > > +	return err ? err : count;
> > > > +}
> > > 
> > > The mutex_lock_interruptible() looks fishy.  Some commented explanation of
> > > what it's doing would be good here.  It's quite unobvious to this reader. 
> > > Cheesy deadlock avoidance?  Hope not.
> > 
> > No, it's simply to avoid writing the SPROM concurrently.
> > SPROM writing is hairy and we must make sure here that
> > we are the only one accessing the whole bus. We do that
> > by suspending all devices and taking a lock to protect
> > the SPROM from write concurrency.
> 
> Sure, but why is the locking interruptible rather than plain old
> mutex_lock()?

Hm, well. We hold this mutex for several seconds, as writing takes
this long. So I simply thought it was worth allowing the waiter
to interrupt here. If you say that's not an issue, I'll be happy
to use mutex_lock() and reduce code complexity in this area.

-- 
Greetings Michael.


From mb at bu3sch.de  Fri Jul 27 22:28:01 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 27 Jul 2007 22:28:01 +0200
Subject: [PATCH] Merge the Sonics Silicon Backplane subsystem
In-Reply-To: <20070727131249.74330a3d.akpm@linux-foundation.org>
References: <200707271857.24162.mb@bu3sch.de> <200707272143.59551.mb@bu3sch.de>
	<20070727131249.74330a3d.akpm@linux-foundation.org>
Message-ID: <200707272228.02152.mb@bu3sch.de>

On Friday 27 July 2007 22:12:49 Andrew Morton wrote:
> On Fri, 27 Jul 2007 21:43:59 +0200
> Michael Buesch <mb at bu3sch.de> wrote:
> 
> > > Sure, but why is the locking interruptible rather than plain old
> > > mutex_lock()?
> > 
> > Hm, well. We hold this mutex for several seconds, as writing takes
> > this long. So I simply thought it was worth allowing the waiter
> > to interrupt here. If you say that's not an issue, I'll be happy
> > to use mutex_lock() and reduce code complexity in this area.
> 
> So..  is that what the _interruptible() is for?  To allow an impatient user to ^c
> a read?

Yeah, I thought so.

> If so, that sounds reasonable.  It's worth a comment explaining these decisions
> to future readers, because it is hard to work out this sort of thinking just
> from the bare C code.

Ok, no problem.


-- 
Greetings Michael.


From mb at bu3sch.de  Fri Jul 27 22:55:00 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 27 Jul 2007 22:55:00 +0200
Subject: [PATCH 2] Merge the Sonics Silicon Backplane subsystem
Message-ID: <200707272255.02237.mb@bu3sch.de>

The Sonics Silicon Backplane is a mini-bus used on
various Broadcom chips and embedded devices.
Devices using the SSB include b44, bcm43xx and various
Broadcom based wireless routers.
A b44 and bcm43xx port and a SSB based OHCI driver is available.

Patch #2: This includes a compilation fix for nondebug build (d'oh)
and various small fixes based on comments.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Acked-by: John Linville <linville at tuxdriver.com>

diff --git a/drivers/Makefile b/drivers/Makefile
index a9e4c5f..2b079ed 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -87,3 +87,4 @@ obj-$(CONFIG_DMA_ENGINE)	+= dma/
 obj-$(CONFIG_HID)		+= hid/
 obj-$(CONFIG_PPC_PS3)		+= ps3/
 obj-$(CONFIG_OF)		+= of/
+obj-$(CONFIG_SSB)		+= ssb/
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 3e1c442..7bdae47 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -58,6 +58,8 @@ source "drivers/power/Kconfig"
 
 source "drivers/hwmon/Kconfig"
 
+source "drivers/ssb/Kconfig"
+
 source "drivers/mfd/Kconfig"
 
 source "drivers/media/Kconfig"
diff --git a/drivers/ssb/Makefile b/drivers/ssb/Makefile
new file mode 100644
index 0000000..045aff0
--- /dev/null
+++ b/drivers/ssb/Makefile
@@ -0,0 +1,13 @@
+# core
+ssb-y					+= main.o scan.o
+
+# host support
+ssb-$(CONFIG_SSB_PCIHOST)		+= pci.o pcihost_wrapper.o
+ssb-$(CONFIG_SSB_PCMCIAHOST)		+= pcmcia.o
+
+# built-in drivers
+ssb-y					+= driver_chipcommon.o
+ssb-$(CONFIG_SSB_DRIVER_MIPS)		+= driver_mipscore.o
+ssb-$(CONFIG_SSB_DRIVER_PCICORE)	+= driver_pcicore.o
+
+obj-$(CONFIG_SSB)			+= ssb.o
diff --git a/drivers/ssb/Kconfig b/drivers/ssb/Kconfig
new file mode 100644
index 0000000..34a9411
--- /dev/null
+++ b/drivers/ssb/Kconfig
@@ -0,0 +1,92 @@
+menu "Sonics Silicon Backplane"
+
+config SSB
+	tristate "Sonics Silicon Backplane support"
+	depends on EXPERIMENTAL
+	help
+	  Support for the Sonics Silicon Backplane bus
+
+	  The module will be called ssb
+
+	  If unsure, say M
+
+config SSB_PCIHOST
+	bool "Support for SSB on PCI-bus host"
+	depends on SSB && PCI
+	default y
+	help
+	  Support for a Sonics Silicon Backplane on top
+	  of a PCI device.
+
+	  If unsure, say Y
+
+config SSB_PCMCIAHOST
+	bool "Support for SSB on PCMCIA-bus host"
+	depends on SSB && PCMCIA
+	help
+	  Support for a Sonics Silicon Backplane on top
+	  of a PCMCIA device.
+
+	  If unsure, say N
+
+config SSB_SILENT
+	bool "No SSB kernel messages"
+	depends on SSB
+	help
+	  This option turns off all Sonics Silicon Backplane printks.
+	  Note that you won't be able to identify problems, once
+	  messages are turned off.
+	  This might only be desired for production kernels on
+	  embedded devices to reduce the kernel size.
+
+	  Say N
+
+config SSB_DEBUG
+	bool "SSB debugging"
+	depends on SSB && !SSB_SILENT
+	help
+	  This turns on additional runtime checks and debugging
+	  messages. Turn this on for SSB troubleshooting.
+
+	  If unsure, say N
+
+config SSB_SERIAL
+	bool
+	depends on SSB
+	# ChipCommon and ExtIf serial support routines.
+
+config SSB_DRIVER_PCICORE
+	bool "SSB PCI core driver"
+	depends on SSB && SSB_PCIHOST
+	help
+	  Driver for the Sonics Silicon Backplane attached
+	  Broadcom PCI core.
+
+	  If unsure, say Y
+
+config SSB_PCICORE_HOSTMODE
+	bool "Hostmode support for SSB PCI core"
+	depends on SSB_DRIVER_PCICORE && SSB_DRIVER_MIPS
+	help
+	  PCIcore hostmode operation (external PCI bus).
+
+config SSB_DRIVER_MIPS
+	bool "SSB Broadcom MIPS core driver"
+	depends on SSB && MIPS
+	select SSB_SERIAL
+	help
+	  Driver for the Sonics Silicon Backplane attached
+	  Broadcom MIPS core.
+
+	  If unsure, say N
+
+config SSB_DRIVER_EXTIF
+	bool "SSB Broadcom EXTIF core driver"
+	depends on SSB_DRIVER_MIPS
+	help
+	  Driver for the Sonics Silicon Backplane attached
+	  Broadcom EXTIF core.
+
+	  If unsure, say N
+
+endmenu
diff --git a/drivers/ssb/driver_chipcommon.c b/drivers/ssb/driver_chipcommon.c
new file mode 100644
index 0000000..8e5491c
--- /dev/null
+++ b/drivers/ssb/driver_chipcommon.c
@@ -0,0 +1,394 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom ChipCommon core driver
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+#include <linux/pci.h>
+
+#include "ssb_private.h"
+
+
+/* Clock sources */
+enum ssb_clksrc {
+	/* PCI clock */
+	SSB_CHIPCO_CLKSRC_PCI,
+	/* Crystal slow clock oscillator */
+	SSB_CHIPCO_CLKSRC_XTALOS,
+	/* Low power oscillator */
+	SSB_CHIPCO_CLKSRC_LOPWROS,
+};
+
+
+static inline u32 chipco_read32(struct ssb_chipcommon *cc,
+				u16 offset)
+{
+	return ssb_read32(cc->dev, offset);
+}
+
+static inline void chipco_write32(struct ssb_chipcommon *cc,
+				  u16 offset,
+				  u32 value)
+{
+	ssb_write32(cc->dev, offset, value);
+}
+
+void ssb_chipco_set_clockmode(struct ssb_chipcommon *cc,
+			      enum ssb_clkmode mode)
+{
+	struct ssb_device *ccdev = cc->dev;
+	struct ssb_bus *bus;
+	u32 tmp;
+
+	if (!ccdev)
+		return;
+	bus = ccdev->bus;
+	/* chipcommon cores prior to rev6 don't support dynamic clock control */
+	if (ccdev->id.revision < 6)
+		return;
+	/* chipcommon cores rev10 are a whole new ball game */
+	if (ccdev->id.revision >= 10)
+		return;
+	if (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))
+		return;
+
+	switch (mode) {
+	case SSB_CLKMODE_SLOW:
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp |= SSB_CHIPCO_SLOWCLKCTL_FSLOW;
+		chipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);
+		break;
+	case SSB_CLKMODE_FAST:
+		ssb_pci_xtal(bus, SSB_GPIO_XTAL, 1); /* Force crystal on */
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_FSLOW;
+		tmp |= SSB_CHIPCO_SLOWCLKCTL_IPLL;
+		chipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);
+		break;
+	case SSB_CLKMODE_DYNAMIC:
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_FSLOW;
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_IPLL;
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_ENXTAL;
+		if ((tmp & SSB_CHIPCO_SLOWCLKCTL_SRC) != SSB_CHIPCO_SLOWCLKCTL_SRC_XTAL)
+			tmp |= SSB_CHIPCO_SLOWCLKCTL_ENXTAL;
+		chipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);
+
+		/* for dynamic control, we have to release our xtal_pu "force on" */
+		if (tmp & SSB_CHIPCO_SLOWCLKCTL_ENXTAL)
+			ssb_pci_xtal(bus, SSB_GPIO_XTAL, 0);
+		break;
+	default:
+		SSB_WARN_ON(1);
+	}
+}
+
+/* Get the Slow Clock Source */
+static enum ssb_clksrc chipco_pctl_get_slowclksrc(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	u32 uninitialized_var(tmp);
+
+	if (cc->dev->id.revision < 6) {
+		if (bus->bustype == SSB_BUSTYPE_SSB ||
+		    bus->bustype == SSB_BUSTYPE_PCMCIA)
+			return SSB_CHIPCO_CLKSRC_XTALOS;
+		if (bus->bustype == SSB_BUSTYPE_PCI) {
+			pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT, &tmp);
+			if (tmp & 0x10)
+				return SSB_CHIPCO_CLKSRC_PCI;
+			return SSB_CHIPCO_CLKSRC_XTALOS;
+		}
+	}
+	if (cc->dev->id.revision < 10) {
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp &= 0x7;
+		if (tmp == 0)
+			return SSB_CHIPCO_CLKSRC_LOPWROS;
+		if (tmp == 1)
+			return SSB_CHIPCO_CLKSRC_XTALOS;
+		if (tmp == 2)
+			return SSB_CHIPCO_CLKSRC_PCI;
+	}
+
+	return SSB_CHIPCO_CLKSRC_XTALOS;
+}
+
+/* Get maximum or minimum (depending on get_max flag) slowclock frequency. */
+static int chipco_pctl_clockfreqlimit(struct ssb_chipcommon *cc, int get_max)
+{
+	int uninitialized_var(limit);
+	enum ssb_clksrc clocksrc;
+	int divisor = 1;
+	u32 tmp;
+
+	clocksrc = chipco_pctl_get_slowclksrc(cc);
+	if (cc->dev->id.revision < 6) {
+		switch (clocksrc) {
+		case SSB_CHIPCO_CLKSRC_PCI:
+			divisor = 64;
+			break;
+		case SSB_CHIPCO_CLKSRC_XTALOS:
+			divisor = 32;
+			break;
+		default:
+			SSB_WARN_ON(1);
+		}
+	} else if (cc->dev->id.revision < 10) {
+		switch (clocksrc) {
+		case SSB_CHIPCO_CLKSRC_LOPWROS:
+			break;
+		case SSB_CHIPCO_CLKSRC_XTALOS:
+		case SSB_CHIPCO_CLKSRC_PCI:
+			tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+			divisor = (tmp >> 16) + 1;
+			divisor *= 4;
+			break;
+		}
+	} else {
+		tmp = chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL);
+		divisor = (tmp >> 16) + 1;
+		divisor *= 4;
+	}
+
+	switch (clocksrc) {
+	case SSB_CHIPCO_CLKSRC_LOPWROS:
+		if (get_max)
+			limit = 43000;
+		else
+			limit = 25000;
+		break;
+	case SSB_CHIPCO_CLKSRC_XTALOS:
+		if (get_max)
+			limit = 20200000;
+		else
+			limit = 19800000;
+		break;
+	case SSB_CHIPCO_CLKSRC_PCI:
+		if (get_max)
+			limit = 34000000;
+		else
+			limit = 25000000;
+		break;
+	}
+	limit /= divisor;
+
+	return limit;
+}
+
+static void chipco_powercontrol_init(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+
+	if (bus->chip_id == 0x4321) {
+		if (bus->chip_rev == 0)
+			chipco_write32(cc, SSB_CHIPCO_CHIPCTL, 0x3A4);
+		else if (bus->chip_rev == 1)
+			chipco_write32(cc, SSB_CHIPCO_CHIPCTL, 0xA4);
+	}
+
+	if (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))
+		return;
+
+	if (cc->dev->id.revision >= 10) {
+		/* Set Idle Power clock rate to 1Mhz */
+		chipco_write32(cc, SSB_CHIPCO_SYSCLKCTL,
+			       (chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL) &
+				0x0000FFFF) | 0x00040000);
+	} else {
+		int maxfreq;
+
+		maxfreq = chipco_pctl_clockfreqlimit(cc, 1);
+		chipco_write32(cc, SSB_CHIPCO_PLLONDELAY,
+			       (maxfreq * 150 + 999999) / 1000000);
+		chipco_write32(cc, SSB_CHIPCO_FREFSELDELAY,
+			       (maxfreq * 15 + 999999) / 1000000);
+	}
+}
+
+static void calc_fast_powerup_delay(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	int minfreq;
+	unsigned int tmp;
+	u32 pll_on_delay;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return;
+	if (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))
+		return;
+
+	minfreq = chipco_pctl_clockfreqlimit(cc, 0);
+	pll_on_delay = chipco_read32(cc, SSB_CHIPCO_PLLONDELAY);
+	tmp = (((pll_on_delay + 2) * 1000000) + (minfreq - 1)) / minfreq;
+	SSB_WARN_ON(tmp & ~0xFFFF);
+
+	cc->fast_pwrup_delay = tmp;
+}
+
+void ssb_chipcommon_init(struct ssb_chipcommon *cc)
+{
+	if (!cc->dev)
+		return; /* We don't have a ChipCommon */
+	chipco_powercontrol_init(cc);
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_FAST);
+	calc_fast_powerup_delay(cc);
+}
+
+void ssb_chipco_suspend(struct ssb_chipcommon *cc, pm_message_t state)
+{
+	if (!cc->dev)
+		return;
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_SLOW);
+}
+
+void ssb_chipco_resume(struct ssb_chipcommon *cc)
+{
+	if (!cc->dev)
+		return;
+	chipco_powercontrol_init(cc);
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_FAST);
+}
+
+void ssb_chipco_get_clockcontrol(struct ssb_chipcommon *cc,
+				 u32 *plltype, u32 *n, u32 *m)
+{
+	*n = chipco_read32(cc, SSB_CHIPCO_CLOCK_N);
+	*plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);
+	switch (*plltype) {
+	case SSB_PLLTYPE_6: /* 100/200 or 120/240 only */
+		*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_MIPS);
+		break;
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+		if (cc->dev->bus->chip_id != 0x5365) {
+			*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_M2);
+			break;
+		}
+		/* Fallthough */
+	default:
+		*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_SB);
+	}
+}
+
+void ssb_chipco_timing_init(struct ssb_chipcommon *cc,
+			    unsigned long ns)
+{
+	struct ssb_device *dev = cc->dev;
+	struct ssb_bus *bus = dev->bus;
+	u32 tmp;
+
+	/* set register for external IO to control LED. */
+	chipco_write32(cc, SSB_CHIPCO_PROG_CFG, 0x11);
+	tmp = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;		/* Waitcount-3 = 10ns */
+	tmp |= DIV_ROUND_UP(40, ns) << SSB_PROG_WCNT_1_SHIFT;	/* Waitcount-1 = 40ns */
+	tmp |= DIV_ROUND_UP(240, ns);				/* Waitcount-0 = 240ns */
+	chipco_write32(cc, SSB_CHIPCO_PROG_WAITCNT, tmp);	/* 0x01020a0c for a 100Mhz clock */
+
+	/* Set timing for the flash */
+	tmp = DIV_ROUND_UP(10, ns) << SSB_FLASH_WCNT_3_SHIFT;	/* Waitcount-3 = 10nS */
+	tmp |= DIV_ROUND_UP(10, ns) << SSB_FLASH_WCNT_1_SHIFT;	/* Waitcount-1 = 10nS */
+	tmp |= DIV_ROUND_UP(120, ns);				/* Waitcount-0 = 120nS */
+	if ((bus->chip_id == 0x5365) ||
+	    (dev->id.revision < 9))
+		chipco_write32(cc, SSB_CHIPCO_FLASH_WAITCNT, tmp);
+	if ((bus->chip_id == 0x5365) ||
+	    (dev->id.revision < 9) ||
+	    ((bus->chip_id == 0x5350) && (bus->chip_rev == 0)))
+		chipco_write32(cc, SSB_CHIPCO_PCMCIA_MEMWAIT, tmp);
+
+	if (bus->chip_id == 0x5350) {
+		/* Enable EXTIF */
+		tmp = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;	  /* Waitcount-3 = 10ns */
+		tmp |= DIV_ROUND_UP(20, ns) << SSB_PROG_WCNT_2_SHIFT;  /* Waitcount-2 = 20ns */
+		tmp |= DIV_ROUND_UP(100, ns) << SSB_PROG_WCNT_1_SHIFT; /* Waitcount-1 = 100ns */
+		tmp |= DIV_ROUND_UP(120, ns);			  /* Waitcount-0 = 120ns */
+		chipco_write32(cc, SSB_CHIPCO_PROG_WAITCNT, tmp); /* 0x01020a0c for a 100Mhz clock */
+	}
+}
+
+
+#ifdef CONFIG_SSB_SERIAL
+int ssb_chipco_serial_init(struct ssb_chipcommon *cc,
+			   struct ssb_serial_port *ports)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	int nr_ports = 0;
+	u32 plltype;
+	unsigned int irq;
+	u32 baud_base, div;
+	u32 i, n;
+
+	plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);
+	irq = ssb_mips_irq(cc->dev);
+
+	if (plltype == SSB_PLLTYPE_1) {
+		/* PLL clock */
+		baud_base = ssb_calc_clock_rate(plltype,
+						chipco_read32(cc, SSB_CHIPCO_CLOCK_N),
+						chipco_read32(cc, SSB_CHIPCO_CLOCK_M2));
+		div = 1;
+	} else {
+		if (cc->dev->id.revision >= 11) {
+			/* Fixed ALP clock */
+			baud_base = 20000000;
+			div = 1;
+			/* Set the override bit so we don't divide it */
+			chipco_write32(cc, SSB_CHIPCO_CORECTL,
+				       SSB_CHIPCO_CORECTL_UARTCLK0);
+		} else if (cc->dev->id.revision >= 3) {
+			/* Internal backplane clock */
+			baud_base = ssb_clockspeed(bus);
+			div = 2; /* Minimum divisor */
+			chipco_write32(cc, SSB_CHIPCO_CLKDIV,
+				       (chipco_read32(cc, SSB_CHIPCO_CLKDIV)
+					& ~SSB_CHIPCO_CLKDIV_UART) | div);
+		} else {
+			/* Fixed internal backplane clock */
+			baud_base = 88000000;
+			div = 48;
+		}
+
+		/* Clock source depends on strapping if UartClkOverride is unset */
+		if ((cc->dev->id.revision > 0) &&
+		    !(chipco_read32(cc, SSB_CHIPCO_CORECTL) & SSB_CHIPCO_CORECTL_UARTCLK0)) {
+			if ((cc->capabilities & SSB_CHIPCO_CAP_UARTCLK) ==
+			    SSB_CHIPCO_CAP_UARTCLK_INT) {
+				/* Internal divided backplane clock */
+				baud_base /= div;
+			} else {
+				/* Assume external clock of 1.8432 MHz */
+				baud_base = 1843200;
+			}
+		}
+	}
+
+	/* Determine the registers of the UARTs */
+	n = (cc->capabilities & SSB_CHIPCO_CAP_NRUART);
+	for (i = 0; i < n; i++) {
+		void __iomem *cc_mmio;
+		void __iomem *uart_regs;
+
+		cc_mmio = cc->dev->bus->mmio + (cc->dev->core_index * SSB_CORE_SIZE);
+		uart_regs = cc_mmio + SSB_CHIPCO_UART0_DATA;
+		/* Offset changed at after rev 0 */
+		if (cc->dev->id.revision == 0)
+			uart_regs += (i * 8);
+		else
+			uart_regs += (i * 256);
+
+		nr_ports++;
+		ports[i].regs = uart_regs;
+		ports[i].irq = irq;
+		ports[i].baud_base = baud_base;
+		ports[i].reg_shift = 0;
+	}
+
+	return nr_ports;
+}
+#endif /* CONFIG_SSB_SERIAL */
diff --git a/drivers/ssb/driver_mipscore.c b/drivers/ssb/driver_mipscore.c
new file mode 100644
index 0000000..3f09598
--- /dev/null
+++ b/drivers/ssb/driver_mipscore.c
@@ -0,0 +1,258 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom MIPS core driver
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+#include <linux/time.h>
+
+#include "ssb_private.h"
+
+
+static inline u32 mips_read32(struct ssb_mipscore *mcore,
+			      u16 offset)
+{
+	return ssb_read32(mcore->dev, offset);
+}
+
+static inline void mips_write32(struct ssb_mipscore *mcore,
+				u16 offset,
+				u32 value)
+{
+	ssb_write32(mcore->dev, offset, value);
+}
+
+static const u32 ipsflag_irq_mask[] = {
+	0,
+	SSB_IPSFLAG_IRQ1,
+	SSB_IPSFLAG_IRQ2,
+	SSB_IPSFLAG_IRQ3,
+	SSB_IPSFLAG_IRQ4,
+};
+
+static const u32 ipsflag_irq_shift[] = {
+	0,
+	SSB_IPSFLAG_IRQ1_SHIFT,
+	SSB_IPSFLAG_IRQ2_SHIFT,
+	SSB_IPSFLAG_IRQ3_SHIFT,
+	SSB_IPSFLAG_IRQ4_SHIFT,
+};
+
+static inline u32 ssb_irqflag(struct ssb_device *dev)
+{
+	return ssb_read32(dev, SSB_TPSFLAG) & SSB_TPSFLAG_BPFLAG;
+}
+
+/* Get the MIPS IRQ assignment for a specified device.
+ * If unassigned, 0 is returned.
+ */
+unsigned int ssb_mips_irq(struct ssb_device *dev)
+{
+	struct ssb_bus *bus = dev->bus;
+	u32 irqflag;
+	u32 ipsflag;
+	u32 tmp;
+	unsigned int irq;
+
+	irqflag = ssb_irqflag(dev);
+	ipsflag = ssb_read32(bus->mipscore.dev, SSB_IPSFLAG);
+	for (irq = 1; irq <= 4; irq++) {
+		tmp = ((ipsflag & ipsflag_irq_mask[irq]) >> ipsflag_irq_shift[irq]);
+		if (tmp == irqflag)
+			break;
+	}
+	if (irq	== 5)
+		irq = 0;
+
+	return irq;
+}
+
+static void clear_irq(struct ssb_bus *bus, unsigned int irq)
+{
+	struct ssb_device *dev = bus->mipscore.dev;
+
+	/* Clear the IRQ in the MIPScore backplane registers */
+	if (irq == 0) {
+		ssb_write32(dev, SSB_INTVEC, 0);
+	} else {
+		ssb_write32(dev, SSB_IPSFLAG,
+			    ssb_read32(dev, SSB_IPSFLAG) |
+			    ipsflag_irq_mask[irq]);
+	}
+}
+
+static void set_irq(struct ssb_device *dev, unsigned int irq)
+{
+	unsigned int oldirq = ssb_mips_irq(dev);
+	struct ssb_bus *bus = dev->bus;
+	struct ssb_device *mdev = bus->mipscore.dev;
+	u32 irqflag = ssb_irqflag(dev);
+
+	dev->irq = irq + 2;
+
+	ssb_dprintk(KERN_INFO PFX
+		    "set_irq: core 0x%04x, irq %d => %d\n",
+		    dev->id.coreid, oldirq, irq);
+	/* clear the old irq */
+	if (oldirq == 0)
+		ssb_write32(mdev, SSB_INTVEC, (~(1 << irqflag) & ssb_read32(mdev, SSB_INTVEC)));
+	else
+		clear_irq(bus, oldirq);
+
+	/* assign the new one */
+	if (irq == 0)
+		ssb_write32(mdev, SSB_INTVEC, ((1 << irqflag) & ssb_read32(mdev, SSB_INTVEC)));
+
+	irqflag <<= ipsflag_irq_shift[irq];
+	irqflag |= (ssb_read32(mdev, SSB_IPSFLAG) & ~ipsflag_irq_mask[irq]);
+	ssb_write32(mdev, SSB_IPSFLAG, irqflag);
+}
+
+/* XXX: leave here or move into separate extif driver? */
+static int ssb_extif_serial_init(struct ssb_device *dev, struct ssb_serial_ports *ports)
+{
+
+}
+
+
+static void ssb_mips_serial_init(struct ssb_mipscore *mcore)
+{
+	struct ssb_bus *bus = mcore->dev->bus;
+
+	//TODO if (EXTIF available
+#if 0
+		extifregs_t *eir = (extifregs_t *) regs;
+		sbconfig_t *sb;
+
+		/* Determine external UART register base */
+		sb = (sbconfig_t *)((ulong) eir + SBCONFIGOFF);
+		base = EXTIF_CFGIF_BASE(sb_base(R_REG(&sb->sbadmatch1)));
+
+		/* Determine IRQ */
+		irq = sb_irq(sbh);
+
+		/* Disable GPIO interrupt initially */
+		W_REG(&eir->gpiointpolarity, 0);
+		W_REG(&eir->gpiointmask, 0);
+
+		/* Search for external UARTs */
+		n = 2;
+		for (i = 0; i < 2; i++) {
+			regs = (void *) REG_MAP(base + (i * 8), 8);
+			if (BCMINIT(serial_exists)(regs)) {
+				/* Set GPIO 1 to be the external UART IRQ */
+				W_REG(&eir->gpiointmask, 2);
+				if (add)
+					add(regs, irq, 13500000, 0);
+			}
+		}
+
+		/* Add internal UART if enabled */
+		if (R_REG(&eir->corecontrol) & CC_UE)
+			if (add)
+				add((void *) &eir->uartdata, irq, sb_clock(sbh), 2);
+
+#endif
+	if (bus->extif.dev)
+		mcore->nr_serial_ports = ssb_extif_serial_init(&bus->extif, mcore->serial_ports);
+	else if (bus->chipco.dev)
+		mcore->nr_serial_ports = ssb_chipco_serial_init(&bus->chipco, mcore->serial_ports);
+	else
+		mcore->nr_serial_ports = 0;
+}
+
+static void ssb_mips_flash_detect(struct ssb_mipscore *mcore)
+{
+	struct ssb_bus *bus = mcore->dev->bus;
+
+	if (bus->chipco.dev) {
+		mcore->flash_window = 0x1c000000;
+		mcore->flash_window_size = 0x800000;
+	} else {
+		mcore->flash_window = 0x1fc00000;
+		mcore->flash_window_size = 0x400000;
+	}
+}
+
+
+static void ssb_cpu_clock(struct ssb_mipscore *mcore)
+{
+}
+
+void ssb_mipscore_init(struct ssb_mipscore *mcore)
+{
+	struct ssb_bus *bus = mcore->dev->bus;
+	struct ssb_device *dev;
+	unsigned long hz, ns;
+	unsigned int irq, i;
+
+	if (!mcore->dev)
+		return; /* We don't have a MIPS core */
+
+	ssb_dprintk(KERN_INFO PFX "Initializing MIPS core...\n");
+
+	hz = ssb_clockspeed(bus);
+	if (!hz)
+		hz = 100000000;
+	ns = 1000000000 / hz;
+
+//TODO
+#if 0
+	if (have EXTIF) {
+		/* Initialize extif so we can get to the LEDs and external UART */
+		W_REG(&eir->prog_config, CF_EN);
+
+		/* Set timing for the flash */
+		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
+		tmp = tmp | (CEIL(40, ns) << FW_W1_SHIFT); /* W1 = 40nS */
+		tmp = tmp | CEIL(120, ns);		/* W0 = 120nS */
+		W_REG(&eir->prog_waitcount, tmp);	/* 0x01020a0c for a 100Mhz clock */
+
+		/* Set programmable interface timing for external uart */
+		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
+		tmp = tmp | (CEIL(20, ns) << FW_W2_SHIFT); /* W2 = 20nS */
+		tmp = tmp | (CEIL(100, ns) << FW_W1_SHIFT); /* W1 = 100nS */
+		tmp = tmp | CEIL(120, ns);		/* W0 = 120nS */
+		W_REG(&eir->prog_waitcount, tmp);
+	}
+#endif
+	if (bus->chipco.dev)
+		ssb_chipco_timing_init(&bus->chipco, ns);
+
+	/* Assign IRQs to all cores on the bus, start with irq line 2, because serial usually takes 1 */
+	for (irq = 2, i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		dev->irq = ssb_mips_irq(dev) + 2;
+		switch (dev->id.coreid) {
+		case SSB_DEV_USB11_HOST:
+			/* shouldn't need a separate irq line for non-4710, most of them have a proper
+			 * external usb controller on the pci */
+			if ((bus->chip_id == 0x4710) && (irq <= 4)) {
+				set_irq(dev, irq++);
+				break;
+			}
+			/* fallthrough */
+		case SSB_DEV_PCI:
+		case SSB_DEV_ETHERNET:
+		case SSB_DEV_80211:
+		case SSB_DEV_USB20_HOST:
+			/* These devices get their own IRQ line if available, the rest goes on IRQ0 */
+			if (irq <= 4) {
+				set_irq(dev, irq++);
+				break;
+			}
+		}
+	}
+
+	ssb_mips_serial_init(mcore);
+	ssb_mips_flash_detect(mcore);
+}
diff --git a/drivers/ssb/driver_pcicore.c b/drivers/ssb/driver_pcicore.c
new file mode 100644
index 0000000..e11b103
--- /dev/null
+++ b/drivers/ssb/driver_pcicore.c
@@ -0,0 +1,568 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom PCI-core driver
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include "ssb_private.h"
+
+
+static inline
+u32 pcicore_read32(struct ssb_pcicore *pc, u16 offset)
+{
+	return ssb_read32(pc->dev, offset);
+}
+
+static inline
+void pcicore_write32(struct ssb_pcicore *pc, u16 offset, u32 value)
+{
+	ssb_write32(pc->dev, offset, value);
+}
+
+/**************************************************
+ * Code for hostmode operation.
+ **************************************************/
+
+#ifdef CONFIG_SSB_PCICORE_HOSTMODE
+
+#include <asm/paccess.h>
+/* Probe a 32bit value on the bus and catch bus exceptions.
+ * Returns nonzero on a bus exception.
+ * This is MIPS specific */
+#define mips_busprobe32(val, addr)	get_dbe((val), ((u32 *)(addr)))
+
+/* Assume one-hot slot wiring */
+#define SSB_PCI_SLOT_MAX	16
+
+/* Global lock is OK, as we won't have more than one extpci anyway. */
+static DEFINE_SPINLOCK(cfgspace_lock);
+/* Core to access the external PCI config space. Can only have one. */
+static struct ssb_pcicore *extpci_core;
+
+static u32 ssb_pcicore_pcibus_iobase = 0x100;
+static u32 ssb_pcicore_pcibus_membase = SSB_PCI_DMA;
+
+int pcibios_plat_dev_init(struct pci_dev *d)
+{
+	struct resource *res;
+	int pos, size;
+	u32 *base;
+
+	ssb_printk(KERN_INFO "PCI: Fixing up device %s\n",
+		   pci_name(d));
+
+	/* Fix up resource bases */
+	for (pos = 0; pos < 6; pos++) {
+		res = &d->resource[pos];
+		if (res->flags & IORESOURCE_IO)
+			base = &ssb_pcicore_pcibus_iobase;
+		else
+			base = &ssb_pcicore_pcibus_membase;
+		if (res->end) {
+			size = res->end - res->start + 1;
+			if (*base & (size - 1))
+				*base = (*base + size) & ~(size - 1);
+			res->start = *base;
+			res->end = res->start + size - 1;
+			*base += size;
+			pci_write_config_dword(d, PCI_BASE_ADDRESS_0 + (pos << 2), res->start);
+		}
+		/* Fix up PCI bridge BAR0 only */
+		if (d->bus->number == 0 && PCI_SLOT(d->devfn) == 0)
+			break;
+	}
+	/* Fix up interrupt lines */
+	d->irq = ssb_mips_irq(extpci_core->dev) + 2;
+	pci_write_config_byte(d, PCI_INTERRUPT_LINE, d->irq);
+
+	return 0;
+}
+
+static void __init ssb_fixup_pcibridge(struct pci_dev *dev)
+{
+	if (dev->bus->number != 0 || PCI_SLOT(dev->devfn) != 0)
+		return;
+
+	ssb_printk(KERN_INFO "PCI: fixing up bridge\n");
+
+	/* Enable PCI bridge bus mastering and memory space */
+	pci_set_master(dev);
+	pcibios_enable_device(dev, ~0);
+
+	/* Enable PCI bridge BAR1 prefetch and burst */
+	pci_write_config_dword(dev, SSB_BAR1_CONTROL, 3);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, ssb_fixup_pcibridge);
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return ssb_mips_irq(extpci_core->dev) + 2;
+}
+
+static u32 get_cfgspace_addr(struct ssb_pcicore *pc,
+			     unsigned int bus, unsigned int dev,
+			     unsigned int func, unsigned int off)
+{
+	u32 addr = 0;
+	u32 tmp;
+
+	if (unlikely(pc->cardbusmode && dev > 1))
+		goto out;
+	if (bus == 0) {
+		/* Type 0 transaction */
+		if (unlikely(dev >= SSB_PCI_SLOT_MAX))
+			goto out;
+		/* Slide the window */
+		tmp = SSB_PCICORE_SBTOPCI_CFG0;
+		tmp |= ((1 << (dev + 16)) & SSB_PCICORE_SBTOPCI1_MASK);
+		pcicore_write32(pc, SSB_PCICORE_SBTOPCI1, tmp);
+		/* Calculate the address */
+		addr = SSB_PCI_CFG;
+		addr |= ((1 << (dev + 16)) & ~SSB_PCICORE_SBTOPCI1_MASK);
+		addr |= (func << 8);
+		addr |= (off & ~3);
+	} else {
+		/* Type 1 transaction */
+		pcicore_write32(pc, SSB_PCICORE_SBTOPCI1,
+				SSB_PCICORE_SBTOPCI_CFG1);
+		/* Calculate the address */
+		addr = SSB_PCI_CFG;
+		addr |= (bus << 16);
+		addr |= (dev << 11);
+		addr |= (func << 8);
+		addr |= (off & ~3);
+	}
+out:
+	return addr;
+}
+
+static int ssb_extpci_read_config(struct ssb_pcicore *pc,
+				  unsigned int bus, unsigned int dev,
+				  unsigned int func, unsigned int off,
+				  void *buf, int len)
+{
+	int err = -EINVAL;
+	u32 addr, val;
+	void __iomem *mmio;
+
+	SSB_WARN_ON(!pc->hostmode);
+	if (unlikely(len != 1 && len != 2 && len != 4))
+		goto out;
+	addr = get_cfgspace_addr(pc, bus, dev, func, off);
+	if (unlikely(!addr))
+		goto out;
+	err = -ENOMEM;
+	mmio = ioremap_nocache(addr, len);
+	if (!mmio)
+		goto out;
+
+	if (mips_busprobe32(val, mmio)) {
+		val = 0xffffffff;
+		goto unmap;
+	}
+
+	val = readl(mmio);
+	val >>= (8 * (off & 3));
+
+	switch (len) {
+	case 1:
+		*((u8 *)buf) = (u8)val;
+		break;
+	case 2:
+		*((u16 *)buf) = (u16)val;
+		break;
+	case 4:
+		*((u32 *)buf) = (u32)val;
+		break;
+	}
+	err = 0;
+unmap:
+	iounmap(mmio);
+out:
+	return err;
+}
+
+static int ssb_extpci_write_config(struct ssb_pcicore *pc,
+				   unsigned int bus, unsigned int dev,
+				   unsigned int func, unsigned int off,
+				   const void *buf, int len)
+{
+	int err = -EINVAL;
+	u32 addr, val = 0;
+	void __iomem *mmio;
+
+	SSB_WARN_ON(!pc->hostmode);
+	if (unlikely(len != 1 && len != 2 && len != 4))
+		goto out;
+	addr = get_cfgspace_addr(pc, bus, dev, func, off);
+	if (unlikely(!addr))
+		goto out;
+	err = -ENOMEM;
+	mmio = ioremap_nocache(addr, len);
+	if (!mmio)
+		goto out;
+
+	if (mips_busprobe32(val, mmio)) {
+		val = 0xffffffff;
+		goto unmap;
+	}
+
+	switch (len) {
+	case 1:
+		val = readl(mmio);
+		val &= ~(0xFF << (8 * (off & 3)));
+		val |= *((const u8 *)buf) << (8 * (off & 3));
+		break;
+	case 2:
+		val = readl(mmio);
+		val &= ~(0xFFFF << (8 * (off & 3)));
+		val |= *((const u16 *)buf) << (8 * (off & 3));
+		break;
+	case 4:
+		val = *((const u32 *)buf);
+		break;
+	}
+	writel(*((const u32 *)buf), mmio);
+
+	err = 0;
+unmap:
+	iounmap(mmio);
+out:
+	return err;
+}
+
+static int ssb_pcicore_read_config(struct pci_bus *bus, unsigned int devfn,
+				   int reg, int size, u32 *val)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&cfgspace_lock, flags);
+	err = ssb_extpci_read_config(extpci_core, bus->number, PCI_SLOT(devfn),
+				     PCI_FUNC(devfn), reg, val, size);
+	spin_unlock_irqrestore(&cfgspace_lock, flags);
+
+	return err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+}
+
+static int ssb_pcicore_write_config(struct pci_bus *bus, unsigned int devfn,
+				    int reg, int size, u32 val)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&cfgspace_lock, flags);
+	err = ssb_extpci_write_config(extpci_core, bus->number, PCI_SLOT(devfn),
+				      PCI_FUNC(devfn), reg, &val, size);
+	spin_unlock_irqrestore(&cfgspace_lock, flags);
+
+	return err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops ssb_pcicore_pciops = {
+	.read	= ssb_pcicore_read_config,
+	.write	= ssb_pcicore_write_config,
+};
+
+static struct resource ssb_pcicore_mem_resource = {
+	.name	= "SSB PCIcore external memory",
+	.start	= SSB_PCI_DMA,
+	.end	= SSB_PCI_DMA + SSB_PCI_DMA_SZ - 1,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct resource ssb_pcicore_io_resource = {
+	.name	= "SSB PCIcore external I/O",
+	.start	= 0x100,
+	.end	= 0x7FF,
+	.flags	= IORESOURCE_IO,
+};
+
+static struct pci_controller ssb_pcicore_controller = {
+	.pci_ops	= &ssb_pcicore_pciops,
+	.io_resource	= &ssb_pcicore_io_resource,
+	.mem_resource	= &ssb_pcicore_mem_resource,
+	.mem_offset	= 0x24000000,
+};
+
+static void ssb_pcicore_init_hostmode(struct ssb_pcicore *pc)
+{
+	u32 val;
+
+	if (WARN_ON(extpci_core))
+		return;
+	extpci_core = pc;
+
+	ssb_dprintk(KERN_INFO PFX "PCIcore in host mode found\n");
+	/* Reset devices on the external PCI bus */
+	val = SSB_PCICORE_CTL_RST_OE;
+	val |= SSB_PCICORE_CTL_CLK_OE;
+	pcicore_write32(pc, SSB_PCICORE_CTL, val);
+	val |= SSB_PCICORE_CTL_CLK; /* Clock on */
+	pcicore_write32(pc, SSB_PCICORE_CTL, val);
+	udelay(150); /* Assertion time demanded by the PCI standard */
+	val |= SSB_PCICORE_CTL_RST; /* Deassert RST# */
+	pcicore_write32(pc, SSB_PCICORE_CTL, val);
+	udelay(1); /* Assertion time demanded by the PCI standard */
+
+	/*TODO cardbus mode */
+
+	/* 64MB I/O window */
+	pcicore_write32(pc, SSB_PCICORE_SBTOPCI0,
+			SSB_PCICORE_SBTOPCI_IO);
+	/* 64MB config space */
+	pcicore_write32(pc, SSB_PCICORE_SBTOPCI1,
+			SSB_PCICORE_SBTOPCI_CFG0);
+	/* 1GB memory window */
+	pcicore_write32(pc, SSB_PCICORE_SBTOPCI2,
+			SSB_PCICORE_SBTOPCI_MEM | SSB_PCI_DMA);
+
+	/* Enable PCI bridge BAR0 prefetch and burst */
+	val = PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	ssb_extpci_write_config(pc, 0, 0, 0, PCI_COMMAND, &val, 2);
+	/* Clear error conditions */
+	val = 0;
+	ssb_extpci_write_config(pc, 0, 0, 0, PCI_STATUS, &val, 2);
+
+	/* Enable PCI interrupts */
+	pcicore_write32(pc, SSB_PCICORE_IMASK,
+			SSB_PCICORE_IMASK_INTA);
+
+	/* Ok, ready to run, register it to the system.
+	 * The following needs change, if we want to port hostmode
+	 * to non-MIPS platform. */
+	set_io_port_base((unsigned long)ioremap_nocache(SSB_PCI_MEM, 0x04000000));
+	register_pci_controller(&ssb_pcicore_controller);
+}
+
+static int pcicore_is_in_hostmode(struct ssb_pcicore *pc)
+{
+	struct ssb_bus *bus = pc->dev->bus;
+	u16 chipid_top;
+	u32 tmp;
+
+	chipid_top = (bus->chip_id & 0xFF00);
+	if (chipid_top != 0x4700 &&
+	    chipid_top != 0x5300)
+		return 0;
+
+	if (bus->sprom.r1.boardflags_lo & SSB_PCICORE_BFL_NOPCI)
+		return 0;
+
+	/* The 200-pin BCM4712 package does not bond out PCI. Even when
+	 * PCI is bonded out, some boards may leave the pins floating. */
+	if (bus->chip_id == 0x4712) {
+		if (bus->chip_package == SSB_CHIPPACK_BCM4712S)
+			return 0;
+		if (bus->chip_package == SSB_CHIPPACK_BCM4712M)
+			return 0;
+	}
+	if (bus->chip_id == 0x5350)
+		return 0;
+
+	return !mips_busprobe32(tmp, (bus->mmio + (pc->dev->core_index * SSB_CORE_SIZE)));
+}
+#endif /* CONFIG_SSB_PCICORE_HOSTMODE */
+
+
+/**************************************************
+ * Generic and Clientmode operation code.
+ **************************************************/
+
+static void ssb_pcicore_init_clientmode(struct ssb_pcicore *pc)
+{
+	/* Disable PCI interrupts. */
+	ssb_write32(pc->dev, SSB_INTVEC, 0);
+}
+
+void ssb_pcicore_init(struct ssb_pcicore *pc)
+{
+	struct ssb_device *dev = pc->dev;
+	struct ssb_bus *bus;
+
+	if (!dev)
+		return;
+	bus = dev->bus;
+	if (!ssb_device_is_enabled(dev))
+		ssb_device_enable(dev, 0);
+
+#ifdef CONFIG_SSB_PCICORE_HOSTMODE
+	pc->hostmode = pcicore_is_in_hostmode(pc);
+	if (pc->hostmode)
+		ssb_pcicore_init_hostmode(pc);
+#endif /* CONFIG_SSB_PCICORE_HOSTMODE */
+	if (!pc->hostmode)
+		ssb_pcicore_init_clientmode(pc);
+}
+
+static u32 ssb_pcie_read(struct ssb_pcicore *pc, u32 address)
+{
+	pcicore_write32(pc, 0x130, address);
+	return pcicore_read32(pc, 0x134);
+}
+
+static void ssb_pcie_write(struct ssb_pcicore *pc, u32 address, u32 data)
+{
+	pcicore_write32(pc, 0x130, address);
+	pcicore_write32(pc, 0x134, data);
+}
+
+static void ssb_pcie_mdio_write(struct ssb_pcicore *pc, u8 device,
+				u8 address, u16 data)
+{
+	const u16 mdio_control = 0x128;
+	const u16 mdio_data = 0x12C;
+	u32 v;
+	int i;
+
+	v = 0x80; /* Enable Preamble Sequence */
+	v |= 0x2; /* MDIO Clock Divisor */
+	pcicore_write32(pc, mdio_control, v);
+
+	v = (1 << 30); /* Start of Transaction */
+	v |= (1 << 28); /* Write Transaction */
+	v |= (1 << 17); /* Turnaround */
+	v |= (u32)device << 22;
+	v |= (u32)address << 18;
+	v |= data;
+	pcicore_write32(pc, mdio_data, v);
+	/* Wait for the device to complete the transaction */
+	udelay(10);
+	for (i = 0; i < 10; i++) {
+		v = pcicore_read32(pc, mdio_control);
+		if (v & 0x100 /* Trans complete */)
+			break;
+		msleep(1);
+	}
+	pcicore_write32(pc, mdio_control, 0);
+}
+
+static void ssb_broadcast_value(struct ssb_device *dev,
+				u32 address, u32 data)
+{
+	/* This is used for both, PCI and ChipCommon core, so be careful. */
+	BUILD_BUG_ON(SSB_PCICORE_BCAST_ADDR != SSB_CHIPCO_BCAST_ADDR);
+	BUILD_BUG_ON(SSB_PCICORE_BCAST_DATA != SSB_CHIPCO_BCAST_DATA);
+
+	ssb_write32(dev, SSB_PCICORE_BCAST_ADDR, address);
+	ssb_read32(dev, SSB_PCICORE_BCAST_ADDR); /* flush */
+	ssb_write32(dev, SSB_PCICORE_BCAST_DATA, data);
+	ssb_read32(dev, SSB_PCICORE_BCAST_DATA); /* flush */
+}
+
+static void ssb_commit_settings(struct ssb_bus *bus)
+{
+	struct ssb_device *dev;
+
+	dev = bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev;
+	if (WARN_ON(!dev))
+		return;
+	/* This forces an update of the cached registers. */
+	ssb_broadcast_value(dev, 0xFD8, 0);
+}
+
+int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
+				   struct ssb_device *dev)
+{
+	struct ssb_device *pdev = pc->dev;
+	struct ssb_bus *bus;
+	int err = 0;
+	u32 tmp;
+
+	might_sleep();
+
+	if (!pdev)
+		goto out;
+	bus = pdev->bus;
+
+	/* Enable interrupts for this device. */
+	if (bus->host_pci &&
+	    ((pdev->id.revision >= 6) || (pdev->id.coreid == SSB_DEV_PCIE))) {
+		u32 coremask;
+
+		/* Calculate the "coremask" for the device. */
+		coremask = (1 << dev->core_index);
+
+		err = pci_read_config_dword(bus->host_pci, SSB_PCI_IRQMASK, &tmp);
+		if (err)
+			goto out;
+		tmp |= coremask << 8;
+		err = pci_write_config_dword(bus->host_pci, SSB_PCI_IRQMASK, tmp);
+		if (err)
+			goto out;
+	} else {
+		u32 intvec;
+
+		intvec = ssb_read32(pdev, SSB_INTVEC);
+		if ((bus->chip_id & 0xFF00) == 0x4400) {
+			/* Workaround: On the BCM44XX the BPFLAG routing
+			 * bit is wrong. Use a hardcoded constant. */
+			intvec |= 0x00000002;
+		} else {
+			tmp = ssb_read32(dev, SSB_TPSFLAG);
+			tmp &= SSB_TPSFLAG_BPFLAG;
+			intvec |= tmp;
+		}
+		ssb_write32(pdev, SSB_INTVEC, intvec);
+	}
+
+	/* Setup PCIcore operation. */
+	if (pc->setup_done)
+		goto out;
+	if (pdev->id.coreid == SSB_DEV_PCI) {
+		tmp = pcicore_read32(pc, SSB_PCICORE_SBTOPCI2);
+		tmp |= SSB_PCICORE_SBTOPCI_PREF;
+		tmp |= SSB_PCICORE_SBTOPCI_BURST;
+		pcicore_write32(pc, SSB_PCICORE_SBTOPCI2, tmp);
+
+		if (pdev->id.revision < 5) {
+			tmp = ssb_read32(pdev, SSB_IMCFGLO);
+			tmp &= ~SSB_IMCFGLO_SERTO;
+			tmp |= 2;
+			tmp &= ~SSB_IMCFGLO_REQTO;
+			tmp |= 3 << SSB_IMCFGLO_REQTO_SHIFT;
+			ssb_write32(pdev, SSB_IMCFGLO, tmp);
+			ssb_commit_settings(bus);
+		} else if (pdev->id.revision >= 11) {
+			tmp = pcicore_read32(pc, SSB_PCICORE_SBTOPCI2);
+			tmp |= SSB_PCICORE_SBTOPCI_MRM;
+			pcicore_write32(pc, SSB_PCICORE_SBTOPCI2, tmp);
+		}
+	} else {
+		WARN_ON(pdev->id.coreid != SSB_DEV_PCIE);
+		//TODO: Better make defines for all these magic PCIE values.
+		if ((pdev->id.revision == 0) || (pdev->id.revision == 1)) {
+			/* TLP Workaround register. */
+			tmp = ssb_pcie_read(pc, 0x4);
+			tmp |= 0x8;
+			ssb_pcie_write(pc, 0x4, tmp);
+		}
+		if (pdev->id.revision == 0) {
+			const u8 serdes_rx_device = 0x1F;
+
+			ssb_pcie_mdio_write(pc, serdes_rx_device,
+					    2 /* Timer */, 0x8128);
+			ssb_pcie_mdio_write(pc, serdes_rx_device,
+					    6 /* CDR */, 0x0100);
+			ssb_pcie_mdio_write(pc, serdes_rx_device,
+					    7 /* CDR BW */, 0x1466);
+		} else if (pdev->id.revision == 1) {
+			/* DLLP Link Control register. */
+			tmp = ssb_pcie_read(pc, 0x100);
+			tmp |= 0x40;
+			ssb_pcie_write(pc, 0x100, tmp);
+		}
+	}
+	pc->setup_done = 1;
+out:
+	return err;
+}
+EXPORT_SYMBOL(ssb_pcicore_dev_irqvecs_enable);
diff --git a/drivers/ssb/main.c b/drivers/ssb/main.c
new file mode 100644
index 0000000..cfe090f
--- /dev/null
+++ b/drivers/ssb/main.c
@@ -0,0 +1,1112 @@
+/*
+ * Sonics Silicon Backplane
+ * Subsystem core
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include "ssb_private.h"
+
+#include <linux/delay.h>
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+
+#include <linux/pci.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+
+
+MODULE_DESCRIPTION("Sonics Silicon Backplane driver");
+MODULE_LICENSE("GPL");
+
+
+/* Temporary list of yet-to-be-attached buses */
+static LIST_HEAD(attach_queue);
+/* List if running buses */
+static LIST_HEAD(buses);
+/* Software ID counter */
+static unsigned int next_busnumber;
+/* buses_mutes locks the two buslists and the next_busnumber.
+ * Don't lock this directly, but use ssb_buses_[un]lock() below. */
+static DEFINE_MUTEX(buses_mutex);
+
+/* There are differences in the codeflow, if the bus is
+ * initialized from early boot, as various needed services
+ * are not available early. This is a mechanism to delay
+ * these initializations to after early boot has finished.
+ * It's also used to avoid mutex locking, as that's not
+ * available and needed early. */
+static bool ssb_is_early_boot = 1;
+
+static void ssb_buses_lock(void);
+static void ssb_buses_unlock(void);
+
+
+#ifdef CONFIG_SSB_PCIHOST
+struct ssb_bus *ssb_pci_dev_to_bus(struct pci_dev *pdev)
+{
+	struct ssb_bus *bus;
+
+	ssb_buses_lock();
+	list_for_each_entry(bus, &buses, list) {
+		if (bus->bustype == SSB_BUSTYPE_PCI &&
+		    bus->host_pci == pdev)
+			goto found;
+	}
+	bus = NULL;
+found:
+	ssb_buses_unlock();
+
+	return bus;
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+static struct ssb_device *ssb_device_get(struct ssb_device *dev)
+{
+	if (dev)
+		get_device(dev->dev);
+	return dev;
+}
+
+static void ssb_device_put(struct ssb_device *dev)
+{
+	if (dev)
+		put_device(dev->dev);
+}
+
+static int ssb_bus_resume(struct ssb_bus *bus)
+{
+	int err;
+
+	ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 1);
+	err = ssb_pcmcia_init(bus);
+	if (err) {
+		/* No need to disable XTAL, as we don't have one on PCMCIA. */
+		return err;
+	}
+	ssb_chipco_resume(&bus->chipco);
+
+	return 0;
+}
+
+static int ssb_device_resume(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv;
+	struct ssb_bus *bus;
+	int err = 0;
+
+	bus = ssb_dev->bus;
+	if (bus->suspend_cnt == bus->nr_devices) {
+		err = ssb_bus_resume(bus);
+		if (err)
+			return err;
+	}
+	bus->suspend_cnt--;
+	if (dev->driver) {
+		ssb_drv = drv_to_ssb_drv(dev->driver);
+		if (ssb_drv && ssb_drv->resume)
+			err = ssb_drv->resume(ssb_dev);
+		if (err)
+			goto out;
+	}
+out:
+	return err;
+}
+
+static void ssb_bus_suspend(struct ssb_bus *bus, pm_message_t state)
+{
+	ssb_chipco_suspend(&bus->chipco, state);
+	ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);
+
+	/* Reset HW state information in memory, so that HW is
+	 * completely reinitialized on resume. */
+	bus->mapped_device = NULL;
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+	bus->pcicore.setup_done = 0;
+#endif
+}
+
+static int ssb_device_suspend(struct device *dev, pm_message_t state)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv;
+	struct ssb_bus *bus;
+	int err = 0;
+
+	if (dev->driver) {
+		ssb_drv = drv_to_ssb_drv(dev->driver);
+		if (ssb_drv && ssb_drv->suspend)
+			err = ssb_drv->suspend(ssb_dev, state);
+		if (err)
+			goto out;
+	}
+
+	bus = ssb_dev->bus;
+	bus->suspend_cnt++;
+	if (bus->suspend_cnt == bus->nr_devices) {
+		/* All devices suspended. Shutdown the bus. */
+		ssb_bus_suspend(bus, state);
+	}
+
+out:
+	return err;
+}
+
+#ifdef CONFIG_SSB_PCIHOST
+int ssb_devices_freeze(struct ssb_bus *bus)
+{
+	struct ssb_device *dev;
+	struct ssb_driver *drv;
+	int err = 0;
+	int i;
+	pm_message_t state = PMSG_FREEZE;
+
+	/* First check that we are capable to freeze all devices. */
+	for (i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		if (!drv->suspend) {
+			/* Nope, can't suspend this one. */
+			return -EOPNOTSUPP;
+		}
+	}
+	/* Now suspend all devices */
+	for (i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		err = drv->suspend(dev, state);
+		if (err) {
+			ssb_printk(KERN_ERR PFX "Failed to freeze device %s\n",
+				   dev->dev->bus_id);
+			goto err_unwind;
+		}
+	}
+
+	return 0;
+err_unwind:
+	for (i--; i >= 0; i--) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		if (drv->resume)
+			drv->resume(dev);
+	}
+	return err;
+}
+
+int ssb_devices_thaw(struct ssb_bus *bus)
+{
+	struct ssb_device *dev;
+	struct ssb_driver *drv;
+	int err;
+	int i;
+
+	for (i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		if (SSB_WARN_ON(!drv->resume))
+			continue;
+		err = drv->resume(dev);
+		if (err) {
+			ssb_printk(KERN_ERR PFX "Failed to thaw device %s\n",
+				   dev->dev->bus_id);
+		}
+	}
+
+	return 0;
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+static void ssb_device_shutdown(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv;
+
+	if (!dev->driver)
+		return;
+	ssb_drv = drv_to_ssb_drv(dev->driver);
+	if (ssb_drv && ssb_drv->shutdown)
+		ssb_drv->shutdown(ssb_dev);
+}
+
+static int ssb_device_remove(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv = drv_to_ssb_drv(dev->driver);
+
+	if (ssb_drv && ssb_drv->remove)
+		ssb_drv->remove(ssb_dev);
+	ssb_device_put(ssb_dev);
+
+	return 0;
+}
+
+static int ssb_device_probe(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv = drv_to_ssb_drv(dev->driver);
+	int err = 0;
+
+	ssb_device_get(ssb_dev);
+	if (ssb_drv && ssb_drv->probe)
+		err = ssb_drv->probe(ssb_dev, &ssb_dev->id);
+	if (err)
+		ssb_device_put(ssb_dev);
+
+	return err;
+}
+
+static int ssb_match_devid(const struct ssb_device_id *tabid,
+			   const struct ssb_device_id *devid)
+{
+	if ((tabid->vendor != devid->vendor) &&
+	    tabid->vendor != SSB_ANY_VENDOR)
+		return 0;
+	if ((tabid->coreid != devid->coreid) &&
+	    tabid->coreid != SSB_ANY_ID)
+		return 0;
+	if ((tabid->revision != devid->revision) &&
+	    tabid->revision != SSB_ANY_REV)
+		return 0;
+	return 1;
+}
+
+static int ssb_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv = drv_to_ssb_drv(drv);
+	const struct ssb_device_id *id;
+
+	for (id = ssb_drv->id_table;
+	     id->vendor || id->coreid || id->revision;
+	     id++) {
+		if (ssb_match_devid(id, &ssb_dev->id))
+			return 1; /* found */
+	}
+
+	return 0;
+}
+
+static struct bus_type ssb_bustype = {
+	.name		= "ssb",
+	.match		= ssb_bus_match,
+	.probe		= ssb_device_probe,
+	.remove		= ssb_device_remove,
+	.shutdown	= ssb_device_shutdown,
+	.suspend	= ssb_device_suspend,
+	.resume		= ssb_device_resume,
+};
+
+static void ssb_buses_lock(void)
+{
+	/* See the comment at the ssb_is_early_boot definition */
+	if (!ssb_is_early_boot)
+		mutex_lock(&buses_mutex);
+}
+
+static void ssb_buses_unlock(void)
+{
+	/* See the comment at the ssb_is_early_boot definition */
+	if (!ssb_is_early_boot)
+		mutex_unlock(&buses_mutex);
+}
+
+static void ssb_devices_unregister(struct ssb_bus *bus)
+{
+	struct ssb_device *sdev;
+	int i;
+
+	for (i = bus->nr_devices - 1; i >= 0; i--) {
+		sdev = &(bus->devices[i]);
+		if (sdev->dev)
+			device_unregister(sdev->dev);
+	}
+}
+
+void ssb_bus_unregister(struct ssb_bus *bus)
+{
+	ssb_buses_lock();
+	ssb_devices_unregister(bus);
+	list_del(&bus->list);
+	ssb_buses_unlock();
+
+	/* ssb_pcmcia_exit(bus); */
+	ssb_pci_exit(bus);
+	ssb_iounmap(bus);
+}
+EXPORT_SYMBOL(ssb_bus_unregister);
+
+static void ssb_release_dev(struct device *dev)
+{
+	struct __ssb_dev_wrapper *devwrap;
+
+	devwrap = container_of(dev, struct __ssb_dev_wrapper, dev);
+	kfree(devwrap);
+}
+
+static int ssb_devices_register(struct ssb_bus *bus)
+{
+	struct ssb_device *sdev;
+	struct device *dev;
+	struct __ssb_dev_wrapper *devwrap;
+	int i, err = 0;
+	int dev_idx = 0;
+
+	for (i = 0; i < bus->nr_devices; i++) {
+		sdev = &(bus->devices[i]);
+
+		/* We don't register SSB-system devices to the kernel,
+		 * as the drivers for them are built into SSB. */
+		switch (sdev->id.coreid) {
+		case SSB_DEV_CHIPCOMMON:
+		case SSB_DEV_PCI:
+		case SSB_DEV_PCIE:
+		case SSB_DEV_PCMCIA:
+		case SSB_DEV_MIPS:
+		case SSB_DEV_MIPS_3302:
+		case SSB_DEV_EXTIF:
+			continue;
+		}
+
+		devwrap = kzalloc(sizeof(*devwrap), GFP_KERNEL);
+		if (!devwrap) {
+			ssb_printk(KERN_ERR PFX
+				   "Could not allocate device\n");
+			err = -ENOMEM;
+			goto error;
+		}
+		dev = &devwrap->dev;
+		devwrap->sdev = sdev;
+
+		dev->release = ssb_release_dev;
+		dev->bus = &ssb_bustype;
+		snprintf(dev->bus_id, sizeof(dev->bus_id),
+			 "ssb%u:%d", bus->busnumber, dev_idx);
+
+		switch (bus->bustype) {
+		case SSB_BUSTYPE_PCI:
+#ifdef CONFIG_SSB_PCIHOST
+			sdev->irq = bus->host_pci->irq;
+			dev->parent = &bus->host_pci->dev;
+#endif
+			break;
+		case SSB_BUSTYPE_PCMCIA:
+#ifdef CONFIG_SSB_PCMCIAHOST
+			dev->parent = &bus->host_pcmcia->dev;
+#endif
+			break;
+		case SSB_BUSTYPE_SSB:
+			break;
+		}
+
+		sdev->dev = dev;
+		err = device_register(dev);
+		if (err) {
+			ssb_printk(KERN_ERR PFX
+				   "Could not register %s\n",
+				   dev->bus_id);
+			/* Set dev to NULL to not unregister
+			 * dev on error unwinding. */
+			sdev->dev = NULL;
+			kfree(devwrap);
+			goto error;
+		}
+		dev_idx++;
+	}
+
+	return 0;
+error:
+	/* Unwind the already registered devices. */
+	ssb_devices_unregister(bus);
+	return err;
+}
+
+/* Needs ssb_buses_lock() */
+static int ssb_attach_queued_buses(void)
+{
+	struct ssb_bus *bus, *n;
+	int err = 0;
+	int drop_them_all = 0;
+
+	list_for_each_entry_safe(bus, n, &attach_queue, list) {
+		if (drop_them_all) {
+			list_del(&bus->list);
+			continue;
+		}
+		/* Can't init the PCIcore in ssb_bus_register(), as that
+		 * is too early in boot for embedded systems
+		 * (no udelay() available). So do it here in attach stage.
+		 */
+		ssb_pcicore_init(&bus->pcicore);
+
+		err = ssb_devices_register(bus);
+		if (err) {
+			drop_them_all = 1;
+			list_del(&bus->list);
+			continue;
+		}
+		list_move_tail(&bus->list, &buses);
+	}
+
+	return err;
+}
+
+static u16 ssb_ssb_read16(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	return readw(bus->mmio + offset);
+}
+
+static u32 ssb_ssb_read32(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	return readl(bus->mmio + offset);
+}
+
+static void ssb_ssb_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	writew(value, bus->mmio + offset);
+}
+
+static void ssb_ssb_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	writel(value, bus->mmio + offset);
+}
+
+/* Ops for the plain SSB bus without a host-device (no PCI or PCMCIA). */
+static const struct ssb_bus_ops ssb_ssb_ops = {
+	.read16		= ssb_ssb_read16,
+	.read32		= ssb_ssb_read32,
+	.write16	= ssb_ssb_write16,
+	.write32	= ssb_ssb_write32,
+};
+
+static int ssb_fetch_invariants(struct ssb_bus *bus,
+				ssb_invariants_func_t get_invariants)
+{
+	struct ssb_init_invariants iv;
+	int err;
+
+	memset(&iv, 0, sizeof(iv));
+	err = get_invariants(bus, &iv);
+	if (err)
+		goto out;
+	memcpy(&bus->boardinfo, &iv.boardinfo, sizeof(iv.boardinfo));
+	memcpy(&bus->sprom, &iv.sprom, sizeof(iv.sprom));
+out:
+	return err;
+}
+
+static int ssb_bus_register(struct ssb_bus *bus,
+			    ssb_invariants_func_t get_invariants,
+			    unsigned long baseaddr)
+{
+	int err;
+
+	spin_lock_init(&bus->bar_lock);
+	INIT_LIST_HEAD(&bus->list);
+
+	/* Powerup the bus */
+	err = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 1);
+	if (err)
+		goto out;
+	ssb_buses_lock();
+	bus->busnumber = next_busnumber;
+	/* Scan for devices (cores) */
+	err = ssb_bus_scan(bus, baseaddr);
+	if (err)
+		goto err_disable_xtal;
+
+	/* Init PCI-host device (if any) */
+	err = ssb_pci_init(bus);
+	if (err)
+		goto err_unmap;
+	/* Init PCMCIA-host device (if any) */
+	err = ssb_pcmcia_init(bus);
+	if (err)
+		goto err_pci_exit;
+
+	/* Initialize basic system devices (if available) */
+	ssb_chipcommon_init(&bus->chipco);
+	ssb_mipscore_init(&bus->mipscore);
+	err = ssb_fetch_invariants(bus, get_invariants);
+	if (err)
+		goto err_pcmcia_exit;
+
+	/* Queue it for attach.
+	 * See the comment at the ssb_is_early_boot definition. */
+	list_add_tail(&bus->list, &attach_queue);
+	if (!ssb_is_early_boot) {
+		/* This is not early boot, so we must attach the bus now */
+		err = ssb_attach_queued_buses();
+		if (err)
+			goto err_dequeue;
+	}
+	next_busnumber++;
+	ssb_buses_unlock();
+
+out:
+	return err;
+
+err_dequeue:
+	list_del(&bus->list);
+err_pcmcia_exit:
+/*	ssb_pcmcia_exit(bus); */
+err_pci_exit:
+	ssb_pci_exit(bus);
+err_unmap:
+	ssb_iounmap(bus);
+err_disable_xtal:
+	ssb_buses_unlock();
+	ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);
+	return err;
+}
+
+#ifdef CONFIG_SSB_PCIHOST
+int ssb_bus_pcibus_register(struct ssb_bus *bus,
+			    struct pci_dev *host_pci)
+{
+	int err;
+
+	bus->bustype = SSB_BUSTYPE_PCI;
+	bus->host_pci = host_pci;
+	bus->ops = &ssb_pci_ops;
+
+	err = ssb_bus_register(bus, ssb_pci_get_invariants, 0);
+	if (!err) {
+		ssb_printk(KERN_INFO PFX "Sonics Silicon Backplane found on "
+			   "PCI device %s\n", host_pci->dev.bus_id);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_pcibus_register);
+#endif /* CONFIG_SSB_PCIHOST */
+
+#ifdef CONFIG_SSB_PCMCIAHOST
+int ssb_bus_pcmciabus_register(struct ssb_bus *bus,
+			       struct pcmcia_device *pcmcia_dev,
+			       unsigned long baseaddr)
+{
+	int err;
+
+	bus->bustype = SSB_BUSTYPE_PCMCIA;
+	bus->host_pcmcia = pcmcia_dev;
+	bus->ops = &ssb_pcmcia_ops;
+
+	err = ssb_bus_register(bus, ssb_pcmcia_get_invariants, baseaddr);
+	if (!err) {
+		ssb_printk(KERN_INFO PFX "Sonics Silicon Backplane found on "
+			   "PCMCIA device %s\n", pcmcia_dev->devname);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_pcmciabus_register);
+#endif /* CONFIG_SSB_PCMCIAHOST */
+
+int ssb_bus_ssbbus_register(struct ssb_bus *bus,
+			    unsigned long baseaddr,
+			    ssb_invariants_func_t get_invariants)
+{
+	int err;
+
+	bus->bustype = SSB_BUSTYPE_SSB;
+	bus->ops = &ssb_ssb_ops;
+
+	err = ssb_bus_register(bus, get_invariants, baseaddr);
+	if (!err) {
+		ssb_printk(KERN_INFO PFX "Sonics Silicon Backplane found at "
+			   "address 0x%08lX\n", baseaddr);
+	}
+
+	return err;
+}
+
+int __ssb_driver_register(struct ssb_driver *drv, struct module *owner)
+{
+	drv->drv.name = drv->name;
+	drv->drv.bus = &ssb_bustype;
+	drv->drv.owner = owner;
+
+	return driver_register(&drv->drv);
+}
+EXPORT_SYMBOL(__ssb_driver_register);
+
+void ssb_driver_unregister(struct ssb_driver *drv)
+{
+	driver_unregister(&drv->drv);
+}
+EXPORT_SYMBOL(ssb_driver_unregister);
+
+void ssb_set_devtypedata(struct ssb_device *dev, void *data)
+{
+	struct ssb_bus *bus = dev->bus;
+	struct ssb_device *ent;
+	int i;
+
+	for (i = 0; i < bus->nr_devices; i++) {
+		ent = &(bus->devices[i]);
+		if (ent->id.vendor != dev->id.vendor)
+			continue;
+		if (ent->id.coreid != dev->id.coreid)
+			continue;
+
+		ent->devtypedata = data;
+	}
+}
+EXPORT_SYMBOL(ssb_set_devtypedata);
+
+static u32 clkfactor_f6_resolve(u32 v)
+{
+	/* map the magic values */
+	switch (v) {
+	case SSB_CHIPCO_CLK_F6_2:
+		return 2;
+	case SSB_CHIPCO_CLK_F6_3:
+		return 3;
+	case SSB_CHIPCO_CLK_F6_4:
+		return 4;
+	case SSB_CHIPCO_CLK_F6_5:
+		return 5;
+	case SSB_CHIPCO_CLK_F6_6:
+		return 6;
+	case SSB_CHIPCO_CLK_F6_7:
+		return 7;
+	}
+	return 0;
+}
+
+/* Calculate the speed the backplane would run at a given set of clockcontrol values */
+u32 ssb_calc_clock_rate(u32 plltype, u32 n, u32 m)
+{
+	u32 n1, n2, clock, m1, m2, m3, mc;
+
+	n1 = (n & SSB_CHIPCO_CLK_N1);
+	n2 = ((n & SSB_CHIPCO_CLK_N2) >> SSB_CHIPCO_CLK_N2_SHIFT);
+
+	switch (plltype) {
+	case SSB_PLLTYPE_6: /* 100/200 or 120/240 only */
+		if (m & SSB_CHIPCO_CLK_T6_MMASK)
+			return SSB_CHIPCO_CLK_T6_M0;
+		return SSB_CHIPCO_CLK_T6_M1;
+	case SSB_PLLTYPE_1: /* 48Mhz base, 3 dividers */
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+	case SSB_PLLTYPE_4: /* 48Mhz, 4 dividers */
+	case SSB_PLLTYPE_7: /* 25Mhz, 4 dividers */
+		n1 = clkfactor_f6_resolve(n1);
+		n2 += SSB_CHIPCO_CLK_F5_BIAS;
+		break;
+	case SSB_PLLTYPE_2: /* 48Mhz, 4 dividers */
+		n1 += SSB_CHIPCO_CLK_T2_BIAS;
+		n2 += SSB_CHIPCO_CLK_T2_BIAS;
+		SSB_WARN_ON(!((n1 >= 2) && (n1 <= 7)));
+		SSB_WARN_ON(!((n2 >= 5) && (n2 <= 23)));
+		break;
+	case SSB_PLLTYPE_5: /* 25Mhz, 4 dividers */
+		return 100000000;
+	default:
+		SSB_WARN_ON(1);
+	}
+
+	switch (plltype) {
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+	case SSB_PLLTYPE_7: /* 25Mhz, 4 dividers */
+		clock = SSB_CHIPCO_CLK_BASE2 * n1 * n2;
+		break;
+	default:
+		clock = SSB_CHIPCO_CLK_BASE1 * n1 * n2;
+	}
+	if (!clock)
+		return 0;
+
+	m1 = (m & SSB_CHIPCO_CLK_M1);
+	m2 = ((m & SSB_CHIPCO_CLK_M2) >> SSB_CHIPCO_CLK_M2_SHIFT);
+	m3 = ((m & SSB_CHIPCO_CLK_M3) >> SSB_CHIPCO_CLK_M3_SHIFT);
+	mc = ((m & SSB_CHIPCO_CLK_MC) >> SSB_CHIPCO_CLK_MC_SHIFT);
+
+	switch (plltype) {
+	case SSB_PLLTYPE_1: /* 48Mhz base, 3 dividers */
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+	case SSB_PLLTYPE_4: /* 48Mhz, 4 dividers */
+	case SSB_PLLTYPE_7: /* 25Mhz, 4 dividers */
+		m1 = clkfactor_f6_resolve(m1);
+		if ((plltype == SSB_PLLTYPE_1) ||
+		    (plltype == SSB_PLLTYPE_3))
+			m2 += SSB_CHIPCO_CLK_F5_BIAS;
+		else
+			m2 = clkfactor_f6_resolve(m2);
+		m3 = clkfactor_f6_resolve(m3);
+
+		switch (mc) {
+		case SSB_CHIPCO_CLK_MC_BYPASS:
+			return clock;
+		case SSB_CHIPCO_CLK_MC_M1:
+			return (clock / m1);
+		case SSB_CHIPCO_CLK_MC_M1M2:
+			return (clock / (m1 * m2));
+		case SSB_CHIPCO_CLK_MC_M1M2M3:
+			return (clock / (m1 * m2 * m3));
+		case SSB_CHIPCO_CLK_MC_M1M3:
+			return (clock / (m1 * m3));
+		}
+		return 0;
+	case SSB_PLLTYPE_2:
+		m1 += SSB_CHIPCO_CLK_T2_BIAS;
+		m2 += SSB_CHIPCO_CLK_T2M2_BIAS;
+		m3 += SSB_CHIPCO_CLK_T2_BIAS;
+		SSB_WARN_ON(!((m1 >= 2) && (m1 <= 7)));
+		SSB_WARN_ON(!((m2 >= 3) && (m2 <= 10)));
+		SSB_WARN_ON(!((m3 >= 2) && (m3 <= 7)));
+
+		if (!(mc & SSB_CHIPCO_CLK_T2MC_M1BYP))
+			clock /= m1;
+		if (!(mc & SSB_CHIPCO_CLK_T2MC_M2BYP))
+			clock /= m2;
+		if (!(mc & SSB_CHIPCO_CLK_T2MC_M3BYP))
+			clock /= m3;
+		return clock;
+	default:
+		SSB_WARN_ON(1);
+	}
+	return 0;
+}
+
+/* Get the current speed the backplane is running at */
+u32 ssb_clockspeed(struct ssb_bus *bus)
+{
+	u32 rate;
+	u32 plltype;
+	u32 clkctl_n, clkctl_m;
+
+	//TODO if EXTIF: PLLTYPE == 1, read n from clockcontrol_n, m from clockcontrol_sb
+
+	if (bus->chipco.dev) {
+		ssb_chipco_get_clockcontrol(&bus->chipco, &plltype,
+					    &clkctl_n, &clkctl_m);
+	} else
+		return 0;
+
+	if (bus->chip_id == 0x5365) {
+		rate = 100000000;
+	} else {
+		rate = ssb_calc_clock_rate(plltype, clkctl_n, clkctl_m);
+		if (plltype == SSB_PLLTYPE_3) /* 25Mhz, 2 dividers */
+			rate /= 2;
+	}
+
+	return rate;
+}
+EXPORT_SYMBOL(ssb_clockspeed);
+
+static u32 ssb_tmslow_reject_bitmask(struct ssb_device *dev)
+{
+	/* The REJECT bit changed position in TMSLOW between
+	 * Backplane revisions. */
+	switch (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV) {
+	case SSB_IDLOW_SSBREV_22:
+		return SSB_TMSLOW_REJECT_22;
+	case SSB_IDLOW_SSBREV_23:
+		return SSB_TMSLOW_REJECT_23;
+	default:
+		WARN_ON(1);
+	}
+	return (SSB_TMSLOW_REJECT_22 | SSB_TMSLOW_REJECT_23);
+}
+
+int ssb_device_is_enabled(struct ssb_device *dev)
+{
+	u32 val;
+	u32 reject;
+
+	reject = ssb_tmslow_reject_bitmask(dev);
+	val = ssb_read32(dev, SSB_TMSLOW);
+	val &= SSB_TMSLOW_CLOCK | SSB_TMSLOW_RESET | reject;
+
+	return (val == SSB_TMSLOW_CLOCK);
+}
+EXPORT_SYMBOL(ssb_device_is_enabled);
+
+static void ssb_flush_tmslow(struct ssb_device *dev)
+{
+	/* Make _really_ sure the device has finished the TMSLOW
+	 * register write transaction, as we risk running into
+	 * a machine check exception otherwise.
+	 * Do this by reading the register back to commit the
+	 * PCI write and delay an additional usec for the device
+	 * to react to the change. */
+	ssb_read32(dev, SSB_TMSLOW);
+	udelay(1);
+}
+
+void ssb_device_enable(struct ssb_device *dev, u32 core_specific_flags)
+{
+	u32 val;
+
+	ssb_device_disable(dev, core_specific_flags);
+	ssb_write32(dev, SSB_TMSLOW,
+		    SSB_TMSLOW_RESET | SSB_TMSLOW_CLOCK |
+		    SSB_TMSLOW_FGC | core_specific_flags);
+	ssb_flush_tmslow(dev);
+
+	/* Clear SERR if set. This is a hw bug workaround. */
+	if (ssb_read32(dev, SSB_TMSHIGH) & SSB_TMSHIGH_SERR)
+		ssb_write32(dev, SSB_TMSHIGH, 0);
+
+	val = ssb_read32(dev, SSB_IMSTATE);
+	if (val & (SSB_IMSTATE_IBE | SSB_IMSTATE_TO)) {
+		val &= ~(SSB_IMSTATE_IBE | SSB_IMSTATE_TO);
+		ssb_write32(dev, SSB_IMSTATE, val);
+	}
+
+	ssb_write32(dev, SSB_TMSLOW,
+		    SSB_TMSLOW_CLOCK | SSB_TMSLOW_FGC |
+		    core_specific_flags);
+	ssb_flush_tmslow(dev);
+
+	ssb_write32(dev, SSB_TMSLOW, SSB_TMSLOW_CLOCK |
+		    core_specific_flags);
+	ssb_flush_tmslow(dev);
+}
+EXPORT_SYMBOL(ssb_device_enable);
+
+/* Wait for a bit in a register to get set or unset.
+ * timeout is in units of ten-microseconds */
+static int ssb_wait_bit(struct ssb_device *dev, u16 reg, u32 bitmask,
+			int timeout, int set)
+{
+	int i;
+	u32 val;
+
+	for (i = 0; i < timeout; i++) {
+		val = ssb_read32(dev, reg);
+		if (set) {
+			if (val & bitmask)
+				return 0;
+		} else {
+			if (!(val & bitmask))
+				return 0;
+		}
+		udelay(10);
+	}
+	printk(KERN_ERR PFX "Timeout waiting for bitmask %08X on "
+			    "register %04X to %s.\n",
+	       bitmask, reg, (set ? "set" : "clear"));
+
+	return -ETIMEDOUT;
+}
+
+void ssb_device_disable(struct ssb_device *dev, u32 core_specific_flags)
+{
+	u32 reject;
+
+	if (ssb_read32(dev, SSB_TMSLOW) & SSB_TMSLOW_RESET)
+		return;
+
+	reject = ssb_tmslow_reject_bitmask(dev);
+	ssb_write32(dev, SSB_TMSLOW, reject | SSB_TMSLOW_CLOCK);
+	ssb_wait_bit(dev, SSB_TMSLOW, reject, 1000, 1);
+	ssb_wait_bit(dev, SSB_TMSHIGH, SSB_TMSHIGH_BUSY, 1000, 0);
+	ssb_write32(dev, SSB_TMSLOW,
+		    SSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK |
+		    reject | SSB_TMSLOW_RESET |
+		    core_specific_flags);
+	ssb_flush_tmslow(dev);
+
+	ssb_write32(dev, SSB_TMSLOW,
+		    reject | SSB_TMSLOW_RESET |
+		    core_specific_flags);
+	ssb_flush_tmslow(dev);
+}
+EXPORT_SYMBOL(ssb_device_disable);
+
+u32 ssb_dma_translation(struct ssb_device *dev)
+{
+	switch (dev->bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		return 0;
+	case SSB_BUSTYPE_PCI:
+	case SSB_BUSTYPE_PCMCIA:
+		return SSB_PCI_DMA;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ssb_dma_translation);
+
+int ssb_dma_set_mask(struct ssb_device *ssb_dev, u64 mask)
+{
+	struct device *dev = ssb_dev->dev;
+
+#ifdef CONFIG_SSB_PCIHOST
+	if (ssb_dev->bus->bustype == SSB_BUSTYPE_PCI &&
+	    !dma_supported(dev, mask))
+		return -EIO;
+#endif
+	dev->coherent_dma_mask = mask;
+	dev->dma_mask = &dev->coherent_dma_mask;
+
+	return 0;
+}
+EXPORT_SYMBOL(ssb_dma_set_mask);
+
+int ssb_bus_may_powerdown(struct ssb_bus *bus)
+{
+	struct ssb_chipcommon *cc;
+	int err;
+
+	/* On buses where more than one core may be working
+	 * at a time, we must not powerdown stuff if there are
+	 * still cores that may want to run. */
+	if (bus->bustype == SSB_BUSTYPE_SSB)
+		return 0;
+
+	cc = &bus->chipco;
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_SLOW);
+	err = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);
+	if (err)
+		goto error;
+
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Bus powerdown failed\n");
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_may_powerdown);
+
+int ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl)
+{
+	struct ssb_chipcommon *cc;
+	int err;
+	enum ssb_clkmode mode;
+
+	err = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 1);
+	if (err)
+		goto error;
+	cc = &bus->chipco;
+	mode = dynamic_pctl ? SSB_CLKMODE_DYNAMIC : SSB_CLKMODE_FAST;
+	ssb_chipco_set_clockmode(cc, mode);
+
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Bus powerup failed\n");
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_powerup);
+
+u32 ssb_admatch_base(u32 adm)
+{
+	u32 base = 0;
+
+	switch (adm & SSB_ADM_TYPE) {
+	case SSB_ADM_TYPE0:
+		base = (adm & SSB_ADM_BASE0);
+		break;
+	case SSB_ADM_TYPE1:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		base = (adm & SSB_ADM_BASE1);
+		break;
+	case SSB_ADM_TYPE2:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		base = (adm & SSB_ADM_BASE2);
+		break;
+	default:
+		SSB_WARN_ON(1);
+	}
+
+	return base;
+}
+EXPORT_SYMBOL(ssb_admatch_base);
+
+u32 ssb_admatch_size(u32 adm)
+{
+	u32 size = 0;
+
+	switch (adm & SSB_ADM_TYPE) {
+	case SSB_ADM_TYPE0:
+		size = ((adm & SSB_ADM_SZ0) >> SSB_ADM_SZ0_SHIFT);
+		break;
+	case SSB_ADM_TYPE1:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		size = ((adm & SSB_ADM_SZ1) >> SSB_ADM_SZ1_SHIFT);
+		break;
+	case SSB_ADM_TYPE2:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		size = ((adm & SSB_ADM_SZ2) >> SSB_ADM_SZ2_SHIFT);
+		break;
+	default:
+		SSB_WARN_ON(1);
+	}
+	size = (1 << (size + 1));
+
+	return size;
+}
+EXPORT_SYMBOL(ssb_admatch_size);
+
+static int __init ssb_modinit(void)
+{
+	int err;
+
+	/* See the comment at the ssb_is_early_boot definition */
+	ssb_is_early_boot = 0;
+	err = bus_register(&ssb_bustype);
+	if (err)
+		return err;
+
+	/* Maybe we already registered some buses at early boot.
+	 * Check for this and attach them
+	 */
+	ssb_buses_lock();
+	err = ssb_attach_queued_buses();
+	ssb_buses_unlock();
+	if (err)
+		bus_unregister(&ssb_bustype);
+
+	return err;
+}
+subsys_initcall(ssb_modinit);
+
+static void __exit ssb_modexit(void)
+{
+	bus_unregister(&ssb_bustype);
+}
+module_exit(ssb_modexit)
diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
new file mode 100644
index 0000000..b3ec4c8
--- /dev/null
+++ b/drivers/ssb/pci.c
@@ -0,0 +1,704 @@
+/*
+ * Sonics Silicon Backplane PCI-Hostbus related functions.
+ *
+ * Copyright (C) 2005-2006 Michael Buesch <mb at bu3sch.de>
+ * Copyright (C) 2005 Martin Langer <martin-langer at gmx.de>
+ * Copyright (C) 2005 Stefano Brivio <st3 at riseup.net>
+ * Copyright (C) 2005 Danny van Dyk <kugelfang at gentoo.org>
+ * Copyright (C) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+ *
+ * Derived from the Broadcom 4400 device driver.
+ * Copyright (C) 2002 David S. Miller (davem at redhat.com)
+ * Fixed by Pekka Pietikainen (pp at ee.oulu.fi)
+ * Copyright (C) 2006 Broadcom Corporation.
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include "ssb_private.h"
+
+
+/* Lowlevel coreswitching */
+int ssb_pci_switch_coreidx(struct ssb_bus *bus, u8 coreidx)
+{
+	int err;
+	int attempts = 0;
+	u32 cur_core;
+
+	while (1) {
+		err = pci_write_config_dword(bus->host_pci, SSB_BAR0_WIN,
+					     (coreidx * SSB_CORE_SIZE)
+					     + SSB_ENUM_BASE);
+		if (err)
+			goto error;
+		err = pci_read_config_dword(bus->host_pci, SSB_BAR0_WIN,
+					    &cur_core);
+		if (err)
+			goto error;
+		cur_core = (cur_core - SSB_ENUM_BASE)
+			   / SSB_CORE_SIZE;
+		if (cur_core == coreidx)
+			break;
+
+		if (attempts++ > SSB_BAR0_MAX_RETRIES)
+			goto error;
+		udelay(10);
+	}
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Failed to switch to core %u\n", coreidx);
+	return -ENODEV;
+}
+
+int ssb_pci_switch_core(struct ssb_bus *bus,
+			struct ssb_device *dev)
+{
+	int err;
+	unsigned long flags;
+
+	ssb_dprintk(KERN_INFO PFX
+		    "Switching to %s core, index %d\n",
+		    ssb_core_name(dev->id.coreid),
+		    dev->core_index);
+
+	spin_lock_irqsave(&bus->bar_lock, flags);
+	err = ssb_pci_switch_coreidx(bus, dev->core_index);
+	if (!err)
+		bus->mapped_device = dev;
+	spin_unlock_irqrestore(&bus->bar_lock, flags);
+
+	return err;
+}
+
+/* Enable/disable the on board crystal oscillator and/or PLL. */
+int ssb_pci_xtal(struct ssb_bus *bus, u32 what, int turn_on)
+{
+	int err;
+	u32 in, out, outenable;
+	u16 pci_status;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return 0;
+
+	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_IN, &in);
+	if (err)
+		goto err_pci;
+	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT, &out);
+	if (err)
+		goto err_pci;
+	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE, &outenable);
+	if (err)
+		goto err_pci;
+
+	outenable |= what;
+
+	if (turn_on) {
+		/* Avoid glitching the clock if GPRS is already using it.
+		 * We can't actually read the state of the PLLPD so we infer it
+		 * by the value of XTAL_PU which *is* readable via gpioin.
+		 */
+		if (!(in & SSB_GPIO_XTAL)) {
+			if (what & SSB_GPIO_XTAL) {
+				/* Turn the crystal on */
+				out |= SSB_GPIO_XTAL;
+				if (what & SSB_GPIO_PLL)
+					out |= SSB_GPIO_PLL;
+				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
+				if (err)
+					goto err_pci;
+				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE,
+							     outenable);
+				if (err)
+					goto err_pci;
+				msleep(1);
+			}
+			if (what & SSB_GPIO_PLL) {
+				/* Turn the PLL on */
+				out &= ~SSB_GPIO_PLL;
+				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
+				if (err)
+					goto err_pci;
+				msleep(5);
+			}
+		}
+
+		err = pci_read_config_word(bus->host_pci, PCI_STATUS, &pci_status);
+		if (err)
+			goto err_pci;
+		pci_status &= ~PCI_STATUS_SIG_TARGET_ABORT;
+		err = pci_write_config_word(bus->host_pci, PCI_STATUS, pci_status);
+		if (err)
+			goto err_pci;
+	} else {
+		if (what & SSB_GPIO_XTAL) {
+			/* Turn the crystal off */
+			out &= ~SSB_GPIO_XTAL;
+		}
+		if (what & SSB_GPIO_PLL) {
+			/* Turn the PLL off */
+			out |= SSB_GPIO_PLL;
+		}
+		err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
+		if (err)
+			goto err_pci;
+		err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE, outenable);
+		if (err)
+			goto err_pci;
+	}
+
+out:
+	return err;
+
+err_pci:
+	printk(KERN_ERR PFX "Error: ssb_pci_xtal() could not access PCI config space!\n");
+	err = -EBUSY;
+	goto out;
+}
+
+/* Get the word-offset for a SSB_SPROM_XXX define. */
+#define SPOFF(offset)	(((offset) - SSB_SPROM_BASE) / sizeof(u16))
+/* Helper to extract some _offset, which is one of the SSB_SPROM_XXX defines. */
+#define SPEX(_outvar, _offset, _mask, _shift)	\
+	out->_outvar = ((in[SPOFF(_offset)] & (_mask)) >> (_shift))
+
+static inline u8 ssb_crc8(u8 crc, u8 data)
+{
+	/* Polynomial:   x^8 + x^7 + x^6 + x^4 + x^2 + 1   */
+	static const u8 t[] = {
+		0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
+		0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
+		0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
+		0xDE, 0x29, 0x67, 0x90, 0xFB, 0x0C, 0x42, 0xB5,
+		0x7F, 0x88, 0xC6, 0x31, 0x5A, 0xAD, 0xE3, 0x14,
+		0x35, 0xC2, 0x8C, 0x7B, 0x10, 0xE7, 0xA9, 0x5E,
+		0xEB, 0x1C, 0x52, 0xA5, 0xCE, 0x39, 0x77, 0x80,
+		0xA1, 0x56, 0x18, 0xEF, 0x84, 0x73, 0x3D, 0xCA,
+		0xFE, 0x09, 0x47, 0xB0, 0xDB, 0x2C, 0x62, 0x95,
+		0xB4, 0x43, 0x0D, 0xFA, 0x91, 0x66, 0x28, 0xDF,
+		0x6A, 0x9D, 0xD3, 0x24, 0x4F, 0xB8, 0xF6, 0x01,
+		0x20, 0xD7, 0x99, 0x6E, 0x05, 0xF2, 0xBC, 0x4B,
+		0x81, 0x76, 0x38, 0xCF, 0xA4, 0x53, 0x1D, 0xEA,
+		0xCB, 0x3C, 0x72, 0x85, 0xEE, 0x19, 0x57, 0xA0,
+		0x15, 0xE2, 0xAC, 0x5B, 0x30, 0xC7, 0x89, 0x7E,
+		0x5F, 0xA8, 0xE6, 0x11, 0x7A, 0x8D, 0xC3, 0x34,
+		0xAB, 0x5C, 0x12, 0xE5, 0x8E, 0x79, 0x37, 0xC0,
+		0xE1, 0x16, 0x58, 0xAF, 0xC4, 0x33, 0x7D, 0x8A,
+		0x3F, 0xC8, 0x86, 0x71, 0x1A, 0xED, 0xA3, 0x54,
+		0x75, 0x82, 0xCC, 0x3B, 0x50, 0xA7, 0xE9, 0x1E,
+		0xD4, 0x23, 0x6D, 0x9A, 0xF1, 0x06, 0x48, 0xBF,
+		0x9E, 0x69, 0x27, 0xD0, 0xBB, 0x4C, 0x02, 0xF5,
+		0x40, 0xB7, 0xF9, 0x0E, 0x65, 0x92, 0xDC, 0x2B,
+		0x0A, 0xFD, 0xB3, 0x44, 0x2F, 0xD8, 0x96, 0x61,
+		0x55, 0xA2, 0xEC, 0x1B, 0x70, 0x87, 0xC9, 0x3E,
+		0x1F, 0xE8, 0xA6, 0x51, 0x3A, 0xCD, 0x83, 0x74,
+		0xC1, 0x36, 0x78, 0x8F, 0xE4, 0x13, 0x5D, 0xAA,
+		0x8B, 0x7C, 0x32, 0xC5, 0xAE, 0x59, 0x17, 0xE0,
+		0x2A, 0xDD, 0x93, 0x64, 0x0F, 0xF8, 0xB6, 0x41,
+		0x60, 0x97, 0xD9, 0x2E, 0x45, 0xB2, 0xFC, 0x0B,
+		0xBE, 0x49, 0x07, 0xF0, 0x9B, 0x6C, 0x22, 0xD5,
+		0xF4, 0x03, 0x4D, 0xBA, 0xD1, 0x26, 0x68, 0x9F,
+	};
+	return t[crc ^ data];
+}
+
+static u8 ssb_sprom_crc(const u16 *sprom)
+{
+	int word;
+	u8 crc = 0xFF;
+
+	for (word = 0; word < SSB_SPROMSIZE_WORDS - 1; word++) {
+		crc = ssb_crc8(crc, sprom[word] & 0x00FF);
+		crc = ssb_crc8(crc, (sprom[word] & 0xFF00) >> 8);
+	}
+	crc = ssb_crc8(crc, sprom[SPOFF(SSB_SPROM_REVISION)] & 0x00FF);
+	crc ^= 0xFF;
+
+	return crc;
+}
+
+static int sprom_check_crc(const u16 *sprom)
+{
+	u8 crc;
+	u8 expected_crc;
+	u16 tmp;
+
+	crc = ssb_sprom_crc(sprom);
+	tmp = sprom[SPOFF(SSB_SPROM_REVISION)] & SSB_SPROM_REVISION_CRC;
+	expected_crc = tmp >> SSB_SPROM_REVISION_CRC_SHIFT;
+	if (crc != expected_crc)
+		return -EPROTO;
+
+	return 0;
+}
+
+static void sprom_do_read(struct ssb_bus *bus, u16 *sprom)
+{
+	int i;
+
+	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++)
+		sprom[i] = readw(bus->mmio + SSB_SPROM_BASE + (i * 2));
+}
+
+static int sprom_do_write(struct ssb_bus *bus, const u16 *sprom)
+{
+	struct pci_dev *pdev = bus->host_pci;
+	int i, err;
+	u32 spromctl;
+
+	ssb_printk(KERN_NOTICE PFX "Writing SPROM. Do NOT turn off the power! Please stand by...\n");
+	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
+	if (err)
+		goto err_ctlreg;
+	spromctl |= SSB_SPROMCTL_WE;
+	err = pci_write_config_dword(pdev, SSB_SPROMCTL, spromctl);
+	if (err)
+		goto err_ctlreg;
+	ssb_printk(KERN_NOTICE PFX "[ 0%%");
+	msleep(500);
+	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
+		if (i == SSB_SPROMSIZE_WORDS / 4)
+			ssb_printk("25%%");
+		else if (i == SSB_SPROMSIZE_WORDS / 2)
+			ssb_printk("50%%");
+		else if (i == (SSB_SPROMSIZE_WORDS / 4) * 3)
+			ssb_printk("75%%");
+		else if (i % 2)
+			ssb_printk(".");
+		writew(sprom[i], bus->mmio + SSB_SPROM_BASE + (i * 2));
+		mmiowb();
+		msleep(20);
+	}
+	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
+	if (err)
+		goto err_ctlreg;
+	spromctl &= ~SSB_SPROMCTL_WE;
+	err = pci_write_config_dword(pdev, SSB_SPROMCTL, spromctl);
+	if (err)
+		goto err_ctlreg;
+	msleep(500);
+	ssb_printk("100%% ]\n");
+	ssb_printk(KERN_NOTICE PFX "SPROM written.\n");
+
+	return 0;
+err_ctlreg:
+	ssb_printk(KERN_ERR PFX "Could not access SPROM control register.\n");
+	return err;
+}
+
+static void sprom_extract_r1(struct ssb_sprom_r1 *out, const u16 *in)
+{
+	int i;
+	u16 v;
+
+	SPEX(pci_spid, SSB_SPROM1_SPID, 0xFFFF, 0);
+	SPEX(pci_svid, SSB_SPROM1_SVID, 0xFFFF, 0);
+	SPEX(pci_pid, SSB_SPROM1_PID, 0xFFFF, 0);
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
+		*(((u16 *)out->il0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_ET0MAC) + i];
+		*(((u16 *)out->et0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_ET1MAC) + i];
+		*(((u16 *)out->et1mac) + i) = cpu_to_be16(v);
+	}
+	SPEX(et0phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0A, 0);
+	SPEX(et1phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1A,
+	     SSB_SPROM1_ETHPHY_ET1A_SHIFT);
+	SPEX(et0mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0M, 14);
+	SPEX(et1mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1M, 15);
+	SPEX(board_rev, SSB_SPROM1_BINF, SSB_SPROM1_BINF_BREV, 0);
+	SPEX(country_code, SSB_SPROM1_BINF, SSB_SPROM1_BINF_CCODE,
+	     SSB_SPROM1_BINF_CCODE_SHIFT);
+	SPEX(antenna_a, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTA,
+	     SSB_SPROM1_BINF_ANTA_SHIFT);
+	SPEX(antenna_bg, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTBG,
+	     SSB_SPROM1_BINF_ANTBG_SHIFT);
+	SPEX(pa0b0, SSB_SPROM1_PA0B0, 0xFFFF, 0);
+	SPEX(pa0b1, SSB_SPROM1_PA0B1, 0xFFFF, 0);
+	SPEX(pa0b2, SSB_SPROM1_PA0B2, 0xFFFF, 0);
+	SPEX(pa1b0, SSB_SPROM1_PA1B0, 0xFFFF, 0);
+	SPEX(pa1b1, SSB_SPROM1_PA1B1, 0xFFFF, 0);
+	SPEX(pa1b2, SSB_SPROM1_PA1B2, 0xFFFF, 0);
+	SPEX(gpio0, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P0, 0);
+	SPEX(gpio1, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P1,
+	     SSB_SPROM1_GPIOA_P1_SHIFT);
+	SPEX(gpio2, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P2, 0);
+	SPEX(gpio3, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P3,
+	     SSB_SPROM1_GPIOB_P3_SHIFT);
+	SPEX(maxpwr_a, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_A,
+	     SSB_SPROM1_MAXPWR_A_SHIFT);
+	SPEX(maxpwr_bg, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_BG, 0);
+	SPEX(itssi_a, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_A,
+	     SSB_SPROM1_ITSSI_A_SHIFT);
+	SPEX(itssi_bg, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_BG, 0);
+	SPEX(boardflags_lo, SSB_SPROM1_BFLLO, 0xFFFF, 0);
+	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
+	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
+	     SSB_SPROM1_AGAIN_BG_SHIFT);
+	for (i = 0; i < 4; i++) {
+		v = in[SPOFF(SSB_SPROM1_OEM) + i];
+		*(((u16 *)out->oem) + i) = cpu_to_le16(v);
+	}
+}
+
+static void sprom_extract_r2(struct ssb_sprom_r2 *out, const u16 *in)
+{
+	int i;
+	u16 v;
+
+	SPEX(boardflags_hi, SSB_SPROM2_BFLHI,  0xFFFF, 0);
+	SPEX(maxpwr_a_hi, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_HI, 0);
+	SPEX(maxpwr_a_lo, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_LO,
+	     SSB_SPROM2_MAXP_A_LO_SHIFT);
+	SPEX(pa1lob0, SSB_SPROM2_PA1LOB0, 0xFFFF, 0);
+	SPEX(pa1lob1, SSB_SPROM2_PA1LOB1, 0xFFFF, 0);
+	SPEX(pa1lob2, SSB_SPROM2_PA1LOB2, 0xFFFF, 0);
+	SPEX(pa1hib0, SSB_SPROM2_PA1HIB0, 0xFFFF, 0);
+	SPEX(pa1hib1, SSB_SPROM2_PA1HIB1, 0xFFFF, 0);
+	SPEX(pa1hib2, SSB_SPROM2_PA1HIB2, 0xFFFF, 0);
+	SPEX(ofdm_pwr_off, SSB_SPROM2_OPO, SSB_SPROM2_OPO_VALUE, 0);
+	for (i = 0; i < 4; i++) {
+		v = in[SPOFF(SSB_SPROM2_CCODE) + i];
+		*(((u16 *)out->country_str) + i) = cpu_to_le16(v);
+	}
+}
+
+static void sprom_extract_r3(struct ssb_sprom_r3 *out, const u16 *in)
+{
+	out->ofdmapo  = (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0xFF00) >> 8;
+	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0x00FF) << 8;
+	out->ofdmapo <<= 16;
+	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0xFF00) >> 8;
+	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0x00FF) << 8;
+
+	out->ofdmalpo  = (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0xFF00) >> 8;
+	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0x00FF) << 8;
+	out->ofdmalpo <<= 16;
+	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0xFF00) >> 8;
+	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0x00FF) << 8;
+
+	out->ofdmahpo  = (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0xFF00) >> 8;
+	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0x00FF) << 8;
+	out->ofdmahpo <<= 16;
+	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0xFF00) >> 8;
+	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0x00FF) << 8;
+
+	SPEX(gpioldc_on_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_ON,
+	     SSB_SPROM3_GPIOLDC_ON_SHIFT);
+	SPEX(gpioldc_off_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_OFF,
+	     SSB_SPROM3_GPIOLDC_OFF_SHIFT);
+	SPEX(cckpo_1M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_1M, 0);
+	SPEX(cckpo_2M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_2M,
+	     SSB_SPROM3_CCKPO_2M_SHIFT);
+	SPEX(cckpo_55M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_55M,
+	     SSB_SPROM3_CCKPO_55M_SHIFT);
+	SPEX(cckpo_11M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_11M,
+	     SSB_SPROM3_CCKPO_11M_SHIFT);
+
+	out->ofdmgpo  = (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0xFF00) >> 8;
+	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0x00FF) << 8;
+	out->ofdmgpo <<= 16;
+	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0xFF00) >> 8;
+	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0x00FF) << 8;
+}
+
+static int sprom_extract(struct ssb_bus *bus,
+			 struct ssb_sprom *out, const u16 *in)
+{
+	memset(out, 0, sizeof(*out));
+
+	SPEX(revision, SSB_SPROM_REVISION, SSB_SPROM_REVISION_REV, 0);
+	SPEX(crc, SSB_SPROM_REVISION, SSB_SPROM_REVISION_CRC,
+	     SSB_SPROM_REVISION_CRC_SHIFT);
+
+	if ((bus->chip_id & 0xFF00) == 0x4400) {
+		/* Workaround: The BCM44XX chip has a stupid revision
+		 * number stored in the SPROM.
+		 * Always extract r1. */
+		sprom_extract_r1(&out->r1, in);
+	} else {
+		if (out->revision == 0)
+			goto unsupported;
+		if (out->revision >= 1 && out->revision <= 3)
+			sprom_extract_r1(&out->r1, in);
+		if (out->revision >= 2 && out->revision <= 3)
+			sprom_extract_r2(&out->r2, in);
+		if (out->revision == 3)
+			sprom_extract_r3(&out->r3, in);
+		if (out->revision >= 4)
+			goto unsupported;
+	}
+
+	return 0;
+unsupported:
+	ssb_printk(KERN_WARNING PFX "Unsupported SPROM revision %d "
+		   "detected. Will extract v1\n", out->revision);
+	sprom_extract_r1(&out->r1, in);
+	return 0;
+}
+
+static int ssb_pci_sprom_get(struct ssb_bus *bus,
+			     struct ssb_sprom *sprom)
+{
+	int err = -ENOMEM;
+	u16 *buf;
+
+	buf = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	if (!buf)
+		goto out;
+	sprom_do_read(bus, buf);
+	err = sprom_check_crc(buf);
+	if (err) {
+		ssb_printk(KERN_WARNING PFX
+			   "WARNING: Invalid SPROM CRC (corrupt SPROM)\n");
+	}
+	err = sprom_extract(bus, sprom, buf);
+
+	kfree(buf);
+out:
+	return err;
+}
+
+static void ssb_pci_get_boardinfo(struct ssb_bus *bus,
+				  struct ssb_boardinfo *bi)
+{
+	pci_read_config_word(bus->host_pci, PCI_SUBSYSTEM_VENDOR_ID,
+			     &bi->vendor);
+	pci_read_config_word(bus->host_pci, PCI_SUBSYSTEM_ID,
+			     &bi->type);
+	pci_read_config_word(bus->host_pci, PCI_REVISION_ID,
+			     &bi->rev);
+}
+
+int ssb_pci_get_invariants(struct ssb_bus *bus,
+			   struct ssb_init_invariants *iv)
+{
+	int err;
+
+	err = ssb_pci_sprom_get(bus, &iv->sprom);
+	if (err)
+		goto out;
+	ssb_pci_get_boardinfo(bus, &iv->boardinfo);
+
+out:
+	return err;
+}
+
+static u16 ssb_pci_read16(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return 0xFFFF;
+	}
+	return readw(bus->mmio + offset);
+}
+
+static u32 ssb_pci_read32(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return 0xFFFFFFFF;
+	}
+	return readl(bus->mmio + offset);
+}
+
+static void ssb_pci_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return;
+	}
+	writew(value, bus->mmio + offset);
+}
+
+static void ssb_pci_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return;
+	}
+	writel(value, bus->mmio + offset);
+}
+
+/* Not "static", as it's used in main.c */
+const struct ssb_bus_ops ssb_pci_ops = {
+	.read16		= ssb_pci_read16,
+	.read32		= ssb_pci_read32,
+	.write16	= ssb_pci_write16,
+	.write32	= ssb_pci_write32,
+};
+
+static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len)
+{
+	int i, pos = 0;
+
+	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
+		pos += snprintf(buf + pos, buf_len - pos - 1,
+				"%04X", swab16(sprom[i]) & 0xFFFF);
+	}
+	pos += snprintf(buf + pos, buf_len - pos - 1, "\n");
+
+	return pos + 1;
+}
+
+static int hex2sprom(u16 *sprom, const char *dump, size_t len)
+{
+	char tmp[5] = { 0 };
+	int cnt = 0;
+	unsigned long parsed;
+
+	if (len < SSB_SPROMSIZE_BYTES * 2)
+		return -EINVAL;
+
+	while (cnt < SSB_SPROMSIZE_WORDS) {
+		memcpy(tmp, dump, 4);
+		dump += 4;
+		parsed = simple_strtoul(tmp, NULL, 16);
+		sprom[cnt++] = swab16((u16)parsed);
+	}
+
+	return 0;
+}
+
+static ssize_t ssb_pci_attr_sprom_show(struct device *pcidev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	struct pci_dev *pdev = container_of(pcidev, struct pci_dev, dev);
+	struct ssb_bus *bus;
+	u16 *sprom;
+	int err = -ENODEV;
+	ssize_t count = 0;
+
+	bus = ssb_pci_dev_to_bus(pdev);
+	if (!bus)
+		goto out;
+	err = -ENOMEM;
+	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	if (!sprom)
+		goto out;
+
+	/* Use interruptible locking, as the SPROM write might
+	 * be holding the lock for several seconds. So allow userspace
+	 * to cancel operation. */
+	err = -ERESTARTSYS;
+	if (mutex_lock_interruptible(&bus->pci_sprom_mutex))
+		goto out_kfree;
+	sprom_do_read(bus, sprom);
+	mutex_unlock(&bus->pci_sprom_mutex);
+
+	count = sprom2hex(sprom, buf, PAGE_SIZE);
+	err = 0;
+
+out_kfree:
+	kfree(sprom);
+out:
+	return err ? err : count;
+}
+
+static ssize_t ssb_pci_attr_sprom_store(struct device *pcidev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct pci_dev *pdev = container_of(pcidev, struct pci_dev, dev);
+	struct ssb_bus *bus;
+	u16 *sprom;
+	int res = 0, err = -ENODEV;
+
+	bus = ssb_pci_dev_to_bus(pdev);
+	if (!bus)
+		goto out;
+	err = -ENOMEM;
+	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	if (!sprom)
+		goto out;
+	err = hex2sprom(sprom, buf, count);
+	if (err) {
+		err = -EINVAL;
+		goto out_kfree;
+	}
+	err = sprom_check_crc(sprom);
+	if (err) {
+		err = -EINVAL;
+		goto out_kfree;
+	}
+
+	/* Use interruptible locking, as the SPROM write might
+	 * be holding the lock for several seconds. So allow userspace
+	 * to cancel operation. */
+	err = -ERESTARTSYS;
+	if (mutex_lock_interruptible(&bus->pci_sprom_mutex))
+		goto out_kfree;
+	err = ssb_devices_freeze(bus);
+	if (err == -EOPNOTSUPP) {
+		ssb_printk(KERN_ERR PFX "SPROM write: Could not freeze devices. "
+			   "No suspend support. Is CONFIG_PM enabled?\n");
+		goto out_unlock;
+	}
+	if (err) {
+		ssb_printk(KERN_ERR PFX "SPROM write: Could not freeze all devices\n");
+		goto out_unlock;
+	}
+	res = sprom_do_write(bus, sprom);
+	err = ssb_devices_thaw(bus);
+	if (err)
+		ssb_printk(KERN_ERR PFX "SPROM write: Could not thaw all devices\n");
+out_unlock:
+	mutex_unlock(&bus->pci_sprom_mutex);
+out_kfree:
+	kfree(sprom);
+out:
+	if (res)
+		return res;
+	return err ? err : count;
+}
+
+static DEVICE_ATTR(ssb_sprom, 0600,
+		   ssb_pci_attr_sprom_show,
+		   ssb_pci_attr_sprom_store);
+
+void ssb_pci_exit(struct ssb_bus *bus)
+{
+	struct pci_dev *pdev;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return;
+
+	pdev = bus->host_pci;
+	device_remove_file(&pdev->dev, &dev_attr_ssb_sprom);
+}
+
+int ssb_pci_init(struct ssb_bus *bus)
+{
+	struct pci_dev *pdev;
+	int err;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return 0;
+
+	pdev = bus->host_pci;
+	mutex_init(&bus->pci_sprom_mutex);
+	err = device_create_file(&pdev->dev, &dev_attr_ssb_sprom);
+	if (err)
+		goto out;
+
+out:
+	return err;
+}
diff --git a/drivers/ssb/pcihost_wrapper.c b/drivers/ssb/pcihost_wrapper.c
new file mode 100644
index 0000000..82a10ab
--- /dev/null
+++ b/drivers/ssb/pcihost_wrapper.c
@@ -0,0 +1,104 @@
+/*
+ * Sonics Silicon Backplane
+ * PCI Hostdevice wrapper
+ *
+ * Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>
+ * Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+ * Copyright (c) 2005 Danny van Dyk <kugelfang at gentoo.org>
+ * Copyright (c) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+ * Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/pci.h>
+#include <linux/ssb/ssb.h>
+
+
+#ifdef CONFIG_PM
+static int ssb_pcihost_suspend(struct pci_dev *dev, pm_message_t state)
+{
+	pci_save_state(dev);
+	pci_disable_device(dev);
+	pci_set_power_state(dev, pci_choose_state(dev, state));
+
+	return 0;
+}
+
+static int ssb_pcihost_resume(struct pci_dev *dev)
+{
+	int err;
+
+	pci_set_power_state(dev, 0);
+	err = pci_enable_device(dev);
+	if (err)
+		return err;
+	pci_restore_state(dev);
+
+	return 0;
+}
+#else /* CONFIG_PM */
+# define ssb_pcihost_suspend	NULL
+# define ssb_pcihost_resume	NULL
+#endif /* CONFIG_PM */
+
+static int ssb_pcihost_probe(struct pci_dev *dev,
+			     const struct pci_device_id *id)
+{
+	struct ssb_bus *ssb;
+	int err = -ENOMEM;
+	const char *name;
+
+	ssb = kzalloc(sizeof(*ssb), GFP_KERNEL);
+	if (!ssb)
+		goto out;
+	err = pci_enable_device(dev);
+	if (err)
+		goto err_kfree_ssb;
+	name = dev->dev.bus_id;
+	if (dev->driver && dev->driver->name)
+		name = dev->driver->name;
+	err = pci_request_regions(dev, name);
+	if (err)
+		goto err_pci_disable;
+	pci_set_master(dev);
+
+	err = ssb_bus_pcibus_register(ssb, dev);
+	if (err)
+		goto err_pci_release_regions;
+
+	pci_set_drvdata(dev, ssb);
+
+out:
+	return err;
+
+err_pci_release_regions:
+	pci_release_regions(dev);
+err_pci_disable:
+	pci_disable_device(dev);
+err_kfree_ssb:
+	kfree(ssb);
+	return err;
+}
+
+static void ssb_pcihost_remove(struct pci_dev *dev)
+{
+	struct ssb_bus *ssb = pci_get_drvdata(dev);
+
+	ssb_bus_unregister(ssb);
+	pci_release_regions(dev);
+	pci_disable_device(dev);
+	kfree(ssb);
+	pci_set_drvdata(dev, NULL);
+}
+
+int ssb_pcihost_register(struct pci_driver *driver)
+{
+	driver->probe = ssb_pcihost_probe;
+	driver->remove = ssb_pcihost_remove;
+	driver->suspend = ssb_pcihost_suspend;
+	driver->resume = ssb_pcihost_resume;
+
+	return pci_register_driver(driver);
+}
+EXPORT_SYMBOL(ssb_pcihost_register);
diff --git a/drivers/ssb/pcmcia.c b/drivers/ssb/pcmcia.c
new file mode 100644
index 0000000..b102738
--- /dev/null
+++ b/drivers/ssb/pcmcia.c
@@ -0,0 +1,265 @@
+/*
+ * Sonics Silicon Backplane
+ * PCMCIA-Hostbus related functions
+ *
+ * Copyright 2006 Johannes Berg <johannes at sipsolutions.net>
+ * Copyright 2007 Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/delay.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ciscode.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/cisreg.h>
+
+#include "ssb_private.h"
+
+
+int ssb_pcmcia_switch_coreidx(struct ssb_bus *bus,
+			      u8 coreidx)
+{
+	struct pcmcia_device *pdev = bus->host_pcmcia;
+	int err;
+	int attempts = 0;
+	u32 cur_core;
+	conf_reg_t reg;
+	u32 addr;
+	u32 read_addr;
+
+	addr = (coreidx * SSB_CORE_SIZE) + SSB_ENUM_BASE;
+	while (1) {
+		reg.Action = CS_WRITE;
+		reg.Offset = 0x2E;
+		reg.Value = (addr & 0x0000F000) >> 12;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		reg.Offset = 0x30;
+		reg.Value = (addr & 0x00FF0000) >> 16;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		reg.Offset = 0x32;
+		reg.Value = (addr & 0xFF000000) >> 24;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+
+		read_addr = 0;
+
+		reg.Action = CS_READ;
+		reg.Offset = 0x2E;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		read_addr |= (reg.Value & 0xF) << 12;
+		reg.Offset = 0x30;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		read_addr |= reg.Value << 16;
+		reg.Offset = 0x32;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		read_addr |= reg.Value << 24;
+
+		cur_core = (read_addr - SSB_ENUM_BASE) / SSB_CORE_SIZE;
+		if (cur_core == coreidx)
+			break;
+
+		if (attempts++ > SSB_BAR0_MAX_RETRIES)
+			goto error;
+		udelay(10);
+	}
+
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Failed to switch to core %u\n", coreidx);
+	return -ENODEV;
+}
+
+int ssb_pcmcia_switch_core(struct ssb_bus *bus,
+			   struct ssb_device *dev)
+{
+	int err;
+	unsigned long flags;
+
+	ssb_dprintk(KERN_INFO PFX
+		    "Switching to %s core, index %d\n",
+		    ssb_core_name(dev->id.coreid),
+		    dev->core_index);
+
+	spin_lock_irqsave(&bus->bar_lock, flags);
+	err = ssb_pcmcia_switch_coreidx(bus, dev->core_index);
+	if (!err)
+		bus->mapped_device = dev;
+	spin_unlock_irqrestore(&bus->bar_lock, flags);
+
+	return err;
+}
+
+int ssb_pcmcia_switch_segment(struct ssb_bus *bus, u8 seg)
+{
+	int attempts = 0;
+	unsigned long flags;
+	conf_reg_t reg;
+	int res, err = 0;
+
+	SSB_WARN_ON((seg != 0) && (seg != 1));
+	reg.Offset = 0x34;
+	reg.Function = 0;
+	spin_lock_irqsave(&bus->bar_lock, flags);
+	while (1) {
+		reg.Action = CS_WRITE;
+		reg.Value = seg;
+		res = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+		if (unlikely(res != CS_SUCCESS))
+			goto error;
+		reg.Value = 0xFF;
+		reg.Action = CS_READ;
+		res = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+		if (unlikely(res != CS_SUCCESS))
+			goto error;
+
+		if (reg.Value == seg)
+			break;
+
+		if (unlikely(attempts++ > SSB_BAR0_MAX_RETRIES))
+			goto error;
+		udelay(10);
+	}
+	bus->mapped_pcmcia_seg = seg;
+out_unlock:
+	spin_unlock_irqrestore(&bus->bar_lock, flags);
+	return err;
+error:
+	ssb_printk(KERN_ERR PFX "Failed to switch pcmcia segment\n");
+	err = -ENODEV;
+	goto out_unlock;
+}
+
+/* These are the main device register access functions.
+ * do_select_core is inline to have the likely hotpath inline.
+ * All unlikely codepaths are out-of-line. */
+static inline int do_select_core(struct ssb_bus *bus,
+				 struct ssb_device *dev,
+				 u16 *offset)
+{
+	int err;
+	u8 need_seg = (*offset >= 0x800) ? 1 : 0;
+
+	if (unlikely(dev != bus->mapped_device)) {
+		err = ssb_pcmcia_switch_core(bus, dev);
+		if (unlikely(err))
+			return err;
+	}
+	if (unlikely(need_seg != bus->mapped_pcmcia_seg)) {
+		err = ssb_pcmcia_switch_segment(bus, need_seg);
+		if (unlikely(err))
+			return err;
+	}
+	if (need_seg == 1)
+		*offset -= 0x800;
+
+	return 0;
+}
+
+static u16 ssb_pcmcia_read16(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+	u16 x;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return 0xFFFF;
+	x = readw(bus->mmio + offset);
+
+	return x;
+}
+
+static u32 ssb_pcmcia_read32(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+	u32 x;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return 0xFFFFFFFF;
+	x = readl(bus->mmio + offset);
+
+	return x;
+}
+
+static void ssb_pcmcia_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return;
+	writew(value, bus->mmio + offset);
+}
+
+static void ssb_pcmcia_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return;
+	readw(bus->mmio + offset);
+	writew(value >> 16, bus->mmio + offset + 2);
+	readw(bus->mmio + offset);
+	writew(value, bus->mmio + offset);
+}
+
+/* Not "static", as it's used in main.c */
+const struct ssb_bus_ops ssb_pcmcia_ops = {
+	.read16		= ssb_pcmcia_read16,
+	.read32		= ssb_pcmcia_read32,
+	.write16	= ssb_pcmcia_write16,
+	.write32	= ssb_pcmcia_write32,
+};
+
+int ssb_pcmcia_get_invariants(struct ssb_bus *bus,
+			      struct ssb_init_invariants *iv)
+{
+	//TODO
+	return 0;
+}
+
+int ssb_pcmcia_init(struct ssb_bus *bus)
+{
+	conf_reg_t reg;
+	int err;
+
+	if (bus->bustype != SSB_BUSTYPE_PCMCIA)
+		return 0;
+
+	/* Switch segment to a known state and sync
+	 * bus->mapped_pcmcia_seg with hardware state. */
+	ssb_pcmcia_switch_segment(bus, 0);
+
+	/* Init IRQ routing */
+	reg.Action = CS_READ;
+	reg.Function = 0;
+	if (bus->chip_id == 0x4306)
+		reg.Offset = 0x00;
+	else
+		reg.Offset = 0x80;
+	err = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+	if (err != CS_SUCCESS)
+		goto error;
+	reg.Action = CS_WRITE;
+	reg.Value |= 0x04 | 0x01;
+	err = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+	if (err != CS_SUCCESS)
+		goto error;
+
+	return 0;
+error:
+	return -ENODEV;
+}
diff --git a/drivers/ssb/scan.c b/drivers/ssb/scan.c
new file mode 100644
index 0000000..96258c6
--- /dev/null
+++ b/drivers/ssb/scan.c
@@ -0,0 +1,413 @@
+/*
+ * Sonics Silicon Backplane
+ * Bus scanning
+ *
+ * Copyright (C) 2005-2007 Michael Buesch <mb at bu3sch.de>
+ * Copyright (C) 2005 Martin Langer <martin-langer at gmx.de>
+ * Copyright (C) 2005 Stefano Brivio <st3 at riseup.net>
+ * Copyright (C) 2005 Danny van Dyk <kugelfang at gentoo.org>
+ * Copyright (C) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+ * Copyright (C) 2006 Broadcom Corporation.
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+#include <linux/pci.h>
+#include <linux/io.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+
+#include "ssb_private.h"
+
+
+const char *ssb_core_name(u16 coreid)
+{
+	switch (coreid) {
+	case SSB_DEV_CHIPCOMMON:
+		return "ChipCommon";
+	case SSB_DEV_ILINE20:
+		return "ILine 20";
+	case SSB_DEV_SDRAM:
+		return "SDRAM";
+	case SSB_DEV_PCI:
+		return "PCI";
+	case SSB_DEV_MIPS:
+		return "MIPS";
+	case SSB_DEV_ETHERNET:
+		return "Fast Ethernet";
+	case SSB_DEV_V90:
+		return "V90";
+	case SSB_DEV_USB11_HOSTDEV:
+		return "USB 1.1 Hostdev";
+	case SSB_DEV_ADSL:
+		return "ADSL";
+	case SSB_DEV_ILINE100:
+		return "ILine 100";
+	case SSB_DEV_IPSEC:
+		return "IPSEC";
+	case SSB_DEV_PCMCIA:
+		return "PCMCIA";
+	case SSB_DEV_INTERNAL_MEM:
+		return "Internal Memory";
+	case SSB_DEV_MEMC_SDRAM:
+		return "MEMC SDRAM";
+	case SSB_DEV_EXTIF:
+		return "EXTIF";
+	case SSB_DEV_80211:
+		return "IEEE 802.11";
+	case SSB_DEV_MIPS_3302:
+		return "MIPS 3302";
+	case SSB_DEV_USB11_HOST:
+		return "USB 1.1 Host";
+	case SSB_DEV_USB11_DEV:
+		return "USB 1.1 Device";
+	case SSB_DEV_USB20_HOST:
+		return "USB 2.0 Host";
+	case SSB_DEV_USB20_DEV:
+		return "USB 2.0 Device";
+	case SSB_DEV_SDIO_HOST:
+		return "SDIO Host";
+	case SSB_DEV_ROBOSWITCH:
+		return "Roboswitch";
+	case SSB_DEV_PARA_ATA:
+		return "PATA";
+	case SSB_DEV_SATA_XORDMA:
+		return "SATA XOR-DMA";
+	case SSB_DEV_ETHERNET_GBIT:
+		return "GBit Ethernet";
+	case SSB_DEV_PCIE:
+		return "PCI-E";
+	case SSB_DEV_MIMO_PHY:
+		return "MIMO PHY";
+	case SSB_DEV_SRAM_CTRLR:
+		return "SRAM Controller";
+	case SSB_DEV_MINI_MACPHY:
+		return "Mini MACPHY";
+	case SSB_DEV_ARM_1176:
+		return "ARM 1176";
+	case SSB_DEV_ARM_7TDMI:
+		return "ARM 7TDMI";
+	}
+	return "UNKNOWN";
+}
+
+static u16 pcidev_to_chipid(struct pci_dev *pci_dev)
+{
+	u16 chipid_fallback = 0;
+
+	switch (pci_dev->device) {
+	case 0x4301:
+		chipid_fallback = 0x4301;
+		break;
+	case 0x4305 ... 0x4307:
+		chipid_fallback = 0x4307;
+		break;
+	case 0x4403:
+		chipid_fallback = 0x4402;
+		break;
+	case 0x4610 ... 0x4615:
+		chipid_fallback = 0x4610;
+		break;
+	case 0x4710 ... 0x4715:
+		chipid_fallback = 0x4710;
+		break;
+	case 0x4320 ... 0x4325:
+		chipid_fallback = 0x4309;
+		break;
+	case PCI_DEVICE_ID_BCM4401:
+	case PCI_DEVICE_ID_BCM4401B0:
+	case PCI_DEVICE_ID_BCM4401B1:
+		chipid_fallback = 0x4401;
+		break;
+	default:
+		ssb_printk(KERN_ERR PFX
+			   "PCI-ID not in fallback list\n");
+	}
+
+	return chipid_fallback;
+}
+
+static u8 chipid_to_nrcores(u16 chipid)
+{
+	switch (chipid) {
+	case 0x5365:
+		return 7;
+	case 0x4306:
+		return 6;
+	case 0x4310:
+		return 8;
+	case 0x4307:
+	case 0x4301:
+		return 5;
+	case 0x4401:
+	case 0x4402:
+		return 3;
+	case 0x4710:
+	case 0x4610:
+	case 0x4704:
+		return 9;
+	default:
+		ssb_printk(KERN_ERR PFX
+			   "CHIPID not in nrcores fallback list\n");
+	}
+
+	return 1;
+}
+
+static u32 scan_read32(struct ssb_bus *bus, u8 current_coreidx,
+		       u16 offset)
+{
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		offset += current_coreidx * SSB_CORE_SIZE;
+		break;
+	case SSB_BUSTYPE_PCI:
+		break;
+	case SSB_BUSTYPE_PCMCIA:
+		if (offset >= 0x800) {
+			ssb_pcmcia_switch_segment(bus, 1);
+			offset -= 0x800;
+		} else
+			ssb_pcmcia_switch_segment(bus, 0);
+		break;
+	}
+	return readl(bus->mmio + offset);
+}
+
+static int scan_switchcore(struct ssb_bus *bus, u8 coreidx)
+{
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		break;
+	case SSB_BUSTYPE_PCI:
+		return ssb_pci_switch_coreidx(bus, coreidx);
+	case SSB_BUSTYPE_PCMCIA:
+		return ssb_pcmcia_switch_coreidx(bus, coreidx);
+	}
+	return 0;
+}
+
+void ssb_iounmap(struct ssb_bus *bus)
+{
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+	case SSB_BUSTYPE_PCMCIA:
+		iounmap(bus->mmio);
+		break;
+	case SSB_BUSTYPE_PCI:
+#ifdef CONFIG_SSB_PCIHOST
+		pci_iounmap(bus->host_pci, bus->mmio);
+#else
+		SSB_BUG_ON(1); /* Can't reach this code. */
+#endif
+		break;
+	}
+	bus->mmio = NULL;
+	bus->mapped_device = NULL;
+}
+
+static void __iomem *ssb_ioremap(struct ssb_bus *bus,
+				 unsigned long baseaddr)
+{
+	void __iomem *mmio = NULL;
+
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		/* Only map the first core for now. */
+		/* fallthrough... */
+	case SSB_BUSTYPE_PCMCIA:
+		mmio = ioremap(baseaddr, SSB_CORE_SIZE);
+		break;
+	case SSB_BUSTYPE_PCI:
+#ifdef CONFIG_SSB_PCIHOST
+		mmio = pci_iomap(bus->host_pci, 0, ~0UL);
+#else
+		SSB_BUG_ON(1); /* Can't reach this code. */
+#endif
+		break;
+	}
+
+	return mmio;
+}
+
+static int we_support_multiple_80211_cores(struct ssb_bus *bus)
+{
+	/* More than one 802.11 core is only supported by special chips.
+	 * There are chips with two 802.11 cores, but with dangling
+	 * pins on the second core. Be careful and reject them here.
+	 */
+
+#ifdef CONFIG_SSB_PCIHOST
+	if (bus->bustype == SSB_BUSTYPE_PCI) {
+		if (bus->host_pci->vendor == PCI_VENDOR_ID_BROADCOM &&
+		    bus->host_pci->device == 0x4324)
+			return 1;
+	}
+#endif /* CONFIG_SSB_PCIHOST */
+	return 0;
+}
+
+int ssb_bus_scan(struct ssb_bus *bus,
+		 unsigned long baseaddr)
+{
+	int err = -ENOMEM;
+	void __iomem *mmio;
+	u32 idhi, cc, rev, tmp;
+	int dev_i, i;
+	struct ssb_device *dev;
+	int nr_80211_cores = 0;
+
+	mmio = ssb_ioremap(bus, baseaddr);
+	if (!mmio)
+		goto out;
+	bus->mmio = mmio;
+
+	err = scan_switchcore(bus, 0); /* Switch to first core */
+	if (err)
+		goto err_unmap;
+
+	idhi = scan_read32(bus, 0, SSB_IDHIGH);
+	cc = (idhi & SSB_IDHIGH_CC) >> SSB_IDHIGH_CC_SHIFT;
+	rev = (idhi & SSB_IDHIGH_RCLO);
+	rev |= (idhi & SSB_IDHIGH_RCHI) >> SSB_IDHIGH_RCHI_SHIFT;
+
+	bus->nr_devices = 0;
+	if (cc == SSB_DEV_CHIPCOMMON) {
+		tmp = scan_read32(bus, 0, SSB_CHIPCO_CHIPID);
+
+		bus->chip_id = (tmp & SSB_CHIPCO_IDMASK);
+		bus->chip_rev = (tmp & SSB_CHIPCO_REVMASK) >>
+				SSB_CHIPCO_REVSHIFT;
+		bus->chip_package = (tmp & SSB_CHIPCO_PACKMASK) >>
+				    SSB_CHIPCO_PACKSHIFT;
+		if (rev >= 4) {
+			bus->nr_devices = (tmp & SSB_CHIPCO_NRCORESMASK) >>
+					  SSB_CHIPCO_NRCORESSHIFT;
+		}
+		tmp = scan_read32(bus, 0, SSB_CHIPCO_CAP);
+		bus->chipco.capabilities = tmp;
+	} else {
+		if (bus->bustype == SSB_BUSTYPE_PCI) {
+			bus->chip_id = pcidev_to_chipid(bus->host_pci);
+			pci_read_config_word(bus->host_pci, PCI_REVISION_ID,
+					     &bus->chip_rev);
+			bus->chip_package = 0;
+		} else {
+			bus->chip_id = 0x4710;
+			bus->chip_rev = 0;
+			bus->chip_package = 0;
+		}
+	}
+	if (!bus->nr_devices)
+		bus->nr_devices = chipid_to_nrcores(bus->chip_id);
+	if (bus->nr_devices > ARRAY_SIZE(bus->devices)) {
+		ssb_printk(KERN_ERR PFX
+			   "More than %d ssb cores found (%d)\n",
+			   SSB_MAX_NR_CORES, bus->nr_devices);
+		goto err_unmap;
+	}
+	if (bus->bustype == SSB_BUSTYPE_SSB) {
+		/* Now that we know the number of cores,
+		 * remap the whole IO space for all cores.
+		 */
+		err = -ENOMEM;
+		iounmap(mmio);
+		mmio = ioremap(baseaddr, SSB_CORE_SIZE * bus->nr_devices);
+		if (!mmio)
+			goto out;
+		bus->mmio = mmio;
+	}
+
+	/* Fetch basic information about each core/device */
+	for (i = 0, dev_i = 0; i < bus->nr_devices; i++) {
+		err = scan_switchcore(bus, i);
+		if (err)
+			goto err_unmap;
+		dev = &(bus->devices[dev_i]);
+
+		idhi = scan_read32(bus, i, SSB_IDHIGH);
+		dev->id.coreid = (idhi & SSB_IDHIGH_CC) >> SSB_IDHIGH_CC_SHIFT;
+		dev->id.revision = (idhi & SSB_IDHIGH_RCLO);
+		dev->id.revision |= (idhi & SSB_IDHIGH_RCHI) >> SSB_IDHIGH_RCHI_SHIFT;
+		dev->id.vendor = (idhi & SSB_IDHIGH_VC) >> SSB_IDHIGH_VC_SHIFT;
+		dev->core_index = i;
+		dev->bus = bus;
+		dev->ops = bus->ops;
+
+		ssb_dprintk(KERN_INFO PFX
+			    "Core %d found: %s "
+			    "(cc 0x%03X, rev 0x%02X, vendor 0x%04X)\n",
+			    i, ssb_core_name(dev->id.coreid),
+			    dev->id.coreid, dev->id.revision, dev->id.vendor);
+
+		switch (dev->id.coreid) {
+		case SSB_DEV_80211:
+			nr_80211_cores++;
+			if (nr_80211_cores > 1) {
+				if (!we_support_multiple_80211_cores(bus)) {
+					ssb_dprintk(KERN_INFO PFX "Ignoring additional "
+						    "802.11 core\n");
+					continue;
+				}
+			}
+			break;
+		case SSB_DEV_EXTIF:
+#ifdef CONFIG_SSB_DRIVER_EXTIF
+			if (bus->extif.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple EXTIFs found\n");
+				break;
+			}
+			bus->extif.dev = dev;
+#endif /* CONFIG_SSB_DRIVER_EXTIF */
+			break;
+		case SSB_DEV_CHIPCOMMON:
+			if (bus->chipco.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple ChipCommon found\n");
+				break;
+			}
+			bus->chipco.dev = dev;
+			break;
+		case SSB_DEV_MIPS:
+		case SSB_DEV_MIPS_3302:
+#ifdef CONFIG_SSB_DRIVER_MIPS
+			if (bus->mipscore.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple MIPS cores found\n");
+				break;
+			}
+			bus->mipscore.dev = dev;
+#endif /* CONFIG_SSB_DRIVER_MIPS */
+			break;
+		case SSB_DEV_PCI:
+		case SSB_DEV_PCIE:
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+			if (bus->pcicore.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple PCI(E) cores found\n");
+				break;
+			}
+			bus->pcicore.dev = dev;
+#endif /* CONFIG_SSB_DRIVER_PCICORE */
+			break;
+		default:
+			break;
+		}
+
+		dev_i++;
+	}
+	bus->nr_devices = dev_i;
+
+	err = 0;
+out:
+	return err;
+err_unmap:
+	ssb_iounmap(bus);
+	goto out;
+}
diff --git a/drivers/ssb/ssb_private.h b/drivers/ssb/ssb_private.h
new file mode 100644
index 0000000..9ccb2d8
--- /dev/null
+++ b/drivers/ssb/ssb_private.h
@@ -0,0 +1,122 @@
+#ifndef LINUX_SSB_PRIVATE_H_
+#define LINUX_SSB_PRIVATE_H_
+
+#include <linux/ssb/ssb.h>
+#include <linux/types.h>
+
+
+#define PFX	"ssb: "
+
+#ifdef CONFIG_SSB_SILENT
+# define ssb_printk(fmt, x...)	do { /* nothing */ } while (0)
+#else
+# define ssb_printk		printk
+#endif /* CONFIG_SSB_SILENT */
+
+/* dprintk: Debugging printk; vanishes for non-debug compilation */
+#ifdef CONFIG_SSB_DEBUG
+# define ssb_dprintk(fmt, x...)	ssb_printk(fmt , ##x)
+#else
+# define ssb_dprintk(fmt, x...)	do { /* nothing */ } while (0)
+#endif
+
+#ifdef CONFIG_SSB_DEBUG
+# define SSB_WARN_ON(x)		WARN_ON(x)
+# define SSB_BUG_ON(x)		BUG_ON(x)
+#else
+static inline int __ssb_do_nothing(void) { return 0; }
+# define SSB_WARN_ON(x)		__ssb_do_nothing()
+# define SSB_BUG_ON(x)		__ssb_do_nothing()
+#endif
+
+
+/* pci.c */
+#ifdef CONFIG_SSB_PCIHOST
+extern int ssb_pci_switch_core(struct ssb_bus *bus,
+			       struct ssb_device *dev);
+extern int ssb_pci_switch_coreidx(struct ssb_bus *bus,
+				  u8 coreidx);
+extern int ssb_pci_xtal(struct ssb_bus *bus, u32 what,
+			int turn_on);
+extern int ssb_pci_get_invariants(struct ssb_bus *bus,
+				  struct ssb_init_invariants *iv);
+extern void ssb_pci_exit(struct ssb_bus *bus);
+extern int ssb_pci_init(struct ssb_bus *bus);
+extern const struct ssb_bus_ops ssb_pci_ops;
+
+#else /* CONFIG_SSB_PCIHOST */
+
+static inline int ssb_pci_switch_core(struct ssb_bus *bus,
+				      struct ssb_device *dev)
+{
+	return 0;
+}
+static inline int ssb_pci_switch_coreidx(struct ssb_bus *bus,
+					 u8 coreidx)
+{
+	return 0;
+}
+static inline int ssb_pci_xtal(struct ssb_bus *bus, u32 what,
+			       int turn_on)
+{
+	return 0;
+}
+static inline void ssb_pci_exit(struct ssb_bus *bus)
+{
+}
+static inline int ssb_pci_init(struct ssb_bus *bus)
+{
+	return 0;
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+
+/* pcmcia.c */
+#ifdef CONFIG_SSB_PCMCIAHOST
+extern int ssb_pcmcia_switch_core(struct ssb_bus *bus,
+				  struct ssb_device *dev);
+extern int ssb_pcmcia_switch_coreidx(struct ssb_bus *bus,
+				     u8 coreidx);
+extern int ssb_pcmcia_switch_segment(struct ssb_bus *bus,
+				     u8 seg);
+extern int ssb_pcmcia_get_invariants(struct ssb_bus *bus,
+				     struct ssb_init_invariants *iv);
+extern int ssb_pcmcia_init(struct ssb_bus *bus);
+extern const struct ssb_bus_ops ssb_pcmcia_ops;
+#else /* CONFIG_SSB_PCMCIAHOST */
+static inline int ssb_pcmcia_switch_core(struct ssb_bus *bus,
+					 struct ssb_device *dev)
+{
+	return 0;
+}
+static inline int ssb_pcmcia_switch_coreidx(struct ssb_bus *bus,
+					    u8 coreidx)
+{
+	return 0;
+}
+static inline int ssb_pcmcia_switch_segment(struct ssb_bus *bus,
+					    u8 seg)
+{
+	return 0;
+}
+static inline int ssb_pcmcia_init(struct ssb_bus *bus)
+{
+	return 0;
+}
+#endif /* CONFIG_SSB_PCMCIAHOST */
+
+
+/* scan.c */
+extern const char *ssb_core_name(u16 coreid);
+extern int ssb_bus_scan(struct ssb_bus *bus,
+			unsigned long baseaddr);
+extern void ssb_iounmap(struct ssb_bus *ssb);
+
+
+/* core.c */
+extern u32 ssb_calc_clock_rate(u32 plltype, u32 n, u32 m);
+extern int ssb_devices_freeze(struct ssb_bus *bus);
+extern int ssb_devices_thaw(struct ssb_bus *bus);
+extern struct ssb_bus *ssb_pci_dev_to_bus(struct pci_dev *pdev);
+
+#endif /* LINUX_SSB_PRIVATE_H_ */
diff --git a/include/linux/ssb/ssb_driver_chipcommon.h b/include/linux/ssb/ssb_driver_chipcommon.h
new file mode 100644
index 0000000..d58c24b
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_chipcommon.h
@@ -0,0 +1,385 @@
+#ifndef LINUX_SSB_CHIPCO_H_
+#define LINUX_SSB_CHIPCO_H_
+
+/* SonicsSiliconBackplane CHIPCOMMON core hardware definitions
+ *
+ * The chipcommon core provides chip identification, SB control,
+ * jtag, 0/1/2 uarts, clock frequency control, a watchdog interrupt timer,
+ * gpio interface, extbus, and support for serial and parallel flashes.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GPL version 2. See COPYING for details.
+ */
+
+/** ChipCommon core registers. **/
+
+#define SSB_CHIPCO_CHIPID		0x0000
+#define  SSB_CHIPCO_IDMASK		0x0000FFFF
+#define  SSB_CHIPCO_REVMASK		0x000F0000
+#define  SSB_CHIPCO_REVSHIFT		16
+#define  SSB_CHIPCO_PACKMASK		0x00F00000
+#define  SSB_CHIPCO_PACKSHIFT		20
+#define  SSB_CHIPCO_NRCORESMASK		0x0F000000
+#define  SSB_CHIPCO_NRCORESSHIFT	24
+#define SSB_CHIPCO_CAP	 		0x0004		/* Capabilities */
+#define  SSB_CHIPCO_CAP_NRUART		0x00000003	/* # of UARTs */
+#define  SSB_CHIPCO_CAP_MIPSEB		0x00000004	/* MIPS in BigEndian Mode */
+#define  SSB_CHIPCO_CAP_UARTCLK		0x00000018	/* UART clock select */
+#define   SSB_CHIPCO_CAP_UARTCLK_INT	0x00000008	/* UARTs are driven by internal divided clock */
+#define  SSB_CHIPCO_CAP_UARTGPIO	0x00000020	/* UARTs on GPIO 15-12 */
+#define  SSB_CHIPCO_CAP_EXTBUS		0x000000C0	/* External buses present */
+#define  SSB_CHIPCO_CAP_FLASHT		0x00000700	/* Flash Type */
+#define   SSB_CHIPCO_FLASHT_NONE	0x00000000	/* No flash */
+#define   SSB_CHIPCO_FLASHT_STSER	0x00000100	/* ST serial flash */
+#define   SSB_CHIPCO_FLASHT_ATSER	0x00000200	/* Atmel serial flash */
+#define	  SSB_CHIPCO_FLASHT_PARA	0x00000700	/* Parallel flash */
+#define  SSB_CHIPCO_CAP_PLLT		0x00038000	/* PLL Type */
+#define   SSB_PLLTYPE_NONE		0x00000000
+#define   SSB_PLLTYPE_1			0x00010000	/* 48Mhz base, 3 dividers */
+#define   SSB_PLLTYPE_2			0x00020000	/* 48Mhz, 4 dividers */
+#define   SSB_PLLTYPE_3			0x00030000	/* 25Mhz, 2 dividers */
+#define   SSB_PLLTYPE_4			0x00008000	/* 48Mhz, 4 dividers */
+#define   SSB_PLLTYPE_5			0x00018000	/* 25Mhz, 4 dividers */
+#define   SSB_PLLTYPE_6			0x00028000	/* 100/200 or 120/240 only */
+#define   SSB_PLLTYPE_7			0x00038000	/* 25Mhz, 4 dividers */
+#define  SSB_CHIPCO_CAP_PCTL		0x00040000	/* Power Control */
+#define  SSB_CHIPCO_CAP_OTPS		0x00380000	/* OTP size */
+#define  SSB_CHIPCO_CAP_OTPS_SHIFT	19
+#define  SSB_CHIPCO_CAP_OTPS_BASE	5
+#define  SSB_CHIPCO_CAP_JTAGM		0x00400000	/* JTAG master present */
+#define  SSB_CHIPCO_CAP_BROM		0x00800000	/* Internal boot ROM active */
+#define  SSB_CHIPCO_CAP_64BIT		0x08000000	/* 64-bit Backplane */
+#define SSB_CHIPCO_CORECTL		0x0008
+#define  SSB_CHIPCO_CORECTL_UARTCLK0	0x00000001	/* Drive UART with internal clock */
+#define	 SSB_CHIPCO_CORECTL_SE		0x00000002	/* sync clk out enable (corerev >= 3) */
+#define SSB_CHIPCO_BIST			0x000C
+#define SSB_CHIPCO_OTPS			0x0010		/* OTP status */
+#define	 SSB_CHIPCO_OTPS_PROGFAIL	0x80000000
+#define	 SSB_CHIPCO_OTPS_PROTECT	0x00000007
+#define	 SSB_CHIPCO_OTPS_HW_PROTECT	0x00000001
+#define	 SSB_CHIPCO_OTPS_SW_PROTECT	0x00000002
+#define	 SSB_CHIPCO_OTPS_CID_PROTECT	0x00000004
+#define SSB_CHIPCO_OTPC			0x0014		/* OTP control */
+#define	 SSB_CHIPCO_OTPC_RECWAIT	0xFF000000
+#define	 SSB_CHIPCO_OTPC_PROGWAIT	0x00FFFF00
+#define	 SSB_CHIPCO_OTPC_PRW_SHIFT	8
+#define	 SSB_CHIPCO_OTPC_MAXFAIL	0x00000038
+#define	 SSB_CHIPCO_OTPC_VSEL		0x00000006
+#define	 SSB_CHIPCO_OTPC_SELVL		0x00000001
+#define SSB_CHIPCO_OTPP			0x0018		/* OTP prog */
+#define	 SSB_CHIPCO_OTPP_COL		0x000000FF
+#define	 SSB_CHIPCO_OTPP_ROW		0x0000FF00
+#define	 SSB_CHIPCO_OTPP_ROW_SHIFT	8
+#define	 SSB_CHIPCO_OTPP_READERR	0x10000000
+#define	 SSB_CHIPCO_OTPP_VALUE		0x20000000
+#define	 SSB_CHIPCO_OTPP_READ		0x40000000
+#define	 SSB_CHIPCO_OTPP_START		0x80000000
+#define	 SSB_CHIPCO_OTPP_BUSY		0x80000000
+#define SSB_CHIPCO_IRQSTAT		0x0020
+#define SSB_CHIPCO_IRQMASK		0x0024
+#define	 SSB_CHIPCO_IRQ_GPIO		0x00000001	/* gpio intr */
+#define	 SSB_CHIPCO_IRQ_EXT		0x00000002	/* ro: ext intr pin (corerev >= 3) */
+#define	 SSB_CHIPCO_IRQ_WDRESET		0x80000000	/* watchdog reset occurred */
+#define SSB_CHIPCO_CHIPCTL		0x0028		/* Rev >= 11 only */
+#define SSB_CHIPCO_CHIPSTAT		0x002C		/* Rev >= 11 only */
+#define SSB_CHIPCO_JCMD			0x0030		/* Rev >= 10 only */
+#define  SSB_CHIPCO_JCMD_START		0x80000000
+#define  SSB_CHIPCO_JCMD_BUSY		0x80000000
+#define  SSB_CHIPCO_JCMD_PAUSE		0x40000000
+#define  SSB_CHIPCO_JCMD0_ACC_MASK	0x0000F000
+#define  SSB_CHIPCO_JCMD0_ACC_IRDR	0x00000000
+#define  SSB_CHIPCO_JCMD0_ACC_DR	0x00001000
+#define  SSB_CHIPCO_JCMD0_ACC_IR	0x00002000
+#define  SSB_CHIPCO_JCMD0_ACC_RESET	0x00003000
+#define  SSB_CHIPCO_JCMD0_ACC_IRPDR	0x00004000
+#define  SSB_CHIPCO_JCMD0_ACC_PDR	0x00005000
+#define  SSB_CHIPCO_JCMD0_IRW_MASK	0x00000F00
+#define  SSB_CHIPCO_JCMD_ACC_MASK	0x000F0000	/* Changes for corerev 11 */
+#define  SSB_CHIPCO_JCMD_ACC_IRDR	0x00000000
+#define  SSB_CHIPCO_JCMD_ACC_DR		0x00010000
+#define  SSB_CHIPCO_JCMD_ACC_IR		0x00020000
+#define  SSB_CHIPCO_JCMD_ACC_RESET	0x00030000
+#define  SSB_CHIPCO_JCMD_ACC_IRPDR	0x00040000
+#define  SSB_CHIPCO_JCMD_ACC_PDR	0x00050000
+#define  SSB_CHIPCO_JCMD_IRW_MASK	0x00001F00
+#define  SSB_CHIPCO_JCMD_IRW_SHIFT	8
+#define  SSB_CHIPCO_JCMD_DRW_MASK	0x0000003F
+#define SSB_CHIPCO_JIR			0x0034		/* Rev >= 10 only */
+#define SSB_CHIPCO_JDR			0x0038		/* Rev >= 10 only */
+#define SSB_CHIPCO_JCTL			0x003C		/* Rev >= 10 only */
+#define  SSB_CHIPCO_JCTL_FORCE_CLK	4		/* Force clock */
+#define  SSB_CHIPCO_JCTL_EXT_EN		2		/* Enable external targets */
+#define  SSB_CHIPCO_JCTL_EN		1		/* Enable Jtag master */
+#define SSB_CHIPCO_FLASHCTL		0x0040
+#define  SSB_CHIPCO_FLASHCTL_START	0x80000000
+#define  SSB_CHIPCO_FLASHCTL_BUSY	SSB_CHIPCO_FLASHCTL_START
+#define SSB_CHIPCO_FLASHADDR		0x0044
+#define SSB_CHIPCO_FLASHDATA		0x0048
+#define SSB_CHIPCO_BCAST_ADDR		0x0050
+#define SSB_CHIPCO_BCAST_DATA		0x0054
+#define SSB_CHIPCO_GPIOIN		0x0060
+#define SSB_CHIPCO_GPIOOUT		0x0064
+#define SSB_CHIPCO_GPIOOUTEN		0x0068
+#define SSB_CHIPCO_GPIOCTL		0x006C
+#define SSB_CHIPCO_GPIOPOL		0x0070
+#define SSB_CHIPCO_GPIOIRQ		0x0074
+#define SSB_CHIPCO_WATCHDOG		0x0080
+#define SSB_CHIPCO_GPIOTIMER		0x0088		/* LED powersave (corerev >= 16) */
+#define  SSB_CHIPCO_GPIOTIMER_ONTIME_SHIFT	16
+#define SSB_CHIPCO_GPIOTOUTM		0x008C		/* LED powersave (corerev >= 16) */
+#define SSB_CHIPCO_CLOCK_N		0x0090
+#define SSB_CHIPCO_CLOCK_SB		0x0094
+#define SSB_CHIPCO_CLOCK_PCI		0x0098
+#define SSB_CHIPCO_CLOCK_M2		0x009C
+#define SSB_CHIPCO_CLOCK_MIPS		0x00A0
+#define SSB_CHIPCO_CLKDIV		0x00A4		/* Rev >= 3 only */
+#define	 SSB_CHIPCO_CLKDIV_SFLASH	0x0F000000
+#define	 SSB_CHIPCO_CLKDIV_SFLASH_SHIFT	24
+#define	 SSB_CHIPCO_CLKDIV_OTP		0x000F0000
+#define	 SSB_CHIPCO_CLKDIV_OTP_SHIFT	16
+#define	 SSB_CHIPCO_CLKDIV_JTAG		0x00000F00
+#define	 SSB_CHIPCO_CLKDIV_JTAG_SHIFT	8
+#define	 SSB_CHIPCO_CLKDIV_UART		0x000000FF
+#define SSB_CHIPCO_PLLONDELAY		0x00B0		/* Rev >= 4 only */
+#define SSB_CHIPCO_FREFSELDELAY		0x00B4		/* Rev >= 4 only */
+#define SSB_CHIPCO_SLOWCLKCTL		0x00B8		/* 6 <= Rev <= 9 only */
+#define  SSB_CHIPCO_SLOWCLKCTL_SRC	0x00000007	/* slow clock source mask */
+#define	  SSB_CHIPCO_SLOWCLKCTL_SRC_LPO		0x00000000	/* source of slow clock is LPO */
+#define   SSB_CHIPCO_SLOWCLKCTL_SRC_XTAL	0x00000001	/* source of slow clock is crystal */
+#define	  SSB_CHIPCO_SLOECLKCTL_SRC_PCI		0x00000002	/* source of slow clock is PCI */
+#define  SSB_CHIPCO_SLOWCLKCTL_LPOFREQ	0x00000200	/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
+#define  SSB_CHIPCO_SLOWCLKCTL_LPOPD	0x00000400	/* LPOPowerDown, 1: LPO is disabled, 0: LPO is enabled */
+#define  SSB_CHIPCO_SLOWCLKCTL_FSLOW	0x00000800	/* ForceSlowClk, 1: sb/cores running on slow clock, 0: power logic control */
+#define  SSB_CHIPCO_SLOWCLKCTL_IPLL	0x00001000	/* IgnorePllOffReq, 1/0: power logic ignores/honors PLL clock disable requests from core */
+#define  SSB_CHIPCO_SLOWCLKCTL_ENXTAL	0x00002000	/* XtalControlEn, 1/0: power logic does/doesn't disable crystal when appropriate */
+#define  SSB_CHIPCO_SLOWCLKCTL_XTALPU	0x00004000	/* XtalPU (RO), 1/0: crystal running/disabled */
+#define  SSB_CHIPCO_SLOWCLKCTL_CLKDIV	0xFFFF0000	/* ClockDivider (SlowClk = 1/(4+divisor)) */
+#define  SSB_CHIPCO_SLOWCLKCTL_CLKDIV_SHIFT	16
+#define SSB_CHIPCO_SYSCLKCTL		0x00C0		/* Rev >= 3 only */
+#define	 SSB_CHIPCO_SYSCLKCTL_IDLPEN	0x00000001	/* ILPen: Enable Idle Low Power */
+#define	 SSB_CHIPCO_SYSCLKCTL_ALPEN	0x00000002	/* ALPen: Enable Active Low Power */
+#define	 SSB_CHIPCO_SYSCLKCTL_PLLEN	0x00000004	/* ForcePLLOn */
+#define	 SSB_CHIPCO_SYSCLKCTL_FORCEALP	0x00000008	/* Force ALP (or HT if ALPen is not set */
+#define	 SSB_CHIPCO_SYSCLKCTL_FORCEHT	0x00000010	/* Force HT */
+#define  SSB_CHIPCO_SYSCLKCTL_CLKDIV	0xFFFF0000	/* ClkDiv  (ILP = 1/(4+divisor)) */
+#define  SSB_CHIPCO_SYSCLKCTL_CLKDIV_SHIFT	16
+#define SSB_CHIPCO_CLKSTSTR		0x00C4		/* Rev >= 3 only */
+#define SSB_CHIPCO_PCMCIA_CFG		0x0100
+#define SSB_CHIPCO_PCMCIA_MEMWAIT	0x0104
+#define SSB_CHIPCO_PCMCIA_ATTRWAIT	0x0108
+#define SSB_CHIPCO_PCMCIA_IOWAIT	0x010C
+#define SSB_CHIPCO_IDE_CFG		0x0110
+#define SSB_CHIPCO_IDE_MEMWAIT		0x0114
+#define SSB_CHIPCO_IDE_ATTRWAIT		0x0118
+#define SSB_CHIPCO_IDE_IOWAIT		0x011C
+#define SSB_CHIPCO_PROG_CFG		0x0120
+#define SSB_CHIPCO_PROG_WAITCNT		0x0124
+#define SSB_CHIPCO_FLASH_CFG		0x0128
+#define SSB_CHIPCO_FLASH_WAITCNT	0x012C
+#define SSB_CHIPCO_UART0_DATA		0x0300
+#define SSB_CHIPCO_UART0_IMR		0x0304
+#define SSB_CHIPCO_UART0_FCR		0x0308
+#define SSB_CHIPCO_UART0_LCR		0x030C
+#define SSB_CHIPCO_UART0_MCR		0x0310
+#define SSB_CHIPCO_UART0_LSR		0x0314
+#define SSB_CHIPCO_UART0_MSR		0x0318
+#define SSB_CHIPCO_UART0_SCRATCH	0x031C
+#define SSB_CHIPCO_UART1_DATA		0x0400
+#define SSB_CHIPCO_UART1_IMR		0x0404
+#define SSB_CHIPCO_UART1_FCR		0x0408
+#define SSB_CHIPCO_UART1_LCR		0x040C
+#define SSB_CHIPCO_UART1_MCR		0x0410
+#define SSB_CHIPCO_UART1_LSR		0x0414
+#define SSB_CHIPCO_UART1_MSR		0x0418
+#define SSB_CHIPCO_UART1_SCRATCH	0x041C
+
+
+
+/** Clockcontrol masks and values **/
+
+/* SSB_CHIPCO_CLOCK_N */
+#define	SSB_CHIPCO_CLK_N1		0x0000003F	/* n1 control */
+#define	SSB_CHIPCO_CLK_N2		0x00003F00	/* n2 control */
+#define	SSB_CHIPCO_CLK_N2_SHIFT		8
+#define	SSB_CHIPCO_CLK_PLLC		0x000F0000	/* pll control */
+#define	SSB_CHIPCO_CLK_PLLC_SHIFT	16
+
+/* SSB_CHIPCO_CLOCK_SB/PCI/UART */
+#define	SSB_CHIPCO_CLK_M1		0x0000003F	/* m1 control */
+#define	SSB_CHIPCO_CLK_M2		0x00003F00	/* m2 control */
+#define	SSB_CHIPCO_CLK_M2_SHIFT		8
+#define	SSB_CHIPCO_CLK_M3		0x003F0000	/* m3 control */
+#define	SSB_CHIPCO_CLK_M3_SHIFT		16
+#define	SSB_CHIPCO_CLK_MC		0x1F000000	/* mux control */
+#define	SSB_CHIPCO_CLK_MC_SHIFT		24
+
+/* N3M Clock control magic field values */
+#define	SSB_CHIPCO_CLK_F6_2		0x02		/* A factor of 2 in */
+#define	SSB_CHIPCO_CLK_F6_3		0x03		/* 6-bit fields like */
+#define	SSB_CHIPCO_CLK_F6_4		0x05		/* N1, M1 or M3 */
+#define	SSB_CHIPCO_CLK_F6_5		0x09
+#define	SSB_CHIPCO_CLK_F6_6		0x11
+#define	SSB_CHIPCO_CLK_F6_7		0x21
+
+#define	SSB_CHIPCO_CLK_F5_BIAS		5		/* 5-bit fields get this added */
+
+#define	SSB_CHIPCO_CLK_MC_BYPASS	0x08
+#define	SSB_CHIPCO_CLK_MC_M1		0x04
+#define	SSB_CHIPCO_CLK_MC_M1M2		0x02
+#define	SSB_CHIPCO_CLK_MC_M1M2M3	0x01
+#define	SSB_CHIPCO_CLK_MC_M1M3		0x11
+
+/* Type 2 Clock control magic field values */
+#define	SSB_CHIPCO_CLK_T2_BIAS		2		/* n1, n2, m1 & m3 bias */
+#define	SSB_CHIPCO_CLK_T2M2_BIAS	3		/* m2 bias */
+
+#define	SSB_CHIPCO_CLK_T2MC_M1BYP	1
+#define	SSB_CHIPCO_CLK_T2MC_M2BYP	2
+#define	SSB_CHIPCO_CLK_T2MC_M3BYP	4
+
+/* Type 6 Clock control magic field values */
+#define	SSB_CHIPCO_CLK_T6_MMASK		1		/* bits of interest in m */
+#define	SSB_CHIPCO_CLK_T6_M0		120000000	/* sb clock for m = 0 */
+#define	SSB_CHIPCO_CLK_T6_M1		100000000	/* sb clock for m = 1 */
+#define	SSB_CHIPCO_CLK_SB2MIPS_T6(sb)	(2 * (sb))
+
+/* Common clock base */
+#define	SSB_CHIPCO_CLK_BASE1		24000000	/* Half the clock freq */
+#define SSB_CHIPCO_CLK_BASE2		12500000	/* Alternate crystal on some PLL's */
+
+/* Clock control values for 200Mhz in 5350 */
+#define	SSB_CHIPCO_CLK_5350_N		0x0311
+#define	SSB_CHIPCO_CLK_5350_M		0x04020009
+
+
+/** Bits in the config registers **/
+
+#define	SSB_CHIPCO_CFG_EN		0x0001		/* Enable */
+#define	SSB_CHIPCO_CFG_EXTM		0x000E		/* Extif Mode */
+#define	 SSB_CHIPCO_CFG_EXTM_ASYNC	0x0002		/* Async/Parallel flash */
+#define	 SSB_CHIPCO_CFG_EXTM_SYNC	0x0004		/* Synchronous */
+#define	 SSB_CHIPCO_CFG_EXTM_PCMCIA	0x0008		/* PCMCIA */
+#define	 SSB_CHIPCO_CFG_EXTM_IDE	0x000A		/* IDE */
+#define	SSB_CHIPCO_CFG_DS16		0x0010		/* Data size, 0=8bit, 1=16bit */
+#define	SSB_CHIPCO_CFG_CLKDIV		0x0060		/* Sync: Clock divisor */
+#define	SSB_CHIPCO_CFG_CLKEN		0x0080		/* Sync: Clock enable */
+#define	SSB_CHIPCO_CFG_BSTRO		0x0100		/* Sync: Size/Bytestrobe */
+
+
+/** Flash-specific control/status values */
+
+/* flashcontrol opcodes for ST flashes */
+#define SSB_CHIPCO_FLASHCTL_ST_WREN	0x0006		/* Write Enable */
+#define SSB_CHIPCO_FLASHCTL_ST_WRDIS	0x0004		/* Write Disable */
+#define SSB_CHIPCO_FLASHCTL_ST_RDSR	0x0105		/* Read Status Register */
+#define SSB_CHIPCO_FLASHCTL_ST_WRSR	0x0101		/* Write Status Register */
+#define SSB_CHIPCO_FLASHCTL_ST_READ	0x0303		/* Read Data Bytes */
+#define SSB_CHIPCO_FLASHCTL_ST_PP	0x0302		/* Page Program */
+#define SSB_CHIPCO_FLASHCTL_ST_SE	0x02D8		/* Sector Erase */
+#define SSB_CHIPCO_FLASHCTL_ST_BE	0x00C7		/* Bulk Erase */
+#define SSB_CHIPCO_FLASHCTL_ST_DP	0x00B9		/* Deep Power-down */
+#define SSB_CHIPCO_FLASHCTL_ST_RSIG	0x03AB		/* Read Electronic Signature */
+
+/* Status register bits for ST flashes */
+#define SSB_CHIPCO_FLASHSTA_ST_WIP	0x01		/* Write In Progress */
+#define SSB_CHIPCO_FLASHSTA_ST_WEL	0x02		/* Write Enable Latch */
+#define SSB_CHIPCO_FLASHSTA_ST_BP	0x1C		/* Block Protect */
+#define SSB_CHIPCO_FLASHSTA_ST_BP_SHIFT	2
+#define SSB_CHIPCO_FLASHSTA_ST_SRWD	0x80		/* Status Register Write Disable */
+
+/* flashcontrol opcodes for Atmel flashes */
+#define SSB_CHIPCO_FLASHCTL_AT_READ		0x07E8
+#define SSB_CHIPCO_FLASHCTL_AT_PAGE_READ	0x07D2
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_READ	/* FIXME */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_READ	/* FIXME */
+#define SSB_CHIPCO_FLASHCTL_AT_STATUS		0x01D7
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_WRITE	0x0384
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_WRITE	0x0387
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_ERASE_PRGM	0x0283	/* Erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_ERASE_PRGM	0x0286	/* Erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_PROGRAM	0x0288
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_PROGRAM	0x0289
+#define SSB_CHIPCO_FLASHCTL_AT_PAGE_ERASE	0x0281
+#define SSB_CHIPCO_FLASHCTL_AT_BLOCK_ERASE	0x0250
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_WRER_PRGM	0x0382	/* Write erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_WRER_PRGM	0x0385	/* Write erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_LOAD	0x0253
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_LOAD	0x0255
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_COMPARE	0x0260
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_COMPARE	0x0261
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_REPROGRAM	0x0258
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_REPROGRAM	0x0259
+
+/* Status register bits for Atmel flashes */
+#define SSB_CHIPCO_FLASHSTA_AT_READY	0x80
+#define SSB_CHIPCO_FLASHSTA_AT_MISMATCH	0x40
+#define SSB_CHIPCO_FLASHSTA_AT_ID	0x38
+#define SSB_CHIPCO_FLASHSTA_AT_ID_SHIFT	3
+
+
+/** OTP **/
+
+/* OTP regions */
+#define	SSB_CHIPCO_OTP_HW_REGION	SSB_CHIPCO_OTPS_HW_PROTECT
+#define	SSB_CHIPCO_OTP_SW_REGION	SSB_CHIPCO_OTPS_SW_PROTECT
+#define	SSB_CHIPCO_OTP_CID_REGION	SSB_CHIPCO_OTPS_CID_PROTECT
+
+/* OTP regions (Byte offsets from otp size) */
+#define	SSB_CHIPCO_OTP_SWLIM_OFF	(-8)
+#define	SSB_CHIPCO_OTP_CIDBASE_OFF	0
+#define	SSB_CHIPCO_OTP_CIDLIM_OFF	8
+
+/* Predefined OTP words (Word offset from otp size) */
+#define	SSB_CHIPCO_OTP_BOUNDARY_OFF	(-4)
+#define	SSB_CHIPCO_OTP_HWSIGN_OFF	(-3)
+#define	SSB_CHIPCO_OTP_SWSIGN_OFF	(-2)
+#define	SSB_CHIPCO_OTP_CIDSIGN_OFF	(-1)
+
+#define	SSB_CHIPCO_OTP_CID_OFF		0
+#define	SSB_CHIPCO_OTP_PKG_OFF		1
+#define	SSB_CHIPCO_OTP_FID_OFF		2
+#define	SSB_CHIPCO_OTP_RSV_OFF		3
+#define	SSB_CHIPCO_OTP_LIM_OFF		4
+
+#define	SSB_CHIPCO_OTP_SIGNATURE	0x578A
+#define	SSB_CHIPCO_OTP_MAGIC		0x4E56
+
+
+struct ssb_device;
+struct ssb_serial_port;
+
+struct ssb_chipcommon {
+	struct ssb_device *dev;
+	u32 capabilities;
+	/* Fast Powerup Delay constant */
+	u16 fast_pwrup_delay;
+};
+
+extern void ssb_chipcommon_init(struct ssb_chipcommon *cc);
+
+#include <linux/pm.h>
+extern void ssb_chipco_suspend(struct ssb_chipcommon *cc, pm_message_t state);
+extern void ssb_chipco_resume(struct ssb_chipcommon *cc);
+
+extern void ssb_chipco_get_clockcontrol(struct ssb_chipcommon *cc,
+					u32 *plltype, u32 *n, u32 *m);
+extern void ssb_chipco_timing_init(struct ssb_chipcommon *cc,
+				   unsigned long ns_per_cycle);
+
+enum ssb_clkmode {
+	SSB_CLKMODE_SLOW,
+	SSB_CLKMODE_FAST,
+	SSB_CLKMODE_DYNAMIC,
+};
+
+extern void ssb_chipco_set_clockmode(struct ssb_chipcommon *cc,
+				     enum ssb_clkmode mode);
+
+#ifdef CONFIG_SSB_SERIAL
+extern int ssb_chipco_serial_init(struct ssb_chipcommon *cc,
+				  struct ssb_serial_port *ports);
+#endif /* CONFIG_SSB_SERIAL */
+
+#endif /* LINUX_SSB_CHIPCO_H_ */
diff --git a/include/linux/ssb/ssb_driver_extif.h b/include/linux/ssb/ssb_driver_extif.h
new file mode 100644
index 0000000..00de749
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_extif.h
@@ -0,0 +1,160 @@
+/*
+ * Hardware-specific External Interface I/O core definitions
+ * for the BCM47xx family of SiliconBackplane-based chips.
+ *
+ * The External Interface core supports a total of three external chip selects
+ * supporting external interfaces. One of the external chip selects is
+ * used for Flash, one is used for PCMCIA, and the other may be
+ * programmed to support either a synchronous interface or an
+ * asynchronous interface. The asynchronous interface can be used to
+ * support external devices such as UARTs and the BCM2019 Bluetooth
+ * baseband processor.
+ * The external interface core also contains 2 on-chip 16550 UARTs, clock
+ * frequency control, a watchdog interrupt timer, and a GPIO interface.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, Michael Buesch
+ *
+ * Licensed under the GPL version 2. See COPYING for details.
+ */
+#ifndef LINUX_SSB_EXTIFCORE_H_
+#define LINUX_SSB_EXTIFCORE_H_
+
+struct ssb_extif {
+	struct ssb_device *dev;
+};
+
+/* external interface address space */
+#define	SSB_EXTIF_PCMCIA_MEMBASE(x)	(x)
+#define	SSB_EXTIF_PCMCIA_IOBASE(x)	((x) + 0x100000)
+#define	SSB_EXTIF_PCMCIA_CFGBASE(x)	((x) + 0x200000)
+#define	SSB_EXTIF_CFGIF_BASE(x)		((x) + 0x800000)
+#define	SSB_EXTIF_FLASH_BASE(x)		((x) + 0xc00000)
+
+#define SSB_EXTIF_NR_GPIOOUT		5
+/* GPIO NOTE:
+ * The multiple instances of output and output enable registers
+ * are present to allow driver software for multiple cores to control
+ * gpio outputs without needing to share a single register pair.
+ * Use the following helper macro to get a register offset value.
+ */
+#define SSB_EXTIF_GPIO_OUT(index)	({		\
+	BUILD_BUG_ON(index >= SSB_EXTIF_NR_GPIOOUT);	\
+	SSB_EXTIF_GPIO_OUT_BASE + ((index) * 8);	\
+					})
+#define SSB_EXTIF_GPIO_OUTEN(index)	({		\
+	BUILD_BUG_ON(index >= SSB_EXTIF_NR_GPIOOUT);	\
+	SSB_EXTIF_GPIO_OUTEN_BASE + ((index) * 8);	\
+					})
+
+/** EXTIF core registers **/
+
+#define SSB_EXTIF_CTL			0x0000
+#define  SSB_EXTIF_CTL_UARTEN		(1 << 0) /* UART enable */
+#define SSB_EXTIF_EXTSTAT		0x0004
+#define  SSB_EXTIF_EXTSTAT_EMODE	(1 << 0) /* Endian mode (ro) */
+#define  SSB_EXTIF_EXTSTAT_EIRQPIN	(1 << 1) /* External interrupt pin (ro) */
+#define  SSB_EXTIF_EXTSTAT_GPIOIRQPIN	(1 << 2) /* GPIO interrupt pin (ro) */
+#define SSB_EXTIF_PCMCIA_CFG		0x0010
+#define SSB_EXTIF_PCMCIA_MEMWAIT	0x0014
+#define SSB_EXTIF_PCMCIA_ATTRWAIT	0x0018
+#define SSB_EXTIF_PCMCIA_IOWAIT		0x001C
+#define SSB_EXTIF_PROG_CFG		0x0020
+#define SSB_EXTIF_PROG_WAITCNT		0x0024
+#define SSB_EXTIF_FLASH_CFG		0x0028
+#define SSB_EXTIF_FLASH_WAITCNT		0x002C
+#define SSB_EXTIF_WATCHDOG		0x0040
+#define SSB_EXTIF_CLOCK_N		0x0044
+#define SSB_EXTIF_CLOCK_SB		0x0048
+#define SSB_EXTIF_CLOCK_PCI		0x004C
+#define SSB_EXTIF_CLOCK_MII		0x0050
+#define SSB_EXTIF_GPIO_IN		0x0060
+#define SSB_EXTIF_GPIO_OUT_BASE		0x0064
+#define SSB_EXTIF_GPIO_OUTEN_BASE	0x0068
+#define SSB_EXTIF_EJTAG_OUTEN		0x0090
+#define SSB_EXTIF_GPIO_INTPOL		0x0094
+#define SSB_EXTIF_GPIO_INTMASK		0x0098
+#define SSB_EXTIF_UART_DATA		0x0300
+#define SSB_EXTIF_UART_TIMER		0x0310
+#define SSB_EXTIF_UART_FCR		0x0320
+#define SSB_EXTIF_UART_LCR		0x0330
+#define SSB_EXTIF_UART_MCR		0x0340
+#define SSB_EXTIF_UART_LSR		0x0350
+#define SSB_EXTIF_UART_MSR		0x0360
+#define SSB_EXTIF_UART_SCRATCH		0x0370
+
+
+
+
+/* pcmcia/prog/flash_config */
+#define	SSB_EXTCFG_EN			(1 << 0)	/* enable */
+#define	SSB_EXTCFG_MODE			0xE		/* mode */
+#define	SSB_EXTCFG_MODE_SHIFT		1
+#define	 SSB_EXTCFG_MODE_FLASH		0x0		/* flash/asynchronous mode */
+#define	 SSB_EXTCFG_MODE_SYNC		0x2		/* synchronous mode */
+#define	 SSB_EXTCFG_MODE_PCMCIA		0x4		/* pcmcia mode */
+#define	SSB_EXTCFG_DS16			(1 << 4)	/* destsize:  0=8bit, 1=16bit */
+#define	SSB_EXTCFG_BSWAP		(1 << 5)	/* byteswap */
+#define	SSB_EXTCFG_CLKDIV		0xC0		/* clock divider */
+#define	SSB_EXTCFG_CLKDIV_SHIFT		6
+#define	 SSB_EXTCFG_CLKDIV_2		0x0		/* backplane/2 */
+#define	 SSB_EXTCFG_CLKDIV_3		0x40		/* backplane/3 */
+#define	 SSB_EXTCFG_CLKDIV_4		0x80		/* backplane/4 */
+#define	SSB_EXTCFG_CLKEN		(1 << 8)	/* clock enable */
+#define	SSB_EXTCFG_STROBE		(1 << 9)	/* size/bytestrobe (synch only) */
+
+/* pcmcia_memwait */
+#define	SSB_PCMCIA_MEMW_0		0x0000003F	/* waitcount0 */
+#define	SSB_PCMCIA_MEMW_1		0x00001F00	/* waitcount1 */
+#define	SSB_PCMCIA_MEMW_1_SHIFT		8
+#define	SSB_PCMCIA_MEMW_2		0x001F0000	/* waitcount2 */
+#define	SSB_PCMCIA_MEMW_2_SHIFT		16
+#define	SSB_PCMCIA_MEMW_3		0x1F000000	/* waitcount3 */
+#define	SSB_PCMCIA_MEMW_3_SHIFT		24
+
+/* pcmcia_attrwait */
+#define	SSB_PCMCIA_ATTW_0		0x0000003F	/* waitcount0 */
+#define	SSB_PCMCIA_ATTW_1		0x00001F00	/* waitcount1 */
+#define	SSB_PCMCIA_ATTW_1_SHIFT		8
+#define	SSB_PCMCIA_ATTW_2		0x001F0000	/* waitcount2 */
+#define	SSB_PCMCIA_ATTW_2_SHIFT		16
+#define	SSB_PCMCIA_ATTW_3		0x1F000000	/* waitcount3 */
+#define	SSB_PCMCIA_ATTW_3_SHIFT		24
+
+/* pcmcia_iowait */
+#define	SSB_PCMCIA_IOW_0		0x0000003F	/* waitcount0 */
+#define	SSB_PCMCIA_IOW_1		0x00001F00	/* waitcount1 */
+#define	SSB_PCMCIA_IOW_1_SHIFT		8
+#define	SSB_PCMCIA_IOW_2		0x001F0000	/* waitcount2 */
+#define	SSB_PCMCIA_IOW_2_SHIFT		16
+#define	SSB_PCMCIA_IOW_3		0x1F000000	/* waitcount3 */
+#define	SSB_PCMCIA_IOW_3_SHIFT		24
+
+/* prog_waitcount */
+#define	SSB_PROG_WCNT_0			0x0000001F	/* waitcount0 */
+#define	SSB_PROG_WCNT_1			0x00001F00	/* waitcount1 */
+#define	SSB_PROG_WCNT_1_SHIFT		8
+#define	SSB_PROG_WCNT_2			0x001F0000	/* waitcount2 */
+#define	SSB_PROG_WCNT_2_SHIFT		16
+#define	SSB_PROG_WCNT_3			0x1F000000	/* waitcount3 */
+#define	SSB_PROG_WCNT_3_SHIFT		24
+
+#define SSB_PROG_W0			0x0000000C
+#define SSB_PROG_W1			0x00000A00
+#define SSB_PROG_W2			0x00020000
+#define SSB_PROG_W3			0x01000000
+
+/* flash_waitcount */
+#define	SSB_FLASH_WCNT_0		0x0000001F	/* waitcount0 */
+#define	SSB_FLASH_WCNT_1		0x00001F00	/* waitcount1 */
+#define	SSB_FLASH_WCNT_1_SHIFT		8
+#define	SSB_FLASH_WCNT_2		0x001F0000	/* waitcount2 */
+#define	SSB_FLASH_WCNT_2_SHIFT		16
+#define	SSB_FLASH_WCNT_3		0x1F000000	/* waitcount3 */
+#define	SSB_FLASH_WCNT_3_SHIFT		24
+
+/* watchdog */
+#define SSB_EXTIF_WATCHDOG_CLK		48000000	/* Hz */
+
+
+#endif /* LINUX_SSB_EXTIFCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_mips.h b/include/linux/ssb/ssb_driver_mips.h
new file mode 100644
index 0000000..cdbb985
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_mips.h
@@ -0,0 +1,44 @@
+#ifndef LINUX_SSB_MIPSCORE_H_
+#define LINUX_SSB_MIPSCORE_H_
+
+#ifdef CONFIG_SSB_DRIVER_MIPS
+
+struct ssb_device;
+
+struct ssb_serial_port {
+	void *regs;
+	unsigned long clockspeed;
+	unsigned int irq;
+	unsigned int baud_base;
+	unsigned int reg_shift;
+};
+
+
+struct ssb_mipscore {
+	struct ssb_device *dev;
+
+	int nr_serial_ports;
+	struct ssb_serial_port serial_ports[4];
+
+	u32 flash_window;
+	u32 flash_window_size;
+};
+
+extern void ssb_mipscore_init(struct ssb_mipscore *mcore);
+
+extern unsigned int ssb_mips_irq(struct ssb_device *dev);
+
+
+#else /* CONFIG_SSB_DRIVER_MIPS */
+
+struct ssb_mipscore {
+};
+
+static inline
+void ssb_mipscore_init(struct ssb_mipscore *mcore)
+{
+}
+
+#endif /* CONFIG_SSB_DRIVER_MIPS */
+
+#endif /* LINUX_SSB_MIPSCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_pci.h b/include/linux/ssb/ssb_driver_pci.h
new file mode 100644
index 0000000..9cfffb7
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_pci.h
@@ -0,0 +1,106 @@
+#ifndef LINUX_SSB_PCICORE_H_
+#define LINUX_SSB_PCICORE_H_
+
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+
+/* PCI core registers. */
+#define SSB_PCICORE_CTL			0x0000	/* PCI Control */
+#define  SSB_PCICORE_CTL_RST_OE		0x00000001 /* PCI_RESET Output Enable */
+#define  SSB_PCICORE_CTL_RST		0x00000002 /* PCI_RESET driven out to pin */
+#define  SSB_PCICORE_CTL_CLK_OE		0x00000004 /* Clock gate Output Enable */
+#define  SSB_PCICORE_CTL_CLK		0x00000008 /* Gate for clock driven out to pin */
+#define SSB_PCICORE_ARBCTL		0x0010	/* PCI Arbiter Control */
+#define  SSB_PCICORE_ARBCTL_INTERN	0x00000001 /* Use internal arbiter */
+#define  SSB_PCICORE_ARBCTL_EXTERN	0x00000002 /* Use external arbiter */
+#define  SSB_PCICORE_ARBCTL_PARKID	0x00000006 /* Mask, selects which agent is parked on an idle bus */
+#define   SSB_PCICORE_ARBCTL_PARKID_LAST	0x00000000 /* Last requestor */
+#define   SSB_PCICORE_ARBCTL_PARKID_4710	0x00000002 /* 4710 */
+#define   SSB_PCICORE_ARBCTL_PARKID_EXT0	0x00000004 /* External requestor 0 */
+#define   SSB_PCICORE_ARBCTL_PARKID_EXT1	0x00000006 /* External requestor 1 */
+#define SSB_PCICORE_ISTAT		0x0020	/* Interrupt status */
+#define  SSB_PCICORE_ISTAT_INTA		0x00000001 /* PCI INTA# */
+#define  SSB_PCICORE_ISTAT_INTB		0x00000002 /* PCI INTB# */
+#define  SSB_PCICORE_ISTAT_SERR		0x00000004 /* PCI SERR# (write to clear) */
+#define  SSB_PCICORE_ISTAT_PERR		0x00000008 /* PCI PERR# (write to clear) */
+#define  SSB_PCICORE_ISTAT_PME		0x00000010 /* PCI PME# */
+#define SSB_PCICORE_IMASK		0x0024	/* Interrupt mask */
+#define  SSB_PCICORE_IMASK_INTA		0x00000001 /* PCI INTA# */
+#define  SSB_PCICORE_IMASK_INTB		0x00000002 /* PCI INTB# */
+#define  SSB_PCICORE_IMASK_SERR		0x00000004 /* PCI SERR# */
+#define  SSB_PCICORE_IMASK_PERR		0x00000008 /* PCI PERR# */
+#define  SSB_PCICORE_IMASK_PME		0x00000010 /* PCI PME# */
+#define SSB_PCICORE_MBOX		0x0028	/* Backplane to PCI Mailbox */
+#define  SSB_PCICORE_MBOX_F0_0		0x00000100 /* PCI function 0, INT 0 */
+#define  SSB_PCICORE_MBOX_F0_1		0x00000200 /* PCI function 0, INT 1 */
+#define  SSB_PCICORE_MBOX_F1_0		0x00000400 /* PCI function 1, INT 0 */
+#define  SSB_PCICORE_MBOX_F1_1		0x00000800 /* PCI function 1, INT 1 */
+#define  SSB_PCICORE_MBOX_F2_0		0x00001000 /* PCI function 2, INT 0 */
+#define  SSB_PCICORE_MBOX_F2_1		0x00002000 /* PCI function 2, INT 1 */
+#define  SSB_PCICORE_MBOX_F3_0		0x00004000 /* PCI function 3, INT 0 */
+#define  SSB_PCICORE_MBOX_F3_1		0x00008000 /* PCI function 3, INT 1 */
+#define SSB_PCICORE_BCAST_ADDR		0x0050	/* Backplane Broadcast Address */
+#define  SSB_PCICORE_BCAST_ADDR_MASK	0x000000FF
+#define SSB_PCICORE_BCAST_DATA		0x0054	/* Backplane Broadcast Data */
+#define SSB_PCICORE_GPIO_IN		0x0060	/* rev >= 2 only */
+#define SSB_PCICORE_GPIO_OUT		0x0064	/* rev >= 2 only */
+#define SSB_PCICORE_GPIO_ENABLE		0x0068	/* rev >= 2 only */
+#define SSB_PCICORE_GPIO_CTL		0x006C	/* rev >= 2 only */
+#define SSB_PCICORE_SBTOPCI0		0x0100	/* Backplane to PCI translation 0 (sbtopci0) */
+#define  SSB_PCICORE_SBTOPCI0_MASK	0xFC000000
+#define SSB_PCICORE_SBTOPCI1		0x0104	/* Backplane to PCI translation 1 (sbtopci1) */
+#define  SSB_PCICORE_SBTOPCI1_MASK	0xFC000000
+#define SSB_PCICORE_SBTOPCI2		0x0108	/* Backplane to PCI translation 2 (sbtopci2) */
+#define  SSB_PCICORE_SBTOPCI2_MASK	0xC0000000
+
+/* SBtoPCIx */
+#define SSB_PCICORE_SBTOPCI_MEM		0x00000000
+#define SSB_PCICORE_SBTOPCI_IO		0x00000001
+#define SSB_PCICORE_SBTOPCI_CFG0	0x00000002
+#define SSB_PCICORE_SBTOPCI_CFG1	0x00000003
+#define SSB_PCICORE_SBTOPCI_PREF	0x00000004 /* Prefetch enable */
+#define SSB_PCICORE_SBTOPCI_BURST	0x00000008 /* Burst enable */
+#define SSB_PCICORE_SBTOPCI_MRM		0x00000020 /* Memory Read Multiple */
+#define SSB_PCICORE_SBTOPCI_RC		0x00000030 /* Read Command mask (rev >= 11) */
+#define  SSB_PCICORE_SBTOPCI_RC_READ	0x00000000 /* Memory read */
+#define  SSB_PCICORE_SBTOPCI_RC_READL	0x00000010 /* Memory read line */
+#define  SSB_PCICORE_SBTOPCI_RC_READM	0x00000020 /* Memory read multiple */
+
+
+/* PCIcore specific boardflags */
+#define SSB_PCICORE_BFL_NOPCI		0x00000400 /* Board leaves PCI floating */
+
+
+struct ssb_pcicore {
+	struct ssb_device *dev;
+	u8 setup_done:1;
+	u8 hostmode:1;
+	u8 cardbusmode:1;
+};
+
+extern void ssb_pcicore_init(struct ssb_pcicore *pc);
+
+/* Enable IRQ routing for a specific device */
+extern int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
+					  struct ssb_device *dev);
+
+
+#else /* CONFIG_SSB_DRIVER_PCICORE */
+
+
+struct ssb_pcicore {
+};
+
+static inline
+void ssb_pcicore_init(struct ssb_pcicore *pc)
+{
+}
+
+static inline
+int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
+				   struct ssb_device *dev)
+{
+	return 0;
+}
+
+#endif /* CONFIG_SSB_DRIVER_PCICORE */
+#endif /* LINUX_SSB_PCICORE_H_ */
diff --git a/include/linux/ssb/ssb.h b/include/linux/ssb/ssb.h
new file mode 100644
index 0000000..8326377
--- /dev/null
+++ b/include/linux/ssb/ssb.h
@@ -0,0 +1,432 @@
+#ifndef LINUX_SSB_H_
+#define LINUX_SSB_H_
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+
+#include <linux/ssb/ssb_regs.h>
+
+
+struct pcmcia_device;
+struct ssb_bus;
+struct ssb_driver;
+
+
+struct ssb_sprom_r1 {
+	u16 pci_spid;		/* Subsystem Product ID for PCI */
+	u16 pci_svid;		/* Subsystem Vendor ID for PCI */
+	u16 pci_pid;		/* Product ID for PCI */
+	u8 il0mac[6];		/* MAC address for 802.11b/g */
+	u8 et0mac[6];		/* MAC address for Ethernet */
+	u8 et1mac[6];		/* MAC address for 802.11a */
+	u8 et0phyaddr:5;	/* MII address for enet0 */
+	u8 et1phyaddr:5;	/* MII address for enet1 */
+	u8 et0mdcport:1;	/* MDIO for enet0 */
+	u8 et1mdcport:1;	/* MDIO for enet1 */
+	u8 board_rev;		/* Board revision */
+	u8 country_code:4;	/* Country Code */
+	u8 antenna_a:2;		/* Antenna 0/1 available for A-PHY */
+	u8 antenna_bg:2;	/* Antenna 0/1 available for B-PHY and G-PHY */
+	u16 pa0b0;
+	u16 pa0b1;
+	u16 pa0b2;
+	u16 pa1b0;
+	u16 pa1b1;
+	u16 pa1b2;
+	u8 gpio0;		/* GPIO pin 0 */
+	u8 gpio1;		/* GPIO pin 1 */
+	u8 gpio2;		/* GPIO pin 2 */
+	u8 gpio3;		/* GPIO pin 3 */
+	u16 maxpwr_a;		/* A-PHY Power Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_bg;		/* B/G-PHY Power Amplifier Max Power (in dBm Q5.2) */
+	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
+	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
+	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
+	u8 antenna_gain_a;	/* A-PHY Antenna gain (in dBm Q5.2) */
+	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
+	u8 oem[8];		/* OEM string (rev 1 only) */
+};
+
+struct ssb_sprom_r2 {
+	u16 boardflags_hi;	/* Boardflags (high 16 bits) */
+	u8 maxpwr_a_lo;		/* A-PHY Max Power Low */
+	u8 maxpwr_a_hi;		/* A-PHY Max Power High */
+	u16 pa1lob0;		/* A-PHY PA Low Settings */
+	u16 pa1lob1;		/* A-PHY PA Low Settings */
+	u16 pa1lob2;		/* A-PHY PA Low Settings */
+	u16 pa1hib0;		/* A-PHY PA High Settings */
+	u16 pa1hib1;		/* A-PHY PA High Settings */
+	u16 pa1hib2;		/* A-PHY PA High Settings */
+	u8 ofdm_pwr_off;	/* OFDM Power Offset from CCK Level */
+	u8 country_str[2];	/* Two char Country Code */
+};
+
+struct ssb_sprom_r3 {
+	u32 ofdmapo;		/* A-PHY OFDM Mid Power Offset */
+	u32 ofdmalpo;		/* A-PHY OFDM Low Power Offset */
+	u32 ofdmahpo;		/* A-PHY OFDM High Power Offset */
+	u8 gpioldc_on_cnt;	/* GPIO LED Powersave Duty Cycle ON count */
+	u8 gpioldc_off_cnt;	/* GPIO LED Powersave Duty Cycle OFF count */
+	u8 cckpo_1M:4;		/* CCK Power Offset for Rate 1M */
+	u8 cckpo_2M:4;		/* CCK Power Offset for Rate 2M */
+	u8 cckpo_55M:4;		/* CCK Power Offset for Rate 5.5M */
+	u8 cckpo_11M:4;		/* CCK Power Offset for Rate 11M */
+	u32 ofdmgpo;		/* G-PHY OFDM Power Offset */
+};
+
+struct ssb_sprom_r4 {
+	/* TODO */
+};
+
+struct ssb_sprom {
+	u8 revision;
+	u8 crc;
+	/* The valid r# fields are selected by the "revision".
+	 * Revision 3 and lower inherit from lower revisions.
+	 */
+	union {
+		struct {
+			struct ssb_sprom_r1 r1;
+			struct ssb_sprom_r2 r2;
+			struct ssb_sprom_r3 r3;
+		};
+		struct ssb_sprom_r4 r4;
+	};
+};
+
+/* Information about the PCB the circuitry is soldered on. */
+struct ssb_boardinfo {
+	u16 vendor;
+	u16 type;
+	u16 rev;
+};
+
+
+struct ssb_device;
+/* Lowlevel read/write operations on the device MMIO.
+ * Internal, don't use that outside of ssb. */
+struct ssb_bus_ops {
+	u16 (*read16)(struct ssb_device *dev, u16 offset);
+	u32 (*read32)(struct ssb_device *dev, u16 offset);
+	void (*write16)(struct ssb_device *dev, u16 offset, u16 value);
+	void (*write32)(struct ssb_device *dev, u16 offset, u32 value);
+};
+
+
+/* Core-ID values. */
+#define SSB_DEV_CHIPCOMMON	0x800
+#define SSB_DEV_ILINE20		0x801
+#define SSB_DEV_SDRAM		0x803
+#define SSB_DEV_PCI		0x804
+#define SSB_DEV_MIPS		0x805
+#define SSB_DEV_ETHERNET	0x806
+#define SSB_DEV_V90		0x807
+#define SSB_DEV_USB11_HOSTDEV	0x808
+#define SSB_DEV_ADSL		0x809
+#define SSB_DEV_ILINE100	0x80A
+#define SSB_DEV_IPSEC		0x80B
+#define SSB_DEV_PCMCIA		0x80D
+#define SSB_DEV_INTERNAL_MEM	0x80E
+#define SSB_DEV_MEMC_SDRAM	0x80F
+#define SSB_DEV_EXTIF		0x811
+#define SSB_DEV_80211		0x812
+#define SSB_DEV_MIPS_3302	0x816
+#define SSB_DEV_USB11_HOST	0x817
+#define SSB_DEV_USB11_DEV	0x818
+#define SSB_DEV_USB20_HOST	0x819
+#define SSB_DEV_USB20_DEV	0x81A
+#define SSB_DEV_SDIO_HOST	0x81B
+#define SSB_DEV_ROBOSWITCH	0x81C
+#define SSB_DEV_PARA_ATA	0x81D
+#define SSB_DEV_SATA_XORDMA	0x81E
+#define SSB_DEV_ETHERNET_GBIT	0x81F
+#define SSB_DEV_PCIE		0x820
+#define SSB_DEV_MIMO_PHY	0x821
+#define SSB_DEV_SRAM_CTRLR	0x822
+#define SSB_DEV_MINI_MACPHY	0x823
+#define SSB_DEV_ARM_1176	0x824
+#define SSB_DEV_ARM_7TDMI	0x825
+
+/* Vendor-ID values */
+#define SSB_VENDOR_BROADCOM	0x4243
+
+struct ssb_device_id {
+	u16 vendor;
+	u16 coreid;
+	u8 revision;
+};
+#define SSB_DEVICE(_vendor, _coreid, _revision)  \
+	{ .vendor = _vendor, .coreid = _coreid, .revision = _revision, }
+#define SSB_DEVTABLE_END  \
+	{ 0, },
+
+#define SSB_ANY_VENDOR		0xFFFF
+#define SSB_ANY_ID		0xFFFF
+#define SSB_ANY_REV		0xFF
+
+/* Some kernel subsystems poke with dev->drvdata, so we must use the
+ * following ugly workaround to get from struct device to struct ssb_device */
+struct __ssb_dev_wrapper {
+	struct device dev;
+	struct ssb_device *sdev;
+};
+
+struct ssb_device {
+	/* Having a copy of the ops pointer in each dev struct
+	 * is an optimization. */
+	const struct ssb_bus_ops *ops;
+
+	struct device *dev;
+	struct ssb_bus *bus;
+	struct ssb_device_id id;
+
+	u8 core_index;
+	unsigned int irq;
+
+	/* Internal-only stuff follows. */
+	void *drvdata;		/* Per-device data */
+	void *devtypedata;	/* Per-devicetype (eg 802.11) data */
+};
+
+/* Go from struct device to struct ssb_device. */
+static inline
+struct ssb_device * dev_to_ssb_dev(struct device *dev)
+{
+	struct __ssb_dev_wrapper *wrap;
+	wrap = container_of(dev, struct __ssb_dev_wrapper, dev);
+	return wrap->sdev;
+}
+
+/* Device specific user data */
+static inline
+void ssb_set_drvdata(struct ssb_device *dev, void *data)
+{
+	dev->drvdata = data;
+}
+static inline
+void * ssb_get_drvdata(struct ssb_device *dev)
+{
+	return dev->drvdata;
+}
+
+/* Devicetype specific user data. This is per device-type (not per device) */
+void ssb_set_devtypedata(struct ssb_device *dev, void *data);
+static inline
+void * ssb_get_devtypedata(struct ssb_device *dev)
+{
+	return dev->devtypedata;
+}
+
+
+struct ssb_driver {
+	const char *name;
+	const struct ssb_device_id *id_table;
+
+	int (*probe)(struct ssb_device *dev, const struct ssb_device_id *id);
+	void (*remove)(struct ssb_device *dev);
+	int (*suspend)(struct ssb_device *dev, pm_message_t state);
+	int (*resume)(struct ssb_device *dev);
+	void (*shutdown)(struct ssb_device *dev);
+
+	struct device_driver drv;
+};
+#define drv_to_ssb_drv(_drv) container_of(_drv, struct ssb_driver, drv)
+
+extern int __ssb_driver_register(struct ssb_driver *drv, struct module *owner);
+static inline int ssb_driver_register(struct ssb_driver *drv)
+{
+	return __ssb_driver_register(drv, THIS_MODULE);
+}
+extern void ssb_driver_unregister(struct ssb_driver *drv);
+
+
+
+
+enum ssb_bustype {
+	SSB_BUSTYPE_SSB,	/* This SSB bus is the system bus */
+	SSB_BUSTYPE_PCI,	/* SSB is connected to PCI bus */
+	SSB_BUSTYPE_PCMCIA,	/* SSB is connected to PCMCIA bus */
+};
+
+/* board_vendor */
+#define SSB_BOARDVENDOR_BCM	0x14E4	/* Broadcom */
+#define SSB_BOARDVENDOR_DELL	0x1028	/* Dell */
+#define SSB_BOARDVENDOR_HP	0x0E11	/* HP */
+/* board_type */
+#define SSB_BOARD_BCM94306MP	0x0418
+#define SSB_BOARD_BCM4309G	0x0421
+#define SSB_BOARD_BCM4306CB	0x0417
+#define SSB_BOARD_BCM4309MP	0x040C
+#define SSB_BOARD_MP4318	0x044A
+#define SSB_BOARD_BU4306	0x0416
+#define SSB_BOARD_BU4309	0x040A
+/* chip_package */
+#define SSB_CHIPPACK_BCM4712S	1	/* Small 200pin 4712 */
+#define SSB_CHIPPACK_BCM4712M	2	/* Medium 225pin 4712 */
+#define SSB_CHIPPACK_BCM4712L	0	/* Large 340pin 4712 */
+
+#include <linux/ssb/ssb_driver_chipcommon.h>
+#include <linux/ssb/ssb_driver_mips.h>
+#include <linux/ssb/ssb_driver_extif.h>
+#include <linux/ssb/ssb_driver_pci.h>
+
+struct ssb_bus {
+	/* The MMIO area. */
+	void __iomem *mmio;
+
+	const struct ssb_bus_ops *ops;
+
+	/* The core in the basic address register window. (PCI bus only) */
+	struct ssb_device *mapped_device;
+	/* Currently mapped PCMCIA segment. (bustype == SSB_BUSTYPE_PCMCIA only) */
+	u8 mapped_pcmcia_seg;
+	/* Lock for core and segment switching. */
+	spinlock_t bar_lock;
+
+	/* The bus this backplane is running on. */
+	enum ssb_bustype bustype;
+	/* Pointer to the PCI bus (only valid if bustype == SSB_BUSTYPE_PCI). */
+	struct pci_dev *host_pci;
+	/* Pointer to the PCMCIA device (only if bustype == SSB_BUSTYPE_PCMCIA). */
+	struct pcmcia_device *host_pcmcia;
+
+#ifdef CONFIG_SSB_PCIHOST
+	/* Mutex to protect the SPROM writing. */
+	struct mutex pci_sprom_mutex;
+#endif
+
+	/* ID information about the Chip. */
+	u16 chip_id;
+	u16 chip_rev;
+	u8 chip_package;
+
+	/* List of devices (cores) on the backplane. */
+	struct ssb_device devices[SSB_MAX_NR_CORES];
+	u8 nr_devices;
+
+	/* Reference count. Number of suspended devices. */
+	u8 suspend_cnt;
+
+	/* Software ID number for this bus. */
+	unsigned int busnumber;
+
+	/* The ChipCommon device (if available). */
+	struct ssb_chipcommon chipco;
+	/* The PCI-core device (if available). */
+	struct ssb_pcicore pcicore;
+	/* The MIPS-core device (if available). */
+	struct ssb_mipscore mipscore;
+	/* The EXTif-core device (if available). */
+	struct ssb_extif extif;
+
+	/* The following structure elements are not available in early
+	 * SSB initialization. Though, they are available for regular
+	 * registered drivers at any stage. So be careful when
+	 * using them in the ssb core code. */
+
+	/* ID information about the PCB. */
+	struct ssb_boardinfo boardinfo;
+	/* Contents of the SPROM. */
+	struct ssb_sprom sprom;
+
+	/* Internal. */
+	struct list_head list;
+};
+
+/* The initialization-invariants. */
+struct ssb_init_invariants {
+	struct ssb_boardinfo boardinfo;
+	struct ssb_sprom sprom;
+};
+/* Type of function to fetch the invariants. */
+typedef int (*ssb_invariants_func_t)(struct ssb_bus *bus,
+				     struct ssb_init_invariants *iv);
+
+/* Register a SSB system bus. get_invariants() is called after the
+ * basic system devices are initialized.
+ * The invariants are usually fetched from some NVRAM.
+ * Put the invariants into the struct pointed to by iv. */
+extern int ssb_bus_ssbbus_register(struct ssb_bus *bus,
+				   unsigned long baseaddr,
+				   ssb_invariants_func_t get_invariants);
+#ifdef CONFIG_SSB_PCIHOST
+extern int ssb_bus_pcibus_register(struct ssb_bus *bus,
+				   struct pci_dev *host_pci);
+#endif /* CONFIG_SSB_PCIHOST */
+#ifdef CONFIG_SSB_PCMCIAHOST
+extern int ssb_bus_pcmciabus_register(struct ssb_bus *bus,
+				      struct pcmcia_device *pcmcia_dev,
+				      unsigned long baseaddr);
+#endif /* CONFIG_SSB_PCMCIAHOST */
+
+extern void ssb_bus_unregister(struct ssb_bus *bus);
+
+extern u32 ssb_clockspeed(struct ssb_bus *bus);
+
+/* Is the device enabled in hardware? */
+int ssb_device_is_enabled(struct ssb_device *dev);
+/* Enable a device and pass device-specific SSB_TMSLOW flags.
+ * If no device-specific flags are available, use 0. */
+void ssb_device_enable(struct ssb_device *dev, u32 core_specific_flags);
+/* Disable a device in hardware and pass SSB_TMSLOW flags (if any). */
+void ssb_device_disable(struct ssb_device *dev, u32 core_specific_flags);
+
+
+/* Device MMIO register read/write functions. */
+static inline u16 ssb_read16(struct ssb_device *dev, u16 offset)
+{
+	return dev->ops->read16(dev, offset);
+}
+static inline u32 ssb_read32(struct ssb_device *dev, u16 offset)
+{
+	return dev->ops->read32(dev, offset);
+}
+static inline void ssb_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	dev->ops->write16(dev, offset, value);
+}
+static inline void ssb_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	dev->ops->write32(dev, offset, value);
+}
+
+
+/* Translation (routing) bits that need to be ORed to DMA
+ * addresses before they are given to a device. */
+extern u32 ssb_dma_translation(struct ssb_device *dev);
+#define SSB_DMA_TRANSLATION_MASK	0xC0000000
+#define SSB_DMA_TRANSLATION_SHIFT	30
+
+extern int ssb_dma_set_mask(struct ssb_device *ssb_dev, u64 mask);
+
+
+#ifdef CONFIG_SSB_PCIHOST
+/* PCI-host wrapper driver */
+extern int ssb_pcihost_register(struct pci_driver *driver);
+static inline void ssb_pcihost_unregister(struct pci_driver *driver)
+{
+	pci_unregister_driver(driver);
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+
+/* If a driver is shutdown or suspended, call this to signal
+ * that the bus may be completely powered down. SSB will decide,
+ * if it's really time to power down the bus, based on if there
+ * are other devices that want to run. */
+extern int ssb_bus_may_powerdown(struct ssb_bus *bus);
+/* Before initializing and enabling a device, call this to power-up the bus.
+ * If you want to allow use of dynamic-power-control, pass the flag.
+ * Otherwise static always-on powercontrol will be used. */
+extern int ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl);
+
+
+/* Various helper functions */
+extern u32 ssb_admatch_base(u32 adm);
+extern u32 ssb_admatch_size(u32 adm);
+
+
+#endif /* LINUX_SSB_H_ */
diff --git a/include/linux/ssb/ssb_regs.h b/include/linux/ssb/ssb_regs.h
new file mode 100644
index 0000000..66751a6
--- /dev/null
+++ b/include/linux/ssb/ssb_regs.h
@@ -0,0 +1,292 @@
+#ifndef LINUX_SSB_REGS_H_
+#define LINUX_SSB_REGS_H_
+
+
+/* SiliconBackplane Address Map.
+ * All regions may not exist on all chips.
+ */
+#define SSB_SDRAM_BASE		0x00000000	/* Physical SDRAM */
+#define SSB_PCI_MEM		0x08000000	/* Host Mode sb2pcitranslation0 (64 MB) */
+#define SSB_PCI_CFG		0x0c000000	/* Host Mode sb2pcitranslation1 (64 MB) */
+#define	SSB_SDRAM_SWAPPED	0x10000000	/* Byteswapped Physical SDRAM */
+#define SSB_ENUM_BASE    	0x18000000	/* Enumeration space base */
+#define	SSB_ENUM_LIMIT		0x18010000	/* Enumeration space limit */
+
+#define	SSB_FLASH2		0x1c000000	/* Flash Region 2 (region 1 shadowed here) */
+#define	SSB_FLASH2_SZ		0x02000000	/* Size of Flash Region 2 */
+
+#define	SSB_EXTIF_BASE		0x1f000000	/* External Interface region base address */
+#define	SSB_FLASH1		0x1fc00000	/* Flash Region 1 */
+#define	SSB_FLASH1_SZ		0x00400000	/* Size of Flash Region 1 */
+
+#define SSB_PCI_DMA		0x40000000	/* Client Mode sb2pcitranslation2 (1 GB) */
+#define SSB_PCI_DMA_SZ		0x40000000	/* Client Mode sb2pcitranslation2 size in bytes */
+#define SSB_PCIE_DMA_L32	0x00000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), low 32 bits */
+#define SSB_PCIE_DMA_H32	0x80000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), high 32 bits */
+#define	SSB_EUART		(SSB_EXTIF_BASE + 0x00800000)
+#define	SSB_LED			(SSB_EXTIF_BASE + 0x00900000)
+
+
+/* Enumeration space constants */
+#define SSB_CORE_SIZE		0x1000	/* Size of a core MMIO area */
+#define SSB_MAX_NR_CORES	((SSB_ENUM_LIMIT - SSB_ENUM_BASE) / SSB_CORE_SIZE)
+
+
+/* mips address */
+#define	SSB_EJTAG		0xff200000	/* MIPS EJTAG space (2M) */
+
+
+/* SSB PCI config space registers. */
+#define SSB_PMCSR		0x44
+#define  SSB_PE			0x100
+#define	SSB_BAR0_WIN		0x80	/* Backplane address space 0 */
+#define	SSB_BAR1_WIN		0x84	/* Backplane address space 1 */
+#define	SSB_SPROMCTL		0x88	/* SPROM control */
+#define  SSB_SPROMCTL_WE	0x10	/* SPROM write enable */
+#define	SSB_BAR1_CONTROL	0x8c	/* Address space 1 burst control */
+#define SSB_PCI_IRQS		0x90	/* PCI interrupts */
+#define SSB_PCI_IRQMASK		0x94	/* PCI IRQ control and mask (pcirev >= 6 only) */
+#define SSB_BACKPLANE_IRQS	0x98	/* Backplane Interrupts */
+#define SSB_GPIO_IN		0xB0	/* GPIO Input (pcirev >= 3 only) */
+#define SSB_GPIO_OUT		0xB4	/* GPIO Output (pcirev >= 3 only) */
+#define SSB_GPIO_OUT_ENABLE	0xB8	/* GPIO Output Enable/Disable (pcirev >= 3 only) */
+#define  SSB_GPIO_SCS		0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
+#define  SSB_GPIO_HWRAD		0x20	/* PCI config space GPIO 13 for hw radio disable */
+#define  SSB_GPIO_XTAL		0x40	/* PCI config space GPIO 14 for Xtal powerup */
+#define  SSB_GPIO_PLL		0x80	/* PCI config space GPIO 15 for PLL powerdown */
+
+
+#define SSB_BAR0_MAX_RETRIES	50
+
+/* Silicon backplane configuration register definitions */
+#define SSB_IPSFLAG		0x0F08
+#define	 SSB_IPSFLAG_IRQ1	0x0000003F /* which sbflags get routed to mips interrupt 1 */
+#define	 SSB_IPSFLAG_IRQ1_SHIFT	0
+#define	 SSB_IPSFLAG_IRQ2	0x00003F00 /* which sbflags get routed to mips interrupt 2 */
+#define	 SSB_IPSFLAG_IRQ2_SHIFT	8
+#define	 SSB_IPSFLAG_IRQ3	0x003F0000 /* which sbflags get routed to mips interrupt 3 */
+#define	 SSB_IPSFLAG_IRQ3_SHIFT	16
+#define	 SSB_IPSFLAG_IRQ4	0x3F000000 /* which sbflags get routed to mips interrupt 4 */
+#define	 SSB_IPSFLAG_IRQ4_SHIFT	24
+#define SSB_TPSFLAG		0x0F18
+#define  SSB_TPSFLAG_BPFLAG	0x0000003F /* Backplane flag # */
+#define  SSB_TPSFLAG_ALWAYSIRQ	0x00000040 /* IRQ is always sent on the Backplane */
+#define SSB_TMERRLOGA		0x0F48
+#define SSB_TMERRLOG		0x0F50
+#define SSB_ADMATCH3		0x0F60
+#define SSB_ADMATCH2		0x0F68
+#define SSB_ADMATCH1		0x0F70
+#define SSB_IMSTATE		0x0F90     /* SB Initiator Agent State */
+#define  SSB_IMSTATE_PC		0x0000000f /* Pipe Count */
+#define  SSB_IMSTATE_AP_MASK	0x00000030 /* Arbitration Priority */
+#define  SSB_IMSTATE_AP_BOTH	0x00000000 /* Use both timeslices and token */
+#define  SSB_IMSTATE_AP_TS	0x00000010 /* Use timeslices only */
+#define  SSB_IMSTATE_AP_TK	0x00000020 /* Use token only */
+#define  SSB_IMSTATE_AP_RSV	0x00000030 /* Reserved */
+#define  SSB_IMSTATE_IBE	0x00020000 /* In Band Error */
+#define  SSB_IMSTATE_TO		0x00040000 /* Timeout */
+#define SSB_INTVEC		0x0F94     /* SB Interrupt Mask */
+#define  SSB_INTVEC_PCI		0x00000001 /* Enable interrupts for PCI */
+#define  SSB_INTVEC_ENET0	0x00000002 /* Enable interrupts for enet 0 */
+#define  SSB_INTVEC_ILINE20	0x00000004 /* Enable interrupts for iline20 */
+#define  SSB_INTVEC_CODEC	0x00000008 /* Enable interrupts for v90 codec */
+#define  SSB_INTVEC_USB		0x00000010 /* Enable interrupts for usb */
+#define  SSB_INTVEC_EXTIF	0x00000020 /* Enable interrupts for external i/f */
+#define  SSB_INTVEC_ENET1	0x00000040 /* Enable interrupts for enet 1 */
+#define SSB_TMSLOW		0x0F98     /* SB Target State Low */
+#define  SSB_TMSLOW_RESET	0x00000001 /* Reset */
+#define  SSB_TMSLOW_REJECT_22	0x00000002 /* Reject (Backplane rev 2.2) */
+#define  SSB_TMSLOW_REJECT_23	0x00000004 /* Reject (Backplane rev 2.3) */
+#define  SSB_TMSLOW_CLOCK	0x00010000 /* Clock Enable */
+#define  SSB_TMSLOW_FGC		0x00020000 /* Force Gated Clocks On */
+#define  SSB_TMSLOW_PE		0x40000000 /* Power Management Enable */
+#define  SSB_TMSLOW_BE		0x80000000 /* BIST Enable */
+#define SSB_TMSHIGH		0x0F9C     /* SB Target State High */
+#define  SSB_TMSHIGH_SERR	0x00000001 /* S-error */
+#define  SSB_TMSHIGH_INT	0x00000002 /* Interrupt */
+#define  SSB_TMSHIGH_BUSY	0x00000004 /* Busy */
+#define  SSB_TMSHIGH_TO		0x00000020 /* Timeout. Backplane rev >= 2.3 only */
+#define  SSB_TMSHIGH_COREFL	0x1FFF0000 /* Core specific flags */
+#define  SSB_TMSHIGH_COREFL_SHIFT	16
+#define  SSB_TMSHIGH_DMA64	0x10000000 /* 64bit DMA supported */
+#define  SSB_TMSHIGH_GCR	0x20000000 /* Gated Clock Request */
+#define  SSB_TMSHIGH_BISTF	0x40000000 /* BIST Failed */
+#define  SSB_TMSHIGH_BISTD	0x80000000 /* BIST Done */
+#define SSB_BWA0		0x0FA0
+#define SSB_IMCFGLO		0x0FA8
+#define  SSB_IMCFGLO_SERTO	0x00000007 /* Service timeout */
+#define  SSB_IMCFGLO_REQTO	0x00000070 /* Request timeout */
+#define  SSB_IMCFGLO_REQTO_SHIFT	4
+#define  SSB_IMCFGLO_CONNID	0x00FF0000 /* Connection ID */
+#define  SSB_IMCFGLO_CONNID_SHIFT	16
+#define SSB_IMCFGHI		0x0FAC
+#define SSB_ADMATCH0		0x0FB0
+#define SSB_TMCFGLO		0x0FB8
+#define SSB_TMCFGHI		0x0FBC
+#define SSB_BCONFIG		0x0FC0
+#define SSB_BSTATE		0x0FC8
+#define SSB_ACTCFG		0x0FD8
+#define SSB_FLAGST		0x0FE8
+#define SSB_IDLOW		0x0FF8
+#define  SSB_IDLOW_CFGSP	0x00000003 /* Config Space */
+#define  SSB_IDLOW_ADDRNGE	0x00000038 /* Address Ranges supported */
+#define  SSB_IDLOW_ADDRNGE_SHIFT	3
+#define  SSB_IDLOW_SYNC		0x00000040
+#define  SSB_IDLOW_INITIATOR	0x00000080
+#define  SSB_IDLOW_MIBL		0x00000F00 /* Minimum Backplane latency */
+#define  SSB_IDLOW_MIBL_SHIFT	8
+#define  SSB_IDLOW_MABL		0x0000F000 /* Maximum Backplane latency */
+#define  SSB_IDLOW_MABL_SHIFT	12
+#define  SSB_IDLOW_TIF		0x00010000 /* This Initiator is first */
+#define  SSB_IDLOW_CCW		0x000C0000 /* Cycle counter width */
+#define  SSB_IDLOW_CCW_SHIFT	18
+#define  SSB_IDLOW_TPT		0x00F00000 /* Target ports */
+#define  SSB_IDLOW_TPT_SHIFT	20
+#define  SSB_IDLOW_INITP	0x0F000000 /* Initiator ports */
+#define  SSB_IDLOW_INITP_SHIFT	24
+#define  SSB_IDLOW_SSBREV	0xF0000000 /* Sonics Backplane Revision code */
+#define  SSB_IDLOW_SSBREV_22	0x00000000 /* <= 2.2 */
+#define  SSB_IDLOW_SSBREV_23	0x10000000 /* 2.3 */
+#define SSB_IDHIGH		0x0FFC     /* SB Identification High */
+#define  SSB_IDHIGH_RCLO	0x0000000F /* Revision Code (low part) */
+#define  SSB_IDHIGH_CC		0x00008FF0 /* Core Code */
+#define  SSB_IDHIGH_CC_SHIFT	4
+#define  SSB_IDHIGH_RCHI	0x00007000 /* Revision Code (high part) */
+#define  SSB_IDHIGH_RCHI_SHIFT	8	   /* yes, shift 8 is right */
+#define  SSB_IDHIGH_VC		0xFFFF0000 /* Vendor Code */
+#define  SSB_IDHIGH_VC_SHIFT	16
+
+/* SPROM shadow area. If not otherwise noted, fields are
+ * two bytes wide. Note that the SPROM can _only_ be read
+ * in two-byte quantinies.
+ */
+#define SSB_SPROMSIZE_WORDS		64
+#define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
+#define SSB_SPROM_BASE			0x1000
+#define SSB_SPROM_REVISION		0x107E
+#define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
+#define  SSB_SPROM_REVISION_CRC		0xFF00	/* SPROM CRC8 value */
+#define  SSB_SPROM_REVISION_CRC_SHIFT	8
+/* SPROM Revision 1 */
+#define SSB_SPROM1_SPID			0x1004	/* Subsystem Product ID for PCI */
+#define SSB_SPROM1_SVID			0x1006	/* Subsystem Vendor ID for PCI */
+#define SSB_SPROM1_PID			0x1008	/* Product ID for PCI */
+#define SSB_SPROM1_IL0MAC		0x1048	/* 6 bytes MAC address for 802.11b/g */
+#define SSB_SPROM1_ET0MAC		0x104E	/* 6 bytes MAC address for Ethernet */
+#define SSB_SPROM1_ET1MAC		0x1054	/* 6 bytes MAC address for 802.11a */
+#define SSB_SPROM1_ETHPHY		0x105A	/* Ethernet PHY settings */
+#define  SSB_SPROM1_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
+#define  SSB_SPROM1_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
+#define  SSB_SPROM1_ETHPHY_ET1A_SHIFT	5
+#define  SSB_SPROM1_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
+#define  SSB_SPROM1_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
+#define SSB_SPROM1_BINF			0x105C	/* Board info */
+#define  SSB_SPROM1_BINF_BREV		0x00FF	/* Board Revision */
+#define  SSB_SPROM1_BINF_CCODE		0x0F00	/* Country Code */
+#define  SSB_SPROM1_BINF_CCODE_SHIFT	8
+#define  SSB_SPROM1_BINF_ANTA		0x3000	/* Available A-PHY antennas */
+#define  SSB_SPROM1_BINF_ANTA_SHIFT	12
+#define  SSB_SPROM1_BINF_ANTBG		0xC000	/* Available B-PHY antennas */
+#define  SSB_SPROM1_BINF_ANTBG_SHIFT	14
+#define SSB_SPROM1_PA0B0		0x105E
+#define SSB_SPROM1_PA0B1		0x1060
+#define SSB_SPROM1_PA0B2		0x1062
+#define SSB_SPROM1_GPIOA		0x1064	/* General Purpose IO pins 0 and 1 */
+#define  SSB_SPROM1_GPIOA_P0		0x00FF	/* Pin 0 */
+#define  SSB_SPROM1_GPIOA_P1		0xFF00	/* Pin 1 */
+#define  SSB_SPROM1_GPIOA_P1_SHIFT	8
+#define SSB_SPROM1_GPIOB		0x1066	/* General Purpuse IO pins 2 and 3 */
+#define  SSB_SPROM1_GPIOB_P2		0x00FF	/* Pin 2 */
+#define  SSB_SPROM1_GPIOB_P3		0xFF00	/* Pin 3 */
+#define  SSB_SPROM1_GPIOB_P3_SHIFT	8
+#define SSB_SPROM1_MAXPWR		0x1068	/* Power Amplifier Max Power */
+#define  SSB_SPROM1_MAXPWR_BG		0x00FF	/* B-PHY and G-PHY (in dBm Q5.2) */
+#define  SSB_SPROM1_MAXPWR_A		0xFF00	/* A-PHY (in dBm Q5.2) */
+#define  SSB_SPROM1_MAXPWR_A_SHIFT	8
+#define SSB_SPROM1_PA1B0		0x106A
+#define SSB_SPROM1_PA1B1		0x106C
+#define SSB_SPROM1_PA1B2		0x106E
+#define SSB_SPROM1_ITSSI		0x1070	/* Idle TSSI Target */
+#define  SSB_SPROM1_ITSSI_BG		0x00FF	/* B-PHY and G-PHY*/
+#define  SSB_SPROM1_ITSSI_A		0xFF00	/* A-PHY */
+#define  SSB_SPROM1_ITSSI_A_SHIFT	8
+#define SSB_SPROM1_BFLLO		0x1072	/* Boardflags (low 16 bits) */
+#define SSB_SPROM1_AGAIN		0x1074	/* Antenna Gain (in dBm Q5.2) */
+#define  SSB_SPROM1_AGAIN_A		0x00FF	/* A-PHY */
+#define  SSB_SPROM1_AGAIN_BG		0xFF00	/* B-PHY and G-PHY */
+#define  SSB_SPROM1_AGAIN_BG_SHIFT	8
+#define SSB_SPROM1_OEM			0x1076	/* 8 bytes OEM string (rev 1 only) */
+/* SPROM Revision 2 (inherits from rev 1) */
+#define SSB_SPROM2_BFLHI		0x1038	/* Boardflags (high 16 bits) */
+#define SSB_SPROM2_MAXP_A		0x103A	/* A-PHY Max Power */
+#define  SSB_SPROM2_MAXP_A_HI		0x00FF	/* Max Power High */
+#define  SSB_SPROM2_MAXP_A_LO		0xFF00	/* Max Power Low */
+#define  SSB_SPROM2_MAXP_A_LO_SHIFT	8
+#define SSB_SPROM2_PA1LOB0		0x103C	/* A-PHY PowerAmplifier Low Settings */
+#define SSB_SPROM2_PA1LOB1		0x103E	/* A-PHY PowerAmplifier Low Settings */
+#define SSB_SPROM2_PA1LOB2		0x1040	/* A-PHY PowerAmplifier Low Settings */
+#define SSB_SPROM2_PA1HIB0		0x1042	/* A-PHY PowerAmplifier High Settings */
+#define SSB_SPROM2_PA1HIB1		0x1044	/* A-PHY PowerAmplifier High Settings */
+#define SSB_SPROM2_PA1HIB2		0x1046	/* A-PHY PowerAmplifier High Settings */
+#define SSB_SPROM2_OPO			0x1078	/* OFDM Power Offset from CCK Level */
+#define  SSB_SPROM2_OPO_VALUE		0x00FF
+#define  SSB_SPROM2_OPO_UNUSED		0xFF00
+#define SSB_SPROM2_CCODE		0x107C	/* Two char Country Code */
+/* SPROM Revision 3 (inherits from rev 2) */
+#define SSB_SPROM3_OFDMAPO		0x102C	/* A-PHY OFDM Mid Power Offset (4 bytes, BigEndian) */
+#define SSB_SPROM3_OFDMALPO		0x1030	/* A-PHY OFDM Low Power Offset (4 bytes, BigEndian) */
+#define SSB_SPROM3_OFDMAHPO		0x1034	/* A-PHY OFDM High Power Offset (4 bytes, BigEndian) */
+#define SSB_SPROM3_GPIOLDC		0x1042	/* GPIO LED Powersave Duty Cycle (4 bytes, BigEndian) */
+#define  SSB_SPROM3_GPIOLDC_OFF		0x0000FF00	/* Off Count */
+#define  SSB_SPROM3_GPIOLDC_OFF_SHIFT	8
+#define  SSB_SPROM3_GPIOLDC_ON		0x00FF0000	/* On Count */
+#define  SSB_SPROM3_GPIOLDC_ON_SHIFT	16
+#define SSB_SPROM3_CCKPO		0x1078	/* CCK Power Offset */
+#define  SSB_SPROM3_CCKPO_1M		0x000F	/* 1M Rate PO */
+#define  SSB_SPROM3_CCKPO_2M		0x00F0	/* 2M Rate PO */
+#define  SSB_SPROM3_CCKPO_2M_SHIFT	4
+#define  SSB_SPROM3_CCKPO_55M		0x0F00	/* 5.5M Rate PO */
+#define  SSB_SPROM3_CCKPO_55M_SHIFT	8
+#define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
+#define  SSB_SPROM3_CCKPO_11M_SHIFT	12
+#define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
+
+/* Values for SSB_SPROM1_BINF_CCODE */
+enum {
+	SSB_SPROM1CCODE_WORLD = 0,
+	SSB_SPROM1CCODE_THAILAND,
+	SSB_SPROM1CCODE_ISRAEL,
+	SSB_SPROM1CCODE_JORDAN,
+	SSB_SPROM1CCODE_CHINA,
+	SSB_SPROM1CCODE_JAPAN,
+	SSB_SPROM1CCODE_USA_CANADA_ANZ,
+	SSB_SPROM1CCODE_EUROPE,
+	SSB_SPROM1CCODE_USA_LOW,
+	SSB_SPROM1CCODE_JAPAN_HIGH,
+	SSB_SPROM1CCODE_ALL,
+	SSB_SPROM1CCODE_NONE,
+};
+
+/* Address-Match values and masks (SSB_ADMATCHxxx) */
+#define SSB_ADM_TYPE			0x00000003	/* Address type */
+#define  SSB_ADM_TYPE0			0
+#define  SSB_ADM_TYPE1			1
+#define  SSB_ADM_TYPE2			2
+#define SSB_ADM_AD64			0x00000004
+#define SSB_ADM_SZ0			0x000000F8	/* Type0 size */
+#define SSB_ADM_SZ0_SHIFT		3
+#define SSB_ADM_SZ1			0x000001F8	/* Type1 size */
+#define SSB_ADM_SZ1_SHIFT		3
+#define SSB_ADM_SZ2			0x000001F8	/* Type2 size */
+#define SSB_ADM_SZ2_SHIFT		3
+#define SSB_ADM_EN			0x00000400	/* Enable */
+#define SSB_ADM_NEG			0x00000800	/* Negative decode */
+#define SSB_ADM_BASE0			0xFFFFFF00	/* Type0 base address */
+#define SSB_ADM_BASE0_SHIFT		8
+#define SSB_ADM_BASE1			0xFFFFF000	/* Type1 base address for the core */
+#define SSB_ADM_BASE1_SHIFT		12
+#define SSB_ADM_BASE2			0xFFFF0000	/* Type2 base address for the core */
+#define SSB_ADM_BASE2_SHIFT		16
+
+
+#endif /* LINUX_SSB_REGS_H_ */
diff --git a/MAINTAINERS b/MAINTAINERS
index 845fbf4..aee5182 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -3298,6 +3347,12 @@
 L:	netdev at vger.kernel.org
 S:	Maintained
 
+SONICS SILICON BACKPLANE DRIVER (SSB)
+P:	Michael Buesch
+M:	mb at bu3sch.de
+L:	netdev at vger.kernel.org
+S:	Maintained
+
 SONY VAIO CONTROL DEVICE DRIVER
 P:	Mattia Dongili
 M:	malattia at linux.it



From Larry.Finger at lwfinger.net  Sat Jul 28 05:36:04 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 27 Jul 2007 22:36:04 -0500
Subject: bcm43xx-mac80211: a fix for the shared interrupt problem
Message-ID: <46aab9a4.pmEWFfaWaaFDLvZd%Larry.Finger@lwfinger.net>

Michael,

I was in the right area with my previous fix to the "irq 11: nobody cared"
message. I think for shared interrupts, skipping out if the status is not
BCM43xx_STAT_STARTED is too severe. I added a message printing out the status
whenever it skipped out, and found many thousands of interrupts with the
status equal to BCM43xx_STAT_INITIALIZED. The patch below makes the necessary
change and modifies a couple of asserts that depend on it.

This patch has been tested on BCM4306 and BCM4318 with shared interrupts,
and BCM4311 without.

Thanks,

Larry
----


Index: wireless-mb/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-mb.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ wireless-mb/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -1374,7 +1374,7 @@ static void bcm43xx_interrupt_tasklet(st
 
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
 
-	assert(bcm43xx_status(dev) == BCM43xx_STAT_STARTED);
+	assert(bcm43xx_status(dev) >= BCM43xx_STAT_INITIALIZED);
 
 	reason = dev->irq_reason;
 	for (i = 0; i < ARRAY_SIZE(dma_reason); i++) {
@@ -1512,7 +1512,7 @@ static irqreturn_t bcm43xx_interrupt_han
 
 	spin_lock(&dev->wl->irq_lock);
 
-	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED)
+	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED)
 		goto out;
 	reason = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
 	if (reason == 0xffffffff) /* shared IRQ */
@@ -1522,7 +1522,7 @@ static irqreturn_t bcm43xx_interrupt_han
 	if (!reason)
 		goto out;
 
-	assert(bcm43xx_status(dev) == BCM43xx_STAT_STARTED);
+	assert(bcm43xx_status(dev) >= BCM43xx_STAT_INITIALIZED);
 
 	dev->dma_reason[0] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA0_REASON)
 			     & 0x0001DC00;


From Larry.Finger at lwfinger.net  Sat Jul 28 12:58:29 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 28 Jul 2007 05:58:29 -0500
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx, uses mac80211
	as MAC layer)
Message-ID: <46AB2155.2010002@lwfinger.net>

The new driver for Broadcom wireless devices is now available for testing. The file is
ftp://lwfinger.dynalias.net/patches/BCM4301_for_2.6.22.patch. As the name implies, it is to be 
applied to the 2.6.22 or 2.6.22.1 source. The ssb driver is included in the patch. To test it, 
follow these steps:

1. Download the file and patch the source. Unfortunately, the current code for mac80211 in 
wireless-2.6 and Linus's tree is not functional with this driver. When we solve this problem and you 
can apply a patch to either of those trees, I'll post that news here.

2. Configure it with 'make xconfig' or 'make menuconfig'. In "Networking/Wireless", select the
mac80211 IEEE80211 networking stack. Deselect the other generic IEEE802.11 stack. Under
Drivers/Network device support/Wireless LAN", select the BCM4301 driver with debugging support.

3. Build and install the kernel and modules. This version uses V3 firmware, the same as
bcm43xx-softmac. Although it is planned that this driver will eventually support only the
802.11b-devices (BCM4301 and BCM4303), it currently supports all 802.11b and 802.11g devices.

Performance of the new driver is better, than bcm43xx. The following transfer results using iperf 
with a server on my LAN are as shown below with the rates given in Mbs with transmitting first and 
receiving second:

Bitrate		BCM4311

1		0.83/8.17
2		1.61/10.4
5.5		3.82/12.6
6		4.28/15.8
9		5.93/16.4
11		6.23/13.3
18		10.1/17.8
24		12.3/17.1
36		15.2/17.5
48		17.2/17.2
54		17.9/17.8

As you can see, performance does not drop off at the highest rates. This is the first time
I have been able to get a reading at 54 Mbs.

I think it might be possible to get this driver into 2.6.23-mm, which would make it possible for it 
to be merged into 2.6.24. If bcm43xx-mac80211 is ready at that time, this driver will be restricted 
to 802.11b devices. If not, it will be pushed as a port of bcm43xx.

PLease report your results - good or bad. In particular, I'm interested in any warnings and/or oops's.

Thanks,

Larry



From Larry.Finger at lwfinger.net  Sat Jul 28 17:07:11 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 28 Jul 2007 10:07:11 -0500
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx, uses mac80211
	as MAC layer)
Message-ID: <46AB5B9F.7030601@lwfinger.net>

This message has a correct URL for the patch.

The new driver for Broadcom wireless devices is now available for testing. The file is
ftp://lwfinger.dynalias.org/patches/BCM4301_for_2.6.22.patch. As the name implies, it is to be
applied to the 2.6.22 or 2.6.22.1 source. The ssb driver is included in the patch. To test it,
follow these steps:

1. Download the file and patch the source. Unfortunately, the current code for mac80211 in
wireless-2.6 and Linus's tree is not functional with this driver. When we solve this problem and you
can apply a patch to either of those trees, I'll post that news here.

2. Configure it with 'make xconfig' or 'make menuconfig'. In "Networking/Wireless", select the
mac80211 IEEE80211 networking stack. Deselect the other generic IEEE802.11 stack. Under
Drivers/Network device support/Wireless LAN", select the BCM4301 driver with debugging support.

3. Build and install the kernel and modules. This version uses V3 firmware, the same as
bcm43xx-softmac. Although it is planned that this driver will eventually support only the
802.11b-devices (BCM4301 and BCM4303), it currently supports all 802.11b and 802.11g devices.

Performance of the new driver is better, than bcm43xx. The following transfer results using iperf
with a server on my LAN are as shown below with the rates given in Mbs with transmitting first and
receiving second:

Bitrate		BCM4311

1		0.83/8.17
2		1.61/10.4
5.5		3.82/12.6
6		4.28/15.8
9		5.93/16.4
11		6.23/13.3
18		10.1/17.8
24		12.3/17.1
36		15.2/17.5
48		17.2/17.2
54		17.9/17.8

As you can see, performance does not drop off at the highest rates. This is the first time
I have been able to get a reading at 54 Mbs.

I think it might be possible to get this driver into 2.6.23-mm, which would make it possible for it
to be merged into 2.6.24. If bcm43xx-mac80211 is ready at that time, this driver will be restricted
to 802.11b devices. If not, it will be pushed as a port of bcm43xx.

PLease report your results - good or bad. In particular, I'm interested in any warnings and/or oops's.

Thanks,

Larry




From mb at bu3sch.de  Sat Jul 28 18:48:02 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 28 Jul 2007 18:48:02 +0200
Subject: bcm43xx-mac80211: a fix for the shared interrupt problem
In-Reply-To: <46aab9a4.pmEWFfaWaaFDLvZd%Larry.Finger@lwfinger.net>
References: <46aab9a4.pmEWFfaWaaFDLvZd%Larry.Finger@lwfinger.net>
Message-ID: <200707281848.02554.mb@bu3sch.de>

On Saturday 28 July 2007 05:36:04 Larry Finger wrote:
> Michael,
> 
> I was in the right area with my previous fix to the "irq 11: nobody cared"
> message. I think for shared interrupts, skipping out if the status is not
> BCM43xx_STAT_STARTED is too severe. I added a message printing out the status
> whenever it skipped out, and found many thousands of interrupts with the
> status equal to BCM43xx_STAT_INITIALIZED. The patch below makes the necessary
> change and modifies a couple of asserts that depend on it.
> 
> This patch has been tested on BCM4306 and BCM4318 with shared interrupts,
> and BCM4311 without.
> 
> Thanks,
> 
> Larry
> ----
> 
> 
> Index: wireless-mb/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> ===================================================================
> --- wireless-mb.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ wireless-mb/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -1374,7 +1374,7 @@ static void bcm43xx_interrupt_tasklet(st
>  
>  	spin_lock_irqsave(&dev->wl->irq_lock, flags);
>  
> -	assert(bcm43xx_status(dev) == BCM43xx_STAT_STARTED);
> +	assert(bcm43xx_status(dev) >= BCM43xx_STAT_INITIALIZED);
>  
>  	reason = dev->irq_reason;
>  	for (i = 0; i < ARRAY_SIZE(dma_reason); i++) {
> @@ -1512,7 +1512,7 @@ static irqreturn_t bcm43xx_interrupt_han
>  
>  	spin_lock(&dev->wl->irq_lock);
>  
> -	if (bcm43xx_status(dev) < BCM43xx_STAT_STARTED)
> +	if (bcm43xx_status(dev) < BCM43xx_STAT_INITIALIZED)
>  		goto out;
>  	reason = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
>  	if (reason == 0xffffffff) /* shared IRQ */
> @@ -1522,7 +1522,7 @@ static irqreturn_t bcm43xx_interrupt_han
>  	if (!reason)
>  		goto out;
>  
> -	assert(bcm43xx_status(dev) == BCM43xx_STAT_STARTED);
> +	assert(bcm43xx_status(dev) >= BCM43xx_STAT_INITIALIZED);
>  
>  	dev->dma_reason[0] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA0_REASON)
>  			     & 0x0001DC00;
> 
> 

That's not the right bugfix.
If the interface is not STAT_STARTED, it should _not_ generate IRQs.
The bug is elsewhere in the init routines.
Please find out which IRQ bits are generated for these spurious IRQs.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sat Jul 28 22:53:21 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 28 Jul 2007 15:53:21 -0500
Subject: bcm43xx-mac80211: a fix for the shared interrupt problem
In-Reply-To: <200707281848.02554.mb@bu3sch.de>
References: <46aab9a4.pmEWFfaWaaFDLvZd%Larry.Finger@lwfinger.net>
	<200707281848.02554.mb@bu3sch.de>
Message-ID: <46ABACC1.1020107@lwfinger.net>

Michael Buesch wrote:
> 
> That's not the right bugfix.
> If the interface is not STAT_STARTED, it should _not_ generate IRQs.
> The bug is elsewhere in the init routines.
> Please find out which IRQ bits are generated for these spurious IRQs.
> 

I trapped those entries where the interface was not STAT_STARTED and got 2 such interrupts, each 
with the IRQ bits set to 0x00000001 (READY). They occur between the "30-bit DMA initialized" and the 
"Wireless interface started" messages.

Larry



From mb at bu3sch.de  Sun Jul 29 01:03:49 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 29 Jul 2007 01:03:49 +0200
Subject: bcm43xx-mac80211: a fix for the shared interrupt problem
In-Reply-To: <46ABACC1.1020107@lwfinger.net>
References: <46aab9a4.pmEWFfaWaaFDLvZd%Larry.Finger@lwfinger.net>
	<200707281848.02554.mb@bu3sch.de> <46ABACC1.1020107@lwfinger.net>
Message-ID: <200707290103.50077.mb@bu3sch.de>

On Saturday 28 July 2007 22:53:21 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > That's not the right bugfix.
> > If the interface is not STAT_STARTED, it should _not_ generate IRQs.
> > The bug is elsewhere in the init routines.
> > Please find out which IRQ bits are generated for these spurious IRQs.
> > 
> 
> I trapped those entries where the interface was not STAT_STARTED and got 2 such interrupts, each 
> with the IRQ bits set to 0x00000001 (READY). They occur between the "30-bit DMA initialized" and the 
> "Wireless interface started" messages.

Ok, seems like we are missing some dummy reads to drain
this IRQ. I'll look at this tomorrow.
Thanks for tracking this down.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sun Jul 29 01:58:25 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 28 Jul 2007 18:58:25 -0500
Subject: bcm43xx-mac80211: a fix for the shared interrupt problem
In-Reply-To: <200707290103.50077.mb@bu3sch.de>
References: <46aab9a4.pmEWFfaWaaFDLvZd%Larry.Finger@lwfinger.net>
	<200707281848.02554.mb@bu3sch.de> <46ABACC1.1020107@lwfinger.net>
	<200707290103.50077.mb@bu3sch.de>
Message-ID: <46ABD821.6060709@lwfinger.net>

Michael Buesch wrote:
> 
> Ok, seems like we are missing some dummy reads to drain
> this IRQ. I'll look at this tomorrow.
> Thanks for tracking this down.

As we shouldn't get any interrupts until STAT_STARTED is reached, I wondered why interrupts were 
enabled so early. As far as I can tell, none of the steps from where interrupts are enabled to where 
STAT_STARTED is set depend on having them enabled; therefore, I tried a patch that delayed the 
enabling of interrupts until after we had reached STAT_STARTED. It works for all my systems.

I'm beginning to think that the shared interrupts have nothing to do with the problem, but it is 
more likely caused by peculiarities in the PCMCIA bridge in my ancient laptop.

Larry

Index: wireless-mb/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
===================================================================
--- wireless-mb.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
+++ wireless-mb/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
@@ -3014,13 +3014,13 @@ static int bcm43xx_wireless_core_start(s
  		       dev->dev->irq);
  		goto out;
  	}
-	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
  	bcm43xx_mac_enable(dev);

  	bcm43xx_periodic_tasks_setup(dev);

  	ieee80211_start_queues(dev->wl->hw);
  	bcm43xx_set_status(dev, BCM43xx_STAT_STARTED);
+	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
  	bcmdbg(dev->wl, "Wireless interface started\n");
  out:
  	return err;


From ftoledo at docksud.com.ar  Sun Jul 29 03:50:44 2007
From: ftoledo at docksud.com.ar (Fernando Toledo)
Date: Sat, 28 Jul 2007 22:50:44 -0300
Subject: ad-hoc / master mode support
Message-ID: <200707282250.44141.ftoledo@docksud.com.ar>

Hi , is possible to get a ad-hoc or master mode today?
with softmac o mac80211 trees?
i have a zd1211 device and i need to make a peer to peer link
thanks!

-- 
Dock Sud BBS
http://www.docksud.com.ar
telnet://bbs.docksud.com.ar
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070728/2f0772bf/attachment.pgp>

From mb at bu3sch.de  Sun Jul 29 10:54:12 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 29 Jul 2007 10:54:12 +0200
Subject: bcm43xx-mac80211: a fix for the shared interrupt problem
In-Reply-To: <46ABD821.6060709@lwfinger.net>
References: <46aab9a4.pmEWFfaWaaFDLvZd%Larry.Finger@lwfinger.net>
	<200707290103.50077.mb@bu3sch.de> <46ABD821.6060709@lwfinger.net>
Message-ID: <200707291054.12853.mb@bu3sch.de>

On Sunday 29 July 2007 01:58, Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > Ok, seems like we are missing some dummy reads to drain
> > this IRQ. I'll look at this tomorrow.
> > Thanks for tracking this down.
> 
> As we shouldn't get any interrupts until STAT_STARTED is reached, I wondered why interrupts were 
> enabled so early. As far as I can tell, none of the steps from where interrupts are enabled to where 
> STAT_STARTED is set depend on having them enabled; therefore, I tried a patch that delayed the 
> enabling of interrupts until after we had reached STAT_STARTED. It works for all my systems.
> 
> I'm beginning to think that the shared interrupts have nothing to do with the problem, but it is 
> more likely caused by peculiarities in the PCMCIA bridge in my ancient laptop.
> 
> Larry
> 
> Index: wireless-mb/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> ===================================================================
> --- wireless-mb.orig/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> +++ wireless-mb/drivers/net/wireless/bcm43xx-mac80211/bcm43xx_main.c
> @@ -3014,13 +3014,13 @@ static int bcm43xx_wireless_core_start(s
>   		       dev->dev->irq);
>   		goto out;
>   	}
> -	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
>   	bcm43xx_mac_enable(dev);
> 
>   	bcm43xx_periodic_tasks_setup(dev);
> 
>   	ieee80211_start_queues(dev->wl->hw);
>   	bcm43xx_set_status(dev, BCM43xx_STAT_STARTED);
> +	bcm43xx_interrupt_enable(dev, dev->irq_savedstate);
>   	bcmdbg(dev->wl, "Wireless interface started\n");
>   out:
>   	return err;
> 

Yes, that seems to be the correct fix.
Thanks.


From mb at bu3sch.de  Sun Jul 29 11:12:03 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 29 Jul 2007 11:12:03 +0200
Subject: ad-hoc / master mode support
In-Reply-To: <200707282250.44141.ftoledo@docksud.com.ar>
References: <200707282250.44141.ftoledo@docksud.com.ar>
Message-ID: <200707291112.03788.mb@bu3sch.de>

On Sunday 29 July 2007 03:50, Fernando Toledo wrote:
> Hi , is possible to get a ad-hoc or master mode today?
> with softmac o mac80211 trees?

With mac80211


From mb at bu3sch.de  Sun Jul 29 13:24:54 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 29 Jul 2007 13:24:54 +0200
Subject: [PATCH FINAL] Merge the Sonics Silicon Backplane subsystem
Message-ID: <200707291324.58691.mb@bu3sch.de>

The Sonics Silicon Backplane is a mini-bus used on
various Broadcom chips and embedded devices.
Devices using the SSB include b44, bcm43xx and various
Broadcom based wireless routers.
A b44 and bcm43xx port and a SSB based OHCI driver is available.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Acked-by: John Linville <linville at tuxdriver.com>

--

Andrew, please put this patch into -mm.
This is the final patch to merge ssb, which means future
cleanups and fixes will come incremental based on this one.

Please also schedule this patch for merge into mainline
when the next merge window opens. I'll also send out a
remind mail when that happens.

Please also leave the patch
avoid-ssb-compililation-on-s390.patch
in -mm and also push that to mainline when the merge window opens.

diff --git a/drivers/Makefile b/drivers/Makefile
index a9e4c5f..2b079ed 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -87,3 +87,4 @@ obj-$(CONFIG_DMA_ENGINE)	+= dma/
 obj-$(CONFIG_HID)		+= hid/
 obj-$(CONFIG_PPC_PS3)		+= ps3/
 obj-$(CONFIG_OF)		+= of/
+obj-$(CONFIG_SSB)		+= ssb/
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 3e1c442..7bdae47 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -58,6 +58,8 @@ source "drivers/power/Kconfig"
 
 source "drivers/hwmon/Kconfig"
 
+source "drivers/ssb/Kconfig"
+
 source "drivers/mfd/Kconfig"
 
 source "drivers/media/Kconfig"
diff --git a/drivers/ssb/Makefile b/drivers/ssb/Makefile
new file mode 100644
index 0000000..045aff0
--- /dev/null
+++ b/drivers/ssb/Makefile
@@ -0,0 +1,13 @@
+# core
+ssb-y					+= main.o scan.o
+
+# host support
+ssb-$(CONFIG_SSB_PCIHOST)		+= pci.o pcihost_wrapper.o
+ssb-$(CONFIG_SSB_PCMCIAHOST)		+= pcmcia.o
+
+# built-in drivers
+ssb-y					+= driver_chipcommon.o
+ssb-$(CONFIG_SSB_DRIVER_MIPS)		+= driver_mipscore.o
+ssb-$(CONFIG_SSB_DRIVER_PCICORE)	+= driver_pcicore.o
+
+obj-$(CONFIG_SSB)			+= ssb.o
diff --git a/drivers/ssb/Kconfig b/drivers/ssb/Kconfig
new file mode 100644
index 0000000..34a9411
--- /dev/null
+++ b/drivers/ssb/Kconfig
@@ -0,0 +1,92 @@
+menu "Sonics Silicon Backplane"
+
+config SSB
+	tristate "Sonics Silicon Backplane support"
+	depends on EXPERIMENTAL
+	help
+	  Support for the Sonics Silicon Backplane bus
+
+	  The module will be called ssb
+
+	  If unsure, say M
+
+config SSB_PCIHOST
+	bool "Support for SSB on PCI-bus host"
+	depends on SSB && PCI
+	default y
+	help
+	  Support for a Sonics Silicon Backplane on top
+	  of a PCI device.
+
+	  If unsure, say Y
+
+config SSB_PCMCIAHOST
+	bool "Support for SSB on PCMCIA-bus host"
+	depends on SSB && PCMCIA
+	help
+	  Support for a Sonics Silicon Backplane on top
+	  of a PCMCIA device.
+
+	  If unsure, say N
+
+config SSB_SILENT
+	bool "No SSB kernel messages"
+	depends on SSB
+	help
+	  This option turns off all Sonics Silicon Backplane printks.
+	  Note that you won't be able to identify problems, once
+	  messages are turned off.
+	  This might only be desired for production kernels on
+	  embedded devices to reduce the kernel size.
+
+	  Say N
+
+config SSB_DEBUG
+	bool "SSB debugging"
+	depends on SSB && !SSB_SILENT
+	help
+	  This turns on additional runtime checks and debugging
+	  messages. Turn this on for SSB troubleshooting.
+
+	  If unsure, say N
+
+config SSB_SERIAL
+	bool
+	depends on SSB
+	# ChipCommon and ExtIf serial support routines.
+
+config SSB_DRIVER_PCICORE
+	bool "SSB PCI core driver"
+	depends on SSB && SSB_PCIHOST
+	help
+	  Driver for the Sonics Silicon Backplane attached
+	  Broadcom PCI core.
+
+	  If unsure, say Y
+
+config SSB_PCICORE_HOSTMODE
+	bool "Hostmode support for SSB PCI core"
+	depends on SSB_DRIVER_PCICORE && SSB_DRIVER_MIPS
+	help
+	  PCIcore hostmode operation (external PCI bus).
+
+config SSB_DRIVER_MIPS
+	bool "SSB Broadcom MIPS core driver"
+	depends on SSB && MIPS
+	select SSB_SERIAL
+	help
+	  Driver for the Sonics Silicon Backplane attached
+	  Broadcom MIPS core.
+
+	  If unsure, say N
+
+config SSB_DRIVER_EXTIF
+	bool "SSB Broadcom EXTIF core driver"
+	depends on SSB_DRIVER_MIPS
+	help
+	  Driver for the Sonics Silicon Backplane attached
+	  Broadcom EXTIF core.
+
+	  If unsure, say N
+
+endmenu
diff --git a/drivers/ssb/driver_chipcommon.c b/drivers/ssb/driver_chipcommon.c
new file mode 100644
index 0000000..8e5491c
--- /dev/null
+++ b/drivers/ssb/driver_chipcommon.c
@@ -0,0 +1,394 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom ChipCommon core driver
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+#include <linux/pci.h>
+
+#include "ssb_private.h"
+
+
+/* Clock sources */
+enum ssb_clksrc {
+	/* PCI clock */
+	SSB_CHIPCO_CLKSRC_PCI,
+	/* Crystal slow clock oscillator */
+	SSB_CHIPCO_CLKSRC_XTALOS,
+	/* Low power oscillator */
+	SSB_CHIPCO_CLKSRC_LOPWROS,
+};
+
+
+static inline u32 chipco_read32(struct ssb_chipcommon *cc,
+				u16 offset)
+{
+	return ssb_read32(cc->dev, offset);
+}
+
+static inline void chipco_write32(struct ssb_chipcommon *cc,
+				  u16 offset,
+				  u32 value)
+{
+	ssb_write32(cc->dev, offset, value);
+}
+
+void ssb_chipco_set_clockmode(struct ssb_chipcommon *cc,
+			      enum ssb_clkmode mode)
+{
+	struct ssb_device *ccdev = cc->dev;
+	struct ssb_bus *bus;
+	u32 tmp;
+
+	if (!ccdev)
+		return;
+	bus = ccdev->bus;
+	/* chipcommon cores prior to rev6 don't support dynamic clock control */
+	if (ccdev->id.revision < 6)
+		return;
+	/* chipcommon cores rev10 are a whole new ball game */
+	if (ccdev->id.revision >= 10)
+		return;
+	if (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))
+		return;
+
+	switch (mode) {
+	case SSB_CLKMODE_SLOW:
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp |= SSB_CHIPCO_SLOWCLKCTL_FSLOW;
+		chipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);
+		break;
+	case SSB_CLKMODE_FAST:
+		ssb_pci_xtal(bus, SSB_GPIO_XTAL, 1); /* Force crystal on */
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_FSLOW;
+		tmp |= SSB_CHIPCO_SLOWCLKCTL_IPLL;
+		chipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);
+		break;
+	case SSB_CLKMODE_DYNAMIC:
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_FSLOW;
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_IPLL;
+		tmp &= ~SSB_CHIPCO_SLOWCLKCTL_ENXTAL;
+		if ((tmp & SSB_CHIPCO_SLOWCLKCTL_SRC) != SSB_CHIPCO_SLOWCLKCTL_SRC_XTAL)
+			tmp |= SSB_CHIPCO_SLOWCLKCTL_ENXTAL;
+		chipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);
+
+		/* for dynamic control, we have to release our xtal_pu "force on" */
+		if (tmp & SSB_CHIPCO_SLOWCLKCTL_ENXTAL)
+			ssb_pci_xtal(bus, SSB_GPIO_XTAL, 0);
+		break;
+	default:
+		SSB_WARN_ON(1);
+	}
+}
+
+/* Get the Slow Clock Source */
+static enum ssb_clksrc chipco_pctl_get_slowclksrc(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	u32 uninitialized_var(tmp);
+
+	if (cc->dev->id.revision < 6) {
+		if (bus->bustype == SSB_BUSTYPE_SSB ||
+		    bus->bustype == SSB_BUSTYPE_PCMCIA)
+			return SSB_CHIPCO_CLKSRC_XTALOS;
+		if (bus->bustype == SSB_BUSTYPE_PCI) {
+			pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT, &tmp);
+			if (tmp & 0x10)
+				return SSB_CHIPCO_CLKSRC_PCI;
+			return SSB_CHIPCO_CLKSRC_XTALOS;
+		}
+	}
+	if (cc->dev->id.revision < 10) {
+		tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+		tmp &= 0x7;
+		if (tmp == 0)
+			return SSB_CHIPCO_CLKSRC_LOPWROS;
+		if (tmp == 1)
+			return SSB_CHIPCO_CLKSRC_XTALOS;
+		if (tmp == 2)
+			return SSB_CHIPCO_CLKSRC_PCI;
+	}
+
+	return SSB_CHIPCO_CLKSRC_XTALOS;
+}
+
+/* Get maximum or minimum (depending on get_max flag) slowclock frequency. */
+static int chipco_pctl_clockfreqlimit(struct ssb_chipcommon *cc, int get_max)
+{
+	int uninitialized_var(limit);
+	enum ssb_clksrc clocksrc;
+	int divisor = 1;
+	u32 tmp;
+
+	clocksrc = chipco_pctl_get_slowclksrc(cc);
+	if (cc->dev->id.revision < 6) {
+		switch (clocksrc) {
+		case SSB_CHIPCO_CLKSRC_PCI:
+			divisor = 64;
+			break;
+		case SSB_CHIPCO_CLKSRC_XTALOS:
+			divisor = 32;
+			break;
+		default:
+			SSB_WARN_ON(1);
+		}
+	} else if (cc->dev->id.revision < 10) {
+		switch (clocksrc) {
+		case SSB_CHIPCO_CLKSRC_LOPWROS:
+			break;
+		case SSB_CHIPCO_CLKSRC_XTALOS:
+		case SSB_CHIPCO_CLKSRC_PCI:
+			tmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);
+			divisor = (tmp >> 16) + 1;
+			divisor *= 4;
+			break;
+		}
+	} else {
+		tmp = chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL);
+		divisor = (tmp >> 16) + 1;
+		divisor *= 4;
+	}
+
+	switch (clocksrc) {
+	case SSB_CHIPCO_CLKSRC_LOPWROS:
+		if (get_max)
+			limit = 43000;
+		else
+			limit = 25000;
+		break;
+	case SSB_CHIPCO_CLKSRC_XTALOS:
+		if (get_max)
+			limit = 20200000;
+		else
+			limit = 19800000;
+		break;
+	case SSB_CHIPCO_CLKSRC_PCI:
+		if (get_max)
+			limit = 34000000;
+		else
+			limit = 25000000;
+		break;
+	}
+	limit /= divisor;
+
+	return limit;
+}
+
+static void chipco_powercontrol_init(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+
+	if (bus->chip_id == 0x4321) {
+		if (bus->chip_rev == 0)
+			chipco_write32(cc, SSB_CHIPCO_CHIPCTL, 0x3A4);
+		else if (bus->chip_rev == 1)
+			chipco_write32(cc, SSB_CHIPCO_CHIPCTL, 0xA4);
+	}
+
+	if (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))
+		return;
+
+	if (cc->dev->id.revision >= 10) {
+		/* Set Idle Power clock rate to 1Mhz */
+		chipco_write32(cc, SSB_CHIPCO_SYSCLKCTL,
+			       (chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL) &
+				0x0000FFFF) | 0x00040000);
+	} else {
+		int maxfreq;
+
+		maxfreq = chipco_pctl_clockfreqlimit(cc, 1);
+		chipco_write32(cc, SSB_CHIPCO_PLLONDELAY,
+			       (maxfreq * 150 + 999999) / 1000000);
+		chipco_write32(cc, SSB_CHIPCO_FREFSELDELAY,
+			       (maxfreq * 15 + 999999) / 1000000);
+	}
+}
+
+static void calc_fast_powerup_delay(struct ssb_chipcommon *cc)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	int minfreq;
+	unsigned int tmp;
+	u32 pll_on_delay;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return;
+	if (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))
+		return;
+
+	minfreq = chipco_pctl_clockfreqlimit(cc, 0);
+	pll_on_delay = chipco_read32(cc, SSB_CHIPCO_PLLONDELAY);
+	tmp = (((pll_on_delay + 2) * 1000000) + (minfreq - 1)) / minfreq;
+	SSB_WARN_ON(tmp & ~0xFFFF);
+
+	cc->fast_pwrup_delay = tmp;
+}
+
+void ssb_chipcommon_init(struct ssb_chipcommon *cc)
+{
+	if (!cc->dev)
+		return; /* We don't have a ChipCommon */
+	chipco_powercontrol_init(cc);
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_FAST);
+	calc_fast_powerup_delay(cc);
+}
+
+void ssb_chipco_suspend(struct ssb_chipcommon *cc, pm_message_t state)
+{
+	if (!cc->dev)
+		return;
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_SLOW);
+}
+
+void ssb_chipco_resume(struct ssb_chipcommon *cc)
+{
+	if (!cc->dev)
+		return;
+	chipco_powercontrol_init(cc);
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_FAST);
+}
+
+void ssb_chipco_get_clockcontrol(struct ssb_chipcommon *cc,
+				 u32 *plltype, u32 *n, u32 *m)
+{
+	*n = chipco_read32(cc, SSB_CHIPCO_CLOCK_N);
+	*plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);
+	switch (*plltype) {
+	case SSB_PLLTYPE_6: /* 100/200 or 120/240 only */
+		*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_MIPS);
+		break;
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+		if (cc->dev->bus->chip_id != 0x5365) {
+			*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_M2);
+			break;
+		}
+		/* Fallthough */
+	default:
+		*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_SB);
+	}
+}
+
+void ssb_chipco_timing_init(struct ssb_chipcommon *cc,
+			    unsigned long ns)
+{
+	struct ssb_device *dev = cc->dev;
+	struct ssb_bus *bus = dev->bus;
+	u32 tmp;
+
+	/* set register for external IO to control LED. */
+	chipco_write32(cc, SSB_CHIPCO_PROG_CFG, 0x11);
+	tmp = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;		/* Waitcount-3 = 10ns */
+	tmp |= DIV_ROUND_UP(40, ns) << SSB_PROG_WCNT_1_SHIFT;	/* Waitcount-1 = 40ns */
+	tmp |= DIV_ROUND_UP(240, ns);				/* Waitcount-0 = 240ns */
+	chipco_write32(cc, SSB_CHIPCO_PROG_WAITCNT, tmp);	/* 0x01020a0c for a 100Mhz clock */
+
+	/* Set timing for the flash */
+	tmp = DIV_ROUND_UP(10, ns) << SSB_FLASH_WCNT_3_SHIFT;	/* Waitcount-3 = 10nS */
+	tmp |= DIV_ROUND_UP(10, ns) << SSB_FLASH_WCNT_1_SHIFT;	/* Waitcount-1 = 10nS */
+	tmp |= DIV_ROUND_UP(120, ns);				/* Waitcount-0 = 120nS */
+	if ((bus->chip_id == 0x5365) ||
+	    (dev->id.revision < 9))
+		chipco_write32(cc, SSB_CHIPCO_FLASH_WAITCNT, tmp);
+	if ((bus->chip_id == 0x5365) ||
+	    (dev->id.revision < 9) ||
+	    ((bus->chip_id == 0x5350) && (bus->chip_rev == 0)))
+		chipco_write32(cc, SSB_CHIPCO_PCMCIA_MEMWAIT, tmp);
+
+	if (bus->chip_id == 0x5350) {
+		/* Enable EXTIF */
+		tmp = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;	  /* Waitcount-3 = 10ns */
+		tmp |= DIV_ROUND_UP(20, ns) << SSB_PROG_WCNT_2_SHIFT;  /* Waitcount-2 = 20ns */
+		tmp |= DIV_ROUND_UP(100, ns) << SSB_PROG_WCNT_1_SHIFT; /* Waitcount-1 = 100ns */
+		tmp |= DIV_ROUND_UP(120, ns);			  /* Waitcount-0 = 120ns */
+		chipco_write32(cc, SSB_CHIPCO_PROG_WAITCNT, tmp); /* 0x01020a0c for a 100Mhz clock */
+	}
+}
+
+
+#ifdef CONFIG_SSB_SERIAL
+int ssb_chipco_serial_init(struct ssb_chipcommon *cc,
+			   struct ssb_serial_port *ports)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	int nr_ports = 0;
+	u32 plltype;
+	unsigned int irq;
+	u32 baud_base, div;
+	u32 i, n;
+
+	plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);
+	irq = ssb_mips_irq(cc->dev);
+
+	if (plltype == SSB_PLLTYPE_1) {
+		/* PLL clock */
+		baud_base = ssb_calc_clock_rate(plltype,
+						chipco_read32(cc, SSB_CHIPCO_CLOCK_N),
+						chipco_read32(cc, SSB_CHIPCO_CLOCK_M2));
+		div = 1;
+	} else {
+		if (cc->dev->id.revision >= 11) {
+			/* Fixed ALP clock */
+			baud_base = 20000000;
+			div = 1;
+			/* Set the override bit so we don't divide it */
+			chipco_write32(cc, SSB_CHIPCO_CORECTL,
+				       SSB_CHIPCO_CORECTL_UARTCLK0);
+		} else if (cc->dev->id.revision >= 3) {
+			/* Internal backplane clock */
+			baud_base = ssb_clockspeed(bus);
+			div = 2; /* Minimum divisor */
+			chipco_write32(cc, SSB_CHIPCO_CLKDIV,
+				       (chipco_read32(cc, SSB_CHIPCO_CLKDIV)
+					& ~SSB_CHIPCO_CLKDIV_UART) | div);
+		} else {
+			/* Fixed internal backplane clock */
+			baud_base = 88000000;
+			div = 48;
+		}
+
+		/* Clock source depends on strapping if UartClkOverride is unset */
+		if ((cc->dev->id.revision > 0) &&
+		    !(chipco_read32(cc, SSB_CHIPCO_CORECTL) & SSB_CHIPCO_CORECTL_UARTCLK0)) {
+			if ((cc->capabilities & SSB_CHIPCO_CAP_UARTCLK) ==
+			    SSB_CHIPCO_CAP_UARTCLK_INT) {
+				/* Internal divided backplane clock */
+				baud_base /= div;
+			} else {
+				/* Assume external clock of 1.8432 MHz */
+				baud_base = 1843200;
+			}
+		}
+	}
+
+	/* Determine the registers of the UARTs */
+	n = (cc->capabilities & SSB_CHIPCO_CAP_NRUART);
+	for (i = 0; i < n; i++) {
+		void __iomem *cc_mmio;
+		void __iomem *uart_regs;
+
+		cc_mmio = cc->dev->bus->mmio + (cc->dev->core_index * SSB_CORE_SIZE);
+		uart_regs = cc_mmio + SSB_CHIPCO_UART0_DATA;
+		/* Offset changed at after rev 0 */
+		if (cc->dev->id.revision == 0)
+			uart_regs += (i * 8);
+		else
+			uart_regs += (i * 256);
+
+		nr_ports++;
+		ports[i].regs = uart_regs;
+		ports[i].irq = irq;
+		ports[i].baud_base = baud_base;
+		ports[i].reg_shift = 0;
+	}
+
+	return nr_ports;
+}
+#endif /* CONFIG_SSB_SERIAL */
diff --git a/drivers/ssb/driver_mipscore.c b/drivers/ssb/driver_mipscore.c
new file mode 100644
index 0000000..3f09598
--- /dev/null
+++ b/drivers/ssb/driver_mipscore.c
@@ -0,0 +1,258 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom MIPS core driver
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+#include <linux/time.h>
+
+#include "ssb_private.h"
+
+
+static inline u32 mips_read32(struct ssb_mipscore *mcore,
+			      u16 offset)
+{
+	return ssb_read32(mcore->dev, offset);
+}
+
+static inline void mips_write32(struct ssb_mipscore *mcore,
+				u16 offset,
+				u32 value)
+{
+	ssb_write32(mcore->dev, offset, value);
+}
+
+static const u32 ipsflag_irq_mask[] = {
+	0,
+	SSB_IPSFLAG_IRQ1,
+	SSB_IPSFLAG_IRQ2,
+	SSB_IPSFLAG_IRQ3,
+	SSB_IPSFLAG_IRQ4,
+};
+
+static const u32 ipsflag_irq_shift[] = {
+	0,
+	SSB_IPSFLAG_IRQ1_SHIFT,
+	SSB_IPSFLAG_IRQ2_SHIFT,
+	SSB_IPSFLAG_IRQ3_SHIFT,
+	SSB_IPSFLAG_IRQ4_SHIFT,
+};
+
+static inline u32 ssb_irqflag(struct ssb_device *dev)
+{
+	return ssb_read32(dev, SSB_TPSFLAG) & SSB_TPSFLAG_BPFLAG;
+}
+
+/* Get the MIPS IRQ assignment for a specified device.
+ * If unassigned, 0 is returned.
+ */
+unsigned int ssb_mips_irq(struct ssb_device *dev)
+{
+	struct ssb_bus *bus = dev->bus;
+	u32 irqflag;
+	u32 ipsflag;
+	u32 tmp;
+	unsigned int irq;
+
+	irqflag = ssb_irqflag(dev);
+	ipsflag = ssb_read32(bus->mipscore.dev, SSB_IPSFLAG);
+	for (irq = 1; irq <= 4; irq++) {
+		tmp = ((ipsflag & ipsflag_irq_mask[irq]) >> ipsflag_irq_shift[irq]);
+		if (tmp == irqflag)
+			break;
+	}
+	if (irq	== 5)
+		irq = 0;
+
+	return irq;
+}
+
+static void clear_irq(struct ssb_bus *bus, unsigned int irq)
+{
+	struct ssb_device *dev = bus->mipscore.dev;
+
+	/* Clear the IRQ in the MIPScore backplane registers */
+	if (irq == 0) {
+		ssb_write32(dev, SSB_INTVEC, 0);
+	} else {
+		ssb_write32(dev, SSB_IPSFLAG,
+			    ssb_read32(dev, SSB_IPSFLAG) |
+			    ipsflag_irq_mask[irq]);
+	}
+}
+
+static void set_irq(struct ssb_device *dev, unsigned int irq)
+{
+	unsigned int oldirq = ssb_mips_irq(dev);
+	struct ssb_bus *bus = dev->bus;
+	struct ssb_device *mdev = bus->mipscore.dev;
+	u32 irqflag = ssb_irqflag(dev);
+
+	dev->irq = irq + 2;
+
+	ssb_dprintk(KERN_INFO PFX
+		    "set_irq: core 0x%04x, irq %d => %d\n",
+		    dev->id.coreid, oldirq, irq);
+	/* clear the old irq */
+	if (oldirq == 0)
+		ssb_write32(mdev, SSB_INTVEC, (~(1 << irqflag) & ssb_read32(mdev, SSB_INTVEC)));
+	else
+		clear_irq(bus, oldirq);
+
+	/* assign the new one */
+	if (irq == 0)
+		ssb_write32(mdev, SSB_INTVEC, ((1 << irqflag) & ssb_read32(mdev, SSB_INTVEC)));
+
+	irqflag <<= ipsflag_irq_shift[irq];
+	irqflag |= (ssb_read32(mdev, SSB_IPSFLAG) & ~ipsflag_irq_mask[irq]);
+	ssb_write32(mdev, SSB_IPSFLAG, irqflag);
+}
+
+/* XXX: leave here or move into separate extif driver? */
+static int ssb_extif_serial_init(struct ssb_device *dev, struct ssb_serial_ports *ports)
+{
+
+}
+
+
+static void ssb_mips_serial_init(struct ssb_mipscore *mcore)
+{
+	struct ssb_bus *bus = mcore->dev->bus;
+
+	//TODO if (EXTIF available
+#if 0
+		extifregs_t *eir = (extifregs_t *) regs;
+		sbconfig_t *sb;
+
+		/* Determine external UART register base */
+		sb = (sbconfig_t *)((ulong) eir + SBCONFIGOFF);
+		base = EXTIF_CFGIF_BASE(sb_base(R_REG(&sb->sbadmatch1)));
+
+		/* Determine IRQ */
+		irq = sb_irq(sbh);
+
+		/* Disable GPIO interrupt initially */
+		W_REG(&eir->gpiointpolarity, 0);
+		W_REG(&eir->gpiointmask, 0);
+
+		/* Search for external UARTs */
+		n = 2;
+		for (i = 0; i < 2; i++) {
+			regs = (void *) REG_MAP(base + (i * 8), 8);
+			if (BCMINIT(serial_exists)(regs)) {
+				/* Set GPIO 1 to be the external UART IRQ */
+				W_REG(&eir->gpiointmask, 2);
+				if (add)
+					add(regs, irq, 13500000, 0);
+			}
+		}
+
+		/* Add internal UART if enabled */
+		if (R_REG(&eir->corecontrol) & CC_UE)
+			if (add)
+				add((void *) &eir->uartdata, irq, sb_clock(sbh), 2);
+
+#endif
+	if (bus->extif.dev)
+		mcore->nr_serial_ports = ssb_extif_serial_init(&bus->extif, mcore->serial_ports);
+	else if (bus->chipco.dev)
+		mcore->nr_serial_ports = ssb_chipco_serial_init(&bus->chipco, mcore->serial_ports);
+	else
+		mcore->nr_serial_ports = 0;
+}
+
+static void ssb_mips_flash_detect(struct ssb_mipscore *mcore)
+{
+	struct ssb_bus *bus = mcore->dev->bus;
+
+	if (bus->chipco.dev) {
+		mcore->flash_window = 0x1c000000;
+		mcore->flash_window_size = 0x800000;
+	} else {
+		mcore->flash_window = 0x1fc00000;
+		mcore->flash_window_size = 0x400000;
+	}
+}
+
+
+static void ssb_cpu_clock(struct ssb_mipscore *mcore)
+{
+}
+
+void ssb_mipscore_init(struct ssb_mipscore *mcore)
+{
+	struct ssb_bus *bus = mcore->dev->bus;
+	struct ssb_device *dev;
+	unsigned long hz, ns;
+	unsigned int irq, i;
+
+	if (!mcore->dev)
+		return; /* We don't have a MIPS core */
+
+	ssb_dprintk(KERN_INFO PFX "Initializing MIPS core...\n");
+
+	hz = ssb_clockspeed(bus);
+	if (!hz)
+		hz = 100000000;
+	ns = 1000000000 / hz;
+
+//TODO
+#if 0
+	if (have EXTIF) {
+		/* Initialize extif so we can get to the LEDs and external UART */
+		W_REG(&eir->prog_config, CF_EN);
+
+		/* Set timing for the flash */
+		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
+		tmp = tmp | (CEIL(40, ns) << FW_W1_SHIFT); /* W1 = 40nS */
+		tmp = tmp | CEIL(120, ns);		/* W0 = 120nS */
+		W_REG(&eir->prog_waitcount, tmp);	/* 0x01020a0c for a 100Mhz clock */
+
+		/* Set programmable interface timing for external uart */
+		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
+		tmp = tmp | (CEIL(20, ns) << FW_W2_SHIFT); /* W2 = 20nS */
+		tmp = tmp | (CEIL(100, ns) << FW_W1_SHIFT); /* W1 = 100nS */
+		tmp = tmp | CEIL(120, ns);		/* W0 = 120nS */
+		W_REG(&eir->prog_waitcount, tmp);
+	}
+#endif
+	if (bus->chipco.dev)
+		ssb_chipco_timing_init(&bus->chipco, ns);
+
+	/* Assign IRQs to all cores on the bus, start with irq line 2, because serial usually takes 1 */
+	for (irq = 2, i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		dev->irq = ssb_mips_irq(dev) + 2;
+		switch (dev->id.coreid) {
+		case SSB_DEV_USB11_HOST:
+			/* shouldn't need a separate irq line for non-4710, most of them have a proper
+			 * external usb controller on the pci */
+			if ((bus->chip_id == 0x4710) && (irq <= 4)) {
+				set_irq(dev, irq++);
+				break;
+			}
+			/* fallthrough */
+		case SSB_DEV_PCI:
+		case SSB_DEV_ETHERNET:
+		case SSB_DEV_80211:
+		case SSB_DEV_USB20_HOST:
+			/* These devices get their own IRQ line if available, the rest goes on IRQ0 */
+			if (irq <= 4) {
+				set_irq(dev, irq++);
+				break;
+			}
+		}
+	}
+
+	ssb_mips_serial_init(mcore);
+	ssb_mips_flash_detect(mcore);
+}
diff --git a/drivers/ssb/driver_pcicore.c b/drivers/ssb/driver_pcicore.c
new file mode 100644
index 0000000..e11b103
--- /dev/null
+++ b/drivers/ssb/driver_pcicore.c
@@ -0,0 +1,568 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom PCI-core driver
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include "ssb_private.h"
+
+
+static inline
+u32 pcicore_read32(struct ssb_pcicore *pc, u16 offset)
+{
+	return ssb_read32(pc->dev, offset);
+}
+
+static inline
+void pcicore_write32(struct ssb_pcicore *pc, u16 offset, u32 value)
+{
+	ssb_write32(pc->dev, offset, value);
+}
+
+/**************************************************
+ * Code for hostmode operation.
+ **************************************************/
+
+#ifdef CONFIG_SSB_PCICORE_HOSTMODE
+
+#include <asm/paccess.h>
+/* Probe a 32bit value on the bus and catch bus exceptions.
+ * Returns nonzero on a bus exception.
+ * This is MIPS specific */
+#define mips_busprobe32(val, addr)	get_dbe((val), ((u32 *)(addr)))
+
+/* Assume one-hot slot wiring */
+#define SSB_PCI_SLOT_MAX	16
+
+/* Global lock is OK, as we won't have more than one extpci anyway. */
+static DEFINE_SPINLOCK(cfgspace_lock);
+/* Core to access the external PCI config space. Can only have one. */
+static struct ssb_pcicore *extpci_core;
+
+static u32 ssb_pcicore_pcibus_iobase = 0x100;
+static u32 ssb_pcicore_pcibus_membase = SSB_PCI_DMA;
+
+int pcibios_plat_dev_init(struct pci_dev *d)
+{
+	struct resource *res;
+	int pos, size;
+	u32 *base;
+
+	ssb_printk(KERN_INFO "PCI: Fixing up device %s\n",
+		   pci_name(d));
+
+	/* Fix up resource bases */
+	for (pos = 0; pos < 6; pos++) {
+		res = &d->resource[pos];
+		if (res->flags & IORESOURCE_IO)
+			base = &ssb_pcicore_pcibus_iobase;
+		else
+			base = &ssb_pcicore_pcibus_membase;
+		if (res->end) {
+			size = res->end - res->start + 1;
+			if (*base & (size - 1))
+				*base = (*base + size) & ~(size - 1);
+			res->start = *base;
+			res->end = res->start + size - 1;
+			*base += size;
+			pci_write_config_dword(d, PCI_BASE_ADDRESS_0 + (pos << 2), res->start);
+		}
+		/* Fix up PCI bridge BAR0 only */
+		if (d->bus->number == 0 && PCI_SLOT(d->devfn) == 0)
+			break;
+	}
+	/* Fix up interrupt lines */
+	d->irq = ssb_mips_irq(extpci_core->dev) + 2;
+	pci_write_config_byte(d, PCI_INTERRUPT_LINE, d->irq);
+
+	return 0;
+}
+
+static void __init ssb_fixup_pcibridge(struct pci_dev *dev)
+{
+	if (dev->bus->number != 0 || PCI_SLOT(dev->devfn) != 0)
+		return;
+
+	ssb_printk(KERN_INFO "PCI: fixing up bridge\n");
+
+	/* Enable PCI bridge bus mastering and memory space */
+	pci_set_master(dev);
+	pcibios_enable_device(dev, ~0);
+
+	/* Enable PCI bridge BAR1 prefetch and burst */
+	pci_write_config_dword(dev, SSB_BAR1_CONTROL, 3);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, ssb_fixup_pcibridge);
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return ssb_mips_irq(extpci_core->dev) + 2;
+}
+
+static u32 get_cfgspace_addr(struct ssb_pcicore *pc,
+			     unsigned int bus, unsigned int dev,
+			     unsigned int func, unsigned int off)
+{
+	u32 addr = 0;
+	u32 tmp;
+
+	if (unlikely(pc->cardbusmode && dev > 1))
+		goto out;
+	if (bus == 0) {
+		/* Type 0 transaction */
+		if (unlikely(dev >= SSB_PCI_SLOT_MAX))
+			goto out;
+		/* Slide the window */
+		tmp = SSB_PCICORE_SBTOPCI_CFG0;
+		tmp |= ((1 << (dev + 16)) & SSB_PCICORE_SBTOPCI1_MASK);
+		pcicore_write32(pc, SSB_PCICORE_SBTOPCI1, tmp);
+		/* Calculate the address */
+		addr = SSB_PCI_CFG;
+		addr |= ((1 << (dev + 16)) & ~SSB_PCICORE_SBTOPCI1_MASK);
+		addr |= (func << 8);
+		addr |= (off & ~3);
+	} else {
+		/* Type 1 transaction */
+		pcicore_write32(pc, SSB_PCICORE_SBTOPCI1,
+				SSB_PCICORE_SBTOPCI_CFG1);
+		/* Calculate the address */
+		addr = SSB_PCI_CFG;
+		addr |= (bus << 16);
+		addr |= (dev << 11);
+		addr |= (func << 8);
+		addr |= (off & ~3);
+	}
+out:
+	return addr;
+}
+
+static int ssb_extpci_read_config(struct ssb_pcicore *pc,
+				  unsigned int bus, unsigned int dev,
+				  unsigned int func, unsigned int off,
+				  void *buf, int len)
+{
+	int err = -EINVAL;
+	u32 addr, val;
+	void __iomem *mmio;
+
+	SSB_WARN_ON(!pc->hostmode);
+	if (unlikely(len != 1 && len != 2 && len != 4))
+		goto out;
+	addr = get_cfgspace_addr(pc, bus, dev, func, off);
+	if (unlikely(!addr))
+		goto out;
+	err = -ENOMEM;
+	mmio = ioremap_nocache(addr, len);
+	if (!mmio)
+		goto out;
+
+	if (mips_busprobe32(val, mmio)) {
+		val = 0xffffffff;
+		goto unmap;
+	}
+
+	val = readl(mmio);
+	val >>= (8 * (off & 3));
+
+	switch (len) {
+	case 1:
+		*((u8 *)buf) = (u8)val;
+		break;
+	case 2:
+		*((u16 *)buf) = (u16)val;
+		break;
+	case 4:
+		*((u32 *)buf) = (u32)val;
+		break;
+	}
+	err = 0;
+unmap:
+	iounmap(mmio);
+out:
+	return err;
+}
+
+static int ssb_extpci_write_config(struct ssb_pcicore *pc,
+				   unsigned int bus, unsigned int dev,
+				   unsigned int func, unsigned int off,
+				   const void *buf, int len)
+{
+	int err = -EINVAL;
+	u32 addr, val = 0;
+	void __iomem *mmio;
+
+	SSB_WARN_ON(!pc->hostmode);
+	if (unlikely(len != 1 && len != 2 && len != 4))
+		goto out;
+	addr = get_cfgspace_addr(pc, bus, dev, func, off);
+	if (unlikely(!addr))
+		goto out;
+	err = -ENOMEM;
+	mmio = ioremap_nocache(addr, len);
+	if (!mmio)
+		goto out;
+
+	if (mips_busprobe32(val, mmio)) {
+		val = 0xffffffff;
+		goto unmap;
+	}
+
+	switch (len) {
+	case 1:
+		val = readl(mmio);
+		val &= ~(0xFF << (8 * (off & 3)));
+		val |= *((const u8 *)buf) << (8 * (off & 3));
+		break;
+	case 2:
+		val = readl(mmio);
+		val &= ~(0xFFFF << (8 * (off & 3)));
+		val |= *((const u16 *)buf) << (8 * (off & 3));
+		break;
+	case 4:
+		val = *((const u32 *)buf);
+		break;
+	}
+	writel(*((const u32 *)buf), mmio);
+
+	err = 0;
+unmap:
+	iounmap(mmio);
+out:
+	return err;
+}
+
+static int ssb_pcicore_read_config(struct pci_bus *bus, unsigned int devfn,
+				   int reg, int size, u32 *val)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&cfgspace_lock, flags);
+	err = ssb_extpci_read_config(extpci_core, bus->number, PCI_SLOT(devfn),
+				     PCI_FUNC(devfn), reg, val, size);
+	spin_unlock_irqrestore(&cfgspace_lock, flags);
+
+	return err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+}
+
+static int ssb_pcicore_write_config(struct pci_bus *bus, unsigned int devfn,
+				    int reg, int size, u32 val)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&cfgspace_lock, flags);
+	err = ssb_extpci_write_config(extpci_core, bus->number, PCI_SLOT(devfn),
+				      PCI_FUNC(devfn), reg, &val, size);
+	spin_unlock_irqrestore(&cfgspace_lock, flags);
+
+	return err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops ssb_pcicore_pciops = {
+	.read	= ssb_pcicore_read_config,
+	.write	= ssb_pcicore_write_config,
+};
+
+static struct resource ssb_pcicore_mem_resource = {
+	.name	= "SSB PCIcore external memory",
+	.start	= SSB_PCI_DMA,
+	.end	= SSB_PCI_DMA + SSB_PCI_DMA_SZ - 1,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct resource ssb_pcicore_io_resource = {
+	.name	= "SSB PCIcore external I/O",
+	.start	= 0x100,
+	.end	= 0x7FF,
+	.flags	= IORESOURCE_IO,
+};
+
+static struct pci_controller ssb_pcicore_controller = {
+	.pci_ops	= &ssb_pcicore_pciops,
+	.io_resource	= &ssb_pcicore_io_resource,
+	.mem_resource	= &ssb_pcicore_mem_resource,
+	.mem_offset	= 0x24000000,
+};
+
+static void ssb_pcicore_init_hostmode(struct ssb_pcicore *pc)
+{
+	u32 val;
+
+	if (WARN_ON(extpci_core))
+		return;
+	extpci_core = pc;
+
+	ssb_dprintk(KERN_INFO PFX "PCIcore in host mode found\n");
+	/* Reset devices on the external PCI bus */
+	val = SSB_PCICORE_CTL_RST_OE;
+	val |= SSB_PCICORE_CTL_CLK_OE;
+	pcicore_write32(pc, SSB_PCICORE_CTL, val);
+	val |= SSB_PCICORE_CTL_CLK; /* Clock on */
+	pcicore_write32(pc, SSB_PCICORE_CTL, val);
+	udelay(150); /* Assertion time demanded by the PCI standard */
+	val |= SSB_PCICORE_CTL_RST; /* Deassert RST# */
+	pcicore_write32(pc, SSB_PCICORE_CTL, val);
+	udelay(1); /* Assertion time demanded by the PCI standard */
+
+	/*TODO cardbus mode */
+
+	/* 64MB I/O window */
+	pcicore_write32(pc, SSB_PCICORE_SBTOPCI0,
+			SSB_PCICORE_SBTOPCI_IO);
+	/* 64MB config space */
+	pcicore_write32(pc, SSB_PCICORE_SBTOPCI1,
+			SSB_PCICORE_SBTOPCI_CFG0);
+	/* 1GB memory window */
+	pcicore_write32(pc, SSB_PCICORE_SBTOPCI2,
+			SSB_PCICORE_SBTOPCI_MEM | SSB_PCI_DMA);
+
+	/* Enable PCI bridge BAR0 prefetch and burst */
+	val = PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	ssb_extpci_write_config(pc, 0, 0, 0, PCI_COMMAND, &val, 2);
+	/* Clear error conditions */
+	val = 0;
+	ssb_extpci_write_config(pc, 0, 0, 0, PCI_STATUS, &val, 2);
+
+	/* Enable PCI interrupts */
+	pcicore_write32(pc, SSB_PCICORE_IMASK,
+			SSB_PCICORE_IMASK_INTA);
+
+	/* Ok, ready to run, register it to the system.
+	 * The following needs change, if we want to port hostmode
+	 * to non-MIPS platform. */
+	set_io_port_base((unsigned long)ioremap_nocache(SSB_PCI_MEM, 0x04000000));
+	register_pci_controller(&ssb_pcicore_controller);
+}
+
+static int pcicore_is_in_hostmode(struct ssb_pcicore *pc)
+{
+	struct ssb_bus *bus = pc->dev->bus;
+	u16 chipid_top;
+	u32 tmp;
+
+	chipid_top = (bus->chip_id & 0xFF00);
+	if (chipid_top != 0x4700 &&
+	    chipid_top != 0x5300)
+		return 0;
+
+	if (bus->sprom.r1.boardflags_lo & SSB_PCICORE_BFL_NOPCI)
+		return 0;
+
+	/* The 200-pin BCM4712 package does not bond out PCI. Even when
+	 * PCI is bonded out, some boards may leave the pins floating. */
+	if (bus->chip_id == 0x4712) {
+		if (bus->chip_package == SSB_CHIPPACK_BCM4712S)
+			return 0;
+		if (bus->chip_package == SSB_CHIPPACK_BCM4712M)
+			return 0;
+	}
+	if (bus->chip_id == 0x5350)
+		return 0;
+
+	return !mips_busprobe32(tmp, (bus->mmio + (pc->dev->core_index * SSB_CORE_SIZE)));
+}
+#endif /* CONFIG_SSB_PCICORE_HOSTMODE */
+
+
+/**************************************************
+ * Generic and Clientmode operation code.
+ **************************************************/
+
+static void ssb_pcicore_init_clientmode(struct ssb_pcicore *pc)
+{
+	/* Disable PCI interrupts. */
+	ssb_write32(pc->dev, SSB_INTVEC, 0);
+}
+
+void ssb_pcicore_init(struct ssb_pcicore *pc)
+{
+	struct ssb_device *dev = pc->dev;
+	struct ssb_bus *bus;
+
+	if (!dev)
+		return;
+	bus = dev->bus;
+	if (!ssb_device_is_enabled(dev))
+		ssb_device_enable(dev, 0);
+
+#ifdef CONFIG_SSB_PCICORE_HOSTMODE
+	pc->hostmode = pcicore_is_in_hostmode(pc);
+	if (pc->hostmode)
+		ssb_pcicore_init_hostmode(pc);
+#endif /* CONFIG_SSB_PCICORE_HOSTMODE */
+	if (!pc->hostmode)
+		ssb_pcicore_init_clientmode(pc);
+}
+
+static u32 ssb_pcie_read(struct ssb_pcicore *pc, u32 address)
+{
+	pcicore_write32(pc, 0x130, address);
+	return pcicore_read32(pc, 0x134);
+}
+
+static void ssb_pcie_write(struct ssb_pcicore *pc, u32 address, u32 data)
+{
+	pcicore_write32(pc, 0x130, address);
+	pcicore_write32(pc, 0x134, data);
+}
+
+static void ssb_pcie_mdio_write(struct ssb_pcicore *pc, u8 device,
+				u8 address, u16 data)
+{
+	const u16 mdio_control = 0x128;
+	const u16 mdio_data = 0x12C;
+	u32 v;
+	int i;
+
+	v = 0x80; /* Enable Preamble Sequence */
+	v |= 0x2; /* MDIO Clock Divisor */
+	pcicore_write32(pc, mdio_control, v);
+
+	v = (1 << 30); /* Start of Transaction */
+	v |= (1 << 28); /* Write Transaction */
+	v |= (1 << 17); /* Turnaround */
+	v |= (u32)device << 22;
+	v |= (u32)address << 18;
+	v |= data;
+	pcicore_write32(pc, mdio_data, v);
+	/* Wait for the device to complete the transaction */
+	udelay(10);
+	for (i = 0; i < 10; i++) {
+		v = pcicore_read32(pc, mdio_control);
+		if (v & 0x100 /* Trans complete */)
+			break;
+		msleep(1);
+	}
+	pcicore_write32(pc, mdio_control, 0);
+}
+
+static void ssb_broadcast_value(struct ssb_device *dev,
+				u32 address, u32 data)
+{
+	/* This is used for both, PCI and ChipCommon core, so be careful. */
+	BUILD_BUG_ON(SSB_PCICORE_BCAST_ADDR != SSB_CHIPCO_BCAST_ADDR);
+	BUILD_BUG_ON(SSB_PCICORE_BCAST_DATA != SSB_CHIPCO_BCAST_DATA);
+
+	ssb_write32(dev, SSB_PCICORE_BCAST_ADDR, address);
+	ssb_read32(dev, SSB_PCICORE_BCAST_ADDR); /* flush */
+	ssb_write32(dev, SSB_PCICORE_BCAST_DATA, data);
+	ssb_read32(dev, SSB_PCICORE_BCAST_DATA); /* flush */
+}
+
+static void ssb_commit_settings(struct ssb_bus *bus)
+{
+	struct ssb_device *dev;
+
+	dev = bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev;
+	if (WARN_ON(!dev))
+		return;
+	/* This forces an update of the cached registers. */
+	ssb_broadcast_value(dev, 0xFD8, 0);
+}
+
+int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
+				   struct ssb_device *dev)
+{
+	struct ssb_device *pdev = pc->dev;
+	struct ssb_bus *bus;
+	int err = 0;
+	u32 tmp;
+
+	might_sleep();
+
+	if (!pdev)
+		goto out;
+	bus = pdev->bus;
+
+	/* Enable interrupts for this device. */
+	if (bus->host_pci &&
+	    ((pdev->id.revision >= 6) || (pdev->id.coreid == SSB_DEV_PCIE))) {
+		u32 coremask;
+
+		/* Calculate the "coremask" for the device. */
+		coremask = (1 << dev->core_index);
+
+		err = pci_read_config_dword(bus->host_pci, SSB_PCI_IRQMASK, &tmp);
+		if (err)
+			goto out;
+		tmp |= coremask << 8;
+		err = pci_write_config_dword(bus->host_pci, SSB_PCI_IRQMASK, tmp);
+		if (err)
+			goto out;
+	} else {
+		u32 intvec;
+
+		intvec = ssb_read32(pdev, SSB_INTVEC);
+		if ((bus->chip_id & 0xFF00) == 0x4400) {
+			/* Workaround: On the BCM44XX the BPFLAG routing
+			 * bit is wrong. Use a hardcoded constant. */
+			intvec |= 0x00000002;
+		} else {
+			tmp = ssb_read32(dev, SSB_TPSFLAG);
+			tmp &= SSB_TPSFLAG_BPFLAG;
+			intvec |= tmp;
+		}
+		ssb_write32(pdev, SSB_INTVEC, intvec);
+	}
+
+	/* Setup PCIcore operation. */
+	if (pc->setup_done)
+		goto out;
+	if (pdev->id.coreid == SSB_DEV_PCI) {
+		tmp = pcicore_read32(pc, SSB_PCICORE_SBTOPCI2);
+		tmp |= SSB_PCICORE_SBTOPCI_PREF;
+		tmp |= SSB_PCICORE_SBTOPCI_BURST;
+		pcicore_write32(pc, SSB_PCICORE_SBTOPCI2, tmp);
+
+		if (pdev->id.revision < 5) {
+			tmp = ssb_read32(pdev, SSB_IMCFGLO);
+			tmp &= ~SSB_IMCFGLO_SERTO;
+			tmp |= 2;
+			tmp &= ~SSB_IMCFGLO_REQTO;
+			tmp |= 3 << SSB_IMCFGLO_REQTO_SHIFT;
+			ssb_write32(pdev, SSB_IMCFGLO, tmp);
+			ssb_commit_settings(bus);
+		} else if (pdev->id.revision >= 11) {
+			tmp = pcicore_read32(pc, SSB_PCICORE_SBTOPCI2);
+			tmp |= SSB_PCICORE_SBTOPCI_MRM;
+			pcicore_write32(pc, SSB_PCICORE_SBTOPCI2, tmp);
+		}
+	} else {
+		WARN_ON(pdev->id.coreid != SSB_DEV_PCIE);
+		//TODO: Better make defines for all these magic PCIE values.
+		if ((pdev->id.revision == 0) || (pdev->id.revision == 1)) {
+			/* TLP Workaround register. */
+			tmp = ssb_pcie_read(pc, 0x4);
+			tmp |= 0x8;
+			ssb_pcie_write(pc, 0x4, tmp);
+		}
+		if (pdev->id.revision == 0) {
+			const u8 serdes_rx_device = 0x1F;
+
+			ssb_pcie_mdio_write(pc, serdes_rx_device,
+					    2 /* Timer */, 0x8128);
+			ssb_pcie_mdio_write(pc, serdes_rx_device,
+					    6 /* CDR */, 0x0100);
+			ssb_pcie_mdio_write(pc, serdes_rx_device,
+					    7 /* CDR BW */, 0x1466);
+		} else if (pdev->id.revision == 1) {
+			/* DLLP Link Control register. */
+			tmp = ssb_pcie_read(pc, 0x100);
+			tmp |= 0x40;
+			ssb_pcie_write(pc, 0x100, tmp);
+		}
+	}
+	pc->setup_done = 1;
+out:
+	return err;
+}
+EXPORT_SYMBOL(ssb_pcicore_dev_irqvecs_enable);
diff --git a/drivers/ssb/main.c b/drivers/ssb/main.c
new file mode 100644
index 0000000..cfe090f
--- /dev/null
+++ b/drivers/ssb/main.c
@@ -0,0 +1,1112 @@
+/*
+ * Sonics Silicon Backplane
+ * Subsystem core
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, 2007, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include "ssb_private.h"
+
+#include <linux/delay.h>
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+
+#include <linux/pci.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+
+
+MODULE_DESCRIPTION("Sonics Silicon Backplane driver");
+MODULE_LICENSE("GPL");
+
+
+/* Temporary list of yet-to-be-attached buses */
+static LIST_HEAD(attach_queue);
+/* List if running buses */
+static LIST_HEAD(buses);
+/* Software ID counter */
+static unsigned int next_busnumber;
+/* buses_mutes locks the two buslists and the next_busnumber.
+ * Don't lock this directly, but use ssb_buses_[un]lock() below. */
+static DEFINE_MUTEX(buses_mutex);
+
+/* There are differences in the codeflow, if the bus is
+ * initialized from early boot, as various needed services
+ * are not available early. This is a mechanism to delay
+ * these initializations to after early boot has finished.
+ * It's also used to avoid mutex locking, as that's not
+ * available and needed early. */
+static bool ssb_is_early_boot = 1;
+
+static void ssb_buses_lock(void);
+static void ssb_buses_unlock(void);
+
+
+#ifdef CONFIG_SSB_PCIHOST
+struct ssb_bus *ssb_pci_dev_to_bus(struct pci_dev *pdev)
+{
+	struct ssb_bus *bus;
+
+	ssb_buses_lock();
+	list_for_each_entry(bus, &buses, list) {
+		if (bus->bustype == SSB_BUSTYPE_PCI &&
+		    bus->host_pci == pdev)
+			goto found;
+	}
+	bus = NULL;
+found:
+	ssb_buses_unlock();
+
+	return bus;
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+static struct ssb_device *ssb_device_get(struct ssb_device *dev)
+{
+	if (dev)
+		get_device(dev->dev);
+	return dev;
+}
+
+static void ssb_device_put(struct ssb_device *dev)
+{
+	if (dev)
+		put_device(dev->dev);
+}
+
+static int ssb_bus_resume(struct ssb_bus *bus)
+{
+	int err;
+
+	ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 1);
+	err = ssb_pcmcia_init(bus);
+	if (err) {
+		/* No need to disable XTAL, as we don't have one on PCMCIA. */
+		return err;
+	}
+	ssb_chipco_resume(&bus->chipco);
+
+	return 0;
+}
+
+static int ssb_device_resume(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv;
+	struct ssb_bus *bus;
+	int err = 0;
+
+	bus = ssb_dev->bus;
+	if (bus->suspend_cnt == bus->nr_devices) {
+		err = ssb_bus_resume(bus);
+		if (err)
+			return err;
+	}
+	bus->suspend_cnt--;
+	if (dev->driver) {
+		ssb_drv = drv_to_ssb_drv(dev->driver);
+		if (ssb_drv && ssb_drv->resume)
+			err = ssb_drv->resume(ssb_dev);
+		if (err)
+			goto out;
+	}
+out:
+	return err;
+}
+
+static void ssb_bus_suspend(struct ssb_bus *bus, pm_message_t state)
+{
+	ssb_chipco_suspend(&bus->chipco, state);
+	ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);
+
+	/* Reset HW state information in memory, so that HW is
+	 * completely reinitialized on resume. */
+	bus->mapped_device = NULL;
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+	bus->pcicore.setup_done = 0;
+#endif
+}
+
+static int ssb_device_suspend(struct device *dev, pm_message_t state)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv;
+	struct ssb_bus *bus;
+	int err = 0;
+
+	if (dev->driver) {
+		ssb_drv = drv_to_ssb_drv(dev->driver);
+		if (ssb_drv && ssb_drv->suspend)
+			err = ssb_drv->suspend(ssb_dev, state);
+		if (err)
+			goto out;
+	}
+
+	bus = ssb_dev->bus;
+	bus->suspend_cnt++;
+	if (bus->suspend_cnt == bus->nr_devices) {
+		/* All devices suspended. Shutdown the bus. */
+		ssb_bus_suspend(bus, state);
+	}
+
+out:
+	return err;
+}
+
+#ifdef CONFIG_SSB_PCIHOST
+int ssb_devices_freeze(struct ssb_bus *bus)
+{
+	struct ssb_device *dev;
+	struct ssb_driver *drv;
+	int err = 0;
+	int i;
+	pm_message_t state = PMSG_FREEZE;
+
+	/* First check that we are capable to freeze all devices. */
+	for (i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		if (!drv->suspend) {
+			/* Nope, can't suspend this one. */
+			return -EOPNOTSUPP;
+		}
+	}
+	/* Now suspend all devices */
+	for (i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		err = drv->suspend(dev, state);
+		if (err) {
+			ssb_printk(KERN_ERR PFX "Failed to freeze device %s\n",
+				   dev->dev->bus_id);
+			goto err_unwind;
+		}
+	}
+
+	return 0;
+err_unwind:
+	for (i--; i >= 0; i--) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		if (drv->resume)
+			drv->resume(dev);
+	}
+	return err;
+}
+
+int ssb_devices_thaw(struct ssb_bus *bus)
+{
+	struct ssb_device *dev;
+	struct ssb_driver *drv;
+	int err;
+	int i;
+
+	for (i = 0; i < bus->nr_devices; i++) {
+		dev = &(bus->devices[i]);
+		if (!dev->dev ||
+		    !dev->dev->driver ||
+		    !device_is_registered(dev->dev))
+			continue;
+		drv = drv_to_ssb_drv(dev->dev->driver);
+		if (!drv)
+			continue;
+		if (SSB_WARN_ON(!drv->resume))
+			continue;
+		err = drv->resume(dev);
+		if (err) {
+			ssb_printk(KERN_ERR PFX "Failed to thaw device %s\n",
+				   dev->dev->bus_id);
+		}
+	}
+
+	return 0;
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+static void ssb_device_shutdown(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv;
+
+	if (!dev->driver)
+		return;
+	ssb_drv = drv_to_ssb_drv(dev->driver);
+	if (ssb_drv && ssb_drv->shutdown)
+		ssb_drv->shutdown(ssb_dev);
+}
+
+static int ssb_device_remove(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv = drv_to_ssb_drv(dev->driver);
+
+	if (ssb_drv && ssb_drv->remove)
+		ssb_drv->remove(ssb_dev);
+	ssb_device_put(ssb_dev);
+
+	return 0;
+}
+
+static int ssb_device_probe(struct device *dev)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv = drv_to_ssb_drv(dev->driver);
+	int err = 0;
+
+	ssb_device_get(ssb_dev);
+	if (ssb_drv && ssb_drv->probe)
+		err = ssb_drv->probe(ssb_dev, &ssb_dev->id);
+	if (err)
+		ssb_device_put(ssb_dev);
+
+	return err;
+}
+
+static int ssb_match_devid(const struct ssb_device_id *tabid,
+			   const struct ssb_device_id *devid)
+{
+	if ((tabid->vendor != devid->vendor) &&
+	    tabid->vendor != SSB_ANY_VENDOR)
+		return 0;
+	if ((tabid->coreid != devid->coreid) &&
+	    tabid->coreid != SSB_ANY_ID)
+		return 0;
+	if ((tabid->revision != devid->revision) &&
+	    tabid->revision != SSB_ANY_REV)
+		return 0;
+	return 1;
+}
+
+static int ssb_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	struct ssb_driver *ssb_drv = drv_to_ssb_drv(drv);
+	const struct ssb_device_id *id;
+
+	for (id = ssb_drv->id_table;
+	     id->vendor || id->coreid || id->revision;
+	     id++) {
+		if (ssb_match_devid(id, &ssb_dev->id))
+			return 1; /* found */
+	}
+
+	return 0;
+}
+
+static struct bus_type ssb_bustype = {
+	.name		= "ssb",
+	.match		= ssb_bus_match,
+	.probe		= ssb_device_probe,
+	.remove		= ssb_device_remove,
+	.shutdown	= ssb_device_shutdown,
+	.suspend	= ssb_device_suspend,
+	.resume		= ssb_device_resume,
+};
+
+static void ssb_buses_lock(void)
+{
+	/* See the comment at the ssb_is_early_boot definition */
+	if (!ssb_is_early_boot)
+		mutex_lock(&buses_mutex);
+}
+
+static void ssb_buses_unlock(void)
+{
+	/* See the comment at the ssb_is_early_boot definition */
+	if (!ssb_is_early_boot)
+		mutex_unlock(&buses_mutex);
+}
+
+static void ssb_devices_unregister(struct ssb_bus *bus)
+{
+	struct ssb_device *sdev;
+	int i;
+
+	for (i = bus->nr_devices - 1; i >= 0; i--) {
+		sdev = &(bus->devices[i]);
+		if (sdev->dev)
+			device_unregister(sdev->dev);
+	}
+}
+
+void ssb_bus_unregister(struct ssb_bus *bus)
+{
+	ssb_buses_lock();
+	ssb_devices_unregister(bus);
+	list_del(&bus->list);
+	ssb_buses_unlock();
+
+	/* ssb_pcmcia_exit(bus); */
+	ssb_pci_exit(bus);
+	ssb_iounmap(bus);
+}
+EXPORT_SYMBOL(ssb_bus_unregister);
+
+static void ssb_release_dev(struct device *dev)
+{
+	struct __ssb_dev_wrapper *devwrap;
+
+	devwrap = container_of(dev, struct __ssb_dev_wrapper, dev);
+	kfree(devwrap);
+}
+
+static int ssb_devices_register(struct ssb_bus *bus)
+{
+	struct ssb_device *sdev;
+	struct device *dev;
+	struct __ssb_dev_wrapper *devwrap;
+	int i, err = 0;
+	int dev_idx = 0;
+
+	for (i = 0; i < bus->nr_devices; i++) {
+		sdev = &(bus->devices[i]);
+
+		/* We don't register SSB-system devices to the kernel,
+		 * as the drivers for them are built into SSB. */
+		switch (sdev->id.coreid) {
+		case SSB_DEV_CHIPCOMMON:
+		case SSB_DEV_PCI:
+		case SSB_DEV_PCIE:
+		case SSB_DEV_PCMCIA:
+		case SSB_DEV_MIPS:
+		case SSB_DEV_MIPS_3302:
+		case SSB_DEV_EXTIF:
+			continue;
+		}
+
+		devwrap = kzalloc(sizeof(*devwrap), GFP_KERNEL);
+		if (!devwrap) {
+			ssb_printk(KERN_ERR PFX
+				   "Could not allocate device\n");
+			err = -ENOMEM;
+			goto error;
+		}
+		dev = &devwrap->dev;
+		devwrap->sdev = sdev;
+
+		dev->release = ssb_release_dev;
+		dev->bus = &ssb_bustype;
+		snprintf(dev->bus_id, sizeof(dev->bus_id),
+			 "ssb%u:%d", bus->busnumber, dev_idx);
+
+		switch (bus->bustype) {
+		case SSB_BUSTYPE_PCI:
+#ifdef CONFIG_SSB_PCIHOST
+			sdev->irq = bus->host_pci->irq;
+			dev->parent = &bus->host_pci->dev;
+#endif
+			break;
+		case SSB_BUSTYPE_PCMCIA:
+#ifdef CONFIG_SSB_PCMCIAHOST
+			dev->parent = &bus->host_pcmcia->dev;
+#endif
+			break;
+		case SSB_BUSTYPE_SSB:
+			break;
+		}
+
+		sdev->dev = dev;
+		err = device_register(dev);
+		if (err) {
+			ssb_printk(KERN_ERR PFX
+				   "Could not register %s\n",
+				   dev->bus_id);
+			/* Set dev to NULL to not unregister
+			 * dev on error unwinding. */
+			sdev->dev = NULL;
+			kfree(devwrap);
+			goto error;
+		}
+		dev_idx++;
+	}
+
+	return 0;
+error:
+	/* Unwind the already registered devices. */
+	ssb_devices_unregister(bus);
+	return err;
+}
+
+/* Needs ssb_buses_lock() */
+static int ssb_attach_queued_buses(void)
+{
+	struct ssb_bus *bus, *n;
+	int err = 0;
+	int drop_them_all = 0;
+
+	list_for_each_entry_safe(bus, n, &attach_queue, list) {
+		if (drop_them_all) {
+			list_del(&bus->list);
+			continue;
+		}
+		/* Can't init the PCIcore in ssb_bus_register(), as that
+		 * is too early in boot for embedded systems
+		 * (no udelay() available). So do it here in attach stage.
+		 */
+		ssb_pcicore_init(&bus->pcicore);
+
+		err = ssb_devices_register(bus);
+		if (err) {
+			drop_them_all = 1;
+			list_del(&bus->list);
+			continue;
+		}
+		list_move_tail(&bus->list, &buses);
+	}
+
+	return err;
+}
+
+static u16 ssb_ssb_read16(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	return readw(bus->mmio + offset);
+}
+
+static u32 ssb_ssb_read32(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	return readl(bus->mmio + offset);
+}
+
+static void ssb_ssb_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	writew(value, bus->mmio + offset);
+}
+
+static void ssb_ssb_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	offset += dev->core_index * SSB_CORE_SIZE;
+	writel(value, bus->mmio + offset);
+}
+
+/* Ops for the plain SSB bus without a host-device (no PCI or PCMCIA). */
+static const struct ssb_bus_ops ssb_ssb_ops = {
+	.read16		= ssb_ssb_read16,
+	.read32		= ssb_ssb_read32,
+	.write16	= ssb_ssb_write16,
+	.write32	= ssb_ssb_write32,
+};
+
+static int ssb_fetch_invariants(struct ssb_bus *bus,
+				ssb_invariants_func_t get_invariants)
+{
+	struct ssb_init_invariants iv;
+	int err;
+
+	memset(&iv, 0, sizeof(iv));
+	err = get_invariants(bus, &iv);
+	if (err)
+		goto out;
+	memcpy(&bus->boardinfo, &iv.boardinfo, sizeof(iv.boardinfo));
+	memcpy(&bus->sprom, &iv.sprom, sizeof(iv.sprom));
+out:
+	return err;
+}
+
+static int ssb_bus_register(struct ssb_bus *bus,
+			    ssb_invariants_func_t get_invariants,
+			    unsigned long baseaddr)
+{
+	int err;
+
+	spin_lock_init(&bus->bar_lock);
+	INIT_LIST_HEAD(&bus->list);
+
+	/* Powerup the bus */
+	err = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 1);
+	if (err)
+		goto out;
+	ssb_buses_lock();
+	bus->busnumber = next_busnumber;
+	/* Scan for devices (cores) */
+	err = ssb_bus_scan(bus, baseaddr);
+	if (err)
+		goto err_disable_xtal;
+
+	/* Init PCI-host device (if any) */
+	err = ssb_pci_init(bus);
+	if (err)
+		goto err_unmap;
+	/* Init PCMCIA-host device (if any) */
+	err = ssb_pcmcia_init(bus);
+	if (err)
+		goto err_pci_exit;
+
+	/* Initialize basic system devices (if available) */
+	ssb_chipcommon_init(&bus->chipco);
+	ssb_mipscore_init(&bus->mipscore);
+	err = ssb_fetch_invariants(bus, get_invariants);
+	if (err)
+		goto err_pcmcia_exit;
+
+	/* Queue it for attach.
+	 * See the comment at the ssb_is_early_boot definition. */
+	list_add_tail(&bus->list, &attach_queue);
+	if (!ssb_is_early_boot) {
+		/* This is not early boot, so we must attach the bus now */
+		err = ssb_attach_queued_buses();
+		if (err)
+			goto err_dequeue;
+	}
+	next_busnumber++;
+	ssb_buses_unlock();
+
+out:
+	return err;
+
+err_dequeue:
+	list_del(&bus->list);
+err_pcmcia_exit:
+/*	ssb_pcmcia_exit(bus); */
+err_pci_exit:
+	ssb_pci_exit(bus);
+err_unmap:
+	ssb_iounmap(bus);
+err_disable_xtal:
+	ssb_buses_unlock();
+	ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);
+	return err;
+}
+
+#ifdef CONFIG_SSB_PCIHOST
+int ssb_bus_pcibus_register(struct ssb_bus *bus,
+			    struct pci_dev *host_pci)
+{
+	int err;
+
+	bus->bustype = SSB_BUSTYPE_PCI;
+	bus->host_pci = host_pci;
+	bus->ops = &ssb_pci_ops;
+
+	err = ssb_bus_register(bus, ssb_pci_get_invariants, 0);
+	if (!err) {
+		ssb_printk(KERN_INFO PFX "Sonics Silicon Backplane found on "
+			   "PCI device %s\n", host_pci->dev.bus_id);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_pcibus_register);
+#endif /* CONFIG_SSB_PCIHOST */
+
+#ifdef CONFIG_SSB_PCMCIAHOST
+int ssb_bus_pcmciabus_register(struct ssb_bus *bus,
+			       struct pcmcia_device *pcmcia_dev,
+			       unsigned long baseaddr)
+{
+	int err;
+
+	bus->bustype = SSB_BUSTYPE_PCMCIA;
+	bus->host_pcmcia = pcmcia_dev;
+	bus->ops = &ssb_pcmcia_ops;
+
+	err = ssb_bus_register(bus, ssb_pcmcia_get_invariants, baseaddr);
+	if (!err) {
+		ssb_printk(KERN_INFO PFX "Sonics Silicon Backplane found on "
+			   "PCMCIA device %s\n", pcmcia_dev->devname);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_pcmciabus_register);
+#endif /* CONFIG_SSB_PCMCIAHOST */
+
+int ssb_bus_ssbbus_register(struct ssb_bus *bus,
+			    unsigned long baseaddr,
+			    ssb_invariants_func_t get_invariants)
+{
+	int err;
+
+	bus->bustype = SSB_BUSTYPE_SSB;
+	bus->ops = &ssb_ssb_ops;
+
+	err = ssb_bus_register(bus, get_invariants, baseaddr);
+	if (!err) {
+		ssb_printk(KERN_INFO PFX "Sonics Silicon Backplane found at "
+			   "address 0x%08lX\n", baseaddr);
+	}
+
+	return err;
+}
+
+int __ssb_driver_register(struct ssb_driver *drv, struct module *owner)
+{
+	drv->drv.name = drv->name;
+	drv->drv.bus = &ssb_bustype;
+	drv->drv.owner = owner;
+
+	return driver_register(&drv->drv);
+}
+EXPORT_SYMBOL(__ssb_driver_register);
+
+void ssb_driver_unregister(struct ssb_driver *drv)
+{
+	driver_unregister(&drv->drv);
+}
+EXPORT_SYMBOL(ssb_driver_unregister);
+
+void ssb_set_devtypedata(struct ssb_device *dev, void *data)
+{
+	struct ssb_bus *bus = dev->bus;
+	struct ssb_device *ent;
+	int i;
+
+	for (i = 0; i < bus->nr_devices; i++) {
+		ent = &(bus->devices[i]);
+		if (ent->id.vendor != dev->id.vendor)
+			continue;
+		if (ent->id.coreid != dev->id.coreid)
+			continue;
+
+		ent->devtypedata = data;
+	}
+}
+EXPORT_SYMBOL(ssb_set_devtypedata);
+
+static u32 clkfactor_f6_resolve(u32 v)
+{
+	/* map the magic values */
+	switch (v) {
+	case SSB_CHIPCO_CLK_F6_2:
+		return 2;
+	case SSB_CHIPCO_CLK_F6_3:
+		return 3;
+	case SSB_CHIPCO_CLK_F6_4:
+		return 4;
+	case SSB_CHIPCO_CLK_F6_5:
+		return 5;
+	case SSB_CHIPCO_CLK_F6_6:
+		return 6;
+	case SSB_CHIPCO_CLK_F6_7:
+		return 7;
+	}
+	return 0;
+}
+
+/* Calculate the speed the backplane would run at a given set of clockcontrol values */
+u32 ssb_calc_clock_rate(u32 plltype, u32 n, u32 m)
+{
+	u32 n1, n2, clock, m1, m2, m3, mc;
+
+	n1 = (n & SSB_CHIPCO_CLK_N1);
+	n2 = ((n & SSB_CHIPCO_CLK_N2) >> SSB_CHIPCO_CLK_N2_SHIFT);
+
+	switch (plltype) {
+	case SSB_PLLTYPE_6: /* 100/200 or 120/240 only */
+		if (m & SSB_CHIPCO_CLK_T6_MMASK)
+			return SSB_CHIPCO_CLK_T6_M0;
+		return SSB_CHIPCO_CLK_T6_M1;
+	case SSB_PLLTYPE_1: /* 48Mhz base, 3 dividers */
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+	case SSB_PLLTYPE_4: /* 48Mhz, 4 dividers */
+	case SSB_PLLTYPE_7: /* 25Mhz, 4 dividers */
+		n1 = clkfactor_f6_resolve(n1);
+		n2 += SSB_CHIPCO_CLK_F5_BIAS;
+		break;
+	case SSB_PLLTYPE_2: /* 48Mhz, 4 dividers */
+		n1 += SSB_CHIPCO_CLK_T2_BIAS;
+		n2 += SSB_CHIPCO_CLK_T2_BIAS;
+		SSB_WARN_ON(!((n1 >= 2) && (n1 <= 7)));
+		SSB_WARN_ON(!((n2 >= 5) && (n2 <= 23)));
+		break;
+	case SSB_PLLTYPE_5: /* 25Mhz, 4 dividers */
+		return 100000000;
+	default:
+		SSB_WARN_ON(1);
+	}
+
+	switch (plltype) {
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+	case SSB_PLLTYPE_7: /* 25Mhz, 4 dividers */
+		clock = SSB_CHIPCO_CLK_BASE2 * n1 * n2;
+		break;
+	default:
+		clock = SSB_CHIPCO_CLK_BASE1 * n1 * n2;
+	}
+	if (!clock)
+		return 0;
+
+	m1 = (m & SSB_CHIPCO_CLK_M1);
+	m2 = ((m & SSB_CHIPCO_CLK_M2) >> SSB_CHIPCO_CLK_M2_SHIFT);
+	m3 = ((m & SSB_CHIPCO_CLK_M3) >> SSB_CHIPCO_CLK_M3_SHIFT);
+	mc = ((m & SSB_CHIPCO_CLK_MC) >> SSB_CHIPCO_CLK_MC_SHIFT);
+
+	switch (plltype) {
+	case SSB_PLLTYPE_1: /* 48Mhz base, 3 dividers */
+	case SSB_PLLTYPE_3: /* 25Mhz, 2 dividers */
+	case SSB_PLLTYPE_4: /* 48Mhz, 4 dividers */
+	case SSB_PLLTYPE_7: /* 25Mhz, 4 dividers */
+		m1 = clkfactor_f6_resolve(m1);
+		if ((plltype == SSB_PLLTYPE_1) ||
+		    (plltype == SSB_PLLTYPE_3))
+			m2 += SSB_CHIPCO_CLK_F5_BIAS;
+		else
+			m2 = clkfactor_f6_resolve(m2);
+		m3 = clkfactor_f6_resolve(m3);
+
+		switch (mc) {
+		case SSB_CHIPCO_CLK_MC_BYPASS:
+			return clock;
+		case SSB_CHIPCO_CLK_MC_M1:
+			return (clock / m1);
+		case SSB_CHIPCO_CLK_MC_M1M2:
+			return (clock / (m1 * m2));
+		case SSB_CHIPCO_CLK_MC_M1M2M3:
+			return (clock / (m1 * m2 * m3));
+		case SSB_CHIPCO_CLK_MC_M1M3:
+			return (clock / (m1 * m3));
+		}
+		return 0;
+	case SSB_PLLTYPE_2:
+		m1 += SSB_CHIPCO_CLK_T2_BIAS;
+		m2 += SSB_CHIPCO_CLK_T2M2_BIAS;
+		m3 += SSB_CHIPCO_CLK_T2_BIAS;
+		SSB_WARN_ON(!((m1 >= 2) && (m1 <= 7)));
+		SSB_WARN_ON(!((m2 >= 3) && (m2 <= 10)));
+		SSB_WARN_ON(!((m3 >= 2) && (m3 <= 7)));
+
+		if (!(mc & SSB_CHIPCO_CLK_T2MC_M1BYP))
+			clock /= m1;
+		if (!(mc & SSB_CHIPCO_CLK_T2MC_M2BYP))
+			clock /= m2;
+		if (!(mc & SSB_CHIPCO_CLK_T2MC_M3BYP))
+			clock /= m3;
+		return clock;
+	default:
+		SSB_WARN_ON(1);
+	}
+	return 0;
+}
+
+/* Get the current speed the backplane is running at */
+u32 ssb_clockspeed(struct ssb_bus *bus)
+{
+	u32 rate;
+	u32 plltype;
+	u32 clkctl_n, clkctl_m;
+
+	//TODO if EXTIF: PLLTYPE == 1, read n from clockcontrol_n, m from clockcontrol_sb
+
+	if (bus->chipco.dev) {
+		ssb_chipco_get_clockcontrol(&bus->chipco, &plltype,
+					    &clkctl_n, &clkctl_m);
+	} else
+		return 0;
+
+	if (bus->chip_id == 0x5365) {
+		rate = 100000000;
+	} else {
+		rate = ssb_calc_clock_rate(plltype, clkctl_n, clkctl_m);
+		if (plltype == SSB_PLLTYPE_3) /* 25Mhz, 2 dividers */
+			rate /= 2;
+	}
+
+	return rate;
+}
+EXPORT_SYMBOL(ssb_clockspeed);
+
+static u32 ssb_tmslow_reject_bitmask(struct ssb_device *dev)
+{
+	/* The REJECT bit changed position in TMSLOW between
+	 * Backplane revisions. */
+	switch (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV) {
+	case SSB_IDLOW_SSBREV_22:
+		return SSB_TMSLOW_REJECT_22;
+	case SSB_IDLOW_SSBREV_23:
+		return SSB_TMSLOW_REJECT_23;
+	default:
+		WARN_ON(1);
+	}
+	return (SSB_TMSLOW_REJECT_22 | SSB_TMSLOW_REJECT_23);
+}
+
+int ssb_device_is_enabled(struct ssb_device *dev)
+{
+	u32 val;
+	u32 reject;
+
+	reject = ssb_tmslow_reject_bitmask(dev);
+	val = ssb_read32(dev, SSB_TMSLOW);
+	val &= SSB_TMSLOW_CLOCK | SSB_TMSLOW_RESET | reject;
+
+	return (val == SSB_TMSLOW_CLOCK);
+}
+EXPORT_SYMBOL(ssb_device_is_enabled);
+
+static void ssb_flush_tmslow(struct ssb_device *dev)
+{
+	/* Make _really_ sure the device has finished the TMSLOW
+	 * register write transaction, as we risk running into
+	 * a machine check exception otherwise.
+	 * Do this by reading the register back to commit the
+	 * PCI write and delay an additional usec for the device
+	 * to react to the change. */
+	ssb_read32(dev, SSB_TMSLOW);
+	udelay(1);
+}
+
+void ssb_device_enable(struct ssb_device *dev, u32 core_specific_flags)
+{
+	u32 val;
+
+	ssb_device_disable(dev, core_specific_flags);
+	ssb_write32(dev, SSB_TMSLOW,
+		    SSB_TMSLOW_RESET | SSB_TMSLOW_CLOCK |
+		    SSB_TMSLOW_FGC | core_specific_flags);
+	ssb_flush_tmslow(dev);
+
+	/* Clear SERR if set. This is a hw bug workaround. */
+	if (ssb_read32(dev, SSB_TMSHIGH) & SSB_TMSHIGH_SERR)
+		ssb_write32(dev, SSB_TMSHIGH, 0);
+
+	val = ssb_read32(dev, SSB_IMSTATE);
+	if (val & (SSB_IMSTATE_IBE | SSB_IMSTATE_TO)) {
+		val &= ~(SSB_IMSTATE_IBE | SSB_IMSTATE_TO);
+		ssb_write32(dev, SSB_IMSTATE, val);
+	}
+
+	ssb_write32(dev, SSB_TMSLOW,
+		    SSB_TMSLOW_CLOCK | SSB_TMSLOW_FGC |
+		    core_specific_flags);
+	ssb_flush_tmslow(dev);
+
+	ssb_write32(dev, SSB_TMSLOW, SSB_TMSLOW_CLOCK |
+		    core_specific_flags);
+	ssb_flush_tmslow(dev);
+}
+EXPORT_SYMBOL(ssb_device_enable);
+
+/* Wait for a bit in a register to get set or unset.
+ * timeout is in units of ten-microseconds */
+static int ssb_wait_bit(struct ssb_device *dev, u16 reg, u32 bitmask,
+			int timeout, int set)
+{
+	int i;
+	u32 val;
+
+	for (i = 0; i < timeout; i++) {
+		val = ssb_read32(dev, reg);
+		if (set) {
+			if (val & bitmask)
+				return 0;
+		} else {
+			if (!(val & bitmask))
+				return 0;
+		}
+		udelay(10);
+	}
+	printk(KERN_ERR PFX "Timeout waiting for bitmask %08X on "
+			    "register %04X to %s.\n",
+	       bitmask, reg, (set ? "set" : "clear"));
+
+	return -ETIMEDOUT;
+}
+
+void ssb_device_disable(struct ssb_device *dev, u32 core_specific_flags)
+{
+	u32 reject;
+
+	if (ssb_read32(dev, SSB_TMSLOW) & SSB_TMSLOW_RESET)
+		return;
+
+	reject = ssb_tmslow_reject_bitmask(dev);
+	ssb_write32(dev, SSB_TMSLOW, reject | SSB_TMSLOW_CLOCK);
+	ssb_wait_bit(dev, SSB_TMSLOW, reject, 1000, 1);
+	ssb_wait_bit(dev, SSB_TMSHIGH, SSB_TMSHIGH_BUSY, 1000, 0);
+	ssb_write32(dev, SSB_TMSLOW,
+		    SSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK |
+		    reject | SSB_TMSLOW_RESET |
+		    core_specific_flags);
+	ssb_flush_tmslow(dev);
+
+	ssb_write32(dev, SSB_TMSLOW,
+		    reject | SSB_TMSLOW_RESET |
+		    core_specific_flags);
+	ssb_flush_tmslow(dev);
+}
+EXPORT_SYMBOL(ssb_device_disable);
+
+u32 ssb_dma_translation(struct ssb_device *dev)
+{
+	switch (dev->bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		return 0;
+	case SSB_BUSTYPE_PCI:
+	case SSB_BUSTYPE_PCMCIA:
+		return SSB_PCI_DMA;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ssb_dma_translation);
+
+int ssb_dma_set_mask(struct ssb_device *ssb_dev, u64 mask)
+{
+	struct device *dev = ssb_dev->dev;
+
+#ifdef CONFIG_SSB_PCIHOST
+	if (ssb_dev->bus->bustype == SSB_BUSTYPE_PCI &&
+	    !dma_supported(dev, mask))
+		return -EIO;
+#endif
+	dev->coherent_dma_mask = mask;
+	dev->dma_mask = &dev->coherent_dma_mask;
+
+	return 0;
+}
+EXPORT_SYMBOL(ssb_dma_set_mask);
+
+int ssb_bus_may_powerdown(struct ssb_bus *bus)
+{
+	struct ssb_chipcommon *cc;
+	int err;
+
+	/* On buses where more than one core may be working
+	 * at a time, we must not powerdown stuff if there are
+	 * still cores that may want to run. */
+	if (bus->bustype == SSB_BUSTYPE_SSB)
+		return 0;
+
+	cc = &bus->chipco;
+	ssb_chipco_set_clockmode(cc, SSB_CLKMODE_SLOW);
+	err = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);
+	if (err)
+		goto error;
+
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Bus powerdown failed\n");
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_may_powerdown);
+
+int ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl)
+{
+	struct ssb_chipcommon *cc;
+	int err;
+	enum ssb_clkmode mode;
+
+	err = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 1);
+	if (err)
+		goto error;
+	cc = &bus->chipco;
+	mode = dynamic_pctl ? SSB_CLKMODE_DYNAMIC : SSB_CLKMODE_FAST;
+	ssb_chipco_set_clockmode(cc, mode);
+
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Bus powerup failed\n");
+	return err;
+}
+EXPORT_SYMBOL(ssb_bus_powerup);
+
+u32 ssb_admatch_base(u32 adm)
+{
+	u32 base = 0;
+
+	switch (adm & SSB_ADM_TYPE) {
+	case SSB_ADM_TYPE0:
+		base = (adm & SSB_ADM_BASE0);
+		break;
+	case SSB_ADM_TYPE1:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		base = (adm & SSB_ADM_BASE1);
+		break;
+	case SSB_ADM_TYPE2:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		base = (adm & SSB_ADM_BASE2);
+		break;
+	default:
+		SSB_WARN_ON(1);
+	}
+
+	return base;
+}
+EXPORT_SYMBOL(ssb_admatch_base);
+
+u32 ssb_admatch_size(u32 adm)
+{
+	u32 size = 0;
+
+	switch (adm & SSB_ADM_TYPE) {
+	case SSB_ADM_TYPE0:
+		size = ((adm & SSB_ADM_SZ0) >> SSB_ADM_SZ0_SHIFT);
+		break;
+	case SSB_ADM_TYPE1:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		size = ((adm & SSB_ADM_SZ1) >> SSB_ADM_SZ1_SHIFT);
+		break;
+	case SSB_ADM_TYPE2:
+		SSB_WARN_ON(adm & SSB_ADM_NEG); /* unsupported */
+		size = ((adm & SSB_ADM_SZ2) >> SSB_ADM_SZ2_SHIFT);
+		break;
+	default:
+		SSB_WARN_ON(1);
+	}
+	size = (1 << (size + 1));
+
+	return size;
+}
+EXPORT_SYMBOL(ssb_admatch_size);
+
+static int __init ssb_modinit(void)
+{
+	int err;
+
+	/* See the comment at the ssb_is_early_boot definition */
+	ssb_is_early_boot = 0;
+	err = bus_register(&ssb_bustype);
+	if (err)
+		return err;
+
+	/* Maybe we already registered some buses at early boot.
+	 * Check for this and attach them
+	 */
+	ssb_buses_lock();
+	err = ssb_attach_queued_buses();
+	ssb_buses_unlock();
+	if (err)
+		bus_unregister(&ssb_bustype);
+
+	return err;
+}
+subsys_initcall(ssb_modinit);
+
+static void __exit ssb_modexit(void)
+{
+	bus_unregister(&ssb_bustype);
+}
+module_exit(ssb_modexit)
diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
new file mode 100644
index 0000000..b3ec4c8
--- /dev/null
+++ b/drivers/ssb/pci.c
@@ -0,0 +1,704 @@
+/*
+ * Sonics Silicon Backplane PCI-Hostbus related functions.
+ *
+ * Copyright (C) 2005-2006 Michael Buesch <mb at bu3sch.de>
+ * Copyright (C) 2005 Martin Langer <martin-langer at gmx.de>
+ * Copyright (C) 2005 Stefano Brivio <st3 at riseup.net>
+ * Copyright (C) 2005 Danny van Dyk <kugelfang at gentoo.org>
+ * Copyright (C) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+ *
+ * Derived from the Broadcom 4400 device driver.
+ * Copyright (C) 2002 David S. Miller (davem at redhat.com)
+ * Fixed by Pekka Pietikainen (pp at ee.oulu.fi)
+ * Copyright (C) 2006 Broadcom Corporation.
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include "ssb_private.h"
+
+
+/* Lowlevel coreswitching */
+int ssb_pci_switch_coreidx(struct ssb_bus *bus, u8 coreidx)
+{
+	int err;
+	int attempts = 0;
+	u32 cur_core;
+
+	while (1) {
+		err = pci_write_config_dword(bus->host_pci, SSB_BAR0_WIN,
+					     (coreidx * SSB_CORE_SIZE)
+					     + SSB_ENUM_BASE);
+		if (err)
+			goto error;
+		err = pci_read_config_dword(bus->host_pci, SSB_BAR0_WIN,
+					    &cur_core);
+		if (err)
+			goto error;
+		cur_core = (cur_core - SSB_ENUM_BASE)
+			   / SSB_CORE_SIZE;
+		if (cur_core == coreidx)
+			break;
+
+		if (attempts++ > SSB_BAR0_MAX_RETRIES)
+			goto error;
+		udelay(10);
+	}
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Failed to switch to core %u\n", coreidx);
+	return -ENODEV;
+}
+
+int ssb_pci_switch_core(struct ssb_bus *bus,
+			struct ssb_device *dev)
+{
+	int err;
+	unsigned long flags;
+
+	ssb_dprintk(KERN_INFO PFX
+		    "Switching to %s core, index %d\n",
+		    ssb_core_name(dev->id.coreid),
+		    dev->core_index);
+
+	spin_lock_irqsave(&bus->bar_lock, flags);
+	err = ssb_pci_switch_coreidx(bus, dev->core_index);
+	if (!err)
+		bus->mapped_device = dev;
+	spin_unlock_irqrestore(&bus->bar_lock, flags);
+
+	return err;
+}
+
+/* Enable/disable the on board crystal oscillator and/or PLL. */
+int ssb_pci_xtal(struct ssb_bus *bus, u32 what, int turn_on)
+{
+	int err;
+	u32 in, out, outenable;
+	u16 pci_status;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return 0;
+
+	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_IN, &in);
+	if (err)
+		goto err_pci;
+	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT, &out);
+	if (err)
+		goto err_pci;
+	err = pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE, &outenable);
+	if (err)
+		goto err_pci;
+
+	outenable |= what;
+
+	if (turn_on) {
+		/* Avoid glitching the clock if GPRS is already using it.
+		 * We can't actually read the state of the PLLPD so we infer it
+		 * by the value of XTAL_PU which *is* readable via gpioin.
+		 */
+		if (!(in & SSB_GPIO_XTAL)) {
+			if (what & SSB_GPIO_XTAL) {
+				/* Turn the crystal on */
+				out |= SSB_GPIO_XTAL;
+				if (what & SSB_GPIO_PLL)
+					out |= SSB_GPIO_PLL;
+				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
+				if (err)
+					goto err_pci;
+				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE,
+							     outenable);
+				if (err)
+					goto err_pci;
+				msleep(1);
+			}
+			if (what & SSB_GPIO_PLL) {
+				/* Turn the PLL on */
+				out &= ~SSB_GPIO_PLL;
+				err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
+				if (err)
+					goto err_pci;
+				msleep(5);
+			}
+		}
+
+		err = pci_read_config_word(bus->host_pci, PCI_STATUS, &pci_status);
+		if (err)
+			goto err_pci;
+		pci_status &= ~PCI_STATUS_SIG_TARGET_ABORT;
+		err = pci_write_config_word(bus->host_pci, PCI_STATUS, pci_status);
+		if (err)
+			goto err_pci;
+	} else {
+		if (what & SSB_GPIO_XTAL) {
+			/* Turn the crystal off */
+			out &= ~SSB_GPIO_XTAL;
+		}
+		if (what & SSB_GPIO_PLL) {
+			/* Turn the PLL off */
+			out |= SSB_GPIO_PLL;
+		}
+		err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);
+		if (err)
+			goto err_pci;
+		err = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE, outenable);
+		if (err)
+			goto err_pci;
+	}
+
+out:
+	return err;
+
+err_pci:
+	printk(KERN_ERR PFX "Error: ssb_pci_xtal() could not access PCI config space!\n");
+	err = -EBUSY;
+	goto out;
+}
+
+/* Get the word-offset for a SSB_SPROM_XXX define. */
+#define SPOFF(offset)	(((offset) - SSB_SPROM_BASE) / sizeof(u16))
+/* Helper to extract some _offset, which is one of the SSB_SPROM_XXX defines. */
+#define SPEX(_outvar, _offset, _mask, _shift)	\
+	out->_outvar = ((in[SPOFF(_offset)] & (_mask)) >> (_shift))
+
+static inline u8 ssb_crc8(u8 crc, u8 data)
+{
+	/* Polynomial:   x^8 + x^7 + x^6 + x^4 + x^2 + 1   */
+	static const u8 t[] = {
+		0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
+		0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
+		0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
+		0xDE, 0x29, 0x67, 0x90, 0xFB, 0x0C, 0x42, 0xB5,
+		0x7F, 0x88, 0xC6, 0x31, 0x5A, 0xAD, 0xE3, 0x14,
+		0x35, 0xC2, 0x8C, 0x7B, 0x10, 0xE7, 0xA9, 0x5E,
+		0xEB, 0x1C, 0x52, 0xA5, 0xCE, 0x39, 0x77, 0x80,
+		0xA1, 0x56, 0x18, 0xEF, 0x84, 0x73, 0x3D, 0xCA,
+		0xFE, 0x09, 0x47, 0xB0, 0xDB, 0x2C, 0x62, 0x95,
+		0xB4, 0x43, 0x0D, 0xFA, 0x91, 0x66, 0x28, 0xDF,
+		0x6A, 0x9D, 0xD3, 0x24, 0x4F, 0xB8, 0xF6, 0x01,
+		0x20, 0xD7, 0x99, 0x6E, 0x05, 0xF2, 0xBC, 0x4B,
+		0x81, 0x76, 0x38, 0xCF, 0xA4, 0x53, 0x1D, 0xEA,
+		0xCB, 0x3C, 0x72, 0x85, 0xEE, 0x19, 0x57, 0xA0,
+		0x15, 0xE2, 0xAC, 0x5B, 0x30, 0xC7, 0x89, 0x7E,
+		0x5F, 0xA8, 0xE6, 0x11, 0x7A, 0x8D, 0xC3, 0x34,
+		0xAB, 0x5C, 0x12, 0xE5, 0x8E, 0x79, 0x37, 0xC0,
+		0xE1, 0x16, 0x58, 0xAF, 0xC4, 0x33, 0x7D, 0x8A,
+		0x3F, 0xC8, 0x86, 0x71, 0x1A, 0xED, 0xA3, 0x54,
+		0x75, 0x82, 0xCC, 0x3B, 0x50, 0xA7, 0xE9, 0x1E,
+		0xD4, 0x23, 0x6D, 0x9A, 0xF1, 0x06, 0x48, 0xBF,
+		0x9E, 0x69, 0x27, 0xD0, 0xBB, 0x4C, 0x02, 0xF5,
+		0x40, 0xB7, 0xF9, 0x0E, 0x65, 0x92, 0xDC, 0x2B,
+		0x0A, 0xFD, 0xB3, 0x44, 0x2F, 0xD8, 0x96, 0x61,
+		0x55, 0xA2, 0xEC, 0x1B, 0x70, 0x87, 0xC9, 0x3E,
+		0x1F, 0xE8, 0xA6, 0x51, 0x3A, 0xCD, 0x83, 0x74,
+		0xC1, 0x36, 0x78, 0x8F, 0xE4, 0x13, 0x5D, 0xAA,
+		0x8B, 0x7C, 0x32, 0xC5, 0xAE, 0x59, 0x17, 0xE0,
+		0x2A, 0xDD, 0x93, 0x64, 0x0F, 0xF8, 0xB6, 0x41,
+		0x60, 0x97, 0xD9, 0x2E, 0x45, 0xB2, 0xFC, 0x0B,
+		0xBE, 0x49, 0x07, 0xF0, 0x9B, 0x6C, 0x22, 0xD5,
+		0xF4, 0x03, 0x4D, 0xBA, 0xD1, 0x26, 0x68, 0x9F,
+	};
+	return t[crc ^ data];
+}
+
+static u8 ssb_sprom_crc(const u16 *sprom)
+{
+	int word;
+	u8 crc = 0xFF;
+
+	for (word = 0; word < SSB_SPROMSIZE_WORDS - 1; word++) {
+		crc = ssb_crc8(crc, sprom[word] & 0x00FF);
+		crc = ssb_crc8(crc, (sprom[word] & 0xFF00) >> 8);
+	}
+	crc = ssb_crc8(crc, sprom[SPOFF(SSB_SPROM_REVISION)] & 0x00FF);
+	crc ^= 0xFF;
+
+	return crc;
+}
+
+static int sprom_check_crc(const u16 *sprom)
+{
+	u8 crc;
+	u8 expected_crc;
+	u16 tmp;
+
+	crc = ssb_sprom_crc(sprom);
+	tmp = sprom[SPOFF(SSB_SPROM_REVISION)] & SSB_SPROM_REVISION_CRC;
+	expected_crc = tmp >> SSB_SPROM_REVISION_CRC_SHIFT;
+	if (crc != expected_crc)
+		return -EPROTO;
+
+	return 0;
+}
+
+static void sprom_do_read(struct ssb_bus *bus, u16 *sprom)
+{
+	int i;
+
+	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++)
+		sprom[i] = readw(bus->mmio + SSB_SPROM_BASE + (i * 2));
+}
+
+static int sprom_do_write(struct ssb_bus *bus, const u16 *sprom)
+{
+	struct pci_dev *pdev = bus->host_pci;
+	int i, err;
+	u32 spromctl;
+
+	ssb_printk(KERN_NOTICE PFX "Writing SPROM. Do NOT turn off the power! Please stand by...\n");
+	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
+	if (err)
+		goto err_ctlreg;
+	spromctl |= SSB_SPROMCTL_WE;
+	err = pci_write_config_dword(pdev, SSB_SPROMCTL, spromctl);
+	if (err)
+		goto err_ctlreg;
+	ssb_printk(KERN_NOTICE PFX "[ 0%%");
+	msleep(500);
+	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
+		if (i == SSB_SPROMSIZE_WORDS / 4)
+			ssb_printk("25%%");
+		else if (i == SSB_SPROMSIZE_WORDS / 2)
+			ssb_printk("50%%");
+		else if (i == (SSB_SPROMSIZE_WORDS / 4) * 3)
+			ssb_printk("75%%");
+		else if (i % 2)
+			ssb_printk(".");
+		writew(sprom[i], bus->mmio + SSB_SPROM_BASE + (i * 2));
+		mmiowb();
+		msleep(20);
+	}
+	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
+	if (err)
+		goto err_ctlreg;
+	spromctl &= ~SSB_SPROMCTL_WE;
+	err = pci_write_config_dword(pdev, SSB_SPROMCTL, spromctl);
+	if (err)
+		goto err_ctlreg;
+	msleep(500);
+	ssb_printk("100%% ]\n");
+	ssb_printk(KERN_NOTICE PFX "SPROM written.\n");
+
+	return 0;
+err_ctlreg:
+	ssb_printk(KERN_ERR PFX "Could not access SPROM control register.\n");
+	return err;
+}
+
+static void sprom_extract_r1(struct ssb_sprom_r1 *out, const u16 *in)
+{
+	int i;
+	u16 v;
+
+	SPEX(pci_spid, SSB_SPROM1_SPID, 0xFFFF, 0);
+	SPEX(pci_svid, SSB_SPROM1_SVID, 0xFFFF, 0);
+	SPEX(pci_pid, SSB_SPROM1_PID, 0xFFFF, 0);
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
+		*(((u16 *)out->il0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_ET0MAC) + i];
+		*(((u16 *)out->et0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_ET1MAC) + i];
+		*(((u16 *)out->et1mac) + i) = cpu_to_be16(v);
+	}
+	SPEX(et0phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0A, 0);
+	SPEX(et1phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1A,
+	     SSB_SPROM1_ETHPHY_ET1A_SHIFT);
+	SPEX(et0mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0M, 14);
+	SPEX(et1mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1M, 15);
+	SPEX(board_rev, SSB_SPROM1_BINF, SSB_SPROM1_BINF_BREV, 0);
+	SPEX(country_code, SSB_SPROM1_BINF, SSB_SPROM1_BINF_CCODE,
+	     SSB_SPROM1_BINF_CCODE_SHIFT);
+	SPEX(antenna_a, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTA,
+	     SSB_SPROM1_BINF_ANTA_SHIFT);
+	SPEX(antenna_bg, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTBG,
+	     SSB_SPROM1_BINF_ANTBG_SHIFT);
+	SPEX(pa0b0, SSB_SPROM1_PA0B0, 0xFFFF, 0);
+	SPEX(pa0b1, SSB_SPROM1_PA0B1, 0xFFFF, 0);
+	SPEX(pa0b2, SSB_SPROM1_PA0B2, 0xFFFF, 0);
+	SPEX(pa1b0, SSB_SPROM1_PA1B0, 0xFFFF, 0);
+	SPEX(pa1b1, SSB_SPROM1_PA1B1, 0xFFFF, 0);
+	SPEX(pa1b2, SSB_SPROM1_PA1B2, 0xFFFF, 0);
+	SPEX(gpio0, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P0, 0);
+	SPEX(gpio1, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P1,
+	     SSB_SPROM1_GPIOA_P1_SHIFT);
+	SPEX(gpio2, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P2, 0);
+	SPEX(gpio3, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P3,
+	     SSB_SPROM1_GPIOB_P3_SHIFT);
+	SPEX(maxpwr_a, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_A,
+	     SSB_SPROM1_MAXPWR_A_SHIFT);
+	SPEX(maxpwr_bg, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_BG, 0);
+	SPEX(itssi_a, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_A,
+	     SSB_SPROM1_ITSSI_A_SHIFT);
+	SPEX(itssi_bg, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_BG, 0);
+	SPEX(boardflags_lo, SSB_SPROM1_BFLLO, 0xFFFF, 0);
+	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
+	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
+	     SSB_SPROM1_AGAIN_BG_SHIFT);
+	for (i = 0; i < 4; i++) {
+		v = in[SPOFF(SSB_SPROM1_OEM) + i];
+		*(((u16 *)out->oem) + i) = cpu_to_le16(v);
+	}
+}
+
+static void sprom_extract_r2(struct ssb_sprom_r2 *out, const u16 *in)
+{
+	int i;
+	u16 v;
+
+	SPEX(boardflags_hi, SSB_SPROM2_BFLHI,  0xFFFF, 0);
+	SPEX(maxpwr_a_hi, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_HI, 0);
+	SPEX(maxpwr_a_lo, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_LO,
+	     SSB_SPROM2_MAXP_A_LO_SHIFT);
+	SPEX(pa1lob0, SSB_SPROM2_PA1LOB0, 0xFFFF, 0);
+	SPEX(pa1lob1, SSB_SPROM2_PA1LOB1, 0xFFFF, 0);
+	SPEX(pa1lob2, SSB_SPROM2_PA1LOB2, 0xFFFF, 0);
+	SPEX(pa1hib0, SSB_SPROM2_PA1HIB0, 0xFFFF, 0);
+	SPEX(pa1hib1, SSB_SPROM2_PA1HIB1, 0xFFFF, 0);
+	SPEX(pa1hib2, SSB_SPROM2_PA1HIB2, 0xFFFF, 0);
+	SPEX(ofdm_pwr_off, SSB_SPROM2_OPO, SSB_SPROM2_OPO_VALUE, 0);
+	for (i = 0; i < 4; i++) {
+		v = in[SPOFF(SSB_SPROM2_CCODE) + i];
+		*(((u16 *)out->country_str) + i) = cpu_to_le16(v);
+	}
+}
+
+static void sprom_extract_r3(struct ssb_sprom_r3 *out, const u16 *in)
+{
+	out->ofdmapo  = (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0xFF00) >> 8;
+	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0x00FF) << 8;
+	out->ofdmapo <<= 16;
+	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0xFF00) >> 8;
+	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0x00FF) << 8;
+
+	out->ofdmalpo  = (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0xFF00) >> 8;
+	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0x00FF) << 8;
+	out->ofdmalpo <<= 16;
+	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0xFF00) >> 8;
+	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0x00FF) << 8;
+
+	out->ofdmahpo  = (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0xFF00) >> 8;
+	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0x00FF) << 8;
+	out->ofdmahpo <<= 16;
+	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0xFF00) >> 8;
+	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0x00FF) << 8;
+
+	SPEX(gpioldc_on_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_ON,
+	     SSB_SPROM3_GPIOLDC_ON_SHIFT);
+	SPEX(gpioldc_off_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_OFF,
+	     SSB_SPROM3_GPIOLDC_OFF_SHIFT);
+	SPEX(cckpo_1M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_1M, 0);
+	SPEX(cckpo_2M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_2M,
+	     SSB_SPROM3_CCKPO_2M_SHIFT);
+	SPEX(cckpo_55M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_55M,
+	     SSB_SPROM3_CCKPO_55M_SHIFT);
+	SPEX(cckpo_11M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_11M,
+	     SSB_SPROM3_CCKPO_11M_SHIFT);
+
+	out->ofdmgpo  = (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0xFF00) >> 8;
+	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0x00FF) << 8;
+	out->ofdmgpo <<= 16;
+	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0xFF00) >> 8;
+	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0x00FF) << 8;
+}
+
+static int sprom_extract(struct ssb_bus *bus,
+			 struct ssb_sprom *out, const u16 *in)
+{
+	memset(out, 0, sizeof(*out));
+
+	SPEX(revision, SSB_SPROM_REVISION, SSB_SPROM_REVISION_REV, 0);
+	SPEX(crc, SSB_SPROM_REVISION, SSB_SPROM_REVISION_CRC,
+	     SSB_SPROM_REVISION_CRC_SHIFT);
+
+	if ((bus->chip_id & 0xFF00) == 0x4400) {
+		/* Workaround: The BCM44XX chip has a stupid revision
+		 * number stored in the SPROM.
+		 * Always extract r1. */
+		sprom_extract_r1(&out->r1, in);
+	} else {
+		if (out->revision == 0)
+			goto unsupported;
+		if (out->revision >= 1 && out->revision <= 3)
+			sprom_extract_r1(&out->r1, in);
+		if (out->revision >= 2 && out->revision <= 3)
+			sprom_extract_r2(&out->r2, in);
+		if (out->revision == 3)
+			sprom_extract_r3(&out->r3, in);
+		if (out->revision >= 4)
+			goto unsupported;
+	}
+
+	return 0;
+unsupported:
+	ssb_printk(KERN_WARNING PFX "Unsupported SPROM revision %d "
+		   "detected. Will extract v1\n", out->revision);
+	sprom_extract_r1(&out->r1, in);
+	return 0;
+}
+
+static int ssb_pci_sprom_get(struct ssb_bus *bus,
+			     struct ssb_sprom *sprom)
+{
+	int err = -ENOMEM;
+	u16 *buf;
+
+	buf = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	if (!buf)
+		goto out;
+	sprom_do_read(bus, buf);
+	err = sprom_check_crc(buf);
+	if (err) {
+		ssb_printk(KERN_WARNING PFX
+			   "WARNING: Invalid SPROM CRC (corrupt SPROM)\n");
+	}
+	err = sprom_extract(bus, sprom, buf);
+
+	kfree(buf);
+out:
+	return err;
+}
+
+static void ssb_pci_get_boardinfo(struct ssb_bus *bus,
+				  struct ssb_boardinfo *bi)
+{
+	pci_read_config_word(bus->host_pci, PCI_SUBSYSTEM_VENDOR_ID,
+			     &bi->vendor);
+	pci_read_config_word(bus->host_pci, PCI_SUBSYSTEM_ID,
+			     &bi->type);
+	pci_read_config_word(bus->host_pci, PCI_REVISION_ID,
+			     &bi->rev);
+}
+
+int ssb_pci_get_invariants(struct ssb_bus *bus,
+			   struct ssb_init_invariants *iv)
+{
+	int err;
+
+	err = ssb_pci_sprom_get(bus, &iv->sprom);
+	if (err)
+		goto out;
+	ssb_pci_get_boardinfo(bus, &iv->boardinfo);
+
+out:
+	return err;
+}
+
+static u16 ssb_pci_read16(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return 0xFFFF;
+	}
+	return readw(bus->mmio + offset);
+}
+
+static u32 ssb_pci_read32(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return 0xFFFFFFFF;
+	}
+	return readl(bus->mmio + offset);
+}
+
+static void ssb_pci_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return;
+	}
+	writew(value, bus->mmio + offset);
+}
+
+static void ssb_pci_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(bus->mapped_device != dev)) {
+		if (unlikely(ssb_pci_switch_core(bus, dev)))
+			return;
+	}
+	writel(value, bus->mmio + offset);
+}
+
+/* Not "static", as it's used in main.c */
+const struct ssb_bus_ops ssb_pci_ops = {
+	.read16		= ssb_pci_read16,
+	.read32		= ssb_pci_read32,
+	.write16	= ssb_pci_write16,
+	.write32	= ssb_pci_write32,
+};
+
+static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len)
+{
+	int i, pos = 0;
+
+	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
+		pos += snprintf(buf + pos, buf_len - pos - 1,
+				"%04X", swab16(sprom[i]) & 0xFFFF);
+	}
+	pos += snprintf(buf + pos, buf_len - pos - 1, "\n");
+
+	return pos + 1;
+}
+
+static int hex2sprom(u16 *sprom, const char *dump, size_t len)
+{
+	char tmp[5] = { 0 };
+	int cnt = 0;
+	unsigned long parsed;
+
+	if (len < SSB_SPROMSIZE_BYTES * 2)
+		return -EINVAL;
+
+	while (cnt < SSB_SPROMSIZE_WORDS) {
+		memcpy(tmp, dump, 4);
+		dump += 4;
+		parsed = simple_strtoul(tmp, NULL, 16);
+		sprom[cnt++] = swab16((u16)parsed);
+	}
+
+	return 0;
+}
+
+static ssize_t ssb_pci_attr_sprom_show(struct device *pcidev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	struct pci_dev *pdev = container_of(pcidev, struct pci_dev, dev);
+	struct ssb_bus *bus;
+	u16 *sprom;
+	int err = -ENODEV;
+	ssize_t count = 0;
+
+	bus = ssb_pci_dev_to_bus(pdev);
+	if (!bus)
+		goto out;
+	err = -ENOMEM;
+	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	if (!sprom)
+		goto out;
+
+	/* Use interruptible locking, as the SPROM write might
+	 * be holding the lock for several seconds. So allow userspace
+	 * to cancel operation. */
+	err = -ERESTARTSYS;
+	if (mutex_lock_interruptible(&bus->pci_sprom_mutex))
+		goto out_kfree;
+	sprom_do_read(bus, sprom);
+	mutex_unlock(&bus->pci_sprom_mutex);
+
+	count = sprom2hex(sprom, buf, PAGE_SIZE);
+	err = 0;
+
+out_kfree:
+	kfree(sprom);
+out:
+	return err ? err : count;
+}
+
+static ssize_t ssb_pci_attr_sprom_store(struct device *pcidev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct pci_dev *pdev = container_of(pcidev, struct pci_dev, dev);
+	struct ssb_bus *bus;
+	u16 *sprom;
+	int res = 0, err = -ENODEV;
+
+	bus = ssb_pci_dev_to_bus(pdev);
+	if (!bus)
+		goto out;
+	err = -ENOMEM;
+	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	if (!sprom)
+		goto out;
+	err = hex2sprom(sprom, buf, count);
+	if (err) {
+		err = -EINVAL;
+		goto out_kfree;
+	}
+	err = sprom_check_crc(sprom);
+	if (err) {
+		err = -EINVAL;
+		goto out_kfree;
+	}
+
+	/* Use interruptible locking, as the SPROM write might
+	 * be holding the lock for several seconds. So allow userspace
+	 * to cancel operation. */
+	err = -ERESTARTSYS;
+	if (mutex_lock_interruptible(&bus->pci_sprom_mutex))
+		goto out_kfree;
+	err = ssb_devices_freeze(bus);
+	if (err == -EOPNOTSUPP) {
+		ssb_printk(KERN_ERR PFX "SPROM write: Could not freeze devices. "
+			   "No suspend support. Is CONFIG_PM enabled?\n");
+		goto out_unlock;
+	}
+	if (err) {
+		ssb_printk(KERN_ERR PFX "SPROM write: Could not freeze all devices\n");
+		goto out_unlock;
+	}
+	res = sprom_do_write(bus, sprom);
+	err = ssb_devices_thaw(bus);
+	if (err)
+		ssb_printk(KERN_ERR PFX "SPROM write: Could not thaw all devices\n");
+out_unlock:
+	mutex_unlock(&bus->pci_sprom_mutex);
+out_kfree:
+	kfree(sprom);
+out:
+	if (res)
+		return res;
+	return err ? err : count;
+}
+
+static DEVICE_ATTR(ssb_sprom, 0600,
+		   ssb_pci_attr_sprom_show,
+		   ssb_pci_attr_sprom_store);
+
+void ssb_pci_exit(struct ssb_bus *bus)
+{
+	struct pci_dev *pdev;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return;
+
+	pdev = bus->host_pci;
+	device_remove_file(&pdev->dev, &dev_attr_ssb_sprom);
+}
+
+int ssb_pci_init(struct ssb_bus *bus)
+{
+	struct pci_dev *pdev;
+	int err;
+
+	if (bus->bustype != SSB_BUSTYPE_PCI)
+		return 0;
+
+	pdev = bus->host_pci;
+	mutex_init(&bus->pci_sprom_mutex);
+	err = device_create_file(&pdev->dev, &dev_attr_ssb_sprom);
+	if (err)
+		goto out;
+
+out:
+	return err;
+}
diff --git a/drivers/ssb/pcihost_wrapper.c b/drivers/ssb/pcihost_wrapper.c
new file mode 100644
index 0000000..82a10ab
--- /dev/null
+++ b/drivers/ssb/pcihost_wrapper.c
@@ -0,0 +1,104 @@
+/*
+ * Sonics Silicon Backplane
+ * PCI Hostdevice wrapper
+ *
+ * Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>
+ * Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+ * Copyright (c) 2005 Danny van Dyk <kugelfang at gentoo.org>
+ * Copyright (c) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+ * Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/pci.h>
+#include <linux/ssb/ssb.h>
+
+
+#ifdef CONFIG_PM
+static int ssb_pcihost_suspend(struct pci_dev *dev, pm_message_t state)
+{
+	pci_save_state(dev);
+	pci_disable_device(dev);
+	pci_set_power_state(dev, pci_choose_state(dev, state));
+
+	return 0;
+}
+
+static int ssb_pcihost_resume(struct pci_dev *dev)
+{
+	int err;
+
+	pci_set_power_state(dev, 0);
+	err = pci_enable_device(dev);
+	if (err)
+		return err;
+	pci_restore_state(dev);
+
+	return 0;
+}
+#else /* CONFIG_PM */
+# define ssb_pcihost_suspend	NULL
+# define ssb_pcihost_resume	NULL
+#endif /* CONFIG_PM */
+
+static int ssb_pcihost_probe(struct pci_dev *dev,
+			     const struct pci_device_id *id)
+{
+	struct ssb_bus *ssb;
+	int err = -ENOMEM;
+	const char *name;
+
+	ssb = kzalloc(sizeof(*ssb), GFP_KERNEL);
+	if (!ssb)
+		goto out;
+	err = pci_enable_device(dev);
+	if (err)
+		goto err_kfree_ssb;
+	name = dev->dev.bus_id;
+	if (dev->driver && dev->driver->name)
+		name = dev->driver->name;
+	err = pci_request_regions(dev, name);
+	if (err)
+		goto err_pci_disable;
+	pci_set_master(dev);
+
+	err = ssb_bus_pcibus_register(ssb, dev);
+	if (err)
+		goto err_pci_release_regions;
+
+	pci_set_drvdata(dev, ssb);
+
+out:
+	return err;
+
+err_pci_release_regions:
+	pci_release_regions(dev);
+err_pci_disable:
+	pci_disable_device(dev);
+err_kfree_ssb:
+	kfree(ssb);
+	return err;
+}
+
+static void ssb_pcihost_remove(struct pci_dev *dev)
+{
+	struct ssb_bus *ssb = pci_get_drvdata(dev);
+
+	ssb_bus_unregister(ssb);
+	pci_release_regions(dev);
+	pci_disable_device(dev);
+	kfree(ssb);
+	pci_set_drvdata(dev, NULL);
+}
+
+int ssb_pcihost_register(struct pci_driver *driver)
+{
+	driver->probe = ssb_pcihost_probe;
+	driver->remove = ssb_pcihost_remove;
+	driver->suspend = ssb_pcihost_suspend;
+	driver->resume = ssb_pcihost_resume;
+
+	return pci_register_driver(driver);
+}
+EXPORT_SYMBOL(ssb_pcihost_register);
diff --git a/drivers/ssb/pcmcia.c b/drivers/ssb/pcmcia.c
new file mode 100644
index 0000000..b102738
--- /dev/null
+++ b/drivers/ssb/pcmcia.c
@@ -0,0 +1,265 @@
+/*
+ * Sonics Silicon Backplane
+ * PCMCIA-Hostbus related functions
+ *
+ * Copyright 2006 Johannes Berg <johannes at sipsolutions.net>
+ * Copyright 2007 Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/delay.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ciscode.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/cisreg.h>
+
+#include "ssb_private.h"
+
+
+int ssb_pcmcia_switch_coreidx(struct ssb_bus *bus,
+			      u8 coreidx)
+{
+	struct pcmcia_device *pdev = bus->host_pcmcia;
+	int err;
+	int attempts = 0;
+	u32 cur_core;
+	conf_reg_t reg;
+	u32 addr;
+	u32 read_addr;
+
+	addr = (coreidx * SSB_CORE_SIZE) + SSB_ENUM_BASE;
+	while (1) {
+		reg.Action = CS_WRITE;
+		reg.Offset = 0x2E;
+		reg.Value = (addr & 0x0000F000) >> 12;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		reg.Offset = 0x30;
+		reg.Value = (addr & 0x00FF0000) >> 16;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		reg.Offset = 0x32;
+		reg.Value = (addr & 0xFF000000) >> 24;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+
+		read_addr = 0;
+
+		reg.Action = CS_READ;
+		reg.Offset = 0x2E;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		read_addr |= (reg.Value & 0xF) << 12;
+		reg.Offset = 0x30;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		read_addr |= reg.Value << 16;
+		reg.Offset = 0x32;
+		err = pcmcia_access_configuration_register(pdev, &reg);
+		if (err != CS_SUCCESS)
+			goto error;
+		read_addr |= reg.Value << 24;
+
+		cur_core = (read_addr - SSB_ENUM_BASE) / SSB_CORE_SIZE;
+		if (cur_core == coreidx)
+			break;
+
+		if (attempts++ > SSB_BAR0_MAX_RETRIES)
+			goto error;
+		udelay(10);
+	}
+
+	return 0;
+error:
+	ssb_printk(KERN_ERR PFX "Failed to switch to core %u\n", coreidx);
+	return -ENODEV;
+}
+
+int ssb_pcmcia_switch_core(struct ssb_bus *bus,
+			   struct ssb_device *dev)
+{
+	int err;
+	unsigned long flags;
+
+	ssb_dprintk(KERN_INFO PFX
+		    "Switching to %s core, index %d\n",
+		    ssb_core_name(dev->id.coreid),
+		    dev->core_index);
+
+	spin_lock_irqsave(&bus->bar_lock, flags);
+	err = ssb_pcmcia_switch_coreidx(bus, dev->core_index);
+	if (!err)
+		bus->mapped_device = dev;
+	spin_unlock_irqrestore(&bus->bar_lock, flags);
+
+	return err;
+}
+
+int ssb_pcmcia_switch_segment(struct ssb_bus *bus, u8 seg)
+{
+	int attempts = 0;
+	unsigned long flags;
+	conf_reg_t reg;
+	int res, err = 0;
+
+	SSB_WARN_ON((seg != 0) && (seg != 1));
+	reg.Offset = 0x34;
+	reg.Function = 0;
+	spin_lock_irqsave(&bus->bar_lock, flags);
+	while (1) {
+		reg.Action = CS_WRITE;
+		reg.Value = seg;
+		res = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+		if (unlikely(res != CS_SUCCESS))
+			goto error;
+		reg.Value = 0xFF;
+		reg.Action = CS_READ;
+		res = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+		if (unlikely(res != CS_SUCCESS))
+			goto error;
+
+		if (reg.Value == seg)
+			break;
+
+		if (unlikely(attempts++ > SSB_BAR0_MAX_RETRIES))
+			goto error;
+		udelay(10);
+	}
+	bus->mapped_pcmcia_seg = seg;
+out_unlock:
+	spin_unlock_irqrestore(&bus->bar_lock, flags);
+	return err;
+error:
+	ssb_printk(KERN_ERR PFX "Failed to switch pcmcia segment\n");
+	err = -ENODEV;
+	goto out_unlock;
+}
+
+/* These are the main device register access functions.
+ * do_select_core is inline to have the likely hotpath inline.
+ * All unlikely codepaths are out-of-line. */
+static inline int do_select_core(struct ssb_bus *bus,
+				 struct ssb_device *dev,
+				 u16 *offset)
+{
+	int err;
+	u8 need_seg = (*offset >= 0x800) ? 1 : 0;
+
+	if (unlikely(dev != bus->mapped_device)) {
+		err = ssb_pcmcia_switch_core(bus, dev);
+		if (unlikely(err))
+			return err;
+	}
+	if (unlikely(need_seg != bus->mapped_pcmcia_seg)) {
+		err = ssb_pcmcia_switch_segment(bus, need_seg);
+		if (unlikely(err))
+			return err;
+	}
+	if (need_seg == 1)
+		*offset -= 0x800;
+
+	return 0;
+}
+
+static u16 ssb_pcmcia_read16(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+	u16 x;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return 0xFFFF;
+	x = readw(bus->mmio + offset);
+
+	return x;
+}
+
+static u32 ssb_pcmcia_read32(struct ssb_device *dev, u16 offset)
+{
+	struct ssb_bus *bus = dev->bus;
+	u32 x;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return 0xFFFFFFFF;
+	x = readl(bus->mmio + offset);
+
+	return x;
+}
+
+static void ssb_pcmcia_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return;
+	writew(value, bus->mmio + offset);
+}
+
+static void ssb_pcmcia_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	struct ssb_bus *bus = dev->bus;
+
+	if (unlikely(do_select_core(bus, dev, &offset)))
+		return;
+	readw(bus->mmio + offset);
+	writew(value >> 16, bus->mmio + offset + 2);
+	readw(bus->mmio + offset);
+	writew(value, bus->mmio + offset);
+}
+
+/* Not "static", as it's used in main.c */
+const struct ssb_bus_ops ssb_pcmcia_ops = {
+	.read16		= ssb_pcmcia_read16,
+	.read32		= ssb_pcmcia_read32,
+	.write16	= ssb_pcmcia_write16,
+	.write32	= ssb_pcmcia_write32,
+};
+
+int ssb_pcmcia_get_invariants(struct ssb_bus *bus,
+			      struct ssb_init_invariants *iv)
+{
+	//TODO
+	return 0;
+}
+
+int ssb_pcmcia_init(struct ssb_bus *bus)
+{
+	conf_reg_t reg;
+	int err;
+
+	if (bus->bustype != SSB_BUSTYPE_PCMCIA)
+		return 0;
+
+	/* Switch segment to a known state and sync
+	 * bus->mapped_pcmcia_seg with hardware state. */
+	ssb_pcmcia_switch_segment(bus, 0);
+
+	/* Init IRQ routing */
+	reg.Action = CS_READ;
+	reg.Function = 0;
+	if (bus->chip_id == 0x4306)
+		reg.Offset = 0x00;
+	else
+		reg.Offset = 0x80;
+	err = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+	if (err != CS_SUCCESS)
+		goto error;
+	reg.Action = CS_WRITE;
+	reg.Value |= 0x04 | 0x01;
+	err = pcmcia_access_configuration_register(bus->host_pcmcia, &reg);
+	if (err != CS_SUCCESS)
+		goto error;
+
+	return 0;
+error:
+	return -ENODEV;
+}
diff --git a/drivers/ssb/scan.c b/drivers/ssb/scan.c
new file mode 100644
index 0000000..96258c6
--- /dev/null
+++ b/drivers/ssb/scan.c
@@ -0,0 +1,413 @@
+/*
+ * Sonics Silicon Backplane
+ * Bus scanning
+ *
+ * Copyright (C) 2005-2007 Michael Buesch <mb at bu3sch.de>
+ * Copyright (C) 2005 Martin Langer <martin-langer at gmx.de>
+ * Copyright (C) 2005 Stefano Brivio <st3 at riseup.net>
+ * Copyright (C) 2005 Danny van Dyk <kugelfang at gentoo.org>
+ * Copyright (C) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+ * Copyright (C) 2006 Broadcom Corporation.
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/ssb/ssb.h>
+#include <linux/ssb/ssb_regs.h>
+#include <linux/pci.h>
+#include <linux/io.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+
+#include "ssb_private.h"
+
+
+const char *ssb_core_name(u16 coreid)
+{
+	switch (coreid) {
+	case SSB_DEV_CHIPCOMMON:
+		return "ChipCommon";
+	case SSB_DEV_ILINE20:
+		return "ILine 20";
+	case SSB_DEV_SDRAM:
+		return "SDRAM";
+	case SSB_DEV_PCI:
+		return "PCI";
+	case SSB_DEV_MIPS:
+		return "MIPS";
+	case SSB_DEV_ETHERNET:
+		return "Fast Ethernet";
+	case SSB_DEV_V90:
+		return "V90";
+	case SSB_DEV_USB11_HOSTDEV:
+		return "USB 1.1 Hostdev";
+	case SSB_DEV_ADSL:
+		return "ADSL";
+	case SSB_DEV_ILINE100:
+		return "ILine 100";
+	case SSB_DEV_IPSEC:
+		return "IPSEC";
+	case SSB_DEV_PCMCIA:
+		return "PCMCIA";
+	case SSB_DEV_INTERNAL_MEM:
+		return "Internal Memory";
+	case SSB_DEV_MEMC_SDRAM:
+		return "MEMC SDRAM";
+	case SSB_DEV_EXTIF:
+		return "EXTIF";
+	case SSB_DEV_80211:
+		return "IEEE 802.11";
+	case SSB_DEV_MIPS_3302:
+		return "MIPS 3302";
+	case SSB_DEV_USB11_HOST:
+		return "USB 1.1 Host";
+	case SSB_DEV_USB11_DEV:
+		return "USB 1.1 Device";
+	case SSB_DEV_USB20_HOST:
+		return "USB 2.0 Host";
+	case SSB_DEV_USB20_DEV:
+		return "USB 2.0 Device";
+	case SSB_DEV_SDIO_HOST:
+		return "SDIO Host";
+	case SSB_DEV_ROBOSWITCH:
+		return "Roboswitch";
+	case SSB_DEV_PARA_ATA:
+		return "PATA";
+	case SSB_DEV_SATA_XORDMA:
+		return "SATA XOR-DMA";
+	case SSB_DEV_ETHERNET_GBIT:
+		return "GBit Ethernet";
+	case SSB_DEV_PCIE:
+		return "PCI-E";
+	case SSB_DEV_MIMO_PHY:
+		return "MIMO PHY";
+	case SSB_DEV_SRAM_CTRLR:
+		return "SRAM Controller";
+	case SSB_DEV_MINI_MACPHY:
+		return "Mini MACPHY";
+	case SSB_DEV_ARM_1176:
+		return "ARM 1176";
+	case SSB_DEV_ARM_7TDMI:
+		return "ARM 7TDMI";
+	}
+	return "UNKNOWN";
+}
+
+static u16 pcidev_to_chipid(struct pci_dev *pci_dev)
+{
+	u16 chipid_fallback = 0;
+
+	switch (pci_dev->device) {
+	case 0x4301:
+		chipid_fallback = 0x4301;
+		break;
+	case 0x4305 ... 0x4307:
+		chipid_fallback = 0x4307;
+		break;
+	case 0x4403:
+		chipid_fallback = 0x4402;
+		break;
+	case 0x4610 ... 0x4615:
+		chipid_fallback = 0x4610;
+		break;
+	case 0x4710 ... 0x4715:
+		chipid_fallback = 0x4710;
+		break;
+	case 0x4320 ... 0x4325:
+		chipid_fallback = 0x4309;
+		break;
+	case PCI_DEVICE_ID_BCM4401:
+	case PCI_DEVICE_ID_BCM4401B0:
+	case PCI_DEVICE_ID_BCM4401B1:
+		chipid_fallback = 0x4401;
+		break;
+	default:
+		ssb_printk(KERN_ERR PFX
+			   "PCI-ID not in fallback list\n");
+	}
+
+	return chipid_fallback;
+}
+
+static u8 chipid_to_nrcores(u16 chipid)
+{
+	switch (chipid) {
+	case 0x5365:
+		return 7;
+	case 0x4306:
+		return 6;
+	case 0x4310:
+		return 8;
+	case 0x4307:
+	case 0x4301:
+		return 5;
+	case 0x4401:
+	case 0x4402:
+		return 3;
+	case 0x4710:
+	case 0x4610:
+	case 0x4704:
+		return 9;
+	default:
+		ssb_printk(KERN_ERR PFX
+			   "CHIPID not in nrcores fallback list\n");
+	}
+
+	return 1;
+}
+
+static u32 scan_read32(struct ssb_bus *bus, u8 current_coreidx,
+		       u16 offset)
+{
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		offset += current_coreidx * SSB_CORE_SIZE;
+		break;
+	case SSB_BUSTYPE_PCI:
+		break;
+	case SSB_BUSTYPE_PCMCIA:
+		if (offset >= 0x800) {
+			ssb_pcmcia_switch_segment(bus, 1);
+			offset -= 0x800;
+		} else
+			ssb_pcmcia_switch_segment(bus, 0);
+		break;
+	}
+	return readl(bus->mmio + offset);
+}
+
+static int scan_switchcore(struct ssb_bus *bus, u8 coreidx)
+{
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		break;
+	case SSB_BUSTYPE_PCI:
+		return ssb_pci_switch_coreidx(bus, coreidx);
+	case SSB_BUSTYPE_PCMCIA:
+		return ssb_pcmcia_switch_coreidx(bus, coreidx);
+	}
+	return 0;
+}
+
+void ssb_iounmap(struct ssb_bus *bus)
+{
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+	case SSB_BUSTYPE_PCMCIA:
+		iounmap(bus->mmio);
+		break;
+	case SSB_BUSTYPE_PCI:
+#ifdef CONFIG_SSB_PCIHOST
+		pci_iounmap(bus->host_pci, bus->mmio);
+#else
+		SSB_BUG_ON(1); /* Can't reach this code. */
+#endif
+		break;
+	}
+	bus->mmio = NULL;
+	bus->mapped_device = NULL;
+}
+
+static void __iomem *ssb_ioremap(struct ssb_bus *bus,
+				 unsigned long baseaddr)
+{
+	void __iomem *mmio = NULL;
+
+	switch (bus->bustype) {
+	case SSB_BUSTYPE_SSB:
+		/* Only map the first core for now. */
+		/* fallthrough... */
+	case SSB_BUSTYPE_PCMCIA:
+		mmio = ioremap(baseaddr, SSB_CORE_SIZE);
+		break;
+	case SSB_BUSTYPE_PCI:
+#ifdef CONFIG_SSB_PCIHOST
+		mmio = pci_iomap(bus->host_pci, 0, ~0UL);
+#else
+		SSB_BUG_ON(1); /* Can't reach this code. */
+#endif
+		break;
+	}
+
+	return mmio;
+}
+
+static int we_support_multiple_80211_cores(struct ssb_bus *bus)
+{
+	/* More than one 802.11 core is only supported by special chips.
+	 * There are chips with two 802.11 cores, but with dangling
+	 * pins on the second core. Be careful and reject them here.
+	 */
+
+#ifdef CONFIG_SSB_PCIHOST
+	if (bus->bustype == SSB_BUSTYPE_PCI) {
+		if (bus->host_pci->vendor == PCI_VENDOR_ID_BROADCOM &&
+		    bus->host_pci->device == 0x4324)
+			return 1;
+	}
+#endif /* CONFIG_SSB_PCIHOST */
+	return 0;
+}
+
+int ssb_bus_scan(struct ssb_bus *bus,
+		 unsigned long baseaddr)
+{
+	int err = -ENOMEM;
+	void __iomem *mmio;
+	u32 idhi, cc, rev, tmp;
+	int dev_i, i;
+	struct ssb_device *dev;
+	int nr_80211_cores = 0;
+
+	mmio = ssb_ioremap(bus, baseaddr);
+	if (!mmio)
+		goto out;
+	bus->mmio = mmio;
+
+	err = scan_switchcore(bus, 0); /* Switch to first core */
+	if (err)
+		goto err_unmap;
+
+	idhi = scan_read32(bus, 0, SSB_IDHIGH);
+	cc = (idhi & SSB_IDHIGH_CC) >> SSB_IDHIGH_CC_SHIFT;
+	rev = (idhi & SSB_IDHIGH_RCLO);
+	rev |= (idhi & SSB_IDHIGH_RCHI) >> SSB_IDHIGH_RCHI_SHIFT;
+
+	bus->nr_devices = 0;
+	if (cc == SSB_DEV_CHIPCOMMON) {
+		tmp = scan_read32(bus, 0, SSB_CHIPCO_CHIPID);
+
+		bus->chip_id = (tmp & SSB_CHIPCO_IDMASK);
+		bus->chip_rev = (tmp & SSB_CHIPCO_REVMASK) >>
+				SSB_CHIPCO_REVSHIFT;
+		bus->chip_package = (tmp & SSB_CHIPCO_PACKMASK) >>
+				    SSB_CHIPCO_PACKSHIFT;
+		if (rev >= 4) {
+			bus->nr_devices = (tmp & SSB_CHIPCO_NRCORESMASK) >>
+					  SSB_CHIPCO_NRCORESSHIFT;
+		}
+		tmp = scan_read32(bus, 0, SSB_CHIPCO_CAP);
+		bus->chipco.capabilities = tmp;
+	} else {
+		if (bus->bustype == SSB_BUSTYPE_PCI) {
+			bus->chip_id = pcidev_to_chipid(bus->host_pci);
+			pci_read_config_word(bus->host_pci, PCI_REVISION_ID,
+					     &bus->chip_rev);
+			bus->chip_package = 0;
+		} else {
+			bus->chip_id = 0x4710;
+			bus->chip_rev = 0;
+			bus->chip_package = 0;
+		}
+	}
+	if (!bus->nr_devices)
+		bus->nr_devices = chipid_to_nrcores(bus->chip_id);
+	if (bus->nr_devices > ARRAY_SIZE(bus->devices)) {
+		ssb_printk(KERN_ERR PFX
+			   "More than %d ssb cores found (%d)\n",
+			   SSB_MAX_NR_CORES, bus->nr_devices);
+		goto err_unmap;
+	}
+	if (bus->bustype == SSB_BUSTYPE_SSB) {
+		/* Now that we know the number of cores,
+		 * remap the whole IO space for all cores.
+		 */
+		err = -ENOMEM;
+		iounmap(mmio);
+		mmio = ioremap(baseaddr, SSB_CORE_SIZE * bus->nr_devices);
+		if (!mmio)
+			goto out;
+		bus->mmio = mmio;
+	}
+
+	/* Fetch basic information about each core/device */
+	for (i = 0, dev_i = 0; i < bus->nr_devices; i++) {
+		err = scan_switchcore(bus, i);
+		if (err)
+			goto err_unmap;
+		dev = &(bus->devices[dev_i]);
+
+		idhi = scan_read32(bus, i, SSB_IDHIGH);
+		dev->id.coreid = (idhi & SSB_IDHIGH_CC) >> SSB_IDHIGH_CC_SHIFT;
+		dev->id.revision = (idhi & SSB_IDHIGH_RCLO);
+		dev->id.revision |= (idhi & SSB_IDHIGH_RCHI) >> SSB_IDHIGH_RCHI_SHIFT;
+		dev->id.vendor = (idhi & SSB_IDHIGH_VC) >> SSB_IDHIGH_VC_SHIFT;
+		dev->core_index = i;
+		dev->bus = bus;
+		dev->ops = bus->ops;
+
+		ssb_dprintk(KERN_INFO PFX
+			    "Core %d found: %s "
+			    "(cc 0x%03X, rev 0x%02X, vendor 0x%04X)\n",
+			    i, ssb_core_name(dev->id.coreid),
+			    dev->id.coreid, dev->id.revision, dev->id.vendor);
+
+		switch (dev->id.coreid) {
+		case SSB_DEV_80211:
+			nr_80211_cores++;
+			if (nr_80211_cores > 1) {
+				if (!we_support_multiple_80211_cores(bus)) {
+					ssb_dprintk(KERN_INFO PFX "Ignoring additional "
+						    "802.11 core\n");
+					continue;
+				}
+			}
+			break;
+		case SSB_DEV_EXTIF:
+#ifdef CONFIG_SSB_DRIVER_EXTIF
+			if (bus->extif.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple EXTIFs found\n");
+				break;
+			}
+			bus->extif.dev = dev;
+#endif /* CONFIG_SSB_DRIVER_EXTIF */
+			break;
+		case SSB_DEV_CHIPCOMMON:
+			if (bus->chipco.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple ChipCommon found\n");
+				break;
+			}
+			bus->chipco.dev = dev;
+			break;
+		case SSB_DEV_MIPS:
+		case SSB_DEV_MIPS_3302:
+#ifdef CONFIG_SSB_DRIVER_MIPS
+			if (bus->mipscore.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple MIPS cores found\n");
+				break;
+			}
+			bus->mipscore.dev = dev;
+#endif /* CONFIG_SSB_DRIVER_MIPS */
+			break;
+		case SSB_DEV_PCI:
+		case SSB_DEV_PCIE:
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+			if (bus->pcicore.dev) {
+				ssb_printk(KERN_WARNING PFX
+					   "WARNING: Multiple PCI(E) cores found\n");
+				break;
+			}
+			bus->pcicore.dev = dev;
+#endif /* CONFIG_SSB_DRIVER_PCICORE */
+			break;
+		default:
+			break;
+		}
+
+		dev_i++;
+	}
+	bus->nr_devices = dev_i;
+
+	err = 0;
+out:
+	return err;
+err_unmap:
+	ssb_iounmap(bus);
+	goto out;
+}
diff --git a/drivers/ssb/ssb_private.h b/drivers/ssb/ssb_private.h
new file mode 100644
index 0000000..4aa77b4
--- /dev/null
+++ b/drivers/ssb/ssb_private.h
@@ -0,0 +1,122 @@
+#ifndef LINUX_SSB_PRIVATE_H_
+#define LINUX_SSB_PRIVATE_H_
+
+#include <linux/ssb/ssb.h>
+#include <linux/types.h>
+
+
+#define PFX	"ssb: "
+
+#ifdef CONFIG_SSB_SILENT
+# define ssb_printk(fmt, x...)	do { /* nothing */ } while (0)
+#else
+# define ssb_printk		printk
+#endif /* CONFIG_SSB_SILENT */
+
+/* dprintk: Debugging printk; vanishes for non-debug compilation */
+#ifdef CONFIG_SSB_DEBUG
+# define ssb_dprintk(fmt, x...)	ssb_printk(fmt , ##x)
+#else
+# define ssb_dprintk(fmt, x...)	do { /* nothing */ } while (0)
+#endif
+
+#ifdef CONFIG_SSB_DEBUG
+# define SSB_WARN_ON(x)		WARN_ON(x)
+# define SSB_BUG_ON(x)		BUG_ON(x)
+#else
+static inline int __ssb_do_nothing(int x) { return x; }
+# define SSB_WARN_ON(x)		__ssb_do_nothing(unlikely(!!(x)))
+# define SSB_BUG_ON(x)		__ssb_do_nothing(unlikely(!!(x)))
+#endif
+
+
+/* pci.c */
+#ifdef CONFIG_SSB_PCIHOST
+extern int ssb_pci_switch_core(struct ssb_bus *bus,
+			       struct ssb_device *dev);
+extern int ssb_pci_switch_coreidx(struct ssb_bus *bus,
+				  u8 coreidx);
+extern int ssb_pci_xtal(struct ssb_bus *bus, u32 what,
+			int turn_on);
+extern int ssb_pci_get_invariants(struct ssb_bus *bus,
+				  struct ssb_init_invariants *iv);
+extern void ssb_pci_exit(struct ssb_bus *bus);
+extern int ssb_pci_init(struct ssb_bus *bus);
+extern const struct ssb_bus_ops ssb_pci_ops;
+
+#else /* CONFIG_SSB_PCIHOST */
+
+static inline int ssb_pci_switch_core(struct ssb_bus *bus,
+				      struct ssb_device *dev)
+{
+	return 0;
+}
+static inline int ssb_pci_switch_coreidx(struct ssb_bus *bus,
+					 u8 coreidx)
+{
+	return 0;
+}
+static inline int ssb_pci_xtal(struct ssb_bus *bus, u32 what,
+			       int turn_on)
+{
+	return 0;
+}
+static inline void ssb_pci_exit(struct ssb_bus *bus)
+{
+}
+static inline int ssb_pci_init(struct ssb_bus *bus)
+{
+	return 0;
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+
+/* pcmcia.c */
+#ifdef CONFIG_SSB_PCMCIAHOST
+extern int ssb_pcmcia_switch_core(struct ssb_bus *bus,
+				  struct ssb_device *dev);
+extern int ssb_pcmcia_switch_coreidx(struct ssb_bus *bus,
+				     u8 coreidx);
+extern int ssb_pcmcia_switch_segment(struct ssb_bus *bus,
+				     u8 seg);
+extern int ssb_pcmcia_get_invariants(struct ssb_bus *bus,
+				     struct ssb_init_invariants *iv);
+extern int ssb_pcmcia_init(struct ssb_bus *bus);
+extern const struct ssb_bus_ops ssb_pcmcia_ops;
+#else /* CONFIG_SSB_PCMCIAHOST */
+static inline int ssb_pcmcia_switch_core(struct ssb_bus *bus,
+					 struct ssb_device *dev)
+{
+	return 0;
+}
+static inline int ssb_pcmcia_switch_coreidx(struct ssb_bus *bus,
+					    u8 coreidx)
+{
+	return 0;
+}
+static inline int ssb_pcmcia_switch_segment(struct ssb_bus *bus,
+					    u8 seg)
+{
+	return 0;
+}
+static inline int ssb_pcmcia_init(struct ssb_bus *bus)
+{
+	return 0;
+}
+#endif /* CONFIG_SSB_PCMCIAHOST */
+
+
+/* scan.c */
+extern const char *ssb_core_name(u16 coreid);
+extern int ssb_bus_scan(struct ssb_bus *bus,
+			unsigned long baseaddr);
+extern void ssb_iounmap(struct ssb_bus *ssb);
+
+
+/* core.c */
+extern u32 ssb_calc_clock_rate(u32 plltype, u32 n, u32 m);
+extern int ssb_devices_freeze(struct ssb_bus *bus);
+extern int ssb_devices_thaw(struct ssb_bus *bus);
+extern struct ssb_bus *ssb_pci_dev_to_bus(struct pci_dev *pdev);
+
+#endif /* LINUX_SSB_PRIVATE_H_ */
diff --git a/include/linux/ssb/ssb_driver_chipcommon.h b/include/linux/ssb/ssb_driver_chipcommon.h
new file mode 100644
index 0000000..d58c24b
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_chipcommon.h
@@ -0,0 +1,385 @@
+#ifndef LINUX_SSB_CHIPCO_H_
+#define LINUX_SSB_CHIPCO_H_
+
+/* SonicsSiliconBackplane CHIPCOMMON core hardware definitions
+ *
+ * The chipcommon core provides chip identification, SB control,
+ * jtag, 0/1/2 uarts, clock frequency control, a watchdog interrupt timer,
+ * gpio interface, extbus, and support for serial and parallel flashes.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, Michael Buesch <mb at bu3sch.de>
+ *
+ * Licensed under the GPL version 2. See COPYING for details.
+ */
+
+/** ChipCommon core registers. **/
+
+#define SSB_CHIPCO_CHIPID		0x0000
+#define  SSB_CHIPCO_IDMASK		0x0000FFFF
+#define  SSB_CHIPCO_REVMASK		0x000F0000
+#define  SSB_CHIPCO_REVSHIFT		16
+#define  SSB_CHIPCO_PACKMASK		0x00F00000
+#define  SSB_CHIPCO_PACKSHIFT		20
+#define  SSB_CHIPCO_NRCORESMASK		0x0F000000
+#define  SSB_CHIPCO_NRCORESSHIFT	24
+#define SSB_CHIPCO_CAP	 		0x0004		/* Capabilities */
+#define  SSB_CHIPCO_CAP_NRUART		0x00000003	/* # of UARTs */
+#define  SSB_CHIPCO_CAP_MIPSEB		0x00000004	/* MIPS in BigEndian Mode */
+#define  SSB_CHIPCO_CAP_UARTCLK		0x00000018	/* UART clock select */
+#define   SSB_CHIPCO_CAP_UARTCLK_INT	0x00000008	/* UARTs are driven by internal divided clock */
+#define  SSB_CHIPCO_CAP_UARTGPIO	0x00000020	/* UARTs on GPIO 15-12 */
+#define  SSB_CHIPCO_CAP_EXTBUS		0x000000C0	/* External buses present */
+#define  SSB_CHIPCO_CAP_FLASHT		0x00000700	/* Flash Type */
+#define   SSB_CHIPCO_FLASHT_NONE	0x00000000	/* No flash */
+#define   SSB_CHIPCO_FLASHT_STSER	0x00000100	/* ST serial flash */
+#define   SSB_CHIPCO_FLASHT_ATSER	0x00000200	/* Atmel serial flash */
+#define	  SSB_CHIPCO_FLASHT_PARA	0x00000700	/* Parallel flash */
+#define  SSB_CHIPCO_CAP_PLLT		0x00038000	/* PLL Type */
+#define   SSB_PLLTYPE_NONE		0x00000000
+#define   SSB_PLLTYPE_1			0x00010000	/* 48Mhz base, 3 dividers */
+#define   SSB_PLLTYPE_2			0x00020000	/* 48Mhz, 4 dividers */
+#define   SSB_PLLTYPE_3			0x00030000	/* 25Mhz, 2 dividers */
+#define   SSB_PLLTYPE_4			0x00008000	/* 48Mhz, 4 dividers */
+#define   SSB_PLLTYPE_5			0x00018000	/* 25Mhz, 4 dividers */
+#define   SSB_PLLTYPE_6			0x00028000	/* 100/200 or 120/240 only */
+#define   SSB_PLLTYPE_7			0x00038000	/* 25Mhz, 4 dividers */
+#define  SSB_CHIPCO_CAP_PCTL		0x00040000	/* Power Control */
+#define  SSB_CHIPCO_CAP_OTPS		0x00380000	/* OTP size */
+#define  SSB_CHIPCO_CAP_OTPS_SHIFT	19
+#define  SSB_CHIPCO_CAP_OTPS_BASE	5
+#define  SSB_CHIPCO_CAP_JTAGM		0x00400000	/* JTAG master present */
+#define  SSB_CHIPCO_CAP_BROM		0x00800000	/* Internal boot ROM active */
+#define  SSB_CHIPCO_CAP_64BIT		0x08000000	/* 64-bit Backplane */
+#define SSB_CHIPCO_CORECTL		0x0008
+#define  SSB_CHIPCO_CORECTL_UARTCLK0	0x00000001	/* Drive UART with internal clock */
+#define	 SSB_CHIPCO_CORECTL_SE		0x00000002	/* sync clk out enable (corerev >= 3) */
+#define SSB_CHIPCO_BIST			0x000C
+#define SSB_CHIPCO_OTPS			0x0010		/* OTP status */
+#define	 SSB_CHIPCO_OTPS_PROGFAIL	0x80000000
+#define	 SSB_CHIPCO_OTPS_PROTECT	0x00000007
+#define	 SSB_CHIPCO_OTPS_HW_PROTECT	0x00000001
+#define	 SSB_CHIPCO_OTPS_SW_PROTECT	0x00000002
+#define	 SSB_CHIPCO_OTPS_CID_PROTECT	0x00000004
+#define SSB_CHIPCO_OTPC			0x0014		/* OTP control */
+#define	 SSB_CHIPCO_OTPC_RECWAIT	0xFF000000
+#define	 SSB_CHIPCO_OTPC_PROGWAIT	0x00FFFF00
+#define	 SSB_CHIPCO_OTPC_PRW_SHIFT	8
+#define	 SSB_CHIPCO_OTPC_MAXFAIL	0x00000038
+#define	 SSB_CHIPCO_OTPC_VSEL		0x00000006
+#define	 SSB_CHIPCO_OTPC_SELVL		0x00000001
+#define SSB_CHIPCO_OTPP			0x0018		/* OTP prog */
+#define	 SSB_CHIPCO_OTPP_COL		0x000000FF
+#define	 SSB_CHIPCO_OTPP_ROW		0x0000FF00
+#define	 SSB_CHIPCO_OTPP_ROW_SHIFT	8
+#define	 SSB_CHIPCO_OTPP_READERR	0x10000000
+#define	 SSB_CHIPCO_OTPP_VALUE		0x20000000
+#define	 SSB_CHIPCO_OTPP_READ		0x40000000
+#define	 SSB_CHIPCO_OTPP_START		0x80000000
+#define	 SSB_CHIPCO_OTPP_BUSY		0x80000000
+#define SSB_CHIPCO_IRQSTAT		0x0020
+#define SSB_CHIPCO_IRQMASK		0x0024
+#define	 SSB_CHIPCO_IRQ_GPIO		0x00000001	/* gpio intr */
+#define	 SSB_CHIPCO_IRQ_EXT		0x00000002	/* ro: ext intr pin (corerev >= 3) */
+#define	 SSB_CHIPCO_IRQ_WDRESET		0x80000000	/* watchdog reset occurred */
+#define SSB_CHIPCO_CHIPCTL		0x0028		/* Rev >= 11 only */
+#define SSB_CHIPCO_CHIPSTAT		0x002C		/* Rev >= 11 only */
+#define SSB_CHIPCO_JCMD			0x0030		/* Rev >= 10 only */
+#define  SSB_CHIPCO_JCMD_START		0x80000000
+#define  SSB_CHIPCO_JCMD_BUSY		0x80000000
+#define  SSB_CHIPCO_JCMD_PAUSE		0x40000000
+#define  SSB_CHIPCO_JCMD0_ACC_MASK	0x0000F000
+#define  SSB_CHIPCO_JCMD0_ACC_IRDR	0x00000000
+#define  SSB_CHIPCO_JCMD0_ACC_DR	0x00001000
+#define  SSB_CHIPCO_JCMD0_ACC_IR	0x00002000
+#define  SSB_CHIPCO_JCMD0_ACC_RESET	0x00003000
+#define  SSB_CHIPCO_JCMD0_ACC_IRPDR	0x00004000
+#define  SSB_CHIPCO_JCMD0_ACC_PDR	0x00005000
+#define  SSB_CHIPCO_JCMD0_IRW_MASK	0x00000F00
+#define  SSB_CHIPCO_JCMD_ACC_MASK	0x000F0000	/* Changes for corerev 11 */
+#define  SSB_CHIPCO_JCMD_ACC_IRDR	0x00000000
+#define  SSB_CHIPCO_JCMD_ACC_DR		0x00010000
+#define  SSB_CHIPCO_JCMD_ACC_IR		0x00020000
+#define  SSB_CHIPCO_JCMD_ACC_RESET	0x00030000
+#define  SSB_CHIPCO_JCMD_ACC_IRPDR	0x00040000
+#define  SSB_CHIPCO_JCMD_ACC_PDR	0x00050000
+#define  SSB_CHIPCO_JCMD_IRW_MASK	0x00001F00
+#define  SSB_CHIPCO_JCMD_IRW_SHIFT	8
+#define  SSB_CHIPCO_JCMD_DRW_MASK	0x0000003F
+#define SSB_CHIPCO_JIR			0x0034		/* Rev >= 10 only */
+#define SSB_CHIPCO_JDR			0x0038		/* Rev >= 10 only */
+#define SSB_CHIPCO_JCTL			0x003C		/* Rev >= 10 only */
+#define  SSB_CHIPCO_JCTL_FORCE_CLK	4		/* Force clock */
+#define  SSB_CHIPCO_JCTL_EXT_EN		2		/* Enable external targets */
+#define  SSB_CHIPCO_JCTL_EN		1		/* Enable Jtag master */
+#define SSB_CHIPCO_FLASHCTL		0x0040
+#define  SSB_CHIPCO_FLASHCTL_START	0x80000000
+#define  SSB_CHIPCO_FLASHCTL_BUSY	SSB_CHIPCO_FLASHCTL_START
+#define SSB_CHIPCO_FLASHADDR		0x0044
+#define SSB_CHIPCO_FLASHDATA		0x0048
+#define SSB_CHIPCO_BCAST_ADDR		0x0050
+#define SSB_CHIPCO_BCAST_DATA		0x0054
+#define SSB_CHIPCO_GPIOIN		0x0060
+#define SSB_CHIPCO_GPIOOUT		0x0064
+#define SSB_CHIPCO_GPIOOUTEN		0x0068
+#define SSB_CHIPCO_GPIOCTL		0x006C
+#define SSB_CHIPCO_GPIOPOL		0x0070
+#define SSB_CHIPCO_GPIOIRQ		0x0074
+#define SSB_CHIPCO_WATCHDOG		0x0080
+#define SSB_CHIPCO_GPIOTIMER		0x0088		/* LED powersave (corerev >= 16) */
+#define  SSB_CHIPCO_GPIOTIMER_ONTIME_SHIFT	16
+#define SSB_CHIPCO_GPIOTOUTM		0x008C		/* LED powersave (corerev >= 16) */
+#define SSB_CHIPCO_CLOCK_N		0x0090
+#define SSB_CHIPCO_CLOCK_SB		0x0094
+#define SSB_CHIPCO_CLOCK_PCI		0x0098
+#define SSB_CHIPCO_CLOCK_M2		0x009C
+#define SSB_CHIPCO_CLOCK_MIPS		0x00A0
+#define SSB_CHIPCO_CLKDIV		0x00A4		/* Rev >= 3 only */
+#define	 SSB_CHIPCO_CLKDIV_SFLASH	0x0F000000
+#define	 SSB_CHIPCO_CLKDIV_SFLASH_SHIFT	24
+#define	 SSB_CHIPCO_CLKDIV_OTP		0x000F0000
+#define	 SSB_CHIPCO_CLKDIV_OTP_SHIFT	16
+#define	 SSB_CHIPCO_CLKDIV_JTAG		0x00000F00
+#define	 SSB_CHIPCO_CLKDIV_JTAG_SHIFT	8
+#define	 SSB_CHIPCO_CLKDIV_UART		0x000000FF
+#define SSB_CHIPCO_PLLONDELAY		0x00B0		/* Rev >= 4 only */
+#define SSB_CHIPCO_FREFSELDELAY		0x00B4		/* Rev >= 4 only */
+#define SSB_CHIPCO_SLOWCLKCTL		0x00B8		/* 6 <= Rev <= 9 only */
+#define  SSB_CHIPCO_SLOWCLKCTL_SRC	0x00000007	/* slow clock source mask */
+#define	  SSB_CHIPCO_SLOWCLKCTL_SRC_LPO		0x00000000	/* source of slow clock is LPO */
+#define   SSB_CHIPCO_SLOWCLKCTL_SRC_XTAL	0x00000001	/* source of slow clock is crystal */
+#define	  SSB_CHIPCO_SLOECLKCTL_SRC_PCI		0x00000002	/* source of slow clock is PCI */
+#define  SSB_CHIPCO_SLOWCLKCTL_LPOFREQ	0x00000200	/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
+#define  SSB_CHIPCO_SLOWCLKCTL_LPOPD	0x00000400	/* LPOPowerDown, 1: LPO is disabled, 0: LPO is enabled */
+#define  SSB_CHIPCO_SLOWCLKCTL_FSLOW	0x00000800	/* ForceSlowClk, 1: sb/cores running on slow clock, 0: power logic control */
+#define  SSB_CHIPCO_SLOWCLKCTL_IPLL	0x00001000	/* IgnorePllOffReq, 1/0: power logic ignores/honors PLL clock disable requests from core */
+#define  SSB_CHIPCO_SLOWCLKCTL_ENXTAL	0x00002000	/* XtalControlEn, 1/0: power logic does/doesn't disable crystal when appropriate */
+#define  SSB_CHIPCO_SLOWCLKCTL_XTALPU	0x00004000	/* XtalPU (RO), 1/0: crystal running/disabled */
+#define  SSB_CHIPCO_SLOWCLKCTL_CLKDIV	0xFFFF0000	/* ClockDivider (SlowClk = 1/(4+divisor)) */
+#define  SSB_CHIPCO_SLOWCLKCTL_CLKDIV_SHIFT	16
+#define SSB_CHIPCO_SYSCLKCTL		0x00C0		/* Rev >= 3 only */
+#define	 SSB_CHIPCO_SYSCLKCTL_IDLPEN	0x00000001	/* ILPen: Enable Idle Low Power */
+#define	 SSB_CHIPCO_SYSCLKCTL_ALPEN	0x00000002	/* ALPen: Enable Active Low Power */
+#define	 SSB_CHIPCO_SYSCLKCTL_PLLEN	0x00000004	/* ForcePLLOn */
+#define	 SSB_CHIPCO_SYSCLKCTL_FORCEALP	0x00000008	/* Force ALP (or HT if ALPen is not set */
+#define	 SSB_CHIPCO_SYSCLKCTL_FORCEHT	0x00000010	/* Force HT */
+#define  SSB_CHIPCO_SYSCLKCTL_CLKDIV	0xFFFF0000	/* ClkDiv  (ILP = 1/(4+divisor)) */
+#define  SSB_CHIPCO_SYSCLKCTL_CLKDIV_SHIFT	16
+#define SSB_CHIPCO_CLKSTSTR		0x00C4		/* Rev >= 3 only */
+#define SSB_CHIPCO_PCMCIA_CFG		0x0100
+#define SSB_CHIPCO_PCMCIA_MEMWAIT	0x0104
+#define SSB_CHIPCO_PCMCIA_ATTRWAIT	0x0108
+#define SSB_CHIPCO_PCMCIA_IOWAIT	0x010C
+#define SSB_CHIPCO_IDE_CFG		0x0110
+#define SSB_CHIPCO_IDE_MEMWAIT		0x0114
+#define SSB_CHIPCO_IDE_ATTRWAIT		0x0118
+#define SSB_CHIPCO_IDE_IOWAIT		0x011C
+#define SSB_CHIPCO_PROG_CFG		0x0120
+#define SSB_CHIPCO_PROG_WAITCNT		0x0124
+#define SSB_CHIPCO_FLASH_CFG		0x0128
+#define SSB_CHIPCO_FLASH_WAITCNT	0x012C
+#define SSB_CHIPCO_UART0_DATA		0x0300
+#define SSB_CHIPCO_UART0_IMR		0x0304
+#define SSB_CHIPCO_UART0_FCR		0x0308
+#define SSB_CHIPCO_UART0_LCR		0x030C
+#define SSB_CHIPCO_UART0_MCR		0x0310
+#define SSB_CHIPCO_UART0_LSR		0x0314
+#define SSB_CHIPCO_UART0_MSR		0x0318
+#define SSB_CHIPCO_UART0_SCRATCH	0x031C
+#define SSB_CHIPCO_UART1_DATA		0x0400
+#define SSB_CHIPCO_UART1_IMR		0x0404
+#define SSB_CHIPCO_UART1_FCR		0x0408
+#define SSB_CHIPCO_UART1_LCR		0x040C
+#define SSB_CHIPCO_UART1_MCR		0x0410
+#define SSB_CHIPCO_UART1_LSR		0x0414
+#define SSB_CHIPCO_UART1_MSR		0x0418
+#define SSB_CHIPCO_UART1_SCRATCH	0x041C
+
+
+
+/** Clockcontrol masks and values **/
+
+/* SSB_CHIPCO_CLOCK_N */
+#define	SSB_CHIPCO_CLK_N1		0x0000003F	/* n1 control */
+#define	SSB_CHIPCO_CLK_N2		0x00003F00	/* n2 control */
+#define	SSB_CHIPCO_CLK_N2_SHIFT		8
+#define	SSB_CHIPCO_CLK_PLLC		0x000F0000	/* pll control */
+#define	SSB_CHIPCO_CLK_PLLC_SHIFT	16
+
+/* SSB_CHIPCO_CLOCK_SB/PCI/UART */
+#define	SSB_CHIPCO_CLK_M1		0x0000003F	/* m1 control */
+#define	SSB_CHIPCO_CLK_M2		0x00003F00	/* m2 control */
+#define	SSB_CHIPCO_CLK_M2_SHIFT		8
+#define	SSB_CHIPCO_CLK_M3		0x003F0000	/* m3 control */
+#define	SSB_CHIPCO_CLK_M3_SHIFT		16
+#define	SSB_CHIPCO_CLK_MC		0x1F000000	/* mux control */
+#define	SSB_CHIPCO_CLK_MC_SHIFT		24
+
+/* N3M Clock control magic field values */
+#define	SSB_CHIPCO_CLK_F6_2		0x02		/* A factor of 2 in */
+#define	SSB_CHIPCO_CLK_F6_3		0x03		/* 6-bit fields like */
+#define	SSB_CHIPCO_CLK_F6_4		0x05		/* N1, M1 or M3 */
+#define	SSB_CHIPCO_CLK_F6_5		0x09
+#define	SSB_CHIPCO_CLK_F6_6		0x11
+#define	SSB_CHIPCO_CLK_F6_7		0x21
+
+#define	SSB_CHIPCO_CLK_F5_BIAS		5		/* 5-bit fields get this added */
+
+#define	SSB_CHIPCO_CLK_MC_BYPASS	0x08
+#define	SSB_CHIPCO_CLK_MC_M1		0x04
+#define	SSB_CHIPCO_CLK_MC_M1M2		0x02
+#define	SSB_CHIPCO_CLK_MC_M1M2M3	0x01
+#define	SSB_CHIPCO_CLK_MC_M1M3		0x11
+
+/* Type 2 Clock control magic field values */
+#define	SSB_CHIPCO_CLK_T2_BIAS		2		/* n1, n2, m1 & m3 bias */
+#define	SSB_CHIPCO_CLK_T2M2_BIAS	3		/* m2 bias */
+
+#define	SSB_CHIPCO_CLK_T2MC_M1BYP	1
+#define	SSB_CHIPCO_CLK_T2MC_M2BYP	2
+#define	SSB_CHIPCO_CLK_T2MC_M3BYP	4
+
+/* Type 6 Clock control magic field values */
+#define	SSB_CHIPCO_CLK_T6_MMASK		1		/* bits of interest in m */
+#define	SSB_CHIPCO_CLK_T6_M0		120000000	/* sb clock for m = 0 */
+#define	SSB_CHIPCO_CLK_T6_M1		100000000	/* sb clock for m = 1 */
+#define	SSB_CHIPCO_CLK_SB2MIPS_T6(sb)	(2 * (sb))
+
+/* Common clock base */
+#define	SSB_CHIPCO_CLK_BASE1		24000000	/* Half the clock freq */
+#define SSB_CHIPCO_CLK_BASE2		12500000	/* Alternate crystal on some PLL's */
+
+/* Clock control values for 200Mhz in 5350 */
+#define	SSB_CHIPCO_CLK_5350_N		0x0311
+#define	SSB_CHIPCO_CLK_5350_M		0x04020009
+
+
+/** Bits in the config registers **/
+
+#define	SSB_CHIPCO_CFG_EN		0x0001		/* Enable */
+#define	SSB_CHIPCO_CFG_EXTM		0x000E		/* Extif Mode */
+#define	 SSB_CHIPCO_CFG_EXTM_ASYNC	0x0002		/* Async/Parallel flash */
+#define	 SSB_CHIPCO_CFG_EXTM_SYNC	0x0004		/* Synchronous */
+#define	 SSB_CHIPCO_CFG_EXTM_PCMCIA	0x0008		/* PCMCIA */
+#define	 SSB_CHIPCO_CFG_EXTM_IDE	0x000A		/* IDE */
+#define	SSB_CHIPCO_CFG_DS16		0x0010		/* Data size, 0=8bit, 1=16bit */
+#define	SSB_CHIPCO_CFG_CLKDIV		0x0060		/* Sync: Clock divisor */
+#define	SSB_CHIPCO_CFG_CLKEN		0x0080		/* Sync: Clock enable */
+#define	SSB_CHIPCO_CFG_BSTRO		0x0100		/* Sync: Size/Bytestrobe */
+
+
+/** Flash-specific control/status values */
+
+/* flashcontrol opcodes for ST flashes */
+#define SSB_CHIPCO_FLASHCTL_ST_WREN	0x0006		/* Write Enable */
+#define SSB_CHIPCO_FLASHCTL_ST_WRDIS	0x0004		/* Write Disable */
+#define SSB_CHIPCO_FLASHCTL_ST_RDSR	0x0105		/* Read Status Register */
+#define SSB_CHIPCO_FLASHCTL_ST_WRSR	0x0101		/* Write Status Register */
+#define SSB_CHIPCO_FLASHCTL_ST_READ	0x0303		/* Read Data Bytes */
+#define SSB_CHIPCO_FLASHCTL_ST_PP	0x0302		/* Page Program */
+#define SSB_CHIPCO_FLASHCTL_ST_SE	0x02D8		/* Sector Erase */
+#define SSB_CHIPCO_FLASHCTL_ST_BE	0x00C7		/* Bulk Erase */
+#define SSB_CHIPCO_FLASHCTL_ST_DP	0x00B9		/* Deep Power-down */
+#define SSB_CHIPCO_FLASHCTL_ST_RSIG	0x03AB		/* Read Electronic Signature */
+
+/* Status register bits for ST flashes */
+#define SSB_CHIPCO_FLASHSTA_ST_WIP	0x01		/* Write In Progress */
+#define SSB_CHIPCO_FLASHSTA_ST_WEL	0x02		/* Write Enable Latch */
+#define SSB_CHIPCO_FLASHSTA_ST_BP	0x1C		/* Block Protect */
+#define SSB_CHIPCO_FLASHSTA_ST_BP_SHIFT	2
+#define SSB_CHIPCO_FLASHSTA_ST_SRWD	0x80		/* Status Register Write Disable */
+
+/* flashcontrol opcodes for Atmel flashes */
+#define SSB_CHIPCO_FLASHCTL_AT_READ		0x07E8
+#define SSB_CHIPCO_FLASHCTL_AT_PAGE_READ	0x07D2
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_READ	/* FIXME */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_READ	/* FIXME */
+#define SSB_CHIPCO_FLASHCTL_AT_STATUS		0x01D7
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_WRITE	0x0384
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_WRITE	0x0387
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_ERASE_PRGM	0x0283	/* Erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_ERASE_PRGM	0x0286	/* Erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_PROGRAM	0x0288
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_PROGRAM	0x0289
+#define SSB_CHIPCO_FLASHCTL_AT_PAGE_ERASE	0x0281
+#define SSB_CHIPCO_FLASHCTL_AT_BLOCK_ERASE	0x0250
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_WRER_PRGM	0x0382	/* Write erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_WRER_PRGM	0x0385	/* Write erase program */
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_LOAD	0x0253
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_LOAD	0x0255
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_COMPARE	0x0260
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_COMPARE	0x0261
+#define SSB_CHIPCO_FLASHCTL_AT_BUF1_REPROGRAM	0x0258
+#define SSB_CHIPCO_FLASHCTL_AT_BUF2_REPROGRAM	0x0259
+
+/* Status register bits for Atmel flashes */
+#define SSB_CHIPCO_FLASHSTA_AT_READY	0x80
+#define SSB_CHIPCO_FLASHSTA_AT_MISMATCH	0x40
+#define SSB_CHIPCO_FLASHSTA_AT_ID	0x38
+#define SSB_CHIPCO_FLASHSTA_AT_ID_SHIFT	3
+
+
+/** OTP **/
+
+/* OTP regions */
+#define	SSB_CHIPCO_OTP_HW_REGION	SSB_CHIPCO_OTPS_HW_PROTECT
+#define	SSB_CHIPCO_OTP_SW_REGION	SSB_CHIPCO_OTPS_SW_PROTECT
+#define	SSB_CHIPCO_OTP_CID_REGION	SSB_CHIPCO_OTPS_CID_PROTECT
+
+/* OTP regions (Byte offsets from otp size) */
+#define	SSB_CHIPCO_OTP_SWLIM_OFF	(-8)
+#define	SSB_CHIPCO_OTP_CIDBASE_OFF	0
+#define	SSB_CHIPCO_OTP_CIDLIM_OFF	8
+
+/* Predefined OTP words (Word offset from otp size) */
+#define	SSB_CHIPCO_OTP_BOUNDARY_OFF	(-4)
+#define	SSB_CHIPCO_OTP_HWSIGN_OFF	(-3)
+#define	SSB_CHIPCO_OTP_SWSIGN_OFF	(-2)
+#define	SSB_CHIPCO_OTP_CIDSIGN_OFF	(-1)
+
+#define	SSB_CHIPCO_OTP_CID_OFF		0
+#define	SSB_CHIPCO_OTP_PKG_OFF		1
+#define	SSB_CHIPCO_OTP_FID_OFF		2
+#define	SSB_CHIPCO_OTP_RSV_OFF		3
+#define	SSB_CHIPCO_OTP_LIM_OFF		4
+
+#define	SSB_CHIPCO_OTP_SIGNATURE	0x578A
+#define	SSB_CHIPCO_OTP_MAGIC		0x4E56
+
+
+struct ssb_device;
+struct ssb_serial_port;
+
+struct ssb_chipcommon {
+	struct ssb_device *dev;
+	u32 capabilities;
+	/* Fast Powerup Delay constant */
+	u16 fast_pwrup_delay;
+};
+
+extern void ssb_chipcommon_init(struct ssb_chipcommon *cc);
+
+#include <linux/pm.h>
+extern void ssb_chipco_suspend(struct ssb_chipcommon *cc, pm_message_t state);
+extern void ssb_chipco_resume(struct ssb_chipcommon *cc);
+
+extern void ssb_chipco_get_clockcontrol(struct ssb_chipcommon *cc,
+					u32 *plltype, u32 *n, u32 *m);
+extern void ssb_chipco_timing_init(struct ssb_chipcommon *cc,
+				   unsigned long ns_per_cycle);
+
+enum ssb_clkmode {
+	SSB_CLKMODE_SLOW,
+	SSB_CLKMODE_FAST,
+	SSB_CLKMODE_DYNAMIC,
+};
+
+extern void ssb_chipco_set_clockmode(struct ssb_chipcommon *cc,
+				     enum ssb_clkmode mode);
+
+#ifdef CONFIG_SSB_SERIAL
+extern int ssb_chipco_serial_init(struct ssb_chipcommon *cc,
+				  struct ssb_serial_port *ports);
+#endif /* CONFIG_SSB_SERIAL */
+
+#endif /* LINUX_SSB_CHIPCO_H_ */
diff --git a/include/linux/ssb/ssb_driver_extif.h b/include/linux/ssb/ssb_driver_extif.h
new file mode 100644
index 0000000..00de749
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_extif.h
@@ -0,0 +1,160 @@
+/*
+ * Hardware-specific External Interface I/O core definitions
+ * for the BCM47xx family of SiliconBackplane-based chips.
+ *
+ * The External Interface core supports a total of three external chip selects
+ * supporting external interfaces. One of the external chip selects is
+ * used for Flash, one is used for PCMCIA, and the other may be
+ * programmed to support either a synchronous interface or an
+ * asynchronous interface. The asynchronous interface can be used to
+ * support external devices such as UARTs and the BCM2019 Bluetooth
+ * baseband processor.
+ * The external interface core also contains 2 on-chip 16550 UARTs, clock
+ * frequency control, a watchdog interrupt timer, and a GPIO interface.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, Michael Buesch
+ *
+ * Licensed under the GPL version 2. See COPYING for details.
+ */
+#ifndef LINUX_SSB_EXTIFCORE_H_
+#define LINUX_SSB_EXTIFCORE_H_
+
+struct ssb_extif {
+	struct ssb_device *dev;
+};
+
+/* external interface address space */
+#define	SSB_EXTIF_PCMCIA_MEMBASE(x)	(x)
+#define	SSB_EXTIF_PCMCIA_IOBASE(x)	((x) + 0x100000)
+#define	SSB_EXTIF_PCMCIA_CFGBASE(x)	((x) + 0x200000)
+#define	SSB_EXTIF_CFGIF_BASE(x)		((x) + 0x800000)
+#define	SSB_EXTIF_FLASH_BASE(x)		((x) + 0xc00000)
+
+#define SSB_EXTIF_NR_GPIOOUT		5
+/* GPIO NOTE:
+ * The multiple instances of output and output enable registers
+ * are present to allow driver software for multiple cores to control
+ * gpio outputs without needing to share a single register pair.
+ * Use the following helper macro to get a register offset value.
+ */
+#define SSB_EXTIF_GPIO_OUT(index)	({		\
+	BUILD_BUG_ON(index >= SSB_EXTIF_NR_GPIOOUT);	\
+	SSB_EXTIF_GPIO_OUT_BASE + ((index) * 8);	\
+					})
+#define SSB_EXTIF_GPIO_OUTEN(index)	({		\
+	BUILD_BUG_ON(index >= SSB_EXTIF_NR_GPIOOUT);	\
+	SSB_EXTIF_GPIO_OUTEN_BASE + ((index) * 8);	\
+					})
+
+/** EXTIF core registers **/
+
+#define SSB_EXTIF_CTL			0x0000
+#define  SSB_EXTIF_CTL_UARTEN		(1 << 0) /* UART enable */
+#define SSB_EXTIF_EXTSTAT		0x0004
+#define  SSB_EXTIF_EXTSTAT_EMODE	(1 << 0) /* Endian mode (ro) */
+#define  SSB_EXTIF_EXTSTAT_EIRQPIN	(1 << 1) /* External interrupt pin (ro) */
+#define  SSB_EXTIF_EXTSTAT_GPIOIRQPIN	(1 << 2) /* GPIO interrupt pin (ro) */
+#define SSB_EXTIF_PCMCIA_CFG		0x0010
+#define SSB_EXTIF_PCMCIA_MEMWAIT	0x0014
+#define SSB_EXTIF_PCMCIA_ATTRWAIT	0x0018
+#define SSB_EXTIF_PCMCIA_IOWAIT		0x001C
+#define SSB_EXTIF_PROG_CFG		0x0020
+#define SSB_EXTIF_PROG_WAITCNT		0x0024
+#define SSB_EXTIF_FLASH_CFG		0x0028
+#define SSB_EXTIF_FLASH_WAITCNT		0x002C
+#define SSB_EXTIF_WATCHDOG		0x0040
+#define SSB_EXTIF_CLOCK_N		0x0044
+#define SSB_EXTIF_CLOCK_SB		0x0048
+#define SSB_EXTIF_CLOCK_PCI		0x004C
+#define SSB_EXTIF_CLOCK_MII		0x0050
+#define SSB_EXTIF_GPIO_IN		0x0060
+#define SSB_EXTIF_GPIO_OUT_BASE		0x0064
+#define SSB_EXTIF_GPIO_OUTEN_BASE	0x0068
+#define SSB_EXTIF_EJTAG_OUTEN		0x0090
+#define SSB_EXTIF_GPIO_INTPOL		0x0094
+#define SSB_EXTIF_GPIO_INTMASK		0x0098
+#define SSB_EXTIF_UART_DATA		0x0300
+#define SSB_EXTIF_UART_TIMER		0x0310
+#define SSB_EXTIF_UART_FCR		0x0320
+#define SSB_EXTIF_UART_LCR		0x0330
+#define SSB_EXTIF_UART_MCR		0x0340
+#define SSB_EXTIF_UART_LSR		0x0350
+#define SSB_EXTIF_UART_MSR		0x0360
+#define SSB_EXTIF_UART_SCRATCH		0x0370
+
+
+
+
+/* pcmcia/prog/flash_config */
+#define	SSB_EXTCFG_EN			(1 << 0)	/* enable */
+#define	SSB_EXTCFG_MODE			0xE		/* mode */
+#define	SSB_EXTCFG_MODE_SHIFT		1
+#define	 SSB_EXTCFG_MODE_FLASH		0x0		/* flash/asynchronous mode */
+#define	 SSB_EXTCFG_MODE_SYNC		0x2		/* synchronous mode */
+#define	 SSB_EXTCFG_MODE_PCMCIA		0x4		/* pcmcia mode */
+#define	SSB_EXTCFG_DS16			(1 << 4)	/* destsize:  0=8bit, 1=16bit */
+#define	SSB_EXTCFG_BSWAP		(1 << 5)	/* byteswap */
+#define	SSB_EXTCFG_CLKDIV		0xC0		/* clock divider */
+#define	SSB_EXTCFG_CLKDIV_SHIFT		6
+#define	 SSB_EXTCFG_CLKDIV_2		0x0		/* backplane/2 */
+#define	 SSB_EXTCFG_CLKDIV_3		0x40		/* backplane/3 */
+#define	 SSB_EXTCFG_CLKDIV_4		0x80		/* backplane/4 */
+#define	SSB_EXTCFG_CLKEN		(1 << 8)	/* clock enable */
+#define	SSB_EXTCFG_STROBE		(1 << 9)	/* size/bytestrobe (synch only) */
+
+/* pcmcia_memwait */
+#define	SSB_PCMCIA_MEMW_0		0x0000003F	/* waitcount0 */
+#define	SSB_PCMCIA_MEMW_1		0x00001F00	/* waitcount1 */
+#define	SSB_PCMCIA_MEMW_1_SHIFT		8
+#define	SSB_PCMCIA_MEMW_2		0x001F0000	/* waitcount2 */
+#define	SSB_PCMCIA_MEMW_2_SHIFT		16
+#define	SSB_PCMCIA_MEMW_3		0x1F000000	/* waitcount3 */
+#define	SSB_PCMCIA_MEMW_3_SHIFT		24
+
+/* pcmcia_attrwait */
+#define	SSB_PCMCIA_ATTW_0		0x0000003F	/* waitcount0 */
+#define	SSB_PCMCIA_ATTW_1		0x00001F00	/* waitcount1 */
+#define	SSB_PCMCIA_ATTW_1_SHIFT		8
+#define	SSB_PCMCIA_ATTW_2		0x001F0000	/* waitcount2 */
+#define	SSB_PCMCIA_ATTW_2_SHIFT		16
+#define	SSB_PCMCIA_ATTW_3		0x1F000000	/* waitcount3 */
+#define	SSB_PCMCIA_ATTW_3_SHIFT		24
+
+/* pcmcia_iowait */
+#define	SSB_PCMCIA_IOW_0		0x0000003F	/* waitcount0 */
+#define	SSB_PCMCIA_IOW_1		0x00001F00	/* waitcount1 */
+#define	SSB_PCMCIA_IOW_1_SHIFT		8
+#define	SSB_PCMCIA_IOW_2		0x001F0000	/* waitcount2 */
+#define	SSB_PCMCIA_IOW_2_SHIFT		16
+#define	SSB_PCMCIA_IOW_3		0x1F000000	/* waitcount3 */
+#define	SSB_PCMCIA_IOW_3_SHIFT		24
+
+/* prog_waitcount */
+#define	SSB_PROG_WCNT_0			0x0000001F	/* waitcount0 */
+#define	SSB_PROG_WCNT_1			0x00001F00	/* waitcount1 */
+#define	SSB_PROG_WCNT_1_SHIFT		8
+#define	SSB_PROG_WCNT_2			0x001F0000	/* waitcount2 */
+#define	SSB_PROG_WCNT_2_SHIFT		16
+#define	SSB_PROG_WCNT_3			0x1F000000	/* waitcount3 */
+#define	SSB_PROG_WCNT_3_SHIFT		24
+
+#define SSB_PROG_W0			0x0000000C
+#define SSB_PROG_W1			0x00000A00
+#define SSB_PROG_W2			0x00020000
+#define SSB_PROG_W3			0x01000000
+
+/* flash_waitcount */
+#define	SSB_FLASH_WCNT_0		0x0000001F	/* waitcount0 */
+#define	SSB_FLASH_WCNT_1		0x00001F00	/* waitcount1 */
+#define	SSB_FLASH_WCNT_1_SHIFT		8
+#define	SSB_FLASH_WCNT_2		0x001F0000	/* waitcount2 */
+#define	SSB_FLASH_WCNT_2_SHIFT		16
+#define	SSB_FLASH_WCNT_3		0x1F000000	/* waitcount3 */
+#define	SSB_FLASH_WCNT_3_SHIFT		24
+
+/* watchdog */
+#define SSB_EXTIF_WATCHDOG_CLK		48000000	/* Hz */
+
+
+#endif /* LINUX_SSB_EXTIFCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_mips.h b/include/linux/ssb/ssb_driver_mips.h
new file mode 100644
index 0000000..cdbb985
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_mips.h
@@ -0,0 +1,44 @@
+#ifndef LINUX_SSB_MIPSCORE_H_
+#define LINUX_SSB_MIPSCORE_H_
+
+#ifdef CONFIG_SSB_DRIVER_MIPS
+
+struct ssb_device;
+
+struct ssb_serial_port {
+	void *regs;
+	unsigned long clockspeed;
+	unsigned int irq;
+	unsigned int baud_base;
+	unsigned int reg_shift;
+};
+
+
+struct ssb_mipscore {
+	struct ssb_device *dev;
+
+	int nr_serial_ports;
+	struct ssb_serial_port serial_ports[4];
+
+	u32 flash_window;
+	u32 flash_window_size;
+};
+
+extern void ssb_mipscore_init(struct ssb_mipscore *mcore);
+
+extern unsigned int ssb_mips_irq(struct ssb_device *dev);
+
+
+#else /* CONFIG_SSB_DRIVER_MIPS */
+
+struct ssb_mipscore {
+};
+
+static inline
+void ssb_mipscore_init(struct ssb_mipscore *mcore)
+{
+}
+
+#endif /* CONFIG_SSB_DRIVER_MIPS */
+
+#endif /* LINUX_SSB_MIPSCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_pci.h b/include/linux/ssb/ssb_driver_pci.h
new file mode 100644
index 0000000..9cfffb7
--- /dev/null
+++ b/include/linux/ssb/ssb_driver_pci.h
@@ -0,0 +1,106 @@
+#ifndef LINUX_SSB_PCICORE_H_
+#define LINUX_SSB_PCICORE_H_
+
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+
+/* PCI core registers. */
+#define SSB_PCICORE_CTL			0x0000	/* PCI Control */
+#define  SSB_PCICORE_CTL_RST_OE		0x00000001 /* PCI_RESET Output Enable */
+#define  SSB_PCICORE_CTL_RST		0x00000002 /* PCI_RESET driven out to pin */
+#define  SSB_PCICORE_CTL_CLK_OE		0x00000004 /* Clock gate Output Enable */
+#define  SSB_PCICORE_CTL_CLK		0x00000008 /* Gate for clock driven out to pin */
+#define SSB_PCICORE_ARBCTL		0x0010	/* PCI Arbiter Control */
+#define  SSB_PCICORE_ARBCTL_INTERN	0x00000001 /* Use internal arbiter */
+#define  SSB_PCICORE_ARBCTL_EXTERN	0x00000002 /* Use external arbiter */
+#define  SSB_PCICORE_ARBCTL_PARKID	0x00000006 /* Mask, selects which agent is parked on an idle bus */
+#define   SSB_PCICORE_ARBCTL_PARKID_LAST	0x00000000 /* Last requestor */
+#define   SSB_PCICORE_ARBCTL_PARKID_4710	0x00000002 /* 4710 */
+#define   SSB_PCICORE_ARBCTL_PARKID_EXT0	0x00000004 /* External requestor 0 */
+#define   SSB_PCICORE_ARBCTL_PARKID_EXT1	0x00000006 /* External requestor 1 */
+#define SSB_PCICORE_ISTAT		0x0020	/* Interrupt status */
+#define  SSB_PCICORE_ISTAT_INTA		0x00000001 /* PCI INTA# */
+#define  SSB_PCICORE_ISTAT_INTB		0x00000002 /* PCI INTB# */
+#define  SSB_PCICORE_ISTAT_SERR		0x00000004 /* PCI SERR# (write to clear) */
+#define  SSB_PCICORE_ISTAT_PERR		0x00000008 /* PCI PERR# (write to clear) */
+#define  SSB_PCICORE_ISTAT_PME		0x00000010 /* PCI PME# */
+#define SSB_PCICORE_IMASK		0x0024	/* Interrupt mask */
+#define  SSB_PCICORE_IMASK_INTA		0x00000001 /* PCI INTA# */
+#define  SSB_PCICORE_IMASK_INTB		0x00000002 /* PCI INTB# */
+#define  SSB_PCICORE_IMASK_SERR		0x00000004 /* PCI SERR# */
+#define  SSB_PCICORE_IMASK_PERR		0x00000008 /* PCI PERR# */
+#define  SSB_PCICORE_IMASK_PME		0x00000010 /* PCI PME# */
+#define SSB_PCICORE_MBOX		0x0028	/* Backplane to PCI Mailbox */
+#define  SSB_PCICORE_MBOX_F0_0		0x00000100 /* PCI function 0, INT 0 */
+#define  SSB_PCICORE_MBOX_F0_1		0x00000200 /* PCI function 0, INT 1 */
+#define  SSB_PCICORE_MBOX_F1_0		0x00000400 /* PCI function 1, INT 0 */
+#define  SSB_PCICORE_MBOX_F1_1		0x00000800 /* PCI function 1, INT 1 */
+#define  SSB_PCICORE_MBOX_F2_0		0x00001000 /* PCI function 2, INT 0 */
+#define  SSB_PCICORE_MBOX_F2_1		0x00002000 /* PCI function 2, INT 1 */
+#define  SSB_PCICORE_MBOX_F3_0		0x00004000 /* PCI function 3, INT 0 */
+#define  SSB_PCICORE_MBOX_F3_1		0x00008000 /* PCI function 3, INT 1 */
+#define SSB_PCICORE_BCAST_ADDR		0x0050	/* Backplane Broadcast Address */
+#define  SSB_PCICORE_BCAST_ADDR_MASK	0x000000FF
+#define SSB_PCICORE_BCAST_DATA		0x0054	/* Backplane Broadcast Data */
+#define SSB_PCICORE_GPIO_IN		0x0060	/* rev >= 2 only */
+#define SSB_PCICORE_GPIO_OUT		0x0064	/* rev >= 2 only */
+#define SSB_PCICORE_GPIO_ENABLE		0x0068	/* rev >= 2 only */
+#define SSB_PCICORE_GPIO_CTL		0x006C	/* rev >= 2 only */
+#define SSB_PCICORE_SBTOPCI0		0x0100	/* Backplane to PCI translation 0 (sbtopci0) */
+#define  SSB_PCICORE_SBTOPCI0_MASK	0xFC000000
+#define SSB_PCICORE_SBTOPCI1		0x0104	/* Backplane to PCI translation 1 (sbtopci1) */
+#define  SSB_PCICORE_SBTOPCI1_MASK	0xFC000000
+#define SSB_PCICORE_SBTOPCI2		0x0108	/* Backplane to PCI translation 2 (sbtopci2) */
+#define  SSB_PCICORE_SBTOPCI2_MASK	0xC0000000
+
+/* SBtoPCIx */
+#define SSB_PCICORE_SBTOPCI_MEM		0x00000000
+#define SSB_PCICORE_SBTOPCI_IO		0x00000001
+#define SSB_PCICORE_SBTOPCI_CFG0	0x00000002
+#define SSB_PCICORE_SBTOPCI_CFG1	0x00000003
+#define SSB_PCICORE_SBTOPCI_PREF	0x00000004 /* Prefetch enable */
+#define SSB_PCICORE_SBTOPCI_BURST	0x00000008 /* Burst enable */
+#define SSB_PCICORE_SBTOPCI_MRM		0x00000020 /* Memory Read Multiple */
+#define SSB_PCICORE_SBTOPCI_RC		0x00000030 /* Read Command mask (rev >= 11) */
+#define  SSB_PCICORE_SBTOPCI_RC_READ	0x00000000 /* Memory read */
+#define  SSB_PCICORE_SBTOPCI_RC_READL	0x00000010 /* Memory read line */
+#define  SSB_PCICORE_SBTOPCI_RC_READM	0x00000020 /* Memory read multiple */
+
+
+/* PCIcore specific boardflags */
+#define SSB_PCICORE_BFL_NOPCI		0x00000400 /* Board leaves PCI floating */
+
+
+struct ssb_pcicore {
+	struct ssb_device *dev;
+	u8 setup_done:1;
+	u8 hostmode:1;
+	u8 cardbusmode:1;
+};
+
+extern void ssb_pcicore_init(struct ssb_pcicore *pc);
+
+/* Enable IRQ routing for a specific device */
+extern int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
+					  struct ssb_device *dev);
+
+
+#else /* CONFIG_SSB_DRIVER_PCICORE */
+
+
+struct ssb_pcicore {
+};
+
+static inline
+void ssb_pcicore_init(struct ssb_pcicore *pc)
+{
+}
+
+static inline
+int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
+				   struct ssb_device *dev)
+{
+	return 0;
+}
+
+#endif /* CONFIG_SSB_DRIVER_PCICORE */
+#endif /* LINUX_SSB_PCICORE_H_ */
diff --git a/include/linux/ssb/ssb.h b/include/linux/ssb/ssb.h
new file mode 100644
index 0000000..8326377
--- /dev/null
+++ b/include/linux/ssb/ssb.h
@@ -0,0 +1,432 @@
+#ifndef LINUX_SSB_H_
+#define LINUX_SSB_H_
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+
+#include <linux/ssb/ssb_regs.h>
+
+
+struct pcmcia_device;
+struct ssb_bus;
+struct ssb_driver;
+
+
+struct ssb_sprom_r1 {
+	u16 pci_spid;		/* Subsystem Product ID for PCI */
+	u16 pci_svid;		/* Subsystem Vendor ID for PCI */
+	u16 pci_pid;		/* Product ID for PCI */
+	u8 il0mac[6];		/* MAC address for 802.11b/g */
+	u8 et0mac[6];		/* MAC address for Ethernet */
+	u8 et1mac[6];		/* MAC address for 802.11a */
+	u8 et0phyaddr:5;	/* MII address for enet0 */
+	u8 et1phyaddr:5;	/* MII address for enet1 */
+	u8 et0mdcport:1;	/* MDIO for enet0 */
+	u8 et1mdcport:1;	/* MDIO for enet1 */
+	u8 board_rev;		/* Board revision */
+	u8 country_code:4;	/* Country Code */
+	u8 antenna_a:2;		/* Antenna 0/1 available for A-PHY */
+	u8 antenna_bg:2;	/* Antenna 0/1 available for B-PHY and G-PHY */
+	u16 pa0b0;
+	u16 pa0b1;
+	u16 pa0b2;
+	u16 pa1b0;
+	u16 pa1b1;
+	u16 pa1b2;
+	u8 gpio0;		/* GPIO pin 0 */
+	u8 gpio1;		/* GPIO pin 1 */
+	u8 gpio2;		/* GPIO pin 2 */
+	u8 gpio3;		/* GPIO pin 3 */
+	u16 maxpwr_a;		/* A-PHY Power Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_bg;		/* B/G-PHY Power Amplifier Max Power (in dBm Q5.2) */
+	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
+	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
+	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
+	u8 antenna_gain_a;	/* A-PHY Antenna gain (in dBm Q5.2) */
+	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
+	u8 oem[8];		/* OEM string (rev 1 only) */
+};
+
+struct ssb_sprom_r2 {
+	u16 boardflags_hi;	/* Boardflags (high 16 bits) */
+	u8 maxpwr_a_lo;		/* A-PHY Max Power Low */
+	u8 maxpwr_a_hi;		/* A-PHY Max Power High */
+	u16 pa1lob0;		/* A-PHY PA Low Settings */
+	u16 pa1lob1;		/* A-PHY PA Low Settings */
+	u16 pa1lob2;		/* A-PHY PA Low Settings */
+	u16 pa1hib0;		/* A-PHY PA High Settings */
+	u16 pa1hib1;		/* A-PHY PA High Settings */
+	u16 pa1hib2;		/* A-PHY PA High Settings */
+	u8 ofdm_pwr_off;	/* OFDM Power Offset from CCK Level */
+	u8 country_str[2];	/* Two char Country Code */
+};
+
+struct ssb_sprom_r3 {
+	u32 ofdmapo;		/* A-PHY OFDM Mid Power Offset */
+	u32 ofdmalpo;		/* A-PHY OFDM Low Power Offset */
+	u32 ofdmahpo;		/* A-PHY OFDM High Power Offset */
+	u8 gpioldc_on_cnt;	/* GPIO LED Powersave Duty Cycle ON count */
+	u8 gpioldc_off_cnt;	/* GPIO LED Powersave Duty Cycle OFF count */
+	u8 cckpo_1M:4;		/* CCK Power Offset for Rate 1M */
+	u8 cckpo_2M:4;		/* CCK Power Offset for Rate 2M */
+	u8 cckpo_55M:4;		/* CCK Power Offset for Rate 5.5M */
+	u8 cckpo_11M:4;		/* CCK Power Offset for Rate 11M */
+	u32 ofdmgpo;		/* G-PHY OFDM Power Offset */
+};
+
+struct ssb_sprom_r4 {
+	/* TODO */
+};
+
+struct ssb_sprom {
+	u8 revision;
+	u8 crc;
+	/* The valid r# fields are selected by the "revision".
+	 * Revision 3 and lower inherit from lower revisions.
+	 */
+	union {
+		struct {
+			struct ssb_sprom_r1 r1;
+			struct ssb_sprom_r2 r2;
+			struct ssb_sprom_r3 r3;
+		};
+		struct ssb_sprom_r4 r4;
+	};
+};
+
+/* Information about the PCB the circuitry is soldered on. */
+struct ssb_boardinfo {
+	u16 vendor;
+	u16 type;
+	u16 rev;
+};
+
+
+struct ssb_device;
+/* Lowlevel read/write operations on the device MMIO.
+ * Internal, don't use that outside of ssb. */
+struct ssb_bus_ops {
+	u16 (*read16)(struct ssb_device *dev, u16 offset);
+	u32 (*read32)(struct ssb_device *dev, u16 offset);
+	void (*write16)(struct ssb_device *dev, u16 offset, u16 value);
+	void (*write32)(struct ssb_device *dev, u16 offset, u32 value);
+};
+
+
+/* Core-ID values. */
+#define SSB_DEV_CHIPCOMMON	0x800
+#define SSB_DEV_ILINE20		0x801
+#define SSB_DEV_SDRAM		0x803
+#define SSB_DEV_PCI		0x804
+#define SSB_DEV_MIPS		0x805
+#define SSB_DEV_ETHERNET	0x806
+#define SSB_DEV_V90		0x807
+#define SSB_DEV_USB11_HOSTDEV	0x808
+#define SSB_DEV_ADSL		0x809
+#define SSB_DEV_ILINE100	0x80A
+#define SSB_DEV_IPSEC		0x80B
+#define SSB_DEV_PCMCIA		0x80D
+#define SSB_DEV_INTERNAL_MEM	0x80E
+#define SSB_DEV_MEMC_SDRAM	0x80F
+#define SSB_DEV_EXTIF		0x811
+#define SSB_DEV_80211		0x812
+#define SSB_DEV_MIPS_3302	0x816
+#define SSB_DEV_USB11_HOST	0x817
+#define SSB_DEV_USB11_DEV	0x818
+#define SSB_DEV_USB20_HOST	0x819
+#define SSB_DEV_USB20_DEV	0x81A
+#define SSB_DEV_SDIO_HOST	0x81B
+#define SSB_DEV_ROBOSWITCH	0x81C
+#define SSB_DEV_PARA_ATA	0x81D
+#define SSB_DEV_SATA_XORDMA	0x81E
+#define SSB_DEV_ETHERNET_GBIT	0x81F
+#define SSB_DEV_PCIE		0x820
+#define SSB_DEV_MIMO_PHY	0x821
+#define SSB_DEV_SRAM_CTRLR	0x822
+#define SSB_DEV_MINI_MACPHY	0x823
+#define SSB_DEV_ARM_1176	0x824
+#define SSB_DEV_ARM_7TDMI	0x825
+
+/* Vendor-ID values */
+#define SSB_VENDOR_BROADCOM	0x4243
+
+struct ssb_device_id {
+	u16 vendor;
+	u16 coreid;
+	u8 revision;
+};
+#define SSB_DEVICE(_vendor, _coreid, _revision)  \
+	{ .vendor = _vendor, .coreid = _coreid, .revision = _revision, }
+#define SSB_DEVTABLE_END  \
+	{ 0, },
+
+#define SSB_ANY_VENDOR		0xFFFF
+#define SSB_ANY_ID		0xFFFF
+#define SSB_ANY_REV		0xFF
+
+/* Some kernel subsystems poke with dev->drvdata, so we must use the
+ * following ugly workaround to get from struct device to struct ssb_device */
+struct __ssb_dev_wrapper {
+	struct device dev;
+	struct ssb_device *sdev;
+};
+
+struct ssb_device {
+	/* Having a copy of the ops pointer in each dev struct
+	 * is an optimization. */
+	const struct ssb_bus_ops *ops;
+
+	struct device *dev;
+	struct ssb_bus *bus;
+	struct ssb_device_id id;
+
+	u8 core_index;
+	unsigned int irq;
+
+	/* Internal-only stuff follows. */
+	void *drvdata;		/* Per-device data */
+	void *devtypedata;	/* Per-devicetype (eg 802.11) data */
+};
+
+/* Go from struct device to struct ssb_device. */
+static inline
+struct ssb_device * dev_to_ssb_dev(struct device *dev)
+{
+	struct __ssb_dev_wrapper *wrap;
+	wrap = container_of(dev, struct __ssb_dev_wrapper, dev);
+	return wrap->sdev;
+}
+
+/* Device specific user data */
+static inline
+void ssb_set_drvdata(struct ssb_device *dev, void *data)
+{
+	dev->drvdata = data;
+}
+static inline
+void * ssb_get_drvdata(struct ssb_device *dev)
+{
+	return dev->drvdata;
+}
+
+/* Devicetype specific user data. This is per device-type (not per device) */
+void ssb_set_devtypedata(struct ssb_device *dev, void *data);
+static inline
+void * ssb_get_devtypedata(struct ssb_device *dev)
+{
+	return dev->devtypedata;
+}
+
+
+struct ssb_driver {
+	const char *name;
+	const struct ssb_device_id *id_table;
+
+	int (*probe)(struct ssb_device *dev, const struct ssb_device_id *id);
+	void (*remove)(struct ssb_device *dev);
+	int (*suspend)(struct ssb_device *dev, pm_message_t state);
+	int (*resume)(struct ssb_device *dev);
+	void (*shutdown)(struct ssb_device *dev);
+
+	struct device_driver drv;
+};
+#define drv_to_ssb_drv(_drv) container_of(_drv, struct ssb_driver, drv)
+
+extern int __ssb_driver_register(struct ssb_driver *drv, struct module *owner);
+static inline int ssb_driver_register(struct ssb_driver *drv)
+{
+	return __ssb_driver_register(drv, THIS_MODULE);
+}
+extern void ssb_driver_unregister(struct ssb_driver *drv);
+
+
+
+
+enum ssb_bustype {
+	SSB_BUSTYPE_SSB,	/* This SSB bus is the system bus */
+	SSB_BUSTYPE_PCI,	/* SSB is connected to PCI bus */
+	SSB_BUSTYPE_PCMCIA,	/* SSB is connected to PCMCIA bus */
+};
+
+/* board_vendor */
+#define SSB_BOARDVENDOR_BCM	0x14E4	/* Broadcom */
+#define SSB_BOARDVENDOR_DELL	0x1028	/* Dell */
+#define SSB_BOARDVENDOR_HP	0x0E11	/* HP */
+/* board_type */
+#define SSB_BOARD_BCM94306MP	0x0418
+#define SSB_BOARD_BCM4309G	0x0421
+#define SSB_BOARD_BCM4306CB	0x0417
+#define SSB_BOARD_BCM4309MP	0x040C
+#define SSB_BOARD_MP4318	0x044A
+#define SSB_BOARD_BU4306	0x0416
+#define SSB_BOARD_BU4309	0x040A
+/* chip_package */
+#define SSB_CHIPPACK_BCM4712S	1	/* Small 200pin 4712 */
+#define SSB_CHIPPACK_BCM4712M	2	/* Medium 225pin 4712 */
+#define SSB_CHIPPACK_BCM4712L	0	/* Large 340pin 4712 */
+
+#include <linux/ssb/ssb_driver_chipcommon.h>
+#include <linux/ssb/ssb_driver_mips.h>
+#include <linux/ssb/ssb_driver_extif.h>
+#include <linux/ssb/ssb_driver_pci.h>
+
+struct ssb_bus {
+	/* The MMIO area. */
+	void __iomem *mmio;
+
+	const struct ssb_bus_ops *ops;
+
+	/* The core in the basic address register window. (PCI bus only) */
+	struct ssb_device *mapped_device;
+	/* Currently mapped PCMCIA segment. (bustype == SSB_BUSTYPE_PCMCIA only) */
+	u8 mapped_pcmcia_seg;
+	/* Lock for core and segment switching. */
+	spinlock_t bar_lock;
+
+	/* The bus this backplane is running on. */
+	enum ssb_bustype bustype;
+	/* Pointer to the PCI bus (only valid if bustype == SSB_BUSTYPE_PCI). */
+	struct pci_dev *host_pci;
+	/* Pointer to the PCMCIA device (only if bustype == SSB_BUSTYPE_PCMCIA). */
+	struct pcmcia_device *host_pcmcia;
+
+#ifdef CONFIG_SSB_PCIHOST
+	/* Mutex to protect the SPROM writing. */
+	struct mutex pci_sprom_mutex;
+#endif
+
+	/* ID information about the Chip. */
+	u16 chip_id;
+	u16 chip_rev;
+	u8 chip_package;
+
+	/* List of devices (cores) on the backplane. */
+	struct ssb_device devices[SSB_MAX_NR_CORES];
+	u8 nr_devices;
+
+	/* Reference count. Number of suspended devices. */
+	u8 suspend_cnt;
+
+	/* Software ID number for this bus. */
+	unsigned int busnumber;
+
+	/* The ChipCommon device (if available). */
+	struct ssb_chipcommon chipco;
+	/* The PCI-core device (if available). */
+	struct ssb_pcicore pcicore;
+	/* The MIPS-core device (if available). */
+	struct ssb_mipscore mipscore;
+	/* The EXTif-core device (if available). */
+	struct ssb_extif extif;
+
+	/* The following structure elements are not available in early
+	 * SSB initialization. Though, they are available for regular
+	 * registered drivers at any stage. So be careful when
+	 * using them in the ssb core code. */
+
+	/* ID information about the PCB. */
+	struct ssb_boardinfo boardinfo;
+	/* Contents of the SPROM. */
+	struct ssb_sprom sprom;
+
+	/* Internal. */
+	struct list_head list;
+};
+
+/* The initialization-invariants. */
+struct ssb_init_invariants {
+	struct ssb_boardinfo boardinfo;
+	struct ssb_sprom sprom;
+};
+/* Type of function to fetch the invariants. */
+typedef int (*ssb_invariants_func_t)(struct ssb_bus *bus,
+				     struct ssb_init_invariants *iv);
+
+/* Register a SSB system bus. get_invariants() is called after the
+ * basic system devices are initialized.
+ * The invariants are usually fetched from some NVRAM.
+ * Put the invariants into the struct pointed to by iv. */
+extern int ssb_bus_ssbbus_register(struct ssb_bus *bus,
+				   unsigned long baseaddr,
+				   ssb_invariants_func_t get_invariants);
+#ifdef CONFIG_SSB_PCIHOST
+extern int ssb_bus_pcibus_register(struct ssb_bus *bus,
+				   struct pci_dev *host_pci);
+#endif /* CONFIG_SSB_PCIHOST */
+#ifdef CONFIG_SSB_PCMCIAHOST
+extern int ssb_bus_pcmciabus_register(struct ssb_bus *bus,
+				      struct pcmcia_device *pcmcia_dev,
+				      unsigned long baseaddr);
+#endif /* CONFIG_SSB_PCMCIAHOST */
+
+extern void ssb_bus_unregister(struct ssb_bus *bus);
+
+extern u32 ssb_clockspeed(struct ssb_bus *bus);
+
+/* Is the device enabled in hardware? */
+int ssb_device_is_enabled(struct ssb_device *dev);
+/* Enable a device and pass device-specific SSB_TMSLOW flags.
+ * If no device-specific flags are available, use 0. */
+void ssb_device_enable(struct ssb_device *dev, u32 core_specific_flags);
+/* Disable a device in hardware and pass SSB_TMSLOW flags (if any). */
+void ssb_device_disable(struct ssb_device *dev, u32 core_specific_flags);
+
+
+/* Device MMIO register read/write functions. */
+static inline u16 ssb_read16(struct ssb_device *dev, u16 offset)
+{
+	return dev->ops->read16(dev, offset);
+}
+static inline u32 ssb_read32(struct ssb_device *dev, u16 offset)
+{
+	return dev->ops->read32(dev, offset);
+}
+static inline void ssb_write16(struct ssb_device *dev, u16 offset, u16 value)
+{
+	dev->ops->write16(dev, offset, value);
+}
+static inline void ssb_write32(struct ssb_device *dev, u16 offset, u32 value)
+{
+	dev->ops->write32(dev, offset, value);
+}
+
+
+/* Translation (routing) bits that need to be ORed to DMA
+ * addresses before they are given to a device. */
+extern u32 ssb_dma_translation(struct ssb_device *dev);
+#define SSB_DMA_TRANSLATION_MASK	0xC0000000
+#define SSB_DMA_TRANSLATION_SHIFT	30
+
+extern int ssb_dma_set_mask(struct ssb_device *ssb_dev, u64 mask);
+
+
+#ifdef CONFIG_SSB_PCIHOST
+/* PCI-host wrapper driver */
+extern int ssb_pcihost_register(struct pci_driver *driver);
+static inline void ssb_pcihost_unregister(struct pci_driver *driver)
+{
+	pci_unregister_driver(driver);
+}
+#endif /* CONFIG_SSB_PCIHOST */
+
+
+/* If a driver is shutdown or suspended, call this to signal
+ * that the bus may be completely powered down. SSB will decide,
+ * if it's really time to power down the bus, based on if there
+ * are other devices that want to run. */
+extern int ssb_bus_may_powerdown(struct ssb_bus *bus);
+/* Before initializing and enabling a device, call this to power-up the bus.
+ * If you want to allow use of dynamic-power-control, pass the flag.
+ * Otherwise static always-on powercontrol will be used. */
+extern int ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl);
+
+
+/* Various helper functions */
+extern u32 ssb_admatch_base(u32 adm);
+extern u32 ssb_admatch_size(u32 adm);
+
+
+#endif /* LINUX_SSB_H_ */
diff --git a/include/linux/ssb/ssb_regs.h b/include/linux/ssb/ssb_regs.h
new file mode 100644
index 0000000..66751a6
--- /dev/null
+++ b/include/linux/ssb/ssb_regs.h
@@ -0,0 +1,292 @@
+#ifndef LINUX_SSB_REGS_H_
+#define LINUX_SSB_REGS_H_
+
+
+/* SiliconBackplane Address Map.
+ * All regions may not exist on all chips.
+ */
+#define SSB_SDRAM_BASE		0x00000000	/* Physical SDRAM */
+#define SSB_PCI_MEM		0x08000000	/* Host Mode sb2pcitranslation0 (64 MB) */
+#define SSB_PCI_CFG		0x0c000000	/* Host Mode sb2pcitranslation1 (64 MB) */
+#define	SSB_SDRAM_SWAPPED	0x10000000	/* Byteswapped Physical SDRAM */
+#define SSB_ENUM_BASE    	0x18000000	/* Enumeration space base */
+#define	SSB_ENUM_LIMIT		0x18010000	/* Enumeration space limit */
+
+#define	SSB_FLASH2		0x1c000000	/* Flash Region 2 (region 1 shadowed here) */
+#define	SSB_FLASH2_SZ		0x02000000	/* Size of Flash Region 2 */
+
+#define	SSB_EXTIF_BASE		0x1f000000	/* External Interface region base address */
+#define	SSB_FLASH1		0x1fc00000	/* Flash Region 1 */
+#define	SSB_FLASH1_SZ		0x00400000	/* Size of Flash Region 1 */
+
+#define SSB_PCI_DMA		0x40000000	/* Client Mode sb2pcitranslation2 (1 GB) */
+#define SSB_PCI_DMA_SZ		0x40000000	/* Client Mode sb2pcitranslation2 size in bytes */
+#define SSB_PCIE_DMA_L32	0x00000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), low 32 bits */
+#define SSB_PCIE_DMA_H32	0x80000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), high 32 bits */
+#define	SSB_EUART		(SSB_EXTIF_BASE + 0x00800000)
+#define	SSB_LED			(SSB_EXTIF_BASE + 0x00900000)
+
+
+/* Enumeration space constants */
+#define SSB_CORE_SIZE		0x1000	/* Size of a core MMIO area */
+#define SSB_MAX_NR_CORES	((SSB_ENUM_LIMIT - SSB_ENUM_BASE) / SSB_CORE_SIZE)
+
+
+/* mips address */
+#define	SSB_EJTAG		0xff200000	/* MIPS EJTAG space (2M) */
+
+
+/* SSB PCI config space registers. */
+#define SSB_PMCSR		0x44
+#define  SSB_PE			0x100
+#define	SSB_BAR0_WIN		0x80	/* Backplane address space 0 */
+#define	SSB_BAR1_WIN		0x84	/* Backplane address space 1 */
+#define	SSB_SPROMCTL		0x88	/* SPROM control */
+#define  SSB_SPROMCTL_WE	0x10	/* SPROM write enable */
+#define	SSB_BAR1_CONTROL	0x8c	/* Address space 1 burst control */
+#define SSB_PCI_IRQS		0x90	/* PCI interrupts */
+#define SSB_PCI_IRQMASK		0x94	/* PCI IRQ control and mask (pcirev >= 6 only) */
+#define SSB_BACKPLANE_IRQS	0x98	/* Backplane Interrupts */
+#define SSB_GPIO_IN		0xB0	/* GPIO Input (pcirev >= 3 only) */
+#define SSB_GPIO_OUT		0xB4	/* GPIO Output (pcirev >= 3 only) */
+#define SSB_GPIO_OUT_ENABLE	0xB8	/* GPIO Output Enable/Disable (pcirev >= 3 only) */
+#define  SSB_GPIO_SCS		0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
+#define  SSB_GPIO_HWRAD		0x20	/* PCI config space GPIO 13 for hw radio disable */
+#define  SSB_GPIO_XTAL		0x40	/* PCI config space GPIO 14 for Xtal powerup */
+#define  SSB_GPIO_PLL		0x80	/* PCI config space GPIO 15 for PLL powerdown */
+
+
+#define SSB_BAR0_MAX_RETRIES	50
+
+/* Silicon backplane configuration register definitions */
+#define SSB_IPSFLAG		0x0F08
+#define	 SSB_IPSFLAG_IRQ1	0x0000003F /* which sbflags get routed to mips interrupt 1 */
+#define	 SSB_IPSFLAG_IRQ1_SHIFT	0
+#define	 SSB_IPSFLAG_IRQ2	0x00003F00 /* which sbflags get routed to mips interrupt 2 */
+#define	 SSB_IPSFLAG_IRQ2_SHIFT	8
+#define	 SSB_IPSFLAG_IRQ3	0x003F0000 /* which sbflags get routed to mips interrupt 3 */
+#define	 SSB_IPSFLAG_IRQ3_SHIFT	16
+#define	 SSB_IPSFLAG_IRQ4	0x3F000000 /* which sbflags get routed to mips interrupt 4 */
+#define	 SSB_IPSFLAG_IRQ4_SHIFT	24
+#define SSB_TPSFLAG		0x0F18
+#define  SSB_TPSFLAG_BPFLAG	0x0000003F /* Backplane flag # */
+#define  SSB_TPSFLAG_ALWAYSIRQ	0x00000040 /* IRQ is always sent on the Backplane */
+#define SSB_TMERRLOGA		0x0F48
+#define SSB_TMERRLOG		0x0F50
+#define SSB_ADMATCH3		0x0F60
+#define SSB_ADMATCH2		0x0F68
+#define SSB_ADMATCH1		0x0F70
+#define SSB_IMSTATE		0x0F90     /* SB Initiator Agent State */
+#define  SSB_IMSTATE_PC		0x0000000f /* Pipe Count */
+#define  SSB_IMSTATE_AP_MASK	0x00000030 /* Arbitration Priority */
+#define  SSB_IMSTATE_AP_BOTH	0x00000000 /* Use both timeslices and token */
+#define  SSB_IMSTATE_AP_TS	0x00000010 /* Use timeslices only */
+#define  SSB_IMSTATE_AP_TK	0x00000020 /* Use token only */
+#define  SSB_IMSTATE_AP_RSV	0x00000030 /* Reserved */
+#define  SSB_IMSTATE_IBE	0x00020000 /* In Band Error */
+#define  SSB_IMSTATE_TO		0x00040000 /* Timeout */
+#define SSB_INTVEC		0x0F94     /* SB Interrupt Mask */
+#define  SSB_INTVEC_PCI		0x00000001 /* Enable interrupts for PCI */
+#define  SSB_INTVEC_ENET0	0x00000002 /* Enable interrupts for enet 0 */
+#define  SSB_INTVEC_ILINE20	0x00000004 /* Enable interrupts for iline20 */
+#define  SSB_INTVEC_CODEC	0x00000008 /* Enable interrupts for v90 codec */
+#define  SSB_INTVEC_USB		0x00000010 /* Enable interrupts for usb */
+#define  SSB_INTVEC_EXTIF	0x00000020 /* Enable interrupts for external i/f */
+#define  SSB_INTVEC_ENET1	0x00000040 /* Enable interrupts for enet 1 */
+#define SSB_TMSLOW		0x0F98     /* SB Target State Low */
+#define  SSB_TMSLOW_RESET	0x00000001 /* Reset */
+#define  SSB_TMSLOW_REJECT_22	0x00000002 /* Reject (Backplane rev 2.2) */
+#define  SSB_TMSLOW_REJECT_23	0x00000004 /* Reject (Backplane rev 2.3) */
+#define  SSB_TMSLOW_CLOCK	0x00010000 /* Clock Enable */
+#define  SSB_TMSLOW_FGC		0x00020000 /* Force Gated Clocks On */
+#define  SSB_TMSLOW_PE		0x40000000 /* Power Management Enable */
+#define  SSB_TMSLOW_BE		0x80000000 /* BIST Enable */
+#define SSB_TMSHIGH		0x0F9C     /* SB Target State High */
+#define  SSB_TMSHIGH_SERR	0x00000001 /* S-error */
+#define  SSB_TMSHIGH_INT	0x00000002 /* Interrupt */
+#define  SSB_TMSHIGH_BUSY	0x00000004 /* Busy */
+#define  SSB_TMSHIGH_TO		0x00000020 /* Timeout. Backplane rev >= 2.3 only */
+#define  SSB_TMSHIGH_COREFL	0x1FFF0000 /* Core specific flags */
+#define  SSB_TMSHIGH_COREFL_SHIFT	16
+#define  SSB_TMSHIGH_DMA64	0x10000000 /* 64bit DMA supported */
+#define  SSB_TMSHIGH_GCR	0x20000000 /* Gated Clock Request */
+#define  SSB_TMSHIGH_BISTF	0x40000000 /* BIST Failed */
+#define  SSB_TMSHIGH_BISTD	0x80000000 /* BIST Done */
+#define SSB_BWA0		0x0FA0
+#define SSB_IMCFGLO		0x0FA8
+#define  SSB_IMCFGLO_SERTO	0x00000007 /* Service timeout */
+#define  SSB_IMCFGLO_REQTO	0x00000070 /* Request timeout */
+#define  SSB_IMCFGLO_REQTO_SHIFT	4
+#define  SSB_IMCFGLO_CONNID	0x00FF0000 /* Connection ID */
+#define  SSB_IMCFGLO_CONNID_SHIFT	16
+#define SSB_IMCFGHI		0x0FAC
+#define SSB_ADMATCH0		0x0FB0
+#define SSB_TMCFGLO		0x0FB8
+#define SSB_TMCFGHI		0x0FBC
+#define SSB_BCONFIG		0x0FC0
+#define SSB_BSTATE		0x0FC8
+#define SSB_ACTCFG		0x0FD8
+#define SSB_FLAGST		0x0FE8
+#define SSB_IDLOW		0x0FF8
+#define  SSB_IDLOW_CFGSP	0x00000003 /* Config Space */
+#define  SSB_IDLOW_ADDRNGE	0x00000038 /* Address Ranges supported */
+#define  SSB_IDLOW_ADDRNGE_SHIFT	3
+#define  SSB_IDLOW_SYNC		0x00000040
+#define  SSB_IDLOW_INITIATOR	0x00000080
+#define  SSB_IDLOW_MIBL		0x00000F00 /* Minimum Backplane latency */
+#define  SSB_IDLOW_MIBL_SHIFT	8
+#define  SSB_IDLOW_MABL		0x0000F000 /* Maximum Backplane latency */
+#define  SSB_IDLOW_MABL_SHIFT	12
+#define  SSB_IDLOW_TIF		0x00010000 /* This Initiator is first */
+#define  SSB_IDLOW_CCW		0x000C0000 /* Cycle counter width */
+#define  SSB_IDLOW_CCW_SHIFT	18
+#define  SSB_IDLOW_TPT		0x00F00000 /* Target ports */
+#define  SSB_IDLOW_TPT_SHIFT	20
+#define  SSB_IDLOW_INITP	0x0F000000 /* Initiator ports */
+#define  SSB_IDLOW_INITP_SHIFT	24
+#define  SSB_IDLOW_SSBREV	0xF0000000 /* Sonics Backplane Revision code */
+#define  SSB_IDLOW_SSBREV_22	0x00000000 /* <= 2.2 */
+#define  SSB_IDLOW_SSBREV_23	0x10000000 /* 2.3 */
+#define SSB_IDHIGH		0x0FFC     /* SB Identification High */
+#define  SSB_IDHIGH_RCLO	0x0000000F /* Revision Code (low part) */
+#define  SSB_IDHIGH_CC		0x00008FF0 /* Core Code */
+#define  SSB_IDHIGH_CC_SHIFT	4
+#define  SSB_IDHIGH_RCHI	0x00007000 /* Revision Code (high part) */
+#define  SSB_IDHIGH_RCHI_SHIFT	8	   /* yes, shift 8 is right */
+#define  SSB_IDHIGH_VC		0xFFFF0000 /* Vendor Code */
+#define  SSB_IDHIGH_VC_SHIFT	16
+
+/* SPROM shadow area. If not otherwise noted, fields are
+ * two bytes wide. Note that the SPROM can _only_ be read
+ * in two-byte quantinies.
+ */
+#define SSB_SPROMSIZE_WORDS		64
+#define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
+#define SSB_SPROM_BASE			0x1000
+#define SSB_SPROM_REVISION		0x107E
+#define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
+#define  SSB_SPROM_REVISION_CRC		0xFF00	/* SPROM CRC8 value */
+#define  SSB_SPROM_REVISION_CRC_SHIFT	8
+/* SPROM Revision 1 */
+#define SSB_SPROM1_SPID			0x1004	/* Subsystem Product ID for PCI */
+#define SSB_SPROM1_SVID			0x1006	/* Subsystem Vendor ID for PCI */
+#define SSB_SPROM1_PID			0x1008	/* Product ID for PCI */
+#define SSB_SPROM1_IL0MAC		0x1048	/* 6 bytes MAC address for 802.11b/g */
+#define SSB_SPROM1_ET0MAC		0x104E	/* 6 bytes MAC address for Ethernet */
+#define SSB_SPROM1_ET1MAC		0x1054	/* 6 bytes MAC address for 802.11a */
+#define SSB_SPROM1_ETHPHY		0x105A	/* Ethernet PHY settings */
+#define  SSB_SPROM1_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
+#define  SSB_SPROM1_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
+#define  SSB_SPROM1_ETHPHY_ET1A_SHIFT	5
+#define  SSB_SPROM1_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
+#define  SSB_SPROM1_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
+#define SSB_SPROM1_BINF			0x105C	/* Board info */
+#define  SSB_SPROM1_BINF_BREV		0x00FF	/* Board Revision */
+#define  SSB_SPROM1_BINF_CCODE		0x0F00	/* Country Code */
+#define  SSB_SPROM1_BINF_CCODE_SHIFT	8
+#define  SSB_SPROM1_BINF_ANTA		0x3000	/* Available A-PHY antennas */
+#define  SSB_SPROM1_BINF_ANTA_SHIFT	12
+#define  SSB_SPROM1_BINF_ANTBG		0xC000	/* Available B-PHY antennas */
+#define  SSB_SPROM1_BINF_ANTBG_SHIFT	14
+#define SSB_SPROM1_PA0B0		0x105E
+#define SSB_SPROM1_PA0B1		0x1060
+#define SSB_SPROM1_PA0B2		0x1062
+#define SSB_SPROM1_GPIOA		0x1064	/* General Purpose IO pins 0 and 1 */
+#define  SSB_SPROM1_GPIOA_P0		0x00FF	/* Pin 0 */
+#define  SSB_SPROM1_GPIOA_P1		0xFF00	/* Pin 1 */
+#define  SSB_SPROM1_GPIOA_P1_SHIFT	8
+#define SSB_SPROM1_GPIOB		0x1066	/* General Purpuse IO pins 2 and 3 */
+#define  SSB_SPROM1_GPIOB_P2		0x00FF	/* Pin 2 */
+#define  SSB_SPROM1_GPIOB_P3		0xFF00	/* Pin 3 */
+#define  SSB_SPROM1_GPIOB_P3_SHIFT	8
+#define SSB_SPROM1_MAXPWR		0x1068	/* Power Amplifier Max Power */
+#define  SSB_SPROM1_MAXPWR_BG		0x00FF	/* B-PHY and G-PHY (in dBm Q5.2) */
+#define  SSB_SPROM1_MAXPWR_A		0xFF00	/* A-PHY (in dBm Q5.2) */
+#define  SSB_SPROM1_MAXPWR_A_SHIFT	8
+#define SSB_SPROM1_PA1B0		0x106A
+#define SSB_SPROM1_PA1B1		0x106C
+#define SSB_SPROM1_PA1B2		0x106E
+#define SSB_SPROM1_ITSSI		0x1070	/* Idle TSSI Target */
+#define  SSB_SPROM1_ITSSI_BG		0x00FF	/* B-PHY and G-PHY*/
+#define  SSB_SPROM1_ITSSI_A		0xFF00	/* A-PHY */
+#define  SSB_SPROM1_ITSSI_A_SHIFT	8
+#define SSB_SPROM1_BFLLO		0x1072	/* Boardflags (low 16 bits) */
+#define SSB_SPROM1_AGAIN		0x1074	/* Antenna Gain (in dBm Q5.2) */
+#define  SSB_SPROM1_AGAIN_A		0x00FF	/* A-PHY */
+#define  SSB_SPROM1_AGAIN_BG		0xFF00	/* B-PHY and G-PHY */
+#define  SSB_SPROM1_AGAIN_BG_SHIFT	8
+#define SSB_SPROM1_OEM			0x1076	/* 8 bytes OEM string (rev 1 only) */
+/* SPROM Revision 2 (inherits from rev 1) */
+#define SSB_SPROM2_BFLHI		0x1038	/* Boardflags (high 16 bits) */
+#define SSB_SPROM2_MAXP_A		0x103A	/* A-PHY Max Power */
+#define  SSB_SPROM2_MAXP_A_HI		0x00FF	/* Max Power High */
+#define  SSB_SPROM2_MAXP_A_LO		0xFF00	/* Max Power Low */
+#define  SSB_SPROM2_MAXP_A_LO_SHIFT	8
+#define SSB_SPROM2_PA1LOB0		0x103C	/* A-PHY PowerAmplifier Low Settings */
+#define SSB_SPROM2_PA1LOB1		0x103E	/* A-PHY PowerAmplifier Low Settings */
+#define SSB_SPROM2_PA1LOB2		0x1040	/* A-PHY PowerAmplifier Low Settings */
+#define SSB_SPROM2_PA1HIB0		0x1042	/* A-PHY PowerAmplifier High Settings */
+#define SSB_SPROM2_PA1HIB1		0x1044	/* A-PHY PowerAmplifier High Settings */
+#define SSB_SPROM2_PA1HIB2		0x1046	/* A-PHY PowerAmplifier High Settings */
+#define SSB_SPROM2_OPO			0x1078	/* OFDM Power Offset from CCK Level */
+#define  SSB_SPROM2_OPO_VALUE		0x00FF
+#define  SSB_SPROM2_OPO_UNUSED		0xFF00
+#define SSB_SPROM2_CCODE		0x107C	/* Two char Country Code */
+/* SPROM Revision 3 (inherits from rev 2) */
+#define SSB_SPROM3_OFDMAPO		0x102C	/* A-PHY OFDM Mid Power Offset (4 bytes, BigEndian) */
+#define SSB_SPROM3_OFDMALPO		0x1030	/* A-PHY OFDM Low Power Offset (4 bytes, BigEndian) */
+#define SSB_SPROM3_OFDMAHPO		0x1034	/* A-PHY OFDM High Power Offset (4 bytes, BigEndian) */
+#define SSB_SPROM3_GPIOLDC		0x1042	/* GPIO LED Powersave Duty Cycle (4 bytes, BigEndian) */
+#define  SSB_SPROM3_GPIOLDC_OFF		0x0000FF00	/* Off Count */
+#define  SSB_SPROM3_GPIOLDC_OFF_SHIFT	8
+#define  SSB_SPROM3_GPIOLDC_ON		0x00FF0000	/* On Count */
+#define  SSB_SPROM3_GPIOLDC_ON_SHIFT	16
+#define SSB_SPROM3_CCKPO		0x1078	/* CCK Power Offset */
+#define  SSB_SPROM3_CCKPO_1M		0x000F	/* 1M Rate PO */
+#define  SSB_SPROM3_CCKPO_2M		0x00F0	/* 2M Rate PO */
+#define  SSB_SPROM3_CCKPO_2M_SHIFT	4
+#define  SSB_SPROM3_CCKPO_55M		0x0F00	/* 5.5M Rate PO */
+#define  SSB_SPROM3_CCKPO_55M_SHIFT	8
+#define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
+#define  SSB_SPROM3_CCKPO_11M_SHIFT	12
+#define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
+
+/* Values for SSB_SPROM1_BINF_CCODE */
+enum {
+	SSB_SPROM1CCODE_WORLD = 0,
+	SSB_SPROM1CCODE_THAILAND,
+	SSB_SPROM1CCODE_ISRAEL,
+	SSB_SPROM1CCODE_JORDAN,
+	SSB_SPROM1CCODE_CHINA,
+	SSB_SPROM1CCODE_JAPAN,
+	SSB_SPROM1CCODE_USA_CANADA_ANZ,
+	SSB_SPROM1CCODE_EUROPE,
+	SSB_SPROM1CCODE_USA_LOW,
+	SSB_SPROM1CCODE_JAPAN_HIGH,
+	SSB_SPROM1CCODE_ALL,
+	SSB_SPROM1CCODE_NONE,
+};
+
+/* Address-Match values and masks (SSB_ADMATCHxxx) */
+#define SSB_ADM_TYPE			0x00000003	/* Address type */
+#define  SSB_ADM_TYPE0			0
+#define  SSB_ADM_TYPE1			1
+#define  SSB_ADM_TYPE2			2
+#define SSB_ADM_AD64			0x00000004
+#define SSB_ADM_SZ0			0x000000F8	/* Type0 size */
+#define SSB_ADM_SZ0_SHIFT		3
+#define SSB_ADM_SZ1			0x000001F8	/* Type1 size */
+#define SSB_ADM_SZ1_SHIFT		3
+#define SSB_ADM_SZ2			0x000001F8	/* Type2 size */
+#define SSB_ADM_SZ2_SHIFT		3
+#define SSB_ADM_EN			0x00000400	/* Enable */
+#define SSB_ADM_NEG			0x00000800	/* Negative decode */
+#define SSB_ADM_BASE0			0xFFFFFF00	/* Type0 base address */
+#define SSB_ADM_BASE0_SHIFT		8
+#define SSB_ADM_BASE1			0xFFFFF000	/* Type1 base address for the core */
+#define SSB_ADM_BASE1_SHIFT		12
+#define SSB_ADM_BASE2			0xFFFF0000	/* Type2 base address for the core */
+#define SSB_ADM_BASE2_SHIFT		16
+
+
+#endif /* LINUX_SSB_REGS_H_ */
diff --git a/MAINTAINERS b/MAINTAINERS
index 845fbf4..aee5182 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -3298,6 +3347,12 @@
 L:	netdev at vger.kernel.org
 S:	Maintained
 
+SONICS SILICON BACKPLANE DRIVER (SSB)
+P:	Michael Buesch
+M:	mb at bu3sch.de
+L:	netdev at vger.kernel.org
+S:	Maintained
+
 SONY VAIO CONTROL DEVICE DRIVER
 P:	Mattia Dongili
 M:	malattia at linux.it


From bcm43xx at richardharman.com  Sun Jul 29 19:00:52 2007
From: bcm43xx at richardharman.com (Richard Harman)
Date: Sun, 29 Jul 2007 13:00:52 -0400
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
Message-ID: <46ACC7C4.5060808@richardharman.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Some local searching of the list didn't come up with much, and some
interactive poking of Jose on irc helped.

Larry- I have a 4311 that I can let you borrow.  Infact, in about two
weeks, you can borrow the entire horking laptop that it came with.

Send me your mailing address off list, and I'll be more than happy to
ship the whole thing to you.

(one warning though: this laptop, along with the entire HP pavilion
dv6000/dv9000 series appears to have apic/acpi problems.)

- --
- -----------------------------------------------------------
"Looks like there'll be no money for you, Crazy Round Man."
                                             - Samurai Jack
Richard G Harman Jr           <me+nospam at richardharman.com>
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2.2 (GNU/Linux)
Comment: Using GnuPG with Fedora - http://enigmail.mozdev.org

iD8DBQFGrMfE3rKdb192Vz8RAlFiAJwPm/rhSoTXP6+ZuvgIC1IvAlnigQCeLh8c
Rds6BNWGk5I9ytGZOjPjHao=
=nuG9
-----END PGP SIGNATURE-----


From josejx at gentoo.org  Sun Jul 29 19:44:30 2007
From: josejx at gentoo.org (Joseph Jezak)
Date: Sun, 29 Jul 2007 13:44:30 -0400
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <46ACC7C4.5060808@richardharman.com>
References: <46ACC7C4.5060808@richardharman.com>
Message-ID: <46ACD1FE.3030208@gentoo.org>

Richard Harman wrote:
> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA1
> 
> Some local searching of the list didn't come up with much, and some
> interactive poking of Jose on irc helped.
> 
> Larry- I have a 4311 that I can let you borrow.  Infact, in about two
> weeks, you can borrow the entire horking laptop that it came with.
> 
> Send me your mailing address off list, and I'll be more than happy to
> ship the whole thing to you.
> 
> (one warning though: this laptop, along with the entire HP pavilion
> dv6000/dv9000 series appears to have apic/acpi problems.)

Just an FYI about the card.  It's a mini PCIe card with a 4311 
ChipID.  It appears to be supported in the 4.131.27.0 driver 
revision that I'm currently looking at.  It uses the d11ucode13 
ucode along with the rev13 initvals.  I'll update the specs if I 
find anything else, but I'm not sure how much time I'll have to put 
into this for the next few weeks.

-Joe


From mansour77 at yahoo.com  Sun Jul 29 20:23:36 2007
From: mansour77 at yahoo.com (Mansour)
Date: Sun, 29 Jul 2007 15:23:36 -0300
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <46ACD1FE.3030208@gentoo.org>
References: <46ACC7C4.5060808@richardharman.com> <46ACD1FE.3030208@gentoo.org>
Message-ID: <46ACDB28.4030009@yahoo.com>

I have the same laptop HP (dv9000)  model DV9408ca with min PCI card. 
extra info is attached. Does this mean that mine is supported?

I am getting :
 bcm43xx: Unsupported 80211 core revision 13



Joseph Jezak wrote:
> Richard Harman wrote:
>   
>> -----BEGIN PGP SIGNED MESSAGE-----
>> Hash: SHA1
>>
>> Some local searching of the list didn't come up with much, and some
>> interactive poking of Jose on irc helped.
>>
>> Larry- I have a 4311 that I can let you borrow.  Infact, in about two
>> weeks, you can borrow the entire horking laptop that it came with.
>>
>> Send me your mailing address off list, and I'll be more than happy to
>> ship the whole thing to you.
>>
>> (one warning though: this laptop, along with the entire HP pavilion
>> dv6000/dv9000 series appears to have apic/acpi problems.)
>>     
>
> Just an FYI about the card.  It's a mini PCIe card with a 4311 
> ChipID.  It appears to be supported in the 4.131.27.0 driver 
> revision that I'm currently looking at.  It uses the d11ucode13 
> ucode along with the rev13 initvals.  I'll update the specs if I 
> find anything else, but I'm not sure how much time I'll have to put 
> into this for the next few weeks.
>
> -Joe
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
>   

-------------- next part --------------
A non-text attachment was scrubbed...
Name: troubleshoot.tar.gz
Type: application/x-gzip
Size: 10875 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070729/de7dfcc0/attachment.bin>

From josejx at gentoo.org  Sun Jul 29 20:43:07 2007
From: josejx at gentoo.org (Joseph Jezak)
Date: Sun, 29 Jul 2007 14:43:07 -0400
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <46ACDB28.4030009@yahoo.com>
References: <46ACC7C4.5060808@richardharman.com> <46ACD1FE.3030208@gentoo.org>
	<46ACDB28.4030009@yahoo.com>
Message-ID: <46ACDFBB.80301@gentoo.org>

Mansour wrote:
> I have the same laptop HP (dv9000)  model DV9408ca with min PCI card. 
> extra info is attached. Does this mean that mine is supported?
> 
> I am getting :
> bcm43xx: Unsupported 80211 core revision 13

Yes, that's the same error.

-Joe


From mansour77 at yahoo.com  Sun Jul 29 21:34:35 2007
From: mansour77 at yahoo.com (Mansour)
Date: Sun, 29 Jul 2007 16:34:35 -0300
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <46ACDFBB.80301@gentoo.org>
References: <46ACC7C4.5060808@richardharman.com> <46ACD1FE.3030208@gentoo.org>
	<46ACDB28.4030009@yahoo.com> <46ACDFBB.80301@gentoo.org>
Message-ID: <46ACEBCB.6070003@yahoo.com>

Great, and regarding the acpi, I have to boot with pci=noacpi. Am I wrong ?


Joseph Jezak wrote:
> Mansour wrote:
>> I have the same laptop HP (dv9000)  model DV9408ca with min PCI card. 
>> extra info is attached. Does this mean that mine is supported?
>>
>> I am getting :
>> bcm43xx: Unsupported 80211 core revision 13
>
> Yes, that's the same error.
>
> -Joe
>



From john.j35 at gmail.com  Sun Jul 29 23:37:50 2007
From: john.j35 at gmail.com (John Pierce)
Date: Sun, 29 Jul 2007 16:37:50 -0500
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <46ACEBCB.6070003@yahoo.com>
References: <46ACC7C4.5060808@richardharman.com> <46ACD1FE.3030208@gentoo.org>
	<46ACDB28.4030009@yahoo.com> <46ACDFBB.80301@gentoo.org>
	<46ACEBCB.6070003@yahoo.com>
Message-ID: <aa73b9a0707291437k33d4b6ebj41fcb49cb60121da@mail.gmail.com>

On 7/29/07, Mansour <mansour77 at yahoo.com> wrote:
> Great, and regarding the acpi, I have to boot with pci=noacpi. Am I wrong ?
>
>
> Joseph Jezak wrote:
> > Mansour wrote:
> >> I have the same laptop HP (dv9000)  model DV9408ca with min PCI card.
> >> extra info is attached. Does this mean that mine is supported?
> >>
> >> I am getting :
> >> bcm43xx: Unsupported 80211 core revision 13
> >
I have a DV9208NR and I have had no acpi problems.  However, I have to
boot with the pci=nommconf in order for the ndiswrapper to drive the
broadcom 4311.  I periodically black list the ndiswrapper and enable
the bcm43xx-80211 driver and this past week was the first time I could
get the native driver to associate with my router using wep
encryption.

I could not get more than 11m out of it though.  If I tried to force
it to any rate greater than 11 then it would associate, but it would
not allow any through put.

-- 
John
Registered Linux User 263680, get counted at
http://counter.li.org


From richie at coderworld.net  Sun Jul 29 23:53:24 2007
From: richie at coderworld.net (Richard Jonsson)
Date: Sun, 29 Jul 2007 23:53:24 +0200
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <46AB5B9F.7030601@lwfinger.net>
References: <46AB5B9F.7030601@lwfinger.net>
Message-ID: <200707292353.24897.richie@coderworld.net>

I have tried using this patch applied to kernel 2.6.22.1 on a 4311 chip. The 
module loads fine, but when attempting to associate the computer hangs.

I'm doing fine with bcm43xx, but was tempted to try bcm4301 since the numbers 
looked so promising.
-------------- next part --------------
[    0.000000] Linux version 2.6.22.1 (root at richie-laptop) (gcc version 4.1.2 (Ubuntu 4.1.2-0ubuntu4)) #2 SMP Sun Jul 29 22:19:43 CEST 2007
[    0.000000] Command line: root=UUID=4083c050-c184-47b7-b25d-a154c0c2a074 ro single
[    0.000000] BIOS-provided physical RAM map:
[    0.000000]  BIOS-e820: 0000000000000000 - 000000000009dc00 (usable)
[    0.000000]  BIOS-e820: 000000000009dc00 - 00000000000a0000 (reserved)
[    0.000000]  BIOS-e820: 00000000000d2000 - 0000000000100000 (reserved)
[    0.000000]  BIOS-e820: 0000000000100000 - 000000003bf00000 (usable)
[    0.000000]  BIOS-e820: 000000003bf00000 - 000000003bf17000 (ACPI data)
[    0.000000]  BIOS-e820: 000000003bf17000 - 000000003bf80000 (ACPI NVS)
[    0.000000]  BIOS-e820: 000000003bf80000 - 0000000040000000 (reserved)
[    0.000000]  BIOS-e820: 00000000e0000000 - 00000000f0000000 (reserved)
[    0.000000]  BIOS-e820: 00000000fec00000 - 00000000fec10000 (reserved)
[    0.000000]  BIOS-e820: 00000000fed00000 - 00000000fed00400 (reserved)
[    0.000000]  BIOS-e820: 00000000fee00000 - 00000000fee01000 (reserved)
[    0.000000]  BIOS-e820: 00000000fff80000 - 0000000100000000 (reserved)
[    0.000000] Entering add_active_range(0, 0, 157) 0 entries of 3200 used
[    0.000000] Entering add_active_range(0, 256, 245504) 1 entries of 3200 used
[    0.000000] end_pfn_map = 1048576
[    0.000000] DMI present.
[    0.000000] ACPI: RSDP 000F87A0, 0024 (r3 HPQOEM)
[    0.000000] ACPI: XSDT 3BF10031, 005C (r1 HPQOEM SLIC-MPC  6040000  LTP        0)
[    0.000000] ACPI: FACP 3BF16AA6, 00F4 (r3 HPQOEM SLIC-MPC  6040000 PTL     F4240)
[    0.000000] ACPI: DSDT 3BF1008D, 6A19 (r1 HPQOEM SLIC-MPC  6040000 MSFT  100000E)
[    0.000000] ACPI: FACS 3BF17FC0, 0040
[    0.000000] ACPI: SLIC 3BF16C0E, 0176 (r1 HPQOEM SLIC-MPC  6040000 HPQ         1)
[    0.000000] ACPI: MCFG 3BF16D84, 003C (r1 HPQOEM SLIC-MPC  6040000  LTP        0)
[    0.000000] ACPI: HPET 3BF16DC0, 0038 (r1 HPQOEM SLIC-MPC  6040000  LTP        1)
[    0.000000] ACPI: APIC 3BF16DF8, 005E (r1 HPQOEM SLIC-MPC  6040000  LTP        0)
[    0.000000] ACPI: BOOT 3BF16E56, 0028 (r1 HPQOEM SLIC-MPC  6040000  LTP        1)
[    0.000000] ACPI: SSDT 3BF16E7E, 0182 (r1 HPQOEM SLIC-MPC  6040000  LTP        1)
[    0.000000] Scanning NUMA topology in Northbridge 24
[    0.000000] No NUMA configuration found
[    0.000000] Faking a node at 0000000000000000-000000003bf00000
[    0.000000] Entering add_active_range(0, 0, 157) 0 entries of 3200 used
[    0.000000] Entering add_active_range(0, 256, 245504) 1 entries of 3200 used
[    0.000000] Bootmem setup node 0 0000000000000000-000000003bf00000
[    0.000000] Zone PFN ranges:
[    0.000000]   DMA             0 ->     4096
[    0.000000]   DMA32        4096 ->  1048576
[    0.000000]   Normal    1048576 ->  1048576
[    0.000000] early_node_map[2] active PFN ranges
[    0.000000]     0:        0 ->      157
[    0.000000]     0:      256 ->   245504
[    0.000000] On node 0 totalpages: 245405
[    0.000000]   DMA zone: 56 pages used for memmap
[    0.000000]   DMA zone: 1368 pages reserved
[    0.000000]   DMA zone: 2573 pages, LIFO batch:0
[    0.000000]   DMA32 zone: 3300 pages used for memmap
[    0.000000]   DMA32 zone: 238108 pages, LIFO batch:31
[    0.000000]   Normal zone: 0 pages used for memmap
[    0.000000] ACPI: PM-Timer IO Port: 0x1008
[    0.000000] ACPI: Local APIC address 0xfee00000
[    0.000000] ACPI: LAPIC (acpi_id[0x00] lapic_id[0x00] enabled)
[    0.000000] Processor #0 (Bootup-CPU)
[    0.000000] ACPI: LAPIC (acpi_id[0x01] lapic_id[0x01] enabled)
[    0.000000] Processor #1
[    0.000000] ACPI: LAPIC_NMI (acpi_id[0x00] high edge lint[0x1])
[    0.000000] ACPI: LAPIC_NMI (acpi_id[0x01] high edge lint[0x1])
[    0.000000] ACPI: IOAPIC (id[0x02] address[0xfec00000] gsi_base[0])
[    0.000000] IOAPIC[0]: apic_id 2, address 0xfec00000, GSI 0-23
[    0.000000] ACPI: INT_SRC_OVR (bus 0 bus_irq 0 global_irq 2 dfl dfl)
[    0.000000] ACPI: IRQ0 used by override.
[    0.000000] ACPI: IRQ2 used by override.
[    0.000000] ACPI: IRQ9 used by override.
[    0.000000] Setting APIC routing to flat
[    0.000000] ACPI: HPET id: 0x10de8201 base: 0xfed00000
[    0.000000] Using ACPI (MADT) for SMP configuration information
[    0.000000] swsusp: Registered nosave memory region: 000000000009d000 - 000000000009e000
[    0.000000] swsusp: Registered nosave memory region: 000000000009e000 - 00000000000a0000
[    0.000000] swsusp: Registered nosave memory region: 00000000000a0000 - 00000000000d2000
[    0.000000] swsusp: Registered nosave memory region: 00000000000d2000 - 0000000000100000
[    0.000000] Allocating PCI resources starting at 50000000 (gap: 40000000:a0000000)
[    0.000000] SMP: Allowing 2 CPUs, 0 hotplug CPUs
[    0.000000] PERCPU: Allocating 34056 bytes of per cpu data
[    0.000000] Built 1 zonelists.  Total pages: 240681
[    0.000000] Kernel command line: root=UUID=4083c050-c184-47b7-b25d-a154c0c2a074 ro single
[    0.000000] Initializing CPU#0
[    0.000000] PID hash table entries: 4096 (order: 12, 32768 bytes)
[    0.000000] Extended CMOS year: 2000
[    0.000000] Marking TSC unstable due to TSCs unsynchronized
[   17.163806] time.c: Detected 1607.316 MHz processor.
[   17.166954] Console: colour VGA+ 80x25
[   17.170272] Checking aperture...
[   17.170323] CPU 0: aperture @ 2000000000 size 32 MB
[   17.170374] Aperture too small (32 MB)
[   17.177457] No AGP bridge found
[   17.189446] Memory: 958604k/982016k available (2885k kernel code, 23016k reserved, 1637k data, 316k init)
[   17.269571] Calibrating delay using timer specific routine.. 3217.41 BogoMIPS (lpj=6434834)
[   17.269717] Security Framework v1.0.0 initialized
[   17.269772] SELinux:  Disabled at boot.
[   17.269939] Dentry cache hash table entries: 131072 (order: 8, 1048576 bytes)
[   17.270739] Inode-cache hash table entries: 65536 (order: 7, 524288 bytes)
[   17.271063] Mount-cache hash table entries: 256
[   17.271224] CPU: L1 I Cache: 64K (64 bytes/line), D cache 64K (64 bytes/line)
[   17.271279] CPU: L2 Cache: 512K (64 bytes/line)
[   17.271330] CPU 0/0 -> Node 0
[   17.271379] CPU: Physical Processor ID: 0
[   17.271428] CPU: Processor Core ID: 0
[   17.271494] SMP alternatives: switching to UP code
[   17.271714] ACPI: Core revision 20070126
[   17.497421] Using local APIC timer interrupts.
[   17.559681] result 12557153
[   17.559730] Detected 12.557 MHz APIC timer.
[   17.561637] SMP alternatives: switching to SMP code
[   17.561818] Booting processor 1/2 APIC 0x1
[   17.574130] Initializing CPU#1
[   17.651697] Calibrating delay using timer specific routine.. 3214.72 BogoMIPS (lpj=6429452)
[   17.651705] CPU: L1 I Cache: 64K (64 bytes/line), D cache 64K (64 bytes/line)
[   17.651708] CPU: L2 Cache: 512K (64 bytes/line)
[   17.651711] CPU 1/1 -> Node 0
[   17.651713] CPU: Physical Processor ID: 0
[   17.651714] CPU: Processor Core ID: 1
[   17.651807] AMD Turion(tm) 64 X2  stepping 02
[   17.653526] Brought up 2 CPUs
[   17.760066] migration_cost=299
[   17.758097] PM: Adding info for No Bus:platform
[   17.758224] NET: Registered protocol family 16
[   17.758309] PM: Adding info for No Bus:vtcon0
[   17.758369] ACPI: bus type pci registered
[   17.758676] PCI: Using MMCONFIG at e0000000 - e04fffff
[   17.758761] PCI: No mmconfig possible on device 00:18
[   17.758940] PCI: No mmconfig possible on device 05:09
[   17.762782] ACPI: System BIOS is requesting _OSI(Linux)
[   17.762836] ACPI: Please test with "acpi_osi=!Linux"
[   17.762837] Please send dmidecode to linux-acpi at vger.kernel.org
[   17.763287] ACPI: Interpreter enabled
[   17.763337] ACPI: (supports S0 S3 S4 S5)
[   17.763582] ACPI: Using IOAPIC for interrupt routing
[   17.763727] PM: Adding info for acpi:acpi_system:00
[   17.763779] PM: Adding info for acpi:button_power:00
[   17.763820] PM: Adding info for acpi:ACPI0007:00
[   17.763860] PM: Adding info for acpi:ACPI0007:01
[   17.763915] PM: Adding info for acpi:device:00
[   17.764037] PM: Adding info for acpi:HPQ0006:00
[   17.764091] PM: Adding info for acpi:PNP0C14:00
[   17.764245] PM: Adding info for acpi:PNP0C0D:00
[   17.764297] PM: Adding info for acpi:PNP0C0E:00
[   17.764418] PM: Adding info for acpi:PNP0C0C:00
[   17.764546] PM: Adding info for acpi:PNP0A03:00
[   17.764607] PM: Adding info for acpi:video:00
[   17.764657] PM: Adding info for acpi:device:01
[   17.764711] PM: Adding info for acpi:device:02
[   17.764767] PM: Adding info for acpi:device:03
[   17.764819] PM: Adding info for acpi:device:04
[   17.764866] PM: Adding info for acpi:PNP0C02:00
[   17.764918] PM: Adding info for acpi:PNP0C02:01
[   17.764974] PM: Adding info for acpi:PNP0C02:02
[   17.765024] PM: Adding info for acpi:PNP0000:00
[   17.765072] PM: Adding info for acpi:PNP0100:00
[   17.765128] PM: Adding info for acpi:PNP0200:00
[   17.765177] PM: Adding info for acpi:PNP0800:00
[   17.765230] PM: Adding info for acpi:PNP0B00:00
[   17.765280] PM: Adding info for acpi:PNP0C04:00
[   17.765568] PM: Adding info for acpi:PNP0103:00
[   17.766261] PM: Adding info for acpi:PNP0303:00
[   17.767654] PM: Adding info for acpi:SYN0127:00
[   17.767795] PM: Adding info for acpi:PNP0C09:00
[   17.767960] PM: Adding info for acpi:PNP0C32:00
[   17.768110] PM: Adding info for acpi:PNP0C32:01
[   17.768261] PM: Adding info for acpi:PNP0C32:02
[   17.768412] PM: Adding info for acpi:PNP0C32:03
[   17.768563] PM: Adding info for acpi:PNP0C32:04
[   17.768711] PM: Adding info for acpi:PNP0C32:05
[   17.770055] PM: Adding info for acpi:PNP0C0A:00
[   17.770183] PM: Adding info for acpi:ACPI0003:00
[   17.770242] PM: Adding info for acpi:device:05
[   17.770295] PM: Adding info for acpi:device:06
[   17.770350] PM: Adding info for acpi:device:07
[   17.770403] PM: Adding info for acpi:device:08
[   17.770459] PM: Adding info for acpi:device:09
[   17.770512] PM: Adding info for acpi:device:0a
[   17.770565] PM: Adding info for acpi:device:0b
[   17.770694] PM: Adding info for acpi:device:0c
[   17.770806] PM: Adding info for acpi:device:0d
[   17.770865] PM: Adding info for acpi:device:0e
[   17.770917] PM: Adding info for acpi:device:0f
[   17.770967] PM: Adding info for acpi:device:10
[   17.771025] PM: Adding info for acpi:device:11
[   17.771077] PM: Adding info for acpi:device:12
[   17.771128] PM: Adding info for acpi:device:13
[   17.771184] PM: Adding info for acpi:device:14
[   17.771243] PM: Adding info for acpi:device:15
[   17.771293] PM: Adding info for acpi:device:16
[   17.771346] PM: Adding info for acpi:device:17
[   17.771401] PM: Adding info for acpi:device:18
[   17.771458] PM: Adding info for acpi:device:19
[   17.771588] PM: Adding info for acpi:device:1a
[   17.771719] PM: Adding info for acpi:device:1b
[   17.771778] PM: Adding info for acpi:device:1c
[   17.771907] PM: Adding info for acpi:device:1d
[   17.771963] PM: Adding info for acpi:device:1e
[   17.772122] PM: Adding info for acpi:PNP0C0F:00
[   17.772264] PM: Adding info for acpi:PNP0C0F:01
[   17.772409] PM: Adding info for acpi:PNP0C0F:02
[   17.772555] PM: Adding info for acpi:PNP0C0F:03
[   17.772703] PM: Adding info for acpi:PNP0C0F:04
[   17.772849] PM: Adding info for acpi:PNP0C0F:05
[   17.772994] PM: Adding info for acpi:PNP0C0F:06
[   17.773141] PM: Adding info for acpi:PNP0C0F:07
[   17.773285] PM: Adding info for acpi:PNP0C0F:08
[   17.773431] PM: Adding info for acpi:PNP0C0F:09
[   17.773614] PM: Adding info for acpi:PNP0C0F:0a
[   17.773761] PM: Adding info for acpi:PNP0C0F:0b
[   17.773906] PM: Adding info for acpi:PNP0C0F:0c
[   17.774052] PM: Adding info for acpi:PNP0C0F:0d
[   17.774201] PM: Adding info for acpi:PNP0C0F:0e
[   17.774349] PM: Adding info for acpi:PNP0C0F:0f
[   17.774498] PM: Adding info for acpi:PNP0C0F:10
[   17.774645] PM: Adding info for acpi:PNP0C0F:11
[   17.774796] PM: Adding info for acpi:PNP0C0F:12
[   17.774849] PM: Adding info for acpi:thermal:00
[   17.774894] PM: Adding info for acpi:thermal:01
[   17.774942] PM: Adding info for acpi:thermal:02
[   17.785796] ACPI: PCI Root Bridge [PCI0] (0000:00)
[   17.785858] PCI: Probing PCI hardware (bus 00)
[   17.785872] PM: Adding info for No Bus:pci0000:00
[   17.786958] PCI: Transparent bridge - 0000:00:10.0
[   17.787036] ACPI: PCI Interrupt Routing Table [\_SB_.PCI0._PRT]
[   17.787175] ACPI: PCI Interrupt Routing Table [\_SB_.PCI0.P2P0._PRT]
[   17.787230] ACPI: PCI Interrupt Routing Table [\_SB_.PCI0.XVR1._PRT]
[   17.787273] ACPI: PCI Interrupt Routing Table [\_SB_.PCI0.XVR2._PRT]
[   17.791289] PM: Adding info for pci:0000:00:00.0
[   17.795307] PM: Adding info for pci:0000:00:00.1
[   17.799091] PM: Adding info for pci:0000:00:00.2
[   17.803011] PM: Adding info for pci:0000:00:00.3
[   17.806562] PM: Adding info for pci:0000:00:00.4
[   17.810370] PM: Adding info for pci:0000:00:00.5
[   17.813853] PM: Adding info for pci:0000:00:00.6
[   17.818591] PM: Adding info for pci:0000:00:00.7
[   17.822511] PM: Adding info for pci:0000:00:02.0
[   17.826062] PM: Adding info for pci:0000:00:03.0
[   17.830108] PM: Adding info for pci:0000:00:05.0
[   17.833598] PM: Adding info for pci:0000:00:09.0
[   17.838023] PM: Adding info for pci:0000:00:0a.0
[   17.841894] PM: Adding info for pci:0000:00:0a.1
[   17.845367] PM: Adding info for pci:0000:00:0a.3
[   17.849229] PM: Adding info for pci:0000:00:0b.0
[   17.852788] PM: Adding info for pci:0000:00:0b.1
[   17.857026] PM: Adding info for pci:0000:00:0d.0
[   17.861064] PM: Adding info for pci:0000:00:0e.0
[   17.864620] PM: Adding info for pci:0000:00:10.0
[   17.868421] PM: Adding info for pci:0000:00:10.1
[   17.871974] PM: Adding info for pci:0000:00:14.0
[   17.876279] PM: Adding info for pci:0000:00:18.0
[   17.879813] PM: Adding info for pci:0000:00:18.1
[   17.883810] PM: Adding info for pci:0000:00:18.2
[   17.887804] PM: Adding info for pci:0000:00:18.3
[   17.887859] PM: Adding info for pci:0000:01:00.0
[   17.887902] PM: Adding info for pci:0000:05:09.0
[   17.887947] PM: Adding info for pci:0000:05:09.1
[   17.887989] PM: Adding info for pci:0000:05:09.2
[   17.888032] PM: Adding info for pci:0000:05:09.3
[   17.888075] PM: Adding info for pci:0000:05:09.4
[   17.888401] ACPI: PCI Interrupt Link [LNK1] (IRQs 16 17 18 22 23) *0, disabled.
[   17.889017] ACPI: PCI Interrupt Link [LNK2] (IRQs 16 17 18 22 23) *10
[   17.889587] ACPI: PCI Interrupt Link [LNK3] (IRQs 5 7 10 *11 14 15)
[   17.890152] ACPI: PCI Interrupt Link [LNK4] (IRQs 5 7 10 11 14 15) *0, disabled.
[   17.890796] ACPI: PCI Interrupt Link [LK1E] (IRQs 20) *0, disabled.
[   17.891253] ACPI: PCI Interrupt Link [LK2E] (IRQs 19) *10
[   17.891677] ACPI: PCI Interrupt Link [LK3E] (IRQs 21) *10
[   17.892098] ACPI: PCI Interrupt Link [LK4E] (IRQs 16 17 18 22 23) *0, disabled.
[   17.892707] ACPI: PCI Interrupt Link [LSMB] (IRQs 16 17 18 22 23) *10
[   17.893276] ACPI: PCI Interrupt Link [LSMU] (IRQs 16 17 18 22 23) *11
[   17.893841] ACPI: PCI Interrupt Link [LUS0] (IRQs 16 17 18 22 23) *11
[   17.894409] ACPI: PCI Interrupt Link [LUS2] (IRQs 16 17 18 22 23) *7
[   17.894976] ACPI: PCI Interrupt Link [LMAC] (IRQs 16 17 18 22 23) *11
[   17.895547] ACPI: PCI Interrupt Link [LAZA] (IRQs 16 17 18 22 23) *0, disabled.
[   17.896163] ACPI: PCI Interrupt Link [LACI] (IRQs 16 17 18 22 23) *0, disabled.
[   17.896773] ACPI: PCI Interrupt Link [LMCI] (IRQs 16 17 18 22 23) *0, disabled.
[   17.897385] ACPI: PCI Interrupt Link [LPID] (IRQs 16 17 18 22 23) *0, disabled.
[   17.898004] ACPI: PCI Interrupt Link [LTID] (IRQs 16 17 18 22 23) *5
[   17.898575] ACPI: PCI Interrupt Link [LSI1] (IRQs 16 17 18 22 23) *0
[   17.899012] Linux Plug and Play Support v0.97 (c) Adam Belay
[   17.899073] pnp: PnP ACPI init
[   17.899128] PM: Adding info for No Bus:pnp0
[   17.899136] ACPI: bus type pnp registered
[   17.899479] PM: Adding info for pnp:00:00
[   17.899572] PM: Adding info for pnp:00:01
[   17.899869] PM: Adding info for pnp:00:02
[   17.899925] PM: Adding info for pnp:00:03
[   17.899980] PM: Adding info for pnp:00:04
[   17.900025] PM: Adding info for pnp:00:05
[   17.900118] PM: Adding info for pnp:00:06
[   17.900179] PM: Adding info for pnp:00:07
[   17.900345] PM: Adding info for pnp:00:08
[   17.900401] PM: Adding info for pnp:00:09
[   17.900462] PM: Adding info for pnp:00:0a
[   17.902794] pnp: PnP ACPI: found 11 devices
[   17.902847] ACPI: ACPI bus type pnp unregistered
[   17.903027] SCSI subsystem initialized
[   17.903124] libata version 2.21 loaded.
[   17.903173] PCI: Using ACPI for IRQ routing
[   17.903225] PCI: If a device doesn't work, try "pci=routeirq".  If it helps, post a report
[   17.903380] NET: Registered protocol family 8
[   17.903431] NET: Registered protocol family 20
[   17.903599] ACPI: RTC can wake from S4
[   17.903667] Time: hpet clocksource has been installed.
[   17.903778] pnp: 00:01: iomem range 0xe0000000-0xefffffff could not be reserved
[   17.903845] pnp: 00:02: ioport range 0x1000-0x107f has been reserved
[   17.903899] pnp: 00:02: ioport range 0x1080-0x10ff has been reserved
[   17.903952] pnp: 00:02: ioport range 0x1400-0x147f has been reserved
[   17.904006] pnp: 00:02: ioport range 0x1480-0x14ff has been reserved
[   17.904059] pnp: 00:02: ioport range 0x1800-0x187f has been reserved
[   17.904113] pnp: 00:02: ioport range 0x1880-0x18ff has been reserved
[   17.904166] pnp: 00:02: ioport range 0x2000-0x203f has been reserved
[   17.904236] PM: Adding info for No Bus:mem
[   17.904273] PM: Adding info for No Bus:kmem
[   17.904304] PM: Adding info for No Bus:null
[   17.904333] PM: Adding info for No Bus:port
[   17.904366] PM: Adding info for No Bus:zero
[   17.904397] PM: Adding info for No Bus:full
[   17.904427] PM: Adding info for No Bus:random
[   17.904456] PM: Adding info for No Bus:urandom
[   17.904491] PM: Adding info for No Bus:kmsg
[   17.904546] PCI: Bridge: 0000:00:02.0
[   17.904595]   IO window: disabled.
[   17.904646]   MEM window: b3000000-b30fffff
[   17.904697]   PREFETCH window: disabled.
[   17.904746] PCI: Bridge: 0000:00:03.0
[   17.904796]   IO window: 4000-4fff
[   17.904846]   MEM window: b4000000-b7ffffff
[   17.904898]   PREFETCH window: d0000000-d01fffff
[   17.904950] PCI: Bridge: 0000:00:10.0
[   17.904998]   IO window: disabled.
[   17.905049]   MEM window: b8000000-b80fffff
[   17.905100]   PREFETCH window: disabled.
[   17.905157] PCI: Setting latency timer of device 0000:00:02.0 to 64
[   17.905162] PCI: Setting latency timer of device 0000:00:03.0 to 64
[   17.905169] PCI: Setting latency timer of device 0000:00:10.0 to 64
[   17.905269] NET: Registered protocol family 2
[   17.951737] IP route cache hash table entries: 32768 (order: 6, 262144 bytes)
[   17.952289] TCP established hash table entries: 131072 (order: 9, 3145728 bytes)
[   17.954481] TCP bind hash table entries: 65536 (order: 8, 1048576 bytes)
[   17.955149] TCP: Hash tables configured (established 131072 bind 65536)
[   17.955204] TCP reno registered
[   17.971812] checking if image is initramfs... it is
[   18.363117] Freeing initrd memory: 3951k freed
[   18.365904] Simple Boot Flag at 0x36 set to 0x1
[   18.366061] PM: Adding info for No Bus:mcelog
[   18.366436] PM: Adding info for platform:pcspkr
[   18.366561] PM: Adding info for No Bus:snapshot
[   18.366593] audit: initializing netlink socket (disabled)
[   18.366657] audit(1185751119.964:1): initialized
[   18.366877] VFS: Disk quotas dquot_6.5.1
[   18.366937] Dquot-cache hash table entries: 512 (order 0, 4096 bytes)
[   18.367102] io scheduler noop registered
[   18.367152] io scheduler anticipatory registered
[   18.367202] io scheduler deadline registered
[   18.367265] io scheduler cfq registered (default)
[   18.367328] Boot video device is 0000:00:05.0
[   18.584126] PCI: Setting latency timer of device 0000:00:02.0 to 64
[   18.584144] assign_interrupt_mode Found MSI capability
[   18.584211] Allocate Port Service[0000:00:02.0:pcie00]
[   18.584220] PM: Adding info for pci_express:0000:00:02.0:pcie00
[   18.584254] Allocate Port Service[0000:00:02.0:pcie03]
[   18.584260] PM: Adding info for pci_express:0000:00:02.0:pcie03
[   18.584311] PCI: Setting latency timer of device 0000:00:03.0 to 64
[   18.584326] assign_interrupt_mode Found MSI capability
[   18.584389] Allocate Port Service[0000:00:03.0:pcie00]
[   18.584397] PM: Adding info for pci_express:0000:00:03.0:pcie00
[   18.584427] Allocate Port Service[0000:00:03.0:pcie03]
[   18.584433] PM: Adding info for pci_express:0000:00:03.0:pcie03
[   18.584679] ACPI: Processor [CPU0] (supports 8 throttling states)
[   18.584867] ACPI: Processor [CPU1] (supports 8 throttling states)
[   18.603001] ACPI: Thermal Zone [TZS0] (67 C)
[   18.608097] ACPI: Thermal Zone [TZS1] (70 C)
[   18.608170] PM: Adding info for No Bus:tty
[   18.608206] PM: Adding info for No Bus:console
[   18.608241] PM: Adding info for No Bus:ptmx
[   18.608272] PM: Adding info for No Bus:tty0
[   18.608313] PM: Adding info for No Bus:vcs
[   18.608346] PM: Adding info for No Bus:vcsa
[   18.608379] PM: Adding info for No Bus:tty1
[   18.608410] PM: Adding info for No Bus:tty2
[   18.608441] PM: Adding info for No Bus:tty3
[   18.608475] PM: Adding info for No Bus:tty4
[   18.608505] PM: Adding info for No Bus:tty5
[   18.608539] PM: Adding info for No Bus:tty6
[   18.608573] PM: Adding info for No Bus:tty7
[   18.608604] PM: Adding info for No Bus:tty8
[   18.608634] PM: Adding info for No Bus:tty9
[   18.608666] PM: Adding info for No Bus:tty10
[   18.608701] PM: Adding info for No Bus:tty11
[   18.608734] PM: Adding info for No Bus:tty12
[   18.608768] PM: Adding info for No Bus:tty13
[   18.608803] PM: Adding info for No Bus:tty14
[   18.608836] PM: Adding info for No Bus:tty15
[   18.608867] PM: Adding info for No Bus:tty16
[   18.608899] PM: Adding info for No Bus:tty17
[   18.608934] PM: Adding info for No Bus:tty18
[   18.608967] PM: Adding info for No Bus:tty19
[   18.609000] PM: Adding info for No Bus:tty20
[   18.609035] PM: Adding info for No Bus:tty21
[   18.609067] PM: Adding info for No Bus:tty22
[   18.609100] PM: Adding info for No Bus:tty23
[   18.609132] PM: Adding info for No Bus:tty24
[   18.609167] PM: Adding info for No Bus:tty25
[   18.609199] PM: Adding info for No Bus:tty26
[   18.609232] PM: Adding info for No Bus:tty27
[   18.609268] PM: Adding info for No Bus:tty28
[   18.609300] PM: Adding info for No Bus:tty29
[   18.609332] PM: Adding info for No Bus:tty30
[   18.609364] PM: Adding info for No Bus:tty31
[   18.609401] PM: Adding info for No Bus:tty32
[   18.609433] PM: Adding info for No Bus:tty33
[   18.609466] PM: Adding info for No Bus:tty34
[   18.609503] PM: Adding info for No Bus:tty35
[   18.609535] PM: Adding info for No Bus:tty36
[   18.609568] PM: Adding info for No Bus:tty37
[   18.609600] PM: Adding info for No Bus:tty38
[   18.609636] PM: Adding info for No Bus:tty39
[   18.609670] PM: Adding info for No Bus:tty40
[   18.609702] PM: Adding info for No Bus:tty41
[   18.609740] PM: Adding info for No Bus:tty42
[   18.609773] PM: Adding info for No Bus:tty43
[   18.609808] PM: Adding info for No Bus:tty44
[   18.609841] PM: Adding info for No Bus:tty45
[   18.609876] PM: Adding info for No Bus:tty46
[   18.609910] PM: Adding info for No Bus:tty47
[   18.609944] PM: Adding info for No Bus:tty48
[   18.609981] PM: Adding info for No Bus:tty49
[   18.610016] PM: Adding info for No Bus:tty50
[   18.610050] PM: Adding info for No Bus:tty51
[   18.610085] PM: Adding info for No Bus:tty52
[   18.610123] PM: Adding info for No Bus:tty53
[   18.610157] PM: Adding info for No Bus:tty54
[   18.610191] PM: Adding info for No Bus:tty55
[   18.610228] PM: Adding info for No Bus:tty56
[   18.610263] PM: Adding info for No Bus:tty57
[   18.610298] PM: Adding info for No Bus:tty58
[   18.610334] PM: Adding info for No Bus:tty59
[   18.610371] PM: Adding info for No Bus:tty60
[   18.610406] PM: Adding info for No Bus:tty61
[   18.610439] PM: Adding info for No Bus:tty62
[   18.610476] PM: Adding info for No Bus:tty63
[   18.610555] PM: Adding info for No Bus:ptyp0
[   18.610590] PM: Adding info for No Bus:ptyp1
[   18.610624] PM: Adding info for No Bus:ptyp2
[   18.610662] PM: Adding info for No Bus:ptyp3
[   18.610697] PM: Adding info for No Bus:ptyp4
[   18.610732] PM: Adding info for No Bus:ptyp5
[   18.610770] PM: Adding info for No Bus:ptyp6
[   18.610805] PM: Adding info for No Bus:ptyp7
[   18.610841] PM: Adding info for No Bus:ptyp8
[   18.610875] PM: Adding info for No Bus:ptyp9
[   18.610912] PM: Adding info for No Bus:ptypa
[   18.610948] PM: Adding info for No Bus:ptypb
[   18.610982] PM: Adding info for No Bus:ptypc
[   18.611020] PM: Adding info for No Bus:ptypd
[   18.611055] PM: Adding info for No Bus:ptype
[   18.611092] PM: Adding info for No Bus:ptypf
[   18.611126] PM: Adding info for No Bus:ptyq0
[   18.611163] PM: Adding info for No Bus:ptyq1
[   18.611198] PM: Adding info for No Bus:ptyq2
[   18.611233] PM: Adding info for No Bus:ptyq3
[   18.611271] PM: Adding info for No Bus:ptyq4
[   18.611306] PM: Adding info for No Bus:ptyq5
[   18.611344] PM: Adding info for No Bus:ptyq6
[   18.611379] PM: Adding info for No Bus:ptyq7
[   18.611417] PM: Adding info for No Bus:ptyq8
[   18.611452] PM: Adding info for No Bus:ptyq9
[   18.611488] PM: Adding info for No Bus:ptyqa
[   18.611527] PM: Adding info for No Bus:ptyqb
[   18.611571] PM: Adding info for No Bus:ptyqc
[   18.611607] PM: Adding info for No Bus:ptyqd
[   18.611644] PM: Adding info for No Bus:ptyqe
[   18.611685] PM: Adding info for No Bus:ptyqf
[   18.611720] PM: Adding info for No Bus:ptyr0
[   18.611755] PM: Adding info for No Bus:ptyr1
[   18.611793] PM: Adding info for No Bus:ptyr2
[   18.611832] PM: Adding info for No Bus:ptyr3
[   18.611869] PM: Adding info for No Bus:ptyr4
[   18.611907] PM: Adding info for No Bus:ptyr5
[   18.611945] PM: Adding info for No Bus:ptyr6
[   18.611983] PM: Adding info for No Bus:ptyr7
[   18.612019] PM: Adding info for No Bus:ptyr8
[   18.612057] PM: Adding info for No Bus:ptyr9
[   18.612093] PM: Adding info for No Bus:ptyra
[   18.612131] PM: Adding info for No Bus:ptyrb
[   18.612169] PM: Adding info for No Bus:ptyrc
[   18.612209] PM: Adding info for No Bus:ptyrd
[   18.612245] PM: Adding info for No Bus:ptyre
[   18.612282] PM: Adding info for No Bus:ptyrf
[   18.612322] PM: Adding info for No Bus:ptys0
[   18.612358] PM: Adding info for No Bus:ptys1
[   18.612395] PM: Adding info for No Bus:ptys2
[   18.612435] PM: Adding info for No Bus:ptys3
[   18.612476] PM: Adding info for No Bus:ptys4
[   18.612512] PM: Adding info for No Bus:ptys5
[   18.612549] PM: Adding info for No Bus:ptys6
[   18.612591] PM: Adding info for No Bus:ptys7
[   18.612627] PM: Adding info for No Bus:ptys8
[   18.612664] PM: Adding info for No Bus:ptys9
[   18.612702] PM: Adding info for No Bus:ptysa
[   18.612745] PM: Adding info for No Bus:ptysb
[   18.612783] PM: Adding info for No Bus:ptysc
[   18.612820] PM: Adding info for No Bus:ptysd
[   18.612861] PM: Adding info for No Bus:ptyse
[   18.612900] PM: Adding info for No Bus:ptysf
[   18.612938] PM: Adding info for No Bus:ptyt0
[   18.612975] PM: Adding info for No Bus:ptyt1
[   18.613021] PM: Adding info for No Bus:ptyt2
[   18.613060] PM: Adding info for No Bus:ptyt3
[   18.613097] PM: Adding info for No Bus:ptyt4
[   18.613137] PM: Adding info for No Bus:ptyt5
[   18.613174] PM: Adding info for No Bus:ptyt6
[   18.613213] PM: Adding info for No Bus:ptyt7
[   18.613251] PM: Adding info for No Bus:ptyt8
[   18.613293] PM: Adding info for No Bus:ptyt9
[   18.613333] PM: Adding info for No Bus:ptyta
[   18.613374] PM: Adding info for No Bus:ptytb
[   18.613416] PM: Adding info for No Bus:ptytc
[   18.613453] PM: Adding info for No Bus:ptytd
[   18.613491] PM: Adding info for No Bus:ptyte
[   18.613531] PM: Adding info for No Bus:ptytf
[   18.613572] PM: Adding info for No Bus:ptyu0
[   18.613611] PM: Adding info for No Bus:ptyu1
[   18.613649] PM: Adding info for No Bus:ptyu2
[   18.613695] PM: Adding info for No Bus:ptyu3
[   18.613735] PM: Adding info for No Bus:ptyu4
[   18.613776] PM: Adding info for No Bus:ptyu5
[   18.613816] PM: Adding info for No Bus:ptyu6
[   18.613859] PM: Adding info for No Bus:ptyu7
[   18.613899] PM: Adding info for No Bus:ptyu8
[   18.613938] PM: Adding info for No Bus:ptyu9
[   18.613980] PM: Adding info for No Bus:ptyua
[   18.614023] PM: Adding info for No Bus:ptyub
[   18.614062] PM: Adding info for No Bus:ptyuc
[   18.614102] PM: Adding info for No Bus:ptyud
[   18.614145] PM: Adding info for No Bus:ptyue
[   18.614187] PM: Adding info for No Bus:ptyuf
[   18.614228] PM: Adding info for No Bus:ptyv0
[   18.614271] PM: Adding info for No Bus:ptyv1
[   18.614310] PM: Adding info for No Bus:ptyv2
[   18.614350] PM: Adding info for No Bus:ptyv3
[   18.614390] PM: Adding info for No Bus:ptyv4
[   18.614434] PM: Adding info for No Bus:ptyv5
[   18.614474] PM: Adding info for No Bus:ptyv6
[   18.614517] PM: Adding info for No Bus:ptyv7
[   18.614564] PM: Adding info for No Bus:ptyv8
[   18.614606] PM: Adding info for No Bus:ptyv9
[   18.614647] PM: Adding info for No Bus:ptyva
[   18.614689] PM: Adding info for No Bus:ptyvb
[   18.614733] PM: Adding info for No Bus:ptyvc
[   18.614772] PM: Adding info for No Bus:ptyvd
[   18.614814] PM: Adding info for No Bus:ptyve
[   18.614860] PM: Adding info for No Bus:ptyvf
[   18.614901] PM: Adding info for No Bus:ptyw0
[   18.614942] PM: Adding info for No Bus:ptyw1
[   18.614982] PM: Adding info for No Bus:ptyw2
[   18.615027] PM: Adding info for No Bus:ptyw3
[   18.615070] PM: Adding info for No Bus:ptyw4
[   18.615112] PM: Adding info for No Bus:ptyw5
[   18.615158] PM: Adding info for No Bus:ptyw6
[   18.615201] PM: Adding info for No Bus:ptyw7
[   18.615242] PM: Adding info for No Bus:ptyw8
[   18.615283] PM: Adding info for No Bus:ptyw9
[   18.615330] PM: Adding info for No Bus:ptywa
[   18.615373] PM: Adding info for No Bus:ptywb
[   18.615415] PM: Adding info for No Bus:ptywc
[   18.615461] PM: Adding info for No Bus:ptywd
[   18.615503] PM: Adding info for No Bus:ptywe
[   18.615546] PM: Adding info for No Bus:ptywf
[   18.615593] PM: Adding info for No Bus:ptyx0
[   18.615638] PM: Adding info for No Bus:ptyx1
[   18.615681] PM: Adding info for No Bus:ptyx2
[   18.615726] PM: Adding info for No Bus:ptyx3
[   18.615772] PM: Adding info for No Bus:ptyx4
[   18.615815] PM: Adding info for No Bus:ptyx5
[   18.615857] PM: Adding info for No Bus:ptyx6
[   18.615901] PM: Adding info for No Bus:ptyx7
[   18.615947] PM: Adding info for No Bus:ptyx8
[   18.615991] PM: Adding info for No Bus:ptyx9
[   18.616033] PM: Adding info for No Bus:ptyxa
[   18.616081] PM: Adding info for No Bus:ptyxb
[   18.616126] PM: Adding info for No Bus:ptyxc
[   18.616168] PM: Adding info for No Bus:ptyxd
[   18.616211] PM: Adding info for No Bus:ptyxe
[   18.616265] PM: Adding info for No Bus:ptyxf
[   18.616308] PM: Adding info for No Bus:ptyy0
[   18.616351] PM: Adding info for No Bus:ptyy1
[   18.616397] PM: Adding info for No Bus:ptyy2
[   18.616443] PM: Adding info for No Bus:ptyy3
[   18.616486] PM: Adding info for No Bus:ptyy4
[   18.616529] PM: Adding info for No Bus:ptyy5
[   18.616577] PM: Adding info for No Bus:ptyy6
[   18.616623] PM: Adding info for No Bus:ptyy7
[   18.616665] PM: Adding info for No Bus:ptyy8
[   18.616712] PM: Adding info for No Bus:ptyy9
[   18.616757] PM: Adding info for No Bus:ptyya
[   18.616803] PM: Adding info for No Bus:ptyyb
[   18.616846] PM: Adding info for No Bus:ptyyc
[   18.616896] PM: Adding info for No Bus:ptyyd
[   18.616940] PM: Adding info for No Bus:ptyye
[   18.616987] PM: Adding info for No Bus:ptyyf
[   18.617034] PM: Adding info for No Bus:ptyz0
[   18.617079] PM: Adding info for No Bus:ptyz1
[   18.617127] PM: Adding info for No Bus:ptyz2
[   18.617173] PM: Adding info for No Bus:ptyz3
[   18.617221] PM: Adding info for No Bus:ptyz4
[   18.617265] PM: Adding info for No Bus:ptyz5
[   18.617309] PM: Adding info for No Bus:ptyz6
[   18.617358] PM: Adding info for No Bus:ptyz7
[   18.617403] PM: Adding info for No Bus:ptyz8
[   18.617451] PM: Adding info for No Bus:ptyz9
[   18.617496] PM: Adding info for No Bus:ptyza
[   18.617545] PM: Adding info for No Bus:ptyzb
[   18.617595] PM: Adding info for No Bus:ptyzc
[   18.617639] PM: Adding info for No Bus:ptyzd
[   18.617687] PM: Adding info for No Bus:ptyze
[   18.617734] PM: Adding info for No Bus:ptyzf
[   18.617780] PM: Adding info for No Bus:ptya0
[   18.617827] PM: Adding info for No Bus:ptya1
[   18.617876] PM: Adding info for No Bus:ptya2
[   18.617926] PM: Adding info for No Bus:ptya3
[   18.617975] PM: Adding info for No Bus:ptya4
[   18.618026] PM: Adding info for No Bus:ptya5
[   18.618071] PM: Adding info for No Bus:ptya6
[   18.618119] PM: Adding info for No Bus:ptya7
[   18.618167] PM: Adding info for No Bus:ptya8
[   18.618216] PM: Adding info for No Bus:ptya9
[   18.618261] PM: Adding info for No Bus:ptyaa
[   18.618309] PM: Adding info for No Bus:ptyab
[   18.618359] PM: Adding info for No Bus:ptyac
[   18.618406] PM: Adding info for No Bus:ptyad
[   18.618451] PM: Adding info for No Bus:ptyae
[   18.618503] PM: Adding info for No Bus:ptyaf
[   18.618552] PM: Adding info for No Bus:ptyb0
[   18.618598] PM: Adding info for No Bus:ptyb1
[   18.618645] PM: Adding info for No Bus:ptyb2
[   18.618697] PM: Adding info for No Bus:ptyb3
[   18.618743] PM: Adding info for No Bus:ptyb4
[   18.618791] PM: Adding info for No Bus:ptyb5
[   18.618839] PM: Adding info for No Bus:ptyb6
[   18.618890] PM: Adding info for No Bus:ptyb7
[   18.618937] PM: Adding info for No Bus:ptyb8
[   18.618984] PM: Adding info for No Bus:ptyb9
[   18.619037] PM: Adding info for No Bus:ptyba
[   18.619088] PM: Adding info for No Bus:ptybb
[   18.619134] PM: Adding info for No Bus:ptybc
[   18.619182] PM: Adding info for No Bus:ptybd
[   18.619234] PM: Adding info for No Bus:ptybe
[   18.619287] PM: Adding info for No Bus:ptybf
[   18.619334] PM: Adding info for No Bus:ptyc0
[   18.619385] PM: Adding info for No Bus:ptyc1
[   18.619432] PM: Adding info for No Bus:ptyc2
[   18.619482] PM: Adding info for No Bus:ptyc3
[   18.619530] PM: Adding info for No Bus:ptyc4
[   18.619617] PM: Adding info for No Bus:ptyc5
[   18.619727] PM: Adding info for No Bus:ptyc6
[   18.619775] PM: Adding info for No Bus:ptyc7
[   18.619827] PM: Adding info for No Bus:ptyc8
[   18.619875] PM: Adding info for No Bus:ptyc9
[   18.619922] PM: Adding info for No Bus:ptyca
[   18.619971] PM: Adding info for No Bus:ptycb
[   18.620030] PM: Adding info for No Bus:ptycc
[   18.620078] PM: Adding info for No Bus:ptycd
[   18.620126] PM: Adding info for No Bus:ptyce
[   18.620178] PM: Adding info for No Bus:ptycf
[   18.620227] PM: Adding info for No Bus:ptyd0
[   18.620276] PM: Adding info for No Bus:ptyd1
[   18.620325] PM: Adding info for No Bus:ptyd2
[   18.620378] PM: Adding info for No Bus:ptyd3
[   18.620429] PM: Adding info for No Bus:ptyd4
[   18.620478] PM: Adding info for No Bus:ptyd5
[   18.620531] PM: Adding info for No Bus:ptyd6
[   18.620582] PM: Adding info for No Bus:ptyd7
[   18.620631] PM: Adding info for No Bus:ptyd8
[   18.620680] PM: Adding info for No Bus:ptyd9
[   18.620733] PM: Adding info for No Bus:ptyda
[   18.620785] PM: Adding info for No Bus:ptydb
[   18.620834] PM: Adding info for No Bus:ptydc
[   18.620886] PM: Adding info for No Bus:ptydd
[   18.620936] PM: Adding info for No Bus:ptyde
[   18.620986] PM: Adding info for No Bus:ptydf
[   18.621037] PM: Adding info for No Bus:ptye0
[   18.621091] PM: Adding info for No Bus:ptye1
[   18.621143] PM: Adding info for No Bus:ptye2
[   18.621193] PM: Adding info for No Bus:ptye3
[   18.621249] PM: Adding info for No Bus:ptye4
[   18.621300] PM: Adding info for No Bus:ptye5
[   18.621351] PM: Adding info for No Bus:ptye6
[   18.621402] PM: Adding info for No Bus:ptye7
[   18.621457] PM: Adding info for No Bus:ptye8
[   18.621507] PM: Adding info for No Bus:ptye9
[   18.621560] PM: Adding info for No Bus:ptyea
[   18.621615] PM: Adding info for No Bus:ptyeb
[   18.621666] PM: Adding info for No Bus:ptyec
[   18.621717] PM: Adding info for No Bus:ptyed
[   18.621770] PM: Adding info for No Bus:ptyee
[   18.621826] PM: Adding info for No Bus:ptyef
[   18.621885] PM: Adding info for No Bus:ttyp0
[   18.621939] PM: Adding info for No Bus:ttyp1
[   18.621993] PM: Adding info for No Bus:ttyp2
[   18.622047] PM: Adding info for No Bus:ttyp3
[   18.622097] PM: Adding info for No Bus:ttyp4
[   18.622146] PM: Adding info for No Bus:ttyp5
[   18.622200] PM: Adding info for No Bus:ttyp6
[   18.622250] PM: Adding info for No Bus:ttyp7
[   18.622303] PM: Adding info for No Bus:ttyp8
[   18.622357] PM: Adding info for No Bus:ttyp9
[   18.622408] PM: Adding info for No Bus:ttypa
[   18.622459] PM: Adding info for No Bus:ttypb
[   18.622510] PM: Adding info for No Bus:ttypc
[   18.622565] PM: Adding info for No Bus:ttypd
[   18.622618] PM: Adding info for No Bus:ttype
[   18.622670] PM: Adding info for No Bus:ttypf
[   18.622725] PM: Adding info for No Bus:ttyq0
[   18.622777] PM: Adding info for No Bus:ttyq1
[   18.622828] PM: Adding info for No Bus:ttyq2
[   18.622880] PM: Adding info for No Bus:ttyq3
[   18.622936] PM: Adding info for No Bus:ttyq4
[   18.622987] PM: Adding info for No Bus:ttyq5
[   18.623038] PM: Adding info for No Bus:ttyq6
[   18.623095] PM: Adding info for No Bus:ttyq7
[   18.623145] PM: Adding info for No Bus:ttyq8
[   18.623197] PM: Adding info for No Bus:ttyq9
[   18.623247] PM: Adding info for No Bus:ttyqa
[   18.623304] PM: Adding info for No Bus:ttyqb
[   18.623357] PM: Adding info for No Bus:ttyqc
[   18.623409] PM: Adding info for No Bus:ttyqd
[   18.623467] PM: Adding info for No Bus:ttyqe
[   18.623520] PM: Adding info for No Bus:ttyqf
[   18.623579] PM: Adding info for No Bus:ttyr0
[   18.623631] PM: Adding info for No Bus:ttyr1
[   18.623688] PM: Adding info for No Bus:ttyr2
[   18.623741] PM: Adding info for No Bus:ttyr3
[   18.623794] PM: Adding info for No Bus:ttyr4
[   18.623850] PM: Adding info for No Bus:ttyr5
[   18.623908] PM: Adding info for No Bus:ttyr6
[   18.623962] PM: Adding info for No Bus:ttyr7
[   18.624015] PM: Adding info for No Bus:ttyr8
[   18.624071] PM: Adding info for No Bus:ttyr9
[   18.624124] PM: Adding info for No Bus:ttyra
[   18.624179] PM: Adding info for No Bus:ttyrb
[   18.624236] PM: Adding info for No Bus:ttyrc
[   18.624290] PM: Adding info for No Bus:ttyrd
[   18.624344] PM: Adding info for No Bus:ttyre
[   18.624400] PM: Adding info for No Bus:ttyrf
[   18.624456] PM: Adding info for No Bus:ttys0
[   18.624510] PM: Adding info for No Bus:ttys1
[   18.624563] PM: Adding info for No Bus:ttys2
[   18.624620] PM: Adding info for No Bus:ttys3
[   18.624676] PM: Adding info for No Bus:ttys4
[   18.624730] PM: Adding info for No Bus:ttys5
[   18.624785] PM: Adding info for No Bus:ttys6
[   18.624845] PM: Adding info for No Bus:ttys7
[   18.624901] PM: Adding info for No Bus:ttys8
[   18.624956] PM: Adding info for No Bus:ttys9
[   18.625015] PM: Adding info for No Bus:ttysa
[   18.625071] PM: Adding info for No Bus:ttysb
[   18.625131] PM: Adding info for No Bus:ttysc
[   18.625189] PM: Adding info for No Bus:ttysd
[   18.625247] PM: Adding info for No Bus:ttyse
[   18.625304] PM: Adding info for No Bus:ttysf
[   18.625359] PM: Adding info for No Bus:ttyt0
[   18.625418] PM: Adding info for No Bus:ttyt1
[   18.625473] PM: Adding info for No Bus:ttyt2
[   18.625530] PM: Adding info for No Bus:ttyt3
[   18.625588] PM: Adding info for No Bus:ttyt4
[   18.625646] PM: Adding info for No Bus:ttyt5
[   18.625701] PM: Adding info for No Bus:ttyt6
[   18.625757] PM: Adding info for No Bus:ttyt7
[   18.625817] PM: Adding info for No Bus:ttyt8
[   18.625874] PM: Adding info for No Bus:ttyt9
[   18.625931] PM: Adding info for No Bus:ttyta
[   18.625988] PM: Adding info for No Bus:ttytb
[   18.626052] PM: Adding info for No Bus:ttytc
[   18.626109] PM: Adding info for No Bus:ttytd
[   18.626164] PM: Adding info for No Bus:ttyte
[   18.626227] PM: Adding info for No Bus:ttytf
[   18.626284] PM: Adding info for No Bus:ttyu0
[   18.626339] PM: Adding info for No Bus:ttyu1
[   18.626396] PM: Adding info for No Bus:ttyu2
[   18.626457] PM: Adding info for No Bus:ttyu3
[   18.626518] PM: Adding info for No Bus:ttyu4
[   18.626574] PM: Adding info for No Bus:ttyu5
[   18.626633] PM: Adding info for No Bus:ttyu6
[   18.626691] PM: Adding info for No Bus:ttyu7
[   18.626750] PM: Adding info for No Bus:ttyu8
[   18.626809] PM: Adding info for No Bus:ttyu9
[   18.626870] PM: Adding info for No Bus:ttyua
[   18.626928] PM: Adding info for No Bus:ttyub
[   18.626986] PM: Adding info for No Bus:ttyuc
[   18.627047] PM: Adding info for No Bus:ttyud
[   18.627105] PM: Adding info for No Bus:ttyue
[   18.627163] PM: Adding info for No Bus:ttyuf
[   18.627223] PM: Adding info for No Bus:ttyv0
[   18.627283] PM: Adding info for No Bus:ttyv1
[   18.627342] PM: Adding info for No Bus:ttyv2
[   18.627400] PM: Adding info for No Bus:ttyv3
[   18.627462] PM: Adding info for No Bus:ttyv4
[   18.627521] PM: Adding info for No Bus:ttyv5
[   18.627584] PM: Adding info for No Bus:ttyv6
[   18.627652] PM: Adding info for No Bus:ttyv7
[   18.627715] PM: Adding info for No Bus:ttyv8
[   18.627773] PM: Adding info for No Bus:ttyv9
[   18.627830] PM: Adding info for No Bus:ttyva
[   18.627892] PM: Adding info for No Bus:ttyvb
[   18.627954] PM: Adding info for No Bus:ttyvc
[   18.628012] PM: Adding info for No Bus:ttyvd
[   18.628070] PM: Adding info for No Bus:ttyve
[   18.628134] PM: Adding info for No Bus:ttyvf
[   18.628197] PM: Adding info for No Bus:ttyw0
[   18.628256] PM: Adding info for No Bus:ttyw1
[   18.628321] PM: Adding info for No Bus:ttyw2
[   18.628381] PM: Adding info for No Bus:ttyw3
[   18.628441] PM: Adding info for No Bus:ttyw4
[   18.628501] PM: Adding info for No Bus:ttyw5
[   18.628566] PM: Adding info for No Bus:ttyw6
[   18.628625] PM: Adding info for No Bus:ttyw7
[   18.628687] PM: Adding info for No Bus:ttyw8
[   18.628750] PM: Adding info for No Bus:ttyw9
[   18.628811] PM: Adding info for No Bus:ttywa
[   18.628872] PM: Adding info for No Bus:ttywb
[   18.628932] PM: Adding info for No Bus:ttywc
[   18.628996] PM: Adding info for No Bus:ttywd
[   18.629057] PM: Adding info for No Bus:ttywe
[   18.629118] PM: Adding info for No Bus:ttywf
[   18.629181] PM: Adding info for No Bus:ttyx0
[   18.629241] PM: Adding info for No Bus:ttyx1
[   18.629300] PM: Adding info for No Bus:ttyx2
[   18.629362] PM: Adding info for No Bus:ttyx3
[   18.629426] PM: Adding info for No Bus:ttyx4
[   18.629488] PM: Adding info for No Bus:ttyx5
[   18.629550] PM: Adding info for No Bus:ttyx6
[   18.629613] PM: Adding info for No Bus:ttyx7
[   18.629676] PM: Adding info for No Bus:ttyx8
[   18.629736] PM: Adding info for No Bus:ttyx9
[   18.629796] PM: Adding info for No Bus:ttyxa
[   18.629861] PM: Adding info for No Bus:ttyxb
[   18.629925] PM: Adding info for No Bus:ttyxc
[   18.629986] PM: Adding info for No Bus:ttyxd
[   18.630052] PM: Adding info for No Bus:ttyxe
[   18.630114] PM: Adding info for No Bus:ttyxf
[   18.630176] PM: Adding info for No Bus:ttyy0
[   18.630237] PM: Adding info for No Bus:ttyy1
[   18.630301] PM: Adding info for No Bus:ttyy2
[   18.630363] PM: Adding info for No Bus:ttyy3
[   18.630427] PM: Adding info for No Bus:ttyy4
[   18.630491] PM: Adding info for No Bus:ttyy5
[   18.630553] PM: Adding info for No Bus:ttyy6
[   18.630615] PM: Adding info for No Bus:ttyy7
[   18.630677] PM: Adding info for No Bus:ttyy8
[   18.630746] PM: Adding info for No Bus:ttyy9
[   18.630807] PM: Adding info for No Bus:ttyya
[   18.630873] PM: Adding info for No Bus:ttyyb
[   18.630940] PM: Adding info for No Bus:ttyyc
[   18.631002] PM: Adding info for No Bus:ttyyd
[   18.631063] PM: Adding info for No Bus:ttyye
[   18.631125] PM: Adding info for No Bus:ttyyf
[   18.631193] PM: Adding info for No Bus:ttyz0
[   18.631254] PM: Adding info for No Bus:ttyz1
[   18.631319] PM: Adding info for No Bus:ttyz2
[   18.631387] PM: Adding info for No Bus:ttyz3
[   18.631450] PM: Adding info for No Bus:ttyz4
[   18.631512] PM: Adding info for No Bus:ttyz5
[   18.631581] PM: Adding info for No Bus:ttyz6
[   18.631842] PM: Adding info for No Bus:ttyz7
[   18.631904] PM: Adding info for No Bus:ttyz8
[   18.631966] PM: Adding info for No Bus:ttyz9
[   18.632036] PM: Adding info for No Bus:ttyza
[   18.632099] PM: Adding info for No Bus:ttyzb
[   18.632161] PM: Adding info for No Bus:ttyzc
[   18.632224] PM: Adding info for No Bus:ttyzd
[   18.632290] PM: Adding info for No Bus:ttyze
[   18.632353] PM: Adding info for No Bus:ttyzf
[   18.632416] PM: Adding info for No Bus:ttya0
[   18.632483] PM: Adding info for No Bus:ttya1
[   18.632545] PM: Adding info for No Bus:ttya2
[   18.632608] PM: Adding info for No Bus:ttya3
[   18.632672] PM: Adding info for No Bus:ttya4
[   18.632739] PM: Adding info for No Bus:ttya5
[   18.632801] PM: Adding info for No Bus:ttya6
[   18.632864] PM: Adding info for No Bus:ttya7
[   18.632932] PM: Adding info for No Bus:ttya8
[   18.632995] PM: Adding info for No Bus:ttya9
[   18.633058] PM: Adding info for No Bus:ttyaa
[   18.633122] PM: Adding info for No Bus:ttyab
[   18.633188] PM: Adding info for No Bus:ttyac
[   18.633251] PM: Adding info for No Bus:ttyad
[   18.633314] PM: Adding info for No Bus:ttyae
[   18.633382] PM: Adding info for No Bus:ttyaf
[   18.633447] PM: Adding info for No Bus:ttyb0
[   18.633510] PM: Adding info for No Bus:ttyb1
[   18.633574] PM: Adding info for No Bus:ttyb2
[   18.633645] PM: Adding info for No Bus:ttyb3
[   18.633711] PM: Adding info for No Bus:ttyb4
[   18.633776] PM: Adding info for No Bus:ttyb5
[   18.633844] PM: Adding info for No Bus:ttyb6
[   18.633910] PM: Adding info for No Bus:ttyb7
[   18.633975] PM: Adding info for No Bus:ttyb8
[   18.634038] PM: Adding info for No Bus:ttyb9
[   18.634106] PM: Adding info for No Bus:ttyba
[   18.634174] PM: Adding info for No Bus:ttybb
[   18.634238] PM: Adding info for No Bus:ttybc
[   18.634306] PM: Adding info for No Bus:ttybd
[   18.634373] PM: Adding info for No Bus:ttybe
[   18.634439] PM: Adding info for No Bus:ttybf
[   18.634505] PM: Adding info for No Bus:ttyc0
[   18.634573] PM: Adding info for No Bus:ttyc1
[   18.634638] PM: Adding info for No Bus:ttyc2
[   18.634704] PM: Adding info for No Bus:ttyc3
[   18.634773] PM: Adding info for No Bus:ttyc4
[   18.634839] PM: Adding info for No Bus:ttyc5
[   18.634907] PM: Adding info for No Bus:ttyc6
[   18.634974] PM: Adding info for No Bus:ttyc7
[   18.635044] PM: Adding info for No Bus:ttyc8
[   18.635111] PM: Adding info for No Bus:ttyc9
[   18.635177] PM: Adding info for No Bus:ttyca
[   18.635248] PM: Adding info for No Bus:ttycb
[   18.635316] PM: Adding info for No Bus:ttycc
[   18.635383] PM: Adding info for No Bus:ttycd
[   18.635449] PM: Adding info for No Bus:ttyce
[   18.635519] PM: Adding info for No Bus:ttycf
[   18.635594] PM: Adding info for No Bus:ttyd0
[   18.635661] PM: Adding info for No Bus:ttyd1
[   18.635732] PM: Adding info for No Bus:ttyd2
[   18.635801] PM: Adding info for No Bus:ttyd3
[   18.635869] PM: Adding info for No Bus:ttyd4
[   18.635937] PM: Adding info for No Bus:ttyd5
[   18.636007] PM: Adding info for No Bus:ttyd6
[   18.636076] PM: Adding info for No Bus:ttyd7
[   18.636143] PM: Adding info for No Bus:ttyd8
[   18.636214] PM: Adding info for No Bus:ttyd9
[   18.636281] PM: Adding info for No Bus:ttyda
[   18.636349] PM: Adding info for No Bus:ttydb
[   18.636418] PM: Adding info for No Bus:ttydc
[   18.636493] PM: Adding info for No Bus:ttydd
[   18.636560] PM: Adding info for No Bus:ttyde
[   18.636634] PM: Adding info for No Bus:ttydf
[   18.636705] PM: Adding info for No Bus:ttye0
[   18.636773] PM: Adding info for No Bus:ttye1
[   18.636840] PM: Adding info for No Bus:ttye2
[   18.636911] PM: Adding info for No Bus:ttye3
[   18.636982] PM: Adding info for No Bus:ttye4
[   18.637051] PM: Adding info for No Bus:ttye5
[   18.637119] PM: Adding info for No Bus:ttye6
[   18.637192] PM: Adding info for No Bus:ttye7
[   18.637263] PM: Adding info for No Bus:ttye8
[   18.637332] PM: Adding info for No Bus:ttye9
[   18.637403] PM: Adding info for No Bus:ttyea
[   18.637478] PM: Adding info for No Bus:ttyeb
[   18.637548] PM: Adding info for No Bus:ttyec
[   18.637617] PM: Adding info for No Bus:ttyed
[   18.637689] PM: Adding info for No Bus:ttyee
[   18.637759] PM: Adding info for No Bus:ttyef
[   18.637813] PM: Adding info for No Bus:rtc
[   18.637860] Real Time Clock Driver v1.12ac
[   18.637943] Linux agpgart interface v0.102 (c) Dave Jones
[   18.638592] RAMDISK driver initialized: 16 RAM disks of 65536K size 1024 blocksize
[   18.638691] PM: Adding info for No Bus:lo
[   18.638738] Uniform Multi-Platform E-IDE driver Revision: 7.00alpha2
[   18.638792] ide: Assuming 33MHz system bus speed for PIO modes; override with idebus=xx
[   18.638893] NFORCE-MCP51: IDE controller at PCI slot 0000:00:0d.0
[   18.638961] NFORCE-MCP51: chipset revision 241
[   18.639011] NFORCE-MCP51: not 100% native mode: will probe irqs later
[   18.639067] NFORCE-MCP51: 0000:00:0d.0 (rev f1) UDMA133 controller
[   18.639124]     ide0: BM-DMA at 0x3080-0x3087, BIOS settings: hda:pio, hdb:pio
[   18.639264]     ide1: BM-DMA at 0x3088-0x308f, BIOS settings: hdc:pio, hdd:pio
[   18.639402] Probing IDE interface ide0...
[   19.207492] Probing IDE interface ide1...
[   19.943596] hdc: HL-DT-ST DVDRAM GMA-4082N, ATAPI CD/DVD-ROM drive
[   19.943765] PM: Adding info for No Bus:ide1
[   20.280676] ide1 at 0x170-0x177,0x376 on irq 15
[   20.283850] PM: Adding info for ide:1.0
[   20.283957] Probing IDE interface ide0...
[   20.853401] hdc: ATAPI 24X DVD-ROM DVD-R-RAM CD-R/RW drive, 2048kB Cache, DMA
[   20.853743] Uniform CD-ROM driver Revision: 3.20
[   20.861142] sata_nv 0000:00:0e.0: version 3.4
[   20.861152] PCI: Enabling device 0000:00:0e.0 (0005 -> 0007)
[   20.861579] ACPI: PCI Interrupt Link [LTID] enabled at IRQ 23
[   20.861639] ACPI: PCI Interrupt 0000:00:0e.0[A] -> Link [LTID] -> GSI 23 (level, high) -> IRQ 23
[   20.862010] PCI: Setting latency timer of device 0000:00:0e.0 to 64
[   20.862105] scsi0 : sata_nv
[   20.862176] PM: Adding info for No Bus:host0
[   20.862271] scsi1 : sata_nv
[   20.862323] PM: Adding info for No Bus:host1
[   20.862363] ata1: SATA max UDMA/133 cmd 0x00000000000130b0 ctl 0x00000000000130a6 bmdma 0x0000000000013090 irq 23
[   20.862431] ata2: SATA max UDMA/133 cmd 0x00000000000130a8 ctl 0x00000000000130a2 bmdma 0x0000000000013098 irq 23
[   21.337039] ata1: SATA link up 1.5 Gbps (SStatus 113 SControl 300)
[   21.347529] ata1.00: ATA-7: SAMSUNG HM160JI, AD100-16, max UDMA/100
[   21.347584] ata1.00: 312581808 sectors, multi 16: LBA48 NCQ (depth 0/32)
[   21.363521] ata1.00: configured for UDMA/100
[   21.680981] ata2: SATA link down (SStatus 0 SControl 300)
[   21.693844] PM: Adding info for No Bus:target0:0:0
[   21.693915] scsi 0:0:0:0: Direct-Access     ATA      SAMSUNG HM160JI  AD10 PQ: 0 ANSI: 5
[   21.693987] PM: Adding info for scsi:0:0:0:0
[   21.694084] sd 0:0:0:0: [sda] 312581808 512-byte hardware sectors (160042 MB)
[   21.694147] sd 0:0:0:0: [sda] Write Protect is off
[   21.694199] sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
[   21.694214] sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
[   21.694320] sd 0:0:0:0: [sda] 312581808 512-byte hardware sectors (160042 MB)
[   21.694381] sd 0:0:0:0: [sda] Write Protect is off
[   21.694433] sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
[   21.694447] sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
[   21.694515]  sda: sda1 sda2 sda3 sda4
[   21.745613] sd 0:0:0:0: [sda] Attached SCSI disk
[   21.745735] sd 0:0:0:0: Attached scsi generic sg0 type 0
[   21.745896] PNP: PS/2 Controller [PNP0303:KBD0,PNP0f13:PS2M] at 0x60,0x64 irq 1,12
[   21.745997] PM: Adding info for platform:i8042
[   21.746260] i8042.c: Detected active multiplexing controller, rev 1.1.
[   21.746383] serio: i8042 KBD port at 0x60,0x64 irq 1
[   21.746437] serio: i8042 AUX0 port at 0x60,0x64 irq 12
[   21.744279] PM: Adding info for serio:serio0
[   21.746491] serio: i8042 AUX1 port at 0x60,0x64 irq 12
[   21.744341] PM: Adding info for serio:serio1
[   21.746545] serio: i8042 AUX2 port at 0x60,0x64 irq 12
[   21.744378] PM: Adding info for serio:serio2
[   21.746599] serio: i8042 AUX3 port at 0x60,0x64 irq 12
[   21.744429] PM: Adding info for serio:serio3
[   21.744484] PM: Adding info for serio:serio4
[   21.746700] PM: Adding info for No Bus:psaux
[   21.746731] mice: PS/2 mouse device common for all mice
[   21.746878] Advanced Linux Sound Architecture Driver Version 1.0.14 (Thu May 31 09:03:25 2007 UTC).
[   21.746949] PM: Adding info for No Bus:timer
[   21.747486] ACPI: PCI Interrupt Link [LAZA] enabled at IRQ 22
[   21.747546] ACPI: PCI Interrupt 0000:00:10.1[B] -> Link [LAZA] -> GSI 22 (level, high) -> IRQ 22
[   21.747881] PCI: Setting latency timer of device 0000:00:10.1 to 64
[   21.747255] input: AT Translated Set 2 keyboard as /class/input/input0
[   21.923142] PM: Adding info for No Bus:pcmC0D1p
[   21.923199] PM: Adding info for No Bus:pcmC0D0p
[   21.923238] PM: Adding info for No Bus:pcmC0D0c
[   21.923281] PM: Adding info for No Bus:controlC0
[   21.923333] ALSA device list:
[   21.923386]   #0: HDA NVidia at 0xb0000000 irq 22
[   21.923505] TCP cubic registered
[   21.923561] NET: Registered protocol family 1
[   21.923661] powernow-k8: Found 2 AMD Turion(tm) 64 X2  processors (version 2.00.00)
[   21.921585] powernow-k8:    0 : fid 0x8 (1600 MHz), vid 0x12
[   21.921639] powernow-k8:    1 : fid 0x0 (800 MHz), vid 0x1e
[   21.921911] drivers/rtc/hctosys.c: unable to open rtc device (rtc0)
[   21.921970] Freeing unused kernel memory: 316k freed
[   21.922473] PM: Adding info for No Bus:vcs1
[   21.922551] PM: Adding info for No Bus:vcsa1
[   21.998355] PM: Adding info for No Bus:vcs2
[   21.998412] PM: Adding info for No Bus:vcsa2
[   21.998816] PM: Removing info for No Bus:vcs2
[   21.998857] PM: Removing info for No Bus:vcsa2
[   22.002713] PM: Adding info for No Bus:vcs2
[   22.002778] PM: Adding info for No Bus:vcsa2
[   22.006092] PM: Removing info for No Bus:vcs2
[   22.006149] PM: Removing info for No Bus:vcsa2
[   22.005014] PM: Adding info for No Bus:vcs2
[   22.005067] PM: Adding info for No Bus:vcsa2
[   22.006064] PM: Removing info for No Bus:vcs2
[   22.006102] PM: Removing info for No Bus:vcsa2
[   22.006894] PM: Adding info for No Bus:vcs3
[   22.006934] PM: Adding info for No Bus:vcsa3
[   22.007316] PM: Removing info for No Bus:vcs3
[   22.007351] PM: Removing info for No Bus:vcsa3
[   22.011273] PM: Adding info for No Bus:vcs3
[   22.011329] PM: Adding info for No Bus:vcsa3
[   22.014577] PM: Removing info for No Bus:vcs3
[   22.014631] PM: Removing info for No Bus:vcsa3
[   22.015806] PM: Adding info for No Bus:vcs3
[   22.015852] PM: Adding info for No Bus:vcsa3
[   22.016803] PM: Removing info for No Bus:vcs3
[   22.016858] PM: Removing info for No Bus:vcsa3
[   22.017613] PM: Adding info for No Bus:vcs4
[   22.017656] PM: Adding info for No Bus:vcsa4
[   22.018010] PM: Removing info for No Bus:vcs4
[   22.018049] PM: Removing info for No Bus:vcsa4
[   22.019644] PM: Adding info for No Bus:vcs4
[   22.019697] PM: Adding info for No Bus:vcsa4
[   22.022946] PM: Removing info for No Bus:vcs4
[   22.022999] PM: Removing info for No Bus:vcsa4
[   22.021883] PM: Adding info for No Bus:vcs4
[   22.021931] PM: Adding info for No Bus:vcsa4
[   22.022890] PM: Removing info for No Bus:vcs4
[   22.022957] PM: Removing info for No Bus:vcsa4
[   22.023708] PM: Adding info for No Bus:vcs5
[   22.023754] PM: Adding info for No Bus:vcsa5
[   22.024112] PM: Removing info for No Bus:vcs5
[   22.024152] PM: Removing info for No Bus:vcsa5
[   22.027987] PM: Adding info for No Bus:vcs5
[   22.028043] PM: Adding info for No Bus:vcsa5
[   22.031325] PM: Removing info for No Bus:vcs5
[   22.031378] PM: Removing info for No Bus:vcsa5
[   22.030220] PM: Adding info for No Bus:vcs5
[   22.030268] PM: Adding info for No Bus:vcsa5
[   22.031207] PM: Removing info for No Bus:vcs5
[   22.031273] PM: Removing info for No Bus:vcsa5
[   22.032000] PM: Adding info for No Bus:vcs6
[   22.032044] PM: Adding info for No Bus:vcsa6
[   22.032399] PM: Removing info for No Bus:vcs6
[   22.032439] PM: Removing info for No Bus:vcsa6
[   22.036305] PM: Adding info for No Bus:vcs6
[   22.036362] PM: Adding info for No Bus:vcsa6
[   22.039619] PM: Removing info for No Bus:vcs6
[   22.039673] PM: Removing info for No Bus:vcsa6
[   22.038504] PM: Adding info for No Bus:vcs6
[   22.038548] PM: Adding info for No Bus:vcsa6
[   22.039492] PM: Removing info for No Bus:vcs6
[   22.039558] PM: Removing info for No Bus:vcsa6
[   22.478565] kjournald starting.  Commit interval 5 seconds
[   22.480753] EXT3-fs: mounted filesystem with ordered data mode.
[   22.822678] PM: Removing info for No Bus:vcs1
[   22.822709] PM: Removing info for No Bus:vcsa1
[   22.822755] PM: Adding info for No Bus:vcs1
[   22.822769] PM: Adding info for No Bus:vcsa1
[   30.595743] PM: Adding info for No Bus:vcs2
[   30.595773] PM: Adding info for No Bus:vcsa2
[   30.596873] PM: Removing info for No Bus:vcs2
[   30.596902] PM: Removing info for No Bus:vcsa2
[   30.597031] PM: Adding info for No Bus:vcs3
[   30.597047] PM: Adding info for No Bus:vcsa3
[   30.598151] PM: Removing info for No Bus:vcs3
[   30.598181] PM: Removing info for No Bus:vcsa3
[   30.598310] PM: Adding info for No Bus:vcs4
[   30.598329] PM: Adding info for No Bus:vcsa4
[   30.599377] PM: Removing info for No Bus:vcs4
[   30.599393] PM: Removing info for No Bus:vcsa4
[   30.599482] PM: Adding info for No Bus:vcs5
[   30.599497] PM: Adding info for No Bus:vcsa5
[   30.600538] PM: Removing info for No Bus:vcs5
[   30.600554] PM: Removing info for No Bus:vcsa5
[   30.600644] PM: Adding info for No Bus:vcs6
[   30.600659] PM: Adding info for No Bus:vcsa6
[   30.601702] PM: Removing info for No Bus:vcs6
[   30.601718] PM: Removing info for No Bus:vcsa6
[   33.000410] PM: Adding info for No Bus:i2c-0
[   33.000432] i2c-adapter i2c-0: nForce2 SMBus adapter at 0x3040
[   33.000495] PM: Adding info for No Bus:i2c-1
[   33.000509] i2c-adapter i2c-1: nForce2 SMBus adapter at 0x3000
[   33.024692] ACPI: PCI Interrupt Link [LNK1] enabled at IRQ 18
[   33.024758] ACPI: PCI Interrupt 0000:05:09.0[A] -> Link [LNK1] -> GSI 18 (level, high) -> IRQ 18
[   33.024922] PM: Adding info for ieee1394:fw-host0
[   33.077637] ohci1394: fw-host0: OHCI-1394 1.1 (PCI): IRQ=[18]  MMIO=[b8000000-b80007ff]  Max Packet=[2048]  IR/IT contexts=[4/4]
[   33.110231] forcedeth.c: Reverse Engineered nForce ethernet driver. Version 0.60.
[   33.110751] ACPI: PCI Interrupt Link [LMAC] enabled at IRQ 17
[   33.110813] ACPI: PCI Interrupt 0000:00:14.0[A] -> Link [LMAC] -> GSI 17 (level, high) -> IRQ 17
[   33.110953] PCI: Setting latency timer of device 0000:00:14.0 to 64
[   33.110963] forcedeth: using HIGHDMA
[   33.122247] usbcore: registered new interface driver usbfs
[   33.122323] usbcore: registered new interface driver hub
[   33.122404] usbcore: registered new device driver usb
[   33.135236] sdhci: Secure Digital Host Controller Interface driver
[   33.135293] sdhci: Copyright(c) Pierre Ossman
[   33.144751] pci_hotplug: PCI Hot Plug PCI Core version: 0.5
[   33.189355] ohci_hcd: 2006 August 04 USB 1.1 'Open' Host Controller (OHCI) Driver
[   33.624804] Synaptics Touchpad, model: 1, fw: 6.2, id: 0x1a0b1, caps: 0xa04713/0x200000
[   33.629785] PM: Adding info for No Bus:eth0
[   33.629865] eth0: forcedeth.c: subsystem: 0103c:30b5 bound to 0000:00:14.0
[   33.630332] sdhci: SDHCI controller found at 0000:05:09.1 [1180:0822] (rev 19)
[   33.630807] ACPI: PCI Interrupt Link [LNK2] enabled at IRQ 16
[   33.630867] ACPI: PCI Interrupt 0000:05:09.1[B] -> Link [LNK2] -> GSI 16 (level, high) -> IRQ 16
[   33.631254] PM: Adding info for No Bus:mmc0
[   33.631318] mmc0: SDHCI at 0xb8000800 irq 16 DMA
[   33.633424] shpchp: Standard Hot Plug PCI Controller Driver version: 0.4
[   33.633961] ACPI: PCI Interrupt Link [LUS0] enabled at IRQ 23
[   33.634016] ACPI: PCI Interrupt 0000:00:0b.0[A] -> Link [LUS0] -> GSI 23 (level, high) -> IRQ 23
[   33.634289] PCI: Setting latency timer of device 0000:00:0b.0 to 64
[   33.634296] ohci_hcd 0000:00:0b.0: OHCI Host Controller
[   33.634789] ohci_hcd 0000:00:0b.0: new USB bus registered, assigned bus number 1
[   33.634868] ohci_hcd 0000:00:0b.0: irq 23, io mem 0xb0004000
[   33.643081] eth0: no link during initialization.
[   33.654848] input: SynPS/2 Synaptics TouchPad as /class/input/input1
[   33.695427] PM: Adding info for usb:usb1
[   33.695542] PM: Adding info for No Bus:usbdev1.1_ep00
[   33.695577] usb usb1: configuration #1 chosen from 1 choice
[   33.695641] PM: Adding info for usb:1-0:1.0
[   33.695674] hub 1-0:1.0: USB hub found
[   33.695734] hub 1-0:1.0: 8 ports detected
[   33.797545] PM: Adding info for No Bus:usbdev1.1_ep81
[   33.798221] ACPI: PCI Interrupt Link [LUS2] enabled at IRQ 22
[   33.798277] ACPI: PCI Interrupt 0000:00:0b.1[B] -> Link [LUS2] -> GSI 22 (level, high) -> IRQ 22
[   33.798631] PCI: Setting latency timer of device 0000:00:0b.1 to 64
[   33.798638] ehci_hcd 0000:00:0b.1: EHCI Host Controller
[   33.798790] ehci_hcd 0000:00:0b.1: new USB bus registered, assigned bus number 2
[   33.798885] ehci_hcd 0000:00:0b.1: debug port 1
[   33.798938] PCI: cache line size of 64 is not supported by device 0000:00:0b.1
[   33.798946] ehci_hcd 0000:00:0b.1: irq 22, io mem 0xb0005000
[   33.799003] ehci_hcd 0000:00:0b.1: USB 2.0 started, EHCI 1.00, driver 10 Dec 2004
[   33.799092] PM: Adding info for usb:usb2
[   33.799160] PM: Adding info for No Bus:usbdev2.1_ep00
[   33.799194] usb usb2: configuration #1 chosen from 1 choice
[   33.799255] PM: Adding info for usb:2-0:1.0
[   33.799287] hub 2-0:1.0: USB hub found
[   33.799343] hub 2-0:1.0: 8 ports detected
[   33.901524] PM: Adding info for No Bus:usbdev2.1_ep81
[   33.906674] ACPI: PCI Interrupt Link [LK2E] enabled at IRQ 19
[   33.906739] ACPI: PCI Interrupt 0000:01:00.0[A] -> Link [LK2E] -> GSI 19 (level, high) -> IRQ 19
[   33.906881] PCI: Setting latency timer of device 0000:01:00.0 to 64
[   33.929517] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x11, vendor 0x4243)
[   33.929584] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0A, vendor 0x4243)
[   33.929654] ssb: Core 2 found: USB 1.1 Host (cc 0x817, rev 0x03, vendor 0x4243)
[   33.929724] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x01, vendor 0x4243)
[   33.929784] ssb: Switching to ChipCommon core, index 0
[   33.931611] ssb: Switching to PCI-E core, index 3
[   33.934262] PM: Adding info for ssb:ssb0:0
[   33.934336] PM: Adding info for ssb:ssb0:1
[   33.934361] ssb: Sonics Silicon Backplane found on PCI device 0000:01:00.0
[   33.934463] bcm4301-phy0: Broadcom 4311 WLAN found
[   33.934551] ssb: Switching to IEEE 802.11 core, index 1
[   33.961312] bcm4301-phy0 debug: Found PHY: Analog 4, Type 2, Revision 8
[   33.961333] bcm4301-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
[   33.981494] bcm4301-phy0 debug: Radio turned off
[   33.981538] PM: Adding info for No Bus:phy0
[   33.981791] PM: Adding info for No Bus:wmaster0
[   33.981829] wmaster0: Selected rate control algorithm 'simple'
[   33.994750] PM: Adding info for No Bus:wlan0
[   34.009115] bcm4301-phy0 debug: Adding Interface type 2
[   34.059325] ssb: Switching to PCI-E core, index 3
[   34.059386] ssb: Switching to IEEE 802.11 core, index 1
[   34.059460] PM: Adding info for No Bus:ssb0:0
[   34.095385] PM: Removing info for No Bus:ssb0:0
[   34.095836] bcm4301: Microcode bcm43xx_microcode5.fw3.fw loaded
[   34.095921] PM: Adding info for No Bus:ssb0:0
[   34.100089] PM: Removing info for No Bus:ssb0:0
[   34.100524] PM: Adding info for No Bus:ssb0:0
[   34.108623] PM: Removing info for No Bus:ssb0:0
[   34.109032] PM: Adding info for No Bus:ssb0:0
[   34.117044] PM: Removing info for No Bus:ssb0:0
[   34.176961] bcm4301-phy0 debug: Loading firmware version 0x127, patch level 14 (2005-04-18 02:36:27)
[   34.176972] ssb: Switching to ChipCommon core, index 0
[   34.177040] ssb: Switching to IEEE 802.11 core, index 1
[   34.199107] bcm4301-phy0 debug: Radio turned on
[   34.199118] bcm4301-phy0 debug: Radio enabled by hardware
[   34.213278] usb 2-8: new high speed USB device using ehci_hcd and address 2
[   34.256353] EXT3 FS on sda3, internal journal
[   34.361441] PM: Adding info for ieee1394:06e40a00870f5042
[   34.361489] ieee1394: Host added: ID:BUS[0-00:1023]  GUID[06e40a00870f5042]
[   34.360441] PM: Adding info for usb:2-8
[   34.360514] PM: Adding info for No Bus:usbdev2.2_ep00
[   34.360536] usb 2-8: configuration #1 chosen from 1 choice
[   34.360801] PM: Adding info for usb:2-8:1.0
[   34.361418] PM: Adding info for No Bus:usbdev2.2_ep83
[   34.361440] PM: Adding info for usb:2-8:1.1
[   34.443763] bcm4301-phy0 debug: Chip initialized
[   34.443995] bcm4301-phy0 debug: 32-bit DMA initialized
[   34.464934] kjournald starting.  Commit interval 5 seconds
[   34.464943] EXT3-fs warning: maximal mount count reached, running e2fsck is recommended
[   34.465326] EXT3 FS on sda4, internal journal
[   34.465331] EXT3-fs: mounted filesystem with ordered data mode.
[   34.471428] PM: Adding info for No Bus:hw_random
[   34.471478] bcm4301-phy0 debug: Wireless interface started
[   34.472729] HW CONFIG: channel=1 freq=2412 phymode=3
[   34.799484] PM: Adding info for No Bus:vcs2
[   34.801477] PM: Adding info for No Bus:vcsa2
[   34.804305] PM: Removing info for No Bus:vcs2
[   34.803041] PM: Removing info for No Bus:vcsa2
[   34.804318] PM: Adding info for No Bus:vcs2
[   34.804351] PM: Adding info for No Bus:vcsa2
[   34.808494] PM: Removing info for No Bus:vcs2
[   34.808530] PM: Removing info for No Bus:vcsa2
[   34.808797] PM: Adding info for No Bus:vcs3
[   34.808813] PM: Adding info for No Bus:vcsa3
[   34.809723] PM: Removing info for No Bus:vcs3
[   34.809754] PM: Removing info for No Bus:vcsa3
[   34.819406] PM: Adding info for No Bus:vcs3
[   34.819438] PM: Adding info for No Bus:vcsa3
[   34.823610] PM: Removing info for No Bus:vcs3
[   34.823643] PM: Removing info for No Bus:vcsa3
[   34.823903] PM: Adding info for No Bus:vcs4
[   34.823919] PM: Adding info for No Bus:vcsa4
[   34.824839] PM: Removing info for No Bus:vcs4
[   34.824869] PM: Removing info for No Bus:vcsa4
[   34.826283] PM: Adding info for No Bus:vcs4
[   34.826309] PM: Adding info for No Bus:vcsa4
[   34.830476] PM: Removing info for No Bus:vcs4
[   34.830507] PM: Removing info for No Bus:vcsa4
[   34.830771] PM: Adding info for No Bus:vcs5
[   34.830788] PM: Adding info for No Bus:vcsa5
[   34.838306] PM: Removing info for No Bus:vcs5
[   34.838343] PM: Removing info for No Bus:vcsa5
[   34.839650] PM: Adding info for No Bus:vcs5
[   34.839682] PM: Adding info for No Bus:vcsa5
[   34.843860] PM: Removing info for No Bus:vcs5
[   34.844139] PM: Removing info for No Bus:vcsa5
[   34.844529] PM: Adding info for No Bus:vcs6
[   34.848134] PM: Adding info for No Bus:vcsa6
[   34.849054] PM: Removing info for No Bus:vcs6
[   34.849082] PM: Removing info for No Bus:vcsa6
[   34.848272] PM: Adding info for No Bus:vcs6
[   34.848299] PM: Adding info for No Bus:vcsa6
[   34.857303] PM: Removing info for No Bus:vcs6
[   34.857338] PM: Removing info for No Bus:vcsa6
[   34.861905] PM: Adding info for No Bus:vcs2
[   34.861934] PM: Adding info for No Bus:vcsa2
[   34.863170] PM: Removing info for No Bus:vcs2
[   34.863208] PM: Removing info for No Bus:vcsa2
[   34.863359] PM: Adding info for No Bus:vcs3
[   34.863374] PM: Adding info for No Bus:vcsa3
[   34.864553] PM: Removing info for No Bus:vcs3
[   34.864589] PM: Removing info for No Bus:vcsa3
[   34.864732] PM: Adding info for No Bus:vcs4
[   34.864747] PM: Adding info for No Bus:vcsa4
[   34.865978] PM: Removing info for No Bus:vcs4
[   34.866009] PM: Removing info for No Bus:vcsa4
[   34.866152] PM: Adding info for No Bus:vcs5
[   34.866170] PM: Adding info for No Bus:vcsa5
[   34.867372] PM: Removing info for No Bus:vcs5
[   34.867404] PM: Removing info for No Bus:vcsa5
[   34.868511] PM: Adding info for No Bus:vcs6
[   34.868539] PM: Adding info for No Bus:vcsa6
[   34.869768] PM: Removing info for No Bus:vcs6
[   34.869802] PM: Removing info for No Bus:vcsa6
[   35.753007] NET: Registered protocol family 17
[   52.718652] atkbd.c: Unknown key pressed (translated set 2, code 0xd9 on isa0060/serio0).
[   52.718657] atkbd.c: Use 'setkeycodes e059 <keycode>' to make it known.
[   52.719331] atkbd.c: Unknown key released (translated set 2, code 0xd9 on isa0060/serio0).
[   52.719334] atkbd.c: Use 'setkeycodes e059 <keycode>' to make it known.
[   54.318086] NET: Registered protocol family 10
[   54.318177] lo: Disabled Privacy Extensions
[   54.318355] ADDRCONF(NETDEV_UP): eth0: link is not ready
[   54.318390] ADDRCONF(NETDEV_UP): eth1: link is not ready

From josejx at gentoo.org  Mon Jul 30 01:08:56 2007
From: josejx at gentoo.org (Joseph Jezak)
Date: Sun, 29 Jul 2007 19:08:56 -0400
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <46ACEBCB.6070003@yahoo.com>
References: <46ACC7C4.5060808@richardharman.com>
	<46ACD1FE.3030208@gentoo.org>	<46ACDB28.4030009@yahoo.com>
	<46ACDFBB.80301@gentoo.org> <46ACEBCB.6070003@yahoo.com>
Message-ID: <46AD1E08.4020202@gentoo.org>

Mansour wrote:
> Great, and regarding the acpi, I have to boot with pci=noacpi. Am I wrong ?

I can't really say anything about this, it's not really related to 
bcm43xx though.  You might have more luck asking the support 
forums/mailing lists for your distro.

-Joe


From mansour77 at yahoo.com  Mon Jul 30 01:15:53 2007
From: mansour77 at yahoo.com (Mansour)
Date: Sun, 29 Jul 2007 20:15:53 -0300
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <aa73b9a0707291437k33d4b6ebj41fcb49cb60121da@mail.gmail.com>
References: <46ACC7C4.5060808@richardharman.com>
	<46ACD1FE.3030208@gentoo.org>	<46ACDB28.4030009@yahoo.com>
	<46ACDFBB.80301@gentoo.org>	<46ACEBCB.6070003@yahoo.com>
	<aa73b9a0707291437k33d4b6ebj41fcb49cb60121da@mail.gmail.com>
Message-ID: <46AD1FA9.1010803@yahoo.com>

John Pierce wrote:
> On 7/29/07, Mansour <mansour77 at yahoo.com> wrote:
>   
>> Great, and regarding the acpi, I have to boot with pci=noacpi. Am I wrong ?
>>
>>
>> Joseph Jezak wrote:
>>     
>>> Mansour wrote:
>>>       
>>>> I have the same laptop HP (dv9000)  model DV9408ca with min PCI card.
>>>> extra info is attached. Does this mean that mine is supported?
>>>>
>>>> I am getting :
>>>> bcm43xx: Unsupported 80211 core revision 13
>>>>         
> I have a DV9208NR and I have had no acpi problems.  However, I have to
> boot with the pci=nommconf in order for the ndiswrapper to drive the
> broadcom 4311.  I periodically black list the ndiswrapper and enable
> the bcm43xx-80211 driver and this past week was the first time I could
> get the native driver to associate with my router using wep
> encryption.
>
> I could not get more than 11m out of it though.  If I tried to force
> it to any rate greater than 11 then it would associate, but it would
> not allow any through put.
>
>   

John, Thank you. This is the first time I was able to boot to the login 
screen with out using noacpi option. I took your advice and used 
pci=nommconf instead. And it worked fine. Further more, when I try to 
start my wireless connection, it's not complaining any more about  
"SIOCSIFFLAGS: Device or resource busy". I am still not able to connect 
though. I am trying to find why. Here 's the output of starting the 
network service:

---------------------------------------------------------------

Bringing up loopback interface:                            [  OK  ]
Bringing up interface eth0: 
Determining IP information for eth0...dhclient(3930) is already running 
- exiting.
This version of ISC DHCP is based on the release available
on ftp.isc.org.  Features have been added and other changes
have been made to the base software release in order to make
it work better with this distribution.
Please report for this software via the Red Hat Bugzilla site:
    http://bugzilla.redhat.com
exiting.
 failed.
                                                           [FAILED]
Bringing up interface eth1: 
Determining IP information for eth1... failed; no link present.  Check 
cable?
                                                           [FAILED]
RTNETLINK answers: File exists
RTNETLINK answers: File exists
RTNETLINK answers: File exists
RTNETLINK answers: File exists
RTNETLINK answers: File exists
RTNETLINK answers: File exists
RTNETLINK answers: File exists
RTNETLINK answers: File exists
RTNETLINK answers: File exists


--------------------------------------------------------------------------
dmesg  output is attached to this email. Hope it helps. I 'll try to 
find put what's going on. I really appreciate your input.
Thank you.





-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: dmesg.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070729/cf2161f8/attachment.txt>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: startNW.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070729/cf2161f8/attachment-0001.txt>

From josejx at gentoo.org  Mon Jul 30 01:07:49 2007
From: josejx at gentoo.org (Joseph Jezak)
Date: Sun, 29 Jul 2007 19:07:49 -0400
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <aa73b9a0707291437k33d4b6ebj41fcb49cb60121da@mail.gmail.com>
References: <46ACC7C4.5060808@richardharman.com>
	<46ACD1FE.3030208@gentoo.org>	<46ACDB28.4030009@yahoo.com>
	<46ACDFBB.80301@gentoo.org>	<46ACEBCB.6070003@yahoo.com>
	<aa73b9a0707291437k33d4b6ebj41fcb49cb60121da@mail.gmail.com>
Message-ID: <46AD1DC5.5000206@gentoo.org>


> I have a DV9208NR and I have had no acpi problems.  However, I have to
> boot with the pci=nommconf in order for the ndiswrapper to drive the
> broadcom 4311.  I periodically black list the ndiswrapper and enable
> the bcm43xx-80211 driver and this past week was the first time I could
> get the native driver to associate with my router using wep
> encryption.
> 
> I could not get more than 11m out of it though.  If I tried to force
> it to any rate greater than 11 then it would associate, but it would
> not allow any through put.
> 

Which version of the 4311 do you have?  You should see the analog, 
type and revision numbers listed in dmesg if you have debugging 
turned on.  It's most likely not the same one that this thread is 
about if it's working at all.

-Joe


From mansour77 at yahoo.com  Mon Jul 30 01:18:46 2007
From: mansour77 at yahoo.com (Mansour)
Date: Sun, 29 Jul 2007 20:18:46 -0300
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <46AD1E08.4020202@gentoo.org>
References: <46ACC7C4.5060808@richardharman.com>
	<46ACD1FE.3030208@gentoo.org>	<46ACDB28.4030009@yahoo.com>
	<46ACDFBB.80301@gentoo.org> <46ACEBCB.6070003@yahoo.com>
	<46AD1E08.4020202@gentoo.org>
Message-ID: <46AD2056.9060709@yahoo.com>

Joe, I have compiled kernel from source. This has nothing to do with my 
distro (fedora 7).
If you have a look into my previous email, you will see the message 
about not able to register IRQ0 has disappeared.
Does this tell you something ?


Joseph Jezak wrote:
> Mansour wrote:
>> Great, and regarding the acpi, I have to boot with pci=noacpi. Am I 
>> wrong ?
>
> I can't really say anything about this, it's not really related to 
> bcm43xx though.  You might have more luck asking the support 
> forums/mailing lists for your distro.
>
> -Joe
>



From josejx at gentoo.org  Mon Jul 30 01:26:16 2007
From: josejx at gentoo.org (Joseph Jezak)
Date: Sun, 29 Jul 2007 19:26:16 -0400
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <46AD1FA9.1010803@yahoo.com>
References: <46ACC7C4.5060808@richardharman.com>	<46ACD1FE.3030208@gentoo.org>	<46ACDB28.4030009@yahoo.com>	<46ACDFBB.80301@gentoo.org>	<46ACEBCB.6070003@yahoo.com>	<aa73b9a0707291437k33d4b6ebj41fcb49cb60121da@mail.gmail.com>
	<46AD1FA9.1010803@yahoo.com>
Message-ID: <46AD2218.1040407@gentoo.org>

> John, Thank you. This is the first time I was able to boot to the login 
> screen with out using noacpi option. I took your advice and used 
> pci=nommconf instead. And it worked fine. Further more, when I try to 
> start my wireless connection, it's not complaining any more about  
> "SIOCSIFFLAGS: Device or resource busy". I am still not able to connect 
> though. I am trying to find why. Here 's the output of starting the 
> network service:

It's not going to work because bcm43xx isn't setting it up correctly 
like I mentioned in the first email.  We're not uploading the proper 
firmware or initvals for this card.  Additionally, there are 
probably (if previous revisions are any indication) additional 
workarounds required that are specific to this model.

I'm sorry, but we haven't looked through bcm's code yet or spec'd 
these changes, so the chance that things will work is pretty much nil.

Sorry,
-Joe


From mansour77 at yahoo.com  Mon Jul 30 01:57:38 2007
From: mansour77 at yahoo.com (Mansour)
Date: Sun, 29 Jul 2007 20:57:38 -0300
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <46AD1DC5.5000206@gentoo.org>
References: <46ACC7C4.5060808@richardharman.com>	<46ACD1FE.3030208@gentoo.org>	<46ACDB28.4030009@yahoo.com>	<46ACDFBB.80301@gentoo.org>	<46ACEBCB.6070003@yahoo.com>	<aa73b9a0707291437k33d4b6ebj41fcb49cb60121da@mail.gmail.com>
	<46AD1DC5.5000206@gentoo.org>
Message-ID: <46AD2972.504@yahoo.com>

Joseph Jezak wrote:
>> I have a DV9208NR and I have had no acpi problems.  However, I have to
>> boot with the pci=nommconf in order for the ndiswrapper to drive the
>> broadcom 4311.  I periodically black list the ndiswrapper and enable
>> the bcm43xx-80211 driver and this past week was the first time I could
>> get the native driver to associate with my router using wep
>> encryption.
>>
>> I could not get more than 11m out of it though.  If I tried to force
>> it to any rate greater than 11 then it would associate, but it would
>> not allow any through put.
>>
>>     
>
> Which version of the 4311 do you have?  You should see the analog, 
> type and revision numbers listed in dmesg if you have debugging 
> turned on.  It's most likely not the same one that this thread is 
> about if it's working at all.
>
> -Joe
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
>   
you are right Joseph. Mine 1390.



From larry.finger at lwfinger.net  Mon Jul 30 03:35:00 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 29 Jul 2007 20:35:00 -0500
Subject: wireless card 1930 in hp dv9000
In-Reply-To: <46ACB7FC.5030702@yahoo.com>
References: <46ACB7FC.5030702@yahoo.com>
Message-ID: <46AD4044.9090102@lwfinger.net>

Mansour wrote:
> Hello Larry:
> I have been trying to get my card working for few days but no luck. I 
> posted on the forums and ended up going to the IRC channels and they 
> advised me to go to you.
> 
> I just bough an hp dv9000 and things  are great except for the wireless 
> card. Bunny_Bug an member on the IRC channel gave me a link to 
> https://lists.berlios.de/pipermail/bcm43xx-dev/2007-July/005068.html. I 
> never tried this one yet, but another member suggested that I have a new 
> card that have never been seen. They gave m your email and advised me to 
> talk to you to get things going.

Your card has a BCM4311 chip, the same as mine, but it is a different implementation. From your 
dmesg output, we find:

PCI: No IRQ known for interrupt pin A of device 0000:03:00.0. Probably buggy MP table.
PCI: Setting latency timer of device 0000:03:00.0 to 64
bcm43xx: Chip ID 0x4311, rev 0x2
bcm43xx: Number of cores: 4
bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 0x4243
bcm43xx: Unsupported 80211 core revision 13
bcm43xx: Core 2: ID 0x817, rev 0x4, vendor 0x4243
bcm43xx: Core 3: ID 0x820, rev 0x5, vendor 0x4243
bcm43xx: PHY connected
bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 9
bcm43xx: Invalid PHY Revision 9
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
bcm43xx: Radio turned off

The first problem is that interrupts will not be processed for this device. It may be a buggy MP 
table, incorrect firmware, or some other problem. I don't know at this point. In addition, it is 
unlikely that V3 firmware was ever written for this device - thus it will need to use 
bcm43xx-mac80211 with V4 firmware. As you have seen in the messages from Joseph Jezak, drivers for 
this device have not yet been reverse engineered.

Sorry that we will not be able to help you with this problem for some time. This is the result of 
the total lack of cooperation from Broadcom, and too little manpower for the reverse engineering 
effort. We welcome volunteers.

Larry


From larry.finger at lwfinger.net  Mon Jul 30 03:41:01 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 29 Jul 2007 20:41:01 -0500
Subject: Patch for bcm4301 driver (PHY and radio from bcm43xx,
	uses mac80211 as MAC layer)
In-Reply-To: <200707292353.24897.richie@coderworld.net>
References: <46AB5B9F.7030601@lwfinger.net>
	<200707292353.24897.richie@coderworld.net>
Message-ID: <46AD41AD.2020800@lwfinger.net>

Richard Jonsson wrote:
> I have tried using this patch applied to kernel 2.6.22.1 on a 4311 chip. The 
> module loads fine, but when attempting to associate the computer hangs.
> 
> I'm doing fine with bcm43xx, but was tempted to try bcm4301 since the numbers 
> looked so promising.
> 
--- snip ---

> [   54.318355] ADDRCONF(NETDEV_UP): eth0: link is not ready
> [   54.318390] ADDRCONF(NETDEV_UP): eth1: link is not ready

Assuming that eth1 is the wireless device, this is the first indication of trouble. Please send the 
results of 'iwconfig', 'ifconfig', and iwlist scan'.

Thanks,

Larry


From larry.finger at lwfinger.net  Mon Jul 30 03:49:46 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 29 Jul 2007 20:49:46 -0500
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <aa73b9a0707291437k33d4b6ebj41fcb49cb60121da@mail.gmail.com>
References: <46ACC7C4.5060808@richardharman.com>
	<46ACD1FE.3030208@gentoo.org>	<46ACDB28.4030009@yahoo.com>
	<46ACDFBB.80301@gentoo.org>	<46ACEBCB.6070003@yahoo.com>
	<aa73b9a0707291437k33d4b6ebj41fcb49cb60121da@mail.gmail.com>
Message-ID: <46AD43BA.6030108@lwfinger.net>

John Pierce wrote:
> I have a DV9208NR and I have had no acpi problems.  However, I have to
> boot with the pci=nommconf in order for the ndiswrapper to drive the
> broadcom 4311.  I periodically black list the ndiswrapper and enable
> the bcm43xx-80211 driver and this past week was the first time I could
> get the native driver to associate with my router using wep
> encryption.
> 
> I could not get more than 11m out of it though.  If I tried to force
> it to any rate greater than 11 then it would associate, but it would
> not allow any through put.

I added the "set rate" code to mac80211 for testing purposes; however, one should not force it to a 
higher rate than the automatic mechanism wants. If you do, the error rate becomes intolerable, which 
is what you experienced.

Larry


From larry.finger at lwfinger.net  Mon Jul 30 03:55:07 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 29 Jul 2007 20:55:07 -0500
Subject: bcm 4311 w/ pci id 1374 unsupported phy (analog 4, type 2, rev 9)
In-Reply-To: <46AD2056.9060709@yahoo.com>
References: <46ACC7C4.5060808@richardharman.com>
	<46ACD1FE.3030208@gentoo.org>	<46ACDB28.4030009@yahoo.com>
	<46ACDFBB.80301@gentoo.org> <46ACEBCB.6070003@yahoo.com>
	<46AD1E08.4020202@gentoo.org> <46AD2056.9060709@yahoo.com>
Message-ID: <46AD44FB.4070500@lwfinger.net>

Mansour wrote:
> Joe, I have compiled kernel from source. This has nothing to do with my 
> distro (fedora 7).
> If you have a look into my previous email, you will see the message 
> about not able to register IRQ0 has disappeared.
> Does this tell you something ?
> 

Yes - it was due to the MMU problem. Your BCM4311 has a PHY version not supported, which is why you 
get the XMIT error.

Larry


From Larry.Finger at lwfinger.net  Mon Jul 30 21:16:59 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 30 Jul 2007 14:16:59 -0500
Subject: New Patch (#2) for bcm4301 driver (PHY and radio from bcm43xx, uses
	mac80211 as MAC layer)
Message-ID: <46AE392B.9000707@lwfinger.net>

A new version of the new driver for Broadcom wireless devices is now available for testing. The 
problem with it for Linus's or the wireless-2.6 trees was the configuration of SSB. I modified the 
patch to automatically select the correct options to prevent this problem.

There are now three different versions of the patch - one for each supported tree:

ftp://lwfinger.dynalias.org/patches/BCM4301_for_2.6.22.patch
ftp://lwfinger.dynalias.org/patches/BCM4301_for_2.6.23.patch
ftp://lwfinger.dynalias.org/patches/BCM4301_for_wireless-2.6.patch

The instructions are as follows:

1. Download the file and patch the source.

2. Configure it with 'make xconfig' or 'make menuconfig'. In "Networking/Wireless", select the
mac80211 IEEE80211 networking stack. Deselect the other generic IEEE802.11 stack. Under
Drivers/Network device support/Wireless LAN", select the BCM4301 driver with debugging support.

3. Build and install the kernel and modules. This version uses V3 firmware, the same as
bcm43xx-softmac. Although it is planned that this driver will eventually support only the
802.11b-devices (BCM4301 and BCM4303), it currently supports all 802.11b and 802.11g devices.

PLease report your results - good or bad. There have been hangs reported that may have been due to 
the misconfiguration fixed in the new versions. I'm still interested in any warnings and/or oops's.

Thanks,

Larry





From Larry.Finger at lwfinger.net  Tue Jul 31 17:06:04 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 31 Jul 2007 10:06:04 -0500
Subject: [RFC] bcm43xx: Replacement of TODO statements in keymac_write
Message-ID: <46af4fdc.yL3OfRHUkvjfN8br%Larry.Finger@lwfinger.net>

Routine keymac_write in bcm43xx has two TODO statements that generate lots of
useless log output for early chip versions. This patch replaces them with code
to store the keys.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Michael,

Is this correct? The whole business of words versus bytes in shared memory
is very confusing.

Larry

---------

 bcm43xx.h      |    1 +
 bcm43xx_main.c |   21 +++++++++++++++++----
 2 files changed, 18 insertions(+), 4 deletions(-)

Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx.h
+++ wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
@@ -156,6 +156,7 @@
 /* MacFilter offsets. */
 #define BCM43xx_MACFILTER_SELF		0x0000
 #define BCM43xx_MACFILTER_ASSOC		0x0003
+#define BCM43xx_MACFILTER_MAC		0x0010
 
 /* Chipcommon registers. */
 #define BCM43xx_CHIPCOMMON_CAPABILITIES 	0x04
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -378,6 +378,7 @@ static void bcm43xx_macfilter_clear(stru
 	const u8 zero_addr[ETH_ALEN] = { 0 };
 
 	bcm43xx_macfilter_set(bcm, offset, zero_addr);
+	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x003E, 0);
 }
 
 static void bcm43xx_write_mac_bssid_templates(struct bcm43xx_private *bcm)
@@ -1108,12 +1109,24 @@ static void keymac_write(struct bcm43xx_
 				    (index * 2) + 1,
 				    cpu_to_be16(*((u16 *)(addr + 1))));
 	} else {
-		if (index < 8) {
-			TODO(); /* Put them in the macaddress filter */
+		if (index < 4) {
+			bcm43xx_macfilter_set(bcm, BCM43xx_MACFILTER_MAC +
+					      index * 6, (const u8 *)addr);
 		} else {
-			TODO();
 			/* Put them BCM43xx_SHM_SHARED, stating index 0x0120.
-			   Keep in mind to update the count of keymacs in 0x003E as well! */
+			   Update the count of keymacs in 0x003E as well */
+			bcm43xx_shm_write32(bcm,
+					    BCM43xx_SHM_SHARED,
+					    (index - 4) * 6 + 0x120,
+					    cpu_to_be32(*addr));
+			bcm43xx_shm_write16(bcm,
+					    BCM43xx_SHM_SHARED,
+					    (index - 4) * 6 + 0x124,
+					    cpu_to_be16(*((u16 *)(addr + 1))));
+			bcm43xx_shm_write32(bcm,	/* update count */
+					    BCM43xx_SHM_SHARED, 0x003E,
+					    bcm43xx_shm_read32(bcm,
+					    BCM43xx_SHM_SHARED, 0x003E) + 1);
 		}
 	}
 }


From mb at bu3sch.de  Tue Jul 31 20:11:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 31 Jul 2007 20:11:48 +0200
Subject: [RFC] bcm43xx: Replacement of TODO statements in keymac_write
In-Reply-To: <46af4fdc.yL3OfRHUkvjfN8br%Larry.Finger@lwfinger.net>
References: <46af4fdc.yL3OfRHUkvjfN8br%Larry.Finger@lwfinger.net>
Message-ID: <200707312011.48799.mb@bu3sch.de>

On Tuesday 31 July 2007 17:06:04 Larry Finger wrote:
> Routine keymac_write in bcm43xx has two TODO statements that generate lots of
> useless log output for early chip versions. This patch replaces them with code
> to store the keys.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Michael,
> 
> Is this correct? The whole business of words versus bytes in shared memory
> is very confusing.

No, it's completely broken. It's broken like all the other
hwcrypto stuff in the softmac driver. :)
Please simply remove all that hwcrypto stuff and always force
swcrypto.

> Larry
> 
> ---------
> 
>  bcm43xx.h      |    1 +
>  bcm43xx_main.c |   21 +++++++++++++++++----
>  2 files changed, 18 insertions(+), 4 deletions(-)
> 
> Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx.h
> +++ wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
> @@ -156,6 +156,7 @@
>  /* MacFilter offsets. */
>  #define BCM43xx_MACFILTER_SELF		0x0000
>  #define BCM43xx_MACFILTER_ASSOC		0x0003
> +#define BCM43xx_MACFILTER_MAC		0x0010
>  
>  /* Chipcommon registers. */
>  #define BCM43xx_CHIPCOMMON_CAPABILITIES 	0x04
> Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> +++ wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> @@ -378,6 +378,7 @@ static void bcm43xx_macfilter_clear(stru
>  	const u8 zero_addr[ETH_ALEN] = { 0 };
>  
>  	bcm43xx_macfilter_set(bcm, offset, zero_addr);
> +	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x003E, 0);
>  }
>  
>  static void bcm43xx_write_mac_bssid_templates(struct bcm43xx_private *bcm)
> @@ -1108,12 +1109,24 @@ static void keymac_write(struct bcm43xx_
>  				    (index * 2) + 1,
>  				    cpu_to_be16(*((u16 *)(addr + 1))));
>  	} else {
> -		if (index < 8) {
> -			TODO(); /* Put them in the macaddress filter */
> +		if (index < 4) {
> +			bcm43xx_macfilter_set(bcm, BCM43xx_MACFILTER_MAC +
> +					      index * 6, (const u8 *)addr);
>  		} else {
> -			TODO();
>  			/* Put them BCM43xx_SHM_SHARED, stating index 0x0120.
> -			   Keep in mind to update the count of keymacs in 0x003E as well! */
> +			   Update the count of keymacs in 0x003E as well */
> +			bcm43xx_shm_write32(bcm,
> +					    BCM43xx_SHM_SHARED,
> +					    (index - 4) * 6 + 0x120,
> +					    cpu_to_be32(*addr));
> +			bcm43xx_shm_write16(bcm,
> +					    BCM43xx_SHM_SHARED,
> +					    (index - 4) * 6 + 0x124,
> +					    cpu_to_be16(*((u16 *)(addr + 1))));
> +			bcm43xx_shm_write32(bcm,	/* update count */
> +					    BCM43xx_SHM_SHARED, 0x003E,
> +					    bcm43xx_shm_read32(bcm,
> +					    BCM43xx_SHM_SHARED, 0x003E) + 1);
>  		}
>  	}
>  }
> 
> 



-- 
Greetings Michael.


