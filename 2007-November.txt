From mb at bu3sch.de  Fri Nov  2 18:35:02 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 2 Nov 2007 18:35:02 +0100
Subject: [PATCH] b43: debugfs SHM read buffer overrun fix
Message-ID: <200711021835.02371.mb@bu3sch.de>

Fix possible buffer overrun.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

We are searching a new b43legacy maintainer.
So if someone is interested in this job, please start with porting
this easy patch to b43legacy. ;)

Index: wireless-2.6/drivers/net/wireless/b43/debugfs.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/debugfs.c	2007-11-02 18:26:55.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/debugfs.c	2007-11-02 18:28:24.000000000 +0100
@@ -128,7 +128,7 @@ static ssize_t shm_read_file(struct b43_
 	__le16 *le16buf = (__le16 *)buf;
 
 	for (i = 0; i < 0x1000; i++) {
-		if (bufsize <= 0)
+		if (bufsize < sizeof(tmp))
 			break;
 		tmp = b43_shm_read16(dev, B43_SHM_SHARED, 2 * i);
 		le16buf[i] = cpu_to_le16(tmp);


From mb at bu3sch.de  Sat Nov  3 14:34:32 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 3 Nov 2007 14:34:32 +0100
Subject: [PATCH] b43: Rewrite and fix rfkill init
Message-ID: <200711031434.32541.mb@bu3sch.de>

The rfkill subsystem doesn't like code like that
rfkill_allocate();
rfkill_register();
rfkill_unregister();
rfkill_register(); /* <- This will crash */

This sequence happens with
modprobe b43
ifconfig wlanX up
ifconfig wlanX down
ifconfig wlanX up

Fix this by always re-allocating the rfkill stuff before register.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Note that this has to be ported to b43legacy.
Some volunteers? :)


Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2007-11-03 14:19:21.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2007-11-03 14:26:39.000000000 +0100
@@ -3686,7 +3686,6 @@ static int b43_setup_modes(struct b43_wl
 
 static void b43_wireless_core_detach(struct b43_wldev *dev)
 {
-	b43_rfkill_free(dev);
 	/* We release firmware that late to not be required to re-request
 	 * is all the time when we reinit the core. */
 	b43_release_firmware(dev);
@@ -3772,7 +3771,6 @@ static int b43_wireless_core_attach(stru
 	if (!wl->current_dev)
 		wl->current_dev = dev;
 	INIT_WORK(&dev->restart_work, b43_chip_reset);
-	b43_rfkill_alloc(dev);
 
 	b43_radio_turn_off(dev, 1);
 	b43_switch_analog(dev, 0);
Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c	2007-11-02 20:16:14.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.c	2007-11-03 14:19:38.000000000 +0100
@@ -47,18 +47,21 @@ static void b43_rfkill_poll(struct input
 	struct b43_wldev *dev = poll_dev->private;
 	struct b43_wl *wl = dev->wl;
 	bool enabled;
+	bool report_change = 0;
 
 	mutex_lock(&wl->mutex);
 	B43_WARN_ON(b43_status(dev) < B43_STAT_INITIALIZED);
 	enabled = b43_is_hw_radio_enabled(dev);
 	if (unlikely(enabled != dev->radio_hw_enable)) {
 		dev->radio_hw_enable = enabled;
+		report_change = 1;
 		b43info(wl, "Radio hardware status changed to %s\n",
 			enabled ? "ENABLED" : "DISABLED");
-		mutex_unlock(&wl->mutex);
+	}
+	mutex_unlock(&wl->mutex);
+
+	if (unlikely(report_change))
 		input_report_key(poll_dev->input, KEY_WLAN, enabled);
-	} else
-		mutex_unlock(&wl->mutex);
 }
 
 /* Called when the RFKILL toggled in software. */
@@ -68,18 +71,11 @@ static int b43_rfkill_soft_toggle(void *
 	struct b43_wl *wl = dev->wl;
 	int err = 0;
 
-	/* When RFKILL is registered, it will call back into this callback.
-	 * wl->mutex will already be locked when this happens.
-	 * So first trylock. On contention check if we are in initialization.
-	 * Silently return if that happens to avoid a deadlock. */
-	if (mutex_trylock(&wl->mutex) == 0) {
-		if (b43_status(dev) < B43_STAT_INITIALIZED)
-			return 0;
-		mutex_lock(&wl->mutex);
-	}
-	if (b43_status(dev) < B43_STAT_INITIALIZED)
-		goto out_unlock;
+	if (!wl->rfkill.registered)
+		return 0;
 
+	mutex_lock(&wl->mutex);
+	B43_WARN_ON(b43_status(dev) < B43_STAT_INITIALIZED);
 	switch (state) {
 	case RFKILL_STATE_ON:
 		if (!dev->radio_hw_enable) {
@@ -104,11 +100,11 @@ out_unlock:
 
 char * b43_rfkill_led_name(struct b43_wldev *dev)
 {
-	struct b43_wl *wl = dev->wl;
+	struct b43_rfkill *rfk = &(dev->wl->rfkill);
 
-	if (!wl->rfkill.rfkill)
+	if (!rfk->registered)
 		return NULL;
-	return rfkill_get_led_name(wl->rfkill.rfkill);
+	return rfkill_get_led_name(rfk->rfkill);
 }
 
 void b43_rfkill_init(struct b43_wldev *dev)
@@ -117,53 +113,13 @@ void b43_rfkill_init(struct b43_wldev *d
 	struct b43_rfkill *rfk = &(wl->rfkill);
 	int err;
 
-	if (rfk->rfkill) {
-		err = rfkill_register(rfk->rfkill);
-		if (err) {
-			b43warn(wl, "Failed to register RF-kill button\n");
-			goto err_free_rfk;
-		}
-	}
-	if (rfk->poll_dev) {
-		err = input_register_polled_device(rfk->poll_dev);
-		if (err) {
-			b43warn(wl, "Failed to register RF-kill polldev\n");
-			goto err_free_polldev;
-		}
-	}
-
-	return;
-err_free_rfk:
-	rfkill_free(rfk->rfkill);
-	rfk->rfkill = NULL;
-err_free_polldev:
-	input_free_polled_device(rfk->poll_dev);
-	rfk->poll_dev = NULL;
-}
-
-void b43_rfkill_exit(struct b43_wldev *dev)
-{
-	struct b43_rfkill *rfk = &(dev->wl->rfkill);
-
-	if (rfk->poll_dev)
-		input_unregister_polled_device(rfk->poll_dev);
-	if (rfk->rfkill)
-		rfkill_unregister(rfk->rfkill);
-}
-
-void b43_rfkill_alloc(struct b43_wldev *dev)
-{
-	struct b43_wl *wl = dev->wl;
-	struct b43_rfkill *rfk = &(wl->rfkill);
+	rfk->registered = 0;
 
+	rfk->rfkill = rfkill_allocate(dev->dev->dev, RFKILL_TYPE_WLAN);
+	if (!rfk->rfkill)
+		goto out_error;
 	snprintf(rfk->name, sizeof(rfk->name),
 		 "b43-%s", wiphy_name(wl->hw->wiphy));
-
-	rfk->rfkill = rfkill_allocate(dev->dev->dev, RFKILL_TYPE_WLAN);
-	if (!rfk->rfkill) {
-		b43warn(wl, "Failed to allocate RF-kill button\n");
-		return;
-	}
 	rfk->rfkill->name = rfk->name;
 	rfk->rfkill->state = RFKILL_STATE_ON;
 	rfk->rfkill->data = dev;
@@ -171,18 +127,45 @@ void b43_rfkill_alloc(struct b43_wldev *
 	rfk->rfkill->user_claim_unsupported = 1;
 
 	rfk->poll_dev = input_allocate_polled_device();
-	if (rfk->poll_dev) {
-		rfk->poll_dev->private = dev;
-		rfk->poll_dev->poll = b43_rfkill_poll;
-		rfk->poll_dev->poll_interval = 1000; /* msecs */
-	} else
-		b43warn(wl, "Failed to allocate RF-kill polldev\n");
+	if (!rfk->poll_dev)
+		goto err_free_rfk;
+	rfk->poll_dev->private = dev;
+	rfk->poll_dev->poll = b43_rfkill_poll;
+	rfk->poll_dev->poll_interval = 1000; /* msecs */
+
+	err = rfkill_register(rfk->rfkill);
+	if (err)
+		goto err_free_polldev;
+	err = input_register_polled_device(rfk->poll_dev);
+	if (err)
+		goto err_unreg_rfk;
+
+	rfk->registered = 1;
+
+	return;
+err_unreg_rfk:
+	rfkill_unregister(rfk->rfkill);
+err_free_polldev:
+	input_free_polled_device(rfk->poll_dev);
+	rfk->poll_dev = NULL;
+err_free_rfk:
+	rfkill_free(rfk->rfkill);
+	rfk->rfkill = NULL;
+out_error:
+	rfk->registered = 0;
+	b43warn(wl, "RF-kill button init failed\n");
 }
 
-void b43_rfkill_free(struct b43_wldev *dev)
+void b43_rfkill_exit(struct b43_wldev *dev)
 {
 	struct b43_rfkill *rfk = &(dev->wl->rfkill);
 
+	if (!rfk->registered)
+		return;
+	rfk->registered = 0;
+
+	input_unregister_polled_device(rfk->poll_dev);
+	rfkill_unregister(rfk->rfkill);
 	input_free_polled_device(rfk->poll_dev);
 	rfk->poll_dev = NULL;
 	rfkill_free(rfk->rfkill);
Index: wireless-2.6/drivers/net/wireless/b43/rfkill.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.h	2007-10-27 13:28:16.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.h	2007-11-03 14:19:38.000000000 +0100
@@ -15,14 +15,14 @@ struct b43_rfkill {
 	struct rfkill *rfkill;
 	/* The poll device for the RFKILL input button */
 	struct input_polled_dev *poll_dev;
+	/* Did initialization succeed? Used for freeing. */
+	bool registered;
 	/* The unique name of this rfkill switch */
-	char name[32];
+	char name[sizeof("b43-phy4294967295")];
 };
 
-/* All the init functions return void, because we are not interested
+/* The init function returns void, because we are not interested
  * in failing the b43 init process when rfkill init failed. */
-void b43_rfkill_alloc(struct b43_wldev *dev);
-void b43_rfkill_free(struct b43_wldev *dev);
 void b43_rfkill_init(struct b43_wldev *dev);
 void b43_rfkill_exit(struct b43_wldev *dev);
 
@@ -36,12 +36,6 @@ struct b43_rfkill {
 	/* empty */
 };
 
-static inline void b43_rfkill_alloc(struct b43_wldev *dev)
-{
-}
-static inline void b43_rfkill_free(struct b43_wldev *dev)
-{
-}
 static inline void b43_rfkill_init(struct b43_wldev *dev)
 {
 }


From Larry.Finger at lwfinger.net  Sat Nov  3 16:19:46 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 03 Nov 2007 10:19:46 -0500
Subject: [RFC] ssb: Add code for SPROM Rev 4
Message-ID: <472c9192.8nd7AOTgl+jWptik%Larry.Finger@lwfinger.net>

The BCM4328 has a revision 4 SPROM. The necessary changes to handle the
layout and different size of this revision are implemented. The size of
the SPROM is now stored in the ssb_bus struct and used from that location
whenever possible. For those routines that need the size, but do not have
access to that struct, a size argument is added.

Recognition of the PCI_ID of the BCM4328 is also implemented. Note that
the PCI_ID is 0x4328, but the chipid is 0x4321.

This code has been tested by Michael Gerdau <mgerdau at tiscali.de>.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Michael,

Please comment on this patch. It is intended to be applied to wireless-2.6/everything.

Larry
---

 drivers/ssb/b43_pci_bridge.c |    1
 drivers/ssb/main.c           |    8 ++-
 drivers/ssb/pci.c            |  103 ++++++++++++++++++++++++++++++++-----------
 include/linux/ssb/ssb.h      |   35 ++++++++++++++
 include/linux/ssb/ssb_regs.h |   27 ++++++++++-
 5 files changed, 144 insertions(+), 30 deletions(-)

Index: wireless-2.6/drivers/ssb/b43_pci_bridge.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/b43_pci_bridge.c
+++ wireless-2.6/drivers/ssb/b43_pci_bridge.c
@@ -27,6 +27,7 @@ static const struct pci_device_id b43_pc
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4321) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4324) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4325) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4328) },
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, b43_pci_bridge_tbl);
Index: wireless-2.6/drivers/ssb/pci.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/pci.c
+++ wireless-2.6/drivers/ssb/pci.c
@@ -212,29 +212,29 @@ static inline u8 ssb_crc8(u8 crc, u8 dat
 	return t[crc ^ data];
 }
 
-static u8 ssb_sprom_crc(const u16 *sprom)
+static u8 ssb_sprom_crc(const u16 *sprom, u16 size)
 {
 	int word;
 	u8 crc = 0xFF;
 
-	for (word = 0; word < SSB_SPROMSIZE_WORDS - 1; word++) {
+	for (word = 0; word < size - 1; word++) {
 		crc = ssb_crc8(crc, sprom[word] & 0x00FF);
 		crc = ssb_crc8(crc, (sprom[word] & 0xFF00) >> 8);
 	}
-	crc = ssb_crc8(crc, sprom[SPOFF(SSB_SPROM_REVISION)] & 0x00FF);
+	crc = ssb_crc8(crc, sprom[size - 1] & 0x00FF);
 	crc ^= 0xFF;
 
 	return crc;
 }
 
-static int sprom_check_crc(const u16 *sprom)
+static int sprom_check_crc(const u16 *sprom, u16 size)
 {
 	u8 crc;
 	u8 expected_crc;
 	u16 tmp;
 
-	crc = ssb_sprom_crc(sprom);
-	tmp = sprom[SPOFF(SSB_SPROM_REVISION)] & SSB_SPROM_REVISION_CRC;
+	crc = ssb_sprom_crc(sprom, size);
+	tmp = sprom[size - 1] & SSB_SPROM_REVISION_CRC;
 	expected_crc = tmp >> SSB_SPROM_REVISION_CRC_SHIFT;
 	if (crc != expected_crc)
 		return -EPROTO;
@@ -246,7 +246,7 @@ static void sprom_do_read(struct ssb_bus
 {
 	int i;
 
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++)
+	for (i = 0; i < bus->sprom_size; i++)
 		sprom[i] = readw(bus->mmio + SSB_SPROM_BASE + (i * 2));
 }
 
@@ -255,6 +255,7 @@ static int sprom_do_write(struct ssb_bus
 	struct pci_dev *pdev = bus->host_pci;
 	int i, err;
 	u32 spromctl;
+	u16 size = bus->sprom_size;
 
 	ssb_printk(KERN_NOTICE PFX "Writing SPROM. Do NOT turn off the power! Please stand by...\n");
 	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
@@ -266,12 +267,12 @@ static int sprom_do_write(struct ssb_bus
 		goto err_ctlreg;
 	ssb_printk(KERN_NOTICE PFX "[ 0%%");
 	msleep(500);
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
-		if (i == SSB_SPROMSIZE_WORDS / 4)
+	for (i = 0; i < size; i++) {
+		if (i == size / 4)
 			ssb_printk("25%%");
-		else if (i == SSB_SPROMSIZE_WORDS / 2)
+		else if (i == size / 2)
 			ssb_printk("50%%");
-		else if (i == (SSB_SPROMSIZE_WORDS / 4) * 3)
+		else if (i == (size * 3) / 4))
 			ssb_printk("75%%");
 		else if (i % 2)
 			ssb_printk(".");
@@ -417,6 +418,35 @@ static void sprom_extract_r3(struct ssb_
 	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0x00FF) << 8;
 }
 
+static void sprom_extract_r4(struct ssb_sprom_r4 *out, const u16 *in)
+{
+	int i;
+	u16 v;
+
+	SPEX(pci_spid, SSB_SPROM4_SPID, 0xFFFF, 0);
+	SPEX(pci_svid, SSB_SPROM4_SVID, 0xFFFF, 0);
+	SPEX(pci_pid, SSB_SPROM4_PID, 0xFFFF, 0);
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM4_IL0MAC) + i];
+		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
+		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
+		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
+	}
+	SPEX(et0phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET0A, 0);
+	SPEX(et1phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET1A,
+	     SSB_SPROM4_ETHPHY_ET1A_SHIFT);
+	SPEX(et0mdcport, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET0M, 14);
+	SPEX(et1mdcport, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET1M, 15);
+	SPEX(country_code, SSB_SPROM4_CCODE, 0xFFFF, 0);
+	SPEX(antenna_a, SSB_SPROM4_ANT_A, 0xFFFF, 0);
+	SPEX(antenna_bg, SSB_SPROM4_ANT_BG, 0xFFFF, 0);
+	SPEX(boardflags_lo, SSB_SPROM4_BFLLO, 0xFFFF, 0);
+	SPEX(antenna_gain_a, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_0, 0);
+	SPEX(antenna_gain_bg, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_1,
+	     SSB_SPROM4_AGAIN_1_SHIFT);
+	/* TODO - get remaining rev 4 stuff needed */
+}
+
 static int sprom_extract(struct ssb_bus *bus,
 			 struct ssb_sprom *out, const u16 *in)
 {
@@ -431,6 +461,10 @@ static int sprom_extract(struct ssb_bus 
 		 * number stored in the SPROM.
 		 * Always extract r1. */
 		sprom_extract_r1(&out->r1, in);
+	} else if (bus->chip_id == 0x4321) {
+		/* the BCM4328 has a chipid == 0x4321 and a rev 4 SPROM */
+		out->revision = 4;
+		sprom_extract_r4(&out->r4, in);
 	} else {
 		if (out->revision == 0)
 			goto unsupported;
@@ -448,6 +482,7 @@ static int sprom_extract(struct ssb_bus 
 unsupported:
 	ssb_printk(KERN_WARNING PFX "Unsupported SPROM revision %d "
 		   "detected. Will extract v1\n", out->revision);
+
 	sprom_extract_r1(&out->r1, in);
 	return 0;
 }
@@ -458,14 +493,29 @@ static int ssb_pci_sprom_get(struct ssb_
 	int err = -ENOMEM;
 	u16 *buf;
 
-	buf = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	buf = kcalloc(SSB_SPROMSIZE_WORDS_R13, sizeof(u16), GFP_KERNEL);
 	if (!buf)
 		goto out;
+	bus->sprom_size = SSB_SPROMSIZE_WORDS_R13;
 	sprom_do_read(bus, buf);
-	err = sprom_check_crc(buf);
+	err = sprom_check_crc(buf, SSB_SPROMSIZE_WORDS_R13);
 	if (err) {
-		ssb_printk(KERN_WARNING PFX
-			   "WARNING: Invalid SPROM CRC (corrupt SPROM)\n");
+		/* check for rev 4 sprom - has special signature */
+		if (buf [32] == 0x5372) {
+			ssb_printk(KERN_WARNING PFX "Extracting a rev 4"
+				   " SPROM\n");
+			kfree(buf);
+			buf = kcalloc(SSB_SPROMSIZE_WORDS_R4, sizeof(u16),
+				      GFP_KERNEL);
+			if (!buf)
+				goto out;
+			bus->sprom_size = SSB_SPROMSIZE_WORDS_R4;
+			sprom_do_read(bus, buf);
+			err = sprom_check_crc(buf, SSB_SPROMSIZE_WORDS_R4);
+		}
+		if (err)
+			ssb_printk(KERN_WARNING PFX "WARNING: Invalid"
+				   " SPROM CRC (corrupt SPROM)\n");
 	}
 	err = sprom_extract(bus, sprom, buf);
 
@@ -483,6 +533,8 @@ static void ssb_pci_get_boardinfo(struct
 			     &bi->type);
 	pci_read_config_word(bus->host_pci, PCI_REVISION_ID,
 			     &bi->rev);
+	printk(KERN_INFO "ssb: vendor, type, rev: 0x%X 0x%X 0x%X\n",
+	       bi->vendor, bi->type, bi->rev);
 }
 
 int ssb_pci_get_invariants(struct ssb_bus *bus,
@@ -581,29 +633,28 @@ const struct ssb_bus_ops ssb_pci_ops = {
 	.write32	= ssb_pci_write32,
 };
 
-static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len)
+static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len, int size)
 {
 	int i, pos = 0;
 
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
+	for (i = 0; i < size; i++)
 		pos += snprintf(buf + pos, buf_len - pos - 1,
 				"%04X", swab16(sprom[i]) & 0xFFFF);
-	}
 	pos += snprintf(buf + pos, buf_len - pos - 1, "\n");
 
 	return pos + 1;
 }
 
-static int hex2sprom(u16 *sprom, const char *dump, size_t len)
+static int hex2sprom(u16 *sprom, const char *dump, size_t len, u16 size)
 {
 	char tmp[5] = { 0 };
 	int cnt = 0;
 	unsigned long parsed;
 
-	if (len < SSB_SPROMSIZE_BYTES * 2)
+	if (len < size * 2)
 		return -EINVAL;
 
-	while (cnt < SSB_SPROMSIZE_WORDS) {
+	while (cnt < size) {
 		memcpy(tmp, dump, 4);
 		dump += 4;
 		parsed = simple_strtoul(tmp, NULL, 16);
@@ -627,7 +678,7 @@ static ssize_t ssb_pci_attr_sprom_show(s
 	if (!bus)
 		goto out;
 	err = -ENOMEM;
-	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	sprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);
 	if (!sprom)
 		goto out;
 
@@ -640,7 +691,7 @@ static ssize_t ssb_pci_attr_sprom_show(s
 	sprom_do_read(bus, sprom);
 	mutex_unlock(&bus->pci_sprom_mutex);
 
-	count = sprom2hex(sprom, buf, PAGE_SIZE);
+	count = sprom2hex(sprom, buf, PAGE_SIZE, bus->sprom_size);
 	err = 0;
 
 out_kfree:
@@ -662,15 +713,15 @@ static ssize_t ssb_pci_attr_sprom_store(
 	if (!bus)
 		goto out;
 	err = -ENOMEM;
-	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	sprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);
 	if (!sprom)
 		goto out;
-	err = hex2sprom(sprom, buf, count);
+	err = hex2sprom(sprom, buf, count, bus->sprom_size);
 	if (err) {
 		err = -EINVAL;
 		goto out_kfree;
 	}
-	err = sprom_check_crc(sprom);
+	err = sprom_check_crc(sprom, bus->sprom_size);
 	if (err) {
 		err = -EINVAL;
 		goto out_kfree;
Index: wireless-2.6/include/linux/ssb/ssb_regs.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb_regs.h
+++ wireless-2.6/include/linux/ssb/ssb_regs.h
@@ -147,6 +147,8 @@
 #define  SSB_IDLOW_SSBREV	0xF0000000 /* Sonics Backplane Revision code */
 #define  SSB_IDLOW_SSBREV_22	0x00000000 /* <= 2.2 */
 #define  SSB_IDLOW_SSBREV_23	0x10000000 /* 2.3 */
+#define  SSB_IDLOW_SSBREV_24	0x40000000 /* 2.4 */
+#define  SSB_IDLOW_SSBREV_27	0x70000000 /* 2.? */
 #define SSB_IDHIGH		0x0FFC     /* SB Identification High */
 #define  SSB_IDHIGH_RCLO	0x0000000F /* Revision Code (low part) */
 #define  SSB_IDHIGH_CC		0x00008FF0 /* Core Code */
@@ -160,8 +162,10 @@
  * two bytes wide. Note that the SPROM can _only_ be read
  * in two-byte quantinies.
  */
-#define SSB_SPROMSIZE_WORDS		64
-#define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
+#define SSB_SPROMSIZE_WORDS_R13		64
+#define SSB_SPROMSIZE_WORDS_R4		220
+#define SSB_SPROMSIZE_BYTES_R13		(SSB_SPROMSIZE_WORDS_R13 * sizeof(u16))
+#define SSB_SPROMSIZE_BYTES_R4		(SSB_SPROMSIZE_WORDS_R4 * sizeof(u16))
 #define SSB_SPROM_BASE			0x1000
 #define SSB_SPROM_REVISION		0x107E
 #define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
@@ -250,6 +254,25 @@
 #define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
 #define  SSB_SPROM3_CCKPO_11M_SHIFT	12
 #define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
+/* SPROM Revision 4 */
+#define SSB_SPROM4_SPID			0x1004	/* Subsys. Prod. ID for PCI */
+#define SSB_SPROM4_SVID			0x1006	/* Subsys. Vendor ID for PCI */
+#define SSB_SPROM4_PID			0x1008	/* Product ID for PCI */
+#define SSB_SPROM4_IL0MAC		0x104C	/* 6 byte MAC address for b/g */
+#define SSB_SPROM4_ETHPHY		0x105A	/* Ethernet PHY settings */
+#define  SSB_SPROM4_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
+#define  SSB_SPROM4_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
+#define  SSB_SPROM4_ETHPHY_ET1A_SHIFT	5
+#define  SSB_SPROM4_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
+#define  SSB_SPROM4_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
+#define SSB_SPROM4_CCODE		0x1052	/* Country Code (2 bytes) */
+#define SSB_SPROM4_ANT_A		0x105D  /* A Antennas */
+#define SSB_SPROM4_ANT_BG		0x105C  /* B/G Antennas */
+#define SSB_SPROM4_BFLLO		0x1044	/* Boardflags (low 16 bits) */
+#define SSB_SPROM4_AGAIN		0x105E	/* Antenna Gain (in dBm Q5.2) */
+#define  SSB_SPROM4_AGAIN_0		0x00FF	/* Antenna 0 */
+#define  SSB_SPROM4_AGAIN_1		0xFF00	/* Antenna 1 */
+#define  SSB_SPROM4_AGAIN_1_SHIFT	8
 
 /* Values for SSB_SPROM1_BINF_CCODE */
 enum {
Index: wireless-2.6/drivers/ssb/main.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/main.c
+++ wireless-2.6/drivers/ssb/main.c
@@ -876,15 +876,21 @@ EXPORT_SYMBOL(ssb_clockspeed);
 
 static u32 ssb_tmslow_reject_bitmask(struct ssb_device *dev)
 {
+	u32 rev = ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV;
+
 	/* The REJECT bit changed position in TMSLOW between
 	 * Backplane revisions. */
-	switch (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV) {
+	switch (rev) {
 	case SSB_IDLOW_SSBREV_22:
 		return SSB_TMSLOW_REJECT_22;
 	case SSB_IDLOW_SSBREV_23:
 		return SSB_TMSLOW_REJECT_23;
+	case SSB_IDLOW_SSBREV_24:     /* TODO - find the proper REJECT bits */
+	case SSB_IDLOW_SSBREV_27:     /* same here */
+		return SSB_TMSLOW_REJECT_23 | SSB_TMSLOW_REJECT_22;
 	default:
 		WARN_ON(1);
+		printk(KERN_INFO "ssb: Backplane Revision 0x%.8X\n", rev);
 	}
 	return (SSB_TMSLOW_REJECT_22 | SSB_TMSLOW_REJECT_23);
 }
Index: wireless-2.6/include/linux/ssb/ssb.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb.h
+++ wireless-2.6/include/linux/ssb/ssb.h
@@ -79,7 +79,39 @@ struct ssb_sprom_r3 {
 };
 
 struct ssb_sprom_r4 {
-	/* TODO */
+	u16 pci_spid;		/* Subsystem Product ID for PCI */
+	u16 pci_svid;		/* Subsystem Vendor ID for PCI */
+	u16 pci_pid;		/* Product ID for PCI */
+	u8 il0mac[6];		/* MAC address for 802.11b/g */
+	u8 et0mac[6];		/* MAC address for Ethernet */
+	u8 et1mac[6];		/* MAC address for 802.11a */
+	u8 et0phyaddr:5;	/* MII address for enet0 */
+	u8 et1phyaddr:5;	/* MII address for enet1 */
+	u8 et0mdcport:1;	/* MDIO for enet0 */
+	u8 et1mdcport:1;	/* MDIO for enet1 */
+	u8 board_rev;		/* Board revision */
+	u8 country_code:4;	/* Country Code */
+	u8 antenna_a:2;		/* Antenna 0/1 available for A-PHY */
+	u8 antenna_bg:2;	/* Antenna 0/1 available for B-PHY and G-PHY */
+	u16 pa0b0;
+	u16 pa0b1;
+	u16 pa0b2;
+	u16 pa1b0;
+	u16 pa1b1;
+	u16 pa1b2;
+	u8 gpio0;		/* GPIO pin 0 */
+	u8 gpio1;		/* GPIO pin 1 */
+	u8 gpio2;		/* GPIO pin 2 */
+	u8 gpio3;		/* GPIO pin 3 */
+	u16 maxpwr_a;		/* A-PHY Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_bg;		/* B/G-PHY Amplifier Max Power (in dBm Q5.2) */
+	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
+	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
+	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
+	u8 antenna_gain_a;	/* A-PHY Antenna gain (in dBm Q5.2) */
+	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
+	/* The variables above this point must match those of ssb_sprom_r1 */
+	/* TODO - add any special ssb_sprom_r4 variables below this point. */
 };
 
 struct ssb_sprom {
@@ -288,6 +320,7 @@ struct ssb_bus {
 	/* ID information about the Chip. */
 	u16 chip_id;
 	u16 chip_rev;
+	u16 sprom_size;		/* number of words in sprom */
 	u8 chip_package;
 
 	/* List of devices (cores) on the backplane. */


From stefano.brivio at polimi.it  Sat Nov  3 23:35:11 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Sat, 3 Nov 2007 23:35:11 +0100
Subject: b43legacy maintainer needed
In-Reply-To: <471D72A9.9060208@lwfinger.net>
References: <471D72A9.9060208@lwfinger.net>
Message-ID: <20071103233511.3daaeeaa@morte>

Hi Larry,

I happen to have some spare time right now and should have next months. As
I didn't hear about anybody interested in maintaining b43legacy, I started
with porting some patches from b43 from Michael.

In case I feel comfortable with this, and get sure that I'll have the
needed time for a reasonable number of months, I would be happy to maintain
b43legacy until you won't come back.

At the moment, I'll be sending patches back to Michael - who happens to
have a BCM4306/2 card - for testing, will let you know in some days if I
can go on with this and if I need your card.

Thank you for all the effort you put into this.


-- 
Ciao
Stefano


From larry.finger at lwfinger.net  Sat Nov  3 23:57:53 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 03 Nov 2007 17:57:53 -0500
Subject: b43legacy maintainer needed
In-Reply-To: <20071103233511.3daaeeaa@morte>
References: <471D72A9.9060208@lwfinger.net> <20071103233511.3daaeeaa@morte>
Message-ID: <472CFCF1.4070309@lwfinger.net>

Hi Stefano,

Stefano Brivio wrote:

> I happen to have some spare time right now and should have next months. As
> I didn't hear about anybody interested in maintaining b43legacy, I started
> with porting some patches from b43 from Michael.

That is good to hear.

> In case I feel comfortable with this, and get sure that I'll have the
> needed time for a reasonable number of months, I would be happy to maintain
> b43legacy until you won't come back.

I won't be able to come back as I'm "tainted" from looking at the decompiled Broadcom drivers.

> At the moment, I'll be sending patches back to Michael - who happens to
> have a BCM4306/2 card - for testing, will let you know in some days if I
> can go on with this and if I need your card.

I did most of my testing by including the following patch:

Index: linux-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/main.c
+++ linux-2.6/drivers/net/wireless/b43/main.c
@@ -100,7 +100,7 @@ static const struct ssb_device_id b43_ss
        SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 6),
        SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
        SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
-       SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
+//     SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
        SSB_DEVTABLE_END
 };

Index: linux-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ linux-2.6/drivers/net/wireless/b43legacy/main.c
@@ -95,6 +95,7 @@ MODULE_PARM_DESC(fwpostfix, "Postfix for
 static const struct ssb_device_id b43legacy_ssb_tbl[] = {
        SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 2),
        SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 4),
+       SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211,10),
        SSB_DEVTABLE_END
 };
 MODULE_DEVICE_TABLE(ssb, b43legacy_ssb_tbl);

This took my 4311 with and 802.11 core revision of 0xA out of the b43 table and added it to the
b43legacy table. You can do the same with whatever is your primary card; however, I will be happy to
send the BCM4306 card. Do you have access to a PCI-based desktop running Linux? If so, I also have a
Linksys WMP11-V27, which is a B-only device that belongs to the project.

> Thank you for all the effort you put into this.

It has been a lot of fun, and I hope to continue contributing to the specs rather than the driver,
as we get the later Broadcom devices working.

Larry



From stefano.brivio at polimi.it  Sun Nov  4 18:25:05 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Sun, 4 Nov 2007 18:25:05 +0100
Subject: [RFC] A PHY init rewrite
Message-ID: <20071104182505.0edd7ed6@morte>

Sync A PHY initialization code with specs, allowing further work on A PHY
support. Note: G PHY initialization is involved as well.

Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Please test. This could break badly 802.11g devices. It will give two
warnings about unused functions - that's known.


Index: wireless-2.6/drivers/net/wireless/b43/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/Makefile
+++ wireless-2.6/drivers/net/wireless/b43/Makefile
@@ -5,6 +5,7 @@ b43-y				+= phy.o
 b43-y				+= sysfs.o
 b43-y				+= xmit.o
 b43-y				+= lo.o
+b43-y				+= wa.o
 # b43 RFKILL button support
 b43-$(CONFIG_B43_RFKILL)	+= rfkill.o
 # b43 LED support
Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h
+++ wireless-2.6/drivers/net/wireless/b43/b43.h
@@ -542,6 +542,10 @@ struct b43_phy {
 	u16 lofcal;
 
 	u16 initval;		//FIXME rename?
+
+	/* OFDM address read/write caching for hardware auto-increment. */
+	u16 ofdm_addr;
+	u8 ofdm_valid; /* 0: invalid, 1: read, 2: write */
 };
 
 /* Data structures for DMA transmission, per 80211 core. */
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -2264,6 +2264,9 @@ static int b43_chip_init(struct b43_wlde
 	b43_write16(dev, B43_MMIO_POWERUP_DELAY,
 		    dev->dev->bus->chipco.fast_pwrup_delay);
 
+	/* OFDM address caching. */
+	phy->ofdm_valid = 0;
+
 	err = 0;
 	b43dbg(dev->wl, "Chip initialized\n");
 out:
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c
+++ wireless-2.6/drivers/net/wireless/b43/phy.c
@@ -34,6 +34,8 @@
 #include "main.h"
 #include "tables.h"
 #include "lo.h"
+#include "wa.h"
+
 
 static const s8 b43_tssi2dbm_b_table[] = {
 	0x4D, 0x4C, 0x4B, 0x4A,
@@ -303,7 +305,7 @@ void b43_phy_write(struct b43_wldev *dev
 	b43_write16(dev, B43_MMIO_PHY_DATA, val);
 }
 
-static void b43_radio_set_txpower_a(struct b43_wldev *dev, u16 txpower);
+static void b43_set_txpower_a(struct b43_wldev *dev, u16 txpower);
 
 /* Adjust the transmission power output (G-PHY) */
 void b43_set_txpower_g(struct b43_wldev *dev,
@@ -763,214 +765,6 @@ static void b43_phy_init_pctl(struct b43
 	b43_shm_clear_tssi(dev);
 }
 
-static void b43_phy_agcsetup(struct b43_wldev *dev)
-{
-	struct b43_phy *phy = &dev->phy;
-	u16 offset = 0x0000;
-
-	if (phy->rev == 1)
-		offset = 0x4C00;
-
-	b43_ofdmtab_write16(dev, offset, 0, 0x00FE);
-	b43_ofdmtab_write16(dev, offset, 1, 0x000D);
-	b43_ofdmtab_write16(dev, offset, 2, 0x0013);
-	b43_ofdmtab_write16(dev, offset, 3, 0x0019);
-
-	if (phy->rev == 1) {
-		b43_ofdmtab_write16(dev, 0x1800, 0, 0x2710);
-		b43_ofdmtab_write16(dev, 0x1801, 0, 0x9B83);
-		b43_ofdmtab_write16(dev, 0x1802, 0, 0x9B83);
-		b43_ofdmtab_write16(dev, 0x1803, 0, 0x0F8D);
-		b43_phy_write(dev, 0x0455, 0x0004);
-	}
-
-	b43_phy_write(dev, 0x04A5, (b43_phy_read(dev, 0x04A5)
-				    & 0x00FF) | 0x5700);
-	b43_phy_write(dev, 0x041A, (b43_phy_read(dev, 0x041A)
-				    & 0xFF80) | 0x000F);
-	b43_phy_write(dev, 0x041A, (b43_phy_read(dev, 0x041A)
-				    & 0xC07F) | 0x2B80);
-	b43_phy_write(dev, 0x048C, (b43_phy_read(dev, 0x048C)
-				    & 0xF0FF) | 0x0300);
-
-	b43_radio_write16(dev, 0x007A, b43_radio_read16(dev, 0x007A)
-			  | 0x0008);
-
-	b43_phy_write(dev, 0x04A0, (b43_phy_read(dev, 0x04A0)
-				    & 0xFFF0) | 0x0008);
-	b43_phy_write(dev, 0x04A1, (b43_phy_read(dev, 0x04A1)
-				    & 0xF0FF) | 0x0600);
-	b43_phy_write(dev, 0x04A2, (b43_phy_read(dev, 0x04A2)
-				    & 0xF0FF) | 0x0700);
-	b43_phy_write(dev, 0x04A0, (b43_phy_read(dev, 0x04A0)
-				    & 0xF0FF) | 0x0100);
-
-	if (phy->rev == 1) {
-		b43_phy_write(dev, 0x04A2, (b43_phy_read(dev, 0x04A2)
-					    & 0xFFF0) | 0x0007);
-	}
-
-	b43_phy_write(dev, 0x0488, (b43_phy_read(dev, 0x0488)
-				    & 0xFF00) | 0x001C);
-	b43_phy_write(dev, 0x0488, (b43_phy_read(dev, 0x0488)
-				    & 0xC0FF) | 0x0200);
-	b43_phy_write(dev, 0x0496, (b43_phy_read(dev, 0x0496)
-				    & 0xFF00) | 0x001C);
-	b43_phy_write(dev, 0x0489, (b43_phy_read(dev, 0x0489)
-				    & 0xFF00) | 0x0020);
-	b43_phy_write(dev, 0x0489, (b43_phy_read(dev, 0x0489)
-				    & 0xC0FF) | 0x0200);
-	b43_phy_write(dev, 0x0482, (b43_phy_read(dev, 0x0482)
-				    & 0xFF00) | 0x002E);
-	b43_phy_write(dev, 0x0496, (b43_phy_read(dev, 0x0496)
-				    & 0x00FF) | 0x1A00);
-	b43_phy_write(dev, 0x0481, (b43_phy_read(dev, 0x0481)
-				    & 0xFF00) | 0x0028);
-	b43_phy_write(dev, 0x0481, (b43_phy_read(dev, 0x0481)
-				    & 0x00FF) | 0x2C00);
-
-	if (phy->rev == 1) {
-		b43_phy_write(dev, 0x0430, 0x092B);
-		b43_phy_write(dev, 0x041B, (b43_phy_read(dev, 0x041B)
-					    & 0xFFE1) | 0x0002);
-	} else {
-		b43_phy_write(dev, 0x041B, b43_phy_read(dev, 0x041B)
-			      & 0xFFE1);
-		b43_phy_write(dev, 0x041F, 0x287A);
-		b43_phy_write(dev, 0x0420, (b43_phy_read(dev, 0x0420)
-					    & 0xFFF0) | 0x0004);
-	}
-
-	if (phy->rev >= 6) {
-		b43_phy_write(dev, 0x0422, 0x287A);
-		b43_phy_write(dev, 0x0420, (b43_phy_read(dev, 0x0420)
-					    & 0x0FFF) | 0x3000);
-	}
-
-	b43_phy_write(dev, 0x04A8, (b43_phy_read(dev, 0x04A8)
-				    & 0x8080) | 0x7874);
-	b43_phy_write(dev, 0x048E, 0x1C00);
-
-	offset = 0x0800;
-	if (phy->rev == 1) {
-		offset = 0x5400;
-		b43_phy_write(dev, 0x04AB, (b43_phy_read(dev, 0x04AB)
-					    & 0xF0FF) | 0x0600);
-		b43_phy_write(dev, 0x048B, 0x005E);
-		b43_phy_write(dev, 0x048C, (b43_phy_read(dev, 0x048C)
-					    & 0xFF00) | 0x001E);
-		b43_phy_write(dev, 0x048D, 0x0002);
-	}
-	b43_ofdmtab_write16(dev, offset, 0, 0x00);
-	b43_ofdmtab_write16(dev, offset, 1, 0x07);
-	b43_ofdmtab_write16(dev, offset, 2, 0x10);
-	b43_ofdmtab_write16(dev, offset, 3, 0x1C);
-
-	if (phy->rev >= 6) {
-		b43_phy_write(dev, 0x0426, b43_phy_read(dev, 0x0426)
-			      & 0xFFFC);
-		b43_phy_write(dev, 0x0426, b43_phy_read(dev, 0x0426)
-			      & 0xEFFF);
-	}
-}
-
-static void b43_phy_setupg(struct b43_wldev *dev)
-{
-	struct ssb_bus *bus = dev->dev->bus;
-	struct b43_phy *phy = &dev->phy;
-	u16 i;
-
-	B43_WARN_ON(phy->type != B43_PHYTYPE_G);
-	if (phy->rev == 1) {
-		b43_phy_write(dev, 0x0406, 0x4F19);
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      (b43_phy_read(dev, B43_PHY_G_CRS) & 0xFC3F) |
-			      0x0340);
-		b43_phy_write(dev, 0x042C, 0x005A);
-		b43_phy_write(dev, 0x0427, 0x001A);
-
-		for (i = 0; i < B43_TAB_FINEFREQG_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x5800, i,
-					    b43_tab_finefreqg[i]);
-		for (i = 0; i < B43_TAB_NOISEG1_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1800, i, b43_tab_noiseg1[i]);
-		for (i = 0; i < B43_TAB_ROTOR_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x2000, i, b43_tab_rotor[i]);
-	} else {
-		/* nrssi values are signed 6-bit values. Not sure why we write 0x7654 here... */
-		b43_nrssi_hw_write(dev, 0xBA98, (s16) 0x7654);
-
-		if (phy->rev == 2) {
-			b43_phy_write(dev, 0x04C0, 0x1861);
-			b43_phy_write(dev, 0x04C1, 0x0271);
-		} else if (phy->rev > 2) {
-			b43_phy_write(dev, 0x04C0, 0x0098);
-			b43_phy_write(dev, 0x04C1, 0x0070);
-			b43_phy_write(dev, 0x04C9, 0x0080);
-		}
-		b43_phy_write(dev, 0x042B, b43_phy_read(dev, 0x042B) | 0x800);
-
-		for (i = 0; i < 64; i++)
-			b43_ofdmtab_write16(dev, 0x4000, i, i);
-		for (i = 0; i < B43_TAB_NOISEG2_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1800, i, b43_tab_noiseg2[i]);
-	}
-
-	if (phy->rev <= 2)
-		for (i = 0; i < B43_TAB_NOISESCALEG_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1400, i,
-					    b43_tab_noisescaleg1[i]);
-	else if ((phy->rev >= 7) && (b43_phy_read(dev, 0x0449) & 0x0200))
-		for (i = 0; i < B43_TAB_NOISESCALEG_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1400, i,
-					    b43_tab_noisescaleg3[i]);
-	else
-		for (i = 0; i < B43_TAB_NOISESCALEG_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1400, i,
-					    b43_tab_noisescaleg2[i]);
-
-	if (phy->rev == 2)
-		for (i = 0; i < B43_TAB_SIGMASQR_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x5000, i,
-					    b43_tab_sigmasqr1[i]);
-	else if ((phy->rev > 2) && (phy->rev <= 8))
-		for (i = 0; i < B43_TAB_SIGMASQR_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x5000, i,
-					    b43_tab_sigmasqr2[i]);
-
-	if (phy->rev == 1) {
-		for (i = 0; i < B43_TAB_RETARD_SIZE; i++)
-			b43_ofdmtab_write32(dev, 0x2400, i, b43_tab_retard[i]);
-		for (i = 4; i < 20; i++)
-			b43_ofdmtab_write16(dev, 0x5400, i, 0x0020);
-		b43_phy_agcsetup(dev);
-
-		if ((bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM) &&
-		    (bus->boardinfo.type == SSB_BOARD_BU4306) &&
-		    (bus->boardinfo.rev == 0x17))
-			return;
-
-		b43_ofdmtab_write16(dev, 0x5001, 0, 0x0002);
-		b43_ofdmtab_write16(dev, 0x5002, 0, 0x0001);
-	} else {
-		for (i = 0; i < 0x20; i++)
-			b43_ofdmtab_write16(dev, 0x1000, i, 0x0820);
-		b43_phy_agcsetup(dev);
-		b43_phy_read(dev, 0x0400);	/* dummy read */
-		b43_phy_write(dev, 0x0403, 0x1000);
-		b43_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
-		b43_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
-
-		if ((bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM) &&
-		    (bus->boardinfo.type == SSB_BOARD_BU4306) &&
-		    (bus->boardinfo.rev == 0x17))
-			return;
-
-		b43_ofdmtab_write16(dev, 0x0401, 0, 0x0002);
-		b43_ofdmtab_write16(dev, 0x0402, 0, 0x0001);
-	}
-}
-
 /* Initialize the noisescaletable for APHY */
 static void b43_phy_init_noisescaletbl(struct b43_wldev *dev)
 {
@@ -999,195 +793,151 @@ static void b43_phy_init_noisescaletbl(s
 		b43_ofdmtab_write16(dev, 0x1400, i, 0x0023);
 }
 
-static void b43_phy_setupa(struct b43_wldev *dev)
+static void b43_phy_rssiagc(struct b43_wldev *dev, u8 enable)
 {
-	struct b43_phy *phy = &dev->phy;
-	u16 i;
-
-	B43_WARN_ON(phy->type != B43_PHYTYPE_A);
-	switch (phy->rev) {
-	case 2:
-		b43_phy_write(dev, 0x008E, 0x3800);
-		b43_phy_write(dev, 0x0035, 0x03FF);
-		b43_phy_write(dev, 0x0036, 0x0400);
-
-		b43_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-		b43_phy_write(dev, 0x001C, 0x0FF9);
-		b43_phy_write(dev, 0x0020, b43_phy_read(dev, 0x0020) & 0xFF0F);
-		b43_ofdmtab_write16(dev, 0x3C0C, 0, 0x07BF);
-		b43_radio_write16(dev, 0x0002, 0x07BF);
-
-		b43_phy_write(dev, 0x0024, 0x4680);
-		b43_phy_write(dev, 0x0020, 0x0003);
-		b43_phy_write(dev, 0x001D, 0x0F40);
-		b43_phy_write(dev, 0x001F, 0x1C00);
-
-		b43_phy_write(dev, 0x002A, (b43_phy_read(dev, 0x002A)
-					    & 0x00FF) | 0x0400);
-		b43_phy_write(dev, 0x002B, b43_phy_read(dev, 0x002B)
-			      & 0xFBFF);
-		b43_phy_write(dev, 0x008E, 0x58C1);
-
-		b43_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
-		b43_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
-		b43_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-		b43_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-		b43_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
-
-		b43_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0000, 1, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0000, 2, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0000, 3, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0000, 4, 0x0015);
-		b43_ofdmtab_write16(dev, 0x0000, 5, 0x0015);
-		b43_ofdmtab_write16(dev, 0x0000, 6, 0x0019);
-
-		b43_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
-		b43_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
-		b43_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
-
-		for (i = 0; i < 16; i++)
-			b43_ofdmtab_write16(dev, 0x4000, i, (0x8 + i) & 0x000F);
-
-		b43_ofdmtab_write16(dev, 0x3003, 0, 0x1044);
-		b43_ofdmtab_write16(dev, 0x3004, 0, 0x7201);
-		b43_ofdmtab_write16(dev, 0x3006, 0, 0x0040);
-		b43_ofdmtab_write16(dev, 0x3001, 0,
-				    (b43_ofdmtab_read16(dev, 0x3001, 0) &
-				     0x0010) | 0x0008);
-
-		for (i = 0; i < B43_TAB_FINEFREQA_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x5800, i,
-					    b43_tab_finefreqa[i]);
-		for (i = 0; i < B43_TAB_NOISEA2_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1800, i, b43_tab_noisea2[i]);
-		for (i = 0; i < B43_TAB_ROTOR_SIZE; i++)
-			b43_ofdmtab_write32(dev, 0x2000, i, b43_tab_rotor[i]);
-		b43_phy_init_noisescaletbl(dev);
-		for (i = 0; i < B43_TAB_RETARD_SIZE; i++)
-			b43_ofdmtab_write32(dev, 0x2400, i, b43_tab_retard[i]);
-		break;
-	case 3:
-		for (i = 0; i < 64; i++)
-			b43_ofdmtab_write16(dev, 0x4000, i, i);
-
-		b43_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-		b43_phy_write(dev, 0x001C, 0x0FF9);
-		b43_phy_write(dev, 0x0020, b43_phy_read(dev, 0x0020) & 0xFF0F);
-		b43_radio_write16(dev, 0x0002, 0x07BF);
-
-		b43_phy_write(dev, 0x0024, 0x4680);
-		b43_phy_write(dev, 0x0020, 0x0003);
-		b43_phy_write(dev, 0x001D, 0x0F40);
-		b43_phy_write(dev, 0x001F, 0x1C00);
-		b43_phy_write(dev, 0x002A, (b43_phy_read(dev, 0x002A)
-					    & 0x00FF) | 0x0400);
-
-		b43_ofdmtab_write16(dev, 0x3000, 1,
-				    (b43_ofdmtab_read16(dev, 0x3000, 1)
-				     & 0x0010) | 0x0008);
-		for (i = 0; i < B43_TAB_NOISEA3_SIZE; i++) {
-			b43_ofdmtab_write16(dev, 0x1800, i, b43_tab_noisea3[i]);
-		}
-		b43_phy_init_noisescaletbl(dev);
-		for (i = 0; i < B43_TAB_SIGMASQR_SIZE; i++) {
-			b43_ofdmtab_write16(dev, 0x5000, i,
-					    b43_tab_sigmasqr1[i]);
-		}
-
-		b43_phy_write(dev, 0x0003, 0x1808);
-
-		b43_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
-		b43_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
-		b43_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-		b43_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-		b43_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
-
-		b43_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0001, 0, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0002, 0, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0003, 0, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0004, 0, 0x0015);
-		b43_ofdmtab_write16(dev, 0x0005, 0, 0x0015);
-		b43_ofdmtab_write16(dev, 0x0006, 0, 0x0019);
-
-		b43_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
-		b43_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
-		b43_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
+	int i;
 
-		b43_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
-		b43_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
-		break;
-	default:
-		B43_WARN_ON(1);
+	if (dev->phy.rev < 3) {
+		if (enable)
+			for (i = 0; i < B43_TAB_RSSIAGC1_SIZE; i++) {
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_LNAHPFGAIN1, i, 0xFFF8);
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_WRSSI, i, 0xFFF8);
+			}
+		else
+			for (i = 0; i < B43_TAB_RSSIAGC1_SIZE; i++) {
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_LNAHPFGAIN1, i, b43_tab_rssiagc1[i]);
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_WRSSI, i, b43_tab_rssiagc1[i]);
+			}
+	} else {
+		if (enable)
+			for (i = 0; i < B43_TAB_RSSIAGC1_SIZE; i++)
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_WRSSI, i, 0x0820);
+		else
+			for (i = 0; i < B43_TAB_RSSIAGC2_SIZE; i++)
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_WRSSI, i, b43_tab_rssiagc2[i]);
 	}
 }
 
+static void b43_phy_ww(struct b43_wldev *dev)
+{
+	u16 b, curr_s, best_s = 0xFFFF;
+	int i;
+
+	b43_phy_write(dev, B43_PHY_CRS0,
+		b43_phy_read(dev, B43_PHY_CRS0) & ~B43_PHY_CRS0_EN);
+	b43_phy_write(dev, B43_PHY_OFDM(0x1B),
+		b43_phy_read(dev, B43_PHY_OFDM(0x1B)) | 0x1000);
+	b43_phy_write(dev, B43_PHY_OFDM(0x82),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x82)) & 0xF0FF) | 0x0300);
+	b43_radio_write16(dev, 0x0009,
+		b43_radio_read16(dev, 0x0009) | 0x0080);
+	b43_radio_write16(dev, 0x0012,
+		(b43_radio_read16(dev, 0x0012) & 0xFFFC) | 0x0002);
+	b43_wa_initgains(dev);
+	b43_phy_write(dev, B43_PHY_OFDM(0xBA), 0x3ED5);
+	b = b43_phy_read(dev, B43_PHY_PWRDOWN);
+	b43_phy_write(dev, B43_PHY_PWRDOWN, (b & 0xFFF8) | 0x0005);
+	b43_radio_write16(dev, 0x0004,
+		b43_radio_read16(dev, 0x0004) | 0x0004);
+	for (i = 0x10; i <= 0x20; i++) {
+		b43_radio_write16(dev, 0x0013, i);
+		curr_s = b43_phy_read(dev, B43_PHY_OTABLEQ) & 0x00FF;
+		if (!curr_s) {
+			best_s = 0x0000;
+			break;
+		} else if (curr_s >= 0x0080)
+			curr_s = 0x0100 - curr_s;
+		if (curr_s < best_s)
+			best_s = curr_s;
+	}
+	b43_phy_write(dev, B43_PHY_PWRDOWN, b);
+	b43_radio_write16(dev, 0x0004,
+		b43_radio_read16(dev, 0x0004) & 0xFFFB);
+	b43_radio_write16(dev, 0x0013, best_s);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 0, 0xFFEC);
+	b43_phy_write(dev, B43_PHY_OFDM(0xB7), 0x1E80);
+	b43_phy_write(dev, B43_PHY_OFDM(0xB6), 0x1C00);
+	b43_phy_write(dev, B43_PHY_OFDM(0xB5), 0x0EC0);
+	b43_phy_write(dev, B43_PHY_OFDM(0xB2), 0x00C0);
+	b43_phy_write(dev, B43_PHY_OFDM(0xB9), 0x1FFF);
+	b43_phy_write(dev, B43_PHY_OFDM(0xBB),
+		(b43_phy_read(dev, B43_PHY_OFDM(0xBB)) & 0xF000) | 0x0053);
+	b43_phy_write(dev, B43_PHY_OFDM61,
+		(b43_phy_read(dev, B43_PHY_OFDM61 & 0xFE1F)) | 0x0120);
+	b43_phy_write(dev, B43_PHY_OFDM(0x13),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x13)) & 0x0FFF) | 0x3000);
+	b43_phy_write(dev, B43_PHY_OFDM(0x14),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x14)) & 0x0FFF) | 0x3000);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 6, 0x0017);
+	for (i = 0; i < 6; i++)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, i, 0x000F);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0D, 0x000E);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0E, 0x0011);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0F, 0x0013);
+	b43_phy_write(dev, B43_PHY_OFDM(0x33), 0x5030);
+	b43_phy_write(dev, B43_PHY_CRS0,
+		b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
+}
+
 /* Initialize APHY. This is also called for the GPHY in some cases. */
 static void b43_phy_inita(struct b43_wldev *dev)
 {
 	struct ssb_bus *bus = dev->dev->bus;
 	struct b43_phy *phy = &dev->phy;
-	u16 tval;
 
 	might_sleep();
 
+	if (phy->rev >= 6) {
+		if (phy->type == B43_PHYTYPE_A)
+			b43_phy_write(dev, B43_PHY_OFDM(0x1B),
+				b43_phy_read(dev, B43_PHY_OFDM(0x1B)) & ~0x1000);
+		if (b43_phy_read(dev, B43_PHY_ENCORE) & B43_PHY_ENCORE_EN)
+			b43_phy_write(dev, B43_PHY_ENCORE,
+				b43_phy_read(dev, B43_PHY_ENCORE) | 0x0010);
+		else
+			b43_phy_write(dev, B43_PHY_ENCORE,
+				b43_phy_read(dev, B43_PHY_ENCORE) & ~0x1010);
+ 	}
+
+	b43_wa_all(dev);
+
 	if (phy->type == B43_PHYTYPE_A) {
-		b43_phy_setupa(dev);
-	} else {
-		b43_phy_setupg(dev);
-		if (phy->gmode &&
-		    (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL))
-			b43_phy_write(dev, 0x046E, 0x03CF);
-		return;
-	}
+		if (phy->gmode && (phy->rev < 3))
+			b43_phy_write(dev, 0x0034,
+				b43_phy_read(dev, 0x0034) | 0x0001);
+ 		b43_phy_rssiagc(dev, 0);
 
-	b43_phy_write(dev, B43_PHY_A_CRS,
-		      (b43_phy_read(dev, B43_PHY_A_CRS) & 0xF83C) | 0x0340);
-	b43_phy_write(dev, 0x0034, 0x0001);
-
-	//TODO: RSSI AGC
-	b43_phy_write(dev, B43_PHY_A_CRS,
-		      b43_phy_read(dev, B43_PHY_A_CRS) | (1 << 14));
-	b43_radio_init2060(dev);
+		b43_phy_write(dev, B43_PHY_CRS0,
+			b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
 
-	if ((bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM) &&
-	    ((bus->boardinfo.type == SSB_BOARD_BU4306) ||
-	     (bus->boardinfo.type == SSB_BOARD_BU4309))) {
-		if (phy->lofcal == 0xFFFF) {
-			//TODO: LOF Cal
-			b43_radio_set_tx_iq(dev);
-		} else
-			b43_radio_write16(dev, 0x001E, phy->lofcal);
-	}
+		b43_radio_init2060(dev);
 
-	b43_phy_write(dev, 0x007A, 0xF111);
+		if ((bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM) &&
+		    ((bus->boardinfo.type == SSB_BOARD_BU4306) ||
+		     (bus->boardinfo.type == SSB_BOARD_BU4309))) {
+		     	; //TODO: A PHY LO
+ 		}
 
-	if (phy->cur_idle_tssi == 0) {
-		b43_radio_write16(dev, 0x0019, 0x0000);
-		b43_radio_write16(dev, 0x0017, 0x0020);
+		if (phy->rev >= 3)
+			b43_phy_ww(dev);
 
-		tval = b43_ofdmtab_read16(dev, 0x3001, 0);
-		if (phy->rev == 1) {
-			b43_ofdmtab_write16(dev, 0x3001, 0,
-					    (b43_ofdmtab_read16(dev, 0x3001, 0)
-					     & 0xFF87)
-					    | 0x0058);
-		} else {
-			b43_ofdmtab_write16(dev, 0x3001, 0,
-					    (b43_ofdmtab_read16(dev, 0x3001, 0)
-					     & 0xFFC3)
-					    | 0x002C);
-		}
-		b43_dummy_transmission(dev);
-		phy->cur_idle_tssi = b43_phy_read(dev, B43_PHY_A_PCTL);
-		b43_ofdmtab_write16(dev, 0x3001, 0, tval);
+		hardware_pctl_init_aphy(dev);
 
-		b43_radio_set_txpower_a(dev, 0x0018);
+		//TODO: radar detection
 	}
-	b43_shm_clear_tssi(dev);
+
+	if ((phy->type == B43_PHYTYPE_G) &&
+	    (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL)) {
+		b43_phy_write(dev, B43_PHY_OFDM(0x6E),
+				  (b43_phy_read(dev, B43_PHY_OFDM(0x6E))
+				   & 0xE000) | 0x3CF);
+ 	}
 }
 
 static void b43_phy_initb2(struct b43_wldev *dev)
@@ -4277,7 +4027,7 @@ static u16 b43_get_txgain_dac(u16 txpowe
 	return ret;
 }
 
-static void b43_radio_set_txpower_a(struct b43_wldev *dev, u16 txpower)
+static void b43_set_txpower_a(struct b43_wldev *dev, u16 txpower)
 {
 	struct b43_phy *phy = &dev->phy;
 	u16 pamp, base, dac, t;
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h
+++ wireless-2.6/drivers/net/wireless/b43/phy.h
@@ -27,8 +27,11 @@ struct b43_phy;
 #define B43_PHY_PWRDOWN			B43_PHY_OFDM(0x03)	/* Powerdown */
 #define B43_PHY_CRSTHRES1		B43_PHY_OFDM(0x06)	/* CRS Threshold 1 */
 #define B43_PHY_LNAHPFCTL		B43_PHY_OFDM(0x1C)	/* LNA/HPF control */
+#define B43_PHY_LPFGAINCTL		B43_PHY_OFDM(0x20)	/* LPF Gain control */
 #define B43_PHY_ADIVRELATED		B43_PHY_OFDM(0x27)	/* FIXME rename */
 #define B43_PHY_CRS0			B43_PHY_OFDM(0x29)
+#define  B43_PHY_CRS0_EN		0x4000
+#define B43_PHY_PEAK_COUNT		B43_PHY_OFDM(0x30)
 #define B43_PHY_ANTDWELL		B43_PHY_OFDM(0x2B)	/* Antenna dwell */
 #define  B43_PHY_ANTDWELL_AUTODIV1	0x0100	/* Automatic RX diversity start antenna */
 #define B43_PHY_ENCORE			B43_PHY_OFDM(0x49)	/* "Encore" (RangeMax / BroadRange) */
@@ -37,6 +40,7 @@ struct b43_phy;
 #define B43_PHY_OFDM61			B43_PHY_OFDM(0x61)	/* FIXME rename */
 #define  B43_PHY_OFDM61_10		0x0010	/* FIXME rename */
 #define B43_PHY_IQBAL			B43_PHY_OFDM(0x69)	/* I/Q balance */
+#define B43_PHY_BBTXDC_BIAS		B43_PHY_OFDM(0x6B)	/* Baseband TX DC bias */
 #define B43_PHY_OTABLECTL		B43_PHY_OFDM(0x72)	/* OFDM table control (see below) */
 #define  B43_PHY_OTABLEOFF		0x03FF	/* OFDM table offset (see below) */
 #define  B43_PHY_OTABLENR		0xFC00	/* OFDM table number (see below) */
@@ -44,6 +48,9 @@ struct b43_phy;
 #define B43_PHY_OTABLEI			B43_PHY_OFDM(0x73)	/* OFDM table data I */
 #define B43_PHY_OTABLEQ			B43_PHY_OFDM(0x74)	/* OFDM table data Q */
 #define B43_PHY_HPWR_TSSICTL		B43_PHY_OFDM(0x78)	/* Hardware power TSSI control */
+#define B43_PHY_ADCCTL			B43_PHY_OFDM(0x7A)	/* ADC control */
+#define B43_PHY_IDLE_TSSI		B43_PHY_OFDM(0x7B)
+#define B43_PHY_A_TEMP_SENSE		B43_PHY_OFDM(0x7C)	/* A PHY temperature sense */
 #define B43_PHY_NRSSITHRES		B43_PHY_OFDM(0x8A)	/* NRSSI threshold */
 #define B43_PHY_ANTWRSETT		B43_PHY_OFDM(0x8C)	/* Antenna WR settle */
 #define  B43_PHY_ANTWRSETT_ARXDIV	0x2000	/* Automatic RX diversity enabled */
@@ -54,6 +61,8 @@ struct b43_phy;
 #define B43_PHY_N1N2GAIN		B43_PHY_OFDM(0xA2)
 #define B43_PHY_CLIPTHRES		B43_PHY_OFDM(0xA3)
 #define B43_PHY_CLIPN1P2THRES		B43_PHY_OFDM(0xA4)
+#define B43_PHY_CCKSHIFTBITS_WA		B43_PHY_OFDM(0xA5)	/* CCK shiftbits workaround, FIXME rename */
+#define B43_PHY_CCKSHIFTBITS		B43_PHY_OFDM(0xA7)	/* FIXME rename */
 #define B43_PHY_DIVSRCHIDX		B43_PHY_OFDM(0xA8)	/* Divider search gain/index */
 #define B43_PHY_CLIPP2THRES		B43_PHY_OFDM(0xA9)
 #define B43_PHY_CLIPP3THRES		B43_PHY_OFDM(0xAA)
@@ -125,13 +134,14 @@ struct b43_phy;
 #define B43_OFDMTAB_DC			B43_OFDMTAB(0x0E, 7)
 #define B43_OFDMTAB_PWRDYN2		B43_OFDMTAB(0x0E, 12)
 #define B43_OFDMTAB_LNAGAIN		B43_OFDMTAB(0x0E, 13)
-//TODO
+#define B43_OFDMTAB_UNKNOWN_0F		B43_OFDMTAB(0x0F, 0)	//TODO rename
+#define B43_OFDMTAB_UNKNOWN_APHY	B43_OFDMTAB(0x0F, 7)	//TODO rename
 #define B43_OFDMTAB_LPFGAIN		B43_OFDMTAB(0x0F, 12)
 #define B43_OFDMTAB_RSSI		B43_OFDMTAB(0x10, 0)
-//TODO
+#define B43_OFDMTAB_UNKNOWN_11		B43_OFDMTAB(0x11, 4)	//TODO rename
 #define B43_OFDMTAB_AGC1_R1		B43_OFDMTAB(0x13, 0)
-#define B43_OFDMTAB_GAINX_R1		B43_OFDMTAB(0x14, 0)	//TODO rename
-#define B43_OFDMTAB_MINSIGSQ		B43_OFDMTAB(0x14, 1)
+#define B43_OFDMTAB_GAINX_R1		B43_OFDMTAB(0x14, 0)	//TODO remove!
+#define B43_OFDMTAB_MINSIGSQ		B43_OFDMTAB(0x14, 0)
 #define B43_OFDMTAB_AGC3_R1		B43_OFDMTAB(0x15, 0)
 #define B43_OFDMTAB_WRSSI_R1		B43_OFDMTAB(0x15, 4)
 #define B43_OFDMTAB_TSSI		B43_OFDMTAB(0x15, 0)
Index: wireless-2.6/drivers/net/wireless/b43/tables.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/tables.c
+++ wireless-2.6/drivers/net/wireless/b43/tables.c
@@ -229,7 +229,7 @@ const u16 b43_tab_noisea2[] = {
 };
 
 const u16 b43_tab_noisea3[] = {
-	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
+	0x5E5E, 0x5E5E, 0x5E5E, 0x3F48,
 	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
 };
 
@@ -243,6 +243,26 @@ const u16 b43_tab_noiseg2[] = {
 	0x0000, 0x0000, 0x0000, 0x0000,
 };
 
+const u16 b43_tab_noisescalea2[] = {
+	0x6767, 0x6767, 0x6767, 0x6767, /* 0 */
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6700, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x6767, 0x6767, /* 16 */
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x0067,
+};
+
+const u16 b43_tab_noisescalea3[] = {
+	0x2323, 0x2323, 0x2323, 0x2323, /* 0 */
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2300, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x2323, 0x2323, /* 16 */
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x0023,
+};
+
 const u16 b43_tab_noisescaleg1[] = {
 	0x6C77, 0x5162, 0x3B40, 0x3335,	/* 0 */
 	0x2F2D, 0x2A2A, 0x2527, 0x1F21,
@@ -254,7 +274,7 @@ const u16 b43_tab_noisescaleg1[] = {
 };
 
 const u16 b43_tab_noisescaleg2[] = {
-	0xD8DD, 0xCBD4, 0xBCC0, 0XB6B7,	/* 0 */
+	0xD8DD, 0xCBD4, 0xBCC0, 0xB6B7,	/* 0 */
 	0xB2B0, 0xADAD, 0xA7A9, 0x9FA1,
 	0x969B, 0x9195, 0x8F8F, 0x8A8A,
 	0x8A8A, 0x8A00, 0x8A8A, 0x8F8A,
@@ -307,6 +327,28 @@ const u16 b43_tab_sigmasqr2[] = {
 	0x00DE,
 };
 
+const u16 b43_tab_rssiagc1[] = {
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8, /* 0 */
+	0xFFF8, 0xFFF9, 0xFFFC, 0xFFFE,
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+};
+
+const u16 b43_tab_rssiagc2[] = {
+	0x0820, 0x0820, 0x0920, 0x0C38, /* 0 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38, /* 16 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38, /* 32 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+};
+
 static inline void assert_sizes(void)
 {
 	BUILD_BUG_ON(B43_TAB_ROTOR_SIZE != ARRAY_SIZE(b43_tab_rotor));
@@ -317,36 +359,65 @@ static inline void assert_sizes(void)
 	BUILD_BUG_ON(B43_TAB_NOISEA3_SIZE != ARRAY_SIZE(b43_tab_noisea3));
 	BUILD_BUG_ON(B43_TAB_NOISEG1_SIZE != ARRAY_SIZE(b43_tab_noiseg1));
 	BUILD_BUG_ON(B43_TAB_NOISEG2_SIZE != ARRAY_SIZE(b43_tab_noiseg2));
-	BUILD_BUG_ON(B43_TAB_NOISESCALEG_SIZE !=
+	BUILD_BUG_ON(B43_TAB_NOISESCALE_SIZE !=
+		     ARRAY_SIZE(b43_tab_noisescalea2));
+	BUILD_BUG_ON(B43_TAB_NOISESCALE_SIZE !=
+		     ARRAY_SIZE(b43_tab_noisescalea3));
+	BUILD_BUG_ON(B43_TAB_NOISESCALE_SIZE !=
 		     ARRAY_SIZE(b43_tab_noisescaleg1));
-	BUILD_BUG_ON(B43_TAB_NOISESCALEG_SIZE !=
+	BUILD_BUG_ON(B43_TAB_NOISESCALE_SIZE !=
 		     ARRAY_SIZE(b43_tab_noisescaleg2));
-	BUILD_BUG_ON(B43_TAB_NOISESCALEG_SIZE !=
+	BUILD_BUG_ON(B43_TAB_NOISESCALE_SIZE !=
 		     ARRAY_SIZE(b43_tab_noisescaleg3));
 	BUILD_BUG_ON(B43_TAB_SIGMASQR_SIZE != ARRAY_SIZE(b43_tab_sigmasqr1));
 	BUILD_BUG_ON(B43_TAB_SIGMASQR_SIZE != ARRAY_SIZE(b43_tab_sigmasqr2));
+	BUILD_BUG_ON(B43_TAB_RSSIAGC1_SIZE != ARRAY_SIZE(b43_tab_rssiagc1));
+	BUILD_BUG_ON(B43_TAB_RSSIAGC2_SIZE != ARRAY_SIZE(b43_tab_rssiagc2));
 }
 
 u16 b43_ofdmtab_read16(struct b43_wldev *dev, u16 table, u16 offset)
 {
-	assert_sizes();
+	struct b43_phy *phy = &dev->phy;
+	u16 addr;
+
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+		b43_phy_write(dev, B43_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 1;
+	}
+	phy->ofdm_addr = addr;
 
-	b43_phy_write(dev, B43_PHY_OTABLECTL, table + offset);
 	return b43_phy_read(dev, B43_PHY_OTABLEI);
+	assert_sizes();
 }
 
 void b43_ofdmtab_write16(struct b43_wldev *dev, u16 table,
 			 u16 offset, u16 value)
 {
-	b43_phy_write(dev, B43_PHY_OTABLECTL, table + offset);
+	struct b43_phy *phy = &dev->phy;
+	u16 addr;
+
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
+		b43_phy_write(dev, B43_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 2;
+	}
+	phy->ofdm_addr = addr;
 	b43_phy_write(dev, B43_PHY_OTABLEI, value);
 }
 
 u32 b43_ofdmtab_read32(struct b43_wldev *dev, u16 table, u16 offset)
 {
+	struct b43_phy *phy = &dev->phy;
 	u32 ret;
+	u16 addr;
 
-	b43_phy_write(dev, B43_PHY_OTABLECTL, table + offset);
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+		b43_phy_write(dev, B43_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 1;
+	}
+	phy->ofdm_addr = addr;
 	ret = b43_phy_read(dev, B43_PHY_OTABLEQ);
 	ret <<= 16;
 	ret |= b43_phy_read(dev, B43_PHY_OTABLEI);
@@ -357,9 +428,17 @@ u32 b43_ofdmtab_read32(struct b43_wldev 
 void b43_ofdmtab_write32(struct b43_wldev *dev, u16 table,
 			 u16 offset, u32 value)
 {
-	b43_phy_write(dev, B43_PHY_OTABLECTL, table + offset);
+	struct b43_phy *phy = &dev->phy;
+	u16 addr;
+
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
+		b43_phy_write(dev, B43_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 2;
+	}
+	phy->ofdm_addr = addr;
+
 	b43_phy_write(dev, B43_PHY_OTABLEI, value);
-	b43_phy_write(dev, B43_PHY_OTABLEQ, (value >> 16));
 }
 
 u16 b43_gtab_read(struct b43_wldev *dev, u16 table, u16 offset)
Index: wireless-2.6/drivers/net/wireless/b43/tables.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/tables.h
+++ wireless-2.6/drivers/net/wireless/b43/tables.h
@@ -1,9 +1,9 @@
 #ifndef B43_TABLES_H_
 #define B43_TABLES_H_
 
-#define B43_TAB_ROTOR_SIZE		53
+#define B43_TAB_ROTOR_SIZE	53
 extern const u32 b43_tab_rotor[];
-#define B43_TAB_RETARD_SIZE		53
+#define B43_TAB_RETARD_SIZE	53
 extern const u32 b43_tab_retard[];
 #define B43_TAB_FINEFREQA_SIZE	256
 extern const u16 b43_tab_finefreqa[];
@@ -17,12 +17,18 @@ extern const u16 b43_tab_noisea3[];
 extern const u16 b43_tab_noiseg1[];
 #define B43_TAB_NOISEG2_SIZE	8
 extern const u16 b43_tab_noiseg2[];
-#define B43_TAB_NOISESCALEG_SIZE	27
+#define B43_TAB_NOISESCALE_SIZE	27
+extern const u16 b43_tab_noisescalea2[];
+extern const u16 b43_tab_noisescalea3[];
 extern const u16 b43_tab_noisescaleg1[];
 extern const u16 b43_tab_noisescaleg2[];
 extern const u16 b43_tab_noisescaleg3[];
 #define B43_TAB_SIGMASQR_SIZE	53
 extern const u16 b43_tab_sigmasqr1[];
 extern const u16 b43_tab_sigmasqr2[];
+#define B43_TAB_RSSIAGC1_SIZE	16
+extern const u16 b43_tab_rssiagc1[];
+#define B43_TAB_RSSIAGC2_SIZE	48
+extern const u16 b43_tab_rssiagc2[];
 
 #endif /* B43_TABLES_H_ */
Index: wireless-2.6/drivers/net/wireless/b43/wa.c
===================================================================
--- /dev/null
+++ wireless-2.6/drivers/net/wireless/b43/wa.c
@@ -0,0 +1,668 @@
+/*
+
+  Broadcom B43 wireless driver
+
+  PHY workarounds.
+
+  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
+  Copyright (c) 2005-2007 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de>
+  Copyright (c) 2005, 2006 Danny van Dyk <kugelfang at gentoo.org>
+  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+
+*/
+
+#include "b43.h"
+#include "main.h"
+#include "tables.h"
+#include "phy.h"
+#include "wa.h"
+
+static void b43_wa_papd(struct b43_wldev *dev)
+{
+	u16 backup;
+
+	backup = b43_ofdmtab_read16(dev, B43_OFDMTAB_PWRDYN2, 0);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_PWRDYN2, 0, 7);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_APHY, 0, 0);
+	b43_dummy_transmission(dev);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_PWRDYN2, 0, backup);
+}
+
+static void b43_wa_auxclipthr(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, B43_PHY_OFDM(0x8E), 0x3800);
+}
+
+static void b43_wa_afcdac(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, 0x0035, 0x03FF);
+	b43_phy_write(dev, 0x0036, 0x0400);
+}
+
+static void b43_wa_txdc_offset(struct b43_wldev *dev)
+{
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_DC, 0, 0x0051);
+}
+
+void b43_wa_initgains(struct b43_wldev *dev)
+{
+	struct b43_phy *phy = &dev->phy;
+
+	b43_phy_write(dev, B43_PHY_LNAHPFCTL, 0x1FF9);
+	b43_phy_write(dev, B43_PHY_LPFGAINCTL,
+		b43_phy_read(dev, B43_PHY_LPFGAINCTL) & 0xFF0F);
+	if (phy->rev <= 2)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_LPFGAIN, 0, 0x1FBF);
+	b43_radio_write16(dev, 0x0002, 0x1FBF);
+
+	b43_phy_write(dev, 0x0024, 0x4680);
+	b43_phy_write(dev, 0x0020, 0x0003);
+	b43_phy_write(dev, 0x001D, 0x0F40);
+	b43_phy_write(dev, 0x001F, 0x1C00);
+	if (phy->rev <= 3)
+		b43_phy_write(dev, 0x002A,
+			(b43_phy_read(dev, 0x002A) & 0x00FF) | 0x0400);
+	else if (phy->rev == 5) {
+		b43_phy_write(dev, 0x002A,
+			(b43_phy_read(dev, 0x002A) & 0x00FF) | 0x1A00);
+		b43_phy_write(dev, 0x00CC, 0x2121);
+	}
+	if (phy->rev >= 3)
+		b43_phy_write(dev, 0x00BA, 0x3ED5);
+}
+
+static void b43_wa_divider(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, 0x002B, b43_phy_read(dev, 0x002B) & ~0x0100);
+	b43_phy_write(dev, 0x008E, 0x58C1);
+}
+
+static void b43_wa_gt(struct b43_wldev *dev) /* Gain table. */
+{
+	if (dev->phy.rev <= 2) {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN2, 0, 15);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN2, 1, 31);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN2, 2, 42);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN2, 3, 48);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN2, 4, 58);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 0, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 1, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 2, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 3, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 4, 21);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 5, 21);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 6, 25);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN1, 0, 3);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN1, 1, 3);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN1, 2, 7);
+	} else {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 0, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 1, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 2, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 3, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 4, 21);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 5, 21);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 6, 25);
+	}
+}
+
+static void b43_wa_rssi_lt(struct b43_wldev *dev) /* RSSI lookup table */
+{
+	int i;
+
+	for (i = 0; i < 8; i++)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_RSSI, i, i + 8);
+	for (i = 8; i < 16; i++)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_RSSI, i, i - 8);
+}
+
+static void b43_wa_analog(struct b43_wldev *dev)
+{
+	struct b43_phy *phy = &dev->phy;
+
+	if (phy->analog > 2) {
+		if (phy->type == B43_PHYTYPE_A)
+			b43_phy_write(dev, B43_PHY_PWRDOWN, 0x1808);
+		else
+			b43_phy_write(dev, B43_PHY_PWRDOWN, 0x1000);
+	} else {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 3, 0x1044);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 4, 0x7201);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 6, 0x0040);
+	}
+}
+
+static void b43_wa_dac(struct b43_wldev *dev)
+{
+	if (dev->phy.analog == 1)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 1,
+			(b43_ofdmtab_read16(dev, B43_OFDMTAB_DAC, 1) & ~0x0034) | 0x0008);
+	else
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 1,
+			(b43_ofdmtab_read16(dev, B43_OFDMTAB_DAC, 1) & ~0x0078) | 0x0010);
+}
+
+static void b43_wa_fft(struct b43_wldev *dev) /* Fine frequency table */
+{
+	int i;
+
+	if (dev->phy.type == B43_PHYTYPE_A)
+		for (i = 0; i < B43_TAB_FINEFREQA_SIZE; i++)
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_DACRFPABB, i, b43_tab_finefreqa[i]);
+	else
+		for (i = 0; i < B43_TAB_FINEFREQG_SIZE; i++)
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_DACRFPABB, i, b43_tab_finefreqg[i]);
+}
+
+static void b43_wa_nft(struct b43_wldev *dev) /* Noise figure table */
+{
+	struct b43_phy *phy = &dev->phy;
+	int i;
+
+	if (phy->type == B43_PHYTYPE_A) {
+		if (phy->rev == 2)
+			for (i = 0; i < B43_TAB_NOISEA2_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, i, b43_tab_noisea2[i]);
+		else
+			for (i = 0; i < B43_TAB_NOISEA3_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, i, b43_tab_noisea3[i]);
+	} else {
+		if (phy->rev == 1)
+			for (i = 0; i < B43_TAB_NOISEG1_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, i, b43_tab_noiseg1[i]);
+		else
+			for (i = 0; i < B43_TAB_NOISEG2_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, i, b43_tab_noiseg2[i]);
+	}
+}
+
+static void b43_wa_rt(struct b43_wldev *dev) /* Rotor table */
+{
+	int i;
+
+	for (i = 0; i < B43_TAB_ROTOR_SIZE; i++)
+		b43_ofdmtab_write32(dev, B43_OFDMTAB_ROTOR, i, b43_tab_rotor[i]);
+}
+
+static void b43_wa_nst(struct b43_wldev *dev) /* Noise scale table */
+{
+	struct b43_phy *phy = &dev->phy;
+	int i;
+
+	if (phy->type == B43_PHYTYPE_A) {
+		if (phy->rev <= 1)
+			for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+							i, 0);
+		else if (phy->rev == 2)
+			for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+							i, b43_tab_noisescalea2[i]);
+		else if (phy->rev == 3)
+			for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+							i, b43_tab_noisescalea3[i]);
+		else
+			for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+							i, b43_tab_noisescaleg3[i]);
+	} else {
+		if (phy->rev >= 6) {
+			if (b43_phy_read(dev, B43_PHY_ENCORE) & B43_PHY_ENCORE_EN)
+				for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+					b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+						i, b43_tab_noisescaleg3[i]);
+			else
+				for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+					b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+						i, b43_tab_noisescaleg2[i]);
+		} else {
+			for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+							i, b43_tab_noisescaleg1[i]);
+		}
+	}
+}
+
+static void b43_wa_art(struct b43_wldev *dev) /* ADV retard table */
+{
+	int i;
+
+	for (i = 0; i < B43_TAB_RETARD_SIZE; i++)
+			b43_ofdmtab_write32(dev, B43_OFDMTAB_ADVRETARD,
+				i, b43_tab_retard[i]);
+}
+
+static void b43_wa_txlna_gain(struct b43_wldev *dev)
+{
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_DC, 13, 0x0000);
+}
+
+static void b43_wa_crs_reset(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, 0x002C, 0x0064);
+}
+
+static void b43_wa_2060txlna_gain(struct b43_wldev *dev)
+{
+	b43_hf_write(dev, b43_hf_read(dev) |
+			 B43_HF_2060W);
+}
+
+static void b43_wa_lms(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, 0x0055,
+		(b43_phy_read(dev, 0x0055) & 0xFFC0) | 0x0004);
+}
+
+static void b43_wa_mixedsignal(struct b43_wldev *dev)
+{
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 1, 3);
+}
+
+static void b43_wa_msst(struct b43_wldev *dev) /* Min sigma square table */
+{
+	struct b43_phy *phy = &dev->phy;
+	int i;
+	const u16 *tab;
+
+	if (phy->type == B43_PHYTYPE_A) {
+		tab = b43_tab_sigmasqr1;
+	} else if (phy->type == B43_PHYTYPE_G) {
+		tab = b43_tab_sigmasqr2;
+	} else {
+		B43_WARN_ON(1);
+		return;
+	}
+
+	for (i = 0; i < B43_TAB_SIGMASQR_SIZE; i++) {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_MINSIGSQ,
+					i, tab[i]);
+	}
+}
+
+static void b43_wa_iqadc(struct b43_wldev *dev)
+{
+	if (dev->phy.analog == 4)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 0,
+			b43_ofdmtab_read16(dev, B43_OFDMTAB_DAC, 0) & ~0xF000);
+}
+
+static void b43_wa_crs_ed(struct b43_wldev *dev)
+{
+	struct b43_phy *phy = &dev->phy;
+
+	if (phy->rev == 1) {
+		b43_phy_write(dev, B43_PHY_CRSTHRES1, 0x4F19);
+	} else if (phy->rev == 2) {
+		b43_phy_write(dev, B43_PHY_CRSTHRES1_R1, 0x1861);
+		b43_phy_write(dev, B43_PHY_CRSTHRES2_R1, 0x1861);
+		b43_phy_write(dev, B43_PHY_ANTDWELL,
+				  b43_phy_read(dev, B43_PHY_ANTDWELL)
+				  | 0x0800);
+	} else {
+		b43_phy_write(dev, B43_PHY_CRSTHRES1_R1, 0x0098);
+		b43_phy_write(dev, B43_PHY_CRSTHRES2_R1, 0x0070);
+		b43_phy_write(dev, B43_PHY_OFDM(0xC9), 0x0080);
+		b43_phy_write(dev, B43_PHY_ANTDWELL,
+				  b43_phy_read(dev, B43_PHY_ANTDWELL)
+				  | 0x0800);
+	}
+}
+
+static void b43_wa_crs_thr(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, B43_PHY_CRS0,
+			(b43_phy_read(dev, B43_PHY_CRS0) & ~0x03C0) | 0xD000);
+}
+
+static void b43_wa_crs_blank(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, B43_PHY_OFDM(0x2C), 0x005A);
+}
+
+static void b43_wa_cck_shiftbits(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, B43_PHY_CCKSHIFTBITS, 0x0026);
+}
+
+static void b43_wa_wrssi_offset(struct b43_wldev *dev)
+{
+	int i;
+
+	if (dev->phy.rev == 1) {
+		for (i = 0; i < 16; i++) {
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_WRSSI_R1,
+						i, 0x0020);
+		}
+	} else {
+		for (i = 0; i < 32; i++) {
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_WRSSI,
+						i, 0x0820);
+		}
+	}
+}
+
+static void b43_wa_txpuoff_rxpuon(struct b43_wldev *dev)
+{
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_0F, 2, 15);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_0F, 3, 20);
+}
+
+static void b43_wa_altagc(struct b43_wldev *dev)
+{
+	struct b43_phy *phy = &dev->phy;
+
+	if (phy->rev == 1) {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 0, 254);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 1, 13);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 2, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 3, 25);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, 0, 0x2710);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, 1, 0x9B83);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, 2, 0x9B83);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, 3, 0x0F8D);
+		b43_phy_write(dev, B43_PHY_LMS, 4);
+	} else {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0, 254);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 1, 13);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 2, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 3, 25);
+	}
+
+	b43_phy_write(dev, B43_PHY_CCKSHIFTBITS_WA,
+		(b43_phy_read(dev, B43_PHY_CCKSHIFTBITS_WA) & ~0xFF00) | 0x5700);
+	b43_phy_write(dev, B43_PHY_OFDM(0x1A),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x1A)) & ~0x007F) | 0x000F);
+	b43_phy_write(dev, B43_PHY_OFDM(0x1A),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x1A)) & ~0x3F80) | 0x2B80);
+	b43_phy_write(dev, B43_PHY_ANTWRSETT,
+		(b43_phy_read(dev, B43_PHY_ANTWRSETT) & 0xF0FF) | 0x0300);
+	b43_radio_write16(dev, 0x7A,
+		b43_radio_read16(dev, 0x7A) | 0x0008);
+	b43_phy_write(dev, B43_PHY_N1P1GAIN,
+		(b43_phy_read(dev, B43_PHY_N1P1GAIN) & ~0x000F) | 0x0008);
+	b43_phy_write(dev, B43_PHY_P1P2GAIN,
+		(b43_phy_read(dev, B43_PHY_P1P2GAIN) & ~0x0F00) | 0x0600);
+	b43_phy_write(dev, B43_PHY_N1N2GAIN,
+		(b43_phy_read(dev, B43_PHY_N1N2GAIN) & ~0x0F00) | 0x0700);
+	b43_phy_write(dev, B43_PHY_N1P1GAIN,
+		(b43_phy_read(dev, B43_PHY_N1P1GAIN) & ~0x0F00) | 0x0100);
+	if (phy->rev == 1) {
+		b43_phy_write(dev, B43_PHY_N1N2GAIN,
+				  (b43_phy_read(dev, B43_PHY_N1N2GAIN)
+				   & ~0x000F) | 0x0007);
+	}
+	b43_phy_write(dev, B43_PHY_OFDM(0x88),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x88)) & ~0x00FF) | 0x001C);
+	b43_phy_write(dev, B43_PHY_OFDM(0x88),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x88)) & ~0x3F00) | 0x0200);
+	b43_phy_write(dev, B43_PHY_OFDM(0x96),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x96)) & ~0x00FF) | 0x001C);
+	b43_phy_write(dev, B43_PHY_OFDM(0x89),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x89)) & ~0x00FF) | 0x0020);
+	b43_phy_write(dev, B43_PHY_OFDM(0x89),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x89)) & ~0x3F00) | 0x0200);
+	b43_phy_write(dev, B43_PHY_OFDM(0x82),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x82)) & ~0x00FF) | 0x002E);
+	b43_phy_write(dev, B43_PHY_OFDM(0x96),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x96)) & ~0xFF00) | 0x1A00);
+	b43_phy_write(dev, B43_PHY_OFDM(0x81),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x81)) & ~0x00FF) | 0x0028);
+	b43_phy_write(dev, B43_PHY_OFDM(0x81),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x81)) & ~0xFF00) | 0x2C00);
+	if (phy->rev == 1) {
+		b43_phy_write(dev, B43_PHY_PEAK_COUNT, 0x092B);
+		b43_phy_write(dev, B43_PHY_OFDM(0x1B),
+			(b43_phy_read(dev, B43_PHY_OFDM(0x1B)) & ~0x001E) | 0x0002);
+	} else {
+		b43_phy_write(dev, B43_PHY_OFDM(0x1B),
+			b43_phy_read(dev, B43_PHY_OFDM(0x1B)) & ~0x001E);
+		b43_phy_write(dev, B43_PHY_OFDM(0x1F), 0x287A);
+		b43_phy_write(dev, B43_PHY_LPFGAINCTL,
+			(b43_phy_read(dev, B43_PHY_LPFGAINCTL) & ~0x000F) | 0x0004);
+		if (phy->rev >= 6) {
+			b43_phy_write(dev, B43_PHY_OFDM(0x22), 0x287A);
+			b43_phy_write(dev, B43_PHY_LPFGAINCTL,
+				(b43_phy_read(dev, B43_PHY_LPFGAINCTL) & ~0xF000) | 0x3000);
+		}
+	}
+	b43_phy_write(dev, B43_PHY_DIVSRCHIDX,
+		(b43_phy_read(dev, B43_PHY_DIVSRCHIDX) & 0x7F7F) | 0x7874);
+	b43_phy_write(dev, B43_PHY_OFDM(0x8E), 0x1C00);
+	if (phy->rev == 1) {
+		b43_phy_write(dev, B43_PHY_DIVP1P2GAIN,
+			(b43_phy_read(dev, B43_PHY_DIVP1P2GAIN) & ~0x0F00) | 0x0600);
+		b43_phy_write(dev, B43_PHY_OFDM(0x8B), 0x005E);
+		b43_phy_write(dev, B43_PHY_ANTWRSETT,
+			(b43_phy_read(dev, B43_PHY_ANTWRSETT) & ~0x00FF) | 0x001E);
+		b43_phy_write(dev, B43_PHY_OFDM(0x8D), 0x0002);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 0, 0);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 1, 7);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 2, 16);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 3, 28);
+	} else {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 0, 0);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 1, 7);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 2, 16);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 3, 28);
+	}
+	if (phy->rev >= 6) {
+		b43_phy_write(dev, B43_PHY_OFDM(0x26),
+			b43_phy_read(dev, B43_PHY_OFDM(0x26)) & ~0x0003);
+		b43_phy_write(dev, B43_PHY_OFDM(0x26),
+			b43_phy_read(dev, B43_PHY_OFDM(0x26)) & ~0x1000);
+	}
+}
+
+static void b43_wa_tr_ltov(struct b43_wldev *dev) /* TR Lookup Table Original Values */
+{
+	b43_gtab_write(dev, B43_GTAB_ORIGTR, 0, 0xC480);
+}
+
+static void b43_wa_cpll_nonpilot(struct b43_wldev *dev)
+{
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_11, 0, 0);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_11, 1, 0);
+}
+
+static void b43_wa_rssi_adc(struct b43_wldev *dev)
+{
+	if (dev->phy.analog == 4)
+		b43_phy_write(dev, 0x00DC, 0x7454);
+}
+
+static void b43_wa_boards_a(struct b43_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+
+	if (bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM &&
+	    bus->boardinfo.type == SSB_BOARD_BU4306 &&
+	    bus->boardinfo.rev < 0x30) {
+		b43_phy_write(dev, 0x0010, 0xE000);
+		b43_phy_write(dev, 0x0013, 0x0140);
+		b43_phy_write(dev, 0x0014, 0x0280);
+	} else {
+		if (bus->boardinfo.type == SSB_BOARD_MP4318 &&
+		    bus->boardinfo.rev < 0x20) {
+			b43_phy_write(dev, 0x0013, 0x0210);
+			b43_phy_write(dev, 0x0014, 0x0840);
+		} else {
+			b43_phy_write(dev, 0x0013, 0x0140);
+			b43_phy_write(dev, 0x0014, 0x0280);
+		}
+		if (dev->phy.rev <= 4)
+			b43_phy_write(dev, 0x0010, 0xE000);
+		else
+			b43_phy_write(dev, 0x0010, 0x2000);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DC, 1, 0x0039);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_APHY, 7, 0x0040);
+	}
+}
+
+static void b43_wa_boards_g(struct b43_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+	struct b43_phy *phy = &dev->phy;
+
+	if (bus->boardinfo.vendor != SSB_BOARDVENDOR_BCM ||
+	    bus->boardinfo.type != SSB_BOARD_BU4306 ||
+	    bus->boardinfo.rev != 0x17) {
+		if (phy->rev < 2) {
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX_R1, 1, 0x0002);
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX_R1, 2, 0x0001);
+		} else {
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 1, 0x0002);
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 2, 0x0001);
+			if ((bus->sprom.r1.boardflags_lo & B43_BFL_EXTLNA) &&
+			    (phy->rev >= 7)) {
+				b43_phy_write(dev, B43_PHY_EXTG(0x11),
+					b43_phy_read(dev, B43_PHY_EXTG(0x11)) & 0xF7FF);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0020, 0x0001);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0021, 0x0001);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0022, 0x0001);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0023, 0x0000);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0000, 0x0000);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0003, 0x0002);
+			}
+		}
+	}
+	if (bus->sprom.r1.boardflags_lo & B43_BFL_FEM) {
+		b43_phy_write(dev, B43_PHY_GTABCTL, 0x3120);
+		b43_phy_write(dev, B43_PHY_GTABDATA, 0xC480);
+	}
+}
+
+void b43_wa_all(struct b43_wldev *dev)
+{
+	struct b43_phy *phy = &dev->phy;
+
+	if (phy->type == B43_PHYTYPE_A) {
+		switch (phy->rev) {
+		case 2:
+			b43_wa_papd(dev);
+			b43_wa_auxclipthr(dev);
+			b43_wa_afcdac(dev);
+			b43_wa_txdc_offset(dev);
+			b43_wa_initgains(dev);
+			b43_wa_divider(dev);
+			b43_wa_gt(dev);
+			b43_wa_rssi_lt(dev);
+			b43_wa_analog(dev);
+			b43_wa_dac(dev);
+			b43_wa_fft(dev);
+			b43_wa_nft(dev);
+			b43_wa_rt(dev);
+			b43_wa_nst(dev);
+			b43_wa_art(dev);
+			b43_wa_txlna_gain(dev);
+			b43_wa_crs_reset(dev);
+			b43_wa_2060txlna_gain(dev);
+			b43_wa_lms(dev);
+			break;
+		case 3:
+			b43_wa_papd(dev);
+			b43_wa_mixedsignal(dev);
+			b43_wa_rssi_lt(dev);
+			b43_wa_txdc_offset(dev);
+			b43_wa_initgains(dev);
+			b43_wa_dac(dev);
+			b43_wa_nft(dev);
+			b43_wa_nst(dev);
+			b43_wa_msst(dev);
+			b43_wa_analog(dev);
+			b43_wa_gt(dev);
+			b43_wa_txpuoff_rxpuon(dev);
+			b43_wa_txlna_gain(dev);
+			break;
+		case 5:
+			b43_wa_iqadc(dev);
+		case 6:
+			b43_wa_papd(dev);
+			b43_wa_rssi_lt(dev);
+			b43_wa_txdc_offset(dev);
+			b43_wa_initgains(dev);
+			b43_wa_dac(dev);
+			b43_wa_nft(dev);
+			b43_wa_nst(dev);
+			b43_wa_msst(dev);
+			b43_wa_analog(dev);
+			b43_wa_gt(dev);
+			b43_wa_txpuoff_rxpuon(dev);
+			b43_wa_txlna_gain(dev);
+			break;
+		case 7:
+			b43_wa_iqadc(dev);
+			b43_wa_papd(dev);
+			b43_wa_rssi_lt(dev);
+			b43_wa_txdc_offset(dev);
+			b43_wa_initgains(dev);
+			b43_wa_dac(dev);
+			b43_wa_nft(dev);
+			b43_wa_nst(dev);
+			b43_wa_msst(dev);
+			b43_wa_analog(dev);
+			b43_wa_gt(dev);
+			b43_wa_txpuoff_rxpuon(dev);
+			b43_wa_txlna_gain(dev);
+			b43_wa_rssi_adc(dev);
+		default:
+			B43_WARN_ON(1);
+		}
+		b43_wa_boards_a(dev);
+	} else if (phy->type == B43_PHYTYPE_G) {
+		switch (phy->rev) {
+		case 1://XXX review rev1
+			b43_wa_crs_ed(dev);
+			b43_wa_crs_thr(dev);
+			b43_wa_crs_blank(dev);
+			b43_wa_cck_shiftbits(dev);
+			b43_wa_fft(dev);
+			b43_wa_nft(dev);
+			b43_wa_rt(dev);
+			b43_wa_nst(dev);
+			b43_wa_art(dev);
+			b43_wa_wrssi_offset(dev);
+			b43_wa_altagc(dev);
+			break;
+		case 2:
+		case 6:
+		case 7:
+		case 8:
+			b43_wa_tr_ltov(dev);
+			b43_wa_crs_ed(dev);
+			b43_wa_rssi_lt(dev);
+			b43_wa_nft(dev);
+			b43_wa_nst(dev);
+			b43_wa_msst(dev);
+			b43_wa_wrssi_offset(dev);
+			b43_wa_altagc(dev);
+			b43_wa_analog(dev);
+			b43_wa_txpuoff_rxpuon(dev);
+			break;
+		default:
+			B43_WARN_ON(1);
+		}
+		b43_wa_boards_g(dev);
+	} else { /* No N PHY support so far */
+		B43_WARN_ON(1);
+	}
+
+	b43_wa_cpll_nonpilot(dev);
+}
Index: wireless-2.6/drivers/net/wireless/b43/wa.h
===================================================================
--- /dev/null
+++ wireless-2.6/drivers/net/wireless/b43/wa.h
@@ -0,0 +1,7 @@
+#ifndef B43_WA_H_
+#define B43_WA_H_
+
+void b43_wa_initgains(struct b43_wldev *dev);
+void b43_wa_all(struct b43_wldev *dev);
+
+#endif /* B43_WA_H_ */


-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Sun Nov  4 18:36:26 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Sun, 4 Nov 2007 18:36:26 +0100
Subject: [RFC] A PHY init rewrite
In-Reply-To: <20071104182505.0edd7ed6@morte>
References: <20071104182505.0edd7ed6@morte>
Message-ID: <20071104183626.7782ea65@morte>

On Sun, 4 Nov 2007 18:25:05 +0100
Stefano Brivio <stefano.brivio at polimi.it> wrote:

> Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

Cc: Michael Busch <mb at bu3sch.de> instead, sorry. :)


-- 
Ciao
Stefano


From mb at bu3sch.de  Sun Nov  4 19:53:07 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 4 Nov 2007 19:53:07 +0100
Subject: [RFC] A PHY init rewrite
In-Reply-To: <20071104183626.7782ea65@morte>
References: <20071104182505.0edd7ed6@morte> <20071104183626.7782ea65@morte>
Message-ID: <200711041953.07863.mb@bu3sch.de>

On Sunday 04 November 2007 18:36:26 Stefano Brivio wrote:
> On Sun, 4 Nov 2007 18:25:05 +0100
> Stefano Brivio <stefano.brivio at polimi.it> wrote:
> 
> > Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
> > Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> Cc: Michael Busch <mb at bu3sch.de> instead, sorry. :)

:)

I tested this on a 4318 and and 4306.
So you can add an
Acked-by: Michael Buesch <mb at bu3sch.de>
for the G-PHY parts.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sun Nov  4 20:11:19 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 04 Nov 2007 13:11:19 -0600
Subject: [RFC] A PHY init rewrite
In-Reply-To: <200711041953.07863.mb@bu3sch.de>
References: <20071104182505.0edd7ed6@morte> <20071104183626.7782ea65@morte>
	<200711041953.07863.mb@bu3sch.de>
Message-ID: <472E1957.805@lwfinger.net>

Michael Buesch wrote:
> On Sunday 04 November 2007 18:36:26 Stefano Brivio wrote:
>> On Sun, 4 Nov 2007 18:25:05 +0100
>> Stefano Brivio <stefano.brivio at polimi.it> wrote:
>>
>>> Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
>>> Signed-off-by: Michael Buesch <mb at bu3sch.de>
>> Cc: Michael Busch <mb at bu3sch.de> instead, sorry. :)
> 
> :)
> 
> I tested this on a 4318 and and 4306.
> So you can add an
> Acked-by: Michael Buesch <mb at bu3sch.de>
> for the G-PHY parts.
> 

It also works for the BCM4311.

Larry



From rjw at sisk.pl  Mon Nov  5 01:13:54 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Mon, 5 Nov 2007 01:13:54 +0100
Subject: b43 on HP nx6325 w/ openSUSE 10.3 (x86_64)
Message-ID: <200711050113.55591.rjw@sisk.pl>

Hi,

I'm trying to make the b43 driver work on an HP nx6325 with openSUSE 10.3
(64-bit).  In short, it sort of works, but some things are a bit ugly.

The kernel is the current -git (approx. 2.6.24-rc1-git13) with the following
extra patches applied:

b43: Fix rfkill callback deadlock
b43: debugfs SHM read buffer overrun fix
b43: Rewrite and fix rfkill init

and I'm using the firmware from
http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2

Here's the debug info from dmesg:

b43-phy1: Broadcom 4311 WLAN found
b43-phy1 debug: Found PHY: Analog 4, Type 2, Revision 8
b43-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
b43-phy1 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
Registered led device: b43-phy1:tx
Registered led device: b43-phy1:rx
b43-phy1 debug: Chip initialized
b43-phy1 debug: 32-bit DMA initialized
b43-phy1 debug: Wireless interface started
b43-phy1 debug: Adding Interface type 2

Now, the first problem is that the card seems to lose frames from time to
time.  This is visible in the output of mtr and while trying to transfer large
files using scp.  With scp the transfer just stalls and stays this way although
the other end is pingable etc. (eg. attempting to transfer more than 400 MB at
once triggers this 100% of the time).

If you can suggest some more specific tests to me, I'll run them and report
back.

The second problem is that YaST is apparently unable to detect the device,
which sort of sucks, because it leads to configuration problems (basically, you
need to set up everything manually).  Evidently, udev manages to handle it, so
this may be related to HAL.  Anyway, it looks like the problem is related to
the fact that the device is not present under /sys/bus/pci/devices/ directly,
but you need to go through the ssb0:0 subdirectory to get to it.

Do you have any ideas how to tell the user space stuff where the devices is
in sysfs?

Greetings,
Rafael


From larry.finger at lwfinger.net  Mon Nov  5 01:39:27 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 04 Nov 2007 18:39:27 -0600
Subject: b43 on HP nx6325 w/ openSUSE 10.3 (x86_64)
In-Reply-To: <200711050113.55591.rjw@sisk.pl>
References: <200711050113.55591.rjw@sisk.pl>
Message-ID: <472E663F.9040501@lwfinger.net>

Rafael J. Wysocki wrote:
> Hi,
> 
> I'm trying to make the b43 driver work on an HP nx6325 with openSUSE 10.3
> (64-bit).  In short, it sort of works, but some things are a bit ugly.
> 
> The kernel is the current -git (approx. 2.6.24-rc1-git13) with the following
> extra patches applied:
> 
> b43: Fix rfkill callback deadlock
> b43: debugfs SHM read buffer overrun fix
> b43: Rewrite and fix rfkill init
> 
> and I'm using the firmware from
> http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2
> 
> Here's the debug info from dmesg:
> 
> b43-phy1: Broadcom 4311 WLAN found
> b43-phy1 debug: Found PHY: Analog 4, Type 2, Revision 8
> b43-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> b43-phy1 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> Registered led device: b43-phy1:tx
> Registered led device: b43-phy1:rx
> b43-phy1 debug: Chip initialized
> b43-phy1 debug: 32-bit DMA initialized
> b43-phy1 debug: Wireless interface started
> b43-phy1 debug: Adding Interface type 2
> 
> Now, the first problem is that the card seems to lose frames from time to
> time.  This is visible in the output of mtr and while trying to transfer large
> files using scp.  With scp the transfer just stalls and stays this way although
> the other end is pingable etc. (eg. attempting to transfer more than 400 MB at
> once triggers this 100% of the time).
> 
> If you can suggest some more specific tests to me, I'll run them and report
> back.
> 
> The second problem is that YaST is apparently unable to detect the device,
> which sort of sucks, because it leads to configuration problems (basically, you
> need to set up everything manually).  Evidently, udev manages to handle it, so
> this may be related to HAL.  Anyway, it looks like the problem is related to
> the fact that the device is not present under /sys/bus/pci/devices/ directly,
> but you need to go through the ssb0:0 subdirectory to get to it.
> 
> Do you have any ideas how to tell the user space stuff where the devices is
> in sysfs?

Your configuration is exactly like mine - openSUSE 10.3, x86_64 with Linus's latest git, and a 4311.
 I have not used mtr or scp and cannot comment on your transfer problems. I have had 0 problems
configuring the device with YaST. On the x86_64 laptop, I let NetworkManager control the wireless
connection, but I have also used the traditional ifup/ifdown method. On an i386 system, I use
ifup/ifdown as I don't run X on that machine. Both make fast connections.

Larry


From johannes at sipsolutions.net  Mon Nov  5 10:07:34 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 05 Nov 2007 10:07:34 +0100
Subject: b43legacy maintainer needed
In-Reply-To: <472CFCF1.4070309@lwfinger.net>
	(sfid-20071103_225837_394315_842D91BC)
References: <471D72A9.9060208@lwfinger.net> <20071103233511.3daaeeaa@morte>
	<472CFCF1.4070309@lwfinger.net> (sfid-20071103_225837_394315_842D91BC)
Message-ID: <1194253654.10968.5.camel@johannes.berg>


> however, I will be happy to
> send the BCM4306 card. Do you have access to a PCI-based desktop running Linux? If so, I also have a
> Linksys WMP11-V27, which is a B-only device that belongs to the project.

I have a PCI 4306 which is G-capable that may or may not be used by b43,
I'd have to put it into a machine. It's up for grabs too as I don't own
any boxes with PCI slots.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071105/69b10f57/attachment.pgp>

From mb at bu3sch.de  Mon Nov  5 13:51:37 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 5 Nov 2007 13:51:37 +0100
Subject: [RFC] ssb: Add code for SPROM Rev 4
In-Reply-To: <472c9192.8nd7AOTgl+jWptik%Larry.Finger@lwfinger.net>
References: <472c9192.8nd7AOTgl+jWptik%Larry.Finger@lwfinger.net>
Message-ID: <200711051351.37252.mb@bu3sch.de>

On Saturday 03 November 2007 16:19:46 Larry Finger wrote:
> The BCM4328 has a revision 4 SPROM. The necessary changes to handle the
> layout and different size of this revision are implemented. The size of
> the SPROM is now stored in the ssb_bus struct and used from that location
> whenever possible. For those routines that need the size, but do not have
> access to that struct, a size argument is added.
> 
> Recognition of the PCI_ID of the BCM4328 is also implemented. Note that
> the PCI_ID is 0x4328, but the chipid is 0x4321.
> 
> This code has been tested by Michael Gerdau <mgerdau at tiscali.de>.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---


> Index: wireless-2.6/include/linux/ssb/ssb.h
> ===================================================================
> --- wireless-2.6.orig/include/linux/ssb/ssb.h
> +++ wireless-2.6/include/linux/ssb/ssb.h
> @@ -79,7 +79,39 @@ struct ssb_sprom_r3 {
>  };
>  
>  struct ssb_sprom_r4 {
> -	/* TODO */
> +	u16 pci_spid;		/* Subsystem Product ID for PCI */
> +	u16 pci_svid;		/* Subsystem Vendor ID for PCI */
> +	u16 pci_pid;		/* Product ID for PCI */
> +	u8 il0mac[6];		/* MAC address for 802.11b/g */
> +	u8 et0mac[6];		/* MAC address for Ethernet */
> +	u8 et1mac[6];		/* MAC address for 802.11a */
> +	u8 et0phyaddr:5;	/* MII address for enet0 */
> +	u8 et1phyaddr:5;	/* MII address for enet1 */
> +	u8 et0mdcport:1;	/* MDIO for enet0 */
> +	u8 et1mdcport:1;	/* MDIO for enet1 */
> +	u8 board_rev;		/* Board revision */
> +	u8 country_code:4;	/* Country Code */
> +	u8 antenna_a:2;		/* Antenna 0/1 available for A-PHY */
> +	u8 antenna_bg:2;	/* Antenna 0/1 available for B-PHY and G-PHY */
> +	u16 pa0b0;
> +	u16 pa0b1;
> +	u16 pa0b2;
> +	u16 pa1b0;
> +	u16 pa1b1;
> +	u16 pa1b2;
> +	u8 gpio0;		/* GPIO pin 0 */
> +	u8 gpio1;		/* GPIO pin 1 */
> +	u8 gpio2;		/* GPIO pin 2 */
> +	u8 gpio3;		/* GPIO pin 3 */
> +	u16 maxpwr_a;		/* A-PHY Amplifier Max Power (in dBm Q5.2) */
> +	u16 maxpwr_bg;		/* B/G-PHY Amplifier Max Power (in dBm Q5.2) */
> +	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
> +	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
> +	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
> +	u8 antenna_gain_a;	/* A-PHY Antenna gain (in dBm Q5.2) */
> +	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
> +	/* The variables above this point must match those of ssb_sprom_r1 */
> +	/* TODO - add any special ssb_sprom_r4 variables below this point. */
>  };
>  
>  struct ssb_sprom {
> @@ -288,6 +320,7 @@ struct ssb_bus {
>  	/* ID information about the Chip. */
>  	u16 chip_id;
>  	u16 chip_rev;
> +	u16 sprom_size;		/* number of words in sprom */
>  	u8 chip_package;
>  
>  	/* List of devices (cores) on the backplane. */

Larry, I did not forget your patch.
But I need to think a little bit more about this.

The union above is not really what I'd like to have here. In fact,
I think to get the v4 sprom implemented the sprom struct has to be
redesigned.

I think we must leave the path of partitioning the sprom struct into
versions, because that obviously doesn't work anymore.
Instead, I think we must develop _one_ common struct that is capable
of holding the information from any sprom. (Note that the struct layout
does not need to reflect the real hardware layout).

And I think we should also remove the fields that are not needed at all,
like the PCI ID stuff.

something like this:


struct ssb_sprom_pathvar {
	bool this_pathvar_is_available;

	...foobar data
};

struct ssb_sprom {
	u8 wl_mac_addr[ETH_ALEN];
	u8 eth0_mac_addr[ETH_ALEN];
	u8 eth1_mac_addr[ETH_ALEN];

	...

	u8 gpio0;
	u8 gpio1;
	...

	antennagain...

	struct ssb_sprom_pathvar pv0;
	struct ssb_sprom_pathvar pv1;
	...
};

Note that I did _not_ look closely at the pathvar stuff, so this
might be a bad idea to design it this way.
But the point I was going to make with that was; we probably need
some "this data is valid" bits for different parts of the sprom
struct, as for example v1-3 don't have these pathvars (So the drivers
must be told it's invalid data).
The reason for all this "valid-bit" stuff is that I think we should
remove any sprom-versioning knowledge from the drivers. That
should be abstracted.

Any idea on how to improve that?

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Mon Nov  5 17:03:47 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 05 Nov 2007 10:03:47 -0600
Subject: [RFC] ssb: Add code for SPROM Rev 4
In-Reply-To: <200711051351.37252.mb@bu3sch.de>
References: <472c9192.8nd7AOTgl+jWptik%Larry.Finger@lwfinger.net>
	<200711051351.37252.mb@bu3sch.de>
Message-ID: <472F3EE3.5040201@lwfinger.net>

Michael Buesch wrote:
> Larry, I did not forget your patch.
> But I need to think a little bit more about this.

I knew that this one would take some time.

> The union above is not really what I'd like to have here. In fact,
> I think to get the v4 sprom implemented the sprom struct has to be
> redesigned.

The way I implemented it was as a "straw man" designed to get shot down. :-) The only benefit it had
was that this format has allowed my tester to get started enough to get b43 loaded. He is rapidly
implementing that part of the specs that are needed to get the BCM4328 with an N PHY working in G mode.

> I think we must leave the path of partitioning the sprom struct into
> versions, because that obviously doesn't work anymore.
> Instead, I think we must develop _one_ common struct that is capable
> of holding the information from any sprom. (Note that the struct layout
> does not need to reflect the real hardware layout).
> 
> And I think we should also remove the fields that are not needed at all,
> like the PCI ID stuff.

I agree.

> something like this:
> 
> 
> struct ssb_sprom_pathvar {
> 	bool this_pathvar_is_available;
> 
> 	...foobar data
> };
> 
> struct ssb_sprom {
> 	u8 wl_mac_addr[ETH_ALEN];
> 	u8 eth0_mac_addr[ETH_ALEN];
> 	u8 eth1_mac_addr[ETH_ALEN];
> 
> 	...
> 
> 	u8 gpio0;
> 	u8 gpio1;
> 	...
> 
> 	antennagain...
> 
> 	struct ssb_sprom_pathvar pv0;
> 	struct ssb_sprom_pathvar pv1;

I think this section can be

	u8 path_data0[SPROM_PATH_DATA_SIZE];
	u8 path_data1 ...

where SPROM_PATH_DATA_SIZE = 0x26. Once we see how the data are used, it may make more sense to have
these data be u16, or even a union so that we can have it both ways.

> 	...
> };
> 
> Note that I did _not_ look closely at the pathvar stuff, so this
> might be a bad idea to design it this way.
> But the point I was going to make with that was; we probably need
> some "this data is valid" bits for different parts of the sprom
> struct, as for example v1-3 don't have these pathvars (So the drivers
> must be told it's invalid data).
> The reason for all this "valid-bit" stuff is that I think we should
> remove any sprom-versioning knowledge from the drivers. That
> should be abstracted.

I agree.

> Any idea on how to improve that?

I'm not sure we need a separate "valid bit" for path data. In the sprom that we are working with,
only paths 1 & 2 are implemented - the paths 3 & 4 region contains all 1's just like any
unimplemented sprom data. It should be OK to initialize the first word of each path to 0xFFFF to
indicate it is unused.

To let you know how the specs translate into a device, here is the dump of the BCM4328 sprom:

ssb: SPROM r4 dump
ssb: 0x0000: 0x2801 0x0000 0x0009 0x1028 0x0000 0x0DBE 0xFF00 0x2BC4
ssb: 0x0010: 0x2A64 0x2964 0x2C64 0x3CE7 0xFFFF 0xFFFF 0xFFFF 0xFFFF
ssb: 0x0020: 0x4328 0x8000 0x0002 0x0000 0x1001 0x1800 0x0000 0x0000
ssb: 0x0030: 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF
ssb: 0x0040: 0x5372 0x004C 0x4A01 0x0000 0x0004 0x0000 0x0019 0x7DA5
ssb: 0x0050: 0x1912 0x0000 0x0001 0x83FF 0xFFFF 0xFFFF 0x0303 0x0202
ssb: 0x0060: 0xFFFF 0x3437 0x5B5B 0x1420 0x5B5B 0x0D0C 0x5B5B 0x1A1E
ssb: 0x0070: 0x5B5B 0x3844 0x3838 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF
ssb: 0x0080: 0x3E4E 0xFEC6 0x15D3 0xFB3D 0x0000 0x3E3C 0x3C3C 0xFE6C
ssb: 0x0090: 0x1664 0xFA7B 0x0000 0xFE37 0x1401 0xFAE7 0x0000 0xFE5A
ssb: 0x00A0: 0x147E 0xFAC7 0x0000 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0x3E4E
ssb: 0x00B0: 0xFEC1 0x15BC 0xFB2F 0x0000 0x3E3C 0x3C3C 0xFE69 0x1608
ssb: 0x00C0: 0xFA81 0x0000 0xFE2A 0x1321 0xFB0B 0x0000 0xFE66 0x1595
ssb: 0x00D0: 0xFA88 0x0000 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF
ssb: 0x00E0: 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF
ssb: 0x00F0: 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF
ssb: 0x0100: 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF
ssb: 0x0110: 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF
ssb: 0x0120: 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF
ssb: 0x0130: 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0x0000 0x0000 0x0000 0x0000
ssb: 0x0140: 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
ssb: 0x0150: 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
ssb: 0x0160: 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
ssb: 0x0170: 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
ssb: 0x0180: 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000
ssb: 0x0190: 0x0000 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF
ssb: 0x01A0: 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF
ssb: 0x01B0: 0xFFFF 0xFFFF 0xFFFF 0x9404

As I said earlier, my current patch is working OK for present needs. Once we come to an agreement
regarding the sprom data structures, I will begin implementing them. As I see it, conversion will be
a 3-step process. We will need a patch to add the new structure, a second to populate that
structure, patches to convert b44, b43, and b43legacy to use the new data, and a final patch to
remove the old structure. In this manner, bisection will be supported.

Larry


From mgerdau at tiscali.de  Mon Nov  5 17:13:36 2007
From: mgerdau at tiscali.de (Michael Gerdau)
Date: Mon, 5 Nov 2007 17:13:36 +0100
Subject: [RFC] ssb: Add code for SPROM Rev 4
In-Reply-To: <472c9192.8nd7AOTgl+jWptik%Larry.Finger@lwfinger.net>
References: <472c9192.8nd7AOTgl+jWptik%Larry.Finger@lwfinger.net>
Message-ID: <200711051716.12419.mgerdau@tiscali.de>

Am Samstag, 3. November 2007 schrieb Larry Finger:
> The BCM4328 has a revision 4 SPROM. The necessary changes to handle the
> layout and different size of this revision are implemented. The size of
> the SPROM is now stored in the ssb_bus struct and used from that location
> whenever possible. For those routines that need the size, but do not have
> access to that struct, a size argument is added.
> 
> Recognition of the PCI_ID of the BCM4328 is also implemented. Note that
> the PCI_ID is 0x4328, but the chipid is 0x4321.
> 
> This code has been tested by Michael Gerdau <mgerdau at tiscali.de>.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Michael,
> 
> Please comment on this patch. It is intended to be applied to wireless-2.6/everything.

This code works for me (AFAICT). Therefor

Acked-by: Michael Gerdau <mgerdau at tiscali.de>

Best,
Michael
-- 
 Vote against SPAM - see http://www.politik-digital.de/spam/
 Michael Gerdau       email: mgerdau at tiscali.de
 GPG-keys available on request or at public keyserver
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 194 bytes
Desc: This is a digitally signed message part.
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071105/3a4c57cf/attachment.pgp>

From mb at bu3sch.de  Mon Nov  5 17:31:33 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 5 Nov 2007 17:31:33 +0100
Subject: [RFC] ssb: Add code for SPROM Rev 4
In-Reply-To: <472F3EE3.5040201@lwfinger.net>
References: <472c9192.8nd7AOTgl+jWptik%Larry.Finger@lwfinger.net>
	<200711051351.37252.mb@bu3sch.de> <472F3EE3.5040201@lwfinger.net>
Message-ID: <200711051731.33284.mb@bu3sch.de>

On Monday 05 November 2007 17:03:47 Larry Finger wrote:
> 	u8 path_data0[SPROM_PATH_DATA_SIZE];
> 	u8 path_data1 ...
> 
> where SPROM_PATH_DATA_SIZE = 0x26. Once we see how the data are used, it may make more sense to have
> these data be u16,


> or even a union so that we can have it both ways. 
            ^^^^^                        ^^^^^^^^^

Whoops, endianess broken :)

> I'm not sure we need a separate "valid bit" for path data. In the sprom that we are working with,

Ok, even better then.
The "valid bit" was just an idea for stuff in the sprom which cannot
be determined valid or not in another way.

> As I said earlier, my current patch is working OK for present needs. Once we come to an agreement
> regarding the sprom data structures, I will begin implementing them. As I see it, conversion will be
> a 3-step process. We will need a patch to add the new structure, a second to populate that
> structure, patches to convert b44, b43, and b43legacy to use the new data, and a final patch to
> remove the old structure. In this manner, bisection will be supported.

cool :)

Are you going to try a redesign of the structure?
I'm not too motivated to do it, as I don't know too much about
the v4 sprom, yet.

-- 
Greetings Michael.


From rjw at sisk.pl  Mon Nov  5 22:13:02 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Mon, 5 Nov 2007 22:13:02 +0100
Subject: b43 on HP nx6325 w/ openSUSE 10.3 (x86_64)
In-Reply-To: <472E663F.9040501@lwfinger.net>
References: <200711050113.55591.rjw@sisk.pl> <472E663F.9040501@lwfinger.net>
Message-ID: <200711052213.03362.rjw@sisk.pl>

On Monday, 5 of November 2007, Larry Finger wrote:
> Rafael J. Wysocki wrote:
> > Hi,
> > 
> > I'm trying to make the b43 driver work on an HP nx6325 with openSUSE 10.3
> > (64-bit).  In short, it sort of works, but some things are a bit ugly.
> > 
> > The kernel is the current -git (approx. 2.6.24-rc1-git13) with the following
> > extra patches applied:
> > 
> > b43: Fix rfkill callback deadlock
> > b43: debugfs SHM read buffer overrun fix
> > b43: Rewrite and fix rfkill init
> > 
> > and I'm using the firmware from
> > http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2
> > 
> > Here's the debug info from dmesg:
> > 
> > b43-phy1: Broadcom 4311 WLAN found
> > b43-phy1 debug: Found PHY: Analog 4, Type 2, Revision 8
> > b43-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> > b43-phy1 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> > Registered led device: b43-phy1:tx
> > Registered led device: b43-phy1:rx
> > b43-phy1 debug: Chip initialized
> > b43-phy1 debug: 32-bit DMA initialized
> > b43-phy1 debug: Wireless interface started
> > b43-phy1 debug: Adding Interface type 2
> > 
> > Now, the first problem is that the card seems to lose frames from time to
> > time.  This is visible in the output of mtr and while trying to transfer large
> > files using scp.  With scp the transfer just stalls and stays this way although
> > the other end is pingable etc. (eg. attempting to transfer more than 400 MB at
> > once triggers this 100% of the time).
> > 
> > If you can suggest some more specific tests to me, I'll run them and report
> > back.
> > 
> > The second problem is that YaST is apparently unable to detect the device,
> > which sort of sucks, because it leads to configuration problems (basically, you
> > need to set up everything manually).  Evidently, udev manages to handle it, so
> > this may be related to HAL.  Anyway, it looks like the problem is related to
> > the fact that the device is not present under /sys/bus/pci/devices/ directly,
> > but you need to go through the ssb0:0 subdirectory to get to it.
> > 
> > Do you have any ideas how to tell the user space stuff where the devices is
> > in sysfs?
> 
> Your configuration is exactly like mine - openSUSE 10.3, x86_64 with Linus's latest git, and a 4311.
>  I have not used mtr or scp and cannot comment on your transfer problems.

That may be AP-related, but I had no such problems with the bcm43xx used
previously on the same hardware w/ the same AP.

> I have had 0 problems configuring the device with YaST.

Hm, I wonder what I've done wrong, then. :-)

Can you send me /etc/sysconfig/network/ifcfg-wlan0 (or whatever the card is
visible as on your system) from the x86_64 laptop?

> On the x86_64 laptop, I let NetworkManager control the wireless 
> connection, but I have also used the traditional ifup/ifdown method. On an i386 system, I use
> ifup/ifdown as I don't run X on that machine. Both make fast connections.

Well, finally I did configure the card with YaST, but I had to manually add it
to the list.  ifup/ifdown works, but I haven't tried NetworkManager yet.

Greetings,
Rafael


From larry.finger at lwfinger.net  Tue Nov  6 16:20:30 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 06 Nov 2007 09:20:30 -0600
Subject: bcm43xx driver capabilities
In-Reply-To: <5d3546670711052134t6b3fe7hc41704268b9c602b@mail.gmail.com>
References: <5d3546670711052134t6b3fe7hc41704268b9c602b@mail.gmail.com>
Message-ID: <4730863E.1060702@lwfinger.net>

Jay Timmerman wrote:
> Hi,
> 
> I have been trying to setup an Ad-Hoc network between a bcm4311(version
> 1) and ipw2200 card and I ran into some problems with the bcm4311 card.
> Mainly, the card cannot associate with the other card via ad-hoc mode.
> The card has no trouble picking up the ad-hoc network, but it simply
> does not associate with it. Worse, the card has problems when it is set
> to master mode. Whenever it is set to master mode, it broadcasts the
> SSID "BRCM_TEST_SSID" and the mac address 00:10:18:F1:F2:F3 (this is not
> correct) when instructed otherwise. It seems like it is some kind of
> undocumented bug that has occurred with several other people. Right now
> I am using kernel 2.6.22 with V3 firmware. Is there some kind of
> explanation for the shaky ad-hoc and master modes?

Your problem is not a fault of the driver, but that of SoftMAC - the MAC layer used by bcm43xx. To
use anything but managed mode, you should switch to b43, which is included in 2.6.24-rc1. I would
suggest installing git and pulling from Linus's git tree, or using the "everything" branch of the
wireless-2.6 git tree. Many of us are trying to get SoftMAC removed from 2.6.25. In any case,
mac80211, which is used by b43, is a much better implementation.

Larry



From mb at bu3sch.de  Tue Nov  6 16:36:41 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 6 Nov 2007 16:36:41 +0100
Subject: b43: pcmcia-host initialization bugfixes
Message-ID: <200711061636.41744.mb@bu3sch.de>

Fix the initialization for PCMCIA devices.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-2.6/drivers/net/wireless/b43/pcmcia.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/pcmcia.c	2007-11-04 12:45:10.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/pcmcia.c	2007-11-04 12:46:24.000000000 +0100
@@ -65,12 +65,12 @@ static int __devinit b43_pcmcia_probe(st
 	tuple_t tuple;
 	cisparse_t parse;
 	int err = -ENOMEM;
-	int res;
+	int res = 0;
 	unsigned char buf[64];
 
 	ssb = kzalloc(sizeof(*ssb), GFP_KERNEL);
 	if (!ssb)
-		goto out;
+		goto out_error;
 
 	err = -ENODEV;
 	tuple.DesiredTuple = CISTPL_CONFIG;
@@ -96,10 +96,12 @@ static int __devinit b43_pcmcia_probe(st
 	dev->io.NumPorts2 = 0;
 	dev->io.Attributes2 = 0;
 
-	win.Attributes = WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;
+	win.Attributes = WIN_ADDR_SPACE_MEM | WIN_MEMORY_TYPE_CM |
+			 WIN_ENABLE | WIN_DATA_WIDTH_16 |
+			 WIN_USE_WAIT;
 	win.Base = 0;
 	win.Size = SSB_CORE_SIZE;
-	win.AccessSpeed = 1000;
+	win.AccessSpeed = 250;
 	res = pcmcia_request_window(&dev, &win, &dev->win);
 	if (res != CS_SUCCESS)
 		goto err_kfree_ssb;
@@ -108,21 +110,26 @@ static int __devinit b43_pcmcia_probe(st
 	mem.Page = 0;
 	res = pcmcia_map_mem_page(dev->win, &mem);
 	if (res != CS_SUCCESS)
-		goto err_kfree_ssb;
+		goto err_disable;
 
 	res = pcmcia_request_configuration(dev, &dev->conf);
 	if (res != CS_SUCCESS)
 		goto err_disable;
 
 	err = ssb_bus_pcmciabus_register(ssb, dev, win.Base);
+	if (err)
+		goto err_disable;
 	dev->priv = ssb;
 
-      out:
-	return err;
-      err_disable:
+	return 0;
+
+err_disable:
 	pcmcia_disable_device(dev);
-      err_kfree_ssb:
+err_kfree_ssb:
 	kfree(ssb);
+out_error:
+	printk(KERN_ERR "b43-pcmcia: Initialization failed (%d, %d)\n",
+	       res, err);
 	return err;
 }
 
@@ -131,22 +138,21 @@ static void __devexit b43_pcmcia_remove(
 	struct ssb_bus *ssb = dev->priv;
 
 	ssb_bus_unregister(ssb);
-	pcmcia_release_window(dev->win);
 	pcmcia_disable_device(dev);
 	kfree(ssb);
 	dev->priv = NULL;
 }
 
 static struct pcmcia_driver b43_pcmcia_driver = {
-	.owner = THIS_MODULE,
-	.drv = {
-		.name = "b43-pcmcia",
-		},
-	.id_table = b43_pcmcia_tbl,
-	.probe = b43_pcmcia_probe,
-	.remove = b43_pcmcia_remove,
-	.suspend = b43_pcmcia_suspend,
-	.resume = b43_pcmcia_resume,
+	.owner		= THIS_MODULE,
+	.drv		= {
+				.name = "b43-pcmcia",
+			},
+	.id_table	= b43_pcmcia_tbl,
+	.probe		= b43_pcmcia_probe,
+	.remove		= __devexit_p(b43_pcmcia_remove),
+	.suspend	= b43_pcmcia_suspend,
+	.resume		= b43_pcmcia_resume,
 };
 
 int b43_pcmcia_init(void)


From larry.finger at lwfinger.net  Tue Nov  6 17:54:40 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 06 Nov 2007 10:54:40 -0600
Subject: b43 on HP nx6325 w/ openSUSE 10.3 (x86_64)
In-Reply-To: <200711052213.03362.rjw@sisk.pl>
References: <200711050113.55591.rjw@sisk.pl> <472E663F.9040501@lwfinger.net>
	<200711052213.03362.rjw@sisk.pl>
Message-ID: <47309C50.5030106@lwfinger.net>

Rafael J. Wysocki wrote:
> On Monday, 5 of November 2007, Larry Finger wrote:
>> Rafael J. Wysocki wrote:
>>> Hi,
>>>
>>> I'm trying to make the b43 driver work on an HP nx6325 with openSUSE 10.3
>>> (64-bit).  In short, it sort of works, but some things are a bit ugly.
>>>
>>> The kernel is the current -git (approx. 2.6.24-rc1-git13) with the following
>>> extra patches applied:
>>>
>>> b43: Fix rfkill callback deadlock
>>> b43: debugfs SHM read buffer overrun fix
>>> b43: Rewrite and fix rfkill init
>>>
>>> and I'm using the firmware from
>>> http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2
>>>
>>> Here's the debug info from dmesg:
>>>
>>> b43-phy1: Broadcom 4311 WLAN found
>>> b43-phy1 debug: Found PHY: Analog 4, Type 2, Revision 8
>>> b43-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
>>> b43-phy1 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
>>> Registered led device: b43-phy1:tx
>>> Registered led device: b43-phy1:rx
>>> b43-phy1 debug: Chip initialized
>>> b43-phy1 debug: 32-bit DMA initialized
>>> b43-phy1 debug: Wireless interface started
>>> b43-phy1 debug: Adding Interface type 2
>>>
>>> Now, the first problem is that the card seems to lose frames from time to
>>> time.  This is visible in the output of mtr and while trying to transfer large
>>> files using scp.  With scp the transfer just stalls and stays this way although
>>> the other end is pingable etc. (eg. attempting to transfer more than 400 MB at
>>> once triggers this 100% of the time).
>>>
>>> If you can suggest some more specific tests to me, I'll run them and report
>>> back.
>>>
>>> The second problem is that YaST is apparently unable to detect the device,
>>> which sort of sucks, because it leads to configuration problems (basically, you
>>> need to set up everything manually).  Evidently, udev manages to handle it, so
>>> this may be related to HAL.  Anyway, it looks like the problem is related to
>>> the fact that the device is not present under /sys/bus/pci/devices/ directly,
>>> but you need to go through the ssb0:0 subdirectory to get to it.
>>>
>>> Do you have any ideas how to tell the user space stuff where the devices is
>>> in sysfs?
>> Your configuration is exactly like mine - openSUSE 10.3, x86_64 with Linus's latest git, and a 4311.
>>  I have not used mtr or scp and cannot comment on your transfer problems.
> 
> That may be AP-related, but I had no such problems with the bcm43xx used
> previously on the same hardware w/ the same AP.
> 
>> I have had 0 problems configuring the device with YaST.
> 
> Hm, I wonder what I've done wrong, then. :-)
> 
> Can you send me /etc/sysconfig/network/ifcfg-wlan0 (or whatever the card is
> visible as on your system) from the x86_64 laptop?

This config file is for WPA-PSK TKIP

BOOTPROTO='dhcp'
BROADCAST=''
ETHTOOL_OPTIONS=''
IFPLUGD_PRIORITY='10'
IPADDR=''
MTU=''
NAME='Hewlett-Packard Company WLAN controller'
NETMASK=''
NETWORK=''
REMOTE_IPADDR=''
STARTMODE='ifplugd'
USERCONTROL='yes'
WIRELESS_AP=''
WIRELESS_AUTH_MODE='psk'
WIRELESS_BITRATE='auto'
WIRELESS_CA_CERT=''
WIRELESS_CHANNEL=''
WIRELESS_CLIENT_CERT=''
WIRELESS_CLIENT_KEY=''
WIRELESS_CLIENT_KEY_PASSWORD=''
WIRELESS_DEFAULT_KEY='0'
WIRELESS_EAP_AUTH=''
WIRELESS_EAP_MODE=''
WIRELESS_ESSID='lwfdjf'
WIRELESS_FREQUENCY=''
WIRELESS_KEY=''
WIRELESS_KEY_0=''
WIRELESS_KEY_1=''
WIRELESS_KEY_2=''
WIRELESS_KEY_3=''
WIRELESS_KEY_LENGTH='128'
WIRELESS_MODE='Managed'
WIRELESS_NICK=''
WIRELESS_NWID=''
WIRELESS_PEAP_VERSION=''
WIRELESS_POWER='yes'
WIRELESS_WPA_ANONID=''
WIRELESS_WPA_IDENTITY=''
WIRELESS_WPA_PASSWORD=''
WIRELESS_WPA_PSK='<My secret>'

Larry


From Larry.Finger at lwfinger.net  Tue Nov  6 20:12:56 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 06 Nov 2007 13:12:56 -0600
Subject: [RFC 0/6] ssb and friends: Change layout and naming of SPROM data
Message-ID: <4730BCB8.900@lwfinger.net>

In the various Broadcom devices that are supported, several revisions of the SPROM have been
encountered. Current code takes advantage of the fact that Revision 2 inherits all the data of
1, and that Revision 3 inherits from 2. This scheme breaks down with revision 4, which does not
inherit from the earlier models. In deciding how best to implement the new design, a fresh approach
is warranted. Furthermore, we decided not to include any SPROM variables not used in b44, b43 or
b43legacy, the supported drivers. To keep the patches small while preserving compilation and correct
execution during bisection, the change has been split into the following pieces:

1. Introduce new structure while maintaining the old.
2. Convert the ssb module to the new structure.
3. Convert the b44 driver.
4. Convert b43.
5. convert b43legacy.
6. Remove the old structures from ssb.

Larry



From Larry.Finger at lwfinger.net  Tue Nov  6 20:14:11 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 06 Nov 2007 13:14:11 -0600
Subject: [RFC 1 of 6] ssb: Add new SPROM structure while keeping the old
Message-ID: <4730bd03.rGmiNlJ18XBoW/Yb%Larry.Finger@lwfinger.net>

This is patch 1 of 6.

The SPROM's for various devices utilizing the Sonics Silicon Backplane come
with various revisions. The Revision 2 SPROM inherited the data layout of 1, and
Revision 3 inherited the layout of 2. The first instance of Revision 4 has
now been found in a BCM4328 wireless LAN card. This device does not inherit any
layout from previous versions. Although it was possible to create a data
structure that kept all the old layouts, we decided to start fresh, keep only
those SPROM variables that are used by the drivers that utilize ssb, and to
do the conversion in such a manner that neither compilation or execution will
be affected if a bisection lands in the middle of these changes, while keeping
the patches as small as possible.

In this patch, the sprom structures are changed while maintaining the old ones.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/include/linux/ssb/ssb.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb.h
+++ wireless-2.6/include/linux/ssb/ssb.h
@@ -78,8 +78,32 @@ struct ssb_sprom_r3 {
 	u32 ofdmgpo;		/* G-PHY OFDM Power Offset */
 };
 
-struct ssb_sprom_r4 {
-	/* TODO */
+struct ssb_sprom_data {
+	u8 il0mac[6];		/* MAC address for 802.11b/g */
+	u8 et0mac[6];		/* MAC address for Ethernet */
+	u8 et1mac[6];		/* MAC address for 802.11a */
+	u8 et0phyaddr:5;	/* MII address for enet0 */
+	u8 et1phyaddr:5;	/* MII address for enet1 */
+	u8 country_code;	/* Country Code */
+	u16 pa0b0;
+	u16 pa0b1;
+	u16 pa0b2;
+	u16 pa1b0;
+	u16 pa1b1;
+	u16 pa1b2;
+	u8 gpio0;		/* GPIO pin 0 */
+	u8 gpio1;		/* GPIO pin 1 */
+	u8 gpio2;		/* GPIO pin 2 */
+	u8 gpio3;		/* GPIO pin 3 */
+	u16 maxpwr_a;		/* A-PHY Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_bg;		/* B/G-PHY Amplifier Max Power (in dBm Q5.2) */
+	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
+	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
+	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
+	u8 antenna_gain_a;	/* A-PHY Antenna gain (in dBm Q5.2) */
+	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
+
+	/* TODO - add any parameters needed from rev 2, 3, or 4 SPROMs */
 };
 
 struct ssb_sprom {
@@ -94,8 +118,8 @@ struct ssb_sprom {
 			struct ssb_sprom_r2 r2;
 			struct ssb_sprom_r3 r3;
 		};
-		struct ssb_sprom_r4 r4;
 	};
+	struct ssb_sprom_data data;
 };
 
 /* Information about the PCB the circuitry is soldered on. */
Index: wireless-2.6/include/linux/ssb/ssb_regs.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb_regs.h
+++ wireless-2.6/include/linux/ssb/ssb_regs.h
@@ -250,6 +250,38 @@
 #define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
 #define  SSB_SPROM3_CCKPO_11M_SHIFT	12
 #define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
+/* SPROM Revision 4 */
+#define SSB_SPROM4_IL0MAC		0x104C	/* 6 byte MAC address for b/g */
+#define SSB_SPROM4_ETHPHY		0x105A	/* Ethernet PHY settings */
+#define  SSB_SPROM4_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
+#define  SSB_SPROM4_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
+#define  SSB_SPROM4_ETHPHY_ET1A_SHIFT	5
+#define  SSB_SPROM4_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
+#define  SSB_SPROM4_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
+#define SSB_SPROM4_CCODE		0x1052	/* Country Code (2 bytes) */
+#define SSB_SPROM4_ANT_A		0x105D  /* A Antennas */
+#define SSB_SPROM4_ANT_BG		0x105C  /* B/G Antennas */
+#define SSB_SPROM4_BFLLO		0x1044	/* Boardflags (low 16 bits) */
+#define SSB_SPROM4_AGAIN		0x105E	/* Antenna Gain (in dBm Q5.2) */
+#define SSB_SPROM4_BFLHI		0x1046  /* Board Flags Hi */
+#define SSB_SPROM4_MAXP_A		0x1000  /* Max Power A */
+#define SSB_SPROM4_MAXP_A_HI		0x00FF  /* Mask for Hi */
+#define SSB_SPROM4_MAXP_A_LO		0xFF00  /* Mask for Lo */
+#define SSB_SPROM4_MAXP_A_LO_SHIFT	16	/* Shift for Lo */
+#define SSB_SPROM4_PA1LOB0		0x1000
+#define SSB_SPROM4_PA1LOB1		0x1000
+#define SSB_SPROM4_PA1LOB2		0x1000
+#define SSB_SPROM4_PA1HIB0		0x1000
+#define SSB_SPROM4_PA1HIB1		0x1000
+#define SSB_SPROM4_PA1HIB2		0x1000
+#define SSB_SPROM4_OPO			0x1000
+#define SSB_SPROM4_OPO_VALUE		0x0000
+#define SSB_SPROM4_GPIOLDC		0x105A	/* LED Powersave Duty Cycle */
+#define  SSB_SPROM4_GPIOLDC_OFF		0x0000FF00	/* Off Count */
+#define  SSB_SPROM4_GPIOLDC_OFF_SHIFT	8
+#define  SSB_SPROM4_GPIOLDC_ON		0x00FF0000	/* On Count */
+#define  SSB_SPROM4_GPIOLDC_ON_SHIFT	16
+
 
 /* Values for SSB_SPROM1_BINF_CCODE */
 enum {


From Larry.Finger at lwfinger.net  Tue Nov  6 20:14:54 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 06 Nov 2007 13:14:54 -0600
Subject: [RFC 2 of 6] ssb: Convert to use of the new SPROM structure
Message-ID: <4730bd2e.JniKqRNAOBCjyPGm%Larry.Finger@lwfinger.net>

Patch 2 of 6:

Change ssb to handle the revision 4 SPROM, which is a different size.
This change in size is handled by adding a new variable to the ssb_sprom
struct and using it whenever possible. For those routines that do not
have access to this structure, a 'u16 size' argument is added.

The new PCI_ID for the BCM4328 is also added.

Testing of the Revision 4 SPROM, which is used on the BCM4328, was done
by Michael Gerdau <mgerdau at tiscali.de>.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/drivers/ssb/pci.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/pci.c
+++ wireless-2.6/drivers/ssb/pci.c
@@ -212,29 +212,29 @@ static inline u8 ssb_crc8(u8 crc, u8 dat
 	return t[crc ^ data];
 }
 
-static u8 ssb_sprom_crc(const u16 *sprom)
+static u8 ssb_sprom_crc(const u16 *sprom, u16 size)
 {
 	int word;
 	u8 crc = 0xFF;
 
-	for (word = 0; word < SSB_SPROMSIZE_WORDS - 1; word++) {
+	for (word = 0; word < size - 1; word++) {
 		crc = ssb_crc8(crc, sprom[word] & 0x00FF);
 		crc = ssb_crc8(crc, (sprom[word] & 0xFF00) >> 8);
 	}
-	crc = ssb_crc8(crc, sprom[SPOFF(SSB_SPROM_REVISION)] & 0x00FF);
+	crc = ssb_crc8(crc, sprom[size - 1] & 0x00FF);
 	crc ^= 0xFF;
 
 	return crc;
 }
 
-static int sprom_check_crc(const u16 *sprom)
+static int sprom_check_crc(const u16 *sprom, u16 size)
 {
 	u8 crc;
 	u8 expected_crc;
 	u16 tmp;
 
-	crc = ssb_sprom_crc(sprom);
-	tmp = sprom[SPOFF(SSB_SPROM_REVISION)] & SSB_SPROM_REVISION_CRC;
+	crc = ssb_sprom_crc(sprom, size);
+	tmp = sprom[size - 1] & SSB_SPROM_REVISION_CRC;
 	expected_crc = tmp >> SSB_SPROM_REVISION_CRC_SHIFT;
 	if (crc != expected_crc)
 		return -EPROTO;
@@ -246,7 +246,7 @@ static void sprom_do_read(struct ssb_bus
 {
 	int i;
 
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++)
+	for (i = 0; i < bus->sprom_size; i++)
 		sprom[i] = readw(bus->mmio + SSB_SPROM_BASE + (i * 2));
 }
 
@@ -255,6 +255,7 @@ static int sprom_do_write(struct ssb_bus
 	struct pci_dev *pdev = bus->host_pci;
 	int i, err;
 	u32 spromctl;
+	u16 size = bus->sprom_size;
 
 	ssb_printk(KERN_NOTICE PFX "Writing SPROM. Do NOT turn off the power! Please stand by...\n");
 	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
@@ -266,12 +267,12 @@ static int sprom_do_write(struct ssb_bus
 		goto err_ctlreg;
 	ssb_printk(KERN_NOTICE PFX "[ 0%%");
 	msleep(500);
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
-		if (i == SSB_SPROMSIZE_WORDS / 4)
+	for (i = 0; i < size; i++) {
+		if (i == size / 4)
 			ssb_printk("25%%");
-		else if (i == SSB_SPROMSIZE_WORDS / 2)
+		else if (i == size / 2)
 			ssb_printk("50%%");
-		else if (i == (SSB_SPROMSIZE_WORDS / 4) * 3)
+		else if (i == (size * 3) / 4)
 			ssb_printk("75%%");
 		else if (i % 2)
 			ssb_printk(".");
@@ -350,71 +351,76 @@ static void sprom_extract_r1(struct ssb_
 	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
 	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
 	     SSB_SPROM1_AGAIN_BG_SHIFT);
-	for (i = 0; i < 4; i++) {
-		v = in[SPOFF(SSB_SPROM1_OEM) + i];
-		*(((__le16 *)out->oem) + i) = cpu_to_le16(v);
-	}
 }
 
-static void sprom_extract_r2(struct ssb_sprom_r2 *out, const u16 *in)
+static void sprom_extract_r123(struct ssb_sprom_data *out, const u16 *in,
+			       int rev)
 {
 	int i;
 	u16 v;
 
-	SPEX(boardflags_hi, SSB_SPROM2_BFLHI,  0xFFFF, 0);
-	SPEX(maxpwr_a_hi, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_HI, 0);
-	SPEX(maxpwr_a_lo, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_LO,
-	     SSB_SPROM2_MAXP_A_LO_SHIFT);
-	SPEX(pa1lob0, SSB_SPROM2_PA1LOB0, 0xFFFF, 0);
-	SPEX(pa1lob1, SSB_SPROM2_PA1LOB1, 0xFFFF, 0);
-	SPEX(pa1lob2, SSB_SPROM2_PA1LOB2, 0xFFFF, 0);
-	SPEX(pa1hib0, SSB_SPROM2_PA1HIB0, 0xFFFF, 0);
-	SPEX(pa1hib1, SSB_SPROM2_PA1HIB1, 0xFFFF, 0);
-	SPEX(pa1hib2, SSB_SPROM2_PA1HIB2, 0xFFFF, 0);
-	SPEX(ofdm_pwr_off, SSB_SPROM2_OPO, SSB_SPROM2_OPO_VALUE, 0);
-	for (i = 0; i < 4; i++) {
-		v = in[SPOFF(SSB_SPROM2_CCODE) + i];
-		*(((__le16 *)out->country_str) + i) = cpu_to_le16(v);
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
+		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
 	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_ET0MAC) + i];
+		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM1_ET1MAC) + i];
+		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
+	}
+	SPEX(et0phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0A, 0);
+	SPEX(et1phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1A,
+	     SSB_SPROM1_ETHPHY_ET1A_SHIFT);
+	SPEX(country_code, SSB_SPROM1_BINF, SSB_SPROM1_BINF_CCODE,
+	     SSB_SPROM1_BINF_CCODE_SHIFT);
+	SPEX(pa0b0, SSB_SPROM1_PA0B0, 0xFFFF, 0);
+	SPEX(pa0b1, SSB_SPROM1_PA0B1, 0xFFFF, 0);
+	SPEX(pa0b2, SSB_SPROM1_PA0B2, 0xFFFF, 0);
+	SPEX(pa1b0, SSB_SPROM1_PA1B0, 0xFFFF, 0);
+	SPEX(pa1b1, SSB_SPROM1_PA1B1, 0xFFFF, 0);
+	SPEX(pa1b2, SSB_SPROM1_PA1B2, 0xFFFF, 0);
+	SPEX(gpio0, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P0, 0);
+	SPEX(gpio1, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P1,
+	     SSB_SPROM1_GPIOA_P1_SHIFT);
+	SPEX(gpio2, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P2, 0);
+	SPEX(gpio3, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P3,
+	     SSB_SPROM1_GPIOB_P3_SHIFT);
+	SPEX(maxpwr_a, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_A,
+	     SSB_SPROM1_MAXPWR_A_SHIFT);
+	SPEX(maxpwr_bg, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_BG, 0);
+	SPEX(itssi_a, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_A,
+	     SSB_SPROM1_ITSSI_A_SHIFT);
+	SPEX(itssi_bg, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_BG, 0);
+	SPEX(boardflags_lo, SSB_SPROM1_BFLLO, 0xFFFF, 0);
+	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
+	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
+	     SSB_SPROM1_AGAIN_BG_SHIFT);
 }
 
-static void sprom_extract_r3(struct ssb_sprom_r3 *out, const u16 *in)
-{
-	out->ofdmapo  = (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0xFF00) >> 8;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0x00FF) << 8;
-	out->ofdmapo <<= 16;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0xFF00) >> 8;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0x00FF) << 8;
-
-	out->ofdmalpo  = (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0xFF00) >> 8;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0x00FF) << 8;
-	out->ofdmalpo <<= 16;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0xFF00) >> 8;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0x00FF) << 8;
-
-	out->ofdmahpo  = (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0xFF00) >> 8;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0x00FF) << 8;
-	out->ofdmahpo <<= 16;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0xFF00) >> 8;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0x00FF) << 8;
-
-	SPEX(gpioldc_on_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_ON,
-	     SSB_SPROM3_GPIOLDC_ON_SHIFT);
-	SPEX(gpioldc_off_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_OFF,
-	     SSB_SPROM3_GPIOLDC_OFF_SHIFT);
-	SPEX(cckpo_1M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_1M, 0);
-	SPEX(cckpo_2M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_2M,
-	     SSB_SPROM3_CCKPO_2M_SHIFT);
-	SPEX(cckpo_55M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_55M,
-	     SSB_SPROM3_CCKPO_55M_SHIFT);
-	SPEX(cckpo_11M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_11M,
-	     SSB_SPROM3_CCKPO_11M_SHIFT);
-
-	out->ofdmgpo  = (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0xFF00) >> 8;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0x00FF) << 8;
-	out->ofdmgpo <<= 16;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0xFF00) >> 8;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0x00FF) << 8;
+static void sprom_extract_r4(struct ssb_sprom_data *out, const u16 *in)
+{
+	int i;
+	u16 v;
+
+	/* extract the r1 variables */
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM4_IL0MAC) + i];
+		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
+		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
+		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
+	}
+	SPEX(et0phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET0A, 0);
+	SPEX(et1phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET1A,
+	     SSB_SPROM4_ETHPHY_ET1A_SHIFT);
+	SPEX(country_code, SSB_SPROM4_CCODE, 0xFFFF, 0);
+	SPEX(boardflags_lo, SSB_SPROM4_BFLLO, 0xFFFF, 0);
+	SPEX(antenna_gain_a, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_0, 0);
+	SPEX(antenna_gain_bg, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_1,
+	     SSB_SPROM4_AGAIN_1_SHIFT);
+	/* TODO - get remaining rev 4 stuff needed */
 }
 
 static int sprom_extract(struct ssb_bus *bus,
@@ -431,16 +437,21 @@ static int sprom_extract(struct ssb_bus 
 		 * number stored in the SPROM.
 		 * Always extract r1. */
 		sprom_extract_r1(&out->r1, in);
+		sprom_extract_r123(&out->data, in, out->revision);
+	} else if (bus->chip_id == 0x4321) {
+		/* the BCM4328 has a chipid == 0x4321 and a rev 4 SPROM */
+		out->revision = 4;
+		sprom_extract_r4(&out->data, in);
 	} else {
 		if (out->revision == 0)
 			goto unsupported;
-		if (out->revision >= 1 && out->revision <= 3)
+		if (out->revision >= 1 && out->revision <= 3) {
 			sprom_extract_r1(&out->r1, in);
-		if (out->revision >= 2 && out->revision <= 3)
-			sprom_extract_r2(&out->r2, in);
-		if (out->revision == 3)
-			sprom_extract_r3(&out->r3, in);
-		if (out->revision >= 4)
+			sprom_extract_r123(&out->data, in, out->revision);
+		}
+		if (out->revision == 4)
+			sprom_extract_r4(&out->data, in);
+		if (out->revision >= 5)
 			goto unsupported;
 	}
 
@@ -458,14 +469,29 @@ static int ssb_pci_sprom_get(struct ssb_
 	int err = -ENOMEM;
 	u16 *buf;
 
-	buf = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	buf = kcalloc(SSB_SPROMSIZE_WORDS_R123, sizeof(u16), GFP_KERNEL);
 	if (!buf)
 		goto out;
+	bus->sprom_size = SSB_SPROMSIZE_WORDS_R123;
 	sprom_do_read(bus, buf);
-	err = sprom_check_crc(buf);
+	err = sprom_check_crc(buf, bus->sprom_size);
 	if (err) {
-		ssb_printk(KERN_WARNING PFX
-			   "WARNING: Invalid SPROM CRC (corrupt SPROM)\n");
+		/* check for rev 4 sprom - has special signature */
+		if (buf [32] == 0x5372) {
+			ssb_printk(KERN_WARNING PFX "Extracting a rev 4"
+				   " SPROM\n");
+			kfree(buf);
+			buf = kcalloc(SSB_SPROMSIZE_WORDS_R4, sizeof(u16),
+				      GFP_KERNEL);
+			if (!buf)
+				goto out;
+			bus->sprom_size = SSB_SPROMSIZE_WORDS_R4;
+			sprom_do_read(bus, buf);
+			err = sprom_check_crc(buf, bus->sprom_size);
+		}
+		if (err)
+			ssb_printk(KERN_WARNING PFX "WARNING: Invalid"
+				   " SPROM CRC (corrupt SPROM)\n");
 	}
 	err = sprom_extract(bus, sprom, buf);
 
@@ -581,29 +607,28 @@ const struct ssb_bus_ops ssb_pci_ops = {
 	.write32	= ssb_pci_write32,
 };
 
-static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len)
+static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len, u16 size)
 {
 	int i, pos = 0;
 
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
+	for (i = 0; i < size; i++)
 		pos += snprintf(buf + pos, buf_len - pos - 1,
 				"%04X", swab16(sprom[i]) & 0xFFFF);
-	}
 	pos += snprintf(buf + pos, buf_len - pos - 1, "\n");
 
 	return pos + 1;
 }
 
-static int hex2sprom(u16 *sprom, const char *dump, size_t len)
+static int hex2sprom(u16 *sprom, const char *dump, size_t len, u16 size)
 {
 	char tmp[5] = { 0 };
 	int cnt = 0;
 	unsigned long parsed;
 
-	if (len < SSB_SPROMSIZE_BYTES * 2)
+	if (len < size * 2)
 		return -EINVAL;
 
-	while (cnt < SSB_SPROMSIZE_WORDS) {
+	while (cnt < size) {
 		memcpy(tmp, dump, 4);
 		dump += 4;
 		parsed = simple_strtoul(tmp, NULL, 16);
@@ -627,7 +652,7 @@ static ssize_t ssb_pci_attr_sprom_show(s
 	if (!bus)
 		goto out;
 	err = -ENOMEM;
-	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	sprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);
 	if (!sprom)
 		goto out;
 
@@ -640,7 +665,7 @@ static ssize_t ssb_pci_attr_sprom_show(s
 	sprom_do_read(bus, sprom);
 	mutex_unlock(&bus->pci_sprom_mutex);
 
-	count = sprom2hex(sprom, buf, PAGE_SIZE);
+	count = sprom2hex(sprom, buf, PAGE_SIZE, bus->sprom_size);
 	err = 0;
 
 out_kfree:
@@ -662,15 +687,15 @@ static ssize_t ssb_pci_attr_sprom_store(
 	if (!bus)
 		goto out;
 	err = -ENOMEM;
-	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	sprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);
 	if (!sprom)
 		goto out;
-	err = hex2sprom(sprom, buf, count);
+	err = hex2sprom(sprom, buf, count, bus->sprom_size);
 	if (err) {
 		err = -EINVAL;
 		goto out_kfree;
 	}
-	err = sprom_check_crc(sprom);
+	err = sprom_check_crc(sprom, bus->sprom_size);
 	if (err) {
 		err = -EINVAL;
 		goto out_kfree;
Index: wireless-2.6/drivers/ssb/main.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/main.c
+++ wireless-2.6/drivers/ssb/main.c
@@ -871,14 +871,20 @@ EXPORT_SYMBOL(ssb_clockspeed);
 
 static u32 ssb_tmslow_reject_bitmask(struct ssb_device *dev)
 {
+	u32 rev = ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV;
+
 	/* The REJECT bit changed position in TMSLOW between
 	 * Backplane revisions. */
-	switch (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV) {
+	switch (rev) {
 	case SSB_IDLOW_SSBREV_22:
 		return SSB_TMSLOW_REJECT_22;
 	case SSB_IDLOW_SSBREV_23:
 		return SSB_TMSLOW_REJECT_23;
+	case SSB_IDLOW_SSBREV_24:     /* TODO - find the proper REJECT bits */
+	case SSB_IDLOW_SSBREV_27:     /* same here */
+		return SSB_TMSLOW_REJECT_23 | SSB_TMSLOW_REJECT_22;
 	default:
+		printk(KERN_INFO "ssb: Backplane Revision 0x%.8X\n", rev);
 		WARN_ON(1);
 	}
 	return (SSB_TMSLOW_REJECT_22 | SSB_TMSLOW_REJECT_23);
Index: wireless-2.6/include/linux/ssb/ssb.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb.h
+++ wireless-2.6/include/linux/ssb/ssb.h
@@ -312,6 +312,7 @@ struct ssb_bus {
 	/* ID information about the Chip. */
 	u16 chip_id;
 	u16 chip_rev;
+	u16 sprom_size;		/* number of words in sprom */
 	u8 chip_package;
 
 	/* List of devices (cores) on the backplane. */
Index: wireless-2.6/include/linux/ssb/ssb_regs.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb_regs.h
+++ wireless-2.6/include/linux/ssb/ssb_regs.h
@@ -147,6 +147,8 @@
 #define  SSB_IDLOW_SSBREV	0xF0000000 /* Sonics Backplane Revision code */
 #define  SSB_IDLOW_SSBREV_22	0x00000000 /* <= 2.2 */
 #define  SSB_IDLOW_SSBREV_23	0x10000000 /* 2.3 */
+#define  SSB_IDLOW_SSBREV_24	0x40000000 /* 2.4 */
+#define  SSB_IDLOW_SSBREV_27	0x70000000 /* 2.? */
 #define SSB_IDHIGH		0x0FFC     /* SB Identification High */
 #define  SSB_IDHIGH_RCLO	0x0000000F /* Revision Code (low part) */
 #define  SSB_IDHIGH_CC		0x00008FF0 /* Core Code */
@@ -162,6 +164,10 @@
  */
 #define SSB_SPROMSIZE_WORDS		64
 #define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
+#define SSB_SPROMSIZE_WORDS_R123	64
+#define SSB_SPROMSIZE_WORDS_R4		220
+#define SSB_SPROMSIZE_BYTES_R123	(SSB_SPROMSIZE_WORDS_R123 * sizeof(u16))
+#define SSB_SPROMSIZE_BYTES_R4		(SSB_SPROMSIZE_WORDS_R4 * sizeof(u16))
 #define SSB_SPROM_BASE			0x1000
 #define SSB_SPROM_REVISION		0x107E
 #define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
@@ -263,6 +269,9 @@
 #define SSB_SPROM4_ANT_BG		0x105C  /* B/G Antennas */
 #define SSB_SPROM4_BFLLO		0x1044	/* Boardflags (low 16 bits) */
 #define SSB_SPROM4_AGAIN		0x105E	/* Antenna Gain (in dBm Q5.2) */
+#define  SSB_SPROM4_AGAIN_0		0x00FF	/* Antenna 0 */
+#define  SSB_SPROM4_AGAIN_1		0xFF00	/* Antenna 1 */
+#define  SSB_SPROM4_AGAIN_1_SHIFT	8
 #define SSB_SPROM4_BFLHI		0x1046  /* Board Flags Hi */
 #define SSB_SPROM4_MAXP_A		0x1000  /* Max Power A */
 #define SSB_SPROM4_MAXP_A_HI		0x00FF  /* Mask for Hi */
Index: wireless-2.6/drivers/ssb/b43_pci_bridge.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/b43_pci_bridge.c
+++ wireless-2.6/drivers/ssb/b43_pci_bridge.c
@@ -27,6 +27,7 @@ static const struct pci_device_id b43_pc
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4321) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4324) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4325) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4328) },
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, b43_pci_bridge_tbl);


From Larry.Finger at lwfinger.net  Tue Nov  6 20:15:31 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 06 Nov 2007 13:15:31 -0600
Subject: [RFC 3 of 6] b44: Convert to use of the new SPROM structure
Message-ID: <4730bd53.yVvid0NgFQXoiJkE%Larry.Finger@lwfinger.net>

Patch 3 of 6.

The b44 driver is changed to use the new SPROM data structure.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/drivers/net/b44.c
===================================================================
--- wireless-2.6.orig/drivers/net/b44.c
+++ wireless-2.6/drivers/net/b44.c
@@ -2060,11 +2060,11 @@ static int __devinit b44_get_invariants(
 
 	if (sdev->bus->bustype == SSB_BUSTYPE_SSB &&
 	    instance > 1) {
-		addr = sdev->bus->sprom.r1.et1mac;
-		bp->phy_addr = sdev->bus->sprom.r1.et1phyaddr;
+		addr = sdev->bus->sprom.data.et1mac;
+		bp->phy_addr = sdev->bus->sprom.data.et1phyaddr;
 	} else {
-		addr = sdev->bus->sprom.r1.et0mac;
-		bp->phy_addr = sdev->bus->sprom.r1.et0phyaddr;
+		addr = sdev->bus->sprom.data.et0mac;
+		bp->phy_addr = sdev->bus->sprom.data.et0phyaddr;
 	}
 	memcpy(bp->dev->dev_addr, addr, 6);
 


From Larry.Finger at lwfinger.net  Tue Nov  6 20:15:47 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 06 Nov 2007 13:15:47 -0600
Subject: [RFC 4 of 6] b43: Convert to use of the new SPROM structure
Message-ID: <4730bd63.SCEMV/0C8ibw0lSX%Larry.Finger@lwfinger.net>

Patch 4 of 6.

The b43 driver is modified to use the new SPROM structure.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.c
+++ wireless-2.6/drivers/net/wireless/b43/leds.c
@@ -187,10 +187,10 @@ void b43_leds_init(struct b43_wldev *dev
 	enum b43_led_behaviour behaviour;
 	bool activelow;
 
-	sprom[0] = bus->sprom.r1.gpio0;
-	sprom[1] = bus->sprom.r1.gpio1;
-	sprom[2] = bus->sprom.r1.gpio2;
-	sprom[3] = bus->sprom.r1.gpio3;
+	sprom[0] = bus->sprom.data.gpio0;
+	sprom[1] = bus->sprom.data.gpio1;
+	sprom[2] = bus->sprom.data.gpio2;
+	sprom[3] = bus->sprom.data.gpio3;
 
 	for (i = 0; i < 4; i++) {
 		if (sprom[i] == 0xFF) {
Index: wireless-2.6/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/lo.c
+++ wireless-2.6/drivers/net/wireless/b43/lo.c
@@ -264,8 +264,8 @@ static u16 lo_measure_feedthrough(struct
 		rfover |= pga;
 		rfover |= lna;
 		rfover |= trsw_rx;
-		if ((dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_EXTLNA) &&
-		    phy->rev > 6)
+		if ((dev->dev->bus->sprom.data.boardflags_lo & B43_BFL_EXTLNA)
+		    && phy->rev > 6)
 			rfover |= B43_PHY_RFOVERVAL_EXTLNA;
 
 		b43_phy_write(dev, B43_PHY_PGACTL, 0xE300);
@@ -634,7 +634,7 @@ static void lo_measure_setup(struct b43_
 			      & 0xFFFC);
 		if (phy->type == B43_PHYTYPE_G) {
 			if ((phy->rev >= 7) &&
-			    (sprom->r1.boardflags_lo & B43_BFL_EXTLNA)) {
+			    (sprom->data.boardflags_lo & B43_BFL_EXTLNA)) {
 				b43_phy_write(dev, B43_PHY_RFOVER, 0x933);
 			} else {
 				b43_phy_write(dev, B43_PHY_RFOVER, 0x133);
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -1924,7 +1924,7 @@ static int b43_gpio_init(struct b43_wlde
 		mask |= 0x0180;
 		set |= 0x0180;
 	}
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL) {
+	if (dev->dev->bus->sprom.data.boardflags_lo & B43_BFL_PACTRL) {
 		b43_write16(dev, B43_MMIO_GPIO_MASK,
 			    b43_read16(dev, B43_MMIO_GPIO_MASK)
 			    | 0x0200);
@@ -2289,7 +2289,7 @@ static void b43_periodic_every60sec(stru
 
 	if (!b43_has_hardware_pctl(phy))
 		b43_lo_g_ctl_mark_all_unused(dev);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI) {
+	if (dev->dev->bus->sprom.data.boardflags_lo & B43_BFL_RSSI) {
 		b43_mac_suspend(dev);
 		b43_calc_nrssi_slope(dev);
 		if ((phy->radio_ver == 0x2050) && (phy->radio_rev == 8)) {
@@ -3205,13 +3205,13 @@ static void b43_bluetooth_coext_enable(s
 	struct ssb_sprom *sprom = &dev->dev->bus->sprom;
 	u32 hf;
 
-	if (!(sprom->r1.boardflags_lo & B43_BFL_BTCOEXIST))
+	if (!(sprom->data.boardflags_lo & B43_BFL_BTCOEXIST))
 		return;
 	if (dev->phy.type != B43_PHYTYPE_B && !dev->phy.gmode)
 		return;
 
 	hf = b43_hf_read(dev);
-	if (sprom->r1.boardflags_lo & B43_BFL_BTCMOD)
+	if (sprom->data.boardflags_lo & B43_BFL_BTCMOD)
 		hf |= B43_HF_BTCOEXALT;
 	else
 		hf |= B43_HF_BTCOEX;
@@ -3345,7 +3345,7 @@ static int b43_wireless_core_init(struct
 		hf |= B43_HF_SYMW;
 		if (phy->rev == 1)
 			hf |= B43_HF_GDCW;
-		if (sprom->r1.boardflags_lo & B43_BFL_PACTRL)
+		if (sprom->data.boardflags_lo & B43_BFL_PACTRL)
 			hf |= B43_HF_OFDMPABOOST;
 	} else if (phy->type == B43_PHYTYPE_B) {
 		hf |= B43_HF_SYMW;
@@ -3856,20 +3856,20 @@ static void b43_sprom_fixup(struct ssb_b
 	/* boardflags workarounds */
 	if (bus->boardinfo.vendor == SSB_BOARDVENDOR_DELL &&
 	    bus->chip_id == 0x4301 && bus->boardinfo.rev == 0x74)
-		bus->sprom.r1.boardflags_lo |= B43_BFL_BTCOEXIST;
+		bus->sprom.data.boardflags_lo |= B43_BFL_BTCOEXIST;
 	if (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE &&
 	    bus->boardinfo.type == 0x4E && bus->boardinfo.rev > 0x40)
-		bus->sprom.r1.boardflags_lo |= B43_BFL_PACTRL;
+		bus->sprom.data.boardflags_lo |= B43_BFL_PACTRL;
 
 	/* Handle case when gain is not set in sprom */
-	if (bus->sprom.r1.antenna_gain_a == 0xFF)
-		bus->sprom.r1.antenna_gain_a = 2;
-	if (bus->sprom.r1.antenna_gain_bg == 0xFF)
-		bus->sprom.r1.antenna_gain_bg = 2;
+	if (bus->sprom.data.antenna_gain_a == 0xFF)
+		bus->sprom.data.antenna_gain_a = 2;
+	if (bus->sprom.data.antenna_gain_bg == 0xFF)
+		bus->sprom.data.antenna_gain_bg = 2;
 
 	/* Convert Antennagain values to Q5.2 */
-	bus->sprom.r1.antenna_gain_a <<= 2;
-	bus->sprom.r1.antenna_gain_bg <<= 2;
+	bus->sprom.data.antenna_gain_a <<= 2;
+	bus->sprom.data.antenna_gain_bg <<= 2;
 }
 
 static void b43_wireless_exit(struct ssb_device *dev, struct b43_wl *wl)
@@ -3902,10 +3902,10 @@ static int b43_wireless_init(struct ssb_
 	hw->max_noise = -110;
 	hw->queues = 1;		/* FIXME: hardware has more queues */
 	SET_IEEE80211_DEV(hw, dev->dev);
-	if (is_valid_ether_addr(sprom->r1.et1mac))
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.et1mac);
+	if (is_valid_ether_addr(sprom->data.et1mac))
+		SET_IEEE80211_PERM_ADDR(hw, sprom->data.et1mac);
 	else
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.il0mac);
+		SET_IEEE80211_PERM_ADDR(hw, sprom->data.il0mac);
 
 	/* Get and initialize struct b43_wl */
 	wl = hw_to_b43_wl(hw);
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c
+++ wireless-2.6/drivers/net/wireless/b43/phy.c
@@ -1139,7 +1139,7 @@ static void b43_phy_inita(struct b43_wld
 	} else {
 		b43_phy_setupg(dev);
 		if (phy->gmode &&
-		    (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL))
+		    (dev->dev->bus->sprom.data.boardflags_lo & B43_BFL_PACTRL))
 			b43_phy_write(dev, 0x046E, 0x03CF);
 		return;
 	}
@@ -1286,7 +1286,7 @@ static void b43_phy_initb4(struct b43_wl
 	if (phy->radio_ver == 0x2050)
 		b43_phy_write(dev, 0x002A, 0x88C2);
 	b43_set_txpower_g(dev, &phy->bbatt, &phy->rfatt, phy->tx_control);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI) {
+	if (dev->dev->bus->sprom.data.boardflags_lo & B43_BFL_RSSI) {
 		b43_calc_nrssi_slope(dev);
 		b43_calc_nrssi_threshold(dev);
 	}
@@ -1433,7 +1433,7 @@ static void b43_phy_initb6(struct b43_wl
 		b43_radio_write16(dev, 0x5A, 0x88);
 		b43_radio_write16(dev, 0x5B, 0x6B);
 		b43_radio_write16(dev, 0x5C, 0x0F);
-		if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_ALTIQ) {
+		if (dev->dev->bus->sprom.data.boardflags_lo & B43_BFL_ALTIQ) {
 			b43_radio_write16(dev, 0x5D, 0xFA);
 			b43_radio_write16(dev, 0x5E, 0xD8);
 		} else {
@@ -1525,7 +1525,7 @@ static void b43_phy_initb6(struct b43_wl
 		b43_phy_write(dev, 0x0062, 0x0007);
 		b43_radio_init2050(dev);
 		b43_lo_g_measure(dev);
-		if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI) {
+		if (dev->dev->bus->sprom.data.boardflags_lo & B43_BFL_RSSI) {
 			b43_calc_nrssi_slope(dev);
 			b43_calc_nrssi_threshold(dev);
 		}
@@ -1645,7 +1645,7 @@ static void b43_calc_loopback_gain(struc
 	b43_phy_write(dev, B43_PHY_RFOVERVAL,
 		      b43_phy_read(dev, B43_PHY_RFOVERVAL) & 0xCFFF);
 
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_EXTLNA) {
+	if (dev->dev->bus->sprom.data.boardflags_lo & B43_BFL_EXTLNA) {
 		if (phy->rev >= 7) {
 			b43_phy_write(dev, B43_PHY_RFOVER,
 				      b43_phy_read(dev, B43_PHY_RFOVER)
@@ -1812,7 +1812,7 @@ static void b43_phy_initg(struct b43_wld
 				       & 0x0FFF) | (phy->lo_control->
 						    tx_bias << 12));
 		}
-		if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL)
+		if (dev->dev->bus->sprom.data.boardflags_lo & B43_BFL_PACTRL)
 			b43_phy_write(dev, B43_PHY_BASE(0x2E), 0x8075);
 		else
 			b43_phy_write(dev, B43_PHY_BASE(0x2E), 0x807F);
@@ -1826,7 +1826,7 @@ static void b43_phy_initg(struct b43_wld
 		b43_phy_write(dev, B43_PHY_LO_MASK, 0x8078);
 	}
 
-	if (!(dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI)) {
+	if (!(dev->dev->bus->sprom.data.boardflags_lo & B43_BFL_RSSI)) {
 		/* The specs state to update the NRSSI LT with
 		 * the value 0x7FFFFFFF here. I think that is some weird
 		 * compiler optimization in the original driver.
@@ -2036,16 +2036,15 @@ void b43_phy_xmitpower(struct b43_wldev 
 			estimated_pwr =
 			    b43_phy_estimate_power_out(dev, average);
 
-			max_pwr = dev->dev->bus->sprom.r1.maxpwr_bg;
-			if ((dev->dev->bus->sprom.r1.
-			     boardflags_lo & B43_BFL_PACTRL)
-			    && (phy->type == B43_PHYTYPE_G))
+			max_pwr = dev->dev->bus->sprom.data.maxpwr_bg;
+			if ((dev->dev->bus->sprom.data.boardflags_lo
+			    & B43_BFL_PACTRL) && (phy->type == B43_PHYTYPE_G))
 				max_pwr -= 0x3;
 			if (unlikely(max_pwr <= 0)) {
 				b43warn(dev->wl,
 					"Invalid max-TX-power value in SPROM.\n");
 				max_pwr = 60;	/* fake it */
-				dev->dev->bus->sprom.r1.maxpwr_bg = max_pwr;
+				dev->dev->bus->sprom.data.maxpwr_bg = max_pwr;
 			}
 
 			/*TODO:
@@ -2103,7 +2102,7 @@ void b43_phy_xmitpower(struct b43_wldev 
 						    B43_TXCTL_TXMIX;
 						rfatt += 2;
 						bbatt += 2;
-					} else if (dev->dev->bus->sprom.r1.
+					} else if (dev->dev->bus->sprom.data.
 						   boardflags_lo &
 						   B43_BFL_PACTRL) {
 						bbatt += 4 * (rfatt - 2);
@@ -2179,13 +2178,13 @@ int b43_phy_init_tssi2dbm_table(struct b
 	s8 *dyn_tssi2dbm;
 
 	if (phy->type == B43_PHYTYPE_A) {
-		pab0 = (s16) (dev->dev->bus->sprom.r1.pa1b0);
-		pab1 = (s16) (dev->dev->bus->sprom.r1.pa1b1);
-		pab2 = (s16) (dev->dev->bus->sprom.r1.pa1b2);
+		pab0 = (s16) (dev->dev->bus->sprom.data.pa1b0);
+		pab1 = (s16) (dev->dev->bus->sprom.data.pa1b1);
+		pab2 = (s16) (dev->dev->bus->sprom.data.pa1b2);
 	} else {
-		pab0 = (s16) (dev->dev->bus->sprom.r1.pa0b0);
-		pab1 = (s16) (dev->dev->bus->sprom.r1.pa0b1);
-		pab2 = (s16) (dev->dev->bus->sprom.r1.pa0b2);
+		pab0 = (s16) (dev->dev->bus->sprom.data.pa0b0);
+		pab1 = (s16) (dev->dev->bus->sprom.data.pa0b1);
+		pab2 = (s16) (dev->dev->bus->sprom.data.pa0b2);
 	}
 
 	if ((dev->dev->bus->chip_id == 0x4301) && (phy->radio_ver != 0x2050)) {
@@ -2198,17 +2197,17 @@ int b43_phy_init_tssi2dbm_table(struct b
 	    pab0 != -1 && pab1 != -1 && pab2 != -1) {
 		/* The pabX values are set in SPROM. Use them. */
 		if (phy->type == B43_PHYTYPE_A) {
-			if ((s8) dev->dev->bus->sprom.r1.itssi_a != 0 &&
-			    (s8) dev->dev->bus->sprom.r1.itssi_a != -1)
+			if ((s8) dev->dev->bus->sprom.data.itssi_a != 0 &&
+			    (s8) dev->dev->bus->sprom.data.itssi_a != -1)
 				phy->tgt_idle_tssi =
-				    (s8) (dev->dev->bus->sprom.r1.itssi_a);
+				    (s8) (dev->dev->bus->sprom.data.itssi_a);
 			else
 				phy->tgt_idle_tssi = 62;
 		} else {
-			if ((s8) dev->dev->bus->sprom.r1.itssi_bg != 0 &&
-			    (s8) dev->dev->bus->sprom.r1.itssi_bg != -1)
+			if ((s8) dev->dev->bus->sprom.data.itssi_bg != 0 &&
+			    (s8) dev->dev->bus->sprom.data.itssi_bg != -1)
 				phy->tgt_idle_tssi =
-				    (s8) (dev->dev->bus->sprom.r1.itssi_bg);
+				    (s8) (dev->dev->bus->sprom.data.itssi_bg);
 			else
 				phy->tgt_idle_tssi = 62;
 		}
@@ -3114,7 +3113,7 @@ void b43_calc_nrssi_threshold(struct b43
 			if (phy->radio_ver != 0x2050)
 				return;
 			if (!
-			    (dev->dev->bus->sprom.r1.
+			    (dev->dev->bus->sprom.data.
 			     boardflags_lo & B43_BFL_RSSI))
 				return;
 
@@ -3145,7 +3144,7 @@ void b43_calc_nrssi_threshold(struct b43
 		}
 	case B43_PHYTYPE_G:
 		if (!phy->gmode ||
-		    !(dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI)) {
+		    !(dev->dev->bus->sprom.data.boardflags_lo & B43_BFL_RSSI)) {
 			tmp16 = b43_nrssi_hw_read(dev, 0x20);
 			if (tmp16 >= 0x20)
 				tmp16 -= 0x40;
@@ -3667,7 +3666,7 @@ static u16 radio2050_rfover_val(struct b
 		}
 
 		if ((phy->rev < 7) ||
-		    !(sprom->r1.boardflags_lo & B43_BFL_EXTLNA)) {
+		    !(sprom->data.boardflags_lo & B43_BFL_EXTLNA)) {
 			if (phy_register == B43_PHY_RFOVER) {
 				return 0x1B3;
 			} else if (phy_register == B43_PHY_RFOVERVAL) {
@@ -3707,7 +3706,7 @@ static u16 radio2050_rfover_val(struct b
 		}
 	} else {
 		if ((phy->rev < 7) ||
-		    !(sprom->r1.boardflags_lo & B43_BFL_EXTLNA)) {
+		    !(sprom->data.boardflags_lo & B43_BFL_EXTLNA)) {
 			if (phy_register == B43_PHY_RFOVER) {
 				return 0x1B3;
 			} else if (phy_register == B43_PHY_RFOVERVAL) {
@@ -4186,7 +4185,7 @@ int b43_radio_selectchannel(struct b43_w
 		b43_write16(dev, B43_MMIO_CHANNEL, channel2freq_bg(channel));
 
 		if (channel == 14) {
-			if (dev->dev->bus->sprom.r1.country_code ==
+			if (dev->dev->bus->sprom.data.country_code ==
 			    SSB_SPROM1CCODE_JAPAN)
 				b43_hf_write(dev,
 					     b43_hf_read(dev) & ~B43_HF_ACPR);
Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c
+++ wireless-2.6/drivers/net/wireless/b43/xmit.c
@@ -385,7 +385,7 @@ static s8 b43_rssi_postprocess(struct b4
 			else
 				tmp -= 3;
 		} else {
-			if (dev->dev->bus->sprom.r1.
+			if (dev->dev->bus->sprom.data.
 			    boardflags_lo & B43_BFL_RSSI) {
 				if (in_rssi > 63)
 					in_rssi = 63;


From Larry.Finger at lwfinger.net  Tue Nov  6 20:16:05 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 06 Nov 2007 13:16:05 -0600
Subject: [RFC 5 of 6] b43legacy: Convert to use of the new SPROM structure
Message-ID: <4730bd75.jwiBAv3atOVcVl2f%Larry.Finger@lwfinger.net>

Patch 5 of 6.

The b43legacy driver is modified to use the new SPROM structure.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/drivers/net/wireless/b43legacy/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/leds.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/leds.c
@@ -189,10 +189,10 @@ void b43legacy_leds_init(struct b43legac
 	enum b43legacy_led_behaviour behaviour;
 	bool activelow;
 
-	sprom[0] = bus->sprom.r1.gpio0;
-	sprom[1] = bus->sprom.r1.gpio1;
-	sprom[2] = bus->sprom.r1.gpio2;
-	sprom[3] = bus->sprom.r1.gpio3;
+	sprom[0] = bus->sprom.data.gpio0;
+	sprom[1] = bus->sprom.data.gpio1;
+	sprom[2] = bus->sprom.data.gpio2;
+	sprom[3] = bus->sprom.data.gpio3;
 
 	for (i = 0; i < 4; i++) {
 		if (sprom[i] == 0xFF) {
Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -1753,7 +1753,7 @@ static int b43legacy_gpio_init(struct b4
 		mask |= 0x0060;
 		set |= 0x0060;
 	}
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_PACTRL) {
+	if (dev->dev->bus->sprom.data.boardflags_lo & B43legacy_BFL_PACTRL) {
 		b43legacy_write16(dev, B43legacy_MMIO_GPIO_MASK,
 				  b43legacy_read16(dev,
 				  B43legacy_MMIO_GPIO_MASK)
@@ -2130,7 +2130,7 @@ static void b43legacy_periodic_every120s
 static void b43legacy_periodic_every60sec(struct b43legacy_wldev *dev)
 {
 	b43legacy_phy_lo_mark_all_unused(dev);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_RSSI) {
+	if (dev->dev->bus->sprom.data.boardflags_lo & B43legacy_BFL_RSSI) {
 		b43legacy_mac_suspend(dev);
 		b43legacy_calc_nrssi_slope(dev);
 		b43legacy_mac_enable(dev);
@@ -3055,7 +3055,7 @@ static int b43legacy_wireless_core_init(
 		hf |= B43legacy_HF_SYMW;
 		if (phy->rev == 1)
 			hf |= B43legacy_HF_GDCW;
-		if (sprom->r1.boardflags_lo & B43legacy_BFL_PACTRL)
+		if (sprom->data.boardflags_lo & B43legacy_BFL_PACTRL)
 			hf |= B43legacy_HF_OFDMPABOOST;
 	} else if (phy->type == B43legacy_PHYTYPE_B) {
 		hf |= B43legacy_HF_SYMW;
@@ -3534,12 +3534,12 @@ static void b43legacy_sprom_fixup(struct
 	if (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE &&
 	    bus->boardinfo.type == 0x4E &&
 	    bus->boardinfo.rev > 0x40)
-		bus->sprom.r1.boardflags_lo |= B43legacy_BFL_PACTRL;
+		bus->sprom.data.boardflags_lo |= B43legacy_BFL_PACTRL;
 
 	/* Convert Antennagain values to Q5.2 */
-	if (bus->sprom.r1.antenna_gain_bg == 0xFF)
-		bus->sprom.r1.antenna_gain_bg = 2; /* if unset, use 2 dBm */
-	bus->sprom.r1.antenna_gain_bg <<= 2;
+	if (bus->sprom.data.antenna_gain_bg == 0xFF)
+		bus->sprom.data.antenna_gain_bg = 2; /* if unset, use 2 dBm */
+	bus->sprom.data.antenna_gain_bg <<= 2;
 }
 
 static void b43legacy_wireless_exit(struct ssb_device *dev,
@@ -3574,10 +3574,10 @@ static int b43legacy_wireless_init(struc
 	hw->max_noise = -110;
 	hw->queues = 1; /* FIXME: hardware has more queues */
 	SET_IEEE80211_DEV(hw, dev->dev);
-	if (is_valid_ether_addr(sprom->r1.et1mac))
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.et1mac);
+	if (is_valid_ether_addr(sprom->data.et1mac))
+		SET_IEEE80211_PERM_ADDR(hw, sprom->data.et1mac);
 	else
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.il0mac);
+		SET_IEEE80211_PERM_ADDR(hw, sprom->data.il0mac);
 
 	/* Get and initialize struct b43legacy_wl */
 	wl = hw_to_b43legacy_wl(hw);
Index: wireless-2.6/drivers/net/wireless/b43legacy/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/phy.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/phy.c
@@ -441,7 +441,7 @@ static void b43legacy_phy_inita(struct b
 	might_sleep();
 
 	b43legacy_phy_setupg(dev);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_PACTRL)
+	if (dev->dev->bus->sprom.data.boardflags_lo & B43legacy_BFL_PACTRL)
 		b43legacy_phy_write(dev, 0x046E, 0x03CF);
 }
 
@@ -543,7 +543,7 @@ static void b43legacy_phy_initb4(struct 
 	if (phy->radio_ver == 0x2050)
 		b43legacy_phy_write(dev, 0x002A, 0x88C2);
 	b43legacy_radio_set_txpower_bg(dev, 0xFFFF, 0xFFFF, 0xFFFF);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_RSSI) {
+	if (dev->dev->bus->sprom.data.boardflags_lo & B43legacy_BFL_RSSI) {
 		b43legacy_calc_nrssi_slope(dev);
 		b43legacy_calc_nrssi_threshold(dev);
 	}
@@ -699,7 +699,7 @@ static void b43legacy_phy_initb6(struct 
 		b43legacy_radio_write16(dev, 0x005A, 0x0088);
 		b43legacy_radio_write16(dev, 0x005B, 0x006B);
 		b43legacy_radio_write16(dev, 0x005C, 0x000F);
-		if (dev->dev->bus->sprom.r1.boardflags_lo & 0x8000) {
+		if (dev->dev->bus->sprom.data.boardflags_lo & 0x8000) {
 			b43legacy_radio_write16(dev, 0x005D, 0x00FA);
 			b43legacy_radio_write16(dev, 0x005E, 0x00D8);
 		} else {
@@ -797,7 +797,7 @@ static void b43legacy_phy_initb6(struct 
 		b43legacy_phy_write(dev, 0x0062, 0x0007);
 		b43legacy_radio_init2050(dev);
 		b43legacy_phy_lo_g_measure(dev);
-		if (dev->dev->bus->sprom.r1.boardflags_lo &
+		if (dev->dev->bus->sprom.data.boardflags_lo &
 		    B43legacy_BFL_RSSI) {
 			b43legacy_calc_nrssi_slope(dev);
 			b43legacy_calc_nrssi_threshold(dev);
@@ -921,7 +921,7 @@ static void b43legacy_calc_loopback_gain
 			    b43legacy_phy_read(dev, 0x0811) | 0x0100);
 	b43legacy_phy_write(dev, 0x0812,
 			    b43legacy_phy_read(dev, 0x0812) & 0xCFFF);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_EXTLNA) {
+	if (dev->dev->bus->sprom.data.boardflags_lo & B43legacy_BFL_EXTLNA) {
 		if (phy->rev >= 7) {
 			b43legacy_phy_write(dev, 0x0811,
 					    b43legacy_phy_read(dev, 0x0811)
@@ -1072,7 +1072,7 @@ static void b43legacy_phy_initg(struct b
 			b43legacy_phy_write(dev, 0x0036,
 					    (b43legacy_phy_read(dev, 0x0036)
 					     & 0x0FFF) | (phy->txctl2 << 12));
-		if (dev->dev->bus->sprom.r1.boardflags_lo &
+		if (dev->dev->bus->sprom.data.boardflags_lo &
 		    B43legacy_BFL_PACTRL)
 			b43legacy_phy_write(dev, 0x002E, 0x8075);
 		else
@@ -1087,7 +1087,7 @@ static void b43legacy_phy_initg(struct b
 		b43legacy_phy_write(dev, 0x080F, 0x8078);
 	}
 
-	if (!(dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_RSSI)) {
+	if (!(dev->dev->bus->sprom.data.boardflags_lo & B43legacy_BFL_RSSI)) {
 		/* The specs state to update the NRSSI LT with
 		 * the value 0x7FFFFFFF here. I think that is some weird
 		 * compiler optimization in the original driver.
@@ -1838,9 +1838,9 @@ void b43legacy_phy_xmitpower(struct b43l
 
 	estimated_pwr = b43legacy_phy_estimate_power_out(dev, average);
 
-	max_pwr = dev->dev->bus->sprom.r1.maxpwr_bg;
+	max_pwr = dev->dev->bus->sprom.data.maxpwr_bg;
 
-	if ((dev->dev->bus->sprom.r1.boardflags_lo
+	if ((dev->dev->bus->sprom.data.boardflags_lo
 	     & B43legacy_BFL_PACTRL) &&
 	    (phy->type == B43legacy_PHYTYPE_G))
 		max_pwr -= 0x3;
@@ -1848,7 +1848,7 @@ void b43legacy_phy_xmitpower(struct b43l
 		b43legacywarn(dev->wl, "Invalid max-TX-power value in SPROM."
 			"\n");
 		max_pwr = 74; /* fake it */
-		dev->dev->bus->sprom.r1.maxpwr_bg = max_pwr;
+		dev->dev->bus->sprom.data.maxpwr_bg = max_pwr;
 	}
 
 	/* Use regulatory information to get the maximum power.
@@ -1858,7 +1858,8 @@ void b43legacy_phy_xmitpower(struct b43l
 	 * and 1.5 dBm (a safety factor??). The result is in Q5.2 format
 	 * which accounts for the factor of 4 */
 #define REG_MAX_PWR 20
-	max_pwr = min(REG_MAX_PWR * 4 - dev->dev->bus->sprom.r1.antenna_gain_bg
+	max_pwr = min(REG_MAX_PWR * 4
+		      - dev->dev->bus->sprom.data.antenna_gain_bg
 		      - 0x6, max_pwr);
 
 	/* find the desired power in Q5.2 - power_level is in dBm
@@ -1918,7 +1919,7 @@ void b43legacy_phy_xmitpower(struct b43l
 				txpower = 3;
 				radio_attenuation += 2;
 				baseband_attenuation += 2;
-			} else if (dev->dev->bus->sprom.r1.boardflags_lo
+			} else if (dev->dev->bus->sprom.data.boardflags_lo
 				   & B43legacy_BFL_PACTRL) {
 				baseband_attenuation += 4 *
 						     (radio_attenuation - 2);
@@ -2000,9 +2001,9 @@ int b43legacy_phy_init_tssi2dbm_table(st
 
 	B43legacy_WARN_ON(!(phy->type == B43legacy_PHYTYPE_B ||
 			  phy->type == B43legacy_PHYTYPE_G));
-	pab0 = (s16)(dev->dev->bus->sprom.r1.pa0b0);
-	pab1 = (s16)(dev->dev->bus->sprom.r1.pa0b1);
-	pab2 = (s16)(dev->dev->bus->sprom.r1.pa0b2);
+	pab0 = (s16)(dev->dev->bus->sprom.data.pa0b0);
+	pab1 = (s16)(dev->dev->bus->sprom.data.pa0b1);
+	pab2 = (s16)(dev->dev->bus->sprom.data.pa0b2);
 
 	if ((dev->dev->bus->chip_id == 0x4301) && (phy->radio_ver != 0x2050)) {
 		phy->idle_tssi = 0x34;
@@ -2013,9 +2014,10 @@ int b43legacy_phy_init_tssi2dbm_table(st
 	if (pab0 != 0 && pab1 != 0 && pab2 != 0 &&
 	    pab0 != -1 && pab1 != -1 && pab2 != -1) {
 		/* The pabX values are set in SPROM. Use them. */
-		if ((s8)dev->dev->bus->sprom.r1.itssi_bg != 0 &&
-		    (s8)dev->dev->bus->sprom.r1.itssi_bg != -1)
-			phy->idle_tssi = (s8)(dev->dev->bus->sprom.r1.itssi_bg);
+		if ((s8)dev->dev->bus->sprom.data.itssi_bg != 0 &&
+		    (s8)dev->dev->bus->sprom.data.itssi_bg != -1)
+			phy->idle_tssi = (s8)(dev->dev->bus->sprom.data.
+					  itssi_bg);
 		else
 			phy->idle_tssi = 62;
 		dyn_tssi2dbm = kmalloc(64, GFP_KERNEL);
Index: wireless-2.6/drivers/net/wireless/b43legacy/radio.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/radio.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/radio.c
@@ -827,7 +827,7 @@ void b43legacy_calc_nrssi_threshold(stru
 	case B43legacy_PHYTYPE_B: {
 		if (phy->radio_ver != 0x2050)
 			return;
-		if (!(dev->dev->bus->sprom.r1.boardflags_lo &
+		if (!(dev->dev->bus->sprom.data.boardflags_lo &
 		    B43legacy_BFL_RSSI))
 			return;
 
@@ -857,7 +857,7 @@ void b43legacy_calc_nrssi_threshold(stru
 	}
 	case B43legacy_PHYTYPE_G:
 		if (!phy->gmode ||
-		    !(dev->dev->bus->sprom.r1.boardflags_lo &
+		    !(dev->dev->bus->sprom.data.boardflags_lo &
 		    B43legacy_BFL_RSSI)) {
 			tmp16 = b43legacy_nrssi_hw_read(dev, 0x20);
 			if (tmp16 >= 0x20)
@@ -1406,7 +1406,7 @@ static u16 b43legacy_get_812_value(struc
 	if (!phy->gmode)
 		return 0;
 	if (!has_loopback_gain(phy)) {
-		if (phy->rev < 7 || !(dev->dev->bus->sprom.r1.boardflags_lo
+		if (phy->rev < 7 || !(dev->dev->bus->sprom.data.boardflags_lo
 		    & B43legacy_BFL_EXTLNA)) {
 			switch (lpd) {
 			case LPD(0, 1, 1):
@@ -1459,7 +1459,7 @@ static u16 b43legacy_get_812_value(struc
 		}
 
 		loop_or = (loop << 8) | extern_lna_control;
-		if (phy->rev >= 7 && dev->dev->bus->sprom.r1.boardflags_lo
+		if (phy->rev >= 7 && dev->dev->bus->sprom.data.boardflags_lo
 		    & B43legacy_BFL_EXTLNA) {
 			if (extern_lna_control)
 				loop_or |= 0x8000;
@@ -1550,7 +1550,7 @@ u16 b43legacy_radio_init2050(struct b43l
 					    b43legacy_get_812_value(dev,
 					    LPD(0, 1, 1)));
 			if (phy->rev < 7 ||
-			    !(dev->dev->bus->sprom.r1.boardflags_lo
+			    !(dev->dev->bus->sprom.data.boardflags_lo
 			    & B43legacy_BFL_EXTLNA))
 				b43legacy_phy_write(dev, 0x0811, 0x01B3);
 			else
@@ -1786,7 +1786,7 @@ int b43legacy_radio_selectchannel(struct
 			  channel2freq_bg(channel));
 
 	if (channel == 14) {
-		if (dev->dev->bus->sprom.r1.country_code == 5)   /* JAPAN) */
+		if (dev->dev->bus->sprom.data.country_code == 5)   /* JAPAN) */
 			b43legacy_shm_write32(dev, B43legacy_SHM_SHARED,
 					      B43legacy_UCODEFLAGS_OFFSET,
 					      b43legacy_shm_read32(dev,
Index: wireless-2.6/drivers/net/wireless/b43legacy/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/xmit.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/xmit.c
@@ -378,7 +378,7 @@ static s8 b43legacy_rssi_postprocess(str
 			else
 				tmp -= 3;
 		} else {
-			if (dev->dev->bus->sprom.r1.boardflags_lo
+			if (dev->dev->bus->sprom.data.boardflags_lo
 			    & B43legacy_BFL_RSSI) {
 				if (in_rssi > 63)
 					in_rssi = 63;


From Larry.Finger at lwfinger.net  Tue Nov  6 20:17:00 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 06 Nov 2007 13:17:00 -0600
Subject: [RFC 6 of 6] ssb: Remove the old, now unused, data structure
Message-ID: <4730bdac.Oup0h41hJ0GHVCxr%Larry.Finger@lwfinger.net>

Patch 6 of 6.

The old, now unused, data structures and SPROM extraction routines
are removed.

Signed-off-by: Larry Finger<Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/include/linux/ssb/ssb.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb.h
+++ wireless-2.6/include/linux/ssb/ssb.h
@@ -15,69 +15,6 @@ struct pcmcia_device;
 struct ssb_bus;
 struct ssb_driver;
 
-
-struct ssb_sprom_r1 {
-	u16 pci_spid;		/* Subsystem Product ID for PCI */
-	u16 pci_svid;		/* Subsystem Vendor ID for PCI */
-	u16 pci_pid;		/* Product ID for PCI */
-	u8 il0mac[6];		/* MAC address for 802.11b/g */
-	u8 et0mac[6];		/* MAC address for Ethernet */
-	u8 et1mac[6];		/* MAC address for 802.11a */
-	u8 et0phyaddr:5;	/* MII address for enet0 */
-	u8 et1phyaddr:5;	/* MII address for enet1 */
-	u8 et0mdcport:1;	/* MDIO for enet0 */
-	u8 et1mdcport:1;	/* MDIO for enet1 */
-	u8 board_rev;		/* Board revision */
-	u8 country_code:4;	/* Country Code */
-	u8 antenna_a:2;		/* Antenna 0/1 available for A-PHY */
-	u8 antenna_bg:2;	/* Antenna 0/1 available for B-PHY and G-PHY */
-	u16 pa0b0;
-	u16 pa0b1;
-	u16 pa0b2;
-	u16 pa1b0;
-	u16 pa1b1;
-	u16 pa1b2;
-	u8 gpio0;		/* GPIO pin 0 */
-	u8 gpio1;		/* GPIO pin 1 */
-	u8 gpio2;		/* GPIO pin 2 */
-	u8 gpio3;		/* GPIO pin 3 */
-	u16 maxpwr_a;		/* A-PHY Power Amplifier Max Power (in dBm Q5.2) */
-	u16 maxpwr_bg;		/* B/G-PHY Power Amplifier Max Power (in dBm Q5.2) */
-	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
-	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
-	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
-	u8 antenna_gain_a;	/* A-PHY Antenna gain (in dBm Q5.2) */
-	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
-	u8 oem[8];		/* OEM string (rev 1 only) */
-};
-
-struct ssb_sprom_r2 {
-	u16 boardflags_hi;	/* Boardflags (high 16 bits) */
-	u8 maxpwr_a_lo;		/* A-PHY Max Power Low */
-	u8 maxpwr_a_hi;		/* A-PHY Max Power High */
-	u16 pa1lob0;		/* A-PHY PA Low Settings */
-	u16 pa1lob1;		/* A-PHY PA Low Settings */
-	u16 pa1lob2;		/* A-PHY PA Low Settings */
-	u16 pa1hib0;		/* A-PHY PA High Settings */
-	u16 pa1hib1;		/* A-PHY PA High Settings */
-	u16 pa1hib2;		/* A-PHY PA High Settings */
-	u8 ofdm_pwr_off;	/* OFDM Power Offset from CCK Level */
-	u8 country_str[2];	/* Two char Country Code */
-};
-
-struct ssb_sprom_r3 {
-	u32 ofdmapo;		/* A-PHY OFDM Mid Power Offset */
-	u32 ofdmalpo;		/* A-PHY OFDM Low Power Offset */
-	u32 ofdmahpo;		/* A-PHY OFDM High Power Offset */
-	u8 gpioldc_on_cnt;	/* GPIO LED Powersave Duty Cycle ON count */
-	u8 gpioldc_off_cnt;	/* GPIO LED Powersave Duty Cycle OFF count */
-	u8 cckpo_1M:4;		/* CCK Power Offset for Rate 1M */
-	u8 cckpo_2M:4;		/* CCK Power Offset for Rate 2M */
-	u8 cckpo_55M:4;		/* CCK Power Offset for Rate 5.5M */
-	u8 cckpo_11M:4;		/* CCK Power Offset for Rate 11M */
-	u32 ofdmgpo;		/* G-PHY OFDM Power Offset */
-};
-
 struct ssb_sprom_data {
 	u8 il0mac[6];		/* MAC address for 802.11b/g */
 	u8 et0mac[6];		/* MAC address for Ethernet */
@@ -109,16 +46,6 @@ struct ssb_sprom_data {
 struct ssb_sprom {
 	u8 revision;
 	u8 crc;
-	/* The valid r# fields are selected by the "revision".
-	 * Revision 3 and lower inherit from lower revisions.
-	 */
-	union {
-		struct {
-			struct ssb_sprom_r1 r1;
-			struct ssb_sprom_r2 r2;
-			struct ssb_sprom_r3 r3;
-		};
-	};
 	struct ssb_sprom_data data;
 };
 
Index: wireless-2.6/include/linux/ssb/ssb_regs.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb_regs.h
+++ wireless-2.6/include/linux/ssb/ssb_regs.h
@@ -173,10 +173,7 @@
 #define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
 #define  SSB_SPROM_REVISION_CRC		0xFF00	/* SPROM CRC8 value */
 #define  SSB_SPROM_REVISION_CRC_SHIFT	8
-/* SPROM Revision 1 */
-#define SSB_SPROM1_SPID			0x1004	/* Subsystem Product ID for PCI */
-#define SSB_SPROM1_SVID			0x1006	/* Subsystem Vendor ID for PCI */
-#define SSB_SPROM1_PID			0x1008	/* Product ID for PCI */
+/* SPROM Revision 1 - aslo used for Revisions 2 & 3 */
 #define SSB_SPROM1_IL0MAC		0x1048	/* 6 bytes MAC address for 802.11b/g */
 #define SSB_SPROM1_ET0MAC		0x104E	/* 6 bytes MAC address for Ethernet */
 #define SSB_SPROM1_ET1MAC		0x1054	/* 6 bytes MAC address for 802.11a */
@@ -184,8 +181,6 @@
 #define  SSB_SPROM1_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
 #define  SSB_SPROM1_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
 #define  SSB_SPROM1_ETHPHY_ET1A_SHIFT	5
-#define  SSB_SPROM1_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
-#define  SSB_SPROM1_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
 #define SSB_SPROM1_BINF			0x105C	/* Board info */
 #define  SSB_SPROM1_BINF_BREV		0x00FF	/* Board Revision */
 #define  SSB_SPROM1_BINF_CCODE		0x0F00	/* Country Code */
@@ -221,41 +216,6 @@
 #define  SSB_SPROM1_AGAIN_A		0x00FF	/* A-PHY */
 #define  SSB_SPROM1_AGAIN_BG		0xFF00	/* B-PHY and G-PHY */
 #define  SSB_SPROM1_AGAIN_BG_SHIFT	8
-#define SSB_SPROM1_OEM			0x1076	/* 8 bytes OEM string (rev 1 only) */
-/* SPROM Revision 2 (inherits from rev 1) */
-#define SSB_SPROM2_BFLHI		0x1038	/* Boardflags (high 16 bits) */
-#define SSB_SPROM2_MAXP_A		0x103A	/* A-PHY Max Power */
-#define  SSB_SPROM2_MAXP_A_HI		0x00FF	/* Max Power High */
-#define  SSB_SPROM2_MAXP_A_LO		0xFF00	/* Max Power Low */
-#define  SSB_SPROM2_MAXP_A_LO_SHIFT	8
-#define SSB_SPROM2_PA1LOB0		0x103C	/* A-PHY PowerAmplifier Low Settings */
-#define SSB_SPROM2_PA1LOB1		0x103E	/* A-PHY PowerAmplifier Low Settings */
-#define SSB_SPROM2_PA1LOB2		0x1040	/* A-PHY PowerAmplifier Low Settings */
-#define SSB_SPROM2_PA1HIB0		0x1042	/* A-PHY PowerAmplifier High Settings */
-#define SSB_SPROM2_PA1HIB1		0x1044	/* A-PHY PowerAmplifier High Settings */
-#define SSB_SPROM2_PA1HIB2		0x1046	/* A-PHY PowerAmplifier High Settings */
-#define SSB_SPROM2_OPO			0x1078	/* OFDM Power Offset from CCK Level */
-#define  SSB_SPROM2_OPO_VALUE		0x00FF
-#define  SSB_SPROM2_OPO_UNUSED		0xFF00
-#define SSB_SPROM2_CCODE		0x107C	/* Two char Country Code */
-/* SPROM Revision 3 (inherits from rev 2) */
-#define SSB_SPROM3_OFDMAPO		0x102C	/* A-PHY OFDM Mid Power Offset (4 bytes, BigEndian) */
-#define SSB_SPROM3_OFDMALPO		0x1030	/* A-PHY OFDM Low Power Offset (4 bytes, BigEndian) */
-#define SSB_SPROM3_OFDMAHPO		0x1034	/* A-PHY OFDM High Power Offset (4 bytes, BigEndian) */
-#define SSB_SPROM3_GPIOLDC		0x1042	/* GPIO LED Powersave Duty Cycle (4 bytes, BigEndian) */
-#define  SSB_SPROM3_GPIOLDC_OFF		0x0000FF00	/* Off Count */
-#define  SSB_SPROM3_GPIOLDC_OFF_SHIFT	8
-#define  SSB_SPROM3_GPIOLDC_ON		0x00FF0000	/* On Count */
-#define  SSB_SPROM3_GPIOLDC_ON_SHIFT	16
-#define SSB_SPROM3_CCKPO		0x1078	/* CCK Power Offset */
-#define  SSB_SPROM3_CCKPO_1M		0x000F	/* 1M Rate PO */
-#define  SSB_SPROM3_CCKPO_2M		0x00F0	/* 2M Rate PO */
-#define  SSB_SPROM3_CCKPO_2M_SHIFT	4
-#define  SSB_SPROM3_CCKPO_55M		0x0F00	/* 5.5M Rate PO */
-#define  SSB_SPROM3_CCKPO_55M_SHIFT	8
-#define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
-#define  SSB_SPROM3_CCKPO_11M_SHIFT	12
-#define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
 /* SPROM Revision 4 */
 #define SSB_SPROM4_IL0MAC		0x104C	/* 6 byte MAC address for b/g */
 #define SSB_SPROM4_ETHPHY		0x105A	/* Ethernet PHY settings */
Index: wireless-2.6/drivers/ssb/pci.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/pci.c
+++ wireless-2.6/drivers/ssb/pci.c
@@ -297,62 +297,6 @@ err_ctlreg:
 	return err;
 }
 
-static void sprom_extract_r1(struct ssb_sprom_r1 *out, const u16 *in)
-{
-	int i;
-	u16 v;
-
-	SPEX(pci_spid, SSB_SPROM1_SPID, 0xFFFF, 0);
-	SPEX(pci_svid, SSB_SPROM1_SVID, 0xFFFF, 0);
-	SPEX(pci_pid, SSB_SPROM1_PID, 0xFFFF, 0);
-	for (i = 0; i < 3; i++) {
-		v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
-		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
-	}
-	for (i = 0; i < 3; i++) {
-		v = in[SPOFF(SSB_SPROM1_ET0MAC) + i];
-		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
-	}
-	for (i = 0; i < 3; i++) {
-		v = in[SPOFF(SSB_SPROM1_ET1MAC) + i];
-		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
-	}
-	SPEX(et0phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0A, 0);
-	SPEX(et1phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1A,
-	     SSB_SPROM1_ETHPHY_ET1A_SHIFT);
-	SPEX(et0mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0M, 14);
-	SPEX(et1mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1M, 15);
-	SPEX(board_rev, SSB_SPROM1_BINF, SSB_SPROM1_BINF_BREV, 0);
-	SPEX(country_code, SSB_SPROM1_BINF, SSB_SPROM1_BINF_CCODE,
-	     SSB_SPROM1_BINF_CCODE_SHIFT);
-	SPEX(antenna_a, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTA,
-	     SSB_SPROM1_BINF_ANTA_SHIFT);
-	SPEX(antenna_bg, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTBG,
-	     SSB_SPROM1_BINF_ANTBG_SHIFT);
-	SPEX(pa0b0, SSB_SPROM1_PA0B0, 0xFFFF, 0);
-	SPEX(pa0b1, SSB_SPROM1_PA0B1, 0xFFFF, 0);
-	SPEX(pa0b2, SSB_SPROM1_PA0B2, 0xFFFF, 0);
-	SPEX(pa1b0, SSB_SPROM1_PA1B0, 0xFFFF, 0);
-	SPEX(pa1b1, SSB_SPROM1_PA1B1, 0xFFFF, 0);
-	SPEX(pa1b2, SSB_SPROM1_PA1B2, 0xFFFF, 0);
-	SPEX(gpio0, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P0, 0);
-	SPEX(gpio1, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P1,
-	     SSB_SPROM1_GPIOA_P1_SHIFT);
-	SPEX(gpio2, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P2, 0);
-	SPEX(gpio3, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P3,
-	     SSB_SPROM1_GPIOB_P3_SHIFT);
-	SPEX(maxpwr_a, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_A,
-	     SSB_SPROM1_MAXPWR_A_SHIFT);
-	SPEX(maxpwr_bg, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_BG, 0);
-	SPEX(itssi_a, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_A,
-	     SSB_SPROM1_ITSSI_A_SHIFT);
-	SPEX(itssi_bg, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_BG, 0);
-	SPEX(boardflags_lo, SSB_SPROM1_BFLLO, 0xFFFF, 0);
-	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
-	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
-	     SSB_SPROM1_AGAIN_BG_SHIFT);
-}
-
 static void sprom_extract_r123(struct ssb_sprom_data *out, const u16 *in,
 			       int rev)
 {
@@ -436,7 +380,6 @@ static int sprom_extract(struct ssb_bus 
 		/* Workaround: The BCM44XX chip has a stupid revision
 		 * number stored in the SPROM.
 		 * Always extract r1. */
-		sprom_extract_r1(&out->r1, in);
 		sprom_extract_r123(&out->data, in, out->revision);
 	} else if (bus->chip_id == 0x4321) {
 		/* the BCM4328 has a chipid == 0x4321 and a rev 4 SPROM */
@@ -445,10 +388,8 @@ static int sprom_extract(struct ssb_bus 
 	} else {
 		if (out->revision == 0)
 			goto unsupported;
-		if (out->revision >= 1 && out->revision <= 3) {
-			sprom_extract_r1(&out->r1, in);
+		if (out->revision >= 1 && out->revision <= 3)
 			sprom_extract_r123(&out->data, in, out->revision);
-		}
 		if (out->revision == 4)
 			sprom_extract_r4(&out->data, in);
 		if (out->revision >= 5)
@@ -459,7 +400,7 @@ static int sprom_extract(struct ssb_bus 
 unsupported:
 	ssb_printk(KERN_WARNING PFX "Unsupported SPROM revision %d "
 		   "detected. Will extract v1\n", out->revision);
-	sprom_extract_r1(&out->r1, in);
+	sprom_extract_r123(&out->data, in, 1);
 	return 0;
 }
 


From mb at bu3sch.de  Tue Nov  6 20:22:41 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 6 Nov 2007 20:22:41 +0100
Subject: [RFC 1 of 6] ssb: Add new SPROM structure while keeping the old
In-Reply-To: <4730bd03.rGmiNlJ18XBoW/Yb%Larry.Finger@lwfinger.net>
References: <4730bd03.rGmiNlJ18XBoW/Yb%Larry.Finger@lwfinger.net>
Message-ID: <200711062022.41248.mb@bu3sch.de>

On Tuesday 06 November 2007 20:14:11 Larry Finger wrote:
> This is patch 1 of 6.
> 
> The SPROM's for various devices utilizing the Sonics Silicon Backplane come
> with various revisions. The Revision 2 SPROM inherited the data layout of 1, and
> Revision 3 inherited the layout of 2. The first instance of Revision 4 has
> now been found in a BCM4328 wireless LAN card. This device does not inherit any
> layout from previous versions. Although it was possible to create a data
> structure that kept all the old layouts, we decided to start fresh, keep only
> those SPROM variables that are used by the drivers that utilize ssb, and to
> do the conversion in such a manner that neither compilation or execution will
> be affected if a bisection lands in the middle of these changes, while keeping
> the patches as small as possible.
> 
> In this patch, the sprom structures are changed while maintaining the old ones.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Index: wireless-2.6/include/linux/ssb/ssb.h
> ===================================================================
> --- wireless-2.6.orig/include/linux/ssb/ssb.h
> +++ wireless-2.6/include/linux/ssb/ssb.h
> @@ -78,8 +78,32 @@ struct ssb_sprom_r3 {
>  	u32 ofdmgpo;		/* G-PHY OFDM Power Offset */
>  };
>  
> -struct ssb_sprom_r4 {
> -	/* TODO */
> +struct ssb_sprom_data {
> +	u8 il0mac[6];		/* MAC address for 802.11b/g */
> +	u8 et0mac[6];		/* MAC address for Ethernet */
> +	u8 et1mac[6];		/* MAC address for 802.11a */
> +	u8 et0phyaddr:5;	/* MII address for enet0 */
> +	u8 et1phyaddr:5;	/* MII address for enet1 */

While we are at it, please also get rid of these ugly foo:X bitfields.

-- 
Greetings Michael.


From mb at bu3sch.de  Tue Nov  6 20:26:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 6 Nov 2007 20:26:58 +0100
Subject: [RFC 6 of 6] ssb: Remove the old, now unused, data structure
In-Reply-To: <4730bdac.Oup0h41hJ0GHVCxr%Larry.Finger@lwfinger.net>
References: <4730bdac.Oup0h41hJ0GHVCxr%Larry.Finger@lwfinger.net>
Message-ID: <200711062026.58650.mb@bu3sch.de>

On Tuesday 06 November 2007 20:17:00 Larry Finger wrote:
> Patch 6 of 6.
> 
> The old, now unused, data structures and SPROM extraction routines
> are removed.
> 
> Signed-off-by: Larry Finger<Larry.Finger at lwfinger.net>
> ---
> 
> Index: wireless-2.6/include/linux/ssb/ssb.h
> ===================================================================
> --- wireless-2.6.orig/include/linux/ssb/ssb.h
> +++ wireless-2.6/include/linux/ssb/ssb.h
> @@ -15,69 +15,6 @@ struct pcmcia_device;
>  struct ssb_bus;
>  struct ssb_driver;
>  
> -
> -struct ssb_sprom_r1 {
> -	u16 pci_spid;		/* Subsystem Product ID for PCI */
> -	u16 pci_svid;		/* Subsystem Vendor ID for PCI */
> -	u16 pci_pid;		/* Product ID for PCI */
> -	u8 il0mac[6];		/* MAC address for 802.11b/g */
> -	u8 et0mac[6];		/* MAC address for Ethernet */
> -	u8 et1mac[6];		/* MAC address for 802.11a */
> -	u8 et0phyaddr:5;	/* MII address for enet0 */
> -	u8 et1phyaddr:5;	/* MII address for enet1 */
> -	u8 et0mdcport:1;	/* MDIO for enet0 */
> -	u8 et1mdcport:1;	/* MDIO for enet1 */
> -	u8 board_rev;		/* Board revision */
> -	u8 country_code:4;	/* Country Code */
> -	u8 antenna_a:2;		/* Antenna 0/1 available for A-PHY */
> -	u8 antenna_bg:2;	/* Antenna 0/1 available for B-PHY and G-PHY */
> -	u16 pa0b0;
> -	u16 pa0b1;
> -	u16 pa0b2;
> -	u16 pa1b0;
> -	u16 pa1b1;
> -	u16 pa1b2;
> -	u8 gpio0;		/* GPIO pin 0 */
> -	u8 gpio1;		/* GPIO pin 1 */
> -	u8 gpio2;		/* GPIO pin 2 */
> -	u8 gpio3;		/* GPIO pin 3 */
> -	u16 maxpwr_a;		/* A-PHY Power Amplifier Max Power (in dBm Q5.2) */
> -	u16 maxpwr_bg;		/* B/G-PHY Power Amplifier Max Power (in dBm Q5.2) */
> -	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
> -	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
> -	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
> -	u8 antenna_gain_a;	/* A-PHY Antenna gain (in dBm Q5.2) */
> -	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
> -	u8 oem[8];		/* OEM string (rev 1 only) */
> -};
> -
> -struct ssb_sprom_r2 {
> -	u16 boardflags_hi;	/* Boardflags (high 16 bits) */
> -	u8 maxpwr_a_lo;		/* A-PHY Max Power Low */
> -	u8 maxpwr_a_hi;		/* A-PHY Max Power High */
> -	u16 pa1lob0;		/* A-PHY PA Low Settings */
> -	u16 pa1lob1;		/* A-PHY PA Low Settings */
> -	u16 pa1lob2;		/* A-PHY PA Low Settings */
> -	u16 pa1hib0;		/* A-PHY PA High Settings */
> -	u16 pa1hib1;		/* A-PHY PA High Settings */
> -	u16 pa1hib2;		/* A-PHY PA High Settings */
> -	u8 ofdm_pwr_off;	/* OFDM Power Offset from CCK Level */
> -	u8 country_str[2];	/* Two char Country Code */
> -};
> -
> -struct ssb_sprom_r3 {
> -	u32 ofdmapo;		/* A-PHY OFDM Mid Power Offset */
> -	u32 ofdmalpo;		/* A-PHY OFDM Low Power Offset */
> -	u32 ofdmahpo;		/* A-PHY OFDM High Power Offset */
> -	u8 gpioldc_on_cnt;	/* GPIO LED Powersave Duty Cycle ON count */
> -	u8 gpioldc_off_cnt;	/* GPIO LED Powersave Duty Cycle OFF count */
> -	u8 cckpo_1M:4;		/* CCK Power Offset for Rate 1M */
> -	u8 cckpo_2M:4;		/* CCK Power Offset for Rate 2M */
> -	u8 cckpo_55M:4;		/* CCK Power Offset for Rate 5.5M */
> -	u8 cckpo_11M:4;		/* CCK Power Offset for Rate 11M */
> -	u32 ofdmgpo;		/* G-PHY OFDM Power Offset */
> -};
> -
>  struct ssb_sprom_data {
>  	u8 il0mac[6];		/* MAC address for 802.11b/g */
>  	u8 et0mac[6];		/* MAC address for Ethernet */
> @@ -109,16 +46,6 @@ struct ssb_sprom_data {
>  struct ssb_sprom {
>  	u8 revision;
>  	u8 crc;
> -	/* The valid r# fields are selected by the "revision".
> -	 * Revision 3 and lower inherit from lower revisions.
> -	 */
> -	union {
> -		struct {
> -			struct ssb_sprom_r1 r1;
> -			struct ssb_sprom_r2 r2;
> -			struct ssb_sprom_r3 r3;
> -		};
> -	};
>  	struct ssb_sprom_data data;
>  };


I'd also like to get rid of the "revision" and "crc" fields, as they
are of no use to drivers. So you can rename struct ssb_sprom_data
to struct ssb_sprom and remove the old struct ssb_sprom.

If that creates problems with merging (bisect), just create one big patch.
I like big patches more than hundreds of small ones that change this
and that and in the end revert everything, just for the sake of
having multiple patches. :)

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Tue Nov  6 20:29:41 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 06 Nov 2007 13:29:41 -0600
Subject: [RFC 1 of 6] ssb: Add new SPROM structure while keeping the old
In-Reply-To: <200711062022.41248.mb@bu3sch.de>
References: <4730bd03.rGmiNlJ18XBoW/Yb%Larry.Finger@lwfinger.net>
	<200711062022.41248.mb@bu3sch.de>
Message-ID: <4730C0A5.60700@lwfinger.net>

Michael Buesch wrote:
> On Tuesday 06 November 2007 20:14:11 Larry Finger wrote:
>> +	u8 et0phyaddr:5;	/* MII address for enet0 */
>> +	u8 et1phyaddr:5;	/* MII address for enet1 */
> 
> While we are at it, please also get rid of these ugly foo:X bitfields.
> 

Done.

Larry



From stefano.brivio at polimi.it  Tue Nov  6 22:48:12 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 6 Nov 2007 22:48:12 +0100
Subject: [PATCH 1/7] b43legacy: use the retry limits provided by mac80211
Message-ID: <20071106224812.6d144692@morte>

Use the retry limits provided by mac80211.

The patch to b43 by Michael Buesch <mb at bu3sch.de> has been ported to
b43legacy.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

----

Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -75,14 +75,6 @@ module_param_named(bad_frames_preempt, m
 MODULE_PARM_DESC(bad_frames_preempt, "enable(1) / disable(0) Bad Frames"
 		 " Preemption");
 
-static int modparam_short_retry = B43legacy_DEFAULT_SHORT_RETRY_LIMIT;
-module_param_named(short_retry, modparam_short_retry, int, 0444);
-MODULE_PARM_DESC(short_retry, "Short-Retry-Limit (0 - 15)");
-
-static int modparam_long_retry = B43legacy_DEFAULT_LONG_RETRY_LIMIT;
-module_param_named(long_retry, modparam_long_retry, int, 0444);
-MODULE_PARM_DESC(long_retry, "Long-Retry-Limit (0 - 15)");
-
 static char modparam_fwpostfix[16];
 module_param_string(fwpostfix, modparam_fwpostfix, 16, 0444);
 MODULE_PARM_DESC(fwpostfix, "Postfix for the firmware files to load.");
@@ -2927,6 +2919,20 @@ static void b43legacy_imcfglo_timeouts_w
 #endif /* CONFIG_SSB_DRIVER_PCICORE */
 }
 
+/* Write the short and long frame retry limit values. */
+static void b43legacy_set_retry_limits(struct b43legacy_wldev *dev,
+				       unsigned int short_retry,
+				       unsigned int long_retry)
+{
+	/* The retry limit is a 4-bit counter. Enforce this to avoid overflowing
+	 * the chip-internal counter. */
+	short_retry = min(short_retry, (unsigned int)0xF);
+	long_retry = min(long_retry, (unsigned int)0xF);
+
+	b43legacy_shm_write16(dev, B43legacy_SHM_WIRELESS, 0x0006, short_retry);
+	b43legacy_shm_write16(dev, B43legacy_SHM_WIRELESS, 0x0007, long_retry);
+}
+
 /* Shutdown a wireless core */
 /* Locking: wl->mutex */
 static void b43legacy_wireless_core_exit(struct b43legacy_wldev *dev)
@@ -3064,16 +3070,9 @@ static int b43legacy_wireless_core_init(
 	}
 	b43legacy_hf_write(dev, hf);
 
-	/* Short/Long Retry Limit.
-	 * The retry-limit is a 4-bit counter. Enforce this to avoid overflowing
-	 * the chip-internal counter.
-	 */
-	tmp = limit_value(modparam_short_retry, 0, 0xF);
-	b43legacy_shm_write16(dev, B43legacy_SHM_WIRELESS,
-			      0x0006, tmp);
-	tmp = limit_value(modparam_long_retry, 0, 0xF);
-	b43legacy_shm_write16(dev, B43legacy_SHM_WIRELESS,
-			      0x0007, tmp);
+	b43legacy_set_retry_limits(dev,
+				   B43legacy_DEFAULT_SHORT_RETRY_LIMIT,
+				   B43legacy_DEFAULT_LONG_RETRY_LIMIT);
 
 	b43legacy_shm_write16(dev, B43legacy_SHM_SHARED,
 			      0x0044, 3);
@@ -3250,19 +3249,41 @@ static void b43legacy_stop(struct ieee80
 	mutex_unlock(&wl->mutex);
 }
 
+static int b43legacy_op_set_retry_limit(struct ieee80211_hw *hw,
+					u32 short_retry_limit,
+					u32 long_retry_limit)
+{
+	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
+	struct b43legacy_wldev *dev;
+	int err = 0;
+
+	mutex_lock(&wl->mutex);
+	dev = wl->current_dev;
+	if (unlikely(!dev ||
+		     (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED))) {
+		err = -ENODEV;
+		goto out_unlock;
+	}
+	b43legacy_set_retry_limits(dev, short_retry_limit, long_retry_limit);
+out_unlock:
+	mutex_unlock(&wl->mutex);
+
+	return err;
+}
 
 static const struct ieee80211_ops b43legacy_hw_ops = {
-	.tx = b43legacy_tx,
-	.conf_tx = b43legacy_conf_tx,
-	.add_interface = b43legacy_add_interface,
-	.remove_interface = b43legacy_remove_interface,
-	.config = b43legacy_dev_config,
-	.config_interface = b43legacy_config_interface,
-	.configure_filter = b43legacy_configure_filter,
-	.get_stats = b43legacy_get_stats,
-	.get_tx_stats = b43legacy_get_tx_stats,
-	.start = b43legacy_start,
-	.stop = b43legacy_stop,
+	.tx			= b43legacy_tx,
+	.conf_tx		= b43legacy_conf_tx,
+	.add_interface		= b43legacy_add_interface,
+	.remove_interface	= b43legacy_remove_interface,
+	.config			= b43legacy_dev_config,
+	.config_interface	= b43legacy_config_interface,
+	.configure_filter	= b43legacy_configure_filter,
+	.get_stats		= b43legacy_get_stats,
+	.get_tx_stats		= b43legacy_get_tx_stats,
+	.start			= b43legacy_start,
+	.stop			= b43legacy_stop,
+	.set_retry_limit	= b43legacy_op_set_retry_limit,
 };
 
 /* Hard-reset the chip. Do not call this directly.
Index: wireless-2.6/drivers/net/wireless/b43legacy/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/xmit.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/xmit.c
@@ -290,6 +290,8 @@ static void generate_txhdr_fw3(struct b4
 		mac_ctl |= B43legacy_TX4_MAC_STMSDU;
 	if (rate_fb_ofdm)
 		mac_ctl |= B43legacy_TX4_MAC_FALLBACKOFDM;
+	if (txctl->flags & IEEE80211_TXCTL_LONG_RETRY_LIMIT)
+		mac_ctl |= B43legacy_TX4_MAC_LONGFRAME;
 
 	/* Generate the RTS or CTS-to-self frame */
 	if ((txctl->flags & IEEE80211_TXCTL_USE_RTS_CTS) ||
@@ -335,7 +337,6 @@ static void generate_txhdr_fw3(struct b4
 					    len, rts_rate_fb);
 		hdr = (struct ieee80211_hdr *)(&txhdr->rts_frame);
 		txhdr->rts_dur_fb = hdr->duration_id;
-		mac_ctl |= B43legacy_TX4_MAC_LONGFRAME;
 	}
 
 	/* Magic cookie */



-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Tue Nov  6 22:48:25 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 6 Nov 2007 22:48:25 +0100
Subject: [PATCH 2/7] b43legacy: use a consistent naming scheme for the ops
In-Reply-To: <20071106222313.31e9bcd9@morte>
References: <20071106222313.31e9bcd9@morte>
Message-ID: <20071106224825.5b942f3f@morte>

Use a consistent naming scheme for the ops.

The patch to b43 by Michael Buesch <mb at bu3sch.de> has been ported to
b43legacy.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

----

Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -2285,9 +2285,9 @@ static int b43legacy_rng_init(struct b43
 	return err;
 }
 
-static int b43legacy_tx(struct ieee80211_hw *hw,
-			struct sk_buff *skb,
-			struct ieee80211_tx_control *ctl)
+static int b43legacy_op_tx(struct ieee80211_hw *hw,
+			   struct sk_buff *skb,
+			   struct ieee80211_tx_control *ctl)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev = wl->current_dev;
@@ -2311,15 +2311,15 @@ out:
 	return NETDEV_TX_OK;
 }
 
-static int b43legacy_conf_tx(struct ieee80211_hw *hw,
-			     int queue,
-			     const struct ieee80211_tx_queue_params *params)
+static int b43legacy_op_conf_tx(struct ieee80211_hw *hw,
+				int queue,
+				const struct ieee80211_tx_queue_params *params)
 {
 	return 0;
 }
 
-static int b43legacy_get_tx_stats(struct ieee80211_hw *hw,
-				  struct ieee80211_tx_queue_stats *stats)
+static int b43legacy_op_get_tx_stats(struct ieee80211_hw *hw,
+				     struct ieee80211_tx_queue_stats *stats)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev = wl->current_dev;
@@ -2341,8 +2341,8 @@ out:
 	return err;
 }
 
-static int b43legacy_get_stats(struct ieee80211_hw *hw,
-			       struct ieee80211_low_level_stats *stats)
+static int b43legacy_op_get_stats(struct ieee80211_hw *hw,
+				  struct ieee80211_low_level_stats *stats)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	unsigned long flags;
@@ -2491,8 +2491,8 @@ static int b43legacy_antenna_from_ieee80
 	}
 }
 
-static int b43legacy_dev_config(struct ieee80211_hw *hw,
-				struct ieee80211_conf *conf)
+static int b43legacy_op_dev_config(struct ieee80211_hw *hw,
+				   struct ieee80211_conf *conf)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev;
@@ -2595,11 +2595,11 @@ out_unlock_mutex:
 	return err;
 }
 
-static void b43legacy_configure_filter(struct ieee80211_hw *hw,
-				       unsigned int changed,
-				       unsigned int *fflags,
-				       int mc_count,
-				       struct dev_addr_list *mc_list)
+static void b43legacy_op_configure_filter(struct ieee80211_hw *hw,
+					  unsigned int changed,
+					  unsigned int *fflags,
+					  int mc_count,
+					  struct dev_addr_list *mc_list)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev = wl->current_dev;
@@ -2634,9 +2634,9 @@ static void b43legacy_configure_filter(s
 	spin_unlock_irqrestore(&wl->irq_lock, flags);
 }
 
-static int b43legacy_config_interface(struct ieee80211_hw *hw,
-				      int if_id,
-				      struct ieee80211_if_conf *conf)
+static int b43legacy_op_config_interface(struct ieee80211_hw *hw,
+					 int if_id,
+					 struct ieee80211_if_conf *conf)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev = wl->current_dev;
@@ -3141,8 +3141,8 @@ err_kfree_lo_control:
 	return err;
 }
 
-static int b43legacy_add_interface(struct ieee80211_hw *hw,
-				   struct ieee80211_if_init_conf *conf)
+static int b43legacy_op_add_interface(struct ieee80211_hw *hw,
+				      struct ieee80211_if_init_conf *conf)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev;
@@ -3181,8 +3181,8 @@ static int b43legacy_add_interface(struc
 	return err;
 }
 
-static void b43legacy_remove_interface(struct ieee80211_hw *hw,
-				       struct ieee80211_if_init_conf *conf)
+static void b43legacy_op_remove_interface(struct ieee80211_hw *hw,
+					  struct ieee80211_if_init_conf *conf)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev = wl->current_dev;
@@ -3206,7 +3206,7 @@ static void b43legacy_remove_interface(s
 	mutex_unlock(&wl->mutex);
 }
 
-static int b43legacy_start(struct ieee80211_hw *hw)
+static int b43legacy_op_start(struct ieee80211_hw *hw)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev = wl->current_dev;
@@ -3237,7 +3237,7 @@ out_mutex_unlock:
 	return err;
 }
 
-static void b43legacy_stop(struct ieee80211_hw *hw)
+static void b43legacy_op_stop(struct ieee80211_hw *hw)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev = wl->current_dev;
@@ -3272,17 +3272,17 @@ out_unlock:
 }
 
 static const struct ieee80211_ops b43legacy_hw_ops = {
-	.tx			= b43legacy_tx,
-	.conf_tx		= b43legacy_conf_tx,
-	.add_interface		= b43legacy_add_interface,
-	.remove_interface	= b43legacy_remove_interface,
-	.config			= b43legacy_dev_config,
-	.config_interface	= b43legacy_config_interface,
-	.configure_filter	= b43legacy_configure_filter,
-	.get_stats		= b43legacy_get_stats,
-	.get_tx_stats		= b43legacy_get_tx_stats,
-	.start			= b43legacy_start,
-	.stop			= b43legacy_stop,
+	.tx			= b43legacy_op_tx,
+	.conf_tx		= b43legacy_op_conf_tx,
+	.add_interface		= b43legacy_op_add_interface,
+	.remove_interface	= b43legacy_op_remove_interface,
+	.config			= b43legacy_op_dev_config,
+	.config_interface	= b43legacy_op_config_interface,
+	.configure_filter	= b43legacy_op_configure_filter,
+	.get_stats		= b43legacy_op_get_stats,
+	.get_tx_stats		= b43legacy_op_get_tx_stats,
+	.start			= b43legacy_op_start,
+	.stop			= b43legacy_op_stop,
 	.set_retry_limit	= b43legacy_op_set_retry_limit,
 };
 


-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Tue Nov  6 22:48:36 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 6 Nov 2007 22:48:36 +0100
Subject: [PATCH 3/7] b43legacy: fix possible buffer overrun in debugfs
In-Reply-To: <20071106222313.31e9bcd9@morte>
References: <20071106222313.31e9bcd9@morte>
Message-ID: <20071106224836.0d90cb4c@morte>

Fix possible buffer overrun.

The patch to b43 by Michael Buesch <mb at bu3sch.de> has been ported to
b43legacy.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

----

Index: wireless-2.6/drivers/net/wireless/b43legacy/debugfs.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/debugfs.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/debugfs.c
@@ -124,7 +124,7 @@ static ssize_t shm_read_file(struct b43l
 	__le16 *le16buf = (__le16 *)buf;
 
 	for (i = 0; i < 0x1000; i++) {
-		if (bufsize <= 0)
+		if (bufsize < sizeof(tmp))
 			break;
 		tmp = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED, 2 * i);
 		le16buf[i] = cpu_to_le16(tmp);



-- 
Ciao
Stefano

-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Tue Nov  6 22:48:45 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 6 Nov 2007 22:48:45 +0100
Subject: [PATCH 4/7] b43legacy: rewrite and fix rfkill initialization
In-Reply-To: <20071106222313.31e9bcd9@morte>
References: <20071106222313.31e9bcd9@morte>
Message-ID: <20071106224845.7735a4f1@morte>

The rfkill subsystem doesn't like code like that
rfkill_allocate();
rfkill_register();
rfkill_unregister();
rfkill_register(); /* <- This will crash */

This sequence happens with
modprobe b43
ifconfig wlanX up
ifconfig wlanX down
ifconfig wlanX up

Fix this by always re-allocating the rfkill stuff before register.

The patch to b43 by Michael Buesch <mb at bu3sch.de> has been ported to
b43legacy.

Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

----

Index: wireless-2.6/drivers/net/wireless/b43legacy/rfkill.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/rfkill.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/rfkill.c
@@ -48,18 +48,21 @@ static void b43legacy_rfkill_poll(struct
 	struct b43legacy_wldev *dev = poll_dev->private;
 	struct b43legacy_wl *wl = dev->wl;
 	bool enabled;
+	bool report_change = 0;
 
 	mutex_lock(&wl->mutex);
 	B43legacy_WARN_ON(b43legacy_status(dev) < B43legacy_STAT_INITIALIZED);
 	enabled = b43legacy_is_hw_radio_enabled(dev);
 	if (unlikely(enabled != dev->radio_hw_enable)) {
 		dev->radio_hw_enable = enabled;
+		report_change = 1;
 		b43legacyinfo(wl, "Radio hardware status changed to %s\n",
 			enabled ? "ENABLED" : "DISABLED");
-		mutex_unlock(&wl->mutex);
+	}
+	mutex_unlock(&wl->mutex);
+
+	if (unlikely(report_change))
 		input_report_key(poll_dev->input, KEY_WLAN, enabled);
-	} else
-		mutex_unlock(&wl->mutex);
 }
 
 /* Called when the RFKILL toggled in software. */
@@ -69,18 +72,11 @@ static int b43legacy_rfkill_soft_toggle(
 	struct b43legacy_wl *wl = dev->wl;
 	int err = 0;
 
-	/* When RFKILL is registered, it will call back into this callback.
-	 * wl->mutex will already be locked when this happens.
-	 * So first trylock. On contention check if we are in initialization.
-	 * Silently return if that happens to avoid a deadlock. */
-	if (mutex_trylock(&wl->mutex) == 0) {
-		if (b43legacy_status(dev) < B43_STAT_INITIALIZED)
-			return 0;
-		mutex_lock(&wl->mutex);
-	}
-	if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED)
-		goto out_unlock;
+	if (!wl->rfkill.registered)
+		return 0;
 
+	mutex_lock(&wl->mutex);
+	B43legacy_WARN_ON(b43legacy_status(dev) < B43legacy_STAT_INITIALIZED);
 	switch (state) {
 	case RFKILL_STATE_ON:
 		if (!dev->radio_hw_enable) {
Index: wireless-2.6/drivers/net/wireless/b43legacy/rfkill.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/rfkill.h
+++ wireless-2.6/drivers/net/wireless/b43legacy/rfkill.h
@@ -16,14 +16,14 @@ struct b43legacy_rfkill {
 	struct rfkill *rfkill;
 	/* The poll device for the RFKILL input button */
 	struct input_polled_dev *poll_dev;
+	/* Did initialization succeed? Used for freeing. */
+	bool registered;
 	/* The unique name of this rfkill switch */
-	char name[32];
+	char name[sizeof("b43legacy-phy4294967295")];
 };
 
-/* All the init functions return void, because we are not interested
+/* The init function returns void, because we are not interested
  * in failing the b43 init process when rfkill init failed. */
-void b43legacy_rfkill_alloc(struct b43legacy_wldev *dev);
-void b43legacy_rfkill_free(struct b43legacy_wldev *dev);
 void b43legacy_rfkill_init(struct b43legacy_wldev *dev);
 void b43legacy_rfkill_exit(struct b43legacy_wldev *dev);

Index: wireless-2.6/drivers/net/wireless/b43legacy/rfkill.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -3360,7 +3381,6 @@ static int b43legacy_setup_modes(struct b43legacy_wldev *dev,
 
 static void b43legacy_wireless_core_detach(struct b43legacy_wldev *dev)
 {
-	b43legacy_rfkill_free(dev);
 	/* We release firmware that late to not be required to re-request
 	 * is all the time when we reinit the core. */
 	b43legacy_release_firmware(dev);
@@ -3442,7 +3462,6 @@ static int b43legacy_wireless_core_attach(struct b43legacy_wldev *dev)
 	if (!wl->current_dev)
 		wl->current_dev = dev;
 	INIT_WORK(&dev->restart_work, b43legacy_chip_reset);
-	b43legacy_rfkill_alloc(dev);
 
 	b43legacy_radio_turn_off(dev, 1);
 	b43legacy_switch_analog(dev, 0);



-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Tue Nov  6 22:48:56 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 6 Nov 2007 22:48:56 +0100
Subject: [PATCH 5/7] b43legacy: add me as maintainer and fix URLs
In-Reply-To: <20071106222313.31e9bcd9@morte>
References: <20071106222313.31e9bcd9@morte>
Message-ID: <20071106224856.4dbc5d4f@morte>

As b43legacy is going to be orphaned, add me as a maintainer. Fix URLs for
the related website and fix my e-mail address in MAINTAINERS file.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
Cc: Larry Finger <larry.finger at lwfinger.net>

----

Index: wireless-2.6/MAINTAINERS
===================================================================
--- wireless-2.6.orig/MAINTAINERS
+++ wireless-2.6/MAINTAINERS
@@ -798,23 +798,25 @@ B43 WIRELESS DRIVER
 P:	Michael Buesch
 M:	mb at bu3sch.de
 P:	Stefano Brivio
-M:	st3 at riseup.net
+M:	stefano.brivio at polimi.it
 L:	linux-wireless at vger.kernel.org
-W:	http://bcm43xx.berlios.de/
+W:	http://linuxwireless.org/en/users/Drivers/b43
 S:	Maintained
 
 B43LEGACY WIRELESS DRIVER
 P:	Larry Finger
 M:	Larry.Finger at lwfinger.net
+P:	Stefano Brivio
+M:	stefano.brivio at polimi.it
 L:	linux-wireless at vger.kernel.org
-W:	http://bcm43xx.berlios.de/
+W:	http://linuxwireless.org/en/users/Drivers/b43
 S:	Maintained
 
 BCM43XX WIRELESS DRIVER (SOFTMAC BASED VERSION)
 P:	Larry Finger
 M:	Larry.Finger at lwfinger.net
 P:	Stefano Brivio
-M:	st3 at riseup.net
+M:	stefano.brivio at polimi.it
 L:	linux-wireless at vger.kernel.org
 W:	http://bcm43xx.berlios.de/
 S:	Maintained



-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Tue Nov  6 22:49:05 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 6 Nov 2007 22:49:05 +0100
Subject: [PATCH 6/7] b43: rewrite A PHY initialization
In-Reply-To: <20071106222313.31e9bcd9@morte>
References: <20071106222313.31e9bcd9@morte>
Message-ID: <20071106224905.5dc058b0@morte>

Rewrite and sync A PHY initialization with specs, thus allowing for further
work to be done on 802.11a support. Note that A PHY initialization involves
G PHYs as well.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
Acked-by: Michael Buesch <mb at bu3sch.de>

----

Index: wireless-2.6/drivers/net/wireless/b43/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/Makefile
+++ wireless-2.6/drivers/net/wireless/b43/Makefile
@@ -5,6 +5,7 @@ b43-y				+= phy.o
 b43-y				+= sysfs.o
 b43-y				+= xmit.o
 b43-y				+= lo.o
+b43-y				+= wa.o
 # b43 RFKILL button support
 b43-$(CONFIG_B43_RFKILL)	+= rfkill.o
 # b43 LED support
Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h
+++ wireless-2.6/drivers/net/wireless/b43/b43.h
@@ -542,6 +542,10 @@ struct b43_phy {
 	u16 lofcal;
 
 	u16 initval;		//FIXME rename?
+
+	/* OFDM address read/write caching for hardware auto-increment. */
+	u16 ofdm_addr;
+	u8 ofdm_valid; /* 0: invalid, 1: read, 2: write */
 };
 
 /* Data structures for DMA transmission, per 80211 core. */
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -2256,6 +2256,9 @@ static int b43_chip_init(struct b43_wlde
 	b43_write16(dev, B43_MMIO_POWERUP_DELAY,
 		    dev->dev->bus->chipco.fast_pwrup_delay);
 
+	/* OFDM address caching. */
+	phy->ofdm_valid = 0;
+
 	err = 0;
 	b43dbg(dev->wl, "Chip initialized\n");
 out:
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c
+++ wireless-2.6/drivers/net/wireless/b43/phy.c
@@ -34,6 +34,8 @@
 #include "main.h"
 #include "tables.h"
 #include "lo.h"
+#include "wa.h"
+
 
 static const s8 b43_tssi2dbm_b_table[] = {
 	0x4D, 0x4C, 0x4B, 0x4A,
@@ -303,7 +305,7 @@ void b43_phy_write(struct b43_wldev *dev
 	b43_write16(dev, B43_MMIO_PHY_DATA, val);
 }
 
-static void b43_radio_set_txpower_a(struct b43_wldev *dev, u16 txpower);
+static void b43_set_txpower_a(struct b43_wldev *dev, u16 txpower);
 
 /* Adjust the transmission power output (G-PHY) */
 void b43_set_txpower_g(struct b43_wldev *dev,
@@ -763,366 +765,96 @@ static void b43_phy_init_pctl(struct b43
 	b43_shm_clear_tssi(dev);
 }
 
-static void b43_phy_agcsetup(struct b43_wldev *dev)
-{
-	struct b43_phy *phy = &dev->phy;
-	u16 offset = 0x0000;
-
-	if (phy->rev == 1)
-		offset = 0x4C00;
-
-	b43_ofdmtab_write16(dev, offset, 0, 0x00FE);
-	b43_ofdmtab_write16(dev, offset, 1, 0x000D);
-	b43_ofdmtab_write16(dev, offset, 2, 0x0013);
-	b43_ofdmtab_write16(dev, offset, 3, 0x0019);
-
-	if (phy->rev == 1) {
-		b43_ofdmtab_write16(dev, 0x1800, 0, 0x2710);
-		b43_ofdmtab_write16(dev, 0x1801, 0, 0x9B83);
-		b43_ofdmtab_write16(dev, 0x1802, 0, 0x9B83);
-		b43_ofdmtab_write16(dev, 0x1803, 0, 0x0F8D);
-		b43_phy_write(dev, 0x0455, 0x0004);
-	}
-
-	b43_phy_write(dev, 0x04A5, (b43_phy_read(dev, 0x04A5)
-				    & 0x00FF) | 0x5700);
-	b43_phy_write(dev, 0x041A, (b43_phy_read(dev, 0x041A)
-				    & 0xFF80) | 0x000F);
-	b43_phy_write(dev, 0x041A, (b43_phy_read(dev, 0x041A)
-				    & 0xC07F) | 0x2B80);
-	b43_phy_write(dev, 0x048C, (b43_phy_read(dev, 0x048C)
-				    & 0xF0FF) | 0x0300);
-
-	b43_radio_write16(dev, 0x007A, b43_radio_read16(dev, 0x007A)
-			  | 0x0008);
-
-	b43_phy_write(dev, 0x04A0, (b43_phy_read(dev, 0x04A0)
-				    & 0xFFF0) | 0x0008);
-	b43_phy_write(dev, 0x04A1, (b43_phy_read(dev, 0x04A1)
-				    & 0xF0FF) | 0x0600);
-	b43_phy_write(dev, 0x04A2, (b43_phy_read(dev, 0x04A2)
-				    & 0xF0FF) | 0x0700);
-	b43_phy_write(dev, 0x04A0, (b43_phy_read(dev, 0x04A0)
-				    & 0xF0FF) | 0x0100);
-
-	if (phy->rev == 1) {
-		b43_phy_write(dev, 0x04A2, (b43_phy_read(dev, 0x04A2)
-					    & 0xFFF0) | 0x0007);
-	}
-
-	b43_phy_write(dev, 0x0488, (b43_phy_read(dev, 0x0488)
-				    & 0xFF00) | 0x001C);
-	b43_phy_write(dev, 0x0488, (b43_phy_read(dev, 0x0488)
-				    & 0xC0FF) | 0x0200);
-	b43_phy_write(dev, 0x0496, (b43_phy_read(dev, 0x0496)
-				    & 0xFF00) | 0x001C);
-	b43_phy_write(dev, 0x0489, (b43_phy_read(dev, 0x0489)
-				    & 0xFF00) | 0x0020);
-	b43_phy_write(dev, 0x0489, (b43_phy_read(dev, 0x0489)
-				    & 0xC0FF) | 0x0200);
-	b43_phy_write(dev, 0x0482, (b43_phy_read(dev, 0x0482)
-				    & 0xFF00) | 0x002E);
-	b43_phy_write(dev, 0x0496, (b43_phy_read(dev, 0x0496)
-				    & 0x00FF) | 0x1A00);
-	b43_phy_write(dev, 0x0481, (b43_phy_read(dev, 0x0481)
-				    & 0xFF00) | 0x0028);
-	b43_phy_write(dev, 0x0481, (b43_phy_read(dev, 0x0481)
-				    & 0x00FF) | 0x2C00);
-
-	if (phy->rev == 1) {
-		b43_phy_write(dev, 0x0430, 0x092B);
-		b43_phy_write(dev, 0x041B, (b43_phy_read(dev, 0x041B)
-					    & 0xFFE1) | 0x0002);
-	} else {
-		b43_phy_write(dev, 0x041B, b43_phy_read(dev, 0x041B)
-			      & 0xFFE1);
-		b43_phy_write(dev, 0x041F, 0x287A);
-		b43_phy_write(dev, 0x0420, (b43_phy_read(dev, 0x0420)
-					    & 0xFFF0) | 0x0004);
-	}
-
-	if (phy->rev >= 6) {
-		b43_phy_write(dev, 0x0422, 0x287A);
-		b43_phy_write(dev, 0x0420, (b43_phy_read(dev, 0x0420)
-					    & 0x0FFF) | 0x3000);
-	}
-
-	b43_phy_write(dev, 0x04A8, (b43_phy_read(dev, 0x04A8)
-				    & 0x8080) | 0x7874);
-	b43_phy_write(dev, 0x048E, 0x1C00);
-
-	offset = 0x0800;
-	if (phy->rev == 1) {
-		offset = 0x5400;
-		b43_phy_write(dev, 0x04AB, (b43_phy_read(dev, 0x04AB)
-					    & 0xF0FF) | 0x0600);
-		b43_phy_write(dev, 0x048B, 0x005E);
-		b43_phy_write(dev, 0x048C, (b43_phy_read(dev, 0x048C)
-					    & 0xFF00) | 0x001E);
-		b43_phy_write(dev, 0x048D, 0x0002);
-	}
-	b43_ofdmtab_write16(dev, offset, 0, 0x00);
-	b43_ofdmtab_write16(dev, offset, 1, 0x07);
-	b43_ofdmtab_write16(dev, offset, 2, 0x10);
-	b43_ofdmtab_write16(dev, offset, 3, 0x1C);
-
-	if (phy->rev >= 6) {
-		b43_phy_write(dev, 0x0426, b43_phy_read(dev, 0x0426)
-			      & 0xFFFC);
-		b43_phy_write(dev, 0x0426, b43_phy_read(dev, 0x0426)
-			      & 0xEFFF);
-	}
-}
-
-static void b43_phy_setupg(struct b43_wldev *dev)
+static void b43_phy_rssiagc(struct b43_wldev *dev, u8 enable)
 {
-	struct ssb_bus *bus = dev->dev->bus;
-	struct b43_phy *phy = &dev->phy;
-	u16 i;
-
-	B43_WARN_ON(phy->type != B43_PHYTYPE_G);
-	if (phy->rev == 1) {
-		b43_phy_write(dev, 0x0406, 0x4F19);
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      (b43_phy_read(dev, B43_PHY_G_CRS) & 0xFC3F) |
-			      0x0340);
-		b43_phy_write(dev, 0x042C, 0x005A);
-		b43_phy_write(dev, 0x0427, 0x001A);
-
-		for (i = 0; i < B43_TAB_FINEFREQG_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x5800, i,
-					    b43_tab_finefreqg[i]);
-		for (i = 0; i < B43_TAB_NOISEG1_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1800, i, b43_tab_noiseg1[i]);
-		for (i = 0; i < B43_TAB_ROTOR_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x2000, i, b43_tab_rotor[i]);
-	} else {
-		/* nrssi values are signed 6-bit values. Not sure why we write 0x7654 here... */
-		b43_nrssi_hw_write(dev, 0xBA98, (s16) 0x7654);
-
-		if (phy->rev == 2) {
-			b43_phy_write(dev, 0x04C0, 0x1861);
-			b43_phy_write(dev, 0x04C1, 0x0271);
-		} else if (phy->rev > 2) {
-			b43_phy_write(dev, 0x04C0, 0x0098);
-			b43_phy_write(dev, 0x04C1, 0x0070);
-			b43_phy_write(dev, 0x04C9, 0x0080);
-		}
-		b43_phy_write(dev, 0x042B, b43_phy_read(dev, 0x042B) | 0x800);
-
-		for (i = 0; i < 64; i++)
-			b43_ofdmtab_write16(dev, 0x4000, i, i);
-		for (i = 0; i < B43_TAB_NOISEG2_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1800, i, b43_tab_noiseg2[i]);
-	}
-
-	if (phy->rev <= 2)
-		for (i = 0; i < B43_TAB_NOISESCALEG_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1400, i,
-					    b43_tab_noisescaleg1[i]);
-	else if ((phy->rev >= 7) && (b43_phy_read(dev, 0x0449) & 0x0200))
-		for (i = 0; i < B43_TAB_NOISESCALEG_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1400, i,
-					    b43_tab_noisescaleg3[i]);
-	else
-		for (i = 0; i < B43_TAB_NOISESCALEG_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1400, i,
-					    b43_tab_noisescaleg2[i]);
-
-	if (phy->rev == 2)
-		for (i = 0; i < B43_TAB_SIGMASQR_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x5000, i,
-					    b43_tab_sigmasqr1[i]);
-	else if ((phy->rev > 2) && (phy->rev <= 8))
-		for (i = 0; i < B43_TAB_SIGMASQR_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x5000, i,
-					    b43_tab_sigmasqr2[i]);
-
-	if (phy->rev == 1) {
-		for (i = 0; i < B43_TAB_RETARD_SIZE; i++)
-			b43_ofdmtab_write32(dev, 0x2400, i, b43_tab_retard[i]);
-		for (i = 4; i < 20; i++)
-			b43_ofdmtab_write16(dev, 0x5400, i, 0x0020);
-		b43_phy_agcsetup(dev);
-
-		if ((bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM) &&
-		    (bus->boardinfo.type == SSB_BOARD_BU4306) &&
-		    (bus->boardinfo.rev == 0x17))
-			return;
-
-		b43_ofdmtab_write16(dev, 0x5001, 0, 0x0002);
-		b43_ofdmtab_write16(dev, 0x5002, 0, 0x0001);
-	} else {
-		for (i = 0; i < 0x20; i++)
-			b43_ofdmtab_write16(dev, 0x1000, i, 0x0820);
-		b43_phy_agcsetup(dev);
-		b43_phy_read(dev, 0x0400);	/* dummy read */
-		b43_phy_write(dev, 0x0403, 0x1000);
-		b43_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
-		b43_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
-
-		if ((bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM) &&
-		    (bus->boardinfo.type == SSB_BOARD_BU4306) &&
-		    (bus->boardinfo.rev == 0x17))
-			return;
-
-		b43_ofdmtab_write16(dev, 0x0401, 0, 0x0002);
-		b43_ofdmtab_write16(dev, 0x0402, 0, 0x0001);
-	}
-}
-
-/* Initialize the noisescaletable for APHY */
-static void b43_phy_init_noisescaletbl(struct b43_wldev *dev)
-{
-	struct b43_phy *phy = &dev->phy;
 	int i;
 
-	for (i = 0; i < 12; i++) {
-		if (phy->rev == 2)
-			b43_ofdmtab_write16(dev, 0x1400, i, 0x6767);
+	if (dev->phy.rev < 3) {
+		if (enable)
+			for (i = 0; i < B43_TAB_RSSIAGC1_SIZE; i++) {
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_LNAHPFGAIN1, i, 0xFFF8);
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_WRSSI, i, 0xFFF8);
+			}
 		else
-			b43_ofdmtab_write16(dev, 0x1400, i, 0x2323);
-	}
-	if (phy->rev == 2)
-		b43_ofdmtab_write16(dev, 0x1400, i, 0x6700);
-	else
-		b43_ofdmtab_write16(dev, 0x1400, i, 0x2300);
-	for (i = 0; i < 11; i++) {
-		if (phy->rev == 2)
-			b43_ofdmtab_write16(dev, 0x1400, i, 0x6767);
+			for (i = 0; i < B43_TAB_RSSIAGC1_SIZE; i++) {
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_LNAHPFGAIN1, i, b43_tab_rssiagc1[i]);
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_WRSSI, i, b43_tab_rssiagc1[i]);
+			}
+	} else {
+		if (enable)
+			for (i = 0; i < B43_TAB_RSSIAGC1_SIZE; i++)
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_WRSSI, i, 0x0820);
 		else
-			b43_ofdmtab_write16(dev, 0x1400, i, 0x2323);
+			for (i = 0; i < B43_TAB_RSSIAGC2_SIZE; i++)
+				b43_ofdmtab_write16(dev,
+					B43_OFDMTAB_WRSSI, i, b43_tab_rssiagc2[i]);
 	}
-	if (phy->rev == 2)
-		b43_ofdmtab_write16(dev, 0x1400, i, 0x0067);
-	else
-		b43_ofdmtab_write16(dev, 0x1400, i, 0x0023);
 }
 
-static void b43_phy_setupa(struct b43_wldev *dev)
+static void b43_phy_ww(struct b43_wldev *dev)
 {
-	struct b43_phy *phy = &dev->phy;
-	u16 i;
-
-	B43_WARN_ON(phy->type != B43_PHYTYPE_A);
-	switch (phy->rev) {
-	case 2:
-		b43_phy_write(dev, 0x008E, 0x3800);
-		b43_phy_write(dev, 0x0035, 0x03FF);
-		b43_phy_write(dev, 0x0036, 0x0400);
-
-		b43_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-		b43_phy_write(dev, 0x001C, 0x0FF9);
-		b43_phy_write(dev, 0x0020, b43_phy_read(dev, 0x0020) & 0xFF0F);
-		b43_ofdmtab_write16(dev, 0x3C0C, 0, 0x07BF);
-		b43_radio_write16(dev, 0x0002, 0x07BF);
-
-		b43_phy_write(dev, 0x0024, 0x4680);
-		b43_phy_write(dev, 0x0020, 0x0003);
-		b43_phy_write(dev, 0x001D, 0x0F40);
-		b43_phy_write(dev, 0x001F, 0x1C00);
-
-		b43_phy_write(dev, 0x002A, (b43_phy_read(dev, 0x002A)
-					    & 0x00FF) | 0x0400);
-		b43_phy_write(dev, 0x002B, b43_phy_read(dev, 0x002B)
-			      & 0xFBFF);
-		b43_phy_write(dev, 0x008E, 0x58C1);
-
-		b43_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
-		b43_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
-		b43_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-		b43_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-		b43_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
-
-		b43_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0000, 1, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0000, 2, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0000, 3, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0000, 4, 0x0015);
-		b43_ofdmtab_write16(dev, 0x0000, 5, 0x0015);
-		b43_ofdmtab_write16(dev, 0x0000, 6, 0x0019);
-
-		b43_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
-		b43_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
-		b43_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
-
-		for (i = 0; i < 16; i++)
-			b43_ofdmtab_write16(dev, 0x4000, i, (0x8 + i) & 0x000F);
-
-		b43_ofdmtab_write16(dev, 0x3003, 0, 0x1044);
-		b43_ofdmtab_write16(dev, 0x3004, 0, 0x7201);
-		b43_ofdmtab_write16(dev, 0x3006, 0, 0x0040);
-		b43_ofdmtab_write16(dev, 0x3001, 0,
-				    (b43_ofdmtab_read16(dev, 0x3001, 0) &
-				     0x0010) | 0x0008);
-
-		for (i = 0; i < B43_TAB_FINEFREQA_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x5800, i,
-					    b43_tab_finefreqa[i]);
-		for (i = 0; i < B43_TAB_NOISEA2_SIZE; i++)
-			b43_ofdmtab_write16(dev, 0x1800, i, b43_tab_noisea2[i]);
-		for (i = 0; i < B43_TAB_ROTOR_SIZE; i++)
-			b43_ofdmtab_write32(dev, 0x2000, i, b43_tab_rotor[i]);
-		b43_phy_init_noisescaletbl(dev);
-		for (i = 0; i < B43_TAB_RETARD_SIZE; i++)
-			b43_ofdmtab_write32(dev, 0x2400, i, b43_tab_retard[i]);
-		break;
-	case 3:
-		for (i = 0; i < 64; i++)
-			b43_ofdmtab_write16(dev, 0x4000, i, i);
-
-		b43_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-		b43_phy_write(dev, 0x001C, 0x0FF9);
-		b43_phy_write(dev, 0x0020, b43_phy_read(dev, 0x0020) & 0xFF0F);
-		b43_radio_write16(dev, 0x0002, 0x07BF);
-
-		b43_phy_write(dev, 0x0024, 0x4680);
-		b43_phy_write(dev, 0x0020, 0x0003);
-		b43_phy_write(dev, 0x001D, 0x0F40);
-		b43_phy_write(dev, 0x001F, 0x1C00);
-		b43_phy_write(dev, 0x002A, (b43_phy_read(dev, 0x002A)
-					    & 0x00FF) | 0x0400);
-
-		b43_ofdmtab_write16(dev, 0x3000, 1,
-				    (b43_ofdmtab_read16(dev, 0x3000, 1)
-				     & 0x0010) | 0x0008);
-		for (i = 0; i < B43_TAB_NOISEA3_SIZE; i++) {
-			b43_ofdmtab_write16(dev, 0x1800, i, b43_tab_noisea3[i]);
-		}
-		b43_phy_init_noisescaletbl(dev);
-		for (i = 0; i < B43_TAB_SIGMASQR_SIZE; i++) {
-			b43_ofdmtab_write16(dev, 0x5000, i,
-					    b43_tab_sigmasqr1[i]);
-		}
-
-		b43_phy_write(dev, 0x0003, 0x1808);
-
-		b43_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
-		b43_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
-		b43_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-		b43_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-		b43_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
-
-		b43_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0001, 0, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0002, 0, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0003, 0, 0x0013);
-		b43_ofdmtab_write16(dev, 0x0004, 0, 0x0015);
-		b43_ofdmtab_write16(dev, 0x0005, 0, 0x0015);
-		b43_ofdmtab_write16(dev, 0x0006, 0, 0x0019);
-
-		b43_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
-		b43_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
-		b43_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
+	u16 b, curr_s, best_s = 0xFFFF;
+	int i;
 
-		b43_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
-		b43_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
-		break;
-	default:
-		B43_WARN_ON(1);
-	}
+	b43_phy_write(dev, B43_PHY_CRS0,
+		b43_phy_read(dev, B43_PHY_CRS0) & ~B43_PHY_CRS0_EN);
+	b43_phy_write(dev, B43_PHY_OFDM(0x1B),
+		b43_phy_read(dev, B43_PHY_OFDM(0x1B)) | 0x1000);
+	b43_phy_write(dev, B43_PHY_OFDM(0x82),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x82)) & 0xF0FF) | 0x0300);
+	b43_radio_write16(dev, 0x0009,
+		b43_radio_read16(dev, 0x0009) | 0x0080);
+	b43_radio_write16(dev, 0x0012,
+		(b43_radio_read16(dev, 0x0012) & 0xFFFC) | 0x0002);
+	b43_wa_initgains(dev);
+	b43_phy_write(dev, B43_PHY_OFDM(0xBA), 0x3ED5);
+	b = b43_phy_read(dev, B43_PHY_PWRDOWN);
+	b43_phy_write(dev, B43_PHY_PWRDOWN, (b & 0xFFF8) | 0x0005);
+	b43_radio_write16(dev, 0x0004,
+		b43_radio_read16(dev, 0x0004) | 0x0004);
+	for (i = 0x10; i <= 0x20; i++) {
+		b43_radio_write16(dev, 0x0013, i);
+		curr_s = b43_phy_read(dev, B43_PHY_OTABLEQ) & 0x00FF;
+		if (!curr_s) {
+			best_s = 0x0000;
+			break;
+		} else if (curr_s >= 0x0080)
+			curr_s = 0x0100 - curr_s;
+		if (curr_s < best_s)
+			best_s = curr_s;
+	}
+	b43_phy_write(dev, B43_PHY_PWRDOWN, b);
+	b43_radio_write16(dev, 0x0004,
+		b43_radio_read16(dev, 0x0004) & 0xFFFB);
+	b43_radio_write16(dev, 0x0013, best_s);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 0, 0xFFEC);
+	b43_phy_write(dev, B43_PHY_OFDM(0xB7), 0x1E80);
+	b43_phy_write(dev, B43_PHY_OFDM(0xB6), 0x1C00);
+	b43_phy_write(dev, B43_PHY_OFDM(0xB5), 0x0EC0);
+	b43_phy_write(dev, B43_PHY_OFDM(0xB2), 0x00C0);
+	b43_phy_write(dev, B43_PHY_OFDM(0xB9), 0x1FFF);
+	b43_phy_write(dev, B43_PHY_OFDM(0xBB),
+		(b43_phy_read(dev, B43_PHY_OFDM(0xBB)) & 0xF000) | 0x0053);
+	b43_phy_write(dev, B43_PHY_OFDM61,
+		(b43_phy_read(dev, B43_PHY_OFDM61 & 0xFE1F)) | 0x0120);
+	b43_phy_write(dev, B43_PHY_OFDM(0x13),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x13)) & 0x0FFF) | 0x3000);
+	b43_phy_write(dev, B43_PHY_OFDM(0x14),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x14)) & 0x0FFF) | 0x3000);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 6, 0x0017);
+	for (i = 0; i < 6; i++)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, i, 0x000F);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0D, 0x000E);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0E, 0x0011);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0F, 0x0013);
+	b43_phy_write(dev, B43_PHY_OFDM(0x33), 0x5030);
+	b43_phy_write(dev, B43_PHY_CRS0,
+		b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
 }
 
 /* Initialize APHY. This is also called for the GPHY in some cases. */
@@ -1130,64 +862,54 @@ static void b43_phy_inita(struct b43_wld
 {
 	struct ssb_bus *bus = dev->dev->bus;
 	struct b43_phy *phy = &dev->phy;
-	u16 tval;
 
 	might_sleep();
 
+	if (phy->rev >= 6) {
+		if (phy->type == B43_PHYTYPE_A)
+			b43_phy_write(dev, B43_PHY_OFDM(0x1B),
+				b43_phy_read(dev, B43_PHY_OFDM(0x1B)) & ~0x1000);
+		if (b43_phy_read(dev, B43_PHY_ENCORE) & B43_PHY_ENCORE_EN)
+			b43_phy_write(dev, B43_PHY_ENCORE,
+				b43_phy_read(dev, B43_PHY_ENCORE) | 0x0010);
+		else
+			b43_phy_write(dev, B43_PHY_ENCORE,
+				b43_phy_read(dev, B43_PHY_ENCORE) & ~0x1010);
+ 	}
+
+	b43_wa_all(dev);
+
 	if (phy->type == B43_PHYTYPE_A) {
-		b43_phy_setupa(dev);
-	} else {
-		b43_phy_setupg(dev);
-		if (phy->gmode &&
-		    (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL))
-			b43_phy_write(dev, 0x046E, 0x03CF);
-		return;
-	}
+		if (phy->gmode && (phy->rev < 3))
+			b43_phy_write(dev, 0x0034,
+				b43_phy_read(dev, 0x0034) | 0x0001);
+ 		b43_phy_rssiagc(dev, 0);
 
-	b43_phy_write(dev, B43_PHY_A_CRS,
-		      (b43_phy_read(dev, B43_PHY_A_CRS) & 0xF83C) | 0x0340);
-	b43_phy_write(dev, 0x0034, 0x0001);
-
-	//TODO: RSSI AGC
-	b43_phy_write(dev, B43_PHY_A_CRS,
-		      b43_phy_read(dev, B43_PHY_A_CRS) | (1 << 14));
-	b43_radio_init2060(dev);
+		b43_phy_write(dev, B43_PHY_CRS0,
+			b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
 
-	if ((bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM) &&
-	    ((bus->boardinfo.type == SSB_BOARD_BU4306) ||
-	     (bus->boardinfo.type == SSB_BOARD_BU4309))) {
-		if (phy->lofcal == 0xFFFF) {
-			//TODO: LOF Cal
-			b43_radio_set_tx_iq(dev);
-		} else
-			b43_radio_write16(dev, 0x001E, phy->lofcal);
-	}
+		b43_radio_init2060(dev);
 
-	b43_phy_write(dev, 0x007A, 0xF111);
+		if ((bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM) &&
+		    ((bus->boardinfo.type == SSB_BOARD_BU4306) ||
+		     (bus->boardinfo.type == SSB_BOARD_BU4309))) {
+		     	; //TODO: A PHY LO
+ 		}
 
-	if (phy->cur_idle_tssi == 0) {
-		b43_radio_write16(dev, 0x0019, 0x0000);
-		b43_radio_write16(dev, 0x0017, 0x0020);
+		if (phy->rev >= 3)
+			b43_phy_ww(dev);
 
-		tval = b43_ofdmtab_read16(dev, 0x3001, 0);
-		if (phy->rev == 1) {
-			b43_ofdmtab_write16(dev, 0x3001, 0,
-					    (b43_ofdmtab_read16(dev, 0x3001, 0)
-					     & 0xFF87)
-					    | 0x0058);
-		} else {
-			b43_ofdmtab_write16(dev, 0x3001, 0,
-					    (b43_ofdmtab_read16(dev, 0x3001, 0)
-					     & 0xFFC3)
-					    | 0x002C);
-		}
-		b43_dummy_transmission(dev);
-		phy->cur_idle_tssi = b43_phy_read(dev, B43_PHY_A_PCTL);
-		b43_ofdmtab_write16(dev, 0x3001, 0, tval);
+		hardware_pctl_init_aphy(dev);
 
-		b43_radio_set_txpower_a(dev, 0x0018);
+		//TODO: radar detection
 	}
-	b43_shm_clear_tssi(dev);
+
+	if ((phy->type == B43_PHYTYPE_G) &&
+	    (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL)) {
+		b43_phy_write(dev, B43_PHY_OFDM(0x6E),
+				  (b43_phy_read(dev, B43_PHY_OFDM(0x6E))
+				   & 0xE000) | 0x3CF);
+ 	}
 }
 
 static void b43_phy_initb2(struct b43_wldev *dev)
@@ -4277,36 +3999,6 @@ static u16 b43_get_txgain_dac(u16 txpowe
 	return ret;
 }
 
-static void b43_radio_set_txpower_a(struct b43_wldev *dev, u16 txpower)
-{
-	struct b43_phy *phy = &dev->phy;
-	u16 pamp, base, dac, t;
-
-	txpower = limit_value(txpower, 0, 63);
-
-	pamp = b43_get_txgain_freq_power_amp(txpower);
-	pamp <<= 5;
-	pamp &= 0x00E0;
-	b43_phy_write(dev, 0x0019, pamp);
-
-	base = b43_get_txgain_base_band(txpower);
-	base &= 0x000F;
-	b43_phy_write(dev, 0x0017, base | 0x0020);
-
-	t = b43_ofdmtab_read16(dev, 0x3000, 1);
-	t &= 0x0007;
-
-	dac = b43_get_txgain_dac(txpower);
-	dac <<= 3;
-	dac |= t;
-
-	b43_ofdmtab_write16(dev, 0x3000, 1, dac);
-
-	phy->txpwr_offset = txpower;
-
-	//TODO: FuncPlaceholder (Adjust BB loft cancel)
-}
-
 void b43_radio_turn_on(struct b43_wldev *dev)
 {
 	struct b43_phy *phy = &dev->phy;
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h
+++ wireless-2.6/drivers/net/wireless/b43/phy.h
@@ -27,8 +27,11 @@ struct b43_phy;
 #define B43_PHY_PWRDOWN			B43_PHY_OFDM(0x03)	/* Powerdown */
 #define B43_PHY_CRSTHRES1		B43_PHY_OFDM(0x06)	/* CRS Threshold 1 */
 #define B43_PHY_LNAHPFCTL		B43_PHY_OFDM(0x1C)	/* LNA/HPF control */
+#define B43_PHY_LPFGAINCTL		B43_PHY_OFDM(0x20)	/* LPF Gain control */
 #define B43_PHY_ADIVRELATED		B43_PHY_OFDM(0x27)	/* FIXME rename */
 #define B43_PHY_CRS0			B43_PHY_OFDM(0x29)
+#define  B43_PHY_CRS0_EN		0x4000
+#define B43_PHY_PEAK_COUNT		B43_PHY_OFDM(0x30)
 #define B43_PHY_ANTDWELL		B43_PHY_OFDM(0x2B)	/* Antenna dwell */
 #define  B43_PHY_ANTDWELL_AUTODIV1	0x0100	/* Automatic RX diversity start antenna */
 #define B43_PHY_ENCORE			B43_PHY_OFDM(0x49)	/* "Encore" (RangeMax / BroadRange) */
@@ -37,6 +40,7 @@ struct b43_phy;
 #define B43_PHY_OFDM61			B43_PHY_OFDM(0x61)	/* FIXME rename */
 #define  B43_PHY_OFDM61_10		0x0010	/* FIXME rename */
 #define B43_PHY_IQBAL			B43_PHY_OFDM(0x69)	/* I/Q balance */
+#define B43_PHY_BBTXDC_BIAS		B43_PHY_OFDM(0x6B)	/* Baseband TX DC bias */
 #define B43_PHY_OTABLECTL		B43_PHY_OFDM(0x72)	/* OFDM table control (see below) */
 #define  B43_PHY_OTABLEOFF		0x03FF	/* OFDM table offset (see below) */
 #define  B43_PHY_OTABLENR		0xFC00	/* OFDM table number (see below) */
@@ -44,6 +48,9 @@ struct b43_phy;
 #define B43_PHY_OTABLEI			B43_PHY_OFDM(0x73)	/* OFDM table data I */
 #define B43_PHY_OTABLEQ			B43_PHY_OFDM(0x74)	/* OFDM table data Q */
 #define B43_PHY_HPWR_TSSICTL		B43_PHY_OFDM(0x78)	/* Hardware power TSSI control */
+#define B43_PHY_ADCCTL			B43_PHY_OFDM(0x7A)	/* ADC control */
+#define B43_PHY_IDLE_TSSI		B43_PHY_OFDM(0x7B)
+#define B43_PHY_A_TEMP_SENSE		B43_PHY_OFDM(0x7C)	/* A PHY temperature sense */
 #define B43_PHY_NRSSITHRES		B43_PHY_OFDM(0x8A)	/* NRSSI threshold */
 #define B43_PHY_ANTWRSETT		B43_PHY_OFDM(0x8C)	/* Antenna WR settle */
 #define  B43_PHY_ANTWRSETT_ARXDIV	0x2000	/* Automatic RX diversity enabled */
@@ -54,6 +61,8 @@ struct b43_phy;
 #define B43_PHY_N1N2GAIN		B43_PHY_OFDM(0xA2)
 #define B43_PHY_CLIPTHRES		B43_PHY_OFDM(0xA3)
 #define B43_PHY_CLIPN1P2THRES		B43_PHY_OFDM(0xA4)
+#define B43_PHY_CCKSHIFTBITS_WA		B43_PHY_OFDM(0xA5)	/* CCK shiftbits workaround, FIXME rename */
+#define B43_PHY_CCKSHIFTBITS		B43_PHY_OFDM(0xA7)	/* FIXME rename */
 #define B43_PHY_DIVSRCHIDX		B43_PHY_OFDM(0xA8)	/* Divider search gain/index */
 #define B43_PHY_CLIPP2THRES		B43_PHY_OFDM(0xA9)
 #define B43_PHY_CLIPP3THRES		B43_PHY_OFDM(0xAA)
@@ -125,13 +134,14 @@ struct b43_phy;
 #define B43_OFDMTAB_DC			B43_OFDMTAB(0x0E, 7)
 #define B43_OFDMTAB_PWRDYN2		B43_OFDMTAB(0x0E, 12)
 #define B43_OFDMTAB_LNAGAIN		B43_OFDMTAB(0x0E, 13)
-//TODO
+#define B43_OFDMTAB_UNKNOWN_0F		B43_OFDMTAB(0x0F, 0)	//TODO rename
+#define B43_OFDMTAB_UNKNOWN_APHY	B43_OFDMTAB(0x0F, 7)	//TODO rename
 #define B43_OFDMTAB_LPFGAIN		B43_OFDMTAB(0x0F, 12)
 #define B43_OFDMTAB_RSSI		B43_OFDMTAB(0x10, 0)
-//TODO
+#define B43_OFDMTAB_UNKNOWN_11		B43_OFDMTAB(0x11, 4)	//TODO rename
 #define B43_OFDMTAB_AGC1_R1		B43_OFDMTAB(0x13, 0)
-#define B43_OFDMTAB_GAINX_R1		B43_OFDMTAB(0x14, 0)	//TODO rename
-#define B43_OFDMTAB_MINSIGSQ		B43_OFDMTAB(0x14, 1)
+#define B43_OFDMTAB_GAINX_R1		B43_OFDMTAB(0x14, 0)	//TODO remove!
+#define B43_OFDMTAB_MINSIGSQ		B43_OFDMTAB(0x14, 0)
 #define B43_OFDMTAB_AGC3_R1		B43_OFDMTAB(0x15, 0)
 #define B43_OFDMTAB_WRSSI_R1		B43_OFDMTAB(0x15, 4)
 #define B43_OFDMTAB_TSSI		B43_OFDMTAB(0x15, 0)
Index: wireless-2.6/drivers/net/wireless/b43/tables.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/tables.c
+++ wireless-2.6/drivers/net/wireless/b43/tables.c
@@ -229,7 +229,7 @@ const u16 b43_tab_noisea2[] = {
 };
 
 const u16 b43_tab_noisea3[] = {
-	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
+	0x5E5E, 0x5E5E, 0x5E5E, 0x3F48,
 	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
 };
 
@@ -243,6 +243,26 @@ const u16 b43_tab_noiseg2[] = {
 	0x0000, 0x0000, 0x0000, 0x0000,
 };
 
+const u16 b43_tab_noisescalea2[] = {
+	0x6767, 0x6767, 0x6767, 0x6767, /* 0 */
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6700, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x6767, 0x6767, /* 16 */
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x0067,
+};
+
+const u16 b43_tab_noisescalea3[] = {
+	0x2323, 0x2323, 0x2323, 0x2323, /* 0 */
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2300, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x2323, 0x2323, /* 16 */
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x0023,
+};
+
 const u16 b43_tab_noisescaleg1[] = {
 	0x6C77, 0x5162, 0x3B40, 0x3335,	/* 0 */
 	0x2F2D, 0x2A2A, 0x2527, 0x1F21,
@@ -254,7 +274,7 @@ const u16 b43_tab_noisescaleg1[] = {
 };
 
 const u16 b43_tab_noisescaleg2[] = {
-	0xD8DD, 0xCBD4, 0xBCC0, 0XB6B7,	/* 0 */
+	0xD8DD, 0xCBD4, 0xBCC0, 0xB6B7,	/* 0 */
 	0xB2B0, 0xADAD, 0xA7A9, 0x9FA1,
 	0x969B, 0x9195, 0x8F8F, 0x8A8A,
 	0x8A8A, 0x8A00, 0x8A8A, 0x8F8A,
@@ -307,6 +327,28 @@ const u16 b43_tab_sigmasqr2[] = {
 	0x00DE,
 };
 
+const u16 b43_tab_rssiagc1[] = {
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8, /* 0 */
+	0xFFF8, 0xFFF9, 0xFFFC, 0xFFFE,
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+};
+
+const u16 b43_tab_rssiagc2[] = {
+	0x0820, 0x0820, 0x0920, 0x0C38, /* 0 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38, /* 16 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38, /* 32 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+};
+
 static inline void assert_sizes(void)
 {
 	BUILD_BUG_ON(B43_TAB_ROTOR_SIZE != ARRAY_SIZE(b43_tab_rotor));
@@ -317,36 +359,65 @@ static inline void assert_sizes(void)
 	BUILD_BUG_ON(B43_TAB_NOISEA3_SIZE != ARRAY_SIZE(b43_tab_noisea3));
 	BUILD_BUG_ON(B43_TAB_NOISEG1_SIZE != ARRAY_SIZE(b43_tab_noiseg1));
 	BUILD_BUG_ON(B43_TAB_NOISEG2_SIZE != ARRAY_SIZE(b43_tab_noiseg2));
-	BUILD_BUG_ON(B43_TAB_NOISESCALEG_SIZE !=
+	BUILD_BUG_ON(B43_TAB_NOISESCALE_SIZE !=
+		     ARRAY_SIZE(b43_tab_noisescalea2));
+	BUILD_BUG_ON(B43_TAB_NOISESCALE_SIZE !=
+		     ARRAY_SIZE(b43_tab_noisescalea3));
+	BUILD_BUG_ON(B43_TAB_NOISESCALE_SIZE !=
 		     ARRAY_SIZE(b43_tab_noisescaleg1));
-	BUILD_BUG_ON(B43_TAB_NOISESCALEG_SIZE !=
+	BUILD_BUG_ON(B43_TAB_NOISESCALE_SIZE !=
 		     ARRAY_SIZE(b43_tab_noisescaleg2));
-	BUILD_BUG_ON(B43_TAB_NOISESCALEG_SIZE !=
+	BUILD_BUG_ON(B43_TAB_NOISESCALE_SIZE !=
 		     ARRAY_SIZE(b43_tab_noisescaleg3));
 	BUILD_BUG_ON(B43_TAB_SIGMASQR_SIZE != ARRAY_SIZE(b43_tab_sigmasqr1));
 	BUILD_BUG_ON(B43_TAB_SIGMASQR_SIZE != ARRAY_SIZE(b43_tab_sigmasqr2));
+	BUILD_BUG_ON(B43_TAB_RSSIAGC1_SIZE != ARRAY_SIZE(b43_tab_rssiagc1));
+	BUILD_BUG_ON(B43_TAB_RSSIAGC2_SIZE != ARRAY_SIZE(b43_tab_rssiagc2));
 }
 
 u16 b43_ofdmtab_read16(struct b43_wldev *dev, u16 table, u16 offset)
 {
-	assert_sizes();
+	struct b43_phy *phy = &dev->phy;
+	u16 addr;
+
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+		b43_phy_write(dev, B43_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 1;
+	}
+	phy->ofdm_addr = addr;
 
-	b43_phy_write(dev, B43_PHY_OTABLECTL, table + offset);
 	return b43_phy_read(dev, B43_PHY_OTABLEI);
+	assert_sizes();
 }
 
 void b43_ofdmtab_write16(struct b43_wldev *dev, u16 table,
 			 u16 offset, u16 value)
 {
-	b43_phy_write(dev, B43_PHY_OTABLECTL, table + offset);
+	struct b43_phy *phy = &dev->phy;
+	u16 addr;
+
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
+		b43_phy_write(dev, B43_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 2;
+	}
+	phy->ofdm_addr = addr;
 	b43_phy_write(dev, B43_PHY_OTABLEI, value);
 }
 
 u32 b43_ofdmtab_read32(struct b43_wldev *dev, u16 table, u16 offset)
 {
+	struct b43_phy *phy = &dev->phy;
 	u32 ret;
+	u16 addr;
 
-	b43_phy_write(dev, B43_PHY_OTABLECTL, table + offset);
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+		b43_phy_write(dev, B43_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 1;
+	}
+	phy->ofdm_addr = addr;
 	ret = b43_phy_read(dev, B43_PHY_OTABLEQ);
 	ret <<= 16;
 	ret |= b43_phy_read(dev, B43_PHY_OTABLEI);
@@ -357,9 +428,17 @@ u32 b43_ofdmtab_read32(struct b43_wldev 
 void b43_ofdmtab_write32(struct b43_wldev *dev, u16 table,
 			 u16 offset, u32 value)
 {
-	b43_phy_write(dev, B43_PHY_OTABLECTL, table + offset);
+	struct b43_phy *phy = &dev->phy;
+	u16 addr;
+
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
+		b43_phy_write(dev, B43_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 2;
+	}
+	phy->ofdm_addr = addr;
+
 	b43_phy_write(dev, B43_PHY_OTABLEI, value);
-	b43_phy_write(dev, B43_PHY_OTABLEQ, (value >> 16));
 }
 
 u16 b43_gtab_read(struct b43_wldev *dev, u16 table, u16 offset)
Index: wireless-2.6/drivers/net/wireless/b43/tables.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/tables.h
+++ wireless-2.6/drivers/net/wireless/b43/tables.h
@@ -1,9 +1,9 @@
 #ifndef B43_TABLES_H_
 #define B43_TABLES_H_
 
-#define B43_TAB_ROTOR_SIZE		53
+#define B43_TAB_ROTOR_SIZE	53
 extern const u32 b43_tab_rotor[];
-#define B43_TAB_RETARD_SIZE		53
+#define B43_TAB_RETARD_SIZE	53
 extern const u32 b43_tab_retard[];
 #define B43_TAB_FINEFREQA_SIZE	256
 extern const u16 b43_tab_finefreqa[];
@@ -17,12 +17,18 @@ extern const u16 b43_tab_noisea3[];
 extern const u16 b43_tab_noiseg1[];
 #define B43_TAB_NOISEG2_SIZE	8
 extern const u16 b43_tab_noiseg2[];
-#define B43_TAB_NOISESCALEG_SIZE	27
+#define B43_TAB_NOISESCALE_SIZE	27
+extern const u16 b43_tab_noisescalea2[];
+extern const u16 b43_tab_noisescalea3[];
 extern const u16 b43_tab_noisescaleg1[];
 extern const u16 b43_tab_noisescaleg2[];
 extern const u16 b43_tab_noisescaleg3[];
 #define B43_TAB_SIGMASQR_SIZE	53
 extern const u16 b43_tab_sigmasqr1[];
 extern const u16 b43_tab_sigmasqr2[];
+#define B43_TAB_RSSIAGC1_SIZE	16
+extern const u16 b43_tab_rssiagc1[];
+#define B43_TAB_RSSIAGC2_SIZE	48
+extern const u16 b43_tab_rssiagc2[];
 
 #endif /* B43_TABLES_H_ */
Index: wireless-2.6/drivers/net/wireless/b43/wa.c
===================================================================
--- /dev/null
+++ wireless-2.6/drivers/net/wireless/b43/wa.c
@@ -0,0 +1,668 @@
+/*
+
+  Broadcom B43 wireless driver
+
+  PHY workarounds.
+
+  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
+  Copyright (c) 2005-2007 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de>
+  Copyright (c) 2005, 2006 Danny van Dyk <kugelfang at gentoo.org>
+  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+
+*/
+
+#include "b43.h"
+#include "main.h"
+#include "tables.h"
+#include "phy.h"
+#include "wa.h"
+
+static void b43_wa_papd(struct b43_wldev *dev)
+{
+	u16 backup;
+
+	backup = b43_ofdmtab_read16(dev, B43_OFDMTAB_PWRDYN2, 0);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_PWRDYN2, 0, 7);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_APHY, 0, 0);
+	b43_dummy_transmission(dev);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_PWRDYN2, 0, backup);
+}
+
+static void b43_wa_auxclipthr(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, B43_PHY_OFDM(0x8E), 0x3800);
+}
+
+static void b43_wa_afcdac(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, 0x0035, 0x03FF);
+	b43_phy_write(dev, 0x0036, 0x0400);
+}
+
+static void b43_wa_txdc_offset(struct b43_wldev *dev)
+{
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_DC, 0, 0x0051);
+}
+
+void b43_wa_initgains(struct b43_wldev *dev)
+{
+	struct b43_phy *phy = &dev->phy;
+
+	b43_phy_write(dev, B43_PHY_LNAHPFCTL, 0x1FF9);
+	b43_phy_write(dev, B43_PHY_LPFGAINCTL,
+		b43_phy_read(dev, B43_PHY_LPFGAINCTL) & 0xFF0F);
+	if (phy->rev <= 2)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_LPFGAIN, 0, 0x1FBF);
+	b43_radio_write16(dev, 0x0002, 0x1FBF);
+
+	b43_phy_write(dev, 0x0024, 0x4680);
+	b43_phy_write(dev, 0x0020, 0x0003);
+	b43_phy_write(dev, 0x001D, 0x0F40);
+	b43_phy_write(dev, 0x001F, 0x1C00);
+	if (phy->rev <= 3)
+		b43_phy_write(dev, 0x002A,
+			(b43_phy_read(dev, 0x002A) & 0x00FF) | 0x0400);
+	else if (phy->rev == 5) {
+		b43_phy_write(dev, 0x002A,
+			(b43_phy_read(dev, 0x002A) & 0x00FF) | 0x1A00);
+		b43_phy_write(dev, 0x00CC, 0x2121);
+	}
+	if (phy->rev >= 3)
+		b43_phy_write(dev, 0x00BA, 0x3ED5);
+}
+
+static void b43_wa_divider(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, 0x002B, b43_phy_read(dev, 0x002B) & ~0x0100);
+	b43_phy_write(dev, 0x008E, 0x58C1);
+}
+
+static void b43_wa_gt(struct b43_wldev *dev) /* Gain table. */
+{
+	if (dev->phy.rev <= 2) {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN2, 0, 15);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN2, 1, 31);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN2, 2, 42);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN2, 3, 48);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN2, 4, 58);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 0, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 1, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 2, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 3, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 4, 21);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 5, 21);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 6, 25);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN1, 0, 3);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN1, 1, 3);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN1, 2, 7);
+	} else {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 0, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 1, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 2, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 3, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 4, 21);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 5, 21);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_GAIN0, 6, 25);
+	}
+}
+
+static void b43_wa_rssi_lt(struct b43_wldev *dev) /* RSSI lookup table */
+{
+	int i;
+
+	for (i = 0; i < 8; i++)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_RSSI, i, i + 8);
+	for (i = 8; i < 16; i++)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_RSSI, i, i - 8);
+}
+
+static void b43_wa_analog(struct b43_wldev *dev)
+{
+	struct b43_phy *phy = &dev->phy;
+
+	if (phy->analog > 2) {
+		if (phy->type == B43_PHYTYPE_A)
+			b43_phy_write(dev, B43_PHY_PWRDOWN, 0x1808);
+		else
+			b43_phy_write(dev, B43_PHY_PWRDOWN, 0x1000);
+	} else {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 3, 0x1044);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 4, 0x7201);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 6, 0x0040);
+	}
+}
+
+static void b43_wa_dac(struct b43_wldev *dev)
+{
+	if (dev->phy.analog == 1)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 1,
+			(b43_ofdmtab_read16(dev, B43_OFDMTAB_DAC, 1) & ~0x0034) | 0x0008);
+	else
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 1,
+			(b43_ofdmtab_read16(dev, B43_OFDMTAB_DAC, 1) & ~0x0078) | 0x0010);
+}
+
+static void b43_wa_fft(struct b43_wldev *dev) /* Fine frequency table */
+{
+	int i;
+
+	if (dev->phy.type == B43_PHYTYPE_A)
+		for (i = 0; i < B43_TAB_FINEFREQA_SIZE; i++)
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_DACRFPABB, i, b43_tab_finefreqa[i]);
+	else
+		for (i = 0; i < B43_TAB_FINEFREQG_SIZE; i++)
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_DACRFPABB, i, b43_tab_finefreqg[i]);
+}
+
+static void b43_wa_nft(struct b43_wldev *dev) /* Noise figure table */
+{
+	struct b43_phy *phy = &dev->phy;
+	int i;
+
+	if (phy->type == B43_PHYTYPE_A) {
+		if (phy->rev == 2)
+			for (i = 0; i < B43_TAB_NOISEA2_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, i, b43_tab_noisea2[i]);
+		else
+			for (i = 0; i < B43_TAB_NOISEA3_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, i, b43_tab_noisea3[i]);
+	} else {
+		if (phy->rev == 1)
+			for (i = 0; i < B43_TAB_NOISEG1_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, i, b43_tab_noiseg1[i]);
+		else
+			for (i = 0; i < B43_TAB_NOISEG2_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, i, b43_tab_noiseg2[i]);
+	}
+}
+
+static void b43_wa_rt(struct b43_wldev *dev) /* Rotor table */
+{
+	int i;
+
+	for (i = 0; i < B43_TAB_ROTOR_SIZE; i++)
+		b43_ofdmtab_write32(dev, B43_OFDMTAB_ROTOR, i, b43_tab_rotor[i]);
+}
+
+static void b43_wa_nst(struct b43_wldev *dev) /* Noise scale table */
+{
+	struct b43_phy *phy = &dev->phy;
+	int i;
+
+	if (phy->type == B43_PHYTYPE_A) {
+		if (phy->rev <= 1)
+			for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+							i, 0);
+		else if (phy->rev == 2)
+			for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+							i, b43_tab_noisescalea2[i]);
+		else if (phy->rev == 3)
+			for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+							i, b43_tab_noisescalea3[i]);
+		else
+			for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+							i, b43_tab_noisescaleg3[i]);
+	} else {
+		if (phy->rev >= 6) {
+			if (b43_phy_read(dev, B43_PHY_ENCORE) & B43_PHY_ENCORE_EN)
+				for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+					b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+						i, b43_tab_noisescaleg3[i]);
+			else
+				for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+					b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+						i, b43_tab_noisescaleg2[i]);
+		} else {
+			for (i = 0; i < B43_TAB_NOISESCALE_SIZE; i++)
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_NOISESCALE,
+							i, b43_tab_noisescaleg1[i]);
+		}
+	}
+}
+
+static void b43_wa_art(struct b43_wldev *dev) /* ADV retard table */
+{
+	int i;
+
+	for (i = 0; i < B43_TAB_RETARD_SIZE; i++)
+			b43_ofdmtab_write32(dev, B43_OFDMTAB_ADVRETARD,
+				i, b43_tab_retard[i]);
+}
+
+static void b43_wa_txlna_gain(struct b43_wldev *dev)
+{
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_DC, 13, 0x0000);
+}
+
+static void b43_wa_crs_reset(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, 0x002C, 0x0064);
+}
+
+static void b43_wa_2060txlna_gain(struct b43_wldev *dev)
+{
+	b43_hf_write(dev, b43_hf_read(dev) |
+			 B43_HF_2060W);
+}
+
+static void b43_wa_lms(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, 0x0055,
+		(b43_phy_read(dev, 0x0055) & 0xFFC0) | 0x0004);
+}
+
+static void b43_wa_mixedsignal(struct b43_wldev *dev)
+{
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 1, 3);
+}
+
+static void b43_wa_msst(struct b43_wldev *dev) /* Min sigma square table */
+{
+	struct b43_phy *phy = &dev->phy;
+	int i;
+	const u16 *tab;
+
+	if (phy->type == B43_PHYTYPE_A) {
+		tab = b43_tab_sigmasqr1;
+	} else if (phy->type == B43_PHYTYPE_G) {
+		tab = b43_tab_sigmasqr2;
+	} else {
+		B43_WARN_ON(1);
+		return;
+	}
+
+	for (i = 0; i < B43_TAB_SIGMASQR_SIZE; i++) {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_MINSIGSQ,
+					i, tab[i]);
+	}
+}
+
+static void b43_wa_iqadc(struct b43_wldev *dev)
+{
+	if (dev->phy.analog == 4)
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 0,
+			b43_ofdmtab_read16(dev, B43_OFDMTAB_DAC, 0) & ~0xF000);
+}
+
+static void b43_wa_crs_ed(struct b43_wldev *dev)
+{
+	struct b43_phy *phy = &dev->phy;
+
+	if (phy->rev == 1) {
+		b43_phy_write(dev, B43_PHY_CRSTHRES1, 0x4F19);
+	} else if (phy->rev == 2) {
+		b43_phy_write(dev, B43_PHY_CRSTHRES1_R1, 0x1861);
+		b43_phy_write(dev, B43_PHY_CRSTHRES2_R1, 0x1861);
+		b43_phy_write(dev, B43_PHY_ANTDWELL,
+				  b43_phy_read(dev, B43_PHY_ANTDWELL)
+				  | 0x0800);
+	} else {
+		b43_phy_write(dev, B43_PHY_CRSTHRES1_R1, 0x0098);
+		b43_phy_write(dev, B43_PHY_CRSTHRES2_R1, 0x0070);
+		b43_phy_write(dev, B43_PHY_OFDM(0xC9), 0x0080);
+		b43_phy_write(dev, B43_PHY_ANTDWELL,
+				  b43_phy_read(dev, B43_PHY_ANTDWELL)
+				  | 0x0800);
+	}
+}
+
+static void b43_wa_crs_thr(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, B43_PHY_CRS0,
+			(b43_phy_read(dev, B43_PHY_CRS0) & ~0x03C0) | 0xD000);
+}
+
+static void b43_wa_crs_blank(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, B43_PHY_OFDM(0x2C), 0x005A);
+}
+
+static void b43_wa_cck_shiftbits(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, B43_PHY_CCKSHIFTBITS, 0x0026);
+}
+
+static void b43_wa_wrssi_offset(struct b43_wldev *dev)
+{
+	int i;
+
+	if (dev->phy.rev == 1) {
+		for (i = 0; i < 16; i++) {
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_WRSSI_R1,
+						i, 0x0020);
+		}
+	} else {
+		for (i = 0; i < 32; i++) {
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_WRSSI,
+						i, 0x0820);
+		}
+	}
+}
+
+static void b43_wa_txpuoff_rxpuon(struct b43_wldev *dev)
+{
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_0F, 2, 15);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_0F, 3, 20);
+}
+
+static void b43_wa_altagc(struct b43_wldev *dev)
+{
+	struct b43_phy *phy = &dev->phy;
+
+	if (phy->rev == 1) {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 0, 254);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 1, 13);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 2, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1_R1, 3, 25);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, 0, 0x2710);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, 1, 0x9B83);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, 2, 0x9B83);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC2, 3, 0x0F8D);
+		b43_phy_write(dev, B43_PHY_LMS, 4);
+	} else {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0, 254);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 1, 13);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 2, 19);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 3, 25);
+	}
+
+	b43_phy_write(dev, B43_PHY_CCKSHIFTBITS_WA,
+		(b43_phy_read(dev, B43_PHY_CCKSHIFTBITS_WA) & ~0xFF00) | 0x5700);
+	b43_phy_write(dev, B43_PHY_OFDM(0x1A),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x1A)) & ~0x007F) | 0x000F);
+	b43_phy_write(dev, B43_PHY_OFDM(0x1A),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x1A)) & ~0x3F80) | 0x2B80);
+	b43_phy_write(dev, B43_PHY_ANTWRSETT,
+		(b43_phy_read(dev, B43_PHY_ANTWRSETT) & 0xF0FF) | 0x0300);
+	b43_radio_write16(dev, 0x7A,
+		b43_radio_read16(dev, 0x7A) | 0x0008);
+	b43_phy_write(dev, B43_PHY_N1P1GAIN,
+		(b43_phy_read(dev, B43_PHY_N1P1GAIN) & ~0x000F) | 0x0008);
+	b43_phy_write(dev, B43_PHY_P1P2GAIN,
+		(b43_phy_read(dev, B43_PHY_P1P2GAIN) & ~0x0F00) | 0x0600);
+	b43_phy_write(dev, B43_PHY_N1N2GAIN,
+		(b43_phy_read(dev, B43_PHY_N1N2GAIN) & ~0x0F00) | 0x0700);
+	b43_phy_write(dev, B43_PHY_N1P1GAIN,
+		(b43_phy_read(dev, B43_PHY_N1P1GAIN) & ~0x0F00) | 0x0100);
+	if (phy->rev == 1) {
+		b43_phy_write(dev, B43_PHY_N1N2GAIN,
+				  (b43_phy_read(dev, B43_PHY_N1N2GAIN)
+				   & ~0x000F) | 0x0007);
+	}
+	b43_phy_write(dev, B43_PHY_OFDM(0x88),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x88)) & ~0x00FF) | 0x001C);
+	b43_phy_write(dev, B43_PHY_OFDM(0x88),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x88)) & ~0x3F00) | 0x0200);
+	b43_phy_write(dev, B43_PHY_OFDM(0x96),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x96)) & ~0x00FF) | 0x001C);
+	b43_phy_write(dev, B43_PHY_OFDM(0x89),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x89)) & ~0x00FF) | 0x0020);
+	b43_phy_write(dev, B43_PHY_OFDM(0x89),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x89)) & ~0x3F00) | 0x0200);
+	b43_phy_write(dev, B43_PHY_OFDM(0x82),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x82)) & ~0x00FF) | 0x002E);
+	b43_phy_write(dev, B43_PHY_OFDM(0x96),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x96)) & ~0xFF00) | 0x1A00);
+	b43_phy_write(dev, B43_PHY_OFDM(0x81),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x81)) & ~0x00FF) | 0x0028);
+	b43_phy_write(dev, B43_PHY_OFDM(0x81),
+		(b43_phy_read(dev, B43_PHY_OFDM(0x81)) & ~0xFF00) | 0x2C00);
+	if (phy->rev == 1) {
+		b43_phy_write(dev, B43_PHY_PEAK_COUNT, 0x092B);
+		b43_phy_write(dev, B43_PHY_OFDM(0x1B),
+			(b43_phy_read(dev, B43_PHY_OFDM(0x1B)) & ~0x001E) | 0x0002);
+	} else {
+		b43_phy_write(dev, B43_PHY_OFDM(0x1B),
+			b43_phy_read(dev, B43_PHY_OFDM(0x1B)) & ~0x001E);
+		b43_phy_write(dev, B43_PHY_OFDM(0x1F), 0x287A);
+		b43_phy_write(dev, B43_PHY_LPFGAINCTL,
+			(b43_phy_read(dev, B43_PHY_LPFGAINCTL) & ~0x000F) | 0x0004);
+		if (phy->rev >= 6) {
+			b43_phy_write(dev, B43_PHY_OFDM(0x22), 0x287A);
+			b43_phy_write(dev, B43_PHY_LPFGAINCTL,
+				(b43_phy_read(dev, B43_PHY_LPFGAINCTL) & ~0xF000) | 0x3000);
+		}
+	}
+	b43_phy_write(dev, B43_PHY_DIVSRCHIDX,
+		(b43_phy_read(dev, B43_PHY_DIVSRCHIDX) & 0x7F7F) | 0x7874);
+	b43_phy_write(dev, B43_PHY_OFDM(0x8E), 0x1C00);
+	if (phy->rev == 1) {
+		b43_phy_write(dev, B43_PHY_DIVP1P2GAIN,
+			(b43_phy_read(dev, B43_PHY_DIVP1P2GAIN) & ~0x0F00) | 0x0600);
+		b43_phy_write(dev, B43_PHY_OFDM(0x8B), 0x005E);
+		b43_phy_write(dev, B43_PHY_ANTWRSETT,
+			(b43_phy_read(dev, B43_PHY_ANTWRSETT) & ~0x00FF) | 0x001E);
+		b43_phy_write(dev, B43_PHY_OFDM(0x8D), 0x0002);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 0, 0);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 1, 7);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 2, 16);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3_R1, 3, 28);
+	} else {
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 0, 0);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 1, 7);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 2, 16);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC3, 3, 28);
+	}
+	if (phy->rev >= 6) {
+		b43_phy_write(dev, B43_PHY_OFDM(0x26),
+			b43_phy_read(dev, B43_PHY_OFDM(0x26)) & ~0x0003);
+		b43_phy_write(dev, B43_PHY_OFDM(0x26),
+			b43_phy_read(dev, B43_PHY_OFDM(0x26)) & ~0x1000);
+	}
+}
+
+static void b43_wa_tr_ltov(struct b43_wldev *dev) /* TR Lookup Table Original Values */
+{
+	b43_gtab_write(dev, B43_GTAB_ORIGTR, 0, 0xC480);
+}
+
+static void b43_wa_cpll_nonpilot(struct b43_wldev *dev)
+{
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_11, 0, 0);
+	b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_11, 1, 0);
+}
+
+static void b43_wa_rssi_adc(struct b43_wldev *dev)
+{
+	if (dev->phy.analog == 4)
+		b43_phy_write(dev, 0x00DC, 0x7454);
+}
+
+static void b43_wa_boards_a(struct b43_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+
+	if (bus->boardinfo.vendor == SSB_BOARDVENDOR_BCM &&
+	    bus->boardinfo.type == SSB_BOARD_BU4306 &&
+	    bus->boardinfo.rev < 0x30) {
+		b43_phy_write(dev, 0x0010, 0xE000);
+		b43_phy_write(dev, 0x0013, 0x0140);
+		b43_phy_write(dev, 0x0014, 0x0280);
+	} else {
+		if (bus->boardinfo.type == SSB_BOARD_MP4318 &&
+		    bus->boardinfo.rev < 0x20) {
+			b43_phy_write(dev, 0x0013, 0x0210);
+			b43_phy_write(dev, 0x0014, 0x0840);
+		} else {
+			b43_phy_write(dev, 0x0013, 0x0140);
+			b43_phy_write(dev, 0x0014, 0x0280);
+		}
+		if (dev->phy.rev <= 4)
+			b43_phy_write(dev, 0x0010, 0xE000);
+		else
+			b43_phy_write(dev, 0x0010, 0x2000);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_DC, 1, 0x0039);
+		b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_APHY, 7, 0x0040);
+	}
+}
+
+static void b43_wa_boards_g(struct b43_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+	struct b43_phy *phy = &dev->phy;
+
+	if (bus->boardinfo.vendor != SSB_BOARDVENDOR_BCM ||
+	    bus->boardinfo.type != SSB_BOARD_BU4306 ||
+	    bus->boardinfo.rev != 0x17) {
+		if (phy->rev < 2) {
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX_R1, 1, 0x0002);
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX_R1, 2, 0x0001);
+		} else {
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 1, 0x0002);
+			b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 2, 0x0001);
+			if ((bus->sprom.r1.boardflags_lo & B43_BFL_EXTLNA) &&
+			    (phy->rev >= 7)) {
+				b43_phy_write(dev, B43_PHY_EXTG(0x11),
+					b43_phy_read(dev, B43_PHY_EXTG(0x11)) & 0xF7FF);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0020, 0x0001);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0021, 0x0001);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0022, 0x0001);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0023, 0x0000);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0000, 0x0000);
+				b43_ofdmtab_write16(dev, B43_OFDMTAB_GAINX, 0x0003, 0x0002);
+			}
+		}
+	}
+	if (bus->sprom.r1.boardflags_lo & B43_BFL_FEM) {
+		b43_phy_write(dev, B43_PHY_GTABCTL, 0x3120);
+		b43_phy_write(dev, B43_PHY_GTABDATA, 0xC480);
+	}
+}
+
+void b43_wa_all(struct b43_wldev *dev)
+{
+	struct b43_phy *phy = &dev->phy;
+
+	if (phy->type == B43_PHYTYPE_A) {
+		switch (phy->rev) {
+		case 2:
+			b43_wa_papd(dev);
+			b43_wa_auxclipthr(dev);
+			b43_wa_afcdac(dev);
+			b43_wa_txdc_offset(dev);
+			b43_wa_initgains(dev);
+			b43_wa_divider(dev);
+			b43_wa_gt(dev);
+			b43_wa_rssi_lt(dev);
+			b43_wa_analog(dev);
+			b43_wa_dac(dev);
+			b43_wa_fft(dev);
+			b43_wa_nft(dev);
+			b43_wa_rt(dev);
+			b43_wa_nst(dev);
+			b43_wa_art(dev);
+			b43_wa_txlna_gain(dev);
+			b43_wa_crs_reset(dev);
+			b43_wa_2060txlna_gain(dev);
+			b43_wa_lms(dev);
+			break;
+		case 3:
+			b43_wa_papd(dev);
+			b43_wa_mixedsignal(dev);
+			b43_wa_rssi_lt(dev);
+			b43_wa_txdc_offset(dev);
+			b43_wa_initgains(dev);
+			b43_wa_dac(dev);
+			b43_wa_nft(dev);
+			b43_wa_nst(dev);
+			b43_wa_msst(dev);
+			b43_wa_analog(dev);
+			b43_wa_gt(dev);
+			b43_wa_txpuoff_rxpuon(dev);
+			b43_wa_txlna_gain(dev);
+			break;
+		case 5:
+			b43_wa_iqadc(dev);
+		case 6:
+			b43_wa_papd(dev);
+			b43_wa_rssi_lt(dev);
+			b43_wa_txdc_offset(dev);
+			b43_wa_initgains(dev);
+			b43_wa_dac(dev);
+			b43_wa_nft(dev);
+			b43_wa_nst(dev);
+			b43_wa_msst(dev);
+			b43_wa_analog(dev);
+			b43_wa_gt(dev);
+			b43_wa_txpuoff_rxpuon(dev);
+			b43_wa_txlna_gain(dev);
+			break;
+		case 7:
+			b43_wa_iqadc(dev);
+			b43_wa_papd(dev);
+			b43_wa_rssi_lt(dev);
+			b43_wa_txdc_offset(dev);
+			b43_wa_initgains(dev);
+			b43_wa_dac(dev);
+			b43_wa_nft(dev);
+			b43_wa_nst(dev);
+			b43_wa_msst(dev);
+			b43_wa_analog(dev);
+			b43_wa_gt(dev);
+			b43_wa_txpuoff_rxpuon(dev);
+			b43_wa_txlna_gain(dev);
+			b43_wa_rssi_adc(dev);
+		default:
+			B43_WARN_ON(1);
+		}
+		b43_wa_boards_a(dev);
+	} else if (phy->type == B43_PHYTYPE_G) {
+		switch (phy->rev) {
+		case 1://XXX review rev1
+			b43_wa_crs_ed(dev);
+			b43_wa_crs_thr(dev);
+			b43_wa_crs_blank(dev);
+			b43_wa_cck_shiftbits(dev);
+			b43_wa_fft(dev);
+			b43_wa_nft(dev);
+			b43_wa_rt(dev);
+			b43_wa_nst(dev);
+			b43_wa_art(dev);
+			b43_wa_wrssi_offset(dev);
+			b43_wa_altagc(dev);
+			break;
+		case 2:
+		case 6:
+		case 7:
+		case 8:
+			b43_wa_tr_ltov(dev);
+			b43_wa_crs_ed(dev);
+			b43_wa_rssi_lt(dev);
+			b43_wa_nft(dev);
+			b43_wa_nst(dev);
+			b43_wa_msst(dev);
+			b43_wa_wrssi_offset(dev);
+			b43_wa_altagc(dev);
+			b43_wa_analog(dev);
+			b43_wa_txpuoff_rxpuon(dev);
+			break;
+		default:
+			B43_WARN_ON(1);
+		}
+		b43_wa_boards_g(dev);
+	} else { /* No N PHY support so far */
+		B43_WARN_ON(1);
+	}
+
+	b43_wa_cpll_nonpilot(dev);
+}
Index: wireless-2.6/drivers/net/wireless/b43/wa.h
===================================================================
--- /dev/null
+++ wireless-2.6/drivers/net/wireless/b43/wa.h
@@ -0,0 +1,7 @@
+#ifndef B43_WA_H_
+#define B43_WA_H_
+
+void b43_wa_initgains(struct b43_wldev *dev);
+void b43_wa_all(struct b43_wldev *dev);
+
+#endif /* B43_WA_H_ */



--
Ciao
Stefano


From stefano.brivio at polimi.it  Tue Nov  6 22:49:20 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 6 Nov 2007 22:49:20 +0100
Subject: [PATCH 7/7] b43/b43legacy: fix my copyright notices
In-Reply-To: <20071106222313.31e9bcd9@morte>
References: <20071106222313.31e9bcd9@morte>
Message-ID: <20071106224920.20f329b3@morte>

Fix my copyright notices in b43 and b43legacy.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
Cc: Michael Buesch <mb at bu3sch.de>

----

Index: wireless-2.6/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.c
+++ wireless-2.6/drivers/net/wireless/b43/leds.c
@@ -4,7 +4,7 @@
   LED control
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-  Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005 Stefano Brivio <stefano.brivio at polimi.it>
   Copyright (c) 2005-2007 Michael Buesch <mb at bu3sch.de>
   Copyright (c) 2005 Danny van Dyk <kugelfang at gentoo.org>
   Copyright (c) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/lo.c
+++ wireless-2.6/drivers/net/wireless/b43/lo.c
@@ -5,7 +5,7 @@
   G PHY LO (LocalOscillator) Measuring and Control routines
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-  Copyright (c) 2005, 2006 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005, 2006 Stefano Brivio <stefano.brivio at polimi.it>
   Copyright (c) 2005-2007 Michael Buesch <mb at bu3sch.de>
   Copyright (c) 2005, 2006 Danny van Dyk <kugelfang at gentoo.org>
   Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -3,7 +3,7 @@
   Broadcom B43 wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>
-  Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005 Stefano Brivio <stefano.brivio at polimi.it>
   Copyright (c) 2005, 2006 Michael Buesch <mb at bu3sch.de>
   Copyright (c) 2005 Danny van Dyk <kugelfang at gentoo.org>
   Copyright (c) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43/main.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.h
+++ wireless-2.6/drivers/net/wireless/b43/main.h
@@ -3,7 +3,7 @@
   Broadcom B43 wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
+                     Stefano Brivio <stefano.brivio at polimi.it>
                      Michael Buesch <mb at bu3sch.de>
                      Danny van Dyk <kugelfang at gentoo.org>
                      Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c
+++ wireless-2.6/drivers/net/wireless/b43/phy.c
@@ -3,7 +3,7 @@
   Broadcom B43 wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-  Copyright (c) 2005, 2006 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005-2007 Stefano Brivio <stefano.brivio at polimi.it>
   Copyright (c) 2005, 2006 Michael Buesch <mb at bu3sch.de>
   Copyright (c) 2005, 2006 Danny van Dyk <kugelfang at gentoo.org>
   Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43/tables.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/tables.c
+++ wireless-2.6/drivers/net/wireless/b43/tables.c
@@ -3,7 +3,7 @@
   Broadcom B43 wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-  Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005-2007 Stefano Brivio <stefano.brivio at polimi.it>
   Copyright (c) 2006, 2006 Michael Buesch <mb at bu3sch.de>
   Copyright (c) 2005 Danny van Dyk <kugelfang at gentoo.org>
   Copyright (c) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
+++ wireless-2.6/drivers/net/wireless/b43/wa.c
@@ -4,11 +4,8 @@
 
   PHY workarounds.
 
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-  Copyright (c) 2005-2007 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005-2007 Stefano Brivio <stefano.brivio at polimi.it>
   Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de>
-  Copyright (c) 2005, 2006 Danny van Dyk <kugelfang at gentoo.org>
-  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi at waterwave.ch>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c
+++ wireless-2.6/drivers/net/wireless/b43/xmit.c
@@ -5,7 +5,7 @@
   Transmission (TX/RX) related functions.
 
   Copyright (C) 2005 Martin Langer <martin-langer at gmx.de>
-  Copyright (C) 2005 Stefano Brivio <st3 at riseup.net>
+  Copyright (C) 2005 Stefano Brivio <stefano.brivio at polimi.it>
   Copyright (C) 2005, 2006 Michael Buesch <mb at bu3sch.de>
   Copyright (C) 2005 Danny van Dyk <kugelfang at gentoo.org>
   Copyright (C) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43legacy/ilt.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/ilt.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/ilt.c
@@ -3,7 +3,7 @@
   Broadcom B43legacy wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-		     Stefano Brivio <st3 at riseup.net>
+		     Stefano Brivio <stefano.brivio at polimi.it>
 		     Michael Buesch <mbuesch at freenet.de>
 		     Danny van Dyk <kugelfang at gentoo.org>
 		     Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43legacy/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/leds.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/leds.c
@@ -4,7 +4,7 @@
   LED control
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-  Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005 Stefano Brivio <stefano.brivio at polimi.it>
   Copyright (c) 2005-2007 Michael Buesch <mb at bu3sch.de>
   Copyright (c) 2005 Danny van Dyk <kugelfang at gentoo.org>
   Copyright (c) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -3,7 +3,7 @@
  *  Broadcom B43legacy wireless driver
  *
  *  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>
- *  Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+ *  Copyright (c) 2005-2007 Stefano Brivio <stefano.brivio at polimi.it>
  *  Copyright (c) 2005, 2006 Michael Buesch <mb at bu3sch.de>
  *  Copyright (c) 2005 Danny van Dyk <kugelfang at gentoo.org>
  *  Copyright (c) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43legacy/main.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.h
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.h
@@ -3,7 +3,7 @@
   Broadcom B43legacy wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-  Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005 Stefano Brivio <stefano.brivio at polimi.it>
   Copyright (c) 2005, 2006 Michael Buesch <mb at bu3sch.de>
   Copyright (c) 2005  Danny van Dyk <kugelfang at gentoo.org>
   Copyright (c) 2005  Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43legacy/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/phy.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/phy.c
@@ -3,7 +3,7 @@
   Broadcom B43legacy wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-		     Stefano Brivio <st3 at riseup.net>
+		     Stefano Brivio <stefano.brivio at polimi.it>
 		     Michael Buesch <mbuesch at freenet.de>
 		     Danny van Dyk <kugelfang at gentoo.org>
      Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43legacy/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/phy.h
+++ wireless-2.6/drivers/net/wireless/b43legacy/phy.h
@@ -3,7 +3,7 @@
   Broadcom B43legacy wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-		     Stefano Brivio <st3 at riseup.net>
+		     Stefano Brivio <stefano.brivio at polimi.it>
 		     Michael Buesch <mbuesch at freenet.de>
 		     Danny van Dyk <kugelfang at gentoo.org>
 		     Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43legacy/radio.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/radio.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/radio.c
@@ -3,7 +3,7 @@
   Broadcom B43legacy wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-		     Stefano Brivio <st3 at riseup.net>
+		     Stefano Brivio <stefano.brivio at polimi.it>
 		     Michael Buesch <mbuesch at freenet.de>
 		     Danny van Dyk <kugelfang at gentoo.org>
 		     Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43legacy/radio.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/radio.h
+++ wireless-2.6/drivers/net/wireless/b43legacy/radio.h
@@ -3,7 +3,7 @@
   Broadcom B43legacy wireless driver
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-		     Stefano Brivio <st3 at riseup.net>
+		     Stefano Brivio <stefano.brivio at polimi.it>
 		     Michael Buesch <mbuesch at freenet.de>
 		     Danny van Dyk <kugelfang at gentoo.org>
 		     Andreas Jaggi <andreas.jaggi at waterwave.ch>
Index: wireless-2.6/drivers/net/wireless/b43legacy/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/xmit.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/xmit.c
@@ -5,7 +5,7 @@
   Transmission (TX/RX) related functions.
 
   Copyright (C) 2005 Martin Langer <martin-langer at gmx.de>
-  Copyright (C) 2005 Stefano Brivio <st3 at riseup.net>
+  Copyright (C) 2005 Stefano Brivio <stefano.brivio at polimi.it>
   Copyright (C) 2005, 2006 Michael Buesch <mb at bu3sch.de>
   Copyright (C) 2005 Danny van Dyk <kugelfang at gentoo.org>
   Copyright (C) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>



-- 
Ciao
Stefano


From rjw at sisk.pl  Wed Nov  7 00:25:52 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Wed, 7 Nov 2007 00:25:52 +0100
Subject: b43 on HP nx6325 w/ openSUSE 10.3 (x86_64)
In-Reply-To: <47309C50.5030106@lwfinger.net>
References: <200711050113.55591.rjw@sisk.pl> <200711052213.03362.rjw@sisk.pl>
	<47309C50.5030106@lwfinger.net>
Message-ID: <200711070025.52988.rjw@sisk.pl>

On Tuesday, 6 of November 2007, Larry Finger wrote:
> Rafael J. Wysocki wrote:
> > On Monday, 5 of November 2007, Larry Finger wrote:
> >> Rafael J. Wysocki wrote:
> >>> Hi,
> >>>
> >>> I'm trying to make the b43 driver work on an HP nx6325 with openSUSE 10.3
> >>> (64-bit).  In short, it sort of works, but some things are a bit ugly.
> >>>
> >>> The kernel is the current -git (approx. 2.6.24-rc1-git13) with the following
> >>> extra patches applied:
> >>>
> >>> b43: Fix rfkill callback deadlock
> >>> b43: debugfs SHM read buffer overrun fix
> >>> b43: Rewrite and fix rfkill init
> >>>
> >>> and I'm using the firmware from
> >>> http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2
> >>>
> >>> Here's the debug info from dmesg:
> >>>
> >>> b43-phy1: Broadcom 4311 WLAN found
> >>> b43-phy1 debug: Found PHY: Analog 4, Type 2, Revision 8
> >>> b43-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> >>> b43-phy1 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> >>> Registered led device: b43-phy1:tx
> >>> Registered led device: b43-phy1:rx
> >>> b43-phy1 debug: Chip initialized
> >>> b43-phy1 debug: 32-bit DMA initialized
> >>> b43-phy1 debug: Wireless interface started
> >>> b43-phy1 debug: Adding Interface type 2
> >>>
> >>> Now, the first problem is that the card seems to lose frames from time to
> >>> time.  This is visible in the output of mtr and while trying to transfer large
> >>> files using scp.  With scp the transfer just stalls and stays this way although
> >>> the other end is pingable etc. (eg. attempting to transfer more than 400 MB at
> >>> once triggers this 100% of the time).
> >>>
> >>> If you can suggest some more specific tests to me, I'll run them and report
> >>> back.
> >>>
> >>> The second problem is that YaST is apparently unable to detect the device,
> >>> which sort of sucks, because it leads to configuration problems (basically, you
> >>> need to set up everything manually).  Evidently, udev manages to handle it, so
> >>> this may be related to HAL.  Anyway, it looks like the problem is related to
> >>> the fact that the device is not present under /sys/bus/pci/devices/ directly,
> >>> but you need to go through the ssb0:0 subdirectory to get to it.
> >>>
> >>> Do you have any ideas how to tell the user space stuff where the devices is
> >>> in sysfs?
> >> Your configuration is exactly like mine - openSUSE 10.3, x86_64 with Linus's latest git, and a 4311.
> >>  I have not used mtr or scp and cannot comment on your transfer problems.
> > 
> > That may be AP-related, but I had no such problems with the bcm43xx used
> > previously on the same hardware w/ the same AP.
> > 
> >> I have had 0 problems configuring the device with YaST.
> > 
> > Hm, I wonder what I've done wrong, then. :-)
> > 
> > Can you send me /etc/sysconfig/network/ifcfg-wlan0 (or whatever the card is
> > visible as on your system) from the x86_64 laptop?
> 
> This config file is for WPA-PSK TKIP
> 
> BOOTPROTO='dhcp'
> BROADCAST=''
> ETHTOOL_OPTIONS=''
> IFPLUGD_PRIORITY='10'
> IPADDR=''
> MTU=''
> NAME='Hewlett-Packard Company WLAN controller'
> NETMASK=''
> NETWORK=''
> REMOTE_IPADDR=''
> STARTMODE='ifplugd'
> USERCONTROL='yes'
> WIRELESS_AP=''
> WIRELESS_AUTH_MODE='psk'
> WIRELESS_BITRATE='auto'
> WIRELESS_CA_CERT=''
> WIRELESS_CHANNEL=''
> WIRELESS_CLIENT_CERT=''
> WIRELESS_CLIENT_KEY=''
> WIRELESS_CLIENT_KEY_PASSWORD=''
> WIRELESS_DEFAULT_KEY='0'
> WIRELESS_EAP_AUTH=''
> WIRELESS_EAP_MODE=''
> WIRELESS_ESSID='lwfdjf'
> WIRELESS_FREQUENCY=''
> WIRELESS_KEY=''
> WIRELESS_KEY_0=''
> WIRELESS_KEY_1=''
> WIRELESS_KEY_2=''
> WIRELESS_KEY_3=''
> WIRELESS_KEY_LENGTH='128'
> WIRELESS_MODE='Managed'
> WIRELESS_NICK=''
> WIRELESS_NWID=''
> WIRELESS_PEAP_VERSION=''
> WIRELESS_POWER='yes'
> WIRELESS_WPA_ANONID=''
> WIRELESS_WPA_IDENTITY=''
> WIRELESS_WPA_PASSWORD=''
> WIRELESS_WPA_PSK='<My secret>'

Thanks!

Well, it's similar to mine ...

Anyway, I'm now running NetworkManager with b43 and it seems fine so far
(except for the transfer problems described in the $subject message).

Greetings,
Rafael


From stefano.brivio at polimi.it  Wed Nov  7 18:16:11 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Wed, 7 Nov 2007 18:16:11 +0100
Subject: [PATCH] b43: fix shared IRQ race condition
Message-ID: <20071107181611.23de23f1@morte>

Fix an IRQ race condition in b43. If we call b43_stop_wireless_core(), it
will set the status of the device to INITIALIZED and the IRQ handler won't
care any longer about IRQs, thus the kernel will disable the IRQ if it's
shared (unless we boot it with the 'irqpoll' option). So we must disable
IRQs before changing the device status.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

--- wireless-2.6/drivers/net/wireless/b43/main.c.orig	2007-11-07 17:55:30.553591943 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2007-11-07 17:59:23.356020048 +0100
@@ -2979,6 +2979,16 @@
 
 	if (b43_status(dev) < B43_STAT_STARTED)
 		return;
+
+	/* Disable and sync interrupts. We must do this before than
+	 * setting the status to INITIALIZED, as the interrupt handler
+	 * won't care about IRQs then. */
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	dev->irq_savedstate = b43_interrupt_disable(dev, B43_IRQ_ALL);
+	b43_read32(dev, B43_MMIO_GEN_IRQ_MASK);	/* flush */
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+	b43_synchronize_irq(dev);
+
 	b43_set_status(dev, B43_STAT_INITIALIZED);
 
 	mutex_unlock(&wl->mutex);
@@ -2989,13 +2999,6 @@
 
 	ieee80211_stop_queues(wl->hw);	//FIXME this could cause a deadlock, as mac80211 seems buggy.
 
-	/* Disable and sync interrupts. */
-	spin_lock_irqsave(&wl->irq_lock, flags);
-	dev->irq_savedstate = b43_interrupt_disable(dev, B43_IRQ_ALL);
-	b43_read32(dev, B43_MMIO_GEN_IRQ_MASK);	/* flush */
-	spin_unlock_irqrestore(&wl->irq_lock, flags);
-	b43_synchronize_irq(dev);
-
 	b43_mac_suspend(dev);
 	free_irq(dev->dev->irq, dev);
 	b43dbg(wl, "Wireless interface stopped\n");


-- 
Ciao
Stefano


From rugg.argos at tiscali.it  Wed Nov  7 18:20:41 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Wed, 7 Nov 2007 18:20:41 +0100
Subject: BCM94311MCG
Message-ID: <001e01c82162$864cc970$0601a8c0@ruggiero>

i don't know if it's this the place to write about this problem...but if u say me where i should post the problem i'll do...here it comes...
i have installed ubuntu 7.10 and i recompiled the kernel with to 2.6.23.1 because on the earlier kernel my wireless card didn't work with bcm43xx drivers but only with ndiswrapper..(i could see the access point but couldn't connect to it)
now after recompiled i installed bcm43xx-fwcutter and by this i extracted the firmware using wl_apsta-3.130.20.0.o .. now as for the earlier kernel i can see the access point by typing "sudo iwlist scan" but i can't connect to it..sometime i can but only if i'm near to the access point(two meters) but anyway speed is really slow :(

the card BCM94311MCG rev01 this is what comes out by typing lspci 
hope u can help me and if u need more dates i'll be glad to give...

ragards,
ruggiero

-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 814 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071107/acf9d85a/attachment.html>

From mb at bu3sch.de  Wed Nov  7 18:31:10 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 7 Nov 2007 18:31:10 +0100
Subject: [PATCH] b43: fix shared IRQ race condition
In-Reply-To: <20071107181611.23de23f1@morte>
References: <20071107181611.23de23f1@morte>
Message-ID: <200711071831.10562.mb@bu3sch.de>

On Wednesday 07 November 2007 18:16:11 Stefano Brivio wrote:
> Fix an IRQ race condition in b43. If we call b43_stop_wireless_core(), it
> will set the status of the device to INITIALIZED and the IRQ handler won't
> care any longer about IRQs, thus the kernel will disable the IRQ if it's
> shared (unless we boot it with the 'irqpoll' option). So we must disable
> IRQs before changing the device status.
> 
> 
> Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
> 
> ---
> 
> --- wireless-2.6/drivers/net/wireless/b43/main.c.orig	2007-11-07 17:55:30.553591943 +0100
> +++ wireless-2.6/drivers/net/wireless/b43/main.c	2007-11-07 17:59:23.356020048 +0100
> @@ -2979,6 +2979,16 @@
>  
>  	if (b43_status(dev) < B43_STAT_STARTED)
>  		return;
> +
> +	/* Disable and sync interrupts. We must do this before than
> +	 * setting the status to INITIALIZED, as the interrupt handler
> +	 * won't care about IRQs then. */
> +	spin_lock_irqsave(&wl->irq_lock, flags);
> +	dev->irq_savedstate = b43_interrupt_disable(dev, B43_IRQ_ALL);
> +	b43_read32(dev, B43_MMIO_GEN_IRQ_MASK);	/* flush */
> +	spin_unlock_irqrestore(&wl->irq_lock, flags);
> +	b43_synchronize_irq(dev);
> +
>  	b43_set_status(dev, B43_STAT_INITIALIZED);
>  
>  	mutex_unlock(&wl->mutex);
> @@ -2989,13 +2999,6 @@
>  
>  	ieee80211_stop_queues(wl->hw);	//FIXME this could cause a deadlock, as mac80211 seems buggy.
>  
> -	/* Disable and sync interrupts. */
> -	spin_lock_irqsave(&wl->irq_lock, flags);
> -	dev->irq_savedstate = b43_interrupt_disable(dev, B43_IRQ_ALL);
> -	b43_read32(dev, B43_MMIO_GEN_IRQ_MASK);	/* flush */
> -	spin_unlock_irqrestore(&wl->irq_lock, flags);
> -	b43_synchronize_irq(dev);
> -
>  	b43_mac_suspend(dev);
>  	free_irq(dev->dev->irq, dev);
>  	b43dbg(wl, "Wireless interface stopped\n");
> 
> 

Acked-by: Michael Buesch <mb at bu3sch.de>

-- 
Greetings Michael.


From stefano.brivio at polimi.it  Wed Nov  7 18:33:37 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Wed, 7 Nov 2007 18:33:37 +0100
Subject: [PATCH] b43legacy: fix shared IRQ race condition
Message-ID: <20071107183337.4a77dbd4@morte>

Fix an IRQ race condition in b43legacy. If we call
b43legacy_wireless_core_stop(), it will set the status of the device to
INITIALIZED and the IRQ handler won't care any longer about IRQs, thus the
kernel will disable the IRQ if it's shared (unless we boot it with the
'irqpoll' option). So we must disable IRQs before changing the device
status.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

--- wireless-2.6/drivers/net/wireless/b43legacy/main.c.orig	2007-11-07 18:27:54.710703615 +0100
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c	2007-11-07 18:29:37.731201996 +0100
@@ -2682,6 +2682,17 @@
 
 	if (b43legacy_status(dev) < B43legacy_STAT_STARTED)
 		return;
+
+	/* Disable and sync interrupts. We must do this before than
+	 * setting the status to INITIALIZED, as the interrupt handler
+	 * won't care about IRQs then. */
+	spin_lock_irqsave(&wl->irq_lock, flags);
+	dev->irq_savedstate = b43legacy_interrupt_disable(dev,
+							  B43legacy_IRQ_ALL);
+	b43legacy_read32(dev, B43legacy_MMIO_GEN_IRQ_MASK); /* flush */
+	spin_unlock_irqrestore(&wl->irq_lock, flags);
+	b43legacy_synchronize_irq(dev);
+
 	b43legacy_set_status(dev, B43legacy_STAT_INITIALIZED);
 
 	mutex_unlock(&wl->mutex);
@@ -2692,14 +2703,6 @@
 
 	ieee80211_stop_queues(wl->hw); /* FIXME this could cause a deadlock */
 
-	/* Disable and sync interrupts. */
-	spin_lock_irqsave(&wl->irq_lock, flags);
-	dev->irq_savedstate = b43legacy_interrupt_disable(dev,
-							  B43legacy_IRQ_ALL);
-	b43legacy_read32(dev, B43legacy_MMIO_GEN_IRQ_MASK); /* flush */
-	spin_unlock_irqrestore(&wl->irq_lock, flags);
-	b43legacy_synchronize_irq(dev);
-
 	b43legacy_mac_suspend(dev);
 	free_irq(dev->dev->irq, dev);
 	b43legacydbg(wl, "Wireless interface stopped\n");


-- 
Ciao
Stefano


From larry.finger at lwfinger.net  Wed Nov  7 19:04:54 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 07 Nov 2007 12:04:54 -0600
Subject: BCM94311MCG
In-Reply-To: <001e01c82162$864cc970$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
Message-ID: <4731FE46.1060403@lwfinger.net>

Ruggiero wrote:
> i don't know if it's this the place to write about this problem...but if
> u say me where i should post the problem i'll do...here it comes...
> i have installed ubuntu 7.10 and i recompiled the kernel with to
> 2.6.23.1 because on the earlier kernel my wireless card didn't work with
> bcm43xx drivers but only with ndiswrapper..(i could see the access point
> but couldn't connect to it)
> now after recompiled i installed bcm43xx-fwcutter and by this i
> extracted the firmware using wl_apsta-3.130.20.0.o .. now as for the
> earlier kernel i can see the access point by typing "sudo iwlist scan"
> but i can't connect to it..sometime i can but only if i'm near to the
> access point(two meters) but anyway speed is really slow :(
>  
> the card BCM94311MCG rev01 this is what comes out by typing lspci
> hope u can help me and if u need more dates i'll be glad to give...

What is the output from a 'dmesg | grep bcm' command? In addition, please send the output of 'iwlist
scan'.

Larry


From mb at bu3sch.de  Wed Nov  7 19:03:35 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 7 Nov 2007 19:03:35 +0100
Subject: [PATCH] ssb: Fix PCMCIA-host lowlevel bus access
Message-ID: <200711071903.35469.mb@bu3sch.de>

This fixes the lowlevel bus access routines for
PCMCIA based devices.

There are still a few issues with register access sideeffects after
this patch. This will be addressed in a later patch.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-2.6/drivers/ssb/pcmcia.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/pcmcia.c	2007-11-06 18:19:27.000000000 +0100
+++ wireless-2.6/drivers/ssb/pcmcia.c	2007-11-07 15:48:37.000000000 +0100
@@ -63,17 +63,17 @@ int ssb_pcmcia_switch_coreidx(struct ssb
 		err = pcmcia_access_configuration_register(pdev, &reg);
 		if (err != CS_SUCCESS)
 			goto error;
-		read_addr |= (reg.Value & 0xF) << 12;
+		read_addr |= ((u32)(reg.Value & 0x0F)) << 12;
 		reg.Offset = 0x30;
 		err = pcmcia_access_configuration_register(pdev, &reg);
 		if (err != CS_SUCCESS)
 			goto error;
-		read_addr |= reg.Value << 16;
+		read_addr |= ((u32)reg.Value) << 16;
 		reg.Offset = 0x32;
 		err = pcmcia_access_configuration_register(pdev, &reg);
 		if (err != CS_SUCCESS)
 			goto error;
-		read_addr |= reg.Value << 24;
+		read_addr |= ((u32)reg.Value) << 24;
 
 		cur_core = (read_addr - SSB_ENUM_BASE) / SSB_CORE_SIZE;
 		if (cur_core == coreidx)
@@ -152,28 +152,29 @@ error:
 	goto out_unlock;
 }
 
-/* These are the main device register access functions.
- * do_select_core is inline to have the likely hotpath inline.
- * All unlikely codepaths are out-of-line. */
-static inline int do_select_core(struct ssb_bus *bus,
-				 struct ssb_device *dev,
-				 u16 *offset)
+static int select_core_and_segment(struct ssb_device *dev,
+				   u16 *offset)
 {
+	struct ssb_bus *bus = dev->bus;
 	int err;
-	u8 need_seg = (*offset >= 0x800) ? 1 : 0;
+	u8 need_segment;
+
+	if (*offset >= 0x800) {
+		*offset -= 0x800;
+		need_segment = 1;
+	} else
+		need_segment = 0;
 
 	if (unlikely(dev != bus->mapped_device)) {
 		err = ssb_pcmcia_switch_core(bus, dev);
 		if (unlikely(err))
 			return err;
 	}
-	if (unlikely(need_seg != bus->mapped_pcmcia_seg)) {
-		err = ssb_pcmcia_switch_segment(bus, need_seg);
+	if (unlikely(need_segment != bus->mapped_pcmcia_seg)) {
+		err = ssb_pcmcia_switch_segment(bus, need_segment);
 		if (unlikely(err))
 			return err;
 	}
-	if (need_seg == 1)
-		*offset -= 0x800;
 
 	return 0;
 }
@@ -181,32 +182,31 @@ static inline int do_select_core(struct 
 static u16 ssb_pcmcia_read16(struct ssb_device *dev, u16 offset)
 {
 	struct ssb_bus *bus = dev->bus;
-	u16 x;
 
-	if (unlikely(do_select_core(bus, dev, &offset)))
+	if (unlikely(select_core_and_segment(dev, &offset)))
 		return 0xFFFF;
-	x = readw(bus->mmio + offset);
 
-	return x;
+	return readw(bus->mmio + offset);
 }
 
 static u32 ssb_pcmcia_read32(struct ssb_device *dev, u16 offset)
 {
 	struct ssb_bus *bus = dev->bus;
-	u32 x;
+	u32 lo, hi;
 
-	if (unlikely(do_select_core(bus, dev, &offset)))
+	if (unlikely(select_core_and_segment(dev, &offset)))
 		return 0xFFFFFFFF;
-	x = readl(bus->mmio + offset);
+	lo = readw(bus->mmio + offset);
+	hi = readw(bus->mmio + offset + 2);
 
-	return x;
+	return (lo | (hi << 16));
 }
 
 static void ssb_pcmcia_write16(struct ssb_device *dev, u16 offset, u16 value)
 {
 	struct ssb_bus *bus = dev->bus;
 
-	if (unlikely(do_select_core(bus, dev, &offset)))
+	if (unlikely(select_core_and_segment(dev, &offset)))
 		return;
 	writew(value, bus->mmio + offset);
 }
@@ -215,12 +215,12 @@ static void ssb_pcmcia_write32(struct ss
 {
 	struct ssb_bus *bus = dev->bus;
 
-	if (unlikely(do_select_core(bus, dev, &offset)))
+	if (unlikely(select_core_and_segment(dev, &offset)))
 		return;
-	readw(bus->mmio + offset);
-	writew(value >> 16, bus->mmio + offset + 2);
-	readw(bus->mmio + offset);
-	writew(value, bus->mmio + offset);
+	writeb((value & 0xFF000000) >> 24, bus->mmio + offset + 3);
+	writeb((value & 0x00FF0000) >> 16, bus->mmio + offset + 2);
+	writeb((value & 0x0000FF00) >> 8, bus->mmio + offset + 1);
+	writeb((value & 0x000000FF) >> 0, bus->mmio + offset + 0);
 }
 
 /* Not "static", as it's used in main.c */
Index: wireless-2.6/drivers/ssb/main.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/main.c	2007-11-06 17:34:27.000000000 +0100
+++ wireless-2.6/drivers/ssb/main.c	2007-11-07 15:54:53.000000000 +0100
@@ -440,6 +440,7 @@ static int ssb_devices_register(struct s
 			break;
 		case SSB_BUSTYPE_PCMCIA:
 #ifdef CONFIG_SSB_PCMCIAHOST
+			sdev->irq = bus->host_pcmcia->irq.AssignedIRQ;
 			dev->parent = &bus->host_pcmcia->dev;
 #endif
 			break;


From mb at bu3sch.de  Wed Nov  7 19:08:26 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 7 Nov 2007 19:08:26 +0100
Subject: [PATCH] b43: properly request pcmcia IRQ
Message-ID: <200711071908.26195.mb@bu3sch.de>

PCMCIA needs an additional step to request the IRQ.

No need to add code to release the IRQ here, as that's done
automatically in pcmcia_disable_device().

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-2.6/drivers/net/wireless/b43/pcmcia.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/pcmcia.c	2007-11-07 15:54:21.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/pcmcia.c	2007-11-07 18:45:08.000000000 +0100
@@ -112,6 +112,14 @@ static int __devinit b43_pcmcia_probe(st
 	if (res != CS_SUCCESS)
 		goto err_disable;
 
+	dev->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING | IRQ_FIRST_SHARED;
+	dev->irq.IRQInfo1 = IRQ_LEVEL_ID | IRQ_SHARE_ID;
+	dev->irq.Handler = NULL; /* The handler is registered later. */
+	dev->irq.Instance = NULL;
+	res = pcmcia_request_irq(dev, &dev->irq);
+	if (res != CS_SUCCESS)
+		goto err_disable;
+
 	res = pcmcia_request_configuration(dev, &dev->conf);
 	if (res != CS_SUCCESS)
 		goto err_disable;


From Larry.Finger at lwfinger.net  Wed Nov  7 19:20:09 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 07 Nov 2007 12:20:09 -0600
Subject: Meaning of ssb SPROM variables
Message-ID: <473201D9.6070603@lwfinger.net>

I am working at matching the variables in the ssb Revision 4 SPROMS with those from earlier
revisions and are used by the drivers. I have gotten all of them except those with names in the
series paXbY, where X is 0 for a G PHY and 1 for an A PHY, and Y is the "loop position".

Does anyone know anything more about these variables that would help me match them to the r4 sprom?

Thanks,

Larry



From mb at bu3sch.de  Wed Nov  7 19:27:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 7 Nov 2007 19:27:48 +0100
Subject: Meaning of ssb SPROM variables
In-Reply-To: <473201D9.6070603@lwfinger.net>
References: <473201D9.6070603@lwfinger.net>
Message-ID: <200711071927.48831.mb@bu3sch.de>

On Wednesday 07 November 2007 19:20:09 Larry Finger wrote:
> I am working at matching the variables in the ssb Revision 4 SPROMS with those from earlier
> revisions and are used by the drivers. I have gotten all of them except those with names in the
> series paXbY, where X is 0 for a G PHY and 1 for an A PHY, and Y is the "loop position".
> 
> Does anyone know anything more about these variables that would help me match them to the r4 sprom?

These are Power Amplifier (pa) calibration values.
It's related to TX power and the TSSI values.

-- 
Greetings Michael.


From rugg.argos at tiscali.it  Wed Nov  7 20:55:34 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Wed, 7 Nov 2007 20:55:34 +0100
Subject: BCM94311MCG
Message-ID: <001201c82178$2a77b720$0601a8c0@ruggiero>

> What is the output from a 'dmesg | grep bcm' command? In addition, please send the output of 'iwlist
> scan'.
> 
> Larry

here it's the output of what u requested

ruggiero at ruggiero-laptop:~$ sudo iwlist scan
lo        Interface doesn't support scanning.

eth0      Interface doesn't support scanning.

eth1      Scan completed :
          Cell 01 - Address: 00:0C:41:19:2D:C1
                    ESSID:"<hidden>"
                    Protocol:IEEE 802.11b
                    Mode:Master
                    Frequency:2.462 GHz (Channel 11)
                    Encryption key:on
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
                    Quality=98/100  Signal level=-42 dBm  Noise level=-256 dBm
                    Extra: Last beacon: 717ms ago

ruggiero at ruggiero-laptop:~$ dmesg|grep bcm
[   28.759141] bcm43xx driver

this is the network card:
05:00.0 Network controller: Broadcom Corporation BCM94311MCG wlan mini-PCI (rev 01)


and this is what happen when i ping my router (in the case that it connects to me when i'm really near,but not always happen) and i get far away from the router of some meters:

PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data
64 bytes from 192.168.1.1: icmp_seq=1 ttl=150 time=2.49 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=3 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=4 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=5 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=6 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=7 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=8 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=9 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=10 ttl=150 time=5.69 ms
64 bytes from 192.168.1.1: icmp_seq=11 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=12 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=13 ttl=150 time=2.37 ms
64 bytes from 192.168.1.1: icmp_seq=14 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=15 ttl=150 time=2.39 ms
64 bytes from 192.168.1.1: icmp_seq=16 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=17 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=18 ttl=150 time=25.2 ms
64 bytes from 192.168.1.1: icmp_seq=19 ttl=150 time=4.94 ms
64 bytes from 192.168.1.1: icmp_seq=20 ttl=150 time=4.07 ms
64 bytes from 192.168.1.1: icmp_seq=21 ttl=150 time=2.47 ms
64 bytes from 192.168.1.1: icmp_seq=22 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=23 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=24 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=25 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=26 ttl=150 time=2.37 ms
64 bytes from 192.168.1.1: icmp_seq=27 ttl=150 time=2.40 ms
64 bytes from 192.168.1.1: icmp_seq=28 ttl=150 time=15.3 ms
64 bytes from 192.168.1.1: icmp_seq=29 ttl=150 time=2.71 ms
64 bytes from 192.168.1.1: icmp_seq=30 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=31 ttl=150 time=654 ms
64 bytes from 192.168.1.1: icmp_seq=32 ttl=150 time=9.89 ms
64 bytes from 192.168.1.1: icmp_seq=33 ttl=150 time=70.7 ms
64 bytes from 192.168.1.1: icmp_seq=34 ttl=150 time=565 ms
64 bytes from 192.168.1.1: icmp_seq=35 ttl=150 time=6.12 ms
64 bytes from 192.168.1.1: icmp_seq=36 ttl=150 time=75.9 ms
64 bytes from 192.168.1.1: icmp_seq=37 ttl=150 time=340 ms
64 bytes from 192.168.1.1: icmp_seq=38 ttl=150 time=937 ms
64 bytes from 192.168.1.1: icmp_seq=40 ttl=150 time=115 ms
64 bytes from 192.168.1.1: icmp_seq=44 ttl=150 time=193 ms
64 bytes from 192.168.1.1: icmp_seq=45 ttl=150 time=266 ms
64 bytes from 192.168.1.1: icmp_seq=50 ttl=150 time=1165 ms
64 bytes from 192.168.1.1: icmp_seq=54 ttl=150 time=40.8 ms

From rugg.argos at tiscali.it  Wed Nov  7 21:07:41 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Wed, 7 Nov 2007 21:07:41 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
Message-ID: <003701c82179$da3f4c80$0601a8c0@ruggiero>

here it's the output of what u requested

ruggiero at ruggiero-laptop:~$ sudo iwlist scan
lo        Interface doesn't support scanning.

eth0      Interface doesn't support scanning.

eth1      Scan completed :
          Cell 01 - Address: 00:0C:41:19:2D:C1
                    ESSID:"<hidden>"
                    Protocol:IEEE 802.11b
                    Mode:Master
                    Frequency:2.462 GHz (Channel 11)
                    Encryption key:on
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
                    Quality=98/100  Signal level=-42 dBm  Noise level=-256 
dBm
                    Extra: Last beacon: 717ms ago

ruggiero at ruggiero-laptop:~$ dmesg|grep bcm
[   28.759141] bcm43xx driver

this is the network card:
05:00.0 Network controller: Broadcom Corporation BCM94311MCG wlan mini-PCI 
(rev 01)


and this is what happen when i ping my router (in the case that it connects 
to me when i'm really near,but not always happen) and i get far away from 
the router of some meters:

PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data
64 bytes from 192.168.1.1: icmp_seq=1 ttl=150 time=2.49 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=3 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=4 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=5 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=6 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=7 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=8 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=9 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=10 ttl=150 time=5.69 ms
64 bytes from 192.168.1.1: icmp_seq=11 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=12 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=13 ttl=150 time=2.37 ms
64 bytes from 192.168.1.1: icmp_seq=14 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=15 ttl=150 time=2.39 ms
64 bytes from 192.168.1.1: icmp_seq=16 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=17 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=18 ttl=150 time=25.2 ms
64 bytes from 192.168.1.1: icmp_seq=19 ttl=150 time=4.94 ms
64 bytes from 192.168.1.1: icmp_seq=20 ttl=150 time=4.07 ms
64 bytes from 192.168.1.1: icmp_seq=21 ttl=150 time=2.47 ms
64 bytes from 192.168.1.1: icmp_seq=22 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=23 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=24 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=25 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=26 ttl=150 time=2.37 ms
64 bytes from 192.168.1.1: icmp_seq=27 ttl=150 time=2.40 ms
64 bytes from 192.168.1.1: icmp_seq=28 ttl=150 time=15.3 ms
64 bytes from 192.168.1.1: icmp_seq=29 ttl=150 time=2.71 ms
64 bytes from 192.168.1.1: icmp_seq=30 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=31 ttl=150 time=654 ms
64 bytes from 192.168.1.1: icmp_seq=32 ttl=150 time=9.89 ms
64 bytes from 192.168.1.1: icmp_seq=33 ttl=150 time=70.7 ms
64 bytes from 192.168.1.1: icmp_seq=34 ttl=150 time=565 ms
64 bytes from 192.168.1.1: icmp_seq=35 ttl=150 time=6.12 ms
64 bytes from 192.168.1.1: icmp_seq=36 ttl=150 time=75.9 ms
64 bytes from 192.168.1.1: icmp_seq=37 ttl=150 time=340 ms
64 bytes from 192.168.1.1: icmp_seq=38 ttl=150 time=937 ms
64 bytes from 192.168.1.1: icmp_seq=40 ttl=150 time=115 ms
64 bytes from 192.168.1.1: icmp_seq=44 ttl=150 time=193 ms
64 bytes from 192.168.1.1: icmp_seq=45 ttl=150 time=266 ms
64 bytes from 192.168.1.1: icmp_seq=50 ttl=150 time=1165 ms
64 bytes from 192.168.1.1: icmp_seq=54 ttl=150 time=40.8 ms

From rugg.argos at tiscali.it  Wed Nov  7 21:02:38 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Wed, 7 Nov 2007 21:02:38 +0100
Subject: BCM94311MCG
Message-ID: <002901c82179$25cdc1a0$0601a8c0@ruggiero>

> What is the output from a 'dmesg | grep bcm' command? In addition, please send the output of 'iwlist
> scan'.
> 
> Larry

here it's the output of what u requested

ruggiero at ruggiero-laptop:~$ sudo iwlist scan
lo        Interface doesn't support scanning.

eth0      Interface doesn't support scanning.

eth1      Scan completed :
          Cell 01 - Address: 00:0C:41:19:2D:C1
                    ESSID:"<hidden>"
                    Protocol:IEEE 802.11b
                    Mode:Master
                    Frequency:2.462 GHz (Channel 11)
                    Encryption key:on
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
                    Quality=98/100  Signal level=-42 dBm  Noise level=-256 dBm
                    Extra: Last beacon: 717ms ago

ruggiero at ruggiero-laptop:~$ dmesg|grep bcm
[   28.759141] bcm43xx driver

this is the network card:
05:00.0 Network controller: Broadcom Corporation BCM94311MCG wlan mini-PCI (rev 01)


and this is what happen when i ping my router (in the case that it connects to me when i'm really near,but not always happen) and i get far away from the router of some meters:

PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data
64 bytes from 192.168.1.1: icmp_seq=1 ttl=150 time=2.49 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=3 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=4 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=5 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=6 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=7 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=8 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=9 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=10 ttl=150 time=5.69 ms
64 bytes from 192.168.1.1: icmp_seq=11 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=12 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=13 ttl=150 time=2.37 ms
64 bytes from 192.168.1.1: icmp_seq=14 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=15 ttl=150 time=2.39 ms
64 bytes from 192.168.1.1: icmp_seq=16 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=17 ttl=150 time=2.36 ms
64 bytes from 192.168.1.1: icmp_seq=18 ttl=150 time=25.2 ms
64 bytes from 192.168.1.1: icmp_seq=19 ttl=150 time=4.94 ms
64 bytes from 192.168.1.1: icmp_seq=20 ttl=150 time=4.07 ms
64 bytes from 192.168.1.1: icmp_seq=21 ttl=150 time=2.47 ms
64 bytes from 192.168.1.1: icmp_seq=22 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=23 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=24 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=25 ttl=150 time=2.35 ms
64 bytes from 192.168.1.1: icmp_seq=26 ttl=150 time=2.37 ms
64 bytes from 192.168.1.1: icmp_seq=27 ttl=150 time=2.40 ms
64 bytes from 192.168.1.1: icmp_seq=28 ttl=150 time=15.3 ms
64 bytes from 192.168.1.1: icmp_seq=29 ttl=150 time=2.71 ms
64 bytes from 192.168.1.1: icmp_seq=30 ttl=150 time=2.38 ms
64 bytes from 192.168.1.1: icmp_seq=31 ttl=150 time=654 ms
64 bytes from 192.168.1.1: icmp_seq=32 ttl=150 time=9.89 ms
64 bytes from 192.168.1.1: icmp_seq=33 ttl=150 time=70.7 ms
64 bytes from 192.168.1.1: icmp_seq=34 ttl=150 time=565 ms
64 bytes from 192.168.1.1: icmp_seq=35 ttl=150 time=6.12 ms
64 bytes from 192.168.1.1: icmp_seq=36 ttl=150 time=75.9 ms
64 bytes from 192.168.1.1: icmp_seq=37 ttl=150 time=340 ms
64 bytes from 192.168.1.1: icmp_seq=38 ttl=150 time=937 ms
64 bytes from 192.168.1.1: icmp_seq=40 ttl=150 time=115 ms
64 bytes from 192.168.1.1: icmp_seq=44 ttl=150 time=193 ms
64 bytes from 192.168.1.1: icmp_seq=45 ttl=150 time=266 ms
64 bytes from 192.168.1.1: icmp_seq=50 ttl=150 time=1165 ms
64 bytes from 192.168.1.1: icmp_seq=54 ttl=150 time=40.8 ms

From mb at bu3sch.de  Wed Nov  7 21:21:55 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 7 Nov 2007 21:21:55 +0100
Subject: [PATCH] b43legacy: Fix sparse warning
Message-ID: <200711072121.55828.mb@bu3sch.de>

Fix a sparse warning about a nonstatic function.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Note that this patch might collide with Stefano's recently
sent patches. But it should be trivial enough to fix that.

Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c	2007-11-07 20:31:06.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c	2007-11-07 20:47:36.000000000 +0100
@@ -3238,7 +3238,7 @@ out_mutex_unlock:
 	return err;
 }
 
-void b43legacy_stop(struct ieee80211_hw *hw)
+static void b43legacy_stop(struct ieee80211_hw *hw)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev = wl->current_dev;


From mb at bu3sch.de  Wed Nov  7 21:24:07 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 7 Nov 2007 21:24:07 +0100
Subject: [PATCH] b43: Fix kconfig dependencies for rfkill and leds
Message-ID: <200711072124.07308.mb@bu3sch.de>

Fix dependencies for built-in b43.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

I thought that I already submitted this patch, but it's not in wireless-2.6.
Maybe it was lost somewhere inbetween us or I simply forgot to send it.

Stefano, can you check if this patch is already applied to b43legacy?

Index: wireless-2.6/drivers/net/wireless/b43/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/Kconfig	2007-10-27 13:28:16.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/Kconfig	2007-10-27 14:29:28.000000000 +0200
@@ -61,16 +61,18 @@ config B43_PCMCIA
 
 	  If unsure, say N.
 
-# LED support
+# This config option automatically enables b43 LEDS support,
+# if it's possible.
 config B43_LEDS
 	bool
-	depends on B43 && MAC80211_LEDS
+	depends on B43 && MAC80211_LEDS && (LEDS_CLASS = y || LEDS_CLASS = B43)
 	default y
 
-# RFKILL support
+# This config option automatically enables b43 RFKILL support,
+# if it's possible.
 config B43_RFKILL
 	bool
-	depends on B43 && RFKILL && RFKILL_INPUT && INPUT_POLLDEV
+	depends on B43 && (RFKILL = y || RFKILL = B43) && RFKILL_INPUT && (INPUT_POLLDEV = y || INPUT_POLLDEV = B43)
 	default y
 
 config B43_DEBUG


From gene.heskett at verizon.net  Thu Nov  8 00:12:53 2007
From: gene.heskett at verizon.net (Gene Heskett)
Date: Wed, 07 Nov 2007 18:12:53 -0500
Subject: b43, b43legacy questions
Message-ID: <200711071812.53305.gene.heskett@verizon.net>

How do I tell which of these drivers to use with the 2.6.23.1-21.fc7 fedora 
kernel.

I've removed the alias's from /etc/modprobe.conf that said wlan0 was 
ndiswrapper, and NM enables the radio but cannot connect.

After a reboot with no aliases set its b43, mac80211, rc80211_simple and ssb 
that show in an lsmod|grep b43.

NM and the dispatcher are enabled.

Its an HP lappy, and lspci says its a "Broadcom Corporation BCM4318 [AirForce 
One 54G] 802-11g Wireless LAN Controller (rev 02)

Whats next?

-- 
Cheers, Gene
"There are four boxes to be used in defense of liberty:
 soap, ballot, jury, and ammo. Please use in that order."
-Ed Howdershelt (Author)
Everything you know is wrong!


From stefano.brivio at polimi.it  Thu Nov  8 00:28:00 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Thu, 8 Nov 2007 00:28:00 +0100
Subject: [PATCH] b43legacy: fix kconfig dependecies for rfkill and leds
Message-ID: <20071108002800.3d73dced@morte>

Fix dependencies for built-in b43legacy.

The patch to b43 by Michael Buesch <mb at bu3sch.de> has been ported to
b43legacy.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

Index: wireless-2.6/drivers/net/wireless/b43legacy/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/Kconfig
+++ wireless-2.6/drivers/net/wireless/b43legacy/Kconfig
@@ -35,15 +35,19 @@ config B43LEGACY_PCICORE_AUTOSELECT
 	default y
 
 # LED support
+# This config option automatically enables b43legacy LEDS support,
+# if it's possible.
 config B43LEGACY_LEDS
 	bool
-	depends on B43LEGACY && MAC80211_LEDS
+	depends on B43LEGACY && MAC80211_LEDS && (LEDS_CLASS = y || LEDS_CLASS = B43LEGACY)
 	default y
 
 # RFKILL support
+# This config option automatically enables b43legacy RFKILL support,
+# if it's possible.
 config B43LEGACY_RFKILL
 	bool
-	depends on B43LEGACY && RFKILL && RFKILL_INPUT && INPUT_POLLDEV
+	depends on B43LEGACY && (RFKILL = y || RFKILL = B43LEGACY) && RFKILL_INPUT && (INPUT_POLLDEV = y || INPUT_POLLDEV = B43LEGACY)
 	default y
 
 config B43LEGACY_DEBUG



-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Thu Nov  8 00:28:55 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Thu, 8 Nov 2007 00:28:55 +0100
Subject: [PATCH] b43: Fix kconfig dependencies for rfkill and leds
In-Reply-To: <200711072124.07308.mb@bu3sch.de>
References: <200711072124.07308.mb@bu3sch.de>
Message-ID: <20071108002855.719f5e43@morte>

On Wed, 7 Nov 2007 21:24:07 +0100
Michael Buesch <mb at bu3sch.de> wrote:

> Stefano, can you check if this patch is already applied to b43legacy?

It wasn't, I just sent it. Thank you.


-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Thu Nov  8 00:29:46 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Thu, 8 Nov 2007 00:29:46 +0100
Subject: [PATCH] b43legacy: Fix sparse warning
In-Reply-To: <200711072121.55828.mb@bu3sch.de>
References: <200711072121.55828.mb@bu3sch.de>
Message-ID: <20071108002946.2fa90b5d@morte>

On Wed, 7 Nov 2007 21:21:55 +0100
Michael Buesch <mb at bu3sch.de> wrote:

> Fix a sparse warning about a nonstatic function.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

Acked-by: Stefano Brivio <stefano.brivio at polimi.it>


-- 
Ciao
Stefano


From gavron at Wetwork.Net  Thu Nov  8 01:29:12 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Wed, 07 Nov 2007 17:29:12 -0700
Subject: b43, b43legacy questions
In-Reply-To: <200711071812.53305.gene.heskett@verizon.net>
References: <200711071812.53305.gene.heskett@verizon.net>
Message-ID: <47325858.3040500@Wetwork.Net>

dmesg | grep b43

The version with F7 wants the v4 microcode files with the *old* names 
(bcm43xx_*) instead of the new ones.

dmesg will have the clues.

Ehud

Gene Heskett wrote:
> How do I tell which of these drivers to use with the 2.6.23.1-21.fc7 fedora 
> kernel.
>
> I've removed the alias's from /etc/modprobe.conf that said wlan0 was 
> ndiswrapper, and NM enables the radio but cannot connect.
>
> After a reboot with no aliases set its b43, mac80211, rc80211_simple and ssb 
> that show in an lsmod|grep b43.
>
> NM and the dispatcher are enabled.
>
> Its an HP lappy, and lspci says its a "Broadcom Corporation BCM4318 [AirForce 
> One 54G] 802-11g Wireless LAN Controller (rev 02)
>
> Whats next?
>
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071107/f31911ef/attachment.bin>

From linville at tuxdriver.com  Thu Nov  8 02:39:56 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 7 Nov 2007 20:39:56 -0500
Subject: b43, b43legacy questions
In-Reply-To: <47325858.3040500@Wetwork.Net>
References: <200711071812.53305.gene.heskett@verizon.net>
	<47325858.3040500@Wetwork.Net>
Message-ID: <20071108013956.GC11957@tuxdriver.com>

On Wed, Nov 07, 2007 at 05:29:12PM -0700, Ehud Gavron wrote:
> dmesg | grep b43
> 
> The version with F7 wants the v4 microcode files with the *old* names 
> (bcm43xx_*) instead of the new ones.

Just to clarify, all this means is that for F7 you should continue
to use "bcm43xx-fwcutter" instead of "b43-fwcutter".

Gene, FWIW if b43 is getting loaded then that is almost certainly the
right driver.  The one in F7 is a bit behind, so if it isn't working
you might want to try an F8 kernel.  I think you should be able to
run an F8 kernel on F7 w/o any trouble.  Hopefully that will drive
your 4318 -- it works for both of mine.

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Thu Nov  8 05:55:41 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 07 Nov 2007 22:55:41 -0600
Subject: bcm43xx + Kismet = signal and noise zero
In-Reply-To: <47327F79.7070404@bellsouth.net>
References: <47327F79.7070404@bellsouth.net>
Message-ID: <473296CD.1080309@lwfinger.net>

DeckerXL wrote:
> I'm using a bcm43xx wireless adapter in Linux and running Kismet in
> Backtrack2 (BackTrack 2 Stable release Mar 06 2007)
> Works fine except that I'm not getting signal strength & noise values
> from the wifi adapter in Kismet.  Do you know why?
> 
> The specific wifi cardbus card I'm using is:
> Buffalo WLI-PCI-G54 4306
> 
> In Kismet, I get the value 0 (zero) for Signal Strength (Sgn) and
> Noise (Nse) columns.  Do you know why?
> 
> I also did the firmware upgrade as listed on your support page for
> bcm43xx: with no effect.
> For bcm43xx: 'sudo bcm43xx-fwcutter -w /lib/firmware
> wl_apsta-3.130.20.0.o'

What kernel does Backtrack2 run? Send the output of 'uname -r'.

There have been a lot of changes in bcm43xx over the past 9 months. I cannot say which of them might
have affected the Kismet results.

Larry


From larry.finger at lwfinger.net  Thu Nov  8 05:57:52 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 07 Nov 2007 22:57:52 -0600
Subject: BCM94311MCG
In-Reply-To: <003701c82179$da3f4c80$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
Message-ID: <47329750.7080505@lwfinger.net>

Ruggiero wrote:
> here it's the output of what u requested
> 
> ruggiero at ruggiero-laptop:~$ sudo iwlist scan
> lo        Interface doesn't support scanning.
> 
> eth0      Interface doesn't support scanning.
> 
> eth1      Scan completed :
>           Cell 01 - Address: 00:0C:41:19:2D:C1
>                     ESSID:"<hidden>"
>                     Protocol:IEEE 802.11b
>                     Mode:Master
>                     Frequency:2.462 GHz (Channel 11)
>                     Encryption key:on
>                     Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
>                     Quality=98/100  Signal level=-42 dBm  Noise level=-256 
> dBm
>                     Extra: Last beacon: 717ms ago
> 
> ruggiero at ruggiero-laptop:~$ dmesg|grep bcm
> [   28.759141] bcm43xx driver

Since Ubuntu didn't turn debugging on, there isn't much we can do for you.

Larry



From rugg.argos at tiscali.it  Thu Nov  8 08:57:41 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Thu, 8 Nov 2007 08:57:41 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
Message-ID: <000601c821dd$09fc0720$0601a8c0@ruggiero>

could u suggest me any good distribution that i can use?
regards
ruggiero

----- Original Message ----- 
From: "Larry Finger" <larry.finger at lwfinger.net>
To: "Ruggiero" <rugg.argos at tiscali.it>
Cc: <bcm43xx-dev at lists.berlios.de>
Sent: Thursday, November 08, 2007 5:57 AM
Subject: Re: BCM94311MCG


> Ruggiero wrote:
>> here it's the output of what u requested
>>
>> ruggiero at ruggiero-laptop:~$ sudo iwlist scan
>> lo        Interface doesn't support scanning.
>>
>> eth0      Interface doesn't support scanning.
>>
>> eth1      Scan completed :
>>           Cell 01 - Address: 00:0C:41:19:2D:C1
>>                     ESSID:"<hidden>"
>>                     Protocol:IEEE 802.11b
>>                     Mode:Master
>>                     Frequency:2.462 GHz (Channel 11)
>>                     Encryption key:on
>>                     Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
>>                     Quality=98/100  Signal level=-42 dBm  Noise 
>> level=-256
>> dBm
>>                     Extra: Last beacon: 717ms ago
>>
>> ruggiero at ruggiero-laptop:~$ dmesg|grep bcm
>> [   28.759141] bcm43xx driver
>
> Since Ubuntu didn't turn debugging on, there isn't much we can do for you.
>
> Larry
> 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 818 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From larry.finger at lwfinger.net  Thu Nov  8 16:53:35 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 08 Nov 2007 09:53:35 -0600
Subject: BCM94311MCG
In-Reply-To: <000601c821dd$09fc0720$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
Message-ID: <473330FF.4090605@lwfinger.net>

Ruggiero wrote:
> could u suggest me any good distribution that i can use?
> regards
> ruggiero

Fedora 7 has the configuration set properly. There are likely others as well.

Larry



From Larry.Finger at lwfinger.net  Thu Nov  8 17:18:58 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 08 Nov 2007 10:18:58 -0600
Subject: Request for information
Message-ID: <473336F2.9090200@lwfinger.net>

In the various devices using the Sonics Silicon Backplane (ssb), we are aware of at least 4
different revisions of the SPROM, which stores information regarding that device such as MAC
address, etc. The specifications list the layouts of the various revisions. From everything we knew,
rev 2 inherited all the rev 1 data, and rev 3 inherited from rev 2. To my surprise, I found that
when I examined my first rev 3 device, the layout was not the same as my rev 2 device. The
differences are such that the current driver could never work with the new layout.

I need to know if this is really the first rev 3 SPROM that has been discovered, or if more than one
flavor of the beast exists. To provide the information, please run the following two commands:

SSB_SPROM=$(find /sys -name ssb_sprom)
sudo cat $SSB_SPROM

For these commands to work, you will need to be running a bash shell and using either
bcm43xx-mac80211 or b43 as your driver. The second command will result in a string of hexadecimal
digits that looks like:

0130000063133C100800BE0D00FFFFFF11430080020000000010001800000000
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFF
FFFFFFFFFFFFFFFF1A000473E51DFFFFFFFFFFFFFFFFFFFFFFFFFFFF39303D15
A0FA79FEFF83FFFF4AFFFFFFFFFFFFFF3EFF494A02FF53550CFFFFFFFFFF02C0

I have added line breaks for this E-mail - the real thing will be an unbroken string of characters.
If the 3rd and 4th characters from the end are "03" (mine has "02"), please send me the entire string.

Thanks,

Larry


From rugg.argos at tiscali.it  Thu Nov  8 17:36:12 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Thu, 8 Nov 2007 17:36:12 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
Message-ID: <000601c82225$7bc63220$0601a8c0@ruggiero>

i just installed fedora7 and the firmware 4 by bcm43xx_fwcutter,it's a bit 
different by ubuntu because i don't have the command iwconfig and iwlist 
scan,how can i verify the card is working properly?here there is some 
informations:
i have a b44ethernet card in the laptop

[ruggiero at localhost ~]$ dmesg|grep bcm
bcm43xx_mac80211: Broadcom 4311 WLAN found
bcm43xx_mac80211: Found PHY: Analog 4, Type 2, Revision 8
bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Adding Interface type 2
bcm43xx_mac80211: Loading firmware version 351.126 (2006-07-29 05:54:02)
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: !WARNING! Idle-TSSI phy->cur_idle_tssi measuring failed. 
(cur=5, tgt=62). Disabling TX power adjustment.
bcm43xx_mac80211: Chip initialized
bcm43xx_mac80211: 32-bit DMA initialized
bcm43xx_mac80211: Wireless interface started

thanks a lot for helping
ruggiero
----- Original Message ----- 
From: "Larry Finger" <larry.finger at lwfinger.net>
To: "Ruggiero" <rugg.argos at tiscali.it>
Cc: <bcm43xx-dev at lists.berlios.de>
Sent: Thursday, November 08, 2007 4:53 PM
Subject: Re: BCM94311MCG


> Ruggiero wrote:
>> could u suggest me any good distribution that i can use?
>> regards
>> ruggiero
>
> Fedora 7 has the configuration set properly. There are likely others as 
> well.
>
> Larry
> 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 819 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From gavron at Wetwork.Net  Thu Nov  8 17:48:13 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Thu, 08 Nov 2007 09:48:13 -0700
Subject: BCM94311MCG
In-Reply-To: <000601c82225$7bc63220$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
Message-ID: <47333DCD.5090304@Wetwork.Net>

$ su -

and don't forget to ifconfig the interface up (in addition to all the 
iwconfigs, MUST ifconfig it up)

Ehud

Ruggiero wrote:
> i just installed fedora7 and the firmware 4 by bcm43xx_fwcutter,it's a bit 
> different by ubuntu because i don't have the command iwconfig and iwlist 
> scan,how can i verify the card is working properly?here there is some 
> informations:
> i have a b44ethernet card in the laptop
>
> [ruggiero at localhost ~]$ dmesg|grep bcm
> bcm43xx_mac80211: Broadcom 4311 WLAN found
> bcm43xx_mac80211: Found PHY: Analog 4, Type 2, Revision 8
> bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> bcm43xx_mac80211: Radio turned off
> bcm43xx_mac80211: Adding Interface type 2
> bcm43xx_mac80211: Loading firmware version 351.126 (2006-07-29 05:54:02)
> bcm43xx_mac80211: Radio turned on
> bcm43xx_mac80211: Radio enabled by hardware
> bcm43xx_mac80211: !WARNING! Idle-TSSI phy->cur_idle_tssi measuring failed. 
> (cur=5, tgt=62). Disabling TX power adjustment.
> bcm43xx_mac80211: Chip initialized
> bcm43xx_mac80211: 32-bit DMA initialized
> bcm43xx_mac80211: Wireless interface started
>
> thanks a lot for helping
> ruggiero
> ----- Original Message ----- 
> From: "Larry Finger" <larry.finger at lwfinger.net>
> To: "Ruggiero" <rugg.argos at tiscali.it>
> Cc: <bcm43xx-dev at lists.berlios.de>
> Sent: Thursday, November 08, 2007 4:53 PM
> Subject: Re: BCM94311MCG
>
>
>   
>> Ruggiero wrote:
>>     
>>> could u suggest me any good distribution that i can use?
>>> regards
>>> ruggiero
>>>       
>> Fedora 7 has the configuration set properly. There are likely others as 
>> well.
>>
>> Larry
>>
>>     
>
>
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071108/7290f443/attachment.bin>

From larry.finger at lwfinger.net  Thu Nov  8 18:13:34 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 08 Nov 2007 11:13:34 -0600
Subject: BCM94311MCG
In-Reply-To: <000601c82225$7bc63220$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
Message-ID: <473343BE.4040208@lwfinger.net>

Ruggiero wrote:
> i just installed fedora7 and the firmware 4 by bcm43xx_fwcutter,it's a 
> bit different by ubuntu because i don't have the command iwconfig and 
> iwlist scan,how can i verify the card is working properly?here there is 
> some informations:
> i have a b44ethernet card in the laptop
> 
> [ruggiero at localhost ~]$ dmesg|grep bcm
> bcm43xx_mac80211: Broadcom 4311 WLAN found
> bcm43xx_mac80211: Found PHY: Analog 4, Type 2, Revision 8
> bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> bcm43xx_mac80211: Radio turned off
> bcm43xx_mac80211: Adding Interface type 2
> bcm43xx_mac80211: Loading firmware version 351.126 (2006-07-29 05:54:02)
> bcm43xx_mac80211: Radio turned on
> bcm43xx_mac80211: Radio enabled by hardware
> bcm43xx_mac80211: !WARNING! Idle-TSSI phy->cur_idle_tssi measuring 
> failed. (cur=5, tgt=62). Disabling TX power adjustment.
> bcm43xx_mac80211: Chip initialized
> bcm43xx_mac80211: 32-bit DMA initialized
> bcm43xx_mac80211: Wireless interface started
> 

I think the WEX commands are there, just not in your path. Try /sbin/iwconfig, etc.

Larry




From rugg.argos at tiscali.it  Thu Nov  8 18:03:49 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Thu, 8 Nov 2007 18:03:49 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<47333DCD.5090304@Wetwork.Net>
Message-ID: <000901c82229$97012fa0$0601a8c0@ruggiero>

thanks for informations,i followed your suggestions...but i think i'm 
missing something...here there are other informations:

[root at localhost ~]# ifconfig
eth0      Link encap:Ethernet  HWaddr 00:16:D4:DF:*:*
         UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:21

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:8602 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8602 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:69166424 (65.9 MiB)  TX bytes:69166424 (65.9 MiB)

wlan0     Link encap:Ethernet  HWaddr 00:19:7E:84:*:*
          inet addr:192.168.1.80  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)

wmaster0  Link encap:UNSPEC  HWaddr 
*19-7E-84-*D3-D8-98-00-00-00-00-00-00-00-00
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)


[root at localhost ~]# iwconfig
lo        no wireless extensions.

eth0      no wireless extensions.

wmaster0  no wireless extensions.

wlan0     IEEE 802.11g  ESSID:"*****
        Mode:Managed  Frequency:2.412 GHz  Access Point: Not-Associated
          Retry min limit:7   RTS thr:off   Fragment thr=2346 B
          Encryption key:******************************************
         Link Quality:0  Signal level:0  Noise level:0
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

[root at localhost ~]# iwlist scan
lo        Interface doesn't support scanning.

eth0      Interface doesn't support scanning.

wmaster0  Interface doesn't support scanning.

wlan0     Scan completed :
          Cell 01 - Address: *0C:41:19:2D:*
                   ESSID:""
                    Mode:Master
                    Channel:11
                    Frequency:2.462 GHz
                    Quality=204/146  Signal level=-206 dBm  Noise level=-67 
dBm
                    Encryption key:on
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
                    Extra:tsf=0000000012e26229

thanks again for helping 



From gavron at Wetwork.Net  Thu Nov  8 18:35:45 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Thu, 08 Nov 2007 10:35:45 -0700
Subject: BCM94311MCG
In-Reply-To: <000901c82229$97012fa0$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<47333DCD.5090304@Wetwork.Net>
	<000901c82229$97012fa0$0601a8c0@ruggiero>
Message-ID: <473348F1.2000107@Wetwork.Net>

I'm really not sure why you're ***'ing out your MAC addresses. 

At any rate your current problem is you're not associated with an AP.

# iwlist wlan0 scan | grep Cell | sed -e "s/\(.*Address:\)\(.*\)/\2/g" | 
xargs -i$ iwconfig wlan0 ap $

See how annoying it gets when you leave out useful but not 
security-related information?

Ehud

Ruggiero wrote:
> thanks for informations,i followed your suggestions...but i think i'm 
> missing something...here there are other informations:
>
> [root at localhost ~]# ifconfig
> eth0      Link encap:Ethernet  HWaddr 00:16:D4:DF:*:*
>         UP BROADCAST MULTICAST  MTU:1500  Metric:1
>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:1000
>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
>          Interrupt:21
>
> lo        Link encap:Local Loopback
>          inet addr:127.0.0.1  Mask:255.0.0.0
>          inet6 addr: ::1/128 Scope:Host
>          UP LOOPBACK RUNNING  MTU:16436  Metric:1
>          RX packets:8602 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:8602 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:0
>          RX bytes:69166424 (65.9 MiB)  TX bytes:69166424 (65.9 MiB)
>
> wlan0     Link encap:Ethernet  HWaddr 00:19:7E:84:*:*
>          inet addr:192.168.1.80  Bcast:192.168.1.255  Mask:255.255.255.0
>          UP BROADCAST MULTICAST  MTU:1500  Metric:1
>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:1000
>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
>
> wmaster0  Link encap:UNSPEC  HWaddr 
> *19-7E-84-*D3-D8-98-00-00-00-00-00-00-00-00
>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:1000
>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
>
>
> [root at localhost ~]# iwconfig
> lo        no wireless extensions.
>
> eth0      no wireless extensions.
>
> wmaster0  no wireless extensions.
>
> wlan0     IEEE 802.11g  ESSID:"*****
>        Mode:Managed  Frequency:2.412 GHz  Access Point: Not-Associated
>          Retry min limit:7   RTS thr:off   Fragment thr=2346 B
>          Encryption key:******************************************
>         Link Quality:0  Signal level:0  Noise level:0
>          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>          Tx excessive retries:0  Invalid misc:0   Missed beacon:0
>
> [root at localhost ~]# iwlist scan
> lo        Interface doesn't support scanning.
>
> eth0      Interface doesn't support scanning.
>
> wmaster0  Interface doesn't support scanning.
>
> wlan0     Scan completed :
>          Cell 01 - Address: *0C:41:19:2D:*
>                   ESSID:""
>                    Mode:Master
>                    Channel:11
>                    Frequency:2.462 GHz
>                    Quality=204/146  Signal level=-206 dBm  Noise 
> level=-67 dBm
>                    Encryption key:on
>                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
>                    Extra:tsf=0000000012e26229
>
> thanks again for helping 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071108/383ddb5f/attachment.bin>

From larry.finger at lwfinger.net  Thu Nov  8 18:42:16 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 08 Nov 2007 11:42:16 -0600
Subject: BCM94311MCG
In-Reply-To: <000901c82229$97012fa0$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<47333DCD.5090304@Wetwork.Net>
	<000901c82229$97012fa0$0601a8c0@ruggiero>
Message-ID: <47334A78.4090601@lwfinger.net>

Ruggiero wrote:
> thanks for informations,i followed your suggestions...but i think i'm 
> missing something...here there are other informations:
> 
> [root at localhost ~]# ifconfig
> eth0      Link encap:Ethernet  HWaddr 00:16:D4:DF:*:*
>         UP BROADCAST MULTICAST  MTU:1500  Metric:1
>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:1000
>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
>          Interrupt:21
> 
> lo        Link encap:Local Loopback
>          inet addr:127.0.0.1  Mask:255.0.0.0
>          inet6 addr: ::1/128 Scope:Host
>          UP LOOPBACK RUNNING  MTU:16436  Metric:1
>          RX packets:8602 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:8602 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:0
>          RX bytes:69166424 (65.9 MiB)  TX bytes:69166424 (65.9 MiB)
> 
> wlan0     Link encap:Ethernet  HWaddr 00:19:7E:84:*:*
>          inet addr:192.168.1.80  Bcast:192.168.1.255  Mask:255.255.255.0
>          UP BROADCAST MULTICAST  MTU:1500  Metric:1
>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:1000
>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
> 
> wmaster0  Link encap:UNSPEC  HWaddr 
> *19-7E-84-*D3-D8-98-00-00-00-00-00-00-00-00
>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:1000
>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
> 
> 
> [root at localhost ~]# iwconfig
> lo        no wireless extensions.
> 
> eth0      no wireless extensions.
> 
> wmaster0  no wireless extensions.
> 
> wlan0     IEEE 802.11g  ESSID:"*****
>        Mode:Managed  Frequency:2.412 GHz  Access Point: Not-Associated
>          Retry min limit:7   RTS thr:off   Fragment thr=2346 B
>          Encryption key:******************************************
>         Link Quality:0  Signal level:0  Noise level:0
>          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>          Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> 
> [root at localhost ~]# iwlist scan
> lo        Interface doesn't support scanning.
> 
> eth0      Interface doesn't support scanning.
> 
> wmaster0  Interface doesn't support scanning.
> 
> wlan0     Scan completed :
>          Cell 01 - Address: *0C:41:19:2D:*
>                   ESSID:""
>                    Mode:Master
>                    Channel:11
>                    Frequency:2.462 GHz
>                    Quality=204/146  Signal level=-206 dBm  Noise 
> level=-67 dBm
>                    Encryption key:on
>                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
>                    Extra:tsf=0000000012e26229
> 
> thanks again for helping

Fedora 7 offers the possibility of controlling your interface with NetworkManager, which I find much 
easier to use that ifup/ifdown, etc. The current version does require using dynamic IP's, not a 
static value. Is that possible for you?

Now that your wireless interface is up, please send a new copy of 'dmesg | grep bcm'.

Larry




From rugg.argos at tiscali.it  Thu Nov  8 18:49:42 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Thu, 8 Nov 2007 18:49:42 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<47333DCD.5090304@Wetwork.Net>
	<000901c82229$97012fa0$0601a8c0@ruggiero>
	<473348F1.2000107@Wetwork.Net>
Message-ID: <001701c8222f$bf0da950$0601a8c0@ruggiero>

lol,sorry for that,i'm newbie and i thought it could be useful to 
hide...here there is everything.another thing...when i go in 
System-<administration->Network and i active wlan0 i get a message that soon 
disappear,where is written...couldn't set rate...something like that ,i 
can't read everything
i use hidden essid on AP

[root at localhost ~]# ifconfig
eth0      Link encap:Ethernet  HWaddr 00:16:D4:DF:6C:04
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:21

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:8602 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8602 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:69166424 (65.9 MiB)  TX bytes:69166424 (65.9 MiB)

wlan0     Link encap:Ethernet  HWaddr 00:19:7E:84:F9:D3
          inet addr:192.168.1.80  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)

wmaster0  Link encap:UNSPEC  HWaddr 
00-19-7E-84-F9-D3-D8-98-00-00-00-00-00-00-00-00
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)


[root at localhost ~]# iwconfig
lo        no wireless extensions.

eth0      no wireless extensions.

wmaster0  no wireless extensions.

wlan0     IEEE 802.11g  ESSID:"che12345"
          Mode:Managed  Frequency:2.412 GHz  Access Point: Not-Associated
          Retry min limit:7   RTS thr:off   Fragment thr=2346 B
          Encryption key:6FFb-F8F9-D105-87F6-335C-8985-D8
          Link Quality:0  Signal level:0  Noise level:0
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

[root at localhost ~]# iwlist scan
lo        Interface doesn't support scanning.

eth0      Interface doesn't support scanning.

wmaster0  Interface doesn't support scanning.

wlan0     Scan completed :
          Cell 01 - Address: 00:0C:41:19:2D:C1
                    ESSID:""
                    Mode:Master
                    Channel:11
                    Frequency:2.462 GHz
                    Quality=204/146  Signal level=-206 dBm  Noise level=-67 
dBm
                    Encryption key:on
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
                    Extra:tsf=0000000012e26229



-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 821 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From rugg.argos at tiscali.it  Thu Nov  8 18:54:51 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Thu, 8 Nov 2007 18:54:51 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<47333DCD.5090304@Wetwork.Net>
	<000901c82229$97012fa0$0601a8c0@ruggiero>
	<47334A78.4090601@lwfinger.net>
Message-ID: <001b01c82230$76411350$0601a8c0@ruggiero>

can't i use static ip address?because all the lan is set up without dhcp

[root at localhost ~]# dmesg|grep bcm
bcm43xx_mac80211: Broadcom 4311 WLAN found
bcm43xx_mac80211: Found PHY: Analog 4, Type 2, Revision 8
bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Adding Interface type 2
bcm43xx_mac80211: Loading firmware version 351.126 (2006-07-29 05:54:02)
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: !WARNING! Idle-TSSI phy->cur_idle_tssi measuring failed. 
(cur=21, tgt=62). Disabling TX power adjustment.
bcm43xx_mac80211: Chip initialized
bcm43xx_mac80211: 32-bit DMA initialized
bcm43xx_mac80211: Wireless interface started
bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff


----- Original Message ----- 
From: "Larry Finger" <larry.finger at lwfinger.net>
To: "Ruggiero" <rugg.argos at tiscali.it>
Cc: "Ehud Gavron" <gavron at Wetwork.Net>; <bcm43xx-dev at lists.berlios.de>
Sent: Thursday, November 08, 2007 6:42 PM
Subject: Re: BCM94311MCG


> Ruggiero wrote:
>> thanks for informations,i followed your suggestions...but i think i'm 
>> missing something...here there are other informations:
>>
>> [root at localhost ~]# ifconfig
>> eth0      Link encap:Ethernet  HWaddr 00:16:D4:DF:*:*
>>         UP BROADCAST MULTICAST  MTU:1500  Metric:1
>>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>>          collisions:0 txqueuelen:1000
>>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
>>          Interrupt:21
>>
>> lo        Link encap:Local Loopback
>>          inet addr:127.0.0.1  Mask:255.0.0.0
>>          inet6 addr: ::1/128 Scope:Host
>>          UP LOOPBACK RUNNING  MTU:16436  Metric:1
>>          RX packets:8602 errors:0 dropped:0 overruns:0 frame:0
>>          TX packets:8602 errors:0 dropped:0 overruns:0 carrier:0
>>          collisions:0 txqueuelen:0
>>          RX bytes:69166424 (65.9 MiB)  TX bytes:69166424 (65.9 MiB)
>>
>> wlan0     Link encap:Ethernet  HWaddr 00:19:7E:84:*:*
>>          inet addr:192.168.1.80  Bcast:192.168.1.255  Mask:255.255.255.0
>>          UP BROADCAST MULTICAST  MTU:1500  Metric:1
>>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>>          collisions:0 txqueuelen:1000
>>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
>>
>> wmaster0  Link encap:UNSPEC  HWaddr 
>> *19-7E-84-*D3-D8-98-00-00-00-00-00-00-00-00
>>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
>>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>>          collisions:0 txqueuelen:1000
>>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
>>
>>
>> [root at localhost ~]# iwconfig
>> lo        no wireless extensions.
>>
>> eth0      no wireless extensions.
>>
>> wmaster0  no wireless extensions.
>>
>> wlan0     IEEE 802.11g  ESSID:"*****
>>        Mode:Managed  Frequency:2.412 GHz  Access Point: Not-Associated
>>          Retry min limit:7   RTS thr:off   Fragment thr=2346 B
>>          Encryption key:******************************************
>>         Link Quality:0  Signal level:0  Noise level:0
>>          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>>          Tx excessive retries:0  Invalid misc:0   Missed beacon:0
>>
>> [root at localhost ~]# iwlist scan
>> lo        Interface doesn't support scanning.
>>
>> eth0      Interface doesn't support scanning.
>>
>> wmaster0  Interface doesn't support scanning.
>>
>> wlan0     Scan completed :
>>          Cell 01 - Address: *0C:41:19:2D:*
>>                   ESSID:""
>>                    Mode:Master
>>                    Channel:11
>>                    Frequency:2.462 GHz
>>                    Quality=204/146  Signal level=-206 dBm  Noise 
>> level=-67 dBm
>>                    Encryption key:on
>>                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
>>                    Extra:tsf=0000000012e26229
>>
>> thanks again for helping
>
> Fedora 7 offers the possibility of controlling your interface with 
> NetworkManager, which I find much easier to use that ifup/ifdown, etc. The 
> current version does require using dynamic IP's, not a static value. Is 
> that possible for you?
>
> Now that your wireless interface is up, please send a new copy of 'dmesg | 
> grep bcm'.
>
> Larry
>
> 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 821 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From larry.finger at lwfinger.net  Thu Nov  8 20:22:15 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 08 Nov 2007 13:22:15 -0600
Subject: BCM94311MCG
In-Reply-To: <001b01c82230$76411350$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<47333DCD.5090304@Wetwork.Net>
	<000901c82229$97012fa0$0601a8c0@ruggiero>
	<47334A78.4090601@lwfinger.net>
	<001b01c82230$76411350$0601a8c0@ruggiero>
Message-ID: <473361E7.9070300@lwfinger.net>

Ruggiero wrote:
> can't i use static ip address?because all the lan is set up without dhcp

Yes, you can use static IP, but not with NetworkManager.

I'm not sure that the version of mac80211 in your system will work with hidden ESSID's. Do yourself 
a favor and unhide it. The degree of security afforded by a hidden ESSID is minimal.

Larry



From proski at gnu.org  Thu Nov  8 22:00:37 2007
From: proski at gnu.org (Pavel Roskin)
Date: Thu, 08 Nov 2007 16:00:37 -0500
Subject: BCM94311MCG
In-Reply-To: <000601c82225$7bc63220$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
Message-ID: <1194555637.25768.7.camel@dv>


On Thu, 2007-11-08 at 17:36 +0100, Ruggiero wrote:
> i just installed fedora7 and the firmware 4 by bcm43xx_fwcutter,it's a bit 
> different by ubuntu because i don't have the command iwconfig and iwlist 
> scan,how can i verify the card is working properly?here there is some 
> informations:
> i have a b44ethernet card in the laptop
> 
> [ruggiero at localhost ~]$ dmesg|grep bcm
> bcm43xx_mac80211: Broadcom 4311 WLAN found

You should upgrade your system with "yum upgrade".  The current Fedora 7
kernel is 2.6.23.1 with b43 and b43legacy drivers, which work much
better.

You'll need b43-fwcutter to prepare firmware for the updated drivers.
It creates firmware files in subdirectories and avoids conflict between
v23 and v4 firmware.

Just in case, today may not be the best day to upgrade Fedora, and
Fedora 8 was released, and the pipes are likely saturated.  Try
upgrading just the kernel: "yum upgrade kernel"

On the other hand, Fedora updates are so massive, that you may prefer to
join the torrent and download Fedora 8.

-- 
Regards,
Pavel Roskin



From mansour77 at yahoo.com  Fri Nov  9 01:17:22 2007
From: mansour77 at yahoo.com (Mansour)
Date: Thu, 08 Nov 2007 20:17:22 -0400
Subject: Can not get the card to work
Message-ID: <4733A712.9060006@yahoo.com>

Hello every one:
I just received a card that's supported by my laptop. I can not figure 
out how to get it to work. What FW do I need, any drivers ....etc.

dmesg | grep -i bcm
bcm43xx driver
bcm43xx: Chip ID 0x4311, rev 0x1
bcm43xx: Number of cores: 4
bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
bcm43xx: PHY connected
bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
bcm43xx: Radio turned off
bcm43xx: Radio turned off
bcm43xx: PHY connected
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
failed.
bcm43xx: core_up for active 802.11 core failed (-2)
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
failed.
bcm43xx: core_up for active 802.11 core failed (-2)
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
failed.
bcm43xx: core_up for active 802.11 core failed (-2)
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
failed.
bcm43xx: core_up for active 802.11 core failed (-2)
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
failed.
bcm43xx: core_up for active 802.11 core failed (-2)
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
failed.
bcm43xx: core_up for active 802.11 core failed (-2)
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
failed.
bcm43xx: core_up for active 802.11 core failed (-2)
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
.encrypt = 1
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
failed.
bcm43xx: core_up for active 802.11 core failed (-2)



cat /var/log/messages
Nov  8 21:10:11 localhost syslogd 1.4.2: restart.
Nov  8 21:10:19 localhost firmware_helper[4988]: Loading of 
/lib/firmware/bcm43xx_microcode5.fw for bcm43xx driver failed: No such 
file or directory
Nov  8 21:10:19 localhost kernel: bcm43xx: Error: Microcode 
"bcm43xx_microcode5.fw" not available or load failed.
Nov  8 21:10:19 localhost kernel: bcm43xx: core_up for active 802.11 
core failed (-2)
Nov  8 21:10:19 localhost kernel: bcm43xx: set security called, 
.active_key = 0, .level = 1, .enabled = 1, .encrypt = 1
Nov  8 21:10:20 localhost kernel: SoftMAC: Unable to find matching 
network after scan!
Nov  8 21:10:20 localhost firmware_helper[5001]: Loading of 
/lib/firmware/bcm43xx_microcode5.fw for bcm43xx driver failed: No such 
file or directory
Nov  8 21:10:20 localhost kernel: bcm43xx: Error: Microcode 
"bcm43xx_microcode5.fw" not available or load failed.
Nov  8 21:10:20 localhost kernel: bcm43xx: core_up for active 802.11 
core failed (-2)


Any advice about how to proceed ?







From ftoledo at docksud.com.ar  Fri Nov  9 03:37:11 2007
From: ftoledo at docksud.com.ar (Fernando Toledo)
Date: Thu, 8 Nov 2007 23:37:11 -0300
Subject: Can not get the card to work
In-Reply-To: <4733A712.9060006@yahoo.com>
References: <4733A712.9060006@yahoo.com>
Message-ID: <200711082337.15701.ftoledo@docksud.com.ar>

El Jue 08 Nov 2007, Mansour escribi?:
> Hello every one:
> I just received a card that's supported by my laptop. I can not figure
> out how to get it to work. What FW do I need, any drivers ....etc.
>
>
>
> Any advice about how to proceed ?
>
you must install the firmware :
http://www.linuxwireless.org/en/users/Drivers/b43#firmwareinstallation


-- 
Dock Sud BBS
http://www.docksud.com.ar
telnet://bbs.docksud.com.ar
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part.
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071108/a6afd671/attachment.pgp>

From larry.finger at lwfinger.net  Fri Nov  9 04:09:01 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 08 Nov 2007 21:09:01 -0600
Subject: Can not get the card to work
In-Reply-To: <4733A712.9060006@yahoo.com>
References: <4733A712.9060006@yahoo.com>
Message-ID: <4733CF4D.6090607@lwfinger.net>

Mansour wrote:
> Hello every one:
> I just received a card that's supported by my laptop. I can not figure 
> out how to get it to work. What FW do I need, any drivers ....etc.
> 
> dmesg | grep -i bcm
> bcm43xx driver
> bcm43xx: Chip ID 0x4311, rev 0x1
> bcm43xx: Number of cores: 4
> bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
> bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
> bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
> bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
> bcm43xx: PHY connected
> bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
> bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> bcm43xx: Radio turned off
> bcm43xx: Radio turned off
> bcm43xx: PHY connected
> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
> failed.
> bcm43xx: core_up for active 802.11 core failed (-2)
> bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
> .encrypt = 1
> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
> failed.
> bcm43xx: core_up for active 802.11 core failed (-2)
> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
> failed.
> bcm43xx: core_up for active 802.11 core failed (-2)
> bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
> .encrypt = 1
> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
> failed.
> bcm43xx: core_up for active 802.11 core failed (-2)
> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
> failed.
> bcm43xx: core_up for active 802.11 core failed (-2)
> bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
> .encrypt = 1
> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
> failed.
> bcm43xx: core_up for active 802.11 core failed (-2)
> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
> failed.
> bcm43xx: core_up for active 802.11 core failed (-2)
> bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
> .encrypt = 1
> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
> failed.
> bcm43xx: core_up for active 802.11 core failed (-2)
> 
> 
> 
> cat /var/log/messages
> Nov  8 21:10:11 localhost syslogd 1.4.2: restart.
> Nov  8 21:10:19 localhost firmware_helper[4988]: Loading of 
> /lib/firmware/bcm43xx_microcode5.fw for bcm43xx driver failed: No such 
> file or directory
> Nov  8 21:10:19 localhost kernel: bcm43xx: Error: Microcode 
> "bcm43xx_microcode5.fw" not available or load failed.
> Nov  8 21:10:19 localhost kernel: bcm43xx: core_up for active 802.11 
> core failed (-2)
> Nov  8 21:10:19 localhost kernel: bcm43xx: set security called, 
> .active_key = 0, .level = 1, .enabled = 1, .encrypt = 1
> Nov  8 21:10:20 localhost kernel: SoftMAC: Unable to find matching 
> network after scan!
> Nov  8 21:10:20 localhost firmware_helper[5001]: Loading of 
> /lib/firmware/bcm43xx_microcode5.fw for bcm43xx driver failed: No such 
> file or directory
> Nov  8 21:10:20 localhost kernel: bcm43xx: Error: Microcode 
> "bcm43xx_microcode5.fw" not available or load failed.
> Nov  8 21:10:20 localhost kernel: bcm43xx: core_up for active 802.11 
> core failed (-2)
> 
> 
> Any advice about how to proceed ?

You need to install the firmware. Go to http://linuxwireless.org/en/users/Drivers/b43#devicefirmware
and follow the instructions. The installation instructions are the next section of that webpage.You
will need V3 firmware for the bcm43xx. Once you get the firmware installed, it should work just fine.

Larry


From mansour77 at yahoo.com  Fri Nov  9 04:50:30 2007
From: mansour77 at yahoo.com (Mansour)
Date: Thu, 08 Nov 2007 23:50:30 -0400
Subject: Can not get the card to work
In-Reply-To: <4733CF4D.6090607@lwfinger.net>
References: <4733A712.9060006@yahoo.com> <4733CF4D.6090607@lwfinger.net>
Message-ID: <4733D906.4030902@yahoo.com>

I am still unable to get it to work.  That's what I did :
downloaded the firmware for version 3 from 
http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o
Then I compiled and installed 
http://linuxwireless.org/download/bcm43xx/fwcutter/bcm43xx-fwcutter.tar.bz2

Then I installed the extracte using the command:

bcm43xx-fwcutter -w /lib/firmware/ wl_apsta-3.130.20.0.o

now that's what I getting:
dmesg | tail -n 11

IPv6 over IPv4 tunneling driver
sit0: Disabled Privacy Extensions
b43-phy0 debug: Adding Interface type 2
b43-phy0 ERROR: YOUR FIRMWARE IS TOO OLD. Firmware from binary drivers 
older than version 4.x is unsupported. You must upgrade your firmware files.
b43-phy0 debug: Adding Interface type 2
b43-phy0 ERROR: Microcode not responding
b43-phy0 debug: Adding Interface type 2
b43-phy0 ERROR: YOUR FIRMWARE IS TOO OLD. Firmware from binary drivers 
older than version 4.x is unsupported. You must upgrade your firmware files.
b43-phy0 debug: Adding Interface type 2
b43-phy0 ERROR: Microcode not responding
eth0: no IPv6 routers present




Larry Finger wrote:
> Mansour wrote:
>   
>> Hello every one:
>> I just received a card that's supported by my laptop. I can not figure 
>> out how to get it to work. What FW do I need, any drivers ....etc.
>>
>> dmesg | grep -i bcm
>> bcm43xx driver
>> bcm43xx: Chip ID 0x4311, rev 0x1
>> bcm43xx: Number of cores: 4
>> bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
>> bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
>> bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
>> bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
>> bcm43xx: PHY connected
>> bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
>> bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
>> bcm43xx: Radio turned off
>> bcm43xx: Radio turned off
>> bcm43xx: PHY connected
>> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
>> failed.
>> bcm43xx: core_up for active 802.11 core failed (-2)
>> bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
>> .encrypt = 1
>> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
>> failed.
>> bcm43xx: core_up for active 802.11 core failed (-2)
>> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
>> failed.
>> bcm43xx: core_up for active 802.11 core failed (-2)
>> bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
>> .encrypt = 1
>> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
>> failed.
>> bcm43xx: core_up for active 802.11 core failed (-2)
>> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
>> failed.
>> bcm43xx: core_up for active 802.11 core failed (-2)
>> bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
>> .encrypt = 1
>> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
>> failed.
>> bcm43xx: core_up for active 802.11 core failed (-2)
>> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
>> failed.
>> bcm43xx: core_up for active 802.11 core failed (-2)
>> bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, 
>> .encrypt = 1
>> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
>> failed.
>> bcm43xx: core_up for active 802.11 core failed (-2)
>>
>>
>>
>> cat /var/log/messages
>> Nov  8 21:10:11 localhost syslogd 1.4.2: restart.
>> Nov  8 21:10:19 localhost firmware_helper[4988]: Loading of 
>> /lib/firmware/bcm43xx_microcode5.fw for bcm43xx driver failed: No such 
>> file or directory
>> Nov  8 21:10:19 localhost kernel: bcm43xx: Error: Microcode 
>> "bcm43xx_microcode5.fw" not available or load failed.
>> Nov  8 21:10:19 localhost kernel: bcm43xx: core_up for active 802.11 
>> core failed (-2)
>> Nov  8 21:10:19 localhost kernel: bcm43xx: set security called, 
>> .active_key = 0, .level = 1, .enabled = 1, .encrypt = 1
>> Nov  8 21:10:20 localhost kernel: SoftMAC: Unable to find matching 
>> network after scan!
>> Nov  8 21:10:20 localhost firmware_helper[5001]: Loading of 
>> /lib/firmware/bcm43xx_microcode5.fw for bcm43xx driver failed: No such 
>> file or directory
>> Nov  8 21:10:20 localhost kernel: bcm43xx: Error: Microcode 
>> "bcm43xx_microcode5.fw" not available or load failed.
>> Nov  8 21:10:20 localhost kernel: bcm43xx: core_up for active 802.11 
>> core failed (-2)
>>
>>
>> Any advice about how to proceed ?
>>     
>
> You need to install the firmware. Go to http://linuxwireless.org/en/users/Drivers/b43#devicefirmware
> and follow the instructions. The installation instructions are the next section of that webpage.You
> will need V3 firmware for the bcm43xx. Once you get the firmware installed, it should work just fine.
>
> Larry
>
>   



From larry.finger at lwfinger.net  Fri Nov  9 05:03:50 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 08 Nov 2007 22:03:50 -0600
Subject: Can not get the card to work
In-Reply-To: <4733D906.4030902@yahoo.com>
References: <4733A712.9060006@yahoo.com> <4733CF4D.6090607@lwfinger.net>
	<4733D906.4030902@yahoo.com>
Message-ID: <4733DC26.8000704@lwfinger.net>

Mansour wrote:
> I am still unable to get it to work.  That's what I did :
> downloaded the firmware for version 3 from 
> http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o
> Then I compiled and installed 
> http://linuxwireless.org/download/bcm43xx/fwcutter/bcm43xx-fwcutter.tar.bz2
> 
> Then I installed the extracte using the command:
> 
> bcm43xx-fwcutter -w /lib/firmware/ wl_apsta-3.130.20.0.o
> 
> now that's what I getting:
> dmesg | tail -n 11
> 
> IPv6 over IPv4 tunneling driver
> sit0: Disabled Privacy Extensions
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 ERROR: YOUR FIRMWARE IS TOO OLD. Firmware from binary drivers 
> older than version 4.x is unsupported. You must upgrade your firmware files.
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 ERROR: Microcode not responding
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 ERROR: YOUR FIRMWARE IS TOO OLD. Firmware from binary drivers 
> older than version 4.x is unsupported. You must upgrade your firmware files.
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 ERROR: Microcode not responding
> eth0: no IPv6 routers present

Between the previous message and this one, you switched from bcm43xx to b43. The b43 driver needs V4
firmware that is installed with b43-fwcutter, not bcm43xx-fwcutter. That is explained on the web
site you were given earlier.

Larry




From mansour77 at yahoo.com  Fri Nov  9 05:20:53 2007
From: mansour77 at yahoo.com (Mansour)
Date: Fri, 09 Nov 2007 00:20:53 -0400
Subject: Can not get the card to work
In-Reply-To: <4733DC26.8000704@lwfinger.net>
References: <4733A712.9060006@yahoo.com> <4733CF4D.6090607@lwfinger.net>
	<4733D906.4030902@yahoo.com> <4733DC26.8000704@lwfinger.net>
Message-ID: <4733E025.10903@yahoo.com>

Larry, I think there's a confusion here.
The web page says:

"1. Download the appropriate driver listed above. Note that b43 needs V4 
firmware, b43legacy and bcm43xx need V3. For V4 firmware, you will also 
need to untar the downloaded file. "


Now, I downloaded the firmware for V3 which is (wl_apsta-3.130.20.0.o) 
and to install it I needed bcm43xx-fwcutter based on what the webpage says.
The command in my previous post, shows that I have used V3 to install 
the firmware.
I don't understand what I am doing wrong.





Larry Finger wrote:
> Mansour wrote:
>   
>> I am still unable to get it to work.  That's what I did :
>> downloaded the firmware for version 3 from 
>> http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o
>> Then I compiled and installed 
>> http://linuxwireless.org/download/bcm43xx/fwcutter/bcm43xx-fwcutter.tar.bz2
>>
>> Then I installed the extracte using the command:
>>
>> bcm43xx-fwcutter -w /lib/firmware/ wl_apsta-3.130.20.0.o
>>
>> now that's what I getting:
>> dmesg | tail -n 11
>>
>> IPv6 over IPv4 tunneling driver
>> sit0: Disabled Privacy Extensions
>> b43-phy0 debug: Adding Interface type 2
>> b43-phy0 ERROR: YOUR FIRMWARE IS TOO OLD. Firmware from binary drivers 
>> older than version 4.x is unsupported. You must upgrade your firmware files.
>> b43-phy0 debug: Adding Interface type 2
>> b43-phy0 ERROR: Microcode not responding
>> b43-phy0 debug: Adding Interface type 2
>> b43-phy0 ERROR: YOUR FIRMWARE IS TOO OLD. Firmware from binary drivers 
>> older than version 4.x is unsupported. You must upgrade your firmware files.
>> b43-phy0 debug: Adding Interface type 2
>> b43-phy0 ERROR: Microcode not responding
>> eth0: no IPv6 routers present
>>     
>
> Between the previous message and this one, you switched from bcm43xx to b43. The b43 driver needs V4
> firmware that is installed with b43-fwcutter, not bcm43xx-fwcutter. That is explained on the web
> site you were given earlier.
>
> Larry
>
>
>
>   



From larry.finger at lwfinger.net  Fri Nov  9 05:36:03 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 08 Nov 2007 22:36:03 -0600
Subject: Can not get the card to work
In-Reply-To: <4733E025.10903@yahoo.com>
References: <4733A712.9060006@yahoo.com> <4733CF4D.6090607@lwfinger.net>
	<4733D906.4030902@yahoo.com> <4733DC26.8000704@lwfinger.net>
	<4733E025.10903@yahoo.com>
Message-ID: <4733E3B3.6@lwfinger.net>

Mansour wrote:
> Larry, I think there's a confusion here.
> The web page says:
> 
> "1. Download the appropriate driver listed above. Note that b43 needs V4
> firmware, b43legacy and bcm43xx need V3. For V4 firmware, you will also
> need to untar the downloaded file. "
> 
> 
> Now, I downloaded the firmware for V3 which is (wl_apsta-3.130.20.0.o)
> and to install it I needed bcm43xx-fwcutter based on what the webpage says.
> The command in my previous post, shows that I have used V3 to install
> the firmware.
> I don't understand what I am doing wrong.

As it says, b43 needs V4 firmware. V3 firmware only works for bcm43xx and b43legacy.

To install firmware for bcm43xx, use bcm43xx-fwcutter.

To install firmware for b43 and b43legacy, use b43-fwcutter.

Larry



From mgerdau at tiscali.de  Fri Nov  9 07:51:54 2007
From: mgerdau at tiscali.de (Michael Gerdau)
Date: Fri, 9 Nov 2007 07:51:54 +0100
Subject: Can not get the card to work
In-Reply-To: <4733D906.4030902@yahoo.com>
References: <4733A712.9060006@yahoo.com> <4733CF4D.6090607@lwfinger.net>
	<4733D906.4030902@yahoo.com>
Message-ID: <200711090752.08499.mgerdau@tiscali.de>

> now that's what I getting:
> dmesg | tail -n 11
> 
> IPv6 over IPv4 tunneling driver
> sit0: Disabled Privacy Extensions
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 ERROR: YOUR FIRMWARE IS TOO OLD. Firmware from binary drivers 
> older than version 4.x is unsupported. You must upgrade your firmware files.
[snip]

These msgs all say 'b43'-something

In a previous msg you wrote:

> >> I just received a card that's supported by my laptop. I can not figure 
> >> out how to get it to work. What FW do I need, any drivers ....etc.
> >>
> >> dmesg | grep -i bcm
> >> bcm43xx driver
> >> bcm43xx: Chip ID 0x4311, rev 0x1
> >> bcm43xx: Number of cores: 4
[snip]

These msgs all say 'bcm43xx'-something.

The reason is you changed the driver you were using. Both drivers
need different firmware.

Best,
Michael
-- 
 Vote against SPAM - see http://www.politik-digital.de/spam/
 Michael Gerdau       email: mgerdau at tiscali.de
 GPG-keys available on request or at public keyserver
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 194 bytes
Desc: This is a digitally signed message part.
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071109/c26744cb/attachment.pgp>

From rugg.argos at tiscali.it  Fri Nov  9 13:47:38 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Fri, 9 Nov 2007 13:47:38 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<1194555637.25768.7.camel@dv>
Message-ID: <000001c822ce$cb1b9910$0601a8c0@ruggiero>

i just installed fedora 8 and with b43-fwcutter i installed firmware 
v4...now if i use NetworkManager and i connect to the ap,i insert wep key 
but after a while it ask me again for the password and i don't get 
connected...
while if i use iwconfig i got connected but i can't ping anything or 
visiting websites,also on the access point it tells me that another device 
is connected..here there is some informations:

[root at localhost ~]# iwconfig
lo        no wireless extensions.

eth0      no wireless extensions.

wmaster0  no wireless extensions.

wlan0     IEEE 802.11g  ESSID:"che12345"
          Mode:Managed  Frequency:2.462 GHz  Access Point: 00:0C:41:19:2D:C1
          Bit Rate=1 Mb/s   Tx-Power=27 dBm
          Retry min limit:7   RTS thr:off   Fragment thr=2346 B
          Encryption key:6FFB-F8F9-D105-87F6-335C-8985-D8
          Link Quality=96/100  Signal level=-38 dBm  Noise level=-38 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

[root at localhost ~]# dmesg|grep b43
b43-phy0: Broadcom 4311 WLAN found
b43-phy0 debug: Found PHY: Analog 4, Type 2, Revision 8
b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
b43-phy0 debug: Removing Interface type 2
b43-phy0 debug: Wireless interface stopped
b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 8/128
b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff


i think i'm missing something...but i don't know what...hope anyone can help 
me
greetings
ruggiero 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 824 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From rugg.argos at tiscali.it  Fri Nov  9 14:30:00 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Fri, 9 Nov 2007 14:30:00 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<1194555637.25768.7.camel@dv>
Message-ID: <000501c822d4$a12e8210$0601a8c0@ruggiero>

here there is some more informations:

[root at localhost ~]# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use 
Iface
192.168.1.0     *               255.255.255.0   U     0      0        0 
wlan0
link-local      *               255.255.0.0     U     0      0        0 
wlan0
default         192.168.1.1     0.0.0.0         UG    0      0        0 
wlan0

      40: Fri Nov 09 2007 14:22:04  Wireless PC Connected Mac: 
00-19-7e-84-f9-d3
      41: Fri Nov 09 2007 14:24:11  Wireless PC Connected Mac: 
00-19-7e-84-f9-d3

this is what comes out from the ap log 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 826 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From larry.finger at lwfinger.net  Fri Nov  9 16:52:18 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 09:52:18 -0600
Subject: bcm43xx + Kismet = signal and noise zero
In-Reply-To: <47347A1E.6080803@bellsouth.net>
References: <47327F79.7070404@bellsouth.net> <473296CD.1080309@lwfinger.net>
	<47347A1E.6080803@bellsouth.net>
Message-ID: <47348232.7090302@lwfinger.net>

DeckerXL wrote:
> Linux bt 2.6.20-BT-PwnSauce-NOSMP #3 Sat Feb 24 15:52:59 GMT 2007 i686
> athlon-4 i386 GNU/Linux
> 

You should update to 2.6.22 or later.

Larry



From larry.finger at lwfinger.net  Fri Nov  9 17:02:26 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 10:02:26 -0600
Subject: BCM94311MCG
In-Reply-To: <000001c822ce$cb1b9910$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>	<4731FE46.1060403@lwfinger.net>	<003701c82179$da3f4c80$0601a8c0@ruggiero>	<47329750.7080505@lwfinger.net>	<000601c821dd$09fc0720$0601a8c0@ruggiero>	<473330FF.4090605@lwfinger.net>	<000601c82225$7bc63220$0601a8c0@ruggiero>	<1194555637.25768.7.camel@dv>
	<000001c822ce$cb1b9910$0601a8c0@ruggiero>
Message-ID: <47348492.3070605@lwfinger.net>

Ruggiero wrote:
> i just installed fedora 8 and with b43-fwcutter i installed firmware 
> v4...now if i use NetworkManager and i connect to the ap,i insert wep key 
> but after a while it ask me again for the password and i don't get 
> connected...
> while if i use iwconfig i got connected but i can't ping anything or 
> visiting websites,also on the access point it tells me that another device 
> is connected..here there is some informations:
> 
> [root at localhost ~]# iwconfig
> lo        no wireless extensions.
> 
> eth0      no wireless extensions.
> 
> wmaster0  no wireless extensions.
> 
> wlan0     IEEE 802.11g  ESSID:"che12345"
>           Mode:Managed  Frequency:2.462 GHz  Access Point: 00:0C:41:19:2D:C1
>           Bit Rate=1 Mb/s   Tx-Power=27 dBm
>           Retry min limit:7   RTS thr:off   Fragment thr=2346 B
>           Encryption key:6FFB-F8F9-D105-87F6-335C-8985-D8
>           Link Quality=96/100  Signal level=-38 dBm  Noise level=-38 dBm
>           Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>           Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> 
> [root at localhost ~]# dmesg|grep b43
> b43-phy0: Broadcom 4311 WLAN found
> b43-phy0 debug: Found PHY: Analog 4, Type 2, Revision 8
> b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: 
> ff:ff:ff:ff:ff:ff
> b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: 
> ff:ff:ff:ff:ff:ff
> b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: 
> ff:ff:ff:ff:ff:ff
> b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: 
> ff:ff:ff:ff:ff:ff
> b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: 
> ff:ff:ff:ff:ff:ff
> b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: 
> ff:ff:ff:ff:ff:ff
> b43-phy0 debug: Removing Interface type 2
> b43-phy0 debug: Wireless interface stopped
> b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
> b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 8/128
> b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: 
> ff:ff:ff:ff:ff:ff
> 
> 
> i think i'm missing something...but i don't know what...hope anyone can help 
> me

In your dmesg output, you should see something like

b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff
eth1: Initial auth_alg=0
eth1: authenticate with AP 00:14:bf:85:49:fa
eth1: RX authentication from 00:14:bf:85:49:fa (alg=0 transaction=2 status=0)
eth1: authenticated
eth1: associate with AP 00:14:bf:85:49:fa
eth1: RX AssocResp from 00:14:bf:85:49:fa (capab=0x431 status=0 aid=1)
eth1: associated

In your case, it will say wlan0 rather than eth1.

If you are not getting authentication, the problem is likely in your WEP key. How are you setting
that? If you are trying to use a passphrase, your AP and NetworkManager may not be converting to a
hex key using the same algorithm. When I use WEP, I enter a passphrase into my AP, but write down
the hex key and use that on all the computers.

Incidentally, are you aware that you published your encryption key for the entire world to see?

Larry


From rugg.argos at tiscali.it  Fri Nov  9 18:10:39 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Fri, 9 Nov 2007 18:10:39 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<1194555637.25768.7.camel@dv>
	<000001c822ce$cb1b9910$0601a8c0@ruggiero>
	<47348492.3070605@lwfinger.net>
Message-ID: <000301c822f3$73dbef90$0601a8c0@ruggiero>

i have no idea of what happens....i disabled wep encription and can't get 
connected either...i don't know what to do anymore :(




b43-phy0: Broadcom 4311 WLAN found
b43-phy0 debug: Found PHY: Analog 4, Type 2, Revision 8
b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Removing Interface type 2
b43-phy0 debug: Wireless interface stopped
b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 6/128
b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac: 
ff:ff:ff:ff:ff:ff
b43-phy0 debug: Removing Interface type 2
b43-phy0 debug: Wireless interface stopped
b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 8/128
b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Removing Interface type 2
b43-phy0 debug: Wireless interface stopped
b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 4/128
b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Removing Interface type 2
b43-phy0 debug: Wireless interface stopped
b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 8/128
b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Removing Interface type 2
b43-phy0 debug: Wireless interface stopped
b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 6/128
b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started



-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 827 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From larry.finger at lwfinger.net  Fri Nov  9 18:22:05 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 11:22:05 -0600
Subject: BCM94311MCG
In-Reply-To: <000301c822f3$73dbef90$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<1194555637.25768.7.camel@dv>
	<000001c822ce$cb1b9910$0601a8c0@ruggiero>
	<47348492.3070605@lwfinger.net>
	<000301c822f3$73dbef90$0601a8c0@ruggiero>
Message-ID: <4734973D.4060703@lwfinger.net>

Ruggiero wrote:
> i have no idea of what happens....i disabled wep encription and can't
> get connected either...i don't know what to do anymore :(
> 
> 
> 
> 
> b43-phy0: Broadcom 4311 WLAN found
> b43-phy0 debug: Found PHY: Analog 4, Type 2, Revision 8
> b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> b43-phy0 debug: Removing Interface type 2
> b43-phy0 debug: Wireless interface stopped
> b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
> b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 6/128
> b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac:
> ff:ff:ff:ff:ff:ff
> b43-phy0 debug: Disabling hardware based encryption for keyidx: 0, mac:
> ff:ff:ff:ff:ff:ff
> b43-phy0 debug: Removing Interface type 2
> b43-phy0 debug: Wireless interface stopped
> b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
> b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 8/128
> b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> b43-phy0 debug: Removing Interface type 2
> b43-phy0 debug: Wireless interface stopped
> b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
> b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 4/128
> b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> b43-phy0 debug: Removing Interface type 2
> b43-phy0 debug: Wireless interface stopped
> b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
> b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 8/128
> b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> b43-phy0 debug: Removing Interface type 2
> b43-phy0 debug: Wireless interface stopped
> b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
> b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 6/128
> b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started

b43 is showing no errors; therefore the problem is somewhere else. We need to see the output of the
following:

iwconfig
ifconfig
iwlist scan
the part of dmesg that follows the b43 "Loading firmware" message.

Are you using NetworkManager of the traditional ifup/ifdown method?

Larry


From rugg.argos at tiscali.it  Fri Nov  9 19:54:11 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Fri, 9 Nov 2007 19:54:11 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<1194555637.25768.7.camel@dv>
	<000001c822ce$cb1b9910$0601a8c0@ruggiero>
	<47348492.3070605@lwfinger.net>
	<000301c822f3$73dbef90$0601a8c0@ruggiero>
	<4734973D.4060703@lwfinger.net>
Message-ID: <000301c82301$eafbd050$0601a8c0@ruggiero>

i used "system->adminstration>Network" and i configurated everything from 
there...and the clicking on "activate wlan0" for a while my access point 
communicate and in the log i see that it's connected... here are outputs:
ah,in iwconfig there is IEEE 802.11g,my access point is b...could this be 
the problem?
if i use NetworkManager i see it's connecting...but after a while i get the 
message "disconnected"


[root at localhost ~]# dmesg|grep b43
b43-phy0: Broadcom 4311 WLAN found
b43-phy0 debug: Found PHY: Analog 4, Type 2, Revision 8
b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Removing Interface type 2
b43-phy0 debug: Wireless interface stopped
b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 10/128
b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Removing Interface type 2
b43-phy0 debug: Wireless interface stopped
b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 6/128
b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started


[root at localhost ~]# iwconfig
lo        no wireless extensions.

eth0      no wireless extensions.

wmaster0  no wireless extensions.

wlan0     IEEE 802.11g  ESSID:"che12345"
          Mode:Managed  Frequency:2.462 GHz  Access Point: 00:0C:41:19:2D:C1
          Bit Rate=1 Mb/s   Tx-Power=27 dBm
          Retry min limit:7   RTS thr:off   Fragment thr=2346 B
          Encryption key:off
          Link Quality=100/100  Signal level=-35 dBm  Noise level=-38 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

[root at localhost ~]# ifconfig
eth0      Link encap:Ethernet  HWaddr 00:16:D4:DF:6C:04
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:21

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:5847 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5847 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:3271092 (3.1 MiB)  TX bytes:3271092 (3.1 MiB)

wlan0     Link encap:Ethernet  HWaddr 00:19:7E:84:F9:D3
          inet addr:192.168.1.80  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::219:7eff:fe84:f9d3/64 Scope:Link
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:1 errors:0 dropped:0 overruns:0 frame:0
          TX packets:33 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:247 (247.0 b)  TX bytes:5496 (5.3 KiB)

wmaster0  Link encap:UNSPEC  HWaddr 
00-19-7E-84-F9-D3-18-EF-00-00-00-00-00-00-00-00
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)

[root at localhost ~]# iwlist scan
lo        Interface doesn't support scanning.

eth0      Interface doesn't support scanning.

wmaster0  Interface doesn't support scanning.

wlan0     Scan completed :
          Cell 01 - Address: 00:0C:41:19:2D:C1
                    ESSID:"che12345"
                    Mode:Master
                    Channel:11
                    Frequency:2.462 GHz (Channel 11)
                    Quality=98/100  Signal level=-36 dBm  Noise level=-38 
dBm
                    Encryption key:off
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
                    Extra:tsf=000000001cad652f

thanks u all for helping 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 827 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From larry.finger at lwfinger.net  Fri Nov  9 20:03:35 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 13:03:35 -0600
Subject: BCM94311MCG
In-Reply-To: <000301c82301$eafbd050$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<1194555637.25768.7.camel@dv>
	<000001c822ce$cb1b9910$0601a8c0@ruggiero>
	<47348492.3070605@lwfinger.net>
	<000301c822f3$73dbef90$0601a8c0@ruggiero>
	<4734973D.4060703@lwfinger.net>
	<000301c82301$eafbd050$0601a8c0@ruggiero>
Message-ID: <4734AF07.5040003@lwfinger.net>

Ruggiero wrote:
> i used "system->adminstration>Network" and i configurated everything
> from there...and the clicking on "activate wlan0" for a while my access
> point communicate and in the log i see that it's connected... here are
> outputs:
> ah,in iwconfig there is IEEE 802.11g,my access point is b...could this
> be the problem?
> if i use NetworkManager i see it's connecting...but after a while i get
> the message "disconnected"
> 
> 
> [root at localhost ~]# dmesg|grep b43
> b43-phy0: Broadcom 4311 WLAN found
> b43-phy0 debug: Found PHY: Analog 4, Type 2, Revision 8
> b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> b43-phy0 debug: Removing Interface type 2
> b43-phy0 debug: Wireless interface stopped
> b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
> b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 10/128
> b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> b43-phy0 debug: Removing Interface type 2
> b43-phy0 debug: Wireless interface stopped
> b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
> b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
> b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 6/128
> b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
> b43-phy0 debug: Adding Interface type 2
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> 
> 
> [root at localhost ~]# iwconfig
> lo        no wireless extensions.
> 
> eth0      no wireless extensions.
> 
> wmaster0  no wireless extensions.
> 
> wlan0     IEEE 802.11g  ESSID:"che12345"
>          Mode:Managed  Frequency:2.462 GHz  Access Point: 00:0C:41:19:2D:C1
>          Bit Rate=1 Mb/s   Tx-Power=27 dBm
>          Retry min limit:7   RTS thr:off   Fragment thr=2346 B
>          Encryption key:off
>          Link Quality=100/100  Signal level=-35 dBm  Noise level=-38 dBm
>          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
>          Tx excessive retries:0  Invalid misc:0   Missed beacon:0
> 
> [root at localhost ~]# ifconfig
> eth0      Link encap:Ethernet  HWaddr 00:16:D4:DF:6C:04
>          UP BROADCAST MULTICAST  MTU:1500  Metric:1
>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:1000
>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
>          Interrupt:21
> 
> lo        Link encap:Local Loopback
>          inet addr:127.0.0.1  Mask:255.0.0.0
>          inet6 addr: ::1/128 Scope:Host
>          UP LOOPBACK RUNNING  MTU:16436  Metric:1
>          RX packets:5847 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:5847 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:0
>          RX bytes:3271092 (3.1 MiB)  TX bytes:3271092 (3.1 MiB)
> 
> wlan0     Link encap:Ethernet  HWaddr 00:19:7E:84:F9:D3
>          inet addr:192.168.1.80  Bcast:192.168.1.255  Mask:255.255.255.0
>          inet6 addr: fe80::219:7eff:fe84:f9d3/64 Scope:Link
>          UP BROADCAST MULTICAST  MTU:1500  Metric:1
>          RX packets:1 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:33 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:1000
>          RX bytes:247 (247.0 b)  TX bytes:5496 (5.3 KiB)
> 
> wmaster0  Link encap:UNSPEC  HWaddr
> 00-19-7E-84-F9-D3-18-EF-00-00-00-00-00-00-00-00
>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>          collisions:0 txqueuelen:1000
>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
> 
> [root at localhost ~]# iwlist scan
> lo        Interface doesn't support scanning.
> 
> eth0      Interface doesn't support scanning.
> 
> wmaster0  Interface doesn't support scanning.
> 
> wlan0     Scan completed :
>          Cell 01 - Address: 00:0C:41:19:2D:C1
>                    ESSID:"che12345"
>                    Mode:Master
>                    Channel:11
>                    Frequency:2.462 GHz (Channel 11)
>                    Quality=98/100  Signal level=-36 dBm  Noise level=-38
> dBm
>                    Encryption key:off
>                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s
>                    Extra:tsf=000000001cad652f
> 
> thanks u all for helping

You missed this part of my request!  "the part of dmesg that follows the b43 "Loading firmware"
message."

The fact that your interface is 802.11g and your AP is 802.11b will not matter.

Larry


From rugg.argos at tiscali.it  Fri Nov  9 21:23:36 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Fri, 9 Nov 2007 21:23:36 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<1194555637.25768.7.camel@dv>
	<000001c822ce$cb1b9910$0601a8c0@ruggiero>
	<47348492.3070605@lwfinger.net>
	<000301c822f3$73dbef90$0601a8c0@ruggiero>
	<4734973D.4060703@lwfinger.net>
	<000301c82301$eafbd050$0601a8c0@ruggiero>
	<4734AF07.5040003@lwfinger.net>
Message-ID: <000301c8230e$6880b980$0601a8c0@ruggiero>

but i posted everything.... i didn't cut anything...that's the output of 
dmesg|grep b43 i checked it more than 1 time because u asked for it but 
there wasn't anything more 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 828 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From larry.finger at lwfinger.net  Fri Nov  9 22:11:22 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 15:11:22 -0600
Subject: BCM94311MCG
In-Reply-To: <000301c8230e$6880b980$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<1194555637.25768.7.camel@dv>
	<000001c822ce$cb1b9910$0601a8c0@ruggiero>
	<47348492.3070605@lwfinger.net>
	<000301c822f3$73dbef90$0601a8c0@ruggiero>
	<4734973D.4060703@lwfinger.net>
	<000301c82301$eafbd050$0601a8c0@ruggiero>
	<4734AF07.5040003@lwfinger.net>
	<000301c8230e$6880b980$0601a8c0@ruggiero>
Message-ID: <4734CCFA.1020504@lwfinger.net>

Ruggiero wrote:
> but i posted everything.... i didn't cut anything...that's the output of
> dmesg|grep b43 i checked it more than 1 time because u asked for it but
> there wasn't anything more

I want the non-b43 stuff that tells about associating, etc. It will have a wlan0: prefix.

Larry


From rugg.argos at tiscali.it  Fri Nov  9 22:17:33 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Fri, 9 Nov 2007 22:17:33 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<1194555637.25768.7.camel@dv>
	<000001c822ce$cb1b9910$0601a8c0@ruggiero>
	<47348492.3070605@lwfinger.net>
	<000301c822f3$73dbef90$0601a8c0@ruggiero>
	<4734973D.4060703@lwfinger.net>
	<000301c82301$eafbd050$0601a8c0@ruggiero>
	<4734AF07.5040003@lwfinger.net>
	<000301c8230e$6880b980$0601a8c0@ruggiero>
	<4734CCFA.1020504@lwfinger.net>
Message-ID: <000301c82315$f1d71830$0601a8c0@ruggiero>

sorry for my being newbie...but what i have to type in the terminal?
i typed dmesg|grep b43 and i copied everything....
sorry again

-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 828 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From larry.finger at lwfinger.net  Fri Nov  9 22:37:44 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 15:37:44 -0600
Subject: BCM94311MCG
In-Reply-To: <000301c82315$f1d71830$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<1194555637.25768.7.camel@dv>
	<000001c822ce$cb1b9910$0601a8c0@ruggiero>
	<47348492.3070605@lwfinger.net>
	<000301c822f3$73dbef90$0601a8c0@ruggiero>
	<4734973D.4060703@lwfinger.net>
	<000301c82301$eafbd050$0601a8c0@ruggiero>
	<4734AF07.5040003@lwfinger.net>
	<000301c8230e$6880b980$0601a8c0@ruggiero>
	<4734CCFA.1020504@lwfinger.net>
	<000301c82315$f1d71830$0601a8c0@ruggiero>
Message-ID: <4734D328.20106@lwfinger.net>

Ruggiero wrote:
> sorry for my being newbie...but what i have to type in the terminal?
> i typed dmesg|grep b43 and i copied everything....
> sorry again
> 

Just type dmesg and send everything after the last "Firmware loaded" message.

Larry


From rugg.argos at tiscali.it  Fri Nov  9 22:51:40 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Fri, 9 Nov 2007 22:51:40 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero>
	<4731FE46.1060403@lwfinger.net>
	<003701c82179$da3f4c80$0601a8c0@ruggiero>
	<47329750.7080505@lwfinger.net>
	<000601c821dd$09fc0720$0601a8c0@ruggiero>
	<473330FF.4090605@lwfinger.net>
	<000601c82225$7bc63220$0601a8c0@ruggiero>
	<1194555637.25768.7.camel@dv>
	<000001c822ce$cb1b9910$0601a8c0@ruggiero>
	<47348492.3070605@lwfinger.net>
	<000301c822f3$73dbef90$0601a8c0@ruggiero>
	<4734973D.4060703@lwfinger.net>
	<000301c82301$eafbd050$0601a8c0@ruggiero>
	<4734AF07.5040003@lwfinger.net>
	<000301c8230e$6880b980$0601a8c0@ruggiero>
	<4734CCFA.1020504@lwfinger.net>
	<000301c82315$f1d71830$0601a8c0@ruggiero>
	<4734D328.20106@lwfinger.net>
Message-ID: <000b01c8231a$b78c82a0$0601a8c0@ruggiero>

thanks a lot for helping i found what u asked : 

b43-phy0 debug: Adding Interface type 2
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started
ADDRCONF(NETDEV_UP): wlan0: link is not ready
[drm] Initialized drm 1.1.0 20060810
[drm] Initialized i915 1.6.0 20060119 on minor 0
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authentication with AP 00:0c:41:19:2d:c1 timed out
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authentication with AP 00:0c:41:19:2d:c1 timed out
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authentication with AP 00:0c:41:19:2d:c1 timed out

i disabled SElinux if was enabled before...

-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 828 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From rugg.argos at tiscali.it  Fri Nov  9 23:00:54 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Fri, 9 Nov 2007 23:00:54 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net>
	<000b01c8231a$b78c82a0$0601a8c0@ruggiero>
Message-ID: <001001c8231c$04413d60$0601a8c0@ruggiero>

wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authentication with AP 00:0c:41:19:2d:c1 timed out
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in 
authenticate state - ignored
wlan0: RX disassociation from 00:0c:41:19:2d:c1 (reason=4)

i found this message too...i don't know if it can be useful 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 828 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From larry.finger at lwfinger.net  Fri Nov  9 23:39:56 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 16:39:56 -0600
Subject: Help with wireless on Fedora 8
In-Reply-To: <001001c8231c$04413d60$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net>
	<000b01c8231a$b78c82a0$0601a8c0@ruggiero>
	<001001c8231c$04413d60$0601a8c0@ruggiero>
Message-ID: <4734E1BC.1060608@lwfinger.net>

I need some Fedora help. This new b43 user is having problems making a connection. He has a b-only
AP of unspecified make with no encryption. He is using F8 with the default kernel (I think). He has
done the following:

Ruggiero wrote:
> i used "system->adminstration>Network" and i configurated everything from 
> there...and the clicking on "activate wlan0" for a while my access point 
> communicate and in the log i see that it's connected... here are outputs:
> if i use NetworkManager i see it's connecting...but after a while i get the 
> message "disconnected"

Tail of dmesg:

> wlan0: Initial auth_alg=0
> wlan0: authenticate with AP 00:0c:41:19:2d:c1
> wlan0: authenticate with AP 00:0c:41:19:2d:c1
> wlan0: authenticate with AP 00:0c:41:19:2d:c1
> wlan0: authentication with AP 00:0c:41:19:2d:c1 timed out
> wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
> authenticate state - ignored
> wlan0: RX disassociation from 00:0c:41:19:2d:c1 (reason=4)

All the b43 messages are normal. He sees the AP with a scan, but never authenticates. Any suggestions?

Larry


From larry.finger at lwfinger.net  Fri Nov  9 23:40:44 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 16:40:44 -0600
Subject: BCM94311MCG
In-Reply-To: <001001c8231c$04413d60$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net>
	<000b01c8231a$b78c82a0$0601a8c0@ruggiero>
	<001001c8231c$04413d60$0601a8c0@ruggiero>
Message-ID: <4734E1EC.1040107@lwfinger.net>

Ruggiero wrote:
> wlan0: Initial auth_alg=0
> wlan0: authenticate with AP 00:0c:41:19:2d:c1
> wlan0: authenticate with AP 00:0c:41:19:2d:c1
> wlan0: authenticate with AP 00:0c:41:19:2d:c1
> wlan0: authentication with AP 00:0c:41:19:2d:c1 timed out
> wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
> authenticate state - ignored
> wlan0: RX disassociation from 00:0c:41:19:2d:c1 (reason=4)
> 
> i found this message too...i don't know if it can be useful
> 

One last check - Is your radio hardware switch on?

Larry



From Larry.Finger at lwfinger.net  Fri Nov  9 23:47:37 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 16:47:37 -0600
Subject: [PATCH] b43: Output message at startup if hardware switch for
	radio is off
Message-ID: <4734e389.AF3t4zZIQw1IryOf%Larry.Finger@lwfinger.net>

Now that the radio is controlled by rfkill, there is a potential
difficulty in helping a new user get started, as it is unlikely
that they will have setup rfkill. This patch prints a message if
the interface is started with the hardware switch off.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This patch is intended for the everything branch of wireless-2.6.

Larry

 main.c   |   10 +++++++---
 main.h   |    2 ++
 rfkill.c |    2 +-
 3 files changed, 10 insertions(+), 4 deletions(-)

Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -3181,11 +3181,15 @@ static void setup_struct_phy_for_init(st
 
 static void setup_struct_wldev_for_init(struct b43_wldev *dev)
 {
+	struct b43_wl *wl = dev->wl;
+
 	/* Flags */
 	dev->reg124_set_0x4 = 0;
-	/* Assume the radio is enabled. If it's not enabled, the state will
-	 * immediately get fixed on the first periodic work run. */
-	dev->radio_hw_enable = 1;
+	dev->radio_hw_enable = b43_is_hw_radio_enabled(dev);
+	if (!dev->radio_hw_enable)
+		b43info(wl, "***** The hardware switch for your radio switch"
+			" is off.\n          ***** Until it is switched on,"
+			" your device will not work.\n");
 
 	/* Stats */
 	memset(&dev->stats, 0, sizeof(dev->stats));
Index: wireless-2.6/drivers/net/wireless/b43/main.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.h
+++ wireless-2.6/drivers/net/wireless/b43/main.h
@@ -116,6 +116,8 @@ void b43_mac_enable(struct b43_wldev *de
 
 void b43_controller_restart(struct b43_wldev *dev, const char *reason);
 
+bool b43_is_hw_radio_enabled(struct b43_wldev *dev);
+
 #define B43_PS_ENABLED	(1 << 0)	/* Force enable hardware power saving */
 #define B43_PS_DISABLED	(1 << 1)	/* Force disable hardware power saving */
 #define B43_PS_AWAKE	(1 << 2)	/* Force device awake */
Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
@@ -27,7 +27,7 @@
 
 
 /* Returns TRUE, if the radio is enabled in hardware. */
-static bool b43_is_hw_radio_enabled(struct b43_wldev *dev)
+bool b43_is_hw_radio_enabled(struct b43_wldev *dev)
 {
 	if (dev->phy.rev >= 3) {
 		if (!(b43_read32(dev, B43_MMIO_RADIO_HWENABLED_HI)


From Larry.Finger at lwfinger.net  Fri Nov  9 23:53:33 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 16:53:33 -0600
Subject: [PATCH 0/6] ssb and friends: Change layout and naming of SPROM data
Message-ID: <4734E4ED.5000800@lwfinger.net>

In the various Broadcom devices that are supported, several revisions of the SPROM have been
encountered. Current code takes advantage of the fact that Revision 2 inherits all the data of
1, and that Revision 3 inherits most data from 2. This scheme breaks down with revision 4, which
does not inherit from the earlier models. In addition, the current code has an error for Rev. 3
SPROMS. In deciding how best to implement the new design, a fresh approach is warranted.
Furthermore, we decided not to include any SPROM variables not used in the supported drivers (b44,
b43 and b43legacy). To keep the patches small while preserving compilation and correct execution
during bisection, the change has been split into the following pieces:

1. Introduce new structure while maintaining the old.
2. Convert the ssb module to the new structure.
3. Convert the b44 driver.
4. Convert b43.
5. convert b43legacy.
6. Remove the old structures from ssb.

Larry




From Larry.Finger at lwfinger.net  Fri Nov  9 23:54:45 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 16:54:45 -0600
Subject: [PATCH 1/ 6] ssb: Add new SPROM structure while keeping the old
Message-ID: <4734e535.rVgJmrUgOzACE+vZ%Larry.Finger@lwfinger.net>

This is patch 1 of 6.

The SPROM's for various devices utilizing the Sonics Silicon Backplane come
with various revisions. The Revision 2 SPROM inherited the data layout of 1, and
Revision 3 inherited the layout of 2. The first instance of Revision 4 has
now been found in a BCM4328 wireless LAN card. This device does not inherit any
layout from previous versions. Although it was possible to create a data
structure that kept all the old layouts, we decided to start fresh, keep only
those SPROM variables that are used by the drivers that utilize ssb, and to
do the conversion in such a manner that neither compilation or execution will
be affected if a bisection lands in the middle of these changes, while keeping
the patches as small as possible.

In this patch, the sprom structures are changed while maintaining the old ones.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/include/linux/ssb/ssb.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb.h
+++ wireless-2.6/include/linux/ssb/ssb.h
@@ -78,13 +78,34 @@ struct ssb_sprom_r3 {
 	u32 ofdmgpo;		/* G-PHY OFDM Power Offset */
 };
 
-struct ssb_sprom_r4 {
-	/* TODO */
-};
-
 struct ssb_sprom {
 	u8 revision;
-	u8 crc;
+	u8 temp_fill[2 * sizeof(struct ssb_sprom_r1)];
+	u8 il0mac[6];		/* MAC address for 802.11b/g */
+	u8 et0mac[6];		/* MAC address for Ethernet */
+	u8 et1mac[6];		/* MAC address for 802.11a */
+	u8 et0phyaddr;		/* MII address for enet0 */
+	u8 et1phyaddr;		/* MII address for enet1 */
+	u8 country_code;	/* Country Code */
+	u16 pa0b0;
+	u16 pa0b1;
+	u16 pa0b2;
+	u16 pa1b0;
+	u16 pa1b1;
+	u16 pa1b2;
+	u8 gpio0;		/* GPIO pin 0 */
+	u8 gpio1;		/* GPIO pin 1 */
+	u8 gpio2;		/* GPIO pin 2 */
+	u8 gpio3;		/* GPIO pin 3 */
+	u16 maxpwr_a;		/* A-PHY Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_bg;		/* B/G-PHY Amplifier Max Power (in dBm Q5.2) */
+	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
+	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
+	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
+	u8 antenna_gain_a;	/* A-PHY Antenna gain (in dBm Q5.2) */
+	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
+
+	/* TODO - add any parameters needed from rev 2, 3, or 4 SPROMs */
 	/* The valid r# fields are selected by the "revision".
 	 * Revision 3 and lower inherit from lower revisions.
 	 */
@@ -94,7 +115,6 @@ struct ssb_sprom {
 			struct ssb_sprom_r2 r2;
 			struct ssb_sprom_r3 r3;
 		};
-		struct ssb_sprom_r4 r4;
 	};
 };
 
Index: wireless-2.6/include/linux/ssb/ssb_regs.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb_regs.h
+++ wireless-2.6/include/linux/ssb/ssb_regs.h
@@ -250,6 +250,38 @@
 #define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
 #define  SSB_SPROM3_CCKPO_11M_SHIFT	12
 #define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
+/* SPROM Revision 4 */
+#define SSB_SPROM4_IL0MAC		0x104C	/* 6 byte MAC address for b/g */
+#define SSB_SPROM4_ETHPHY		0x105A	/* Ethernet PHY settings */
+#define  SSB_SPROM4_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
+#define  SSB_SPROM4_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
+#define  SSB_SPROM4_ETHPHY_ET1A_SHIFT	5
+#define  SSB_SPROM4_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
+#define  SSB_SPROM4_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
+#define SSB_SPROM4_CCODE		0x1052	/* Country Code (2 bytes) */
+#define SSB_SPROM4_ANT_A		0x105D  /* A Antennas */
+#define SSB_SPROM4_ANT_BG		0x105C  /* B/G Antennas */
+#define SSB_SPROM4_BFLLO		0x1044	/* Boardflags (low 16 bits) */
+#define SSB_SPROM4_AGAIN		0x105E	/* Antenna Gain (in dBm Q5.2) */
+#define SSB_SPROM4_BFLHI		0x1046  /* Board Flags Hi */
+#define SSB_SPROM4_MAXP_A		0x1000  /* Max Power A */
+#define SSB_SPROM4_MAXP_A_HI		0x00FF  /* Mask for Hi */
+#define SSB_SPROM4_MAXP_A_LO		0xFF00  /* Mask for Lo */
+#define SSB_SPROM4_MAXP_A_LO_SHIFT	16	/* Shift for Lo */
+#define SSB_SPROM4_PA1LOB0		0x1000
+#define SSB_SPROM4_PA1LOB1		0x1000
+#define SSB_SPROM4_PA1LOB2		0x1000
+#define SSB_SPROM4_PA1HIB0		0x1000
+#define SSB_SPROM4_PA1HIB1		0x1000
+#define SSB_SPROM4_PA1HIB2		0x1000
+#define SSB_SPROM4_OPO			0x1000
+#define SSB_SPROM4_OPO_VALUE		0x0000
+#define SSB_SPROM4_GPIOLDC		0x105A	/* LED Powersave Duty Cycle */
+#define  SSB_SPROM4_GPIOLDC_OFF		0x0000FF00	/* Off Count */
+#define  SSB_SPROM4_GPIOLDC_OFF_SHIFT	8
+#define  SSB_SPROM4_GPIOLDC_ON		0x00FF0000	/* On Count */
+#define  SSB_SPROM4_GPIOLDC_ON_SHIFT	16
+
 
 /* Values for SSB_SPROM1_BINF_CCODE */
 enum {
Index: wireless-2.6/drivers/ssb/pci.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/pci.c
+++ wireless-2.6/drivers/ssb/pci.c
@@ -423,8 +423,6 @@ static int sprom_extract(struct ssb_bus 
 	memset(out, 0, sizeof(*out));
 
 	SPEX(revision, SSB_SPROM_REVISION, SSB_SPROM_REVISION_REV, 0);
-	SPEX(crc, SSB_SPROM_REVISION, SSB_SPROM_REVISION_CRC,
-	     SSB_SPROM_REVISION_CRC_SHIFT);
 
 	if ((bus->chip_id & 0xFF00) == 0x4400) {
 		/* Workaround: The BCM44XX chip has a stupid revision


From Larry.Finger at lwfinger.net  Fri Nov  9 23:55:21 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 16:55:21 -0600
Subject: [PATCH 1/ 6] ssb: Convert to use of the new SPROM structure
Message-ID: <4734e559.iN+PqOZ8cjP4xpyq%Larry.Finger@lwfinger.net>

Patch 2 of 6:

In disagreement with the SPROM specs, revision 3 devices appear to have
moved the MAC address.

Change ssb to handle the revision 4 SPROM, which is a different size.
This change in size is handled by adding a new variable to the ssb_sprom
struct and using it whenever possible. For those routines that do not
have access to this structure, a 'u16 size' argument is added.

The new PCI_ID for the BCM4328 is also added.

Testing of the Revision 4 SPROM, which is used on the BCM4328, was done
by Michael Gerdau <mgerdau at tiscali.de>.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/drivers/ssb/pci.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/pci.c
+++ wireless-2.6/drivers/ssb/pci.c
@@ -212,29 +212,29 @@ static inline u8 ssb_crc8(u8 crc, u8 dat
 	return t[crc ^ data];
 }
 
-static u8 ssb_sprom_crc(const u16 *sprom)
+static u8 ssb_sprom_crc(const u16 *sprom, u16 size)
 {
 	int word;
 	u8 crc = 0xFF;
 
-	for (word = 0; word < SSB_SPROMSIZE_WORDS - 1; word++) {
+	for (word = 0; word < size - 1; word++) {
 		crc = ssb_crc8(crc, sprom[word] & 0x00FF);
 		crc = ssb_crc8(crc, (sprom[word] & 0xFF00) >> 8);
 	}
-	crc = ssb_crc8(crc, sprom[SPOFF(SSB_SPROM_REVISION)] & 0x00FF);
+	crc = ssb_crc8(crc, sprom[size - 1] & 0x00FF);
 	crc ^= 0xFF;
 
 	return crc;
 }
 
-static int sprom_check_crc(const u16 *sprom)
+static int sprom_check_crc(const u16 *sprom, u16 size)
 {
 	u8 crc;
 	u8 expected_crc;
 	u16 tmp;
 
-	crc = ssb_sprom_crc(sprom);
-	tmp = sprom[SPOFF(SSB_SPROM_REVISION)] & SSB_SPROM_REVISION_CRC;
+	crc = ssb_sprom_crc(sprom, size);
+	tmp = sprom[size - 1] & SSB_SPROM_REVISION_CRC;
 	expected_crc = tmp >> SSB_SPROM_REVISION_CRC_SHIFT;
 	if (crc != expected_crc)
 		return -EPROTO;
@@ -246,7 +246,7 @@ static void sprom_do_read(struct ssb_bus
 {
 	int i;
 
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++)
+	for (i = 0; i < bus->sprom_size; i++)
 		sprom[i] = readw(bus->mmio + SSB_SPROM_BASE + (i * 2));
 }
 
@@ -255,6 +255,7 @@ static int sprom_do_write(struct ssb_bus
 	struct pci_dev *pdev = bus->host_pci;
 	int i, err;
 	u32 spromctl;
+	u16 size = bus->sprom_size;
 
 	ssb_printk(KERN_NOTICE PFX "Writing SPROM. Do NOT turn off the power! Please stand by...\n");
 	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
@@ -266,12 +267,12 @@ static int sprom_do_write(struct ssb_bus
 		goto err_ctlreg;
 	ssb_printk(KERN_NOTICE PFX "[ 0%%");
 	msleep(500);
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
-		if (i == SSB_SPROMSIZE_WORDS / 4)
+	for (i = 0; i < size; i++) {
+		if (i == size / 4)
 			ssb_printk("25%%");
-		else if (i == SSB_SPROMSIZE_WORDS / 2)
+		else if (i == size / 2)
 			ssb_printk("50%%");
-		else if (i == (SSB_SPROMSIZE_WORDS / 4) * 3)
+		else if (i == (size * 3) / 4)
 			ssb_printk("75%%");
 		else if (i % 2)
 			ssb_printk(".");
@@ -350,95 +351,120 @@ static void sprom_extract_r1(struct ssb_
 	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
 	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
 	     SSB_SPROM1_AGAIN_BG_SHIFT);
-	for (i = 0; i < 4; i++) {
-		v = in[SPOFF(SSB_SPROM1_OEM) + i];
-		*(((__le16 *)out->oem) + i) = cpu_to_le16(v);
-	}
 }
 
-static void sprom_extract_r2(struct ssb_sprom_r2 *out, const u16 *in)
+static void sprom_extract_r123(struct ssb_sprom *out, const u16 *in)
 {
 	int i;
 	u16 v;
+	u16 loc[3];
 
-	SPEX(boardflags_hi, SSB_SPROM2_BFLHI,  0xFFFF, 0);
-	SPEX(maxpwr_a_hi, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_HI, 0);
-	SPEX(maxpwr_a_lo, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_LO,
-	     SSB_SPROM2_MAXP_A_LO_SHIFT);
-	SPEX(pa1lob0, SSB_SPROM2_PA1LOB0, 0xFFFF, 0);
-	SPEX(pa1lob1, SSB_SPROM2_PA1LOB1, 0xFFFF, 0);
-	SPEX(pa1lob2, SSB_SPROM2_PA1LOB2, 0xFFFF, 0);
-	SPEX(pa1hib0, SSB_SPROM2_PA1HIB0, 0xFFFF, 0);
-	SPEX(pa1hib1, SSB_SPROM2_PA1HIB1, 0xFFFF, 0);
-	SPEX(pa1hib2, SSB_SPROM2_PA1HIB2, 0xFFFF, 0);
-	SPEX(ofdm_pwr_off, SSB_SPROM2_OPO, SSB_SPROM2_OPO_VALUE, 0);
-	for (i = 0; i < 4; i++) {
-		v = in[SPOFF(SSB_SPROM2_CCODE) + i];
-		*(((__le16 *)out->country_str) + i) = cpu_to_le16(v);
+	if (out->revision == 3) {			/* rev 3 moved MAC */
+		loc[0] = SSB_SPROM3_IL0MAC;
+		loc[1] = SSB_SPROM3_ET0MAC;
+		loc[2] = SSB_SPROM3_ET1MAC;
+	} else {
+		loc[0] = SSB_SPROM1_IL0MAC;
+		loc[1] = SSB_SPROM1_ET0MAC;
+		loc[2] = SSB_SPROM1_ET1MAC;
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(loc[0]) + i];
+		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(loc[1]) + i];
+		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(loc[2]) + i];
+		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
 	}
+	SPEX(et0phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0A, 0);
+	SPEX(et1phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1A,
+	     SSB_SPROM1_ETHPHY_ET1A_SHIFT);
+	SPEX(country_code, SSB_SPROM1_BINF, SSB_SPROM1_BINF_CCODE,
+	     SSB_SPROM1_BINF_CCODE_SHIFT);
+	SPEX(pa0b0, SSB_SPROM1_PA0B0, 0xFFFF, 0);
+	SPEX(pa0b1, SSB_SPROM1_PA0B1, 0xFFFF, 0);
+	SPEX(pa0b2, SSB_SPROM1_PA0B2, 0xFFFF, 0);
+	SPEX(pa1b0, SSB_SPROM1_PA1B0, 0xFFFF, 0);
+	SPEX(pa1b1, SSB_SPROM1_PA1B1, 0xFFFF, 0);
+	SPEX(pa1b2, SSB_SPROM1_PA1B2, 0xFFFF, 0);
+	SPEX(gpio0, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P0, 0);
+	SPEX(gpio1, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P1,
+	     SSB_SPROM1_GPIOA_P1_SHIFT);
+	SPEX(gpio2, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P2, 0);
+	SPEX(gpio3, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P3,
+	     SSB_SPROM1_GPIOB_P3_SHIFT);
+	SPEX(maxpwr_a, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_A,
+	     SSB_SPROM1_MAXPWR_A_SHIFT);
+	SPEX(maxpwr_bg, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_BG, 0);
+	SPEX(itssi_a, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_A,
+	     SSB_SPROM1_ITSSI_A_SHIFT);
+	SPEX(itssi_bg, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_BG, 0);
+	SPEX(boardflags_lo, SSB_SPROM1_BFLLO, 0xFFFF, 0);
+	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
+	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
+	     SSB_SPROM1_AGAIN_BG_SHIFT);
 }
 
-static void sprom_extract_r3(struct ssb_sprom_r3 *out, const u16 *in)
-{
-	out->ofdmapo  = (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0xFF00) >> 8;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0x00FF) << 8;
-	out->ofdmapo <<= 16;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0xFF00) >> 8;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0x00FF) << 8;
-
-	out->ofdmalpo  = (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0xFF00) >> 8;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0x00FF) << 8;
-	out->ofdmalpo <<= 16;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0xFF00) >> 8;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0x00FF) << 8;
-
-	out->ofdmahpo  = (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0xFF00) >> 8;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0x00FF) << 8;
-	out->ofdmahpo <<= 16;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0xFF00) >> 8;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0x00FF) << 8;
-
-	SPEX(gpioldc_on_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_ON,
-	     SSB_SPROM3_GPIOLDC_ON_SHIFT);
-	SPEX(gpioldc_off_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_OFF,
-	     SSB_SPROM3_GPIOLDC_OFF_SHIFT);
-	SPEX(cckpo_1M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_1M, 0);
-	SPEX(cckpo_2M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_2M,
-	     SSB_SPROM3_CCKPO_2M_SHIFT);
-	SPEX(cckpo_55M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_55M,
-	     SSB_SPROM3_CCKPO_55M_SHIFT);
-	SPEX(cckpo_11M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_11M,
-	     SSB_SPROM3_CCKPO_11M_SHIFT);
-
-	out->ofdmgpo  = (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0xFF00) >> 8;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0x00FF) << 8;
-	out->ofdmgpo <<= 16;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0xFF00) >> 8;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0x00FF) << 8;
+static void sprom_extract_r4(struct ssb_sprom *out, const u16 *in)
+{
+	int i;
+	u16 v;
+
+	/* extract the r1 variables */
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM4_IL0MAC) + i];
+		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM4_ET0MAC) + i];
+		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM4_ET1MAC) + i];
+		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
+	}
+	SPEX(et0phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET0A, 0);
+	SPEX(et1phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET1A,
+	     SSB_SPROM4_ETHPHY_ET1A_SHIFT);
+	SPEX(country_code, SSB_SPROM4_CCODE, 0xFFFF, 0);
+	SPEX(boardflags_lo, SSB_SPROM4_BFLLO, 0xFFFF, 0);
+	SPEX(antenna_gain_a, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_0, 0);
+	SPEX(antenna_gain_bg, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_1,
+	     SSB_SPROM4_AGAIN_1_SHIFT);
+	/* TODO - get remaining rev 4 stuff needed */
 }
 
-static int sprom_extract(struct ssb_bus *bus,
-			 struct ssb_sprom *out, const u16 *in)
+static int sprom_extract(struct ssb_bus *bus, struct ssb_sprom *out,
+			 const u16 *in, u16 size)
 {
 	memset(out, 0, sizeof(*out));
 
-	SPEX(revision, SSB_SPROM_REVISION, SSB_SPROM_REVISION_REV, 0);
-
+	out->revision = in[size - 1] & 0x00FF;
 	if ((bus->chip_id & 0xFF00) == 0x4400) {
 		/* Workaround: The BCM44XX chip has a stupid revision
 		 * number stored in the SPROM.
 		 * Always extract r1. */
+		out->revision = 1;
+		sprom_extract_r123(out, in);
 		sprom_extract_r1(&out->r1, in);
+	} else if (bus->chip_id == 0x4321) {
+		/* the BCM4328 has a chipid == 0x4321 and a rev 4 SPROM */
+		out->revision = 4;
+		sprom_extract_r4(out, in);
 	} else {
 		if (out->revision == 0)
 			goto unsupported;
-		if (out->revision >= 1 && out->revision <= 3)
+		if (out->revision >= 1 && out->revision <= 3) {
+			sprom_extract_r123(out, in, out->revision);
 			sprom_extract_r1(&out->r1, in);
-		if (out->revision >= 2 && out->revision <= 3)
-			sprom_extract_r2(&out->r2, in);
-		if (out->revision == 3)
-			sprom_extract_r3(&out->r3, in);
-		if (out->revision >= 4)
+		}
+		if (out->revision == 4)
+			sprom_extract_r4(out, in);
+		if (out->revision >= 5)
 			goto unsupported;
 	}
 
@@ -456,16 +482,31 @@ static int ssb_pci_sprom_get(struct ssb_
 	int err = -ENOMEM;
 	u16 *buf;
 
-	buf = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	buf = kcalloc(SSB_SPROMSIZE_WORDS_R123, sizeof(u16), GFP_KERNEL);
 	if (!buf)
 		goto out;
+	bus->sprom_size = SSB_SPROMSIZE_WORDS_R123;
 	sprom_do_read(bus, buf);
-	err = sprom_check_crc(buf);
+	err = sprom_check_crc(buf, bus->sprom_size);
 	if (err) {
-		ssb_printk(KERN_WARNING PFX
-			   "WARNING: Invalid SPROM CRC (corrupt SPROM)\n");
+		/* check for rev 4 sprom - has special signature */
+		if (buf [32] == 0x5372) {
+			ssb_printk(KERN_WARNING PFX "Extracting a rev 4"
+				   " SPROM\n");
+			kfree(buf);
+			buf = kcalloc(SSB_SPROMSIZE_WORDS_R4, sizeof(u16),
+				      GFP_KERNEL);
+			if (!buf)
+				goto out;
+			bus->sprom_size = SSB_SPROMSIZE_WORDS_R4;
+			sprom_do_read(bus, buf);
+			err = sprom_check_crc(buf, bus->sprom_size);
+		}
+		if (err)
+			ssb_printk(KERN_WARNING PFX "WARNING: Invalid"
+				   " SPROM CRC (corrupt SPROM)\n");
 	}
-	err = sprom_extract(bus, sprom, buf);
+	err = sprom_extract(bus, sprom, buf, bus->sprom_size);
 
 	kfree(buf);
 out:
@@ -579,29 +620,28 @@ const struct ssb_bus_ops ssb_pci_ops = {
 	.write32	= ssb_pci_write32,
 };
 
-static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len)
+static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len, u16 size)
 {
 	int i, pos = 0;
 
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
+	for (i = 0; i < size; i++)
 		pos += snprintf(buf + pos, buf_len - pos - 1,
 				"%04X", swab16(sprom[i]) & 0xFFFF);
-	}
 	pos += snprintf(buf + pos, buf_len - pos - 1, "\n");
 
 	return pos + 1;
 }
 
-static int hex2sprom(u16 *sprom, const char *dump, size_t len)
+static int hex2sprom(u16 *sprom, const char *dump, size_t len, u16 size)
 {
 	char tmp[5] = { 0 };
 	int cnt = 0;
 	unsigned long parsed;
 
-	if (len < SSB_SPROMSIZE_BYTES * 2)
+	if (len < size * 2)
 		return -EINVAL;
 
-	while (cnt < SSB_SPROMSIZE_WORDS) {
+	while (cnt < size) {
 		memcpy(tmp, dump, 4);
 		dump += 4;
 		parsed = simple_strtoul(tmp, NULL, 16);
@@ -625,7 +665,7 @@ static ssize_t ssb_pci_attr_sprom_show(s
 	if (!bus)
 		goto out;
 	err = -ENOMEM;
-	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	sprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);
 	if (!sprom)
 		goto out;
 
@@ -638,7 +678,7 @@ static ssize_t ssb_pci_attr_sprom_show(s
 	sprom_do_read(bus, sprom);
 	mutex_unlock(&bus->pci_sprom_mutex);
 
-	count = sprom2hex(sprom, buf, PAGE_SIZE);
+	count = sprom2hex(sprom, buf, PAGE_SIZE, bus->sprom_size);
 	err = 0;
 
 out_kfree:
@@ -660,15 +700,15 @@ static ssize_t ssb_pci_attr_sprom_store(
 	if (!bus)
 		goto out;
 	err = -ENOMEM;
-	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	sprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);
 	if (!sprom)
 		goto out;
-	err = hex2sprom(sprom, buf, count);
+	err = hex2sprom(sprom, buf, count, bus->sprom_size);
 	if (err) {
 		err = -EINVAL;
 		goto out_kfree;
 	}
-	err = sprom_check_crc(sprom);
+	err = sprom_check_crc(sprom, bus->sprom_size);
 	if (err) {
 		err = -EINVAL;
 		goto out_kfree;
Index: wireless-2.6/drivers/ssb/main.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/main.c
+++ wireless-2.6/drivers/ssb/main.c
@@ -872,14 +872,22 @@ EXPORT_SYMBOL(ssb_clockspeed);
 
 static u32 ssb_tmslow_reject_bitmask(struct ssb_device *dev)
 {
+	u32 rev = ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV;
+
 	/* The REJECT bit changed position in TMSLOW between
 	 * Backplane revisions. */
-	switch (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV) {
+	switch (rev) {
 	case SSB_IDLOW_SSBREV_22:
 		return SSB_TMSLOW_REJECT_22;
 	case SSB_IDLOW_SSBREV_23:
 		return SSB_TMSLOW_REJECT_23;
+	case SSB_IDLOW_SSBREV_24:     /* TODO - find the proper REJECT bits */
+	case SSB_IDLOW_SSBREV_25:     /* same here */
+	case SSB_IDLOW_SSBREV_26:     /* same here */
+	case SSB_IDLOW_SSBREV_27:     /* same here */
+		return SSB_TMSLOW_REJECT_23;	/* this is a guess */
 	default:
+		printk(KERN_INFO "ssb: Backplane Revision 0x%.8X\n", rev);
 		WARN_ON(1);
 	}
 	return (SSB_TMSLOW_REJECT_22 | SSB_TMSLOW_REJECT_23);
Index: wireless-2.6/include/linux/ssb/ssb.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb.h
+++ wireless-2.6/include/linux/ssb/ssb.h
@@ -308,6 +308,7 @@ struct ssb_bus {
 	/* ID information about the Chip. */
 	u16 chip_id;
 	u16 chip_rev;
+	u16 sprom_size;		/* number of words in sprom */
 	u8 chip_package;
 
 	/* List of devices (cores) on the backplane. */
Index: wireless-2.6/include/linux/ssb/ssb_regs.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb_regs.h
+++ wireless-2.6/include/linux/ssb/ssb_regs.h
@@ -147,6 +147,10 @@
 #define  SSB_IDLOW_SSBREV	0xF0000000 /* Sonics Backplane Revision code */
 #define  SSB_IDLOW_SSBREV_22	0x00000000 /* <= 2.2 */
 #define  SSB_IDLOW_SSBREV_23	0x10000000 /* 2.3 */
+#define  SSB_IDLOW_SSBREV_24	0x40000000 /* ?? Found in BCM4328 */
+#define  SSB_IDLOW_SSBREV_25	0x50000000 /* ?? Not Found yet */
+#define  SSB_IDLOW_SSBREV_26	0x60000000 /* ?? Found in some BCM4311/2 */
+#define  SSB_IDLOW_SSBREV_27	0x70000000 /* ?? Found in some BCM4311/2 */
 #define SSB_IDHIGH		0x0FFC     /* SB Identification High */
 #define  SSB_IDHIGH_RCLO	0x0000000F /* Revision Code (low part) */
 #define  SSB_IDHIGH_CC		0x00008FF0 /* Core Code */
@@ -162,6 +166,10 @@
  */
 #define SSB_SPROMSIZE_WORDS		64
 #define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
+#define SSB_SPROMSIZE_WORDS_R123	64
+#define SSB_SPROMSIZE_WORDS_R4		220
+#define SSB_SPROMSIZE_BYTES_R123	(SSB_SPROMSIZE_WORDS_R123 * sizeof(u16))
+#define SSB_SPROMSIZE_BYTES_R4		(SSB_SPROMSIZE_WORDS_R4 * sizeof(u16))
 #define SSB_SPROM_BASE			0x1000
 #define SSB_SPROM_REVISION		0x107E
 #define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
@@ -232,7 +240,10 @@
 #define  SSB_SPROM2_OPO_VALUE		0x00FF
 #define  SSB_SPROM2_OPO_UNUSED		0xFF00
 #define SSB_SPROM2_CCODE		0x107C	/* Two char Country Code */
-/* SPROM Revision 3 (inherits from rev 2) */
+/* SPROM Revision 3 (inherits most data from rev 2) */
+#define SSB_SPROM3_IL0MAC		0x104A	/* 6 bytes MAC address for 802.11b/g */
+#define SSB_SPROM3_ET0MAC		0x1050	/* 6 bytes MAC address for Ethernet ?? */
+#define SSB_SPROM3_ET1MAC		0x1050	/* 6 bytes MAC address for 802.11a ?? */
 #define SSB_SPROM3_OFDMAPO		0x102C	/* A-PHY OFDM Mid Power Offset (4 bytes, BigEndian) */
 #define SSB_SPROM3_OFDMALPO		0x1030	/* A-PHY OFDM Low Power Offset (4 bytes, BigEndian) */
 #define SSB_SPROM3_OFDMAHPO		0x1034	/* A-PHY OFDM High Power Offset (4 bytes, BigEndian) */
@@ -250,8 +261,10 @@
 #define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
 #define  SSB_SPROM3_CCKPO_11M_SHIFT	12
 #define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
-/* SPROM Revision 4 */
+/* SPROM Revision 4 		entries with ?? in comment are unknown */
 #define SSB_SPROM4_IL0MAC		0x104C	/* 6 byte MAC address for b/g */
+#define SSB_SPROM4_ET0MAC		0x1018	/* 6 bytes MAC address for Ethernet ?? */
+#define SSB_SPROM4_ET1MAC		0x1018	/* 6 bytes MAC address for 802.11a ?? */
 #define SSB_SPROM4_ETHPHY		0x105A	/* Ethernet PHY settings */
 #define  SSB_SPROM4_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
 #define  SSB_SPROM4_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
@@ -263,19 +276,22 @@
 #define SSB_SPROM4_ANT_BG		0x105C  /* B/G Antennas */
 #define SSB_SPROM4_BFLLO		0x1044	/* Boardflags (low 16 bits) */
 #define SSB_SPROM4_AGAIN		0x105E	/* Antenna Gain (in dBm Q5.2) */
+#define  SSB_SPROM4_AGAIN_0		0x00FF	/* Antenna 0 */
+#define  SSB_SPROM4_AGAIN_1		0xFF00	/* Antenna 1 */
+#define  SSB_SPROM4_AGAIN_1_SHIFT	8
 #define SSB_SPROM4_BFLHI		0x1046  /* Board Flags Hi */
-#define SSB_SPROM4_MAXP_A		0x1000  /* Max Power A */
+#define SSB_SPROM4_MAXP_A		0x1000  /* Max Power A ?? */
 #define SSB_SPROM4_MAXP_A_HI		0x00FF  /* Mask for Hi */
 #define SSB_SPROM4_MAXP_A_LO		0xFF00  /* Mask for Lo */
 #define SSB_SPROM4_MAXP_A_LO_SHIFT	16	/* Shift for Lo */
-#define SSB_SPROM4_PA1LOB0		0x1000
-#define SSB_SPROM4_PA1LOB1		0x1000
-#define SSB_SPROM4_PA1LOB2		0x1000
-#define SSB_SPROM4_PA1HIB0		0x1000
-#define SSB_SPROM4_PA1HIB1		0x1000
-#define SSB_SPROM4_PA1HIB2		0x1000
-#define SSB_SPROM4_OPO			0x1000
-#define SSB_SPROM4_OPO_VALUE		0x0000
+#define SSB_SPROM4_PA1LOB0		0x1000  /* ?? */
+#define SSB_SPROM4_PA1LOB1		0x1000  /* ?? */
+#define SSB_SPROM4_PA1LOB2		0x1000  /* ?? */
+#define SSB_SPROM4_PA1HIB0		0x1000	/* ?? */
+#define SSB_SPROM4_PA1HIB1		0x1000	/* ?? */
+#define SSB_SPROM4_PA1HIB2		0x1000	/* ?? */
+#define SSB_SPROM4_OPO			0x1000	/* ?? */
+#define SSB_SPROM4_OPO_VALUE		0x0000	/* ?? */
 #define SSB_SPROM4_GPIOLDC		0x105A	/* LED Powersave Duty Cycle */
 #define  SSB_SPROM4_GPIOLDC_OFF		0x0000FF00	/* Off Count */
 #define  SSB_SPROM4_GPIOLDC_OFF_SHIFT	8
Index: wireless-2.6/drivers/ssb/b43_pci_bridge.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/b43_pci_bridge.c
+++ wireless-2.6/drivers/ssb/b43_pci_bridge.c
@@ -27,6 +27,7 @@ static const struct pci_device_id b43_pc
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4321) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4324) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4325) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4328) },
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, b43_pci_bridge_tbl);


From Larry.Finger at lwfinger.net  Fri Nov  9 23:56:10 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 16:56:10 -0600
Subject: [PATCH 3/6] b44: Convert to use of the new SPROM structure
Message-ID: <4734e58a.3cN0AKWadrMywLAZ%Larry.Finger@lwfinger.net>

Patch 3 of 6.

The b44 driver is changed to use the new SPROM data structure.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/drivers/net/b44.c
===================================================================
--- wireless-2.6.orig/drivers/net/b44.c
+++ wireless-2.6/drivers/net/b44.c
@@ -2060,11 +2060,11 @@ static int __devinit b44_get_invariants(
 
 	if (sdev->bus->bustype == SSB_BUSTYPE_SSB &&
 	    instance > 1) {
-		addr = sdev->bus->sprom.r1.et1mac;
-		bp->phy_addr = sdev->bus->sprom.r1.et1phyaddr;
+		addr = sdev->bus->sprom.et1mac;
+		bp->phy_addr = sdev->bus->sprom.et1phyaddr;
 	} else {
-		addr = sdev->bus->sprom.r1.et0mac;
-		bp->phy_addr = sdev->bus->sprom.r1.et0phyaddr;
+		addr = sdev->bus->sprom.et0mac;
+		bp->phy_addr = sdev->bus->sprom.et0phyaddr;
 	}
 	memcpy(bp->dev->dev_addr, addr, 6);
 


From Larry.Finger at lwfinger.net  Fri Nov  9 23:56:25 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 16:56:25 -0600
Subject: [PATCH 2/ 6 V2] ssb: Convert to use of the new SPROM structure
Message-ID: <4734e599.kXz/XyQZDr1Vhrua%Larry.Finger@lwfinger.net>

Patch 2 of 6:

In disagreement with the SPROM specs, revision 3 devices appear to have
moved the MAC address.

Change ssb to handle the revision 4 SPROM, which is a different size.
This change in size is handled by adding a new variable to the ssb_sprom
struct and using it whenever possible. For those routines that do not
have access to this structure, a 'u16 size' argument is added.

The new PCI_ID for the BCM4328 is also added.

Testing of the Revision 4 SPROM, which is used on the BCM4328, was done
by Michael Gerdau <mgerdau at tiscali.de>.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/drivers/ssb/pci.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/pci.c
+++ wireless-2.6/drivers/ssb/pci.c
@@ -212,29 +212,29 @@ static inline u8 ssb_crc8(u8 crc, u8 dat
 	return t[crc ^ data];
 }
 
-static u8 ssb_sprom_crc(const u16 *sprom)
+static u8 ssb_sprom_crc(const u16 *sprom, u16 size)
 {
 	int word;
 	u8 crc = 0xFF;
 
-	for (word = 0; word < SSB_SPROMSIZE_WORDS - 1; word++) {
+	for (word = 0; word < size - 1; word++) {
 		crc = ssb_crc8(crc, sprom[word] & 0x00FF);
 		crc = ssb_crc8(crc, (sprom[word] & 0xFF00) >> 8);
 	}
-	crc = ssb_crc8(crc, sprom[SPOFF(SSB_SPROM_REVISION)] & 0x00FF);
+	crc = ssb_crc8(crc, sprom[size - 1] & 0x00FF);
 	crc ^= 0xFF;
 
 	return crc;
 }
 
-static int sprom_check_crc(const u16 *sprom)
+static int sprom_check_crc(const u16 *sprom, u16 size)
 {
 	u8 crc;
 	u8 expected_crc;
 	u16 tmp;
 
-	crc = ssb_sprom_crc(sprom);
-	tmp = sprom[SPOFF(SSB_SPROM_REVISION)] & SSB_SPROM_REVISION_CRC;
+	crc = ssb_sprom_crc(sprom, size);
+	tmp = sprom[size - 1] & SSB_SPROM_REVISION_CRC;
 	expected_crc = tmp >> SSB_SPROM_REVISION_CRC_SHIFT;
 	if (crc != expected_crc)
 		return -EPROTO;
@@ -246,7 +246,7 @@ static void sprom_do_read(struct ssb_bus
 {
 	int i;
 
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++)
+	for (i = 0; i < bus->sprom_size; i++)
 		sprom[i] = readw(bus->mmio + SSB_SPROM_BASE + (i * 2));
 }
 
@@ -255,6 +255,7 @@ static int sprom_do_write(struct ssb_bus
 	struct pci_dev *pdev = bus->host_pci;
 	int i, err;
 	u32 spromctl;
+	u16 size = bus->sprom_size;
 
 	ssb_printk(KERN_NOTICE PFX "Writing SPROM. Do NOT turn off the power! Please stand by...\n");
 	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
@@ -266,12 +267,12 @@ static int sprom_do_write(struct ssb_bus
 		goto err_ctlreg;
 	ssb_printk(KERN_NOTICE PFX "[ 0%%");
 	msleep(500);
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
-		if (i == SSB_SPROMSIZE_WORDS / 4)
+	for (i = 0; i < size; i++) {
+		if (i == size / 4)
 			ssb_printk("25%%");
-		else if (i == SSB_SPROMSIZE_WORDS / 2)
+		else if (i == size / 2)
 			ssb_printk("50%%");
-		else if (i == (SSB_SPROMSIZE_WORDS / 4) * 3)
+		else if (i == (size * 3) / 4)
 			ssb_printk("75%%");
 		else if (i % 2)
 			ssb_printk(".");
@@ -350,95 +351,120 @@ static void sprom_extract_r1(struct ssb_
 	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
 	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
 	     SSB_SPROM1_AGAIN_BG_SHIFT);
-	for (i = 0; i < 4; i++) {
-		v = in[SPOFF(SSB_SPROM1_OEM) + i];
-		*(((__le16 *)out->oem) + i) = cpu_to_le16(v);
-	}
 }
 
-static void sprom_extract_r2(struct ssb_sprom_r2 *out, const u16 *in)
+static void sprom_extract_r123(struct ssb_sprom *out, const u16 *in)
 {
 	int i;
 	u16 v;
+	u16 loc[3];
 
-	SPEX(boardflags_hi, SSB_SPROM2_BFLHI,  0xFFFF, 0);
-	SPEX(maxpwr_a_hi, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_HI, 0);
-	SPEX(maxpwr_a_lo, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_LO,
-	     SSB_SPROM2_MAXP_A_LO_SHIFT);
-	SPEX(pa1lob0, SSB_SPROM2_PA1LOB0, 0xFFFF, 0);
-	SPEX(pa1lob1, SSB_SPROM2_PA1LOB1, 0xFFFF, 0);
-	SPEX(pa1lob2, SSB_SPROM2_PA1LOB2, 0xFFFF, 0);
-	SPEX(pa1hib0, SSB_SPROM2_PA1HIB0, 0xFFFF, 0);
-	SPEX(pa1hib1, SSB_SPROM2_PA1HIB1, 0xFFFF, 0);
-	SPEX(pa1hib2, SSB_SPROM2_PA1HIB2, 0xFFFF, 0);
-	SPEX(ofdm_pwr_off, SSB_SPROM2_OPO, SSB_SPROM2_OPO_VALUE, 0);
-	for (i = 0; i < 4; i++) {
-		v = in[SPOFF(SSB_SPROM2_CCODE) + i];
-		*(((__le16 *)out->country_str) + i) = cpu_to_le16(v);
+	if (out->revision == 3) {			/* rev 3 moved MAC */
+		loc[0] = SSB_SPROM3_IL0MAC;
+		loc[1] = SSB_SPROM3_ET0MAC;
+		loc[2] = SSB_SPROM3_ET1MAC;
+	} else {
+		loc[0] = SSB_SPROM1_IL0MAC;
+		loc[1] = SSB_SPROM1_ET0MAC;
+		loc[2] = SSB_SPROM1_ET1MAC;
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(loc[0]) + i];
+		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(loc[1]) + i];
+		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(loc[2]) + i];
+		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
 	}
+	SPEX(et0phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0A, 0);
+	SPEX(et1phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1A,
+	     SSB_SPROM1_ETHPHY_ET1A_SHIFT);
+	SPEX(country_code, SSB_SPROM1_BINF, SSB_SPROM1_BINF_CCODE,
+	     SSB_SPROM1_BINF_CCODE_SHIFT);
+	SPEX(pa0b0, SSB_SPROM1_PA0B0, 0xFFFF, 0);
+	SPEX(pa0b1, SSB_SPROM1_PA0B1, 0xFFFF, 0);
+	SPEX(pa0b2, SSB_SPROM1_PA0B2, 0xFFFF, 0);
+	SPEX(pa1b0, SSB_SPROM1_PA1B0, 0xFFFF, 0);
+	SPEX(pa1b1, SSB_SPROM1_PA1B1, 0xFFFF, 0);
+	SPEX(pa1b2, SSB_SPROM1_PA1B2, 0xFFFF, 0);
+	SPEX(gpio0, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P0, 0);
+	SPEX(gpio1, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P1,
+	     SSB_SPROM1_GPIOA_P1_SHIFT);
+	SPEX(gpio2, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P2, 0);
+	SPEX(gpio3, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P3,
+	     SSB_SPROM1_GPIOB_P3_SHIFT);
+	SPEX(maxpwr_a, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_A,
+	     SSB_SPROM1_MAXPWR_A_SHIFT);
+	SPEX(maxpwr_bg, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_BG, 0);
+	SPEX(itssi_a, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_A,
+	     SSB_SPROM1_ITSSI_A_SHIFT);
+	SPEX(itssi_bg, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_BG, 0);
+	SPEX(boardflags_lo, SSB_SPROM1_BFLLO, 0xFFFF, 0);
+	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
+	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
+	     SSB_SPROM1_AGAIN_BG_SHIFT);
 }
 
-static void sprom_extract_r3(struct ssb_sprom_r3 *out, const u16 *in)
-{
-	out->ofdmapo  = (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0xFF00) >> 8;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0x00FF) << 8;
-	out->ofdmapo <<= 16;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0xFF00) >> 8;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0x00FF) << 8;
-
-	out->ofdmalpo  = (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0xFF00) >> 8;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0x00FF) << 8;
-	out->ofdmalpo <<= 16;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0xFF00) >> 8;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0x00FF) << 8;
-
-	out->ofdmahpo  = (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0xFF00) >> 8;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0x00FF) << 8;
-	out->ofdmahpo <<= 16;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0xFF00) >> 8;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0x00FF) << 8;
-
-	SPEX(gpioldc_on_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_ON,
-	     SSB_SPROM3_GPIOLDC_ON_SHIFT);
-	SPEX(gpioldc_off_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_OFF,
-	     SSB_SPROM3_GPIOLDC_OFF_SHIFT);
-	SPEX(cckpo_1M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_1M, 0);
-	SPEX(cckpo_2M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_2M,
-	     SSB_SPROM3_CCKPO_2M_SHIFT);
-	SPEX(cckpo_55M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_55M,
-	     SSB_SPROM3_CCKPO_55M_SHIFT);
-	SPEX(cckpo_11M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_11M,
-	     SSB_SPROM3_CCKPO_11M_SHIFT);
-
-	out->ofdmgpo  = (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0xFF00) >> 8;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0x00FF) << 8;
-	out->ofdmgpo <<= 16;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0xFF00) >> 8;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0x00FF) << 8;
+static void sprom_extract_r4(struct ssb_sprom *out, const u16 *in)
+{
+	int i;
+	u16 v;
+
+	/* extract the r1 variables */
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM4_IL0MAC) + i];
+		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM4_ET0MAC) + i];
+		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM4_ET1MAC) + i];
+		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
+	}
+	SPEX(et0phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET0A, 0);
+	SPEX(et1phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET1A,
+	     SSB_SPROM4_ETHPHY_ET1A_SHIFT);
+	SPEX(country_code, SSB_SPROM4_CCODE, 0xFFFF, 0);
+	SPEX(boardflags_lo, SSB_SPROM4_BFLLO, 0xFFFF, 0);
+	SPEX(antenna_gain_a, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_0, 0);
+	SPEX(antenna_gain_bg, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_1,
+	     SSB_SPROM4_AGAIN_1_SHIFT);
+	/* TODO - get remaining rev 4 stuff needed */
 }
 
-static int sprom_extract(struct ssb_bus *bus,
-			 struct ssb_sprom *out, const u16 *in)
+static int sprom_extract(struct ssb_bus *bus, struct ssb_sprom *out,
+			 const u16 *in, u16 size)
 {
 	memset(out, 0, sizeof(*out));
 
-	SPEX(revision, SSB_SPROM_REVISION, SSB_SPROM_REVISION_REV, 0);
-
+	out->revision = in[size - 1] & 0x00FF;
 	if ((bus->chip_id & 0xFF00) == 0x4400) {
 		/* Workaround: The BCM44XX chip has a stupid revision
 		 * number stored in the SPROM.
 		 * Always extract r1. */
+		out->revision = 1;
+		sprom_extract_r123(out, in);
 		sprom_extract_r1(&out->r1, in);
+	} else if (bus->chip_id == 0x4321) {
+		/* the BCM4328 has a chipid == 0x4321 and a rev 4 SPROM */
+		out->revision = 4;
+		sprom_extract_r4(out, in);
 	} else {
 		if (out->revision == 0)
 			goto unsupported;
-		if (out->revision >= 1 && out->revision <= 3)
+		if (out->revision >= 1 && out->revision <= 3) {
+			sprom_extract_r123(out, in, out->revision);
 			sprom_extract_r1(&out->r1, in);
-		if (out->revision >= 2 && out->revision <= 3)
-			sprom_extract_r2(&out->r2, in);
-		if (out->revision == 3)
-			sprom_extract_r3(&out->r3, in);
-		if (out->revision >= 4)
+		}
+		if (out->revision == 4)
+			sprom_extract_r4(out, in);
+		if (out->revision >= 5)
 			goto unsupported;
 	}
 
@@ -456,16 +482,31 @@ static int ssb_pci_sprom_get(struct ssb_
 	int err = -ENOMEM;
 	u16 *buf;
 
-	buf = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	buf = kcalloc(SSB_SPROMSIZE_WORDS_R123, sizeof(u16), GFP_KERNEL);
 	if (!buf)
 		goto out;
+	bus->sprom_size = SSB_SPROMSIZE_WORDS_R123;
 	sprom_do_read(bus, buf);
-	err = sprom_check_crc(buf);
+	err = sprom_check_crc(buf, bus->sprom_size);
 	if (err) {
-		ssb_printk(KERN_WARNING PFX
-			   "WARNING: Invalid SPROM CRC (corrupt SPROM)\n");
+		/* check for rev 4 sprom - has special signature */
+		if (buf [32] == 0x5372) {
+			ssb_printk(KERN_WARNING PFX "Extracting a rev 4"
+				   " SPROM\n");
+			kfree(buf);
+			buf = kcalloc(SSB_SPROMSIZE_WORDS_R4, sizeof(u16),
+				      GFP_KERNEL);
+			if (!buf)
+				goto out;
+			bus->sprom_size = SSB_SPROMSIZE_WORDS_R4;
+			sprom_do_read(bus, buf);
+			err = sprom_check_crc(buf, bus->sprom_size);
+		}
+		if (err)
+			ssb_printk(KERN_WARNING PFX "WARNING: Invalid"
+				   " SPROM CRC (corrupt SPROM)\n");
 	}
-	err = sprom_extract(bus, sprom, buf);
+	err = sprom_extract(bus, sprom, buf, bus->sprom_size);
 
 	kfree(buf);
 out:
@@ -579,29 +620,28 @@ const struct ssb_bus_ops ssb_pci_ops = {
 	.write32	= ssb_pci_write32,
 };
 
-static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len)
+static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len, u16 size)
 {
 	int i, pos = 0;
 
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
+	for (i = 0; i < size; i++)
 		pos += snprintf(buf + pos, buf_len - pos - 1,
 				"%04X", swab16(sprom[i]) & 0xFFFF);
-	}
 	pos += snprintf(buf + pos, buf_len - pos - 1, "\n");
 
 	return pos + 1;
 }
 
-static int hex2sprom(u16 *sprom, const char *dump, size_t len)
+static int hex2sprom(u16 *sprom, const char *dump, size_t len, u16 size)
 {
 	char tmp[5] = { 0 };
 	int cnt = 0;
 	unsigned long parsed;
 
-	if (len < SSB_SPROMSIZE_BYTES * 2)
+	if (len < size * 2)
 		return -EINVAL;
 
-	while (cnt < SSB_SPROMSIZE_WORDS) {
+	while (cnt < size) {
 		memcpy(tmp, dump, 4);
 		dump += 4;
 		parsed = simple_strtoul(tmp, NULL, 16);
@@ -625,7 +665,7 @@ static ssize_t ssb_pci_attr_sprom_show(s
 	if (!bus)
 		goto out;
 	err = -ENOMEM;
-	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	sprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);
 	if (!sprom)
 		goto out;
 
@@ -638,7 +678,7 @@ static ssize_t ssb_pci_attr_sprom_show(s
 	sprom_do_read(bus, sprom);
 	mutex_unlock(&bus->pci_sprom_mutex);
 
-	count = sprom2hex(sprom, buf, PAGE_SIZE);
+	count = sprom2hex(sprom, buf, PAGE_SIZE, bus->sprom_size);
 	err = 0;
 
 out_kfree:
@@ -660,15 +700,15 @@ static ssize_t ssb_pci_attr_sprom_store(
 	if (!bus)
 		goto out;
 	err = -ENOMEM;
-	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	sprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);
 	if (!sprom)
 		goto out;
-	err = hex2sprom(sprom, buf, count);
+	err = hex2sprom(sprom, buf, count, bus->sprom_size);
 	if (err) {
 		err = -EINVAL;
 		goto out_kfree;
 	}
-	err = sprom_check_crc(sprom);
+	err = sprom_check_crc(sprom, bus->sprom_size);
 	if (err) {
 		err = -EINVAL;
 		goto out_kfree;
Index: wireless-2.6/drivers/ssb/main.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/main.c
+++ wireless-2.6/drivers/ssb/main.c
@@ -872,14 +872,22 @@ EXPORT_SYMBOL(ssb_clockspeed);
 
 static u32 ssb_tmslow_reject_bitmask(struct ssb_device *dev)
 {
+	u32 rev = ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV;
+
 	/* The REJECT bit changed position in TMSLOW between
 	 * Backplane revisions. */
-	switch (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV) {
+	switch (rev) {
 	case SSB_IDLOW_SSBREV_22:
 		return SSB_TMSLOW_REJECT_22;
 	case SSB_IDLOW_SSBREV_23:
 		return SSB_TMSLOW_REJECT_23;
+	case SSB_IDLOW_SSBREV_24:     /* TODO - find the proper REJECT bits */
+	case SSB_IDLOW_SSBREV_25:     /* same here */
+	case SSB_IDLOW_SSBREV_26:     /* same here */
+	case SSB_IDLOW_SSBREV_27:     /* same here */
+		return SSB_TMSLOW_REJECT_23;	/* this is a guess */
 	default:
+		printk(KERN_INFO "ssb: Backplane Revision 0x%.8X\n", rev);
 		WARN_ON(1);
 	}
 	return (SSB_TMSLOW_REJECT_22 | SSB_TMSLOW_REJECT_23);
Index: wireless-2.6/include/linux/ssb/ssb.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb.h
+++ wireless-2.6/include/linux/ssb/ssb.h
@@ -308,6 +308,7 @@ struct ssb_bus {
 	/* ID information about the Chip. */
 	u16 chip_id;
 	u16 chip_rev;
+	u16 sprom_size;		/* number of words in sprom */
 	u8 chip_package;
 
 	/* List of devices (cores) on the backplane. */
Index: wireless-2.6/include/linux/ssb/ssb_regs.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb_regs.h
+++ wireless-2.6/include/linux/ssb/ssb_regs.h
@@ -147,6 +147,10 @@
 #define  SSB_IDLOW_SSBREV	0xF0000000 /* Sonics Backplane Revision code */
 #define  SSB_IDLOW_SSBREV_22	0x00000000 /* <= 2.2 */
 #define  SSB_IDLOW_SSBREV_23	0x10000000 /* 2.3 */
+#define  SSB_IDLOW_SSBREV_24	0x40000000 /* ?? Found in BCM4328 */
+#define  SSB_IDLOW_SSBREV_25	0x50000000 /* ?? Not Found yet */
+#define  SSB_IDLOW_SSBREV_26	0x60000000 /* ?? Found in some BCM4311/2 */
+#define  SSB_IDLOW_SSBREV_27	0x70000000 /* ?? Found in some BCM4311/2 */
 #define SSB_IDHIGH		0x0FFC     /* SB Identification High */
 #define  SSB_IDHIGH_RCLO	0x0000000F /* Revision Code (low part) */
 #define  SSB_IDHIGH_CC		0x00008FF0 /* Core Code */
@@ -162,6 +166,10 @@
  */
 #define SSB_SPROMSIZE_WORDS		64
 #define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
+#define SSB_SPROMSIZE_WORDS_R123	64
+#define SSB_SPROMSIZE_WORDS_R4		220
+#define SSB_SPROMSIZE_BYTES_R123	(SSB_SPROMSIZE_WORDS_R123 * sizeof(u16))
+#define SSB_SPROMSIZE_BYTES_R4		(SSB_SPROMSIZE_WORDS_R4 * sizeof(u16))
 #define SSB_SPROM_BASE			0x1000
 #define SSB_SPROM_REVISION		0x107E
 #define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
@@ -232,7 +240,10 @@
 #define  SSB_SPROM2_OPO_VALUE		0x00FF
 #define  SSB_SPROM2_OPO_UNUSED		0xFF00
 #define SSB_SPROM2_CCODE		0x107C	/* Two char Country Code */
-/* SPROM Revision 3 (inherits from rev 2) */
+/* SPROM Revision 3 (inherits most data from rev 2) */
+#define SSB_SPROM3_IL0MAC		0x104A	/* 6 bytes MAC address for 802.11b/g */
+#define SSB_SPROM3_ET0MAC		0x1050	/* 6 bytes MAC address for Ethernet ?? */
+#define SSB_SPROM3_ET1MAC		0x1050	/* 6 bytes MAC address for 802.11a ?? */
 #define SSB_SPROM3_OFDMAPO		0x102C	/* A-PHY OFDM Mid Power Offset (4 bytes, BigEndian) */
 #define SSB_SPROM3_OFDMALPO		0x1030	/* A-PHY OFDM Low Power Offset (4 bytes, BigEndian) */
 #define SSB_SPROM3_OFDMAHPO		0x1034	/* A-PHY OFDM High Power Offset (4 bytes, BigEndian) */
@@ -250,8 +261,10 @@
 #define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
 #define  SSB_SPROM3_CCKPO_11M_SHIFT	12
 #define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
-/* SPROM Revision 4 */
+/* SPROM Revision 4 		entries with ?? in comment are unknown */
 #define SSB_SPROM4_IL0MAC		0x104C	/* 6 byte MAC address for b/g */
+#define SSB_SPROM4_ET0MAC		0x1018	/* 6 bytes MAC address for Ethernet ?? */
+#define SSB_SPROM4_ET1MAC		0x1018	/* 6 bytes MAC address for 802.11a ?? */
 #define SSB_SPROM4_ETHPHY		0x105A	/* Ethernet PHY settings */
 #define  SSB_SPROM4_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
 #define  SSB_SPROM4_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
@@ -263,19 +276,22 @@
 #define SSB_SPROM4_ANT_BG		0x105C  /* B/G Antennas */
 #define SSB_SPROM4_BFLLO		0x1044	/* Boardflags (low 16 bits) */
 #define SSB_SPROM4_AGAIN		0x105E	/* Antenna Gain (in dBm Q5.2) */
+#define  SSB_SPROM4_AGAIN_0		0x00FF	/* Antenna 0 */
+#define  SSB_SPROM4_AGAIN_1		0xFF00	/* Antenna 1 */
+#define  SSB_SPROM4_AGAIN_1_SHIFT	8
 #define SSB_SPROM4_BFLHI		0x1046  /* Board Flags Hi */
-#define SSB_SPROM4_MAXP_A		0x1000  /* Max Power A */
+#define SSB_SPROM4_MAXP_A		0x1000  /* Max Power A ?? */
 #define SSB_SPROM4_MAXP_A_HI		0x00FF  /* Mask for Hi */
 #define SSB_SPROM4_MAXP_A_LO		0xFF00  /* Mask for Lo */
 #define SSB_SPROM4_MAXP_A_LO_SHIFT	16	/* Shift for Lo */
-#define SSB_SPROM4_PA1LOB0		0x1000
-#define SSB_SPROM4_PA1LOB1		0x1000
-#define SSB_SPROM4_PA1LOB2		0x1000
-#define SSB_SPROM4_PA1HIB0		0x1000
-#define SSB_SPROM4_PA1HIB1		0x1000
-#define SSB_SPROM4_PA1HIB2		0x1000
-#define SSB_SPROM4_OPO			0x1000
-#define SSB_SPROM4_OPO_VALUE		0x0000
+#define SSB_SPROM4_PA1LOB0		0x1000  /* ?? */
+#define SSB_SPROM4_PA1LOB1		0x1000  /* ?? */
+#define SSB_SPROM4_PA1LOB2		0x1000  /* ?? */
+#define SSB_SPROM4_PA1HIB0		0x1000	/* ?? */
+#define SSB_SPROM4_PA1HIB1		0x1000	/* ?? */
+#define SSB_SPROM4_PA1HIB2		0x1000	/* ?? */
+#define SSB_SPROM4_OPO			0x1000	/* ?? */
+#define SSB_SPROM4_OPO_VALUE		0x0000	/* ?? */
 #define SSB_SPROM4_GPIOLDC		0x105A	/* LED Powersave Duty Cycle */
 #define  SSB_SPROM4_GPIOLDC_OFF		0x0000FF00	/* Off Count */
 #define  SSB_SPROM4_GPIOLDC_OFF_SHIFT	8
Index: wireless-2.6/drivers/ssb/b43_pci_bridge.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/b43_pci_bridge.c
+++ wireless-2.6/drivers/ssb/b43_pci_bridge.c
@@ -27,6 +27,7 @@ static const struct pci_device_id b43_pc
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4321) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4324) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4325) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4328) },
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, b43_pci_bridge_tbl);


From Larry.Finger at lwfinger.net  Fri Nov  9 23:57:18 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 16:57:18 -0600
Subject: [PATCH 4/6] b43: Convert to use of the new SPROM structure
Message-ID: <4734e5ce.d7a1RTXjEeuuQ7XG%Larry.Finger@lwfinger.net>

Patch 4 of 6.

The b43 driver is modified to use the new SPROM structure.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.c
+++ wireless-2.6/drivers/net/wireless/b43/leds.c
@@ -187,10 +187,10 @@ void b43_leds_init(struct b43_wldev *dev
 	enum b43_led_behaviour behaviour;
 	bool activelow;
 
-	sprom[0] = bus->sprom.r1.gpio0;
-	sprom[1] = bus->sprom.r1.gpio1;
-	sprom[2] = bus->sprom.r1.gpio2;
-	sprom[3] = bus->sprom.r1.gpio3;
+	sprom[0] = bus->sprom.gpio0;
+	sprom[1] = bus->sprom.gpio1;
+	sprom[2] = bus->sprom.gpio2;
+	sprom[3] = bus->sprom.gpio3;
 
 	for (i = 0; i < 4; i++) {
 		if (sprom[i] == 0xFF) {
Index: wireless-2.6/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/lo.c
+++ wireless-2.6/drivers/net/wireless/b43/lo.c
@@ -264,8 +264,8 @@ static u16 lo_measure_feedthrough(struct
 		rfover |= pga;
 		rfover |= lna;
 		rfover |= trsw_rx;
-		if ((dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_EXTLNA) &&
-		    phy->rev > 6)
+		if ((dev->dev->bus->sprom.boardflags_lo & B43_BFL_EXTLNA)
+		    && phy->rev > 6)
 			rfover |= B43_PHY_RFOVERVAL_EXTLNA;
 
 		b43_phy_write(dev, B43_PHY_PGACTL, 0xE300);
@@ -634,7 +634,7 @@ static void lo_measure_setup(struct b43_
 			      & 0xFFFC);
 		if (phy->type == B43_PHYTYPE_G) {
 			if ((phy->rev >= 7) &&
-			    (sprom->r1.boardflags_lo & B43_BFL_EXTLNA)) {
+			    (sprom->boardflags_lo & B43_BFL_EXTLNA)) {
 				b43_phy_write(dev, B43_PHY_RFOVER, 0x933);
 			} else {
 				b43_phy_write(dev, B43_PHY_RFOVER, 0x133);
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -1924,7 +1924,7 @@ static int b43_gpio_init(struct b43_wlde
 		mask |= 0x0180;
 		set |= 0x0180;
 	}
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_PACTRL) {
 		b43_write16(dev, B43_MMIO_GPIO_MASK,
 			    b43_read16(dev, B43_MMIO_GPIO_MASK)
 			    | 0x0200);
@@ -2289,7 +2289,7 @@ static void b43_periodic_every60sec(stru
 
 	if (!b43_has_hardware_pctl(phy))
 		b43_lo_g_ctl_mark_all_unused(dev);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI) {
 		b43_mac_suspend(dev);
 		b43_calc_nrssi_slope(dev);
 		if ((phy->radio_ver == 0x2050) && (phy->radio_rev == 8)) {
@@ -3208,13 +3208,13 @@ static void b43_bluetooth_coext_enable(s
 	struct ssb_sprom *sprom = &dev->dev->bus->sprom;
 	u32 hf;
 
-	if (!(sprom->r1.boardflags_lo & B43_BFL_BTCOEXIST))
+	if (!(sprom->boardflags_lo & B43_BFL_BTCOEXIST))
 		return;
 	if (dev->phy.type != B43_PHYTYPE_B && !dev->phy.gmode)
 		return;
 
 	hf = b43_hf_read(dev);
-	if (sprom->r1.boardflags_lo & B43_BFL_BTCMOD)
+	if (sprom->boardflags_lo & B43_BFL_BTCMOD)
 		hf |= B43_HF_BTCOEXALT;
 	else
 		hf |= B43_HF_BTCOEX;
@@ -3348,7 +3348,7 @@ static int b43_wireless_core_init(struct
 		hf |= B43_HF_SYMW;
 		if (phy->rev == 1)
 			hf |= B43_HF_GDCW;
-		if (sprom->r1.boardflags_lo & B43_BFL_PACTRL)
+		if (sprom->boardflags_lo & B43_BFL_PACTRL)
 			hf |= B43_HF_OFDMPABOOST;
 	} else if (phy->type == B43_PHYTYPE_B) {
 		hf |= B43_HF_SYMW;
@@ -3859,20 +3859,20 @@ static void b43_sprom_fixup(struct ssb_b
 	/* boardflags workarounds */
 	if (bus->boardinfo.vendor == SSB_BOARDVENDOR_DELL &&
 	    bus->chip_id == 0x4301 && bus->boardinfo.rev == 0x74)
-		bus->sprom.r1.boardflags_lo |= B43_BFL_BTCOEXIST;
+		bus->sprom.boardflags_lo |= B43_BFL_BTCOEXIST;
 	if (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE &&
 	    bus->boardinfo.type == 0x4E && bus->boardinfo.rev > 0x40)
-		bus->sprom.r1.boardflags_lo |= B43_BFL_PACTRL;
+		bus->sprom.boardflags_lo |= B43_BFL_PACTRL;
 
 	/* Handle case when gain is not set in sprom */
-	if (bus->sprom.r1.antenna_gain_a == 0xFF)
-		bus->sprom.r1.antenna_gain_a = 2;
-	if (bus->sprom.r1.antenna_gain_bg == 0xFF)
-		bus->sprom.r1.antenna_gain_bg = 2;
+	if (bus->sprom.antenna_gain_a == 0xFF)
+		bus->sprom.antenna_gain_a = 2;
+	if (bus->sprom.antenna_gain_bg == 0xFF)
+		bus->sprom.antenna_gain_bg = 2;
 
 	/* Convert Antennagain values to Q5.2 */
-	bus->sprom.r1.antenna_gain_a <<= 2;
-	bus->sprom.r1.antenna_gain_bg <<= 2;
+	bus->sprom.antenna_gain_a <<= 2;
+	bus->sprom.antenna_gain_bg <<= 2;
 }
 
 static void b43_wireless_exit(struct ssb_device *dev, struct b43_wl *wl)
@@ -3905,10 +3905,10 @@ static int b43_wireless_init(struct ssb_
 	hw->max_noise = -110;
 	hw->queues = 1;		/* FIXME: hardware has more queues */
 	SET_IEEE80211_DEV(hw, dev->dev);
-	if (is_valid_ether_addr(sprom->r1.et1mac))
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.et1mac);
+	if (is_valid_ether_addr(sprom->et1mac))
+		SET_IEEE80211_PERM_ADDR(hw, sprom->et1mac);
 	else
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.il0mac);
+		SET_IEEE80211_PERM_ADDR(hw, sprom->il0mac);
 
 	/* Get and initialize struct b43_wl */
 	wl = hw_to_b43_wl(hw);
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c
+++ wireless-2.6/drivers/net/wireless/b43/phy.c
@@ -1139,7 +1139,7 @@ static void b43_phy_inita(struct b43_wld
 	} else {
 		b43_phy_setupg(dev);
 		if (phy->gmode &&
-		    (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL))
+		    (dev->dev->bus->sprom.boardflags_lo & B43_BFL_PACTRL))
 			b43_phy_write(dev, 0x046E, 0x03CF);
 		return;
 	}
@@ -1286,7 +1286,7 @@ static void b43_phy_initb4(struct b43_wl
 	if (phy->radio_ver == 0x2050)
 		b43_phy_write(dev, 0x002A, 0x88C2);
 	b43_set_txpower_g(dev, &phy->bbatt, &phy->rfatt, phy->tx_control);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI) {
 		b43_calc_nrssi_slope(dev);
 		b43_calc_nrssi_threshold(dev);
 	}
@@ -1433,7 +1433,7 @@ static void b43_phy_initb6(struct b43_wl
 		b43_radio_write16(dev, 0x5A, 0x88);
 		b43_radio_write16(dev, 0x5B, 0x6B);
 		b43_radio_write16(dev, 0x5C, 0x0F);
-		if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_ALTIQ) {
+		if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_ALTIQ) {
 			b43_radio_write16(dev, 0x5D, 0xFA);
 			b43_radio_write16(dev, 0x5E, 0xD8);
 		} else {
@@ -1525,7 +1525,7 @@ static void b43_phy_initb6(struct b43_wl
 		b43_phy_write(dev, 0x0062, 0x0007);
 		b43_radio_init2050(dev);
 		b43_lo_g_measure(dev);
-		if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI) {
+		if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI) {
 			b43_calc_nrssi_slope(dev);
 			b43_calc_nrssi_threshold(dev);
 		}
@@ -1645,7 +1645,7 @@ static void b43_calc_loopback_gain(struc
 	b43_phy_write(dev, B43_PHY_RFOVERVAL,
 		      b43_phy_read(dev, B43_PHY_RFOVERVAL) & 0xCFFF);
 
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_EXTLNA) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_EXTLNA) {
 		if (phy->rev >= 7) {
 			b43_phy_write(dev, B43_PHY_RFOVER,
 				      b43_phy_read(dev, B43_PHY_RFOVER)
@@ -1812,7 +1812,7 @@ static void b43_phy_initg(struct b43_wld
 				       & 0x0FFF) | (phy->lo_control->
 						    tx_bias << 12));
 		}
-		if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL)
+		if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_PACTRL)
 			b43_phy_write(dev, B43_PHY_BASE(0x2E), 0x8075);
 		else
 			b43_phy_write(dev, B43_PHY_BASE(0x2E), 0x807F);
@@ -1826,7 +1826,7 @@ static void b43_phy_initg(struct b43_wld
 		b43_phy_write(dev, B43_PHY_LO_MASK, 0x8078);
 	}
 
-	if (!(dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI)) {
+	if (!(dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI)) {
 		/* The specs state to update the NRSSI LT with
 		 * the value 0x7FFFFFFF here. I think that is some weird
 		 * compiler optimization in the original driver.
@@ -2036,16 +2036,15 @@ void b43_phy_xmitpower(struct b43_wldev 
 			estimated_pwr =
 			    b43_phy_estimate_power_out(dev, average);
 
-			max_pwr = dev->dev->bus->sprom.r1.maxpwr_bg;
-			if ((dev->dev->bus->sprom.r1.
-			     boardflags_lo & B43_BFL_PACTRL)
-			    && (phy->type == B43_PHYTYPE_G))
+			max_pwr = dev->dev->bus->sprom.maxpwr_bg;
+			if ((dev->dev->bus->sprom.boardflags_lo
+			    & B43_BFL_PACTRL) && (phy->type == B43_PHYTYPE_G))
 				max_pwr -= 0x3;
 			if (unlikely(max_pwr <= 0)) {
 				b43warn(dev->wl,
 					"Invalid max-TX-power value in SPROM.\n");
 				max_pwr = 60;	/* fake it */
-				dev->dev->bus->sprom.r1.maxpwr_bg = max_pwr;
+				dev->dev->bus->sprom.maxpwr_bg = max_pwr;
 			}
 
 			/*TODO:
@@ -2103,7 +2102,7 @@ void b43_phy_xmitpower(struct b43_wldev 
 						    B43_TXCTL_TXMIX;
 						rfatt += 2;
 						bbatt += 2;
-					} else if (dev->dev->bus->sprom.r1.
+					} else if (dev->dev->bus->sprom.
 						   boardflags_lo &
 						   B43_BFL_PACTRL) {
 						bbatt += 4 * (rfatt - 2);
@@ -2179,13 +2178,13 @@ int b43_phy_init_tssi2dbm_table(struct b
 	s8 *dyn_tssi2dbm;
 
 	if (phy->type == B43_PHYTYPE_A) {
-		pab0 = (s16) (dev->dev->bus->sprom.r1.pa1b0);
-		pab1 = (s16) (dev->dev->bus->sprom.r1.pa1b1);
-		pab2 = (s16) (dev->dev->bus->sprom.r1.pa1b2);
+		pab0 = (s16) (dev->dev->bus->sprom.pa1b0);
+		pab1 = (s16) (dev->dev->bus->sprom.pa1b1);
+		pab2 = (s16) (dev->dev->bus->sprom.pa1b2);
 	} else {
-		pab0 = (s16) (dev->dev->bus->sprom.r1.pa0b0);
-		pab1 = (s16) (dev->dev->bus->sprom.r1.pa0b1);
-		pab2 = (s16) (dev->dev->bus->sprom.r1.pa0b2);
+		pab0 = (s16) (dev->dev->bus->sprom.pa0b0);
+		pab1 = (s16) (dev->dev->bus->sprom.pa0b1);
+		pab2 = (s16) (dev->dev->bus->sprom.pa0b2);
 	}
 
 	if ((dev->dev->bus->chip_id == 0x4301) && (phy->radio_ver != 0x2050)) {
@@ -2198,17 +2197,17 @@ int b43_phy_init_tssi2dbm_table(struct b
 	    pab0 != -1 && pab1 != -1 && pab2 != -1) {
 		/* The pabX values are set in SPROM. Use them. */
 		if (phy->type == B43_PHYTYPE_A) {
-			if ((s8) dev->dev->bus->sprom.r1.itssi_a != 0 &&
-			    (s8) dev->dev->bus->sprom.r1.itssi_a != -1)
+			if ((s8) dev->dev->bus->sprom.itssi_a != 0 &&
+			    (s8) dev->dev->bus->sprom.itssi_a != -1)
 				phy->tgt_idle_tssi =
-				    (s8) (dev->dev->bus->sprom.r1.itssi_a);
+				    (s8) (dev->dev->bus->sprom.itssi_a);
 			else
 				phy->tgt_idle_tssi = 62;
 		} else {
-			if ((s8) dev->dev->bus->sprom.r1.itssi_bg != 0 &&
-			    (s8) dev->dev->bus->sprom.r1.itssi_bg != -1)
+			if ((s8) dev->dev->bus->sprom.itssi_bg != 0 &&
+			    (s8) dev->dev->bus->sprom.itssi_bg != -1)
 				phy->tgt_idle_tssi =
-				    (s8) (dev->dev->bus->sprom.r1.itssi_bg);
+				    (s8) (dev->dev->bus->sprom.itssi_bg);
 			else
 				phy->tgt_idle_tssi = 62;
 		}
@@ -3114,7 +3113,7 @@ void b43_calc_nrssi_threshold(struct b43
 			if (phy->radio_ver != 0x2050)
 				return;
 			if (!
-			    (dev->dev->bus->sprom.r1.
+			    (dev->dev->bus->sprom.
 			     boardflags_lo & B43_BFL_RSSI))
 				return;
 
@@ -3145,7 +3144,7 @@ void b43_calc_nrssi_threshold(struct b43
 		}
 	case B43_PHYTYPE_G:
 		if (!phy->gmode ||
-		    !(dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI)) {
+		    !(dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI)) {
 			tmp16 = b43_nrssi_hw_read(dev, 0x20);
 			if (tmp16 >= 0x20)
 				tmp16 -= 0x40;
@@ -3667,7 +3666,7 @@ static u16 radio2050_rfover_val(struct b
 		}
 
 		if ((phy->rev < 7) ||
-		    !(sprom->r1.boardflags_lo & B43_BFL_EXTLNA)) {
+		    !(sprom->boardflags_lo & B43_BFL_EXTLNA)) {
 			if (phy_register == B43_PHY_RFOVER) {
 				return 0x1B3;
 			} else if (phy_register == B43_PHY_RFOVERVAL) {
@@ -3707,7 +3706,7 @@ static u16 radio2050_rfover_val(struct b
 		}
 	} else {
 		if ((phy->rev < 7) ||
-		    !(sprom->r1.boardflags_lo & B43_BFL_EXTLNA)) {
+		    !(sprom->boardflags_lo & B43_BFL_EXTLNA)) {
 			if (phy_register == B43_PHY_RFOVER) {
 				return 0x1B3;
 			} else if (phy_register == B43_PHY_RFOVERVAL) {
@@ -4186,7 +4185,7 @@ int b43_radio_selectchannel(struct b43_w
 		b43_write16(dev, B43_MMIO_CHANNEL, channel2freq_bg(channel));
 
 		if (channel == 14) {
-			if (dev->dev->bus->sprom.r1.country_code ==
+			if (dev->dev->bus->sprom.country_code ==
 			    SSB_SPROM1CCODE_JAPAN)
 				b43_hf_write(dev,
 					     b43_hf_read(dev) & ~B43_HF_ACPR);
Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c
+++ wireless-2.6/drivers/net/wireless/b43/xmit.c
@@ -385,7 +385,7 @@ static s8 b43_rssi_postprocess(struct b4
 			else
 				tmp -= 3;
 		} else {
-			if (dev->dev->bus->sprom.r1.
+			if (dev->dev->bus->sprom.
 			    boardflags_lo & B43_BFL_RSSI) {
 				if (in_rssi > 63)
 					in_rssi = 63;


From Larry.Finger at lwfinger.net  Fri Nov  9 23:57:34 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 16:57:34 -0600
Subject: [PATCH 5/6] b43legacy: Convert to use of the new SPROM structure
Message-ID: <4734e5de.lq2tynVQPACFW5qg%Larry.Finger@lwfinger.net>

Patch 5 of 6.

The b43legacy driver is modified to use the new SPROM structure.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/drivers/net/wireless/b43legacy/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/leds.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/leds.c
@@ -189,10 +189,10 @@ void b43legacy_leds_init(struct b43legac
 	enum b43legacy_led_behaviour behaviour;
 	bool activelow;
 
-	sprom[0] = bus->sprom.r1.gpio0;
-	sprom[1] = bus->sprom.r1.gpio1;
-	sprom[2] = bus->sprom.r1.gpio2;
-	sprom[3] = bus->sprom.r1.gpio3;
+	sprom[0] = bus->sprom.gpio0;
+	sprom[1] = bus->sprom.gpio1;
+	sprom[2] = bus->sprom.gpio2;
+	sprom[3] = bus->sprom.gpio3;
 
 	for (i = 0; i < 4; i++) {
 		if (sprom[i] == 0xFF) {
Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -1753,7 +1753,7 @@ static int b43legacy_gpio_init(struct b4
 		mask |= 0x0060;
 		set |= 0x0060;
 	}
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_PACTRL) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_PACTRL) {
 		b43legacy_write16(dev, B43legacy_MMIO_GPIO_MASK,
 				  b43legacy_read16(dev,
 				  B43legacy_MMIO_GPIO_MASK)
@@ -2130,7 +2130,7 @@ static void b43legacy_periodic_every120s
 static void b43legacy_periodic_every60sec(struct b43legacy_wldev *dev)
 {
 	b43legacy_phy_lo_mark_all_unused(dev);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_RSSI) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_RSSI) {
 		b43legacy_mac_suspend(dev);
 		b43legacy_calc_nrssi_slope(dev);
 		b43legacy_mac_enable(dev);
@@ -3058,7 +3058,7 @@ static int b43legacy_wireless_core_init(
 		hf |= B43legacy_HF_SYMW;
 		if (phy->rev == 1)
 			hf |= B43legacy_HF_GDCW;
-		if (sprom->r1.boardflags_lo & B43legacy_BFL_PACTRL)
+		if (sprom->boardflags_lo & B43legacy_BFL_PACTRL)
 			hf |= B43legacy_HF_OFDMPABOOST;
 	} else if (phy->type == B43legacy_PHYTYPE_B) {
 		hf |= B43legacy_HF_SYMW;
@@ -3537,12 +3537,12 @@ static void b43legacy_sprom_fixup(struct
 	if (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE &&
 	    bus->boardinfo.type == 0x4E &&
 	    bus->boardinfo.rev > 0x40)
-		bus->sprom.r1.boardflags_lo |= B43legacy_BFL_PACTRL;
+		bus->sprom.boardflags_lo |= B43legacy_BFL_PACTRL;
 
 	/* Convert Antennagain values to Q5.2 */
-	if (bus->sprom.r1.antenna_gain_bg == 0xFF)
-		bus->sprom.r1.antenna_gain_bg = 2; /* if unset, use 2 dBm */
-	bus->sprom.r1.antenna_gain_bg <<= 2;
+	if (bus->sprom.antenna_gain_bg == 0xFF)
+		bus->sprom.antenna_gain_bg = 2; /* if unset, use 2 dBm */
+	bus->sprom.antenna_gain_bg <<= 2;
 }
 
 static void b43legacy_wireless_exit(struct ssb_device *dev,
@@ -3577,10 +3577,10 @@ static int b43legacy_wireless_init(struc
 	hw->max_noise = -110;
 	hw->queues = 1; /* FIXME: hardware has more queues */
 	SET_IEEE80211_DEV(hw, dev->dev);
-	if (is_valid_ether_addr(sprom->r1.et1mac))
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.et1mac);
+	if (is_valid_ether_addr(sprom->et1mac))
+		SET_IEEE80211_PERM_ADDR(hw, sprom->et1mac);
 	else
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.il0mac);
+		SET_IEEE80211_PERM_ADDR(hw, sprom->il0mac);
 
 	/* Get and initialize struct b43legacy_wl */
 	wl = hw_to_b43legacy_wl(hw);
Index: wireless-2.6/drivers/net/wireless/b43legacy/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/phy.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/phy.c
@@ -441,7 +441,7 @@ static void b43legacy_phy_inita(struct b
 	might_sleep();
 
 	b43legacy_phy_setupg(dev);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_PACTRL)
+	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_PACTRL)
 		b43legacy_phy_write(dev, 0x046E, 0x03CF);
 }
 
@@ -543,7 +543,7 @@ static void b43legacy_phy_initb4(struct 
 	if (phy->radio_ver == 0x2050)
 		b43legacy_phy_write(dev, 0x002A, 0x88C2);
 	b43legacy_radio_set_txpower_bg(dev, 0xFFFF, 0xFFFF, 0xFFFF);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_RSSI) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_RSSI) {
 		b43legacy_calc_nrssi_slope(dev);
 		b43legacy_calc_nrssi_threshold(dev);
 	}
@@ -699,7 +699,7 @@ static void b43legacy_phy_initb6(struct 
 		b43legacy_radio_write16(dev, 0x005A, 0x0088);
 		b43legacy_radio_write16(dev, 0x005B, 0x006B);
 		b43legacy_radio_write16(dev, 0x005C, 0x000F);
-		if (dev->dev->bus->sprom.r1.boardflags_lo & 0x8000) {
+		if (dev->dev->bus->sprom.boardflags_lo & 0x8000) {
 			b43legacy_radio_write16(dev, 0x005D, 0x00FA);
 			b43legacy_radio_write16(dev, 0x005E, 0x00D8);
 		} else {
@@ -797,7 +797,7 @@ static void b43legacy_phy_initb6(struct 
 		b43legacy_phy_write(dev, 0x0062, 0x0007);
 		b43legacy_radio_init2050(dev);
 		b43legacy_phy_lo_g_measure(dev);
-		if (dev->dev->bus->sprom.r1.boardflags_lo &
+		if (dev->dev->bus->sprom.boardflags_lo &
 		    B43legacy_BFL_RSSI) {
 			b43legacy_calc_nrssi_slope(dev);
 			b43legacy_calc_nrssi_threshold(dev);
@@ -921,7 +921,7 @@ static void b43legacy_calc_loopback_gain
 			    b43legacy_phy_read(dev, 0x0811) | 0x0100);
 	b43legacy_phy_write(dev, 0x0812,
 			    b43legacy_phy_read(dev, 0x0812) & 0xCFFF);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_EXTLNA) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_EXTLNA) {
 		if (phy->rev >= 7) {
 			b43legacy_phy_write(dev, 0x0811,
 					    b43legacy_phy_read(dev, 0x0811)
@@ -1072,7 +1072,7 @@ static void b43legacy_phy_initg(struct b
 			b43legacy_phy_write(dev, 0x0036,
 					    (b43legacy_phy_read(dev, 0x0036)
 					     & 0x0FFF) | (phy->txctl2 << 12));
-		if (dev->dev->bus->sprom.r1.boardflags_lo &
+		if (dev->dev->bus->sprom.boardflags_lo &
 		    B43legacy_BFL_PACTRL)
 			b43legacy_phy_write(dev, 0x002E, 0x8075);
 		else
@@ -1087,7 +1087,7 @@ static void b43legacy_phy_initg(struct b
 		b43legacy_phy_write(dev, 0x080F, 0x8078);
 	}
 
-	if (!(dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_RSSI)) {
+	if (!(dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_RSSI)) {
 		/* The specs state to update the NRSSI LT with
 		 * the value 0x7FFFFFFF here. I think that is some weird
 		 * compiler optimization in the original driver.
@@ -1838,9 +1838,9 @@ void b43legacy_phy_xmitpower(struct b43l
 
 	estimated_pwr = b43legacy_phy_estimate_power_out(dev, average);
 
-	max_pwr = dev->dev->bus->sprom.r1.maxpwr_bg;
+	max_pwr = dev->dev->bus->sprom.maxpwr_bg;
 
-	if ((dev->dev->bus->sprom.r1.boardflags_lo
+	if ((dev->dev->bus->sprom.boardflags_lo
 	     & B43legacy_BFL_PACTRL) &&
 	    (phy->type == B43legacy_PHYTYPE_G))
 		max_pwr -= 0x3;
@@ -1848,7 +1848,7 @@ void b43legacy_phy_xmitpower(struct b43l
 		b43legacywarn(dev->wl, "Invalid max-TX-power value in SPROM."
 			"\n");
 		max_pwr = 74; /* fake it */
-		dev->dev->bus->sprom.r1.maxpwr_bg = max_pwr;
+		dev->dev->bus->sprom.maxpwr_bg = max_pwr;
 	}
 
 	/* Use regulatory information to get the maximum power.
@@ -1858,7 +1858,8 @@ void b43legacy_phy_xmitpower(struct b43l
 	 * and 1.5 dBm (a safety factor??). The result is in Q5.2 format
 	 * which accounts for the factor of 4 */
 #define REG_MAX_PWR 20
-	max_pwr = min(REG_MAX_PWR * 4 - dev->dev->bus->sprom.r1.antenna_gain_bg
+	max_pwr = min(REG_MAX_PWR * 4
+		      - dev->dev->bus->sprom.antenna_gain_bg
 		      - 0x6, max_pwr);
 
 	/* find the desired power in Q5.2 - power_level is in dBm
@@ -1918,7 +1919,7 @@ void b43legacy_phy_xmitpower(struct b43l
 				txpower = 3;
 				radio_attenuation += 2;
 				baseband_attenuation += 2;
-			} else if (dev->dev->bus->sprom.r1.boardflags_lo
+			} else if (dev->dev->bus->sprom.boardflags_lo
 				   & B43legacy_BFL_PACTRL) {
 				baseband_attenuation += 4 *
 						     (radio_attenuation - 2);
@@ -2000,9 +2001,9 @@ int b43legacy_phy_init_tssi2dbm_table(st
 
 	B43legacy_WARN_ON(!(phy->type == B43legacy_PHYTYPE_B ||
 			  phy->type == B43legacy_PHYTYPE_G));
-	pab0 = (s16)(dev->dev->bus->sprom.r1.pa0b0);
-	pab1 = (s16)(dev->dev->bus->sprom.r1.pa0b1);
-	pab2 = (s16)(dev->dev->bus->sprom.r1.pa0b2);
+	pab0 = (s16)(dev->dev->bus->sprom.pa0b0);
+	pab1 = (s16)(dev->dev->bus->sprom.pa0b1);
+	pab2 = (s16)(dev->dev->bus->sprom.pa0b2);
 
 	if ((dev->dev->bus->chip_id == 0x4301) && (phy->radio_ver != 0x2050)) {
 		phy->idle_tssi = 0x34;
@@ -2013,9 +2014,10 @@ int b43legacy_phy_init_tssi2dbm_table(st
 	if (pab0 != 0 && pab1 != 0 && pab2 != 0 &&
 	    pab0 != -1 && pab1 != -1 && pab2 != -1) {
 		/* The pabX values are set in SPROM. Use them. */
-		if ((s8)dev->dev->bus->sprom.r1.itssi_bg != 0 &&
-		    (s8)dev->dev->bus->sprom.r1.itssi_bg != -1)
-			phy->idle_tssi = (s8)(dev->dev->bus->sprom.r1.itssi_bg);
+		if ((s8)dev->dev->bus->sprom.itssi_bg != 0 &&
+		    (s8)dev->dev->bus->sprom.itssi_bg != -1)
+			phy->idle_tssi = (s8)(dev->dev->bus->sprom.
+					  itssi_bg);
 		else
 			phy->idle_tssi = 62;
 		dyn_tssi2dbm = kmalloc(64, GFP_KERNEL);
Index: wireless-2.6/drivers/net/wireless/b43legacy/radio.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/radio.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/radio.c
@@ -827,7 +827,7 @@ void b43legacy_calc_nrssi_threshold(stru
 	case B43legacy_PHYTYPE_B: {
 		if (phy->radio_ver != 0x2050)
 			return;
-		if (!(dev->dev->bus->sprom.r1.boardflags_lo &
+		if (!(dev->dev->bus->sprom.boardflags_lo &
 		    B43legacy_BFL_RSSI))
 			return;
 
@@ -857,7 +857,7 @@ void b43legacy_calc_nrssi_threshold(stru
 	}
 	case B43legacy_PHYTYPE_G:
 		if (!phy->gmode ||
-		    !(dev->dev->bus->sprom.r1.boardflags_lo &
+		    !(dev->dev->bus->sprom.boardflags_lo &
 		    B43legacy_BFL_RSSI)) {
 			tmp16 = b43legacy_nrssi_hw_read(dev, 0x20);
 			if (tmp16 >= 0x20)
@@ -1406,7 +1406,7 @@ static u16 b43legacy_get_812_value(struc
 	if (!phy->gmode)
 		return 0;
 	if (!has_loopback_gain(phy)) {
-		if (phy->rev < 7 || !(dev->dev->bus->sprom.r1.boardflags_lo
+		if (phy->rev < 7 || !(dev->dev->bus->sprom.boardflags_lo
 		    & B43legacy_BFL_EXTLNA)) {
 			switch (lpd) {
 			case LPD(0, 1, 1):
@@ -1459,7 +1459,7 @@ static u16 b43legacy_get_812_value(struc
 		}
 
 		loop_or = (loop << 8) | extern_lna_control;
-		if (phy->rev >= 7 && dev->dev->bus->sprom.r1.boardflags_lo
+		if (phy->rev >= 7 && dev->dev->bus->sprom.boardflags_lo
 		    & B43legacy_BFL_EXTLNA) {
 			if (extern_lna_control)
 				loop_or |= 0x8000;
@@ -1550,7 +1550,7 @@ u16 b43legacy_radio_init2050(struct b43l
 					    b43legacy_get_812_value(dev,
 					    LPD(0, 1, 1)));
 			if (phy->rev < 7 ||
-			    !(dev->dev->bus->sprom.r1.boardflags_lo
+			    !(dev->dev->bus->sprom.boardflags_lo
 			    & B43legacy_BFL_EXTLNA))
 				b43legacy_phy_write(dev, 0x0811, 0x01B3);
 			else
@@ -1786,7 +1786,7 @@ int b43legacy_radio_selectchannel(struct
 			  channel2freq_bg(channel));
 
 	if (channel == 14) {
-		if (dev->dev->bus->sprom.r1.country_code == 5)   /* JAPAN) */
+		if (dev->dev->bus->sprom.country_code == 5)   /* JAPAN) */
 			b43legacy_shm_write32(dev, B43legacy_SHM_SHARED,
 					      B43legacy_UCODEFLAGS_OFFSET,
 					      b43legacy_shm_read32(dev,
Index: wireless-2.6/drivers/net/wireless/b43legacy/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/xmit.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/xmit.c
@@ -378,7 +378,7 @@ static s8 b43legacy_rssi_postprocess(str
 			else
 				tmp -= 3;
 		} else {
-			if (dev->dev->bus->sprom.r1.boardflags_lo
+			if (dev->dev->bus->sprom.boardflags_lo
 			    & B43legacy_BFL_RSSI) {
 				if (in_rssi > 63)
 					in_rssi = 63;


From Larry.Finger at lwfinger.net  Fri Nov  9 23:58:20 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 09 Nov 2007 16:58:20 -0600
Subject: [PATCH 6/6] ssb: Remove the old, now unused, data structures
Message-ID: <4734e60c.mXHHDefHDb29vGwY%Larry.Finger@lwfinger.net>

Patch 6 of 6.

The old, now unused, data structures and SPROM extraction routines
are removed.

Signed-off-by: Larry Finger<Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/include/linux/ssb/ssb.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb.h
+++ wireless-2.6/include/linux/ssb/ssb.h
@@ -15,72 +15,7 @@ struct pcmcia_device;
 struct ssb_bus;
 struct ssb_driver;
 
-
-struct ssb_sprom_r1 {
-	u16 pci_spid;		/* Subsystem Product ID for PCI */
-	u16 pci_svid;		/* Subsystem Vendor ID for PCI */
-	u16 pci_pid;		/* Product ID for PCI */
-	u8 il0mac[6];		/* MAC address for 802.11b/g */
-	u8 et0mac[6];		/* MAC address for Ethernet */
-	u8 et1mac[6];		/* MAC address for 802.11a */
-	u8 et0phyaddr:5;	/* MII address for enet0 */
-	u8 et1phyaddr:5;	/* MII address for enet1 */
-	u8 et0mdcport:1;	/* MDIO for enet0 */
-	u8 et1mdcport:1;	/* MDIO for enet1 */
-	u8 board_rev;		/* Board revision */
-	u8 country_code:4;	/* Country Code */
-	u8 antenna_a:2;		/* Antenna 0/1 available for A-PHY */
-	u8 antenna_bg:2;	/* Antenna 0/1 available for B-PHY and G-PHY */
-	u16 pa0b0;
-	u16 pa0b1;
-	u16 pa0b2;
-	u16 pa1b0;
-	u16 pa1b1;
-	u16 pa1b2;
-	u8 gpio0;		/* GPIO pin 0 */
-	u8 gpio1;		/* GPIO pin 1 */
-	u8 gpio2;		/* GPIO pin 2 */
-	u8 gpio3;		/* GPIO pin 3 */
-	u16 maxpwr_a;		/* A-PHY Power Amplifier Max Power (in dBm Q5.2) */
-	u16 maxpwr_bg;		/* B/G-PHY Power Amplifier Max Power (in dBm Q5.2) */
-	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
-	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
-	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
-	u8 antenna_gain_a;	/* A-PHY Antenna gain (in dBm Q5.2) */
-	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
-	u8 oem[8];		/* OEM string (rev 1 only) */
-};
-
-struct ssb_sprom_r2 {
-	u16 boardflags_hi;	/* Boardflags (high 16 bits) */
-	u8 maxpwr_a_lo;		/* A-PHY Max Power Low */
-	u8 maxpwr_a_hi;		/* A-PHY Max Power High */
-	u16 pa1lob0;		/* A-PHY PA Low Settings */
-	u16 pa1lob1;		/* A-PHY PA Low Settings */
-	u16 pa1lob2;		/* A-PHY PA Low Settings */
-	u16 pa1hib0;		/* A-PHY PA High Settings */
-	u16 pa1hib1;		/* A-PHY PA High Settings */
-	u16 pa1hib2;		/* A-PHY PA High Settings */
-	u8 ofdm_pwr_off;	/* OFDM Power Offset from CCK Level */
-	u8 country_str[2];	/* Two char Country Code */
-};
-
-struct ssb_sprom_r3 {
-	u32 ofdmapo;		/* A-PHY OFDM Mid Power Offset */
-	u32 ofdmalpo;		/* A-PHY OFDM Low Power Offset */
-	u32 ofdmahpo;		/* A-PHY OFDM High Power Offset */
-	u8 gpioldc_on_cnt;	/* GPIO LED Powersave Duty Cycle ON count */
-	u8 gpioldc_off_cnt;	/* GPIO LED Powersave Duty Cycle OFF count */
-	u8 cckpo_1M:4;		/* CCK Power Offset for Rate 1M */
-	u8 cckpo_2M:4;		/* CCK Power Offset for Rate 2M */
-	u8 cckpo_55M:4;		/* CCK Power Offset for Rate 5.5M */
-	u8 cckpo_11M:4;		/* CCK Power Offset for Rate 11M */
-	u32 ofdmgpo;		/* G-PHY OFDM Power Offset */
-};
-
 struct ssb_sprom {
-	u8 revision;
-	u8 temp_fill[2 * sizeof(struct ssb_sprom_r1)];
 	u8 il0mac[6];		/* MAC address for 802.11b/g */
 	u8 et0mac[6];		/* MAC address for Ethernet */
 	u8 et1mac[6];		/* MAC address for 802.11a */
@@ -106,16 +41,6 @@ struct ssb_sprom {
 	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
 
 	/* TODO - add any parameters needed from rev 2, 3, or 4 SPROMs */
-	/* The valid r# fields are selected by the "revision".
-	 * Revision 3 and lower inherit from lower revisions.
-	 */
-	union {
-		struct {
-			struct ssb_sprom_r1 r1;
-			struct ssb_sprom_r2 r2;
-			struct ssb_sprom_r3 r3;
-		};
-	};
 };
 
 /* Information about the PCB the circuitry is soldered on. */
Index: wireless-2.6/drivers/ssb/pci.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/pci.c
+++ wireless-2.6/drivers/ssb/pci.c
@@ -297,62 +297,6 @@ err_ctlreg:
 	return err;
 }
 
-static void sprom_extract_r1(struct ssb_sprom_r1 *out, const u16 *in)
-{
-	int i;
-	u16 v;
-
-	SPEX(pci_spid, SSB_SPROM1_SPID, 0xFFFF, 0);
-	SPEX(pci_svid, SSB_SPROM1_SVID, 0xFFFF, 0);
-	SPEX(pci_pid, SSB_SPROM1_PID, 0xFFFF, 0);
-	for (i = 0; i < 3; i++) {
-		v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
-		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
-	}
-	for (i = 0; i < 3; i++) {
-		v = in[SPOFF(SSB_SPROM1_ET0MAC) + i];
-		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
-	}
-	for (i = 0; i < 3; i++) {
-		v = in[SPOFF(SSB_SPROM1_ET1MAC) + i];
-		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
-	}
-	SPEX(et0phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0A, 0);
-	SPEX(et1phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1A,
-	     SSB_SPROM1_ETHPHY_ET1A_SHIFT);
-	SPEX(et0mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0M, 14);
-	SPEX(et1mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1M, 15);
-	SPEX(board_rev, SSB_SPROM1_BINF, SSB_SPROM1_BINF_BREV, 0);
-	SPEX(country_code, SSB_SPROM1_BINF, SSB_SPROM1_BINF_CCODE,
-	     SSB_SPROM1_BINF_CCODE_SHIFT);
-	SPEX(antenna_a, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTA,
-	     SSB_SPROM1_BINF_ANTA_SHIFT);
-	SPEX(antenna_bg, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTBG,
-	     SSB_SPROM1_BINF_ANTBG_SHIFT);
-	SPEX(pa0b0, SSB_SPROM1_PA0B0, 0xFFFF, 0);
-	SPEX(pa0b1, SSB_SPROM1_PA0B1, 0xFFFF, 0);
-	SPEX(pa0b2, SSB_SPROM1_PA0B2, 0xFFFF, 0);
-	SPEX(pa1b0, SSB_SPROM1_PA1B0, 0xFFFF, 0);
-	SPEX(pa1b1, SSB_SPROM1_PA1B1, 0xFFFF, 0);
-	SPEX(pa1b2, SSB_SPROM1_PA1B2, 0xFFFF, 0);
-	SPEX(gpio0, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P0, 0);
-	SPEX(gpio1, SSB_SPROM1_GPIOA, SSB_SPROM1_GPIOA_P1,
-	     SSB_SPROM1_GPIOA_P1_SHIFT);
-	SPEX(gpio2, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P2, 0);
-	SPEX(gpio3, SSB_SPROM1_GPIOB, SSB_SPROM1_GPIOB_P3,
-	     SSB_SPROM1_GPIOB_P3_SHIFT);
-	SPEX(maxpwr_a, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_A,
-	     SSB_SPROM1_MAXPWR_A_SHIFT);
-	SPEX(maxpwr_bg, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_BG, 0);
-	SPEX(itssi_a, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_A,
-	     SSB_SPROM1_ITSSI_A_SHIFT);
-	SPEX(itssi_bg, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_BG, 0);
-	SPEX(boardflags_lo, SSB_SPROM1_BFLLO, 0xFFFF, 0);
-	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
-	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
-	     SSB_SPROM1_AGAIN_BG_SHIFT);
-}
-
 static void sprom_extract_r123(struct ssb_sprom *out, const u16 *in)
 {
 	int i;
@@ -414,7 +358,7 @@ static void sprom_extract_r4(struct ssb_
 	int i;
 	u16 v;
 
-	/* extract the r1 variables */
+	/* extract the equivalent of the r1 variables */
 	for (i = 0; i < 3; i++) {
 		v = in[SPOFF(SSB_SPROM4_IL0MAC) + i];
 		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
@@ -435,6 +379,18 @@ static void sprom_extract_r4(struct ssb_
 	SPEX(antenna_gain_a, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_0, 0);
 	SPEX(antenna_gain_bg, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_1,
 	     SSB_SPROM4_AGAIN_1_SHIFT);
+	SPEX(maxpwr_bg, SSB_SPROM4_MAXP_BG, SSB_SPROM4_MAXP_BG_MASK, 0);
+	SPEX(itssi_bg, SSB_SPROM4_MAXP_BG, SSB_SPROM4_ITSSI_BG,
+	     SSB_SPROM4_ITSSI_BG_SHIFT);
+	SPEX(maxpwr_a, SSB_SPROM4_MAXP_A, SSB_SPROM4_MAXP_A_MASK, 0);
+	SPEX(itssi_a, SSB_SPROM4_MAXP_A, SSB_SPROM4_ITSSI_A,
+	     SSB_SPROM4_ITSSI_A_SHIFT);
+	SPEX(gpio0, SSB_SPROM4_GPIOA, SSB_SPROM4_GPIOA_P0, 0);
+	SPEX(gpio1, SSB_SPROM4_GPIOA, SSB_SPROM4_GPIOA_P1,
+	     SSB_SPROM4_GPIOA_P1_SHIFT);
+	SPEX(gpio2, SSB_SPROM4_GPIOB, SSB_SPROM4_GPIOB_P2, 0);
+	SPEX(gpio3, SSB_SPROM4_GPIOB, SSB_SPROM4_GPIOB_P3,
+	     SSB_SPROM4_GPIOB_P3_SHIFT);
 	/* TODO - get remaining rev 4 stuff needed */
 }
 
@@ -444,13 +400,13 @@ static int sprom_extract(struct ssb_bus 
 	memset(out, 0, sizeof(*out));
 
 	out->revision = in[size - 1] & 0x00FF;
+	ssb_printk(KERN_INFO PFX "SPROM revision %d detected.\n", out->revision);
 	if ((bus->chip_id & 0xFF00) == 0x4400) {
 		/* Workaround: The BCM44XX chip has a stupid revision
 		 * number stored in the SPROM.
 		 * Always extract r1. */
 		out->revision = 1;
 		sprom_extract_r123(out, in);
-		sprom_extract_r1(&out->r1, in);
 	} else if (bus->chip_id == 0x4321) {
 		/* the BCM4328 has a chipid == 0x4321 and a rev 4 SPROM */
 		out->revision = 4;
@@ -460,7 +416,6 @@ static int sprom_extract(struct ssb_bus 
 			goto unsupported;
 		if (out->revision >= 1 && out->revision <= 3) {
 			sprom_extract_r123(out, in);
-			sprom_extract_r1(&out->r1, in);
 		}
 		if (out->revision == 4)
 			sprom_extract_r4(out, in);
@@ -472,7 +427,7 @@ static int sprom_extract(struct ssb_bus 
 unsupported:
 	ssb_printk(KERN_WARNING PFX "Unsupported SPROM revision %d "
 		   "detected. Will extract v1\n", out->revision);
-	sprom_extract_r1(&out->r1, in);
+	sprom_extract_r123(out, in);
 	return 0;
 }
 
Index: wireless-2.6/include/linux/ssb/ssb_regs.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb_regs.h
+++ wireless-2.6/include/linux/ssb/ssb_regs.h
@@ -175,6 +175,7 @@
 #define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
 #define  SSB_SPROM_REVISION_CRC		0xFF00	/* SPROM CRC8 value */
 #define  SSB_SPROM_REVISION_CRC_SHIFT	8
+
 /* SPROM Revision 1 */
 #define SSB_SPROM1_SPID			0x1004	/* Subsystem Product ID for PCI */
 #define SSB_SPROM1_SVID			0x1006	/* Subsystem Vendor ID for PCI */
@@ -223,7 +224,7 @@
 #define  SSB_SPROM1_AGAIN_A		0x00FF	/* A-PHY */
 #define  SSB_SPROM1_AGAIN_BG		0xFF00	/* B-PHY and G-PHY */
 #define  SSB_SPROM1_AGAIN_BG_SHIFT	8
-#define SSB_SPROM1_OEM			0x1076	/* 8 bytes OEM string (rev 1 only) */
+
 /* SPROM Revision 2 (inherits from rev 1) */
 #define SSB_SPROM2_BFLHI		0x1038	/* Boardflags (high 16 bits) */
 #define SSB_SPROM2_MAXP_A		0x103A	/* A-PHY Max Power */
@@ -240,6 +241,7 @@
 #define  SSB_SPROM2_OPO_VALUE		0x00FF
 #define  SSB_SPROM2_OPO_UNUSED		0xFF00
 #define SSB_SPROM2_CCODE		0x107C	/* Two char Country Code */
+
 /* SPROM Revision 3 (inherits most data from rev 2) */
 #define SSB_SPROM3_IL0MAC		0x104A	/* 6 bytes MAC address for 802.11b/g */
 #define SSB_SPROM3_ET0MAC		0x1050	/* 6 bytes MAC address for Ethernet ?? */
@@ -261,11 +263,12 @@
 #define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
 #define  SSB_SPROM3_CCKPO_11M_SHIFT	12
 #define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
+
 /* SPROM Revision 4 		entries with ?? in comment are unknown */
-#define SSB_SPROM4_IL0MAC		0x104C	/* 6 byte MAC address for b/g */
+#define SSB_SPROM4_IL0MAC		0x104C	/* 6 byte MAC address for a/b/g/n */
 #define SSB_SPROM4_ET0MAC		0x1018	/* 6 bytes MAC address for Ethernet ?? */
 #define SSB_SPROM4_ET1MAC		0x1018	/* 6 bytes MAC address for 802.11a ?? */
-#define SSB_SPROM4_ETHPHY		0x105A	/* Ethernet PHY settings */
+#define SSB_SPROM4_ETHPHY		0x105A	/* Ethernet PHY settings ?? */
 #define  SSB_SPROM4_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
 #define  SSB_SPROM4_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
 #define  SSB_SPROM4_ETHPHY_ET1A_SHIFT	5
@@ -280,24 +283,28 @@
 #define  SSB_SPROM4_AGAIN_1		0xFF00	/* Antenna 1 */
 #define  SSB_SPROM4_AGAIN_1_SHIFT	8
 #define SSB_SPROM4_BFLHI		0x1046  /* Board Flags Hi */
-#define SSB_SPROM4_MAXP_A		0x1000  /* Max Power A ?? */
-#define SSB_SPROM4_MAXP_A_HI		0x00FF  /* Mask for Hi */
-#define SSB_SPROM4_MAXP_A_LO		0xFF00  /* Mask for Lo */
-#define SSB_SPROM4_MAXP_A_LO_SHIFT	16	/* Shift for Lo */
-#define SSB_SPROM4_PA1LOB0		0x1000  /* ?? */
-#define SSB_SPROM4_PA1LOB1		0x1000  /* ?? */
-#define SSB_SPROM4_PA1LOB2		0x1000  /* ?? */
-#define SSB_SPROM4_PA1HIB0		0x1000	/* ?? */
-#define SSB_SPROM4_PA1HIB1		0x1000	/* ?? */
-#define SSB_SPROM4_PA1HIB2		0x1000	/* ?? */
-#define SSB_SPROM4_OPO			0x1000	/* ?? */
-#define SSB_SPROM4_OPO_VALUE		0x0000	/* ?? */
-#define SSB_SPROM4_GPIOLDC		0x105A	/* LED Powersave Duty Cycle */
-#define  SSB_SPROM4_GPIOLDC_OFF		0x0000FF00	/* Off Count */
-#define  SSB_SPROM4_GPIOLDC_OFF_SHIFT	8
-#define  SSB_SPROM4_GPIOLDC_ON		0x00FF0000	/* On Count */
-#define  SSB_SPROM4_GPIOLDC_ON_SHIFT	16
-
+#define SSB_SPROM4_MAXP_BG		0x1080  /* Max Power BG in path 1 */
+#define  SSB_SPROM4_MAXP_BG_MASK	0x00FF  /* Mask for Max Power BG */
+#define  SSB_SPROM4_ITSSI_BG		0xFF00	/* Mask for path 1 itssi_bg */
+#define  SSB_SPROM4_ITSSI_BG_SHIFT	8
+#define SSB_SPROM4_MAXP_A		0x108A  /* Max Power A in path 1 */
+#define  SSB_SPROM4_MAXP_A_MASK		0x00FF  /* Mask for Max Power A */
+#define  SSB_SPROM4_ITSSI_A		0xFF00	/* Mask for path 1 itssi_a */
+#define  SSB_SPROM4_ITSSI_A_SHIFT	8
+#define SSB_SPROM4_GPIOA		0x1056	/* Gen. Purpose IO # 0 and 1 */
+#define  SSB_SPROM4_GPIOA_P0		0x00FF	/* Pin 0 */
+#define  SSB_SPROM4_GPIOA_P1		0xFF00	/* Pin 1 */
+#define  SSB_SPROM4_GPIOA_P1_SHIFT	8
+#define SSB_SPROM4_GPIOB		0x1058	/* Gen. Purpose IO # 2 and 3 */
+#define  SSB_SPROM4_GPIOB_P2		0x00FF	/* Pin 2 */
+#define  SSB_SPROM4_GPIOB_P3		0xFF00	/* Pin 3 */
+#define  SSB_SPROM4_GPIOB_P3_SHIFT	8
+#define SSB_SPROM4_PA0B0		0x1082	/* The paXbY locations are */
+#define SSB_SPROM4_PA0B1		0x1084	/*   only guesses */
+#define SSB_SPROM4_PA0B2		0x1086
+#define SSB_SPROM4_PA1B0		0x108E
+#define SSB_SPROM4_PA1B1		0x1090
+#define SSB_SPROM4_PA1B2		0x1092
 
 /* Values for SSB_SPROM1_BINF_CCODE */
 enum {


From linville at tuxdriver.com  Sat Nov 10 01:21:58 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Fri, 9 Nov 2007 19:21:58 -0500
Subject: Help with wireless on Fedora 8
In-Reply-To: <4734E1BC.1060608@lwfinger.net>
References: <000b01c8231a$b78c82a0$0601a8c0@ruggiero>
	<001001c8231c$04413d60$0601a8c0@ruggiero>
	<4734E1BC.1060608@lwfinger.net>
Message-ID: <20071110002158.GB32472@tuxdriver.com>

On Fri, Nov 09, 2007 at 04:39:56PM -0600, Larry Finger wrote:
> I need some Fedora help. This new b43 user is having problems making a connection. He has a b-only
> AP of unspecified make with no encryption. He is using F8 with the default kernel (I think). He has
> done the following:
> 
> Ruggiero wrote:
> > i used "system->adminstration>Network" and i configurated everything from 
> > there...and the clicking on "activate wlan0" for a while my access point 
> > communicate and in the log i see that it's connected... here are outputs:
> > if i use NetworkManager i see it's connecting...but after a while i get the 
> > message "disconnected"
> 
> Tail of dmesg:
> 
> > wlan0: Initial auth_alg=0
> > wlan0: authenticate with AP 00:0c:41:19:2d:c1
> > wlan0: authenticate with AP 00:0c:41:19:2d:c1
> > wlan0: authenticate with AP 00:0c:41:19:2d:c1
> > wlan0: authentication with AP 00:0c:41:19:2d:c1 timed out
> > wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
> > authenticate state - ignored
> > wlan0: RX disassociation from 00:0c:41:19:2d:c1 (reason=4)
> 
> All the b43 messages are normal. He sees the AP with a scan, but never authenticates. Any suggestions?

FWIW, the F8 install kernel has wireless bits that are a month or
so old.  You may want to have him try these kernels:

	http://koji.fedoraproject.org/koji/buildinfo?buildID=23734

Those at least have wireless bits that are up-to-date w/ wireless-2.6.

John
-- 
John W. Linville
linville at tuxdriver.com


From rugg.argos at tiscali.it  Sat Nov 10 10:13:10 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Sat, 10 Nov 2007 10:13:10 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net>
	<000b01c8231a$b78c82a0$0601a8c0@ruggiero>
	<001001c8231c$04413d60$0601a8c0@ruggiero>
	<4734E1EC.1040107@lwfinger.net>
Message-ID: <000801c82379$ea3d4cc0$0601a8c0@ruggiero>

yes the radio switcher was on...here there are new informations after 
upgrading the kernel,i tried first with NetworkManager and then with 
System->Administration->Network and then activating interface :



b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
Registered led device: b43-phy0:tx
Registered led device: b43-phy0:rx
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
input: Unspecified device as /class/input/input10
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Adding Interface type 2
ADDRCONF(NETDEV_UP): wlan0: link is not ready
[drm] Initialized drm 1.1.0 20060810
[drm] Initialized i915 1.6.0 20060119 on minor 0
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authentication with AP 00:0c:41:19:2d:c1 timed out
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in 
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in 
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in 
authenticate state - ignored
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authentication with AP 00:0c:41:19:2d:c1 timed out
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in 
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in 
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in 
authenticate state - ignored
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: RX authentication from 00:0c:41:19:2d:c1 (alg=0 transaction=2 
status=0)
wlan0: authenticated
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in 
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in 
authenticate state - ignored
wlan0: RX AssocResp from 00:0c:41:19:2d:c1 (capab=0x1 status=0 aid=2)
wlan0: associated
ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
wlan0: disassociate(reason=3)
wlan0: association frame received from 00:0c:41:19:2d:c1, but not in 
associate state - ignored
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: deauthenticated
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: RX authentication from 00:0c:41:19:2d:c1 (alg=0 transaction=2 
status=0)
wlan0: authenticated
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: RX ReassocResp from 00:0c:41:19:2d:c1 (capab=0x1 status=0 aid=3)
wlan0: associated
wlan0: disassociate(reason=3)
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: deauthenticated
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: RX authentication from 00:0c:41:19:2d:c1 (alg=0 transaction=2 
status=0)
wlan0: authenticated
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: association with AP 00:0c:41:19:2d:c1 timed out
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in 
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in 
authenticate state - ignored
wlan0: association frame received from 00:0c:41:19:2d:c1, but not in 
associate state - ignored
wlan0: association frame received from 00:0c:41:19:2d:c1, but not in 
associate state - ignored
wlan0: association frame received from 00:0c:41:19:2d:c1, but not in 
associate state - ignored
wlan0: no IPv6 routers present

thanks u all for helping 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 831 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From rugg.argos at tiscali.it  Sat Nov 10 10:14:11 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Sat, 10 Nov 2007 10:14:11 +0100
Subject: Help with wireless on Fedora 8
References: <000b01c8231a$b78c82a0$0601a8c0@ruggiero>
	<001001c8231c$04413d60$0601a8c0@ruggiero>
	<4734E1BC.1060608@lwfinger.net>
	<20071110002158.GB32472@tuxdriver.com>
Message-ID: <001001c8237a$0f0b9a20$0601a8c0@ruggiero>

here there are new informations after
upgrading the kernel,i tried to connect first with NetworkManager and then 
with
System->Administration->Network and then activating interface :



b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
Registered led device: b43-phy0:tx
Registered led device: b43-phy0:rx
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
input: Unspecified device as /class/input/input10
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Adding Interface type 2
ADDRCONF(NETDEV_UP): wlan0: link is not ready
[drm] Initialized drm 1.1.0 20060810
[drm] Initialized i915 1.6.0 20060119 on minor 0
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authentication with AP 00:0c:41:19:2d:c1 timed out
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
authenticate state - ignored
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authentication with AP 00:0c:41:19:2d:c1 timed out
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
authenticate state - ignored
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: RX authentication from 00:0c:41:19:2d:c1 (alg=0 transaction=2
status=0)
wlan0: authenticated
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
authenticate state - ignored
wlan0: RX AssocResp from 00:0c:41:19:2d:c1 (capab=0x1 status=0 aid=2)
wlan0: associated
ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
wlan0: disassociate(reason=3)
wlan0: association frame received from 00:0c:41:19:2d:c1, but not in
associate state - ignored
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: deauthenticated
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: RX authentication from 00:0c:41:19:2d:c1 (alg=0 transaction=2
status=0)
wlan0: authenticated
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: RX ReassocResp from 00:0c:41:19:2d:c1 (capab=0x1 status=0 aid=3)
wlan0: associated
wlan0: disassociate(reason=3)
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: deauthenticated
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: RX deauthentication from 00:0c:41:19:2d:c1 (reason=6)
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: RX authentication from 00:0c:41:19:2d:c1 (alg=0 transaction=2
status=0)
wlan0: authenticated
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: association with AP 00:0c:41:19:2d:c1 timed out
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
authenticate state - ignored
wlan0: authentication frame received from 00:0c:41:19:2d:c1, but not in
authenticate state - ignored
wlan0: association frame received from 00:0c:41:19:2d:c1, but not in
associate state - ignored
wlan0: association frame received from 00:0c:41:19:2d:c1, but not in
associate state - ignored
wlan0: association frame received from 00:0c:41:19:2d:c1, but not in
associate state - ignored
wlan0: no IPv6 routers present

thanks u all for helping


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 831 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From rugg.argos at tiscali.it  Sat Nov 10 11:57:49 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Sat, 10 Nov 2007 11:57:49 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net><000b01c8231a$b78c82a0$0601a8c0@ruggiero><001001c8231c$04413d60$0601a8c0@ruggiero><4734E1EC.1040107@lwfinger.net>
	<000801c82379$ea3d4cc0$0601a8c0@ruggiero>
Message-ID: <000401c82388$8a090330$0601a8c0@ruggiero>

ok...i think i halfed resolved the problem...now i 'm connected,i disabled 
network manager on the startup and to connect i used the classic way....by 
the way just now i notice i have a really slow ping times...and by the way i 
can't surf any site..

phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
Registered led device: b43-phy0:tx
Registered led device: b43-phy0:rx
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
input: Unspecified device as /class/input/input10
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Adding Interface type 2
ADDRCONF(NETDEV_UP): wlan0: link is not ready
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:0c:41:19:2d:c1
wlan0: RX authentication from 00:0c:41:19:2d:c1 (alg=0 transaction=2 
status=0)
wlan0: authenticated
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: associate with AP 00:0c:41:19:2d:c1
wlan0: RX AssocResp from 00:0c:41:19:2d:c1 (capab=0x1 status=0 aid=9)
wlan0: associated
ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
wlan0: no IPv6 routers present


[root at localhost ~]# ping 192.168.1.1
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_seq=1 ttl=150 time=88.2 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=150 time=169 ms
64 bytes from 192.168.1.1: icmp_seq=5 ttl=150 time=888 ms
64 bytes from 192.168.1.1: icmp_seq=6 ttl=150 time=757 ms
64 bytes from 192.168.1.1: icmp_seq=7 ttl=150 time=390 ms
64 bytes from 192.168.1.1: icmp_seq=8 ttl=150 time=105 ms


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 831 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From rugg.argos at tiscali.it  Sat Nov 10 12:11:51 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Sat, 10 Nov 2007 12:11:51 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net>
	<000b01c8231a$b78c82a0$0601a8c0@ruggiero>
	<001001c8231c$04413d60$0601a8c0@ruggiero>
	<4734E1EC.1040107@lwfinger.net>
Message-ID: <000201c8238a$b21f8bd0$0601a8c0@ruggiero>

then i can ping only router...and not any other site....pings time of the 
router are really high.. 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 831 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From mb at bu3sch.de  Sat Nov 10 16:14:03 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 10 Nov 2007 16:14:03 +0100
Subject: [PATCH] b43: silence a bogus gcc warning
Message-ID: <200711101614.03776.mb@bu3sch.de>

From: Frank Lichtenheld <frank at lichtenheld.de>

inititalise ret to 0 to avoid the following bogus warning:
  CC [M]  drivers/net/wireless/b43/debugfs.o
drivers/net/wireless/b43/debugfs.c: In function ?b43_debugfs_read?:
drivers/net/wireless/b43/debugfs.c:355: warning: ?ret? may be used uninitialized in this function

Signed-off-by: Frank Lichtenheld <frank at lichtenheld.de>
Signed-off-by: Michael Buesch <mb at bu3sch.de>

---
 drivers/net/wireless/b43/debugfs.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/debugfs.c b/drivers/net/wireless/b43/debugfs.c
index 734e70e..d8ac058 100644
--- a/drivers/net/wireless/b43/debugfs.c
+++ b/drivers/net/wireless/b43/debugfs.c
@@ -352,7 +352,7 @@ static ssize_t b43_debugfs_read(struct file *file, char __user *userbuf,
 	struct b43_wldev *dev;
 	struct b43_debugfs_fops *dfops;
 	struct b43_dfs_file *dfile;
-	ssize_t ret;
+	ssize_t ret = 0;
 	char *buf;
 	const size_t bufsize = 1024 * 128;
 	const size_t buforder = get_order(bufsize);
-- 
1.5.3.4



-------------------------------------------------------

-- 
Greetings Michael.


From mb at bu3sch.de  Sat Nov 10 16:24:50 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 10 Nov 2007 16:24:50 +0100
Subject: [PATCH] b43: Output message at startup if hardware switch for
	radio is off
In-Reply-To: <4734e389.AF3t4zZIQw1IryOf%Larry.Finger@lwfinger.net>
References: <4734e389.AF3t4zZIQw1IryOf%Larry.Finger@lwfinger.net>
Message-ID: <200711101624.50808.mb@bu3sch.de>

On Friday 09 November 2007 23:47:37 Larry Finger wrote:
> Now that the radio is controlled by rfkill, there is a potential
> difficulty in helping a new user get started, as it is unlikely
> that they will have setup rfkill. This patch prints a message if
> the interface is started with the hardware switch off.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John,
> 
> This patch is intended for the everything branch of wireless-2.6.
> 
> Larry

Well... Pressing the rfkill button is the _FIRST_ thing that I would
do, if the device does not work. I'm wondering why people have a problem
with that. On other operating systems it's the very same. On Windows there
is no dmesg.

-- 
Greetings Michael.


From linville at tuxdriver.com  Sat Nov 10 16:25:33 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Sat, 10 Nov 2007 10:25:33 -0500
Subject: [PATCH] b43: silence a bogus gcc warning
In-Reply-To: <200711101614.03776.mb@bu3sch.de>
References: <200711101614.03776.mb@bu3sch.de>
Message-ID: <20071110152533.GC32472@tuxdriver.com>

On Sat, Nov 10, 2007 at 04:14:03PM +0100, Michael Buesch wrote:
> From: Frank Lichtenheld <frank at lichtenheld.de>
> 
> inititalise ret to 0 to avoid the following bogus warning:
>   CC [M]  drivers/net/wireless/b43/debugfs.o
> drivers/net/wireless/b43/debugfs.c: In function ?b43_debugfs_read?:
> drivers/net/wireless/b43/debugfs.c:355: warning: ?ret? may be used uninitialized in this function
> 
> Signed-off-by: Frank Lichtenheld <frank at lichtenheld.de>
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

Isn't this what uninitialized_var() is for?

-- 
John W. Linville
linville at tuxdriver.com


From rugg.argos at tiscali.it  Sat Nov 10 17:22:42 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Sat, 10 Nov 2007 17:22:42 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net>
	<000b01c8231a$b78c82a0$0601a8c0@ruggiero>
	<001001c8231c$04413d60$0601a8c0@ruggiero>
	<4734E1EC.1040107@lwfinger.net>
Message-ID: <000201c823b5$eb8c6ac0$0601a8c0@ruggiero>

i loaded the old kernel always not starting network manager...i'm able to 
open some website....but connection is really...really slow...any suggestion 
about? 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 832 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From mb at bu3sch.de  Sat Nov 10 17:27:43 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 10 Nov 2007 17:27:43 +0100
Subject: [PATCH] b43: silence a bogus gcc warning
In-Reply-To: <20071110152533.GC32472@tuxdriver.com>
References: <200711101614.03776.mb@bu3sch.de>
	<20071110152533.GC32472@tuxdriver.com>
Message-ID: <200711101727.43736.mb@bu3sch.de>

On Saturday 10 November 2007 16:25:33 John W. Linville wrote:
> On Sat, Nov 10, 2007 at 04:14:03PM +0100, Michael Buesch wrote:
> > From: Frank Lichtenheld <frank at lichtenheld.de>
> > 
> > inititalise ret to 0 to avoid the following bogus warning:
> >   CC [M]  drivers/net/wireless/b43/debugfs.o
> > drivers/net/wireless/b43/debugfs.c: In function ?b43_debugfs_read?:
> > drivers/net/wireless/b43/debugfs.c:355: warning: ?ret? may be used uninitialized in this function
> > 
> > Signed-off-by: Frank Lichtenheld <frank at lichtenheld.de>
> > Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> Isn't this what uninitialized_var() is for?
> 

I'd be OK with that, too.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sat Nov 10 17:29:22 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 10 Nov 2007 10:29:22 -0600
Subject: BCM94311MCG
In-Reply-To: <000201c823b5$eb8c6ac0$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net>
	<000b01c8231a$b78c82a0$0601a8c0@ruggiero>
	<001001c8231c$04413d60$0601a8c0@ruggiero>
	<4734E1EC.1040107@lwfinger.net>
	<000201c823b5$eb8c6ac0$0601a8c0@ruggiero>
Message-ID: <4735DC62.3050909@lwfinger.net>

Ruggiero wrote:
> i loaded the old kernel always not starting network manager...i'm able 
> to open some website....but connection is really...really slow...any 
> suggestion about?

Have you used ndiswrapper with this interface and AP? If so, is it also slow, or is it OK?

You might try blacklisting ipv6, if you are using only ipv4. It has been known to slow down 
communications.

Larry




From rugg.argos at tiscali.it  Sat Nov 10 17:31:23 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Sat, 10 Nov 2007 17:31:23 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net>
	<000b01c8231a$b78c82a0$0601a8c0@ruggiero>
	<001001c8231c$04413d60$0601a8c0@ruggiero>
	<4734E1EC.1040107@lwfinger.net>
	<000201c823b5$eb8c6ac0$0601a8c0@ruggiero>
	<4735DC62.3050909@lwfinger.net>
Message-ID: <000801c823b7$225bfba0$0601a8c0@ruggiero>

yes i tried with ndiswrapper in ubuntu and speed was ok and also with 
windows speed is ok,just now i can't get speed faster than 28kB/sec... i 
know that i look a bit stupid but how can i blacklist ipv6?
thanks 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 832 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From mauritsd at xs4all.nl  Sat Nov 10 17:40:22 2007
From: mauritsd at xs4all.nl (Maurits Dijkstra)
Date: Sat, 10 Nov 2007 17:40:22 +0100 (CET)
Subject: b43 on a Linksys WRT54GL
Message-ID: <51471.212.123.219.162.1194712822.squirrel@home.parabolic.nl>

Hi all,

The last few days I've been trying to get b43 to work on my WRT54GL
wlan-router. The reason I've been trying this is because I want to use the
device as a bridge between the local university wlan and my own local
network. However, because the network I'm trying to connect to is part of
the academic eduroam infrastructure I need 802.1x with dynamic WEP keying.

The proprietary broadcom drivers do not seem to support wpa_supplicant or
xsupplicant as they do not implement (much of) the standard linux wireless
extensions. There is a broadcom-specific driver for wpa_supplicant, but it
is broken, and it would be nice to get rid of the binary-only driver
altogether, not patch it up with yet another hack. So I set out to get b43
working. After a few hours of tinkering I got the driver to insert and
load the firmware:

b43-phy0: Broadcom 5352 WLAN found
b43-phy0 debug: Found PHY: Analog 2, Type 2, Revision 7
b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
b43-phy0 debug: DebugFS (CONFIG_DEBUG_FS) not enabled in kernel config
phy0: Selected rate control algorithm 'simple'
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 32-bit DMA initialized
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Adding Interface type 2

So far so good, I thought. But when I tried to actually do anything with
the interface this message appeared in dmesg:

b43-phy0 warning: Invalid max-TX-power value in SPROM.

The driver itself responds to commands, but scanning finds nothing and
trying to associate to access points doesn't work either. Also, the MAC
addresses for both the wmaster0 and wlan0 interfaces are zeroed out:

wlan0     Link encap:Ethernet  HWaddr 00:00:00:00:00:00
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

wmaster0  Link encap:UNSPEC  HWaddr
00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

I've tried b43 from a git tree I pulled yesterday evening on openwrt
kamikaze svn trunk (r9519), running linux 2.6.23.1. My SSB info is:

ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x0E, vendor 0x4243)
ssb: Core 1 found: Fast Ethernet (cc 0x806, rev 0x09, vendor 0x4243)
ssb: Core 2 found: MIPS 3302 (cc 0x816, rev 0x06, vendor 0x4243)
ssb: Core 3 found: USB 1.1 Host (cc 0x817, rev 0x02, vendor 0x4243)
ssb: Core 4 found: MEMC SDRAM (cc 0x80F, rev 0x01, vendor 0x4243)
ssb: Core 5 found: IEEE 802.11 (cc 0x812, rev 0x09, vendor 0x4243)
ssb: Core 6 found: Roboswitch (cc 0x81C, rev 0x02, vendor 0x4243)
ssb: Initializing MIPS core...
ssb: set_irq: core 0x0806, irq 2 => 2
ssb: set_irq: core 0x0817, irq 4 => 3
ssb: set_irq: core 0x0812, irq 0 => 4
ssb: Sonics Silicon Backplane found at address 0x18000000

If I were to take a fairly uneducated guess, I'd say the driver is not
recognizing the layout of the SPROM correctly, since it doesn't seem to be
able to find  correct values for the MAC address and TX-power, both of
which should be stored there...

Is there anyone who knows what's wrong or can provide pointers on where to
look? Any help would be greatly appreciated and I wouldn't mind getting my
own hands dirty to fix it. :)

Maurits Dijkstra



From larry.finger at lwfinger.net  Sat Nov 10 17:41:57 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 10 Nov 2007 10:41:57 -0600
Subject: BCM94311MCG
In-Reply-To: <000801c823b7$225bfba0$0601a8c0@ruggiero>
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net>	<000b01c8231a$b78c82a0$0601a8c0@ruggiero>	<001001c8231c$04413d60$0601a8c0@ruggiero>	<4734E1EC.1040107@lwfinger.net>	<000201c823b5$eb8c6ac0$0601a8c0@ruggiero>	<4735DC62.3050909@lwfinger.net>
	<000801c823b7$225bfba0$0601a8c0@ruggiero>
Message-ID: <4735DF55.5080205@lwfinger.net>

Ruggiero wrote:
> yes i tried with ndiswrapper in ubuntu and speed was ok and also with 
> windows speed is ok,just now i can't get speed faster than 28kB/sec... i 
> know that i look a bit stupid but how can i blacklist ipv6?
> thanks 
Add it to /etc/modprobe.d/blacklist. For a single trial, you could also 'modprobe -rv ipv6'.

Larry


From rugg.argos at tiscali.it  Sat Nov 10 17:52:49 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Sat, 10 Nov 2007 17:52:49 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net>
	<000b01c8231a$b78c82a0$0601a8c0@ruggiero>
	<001001c8231c$04413d60$0601a8c0@ruggiero>
	<4734E1EC.1040107@lwfinger.net>
	<000201c823b5$eb8c6ac0$0601a8c0@ruggiero>
	<4735DC62.3050909@lwfinger.net>
	<000801c823b7$225bfba0$0601a8c0@ruggiero>
	<4735DF55.5080205@lwfinger.net>
Message-ID: <000f01c823ba$20e24c90$0601a8c0@ruggiero>

i followed your suggestions...but the speed is always the same... :S have no 
idea of what i could do? by the way now i'm connected to the ap...if there 
aren't any chances i'll go back to ndiswrapper :(
thanks u all for helping 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 832 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From larry.finger at lwfinger.net  Sat Nov 10 18:14:17 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 10 Nov 2007 11:14:17 -0600
Subject: b43 on a Linksys WRT54GL
In-Reply-To: <51471.212.123.219.162.1194712822.squirrel@home.parabolic.nl>
References: <51471.212.123.219.162.1194712822.squirrel@home.parabolic.nl>
Message-ID: <4735E6E9.3020309@lwfinger.net>

Maurits Dijkstra wrote:
> Hi all,
> 
> The last few days I've been trying to get b43 to work on my WRT54GL
> wlan-router. The reason I've been trying this is because I want to use the
> device as a bridge between the local university wlan and my own local
> network. However, because the network I'm trying to connect to is part of
> the academic eduroam infrastructure I need 802.1x with dynamic WEP keying.
> 
> The proprietary broadcom drivers do not seem to support wpa_supplicant or
> xsupplicant as they do not implement (much of) the standard linux wireless
> extensions. There is a broadcom-specific driver for wpa_supplicant, but it
> is broken, and it would be nice to get rid of the binary-only driver
> altogether, not patch it up with yet another hack. So I set out to get b43
> working. After a few hours of tinkering I got the driver to insert and
> load the firmware:
> 
> b43-phy0: Broadcom 5352 WLAN found
> b43-phy0 debug: Found PHY: Analog 2, Type 2, Revision 7
> b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> b43-phy0 debug: DebugFS (CONFIG_DEBUG_FS) not enabled in kernel config
> phy0: Selected rate control algorithm 'simple'
> b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy0 debug: Chip initialized
> b43-phy0 debug: 32-bit DMA initialized
> b43-phy0 debug: Wireless interface started
> b43-phy0 debug: Adding Interface type 2
> 
> So far so good, I thought. But when I tried to actually do anything with
> the interface this message appeared in dmesg:
> 
> b43-phy0 warning: Invalid max-TX-power value in SPROM.
> 
> The driver itself responds to commands, but scanning finds nothing and
> trying to associate to access points doesn't work either. Also, the MAC
> addresses for both the wmaster0 and wlan0 interfaces are zeroed out:
> 
> wlan0     Link encap:Ethernet  HWaddr 00:00:00:00:00:00
>           UP BROADCAST MULTICAST  MTU:1500  Metric:1
>           RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>           TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>           collisions:0 txqueuelen:1000
>           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
> 
> wmaster0  Link encap:UNSPEC  HWaddr
> 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
>           UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
>           RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>           TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>           collisions:0 txqueuelen:1000
>           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
> 
> I've tried b43 from a git tree I pulled yesterday evening on openwrt
> kamikaze svn trunk (r9519), running linux 2.6.23.1. My SSB info is:
> 
> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x0E, vendor 0x4243)
> ssb: Core 1 found: Fast Ethernet (cc 0x806, rev 0x09, vendor 0x4243)
> ssb: Core 2 found: MIPS 3302 (cc 0x816, rev 0x06, vendor 0x4243)
> ssb: Core 3 found: USB 1.1 Host (cc 0x817, rev 0x02, vendor 0x4243)
> ssb: Core 4 found: MEMC SDRAM (cc 0x80F, rev 0x01, vendor 0x4243)
> ssb: Core 5 found: IEEE 802.11 (cc 0x812, rev 0x09, vendor 0x4243)
> ssb: Core 6 found: Roboswitch (cc 0x81C, rev 0x02, vendor 0x4243)
> ssb: Initializing MIPS core...
> ssb: set_irq: core 0x0806, irq 2 => 2
> ssb: set_irq: core 0x0817, irq 4 => 3
> ssb: set_irq: core 0x0812, irq 0 => 4
> ssb: Sonics Silicon Backplane found at address 0x18000000
> 
> If I were to take a fairly uneducated guess, I'd say the driver is not
> recognizing the layout of the SPROM correctly, since it doesn't seem to be
> able to find  correct values for the MAC address and TX-power, both of
> which should be stored there...
> 
> Is there anyone who knows what's wrong or can provide pointers on where to
> look? Any help would be greatly appreciated and I wouldn't mind getting my
> own hands dirty to fix it. :)

In the past few days, I have discovered that the SPROM revision 3 layout doesn't match the specs. To
dump the SPROM, I used the following patch:

Index: linux-2.6/drivers/ssb/pci.c
===================================================================
--- linux-2.6.orig/drivers/ssb/pci.c
+++ linux-2.6/drivers/ssb/pci.c
@@ -457,6 +457,7 @@ static int ssb_pci_sprom_get(struct ssb_
 {
        int err = -ENOMEM;
        u16 *buf;
+       int i;

        buf = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
        if (!buf)
@@ -467,6 +468,12 @@ static int ssb_pci_sprom_get(struct ssb_
                ssb_printk(KERN_WARNING PFX
                           "WARNING: Invalid SPROM CRC (corrupt SPROM)\n");
        }
+       printk("ssb: SPROM DUMP\nssb: 0x0000: ");
+       for (i=0; i < SSB_SPROMSIZE_WORDS; i++) {
+               printk("0x%.4X", buf[i]);
+               if ((i % 8) == 7) printk("\nssb: 0x%.4X: ", (i + 1) * 2);
+       }
+       printk("\n");
        err = sprom_extract(bus, sprom, buf);

        kfree(buf);

I think your system doesn't use PCI, so this probably won't work, but you should be able to
implement something similar. Once you have a dump, you should be able to find the MAC addresses of
the wireless and ethernet interfaces.

Larry



From ranma at tdiedrich.de  Sat Nov 10 20:55:01 2007
From: ranma at tdiedrich.de (Tobias Diedrich)
Date: Sat, 10 Nov 2007 20:55:01 +0100
Subject: b43 on a Linksys WRT54GL
In-Reply-To: <4735E6E9.3020309@lwfinger.net>
References: <51471.212.123.219.162.1194712822.squirrel@home.parabolic.nl>
	<4735E6E9.3020309@lwfinger.net>
Message-ID: <20071110195501.GA12003@yamamaya.is-a-geek.org>

Larry Finger wrote:

> I think your system doesn't use PCI, so this probably won't work,
> but you should be able to implement something similar. Once you
> have a dump, you should be able to find the MAC addresses of the
> wireless and ethernet interfaces.

IIRC the WRTs don't have a sprom, instead its stored in their nvram
flash area:

For a WRT54GS v1.1:
root at OpenWrt:~# nvram show | grep -E "^(wl0[^_]|pa0|board|et0|il0)"
size: 7749 bytes (25019 left)
boardrev=0x10
il0macaddr=00:12:17:15:fe:9e
et0macaddr=00:12:17:15:FE:9C
et0mdcport=0
boardtype=0x0101
wl0id=0x4320
wl0gpio2=0
wl0gpio3=0
boardflags2=0
pa0itssit=62
pa0maxpwr=0x48
boardflags=0x0188
et0phyaddr=30
pa0b0=0x170c
pa0b1=0xfa24
pa0b2=0xfe70
boardnum=42



For a WRT54GL v1.?:
root at linksys2:~# nvram show | grep -E "^(wl0[^_]|pa0|board|et0|il0)"
size: 1771 bytes (30997 left)
boardrev=0x10
il0macaddr=00:13:10:3f:35:27
et0macaddr=00:13:10:3F:35:25
et0mdcport=0
boardtype=0x0708
wl0id=0x4320
wl0gpio2=0
wl0gpio3=0
boardflags2=0
pa0itssit=62
pa0maxpwr=0x4e
boardflags=0x0118
et0phyaddr=30
pa0b0=0x15eb
pa0b1=0xfa82
pa0b2=0xfe66
boardnum=42

An older bcm47xx patch had this part in bcm43xx_main.c to fetch the
values from nvram:
#ifdef CONFIG_BCM947XX
	/* In the case some settings are found in nvram, use them
	 * to override those read from sprom.
	 */
	c = nvram_get("boardflags2");
	if (c)
		sprom[BCM43xx_SPROM_BOARDFLAGS2] = simple_strtoul(c, NULL, 0);
        c = nvram_get("boardflags");
	if (c)
		sprom[BCM43xx_SPROM_BOARDFLAGS] = simple_strtoul(c, NULL, 0);
	c = nvram_get("il0macaddr");
	if (c)
		bcm43xx_aton(c, (char *)&(sprom[BCM43xx_SPROM_IL0MACADDR]));
	c = nvram_get("et1macaddr");
	if (c)
		bcm43xx_aton(c, (char *)&(sprom[BCM43xx_SPROM_ET1MACADDR]));
	c = nvram_get("pa0b0");
	if (c)
		sprom[BCM43xx_SPROM_PA0B0] = simple_strtoul(c, NULL, 0);
	c = nvram_get("pa0b1");
	if (c)
		sprom[BCM43xx_SPROM_PA0B1] = simple_strtoul(c, NULL, 0);
	c = nvram_get("pa0b2");
	if (c)
		sprom[BCM43xx_SPROM_PA0B2] = simple_strtoul(c, NULL, 0);
	c = nvram_get("pa1b0");
	if (c)
		sprom[BCM43xx_SPROM_PA1B0] = simple_strtoul(c, NULL, 0);
	c = nvram_get("pa1b1");
	if (c)
		sprom[BCM43xx_SPROM_PA1B1] = simple_strtoul(c, NULL, 0);
	c = nvram_get("pa1b2");
	if (c)
		sprom[BCM43xx_SPROM_PA1B2] = simple_strtoul(c, NULL, 0);
	c = nvram_get("boardrev");
	if (c)
		sprom[BCM43xx_SPROM_BOARDREV] = simple_strtoul(c, NULL, 0);
#endif

-- 
Tobias						PGP: http://9ac7e0bc.uguu.de
??????????????????????????


From rmckibbe at bellsouth.net  Sun Nov 11 05:23:22 2007
From: rmckibbe at bellsouth.net (rob m)
Date: Sat, 10 Nov 2007 22:23:22 -0600
Subject: unsubcribe
Message-ID: <473683BA.6080207@bellsouth.net>




From mb at bu3sch.de  Sun Nov 11 12:23:54 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 11 Nov 2007 12:23:54 +0100
Subject: [PATCH] b43: silence a bogus gcc warning
In-Reply-To: <20071111092703.GQ2961@planck.djpig.de>
References: <200711101614.03776.mb@bu3sch.de> <200711101727.43736.mb@bu3sch.de>
	<20071111092703.GQ2961@planck.djpig.de>
Message-ID: <200711111223.55055.mb@bu3sch.de>

On Sunday 11 November 2007 10:27:03 Frank Lichtenheld wrote:
> On Sat, Nov 10, 2007 at 05:27:43PM +0100, Michael Buesch wrote:
> > On Saturday 10 November 2007 16:25:33 John W. Linville wrote:
> > > On Sat, Nov 10, 2007 at 04:14:03PM +0100, Michael Buesch wrote:
> > > > From: Frank Lichtenheld <frank at lichtenheld.de>
> > > > 
> > > > inititalise ret to 0 to avoid the following bogus warning:
> > > >   CC [M]  drivers/net/wireless/b43/debugfs.o
> > > > drivers/net/wireless/b43/debugfs.c: In function ?b43_debugfs_read?:
> > > > drivers/net/wireless/b43/debugfs.c:355: warning: ?ret? may be used uninitialized in this function
> > > > 
> > > > Signed-off-by: Frank Lichtenheld <frank at lichtenheld.de>
> > > > Signed-off-by: Michael Buesch <mb at bu3sch.de>
> > > 
> > > Isn't this what uninitialized_var() is for?
> 
> Erh, I didn't actually knew that existed, sorry.
> OTOH in this case it is actually longer to write.
> 
> > I'd be OK with that, too.
> 
> Should I send a changed patch?

Yes.

-- 
Greetings Michael.


From evanfoss at gmail.com  Mon Nov 12 05:50:53 2007
From: evanfoss at gmail.com (evan foss)
Date: Sun, 11 Nov 2007 23:50:53 -0500
Subject: Request for information
In-Reply-To: <4a55afb80711101512i4b0e264fudfaead528767da99@mail.gmail.com>
References: <473336F2.9090200@lwfinger.net>
	<4a55afb80711101512i4b0e264fudfaead528767da99@mail.gmail.com>
Message-ID: <4a55afb80711112050i335fd62dt16ee816fb7a36525@mail.gmail.com>

Sorry I meant to send this to the list.

On Nov 10, 2007 6:12 PM, evan foss <evanfoss at gmail.com> wrote:
> I am not sure if this is correct as I still don't have the b43 driver
> working but here is my boxes data.
>
> 0130000063133C100800BE0D00FFFFFF11430080020000000010001800000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF1400B7A51554FFFFFFFFFFFFFFFFFFFFFFFFFFFF42303D15A0FA79FEFF83FFFF4AFFFFFFFFFFFFFF3EFF494A02FF53550CFFFFFFFFFF020A
>
> The box is a compaq v3019us the chip is a bcm4311. For some reason the
> lspci reads this instead of what it read under 2.6.20-r6.
>
> 01:00.0 Network controller: Broadcom Corporation BCM94311MCG wlan
> mini-PCI (rev 01)
>         Subsystem: Hewlett-Packard Company Unknown device 1363
>         Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR+ FastB2B- DisINTx-
>         Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort-
> <TAbort- <MAbort- >SERR- <PERR- INTx-
>         Latency: 0, Cache Line Size: 64 bytes
>         Interrupt: pin A routed to IRQ 19
>         Region 0: Memory at c3000000 (32-bit, non-prefetchable) [size=16K]
>         Capabilities: [40] Power Management version 2
>                 Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=375mA PME(D0-,D1-,D2-,D3hot-,D3cold-)
>                 Status: D0 PME-Enable- DSel=0 DScale=2 PME-
>         Capabilities: [58] Message Signalled Interrupts: Mask- 64bit- Queue=0/0 Enable-
>                 Address: 00000000  Data: 0000
>         Capabilities: [d0] Express (v1) Legacy Endpoint, MSI 00
>                 DevCap: MaxPayload 128 bytes, PhantFunc 0, Latency L0s <4us, L1 unlimited
>                         ExtTag+ AttnBtn- AttnInd- PwrInd- RBE- FLReset-
>                 DevCtl: Report errors: Correctable- Non-Fatal- Fatal- Unsupported-
>                         RlxdOrd- ExtTag- PhantFunc- AuxPwr- NoSnoop-
>                         MaxPayload 128 bytes, MaxReadReq 128 bytes
>                 DevSta: CorrErr- UncorrErr- FatalErr- UnsuppReq- AuxPwr- TransPend-
>                 LnkCap: Port #0, Speed 2.5GT/s, Width x1, ASPM L0s, Latency L0 <4us, L1 <64us
>                         ClockPM- Suprise- LLActRep- BwNot-
>                 LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- Retrain- CommClk-
>                         ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
>                 LnkSta: Speed 2.5GT/s, Width x1, TrErr- Train- SlotClk+ DLActive-
> BWMgmt- ABWMgmt-
>         Capabilities: [100] Advanced Error Reporting
>         Capabilities: [13c] Virtual Channel
>
> --
> http://www.coe.neu.edu/~efoss/
> http://evanfoss.googlepages.com/
>



-- 
http://www.coe.neu.edu/~efoss/
http://evanfoss.googlepages.com/


From gavron at Wetwork.Net  Mon Nov 12 05:59:48 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Sun, 11 Nov 2007 21:59:48 -0700
Subject: Request for information
In-Reply-To: <4a55afb80711112050i335fd62dt16ee816fb7a36525@mail.gmail.com>
References: <473336F2.9090200@lwfinger.net>
	<4a55afb80711101512i4b0e264fudfaead528767da99@mail.gmail.com>
	<4a55afb80711112050i335fd62dt16ee816fb7a36525@mail.gmail.com>
Message-ID: <4737DDC4.2020702@Wetwork.Net>

Based on your problem description...
there isn't one.

Based on your uname -a ...
there isn't one.

Based on your dmesg...
there isn't one.

This is like a "locked room mystery", right, you want us to "solve the 
problem" without the problem being
a. mentioned
b. described
c. error messages mentioned
or even
d. the environment described.

Wow, you have a lot of faith.

Ehud
PS Good thing you have two whole web pages!  Perhaps that way you can be 
famous in your genius.

evan foss wrote:
> Sorry I meant to send this to the list.
>
> On Nov 10, 2007 6:12 PM, evan foss <evanfoss at gmail.com> wrote:
>   
>> I am not sure if this is correct as I still don't have the b43 driver
>> working but here is my boxes data.
>>
>> 0130000063133C100800BE0D00FFFFFF11430080020000000010001800000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF1400B7A51554FFFFFFFFFFFFFFFFFFFFFFFFFFFF42303D15A0FA79FEFF83FFFF4AFFFFFFFFFFFFFF3EFF494A02FF53550CFFFFFFFFFF020A
>>
>> The box is a compaq v3019us the chip is a bcm4311. For some reason the
>> lspci reads this instead of what it read under 2.6.20-r6.
>>
>> 01:00.0 Network controller: Broadcom Corporation BCM94311MCG wlan
>> mini-PCI (rev 01)
>>         Subsystem: Hewlett-Packard Company Unknown device 1363
>>         Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
>> Stepping- SERR+ FastB2B- DisINTx-
>>         Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort-
>> <TAbort- <MAbort- >SERR- <PERR- INTx-
>>         Latency: 0, Cache Line Size: 64 bytes
>>         Interrupt: pin A routed to IRQ 19
>>         Region 0: Memory at c3000000 (32-bit, non-prefetchable) [size=16K]
>>         Capabilities: [40] Power Management version 2
>>                 Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=375mA PME(D0-,D1-,D2-,D3hot-,D3cold-)
>>                 Status: D0 PME-Enable- DSel=0 DScale=2 PME-
>>         Capabilities: [58] Message Signalled Interrupts: Mask- 64bit- Queue=0/0 Enable-
>>                 Address: 00000000  Data: 0000
>>         Capabilities: [d0] Express (v1) Legacy Endpoint, MSI 00
>>                 DevCap: MaxPayload 128 bytes, PhantFunc 0, Latency L0s <4us, L1 unlimited
>>                         ExtTag+ AttnBtn- AttnInd- PwrInd- RBE- FLReset-
>>                 DevCtl: Report errors: Correctable- Non-Fatal- Fatal- Unsupported-
>>                         RlxdOrd- ExtTag- PhantFunc- AuxPwr- NoSnoop-
>>                         MaxPayload 128 bytes, MaxReadReq 128 bytes
>>                 DevSta: CorrErr- UncorrErr- FatalErr- UnsuppReq- AuxPwr- TransPend-
>>                 LnkCap: Port #0, Speed 2.5GT/s, Width x1, ASPM L0s, Latency L0 <4us, L1 <64us
>>                         ClockPM- Suprise- LLActRep- BwNot-
>>                 LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- Retrain- CommClk-
>>                         ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
>>                 LnkSta: Speed 2.5GT/s, Width x1, TrErr- Train- SlotClk+ DLActive-
>> BWMgmt- ABWMgmt-
>>         Capabilities: [100] Advanced Error Reporting
>>         Capabilities: [13c] Virtual Channel
>>
>> --
>> http://www.coe.neu.edu/~efoss/
>> http://evanfoss.googlepages.com/
>>
>>     
>
>
>
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071111/bf63ed6c/attachment.bin>

From larry.finger at lwfinger.net  Mon Nov 12 06:11:33 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 11 Nov 2007 23:11:33 -0600
Subject: Request for information
In-Reply-To: <4737DDC4.2020702@Wetwork.Net>
References: <473336F2.9090200@lwfinger.net>	<4a55afb80711101512i4b0e264fudfaead528767da99@mail.gmail.com>	<4a55afb80711112050i335fd62dt16ee816fb7a36525@mail.gmail.com>
	<4737DDC4.2020702@Wetwork.Net>
Message-ID: <4737E085.4090704@lwfinger.net>

Ehud Gavron wrote:
> Based on your problem description...
> there isn't one.
> 
> Based on your uname -a ...
> there isn't one.
> 
> Based on your dmesg...
> there isn't one.
> 
> This is like a "locked room mystery", right, you want us to "solve the
> problem" without the problem being
> a. mentioned
> b. described
> c. error messages mentioned
> or even
> d. the environment described.
> 
> Wow, you have a lot of faith.
> 
> Ehud
> PS Good thing you have two whole web pages!  Perhaps that way you can be
> famous in your genius.

He doesn't have a problem. He was just sending me the contents of his SPROM. It was a rev 2, so I'm
not interested anyway.

Larry


From rugg.argos at tiscali.it  Mon Nov 12 12:44:00 2007
From: rugg.argos at tiscali.it (Ruggiero)
Date: Mon, 12 Nov 2007 12:44:00 +0100
Subject: BCM94311MCG
References: <001e01c82162$864cc970$0601a8c0@ruggiero><4731FE46.1060403@lwfinger.net><003701c82179$da3f4c80$0601a8c0@ruggiero><47329750.7080505@lwfinger.net><000601c821dd$09fc0720$0601a8c0@ruggiero><473330FF.4090605@lwfinger.net><000601c82225$7bc63220$0601a8c0@ruggiero><1194555637.25768.7.camel@dv><000001c822ce$cb1b9910$0601a8c0@ruggiero><47348492.3070605@lwfinger.net><000301c822f3$73dbef90$0601a8c0@ruggiero><4734973D.4060703@lwfinger.net><000301c82301$eafbd050$0601a8c0@ruggiero><4734AF07.5040003@lwfinger.net><000301c8230e$6880b980$0601a8c0@ruggiero><4734CCFA.1020504@lwfinger.net><000301c82315$f1d71830$0601a8c0@ruggiero><4734D328.20106@lwfinger.net><000b01c8231a$b78c82a0$0601a8c0@ruggiero><001001c8231c$04413d60$0601a8c0@ruggiero><4734E1EC.1040107@lwfinger.net><000201c823b5$eb8c6ac0$0601a8c0@ruggiero><4735DC62.3050909@lwfinger.net><000801c823b7$225bfba0$0601a8c0@ruggiero><4735DF55.5080205@lwfinger.net>
	<000f01c823ba$20e24c90$0601a8c0@ruggiero>
Message-ID: <000801c82521$517b6950$0601a8c0@ruggiero>

i hope this could be useful,i installed opensuse10.3,by bcm43-fwcutter i 
extracted firmware v3,by the way i have the same problem that was on fedora 
8,i get connected,everything ok authentication...(but always disabling 
networkmanager) but the speed is always slow,not more than 30kb/s..more i 
noticed that if i get more distant from the router i can't connect...but i 
can see the access point,with a good power signal...next days i'll try on 
debian too
the access point is linksys wap11
greetings
ruggiero 


-- 
Io utilizzo la versione gratuita di SPAMfighter per utenti privati. Sino ad ora
 ha rimosso 839 mail spam. 
 Gli utenti paganti non hanno questo messaggio nelle loro email .
 Prova gratuitamente SPAMfighter qui:http://www.spamfighter.com/lit




From hs4233 at mail.mn-solutions.de  Mon Nov 12 13:36:42 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Mon, 12 Nov 2007 13:36:42 +0100
Subject: [PATCH] b43: Output message at startup if hardware switch for
	radio is off
In-Reply-To: <200711101624.50808.mb@bu3sch.de>
References: <4734e389.AF3t4zZIQw1IryOf%Larry.Finger@lwfinger.net>
	<200711101624.50808.mb@bu3sch.de>
Message-ID: <200711121336.42389.hs4233@mail.mn-solutions.de>

> Well... Pressing the rfkill button is the _FIRST_ thing that I
> would do, if the device does not work. I'm wondering why
> people have a problem with that. On other operating systems
> it's the very same. On Windows there is no dmesg.

On Windows, the "Wireless Network Connection" wizard displays

-----------------------------------------------------
No wireless networks were found in range

Make sure the wireless switch on your computer is on.
To see an updated list, click "Refresh network list".
-----------------------------------------------------

The Linux ?quivalent would be NetworkManager or the KDE tools for 
this job.


That's at least displayed on the WinXP Embedded device that I 
just created :-)


From evanfoss at gmail.com  Mon Nov 12 18:54:07 2007
From: evanfoss at gmail.com (evan foss)
Date: Mon, 12 Nov 2007 12:54:07 -0500
Subject: Request for information
In-Reply-To: <4a55afb80711120952q76e7a4e9sb3b9b21f0baf5e0a@mail.gmail.com>
References: <473336F2.9090200@lwfinger.net>
	<4a55afb80711101512i4b0e264fudfaead528767da99@mail.gmail.com>
	<4a55afb80711112050i335fd62dt16ee816fb7a36525@mail.gmail.com>
	<4737DDC4.2020702@Wetwork.Net>
	<4a55afb80711120952q76e7a4e9sb3b9b21f0baf5e0a@mail.gmail.com>
Message-ID: <4a55afb80711120954x32d2c31fyfe317039fde57e77@mail.gmail.com>

On Nov 11, 2007 11:59 PM, Ehud Gavron <gavron at wetwork.net> wrote:
> Based on your problem description...
> there isn't one.
>
> Based on your uname -a ...
> there isn't one.
>
> Based on your dmesg...
> there isn't one.
>
> This is like a "locked room mystery", right, you want us to "solve the
> problem" without the problem being
> a. mentioned
> b. described
> c. error messages mentioned
> or even
> d. the environment described.

I did describe the problem in a fair amount of detail in an email I
sent. To just Larry. I messed up the address sorry.

> Wow, you have a lot of faith.

I don't believe in god actually. I do believe in sarcasm thankfully.
With an attitude like yours who wouldn't want to ask you for help?

> Ehud
> PS Good thing you have two whole web pages!  Perhaps that way you can be
> famous in your genius.

The second one is a place holder for when I have to graduate and
shutdown my school issued space.


From evanfoss at gmail.com  Mon Nov 12 18:57:07 2007
From: evanfoss at gmail.com (evan foss)
Date: Mon, 12 Nov 2007 12:57:07 -0500
Subject: Another unknown error message?
Message-ID: <4a55afb80711120957j23d96511q45790ebd1a4ff53b@mail.gmail.com>

I can't get b43 to work. I did a git of b43 a few weeks ago and after
I was told what rate control control algorithm (rc80211_simple). That
in hand I am still having some issues. First sysfs is off but udev is
changing things in funny ways. I boot the box unload all the modules
mac80211, cfg80211, ssb, b43, etc. Then I modprobe rc80211_simple
which loads mac80211 & cfg80211.

Here is some of my dmesg after the reload....

ACPI: PCI interrupt for device 0000:01:00.0 disabled
ACPI: PCI Interrupt 0000:01:00.0[A] -> Link [LK2E] -> GSI 19 (level,
high) -> IRQ 19
PCI: Setting latency timer of device 0000:01:00.0 to 64
ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x11, vendor 0x4243)
ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0A, vendor 0x4243)
ssb: Core 2 found: USB 1.1 Host (cc 0x817, rev 0x03, vendor 0x4243)
ssb: Core 3 found: PCI-E (cc 0x820, rev 0x01, vendor 0x4243)
ssb: Sonics Silicon Backplane found on PCI device 0000:01:00.0
b43-phy1: Broadcom 4311 WLAN found
b43-phy1 debug: Found PHY: Analog 4, Type 2, Revision 8
b43-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
phy1: Selected rate control algorithm 'simple'
udev: renamed network interface wmaster0 to eth1

Then I modprobe b43. udev renames the interface from wmaster0 to eth1
which I can't bring up.....

SIOCSIFFLAGS: Operation not supported

So that is out but I have this other interface that just appears out
of no where called wlan0_rename. I can bring it up.

b43-phy2 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy2 debug: Chip initialized
b43-phy2 debug: 32-bit DMA initialized
input: Unspecified device as /devices/virtual/input/input7
b43-phy2 debug: Wireless interface started
b43-phy2 debug: Adding Interface type 2
ADDRCONF(NETDEV_UP): wlan0_rename: link is not ready
HW CONFIG: channel=1 freq=2412 phymode=2
phy2: TX to low-level driver (len=42) FC=0x0040 DUR=0x0000
A1=ff:ff:ff:ff:ff:ff A2=00:14:a5:b7:54:15 A3=ff:ff:ff:ff:ff:ff
HW CONFIG: channel=2 freq=2417 phymode=2

I can wlist wlan0_rename scan but it has issues and seems to alter
eth1. Now I haven't yet tried this at a location with good signal
quality. I just want to understand what is happening with the
interface name(s).

-- 
http://www.coe.neu.edu/~efoss/
http://evanfoss.googlepages.com/


From johannes at sipsolutions.net  Mon Nov 12 19:10:56 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 12 Nov 2007 19:10:56 +0100
Subject: Another unknown error message?
In-Reply-To: <4a55afb80711120957j23d96511q45790ebd1a4ff53b@mail.gmail.com>
	(sfid-20071112_175812_912626_5C0AAAD6)
References: <4a55afb80711120957j23d96511q45790ebd1a4ff53b@mail.gmail.com>
	(sfid-20071112_175812_912626_5C0AAAD6)
Message-ID: <1194891056.4456.13.camel@johannes.berg>


> ACPI: PCI interrupt for device 0000:01:00.0 disabled
> ACPI: PCI Interrupt 0000:01:00.0[A] -> Link [LK2E] -> GSI 19 (level,
> high) -> IRQ 19
> PCI: Setting latency timer of device 0000:01:00.0 to 64
> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x11, vendor 0x4243)
> ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0A, vendor 0x4243)
> ssb: Core 2 found: USB 1.1 Host (cc 0x817, rev 0x03, vendor 0x4243)
> ssb: Core 3 found: PCI-E (cc 0x820, rev 0x01, vendor 0x4243)
> ssb: Sonics Silicon Backplane found on PCI device 0000:01:00.0
> b43-phy1: Broadcom 4311 WLAN found
> b43-phy1 debug: Found PHY: Analog 4, Type 2, Revision 8
> b43-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> phy1: Selected rate control algorithm 'simple'
> udev: renamed network interface wmaster0 to eth1
> 
> Then I modprobe b43.

But b43 is already loaded so that's a noop.

>  udev renames the interface from wmaster0 to eth1
> which I can't bring up.....

You can't ever bring up wmaster0. You want to bring up 'wlan0' whatever
that was renamed to.

> So that is out but I have this other interface that just appears out
> of no where called wlan0_rename. I can bring it up.

Yup, that's the one.

> b43-phy2 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
> b43-phy2 debug: Chip initialized
> b43-phy2 debug: 32-bit DMA initialized
> input: Unspecified device as /devices/virtual/input/input7

That's probably rfkill.

> phy2: TX to low-level driver (len=42) FC=0x0040 DUR=0x0000
> A1=ff:ff:ff:ff:ff:ff A2=00:14:a5:b7:54:15 A3=ff:ff:ff:ff:ff:ff

Heh. You enabled too many debug options ;)

> I can wlist wlan0_rename scan but it has issues and seems to alter
> eth1. Now I haven't yet tried this at a location with good signal
> quality. I just want to understand what is happening with the
> interface name(s).

You want to ignore wmaster0 (renamed to eth1) and use wlan0. The thing
with the device names is that udev is trying to rename them both to eth1
in the order they appear because they have the same MAC address. Try
deleting the automatic udev device name stuff.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071112/20f5c9e4/attachment.pgp>

From evanfoss at gmail.com  Mon Nov 12 20:56:01 2007
From: evanfoss at gmail.com (evan foss)
Date: Mon, 12 Nov 2007 14:56:01 -0500
Subject: Another unknown error message?
In-Reply-To: <4a55afb80711121155q789a70c4k3b59131127f07405@mail.gmail.com>
References: <4a55afb80711120957j23d96511q45790ebd1a4ff53b@mail.gmail.com>
	<4738A40C.9010907@lwfinger.net>
	<4a55afb80711121155q789a70c4k3b59131127f07405@mail.gmail.com>
Message-ID: <4a55afb80711121156k60ac38a3sc3bd468b16a9f423@mail.gmail.com>

Sorry I meant to send this to the group.

On Nov 12, 2007 2:55 PM, evan foss <evanfoss at gmail.com> wrote:
>
> On Nov 12, 2007 2:05 PM, Larry Finger <larry.finger at lwfinger.net> wrote:
> > evan foss wrote:
> > > I can wlist wlan0_rename scan but it has issues and seems to alter
> > > eth1. Now I haven't yet tried this at a location with good signal
> > > quality. I just want to understand what is happening with the
> > > interface name(s).
> >
> > The device renaming is probably handled in directory /etc/udev/rules.d by a rule with "persistent"
> > and "net" in its name. On my openSUSE 10.3 system, it is called 70-persistent-net.rules. On 10.2, it
> > was 30-xxxxxxx. In this file, you should see statements like
> >
> > # PCI device 0x10de:0x0269 (forcedeth)
> > SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="00:16:d3:17:07:2e", NAME="eth0"
> >
> > # PCI device 0x14e4:0x4311 (b43, b43legacy, b43legacy)
> > SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="00:1a:73:04:1d:e5", ATTR{type}=="1", NAME="eth1"
> >
> > Your rule for the wireless device should have your MAC address (00:14:a5:b7:54:15) in the address
> > field. These rules leave the name of wmaster0 alone, at least on the version of udev that I'm using.
> >
> > Larry
> >
>
> Mine was under 70-persistent-net.rules
> I commented out the following line.
>
> # PCI device 0x14e4:0x4311 (bcm43xx)
> #SUBSYSTEM=="net", DRIVERS=="?*", ATTRS{address}=="00:14:a5:b7:54:15",
> NAME="eth1"
>
> Then reloaded the module. Which caused udev to add this.
>
> # PCI device 0x14e4:0x4311 (b43-pci-bridge)
> SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="00:14:a5:b7:54:15",
> ATTR{type}=="1", NAME="wlan0"
>
> Which seems to work fine. Except that I still get wmaster0 with wlan0.
> wlan0 gets the correct mac address but won't let me set essid. It does
> scan (iwlist). But I think wmaster0 is causing problems it has the
> same mac address as wlan0 only with a few extra zeros at the end. I
> suspect that wmaster0 is interfering with wlan0.
>
>
> --
> http://www.coe.neu.edu/~efoss/
> http://evanfoss.googlepages.com/
>



-- 
http://www.coe.neu.edu/~efoss/
http://evanfoss.googlepages.com/


From evanfoss at gmail.com  Mon Nov 12 21:29:48 2007
From: evanfoss at gmail.com (evan foss)
Date: Mon, 12 Nov 2007 15:29:48 -0500
Subject: bcm43xx + Kismet = signal and noise zero
In-Reply-To: <47348232.7090302@lwfinger.net>
References: <47327F79.7070404@bellsouth.net> <473296CD.1080309@lwfinger.net>
	<47347A1E.6080803@bellsouth.net> <47348232.7090302@lwfinger.net>
Message-ID: <4a55afb80711121229n4b29aa73ld1e9804e98b5487c@mail.gmail.com>

I have kernel 2.6.22 working at least for networking purposes and
while kismet works it does not report signal stats. Unlike him I have
smp turned on. Under a working 2.6.20-r6 configuration with your
patches it is also the same. My chip is a bcm4311. I just though you
would like the data going forward. I don't have much use for kismet so
I never really noticed this.

On Nov 9, 2007 10:52 AM, Larry Finger <larry.finger at lwfinger.net> wrote:
> DeckerXL wrote:
> > Linux bt 2.6.20-BT-PwnSauce-NOSMP #3 Sat Feb 24 15:52:59 GMT 2007 i686
> > athlon-4 i386 GNU/Linux
> >
>
> You should update to 2.6.22 or later.
>
>
> Larry
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>



-- 
http://www.coe.neu.edu/~efoss/
http://evanfoss.googlepages.com/


From larry.finger at lwfinger.net  Mon Nov 12 22:38:47 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 12 Nov 2007 15:38:47 -0600
Subject: Another unknown error message?
In-Reply-To: <4a55afb80711121155q789a70c4k3b59131127f07405@mail.gmail.com>
References: <4a55afb80711120957j23d96511q45790ebd1a4ff53b@mail.gmail.com>	
	<4738A40C.9010907@lwfinger.net>
	<4a55afb80711121155q789a70c4k3b59131127f07405@mail.gmail.com>
Message-ID: <4738C7E7.60408@lwfinger.net>

evan foss wrote:
> On Nov 12, 2007 2:05 PM, Larry Finger <larry.finger at lwfinger.net> wrote:
>> evan foss wrote:
>>> I can wlist wlan0_rename scan but it has issues and seems to alter
>>> eth1. Now I haven't yet tried this at a location with good signal
>>> quality. I just want to understand what is happening with the
>>> interface name(s).
>> The device renaming is probably handled in directory /etc/udev/rules.d by a rule with "persistent"
>> and "net" in its name. On my openSUSE 10.3 system, it is called 70-persistent-net.rules. On 10.2, it
>> was 30-xxxxxxx. In this file, you should see statements like
>>
>> # PCI device 0x10de:0x0269 (forcedeth)
>> SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="00:16:d3:17:07:2e", NAME="eth0"
>>
>> # PCI device 0x14e4:0x4311 (b43, b43legacy, b43legacy)
>> SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="00:1a:73:04:1d:e5", ATTR{type}=="1", NAME="eth1"
>>
>> Your rule for the wireless device should have your MAC address (00:14:a5:b7:54:15) in the address
>> field. These rules leave the name of wmaster0 alone, at least on the version of udev that I'm using.
>>
>> Larry
>>
> 
> Mine was under 70-persistent-net.rules
> I commented out the following line.
> 
> # PCI device 0x14e4:0x4311 (bcm43xx)
> #SUBSYSTEM=="net", DRIVERS=="?*", ATTRS{address}=="00:14:a5:b7:54:15",
> NAME="eth1"
> 
> Then reloaded the module. Which caused udev to add this.
> 
> # PCI device 0x14e4:0x4311 (b43-pci-bridge)
> SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="00:14:a5:b7:54:15",
> ATTR{type}=="1", NAME="wlan0"
> 
> Which seems to work fine. Except that I still get wmaster0 with wlan0.
> wlan0 gets the correct mac address but won't let me set essid. It does
> scan (iwlist). But I think wmaster0 is causing problems it has the
> same mac address as wlan0 only with a few extra zeros at the end. I
> suspect that wmaster0 is interfering with wlan0.

Whatever problems you are having, they are not caused by wmaster0. It is a "feature" of mac80211,
and we all have wmaster0 and a separate wlan0, or eth1. It does not get in the way.

Are you running iwconfig as root when you are trying to set essid? Setting anything requires
privilege. If you are root, what is the error message?

Larry


From evanfoss at gmail.com  Mon Nov 12 23:09:19 2007
From: evanfoss at gmail.com (evan foss)
Date: Mon, 12 Nov 2007 17:09:19 -0500
Subject: Another unknown error message?
In-Reply-To: <4a55afb80711121407g3f4d6ac5s8982efc812c9b8be@mail.gmail.com>
References: <4a55afb80711120957j23d96511q45790ebd1a4ff53b@mail.gmail.com>
	<4738A40C.9010907@lwfinger.net>
	<4a55afb80711121155q789a70c4k3b59131127f07405@mail.gmail.com>
	<4738C7E7.60408@lwfinger.net>
	<4a55afb80711121407g3f4d6ac5s8982efc812c9b8be@mail.gmail.com>
Message-ID: <4a55afb80711121409x4621339aibbb7a158739f9e33@mail.gmail.com>

On Nov 12, 2007 4:38 PM, Larry Finger <larry.finger at lwfinger.net> wrote:
>
> evan foss wrote:
> > On Nov 12, 2007 2:05 PM, Larry Finger <larry.finger at lwfinger.net> wrote:
> >> evan foss wrote:
> >>> I can wlist wlan0_rename scan but it has issues and seems to alter
> >>> eth1. Now I haven't yet tried this at a location with good signal
> >>> quality. I just want to understand what is happening with the
> >>> interface name(s).
> >> The device renaming is probably handled in directory /etc/udev/rules.d by a rule with "persistent"
> >> and "net" in its name. On my openSUSE 10.3 system, it is called 70-persistent-net.rules. On 10.2, it
> >> was 30-xxxxxxx. In this file, you should see statements like
> >>
> >> # PCI device 0x10de:0x0269 (forcedeth)
> >> SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="00:16:d3:17:07:2e", NAME="eth0"
> >>
> >> # PCI device 0x14e4:0x4311 (b43, b43legacy, b43legacy)
> >> SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="00:1a:73:04:1d:e5", ATTR{type}=="1", NAME="eth1"
> >>
> >> Your rule for the wireless device should have your MAC address (00:14:a5:b7:54:15) in the address
> >> field. These rules leave the name of wmaster0 alone, at least on the version of udev that I'm using.
> >>
> >> Larry
> >>
> >
> > Mine was under 70-persistent-net.rules
> > I commented out the following line.
> >
> > # PCI device 0x14e4:0x4311 (bcm43xx)
> > #SUBSYSTEM=="net", DRIVERS=="?*", ATTRS{address}=="00:14:a5:b7:54:15",
> > NAME="eth1"
> >
> > Then reloaded the module. Which caused udev to add this.
> >
> > # PCI device 0x14e4:0x4311 (b43-pci-bridge)
> > SUBSYSTEM=="net", DRIVERS=="?*", ATTR{address}=="00:14:a5:b7:54:15",
> > ATTR{type}=="1", NAME="wlan0"
> >
> > Which seems to work fine. Except that I still get wmaster0 with wlan0.
> > wlan0 gets the correct mac address but won't let me set essid. It does
> > scan (iwlist). But I think wmaster0 is causing problems it has the
> > same mac address as wlan0 only with a few extra zeros at the end. I
> > suspect that wmaster0 is interfering with wlan0.
>
> Whatever problems you are having, they are not caused by wmaster0. It is a "feature" of mac80211,
> and we all have wmaster0 and a separate wlan0, or eth1. It does not get in the way.

Oh. Thanks for clearing that up.

> Are you running iwconfig as root when you are trying to set essid? Setting anything requires
> privilege. If you are root, what is the error message?

Yes I have been using root. I must have messed up something else. Give
me some time to exhaust my debugging skills.

> Larry

Evan


From Larry.Finger at lwfinger.net  Thu Nov 15 06:55:42 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 14 Nov 2007 23:55:42 -0600
Subject: [RFC/T] b43: Implement the BCM94311MCG rev 02 card with a rev 13
	802.11 core
Message-ID: <473bdf5e.LS8yn+6u1JmDiT9C%Larry.Finger@lwfinger.net>

This patch file will enable the usage of the b43 driver with the
BCM94311MCG wlan mini-PCI (rev 02), which has not been supported.
This PCIe card uses 64-bit DMA. Most of the changes were needed
to implement this mode. It has been tested on the x86_64 architecture,
but should work on all platforms. FYI, full 64-bit DMA addressing
is implemented and the driver should work with a full 2^(64) bytes
of RAM. No, I have not tested that feature!

This patch is intended to be applied to the everything branch of
the wireless-2.6 git tree. For it to work, the set of 6 patches to
modify the SPROM handling code of ssb that I recently submitted must
be applied as well.

There is one anomaly with the code. When it initializes the DMA, and
enables interrupts for the first time, a single "PHY TX Error" is
generated. I have code to suppress that error message; however, it was
in the bottom-half interrupt handler, and I'm still trying to fix it
in less critical code.

The commitment text is shown below:

Larry
==================================================================

The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
has not been supported until now. The changes include the following:

(1) Adding the 802.11 rev 13 device to the ssb_device_id table to load b43.
(2) Change the descriptor ring buffers allocation to 8K to force alignment
    on 8K boundary.
(3) Added PHY revision 9 to the supported list.
(4) Fixed 64-bit addressing errors.
(5) Removed some magic numbers in the DMA setup.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

 dma.c  |   39 ++++++++++++++++-----------------------
 dma.h  |    7 +++++++
 main.c |    3 ++-
 3 files changed, 25 insertions(+), 24 deletions(-)

Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -93,6 +93,7 @@ static const struct ssb_device_id b43_ss
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
 	SSB_DEVTABLE_END
 };
 
@@ -3061,7 +3062,7 @@ static int b43_phy_versioning(struct b43
 			unsupported = 1;
 		break;
 	case B43_PHYTYPE_G:
-		if (phy_rev > 8)
+		if (phy_rev > 9)
 			unsupported = 1;
 		break;
 	default:
Index: wireless-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/dma.c
+++ wireless-2.6/drivers/net/wireless/b43/dma.c
@@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct 
 	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
 	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
 	    >> SSB_DMA_TRANSLATION_SHIFT;
-	addrhi |= ssb_dma_translation(ring->dev->dev);
+	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
 	if (slot == ring->nr_slots - 1)
 		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
 	if (start)
@@ -426,14 +426,15 @@ static inline
 static int alloc_ringmemory(struct b43_dmaring *ring)
 {
 	struct device *dev = ring->dev->dev->dev;
+	int size = (ring->dma64) ? 8192 : B43_DMA_RINGMEMSIZE;
 
-	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
+	ring->descbase = dma_alloc_coherent(dev, size,
 					    &(ring->dmabase), GFP_KERNEL);
 	if (!ring->descbase) {
 		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
 		return -ENOMEM;
 	}
-	memset(ring->descbase, 0, B43_DMA_RINGMEMSIZE);
+	memset(ring->descbase, 0, size);
 
 	return 0;
 }
@@ -483,7 +484,7 @@ int b43_dmacontroller_rx_reset(struct b4
 	return 0;
 }
 
-/* Reset the RX DMA channel */
+/* Reset the TX DMA channel */
 int b43_dmacontroller_tx_reset(struct b43_wldev *dev, u16 mmio_base, int dma64)
 {
 	int i;
@@ -636,18 +637,13 @@ static int dmacontroller_setup(struct b4
 		if (ring->dma64) {
 			u64 ringbase = (u64) (ring->dmabase);
 
-			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
-			    >> SSB_DMA_TRANSLATION_SHIFT;
-			value = B43_DMA64_TXENABLE;
-			value |= (addrext << B43_DMA64_TXADDREXT_SHIFT)
-			    & B43_DMA64_TXADDREXT_MASK;
-			b43_dma_write(ring, B43_DMA64_TXCTL, value);
+			b43_dma_write(ring, B43_DMA64_TXCTL,
+				      B43_DMA64_TXENABLE);
 			b43_dma_write(ring, B43_DMA64_TXRINGLO,
 				      (ringbase & 0xFFFFFFFF));
 			b43_dma_write(ring, B43_DMA64_TXRINGHI,
 				      ((ringbase >> 32) &
-				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
+				       0xFFFFFFFF));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -668,20 +664,16 @@ static int dmacontroller_setup(struct b4
 		if (ring->dma64) {
 			u64 ringbase = (u64) (ring->dmabase);
 
-			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
-			    >> SSB_DMA_TRANSLATION_SHIFT;
-			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT);
-			value |= B43_DMA64_RXENABLE;
-			value |= (addrext << B43_DMA64_RXADDREXT_SHIFT)
-			    & B43_DMA64_RXADDREXT_MASK;
+			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT)
+				| B43_DMA64_RXENABLE;
 			b43_dma_write(ring, B43_DMA64_RXCTL, value);
 			b43_dma_write(ring, B43_DMA64_RXRINGLO,
 				      (ringbase & 0xFFFFFFFF));
 			b43_dma_write(ring, B43_DMA64_RXRINGHI,
 				      ((ringbase >> 32) &
-				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
-			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
+				       0xFFFFFFFF));
+			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc64));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -695,11 +687,12 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA32_RXRING,
 				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
 				      | trans);
-			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
+			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc32));
 		}
 	}
 
-      out:
+out:
 	return err;
 }
 
Index: wireless-2.6/drivers/net/wireless/b43/dma.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/dma.h
+++ wireless-2.6/drivers/net/wireless/b43/dma.h
@@ -260,6 +260,13 @@ static inline u32 b43_dma_read(struct b4
 static inline
     void b43_dma_write(struct b43_dmaring *ring, u16 offset, u32 value)
 {
+	/* temporary debugging code */
+	if (((offset == 8) || (offset == 0x28)) && ring->dma64 &&
+	     ((value & 0x1FFF) != 0)) {
+		printk(KERN_ERR "b43: bad desc ring address for 64-bit DMA"
+		       " - offset, value: 0x%.2X 0x%.4X\n", offset, value);
+		dump_stack();
+	}
 	b43_write32(ring->dev, ring->mmio_base + offset, value);
 }
 


From banan at ludd.ltu.se  Thu Nov 15 09:02:22 2007
From: banan at ludd.ltu.se (Benjamin Larsson)
Date: Thu, 15 Nov 2007 09:02:22 +0100
Subject: Pre N card donation
Message-ID: <473BFD0E.6040904@ludd.ltu.se>

Hi, I have a pre-N broadcom card that I don't need. If any dev wants the 
card just send me your address.

MvH
Benjamin Larsson




From gmccullagh at gmail.com  Thu Nov 15 09:57:32 2007
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Thu, 15 Nov 2007 08:57:32 +0000
Subject: b43 with BCM4318 [AirForce One 54g] gets 2Mb/sec
In-Reply-To: <473bdf5e.LS8yn+6u1JmDiT9C%Larry.Finger@lwfinger.net>
References: <473bdf5e.LS8yn+6u1JmDiT9C%Larry.Finger@lwfinger.net>
Message-ID: <20071115085732.GA24018@gmail.com>

Hi,

I had in the past managed to get bcm43xx to work with this card in Ubuntu
gutsy.  It was quite difficult to get it to connect at times, but I never
managed to track down whether the issue was with the driver itself or
network-manager.

https://help.ubuntu.com/community/WifiDocs/Device/Broadcom_BCM4318_%5bAirForce_One_54g%5d_%28Native_Driver%29

I recently checked out a newer version of wireless-2.6 and checked out all
to compile the b43 driver.  After some messing around compiling b43-cutter
etc., I did get it to work.  There are still some initial connection
problems but I'm starting to think they are down to network-manager.  

The most noticeable issue with the driver is that while it connects
reliably but always at 2Mb/sec on 802.11G networks.  Is this expected
behaviour?

Gavin



From mb at bu3sch.de  Thu Nov 15 11:38:16 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 15 Nov 2007 11:38:16 +0100
Subject: [RFC/T] b43: Implement the BCM94311MCG rev 02 card with a rev 13
	802.11 core
In-Reply-To: <473bdf5e.LS8yn+6u1JmDiT9C%Larry.Finger@lwfinger.net>
References: <473bdf5e.LS8yn+6u1JmDiT9C%Larry.Finger@lwfinger.net>
Message-ID: <200711151138.17468.mb@bu3sch.de>

On Thursday 15 November 2007 06:55:42 Larry Finger wrote:
> This patch file will enable the usage of the b43 driver with the
> BCM94311MCG wlan mini-PCI (rev 02), which has not been supported.
> This PCIe card uses 64-bit DMA. Most of the changes were needed
> to implement this mode. It has been tested on the x86_64 architecture,
> but should work on all platforms. FYI, full 64-bit DMA addressing
> is implemented and the driver should work with a full 2^(64) bytes
> of RAM. No, I have not tested that feature!
> 
> This patch is intended to be applied to the everything branch of
> the wireless-2.6 git tree. For it to work, the set of 6 patches to
> modify the SPROM handling code of ssb that I recently submitted must
> be applied as well.
> 
> There is one anomaly with the code. When it initializes the DMA, and
> enables interrupts for the first time, a single "PHY TX Error" is
> generated. I have code to suppress that error message; however, it was
> in the bottom-half interrupt handler, and I'm still trying to fix it
> in less critical code.
> 
> The commitment text is shown below:

> Index: wireless-2.6/drivers/net/wireless/b43/dma.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/dma.c
> +++ wireless-2.6/drivers/net/wireless/b43/dma.c
> @@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct 
>  	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
>  	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
>  	    >> SSB_DMA_TRANSLATION_SHIFT;
> -	addrhi |= ssb_dma_translation(ring->dev->dev);
> +	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
>  	if (slot == ring->nr_slots - 1)
>  		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
>  	if (start)

Wait, this looks broken to me. It looks like the bug is more
inside of the ssb_dma_translation function, rather than here.

> @@ -426,14 +426,15 @@ static inline
>  static int alloc_ringmemory(struct b43_dmaring *ring)
>  {
>  	struct device *dev = ring->dev->dev->dev;
> +	int size = (ring->dma64) ? 8192 : B43_DMA_RINGMEMSIZE;

Uhm, a page is also 4k in x86_64?
Why doesn't using a page here work? What does happen?

> -	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
> +	ring->descbase = dma_alloc_coherent(dev, size,
>  					    &(ring->dmabase), GFP_KERNEL);
>  	if (!ring->descbase) {
>  		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
>  		return -ENOMEM;
>  	}
> -	memset(ring->descbase, 0, B43_DMA_RINGMEMSIZE);
> +	memset(ring->descbase, 0, size);
>  
>  	return 0;
>  }
> @@ -483,7 +484,7 @@ int b43_dmacontroller_rx_reset(struct b4
>  	return 0;
>  }
>  
> -/* Reset the RX DMA channel */
> +/* Reset the TX DMA channel */
>  int b43_dmacontroller_tx_reset(struct b43_wldev *dev, u16 mmio_base, int dma64)
>  {
>  	int i;
> @@ -636,18 +637,13 @@ static int dmacontroller_setup(struct b4
>  		if (ring->dma64) {
>  			u64 ringbase = (u64) (ring->dmabase);
>  
> -			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
> -			    >> SSB_DMA_TRANSLATION_SHIFT;
> -			value = B43_DMA64_TXENABLE;
> -			value |= (addrext << B43_DMA64_TXADDREXT_SHIFT)
> -			    & B43_DMA64_TXADDREXT_MASK;
> -			b43_dma_write(ring, B43_DMA64_TXCTL, value);
> +			b43_dma_write(ring, B43_DMA64_TXCTL,
> +				      B43_DMA64_TXENABLE);

Ehm, why are you removing this?

>  			b43_dma_write(ring, B43_DMA64_TXRINGLO,
>  				      (ringbase & 0xFFFFFFFF));
>  			b43_dma_write(ring, B43_DMA64_TXRINGHI,
>  				      ((ringbase >> 32) &
> -				       ~SSB_DMA_TRANSLATION_MASK)
> -				      | trans);
> +				       0xFFFFFFFF));

Huh?

>  		} else {
>  			u32 ringbase = (u32) (ring->dmabase);
>  
> @@ -668,20 +664,16 @@ static int dmacontroller_setup(struct b4
>  		if (ring->dma64) {
>  			u64 ringbase = (u64) (ring->dmabase);
>  
> -			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
> -			    >> SSB_DMA_TRANSLATION_SHIFT;
> -			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT);
> -			value |= B43_DMA64_RXENABLE;
> -			value |= (addrext << B43_DMA64_RXADDREXT_SHIFT)
> -			    & B43_DMA64_RXADDREXT_MASK;
> +			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT)
> +				| B43_DMA64_RXENABLE;
>  			b43_dma_write(ring, B43_DMA64_RXCTL, value);
>  			b43_dma_write(ring, B43_DMA64_RXRINGLO,
>  				      (ringbase & 0xFFFFFFFF));
>  			b43_dma_write(ring, B43_DMA64_RXRINGHI,
>  				      ((ringbase >> 32) &
> -				       ~SSB_DMA_TRANSLATION_MASK)
> -				      | trans);
> -			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
> +				       0xFFFFFFFF));
> +			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
> +				      sizeof(struct b43_dmadesc64));

Same here.

>  		} else {
>  			u32 ringbase = (u32) (ring->dmabase);
>  
> @@ -695,11 +687,12 @@ static int dmacontroller_setup(struct b4
>  			b43_dma_write(ring, B43_DMA32_RXRING,
>  				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
>  				      | trans);
> -			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
> +			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
> +				      sizeof(struct b43_dmadesc32));

I'm not sure why you do this change.

>  		}
>  	}
>  
> -      out:
> +out:
>  	return err;
>  }
>  
> Index: wireless-2.6/drivers/net/wireless/b43/dma.h
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/dma.h
> +++ wireless-2.6/drivers/net/wireless/b43/dma.h
> @@ -260,6 +260,13 @@ static inline u32 b43_dma_read(struct b4
>  static inline
>      void b43_dma_write(struct b43_dmaring *ring, u16 offset, u32 value)
>  {
> +	/* temporary debugging code */
> +	if (((offset == 8) || (offset == 0x28)) && ring->dma64 &&
> +	     ((value & 0x1FFF) != 0)) {
> +		printk(KERN_ERR "b43: bad desc ring address for 64-bit DMA"
> +		       " - offset, value: 0x%.2X 0x%.4X\n", offset, value);
> +		dump_stack();
> +	}

Ok, temporary. You know what that means :)

>  	b43_write32(ring->dev, ring->mmio_base + offset, value);
>  }
>  
> 
> 



-- 
Greetings Michael.


From larry.finger at lwfinger.net  Thu Nov 15 16:02:48 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 15 Nov 2007 09:02:48 -0600
Subject: [RFC/T] b43: Implement the BCM94311MCG rev 02 card with a rev
	13 802.11 core
In-Reply-To: <200711151138.17468.mb@bu3sch.de>
References: <473bdf5e.LS8yn+6u1JmDiT9C%Larry.Finger@lwfinger.net>
	<200711151138.17468.mb@bu3sch.de>
Message-ID: <473C5F98.1050007@lwfinger.net>

Michael Buesch wrote:
> On Thursday 15 November 2007 06:55:42 Larry Finger wrote:
>> --- wireless-2.6.orig/drivers/net/wireless/b43/dma.c
>> +++ wireless-2.6/drivers/net/wireless/b43/dma.c
>> @@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct 
>>  	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
>>  	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
>>  	    >> SSB_DMA_TRANSLATION_SHIFT;
>> -	addrhi |= ssb_dma_translation(ring->dev->dev);
>> +	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
>>  	if (slot == ring->nr_slots - 1)
>>  		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
>>  	if (start)
> 
> Wait, this looks broken to me. It looks like the bug is more
> inside of the ssb_dma_translation function, rather than here.

Yes and no. In the DMA specs (http://bcm-v4.sipsolutions.net/802.11/DMA), a 2-bit "routing code" is
used for the address portion of a descriptor. For 32-bit, a value of 1 indicates "Client Mode
Translation". With a 64-bit device, a value of 2 is the valid routing code and 1 leads to DMA
Errors. It seemed easier to take a 0/1 output from ssb_dma_translation and shift it for the 64-bit
case than to teach ssb to distinguish between 32- and 64-bit DMA. BTW, we do have one other option -
we could ignore the routing and address extension bits and _limit_ the user to a maximum of 0.5
Zettabytes! What is the probability that any machine will exceed that amount of memory within our
lifetimes? But then, I never expected to see Terrabyte disk drives in a 3.5 inch package!! Have you
noted that Broadcom uses a 2-bit routing code _AND_ a 2-bit address extension? Why they didn't use a
flat 64-bit address is a mystery.

I can, however, go either way - your drivers and your call.

>> @@ -426,14 +426,15 @@ static inline
>>  static int alloc_ringmemory(struct b43_dmaring *ring)
>>  {
>>  	struct device *dev = ring->dev->dev->dev;
>> +	int size = (ring->dma64) ? 8192 : B43_DMA_RINGMEMSIZE;
> 
> Uhm, a page is also 4k in x86_64?
> Why doesn't using a page here work? What does happen?

You get random 4K/8K alignment and the driver fails with a Fatal DMA error for those with 4K alignment.

>> @@ -636,18 +637,13 @@ static int dmacontroller_setup(struct b4
>>  		if (ring->dma64) {
>>  			u64 ringbase = (u64) (ring->dmabase);
>>  
>> -			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
>> -			    >> SSB_DMA_TRANSLATION_SHIFT;
>> -			value = B43_DMA64_TXENABLE;
>> -			value |= (addrext << B43_DMA64_TXADDREXT_SHIFT)
>> -			    & B43_DMA64_TXADDREXT_MASK;
>> -			b43_dma_write(ring, B43_DMA64_TXCTL, value);
>> +			b43_dma_write(ring, B43_DMA64_TXCTL,
>> +				      B43_DMA64_TXENABLE);
> 
> Ehm, why are you removing this?

Unlike 32-bit DMA and the 64-bit descriptors, the 64-bit case uses two full 32-bit words to store
the Descriptor Ring Address. No fancy packing of the upper bits into the control word are needed.

>>  			b43_dma_write(ring, B43_DMA64_TXRINGLO,
>>  				      (ringbase & 0xFFFFFFFF));
>>  			b43_dma_write(ring, B43_DMA64_TXRINGHI,
>>  				      ((ringbase >> 32) &
>> -				       ~SSB_DMA_TRANSLATION_MASK)
>> -				      | trans);
>> +				       0xFFFFFFFF));
> 
> Huh?

This mask is not needed. It is a carryover from when I was having a problem. This will become
b43_dma_write(ring, B43_DMA64_TXRINGHI,(ringbase >> 32)); in the next version.

>>  		} else {
>>  			u32 ringbase = (u32) (ring->dmabase);
>>  
>> @@ -668,20 +664,16 @@ static int dmacontroller_setup(struct b4
>>  		if (ring->dma64) {
>>  			u64 ringbase = (u64) (ring->dmabase);
>>  
>> -			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
>> -			    >> SSB_DMA_TRANSLATION_SHIFT;
>> -			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT);
>> -			value |= B43_DMA64_RXENABLE;
>> -			value |= (addrext << B43_DMA64_RXADDREXT_SHIFT)
>> -			    & B43_DMA64_RXADDREXT_MASK;
>> +			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT)
>> +				| B43_DMA64_RXENABLE;
>>  			b43_dma_write(ring, B43_DMA64_RXCTL, value);
>>  			b43_dma_write(ring, B43_DMA64_RXRINGLO,
>>  				      (ringbase & 0xFFFFFFFF));
>>  			b43_dma_write(ring, B43_DMA64_RXRINGHI,
>>  				      ((ringbase >> 32) &
>> -				       ~SSB_DMA_TRANSLATION_MASK)
>> -				      | trans);
>> -			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
>> +				       0xFFFFFFFF));
>> +			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
>> +				      sizeof(struct b43_dmadesc64));
> 
> Same here.

Same change for the RX Descriptor Ring Address.

>> @@ -695,11 +687,12 @@ static int dmacontroller_setup(struct b4
>>  			b43_dma_write(ring, B43_DMA32_RXRING,
>>  				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
>>  				      | trans);
>> -			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
>> +			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
>> +				      sizeof(struct b43_dmadesc32));
> 
> I'm not sure why you do this change.

It took me a while to figure out where the magic number of 200 came from, and what I needed for the
64-bit case. In fact I think the 200 is a bug and should be 0x200. To me, this change makes it clearer.

>> Index: wireless-2.6/drivers/net/wireless/b43/dma.h
>> ===================================================================
>> --- wireless-2.6.orig/drivers/net/wireless/b43/dma.h
>> +++ wireless-2.6/drivers/net/wireless/b43/dma.h
>> @@ -260,6 +260,13 @@ static inline u32 b43_dma_read(struct b4
>>  static inline
>>      void b43_dma_write(struct b43_dmaring *ring, u16 offset, u32 value)
>>  {
>> +	/* temporary debugging code */
>> +	if (((offset == 8) || (offset == 0x28)) && ring->dma64 &&
>> +	     ((value & 0x1FFF) != 0)) {
>> +		printk(KERN_ERR "b43: bad desc ring address for 64-bit DMA"
>> +		       " - offset, value: 0x%.2X 0x%.4X\n", offset, value);
>> +		dump_stack();
>> +	}
> 
> Ok, temporary. You know what that means :)

In this case, it disappears before the patch goes to John!

Larry




From simonhandy at blueyonder.co.uk  Thu Nov 15 20:09:29 2007
From: simonhandy at blueyonder.co.uk (simonhandy at blueyonder.co.uk)
Date: Thu, 15 Nov 2007 19:09:29 -0000 (GMT)
Subject: b43 with BCM4318 [AirForce One 54g] gets 2Mb/sec (Gavin McCullagh)
In-Reply-To: <mailman.55.1195124472.13704.bcm43xx-dev@lists.berlios.de>
References: <mailman.55.1195124472.13704.bcm43xx-dev@lists.berlios.de>
Message-ID: <55663.62.31.93.108.1195153769.VlNKBWgPS094.squirrel@62.31.93.108>

> I had in the past managed to get bcm43xx to work with this card in Ubuntu
> gutsy.  It was quite difficult to get it to connect at times, but I never
> managed to track down whether the issue was with the driver itself or
> network-manager.
>
> https://help.ubuntu.com/community/WifiDocs/Device/Broadcom_BCM4318_%5bAirForce_One_54g%5d_%28Native_Driver%29
>
> I recently checked out a newer version of wireless-2.6 and checked out all
> to compile the b43 driver.  After some messing around compiling b43-cutter
> etc., I did get it to work.  There are still some initial connection
> problems but I'm starting to think they are down to network-manager.
>
> The most noticeable issue with the driver is that while it connects
> reliably but always at 2Mb/sec on 802.11G networks.  Is this expected
> behaviour?
>
> Gavin
All, please correct me if I am getting this wrong.
Gavin,
Are you getting the speed from the NetworkManager applet, because that
only reports on the initial connection speed of the interface. To get a
current rate you must use iwconfig or another application that gets the
rate dynamically.
The code for the b43 driver starts the interface at a low rate and
constantly monitors the signal quality and adjusts the transmission power
and rate depending on the quality. In a good environment the connection
should remain reliable and the driver will steadily increase the
transmission rate.  The less reliable the connection the lower the rate. 
I consistently get 12-24 Mb/s with the driver on a stock Fedora 7/8 kernel
on a 4318.
I have had connection quality problems before, related to the channel I
was using and interference  from various other AP's in the neighbourhood.
So you might want to check this.
Thanks
Simon.




From gmccullagh at gmail.com  Thu Nov 15 20:21:47 2007
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Thu, 15 Nov 2007 19:21:47 +0000
Subject: b43 with BCM4318 [AirForce One 54g] gets 2Mb/sec (Gavin McCullagh)
In-Reply-To: <55663.62.31.93.108.1195153769.VlNKBWgPS094.squirrel@62.31.93.108>
References: <mailman.55.1195124472.13704.bcm43xx-dev@lists.berlios.de>
	<55663.62.31.93.108.1195153769.VlNKBWgPS094.squirrel@62.31.93.108>
Message-ID: <20071115192147.GB3544@gmail.com>

Hi,

On Thu, 15 Nov 2007, simonhandy at blueyonder.co.uk wrote:

> Are you getting the speed from the NetworkManager applet, because that
> only reports on the initial connection speed of the interface. To get a
> current rate you must use iwconfig or another application that gets the
> rate dynamically.

Your dead right.  network-manager reports 2mbps, iwconfig says 54Mbps.

Sorry,
Gavin



From mb at bu3sch.de  Thu Nov 15 22:49:12 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 15 Nov 2007 22:49:12 +0100
Subject: [RFC/T] b43: Implement the BCM94311MCG rev 02 card with a rev 13
	802.11 core
In-Reply-To: <473C5F98.1050007@lwfinger.net>
References: <473bdf5e.LS8yn+6u1JmDiT9C%Larry.Finger@lwfinger.net>
	<200711151138.17468.mb@bu3sch.de> <473C5F98.1050007@lwfinger.net>
Message-ID: <200711152249.12824.mb@bu3sch.de>

On Thursday 15 November 2007 16:02:48 Larry Finger wrote:
> >> @@ -695,11 +687,12 @@ static int dmacontroller_setup(struct b4
> >>  			b43_dma_write(ring, B43_DMA32_RXRING,
> >>  				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
> >>  				      | trans);
> >> -			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
> >> +			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
> >> +				      sizeof(struct b43_dmadesc32));
> > 
> > I'm not sure why you do this change.
> 
> It took me a while to figure out where the magic number of 200 came from, and what I needed for the
> 64-bit case. In fact I think the 200 is a bug and should be 0x200. To me, this change makes it clearer.

The 200 is just a random number.
I think we don't really care what the value is. (Except zero, which doesn't
work on some devices).

-- 
Greetings Michael.


From banan at ludd.ltu.se  Thu Nov 15 22:50:09 2007
From: banan at ludd.ltu.se (Benjamin Larsson)
Date: Thu, 15 Nov 2007 22:50:09 +0100
Subject: Pre N card donation
In-Reply-To: <473BFD0E.6040904@ludd.ltu.se>
References: <473BFD0E.6040904@ludd.ltu.se>
Message-ID: <473CBF11.5010003@ludd.ltu.se>

Benjamin Larsson wrote:
> Hi, I have a pre-N broadcom card that I don't need. If any dev wants the 
> card just send me your address.
> 
> MvH
> Benjamin Larsson
> 

I'm sorry I must have been smoking but the chipset on this actual card
is Airgo (AGN100 or something). So I'll try to donate it to some dev
writing a driver for that chipset.

MvH
Benjamin Larsson


From larry.finger at lwfinger.net  Thu Nov 15 23:15:42 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 15 Nov 2007 16:15:42 -0600
Subject: bcm4311 rev2
In-Reply-To: <BAY129-DS1310BCBED4B6D720B3FC88B820@phx.gbl>
References: <BAY129-DS1310BCBED4B6D720B3FC88B820@phx.gbl>
Message-ID: <473CC50E.6000003@lwfinger.net>

Tomas Trnka wrote:
> Hello,
> I have seen the discussion and I'm expecting similar problems with
> bcm4311 rev2. I can't see any signal.
> I have HP pavilion 6580ec. I tried to run it on slackware (backtrack,
> wifislax), but Iam afraid Iam not very skilled in using Linux.
> Can you tell me if there is a real chance of getting the right driver?
> Where? What do I have to do for it ? (if its possible somehow, my
> teachers can help me)

To implement this driver, you will need to acquire the kernel source for 2.6.24-rc2 from kernel.org,
make sure you have the compiler and other tools needed to build a new kernel. In addition, you will
need the set of patches that modify the SPROM handling, and the patch I published today. I will be
combining them and putting the whole set on my FTP site. Watch this mailing list for an announcement.

The other thing that will be needed is b43-fwcutter and the Broadcom driver from which to extract V4
firmware. The process for this extraction is described at http://linuxwireless.org/en/users/Drivers/b43.

Building a new kernel seems difficult the first time you do it. I certainly hope you get some local
help.

Larry


From larry.finger at lwfinger.net  Fri Nov 16 00:11:16 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 15 Nov 2007 17:11:16 -0600
Subject: [RFC/T] b43: Implement the BCM94311MCG rev 02 card with a rev
	13 802.11 core
In-Reply-To: <200711152249.12824.mb@bu3sch.de>
References: <473bdf5e.LS8yn+6u1JmDiT9C%Larry.Finger@lwfinger.net>
	<200711151138.17468.mb@bu3sch.de> <473C5F98.1050007@lwfinger.net>
	<200711152249.12824.mb@bu3sch.de>
Message-ID: <473CD214.3060000@lwfinger.net>

Michael Buesch wrote:
> On Thursday 15 November 2007 16:02:48 Larry Finger wrote:
>> It took me a while to figure out where the magic number of 200 came from, and what I needed for the
>> 64-bit case. In fact I think the 200 is a bug and should be 0x200. To me, this change makes it clearer.
> 
> The 200 is just a random number.
> I think we don't really care what the value is. (Except zero, which doesn't
> work on some devices).

I think the specs are missing one word and that this quantity should be called "Descriptor Stop
Index" for RX. My understanding is that the RX process uses the descriptors in order until this
particular value is reached. At this point, it restarts at the beginning making a ring buffer. As we
have just allocated 64 slots, it didn't quite seem right to use only the first 25 of them, which is
what the 200 accomplishes. Of course, 25 DMA RX buffers are quite likely to be more than enough. We
might reconsider cutting the allocation number and not take so much DMAable memory. With 64-bit DMA,
all memory is suitable, but not so for the 30-bit cards.

Larry




From Larry.Finger at lwfinger.net  Fri Nov 16 07:48:23 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 16 Nov 2007 00:48:23 -0600
Subject: [PATCH] ssb: Fix compilation errors in ssb
Message-ID: <473d3d37.IWXGkSribrkSiHBl%Larry.Finger@lwfinger.net>

Recent changes in ssb sprom handling break compilation. These two patches
fix the problem.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

These two changes should be applied to the everything branch of wireless-2.6
ASAP. Sorry about the mixup - I have no idea what happened.

Larry

Index: wireless-2.6/drivers/ssb/pci.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/pci.c
+++ wireless-2.6/drivers/ssb/pci.c
@@ -415,7 +415,7 @@ static int sprom_extract(struct ssb_bus 
 		if (out->revision == 0)
 			goto unsupported;
 		if (out->revision >= 1 && out->revision <= 3) {
-			sprom_extract_r123(out, in, out->revision);
+			sprom_extract_r123(out, in);
 		}
 		if (out->revision == 4)
 			sprom_extract_r4(out, in);
Index: wireless-2.6/include/linux/ssb/ssb.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb.h
+++ wireless-2.6/include/linux/ssb/ssb.h
@@ -16,6 +16,7 @@ struct ssb_bus;
 struct ssb_driver;
 
 struct ssb_sprom {
+	u8 revision;
 	u8 il0mac[6];		/* MAC address for 802.11b/g */
 	u8 et0mac[6];		/* MAC address for Ethernet */
 	u8 et1mac[6];		/* MAC address for 802.11a */


From mb at bu3sch.de  Fri Nov 16 11:30:46 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 16 Nov 2007 11:30:46 +0100
Subject: [PATCH] ssb: Fix compilation errors in ssb
In-Reply-To: <473d3d37.IWXGkSribrkSiHBl%Larry.Finger@lwfinger.net>
References: <473d3d37.IWXGkSribrkSiHBl%Larry.Finger@lwfinger.net>
Message-ID: <200711161130.46770.mb@bu3sch.de>

On Friday 16 November 2007 07:48:23 Larry Finger wrote:
> Recent changes in ssb sprom handling break compilation. These two patches
> fix the problem.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John,
> 
> These two changes should be applied to the everything branch of wireless-2.6
> ASAP. Sorry about the mixup - I have no idea what happened.

are your sprom r4 changes already applied? I didn't test that in the b44, yet.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Fri Nov 16 15:21:43 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 16 Nov 2007 08:21:43 -0600
Subject: [PATCH] ssb: Fix compilation errors in ssb
In-Reply-To: <200711161130.46770.mb@bu3sch.de>
References: <473d3d37.IWXGkSribrkSiHBl%Larry.Finger@lwfinger.net>
	<200711161130.46770.mb@bu3sch.de>
Message-ID: <473DA777.2090203@lwfinger.net>

Michael Buesch wrote:
> On Friday 16 November 2007 07:48:23 Larry Finger wrote:
>> Recent changes in ssb sprom handling break compilation. These two patches
>> fix the problem.
>>
>> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
>> ---
>>
>> John,
>>
>> These two changes should be applied to the everything branch of wireless-2.6
>> ASAP. Sorry about the mixup - I have no idea what happened.
> 
> are your sprom r4 changes already applied? I didn't test that in the b44, yet.

I did a git pull yesterday and the sprom r3 and r4 changes were in wireless-2.6/everything.

Larry


From linville at tuxdriver.com  Fri Nov 16 15:56:32 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Fri, 16 Nov 2007 09:56:32 -0500
Subject: [PATCH] ssb: Fix compilation errors in ssb
In-Reply-To: <473DA777.2090203@lwfinger.net>
References: <473d3d37.IWXGkSribrkSiHBl%Larry.Finger@lwfinger.net>
	<200711161130.46770.mb@bu3sch.de> <473DA777.2090203@lwfinger.net>
Message-ID: <20071116145632.GA25828@tuxdriver.com>

On Fri, Nov 16, 2007 at 08:21:43AM -0600, Larry Finger wrote:
> Michael Buesch wrote:
> > On Friday 16 November 2007 07:48:23 Larry Finger wrote:
> >> Recent changes in ssb sprom handling break compilation. These two patches
> >> fix the problem.

> > are your sprom r4 changes already applied? I didn't test that in the b44, yet.
> 
> I did a git pull yesterday and the sprom r3 and r4 changes were in wireless-2.6/everything.

And now, so is this one.  I'll probably roll it into the main ssb
sprom patch before actually sending it to Jeff.

Thanks,

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Fri Nov 16 17:56:13 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 16 Nov 2007 10:56:13 -0600
Subject: [RFC/T] b43: Implement the BCM94311MCG rev 02 card with a rev
	13 802.11 core
In-Reply-To: <473DC7CB.7070005@matws.net>
References: <473DC7CB.7070005@matws.net>
Message-ID: <473DCBAD.8000101@lwfinger.net>

Matthieu PATOU wrote:
> Larry,
> I wanted to thank you for the patch because yesterday I tried your patch
> on my laptop.
> It is equipped with a broadcom 4312 rev02 wifi card, and until then I
> haven't been successfull making this card working.
> With your patch it works, it seems that speed is limited to 2mb/s and i
> got messages/problems about ssb and b43 at boot or after suspend to ram.
> 
> I wonder if I can help you or the wireless team with some tests and how
> to report those informations if it could be  useful.

How did you determine that the speed was limited to 2 Mbs? If you are looking at the number from
NetworkManager, it only gets the speed at connection and does not update it as the rate-control
algorithm changes the speed. You should use iwconfig to get the current speed. My 4311 rev02 has
migrated to 54 Mbs.

Please send the ssb and b43 messages to the bcm43xx mailing list. Thanks for testing.

Larry


From mb at bu3sch.de  Fri Nov 16 22:53:03 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 16 Nov 2007 22:53:03 +0100
Subject: [PATCH] ssb: Fix compilation errors in ssb
In-Reply-To: <20071116145632.GA25828@tuxdriver.com>
References: <473d3d37.IWXGkSribrkSiHBl%Larry.Finger@lwfinger.net>
	<473DA777.2090203@lwfinger.net>
	<20071116145632.GA25828@tuxdriver.com>
Message-ID: <200711162253.03566.mb@bu3sch.de>

On Friday 16 November 2007 15:56:32 John W. Linville wrote:
> On Fri, Nov 16, 2007 at 08:21:43AM -0600, Larry Finger wrote:
> > Michael Buesch wrote:
> > > On Friday 16 November 2007 07:48:23 Larry Finger wrote:
> > >> Recent changes in ssb sprom handling break compilation. These two patches
> > >> fix the problem.
> 
> > > are your sprom r4 changes already applied? I didn't test that in the b44, yet.
> > 
> > I did a git pull yesterday and the sprom r3 and r4 changes were in wireless-2.6/everything.
> 
> And now, so is this one.  I'll probably roll it into the main ssb
> sprom patch before actually sending it to Jeff.

Ok, cool.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Mon Nov 19 16:18:48 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 19 Nov 2007 09:18:48 -0600
Subject: [Bugme-new] [Bug 9402] New: Not work chipset broadcom 4318
In-Reply-To: <20071119005050.2afbcf6e.akpm@linux-foundation.org>
References: <bug-9402-10286@http.bugzilla.kernel.org/>
	<20071119005050.2afbcf6e.akpm@linux-foundation.org>
Message-ID: <4741A958.9030300@lwfinger.net>

Andrew Morton wrote:
> On Sun, 18 Nov 2007 15:49:40 -0800 (PST) bugme-daemon at bugzilla.kernel.org wrote:
> 
>> http://bugzilla.kernel.org/show_bug.cgi?id=9402
> 
> Rafael, this is allegedly a post-2.6.23 regression.
> 

Raphael and Andrew,

This is most definitely not a regression. The OP has switched from the SoftMAC to the mac80211
driver. His original problem is that he did not do the requisite upgrade of the firmware. Now that
he has done so, his is also running into a problem with his udev renaming rules. In managed mode,
mac80211 creates two interfaces - one named wmaster0 with type 0x801 and a second named wlan0 with
type 0x001. On the OP's system, the renaming rules have wmaster0 => eth1 and wlan0 => wlan0-ren. The
proper renaming rule for udev should have a 'ATTR{TYPE}=="1"' clause, which is likely missing. Once
the names are wrong, so are the scripts in /etc/sysconfig/network.

Larry





From stefano.brivio at polimi.it  Mon Nov 19 17:12:17 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Mon, 19 Nov 2007 17:12:17 +0100
Subject: [PATCH] remove bcm43xx
Message-ID: <20071119171217.557ea31f@morte>

Remove bcm43xx. Fix some left-over URLs and ifdefs in b43 and b43legacy
drivers.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

John,
this is for 2.6.25.

---

Index: wireless-2.6/drivers/net/wireless/bcm43xx/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/Kconfig
+++ /dev/null
@@ -1,67 +0,0 @@
-config BCM43XX
-	tristate "Broadcom BCM43xx wireless support"
-	depends on PCI && IEEE80211 && IEEE80211_SOFTMAC && WLAN_80211 && EXPERIMENTAL
-	select WIRELESS_EXT
-	select FW_LOADER
-	select HW_RANDOM
-	---help---
-	  This is an experimental driver for the Broadcom 43xx wireless chip,
-	  found in the Apple Airport Extreme and various other devices.
-
-config BCM43XX_DEBUG
-	bool "Broadcom BCM43xx debugging (RECOMMENDED)"
-	depends on BCM43XX
-	default y
-	---help---
-	  Broadcom 43xx debugging messages.
-	  Say Y, because the driver is still very experimental and
-	  this will help you get it running.
-
-config BCM43XX_DMA
-	bool
-	depends on BCM43XX
-
-config BCM43XX_PIO
-	bool
-	depends on BCM43XX
-
-choice
-	prompt "BCM43xx data transfer mode"
-	depends on BCM43XX
-	default BCM43XX_DMA_AND_PIO_MODE
-
-config BCM43XX_DMA_AND_PIO_MODE
-	bool "DMA + PIO"
-	select BCM43XX_DMA
-	select BCM43XX_PIO
-	---help---
-	  Include both, Direct Memory Access (DMA) and Programmed I/O (PIO)
-	  data transfer modes.
-	  The actually used mode is selectable through the module
-	  parameter "pio". If the module parameter is pio=0, DMA is used.
-	  Otherwise PIO is used. DMA is default.
-
-	  If unsure, choose this option.
-
-config BCM43XX_DMA_MODE
-	bool "DMA (Direct Memory Access) only"
-	select BCM43XX_DMA
-	---help---
-	  Only include Direct Memory Access (DMA).
-	  This reduces the size of the driver module, by omitting the PIO code.
-
-config BCM43XX_PIO_MODE
-	bool "PIO (Programmed I/O) only"
-	select BCM43XX_PIO
-	---help---
-	  Only include Programmed I/O (PIO).
-	  This reduces the size of the driver module, by omitting the DMA code.
-	  Please note that PIO transfers are slow (compared to DMA).
-
-	  Also note that not all devices of the 43xx series support PIO.
-	  The 4306 (Apple Airport Extreme and others) supports PIO, while
-	  the 4318 is known to _not_ support PIO.
-
-	  Only use PIO, if DMA does not work for you.
-
-endchoice
Index: wireless-2.6/drivers/net/wireless/bcm43xx/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/Makefile
+++ /dev/null
@@ -1,12 +0,0 @@
-obj-$(CONFIG_BCM43XX) += bcm43xx.o
-bcm43xx-obj-$(CONFIG_BCM43XX_DEBUG) += bcm43xx_debugfs.o
-
-bcm43xx-obj-$(CONFIG_BCM43XX_DMA) += bcm43xx_dma.o
-bcm43xx-obj-$(CONFIG_BCM43XX_PIO) += bcm43xx_pio.o
-
-bcm43xx-objs := bcm43xx_main.o bcm43xx_ilt.o \
-		bcm43xx_radio.o bcm43xx_phy.o \
-		bcm43xx_power.o bcm43xx_wx.o \
-		bcm43xx_leds.o bcm43xx_ethtool.o \
-		bcm43xx_xmit.o bcm43xx_sysfs.o \
-		$(bcm43xx-obj-y)
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx.h
+++ /dev/null
@@ -1,997 +0,0 @@
-#ifndef BCM43xx_H_
-#define BCM43xx_H_
-
-#include <linux/hw_random.h>
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/spinlock.h>
-#include <linux/interrupt.h>
-#include <linux/stringify.h>
-#include <linux/pci.h>
-#include <net/ieee80211.h>
-#include <net/ieee80211softmac.h>
-#include <asm/atomic.h>
-#include <asm/io.h>
-
-
-#include "bcm43xx_debugfs.h"
-#include "bcm43xx_leds.h"
-
-
-#define PFX				KBUILD_MODNAME ": "
-
-#define BCM43xx_SWITCH_CORE_MAX_RETRIES	50
-#define BCM43xx_IRQWAIT_MAX_RETRIES	100
-
-#define BCM43xx_IO_SIZE			8192
-
-/* Active Core PCI Configuration Register. */
-#define BCM43xx_PCICFG_ACTIVE_CORE	0x80
-/* SPROM control register. */
-#define BCM43xx_PCICFG_SPROMCTL		0x88
-/* Interrupt Control PCI Configuration Register. (Only on PCI cores with rev >= 6) */
-#define BCM43xx_PCICFG_ICR		0x94
-
-/* MMIO offsets */
-#define BCM43xx_MMIO_DMA0_REASON	0x20
-#define BCM43xx_MMIO_DMA0_IRQ_MASK	0x24
-#define BCM43xx_MMIO_DMA1_REASON	0x28
-#define BCM43xx_MMIO_DMA1_IRQ_MASK	0x2C
-#define BCM43xx_MMIO_DMA2_REASON	0x30
-#define BCM43xx_MMIO_DMA2_IRQ_MASK	0x34
-#define BCM43xx_MMIO_DMA3_REASON	0x38
-#define BCM43xx_MMIO_DMA3_IRQ_MASK	0x3C
-#define BCM43xx_MMIO_DMA4_REASON	0x40
-#define BCM43xx_MMIO_DMA4_IRQ_MASK	0x44
-#define BCM43xx_MMIO_DMA5_REASON	0x48
-#define BCM43xx_MMIO_DMA5_IRQ_MASK	0x4C
-#define BCM43xx_MMIO_STATUS_BITFIELD	0x120
-#define BCM43xx_MMIO_STATUS2_BITFIELD	0x124
-#define BCM43xx_MMIO_GEN_IRQ_REASON	0x128
-#define BCM43xx_MMIO_GEN_IRQ_MASK	0x12C
-#define BCM43xx_MMIO_RAM_CONTROL	0x130
-#define BCM43xx_MMIO_RAM_DATA		0x134
-#define BCM43xx_MMIO_PS_STATUS		0x140
-#define BCM43xx_MMIO_RADIO_HWENABLED_HI	0x158
-#define BCM43xx_MMIO_SHM_CONTROL	0x160
-#define BCM43xx_MMIO_SHM_DATA		0x164
-#define BCM43xx_MMIO_SHM_DATA_UNALIGNED	0x166
-#define BCM43xx_MMIO_XMITSTAT_0		0x170
-#define BCM43xx_MMIO_XMITSTAT_1		0x174
-#define BCM43xx_MMIO_REV3PLUS_TSF_LOW	0x180 /* core rev >= 3 only */
-#define BCM43xx_MMIO_REV3PLUS_TSF_HIGH	0x184 /* core rev >= 3 only */
-
-/* 32-bit DMA */
-#define BCM43xx_MMIO_DMA32_BASE0	0x200
-#define BCM43xx_MMIO_DMA32_BASE1	0x220
-#define BCM43xx_MMIO_DMA32_BASE2	0x240
-#define BCM43xx_MMIO_DMA32_BASE3	0x260
-#define BCM43xx_MMIO_DMA32_BASE4	0x280
-#define BCM43xx_MMIO_DMA32_BASE5	0x2A0
-/* 64-bit DMA */
-#define BCM43xx_MMIO_DMA64_BASE0	0x200
-#define BCM43xx_MMIO_DMA64_BASE1	0x240
-#define BCM43xx_MMIO_DMA64_BASE2	0x280
-#define BCM43xx_MMIO_DMA64_BASE3	0x2C0
-#define BCM43xx_MMIO_DMA64_BASE4	0x300
-#define BCM43xx_MMIO_DMA64_BASE5	0x340
-/* PIO */
-#define BCM43xx_MMIO_PIO1_BASE		0x300
-#define BCM43xx_MMIO_PIO2_BASE		0x310
-#define BCM43xx_MMIO_PIO3_BASE		0x320
-#define BCM43xx_MMIO_PIO4_BASE		0x330
-
-#define BCM43xx_MMIO_PHY_VER		0x3E0
-#define BCM43xx_MMIO_PHY_RADIO		0x3E2
-#define BCM43xx_MMIO_ANTENNA		0x3E8
-#define BCM43xx_MMIO_CHANNEL		0x3F0
-#define BCM43xx_MMIO_CHANNEL_EXT	0x3F4
-#define BCM43xx_MMIO_RADIO_CONTROL	0x3F6
-#define BCM43xx_MMIO_RADIO_DATA_HIGH	0x3F8
-#define BCM43xx_MMIO_RADIO_DATA_LOW	0x3FA
-#define BCM43xx_MMIO_PHY_CONTROL	0x3FC
-#define BCM43xx_MMIO_PHY_DATA		0x3FE
-#define BCM43xx_MMIO_MACFILTER_CONTROL	0x420
-#define BCM43xx_MMIO_MACFILTER_DATA	0x422
-#define BCM43xx_MMIO_RADIO_HWENABLED_LO	0x49A
-#define BCM43xx_MMIO_GPIO_CONTROL	0x49C
-#define BCM43xx_MMIO_GPIO_MASK		0x49E
-#define BCM43xx_MMIO_TSF_0		0x632 /* core rev < 3 only */
-#define BCM43xx_MMIO_TSF_1		0x634 /* core rev < 3 only */
-#define BCM43xx_MMIO_TSF_2		0x636 /* core rev < 3 only */
-#define BCM43xx_MMIO_TSF_3		0x638 /* core rev < 3 only */
-#define BCM43xx_MMIO_RNG		0x65A
-#define BCM43xx_MMIO_POWERUP_DELAY	0x6A8
-
-/* SPROM offsets. */
-#define BCM43xx_SPROM_BASE		0x1000
-#define BCM43xx_SPROM_BOARDFLAGS2	0x1c
-#define BCM43xx_SPROM_IL0MACADDR	0x24
-#define BCM43xx_SPROM_ET0MACADDR	0x27
-#define BCM43xx_SPROM_ET1MACADDR	0x2a
-#define BCM43xx_SPROM_ETHPHY		0x2d
-#define BCM43xx_SPROM_BOARDREV		0x2e
-#define BCM43xx_SPROM_PA0B0		0x2f
-#define BCM43xx_SPROM_PA0B1		0x30
-#define BCM43xx_SPROM_PA0B2		0x31
-#define BCM43xx_SPROM_WL0GPIO0		0x32
-#define BCM43xx_SPROM_WL0GPIO2		0x33
-#define BCM43xx_SPROM_MAXPWR		0x34
-#define BCM43xx_SPROM_PA1B0		0x35
-#define BCM43xx_SPROM_PA1B1		0x36
-#define BCM43xx_SPROM_PA1B2		0x37
-#define BCM43xx_SPROM_IDL_TSSI_TGT	0x38
-#define BCM43xx_SPROM_BOARDFLAGS	0x39
-#define BCM43xx_SPROM_ANTENNA_GAIN	0x3a
-#define BCM43xx_SPROM_VERSION		0x3f
-
-/* BCM43xx_SPROM_BOARDFLAGS values */
-#define BCM43xx_BFL_BTCOEXIST		0x0001 /* implements Bluetooth coexistance */
-#define BCM43xx_BFL_PACTRL		0x0002 /* GPIO 9 controlling the PA */
-#define BCM43xx_BFL_AIRLINEMODE		0x0004 /* implements GPIO 13 radio disable indication */
-#define BCM43xx_BFL_RSSI		0x0008 /* software calculates nrssi slope. */
-#define BCM43xx_BFL_ENETSPI		0x0010 /* has ephy roboswitch spi */
-#define BCM43xx_BFL_XTAL_NOSLOW		0x0020 /* no slow clock available */
-#define BCM43xx_BFL_CCKHIPWR		0x0040 /* can do high power CCK transmission */
-#define BCM43xx_BFL_ENETADM		0x0080 /* has ADMtek switch */
-#define BCM43xx_BFL_ENETVLAN		0x0100 /* can do vlan */
-#define BCM43xx_BFL_AFTERBURNER		0x0200 /* supports Afterburner mode */
-#define BCM43xx_BFL_NOPCI		0x0400 /* leaves PCI floating */
-#define BCM43xx_BFL_FEM			0x0800 /* supports the Front End Module */
-#define BCM43xx_BFL_EXTLNA		0x1000 /* has an external LNA */
-#define BCM43xx_BFL_HGPA		0x2000 /* had high gain PA */
-#define BCM43xx_BFL_BTCMOD		0x4000 /* BFL_BTCOEXIST is given in alternate GPIOs */
-#define BCM43xx_BFL_ALTIQ		0x8000 /* alternate I/Q settings */
-
-/* GPIO register offset, in both ChipCommon and PCI core. */
-#define BCM43xx_GPIO_CONTROL		0x6c
-
-/* SHM Routing */
-#define BCM43xx_SHM_SHARED		0x0001
-#define BCM43xx_SHM_WIRELESS		0x0002
-#define BCM43xx_SHM_PCM			0x0003
-#define BCM43xx_SHM_HWMAC		0x0004
-#define BCM43xx_SHM_UCODE		0x0300
-
-/* MacFilter offsets. */
-#define BCM43xx_MACFILTER_SELF		0x0000
-#define BCM43xx_MACFILTER_ASSOC		0x0003
-
-/* Chipcommon registers. */
-#define BCM43xx_CHIPCOMMON_CAPABILITIES 	0x04
-#define BCM43xx_CHIPCOMMON_CTL			0x28
-#define BCM43xx_CHIPCOMMON_PLLONDELAY		0xB0
-#define BCM43xx_CHIPCOMMON_FREFSELDELAY		0xB4
-#define BCM43xx_CHIPCOMMON_SLOWCLKCTL		0xB8
-#define BCM43xx_CHIPCOMMON_SYSCLKCTL		0xC0
-
-/* PCI core specific registers. */
-#define BCM43xx_PCICORE_BCAST_ADDR	0x50
-#define BCM43xx_PCICORE_BCAST_DATA	0x54
-#define BCM43xx_PCICORE_SBTOPCI2	0x108
-
-/* SBTOPCI2 values. */
-#define BCM43xx_SBTOPCI2_PREFETCH	0x4
-#define BCM43xx_SBTOPCI2_BURST		0x8
-#define BCM43xx_SBTOPCI2_MEMREAD_MULTI	0x20
-
-/* PCI-E core registers. */
-#define BCM43xx_PCIECORE_REG_ADDR      0x0130
-#define BCM43xx_PCIECORE_REG_DATA      0x0134
-#define BCM43xx_PCIECORE_MDIO_CTL      0x0128
-#define BCM43xx_PCIECORE_MDIO_DATA     0x012C
-
-/* PCI-E registers. */
-#define BCM43xx_PCIE_TLP_WORKAROUND    0x0004
-#define BCM43xx_PCIE_DLLP_LINKCTL      0x0100
-
-/* PCI-E MDIO bits. */
-#define BCM43xx_PCIE_MDIO_ST   0x40000000
-#define BCM43xx_PCIE_MDIO_WT   0x10000000
-#define BCM43xx_PCIE_MDIO_DEV  22
-#define BCM43xx_PCIE_MDIO_REG  18
-#define BCM43xx_PCIE_MDIO_TA   0x00020000
-#define BCM43xx_PCIE_MDIO_TC   0x0100
-
-/* MDIO devices. */
-#define BCM43xx_MDIO_SERDES_RX	0x1F
-
-/* SERDES RX registers. */
-#define BCM43xx_SERDES_RXTIMER	0x2
-#define BCM43xx_SERDES_CDR	0x6
-#define BCM43xx_SERDES_CDR_BW	0x7
-
-/* Chipcommon capabilities. */
-#define BCM43xx_CAPABILITIES_PCTL		0x00040000
-#define BCM43xx_CAPABILITIES_PLLMASK		0x00030000
-#define BCM43xx_CAPABILITIES_PLLSHIFT		16
-#define BCM43xx_CAPABILITIES_FLASHMASK		0x00000700
-#define BCM43xx_CAPABILITIES_FLASHSHIFT		8
-#define BCM43xx_CAPABILITIES_EXTBUSPRESENT	0x00000040
-#define BCM43xx_CAPABILITIES_UARTGPIO		0x00000020
-#define BCM43xx_CAPABILITIES_UARTCLOCKMASK	0x00000018
-#define BCM43xx_CAPABILITIES_UARTCLOCKSHIFT	3
-#define BCM43xx_CAPABILITIES_MIPSBIGENDIAN	0x00000004
-#define BCM43xx_CAPABILITIES_NRUARTSMASK	0x00000003
-
-/* PowerControl */
-#define BCM43xx_PCTL_IN			0xB0
-#define BCM43xx_PCTL_OUT		0xB4
-#define BCM43xx_PCTL_OUTENABLE		0xB8
-#define BCM43xx_PCTL_XTAL_POWERUP	0x40
-#define BCM43xx_PCTL_PLL_POWERDOWN	0x80
-
-/* PowerControl Clock Modes */
-#define BCM43xx_PCTL_CLK_FAST		0x00
-#define BCM43xx_PCTL_CLK_SLOW		0x01
-#define BCM43xx_PCTL_CLK_DYNAMIC	0x02
-
-#define BCM43xx_PCTL_FORCE_SLOW		0x0800
-#define BCM43xx_PCTL_FORCE_PLL		0x1000
-#define BCM43xx_PCTL_DYN_XTAL		0x2000
-
-/* COREIDs */
-#define BCM43xx_COREID_CHIPCOMMON	0x800
-#define BCM43xx_COREID_ILINE20          0x801
-#define BCM43xx_COREID_SDRAM            0x803
-#define BCM43xx_COREID_PCI		0x804
-#define BCM43xx_COREID_MIPS             0x805
-#define BCM43xx_COREID_ETHERNET         0x806
-#define BCM43xx_COREID_V90		0x807
-#define BCM43xx_COREID_USB11_HOSTDEV    0x80a
-#define BCM43xx_COREID_IPSEC            0x80b
-#define BCM43xx_COREID_PCMCIA		0x80d
-#define BCM43xx_COREID_EXT_IF           0x80f
-#define BCM43xx_COREID_80211		0x812
-#define BCM43xx_COREID_MIPS_3302        0x816
-#define BCM43xx_COREID_USB11_HOST       0x817
-#define BCM43xx_COREID_USB11_DEV        0x818
-#define BCM43xx_COREID_USB20_HOST       0x819
-#define BCM43xx_COREID_USB20_DEV        0x81a
-#define BCM43xx_COREID_SDIO_HOST        0x81b
-#define BCM43xx_COREID_PCIE		0x820
-
-/* Core Information Registers */
-#define BCM43xx_CIR_BASE		0xf00
-#define BCM43xx_CIR_SBTPSFLAG		(BCM43xx_CIR_BASE + 0x18)
-#define BCM43xx_CIR_SBIMSTATE		(BCM43xx_CIR_BASE + 0x90)
-#define BCM43xx_CIR_SBINTVEC		(BCM43xx_CIR_BASE + 0x94)
-#define BCM43xx_CIR_SBTMSTATELOW	(BCM43xx_CIR_BASE + 0x98)
-#define BCM43xx_CIR_SBTMSTATEHIGH	(BCM43xx_CIR_BASE + 0x9c)
-#define BCM43xx_CIR_SBIMCONFIGLOW	(BCM43xx_CIR_BASE + 0xa8)
-#define BCM43xx_CIR_SB_ID_HI		(BCM43xx_CIR_BASE + 0xfc)
-
-/* Mask to get the Backplane Flag Number from SBTPSFLAG. */
-#define BCM43xx_BACKPLANE_FLAG_NR_MASK	0x3f
-
-/* SBIMCONFIGLOW values/masks. */
-#define BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_MASK		0x00000007
-#define BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_SHIFT	0
-#define BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_MASK		0x00000070
-#define BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_SHIFT	4
-#define BCM43xx_SBIMCONFIGLOW_CONNID_MASK		0x00ff0000
-#define BCM43xx_SBIMCONFIGLOW_CONNID_SHIFT		16
-
-/* sbtmstatelow state flags */
-#define BCM43xx_SBTMSTATELOW_RESET		0x01
-#define BCM43xx_SBTMSTATELOW_REJECT		0x02
-#define BCM43xx_SBTMSTATELOW_CLOCK		0x10000
-#define BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK	0x20000
-#define BCM43xx_SBTMSTATELOW_G_MODE_ENABLE	0x20000000
-
-/* sbtmstatehigh state flags */
-#define BCM43xx_SBTMSTATEHIGH_SERROR		0x00000001
-#define BCM43xx_SBTMSTATEHIGH_BUSY		0x00000004
-#define BCM43xx_SBTMSTATEHIGH_TIMEOUT		0x00000020
-#define BCM43xx_SBTMSTATEHIGH_G_PHY_AVAIL	0x00010000
-#define BCM43xx_SBTMSTATEHIGH_A_PHY_AVAIL	0x00020000
-#define BCM43xx_SBTMSTATEHIGH_COREFLAGS		0x1FFF0000
-#define BCM43xx_SBTMSTATEHIGH_DMA64BIT		0x10000000
-#define BCM43xx_SBTMSTATEHIGH_GATEDCLK		0x20000000
-#define BCM43xx_SBTMSTATEHIGH_BISTFAILED	0x40000000
-#define BCM43xx_SBTMSTATEHIGH_BISTCOMPLETE	0x80000000
-
-/* sbimstate flags */
-#define BCM43xx_SBIMSTATE_IB_ERROR		0x20000
-#define BCM43xx_SBIMSTATE_TIMEOUT		0x40000
-
-/* PHYVersioning */
-#define BCM43xx_PHYTYPE_A		0x00
-#define BCM43xx_PHYTYPE_B		0x01
-#define BCM43xx_PHYTYPE_G		0x02
-
-/* PHYRegisters */
-#define BCM43xx_PHY_ILT_A_CTRL		0x0072
-#define BCM43xx_PHY_ILT_A_DATA1		0x0073
-#define BCM43xx_PHY_ILT_A_DATA2		0x0074
-#define BCM43xx_PHY_G_LO_CONTROL	0x0810
-#define BCM43xx_PHY_ILT_G_CTRL		0x0472
-#define BCM43xx_PHY_ILT_G_DATA1		0x0473
-#define BCM43xx_PHY_ILT_G_DATA2		0x0474
-#define BCM43xx_PHY_A_PCTL		0x007B
-#define BCM43xx_PHY_G_PCTL		0x0029
-#define BCM43xx_PHY_A_CRS		0x0029
-#define BCM43xx_PHY_RADIO_BITFIELD	0x0401
-#define BCM43xx_PHY_G_CRS		0x0429
-#define BCM43xx_PHY_NRSSILT_CTRL	0x0803
-#define BCM43xx_PHY_NRSSILT_DATA	0x0804
-
-/* RadioRegisters */
-#define BCM43xx_RADIOCTL_ID		0x01
-
-/* StatusBitField */
-#define BCM43xx_SBF_MAC_ENABLED		0x00000001
-#define BCM43xx_SBF_2			0x00000002 /*FIXME: fix name*/
-#define BCM43xx_SBF_CORE_READY		0x00000004
-#define BCM43xx_SBF_400			0x00000400 /*FIXME: fix name*/
-#define BCM43xx_SBF_4000		0x00004000 /*FIXME: fix name*/
-#define BCM43xx_SBF_8000		0x00008000 /*FIXME: fix name*/
-#define BCM43xx_SBF_XFER_REG_BYTESWAP	0x00010000
-#define BCM43xx_SBF_MODE_NOTADHOC	0x00020000
-#define BCM43xx_SBF_MODE_AP		0x00040000
-#define BCM43xx_SBF_RADIOREG_LOCK	0x00080000
-#define BCM43xx_SBF_MODE_MONITOR	0x00400000
-#define BCM43xx_SBF_MODE_PROMISC	0x01000000
-#define BCM43xx_SBF_PS1			0x02000000
-#define BCM43xx_SBF_PS2			0x04000000
-#define BCM43xx_SBF_NO_SSID_BCAST	0x08000000
-#define BCM43xx_SBF_TIME_UPDATE		0x10000000
-#define BCM43xx_SBF_MODE_G		0x80000000
-
-/* Microcode */
-#define BCM43xx_UCODE_REVISION		0x0000
-#define BCM43xx_UCODE_PATCHLEVEL	0x0002
-#define BCM43xx_UCODE_DATE		0x0004
-#define BCM43xx_UCODE_TIME		0x0006
-#define BCM43xx_UCODE_STATUS		0x0040
-
-/* MicrocodeFlagsBitfield (addr + lo-word values?)*/
-#define BCM43xx_UCODEFLAGS_OFFSET	0x005E
-
-#define BCM43xx_UCODEFLAG_AUTODIV	0x0001
-#define BCM43xx_UCODEFLAG_UNKBGPHY	0x0002
-#define BCM43xx_UCODEFLAG_UNKBPHY	0x0004
-#define BCM43xx_UCODEFLAG_UNKGPHY	0x0020
-#define BCM43xx_UCODEFLAG_UNKPACTRL	0x0040
-#define BCM43xx_UCODEFLAG_JAPAN		0x0080
-
-/* Hardware Radio Enable masks */
-#define BCM43xx_MMIO_RADIO_HWENABLED_HI_MASK (1 << 16)
-#define BCM43xx_MMIO_RADIO_HWENABLED_LO_MASK (1 << 4)
-
-/* Generic-Interrupt reasons. */
-#define BCM43xx_IRQ_READY		(1 << 0)
-#define BCM43xx_IRQ_BEACON		(1 << 1)
-#define BCM43xx_IRQ_PS			(1 << 2)
-#define BCM43xx_IRQ_REG124		(1 << 5)
-#define BCM43xx_IRQ_PMQ			(1 << 6)
-#define BCM43xx_IRQ_PIO_WORKAROUND	(1 << 8)
-#define BCM43xx_IRQ_XMIT_ERROR		(1 << 11)
-#define BCM43xx_IRQ_RX			(1 << 15)
-#define BCM43xx_IRQ_SCAN		(1 << 16)
-#define BCM43xx_IRQ_NOISE		(1 << 18)
-#define BCM43xx_IRQ_XMIT_STATUS		(1 << 29)
-
-#define BCM43xx_IRQ_ALL			0xffffffff
-#define BCM43xx_IRQ_INITIAL		(BCM43xx_IRQ_PS |		\
-					 BCM43xx_IRQ_REG124 |		\
-					 BCM43xx_IRQ_PMQ |		\
-					 BCM43xx_IRQ_XMIT_ERROR |	\
-					 BCM43xx_IRQ_RX |		\
-					 BCM43xx_IRQ_SCAN |		\
-					 BCM43xx_IRQ_NOISE |		\
-					 BCM43xx_IRQ_XMIT_STATUS)
-					 
-
-/* Initial default iw_mode */
-#define BCM43xx_INITIAL_IWMODE			IW_MODE_INFRA
-
-/* Bus type PCI. */
-#define BCM43xx_BUSTYPE_PCI	0
-/* Bus type Silicone Backplane Bus. */
-#define BCM43xx_BUSTYPE_SB	1
-/* Bus type PCMCIA. */
-#define BCM43xx_BUSTYPE_PCMCIA	2
-
-/* Threshold values. */
-#define BCM43xx_MIN_RTS_THRESHOLD		1U
-#define BCM43xx_MAX_RTS_THRESHOLD		2304U
-#define BCM43xx_DEFAULT_RTS_THRESHOLD		BCM43xx_MAX_RTS_THRESHOLD
-
-#define BCM43xx_DEFAULT_SHORT_RETRY_LIMIT	7
-#define BCM43xx_DEFAULT_LONG_RETRY_LIMIT	4
-
-/* FIXME: the next line is a guess as to what the maximum RSSI value might be */
-#define RX_RSSI_MAX				60
-
-/* Max size of a security key */
-#define BCM43xx_SEC_KEYSIZE			16
-/* Security algorithms. */
-enum {
-	BCM43xx_SEC_ALGO_NONE = 0, /* unencrypted, as of TX header. */
-	BCM43xx_SEC_ALGO_WEP,
-	BCM43xx_SEC_ALGO_UNKNOWN,
-	BCM43xx_SEC_ALGO_AES,
-	BCM43xx_SEC_ALGO_WEP104,
-	BCM43xx_SEC_ALGO_TKIP,
-};
-
-#ifdef assert
-# undef assert
-#endif
-#ifdef CONFIG_BCM43XX_DEBUG
-#define assert(expr) \
-	do {									\
-		if (unlikely(!(expr))) {					\
-		printk(KERN_ERR PFX "ASSERTION FAILED (%s) at: %s:%d:%s()\n",	\
-			#expr, __FILE__, __LINE__, __FUNCTION__);		\
-		}								\
-	} while (0)
-#else
-#define assert(expr)	do { /* nothing */ } while (0)
-#endif
-
-/* rate limited printk(). */
-#ifdef printkl
-# undef printkl
-#endif
-#define printkl(f, x...)  do { if (printk_ratelimit()) printk(f ,##x); } while (0)
-/* rate limited printk() for debugging */
-#ifdef dprintkl
-# undef dprintkl
-#endif
-#ifdef CONFIG_BCM43XX_DEBUG
-# define dprintkl		printkl
-#else
-# define dprintkl(f, x...)	do { /* nothing */ } while (0)
-#endif
-
-/* Helper macro for if branches.
- * An if branch marked with this macro is only taken in DEBUG mode.
- * Example:
- *	if (DEBUG_ONLY(foo == bar)) {
- *		do something
- *	}
- *	In DEBUG mode, the branch will be taken if (foo == bar).
- *	In non-DEBUG mode, the branch will never be taken.
- */
-#ifdef DEBUG_ONLY
-# undef DEBUG_ONLY
-#endif
-#ifdef CONFIG_BCM43XX_DEBUG
-# define DEBUG_ONLY(x)	(x)
-#else
-# define DEBUG_ONLY(x)	0
-#endif
-
-/* debugging printk() */
-#ifdef dprintk
-# undef dprintk
-#endif
-#ifdef CONFIG_BCM43XX_DEBUG
-# define dprintk(f, x...)  do { printk(f ,##x); } while (0)
-#else
-# define dprintk(f, x...)  do { /* nothing */ } while (0)
-#endif
-
-
-struct net_device;
-struct pci_dev;
-struct bcm43xx_dmaring;
-struct bcm43xx_pioqueue;
-
-struct bcm43xx_initval {
-	u16 offset;
-	u16 size;
-	u32 value;
-} __attribute__((__packed__));
-
-/* Values for bcm430x_sprominfo.locale */
-enum {
-	BCM43xx_LOCALE_WORLD = 0,
-	BCM43xx_LOCALE_THAILAND,
-	BCM43xx_LOCALE_ISRAEL,
-	BCM43xx_LOCALE_JORDAN,
-	BCM43xx_LOCALE_CHINA,
-	BCM43xx_LOCALE_JAPAN,
-	BCM43xx_LOCALE_USA_CANADA_ANZ,
-	BCM43xx_LOCALE_EUROPE,
-	BCM43xx_LOCALE_USA_LOW,
-	BCM43xx_LOCALE_JAPAN_HIGH,
-	BCM43xx_LOCALE_ALL,
-	BCM43xx_LOCALE_NONE,
-};
-
-#define BCM43xx_SPROM_SIZE	64 /* in 16-bit words. */
-struct bcm43xx_sprominfo {
-	u16 boardflags2;
-	u8 il0macaddr[6];
-	u8 et0macaddr[6];
-	u8 et1macaddr[6];
-	u8 et0phyaddr:5;
-	u8 et1phyaddr:5;
-	u8 boardrev;
-	u8 locale:4;
-	u8 antennas_aphy:2;
-	u8 antennas_bgphy:2;
-	u16 pa0b0;
-	u16 pa0b1;
-	u16 pa0b2;
-	u8 wl0gpio0;
-	u8 wl0gpio1;
-	u8 wl0gpio2;
-	u8 wl0gpio3;
-	u8 maxpower_aphy;
-	u8 maxpower_bgphy;
-	u16 pa1b0;
-	u16 pa1b1;
-	u16 pa1b2;
-	u8 idle_tssi_tgt_aphy;
-	u8 idle_tssi_tgt_bgphy;
-	u16 boardflags;
-	u16 antennagain_aphy;
-	u16 antennagain_bgphy;
-};
-
-/* Value pair to measure the LocalOscillator. */
-struct bcm43xx_lopair {
-	s8 low;
-	s8 high;
-	u8 used:1;
-};
-#define BCM43xx_LO_COUNT	(14*4)
-
-struct bcm43xx_phyinfo {
-	/* Hardware Data */
-	u8 analog;
-	u8 type;
-	u8 rev;
-	u16 antenna_diversity;
-	u16 savedpctlreg;
-	u16 minlowsig[2];
-	u16 minlowsigpos[2];
-	u8 connected:1,
-	   calibrated:1,
-	   is_locked:1, /* used in bcm43xx_phy_{un}lock() */
-	   dyn_tssi_tbl:1; /* used in bcm43xx_phy_init_tssi2dbm_table() */
-	/* LO Measurement Data.
-	 * Use bcm43xx_get_lopair() to get a value.
-	 */
-	struct bcm43xx_lopair *_lo_pairs;
-
-	/* TSSI to dBm table in use */
-	const s8 *tssi2dbm;
-	/* idle TSSI value */
-	s8 idle_tssi;
-
-	/* Values from bcm43xx_calc_loopback_gain() */
-	u16 loopback_gain[2];
-
-	/* PHY lock for core.rev < 3
-	 * This lock is only used by bcm43xx_phy_{un}lock()
-	 */
-	spinlock_t lock;
-
-	/* Firmware. */
-	const struct firmware *ucode;
-	const struct firmware *pcm;
-	const struct firmware *initvals0;
-	const struct firmware *initvals1;
-};
-
-
-struct bcm43xx_radioinfo {
-	u16 manufact;
-	u16 version;
-	u8 revision;
-
-	/* Desired TX power in dBm Q5.2 */
-	u16 txpower_desired;
-	/* TX Power control values. */
-	union {
-		/* B/G PHY */
-		struct {
-			u16 baseband_atten;
-			u16 radio_atten;
-			u16 txctl1;
-			u16 txctl2;
-		};
-		/* A PHY */
-		struct {
-			u16 txpwr_offset;
-		};
-	};
-
-	/* Current Interference Mitigation mode */
-	int interfmode;
-	/* Stack of saved values from the Interference Mitigation code.
-	 * Each value in the stack is layed out as follows:
-	 * bit 0-11:  offset
-	 * bit 12-15: register ID
-	 * bit 16-32: value
-	 * register ID is: 0x1 PHY, 0x2 Radio, 0x3 ILT
-	 */
-#define BCM43xx_INTERFSTACK_SIZE	26
-	u32 interfstack[BCM43xx_INTERFSTACK_SIZE];
-
-	/* Saved values from the NRSSI Slope calculation */
-	s16 nrssi[2];
-	s32 nrssislope;
-	/* In memory nrssi lookup table. */
-	s8 nrssi_lt[64];
-
-	/* current channel */
-	u8 channel;
-	u8 initial_channel;
-
-	u16 lofcal;
-
-	u16 initval;
-
-	u8 enabled:1;
-	/* ACI (adjacent channel interference) flags. */
-	u8 aci_enable:1,
-	   aci_wlan_automatic:1,
-	   aci_hw_rssi:1;
-};
-
-/* Data structures for DMA transmission, per 80211 core. */
-struct bcm43xx_dma {
-	struct bcm43xx_dmaring *tx_ring0;
-	struct bcm43xx_dmaring *tx_ring1;
-	struct bcm43xx_dmaring *tx_ring2;
-	struct bcm43xx_dmaring *tx_ring3;
-	struct bcm43xx_dmaring *tx_ring4;
-	struct bcm43xx_dmaring *tx_ring5;
-
-	struct bcm43xx_dmaring *rx_ring0;
-	struct bcm43xx_dmaring *rx_ring3; /* only available on core.rev < 5 */
-};
-
-/* Data structures for PIO transmission, per 80211 core. */
-struct bcm43xx_pio {
-	struct bcm43xx_pioqueue *queue0;
-	struct bcm43xx_pioqueue *queue1;
-	struct bcm43xx_pioqueue *queue2;
-	struct bcm43xx_pioqueue *queue3;
-};
-
-#define BCM43xx_MAX_80211_CORES		2
-
-/* Generic information about a core. */
-struct bcm43xx_coreinfo {
-	u8 available:1,
-	   enabled:1,
-	   initialized:1;
-	/** core_rev revision number */
-	u8 rev;
-	/** Index number for _switch_core() */
-	u8 index;
-	/** core_id ID number */
-	u16 id;
-	/** Core-specific data. */
-	void *priv;
-};
-
-/* Additional information for each 80211 core. */
-struct bcm43xx_coreinfo_80211 {
-	/* PHY device. */
-	struct bcm43xx_phyinfo phy;
-	/* Radio device. */
-	struct bcm43xx_radioinfo radio;
-	union {
-		/* DMA context. */
-		struct bcm43xx_dma dma;
-		/* PIO context. */
-		struct bcm43xx_pio pio;
-	};
-};
-
-/* Context information for a noise calculation (Link Quality). */
-struct bcm43xx_noise_calculation {
-	struct bcm43xx_coreinfo *core_at_start;
-	u8 channel_at_start;
-	u8 calculation_running:1;
-	u8 nr_samples;
-	s8 samples[8][4];
-};
-
-struct bcm43xx_stats {
-	u8 noise;
-	struct iw_statistics wstats;
-	/* Store the last TX/RX times here for updating the leds. */
-	unsigned long last_tx;
-	unsigned long last_rx;
-};
-
-struct bcm43xx_key {
-	u8 enabled:1;
-	u8 algorithm;
-};
-
-/* Driver initialization status. */
-enum {
-	BCM43xx_STAT_UNINIT,		/* Uninitialized. */
-	BCM43xx_STAT_INITIALIZING,	/* init_board() in progress. */
-	BCM43xx_STAT_INITIALIZED,	/* Fully operational. */
-	BCM43xx_STAT_SHUTTINGDOWN,	/* free_board() in progress. */
-	BCM43xx_STAT_RESTARTING,	/* controller_restart() called. */
-};
-#define bcm43xx_status(bcm)		atomic_read(&(bcm)->init_status)
-#define bcm43xx_set_status(bcm, stat)	do {			\
-		atomic_set(&(bcm)->init_status, (stat));	\
-		smp_wmb();					\
-					} while (0)
-
-/*    *** THEORY OF LOCKING ***
- *
- * We have two different locks in the bcm43xx driver.
- * => bcm->mutex:    General sleeping mutex. Protects struct bcm43xx_private
- *                   and the device registers. This mutex does _not_ protect
- *                   against concurrency from the IRQ handler.
- * => bcm->irq_lock: IRQ spinlock. Protects against IRQ handler concurrency.
- *
- * Please note that, if you only take the irq_lock, you are not protected
- * against concurrency from the periodic work handlers.
- * Most times you want to take _both_ locks.
- */
-
-struct bcm43xx_private {
-	struct ieee80211_device *ieee;
-	struct ieee80211softmac_device *softmac;
-
-	struct net_device *net_dev;
-	struct pci_dev *pci_dev;
-	unsigned int irq;
-
-	void __iomem *mmio_addr;
-
-	spinlock_t irq_lock;
-	struct mutex mutex;
-
-	/* Driver initialization status BCM43xx_STAT_*** */
-	atomic_t init_status;
-
-	u16 was_initialized:1,		/* for PCI suspend/resume. */
-	    __using_pio:1,		/* Internal, use bcm43xx_using_pio(). */
-	    bad_frames_preempt:1,	/* Use "Bad Frames Preemption" (default off) */
-	    reg124_set_0x4:1,		/* Some variable to keep track of IRQ stuff. */
-	    short_preamble:1,		/* TRUE, if short preamble is enabled. */
-	    firmware_norelease:1,	/* Do not release the firmware. Used on suspend. */
-	    radio_hw_enable:1;		/* TRUE if radio is hardware enabled */
-
-	struct bcm43xx_stats stats;
-
-	/* Bus type we are connected to.
-	 * This is currently always BCM43xx_BUSTYPE_PCI
-	 */
-	u8 bustype;
-	u64 dma_mask;
-
-	u16 board_vendor;
-	u16 board_type;
-	u16 board_revision;
-
-	u16 chip_id;
-	u8 chip_rev;
-	u8 chip_package;
-
-	struct bcm43xx_sprominfo sprom;
-#define BCM43xx_NR_LEDS		4
-	struct bcm43xx_led leds[BCM43xx_NR_LEDS];
-	spinlock_t leds_lock;
-
-	/* The currently active core. */
-	struct bcm43xx_coreinfo *current_core;
-	struct bcm43xx_coreinfo *active_80211_core;
-	/* coreinfo structs for all possible cores follow.
-	 * Note that a core might not exist.
-	 * So check the coreinfo flags before using it.
-	 */
-	struct bcm43xx_coreinfo core_chipcommon;
-	struct bcm43xx_coreinfo core_pci;
-	struct bcm43xx_coreinfo core_80211[ BCM43xx_MAX_80211_CORES ];
-	/* Additional information, specific to the 80211 cores. */
-	struct bcm43xx_coreinfo_80211 core_80211_ext[ BCM43xx_MAX_80211_CORES ];
-	/* Number of available 80211 cores. */
-	int nr_80211_available;
-
-	u32 chipcommon_capabilities;
-
-	/* Reason code of the last interrupt. */
-	u32 irq_reason;
-	u32 dma_reason[6];
-	/* saved irq enable/disable state bitfield. */
-	u32 irq_savedstate;
-	/* Link Quality calculation context. */
-	struct bcm43xx_noise_calculation noisecalc;
-	/* if > 0 MAC is suspended. if == 0 MAC is enabled. */
-	int mac_suspended;
-
-	/* Threshold values. */
-	//TODO: The RTS thr has to be _used_. Currently, it is only set via WX.
-	u32 rts_threshold;
-
-	/* Interrupt Service Routine tasklet (bottom-half) */
-	struct tasklet_struct isr_tasklet;
-
-	/* Periodic tasks */
-	struct delayed_work periodic_work;
-	unsigned int periodic_state;
-
-	struct work_struct restart_work;
-
-	/* Informational stuff. */
-	char nick[IW_ESSID_MAX_SIZE + 1];
-
-	/* encryption/decryption */
-	u16 security_offset;
-	struct bcm43xx_key key[54];
-	u8 default_key_idx;
-
-	/* Random Number Generator. */
-	struct hwrng rng;
-	char rng_name[20 + 1];
-
-	/* Debugging stuff follows. */
-#ifdef CONFIG_BCM43XX_DEBUG
-	struct bcm43xx_dfsentry *dfsentry;
-#endif
-};
-
-
-static inline
-struct bcm43xx_private * bcm43xx_priv(struct net_device *dev)
-{
-	return ieee80211softmac_priv(dev);
-}
-
-struct device;
-
-static inline
-struct bcm43xx_private * dev_to_bcm(struct device *dev)
-{
-	struct net_device *net_dev;
-	struct bcm43xx_private *bcm;
-
-	net_dev = dev_get_drvdata(dev);
-	bcm = bcm43xx_priv(net_dev);
-
-	return bcm;
-}
-
-
-/* Helper function, which returns a boolean.
- * TRUE, if PIO is used; FALSE, if DMA is used.
- */
-#if defined(CONFIG_BCM43XX_DMA) && defined(CONFIG_BCM43XX_PIO)
-static inline
-int bcm43xx_using_pio(struct bcm43xx_private *bcm)
-{
-	return bcm->__using_pio;
-}
-#elif defined(CONFIG_BCM43XX_DMA)
-static inline
-int bcm43xx_using_pio(struct bcm43xx_private *bcm)
-{
-	return 0;
-}
-#elif defined(CONFIG_BCM43XX_PIO)
-static inline
-int bcm43xx_using_pio(struct bcm43xx_private *bcm)
-{
-	return 1;
-}
-#else
-# error "Using neither DMA nor PIO? Confused..."
-#endif
-
-/* Helper functions to access data structures private to the 80211 cores.
- * Note that we _must_ have an 80211 core mapped when calling
- * any of these functions.
- */
-static inline
-struct bcm43xx_coreinfo_80211 *
-bcm43xx_current_80211_priv(struct bcm43xx_private *bcm)
-{
-	assert(bcm->current_core->id == BCM43xx_COREID_80211);
-	return bcm->current_core->priv;
-}
-static inline
-struct bcm43xx_pio * bcm43xx_current_pio(struct bcm43xx_private *bcm)
-{
-	assert(bcm43xx_using_pio(bcm));
-	return &(bcm43xx_current_80211_priv(bcm)->pio);
-}
-static inline
-struct bcm43xx_dma * bcm43xx_current_dma(struct bcm43xx_private *bcm)
-{
-	assert(!bcm43xx_using_pio(bcm));
-	return &(bcm43xx_current_80211_priv(bcm)->dma);
-}
-static inline
-struct bcm43xx_phyinfo * bcm43xx_current_phy(struct bcm43xx_private *bcm)
-{
-	return &(bcm43xx_current_80211_priv(bcm)->phy);
-}
-static inline
-struct bcm43xx_radioinfo * bcm43xx_current_radio(struct bcm43xx_private *bcm)
-{
-	return &(bcm43xx_current_80211_priv(bcm)->radio);
-}
-
-
-static inline
-struct bcm43xx_lopair * bcm43xx_get_lopair(struct bcm43xx_phyinfo *phy,
-					   u16 radio_attenuation,
-					   u16 baseband_attenuation)
-{
-	return phy->_lo_pairs + (radio_attenuation + 14 * (baseband_attenuation / 2));
-}
-
-
-static inline
-u16 bcm43xx_read16(struct bcm43xx_private *bcm, u16 offset)
-{
-	return ioread16(bcm->mmio_addr + offset);
-}
-
-static inline
-void bcm43xx_write16(struct bcm43xx_private *bcm, u16 offset, u16 value)
-{
-	iowrite16(value, bcm->mmio_addr + offset);
-}
-
-static inline
-u32 bcm43xx_read32(struct bcm43xx_private *bcm, u16 offset)
-{
-	return ioread32(bcm->mmio_addr + offset);
-}
-
-static inline
-void bcm43xx_write32(struct bcm43xx_private *bcm, u16 offset, u32 value)
-{
-	iowrite32(value, bcm->mmio_addr + offset);
-}
-
-static inline
-int bcm43xx_pci_read_config16(struct bcm43xx_private *bcm, int offset, u16 *value)
-{
-	return pci_read_config_word(bcm->pci_dev, offset, value);
-}
-
-static inline
-int bcm43xx_pci_read_config32(struct bcm43xx_private *bcm, int offset, u32 *value)
-{
-	return pci_read_config_dword(bcm->pci_dev, offset, value);
-}
-
-static inline
-int bcm43xx_pci_write_config16(struct bcm43xx_private *bcm, int offset, u16 value)
-{
-	return pci_write_config_word(bcm->pci_dev, offset, value);
-}
-
-static inline
-int bcm43xx_pci_write_config32(struct bcm43xx_private *bcm, int offset, u32 value)
-{
-	return pci_write_config_dword(bcm->pci_dev, offset, value);
-}
-
-/** Limit a value between two limits */
-#ifdef limit_value
-# undef limit_value
-#endif
-#define limit_value(value, min, max)  \
-	({						\
-		typeof(value) __value = (value);	\
-	 	typeof(value) __min = (min);		\
-	 	typeof(value) __max = (max);		\
-	 	if (__value < __min)			\
-	 		__value = __min;		\
-	 	else if (__value > __max)		\
-	 		__value = __max;		\
-	 	__value;				\
-	})
-
-#endif /* BCM43xx_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.c
+++ /dev/null
@@ -1,556 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  debugfs driver debugging code
-
-  Copyright (c) 2005 Michael Buesch <mbuesch at freenet.de>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-
-
-#include <linux/fs.h>
-#include <linux/debugfs.h>
-#include <linux/slab.h>
-#include <linux/netdevice.h>
-#include <linux/pci.h>
-#include <asm/io.h>
-
-#include "bcm43xx.h"
-#include "bcm43xx_main.h"
-#include "bcm43xx_debugfs.h"
-#include "bcm43xx_dma.h"
-#include "bcm43xx_pio.h"
-#include "bcm43xx_xmit.h"
-
-#define REALLY_BIG_BUFFER_SIZE	(1024*256)
-
-static struct bcm43xx_debugfs fs;
-static char really_big_buffer[REALLY_BIG_BUFFER_SIZE];
-static DECLARE_MUTEX(big_buffer_sem);
-
-
-static ssize_t write_file_dummy(struct file *file, const char __user *buf,
-				size_t count, loff_t *ppos)
-{
-	return count;
-}
-
-static int open_file_generic(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-#define fappend(fmt, x...)	pos += snprintf(buf + pos, len - pos, fmt , ##x)
-
-static ssize_t devinfo_read_file(struct file *file, char __user *userbuf,
-				 size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	struct net_device *net_dev;
-	struct pci_dev *pci_dev;
-	unsigned long flags;
-	u16 tmp16;
-	int i;
-
-	down(&big_buffer_sem);
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
-	net_dev = bcm->net_dev;
-	pci_dev = bcm->pci_dev;
-
-	/* This is where the information is written to the "devinfo" file */
-	fappend("*** %s devinfo ***\n", net_dev->name);
-	fappend("vendor:           0x%04x   device:           0x%04x\n",
-		pci_dev->vendor, pci_dev->device);
-	fappend("subsystem_vendor: 0x%04x   subsystem_device: 0x%04x\n",
-		pci_dev->subsystem_vendor, pci_dev->subsystem_device);
-	fappend("IRQ: %d\n", bcm->irq);
-	fappend("mmio_addr: 0x%p\n", bcm->mmio_addr);
-	fappend("chip_id: 0x%04x   chip_rev: 0x%02x\n", bcm->chip_id, bcm->chip_rev);
-	if ((bcm->core_80211[0].rev >= 3) && (bcm43xx_read32(bcm, 0x0158) & (1 << 16)))
-		fappend("Radio disabled by hardware!\n");
-	if ((bcm->core_80211[0].rev < 3) && !(bcm43xx_read16(bcm, 0x049A) & (1 << 4)))
-		fappend("Radio disabled by hardware!\n");
-	fappend("board_vendor: 0x%04x   board_type: 0x%04x\n", bcm->board_vendor,
-	        bcm->board_type);
-
-	fappend("\nCores:\n");
-#define fappend_core(name, info) fappend("core \"" name "\" %s, %s, id: 0x%04x, "	\
-					 "rev: 0x%02x, index: 0x%02x\n",		\
-					 (info).available				\
-						? "available" : "nonavailable",		\
-					 (info).enabled					\
-						? "enabled" : "disabled",		\
-					 (info).id, (info).rev, (info).index)
-	fappend_core("CHIPCOMMON", bcm->core_chipcommon);
-	fappend_core("PCI", bcm->core_pci);
-	fappend_core("first 80211", bcm->core_80211[0]);
-	fappend_core("second 80211", bcm->core_80211[1]);
-#undef fappend_core
-	tmp16 = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
-	fappend("LEDs: ");
-	for (i = 0; i < BCM43xx_NR_LEDS; i++)
-		fappend("%d ", !!(tmp16 & (1 << i)));
-	fappend("\n");
-
-out:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&big_buffer_sem);
-	return res;
-}
-
-static ssize_t drvinfo_read_file(struct file *file, char __user *userbuf,
-				 size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-
-	down(&big_buffer_sem);
-
-	/* This is where the information is written to the "driver" file */
-	fappend(KBUILD_MODNAME " driver\n");
-	fappend("Compiled at: %s %s\n", __DATE__, __TIME__);
-
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&big_buffer_sem);
-	return res;
-}
-
-static ssize_t spromdump_read_file(struct file *file, char __user *userbuf,
-				 size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
-
-	down(&big_buffer_sem);
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
-
-	/* This is where the information is written to the "sprom_dump" file */
-	fappend("boardflags: 0x%04x\n", bcm->sprom.boardflags);
-
-out:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&big_buffer_sem);
-	return res;
-}
-
-static ssize_t tsf_read_file(struct file *file, char __user *userbuf,
-			     size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
-	u64 tsf;
-
-	down(&big_buffer_sem);
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
-	bcm43xx_tsf_read(bcm, &tsf);
-	fappend("0x%08x%08x\n",
-		(unsigned int)((tsf & 0xFFFFFFFF00000000ULL) >> 32),
-		(unsigned int)(tsf & 0xFFFFFFFFULL));
-
-out:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&big_buffer_sem);
-	return res;
-}
-
-static ssize_t tsf_write_file(struct file *file, const char __user *user_buf,
-			      size_t count, loff_t *ppos)
-{
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags;
-	u64 tsf;
-
-	buf_size = min(count, sizeof (really_big_buffer) - 1);
-	down(&big_buffer_sem);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-	        res = -EFAULT;
-		goto out_up;
-	}
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		printk(KERN_INFO PFX "debugfs: Board not initialized.\n");
-		res = -EFAULT;
-		goto out_unlock;
-	}
-	if (sscanf(buf, "%lli", &tsf) != 1) {
-		printk(KERN_INFO PFX "debugfs: invalid values for \"tsf\"\n");
-		res = -EINVAL;
-		goto out_unlock;
-	}
-	bcm43xx_tsf_write(bcm, tsf);
-	mmiowb();
-	res = buf_size;
-	
-out_unlock:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-out_up:
-	up(&big_buffer_sem);
-	return res;
-}
-
-static ssize_t txstat_read_file(struct file *file, char __user *userbuf,
-				size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
-	struct bcm43xx_dfsentry *e;
-	struct bcm43xx_xmitstatus *status;
-	int i, cnt, j = 0;
-
-	down(&big_buffer_sem);
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-
-	fappend("Last %d logged xmitstatus blobs (Latest first):\n\n",
-		BCM43xx_NR_LOGGED_XMITSTATUS);
-	e = bcm->dfsentry;
-	if (e->xmitstatus_printing == 0) {
-		/* At the beginning, make a copy of all data to avoid
-		 * concurrency, as this function is called multiple
-		 * times for big logs. Without copying, the data might
-		 * change between reads. This would result in total trash.
-		 */
-		e->xmitstatus_printing = 1;
-		e->saved_xmitstatus_ptr = e->xmitstatus_ptr;
-		e->saved_xmitstatus_cnt = e->xmitstatus_cnt;
-		memcpy(e->xmitstatus_print_buffer, e->xmitstatus_buffer,
-		       BCM43xx_NR_LOGGED_XMITSTATUS * sizeof(*(e->xmitstatus_buffer)));
-	}
-	i = e->saved_xmitstatus_ptr - 1;
-	if (i < 0)
-		i = BCM43xx_NR_LOGGED_XMITSTATUS - 1;
-	cnt = e->saved_xmitstatus_cnt;
-	while (cnt) {
-		status = e->xmitstatus_print_buffer + i;
-		fappend("0x%02x:   cookie: 0x%04x,  flags: 0x%02x,  "
-			"cnt1: 0x%02x,  cnt2: 0x%02x,  seq: 0x%04x,  "
-			"unk: 0x%04x\n", j,
-			status->cookie, status->flags,
-			status->cnt1, status->cnt2, status->seq,
-			status->unknown);
-		j++;
-		cnt--;
-		i--;
-		if (i < 0)
-			i = BCM43xx_NR_LOGGED_XMITSTATUS - 1;
-	}
-
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (*ppos == pos) {
-		/* Done. Drop the copied data. */
-		e->xmitstatus_printing = 0;
-	}
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-	up(&big_buffer_sem);
-	return res;
-}
-
-static ssize_t restart_write_file(struct file *file, const char __user *user_buf,
-				  size_t count, loff_t *ppos)
-{
-	struct bcm43xx_private *bcm = file->private_data;
-	char *buf = really_big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags;
-
-	buf_size = min(count, sizeof (really_big_buffer) - 1);
-	down(&big_buffer_sem);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-	        res = -EFAULT;
-		goto out_up;
-	}
-	mutex_lock(&(bcm)->mutex);
-	spin_lock_irqsave(&(bcm)->irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		printk(KERN_INFO PFX "debugfs: Board not initialized.\n");
-		res = -EFAULT;
-		goto out_unlock;
-	}
-	if (count > 0 && buf[0] == '1') {
-		bcm43xx_controller_restart(bcm, "manually restarted");
-		res = count;
-	} else
-		res = -EINVAL;
-
-out_unlock:
-	spin_unlock_irqrestore(&(bcm)->irq_lock, flags);
-	mutex_unlock(&(bcm)->mutex);
-out_up:
-	up(&big_buffer_sem);
-	return res;
-}
-
-#undef fappend
-
-
-static const struct file_operations devinfo_fops = {
-	.read = devinfo_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
-
-static const struct file_operations spromdump_fops = {
-	.read = spromdump_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
-
-static const struct file_operations drvinfo_fops = {
-	.read = drvinfo_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
-
-static const struct file_operations tsf_fops = {
-	.read = tsf_read_file,
-	.write = tsf_write_file,
-	.open = open_file_generic,
-};
-
-static const struct file_operations txstat_fops = {
-	.read = txstat_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
-
-static const struct file_operations restart_fops = {
-	.write = restart_write_file,
-	.open = open_file_generic,
-};
-
-
-void bcm43xx_debugfs_add_device(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_dfsentry *e;
-	char devdir[IFNAMSIZ];
-
-	assert(bcm);
-	e = kzalloc(sizeof(*e), GFP_KERNEL);
-	if (!e) {
-		printk(KERN_ERR PFX "out of memory\n");
-		return;
-	}
-	e->bcm = bcm;
-	e->xmitstatus_buffer = kzalloc(BCM43xx_NR_LOGGED_XMITSTATUS
-				       * sizeof(*(e->xmitstatus_buffer)),
-				       GFP_KERNEL);
-	if (!e->xmitstatus_buffer) {
-		printk(KERN_ERR PFX "out of memory\n");
-		kfree(e);
-		return;
-	}
-	e->xmitstatus_print_buffer = kzalloc(BCM43xx_NR_LOGGED_XMITSTATUS
-					     * sizeof(*(e->xmitstatus_buffer)),
-					     GFP_KERNEL);
-	if (!e->xmitstatus_print_buffer) {
-		printk(KERN_ERR PFX "out of memory\n");
-		kfree(e);
-		return;
-	}
-
-
-	bcm->dfsentry = e;
-
-	strncpy(devdir, bcm->net_dev->name, ARRAY_SIZE(devdir));
-	e->subdir = debugfs_create_dir(devdir, fs.root);
-	e->dentry_devinfo = debugfs_create_file("devinfo", 0444, e->subdir,
-						bcm, &devinfo_fops);
-	if (!e->dentry_devinfo)
-		printk(KERN_ERR PFX "debugfs: creating \"devinfo\" for \"%s\" failed!\n", devdir);
-	e->dentry_spromdump = debugfs_create_file("sprom_dump", 0444, e->subdir,
-						  bcm, &spromdump_fops);
-	if (!e->dentry_spromdump)
-		printk(KERN_ERR PFX "debugfs: creating \"sprom_dump\" for \"%s\" failed!\n", devdir);
-	e->dentry_tsf = debugfs_create_file("tsf", 0666, e->subdir,
-	                                    bcm, &tsf_fops);
-	if (!e->dentry_tsf)
-		printk(KERN_ERR PFX "debugfs: creating \"tsf\" for \"%s\" failed!\n", devdir);
-	e->dentry_txstat = debugfs_create_file("tx_status", 0444, e->subdir,
-						bcm, &txstat_fops);
-	if (!e->dentry_txstat)
-		printk(KERN_ERR PFX "debugfs: creating \"tx_status\" for \"%s\" failed!\n", devdir);
-	e->dentry_restart = debugfs_create_file("restart", 0222, e->subdir,
-						bcm, &restart_fops);
-	if (!e->dentry_restart)
-		printk(KERN_ERR PFX "debugfs: creating \"restart\" for \"%s\" failed!\n", devdir);
-}
-
-void bcm43xx_debugfs_remove_device(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_dfsentry *e;
-
-	if (!bcm)
-		return;
-
-	e = bcm->dfsentry;
-	assert(e);
-	debugfs_remove(e->dentry_spromdump);
-	debugfs_remove(e->dentry_devinfo);
-	debugfs_remove(e->dentry_tsf);
-	debugfs_remove(e->dentry_txstat);
-	debugfs_remove(e->dentry_restart);
-	debugfs_remove(e->subdir);
-	kfree(e->xmitstatus_buffer);
-	kfree(e->xmitstatus_print_buffer);
-	kfree(e);
-}
-
-void bcm43xx_debugfs_log_txstat(struct bcm43xx_private *bcm,
-				struct bcm43xx_xmitstatus *status)
-{
-	struct bcm43xx_dfsentry *e;
-	struct bcm43xx_xmitstatus *savedstatus;
-
-	/* This is protected by bcm->_lock */
-	e = bcm->dfsentry;
-	assert(e);
-	savedstatus = e->xmitstatus_buffer + e->xmitstatus_ptr;
-	memcpy(savedstatus, status, sizeof(*status));
-	e->xmitstatus_ptr++;
-	if (e->xmitstatus_ptr >= BCM43xx_NR_LOGGED_XMITSTATUS)
-		e->xmitstatus_ptr = 0;
-	if (e->xmitstatus_cnt < BCM43xx_NR_LOGGED_XMITSTATUS)
-		e->xmitstatus_cnt++;
-}
-
-void bcm43xx_debugfs_init(void)
-{
-	memset(&fs, 0, sizeof(fs));
-	fs.root = debugfs_create_dir(KBUILD_MODNAME, NULL);
-	if (!fs.root)
-		printk(KERN_ERR PFX "debugfs: creating \"" KBUILD_MODNAME "\" subdir failed!\n");
-	fs.dentry_driverinfo = debugfs_create_file("driver", 0444, fs.root, NULL, &drvinfo_fops);
-	if (!fs.dentry_driverinfo)
-		printk(KERN_ERR PFX "debugfs: creating \"" KBUILD_MODNAME "/driver\" failed!\n");
-}
-
-void bcm43xx_debugfs_exit(void)
-{
-	debugfs_remove(fs.dentry_driverinfo);
-	debugfs_remove(fs.root);
-}
-
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description)
-{
-	size_t i;
-	char c;
-
-	printk(KERN_INFO PFX "Data dump (%s, %zd bytes):",
-	       description, size);
-	for (i = 0; i < size; i++) {
-		c = data[i];
-		if (i % 8 == 0)
-			printk("\n" KERN_INFO PFX "0x%08zx:  0x%02x, ", i, c & 0xff);
-		else
-			printk("0x%02x, ", c & 0xff);
-	}
-	printk("\n");
-}
-
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description)
-{
-	size_t i;
-	int j;
-	const unsigned char *d;
-
-	printk(KERN_INFO PFX "*** Bitdump (%s, %zd bytes, %s) ***",
-	       description, bytes, msb_to_lsb ? "MSB to LSB" : "LSB to MSB");
-	for (i = 0; i < bytes; i++) {
-		d = data + i;
-		if (i % 8 == 0)
-			printk("\n" KERN_INFO PFX "0x%08zx:  ", i);
-		if (msb_to_lsb) {
-			for (j = 7; j >= 0; j--) {
-				if (*d & (1 << j))
-					printk("1");
-				else
-					printk("0");
-			}
-		} else {
-			for (j = 0; j < 8; j++) {
-				if (*d & (1 << j))
-					printk("1");
-				else
-					printk("0");
-			}
-		}
-		printk(" ");
-	}
-	printk("\n");
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.h
+++ /dev/null
@@ -1,118 +0,0 @@
-#ifndef BCM43xx_DEBUGFS_H_
-#define BCM43xx_DEBUGFS_H_
-
-struct bcm43xx_private;
-struct bcm43xx_xmitstatus;
-
-#ifdef CONFIG_BCM43XX_DEBUG
-
-#include <linux/list.h>
-#include <asm/semaphore.h>
-
-struct dentry;
-
-/* limited by the size of the "really_big_buffer" */
-#define BCM43xx_NR_LOGGED_XMITSTATUS	100
-
-struct bcm43xx_dfsentry {
-	struct dentry *subdir;
-	struct dentry *dentry_devinfo;
-	struct dentry *dentry_spromdump;
-	struct dentry *dentry_tsf;
-	struct dentry *dentry_txstat;
-	struct dentry *dentry_restart;
-
-	struct bcm43xx_private *bcm;
-
-	/* saved xmitstatus. */
-	struct bcm43xx_xmitstatus *xmitstatus_buffer;
-	int xmitstatus_ptr;
-	int xmitstatus_cnt;
-	/* We need a seperate buffer while printing to avoid
-	 * concurrency issues. (New xmitstatus can arrive
-	 * while we are printing).
-	 */
-	struct bcm43xx_xmitstatus *xmitstatus_print_buffer;
-	int saved_xmitstatus_ptr;
-	int saved_xmitstatus_cnt;
-	int xmitstatus_printing;
-};
-
-struct bcm43xx_debugfs {
-	struct dentry *root;
-	struct dentry *dentry_driverinfo;
-};
-
-void bcm43xx_debugfs_init(void);
-void bcm43xx_debugfs_exit(void);
-void bcm43xx_debugfs_add_device(struct bcm43xx_private *bcm);
-void bcm43xx_debugfs_remove_device(struct bcm43xx_private *bcm);
-void bcm43xx_debugfs_log_txstat(struct bcm43xx_private *bcm,
-				struct bcm43xx_xmitstatus *status);
-
-/* Debug helper: Dump binary data through printk. */
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description);
-/* Debug helper: Dump bitwise binary data through printk. */
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description);
-#define bcm43xx_printk_bitdumpt(pointer, msb_to_lsb, description) \
-	do {									\
-		bcm43xx_printk_bitdump((const unsigned char *)(pointer),	\
-				       sizeof(*(pointer)),			\
-				       (msb_to_lsb),				\
-				       (description));				\
-	} while (0)
-
-#else /* CONFIG_BCM43XX_DEBUG*/
-
-static inline
-void bcm43xx_debugfs_init(void) { }
-static inline
-void bcm43xx_debugfs_exit(void) { }
-static inline
-void bcm43xx_debugfs_add_device(struct bcm43xx_private *bcm) { }
-static inline
-void bcm43xx_debugfs_remove_device(struct bcm43xx_private *bcm) { }
-static inline
-void bcm43xx_debugfs_log_txstat(struct bcm43xx_private *bcm,
-				struct bcm43xx_xmitstatus *status) { }
-
-static inline
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description)
-{
-}
-static inline
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description)
-{
-}
-#define bcm43xx_printk_bitdumpt(pointer, msb_to_lsb, description)  do { /* nothing */ } while (0)
-
-#endif /* CONFIG_BCM43XX_DEBUG*/
-
-/* Ugly helper macros to make incomplete code more verbose on runtime */
-#ifdef TODO
-# undef TODO
-#endif
-#define TODO()  \
-	do {										\
-		printk(KERN_INFO PFX "TODO: Incomplete code in %s() at %s:%d\n",	\
-		       __FUNCTION__, __FILE__, __LINE__);				\
-	} while (0)
-
-#ifdef FIXME
-# undef FIXME
-#endif
-#define FIXME()  \
-	do {										\
-		printk(KERN_INFO PFX "FIXME: Possibly broken code in %s() at %s:%d\n",	\
-		       __FUNCTION__, __FILE__, __LINE__);				\
-	} while (0)
-
-#endif /* BCM43xx_DEBUGFS_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_dma.c
+++ /dev/null
@@ -1,1263 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  DMA ringbuffer and descriptor allocation/management
-
-  Copyright (c) 2005, 2006 Michael Buesch <mbuesch at freenet.de>
-
-  Some code in this file is derived from the b44.c driver
-  Copyright (C) 2002 David S. Miller
-  Copyright (C) Pekka Pietikainen
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include "bcm43xx.h"
-#include "bcm43xx_dma.h"
-#include "bcm43xx_main.h"
-#include "bcm43xx_debugfs.h"
-#include "bcm43xx_power.h"
-#include "bcm43xx_xmit.h"
-
-#include <linux/dma-mapping.h>
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include <linux/skbuff.h>
-
-
-static inline int free_slots(struct bcm43xx_dmaring *ring)
-{
-	return (ring->nr_slots - ring->used_slots);
-}
-
-static inline int next_slot(struct bcm43xx_dmaring *ring, int slot)
-{
-	assert(slot >= -1 && slot <= ring->nr_slots - 1);
-	if (slot == ring->nr_slots - 1)
-		return 0;
-	return slot + 1;
-}
-
-static inline int prev_slot(struct bcm43xx_dmaring *ring, int slot)
-{
-	assert(slot >= 0 && slot <= ring->nr_slots - 1);
-	if (slot == 0)
-		return ring->nr_slots - 1;
-	return slot - 1;
-}
-
-/* Request a slot for usage. */
-static inline
-int request_slot(struct bcm43xx_dmaring *ring)
-{
-	int slot;
-
-	assert(ring->tx);
-	assert(!ring->suspended);
-	assert(free_slots(ring) != 0);
-
-	slot = next_slot(ring, ring->current_slot);
-	ring->current_slot = slot;
-	ring->used_slots++;
-
-	/* Check the number of available slots and suspend TX,
-	 * if we are running low on free slots.
-	 */
-	if (unlikely(free_slots(ring) < ring->suspend_mark)) {
-		netif_stop_queue(ring->bcm->net_dev);
-		ring->suspended = 1;
-	}
-#ifdef CONFIG_BCM43XX_DEBUG
-	if (ring->used_slots > ring->max_used_slots)
-		ring->max_used_slots = ring->used_slots;
-#endif /* CONFIG_BCM43XX_DEBUG*/
-
-	return slot;
-}
-
-/* Return a slot to the free slots. */
-static inline
-void return_slot(struct bcm43xx_dmaring *ring, int slot)
-{
-	assert(ring->tx);
-
-	ring->used_slots--;
-
-	/* Check if TX is suspended and check if we have
-	 * enough free slots to resume it again.
-	 */
-	if (unlikely(ring->suspended)) {
-		if (free_slots(ring) >= ring->resume_mark) {
-			ring->suspended = 0;
-			netif_wake_queue(ring->bcm->net_dev);
-		}
-	}
-}
-
-u16 bcm43xx_dmacontroller_base(int dma64bit, int controller_idx)
-{
-	static const u16 map64[] = {
-		BCM43xx_MMIO_DMA64_BASE0,
-		BCM43xx_MMIO_DMA64_BASE1,
-		BCM43xx_MMIO_DMA64_BASE2,
-		BCM43xx_MMIO_DMA64_BASE3,
-		BCM43xx_MMIO_DMA64_BASE4,
-		BCM43xx_MMIO_DMA64_BASE5,
-	};
-	static const u16 map32[] = {
-		BCM43xx_MMIO_DMA32_BASE0,
-		BCM43xx_MMIO_DMA32_BASE1,
-		BCM43xx_MMIO_DMA32_BASE2,
-		BCM43xx_MMIO_DMA32_BASE3,
-		BCM43xx_MMIO_DMA32_BASE4,
-		BCM43xx_MMIO_DMA32_BASE5,
-	};
-
-	if (dma64bit) {
-		assert(controller_idx >= 0 &&
-		       controller_idx < ARRAY_SIZE(map64));
-		return map64[controller_idx];
-	}
-	assert(controller_idx >= 0 &&
-	       controller_idx < ARRAY_SIZE(map32));
-	return map32[controller_idx];
-}
-
-static inline
-dma_addr_t map_descbuffer(struct bcm43xx_dmaring *ring,
-			  unsigned char *buf,
-			  size_t len,
-			  int tx)
-{
-	dma_addr_t dmaaddr;
-	int direction = PCI_DMA_FROMDEVICE;
-
-	if (tx)
-		direction = PCI_DMA_TODEVICE;
-
-	dmaaddr = pci_map_single(ring->bcm->pci_dev,
-					 buf, len,
-					 direction);
-
-	return dmaaddr;
-}
-
-static inline
-void unmap_descbuffer(struct bcm43xx_dmaring *ring,
-		      dma_addr_t addr,
-		      size_t len,
-		      int tx)
-{
-	if (tx) {
-		pci_unmap_single(ring->bcm->pci_dev,
-				 addr, len,
-				 PCI_DMA_TODEVICE);
-	} else {
-		pci_unmap_single(ring->bcm->pci_dev,
-				 addr, len,
-				 PCI_DMA_FROMDEVICE);
-	}
-}
-
-static inline
-void sync_descbuffer_for_cpu(struct bcm43xx_dmaring *ring,
-			     dma_addr_t addr,
-			     size_t len)
-{
-	assert(!ring->tx);
-
-	pci_dma_sync_single_for_cpu(ring->bcm->pci_dev,
-				    addr, len, PCI_DMA_FROMDEVICE);
-}
-
-static inline
-void sync_descbuffer_for_device(struct bcm43xx_dmaring *ring,
-				dma_addr_t addr,
-				size_t len)
-{
-	assert(!ring->tx);
-
-	pci_dma_sync_single_for_cpu(ring->bcm->pci_dev,
-				    addr, len, PCI_DMA_TODEVICE);
-}
-
-/* Unmap and free a descriptor buffer. */
-static inline
-void free_descriptor_buffer(struct bcm43xx_dmaring *ring,
-			    struct bcm43xx_dmadesc_meta *meta,
-			    int irq_context)
-{
-	assert(meta->skb);
-	if (irq_context)
-		dev_kfree_skb_irq(meta->skb);
-	else
-		dev_kfree_skb(meta->skb);
-	meta->skb = NULL;
-}
-
-static int alloc_ringmemory(struct bcm43xx_dmaring *ring)
-{
-	ring->descbase = pci_alloc_consistent(ring->bcm->pci_dev, BCM43xx_DMA_RINGMEMSIZE,
-					    &(ring->dmabase));
-	if (!ring->descbase) {
-		/* Allocation may have failed due to pci_alloc_consistent
-		   insisting on use of GFP_DMA, which is more restrictive
-		   than necessary...  */
-		struct dma_desc *rx_ring;
-		dma_addr_t rx_ring_dma;
-
-		rx_ring = kzalloc(BCM43xx_DMA_RINGMEMSIZE, GFP_KERNEL);
-		if (!rx_ring)
-			goto out_err;
-
-		rx_ring_dma = pci_map_single(ring->bcm->pci_dev, rx_ring,
-					     BCM43xx_DMA_RINGMEMSIZE,
-					     PCI_DMA_BIDIRECTIONAL);
-
-		if (pci_dma_mapping_error(rx_ring_dma) ||
-		    rx_ring_dma + BCM43xx_DMA_RINGMEMSIZE > ring->bcm->dma_mask) {
-			/* Sigh... */
-			if (!pci_dma_mapping_error(rx_ring_dma))
-				pci_unmap_single(ring->bcm->pci_dev,
-						 rx_ring_dma, BCM43xx_DMA_RINGMEMSIZE,
-						 PCI_DMA_BIDIRECTIONAL);
-			rx_ring_dma = pci_map_single(ring->bcm->pci_dev,
-						 rx_ring, BCM43xx_DMA_RINGMEMSIZE,
-						 PCI_DMA_BIDIRECTIONAL);
-			if (pci_dma_mapping_error(rx_ring_dma) ||
-			    rx_ring_dma + BCM43xx_DMA_RINGMEMSIZE > ring->bcm->dma_mask) {
-				assert(0);
-				if (!pci_dma_mapping_error(rx_ring_dma))
-					pci_unmap_single(ring->bcm->pci_dev,
-							 rx_ring_dma, BCM43xx_DMA_RINGMEMSIZE,
-							 PCI_DMA_BIDIRECTIONAL);
-				goto out_err;
-			}
-                }
-
-                ring->descbase = rx_ring;
-                ring->dmabase = rx_ring_dma;
-	}
-	memset(ring->descbase, 0, BCM43xx_DMA_RINGMEMSIZE);
-
-	return 0;
-out_err:
-	printk(KERN_ERR PFX "DMA ringmemory allocation failed\n");
-	return -ENOMEM;
-}
-
-static void free_ringmemory(struct bcm43xx_dmaring *ring)
-{
-	struct device *dev = &(ring->bcm->pci_dev->dev);
-
-	dma_free_coherent(dev, BCM43xx_DMA_RINGMEMSIZE,
-			  ring->descbase, ring->dmabase);
-}
-
-/* Reset the RX DMA channel */
-int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_private *bcm,
-				   u16 mmio_base, int dma64)
-{
-	int i;
-	u32 value;
-	u16 offset;
-
-	offset = dma64 ? BCM43xx_DMA64_RXCTL : BCM43xx_DMA32_RXCTL;
-	bcm43xx_write32(bcm, mmio_base + offset, 0);
-	for (i = 0; i < 1000; i++) {
-		offset = dma64 ? BCM43xx_DMA64_RXSTATUS : BCM43xx_DMA32_RXSTATUS;
-		value = bcm43xx_read32(bcm, mmio_base + offset);
-		if (dma64) {
-			value &= BCM43xx_DMA64_RXSTAT;
-			if (value == BCM43xx_DMA64_RXSTAT_DISABLED) {
-				i = -1;
-				break;
-			}
-		} else {
-			value &= BCM43xx_DMA32_RXSTATE;
-			if (value == BCM43xx_DMA32_RXSTAT_DISABLED) {
-				i = -1;
-				break;
-			}
-		}
-		udelay(10);
-	}
-	if (i != -1) {
-		printk(KERN_ERR PFX "Error: Wait on DMA RX status timed out.\n");
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-/* Reset the RX DMA channel */
-int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_private *bcm,
-				   u16 mmio_base, int dma64)
-{
-	int i;
-	u32 value;
-	u16 offset;
-
-	for (i = 0; i < 1000; i++) {
-		offset = dma64 ? BCM43xx_DMA64_TXSTATUS : BCM43xx_DMA32_TXSTATUS;
-		value = bcm43xx_read32(bcm, mmio_base + offset);
-		if (dma64) {
-			value &= BCM43xx_DMA64_TXSTAT;
-			if (value == BCM43xx_DMA64_TXSTAT_DISABLED ||
-			    value == BCM43xx_DMA64_TXSTAT_IDLEWAIT ||
-			    value == BCM43xx_DMA64_TXSTAT_STOPPED)
-				break;
-		} else {
-			value &= BCM43xx_DMA32_TXSTATE;
-			if (value == BCM43xx_DMA32_TXSTAT_DISABLED ||
-			    value == BCM43xx_DMA32_TXSTAT_IDLEWAIT ||
-			    value == BCM43xx_DMA32_TXSTAT_STOPPED)
-				break;
-		}
-		udelay(10);
-	}
-	offset = dma64 ? BCM43xx_DMA64_TXCTL : BCM43xx_DMA32_TXCTL;
-	bcm43xx_write32(bcm, mmio_base + offset, 0);
-	for (i = 0; i < 1000; i++) {
-		offset = dma64 ? BCM43xx_DMA64_TXSTATUS : BCM43xx_DMA32_TXSTATUS;
-		value = bcm43xx_read32(bcm, mmio_base + offset);
-		if (dma64) {
-			value &= BCM43xx_DMA64_TXSTAT;
-			if (value == BCM43xx_DMA64_TXSTAT_DISABLED) {
-				i = -1;
-				break;
-			}
-		} else {
-			value &= BCM43xx_DMA32_TXSTATE;
-			if (value == BCM43xx_DMA32_TXSTAT_DISABLED) {
-				i = -1;
-				break;
-			}
-		}
-		udelay(10);
-	}
-	if (i != -1) {
-		printk(KERN_ERR PFX "Error: Wait on DMA TX status timed out.\n");
-		return -ENODEV;
-	}
-	/* ensure the reset is completed. */
-	udelay(300);
-
-	return 0;
-}
-
-static void fill_descriptor(struct bcm43xx_dmaring *ring,
-			    struct bcm43xx_dmadesc_generic *desc,
-			    dma_addr_t dmaaddr,
-			    u16 bufsize,
-			    int start, int end, int irq)
-{
-	int slot;
-
-	slot = bcm43xx_dma_desc2idx(ring, desc);
-	assert(slot >= 0 && slot < ring->nr_slots);
-
-	if (ring->dma64) {
-		u32 ctl0 = 0, ctl1 = 0;
-		u32 addrlo, addrhi;
-		u32 addrext;
-
-		addrlo = (u32)(dmaaddr & 0xFFFFFFFF);
-		addrhi = (((u64)dmaaddr >> 32) & ~BCM43xx_DMA64_ROUTING);
-		addrext = (((u64)dmaaddr >> 32) >> BCM43xx_DMA64_ROUTING_SHIFT);
-		addrhi |= ring->routing;
-		if (slot == ring->nr_slots - 1)
-			ctl0 |= BCM43xx_DMA64_DCTL0_DTABLEEND;
-		if (start)
-			ctl0 |= BCM43xx_DMA64_DCTL0_FRAMESTART;
-		if (end)
-			ctl0 |= BCM43xx_DMA64_DCTL0_FRAMEEND;
-		if (irq)
-			ctl0 |= BCM43xx_DMA64_DCTL0_IRQ;
-		ctl1 |= (bufsize - ring->frameoffset)
-			& BCM43xx_DMA64_DCTL1_BYTECNT;
-		ctl1 |= (addrext << BCM43xx_DMA64_DCTL1_ADDREXT_SHIFT)
-			& BCM43xx_DMA64_DCTL1_ADDREXT_MASK;
-
-		desc->dma64.control0 = cpu_to_le32(ctl0);
-		desc->dma64.control1 = cpu_to_le32(ctl1);
-		desc->dma64.address_low = cpu_to_le32(addrlo);
-		desc->dma64.address_high = cpu_to_le32(addrhi);
-	} else {
-		u32 ctl;
-		u32 addr;
-		u32 addrext;
-
-		addr = (u32)(dmaaddr & ~BCM43xx_DMA32_ROUTING);
-		addrext = (u32)(dmaaddr & BCM43xx_DMA32_ROUTING)
-			   >> BCM43xx_DMA32_ROUTING_SHIFT;
-		addr |= ring->routing;
-		ctl = (bufsize - ring->frameoffset)
-		      & BCM43xx_DMA32_DCTL_BYTECNT;
-		if (slot == ring->nr_slots - 1)
-			ctl |= BCM43xx_DMA32_DCTL_DTABLEEND;
-		if (start)
-			ctl |= BCM43xx_DMA32_DCTL_FRAMESTART;
-		if (end)
-			ctl |= BCM43xx_DMA32_DCTL_FRAMEEND;
-		if (irq)
-			ctl |= BCM43xx_DMA32_DCTL_IRQ;
-		ctl |= (addrext << BCM43xx_DMA32_DCTL_ADDREXT_SHIFT)
-		       & BCM43xx_DMA32_DCTL_ADDREXT_MASK;
-
-		desc->dma32.control = cpu_to_le32(ctl);
-		desc->dma32.address = cpu_to_le32(addr);
-	}
-}
-
-static int setup_rx_descbuffer(struct bcm43xx_dmaring *ring,
-			       struct bcm43xx_dmadesc_generic *desc,
-			       struct bcm43xx_dmadesc_meta *meta,
-			       gfp_t gfp_flags)
-{
-	struct bcm43xx_rxhdr *rxhdr;
-	struct bcm43xx_hwxmitstatus *xmitstat;
-	dma_addr_t dmaaddr;
-	struct sk_buff *skb;
-
-	assert(!ring->tx);
-
-	skb = __dev_alloc_skb(ring->rx_buffersize, gfp_flags);
-	if (unlikely(!skb))
-		return -ENOMEM;
-	dmaaddr = map_descbuffer(ring, skb->data, ring->rx_buffersize, 0);
-	/* This hardware bug work-around adapted from the b44 driver.
-	   The chip may be unable to do PCI DMA to/from anything above 1GB */
-	if (pci_dma_mapping_error(dmaaddr) ||
-	    dmaaddr + ring->rx_buffersize > ring->bcm->dma_mask) {
-		/* This one has 30-bit addressing... */
-		if (!pci_dma_mapping_error(dmaaddr))
-			pci_unmap_single(ring->bcm->pci_dev,
-					 dmaaddr, ring->rx_buffersize,
-					 PCI_DMA_FROMDEVICE);
-		dev_kfree_skb_any(skb);
-		skb = __dev_alloc_skb(ring->rx_buffersize,GFP_DMA);
-		if (skb == NULL)
-			return -ENOMEM;
-		dmaaddr = pci_map_single(ring->bcm->pci_dev,
-					 skb->data, ring->rx_buffersize,
-					 PCI_DMA_FROMDEVICE);
-		if (pci_dma_mapping_error(dmaaddr) ||
-		    dmaaddr + ring->rx_buffersize > ring->bcm->dma_mask) {
-			assert(0);
-			dev_kfree_skb_any(skb);
-			return -ENOMEM;
-		}
-	}
-	meta->skb = skb;
-	meta->dmaaddr = dmaaddr;
-	skb->dev = ring->bcm->net_dev;
-
-	fill_descriptor(ring, desc, dmaaddr,
-			ring->rx_buffersize, 0, 0, 0);
-
-	rxhdr = (struct bcm43xx_rxhdr *)(skb->data);
-	rxhdr->frame_length = 0;
-	rxhdr->flags1 = 0;
-	xmitstat = (struct bcm43xx_hwxmitstatus *)(skb->data);
-	xmitstat->cookie = 0;
-
-	return 0;
-}
-
-/* Allocate the initial descbuffers.
- * This is used for an RX ring only.
- */
-static int alloc_initial_descbuffers(struct bcm43xx_dmaring *ring)
-{
-	int i, err = -ENOMEM;
-	struct bcm43xx_dmadesc_generic *desc;
-	struct bcm43xx_dmadesc_meta *meta;
-
-	for (i = 0; i < ring->nr_slots; i++) {
-		desc = bcm43xx_dma_idx2desc(ring, i, &meta);
-
-		err = setup_rx_descbuffer(ring, desc, meta, GFP_KERNEL);
-		if (err)
-			goto err_unwind;
-	}
-	mb();
-	ring->used_slots = ring->nr_slots;
-	err = 0;
-out:
-	return err;
-
-err_unwind:
-	for (i--; i >= 0; i--) {
-		desc = bcm43xx_dma_idx2desc(ring, i, &meta);
-
-		unmap_descbuffer(ring, meta->dmaaddr, ring->rx_buffersize, 0);
-		dev_kfree_skb(meta->skb);
-	}
-	goto out;
-}
-
-/* Do initial setup of the DMA controller.
- * Reset the controller, write the ring busaddress
- * and switch the "enable" bit on.
- */
-static int dmacontroller_setup(struct bcm43xx_dmaring *ring)
-{
-	int err = 0;
-	u32 value;
-	u32 addrext;
-
-	if (ring->tx) {
-		if (ring->dma64) {
-			u64 ringbase = (u64)(ring->dmabase);
-
-			addrext = ((ringbase >> 32) >> BCM43xx_DMA64_ROUTING_SHIFT);
-			value = BCM43xx_DMA64_TXENABLE;
-			value |= (addrext << BCM43xx_DMA64_TXADDREXT_SHIFT)
-				& BCM43xx_DMA64_TXADDREXT_MASK;
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXCTL, value);
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGLO,
-					(ringbase & 0xFFFFFFFF));
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGHI,
-					((ringbase >> 32) & ~BCM43xx_DMA64_ROUTING)
-					| ring->routing);
-		} else {
-			u32 ringbase = (u32)(ring->dmabase);
-
-			addrext = (ringbase >> BCM43xx_DMA32_ROUTING_SHIFT);
-			value = BCM43xx_DMA32_TXENABLE;
-			value |= (addrext << BCM43xx_DMA32_TXADDREXT_SHIFT)
-				& BCM43xx_DMA32_TXADDREXT_MASK;
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_TXCTL, value);
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_TXRING,
-					(ringbase & ~BCM43xx_DMA32_ROUTING)
-					| ring->routing);
-		}
-	} else {
-		err = alloc_initial_descbuffers(ring);
-		if (err)
-			goto out;
-		if (ring->dma64) {
-			u64 ringbase = (u64)(ring->dmabase);
-
-			addrext = ((ringbase >> 32) >> BCM43xx_DMA64_ROUTING_SHIFT);
-			value = (ring->frameoffset << BCM43xx_DMA64_RXFROFF_SHIFT);
-			value |= BCM43xx_DMA64_RXENABLE;
-			value |= (addrext << BCM43xx_DMA64_RXADDREXT_SHIFT)
-				& BCM43xx_DMA64_RXADDREXT_MASK;
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXCTL, value);
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGLO,
-					(ringbase & 0xFFFFFFFF));
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGHI,
-					((ringbase >> 32) & ~BCM43xx_DMA64_ROUTING)
-					| ring->routing);
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXINDEX, 200);
-		} else {
-			u32 ringbase = (u32)(ring->dmabase);
-
-			addrext = (ringbase >> BCM43xx_DMA32_ROUTING_SHIFT);
-			value = (ring->frameoffset << BCM43xx_DMA32_RXFROFF_SHIFT);
-			value |= BCM43xx_DMA32_RXENABLE;
-			value |= (addrext << BCM43xx_DMA32_RXADDREXT_SHIFT)
-				& BCM43xx_DMA32_RXADDREXT_MASK;
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXCTL, value);
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXRING,
-					(ringbase & ~BCM43xx_DMA32_ROUTING)
-					| ring->routing);
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXINDEX, 200);
-		}
-	}
-
-out:
-	return err;
-}
-
-/* Shutdown the DMA controller. */
-static void dmacontroller_cleanup(struct bcm43xx_dmaring *ring)
-{
-	if (ring->tx) {
-		bcm43xx_dmacontroller_tx_reset(ring->bcm, ring->mmio_base, ring->dma64);
-		if (ring->dma64) {
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGLO, 0);
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGHI, 0);
-		} else
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_TXRING, 0);
-	} else {
-		bcm43xx_dmacontroller_rx_reset(ring->bcm, ring->mmio_base, ring->dma64);
-		if (ring->dma64) {
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGLO, 0);
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGHI, 0);
-		} else
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXRING, 0);
-	}
-}
-
-static void free_all_descbuffers(struct bcm43xx_dmaring *ring)
-{
-	struct bcm43xx_dmadesc_generic *desc;
-	struct bcm43xx_dmadesc_meta *meta;
-	int i;
-
-	if (!ring->used_slots)
-		return;
-	for (i = 0; i < ring->nr_slots; i++) {
-		desc = bcm43xx_dma_idx2desc(ring, i, &meta);
-
-		if (!meta->skb) {
-			assert(ring->tx);
-			continue;
-		}
-		if (ring->tx) {
-			unmap_descbuffer(ring, meta->dmaaddr,
-					meta->skb->len, 1);
-		} else {
-			unmap_descbuffer(ring, meta->dmaaddr,
-					ring->rx_buffersize, 0);
-		}
-		free_descriptor_buffer(ring, meta, 0);
-	}
-}
-
-/* Main initialization function. */
-static
-struct bcm43xx_dmaring * bcm43xx_setup_dmaring(struct bcm43xx_private *bcm,
-					       int controller_index,
-					       int for_tx,
-					       int dma64)
-{
-	struct bcm43xx_dmaring *ring;
-	int err;
-	int nr_slots;
-
-	ring = kzalloc(sizeof(*ring), GFP_KERNEL);
-	if (!ring)
-		goto out;
-
-	nr_slots = BCM43xx_RXRING_SLOTS;
-	if (for_tx)
-		nr_slots = BCM43xx_TXRING_SLOTS;
-
-	ring->meta = kcalloc(nr_slots, sizeof(struct bcm43xx_dmadesc_meta),
-			     GFP_KERNEL);
-	if (!ring->meta)
-		goto err_kfree_ring;
-
-	ring->routing = BCM43xx_DMA32_CLIENTTRANS;
-	if (dma64)
-		ring->routing = BCM43xx_DMA64_CLIENTTRANS;
-
-	ring->bcm = bcm;
-	ring->nr_slots = nr_slots;
-	ring->suspend_mark = ring->nr_slots * BCM43xx_TXSUSPEND_PERCENT / 100;
-	ring->resume_mark = ring->nr_slots * BCM43xx_TXRESUME_PERCENT / 100;
-	assert(ring->suspend_mark < ring->resume_mark);
-	ring->mmio_base = bcm43xx_dmacontroller_base(dma64, controller_index);
-	ring->index = controller_index;
-	ring->dma64 = !!dma64;
-	if (for_tx) {
-		ring->tx = 1;
-		ring->current_slot = -1;
-	} else {
-		if (ring->index == 0) {
-			ring->rx_buffersize = BCM43xx_DMA0_RX_BUFFERSIZE;
-			ring->frameoffset = BCM43xx_DMA0_RX_FRAMEOFFSET;
-		} else if (ring->index == 3) {
-			ring->rx_buffersize = BCM43xx_DMA3_RX_BUFFERSIZE;
-			ring->frameoffset = BCM43xx_DMA3_RX_FRAMEOFFSET;
-		} else
-			assert(0);
-	}
-
-	err = alloc_ringmemory(ring);
-	if (err)
-		goto err_kfree_meta;
-	err = dmacontroller_setup(ring);
-	if (err)
-		goto err_free_ringmemory;
-	return ring;
-
-out:
-	printk(KERN_ERR PFX "Error in bcm43xx_setup_dmaring\n");
-	return ring;
-
-err_free_ringmemory:
-	free_ringmemory(ring);
-err_kfree_meta:
-	kfree(ring->meta);
-err_kfree_ring:
-	kfree(ring);
-	ring = NULL;
-	goto out;
-}
-
-/* Main cleanup function. */
-static void bcm43xx_destroy_dmaring(struct bcm43xx_dmaring *ring)
-{
-	if (!ring)
-		return;
-
-	dprintk(KERN_INFO PFX "DMA-%s 0x%04X (%s) max used slots: %d/%d\n",
-		(ring->dma64) ? "64" : "32",
-		ring->mmio_base,
-		(ring->tx) ? "TX" : "RX",
-		ring->max_used_slots, ring->nr_slots);
-	/* Device IRQs are disabled prior entering this function,
-	 * so no need to take care of concurrency with rx handler stuff.
-	 */
-	dmacontroller_cleanup(ring);
-	free_all_descbuffers(ring);
-	free_ringmemory(ring);
-
-	kfree(ring->meta);
-	kfree(ring);
-}
-
-void bcm43xx_dma_free(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_dma *dma;
-
-	if (bcm43xx_using_pio(bcm))
-		return;
-	dma = bcm43xx_current_dma(bcm);
-
-	bcm43xx_destroy_dmaring(dma->rx_ring3);
-	dma->rx_ring3 = NULL;
-	bcm43xx_destroy_dmaring(dma->rx_ring0);
-	dma->rx_ring0 = NULL;
-
-	bcm43xx_destroy_dmaring(dma->tx_ring5);
-	dma->tx_ring5 = NULL;
-	bcm43xx_destroy_dmaring(dma->tx_ring4);
-	dma->tx_ring4 = NULL;
-	bcm43xx_destroy_dmaring(dma->tx_ring3);
-	dma->tx_ring3 = NULL;
-	bcm43xx_destroy_dmaring(dma->tx_ring2);
-	dma->tx_ring2 = NULL;
-	bcm43xx_destroy_dmaring(dma->tx_ring1);
-	dma->tx_ring1 = NULL;
-	bcm43xx_destroy_dmaring(dma->tx_ring0);
-	dma->tx_ring0 = NULL;
-}
-
-int bcm43xx_dma_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_dma *dma = bcm43xx_current_dma(bcm);
-	struct bcm43xx_dmaring *ring;
-	int err = -ENOMEM;
-	int dma64 = 0;
-
-	bcm->dma_mask = bcm43xx_get_supported_dma_mask(bcm);
-	if (bcm->dma_mask == DMA_64BIT_MASK)
-		dma64 = 1;
-	err = pci_set_dma_mask(bcm->pci_dev, bcm->dma_mask);
-	if (err)
-		goto no_dma;
-	err = pci_set_consistent_dma_mask(bcm->pci_dev, bcm->dma_mask);
-	if (err)
-		goto no_dma;
-
-	/* setup TX DMA channels. */
-	ring = bcm43xx_setup_dmaring(bcm, 0, 1, dma64);
-	if (!ring)
-		goto out;
-	dma->tx_ring0 = ring;
-
-	ring = bcm43xx_setup_dmaring(bcm, 1, 1, dma64);
-	if (!ring)
-		goto err_destroy_tx0;
-	dma->tx_ring1 = ring;
-
-	ring = bcm43xx_setup_dmaring(bcm, 2, 1, dma64);
-	if (!ring)
-		goto err_destroy_tx1;
-	dma->tx_ring2 = ring;
-
-	ring = bcm43xx_setup_dmaring(bcm, 3, 1, dma64);
-	if (!ring)
-		goto err_destroy_tx2;
-	dma->tx_ring3 = ring;
-
-	ring = bcm43xx_setup_dmaring(bcm, 4, 1, dma64);
-	if (!ring)
-		goto err_destroy_tx3;
-	dma->tx_ring4 = ring;
-
-	ring = bcm43xx_setup_dmaring(bcm, 5, 1, dma64);
-	if (!ring)
-		goto err_destroy_tx4;
-	dma->tx_ring5 = ring;
-
-	/* setup RX DMA channels. */
-	ring = bcm43xx_setup_dmaring(bcm, 0, 0, dma64);
-	if (!ring)
-		goto err_destroy_tx5;
-	dma->rx_ring0 = ring;
-
-	if (bcm->current_core->rev < 5) {
-		ring = bcm43xx_setup_dmaring(bcm, 3, 0, dma64);
-		if (!ring)
-			goto err_destroy_rx0;
-		dma->rx_ring3 = ring;
-	}
-
-	dprintk(KERN_INFO PFX "%d-bit DMA initialized\n",
-		(bcm->dma_mask == DMA_64BIT_MASK) ? 64 :
-		(bcm->dma_mask == DMA_32BIT_MASK) ? 32 : 30);
-	err = 0;
-out:
-	return err;
-
-err_destroy_rx0:
-	bcm43xx_destroy_dmaring(dma->rx_ring0);
-	dma->rx_ring0 = NULL;
-err_destroy_tx5:
-	bcm43xx_destroy_dmaring(dma->tx_ring5);
-	dma->tx_ring5 = NULL;
-err_destroy_tx4:
-	bcm43xx_destroy_dmaring(dma->tx_ring4);
-	dma->tx_ring4 = NULL;
-err_destroy_tx3:
-	bcm43xx_destroy_dmaring(dma->tx_ring3);
-	dma->tx_ring3 = NULL;
-err_destroy_tx2:
-	bcm43xx_destroy_dmaring(dma->tx_ring2);
-	dma->tx_ring2 = NULL;
-err_destroy_tx1:
-	bcm43xx_destroy_dmaring(dma->tx_ring1);
-	dma->tx_ring1 = NULL;
-err_destroy_tx0:
-	bcm43xx_destroy_dmaring(dma->tx_ring0);
-	dma->tx_ring0 = NULL;
-no_dma:
-#ifdef CONFIG_BCM43XX_PIO
-	printk(KERN_WARNING PFX "DMA not supported on this device."
-				" Falling back to PIO.\n");
-	bcm->__using_pio = 1;
-	return -ENOSYS;
-#else
-	printk(KERN_ERR PFX "FATAL: DMA not supported and PIO not configured. "
-			    "Please recompile the driver with PIO support.\n");
-	return -ENODEV;
-#endif /* CONFIG_BCM43XX_PIO */
-}
-
-/* Generate a cookie for the TX header. */
-static u16 generate_cookie(struct bcm43xx_dmaring *ring,
-			   int slot)
-{
-	u16 cookie = 0x1000;
-
-	/* Use the upper 4 bits of the cookie as
-	 * DMA controller ID and store the slot number
-	 * in the lower 12 bits.
-	 * Note that the cookie must never be 0, as this
-	 * is a special value used in RX path.
-	 */
-	switch (ring->index) {
-	case 0:
-		cookie = 0xA000;
-		break;
-	case 1:
-		cookie = 0xB000;
-		break;
-	case 2:
-		cookie = 0xC000;
-		break;
-	case 3:
-		cookie = 0xD000;
-		break;
-	case 4:
-		cookie = 0xE000;
-		break;
-	case 5:
-		cookie = 0xF000;
-		break;
-	}
-	assert(((u16)slot & 0xF000) == 0x0000);
-	cookie |= (u16)slot;
-
-	return cookie;
-}
-
-/* Inspect a cookie and find out to which controller/slot it belongs. */
-static
-struct bcm43xx_dmaring * parse_cookie(struct bcm43xx_private *bcm,
-				      u16 cookie, int *slot)
-{
-	struct bcm43xx_dma *dma = bcm43xx_current_dma(bcm);
-	struct bcm43xx_dmaring *ring = NULL;
-
-	switch (cookie & 0xF000) {
-	case 0xA000:
-		ring = dma->tx_ring0;
-		break;
-	case 0xB000:
-		ring = dma->tx_ring1;
-		break;
-	case 0xC000:
-		ring = dma->tx_ring2;
-		break;
-	case 0xD000:
-		ring = dma->tx_ring3;
-		break;
-	case 0xE000:
-		ring = dma->tx_ring4;
-		break;
-	case 0xF000:
-		ring = dma->tx_ring5;
-		break;
-	default:
-		assert(0);
-	}
-	*slot = (cookie & 0x0FFF);
-	assert(*slot >= 0 && *slot < ring->nr_slots);
-
-	return ring;
-}
-
-static void dmacontroller_poke_tx(struct bcm43xx_dmaring *ring,
-				  int slot)
-{
-	u16 offset;
-	int descsize;
-
-	/* Everything is ready to start. Buffers are DMA mapped and
-	 * associated with slots.
-	 * "slot" is the last slot of the new frame we want to transmit.
-	 * Close your seat belts now, please.
-	 */
-	wmb();
-	slot = next_slot(ring, slot);
-	offset = (ring->dma64) ? BCM43xx_DMA64_TXINDEX : BCM43xx_DMA32_TXINDEX;
-	descsize = (ring->dma64) ? sizeof(struct bcm43xx_dmadesc64)
-		: sizeof(struct bcm43xx_dmadesc32);
-	bcm43xx_dma_write(ring, offset,
-			(u32)(slot * descsize));
-}
-
-static void dma_tx_fragment(struct bcm43xx_dmaring *ring,
-			    struct sk_buff *skb,
-			    u8 cur_frag)
-{
-	int slot;
-	struct bcm43xx_dmadesc_generic *desc;
-	struct bcm43xx_dmadesc_meta *meta;
-	dma_addr_t dmaaddr;
-	struct sk_buff *bounce_skb;
-
-	assert(skb_shinfo(skb)->nr_frags == 0);
-
-	slot = request_slot(ring);
-	desc = bcm43xx_dma_idx2desc(ring, slot, &meta);
-
-	/* Add a device specific TX header. */
-	assert(skb_headroom(skb) >= sizeof(struct bcm43xx_txhdr));
-	/* Reserve enough headroom for the device tx header. */
-	__skb_push(skb, sizeof(struct bcm43xx_txhdr));
-	/* Now calculate and add the tx header.
-	 * The tx header includes the PLCP header.
-	 */
-	bcm43xx_generate_txhdr(ring->bcm,
-			       (struct bcm43xx_txhdr *)skb->data,
-			       skb->data + sizeof(struct bcm43xx_txhdr),
-			       skb->len - sizeof(struct bcm43xx_txhdr),
-			       (cur_frag == 0),
-			       generate_cookie(ring, slot));
-	dmaaddr = map_descbuffer(ring, skb->data, skb->len, 1);
-	if (dma_mapping_error(dmaaddr) || dmaaddr + skb->len > ring->bcm->dma_mask) {
-		/* chip cannot handle DMA to/from > 1GB, use bounce buffer (copied from b44 driver) */
-		if (!dma_mapping_error(dmaaddr))
-			unmap_descbuffer(ring, dmaaddr, skb->len, 1);
-		bounce_skb = __dev_alloc_skb(skb->len, GFP_ATOMIC|GFP_DMA);
-		if (!bounce_skb)
-			return;
-		dmaaddr = map_descbuffer(ring, bounce_skb->data, bounce_skb->len, 1);
-		if (dma_mapping_error(dmaaddr) || dmaaddr + skb->len > ring->bcm->dma_mask) {
-			if (!dma_mapping_error(dmaaddr))
-				unmap_descbuffer(ring, dmaaddr, skb->len, 1);
-			dev_kfree_skb_any(bounce_skb);
-			assert(0);
-			return;
-		}
-		skb_copy_from_linear_data(skb, skb_put(bounce_skb, skb->len),
-					  skb->len);
-		dev_kfree_skb_any(skb);
-		skb = bounce_skb;
-	}
-
-	meta->skb = skb;
-	meta->dmaaddr = dmaaddr;
-
-	fill_descriptor(ring, desc, dmaaddr,
-			skb->len, 1, 1, 1);
-
-	/* Now transfer the whole frame. */
-	dmacontroller_poke_tx(ring, slot);
-}
-
-int bcm43xx_dma_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
-{
-	/* We just received a packet from the kernel network subsystem.
-	 * Add headers and DMA map the memory. Poke
-	 * the device to send the stuff.
-	 * Note that this is called from atomic context.
-	 */
-	struct bcm43xx_dmaring *ring = bcm43xx_current_dma(bcm)->tx_ring1;
-	u8 i;
-	struct sk_buff *skb;
-
-	assert(ring->tx);
-	if (unlikely(free_slots(ring) < txb->nr_frags)) {
-		/* The queue should be stopped,
-		 * if we are low on free slots.
-		 * If this ever triggers, we have to lower the suspend_mark.
-		 */
-		dprintkl(KERN_ERR PFX "Out of DMA descriptor slots!\n");
-		return -ENOMEM;
-	}
-
-	for (i = 0; i < txb->nr_frags; i++) {
-		skb = txb->fragments[i];
-		/* Take skb from ieee80211_txb_free */
-		txb->fragments[i] = NULL;
-		dma_tx_fragment(ring, skb, i);
-	}
-	ieee80211_txb_free(txb);
-
-	return 0;
-}
-
-void bcm43xx_dma_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
-{
-	struct bcm43xx_dmaring *ring;
-	struct bcm43xx_dmadesc_generic *desc;
-	struct bcm43xx_dmadesc_meta *meta;
-	int is_last_fragment;
-	int slot;
-	u32 tmp;
-
-	ring = parse_cookie(bcm, status->cookie, &slot);
-	assert(ring);
-	assert(ring->tx);
-	while (1) {
-		assert(slot >= 0 && slot < ring->nr_slots);
-		desc = bcm43xx_dma_idx2desc(ring, slot, &meta);
-
-		if (ring->dma64) {
-			tmp = le32_to_cpu(desc->dma64.control0);
-			is_last_fragment = !!(tmp & BCM43xx_DMA64_DCTL0_FRAMEEND);
-		} else {
-			tmp = le32_to_cpu(desc->dma32.control);
-			is_last_fragment = !!(tmp & BCM43xx_DMA32_DCTL_FRAMEEND);
-		}
-		unmap_descbuffer(ring, meta->dmaaddr, meta->skb->len, 1);
-		free_descriptor_buffer(ring, meta, 1);
-		/* Everything belonging to the slot is unmapped
-		 * and freed, so we can return it.
-		 */
-		return_slot(ring, slot);
-
-		if (is_last_fragment)
-			break;
-		slot = next_slot(ring, slot);
-	}
-	bcm->stats.last_tx = jiffies;
-}
-
-static void dma_rx(struct bcm43xx_dmaring *ring,
-		   int *slot)
-{
-	struct bcm43xx_dmadesc_generic *desc;
-	struct bcm43xx_dmadesc_meta *meta;
-	struct bcm43xx_rxhdr *rxhdr;
-	struct sk_buff *skb;
-	u16 len;
-	int err;
-	dma_addr_t dmaaddr;
-
-	desc = bcm43xx_dma_idx2desc(ring, *slot, &meta);
-
-	sync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);
-	skb = meta->skb;
-
-	if (ring->index == 3) {
-		/* We received an xmit status. */
-		struct bcm43xx_hwxmitstatus *hw = (struct bcm43xx_hwxmitstatus *)skb->data;
-		struct bcm43xx_xmitstatus stat;
-		int i = 0;
-
-		stat.cookie = le16_to_cpu(hw->cookie);
-		while (stat.cookie == 0) {
-			if (unlikely(++i >= 10000)) {
-				assert(0);
-				break;
-			}
-			udelay(2);
-			barrier();
-			stat.cookie = le16_to_cpu(hw->cookie);
-		}
-		stat.flags = hw->flags;
-		stat.cnt1 = hw->cnt1;
-		stat.cnt2 = hw->cnt2;
-		stat.seq = le16_to_cpu(hw->seq);
-		stat.unknown = le16_to_cpu(hw->unknown);
-
-		bcm43xx_debugfs_log_txstat(ring->bcm, &stat);
-		bcm43xx_dma_handle_xmitstatus(ring->bcm, &stat);
-		/* recycle the descriptor buffer. */
-		sync_descbuffer_for_device(ring, meta->dmaaddr, ring->rx_buffersize);
-
-		return;
-	}
-	rxhdr = (struct bcm43xx_rxhdr *)skb->data;
-	len = le16_to_cpu(rxhdr->frame_length);
-	if (len == 0) {
-		int i = 0;
-
-		do {
-			udelay(2);
-			barrier();
-			len = le16_to_cpu(rxhdr->frame_length);
-		} while (len == 0 && i++ < 5);
-		if (unlikely(len == 0)) {
-			/* recycle the descriptor buffer. */
-			sync_descbuffer_for_device(ring, meta->dmaaddr,
-						   ring->rx_buffersize);
-			goto drop;
-		}
-	}
-	if (unlikely(len > ring->rx_buffersize)) {
-		/* The data did not fit into one descriptor buffer
-		 * and is split over multiple buffers.
-		 * This should never happen, as we try to allocate buffers
-		 * big enough. So simply ignore this packet.
-		 */
-		int cnt = 0;
-		s32 tmp = len;
-
-		while (1) {
-			desc = bcm43xx_dma_idx2desc(ring, *slot, &meta);
-			/* recycle the descriptor buffer. */
-			sync_descbuffer_for_device(ring, meta->dmaaddr,
-						   ring->rx_buffersize);
-			*slot = next_slot(ring, *slot);
-			cnt++;
-			tmp -= ring->rx_buffersize;
-			if (tmp <= 0)
-				break;
-		}
-		printkl(KERN_ERR PFX "DMA RX buffer too small "
-			"(len: %u, buffer: %u, nr-dropped: %d)\n",
-			len, ring->rx_buffersize, cnt);
-		goto drop;
-	}
-	len -= IEEE80211_FCS_LEN;
-
-	dmaaddr = meta->dmaaddr;
-	err = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);
-	if (unlikely(err)) {
-		dprintkl(KERN_ERR PFX "DMA RX: setup_rx_descbuffer() failed\n");
-		sync_descbuffer_for_device(ring, dmaaddr,
-					   ring->rx_buffersize);
-		goto drop;
-	}
-
-	unmap_descbuffer(ring, dmaaddr, ring->rx_buffersize, 0);
-	skb_put(skb, len + ring->frameoffset);
-	skb_pull(skb, ring->frameoffset);
-
-	err = bcm43xx_rx(ring->bcm, skb, rxhdr);
-	if (err) {
-		dev_kfree_skb_irq(skb);
-		goto drop;
-	}
-
-drop:
-	return;
-}
-
-void bcm43xx_dma_rx(struct bcm43xx_dmaring *ring)
-{
-	u32 status;
-	u16 descptr;
-	int slot, current_slot;
-#ifdef CONFIG_BCM43XX_DEBUG
-	int used_slots = 0;
-#endif
-
-	assert(!ring->tx);
-	if (ring->dma64) {
-		status = bcm43xx_dma_read(ring, BCM43xx_DMA64_RXSTATUS);
-		descptr = (status & BCM43xx_DMA64_RXSTATDPTR);
-		current_slot = descptr / sizeof(struct bcm43xx_dmadesc64);
-	} else {
-		status = bcm43xx_dma_read(ring, BCM43xx_DMA32_RXSTATUS);
-		descptr = (status & BCM43xx_DMA32_RXDPTR);
-		current_slot = descptr / sizeof(struct bcm43xx_dmadesc32);
-	}
-	assert(current_slot >= 0 && current_slot < ring->nr_slots);
-
-	slot = ring->current_slot;
-	for ( ; slot != current_slot; slot = next_slot(ring, slot)) {
-		dma_rx(ring, &slot);
-#ifdef CONFIG_BCM43XX_DEBUG
-		if (++used_slots > ring->max_used_slots)
-			ring->max_used_slots = used_slots;
-#endif
-	}
-	if (ring->dma64) {
-		bcm43xx_dma_write(ring, BCM43xx_DMA64_RXINDEX,
-				(u32)(slot * sizeof(struct bcm43xx_dmadesc64)));
-	} else {
-		bcm43xx_dma_write(ring, BCM43xx_DMA32_RXINDEX,
-				(u32)(slot * sizeof(struct bcm43xx_dmadesc32)));
-	}
-	ring->current_slot = slot;
-}
-
-void bcm43xx_dma_tx_suspend(struct bcm43xx_dmaring *ring)
-{
-	assert(ring->tx);
-	bcm43xx_power_saving_ctl_bits(ring->bcm, -1, 1);
-	if (ring->dma64) {
-		bcm43xx_dma_write(ring, BCM43xx_DMA64_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA64_TXCTL)
-				| BCM43xx_DMA64_TXSUSPEND);
-	} else {
-		bcm43xx_dma_write(ring, BCM43xx_DMA32_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA32_TXCTL)
-				| BCM43xx_DMA32_TXSUSPEND);
-	}
-}
-
-void bcm43xx_dma_tx_resume(struct bcm43xx_dmaring *ring)
-{
-	assert(ring->tx);
-	if (ring->dma64) {
-		bcm43xx_dma_write(ring, BCM43xx_DMA64_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA64_TXCTL)
-				& ~BCM43xx_DMA64_TXSUSPEND);
-	} else {
-		bcm43xx_dma_write(ring, BCM43xx_DMA32_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA32_TXCTL)
-				& ~BCM43xx_DMA32_TXSUSPEND);
-	}
-	bcm43xx_power_saving_ctl_bits(ring->bcm, -1, -1);
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_dma.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_dma.h
+++ /dev/null
@@ -1,386 +0,0 @@
-#ifndef BCM43xx_DMA_H_
-#define BCM43xx_DMA_H_
-
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/workqueue.h>
-#include <linux/dma-mapping.h>
-#include <linux/linkage.h>
-#include <asm/atomic.h>
-
-
-/* DMA-Interrupt reasons. */
-#define BCM43xx_DMAIRQ_FATALMASK	((1 << 10) | (1 << 11) | (1 << 12) \
-					 | (1 << 14) | (1 << 15))
-#define BCM43xx_DMAIRQ_NONFATALMASK	(1 << 13)
-#define BCM43xx_DMAIRQ_RX_DONE		(1 << 16)
-
-
-/*** 32-bit DMA Engine. ***/
-
-/* 32-bit DMA controller registers. */
-#define BCM43xx_DMA32_TXCTL				0x00
-#define		BCM43xx_DMA32_TXENABLE			0x00000001
-#define		BCM43xx_DMA32_TXSUSPEND			0x00000002
-#define		BCM43xx_DMA32_TXLOOPBACK		0x00000004
-#define		BCM43xx_DMA32_TXFLUSH			0x00000010
-#define		BCM43xx_DMA32_TXADDREXT_MASK		0x00030000
-#define		BCM43xx_DMA32_TXADDREXT_SHIFT		16
-#define BCM43xx_DMA32_TXRING				0x04
-#define BCM43xx_DMA32_TXINDEX				0x08
-#define BCM43xx_DMA32_TXSTATUS				0x0C
-#define		BCM43xx_DMA32_TXDPTR			0x00000FFF
-#define		BCM43xx_DMA32_TXSTATE			0x0000F000
-#define			BCM43xx_DMA32_TXSTAT_DISABLED	0x00000000
-#define			BCM43xx_DMA32_TXSTAT_ACTIVE	0x00001000
-#define			BCM43xx_DMA32_TXSTAT_IDLEWAIT	0x00002000
-#define			BCM43xx_DMA32_TXSTAT_STOPPED	0x00003000
-#define			BCM43xx_DMA32_TXSTAT_SUSP	0x00004000
-#define		BCM43xx_DMA32_TXERROR			0x000F0000
-#define			BCM43xx_DMA32_TXERR_NOERR	0x00000000
-#define			BCM43xx_DMA32_TXERR_PROT	0x00010000
-#define			BCM43xx_DMA32_TXERR_UNDERRUN	0x00020000
-#define			BCM43xx_DMA32_TXERR_BUFREAD	0x00030000
-#define			BCM43xx_DMA32_TXERR_DESCREAD	0x00040000
-#define		BCM43xx_DMA32_TXACTIVE			0xFFF00000
-#define BCM43xx_DMA32_RXCTL				0x10
-#define		BCM43xx_DMA32_RXENABLE			0x00000001
-#define		BCM43xx_DMA32_RXFROFF_MASK		0x000000FE
-#define		BCM43xx_DMA32_RXFROFF_SHIFT		1
-#define		BCM43xx_DMA32_RXDIRECTFIFO		0x00000100
-#define		BCM43xx_DMA32_RXADDREXT_MASK		0x00030000
-#define		BCM43xx_DMA32_RXADDREXT_SHIFT		16
-#define BCM43xx_DMA32_RXRING				0x14
-#define BCM43xx_DMA32_RXINDEX				0x18
-#define BCM43xx_DMA32_RXSTATUS				0x1C
-#define		BCM43xx_DMA32_RXDPTR			0x00000FFF
-#define		BCM43xx_DMA32_RXSTATE			0x0000F000
-#define			BCM43xx_DMA32_RXSTAT_DISABLED	0x00000000
-#define			BCM43xx_DMA32_RXSTAT_ACTIVE	0x00001000
-#define			BCM43xx_DMA32_RXSTAT_IDLEWAIT	0x00002000
-#define			BCM43xx_DMA32_RXSTAT_STOPPED	0x00003000
-#define		BCM43xx_DMA32_RXERROR			0x000F0000
-#define			BCM43xx_DMA32_RXERR_NOERR	0x00000000
-#define			BCM43xx_DMA32_RXERR_PROT	0x00010000
-#define			BCM43xx_DMA32_RXERR_OVERFLOW	0x00020000
-#define			BCM43xx_DMA32_RXERR_BUFWRITE	0x00030000
-#define			BCM43xx_DMA32_RXERR_DESCREAD	0x00040000
-#define		BCM43xx_DMA32_RXACTIVE			0xFFF00000
-
-/* 32-bit DMA descriptor. */
-struct bcm43xx_dmadesc32 {
-	__le32 control;
-	__le32 address;
-} __attribute__((__packed__));
-#define BCM43xx_DMA32_DCTL_BYTECNT		0x00001FFF
-#define BCM43xx_DMA32_DCTL_ADDREXT_MASK		0x00030000
-#define BCM43xx_DMA32_DCTL_ADDREXT_SHIFT	16
-#define BCM43xx_DMA32_DCTL_DTABLEEND		0x10000000
-#define BCM43xx_DMA32_DCTL_IRQ			0x20000000
-#define BCM43xx_DMA32_DCTL_FRAMEEND		0x40000000
-#define BCM43xx_DMA32_DCTL_FRAMESTART		0x80000000
-
-/* Address field Routing value. */
-#define BCM43xx_DMA32_ROUTING			0xC0000000
-#define BCM43xx_DMA32_ROUTING_SHIFT		30
-#define		BCM43xx_DMA32_NOTRANS		0x00000000
-#define		BCM43xx_DMA32_CLIENTTRANS	0x40000000
-
-
-
-/*** 64-bit DMA Engine. ***/
-
-/* 64-bit DMA controller registers. */
-#define BCM43xx_DMA64_TXCTL				0x00
-#define		BCM43xx_DMA64_TXENABLE			0x00000001
-#define		BCM43xx_DMA64_TXSUSPEND			0x00000002
-#define		BCM43xx_DMA64_TXLOOPBACK		0x00000004
-#define		BCM43xx_DMA64_TXFLUSH			0x00000010
-#define		BCM43xx_DMA64_TXADDREXT_MASK		0x00030000
-#define		BCM43xx_DMA64_TXADDREXT_SHIFT		16
-#define BCM43xx_DMA64_TXINDEX				0x04
-#define BCM43xx_DMA64_TXRINGLO				0x08
-#define BCM43xx_DMA64_TXRINGHI				0x0C
-#define BCM43xx_DMA64_TXSTATUS				0x10
-#define		BCM43xx_DMA64_TXSTATDPTR		0x00001FFF
-#define		BCM43xx_DMA64_TXSTAT			0xF0000000
-#define			BCM43xx_DMA64_TXSTAT_DISABLED	0x00000000
-#define			BCM43xx_DMA64_TXSTAT_ACTIVE	0x10000000
-#define			BCM43xx_DMA64_TXSTAT_IDLEWAIT	0x20000000
-#define			BCM43xx_DMA64_TXSTAT_STOPPED	0x30000000
-#define			BCM43xx_DMA64_TXSTAT_SUSP	0x40000000
-#define BCM43xx_DMA64_TXERROR				0x14
-#define		BCM43xx_DMA64_TXERRDPTR			0x0001FFFF
-#define		BCM43xx_DMA64_TXERR			0xF0000000
-#define			BCM43xx_DMA64_TXERR_NOERR	0x00000000
-#define			BCM43xx_DMA64_TXERR_PROT	0x10000000
-#define			BCM43xx_DMA64_TXERR_UNDERRUN	0x20000000
-#define			BCM43xx_DMA64_TXERR_TRANSFER	0x30000000
-#define			BCM43xx_DMA64_TXERR_DESCREAD	0x40000000
-#define			BCM43xx_DMA64_TXERR_CORE	0x50000000
-#define BCM43xx_DMA64_RXCTL				0x20
-#define		BCM43xx_DMA64_RXENABLE			0x00000001
-#define		BCM43xx_DMA64_RXFROFF_MASK		0x000000FE
-#define		BCM43xx_DMA64_RXFROFF_SHIFT		1
-#define		BCM43xx_DMA64_RXDIRECTFIFO		0x00000100
-#define		BCM43xx_DMA64_RXADDREXT_MASK		0x00030000
-#define		BCM43xx_DMA64_RXADDREXT_SHIFT		16
-#define BCM43xx_DMA64_RXINDEX				0x24
-#define BCM43xx_DMA64_RXRINGLO				0x28
-#define BCM43xx_DMA64_RXRINGHI				0x2C
-#define BCM43xx_DMA64_RXSTATUS				0x30
-#define		BCM43xx_DMA64_RXSTATDPTR		0x00001FFF
-#define		BCM43xx_DMA64_RXSTAT			0xF0000000
-#define			BCM43xx_DMA64_RXSTAT_DISABLED	0x00000000
-#define			BCM43xx_DMA64_RXSTAT_ACTIVE	0x10000000
-#define			BCM43xx_DMA64_RXSTAT_IDLEWAIT	0x20000000
-#define			BCM43xx_DMA64_RXSTAT_STOPPED	0x30000000
-#define			BCM43xx_DMA64_RXSTAT_SUSP	0x40000000
-#define BCM43xx_DMA64_RXERROR				0x34
-#define		BCM43xx_DMA64_RXERRDPTR			0x0001FFFF
-#define		BCM43xx_DMA64_RXERR			0xF0000000
-#define			BCM43xx_DMA64_RXERR_NOERR	0x00000000
-#define			BCM43xx_DMA64_RXERR_PROT	0x10000000
-#define			BCM43xx_DMA64_RXERR_UNDERRUN	0x20000000
-#define			BCM43xx_DMA64_RXERR_TRANSFER	0x30000000
-#define			BCM43xx_DMA64_RXERR_DESCREAD	0x40000000
-#define			BCM43xx_DMA64_RXERR_CORE	0x50000000
-
-/* 64-bit DMA descriptor. */
-struct bcm43xx_dmadesc64 {
-	__le32 control0;
-	__le32 control1;
-	__le32 address_low;
-	__le32 address_high;
-} __attribute__((__packed__));
-#define BCM43xx_DMA64_DCTL0_DTABLEEND		0x10000000
-#define BCM43xx_DMA64_DCTL0_IRQ			0x20000000
-#define BCM43xx_DMA64_DCTL0_FRAMEEND		0x40000000
-#define BCM43xx_DMA64_DCTL0_FRAMESTART		0x80000000
-#define BCM43xx_DMA64_DCTL1_BYTECNT		0x00001FFF
-#define BCM43xx_DMA64_DCTL1_ADDREXT_MASK	0x00030000
-#define BCM43xx_DMA64_DCTL1_ADDREXT_SHIFT	16
-
-/* Address field Routing value. */
-#define BCM43xx_DMA64_ROUTING			0xC0000000
-#define BCM43xx_DMA64_ROUTING_SHIFT		30
-#define		BCM43xx_DMA64_NOTRANS		0x00000000
-#define		BCM43xx_DMA64_CLIENTTRANS	0x80000000
-
-
-
-struct bcm43xx_dmadesc_generic {
-	union {
-		struct bcm43xx_dmadesc32 dma32;
-		struct bcm43xx_dmadesc64 dma64;
-	} __attribute__((__packed__));
-} __attribute__((__packed__));
-
-
-/* Misc DMA constants */
-#define BCM43xx_DMA_RINGMEMSIZE		PAGE_SIZE
-#define BCM43xx_DMA0_RX_FRAMEOFFSET	30
-#define BCM43xx_DMA3_RX_FRAMEOFFSET	0
-
-
-/* DMA engine tuning knobs */
-#define BCM43xx_TXRING_SLOTS		512
-#define BCM43xx_RXRING_SLOTS		64
-#define BCM43xx_DMA0_RX_BUFFERSIZE	(2304 + 100)
-#define BCM43xx_DMA3_RX_BUFFERSIZE	16
-/* Suspend the tx queue, if less than this percent slots are free. */
-#define BCM43xx_TXSUSPEND_PERCENT	20
-/* Resume the tx queue, if more than this percent slots are free. */
-#define BCM43xx_TXRESUME_PERCENT	50
-
-
-
-#ifdef CONFIG_BCM43XX_DMA
-
-
-struct sk_buff;
-struct bcm43xx_private;
-struct bcm43xx_xmitstatus;
-
-
-struct bcm43xx_dmadesc_meta {
-	/* The kernel DMA-able buffer. */
-	struct sk_buff *skb;
-	/* DMA base bus-address of the descriptor buffer. */
-	dma_addr_t dmaaddr;
-};
-
-struct bcm43xx_dmaring {
-	/* Kernel virtual base address of the ring memory. */
-	void *descbase;
-	/* Meta data about all descriptors. */
-	struct bcm43xx_dmadesc_meta *meta;
-	/* DMA Routing value. */
-	u32 routing;
-	/* (Unadjusted) DMA base bus-address of the ring memory. */
-	dma_addr_t dmabase;
-	/* Number of descriptor slots in the ring. */
-	int nr_slots;
-	/* Number of used descriptor slots. */
-	int used_slots;
-	/* Currently used slot in the ring. */
-	int current_slot;
-	/* Marks to suspend/resume the queue. */
-	int suspend_mark;
-	int resume_mark;
-	/* Frameoffset in octets. */
-	u32 frameoffset;
-	/* Descriptor buffer size. */
-	u16 rx_buffersize;
-	/* The MMIO base register of the DMA controller. */
-	u16 mmio_base;
-	/* DMA controller index number (0-5). */
-	int index;
-	/* Boolean. Is this a TX ring? */
-	u8 tx;
-	/* Boolean. 64bit DMA if true, 32bit DMA otherwise. */
-	u8 dma64;
-	/* Boolean. Are transfers suspended on this ring? */
-	u8 suspended;
-	struct bcm43xx_private *bcm;
-#ifdef CONFIG_BCM43XX_DEBUG
-	/* Maximum number of used slots. */
-	int max_used_slots;
-#endif /* CONFIG_BCM43XX_DEBUG*/
-};
-
-
-static inline
-int bcm43xx_dma_desc2idx(struct bcm43xx_dmaring *ring,
-			 struct bcm43xx_dmadesc_generic *desc)
-{
-	if (ring->dma64) {
-		struct bcm43xx_dmadesc64 *dd64 = ring->descbase;
-		return (int)(&(desc->dma64) - dd64);
-	} else {
-		struct bcm43xx_dmadesc32 *dd32 = ring->descbase;
-		return (int)(&(desc->dma32) - dd32);
-	}
-}
-
-static inline
-struct bcm43xx_dmadesc_generic * bcm43xx_dma_idx2desc(struct bcm43xx_dmaring *ring,
-						      int slot,
-						      struct bcm43xx_dmadesc_meta **meta)
-{
-	*meta = &(ring->meta[slot]);
-	if (ring->dma64) {
-		struct bcm43xx_dmadesc64 *dd64 = ring->descbase;
-		return (struct bcm43xx_dmadesc_generic *)(&(dd64[slot]));
-	} else {
-		struct bcm43xx_dmadesc32 *dd32 = ring->descbase;
-		return (struct bcm43xx_dmadesc_generic *)(&(dd32[slot]));
-	}
-}
-
-static inline
-u32 bcm43xx_dma_read(struct bcm43xx_dmaring *ring,
-		     u16 offset)
-{
-	return bcm43xx_read32(ring->bcm, ring->mmio_base + offset);
-}
-
-static inline
-void bcm43xx_dma_write(struct bcm43xx_dmaring *ring,
-		       u16 offset, u32 value)
-{
-	bcm43xx_write32(ring->bcm, ring->mmio_base + offset, value);
-}
-
-
-int bcm43xx_dma_init(struct bcm43xx_private *bcm);
-void bcm43xx_dma_free(struct bcm43xx_private *bcm);
-
-int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_private *bcm,
-				   u16 dmacontroller_mmio_base,
-				   int dma64);
-int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_private *bcm,
-				   u16 dmacontroller_mmio_base,
-				   int dma64);
-
-u16 bcm43xx_dmacontroller_base(int dma64bit, int dmacontroller_idx);
-
-void bcm43xx_dma_tx_suspend(struct bcm43xx_dmaring *ring);
-void bcm43xx_dma_tx_resume(struct bcm43xx_dmaring *ring);
-
-void bcm43xx_dma_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status);
-
-int bcm43xx_dma_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb);
-void bcm43xx_dma_rx(struct bcm43xx_dmaring *ring);
-
-/* Helper function that returns the dma mask for this device. */
-static inline
-u64 bcm43xx_get_supported_dma_mask(struct bcm43xx_private *bcm)
-{
-	int dma64 = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH) &
-				   BCM43xx_SBTMSTATEHIGH_DMA64BIT;
-	u16 mmio_base = bcm43xx_dmacontroller_base(dma64, 0);
-	u32 mask = BCM43xx_DMA32_TXADDREXT_MASK;
-
-	if (dma64)
-		return DMA_64BIT_MASK;
-	bcm43xx_write32(bcm, mmio_base + BCM43xx_DMA32_TXCTL, mask);
-	if (bcm43xx_read32(bcm, mmio_base + BCM43xx_DMA32_TXCTL) & mask)
-		return DMA_32BIT_MASK;
-	return DMA_30BIT_MASK;
-}
-
-#else /* CONFIG_BCM43XX_DMA */
-
-
-static inline
-int bcm43xx_dma_init(struct bcm43xx_private *bcm)
-{
-	return 0;
-}
-static inline
-void bcm43xx_dma_free(struct bcm43xx_private *bcm)
-{
-}
-static inline
-int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_private *bcm,
-				   u16 dmacontroller_mmio_base,
-				   int dma64)
-{
-	return 0;
-}
-static inline
-int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_private *bcm,
-				   u16 dmacontroller_mmio_base,
-				   int dma64)
-{
-	return 0;
-}
-static inline
-int bcm43xx_dma_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
-{
-	return 0;
-}
-static inline
-void bcm43xx_dma_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
-{
-}
-static inline
-void bcm43xx_dma_rx(struct bcm43xx_dmaring *ring)
-{
-}
-static inline
-void bcm43xx_dma_tx_suspend(struct bcm43xx_dmaring *ring)
-{
-}
-static inline
-void bcm43xx_dma_tx_resume(struct bcm43xx_dmaring *ring)
-{
-}
-
-#endif /* CONFIG_BCM43XX_DMA */
-#endif /* BCM43xx_DMA_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ethtool.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_ethtool.c
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  ethtool support
-
-  Copyright (c) 2006 Jason Lunz <lunz at falooley.org>
-
-  Some code in this file is derived from the 8139too.c driver
-  Copyright (C) 2002 Jeff Garzik
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include "bcm43xx.h"
-#include "bcm43xx_ethtool.h"
-
-#include <linux/netdevice.h>
-#include <linux/pci.h>
-#include <linux/string.h>
-#include <linux/utsname.h>
-
-
-static void bcm43xx_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(dev);
-
-	strncpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));
-	strncpy(info->version, utsname()->release, sizeof(info->version));
-	strncpy(info->bus_info, pci_name(bcm->pci_dev), ETHTOOL_BUSINFO_LEN);
-}
-
-const struct ethtool_ops bcm43xx_ethtool_ops = {
-	.get_drvinfo = bcm43xx_get_drvinfo,
-	.get_link = ethtool_op_get_link,
-};
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ethtool.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_ethtool.h
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef BCM43xx_ETHTOOL_H_
-#define BCM43xx_ETHTOOL_H_
-
-#include <linux/ethtool.h>
-
-extern const struct ethtool_ops bcm43xx_ethtool_ops;
-
-#endif /* BCM43xx_ETHTOOL_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ilt.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_ilt.c
+++ /dev/null
@@ -1,352 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include "bcm43xx.h"
-#include "bcm43xx_ilt.h"
-#include "bcm43xx_phy.h"
-
-
-/**** Initial Internal Lookup Tables ****/
-
-const u32 bcm43xx_ilt_rotor[BCM43xx_ILT_ROTOR_SIZE] = {
-	0xFEB93FFD, 0xFEC63FFD, /* 0 */
-	0xFED23FFD, 0xFEDF3FFD,
-	0xFEEC3FFE, 0xFEF83FFE,
-	0xFF053FFE, 0xFF113FFE,
-	0xFF1E3FFE, 0xFF2A3FFF, /* 8 */
-	0xFF373FFF, 0xFF443FFF,
-	0xFF503FFF, 0xFF5D3FFF,
-	0xFF693FFF, 0xFF763FFF,
-	0xFF824000, 0xFF8F4000, /* 16 */
-	0xFF9B4000, 0xFFA84000,
-	0xFFB54000, 0xFFC14000,
-	0xFFCE4000, 0xFFDA4000,
-	0xFFE74000, 0xFFF34000, /* 24 */
-	0x00004000, 0x000D4000,
-	0x00194000, 0x00264000,
-	0x00324000, 0x003F4000,
-	0x004B4000, 0x00584000, /* 32 */
-	0x00654000, 0x00714000,
-	0x007E4000, 0x008A3FFF,
-	0x00973FFF, 0x00A33FFF,
-	0x00B03FFF, 0x00BC3FFF, /* 40 */
-	0x00C93FFF, 0x00D63FFF,
-	0x00E23FFE, 0x00EF3FFE,
-	0x00FB3FFE, 0x01083FFE,
-	0x01143FFE, 0x01213FFD, /* 48 */
-	0x012E3FFD, 0x013A3FFD,
-	0x01473FFD,
-};
-
-const u32 bcm43xx_ilt_retard[BCM43xx_ILT_RETARD_SIZE] = {
-	0xDB93CB87, 0xD666CF64, /* 0 */
-	0xD1FDD358, 0xCDA6D826,
-	0xCA38DD9F, 0xC729E2B4,
-	0xC469E88E, 0xC26AEE2B,
-	0xC0DEF46C, 0xC073FA62, /* 8 */
-	0xC01D00D5, 0xC0760743,
-	0xC1560D1E, 0xC2E51369,
-	0xC4ED18FF, 0xC7AC1ED7,
-	0xCB2823B2, 0xCEFA28D9, /* 16 */
-	0xD2F62D3F, 0xD7BB3197,
-	0xDCE53568, 0xE1FE3875,
-	0xE7D13B35, 0xED663D35,
-	0xF39B3EC4, 0xF98E3FA7, /* 24 */
-	0x00004000, 0x06723FA7,
-	0x0C653EC4, 0x129A3D35,
-	0x182F3B35, 0x1E023875,
-	0x231B3568, 0x28453197, /* 32 */
-	0x2D0A2D3F, 0x310628D9,
-	0x34D823B2, 0x38541ED7,
-	0x3B1318FF, 0x3D1B1369,
-	0x3EAA0D1E, 0x3F8A0743, /* 40 */
-	0x3FE300D5, 0x3F8DFA62,
-	0x3F22F46C, 0x3D96EE2B,
-	0x3B97E88E, 0x38D7E2B4,
-	0x35C8DD9F, 0x325AD826, /* 48 */
-	0x2E03D358, 0x299ACF64,
-	0x246DCB87,
-};
-
-const u16 bcm43xx_ilt_finefreqa[BCM43xx_ILT_FINEFREQA_SIZE] = {
-	0x0082, 0x0082, 0x0102, 0x0182, /* 0 */
- 	0x0202, 0x0282, 0x0302, 0x0382,
- 	0x0402, 0x0482, 0x0502, 0x0582,
- 	0x05E2, 0x0662, 0x06E2, 0x0762,
- 	0x07E2, 0x0842, 0x08C2, 0x0942, /* 16 */
- 	0x09C2, 0x0A22, 0x0AA2, 0x0B02,
- 	0x0B82, 0x0BE2, 0x0C62, 0x0CC2,
- 	0x0D42, 0x0DA2, 0x0E02, 0x0E62,
- 	0x0EE2, 0x0F42, 0x0FA2, 0x1002, /* 32 */
- 	0x1062, 0x10C2, 0x1122, 0x1182,
- 	0x11E2, 0x1242, 0x12A2, 0x12E2,
- 	0x1342, 0x13A2, 0x1402, 0x1442,
- 	0x14A2, 0x14E2, 0x1542, 0x1582, /* 48 */
- 	0x15E2, 0x1622, 0x1662, 0x16C1,
- 	0x1701, 0x1741, 0x1781, 0x17E1,
- 	0x1821, 0x1861, 0x18A1, 0x18E1,
- 	0x1921, 0x1961, 0x19A1, 0x19E1, /* 64 */
- 	0x1A21, 0x1A61, 0x1AA1, 0x1AC1,
- 	0x1B01, 0x1B41, 0x1B81, 0x1BA1,
- 	0x1BE1, 0x1C21, 0x1C41, 0x1C81,
- 	0x1CA1, 0x1CE1, 0x1D01, 0x1D41, /* 80 */
- 	0x1D61, 0x1DA1, 0x1DC1, 0x1E01,
- 	0x1E21, 0x1E61, 0x1E81, 0x1EA1,
- 	0x1EE1, 0x1F01, 0x1F21, 0x1F41,
- 	0x1F81, 0x1FA1, 0x1FC1, 0x1FE1, /* 96 */
- 	0x2001, 0x2041, 0x2061, 0x2081,
- 	0x20A1, 0x20C1, 0x20E1, 0x2101,
- 	0x2121, 0x2141, 0x2161, 0x2181,
- 	0x21A1, 0x21C1, 0x21E1, 0x2201, /* 112 */
- 	0x2221, 0x2241, 0x2261, 0x2281,
- 	0x22A1, 0x22C1, 0x22C1, 0x22E1,
- 	0x2301, 0x2321, 0x2341, 0x2361,
- 	0x2361, 0x2381, 0x23A1, 0x23C1, /* 128 */
- 	0x23E1, 0x23E1, 0x2401, 0x2421,
- 	0x2441, 0x2441, 0x2461, 0x2481,
- 	0x2481, 0x24A1, 0x24C1, 0x24C1,
- 	0x24E1, 0x2501, 0x2501, 0x2521, /* 144 */
- 	0x2541, 0x2541, 0x2561, 0x2561,
- 	0x2581, 0x25A1, 0x25A1, 0x25C1,
- 	0x25C1, 0x25E1, 0x2601, 0x2601,
- 	0x2621, 0x2621, 0x2641, 0x2641, /* 160 */
- 	0x2661, 0x2661, 0x2681, 0x2681,
- 	0x26A1, 0x26A1, 0x26C1, 0x26C1,
- 	0x26E1, 0x26E1, 0x2701, 0x2701,
- 	0x2721, 0x2721, 0x2740, 0x2740, /* 176 */
- 	0x2760, 0x2760, 0x2780, 0x2780,
- 	0x2780, 0x27A0, 0x27A0, 0x27C0,
- 	0x27C0, 0x27E0, 0x27E0, 0x27E0,
- 	0x2800, 0x2800, 0x2820, 0x2820, /* 192 */
- 	0x2820, 0x2840, 0x2840, 0x2840,
- 	0x2860, 0x2860, 0x2880, 0x2880,
- 	0x2880, 0x28A0, 0x28A0, 0x28A0,
- 	0x28C0, 0x28C0, 0x28C0, 0x28E0, /* 208 */
- 	0x28E0, 0x28E0, 0x2900, 0x2900,
- 	0x2900, 0x2920, 0x2920, 0x2920,
- 	0x2940, 0x2940, 0x2940, 0x2960,
- 	0x2960, 0x2960, 0x2960, 0x2980, /* 224 */
- 	0x2980, 0x2980, 0x29A0, 0x29A0,
- 	0x29A0, 0x29A0, 0x29C0, 0x29C0,
- 	0x29C0, 0x29E0, 0x29E0, 0x29E0,
- 	0x29E0, 0x2A00, 0x2A00, 0x2A00, /* 240 */
- 	0x2A00, 0x2A20, 0x2A20, 0x2A20,
- 	0x2A20, 0x2A40, 0x2A40, 0x2A40,
- 	0x2A40, 0x2A60, 0x2A60, 0x2A60,
-};
-
-const u16 bcm43xx_ilt_finefreqg[BCM43xx_ILT_FINEFREQG_SIZE] = {
-	0x0089, 0x02E9, 0x0409, 0x04E9, /* 0 */
-	0x05A9, 0x0669, 0x0709, 0x0789,
-	0x0829, 0x08A9, 0x0929, 0x0989,
-	0x0A09, 0x0A69, 0x0AC9, 0x0B29,
-	0x0BA9, 0x0BE9, 0x0C49, 0x0CA9, /* 16 */
-	0x0D09, 0x0D69, 0x0DA9, 0x0E09,
-	0x0E69, 0x0EA9, 0x0F09, 0x0F49,
-	0x0FA9, 0x0FE9, 0x1029, 0x1089,
-	0x10C9, 0x1109, 0x1169, 0x11A9, /* 32 */
-	0x11E9, 0x1229, 0x1289, 0x12C9,
-	0x1309, 0x1349, 0x1389, 0x13C9,
-	0x1409, 0x1449, 0x14A9, 0x14E9,
-	0x1529, 0x1569, 0x15A9, 0x15E9, /* 48 */
-	0x1629, 0x1669, 0x16A9, 0x16E8,
-	0x1728, 0x1768, 0x17A8, 0x17E8,
-	0x1828, 0x1868, 0x18A8, 0x18E8,
-	0x1928, 0x1968, 0x19A8, 0x19E8, /* 64 */
-	0x1A28, 0x1A68, 0x1AA8, 0x1AE8,
-	0x1B28, 0x1B68, 0x1BA8, 0x1BE8,
-	0x1C28, 0x1C68, 0x1CA8, 0x1CE8,
-	0x1D28, 0x1D68, 0x1DC8, 0x1E08, /* 80 */
-	0x1E48, 0x1E88, 0x1EC8, 0x1F08,
-	0x1F48, 0x1F88, 0x1FE8, 0x2028,
-	0x2068, 0x20A8, 0x2108, 0x2148,
-	0x2188, 0x21C8, 0x2228, 0x2268, /* 96 */
-	0x22C8, 0x2308, 0x2348, 0x23A8,
-	0x23E8, 0x2448, 0x24A8, 0x24E8,
-	0x2548, 0x25A8, 0x2608, 0x2668,
-	0x26C8, 0x2728, 0x2787, 0x27E7, /* 112 */
-	0x2847, 0x28C7, 0x2947, 0x29A7,
-	0x2A27, 0x2AC7, 0x2B47, 0x2BE7,
-	0x2CA7, 0x2D67, 0x2E47, 0x2F67,
-	0x3247, 0x3526, 0x3646, 0x3726, /* 128 */
-	0x3806, 0x38A6, 0x3946, 0x39E6,
-	0x3A66, 0x3AE6, 0x3B66, 0x3BC6,
-	0x3C45, 0x3CA5, 0x3D05, 0x3D85,
-	0x3DE5, 0x3E45, 0x3EA5, 0x3EE5, /* 144 */
-	0x3F45, 0x3FA5, 0x4005, 0x4045,
-	0x40A5, 0x40E5, 0x4145, 0x4185,
-	0x41E5, 0x4225, 0x4265, 0x42C5,
-	0x4305, 0x4345, 0x43A5, 0x43E5, /* 160 */
-	0x4424, 0x4464, 0x44C4, 0x4504,
-	0x4544, 0x4584, 0x45C4, 0x4604,
-	0x4644, 0x46A4, 0x46E4, 0x4724,
-	0x4764, 0x47A4, 0x47E4, 0x4824, /* 176 */
-	0x4864, 0x48A4, 0x48E4, 0x4924,
-	0x4964, 0x49A4, 0x49E4, 0x4A24,
-	0x4A64, 0x4AA4, 0x4AE4, 0x4B23,
-	0x4B63, 0x4BA3, 0x4BE3, 0x4C23, /* 192 */
-	0x4C63, 0x4CA3, 0x4CE3, 0x4D23,
-	0x4D63, 0x4DA3, 0x4DE3, 0x4E23,
-	0x4E63, 0x4EA3, 0x4EE3, 0x4F23,
-	0x4F63, 0x4FC3, 0x5003, 0x5043, /* 208 */
-	0x5083, 0x50C3, 0x5103, 0x5143,
-	0x5183, 0x51E2, 0x5222, 0x5262,
-	0x52A2, 0x52E2, 0x5342, 0x5382,
-	0x53C2, 0x5402, 0x5462, 0x54A2, /* 224 */
-	0x5502, 0x5542, 0x55A2, 0x55E2,
-	0x5642, 0x5682, 0x56E2, 0x5722,
-	0x5782, 0x57E1, 0x5841, 0x58A1,
-	0x5901, 0x5961, 0x59C1, 0x5A21, /* 240 */
-	0x5AA1, 0x5B01, 0x5B81, 0x5BE1,
-	0x5C61, 0x5D01, 0x5D80, 0x5E20,
-	0x5EE0, 0x5FA0, 0x6080, 0x61C0,
-};
-
-const u16 bcm43xx_ilt_noisea2[BCM43xx_ILT_NOISEA2_SIZE] = {
-	0x0001, 0x0001, 0x0001, 0xFFFE,
-	0xFFFE, 0x3FFF, 0x1000, 0x0393,
-};
-
-const u16 bcm43xx_ilt_noisea3[BCM43xx_ILT_NOISEA3_SIZE] = {
-	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
-	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
-};
-
-const u16 bcm43xx_ilt_noiseg1[BCM43xx_ILT_NOISEG1_SIZE] = {
-	0x013C, 0x01F5, 0x031A, 0x0631,
-	0x0001, 0x0001, 0x0001, 0x0001,
-};
-
-const u16 bcm43xx_ilt_noiseg2[BCM43xx_ILT_NOISEG2_SIZE] = {
-	0x5484, 0x3C40, 0x0000, 0x0000,
-	0x0000, 0x0000, 0x0000, 0x0000,
-};
-
-const u16 bcm43xx_ilt_noisescaleg1[BCM43xx_ILT_NOISESCALEG_SIZE] = {
-	0x6C77, 0x5162, 0x3B40, 0x3335, /* 0 */
-	0x2F2D, 0x2A2A, 0x2527, 0x1F21,
-	0x1A1D, 0x1719, 0x1616, 0x1414,
-	0x1414, 0x1400, 0x1414, 0x1614,
-	0x1716, 0x1A19, 0x1F1D, 0x2521, /* 16 */
-	0x2A27, 0x2F2A, 0x332D, 0x3B35,
-	0x5140, 0x6C62, 0x0077,
-};
-
-const u16 bcm43xx_ilt_noisescaleg2[BCM43xx_ILT_NOISESCALEG_SIZE] = {
-	0xD8DD, 0xCBD4, 0xBCC0, 0XB6B7, /* 0 */
-	0xB2B0, 0xADAD, 0xA7A9, 0x9FA1,
-	0x969B, 0x9195, 0x8F8F, 0x8A8A,
-	0x8A8A, 0x8A00, 0x8A8A, 0x8F8A,
-	0x918F, 0x9695, 0x9F9B, 0xA7A1, /* 16 */
-	0xADA9, 0xB2AD, 0xB6B0, 0xBCB7,
-	0xCBC0, 0xD8D4, 0x00DD,
-};
-
-const u16 bcm43xx_ilt_noisescaleg3[BCM43xx_ILT_NOISESCALEG_SIZE] = {
-	0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4, /* 0 */
-	0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4,
-	0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4,
-	0xA4A4, 0xA400, 0xA4A4, 0xA4A4,
-	0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4, /* 16 */
-	0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4,
-	0xA4A4, 0xA4A4, 0x00A4,
-};
-
-const u16 bcm43xx_ilt_sigmasqr1[BCM43xx_ILT_SIGMASQR_SIZE] = {
-	0x007A, 0x0075, 0x0071, 0x006C, /* 0 */
-	0x0067, 0x0063, 0x005E, 0x0059,
-	0x0054, 0x0050, 0x004B, 0x0046,
-	0x0042, 0x003D, 0x003D, 0x003D,
-	0x003D, 0x003D, 0x003D, 0x003D, /* 16 */
-	0x003D, 0x003D, 0x003D, 0x003D,
-	0x003D, 0x003D, 0x0000, 0x003D,
-	0x003D, 0x003D, 0x003D, 0x003D,
-	0x003D, 0x003D, 0x003D, 0x003D, /* 32 */
-	0x003D, 0x003D, 0x003D, 0x003D,
-	0x0042, 0x0046, 0x004B, 0x0050,
-	0x0054, 0x0059, 0x005E, 0x0063,
-	0x0067, 0x006C, 0x0071, 0x0075, /* 48 */
-	0x007A,
-};
-
-const u16 bcm43xx_ilt_sigmasqr2[BCM43xx_ILT_SIGMASQR_SIZE] = {
-	0x00DE, 0x00DC, 0x00DA, 0x00D8, /* 0 */
-	0x00D6, 0x00D4, 0x00D2, 0x00CF,
-	0x00CD, 0x00CA, 0x00C7, 0x00C4,
-	0x00C1, 0x00BE, 0x00BE, 0x00BE,
-	0x00BE, 0x00BE, 0x00BE, 0x00BE, /* 16 */
-	0x00BE, 0x00BE, 0x00BE, 0x00BE,
-	0x00BE, 0x00BE, 0x0000, 0x00BE,
-	0x00BE, 0x00BE, 0x00BE, 0x00BE,
-	0x00BE, 0x00BE, 0x00BE, 0x00BE, /* 32 */
-	0x00BE, 0x00BE, 0x00BE, 0x00BE,
-	0x00C1, 0x00C4, 0x00C7, 0x00CA,
-	0x00CD, 0x00CF, 0x00D2, 0x00D4,
-	0x00D6, 0x00D8, 0x00DA, 0x00DC, /* 48 */
-	0x00DE,
-};
-
-/**** Helper functions to access the device Internal Lookup Tables ****/
-
-void bcm43xx_ilt_write(struct bcm43xx_private *bcm, u16 offset, u16 val)
-{
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, val);
-	} else {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_DATA1, val);
-	}
-}
-
-void bcm43xx_ilt_write32(struct bcm43xx_private *bcm, u16 offset, u32 val)
-{
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA2, (val & 0xFFFF0000) >> 16);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, val & 0x0000FFFF);
-	} else {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_DATA2, (val & 0xFFFF0000) >> 16);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_DATA1, val & 0x0000FFFF);
-	}
-}
-
-u16 bcm43xx_ilt_read(struct bcm43xx_private *bcm, u16 offset)
-{
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, offset);
-		return bcm43xx_phy_read(bcm, BCM43xx_PHY_ILT_A_DATA1);
-	} else {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_CTRL, offset);
-		return bcm43xx_phy_read(bcm, BCM43xx_PHY_ILT_G_DATA1);
-	}
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ilt.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_ilt.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#ifndef BCM43xx_ILT_H_
-#define BCM43xx_ILT_H_
-
-#define BCM43xx_ILT_ROTOR_SIZE		53
-extern const u32 bcm43xx_ilt_rotor[BCM43xx_ILT_ROTOR_SIZE];
-#define BCM43xx_ILT_RETARD_SIZE		53
-extern const u32 bcm43xx_ilt_retard[BCM43xx_ILT_RETARD_SIZE];
-#define BCM43xx_ILT_FINEFREQA_SIZE	256
-extern const u16 bcm43xx_ilt_finefreqa[BCM43xx_ILT_FINEFREQA_SIZE];
-#define BCM43xx_ILT_FINEFREQG_SIZE	256
-extern const u16 bcm43xx_ilt_finefreqg[BCM43xx_ILT_FINEFREQG_SIZE];
-#define BCM43xx_ILT_NOISEA2_SIZE	8
-extern const u16 bcm43xx_ilt_noisea2[BCM43xx_ILT_NOISEA2_SIZE];
-#define BCM43xx_ILT_NOISEA3_SIZE	8
-extern const u16 bcm43xx_ilt_noisea3[BCM43xx_ILT_NOISEA3_SIZE];
-#define BCM43xx_ILT_NOISEG1_SIZE	8
-extern const u16 bcm43xx_ilt_noiseg1[BCM43xx_ILT_NOISEG1_SIZE];
-#define BCM43xx_ILT_NOISEG2_SIZE	8
-extern const u16 bcm43xx_ilt_noiseg2[BCM43xx_ILT_NOISEG2_SIZE];
-#define BCM43xx_ILT_NOISESCALEG_SIZE	27
-extern const u16 bcm43xx_ilt_noisescaleg1[BCM43xx_ILT_NOISESCALEG_SIZE];
-extern const u16 bcm43xx_ilt_noisescaleg2[BCM43xx_ILT_NOISESCALEG_SIZE];
-extern const u16 bcm43xx_ilt_noisescaleg3[BCM43xx_ILT_NOISESCALEG_SIZE];
-#define BCM43xx_ILT_SIGMASQR_SIZE	53
-extern const u16 bcm43xx_ilt_sigmasqr1[BCM43xx_ILT_SIGMASQR_SIZE];
-extern const u16 bcm43xx_ilt_sigmasqr2[BCM43xx_ILT_SIGMASQR_SIZE];
-
-
-void bcm43xx_ilt_write(struct bcm43xx_private *bcm, u16 offset, u16 val);
-void bcm43xx_ilt_write32(struct bcm43xx_private *bcm, u16 offset, u32 val);
-u16 bcm43xx_ilt_read(struct bcm43xx_private *bcm, u16 offset);
-
-#endif /* BCM43xx_ILT_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_leds.c
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include "bcm43xx_leds.h"
-#include "bcm43xx_radio.h"
-#include "bcm43xx.h"
-
-#include <linux/bitops.h>
-
-
-static void bcm43xx_led_changestate(struct bcm43xx_led *led)
-{
-	struct bcm43xx_private *bcm = led->bcm;
-	const int index = bcm43xx_led_index(led);
-	const u16 mask = (1 << index);
-	u16 ledctl;
-
-	assert(index >= 0 && index < BCM43xx_NR_LEDS);
-	assert(led->blink_interval);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
-	ledctl = (ledctl & mask) ? (ledctl & ~mask) : (ledctl | mask);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
-}
-
-static void bcm43xx_led_blink(unsigned long d)
-{
-	struct bcm43xx_led *led = (struct bcm43xx_led *)d;
-	struct bcm43xx_private *bcm = led->bcm;
-	unsigned long flags;
-
-	spin_lock_irqsave(&bcm->leds_lock, flags);
-	if (led->blink_interval) {
-		bcm43xx_led_changestate(led);
-		mod_timer(&led->blink_timer, jiffies + led->blink_interval);
-	}
-	spin_unlock_irqrestore(&bcm->leds_lock, flags);
-}
-
-static void bcm43xx_led_blink_start(struct bcm43xx_led *led,
-				    unsigned long interval)
-{
-	if (led->blink_interval)
-		return;
-	led->blink_interval = interval;
-	bcm43xx_led_changestate(led);
-	led->blink_timer.expires = jiffies + interval;
-	add_timer(&led->blink_timer);
-}
-
-static void bcm43xx_led_blink_stop(struct bcm43xx_led *led, int sync)
-{
-	struct bcm43xx_private *bcm = led->bcm;
-	const int index = bcm43xx_led_index(led);
-	u16 ledctl;
-
-	if (!led->blink_interval)
-		return;
-	if (unlikely(sync))
-		del_timer_sync(&led->blink_timer);
-	else
-		del_timer(&led->blink_timer);
-	led->blink_interval = 0;
-
-	/* Make sure the LED is turned off. */
-	assert(index >= 0 && index < BCM43xx_NR_LEDS);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
-	if (led->activelow)
-		ledctl |= (1 << index);
-	else
-		ledctl &= ~(1 << index);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
-}
-
-static void bcm43xx_led_init_hardcoded(struct bcm43xx_private *bcm,
-				       struct bcm43xx_led *led,
-				       int led_index)
-{
-	/* This function is called, if the behaviour (and activelow)
-	 * information for a LED is missing in the SPROM.
-	 * We hardcode the behaviour values for various devices here.
-	 * Note that the BCM43xx_LED_TEST_XXX behaviour values can
-	 * be used to figure out which led is mapped to which index.
-	 */
-
-	switch (led_index) {
-	case 0:
-		led->behaviour = BCM43xx_LED_ACTIVITY;
-		led->activelow = 1;
-		if (bcm->board_vendor == PCI_VENDOR_ID_COMPAQ)
-			led->behaviour = BCM43xx_LED_RADIO_ALL;
-		break;
-	case 1:
-		led->behaviour = BCM43xx_LED_RADIO_B;
-		if (bcm->board_vendor == PCI_VENDOR_ID_ASUSTEK)
-			led->behaviour = BCM43xx_LED_ASSOC;
-		break;
-	case 2:
-		led->behaviour = BCM43xx_LED_RADIO_A;
-		break;
-	case 3:
-		led->behaviour = BCM43xx_LED_OFF;
-		break;
-	default:
-		assert(0);
-	}
-}
-
-int bcm43xx_leds_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_led *led;
-	u8 sprom[4];
-	int i;
-
-	sprom[0] = bcm->sprom.wl0gpio0;
-	sprom[1] = bcm->sprom.wl0gpio1;
-	sprom[2] = bcm->sprom.wl0gpio2;
-	sprom[3] = bcm->sprom.wl0gpio3;
-
-	for (i = 0; i < BCM43xx_NR_LEDS; i++) {
-		led = &(bcm->leds[i]);
-		led->bcm = bcm;
-		setup_timer(&led->blink_timer,
-			    bcm43xx_led_blink,
-			    (unsigned long)led);
-
-		if (sprom[i] == 0xFF) {
-			bcm43xx_led_init_hardcoded(bcm, led, i);
-		} else {
-			led->behaviour = sprom[i] & BCM43xx_LED_BEHAVIOUR;
-			led->activelow = !!(sprom[i] & BCM43xx_LED_ACTIVELOW);
-		}
-	}
-
-	return 0;
-}
-
-void bcm43xx_leds_exit(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_led *led;
-	int i;
-
-	for (i = 0; i < BCM43xx_NR_LEDS; i++) {
-		led = &(bcm->leds[i]);
-		bcm43xx_led_blink_stop(led, 1);
-	}
-	bcm43xx_leds_switch_all(bcm, 0);
-}
-
-void bcm43xx_leds_update(struct bcm43xx_private *bcm, int activity)
-{
-	struct bcm43xx_led *led;
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	const int transferring = (jiffies - bcm->stats.last_tx) < BCM43xx_LED_XFER_THRES;
-	int i, turn_on;
-	unsigned long interval = 0;
-	u16 ledctl;
-	unsigned long flags;
-
-	spin_lock_irqsave(&bcm->leds_lock, flags);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
-	for (i = 0; i < BCM43xx_NR_LEDS; i++) {
-		led = &(bcm->leds[i]);
-
-		turn_on = 0;
-		switch (led->behaviour) {
-		case BCM43xx_LED_INACTIVE:
-			continue;
-		case BCM43xx_LED_OFF:
-		case BCM43xx_LED_BCM4303_3:
-			break;
-		case BCM43xx_LED_ON:
-			turn_on = 1;
-			break;
-		case BCM43xx_LED_ACTIVITY:
-		case BCM43xx_LED_BCM4303_0:
-			turn_on = activity;
-			break;
-		case BCM43xx_LED_RADIO_ALL:
-			turn_on = radio->enabled && bcm43xx_is_hw_radio_enabled(bcm);
-			break;
-		case BCM43xx_LED_RADIO_A:
-		case BCM43xx_LED_BCM4303_2:
-			turn_on = (radio->enabled && bcm43xx_is_hw_radio_enabled(bcm) &&
-				   phy->type == BCM43xx_PHYTYPE_A);
-			break;
-		case BCM43xx_LED_RADIO_B:
-		case BCM43xx_LED_BCM4303_1:
-			turn_on = (radio->enabled && bcm43xx_is_hw_radio_enabled(bcm) &&
-				   (phy->type == BCM43xx_PHYTYPE_B ||
-				    phy->type == BCM43xx_PHYTYPE_G));
-			break;
-		case BCM43xx_LED_MODE_BG:
-			if (phy->type == BCM43xx_PHYTYPE_G && bcm43xx_is_hw_radio_enabled(bcm) &&
-			    1/*FIXME: using G rates.*/)
-				turn_on = 1;
-			break;
-		case BCM43xx_LED_TRANSFER:
-			if (transferring)
-				bcm43xx_led_blink_start(led, BCM43xx_LEDBLINK_MEDIUM);
-			else
-				bcm43xx_led_blink_stop(led, 0);
-			continue;
-		case BCM43xx_LED_APTRANSFER:
-			if (bcm->ieee->iw_mode == IW_MODE_MASTER) {
-				if (transferring) {
-					interval = BCM43xx_LEDBLINK_FAST;
-					turn_on = 1;
-				}
-			} else {
-				turn_on = 1;
-				if (0/*TODO: not assoc*/)
-					interval = BCM43xx_LEDBLINK_SLOW;
-				else if (transferring)
-					interval = BCM43xx_LEDBLINK_FAST;
-				else
-					turn_on = 0;
-			}
-			if (turn_on)
-				bcm43xx_led_blink_start(led, interval);
-			else
-				bcm43xx_led_blink_stop(led, 0);
-			continue;
-		case BCM43xx_LED_WEIRD:
-			//TODO
-			break;
-		case BCM43xx_LED_ASSOC:
-			if (bcm->softmac->associnfo.associated)
-				turn_on = 1;
-			break;
-#ifdef CONFIG_BCM43XX_DEBUG
-		case BCM43xx_LED_TEST_BLINKSLOW:
-			bcm43xx_led_blink_start(led, BCM43xx_LEDBLINK_SLOW);
-			continue;
-		case BCM43xx_LED_TEST_BLINKMEDIUM:
-			bcm43xx_led_blink_start(led, BCM43xx_LEDBLINK_MEDIUM);
-			continue;
-		case BCM43xx_LED_TEST_BLINKFAST:
-			bcm43xx_led_blink_start(led, BCM43xx_LEDBLINK_FAST);
-			continue;
-#endif /* CONFIG_BCM43XX_DEBUG */
-		default:
-			dprintkl(KERN_INFO PFX "Bad value in leds_update,"
-				" led->behaviour: 0x%x\n", led->behaviour);
-		};
-
-		if (led->activelow)
-			turn_on = !turn_on;
-		if (turn_on)
-			ledctl |= (1 << i);
-		else
-			ledctl &= ~(1 << i);
-	}
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
-	spin_unlock_irqrestore(&bcm->leds_lock, flags);
-}
-
-void bcm43xx_leds_switch_all(struct bcm43xx_private *bcm, int on)
-{
-	struct bcm43xx_led *led;
-	u16 ledctl;
-	int i;
-	int bit_on;
-	unsigned long flags;
-
-	spin_lock_irqsave(&bcm->leds_lock, flags);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
-	for (i = 0; i < BCM43xx_NR_LEDS; i++) {
-		led = &(bcm->leds[i]);
-		if (led->behaviour == BCM43xx_LED_INACTIVE)
-			continue;
-		if (on)
-			bit_on = led->activelow ? 0 : 1;
-		else
-			bit_on = led->activelow ? 1 : 0;
-		if (bit_on)
-			ledctl |= (1 << i);
-		else
-			ledctl &= ~(1 << i);
-	}
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
-	spin_unlock_irqrestore(&bcm->leds_lock, flags);
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_leds.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_leds.h
+++ /dev/null
@@ -1,62 +0,0 @@
-#ifndef BCM43xx_LEDS_H_
-#define BCM43xx_LEDS_H_
-
-#include <linux/types.h>
-#include <linux/timer.h>
-
-
-struct bcm43xx_led {
-	u8 behaviour:7;
-	u8 activelow:1;
-
-	struct bcm43xx_private *bcm;
-	struct timer_list blink_timer;
-	unsigned long blink_interval;
-};
-#define bcm43xx_led_index(led)	((int)((led) - (led)->bcm->leds))
-
-/* Delay between state changes when blinking in jiffies */
-#define BCM43xx_LEDBLINK_SLOW		(HZ / 1)
-#define BCM43xx_LEDBLINK_MEDIUM		(HZ / 4)
-#define BCM43xx_LEDBLINK_FAST		(HZ / 8)
-
-#define BCM43xx_LED_XFER_THRES		(HZ / 100)
-
-#define BCM43xx_LED_BEHAVIOUR		0x7F
-#define BCM43xx_LED_ACTIVELOW		0x80
-enum { /* LED behaviour values */
-	BCM43xx_LED_OFF,
-	BCM43xx_LED_ON,
-	BCM43xx_LED_ACTIVITY,
-	BCM43xx_LED_RADIO_ALL,
-	BCM43xx_LED_RADIO_A,
-	BCM43xx_LED_RADIO_B,
-	BCM43xx_LED_MODE_BG,
-	BCM43xx_LED_TRANSFER,
-	BCM43xx_LED_APTRANSFER,
-	BCM43xx_LED_WEIRD,//FIXME
-	BCM43xx_LED_ASSOC,
-	BCM43xx_LED_INACTIVE,
-
-	/* Behaviour values for testing.
-	 * With these values it is easier to figure out
-	 * the real behaviour of leds, in case the SPROM
-	 * is missing information.
-	 */
-	BCM43xx_LED_TEST_BLINKSLOW,
-	BCM43xx_LED_TEST_BLINKMEDIUM,
-	BCM43xx_LED_TEST_BLINKFAST,
-
-	/* Misc values for BCM4303 */
-	BCM43xx_LED_BCM4303_0 = 0x2B,
-	BCM43xx_LED_BCM4303_1 = 0x78,
-	BCM43xx_LED_BCM4303_2 = 0x2E,
-	BCM43xx_LED_BCM4303_3 = 0x19,
-};
-
-int bcm43xx_leds_init(struct bcm43xx_private *bcm);
-void bcm43xx_leds_exit(struct bcm43xx_private *bcm);
-void bcm43xx_leds_update(struct bcm43xx_private *bcm, int activity);
-void bcm43xx_leds_switch_all(struct bcm43xx_private *bcm, int on);
-
-#endif /* BCM43xx_LEDS_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ /dev/null
@@ -1,4281 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/moduleparam.h>
-#include <linux/if_arp.h>
-#include <linux/etherdevice.h>
-#include <linux/version.h>
-#include <linux/firmware.h>
-#include <linux/wireless.h>
-#include <linux/workqueue.h>
-#include <linux/skbuff.h>
-#include <linux/dma-mapping.h>
-#include <net/iw_handler.h>
-
-#include "bcm43xx.h"
-#include "bcm43xx_main.h"
-#include "bcm43xx_debugfs.h"
-#include "bcm43xx_radio.h"
-#include "bcm43xx_phy.h"
-#include "bcm43xx_dma.h"
-#include "bcm43xx_pio.h"
-#include "bcm43xx_power.h"
-#include "bcm43xx_wx.h"
-#include "bcm43xx_ethtool.h"
-#include "bcm43xx_xmit.h"
-#include "bcm43xx_sysfs.h"
-
-
-MODULE_DESCRIPTION("Broadcom BCM43xx wireless driver");
-MODULE_AUTHOR("Martin Langer");
-MODULE_AUTHOR("Stefano Brivio");
-MODULE_AUTHOR("Michael Buesch");
-MODULE_LICENSE("GPL");
-
-#if defined(CONFIG_BCM43XX_DMA) && defined(CONFIG_BCM43XX_PIO)
-static int modparam_pio;
-module_param_named(pio, modparam_pio, int, 0444);
-MODULE_PARM_DESC(pio, "enable(1) / disable(0) PIO mode");
-#elif defined(CONFIG_BCM43XX_DMA)
-# define modparam_pio	0
-#elif defined(CONFIG_BCM43XX_PIO)
-# define modparam_pio	1
-#endif
-
-static int modparam_bad_frames_preempt;
-module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
-MODULE_PARM_DESC(bad_frames_preempt, "enable(1) / disable(0) Bad Frames Preemption");
-
-static int modparam_short_retry = BCM43xx_DEFAULT_SHORT_RETRY_LIMIT;
-module_param_named(short_retry, modparam_short_retry, int, 0444);
-MODULE_PARM_DESC(short_retry, "Short-Retry-Limit (0 - 15)");
-
-static int modparam_long_retry = BCM43xx_DEFAULT_LONG_RETRY_LIMIT;
-module_param_named(long_retry, modparam_long_retry, int, 0444);
-MODULE_PARM_DESC(long_retry, "Long-Retry-Limit (0 - 15)");
-
-static int modparam_locale = -1;
-module_param_named(locale, modparam_locale, int, 0444);
-MODULE_PARM_DESC(country, "Select LocaleCode 0-11 (For travelers)");
-
-static int modparam_noleds;
-module_param_named(noleds, modparam_noleds, int, 0444);
-MODULE_PARM_DESC(noleds, "Turn off all LED activity");
-
-static char modparam_fwpostfix[64];
-module_param_string(fwpostfix, modparam_fwpostfix, 64, 0444);
-MODULE_PARM_DESC(fwpostfix, "Postfix for .fw files. Useful for using multiple firmware image versions.");
-
-
-/* If you want to debug with just a single device, enable this,
- * where the string is the pci device ID (as given by the kernel's
- * pci_name function) of the device to be used.
- */
-//#define DEBUG_SINGLE_DEVICE_ONLY	"0001:11:00.0"
-
-/* If you want to enable printing of each MMIO access, enable this. */
-//#define DEBUG_ENABLE_MMIO_PRINT
-
-/* If you want to enable printing of MMIO access within
- * ucode/pcm upload, initvals write, enable this.
- */
-//#define DEBUG_ENABLE_UCODE_MMIO_PRINT
-
-/* If you want to enable printing of PCI Config Space access, enable this */
-//#define DEBUG_ENABLE_PCILOG
-
-
-/* Detailed list maintained at:
- * http://openfacts.berlios.de/index-en.phtml?title=Bcm43xxDevices
- */
-	static struct pci_device_id bcm43xx_pci_tbl[] = {
-	/* Broadcom 4303 802.11b */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4301, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4307 802.11b */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4307, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4311 802.11(a)/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4311, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4312 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4312, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4318 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4318, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4319 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4319, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4306 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4320, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4306 802.11a */
-//	{ PCI_VENDOR_ID_BROADCOM, 0x4321, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4309 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4324, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 43XG 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4325, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ 0 },
-};
-MODULE_DEVICE_TABLE(pci, bcm43xx_pci_tbl);
-
-static void bcm43xx_ram_write(struct bcm43xx_private *bcm, u16 offset, u32 val)
-{
-	u32 status;
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	if (!(status & BCM43xx_SBF_XFER_REG_BYTESWAP))
-		val = swab32(val);
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_RAM_CONTROL, offset);
-	mmiowb();
-	bcm43xx_write32(bcm, BCM43xx_MMIO_RAM_DATA, val);
-}
-
-static inline
-void bcm43xx_shm_control_word(struct bcm43xx_private *bcm,
-			      u16 routing, u16 offset)
-{
-	u32 control;
-
-	/* "offset" is the WORD offset. */
-
-	control = routing;
-	control <<= 16;
-	control |= offset;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_CONTROL, control);
-}
-
-u32 bcm43xx_shm_read32(struct bcm43xx_private *bcm,
-		       u16 routing, u16 offset)
-{
-	u32 ret;
-
-	if (routing == BCM43xx_SHM_SHARED) {
-		if (offset & 0x0003) {
-			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset >> 2);
-			ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED);
-			ret <<= 16;
-			bcm43xx_shm_control_word(bcm, routing, (offset >> 2) + 1);
-			ret |= bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA);
-
-			return ret;
-		}
-		offset >>= 2;
-	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	ret = bcm43xx_read32(bcm, BCM43xx_MMIO_SHM_DATA);
-
-	return ret;
-}
-
-u16 bcm43xx_shm_read16(struct bcm43xx_private *bcm,
-		       u16 routing, u16 offset)
-{
-	u16 ret;
-
-	if (routing == BCM43xx_SHM_SHARED) {
-		if (offset & 0x0003) {
-			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset >> 2);
-			ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED);
-
-			return ret;
-		}
-		offset >>= 2;
-	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA);
-
-	return ret;
-}
-
-void bcm43xx_shm_write32(struct bcm43xx_private *bcm,
-			 u16 routing, u16 offset,
-			 u32 value)
-{
-	if (routing == BCM43xx_SHM_SHARED) {
-		if (offset & 0x0003) {
-			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset >> 2);
-			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
-					(value >> 16) & 0xffff);
-			mmiowb();
-			bcm43xx_shm_control_word(bcm, routing, (offset >> 2) + 1);
-			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA,
-					value & 0xffff);
-			return;
-		}
-		offset >>= 2;
-	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	mmiowb();
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA, value);
-}
-
-void bcm43xx_shm_write16(struct bcm43xx_private *bcm,
-			 u16 routing, u16 offset,
-			 u16 value)
-{
-	if (routing == BCM43xx_SHM_SHARED) {
-		if (offset & 0x0003) {
-			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset >> 2);
-			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
-					value);
-			return;
-		}
-		offset >>= 2;
-	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	mmiowb();
-	bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA, value);
-}
-
-void bcm43xx_tsf_read(struct bcm43xx_private *bcm, u64 *tsf)
-{
-	/* We need to be careful. As we read the TSF from multiple
-	 * registers, we should take care of register overflows.
-	 * In theory, the whole tsf read process should be atomic.
-	 * We try to be atomic here, by restaring the read process,
-	 * if any of the high registers changed (overflew).
-	 */
-	if (bcm->current_core->rev >= 3) {
-		u32 low, high, high2;
-
-		do {
-			high = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
-			low = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW);
-			high2 = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
-		} while (unlikely(high != high2));
-
-		*tsf = high;
-		*tsf <<= 32;
-		*tsf |= low;
-	} else {
-		u64 tmp;
-		u16 v0, v1, v2, v3;
-		u16 test1, test2, test3;
-
-		do {
-			v3 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_3);
-			v2 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_2);
-			v1 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_1);
-			v0 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_0);
-
-			test3 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_3);
-			test2 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_2);
-			test1 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_1);
-		} while (v3 != test3 || v2 != test2 || v1 != test1);
-
-		*tsf = v3;
-		*tsf <<= 48;
-		tmp = v2;
-		tmp <<= 32;
-		*tsf |= tmp;
-		tmp = v1;
-		tmp <<= 16;
-		*tsf |= tmp;
-		*tsf |= v0;
-	}
-}
-
-void bcm43xx_tsf_write(struct bcm43xx_private *bcm, u64 tsf)
-{
-	u32 status;
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	status |= BCM43xx_SBF_TIME_UPDATE;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-	mmiowb();
-
-	/* Be careful with the in-progress timer.
-	 * First zero out the low register, so we have a full
-	 * register-overflow duration to complete the operation.
-	 */
-	if (bcm->current_core->rev >= 3) {
-		u32 lo = (tsf & 0x00000000FFFFFFFFULL);
-		u32 hi = (tsf & 0xFFFFFFFF00000000ULL) >> 32;
-
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW, 0);
-		mmiowb();
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH, hi);
-		mmiowb();
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW, lo);
-	} else {
-		u16 v0 = (tsf & 0x000000000000FFFFULL);
-		u16 v1 = (tsf & 0x00000000FFFF0000ULL) >> 16;
-		u16 v2 = (tsf & 0x0000FFFF00000000ULL) >> 32;
-		u16 v3 = (tsf & 0xFFFF000000000000ULL) >> 48;
-
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_0, 0);
-		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_3, v3);
-		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_2, v2);
-		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_1, v1);
-		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_0, v0);
-	}
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	status &= ~BCM43xx_SBF_TIME_UPDATE;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-}
-
-static
-void bcm43xx_macfilter_set(struct bcm43xx_private *bcm,
-			   u16 offset,
-			   const u8 *mac)
-{
-	u16 data;
-
-	offset |= 0x0020;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_CONTROL, offset);
-
-	data = mac[0];
-	data |= mac[1] << 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
-	data = mac[2];
-	data |= mac[3] << 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
-	data = mac[4];
-	data |= mac[5] << 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
-}
-
-static void bcm43xx_macfilter_clear(struct bcm43xx_private *bcm,
-				    u16 offset)
-{
-	const u8 zero_addr[ETH_ALEN] = { 0 };
-
-	bcm43xx_macfilter_set(bcm, offset, zero_addr);
-}
-
-static void bcm43xx_write_mac_bssid_templates(struct bcm43xx_private *bcm)
-{
-	const u8 *mac = (const u8 *)(bcm->net_dev->dev_addr);
-	const u8 *bssid = (const u8 *)(bcm->ieee->bssid);
-	u8 mac_bssid[ETH_ALEN * 2];
-	int i;
-
-	memcpy(mac_bssid, mac, ETH_ALEN);
-	memcpy(mac_bssid + ETH_ALEN, bssid, ETH_ALEN);
-
-	/* Write our MAC address and BSSID to template ram */
-	for (i = 0; i < ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x20 + i, *((u32 *)(mac_bssid + i)));
-	for (i = 0; i < ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x78 + i, *((u32 *)(mac_bssid + i)));
-	for (i = 0; i < ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x478 + i, *((u32 *)(mac_bssid + i)));
-}
-
-//FIXME: Well, we should probably call them from somewhere.
-#if 0
-static void bcm43xx_set_slot_time(struct bcm43xx_private *bcm, u16 slot_time)
-{
-	/* slot_time is in usec. */
-	if (bcm43xx_current_phy(bcm)->type != BCM43xx_PHYTYPE_G)
-		return;
-	bcm43xx_write16(bcm, 0x684, 510 + slot_time);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0010, slot_time);
-}
-
-static void bcm43xx_short_slot_timing_enable(struct bcm43xx_private *bcm)
-{
-	bcm43xx_set_slot_time(bcm, 9);
-}
-
-static void bcm43xx_short_slot_timing_disable(struct bcm43xx_private *bcm)
-{
-	bcm43xx_set_slot_time(bcm, 20);
-}
-#endif
-
-/* FIXME: To get the MAC-filter working, we need to implement the
- *        following functions (and rename them :)
- */
-#if 0
-static void bcm43xx_disassociate(struct bcm43xx_private *bcm)
-{
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_macfilter_clear(bcm, BCM43xx_MACFILTER_ASSOC);
-
-	bcm43xx_ram_write(bcm, 0x0026, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0028, 0x0000);
-	bcm43xx_ram_write(bcm, 0x007E, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0080, 0x0000);
-	bcm43xx_ram_write(bcm, 0x047E, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0480, 0x0000);
-
-	if (bcm->current_core->rev < 3) {
-		bcm43xx_write16(bcm, 0x0610, 0x8000);
-		bcm43xx_write16(bcm, 0x060E, 0x0000);
-	} else
-		bcm43xx_write32(bcm, 0x0188, 0x80000000);
-
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0004, 0x000003ff);
-
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_G &&
-	    ieee80211_is_ofdm_rate(bcm->softmac->txrates.default_rate))
-		bcm43xx_short_slot_timing_enable(bcm);
-
-	bcm43xx_mac_enable(bcm);
-}
-
-static void bcm43xx_associate(struct bcm43xx_private *bcm,
-			      const u8 *mac)
-{
-	memcpy(bcm->ieee->bssid, mac, ETH_ALEN);
-
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_macfilter_set(bcm, BCM43xx_MACFILTER_ASSOC, mac);
-	bcm43xx_write_mac_bssid_templates(bcm);
-	bcm43xx_mac_enable(bcm);
-}
-#endif
-
-/* Enable a Generic IRQ. "mask" is the mask of which IRQs to enable.
- * Returns the _previously_ enabled IRQ mask.
- */
-static inline u32 bcm43xx_interrupt_enable(struct bcm43xx_private *bcm, u32 mask)
-{
-	u32 old_mask;
-
-	old_mask = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask | mask);
-
-	return old_mask;
-}
-
-/* Disable a Generic IRQ. "mask" is the mask of which IRQs to disable.
- * Returns the _previously_ enabled IRQ mask.
- */
-static inline u32 bcm43xx_interrupt_disable(struct bcm43xx_private *bcm, u32 mask)
-{
-	u32 old_mask;
-
-	old_mask = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask & ~mask);
-
-	return old_mask;
-}
-
-/* Synchronize IRQ top- and bottom-half.
- * IRQs must be masked before calling this.
- * This must not be called with the irq_lock held.
- */
-static void bcm43xx_synchronize_irq(struct bcm43xx_private *bcm)
-{
-	synchronize_irq(bcm->irq);
-	tasklet_disable(&bcm->isr_tasklet);
-}
-
-/* Make sure we don't receive more data from the device. */
-static int bcm43xx_disable_interrupts_sync(struct bcm43xx_private *bcm)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (unlikely(bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)) {
-		spin_unlock_irqrestore(&bcm->irq_lock, flags);
-		return -EBUSY;
-	}
-	bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-	bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK); /* flush */
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	bcm43xx_synchronize_irq(bcm);
-
-	return 0;
-}
-
-static int bcm43xx_read_radioinfo(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u32 radio_id;
-	u16 manufact;
-	u16 version;
-	u8 revision;
-
-	if (bcm->chip_id == 0x4317) {
-		if (bcm->chip_rev == 0x00)
-			radio_id = 0x3205017F;
-		else if (bcm->chip_rev == 0x01)
-			radio_id = 0x4205017F;
-		else
-			radio_id = 0x5205017F;
-	} else {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, BCM43xx_RADIOCTL_ID);
-		radio_id = bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_DATA_HIGH);
-		radio_id <<= 16;
-		bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, BCM43xx_RADIOCTL_ID);
-		radio_id |= bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_DATA_LOW);
-	}
-
-	manufact = (radio_id & 0x00000FFF);
-	version = (radio_id & 0x0FFFF000) >> 12;
-	revision = (radio_id & 0xF0000000) >> 28;
-
-	dprintk(KERN_INFO PFX "Detected Radio: ID: %x (Manuf: %x Ver: %x Rev: %x)\n",
-		radio_id, manufact, version, revision);
-
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		if ((version != 0x2060) || (revision != 1) || (manufact != 0x17f))
-			goto err_unsupported_radio;
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if ((version & 0xFFF0) != 0x2050)
-			goto err_unsupported_radio;
-		break;
-	case BCM43xx_PHYTYPE_G:
-		if (version != 0x2050)
-			goto err_unsupported_radio;
-		break;
-	}
-
-	radio->manufact = manufact;
-	radio->version = version;
-	radio->revision = revision;
-
-	if (phy->type == BCM43xx_PHYTYPE_A)
-		radio->txpower_desired = bcm->sprom.maxpower_aphy;
-	else
-		radio->txpower_desired = bcm->sprom.maxpower_bgphy;
-
-	return 0;
-
-err_unsupported_radio:
-	printk(KERN_ERR PFX "Unsupported Radio connected to the PHY!\n");
-	return -ENODEV;
-}
-
-static const char * bcm43xx_locale_iso(u8 locale)
-{
-	/* ISO 3166-1 country codes.
-	 * Note that there aren't ISO 3166-1 codes for
-	 * all or locales. (Not all locales are countries)
-	 */
-	switch (locale) {
-	case BCM43xx_LOCALE_WORLD:
-	case BCM43xx_LOCALE_ALL:
-		return "XX";
-	case BCM43xx_LOCALE_THAILAND:
-		return "TH";
-	case BCM43xx_LOCALE_ISRAEL:
-		return "IL";
-	case BCM43xx_LOCALE_JORDAN:
-		return "JO";
-	case BCM43xx_LOCALE_CHINA:
-		return "CN";
-	case BCM43xx_LOCALE_JAPAN:
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		return "JP";
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-	case BCM43xx_LOCALE_USA_LOW:
-		return "US";
-	case BCM43xx_LOCALE_EUROPE:
-		return "EU";
-	case BCM43xx_LOCALE_NONE:
-		return "  ";
-	}
-	assert(0);
-	return "  ";
-}
-
-static const char * bcm43xx_locale_string(u8 locale)
-{
-	switch (locale) {
-	case BCM43xx_LOCALE_WORLD:
-		return "World";
-	case BCM43xx_LOCALE_THAILAND:
-		return "Thailand";
-	case BCM43xx_LOCALE_ISRAEL:
-		return "Israel";
-	case BCM43xx_LOCALE_JORDAN:
-		return "Jordan";
-	case BCM43xx_LOCALE_CHINA:
-		return "China";
-	case BCM43xx_LOCALE_JAPAN:
-		return "Japan";
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-		return "USA/Canada/ANZ";
-	case BCM43xx_LOCALE_EUROPE:
-		return "Europe";
-	case BCM43xx_LOCALE_USA_LOW:
-		return "USAlow";
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		return "JapanHigh";
-	case BCM43xx_LOCALE_ALL:
-		return "All";
-	case BCM43xx_LOCALE_NONE:
-		return "None";
-	}
-	assert(0);
-	return "";
-}
-
-static inline u8 bcm43xx_crc8(u8 crc, u8 data)
-{
-	static const u8 t[] = {
-		0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
-		0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
-		0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
-		0xDE, 0x29, 0x67, 0x90, 0xFB, 0x0C, 0x42, 0xB5,
-		0x7F, 0x88, 0xC6, 0x31, 0x5A, 0xAD, 0xE3, 0x14,
-		0x35, 0xC2, 0x8C, 0x7B, 0x10, 0xE7, 0xA9, 0x5E,
-		0xEB, 0x1C, 0x52, 0xA5, 0xCE, 0x39, 0x77, 0x80,
-		0xA1, 0x56, 0x18, 0xEF, 0x84, 0x73, 0x3D, 0xCA,
-		0xFE, 0x09, 0x47, 0xB0, 0xDB, 0x2C, 0x62, 0x95,
-		0xB4, 0x43, 0x0D, 0xFA, 0x91, 0x66, 0x28, 0xDF,
-		0x6A, 0x9D, 0xD3, 0x24, 0x4F, 0xB8, 0xF6, 0x01,
-		0x20, 0xD7, 0x99, 0x6E, 0x05, 0xF2, 0xBC, 0x4B,
-		0x81, 0x76, 0x38, 0xCF, 0xA4, 0x53, 0x1D, 0xEA,
-		0xCB, 0x3C, 0x72, 0x85, 0xEE, 0x19, 0x57, 0xA0,
-		0x15, 0xE2, 0xAC, 0x5B, 0x30, 0xC7, 0x89, 0x7E,
-		0x5F, 0xA8, 0xE6, 0x11, 0x7A, 0x8D, 0xC3, 0x34,
-		0xAB, 0x5C, 0x12, 0xE5, 0x8E, 0x79, 0x37, 0xC0,
-		0xE1, 0x16, 0x58, 0xAF, 0xC4, 0x33, 0x7D, 0x8A,
-		0x3F, 0xC8, 0x86, 0x71, 0x1A, 0xED, 0xA3, 0x54,
-		0x75, 0x82, 0xCC, 0x3B, 0x50, 0xA7, 0xE9, 0x1E,
-		0xD4, 0x23, 0x6D, 0x9A, 0xF1, 0x06, 0x48, 0xBF,
-		0x9E, 0x69, 0x27, 0xD0, 0xBB, 0x4C, 0x02, 0xF5,
-		0x40, 0xB7, 0xF9, 0x0E, 0x65, 0x92, 0xDC, 0x2B,
-		0x0A, 0xFD, 0xB3, 0x44, 0x2F, 0xD8, 0x96, 0x61,
-		0x55, 0xA2, 0xEC, 0x1B, 0x70, 0x87, 0xC9, 0x3E,
-		0x1F, 0xE8, 0xA6, 0x51, 0x3A, 0xCD, 0x83, 0x74,
-		0xC1, 0x36, 0x78, 0x8F, 0xE4, 0x13, 0x5D, 0xAA,
-		0x8B, 0x7C, 0x32, 0xC5, 0xAE, 0x59, 0x17, 0xE0,
-		0x2A, 0xDD, 0x93, 0x64, 0x0F, 0xF8, 0xB6, 0x41,
-		0x60, 0x97, 0xD9, 0x2E, 0x45, 0xB2, 0xFC, 0x0B,
-		0xBE, 0x49, 0x07, 0xF0, 0x9B, 0x6C, 0x22, 0xD5,
-		0xF4, 0x03, 0x4D, 0xBA, 0xD1, 0x26, 0x68, 0x9F,
-	};
-	return t[crc ^ data];
-}
-
-static u8 bcm43xx_sprom_crc(const u16 *sprom)
-{
-	int word;
-	u8 crc = 0xFF;
-
-	for (word = 0; word < BCM43xx_SPROM_SIZE - 1; word++) {
-		crc = bcm43xx_crc8(crc, sprom[word] & 0x00FF);
-		crc = bcm43xx_crc8(crc, (sprom[word] & 0xFF00) >> 8);
-	}
-	crc = bcm43xx_crc8(crc, sprom[BCM43xx_SPROM_VERSION] & 0x00FF);
-	crc ^= 0xFF;
-
-	return crc;
-}
-
-int bcm43xx_sprom_read(struct bcm43xx_private *bcm, u16 *sprom)
-{
-	int i;
-	u8 crc, expected_crc;
-
-	for (i = 0; i < BCM43xx_SPROM_SIZE; i++)
-		sprom[i] = bcm43xx_read16(bcm, BCM43xx_SPROM_BASE + (i * 2));
-	/* CRC-8 check. */
-	crc = bcm43xx_sprom_crc(sprom);
-	expected_crc = (sprom[BCM43xx_SPROM_VERSION] & 0xFF00) >> 8;
-	if (crc != expected_crc) {
-		printk(KERN_WARNING PFX "WARNING: Invalid SPROM checksum "
-					"(0x%02X, expected: 0x%02X)\n",
-		       crc, expected_crc);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int bcm43xx_sprom_write(struct bcm43xx_private *bcm, const u16 *sprom)
-{
-	int i, err;
-	u8 crc, expected_crc;
-	u32 spromctl;
-
-	/* CRC-8 validation of the input data. */
-	crc = bcm43xx_sprom_crc(sprom);
-	expected_crc = (sprom[BCM43xx_SPROM_VERSION] & 0xFF00) >> 8;
-	if (crc != expected_crc) {
-		printk(KERN_ERR PFX "SPROM input data: Invalid CRC\n");
-		return -EINVAL;
-	}
-
-	printk(KERN_INFO PFX "Writing SPROM. Do NOT turn off the power! Please stand by...\n");
-	err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_SPROMCTL, &spromctl);
-	if (err)
-		goto err_ctlreg;
-	spromctl |= 0x10; /* SPROM WRITE enable. */
-	err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_SPROMCTL, spromctl);
-	if (err)
-		goto err_ctlreg;
-	/* We must burn lots of CPU cycles here, but that does not
-	 * really matter as one does not write the SPROM every other minute...
-	 */
-	printk(KERN_INFO PFX "[ 0%%");
-	mdelay(500);
-	for (i = 0; i < BCM43xx_SPROM_SIZE; i++) {
-		if (i == 16)
-			printk("25%%");
-		else if (i == 32)
-			printk("50%%");
-		else if (i == 48)
-			printk("75%%");
-		else if (i % 2)
-			printk(".");
-		bcm43xx_write16(bcm, BCM43xx_SPROM_BASE + (i * 2), sprom[i]);
-		mmiowb();
-		mdelay(20);
-	}
-	spromctl &= ~0x10; /* SPROM WRITE enable. */
-	err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_SPROMCTL, spromctl);
-	if (err)
-		goto err_ctlreg;
-	mdelay(500);
-	printk("100%% ]\n");
-	printk(KERN_INFO PFX "SPROM written.\n");
-	bcm43xx_controller_restart(bcm, "SPROM update");
-
-	return 0;
-err_ctlreg:
-	printk(KERN_ERR PFX "Could not access SPROM control register.\n");
-	return -ENODEV;
-}
-
-static int bcm43xx_sprom_extract(struct bcm43xx_private *bcm)
-{
-	u16 value;
-	u16 *sprom;
-
-	sprom = kzalloc(BCM43xx_SPROM_SIZE * sizeof(u16),
-			GFP_KERNEL);
-	if (!sprom) {
-		printk(KERN_ERR PFX "sprom_extract OOM\n");
-		return -ENOMEM;
-	}
-	bcm43xx_sprom_read(bcm, sprom);
-
-	/* boardflags2 */
-	value = sprom[BCM43xx_SPROM_BOARDFLAGS2];
-	bcm->sprom.boardflags2 = value;
-
-	/* il0macaddr */
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 0];
-	*(((u16 *)bcm->sprom.il0macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 1];
-	*(((u16 *)bcm->sprom.il0macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 2];
-	*(((u16 *)bcm->sprom.il0macaddr) + 2) = cpu_to_be16(value);
-
-	/* et0macaddr */
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 0];
-	*(((u16 *)bcm->sprom.et0macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 1];
-	*(((u16 *)bcm->sprom.et0macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 2];
-	*(((u16 *)bcm->sprom.et0macaddr) + 2) = cpu_to_be16(value);
-
-	/* et1macaddr */
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 0];
-	*(((u16 *)bcm->sprom.et1macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 1];
-	*(((u16 *)bcm->sprom.et1macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 2];
-	*(((u16 *)bcm->sprom.et1macaddr) + 2) = cpu_to_be16(value);
-
-	/* ethernet phy settings */
-	value = sprom[BCM43xx_SPROM_ETHPHY];
-	bcm->sprom.et0phyaddr = (value & 0x001F);
-	bcm->sprom.et1phyaddr = (value & 0x03E0) >> 5;
-
-	/* boardrev, antennas, locale */
-	value = sprom[BCM43xx_SPROM_BOARDREV];
-	bcm->sprom.boardrev = (value & 0x00FF);
-	bcm->sprom.locale = (value & 0x0F00) >> 8;
-	bcm->sprom.antennas_aphy = (value & 0x3000) >> 12;
-	bcm->sprom.antennas_bgphy = (value & 0xC000) >> 14;
-	if (modparam_locale != -1) {
-		if (modparam_locale >= 0 && modparam_locale <= 11) {
-			bcm->sprom.locale = modparam_locale;
-			printk(KERN_WARNING PFX "Operating with modified "
-						"LocaleCode %u (%s)\n",
-			       bcm->sprom.locale,
-			       bcm43xx_locale_string(bcm->sprom.locale));
-		} else {
-			printk(KERN_WARNING PFX "Module parameter \"locale\" "
-						"invalid value. (0 - 11)\n");
-		}
-	}
-
-	/* pa0b* */
-	value = sprom[BCM43xx_SPROM_PA0B0];
-	bcm->sprom.pa0b0 = value;
-	value = sprom[BCM43xx_SPROM_PA0B1];
-	bcm->sprom.pa0b1 = value;
-	value = sprom[BCM43xx_SPROM_PA0B2];
-	bcm->sprom.pa0b2 = value;
-
-	/* wl0gpio* */
-	value = sprom[BCM43xx_SPROM_WL0GPIO0];
-	if (value == 0x0000)
-		value = 0xFFFF;
-	bcm->sprom.wl0gpio0 = value & 0x00FF;
-	bcm->sprom.wl0gpio1 = (value & 0xFF00) >> 8;
-	value = sprom[BCM43xx_SPROM_WL0GPIO2];
-	if (value == 0x0000)
-		value = 0xFFFF;
-	bcm->sprom.wl0gpio2 = value & 0x00FF;
-	bcm->sprom.wl0gpio3 = (value & 0xFF00) >> 8;
-
-	/* maxpower */
-	value = sprom[BCM43xx_SPROM_MAXPWR];
-	bcm->sprom.maxpower_aphy = (value & 0xFF00) >> 8;
-	bcm->sprom.maxpower_bgphy = value & 0x00FF;
-
-	/* pa1b* */
-	value = sprom[BCM43xx_SPROM_PA1B0];
-	bcm->sprom.pa1b0 = value;
-	value = sprom[BCM43xx_SPROM_PA1B1];
-	bcm->sprom.pa1b1 = value;
-	value = sprom[BCM43xx_SPROM_PA1B2];
-	bcm->sprom.pa1b2 = value;
-
-	/* idle tssi target */
-	value = sprom[BCM43xx_SPROM_IDL_TSSI_TGT];
-	bcm->sprom.idle_tssi_tgt_aphy = value & 0x00FF;
-	bcm->sprom.idle_tssi_tgt_bgphy = (value & 0xFF00) >> 8;
-
-	/* boardflags */
-	value = sprom[BCM43xx_SPROM_BOARDFLAGS];
-	if (value == 0xFFFF)
-		value = 0x0000;
-	bcm->sprom.boardflags = value;
-	/* boardflags workarounds */
-	if (bcm->board_vendor == PCI_VENDOR_ID_DELL &&
-	    bcm->chip_id == 0x4301 &&
-	    bcm->board_revision == 0x74)
-		bcm->sprom.boardflags |= BCM43xx_BFL_BTCOEXIST;
-	if (bcm->board_vendor == PCI_VENDOR_ID_APPLE &&
-	    bcm->board_type == 0x4E &&
-	    bcm->board_revision > 0x40)
-		bcm->sprom.boardflags |= BCM43xx_BFL_PACTRL;
-
-	/* antenna gain */
-	value = sprom[BCM43xx_SPROM_ANTENNA_GAIN];
-	if (value == 0x0000 || value == 0xFFFF)
-		value = 0x0202;
-	/* convert values to Q5.2 */
-	bcm->sprom.antennagain_aphy = ((value & 0xFF00) >> 8) * 4;
-	bcm->sprom.antennagain_bgphy = (value & 0x00FF) * 4;
-
-	kfree(sprom);
-
-	return 0;
-}
-
-static int bcm43xx_geo_init(struct bcm43xx_private *bcm)
-{
-	struct ieee80211_geo *geo;
-	struct ieee80211_channel *chan;
-	int have_a = 0, have_bg = 0;
-	int i;
-	u8 channel;
-	struct bcm43xx_phyinfo *phy;
-	const char *iso_country;
-	u8 max_bg_channel;
-
-	geo = kzalloc(sizeof(*geo), GFP_KERNEL);
-	if (!geo)
-		return -ENOMEM;
-
-	for (i = 0; i < bcm->nr_80211_available; i++) {
-		phy = &(bcm->core_80211_ext[i].phy);
-		switch (phy->type) {
-		case BCM43xx_PHYTYPE_B:
-		case BCM43xx_PHYTYPE_G:
-			have_bg = 1;
-			break;
-		case BCM43xx_PHYTYPE_A:
-			have_a = 1;
-			break;
-		default:
-			assert(0);
-		}
-	}
-	iso_country = bcm43xx_locale_iso(bcm->sprom.locale);
-
-/* set the maximum channel based on locale set in sprom or witle locale option */
-	switch (bcm->sprom.locale) {
-	case BCM43xx_LOCALE_THAILAND:
-	case BCM43xx_LOCALE_ISRAEL:
-	case BCM43xx_LOCALE_JORDAN:
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-	case BCM43xx_LOCALE_USA_LOW:
-		max_bg_channel = 11;
-		break;
-	case BCM43xx_LOCALE_JAPAN:
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		max_bg_channel = 14;
-		break;
-	default:
-		max_bg_channel = 13;
-	}
-
- 	if (have_a) {
-		for (i = 0, channel = IEEE80211_52GHZ_MIN_CHANNEL;
-		      channel <= IEEE80211_52GHZ_MAX_CHANNEL; channel++) {
-			chan = &geo->a[i++];
-			chan->freq = bcm43xx_channel_to_freq_a(channel);
-			chan->channel = channel;
-		}
-		geo->a_channels = i;
-	}
-	if (have_bg) {
-		for (i = 0, channel = IEEE80211_24GHZ_MIN_CHANNEL;
-		      channel <= max_bg_channel; channel++) {
-			chan = &geo->bg[i++];
-			chan->freq = bcm43xx_channel_to_freq_bg(channel);
-			chan->channel = channel;
-		}
-		geo->bg_channels = i;
-	}
-	memcpy(geo->name, iso_country, 2);
-	if (0 /*TODO: Outdoor use only */)
-		geo->name[2] = 'O';
-	else if (0 /*TODO: Indoor use only */)
-		geo->name[2] = 'I';
-	else
-		geo->name[2] = ' ';
-	geo->name[3] = '\0';
-
-	ieee80211_set_geo(bcm->ieee, geo);
-	kfree(geo);
-
-	return 0;
-}
-
-/* DummyTransmission function, as documented on 
- * http://bcm-specs.sipsolutions.net/DummyTransmission
- */
-void bcm43xx_dummy_transmission(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	unsigned int i, max_loop;
-	u16 value = 0;
-	u32 buffer[5] = {
-		0x00000000,
-		0x0000D400,
-		0x00000000,
-		0x00000001,
-		0x00000000,
-	};
-
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		max_loop = 0x1E;
-		buffer[0] = 0xCC010200;
-		break;
-	case BCM43xx_PHYTYPE_B:
-	case BCM43xx_PHYTYPE_G:
-		max_loop = 0xFA;
-		buffer[0] = 0x6E840B00; 
-		break;
-	default:
-		assert(0);
-		return;
-	}
-
-	for (i = 0; i < 5; i++)
-		bcm43xx_ram_write(bcm, i * 4, buffer[i]);
-
-	bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD); /* dummy read */
-
-	bcm43xx_write16(bcm, 0x0568, 0x0000);
-	bcm43xx_write16(bcm, 0x07C0, 0x0000);
-	bcm43xx_write16(bcm, 0x050C, ((phy->type == BCM43xx_PHYTYPE_A) ? 1 : 0));
-	bcm43xx_write16(bcm, 0x0508, 0x0000);
-	bcm43xx_write16(bcm, 0x050A, 0x0000);
-	bcm43xx_write16(bcm, 0x054C, 0x0000);
-	bcm43xx_write16(bcm, 0x056A, 0x0014);
-	bcm43xx_write16(bcm, 0x0568, 0x0826);
-	bcm43xx_write16(bcm, 0x0500, 0x0000);
-	bcm43xx_write16(bcm, 0x0502, 0x0030);
-
-	if (radio->version == 0x2050 && radio->revision <= 0x5)
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0017);
-	for (i = 0x00; i < max_loop; i++) {
-		value = bcm43xx_read16(bcm, 0x050E);
-		if (value & 0x0080)
-			break;
-		udelay(10);
-	}
-	for (i = 0x00; i < 0x0A; i++) {
-		value = bcm43xx_read16(bcm, 0x050E);
-		if (value & 0x0400)
-			break;
-		udelay(10);
-	}
-	for (i = 0x00; i < 0x0A; i++) {
-		value = bcm43xx_read16(bcm, 0x0690);
-		if (!(value & 0x0100))
-			break;
-		udelay(10);
-	}
-	if (radio->version == 0x2050 && radio->revision <= 0x5)
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0037);
-}
-
-static void key_write(struct bcm43xx_private *bcm,
-		      u8 index, u8 algorithm, const u16 *key)
-{
-	unsigned int i, basic_wep = 0;
-	u32 offset;
-	u16 value;
- 
-	/* Write associated key information */
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x100 + (index * 2),
-			    ((index << 4) | (algorithm & 0x0F)));
- 
-	/* The first 4 WEP keys need extra love */
-	if (((algorithm == BCM43xx_SEC_ALGO_WEP) ||
-	    (algorithm == BCM43xx_SEC_ALGO_WEP104)) && (index < 4))
-		basic_wep = 1;
- 
-	/* Write key payload, 8 little endian words */
-	offset = bcm->security_offset + (index * BCM43xx_SEC_KEYSIZE);
-	for (i = 0; i < (BCM43xx_SEC_KEYSIZE / sizeof(u16)); i++) {
-		value = cpu_to_le16(key[i]);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    offset + (i * 2), value);
- 
-		if (!basic_wep)
-			continue;
- 
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    offset + (i * 2) + 4 * BCM43xx_SEC_KEYSIZE,
-				    value);
-	}
-}
-
-static void keymac_write(struct bcm43xx_private *bcm,
-			 u8 index, const u32 *addr)
-{
-	/* for keys 0-3 there is no associated mac address */
-	if (index < 4)
-		return;
-
-	index -= 4;
-	if (bcm->current_core->rev >= 5) {
-		bcm43xx_shm_write32(bcm,
-				    BCM43xx_SHM_HWMAC,
-				    index * 2,
-				    cpu_to_be32(*addr));
-		bcm43xx_shm_write16(bcm,
-				    BCM43xx_SHM_HWMAC,
-				    (index * 2) + 1,
-				    cpu_to_be16(*((u16 *)(addr + 1))));
-	} else {
-		if (index < 8) {
-			TODO(); /* Put them in the macaddress filter */
-		} else {
-			TODO();
-			/* Put them BCM43xx_SHM_SHARED, stating index 0x0120.
-			   Keep in mind to update the count of keymacs in 0x003E as well! */
-		}
-	}
-}
-
-static int bcm43xx_key_write(struct bcm43xx_private *bcm,
-			     u8 index, u8 algorithm,
-			     const u8 *_key, int key_len,
-			     const u8 *mac_addr)
-{
-	u8 key[BCM43xx_SEC_KEYSIZE] = { 0 };
-
-	if (index >= ARRAY_SIZE(bcm->key))
-		return -EINVAL;
-	if (key_len > ARRAY_SIZE(key))
-		return -EINVAL;
-	if (algorithm < 1 || algorithm > 5)
-		return -EINVAL;
-
-	memcpy(key, _key, key_len);
-	key_write(bcm, index, algorithm, (const u16 *)key);
-	keymac_write(bcm, index, (const u32 *)mac_addr);
-
-	bcm->key[index].algorithm = algorithm;
-
-	return 0;
-}
-
-static void bcm43xx_clear_keys(struct bcm43xx_private *bcm)
-{
-	static const u32 zero_mac[2] = { 0 };
-	unsigned int i,j, nr_keys = 54;
-	u16 offset;
-
-	if (bcm->current_core->rev < 5)
-		nr_keys = 16;
-	assert(nr_keys <= ARRAY_SIZE(bcm->key));
-
-	for (i = 0; i < nr_keys; i++) {
-		bcm->key[i].enabled = 0;
-		/* returns for i < 4 immediately */
-		keymac_write(bcm, i, zero_mac);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    0x100 + (i * 2), 0x0000);
-		for (j = 0; j < 8; j++) {
-			offset = bcm->security_offset + (j * 4) + (i * BCM43xx_SEC_KEYSIZE);
-			bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-					    offset, 0x0000);
-		}
-	}
-	dprintk(KERN_INFO PFX "Keys cleared\n");
-}
-
-/* Lowlevel core-switch function. This is only to be used in
- * bcm43xx_switch_core() and bcm43xx_probe_cores()
- */
-static int _switch_core(struct bcm43xx_private *bcm, int core)
-{
-	int err;
-	int attempts = 0;
-	u32 current_core;
-
-	assert(core >= 0);
-	while (1) {
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_ACTIVE_CORE,
-						 (core * 0x1000) + 0x18000000);
-		if (unlikely(err))
-			goto error;
-		err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_ACTIVE_CORE,
-						&current_core);
-		if (unlikely(err))
-			goto error;
-		current_core = (current_core - 0x18000000) / 0x1000;
-		if (current_core == core)
-			break;
-
-		if (unlikely(attempts++ > BCM43xx_SWITCH_CORE_MAX_RETRIES))
-			goto error;
-		udelay(10);
-	}
-
-	return 0;
-error:
-	printk(KERN_ERR PFX "Failed to switch to core %d\n", core);
-	return -ENODEV;
-}
-
-int bcm43xx_switch_core(struct bcm43xx_private *bcm, struct bcm43xx_coreinfo *new_core)
-{
-	int err;
-
-	if (unlikely(!new_core))
-		return 0;
-	if (!new_core->available)
-		return -ENODEV;
-	if (bcm->current_core == new_core)
-		return 0;
-	err = _switch_core(bcm, new_core->index);
-	if (unlikely(err))
-		goto out;
-
-	bcm->current_core = new_core;
-out:
-	return err;
-}
-
-static int bcm43xx_core_enabled(struct bcm43xx_private *bcm)
-{
-	u32 value;
-
-	value = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	value &= BCM43xx_SBTMSTATELOW_CLOCK | BCM43xx_SBTMSTATELOW_RESET
-		 | BCM43xx_SBTMSTATELOW_REJECT;
-
-	return (value == BCM43xx_SBTMSTATELOW_CLOCK);
-}
-
-/* disable current core */
-static int bcm43xx_core_disable(struct bcm43xx_private *bcm, u32 core_flags)
-{
-	u32 sbtmstatelow;
-	u32 sbtmstatehigh;
-	int i;
-
-	/* fetch sbtmstatelow from core information registers */
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-
-	/* core is already in reset */
-	if (sbtmstatelow & BCM43xx_SBTMSTATELOW_RESET)
-		goto out;
-
-	if (sbtmstatelow & BCM43xx_SBTMSTATELOW_CLOCK) {
-		sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-			       BCM43xx_SBTMSTATELOW_REJECT;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-
-		for (i = 0; i < 1000; i++) {
-			sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-			if (sbtmstatelow & BCM43xx_SBTMSTATELOW_REJECT) {
-				i = -1;
-				break;
-			}
-			udelay(10);
-		}
-		if (i != -1) {
-			printk(KERN_ERR PFX "Error: core_disable() REJECT timeout!\n");
-			return -EBUSY;
-		}
-
-		for (i = 0; i < 1000; i++) {
-			sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-			if (!(sbtmstatehigh & BCM43xx_SBTMSTATEHIGH_BUSY)) {
-				i = -1;
-				break;
-			}
-			udelay(10);
-		}
-		if (i != -1) {
-			printk(KERN_ERR PFX "Error: core_disable() BUSY timeout!\n");
-			return -EBUSY;
-		}
-
-		sbtmstatelow = BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-			       BCM43xx_SBTMSTATELOW_REJECT |
-			       BCM43xx_SBTMSTATELOW_RESET |
-			       BCM43xx_SBTMSTATELOW_CLOCK |
-			       core_flags;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-		udelay(10);
-	}
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_RESET |
-		       BCM43xx_SBTMSTATELOW_REJECT |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-
-out:
-	bcm->current_core->enabled = 0;
-
-	return 0;
-}
-
-/* enable (reset) current core */
-static int bcm43xx_core_enable(struct bcm43xx_private *bcm, u32 core_flags)
-{
-	u32 sbtmstatelow;
-	u32 sbtmstatehigh;
-	u32 sbimstate;
-	int err;
-
-	err = bcm43xx_core_disable(bcm, core_flags);
-	if (err)
-		goto out;
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-		       BCM43xx_SBTMSTATELOW_RESET |
-		       BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-	if (sbtmstatehigh & BCM43xx_SBTMSTATEHIGH_SERROR) {
-		sbtmstatehigh = 0x00000000;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATEHIGH, sbtmstatehigh);
-	}
-
-	sbimstate = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMSTATE);
-	if (sbimstate & (BCM43xx_SBIMSTATE_IB_ERROR | BCM43xx_SBIMSTATE_TIMEOUT)) {
-		sbimstate &= ~(BCM43xx_SBIMSTATE_IB_ERROR | BCM43xx_SBIMSTATE_TIMEOUT);
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBIMSTATE, sbimstate);
-	}
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-		       BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK | core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	bcm->current_core->enabled = 1;
-	assert(err == 0);
-out:
-	return err;
-}
-
-/* http://bcm-specs.sipsolutions.net/80211CoreReset */
-void bcm43xx_wireless_core_reset(struct bcm43xx_private *bcm, int connect_phy)
-{
-	u32 flags = 0x00040000;
-
-	if ((bcm43xx_core_enabled(bcm)) &&
-	    !bcm43xx_using_pio(bcm)) {
-	}
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_SHUTTINGDOWN) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				& ~(BCM43xx_SBF_MAC_ENABLED | 0x00000002));
-	} else {
-		if (connect_phy)
-			flags |= BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_phy_connect(bcm, connect_phy);
-		bcm43xx_core_enable(bcm, flags);
-		bcm43xx_write16(bcm, 0x03E6, 0x0000);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-				bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				| BCM43xx_SBF_400);
-	}
-}
-
-static void bcm43xx_wireless_core_disable(struct bcm43xx_private *bcm)
-{
-	bcm43xx_radio_turn_off(bcm);
-	bcm43xx_write16(bcm, 0x03E6, 0x00F4);
-	bcm43xx_core_disable(bcm, 0);
-}
-
-/* Mark the current 80211 core inactive. */
-static void bcm43xx_wireless_core_mark_inactive(struct bcm43xx_private *bcm)
-{
-	u32 sbtmstatelow;
-
-	bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-	bcm43xx_radio_turn_off(bcm);
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	sbtmstatelow &= 0xDFF5FFFF;
-	sbtmstatelow |= 0x000A0000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	sbtmstatelow &= 0xFFF5FFFF;
-	sbtmstatelow |= 0x00080000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-}
-
-static void handle_irq_transmit_status(struct bcm43xx_private *bcm)
-{
-	u32 v0, v1;
-	u16 tmp;
-	struct bcm43xx_xmitstatus stat;
-
-	while (1) {
-		v0 = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_0);
-		if (!v0)
-			break;
-		v1 = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_1);
-
-		stat.cookie = (v0 >> 16) & 0x0000FFFF;
-		tmp = (u16)((v0 & 0xFFF0) | ((v0 & 0xF) >> 1));
-		stat.flags = tmp & 0xFF;
-		stat.cnt1 = (tmp & 0x0F00) >> 8;
-		stat.cnt2 = (tmp & 0xF000) >> 12;
-		stat.seq = (u16)(v1 & 0xFFFF);
-		stat.unknown = (u16)((v1 >> 16) & 0xFF);
-
-		bcm43xx_debugfs_log_txstat(bcm, &stat);
-
-		if (stat.flags & BCM43xx_TXSTAT_FLAG_AMPDU)
-			continue;
-		if (stat.flags & BCM43xx_TXSTAT_FLAG_INTER)
-			continue;
-
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_handle_xmitstatus(bcm, &stat);
-		else
-			bcm43xx_dma_handle_xmitstatus(bcm, &stat);
-	}
-}
-
-static void drain_txstatus_queue(struct bcm43xx_private *bcm)
-{
-	u32 dummy;
-
-	if (bcm->current_core->rev < 5)
-		return;
-	/* Read all entries from the microcode TXstatus FIFO
-	 * and throw them away.
-	 */
-	while (1) {
-		dummy = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_0);
-		if (!dummy)
-			break;
-		dummy = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_1);
-	}
-}
-
-static void bcm43xx_generate_noise_sample(struct bcm43xx_private *bcm)
-{
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x408, 0x7F7F);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x40A, 0x7F7F);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD) | (1 << 4));
-	assert(bcm->noisecalc.core_at_start == bcm->current_core);
-	assert(bcm->noisecalc.channel_at_start == bcm43xx_current_radio(bcm)->channel);
-}
-
-static void bcm43xx_calculate_link_quality(struct bcm43xx_private *bcm)
-{
-	/* Top half of Link Quality calculation. */
-
-	if (bcm->noisecalc.calculation_running)
-		return;
-	bcm->noisecalc.core_at_start = bcm->current_core;
-	bcm->noisecalc.channel_at_start = bcm43xx_current_radio(bcm)->channel;
-	bcm->noisecalc.calculation_running = 1;
-	bcm->noisecalc.nr_samples = 0;
-
-	bcm43xx_generate_noise_sample(bcm);
-}
-
-static void handle_irq_noise(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 tmp;
-	u8 noise[4];
-	u8 i, j;
-	s32 average;
-
-	/* Bottom half of Link Quality calculation. */
-
-	assert(bcm->noisecalc.calculation_running);
-	if (bcm->noisecalc.core_at_start != bcm->current_core ||
-	    bcm->noisecalc.channel_at_start != radio->channel)
-		goto drop_calculation;
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x408);
-	noise[0] = (tmp & 0x00FF);
-	noise[1] = (tmp & 0xFF00) >> 8;
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x40A);
-	noise[2] = (tmp & 0x00FF);
-	noise[3] = (tmp & 0xFF00) >> 8;
-	if (noise[0] == 0x7F || noise[1] == 0x7F ||
-	    noise[2] == 0x7F || noise[3] == 0x7F)
-		goto generate_new;
-
-	/* Get the noise samples. */
-	assert(bcm->noisecalc.nr_samples < 8);
-	i = bcm->noisecalc.nr_samples;
-	noise[0] = limit_value(noise[0], 0, ARRAY_SIZE(radio->nrssi_lt) - 1);
-	noise[1] = limit_value(noise[1], 0, ARRAY_SIZE(radio->nrssi_lt) - 1);
-	noise[2] = limit_value(noise[2], 0, ARRAY_SIZE(radio->nrssi_lt) - 1);
-	noise[3] = limit_value(noise[3], 0, ARRAY_SIZE(radio->nrssi_lt) - 1);
-	bcm->noisecalc.samples[i][0] = radio->nrssi_lt[noise[0]];
-	bcm->noisecalc.samples[i][1] = radio->nrssi_lt[noise[1]];
-	bcm->noisecalc.samples[i][2] = radio->nrssi_lt[noise[2]];
-	bcm->noisecalc.samples[i][3] = radio->nrssi_lt[noise[3]];
-	bcm->noisecalc.nr_samples++;
-	if (bcm->noisecalc.nr_samples == 8) {
-		/* Calculate the Link Quality by the noise samples. */
-		average = 0;
-		for (i = 0; i < 8; i++) {
-			for (j = 0; j < 4; j++)
-				average += bcm->noisecalc.samples[i][j];
-		}
-		average /= (8 * 4);
-		average *= 125;
-		average += 64;
-		average /= 128;
-
-		tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x40C);
-		tmp = (tmp / 128) & 0x1F;
-		if (tmp >= 8)
-			average += 2;
-		else
-			average -= 25;
-		if (tmp == 8)
-			average -= 72;
-		else
-			average -= 48;
-
-		bcm->stats.noise = average;
-drop_calculation:
-		bcm->noisecalc.calculation_running = 0;
-		return;
-	}
-generate_new:
-	bcm43xx_generate_noise_sample(bcm);
-}
-
-static void handle_irq_ps(struct bcm43xx_private *bcm)
-{
-	if (bcm->ieee->iw_mode == IW_MODE_MASTER) {
-		///TODO: PS TBTT
-	} else {
-		if (1/*FIXME: the last PSpoll frame was sent successfully */)
-			bcm43xx_power_saving_ctl_bits(bcm, -1, -1);
-	}
-	if (bcm->ieee->iw_mode == IW_MODE_ADHOC)
-		bcm->reg124_set_0x4 = 1;
-	//FIXME else set to false?
-}
-
-static void handle_irq_reg124(struct bcm43xx_private *bcm)
-{
-	if (!bcm->reg124_set_0x4)
-		return;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD)
-			| 0x4);
-	//FIXME: reset reg124_set_0x4 to false?
-}
-
-static void handle_irq_pmq(struct bcm43xx_private *bcm)
-{
-	u32 tmp;
-
-	//TODO: AP mode.
-
-	while (1) {
-		tmp = bcm43xx_read32(bcm, BCM43xx_MMIO_PS_STATUS);
-		if (!(tmp & 0x00000008))
-			break;
-	}
-	/* 16bit write is odd, but correct. */
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PS_STATUS, 0x0002);
-}
-
-static void bcm43xx_generate_beacon_template(struct bcm43xx_private *bcm,
-					     u16 ram_offset, u16 shm_size_offset)
-{
-	u32 value;
-	u16 size = 0;
-
-	/* Timestamp. */
-	//FIXME: assumption: The chip sets the timestamp
-	value = 0;
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	size += 8;
-
-	/* Beacon Interval / Capability Information */
-	value = 0x0000;//FIXME: Which interval?
-	value |= (1 << 0) << 16; /* ESS */
-	value |= (1 << 2) << 16; /* CF Pollable */	//FIXME?
-	value |= (1 << 3) << 16; /* CF Poll Request */	//FIXME?
-	if (!bcm->ieee->open_wep)
-		value |= (1 << 4) << 16; /* Privacy */
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	size += 4;
-
-	/* SSID */
-	//TODO
-
-	/* FH Parameter Set */
-	//TODO
-
-	/* DS Parameter Set */
-	//TODO
-
-	/* CF Parameter Set */
-	//TODO
-
-	/* TIM */
-	//TODO
-
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, shm_size_offset, size);
-}
-
-static void handle_irq_beacon(struct bcm43xx_private *bcm)
-{
-	u32 status;
-
-	bcm->irq_savedstate &= ~BCM43xx_IRQ_BEACON;
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD);
-
-	if ((status & 0x1) && (status & 0x2)) {
-		/* ACK beacon IRQ. */
-		bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON,
-				BCM43xx_IRQ_BEACON);
-		bcm->irq_savedstate |= BCM43xx_IRQ_BEACON;
-		return;
-	}
-	if (!(status & 0x1)) {
-		bcm43xx_generate_beacon_template(bcm, 0x68, 0x18);
-		status |= 0x1;
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD, status);
-	}
-	if (!(status & 0x2)) {
-		bcm43xx_generate_beacon_template(bcm, 0x468, 0x1A);
-		status |= 0x2;
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD, status);
-	}
-}
-
-/* Interrupt handler bottom-half */
-static void bcm43xx_interrupt_tasklet(struct bcm43xx_private *bcm)
-{
-	u32 reason;
-	u32 dma_reason[6];
-	u32 merged_dma_reason = 0;
-	int i, activity = 0;
-	unsigned long flags;
-
-#ifdef CONFIG_BCM43XX_DEBUG
-	u32 _handled = 0x00000000;
-# define bcmirq_handled(irq)	do { _handled |= (irq); } while (0)
-#else
-# define bcmirq_handled(irq)	do { /* nothing */ } while (0)
-#endif /* CONFIG_BCM43XX_DEBUG*/
-
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	reason = bcm->irq_reason;
-	for (i = 5; i >= 0; i--) {
-		dma_reason[i] = bcm->dma_reason[i];
-		merged_dma_reason |= dma_reason[i];
-	}
-
-	if (unlikely(reason & BCM43xx_IRQ_XMIT_ERROR)) {
-		/* TX error. We get this when Template Ram is written in wrong endianess
-		 * in dummy_tx(). We also get this if something is wrong with the TX header
-		 * on DMA or PIO queues.
-		 * Maybe we get this in other error conditions, too.
-		 */
-		printkl(KERN_ERR PFX "FATAL ERROR: BCM43xx_IRQ_XMIT_ERROR\n");
-		bcmirq_handled(BCM43xx_IRQ_XMIT_ERROR);
-	}
-	if (unlikely(merged_dma_reason & BCM43xx_DMAIRQ_FATALMASK)) {
-		printkl(KERN_ERR PFX "FATAL ERROR: Fatal DMA error: "
-				     "0x%08X, 0x%08X, 0x%08X, "
-				     "0x%08X, 0x%08X, 0x%08X\n",
-		        dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3],
-			dma_reason[4], dma_reason[5]);
-		bcm43xx_controller_restart(bcm, "DMA error");
-		mmiowb();
-		spin_unlock_irqrestore(&bcm->irq_lock, flags);
-		return;
-	}
-	if (unlikely(merged_dma_reason & BCM43xx_DMAIRQ_NONFATALMASK)) {
-		printkl(KERN_ERR PFX "DMA error: "
-				     "0x%08X, 0x%08X, 0x%08X, "
-				     "0x%08X, 0x%08X, 0x%08X\n",
-		        dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3],
-			dma_reason[4], dma_reason[5]);
-	}
-
-	if (reason & BCM43xx_IRQ_PS) {
-		handle_irq_ps(bcm);
-		bcmirq_handled(BCM43xx_IRQ_PS);
-	}
-
-	if (reason & BCM43xx_IRQ_REG124) {
-		handle_irq_reg124(bcm);
-		bcmirq_handled(BCM43xx_IRQ_REG124);
-	}
-
-	if (reason & BCM43xx_IRQ_BEACON) {
-		if (bcm->ieee->iw_mode == IW_MODE_MASTER)
-			handle_irq_beacon(bcm);
-		bcmirq_handled(BCM43xx_IRQ_BEACON);
-	}
-
-	if (reason & BCM43xx_IRQ_PMQ) {
-		handle_irq_pmq(bcm);
-		bcmirq_handled(BCM43xx_IRQ_PMQ);
-	}
-
-	if (reason & BCM43xx_IRQ_SCAN) {
-		/*TODO*/
-		//bcmirq_handled(BCM43xx_IRQ_SCAN);
-	}
-
-	if (reason & BCM43xx_IRQ_NOISE) {
-		handle_irq_noise(bcm);
-		bcmirq_handled(BCM43xx_IRQ_NOISE);
-	}
-
-	/* Check the DMA reason registers for received data. */
-	if (dma_reason[0] & BCM43xx_DMAIRQ_RX_DONE) {
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_rx(bcm43xx_current_pio(bcm)->queue0);
-		else
-			bcm43xx_dma_rx(bcm43xx_current_dma(bcm)->rx_ring0);
-		/* We intentionally don't set "activity" to 1, here. */
-	}
-	assert(!(dma_reason[1] & BCM43xx_DMAIRQ_RX_DONE));
-	assert(!(dma_reason[2] & BCM43xx_DMAIRQ_RX_DONE));
-	if (dma_reason[3] & BCM43xx_DMAIRQ_RX_DONE) {
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_rx(bcm43xx_current_pio(bcm)->queue3);
-		else
-			bcm43xx_dma_rx(bcm43xx_current_dma(bcm)->rx_ring3);
-		activity = 1;
-	}
-	assert(!(dma_reason[4] & BCM43xx_DMAIRQ_RX_DONE));
-	assert(!(dma_reason[5] & BCM43xx_DMAIRQ_RX_DONE));
-	bcmirq_handled(BCM43xx_IRQ_RX);
-
-	if (reason & BCM43xx_IRQ_XMIT_STATUS) {
-		handle_irq_transmit_status(bcm);
-		activity = 1;
-		//TODO: In AP mode, this also causes sending of powersave responses.
-		bcmirq_handled(BCM43xx_IRQ_XMIT_STATUS);
-	}
-
-	/* IRQ_PIO_WORKAROUND is handled in the top-half. */
-	bcmirq_handled(BCM43xx_IRQ_PIO_WORKAROUND);
-#ifdef CONFIG_BCM43XX_DEBUG
-	if (unlikely(reason & ~_handled)) {
-		printkl(KERN_WARNING PFX
-			"Unhandled IRQ! Reason: 0x%08x,  Unhandled: 0x%08x,  "
-			"DMA: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
-			reason, (reason & ~_handled),
-			dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3]);
-	}
-#endif
-#undef bcmirq_handled
-
-	if (!modparam_noleds)
-		bcm43xx_leds_update(bcm, activity);
-	bcm43xx_interrupt_enable(bcm, bcm->irq_savedstate);
-	mmiowb();
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-}
-
-static void pio_irq_workaround(struct bcm43xx_private *bcm,
-			       u16 base, int queueidx)
-{
-	u16 rxctl;
-
-	rxctl = bcm43xx_read16(bcm, base + BCM43xx_PIO_RXCTL);
-	if (rxctl & BCM43xx_PIO_RXCTL_DATAAVAILABLE)
-		bcm->dma_reason[queueidx] |= BCM43xx_DMAIRQ_RX_DONE;
-	else
-		bcm->dma_reason[queueidx] &= ~BCM43xx_DMAIRQ_RX_DONE;
-}
-
-static void bcm43xx_interrupt_ack(struct bcm43xx_private *bcm, u32 reason)
-{
-	if (bcm43xx_using_pio(bcm) &&
-	    (bcm->current_core->rev < 3) &&
-	    (!(reason & BCM43xx_IRQ_PIO_WORKAROUND))) {
-		/* Apply a PIO specific workaround to the dma_reasons */
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO1_BASE, 0);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO2_BASE, 1);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO3_BASE, 2);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO4_BASE, 3);
-	}
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, reason);
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA0_REASON,
-			bcm->dma_reason[0]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA1_REASON,
-			bcm->dma_reason[1]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA2_REASON,
-			bcm->dma_reason[2]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA3_REASON,
-			bcm->dma_reason[3]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA4_REASON,
-			bcm->dma_reason[4]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA5_REASON,
-			bcm->dma_reason[5]);
-}
-
-/* Interrupt handler top-half */
-static irqreturn_t bcm43xx_interrupt_handler(int irq, void *dev_id)
-{
-	irqreturn_t ret = IRQ_HANDLED;
-	struct bcm43xx_private *bcm = dev_id;
-	u32 reason;
-
-	if (!bcm)
-		return IRQ_NONE;
-
-	spin_lock(&bcm->irq_lock);
-
-	reason = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-	if (reason == 0xffffffff) {
-		/* irq not for us (shared irq) */
-		ret = IRQ_NONE;
-		goto out;
-	}
-	reason &= bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
-	if (!reason)
-		goto out;
-
-	assert(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED);
-	assert(bcm->current_core->id == BCM43xx_COREID_80211);
-
-	bcm->dma_reason[0] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA0_REASON)
-			     & 0x0001DC00;
-	bcm->dma_reason[1] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA1_REASON)
-			     & 0x0000DC00;
-	bcm->dma_reason[2] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA2_REASON)
-			     & 0x0000DC00;
-	bcm->dma_reason[3] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA3_REASON)
-			     & 0x0001DC00;
-	bcm->dma_reason[4] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA4_REASON)
-			     & 0x0000DC00;
-	bcm->dma_reason[5] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA5_REASON)
-			     & 0x0000DC00;
-
-	bcm43xx_interrupt_ack(bcm, reason);
-
-	/* disable all IRQs. They are enabled again in the bottom half. */
-	bcm->irq_savedstate = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-	/* save the reason code and call our bottom half. */
-	bcm->irq_reason = reason;
-	tasklet_schedule(&bcm->isr_tasklet);
-
-out:
-	mmiowb();
-	spin_unlock(&bcm->irq_lock);
-
-	return ret;
-}
-
-static void bcm43xx_release_firmware(struct bcm43xx_private *bcm, int force)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	if (bcm->firmware_norelease && !force)
-		return; /* Suspending or controller reset. */
-	release_firmware(phy->ucode);
-	phy->ucode = NULL;
-	release_firmware(phy->pcm);
-	phy->pcm = NULL;
-	release_firmware(phy->initvals0);
-	phy->initvals0 = NULL;
-	release_firmware(phy->initvals1);
-	phy->initvals1 = NULL;
-}
-
-static int bcm43xx_request_firmware(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u8 rev = bcm->current_core->rev;
-	int err = 0;
-	int nr;
-	char buf[22 + sizeof(modparam_fwpostfix) - 1] = { 0 };
-
-	if (!phy->ucode) {
-		snprintf(buf, ARRAY_SIZE(buf), "bcm43xx_microcode%d%s.fw",
-			 (rev >= 5 ? 5 : rev),
-			 modparam_fwpostfix);
-		err = request_firmware(&phy->ucode, buf, &bcm->pci_dev->dev);
-		if (err) {
-			printk(KERN_ERR PFX 
-			       "Error: Microcode \"%s\" not available or load failed.\n",
-			        buf);
-			goto error;
-		}
-	}
-
-	if (!phy->pcm) {
-		snprintf(buf, ARRAY_SIZE(buf),
-			 "bcm43xx_pcm%d%s.fw",
-			 (rev < 5 ? 4 : 5),
-			 modparam_fwpostfix);
-		err = request_firmware(&phy->pcm, buf, &bcm->pci_dev->dev);
-		if (err) {
-			printk(KERN_ERR PFX
-			       "Error: PCM \"%s\" not available or load failed.\n",
-			       buf);
-			goto error;
-		}
-	}
-
-	if (!phy->initvals0) {
-		if (rev == 2 || rev == 4) {
-			switch (phy->type) {
-			case BCM43xx_PHYTYPE_A:
-				nr = 3;
-				break;
-			case BCM43xx_PHYTYPE_B:
-			case BCM43xx_PHYTYPE_G:
-				nr = 1;
-				break;
-			default:
-				goto err_noinitval;
-			}
-		
-		} else if (rev >= 5) {
-			switch (phy->type) {
-			case BCM43xx_PHYTYPE_A:
-				nr = 7;
-				break;
-			case BCM43xx_PHYTYPE_B:
-			case BCM43xx_PHYTYPE_G:
-				nr = 5;
-				break;
-			default:
-				goto err_noinitval;
-			}
-		} else
-			goto err_noinitval;
-		snprintf(buf, ARRAY_SIZE(buf), "bcm43xx_initval%02d%s.fw",
-			 nr, modparam_fwpostfix);
-
-		err = request_firmware(&phy->initvals0, buf, &bcm->pci_dev->dev);
-		if (err) {
-			printk(KERN_ERR PFX 
-			       "Error: InitVals \"%s\" not available or load failed.\n",
-			        buf);
-			goto error;
-		}
-		if (phy->initvals0->size % sizeof(struct bcm43xx_initval)) {
-			printk(KERN_ERR PFX "InitVals fileformat error.\n");
-			goto error;
-		}
-	}
-
-	if (!phy->initvals1) {
-		if (rev >= 5) {
-			u32 sbtmstatehigh;
-
-			switch (phy->type) {
-			case BCM43xx_PHYTYPE_A:
-				sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-				if (sbtmstatehigh & 0x00010000)
-					nr = 9;
-				else
-					nr = 10;
-				break;
-			case BCM43xx_PHYTYPE_B:
-			case BCM43xx_PHYTYPE_G:
-					nr = 6;
-				break;
-			default:
-				goto err_noinitval;
-			}
-			snprintf(buf, ARRAY_SIZE(buf), "bcm43xx_initval%02d%s.fw",
-				 nr, modparam_fwpostfix);
-
-			err = request_firmware(&phy->initvals1, buf, &bcm->pci_dev->dev);
-			if (err) {
-				printk(KERN_ERR PFX 
-				       "Error: InitVals \"%s\" not available or load failed.\n",
-			        	buf);
-				goto error;
-			}
-			if (phy->initvals1->size % sizeof(struct bcm43xx_initval)) {
-				printk(KERN_ERR PFX "InitVals fileformat error.\n");
-				goto error;
-			}
-		}
-	}
-
-out:
-	return err;
-error:
-	bcm43xx_release_firmware(bcm, 1);
-	goto out;
-err_noinitval:
-	printk(KERN_ERR PFX "Error: No InitVals available!\n");
-	err = -ENOENT;
-	goto error;
-}
-
-static void bcm43xx_upload_microcode(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	const u32 *data;
-	unsigned int i, len;
-
-	/* Upload Microcode. */
-	data = (u32 *)(phy->ucode->data);
-	len = phy->ucode->size / sizeof(u32);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_UCODE, 0x0000);
-	for (i = 0; i < len; i++) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA,
-				be32_to_cpu(data[i]));
-		udelay(10);
-	}
-
-	/* Upload PCM data. */
-	data = (u32 *)(phy->pcm->data);
-	len = phy->pcm->size / sizeof(u32);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_PCM, 0x01ea);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA, 0x00004000);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_PCM, 0x01eb);
-	for (i = 0; i < len; i++) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA,
-				be32_to_cpu(data[i]));
-		udelay(10);
-	}
-}
-
-static int bcm43xx_write_initvals(struct bcm43xx_private *bcm,
-				  const struct bcm43xx_initval *data,
-				  const unsigned int len)
-{
-	u16 offset, size;
-	u32 value;
-	unsigned int i;
-
-	for (i = 0; i < len; i++) {
-		offset = be16_to_cpu(data[i].offset);
-		size = be16_to_cpu(data[i].size);
-		value = be32_to_cpu(data[i].value);
-
-		if (unlikely(offset >= 0x1000))
-			goto err_format;
-		if (size == 2) {
-			if (unlikely(value & 0xFFFF0000))
-				goto err_format;
-			bcm43xx_write16(bcm, offset, (u16)value);
-		} else if (size == 4) {
-			bcm43xx_write32(bcm, offset, value);
-		} else
-			goto err_format;
-	}
-
-	return 0;
-
-err_format:
-	printk(KERN_ERR PFX "InitVals (bcm43xx_initvalXX.fw) file-format error. "
-			    "Please fix your bcm43xx firmware files.\n");
-	return -EPROTO;
-}
-
-static int bcm43xx_upload_initvals(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	int err;
-
-	err = bcm43xx_write_initvals(bcm, (struct bcm43xx_initval *)phy->initvals0->data,
-				     phy->initvals0->size / sizeof(struct bcm43xx_initval));
-	if (err)
-		goto out;
-	if (phy->initvals1) {
-		err = bcm43xx_write_initvals(bcm, (struct bcm43xx_initval *)phy->initvals1->data,
-					     phy->initvals1->size / sizeof(struct bcm43xx_initval));
-		if (err)
-			goto out;
-	}
-out:
-	return err;
-}
-
-static int bcm43xx_initialize_irq(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	bcm->irq = bcm->pci_dev->irq;
-	err = request_irq(bcm->irq, bcm43xx_interrupt_handler,
-			  IRQF_SHARED, KBUILD_MODNAME, bcm);
-	if (err)
-		printk(KERN_ERR PFX "Cannot register IRQ%d\n", bcm->irq);
-
-	return err;
-}
-
-/* Switch to the core used to write the GPIO register.
- * This is either the ChipCommon, or the PCI core.
- */
-static int switch_to_gpio_core(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	/* Where to find the GPIO register depends on the chipset.
-	 * If it has a ChipCommon, its register at offset 0x6c is the GPIO
-	 * control register. Otherwise the register at offset 0x6c in the
-	 * PCI core is the GPIO control register.
-	 */
-	err = bcm43xx_switch_core(bcm, &bcm->core_chipcommon);
-	if (err == -ENODEV) {
-		err = bcm43xx_switch_core(bcm, &bcm->core_pci);
-		if (unlikely(err == -ENODEV)) {
-			printk(KERN_ERR PFX "gpio error: "
-			       "Neither ChipCommon nor PCI core available!\n");
-		}
-	}
-
-	return err;
-}
-
-/* Initialize the GPIOs
- * http://bcm-specs.sipsolutions.net/GPIO
- */
-static int bcm43xx_gpio_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_coreinfo *old_core;
-	int err;
-	u32 mask, set;
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-			& 0xFFFF3FFF);
-
-	bcm43xx_leds_switch_all(bcm, 0);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-			bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK) | 0x000F);
-
-	mask = 0x0000001F;
-	set = 0x0000000F;
-	if (bcm->chip_id == 0x4301) {
-		mask |= 0x0060;
-		set |= 0x0060;
-	}
-	if (0 /* FIXME: conditional unknown */) {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-				bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK)
-				| 0x0100);
-		mask |= 0x0180;
-		set |= 0x0180;
-	}
-	if (bcm->sprom.boardflags & BCM43xx_BFL_PACTRL) {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-				bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK)
-				| 0x0200);
-		mask |= 0x0200;
-		set |= 0x0200;
-	}
-	if (bcm->current_core->rev >= 2)
-		mask  |= 0x0010; /* FIXME: This is redundant. */
-
-	old_core = bcm->current_core;
-	err = switch_to_gpio_core(bcm);
-	if (err)
-		goto out;
-	bcm43xx_write32(bcm, BCM43xx_GPIO_CONTROL,
-	                (bcm43xx_read32(bcm, BCM43xx_GPIO_CONTROL) & mask) | set);
-	err = bcm43xx_switch_core(bcm, old_core);
-out:
-	return err;
-}
-
-/* Turn off all GPIO stuff. Call this on module unload, for example. */
-static int bcm43xx_gpio_cleanup(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_coreinfo *old_core;
-	int err;
-
-	old_core = bcm->current_core;
-	err = switch_to_gpio_core(bcm);
-	if (err)
-		return err;
-	bcm43xx_write32(bcm, BCM43xx_GPIO_CONTROL, 0x00000000);
-	err = bcm43xx_switch_core(bcm, old_core);
-	assert(err == 0);
-
-	return 0;
-}
-
-/* http://bcm-specs.sipsolutions.net/EnableMac */
-void bcm43xx_mac_enable(struct bcm43xx_private *bcm)
-{
-	bcm->mac_suspended--;
-	assert(bcm->mac_suspended >= 0);
-	if (bcm->mac_suspended == 0) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				| BCM43xx_SBF_MAC_ENABLED);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, BCM43xx_IRQ_READY);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD); /* dummy read */
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-		bcm43xx_power_saving_ctl_bits(bcm, -1, -1);
-	}
-}
-
-/* http://bcm-specs.sipsolutions.net/SuspendMAC */
-void bcm43xx_mac_suspend(struct bcm43xx_private *bcm)
-{
-	int i;
-	u32 tmp;
-
-	assert(bcm->mac_suspended >= 0);
-	if (bcm->mac_suspended == 0) {
-		bcm43xx_power_saving_ctl_bits(bcm, -1, 1);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				& ~BCM43xx_SBF_MAC_ENABLED);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-		for (i = 10000; i; i--) {
-			tmp = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-			if (tmp & BCM43xx_IRQ_READY)
-				goto out;
-			udelay(1);
-		}
-		printkl(KERN_ERR PFX "MAC suspend failed\n");
-	}
-out:
-	bcm->mac_suspended++;
-}
-
-void bcm43xx_set_iwmode(struct bcm43xx_private *bcm,
-			int iw_mode)
-{
-	unsigned long flags;
-	struct net_device *net_dev = bcm->net_dev;
-	u32 status;
-	u16 value;
-
-	spin_lock_irqsave(&bcm->ieee->lock, flags);
-	bcm->ieee->iw_mode = iw_mode;
-	spin_unlock_irqrestore(&bcm->ieee->lock, flags);
-	if (iw_mode == IW_MODE_MONITOR)
-		net_dev->type = ARPHRD_IEEE80211;
-	else
-		net_dev->type = ARPHRD_ETHER;
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	/* Reset status to infrastructured mode */
-	status &= ~(BCM43xx_SBF_MODE_AP | BCM43xx_SBF_MODE_MONITOR);
-	status &= ~BCM43xx_SBF_MODE_PROMISC;
-	status |= BCM43xx_SBF_MODE_NOTADHOC;
-
-/* FIXME: Always enable promisc mode, until we get the MAC filters working correctly. */
-status |= BCM43xx_SBF_MODE_PROMISC;
-
-	switch (iw_mode) {
-	case IW_MODE_MONITOR:
-		status |= BCM43xx_SBF_MODE_MONITOR;
-		status |= BCM43xx_SBF_MODE_PROMISC;
-		break;
-	case IW_MODE_ADHOC:
-		status &= ~BCM43xx_SBF_MODE_NOTADHOC;
-		break;
-	case IW_MODE_MASTER:
-		status |= BCM43xx_SBF_MODE_AP;
-		break;
-	case IW_MODE_SECOND:
-	case IW_MODE_REPEAT:
-		TODO(); /* TODO */
-		break;
-	case IW_MODE_INFRA:
-		/* nothing to be done here... */
-		break;
-	default:
-		dprintk(KERN_ERR PFX "Unknown mode in set_iwmode: %d\n", iw_mode);
-	}
-	if (net_dev->flags & IFF_PROMISC)
-		status |= BCM43xx_SBF_MODE_PROMISC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-
-	value = 0x0002;
-	if (iw_mode != IW_MODE_ADHOC && iw_mode != IW_MODE_MASTER) {
-		if (bcm->chip_id == 0x4306 && bcm->chip_rev == 3)
-			value = 0x0064;
-		else
-			value = 0x0032;
-	}
-	bcm43xx_write16(bcm, 0x0612, value);
-}
-
-/* This is the opposite of bcm43xx_chip_init() */
-static void bcm43xx_chip_cleanup(struct bcm43xx_private *bcm)
-{
-	bcm43xx_radio_turn_off(bcm);
-	if (!modparam_noleds)
-		bcm43xx_leds_exit(bcm);
-	bcm43xx_gpio_cleanup(bcm);
-	bcm43xx_release_firmware(bcm, 0);
-}
-
-/* Initialize the chip
- * http://bcm-specs.sipsolutions.net/ChipInit
- */
-static int bcm43xx_chip_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	int err;
-	int i, tmp;
-	u32 value32;
-	u16 value16;
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-			BCM43xx_SBF_CORE_READY
-			| BCM43xx_SBF_400);
-
-	err = bcm43xx_request_firmware(bcm);
-	if (err)
-		goto out;
-	bcm43xx_upload_microcode(bcm);
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, 0xFFFFFFFF);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, 0x00020402);
-	i = 0;
-	while (1) {
-		value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-		if (value32 == BCM43xx_IRQ_READY)
-			break;
-		i++;
-		if (i >= BCM43xx_IRQWAIT_MAX_RETRIES) {
-			printk(KERN_ERR PFX "IRQ_READY timeout\n");
-			err = -ENODEV;
-			goto err_release_fw;
-		}
-		udelay(10);
-	}
-	bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-
-	value16 = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				     BCM43xx_UCODE_REVISION);
-
-	dprintk(KERN_INFO PFX "Microcode rev 0x%x, pl 0x%x "
-		"(20%.2i-%.2i-%.2i  %.2i:%.2i:%.2i)\n", value16,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_PATCHLEVEL),
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODE_DATE) >> 12) & 0xf,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODE_DATE) >> 8) & 0xf,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_DATE) & 0xff,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) >> 11) & 0x1f,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) >> 5) & 0x3f,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) & 0x1f);
-
-	if ( value16 > 0x128 ) {
-		printk(KERN_ERR PFX
-			"Firmware: no support for microcode extracted "
-			"from version 4.x binary drivers.\n");
-		err = -EOPNOTSUPP;
-		goto err_release_fw;
-	}
-
-	err = bcm43xx_gpio_init(bcm);
-	if (err)
-		goto err_release_fw;
-
-	err = bcm43xx_upload_initvals(bcm);
-	if (err)
-		goto err_gpio_cleanup;
-	bcm43xx_radio_turn_on(bcm);
-	bcm->radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
-	printk(KERN_INFO PFX "Radio %s by hardware\n",
-		(bcm->radio_hw_enable == 0) ? "disabled" : "enabled");
-
-	bcm43xx_write16(bcm, 0x03E6, 0x0000);
-	err = bcm43xx_phy_init(bcm);
-	if (err)
-		goto err_radio_off;
-
-	/* Select initial Interference Mitigation. */
-	tmp = radio->interfmode;
-	radio->interfmode = BCM43xx_RADIO_INTERFMODE_NONE;
-	bcm43xx_radio_set_interference_mitigation(bcm, tmp);
-
-	bcm43xx_phy_set_antenna_diversity(bcm);
-	bcm43xx_radio_set_txantenna(bcm, BCM43xx_RADIO_TXANTENNA_DEFAULT);
-	if (phy->type == BCM43xx_PHYTYPE_B) {
-		value16 = bcm43xx_read16(bcm, 0x005E);
-		value16 |= 0x0004;
-		bcm43xx_write16(bcm, 0x005E, value16);
-	}
-	bcm43xx_write32(bcm, 0x0100, 0x01000000);
-	if (bcm->current_core->rev < 5)
-		bcm43xx_write32(bcm, 0x010C, 0x01000000);
-
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	value32 &= ~ BCM43xx_SBF_MODE_NOTADHOC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	value32 |= BCM43xx_SBF_MODE_NOTADHOC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
-
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	value32 |= 0x100000;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
-
-	if (bcm43xx_using_pio(bcm)) {
-		bcm43xx_write32(bcm, 0x0210, 0x00000100);
-		bcm43xx_write32(bcm, 0x0230, 0x00000100);
-		bcm43xx_write32(bcm, 0x0250, 0x00000100);
-		bcm43xx_write32(bcm, 0x0270, 0x00000100);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0034, 0x0000);
-	}
-
-	/* Probe Response Timeout value */
-	/* FIXME: Default to 0, has to be set by ioctl probably... :-/ */
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0074, 0x0000);
-
-	/* Initially set the wireless operation mode. */
-	bcm43xx_set_iwmode(bcm, bcm->ieee->iw_mode);
-
-	if (bcm->current_core->rev < 3) {
-		bcm43xx_write16(bcm, 0x060E, 0x0000);
-		bcm43xx_write16(bcm, 0x0610, 0x8000);
-		bcm43xx_write16(bcm, 0x0604, 0x0000);
-		bcm43xx_write16(bcm, 0x0606, 0x0200);
-	} else {
-		bcm43xx_write32(bcm, 0x0188, 0x80000000);
-		bcm43xx_write32(bcm, 0x018C, 0x02000000);
-	}
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, 0x00004000);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA0_IRQ_MASK, 0x0001DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA1_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA2_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA3_IRQ_MASK, 0x0001DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA4_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA5_IRQ_MASK, 0x0000DC00);
-
-	value32 = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	value32 |= 0x00100000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, value32);
-
-	bcm43xx_write16(bcm, BCM43xx_MMIO_POWERUP_DELAY, bcm43xx_pctl_powerup_delay(bcm));
-
-	assert(err == 0);
-	dprintk(KERN_INFO PFX "Chip initialized\n");
-out:
-	return err;
-
-err_radio_off:
-	bcm43xx_radio_turn_off(bcm);
-err_gpio_cleanup:
-	bcm43xx_gpio_cleanup(bcm);
-err_release_fw:
-	bcm43xx_release_firmware(bcm, 1);
-	goto out;
-}
-	
-/* Validate chip access
- * http://bcm-specs.sipsolutions.net/ValidateChipAccess */
-static int bcm43xx_validate_chip(struct bcm43xx_private *bcm)
-{
-	u32 value;
-	u32 shm_backup;
-
-	shm_backup = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, 0xAA5555AA);
-	if (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000) != 0xAA5555AA)
-		goto error;
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, 0x55AAAA55);
-	if (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000) != 0x55AAAA55)
-		goto error;
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, shm_backup);
-
-	value = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	if ((value | 0x80000000) != 0x80000400)
-		goto error;
-
-	value = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-	if (value != 0x00000000)
-		goto error;
-
-	return 0;
-error:
-	printk(KERN_ERR PFX "Failed to validate the chipaccess\n");
-	return -ENODEV;
-}
-
-static void bcm43xx_init_struct_phyinfo(struct bcm43xx_phyinfo *phy)
-{
-	/* Initialize a "phyinfo" structure. The structure is already
-	 * zeroed out.
-	 * This is called on insmod time to initialize members.
-	 */
-	phy->savedpctlreg = 0xFFFF;
-	spin_lock_init(&phy->lock);
-}
-
-static void bcm43xx_init_struct_radioinfo(struct bcm43xx_radioinfo *radio)
-{
-	/* Initialize a "radioinfo" structure. The structure is already
-	 * zeroed out.
-	 * This is called on insmod time to initialize members.
-	 */
-	radio->interfmode = BCM43xx_RADIO_INTERFMODE_NONE;
-	radio->channel = 0xFF;
-	radio->initial_channel = 0xFF;
-}
-
-static int bcm43xx_probe_cores(struct bcm43xx_private *bcm)
-{
-	int err, i;
-	int current_core;
-	u32 core_vendor, core_id, core_rev;
-	u32 sb_id_hi, chip_id_32 = 0;
-	u16 pci_device, chip_id_16;
-	u8 core_count;
-
-	memset(&bcm->core_chipcommon, 0, sizeof(struct bcm43xx_coreinfo));
-	memset(&bcm->core_pci, 0, sizeof(struct bcm43xx_coreinfo));
-	memset(&bcm->core_80211, 0, sizeof(struct bcm43xx_coreinfo)
-				    * BCM43xx_MAX_80211_CORES);
-	memset(&bcm->core_80211_ext, 0, sizeof(struct bcm43xx_coreinfo_80211)
-					* BCM43xx_MAX_80211_CORES);
-	bcm->nr_80211_available = 0;
-	bcm->current_core = NULL;
-	bcm->active_80211_core = NULL;
-
-	/* map core 0 */
-	err = _switch_core(bcm, 0);
-	if (err)
-		goto out;
-
-	/* fetch sb_id_hi from core information registers */
-	sb_id_hi = bcm43xx_read32(bcm, BCM43xx_CIR_SB_ID_HI);
-
-	core_id = (sb_id_hi & 0x8FF0) >> 4;
-	core_rev = (sb_id_hi & 0x7000) >> 8;
-	core_rev |= (sb_id_hi & 0xF);
-	core_vendor = (sb_id_hi & 0xFFFF0000) >> 16;
-
-	/* if present, chipcommon is always core 0; read the chipid from it */
-	if (core_id == BCM43xx_COREID_CHIPCOMMON) {
-		chip_id_32 = bcm43xx_read32(bcm, 0);
-		chip_id_16 = chip_id_32 & 0xFFFF;
-		bcm->core_chipcommon.available = 1;
-		bcm->core_chipcommon.id = core_id;
-		bcm->core_chipcommon.rev = core_rev;
-		bcm->core_chipcommon.index = 0;
-		/* While we are at it, also read the capabilities. */
-		bcm->chipcommon_capabilities = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_CAPABILITIES);
-	} else {
-		/* without a chipCommon, use a hard coded table. */
-		pci_device = bcm->pci_dev->device;
-		if (pci_device == 0x4301)
-			chip_id_16 = 0x4301;
-		else if ((pci_device >= 0x4305) && (pci_device <= 0x4307))
-			chip_id_16 = 0x4307;
-		else if ((pci_device >= 0x4402) && (pci_device <= 0x4403))
-			chip_id_16 = 0x4402;
-		else if ((pci_device >= 0x4610) && (pci_device <= 0x4615))
-			chip_id_16 = 0x4610;
-		else if ((pci_device >= 0x4710) && (pci_device <= 0x4715))
-			chip_id_16 = 0x4710;
-		else {
-			printk(KERN_ERR PFX "Could not determine Chip ID\n");
-			return -ENODEV;
-		}
-	}
-
-	/* ChipCommon with Core Rev >=4 encodes number of cores,
-	 * otherwise consult hardcoded table */
-	if ((core_id == BCM43xx_COREID_CHIPCOMMON) && (core_rev >= 4)) {
-		core_count = (chip_id_32 & 0x0F000000) >> 24;
-	} else {
-		switch (chip_id_16) {
-			case 0x4610:
-			case 0x4704:
-			case 0x4710:
-				core_count = 9;
-				break;
-			case 0x4310:
-				core_count = 8;
-				break;
-			case 0x5365:
-				core_count = 7;
-				break;
-			case 0x4306:
-				core_count = 6;
-				break;
-			case 0x4301:
-			case 0x4307:
-				core_count = 5;
-				break;
-			case 0x4402:
-				core_count = 3;
-				break;
-			default:
-				/* SOL if we get here */
-				assert(0);
-				core_count = 1;
-		}
-	}
-
-	bcm->chip_id = chip_id_16;
-	bcm->chip_rev = (chip_id_32 & 0x000F0000) >> 16;
-	bcm->chip_package = (chip_id_32 & 0x00F00000) >> 20;
-
-	dprintk(KERN_INFO PFX "Chip ID 0x%x, rev 0x%x\n",
-		bcm->chip_id, bcm->chip_rev);
-	dprintk(KERN_INFO PFX "Number of cores: %d\n", core_count);
-	if (bcm->core_chipcommon.available) {
-		dprintk(KERN_INFO PFX "Core 0: ID 0x%x, rev 0x%x, vendor 0x%x\n",
-			core_id, core_rev, core_vendor);
-		current_core = 1;
-	} else
-		current_core = 0;
-	for ( ; current_core < core_count; current_core++) {
-		struct bcm43xx_coreinfo *core;
-		struct bcm43xx_coreinfo_80211 *ext_80211;
-
-		err = _switch_core(bcm, current_core);
-		if (err)
-			goto out;
-		/* Gather information */
-		/* fetch sb_id_hi from core information registers */
-		sb_id_hi = bcm43xx_read32(bcm, BCM43xx_CIR_SB_ID_HI);
-
-		/* extract core_id, core_rev, core_vendor */
-		core_id = (sb_id_hi & 0x8FF0) >> 4;
-		core_rev = ((sb_id_hi & 0xF) | ((sb_id_hi & 0x7000) >> 8));
-		core_vendor = (sb_id_hi & 0xFFFF0000) >> 16;
-
-		dprintk(KERN_INFO PFX "Core %d: ID 0x%x, rev 0x%x, vendor 0x%x\n",
-			current_core, core_id, core_rev, core_vendor);
-
-		core = NULL;
-		switch (core_id) {
-		case BCM43xx_COREID_PCI:
-		case BCM43xx_COREID_PCIE:
-			core = &bcm->core_pci;
-			if (core->available) {
-				printk(KERN_WARNING PFX "Multiple PCI cores found.\n");
-				continue;
-			}
-			break;
-		case BCM43xx_COREID_80211:
-			for (i = 0; i < BCM43xx_MAX_80211_CORES; i++) {
-				core = &(bcm->core_80211[i]);
-				ext_80211 = &(bcm->core_80211_ext[i]);
-				if (!core->available)
-					break;
-				core = NULL;
-			}
-			if (!core) {
-				printk(KERN_WARNING PFX "More than %d cores of type 802.11 found.\n",
-				       BCM43xx_MAX_80211_CORES);
-				continue;
-			}
-			if (i != 0) {
-				/* More than one 80211 core is only supported
-				 * by special chips.
-				 * There are chips with two 80211 cores, but with
-				 * dangling pins on the second core. Be careful
-				 * and ignore these cores here.
-				 */
-				if (1 /*bcm->pci_dev->device != 0x4324*/ ) {
-				/* TODO: A PHY */
-					dprintk(KERN_INFO PFX "Ignoring additional 802.11a core.\n");
-					continue;
-				}
-			}
-			switch (core_rev) {
-			case 2:
-			case 4:
-			case 5:
-			case 6:
-			case 7:
-			case 9:
-			case 10:
-				break;
-			default:
-				printk(KERN_WARNING PFX
-				       "Unsupported 80211 core revision %u\n",
-				       core_rev);
-			}
-			bcm->nr_80211_available++;
-			core->priv = ext_80211;
-			bcm43xx_init_struct_phyinfo(&ext_80211->phy);
-			bcm43xx_init_struct_radioinfo(&ext_80211->radio);
-			break;
-		case BCM43xx_COREID_CHIPCOMMON:
-			printk(KERN_WARNING PFX "Multiple CHIPCOMMON cores found.\n");
-			break;
-		}
-		if (core) {
-			core->available = 1;
-			core->id = core_id;
-			core->rev = core_rev;
-			core->index = current_core;
-		}
-	}
-
-	if (!bcm->core_80211[0].available) {
-		printk(KERN_ERR PFX "Error: No 80211 core found!\n");
-		err = -ENODEV;
-		goto out;
-	}
-
-	err = bcm43xx_switch_core(bcm, &bcm->core_80211[0]);
-
-	assert(err == 0);
-out:
-	return err;
-}
-
-static void bcm43xx_gen_bssid(struct bcm43xx_private *bcm)
-{
-	const u8 *mac = (const u8*)(bcm->net_dev->dev_addr);
-	u8 *bssid = bcm->ieee->bssid;
-
-	switch (bcm->ieee->iw_mode) {
-	case IW_MODE_ADHOC:
-		random_ether_addr(bssid);
-		break;
-	case IW_MODE_MASTER:
-	case IW_MODE_INFRA:
-	case IW_MODE_REPEAT:
-	case IW_MODE_SECOND:
-	case IW_MODE_MONITOR:
-		memcpy(bssid, mac, ETH_ALEN);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-static void bcm43xx_rate_memory_write(struct bcm43xx_private *bcm,
-				      u16 rate,
-				      int is_ofdm)
-{
-	u16 offset;
-
-	if (is_ofdm) {
-		offset = 0x480;
-		offset += (bcm43xx_plcp_get_ratecode_ofdm(rate) & 0x000F) * 2;
-	}
-	else {
-		offset = 0x4C0;
-		offset += (bcm43xx_plcp_get_ratecode_cck(rate) & 0x000F) * 2;
-	}
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, offset + 0x20,
-			    bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, offset));
-}
-
-static void bcm43xx_rate_memory_init(struct bcm43xx_private *bcm)
-{
-	switch (bcm43xx_current_phy(bcm)->type) {
-	case BCM43xx_PHYTYPE_A:
-	case BCM43xx_PHYTYPE_G:
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_6MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_12MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_18MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_24MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_36MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_48MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_54MB, 1);
-	case BCM43xx_PHYTYPE_B:
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_1MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_2MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_5MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_11MB, 0);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-static void bcm43xx_wireless_core_cleanup(struct bcm43xx_private *bcm)
-{
-	bcm43xx_chip_cleanup(bcm);
-	bcm43xx_pio_free(bcm);
-	bcm43xx_dma_free(bcm);
-
-	bcm->current_core->initialized = 0;
-}
-
-/* http://bcm-specs.sipsolutions.net/80211Init */
-static int bcm43xx_wireless_core_init(struct bcm43xx_private *bcm,
-				      int active_wlcore)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u32 ucodeflags;
-	int err;
-	u32 sbimconfiglow;
-	u8 limit;
-
-	if (bcm->core_pci.rev <= 5 && bcm->core_pci.id != BCM43xx_COREID_PCIE) {
-		sbimconfiglow = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMCONFIGLOW);
-		sbimconfiglow &= ~ BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_MASK;
-		sbimconfiglow &= ~ BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_MASK;
-		if (bcm->bustype == BCM43xx_BUSTYPE_PCI)
-			sbimconfiglow |= 0x32;
-		else
-			sbimconfiglow |= 0x53;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBIMCONFIGLOW, sbimconfiglow);
-	}
-
-	bcm43xx_phy_calibrate(bcm);
-	err = bcm43xx_chip_init(bcm);
-	if (err)
-		goto out;
-
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0016, bcm->current_core->rev);
-	ucodeflags = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, BCM43xx_UCODEFLAGS_OFFSET);
-
-	if (0 /*FIXME: which condition has to be used here? */)
-		ucodeflags |= 0x00000010;
-
-	/* HW decryption needs to be set now */
-	ucodeflags |= 0x40000000;
-	
-	if (phy->type == BCM43xx_PHYTYPE_G) {
-		ucodeflags |= BCM43xx_UCODEFLAG_UNKBGPHY;
-		if (phy->rev == 1)
-			ucodeflags |= BCM43xx_UCODEFLAG_UNKGPHY;
-		if (bcm->sprom.boardflags & BCM43xx_BFL_PACTRL)
-			ucodeflags |= BCM43xx_UCODEFLAG_UNKPACTRL;
-	} else if (phy->type == BCM43xx_PHYTYPE_B) {
-		ucodeflags |= BCM43xx_UCODEFLAG_UNKBGPHY;
-		if (phy->rev >= 2 && radio->version == 0x2050)
-			ucodeflags &= ~BCM43xx_UCODEFLAG_UNKGPHY;
-	}
-
-	if (ucodeflags != bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-					     BCM43xx_UCODEFLAGS_OFFSET)) {
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODEFLAGS_OFFSET, ucodeflags);
-	}
-
-	/* Short/Long Retry Limit.
-	 * The retry-limit is a 4-bit counter. Enforce this to avoid overflowing
-	 * the chip-internal counter.
-	 */
-	limit = limit_value(modparam_short_retry, 0, 0xF);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0006, limit);
-	limit = limit_value(modparam_long_retry, 0, 0xF);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0007, limit);
-
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0044, 3);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0046, 2);
-
-	bcm43xx_rate_memory_init(bcm);
-
-	/* Minimum Contention Window */
-	if (phy->type == BCM43xx_PHYTYPE_B)
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0003, 0x0000001f);
-	else
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0003, 0x0000000f);
-	/* Maximum Contention Window */
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0004, 0x000003ff);
-
-	bcm43xx_gen_bssid(bcm);
-	bcm43xx_write_mac_bssid_templates(bcm);
-
-	if (bcm->current_core->rev >= 5)
-		bcm43xx_write16(bcm, 0x043C, 0x000C);
-
-	if (active_wlcore) {
-		if (bcm43xx_using_pio(bcm)) {
-			err = bcm43xx_pio_init(bcm);
-		} else {
-			err = bcm43xx_dma_init(bcm);
-			if (err == -ENOSYS)
-				err = bcm43xx_pio_init(bcm);
-		}
-		if (err)
-			goto err_chip_cleanup;
-	}
-	bcm43xx_write16(bcm, 0x0612, 0x0050);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0416, 0x0050);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0414, 0x01F4);
-
-	if (active_wlcore) {
-		if (radio->initial_channel != 0xFF)
-			bcm43xx_radio_selectchannel(bcm, radio->initial_channel, 0);
-	}
-
-	/* Don't enable MAC/IRQ here, as it will race with the IRQ handler.
-	 * We enable it later.
-	 */
-	bcm->current_core->initialized = 1;
-out:
-	return err;
-
-err_chip_cleanup:
-	bcm43xx_chip_cleanup(bcm);
-	goto out;
-}
-
-static int bcm43xx_chipset_attach(struct bcm43xx_private *bcm)
-{
-	int err;
-	u16 pci_status;
-
-	err = bcm43xx_pctl_set_crystal(bcm, 1);
-	if (err)
-		goto out;
-	err = bcm43xx_pci_read_config16(bcm, PCI_STATUS, &pci_status);
-	if (err)
-		goto out;
-	err = bcm43xx_pci_write_config16(bcm, PCI_STATUS, pci_status & ~PCI_STATUS_SIG_TARGET_ABORT);
-
-out:
-	return err;
-}
-
-static void bcm43xx_chipset_detach(struct bcm43xx_private *bcm)
-{
-	bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_SLOW);
-	bcm43xx_pctl_set_crystal(bcm, 0);
-}
-
-static void bcm43xx_pcicore_broadcast_value(struct bcm43xx_private *bcm,
-					    u32 address,
-					    u32 data)
-{
-	bcm43xx_write32(bcm, BCM43xx_PCICORE_BCAST_ADDR, address);
-	bcm43xx_write32(bcm, BCM43xx_PCICORE_BCAST_DATA, data);
-}
-
-static int bcm43xx_pcicore_commit_settings(struct bcm43xx_private *bcm)
-{
-	int err = 0;
-
-	bcm->irq_savedstate = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-
-	if (bcm->core_chipcommon.available) {
-		err = bcm43xx_switch_core(bcm, &bcm->core_chipcommon);
-		if (err)
-			goto out;
-
-		bcm43xx_pcicore_broadcast_value(bcm, 0xfd8, 0x00000000);
-
-		/* this function is always called when a PCI core is mapped */
-		err = bcm43xx_switch_core(bcm, &bcm->core_pci);
-		if (err)
-			goto out;
-	} else
-		bcm43xx_pcicore_broadcast_value(bcm, 0xfd8, 0x00000000);
-
-	bcm43xx_interrupt_enable(bcm, bcm->irq_savedstate);
-
-out:
-	return err;
-}
-
-static u32 bcm43xx_pcie_reg_read(struct bcm43xx_private *bcm, u32 address)
-{
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_ADDR, address);
-	return bcm43xx_read32(bcm, BCM43xx_PCIECORE_REG_DATA);
-}
-
-static void bcm43xx_pcie_reg_write(struct bcm43xx_private *bcm, u32 address,
-				    u32 data)
-{
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_ADDR, address);
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_DATA, data);
-}
-
-static void bcm43xx_pcie_mdio_write(struct bcm43xx_private *bcm, u8 dev, u8 reg,
-				    u16 data)
-{
-	int i;
-
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_CTL, 0x0082);
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_DATA, BCM43xx_PCIE_MDIO_ST |
-			BCM43xx_PCIE_MDIO_WT | (dev << BCM43xx_PCIE_MDIO_DEV) |
-			(reg << BCM43xx_PCIE_MDIO_REG) | BCM43xx_PCIE_MDIO_TA |
-			data);
-	udelay(10);
-
-	for (i = 0; i < 10; i++) {
-		if (bcm43xx_read32(bcm, BCM43xx_PCIECORE_MDIO_CTL) &
-		    BCM43xx_PCIE_MDIO_TC)
-			break;
-		msleep(1);
-	}
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_CTL, 0);
-}
-
-/* Make an I/O Core usable. "core_mask" is the bitmask of the cores to enable.
- * To enable core 0, pass a core_mask of 1<<0
- */
-static int bcm43xx_setup_backplane_pci_connection(struct bcm43xx_private *bcm,
-						  u32 core_mask)
-{
-	u32 backplane_flag_nr;
-	u32 value;
-	struct bcm43xx_coreinfo *old_core;
-	int err = 0;
-
-	value = bcm43xx_read32(bcm, BCM43xx_CIR_SBTPSFLAG);
-	backplane_flag_nr = value & BCM43xx_BACKPLANE_FLAG_NR_MASK;
-
-	old_core = bcm->current_core;
-	err = bcm43xx_switch_core(bcm, &bcm->core_pci);
-	if (err)
-		goto out;
-
-	if (bcm->current_core->rev < 6 &&
-		bcm->current_core->id == BCM43xx_COREID_PCI) {
-		value = bcm43xx_read32(bcm, BCM43xx_CIR_SBINTVEC);
-		value |= (1 << backplane_flag_nr);
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBINTVEC, value);
-	} else {
-		err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_ICR, &value);
-		if (err) {
-			printk(KERN_ERR PFX "Error: ICR setup failure!\n");
-			goto out_switch_back;
-		}
-		value |= core_mask << 8;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_ICR, value);
-		if (err) {
-			printk(KERN_ERR PFX "Error: ICR setup failure!\n");
-			goto out_switch_back;
-		}
-	}
-
-	if (bcm->current_core->id == BCM43xx_COREID_PCI) {
-		value = bcm43xx_read32(bcm, BCM43xx_PCICORE_SBTOPCI2);
-		value |= BCM43xx_SBTOPCI2_PREFETCH | BCM43xx_SBTOPCI2_BURST;
-		bcm43xx_write32(bcm, BCM43xx_PCICORE_SBTOPCI2, value);
-
-		if (bcm->current_core->rev < 5) {
-			value = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMCONFIGLOW);
-			value |= (2 << BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_SHIFT)
-				 & BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_MASK;
-			value |= (3 << BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_SHIFT)
-				 & BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_MASK;
-			bcm43xx_write32(bcm, BCM43xx_CIR_SBIMCONFIGLOW, value);
-			err = bcm43xx_pcicore_commit_settings(bcm);
-			assert(err == 0);
-		} else if (bcm->current_core->rev >= 11) {
-			value = bcm43xx_read32(bcm, BCM43xx_PCICORE_SBTOPCI2);
-			value |= BCM43xx_SBTOPCI2_MEMREAD_MULTI;
-			bcm43xx_write32(bcm, BCM43xx_PCICORE_SBTOPCI2, value);
-		}
-	} else {
-		if (bcm->current_core->rev == 0 || bcm->current_core->rev == 1) {
-			value = bcm43xx_pcie_reg_read(bcm, BCM43xx_PCIE_TLP_WORKAROUND);
-			value |= 0x8;
-			bcm43xx_pcie_reg_write(bcm, BCM43xx_PCIE_TLP_WORKAROUND,
-					       value);
-		}
-		if (bcm->current_core->rev == 0) {
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_RXTIMER, 0x8128);
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_CDR, 0x0100);
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_CDR_BW, 0x1466);
-		} else if (bcm->current_core->rev == 1) {
-			value = bcm43xx_pcie_reg_read(bcm, BCM43xx_PCIE_DLLP_LINKCTL);
-			value |= 0x40;
-			bcm43xx_pcie_reg_write(bcm, BCM43xx_PCIE_DLLP_LINKCTL,
-					       value);
-		}
-	}
-out_switch_back:
-	err = bcm43xx_switch_core(bcm, old_core);
-out:
-	return err;
-}
-
-static void bcm43xx_periodic_every120sec(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	if (phy->type != BCM43xx_PHYTYPE_G || phy->rev < 2)
-		return;
-
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_phy_lo_g_measure(bcm);
-	bcm43xx_mac_enable(bcm);
-}
-
-static void bcm43xx_periodic_every60sec(struct bcm43xx_private *bcm)
-{
-	bcm43xx_phy_lo_mark_all_unused(bcm);
-	if (bcm->sprom.boardflags & BCM43xx_BFL_RSSI) {
-		bcm43xx_mac_suspend(bcm);
-		bcm43xx_calc_nrssi_slope(bcm);
-		bcm43xx_mac_enable(bcm);
-	}
-}
-
-static void bcm43xx_periodic_every30sec(struct bcm43xx_private *bcm)
-{
-	/* Update device statistics. */
-	bcm43xx_calculate_link_quality(bcm);
-}
-
-static void bcm43xx_periodic_every15sec(struct bcm43xx_private *bcm)
-{
-	bcm43xx_phy_xmitpower(bcm); //FIXME: unless scanning?
-	//TODO for APHY (temperature?)
-}
-
-static void bcm43xx_periodic_every1sec(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	int radio_hw_enable;
-
-	/* check if radio hardware enabled status changed */
-	radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
-	if (unlikely(bcm->radio_hw_enable != radio_hw_enable)) {
-		bcm->radio_hw_enable = radio_hw_enable;
-		printk(KERN_INFO PFX "Radio hardware status changed to %s\n",
-		       (radio_hw_enable == 0) ? "disabled" : "enabled");
-		bcm43xx_leds_update(bcm, 0);
-	}
-	if (phy->type == BCM43xx_PHYTYPE_G) {
-		//TODO: update_aci_moving_average
-		if (radio->aci_enable && radio->aci_wlan_automatic) {
-			bcm43xx_mac_suspend(bcm);
-			if (!radio->aci_enable && 1 /*TODO: not scanning? */) {
-				if (0 /*TODO: bunch of conditions*/) {
-					bcm43xx_radio_set_interference_mitigation(bcm,
-										  BCM43xx_RADIO_INTERFMODE_MANUALWLAN);
-				}
-			} else if (1/*TODO*/) {
-				/*
-				if ((aci_average > 1000) && !(bcm43xx_radio_aci_scan(bcm))) {
-					bcm43xx_radio_set_interference_mitigation(bcm,
-										  BCM43xx_RADIO_INTERFMODE_NONE);
-				}
-				*/
-			}
-			bcm43xx_mac_enable(bcm);
-		} else if (radio->interfmode == BCM43xx_RADIO_INTERFMODE_NONWLAN &&
-			   phy->rev == 1) {
-			//TODO: implement rev1 workaround
-		}
-	}
-}
-
-static void do_periodic_work(struct bcm43xx_private *bcm)
-{
-	if (bcm->periodic_state % 120 == 0)
-		bcm43xx_periodic_every120sec(bcm);
-	if (bcm->periodic_state % 60 == 0)
-		bcm43xx_periodic_every60sec(bcm);
-	if (bcm->periodic_state % 30 == 0)
-		bcm43xx_periodic_every30sec(bcm);
-	if (bcm->periodic_state % 15 == 0)
-		bcm43xx_periodic_every15sec(bcm);
-	bcm43xx_periodic_every1sec(bcm);
-
-	schedule_delayed_work(&bcm->periodic_work, HZ);
-}
-
-static void bcm43xx_periodic_work_handler(struct work_struct *work)
-{
-	struct bcm43xx_private *bcm =
-		container_of(work, struct bcm43xx_private, periodic_work.work);
-	struct net_device *net_dev = bcm->net_dev;
-	unsigned long flags;
-	u32 savedirqs = 0;
-	unsigned long orig_trans_start = 0;
-
-	mutex_lock(&bcm->mutex);
-	/* keep from doing and rearming periodic work if shutting down */
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
-		goto unlock_mutex;
-	if (unlikely(bcm->periodic_state % 60 == 0)) {
-		/* Periodic work will take a long time, so we want it to
-		 * be preemtible.
-		 */
-
-		netif_tx_lock_bh(net_dev);
-		/* We must fake a started transmission here, as we are going to
-		 * disable TX. If we wouldn't fake a TX, it would be possible to
-		 * trigger the netdev watchdog, if the last real TX is already
-		 * some time on the past (slightly less than 5secs)
-		 */
-		orig_trans_start = net_dev->trans_start;
-		net_dev->trans_start = jiffies;
-		netif_stop_queue(net_dev);
-		netif_tx_unlock_bh(net_dev);
-
-		spin_lock_irqsave(&bcm->irq_lock, flags);
-		bcm43xx_mac_suspend(bcm);
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_freeze_txqueues(bcm);
-		savedirqs = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-		spin_unlock_irqrestore(&bcm->irq_lock, flags);
-		bcm43xx_synchronize_irq(bcm);
-	} else {
-		/* Periodic work should take short time, so we want low
-		 * locking overhead.
-		 */
-		spin_lock_irqsave(&bcm->irq_lock, flags);
-	}
-
-	do_periodic_work(bcm);
-
-	if (unlikely(bcm->periodic_state % 60 == 0)) {
-		spin_lock_irqsave(&bcm->irq_lock, flags);
-		tasklet_enable(&bcm->isr_tasklet);
-		bcm43xx_interrupt_enable(bcm, savedirqs);
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_thaw_txqueues(bcm);
-		bcm43xx_mac_enable(bcm);
-		netif_wake_queue(bcm->net_dev);
-		net_dev->trans_start = orig_trans_start;
-	}
-	mmiowb();
-	bcm->periodic_state++;
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-unlock_mutex:
-	mutex_unlock(&bcm->mutex);
-}
-
-void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
-{
-	struct delayed_work *work = &bcm->periodic_work;
-
-	assert(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED);
-	INIT_DELAYED_WORK(work, bcm43xx_periodic_work_handler);
-	schedule_delayed_work(work, 0);
-}
-
-static void bcm43xx_security_init(struct bcm43xx_private *bcm)
-{
-	bcm->security_offset = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-						  0x0056) * 2;
-	bcm43xx_clear_keys(bcm);
-}
-
-static int bcm43xx_rng_read(struct hwrng *rng, u32 *data)
-{
-	struct bcm43xx_private *bcm = (struct bcm43xx_private *)rng->priv;
-	unsigned long flags;
-
-	spin_lock_irqsave(&(bcm)->irq_lock, flags);
-	*data = bcm43xx_read16(bcm, BCM43xx_MMIO_RNG);
-	spin_unlock_irqrestore(&(bcm)->irq_lock, flags);
-
-	return (sizeof(u16));
-}
-
-static void bcm43xx_rng_exit(struct bcm43xx_private *bcm)
-{
-	hwrng_unregister(&bcm->rng);
-}
-
-static int bcm43xx_rng_init(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	snprintf(bcm->rng_name, ARRAY_SIZE(bcm->rng_name),
-		 "%s_%s", KBUILD_MODNAME, bcm->net_dev->name);
-	bcm->rng.name = bcm->rng_name;
-	bcm->rng.data_read = bcm43xx_rng_read;
-	bcm->rng.priv = (unsigned long)bcm;
-	err = hwrng_register(&bcm->rng);
-	if (err)
-		printk(KERN_ERR PFX "RNG init failed (%d)\n", err);
-
-	return err;
-}
-
-void bcm43xx_cancel_work(struct bcm43xx_private *bcm)
-{
-	/* The system must be unlocked when this routine is entered.
-	 * If not, the next 2 steps may deadlock */
-	cancel_work_sync(&bcm->restart_work);
-	cancel_delayed_work_sync(&bcm->periodic_work);
-}
-
-static int bcm43xx_shutdown_all_wireless_cores(struct bcm43xx_private *bcm)
-{
-	int ret = 0;
-	int i, err;
-	struct bcm43xx_coreinfo *core;
-
-	bcm43xx_set_status(bcm, BCM43xx_STAT_SHUTTINGDOWN);
-	for (i = 0; i < bcm->nr_80211_available; i++) {
-		core = &(bcm->core_80211[i]);
-		assert(core->available);
-		if (!core->initialized)
-			continue;
-		err = bcm43xx_switch_core(bcm, core);
-		if (err) {
-			dprintk(KERN_ERR PFX "shutdown_all_wireless_cores "
-					     "switch_core failed (%d)\n", err);
-			ret = err;
-			continue;
-		}
-		bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-		bcm43xx_wireless_core_cleanup(bcm);
-		if (core == bcm->active_80211_core)
-			bcm->active_80211_core = NULL;
-	}
-	free_irq(bcm->irq, bcm);
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-
-	return ret;
-}
-
-/* This is the opposite of bcm43xx_init_board() */
-static void bcm43xx_free_board(struct bcm43xx_private *bcm)
-{
-	bcm43xx_rng_exit(bcm);
-	bcm43xx_sysfs_unregister(bcm);
-
-	mutex_lock(&(bcm)->mutex);
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-	mutex_unlock(&(bcm)->mutex);
-
-	bcm43xx_cancel_work(bcm);
-
-	mutex_lock(&(bcm)->mutex);
-	bcm43xx_shutdown_all_wireless_cores(bcm);
-	bcm43xx_pctl_set_crystal(bcm, 0);
-	mutex_unlock(&(bcm)->mutex);
-}
-
-static void prepare_phydata_for_init(struct bcm43xx_phyinfo *phy)
-{
-	phy->antenna_diversity = 0xFFFF;
-	memset(phy->minlowsig, 0xFF, sizeof(phy->minlowsig));
-	memset(phy->minlowsigpos, 0, sizeof(phy->minlowsigpos));
-
-	/* Flags */
-	phy->calibrated = 0;
-	phy->is_locked = 0;
-
-	if (phy->_lo_pairs) {
-		memset(phy->_lo_pairs, 0,
-		       sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT);
-	}
-	memset(phy->loopback_gain, 0, sizeof(phy->loopback_gain));
-}
-
-static void prepare_radiodata_for_init(struct bcm43xx_private *bcm,
-				       struct bcm43xx_radioinfo *radio)
-{
-	int i;
-
-	/* Set default attenuation values. */
-	radio->baseband_atten = bcm43xx_default_baseband_attenuation(bcm);
-	radio->radio_atten = bcm43xx_default_radio_attenuation(bcm);
-	radio->txctl1 = bcm43xx_default_txctl1(bcm);
-	radio->txctl2 = 0xFFFF;
-	radio->txpwr_offset = 0;
-
-	/* NRSSI */
-	radio->nrssislope = 0;
-	for (i = 0; i < ARRAY_SIZE(radio->nrssi); i++)
-		radio->nrssi[i] = -1000;
-	for (i = 0; i < ARRAY_SIZE(radio->nrssi_lt); i++)
-		radio->nrssi_lt[i] = i;
-
-	radio->lofcal = 0xFFFF;
-	radio->initval = 0xFFFF;
-
-	radio->aci_enable = 0;
-	radio->aci_wlan_automatic = 0;
-	radio->aci_hw_rssi = 0;
-}
-
-static void prepare_priv_for_init(struct bcm43xx_private *bcm)
-{
-	int i;
-	struct bcm43xx_coreinfo *core;
-	struct bcm43xx_coreinfo_80211 *wlext;
-
-	assert(!bcm->active_80211_core);
-
-	bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZING);
-
-	/* Flags */
-	bcm->was_initialized = 0;
-	bcm->reg124_set_0x4 = 0;
-
-	/* Stats */
-	memset(&bcm->stats, 0, sizeof(bcm->stats));
-
-	/* Wireless core data */
-	for (i = 0; i < BCM43xx_MAX_80211_CORES; i++) {
-		core = &(bcm->core_80211[i]);
-		wlext = core->priv;
-
-		if (!core->available)
-			continue;
-		assert(wlext == &(bcm->core_80211_ext[i]));
-
-		prepare_phydata_for_init(&wlext->phy);
-		prepare_radiodata_for_init(bcm, &wlext->radio);
-	}
-
-	/* IRQ related flags */
-	bcm->irq_reason = 0;
-	memset(bcm->dma_reason, 0, sizeof(bcm->dma_reason));
-	bcm->irq_savedstate = BCM43xx_IRQ_INITIAL;
-
-	bcm->mac_suspended = 1;
-
-	/* Noise calculation context */
-	memset(&bcm->noisecalc, 0, sizeof(bcm->noisecalc));
-
-	/* Periodic work context */
-	bcm->periodic_state = 0;
-}
-
-static int wireless_core_up(struct bcm43xx_private *bcm,
-			    int active_wlcore)
-{
-	int err;
-
-	if (!bcm43xx_core_enabled(bcm))
-		bcm43xx_wireless_core_reset(bcm, 1);
-	if (!active_wlcore)
-		bcm43xx_wireless_core_mark_inactive(bcm);
-	err = bcm43xx_wireless_core_init(bcm, active_wlcore);
-	if (err)
-		goto out;
-	if (!active_wlcore)
-		bcm43xx_radio_turn_off(bcm);
-out:
-	return err;
-}
-
-/* Select and enable the "to be used" wireless core.
- * Locking: bcm->mutex must be aquired before calling this.
- *          bcm->irq_lock must not be aquired.
- */
-int bcm43xx_select_wireless_core(struct bcm43xx_private *bcm,
-				 int phytype)
-{
-	int i, err;
-	struct bcm43xx_coreinfo *active_core = NULL;
-	struct bcm43xx_coreinfo_80211 *active_wlext = NULL;
-	struct bcm43xx_coreinfo *core;
-	struct bcm43xx_coreinfo_80211 *wlext;
-	int adjust_active_sbtmstatelow = 0;
-
-	might_sleep();
-
-	if (phytype < 0) {
-		/* If no phytype is requested, select the first core. */
-		assert(bcm->core_80211[0].available);
-		wlext = bcm->core_80211[0].priv;
-		phytype = wlext->phy.type;
-	}
-	/* Find the requested core. */
-	for (i = 0; i < bcm->nr_80211_available; i++) {
-		core = &(bcm->core_80211[i]);
-		wlext = core->priv;
-		if (wlext->phy.type == phytype) {
-			active_core = core;
-			active_wlext = wlext;
-			break;
-		}
-	}
-	if (!active_core)
-		return -ESRCH; /* No such PHYTYPE on this board. */
-
-	if (bcm->active_80211_core) {
-		/* We already selected a wl core in the past.
-		 * So first clean up everything.
-		 */
-		dprintk(KERN_INFO PFX "select_wireless_core: cleanup\n");
-		ieee80211softmac_stop(bcm->net_dev);
-		bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZED);
-		err = bcm43xx_disable_interrupts_sync(bcm);
-		assert(!err);
-		tasklet_enable(&bcm->isr_tasklet);
-		err = bcm43xx_shutdown_all_wireless_cores(bcm);
-		if (err)
-			goto error;
-		/* Ok, everything down, continue to re-initialize. */
-		bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZING);
-	}
-
-	/* Reset all data structures. */
-	prepare_priv_for_init(bcm);
-
-	err = bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_FAST);
-	if (err)
-		goto error;
-
-	/* Mark all unused cores "inactive". */
-	for (i = 0; i < bcm->nr_80211_available; i++) {
-		core = &(bcm->core_80211[i]);
-		wlext = core->priv;
-
-		if (core == active_core)
-			continue;
-		err = bcm43xx_switch_core(bcm, core);
-		if (err) {
-			dprintk(KERN_ERR PFX "Could not switch to inactive "
-					     "802.11 core (%d)\n", err);
-			goto error;
-		}
-		err = wireless_core_up(bcm, 0);
-		if (err) {
-			dprintk(KERN_ERR PFX "core_up for inactive 802.11 core "
-					     "failed (%d)\n", err);
-			goto error;
-		}
-		adjust_active_sbtmstatelow = 1;
-	}
-
-	/* Now initialize the active 802.11 core. */
-	err = bcm43xx_switch_core(bcm, active_core);
-	if (err) {
-		dprintk(KERN_ERR PFX "Could not switch to active "
-				     "802.11 core (%d)\n", err);
-		goto error;
-	}
-	if (adjust_active_sbtmstatelow &&
-	    active_wlext->phy.type == BCM43xx_PHYTYPE_G) {
-		u32 sbtmstatelow;
-
-		sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-		sbtmstatelow |= BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	}
-	err = wireless_core_up(bcm, 1);
-	if (err) {
-		dprintk(KERN_ERR PFX "core_up for active 802.11 core "
-				     "failed (%d)\n", err);
-		goto error;
-	}
-	err = bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_DYNAMIC);
-	if (err)
-		goto error;
-	bcm->active_80211_core = active_core;
-
-	bcm43xx_macfilter_clear(bcm, BCM43xx_MACFILTER_ASSOC);
-	bcm43xx_macfilter_set(bcm, BCM43xx_MACFILTER_SELF, (u8 *)(bcm->net_dev->dev_addr));
-	bcm43xx_security_init(bcm);
-	drain_txstatus_queue(bcm);
-	ieee80211softmac_start(bcm->net_dev);
-
-	/* Let's go! Be careful after enabling the IRQs.
-	 * Don't switch cores, for example.
-	 */
-	bcm43xx_mac_enable(bcm);
-	bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZED);
-	err = bcm43xx_initialize_irq(bcm);
-	if (err)
-		goto error;
-	bcm43xx_interrupt_enable(bcm, bcm->irq_savedstate);
-
-	dprintk(KERN_INFO PFX "Selected 802.11 core (phytype %d)\n",
-		active_wlext->phy.type);
-
-	return 0;
-
-error:
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-	bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_SLOW);
-	return err;
-}
-
-static int bcm43xx_init_board(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	mutex_lock(&(bcm)->mutex);
-
-	tasklet_enable(&bcm->isr_tasklet);
-	err = bcm43xx_pctl_set_crystal(bcm, 1);
-	if (err)
-		goto err_tasklet;
-	err = bcm43xx_pctl_init(bcm);
-	if (err)
-		goto err_crystal_off;
-	err = bcm43xx_select_wireless_core(bcm, -1);
-	if (err)
-		goto err_crystal_off;
-	err = bcm43xx_sysfs_register(bcm);
-	if (err)
-		goto err_wlshutdown;
-	err = bcm43xx_rng_init(bcm);
-	if (err)
-		goto err_sysfs_unreg;
-	bcm43xx_periodic_tasks_setup(bcm);
-
-	/*FIXME: This should be handled by softmac instead. */
-	schedule_delayed_work(&bcm->softmac->associnfo.work, 0);
-
-out:
-	mutex_unlock(&(bcm)->mutex);
-
-	return err;
-
-err_sysfs_unreg:
-	bcm43xx_sysfs_unregister(bcm);
-err_wlshutdown:
-	bcm43xx_shutdown_all_wireless_cores(bcm);
-err_crystal_off:
-	bcm43xx_pctl_set_crystal(bcm, 0);
-err_tasklet:
-	tasklet_disable(&bcm->isr_tasklet);
-	goto out;
-}
-
-static void bcm43xx_detach_board(struct bcm43xx_private *bcm)
-{
-	struct pci_dev *pci_dev = bcm->pci_dev;
-	int i;
-
-	bcm43xx_chipset_detach(bcm);
-	/* Do _not_ access the chip, after it is detached. */
-	pci_iounmap(pci_dev, bcm->mmio_addr);
-	pci_release_regions(pci_dev);
-	pci_disable_device(pci_dev);
-
-	/* Free allocated structures/fields */
-	for (i = 0; i < BCM43xx_MAX_80211_CORES; i++) {
-		kfree(bcm->core_80211_ext[i].phy._lo_pairs);
-		if (bcm->core_80211_ext[i].phy.dyn_tssi_tbl)
-			kfree(bcm->core_80211_ext[i].phy.tssi2dbm);
-	}
-}	
-
-static int bcm43xx_read_phyinfo(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 value;
-	u8 phy_analog;
-	u8 phy_type;
-	u8 phy_rev;
-	int phy_rev_ok = 1;
-	void *p;
-
-	value = bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_VER);
-
-	phy_analog = (value & 0xF000) >> 12;
-	phy_type = (value & 0x0F00) >> 8;
-	phy_rev = (value & 0x000F);
-
-	dprintk(KERN_INFO PFX "Detected PHY: Analog: %x, Type %x, Revision %x\n",
-		phy_analog, phy_type, phy_rev);
-
-	switch (phy_type) {
-	case BCM43xx_PHYTYPE_A:
-		if (phy_rev >= 4)
-			phy_rev_ok = 0;
-		/*FIXME: We need to switch the ieee->modulation, etc.. flags,
-		 *       if we switch 80211 cores after init is done.
-		 *       As we do not implement on the fly switching between
-		 *       wireless cores, I will leave this as a future task.
-		 */
-		bcm->ieee->modulation = IEEE80211_OFDM_MODULATION;
-		bcm->ieee->mode = IEEE_A;
-		bcm->ieee->freq_band = IEEE80211_52GHZ_BAND |
-				       IEEE80211_24GHZ_BAND;
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if (phy_rev != 2 && phy_rev != 4 && phy_rev != 6 && phy_rev != 7)
-			phy_rev_ok = 0;
-		bcm->ieee->modulation = IEEE80211_CCK_MODULATION;
-		bcm->ieee->mode = IEEE_B;
-		bcm->ieee->freq_band = IEEE80211_24GHZ_BAND;
-		break;
-	case BCM43xx_PHYTYPE_G:
-		if (phy_rev > 8)
-			phy_rev_ok = 0;
-		bcm->ieee->modulation = IEEE80211_OFDM_MODULATION |
-					IEEE80211_CCK_MODULATION;
-		bcm->ieee->mode = IEEE_G;
-		bcm->ieee->freq_band = IEEE80211_24GHZ_BAND;
-		break;
-	default:
-		printk(KERN_ERR PFX "Error: Unknown PHY Type %x\n",
-		       phy_type);
-		return -ENODEV;
-	};
-	bcm->ieee->perfect_rssi = RX_RSSI_MAX;
-	bcm->ieee->worst_rssi = 0;
-	if (!phy_rev_ok) {
-		printk(KERN_WARNING PFX "Invalid PHY Revision %x\n",
-		       phy_rev);
-	}
-
-	phy->analog = phy_analog;
-	phy->type = phy_type;
-	phy->rev = phy_rev;
-	if ((phy_type == BCM43xx_PHYTYPE_B) || (phy_type == BCM43xx_PHYTYPE_G)) {
-		p = kzalloc(sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT,
-			    GFP_KERNEL);
-		if (!p)
-			return -ENOMEM;
-		phy->_lo_pairs = p;
-	}
-
-	return 0;
-}
-
-static int bcm43xx_attach_board(struct bcm43xx_private *bcm)
-{
-	struct pci_dev *pci_dev = bcm->pci_dev;
-	struct net_device *net_dev = bcm->net_dev;
-	int err;
-	int i;
-	u32 coremask;
-
-	err = pci_enable_device(pci_dev);
-	if (err) {
-		printk(KERN_ERR PFX "pci_enable_device() failed\n");
-		goto out;
-	}
-	err = pci_request_regions(pci_dev, KBUILD_MODNAME);
-	if (err) {
-		printk(KERN_ERR PFX "pci_request_regions() failed\n");
-		goto err_pci_disable;
-	}
-	/* enable PCI bus-mastering */
-	pci_set_master(pci_dev);
-	bcm->mmio_addr = pci_iomap(pci_dev, 0, ~0UL);
-	if (!bcm->mmio_addr) {
-		printk(KERN_ERR PFX "pci_iomap() failed\n");
-		err = -EIO;
-		goto err_pci_release;
-	}
-	net_dev->base_addr = (unsigned long)bcm->mmio_addr;
-
-	err = bcm43xx_pci_read_config16(bcm, PCI_SUBSYSTEM_VENDOR_ID,
-	                          &bcm->board_vendor);
-	if (err)
-		goto err_iounmap;
-	err = bcm43xx_pci_read_config16(bcm, PCI_SUBSYSTEM_ID,
-	                          &bcm->board_type);
-	if (err)
-		goto err_iounmap;
-
-	bcm->board_revision = bcm->pci_dev->revision;
-
-	err = bcm43xx_chipset_attach(bcm);
-	if (err)
-		goto err_iounmap;
-	err = bcm43xx_pctl_init(bcm);
-	if (err)
-		goto err_chipset_detach;
-	err = bcm43xx_probe_cores(bcm);
-	if (err)
-		goto err_chipset_detach;
-	
-	/* Attach all IO cores to the backplane. */
-	coremask = 0;
-	for (i = 0; i < bcm->nr_80211_available; i++)
-		coremask |= (1 << bcm->core_80211[i].index);
-	//FIXME: Also attach some non80211 cores?
-	err = bcm43xx_setup_backplane_pci_connection(bcm, coremask);
-	if (err) {
-		printk(KERN_ERR PFX "Backplane->PCI connection failed!\n");
-		goto err_chipset_detach;
-	}
-
-	err = bcm43xx_sprom_extract(bcm);
-	if (err)
-		goto err_chipset_detach;
-	err = bcm43xx_leds_init(bcm);
-	if (err)
-		goto err_chipset_detach;
-
-	for (i = 0; i < bcm->nr_80211_available; i++) {
-		err = bcm43xx_switch_core(bcm, &bcm->core_80211[i]);
-		assert(err != -ENODEV);
-		if (err)
-			goto err_80211_unwind;
-
-		/* Enable the selected wireless core.
-		 * Connect PHY only on the first core.
-		 */
-		bcm43xx_wireless_core_reset(bcm, (i == 0));
-
-		err = bcm43xx_read_phyinfo(bcm);
-		if (err && (i == 0))
-			goto err_80211_unwind;
-
-		err = bcm43xx_read_radioinfo(bcm);
-		if (err && (i == 0))
-			goto err_80211_unwind;
-
-		err = bcm43xx_validate_chip(bcm);
-		if (err && (i == 0))
-			goto err_80211_unwind;
-
-		bcm43xx_radio_turn_off(bcm);
-		err = bcm43xx_phy_init_tssi2dbm_table(bcm);
-		if (err)
-			goto err_80211_unwind;
-		bcm43xx_wireless_core_disable(bcm);
-	}
-	err = bcm43xx_geo_init(bcm);
-	if (err)
-		goto err_80211_unwind;
-	bcm43xx_pctl_set_crystal(bcm, 0);
-
-	/* Set the MAC address in the networking subsystem */
-	if (is_valid_ether_addr(bcm->sprom.et1macaddr))
-		memcpy(bcm->net_dev->dev_addr, bcm->sprom.et1macaddr, 6);
-	else
-		memcpy(bcm->net_dev->dev_addr, bcm->sprom.il0macaddr, 6);
-
-	snprintf(bcm->nick, IW_ESSID_MAX_SIZE,
-		 "Broadcom %04X", bcm->chip_id);
-
-	assert(err == 0);
-out:
-	return err;
-
-err_80211_unwind:
-	for (i = 0; i < BCM43xx_MAX_80211_CORES; i++) {
-		kfree(bcm->core_80211_ext[i].phy._lo_pairs);
-		if (bcm->core_80211_ext[i].phy.dyn_tssi_tbl)
-			kfree(bcm->core_80211_ext[i].phy.tssi2dbm);
-	}
-err_chipset_detach:
-	bcm43xx_chipset_detach(bcm);
-err_iounmap:
-	pci_iounmap(pci_dev, bcm->mmio_addr);
-err_pci_release:
-	pci_release_regions(pci_dev);
-err_pci_disable:
-	pci_disable_device(pci_dev);
-	printk(KERN_ERR PFX "Unable to attach board\n");
-	goto out;
-}
-
-/* Do the Hardware IO operations to send the txb */
-static inline int bcm43xx_tx(struct bcm43xx_private *bcm,
-			     struct ieee80211_txb *txb)
-{
-	int err = -ENODEV;
-
-	if (bcm43xx_using_pio(bcm))
-		err = bcm43xx_pio_tx(bcm, txb);
-	else
-		err = bcm43xx_dma_tx(bcm, txb);
-	bcm->net_dev->trans_start = jiffies;
-
-	return err;
-}
-
-static void bcm43xx_ieee80211_set_chan(struct net_device *net_dev,
-				       u8 channel)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct bcm43xx_radioinfo *radio;
-	unsigned long flags;
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm43xx_mac_suspend(bcm);
-		bcm43xx_radio_selectchannel(bcm, channel, 0);
-		bcm43xx_mac_enable(bcm);
-	} else {
-		radio = bcm43xx_current_radio(bcm);
-		radio->initial_channel = channel;
-	}
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-}
-
-/* set_security() callback in struct ieee80211_device */
-static void bcm43xx_ieee80211_set_security(struct net_device *net_dev,
-					   struct ieee80211_security *sec)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct ieee80211_security *secinfo = &bcm->ieee->sec;
-	unsigned long flags;
-	int keyidx;
-	
-	dprintk(KERN_INFO PFX "set security called");
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-
-	for (keyidx = 0; keyidx<WEP_KEYS; keyidx++)
-		if (sec->flags & (1<<keyidx)) {
-			secinfo->encode_alg[keyidx] = sec->encode_alg[keyidx];
-			secinfo->key_sizes[keyidx] = sec->key_sizes[keyidx];
-			memcpy(secinfo->keys[keyidx], sec->keys[keyidx], SCM_KEY_LEN);
-		}
-	
-	if (sec->flags & SEC_ACTIVE_KEY) {
-		secinfo->active_key = sec->active_key;
-		dprintk(", .active_key = %d", sec->active_key);
-	}
-	if (sec->flags & SEC_UNICAST_GROUP) {
-		secinfo->unicast_uses_group = sec->unicast_uses_group;
-		dprintk(", .unicast_uses_group = %d", sec->unicast_uses_group);
-	}
-	if (sec->flags & SEC_LEVEL) {
-		secinfo->level = sec->level;
-		dprintk(", .level = %d", sec->level);
-	}
-	if (sec->flags & SEC_ENABLED) {
-		secinfo->enabled = sec->enabled;
-		dprintk(", .enabled = %d", sec->enabled);
-	}
-	if (sec->flags & SEC_ENCRYPT) {
-		secinfo->encrypt = sec->encrypt;
-		dprintk(", .encrypt = %d", sec->encrypt);
-	}
-	if (sec->flags & SEC_AUTH_MODE) {
-		secinfo->auth_mode = sec->auth_mode;
-		dprintk(", .auth_mode = %d", sec->auth_mode);
-	}
-	dprintk("\n");
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED &&
-	    !bcm->ieee->host_encrypt) {
-		if (secinfo->enabled) {
-			/* upload WEP keys to hardware */
-			char null_address[6] = { 0 };
-			u8 algorithm = 0;
-			for (keyidx = 0; keyidx<WEP_KEYS; keyidx++) {
-				if (!(sec->flags & (1<<keyidx)))
-					continue;
-				switch (sec->encode_alg[keyidx]) {
-					case SEC_ALG_NONE: algorithm = BCM43xx_SEC_ALGO_NONE; break;
-					case SEC_ALG_WEP:
-						algorithm = BCM43xx_SEC_ALGO_WEP;
-						if (secinfo->key_sizes[keyidx] == 13)
-							algorithm = BCM43xx_SEC_ALGO_WEP104;
-						break;
-					case SEC_ALG_TKIP:
-						FIXME();
-						algorithm = BCM43xx_SEC_ALGO_TKIP;
-						break;
-					case SEC_ALG_CCMP:
-						FIXME();
-						algorithm = BCM43xx_SEC_ALGO_AES;
-						break;
-					default:
-						assert(0);
-						break;
-				}
-				bcm43xx_key_write(bcm, keyidx, algorithm, sec->keys[keyidx], secinfo->key_sizes[keyidx], &null_address[0]);
-				bcm->key[keyidx].enabled = 1;
-				bcm->key[keyidx].algorithm = algorithm;
-			}
-		} else
-				bcm43xx_clear_keys(bcm);
-	}
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-}
-
-/* hard_start_xmit() callback in struct ieee80211_device */
-static int bcm43xx_ieee80211_hard_start_xmit(struct ieee80211_txb *txb,
-					     struct net_device *net_dev,
-					     int pri)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err = -ENODEV;
-	unsigned long flags;
-
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (likely(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED))
-		err = bcm43xx_tx(bcm, txb);
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-
-	if (unlikely(err))
-		return NETDEV_TX_BUSY;
-	return NETDEV_TX_OK;
-}
-
-static void bcm43xx_net_tx_timeout(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	bcm43xx_controller_restart(bcm, "TX timeout");
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-}
-
-#ifdef CONFIG_NET_POLL_CONTROLLER
-static void bcm43xx_net_poll_controller(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-
-	local_irq_save(flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED)
-		bcm43xx_interrupt_handler(bcm->irq, bcm);
-	local_irq_restore(flags);
-}
-#endif /* CONFIG_NET_POLL_CONTROLLER */
-
-static int bcm43xx_net_open(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-
-	return bcm43xx_init_board(bcm);
-}
-
-static int bcm43xx_net_stop(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
-
-	ieee80211softmac_stop(net_dev);
-	err = bcm43xx_disable_interrupts_sync(bcm);
-	assert(!err);
-	bcm43xx_free_board(bcm);
-	bcm43xx_cancel_work(bcm);
-
-	return 0;
-}
-
-static int bcm43xx_init_private(struct bcm43xx_private *bcm,
-				struct net_device *net_dev,
-				struct pci_dev *pci_dev)
-{
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-	bcm->ieee = netdev_priv(net_dev);
-	bcm->softmac = ieee80211_priv(net_dev);
-	bcm->softmac->set_channel = bcm43xx_ieee80211_set_chan;
-
-	bcm->irq_savedstate = BCM43xx_IRQ_INITIAL;
-	bcm->mac_suspended = 1;
-	bcm->pci_dev = pci_dev;
-	bcm->net_dev = net_dev;
-	bcm->bad_frames_preempt = modparam_bad_frames_preempt;
-	spin_lock_init(&bcm->irq_lock);
-	spin_lock_init(&bcm->leds_lock);
-	mutex_init(&bcm->mutex);
-	tasklet_init(&bcm->isr_tasklet,
-		     (void (*)(unsigned long))bcm43xx_interrupt_tasklet,
-		     (unsigned long)bcm);
-	tasklet_disable_nosync(&bcm->isr_tasklet);
-	if (modparam_pio)
-		bcm->__using_pio = 1;
-	bcm->rts_threshold = BCM43xx_DEFAULT_RTS_THRESHOLD;
-
-	/* default to sw encryption for now */
-	bcm->ieee->host_build_iv = 0;
-	bcm->ieee->host_encrypt = 1;
-	bcm->ieee->host_decrypt = 1;
-	
-	bcm->ieee->iw_mode = BCM43xx_INITIAL_IWMODE;
-	bcm->ieee->tx_headroom = sizeof(struct bcm43xx_txhdr);
-	bcm->ieee->set_security = bcm43xx_ieee80211_set_security;
-	bcm->ieee->hard_start_xmit = bcm43xx_ieee80211_hard_start_xmit;
-
-	return 0;
-}
-
-static int __devinit bcm43xx_init_one(struct pci_dev *pdev,
-				      const struct pci_device_id *ent)
-{
-	struct net_device *net_dev;
-	struct bcm43xx_private *bcm;
-	int err;
-
-#ifdef DEBUG_SINGLE_DEVICE_ONLY
-	if (strcmp(pci_name(pdev), DEBUG_SINGLE_DEVICE_ONLY))
-		return -ENODEV;
-#endif
-
-	net_dev = alloc_ieee80211softmac(sizeof(*bcm));
-	if (!net_dev) {
-		printk(KERN_ERR PFX
-		       "could not allocate ieee80211 device %s\n",
-		       pci_name(pdev));
-		err = -ENOMEM;
-		goto out;
-	}
-	/* initialize the net_device struct */
-	SET_NETDEV_DEV(net_dev, &pdev->dev);
-
-	net_dev->open = bcm43xx_net_open;
-	net_dev->stop = bcm43xx_net_stop;
-	net_dev->tx_timeout = bcm43xx_net_tx_timeout;
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	net_dev->poll_controller = bcm43xx_net_poll_controller;
-#endif
-	net_dev->wireless_handlers = &bcm43xx_wx_handlers_def;
-	net_dev->irq = pdev->irq;
-	SET_ETHTOOL_OPS(net_dev, &bcm43xx_ethtool_ops);
-
-	/* initialize the bcm43xx_private struct */
-	bcm = bcm43xx_priv(net_dev);
-	memset(bcm, 0, sizeof(*bcm));
-	err = bcm43xx_init_private(bcm, net_dev, pdev);
-	if (err)
-		goto err_free_netdev;
-
-	pci_set_drvdata(pdev, net_dev);
-
-	err = bcm43xx_attach_board(bcm);
-	if (err)
-		goto err_free_netdev;
-
-	err = register_netdev(net_dev);
-	if (err) {
-		printk(KERN_ERR PFX "Cannot register net device, "
-		       "aborting.\n");
-		err = -ENOMEM;
-		goto err_detach_board;
-	}
-
-	bcm43xx_debugfs_add_device(bcm);
-
-	assert(err == 0);
-out:
-	return err;
-
-err_detach_board:
-	bcm43xx_detach_board(bcm);
-err_free_netdev:
-	free_ieee80211softmac(net_dev);
-	goto out;
-}
-
-static void __devexit bcm43xx_remove_one(struct pci_dev *pdev)
-{
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-
-	bcm43xx_debugfs_remove_device(bcm);
-	unregister_netdev(net_dev);
-	bcm43xx_detach_board(bcm);
-	free_ieee80211softmac(net_dev);
-}
-
-/* Hard-reset the chip. Do not call this directly.
- * Use bcm43xx_controller_restart()
- */
-static void bcm43xx_chip_reset(struct work_struct *work)
-{
-	struct bcm43xx_private *bcm =
-		container_of(work, struct bcm43xx_private, restart_work);
-	struct bcm43xx_phyinfo *phy;
-	int err = -ENODEV;
-
-	bcm43xx_cancel_work(bcm);
-	mutex_lock(&(bcm)->mutex);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		phy = bcm43xx_current_phy(bcm);
-		err = bcm43xx_select_wireless_core(bcm, phy->type);
-		if (!err)
-			bcm43xx_periodic_tasks_setup(bcm);
-	}
-	mutex_unlock(&(bcm)->mutex);
-
-	printk(KERN_ERR PFX "Controller restart%s\n",
-	       (err == 0) ? "ed" : " failed");
-}
-
-/* Hard-reset the chip.
- * This can be called from interrupt or process context.
- * bcm->irq_lock must be locked.
- */
-void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason)
-{
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)
-		return;
-	printk(KERN_ERR PFX "Controller RESET (%s) ...\n", reason);
-	INIT_WORK(&bcm->restart_work, bcm43xx_chip_reset);
-	schedule_work(&bcm->restart_work);
-}
-
-#ifdef CONFIG_PM
-
-static int bcm43xx_suspend(struct pci_dev *pdev, pm_message_t state)
-{
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
-
-	dprintk(KERN_INFO PFX "Suspending...\n");
-
-	netif_device_detach(net_dev);
-	bcm->was_initialized = 0;
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm->was_initialized = 1;
-		ieee80211softmac_stop(net_dev);
-		err = bcm43xx_disable_interrupts_sync(bcm);
-		if (unlikely(err)) {
-			dprintk(KERN_ERR PFX "Suspend failed.\n");
-			return -EAGAIN;
-		}
-		bcm->firmware_norelease = 1;
-		bcm43xx_free_board(bcm);
-		bcm->firmware_norelease = 0;
-	}
-	bcm43xx_chipset_detach(bcm);
-
-	pci_save_state(pdev);
-	pci_disable_device(pdev);
-	pci_set_power_state(pdev, pci_choose_state(pdev, state));
-
-	dprintk(KERN_INFO PFX "Device suspended.\n");
-
-	return 0;
-}
-
-static int bcm43xx_resume(struct pci_dev *pdev)
-{
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err = 0;
-
-	dprintk(KERN_INFO PFX "Resuming...\n");
-
-	pci_set_power_state(pdev, 0);
-	err = pci_enable_device(pdev);
-	if (err) {
-		printk(KERN_ERR PFX "Failure with pci_enable_device!\n");
-		return err;
-	}
-	pci_restore_state(pdev);
-
-	bcm43xx_chipset_attach(bcm);
-	if (bcm->was_initialized)
-		err = bcm43xx_init_board(bcm);
-	if (err) {
-		printk(KERN_ERR PFX "Resume failed!\n");
-		return err;
-	}
-	netif_device_attach(net_dev);
-
-	dprintk(KERN_INFO PFX "Device resumed.\n");
-
-	return 0;
-}
-
-#endif				/* CONFIG_PM */
-
-static struct pci_driver bcm43xx_pci_driver = {
-	.name = KBUILD_MODNAME,
-	.id_table = bcm43xx_pci_tbl,
-	.probe = bcm43xx_init_one,
-	.remove = __devexit_p(bcm43xx_remove_one),
-#ifdef CONFIG_PM
-	.suspend = bcm43xx_suspend,
-	.resume = bcm43xx_resume,
-#endif				/* CONFIG_PM */
-};
-
-static int __init bcm43xx_init(void)
-{
-	printk(KERN_INFO KBUILD_MODNAME " driver\n");
-	bcm43xx_debugfs_init();
-	return pci_register_driver(&bcm43xx_pci_driver);
-}
-
-static void __exit bcm43xx_exit(void)
-{
-	pci_unregister_driver(&bcm43xx_pci_driver);
-	bcm43xx_debugfs_exit();
-}
-
-module_init(bcm43xx_init)
-module_exit(bcm43xx_exit)
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef BCM43xx_MAIN_H_
-#define BCM43xx_MAIN_H_
-
-#include "bcm43xx.h"
-
-#define P4D_BYT3S(magic, nr_bytes)	u8 __p4dding##magic[nr_bytes]
-#define P4D_BYTES(line, nr_bytes)	P4D_BYT3S(line, nr_bytes)
-/* Magic helper macro to pad structures. Ignore those above. It's magic. */
-#define PAD_BYTES(nr_bytes)		P4D_BYTES( __LINE__ , (nr_bytes))
-
-
-/* Lightweight function to convert a frequency (in Mhz) to a channel number. */
-static inline
-u8 bcm43xx_freq_to_channel_a(int freq)
-{
-	return ((freq - 5000) / 5);
-}
-static inline
-u8 bcm43xx_freq_to_channel_bg(int freq)
-{
-	u8 channel;
-
-	if (freq == 2484)
-		channel = 14;
-	else
-		channel = (freq - 2407) / 5;
-
-	return channel;
-}
-static inline
-u8 bcm43xx_freq_to_channel(struct bcm43xx_private *bcm,
-			   int freq)
-{
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_A)
-		return bcm43xx_freq_to_channel_a(freq);
-	return bcm43xx_freq_to_channel_bg(freq);
-}
-
-/* Lightweight function to convert a channel number to a frequency (in Mhz). */
-static inline
-int bcm43xx_channel_to_freq_a(u8 channel)
-{
-	return (5000 + (5 * channel));
-}
-static inline
-int bcm43xx_channel_to_freq_bg(u8 channel)
-{
-	int freq;
-
-	if (channel == 14)
-		freq = 2484;
-	else
-		freq = 2407 + (5 * channel);
-
-	return freq;
-}
-static inline
-int bcm43xx_channel_to_freq(struct bcm43xx_private *bcm,
-			    u8 channel)
-{
-	if (bcm43xx_current_phy(bcm)->type == BCM43xx_PHYTYPE_A)
-		return bcm43xx_channel_to_freq_a(channel);
-	return bcm43xx_channel_to_freq_bg(channel);
-}
-
-void bcm43xx_tsf_read(struct bcm43xx_private *bcm, u64 *tsf);
-void bcm43xx_tsf_write(struct bcm43xx_private *bcm, u64 tsf);
-
-void bcm43xx_set_iwmode(struct bcm43xx_private *bcm,
-			int iw_mode);
-
-u32 bcm43xx_shm_read32(struct bcm43xx_private *bcm,
-		       u16 routing, u16 offset);
-u16 bcm43xx_shm_read16(struct bcm43xx_private *bcm,
-		       u16 routing, u16 offset);
-void bcm43xx_shm_write32(struct bcm43xx_private *bcm,
-			 u16 routing, u16 offset,
-			 u32 value);
-void bcm43xx_shm_write16(struct bcm43xx_private *bcm,
-			 u16 routing, u16 offset,
-			 u16 value);
-
-void bcm43xx_dummy_transmission(struct bcm43xx_private *bcm);
-
-int bcm43xx_switch_core(struct bcm43xx_private *bcm, struct bcm43xx_coreinfo *new_core);
-
-int bcm43xx_select_wireless_core(struct bcm43xx_private *bcm,
-				 int phytype);
-
-void bcm43xx_wireless_core_reset(struct bcm43xx_private *bcm, int connect_phy);
-
-void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
-void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
-
-void bcm43xx_cancel_work(struct bcm43xx_private *bcm);
-void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
-
-void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
-
-int bcm43xx_sprom_read(struct bcm43xx_private *bcm, u16 *sprom);
-int bcm43xx_sprom_write(struct bcm43xx_private *bcm, const u16 *sprom);
-
-#endif /* BCM43xx_MAIN_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
+++ /dev/null
@@ -1,2346 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include <linux/delay.h>
-#include <linux/pci.h>
-#include <linux/types.h>
-
-#include "bcm43xx.h"
-#include "bcm43xx_phy.h"
-#include "bcm43xx_main.h"
-#include "bcm43xx_radio.h"
-#include "bcm43xx_ilt.h"
-#include "bcm43xx_power.h"
-
-
-static const s8 bcm43xx_tssi2dbm_b_table[] = {
-	0x4D, 0x4C, 0x4B, 0x4A,
-	0x4A, 0x49, 0x48, 0x47,
-	0x47, 0x46, 0x45, 0x45,
-	0x44, 0x43, 0x42, 0x42,
-	0x41, 0x40, 0x3F, 0x3E,
-	0x3D, 0x3C, 0x3B, 0x3A,
-	0x39, 0x38, 0x37, 0x36,
-	0x35, 0x34, 0x32, 0x31,
-	0x30, 0x2F, 0x2D, 0x2C,
-	0x2B, 0x29, 0x28, 0x26,
-	0x25, 0x23, 0x21, 0x1F,
-	0x1D, 0x1A, 0x17, 0x14,
-	0x10, 0x0C, 0x06, 0x00,
-	  -7,   -7,   -7,   -7,
-	  -7,   -7,   -7,   -7,
-	  -7,   -7,   -7,   -7,
-};
-
-static const s8 bcm43xx_tssi2dbm_g_table[] = {
-	 77,  77,  77,  76,
-	 76,  76,  75,  75,
-	 74,  74,  73,  73,
-	 73,  72,  72,  71,
-	 71,  70,  70,  69,
-	 68,  68,  67,  67,
-	 66,  65,  65,  64,
-	 63,  63,  62,  61,
-	 60,  59,  58,  57,
-	 56,  55,  54,  53,
-	 52,  50,  49,  47,
-	 45,  43,  40,  37,
-	 33,  28,  22,  14,
-	  5,  -7, -20, -20,
-	-20, -20, -20, -20,
-	-20, -20, -20, -20,
-};
-
-static void bcm43xx_phy_initg(struct bcm43xx_private *bcm);
-
-
-static inline
-void bcm43xx_voluntary_preempt(void)
-{
-	assert(!in_atomic() && !in_irq() &&
-	       !in_interrupt() && !irqs_disabled());
-#ifndef CONFIG_PREEMPT
-	cond_resched();
-#endif /* CONFIG_PREEMPT */
-}
-
-void bcm43xx_raw_phy_lock(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	assert(irqs_disabled());
-	if (bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD) == 0x00000000) {
-		phy->is_locked = 0;
-		return;
-	}
-	if (bcm->current_core->rev < 3) {
-		bcm43xx_mac_suspend(bcm);
-		spin_lock(&phy->lock);
-	} else {
-		if (bcm->ieee->iw_mode != IW_MODE_MASTER)
-			bcm43xx_power_saving_ctl_bits(bcm, -1, 1);
-	}
-	phy->is_locked = 1;
-}
-
-void bcm43xx_raw_phy_unlock(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	assert(irqs_disabled());
-	if (bcm->current_core->rev < 3) {
-		if (phy->is_locked) {
-			spin_unlock(&phy->lock);
-			bcm43xx_mac_enable(bcm);
-		}
-	} else {
-		if (bcm->ieee->iw_mode != IW_MODE_MASTER)
-			bcm43xx_power_saving_ctl_bits(bcm, -1, -1);
-	}
-	phy->is_locked = 0;
-}
-
-u16 bcm43xx_phy_read(struct bcm43xx_private *bcm, u16 offset)
-{
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_CONTROL, offset);
-	return bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_DATA);
-}
-
-void bcm43xx_phy_write(struct bcm43xx_private *bcm, u16 offset, u16 val)
-{
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_CONTROL, offset);
-	mmiowb();
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_DATA, val);
-}
-
-void bcm43xx_phy_calibrate(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD); /* Dummy read. */
-	if (phy->calibrated)
-		return;
-	if (phy->type == BCM43xx_PHYTYPE_G && phy->rev == 1) {
-		bcm43xx_wireless_core_reset(bcm, 0);
-		bcm43xx_phy_initg(bcm);
-		bcm43xx_wireless_core_reset(bcm, 1);
-	}
-	phy->calibrated = 1;
-}
-
-/* Connect the PHY 
- * http://bcm-specs.sipsolutions.net/SetPHY
- */
-int bcm43xx_phy_connect(struct bcm43xx_private *bcm, int connect)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u32 flags;
-
-	if (bcm->current_core->rev < 5)
-		goto out;
-
-	flags = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-	if (connect) {
-		if (!(flags & BCM43xx_SBTMSTATEHIGH_G_PHY_AVAIL))
-			return -ENODEV;
-		flags = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-		flags |= BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, flags);
-	} else {
-		if (!(flags & BCM43xx_SBTMSTATEHIGH_A_PHY_AVAIL))
-			return -ENODEV;
-		flags = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-		flags &= ~BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, flags);
-	}
-out:
-	phy->connected = connect;
-	if (connect)
-		dprintk(KERN_INFO PFX "PHY connected\n");
-	else
-		dprintk(KERN_INFO PFX "PHY disconnected\n");
-
-	return 0;
-}
-
-/* intialize B PHY power control
- * as described in http://bcm-specs.sipsolutions.net/InitPowerControl
- */
-static void bcm43xx_phy_init_pctl(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 saved_batt = 0, saved_ratt = 0, saved_txctl1 = 0;
-	int must_reset_txpower = 0;
-
-	assert(phy->type != BCM43xx_PHYTYPE_A);
-	if ((bcm->board_vendor == PCI_VENDOR_ID_BROADCOM) &&
-	    (bcm->board_type == 0x0416))
-		return;
-
-	bcm43xx_phy_write(bcm, 0x0028, 0x8018);
-	bcm43xx_write16(bcm, 0x03E6, bcm43xx_read16(bcm, 0x03E6) & 0xFFDF);
-
-	if (phy->type == BCM43xx_PHYTYPE_G) {
-		if (!phy->connected)
-			return;
-		bcm43xx_phy_write(bcm, 0x047A, 0xC111);
-	}
-	if (phy->savedpctlreg != 0xFFFF)
-		return;
-
-	if (phy->type == BCM43xx_PHYTYPE_B &&
-	    phy->rev >= 2 &&
-	    radio->version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0076,
-				      bcm43xx_radio_read16(bcm, 0x0076) | 0x0084);
-	} else {
-		saved_batt = radio->baseband_atten;
-		saved_ratt = radio->radio_atten;
-		saved_txctl1 = radio->txctl1;
-		if ((radio->revision >= 6) && (radio->revision <= 8)
-		    && /*FIXME: incomplete specs for 5 < revision < 9 */ 0)
-			bcm43xx_radio_set_txpower_bg(bcm, 0xB, 0x1F, 0);
-		else
-			bcm43xx_radio_set_txpower_bg(bcm, 0xB, 9, 0);
-		must_reset_txpower = 1;
-	}
-	bcm43xx_dummy_transmission(bcm);
-
-	phy->savedpctlreg = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_PCTL);
-
-	if (must_reset_txpower)
-		bcm43xx_radio_set_txpower_bg(bcm, saved_batt, saved_ratt, saved_txctl1);
-	else
-		bcm43xx_radio_write16(bcm, 0x0076, bcm43xx_radio_read16(bcm, 0x0076) & 0xFF7B);
-	bcm43xx_radio_clear_tssi(bcm);
-}
-
-static void bcm43xx_phy_agcsetup(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 offset = 0x0000;
-
-	if (phy->rev == 1)
-		offset = 0x4C00;
-
-	bcm43xx_ilt_write(bcm, offset, 0x00FE);
-	bcm43xx_ilt_write(bcm, offset + 1, 0x000D);
-	bcm43xx_ilt_write(bcm, offset + 2, 0x0013);
-	bcm43xx_ilt_write(bcm, offset + 3, 0x0019);
-
-	if (phy->rev == 1) {
-		bcm43xx_ilt_write(bcm, 0x1800, 0x2710);
-		bcm43xx_ilt_write(bcm, 0x1801, 0x9B83);
-		bcm43xx_ilt_write(bcm, 0x1802, 0x9B83);
-		bcm43xx_ilt_write(bcm, 0x1803, 0x0F8D);
-		bcm43xx_phy_write(bcm, 0x0455, 0x0004);
-	}
-
-	bcm43xx_phy_write(bcm, 0x04A5, (bcm43xx_phy_read(bcm, 0x04A5) & 0x00FF) | 0x5700);
-	bcm43xx_phy_write(bcm, 0x041A, (bcm43xx_phy_read(bcm, 0x041A) & 0xFF80) | 0x000F);
-	bcm43xx_phy_write(bcm, 0x041A, (bcm43xx_phy_read(bcm, 0x041A) & 0xC07F) | 0x2B80);
-	bcm43xx_phy_write(bcm, 0x048C, (bcm43xx_phy_read(bcm, 0x048C) & 0xF0FF) | 0x0300);
-
-	bcm43xx_radio_write16(bcm, 0x007A, bcm43xx_radio_read16(bcm, 0x007A) | 0x0008);
-
-	bcm43xx_phy_write(bcm, 0x04A0, (bcm43xx_phy_read(bcm, 0x04A0) & 0xFFF0) | 0x0008);
-	bcm43xx_phy_write(bcm, 0x04A1, (bcm43xx_phy_read(bcm, 0x04A1) & 0xF0FF) | 0x0600);
-	bcm43xx_phy_write(bcm, 0x04A2, (bcm43xx_phy_read(bcm, 0x04A2) & 0xF0FF) | 0x0700);
-	bcm43xx_phy_write(bcm, 0x04A0, (bcm43xx_phy_read(bcm, 0x04A0) & 0xF0FF) | 0x0100);
-
-	if (phy->rev == 1)
-		bcm43xx_phy_write(bcm, 0x04A2, (bcm43xx_phy_read(bcm, 0x04A2) & 0xFFF0) | 0x0007);
-
-	bcm43xx_phy_write(bcm, 0x0488, (bcm43xx_phy_read(bcm, 0x0488) & 0xFF00) | 0x001C);
-	bcm43xx_phy_write(bcm, 0x0488, (bcm43xx_phy_read(bcm, 0x0488) & 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(bcm, 0x0496, (bcm43xx_phy_read(bcm, 0x0496) & 0xFF00) | 0x001C);
-	bcm43xx_phy_write(bcm, 0x0489, (bcm43xx_phy_read(bcm, 0x0489) & 0xFF00) | 0x0020);
-	bcm43xx_phy_write(bcm, 0x0489, (bcm43xx_phy_read(bcm, 0x0489) & 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(bcm, 0x0482, (bcm43xx_phy_read(bcm, 0x0482) & 0xFF00) | 0x002E);
-	bcm43xx_phy_write(bcm, 0x0496, (bcm43xx_phy_read(bcm, 0x0496) & 0x00FF) | 0x1A00);
-	bcm43xx_phy_write(bcm, 0x0481, (bcm43xx_phy_read(bcm, 0x0481) & 0xFF00) | 0x0028);
-	bcm43xx_phy_write(bcm, 0x0481, (bcm43xx_phy_read(bcm, 0x0481) & 0x00FF) | 0x2C00);
-
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(bcm, 0x0430, 0x092B);
-		bcm43xx_phy_write(bcm, 0x041B, (bcm43xx_phy_read(bcm, 0x041B) & 0xFFE1) | 0x0002);
-	} else {
-		bcm43xx_phy_write(bcm, 0x041B, bcm43xx_phy_read(bcm, 0x041B) & 0xFFE1);
-		bcm43xx_phy_write(bcm, 0x041F, 0x287A);
-		bcm43xx_phy_write(bcm, 0x0420, (bcm43xx_phy_read(bcm, 0x0420) & 0xFFF0) | 0x0004);
-	}
-
-	if (phy->rev > 2) {
-		bcm43xx_phy_write(bcm, 0x0422, 0x287A);
-		bcm43xx_phy_write(bcm, 0x0420, (bcm43xx_phy_read(bcm, 0x0420)
-				  & 0x0FFF) | 0x3000);
-	}
-		
-	bcm43xx_phy_write(bcm, 0x04A8, (bcm43xx_phy_read(bcm, 0x04A8) & 0x8080)
-					| 0x7874);
-	bcm43xx_phy_write(bcm, 0x048E, 0x1C00);
-
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(bcm, 0x04AB, (bcm43xx_phy_read(bcm, 0x04AB)
-				  & 0xF0FF) | 0x0600);
-		bcm43xx_phy_write(bcm, 0x048B, 0x005E);
-		bcm43xx_phy_write(bcm, 0x048C, (bcm43xx_phy_read(bcm, 0x048C)
-				  & 0xFF00) | 0x001E);
-		bcm43xx_phy_write(bcm, 0x048D, 0x0002);
-	}
-
-	bcm43xx_ilt_write(bcm, offset + 0x0800, 0);
-	bcm43xx_ilt_write(bcm, offset + 0x0801, 7);
-	bcm43xx_ilt_write(bcm, offset + 0x0802, 16);
-	bcm43xx_ilt_write(bcm, offset + 0x0803, 28);
-
-	if (phy->rev >= 6) {
-		bcm43xx_phy_write(bcm, 0x0426, (bcm43xx_phy_read(bcm, 0x0426)
-				  & 0xFFFC));
-		bcm43xx_phy_write(bcm, 0x0426, (bcm43xx_phy_read(bcm, 0x0426)
-				  & 0xEFFF));
-	}
-}
-
-static void bcm43xx_phy_setupg(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 i;
-
-	assert(phy->type == BCM43xx_PHYTYPE_G);
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(bcm, 0x0406, 0x4F19);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  (bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS)
-				  & 0xFC3F) | 0x0340);
-		bcm43xx_phy_write(bcm, 0x042C, 0x005A);
-		bcm43xx_phy_write(bcm, 0x0427, 0x001A);
-
-		for (i = 0; i < BCM43xx_ILT_FINEFREQG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5800 + i, bcm43xx_ilt_finefreqg[i]);
-		for (i = 0; i < BCM43xx_ILT_NOISEG1_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noiseg1[i]);
-		for (i = 0; i < BCM43xx_ILT_ROTOR_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2000 + i, bcm43xx_ilt_rotor[i]);
-	} else {
-		/* nrssi values are signed 6-bit values. Not sure why we write 0x7654 here... */
-		bcm43xx_nrssi_hw_write(bcm, 0xBA98, (s16)0x7654);
-
-		if (phy->rev == 2) {
-			bcm43xx_phy_write(bcm, 0x04C0, 0x1861);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x0271);
-		} else if (phy->rev > 2) {
-			bcm43xx_phy_write(bcm, 0x04C0, 0x0098);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x0070);
-			bcm43xx_phy_write(bcm, 0x04C9, 0x0080);
-		}
-		bcm43xx_phy_write(bcm, 0x042B, bcm43xx_phy_read(bcm, 0x042B) | 0x800);
-
-		for (i = 0; i < 64; i++)
-			bcm43xx_ilt_write(bcm, 0x4000 + i, i);
-		for (i = 0; i < BCM43xx_ILT_NOISEG2_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noiseg2[i]);
-	}
-	
-	if (phy->rev <= 2)
-		for (i = 0; i < BCM43xx_ILT_NOISESCALEG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1400 + i, bcm43xx_ilt_noisescaleg1[i]);
-	else if ((phy->rev >= 7) && (bcm43xx_phy_read(bcm, 0x0449) & 0x0200))
-		for (i = 0; i < BCM43xx_ILT_NOISESCALEG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1400 + i, bcm43xx_ilt_noisescaleg3[i]);
-	else
-		for (i = 0; i < BCM43xx_ILT_NOISESCALEG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1400 + i, bcm43xx_ilt_noisescaleg2[i]);
-	
-	if (phy->rev == 2)
-		for (i = 0; i < BCM43xx_ILT_SIGMASQR_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5000 + i, bcm43xx_ilt_sigmasqr1[i]);
-	else if ((phy->rev > 2) && (phy->rev <= 8))
-		for (i = 0; i < BCM43xx_ILT_SIGMASQR_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5000 + i, bcm43xx_ilt_sigmasqr2[i]);
-	
-	if (phy->rev == 1) {
-		for (i = 0; i < BCM43xx_ILT_RETARD_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2400 + i, bcm43xx_ilt_retard[i]);
-		for (i = 0; i < 4; i++) {
-			bcm43xx_ilt_write(bcm, 0x5404 + i, 0x0020);
-			bcm43xx_ilt_write(bcm, 0x5408 + i, 0x0020);
-			bcm43xx_ilt_write(bcm, 0x540C + i, 0x0020);
-			bcm43xx_ilt_write(bcm, 0x5410 + i, 0x0020);
-		}
-		bcm43xx_phy_agcsetup(bcm);
-
-		if ((bcm->board_vendor == PCI_VENDOR_ID_BROADCOM) &&
-		    (bcm->board_type == 0x0416) &&
-		    (bcm->board_revision == 0x0017))
-			return;
-
-		bcm43xx_ilt_write(bcm, 0x5001, 0x0002);
-		bcm43xx_ilt_write(bcm, 0x5002, 0x0001);
-	} else {
-		for (i = 0; i <= 0x2F; i++)
-			bcm43xx_ilt_write(bcm, 0x1000 + i, 0x0820);
-		bcm43xx_phy_agcsetup(bcm);
-		bcm43xx_phy_read(bcm, 0x0400); /* dummy read */
-		bcm43xx_phy_write(bcm, 0x0403, 0x1000);
-		bcm43xx_ilt_write(bcm, 0x3C02, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x3C03, 0x0014);
-
-		if ((bcm->board_vendor == PCI_VENDOR_ID_BROADCOM) &&
-		    (bcm->board_type == 0x0416) &&
-		    (bcm->board_revision == 0x0017))
-			return;
-
-		bcm43xx_ilt_write(bcm, 0x0401, 0x0002);
-		bcm43xx_ilt_write(bcm, 0x0402, 0x0001);
-	}
-}
-
-/* Initialize the noisescaletable for APHY */
-static void bcm43xx_phy_init_noisescaletbl(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	int i;
-
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, 0x1400);
-	for (i = 0; i < 12; i++) {
-		if (phy->rev == 2)
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x6767);
-		else
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x2323);
-	}
-	if (phy->rev == 2)
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x6700);
-	else
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x2300);
-	for (i = 0; i < 11; i++) {
-		if (phy->rev == 2)
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x6767);
-		else
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x2323);
-	}
-	if (phy->rev == 2)
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x0067);
-	else
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x0023);
-}
-
-static void bcm43xx_phy_setupa(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 i;
-
-	assert(phy->type == BCM43xx_PHYTYPE_A);
-	switch (phy->rev) {
-	case 2:
-		bcm43xx_phy_write(bcm, 0x008E, 0x3800);
-		bcm43xx_phy_write(bcm, 0x0035, 0x03FF);
-		bcm43xx_phy_write(bcm, 0x0036, 0x0400);
-
-		bcm43xx_ilt_write(bcm, 0x3807, 0x0051);
-
-		bcm43xx_phy_write(bcm, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(bcm, 0x0020, bcm43xx_phy_read(bcm, 0x0020) & 0xFF0F);
-		bcm43xx_ilt_write(bcm, 0x3C0C, 0x07BF);
-		bcm43xx_radio_write16(bcm, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(bcm, 0x0024, 0x4680);
-		bcm43xx_phy_write(bcm, 0x0020, 0x0003);
-		bcm43xx_phy_write(bcm, 0x001D, 0x0F40);
-		bcm43xx_phy_write(bcm, 0x001F, 0x1C00);
-
-		bcm43xx_phy_write(bcm, 0x002A, (bcm43xx_phy_read(bcm, 0x002A) & 0x00FF) | 0x0400);
-		bcm43xx_phy_write(bcm, 0x002B, bcm43xx_phy_read(bcm, 0x002B) & 0xFBFF);
-		bcm43xx_phy_write(bcm, 0x008E, 0x58C1);
-
-		bcm43xx_ilt_write(bcm, 0x0803, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x0804, 0x001F);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x002A);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x0030);
-		bcm43xx_ilt_write(bcm, 0x0807, 0x003A);
-
-		bcm43xx_ilt_write(bcm, 0x0000, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0001, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0002, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0003, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0004, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0005, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0006, 0x0019);
-
-		bcm43xx_ilt_write(bcm, 0x0404, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0405, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0406, 0x0007);
-
-		for (i = 0; i < 16; i++)
-			bcm43xx_ilt_write(bcm, 0x4000 + i, (0x8 + i) & 0x000F);
-
-		bcm43xx_ilt_write(bcm, 0x3003, 0x1044);
-		bcm43xx_ilt_write(bcm, 0x3004, 0x7201);
-		bcm43xx_ilt_write(bcm, 0x3006, 0x0040);
-		bcm43xx_ilt_write(bcm, 0x3001, (bcm43xx_ilt_read(bcm, 0x3001) & 0x0010) | 0x0008);
-
-		for (i = 0; i < BCM43xx_ILT_FINEFREQA_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5800 + i, bcm43xx_ilt_finefreqa[i]);
-		for (i = 0; i < BCM43xx_ILT_NOISEA2_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noisea2[i]);
-		for (i = 0; i < BCM43xx_ILT_ROTOR_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2000 + i, bcm43xx_ilt_rotor[i]);
-		bcm43xx_phy_init_noisescaletbl(bcm);
-		for (i = 0; i < BCM43xx_ILT_RETARD_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2400 + i, bcm43xx_ilt_retard[i]);
-		break;
-	case 3:
-		for (i = 0; i < 64; i++)
-			bcm43xx_ilt_write(bcm, 0x4000 + i, i);
-
-		bcm43xx_ilt_write(bcm, 0x3807, 0x0051);
-
-		bcm43xx_phy_write(bcm, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(bcm, 0x0020, bcm43xx_phy_read(bcm, 0x0020) & 0xFF0F);
-		bcm43xx_radio_write16(bcm, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(bcm, 0x0024, 0x4680);
-		bcm43xx_phy_write(bcm, 0x0020, 0x0003);
-		bcm43xx_phy_write(bcm, 0x001D, 0x0F40);
-		bcm43xx_phy_write(bcm, 0x001F, 0x1C00);
-		bcm43xx_phy_write(bcm, 0x002A, (bcm43xx_phy_read(bcm, 0x002A) & 0x00FF) | 0x0400);
-
-		bcm43xx_ilt_write(bcm, 0x3001, (bcm43xx_ilt_read(bcm, 0x3001) & 0x0010) | 0x0008);
-		for (i = 0; i < BCM43xx_ILT_NOISEA3_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noisea3[i]);
-		bcm43xx_phy_init_noisescaletbl(bcm);
-		for (i = 0; i < BCM43xx_ILT_SIGMASQR_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5000 + i, bcm43xx_ilt_sigmasqr1[i]);
-
-		bcm43xx_phy_write(bcm, 0x0003, 0x1808);
-
-		bcm43xx_ilt_write(bcm, 0x0803, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x0804, 0x001F);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x002A);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x0030);
-		bcm43xx_ilt_write(bcm, 0x0807, 0x003A);
-
-		bcm43xx_ilt_write(bcm, 0x0000, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0001, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0002, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0003, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0004, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0005, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0006, 0x0019);
-
-		bcm43xx_ilt_write(bcm, 0x0404, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0405, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0406, 0x0007);
-
-		bcm43xx_ilt_write(bcm, 0x3C02, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x3C03, 0x0014);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-/* Initialize APHY. This is also called for the GPHY in some cases. */
-static void bcm43xx_phy_inita(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 tval;
-
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_setupa(bcm);
-	} else {
-		bcm43xx_phy_setupg(bcm);
-		if (bcm->sprom.boardflags & BCM43xx_BFL_PACTRL)
-			bcm43xx_phy_write(bcm, 0x046E, 0x03CF);
-		return;
-	}
-
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_A_CRS,
-	                  (bcm43xx_phy_read(bcm, BCM43xx_PHY_A_CRS) & 0xF83C) | 0x0340);
-	bcm43xx_phy_write(bcm, 0x0034, 0x0001);
-
-	TODO();//TODO: RSSI AGC
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_A_CRS,
-	                  bcm43xx_phy_read(bcm, BCM43xx_PHY_A_CRS) | (1 << 14));
-	bcm43xx_radio_init2060(bcm);
-
-	if ((bcm->board_vendor == PCI_VENDOR_ID_BROADCOM)
-	    && ((bcm->board_type == 0x0416) || (bcm->board_type == 0x040A))) {
-		if (radio->lofcal == 0xFFFF) {
-			TODO();//TODO: LOF Cal
-			bcm43xx_radio_set_tx_iq(bcm);
-		} else
-			bcm43xx_radio_write16(bcm, 0x001E, radio->lofcal);
-	}
-
-	bcm43xx_phy_write(bcm, 0x007A, 0xF111);
-
-	if (phy->savedpctlreg == 0xFFFF) {
-		bcm43xx_radio_write16(bcm, 0x0019, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0017, 0x0020);
-
-		tval = bcm43xx_ilt_read(bcm, 0x3001);
-		if (phy->rev == 1) {
-			bcm43xx_ilt_write(bcm, 0x3001,
-					  (bcm43xx_ilt_read(bcm, 0x3001) & 0xFF87)
-					  | 0x0058);
-		} else {
-			bcm43xx_ilt_write(bcm, 0x3001,
-					  (bcm43xx_ilt_read(bcm, 0x3001) & 0xFFC3)
-					  | 0x002C);
-		}
-		bcm43xx_dummy_transmission(bcm);
-		phy->savedpctlreg = bcm43xx_phy_read(bcm, BCM43xx_PHY_A_PCTL);
-		bcm43xx_ilt_write(bcm, 0x3001, tval);
-
-		bcm43xx_radio_set_txpower_a(bcm, 0x0018);
-	}
-	bcm43xx_radio_clear_tssi(bcm);
-}
-
-static void bcm43xx_phy_initb2(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 offset, val;
-
-	bcm43xx_write16(bcm, 0x03EC, 0x3F22);
-	bcm43xx_phy_write(bcm, 0x0020, 0x301C);
-	bcm43xx_phy_write(bcm, 0x0026, 0x0000);
-	bcm43xx_phy_write(bcm, 0x0030, 0x00C6);
-	bcm43xx_phy_write(bcm, 0x0088, 0x3E00);
-	val = 0x3C3D;
-	for (offset = 0x0089; offset < 0x00A7; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
-		val -= 0x0202;
-	}
-	bcm43xx_phy_write(bcm, 0x03E4, 0x3000);
-	if (radio->channel == 0xFF)
-		bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_BG, 0);
-	else
-		bcm43xx_radio_selectchannel(bcm, radio->channel, 0);
-	if (radio->version != 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0075, 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0079, 0x0081);
-	}
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
-	if (radio->version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
-		bcm43xx_radio_write16(bcm, 0x007A, 0x000F);
-		bcm43xx_phy_write(bcm, 0x0038, 0x0677);
-		bcm43xx_radio_init2050(bcm);
-	}
-	bcm43xx_phy_write(bcm, 0x0014, 0x0080);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CA);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CC);
-	bcm43xx_phy_write(bcm, 0x0035, 0x07C2);
-	bcm43xx_phy_lo_b_measure(bcm);
-	bcm43xx_phy_write(bcm, 0x0026, 0xCC00);
-	if (radio->version != 0x2050)
-		bcm43xx_phy_write(bcm, 0x0026, 0xCE00);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, 0x1000);
-	bcm43xx_phy_write(bcm, 0x002A, 0x88A3);
-	if (radio->version != 0x2050)
-		bcm43xx_phy_write(bcm, 0x002A, 0x88C2);
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
-	bcm43xx_phy_init_pctl(bcm);
-}
-
-static void bcm43xx_phy_initb4(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 offset, val;
-
-	bcm43xx_write16(bcm, 0x03EC, 0x3F22);
-	bcm43xx_phy_write(bcm, 0x0020, 0x301C);
-	bcm43xx_phy_write(bcm, 0x0026, 0x0000);
-	bcm43xx_phy_write(bcm, 0x0030, 0x00C6);
-	bcm43xx_phy_write(bcm, 0x0088, 0x3E00);
-	val = 0x3C3D;
-	for (offset = 0x0089; offset < 0x00A7; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
-		val -= 0x0202;
-	}
-	bcm43xx_phy_write(bcm, 0x03E4, 0x3000);
-	if (radio->channel == 0xFF)
-		bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_BG, 0);
-	else
-		bcm43xx_radio_selectchannel(bcm, radio->channel, 0);
-	if (radio->version != 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0075, 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0079, 0x0081);
-	}
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
-	if (radio->version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
-		bcm43xx_radio_write16(bcm, 0x007A, 0x000F);
-		bcm43xx_phy_write(bcm, 0x0038, 0x0677);
-		bcm43xx_radio_init2050(bcm);
-	}
-	bcm43xx_phy_write(bcm, 0x0014, 0x0080);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CA);
-	if (radio->version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x0032, 0x00E0);
-	bcm43xx_phy_write(bcm, 0x0035, 0x07C2);
-
-	bcm43xx_phy_lo_b_measure(bcm);
-
-	bcm43xx_phy_write(bcm, 0x0026, 0xCC00);
-	if (radio->version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x0026, 0xCE00);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, 0x1100);
-	bcm43xx_phy_write(bcm, 0x002A, 0x88A3);
-	if (radio->version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x002A, 0x88C2);
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
-	if (bcm->sprom.boardflags & BCM43xx_BFL_RSSI) {
-		bcm43xx_calc_nrssi_slope(bcm);
-		bcm43xx_calc_nrssi_threshold(bcm);
-	}
-	bcm43xx_phy_init_pctl(bcm);
-}
-
-static void bcm43xx_phy_initb5(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 offset;
-	u16 value;
-	u8 old_channel;
-
-	if (phy->analog == 1)
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A)
-				      | 0x0050);
-	if ((bcm->board_vendor != PCI_VENDOR_ID_BROADCOM) &&
-	    (bcm->board_type != 0x0416)) {
-		value = 0x2120;
-		for (offset = 0x00A8 ; offset < 0x00C7; offset++) {
-			bcm43xx_phy_write(bcm, offset, value);
-			value += 0x0202;
-		}
-	}
-	bcm43xx_phy_write(bcm, 0x0035,
-			  (bcm43xx_phy_read(bcm, 0x0035) & 0xF0FF)
-			  | 0x0700);
-	if (radio->version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x0038, 0x0667);
-
-	if (phy->connected) {
-		if (radio->version == 0x2050) {
-			bcm43xx_radio_write16(bcm, 0x007A,
-					      bcm43xx_radio_read16(bcm, 0x007A)
-					      | 0x0020);
-			bcm43xx_radio_write16(bcm, 0x0051,
-					      bcm43xx_radio_read16(bcm, 0x0051)
-					      | 0x0004);
-		}
-		bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_RADIO, 0x0000);
-
-		bcm43xx_phy_write(bcm, 0x0802, bcm43xx_phy_read(bcm, 0x0802) | 0x0100);
-		bcm43xx_phy_write(bcm, 0x042B, bcm43xx_phy_read(bcm, 0x042B) | 0x2000);
-
-		bcm43xx_phy_write(bcm, 0x001C, 0x186A);
-
-		bcm43xx_phy_write(bcm, 0x0013, (bcm43xx_phy_read(bcm, 0x0013) & 0x00FF) | 0x1900);
-		bcm43xx_phy_write(bcm, 0x0035, (bcm43xx_phy_read(bcm, 0x0035) & 0xFFC0) | 0x0064);
-		bcm43xx_phy_write(bcm, 0x005D, (bcm43xx_phy_read(bcm, 0x005D) & 0xFF80) | 0x000A);
-	}
-
-	if (bcm->bad_frames_preempt) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD) | (1 << 11));
-	}
-
-	if (phy->analog == 1) {
-		bcm43xx_phy_write(bcm, 0x0026, 0xCE00);
-		bcm43xx_phy_write(bcm, 0x0021, 0x3763);
-		bcm43xx_phy_write(bcm, 0x0022, 0x1BC3);
-		bcm43xx_phy_write(bcm, 0x0023, 0x06F9);
-		bcm43xx_phy_write(bcm, 0x0024, 0x037E);
-	} else
-		bcm43xx_phy_write(bcm, 0x0026, 0xCC00);
-	bcm43xx_phy_write(bcm, 0x0030, 0x00C6);
-	bcm43xx_write16(bcm, 0x03EC, 0x3F22);
-
-	if (phy->analog == 1)
-		bcm43xx_phy_write(bcm, 0x0020, 0x3E1C);
-	else
-		bcm43xx_phy_write(bcm, 0x0020, 0x301C);
-
-	if (phy->analog == 0)
-		bcm43xx_write16(bcm, 0x03E4, 0x3000);
-
-	old_channel = radio->channel;
-	/* Force to channel 7, even if not supported. */
-	bcm43xx_radio_selectchannel(bcm, 7, 0);
-
-	if (radio->version != 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0075, 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0079, 0x0081);
-	}
-
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
-
-	if (radio->version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
-	}
-
-	bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-	bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
-
-	bcm43xx_radio_write16(bcm, 0x007A, bcm43xx_radio_read16(bcm, 0x007A) | 0x0007);
-
-	bcm43xx_radio_selectchannel(bcm, old_channel, 0);
-
-	bcm43xx_phy_write(bcm, 0x0014, 0x0080);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CA);
-	bcm43xx_phy_write(bcm, 0x002A, 0x88A3);
-
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
-
-	if (radio->version == 0x2050)
-		bcm43xx_radio_write16(bcm, 0x005D, 0x000D);
-
-	bcm43xx_write16(bcm, 0x03E4, (bcm43xx_read16(bcm, 0x03E4) & 0xFFC0) | 0x0004);
-}
-
-static void bcm43xx_phy_initb6(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 offset, val;
-	u8 old_channel;
-
-	bcm43xx_phy_write(bcm, 0x003E, 0x817A);
-	bcm43xx_radio_write16(bcm, 0x007A,
-	                      (bcm43xx_radio_read16(bcm, 0x007A) | 0x0058));
-	if (radio->revision == 4 ||
-	     radio->revision == 5) {
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0037);
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x0053, 0x00B3);
-		bcm43xx_radio_write16(bcm, 0x0054, 0x009B);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005D, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005E, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x007D, 0x0088);
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODEFLAGS_OFFSET,
-				    (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODEFLAGS_OFFSET)
-				    | 0x00000200));
-	}
-	if (radio->revision == 8) {
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0040);
-		bcm43xx_radio_write16(bcm, 0x0053, 0x00B7);
-		bcm43xx_radio_write16(bcm, 0x0054, 0x0098);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x006B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x000F);
-		if (bcm->sprom.boardflags & 0x8000) {
-			bcm43xx_radio_write16(bcm, 0x005D, 0x00FA);
-			bcm43xx_radio_write16(bcm, 0x005E, 0x00D8);
-		} else {
-			bcm43xx_radio_write16(bcm, 0x005D, 0x00F5);
-			bcm43xx_radio_write16(bcm, 0x005E, 0x00B8);
-		}
-		bcm43xx_radio_write16(bcm, 0x0073, 0x0003);
-		bcm43xx_radio_write16(bcm, 0x007D, 0x00A8);
-		bcm43xx_radio_write16(bcm, 0x007C, 0x0001);
-		bcm43xx_radio_write16(bcm, 0x007E, 0x0008);
-	}
-	val = 0x1E1F;
-	for (offset = 0x0088; offset < 0x0098; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
-		val -= 0x0202;
-	}
-	val = 0x3E3F;
-	for (offset = 0x0098; offset < 0x00A8; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
-		val -= 0x0202;
-	}
-	val = 0x2120;
-	for (offset = 0x00A8; offset < 0x00C8; offset++) {
-		bcm43xx_phy_write(bcm, offset, (val & 0x3F3F));
-		val += 0x0202;
-	}
-	if (phy->type == BCM43xx_PHYTYPE_G) {
-		bcm43xx_radio_write16(bcm, 0x007A,
-		                      bcm43xx_radio_read16(bcm, 0x007A) | 0x0020);
-		bcm43xx_radio_write16(bcm, 0x0051,
-		                      bcm43xx_radio_read16(bcm, 0x0051) | 0x0004);
-		bcm43xx_phy_write(bcm, 0x0802,
-		                  bcm43xx_phy_read(bcm, 0x0802) | 0x0100);
-		bcm43xx_phy_write(bcm, 0x042B,
-		                  bcm43xx_phy_read(bcm, 0x042B) | 0x2000);
-		bcm43xx_phy_write(bcm, 0x5B, 0x0000);
-		bcm43xx_phy_write(bcm, 0x5C, 0x0000);
-	}
-
-	old_channel = radio->channel;
-	if (old_channel >= 8)
-		bcm43xx_radio_selectchannel(bcm, 1, 0);
-	else
-		bcm43xx_radio_selectchannel(bcm, 13, 0);
-
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
-	udelay(40);
-	if (radio->revision < 6 || radio-> revision == 8) {
-		bcm43xx_radio_write16(bcm, 0x007C, (bcm43xx_radio_read16(bcm, 0x007C)
-				      | 0x0002));
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	}
-	if (radio->revision <= 2) {
-		bcm43xx_radio_write16(bcm, 0x007C, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
-	}
-	bcm43xx_radio_write16(bcm, 0x007A,
-	                      (bcm43xx_radio_read16(bcm, 0x007A) & 0x00F8) | 0x0007);
-
-	bcm43xx_radio_selectchannel(bcm, old_channel, 0);
-
-	bcm43xx_phy_write(bcm, 0x0014, 0x0200);
-	if (radio->revision >= 6)
-		bcm43xx_phy_write(bcm, 0x002A, 0x88C2);
-	else
-		bcm43xx_phy_write(bcm, 0x002A, 0x8AC0);
-	bcm43xx_phy_write(bcm, 0x0038, 0x0668);
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
-	if (radio->revision <= 5)
-		bcm43xx_phy_write(bcm, 0x005D, (bcm43xx_phy_read(bcm, 0x005D)
-			          & 0xFF80) | 0x0003);
-	if (radio->revision <= 2)
-		bcm43xx_radio_write16(bcm, 0x005D, 0x000D);
-	
-	if (phy->analog == 4){
-		bcm43xx_write16(bcm, 0x03E4, 0x0009);
-		bcm43xx_phy_write(bcm, 0x61, bcm43xx_phy_read(bcm, 0x61) & 0xFFF);
-	} else {
-		bcm43xx_phy_write(bcm, 0x0002, (bcm43xx_phy_read(bcm, 0x0002) & 0xFFC0) | 0x0004);
-	}
-	if (phy->type == BCM43xx_PHYTYPE_G)
-		bcm43xx_write16(bcm, 0x03E6, 0x0);
-	if (phy->type == BCM43xx_PHYTYPE_B) {
-		bcm43xx_write16(bcm, 0x03E6, 0x8140);
-		bcm43xx_phy_write(bcm, 0x0016, 0x0410);
-		bcm43xx_phy_write(bcm, 0x0017, 0x0820);
-		bcm43xx_phy_write(bcm, 0x0062, 0x0007);
-		bcm43xx_radio_init2050(bcm);
-		bcm43xx_phy_lo_g_measure(bcm);
-		if (bcm->sprom.boardflags & BCM43xx_BFL_RSSI) {
-			bcm43xx_calc_nrssi_slope(bcm);
-			bcm43xx_calc_nrssi_threshold(bcm);
-		}
-		bcm43xx_phy_init_pctl(bcm);
-	}
-}
-
-static void bcm43xx_calc_loopback_gain(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 backup_phy[15] = {0};
-	u16 backup_radio[3];
-	u16 backup_bband;
-	u16 i;
-	u16 loop1_cnt, loop1_done, loop1_omitted;
-	u16 loop2_done;
-
-	backup_phy[0] = bcm43xx_phy_read(bcm, 0x0429);
-	backup_phy[1] = bcm43xx_phy_read(bcm, 0x0001);
-	backup_phy[2] = bcm43xx_phy_read(bcm, 0x0811);
-	backup_phy[3] = bcm43xx_phy_read(bcm, 0x0812);
-	if (phy->rev != 1) {
-		backup_phy[4] = bcm43xx_phy_read(bcm, 0x0814);
-		backup_phy[5] = bcm43xx_phy_read(bcm, 0x0815);
-	}
-	backup_phy[6] = bcm43xx_phy_read(bcm, 0x005A);
-	backup_phy[7] = bcm43xx_phy_read(bcm, 0x0059);
-	backup_phy[8] = bcm43xx_phy_read(bcm, 0x0058);
-	backup_phy[9] = bcm43xx_phy_read(bcm, 0x000A);
-	backup_phy[10] = bcm43xx_phy_read(bcm, 0x0003);
-	backup_phy[11] = bcm43xx_phy_read(bcm, 0x080F);
-	backup_phy[12] = bcm43xx_phy_read(bcm, 0x0810);
-	backup_phy[13] = bcm43xx_phy_read(bcm, 0x002B);
-	backup_phy[14] = bcm43xx_phy_read(bcm, 0x0015);
-	bcm43xx_phy_read(bcm, 0x002D); /* dummy read */
-	backup_bband = radio->baseband_atten;
-	backup_radio[0] = bcm43xx_radio_read16(bcm, 0x0052);
-	backup_radio[1] = bcm43xx_radio_read16(bcm, 0x0043);
-	backup_radio[2] = bcm43xx_radio_read16(bcm, 0x007A);
-
-	bcm43xx_phy_write(bcm, 0x0429,
-			  bcm43xx_phy_read(bcm, 0x0429) & 0x3FFF);
-	bcm43xx_phy_write(bcm, 0x0001,
-			  bcm43xx_phy_read(bcm, 0x0001) & 0x8000);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x0002);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) & 0xFFFD);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x0001);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) & 0xFFFE);
-	if (phy->rev != 1) {
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0001);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) & 0xFFFE);
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0002);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) & 0xFFFD);
-	}
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x000C);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) | 0x000C);
-
-	bcm43xx_phy_write(bcm, 0x0811,
-			  (bcm43xx_phy_read(bcm, 0x0811)
-			   & 0xFFCF) | 0x0030);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  (bcm43xx_phy_read(bcm, 0x0812)
-			   & 0xFFCF) | 0x0010);
-
-	bcm43xx_phy_write(bcm, 0x005A, 0x0780);
-	bcm43xx_phy_write(bcm, 0x0059, 0xC810);
-	bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-	if (phy->analog == 0) {
-		bcm43xx_phy_write(bcm, 0x0003, 0x0122);
-	} else {
-		bcm43xx_phy_write(bcm, 0x000A,
-				  bcm43xx_phy_read(bcm, 0x000A)
-				  | 0x2000);
-	}
-	if (phy->rev != 1) {
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0004);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) & 0xFFFB);
-	}
-	bcm43xx_phy_write(bcm, 0x0003,
-			  (bcm43xx_phy_read(bcm, 0x0003)
-			   & 0xFF9F) | 0x0040);
-	if (radio->version == 0x2050 && radio->revision == 2) {
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      (bcm43xx_radio_read16(bcm, 0x0043)
-				       & 0xFFF0) | 0x0009);
-		loop1_cnt = 9;
-	} else if (radio->revision == 8) {
-		bcm43xx_radio_write16(bcm, 0x0043, 0x000F);
-		loop1_cnt = 15;
-	} else
-		loop1_cnt = 0;
-
-	bcm43xx_phy_set_baseband_attenuation(bcm, 11);
-
-	if (phy->rev >= 3)
-		bcm43xx_phy_write(bcm, 0x080F, 0xC020);
-	else
-		bcm43xx_phy_write(bcm, 0x080F, 0x8020);
-	bcm43xx_phy_write(bcm, 0x0810, 0x0000);
-
-	bcm43xx_phy_write(bcm, 0x002B,
-			  (bcm43xx_phy_read(bcm, 0x002B)
-			   & 0xFFC0) | 0x0001);
-	bcm43xx_phy_write(bcm, 0x002B,
-			  (bcm43xx_phy_read(bcm, 0x002B)
-			   & 0xC0FF) | 0x0800);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x0100);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) & 0xCFFF);
-	if (bcm->sprom.boardflags & BCM43xx_BFL_EXTLNA) {
-		if (phy->rev >= 7) {
-			bcm43xx_phy_write(bcm, 0x0811,
-					  bcm43xx_phy_read(bcm, 0x0811)
-					  | 0x0800);
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_phy_read(bcm, 0x0812)
-					  | 0x8000);
-		}
-	}
-	bcm43xx_radio_write16(bcm, 0x007A,
-			      bcm43xx_radio_read16(bcm, 0x007A)
-			      & 0x00F7);
-
-	for (i = 0; i < loop1_cnt; i++) {
-		bcm43xx_radio_write16(bcm, 0x0043, loop1_cnt);
-		bcm43xx_phy_write(bcm, 0x0812,
-				  (bcm43xx_phy_read(bcm, 0x0812)
-				   & 0xF0FF) | (i << 8));
-		bcm43xx_phy_write(bcm, 0x0015,
-				  (bcm43xx_phy_read(bcm, 0x0015)
-				   & 0x0FFF) | 0xA000);
-		bcm43xx_phy_write(bcm, 0x0015,
-				  (bcm43xx_phy_read(bcm, 0x0015)
-				   & 0x0FFF) | 0xF000);
-		udelay(20);
-		if (bcm43xx_phy_read(bcm, 0x002D) >= 0x0DFC)
-			break;
-	}
-	loop1_done = i;
-	loop1_omitted = loop1_cnt - loop1_done;
-
-	loop2_done = 0;
-	if (loop1_done >= 8) {
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_phy_read(bcm, 0x0812)
-				  | 0x0030);
-		for (i = loop1_done - 8; i < 16; i++) {
-			bcm43xx_phy_write(bcm, 0x0812,
-					  (bcm43xx_phy_read(bcm, 0x0812)
-					   & 0xF0FF) | (i << 8));
-			bcm43xx_phy_write(bcm, 0x0015,
-					  (bcm43xx_phy_read(bcm, 0x0015)
-					   & 0x0FFF) | 0xA000);
-			bcm43xx_phy_write(bcm, 0x0015,
-					  (bcm43xx_phy_read(bcm, 0x0015)
-					   & 0x0FFF) | 0xF000);
-			udelay(20);
-			if (bcm43xx_phy_read(bcm, 0x002D) >= 0x0DFC)
-				break;
-		}
-	}
-
-	if (phy->rev != 1) {
-		bcm43xx_phy_write(bcm, 0x0814, backup_phy[4]);
-		bcm43xx_phy_write(bcm, 0x0815, backup_phy[5]);
-	}
-	bcm43xx_phy_write(bcm, 0x005A, backup_phy[6]);
-	bcm43xx_phy_write(bcm, 0x0059, backup_phy[7]);
-	bcm43xx_phy_write(bcm, 0x0058, backup_phy[8]);
-	bcm43xx_phy_write(bcm, 0x000A, backup_phy[9]);
-	bcm43xx_phy_write(bcm, 0x0003, backup_phy[10]);
-	bcm43xx_phy_write(bcm, 0x080F, backup_phy[11]);
-	bcm43xx_phy_write(bcm, 0x0810, backup_phy[12]);
-	bcm43xx_phy_write(bcm, 0x002B, backup_phy[13]);
-	bcm43xx_phy_write(bcm, 0x0015, backup_phy[14]);
-
-	bcm43xx_phy_set_baseband_attenuation(bcm, backup_bband);
-
-	bcm43xx_radio_write16(bcm, 0x0052, backup_radio[0]);
-	bcm43xx_radio_write16(bcm, 0x0043, backup_radio[1]);
-	bcm43xx_radio_write16(bcm, 0x007A, backup_radio[2]);
-
-	bcm43xx_phy_write(bcm, 0x0811, backup_phy[2] | 0x0003);
-	udelay(10);
-	bcm43xx_phy_write(bcm, 0x0811, backup_phy[2]);
-	bcm43xx_phy_write(bcm, 0x0812, backup_phy[3]);
-	bcm43xx_phy_write(bcm, 0x0429, backup_phy[0]);
-	bcm43xx_phy_write(bcm, 0x0001, backup_phy[1]);
-
-	phy->loopback_gain[0] = ((loop1_done * 6) - (loop1_omitted * 4)) - 11;
-	phy->loopback_gain[1] = (24 - (3 * loop2_done)) * 2;
-}
-
-static void bcm43xx_phy_initg(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 tmp;
-
-	if (phy->rev == 1)
-		bcm43xx_phy_initb5(bcm);
-	else
-		bcm43xx_phy_initb6(bcm);
-	if (phy->rev >= 2 || phy->connected)
-		bcm43xx_phy_inita(bcm);
-
-	if (phy->rev >= 2) {
-		bcm43xx_phy_write(bcm, 0x0814, 0x0000);
-		bcm43xx_phy_write(bcm, 0x0815, 0x0000);
-	}
-	if (phy->rev == 2) {
-		bcm43xx_phy_write(bcm, 0x0811, 0x0000);
-		bcm43xx_phy_write(bcm, 0x0015, 0x00C0);
-	}
-	if (phy->rev > 5) {
-		bcm43xx_phy_write(bcm, 0x0811, 0x0400);
-		bcm43xx_phy_write(bcm, 0x0015, 0x00C0);
-	}
-	if (phy->rev >= 2 && phy->connected) {
-		tmp = bcm43xx_phy_read(bcm, 0x0400) & 0xFF;
-		if (tmp ==3 || tmp == 5) {
-			bcm43xx_phy_write(bcm, 0x04C2, 0x1816);
-			bcm43xx_phy_write(bcm, 0x04C3, 0x8006);
-			if (tmp == 5) {
-				bcm43xx_phy_write(bcm, 0x04CC,
-						  (bcm43xx_phy_read(bcm, 0x04CC)
-						   & 0x00FF) | 0x1F00);
-			}
-		}
-		bcm43xx_phy_write(bcm, 0x047E, 0x0078);
-	}
-	if (radio->revision == 8) {
-		bcm43xx_phy_write(bcm, 0x0801, bcm43xx_phy_read(bcm, 0x0801) | 0x0080);
-		bcm43xx_phy_write(bcm, 0x043E, bcm43xx_phy_read(bcm, 0x043E) | 0x0004);
-	}
-	if (phy->rev >= 2 && phy->connected)
-		bcm43xx_calc_loopback_gain(bcm);
-	if (radio->revision != 8) {
-		if (radio->initval == 0xFFFF)
-			radio->initval = bcm43xx_radio_init2050(bcm);
-		else
-			bcm43xx_radio_write16(bcm, 0x0078, radio->initval);
-	}
-	if (radio->txctl2 == 0xFFFF) {
-		bcm43xx_phy_lo_g_measure(bcm);
-	} else {
-		if (radio->version == 0x2050 && radio->revision == 8) {
-			bcm43xx_radio_write16(bcm, 0x0052,
-					      (radio->txctl1 << 4) | radio->txctl2);
-		} else {
-			bcm43xx_radio_write16(bcm, 0x0052,
-					      (bcm43xx_radio_read16(bcm, 0x0052)
-					       & 0xFFF0) | radio->txctl1);
-		}
-		if (phy->rev >= 6) {
-			bcm43xx_phy_write(bcm, 0x0036,
-					  (bcm43xx_phy_read(bcm, 0x0036)
-					   & 0x0FFF) | (radio->txctl2 << 12));
-		}
-		if (bcm->sprom.boardflags & BCM43xx_BFL_PACTRL)
-			bcm43xx_phy_write(bcm, 0x002E, 0x8075);
-		else
-			bcm43xx_phy_write(bcm, 0x002E, 0x807F);
-		if (phy->rev < 2)
-			bcm43xx_phy_write(bcm, 0x002F, 0x0101);
-		else
-			bcm43xx_phy_write(bcm, 0x002F, 0x0202);
-	}
-	if (phy->connected || phy->rev >= 2) {
-		bcm43xx_phy_lo_adjust(bcm, 0);
-		bcm43xx_phy_write(bcm, 0x080F, 0x8078);
-	}
-
-	if (!(bcm->sprom.boardflags & BCM43xx_BFL_RSSI)) {
-		/* The specs state to update the NRSSI LT with
-		 * the value 0x7FFFFFFF here. I think that is some weird
-		 * compiler optimization in the original driver.
-		 * Essentially, what we do here is resetting all NRSSI LT
-		 * entries to -32 (see the limit_value() in nrssi_hw_update())
-		 */
-		bcm43xx_nrssi_hw_update(bcm, 0xFFFF);
-		bcm43xx_calc_nrssi_threshold(bcm);
-	} else if (phy->connected || phy->rev >= 2) {
-		if (radio->nrssi[0] == -1000) {
-			assert(radio->nrssi[1] == -1000);
-			bcm43xx_calc_nrssi_slope(bcm);
-		} else {
-			assert(radio->nrssi[1] != -1000);
-			bcm43xx_calc_nrssi_threshold(bcm);
-		}
-	}
-	if (radio->revision == 8)
-		bcm43xx_phy_write(bcm, 0x0805, 0x3230);
-	bcm43xx_phy_init_pctl(bcm);
-	if (bcm->chip_id == 0x4306 && bcm->chip_package == 2) {
-		bcm43xx_phy_write(bcm, 0x0429,
-				  bcm43xx_phy_read(bcm, 0x0429) & 0xBFFF);
-		bcm43xx_phy_write(bcm, 0x04C3,
-				  bcm43xx_phy_read(bcm, 0x04C3) & 0x7FFF);
-	}
-}
-
-static u16 bcm43xx_phy_lo_b_r15_loop(struct bcm43xx_private *bcm)
-{
-	int i;
-	u16 ret = 0;
-	unsigned long flags;
-
-	local_irq_save(flags);
-	for (i = 0; i < 10; i++){
-		bcm43xx_phy_write(bcm, 0x0015, 0xAFA0);
-		udelay(1);
-		bcm43xx_phy_write(bcm, 0x0015, 0xEFA0);
-		udelay(10);
-		bcm43xx_phy_write(bcm, 0x0015, 0xFFA0);
-		udelay(40);
-		ret += bcm43xx_phy_read(bcm, 0x002C);
-	}
-	local_irq_restore(flags);
-	bcm43xx_voluntary_preempt();
-
-	return ret;
-}
-
-void bcm43xx_phy_lo_b_measure(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 regstack[12] = { 0 };
-	u16 mls;
-	u16 fval;
-	int i, j;
-
-	regstack[0] = bcm43xx_phy_read(bcm, 0x0015);
-	regstack[1] = bcm43xx_radio_read16(bcm, 0x0052) & 0xFFF0;
-
-	if (radio->version == 0x2053) {
-		regstack[2] = bcm43xx_phy_read(bcm, 0x000A);
-		regstack[3] = bcm43xx_phy_read(bcm, 0x002A);
-		regstack[4] = bcm43xx_phy_read(bcm, 0x0035);
-		regstack[5] = bcm43xx_phy_read(bcm, 0x0003);
-		regstack[6] = bcm43xx_phy_read(bcm, 0x0001);
-		regstack[7] = bcm43xx_phy_read(bcm, 0x0030);
-
-		regstack[8] = bcm43xx_radio_read16(bcm, 0x0043);
-		regstack[9] = bcm43xx_radio_read16(bcm, 0x007A);
-		regstack[10] = bcm43xx_read16(bcm, 0x03EC);
-		regstack[11] = bcm43xx_radio_read16(bcm, 0x0052) & 0x00F0;
-
-		bcm43xx_phy_write(bcm, 0x0030, 0x00FF);
-		bcm43xx_write16(bcm, 0x03EC, 0x3F3F);
-		bcm43xx_phy_write(bcm, 0x0035, regstack[4] & 0xFF7F);
-		bcm43xx_radio_write16(bcm, 0x007A, regstack[9] & 0xFFF0);
-	}
-	bcm43xx_phy_write(bcm, 0x0015, 0xB000);
-	bcm43xx_phy_write(bcm, 0x002B, 0x0004);
-
-	if (radio->version == 0x2053) {
-		bcm43xx_phy_write(bcm, 0x002B, 0x0203);
-		bcm43xx_phy_write(bcm, 0x002A, 0x08A3);
-	}
-
-	phy->minlowsig[0] = 0xFFFF;
-
-	for (i = 0; i < 4; i++) {
-		bcm43xx_radio_write16(bcm, 0x0052, regstack[1] | i);
-		bcm43xx_phy_lo_b_r15_loop(bcm);
-	}
-	for (i = 0; i < 10; i++) {
-		bcm43xx_radio_write16(bcm, 0x0052, regstack[1] | i);
-		mls = bcm43xx_phy_lo_b_r15_loop(bcm) / 10;
-		if (mls < phy->minlowsig[0]) {
-			phy->minlowsig[0] = mls;
-			phy->minlowsigpos[0] = i;
-		}
-	}
-	bcm43xx_radio_write16(bcm, 0x0052, regstack[1] | phy->minlowsigpos[0]);
-
-	phy->minlowsig[1] = 0xFFFF;
-
-	for (i = -4; i < 5; i += 2) {
-		for (j = -4; j < 5; j += 2) {
-			if (j < 0)
-				fval = (0x0100 * i) + j + 0x0100;
-			else
-				fval = (0x0100 * i) + j;
-			bcm43xx_phy_write(bcm, 0x002F, fval);
-			mls = bcm43xx_phy_lo_b_r15_loop(bcm) / 10;
-			if (mls < phy->minlowsig[1]) {
-				phy->minlowsig[1] = mls;
-				phy->minlowsigpos[1] = fval;
-			}
-		}
-	}
-	phy->minlowsigpos[1] += 0x0101;
-
-	bcm43xx_phy_write(bcm, 0x002F, phy->minlowsigpos[1]);
-	if (radio->version == 0x2053) {
-		bcm43xx_phy_write(bcm, 0x000A, regstack[2]);
-		bcm43xx_phy_write(bcm, 0x002A, regstack[3]);
-		bcm43xx_phy_write(bcm, 0x0035, regstack[4]);
-		bcm43xx_phy_write(bcm, 0x0003, regstack[5]);
-		bcm43xx_phy_write(bcm, 0x0001, regstack[6]);
-		bcm43xx_phy_write(bcm, 0x0030, regstack[7]);
-
-		bcm43xx_radio_write16(bcm, 0x0043, regstack[8]);
-		bcm43xx_radio_write16(bcm, 0x007A, regstack[9]);
-
-		bcm43xx_radio_write16(bcm, 0x0052,
-		                      (bcm43xx_radio_read16(bcm, 0x0052) & 0x000F)
-				      | regstack[11]);
-
-		bcm43xx_write16(bcm, 0x03EC, regstack[10]);
-	}
-	bcm43xx_phy_write(bcm, 0x0015, regstack[0]);
-}
-
-static inline
-u16 bcm43xx_phy_lo_g_deviation_subval(struct bcm43xx_private *bcm, u16 control)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 ret;
-	unsigned long flags;
-
-	local_irq_save(flags);
-	if (phy->connected) {
-		bcm43xx_phy_write(bcm, 0x15, 0xE300);
-		control <<= 8;
-		bcm43xx_phy_write(bcm, 0x0812, control | 0x00B0);
-		udelay(5);
-		bcm43xx_phy_write(bcm, 0x0812, control | 0x00B2);
-		udelay(2);
-		bcm43xx_phy_write(bcm, 0x0812, control | 0x00B3);
-		udelay(4);
-		bcm43xx_phy_write(bcm, 0x0015, 0xF300);
-		udelay(8);
-	} else {
-		bcm43xx_phy_write(bcm, 0x0015, control | 0xEFA0);
-		udelay(2);
-		bcm43xx_phy_write(bcm, 0x0015, control | 0xEFE0);
-		udelay(4);
-		bcm43xx_phy_write(bcm, 0x0015, control | 0xFFE0);
-		udelay(8);
-	}
-	ret = bcm43xx_phy_read(bcm, 0x002D);
-	local_irq_restore(flags);
-	bcm43xx_voluntary_preempt();
-
-	return ret;
-}
-
-static u32 bcm43xx_phy_lo_g_singledeviation(struct bcm43xx_private *bcm, u16 control)
-{
-	int i;
-	u32 ret = 0;
-
-	for (i = 0; i < 8; i++)
-		ret += bcm43xx_phy_lo_g_deviation_subval(bcm, control);
-
-	return ret;
-}
-
-/* Write the LocalOscillator CONTROL */
-static inline
-void bcm43xx_lo_write(struct bcm43xx_private *bcm,
-		      struct bcm43xx_lopair *pair)
-{
-	u16 value;
-
-	value = (u8)(pair->low);
-	value |= ((u8)(pair->high)) << 8;
-
-#ifdef CONFIG_BCM43XX_DEBUG
-	/* Sanity check. */
-	if (pair->low < -8 || pair->low > 8 ||
-	    pair->high < -8 || pair->high > 8) {
-		printk(KERN_WARNING PFX
-		       "WARNING: Writing invalid LOpair "
-		       "(low: %d, high: %d, index: %lu)\n",
-		       pair->low, pair->high,
-		       (unsigned long)(pair - bcm43xx_current_phy(bcm)->_lo_pairs));
-		dump_stack();
-	}
-#endif
-
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_G_LO_CONTROL, value);
-}
-
-static inline
-struct bcm43xx_lopair * bcm43xx_find_lopair(struct bcm43xx_private *bcm,
-					    u16 baseband_attenuation,
-					    u16 radio_attenuation,
-					    u16 tx)
-{
-	static const u8 dict[10] = { 11, 10, 11, 12, 13, 12, 13, 12, 13, 12 };
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	if (baseband_attenuation > 6)
-		baseband_attenuation = 6;
-	assert(radio_attenuation < 10);
-
-	if (tx == 3) {
-		return bcm43xx_get_lopair(phy,
-					  radio_attenuation,
-					  baseband_attenuation);
-	}
-	return bcm43xx_get_lopair(phy, dict[radio_attenuation], baseband_attenuation);
-}
-
-static inline
-struct bcm43xx_lopair * bcm43xx_current_lopair(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-
-	return bcm43xx_find_lopair(bcm,
-				   radio->baseband_atten,
-				   radio->radio_atten,
-				   radio->txctl1);
-}
-
-/* Adjust B/G LO */
-void bcm43xx_phy_lo_adjust(struct bcm43xx_private *bcm, int fixed)
-{
-	struct bcm43xx_lopair *pair;
-
-	if (fixed) {
-		/* Use fixed values. Only for initialization. */
-		pair = bcm43xx_find_lopair(bcm, 2, 3, 0);
-	} else
-		pair = bcm43xx_current_lopair(bcm);
-	bcm43xx_lo_write(bcm, pair);
-}
-
-static void bcm43xx_phy_lo_g_measure_txctl2(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 txctl2 = 0, i;
-	u32 smallest, tmp;
-
-	bcm43xx_radio_write16(bcm, 0x0052, 0x0000);
-	udelay(10);
-	smallest = bcm43xx_phy_lo_g_singledeviation(bcm, 0);
-	for (i = 0; i < 16; i++) {
-		bcm43xx_radio_write16(bcm, 0x0052, i);
-		udelay(10);
-		tmp = bcm43xx_phy_lo_g_singledeviation(bcm, 0);
-		if (tmp < smallest) {
-			smallest = tmp;
-			txctl2 = i;
-		}
-	}
-	radio->txctl2 = txctl2;
-}
-
-static
-void bcm43xx_phy_lo_g_state(struct bcm43xx_private *bcm,
-			    const struct bcm43xx_lopair *in_pair,
-			    struct bcm43xx_lopair *out_pair,
-			    u16 r27)
-{
-	static const struct bcm43xx_lopair transitions[8] = {
-		{ .high =  1,  .low =  1, },
-		{ .high =  1,  .low =  0, },
-		{ .high =  1,  .low = -1, },
-		{ .high =  0,  .low = -1, },
-		{ .high = -1,  .low = -1, },
-		{ .high = -1,  .low =  0, },
-		{ .high = -1,  .low =  1, },
-		{ .high =  0,  .low =  1, },
-	};
-	struct bcm43xx_lopair lowest_transition = {
-		.high = in_pair->high,
-		.low = in_pair->low,
-	};
-	struct bcm43xx_lopair tmp_pair;
-	struct bcm43xx_lopair transition;
-	int i = 12;
-	int state = 0;
-	int found_lower;
-	int j, begin, end;
-	u32 lowest_deviation;
-	u32 tmp;
-
-	/* Note that in_pair and out_pair can point to the same pair. Be careful. */
-
-	bcm43xx_lo_write(bcm, &lowest_transition);
-	lowest_deviation = bcm43xx_phy_lo_g_singledeviation(bcm, r27);
-	do {
-		found_lower = 0;
-		assert(state >= 0 && state <= 8);
-		if (state == 0) {
-			begin = 1;
-			end = 8;
-		} else if (state % 2 == 0) {
-			begin = state - 1;
-			end = state + 1;
-		} else {
-			begin = state - 2;
-			end = state + 2;
-		}
-		if (begin < 1)
-			begin += 8;
-		if (end > 8)
-			end -= 8;
-
-		j = begin;
-		tmp_pair.high = lowest_transition.high;
-		tmp_pair.low = lowest_transition.low;
-		while (1) {
-			assert(j >= 1 && j <= 8);
-			transition.high = tmp_pair.high + transitions[j - 1].high;
-			transition.low = tmp_pair.low + transitions[j - 1].low;
-			if ((abs(transition.low) < 9) && (abs(transition.high) < 9)) {
-				bcm43xx_lo_write(bcm, &transition);
-				tmp = bcm43xx_phy_lo_g_singledeviation(bcm, r27);
-				if (tmp < lowest_deviation) {
-					lowest_deviation = tmp;
-					state = j;
-					found_lower = 1;
-
-					lowest_transition.high = transition.high;
-					lowest_transition.low = transition.low;
-				}
-			}
-			if (j == end)
-				break;
-			if (j == 8)
-				j = 1;
-			else
-				j++;
-		}
-	} while (i-- && found_lower);
-
-	out_pair->high = lowest_transition.high;
-	out_pair->low = lowest_transition.low;
-}
-
-/* Set the baseband attenuation value on chip. */
-void bcm43xx_phy_set_baseband_attenuation(struct bcm43xx_private *bcm,
-					  u16 baseband_attenuation)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 value;
-
-	if (phy->analog == 0) {
-		value = (bcm43xx_read16(bcm, 0x03E6) & 0xFFF0);
-		value |= (baseband_attenuation & 0x000F);
-		bcm43xx_write16(bcm, 0x03E6, value);
-		return;
-	}
-
-	if (phy->analog > 1) {
-		value = bcm43xx_phy_read(bcm, 0x0060) & ~0x003C;
-		value |= (baseband_attenuation << 2) & 0x003C;
-	} else {
-		value = bcm43xx_phy_read(bcm, 0x0060) & ~0x0078;
-		value |= (baseband_attenuation << 3) & 0x0078;
-	}
-	bcm43xx_phy_write(bcm, 0x0060, value);
-}
-
-/* http://bcm-specs.sipsolutions.net/LocalOscillator/Measure */
-void bcm43xx_phy_lo_g_measure(struct bcm43xx_private *bcm)
-{
-	static const u8 pairorder[10] = { 3, 1, 5, 7, 9, 2, 0, 4, 6, 8 };
-	const int is_initializing = (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZING);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 h, i, oldi = 0, j;
-	struct bcm43xx_lopair control;
-	struct bcm43xx_lopair *tmp_control;
-	u16 tmp;
-	u16 regstack[16] = { 0 };
-	u8 oldchannel;
-
-	//XXX: What are these?
-	u8 r27 = 0, r31;
-
-	oldchannel = radio->channel;
-	/* Setup */
-	if (phy->connected) {
-		regstack[0] = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS);
-		regstack[1] = bcm43xx_phy_read(bcm, 0x0802);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, regstack[0] & 0x7FFF);
-		bcm43xx_phy_write(bcm, 0x0802, regstack[1] & 0xFFFC);
-	}
-	regstack[3] = bcm43xx_read16(bcm, 0x03E2);
-	bcm43xx_write16(bcm, 0x03E2, regstack[3] | 0x8000);
-	regstack[4] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
-	regstack[5] = bcm43xx_phy_read(bcm, 0x15);
-	regstack[6] = bcm43xx_phy_read(bcm, 0x2A);
-	regstack[7] = bcm43xx_phy_read(bcm, 0x35);
-	regstack[8] = bcm43xx_phy_read(bcm, 0x60);
-	regstack[9] = bcm43xx_radio_read16(bcm, 0x43);
-	regstack[10] = bcm43xx_radio_read16(bcm, 0x7A);
-	regstack[11] = bcm43xx_radio_read16(bcm, 0x52);
-	if (phy->connected) {
-		regstack[12] = bcm43xx_phy_read(bcm, 0x0811);
-		regstack[13] = bcm43xx_phy_read(bcm, 0x0812);
-		regstack[14] = bcm43xx_phy_read(bcm, 0x0814);
-		regstack[15] = bcm43xx_phy_read(bcm, 0x0815);
-	}
-	bcm43xx_radio_selectchannel(bcm, 6, 0);
-	if (phy->connected) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, regstack[0] & 0x7FFF);
-		bcm43xx_phy_write(bcm, 0x0802, regstack[1] & 0xFFFC);
-		bcm43xx_dummy_transmission(bcm);
-	}
-	bcm43xx_radio_write16(bcm, 0x0043, 0x0006);
-
-	bcm43xx_phy_set_baseband_attenuation(bcm, 2);
-
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, 0x0000);
-	bcm43xx_phy_write(bcm, 0x002E, 0x007F);
-	bcm43xx_phy_write(bcm, 0x080F, 0x0078);
-	bcm43xx_phy_write(bcm, 0x0035, regstack[7] & ~(1 << 7));
-	bcm43xx_radio_write16(bcm, 0x007A, regstack[10] & 0xFFF0);
-	bcm43xx_phy_write(bcm, 0x002B, 0x0203);
-	bcm43xx_phy_write(bcm, 0x002A, 0x08A3);
-	if (phy->connected) {
-		bcm43xx_phy_write(bcm, 0x0814, regstack[14] | 0x0003);
-		bcm43xx_phy_write(bcm, 0x0815, regstack[15] & 0xFFFC);
-		bcm43xx_phy_write(bcm, 0x0811, 0x01B3);
-		bcm43xx_phy_write(bcm, 0x0812, 0x00B2);
-	}
-	if (is_initializing)
-		bcm43xx_phy_lo_g_measure_txctl2(bcm);
-	bcm43xx_phy_write(bcm, 0x080F, 0x8078);
-
-	/* Measure */
-	control.low = 0;
-	control.high = 0;
-	for (h = 0; h < 10; h++) {
-		/* Loop over each possible RadioAttenuation (0-9) */
-		i = pairorder[h];
-		if (is_initializing) {
-			if (i == 3) {
-				control.low = 0;
-				control.high = 0;
-			} else if (((i % 2 == 1) && (oldi % 2 == 1)) ||
-				  ((i % 2 == 0) && (oldi % 2 == 0))) {
-				tmp_control = bcm43xx_get_lopair(phy, oldi, 0);
-				memcpy(&control, tmp_control, sizeof(control));
-			} else {
-				tmp_control = bcm43xx_get_lopair(phy, 3, 0);
-				memcpy(&control, tmp_control, sizeof(control));
-			}
-		}
-		/* Loop over each possible BasebandAttenuation/2 */
-		for (j = 0; j < 4; j++) {
-			if (is_initializing) {
-				tmp = i * 2 + j;
-				r27 = 0;
-				r31 = 0;
-				if (tmp > 14) {
-					r31 = 1;
-					if (tmp > 17)
-						r27 = 1;
-					if (tmp > 19)
-						r27 = 2;
-				}
-			} else {
-				tmp_control = bcm43xx_get_lopair(phy, i, j * 2);
-				if (!tmp_control->used)
-					continue;
-				memcpy(&control, tmp_control, sizeof(control));
-				r27 = 3;
-				r31 = 0;
-			}
-			bcm43xx_radio_write16(bcm, 0x43, i);
-			bcm43xx_radio_write16(bcm, 0x52, radio->txctl2);
-			udelay(10);
-			bcm43xx_voluntary_preempt();
-
-			bcm43xx_phy_set_baseband_attenuation(bcm, j * 2);
-
-			tmp = (regstack[10] & 0xFFF0);
-			if (r31)
-				tmp |= 0x0008;
-			bcm43xx_radio_write16(bcm, 0x007A, tmp);
-
-			tmp_control = bcm43xx_get_lopair(phy, i, j * 2);
-			bcm43xx_phy_lo_g_state(bcm, &control, tmp_control, r27);
-		}
-		oldi = i;
-	}
-	/* Loop over each possible RadioAttenuation (10-13) */
-	for (i = 10; i < 14; i++) {
-		/* Loop over each possible BasebandAttenuation/2 */
-		for (j = 0; j < 4; j++) {
-			if (is_initializing) {
-				tmp_control = bcm43xx_get_lopair(phy, i - 9, j * 2);
-				memcpy(&control, tmp_control, sizeof(control));
-				tmp = (i - 9) * 2 + j - 5;//FIXME: This is wrong, as the following if statement can never trigger.
-				r27 = 0;
-				r31 = 0;
-				if (tmp > 14) {
-					r31 = 1;
-					if (tmp > 17)
-						r27 = 1;
-					if (tmp > 19)
-						r27 = 2;
-				}
-			} else {
-				tmp_control = bcm43xx_get_lopair(phy, i - 9, j * 2);
-				if (!tmp_control->used)
-					continue;
-				memcpy(&control, tmp_control, sizeof(control));
-				r27 = 3;
-				r31 = 0;
-			}
-			bcm43xx_radio_write16(bcm, 0x43, i - 9);
-			bcm43xx_radio_write16(bcm, 0x52,
-					      radio->txctl2
-					      | (3/*txctl1*/ << 4));//FIXME: shouldn't txctl1 be zero here and 3 in the loop above?
-			udelay(10);
-			bcm43xx_voluntary_preempt();
-
-			bcm43xx_phy_set_baseband_attenuation(bcm, j * 2);
-
-			tmp = (regstack[10] & 0xFFF0);
-			if (r31)
-				tmp |= 0x0008;
-			bcm43xx_radio_write16(bcm, 0x7A, tmp);
-
-			tmp_control = bcm43xx_get_lopair(phy, i, j * 2);
-			bcm43xx_phy_lo_g_state(bcm, &control, tmp_control, r27);
-		}
-	}
-
-	/* Restoration */
-	if (phy->connected) {
-		bcm43xx_phy_write(bcm, 0x0015, 0xE300);
-		bcm43xx_phy_write(bcm, 0x0812, (r27 << 8) | 0xA0);
-		udelay(5);
-		bcm43xx_phy_write(bcm, 0x0812, (r27 << 8) | 0xA2);
-		udelay(2);
-		bcm43xx_phy_write(bcm, 0x0812, (r27 << 8) | 0xA3);
-		bcm43xx_voluntary_preempt();
-	} else
-		bcm43xx_phy_write(bcm, 0x0015, r27 | 0xEFA0);
-	bcm43xx_phy_lo_adjust(bcm, is_initializing);
-	bcm43xx_phy_write(bcm, 0x002E, 0x807F);
-	if (phy->connected)
-		bcm43xx_phy_write(bcm, 0x002F, 0x0202);
-	else
-		bcm43xx_phy_write(bcm, 0x002F, 0x0101);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, regstack[4]);
-	bcm43xx_phy_write(bcm, 0x0015, regstack[5]);
-	bcm43xx_phy_write(bcm, 0x002A, regstack[6]);
-	bcm43xx_phy_write(bcm, 0x0035, regstack[7]);
-	bcm43xx_phy_write(bcm, 0x0060, regstack[8]);
-	bcm43xx_radio_write16(bcm, 0x0043, regstack[9]);
-	bcm43xx_radio_write16(bcm, 0x007A, regstack[10]);
-	regstack[11] &= 0x00F0;
-	regstack[11] |= (bcm43xx_radio_read16(bcm, 0x52) & 0x000F);
-	bcm43xx_radio_write16(bcm, 0x52, regstack[11]);
-	bcm43xx_write16(bcm, 0x03E2, regstack[3]);
-	if (phy->connected) {
-		bcm43xx_phy_write(bcm, 0x0811, regstack[12]);
-		bcm43xx_phy_write(bcm, 0x0812, regstack[13]);
-		bcm43xx_phy_write(bcm, 0x0814, regstack[14]);
-		bcm43xx_phy_write(bcm, 0x0815, regstack[15]);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, regstack[0]);
-		bcm43xx_phy_write(bcm, 0x0802, regstack[1]);
-	}
-	bcm43xx_radio_selectchannel(bcm, oldchannel, 1);
-
-#ifdef CONFIG_BCM43XX_DEBUG
-	{
-		/* Sanity check for all lopairs. */
-		for (i = 0; i < BCM43xx_LO_COUNT; i++) {
-			tmp_control = phy->_lo_pairs + i;
-			if (tmp_control->low < -8 || tmp_control->low > 8 ||
-			    tmp_control->high < -8 || tmp_control->high > 8) {
-				printk(KERN_WARNING PFX
-				       "WARNING: Invalid LOpair (low: %d, high: %d, index: %d)\n",
-				       tmp_control->low, tmp_control->high, i);
-			}
-		}
-	}
-#endif /* CONFIG_BCM43XX_DEBUG */
-}
-
-static
-void bcm43xx_phy_lo_mark_current_used(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_lopair *pair;
-
-	pair = bcm43xx_current_lopair(bcm);
-	pair->used = 1;
-}
-
-void bcm43xx_phy_lo_mark_all_unused(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_lopair *pair;
-	int i;
-
-	for (i = 0; i < BCM43xx_LO_COUNT; i++) {
-		pair = phy->_lo_pairs + i;
-		pair->used = 0;
-	}
-}
-
-/* http://bcm-specs.sipsolutions.net/EstimatePowerOut
- * This function converts a TSSI value to dBm in Q5.2
- */
-static s8 bcm43xx_phy_estimate_power_out(struct bcm43xx_private *bcm, s8 tssi)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	s8 dbm = 0;
-	s32 tmp;
-
-	tmp = phy->idle_tssi;
-	tmp += tssi;
-	tmp -= phy->savedpctlreg;
-
-	switch (phy->type) {
-		case BCM43xx_PHYTYPE_A:
-			tmp += 0x80;
-			tmp = limit_value(tmp, 0x00, 0xFF);
-			dbm = phy->tssi2dbm[tmp];
-			TODO(); //TODO: There's a FIXME on the specs
-			break;
-		case BCM43xx_PHYTYPE_B:
-		case BCM43xx_PHYTYPE_G:
-			tmp = limit_value(tmp, 0x00, 0x3F);
-			dbm = phy->tssi2dbm[tmp];
-			break;
-		default:
-			assert(0);
-	}
-
-	return dbm;
-}
-
-/* http://bcm-specs.sipsolutions.net/RecalculateTransmissionPower */
-void bcm43xx_phy_xmitpower(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	
-	if (phy->savedpctlreg == 0xFFFF)
-		return;
-	if ((bcm->board_type == 0x0416) &&
-	    (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM))
-		return;
-	
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A: {
-
-		TODO(); //TODO: Nothing for A PHYs yet :-/
-
-		break;
-	}
-	case BCM43xx_PHYTYPE_B:
-	case BCM43xx_PHYTYPE_G: {
-		u16 tmp;
-		u16 txpower;
-		s8 v0, v1, v2, v3;
-		s8 average;
-		u8 max_pwr;
-		s16 desired_pwr, estimated_pwr, pwr_adjust;
-		s16 radio_att_delta, baseband_att_delta;
-		s16 radio_attenuation, baseband_attenuation;
-		unsigned long phylock_flags;
-
-		tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0058);
-		v0 = (s8)(tmp & 0x00FF);
-		v1 = (s8)((tmp & 0xFF00) >> 8);
-		tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x005A);
-		v2 = (s8)(tmp & 0x00FF);
-		v3 = (s8)((tmp & 0xFF00) >> 8);
-		tmp = 0;
-
-		if (v0 == 0x7F || v1 == 0x7F || v2 == 0x7F || v3 == 0x7F) {
-			tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0070);
-			v0 = (s8)(tmp & 0x00FF);
-			v1 = (s8)((tmp & 0xFF00) >> 8);
-			tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0072);
-			v2 = (s8)(tmp & 0x00FF);
-			v3 = (s8)((tmp & 0xFF00) >> 8);
-			if (v0 == 0x7F || v1 == 0x7F || v2 == 0x7F || v3 == 0x7F)
-				return;
-			v0 = (v0 + 0x20) & 0x3F;
-			v1 = (v1 + 0x20) & 0x3F;
-			v2 = (v2 + 0x20) & 0x3F;
-			v3 = (v3 + 0x20) & 0x3F;
-			tmp = 1;
-		}
-		bcm43xx_radio_clear_tssi(bcm);
-
-		average = (v0 + v1 + v2 + v3 + 2) / 4;
-
-		if (tmp && (bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x005E) & 0x8))
-			average -= 13;
-
-		estimated_pwr = bcm43xx_phy_estimate_power_out(bcm, average);
-
-		max_pwr = bcm->sprom.maxpower_bgphy;
-
-		if ((bcm->sprom.boardflags & BCM43xx_BFL_PACTRL) &&
-		    (phy->type == BCM43xx_PHYTYPE_G))
-			max_pwr -= 0x3;
-
-		/*TODO:
-		max_pwr = min(REG - bcm->sprom.antennagain_bgphy - 0x6, max_pwr)
-			where REG is the max power as per the regulatory domain
-		*/
-
-		desired_pwr = limit_value(radio->txpower_desired, 0, max_pwr);
-		/* Check if we need to adjust the current power. */
-		pwr_adjust = desired_pwr - estimated_pwr;
-		radio_att_delta = -(pwr_adjust + 7) >> 3;
-		baseband_att_delta = -(pwr_adjust >> 1) - (4 * radio_att_delta);
-		if ((radio_att_delta == 0) && (baseband_att_delta == 0)) {
-			bcm43xx_phy_lo_mark_current_used(bcm);
-			return;
-		}
-
-		/* Calculate the new attenuation values. */
-		baseband_attenuation = radio->baseband_atten;
-		baseband_attenuation += baseband_att_delta;
-		radio_attenuation = radio->radio_atten;
-		radio_attenuation += radio_att_delta;
-
-		/* Get baseband and radio attenuation values into their permitted ranges.
-		 * baseband 0-11, radio 0-9.
-		 * Radio attenuation affects power level 4 times as much as baseband.
-		 */
-		if (radio_attenuation < 0) {
-			baseband_attenuation -= (4 * -radio_attenuation);
-			radio_attenuation = 0;
-		} else if (radio_attenuation > 9) {
-			baseband_attenuation += (4 * (radio_attenuation - 9));
-			radio_attenuation = 9;
-		} else {
-			while (baseband_attenuation < 0 && radio_attenuation > 0) {
-				baseband_attenuation += 4;
-				radio_attenuation--;
-			}
-			while (baseband_attenuation > 11 && radio_attenuation < 9) {
-				baseband_attenuation -= 4;
-				radio_attenuation++;
-			}
-		}
-		baseband_attenuation = limit_value(baseband_attenuation, 0, 11);
-
-		txpower = radio->txctl1;
-		if ((radio->version == 0x2050) && (radio->revision == 2)) {
-			if (radio_attenuation <= 1) {
-				if (txpower == 0) {
-					txpower = 3;
-					radio_attenuation += 2;
-					baseband_attenuation += 2;
-				} else if (bcm->sprom.boardflags & BCM43xx_BFL_PACTRL) {
-					baseband_attenuation += 4 * (radio_attenuation - 2);
-					radio_attenuation = 2;
-				}
-			} else if (radio_attenuation > 4 && txpower != 0) {
-				txpower = 0;
-				if (baseband_attenuation < 3) {
-					radio_attenuation -= 3;
-					baseband_attenuation += 2;
-				} else {
-					radio_attenuation -= 2;
-					baseband_attenuation -= 2;
-				}
-			}
-		}
-		radio->txctl1 = txpower;
-		baseband_attenuation = limit_value(baseband_attenuation, 0, 11);
-		radio_attenuation = limit_value(radio_attenuation, 0, 9);
-
-		bcm43xx_phy_lock(bcm, phylock_flags);
-		bcm43xx_radio_lock(bcm);
-		bcm43xx_radio_set_txpower_bg(bcm, baseband_attenuation,
-					     radio_attenuation, txpower);
-		bcm43xx_phy_lo_mark_current_used(bcm);
-		bcm43xx_radio_unlock(bcm);
-		bcm43xx_phy_unlock(bcm, phylock_flags);
-		break;
-	}
-	default:
-		assert(0);
-	}
-}
-
-static inline
-s32 bcm43xx_tssi2dbm_ad(s32 num, s32 den)
-{
-	if (num < 0)
-		return num/den;
-	else
-		return (num+den/2)/den;
-}
-
-static inline
-s8 bcm43xx_tssi2dbm_entry(s8 entry [], u8 index, s16 pab0, s16 pab1, s16 pab2)
-{
-	s32 m1, m2, f = 256, q, delta;
-	s8 i = 0;
-	
-	m1 = bcm43xx_tssi2dbm_ad(16 * pab0 + index * pab1, 32);
-	m2 = max(bcm43xx_tssi2dbm_ad(32768 + index * pab2, 256), 1);
-	do {
-		if (i > 15)
-			return -EINVAL;
-		q = bcm43xx_tssi2dbm_ad(f * 4096 -
-					bcm43xx_tssi2dbm_ad(m2 * f, 16) * f, 2048);
-		delta = abs(q - f);
-		f = q;
-		i++;
-	} while (delta >= 2);
-	entry[index] = limit_value(bcm43xx_tssi2dbm_ad(m1 * f, 8192), -127, 128);
-	return 0;
-}
-
-/* http://bcm-specs.sipsolutions.net/TSSI_to_DBM_Table */
-int bcm43xx_phy_init_tssi2dbm_table(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	s16 pab0, pab1, pab2;
-	u8 idx;
-	s8 *dyn_tssi2dbm;
-	
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		pab0 = (s16)(bcm->sprom.pa1b0);
-		pab1 = (s16)(bcm->sprom.pa1b1);
-		pab2 = (s16)(bcm->sprom.pa1b2);
-	} else {
-		pab0 = (s16)(bcm->sprom.pa0b0);
-		pab1 = (s16)(bcm->sprom.pa0b1);
-		pab2 = (s16)(bcm->sprom.pa0b2);
-	}
-
-	if ((bcm->chip_id == 0x4301) && (radio->version != 0x2050)) {
-		phy->idle_tssi = 0x34;
-		phy->tssi2dbm = bcm43xx_tssi2dbm_b_table;
-		return 0;
-	}
-
-	if (pab0 != 0 && pab1 != 0 && pab2 != 0 &&
-	    pab0 != -1 && pab1 != -1 && pab2 != -1) {
-		/* The pabX values are set in SPROM. Use them. */
-		if (phy->type == BCM43xx_PHYTYPE_A) {
-			if ((s8)bcm->sprom.idle_tssi_tgt_aphy != 0 &&
-			    (s8)bcm->sprom.idle_tssi_tgt_aphy != -1)
-				phy->idle_tssi = (s8)(bcm->sprom.idle_tssi_tgt_aphy);
-			else
-				phy->idle_tssi = 62;
-		} else {
-			if ((s8)bcm->sprom.idle_tssi_tgt_bgphy != 0 &&
-			    (s8)bcm->sprom.idle_tssi_tgt_bgphy != -1)
-				phy->idle_tssi = (s8)(bcm->sprom.idle_tssi_tgt_bgphy);
-			else
-				phy->idle_tssi = 62;
-		}
-		dyn_tssi2dbm = kmalloc(64, GFP_KERNEL);
-		if (dyn_tssi2dbm == NULL) {
-			printk(KERN_ERR PFX "Could not allocate memory"
-					    "for tssi2dbm table\n");
-			return -ENOMEM;
-		}
-		for (idx = 0; idx < 64; idx++)
-			if (bcm43xx_tssi2dbm_entry(dyn_tssi2dbm, idx, pab0, pab1, pab2)) {
-				phy->tssi2dbm = NULL;
-				printk(KERN_ERR PFX "Could not generate "
-						    "tssi2dBm table\n");
-				kfree(dyn_tssi2dbm);
-				return -ENODEV;
-			}
-		phy->tssi2dbm = dyn_tssi2dbm;
-		phy->dyn_tssi_tbl = 1;
-	} else {
-		/* pabX values not set in SPROM. */
-		switch (phy->type) {
-		case BCM43xx_PHYTYPE_A:
-			/* APHY needs a generated table. */
-			phy->tssi2dbm = NULL;
-			printk(KERN_ERR PFX "Could not generate tssi2dBm "
-					    "table (wrong SPROM info)!\n");
-			return -ENODEV;
-		case BCM43xx_PHYTYPE_B:
-			phy->idle_tssi = 0x34;
-			phy->tssi2dbm = bcm43xx_tssi2dbm_b_table;
-			break;
-		case BCM43xx_PHYTYPE_G:
-			phy->idle_tssi = 0x34;
-			phy->tssi2dbm = bcm43xx_tssi2dbm_g_table;
-			break;
-		}
-	}
-
-	return 0;
-}
-
-int bcm43xx_phy_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	int err = -ENODEV;
-
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		if (phy->rev == 2 || phy->rev == 3) {
-			bcm43xx_phy_inita(bcm);
-			err = 0;
-		}
-		break;
-	case BCM43xx_PHYTYPE_B:
-		switch (phy->rev) {
-		case 2:
-			bcm43xx_phy_initb2(bcm);
-			err = 0;
-			break;
-		case 4:
-			bcm43xx_phy_initb4(bcm);
-			err = 0;
-			break;
-		case 5:
-			bcm43xx_phy_initb5(bcm);
-			err = 0;
-			break;
-		case 6:
-			bcm43xx_phy_initb6(bcm);
-			err = 0;
-			break;
-		}
-		break;
-	case BCM43xx_PHYTYPE_G:
-		bcm43xx_phy_initg(bcm);
-		err = 0;
-		break;
-	}
-	if (err)
-		printk(KERN_WARNING PFX "Unknown PHYTYPE found!\n");
-
-	return err;
-}
-
-void bcm43xx_phy_set_antenna_diversity(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 antennadiv;
-	u16 offset;
-	u16 value;
-	u32 ucodeflags;
-
-	antennadiv = phy->antenna_diversity;
-
-	if (antennadiv == 0xFFFF)
-		antennadiv = 3;
-	assert(antennadiv <= 3);
-
-	ucodeflags = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-					BCM43xx_UCODEFLAGS_OFFSET);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-			    BCM43xx_UCODEFLAGS_OFFSET,
-			    ucodeflags & ~BCM43xx_UCODEFLAG_AUTODIV);
-
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-	case BCM43xx_PHYTYPE_G:
-		if (phy->type == BCM43xx_PHYTYPE_A)
-			offset = 0x0000;
-		else
-			offset = 0x0400;
-
-		if (antennadiv == 2)
-			value = (3/*automatic*/ << 7);
-		else
-			value = (antennadiv << 7);
-		bcm43xx_phy_write(bcm, offset + 1,
-				  (bcm43xx_phy_read(bcm, offset + 1)
-				   & 0x7E7F) | value);
-
-		if (antennadiv >= 2) {
-			if (antennadiv == 2)
-				value = (antennadiv << 7);
-			else
-				value = (0/*force0*/ << 7);
-			bcm43xx_phy_write(bcm, offset + 0x2B,
-					  (bcm43xx_phy_read(bcm, offset + 0x2B)
-					   & 0xFEFF) | value);
-		}
-
-		if (phy->type == BCM43xx_PHYTYPE_G) {
-			if (antennadiv >= 2)
-				bcm43xx_phy_write(bcm, 0x048C,
-						  bcm43xx_phy_read(bcm, 0x048C)
-						   | 0x2000);
-			else
-				bcm43xx_phy_write(bcm, 0x048C,
-						  bcm43xx_phy_read(bcm, 0x048C)
-						   & ~0x2000);
-			if (phy->rev >= 2) {
-				bcm43xx_phy_write(bcm, 0x0461,
-						  bcm43xx_phy_read(bcm, 0x0461)
-						   | 0x0010);
-				bcm43xx_phy_write(bcm, 0x04AD,
-						  (bcm43xx_phy_read(bcm, 0x04AD)
-						   & 0x00FF) | 0x0015);
-				if (phy->rev == 2)
-					bcm43xx_phy_write(bcm, 0x0427, 0x0008);
-				else
-					bcm43xx_phy_write(bcm, 0x0427,
-						(bcm43xx_phy_read(bcm, 0x0427)
-						 & 0x00FF) | 0x0008);
-			}
-			else if (phy->rev >= 6)
-				bcm43xx_phy_write(bcm, 0x049B, 0x00DC);
-		} else {
-			if (phy->rev < 3)
-				bcm43xx_phy_write(bcm, 0x002B,
-						  (bcm43xx_phy_read(bcm, 0x002B)
-						   & 0x00FF) | 0x0024);
-			else {
-				bcm43xx_phy_write(bcm, 0x0061,
-						  bcm43xx_phy_read(bcm, 0x0061)
-						   | 0x0010);
-				if (phy->rev == 3) {
-					bcm43xx_phy_write(bcm, 0x0093, 0x001D);
-					bcm43xx_phy_write(bcm, 0x0027, 0x0008);
-				} else {
-					bcm43xx_phy_write(bcm, 0x0093, 0x003A);
-					bcm43xx_phy_write(bcm, 0x0027,
-						(bcm43xx_phy_read(bcm, 0x0027)
-						 & 0x00FF) | 0x0008);
-				}
-			}
-		}
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if (bcm->current_core->rev == 2)
-			value = (3/*automatic*/ << 7);
-		else
-			value = (antennadiv << 7);
-		bcm43xx_phy_write(bcm, 0x03E2,
-				  (bcm43xx_phy_read(bcm, 0x03E2)
-				   & 0xFE7F) | value);
-		break;
-	default:
-		assert(0);
-	}
-
-	if (antennadiv >= 2) {
-		ucodeflags = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-						BCM43xx_UCODEFLAGS_OFFSET);
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODEFLAGS_OFFSET,
-				    ucodeflags | BCM43xx_UCODEFLAG_AUTODIV);
-	}
-
-	phy->antenna_diversity = antennadiv;
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_phy.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef BCM43xx_PHY_H_
-#define BCM43xx_PHY_H_
-
-#include <linux/types.h>
-
-struct bcm43xx_private;
-
-void bcm43xx_raw_phy_lock(struct bcm43xx_private *bcm);
-#define bcm43xx_phy_lock(bcm, flags) \
-	do {					\
-		local_irq_save(flags);		\
-		bcm43xx_raw_phy_lock(bcm);	\
-	} while (0)
-void bcm43xx_raw_phy_unlock(struct bcm43xx_private *bcm);
-#define bcm43xx_phy_unlock(bcm, flags) \
-	do {					\
-		bcm43xx_raw_phy_unlock(bcm);	\
-		local_irq_restore(flags);	\
-	} while (0)
-
-/* Card uses the loopback gain stuff */
-#define has_loopback_gain(phy) \
-        (((phy)->rev > 1) || ((phy)->connected))
-
-u16 bcm43xx_phy_read(struct bcm43xx_private *bcm, u16 offset);
-void bcm43xx_phy_write(struct bcm43xx_private *bcm, u16 offset, u16 val);
-
-int bcm43xx_phy_init_tssi2dbm_table(struct bcm43xx_private *bcm);
-int bcm43xx_phy_init(struct bcm43xx_private *bcm);
-
-void bcm43xx_phy_set_antenna_diversity(struct bcm43xx_private *bcm);
-void bcm43xx_phy_calibrate(struct bcm43xx_private *bcm);
-int bcm43xx_phy_connect(struct bcm43xx_private *bcm, int connect);
-
-void bcm43xx_phy_lo_b_measure(struct bcm43xx_private *bcm);
-void bcm43xx_phy_lo_g_measure(struct bcm43xx_private *bcm);
-void bcm43xx_phy_xmitpower(struct bcm43xx_private *bcm);
-
-/* Adjust the LocalOscillator to the saved values.
- * "fixed" is only set to 1 once in initialization. Set to 0 otherwise.
- */
-void bcm43xx_phy_lo_adjust(struct bcm43xx_private *bcm, int fixed);
-void bcm43xx_phy_lo_mark_all_unused(struct bcm43xx_private *bcm);
-
-void bcm43xx_phy_set_baseband_attenuation(struct bcm43xx_private *bcm,
-					  u16 baseband_attenuation);
-
-#endif /* BCM43xx_PHY_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_pio.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_pio.c
+++ /dev/null
@@ -1,674 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  PIO Transmission
-
-  Copyright (c) 2005 Michael Buesch <mbuesch at freenet.de>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include "bcm43xx.h"
-#include "bcm43xx_pio.h"
-#include "bcm43xx_main.h"
-#include "bcm43xx_xmit.h"
-#include "bcm43xx_power.h"
-
-#include <linux/delay.h>
-
-
-static void tx_start(struct bcm43xx_pioqueue *queue)
-{
-	bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-			  BCM43xx_PIO_TXCTL_INIT);
-}
-
-static void tx_octet(struct bcm43xx_pioqueue *queue,
-		     u8 octet)
-{
-	if (queue->need_workarounds) {
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA,
-				  octet);
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-				  BCM43xx_PIO_TXCTL_WRITELO);
-	} else {
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-				  BCM43xx_PIO_TXCTL_WRITELO);
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA,
-				  octet);
-	}
-}
-
-static u16 tx_get_next_word(struct bcm43xx_txhdr *txhdr,
-			    const u8 *packet,
-			    unsigned int *pos)
-{
-	const u8 *source;
-	unsigned int i = *pos;
-	u16 ret;
-
-	if (i < sizeof(*txhdr)) {
-		source = (const u8 *)txhdr;
-	} else {
-		source = packet;
-		i -= sizeof(*txhdr);
-	}
-	ret = le16_to_cpu( *((u16 *)(source + i)) );
-	*pos += 2;
-
-	return ret;
-}
-
-static void tx_data(struct bcm43xx_pioqueue *queue,
-		    struct bcm43xx_txhdr *txhdr,
-		    const u8 *packet,
-		    unsigned int octets)
-{
-	u16 data;
-	unsigned int i = 0;
-
-	if (queue->need_workarounds) {
-		data = tx_get_next_word(txhdr, packet, &i);
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA, data);
-	}
-	bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-			  BCM43xx_PIO_TXCTL_WRITELO |
-			  BCM43xx_PIO_TXCTL_WRITEHI);
-	while (i < octets - 1) {
-		data = tx_get_next_word(txhdr, packet, &i);
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA, data);
-	}
-	if (octets % 2)
-		tx_octet(queue, packet[octets - sizeof(*txhdr) - 1]);
-}
-
-static void tx_complete(struct bcm43xx_pioqueue *queue,
-			struct sk_buff *skb)
-{
-	if (queue->need_workarounds) {
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA,
-				  skb->data[skb->len - 1]);
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-				  BCM43xx_PIO_TXCTL_WRITELO |
-				  BCM43xx_PIO_TXCTL_COMPLETE);
-	} else {
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-				  BCM43xx_PIO_TXCTL_COMPLETE);
-	}
-}
-
-static u16 generate_cookie(struct bcm43xx_pioqueue *queue,
-			   struct bcm43xx_pio_txpacket *packet)
-{
-	u16 cookie = 0x0000;
-	int packetindex;
-
-	/* We use the upper 4 bits for the PIO
-	 * controller ID and the lower 12 bits
-	 * for the packet index (in the cache).
-	 */
-	switch (queue->mmio_base) {
-	case BCM43xx_MMIO_PIO1_BASE:
-		break;
-	case BCM43xx_MMIO_PIO2_BASE:
-		cookie = 0x1000;
-		break;
-	case BCM43xx_MMIO_PIO3_BASE:
-		cookie = 0x2000;
-		break;
-	case BCM43xx_MMIO_PIO4_BASE:
-		cookie = 0x3000;
-		break;
-	default:
-		assert(0);
-	}
-	packetindex = pio_txpacket_getindex(packet);
-	assert(((u16)packetindex & 0xF000) == 0x0000);
-	cookie |= (u16)packetindex;
-
-	return cookie;
-}
-
-static
-struct bcm43xx_pioqueue * parse_cookie(struct bcm43xx_private *bcm,
-				       u16 cookie,
-				       struct bcm43xx_pio_txpacket **packet)
-{
-	struct bcm43xx_pio *pio = bcm43xx_current_pio(bcm);
-	struct bcm43xx_pioqueue *queue = NULL;
-	int packetindex;
-
-	switch (cookie & 0xF000) {
-	case 0x0000:
-		queue = pio->queue0;
-		break;
-	case 0x1000:
-		queue = pio->queue1;
-		break;
-	case 0x2000:
-		queue = pio->queue2;
-		break;
-	case 0x3000:
-		queue = pio->queue3;
-		break;
-	default:
-		assert(0);
-	}
-	packetindex = (cookie & 0x0FFF);
-	assert(packetindex >= 0 && packetindex < BCM43xx_PIO_MAXTXPACKETS);
-	*packet = &(queue->tx_packets_cache[packetindex]);
-
-	return queue;
-}
-
-static void pio_tx_write_fragment(struct bcm43xx_pioqueue *queue,
-				  struct sk_buff *skb,
-				  struct bcm43xx_pio_txpacket *packet)
-{
-	struct bcm43xx_txhdr txhdr;
-	unsigned int octets;
-
-	assert(skb_shinfo(skb)->nr_frags == 0);
-	bcm43xx_generate_txhdr(queue->bcm,
-			       &txhdr, skb->data, skb->len,
-			       (packet->xmitted_frags == 0),
-			       generate_cookie(queue, packet));
-
-	tx_start(queue);
-	octets = skb->len + sizeof(txhdr);
-	if (queue->need_workarounds)
-		octets--;
-	tx_data(queue, &txhdr, (u8 *)skb->data, octets);
-	tx_complete(queue, skb);
-}
-
-static void free_txpacket(struct bcm43xx_pio_txpacket *packet,
-			  int irq_context)
-{
-	struct bcm43xx_pioqueue *queue = packet->queue;
-
-	ieee80211_txb_free(packet->txb);
-	list_move(&packet->list, &queue->txfree);
-	queue->nr_txfree++;
-
-	assert(queue->tx_devq_used >= packet->xmitted_octets);
-	assert(queue->tx_devq_packets >= packet->xmitted_frags);
-	queue->tx_devq_used -= packet->xmitted_octets;
-	queue->tx_devq_packets -= packet->xmitted_frags;
-}
-
-static int pio_tx_packet(struct bcm43xx_pio_txpacket *packet)
-{
-	struct bcm43xx_pioqueue *queue = packet->queue;
-	struct ieee80211_txb *txb = packet->txb;
-	struct sk_buff *skb;
-	u16 octets;
-	int i;
-
-	for (i = packet->xmitted_frags; i < txb->nr_frags; i++) {
-		skb = txb->fragments[i];
-
-		octets = (u16)skb->len + sizeof(struct bcm43xx_txhdr);
-		assert(queue->tx_devq_size >= octets);
-		assert(queue->tx_devq_packets <= BCM43xx_PIO_MAXTXDEVQPACKETS);
-		assert(queue->tx_devq_used <= queue->tx_devq_size);
-		/* Check if there is sufficient free space on the device
-		 * TX queue. If not, return and let the TX tasklet
-		 * retry later.
-		 */
-		if (queue->tx_devq_packets == BCM43xx_PIO_MAXTXDEVQPACKETS)
-			return -EBUSY;
-		if (queue->tx_devq_used + octets > queue->tx_devq_size)
-			return -EBUSY;
-		/* Now poke the device. */
-		pio_tx_write_fragment(queue, skb, packet);
-
-		/* Account for the packet size.
-		 * (We must not overflow the device TX queue)
-		 */
-		queue->tx_devq_packets++;
-		queue->tx_devq_used += octets;
-
-		assert(packet->xmitted_frags < packet->txb->nr_frags);
-		packet->xmitted_frags++;
-		packet->xmitted_octets += octets;
-	}
-	list_move_tail(&packet->list, &queue->txrunning);
-
-	return 0;
-}
-
-static void tx_tasklet(unsigned long d)
-{
-	struct bcm43xx_pioqueue *queue = (struct bcm43xx_pioqueue *)d;
-	struct bcm43xx_private *bcm = queue->bcm;
-	unsigned long flags;
-	struct bcm43xx_pio_txpacket *packet, *tmp_packet;
-	int err;
-	u16 txctl;
-
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-
-	if (queue->tx_frozen)
-		goto out_unlock;
-	txctl = bcm43xx_pio_read(queue, BCM43xx_PIO_TXCTL);
-	if (txctl & BCM43xx_PIO_TXCTL_SUSPEND)
-		goto out_unlock;
-
-	list_for_each_entry_safe(packet, tmp_packet, &queue->txqueue, list) {
-		assert(packet->xmitted_frags < packet->txb->nr_frags);
-		if (packet->xmitted_frags == 0) {
-			int i;
-			struct sk_buff *skb;
-
-			/* Check if the device queue is big
-			 * enough for every fragment. If not, drop the
-			 * whole packet.
-			 */
-			for (i = 0; i < packet->txb->nr_frags; i++) {
-				skb = packet->txb->fragments[i];
-				if (unlikely(skb->len > queue->tx_devq_size)) {
-					dprintkl(KERN_ERR PFX "PIO TX device queue too small. "
-							      "Dropping packet.\n");
-					free_txpacket(packet, 1);
-					goto next_packet;
-				}
-			}
-		}
-		/* Try to transmit the packet.
-		 * This may not completely succeed.
-		 */
-		err = pio_tx_packet(packet);
-		if (err)
-			break;
-	next_packet:
-		continue;
-	}
-out_unlock:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-}
-
-static void setup_txqueues(struct bcm43xx_pioqueue *queue)
-{
-	struct bcm43xx_pio_txpacket *packet;
-	int i;
-
-	queue->nr_txfree = BCM43xx_PIO_MAXTXPACKETS;
-	for (i = 0; i < BCM43xx_PIO_MAXTXPACKETS; i++) {
-		packet = &(queue->tx_packets_cache[i]);
-
-		packet->queue = queue;
-		INIT_LIST_HEAD(&packet->list);
-
-		list_add(&packet->list, &queue->txfree);
-	}
-}
-
-static
-struct bcm43xx_pioqueue * bcm43xx_setup_pioqueue(struct bcm43xx_private *bcm,
-						 u16 pio_mmio_base)
-{
-	struct bcm43xx_pioqueue *queue;
-	u32 value;
-	u16 qsize;
-
-	queue = kzalloc(sizeof(*queue), GFP_KERNEL);
-	if (!queue)
-		goto out;
-
-	queue->bcm = bcm;
-	queue->mmio_base = pio_mmio_base;
-	queue->need_workarounds = (bcm->current_core->rev < 3);
-
-	INIT_LIST_HEAD(&queue->txfree);
-	INIT_LIST_HEAD(&queue->txqueue);
-	INIT_LIST_HEAD(&queue->txrunning);
-	tasklet_init(&queue->txtask, tx_tasklet,
-		     (unsigned long)queue);
-
-	value = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	value &= ~BCM43xx_SBF_XFER_REG_BYTESWAP;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value);
-
-	qsize = bcm43xx_read16(bcm, queue->mmio_base + BCM43xx_PIO_TXQBUFSIZE);
-	if (qsize == 0) {
-		printk(KERN_ERR PFX "ERROR: This card does not support PIO "
-				    "operation mode. Please use DMA mode "
-				    "(module parameter pio=0).\n");
-		goto err_freequeue;
-	}
-	if (qsize <= BCM43xx_PIO_TXQADJUST) {
-		printk(KERN_ERR PFX "PIO tx device-queue too small (%u)\n",
-		       qsize);
-		goto err_freequeue;
-	}
-	qsize -= BCM43xx_PIO_TXQADJUST;
-	queue->tx_devq_size = qsize;
-
-	setup_txqueues(queue);
-
-out:
-	return queue;
-
-err_freequeue:
-	kfree(queue);
-	queue = NULL;
-	goto out;
-}
-
-static void cancel_transfers(struct bcm43xx_pioqueue *queue)
-{
-	struct bcm43xx_pio_txpacket *packet, *tmp_packet;
-
-	netif_tx_disable(queue->bcm->net_dev);
-	tasklet_disable(&queue->txtask);
-
-	list_for_each_entry_safe(packet, tmp_packet, &queue->txrunning, list)
-		free_txpacket(packet, 0);
-	list_for_each_entry_safe(packet, tmp_packet, &queue->txqueue, list)
-		free_txpacket(packet, 0);
-}
-
-static void bcm43xx_destroy_pioqueue(struct bcm43xx_pioqueue *queue)
-{
-	if (!queue)
-		return;
-
-	cancel_transfers(queue);
-	kfree(queue);
-}
-
-void bcm43xx_pio_free(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_pio *pio;
-
-	if (!bcm43xx_using_pio(bcm))
-		return;
-	pio = bcm43xx_current_pio(bcm);
-
-	bcm43xx_destroy_pioqueue(pio->queue3);
-	pio->queue3 = NULL;
-	bcm43xx_destroy_pioqueue(pio->queue2);
-	pio->queue2 = NULL;
-	bcm43xx_destroy_pioqueue(pio->queue1);
-	pio->queue1 = NULL;
-	bcm43xx_destroy_pioqueue(pio->queue0);
-	pio->queue0 = NULL;
-}
-
-int bcm43xx_pio_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_pio *pio = bcm43xx_current_pio(bcm);
-	struct bcm43xx_pioqueue *queue;
-	int err = -ENOMEM;
-
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO1_BASE);
-	if (!queue)
-		goto out;
-	pio->queue0 = queue;
-
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO2_BASE);
-	if (!queue)
-		goto err_destroy0;
-	pio->queue1 = queue;
-
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO3_BASE);
-	if (!queue)
-		goto err_destroy1;
-	pio->queue2 = queue;
-
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO4_BASE);
-	if (!queue)
-		goto err_destroy2;
-	pio->queue3 = queue;
-
-	if (bcm->current_core->rev < 3)
-		bcm->irq_savedstate |= BCM43xx_IRQ_PIO_WORKAROUND;
-
-	dprintk(KERN_INFO PFX "PIO initialized\n");
-	err = 0;
-out:
-	return err;
-
-err_destroy2:
-	bcm43xx_destroy_pioqueue(pio->queue2);
-	pio->queue2 = NULL;
-err_destroy1:
-	bcm43xx_destroy_pioqueue(pio->queue1);
-	pio->queue1 = NULL;
-err_destroy0:
-	bcm43xx_destroy_pioqueue(pio->queue0);
-	pio->queue0 = NULL;
-	goto out;
-}
-
-int bcm43xx_pio_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
-{
-	struct bcm43xx_pioqueue *queue = bcm43xx_current_pio(bcm)->queue1;
-	struct bcm43xx_pio_txpacket *packet;
-
-	assert(!queue->tx_suspended);
-	assert(!list_empty(&queue->txfree));
-
-	packet = list_entry(queue->txfree.next, struct bcm43xx_pio_txpacket, list);
-	packet->txb = txb;
-	packet->xmitted_frags = 0;
-	packet->xmitted_octets = 0;
-	list_move_tail(&packet->list, &queue->txqueue);
-	queue->nr_txfree--;
-	assert(queue->nr_txfree < BCM43xx_PIO_MAXTXPACKETS);
-
-	/* Suspend TX, if we are out of packets in the "free" queue. */
-	if (list_empty(&queue->txfree)) {
-		netif_stop_queue(queue->bcm->net_dev);
-		queue->tx_suspended = 1;
-	}
-
-	tasklet_schedule(&queue->txtask);
-
-	return 0;
-}
-
-void bcm43xx_pio_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
-{
-	struct bcm43xx_pioqueue *queue;
-	struct bcm43xx_pio_txpacket *packet;
-
-	queue = parse_cookie(bcm, status->cookie, &packet);
-	assert(queue);
-
-	free_txpacket(packet, 1);
-	if (queue->tx_suspended) {
-		queue->tx_suspended = 0;
-		netif_wake_queue(queue->bcm->net_dev);
-	}
-	/* If there are packets on the txqueue, poke the tasklet
-	 * to transmit them.
-	 */
-	if (!list_empty(&queue->txqueue))
-		tasklet_schedule(&queue->txtask);
-}
-
-static void pio_rx_error(struct bcm43xx_pioqueue *queue,
-			 int clear_buffers,
-			 const char *error)
-{
-	int i;
-
-	printkl("PIO RX error: %s\n", error);
-	bcm43xx_pio_write(queue, BCM43xx_PIO_RXCTL,
-			  BCM43xx_PIO_RXCTL_READY);
-	if (clear_buffers) {
-		assert(queue->mmio_base == BCM43xx_MMIO_PIO1_BASE);
-		for (i = 0; i < 15; i++) {
-			/* Dummy read. */
-			bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
-		}
-	}
-}
-
-void bcm43xx_pio_rx(struct bcm43xx_pioqueue *queue)
-{
-	u16 preamble[21] = { 0 };
-	struct bcm43xx_rxhdr *rxhdr;
-	u16 tmp, len, rxflags2;
-	int i, preamble_readwords;
-	struct sk_buff *skb;
-
-	tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXCTL);
-	if (!(tmp & BCM43xx_PIO_RXCTL_DATAAVAILABLE))
-		return;
-	bcm43xx_pio_write(queue, BCM43xx_PIO_RXCTL,
-			  BCM43xx_PIO_RXCTL_DATAAVAILABLE);
-
-	for (i = 0; i < 10; i++) {
-		tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXCTL);
-		if (tmp & BCM43xx_PIO_RXCTL_READY)
-			goto data_ready;
-		udelay(10);
-	}
-	dprintkl(KERN_ERR PFX "PIO RX timed out\n");
-	return;
-data_ready:
-
-	len = bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
-	if (unlikely(len > 0x700)) {
-		pio_rx_error(queue, 0, "len > 0x700");
-		return;
-	}
-	if (unlikely(len == 0 && queue->mmio_base != BCM43xx_MMIO_PIO4_BASE)) {
-		pio_rx_error(queue, 0, "len == 0");
-		return;
-	}
-	preamble[0] = cpu_to_le16(len);
-	if (queue->mmio_base == BCM43xx_MMIO_PIO4_BASE)
-		preamble_readwords = 14 / sizeof(u16);
-	else
-		preamble_readwords = 18 / sizeof(u16);
-	for (i = 0; i < preamble_readwords; i++) {
-		tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
-		preamble[i + 1] = cpu_to_le16(tmp);
-	}
-	rxhdr = (struct bcm43xx_rxhdr *)preamble;
-	rxflags2 = le16_to_cpu(rxhdr->flags2);
-	if (unlikely(rxflags2 & BCM43xx_RXHDR_FLAGS2_INVALIDFRAME)) {
-		pio_rx_error(queue,
-			     (queue->mmio_base == BCM43xx_MMIO_PIO1_BASE),
-			     "invalid frame");
-		return;
-	}
-	if (queue->mmio_base == BCM43xx_MMIO_PIO4_BASE) {
-		/* We received an xmit status. */
-		struct bcm43xx_hwxmitstatus *hw;
-		struct bcm43xx_xmitstatus stat;
-
-		hw = (struct bcm43xx_hwxmitstatus *)(preamble + 1);
-		stat.cookie = le16_to_cpu(hw->cookie);
-		stat.flags = hw->flags;
-		stat.cnt1 = hw->cnt1;
-		stat.cnt2 = hw->cnt2;
-		stat.seq = le16_to_cpu(hw->seq);
-		stat.unknown = le16_to_cpu(hw->unknown);
-
-		bcm43xx_debugfs_log_txstat(queue->bcm, &stat);
-		bcm43xx_pio_handle_xmitstatus(queue->bcm, &stat);
-
-		return;
-	}
-
-	skb = dev_alloc_skb(len);
-	if (unlikely(!skb)) {
-		pio_rx_error(queue, 1, "OOM");
-		return;
-	}
-	skb_put(skb, len);
-	for (i = 0; i < len - 1; i += 2) {
-		tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
-		*((u16 *)(skb->data + i)) = cpu_to_le16(tmp);
-	}
-	if (len % 2) {
-		tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
-		skb->data[len - 1] = (tmp & 0x00FF);
-/* The specs say the following is required, but
- * it is wrong and corrupts the PLCP. If we don't do
- * this, the PLCP seems to be correct. So ifdef it out for now.
- */
-#if 0
-		if (rxflags2 & BCM43xx_RXHDR_FLAGS2_TYPE2FRAME)
-			skb->data[2] = (tmp & 0xFF00) >> 8;
-		else
-			skb->data[0] = (tmp & 0xFF00) >> 8;
-#endif
-	}
-	skb_trim(skb, len - IEEE80211_FCS_LEN);
-	bcm43xx_rx(queue->bcm, skb, rxhdr);
-}
-
-void bcm43xx_pio_tx_suspend(struct bcm43xx_pioqueue *queue)
-{
-	bcm43xx_power_saving_ctl_bits(queue->bcm, -1, 1);
-	bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-			  bcm43xx_pio_read(queue, BCM43xx_PIO_TXCTL)
-			  | BCM43xx_PIO_TXCTL_SUSPEND);
-}
-
-void bcm43xx_pio_tx_resume(struct bcm43xx_pioqueue *queue)
-{
-	bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-			  bcm43xx_pio_read(queue, BCM43xx_PIO_TXCTL)
-			  & ~BCM43xx_PIO_TXCTL_SUSPEND);
-	bcm43xx_power_saving_ctl_bits(queue->bcm, -1, -1);
-	if (!list_empty(&queue->txqueue))
-		tasklet_schedule(&queue->txtask);
-}
-
-void bcm43xx_pio_freeze_txqueues(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_pio *pio;
-
-	assert(bcm43xx_using_pio(bcm));
-	pio = bcm43xx_current_pio(bcm);
-	pio->queue0->tx_frozen = 1;
-	pio->queue1->tx_frozen = 1;
-	pio->queue2->tx_frozen = 1;
-	pio->queue3->tx_frozen = 1;
-}
-
-void bcm43xx_pio_thaw_txqueues(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_pio *pio;
-
-	assert(bcm43xx_using_pio(bcm));
-	pio = bcm43xx_current_pio(bcm);
-	pio->queue0->tx_frozen = 0;
-	pio->queue1->tx_frozen = 0;
-	pio->queue2->tx_frozen = 0;
-	pio->queue3->tx_frozen = 0;
-	if (!list_empty(&pio->queue0->txqueue))
-		tasklet_schedule(&pio->queue0->txtask);
-	if (!list_empty(&pio->queue1->txqueue))
-		tasklet_schedule(&pio->queue1->txtask);
-	if (!list_empty(&pio->queue2->txqueue))
-		tasklet_schedule(&pio->queue2->txtask);
-	if (!list_empty(&pio->queue3->txqueue))
-		tasklet_schedule(&pio->queue3->txtask);
-}
-
-
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_pio.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_pio.h
+++ /dev/null
@@ -1,163 +0,0 @@
-#ifndef BCM43xx_PIO_H_
-#define BCM43xx_PIO_H_
-
-#include "bcm43xx.h"
-
-#include <linux/interrupt.h>
-#include <linux/list.h>
-#include <linux/skbuff.h>
-
-
-#define BCM43xx_PIO_TXCTL		0x00
-#define BCM43xx_PIO_TXDATA		0x02
-#define BCM43xx_PIO_TXQBUFSIZE		0x04
-#define BCM43xx_PIO_RXCTL		0x08
-#define BCM43xx_PIO_RXDATA		0x0A
-
-#define BCM43xx_PIO_TXCTL_WRITELO	(1 << 0)
-#define BCM43xx_PIO_TXCTL_WRITEHI	(1 << 1)
-#define BCM43xx_PIO_TXCTL_COMPLETE	(1 << 2)
-#define BCM43xx_PIO_TXCTL_INIT		(1 << 3)
-#define BCM43xx_PIO_TXCTL_SUSPEND	(1 << 7)
-
-#define BCM43xx_PIO_RXCTL_DATAAVAILABLE	(1 << 0)
-#define BCM43xx_PIO_RXCTL_READY		(1 << 1)
-
-/* PIO constants */
-#define BCM43xx_PIO_MAXTXDEVQPACKETS	31
-#define BCM43xx_PIO_TXQADJUST		80
-
-/* PIO tuning knobs */
-#define BCM43xx_PIO_MAXTXPACKETS	256
-
-
-
-#ifdef CONFIG_BCM43XX_PIO
-
-
-struct bcm43xx_pioqueue;
-struct bcm43xx_xmitstatus;
-
-struct bcm43xx_pio_txpacket {
-	struct bcm43xx_pioqueue *queue;
-	struct ieee80211_txb *txb;
-	struct list_head list;
-
-	u8 xmitted_frags;
-	u16 xmitted_octets;
-};
-
-#define pio_txpacket_getindex(packet) ((int)((packet) - (packet)->queue->tx_packets_cache)) 
-
-struct bcm43xx_pioqueue {
-	struct bcm43xx_private *bcm;
-	u16 mmio_base;
-
-	u8 tx_suspended:1,
-	   tx_frozen:1,
-	   need_workarounds:1; /* Workarounds needed for core.rev < 3 */
-
-	/* Adjusted size of the device internal TX buffer. */
-	u16 tx_devq_size;
-	/* Used octets of the device internal TX buffer. */
-	u16 tx_devq_used;
-	/* Used packet slots in the device internal TX buffer. */
-	u8 tx_devq_packets;
-	/* Packets from the txfree list can
-	 * be taken on incoming TX requests.
-	 */
-	struct list_head txfree;
-	unsigned int nr_txfree;
-	/* Packets on the txqueue are queued,
-	 * but not completely written to the chip, yet.
-	 */
-	struct list_head txqueue;
-	/* Packets on the txrunning queue are completely
-	 * posted to the device. We are waiting for the txstatus.
-	 */
-	struct list_head txrunning;
-	/* Total number or packets sent.
-	 * (This counter can obviously wrap).
-	 */
-	unsigned int nr_tx_packets;
-	struct tasklet_struct txtask;
-	struct bcm43xx_pio_txpacket tx_packets_cache[BCM43xx_PIO_MAXTXPACKETS];
-};
-
-static inline
-u16 bcm43xx_pio_read(struct bcm43xx_pioqueue *queue,
-		     u16 offset)
-{
-	return bcm43xx_read16(queue->bcm, queue->mmio_base + offset);
-}
-
-static inline
-void bcm43xx_pio_write(struct bcm43xx_pioqueue *queue,
-		       u16 offset, u16 value)
-{
-	bcm43xx_write16(queue->bcm, queue->mmio_base + offset, value);
-	mmiowb();
-}
-
-
-int bcm43xx_pio_init(struct bcm43xx_private *bcm);
-void bcm43xx_pio_free(struct bcm43xx_private *bcm);
-
-int bcm43xx_pio_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb);
-void bcm43xx_pio_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status);
-void bcm43xx_pio_rx(struct bcm43xx_pioqueue *queue);
-
-/* Suspend a TX queue on hardware level. */
-void bcm43xx_pio_tx_suspend(struct bcm43xx_pioqueue *queue);
-void bcm43xx_pio_tx_resume(struct bcm43xx_pioqueue *queue);
-/* Suspend (freeze) the TX tasklet (software level). */
-void bcm43xx_pio_freeze_txqueues(struct bcm43xx_private *bcm);
-void bcm43xx_pio_thaw_txqueues(struct bcm43xx_private *bcm);
-
-#else /* CONFIG_BCM43XX_PIO */
-
-static inline
-int bcm43xx_pio_init(struct bcm43xx_private *bcm)
-{
-	return 0;
-}
-static inline
-void bcm43xx_pio_free(struct bcm43xx_private *bcm)
-{
-}
-static inline
-int bcm43xx_pio_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
-{
-	return 0;
-}
-static inline
-void bcm43xx_pio_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
-{
-}
-static inline
-void bcm43xx_pio_rx(struct bcm43xx_pioqueue *queue)
-{
-}
-static inline
-void bcm43xx_pio_tx_suspend(struct bcm43xx_pioqueue *queue)
-{
-}
-static inline
-void bcm43xx_pio_tx_resume(struct bcm43xx_pioqueue *queue)
-{
-}
-static inline
-void bcm43xx_pio_freeze_txqueues(struct bcm43xx_private *bcm)
-{
-}
-static inline
-void bcm43xx_pio_thaw_txqueues(struct bcm43xx_private *bcm)
-{
-}
-
-#endif /* CONFIG_BCM43XX_PIO */
-#endif /* BCM43xx_PIO_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_power.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_power.c
+++ /dev/null
@@ -1,393 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include <linux/delay.h>
-
-#include "bcm43xx.h"
-#include "bcm43xx_power.h"
-#include "bcm43xx_main.h"
-
-
-/* Get the Slow Clock Source */
-static int bcm43xx_pctl_get_slowclksrc(struct bcm43xx_private *bcm)
-{
-	u32 tmp;
-	int err;
-
-	assert(bcm->current_core == &bcm->core_chipcommon);
-	if (bcm->current_core->rev < 6) {
-		if (bcm->bustype == BCM43xx_BUSTYPE_PCMCIA ||
-		    bcm->bustype == BCM43xx_BUSTYPE_SB)
-			return BCM43xx_PCTL_CLKSRC_XTALOS;
-		if (bcm->bustype == BCM43xx_BUSTYPE_PCI) {
-			err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCTL_OUT, &tmp);
-			assert(!err);
-			if (tmp & 0x10)
-				return BCM43xx_PCTL_CLKSRC_PCI;
-			return BCM43xx_PCTL_CLKSRC_XTALOS;
-		}
-	}
-	if (bcm->current_core->rev < 10) {
-		tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL);
-		tmp &= 0x7;
-		if (tmp == 0)
-			return BCM43xx_PCTL_CLKSRC_LOPWROS;
-		if (tmp == 1)
-			return BCM43xx_PCTL_CLKSRC_XTALOS;
-		if (tmp == 2)
-			return BCM43xx_PCTL_CLKSRC_PCI;
-	}
-
-	return BCM43xx_PCTL_CLKSRC_XTALOS;
-}
-
-/* Get max/min slowclock frequency
- * as described in http://bcm-specs.sipsolutions.net/PowerControl
- */
-static int bcm43xx_pctl_clockfreqlimit(struct bcm43xx_private *bcm,
-				       int get_max)
-{
-	int limit;
-	int clocksrc;
-	int divisor;
-	u32 tmp;
-
-	assert(bcm->chipcommon_capabilities & BCM43xx_CAPABILITIES_PCTL);
-	assert(bcm->current_core == &bcm->core_chipcommon);
-
-	clocksrc = bcm43xx_pctl_get_slowclksrc(bcm);
-	if (bcm->current_core->rev < 6) {
-		switch (clocksrc) {
-		case BCM43xx_PCTL_CLKSRC_PCI:
-			divisor = 64;
-			break;
-		case BCM43xx_PCTL_CLKSRC_XTALOS:
-			divisor = 32;
-			break;
-		default:
-			assert(0);
-			divisor = 1;
-		}
-	} else if (bcm->current_core->rev < 10) {
-		switch (clocksrc) {
-		case BCM43xx_PCTL_CLKSRC_LOPWROS:
-			divisor = 1;
-			break;
-		case BCM43xx_PCTL_CLKSRC_XTALOS:
-		case BCM43xx_PCTL_CLKSRC_PCI:
-			tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL);
-			divisor = ((tmp & 0xFFFF0000) >> 16) + 1;
-			divisor *= 4;
-			break;
-		default:
-			assert(0);
-			divisor = 1;
-		}
-	} else {
-		tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SYSCLKCTL);
-		divisor = ((tmp & 0xFFFF0000) >> 16) + 1;
-		divisor *= 4;
-	}
-
-	switch (clocksrc) {
-	case BCM43xx_PCTL_CLKSRC_LOPWROS:
-		if (get_max)
-			limit = 43000;
-		else
-			limit = 25000;
-		break;
-	case BCM43xx_PCTL_CLKSRC_XTALOS:
-		if (get_max)
-			limit = 20200000;
-		else
-			limit = 19800000;
-		break;
-	case BCM43xx_PCTL_CLKSRC_PCI:
-		if (get_max)
-			limit = 34000000;
-		else
-			limit = 25000000;
-		break;
-	default:
-		assert(0);
-		limit = 0;
-	}
-	limit /= divisor;
-
-	return limit;
-}
-
-
-/* init power control
- * as described in http://bcm-specs.sipsolutions.net/PowerControl
- */
-int bcm43xx_pctl_init(struct bcm43xx_private *bcm)
-{
-	int err, maxfreq;
-	struct bcm43xx_coreinfo *old_core;
-
-	old_core = bcm->current_core;
-	err = bcm43xx_switch_core(bcm, &bcm->core_chipcommon);
-	if (err == -ENODEV)
-		return 0;
-	if (err)
-		goto out;
-
-	if (bcm->chip_id == 0x4321) {
-		if (bcm->chip_rev == 0)
-			bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_CTL, 0x03A4);
-		if (bcm->chip_rev == 1)
-			bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_CTL, 0x00A4);
-	}
-
-	if (bcm->chipcommon_capabilities & BCM43xx_CAPABILITIES_PCTL) {
-		if (bcm->current_core->rev >= 10) {
-			/* Set Idle Power clock rate to 1Mhz */
-			bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_SYSCLKCTL,
-				       (bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SYSCLKCTL)
-				       & 0x0000FFFF) | 0x40000);
-		} else {
-			maxfreq = bcm43xx_pctl_clockfreqlimit(bcm, 1);
-			bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_PLLONDELAY,
-				       (maxfreq * 150 + 999999) / 1000000);
-			bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_FREFSELDELAY,
-				       (maxfreq * 15 + 999999) / 1000000);
-		}
-	}
-
-	err = bcm43xx_switch_core(bcm, old_core);
-	assert(err == 0);
-
-out:
-	return err;
-}
-
-u16 bcm43xx_pctl_powerup_delay(struct bcm43xx_private *bcm)
-{
-	u16 delay = 0;
-	int err;
-	u32 pll_on_delay;
-	struct bcm43xx_coreinfo *old_core;
-	int minfreq;
-
-	if (bcm->bustype != BCM43xx_BUSTYPE_PCI)
-		goto out;
-	if (!(bcm->chipcommon_capabilities & BCM43xx_CAPABILITIES_PCTL))
-		goto out;
-	old_core = bcm->current_core;
-	err = bcm43xx_switch_core(bcm, &bcm->core_chipcommon);
-	if (err == -ENODEV)
-		goto out;
-
-	minfreq = bcm43xx_pctl_clockfreqlimit(bcm, 0);
-	pll_on_delay = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_PLLONDELAY);
-	delay = (((pll_on_delay + 2) * 1000000) + (minfreq - 1)) / minfreq;
-
-	err = bcm43xx_switch_core(bcm, old_core);
-	assert(err == 0);
-
-out:
-	return delay;
-}
-
-/* set the powercontrol clock
- * as described in http://bcm-specs.sipsolutions.net/PowerControl
- */
-int bcm43xx_pctl_set_clock(struct bcm43xx_private *bcm, u16 mode)
-{
-	int err;
-	struct bcm43xx_coreinfo *old_core;
-	u32 tmp;
-
-	old_core = bcm->current_core;
-	err = bcm43xx_switch_core(bcm, &bcm->core_chipcommon);
-	if (err == -ENODEV)
-		return 0;
-	if (err)
-		goto out;
-	
-	if (bcm->core_chipcommon.rev < 6) {
-		if (mode == BCM43xx_PCTL_CLK_FAST) {
-			err = bcm43xx_pctl_set_crystal(bcm, 1);
-			if (err)
-				goto out;
-		}
-	} else {
-		if ((bcm->chipcommon_capabilities & BCM43xx_CAPABILITIES_PCTL) &&
-			(bcm->core_chipcommon.rev < 10)) {
-			switch (mode) {
-			case BCM43xx_PCTL_CLK_FAST:
-				tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL);
-				tmp = (tmp & ~BCM43xx_PCTL_FORCE_SLOW) | BCM43xx_PCTL_FORCE_PLL;
-				bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL, tmp);
-				break;
-			case BCM43xx_PCTL_CLK_SLOW:
-				tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL);
-				tmp |= BCM43xx_PCTL_FORCE_SLOW;
-				bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL, tmp);
-				break;
-			case BCM43xx_PCTL_CLK_DYNAMIC:
-				tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL);
-				tmp &= ~BCM43xx_PCTL_FORCE_SLOW;
-				tmp |= BCM43xx_PCTL_FORCE_PLL;
-				tmp &= ~BCM43xx_PCTL_DYN_XTAL;
-				bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL, tmp);
-			}
-		}
-	}
-	
-	err = bcm43xx_switch_core(bcm, old_core);
-	assert(err == 0);
-
-out:
-	return err;
-}
-
-int bcm43xx_pctl_set_crystal(struct bcm43xx_private *bcm, int on)
-{
-	int err;
-	u32 in, out, outenable;
-
-	err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCTL_IN, &in);
-	if (err)
-		goto err_pci;
-	err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCTL_OUT, &out);
-	if (err)
-		goto err_pci;
-	err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCTL_OUTENABLE, &outenable);
-	if (err)
-		goto err_pci;
-
-	outenable |= (BCM43xx_PCTL_XTAL_POWERUP | BCM43xx_PCTL_PLL_POWERDOWN);
-
-	if (on) {
-		if (in & 0x40)
-			return 0;
-
-		out |= (BCM43xx_PCTL_XTAL_POWERUP | BCM43xx_PCTL_PLL_POWERDOWN);
-
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCTL_OUT, out);
-		if (err)
-			goto err_pci;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCTL_OUTENABLE, outenable);
-		if (err)
-			goto err_pci;
-		udelay(1000);
-
-		out &= ~BCM43xx_PCTL_PLL_POWERDOWN;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCTL_OUT, out);
-		if (err)
-			goto err_pci;
-		udelay(5000);
-	} else {
-		if (bcm->current_core->rev < 5)
-			return 0;
-		if (bcm->sprom.boardflags & BCM43xx_BFL_XTAL_NOSLOW)
-			return 0;
-
-/*		XXX: Why BCM43xx_MMIO_RADIO_HWENABLED_xx can't be read at this time?
- *		err = bcm43xx_switch_core(bcm, bcm->active_80211_core);
- *		if (err)
- *			return err;
- *		if (((bcm->current_core->rev >= 3) &&
- *			(bcm43xx_read32(bcm, BCM43xx_MMIO_RADIO_HWENABLED_HI) & (1 << 16))) ||
- *		      ((bcm->current_core->rev < 3) &&
- *			!(bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_HWENABLED_LO) & (1 << 4))))
- *			return 0;
- *		err = bcm43xx_switch_core(bcm, &bcm->core_chipcommon);
- *		if (err)
- *			return err;
- */
-		
-		err = bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_SLOW);
-		if (err)
-			goto out;
-		out &= ~BCM43xx_PCTL_XTAL_POWERUP;
-		out |= BCM43xx_PCTL_PLL_POWERDOWN;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCTL_OUT, out);
-		if (err)
-			goto err_pci;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCTL_OUTENABLE, outenable);
-		if (err)
-			goto err_pci;
-	}
-
-out:
-	return err;
-
-err_pci:
-	printk(KERN_ERR PFX "Error: pctl_set_clock() could not access PCI config space!\n");
-	err = -EBUSY;
-	goto out;
-}
-
-/* Set the PowerSavingControlBits.
- * Bitvalues:
- *   0  => unset the bit
- *   1  => set the bit
- *   -1 => calculate the bit
- */
-void bcm43xx_power_saving_ctl_bits(struct bcm43xx_private *bcm,
-				   int bit25, int bit26)
-{
-	int i;
-	u32 status;
-
-//FIXME: Force 25 to off and 26 to on for now:
-bit25 = 0;
-bit26 = 1;
-
-	if (bit25 == -1) {
-		//TODO: If powersave is not off and FIXME is not set and we are not in adhoc
-		//	and thus is not an AP and we are associated, set bit 25
-	}
-	if (bit26 == -1) {
-		//TODO: If the device is awake or this is an AP, or we are scanning, or FIXME,
-		//	or we are associated, or FIXME, or the latest PS-Poll packet sent was
-		//	successful, set bit26
-	}
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	if (bit25)
-		status |= BCM43xx_SBF_PS1;
-	else
-		status &= ~BCM43xx_SBF_PS1;
-	if (bit26)
-		status |= BCM43xx_SBF_PS2;
-	else
-		status &= ~BCM43xx_SBF_PS2;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-	if (bit26 && bcm->current_core->rev >= 5) {
-		for (i = 0; i < 100; i++) {
-			if (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0040) != 4)
-				break;
-			udelay(10);
-		}
-	}
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_power.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_power.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef BCM43xx_POWER_H_
-#define BCM43xx_POWER_H_
-
-#include <linux/types.h>
-
-/* Clock sources */
-enum {
-	/* PCI clock */
-	BCM43xx_PCTL_CLKSRC_PCI,
-	/* Crystal slow clock oscillator */
-	BCM43xx_PCTL_CLKSRC_XTALOS,
-	/* Low power oscillator */
-	BCM43xx_PCTL_CLKSRC_LOPWROS,
-};
-
-struct bcm43xx_private;
-
-int bcm43xx_pctl_init(struct bcm43xx_private *bcm);
-int bcm43xx_pctl_set_clock(struct bcm43xx_private *bcm, u16 mode);
-int bcm43xx_pctl_set_crystal(struct bcm43xx_private *bcm, int on);
-u16 bcm43xx_pctl_powerup_delay(struct bcm43xx_private *bcm);
-
-void bcm43xx_power_saving_ctl_bits(struct bcm43xx_private *bcm,
-				   int bit25, int bit26);
-
-#endif /* BCM43xx_POWER_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_radio.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_radio.c
+++ /dev/null
@@ -1,2170 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include <linux/delay.h>
-
-#include "bcm43xx.h"
-#include "bcm43xx_main.h"
-#include "bcm43xx_phy.h"
-#include "bcm43xx_radio.h"
-#include "bcm43xx_ilt.h"
-
-
-/* Table for bcm43xx_radio_calibrationvalue() */
-static const u16 rcc_table[16] = {
-	0x0002, 0x0003, 0x0001, 0x000F,
-	0x0006, 0x0007, 0x0005, 0x000F,
-	0x000A, 0x000B, 0x0009, 0x000F,
-	0x000E, 0x000F, 0x000D, 0x000F,
-};
-
-/* Reverse the bits of a 4bit value.
- * Example:  1101 is flipped 1011
- */
-static u16 flip_4bit(u16 value)
-{
-	u16 flipped = 0x0000;
-
-	assert((value & ~0x000F) == 0x0000);
-
-	flipped |= (value & 0x0001) << 3;
-	flipped |= (value & 0x0002) << 1;
-	flipped |= (value & 0x0004) >> 1;
-	flipped |= (value & 0x0008) >> 3;
-
-	return flipped;
-}
-
-/* Get the freq, as it has to be written to the device. */
-static inline
-u16 channel2freq_bg(u8 channel)
-{
-	/* Frequencies are given as frequencies_bg[index] + 2.4GHz
-	 * Starting with channel 1
-	 */
-	static const u16 frequencies_bg[14] = {
-		12, 17, 22, 27,
-		32, 37, 42, 47,
-		52, 57, 62, 67,
-		72, 84,
-	};
-
-	assert(channel >= 1 && channel <= 14);
-
-	return frequencies_bg[channel - 1];
-}
-
-/* Get the freq, as it has to be written to the device. */
-static inline
-u16 channel2freq_a(u8 channel)
-{
-	assert(channel <= 200);
-
-	return (5000 + 5 * channel);
-}
-
-void bcm43xx_radio_lock(struct bcm43xx_private *bcm)
-{
-	u32 status;
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	status |= BCM43xx_SBF_RADIOREG_LOCK;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-	mmiowb();
-	udelay(10);
-}
-
-void bcm43xx_radio_unlock(struct bcm43xx_private *bcm)
-{
-	u32 status;
-
-	bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_VER); /* dummy read */
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	status &= ~BCM43xx_SBF_RADIOREG_LOCK;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-	mmiowb();
-}
-
-u16 bcm43xx_radio_read16(struct bcm43xx_private *bcm, u16 offset)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		offset |= 0x0040;
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if (radio->version == 0x2053) {
-			if (offset < 0x70)
-				offset += 0x80;
-			else if (offset < 0x80)
-				offset += 0x70;
-		} else if (radio->version == 0x2050) {
-			offset |= 0x80;
-		} else
-			assert(0);
-		break;
-	case BCM43xx_PHYTYPE_G:
-		offset |= 0x80;
-		break;
-	}
-
-	bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, offset);
-	return bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_DATA_LOW);
-}
-
-void bcm43xx_radio_write16(struct bcm43xx_private *bcm, u16 offset, u16 val)
-{
-	bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, offset);
-	mmiowb();
-	bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_DATA_LOW, val);
-}
-
-static void bcm43xx_set_all_gains(struct bcm43xx_private *bcm,
-				  s16 first, s16 second, s16 third)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 i;
-	u16 start = 0x08, end = 0x18;
-	u16 offset = 0x0400;
-	u16 tmp;
-
-	if (phy->rev <= 1) {
-		offset = 0x5000;
-		start = 0x10;
-		end = 0x20;
-	}
-
-	for (i = 0; i < 4; i++)
-		bcm43xx_ilt_write(bcm, offset + i, first);
-
-	for (i = start; i < end; i++)
-		bcm43xx_ilt_write(bcm, offset + i, second);
-
-	if (third != -1) {
-		tmp = ((u16)third << 14) | ((u16)third << 6);
-		bcm43xx_phy_write(bcm, 0x04A0,
-		                  (bcm43xx_phy_read(bcm, 0x04A0) & 0xBFBF) | tmp);
-		bcm43xx_phy_write(bcm, 0x04A1,
-		                  (bcm43xx_phy_read(bcm, 0x04A1) & 0xBFBF) | tmp);
-		bcm43xx_phy_write(bcm, 0x04A2,
-		                  (bcm43xx_phy_read(bcm, 0x04A2) & 0xBFBF) | tmp);
-	}
-	bcm43xx_dummy_transmission(bcm);
-}
-
-static void bcm43xx_set_original_gains(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 i, tmp;
-	u16 offset = 0x0400;
-	u16 start = 0x0008, end = 0x0018;
-
-	if (phy->rev <= 1) {
-		offset = 0x5000;
-		start = 0x0010;
-		end = 0x0020;
-	}
-
-	for (i = 0; i < 4; i++) {
-		tmp = (i & 0xFFFC);
-		tmp |= (i & 0x0001) << 1;
-		tmp |= (i & 0x0002) >> 1;
-
-		bcm43xx_ilt_write(bcm, offset + i, tmp);
-	}
-
-	for (i = start; i < end; i++)
-		bcm43xx_ilt_write(bcm, offset + i, i - start);
-
-	bcm43xx_phy_write(bcm, 0x04A0,
-	                  (bcm43xx_phy_read(bcm, 0x04A0) & 0xBFBF) | 0x4040);
-	bcm43xx_phy_write(bcm, 0x04A1,
-	                  (bcm43xx_phy_read(bcm, 0x04A1) & 0xBFBF) | 0x4040);
-	bcm43xx_phy_write(bcm, 0x04A2,
-	                  (bcm43xx_phy_read(bcm, 0x04A2) & 0xBFBF) | 0x4000);
-	bcm43xx_dummy_transmission(bcm);
-}
-
-/* Synthetic PU workaround */
-static void bcm43xx_synth_pu_workaround(struct bcm43xx_private *bcm, u8 channel)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	
-	if (radio->version != 0x2050 || radio->revision >= 6) {
-		/* We do not need the workaround. */
-		return;
-	}
-
-	if (channel <= 10) {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
-				channel2freq_bg(channel + 4));
-	} else {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
-				channel2freq_bg(1));
-	}
-	udelay(100);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
-			channel2freq_bg(channel));
-}
-
-u8 bcm43xx_radio_aci_detect(struct bcm43xx_private *bcm, u8 channel)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u8 ret = 0;
-	u16 saved, rssi, temp;
-	int i, j = 0;
-
-	saved = bcm43xx_phy_read(bcm, 0x0403);
-	bcm43xx_radio_selectchannel(bcm, channel, 0);
-	bcm43xx_phy_write(bcm, 0x0403, (saved & 0xFFF8) | 5);
-	if (radio->aci_hw_rssi)
-		rssi = bcm43xx_phy_read(bcm, 0x048A) & 0x3F;
-	else
-		rssi = saved & 0x3F;
-	/* clamp temp to signed 5bit */
-	if (rssi > 32)
-		rssi -= 64;
-	for (i = 0;i < 100; i++) {
-		temp = (bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x3F;
-		if (temp > 32)
-			temp -= 64;
-		if (temp < rssi)
-			j++;
-		if (j >= 20)
-			ret = 1;
-	}
-	bcm43xx_phy_write(bcm, 0x0403, saved);
-
-	return ret;
-}
-
-u8 bcm43xx_radio_aci_scan(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u8 ret[13];
-	unsigned int channel = radio->channel;
-	unsigned int i, j, start, end;
-	unsigned long phylock_flags;
-
-	if (!((phy->type == BCM43xx_PHYTYPE_G) && (phy->rev > 0)))
-		return 0;
-
-	bcm43xx_phy_lock(bcm, phylock_flags);
-	bcm43xx_radio_lock(bcm);
-	bcm43xx_phy_write(bcm, 0x0802,
-	                  bcm43xx_phy_read(bcm, 0x0802) & 0xFFFC);
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-	                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) & 0x7FFF);
-	bcm43xx_set_all_gains(bcm, 3, 8, 1);
-
-	start = (channel - 5 > 0) ? channel - 5 : 1;
-	end = (channel + 5 < 14) ? channel + 5 : 13;
-
-	for (i = start; i <= end; i++) {
-		if (abs(channel - i) > 2)
-			ret[i-1] = bcm43xx_radio_aci_detect(bcm, i);
-	}
-	bcm43xx_radio_selectchannel(bcm, channel, 0);
-	bcm43xx_phy_write(bcm, 0x0802,
-	                  (bcm43xx_phy_read(bcm, 0x0802) & 0xFFFC) | 0x0003);
-	bcm43xx_phy_write(bcm, 0x0403,
-	                  bcm43xx_phy_read(bcm, 0x0403) & 0xFFF8);
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-	                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x8000);
-	bcm43xx_set_original_gains(bcm);
-	for (i = 0; i < 13; i++) {
-		if (!ret[i])
-			continue;
-		end = (i + 5 < 13) ? i + 5 : 13;
-		for (j = i; j < end; j++)
-			ret[j] = 1;
-	}
-	bcm43xx_radio_unlock(bcm);
-	bcm43xx_phy_unlock(bcm, phylock_flags);
-
-	return ret[channel - 1];
-}
-
-/* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
-void bcm43xx_nrssi_hw_write(struct bcm43xx_private *bcm, u16 offset, s16 val)
-{
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_NRSSILT_CTRL, offset);
-	mmiowb();
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_NRSSILT_DATA, (u16)val);
-}
-
-/* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
-s16 bcm43xx_nrssi_hw_read(struct bcm43xx_private *bcm, u16 offset)
-{
-	u16 val;
-
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_NRSSILT_CTRL, offset);
-	val = bcm43xx_phy_read(bcm, BCM43xx_PHY_NRSSILT_DATA);
-
-	return (s16)val;
-}
-
-/* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
-void bcm43xx_nrssi_hw_update(struct bcm43xx_private *bcm, u16 val)
-{
-	u16 i;
-	s16 tmp;
-
-	for (i = 0; i < 64; i++) {
-		tmp = bcm43xx_nrssi_hw_read(bcm, i);
-		tmp -= val;
-		tmp = limit_value(tmp, -32, 31);
-		bcm43xx_nrssi_hw_write(bcm, i, tmp);
-	}
-}
-
-/* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
-void bcm43xx_nrssi_mem_update(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	s16 i, delta;
-	s32 tmp;
-
-	delta = 0x1F - radio->nrssi[0];
-	for (i = 0; i < 64; i++) {
-		tmp = (i - delta) * radio->nrssislope;
-		tmp /= 0x10000;
-		tmp += 0x3A;
-		tmp = limit_value(tmp, 0, 0x3F);
-		radio->nrssi_lt[i] = tmp;
-	}
-}
-
-static void bcm43xx_calc_nrssi_offset(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 backup[20] = { 0 };
-	s16 v47F;
-	u16 i;
-	u16 saved = 0xFFFF;
-
-	backup[0] = bcm43xx_phy_read(bcm, 0x0001);
-	backup[1] = bcm43xx_phy_read(bcm, 0x0811);
-	backup[2] = bcm43xx_phy_read(bcm, 0x0812);
-	backup[3] = bcm43xx_phy_read(bcm, 0x0814);
-	backup[4] = bcm43xx_phy_read(bcm, 0x0815);
-	backup[5] = bcm43xx_phy_read(bcm, 0x005A);
-	backup[6] = bcm43xx_phy_read(bcm, 0x0059);
-	backup[7] = bcm43xx_phy_read(bcm, 0x0058);
-	backup[8] = bcm43xx_phy_read(bcm, 0x000A);
-	backup[9] = bcm43xx_phy_read(bcm, 0x0003);
-	backup[10] = bcm43xx_radio_read16(bcm, 0x007A);
-	backup[11] = bcm43xx_radio_read16(bcm, 0x0043);
-
-	bcm43xx_phy_write(bcm, 0x0429,
-			  bcm43xx_phy_read(bcm, 0x0429) & 0x7FFF);
-	bcm43xx_phy_write(bcm, 0x0001,
-			  (bcm43xx_phy_read(bcm, 0x0001) & 0x3FFF) | 0x4000);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x000C);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  (bcm43xx_phy_read(bcm, 0x0812) & 0xFFF3) | 0x0004);
-	bcm43xx_phy_write(bcm, 0x0802,
-			  bcm43xx_phy_read(bcm, 0x0802) & ~(0x1 | 0x2));
-	if (phy->rev >= 6) {
-		backup[12] = bcm43xx_phy_read(bcm, 0x002E);
-		backup[13] = bcm43xx_phy_read(bcm, 0x002F);
-		backup[14] = bcm43xx_phy_read(bcm, 0x080F);
-		backup[15] = bcm43xx_phy_read(bcm, 0x0810);
-		backup[16] = bcm43xx_phy_read(bcm, 0x0801);
-		backup[17] = bcm43xx_phy_read(bcm, 0x0060);
-		backup[18] = bcm43xx_phy_read(bcm, 0x0014);
-		backup[19] = bcm43xx_phy_read(bcm, 0x0478);
-
-		bcm43xx_phy_write(bcm, 0x002E, 0);
-		bcm43xx_phy_write(bcm, 0x002F, 0);
-		bcm43xx_phy_write(bcm, 0x080F, 0);
-		bcm43xx_phy_write(bcm, 0x0810, 0);
-		bcm43xx_phy_write(bcm, 0x0478,
-				  bcm43xx_phy_read(bcm, 0x0478) | 0x0100);
-		bcm43xx_phy_write(bcm, 0x0801,
-				  bcm43xx_phy_read(bcm, 0x0801) | 0x0040);
-		bcm43xx_phy_write(bcm, 0x0060,
-				  bcm43xx_phy_read(bcm, 0x0060) | 0x0040);
-		bcm43xx_phy_write(bcm, 0x0014,
-				  bcm43xx_phy_read(bcm, 0x0014) | 0x0200);
-	}
-	bcm43xx_radio_write16(bcm, 0x007A,
-			      bcm43xx_radio_read16(bcm, 0x007A) | 0x0070);
-	bcm43xx_radio_write16(bcm, 0x007A,
-			      bcm43xx_radio_read16(bcm, 0x007A) | 0x0080);
-	udelay(30);
-
-	v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
-	if (v47F >= 0x20)
-		v47F -= 0x40;
-	if (v47F == 31) {
-		for (i = 7; i >= 4; i--) {
-			bcm43xx_radio_write16(bcm, 0x007B, i);
-			udelay(20);
-			v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
-			if (v47F >= 0x20)
-				v47F -= 0x40;
-			if (v47F < 31 && saved == 0xFFFF)
-				saved = i;
-		}
-		if (saved == 0xFFFF)
-			saved = 4;
-	} else {
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) & 0x007F);
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0001);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) & 0xFFFE);
-		bcm43xx_phy_write(bcm, 0x0811,
-				  bcm43xx_phy_read(bcm, 0x0811) | 0x000C);
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_phy_read(bcm, 0x0812) | 0x000C);
-		bcm43xx_phy_write(bcm, 0x0811,
-				  bcm43xx_phy_read(bcm, 0x0811) | 0x0030);
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_phy_read(bcm, 0x0812) | 0x0030);
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0x0810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-		if (phy->analog == 0) {
-			bcm43xx_phy_write(bcm, 0x0003, 0x0122);
-		} else {
-			bcm43xx_phy_write(bcm, 0x000A,
-					  bcm43xx_phy_read(bcm, 0x000A)
-					  | 0x2000);
-		}
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0004);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) & 0xFFFB);
-		bcm43xx_phy_write(bcm, 0x0003,
-				  (bcm43xx_phy_read(bcm, 0x0003) & 0xFF9F)
-				  | 0x0040);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x000F);
-		bcm43xx_set_all_gains(bcm, 3, 0, 1);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      (bcm43xx_radio_read16(bcm, 0x0043)
-				       & 0x00F0) | 0x000F);
-		udelay(30);
-		v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
-		if (v47F >= 0x20)
-			v47F -= 0x40;
-		if (v47F == -32) {
-			for (i = 0; i < 4; i++) {
-				bcm43xx_radio_write16(bcm, 0x007B, i);
-				udelay(20);
-				v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
-				if (v47F >= 0x20)
-					v47F -= 0x40;
-				if (v47F > -31 && saved == 0xFFFF)
-					saved = i;
-			}
-			if (saved == 0xFFFF)
-				saved = 3;
-		} else
-			saved = 0;
-	}
-	bcm43xx_radio_write16(bcm, 0x007B, saved);
-
-	if (phy->rev >= 6) {
-		bcm43xx_phy_write(bcm, 0x002E, backup[12]);
-		bcm43xx_phy_write(bcm, 0x002F, backup[13]);
-		bcm43xx_phy_write(bcm, 0x080F, backup[14]);
-		bcm43xx_phy_write(bcm, 0x0810, backup[15]);
-	}
-	bcm43xx_phy_write(bcm, 0x0814, backup[3]);
-	bcm43xx_phy_write(bcm, 0x0815, backup[4]);
-	bcm43xx_phy_write(bcm, 0x005A, backup[5]);
-	bcm43xx_phy_write(bcm, 0x0059, backup[6]);
-	bcm43xx_phy_write(bcm, 0x0058, backup[7]);
-	bcm43xx_phy_write(bcm, 0x000A, backup[8]);
-	bcm43xx_phy_write(bcm, 0x0003, backup[9]);
-	bcm43xx_radio_write16(bcm, 0x0043, backup[11]);
-	bcm43xx_radio_write16(bcm, 0x007A, backup[10]);
-	bcm43xx_phy_write(bcm, 0x0802,
-			  bcm43xx_phy_read(bcm, 0x0802) | 0x1 | 0x2);
-	bcm43xx_phy_write(bcm, 0x0429,
-			  bcm43xx_phy_read(bcm, 0x0429) | 0x8000);
-	bcm43xx_set_original_gains(bcm);
-	if (phy->rev >= 6) {
-		bcm43xx_phy_write(bcm, 0x0801, backup[16]);
-		bcm43xx_phy_write(bcm, 0x0060, backup[17]);
-		bcm43xx_phy_write(bcm, 0x0014, backup[18]);
-		bcm43xx_phy_write(bcm, 0x0478, backup[19]);
-	}
-	bcm43xx_phy_write(bcm, 0x0001, backup[0]);
-	bcm43xx_phy_write(bcm, 0x0812, backup[2]);
-	bcm43xx_phy_write(bcm, 0x0811, backup[1]);
-}
-
-void bcm43xx_calc_nrssi_slope(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 backup[18] = { 0 };
-	u16 tmp;
-	s16 nrssi0, nrssi1;
-
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_B:
-		backup[0] = bcm43xx_radio_read16(bcm, 0x007A);
-		backup[1] = bcm43xx_radio_read16(bcm, 0x0052);
-		backup[2] = bcm43xx_radio_read16(bcm, 0x0043);
-		backup[3] = bcm43xx_phy_read(bcm, 0x0030);
-		backup[4] = bcm43xx_phy_read(bcm, 0x0026);
-		backup[5] = bcm43xx_phy_read(bcm, 0x0015);
-		backup[6] = bcm43xx_phy_read(bcm, 0x002A);
-		backup[7] = bcm43xx_phy_read(bcm, 0x0020);
-		backup[8] = bcm43xx_phy_read(bcm, 0x005A);
-		backup[9] = bcm43xx_phy_read(bcm, 0x0059);
-		backup[10] = bcm43xx_phy_read(bcm, 0x0058);
-		backup[11] = bcm43xx_read16(bcm, 0x03E2);
-		backup[12] = bcm43xx_read16(bcm, 0x03E6);
-		backup[13] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
-
-		tmp  = bcm43xx_radio_read16(bcm, 0x007A);
-		tmp &= (phy->rev >= 5) ? 0x007F : 0x000F;
-		bcm43xx_radio_write16(bcm, 0x007A, tmp);
-		bcm43xx_phy_write(bcm, 0x0030, 0x00FF);
-		bcm43xx_write16(bcm, 0x03EC, 0x7F7F);
-		bcm43xx_phy_write(bcm, 0x0026, 0x0000);
-		bcm43xx_phy_write(bcm, 0x0015,
-				  bcm43xx_phy_read(bcm, 0x0015) | 0x0020);
-		bcm43xx_phy_write(bcm, 0x002A, 0x08A3);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x0080);
-
-		nrssi0 = (s16)bcm43xx_phy_read(bcm, 0x0027);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) & 0x007F);
-		if (phy->analog >= 2) {
-			bcm43xx_write16(bcm, 0x03E6, 0x0040);
-		} else if (phy->analog == 0) {
-			bcm43xx_write16(bcm, 0x03E6, 0x0122);
-		} else {
-			bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-					bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT) & 0x2000);
-		}
-		bcm43xx_phy_write(bcm, 0x0020, 0x3F3F);
-		bcm43xx_phy_write(bcm, 0x0015, 0xF330);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0060);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      bcm43xx_radio_read16(bcm, 0x0043) & 0x00F0);
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0x0810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-		udelay(20);
-
-		nrssi1 = (s16)bcm43xx_phy_read(bcm, 0x0027);
-		bcm43xx_phy_write(bcm, 0x0030, backup[3]);
-		bcm43xx_radio_write16(bcm, 0x007A, backup[0]);
-		bcm43xx_write16(bcm, 0x03E2, backup[11]);
-		bcm43xx_phy_write(bcm, 0x0026, backup[4]);
-		bcm43xx_phy_write(bcm, 0x0015, backup[5]);
-		bcm43xx_phy_write(bcm, 0x002A, backup[6]);
-		bcm43xx_synth_pu_workaround(bcm, radio->channel);
-		if (phy->analog != 0)
-			bcm43xx_write16(bcm, 0x03F4, backup[13]);
-
-		bcm43xx_phy_write(bcm, 0x0020, backup[7]);
-		bcm43xx_phy_write(bcm, 0x005A, backup[8]);
-		bcm43xx_phy_write(bcm, 0x0059, backup[9]);
-		bcm43xx_phy_write(bcm, 0x0058, backup[10]);
-		bcm43xx_radio_write16(bcm, 0x0052, backup[1]);
-		bcm43xx_radio_write16(bcm, 0x0043, backup[2]);
-
-		if (nrssi0 == nrssi1)
-			radio->nrssislope = 0x00010000;
-		else 
-			radio->nrssislope = 0x00400000 / (nrssi0 - nrssi1);
-
-		if (nrssi0 <= -4) {
-			radio->nrssi[0] = nrssi0;
-			radio->nrssi[1] = nrssi1;
-		}
-		break;
-	case BCM43xx_PHYTYPE_G:
-		if (radio->revision >= 9)
-			return;
-		if (radio->revision == 8)
-			bcm43xx_calc_nrssi_offset(bcm);
-
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) & 0x7FFF);
-		bcm43xx_phy_write(bcm, 0x0802,
-				  bcm43xx_phy_read(bcm, 0x0802) & 0xFFFC);
-		backup[7] = bcm43xx_read16(bcm, 0x03E2);
-		bcm43xx_write16(bcm, 0x03E2,
-				bcm43xx_read16(bcm, 0x03E2) | 0x8000);
-		backup[0] = bcm43xx_radio_read16(bcm, 0x007A);
-		backup[1] = bcm43xx_radio_read16(bcm, 0x0052);
-		backup[2] = bcm43xx_radio_read16(bcm, 0x0043);
-		backup[3] = bcm43xx_phy_read(bcm, 0x0015);
-		backup[4] = bcm43xx_phy_read(bcm, 0x005A);
-		backup[5] = bcm43xx_phy_read(bcm, 0x0059);
-		backup[6] = bcm43xx_phy_read(bcm, 0x0058);
-		backup[8] = bcm43xx_read16(bcm, 0x03E6);
-		backup[9] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
-		if (phy->rev >= 3) {
-			backup[10] = bcm43xx_phy_read(bcm, 0x002E);
-			backup[11] = bcm43xx_phy_read(bcm, 0x002F);
-			backup[12] = bcm43xx_phy_read(bcm, 0x080F);
-			backup[13] = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_LO_CONTROL);
-			backup[14] = bcm43xx_phy_read(bcm, 0x0801);
-			backup[15] = bcm43xx_phy_read(bcm, 0x0060);
-			backup[16] = bcm43xx_phy_read(bcm, 0x0014);
-			backup[17] = bcm43xx_phy_read(bcm, 0x0478);
-			bcm43xx_phy_write(bcm, 0x002E, 0);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_LO_CONTROL, 0);
-			switch (phy->rev) {
-			case 4: case 6: case 7:
-				bcm43xx_phy_write(bcm, 0x0478,
-						  bcm43xx_phy_read(bcm, 0x0478)
-						  | 0x0100);
-				bcm43xx_phy_write(bcm, 0x0801,
-						  bcm43xx_phy_read(bcm, 0x0801)
-						  | 0x0040);
-				break;
-			case 3: case 5:
-				bcm43xx_phy_write(bcm, 0x0801,
-						  bcm43xx_phy_read(bcm, 0x0801)
-						  & 0xFFBF);
-				break;
-			}
-			bcm43xx_phy_write(bcm, 0x0060,
-					  bcm43xx_phy_read(bcm, 0x0060)
-					  | 0x0040);
-			bcm43xx_phy_write(bcm, 0x0014,
-					  bcm43xx_phy_read(bcm, 0x0014)
-					  | 0x0200);
-		}
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x0070);
-		bcm43xx_set_all_gains(bcm, 0, 8, 0);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) & 0x00F7);
-		if (phy->rev >= 2) {
-			bcm43xx_phy_write(bcm, 0x0811,
-					  (bcm43xx_phy_read(bcm, 0x0811) & 0xFFCF) | 0x0030);
-			bcm43xx_phy_write(bcm, 0x0812,
-					  (bcm43xx_phy_read(bcm, 0x0812) & 0xFFCF) | 0x0010);
-		}
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x0080);
-		udelay(20);
-
-		nrssi0 = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
-		if (nrssi0 >= 0x0020)
-			nrssi0 -= 0x0040;
-
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) & 0x007F);
-		if (phy->analog >= 2) {
-			bcm43xx_phy_write(bcm, 0x0003,
-					  (bcm43xx_phy_read(bcm, 0x0003)
-					   & 0xFF9F) | 0x0040);
-		}
-
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-				bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
-				| 0x2000);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x000F);
-		bcm43xx_phy_write(bcm, 0x0015, 0xF330);
-		if (phy->rev >= 2) {
-			bcm43xx_phy_write(bcm, 0x0812,
-					  (bcm43xx_phy_read(bcm, 0x0812) & 0xFFCF) | 0x0020);
-			bcm43xx_phy_write(bcm, 0x0811,
-					  (bcm43xx_phy_read(bcm, 0x0811) & 0xFFCF) | 0x0020);
-		}
-
-		bcm43xx_set_all_gains(bcm, 3, 0, 1);
-		if (radio->revision == 8) {
-			bcm43xx_radio_write16(bcm, 0x0043, 0x001F);
-		} else {
-			tmp = bcm43xx_radio_read16(bcm, 0x0052) & 0xFF0F;
-			bcm43xx_radio_write16(bcm, 0x0052, tmp | 0x0060);
-			tmp = bcm43xx_radio_read16(bcm, 0x0043) & 0xFFF0;
-			bcm43xx_radio_write16(bcm, 0x0043, tmp | 0x0009);
-		}
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0x0810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-		udelay(20);
-		nrssi1 = (s16)((bcm43xx_phy_read(bcm, 0x047F) >> 8) & 0x003F);
-		if (nrssi1 >= 0x0020)
-			nrssi1 -= 0x0040;
-		if (nrssi0 == nrssi1)
-			radio->nrssislope = 0x00010000;
-		else
-			radio->nrssislope = 0x00400000 / (nrssi0 - nrssi1);
-		if (nrssi0 >= -4) {
-			radio->nrssi[0] = nrssi1;
-			radio->nrssi[1] = nrssi0;
-		}
-		if (phy->rev >= 3) {
-			bcm43xx_phy_write(bcm, 0x002E, backup[10]);
-			bcm43xx_phy_write(bcm, 0x002F, backup[11]);
-			bcm43xx_phy_write(bcm, 0x080F, backup[12]);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_LO_CONTROL, backup[13]);
-		}
-		if (phy->rev >= 2) {
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_phy_read(bcm, 0x0812) & 0xFFCF);
-			bcm43xx_phy_write(bcm, 0x0811,
-					  bcm43xx_phy_read(bcm, 0x0811) & 0xFFCF);
-		}
-
-		bcm43xx_radio_write16(bcm, 0x007A, backup[0]);
-		bcm43xx_radio_write16(bcm, 0x0052, backup[1]);
-		bcm43xx_radio_write16(bcm, 0x0043, backup[2]);
-		bcm43xx_write16(bcm, 0x03E2, backup[7]);
-		bcm43xx_write16(bcm, 0x03E6, backup[8]);
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, backup[9]);
-		bcm43xx_phy_write(bcm, 0x0015, backup[3]);
-		bcm43xx_phy_write(bcm, 0x005A, backup[4]);
-		bcm43xx_phy_write(bcm, 0x0059, backup[5]);
-		bcm43xx_phy_write(bcm, 0x0058, backup[6]);
-		bcm43xx_synth_pu_workaround(bcm, radio->channel);
-		bcm43xx_phy_write(bcm, 0x0802,
-				  bcm43xx_phy_read(bcm, 0x0802) | (0x0001 | 0x0002));
-		bcm43xx_set_original_gains(bcm);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x8000);
-		if (phy->rev >= 3) {
-			bcm43xx_phy_write(bcm, 0x0801, backup[14]);
-			bcm43xx_phy_write(bcm, 0x0060, backup[15]);
-			bcm43xx_phy_write(bcm, 0x0014, backup[16]);
-			bcm43xx_phy_write(bcm, 0x0478, backup[17]);
-		}
-		bcm43xx_nrssi_mem_update(bcm);
-		bcm43xx_calc_nrssi_threshold(bcm);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-void bcm43xx_calc_nrssi_threshold(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	s32 threshold;
-	s32 a, b;
-	s16 tmp16;
-	u16 tmp_u16;
-
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_B: {
-		if (radio->version != 0x2050)
-			return;
-		if (!(bcm->sprom.boardflags & BCM43xx_BFL_RSSI))
-			return;
-
-		if (radio->revision >= 6) {
-			threshold = (radio->nrssi[1] - radio->nrssi[0]) * 32;
-			threshold += 20 * (radio->nrssi[0] + 1);
-			threshold /= 40;
-		} else
-			threshold = radio->nrssi[1] - 5;
-
-		threshold = limit_value(threshold, 0, 0x3E);
-		bcm43xx_phy_read(bcm, 0x0020); /* dummy read */
-		bcm43xx_phy_write(bcm, 0x0020, (((u16)threshold) << 8) | 0x001C);
-
-		if (radio->revision >= 6) {
-			bcm43xx_phy_write(bcm, 0x0087, 0x0E0D);
-			bcm43xx_phy_write(bcm, 0x0086, 0x0C0B);
-			bcm43xx_phy_write(bcm, 0x0085, 0x0A09);
-			bcm43xx_phy_write(bcm, 0x0084, 0x0808);
-			bcm43xx_phy_write(bcm, 0x0083, 0x0808);
-			bcm43xx_phy_write(bcm, 0x0082, 0x0604);
-			bcm43xx_phy_write(bcm, 0x0081, 0x0302);
-			bcm43xx_phy_write(bcm, 0x0080, 0x0100);
-		}
-		break;
-	}
-	case BCM43xx_PHYTYPE_G:
-		if (!phy->connected ||
-		    !(bcm->sprom.boardflags & BCM43xx_BFL_RSSI)) {
-			tmp16 = bcm43xx_nrssi_hw_read(bcm, 0x20);
-			if (tmp16 >= 0x20)
-				tmp16 -= 0x40;
-			if (tmp16 < 3) {
-				bcm43xx_phy_write(bcm, 0x048A,
-						  (bcm43xx_phy_read(bcm, 0x048A)
-						   & 0xF000) | 0x09EB);
-			} else {
-				bcm43xx_phy_write(bcm, 0x048A,
-						  (bcm43xx_phy_read(bcm, 0x048A)
-						   & 0xF000) | 0x0AED);
-			}
-		} else {
-			if (radio->interfmode == BCM43xx_RADIO_INTERFMODE_NONWLAN) {
-				a = 0xE;
-				b = 0xA;
-			} else if (!radio->aci_wlan_automatic && radio->aci_enable) {
-				a = 0x13;
-				b = 0x12;
-			} else {
-				a = 0xE;
-				b = 0x11;
-			}
-
-			a = a * (radio->nrssi[1] - radio->nrssi[0]);
-			a += (radio->nrssi[0] << 6);
-			if (a < 32)
-				a += 31;
-			else
-				a += 32;
-			a = a >> 6;
-			a = limit_value(a, -31, 31);
-
-			b = b * (radio->nrssi[1] - radio->nrssi[0]);
-			b += (radio->nrssi[0] << 6);
-			if (b < 32)
-				b += 31;
-			else
-				b += 32;
-			b = b >> 6;
-			b = limit_value(b, -31, 31);
-
-			tmp_u16 = bcm43xx_phy_read(bcm, 0x048A) & 0xF000;
-			tmp_u16 |= ((u32)b & 0x0000003F);
-			tmp_u16 |= (((u32)a & 0x0000003F) << 6);
-			bcm43xx_phy_write(bcm, 0x048A, tmp_u16);
-		}
-		break;
-	default:
-		assert(0);
-	}
-}
-
-/* Stack implementation to save/restore values from the
- * interference mitigation code.
- * It is save to restore values in random order.
- */
-static void _stack_save(u32 *_stackptr, size_t *stackidx,
-			u8 id, u16 offset, u16 value)
-{
-	u32 *stackptr = &(_stackptr[*stackidx]);
-
-	assert((offset & 0xE000) == 0x0000);
-	assert((id & 0xF8) == 0x00);
-	*stackptr = offset;
-	*stackptr |= ((u32)id) << 13;
-	*stackptr |= ((u32)value) << 16;
-	(*stackidx)++;
-	assert(*stackidx < BCM43xx_INTERFSTACK_SIZE);
-}
-
-static u16 _stack_restore(u32 *stackptr,
-			  u8 id, u16 offset)
-{
-	size_t i;
-
-	assert((offset & 0xE000) == 0x0000);
-	assert((id & 0xF8) == 0x00);
-	for (i = 0; i < BCM43xx_INTERFSTACK_SIZE; i++, stackptr++) {
-		if ((*stackptr & 0x00001FFF) != offset)
-			continue;
-		if (((*stackptr & 0x00007000) >> 13) != id)
-			continue;
-		return ((*stackptr & 0xFFFF0000) >> 16);
-	}
-	assert(0);
-
-	return 0;
-}
-
-#define phy_stacksave(offset)					\
-	do {							\
-		_stack_save(stack, &stackidx, 0x1, (offset),	\
-			    bcm43xx_phy_read(bcm, (offset)));	\
-	} while (0)
-#define phy_stackrestore(offset)				\
-	do {							\
-		bcm43xx_phy_write(bcm, (offset),		\
-				  _stack_restore(stack, 0x1,	\
-					  	 (offset)));	\
-	} while (0)
-#define radio_stacksave(offset)						\
-	do {								\
-		_stack_save(stack, &stackidx, 0x2, (offset),		\
-			    bcm43xx_radio_read16(bcm, (offset)));	\
-	} while (0)
-#define radio_stackrestore(offset)					\
-	do {								\
-		bcm43xx_radio_write16(bcm, (offset),			\
-				      _stack_restore(stack, 0x2,	\
-						     (offset)));	\
-	} while (0)
-#define ilt_stacksave(offset)					\
-	do {							\
-		_stack_save(stack, &stackidx, 0x3, (offset),	\
-			    bcm43xx_ilt_read(bcm, (offset)));	\
-	} while (0)
-#define ilt_stackrestore(offset)				\
-	do {							\
-		bcm43xx_ilt_write(bcm, (offset),		\
-				  _stack_restore(stack, 0x3,	\
-						 (offset)));	\
-	} while (0)
-
-static void
-bcm43xx_radio_interference_mitigation_enable(struct bcm43xx_private *bcm,
-					     int mode)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 tmp, flipped;
-	u32 tmp32;
-	size_t stackidx = 0;
-	u32 *stack = radio->interfstack;
-
-	switch (mode) {
-	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
-		if (phy->rev != 1) {
-			bcm43xx_phy_write(bcm, 0x042B,
-			                  bcm43xx_phy_read(bcm, 0x042B) | 0x0800);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-			                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) & ~0x4000);
-			break;
-		}
-		radio_stacksave(0x0078);
-		tmp = (bcm43xx_radio_read16(bcm, 0x0078) & 0x001E);
-		flipped = flip_4bit(tmp);
-		if (flipped < 10 && flipped >= 8)
-			flipped = 7;
-		else if (flipped >= 10)
-			flipped -= 3;
-		flipped = flip_4bit(flipped);
-		flipped = (flipped << 1) | 0x0020;
-		bcm43xx_radio_write16(bcm, 0x0078, flipped);
-
-		bcm43xx_calc_nrssi_threshold(bcm);
-
-		phy_stacksave(0x0406);
-		bcm43xx_phy_write(bcm, 0x0406, 0x7E28);
-
-		bcm43xx_phy_write(bcm, 0x042B,
-		                  bcm43xx_phy_read(bcm, 0x042B) | 0x0800);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-		                  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD) | 0x1000);
-
-		phy_stacksave(0x04A0);
-		bcm43xx_phy_write(bcm, 0x04A0,
-		                  (bcm43xx_phy_read(bcm, 0x04A0) & 0xC0C0) | 0x0008);
-		phy_stacksave(0x04A1);
-		bcm43xx_phy_write(bcm, 0x04A1,
-				  (bcm43xx_phy_read(bcm, 0x04A1) & 0xC0C0) | 0x0605);
-		phy_stacksave(0x04A2);
-		bcm43xx_phy_write(bcm, 0x04A2,
-				  (bcm43xx_phy_read(bcm, 0x04A2) & 0xC0C0) | 0x0204);
-		phy_stacksave(0x04A8);
-		bcm43xx_phy_write(bcm, 0x04A8,
-				  (bcm43xx_phy_read(bcm, 0x04A8) & 0xC0C0) | 0x0803);
-		phy_stacksave(0x04AB);
-		bcm43xx_phy_write(bcm, 0x04AB,
-				  (bcm43xx_phy_read(bcm, 0x04AB) & 0xC0C0) | 0x0605);
-
-		phy_stacksave(0x04A7);
-		bcm43xx_phy_write(bcm, 0x04A7, 0x0002);
-		phy_stacksave(0x04A3);
-		bcm43xx_phy_write(bcm, 0x04A3, 0x287A);
-		phy_stacksave(0x04A9);
-		bcm43xx_phy_write(bcm, 0x04A9, 0x2027);
-		phy_stacksave(0x0493);
-		bcm43xx_phy_write(bcm, 0x0493, 0x32F5);
-		phy_stacksave(0x04AA);
-		bcm43xx_phy_write(bcm, 0x04AA, 0x2027);
-		phy_stacksave(0x04AC);
-		bcm43xx_phy_write(bcm, 0x04AC, 0x32F5);
-		break;
-	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		if (bcm43xx_phy_read(bcm, 0x0033) & 0x0800)
-			break;
-
-		radio->aci_enable = 1;
-
-		phy_stacksave(BCM43xx_PHY_RADIO_BITFIELD);
-		phy_stacksave(BCM43xx_PHY_G_CRS);
-		if (phy->rev < 2) {
-			phy_stacksave(0x0406);
-		} else {
-			phy_stacksave(0x04C0);
-			phy_stacksave(0x04C1);
-		}
-		phy_stacksave(0x0033);
-		phy_stacksave(0x04A7);
-		phy_stacksave(0x04A3);
-		phy_stacksave(0x04A9);
-		phy_stacksave(0x04AA);
-		phy_stacksave(0x04AC);
-		phy_stacksave(0x0493);
-		phy_stacksave(0x04A1);
-		phy_stacksave(0x04A0);
-		phy_stacksave(0x04A2);
-		phy_stacksave(0x048A);
-		phy_stacksave(0x04A8);
-		phy_stacksave(0x04AB);
-		if (phy->rev == 2) {
-			phy_stacksave(0x04AD);
-			phy_stacksave(0x04AE);
-		} else if (phy->rev >= 3) {
-			phy_stacksave(0x04AD);
-			phy_stacksave(0x0415);
-			phy_stacksave(0x0416);
-			phy_stacksave(0x0417);
-			ilt_stacksave(0x1A00 + 0x2);
-			ilt_stacksave(0x1A00 + 0x3);
-		}
-		phy_stacksave(0x042B);
-		phy_stacksave(0x048C);
-
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD)
-				  & ~0x1000);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  (bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS)
-				   & 0xFFFC) | 0x0002);
-
-		bcm43xx_phy_write(bcm, 0x0033, 0x0800);
-		bcm43xx_phy_write(bcm, 0x04A3, 0x2027);
-		bcm43xx_phy_write(bcm, 0x04A9, 0x1CA8);
-		bcm43xx_phy_write(bcm, 0x0493, 0x287A);
-		bcm43xx_phy_write(bcm, 0x04AA, 0x1CA8);
-		bcm43xx_phy_write(bcm, 0x04AC, 0x287A);
-
-		bcm43xx_phy_write(bcm, 0x04A0,
-				  (bcm43xx_phy_read(bcm, 0x04A0)
-				   & 0xFFC0) | 0x001A);
-		bcm43xx_phy_write(bcm, 0x04A7, 0x000D);
-
-		if (phy->rev < 2) {
-			bcm43xx_phy_write(bcm, 0x0406, 0xFF0D);
-		} else if (phy->rev == 2) {
-			bcm43xx_phy_write(bcm, 0x04C0, 0xFFFF);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x00A9);
-		} else {
-			bcm43xx_phy_write(bcm, 0x04C0, 0x00C1);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x0059);
-		}
-
-		bcm43xx_phy_write(bcm, 0x04A1,
-		                  (bcm43xx_phy_read(bcm, 0x04A1)
-				   & 0xC0FF) | 0x1800);
-		bcm43xx_phy_write(bcm, 0x04A1,
-		                  (bcm43xx_phy_read(bcm, 0x04A1)
-				   & 0xFFC0) | 0x0015);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   & 0xCFFF) | 0x1000);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   & 0xF0FF) | 0x0A00);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   & 0xCFFF) | 0x1000);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   & 0xF0FF) | 0x0800);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   & 0xFFCF) | 0x0010);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   & 0xFFF0) | 0x0005);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   & 0xFFCF) | 0x0010);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   & 0xFFF0) | 0x0006);
-		bcm43xx_phy_write(bcm, 0x04A2,
-		                  (bcm43xx_phy_read(bcm, 0x04A2)
-				   & 0xF0FF) | 0x0800);
-		bcm43xx_phy_write(bcm, 0x04A0,
-				  (bcm43xx_phy_read(bcm, 0x04A0)
-				   & 0xF0FF) | 0x0500);
-		bcm43xx_phy_write(bcm, 0x04A2,
-				  (bcm43xx_phy_read(bcm, 0x04A2)
-				   & 0xFFF0) | 0x000B);
-
-		if (phy->rev >= 3) {
-			bcm43xx_phy_write(bcm, 0x048A,
-					  bcm43xx_phy_read(bcm, 0x048A)
-					  & ~0x8000);
-			bcm43xx_phy_write(bcm, 0x0415,
-					  (bcm43xx_phy_read(bcm, 0x0415)
-					   & 0x8000) | 0x36D8);
-			bcm43xx_phy_write(bcm, 0x0416,
-					  (bcm43xx_phy_read(bcm, 0x0416)
-					   & 0x8000) | 0x36D8);
-			bcm43xx_phy_write(bcm, 0x0417,
-					  (bcm43xx_phy_read(bcm, 0x0417)
-					   & 0xFE00) | 0x016D);
-		} else {
-			bcm43xx_phy_write(bcm, 0x048A,
-					  bcm43xx_phy_read(bcm, 0x048A)
-					  | 0x1000);
-			bcm43xx_phy_write(bcm, 0x048A,
-					  (bcm43xx_phy_read(bcm, 0x048A)
-					   & 0x9FFF) | 0x2000);
-			tmp32 = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-						   BCM43xx_UCODEFLAGS_OFFSET);
-			if (!(tmp32 & 0x800)) {
-				tmp32 |= 0x800;
-				bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-						    BCM43xx_UCODEFLAGS_OFFSET,
-						    tmp32);
-			}
-		}
-		if (phy->rev >= 2) {
-			bcm43xx_phy_write(bcm, 0x042B,
-					  bcm43xx_phy_read(bcm, 0x042B)
-					  | 0x0800);
-		}
-		bcm43xx_phy_write(bcm, 0x048C,
-				  (bcm43xx_phy_read(bcm, 0x048C)
-				   & 0xF0FF) | 0x0200);
-		if (phy->rev == 2) {
-			bcm43xx_phy_write(bcm, 0x04AE,
-					  (bcm43xx_phy_read(bcm, 0x04AE)
-					   & 0xFF00) | 0x007F);
-			bcm43xx_phy_write(bcm, 0x04AD,
-					  (bcm43xx_phy_read(bcm, 0x04AD)
-					   & 0x00FF) | 0x1300);
-		} else if (phy->rev >= 6) {
-			bcm43xx_ilt_write(bcm, 0x1A00 + 0x3, 0x007F);
-			bcm43xx_ilt_write(bcm, 0x1A00 + 0x2, 0x007F);
-			bcm43xx_phy_write(bcm, 0x04AD,
-					  bcm43xx_phy_read(bcm, 0x04AD)
-					  & 0x00FF);
-		}
-		bcm43xx_calc_nrssi_slope(bcm);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-static void
-bcm43xx_radio_interference_mitigation_disable(struct bcm43xx_private *bcm,
-					      int mode)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u32 tmp32;
-	u32 *stack = radio->interfstack;
-
-	switch (mode) {
-	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
-		if (phy->rev != 1) {
-			bcm43xx_phy_write(bcm, 0x042B,
-			                  bcm43xx_phy_read(bcm, 0x042B) & ~0x0800);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-			                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x4000);
-			break;
-		}
-		phy_stackrestore(0x0078);
-		bcm43xx_calc_nrssi_threshold(bcm);
-		phy_stackrestore(0x0406);
-		bcm43xx_phy_write(bcm, 0x042B,
-				  bcm43xx_phy_read(bcm, 0x042B) & ~0x0800);
-		if (!bcm->bad_frames_preempt) {
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-					  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD)
-					  & ~(1 << 11));
-		}
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x4000);
-		phy_stackrestore(0x04A0);
-		phy_stackrestore(0x04A1);
-		phy_stackrestore(0x04A2);
-		phy_stackrestore(0x04A8);
-		phy_stackrestore(0x04AB);
-		phy_stackrestore(0x04A7);
-		phy_stackrestore(0x04A3);
-		phy_stackrestore(0x04A9);
-		phy_stackrestore(0x0493);
-		phy_stackrestore(0x04AA);
-		phy_stackrestore(0x04AC);
-		break;
-	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		if (!(bcm43xx_phy_read(bcm, 0x0033) & 0x0800))
-			break;
-
-		radio->aci_enable = 0;
-
-		phy_stackrestore(BCM43xx_PHY_RADIO_BITFIELD);
-		phy_stackrestore(BCM43xx_PHY_G_CRS);
-		phy_stackrestore(0x0033);
-		phy_stackrestore(0x04A3);
-		phy_stackrestore(0x04A9);
-		phy_stackrestore(0x0493);
-		phy_stackrestore(0x04AA);
-		phy_stackrestore(0x04AC);
-		phy_stackrestore(0x04A0);
-		phy_stackrestore(0x04A7);
-		if (phy->rev >= 2) {
-			phy_stackrestore(0x04C0);
-			phy_stackrestore(0x04C1);
-		} else
-			phy_stackrestore(0x0406);
-		phy_stackrestore(0x04A1);
-		phy_stackrestore(0x04AB);
-		phy_stackrestore(0x04A8);
-		if (phy->rev == 2) {
-			phy_stackrestore(0x04AD);
-			phy_stackrestore(0x04AE);
-		} else if (phy->rev >= 3) {
-			phy_stackrestore(0x04AD);
-			phy_stackrestore(0x0415);
-			phy_stackrestore(0x0416);
-			phy_stackrestore(0x0417);
-			ilt_stackrestore(0x1A00 + 0x2);
-			ilt_stackrestore(0x1A00 + 0x3);
-		}
-		phy_stackrestore(0x04A2);
-		phy_stackrestore(0x04A8);
-		phy_stackrestore(0x042B);
-		phy_stackrestore(0x048C);
-		tmp32 = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-					   BCM43xx_UCODEFLAGS_OFFSET);
-		if (tmp32 & 0x800) {
-			tmp32 &= ~0x800;
-			bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-					    BCM43xx_UCODEFLAGS_OFFSET,
-					    tmp32);
-		}
-		bcm43xx_calc_nrssi_slope(bcm);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-#undef phy_stacksave
-#undef phy_stackrestore
-#undef radio_stacksave
-#undef radio_stackrestore
-#undef ilt_stacksave
-#undef ilt_stackrestore
-
-int bcm43xx_radio_set_interference_mitigation(struct bcm43xx_private *bcm,
-					      int mode)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	int currentmode;
-
-	if ((phy->type != BCM43xx_PHYTYPE_G) ||
-	    (phy->rev == 0) ||
-	    (!phy->connected))
-		return -ENODEV;
-
-	radio->aci_wlan_automatic = 0;
-	switch (mode) {
-	case BCM43xx_RADIO_INTERFMODE_AUTOWLAN:
-		radio->aci_wlan_automatic = 1;
-		if (radio->aci_enable)
-			mode = BCM43xx_RADIO_INTERFMODE_MANUALWLAN;
-		else
-			mode = BCM43xx_RADIO_INTERFMODE_NONE;
-		break;
-	case BCM43xx_RADIO_INTERFMODE_NONE:
-	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
-	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	currentmode = radio->interfmode;
-	if (currentmode == mode)
-		return 0;
-	if (currentmode != BCM43xx_RADIO_INTERFMODE_NONE)
-		bcm43xx_radio_interference_mitigation_disable(bcm, currentmode);
-
-	if (mode == BCM43xx_RADIO_INTERFMODE_NONE) {
-		radio->aci_enable = 0;
-		radio->aci_hw_rssi = 0;
-	} else
-		bcm43xx_radio_interference_mitigation_enable(bcm, mode);
-	radio->interfmode = mode;
-
-	return 0;
-}
-
-u16 bcm43xx_radio_calibrationvalue(struct bcm43xx_private *bcm)
-{
-	u16 reg, index, ret;
-
-	reg = bcm43xx_radio_read16(bcm, 0x0060);
-	index = (reg & 0x001E) >> 1;
-	ret = rcc_table[index] << 1;
-	ret |= (reg & 0x0001);
-	ret |= 0x0020;
-
-	return ret;
-}
-
-#define LPD(L, P, D)    (((L) << 2) | ((P) << 1) | ((D) << 0))
-static u16 bcm43xx_get_812_value(struct bcm43xx_private *bcm, u8 lpd)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 loop_or = 0;
-	u16 adj_loopback_gain = phy->loopback_gain[0];
-	u8 loop;
-	u16 extern_lna_control;
-
-	if (!phy->connected)
-		return 0;
-	if (!has_loopback_gain(phy)) {
-		if (phy->rev < 7 || !(bcm->sprom.boardflags
-		    & BCM43xx_BFL_EXTLNA)) {
-			switch (lpd) {
-			case LPD(0, 1, 1):
-				return 0x0FB2;
-			case LPD(0, 0, 1):
-				return 0x00B2;
-			case LPD(1, 0, 1):
-				return 0x30B2;
-			case LPD(1, 0, 0):
-				return 0x30B3;
-			default:
-				assert(0);
-			}
-		} else {
-			switch (lpd) {
-			case LPD(0, 1, 1):
-				return 0x8FB2;
-			case LPD(0, 0, 1):
-				return 0x80B2;
-			case LPD(1, 0, 1):
-				return 0x20B2;
-			case LPD(1, 0, 0):
-				return 0x20B3;
-			default:
-				assert(0);
-			}
-		}
-	} else {
-		if (radio->revision == 8)
-			adj_loopback_gain += 0x003E;
-		else
-			adj_loopback_gain += 0x0026;
-		if (adj_loopback_gain >= 0x46) {
-			adj_loopback_gain -= 0x46;
-			extern_lna_control = 0x3000;
-		} else if (adj_loopback_gain >= 0x3A) {
-			adj_loopback_gain -= 0x3A;
-			extern_lna_control = 0x2000;
-		} else if (adj_loopback_gain >= 0x2E) {
-			adj_loopback_gain -= 0x2E;
-			extern_lna_control = 0x1000;
-		} else {
-			adj_loopback_gain -= 0x10;
-			extern_lna_control = 0x0000;
-		}
-		for (loop = 0; loop < 16; loop++) {
-			u16 tmp = adj_loopback_gain - 6 * loop;
-			if (tmp < 6)
-				break;
-		}
-
-		loop_or = (loop << 8) | extern_lna_control;
-		if (phy->rev >= 7 && bcm->sprom.boardflags
-		    & BCM43xx_BFL_EXTLNA) {
-			if (extern_lna_control)
-				loop_or |= 0x8000;
-			switch (lpd) {
-			case LPD(0, 1, 1):
-				return 0x8F92;
-			case LPD(0, 0, 1):
-				return (0x8092 | loop_or);
-			case LPD(1, 0, 1):
-				return (0x2092 | loop_or);
-			case LPD(1, 0, 0):
-				return (0x2093 | loop_or);
-			default:
-				assert(0);
-			}
-		} else {
-			switch (lpd) {
-			case LPD(0, 1, 1):
-				return 0x0F92;
-			case LPD(0, 0, 1):
-			case LPD(1, 0, 1):
-				return (0x0092 | loop_or);
-			case LPD(1, 0, 0):
-				return (0x0093 | loop_or);
-			default:
-				assert(0);
-			}
-		}
-	}
-	return 0;
-}
-
-u16 bcm43xx_radio_init2050(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 backup[21] = { 0 };
-	u16 ret;
-	u16 i, j;
-	u32 tmp1 = 0, tmp2 = 0;
-
-	backup[0] = bcm43xx_radio_read16(bcm, 0x0043);
-	backup[14] = bcm43xx_radio_read16(bcm, 0x0051);
-	backup[15] = bcm43xx_radio_read16(bcm, 0x0052);
-	backup[1] = bcm43xx_phy_read(bcm, 0x0015);
-	backup[16] = bcm43xx_phy_read(bcm, 0x005A);
-	backup[17] = bcm43xx_phy_read(bcm, 0x0059);
-	backup[18] = bcm43xx_phy_read(bcm, 0x0058);
-	if (phy->type == BCM43xx_PHYTYPE_B) {
-		backup[2] = bcm43xx_phy_read(bcm, 0x0030);
-		backup[3] = bcm43xx_read16(bcm, 0x03EC);
-		bcm43xx_phy_write(bcm, 0x0030, 0x00FF);
-		bcm43xx_write16(bcm, 0x03EC, 0x3F3F);
-	} else {
-		if (phy->connected) {
-			backup[4] = bcm43xx_phy_read(bcm, 0x0811);
-			backup[5] = bcm43xx_phy_read(bcm, 0x0812);
-			backup[6] = bcm43xx_phy_read(bcm, 0x0814);
-			backup[7] = bcm43xx_phy_read(bcm, 0x0815);
-			backup[8] = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS);
-			backup[9] = bcm43xx_phy_read(bcm, 0x0802);
-			bcm43xx_phy_write(bcm, 0x0814,
-			                  (bcm43xx_phy_read(bcm, 0x0814)
-					  | 0x0003));
-			bcm43xx_phy_write(bcm, 0x0815,
-			                  (bcm43xx_phy_read(bcm, 0x0815)
-					  & 0xFFFC));
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-			                  (bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS)
-					  & 0x7FFF));
-			bcm43xx_phy_write(bcm, 0x0802,
-			                  (bcm43xx_phy_read(bcm, 0x0802) & 0xFFFC));
-			if (phy->rev > 1) { /* loopback gain enabled */
-				backup[19] = bcm43xx_phy_read(bcm, 0x080F);
-				backup[20] = bcm43xx_phy_read(bcm, 0x0810);
-				if (phy->rev >= 3)
-					bcm43xx_phy_write(bcm, 0x080F, 0xC020);
-				else
-					bcm43xx_phy_write(bcm, 0x080F, 0x8020);
-				bcm43xx_phy_write(bcm, 0x0810, 0x0000);
-			}
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(0, 1, 1)));
-			if (phy->rev < 7 || !(bcm->sprom.boardflags
-			    & BCM43xx_BFL_EXTLNA))
-				bcm43xx_phy_write(bcm, 0x0811, 0x01B3);
-			else
-				bcm43xx_phy_write(bcm, 0x0811, 0x09B3);
-		}
-	}
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_RADIO,
-	                (bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_RADIO) | 0x8000));
-	backup[10] = bcm43xx_phy_read(bcm, 0x0035);
-	bcm43xx_phy_write(bcm, 0x0035,
-	                  (bcm43xx_phy_read(bcm, 0x0035) & 0xFF7F));
-	backup[11] = bcm43xx_read16(bcm, 0x03E6);
-	backup[12] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
-
-	// Initialization
-	if (phy->analog == 0) {
-		bcm43xx_write16(bcm, 0x03E6, 0x0122);
-	} else {
-		if (phy->analog >= 2)
-			bcm43xx_phy_write(bcm, 0x0003,
-					  (bcm43xx_phy_read(bcm, 0x0003)
-					  & 0xFFBF) | 0x0040);
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-		                (bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
-				| 0x2000));
-	}
-
-	ret = bcm43xx_radio_calibrationvalue(bcm);
-
-	if (phy->type == BCM43xx_PHYTYPE_B)
-		bcm43xx_radio_write16(bcm, 0x0078, 0x0026);
-
-	if (phy->connected)
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_get_812_value(bcm, LPD(0, 1, 1)));
-	bcm43xx_phy_write(bcm, 0x0015, 0xBFAF);
-	bcm43xx_phy_write(bcm, 0x002B, 0x1403);
-	if (phy->connected)
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_get_812_value(bcm, LPD(0, 0, 1)));
-	bcm43xx_phy_write(bcm, 0x0015, 0xBFA0);
-	bcm43xx_radio_write16(bcm, 0x0051,
-	                      (bcm43xx_radio_read16(bcm, 0x0051) | 0x0004));
-	if (radio->revision == 8)
-		bcm43xx_radio_write16(bcm, 0x0043, 0x001F);
-	else {
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      (bcm43xx_radio_read16(bcm, 0x0043) & 0xFFF0)
-				      | 0x0009);
-	}
-	bcm43xx_phy_write(bcm, 0x0058, 0x0000);
-
-	for (i = 0; i < 16; i++) {
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0xC810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-		if (phy->connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 1)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
-		udelay(10);
-		if (phy->connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 1)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xEFB0);
-		udelay(10);
-		if (phy->connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 0)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xFFF0);
-		udelay(20);
-		tmp1 += bcm43xx_phy_read(bcm, 0x002D);
-		bcm43xx_phy_write(bcm, 0x0058, 0x0000);
-		if (phy->connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 1)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
-	}
-
-	tmp1++;
-	tmp1 >>= 9;
-	udelay(10);
-	bcm43xx_phy_write(bcm, 0x0058, 0x0000);
-
-	for (i = 0; i < 16; i++) {
-		bcm43xx_radio_write16(bcm, 0x0078, (flip_4bit(i) << 1) | 0x0020);
-		backup[13] = bcm43xx_radio_read16(bcm, 0x0078);
-		udelay(10);
-		for (j = 0; j < 16; j++) {
-			bcm43xx_phy_write(bcm, 0x005A, 0x0D80);
-			bcm43xx_phy_write(bcm, 0x0059, 0xC810);
-			bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-			if (phy->connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
-						  LPD(1, 0, 1)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
-			udelay(10);
-			if (phy->connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
-						  LPD(1, 0, 1)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xEFB0);
-			udelay(10);
-			if (phy->connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
-						  LPD(1, 0, 0)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xFFF0);
-			udelay(10);
-			tmp2 += bcm43xx_phy_read(bcm, 0x002D);
-			bcm43xx_phy_write(bcm, 0x0058, 0x0000);
-			if (phy->connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
-						  LPD(1, 0, 1)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
-		}
-		tmp2++;
-		tmp2 >>= 8;
-		if (tmp1 < tmp2)
-			break;
-	}
-
-	/* Restore the registers */
-	bcm43xx_phy_write(bcm, 0x0015, backup[1]);
-	bcm43xx_radio_write16(bcm, 0x0051, backup[14]);
-	bcm43xx_radio_write16(bcm, 0x0052, backup[15]);
-	bcm43xx_radio_write16(bcm, 0x0043, backup[0]);
-	bcm43xx_phy_write(bcm, 0x005A, backup[16]);
-	bcm43xx_phy_write(bcm, 0x0059, backup[17]);
-	bcm43xx_phy_write(bcm, 0x0058, backup[18]);
-	bcm43xx_write16(bcm, 0x03E6, backup[11]);
-	if (phy->analog != 0)
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, backup[12]);
-	bcm43xx_phy_write(bcm, 0x0035, backup[10]);
-	bcm43xx_radio_selectchannel(bcm, radio->channel, 1);
-	if (phy->type == BCM43xx_PHYTYPE_B) {
-		bcm43xx_phy_write(bcm, 0x0030, backup[2]);
-		bcm43xx_write16(bcm, 0x03EC, backup[3]);
-	} else {
-		if (phy->connected) {
-			bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_RADIO,
-					(bcm43xx_read16(bcm,
-					BCM43xx_MMIO_PHY_RADIO) & 0x7FFF));
-			bcm43xx_phy_write(bcm, 0x0811, backup[4]);
-			bcm43xx_phy_write(bcm, 0x0812, backup[5]);
-			bcm43xx_phy_write(bcm, 0x0814, backup[6]);
-			bcm43xx_phy_write(bcm, 0x0815, backup[7]);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, backup[8]);
-			bcm43xx_phy_write(bcm, 0x0802, backup[9]);
-			if (phy->rev > 1) {
-				bcm43xx_phy_write(bcm, 0x080F, backup[19]);
-				bcm43xx_phy_write(bcm, 0x0810, backup[20]);
-			}
-		}
-	}
-	if (i >= 15)
-		ret = backup[13];
-
-	return ret;
-}
-
-void bcm43xx_radio_init2060(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	bcm43xx_radio_write16(bcm, 0x0004, 0x00C0);
-	bcm43xx_radio_write16(bcm, 0x0005, 0x0008);
-	bcm43xx_radio_write16(bcm, 0x0009, 0x0040);
-	bcm43xx_radio_write16(bcm, 0x0005, 0x00AA);
-	bcm43xx_radio_write16(bcm, 0x0032, 0x008F);
-	bcm43xx_radio_write16(bcm, 0x0006, 0x008F);
-	bcm43xx_radio_write16(bcm, 0x0034, 0x008F);
-	bcm43xx_radio_write16(bcm, 0x002C, 0x0007);
-	bcm43xx_radio_write16(bcm, 0x0082, 0x0080);
-	bcm43xx_radio_write16(bcm, 0x0080, 0x0000);
-	bcm43xx_radio_write16(bcm, 0x003F, 0x00DA);
-	bcm43xx_radio_write16(bcm, 0x0005, bcm43xx_radio_read16(bcm, 0x0005) & ~0x0008);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) & ~0x0010);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) & ~0x0020);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) & ~0x0020);
-	udelay(400);
-
-	bcm43xx_radio_write16(bcm, 0x0081, (bcm43xx_radio_read16(bcm, 0x0081) & ~0x0020) | 0x0010);
-	udelay(400);
-
-	bcm43xx_radio_write16(bcm, 0x0005, (bcm43xx_radio_read16(bcm, 0x0005) & ~0x0008) | 0x0008);
-	bcm43xx_radio_write16(bcm, 0x0085, bcm43xx_radio_read16(bcm, 0x0085) & ~0x0010);
-	bcm43xx_radio_write16(bcm, 0x0005, bcm43xx_radio_read16(bcm, 0x0005) & ~0x0008);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) & ~0x0040);
-	bcm43xx_radio_write16(bcm, 0x0081, (bcm43xx_radio_read16(bcm, 0x0081) & ~0x0040) | 0x0040);
-	bcm43xx_radio_write16(bcm, 0x0005, (bcm43xx_radio_read16(bcm, 0x0081) & ~0x0008) | 0x0008);
-	bcm43xx_phy_write(bcm, 0x0063, 0xDDC6);
-	bcm43xx_phy_write(bcm, 0x0069, 0x07BE);
-	bcm43xx_phy_write(bcm, 0x006A, 0x0000);
-
-	err = bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_A, 0);
-	assert(err == 0);
-	udelay(1000);
-}
-
-static inline
-u16 freq_r3A_value(u16 frequency)
-{
-	u16 value;
-
-	if (frequency < 5091)
-		value = 0x0040;
-	else if (frequency < 5321)
-		value = 0x0000;
-	else if (frequency < 5806)
-		value = 0x0080;
-	else
-		value = 0x0040;
-
-	return value;
-}
-
-void bcm43xx_radio_set_tx_iq(struct bcm43xx_private *bcm)
-{
-	static const u8 data_high[5] = { 0x00, 0x40, 0x80, 0x90, 0xD0 };
-	static const u8 data_low[5]  = { 0x00, 0x01, 0x05, 0x06, 0x0A };
-	u16 tmp = bcm43xx_radio_read16(bcm, 0x001E);
-	int i, j;
-	
-	for (i = 0; i < 5; i++) {
-		for (j = 0; j < 5; j++) {
-			if (tmp == (data_high[i] | data_low[j])) {
-				bcm43xx_phy_write(bcm, 0x0069, (i - j) << 8 | 0x00C0);
-				return;
-			}
-		}
-	}
-}
-
-int bcm43xx_radio_selectchannel(struct bcm43xx_private *bcm,
-				u8 channel,
-				int synthetic_pu_workaround)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 r8, tmp;
-	u16 freq;
-
-	if (!ieee80211_is_valid_channel(bcm->ieee, channel))
-		return -EINVAL;
-	if ((radio->manufact == 0x17F) &&
-	    (radio->version == 0x2060) &&
-	    (radio->revision == 1)) {
-		freq = channel2freq_a(channel);
-
-		r8 = bcm43xx_radio_read16(bcm, 0x0008);
-		bcm43xx_write16(bcm, 0x03F0, freq);
-		bcm43xx_radio_write16(bcm, 0x0008, r8);
-
-		TODO();//TODO: write max channel TX power? to Radio 0x2D
-		tmp = bcm43xx_radio_read16(bcm, 0x002E);
-		tmp &= 0x0080;
-		TODO();//TODO: OR tmp with the Power out estimation for this channel?
-		bcm43xx_radio_write16(bcm, 0x002E, tmp);
-
-		if (freq >= 4920 && freq <= 5500) {
-			/* 
-			 * r8 = (((freq * 15 * 0xE1FC780F) >> 32) / 29) & 0x0F;
-			 *    = (freq * 0.025862069
-			 */
-			r8 = 3 * freq / 116; /* is equal to r8 = freq * 0.025862 */
-		}
-		bcm43xx_radio_write16(bcm, 0x0007, (r8 << 4) | r8);
-		bcm43xx_radio_write16(bcm, 0x0020, (r8 << 4) | r8);
-		bcm43xx_radio_write16(bcm, 0x0021, (r8 << 4) | r8);
-		bcm43xx_radio_write16(bcm, 0x0022,
-				      (bcm43xx_radio_read16(bcm, 0x0022)
-				       & 0x000F) | (r8 << 4));
-		bcm43xx_radio_write16(bcm, 0x002A, (r8 << 4));
-		bcm43xx_radio_write16(bcm, 0x002B, (r8 << 4));
-		bcm43xx_radio_write16(bcm, 0x0008,
-				      (bcm43xx_radio_read16(bcm, 0x0008)
-				       & 0x00F0) | (r8 << 4));
-		bcm43xx_radio_write16(bcm, 0x0029,
-				      (bcm43xx_radio_read16(bcm, 0x0029)
-				       & 0xFF0F) | 0x00B0);
-		bcm43xx_radio_write16(bcm, 0x0035, 0x00AA);
-		bcm43xx_radio_write16(bcm, 0x0036, 0x0085);
-		bcm43xx_radio_write16(bcm, 0x003A,
-				      (bcm43xx_radio_read16(bcm, 0x003A)
-				       & 0xFF20) | freq_r3A_value(freq));
-		bcm43xx_radio_write16(bcm, 0x003D,
-				      bcm43xx_radio_read16(bcm, 0x003D) & 0x00FF);
-		bcm43xx_radio_write16(bcm, 0x0081,
-				      (bcm43xx_radio_read16(bcm, 0x0081)
-				       & 0xFF7F) | 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0035,
-				      bcm43xx_radio_read16(bcm, 0x0035) & 0xFFEF);
-		bcm43xx_radio_write16(bcm, 0x0035,
-				      (bcm43xx_radio_read16(bcm, 0x0035)
-				       & 0xFFEF) | 0x0010);
-		bcm43xx_radio_set_tx_iq(bcm);
-		TODO();	//TODO:	TSSI2dbm workaround
-		bcm43xx_phy_xmitpower(bcm);//FIXME correct?
-	} else {
-		if (synthetic_pu_workaround)
-			bcm43xx_synth_pu_workaround(bcm, channel);
-
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
-				channel2freq_bg(channel));
-
-		if (channel == 14) {
-			if (bcm->sprom.locale == BCM43xx_LOCALE_JAPAN) {
-				bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-						    BCM43xx_UCODEFLAGS_OFFSET,
-						    bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-								       BCM43xx_UCODEFLAGS_OFFSET)
-						    & ~(1 << 7));
-			} else {
-				bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-						    BCM43xx_UCODEFLAGS_OFFSET,
-						    bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-								       BCM43xx_UCODEFLAGS_OFFSET)
-						    | (1 << 7));
-			}
-			bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-					bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
-					| (1 << 11));
-		} else {
-			bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-					bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
-					& 0xF7BF);
-		}
-	}
-
-	radio->channel = channel;
-	//XXX: Using the longer of 2 timeouts (8000 vs 2000 usecs). Specs states
-	//     that 2000 usecs might suffice.
-	udelay(8000);
-
-	return 0;
-}
-
-void bcm43xx_radio_set_txantenna(struct bcm43xx_private *bcm, u32 val)
-{
-	u16 tmp;
-
-	val <<= 8;
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0022) & 0xFCFF;
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0022, tmp | val);
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x03A8) & 0xFCFF;
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x03A8, tmp | val);
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0054) & 0xFCFF;
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0054, tmp | val);
-}
-
-/* http://bcm-specs.sipsolutions.net/TX_Gain_Base_Band */
-static u16 bcm43xx_get_txgain_base_band(u16 txpower)
-{
-	u16 ret;
-
-	assert(txpower <= 63);
-
-	if (txpower >= 54)
-		ret = 2;
-	else if (txpower >= 49)
-		ret = 4;
-	else if (txpower >= 44)
-		ret = 5;
-	else
-		ret = 6;
-
-	return ret;
-}
-
-/* http://bcm-specs.sipsolutions.net/TX_Gain_Radio_Frequency_Power_Amplifier */
-static u16 bcm43xx_get_txgain_freq_power_amp(u16 txpower)
-{
-	u16 ret;
-
-	assert(txpower <= 63);
-
-	if (txpower >= 32)
-		ret = 0;
-	else if (txpower >= 25)
-		ret = 1;
-	else if (txpower >= 20)
-		ret = 2;
-	else if (txpower >= 12)
-		ret = 3;
-	else
-		ret = 4;
-
-	return ret;
-}
-
-/* http://bcm-specs.sipsolutions.net/TX_Gain_Digital_Analog_Converter */
-static u16 bcm43xx_get_txgain_dac(u16 txpower)
-{
-	u16 ret;
-
-	assert(txpower <= 63);
-
-	if (txpower >= 54)
-		ret = txpower - 53;
-	else if (txpower >= 49)
-		ret = txpower - 42;
-	else if (txpower >= 44)
-		ret = txpower - 37;
-	else if (txpower >= 32)
-		ret = txpower - 32;
-	else if (txpower >= 25)
-		ret = txpower - 20;
-	else if (txpower >= 20)
-		ret = txpower - 13;
-	else if (txpower >= 12)
-		ret = txpower - 8;
-	else
-		ret = txpower;
-
-	return ret;
-}
-
-void bcm43xx_radio_set_txpower_a(struct bcm43xx_private *bcm, u16 txpower)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 pamp, base, dac, ilt;
-
-	txpower = limit_value(txpower, 0, 63);
-
-	pamp = bcm43xx_get_txgain_freq_power_amp(txpower);
-	pamp <<= 5;
-	pamp &= 0x00E0;
-	bcm43xx_phy_write(bcm, 0x0019, pamp);
-
-	base = bcm43xx_get_txgain_base_band(txpower);
-	base &= 0x000F;
-	bcm43xx_phy_write(bcm, 0x0017, base | 0x0020);
-
-	ilt = bcm43xx_ilt_read(bcm, 0x3001);
-	ilt &= 0x0007;
-
-	dac = bcm43xx_get_txgain_dac(txpower);
-	dac <<= 3;
-	dac |= ilt;
-
-	bcm43xx_ilt_write(bcm, 0x3001, dac);
-
-	radio->txpwr_offset = txpower;
-
-	TODO();
-	//TODO: FuncPlaceholder (Adjust BB loft cancel)
-}
-
-void bcm43xx_radio_set_txpower_bg(struct bcm43xx_private *bcm,
-                                 u16 baseband_attenuation, u16 radio_attenuation,
-                                 u16 txpower)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	if (baseband_attenuation == 0xFFFF)
-		baseband_attenuation = radio->baseband_atten;
-	if (radio_attenuation == 0xFFFF)
-		radio_attenuation = radio->radio_atten;
-	if (txpower == 0xFFFF)
-		txpower = radio->txctl1;
-	radio->baseband_atten = baseband_attenuation;
-	radio->radio_atten = radio_attenuation;
-	radio->txctl1 = txpower;
-
-	assert(/*baseband_attenuation >= 0 &&*/ baseband_attenuation <= 11);
-	if (radio->revision < 6)
-		assert(/*radio_attenuation >= 0 &&*/ radio_attenuation <= 9);
-	else
-		assert(/* radio_attenuation >= 0 &&*/ radio_attenuation <= 31);
-	assert(/*txpower >= 0 &&*/ txpower <= 7);
-
-	bcm43xx_phy_set_baseband_attenuation(bcm, baseband_attenuation);
-	bcm43xx_radio_write16(bcm, 0x0043, radio_attenuation);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0064, radio_attenuation);
-	if (radio->version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0052,
-		                      (bcm43xx_radio_read16(bcm, 0x0052) & ~0x0070)
-				       | ((txpower << 4) & 0x0070));
-	}
-	//FIXME: The spec is very weird and unclear here.
-	if (phy->type == BCM43xx_PHYTYPE_G)
-		bcm43xx_phy_lo_adjust(bcm, 0);
-}
-
-u16 bcm43xx_default_baseband_attenuation(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-
-	if (radio->version == 0x2050 && radio->revision < 6)
-		return 0;
-	return 2;
-}
-
-u16 bcm43xx_default_radio_attenuation(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 att = 0xFFFF;
-
-	if (phy->type == BCM43xx_PHYTYPE_A)
-		return 0x60;
-
-	switch (radio->version) {
-	case 0x2053:
-		switch (radio->revision) {
-		case 1:
-			att = 6;
-			break;
-		}
-		break;
-	case 0x2050:
-		switch (radio->revision) {
-		case 0:
-			att = 5;
-			break;
-		case 1:
-			if (phy->type == BCM43xx_PHYTYPE_G) {
-				if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-				    bcm->board_type == 0x421 &&
-				    bcm->board_revision >= 30)
-					att = 3;
-				else if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-					 bcm->board_type == 0x416)
-					att = 3;
-				else
-					att = 1;
-			} else {
-				if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-				    bcm->board_type == 0x421 &&
-				    bcm->board_revision >= 30)
-					att = 7;
-				else
-					att = 6;
-			}
-			break;
-		case 2:
-			if (phy->type == BCM43xx_PHYTYPE_G) {
-				if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-				    bcm->board_type == 0x421 &&
-				    bcm->board_revision >= 30)
-					att = 3;
-				else if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-					 bcm->board_type == 0x416)
-					att = 5;
-				else if (bcm->chip_id == 0x4320)
-					att = 4;
-				else
-					att = 3;
-			} else
-				att = 6;
-			break;
-		case 3:
-			att = 5;
-			break;
-		case 4:
-		case 5:
-			att = 1;
-			break;
-		case 6:
-		case 7:
-			att = 5;
-			break;
-		case 8:
-			att = 0x1A;
-			break;
-		case 9:
-		default:
-			att = 5;
-		}
-	}
-	if (bcm->board_vendor == PCI_VENDOR_ID_BROADCOM &&
-	    bcm->board_type == 0x421) {
-		if (bcm->board_revision < 0x43)
-			att = 2;
-		else if (bcm->board_revision < 0x51)
-			att = 3;
-	}
-	if (att == 0xFFFF)
-		att = 5;
-
-	return att;
-}
-
-u16 bcm43xx_default_txctl1(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-
-	if (radio->version != 0x2050)
-		return 0;
-	if (radio->revision == 1)
-		return 3;
-	if (radio->revision < 6)
-		return 2;
-	if (radio->revision == 8)
-		return 1;
-	return 0;
-}
-
-void bcm43xx_radio_turn_on(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	int err;
-
-	if (radio->enabled)
-		return;
-
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		bcm43xx_radio_write16(bcm, 0x0004, 0x00C0);
-		bcm43xx_radio_write16(bcm, 0x0005, 0x0008);
-		bcm43xx_phy_write(bcm, 0x0010, bcm43xx_phy_read(bcm, 0x0010) & 0xFFF7);
-		bcm43xx_phy_write(bcm, 0x0011, bcm43xx_phy_read(bcm, 0x0011) & 0xFFF7);
-		bcm43xx_radio_init2060(bcm);	
-		break;
-	case BCM43xx_PHYTYPE_B:
-	case BCM43xx_PHYTYPE_G:
-		bcm43xx_phy_write(bcm, 0x0015, 0x8000);
-		bcm43xx_phy_write(bcm, 0x0015, 0xCC00);
-		bcm43xx_phy_write(bcm, 0x0015, (phy->connected ? 0x00C0 : 0x0000));
-		err = bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_BG, 1);
-		assert(err == 0);
-		break;
-	default:
-		assert(0);
-	}
-	radio->enabled = 1;
-	dprintk(KERN_INFO PFX "Radio turned on\n");
-	bcm43xx_leds_update(bcm, 0);
-}
-	
-void bcm43xx_radio_turn_off(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_radio_write16(bcm, 0x0004, 0x00FF);
-		bcm43xx_radio_write16(bcm, 0x0005, 0x00FB);
-		bcm43xx_phy_write(bcm, 0x0010, bcm43xx_phy_read(bcm, 0x0010) | 0x0008);
-		bcm43xx_phy_write(bcm, 0x0011, bcm43xx_phy_read(bcm, 0x0011) | 0x0008);
-	}
-	if (phy->type == BCM43xx_PHYTYPE_G && bcm->current_core->rev >= 5) {
-		bcm43xx_phy_write(bcm, 0x0811, bcm43xx_phy_read(bcm, 0x0811) | 0x008C);
-		bcm43xx_phy_write(bcm, 0x0812, bcm43xx_phy_read(bcm, 0x0812) & 0xFF73);
-	} else
-		bcm43xx_phy_write(bcm, 0x0015, 0xAA00);
-	radio->enabled = 0;
-	dprintk(KERN_INFO PFX "Radio initialized\n");
-	bcm43xx_leds_update(bcm, 0);
-}
-
-void bcm43xx_radio_clear_tssi(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	switch (phy->type) {
-	case BCM43xx_PHYTYPE_A:
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0068, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x006a, 0x7F7F);
-		break;
-	case BCM43xx_PHYTYPE_B:
-	case BCM43xx_PHYTYPE_G:
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0058, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x005a, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0070, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0072, 0x7F7F);
-		break;
-	}
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_radio.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_radio.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef BCM43xx_RADIO_H_
-#define BCM43xx_RADIO_H_
-
-#include "bcm43xx.h"
-
-
-#define BCM43xx_RADIO_DEFAULT_CHANNEL_A		36
-#define BCM43xx_RADIO_DEFAULT_CHANNEL_BG	6
-
-/* Force antenna 0. */
-#define BCM43xx_RADIO_TXANTENNA_0		0
-/* Force antenna 1. */
-#define BCM43xx_RADIO_TXANTENNA_1		1
-/* Use the RX antenna, that was selected for the most recently
- * received good PLCP header.
- */
-#define BCM43xx_RADIO_TXANTENNA_LASTPLCP	3
-#define BCM43xx_RADIO_TXANTENNA_DEFAULT		BCM43xx_RADIO_TXANTENNA_LASTPLCP
-
-#define BCM43xx_RADIO_INTERFMODE_NONE		0
-#define BCM43xx_RADIO_INTERFMODE_NONWLAN	1
-#define BCM43xx_RADIO_INTERFMODE_MANUALWLAN	2
-#define BCM43xx_RADIO_INTERFMODE_AUTOWLAN	3
-
-
-void bcm43xx_radio_lock(struct bcm43xx_private *bcm);
-void bcm43xx_radio_unlock(struct bcm43xx_private *bcm);
-
-u16 bcm43xx_radio_read16(struct bcm43xx_private *bcm, u16 offset);
-void bcm43xx_radio_write16(struct bcm43xx_private *bcm, u16 offset, u16 val);
-
-u16 bcm43xx_radio_init2050(struct bcm43xx_private *bcm);
-void bcm43xx_radio_init2060(struct bcm43xx_private *bcm);
-
-void bcm43xx_radio_turn_on(struct bcm43xx_private *bcm);
-void bcm43xx_radio_turn_off(struct bcm43xx_private *bcm);
-
-static inline
-int bcm43xx_is_hw_radio_enabled(struct bcm43xx_private *bcm)
-{
-	/* function to return state of hardware enable of radio
-	 * returns 0 if radio disabled, 1 if radio enabled
-	 */
-	if (bcm->current_core->rev >= 3)
-		return ((bcm43xx_read32(bcm, BCM43xx_MMIO_RADIO_HWENABLED_HI)
-					& BCM43xx_MMIO_RADIO_HWENABLED_HI_MASK)
-					== 0) ? 1 : 0;
-	else
-		return ((bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_HWENABLED_LO)
-					& BCM43xx_MMIO_RADIO_HWENABLED_LO_MASK)
-					== 0) ? 0 : 1;
-}
-
-int bcm43xx_radio_selectchannel(struct bcm43xx_private *bcm, u8 channel,
-				int synthetic_pu_workaround);
-
-void bcm43xx_radio_set_txpower_a(struct bcm43xx_private *bcm, u16 txpower);
-void bcm43xx_radio_set_txpower_bg(struct bcm43xx_private *bcm,
-                               u16 baseband_attenuation, u16 attenuation,
-			       u16 txpower);
-
-u16 bcm43xx_default_baseband_attenuation(struct bcm43xx_private *bcm);
-u16 bcm43xx_default_radio_attenuation(struct bcm43xx_private *bcm);
-u16 bcm43xx_default_txctl1(struct bcm43xx_private *bcm);
-
-void bcm43xx_radio_set_txantenna(struct bcm43xx_private *bcm, u32 val);
-
-void bcm43xx_radio_clear_tssi(struct bcm43xx_private *bcm);
-
-u8 bcm43xx_radio_aci_detect(struct bcm43xx_private *bcm, u8 channel);
-u8 bcm43xx_radio_aci_scan(struct bcm43xx_private *bcm);
-
-int bcm43xx_radio_set_interference_mitigation(struct bcm43xx_private *bcm, int mode);
-
-void bcm43xx_calc_nrssi_slope(struct bcm43xx_private *bcm);
-void bcm43xx_calc_nrssi_threshold(struct bcm43xx_private *bcm);
-s16 bcm43xx_nrssi_hw_read(struct bcm43xx_private *bcm, u16 offset);
-void bcm43xx_nrssi_hw_write(struct bcm43xx_private *bcm, u16 offset, s16 val);
-void bcm43xx_nrssi_hw_update(struct bcm43xx_private *bcm, u16 val);
-void bcm43xx_nrssi_mem_update(struct bcm43xx_private *bcm);
-
-void bcm43xx_radio_set_tx_iq(struct bcm43xx_private *bcm);
-u16 bcm43xx_radio_calibrationvalue(struct bcm43xx_private *bcm);
-
-#endif /* BCM43xx_RADIO_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
+++ /dev/null
@@ -1,471 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  SYSFS support routines
-
-  Copyright (c) 2006 Michael Buesch <mbuesch at freenet.de>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include "bcm43xx_sysfs.h"
-#include "bcm43xx.h"
-#include "bcm43xx_main.h"
-#include "bcm43xx_radio.h"
-
-#include <linux/capability.h>
-
-
-#define GENERIC_FILESIZE	64
-
-
-static int get_integer(const char *buf, size_t count)
-{
-	char tmp[10 + 1] = { 0 };
-	int ret = -EINVAL;
-
-	if (count == 0)
-		goto out;
-	count = min(count, (size_t)10);
-	memcpy(tmp, buf, count);
-	ret = simple_strtol(tmp, NULL, 10);
-out:
-	return ret;
-}
-
-static int get_boolean(const char *buf, size_t count)
-{
-	if (count != 0) {
-		if (buf[0] == '1')
-			return 1;
-		if (buf[0] == '0')
-			return 0;
-		if (count >= 4 && memcmp(buf, "true", 4) == 0)
-			return 1;
-		if (count >= 5 && memcmp(buf, "false", 5) == 0)
-			return 0;
-		if (count >= 3 && memcmp(buf, "yes", 3) == 0)
-			return 1;
-		if (count >= 2 && memcmp(buf, "no", 2) == 0)
-			return 0;
-		if (count >= 2 && memcmp(buf, "on", 2) == 0)
-			return 1;
-		if (count >= 3 && memcmp(buf, "off", 3) == 0)
-			return 0;
-	}
-	return -EINVAL;
-}
-
-static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len)
-{
-	int i, pos = 0;
-
-	for (i = 0; i < BCM43xx_SPROM_SIZE; i++) {
-		pos += snprintf(buf + pos, buf_len - pos - 1,
-				"%04X", swab16(sprom[i]) & 0xFFFF);
-	}
-	pos += snprintf(buf + pos, buf_len - pos - 1, "\n");
-
-	return pos + 1;
-}
-
-static int hex2sprom(u16 *sprom, const char *dump, size_t len)
-{
-	char tmp[5] = { 0 };
-	int cnt = 0;
-	unsigned long parsed;
-
-	if (len < BCM43xx_SPROM_SIZE * sizeof(u16) * 2)
-		return -EINVAL;
-
-	while (cnt < BCM43xx_SPROM_SIZE) {
-		memcpy(tmp, dump, 4);
-		dump += 4;
-		parsed = simple_strtoul(tmp, NULL, 16);
-		sprom[cnt++] = swab16((u16)parsed);
-	}
-
-	return 0;
-}
-
-static ssize_t bcm43xx_attr_sprom_show(struct device *dev,
-				       struct device_attribute *attr,
-				       char *buf)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	u16 *sprom;
-	unsigned long flags;
-	int err;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	assert(BCM43xx_SPROM_SIZE * sizeof(u16) <= PAGE_SIZE);
-	sprom = kmalloc(BCM43xx_SPROM_SIZE * sizeof(*sprom),
-			GFP_KERNEL);
-	if (!sprom)
-		return -ENOMEM;
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	err = bcm43xx_sprom_read(bcm, sprom);
-	if (!err)
-		err = sprom2hex(sprom, buf, PAGE_SIZE);
-	mmiowb();
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-	kfree(sprom);
-
-	return err;
-}
-
-static ssize_t bcm43xx_attr_sprom_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	u16 *sprom;
-	unsigned long flags;
-	int err;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	sprom = kmalloc(BCM43xx_SPROM_SIZE * sizeof(*sprom),
-			GFP_KERNEL);
-	if (!sprom)
-		return -ENOMEM;
-	err = hex2sprom(sprom, buf, count);
-	if (err)
-		goto out_kfree;
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	spin_lock(&bcm->leds_lock);
-	err = bcm43xx_sprom_write(bcm, sprom);
-	mmiowb();
-	spin_unlock(&bcm->leds_lock);
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-out_kfree:
-	kfree(sprom);
-
-	return err ? err : count;
-
-}
-
-static DEVICE_ATTR(sprom, 0600,
-		   bcm43xx_attr_sprom_show,
-		   bcm43xx_attr_sprom_store);
-
-static ssize_t bcm43xx_attr_interfmode_show(struct device *dev,
-					    struct device_attribute *attr,
-					    char *buf)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	ssize_t count = 0;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	mutex_lock(&bcm->mutex);
-
-	switch (bcm43xx_current_radio(bcm)->interfmode) {
-	case BCM43xx_RADIO_INTERFMODE_NONE:
-		count = snprintf(buf, PAGE_SIZE, "0 (No Interference Mitigation)\n");
-		break;
-	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
-		count = snprintf(buf, PAGE_SIZE, "1 (Non-WLAN Interference Mitigation)\n");
-		break;
-	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		count = snprintf(buf, PAGE_SIZE, "2 (WLAN Interference Mitigation)\n");
-		break;
-	default:
-		assert(0);
-	}
-
-	mutex_unlock(&bcm->mutex);
-
-	return count;
-
-}
-
-static ssize_t bcm43xx_attr_interfmode_store(struct device *dev,
-					     struct device_attribute *attr,
-					     const char *buf, size_t count)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	unsigned long flags;
-	int err;
-	int mode;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	mode = get_integer(buf, count);
-	switch (mode) {
-	case 0:
-		mode = BCM43xx_RADIO_INTERFMODE_NONE;
-		break;
-	case 1:
-		mode = BCM43xx_RADIO_INTERFMODE_NONWLAN;
-		break;
-	case 2:
-		mode = BCM43xx_RADIO_INTERFMODE_MANUALWLAN;
-		break;
-	case 3:
-		mode = BCM43xx_RADIO_INTERFMODE_AUTOWLAN;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-
-	err = bcm43xx_radio_set_interference_mitigation(bcm, mode);
-	if (err) {
-		printk(KERN_ERR PFX "Interference Mitigation not "
-				    "supported by device\n");
-	}
-	mmiowb();
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-
-	return err ? err : count;
-}
-
-static DEVICE_ATTR(interference, 0644,
-		   bcm43xx_attr_interfmode_show,
-		   bcm43xx_attr_interfmode_store);
-
-static ssize_t bcm43xx_attr_preamble_show(struct device *dev,
-					  struct device_attribute *attr,
-					  char *buf)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	ssize_t count;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	mutex_lock(&bcm->mutex);
-
-	if (bcm->short_preamble)
-		count = snprintf(buf, PAGE_SIZE, "1 (Short Preamble enabled)\n");
-	else
-		count = snprintf(buf, PAGE_SIZE, "0 (Short Preamble disabled)\n");
-
-	mutex_unlock(&bcm->mutex);
-
-	return count;
-}
-
-static ssize_t bcm43xx_attr_preamble_store(struct device *dev,
-					   struct device_attribute *attr,
-					   const char *buf, size_t count)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	unsigned long flags;
-	int value;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	value = get_boolean(buf, count);
-	if (value < 0)
-		return value;
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-
-	bcm->short_preamble = !!value;
-
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-
-	return count;
-}
-
-static DEVICE_ATTR(shortpreamble, 0644,
-		   bcm43xx_attr_preamble_show,
-		   bcm43xx_attr_preamble_store);
-
-static ssize_t bcm43xx_attr_phymode_store(struct device *dev,
-					  struct device_attribute *attr,
-					  const char *buf, size_t count)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	int phytype;
-	int err = -EINVAL;
-
-	if (count < 1)
-		goto out;
-	switch (buf[0]) {
-	case 'a':  case 'A':
-		phytype = BCM43xx_PHYTYPE_A;
-		break;
-	case 'b':  case 'B':
-		phytype = BCM43xx_PHYTYPE_B;
-		break;
-	case 'g':  case 'G':
-		phytype = BCM43xx_PHYTYPE_G;
-		break;
-	default:
-		goto out;
-	}
-
-	bcm43xx_cancel_work(bcm);
-	mutex_lock(&(bcm)->mutex);
-	err = bcm43xx_select_wireless_core(bcm, phytype);
-	if (!err)
-		bcm43xx_periodic_tasks_setup(bcm);
-	mutex_unlock(&(bcm)->mutex);
-	if (err == -ESRCH)
-		err = -ENODEV;
-
-out:
-	return err ? err : count;
-}
-
-static ssize_t bcm43xx_attr_phymode_show(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	ssize_t count = 0;
-
-	mutex_lock(&(bcm)->mutex);
-	switch (bcm43xx_current_phy(bcm)->type) {
-	case BCM43xx_PHYTYPE_A:
-		snprintf(buf, PAGE_SIZE, "A");
-		break;
-	case BCM43xx_PHYTYPE_B:
-		snprintf(buf, PAGE_SIZE, "B");
-		break;
-	case BCM43xx_PHYTYPE_G:
-		snprintf(buf, PAGE_SIZE, "G");
-		break;
-	default:
-		assert(0);
-	}
-	mutex_unlock(&(bcm)->mutex);
-
-	return count;
-}
-
-static DEVICE_ATTR(phymode, 0644,
-		   bcm43xx_attr_phymode_show,
-		   bcm43xx_attr_phymode_store);
-
-static ssize_t bcm43xx_attr_microcode_show(struct device *dev,
-					   struct device_attribute *attr,
-					   char *buf)
-{
-	unsigned long flags;
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	ssize_t count = 0;
-	u16 status;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	mutex_lock(&(bcm)->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	status = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODE_STATUS);
-
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&(bcm)->mutex);
-	switch (status) {
-	case 0x0000:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (invalid)\n",
-				 status);
-		break;
-	case 0x0001:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (init)\n",
-				 status);
-		break;
-	case 0x0002:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (active)\n",
-				 status);
-		break;
-	case 0x0003:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (suspended)\n",
-				 status);
-		break;
-	case 0x0004:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (asleep)\n",
-				 status);
-		break;
-	default:
-		count = snprintf(buf, PAGE_SIZE, "0x%.4x (unknown)\n",
-				 status);
-		break;
-	}
-
-	return count;
-}
-
-static DEVICE_ATTR(microcodestatus, 0444,
-		   bcm43xx_attr_microcode_show,
-		   NULL);
-
-int bcm43xx_sysfs_register(struct bcm43xx_private *bcm)
-{
-	struct device *dev = &bcm->pci_dev->dev;
-	int err;
-
-	assert(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED);
-
-	err = device_create_file(dev, &dev_attr_sprom);
-	if (err)
-		goto out;
-	err = device_create_file(dev, &dev_attr_interference);
-	if (err)
-		goto err_remove_sprom;
-	err = device_create_file(dev, &dev_attr_shortpreamble);
-	if (err)
-		goto err_remove_interfmode;
-	err = device_create_file(dev, &dev_attr_phymode);
-	if (err)
-		goto err_remove_shortpreamble;
-	err = device_create_file(dev, &dev_attr_microcodestatus);
-	if (err)
-		goto err_remove_phymode;
-
-out:
-	return err;
-err_remove_phymode:
-	device_remove_file(dev, &dev_attr_phymode);
-err_remove_shortpreamble:
-	device_remove_file(dev, &dev_attr_shortpreamble);
-err_remove_interfmode:
-	device_remove_file(dev, &dev_attr_interference);
-err_remove_sprom:
-	device_remove_file(dev, &dev_attr_sprom);
-	goto out;
-}
-
-void bcm43xx_sysfs_unregister(struct bcm43xx_private *bcm)
-{
-	struct device *dev = &bcm->pci_dev->dev;
-
-	device_remove_file(dev, &dev_attr_microcodestatus);
-	device_remove_file(dev, &dev_attr_phymode);
-	device_remove_file(dev, &dev_attr_shortpreamble);
-	device_remove_file(dev, &dev_attr_interference);
-	device_remove_file(dev, &dev_attr_sprom);
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef BCM43xx_SYSFS_H_
-#define BCM43xx_SYSFS_H_
-
-struct bcm43xx_private;
-
-int bcm43xx_sysfs_register(struct bcm43xx_private *bcm);
-void bcm43xx_sysfs_unregister(struct bcm43xx_private *bcm);
-
-#endif /* BCM43xx_SYSFS_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_wx.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_wx.c
+++ /dev/null
@@ -1,1035 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include <linux/wireless.h>
-#include <net/iw_handler.h>
-#include <net/ieee80211softmac.h>
-#include <net/ieee80211softmac_wx.h>
-#include <linux/capability.h>
-#include <linux/delay.h>
-
-#include "bcm43xx.h"
-#include "bcm43xx_wx.h"
-#include "bcm43xx_main.h"
-#include "bcm43xx_radio.h"
-#include "bcm43xx_phy.h"
-
-
-/* The WIRELESS_EXT version, which is implemented by this driver. */
-#define BCM43xx_WX_VERSION	18
-
-#define MAX_WX_STRING		80
-
-static int bcm43xx_wx_get_name(struct net_device *net_dev,
-                               struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int i;
-	struct bcm43xx_phyinfo *phy;
-	char suffix[7] = { 0 };
-	int have_a = 0, have_b = 0, have_g = 0;
-
-	mutex_lock(&bcm->mutex);
-	for (i = 0; i < bcm->nr_80211_available; i++) {
-		phy = &(bcm->core_80211_ext[i].phy);
-		switch (phy->type) {
-		case BCM43xx_PHYTYPE_A:
-			have_a = 1;
-			break;
-		case BCM43xx_PHYTYPE_G:
-			have_g = 1;
-		case BCM43xx_PHYTYPE_B:
-			have_b = 1;
-			break;
-		default:
-			assert(0);
-		}
-	}
-	mutex_unlock(&bcm->mutex);
-
-	i = 0;
-	if (have_a) {
-		suffix[i++] = 'a';
-		suffix[i++] = '/';
-	}
-	if (have_b) {
-		suffix[i++] = 'b';
-		suffix[i++] = '/';
-	}
-	if (have_g) {
-		suffix[i++] = 'g';
-		suffix[i++] = '/';
-	}
-	if (i != 0) 
-		suffix[i - 1] = '\0';
-
-	snprintf(data->name, IFNAMSIZ, "IEEE 802.11%s", suffix);
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_channelfreq(struct net_device *net_dev,
-				      struct iw_request_info *info,
-				      union iwreq_data *data,
-				      char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	u8 channel;
-	s8 expon;
-	int freq;
-	int err = -EINVAL;
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-
-	if ((data->freq.e == 0) &&
-	    (data->freq.m >= 0) && (data->freq.m <= 1000)) {
-		channel = data->freq.m;
-		freq = bcm43xx_channel_to_freq(bcm, channel);
-	} else {
-		freq = data->freq.m;
-		expon = 6 - data->freq.e;
-		while (--expon >= 0)    /* scale down the frequency to MHz */
-			freq /= 10;
-		assert(freq > 1000);
-		channel = bcm43xx_freq_to_channel(bcm, freq);
-	}
-	if (!ieee80211_is_valid_channel(bcm->ieee, channel))
-		goto out_unlock;
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		//ieee80211softmac_disassoc(softmac, $REASON);
-		bcm43xx_mac_suspend(bcm);
-		err = bcm43xx_radio_selectchannel(bcm, channel, 0);
-		bcm43xx_mac_enable(bcm);
-	} else {
-		bcm43xx_current_radio(bcm)->initial_channel = channel;
-		err = 0;
-	}
-out_unlock:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_channelfreq(struct net_device *net_dev,
-				      struct iw_request_info *info,
-				      union iwreq_data *data,
-				      char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct bcm43xx_radioinfo *radio;
-	int err = -ENODEV;
-	u16 channel;
-
-	mutex_lock(&bcm->mutex);
-	radio = bcm43xx_current_radio(bcm);
-	channel = radio->channel;
-	if (channel == 0xFF) {
-		channel = radio->initial_channel;
-		if (channel == 0xFF)
-			goto out_unlock;
-	}
-	assert(channel > 0 && channel <= 1000);
-	data->freq.e = 1;
-	data->freq.m = bcm43xx_channel_to_freq(bcm, channel) * 100000;
-	data->freq.flags = 1;
-
-	err = 0;
-out_unlock:
-	mutex_unlock(&bcm->mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_set_mode(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int mode;
-
-	mode = data->mode;
-	if (mode == IW_MODE_AUTO)
-		mode = BCM43xx_INITIAL_IWMODE;
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		if (bcm->ieee->iw_mode != mode)
-			bcm43xx_set_iwmode(bcm, mode);
-	} else
-		bcm->ieee->iw_mode = mode;
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_get_mode(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-
-	mutex_lock(&bcm->mutex);
-	data->mode = bcm->ieee->iw_mode;
-	mutex_unlock(&bcm->mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_get_rangeparams(struct net_device *net_dev,
-				      struct iw_request_info *info,
-				      union iwreq_data *data,
-				      char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct iw_range *range = (struct iw_range *)extra;
-	const struct ieee80211_geo *geo;
-	int i, j;
-	struct bcm43xx_phyinfo *phy;
-
-	data->data.length = sizeof(*range);
-	memset(range, 0, sizeof(*range));
-
-	//TODO: What about 802.11b?
-	/* 54Mb/s == ~27Mb/s payload throughput (802.11g) */
-	range->throughput = 27 * 1000 * 1000;
-
-	range->max_qual.qual = 100;
-	range->max_qual.level = 146; /* set floor at -110 dBm (146 - 256) */
-	range->max_qual.noise = 146;
-	range->max_qual.updated = IW_QUAL_ALL_UPDATED;
-
-	range->avg_qual.qual = 50;
-	range->avg_qual.level = 0;
-	range->avg_qual.noise = 0;
-	range->avg_qual.updated = IW_QUAL_ALL_UPDATED;
-
-	range->min_rts = BCM43xx_MIN_RTS_THRESHOLD;
-	range->max_rts = BCM43xx_MAX_RTS_THRESHOLD;
-	range->min_frag = MIN_FRAG_THRESHOLD;
-	range->max_frag = MAX_FRAG_THRESHOLD;
-
-	range->encoding_size[0] = 5;
-	range->encoding_size[1] = 13;
-	range->num_encoding_sizes = 2;
-	range->max_encoding_tokens = WEP_KEYS;
-
-	range->we_version_compiled = WIRELESS_EXT;
-	range->we_version_source = BCM43xx_WX_VERSION;
-
-	range->enc_capa = IW_ENC_CAPA_WPA |
-			  IW_ENC_CAPA_WPA2 |
-			  IW_ENC_CAPA_CIPHER_TKIP |
-			  IW_ENC_CAPA_CIPHER_CCMP;
-
-	mutex_lock(&bcm->mutex);
-	phy = bcm43xx_current_phy(bcm);
-
-	range->num_bitrates = 0;
-	i = 0;
-	if (phy->type == BCM43xx_PHYTYPE_A ||
-	    phy->type == BCM43xx_PHYTYPE_G) {
-		range->num_bitrates = 8;
-		range->bitrate[i++] = IEEE80211_OFDM_RATE_6MB * 500000;
-		range->bitrate[i++] = IEEE80211_OFDM_RATE_9MB * 500000;
-		range->bitrate[i++] = IEEE80211_OFDM_RATE_12MB * 500000;
-		range->bitrate[i++] = IEEE80211_OFDM_RATE_18MB * 500000;
-		range->bitrate[i++] = IEEE80211_OFDM_RATE_24MB * 500000;
-		range->bitrate[i++] = IEEE80211_OFDM_RATE_36MB * 500000;
-		range->bitrate[i++] = IEEE80211_OFDM_RATE_48MB * 500000;
-		range->bitrate[i++] = IEEE80211_OFDM_RATE_54MB * 500000;
-	}
-	if (phy->type == BCM43xx_PHYTYPE_B ||
-	    phy->type == BCM43xx_PHYTYPE_G) {
-		range->num_bitrates += 4;
-		range->bitrate[i++] = IEEE80211_CCK_RATE_1MB * 500000;
-		range->bitrate[i++] = IEEE80211_CCK_RATE_2MB * 500000;
-		range->bitrate[i++] = IEEE80211_CCK_RATE_5MB * 500000;
-		range->bitrate[i++] = IEEE80211_CCK_RATE_11MB * 500000;
-	}
-
-	geo = ieee80211_get_geo(bcm->ieee);
-	range->num_channels = geo->a_channels + geo->bg_channels;
-	j = 0;
-	for (i = 0; i < geo->a_channels; i++) {
-		if (j == IW_MAX_FREQUENCIES)
-			break;
-		range->freq[j].i = j + 1;
-		range->freq[j].m = geo->a[i].freq * 100000;
-		range->freq[j].e = 1;
-		j++;
-	}
-	for (i = 0; i < geo->bg_channels; i++) {
-		if (j == IW_MAX_FREQUENCIES)
-			break;
-		range->freq[j].i = j + 1;
-		range->freq[j].m = geo->bg[i].freq * 100000;
-		range->freq[j].e = 1;
-		j++;
-	}
-	range->num_frequency = j;
-
-	mutex_unlock(&bcm->mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_nick(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	size_t len;
-
-	mutex_lock(&bcm->mutex);
-	len =  min((size_t)data->data.length, (size_t)IW_ESSID_MAX_SIZE);
-	memcpy(bcm->nick, extra, len);
-	bcm->nick[len] = '\0';
-	mutex_unlock(&bcm->mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_get_nick(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	size_t len;
-
-	mutex_lock(&bcm->mutex);
-	len = strlen(bcm->nick);
-	memcpy(extra, bcm->nick, len);
-	data->data.length = (__u16)len;
-	data->data.flags = 1;
-	mutex_unlock(&bcm->mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_rts(struct net_device *net_dev,
-			      struct iw_request_info *info,
-			      union iwreq_data *data,
-			      char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int err = -EINVAL;
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (data->rts.disabled) {
-		bcm->rts_threshold = BCM43xx_MAX_RTS_THRESHOLD;
-		err = 0;
-	} else {
-		if (data->rts.value >= BCM43xx_MIN_RTS_THRESHOLD &&
-		    data->rts.value <= BCM43xx_MAX_RTS_THRESHOLD) {
-			bcm->rts_threshold = data->rts.value;
-			err = 0;
-		}
-	}
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_rts(struct net_device *net_dev,
-			      struct iw_request_info *info,
-			      union iwreq_data *data,
-			      char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-
-	mutex_lock(&bcm->mutex);
-	data->rts.value = bcm->rts_threshold;
-	data->rts.fixed = 0;
-	data->rts.disabled = (bcm->rts_threshold == BCM43xx_MAX_RTS_THRESHOLD);
-	mutex_unlock(&bcm->mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_frag(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int err = -EINVAL;
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (data->frag.disabled) {
-		bcm->ieee->fts = MAX_FRAG_THRESHOLD;
-		err = 0;
-	} else {
-		if (data->frag.value >= MIN_FRAG_THRESHOLD &&
-		    data->frag.value <= MAX_FRAG_THRESHOLD) {
-			bcm->ieee->fts = data->frag.value & ~0x1;
-			err = 0;
-		}
-	}
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_frag(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-
-	mutex_lock(&bcm->mutex);
-	data->frag.value = bcm->ieee->fts;
-	data->frag.fixed = 0;
-	data->frag.disabled = (bcm->ieee->fts == MAX_FRAG_THRESHOLD);
-	mutex_unlock(&bcm->mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_xmitpower(struct net_device *net_dev,
-				    struct iw_request_info *info,
-				    union iwreq_data *data,
-				    char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct bcm43xx_radioinfo *radio;
-	struct bcm43xx_phyinfo *phy;
-	unsigned long flags;
-	int err = -ENODEV;
-	u16 maxpower;
-
-	if ((data->txpower.flags & IW_TXPOW_TYPE) != IW_TXPOW_DBM) {
-		printk(KERN_ERR PFX "TX power not in dBm.\n");
-		return -EOPNOTSUPP;
-	}
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)
-		goto out_unlock;
-	radio = bcm43xx_current_radio(bcm);
-	phy = bcm43xx_current_phy(bcm);
-	if (data->txpower.disabled != (!(radio->enabled))) {
-		if (data->txpower.disabled)
-			bcm43xx_radio_turn_off(bcm);
-		else
-			bcm43xx_radio_turn_on(bcm);
-	}
-	if (data->txpower.value > 0) {
-		/* desired and maxpower dBm values are in Q5.2 */
-		if (phy->type == BCM43xx_PHYTYPE_A)
-			maxpower = bcm->sprom.maxpower_aphy;
-		else
-			maxpower = bcm->sprom.maxpower_bgphy;
-		radio->txpower_desired = limit_value(data->txpower.value << 2,
-						     0, maxpower);
-		bcm43xx_phy_xmitpower(bcm);
-	}
-	err = 0;
-
-out_unlock:
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_xmitpower(struct net_device *net_dev,
-				    struct iw_request_info *info,
-				    union iwreq_data *data,
-				    char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct bcm43xx_radioinfo *radio;
-	int err = -ENODEV;
-
-	mutex_lock(&bcm->mutex);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)
-		goto out_unlock;
-	radio = bcm43xx_current_radio(bcm);
-	/* desired dBm value is in Q5.2 */
-	data->txpower.value = radio->txpower_desired >> 2;
-	data->txpower.fixed = 1;
-	data->txpower.flags = IW_TXPOW_DBM;
-	data->txpower.disabled = !(radio->enabled);
-
-	err = 0;
-out_unlock:
-	mutex_unlock(&bcm->mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_set_encoding(struct net_device *net_dev,
-				   struct iw_request_info *info,
-				   union iwreq_data *data,
-				   char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
-
-	err = ieee80211_wx_set_encode(bcm->ieee, info, data, extra);
-
-	return err;
-}
-
-static int bcm43xx_wx_set_encodingext(struct net_device *net_dev,
-                                   struct iw_request_info *info,
-                                   union iwreq_data *data,
-                                   char *extra)
-{
-        struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-        int err;
-
-        err = ieee80211_wx_set_encodeext(bcm->ieee, info, data, extra);
-
-        return err;
-}
-
-static int bcm43xx_wx_get_encoding(struct net_device *net_dev,
-				   struct iw_request_info *info,
-				   union iwreq_data *data,
-				   char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
-
-	err = ieee80211_wx_get_encode(bcm->ieee, info, data, extra);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_encodingext(struct net_device *net_dev,
-                                   struct iw_request_info *info,
-                                   union iwreq_data *data,
-                                   char *extra)
-{
-        struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-        int err;
-
-        err = ieee80211_wx_get_encodeext(bcm->ieee, info, data, extra);
-
-        return err;
-}
-
-static int bcm43xx_wx_set_interfmode(struct net_device *net_dev,
-				     struct iw_request_info *info,
-				     union iwreq_data *data,
-				     char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int mode, err = 0;
-
-	mode = *((int *)extra);
-	switch (mode) {
-	case 0:
-		mode = BCM43xx_RADIO_INTERFMODE_NONE;
-		break;
-	case 1:
-		mode = BCM43xx_RADIO_INTERFMODE_NONWLAN;
-		break;
-	case 2:
-		mode = BCM43xx_RADIO_INTERFMODE_MANUALWLAN;
-		break;
-	case 3:
-		mode = BCM43xx_RADIO_INTERFMODE_AUTOWLAN;
-		break;
-	default:
-		printk(KERN_ERR PFX "set_interfmode allowed parameters are: "
-				    "0 => None,  1 => Non-WLAN,  2 => WLAN,  "
-				    "3 => Auto-WLAN\n");
-		return -EINVAL;
-	}
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		err = bcm43xx_radio_set_interference_mitigation(bcm, mode);
-		if (err) {
-			printk(KERN_ERR PFX "Interference Mitigation not "
-					    "supported by device\n");
-		}
-	} else {
-		if (mode == BCM43xx_RADIO_INTERFMODE_AUTOWLAN) {
-			printk(KERN_ERR PFX "Interference Mitigation mode Auto-WLAN "
-					    "not supported while the interface is down.\n");
-			err = -ENODEV;
-		} else
-			bcm43xx_current_radio(bcm)->interfmode = mode;
-	}
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_interfmode(struct net_device *net_dev,
-				     struct iw_request_info *info,
-				     union iwreq_data *data,
-				     char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int mode;
-
-	mutex_lock(&bcm->mutex);
-	mode = bcm43xx_current_radio(bcm)->interfmode;
-	mutex_unlock(&bcm->mutex);
-
-	switch (mode) {
-	case BCM43xx_RADIO_INTERFMODE_NONE:
-		strncpy(extra, "0 (No Interference Mitigation)", MAX_WX_STRING);
-		break;
-	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
-		strncpy(extra, "1 (Non-WLAN Interference Mitigation)", MAX_WX_STRING);
-		break;
-	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		strncpy(extra, "2 (WLAN Interference Mitigation)", MAX_WX_STRING);
-		break;
-	default:
-		assert(0);
-	}
-	data->data.length = strlen(extra) + 1;
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_shortpreamble(struct net_device *net_dev,
-					struct iw_request_info *info,
-					union iwreq_data *data,
-					char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int on;
-
-	on = *((int *)extra);
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	bcm->short_preamble = !!on;
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_get_shortpreamble(struct net_device *net_dev,
-					struct iw_request_info *info,
-					union iwreq_data *data,
-					char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int on;
-
-	mutex_lock(&bcm->mutex);
-	on = bcm->short_preamble;
-	mutex_unlock(&bcm->mutex);
-
-	if (on)
-		strncpy(extra, "1 (Short Preamble enabled)", MAX_WX_STRING);
-	else
-		strncpy(extra, "0 (Short Preamble disabled)", MAX_WX_STRING);
-	data->data.length = strlen(extra) + 1;
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_swencryption(struct net_device *net_dev,
-				       struct iw_request_info *info,
-				       union iwreq_data *data,
-				       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int on;
-	
-	on = *((int *)extra);
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	bcm->ieee->host_encrypt = !!on;
-	bcm->ieee->host_decrypt = !!on;
-	bcm->ieee->host_build_iv = !on;
-	bcm->ieee->host_strip_iv_icv = !on;
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_get_swencryption(struct net_device *net_dev,
-				       struct iw_request_info *info,
-				       union iwreq_data *data,
-				       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int on;
-
-	mutex_lock(&bcm->mutex);
-	on = bcm->ieee->host_encrypt;
-	mutex_unlock(&bcm->mutex);
-
-	if (on)
-		strncpy(extra, "1 (SW encryption enabled) ", MAX_WX_STRING);
-	else
-		strncpy(extra, "0 (SW encryption disabled) ", MAX_WX_STRING);
-	data->data.length = strlen(extra + 1);
-
-	return 0;
-}
-
-/* Enough buffer to hold a hexdump of the sprom data. */
-#define SPROM_BUFFERSIZE	512
-
-static int sprom2hex(const u16 *sprom, char *dump)
-{
-	int i, pos = 0;
-
-	for (i = 0; i < BCM43xx_SPROM_SIZE; i++) {
-		pos += snprintf(dump + pos, SPROM_BUFFERSIZE - pos - 1,
-				"%04X", swab16(sprom[i]) & 0xFFFF);
-	}
-
-	return pos + 1;
-}
-
-static int hex2sprom(u16 *sprom, const char *dump, unsigned int len)
-{
-	char tmp[5] = { 0 };
-	int cnt = 0;
-	unsigned long parsed;
-
-	if (len < BCM43xx_SPROM_SIZE * sizeof(u16) * 2)
-		return -EINVAL;
-	while (cnt < BCM43xx_SPROM_SIZE) {
-		memcpy(tmp, dump, 4);
-		dump += 4;
-		parsed = simple_strtoul(tmp, NULL, 16);
-		sprom[cnt++] = swab16((u16)parsed);
-	}
-
-	return 0;
-}
-
-static int bcm43xx_wx_sprom_read(struct net_device *net_dev,
-				 struct iw_request_info *info,
-				 union iwreq_data *data,
-				 char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err = -EPERM;
-	u16 *sprom;
-	unsigned long flags;
-
-	if (!capable(CAP_SYS_RAWIO))
-		goto out;
-
-	err = -ENOMEM;
-	sprom = kmalloc(BCM43xx_SPROM_SIZE * sizeof(*sprom),
-			GFP_KERNEL);
-	if (!sprom)
-		goto out;
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	err = -ENODEV;
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED)
-		err = bcm43xx_sprom_read(bcm, sprom);
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-	if (!err)
-		data->data.length = sprom2hex(sprom, extra);
-	kfree(sprom);
-out:
-	return err;
-}
-
-static int bcm43xx_wx_sprom_write(struct net_device *net_dev,
-				  struct iw_request_info *info,
-				  union iwreq_data *data,
-				  char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err = -EPERM;
-	u16 *sprom;
-	unsigned long flags;
-	char *input;
-	unsigned int len;
-
-	if (!capable(CAP_SYS_RAWIO))
-		goto out;
-
-	err = -ENOMEM;
-	sprom = kmalloc(BCM43xx_SPROM_SIZE * sizeof(*sprom),
-			GFP_KERNEL);
-	if (!sprom)
-		goto out;
-
-	len = data->data.length;
-	extra[len - 1] = '\0';
-	input = strchr(extra, ':');
-	if (input) {
-		input++;
-		len -= input - extra;
-	} else
-		input = extra;
-	err = hex2sprom(sprom, input, len);
-	if (err)
-		goto out_kfree;
-
-	mutex_lock(&bcm->mutex);
-	spin_lock_irqsave(&bcm->irq_lock, flags);
-	spin_lock(&bcm->leds_lock);
-	err = -ENODEV;
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED)
-		err = bcm43xx_sprom_write(bcm, sprom);
-	spin_unlock(&bcm->leds_lock);
-	spin_unlock_irqrestore(&bcm->irq_lock, flags);
-	mutex_unlock(&bcm->mutex);
-out_kfree:
-	kfree(sprom);
-out:
-	return err;
-}
-
-/* Get wireless statistics.  Called by /proc/net/wireless and by SIOCGIWSTATS */
-
-static struct iw_statistics *bcm43xx_get_wireless_stats(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct ieee80211softmac_device *mac = ieee80211_priv(net_dev);
-	struct iw_statistics *wstats;
-	struct ieee80211_network *network = NULL;
-	static int tmp_level = 0;
-	static int tmp_qual = 0;
-	unsigned long flags;
-
-	wstats = &bcm->stats.wstats;
-	if (!mac->associnfo.associated) {
-		wstats->miss.beacon = 0;
-//		bcm->ieee->ieee_stats.tx_retry_limit_exceeded = 0; // FIXME: should this be cleared here?
-		wstats->discard.retries = 0;
-//		bcm->ieee->ieee_stats.tx_discards_wrong_sa = 0; // FIXME: same question
-		wstats->discard.nwid = 0;
-//		bcm->ieee->ieee_stats.rx_discards_undecryptable = 0; // FIXME: ditto
-		wstats->discard.code = 0;
-//		bcm->ieee->ieee_stats.rx_fragments = 0;  // FIXME: same here
-		wstats->discard.fragment = 0;
-		wstats->discard.misc = 0;
-		wstats->qual.qual = 0;
-		wstats->qual.level = 0;
-		wstats->qual.noise = 0;
-		wstats->qual.updated = 7;
-		wstats->qual.updated |= IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
-		return wstats;
-	}
-	/* fill in the real statistics when iface associated */
-	spin_lock_irqsave(&mac->ieee->lock, flags);
-	list_for_each_entry(network, &mac->ieee->network_list, list) {
-		if (!memcmp(mac->associnfo.bssid, network->bssid, ETH_ALEN)) {
-			if (!tmp_level)	{	/* get initial values */
-				tmp_level = network->stats.signal;
-				tmp_qual = network->stats.rssi;
-			} else {		/* smooth results */
-				tmp_level = (15 * tmp_level + network->stats.signal)/16;
-				tmp_qual = (15 * tmp_qual + network->stats.rssi)/16;
-			}
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&mac->ieee->lock, flags);
-	wstats->qual.level = tmp_level;
-	wstats->qual.qual = 100 * tmp_qual / RX_RSSI_MAX;
-	wstats->qual.noise = bcm->stats.noise;
-	wstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
-	wstats->discard.code = bcm->ieee->ieee_stats.rx_discards_undecryptable;
-	wstats->discard.retries = bcm->ieee->ieee_stats.tx_retry_limit_exceeded;
-	wstats->discard.nwid = bcm->ieee->ieee_stats.tx_discards_wrong_sa;
-	wstats->discard.fragment = bcm->ieee->ieee_stats.rx_fragments;
-	wstats->discard.misc = 0;	// FIXME
-	wstats->miss.beacon = 0;	// FIXME
-	return wstats;
-}
-
-
-#ifdef WX
-# undef WX
-#endif
-#define WX(ioctl)  [(ioctl) - SIOCSIWCOMMIT]
-static const iw_handler bcm43xx_wx_handlers[] = {
-	/* Wireless Identification */
-	WX(SIOCGIWNAME)		= bcm43xx_wx_get_name,
-	/* Basic operations */
-	WX(SIOCSIWFREQ)		= bcm43xx_wx_set_channelfreq,
-	WX(SIOCGIWFREQ)		= bcm43xx_wx_get_channelfreq,
-	WX(SIOCSIWMODE)		= bcm43xx_wx_set_mode,
-	WX(SIOCGIWMODE)		= bcm43xx_wx_get_mode,
-	/* Informative stuff */
-	WX(SIOCGIWRANGE)	= bcm43xx_wx_get_rangeparams,
-	/* Access Point manipulation */
-	WX(SIOCSIWAP)           = ieee80211softmac_wx_set_wap,
-	WX(SIOCGIWAP)           = ieee80211softmac_wx_get_wap,
-	WX(SIOCSIWSCAN)		= ieee80211softmac_wx_trigger_scan,
-	WX(SIOCGIWSCAN)		= ieee80211softmac_wx_get_scan_results,
-	/* 802.11 specific support */
-	WX(SIOCSIWESSID)	= ieee80211softmac_wx_set_essid,
-	WX(SIOCGIWESSID)	= ieee80211softmac_wx_get_essid,
-	WX(SIOCSIWNICKN)	= bcm43xx_wx_set_nick,
-	WX(SIOCGIWNICKN)	= bcm43xx_wx_get_nick,
-	/* Other parameters */
-	WX(SIOCSIWRATE)		= ieee80211softmac_wx_set_rate,
-	WX(SIOCGIWRATE)		= ieee80211softmac_wx_get_rate,
-	WX(SIOCSIWRTS)		= bcm43xx_wx_set_rts,
-	WX(SIOCGIWRTS)		= bcm43xx_wx_get_rts,
-	WX(SIOCSIWFRAG)		= bcm43xx_wx_set_frag,
-	WX(SIOCGIWFRAG)		= bcm43xx_wx_get_frag,
-	WX(SIOCSIWTXPOW)	= bcm43xx_wx_set_xmitpower,
-	WX(SIOCGIWTXPOW)	= bcm43xx_wx_get_xmitpower,
-//TODO	WX(SIOCSIWRETRY)	= bcm43xx_wx_set_retry,
-//TODO	WX(SIOCGIWRETRY)	= bcm43xx_wx_get_retry,
-	/* Encoding */
-	WX(SIOCSIWENCODE)	= bcm43xx_wx_set_encoding,
-	WX(SIOCGIWENCODE)	= bcm43xx_wx_get_encoding,
-	WX(SIOCSIWENCODEEXT)	= bcm43xx_wx_set_encodingext,
-	WX(SIOCGIWENCODEEXT)	= bcm43xx_wx_get_encodingext,
-	/* Power saving */
-//TODO	WX(SIOCSIWPOWER)	= bcm43xx_wx_set_power,
-//TODO	WX(SIOCGIWPOWER)	= bcm43xx_wx_get_power,
-	WX(SIOCSIWGENIE)	= ieee80211softmac_wx_set_genie,
-	WX(SIOCGIWGENIE)	= ieee80211softmac_wx_get_genie,
-	WX(SIOCSIWAUTH)		= ieee80211_wx_set_auth,
-	WX(SIOCGIWAUTH)		= ieee80211_wx_get_auth,
-};
-#undef WX
-
-static const iw_handler bcm43xx_priv_wx_handlers[] = {
-	/* Set Interference Mitigation Mode. */
-	bcm43xx_wx_set_interfmode,
-	/* Get Interference Mitigation Mode. */
-	bcm43xx_wx_get_interfmode,
-	/* Enable/Disable Short Preamble mode. */
-	bcm43xx_wx_set_shortpreamble,
-	/* Get Short Preamble mode. */
-	bcm43xx_wx_get_shortpreamble,
-	/* Enable/Disable Software Encryption mode */
-	bcm43xx_wx_set_swencryption,
-	/* Get Software Encryption mode */
-	bcm43xx_wx_get_swencryption,
-	/* Write SRPROM data. */
-	bcm43xx_wx_sprom_write,
-	/* Read SPROM data. */
-	bcm43xx_wx_sprom_read,
-};
-
-#define PRIV_WX_SET_INTERFMODE		(SIOCIWFIRSTPRIV + 0)
-#define PRIV_WX_GET_INTERFMODE		(SIOCIWFIRSTPRIV + 1)
-#define PRIV_WX_SET_SHORTPREAMBLE	(SIOCIWFIRSTPRIV + 2)
-#define PRIV_WX_GET_SHORTPREAMBLE	(SIOCIWFIRSTPRIV + 3)
-#define PRIV_WX_SET_SWENCRYPTION	(SIOCIWFIRSTPRIV + 4)
-#define PRIV_WX_GET_SWENCRYPTION	(SIOCIWFIRSTPRIV + 5)
-#define PRIV_WX_SPROM_WRITE		(SIOCIWFIRSTPRIV + 6)
-#define PRIV_WX_SPROM_READ		(SIOCIWFIRSTPRIV + 7)
-
-#define PRIV_WX_DUMMY(ioctl)	\
-	{					\
-		.cmd		= (ioctl),	\
-		.name		= "__unused"	\
-	}
-
-static const struct iw_priv_args bcm43xx_priv_wx_args[] = {
-	{
-		.cmd		= PRIV_WX_SET_INTERFMODE,
-		.set_args	= IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
-		.name		= "set_interfmode",
-	},
-	{
-		.cmd		= PRIV_WX_GET_INTERFMODE,
-		.get_args	= IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_WX_STRING,
-		.name		= "get_interfmode",
-	},
-	{
-		.cmd		= PRIV_WX_SET_SHORTPREAMBLE,
-		.set_args	= IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
-		.name		= "set_shortpreamb",
-	},
-	{
-		.cmd		= PRIV_WX_GET_SHORTPREAMBLE,
-		.get_args	= IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_WX_STRING,
-		.name		= "get_shortpreamb",
-	},
-	{
-		.cmd		= PRIV_WX_SET_SWENCRYPTION,
-		.set_args	= IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
-		.name		= "set_swencrypt",
-	},
-	{
-		.cmd		= PRIV_WX_GET_SWENCRYPTION,
-		.get_args	= IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_WX_STRING,
-		.name		= "get_swencrypt",
-	},
-	{
-		.cmd		= PRIV_WX_SPROM_WRITE,
-		.set_args	= IW_PRIV_TYPE_CHAR | SPROM_BUFFERSIZE,
-		.name		= "write_sprom",
-	},
-	{
-		.cmd		= PRIV_WX_SPROM_READ,
-		.get_args	= IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | SPROM_BUFFERSIZE,
-		.name		= "read_sprom",
-	},
-};
-
-const struct iw_handler_def bcm43xx_wx_handlers_def = {
-	.standard		= bcm43xx_wx_handlers,
-	.num_standard		= ARRAY_SIZE(bcm43xx_wx_handlers),
-	.num_private		= ARRAY_SIZE(bcm43xx_priv_wx_handlers),
-	.num_private_args	= ARRAY_SIZE(bcm43xx_priv_wx_args),
-	.private		= bcm43xx_priv_wx_handlers,
-	.private_args		= bcm43xx_priv_wx_args,
-	.get_wireless_stats	= bcm43xx_get_wireless_stats,
-};
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_wx.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_wx.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef BCM43xx_WX_H_
-#define BCM43xx_WX_H_
-
-extern const struct iw_handler_def bcm43xx_wx_handlers_def;
-
-#endif /* BCM43xx_WX_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_xmit.c
+++ /dev/null
@@ -1,565 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Transmission (TX/RX) related functions.
-
-  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mbuesch at freenet.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include "bcm43xx_xmit.h"
-
-#include <linux/etherdevice.h>
-
-
-/* Extract the bitrate out of a CCK PLCP header. */
-static u8 bcm43xx_plcp_get_bitrate_cck(struct bcm43xx_plcp_hdr4 *plcp)
-{
-	switch (plcp->raw[0]) {
-	case 0x0A:
-		return IEEE80211_CCK_RATE_1MB;
-	case 0x14:
-		return IEEE80211_CCK_RATE_2MB;
-	case 0x37:
-		return IEEE80211_CCK_RATE_5MB;
-	case 0x6E:
-		return IEEE80211_CCK_RATE_11MB;
-	}
-	assert(0);
-	return 0;
-}
-
-/* Extract the bitrate out of an OFDM PLCP header. */
-static u8 bcm43xx_plcp_get_bitrate_ofdm(struct bcm43xx_plcp_hdr4 *plcp)
-{
-	switch (plcp->raw[0] & 0xF) {
-	case 0xB:
-		return IEEE80211_OFDM_RATE_6MB;
-	case 0xF:
-		return IEEE80211_OFDM_RATE_9MB;
-	case 0xA:
-		return IEEE80211_OFDM_RATE_12MB;
-	case 0xE:
-		return IEEE80211_OFDM_RATE_18MB;
-	case 0x9:
-		return IEEE80211_OFDM_RATE_24MB;
-	case 0xD:
-		return IEEE80211_OFDM_RATE_36MB;
-	case 0x8:
-		return IEEE80211_OFDM_RATE_48MB;
-	case 0xC:
-		return IEEE80211_OFDM_RATE_54MB;
-	}
-	assert(0);
-	return 0;
-}
-
-u8 bcm43xx_plcp_get_ratecode_cck(const u8 bitrate)
-{
-	switch (bitrate) {
-	case IEEE80211_CCK_RATE_1MB:
-		return 0x0A;
-	case IEEE80211_CCK_RATE_2MB:
-		return 0x14;
-	case IEEE80211_CCK_RATE_5MB:
-		return 0x37;
-	case IEEE80211_CCK_RATE_11MB:
-		return 0x6E;
-	}
-	assert(0);
-	return 0;
-}
-
-u8 bcm43xx_plcp_get_ratecode_ofdm(const u8 bitrate)
-{
-	switch (bitrate) {
-	case IEEE80211_OFDM_RATE_6MB:
-		return 0xB;
-	case IEEE80211_OFDM_RATE_9MB:
-		return 0xF;
-	case IEEE80211_OFDM_RATE_12MB:
-		return 0xA;
-	case IEEE80211_OFDM_RATE_18MB:
-		return 0xE;
-	case IEEE80211_OFDM_RATE_24MB:
-		return 0x9;
-	case IEEE80211_OFDM_RATE_36MB:
-		return 0xD;
-	case IEEE80211_OFDM_RATE_48MB:
-		return 0x8;
-	case IEEE80211_OFDM_RATE_54MB:
-		return 0xC;
-	}
-	assert(0);
-	return 0;
-}
-
-static void bcm43xx_generate_plcp_hdr(struct bcm43xx_plcp_hdr4 *plcp,
-				      const u16 octets, const u8 bitrate,
-				      const int ofdm_modulation)
-{
-	__le32 *data = &(plcp->data);
-	__u8 *raw = plcp->raw;
-
-	if (ofdm_modulation) {
-		*data = bcm43xx_plcp_get_ratecode_ofdm(bitrate);
-		assert(!(octets & 0xF000));
-		*data |= (octets << 5);
-		*data = cpu_to_le32(*data);
-	} else {
-		u32 plen;
-
-		plen = octets * 16 / bitrate;
-		if ((octets * 16 % bitrate) > 0) {
-			plen++;
-			if ((bitrate == IEEE80211_CCK_RATE_11MB)
-			    && ((octets * 8 % 11) < 4)) {
-				raw[1] = 0x84;
-			} else
-				raw[1] = 0x04;
-		} else
-			raw[1] = 0x04;
-		*data |= cpu_to_le32(plen << 16);
-		raw[0] = bcm43xx_plcp_get_ratecode_cck(bitrate);
-	}
-}
-
-static u8 bcm43xx_calc_fallback_rate(u8 bitrate)
-{
-	switch (bitrate) {
-	case IEEE80211_CCK_RATE_1MB:
-		return IEEE80211_CCK_RATE_1MB;
-	case IEEE80211_CCK_RATE_2MB:
-		return IEEE80211_CCK_RATE_1MB;
-	case IEEE80211_CCK_RATE_5MB:
-		return IEEE80211_CCK_RATE_2MB;
-	case IEEE80211_CCK_RATE_11MB:
-		return IEEE80211_CCK_RATE_5MB;
-	case IEEE80211_OFDM_RATE_6MB:
-		return IEEE80211_CCK_RATE_5MB;
-	case IEEE80211_OFDM_RATE_9MB:
-		return IEEE80211_OFDM_RATE_6MB;
-	case IEEE80211_OFDM_RATE_12MB:
-		return IEEE80211_OFDM_RATE_9MB;
-	case IEEE80211_OFDM_RATE_18MB:
-		return IEEE80211_OFDM_RATE_12MB;
-	case IEEE80211_OFDM_RATE_24MB:
-		return IEEE80211_OFDM_RATE_18MB;
-	case IEEE80211_OFDM_RATE_36MB:
-		return IEEE80211_OFDM_RATE_24MB;
-	case IEEE80211_OFDM_RATE_48MB:
-		return IEEE80211_OFDM_RATE_36MB;
-	case IEEE80211_OFDM_RATE_54MB:
-		return IEEE80211_OFDM_RATE_48MB;
-	}
-	assert(0);
-	return 0;
-}
-
-static
-__le16 bcm43xx_calc_duration_id(const struct ieee80211_hdr *wireless_header,
-				u8 bitrate)
-{
-	const u16 frame_ctl = le16_to_cpu(wireless_header->frame_ctl);
-	__le16 duration_id = wireless_header->duration_id;
-
-	switch (WLAN_FC_GET_TYPE(frame_ctl)) {
-	case IEEE80211_FTYPE_DATA:
-	case IEEE80211_FTYPE_MGMT:
-		//TODO: Steal the code from ieee80211, once it is completed there.
-		break;
-	case IEEE80211_FTYPE_CTL:
-		/* Use the original duration/id. */
-		break;
-	default:
-		assert(0);
-	}
-
-	return duration_id;
-}
-
-static inline
-u16 ceiling_div(u16 dividend, u16 divisor)
-{
-	return ((dividend + divisor - 1) / divisor);
-}
-
-static void bcm43xx_generate_rts(const struct bcm43xx_phyinfo *phy,
-				 struct bcm43xx_txhdr *txhdr,
-				 u16 *flags,
-				 u8 bitrate,
-				 const struct ieee80211_hdr_4addr *wlhdr)
-{
-	u16 fctl;
-	u16 dur;
-	u8 fallback_bitrate;
-	int ofdm_modulation;
-	int fallback_ofdm_modulation;
-//	u8 *sa, *da;
-	u16 flen;
-
-//FIXME	sa = ieee80211_get_SA((struct ieee80211_hdr *)wlhdr);
-//FIXME	da = ieee80211_get_DA((struct ieee80211_hdr *)wlhdr);
-	fallback_bitrate = bcm43xx_calc_fallback_rate(bitrate);
-	ofdm_modulation = !(ieee80211_is_cck_rate(bitrate));
-	fallback_ofdm_modulation = !(ieee80211_is_cck_rate(fallback_bitrate));
-
-	flen = sizeof(u16) + sizeof(u16) + ETH_ALEN + ETH_ALEN + IEEE80211_FCS_LEN,
-	bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)(&txhdr->rts_cts_plcp),
-				  flen, bitrate,
-				  !ieee80211_is_cck_rate(bitrate));
-	bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)(&txhdr->rts_cts_fallback_plcp),
-				  flen, fallback_bitrate,
-				  !ieee80211_is_cck_rate(fallback_bitrate));
-	fctl = IEEE80211_FTYPE_CTL;
-	fctl |= IEEE80211_STYPE_RTS;
-	dur = le16_to_cpu(wlhdr->duration_id);
-/*FIXME: should we test for dur==0 here and let it unmodified in this case?
- *       The following assert checks for this case...
- */
-assert(dur);
-/*FIXME: The duration calculation is not really correct.
- *       I am not 100% sure which bitrate to use. We use the RTS rate here,
- *       but this is likely to be wrong.
- */
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		/* Three times SIFS */
-		dur += 16 * 3;
-		/* Add ACK duration. */
-		dur += ceiling_div((16 + 8 * (14 /*bytes*/) + 6) * 10,
-				   bitrate * 4);
-		/* Add CTS duration. */
-		dur += ceiling_div((16 + 8 * (14 /*bytes*/) + 6) * 10,
-				   bitrate * 4);
-	} else {
-		/* Three times SIFS */
-		dur += 10 * 3;
-		/* Add ACK duration. */
-		dur += ceiling_div(8 * (14 /*bytes*/) * 10,
-				   bitrate);
-		/* Add CTS duration. */
-		dur += ceiling_div(8 * (14 /*bytes*/) * 10,
-				   bitrate);
-	}
-
-	txhdr->rts_cts_frame_control = cpu_to_le16(fctl);
-	txhdr->rts_cts_dur = cpu_to_le16(dur);
-//printk(BCM43xx_MACFMT "  " BCM43xx_MACFMT "  " BCM43xx_MACFMT "\n", BCM43xx_MACARG(wlhdr->addr1), BCM43xx_MACARG(wlhdr->addr2), BCM43xx_MACARG(wlhdr->addr3));
-//printk(BCM43xx_MACFMT "  " BCM43xx_MACFMT "\n", BCM43xx_MACARG(sa), BCM43xx_MACARG(da));
-	memcpy(txhdr->rts_cts_mac1, wlhdr->addr1, ETH_ALEN);//FIXME!
-//	memcpy(txhdr->rts_cts_mac2, sa, ETH_ALEN);
-
-	*flags |= BCM43xx_TXHDRFLAG_RTSCTS;
-	*flags |= BCM43xx_TXHDRFLAG_RTS;
-	if (ofdm_modulation)
-		*flags |= BCM43xx_TXHDRFLAG_RTSCTS_OFDM;
-	if (fallback_ofdm_modulation)
-		*flags |= BCM43xx_TXHDRFLAG_RTSCTSFALLBACK_OFDM;
-}
-				 
-void bcm43xx_generate_txhdr(struct bcm43xx_private *bcm,
-			    struct bcm43xx_txhdr *txhdr,
-			    const unsigned char *fragment_data,
-			    const unsigned int fragment_len,
-			    const int is_first_fragment,
-			    const u16 cookie)
-{
-	const struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	const struct ieee80211_hdr_4addr *wireless_header = (const struct ieee80211_hdr_4addr *)fragment_data;
-	const struct ieee80211_security *secinfo = &bcm->ieee->sec;
-	u8 bitrate;
-	u8 fallback_bitrate;
-	int ofdm_modulation;
-	int fallback_ofdm_modulation;
-	u16 plcp_fragment_len = fragment_len;
-	u16 flags = 0;
-	u16 control = 0;
-	u16 wsec_rate = 0;
-	u16 encrypt_frame;
-	const u16 ftype = WLAN_FC_GET_TYPE(le16_to_cpu(wireless_header->frame_ctl));
-	const int is_mgt = (ftype == IEEE80211_FTYPE_MGMT);
-
-	/* Now construct the TX header. */
-	memset(txhdr, 0, sizeof(*txhdr));
-
-	bitrate = ieee80211softmac_suggest_txrate(bcm->softmac,
-		is_multicast_ether_addr(wireless_header->addr1), is_mgt);
-	ofdm_modulation = !(ieee80211_is_cck_rate(bitrate));
-	fallback_bitrate = bcm43xx_calc_fallback_rate(bitrate);
-	fallback_ofdm_modulation = !(ieee80211_is_cck_rate(fallback_bitrate));
-
-	/* Set Frame Control from 80211 header. */
-	txhdr->frame_control = wireless_header->frame_ctl;
-	/* Copy address1 from 80211 header. */
-	memcpy(txhdr->mac1, wireless_header->addr1, 6);
-	/* Set the fallback duration ID. */
-	txhdr->fallback_dur_id = bcm43xx_calc_duration_id((const struct ieee80211_hdr *)wireless_header,
-							  fallback_bitrate);
-	/* Set the cookie (used as driver internal ID for the frame) */
-	txhdr->cookie = cpu_to_le16(cookie);
-
-	/* Hardware appends FCS. */
-	plcp_fragment_len += IEEE80211_FCS_LEN;
-
-	/* Hardware encryption. */
-	encrypt_frame = le16_to_cpup(&wireless_header->frame_ctl) & IEEE80211_FCTL_PROTECTED;
-	if (encrypt_frame && !bcm->ieee->host_encrypt) {
-		const struct ieee80211_hdr_3addr *hdr = (struct ieee80211_hdr_3addr *)wireless_header;
-		memcpy(txhdr->wep_iv, hdr->payload, 4);
-		/* Hardware appends ICV. */
-		plcp_fragment_len += 4;
-
-		wsec_rate |= (bcm->key[secinfo->active_key].algorithm << BCM43xx_TXHDR_WSEC_ALGO_SHIFT)
-			     & BCM43xx_TXHDR_WSEC_ALGO_MASK;
-		wsec_rate |= (secinfo->active_key << BCM43xx_TXHDR_WSEC_KEYINDEX_SHIFT)
-			     & BCM43xx_TXHDR_WSEC_KEYINDEX_MASK;
-	}
-
-	/* Generate the PLCP header and the fallback PLCP header. */
-	bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)(&txhdr->plcp),
-				  plcp_fragment_len,
-				  bitrate, ofdm_modulation);
-	bcm43xx_generate_plcp_hdr(&txhdr->fallback_plcp, plcp_fragment_len,
-				  fallback_bitrate, fallback_ofdm_modulation);
-
-	/* Set the CONTROL field */
-	if (ofdm_modulation)
-		control |= BCM43xx_TXHDRCTL_OFDM;
-	if (bcm->short_preamble) //FIXME: could be the other way around, please test
-		control |= BCM43xx_TXHDRCTL_SHORT_PREAMBLE;
-	control |= (phy->antenna_diversity << BCM43xx_TXHDRCTL_ANTENNADIV_SHIFT)
-		   & BCM43xx_TXHDRCTL_ANTENNADIV_MASK;
-
-	/* Set the FLAGS field */
-	if (!is_multicast_ether_addr(wireless_header->addr1) &&
-	    !is_broadcast_ether_addr(wireless_header->addr1))
-		flags |= BCM43xx_TXHDRFLAG_EXPECTACK;
-	if (1 /* FIXME: PS poll?? */)
-		flags |= 0x10; // FIXME: unknown meaning.
-	if (fallback_ofdm_modulation)
-		flags |= BCM43xx_TXHDRFLAG_FALLBACKOFDM;
-	if (is_first_fragment)
-		flags |= BCM43xx_TXHDRFLAG_FIRSTFRAGMENT;
-
-	/* Set WSEC/RATE field */
-	wsec_rate |= (txhdr->plcp.raw[0] << BCM43xx_TXHDR_RATE_SHIFT)
-		     & BCM43xx_TXHDR_RATE_MASK;
-
-	/* Generate the RTS/CTS packet, if required. */
-	/* FIXME: We should first try with CTS-to-self,
-	 *        if we are on 80211g. If we get too many
-	 *        failures (hidden nodes), we should switch back to RTS/CTS.
-	 */
-	if (0/*FIXME txctl->use_rts_cts*/) {
-		bcm43xx_generate_rts(phy, txhdr, &flags,
-				     0/*FIXME txctl->rts_cts_rate*/,
-				     wireless_header);
-	}
-
-	txhdr->flags = cpu_to_le16(flags);
-	txhdr->control = cpu_to_le16(control);
-	txhdr->wsec_rate = cpu_to_le16(wsec_rate);
-}
-
-static s8 bcm43xx_rssi_postprocess(struct bcm43xx_private *bcm,
-				   u8 in_rssi, int ofdm,
-				   int adjust_2053, int adjust_2050)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	s32 tmp;
-
-	switch (radio->version) {
-	case 0x2050:
-		if (ofdm) {
-			tmp = in_rssi;
-			if (tmp > 127)
-				tmp -= 256;
-			tmp *= 73;
-			tmp /= 64;
-			if (adjust_2050)
-				tmp += 25;
-			else
-				tmp -= 3;
-		} else {
-			if (bcm->sprom.boardflags & BCM43xx_BFL_RSSI) {
-				if (in_rssi > 63)
-					in_rssi = 63;
-				tmp = radio->nrssi_lt[in_rssi];
-				tmp = 31 - tmp;
-				tmp *= -131;
-				tmp /= 128;
-				tmp -= 57;
-			} else {
-				tmp = in_rssi;
-				tmp = 31 - tmp;
-				tmp *= -149;
-				tmp /= 128;
-				tmp -= 68;
-			}
-			if (phy->type == BCM43xx_PHYTYPE_G &&
-			    adjust_2050)
-				tmp += 25;
-		}
-		break;
-	case 0x2060:
-		if (in_rssi > 127)
-			tmp = in_rssi - 256;
-		else
-			tmp = in_rssi;
-		break;
-	default:
-		tmp = in_rssi;
-		tmp -= 11;
-		tmp *= 103;
-		tmp /= 64;
-		if (adjust_2053)
-			tmp -= 109;
-		else
-			tmp -= 83;
-	}
-
-	return (s8)tmp;
-}
-
-//TODO
-#if 0
-static s8 bcm43xx_rssinoise_postprocess(struct bcm43xx_private *bcm,
-					u8 in_rssi)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	s8 ret;
-
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		//TODO: Incomplete specs.
-		ret = 0;
-	} else
-		ret = bcm43xx_rssi_postprocess(bcm, in_rssi, 0, 1, 1);
-
-	return ret;
-}
-#endif
-
-int bcm43xx_rx(struct bcm43xx_private *bcm,
-	       struct sk_buff *skb,
-	       struct bcm43xx_rxhdr *rxhdr)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_plcp_hdr4 *plcp;
-	struct ieee80211_rx_stats stats;
-	struct ieee80211_hdr_4addr *wlhdr;
-	u16 frame_ctl;
-	int is_packet_for_us = 0;
-	int err = -EINVAL;
-	const u16 rxflags1 = le16_to_cpu(rxhdr->flags1);
-	const u16 rxflags2 = le16_to_cpu(rxhdr->flags2);
-	const u16 rxflags3 = le16_to_cpu(rxhdr->flags3);
-	const int is_ofdm = !!(rxflags1 & BCM43xx_RXHDR_FLAGS1_OFDM);
-
-	if (rxflags2 & BCM43xx_RXHDR_FLAGS2_TYPE2FRAME) {
-		plcp = (struct bcm43xx_plcp_hdr4 *)(skb->data + 2);
-		/* Skip two unknown bytes and the PLCP header. */
-		skb_pull(skb, 2 + sizeof(struct bcm43xx_plcp_hdr6));
-	} else {
-		plcp = (struct bcm43xx_plcp_hdr4 *)(skb->data);
-		/* Skip the PLCP header. */
-		skb_pull(skb, sizeof(struct bcm43xx_plcp_hdr6));
-	}
-	/* The SKB contains the PAYLOAD (wireless header + data)
-	 * at this point. The FCS at the end is stripped.
-	 */
-
-	memset(&stats, 0, sizeof(stats));
-	stats.mac_time = le16_to_cpu(rxhdr->mactime);
-	stats.rssi = rxhdr->rssi;
-	stats.signal = bcm43xx_rssi_postprocess(bcm, rxhdr->rssi, is_ofdm,
-					      !!(rxflags1 & BCM43xx_RXHDR_FLAGS1_2053RSSIADJ),
-					      !!(rxflags3 & BCM43xx_RXHDR_FLAGS3_2050RSSIADJ));
-	stats.noise = bcm->stats.noise;
-	if (is_ofdm)
-		stats.rate = bcm43xx_plcp_get_bitrate_ofdm(plcp);
-	else
-		stats.rate = bcm43xx_plcp_get_bitrate_cck(plcp);
-	stats.received_channel = radio->channel;
-	stats.mask = IEEE80211_STATMASK_SIGNAL |
-		     IEEE80211_STATMASK_NOISE |
-		     IEEE80211_STATMASK_RATE |
-		     IEEE80211_STATMASK_RSSI;
-	if (phy->type == BCM43xx_PHYTYPE_A)
-		stats.freq = IEEE80211_52GHZ_BAND;
-	else
-		stats.freq = IEEE80211_24GHZ_BAND;
-	stats.len = skb->len;
-
-	bcm->stats.last_rx = jiffies;
-	if (bcm->ieee->iw_mode == IW_MODE_MONITOR) {
-		err = ieee80211_rx(bcm->ieee, skb, &stats);
-		return (err == 0) ? -EINVAL : 0;
-	}
-
-	wlhdr = (struct ieee80211_hdr_4addr *)(skb->data);
-
-	switch (bcm->ieee->iw_mode) {
-	case IW_MODE_ADHOC:
-		if (memcmp(wlhdr->addr1, bcm->net_dev->dev_addr, ETH_ALEN) == 0 ||
-		    memcmp(wlhdr->addr3, bcm->ieee->bssid, ETH_ALEN) == 0 ||
-		    is_broadcast_ether_addr(wlhdr->addr1) ||
-		    is_multicast_ether_addr(wlhdr->addr1) ||
-		    bcm->net_dev->flags & IFF_PROMISC)
-			is_packet_for_us = 1;
-		break;
-	case IW_MODE_INFRA:
-	default:
-		/* When receiving multicast or broadcast packets, filter out
-		   the packets we send ourself; we shouldn't see those */
-		if (memcmp(wlhdr->addr3, bcm->ieee->bssid, ETH_ALEN) == 0 ||
-		    memcmp(wlhdr->addr1, bcm->net_dev->dev_addr, ETH_ALEN) == 0 ||
-		    (memcmp(wlhdr->addr3, bcm->net_dev->dev_addr, ETH_ALEN) &&
-		     (is_broadcast_ether_addr(wlhdr->addr1) ||
-		      is_multicast_ether_addr(wlhdr->addr1) ||
-		      bcm->net_dev->flags & IFF_PROMISC)))
-			is_packet_for_us = 1;
-		break;
-	}
-
-	frame_ctl = le16_to_cpu(wlhdr->frame_ctl);
-	switch (WLAN_FC_GET_TYPE(frame_ctl)) {
-	case IEEE80211_FTYPE_MGMT:
-		ieee80211_rx_mgt(bcm->ieee, wlhdr, &stats);
-		break;
-	case IEEE80211_FTYPE_DATA:
-		if (is_packet_for_us) {
-			err = ieee80211_rx(bcm->ieee, skb, &stats);
-			err = (err == 0) ? -EINVAL : 0;
-		}
-		break;
-	case IEEE80211_FTYPE_CTL:
-		break;
-	default:
-		assert(0);
-		return -EINVAL;
-	}
-
-	return err;
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_xmit.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_xmit.h
+++ /dev/null
@@ -1,150 +0,0 @@
-#ifndef BCM43xx_XMIT_H_
-#define BCM43xx_XMIT_H_
-
-#include "bcm43xx_main.h"
-
-
-#define _bcm43xx_declare_plcp_hdr(size) \
-	struct bcm43xx_plcp_hdr##size {		\
-		union {				\
-			__le32 data;		\
-			__u8 raw[size];		\
-		} __attribute__((__packed__));	\
-	} __attribute__((__packed__))
-
-/* struct bcm43xx_plcp_hdr4 */
-_bcm43xx_declare_plcp_hdr(4);
-/* struct bcm43xx_plcp_hdr6 */
-_bcm43xx_declare_plcp_hdr(6);
-
-#undef _bcm43xx_declare_plcp_hdr
-
-/* Device specific TX header. To be prepended to TX frames. */
-struct bcm43xx_txhdr {
-	union {
-		struct {
-			__le16 flags;
-			__le16 wsec_rate;
-			__le16 frame_control;
-			u16 unknown_zeroed_0;
-			__le16 control;
-			u8 wep_iv[10];
-			u8 unknown_wsec_tkip_data[3]; //FIXME
-			PAD_BYTES(3);
-			u8 mac1[6];
-			u16 unknown_zeroed_1;
-			struct bcm43xx_plcp_hdr4 rts_cts_fallback_plcp;
-			__le16 rts_cts_dur_fallback;
-			struct bcm43xx_plcp_hdr4 fallback_plcp;
-			__le16 fallback_dur_id;
-			PAD_BYTES(2);
-			__le16 cookie;
-			__le16 unknown_scb_stuff; //FIXME
-			struct bcm43xx_plcp_hdr6 rts_cts_plcp;
-			__le16 rts_cts_frame_control;
-			__le16 rts_cts_dur;
-			u8 rts_cts_mac1[6];
-			u8 rts_cts_mac2[6];
-			PAD_BYTES(2);
-			struct bcm43xx_plcp_hdr6 plcp;
-		} __attribute__((__packed__));
-		u8 raw[82];
-	} __attribute__((__packed__));
-} __attribute__((__packed__));
-
-/* Values/Masks for the device TX header */
-#define BCM43xx_TXHDRFLAG_EXPECTACK		0x0001
-#define BCM43xx_TXHDRFLAG_RTSCTS		0x0002
-#define BCM43xx_TXHDRFLAG_RTS			0x0004
-#define BCM43xx_TXHDRFLAG_FIRSTFRAGMENT		0x0008
-#define BCM43xx_TXHDRFLAG_DESTPSMODE		0x0020
-#define BCM43xx_TXHDRFLAG_RTSCTS_OFDM		0x0080
-#define BCM43xx_TXHDRFLAG_FALLBACKOFDM		0x0100
-#define BCM43xx_TXHDRFLAG_RTSCTSFALLBACK_OFDM	0x0200
-#define BCM43xx_TXHDRFLAG_CTS			0x0400
-#define BCM43xx_TXHDRFLAG_FRAMEBURST		0x0800
-
-#define BCM43xx_TXHDRCTL_OFDM			0x0001
-#define BCM43xx_TXHDRCTL_SHORT_PREAMBLE		0x0010
-#define BCM43xx_TXHDRCTL_ANTENNADIV_MASK	0x0030
-#define BCM43xx_TXHDRCTL_ANTENNADIV_SHIFT	8
-
-#define BCM43xx_TXHDR_RATE_MASK			0x0F00
-#define BCM43xx_TXHDR_RATE_SHIFT		8
-#define BCM43xx_TXHDR_RTSRATE_MASK		0xF000
-#define BCM43xx_TXHDR_RTSRATE_SHIFT		12
-#define BCM43xx_TXHDR_WSEC_KEYINDEX_MASK	0x00F0
-#define BCM43xx_TXHDR_WSEC_KEYINDEX_SHIFT	4
-#define BCM43xx_TXHDR_WSEC_ALGO_MASK		0x0003
-#define BCM43xx_TXHDR_WSEC_ALGO_SHIFT		0
-
-void bcm43xx_generate_txhdr(struct bcm43xx_private *bcm,
-			    struct bcm43xx_txhdr *txhdr,
-			    const unsigned char *fragment_data,
-			    const unsigned int fragment_len,
-			    const int is_first_fragment,
-			    const u16 cookie);
-
-/* RX header as received from the hardware. */
-struct bcm43xx_rxhdr {
-	/* Frame Length. Must be generated explicitly in PIO mode. */
-	__le16 frame_length;
-	PAD_BYTES(2);
-	/* Flags field 1 */
-	__le16 flags1;
-	u8 rssi;
-	u8 signal_quality;
-	PAD_BYTES(2);
-	/* Flags field 3 */
-	__le16 flags3;
-	/* Flags field 2 */
-	__le16 flags2;
-	/* Lower 16bits of the TSF at the time the frame started. */
-	__le16 mactime;
-	PAD_BYTES(14);
-} __attribute__((__packed__));
-
-#define BCM43xx_RXHDR_FLAGS1_OFDM		(1 << 0)
-/*#define BCM43xx_RXHDR_FLAGS1_SIGNAL???	(1 << 3) FIXME */
-#define BCM43xx_RXHDR_FLAGS1_SHORTPREAMBLE	(1 << 7)
-#define BCM43xx_RXHDR_FLAGS1_2053RSSIADJ	(1 << 14)
-
-#define BCM43xx_RXHDR_FLAGS2_INVALIDFRAME	(1 << 0)
-#define BCM43xx_RXHDR_FLAGS2_TYPE2FRAME		(1 << 2)
-/*FIXME: WEP related flags */
-
-#define BCM43xx_RXHDR_FLAGS3_2050RSSIADJ	(1 << 10)
-
-/* Transmit Status as received from the hardware. */
-struct bcm43xx_hwxmitstatus {
-	PAD_BYTES(4);
-	__le16 cookie;
-	u8 flags;
-	u8 cnt1:4,
-	   cnt2:4;
-	PAD_BYTES(2);
-	__le16 seq;
-	__le16 unknown; //FIXME
-} __attribute__((__packed__));
-
-/* Transmit Status in CPU byteorder. */
-struct bcm43xx_xmitstatus {
-	u16 cookie;
-	u8 flags;
-	u8 cnt1:4,
-	   cnt2:4;
-	u16 seq;
-	u16 unknown; //FIXME
-};
-
-#define BCM43xx_TXSTAT_FLAG_AMPDU	0x10
-#define BCM43xx_TXSTAT_FLAG_INTER	0x20
-
-u8 bcm43xx_plcp_get_ratecode_cck(const u8 bitrate);
-u8 bcm43xx_plcp_get_ratecode_ofdm(const u8 bitrate);
-
-int bcm43xx_rx(struct bcm43xx_private *bcm,
-	       struct sk_buff *skb,
-	       struct bcm43xx_rxhdr *rxhdr);
-
-#endif /* BCM43xx_XMIT_H_ */
Index: wireless-2.6/Documentation/networking/bcm43xx.txt
===================================================================
--- wireless-2.6.orig/Documentation/networking/bcm43xx.txt
+++ /dev/null
@@ -1,89 +0,0 @@
-
-			BCM43xx Linux Driver Project
-			============================
-
-Introduction
-------------
-
-Many of the wireless devices found in modern notebook computers are
-based on the wireless chips produced by Broadcom. These devices have
-been a problem for Linux users as there is no open-source driver
-available. In addition, Broadcom has not released specifications
-for the device, and driver availability has been limited to the
-binary-only form used in the GPL versions of AP hardware such as the
-Linksys WRT54G, and the Windows and OS X drivers.  Before this project
-began, the only way to use these devices were to use the Windows or
-OS X drivers with either the Linuxant or ndiswrapper modules. There
-is a strong penalty if this method is used as loading the binary-only
-module "taints" the kernel, and no kernel developer will help diagnose
-any kernel problems.
-
-Development
------------
-
-This driver has been developed using
-a clean-room technique that is described at
-http://bcm-specs.sipsolutions.net/ReverseEngineeringProcess. For legal
-reasons, none of the clean-room crew works on the on the Linux driver,
-and none of the Linux developers sees anything but the specifications,
-which are the ultimate product of the reverse-engineering group.
-
-Software
---------
-
-Since the release of the 2.6.17 kernel, the bcm43xx driver has been
-distributed with the kernel source, and is prebuilt in most, if not
-all, distributions.  There is, however, additional software that is
-required. The firmware used by the chip is the intellectual property
-of Broadcom and they have not given the bcm43xx team redistribution
-rights to this firmware.  Since we cannot legally redistribute
-the firmware we cannot include it with the driver. Furthermore, it
-cannot be placed in the downloadable archives of any distributing
-organization; therefore, the user is responsible for obtaining the
-firmware and placing it in the appropriate location so that the driver
-can find it when initializing.
-
-To help with this process, the bcm43xx developers provide a separate
-program named bcm43xx-fwcutter to "cut" the firmware out of a
-Windows or OS X driver and write the extracted files to the proper
-location. This program is usually provided with the distribution;
-however, it may be downloaded from
-
-http://developer.berlios.de/project/showfiles.php?group_id=4547
-
-The firmware is available in two versions. V3 firmware is used with
-the in-kernel bcm43xx driver that uses a software MAC layer called
-SoftMAC, and will have a microcode revision of 0x127 or smaller. The
-V4 firmware is used by an out-of-kernel driver employing a variation of
-the Devicescape MAC layer known as d80211. Once bcm43xx-d80211 reaches
-a satisfactory level of development, it will replace bcm43xx-softmac
-in the kernel as it is much more flexible and powerful.
-
-A source for the latest V3 firmware is
-
-http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o
-
-Once this file is downloaded, the command
-'bcm43xx-fwcutter -w <dir> <filename>'
-will extract the microcode and write it to directory
-<dir>. The correct directory will depend on your distribution;
-however, most use '/lib/firmware'. Once this step is completed,
-the bcm3xx driver should load when the system is booted. To see
-any messages relating to the driver, issue the command 'dmesg |
-grep bcm43xx' from a terminal window. If there are any problems,
-please send that output to Bcm43xx-dev at lists.berlios.de.
-
-Although the driver has been in-kernel since 2.6.17, the earliest
-version is quite limited in its capability. Patches that include
-all features of later versions are available for the stable kernel
-versions from 2.6.18. These will be needed if you use a BCM4318,
-or a PCI Express version (BCM4311 and BCM4312). In addition, if you
-have an early BCM4306 and more than 1 GB RAM, your kernel will need
-to be patched.	These patches, which are being updated regularly,
-are available at ftp://lwfinger.dynalias.org/patches. Look for
-combined_2.6.YY.patch. Of course you will need kernel source downloaded
-from kernel.org, or the source from your distribution.
-
-If you build your own kernel, please enable CONFIG_BCM43XX_DEBUG
-and CONFIG_IEEE80211_SOFTMAC_DEBUG. The log information provided is
-essential for solving any problems.
Index: wireless-2.6/MAINTAINERS
===================================================================
--- wireless-2.6.orig/MAINTAINERS
+++ wireless-2.6/MAINTAINERS
@@ -821,15 +821,6 @@ L:	linux-wireless at vger.kernel.org
 W:	http://linuxwireless.org/en/users/Drivers/b43
 S:	Maintained
 
-BCM43XX WIRELESS DRIVER (SOFTMAC BASED VERSION)
-P:	Larry Finger
-M:	Larry.Finger at lwfinger.net
-P:	Stefano Brivio
-M:	stefano.brivio at polimi.it
-L:	linux-wireless at vger.kernel.org
-W:	http://bcm43xx.berlios.de/
-S:	Maintained
-
 BEFS FILE SYSTEM
 P:	Sergey S. Kostyliov
 M:	rathamahata at php4.ru
Index: wireless-2.6/drivers/net/wireless/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/Kconfig
+++ wireless-2.6/drivers/net/wireless/Kconfig
@@ -629,7 +629,6 @@ config ATH5K
 
 source "drivers/net/wireless/iwlwifi/Kconfig"
 source "drivers/net/wireless/hostap/Kconfig"
-source "drivers/net/wireless/bcm43xx/Kconfig"
 source "drivers/net/wireless/b43/Kconfig"
 source "drivers/net/wireless/b43legacy/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
Index: wireless-2.6/drivers/net/wireless/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/Makefile
+++ wireless-2.6/drivers/net/wireless/Makefile
@@ -37,7 +37,6 @@ obj-$(CONFIG_USB_ATMEL)	        += at76_
 obj-$(CONFIG_PRISM54)		+= prism54/
 
 obj-$(CONFIG_HOSTAP)		+= hostap/
-obj-$(CONFIG_BCM43XX)		+= bcm43xx/
 obj-$(CONFIG_B43)		+= b43/
 obj-$(CONFIG_B43LEGACY)		+= b43legacy/
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -1558,7 +1558,7 @@ static void b43_release_firmware(struct 
 static void b43_print_fw_helptext(struct b43_wl *wl)
 {
 	b43err(wl, "You must go to "
-	       "http://linuxwireless.org/en/users/Drivers/bcm43xx#devicefirmware "
+	       "http://linuxwireless.org/en/users/Drivers/b43#devicefirmware "
 	       "and download the correct firmware (version 4).\n");
 }
 
Index: wireless-2.6/drivers/net/wireless/b43legacy/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/dma.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/dma.c
@@ -996,7 +996,7 @@ int b43legacy_dma_init(struct b43legacy_
 
 	err = ssb_dma_set_mask(dev->dev, dmamask);
 	if (err) {
-#ifdef BCM43XX_PIO
+#ifdef CONFIG_B43LEGACY_PIO
 		b43legacywarn(dev->wl, "DMA for this device not supported. "
 			"Falling back to PIO\n");
 		dev->__using_pio = 1;
Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -1398,7 +1398,7 @@ static void b43legacy_release_firmware(s
 static void b43legacy_print_fw_helptext(struct b43legacy_wl *wl)
 {
 	b43legacyerr(wl, "You must go to http://linuxwireless.org/en/users/"
-		     "Drivers/bcm43xx#devicefirmware "
+		     "Drivers/b43#devicefirmware "
 		     "and download the correct firmware (version 3).\n");
 }
 


-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Mon Nov 19 17:27:50 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Mon, 19 Nov 2007 17:27:50 +0100
Subject: [resend] [PATCH] remove bcm43xx
Message-ID: <20071119172750.36aea945@morte>

Remove bcm43xx. Fix some left-over URLs and ifdefs in b43 and b43legacy
drivers.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

John,
this is for 2.6.25 - in case you didn't get the full patch. Please also run:
	git rm -r drivers/wireless/bcm43xx

---

Index: wireless-2.6/Documentation/networking/bcm43xx.txt
===================================================================
--- wireless-2.6.orig/Documentation/networking/bcm43xx.txt
+++ /dev/null
@@ -1,89 +0,0 @@
-
-			BCM43xx Linux Driver Project
-			============================
-
-Introduction
-------------
-
-Many of the wireless devices found in modern notebook computers are
-based on the wireless chips produced by Broadcom. These devices have
-been a problem for Linux users as there is no open-source driver
-available. In addition, Broadcom has not released specifications
-for the device, and driver availability has been limited to the
-binary-only form used in the GPL versions of AP hardware such as the
-Linksys WRT54G, and the Windows and OS X drivers.  Before this project
-began, the only way to use these devices were to use the Windows or
-OS X drivers with either the Linuxant or ndiswrapper modules. There
-is a strong penalty if this method is used as loading the binary-only
-module "taints" the kernel, and no kernel developer will help diagnose
-any kernel problems.
-
-Development
------------
-
-This driver has been developed using
-a clean-room technique that is described at
-http://bcm-specs.sipsolutions.net/ReverseEngineeringProcess. For legal
-reasons, none of the clean-room crew works on the on the Linux driver,
-and none of the Linux developers sees anything but the specifications,
-which are the ultimate product of the reverse-engineering group.
-
-Software
---------
-
-Since the release of the 2.6.17 kernel, the bcm43xx driver has been
-distributed with the kernel source, and is prebuilt in most, if not
-all, distributions.  There is, however, additional software that is
-required. The firmware used by the chip is the intellectual property
-of Broadcom and they have not given the bcm43xx team redistribution
-rights to this firmware.  Since we cannot legally redistribute
-the firmware we cannot include it with the driver. Furthermore, it
-cannot be placed in the downloadable archives of any distributing
-organization; therefore, the user is responsible for obtaining the
-firmware and placing it in the appropriate location so that the driver
-can find it when initializing.
-
-To help with this process, the bcm43xx developers provide a separate
-program named bcm43xx-fwcutter to "cut" the firmware out of a
-Windows or OS X driver and write the extracted files to the proper
-location. This program is usually provided with the distribution;
-however, it may be downloaded from
-
-http://developer.berlios.de/project/showfiles.php?group_id=4547
-
-The firmware is available in two versions. V3 firmware is used with
-the in-kernel bcm43xx driver that uses a software MAC layer called
-SoftMAC, and will have a microcode revision of 0x127 or smaller. The
-V4 firmware is used by an out-of-kernel driver employing a variation of
-the Devicescape MAC layer known as d80211. Once bcm43xx-d80211 reaches
-a satisfactory level of development, it will replace bcm43xx-softmac
-in the kernel as it is much more flexible and powerful.
-
-A source for the latest V3 firmware is
-
-http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o
-
-Once this file is downloaded, the command
-'bcm43xx-fwcutter -w <dir> <filename>'
-will extract the microcode and write it to directory
-<dir>. The correct directory will depend on your distribution;
-however, most use '/lib/firmware'. Once this step is completed,
-the bcm3xx driver should load when the system is booted. To see
-any messages relating to the driver, issue the command 'dmesg |
-grep bcm43xx' from a terminal window. If there are any problems,
-please send that output to Bcm43xx-dev at lists.berlios.de.
-
-Although the driver has been in-kernel since 2.6.17, the earliest
-version is quite limited in its capability. Patches that include
-all features of later versions are available for the stable kernel
-versions from 2.6.18. These will be needed if you use a BCM4318,
-or a PCI Express version (BCM4311 and BCM4312). In addition, if you
-have an early BCM4306 and more than 1 GB RAM, your kernel will need
-to be patched.	These patches, which are being updated regularly,
-are available at ftp://lwfinger.dynalias.org/patches. Look for
-combined_2.6.YY.patch. Of course you will need kernel source downloaded
-from kernel.org, or the source from your distribution.
-
-If you build your own kernel, please enable CONFIG_BCM43XX_DEBUG
-and CONFIG_IEEE80211_SOFTMAC_DEBUG. The log information provided is
-essential for solving any problems.
Index: wireless-2.6/MAINTAINERS
===================================================================
--- wireless-2.6.orig/MAINTAINERS
+++ wireless-2.6/MAINTAINERS
@@ -821,15 +821,6 @@ L:	linux-wireless at vger.kernel.org
 W:	http://linuxwireless.org/en/users/Drivers/b43
 S:	Maintained
 
-BCM43XX WIRELESS DRIVER (SOFTMAC BASED VERSION)
-P:	Larry Finger
-M:	Larry.Finger at lwfinger.net
-P:	Stefano Brivio
-M:	stefano.brivio at polimi.it
-L:	linux-wireless at vger.kernel.org
-W:	http://bcm43xx.berlios.de/
-S:	Maintained
-
 BEFS FILE SYSTEM
 P:	Sergey S. Kostyliov
 M:	rathamahata at php4.ru
Index: wireless-2.6/drivers/net/wireless/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/Kconfig
+++ wireless-2.6/drivers/net/wireless/Kconfig
@@ -629,7 +629,6 @@ config ATH5K
 
 source "drivers/net/wireless/iwlwifi/Kconfig"
 source "drivers/net/wireless/hostap/Kconfig"
-source "drivers/net/wireless/bcm43xx/Kconfig"
 source "drivers/net/wireless/b43/Kconfig"
 source "drivers/net/wireless/b43legacy/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
Index: wireless-2.6/drivers/net/wireless/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/Makefile
+++ wireless-2.6/drivers/net/wireless/Makefile
@@ -37,7 +37,6 @@ obj-$(CONFIG_USB_ATMEL)	        += at76_
 obj-$(CONFIG_PRISM54)		+= prism54/
 
 obj-$(CONFIG_HOSTAP)		+= hostap/
-obj-$(CONFIG_BCM43XX)		+= bcm43xx/
 obj-$(CONFIG_B43)		+= b43/
 obj-$(CONFIG_B43LEGACY)		+= b43legacy/
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -1558,7 +1558,7 @@ static void b43_release_firmware(struct 
 static void b43_print_fw_helptext(struct b43_wl *wl)
 {
 	b43err(wl, "You must go to "
-
"http://linuxwireless.org/en/users/Drivers/bcm43xx#devicefirmware "
+
"http://linuxwireless.org/en/users/Drivers/b43#devicefirmware " "and
download the correct firmware (version 4).\n"); }
 
Index: wireless-2.6/drivers/net/wireless/b43legacy/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/dma.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/dma.c
@@ -996,7 +996,7 @@ int b43legacy_dma_init(struct b43legacy_
 
 	err = ssb_dma_set_mask(dev->dev, dmamask);
 	if (err) {
-#ifdef BCM43XX_PIO
+#ifdef CONFIG_B43LEGACY_PIO
 		b43legacywarn(dev->wl, "DMA for this device not supported.
" "Falling back to PIO\n");
 		dev->__using_pio = 1;
Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -1398,7 +1398,7 @@ static void b43legacy_release_firmware(s
 static void b43legacy_print_fw_helptext(struct b43legacy_wl *wl)
 {
 	b43legacyerr(wl, "You must go to
http://linuxwireless.org/en/users/"
-		     "Drivers/bcm43xx#devicefirmware "
+		     "Drivers/b43#devicefirmware "
 		     "and download the correct firmware (version 3).\n");
 }
 


-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Mon Nov 19 17:33:35 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Mon, 19 Nov 2007 17:33:35 +0100
Subject: [resend] [PATCH] remove bcm43xx
In-Reply-To: <20071119172750.36aea945@morte>
References: <20071119172750.36aea945@morte>
Message-ID: <20071119173335.6bda8dba@morte>

On Mon, 19 Nov 2007 17:27:50 +0100
Stefano Brivio <stefano.brivio at polimi.it> wrote:

> John,
> this is for 2.6.25 - in case you didn't get the full patch. Please also
> run: git rm -r drivers/wireless/bcm43xx

git rm -r drivers/net/wireless/bcm43xx, of course. :)


-- 
Ciao
Stefano


From mb at bu3sch.de  Mon Nov 19 19:18:07 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 19 Nov 2007 19:18:07 +0100
Subject: [PATCH] remove bcm43xx
In-Reply-To: <20071119171217.557ea31f@morte>
References: <20071119171217.557ea31f@morte>
Message-ID: <200711191918.07383.mb@bu3sch.de>

On Monday 19 November 2007 17:12:17 Stefano Brivio wrote:
> Remove bcm43xx. Fix some left-over URLs and ifdefs in b43 and b43legacy
> drivers.
> 

Stefano, please send the fixes for b43 and b43legacy as a seperate
patch, as they have to go into 2.6.24.


-- 
Greetings Michael.


From stefano.brivio at polimi.it  Mon Nov 19 19:44:14 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Mon, 19 Nov 2007 19:44:14 +0100
Subject: [PATCH v2] remove bcm43xx
Message-ID: <20071119194414.1f2f13e2@morte>

Remove bcm43xx.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

John,
this is for 2.6.25. Please also run:
	git rm -r drivers/wireless/bcm43xx


---

Index: wireless-2.6/Documentation/networking/bcm43xx.txt
===================================================================
--- wireless-2.6.orig/Documentation/networking/bcm43xx.txt
+++ /dev/null
@@ -1,89 +0,0 @@
-
-			BCM43xx Linux Driver Project
-			============================
-
-Introduction
-------------
-
-Many of the wireless devices found in modern notebook computers are
-based on the wireless chips produced by Broadcom. These devices have
-been a problem for Linux users as there is no open-source driver
-available. In addition, Broadcom has not released specifications
-for the device, and driver availability has been limited to the
-binary-only form used in the GPL versions of AP hardware such as the
-Linksys WRT54G, and the Windows and OS X drivers.  Before this project
-began, the only way to use these devices were to use the Windows or
-OS X drivers with either the Linuxant or ndiswrapper modules. There
-is a strong penalty if this method is used as loading the binary-only
-module "taints" the kernel, and no kernel developer will help diagnose
-any kernel problems.
-
-Development
------------
-
-This driver has been developed using
-a clean-room technique that is described at
-http://bcm-specs.sipsolutions.net/ReverseEngineeringProcess. For legal
-reasons, none of the clean-room crew works on the on the Linux driver,
-and none of the Linux developers sees anything but the specifications,
-which are the ultimate product of the reverse-engineering group.
-
-Software
---------
-
-Since the release of the 2.6.17 kernel, the bcm43xx driver has been
-distributed with the kernel source, and is prebuilt in most, if not
-all, distributions.  There is, however, additional software that is
-required. The firmware used by the chip is the intellectual property
-of Broadcom and they have not given the bcm43xx team redistribution
-rights to this firmware.  Since we cannot legally redistribute
-the firmware we cannot include it with the driver. Furthermore, it
-cannot be placed in the downloadable archives of any distributing
-organization; therefore, the user is responsible for obtaining the
-firmware and placing it in the appropriate location so that the driver
-can find it when initializing.
-
-To help with this process, the bcm43xx developers provide a separate
-program named bcm43xx-fwcutter to "cut" the firmware out of a
-Windows or OS X driver and write the extracted files to the proper
-location. This program is usually provided with the distribution;
-however, it may be downloaded from
-
-http://developer.berlios.de/project/showfiles.php?group_id=4547
-
-The firmware is available in two versions. V3 firmware is used with
-the in-kernel bcm43xx driver that uses a software MAC layer called
-SoftMAC, and will have a microcode revision of 0x127 or smaller. The
-V4 firmware is used by an out-of-kernel driver employing a variation of
-the Devicescape MAC layer known as d80211. Once bcm43xx-d80211 reaches
-a satisfactory level of development, it will replace bcm43xx-softmac
-in the kernel as it is much more flexible and powerful.
-
-A source for the latest V3 firmware is
-
-http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o
-
-Once this file is downloaded, the command
-'bcm43xx-fwcutter -w <dir> <filename>'
-will extract the microcode and write it to directory
-<dir>. The correct directory will depend on your distribution;
-however, most use '/lib/firmware'. Once this step is completed,
-the bcm3xx driver should load when the system is booted. To see
-any messages relating to the driver, issue the command 'dmesg |
-grep bcm43xx' from a terminal window. If there are any problems,
-please send that output to Bcm43xx-dev at lists.berlios.de.
-
-Although the driver has been in-kernel since 2.6.17, the earliest
-version is quite limited in its capability. Patches that include
-all features of later versions are available for the stable kernel
-versions from 2.6.18. These will be needed if you use a BCM4318,
-or a PCI Express version (BCM4311 and BCM4312). In addition, if you
-have an early BCM4306 and more than 1 GB RAM, your kernel will need
-to be patched.	These patches, which are being updated regularly,
-are available at ftp://lwfinger.dynalias.org/patches. Look for
-combined_2.6.YY.patch. Of course you will need kernel source downloaded
-from kernel.org, or the source from your distribution.
-
-If you build your own kernel, please enable CONFIG_BCM43XX_DEBUG
-and CONFIG_IEEE80211_SOFTMAC_DEBUG. The log information provided is
-essential for solving any problems.
Index: wireless-2.6/MAINTAINERS
===================================================================
--- wireless-2.6.orig/MAINTAINERS
+++ wireless-2.6/MAINTAINERS
@@ -821,15 +821,6 @@ L:	linux-wireless at vger.kernel.org
 W:	http://linuxwireless.org/en/users/Drivers/b43
 S:	Maintained
 
-BCM43XX WIRELESS DRIVER (SOFTMAC BASED VERSION)
-P:	Larry Finger
-M:	Larry.Finger at lwfinger.net
-P:	Stefano Brivio
-M:	stefano.brivio at polimi.it
-L:	linux-wireless at vger.kernel.org
-W:	http://bcm43xx.berlios.de/
-S:	Maintained
-
 BEFS FILE SYSTEM
 P:	Sergey S. Kostyliov
 M:	rathamahata at php4.ru
Index: wireless-2.6/drivers/net/wireless/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/Kconfig
+++ wireless-2.6/drivers/net/wireless/Kconfig
@@ -629,7 +629,6 @@ config ATH5K
 
 source "drivers/net/wireless/iwlwifi/Kconfig"
 source "drivers/net/wireless/hostap/Kconfig"
-source "drivers/net/wireless/bcm43xx/Kconfig"
 source "drivers/net/wireless/b43/Kconfig"
 source "drivers/net/wireless/b43legacy/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
Index: wireless-2.6/drivers/net/wireless/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/Makefile
+++ wireless-2.6/drivers/net/wireless/Makefile
@@ -37,7 +37,6 @@ obj-$(CONFIG_USB_ATMEL)	        += at76_
 obj-$(CONFIG_PRISM54)		+= prism54/
 
 obj-$(CONFIG_HOSTAP)		+= hostap/
-obj-$(CONFIG_BCM43XX)		+= bcm43xx/
 obj-$(CONFIG_B43)		+= b43/
 obj-$(CONFIG_B43LEGACY)		+= b43legacy/
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -1558,7 +1558,7 @@ static void b43_release_firmware(struct 
 static void b43_print_fw_helptext(struct b43_wl *wl)
 {
 	b43err(wl, "You must go to "
-
"http://linuxwireless.org/en/users/Drivers/bcm43xx#devicefirmware "
+
"http://linuxwireless.org/en/users/Drivers/b43#devicefirmware " "and
download the correct firmware (version 4).\n"); }
 
Index: wireless-2.6/drivers/net/wireless/b43legacy/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/dma.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/dma.c
@@ -996,7 +996,7 @@ int b43legacy_dma_init(struct b43legacy_
 
 	err = ssb_dma_set_mask(dev->dev, dmamask);
 	if (err) {
-#ifdef BCM43XX_PIO
+#ifdef CONFIG_B43LEGACY_PIO
 		b43legacywarn(dev->wl, "DMA for this device not supported.
" "Falling back to PIO\n");
 		dev->__using_pio = 1;
Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -1398,7 +1398,7 @@ static void b43legacy_release_firmware(s
 static void b43legacy_print_fw_helptext(struct b43legacy_wl *wl)
 {
 	b43legacyerr(wl, "You must go to
http://linuxwireless.org/en/users/"
-		     "Drivers/bcm43xx#devicefirmware "
+		     "Drivers/b43#devicefirmware "
 		     "and download the correct firmware (version 3).\n");
 }
 


-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Mon Nov 19 19:44:33 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Mon, 19 Nov 2007 19:44:33 +0100
Subject: [PATCH v2] b43/b43legacy: fix left-over URLs and ifdefs
Message-ID: <20071119194433.15f19da4@morte>

Fix some left-over URLs and ifdefs in b43 and b43legacy drivers.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

John,
this is for 2.6.24. Sorry for the noise, please just discard the previous
patch.

---

Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -1558,7 +1558,7 @@ static void b43_release_firmware(struct 
 static void b43_print_fw_helptext(struct b43_wl *wl)
 {
 	b43err(wl, "You must go to "
-
"http://linuxwireless.org/en/users/Drivers/bcm43xx#devicefirmware "
+
"http://linuxwireless.org/en/users/Drivers/b43#devicefirmware " "and
download the correct firmware (version 4).\n"); }
 
Index: wireless-2.6/drivers/net/wireless/b43legacy/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/dma.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/dma.c
@@ -996,7 +996,7 @@ int b43legacy_dma_init(struct b43legacy_
 
 	err = ssb_dma_set_mask(dev->dev, dmamask);
 	if (err) {
-#ifdef BCM43XX_PIO
+#ifdef CONFIG_B43LEGACY_PIO
 		b43legacywarn(dev->wl, "DMA for this device not supported.
" "Falling back to PIO\n");
 		dev->__using_pio = 1;
Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -1398,7 +1398,7 @@ static void b43legacy_release_firmware(s
 static void b43legacy_print_fw_helptext(struct b43legacy_wl *wl)
 {
 	b43legacyerr(wl, "You must go to
http://linuxwireless.org/en/users/"
-		     "Drivers/bcm43xx#devicefirmware "
+		     "Drivers/b43#devicefirmware "
 		     "and download the correct firmware (version 3).\n");
 }
 


-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Mon Nov 19 20:21:21 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Mon, 19 Nov 2007 20:21:21 +0100
Subject: [PATCH v3] remove bcm43xx
Message-ID: <20071119202121.6ad3fa70@morte>

Remove bcm43xx.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

John,
I hope this is the last try, v2 was line wrapped. :) This is for 2.6.25.
Please also run:
	git rm -r drivers/net/wireless/bcm43xx


---

Index: wireless-2.6/Documentation/networking/bcm43xx.txt
===================================================================
--- wireless-2.6.orig/Documentation/networking/bcm43xx.txt
+++ /dev/null
@@ -1,89 +0,0 @@
-
-			BCM43xx Linux Driver Project
-			============================
-
-Introduction
-------------
-
-Many of the wireless devices found in modern notebook computers are
-based on the wireless chips produced by Broadcom. These devices have
-been a problem for Linux users as there is no open-source driver
-available. In addition, Broadcom has not released specifications
-for the device, and driver availability has been limited to the
-binary-only form used in the GPL versions of AP hardware such as the
-Linksys WRT54G, and the Windows and OS X drivers.  Before this project
-began, the only way to use these devices were to use the Windows or
-OS X drivers with either the Linuxant or ndiswrapper modules. There
-is a strong penalty if this method is used as loading the binary-only
-module "taints" the kernel, and no kernel developer will help diagnose
-any kernel problems.
-
-Development
------------
-
-This driver has been developed using
-a clean-room technique that is described at
-http://bcm-specs.sipsolutions.net/ReverseEngineeringProcess. For legal
-reasons, none of the clean-room crew works on the on the Linux driver,
-and none of the Linux developers sees anything but the specifications,
-which are the ultimate product of the reverse-engineering group.
-
-Software
---------
-
-Since the release of the 2.6.17 kernel, the bcm43xx driver has been
-distributed with the kernel source, and is prebuilt in most, if not
-all, distributions.  There is, however, additional software that is
-required. The firmware used by the chip is the intellectual property
-of Broadcom and they have not given the bcm43xx team redistribution
-rights to this firmware.  Since we cannot legally redistribute
-the firmware we cannot include it with the driver. Furthermore, it
-cannot be placed in the downloadable archives of any distributing
-organization; therefore, the user is responsible for obtaining the
-firmware and placing it in the appropriate location so that the driver
-can find it when initializing.
-
-To help with this process, the bcm43xx developers provide a separate
-program named bcm43xx-fwcutter to "cut" the firmware out of a
-Windows or OS X driver and write the extracted files to the proper
-location. This program is usually provided with the distribution;
-however, it may be downloaded from
-
-http://developer.berlios.de/project/showfiles.php?group_id=4547
-
-The firmware is available in two versions. V3 firmware is used with
-the in-kernel bcm43xx driver that uses a software MAC layer called
-SoftMAC, and will have a microcode revision of 0x127 or smaller. The
-V4 firmware is used by an out-of-kernel driver employing a variation of
-the Devicescape MAC layer known as d80211. Once bcm43xx-d80211 reaches
-a satisfactory level of development, it will replace bcm43xx-softmac
-in the kernel as it is much more flexible and powerful.
-
-A source for the latest V3 firmware is
-
-http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o
-
-Once this file is downloaded, the command
-'bcm43xx-fwcutter -w <dir> <filename>'
-will extract the microcode and write it to directory
-<dir>. The correct directory will depend on your distribution;
-however, most use '/lib/firmware'. Once this step is completed,
-the bcm3xx driver should load when the system is booted. To see
-any messages relating to the driver, issue the command 'dmesg |
-grep bcm43xx' from a terminal window. If there are any problems,
-please send that output to Bcm43xx-dev at lists.berlios.de.
-
-Although the driver has been in-kernel since 2.6.17, the earliest
-version is quite limited in its capability. Patches that include
-all features of later versions are available for the stable kernel
-versions from 2.6.18. These will be needed if you use a BCM4318,
-or a PCI Express version (BCM4311 and BCM4312). In addition, if you
-have an early BCM4306 and more than 1 GB RAM, your kernel will need
-to be patched.	These patches, which are being updated regularly,
-are available at ftp://lwfinger.dynalias.org/patches. Look for
-combined_2.6.YY.patch. Of course you will need kernel source downloaded
-from kernel.org, or the source from your distribution.
-
-If you build your own kernel, please enable CONFIG_BCM43XX_DEBUG
-and CONFIG_IEEE80211_SOFTMAC_DEBUG. The log information provided is
-essential for solving any problems.
Index: wireless-2.6/MAINTAINERS
===================================================================
--- wireless-2.6.orig/MAINTAINERS
+++ wireless-2.6/MAINTAINERS
@@ -821,15 +821,6 @@ L:	linux-wireless at vger.kernel.org
 W:	http://linuxwireless.org/en/users/Drivers/b43
 S:	Maintained
 
-BCM43XX WIRELESS DRIVER (SOFTMAC BASED VERSION)
-P:	Larry Finger
-M:	Larry.Finger at lwfinger.net
-P:	Stefano Brivio
-M:	stefano.brivio at polimi.it
-L:	linux-wireless at vger.kernel.org
-W:	http://bcm43xx.berlios.de/
-S:	Maintained
-
 BEFS FILE SYSTEM
 P:	Sergey S. Kostyliov
 M:	rathamahata at php4.ru
Index: wireless-2.6/drivers/net/wireless/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/Kconfig
+++ wireless-2.6/drivers/net/wireless/Kconfig
@@ -629,7 +629,6 @@ config ATH5K
 
 source "drivers/net/wireless/iwlwifi/Kconfig"
 source "drivers/net/wireless/hostap/Kconfig"
-source "drivers/net/wireless/bcm43xx/Kconfig"
 source "drivers/net/wireless/b43/Kconfig"
 source "drivers/net/wireless/b43legacy/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
Index: wireless-2.6/drivers/net/wireless/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/Makefile
+++ wireless-2.6/drivers/net/wireless/Makefile
@@ -37,7 +37,6 @@ obj-$(CONFIG_USB_ATMEL)	        += at76_
 obj-$(CONFIG_PRISM54)		+= prism54/
 
 obj-$(CONFIG_HOSTAP)		+= hostap/
-obj-$(CONFIG_BCM43XX)		+= bcm43xx/
 obj-$(CONFIG_B43)		+= b43/
 obj-$(CONFIG_B43LEGACY)		+= b43legacy/
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/


-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Mon Nov 19 20:21:31 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Mon, 19 Nov 2007 20:21:31 +0100
Subject: [PATCH v3] b43/b43legacy: fix left-over URLs and ifdefs
Message-ID: <20071119202131.63c09285@morte>

Fix some left-over URLs and ifdefs in b43 and b43legacy drivers.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

John,
I hope this is the last try, v2 was line wrapped. :) This is for 2.6.24.

---

Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -1558,7 +1558,7 @@ static void b43_release_firmware(struct 
 static void b43_print_fw_helptext(struct b43_wl *wl)
 {
 	b43err(wl, "You must go to "
-	       "http://linuxwireless.org/en/users/Drivers/bcm43xx#devicefirmware "
+	       "http://linuxwireless.org/en/users/Drivers/b43#devicefirmware "
 	       "and download the correct firmware (version 4).\n");
 }
 
Index: wireless-2.6/drivers/net/wireless/b43legacy/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/dma.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/dma.c
@@ -996,7 +996,7 @@ int b43legacy_dma_init(struct b43legacy_
 
 	err = ssb_dma_set_mask(dev->dev, dmamask);
 	if (err) {
-#ifdef BCM43XX_PIO
+#ifdef CONFIG_B43LEGACY_PIO
 		b43legacywarn(dev->wl, "DMA for this device not supported. "
 			"Falling back to PIO\n");
 		dev->__using_pio = 1;
Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -1398,7 +1398,7 @@ static void b43legacy_release_firmware(s
 static void b43legacy_print_fw_helptext(struct b43legacy_wl *wl)
 {
 	b43legacyerr(wl, "You must go to http://linuxwireless.org/en/users/"
-		     "Drivers/bcm43xx#devicefirmware "
+		     "Drivers/b43#devicefirmware "
 		     "and download the correct firmware (version 3).\n");
 }
 
 
-- 
Ciao
Stefano


From rjw at sisk.pl  Mon Nov 19 23:00:11 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Mon, 19 Nov 2007 23:00:11 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <20071119202121.6ad3fa70@morte>
References: <20071119202121.6ad3fa70@morte>
Message-ID: <200711192300.12183.rjw@sisk.pl>

On Monday, 19 of November 2007, Stefano Brivio wrote:
> Remove bcm43xx.
> 
> 
> Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
> 
> ---
> 
> John,
> I hope this is the last try, v2 was line wrapped. :) This is for 2.6.25.

Well, are you 100% sure that everyone interested knows that this drivers is
going out in 2.6.25 and no one will object?

Rafael


From stefano.brivio at polimi.it  Mon Nov 19 23:19:35 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Mon, 19 Nov 2007 23:19:35 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <200711192300.12183.rjw@sisk.pl>
References: <20071119202121.6ad3fa70@morte>
	<200711192300.12183.rjw@sisk.pl>
Message-ID: <20071119231935.535674ba@morte>

On Mon, 19 Nov 2007 23:00:11 +0100
"Rafael J. Wysocki" <rjw at sisk.pl> wrote:

> Well, are you 100% sure that everyone interested knows that this drivers
> is going out in 2.6.25 and no one will object?

The maintainers know. Having both drivers in 2.6.24 should help find out if
there's anything which should be ironed out with b43/b43legacy, but right
now they are already working a lot better than bcm43xx, and they are more
stable. So I couldn't find a reason why we shouldn't remove bcm43xx in
2.6.25.


-- 
Ciao
Stefano


From schwab at suse.de  Mon Nov 19 23:36:44 2007
From: schwab at suse.de (Andreas Schwab)
Date: Mon, 19 Nov 2007 23:36:44 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <20071119231935.535674ba@morte> (Stefano Brivio's message of
	"Mon\, 19 Nov 2007 23\:19\:35 +0100")
References: <20071119202121.6ad3fa70@morte> <200711192300.12183.rjw@sisk.pl>
	<20071119231935.535674ba@morte>
Message-ID: <jehcjheubn.fsf@sykes.suse.de>

Stefano Brivio <stefano.brivio at polimi.it> writes:

> On Mon, 19 Nov 2007 23:00:11 +0100
> "Rafael J. Wysocki" <rjw at sisk.pl> wrote:
>
>> Well, are you 100% sure that everyone interested knows that this drivers
>> is going out in 2.6.25 and no one will object?
>
> The maintainers know. Having both drivers in 2.6.24 should help find out if
> there's anything which should be ironed out with b43/b43legacy, but right
> now they are already working a lot better than bcm43xx, and they are more
> stable. So I couldn't find a reason why we shouldn't remove bcm43xx in
> 2.6.25.

b43 still does not work at all on ppc.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From rjw at sisk.pl  Mon Nov 19 23:57:43 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Mon, 19 Nov 2007 23:57:43 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <20071119231935.535674ba@morte>
References: <20071119202121.6ad3fa70@morte> <200711192300.12183.rjw@sisk.pl>
	<20071119231935.535674ba@morte>
Message-ID: <200711192357.44407.rjw@sisk.pl>

On Monday, 19 of November 2007, Stefano Brivio wrote:
> On Mon, 19 Nov 2007 23:00:11 +0100
> "Rafael J. Wysocki" <rjw at sisk.pl> wrote:
> 
> > Well, are you 100% sure that everyone interested knows that this drivers
> > is going out in 2.6.25 and no one will object?
> 
> The maintainers know.

I mean the users.

> Having both drivers in 2.6.24 should help find out if 
> there's anything which should be ironed out with b43/b43legacy, but right
> now they are already working a lot better than bcm43xx, and they are more
> stable. So I couldn't find a reason why we shouldn't remove bcm43xx in
> 2.6.25.

Many people use the old driver and you are forcing them to switch in a rather
unfriendly fashion.

Moreover, the switch generally involves a configuration change (on my system
eth1 became wlan0) and is not _that_ seamless.

IMvHO, the schedule of the removal of this driver should be discussed on LKML.

Greetings,
Rafael


From rjw at sisk.pl  Tue Nov 20 00:02:14 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Tue, 20 Nov 2007 00:02:14 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <jehcjheubn.fsf@sykes.suse.de>
References: <20071119202121.6ad3fa70@morte> <20071119231935.535674ba@morte>
	<jehcjheubn.fsf@sykes.suse.de>
Message-ID: <200711200002.14993.rjw@sisk.pl>

On Monday, 19 of November 2007, Andreas Schwab wrote:
> Stefano Brivio <stefano.brivio at polimi.it> writes:
> 
> > On Mon, 19 Nov 2007 23:00:11 +0100
> > "Rafael J. Wysocki" <rjw at sisk.pl> wrote:
> >
> >> Well, are you 100% sure that everyone interested knows that this drivers
> >> is going out in 2.6.25 and no one will object?
> >
> > The maintainers know. Having both drivers in 2.6.24 should help find out if
> > there's anything which should be ironed out with b43/b43legacy, but right
> > now they are already working a lot better than bcm43xx, and they are more
> > stable. So I couldn't find a reason why we shouldn't remove bcm43xx in
> > 2.6.25.
> 
> b43 still does not work at all on ppc.

Well, in that case for ppc users the removal of bcm43xx will be a regression.

Greetings,
Rafael


From stefano.brivio at polimi.it  Tue Nov 20 00:13:29 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 20 Nov 2007 00:13:29 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <jehcjheubn.fsf@sykes.suse.de>
References: <20071119202121.6ad3fa70@morte> <200711192300.12183.rjw@sisk.pl>
	<20071119231935.535674ba@morte> <jehcjheubn.fsf@sykes.suse.de>
Message-ID: <20071120001329.3524494a@morte>

On Mon, 19 Nov 2007 23:36:44 +0100
Andreas Schwab <schwab at suse.de> wrote:

> Stefano Brivio <stefano.brivio at polimi.it> writes:
> 
> > On Mon, 19 Nov 2007 23:00:11 +0100
> > "Rafael J. Wysocki" <rjw at sisk.pl> wrote:
> >
> >> Well, are you 100% sure that everyone interested knows that this
> >> drivers is going out in 2.6.25 and no one will object?
> >
> > The maintainers know. Having both drivers in 2.6.24 should help find
> > out if there's anything which should be ironed out with b43/b43legacy,
> > but right now they are already working a lot better than bcm43xx, and
> > they are more stable. So I couldn't find a reason why we shouldn't
> > remove bcm43xx in 2.6.25.
> 
> b43 still does not work at all on ppc.

This is strange. Because it has been developed mainly on PPC. Plus, if you
could better define "does not work" as per
http://www.chiark.greenend.org.uk/~sgtatham/bugs.html, it would be great.


-- 
Ciao
Stefano


From schwab at suse.de  Tue Nov 20 00:19:55 2007
From: schwab at suse.de (Andreas Schwab)
Date: Tue, 20 Nov 2007 00:19:55 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <20071120001329.3524494a@morte> (Stefano Brivio's message of
	"Tue\, 20 Nov 2007 00\:13\:29 +0100")
References: <20071119202121.6ad3fa70@morte> <200711192300.12183.rjw@sisk.pl>
	<20071119231935.535674ba@morte> <jehcjheubn.fsf@sykes.suse.de>
	<20071120001329.3524494a@morte>
Message-ID: <jed4u5esbo.fsf@sykes.suse.de>

Stefano Brivio <stefano.brivio at polimi.it> writes:

> This is strange. Because it has been developed mainly on PPC. Plus, if you
> could better define "does not work"

See <http://marc.info/?l=linux-wireless&m=119356497407301&w=2>.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From stefano.brivio at polimi.it  Tue Nov 20 01:15:49 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 20 Nov 2007 01:15:49 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <jed4u5esbo.fsf@sykes.suse.de>
References: <20071119202121.6ad3fa70@morte> <200711192300.12183.rjw@sisk.pl>
	<20071119231935.535674ba@morte> <jehcjheubn.fsf@sykes.suse.de>
	<20071120001329.3524494a@morte> <jed4u5esbo.fsf@sykes.suse.de>
Message-ID: <20071120011549.6b04bb4d@morte>

On Tue, 20 Nov 2007 00:19:55 +0100
Andreas Schwab <schwab at suse.de> wrote:

> Stefano Brivio <stefano.brivio at polimi.it> writes:
> 
> > This is strange. Because it has been developed mainly on PPC. Plus, if
> > you could better define "does not work"
> 
> See <http://marc.info/?l=linux-wireless&m=119356497407301&w=2>.

It looks like we don't get a valid txstatus even if the txstatus indicator
register told us we could read it. The only difference I can see between
bcm43xx and b43 here is that in bcm43xx we allowed the whole register to be
non-zero, while in b43 we check a bit only (as per v4 specs). Would you
mind to try this:

--- drivers/net/wireless/b43/main.c.orig        2007-11-20 01:12:12.186524483 +0100
+++ drivers/net/wireless/b43/main.c     2007-11-20 01:12:34.922702865 +0100
@@ -947,7 +947,7 @@

        while (1) {
                v0 = b43_read32(dev, B43_MMIO_XMITSTAT_0);
-               if (!(v0 & 0x00000001))
+               if (!v0)
                        break;
                v1 = b43_read32(dev, B43_MMIO_XMITSTAT_1);

(probably it's not the solution, I just want to see what happens then).
BTW, what firmware are you using? Michael, any clue?


-- 
Ciao
Stefano


From larry.finger at lwfinger.net  Tue Nov 20 03:33:47 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 19 Nov 2007 20:33:47 -0600
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <200711192357.44407.rjw@sisk.pl>
References: <20071119202121.6ad3fa70@morte> <200711192300.12183.rjw@sisk.pl>
	<20071119231935.535674ba@morte> <200711192357.44407.rjw@sisk.pl>
Message-ID: <4742478B.3090908@lwfinger.net>

Rafael J. Wysocki wrote:
> 
> Many people use the old driver and you are forcing them to switch in a rather
> unfriendly fashion.
> 
> Moreover, the switch generally involves a configuration change (on my system
> eth1 became wlan0) and is not _that_ seamless.

That change is in udev and has nothing to do with the bcm43xx - b43 change. The renaming will happen
even though one stays with bcm43xx.

Larry


From Larry.Finger at lwfinger.net  Tue Nov 20 04:06:45 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 19 Nov 2007 21:06:45 -0600
Subject: [RFT] b43: patches to use 2.6.24-rc2 with BCM4311 rev 02
Message-ID: <47424f45.akrBdcMbF2XGmahx%Larry.Finger@lwfinger.net>

This patch modifies the code in kernel 2.6.24-rc2 to implement the BCM94311MCG
rev 02.

This patch will apply to kernel 2.6.24-rc3; however, I am getting fatal DMA
errors. At the moment, it is not clear why. There is a single patch that "fixes"
b43 when it is reverted; however, it is clearly not the problem - it just exposes
whatever is the real cause. The problem may be a bug in the driver, a hardware
problem on my machine, or even a firmware bug. If others could verify that this
patch works on -rc2, and that it fails on -rc3, it would help isolate the problem.

This patch has extra debugging output that will not be in the final version.

Larry Finger

==================================================================

Index: linux-2.6/include/linux/ssb/ssb.h
===================================================================
--- linux-2.6.orig/include/linux/ssb/ssb.h
+++ linux-2.6/include/linux/ssb/ssb.h
@@ -15,22 +15,14 @@ struct pcmcia_device;
 struct ssb_bus;
 struct ssb_driver;
 
-
-struct ssb_sprom_r1 {
-	u16 pci_spid;		/* Subsystem Product ID for PCI */
-	u16 pci_svid;		/* Subsystem Vendor ID for PCI */
-	u16 pci_pid;		/* Product ID for PCI */
+struct ssb_sprom {
+	u8 revision;
 	u8 il0mac[6];		/* MAC address for 802.11b/g */
 	u8 et0mac[6];		/* MAC address for Ethernet */
 	u8 et1mac[6];		/* MAC address for 802.11a */
-	u8 et0phyaddr:5;	/* MII address for enet0 */
-	u8 et1phyaddr:5;	/* MII address for enet1 */
-	u8 et0mdcport:1;	/* MDIO for enet0 */
-	u8 et1mdcport:1;	/* MDIO for enet1 */
-	u8 board_rev;		/* Board revision */
-	u8 country_code:4;	/* Country Code */
-	u8 antenna_a:2;		/* Antenna 0/1 available for A-PHY */
-	u8 antenna_bg:2;	/* Antenna 0/1 available for B-PHY and G-PHY */
+	u8 et0phyaddr;		/* MII address for enet0 */
+	u8 et1phyaddr;		/* MII address for enet1 */
+	u8 country_code;	/* Country Code */
 	u16 pa0b0;
 	u16 pa0b1;
 	u16 pa0b2;
@@ -41,61 +33,15 @@ struct ssb_sprom_r1 {
 	u8 gpio1;		/* GPIO pin 1 */
 	u8 gpio2;		/* GPIO pin 2 */
 	u8 gpio3;		/* GPIO pin 3 */
-	u16 maxpwr_a;		/* A-PHY Power Amplifier Max Power (in dBm Q5.2) */
-	u16 maxpwr_bg;		/* B/G-PHY Power Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_a;		/* A-PHY Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_bg;		/* B/G-PHY Amplifier Max Power (in dBm Q5.2) */
 	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
 	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
 	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
 	u8 antenna_gain_a;	/* A-PHY Antenna gain (in dBm Q5.2) */
 	u8 antenna_gain_bg;	/* B/G-PHY Antenna gain (in dBm Q5.2) */
-	u8 oem[8];		/* OEM string (rev 1 only) */
-};
-
-struct ssb_sprom_r2 {
-	u16 boardflags_hi;	/* Boardflags (high 16 bits) */
-	u8 maxpwr_a_lo;		/* A-PHY Max Power Low */
-	u8 maxpwr_a_hi;		/* A-PHY Max Power High */
-	u16 pa1lob0;		/* A-PHY PA Low Settings */
-	u16 pa1lob1;		/* A-PHY PA Low Settings */
-	u16 pa1lob2;		/* A-PHY PA Low Settings */
-	u16 pa1hib0;		/* A-PHY PA High Settings */
-	u16 pa1hib1;		/* A-PHY PA High Settings */
-	u16 pa1hib2;		/* A-PHY PA High Settings */
-	u8 ofdm_pwr_off;	/* OFDM Power Offset from CCK Level */
-	u8 country_str[2];	/* Two char Country Code */
-};
 
-struct ssb_sprom_r3 {
-	u32 ofdmapo;		/* A-PHY OFDM Mid Power Offset */
-	u32 ofdmalpo;		/* A-PHY OFDM Low Power Offset */
-	u32 ofdmahpo;		/* A-PHY OFDM High Power Offset */
-	u8 gpioldc_on_cnt;	/* GPIO LED Powersave Duty Cycle ON count */
-	u8 gpioldc_off_cnt;	/* GPIO LED Powersave Duty Cycle OFF count */
-	u8 cckpo_1M:4;		/* CCK Power Offset for Rate 1M */
-	u8 cckpo_2M:4;		/* CCK Power Offset for Rate 2M */
-	u8 cckpo_55M:4;		/* CCK Power Offset for Rate 5.5M */
-	u8 cckpo_11M:4;		/* CCK Power Offset for Rate 11M */
-	u32 ofdmgpo;		/* G-PHY OFDM Power Offset */
-};
-
-struct ssb_sprom_r4 {
-	/* TODO */
-};
-
-struct ssb_sprom {
-	u8 revision;
-	u8 crc;
-	/* The valid r# fields are selected by the "revision".
-	 * Revision 3 and lower inherit from lower revisions.
-	 */
-	union {
-		struct {
-			struct ssb_sprom_r1 r1;
-			struct ssb_sprom_r2 r2;
-			struct ssb_sprom_r3 r3;
-		};
-		struct ssb_sprom_r4 r4;
-	};
+	/* TODO - add any parameters needed from rev 2, 3, or 4 SPROMs */
 };
 
 /* Information about the PCB the circuitry is soldered on. */
@@ -288,6 +234,7 @@ struct ssb_bus {
 	/* ID information about the Chip. */
 	u16 chip_id;
 	u16 chip_rev;
+	u16 sprom_size;		/* number of words in sprom */
 	u8 chip_package;
 
 	/* List of devices (cores) on the backplane. */
Index: linux-2.6/include/linux/ssb/ssb_regs.h
===================================================================
--- linux-2.6.orig/include/linux/ssb/ssb_regs.h
+++ linux-2.6/include/linux/ssb/ssb_regs.h
@@ -147,6 +147,10 @@
 #define  SSB_IDLOW_SSBREV	0xF0000000 /* Sonics Backplane Revision code */
 #define  SSB_IDLOW_SSBREV_22	0x00000000 /* <= 2.2 */
 #define  SSB_IDLOW_SSBREV_23	0x10000000 /* 2.3 */
+#define  SSB_IDLOW_SSBREV_24	0x40000000 /* ?? Found in BCM4328 */
+#define  SSB_IDLOW_SSBREV_25	0x50000000 /* ?? Not Found yet */
+#define  SSB_IDLOW_SSBREV_26	0x60000000 /* ?? Found in some BCM4311/2 */
+#define  SSB_IDLOW_SSBREV_27	0x70000000 /* ?? Found in some BCM4311/2 */
 #define SSB_IDHIGH		0x0FFC     /* SB Identification High */
 #define  SSB_IDHIGH_RCLO	0x0000000F /* Revision Code (low part) */
 #define  SSB_IDHIGH_CC		0x00008FF0 /* Core Code */
@@ -162,11 +166,16 @@
  */
 #define SSB_SPROMSIZE_WORDS		64
 #define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
+#define SSB_SPROMSIZE_WORDS_R123	64
+#define SSB_SPROMSIZE_WORDS_R4		220
+#define SSB_SPROMSIZE_BYTES_R123	(SSB_SPROMSIZE_WORDS_R123 * sizeof(u16))
+#define SSB_SPROMSIZE_BYTES_R4		(SSB_SPROMSIZE_WORDS_R4 * sizeof(u16))
 #define SSB_SPROM_BASE			0x1000
 #define SSB_SPROM_REVISION		0x107E
 #define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
 #define  SSB_SPROM_REVISION_CRC		0xFF00	/* SPROM CRC8 value */
 #define  SSB_SPROM_REVISION_CRC_SHIFT	8
+
 /* SPROM Revision 1 */
 #define SSB_SPROM1_SPID			0x1004	/* Subsystem Product ID for PCI */
 #define SSB_SPROM1_SVID			0x1006	/* Subsystem Vendor ID for PCI */
@@ -215,7 +224,7 @@
 #define  SSB_SPROM1_AGAIN_A		0x00FF	/* A-PHY */
 #define  SSB_SPROM1_AGAIN_BG		0xFF00	/* B-PHY and G-PHY */
 #define  SSB_SPROM1_AGAIN_BG_SHIFT	8
-#define SSB_SPROM1_OEM			0x1076	/* 8 bytes OEM string (rev 1 only) */
+
 /* SPROM Revision 2 (inherits from rev 1) */
 #define SSB_SPROM2_BFLHI		0x1038	/* Boardflags (high 16 bits) */
 #define SSB_SPROM2_MAXP_A		0x103A	/* A-PHY Max Power */
@@ -232,7 +241,11 @@
 #define  SSB_SPROM2_OPO_VALUE		0x00FF
 #define  SSB_SPROM2_OPO_UNUSED		0xFF00
 #define SSB_SPROM2_CCODE		0x107C	/* Two char Country Code */
-/* SPROM Revision 3 (inherits from rev 2) */
+
+/* SPROM Revision 3 (inherits most data from rev 2) */
+#define SSB_SPROM3_IL0MAC		0x104A	/* 6 bytes MAC address for 802.11b/g */
+#define SSB_SPROM3_ET0MAC		0x1050	/* 6 bytes MAC address for Ethernet ?? */
+#define SSB_SPROM3_ET1MAC		0x1050	/* 6 bytes MAC address for 802.11a ?? */
 #define SSB_SPROM3_OFDMAPO		0x102C	/* A-PHY OFDM Mid Power Offset (4 bytes, BigEndian) */
 #define SSB_SPROM3_OFDMALPO		0x1030	/* A-PHY OFDM Low Power Offset (4 bytes, BigEndian) */
 #define SSB_SPROM3_OFDMAHPO		0x1034	/* A-PHY OFDM High Power Offset (4 bytes, BigEndian) */
@@ -251,6 +264,48 @@
 #define  SSB_SPROM3_CCKPO_11M_SHIFT	12
 #define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
 
+/* SPROM Revision 4 		entries with ?? in comment are unknown */
+#define SSB_SPROM4_IL0MAC		0x104C	/* 6 byte MAC address for a/b/g/n */
+#define SSB_SPROM4_ET0MAC		0x1018	/* 6 bytes MAC address for Ethernet ?? */
+#define SSB_SPROM4_ET1MAC		0x1018	/* 6 bytes MAC address for 802.11a ?? */
+#define SSB_SPROM4_ETHPHY		0x105A	/* Ethernet PHY settings ?? */
+#define  SSB_SPROM4_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
+#define  SSB_SPROM4_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
+#define  SSB_SPROM4_ETHPHY_ET1A_SHIFT	5
+#define  SSB_SPROM4_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
+#define  SSB_SPROM4_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
+#define SSB_SPROM4_CCODE		0x1052	/* Country Code (2 bytes) */
+#define SSB_SPROM4_ANT_A		0x105D  /* A Antennas */
+#define SSB_SPROM4_ANT_BG		0x105C  /* B/G Antennas */
+#define SSB_SPROM4_BFLLO		0x1044	/* Boardflags (low 16 bits) */
+#define SSB_SPROM4_AGAIN		0x105E	/* Antenna Gain (in dBm Q5.2) */
+#define  SSB_SPROM4_AGAIN_0		0x00FF	/* Antenna 0 */
+#define  SSB_SPROM4_AGAIN_1		0xFF00	/* Antenna 1 */
+#define  SSB_SPROM4_AGAIN_1_SHIFT	8
+#define SSB_SPROM4_BFLHI		0x1046  /* Board Flags Hi */
+#define SSB_SPROM4_MAXP_BG		0x1080  /* Max Power BG in path 1 */
+#define  SSB_SPROM4_MAXP_BG_MASK	0x00FF  /* Mask for Max Power BG */
+#define  SSB_SPROM4_ITSSI_BG		0xFF00	/* Mask for path 1 itssi_bg */
+#define  SSB_SPROM4_ITSSI_BG_SHIFT	8
+#define SSB_SPROM4_MAXP_A		0x108A  /* Max Power A in path 1 */
+#define  SSB_SPROM4_MAXP_A_MASK		0x00FF  /* Mask for Max Power A */
+#define  SSB_SPROM4_ITSSI_A		0xFF00	/* Mask for path 1 itssi_a */
+#define  SSB_SPROM4_ITSSI_A_SHIFT	8
+#define SSB_SPROM4_GPIOA		0x1056	/* Gen. Purpose IO # 0 and 1 */
+#define  SSB_SPROM4_GPIOA_P0		0x00FF	/* Pin 0 */
+#define  SSB_SPROM4_GPIOA_P1		0xFF00	/* Pin 1 */
+#define  SSB_SPROM4_GPIOA_P1_SHIFT	8
+#define SSB_SPROM4_GPIOB		0x1058	/* Gen. Purpose IO # 2 and 3 */
+#define  SSB_SPROM4_GPIOB_P2		0x00FF	/* Pin 2 */
+#define  SSB_SPROM4_GPIOB_P3		0xFF00	/* Pin 3 */
+#define  SSB_SPROM4_GPIOB_P3_SHIFT	8
+#define SSB_SPROM4_PA0B0		0x1082	/* The paXbY locations are */
+#define SSB_SPROM4_PA0B1		0x1084	/*   only guesses */
+#define SSB_SPROM4_PA0B2		0x1086
+#define SSB_SPROM4_PA1B0		0x108E
+#define SSB_SPROM4_PA1B1		0x1090
+#define SSB_SPROM4_PA1B2		0x1092
+
 /* Values for SSB_SPROM1_BINF_CCODE */
 enum {
 	SSB_SPROM1CCODE_WORLD = 0,
Index: linux-2.6/drivers/ssb/pci.c
===================================================================
--- linux-2.6.orig/drivers/ssb/pci.c
+++ linux-2.6/drivers/ssb/pci.c
@@ -212,29 +212,29 @@ static inline u8 ssb_crc8(u8 crc, u8 dat
 	return t[crc ^ data];
 }
 
-static u8 ssb_sprom_crc(const u16 *sprom)
+static u8 ssb_sprom_crc(const u16 *sprom, u16 size)
 {
 	int word;
 	u8 crc = 0xFF;
 
-	for (word = 0; word < SSB_SPROMSIZE_WORDS - 1; word++) {
+	for (word = 0; word < size - 1; word++) {
 		crc = ssb_crc8(crc, sprom[word] & 0x00FF);
 		crc = ssb_crc8(crc, (sprom[word] & 0xFF00) >> 8);
 	}
-	crc = ssb_crc8(crc, sprom[SPOFF(SSB_SPROM_REVISION)] & 0x00FF);
+	crc = ssb_crc8(crc, sprom[size - 1] & 0x00FF);
 	crc ^= 0xFF;
 
 	return crc;
 }
 
-static int sprom_check_crc(const u16 *sprom)
+static int sprom_check_crc(const u16 *sprom, u16 size)
 {
 	u8 crc;
 	u8 expected_crc;
 	u16 tmp;
 
-	crc = ssb_sprom_crc(sprom);
-	tmp = sprom[SPOFF(SSB_SPROM_REVISION)] & SSB_SPROM_REVISION_CRC;
+	crc = ssb_sprom_crc(sprom, size);
+	tmp = sprom[size - 1] & SSB_SPROM_REVISION_CRC;
 	expected_crc = tmp >> SSB_SPROM_REVISION_CRC_SHIFT;
 	if (crc != expected_crc)
 		return -EPROTO;
@@ -246,7 +246,7 @@ static void sprom_do_read(struct ssb_bus
 {
 	int i;
 
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++)
+	for (i = 0; i < bus->sprom_size; i++)
 		sprom[i] = readw(bus->mmio + SSB_SPROM_BASE + (i * 2));
 }
 
@@ -255,6 +255,7 @@ static int sprom_do_write(struct ssb_bus
 	struct pci_dev *pdev = bus->host_pci;
 	int i, err;
 	u32 spromctl;
+	u16 size = bus->sprom_size;
 
 	ssb_printk(KERN_NOTICE PFX "Writing SPROM. Do NOT turn off the power! Please stand by...\n");
 	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
@@ -266,12 +267,12 @@ static int sprom_do_write(struct ssb_bus
 		goto err_ctlreg;
 	ssb_printk(KERN_NOTICE PFX "[ 0%%");
 	msleep(500);
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
-		if (i == SSB_SPROMSIZE_WORDS / 4)
+	for (i = 0; i < size; i++) {
+		if (i == size / 4)
 			ssb_printk("25%%");
-		else if (i == SSB_SPROMSIZE_WORDS / 2)
+		else if (i == size / 2)
 			ssb_printk("50%%");
-		else if (i == (SSB_SPROMSIZE_WORDS / 4) * 3)
+		else if (i == (size * 3) / 4)
 			ssb_printk("75%%");
 		else if (i % 2)
 			ssb_printk(".");
@@ -296,38 +297,38 @@ err_ctlreg:
 	return err;
 }
 
-static void sprom_extract_r1(struct ssb_sprom_r1 *out, const u16 *in)
+static void sprom_extract_r123(struct ssb_sprom *out, const u16 *in)
 {
 	int i;
 	u16 v;
+	u16 loc[3];
 
-	SPEX(pci_spid, SSB_SPROM1_SPID, 0xFFFF, 0);
-	SPEX(pci_svid, SSB_SPROM1_SVID, 0xFFFF, 0);
-	SPEX(pci_pid, SSB_SPROM1_PID, 0xFFFF, 0);
+	if (out->revision == 3) {			/* rev 3 moved MAC */
+		loc[0] = SSB_SPROM3_IL0MAC;
+		loc[1] = SSB_SPROM3_ET0MAC;
+		loc[2] = SSB_SPROM3_ET1MAC;
+	} else {
+		loc[0] = SSB_SPROM1_IL0MAC;
+		loc[1] = SSB_SPROM1_ET0MAC;
+		loc[2] = SSB_SPROM1_ET1MAC;
+	}
 	for (i = 0; i < 3; i++) {
-		v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
+		v = in[SPOFF(loc[0]) + i];
 		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
 	}
 	for (i = 0; i < 3; i++) {
-		v = in[SPOFF(SSB_SPROM1_ET0MAC) + i];
+		v = in[SPOFF(loc[1]) + i];
 		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
 	}
 	for (i = 0; i < 3; i++) {
-		v = in[SPOFF(SSB_SPROM1_ET1MAC) + i];
+		v = in[SPOFF(loc[2]) + i];
 		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
 	}
 	SPEX(et0phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0A, 0);
 	SPEX(et1phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1A,
 	     SSB_SPROM1_ETHPHY_ET1A_SHIFT);
-	SPEX(et0mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0M, 14);
-	SPEX(et1mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1M, 15);
-	SPEX(board_rev, SSB_SPROM1_BINF, SSB_SPROM1_BINF_BREV, 0);
 	SPEX(country_code, SSB_SPROM1_BINF, SSB_SPROM1_BINF_CCODE,
 	     SSB_SPROM1_BINF_CCODE_SHIFT);
-	SPEX(antenna_a, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTA,
-	     SSB_SPROM1_BINF_ANTA_SHIFT);
-	SPEX(antenna_bg, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTBG,
-	     SSB_SPROM1_BINF_ANTBG_SHIFT);
 	SPEX(pa0b0, SSB_SPROM1_PA0B0, 0xFFFF, 0);
 	SPEX(pa0b1, SSB_SPROM1_PA0B1, 0xFFFF, 0);
 	SPEX(pa0b2, SSB_SPROM1_PA0B2, 0xFFFF, 0);
@@ -350,97 +351,75 @@ static void sprom_extract_r1(struct ssb_
 	SPEX(antenna_gain_a, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_A, 0);
 	SPEX(antenna_gain_bg, SSB_SPROM1_AGAIN, SSB_SPROM1_AGAIN_BG,
 	     SSB_SPROM1_AGAIN_BG_SHIFT);
-	for (i = 0; i < 4; i++) {
-		v = in[SPOFF(SSB_SPROM1_OEM) + i];
-		*(((__le16 *)out->oem) + i) = cpu_to_le16(v);
-	}
 }
 
-static void sprom_extract_r2(struct ssb_sprom_r2 *out, const u16 *in)
+static void sprom_extract_r4(struct ssb_sprom *out, const u16 *in)
 {
 	int i;
 	u16 v;
 
-	SPEX(boardflags_hi, SSB_SPROM2_BFLHI,  0xFFFF, 0);
-	SPEX(maxpwr_a_hi, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_HI, 0);
-	SPEX(maxpwr_a_lo, SSB_SPROM2_MAXP_A, SSB_SPROM2_MAXP_A_LO,
-	     SSB_SPROM2_MAXP_A_LO_SHIFT);
-	SPEX(pa1lob0, SSB_SPROM2_PA1LOB0, 0xFFFF, 0);
-	SPEX(pa1lob1, SSB_SPROM2_PA1LOB1, 0xFFFF, 0);
-	SPEX(pa1lob2, SSB_SPROM2_PA1LOB2, 0xFFFF, 0);
-	SPEX(pa1hib0, SSB_SPROM2_PA1HIB0, 0xFFFF, 0);
-	SPEX(pa1hib1, SSB_SPROM2_PA1HIB1, 0xFFFF, 0);
-	SPEX(pa1hib2, SSB_SPROM2_PA1HIB2, 0xFFFF, 0);
-	SPEX(ofdm_pwr_off, SSB_SPROM2_OPO, SSB_SPROM2_OPO_VALUE, 0);
-	for (i = 0; i < 4; i++) {
-		v = in[SPOFF(SSB_SPROM2_CCODE) + i];
-		*(((__le16 *)out->country_str) + i) = cpu_to_le16(v);
+	/* extract the equivalent of the r1 variables */
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM4_IL0MAC) + i];
+		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
 	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM4_ET0MAC) + i];
+		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
+	}
+	for (i = 0; i < 3; i++) {
+		v = in[SPOFF(SSB_SPROM4_ET1MAC) + i];
+		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
+	}
+	SPEX(et0phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET0A, 0);
+	SPEX(et1phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET1A,
+	     SSB_SPROM4_ETHPHY_ET1A_SHIFT);
+	SPEX(country_code, SSB_SPROM4_CCODE, 0xFFFF, 0);
+	SPEX(boardflags_lo, SSB_SPROM4_BFLLO, 0xFFFF, 0);
+	SPEX(antenna_gain_a, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_0, 0);
+	SPEX(antenna_gain_bg, SSB_SPROM4_AGAIN, SSB_SPROM4_AGAIN_1,
+	     SSB_SPROM4_AGAIN_1_SHIFT);
+	SPEX(maxpwr_bg, SSB_SPROM4_MAXP_BG, SSB_SPROM4_MAXP_BG_MASK, 0);
+	SPEX(itssi_bg, SSB_SPROM4_MAXP_BG, SSB_SPROM4_ITSSI_BG,
+	     SSB_SPROM4_ITSSI_BG_SHIFT);
+	SPEX(maxpwr_a, SSB_SPROM4_MAXP_A, SSB_SPROM4_MAXP_A_MASK, 0);
+	SPEX(itssi_a, SSB_SPROM4_MAXP_A, SSB_SPROM4_ITSSI_A,
+	     SSB_SPROM4_ITSSI_A_SHIFT);
+	SPEX(gpio0, SSB_SPROM4_GPIOA, SSB_SPROM4_GPIOA_P0, 0);
+	SPEX(gpio1, SSB_SPROM4_GPIOA, SSB_SPROM4_GPIOA_P1,
+	     SSB_SPROM4_GPIOA_P1_SHIFT);
+	SPEX(gpio2, SSB_SPROM4_GPIOB, SSB_SPROM4_GPIOB_P2, 0);
+	SPEX(gpio3, SSB_SPROM4_GPIOB, SSB_SPROM4_GPIOB_P3,
+	     SSB_SPROM4_GPIOB_P3_SHIFT);
+	/* TODO - get remaining rev 4 stuff needed */
 }
 
-static void sprom_extract_r3(struct ssb_sprom_r3 *out, const u16 *in)
-{
-	out->ofdmapo  = (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0xFF00) >> 8;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 0] & 0x00FF) << 8;
-	out->ofdmapo <<= 16;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0xFF00) >> 8;
-	out->ofdmapo |= (in[SPOFF(SSB_SPROM3_OFDMAPO) + 1] & 0x00FF) << 8;
-
-	out->ofdmalpo  = (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0xFF00) >> 8;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 0] & 0x00FF) << 8;
-	out->ofdmalpo <<= 16;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0xFF00) >> 8;
-	out->ofdmalpo |= (in[SPOFF(SSB_SPROM3_OFDMALPO) + 1] & 0x00FF) << 8;
-
-	out->ofdmahpo  = (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0xFF00) >> 8;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 0] & 0x00FF) << 8;
-	out->ofdmahpo <<= 16;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0xFF00) >> 8;
-	out->ofdmahpo |= (in[SPOFF(SSB_SPROM3_OFDMAHPO) + 1] & 0x00FF) << 8;
-
-	SPEX(gpioldc_on_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_ON,
-	     SSB_SPROM3_GPIOLDC_ON_SHIFT);
-	SPEX(gpioldc_off_cnt, SSB_SPROM3_GPIOLDC, SSB_SPROM3_GPIOLDC_OFF,
-	     SSB_SPROM3_GPIOLDC_OFF_SHIFT);
-	SPEX(cckpo_1M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_1M, 0);
-	SPEX(cckpo_2M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_2M,
-	     SSB_SPROM3_CCKPO_2M_SHIFT);
-	SPEX(cckpo_55M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_55M,
-	     SSB_SPROM3_CCKPO_55M_SHIFT);
-	SPEX(cckpo_11M, SSB_SPROM3_CCKPO, SSB_SPROM3_CCKPO_11M,
-	     SSB_SPROM3_CCKPO_11M_SHIFT);
-
-	out->ofdmgpo  = (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0xFF00) >> 8;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 0] & 0x00FF) << 8;
-	out->ofdmgpo <<= 16;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0xFF00) >> 8;
-	out->ofdmgpo |= (in[SPOFF(SSB_SPROM3_OFDMGPO) + 1] & 0x00FF) << 8;
-}
-
-static int sprom_extract(struct ssb_bus *bus,
-			 struct ssb_sprom *out, const u16 *in)
+static int sprom_extract(struct ssb_bus *bus, struct ssb_sprom *out,
+			 const u16 *in, u16 size)
 {
 	memset(out, 0, sizeof(*out));
 
-	SPEX(revision, SSB_SPROM_REVISION, SSB_SPROM_REVISION_REV, 0);
-	SPEX(crc, SSB_SPROM_REVISION, SSB_SPROM_REVISION_CRC,
-	     SSB_SPROM_REVISION_CRC_SHIFT);
-
+	out->revision = in[size - 1] & 0x00FF;
+	ssb_printk(KERN_INFO PFX "SPROM revision %d detected.\n", out->revision);
 	if ((bus->chip_id & 0xFF00) == 0x4400) {
 		/* Workaround: The BCM44XX chip has a stupid revision
 		 * number stored in the SPROM.
 		 * Always extract r1. */
-		sprom_extract_r1(&out->r1, in);
+		out->revision = 1;
+		sprom_extract_r123(out, in);
+	} else if (bus->chip_id == 0x4321) {
+		/* the BCM4328 has a chipid == 0x4321 and a rev 4 SPROM */
+		out->revision = 4;
+		sprom_extract_r4(out, in);
 	} else {
 		if (out->revision == 0)
 			goto unsupported;
-		if (out->revision >= 1 && out->revision <= 3)
-			sprom_extract_r1(&out->r1, in);
-		if (out->revision >= 2 && out->revision <= 3)
-			sprom_extract_r2(&out->r2, in);
-		if (out->revision == 3)
-			sprom_extract_r3(&out->r3, in);
-		if (out->revision >= 4)
+		if (out->revision >= 1 && out->revision <= 3) {
+			sprom_extract_r123(out, in);
+		}
+		if (out->revision == 4)
+			sprom_extract_r4(out, in);
+		if (out->revision >= 5)
 			goto unsupported;
 	}
 
@@ -448,7 +427,7 @@ static int sprom_extract(struct ssb_bus 
 unsupported:
 	ssb_printk(KERN_WARNING PFX "Unsupported SPROM revision %d "
 		   "detected. Will extract v1\n", out->revision);
-	sprom_extract_r1(&out->r1, in);
+	sprom_extract_r123(out, in);
 	return 0;
 }
 
@@ -458,16 +437,31 @@ static int ssb_pci_sprom_get(struct ssb_
 	int err = -ENOMEM;
 	u16 *buf;
 
-	buf = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	buf = kcalloc(SSB_SPROMSIZE_WORDS_R123, sizeof(u16), GFP_KERNEL);
 	if (!buf)
 		goto out;
+	bus->sprom_size = SSB_SPROMSIZE_WORDS_R123;
 	sprom_do_read(bus, buf);
-	err = sprom_check_crc(buf);
+	err = sprom_check_crc(buf, bus->sprom_size);
 	if (err) {
-		ssb_printk(KERN_WARNING PFX
-			   "WARNING: Invalid SPROM CRC (corrupt SPROM)\n");
+		/* check for rev 4 sprom - has special signature */
+		if (buf [32] == 0x5372) {
+			ssb_printk(KERN_WARNING PFX "Extracting a rev 4"
+				   " SPROM\n");
+			kfree(buf);
+			buf = kcalloc(SSB_SPROMSIZE_WORDS_R4, sizeof(u16),
+				      GFP_KERNEL);
+			if (!buf)
+				goto out;
+			bus->sprom_size = SSB_SPROMSIZE_WORDS_R4;
+			sprom_do_read(bus, buf);
+			err = sprom_check_crc(buf, bus->sprom_size);
+		}
+		if (err)
+			ssb_printk(KERN_WARNING PFX "WARNING: Invalid"
+				   " SPROM CRC (corrupt SPROM)\n");
 	}
-	err = sprom_extract(bus, sprom, buf);
+	err = sprom_extract(bus, sprom, buf, bus->sprom_size);
 
 	kfree(buf);
 out:
@@ -581,29 +575,28 @@ const struct ssb_bus_ops ssb_pci_ops = {
 	.write32	= ssb_pci_write32,
 };
 
-static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len)
+static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len, u16 size)
 {
 	int i, pos = 0;
 
-	for (i = 0; i < SSB_SPROMSIZE_WORDS; i++) {
+	for (i = 0; i < size; i++)
 		pos += snprintf(buf + pos, buf_len - pos - 1,
 				"%04X", swab16(sprom[i]) & 0xFFFF);
-	}
 	pos += snprintf(buf + pos, buf_len - pos - 1, "\n");
 
 	return pos + 1;
 }
 
-static int hex2sprom(u16 *sprom, const char *dump, size_t len)
+static int hex2sprom(u16 *sprom, const char *dump, size_t len, u16 size)
 {
 	char tmp[5] = { 0 };
 	int cnt = 0;
 	unsigned long parsed;
 
-	if (len < SSB_SPROMSIZE_BYTES * 2)
+	if (len < size * 2)
 		return -EINVAL;
 
-	while (cnt < SSB_SPROMSIZE_WORDS) {
+	while (cnt < size) {
 		memcpy(tmp, dump, 4);
 		dump += 4;
 		parsed = simple_strtoul(tmp, NULL, 16);
@@ -627,7 +620,7 @@ static ssize_t ssb_pci_attr_sprom_show(s
 	if (!bus)
 		goto out;
 	err = -ENOMEM;
-	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	sprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);
 	if (!sprom)
 		goto out;
 
@@ -640,7 +633,7 @@ static ssize_t ssb_pci_attr_sprom_show(s
 	sprom_do_read(bus, sprom);
 	mutex_unlock(&bus->pci_sprom_mutex);
 
-	count = sprom2hex(sprom, buf, PAGE_SIZE);
+	count = sprom2hex(sprom, buf, PAGE_SIZE, bus->sprom_size);
 	err = 0;
 
 out_kfree:
@@ -662,15 +655,15 @@ static ssize_t ssb_pci_attr_sprom_store(
 	if (!bus)
 		goto out;
 	err = -ENOMEM;
-	sprom = kcalloc(SSB_SPROMSIZE_WORDS, sizeof(u16), GFP_KERNEL);
+	sprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);
 	if (!sprom)
 		goto out;
-	err = hex2sprom(sprom, buf, count);
+	err = hex2sprom(sprom, buf, count, bus->sprom_size);
 	if (err) {
 		err = -EINVAL;
 		goto out_kfree;
 	}
-	err = sprom_check_crc(sprom);
+	err = sprom_check_crc(sprom, bus->sprom_size);
 	if (err) {
 		err = -EINVAL;
 		goto out_kfree;
Index: linux-2.6/drivers/ssb/main.c
===================================================================
--- linux-2.6.orig/drivers/ssb/main.c
+++ linux-2.6/drivers/ssb/main.c
@@ -872,14 +872,22 @@ EXPORT_SYMBOL(ssb_clockspeed);
 
 static u32 ssb_tmslow_reject_bitmask(struct ssb_device *dev)
 {
+	u32 rev = ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV;
+
 	/* The REJECT bit changed position in TMSLOW between
 	 * Backplane revisions. */
-	switch (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV) {
+	switch (rev) {
 	case SSB_IDLOW_SSBREV_22:
 		return SSB_TMSLOW_REJECT_22;
 	case SSB_IDLOW_SSBREV_23:
 		return SSB_TMSLOW_REJECT_23;
+	case SSB_IDLOW_SSBREV_24:     /* TODO - find the proper REJECT bits */
+	case SSB_IDLOW_SSBREV_25:     /* same here */
+	case SSB_IDLOW_SSBREV_26:     /* same here */
+	case SSB_IDLOW_SSBREV_27:     /* same here */
+		return SSB_TMSLOW_REJECT_23;	/* this is a guess */
 	default:
+		printk(KERN_INFO "ssb: Backplane Revision 0x%.8X\n", rev);
 		WARN_ON(1);
 	}
 	return (SSB_TMSLOW_REJECT_22 | SSB_TMSLOW_REJECT_23);
@@ -1010,7 +1018,7 @@ int ssb_dma_set_mask(struct ssb_device *
 
 #ifdef CONFIG_SSB_PCIHOST
 	if (ssb_dev->bus->bustype == SSB_BUSTYPE_PCI &&
-	    !dma_supported(dev, mask))
+	    !dma_set_mask(dev, mask))
 		return -EIO;
 #endif
 	dev->coherent_dma_mask = mask;
Index: linux-2.6/drivers/ssb/b43_pci_bridge.c
===================================================================
--- linux-2.6.orig/drivers/ssb/b43_pci_bridge.c
+++ linux-2.6/drivers/ssb/b43_pci_bridge.c
@@ -27,6 +27,7 @@ static const struct pci_device_id b43_pc
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4321) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4324) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4325) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4328) },
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, b43_pci_bridge_tbl);
Index: linux-2.6/drivers/net/b44.c
===================================================================
--- linux-2.6.orig/drivers/net/b44.c
+++ linux-2.6/drivers/net/b44.c
@@ -2060,11 +2060,11 @@ static int __devinit b44_get_invariants(
 
 	if (sdev->bus->bustype == SSB_BUSTYPE_SSB &&
 	    instance > 1) {
-		addr = sdev->bus->sprom.r1.et1mac;
-		bp->phy_addr = sdev->bus->sprom.r1.et1phyaddr;
+		addr = sdev->bus->sprom.et1mac;
+		bp->phy_addr = sdev->bus->sprom.et1phyaddr;
 	} else {
-		addr = sdev->bus->sprom.r1.et0mac;
-		bp->phy_addr = sdev->bus->sprom.r1.et0phyaddr;
+		addr = sdev->bus->sprom.et0mac;
+		bp->phy_addr = sdev->bus->sprom.et0phyaddr;
 	}
 	memcpy(bp->dev->dev_addr, addr, 6);
 
Index: linux-2.6/drivers/net/wireless/b43/leds.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/leds.c
+++ linux-2.6/drivers/net/wireless/b43/leds.c
@@ -187,10 +187,10 @@ void b43_leds_init(struct b43_wldev *dev
 	enum b43_led_behaviour behaviour;
 	bool activelow;
 
-	sprom[0] = bus->sprom.r1.gpio0;
-	sprom[1] = bus->sprom.r1.gpio1;
-	sprom[2] = bus->sprom.r1.gpio2;
-	sprom[3] = bus->sprom.r1.gpio3;
+	sprom[0] = bus->sprom.gpio0;
+	sprom[1] = bus->sprom.gpio1;
+	sprom[2] = bus->sprom.gpio2;
+	sprom[3] = bus->sprom.gpio3;
 
 	for (i = 0; i < 4; i++) {
 		if (sprom[i] == 0xFF) {
Index: linux-2.6/drivers/net/wireless/b43/lo.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/lo.c
+++ linux-2.6/drivers/net/wireless/b43/lo.c
@@ -264,8 +264,8 @@ static u16 lo_measure_feedthrough(struct
 		rfover |= pga;
 		rfover |= lna;
 		rfover |= trsw_rx;
-		if ((dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_EXTLNA) &&
-		    phy->rev > 6)
+		if ((dev->dev->bus->sprom.boardflags_lo & B43_BFL_EXTLNA)
+		    && phy->rev > 6)
 			rfover |= B43_PHY_RFOVERVAL_EXTLNA;
 
 		b43_phy_write(dev, B43_PHY_PGACTL, 0xE300);
@@ -634,7 +634,7 @@ static void lo_measure_setup(struct b43_
 			      & 0xFFFC);
 		if (phy->type == B43_PHYTYPE_G) {
 			if ((phy->rev >= 7) &&
-			    (sprom->r1.boardflags_lo & B43_BFL_EXTLNA)) {
+			    (sprom->boardflags_lo & B43_BFL_EXTLNA)) {
 				b43_phy_write(dev, B43_PHY_RFOVER, 0x933);
 			} else {
 				b43_phy_write(dev, B43_PHY_RFOVER, 0x133);
Index: linux-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/main.c
+++ linux-2.6/drivers/net/wireless/b43/main.c
@@ -101,6 +101,7 @@ static const struct ssb_device_id b43_ss
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
 	SSB_DEVTABLE_END
 };
 
@@ -1380,6 +1381,8 @@ static void handle_irq_ucode_debug(struc
 	//TODO
 }
 
+void b43_dump_dma_regs(struct b43_wldev *dev);
+
 /* Interrupt handler bottom-half */
 static void b43_interrupt_tasklet(struct b43_wldev *dev)
 {
@@ -1414,6 +1417,7 @@ static void b43_interrupt_tasklet(struct
 			       dma_reason[0], dma_reason[1],
 			       dma_reason[2], dma_reason[3],
 			       dma_reason[4], dma_reason[5]);
+			b43_dump_dma_regs(dev);
 			b43_controller_restart(dev, "DMA error");
 			mmiowb();
 			spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
@@ -1932,7 +1936,7 @@ static int b43_gpio_init(struct b43_wlde
 		mask |= 0x0180;
 		set |= 0x0180;
 	}
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_PACTRL) {
 		b43_write16(dev, B43_MMIO_GPIO_MASK,
 			    b43_read16(dev, B43_MMIO_GPIO_MASK)
 			    | 0x0200);
@@ -2297,7 +2301,7 @@ static void b43_periodic_every60sec(stru
 
 	if (!b43_has_hardware_pctl(phy))
 		b43_lo_g_ctl_mark_all_unused(dev);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI) {
 		b43_mac_suspend(dev);
 		b43_calc_nrssi_slope(dev);
 		if ((phy->radio_ver == 0x2050) && (phy->radio_rev == 8)) {
@@ -3070,7 +3074,7 @@ static int b43_phy_versioning(struct b43
 			unsupported = 1;
 		break;
 	case B43_PHYTYPE_G:
-		if (phy_rev > 8)
+		if (phy_rev > 9)
 			unsupported = 1;
 		break;
 	default:
@@ -3217,13 +3221,13 @@ static void b43_bluetooth_coext_enable(s
 	struct ssb_sprom *sprom = &dev->dev->bus->sprom;
 	u32 hf;
 
-	if (!(sprom->r1.boardflags_lo & B43_BFL_BTCOEXIST))
+	if (!(sprom->boardflags_lo & B43_BFL_BTCOEXIST))
 		return;
 	if (dev->phy.type != B43_PHYTYPE_B && !dev->phy.gmode)
 		return;
 
 	hf = b43_hf_read(dev);
-	if (sprom->r1.boardflags_lo & B43_BFL_BTCMOD)
+	if (sprom->boardflags_lo & B43_BFL_BTCMOD)
 		hf |= B43_HF_BTCOEXALT;
 	else
 		hf |= B43_HF_BTCOEX;
@@ -3341,7 +3345,7 @@ static int b43_wireless_core_init(struct
 		hf |= B43_HF_SYMW;
 		if (phy->rev == 1)
 			hf |= B43_HF_GDCW;
-		if (sprom->r1.boardflags_lo & B43_BFL_PACTRL)
+		if (sprom->boardflags_lo & B43_BFL_PACTRL)
 			hf |= B43_HF_OFDMPABOOST;
 	} else if (phy->type == B43_PHYTYPE_B) {
 		hf |= B43_HF_SYMW;
@@ -3838,20 +3842,20 @@ static void b43_sprom_fixup(struct ssb_b
 	/* boardflags workarounds */
 	if (bus->boardinfo.vendor == SSB_BOARDVENDOR_DELL &&
 	    bus->chip_id == 0x4301 && bus->boardinfo.rev == 0x74)
-		bus->sprom.r1.boardflags_lo |= B43_BFL_BTCOEXIST;
+		bus->sprom.boardflags_lo |= B43_BFL_BTCOEXIST;
 	if (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE &&
 	    bus->boardinfo.type == 0x4E && bus->boardinfo.rev > 0x40)
-		bus->sprom.r1.boardflags_lo |= B43_BFL_PACTRL;
+		bus->sprom.boardflags_lo |= B43_BFL_PACTRL;
 
 	/* Handle case when gain is not set in sprom */
-	if (bus->sprom.r1.antenna_gain_a == 0xFF)
-		bus->sprom.r1.antenna_gain_a = 2;
-	if (bus->sprom.r1.antenna_gain_bg == 0xFF)
-		bus->sprom.r1.antenna_gain_bg = 2;
+	if (bus->sprom.antenna_gain_a == 0xFF)
+		bus->sprom.antenna_gain_a = 2;
+	if (bus->sprom.antenna_gain_bg == 0xFF)
+		bus->sprom.antenna_gain_bg = 2;
 
 	/* Convert Antennagain values to Q5.2 */
-	bus->sprom.r1.antenna_gain_a <<= 2;
-	bus->sprom.r1.antenna_gain_bg <<= 2;
+	bus->sprom.antenna_gain_a <<= 2;
+	bus->sprom.antenna_gain_bg <<= 2;
 }
 
 static void b43_wireless_exit(struct ssb_device *dev, struct b43_wl *wl)
@@ -3884,10 +3888,10 @@ static int b43_wireless_init(struct ssb_
 	hw->max_noise = -110;
 	hw->queues = 1;		/* FIXME: hardware has more queues */
 	SET_IEEE80211_DEV(hw, dev->dev);
-	if (is_valid_ether_addr(sprom->r1.et1mac))
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.et1mac);
+	if (is_valid_ether_addr(sprom->et1mac))
+		SET_IEEE80211_PERM_ADDR(hw, sprom->et1mac);
 	else
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.il0mac);
+		SET_IEEE80211_PERM_ADDR(hw, sprom->il0mac);
 
 	/* Get and initialize struct b43_wl */
 	wl = hw_to_b43_wl(hw);
Index: linux-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/phy.c
+++ linux-2.6/drivers/net/wireless/b43/phy.c
@@ -1139,7 +1139,7 @@ static void b43_phy_inita(struct b43_wld
 	} else {
 		b43_phy_setupg(dev);
 		if (phy->gmode &&
-		    (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL))
+		    (dev->dev->bus->sprom.boardflags_lo & B43_BFL_PACTRL))
 			b43_phy_write(dev, 0x046E, 0x03CF);
 		return;
 	}
@@ -1286,7 +1286,7 @@ static void b43_phy_initb4(struct b43_wl
 	if (phy->radio_ver == 0x2050)
 		b43_phy_write(dev, 0x002A, 0x88C2);
 	b43_set_txpower_g(dev, &phy->bbatt, &phy->rfatt, phy->tx_control);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI) {
 		b43_calc_nrssi_slope(dev);
 		b43_calc_nrssi_threshold(dev);
 	}
@@ -1433,7 +1433,7 @@ static void b43_phy_initb6(struct b43_wl
 		b43_radio_write16(dev, 0x5A, 0x88);
 		b43_radio_write16(dev, 0x5B, 0x6B);
 		b43_radio_write16(dev, 0x5C, 0x0F);
-		if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_ALTIQ) {
+		if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_ALTIQ) {
 			b43_radio_write16(dev, 0x5D, 0xFA);
 			b43_radio_write16(dev, 0x5E, 0xD8);
 		} else {
@@ -1525,7 +1525,7 @@ static void b43_phy_initb6(struct b43_wl
 		b43_phy_write(dev, 0x0062, 0x0007);
 		b43_radio_init2050(dev);
 		b43_lo_g_measure(dev);
-		if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI) {
+		if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI) {
 			b43_calc_nrssi_slope(dev);
 			b43_calc_nrssi_threshold(dev);
 		}
@@ -1645,7 +1645,7 @@ static void b43_calc_loopback_gain(struc
 	b43_phy_write(dev, B43_PHY_RFOVERVAL,
 		      b43_phy_read(dev, B43_PHY_RFOVERVAL) & 0xCFFF);
 
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_EXTLNA) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_EXTLNA) {
 		if (phy->rev >= 7) {
 			b43_phy_write(dev, B43_PHY_RFOVER,
 				      b43_phy_read(dev, B43_PHY_RFOVER)
@@ -1812,7 +1812,7 @@ static void b43_phy_initg(struct b43_wld
 				       & 0x0FFF) | (phy->lo_control->
 						    tx_bias << 12));
 		}
-		if (dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_PACTRL)
+		if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_PACTRL)
 			b43_phy_write(dev, B43_PHY_BASE(0x2E), 0x8075);
 		else
 			b43_phy_write(dev, B43_PHY_BASE(0x2E), 0x807F);
@@ -1826,7 +1826,7 @@ static void b43_phy_initg(struct b43_wld
 		b43_phy_write(dev, B43_PHY_LO_MASK, 0x8078);
 	}
 
-	if (!(dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI)) {
+	if (!(dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI)) {
 		/* The specs state to update the NRSSI LT with
 		 * the value 0x7FFFFFFF here. I think that is some weird
 		 * compiler optimization in the original driver.
@@ -2036,16 +2036,15 @@ void b43_phy_xmitpower(struct b43_wldev 
 			estimated_pwr =
 			    b43_phy_estimate_power_out(dev, average);
 
-			max_pwr = dev->dev->bus->sprom.r1.maxpwr_bg;
-			if ((dev->dev->bus->sprom.r1.
-			     boardflags_lo & B43_BFL_PACTRL)
-			    && (phy->type == B43_PHYTYPE_G))
+			max_pwr = dev->dev->bus->sprom.maxpwr_bg;
+			if ((dev->dev->bus->sprom.boardflags_lo
+			    & B43_BFL_PACTRL) && (phy->type == B43_PHYTYPE_G))
 				max_pwr -= 0x3;
 			if (unlikely(max_pwr <= 0)) {
 				b43warn(dev->wl,
 					"Invalid max-TX-power value in SPROM.\n");
 				max_pwr = 60;	/* fake it */
-				dev->dev->bus->sprom.r1.maxpwr_bg = max_pwr;
+				dev->dev->bus->sprom.maxpwr_bg = max_pwr;
 			}
 
 			/*TODO:
@@ -2103,7 +2102,7 @@ void b43_phy_xmitpower(struct b43_wldev 
 						    B43_TXCTL_TXMIX;
 						rfatt += 2;
 						bbatt += 2;
-					} else if (dev->dev->bus->sprom.r1.
+					} else if (dev->dev->bus->sprom.
 						   boardflags_lo &
 						   B43_BFL_PACTRL) {
 						bbatt += 4 * (rfatt - 2);
@@ -2179,13 +2178,13 @@ int b43_phy_init_tssi2dbm_table(struct b
 	s8 *dyn_tssi2dbm;
 
 	if (phy->type == B43_PHYTYPE_A) {
-		pab0 = (s16) (dev->dev->bus->sprom.r1.pa1b0);
-		pab1 = (s16) (dev->dev->bus->sprom.r1.pa1b1);
-		pab2 = (s16) (dev->dev->bus->sprom.r1.pa1b2);
+		pab0 = (s16) (dev->dev->bus->sprom.pa1b0);
+		pab1 = (s16) (dev->dev->bus->sprom.pa1b1);
+		pab2 = (s16) (dev->dev->bus->sprom.pa1b2);
 	} else {
-		pab0 = (s16) (dev->dev->bus->sprom.r1.pa0b0);
-		pab1 = (s16) (dev->dev->bus->sprom.r1.pa0b1);
-		pab2 = (s16) (dev->dev->bus->sprom.r1.pa0b2);
+		pab0 = (s16) (dev->dev->bus->sprom.pa0b0);
+		pab1 = (s16) (dev->dev->bus->sprom.pa0b1);
+		pab2 = (s16) (dev->dev->bus->sprom.pa0b2);
 	}
 
 	if ((dev->dev->bus->chip_id == 0x4301) && (phy->radio_ver != 0x2050)) {
@@ -2198,17 +2197,17 @@ int b43_phy_init_tssi2dbm_table(struct b
 	    pab0 != -1 && pab1 != -1 && pab2 != -1) {
 		/* The pabX values are set in SPROM. Use them. */
 		if (phy->type == B43_PHYTYPE_A) {
-			if ((s8) dev->dev->bus->sprom.r1.itssi_a != 0 &&
-			    (s8) dev->dev->bus->sprom.r1.itssi_a != -1)
+			if ((s8) dev->dev->bus->sprom.itssi_a != 0 &&
+			    (s8) dev->dev->bus->sprom.itssi_a != -1)
 				phy->tgt_idle_tssi =
-				    (s8) (dev->dev->bus->sprom.r1.itssi_a);
+				    (s8) (dev->dev->bus->sprom.itssi_a);
 			else
 				phy->tgt_idle_tssi = 62;
 		} else {
-			if ((s8) dev->dev->bus->sprom.r1.itssi_bg != 0 &&
-			    (s8) dev->dev->bus->sprom.r1.itssi_bg != -1)
+			if ((s8) dev->dev->bus->sprom.itssi_bg != 0 &&
+			    (s8) dev->dev->bus->sprom.itssi_bg != -1)
 				phy->tgt_idle_tssi =
-				    (s8) (dev->dev->bus->sprom.r1.itssi_bg);
+				    (s8) (dev->dev->bus->sprom.itssi_bg);
 			else
 				phy->tgt_idle_tssi = 62;
 		}
@@ -3114,7 +3113,7 @@ void b43_calc_nrssi_threshold(struct b43
 			if (phy->radio_ver != 0x2050)
 				return;
 			if (!
-			    (dev->dev->bus->sprom.r1.
+			    (dev->dev->bus->sprom.
 			     boardflags_lo & B43_BFL_RSSI))
 				return;
 
@@ -3145,7 +3144,7 @@ void b43_calc_nrssi_threshold(struct b43
 		}
 	case B43_PHYTYPE_G:
 		if (!phy->gmode ||
-		    !(dev->dev->bus->sprom.r1.boardflags_lo & B43_BFL_RSSI)) {
+		    !(dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI)) {
 			tmp16 = b43_nrssi_hw_read(dev, 0x20);
 			if (tmp16 >= 0x20)
 				tmp16 -= 0x40;
@@ -3667,7 +3666,7 @@ static u16 radio2050_rfover_val(struct b
 		}
 
 		if ((phy->rev < 7) ||
-		    !(sprom->r1.boardflags_lo & B43_BFL_EXTLNA)) {
+		    !(sprom->boardflags_lo & B43_BFL_EXTLNA)) {
 			if (phy_register == B43_PHY_RFOVER) {
 				return 0x1B3;
 			} else if (phy_register == B43_PHY_RFOVERVAL) {
@@ -3707,7 +3706,7 @@ static u16 radio2050_rfover_val(struct b
 		}
 	} else {
 		if ((phy->rev < 7) ||
-		    !(sprom->r1.boardflags_lo & B43_BFL_EXTLNA)) {
+		    !(sprom->boardflags_lo & B43_BFL_EXTLNA)) {
 			if (phy_register == B43_PHY_RFOVER) {
 				return 0x1B3;
 			} else if (phy_register == B43_PHY_RFOVERVAL) {
@@ -4186,7 +4185,7 @@ int b43_radio_selectchannel(struct b43_w
 		b43_write16(dev, B43_MMIO_CHANNEL, channel2freq_bg(channel));
 
 		if (channel == 14) {
-			if (dev->dev->bus->sprom.r1.country_code ==
+			if (dev->dev->bus->sprom.country_code ==
 			    SSB_SPROM1CCODE_JAPAN)
 				b43_hf_write(dev,
 					     b43_hf_read(dev) & ~B43_HF_ACPR);
Index: linux-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/xmit.c
+++ linux-2.6/drivers/net/wireless/b43/xmit.c
@@ -384,7 +384,7 @@ static s8 b43_rssi_postprocess(struct b4
 			else
 				tmp -= 3;
 		} else {
-			if (dev->dev->bus->sprom.r1.
+			if (dev->dev->bus->sprom.
 			    boardflags_lo & B43_BFL_RSSI) {
 				if (in_rssi > 63)
 					in_rssi = 63;
Index: linux-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/dma.c
+++ linux-2.6/drivers/net/wireless/b43/dma.c
@@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct 
 	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
 	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
 	    >> SSB_DMA_TRANSLATION_SHIFT;
-	addrhi |= ssb_dma_translation(ring->dev->dev);
+	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
 	if (slot == ring->nr_slots - 1)
 		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
 	if (start)
@@ -183,6 +183,8 @@ static void op64_fill_descriptor(struct 
 	desc->dma64.control1 = cpu_to_le32(ctl1);
 	desc->dma64.address_low = cpu_to_le32(addrlo);
 	desc->dma64.address_high = cpu_to_le32(addrhi);
+//	printk(KERN_INFO "b43: 64-bit descriptor - slot, address, ctrl0,"
+//		" ctrl1: %d 0x%.8X 0x%.8x 0x%.8X 0x%.8x\n", slot, addrhi, addrlo, ctl0, ctl1);
 }
 
 static void op64_poke_tx(struct b43_dmaring *ring, int slot)
@@ -289,6 +291,61 @@ static inline int request_slot(struct b4
 	return slot;
 }
 
+void b43_dump_dma_regs(struct b43_wldev *dev)
+{
+	struct b43_dmaring *ring;
+	u16 mmio_base;
+
+	ring = dev->dma.tx_ring0;
+	mmio_base = 0x200;
+	printk(KERN_INFO "b43: ring 0: TX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base), b43_read32(dev, mmio_base + 4), b43_read32(dev, mmio_base + 8),
+		b43_read32(dev, mmio_base + 12), b43_read32(dev, mmio_base + 16), b43_read32(dev, mmio_base + 20));	
+	printk(KERN_INFO "b43: ring 0: RX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base + 0x20), b43_read32(dev, mmio_base + 0x24), b43_read32(dev, mmio_base + 0x28),
+		b43_read32(dev, mmio_base + 0x2C), b43_read32(dev, mmio_base + 0x30), b43_read32(dev, mmio_base + 0x34));
+	ring = dev->dma.tx_ring1;
+	mmio_base = 0x240;
+	printk(KERN_INFO "b43: ring 1: TX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base), b43_read32(dev, mmio_base + 4), b43_read32(dev, mmio_base + 8),
+		b43_read32(dev, mmio_base + 12), b43_read32(dev, mmio_base + 16), b43_read32(dev, mmio_base + 20));	
+	printk(KERN_INFO "b43: ring 1: RX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base + 0x20), b43_read32(dev, mmio_base + 0x24), b43_read32(dev, mmio_base + 0x28),
+		b43_read32(dev, mmio_base + 0x2C), b43_read32(dev, mmio_base + 0x30), b43_read32(dev, mmio_base + 0x34));
+	ring = dev->dma.tx_ring2;
+	mmio_base = 0x280;
+	printk(KERN_INFO "b43: ring 2: TX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base), b43_read32(dev, mmio_base + 4), b43_read32(dev, mmio_base + 8),
+		b43_read32(dev, mmio_base + 12), b43_read32(dev, mmio_base + 16), b43_read32(dev, mmio_base + 20));	
+	printk(KERN_INFO "b43: ring 2: RX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base + 0x20), b43_read32(dev, mmio_base + 0x24), b43_read32(dev, mmio_base + 0x28),
+		b43_read32(dev, mmio_base + 0x2C), b43_read32(dev, mmio_base + 0x30), b43_read32(dev, mmio_base + 0x34));
+	ring = dev->dma.tx_ring3;
+	mmio_base = 0x2C0;
+	printk(KERN_INFO "b43: ring 3: TX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base), b43_read32(dev, mmio_base + 4), b43_read32(dev, mmio_base + 8),
+		b43_read32(dev, mmio_base + 12), b43_read32(dev, mmio_base + 16), b43_read32(dev, mmio_base + 20));	
+	printk(KERN_INFO "b43: ring 3: RX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base + 0x20), b43_read32(dev, mmio_base + 0x24), b43_read32(dev, mmio_base + 0x28),
+		b43_read32(dev, mmio_base + 0x2C), b43_read32(dev, mmio_base + 0x30), b43_read32(dev, mmio_base + 0x34));
+	ring = dev->dma.tx_ring4;
+	mmio_base = 0x300;
+	printk(KERN_INFO "b43: ring 4: TX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base), b43_read32(dev, mmio_base + 4), b43_read32(dev, mmio_base + 8),
+		b43_read32(dev, mmio_base + 12), b43_read32(dev, mmio_base + 16), b43_read32(dev, mmio_base + 20));	
+	printk(KERN_INFO "b43: ring 4: RX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base + 0x20), b43_read32(dev, mmio_base + 0x24), b43_read32(dev, mmio_base + 0x28),
+		b43_read32(dev, mmio_base + 0x2C), b43_read32(dev, mmio_base + 0x30), b43_read32(dev, mmio_base + 0x34));
+	ring = dev->dma.tx_ring5;
+	mmio_base = 0x340;
+	printk(KERN_INFO "b43: ring 5: TX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base), b43_read32(dev, mmio_base + 4), b43_read32(dev, mmio_base + 8),
+		b43_read32(dev, mmio_base + 12), b43_read32(dev, mmio_base + 16), b43_read32(dev, mmio_base + 20));	
+	printk(KERN_INFO "b43: ring 5: RX  0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X 0x%.8X\n",
+		b43_read32(dev, mmio_base + 0x20), b43_read32(dev, mmio_base + 0x24), b43_read32(dev, mmio_base + 0x28),
+		b43_read32(dev, mmio_base + 0x2C), b43_read32(dev, mmio_base + 0x30), b43_read32(dev, mmio_base + 0x34));
+}
+
 /* Mac80211-queue to b43-ring mapping */
 static struct b43_dmaring *priority_to_txring(struct b43_wldev *dev,
 					      int queue_priority)
@@ -426,14 +483,15 @@ static inline
 static int alloc_ringmemory(struct b43_dmaring *ring)
 {
 	struct device *dev = ring->dev->dev->dev;
+	int size = (ring->dma64) ? 8192 : B43_DMA_RINGMEMSIZE;
 
-	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
+	ring->descbase = dma_alloc_coherent(dev, size,
 					    &(ring->dmabase), GFP_KERNEL);
 	if (!ring->descbase) {
 		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
 		return -ENOMEM;
 	}
-	memset(ring->descbase, 0, B43_DMA_RINGMEMSIZE);
+	memset(ring->descbase, 0, size);
 
 	return 0;
 }
@@ -441,8 +499,9 @@ static int alloc_ringmemory(struct b43_d
 static void free_ringmemory(struct b43_dmaring *ring)
 {
 	struct device *dev = ring->dev->dev->dev;
+	int size = (ring->dma64) ? 8192 : B43_DMA_RINGMEMSIZE;
 
-	dma_free_coherent(dev, B43_DMA_RINGMEMSIZE,
+	dma_free_coherent(dev, size,
 			  ring->descbase, ring->dmabase);
 }
 
@@ -483,7 +542,7 @@ int b43_dmacontroller_rx_reset(struct b4
 	return 0;
 }
 
-/* Reset the RX DMA channel */
+/* Reset the TX DMA channel */
 int b43_dmacontroller_tx_reset(struct b43_wldev *dev, u16 mmio_base, int dma64)
 {
 	int i;
@@ -636,18 +695,12 @@ static int dmacontroller_setup(struct b4
 		if (ring->dma64) {
 			u64 ringbase = (u64) (ring->dmabase);
 
-			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
-			    >> SSB_DMA_TRANSLATION_SHIFT;
-			value = B43_DMA64_TXENABLE;
-			value |= (addrext << B43_DMA64_TXADDREXT_SHIFT)
-			    & B43_DMA64_TXADDREXT_MASK;
-			b43_dma_write(ring, B43_DMA64_TXCTL, value);
+			b43_dma_write(ring, B43_DMA64_TXCTL,
+				      B43_DMA64_TXENABLE);
 			b43_dma_write(ring, B43_DMA64_TXRINGLO,
 				      (ringbase & 0xFFFFFFFF));
 			b43_dma_write(ring, B43_DMA64_TXRINGHI,
-				      ((ringbase >> 32) &
-				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
+				      (ringbase >> 32));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -668,20 +721,15 @@ static int dmacontroller_setup(struct b4
 		if (ring->dma64) {
 			u64 ringbase = (u64) (ring->dmabase);
 
-			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
-			    >> SSB_DMA_TRANSLATION_SHIFT;
-			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT);
-			value |= B43_DMA64_RXENABLE;
-			value |= (addrext << B43_DMA64_RXADDREXT_SHIFT)
-			    & B43_DMA64_RXADDREXT_MASK;
+			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT)
+				| B43_DMA64_RXENABLE;
 			b43_dma_write(ring, B43_DMA64_RXCTL, value);
 			b43_dma_write(ring, B43_DMA64_RXRINGLO,
 				      (ringbase & 0xFFFFFFFF));
 			b43_dma_write(ring, B43_DMA64_RXRINGHI,
-				      ((ringbase >> 32) &
-				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
-			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
+				      (ringbase >> 32));
+			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc64));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -695,11 +743,12 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA32_RXRING,
 				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
 				      | trans);
-			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
+			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc32));
 		}
 	}
 
-      out:
+out:
 	return err;
 }
 
Index: linux-2.6/drivers/net/wireless/b43legacy/leds.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43legacy/leds.c
+++ linux-2.6/drivers/net/wireless/b43legacy/leds.c
@@ -134,10 +134,10 @@ int b43legacy_leds_init(struct b43legacy
 	u8 sprom[4];
 	int i;
 
-	sprom[0] = dev->dev->bus->sprom.r1.gpio0;
-	sprom[1] = dev->dev->bus->sprom.r1.gpio1;
-	sprom[2] = dev->dev->bus->sprom.r1.gpio2;
-	sprom[3] = dev->dev->bus->sprom.r1.gpio3;
+	sprom[0] = dev->dev->bus->sprom.gpio0;
+	sprom[1] = dev->dev->bus->sprom.gpio1;
+	sprom[2] = dev->dev->bus->sprom.gpio2;
+	sprom[3] = dev->dev->bus->sprom.gpio3;
 
 	for (i = 0; i < B43legacy_NR_LEDS; i++) {
 		led = &(dev->leds[i]);
Index: linux-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ linux-2.6/drivers/net/wireless/b43legacy/main.c
@@ -1767,7 +1767,7 @@ static int b43legacy_gpio_init(struct b4
 		mask |= 0x0060;
 		set |= 0x0060;
 	}
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_PACTRL) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_PACTRL) {
 		b43legacy_write16(dev, B43legacy_MMIO_GPIO_MASK,
 				  b43legacy_read16(dev,
 				  B43legacy_MMIO_GPIO_MASK)
@@ -2140,7 +2140,7 @@ static void b43legacy_periodic_every120s
 static void b43legacy_periodic_every60sec(struct b43legacy_wldev *dev)
 {
 	b43legacy_phy_lo_mark_all_unused(dev);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_RSSI) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_RSSI) {
 		b43legacy_mac_suspend(dev);
 		b43legacy_calc_nrssi_slope(dev);
 		b43legacy_mac_enable(dev);
@@ -3153,7 +3153,7 @@ static int b43legacy_wireless_core_init(
 		hf |= B43legacy_HF_SYMW;
 		if (phy->rev == 1)
 			hf |= B43legacy_HF_GDCW;
-		if (sprom->r1.boardflags_lo & B43legacy_BFL_PACTRL)
+		if (sprom->boardflags_lo & B43legacy_BFL_PACTRL)
 			hf |= B43legacy_HF_OFDMPABOOST;
 	} else if (phy->type == B43legacy_PHYTYPE_B) {
 		hf |= B43legacy_HF_SYMW;
@@ -3637,12 +3637,12 @@ static void b43legacy_sprom_fixup(struct
 	if (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE &&
 	    bus->boardinfo.type == 0x4E &&
 	    bus->boardinfo.rev > 0x40)
-		bus->sprom.r1.boardflags_lo |= B43legacy_BFL_PACTRL;
+		bus->sprom.boardflags_lo |= B43legacy_BFL_PACTRL;
 
 	/* Convert Antennagain values to Q5.2 */
-	if (bus->sprom.r1.antenna_gain_bg == 0xFF)
-		bus->sprom.r1.antenna_gain_bg = 2; /* if unset, use 2 dBm */
-	bus->sprom.r1.antenna_gain_bg <<= 2;
+	if (bus->sprom.antenna_gain_bg == 0xFF)
+		bus->sprom.antenna_gain_bg = 2; /* if unset, use 2 dBm */
+	bus->sprom.antenna_gain_bg <<= 2;
 }
 
 static void b43legacy_wireless_exit(struct ssb_device *dev,
@@ -3677,10 +3677,10 @@ static int b43legacy_wireless_init(struc
 	hw->max_noise = -110;
 	hw->queues = 1; /* FIXME: hardware has more queues */
 	SET_IEEE80211_DEV(hw, dev->dev);
-	if (is_valid_ether_addr(sprom->r1.et1mac))
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.et1mac);
+	if (is_valid_ether_addr(sprom->et1mac))
+		SET_IEEE80211_PERM_ADDR(hw, sprom->et1mac);
 	else
-		SET_IEEE80211_PERM_ADDR(hw, sprom->r1.il0mac);
+		SET_IEEE80211_PERM_ADDR(hw, sprom->il0mac);
 
 	/* Get and initialize struct b43legacy_wl */
 	wl = hw_to_b43legacy_wl(hw);
Index: linux-2.6/drivers/net/wireless/b43legacy/phy.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43legacy/phy.c
+++ linux-2.6/drivers/net/wireless/b43legacy/phy.c
@@ -441,7 +441,7 @@ static void b43legacy_phy_inita(struct b
 	might_sleep();
 
 	b43legacy_phy_setupg(dev);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_PACTRL)
+	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_PACTRL)
 		b43legacy_phy_write(dev, 0x046E, 0x03CF);
 }
 
@@ -543,7 +543,7 @@ static void b43legacy_phy_initb4(struct 
 	if (phy->radio_ver == 0x2050)
 		b43legacy_phy_write(dev, 0x002A, 0x88C2);
 	b43legacy_radio_set_txpower_bg(dev, 0xFFFF, 0xFFFF, 0xFFFF);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_RSSI) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_RSSI) {
 		b43legacy_calc_nrssi_slope(dev);
 		b43legacy_calc_nrssi_threshold(dev);
 	}
@@ -699,7 +699,7 @@ static void b43legacy_phy_initb6(struct 
 		b43legacy_radio_write16(dev, 0x005A, 0x0088);
 		b43legacy_radio_write16(dev, 0x005B, 0x006B);
 		b43legacy_radio_write16(dev, 0x005C, 0x000F);
-		if (dev->dev->bus->sprom.r1.boardflags_lo & 0x8000) {
+		if (dev->dev->bus->sprom.boardflags_lo & 0x8000) {
 			b43legacy_radio_write16(dev, 0x005D, 0x00FA);
 			b43legacy_radio_write16(dev, 0x005E, 0x00D8);
 		} else {
@@ -797,7 +797,7 @@ static void b43legacy_phy_initb6(struct 
 		b43legacy_phy_write(dev, 0x0062, 0x0007);
 		b43legacy_radio_init2050(dev);
 		b43legacy_phy_lo_g_measure(dev);
-		if (dev->dev->bus->sprom.r1.boardflags_lo &
+		if (dev->dev->bus->sprom.boardflags_lo &
 		    B43legacy_BFL_RSSI) {
 			b43legacy_calc_nrssi_slope(dev);
 			b43legacy_calc_nrssi_threshold(dev);
@@ -921,7 +921,7 @@ static void b43legacy_calc_loopback_gain
 			    b43legacy_phy_read(dev, 0x0811) | 0x0100);
 	b43legacy_phy_write(dev, 0x0812,
 			    b43legacy_phy_read(dev, 0x0812) & 0xCFFF);
-	if (dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_EXTLNA) {
+	if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_EXTLNA) {
 		if (phy->rev >= 7) {
 			b43legacy_phy_write(dev, 0x0811,
 					    b43legacy_phy_read(dev, 0x0811)
@@ -1072,7 +1072,7 @@ static void b43legacy_phy_initg(struct b
 			b43legacy_phy_write(dev, 0x0036,
 					    (b43legacy_phy_read(dev, 0x0036)
 					     & 0x0FFF) | (phy->txctl2 << 12));
-		if (dev->dev->bus->sprom.r1.boardflags_lo &
+		if (dev->dev->bus->sprom.boardflags_lo &
 		    B43legacy_BFL_PACTRL)
 			b43legacy_phy_write(dev, 0x002E, 0x8075);
 		else
@@ -1087,7 +1087,7 @@ static void b43legacy_phy_initg(struct b
 		b43legacy_phy_write(dev, 0x080F, 0x8078);
 	}
 
-	if (!(dev->dev->bus->sprom.r1.boardflags_lo & B43legacy_BFL_RSSI)) {
+	if (!(dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_RSSI)) {
 		/* The specs state to update the NRSSI LT with
 		 * the value 0x7FFFFFFF here. I think that is some weird
 		 * compiler optimization in the original driver.
@@ -1838,9 +1838,9 @@ void b43legacy_phy_xmitpower(struct b43l
 
 	estimated_pwr = b43legacy_phy_estimate_power_out(dev, average);
 
-	max_pwr = dev->dev->bus->sprom.r1.maxpwr_bg;
+	max_pwr = dev->dev->bus->sprom.maxpwr_bg;
 
-	if ((dev->dev->bus->sprom.r1.boardflags_lo
+	if ((dev->dev->bus->sprom.boardflags_lo
 	     & B43legacy_BFL_PACTRL) &&
 	    (phy->type == B43legacy_PHYTYPE_G))
 		max_pwr -= 0x3;
@@ -1848,7 +1848,7 @@ void b43legacy_phy_xmitpower(struct b43l
 		b43legacywarn(dev->wl, "Invalid max-TX-power value in SPROM."
 			"\n");
 		max_pwr = 74; /* fake it */
-		dev->dev->bus->sprom.r1.maxpwr_bg = max_pwr;
+		dev->dev->bus->sprom.maxpwr_bg = max_pwr;
 	}
 
 	/* Use regulatory information to get the maximum power.
@@ -1858,7 +1858,7 @@ void b43legacy_phy_xmitpower(struct b43l
 	 * and 1.5 dBm (a safety factor??). The result is in Q5.2 format
 	 * which accounts for the factor of 4 */
 #define REG_MAX_PWR 20
-	max_pwr = min(REG_MAX_PWR * 4 - dev->dev->bus->sprom.r1.antenna_gain_bg
+	max_pwr = min(REG_MAX_PWR * 4 - dev->dev->bus->sprom.antenna_gain_bg
 		      - 0x6, max_pwr);
 
 	/* find the desired power in Q5.2 - power_level is in dBm
@@ -1918,7 +1918,7 @@ void b43legacy_phy_xmitpower(struct b43l
 				txpower = 3;
 				radio_attenuation += 2;
 				baseband_attenuation += 2;
-			} else if (dev->dev->bus->sprom.r1.boardflags_lo
+			} else if (dev->dev->bus->sprom.boardflags_lo
 				   & B43legacy_BFL_PACTRL) {
 				baseband_attenuation += 4 *
 						     (radio_attenuation - 2);
@@ -2000,9 +2000,9 @@ int b43legacy_phy_init_tssi2dbm_table(st
 
 	B43legacy_WARN_ON(!(phy->type == B43legacy_PHYTYPE_B ||
 			  phy->type == B43legacy_PHYTYPE_G));
-	pab0 = (s16)(dev->dev->bus->sprom.r1.pa0b0);
-	pab1 = (s16)(dev->dev->bus->sprom.r1.pa0b1);
-	pab2 = (s16)(dev->dev->bus->sprom.r1.pa0b2);
+	pab0 = (s16)(dev->dev->bus->sprom.pa0b0);
+	pab1 = (s16)(dev->dev->bus->sprom.pa0b1);
+	pab2 = (s16)(dev->dev->bus->sprom.pa0b2);
 
 	if ((dev->dev->bus->chip_id == 0x4301) && (phy->radio_ver != 0x2050)) {
 		phy->idle_tssi = 0x34;
@@ -2013,9 +2013,9 @@ int b43legacy_phy_init_tssi2dbm_table(st
 	if (pab0 != 0 && pab1 != 0 && pab2 != 0 &&
 	    pab0 != -1 && pab1 != -1 && pab2 != -1) {
 		/* The pabX values are set in SPROM. Use them. */
-		if ((s8)dev->dev->bus->sprom.r1.itssi_bg != 0 &&
-		    (s8)dev->dev->bus->sprom.r1.itssi_bg != -1)
-			phy->idle_tssi = (s8)(dev->dev->bus->sprom.r1.itssi_bg);
+		if ((s8)dev->dev->bus->sprom.itssi_bg != 0 &&
+		    (s8)dev->dev->bus->sprom.itssi_bg != -1)
+			phy->idle_tssi = (s8)(dev->dev->bus->sprom.itssi_bg);
 		else
 			phy->idle_tssi = 62;
 		dyn_tssi2dbm = kmalloc(64, GFP_KERNEL);
Index: linux-2.6/drivers/net/wireless/b43legacy/radio.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43legacy/radio.c
+++ linux-2.6/drivers/net/wireless/b43legacy/radio.c
@@ -827,7 +827,7 @@ void b43legacy_calc_nrssi_threshold(stru
 	case B43legacy_PHYTYPE_B: {
 		if (phy->radio_ver != 0x2050)
 			return;
-		if (!(dev->dev->bus->sprom.r1.boardflags_lo &
+		if (!(dev->dev->bus->sprom.boardflags_lo &
 		    B43legacy_BFL_RSSI))
 			return;
 
@@ -857,7 +857,7 @@ void b43legacy_calc_nrssi_threshold(stru
 	}
 	case B43legacy_PHYTYPE_G:
 		if (!phy->gmode ||
-		    !(dev->dev->bus->sprom.r1.boardflags_lo &
+		    !(dev->dev->bus->sprom.boardflags_lo &
 		    B43legacy_BFL_RSSI)) {
 			tmp16 = b43legacy_nrssi_hw_read(dev, 0x20);
 			if (tmp16 >= 0x20)
@@ -1406,7 +1406,7 @@ static u16 b43legacy_get_812_value(struc
 	if (!phy->gmode)
 		return 0;
 	if (!has_loopback_gain(phy)) {
-		if (phy->rev < 7 || !(dev->dev->bus->sprom.r1.boardflags_lo
+		if (phy->rev < 7 || !(dev->dev->bus->sprom.boardflags_lo
 		    & B43legacy_BFL_EXTLNA)) {
 			switch (lpd) {
 			case LPD(0, 1, 1):
@@ -1459,7 +1459,7 @@ static u16 b43legacy_get_812_value(struc
 		}
 
 		loop_or = (loop << 8) | extern_lna_control;
-		if (phy->rev >= 7 && dev->dev->bus->sprom.r1.boardflags_lo
+		if (phy->rev >= 7 && dev->dev->bus->sprom.boardflags_lo
 		    & B43legacy_BFL_EXTLNA) {
 			if (extern_lna_control)
 				loop_or |= 0x8000;
@@ -1550,7 +1550,7 @@ u16 b43legacy_radio_init2050(struct b43l
 					    b43legacy_get_812_value(dev,
 					    LPD(0, 1, 1)));
 			if (phy->rev < 7 ||
-			    !(dev->dev->bus->sprom.r1.boardflags_lo
+			    !(dev->dev->bus->sprom.boardflags_lo
 			    & B43legacy_BFL_EXTLNA))
 				b43legacy_phy_write(dev, 0x0811, 0x01B3);
 			else
@@ -1786,7 +1786,7 @@ int b43legacy_radio_selectchannel(struct
 			  channel2freq_bg(channel));
 
 	if (channel == 14) {
-		if (dev->dev->bus->sprom.r1.country_code == 5)   /* JAPAN) */
+		if (dev->dev->bus->sprom.country_code == 5)   /* JAPAN) */
 			b43legacy_shm_write32(dev, B43legacy_SHM_SHARED,
 					      B43legacy_UCODEFLAGS_OFFSET,
 					      b43legacy_shm_read32(dev,
Index: linux-2.6/drivers/net/wireless/b43legacy/xmit.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43legacy/xmit.c
+++ linux-2.6/drivers/net/wireless/b43legacy/xmit.c
@@ -378,7 +378,7 @@ static s8 b43legacy_rssi_postprocess(str
 			else
 				tmp -= 3;
 		} else {
-			if (dev->dev->bus->sprom.r1.boardflags_lo
+			if (dev->dev->bus->sprom.boardflags_lo
 			    & B43legacy_BFL_RSSI) {
 				if (in_rssi > 63)
 					in_rssi = 63;



From larry.finger at lwfinger.net  Tue Nov 20 05:46:28 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 19 Nov 2007 22:46:28 -0600
Subject: [Bug 9414] Not work light of button-led with module b43 in chipset
	broadcom 4318
In-Reply-To: <20071120043402.8BDBB10806E@picon.linux-foundation.org>
References: <20071120043402.8BDBB10806E@picon.linux-foundation.org>
Message-ID: <474266A4.2000301@lwfinger.net>

bugme-daemon at bugzilla.kernel.org wrote:
> http://bugzilla.kernel.org/show_bug.cgi?id=9414
> 
> 
> caravena at gmail.com changed:
> 
>            What    |Removed                     |Added
> ----------------------------------------------------------------------------
>                  CC|                            |Larry.Finger at lwfinger.net

Michael,

Just like this guy, the light on my wireless switch does not work, and has not since the rfkill
logic was changed. I have been too busy to complain; however, the issue needs to ba addressed.

How does one supply the necessary information so that the light will be changed as the switch is moved?

Larry



From ftoledo at docksud.com.ar  Tue Nov 20 06:22:03 2007
From: ftoledo at docksud.com.ar (Fernando Toledo)
Date: Tue, 20 Nov 2007 02:22:03 -0300
Subject: [Bug 9414] Not work light of button-led with module b43 in
	chipset broadcom 4318
In-Reply-To: <474266A4.2000301@lwfinger.net>
References: <20071120043402.8BDBB10806E@picon.linux-foundation.org>
	<474266A4.2000301@lwfinger.net>
Message-ID: <200711200222.04098.ftoledo@docksud.com.ar>

El Mar 20 Nov 2007, Larry Finger escribi?:
> bugme-daemon at bugzilla.kernel.org wrote:
> > http://bugzilla.kernel.org/show_bug.cgi?id=9414
> >
> >
> > caravena at gmail.com changed:
> >
> >            What    |Removed                     |Added
> > -------------------------------------------------------------------------
> >--- CC|                            |Larry.Finger at lwfinger.net
>
> Michael,
>
> Just like this guy, the light on my wireless switch does not work, and has
> not since the rfkill logic was changed. I have been too busy to complain;
> however, the issue needs to ba addressed.
>
> How does one supply the necessary information so that the light will be
> changed as the switch is moved?
>
> Larry
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev

i can confirm this bug too.
i have a 4311 chipset

10:00.0 Network controller: Broadcom Corporation BCM94311MCG wlan mini-PCI 
(rev 01)

i dont see the led on and the radio button dont show the old message "Radio 
button switched on/off" in the dmesg.



-- 
Dock Sud BBS
http://www.docksud.com.ar
telnet://bbs.docksud.com.ar
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part.
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071120/c4906712/attachment.pgp>

From schwab at suse.de  Tue Nov 20 10:58:49 2007
From: schwab at suse.de (Andreas Schwab)
Date: Tue, 20 Nov 2007 10:58:49 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <20071120011549.6b04bb4d@morte> (Stefano Brivio's message of
	"Tue\, 20 Nov 2007 01\:15\:49 +0100")
References: <20071119202121.6ad3fa70@morte> <200711192300.12183.rjw@sisk.pl>
	<20071119231935.535674ba@morte> <jehcjheubn.fsf@sykes.suse.de>
	<20071120001329.3524494a@morte> <jed4u5esbo.fsf@sykes.suse.de>
	<20071120011549.6b04bb4d@morte>
Message-ID: <jeir3xdyqu.fsf@sykes.suse.de>

Stefano Brivio <stefano.brivio at polimi.it> writes:

> --- drivers/net/wireless/b43/main.c.orig        2007-11-20 01:12:12.186524483 +0100
> +++ drivers/net/wireless/b43/main.c     2007-11-20 01:12:34.922702865 +0100
> @@ -947,7 +947,7 @@
>
>         while (1) {
>                 v0 = b43_read32(dev, B43_MMIO_XMITSTAT_0);
> -               if (!(v0 & 0x00000001))
> +               if (!v0)
>                         break;
>                 v1 = b43_read32(dev, B43_MMIO_XMITSTAT_1);
>
> (probably it's not the solution, I just want to see what happens then).

That didn't change anything.

> BTW, what firmware are you using?

It's 410.2160 from wl_ap.o.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From gaudenz at soziologie.ch  Tue Nov 20 10:39:19 2007
From: gaudenz at soziologie.ch (Gaudenz Steinlin)
Date: Tue, 20 Nov 2007 10:39:19 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <jehcjheubn.fsf@sykes.suse.de>
References: <20071119202121.6ad3fa70@morte> <200711192300.12183.rjw@sisk.pl>
	<20071119231935.535674ba@morte> <jehcjheubn.fsf@sykes.suse.de>
Message-ID: <20071120093919.GI5569@soziologie.ch>

On Mon, Nov 19, 2007 at 11:36:44PM +0100, Andreas Schwab wrote:
> Stefano Brivio <stefano.brivio at polimi.it> writes:
> 
> > On Mon, 19 Nov 2007 23:00:11 +0100
> > "Rafael J. Wysocki" <rjw at sisk.pl> wrote:
> >
> >> Well, are you 100% sure that everyone interested knows that this drivers
> >> is going out in 2.6.25 and no one will object?
> >
> > The maintainers know. Having both drivers in 2.6.24 should help find out if
> > there's anything which should be ironed out with b43/b43legacy, but right
> > now they are already working a lot better than bcm43xx, and they are more
> > stable. So I couldn't find a reason why we shouldn't remove bcm43xx in
> > 2.6.25.
> 
> b43 still does not work at all on ppc.

I use b43 on ppc (wireless-2.6/everything from when 2.6.23 was released)
and it works better than b43xx ever did. This is on a powerbook 5,8 with
this card:
b43-phy3: Broadcom 4318 WLAN found
b43-phy3 debug: Found PHY: Analog 3, Type 2, Revision 7
b43-phy3 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 8

Gaudenz




From schwab at suse.de  Tue Nov 20 13:08:05 2007
From: schwab at suse.de (Andreas Schwab)
Date: Tue, 20 Nov 2007 13:08:05 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <20071120093919.GI5569@soziologie.ch> (Gaudenz Steinlin's message
	of "Tue\, 20 Nov 2007 10\:39\:19 +0100")
References: <20071119202121.6ad3fa70@morte> <200711192300.12183.rjw@sisk.pl>
	<20071119231935.535674ba@morte> <jehcjheubn.fsf@sykes.suse.de>
	<20071120093919.GI5569@soziologie.ch>
Message-ID: <je8x4tdsre.fsf@sykes.suse.de>

Gaudenz Steinlin <gaudenz at soziologie.ch> writes:

> I use b43 on ppc (wireless-2.6/everything from when 2.6.23 was released)
> and it works better than b43xx ever did. This is on a powerbook 5,8 with
> this card:
> b43-phy3: Broadcom 4318 WLAN found
> b43-phy3 debug: Found PHY: Analog 3, Type 2, Revision 7
> b43-phy3 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 8

Mine is the same card, but in a PowerBook6,7.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From johannes at sipsolutions.net  Tue Nov 20 14:17:18 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 20 Nov 2007 14:17:18 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <jehcjheubn.fsf@sykes.suse.de>
	(sfid-20071119_223649_028329_2561B167)
References: <20071119202121.6ad3fa70@morte> <200711192300.12183.rjw@sisk.pl>
	<20071119231935.535674ba@morte>  <jehcjheubn.fsf@sykes.suse.de>
	(sfid-20071119_223649_028329_2561B167)
Message-ID: <1195564638.10920.15.camel@johannes.berg>


> > The maintainers know. Having both drivers in 2.6.24 should help find out if
> > there's anything which should be ironed out with b43/b43legacy, but right
> > now they are already working a lot better than bcm43xx, and they are more
> > stable. So I couldn't find a reason why we shouldn't remove bcm43xx in
> > 2.6.25.
> 
> b43 still does not work at all on ppc.

That's completely false.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071120/0f44eda8/attachment.pgp>

From johannes at sipsolutions.net  Tue Nov 20 14:18:42 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 20 Nov 2007 14:18:42 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <200711192357.44407.rjw@sisk.pl>
	(sfid-20071119_224049_686469_3D7B65CA)
References: <20071119202121.6ad3fa70@morte> <200711192300.12183.rjw@sisk.pl>
	<20071119231935.535674ba@morte>  <200711192357.44407.rjw@sisk.pl>
	(sfid-20071119_224049_686469_3D7B65CA)
Message-ID: <1195564722.10920.17.camel@johannes.berg>


> Many people use the old driver and you are forcing them to switch in a rather
> unfriendly fashion.

> IMvHO, the schedule of the removal of this driver should be discussed on LKML.

We can post a patch to orphan it and then ignore it. We actually prefer
to remove it so people use b43 and we can fix any issues they had.

Face it, nobody is willing to maintain this old thing any more.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071120/abf299ea/attachment.pgp>

From mb at bu3sch.de  Tue Nov 20 15:07:46 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 20 Nov 2007 15:07:46 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <jehcjheubn.fsf@sykes.suse.de>
References: <20071119202121.6ad3fa70@morte> <20071119231935.535674ba@morte>
	<jehcjheubn.fsf@sykes.suse.de>
Message-ID: <200711201507.46998.mb@bu3sch.de>

On Monday 19 November 2007 23:36:44 Andreas Schwab wrote:
> b43 still does not work at all on ppc.

This is absolutely _wrong_.


-- 
Greetings Michael.


From mb at bu3sch.de  Tue Nov 20 15:09:55 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 20 Nov 2007 15:09:55 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <200711192357.44407.rjw@sisk.pl>
References: <20071119202121.6ad3fa70@morte> <20071119231935.535674ba@morte>
	<200711192357.44407.rjw@sisk.pl>
Message-ID: <200711201509.55763.mb@bu3sch.de>

On Monday 19 November 2007 23:57:43 Rafael J. Wysocki wrote:
> > Having both drivers in 2.6.24 should help find out if 
> > there's anything which should be ironed out with b43/b43legacy, but right
> > now they are already working a lot better than bcm43xx, and they are more
> > stable. So I couldn't find a reason why we shouldn't remove bcm43xx in
> > 2.6.25.
> 
> Many people use the old driver and you are forcing them to switch in a rather
> unfriendly fashion.
> 
> Moreover, the switch generally involves a configuration change (on my system
> eth1 became wlan0) and is not _that_ seamless.
> 
> IMvHO, the schedule of the removal of this driver should be discussed on LKML.

Ok, so we are going to add Rafael J. Wysocki as the bcm43xx maintainer
and remove everyone else. I'm OK with that.

It is known for over a year now that b43 (aka bcm43xx-mac80211) is going to
replace bcm43xx. And we already do a parrallel release cycle with both drivers
included so people can switch. What else do you want?

-- 
Greetings Michael.


From schwab at suse.de  Tue Nov 20 15:11:07 2007
From: schwab at suse.de (Andreas Schwab)
Date: Tue, 20 Nov 2007 15:11:07 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <200711201507.46998.mb@bu3sch.de> (Michael Buesch's message of
	"Tue\, 20 Nov 2007 15\:07\:46 +0100")
References: <20071119202121.6ad3fa70@morte> <20071119231935.535674ba@morte>
	<jehcjheubn.fsf@sykes.suse.de> <200711201507.46998.mb@bu3sch.de>
Message-ID: <je4pfhdn2c.fsf@sykes.suse.de>

Michael Buesch <mb at bu3sch.de> writes:

> On Monday 19 November 2007 23:36:44 Andreas Schwab wrote:
>> b43 still does not work at all on ppc.
>
> This is absolutely _wrong_.

Of course it is wrong, but apparently the only way to get attention to a
blocker bug.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From mb at bu3sch.de  Tue Nov 20 15:13:47 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 20 Nov 2007 15:13:47 +0100
Subject: [Bug 9414] Not work light of button-led with module b43 in
	chipset broadcom 4318
In-Reply-To: <474266A4.2000301@lwfinger.net>
References: <20071120043402.8BDBB10806E@picon.linux-foundation.org>
	<474266A4.2000301@lwfinger.net>
Message-ID: <200711201513.47625.mb@bu3sch.de>

On Tuesday 20 November 2007 05:46:28 Larry Finger wrote:
> bugme-daemon at bugzilla.kernel.org wrote:
> > http://bugzilla.kernel.org/show_bug.cgi?id=9414
> > 
> > 
> > caravena at gmail.com changed:
> > 
> >            What    |Removed                     |Added
> > ----------------------------------------------------------------------------
> >                  CC|                            |Larry.Finger at lwfinger.net
> 
> Michael,
> 
> Just like this guy, the light on my wireless switch does not work, and has not since the rfkill
> logic was changed. I have been too busy to complain; however, the issue needs to ba addressed.
> 
> How does one supply the necessary information so that the light will be changed as the switch is moved?

I don't know. You must tell me what kind of LED this is.
There is a LED trigger in rfkill. You just have to hook that up
to the LED.


-- 
Greetings Michael.


From mb at bu3sch.de  Tue Nov 20 15:20:05 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 20 Nov 2007 15:20:05 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <je4pfhdn2c.fsf@sykes.suse.de>
References: <20071119202121.6ad3fa70@morte> <200711201507.46998.mb@bu3sch.de>
	<je4pfhdn2c.fsf@sykes.suse.de>
Message-ID: <200711201520.05718.mb@bu3sch.de>

On Tuesday 20 November 2007 15:11:07 Andreas Schwab wrote:
> Michael Buesch <mb at bu3sch.de> writes:
> 
> > On Monday 19 November 2007 23:36:44 Andreas Schwab wrote:
> >> b43 still does not work at all on ppc.
> >
> > This is absolutely _wrong_.
> 
> Of course it is wrong, but apparently the only way to get attention to a
> blocker bug.

I didn't hear about your bug before.

Are you using latest driver from wireless-2.6 and the officially
supported firmware version from
http://www.linuxwireless.org/en/users/Drivers/b43

-- 
Greetings Michael.


From schwab at suse.de  Tue Nov 20 15:24:23 2007
From: schwab at suse.de (Andreas Schwab)
Date: Tue, 20 Nov 2007 15:24:23 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <200711201520.05718.mb@bu3sch.de> (Michael Buesch's message of
	"Tue\, 20 Nov 2007 15\:20\:05 +0100")
References: <20071119202121.6ad3fa70@morte> <200711201507.46998.mb@bu3sch.de>
	<je4pfhdn2c.fsf@sykes.suse.de> <200711201520.05718.mb@bu3sch.de>
Message-ID: <jezlx9c7vs.fsf@sykes.suse.de>

Michael Buesch <mb at bu3sch.de> writes:

> Are you using latest driver from wireless-2.6 and the officially
> supported firmware version from
> http://www.linuxwireless.org/en/users/Drivers/b43

Please see the other mails in the thread.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From schwab at suse.de  Tue Nov 20 15:47:53 2007
From: schwab at suse.de (Andreas Schwab)
Date: Tue, 20 Nov 2007 15:47:53 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <200711201520.05718.mb@bu3sch.de> (Michael Buesch's message of
	"Tue\, 20 Nov 2007 15\:20\:05 +0100")
References: <20071119202121.6ad3fa70@morte> <200711201507.46998.mb@bu3sch.de>
	<je4pfhdn2c.fsf@sykes.suse.de> <200711201520.05718.mb@bu3sch.de>
Message-ID: <jeve7xc6sm.fsf@sykes.suse.de>

Michael Buesch <mb at bu3sch.de> writes:

> On Tuesday 20 November 2007 15:11:07 Andreas Schwab wrote:
>> Michael Buesch <mb at bu3sch.de> writes:
>> 
>> > On Monday 19 November 2007 23:36:44 Andreas Schwab wrote:
>> >> b43 still does not work at all on ppc.
>> >
>> > This is absolutely _wrong_.
>> 
>> Of course it is wrong, but apparently the only way to get attention to a
>> blocker bug.
>
> I didn't hear about your bug before.
>
> Are you using latest driver from wireless-2.6 and the officially
> supported firmware version from
> http://www.linuxwireless.org/en/users/Drivers/b43

I have now downgraded the firmware (I was foolishly assuming that all
firmware versions recognized by b43-fwcutter are equally supported), and
the error does not occur any more.  Thanks for your help.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab at suse.de
SuSE Linux Products GmbH, Maxfeldstra?e 5, 90409 N?rnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."


From larry.finger at lwfinger.net  Tue Nov 20 16:09:27 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 20 Nov 2007 09:09:27 -0600
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <jeir3xdyqu.fsf@sykes.suse.de>
References: <20071119202121.6ad3fa70@morte>
	<200711192300.12183.rjw@sisk.pl>	<20071119231935.535674ba@morte>
	<jehcjheubn.fsf@sykes.suse.de>	<20071120001329.3524494a@morte>
	<jed4u5esbo.fsf@sykes.suse.de>	<20071120011549.6b04bb4d@morte>
	<jeir3xdyqu.fsf@sykes.suse.de>
Message-ID: <4742F8A7.6070903@lwfinger.net>

Andreas Schwab wrote:
> Stefano Brivio <stefano.brivio at polimi.it> writes:
> 
>> --- drivers/net/wireless/b43/main.c.orig        2007-11-20 01:12:12.186524483 +0100
>> +++ drivers/net/wireless/b43/main.c     2007-11-20 01:12:34.922702865 +0100
>> @@ -947,7 +947,7 @@
>>
>>         while (1) {
>>                 v0 = b43_read32(dev, B43_MMIO_XMITSTAT_0);
>> -               if (!(v0 & 0x00000001))
>> +               if (!v0)
>>                         break;
>>                 v1 = b43_read32(dev, B43_MMIO_XMITSTAT_1);
>>
>> (probably it's not the solution, I just want to see what happens then).
> 
> That didn't change anything.
> 
>> BTW, what firmware are you using?
> 
> It's 410.2160 from wl_ap.o.

Please try version 351.126 from http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2,
which is the officially supported version.

Larry


From mb at bu3sch.de  Tue Nov 20 16:18:21 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 20 Nov 2007 16:18:21 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <4742F8A7.6070903@lwfinger.net>
References: <20071119202121.6ad3fa70@morte> <jeir3xdyqu.fsf@sykes.suse.de>
	<4742F8A7.6070903@lwfinger.net>
Message-ID: <200711201618.21372.mb@bu3sch.de>

On Tuesday 20 November 2007 16:09:27 Larry Finger wrote:
> Andreas Schwab wrote:
> > Stefano Brivio <stefano.brivio at polimi.it> writes:
> > 
> >> --- drivers/net/wireless/b43/main.c.orig        2007-11-20 01:12:12.186524483 +0100
> >> +++ drivers/net/wireless/b43/main.c     2007-11-20 01:12:34.922702865 +0100
> >> @@ -947,7 +947,7 @@
> >>
> >>         while (1) {
> >>                 v0 = b43_read32(dev, B43_MMIO_XMITSTAT_0);
> >> -               if (!(v0 & 0x00000001))
> >> +               if (!v0)
> >>                         break;
> >>                 v1 = b43_read32(dev, B43_MMIO_XMITSTAT_1);
> >>
> >> (probably it's not the solution, I just want to see what happens then).
> > 
> > That didn't change anything.
> > 
> >> BTW, what firmware are you using?
> > 
> > It's 410.2160 from wl_ap.o.
> 
> Please try version 351.126 from http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2,
> which is the officially supported version.

There was some minor API change for newer firmware.
I think the TX and RX header layout slightly changed. I'll address that
later, as it's not too important now. (Or if someone else does want
to fix it, please send some patches...)

-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Tue Nov 20 21:12:56 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 20 Nov 2007 14:12:56 -0600
Subject: Request for information regarding BCM94311MCG rev 02
Message-ID: <47433FC8.8080704@lwfinger.net>

Is anyone running my 4311 rev 02 patches? If so, I need some help.

It appears that I have found either a hardware error with my copy of that card, or there is an error
in the ucode13 firmware. Between 2.6.24-rc2 and -rc3, code that resulted in the Descriptor Address
Rings having low addresses was removed. At that point, my card failed with a DMA error. When the
ring buffer is forced to a low address by requesting it with the GFP_DMA flag, then the card works.
Note that the data buffers for DMA are still at high addresses - only the ring buffer is low.

If you are using my patch, the card is working,  and 'uname -r' results in 2.6.24-rc3, please let me
know. If you kernel version is 2.6.24-rc2 or earlier, please apply the attached patch and report
your findings.

Thanks,

Larry
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: pfn_patch
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071120/93b4fd60/attachment.ksh>

From rjw at sisk.pl  Wed Nov 21 00:26:48 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Wed, 21 Nov 2007 00:26:48 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <200711201509.55763.mb@bu3sch.de>
References: <20071119202121.6ad3fa70@morte> <200711192357.44407.rjw@sisk.pl>
	<200711201509.55763.mb@bu3sch.de>
Message-ID: <200711210026.49732.rjw@sisk.pl>

On Tuesday, 20 of November 2007, Michael Buesch wrote:
> On Monday 19 November 2007 23:57:43 Rafael J. Wysocki wrote:
> > > Having both drivers in 2.6.24 should help find out if 
> > > there's anything which should be ironed out with b43/b43legacy, but right
> > > now they are already working a lot better than bcm43xx, and they are more
> > > stable. So I couldn't find a reason why we shouldn't remove bcm43xx in
> > > 2.6.25.
> > 
> > Many people use the old driver and you are forcing them to switch in a rather
> > unfriendly fashion.
> > 
> > Moreover, the switch generally involves a configuration change (on my system
> > eth1 became wlan0) and is not _that_ seamless.
> > 
> > IMvHO, the schedule of the removal of this driver should be discussed on LKML.
> 
> Ok, so we are going to add Rafael J. Wysocki as the bcm43xx maintainer
> and remove everyone else. I'm OK with that.

[That wasn't nice.]

I'm not qualified to maintain that code, sorry.  Apart from this, I've switched
to b43. :-)

> It is known for over a year now that b43 (aka bcm43xx-mac80211) is going to
> replace bcm43xx. And we already do a parrallel release cycle with both drivers
> included so people can switch. What else do you want?

_First_, mark bcm43xx as unmaintained.  Then, it's not your problem any more.
Perhaps there's someone who'd be willing to maintain it.  Otherwise, it will be
dropped anyway after some time - when no one uses it any more.  Still, it need
not be (and IMHO it shouldn't be) your decision to drop it.

Greetings,
Rafael


From asheesh at asheesh.org  Wed Nov 21 01:25:04 2007
From: asheesh at asheesh.org (Asheesh Laroia)
Date: Tue, 20 Nov 2007 16:25:04 -0800 (PST)
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <jeve7xc6sm.fsf@sykes.suse.de>
References: <20071119202121.6ad3fa70@morte> <200711201507.46998.mb@bu3sch.de>
	<je4pfhdn2c.fsf@sykes.suse.de> <200711201520.05718.mb@bu3sch.de>
	<jeve7xc6sm.fsf@sykes.suse.de>
Message-ID: <alpine.DEB.0.9999.0711201621120.9468@dell.linuxdev.us.dell.com>

On Tue, 20 Nov 2007, Andreas Schwab wrote:

> Michael Buesch <mb at bu3sch.de> writes:
>
>> On Tuesday 20 November 2007 15:11:07 Andreas Schwab wrote:
>>> Michael Buesch <mb at bu3sch.de> writes:
>>>
>>>> On Monday 19 November 2007 23:36:44 Andreas Schwab wrote:
>>>>> b43 still does not work at all on ppc.
>>>>
>>>> This is absolutely _wrong_.
>>>
>>> Of course it is wrong, but apparently the only way to get attention to a
>>> blocker bug.
>>
>> I didn't hear about your bug before.
>>
>> Are you using latest driver from wireless-2.6 and the officially
>> supported firmware version from
>> http://www.linuxwireless.org/en/users/Drivers/b43
>
> I have now downgraded the firmware (I was foolishly assuming that all
> firmware versions recognized by b43-fwcutter are equally supported), and
> the error does not occur any more.  Thanks for your help.

It sounds like b43-fwcutter will extract firmware that is not maximally 
compatible with the b43 driver.  If that's right, then it would be way 
nice to print a notice to the user that he's extracting a 
less-than-perfectly-supported firmware.

Yes, I'm willing to write this patch if people will point me to a table of 
which firmware is maximally-supported.  (If someone else writes it 
instead, I'd prefer that, but if no one will then I can.)

I haven't actually been using a bcm43xx chip for wireless for about a 
year, but I've been enjoying the list mail so I stayed on and read mails 
casually.  It sounds like there's one specific firmware that's 
recommended; if so, then printing "Congratulations, you're using the 
best-supported firmware as of ${RELEASE_DATE_OF_THIS_FWCUTTER}" in that 
case would be easy, as well as "Warning! You're not using the 
best-supported firmware as of ${RELEASE_DATE_OF_THIS_FWCUTTER}".

If it already does that now, then sorry for the noise!

-- Asheesh.

--
Positive, adj.:
 	Mistaken at the top of one's voice.
 		-- Ambrose Bierce, "The Devil's Dictionary"


From mb at bu3sch.de  Wed Nov 21 14:45:29 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 21 Nov 2007 14:45:29 +0100
Subject: [PATCH v3] remove bcm43xx
In-Reply-To: <200711210026.49732.rjw@sisk.pl>
References: <20071119202121.6ad3fa70@morte> <200711201509.55763.mb@bu3sch.de>
	<200711210026.49732.rjw@sisk.pl>
Message-ID: <200711211445.30142.mb@bu3sch.de>

On Wednesday 21 November 2007 00:26:48 Rafael J. Wysocki wrote:
> On Tuesday, 20 of November 2007, Michael Buesch wrote:
> > On Monday 19 November 2007 23:57:43 Rafael J. Wysocki wrote:
> > > > Having both drivers in 2.6.24 should help find out if 
> > > > there's anything which should be ironed out with b43/b43legacy, but right
> > > > now they are already working a lot better than bcm43xx, and they are more
> > > > stable. So I couldn't find a reason why we shouldn't remove bcm43xx in
> > > > 2.6.25.
> > > 
> > > Many people use the old driver and you are forcing them to switch in a rather
> > > unfriendly fashion.
> > > 
> > > Moreover, the switch generally involves a configuration change (on my system
> > > eth1 became wlan0) and is not _that_ seamless.
> > > 
> > > IMvHO, the schedule of the removal of this driver should be discussed on LKML.
> > 
> > Ok, so we are going to add Rafael J. Wysocki as the bcm43xx maintainer
> > and remove everyone else. I'm OK with that.
> 
> [That wasn't nice.]

Exactly.

> _First_, mark bcm43xx as unmaintained.  Then, it's not your problem any more.
> Perhaps there's someone who'd be willing to maintain it.  Otherwise, it will be
> dropped anyway after some time - when no one uses it any more.  Still, it need
> not be (and IMHO it shouldn't be) your decision to drop it.

Who is responsible to do that decision, if the driver authors that wrote all the
code aren't?
I'd be very happy to shift bcm43xx maintainership to someone else, but
there is _nobody_ who wants to do it. Face it. Nobody wants bcm43xx anymore.
And the only sane way to handle this is to run one release cycle with both
drivers included and remove the old driver after that.

bcm43xx is basically dropped since a year and everybody who cares knows that.
And nobody cares to maintain that piece of junk in the future.

-- 
Greetings Michael.


From linville at tuxdriver.com  Wed Nov 21 14:59:27 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 21 Nov 2007 08:59:27 -0500
Subject: schedule bcm43xx removal for 2.6.26 -- Re: [PATCH v3] remove bcm43xx
In-Reply-To: <200711210026.49732.rjw@sisk.pl>
References: <20071119202121.6ad3fa70@morte> <200711192357.44407.rjw@sisk.pl>
	<200711201509.55763.mb@bu3sch.de> <200711210026.49732.rjw@sisk.pl>
Message-ID: <20071121135927.GC8792@tuxdriver.com>

On Wed, Nov 21, 2007 at 12:26:48AM +0100, Rafael J. Wysocki wrote:
> On Tuesday, 20 of November 2007, Michael Buesch wrote:

> > It is known for over a year now that b43 (aka bcm43xx-mac80211) is going to
> > replace bcm43xx. And we already do a parrallel release cycle with both drivers
> > included so people can switch. What else do you want?
> 
> _First_, mark bcm43xx as unmaintained.  Then, it's not your problem any more.
> Perhaps there's someone who'd be willing to maintain it.  Otherwise, it will be
> dropped anyway after some time - when no one uses it any more.  Still, it need
> not be (and IMHO it shouldn't be) your decision to drop it.

It is probably true that we haven't communicated this very well
outside the wireless team.  We probably should have added bcm43xx to
the feature removal schedule before the 2.6.24 merge window closed.

How about if we mark bcm43xx as "Obsolete" in MAINTAINERS and add
an entry to Documentation/feature-removal-schedule.txt with a "When"
of 2.6.26?  I think that should give everyone sufficient notice...?

John
-- 
John W. Linville
linville at tuxdriver.com


From linville at tuxdriver.com  Wed Nov 21 15:16:11 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 21 Nov 2007 09:16:11 -0500
Subject: [PATCH] bcm43xx: mark as obsolete and schedule for removal
In-Reply-To: <20071121135927.GC8792@tuxdriver.com>
References: <20071121135927.GC8792@tuxdriver.com>
Message-ID: <1195654571-10506-1-git-send-email-linville@tuxdriver.com>

Signed-off-by: John W. Linville <linville at tuxdriver.com>
---
 Documentation/feature-removal-schedule.txt |    9 +++++++++
 MAINTAINERS                                |    2 +-
 2 files changed, 10 insertions(+), 1 deletions(-)

diff --git a/Documentation/feature-removal-schedule.txt b/Documentation/feature-removal-schedule.txt
index 20c4c8b..c057e36 100644
--- a/Documentation/feature-removal-schedule.txt
+++ b/Documentation/feature-removal-schedule.txt
@@ -333,3 +333,12 @@ Why:	This driver has been marked obsolete for many years.
 Who:	Stephen Hemminger <shemminger at linux-foundation.org>
 
 ---------------------------
+
+What:	bcm43xx wireless network driver
+When:	2.6.26
+Files:	drivers/net/wireless/bcm43xx
+Why:	This driver's functionality has been replaced by the
+	mac80211-based b43 and b43legacy drivers.
+Who:	John W. Linville <linville at tuxdriver.com>
+
+---------------------------
diff --git a/MAINTAINERS b/MAINTAINERS
index 18b7c8e..2bfc23f 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -828,7 +828,7 @@ P:	Stefano Brivio
 M:	stefano.brivio at polimi.it
 L:	linux-wireless at vger.kernel.org
 W:	http://bcm43xx.berlios.de/
-S:	Maintained
+S:	Obsolete
 
 BEFS FILE SYSTEM
 P:	Sergey S. Kostyliov
-- 
1.5.3.3



From larry.finger at lwfinger.net  Wed Nov 21 16:00:53 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 21 Nov 2007 09:00:53 -0600
Subject: schedule bcm43xx removal for 2.6.26 -- Re: [PATCH v3] remove
	bcm43xx
In-Reply-To: <20071121135927.GC8792@tuxdriver.com>
References: <20071119202121.6ad3fa70@morte> <200711192357.44407.rjw@sisk.pl>
	<200711201509.55763.mb@bu3sch.de> <200711210026.49732.rjw@sisk.pl>
	<20071121135927.GC8792@tuxdriver.com>
Message-ID: <47444825.4070505@lwfinger.net>

John W. Linville wrote:
> 
> It is probably true that we haven't communicated this very well
> outside the wireless team.  We probably should have added bcm43xx to
> the feature removal schedule before the 2.6.24 merge window closed.
> 
> How about if we mark bcm43xx as "Obsolete" in MAINTAINERS and add
> an entry to Documentation/feature-removal-schedule.txt with a "When"
> of 2.6.26?  I think that should give everyone sufficient notice...?

This sounds good to me. Of course, we all understand that once 2.6.25 is released, _EVERY_
complaint/bug report for bcm43xx and SoftMAC will get the response "switch to 2.6.25"!

Larry


From linville at tuxdriver.com  Wed Nov 21 16:26:18 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 21 Nov 2007 10:26:18 -0500
Subject: [PATCH v2] bcm43xx: mark as obsolete and schedule for removal
In-Reply-To: <1195654571-10506-1-git-send-email-linville@tuxdriver.com>
References: <1195654571-10506-1-git-send-email-linville@tuxdriver.com>
Message-ID: <1195658778-13118-1-git-send-email-linville@tuxdriver.com>

Signed-off-by: John W. Linville <linville at tuxdriver.com>
---
Amended based on suggestions from Stefano...

 Documentation/feature-removal-schedule.txt |    9 +++++++++
 MAINTAINERS                                |    2 +-
 drivers/net/wireless/bcm43xx/Kconfig       |    9 ++++++---
 3 files changed, 16 insertions(+), 4 deletions(-)

diff --git a/Documentation/feature-removal-schedule.txt b/Documentation/feature-removal-schedule.txt
index 20c4c8b..c057e36 100644
--- a/Documentation/feature-removal-schedule.txt
+++ b/Documentation/feature-removal-schedule.txt
@@ -333,3 +333,12 @@ Why:	This driver has been marked obsolete for many years.
 Who:	Stephen Hemminger <shemminger at linux-foundation.org>
 
 ---------------------------
+
+What:	bcm43xx wireless network driver
+When:	2.6.26
+Files:	drivers/net/wireless/bcm43xx
+Why:	This driver's functionality has been replaced by the
+	mac80211-based b43 and b43legacy drivers.
+Who:	John W. Linville <linville at tuxdriver.com>
+
+---------------------------
diff --git a/MAINTAINERS b/MAINTAINERS
index 18b7c8e..2bfc23f 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -828,7 +828,7 @@ P:	Stefano Brivio
 M:	stefano.brivio at polimi.it
 L:	linux-wireless at vger.kernel.org
 W:	http://bcm43xx.berlios.de/
-S:	Maintained
+S:	Obsolete
 
 BEFS FILE SYSTEM
 P:	Sergey S. Kostyliov
diff --git a/drivers/net/wireless/bcm43xx/Kconfig b/drivers/net/wireless/bcm43xx/Kconfig
index ce397e4..0159701 100644
--- a/drivers/net/wireless/bcm43xx/Kconfig
+++ b/drivers/net/wireless/bcm43xx/Kconfig
@@ -1,12 +1,15 @@
 config BCM43XX
-	tristate "Broadcom BCM43xx wireless support"
+	tristate "Broadcom BCM43xx wireless support (DEPRECATED)"
 	depends on PCI && IEEE80211 && IEEE80211_SOFTMAC && WLAN_80211 && EXPERIMENTAL
 	select WIRELESS_EXT
 	select FW_LOADER
 	select HW_RANDOM
 	---help---
-	  This is an experimental driver for the Broadcom 43xx wireless chip,
-	  found in the Apple Airport Extreme and various other devices.
+	  This is an experimental driver for the Broadcom 43xx wireless
+	  chip, found in the Apple Airport Extreme and various other
+	  devices.  This driver is deprecated and will be removed
+	  from the kernel in the near future.  It has been replaced
+	  by the b43 and b43legacy drivers.
 
 config BCM43XX_DEBUG
 	bool "Broadcom BCM43xx debugging (RECOMMENDED)"
-- 
1.5.3.3



From johannes at sipsolutions.net  Wed Nov 21 16:39:02 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 21 Nov 2007 16:39:02 +0100
Subject: schedule bcm43xx removal for 2.6.26 -- Re: [PATCH v3] remove
	bcm43xx
In-Reply-To: <47444825.4070505@lwfinger.net>
	(sfid-20071121_150110_312722_AD3AD70B)
References: <20071119202121.6ad3fa70@morte> <200711192357.44407.rjw@sisk.pl>
	<200711201509.55763.mb@bu3sch.de> <200711210026.49732.rjw@sisk.pl>
	<20071121135927.GC8792@tuxdriver.com> <47444825.4070505@lwfinger.net>
	(sfid-20071121_150110_312722_AD3AD70B)
Message-ID: <1195659542.12000.32.camel@johannes.berg>


> This sounds good to me. Of course, we all understand that once 2.6.25 is released, _EVERY_
> complaint/bug report for bcm43xx and SoftMAC will get the response "switch to 2.6.25"!

Nah. That'll even happen with .24 :)

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071121/024301b1/attachment.pgp>

From stefano.brivio at polimi.it  Wed Nov 21 16:46:31 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Wed, 21 Nov 2007 16:46:31 +0100
Subject: [PATCH v2] bcm43xx: mark as obsolete and schedule for removal
In-Reply-To: <1195658778-13118-1-git-send-email-linville@tuxdriver.com>
References: <1195654571-10506-1-git-send-email-linville@tuxdriver.com>
	<1195658778-13118-1-git-send-email-linville@tuxdriver.com>
Message-ID: <20071121164631.5cd1cc44@morte>

On Wed, 21 Nov 2007 10:26:18 -0500
"John W. Linville" <linville at tuxdriver.com> wrote:

> Signed-off-by: John W. Linville <linville at tuxdriver.com>

Acked-by: Stefano Brivio <stefano.brivio at polimi.it>


-- 
Ciao
Stefano


From johannes at sipsolutions.net  Wed Nov 21 16:56:14 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 21 Nov 2007 16:56:14 +0100
Subject: Request for information regarding BCM94311MCG rev 02
In-Reply-To: <47433FC8.8080704@lwfinger.net>
	(sfid-20071120_201343_787435_F696169A)
References: <47433FC8.8080704@lwfinger.net>
	(sfid-20071120_201343_787435_F696169A)
Message-ID: <1195660574.12000.42.camel@johannes.berg>


> It appears that I have found either a hardware error with my copy of that card, or there is an error
> in the ucode13 firmware. 

FWIW, the firmware is hardly involved in DMA so that's extremely
unlikely.

> Between 2.6.24-rc2 and -rc3, code that resulted in the Descriptor Address
> Rings having low addresses was removed. At that point, my card failed with a DMA error. When the
> ring buffer is forced to a low address by requesting it with the GFP_DMA flag, then the card works.
> Note that the data buffers for DMA are still at high addresses - only the ring buffer is low.

Maybe the card can't handle high addresses for the buffers or we're
doing something wrong with the address (extension) here?

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071121/9c69e631/attachment.pgp>

From larry.finger at lwfinger.net  Wed Nov 21 17:53:50 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 21 Nov 2007 10:53:50 -0600
Subject: Request for information regarding BCM94311MCG rev 02
In-Reply-To: <1195660574.12000.42.camel@johannes.berg>
References: <47433FC8.8080704@lwfinger.net>	
	(sfid-20071120_201343_787435_F696169A)
	<1195660574.12000.42.camel@johannes.berg>
Message-ID: <4744629E.7020402@lwfinger.net>

Johannes Berg wrote:
>> It appears that I have found either a hardware error with my copy of that card, or there is an error
>> in the ucode13 firmware. 
> 
> FWIW, the firmware is hardly involved in DMA so that's extremely
> unlikely.

Does this mean the DMA engines are implemented in silicon? If so, there may be an error in the chip
design. AFAIK, all Windows DMA is done to really low-order memory, and such a defect would not show
there. I do not know if this card is ever used on a Mac.

>> Between 2.6.24-rc2 and -rc3, code that resulted in the Descriptor Address
>> Rings having low addresses was removed. At that point, my card failed with a DMA error. When the
>> ring buffer is forced to a low address by requesting it with the GFP_DMA flag, then the card works.
>> Note that the data buffers for DMA are still at high addresses - only the ring buffer is low.
> 
> Maybe the card can't handle high addresses for the buffers or we're
> doing something wrong with the address (extension) here?

According to the specs, a flat 64-bit address is used for the ring buffer and it should be OK to put
the buffer anywhere in RAM. Only the data buffers require messing with an extension field; however,
my test machine has only 1.5 GB RAM, and all addresses fit in the low-order 32 bits.

Larry



From larry.finger at lwfinger.net  Wed Nov 21 17:59:48 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 21 Nov 2007 10:59:48 -0600
Subject: Request for information regarding BCM94311MCG rev 02
In-Reply-To: <1195660574.12000.42.camel@johannes.berg>
References: <47433FC8.8080704@lwfinger.net>	
	(sfid-20071120_201343_787435_F696169A)
	<1195660574.12000.42.camel@johannes.berg>
Message-ID: <47446404.8020200@lwfinger.net>

Johannes Berg wrote:
> 
> Maybe the card can't handle high addresses for the buffers or we're
> doing something wrong with the address (extension) here?

On a whim, I decided to look at the latest version of ndiswrapper, and found this code snippet:

#ifdef CONFIG_X86_64
        /* 64-bit broadcom driver doesn't work if DMA is allocated
         * from over 1GB */
        if (wd->vendor == 0x14e4) {
                if (pci_set_dma_mask(pdev, DMA_30BIT_MASK) ||
                    pci_set_consistent_dma_mask(pdev, DMA_30BIT_MASK))
                        WARNING("couldn't set DMA mask; this driver "
                                "may not work with more than 1GB RAM");
        }
#endif

This makes it look more-and-more like a design problem with the hardware.

Larry



From johannes at sipsolutions.net  Wed Nov 21 18:04:57 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 21 Nov 2007 18:04:57 +0100
Subject: Request for information regarding BCM94311MCG rev 02
In-Reply-To: <4744629E.7020402@lwfinger.net>
References: <47433FC8.8080704@lwfinger.net>
	(sfid-20071120_201343_787435_F696169A)
	<1195660574.12000.42.camel@johannes.berg>
	<4744629E.7020402@lwfinger.net>
Message-ID: <1195664697.12000.59.camel@johannes.berg>


> Does this mean the DMA engines are implemented in silicon? 

Yeah, it's not implemented in the firmware so it must be in silicon.

> If so, there may be an error in the chip
> design. AFAIK, all Windows DMA is done to really low-order memory, and such a defect would not show
> there. I do not know if this card is ever used on a Mac.

Hmm. This is of course possible but I doubt it a bit since the DMA
engine seems to be a quite highly-used piece of "code".

> >> Between 2.6.24-rc2 and -rc3, code that resulted in the Descriptor Address
> >> Rings having low addresses was removed. At that point, my card failed with a DMA error. When the
> >> ring buffer is forced to a low address by requesting it with the GFP_DMA flag, then the card works.
> >> Note that the data buffers for DMA are still at high addresses - only the ring buffer is low.
> > 
> > Maybe the card can't handle high addresses for the buffers or we're
> > doing something wrong with the address (extension) here?
> 
> According to the specs, a flat 64-bit address is used for the ring buffer and it should be OK to put
> the buffer anywhere in RAM. Only the data buffers require messing with an extension field; however,
> my test machine has only 1.5 GB RAM, and all addresses fit in the low-order 32 bits.

Right. Or so we thought :)

> On a whim, I decided to look at the latest version of ndiswrapper, and
> found this code snippet:
> 
> #ifdef CONFIG_X86_64
>         /* 64-bit broadcom driver doesn't work if DMA is allocated
>          * from over 1GB */
>         if (wd->vendor == 0x14e4) {
>                 if (pci_set_dma_mask(pdev, DMA_30BIT_MASK) ||
>                     pci_set_consistent_dma_mask(pdev, DMA_30BIT_MASK))
>                         WARNING("couldn't set DMA mask; this driver "
>                                 "may not work with more than 1GB
> RAM");
>         }
> #endif
> 
> This makes it look more-and-more like a design problem with the
> hardware.

But this isn't quite correct either is it?

You said before that we should be fine allocating the DMA rings below
1GB and then doing arbitrary DMA buffers. If this is the case, then imho
we should just do that, the six DMA rings or whatever we should be able
to fit into low memory.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071121/4ae82b7d/attachment.pgp>

From linville at tuxdriver.com  Wed Nov 21 18:04:37 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 21 Nov 2007 12:04:37 -0500
Subject: Request for information regarding BCM94311MCG rev 02
In-Reply-To: <47446404.8020200@lwfinger.net>
References: <47433FC8.8080704@lwfinger.net>
	<1195660574.12000.42.camel@johannes.berg>
	<47446404.8020200@lwfinger.net>
Message-ID: <20071121170437.GA19848@tuxdriver.com>

On Wed, Nov 21, 2007 at 10:59:48AM -0600, Larry Finger wrote:
> Johannes Berg wrote:
> > 
> > Maybe the card can't handle high addresses for the buffers or we're
> > doing something wrong with the address (extension) here?
> 
> On a whim, I decided to look at the latest version of ndiswrapper, and found this code snippet:
> 
> #ifdef CONFIG_X86_64
>         /* 64-bit broadcom driver doesn't work if DMA is allocated
>          * from over 1GB */
>         if (wd->vendor == 0x14e4) {
>                 if (pci_set_dma_mask(pdev, DMA_30BIT_MASK) ||
>                     pci_set_consistent_dma_mask(pdev, DMA_30BIT_MASK))
>                         WARNING("couldn't set DMA mask; this driver "
>                                 "may not work with more than 1GB RAM");
>         }
> #endif
> 
> This makes it look more-and-more like a design problem with the hardware.

Crap...surely they have resolved this in newer hardware?

-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Wed Nov 21 18:53:40 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 21 Nov 2007 11:53:40 -0600
Subject: Request for information regarding BCM94311MCG rev 02
In-Reply-To: <1195664697.12000.59.camel@johannes.berg>
References: <47433FC8.8080704@lwfinger.net>	(sfid-20071120_201343_787435_F696169A)	<1195660574.12000.42.camel@johannes.berg>	<4744629E.7020402@lwfinger.net>
	<1195664697.12000.59.camel@johannes.berg>
Message-ID: <474470A4.9030200@lwfinger.net>

Johannes Berg wrote:
> 
> But this isn't quite correct either is it?
> 
> You said before that we should be fine allocating the DMA rings below
> 1GB and then doing arbitrary DMA buffers. If this is the case, then imho
> we should just do that, the six DMA rings or whatever we should be able
> to fit into low memory.

No it isn't right. When I booted with a mem=512M option, the DMA error still occurred as long as I
didn't allocate the ring buffer with the GFP_DMA flag. Allocating below the 1 GB boundary is not
sufficient.

John Linville wrote:

> Crap...surely they have resolved this in newer hardware?

It may be even worse. They seem to have made this device look like an ISA device and force the ring
buffer to below the 16 MB boundary.

Larry




From mb at bu3sch.de  Wed Nov 21 19:20:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 21 Nov 2007 19:20:48 +0100
Subject: schedule bcm43xx removal for 2.6.26 -- Re: [PATCH v3] remove
	bcm43xx
In-Reply-To: <20071121135927.GC8792@tuxdriver.com>
References: <20071119202121.6ad3fa70@morte> <200711210026.49732.rjw@sisk.pl>
	<20071121135927.GC8792@tuxdriver.com>
Message-ID: <200711211920.48640.mb@bu3sch.de>

On Wednesday 21 November 2007 14:59:27 John W. Linville wrote:
> On Wed, Nov 21, 2007 at 12:26:48AM +0100, Rafael J. Wysocki wrote:
> > On Tuesday, 20 of November 2007, Michael Buesch wrote:
> 
> > > It is known for over a year now that b43 (aka bcm43xx-mac80211) is going to
> > > replace bcm43xx. And we already do a parrallel release cycle with both drivers
> > > included so people can switch. What else do you want?
> > 
> > _First_, mark bcm43xx as unmaintained.  Then, it's not your problem any more.
> > Perhaps there's someone who'd be willing to maintain it.  Otherwise, it will be
> > dropped anyway after some time - when no one uses it any more.  Still, it need
> > not be (and IMHO it shouldn't be) your decision to drop it.
> 
> It is probably true that we haven't communicated this very well
> outside the wireless team.  We probably should have added bcm43xx to
> the feature removal schedule before the 2.6.24 merge window closed.
> 
> How about if we mark bcm43xx as "Obsolete" in MAINTAINERS and add
> an entry to Documentation/feature-removal-schedule.txt with a "When"
> of 2.6.26?  I think that should give everyone sufficient notice...?

So, is SoftMAC already scheduled?
Otherwise, I think when we are about to remove bcm43xx in 2.6.25 someone
is going to complain that removal of softmac was not scheduled...

Btw: Does someone actually read that feature-removal-schedule.txt file?

-- 
Greetings Michael.


From rjw at sisk.pl  Wed Nov 21 20:35:42 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Wed, 21 Nov 2007 20:35:42 +0100
Subject: schedule bcm43xx removal for 2.6.26 -- Re: [PATCH v3] remove
	bcm43xx
In-Reply-To: <20071121135927.GC8792@tuxdriver.com>
References: <20071119202121.6ad3fa70@morte> <200711210026.49732.rjw@sisk.pl>
	<20071121135927.GC8792@tuxdriver.com>
Message-ID: <200711212035.42857.rjw@sisk.pl>

On Wednesday, 21 of November 2007, John W. Linville wrote:
> On Wed, Nov 21, 2007 at 12:26:48AM +0100, Rafael J. Wysocki wrote:
> > On Tuesday, 20 of November 2007, Michael Buesch wrote:
> 
> > > It is known for over a year now that b43 (aka bcm43xx-mac80211) is going to
> > > replace bcm43xx. And we already do a parrallel release cycle with both drivers
> > > included so people can switch. What else do you want?
> > 
> > _First_, mark bcm43xx as unmaintained.  Then, it's not your problem any more.
> > Perhaps there's someone who'd be willing to maintain it.  Otherwise, it will be
> > dropped anyway after some time - when no one uses it any more.  Still, it need
> > not be (and IMHO it shouldn't be) your decision to drop it.
> 
> It is probably true that we haven't communicated this very well
> outside the wireless team.  We probably should have added bcm43xx to
> the feature removal schedule before the 2.6.24 merge window closed.
> 
> How about if we mark bcm43xx as "Obsolete" in MAINTAINERS and add
> an entry to Documentation/feature-removal-schedule.txt with a "When"
> of 2.6.26?

This is a very good idea IMO.

> I think that should give everyone sufficient notice...? 

Please also state very clearly in the changelog that you'd like to drop the
driver entirely before 2.6.26.

Thanks,
Rafael


From Larry.Finger at lwfinger.net  Wed Nov 21 20:31:53 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 21 Nov 2007 13:31:53 -0600
Subject: [PATCH] b43: Changes to enable BCM4311 rev 02 with wireless core
	revision 13
Message-ID: <474487a9.9c54/m97tX72L4+l%Larry.Finger@lwfinger.net>

The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
has not been supported until now. The changes include the following:

(1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
(2) Add PHY revision 9 to the supported list.
(3) Fix 64-bit addressing errors.
(4) Remove some magic numbers in the DMA setup.

The DMA implementation for this chip supports full 64-bit addressing with
one exception. Whenever the Descriptor Ring Buffer is in high memory, a
fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
to code to "Bias the placement of kernel pages at lower PFNs". When
commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
this problem is thought to arise from a hardware error. The present driver
allocates one ring buffer for RX and six for TX; however, only one of the
TX buffers is used. To minimize any system impact associated with using low
memory, this patch removes the allocation of the unused buffers.

This patch has been tested by C?dric Caumont <icare40 at hotmail.com>.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This patch is intended for the everything branch of wireless-2.6.

Larry
---

 dma.c  |   86 ++++++++++++++++++++++++++++++++++-------------------------------
 main.c |    3 +-
 wa.c   |    1
 3 files changed, 49 insertions(+), 41 deletions(-)

Index: wireless-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/dma.c
+++ wireless-2.6/drivers/net/wireless/b43/dma.c
@@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct 
 	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
 	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
 	    >> SSB_DMA_TRANSLATION_SHIFT;
-	addrhi |= ssb_dma_translation(ring->dev->dev);
+	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
 	if (slot == ring->nr_slots - 1)
 		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
 	if (start)
@@ -426,9 +426,20 @@ static inline
 static int alloc_ringmemory(struct b43_dmaring *ring)
 {
 	struct device *dev = ring->dev->dev->dev;
+	gfp_t flags = GFP_KERNEL;
 
+	/* The specs call for 4K buffers for 30- and 32-bit DMA
+	 * and 8K buffers for 64-bit DMA; however, 4K is sufficient for
+	 * the latter as long as the buffer does not cross an 8K boundary.
+	 *
+	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
+	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
+	 * which accounts for the GFP_DMA flag below.
+	 */
+	if (ring->dma64)
+		flags = GFP_DMA;
 	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
-					    &(ring->dmabase), GFP_KERNEL);
+					    &(ring->dmabase), flags);
 	if (!ring->descbase) {
 		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
 		return -ENOMEM;
@@ -483,7 +494,7 @@ int b43_dmacontroller_rx_reset(struct b4
 	return 0;
 }
 
-/* Reset the RX DMA channel */
+/* Reset the TX DMA channel */
 int b43_dmacontroller_tx_reset(struct b43_wldev *dev, u16 mmio_base, int dma64)
 {
 	int i;
@@ -636,18 +647,12 @@ static int dmacontroller_setup(struct b4
 		if (ring->dma64) {
 			u64 ringbase = (u64) (ring->dmabase);
 
-			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
-			    >> SSB_DMA_TRANSLATION_SHIFT;
-			value = B43_DMA64_TXENABLE;
-			value |= (addrext << B43_DMA64_TXADDREXT_SHIFT)
-			    & B43_DMA64_TXADDREXT_MASK;
-			b43_dma_write(ring, B43_DMA64_TXCTL, value);
+			b43_dma_write(ring, B43_DMA64_TXCTL,
+				      B43_DMA64_TXENABLE);
 			b43_dma_write(ring, B43_DMA64_TXRINGLO,
 				      (ringbase & 0xFFFFFFFF));
 			b43_dma_write(ring, B43_DMA64_TXRINGHI,
-				      ((ringbase >> 32) &
-				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
+				      (ringbase >> 32));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -668,20 +673,15 @@ static int dmacontroller_setup(struct b4
 		if (ring->dma64) {
 			u64 ringbase = (u64) (ring->dmabase);
 
-			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
-			    >> SSB_DMA_TRANSLATION_SHIFT;
-			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT);
-			value |= B43_DMA64_RXENABLE;
-			value |= (addrext << B43_DMA64_RXADDREXT_SHIFT)
-			    & B43_DMA64_RXADDREXT_MASK;
+			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT)
+				| B43_DMA64_RXENABLE;
 			b43_dma_write(ring, B43_DMA64_RXCTL, value);
 			b43_dma_write(ring, B43_DMA64_RXRINGLO,
 				      (ringbase & 0xFFFFFFFF));
 			b43_dma_write(ring, B43_DMA64_RXRINGHI,
-				      ((ringbase >> 32) &
-				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
-			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
+				      (ringbase >> 32));
+			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc64));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -695,11 +695,12 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA32_RXRING,
 				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
 				      | trans);
-			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
+			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc32));
 		}
 	}
 
-      out:
+out:
 	return err;
 }
 
@@ -954,19 +955,21 @@ int b43_dma_init(struct b43_wldev *dev)
 
 	err = -ENOMEM;
 	/* setup TX DMA channels. */
-	ring = b43_setup_dmaring(dev, 0, 1, dma64);
+	ring = b43_setup_dmaring(dev, 1, 1, dma64);
 	if (!ring)
 		goto out;
-	dma->tx_ring0 = ring;
+	dma->tx_ring1 = ring;
 
-	ring = b43_setup_dmaring(dev, 1, 1, dma64);
+	/* The driver only uses ring1 for TX - skip setup for the rest */
+#if 0
+	ring = b43_setup_dmaring(dev, 0, 1, dma64);
 	if (!ring)
-		goto err_destroy_tx0;
-	dma->tx_ring1 = ring;
+		goto err_destroy_tx1;
+	dma->tx_ring0 = ring;
 
 	ring = b43_setup_dmaring(dev, 2, 1, dma64);
 	if (!ring)
-		goto err_destroy_tx1;
+		goto err_destroy_tx0;
 	dma->tx_ring2 = ring;
 
 	ring = b43_setup_dmaring(dev, 3, 1, dma64);
@@ -983,6 +986,7 @@ int b43_dma_init(struct b43_wldev *dev)
 	if (!ring)
 		goto err_destroy_tx4;
 	dma->tx_ring5 = ring;
+#endif
 
 	/* setup RX DMA channels. */
 	ring = b43_setup_dmaring(dev, 0, 0, dma64);
@@ -1001,30 +1005,32 @@ int b43_dma_init(struct b43_wldev *dev)
 	       (dmamask == DMA_64BIT_MASK) ? 64 :
 	       (dmamask == DMA_32BIT_MASK) ? 32 : 30);
 	err = 0;
-      out:
+out:
 	return err;
 
-      err_destroy_rx0:
+err_destroy_rx0:
 	b43_destroy_dmaring(dma->rx_ring0);
 	dma->rx_ring0 = NULL;
-      err_destroy_tx5:
+err_destroy_tx5:
+#if 0
 	b43_destroy_dmaring(dma->tx_ring5);
 	dma->tx_ring5 = NULL;
-      err_destroy_tx4:
+err_destroy_tx4:
 	b43_destroy_dmaring(dma->tx_ring4);
 	dma->tx_ring4 = NULL;
-      err_destroy_tx3:
+err_destroy_tx3:
 	b43_destroy_dmaring(dma->tx_ring3);
 	dma->tx_ring3 = NULL;
-      err_destroy_tx2:
+err_destroy_tx2:
 	b43_destroy_dmaring(dma->tx_ring2);
 	dma->tx_ring2 = NULL;
-      err_destroy_tx1:
-	b43_destroy_dmaring(dma->tx_ring1);
-	dma->tx_ring1 = NULL;
-      err_destroy_tx0:
+err_destroy_tx0:
 	b43_destroy_dmaring(dma->tx_ring0);
 	dma->tx_ring0 = NULL;
+err_destroy_tx1:
+#endif
+	b43_destroy_dmaring(dma->tx_ring1);
+	dma->tx_ring1 = NULL;
 	goto out;
 }
 
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -93,6 +93,7 @@ static const struct ssb_device_id b43_ss
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
 	SSB_DEVTABLE_END
 };
 
@@ -3064,7 +3065,7 @@ static int b43_phy_versioning(struct b43
 			unsupported = 1;
 		break;
 	case B43_PHYTYPE_G:
-		if (phy_rev > 8)
+		if (phy_rev > 9)
 			unsupported = 1;
 		break;
 	default:
Index: wireless-2.6/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
+++ wireless-2.6/drivers/net/wireless/b43/wa.c
@@ -642,6 +642,7 @@ void b43_wa_all(struct b43_wldev *dev)
 		case 6:
 		case 7:
 		case 8:
+		case 9:
 			b43_wa_tr_ltov(dev);
 			b43_wa_crs_ed(dev);
 			b43_wa_rssi_lt(dev);


From mb at bu3sch.de  Wed Nov 21 20:44:08 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 21 Nov 2007 20:44:08 +0100
Subject: [PATCH] b43: Changes to enable BCM4311 rev 02 with wireless core
	revision 13
In-Reply-To: <474487a9.9c54/m97tX72L4+l%Larry.Finger@lwfinger.net>
References: <474487a9.9c54/m97tX72L4+l%Larry.Finger@lwfinger.net>
Message-ID: <200711212044.08265.mb@bu3sch.de>

On Wednesday 21 November 2007 20:31:53 Larry Finger wrote:
> The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
> has not been supported until now. The changes include the following:
> 
> (1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
> (2) Add PHY revision 9 to the supported list.
> (3) Fix 64-bit addressing errors.
> (4) Remove some magic numbers in the DMA setup.
> 
> The DMA implementation for this chip supports full 64-bit addressing with
> one exception. Whenever the Descriptor Ring Buffer is in high memory, a
> fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
> to code to "Bias the placement of kernel pages at lower PFNs". When
> commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
> use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
> this problem is thought to arise from a hardware error. The present driver
> allocates one ring buffer for RX and six for TX; however, only one of the
> TX buffers is used. To minimize any system impact associated with using low
> memory, this patch removes the allocation of the unused buffers.
> 
> This patch has been tested by C?dric Caumont <icare40 at hotmail.com>.
> 

> @@ -954,19 +955,21 @@ int b43_dma_init(struct b43_wldev *dev)
>  
>  	err = -ENOMEM;
>  	/* setup TX DMA channels. */
> -	ring = b43_setup_dmaring(dev, 0, 1, dma64);
> +	ring = b43_setup_dmaring(dev, 1, 1, dma64);
>  	if (!ring)
>  		goto out;
> -	dma->tx_ring0 = ring;
> +	dma->tx_ring1 = ring;
>  
> -	ring = b43_setup_dmaring(dev, 1, 1, dma64);
> +	/* The driver only uses ring1 for TX - skip setup for the rest */
> +#if 0

NACK.

> +	ring = b43_setup_dmaring(dev, 0, 1, dma64);
>  	if (!ring)
> -		goto err_destroy_tx0;
> -	dma->tx_ring1 = ring;
> +		goto err_destroy_tx1;
> +	dma->tx_ring0 = ring;
>  
>  	ring = b43_setup_dmaring(dev, 2, 1, dma64);
>  	if (!ring)
> -		goto err_destroy_tx1;
> +		goto err_destroy_tx0;
>  	dma->tx_ring2 = ring;
>  
>  	ring = b43_setup_dmaring(dev, 3, 1, dma64);
> @@ -983,6 +986,7 @@ int b43_dma_init(struct b43_wldev *dev)
>  	if (!ring)
>  		goto err_destroy_tx4;
>  	dma->tx_ring5 = ring;
> +#endif


-- 
Greetings Michael.


From larry.finger at lwfinger.net  Wed Nov 21 21:02:25 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 21 Nov 2007 14:02:25 -0600
Subject: [PATCH] b43: Changes to enable BCM4311 rev 02 with wireless core
	revision 13
In-Reply-To: <200711212044.08265.mb@bu3sch.de>
References: <474487a9.9c54/m97tX72L4+l%Larry.Finger@lwfinger.net>
	<200711212044.08265.mb@bu3sch.de>
Message-ID: <47448ED1.9090100@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 21 November 2007 20:31:53 Larry Finger wrote:
>> The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
>> has not been supported until now. The changes include the following:
>>
>> (1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
>> (2) Add PHY revision 9 to the supported list.
>> (3) Fix 64-bit addressing errors.
>> (4) Remove some magic numbers in the DMA setup.
>>
>> The DMA implementation for this chip supports full 64-bit addressing with
>> one exception. Whenever the Descriptor Ring Buffer is in high memory, a
>> fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
>> to code to "Bias the placement of kernel pages at lower PFNs". When
>> commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
>> use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
>> this problem is thought to arise from a hardware error. The present driver
>> allocates one ring buffer for RX and six for TX; however, only one of the
>> TX buffers is used. To minimize any system impact associated with using low
>> memory, this patch removes the allocation of the unused buffers.
>>
>> This patch has been tested by C?dric Caumont <icare40 at hotmail.com>.
>>
> 
>> @@ -954,19 +955,21 @@ int b43_dma_init(struct b43_wldev *dev)
>>  
>>  	err = -ENOMEM;
>>  	/* setup TX DMA channels. */
>> -	ring = b43_setup_dmaring(dev, 0, 1, dma64);
>> +	ring = b43_setup_dmaring(dev, 1, 1, dma64);
>>  	if (!ring)
>>  		goto out;
>> -	dma->tx_ring0 = ring;
>> +	dma->tx_ring1 = ring;
>>  
>> -	ring = b43_setup_dmaring(dev, 1, 1, dma64);
>> +	/* The driver only uses ring1 for TX - skip setup for the rest */
>> +#if 0
> 
> NACK.

Are you NACKing the "if 0" or the elimination of the unused TX rings? Perhaps we could have

	if (ring->dma64)
		goto out;

Larry


From mb at bu3sch.de  Wed Nov 21 21:10:15 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 21 Nov 2007 21:10:15 +0100
Subject: [PATCH] b43: Changes to enable BCM4311 rev 02 with wireless core
	revision 13
In-Reply-To: <47448ED1.9090100@lwfinger.net>
References: <474487a9.9c54/m97tX72L4+l%Larry.Finger@lwfinger.net>
	<200711212044.08265.mb@bu3sch.de> <47448ED1.9090100@lwfinger.net>
Message-ID: <200711212110.15901.mb@bu3sch.de>

On Wednesday 21 November 2007 21:02:25 Larry Finger wrote:
> Michael Buesch wrote:
> > On Wednesday 21 November 2007 20:31:53 Larry Finger wrote:
> >> The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
> >> has not been supported until now. The changes include the following:
> >>
> >> (1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
> >> (2) Add PHY revision 9 to the supported list.
> >> (3) Fix 64-bit addressing errors.
> >> (4) Remove some magic numbers in the DMA setup.
> >>
> >> The DMA implementation for this chip supports full 64-bit addressing with
> >> one exception. Whenever the Descriptor Ring Buffer is in high memory, a
> >> fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
> >> to code to "Bias the placement of kernel pages at lower PFNs". When
> >> commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
> >> use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
> >> this problem is thought to arise from a hardware error. The present driver
> >> allocates one ring buffer for RX and six for TX; however, only one of the
> >> TX buffers is used. To minimize any system impact associated with using low
> >> memory, this patch removes the allocation of the unused buffers.
> >>
> >> This patch has been tested by C?dric Caumont <icare40 at hotmail.com>.
> >>
> > 
> >> @@ -954,19 +955,21 @@ int b43_dma_init(struct b43_wldev *dev)
> >>  
> >>  	err = -ENOMEM;
> >>  	/* setup TX DMA channels. */
> >> -	ring = b43_setup_dmaring(dev, 0, 1, dma64);
> >> +	ring = b43_setup_dmaring(dev, 1, 1, dma64);
> >>  	if (!ring)
> >>  		goto out;
> >> -	dma->tx_ring0 = ring;
> >> +	dma->tx_ring1 = ring;
> >>  
> >> -	ring = b43_setup_dmaring(dev, 1, 1, dma64);
> >> +	/* The driver only uses ring1 for TX - skip setup for the rest */
> >> +#if 0
> > 
> > NACK.
> 
> Are you NACKing the "if 0" or the elimination of the unused TX rings? Perhaps we could have

Both

> 	if (ring->dma64)
> 		goto out;

No,
I am going to submit patches to enable use of multiple TX queues.
See my quilt series.
Simply don't change current behaviour. ;)

The only reason for me holding these patches back is that I could
not sufficiently test them yet.

-- 
Greetings Michael.


From linville at tuxdriver.com  Wed Nov 21 21:26:41 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 21 Nov 2007 15:26:41 -0500
Subject: [PATCH] softmac: mark as obsolete and schedule for removal
In-Reply-To: <200711211920.48640.mb@bu3sch.de>
References: <200711211920.48640.mb@bu3sch.de>
Message-ID: <1195676801-30719-1-git-send-email-linville@tuxdriver.com>

Schedule softmac for for removal in the 2.6.26 development window.

Signed-off-by: John W. Linville <linville at tuxdriver.com>
---
 Documentation/feature-removal-schedule.txt |    8 ++++++++
 net/ieee80211/Kconfig                      |    5 +++--
 2 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/Documentation/feature-removal-schedule.txt b/Documentation/feature-removal-schedule.txt
index c057e36..aeaa129 100644
--- a/Documentation/feature-removal-schedule.txt
+++ b/Documentation/feature-removal-schedule.txt
@@ -342,3 +342,11 @@ Why:	This driver's functionality has been replaced by the
 Who:	John W. Linville <linville at tuxdriver.com>
 
 ---------------------------
+
+What:	iee80211 softmac wireless networking component
+When:	2.6.26 (or after removal of bcm43xx and port of zd1211rw to mac80211)
+Files:	net/ieee80211/softmac
+Why:	No in-kernel drivers will depend on it any longer.
+Who:	John W. Linville <linville at tuxdriver.com>
+
+---------------------------
diff --git a/net/ieee80211/Kconfig b/net/ieee80211/Kconfig
index 1438ade..bd50104 100644
--- a/net/ieee80211/Kconfig
+++ b/net/ieee80211/Kconfig
@@ -1,8 +1,9 @@
 config IEEE80211
-	tristate "Generic IEEE 802.11 Networking Stack"
+	tristate "Generic IEEE 802.11 Networking Stack (DEPRECATED)"
 	---help---
 	This option enables the hardware independent IEEE 802.11
-	networking stack.
+	networking stack.  This component is deprecated in favor of the
+	mac80211 component.
 
 config IEEE80211_DEBUG
 	bool "Enable full debugging output"
-- 
1.5.3.3



From cebbert at redhat.com  Wed Nov 21 22:33:55 2007
From: cebbert at redhat.com (Chuck Ebbert)
Date: Wed, 21 Nov 2007 16:33:55 -0500
Subject: [PATCH] b43: Changes to enable BCM4311 rev 02 with wireless core
	revision 13
In-Reply-To: <474487a9.9c54/m97tX72L4+l%Larry.Finger@lwfinger.net>
References: <474487a9.9c54/m97tX72L4+l%Larry.Finger@lwfinger.net>
Message-ID: <4744A443.6070808@redhat.com>

On 11/21/2007 02:31 PM, Larry Finger wrote:
> The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
> has not been supported until now. The changes include the following:
> 

I put this in a private build of the Fedora 8 kernel in place of the
the one that was added a few days ago.

This one works, but I get "PHY transmission error", probably because
the rfkill switch has disabled it. I see two LED devices and an input
device were registered but pushing the rfkill switch has no effect.
Googling doesn't yield any directions for enabling the switch...



From Larry.Finger at lwfinger.net  Wed Nov 21 22:38:12 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 21 Nov 2007 15:38:12 -0600
Subject: [PATCH V2] b43: Changes to enable BCM4311 rev 02 with wireless
	core revision 13
Message-ID: <4744a544.OLz3JRLe85L+V2nd%Larry.Finger@lwfinger.net>

The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
has not been supported until now. The changes include the following:

(1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
(2) Add PHY revision 9 to the supported list.
(3) Fix 64-bit addressing errors.
(4) Remove some magic numbers in the DMA setup.

The DMA implementation for this chip supports full 64-bit addressing with
one exception. Whenever the Descriptor Ring Buffer is in high memory, a
fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
to code to "Bias the placement of kernel pages at lower PFNs". When
commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
this problem is thought to arise from a hardware error.

This patch has been tested on my system and by C?dric Caumont
<icare40 at hotmail.com>.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This patch is intended for the everything branch of wireless-2.6.

Larry
---

 dma.c  |   50 ++++++++++++++++++++++++++------------------------
 main.c |    3 ++-
 wa.c   |    1 +
 3 files changed, 29 insertions(+), 25 deletions(-)

Index: wireless-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/dma.c
+++ wireless-2.6/drivers/net/wireless/b43/dma.c
@@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct 
 	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
 	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
 	    >> SSB_DMA_TRANSLATION_SHIFT;
-	addrhi |= ssb_dma_translation(ring->dev->dev);
+	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
 	if (slot == ring->nr_slots - 1)
 		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
 	if (start)
@@ -426,9 +426,21 @@ static inline
 static int alloc_ringmemory(struct b43_dmaring *ring)
 {
 	struct device *dev = ring->dev->dev->dev;
+	gfp_t flags = GFP_KERNEL;
 
+	/* The specs call for 4K buffers for 30- and 32-bit DMA with 4K
+	 * alignment and 8K buffers for 64-bit DMA with 8K alignment. Testing
+	 * has shown that 4K is sufficient for the latter as long as the buffer
+	 * does not cross an 8K boundary.
+	 *
+	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
+	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
+	 * which accounts for the GFP_DMA flag below.
+	 */
+	if (ring->dma64)
+		flags = GFP_DMA;
 	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
-					    &(ring->dmabase), GFP_KERNEL);
+					    &(ring->dmabase), flags);
 	if (!ring->descbase) {
 		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
 		return -ENOMEM;
@@ -483,7 +495,7 @@ int b43_dmacontroller_rx_reset(struct b4
 	return 0;
 }
 
-/* Reset the RX DMA channel */
+/* Reset the TX DMA channel */
 int b43_dmacontroller_tx_reset(struct b43_wldev *dev, u16 mmio_base, int dma64)
 {
 	int i;
@@ -636,18 +648,12 @@ static int dmacontroller_setup(struct b4
 		if (ring->dma64) {
 			u64 ringbase = (u64) (ring->dmabase);
 
-			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
-			    >> SSB_DMA_TRANSLATION_SHIFT;
-			value = B43_DMA64_TXENABLE;
-			value |= (addrext << B43_DMA64_TXADDREXT_SHIFT)
-			    & B43_DMA64_TXADDREXT_MASK;
-			b43_dma_write(ring, B43_DMA64_TXCTL, value);
+			b43_dma_write(ring, B43_DMA64_TXCTL,
+				      B43_DMA64_TXENABLE);
 			b43_dma_write(ring, B43_DMA64_TXRINGLO,
 				      (ringbase & 0xFFFFFFFF));
 			b43_dma_write(ring, B43_DMA64_TXRINGHI,
-				      ((ringbase >> 32) &
-				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
+				      (ringbase >> 32));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -668,20 +674,15 @@ static int dmacontroller_setup(struct b4
 		if (ring->dma64) {
 			u64 ringbase = (u64) (ring->dmabase);
 
-			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
-			    >> SSB_DMA_TRANSLATION_SHIFT;
-			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT);
-			value |= B43_DMA64_RXENABLE;
-			value |= (addrext << B43_DMA64_RXADDREXT_SHIFT)
-			    & B43_DMA64_RXADDREXT_MASK;
+			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT)
+				| B43_DMA64_RXENABLE;
 			b43_dma_write(ring, B43_DMA64_RXCTL, value);
 			b43_dma_write(ring, B43_DMA64_RXRINGLO,
 				      (ringbase & 0xFFFFFFFF));
 			b43_dma_write(ring, B43_DMA64_RXRINGHI,
-				      ((ringbase >> 32) &
-				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
-			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
+				      (ringbase >> 32));
+			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc64));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -695,11 +696,12 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA32_RXRING,
 				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
 				      | trans);
-			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
+			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc32));
 		}
 	}
 
-      out:
+out:
 	return err;
 }
 
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -93,6 +93,7 @@ static const struct ssb_device_id b43_ss
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
 	SSB_DEVTABLE_END
 };
 
@@ -3064,7 +3065,7 @@ static int b43_phy_versioning(struct b43
 			unsupported = 1;
 		break;
 	case B43_PHYTYPE_G:
-		if (phy_rev > 8)
+		if (phy_rev > 9)
 			unsupported = 1;
 		break;
 	default:
Index: wireless-2.6/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
+++ wireless-2.6/drivers/net/wireless/b43/wa.c
@@ -642,6 +642,7 @@ void b43_wa_all(struct b43_wldev *dev)
 		case 6:
 		case 7:
 		case 8:
+		case 9:
 			b43_wa_tr_ltov(dev);
 			b43_wa_crs_ed(dev);
 			b43_wa_rssi_lt(dev);


From larry.finger at lwfinger.net  Wed Nov 21 22:49:23 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 21 Nov 2007 15:49:23 -0600
Subject: [PATCH] b43: Changes to enable BCM4311 rev 02 with wireless core
	revision 13
In-Reply-To: <4744A443.6070808@redhat.com>
References: <474487a9.9c54/m97tX72L4+l%Larry.Finger@lwfinger.net>
	<4744A443.6070808@redhat.com>
Message-ID: <4744A7E3.6090105@lwfinger.net>

Chuck Ebbert wrote:
> On 11/21/2007 02:31 PM, Larry Finger wrote:
>> The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
>> has not been supported until now. The changes include the following:
>>
> 
> I put this in a private build of the Fedora 8 kernel in place of the
> the one that was added a few days ago.
> 
> This one works, but I get "PHY transmission error", probably because
> the rfkill switch has disabled it. I see two LED devices and an input
> device were registered but pushing the rfkill switch has no effect.
> Googling doesn't yield any directions for enabling the switch...

I don't think the PHY transmission error is caused by the rfkill switch, but I have no idea where it 
arises. It has been present since I enabled the device with 64-bit DMA.

I have not determined how to get rfkill to react to the LED switch, but now that the BCM4311 rev 02 
card is working, I should have some time to look at it.

Larry


From larry.finger at lwfinger.net  Wed Nov 21 23:18:09 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 21 Nov 2007 16:18:09 -0600
Subject: timeout problems with certain APs and b43
In-Reply-To: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
References: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
Message-ID: <4744AEA1.9020705@lwfinger.net>

John H. wrote:
>  uname -a
> Linux laptop 2.6.23.1-49.fc8 #1 SMP Thu Nov 8 21:41:26 EST 2007 i686
> i686 i386 GNU/Linux
> fedora 8
> 
> on certain APs, the internet works for a long time then stops, and I
> get authentication time outs, why?  It usually works again if I reset
> the AP itself, which i should not have to do and don't have to if in
> XP....
> 
> 
> wlan0: switched to long barker preamble (BSSID=00:0f:66:53:3e:24)
> wlan0: switched to short barker preamble (BSSID=00:0f:66:53:3e:24)
> 
> 
> 
> wlan0: Initial auth_alg=0
> wlan0: authenticate with AP 00:0f:66:53:3e:24
> wlan0: authenticate with AP 00:0f:66:53:3e:24
> wlan0: authenticate with AP 00:0f:66:53:3e:24
> wlan0: authentication with AP 00:0f:66:53:3e:24 timed out

Do you have the opportunity to capture the wireless traffic with a second computer using Kismet or
Wireshark when this condition occurs? Without that info, it would be hard to know what might be
wrong. Of course, I don't have the problem with either of my AP's.

Could you identify the make/model and firmware revisions of any AP's that show this behavior?

Larry


From hs4233 at mail.mn-solutions.de  Thu Nov 22 09:12:10 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Thu, 22 Nov 2007 09:12:10 +0100
Subject: mac80211 regression: doesn't associate automatically
Message-ID: <200711220912.10452.hs4233@mail.mn-solutions.de>

I'm on wireless-2.6, branch everything, git commit
7446b6c0e3b18fd2c5f9c406bb20841e6193d058

When I insert a b43 based card, I don't get associated
automatically. This happens:


$ # Insert the card
pccard: CardBus card inserted into slot 0
PCI: Enabling device 0000:03:00.0 (0000 -> 0002)
ACPI: PCI Interrupt 0000:03:00.0[A] -> Link [LNKC] -> GSI 11 (level, low) -> IRQ 11
PCI: Setting latency timer of device 0000:03:00.0 to 64
ssb: SPROM revision 1 detected.
ssb: Sonics Silicon Backplane found on PCI device 0000:03:00.0
b43-phy0: Broadcom 4306 WLAN found
b43-phy0 debug: Found PHY: Analog 2, Type 2, Revision 2
b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
phy0: Selected rate control algorithm 'simple'

$ ifconfig eth1 up
b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
b43-phy0 debug: Chip initialized
b43-phy0 debug: 30-bit DMA initialized
b43-phy0 debug: Wireless interface started
b43-phy0 debug: Adding Interface type 2

$ iwconfig eth1 essid BLAHMUMPF
HW CONFIG: channel=1 freq=2412 phymode=2
HW CONFIG: channel=2 freq=2417 phymode=2
HW CONFIG: channel=3 freq=2422 phymode=2
HW CONFIG: channel=4 freq=2427 phymode=2
HW CONFIG: channel=5 freq=2432 phymode=2
HW CONFIG: channel=6 freq=2437 phymode=2
HW CONFIG: channel=7 freq=2442 phymode=2
HW CONFIG: channel=8 freq=2447 phymode=2
HW CONFIG: channel=9 freq=2452 phymode=2
HW CONFIG: channel=10 freq=2457 phymode=2
HW CONFIG: channel=11 freq=2462 phymode=2
HW CONFIG: channel=1 freq=2412 phymode=2

$ iwconfig eth1 key s:11111
b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff

$ iwconfig eth1
eth1      IEEE 802.11g  ESSID:"BLAHMUMPF"
          Mode:Managed  Frequency:2.412 GHz  Access Point: Not-Associated
          Tx-Power=27 dBm
          Retry min limit:7   RTS thr:off   Fragment thr=2352 B
          Encryption key:3131-3131-31
          Link Quality:0  Signal level:0  Noise level:0
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

As you can see, I'm not associated. However, this sequence used
to work with non-mac80211 based WLAN drivers. However, I can actually
associate if I reverse the essid/key, e.g. first set the key, then
the ssid.


Note that the same happens if I let Debian manage the card. An excerpt
from my /etc/network/interfaces shows:

allow-hotplug eth1
iface eth1 inet static
        address 10.2.1.3
        netmask 255.255.255.0
        wireless-essid BLAHMUMPF
        wireless-key1 s:11111

(the test above has been made completely manually, without this entry)


From format_c at online.de  Thu Nov 22 12:37:12 2007
From: format_c at online.de (Alexander Koeppe)
Date: Thu, 22 Nov 2007 12:37:12 +0100
Subject: Instability with 4318 chip
Message-ID: <474569E8.8050308@online.de>

Hello list,


I'm using Gentoo Linux (2.6.23) on a Apple iBook and was very happy that
my wireless chip is supported.
After installation everything seems to be OK and working fine.
But when the distance to my AP ascends to more than 4 meters, the
connection seems to be down or unstable. Sometimes its also unstable at
a distance of 2 meters.
I also changed the transmission channel on my AP without result.

I investigated a bit using wireshark and found that the device is
sending ARP who-is broadcast packets that are not seen on the normal
cable network , where it should be normally because no L3 device
between. So transmission gives up because my notebook is'nt able to find
the correct MAC address for the a desired IP.

I searched the net and found that the driver in relation with the 4318
chipset has some transmission issues but a fix has been announced for
the 2.6.19 kernel release.

Is there something I can do?


Cheers Alex


From gmccullagh at gmail.com  Thu Nov 22 12:52:56 2007
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Thu, 22 Nov 2007 11:52:56 +0000
Subject: Instability with 4318 chip
In-Reply-To: <474569E8.8050308@online.de>
References: <474569E8.8050308@online.de>
Message-ID: <20071122115256.GJ935@gmail.com>

On Thu, 22 Nov 2007, Alexander Koeppe wrote:

> I'm using Gentoo Linux (2.6.23) on a Apple iBook and was very happy that
> my wireless chip is supported.
> After installation everything seems to be OK and working fine.
> But when the distance to my AP ascends to more than 4 meters, the
> connection seems to be down or unstable. Sometimes its also unstable at
> a distance of 2 meters.
> I also changed the transmission channel on my AP without result.

Are you using the bcm43xx driver?  If so, you might want to try downloading
the wireless-2.6 kernel tree and compiling the b43 driver which now
supercedes bcm43xx and is considerably more stable.

	# get a copy of the tree
	git clone git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-2.6.git 
	cd wireless-2.6
	# checkout all the other stuff
	git checkout -b everything
	# copy your existing kernel config
	cp /boot/configxxxxxxxxx .config
	make menuconfig
		# make sure the bcm driver is configured as a module
	make
	sudo make install

though there may be a tidier way to compile kernels into packages on
gentoo, I'm not sure.

Then you need to follow the firmware installation procedure for b43 (which
uses a different cutter program and a newer firmware).

	http://linuxwireless.org/en/users/Drivers/b43

Gavin



From johannes at sipsolutions.net  Thu Nov 22 14:01:35 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 22 Nov 2007 14:01:35 +0100
Subject: Request for information regarding BCM94311MCG rev 02
In-Reply-To: <474470A4.9030200@lwfinger.net>
References: <47433FC8.8080704@lwfinger.net>
	(sfid-20071120_201343_787435_F696169A)	<1195660574.12000.42.camel@johannes.berg>
	<4744629E.7020402@lwfinger.net>
	<1195664697.12000.59.camel@johannes.berg>
	<474470A4.9030200@lwfinger.net>
Message-ID: <1195736495.6323.93.camel@johannes.berg>


> > You said before that we should be fine allocating the DMA rings below
> > 1GB and then doing arbitrary DMA buffers. If this is the case, then imho
> > we should just do that, the six DMA rings or whatever we should be able
> > to fit into low memory.
> 
> No it isn't right. When I booted with a mem=512M option, the DMA error still occurred as long as I
> didn't allocate the ring buffer with the GFP_DMA flag. Allocating below the 1 GB boundary is not
> sufficient.

> It may be even worse. They seem to have made this device look like an ISA device and force the ring
> buffer to below the 16 MB boundary.

Hmm. No, that definitely doesn't make sense. There must be something
else going wrong like bad windowing in the PCI(e) core.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071122/fc4fab9d/attachment.pgp>

From johannes at sipsolutions.net  Thu Nov 22 14:05:52 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 22 Nov 2007 14:05:52 +0100
Subject: mac80211 regression: doesn't associate automatically
In-Reply-To: <200711220912.10452.hs4233@mail.mn-solutions.de>
	(sfid-20071122_081201_818890_5F650412)
References: <200711220912.10452.hs4233@mail.mn-solutions.de>
	(sfid-20071122_081201_818890_5F650412)
Message-ID: <1195736752.6323.97.camel@johannes.berg>

First off, let me state that I don't think this is a regression.

> $ iwconfig eth1 essid BLAHMUMPF
> HW CONFIG: channel=1 freq=2412 phymode=2
[...]

As you can see, it doesn't find anything that matches the current
configuration.

> $ iwconfig eth1 key s:11111
> b43-phy0 debug: Using hardware based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff

You've now enabled a key, but not told it to associate using that key.

> As you can see, I'm not associated. However, this sequence used
> to work with non-mac80211 based WLAN drivers. However, I can actually
> associate if I reverse the essid/key, e.g. first set the key, then
> the ssid.

Can't say that matters since wext is actually sufficiently undefined to
allow both behaviours. :) I'm strongly against changing the behaviour in
mac80211 because wext is sufficiently undefined that once we accept one
of these things we'll have a HUGE mess of code because all sorts of wext
ioctls affect possible association etc.

> Note that the same happens if I let Debian manage the card. An excerpt
> from my /etc/network/interfaces shows:

That sucks, I guess debian's scripts need to be fixed.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071122/f54f5ba8/attachment.pgp>

From linville at tuxdriver.com  Thu Nov 22 14:26:35 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 22 Nov 2007 08:26:35 -0500
Subject: mac80211 regression: doesn't associate automatically
In-Reply-To: <1195736752.6323.97.camel@johannes.berg>
References: <200711220912.10452.hs4233@mail.mn-solutions.de>
	<1195736752.6323.97.camel@johannes.berg>
Message-ID: <20071122132635.GA3372@tuxdriver.com>

On Thu, Nov 22, 2007 at 02:05:52PM +0100, Johannes Berg wrote:

> > Note that the same happens if I let Debian manage the card. An excerpt
> > from my /etc/network/interfaces shows:
> 
> That sucks, I guess debian's scripts need to be fixed.

As it stands, setting the SSID is the closest thing we have to an
"associate now" trigger.  I would have to advise distros and users to
always set it last in the wireless init, just before running dhclient
or whatever.

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Thu Nov 22 16:18:57 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 22 Nov 2007 09:18:57 -0600
Subject: Instability with 4318 chip
In-Reply-To: <474569E8.8050308@online.de>
References: <474569E8.8050308@online.de>
Message-ID: <47459DE1.2070109@lwfinger.net>

Alexander Koeppe wrote:
> Hello list,
> 
> 
> I'm using Gentoo Linux (2.6.23) on a Apple iBook and was very happy that
> my wireless chip is supported.
> After installation everything seems to be OK and working fine.
> But when the distance to my AP ascends to more than 4 meters, the
> connection seems to be down or unstable. Sometimes its also unstable at
> a distance of 2 meters.
> I also changed the transmission channel on my AP without result.
> 
> I investigated a bit using wireshark and found that the device is
> sending ARP who-is broadcast packets that are not seen on the normal
> cable network , where it should be normally because no L3 device
> between. So transmission gives up because my notebook is'nt able to find
> the correct MAC address for the a desired IP.
> 
> I searched the net and found that the driver in relation with the 4318
> chipset has some transmission issues but a fix has been announced for
> the 2.6.19 kernel release.
> 
> Is there something I can do?

You can start by telling us what kernel you are using (uname -r) and the results of 'dmesg | grep
bcm' and 'dmesg | grep b43'. I'm sorry, but I do not know what kernel every distro is using.

All versions of bcm43xx has some problems with the 4318. Only with b43 were those problems fixed.
That driver does not appear in mainline until 2.6.24.

Larry




From mb at bu3sch.de  Thu Nov 22 18:34:31 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 22 Nov 2007 18:34:31 +0100
Subject: [PATCH V2] b43: Changes to enable BCM4311 rev 02 with wireless
	core revision 13
In-Reply-To: <4744a544.OLz3JRLe85L+V2nd%Larry.Finger@lwfinger.net>
References: <4744a544.OLz3JRLe85L+V2nd%Larry.Finger@lwfinger.net>
Message-ID: <200711221834.32026.mb@bu3sch.de>

On Wednesday 21 November 2007 22:38:12 Larry Finger wrote:
> The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
> has not been supported until now. The changes include the following:
> 
> (1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
> (2) Add PHY revision 9 to the supported list.
> (3) Fix 64-bit addressing errors.
> (4) Remove some magic numbers in the DMA setup.
> 
> The DMA implementation for this chip supports full 64-bit addressing with
> one exception. Whenever the Descriptor Ring Buffer is in high memory, a
> fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
> to code to "Bias the placement of kernel pages at lower PFNs". When
> commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
> use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
> this problem is thought to arise from a hardware error.
> 
> This patch has been tested on my system and by C?dric Caumont
> <icare40 at hotmail.com>.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John,
> 
> This patch is intended for the everything branch of wireless-2.6.
> 
> Larry
> ---
> 
>  dma.c  |   50 ++++++++++++++++++++++++++------------------------
>  main.c |    3 ++-
>  wa.c   |    1 +
>  3 files changed, 29 insertions(+), 25 deletions(-)
> 
> Index: wireless-2.6/drivers/net/wireless/b43/dma.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/dma.c
> +++ wireless-2.6/drivers/net/wireless/b43/dma.c
> @@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct 
>  	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
>  	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
>  	    >> SSB_DMA_TRANSLATION_SHIFT;
> -	addrhi |= ssb_dma_translation(ring->dev->dev);
> +	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
>  	if (slot == ring->nr_slots - 1)
>  		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
>  	if (start)
> @@ -426,9 +426,21 @@ static inline
>  static int alloc_ringmemory(struct b43_dmaring *ring)
>  {
>  	struct device *dev = ring->dev->dev->dev;
> +	gfp_t flags = GFP_KERNEL;
>  
> +	/* The specs call for 4K buffers for 30- and 32-bit DMA with 4K
> +	 * alignment and 8K buffers for 64-bit DMA with 8K alignment. Testing
> +	 * has shown that 4K is sufficient for the latter as long as the buffer
> +	 * does not cross an 8K boundary.
> +	 *
> +	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
> +	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
> +	 * which accounts for the GFP_DMA flag below.
> +	 */
> +	if (ring->dma64)
> +		flags = GFP_DMA;
>  	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
> -					    &(ring->dmabase), GFP_KERNEL);
> +					    &(ring->dmabase), flags);
>  	if (!ring->descbase) {
>  		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
>  		return -ENOMEM;
> @@ -483,7 +495,7 @@ int b43_dmacontroller_rx_reset(struct b4
>  	return 0;
>  }
>  
> -/* Reset the RX DMA channel */
> +/* Reset the TX DMA channel */
>  int b43_dmacontroller_tx_reset(struct b43_wldev *dev, u16 mmio_base, int dma64)
>  {
>  	int i;
> @@ -636,18 +648,12 @@ static int dmacontroller_setup(struct b4
>  		if (ring->dma64) {
>  			u64 ringbase = (u64) (ring->dmabase);
>  
> -			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
> -			    >> SSB_DMA_TRANSLATION_SHIFT;
> -			value = B43_DMA64_TXENABLE;
> -			value |= (addrext << B43_DMA64_TXADDREXT_SHIFT)
> -			    & B43_DMA64_TXADDREXT_MASK;
> -			b43_dma_write(ring, B43_DMA64_TXCTL, value);
> +			b43_dma_write(ring, B43_DMA64_TXCTL,
> +				      B43_DMA64_TXENABLE);
>  			b43_dma_write(ring, B43_DMA64_TXRINGLO,
>  				      (ringbase & 0xFFFFFFFF));
>  			b43_dma_write(ring, B43_DMA64_TXRINGHI,
> -				      ((ringbase >> 32) &
> -				       ~SSB_DMA_TRANSLATION_MASK)
> -				      | trans);
> +				      (ringbase >> 32));
>  		} else {
>  			u32 ringbase = (u32) (ring->dmabase);
>  
> @@ -668,20 +674,15 @@ static int dmacontroller_setup(struct b4
>  		if (ring->dma64) {
>  			u64 ringbase = (u64) (ring->dmabase);
>  
> -			addrext = ((ringbase >> 32) & SSB_DMA_TRANSLATION_MASK)
> -			    >> SSB_DMA_TRANSLATION_SHIFT;
> -			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT);
> -			value |= B43_DMA64_RXENABLE;
> -			value |= (addrext << B43_DMA64_RXADDREXT_SHIFT)
> -			    & B43_DMA64_RXADDREXT_MASK;
> +			value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT)
> +				| B43_DMA64_RXENABLE;
>  			b43_dma_write(ring, B43_DMA64_RXCTL, value);
>  			b43_dma_write(ring, B43_DMA64_RXRINGLO,
>  				      (ringbase & 0xFFFFFFFF));
>  			b43_dma_write(ring, B43_DMA64_RXRINGHI,
> -				      ((ringbase >> 32) &
> -				       ~SSB_DMA_TRANSLATION_MASK)
> -				      | trans);
> -			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
> +				      (ringbase >> 32));
> +			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
> +				      sizeof(struct b43_dmadesc64));
>  		} else {
>  			u32 ringbase = (u32) (ring->dmabase);
>  
> @@ -695,11 +696,12 @@ static int dmacontroller_setup(struct b4
>  			b43_dma_write(ring, B43_DMA32_RXRING,
>  				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
>  				      | trans);
> -			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
> +			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
> +				      sizeof(struct b43_dmadesc32));
>  		}
>  	}
>  
> -      out:
> +out:
>  	return err;
>  }
>  
> Index: wireless-2.6/drivers/net/wireless/b43/main.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/main.c
> +++ wireless-2.6/drivers/net/wireless/b43/main.c
> @@ -93,6 +93,7 @@ static const struct ssb_device_id b43_ss
>  	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
>  	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
>  	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
> +	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
>  	SSB_DEVTABLE_END
>  };
>  
> @@ -3064,7 +3065,7 @@ static int b43_phy_versioning(struct b43
>  			unsupported = 1;
>  		break;
>  	case B43_PHYTYPE_G:
> -		if (phy_rev > 8)
> +		if (phy_rev > 9)
>  			unsupported = 1;
>  		break;
>  	default:
> Index: wireless-2.6/drivers/net/wireless/b43/wa.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
> +++ wireless-2.6/drivers/net/wireless/b43/wa.c
> @@ -642,6 +642,7 @@ void b43_wa_all(struct b43_wldev *dev)
>  		case 6:
>  		case 7:
>  		case 8:
> +		case 9:
>  			b43_wa_tr_ltov(dev);
>  			b43_wa_crs_ed(dev);
>  			b43_wa_rssi_lt(dev);
> 
> 

partially acked.
Though, I'm not quite sure yet why you remove that
address extension bits. The specs clearly say that they _are_ there.
And it makes sense to use them, as two bytes of the address are used
for the routing stuff. So the highest 2 bits of the address have to be put
somewhere else. That's the "Transmit Channel Control Word" and
"Receive Channel Control Word" where 0x00030000 are the extension bits.

However I do think that this might be related to the bug you are explaining
in the comment:
> +	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
> +	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
> +	 * which accounts for the GFP_DMA flag below.

-- 
Greetings Michael.


From proski at gnu.org  Fri Nov 23 01:23:25 2007
From: proski at gnu.org (Pavel Roskin)
Date: Thu, 22 Nov 2007 19:23:25 -0500
Subject: mac80211 regression: doesn't associate automatically
In-Reply-To: <20071122132635.GA3372@tuxdriver.com>
References: <200711220912.10452.hs4233@mail.mn-solutions.de>
	<1195736752.6323.97.camel@johannes.berg>
	<20071122132635.GA3372@tuxdriver.com>
Message-ID: <1195777405.11966.12.camel@dv>

On Thu, 2007-11-22 at 08:26 -0500, John W. Linville wrote:

> As it stands, setting the SSID is the closest thing we have to an
> "associate now" trigger.  I would have to advise distros and users to
> always set it last in the wireless init, just before running dhclient
> or whatever.

Maybe mac80211 should have a "grace period" of 0.5 seconds or so to
allow other settings to be set before the scanning starts?  The same
applies to other events causing scanning, such as bringing up the
interface.  It's too short to be noticeable, yet long enough for the
next command to run even on slow systems.

I think setting the key should not cause reassociation if there is an
association.  It can break some schemes where the WEP key changes
periodically on both sides.

-- 
Regards,
Pavel Roskin



From gavron at wetwork.net  Fri Nov 23 02:18:42 2007
From: gavron at wetwork.net (Ehud Gavron)
Date: Thu, 22 Nov 2007 18:18:42 -0700
Subject: mac80211 regression: doesn't associate automatically
In-Reply-To: <1195777405.11966.12.camel@dv>
References: <200711220912.10452.hs4233@mail.mn-solutions.de>
	<1195736752.6323.97.camel@johannes.berg>
	<20071122132635.GA3372@tuxdriver.com>
	<1195777405.11966.12.camel@dv>
Message-ID: <47462A72.8010303@wetwork.net>

I think this may be related.  If it isn't, my apologies for thread 
crapping.  If it is, I'm willing to do what I can to help find the 
problem and correct it.

I've had occasional troubles with all sorts of association related 
issues, and the only solution I've found is to remove the b43 module and 
reinsert it.
(modprobe -r b43 && sleep 1 && modprobe b43).

Here are different scenarios that are 100% reproducable:

FYI All of my house uses the same ESSID with the same WEP key and 
different channels (1,6,11 from one end to the other).

If I move from the living room (Ch1) to the bedroom (Ch11) then I am 
still associated to the Living Room AP.
***SOMETIMES*** a "iwconfig wlan0 ap off" will make it reassociate with 
the bedroom AP
***NEVER*** does an "iwconfig wlan0 essid same-essid" do anything
***SOMETIMES*** does an "iwconfig wlan0 essid no-such-essid && sleep 1 
&& iwconfig wlan0 essid origina-essid" works
***ALWAYS*** "modprobe -r b43 && sleep 1 && modprobe b43" works

If I move from the bedroom (Ch11) to the living room (Ch1) I DON'T NEED 
TO DO ANYTHING. 
All APs are buffalo airbridges with the same rev firmware.

I find similar symptoms at my Las Vegas hotel where I am this weekend. 

Here are the exact symptoms:
1. Link quality reads 0.  No iwconfig command will fix it (most of the 
time, sometimes the change of ESSID or ap off will fix it).
2. dmesg repeats: wlan0: authentication with AP 00:50:bf:b1:da:64 timed out
3. an iwlist wlan0 scan DOES show the active APs, but no matter which I 
choose none will associate
4. I just upgraded to F8 and am now using NM to manage the link (most of 
the time).  Most of the time it does work but every now and then (like 
here at the hotel after I rebooted the laptop) it will fail to connect.  
Symptoms #1 and #2 appear in the log, and the "modprobe -4/modprobe" 
fixes it.

I'm not sure if this is a mac80211 or a b43 bug... and if anyone has 
ideas to try I'm game.

Ehud



Pavel Roskin wrote:
> On Thu, 2007-11-22 at 08:26 -0500, John W. Linville wrote:
>
>   
>> As it stands, setting the SSID is the closest thing we have to an
>> "associate now" trigger.  I would have to advise distros and users to
>> always set it last in the wireless init, just before running dhclient
>> or whatever.
>>     
>
> Maybe mac80211 should have a "grace period" of 0.5 seconds or so to
> allow other settings to be set before the scanning starts?  The same
> applies to other events causing scanning, such as bringing up the
> interface.  It's too short to be noticeable, yet long enough for the
> next command to run even on slow systems.
>
> I think setting the key should not cause reassociation if there is an
> association.  It can break some schemes where the WEP key changes
> periodically on both sides.
>
>   


From proski at gnu.org  Fri Nov 23 02:26:05 2007
From: proski at gnu.org (Pavel Roskin)
Date: Thu, 22 Nov 2007 20:26:05 -0500
Subject: mac80211 regression: doesn't associate automatically
In-Reply-To: <47462A72.8010303@wetwork.net>
References: <200711220912.10452.hs4233@mail.mn-solutions.de>
	<1195736752.6323.97.camel@johannes.berg>
	<20071122132635.GA3372@tuxdriver.com> <1195777405.11966.12.camel@dv>
	<47462A72.8010303@wetwork.net>
Message-ID: <1195781165.11966.18.camel@dv>

On Thu, 2007-11-22 at 18:18 -0700, Ehud Gavron wrote:

> 2. dmesg repeats: wlan0: authentication with AP 00:50:bf:b1:da:64 timed out

I think it's an unrelated hardware specific issue.  mac80211 tried to
associate but failed.

-- 
Regards,
Pavel Roskin



From larry.finger at lwfinger.net  Fri Nov 23 06:36:55 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 22 Nov 2007 23:36:55 -0600
Subject: [PATCH V2] b43: Changes to enable BCM4311 rev 02 with wireless
	core revision 13
In-Reply-To: <200711221834.32026.mb@bu3sch.de>
References: <4744a544.OLz3JRLe85L+V2nd%Larry.Finger@lwfinger.net>
	<200711221834.32026.mb@bu3sch.de>
Message-ID: <474666F7.6090405@lwfinger.net>

Michael Buesch wrote:
> 
> partially acked.
> Though, I'm not quite sure yet why you remove that
> address extension bits. The specs clearly say that they _are_ there.
> And it makes sense to use them, as two bytes of the address are used
> for the routing stuff. So the highest 2 bits of the address have to be put
> somewhere else. That's the "Transmit Channel Control Word" and
> "Receive Channel Control Word" where 0x00030000 are the extension bits.
> 

The appropriate section of dmacontroller_setup() in my patched source is as follows:

        if (ring->tx) {
                if (ring->dma64) {
                        u64 ringbase = (u64) (ring->dmabase);

                        b43_dma_write(ring, B43_DMA64_TXCTL,
                                      B43_DMA64_TXENABLE);
                        b43_dma_write(ring, B43_DMA64_TXRINGLO,
                                      (ringbase & 0xFFFFFFFF));
                        b43_dma_write(ring, B43_DMA64_TXRINGHI,
                                      (ringbase >> 32));
                } else {
			...... untouched 32-bit stuff ....
		}
        } else {
                err = alloc_initial_descbuffers(ring);
                if (err)
                        goto out;
                if (ring->dma64) {
                        u64 ringbase = (u64) (ring->dmabase);

                        value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT)
                                | B43_DMA64_RXENABLE;
                        b43_dma_write(ring, B43_DMA64_RXCTL, value);
                        b43_dma_write(ring, B43_DMA64_RXRINGLO,
                                      (ringbase & 0xFFFFFFFF));
                        b43_dma_write(ring, B43_DMA64_RXRINGHI,
                                      (ringbase >> 32));
                        b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
                                      sizeof(struct b43_dmadesc64));
                } else {
			........... 32-bit stuff ........
	}

No address extensions are used here because the specs clearly state that a flat 64-bit address is
used to specify the Descriptor Ring address. My code matches the specs.

In the 64-bit fill_descriptor routine, the my patches result in the following code:

        addrlo = (u32) (dmaaddr & 0xFFFFFFFF);
        addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
        addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
            >> SSB_DMA_TRANSLATION_SHIFT;
        addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
        if (slot == ring->nr_slots - 1)
                ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
        if (start)
                ctl0 |= B43_DMA64_DCTL0_FRAMESTART;
        if (end)
                ctl0 |= B43_DMA64_DCTL0_FRAMEEND;
        if (irq)
                ctl0 |= B43_DMA64_DCTL0_IRQ;
        ctl1 |= (bufsize - ring->frameoffset)
            & B43_DMA64_DCTL1_BYTECNT;
        ctl1 |= (addrext << B43_DMA64_DCTL1_ADDREXT_SHIFT)
            & B43_DMA64_DCTL1_ADDREXT_MASK;

In this case, the specs do call for the upper two bits to be masked off the high 32 bits of the
address to be used for the routing code. These are saved in 'addrext' above. The routing bits, which
must be '10' for the 64-bit case, are then shifted into that 2-bit field, and the masked address
bits are encoded into the second control word 'ctl1' in the above snippet. As far as I can tell, my
code is doing exactly what the specs require - address extensions and all. If not, please show me
the error.

> However I do think that this might be related to the bug you are explaining
> in the comment:
>> +	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
>> +	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
>> +	 * which accounts for the GFP_DMA flag below.
>

Not true for two reasons. The first one is that it is the address of the ring buffer that is getting
the error, and that part does not use any extension bits. Secondly, the address extension stuff
would only apply if my computer had more than 2^(62) bytes of RAM, which is something like 10
billion GB - an amount that probably exceeds the total RAM in the world. As best I can tell, this
bug triggers when the Ring Buffer is placed above the 64-Megabyte level.

Larry




From larry.finger at lwfinger.net  Fri Nov 23 06:41:02 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 22 Nov 2007 23:41:02 -0600
Subject: timeout problems with certain APs and b43
In-Reply-To: <5b9417770711222031r28011e75v3a6eb4a7acdf2183@mail.gmail.com>
References: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>	
	<4744AEA1.9020705@lwfinger.net>
	<5b9417770711222031r28011e75v3a6eb4a7acdf2183@mail.gmail.com>
Message-ID: <474667EE.7060100@lwfinger.net>

John H. wrote:
> wrt54gs with latest firmware.
> 
> it seems exclusive to linux:O
> 
> On Nov 21, 2007 4:18 PM, Larry Finger <larry.finger at lwfinger.net> wrote:
>> John H. wrote:
>>>  uname -a
>>> Linux laptop 2.6.23.1-49.fc8 #1 SMP Thu Nov 8 21:41:26 EST 2007 i686
>>> i686 i386 GNU/Linux
>>> fedora 8
>>>
>>> on certain APs, the internet works for a long time then stops, and I
>>> get authentication time outs, why?  It usually works again if I reset
>>> the AP itself, which i should not have to do and don't have to if in
>>> XP....
>>>
>>>
>>> wlan0: switched to long barker preamble (BSSID=00:0f:66:53:3e:24)
>>> wlan0: switched to short barker preamble (BSSID=00:0f:66:53:3e:24)
>>>
>>>
>>>
>>> wlan0: Initial auth_alg=0
>>> wlan0: authenticate with AP 00:0f:66:53:3e:24
>>> wlan0: authenticate with AP 00:0f:66:53:3e:24
>>> wlan0: authenticate with AP 00:0f:66:53:3e:24
>>> wlan0: authentication with AP 00:0f:66:53:3e:24 timed out
>> Do you have the opportunity to capture the wireless traffic with a second computer using Kismet or
>> Wireshark when this condition occurs? Without that info, it would be hard to know what might be
>> wrong. Of course, I don't have the problem with either of my AP's.
>>
>> Could you identify the make/model and firmware revisions of any AP's that show this behavior?

Please do not top post!

The problem is not generic with Linksys AP's. I use a WRT54GL V1.1 and a WRT54G V5. Neither shows
the problem.

We need a dump of the wireless traffic when this condition occurs.

Larry


From janaum72 at yahoo.com  Fri Nov 23 09:39:24 2007
From: janaum72 at yahoo.com (Janny 777)
Date: Fri, 23 Nov 2007 00:39:24 -0800 (PST)
Subject: dell 1390 low signal quality
Message-ID: <732652.70168.qm@web57103.mail.re3.yahoo.com>

hi there,
I am using bcm43xx driver, and I was able to do
everything I wanted with this driver (running broadcom
wifi in linux, monitor mode, injection of packets)
Thanx for a great work.

One issue I am experiencing is low signal quality.
By accident I have windows installed on my dell laptop
and  after I wasn't able to associate with some APs in
linux I found out that I am able to connect to them in
windows.

What's the prob? I don't wanna use m$ for connecting
to wireless networks.

I am using 2.6.22.10 kernel
latest firmware revision 0x127 obtained from V3 driver
3.131.35.0
my chip id is 4311

Can you pls help me to solve this issue?


      ____________________________________________________________________________________
Get easy, one-click access to your favorites. 
Make Yahoo! your homepage.
http://www.yahoo.com/r/hs 


From hs4233 at mail.mn-solutions.de  Fri Nov 23 10:08:51 2007
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Fri, 23 Nov 2007 10:08:51 +0100
Subject: mac80211 regression: doesn't associate automatically
In-Reply-To: <47462A72.8010303@wetwork.net>
References: <200711220912.10452.hs4233@mail.mn-solutions.de>
	<1195777405.11966.12.camel@dv> <47462A72.8010303@wetwork.net>
Message-ID: <200711231008.52003.hs4233@mail.mn-solutions.de>

Do you have any logs of the APs, e.g. do they log that somebody 
tried to associate and failed?

Did you try a workaround to put all 3 APs to the same frequency? 
If you then observe the same problem, you could then use 
wireshark to capture a log of what happens "in the air". If the 
APs have different frequencies, then your monitoring WLAN card 
can't follow the maybe-roaming-card in sync, therefore use 
temporarily only one frequency.


From gmccullagh at gmail.com  Fri Nov 23 10:44:01 2007
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Fri, 23 Nov 2007 09:44:01 +0000
Subject: dell 1390 low signal quality
In-Reply-To: <732652.70168.qm@web57103.mail.re3.yahoo.com>
References: <732652.70168.qm@web57103.mail.re3.yahoo.com>
Message-ID: <20071123094400.GA32311@gmail.com>

Hi,

On Fri, 23 Nov 2007, Janny 777 wrote:

> One issue I am experiencing is low signal quality.
> By accident I have windows installed on my dell laptop
> and  after I wasn't able to associate with some APs in
> linux I found out that I am able to connect to them in
> windows.

The bcm43xx driver has been rewritten, as two drivers called b43 and
b43legacy (each uses a different firmware version) so bcm43xx is not really
being maintained any more.  

There is a bit of a break at the minute in that b43 has not yet made it
into stable linux kernels but bcm43xx is not being actively developed.

This email has rough instructions for how to get b43 working.

http://lists.berlios.de/pipermail/bcm43xx-dev/2007-November/006321.html

Gavin



From johannes at sipsolutions.net  Fri Nov 23 11:05:10 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 23 Nov 2007 11:05:10 +0100
Subject: timeout problems with certain APs and b43
In-Reply-To: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
	(sfid-20071121_193550_720363_FAED080D)
References: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
	(sfid-20071121_193550_720363_FAED080D)
Message-ID: <1195812310.4149.73.camel@johannes.berg>


> on certain APs, the internet works for a long time then stops, and I
> get authentication time outs, why?  It usually works again if I reset
> the AP itself, which i should not have to do and don't have to if in
> XP....

> wlan0: Initial auth_alg=0
> wlan0: authenticate with AP 00:0f:66:53:3e:24
> wlan0: authenticate with AP 00:0f:66:53:3e:24
> wlan0: authenticate with AP 00:0f:66:53:3e:24
> wlan0: authentication with AP 00:0f:66:53:3e:24 timed out

Does it help to reload the b43 module? I think I have seen this problem
before but always associated it with suspend/resume rather than a long
time elapsing, I also thought it was due to bad power recalibration.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071123/edac7da3/attachment.pgp>

From johannes at sipsolutions.net  Fri Nov 23 12:17:26 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 23 Nov 2007 12:17:26 +0100
Subject: [PATCH] b43-fwcutter: unsupported file support
Message-ID: <1195816647.4149.100.camel@johannes.berg>

This patch makes fwcutter support only those files we know are working
and marks the other one unsupported. To allow developers to still work
with such files, an --unsupported command line option is added that
allows one to extract firmware from such unsupported files. Some code
restructuring was necessary to support the --unsupported flag with other
flags in any order.

Also, because this is a significant change, bump the version number.

Signed-off-by: Johannes Berg <johannes at sipsolutions.net>
---
Feel free to leave out the version number change if you want to manage
that with git branches now or simply don't like the change :)

 fwcutter/Makefile        |    2 +-
 fwcutter/fwcutter.c      |   39 ++++++++++++++++++++++++++++++---------
 fwcutter/fwcutter.h      |   14 +++++++++++---
 fwcutter/fwcutter_list.h |    2 +-
 4 files changed, 43 insertions(+), 14 deletions(-)

--- a/fwcutter/Makefile
+++ b/fwcutter/Makefile
@@ -1,4 +1,4 @@
-VERSION = 008
+VERSION = 009
 
 CC ?= cc
 PREFIX ?= /usr/local
--- a/fwcutter/fwcutter.c
+++ b/fwcutter/fwcutter.c
@@ -59,6 +59,12 @@
 static struct cmdline_args cmdargs;
 
 
+/* check whether file will be listed/extracted from */
+static int file_ok(const struct file *f)
+{
+	return !(f->flags & FW_FLAG_UNSUPPORTED) || cmdargs.unsupported;
+}
+
 /* Convert a CPU-endian 16bit integer to Big-Endian */
 static be16_t to_be16(uint16_t v)
 {
@@ -398,7 +404,7 @@ static void extract_or_identify(FILE *f, const struct extract *extract,
 		exit(255);
 	}
 
-	if (!cmdargs.identify_only)
+	if (cmdargs.mode == FWCM_EXTRACT)
 		write_file(extract->name, buf, data_length, &hdr, flags);
 
 	free(buf);
@@ -449,10 +455,10 @@ static void print_supported_files(void)
 	       "<MD5 checksum>\n\n");
 	/* print for legacy driver first */
 	for (i = 0; i < FILES; i++)
-		if (!(files[i].flags & FW_FLAG_V4))
+		if (file_ok(&files[i]) && !(files[i].flags & FW_FLAG_V4))
 			print_file(&files[i]);
 	for (i = 0; i < FILES; i++)
-		if (files[i].flags & FW_FLAG_V4)
+		if (file_ok(&files[i]) && files[i].flags & FW_FLAG_V4)
 			print_file(&files[i]);
 	printf("\n");
 }
@@ -478,7 +484,8 @@ static const struct file *find_file(FILE *fd)
 		 signature[12], signature[13], signature[14], signature[15]);
 
 	for (i = 0; i < FILES; ++i) {
-		if (strcasecmp(md5sig, files[i].md5) == 0) {
+		if (file_ok(&files[i]) &&
+		    strcasecmp(md5sig, files[i].md5) == 0) {
 			printf("This file is recognised as:\n");
 			printf("  filename   :  %s\n", files[i].name);
 			printf("  version    :  %s\n", files[i].ucode_version);
@@ -497,6 +504,8 @@ static void print_usage(int argc, char *argv[])
 {
 	print_banner();
 	printf("\nUsage: %s [OPTION] [driver.sys]\n", argv[0]);
+	printf("  --unsupported         "
+	       "Allow working on extractable but unsupported drivers\n");
 	printf("  -l|--list             "
 	       "List supported driver versions\n");
 	printf("  -i|--identify         "
@@ -584,8 +593,8 @@ static int parse_args(int argc, char *argv[])
 	for (i = 1; i < argc; i++) {
 		res = cmp_arg(argv, &i, "--list", "-l", 0);
 		if (res == ARG_MATCH) {
-			print_supported_files();
-			return 1;
+			cmdargs.mode = FWCM_LIST;
+			continue;
 		} else if (res == ARG_ERROR)
 			goto out;
 
@@ -604,7 +613,14 @@ static int parse_args(int argc, char *argv[])
 
 		res = cmp_arg(argv, &i, "--identify", "-i", 0);
 		if (res == ARG_MATCH) {
-			cmdargs.identify_only = 1;
+			cmdargs.mode = FWCM_IDENTIFY;
+			continue;
+		} else if (res == ARG_ERROR)
+			goto out;
+
+		res = cmp_arg(argv, &i, "--unsupported", NULL, 0);
+		if (res == ARG_MATCH) {
+			cmdargs.unsupported = 1;
 			continue;
 		} else if (res == ARG_ERROR)
 			goto out;
@@ -620,7 +636,7 @@ static int parse_args(int argc, char *argv[])
 		break;
 	}
 
-	if (!cmdargs.infile)
+	if (!cmdargs.infile && cmdargs.mode != FWCM_LIST)
 		goto out_usage;
 	return 0;
 
@@ -645,6 +661,11 @@ int main(int argc, char *argv[])
 	else if (err != 0)
 		return err;
 
+	if (cmdargs.mode == FWCM_LIST) {
+		print_supported_files();
+		return 0;
+	}
+
 	fd = fopen(cmdargs.infile, "rb");
 	if (!fd) {
 		fprintf(stderr, "Cannot open input file %s\n", cmdargs.infile);
@@ -664,7 +685,7 @@ int main(int argc, char *argv[])
 	extract = file->extract;
 	while (extract->name) {
 		printf("%s %s/%s.fw\n",
-		       cmdargs.identify_only ? "Contains" : "Extracting",
+		       cmdargs.mode == FWCM_IDENTIFY ? "Contains" : "Extracting",
 		       dir, extract->name);
 		extract_or_identify(fd, extract, file->flags);
 		extract++;
--- a/fwcutter/fwcutter.h
+++ b/fwcutter/fwcutter.h
@@ -1,8 +1,9 @@
 #ifndef _FWCUTTER_H_
 #define _FWCUTTER_H_
 
-#define FW_FLAG_LE	0x01	/* little endian? convert */
-#define FW_FLAG_V4	0x02	/* b43 vs. b43legacy */
+#define FW_FLAG_LE		0x01	/* little endian? convert */
+#define FW_FLAG_V4		0x02	/* b43 vs. b43legacy */
+#define FW_FLAG_UNSUPPORTED	0x04	/* not supported/working */
 
 #define fwcutter_stringify_1(x)	#x
 #define fwcutter_stringify(x)	fwcutter_stringify_1(x)
@@ -20,10 +21,17 @@ typedef uint32_t be32_t; /* Big-endian 32bit */
 #define ARG_NOMATCH	1
 #define ARG_ERROR	-1
 
+enum fwcutter_mode {
+	FWCM_EXTRACT = 0,	/* default */
+	FWCM_LIST,
+	FWCM_IDENTIFY,
+};
+
 struct cmdline_args {
 	const char *infile;
 	const char *target_dir;
-	int identify_only;
+	enum fwcutter_mode mode;
+	int unsupported;
 };
 
 struct insn {
--- a/fwcutter/fwcutter_list.h
+++ b/fwcutter/fwcutter_list.h
@@ -147,7 +147,7 @@ static const struct file files[] =
 		.name		= "wl_ap.o",
 		.ucode_version	= "410.2160",
 		.md5		= "1e4763b4cb8cfbaae43e5c6d3d6b2ae7",
-		.flags		= FW_FLAG_LE | FW_FLAG_V4,
+		.flags		= FW_FLAG_LE | FW_FLAG_V4 | FW_FLAG_UNSUPPORTED,
 		.extract	= _1e4763b4cb8cfbaae43e5c6d3d6b2ae7,
 	},
 };




From johannes at sipsolutions.net  Fri Nov 23 12:21:59 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 23 Nov 2007 12:21:59 +0100
Subject: [PATCH] b43-fwcutter: make sparse happier
Message-ID: <1195816919.4149.104.camel@johannes.berg>

Just for the fun of it.

Signed-off-by: Johannes Berg <johannes at sipsolutions.net>
---
 fwcutter/fwcutter.c      |   12 ++++++------
 fwcutter/fwcutter_list.h |    8 ++++----
 2 files changed, 10 insertions(+), 10 deletions(-)

--- b43-tools.orig/fwcutter/fwcutter.c	2007-11-23 12:14:43.000000000 +0100
+++ b43-tools/fwcutter/fwcutter.c	2007-11-23 12:15:26.000000000 +0100
@@ -553,7 +553,7 @@ static int do_cmp_arg(char **argv, int *
 		if (param) {
 			/* Skip the parameter on the next iteration. */
 			(*pos)++;
-			if (*param == 0) {
+			if (!*param) {
 				printf("%s needs a parameter\n", arg);
 				return ARG_ERROR;
 			}
@@ -591,34 +591,34 @@ static int parse_args(int argc, char *ar
 	if (argc < 2)
 		goto out_usage;
 	for (i = 1; i < argc; i++) {
-		res = cmp_arg(argv, &i, "--list", "-l", 0);
+		res = cmp_arg(argv, &i, "--list", "-l", NULL);
 		if (res == ARG_MATCH) {
 			cmdargs.mode = FWCM_LIST;
 			continue;
 		} else if (res == ARG_ERROR)
 			goto out;
 
-		res = cmp_arg(argv, &i, "--version", "-v", 0);
+		res = cmp_arg(argv, &i, "--version", "-v", NULL);
 		if (res == ARG_MATCH) {
 			print_banner();
 			return 1;
 		} else if (res == ARG_ERROR)
 			goto out;
 
-		res = cmp_arg(argv, &i, "--help", "-h", 0);
+		res = cmp_arg(argv, &i, "--help", "-h", NULL);
 		if (res == ARG_MATCH)
 			goto out_usage;
 		else if (res == ARG_ERROR)
 			goto out;
 
-		res = cmp_arg(argv, &i, "--identify", "-i", 0);
+		res = cmp_arg(argv, &i, "--identify", "-i", NULL);
 		if (res == ARG_MATCH) {
 			cmdargs.mode = FWCM_IDENTIFY;
 			continue;
 		} else if (res == ARG_ERROR)
 			goto out;
 
-		res = cmp_arg(argv, &i, "--unsupported", NULL, 0);
+		res = cmp_arg(argv, &i, "--unsupported", NULL, NULL);
 		if (res == ARG_MATCH) {
 			cmdargs.unsupported = 1;
 			continue;
--- b43-tools.orig/fwcutter/fwcutter_list.h	2007-11-23 12:14:24.000000000 +0100
+++ b43-tools/fwcutter/fwcutter_list.h	2007-11-23 12:14:38.000000000 +0100
@@ -1,6 +1,6 @@
 
 /* file member lists */
-struct extract _e08665c5c5b66beb9c3b2dd54aa80cb3[] =
+static struct extract _e08665c5c5b66beb9c3b2dd54aa80cb3[] =
 {
 	{ .name = "ucode2", .offset = 0x59ca0, .length = 0x3fe0, .type = EXT_UCODE_1, },
 	{ .name = "ucode4", .offset = 0x5dc84, .length = 0x4e78, .type = EXT_UCODE_1, },
@@ -21,7 +21,7 @@ struct extract _e08665c5c5b66beb9c3b2dd5
 	EXTRACT_LIST_END
 };
 
-struct extract _9207bc565c2fc9fa1591f6c7911d3fc0[] =
+static struct extract _9207bc565c2fc9fa1591f6c7911d3fc0[] =
 {
 	{ .name = "ucode4",  .offset = 0x66220 +  0x7ad8, .length = 0x4e68, .type = EXT_UCODE_1, },
 	{ .name = "ucode5",  .offset = 0x66220 +  0xc944, .length = 0x5640, .type = EXT_UCODE_2, },
@@ -48,7 +48,7 @@ struct extract _9207bc565c2fc9fa1591f6c7
 	EXTRACT_LIST_END
 };
 
-struct extract _722e2e0d8cc04b8f118bb5afe6829ff9[] =
+static struct extract _722e2e0d8cc04b8f118bb5afe6829ff9[] =
 {
 	{ .name = "ucode4",  .offset = 0x76a10 +  0x8960, .length = 0x4e68, .type = EXT_UCODE_1, },
 	{ .name = "ucode5",  .offset = 0x76a10 +  0xd7cc, .length = 0x5640, .type = EXT_UCODE_2, },
@@ -75,7 +75,7 @@ struct extract _722e2e0d8cc04b8f118bb5af
 	EXTRACT_LIST_END
 };
 
-struct extract _1e4763b4cb8cfbaae43e5c6d3d6b2ae7[] =
+static struct extract _1e4763b4cb8cfbaae43e5c6d3d6b2ae7[] =
 {
 	{ .name = "ucode5",  .offset = 0x71c80 +  0xacd0, .length = 0x5768, .type = EXT_UCODE_2, },
 	{ .name = "ucode9",  .offset = 0x71c80 + 0x1043c, .length = 0x6240, .type = EXT_UCODE_2, },




From gavron at wetwork.net  Fri Nov 23 13:49:49 2007
From: gavron at wetwork.net (Ehud Gavron)
Date: Fri, 23 Nov 2007 05:49:49 -0700
Subject: mac80211 regression: doesn't associate automatically
In-Reply-To: <200711231008.52003.hs4233@mail.mn-solutions.de>
References: <200711220912.10452.hs4233@mail.mn-solutions.de>
	<1195777405.11966.12.camel@dv> <47462A72.8010303@wetwork.net>
	<200711231008.52003.hs4233@mail.mn-solutions.de>
Message-ID: <4746CC6D.7000807@wetwork.net>

Excellent suggestion.  I'll test that upon my return home and get back here.
Thanks!
E

Holger Schurig wrote:
> Do you have any logs of the APs, e.g. do they log that somebody 
> tried to associate and failed?
>
> Did you try a workaround to put all 3 APs to the same frequency? 
> If you then observe the same problem, you could then use 
> wireshark to capture a log of what happens "in the air". If the 
> APs have different frequencies, then your monitoring WLAN card 
> can't follow the maybe-roaming-card in sync, therefore use 
> temporarily only one frequency.
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   


From mark.hagger at m-spatial.com  Fri Nov 23 14:13:14 2007
From: mark.hagger at m-spatial.com (Mark Hagger)
Date: Fri, 23 Nov 2007 13:13:14 +0000
Subject: timeout problems with certain APs and b43
In-Reply-To: <1195812310.4149.73.camel@johannes.berg>
References: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
	<1195812310.4149.73.camel@johannes.berg>
Message-ID: <200711231313.14184.mark.hagger@m-spatial.com>

Interestingly I've been having the exact same issue here, and I too had 
thought it was the fact that I was suspend/resuming now and then (using tux 
on ice hibernate in fact).  Next time it happens I'll try a module reload 
instead of an AP reboot.

Mark


On Friday 23 November 2007, Johannes Berg wrote:
> > on certain APs, the internet works for a long time then stops, and I
> > get authentication time outs, why?  It usually works again if I reset
> > the AP itself, which i should not have to do and don't have to if in
> > XP....
> >
> > wlan0: Initial auth_alg=0
> > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > wlan0: authentication with AP 00:0f:66:53:3e:24 timed out
>
> Does it help to reload the b43 module? I think I have seen this problem
> before but always associated it with suspend/resume rather than a long
> time elapsing, I also thought it was due to bad power recalibration.
>
> johannes
>
> ________________________________________________________________________
> This email has been scanned for all known viruses by the MessageLabs
> SkyScan service.

________________________________________________________________________
This email has been scanned for all known viruses by the MessageLabs SkyScan service.


From mb at bu3sch.de  Fri Nov 23 14:47:18 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 23 Nov 2007 14:47:18 +0100
Subject: [PATCH V2] b43: Changes to enable BCM4311 rev 02 with wireless
	core revision 13
In-Reply-To: <474666F7.6090405@lwfinger.net>
References: <4744a544.OLz3JRLe85L+V2nd%Larry.Finger@lwfinger.net>
	<200711221834.32026.mb@bu3sch.de> <474666F7.6090405@lwfinger.net>
Message-ID: <200711231447.19262.mb@bu3sch.de>

On Friday 23 November 2007 06:36:55 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > partially acked.
> > Though, I'm not quite sure yet why you remove that
> > address extension bits. The specs clearly say that they _are_ there.
> > And it makes sense to use them, as two bytes of the address are used
> > for the routing stuff. So the highest 2 bits of the address have to be put
> > somewhere else. That's the "Transmit Channel Control Word" and
> > "Receive Channel Control Word" where 0x00030000 are the extension bits.
> > 
> 
> The appropriate section of dmacontroller_setup() in my patched source is as follows:
> 
>         if (ring->tx) {
>                 if (ring->dma64) {
>                         u64 ringbase = (u64) (ring->dmabase);
> 
>                         b43_dma_write(ring, B43_DMA64_TXCTL,
>                                       B43_DMA64_TXENABLE);
>                         b43_dma_write(ring, B43_DMA64_TXRINGLO,
>                                       (ringbase & 0xFFFFFFFF));
>                         b43_dma_write(ring, B43_DMA64_TXRINGHI,
>                                       (ringbase >> 32));
>                 } else {
> 			...... untouched 32-bit stuff ....
> 		}
>         } else {
>                 err = alloc_initial_descbuffers(ring);
>                 if (err)
>                         goto out;
>                 if (ring->dma64) {
>                         u64 ringbase = (u64) (ring->dmabase);
> 
>                         value = (ring->frameoffset << B43_DMA64_RXFROFF_SHIFT)
>                                 | B43_DMA64_RXENABLE;
>                         b43_dma_write(ring, B43_DMA64_RXCTL, value);
>                         b43_dma_write(ring, B43_DMA64_RXRINGLO,
>                                       (ringbase & 0xFFFFFFFF));
>                         b43_dma_write(ring, B43_DMA64_RXRINGHI,
>                                       (ringbase >> 32));
>                         b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
>                                       sizeof(struct b43_dmadesc64));
>                 } else {
> 			........... 32-bit stuff ........
> 	}
> 
> No address extensions are used here because the specs clearly state that a flat 64-bit address is
> used to specify the Descriptor Ring address. My code matches the specs.

I'm not sure which specifications you use, but here it clearly describes the
extension bits:
http://bcm-v4.sipsolutions.net/802.11/DMA#TransmitChannelControlWord-1

> > However I do think that this might be related to the bug you are explaining
> > in the comment:
> >> +	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
> >> +	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
> >> +	 * which accounts for the GFP_DMA flag below.

> the error, and that part does not use any extension bits. Secondly, the address extension stuff
> would only apply if my computer had more than 2^(62) bytes of RAM, which is something like 10
> billion GB - an amount that probably exceeds the total RAM in the world.

This is not true. We live in a world with IO-MMUs.

-- 
Greetings Michael.


From mb at bu3sch.de  Fri Nov 23 14:50:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 23 Nov 2007 14:50:51 +0100
Subject: [PATCH] b43: include full 64-bit timestamp in monitor mode
Message-ID: <200711231450.52403.mb@bu3sch.de>

From: Johannes Berg <johannes at sipsolutions.net>

When monitor mode is enabled, this will make b43 read out the
full 64-bit MAC time from the chip for each received packet.

Signed-off-by: Johannes Berg <johannes at sipsolutions.net>
Signed-off-by: Michael Buesch <mb at bu3sch.de>

---
 drivers/net/wireless/b43/b43.h  |    2 ++
 drivers/net/wireless/b43/main.c |    2 ++
 drivers/net/wireless/b43/xmit.c |   18 +++++++++++++++++-
 3 files changed, 21 insertions(+), 1 deletion(-)

--- everything.orig/drivers/net/wireless/b43/b43.h	2007-11-22 22:56:20.648678709 +0100
+++ everything/drivers/net/wireless/b43/b43.h	2007-11-22 23:03:27.268675020 +0100
@@ -635,6 +635,8 @@ struct b43_wl {
 	/* List of all wireless devices on this chip */
 	struct list_head devlist;
 	u8 nr_devs;
+
+	bool radiotap_enabled;
 };
 
 /* Pointers to the firmware data and meta information about it. */
--- everything.orig/drivers/net/wireless/b43/main.c	2007-11-22 22:55:49.608678981 +0100
+++ everything/drivers/net/wireless/b43/main.c	2007-11-22 23:03:53.678676051 +0100
@@ -2853,6 +2853,8 @@ static int b43_op_config(struct ieee8021
 			b43_short_slot_timing_disable(dev);
 	}
 
+	dev->wl->radiotap_enabled = !!(conf->flags & IEEE80211_CONF_RADIOTAP);
+
 	/* Adjust the desired TX power level. */
 	if (conf->power_level != 0) {
 		if (conf->power_level != phy->power_level) {
--- everything.orig/drivers/net/wireless/b43/xmit.c	2007-11-22 22:54:33.498725965 +0100
+++ everything/drivers/net/wireless/b43/xmit.c	2007-11-22 23:15:44.808681966 +0100
@@ -526,7 +526,23 @@ void b43_rx(struct b43_wldev *dev, struc
 	else
 		status.rate = b43_plcp_get_bitrate_cck(plcp);
 	status.antenna = !!(phystat0 & B43_RX_PHYST0_ANT);
-	status.mactime = mactime;
+
+	/*
+	 * If monitors are present get full 64-bit timestamp. This
+	 * code assumes we get to process the packet within 16 bits
+	 * of timestamp, i.e. about 65 milliseconds after the PHY
+	 * received the first symbol.
+	 */
+	if (dev->wl->radiotap_enabled) {
+		u16 low_mactime_now;
+
+		b43_tsf_read(dev, &status.mactime);
+		low_mactime_now = status.mactime;
+		status.mactime = status.mactime & ~0xFFFFULL;
+		status.mactime += mactime;
+		if (low_mactime_now <= mactime)
+			status.mactime -= 0x10000;
+	}
 
 	chanid = (chanstat & B43_RX_CHAN_ID) >> B43_RX_CHAN_ID_SHIFT;
 	switch (chanstat & B43_RX_CHAN_PHYTYPE) {




-------------------------------------------------------

-- 
Greetings Michael.


From mb at bu3sch.de  Fri Nov 23 14:54:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 23 Nov 2007 14:54:48 +0100
Subject: [PATCH] b43-fwcutter: unsupported file support
In-Reply-To: <1195816647.4149.100.camel@johannes.berg>
References: <1195816647.4149.100.camel@johannes.berg>
Message-ID: <200711231454.48714.mb@bu3sch.de>

On Friday 23 November 2007 12:17:26 Johannes Berg wrote:
> This patch makes fwcutter support only those files we know are working
> and marks the other one unsupported. To allow developers to still work
> with such files, an --unsupported command line option is added that
> allows one to extract firmware from such unsupported files. Some code
> restructuring was necessary to support the --unsupported flag with other
> flags in any order.
> 
> Also, because this is a significant change, bump the version number.
> 
> Signed-off-by: Johannes Berg <johannes at sipsolutions.net>

Applied, thanks.

-- 
Greetings Michael.


From mb at bu3sch.de  Fri Nov 23 14:54:59 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 23 Nov 2007 14:54:59 +0100
Subject: [PATCH] b43-fwcutter: make sparse happier
In-Reply-To: <1195816919.4149.104.camel@johannes.berg>
References: <1195816919.4149.104.camel@johannes.berg>
Message-ID: <200711231455.00128.mb@bu3sch.de>

On Friday 23 November 2007 12:21:59 Johannes Berg wrote:
> Just for the fun of it.
> 
> Signed-off-by: Johannes Berg <johannes at sipsolutions.net>
> ---

Applied, thanks.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Fri Nov 23 16:25:14 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 23 Nov 2007 09:25:14 -0600
Subject: dell 1390 low signal quality
In-Reply-To: <732652.70168.qm@web57103.mail.re3.yahoo.com>
References: <732652.70168.qm@web57103.mail.re3.yahoo.com>
Message-ID: <4746F0DA.3060506@lwfinger.net>

Janny 777 wrote:
> hi there,
> I am using bcm43xx driver, and I was able to do
> everything I wanted with this driver (running broadcom
> wifi in linux, monitor mode, injection of packets)
> Thanx for a great work.
> 
> One issue I am experiencing is low signal quality.
> By accident I have windows installed on my dell laptop
> and  after I wasn't able to associate with some APs in
> linux I found out that I am able to connect to them in
> windows.
> 
> What's the prob? I don't wanna use m$ for connecting
> to wireless networks.
> 
> I am using 2.6.22.10 kernel
> latest firmware revision 0x127 obtained from V3 driver
> 3.131.35.0
> my chip id is 4311
> 
> Can you pls help me to solve this issue?

The solution is easy. Switch to 2.6.24-rc3 and use the b43 driver. With that combination, I get
higher throughput under Linux than I get from Windows XP.

Larry


From ftoledo at docksud.com.ar  Fri Nov 23 20:31:50 2007
From: ftoledo at docksud.com.ar (Fernando Toledo)
Date: Fri, 23 Nov 2007 16:31:50 -0300
Subject: timeout problems with certain APs and b43
In-Reply-To: <4744AEA1.9020705@lwfinger.net>
References: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
	<4744AEA1.9020705@lwfinger.net>
Message-ID: <200711231631.50577.ftoledo@docksud.com.ar>

El Mi? 21 Nov 2007, Larry Finger escribi?:
> John H. wrote:
> >  uname -a
> > Linux laptop 2.6.23.1-49.fc8 #1 SMP Thu Nov 8 21:41:26 EST 2007 i686
> > i686 i386 GNU/Linux
> > fedora 8
> >
> > on certain APs, the internet works for a long time then stops, and I
> > get authentication time outs, why?  It usually works again if I reset
> > the AP itself, which i should not have to do and don't have to if in
> > XP....
> >
> >
> > wlan0: switched to long barker preamble (BSSID=00:0f:66:53:3e:24)
> > wlan0: switched to short barker preamble (BSSID=00:0f:66:53:3e:24)
> >
> >
> >
> > wlan0: Initial auth_alg=0
> > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > wlan0: authentication with AP 00:0f:66:53:3e:24 timed out
>
> Do you have the opportunity to capture the wireless traffic with a second
> computer using Kismet or Wireshark when this condition occurs? Without that
> info, it would be hard to know what might be wrong. Of course, I don't have
> the problem with either of my AP's.
>
> Could you identify the make/model and firmware revisions of any AP's that
> show this behavior?
>
> Larry
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev

i also have same problem with dlink ap900 
i will test on next week


-- 
Dock Sud BBS
http://www.docksud.com.ar
telnet://bbs.docksud.com.ar
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part.
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071123/221249b9/attachment.pgp>

From rjw at sisk.pl  Fri Nov 23 22:58:24 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Fri, 23 Nov 2007 22:58:24 +0100
Subject: timeout problems with certain APs and b43
In-Reply-To: <1195812310.4149.73.camel@johannes.berg>
References: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
	<1195812310.4149.73.camel@johannes.berg>
Message-ID: <200711232258.25965.rjw@sisk.pl>

On Friday, 23 of November 2007, Johannes Berg wrote:
> 
> > on certain APs, the internet works for a long time then stops, and I
> > get authentication time outs, why?  It usually works again if I reset
> > the AP itself, which i should not have to do and don't have to if in
> > XP....
> 
> > wlan0: Initial auth_alg=0
> > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > wlan0: authentication with AP 00:0f:66:53:3e:24 timed out
> 
> Does it help to reload the b43 module? I think I have seen this problem
> before but always associated it with suspend/resume rather than a long
> time elapsing, I also thought it was due to bad power recalibration.

It seems that I can reproduce something similar on demand with an SMC wireless
router by moving my box sufficiently far away from it. :-)

Greetings,
Rafael


From johannes at sipsolutions.net  Fri Nov 23 22:57:30 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 23 Nov 2007 22:57:30 +0100
Subject: timeout problems with certain APs and b43
In-Reply-To: <200711232258.25965.rjw@sisk.pl>
	(sfid-20071123_214335_768868_45E88660)
References: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
	<1195812310.4149.73.camel@johannes.berg>
	<200711232258.25965.rjw@sisk.pl>
	(sfid-20071123_214335_768868_45E88660)
Message-ID: <1195855050.4149.179.camel@johannes.berg>


> > > on certain APs, the internet works for a long time then stops, and I
> > > get authentication time outs, why?  It usually works again if I reset
> > > the AP itself, which i should not have to do and don't have to if in
> > > XP....
> > 
> > > wlan0: Initial auth_alg=0
> > > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > > wlan0: authentication with AP 00:0f:66:53:3e:24 timed out
> > 
> > Does it help to reload the b43 module? I think I have seen this problem
> > before but always associated it with suspend/resume rather than a long
> > time elapsing, I also thought it was due to bad power recalibration.
> 
> It seems that I can reproduce something similar on demand with an SMC wireless
> router by moving my box sufficiently far away from it. :-)

Well, yeah, that's expected though, you lose signal at some point. Not
expected is that it happens without moving anything. Unless the
calibration code is wrong which wouldn't really surprise me either.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071123/b5c15265/attachment.pgp>

From rjw at sisk.pl  Fri Nov 23 23:21:56 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Fri, 23 Nov 2007 23:21:56 +0100
Subject: timeout problems with certain APs and b43
In-Reply-To: <1195855050.4149.179.camel@johannes.berg>
References: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
	<200711232258.25965.rjw@sisk.pl>
	<1195855050.4149.179.camel@johannes.berg>
Message-ID: <200711232321.58516.rjw@sisk.pl>

On Friday, 23 of November 2007, Johannes Berg wrote:
> 
> > > > on certain APs, the internet works for a long time then stops, and I
> > > > get authentication time outs, why?  It usually works again if I reset
> > > > the AP itself, which i should not have to do and don't have to if in
> > > > XP....
> > > 
> > > > wlan0: Initial auth_alg=0
> > > > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > > > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > > > wlan0: authenticate with AP 00:0f:66:53:3e:24
> > > > wlan0: authentication with AP 00:0f:66:53:3e:24 timed out
> > > 
> > > Does it help to reload the b43 module? I think I have seen this problem
> > > before but always associated it with suspend/resume rather than a long
> > > time elapsing, I also thought it was due to bad power recalibration.
> > 
> > It seems that I can reproduce something similar on demand with an SMC wireless
> > router by moving my box sufficiently far away from it. :-)
> 
> Well, yeah, that's expected though, you lose signal at some point. Not
> expected is that it happens without moving anything. Unless the
> calibration code is wrong which wouldn't really surprise me either.

In my case, everything works just fine when the box is 6 meters away from the
AP (including a thick wall in between), but when I move it another 5-6 meters
away from the AP, things break down ...

I'd expect it to work at longer distances, but well. :-)

Greetings,
Rafael


From johannes at sipsolutions.net  Sat Nov 24 09:35:31 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Sat, 24 Nov 2007 09:35:31 +0100
Subject: timeout problems with certain APs and b43
In-Reply-To: <200711232321.58516.rjw@sisk.pl>
References: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
	<200711232258.25965.rjw@sisk.pl>
	<1195855050.4149.179.camel@johannes.berg>
	<200711232321.58516.rjw@sisk.pl>
Message-ID: <1195893331.4149.190.camel@johannes.berg>


> > > It seems that I can reproduce something similar on demand with an SMC wireless
> > > router by moving my box sufficiently far away from it. :-)
> > 
> > Well, yeah, that's expected though, you lose signal at some point. Not
> > expected is that it happens without moving anything. Unless the
> > calibration code is wrong which wouldn't really surprise me either.
> 
> In my case, everything works just fine when the box is 6 meters away from the
> AP (including a thick wall in between), but when I move it another 5-6 meters
> away from the AP, things break down ...
> 
> I'd expect it to work at longer distances, but well. :-)

Yeah, but keep in mind we reverse engineered all the calibration code.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071124/2f9dae53/attachment.pgp>

From rjw at sisk.pl  Sat Nov 24 12:17:37 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Sat, 24 Nov 2007 12:17:37 +0100
Subject: timeout problems with certain APs and b43
In-Reply-To: <1195893331.4149.190.camel@johannes.berg>
References: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
	<200711232321.58516.rjw@sisk.pl>
	<1195893331.4149.190.camel@johannes.berg>
Message-ID: <200711241217.38559.rjw@sisk.pl>

On Saturday, 24 of November 2007, Johannes Berg wrote:
> 
> > > > It seems that I can reproduce something similar on demand with an SMC wireless
> > > > router by moving my box sufficiently far away from it. :-)
> > > 
> > > Well, yeah, that's expected though, you lose signal at some point. Not
> > > expected is that it happens without moving anything. Unless the
> > > calibration code is wrong which wouldn't really surprise me either.
> > 
> > In my case, everything works just fine when the box is 6 meters away from the
> > AP (including a thick wall in between), but when I move it another 5-6 meters
> > away from the AP, things break down ...
> > 
> > I'd expect it to work at longer distances, but well. :-)
> 
> Yeah, but keep in mind we reverse engineered all the calibration code.

Sure. :-)

For me it's not a problem (everywhere I use the wireless, there are APs close
enough ;-)), but it seems related to what's been reported in this thread.

Greetings,
Rafael


From mark.hagger at m-spatial.com  Sat Nov 24 14:35:28 2007
From: mark.hagger at m-spatial.com (Mark Hagger)
Date: Sat, 24 Nov 2007 13:35:28 +0000
Subject: timeout problems with certain APs and b43
In-Reply-To: <200711241217.38559.rjw@sisk.pl>
References: <5b9417770711211135p65eab873leef65cd0e71452aa@mail.gmail.com>
	<1195893331.4149.190.camel@johannes.berg>
	<200711241217.38559.rjw@sisk.pl>
Message-ID: <200711241335.28177.mark.hagger@m-spatial.com>

> On Saturday, 24 of November 2007, Johannes Berg wrote:
> >
> > Yeah, but keep in mind we reverse engineered all the calibration code.

Ah, I assume thats why the signal strength numbers etc are not really correct 
at all, ie even when my laptop is a metre from the AP its only showing 47% or 
so signal strength, whereas with XP/ndiswrapper its 100% up to many metres 
away.  I had wondered about that.

Mark

________________________________________________________________________
This email has been scanned for all known viruses by the MessageLabs SkyScan service.


From mb at bu3sch.de  Sat Nov 24 15:06:33 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 24 Nov 2007 15:06:33 +0100
Subject: [PATCH] b43: include FCS in frames handed to mac80211
Message-ID: <200711241506.33414.mb@bu3sch.de>

From: Johannes Berg <johannes at sipsolutions.net>

Sometimes it can be useful to see the FCS, especially when
bad-FCS frames are shown. Pass the FCS to mac80211 and let
it worry about snipping it off when required.

Signed-off-by: Johannes Berg <johannes at sipsolutions.net>
Signed-off-by: Michael Buesch <mb at bu3sch.de>

---
 drivers/net/wireless/b43/main.c |    3 ++-
 drivers/net/wireless/b43/xmit.c |    1 -
 2 files changed, 2 insertions(+), 2 deletions(-)

--- everything.orig/drivers/net/wireless/b43/main.c	2007-11-22 23:35:41.208716199 +0100
+++ everything/drivers/net/wireless/b43/main.c	2007-11-22 23:36:03.138677951 +0100
@@ -4158,7 +4158,8 @@ static int b43_wireless_init(struct ssb_
 	}
 
 	/* fill hw info */
-	hw->flags = IEEE80211_HW_HOST_GEN_BEACON_TEMPLATE;
+	hw->flags = IEEE80211_HW_HOST_GEN_BEACON_TEMPLATE |
+		    IEEE80211_HW_RX_INCLUDES_FCS;
 	hw->max_signal = 100;
 	hw->max_rssi = -110;
 	hw->max_noise = -110;
--- everything.orig/drivers/net/wireless/b43/xmit.c	2007-11-22 23:36:05.668676810 +0100
+++ everything/drivers/net/wireless/b43/xmit.c	2007-11-22 23:36:22.668677190 +0100
@@ -489,7 +489,6 @@ void b43_rx(struct b43_wldev *dev, struc
 	}
 	wlhdr = (struct ieee80211_hdr *)(skb->data);
 	fctl = le16_to_cpu(wlhdr->frame_control);
-	skb_trim(skb, skb->len - FCS_LEN);
 
 	if (macstat & B43_RX_MAC_DEC) {
 		unsigned int keyidx;




-------------------------------------------------------

-- 
Greetings Michael.


From mb at bu3sch.de  Sun Nov 25 11:10:33 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 25 Nov 2007 11:10:33 +0100
Subject: [PATCH] b43: reinit on too many PHY TX errors
Message-ID: <200711251110.33613.mb@bu3sch.de>

From: Stefano Brivio <stefano.brivio at polimi.it>

Restart the hardware on too many PHY TX errors. A thousand PHY TX errors
per 15 seconds means we won't be able to recover for sure.

Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h
+++ wireless-2.6/drivers/net/wireless/b43/b43.h
@@ -391,6 +391,8 @@ enum {
 #define B43_DEFAULT_SHORT_RETRY_LIMIT	7
 #define B43_DEFAULT_LONG_RETRY_LIMIT	4
 
+#define B43_PHY_TX_BADNESS_LIMIT	1000
+
 /* Max size of a security key */
 #define B43_SEC_KEYSIZE			16
 /* Security algorithms. */
@@ -546,6 +548,9 @@ struct b43_phy {
 	/* OFDM address read/write caching for hardware auto-increment. */
 	u16 ofdm_addr;
 	u8 ofdm_valid; /* 0: invalid, 1: read, 2: write */
+
+	/* PHY TX errors counter. */
+	atomic_t txerr_cnt;
 };
 
 /* Data structures for DMA transmission, per 80211 core. */
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -1394,8 +1394,17 @@ static void b43_interrupt_tasklet(struct
 	if (unlikely(reason & B43_IRQ_MAC_TXERR))
 		b43err(dev->wl, "MAC transmission error\n");
 
-	if (unlikely(reason & B43_IRQ_PHY_TXERR))
+	if (unlikely(reason & B43_IRQ_PHY_TXERR)) {
 		b43err(dev->wl, "PHY transmission error\n");
+		rmb();
+		if (unlikely(atomic_dec_and_test(&dev->phy.txerr_cnt))) {
+			atomic_set(&dev->phy.txerr_cnt,
+				   B43_PHY_TX_BADNESS_LIMIT);
+			b43err(dev->wl, "Too many PHY TX errors, "
+					"restarting the controller\n");
+			b43_controller_restart(dev, "PHY TX errors");
+		}
+	}
 
 	if (unlikely(merged_dma_reason & (B43_DMAIRQ_FATALMASK |
 					  B43_DMAIRQ_NONFATALMASK))) {
@@ -2259,6 +2268,9 @@ static int b43_chip_init(struct b43_wlde
 	/* OFDM address caching. */
 	phy->ofdm_valid = 0;
 
+	/* PHY TX errors counter. */
+	atomic_set(&phy->txerr_cnt, B43_PHY_TX_BADNESS_LIMIT);
+
 	err = 0;
 	b43dbg(dev->wl, "Chip initialized\n");
 out:
@@ -2344,6 +2356,9 @@ static void b43_periodic_every15sec(stru
 	}
 	b43_phy_xmitpower(dev);	//FIXME: unless scanning?
 	//TODO for APHY (temperature?)
+
+	atomic_set(&phy->txerr_cnt, B43_PHY_TX_BADNESS_LIMIT);
+	wmb();
 }
 
 static void do_periodic_work(struct b43_wldev *dev)


-------------------------------------------------------

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sun Nov 25 16:54:49 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 25 Nov 2007 09:54:49 -0600
Subject: [PATCH] b43: reinit on too many PHY TX errors
In-Reply-To: <200711251110.33613.mb@bu3sch.de>
References: <200711251110.33613.mb@bu3sch.de>
Message-ID: <47499AC9.9060703@lwfinger.net>

Michael Buesch wrote:
> From: Stefano Brivio <stefano.brivio at polimi.it>
> 
> Restart the hardware on too many PHY TX errors. A thousand PHY TX errors
> per 15 seconds means we won't be able to recover for sure

Do we know what causes the PHY TX errors? On the BCM4311/2, I always get one that I have not been 
able to fix.

Larry




From larry.finger at lwfinger.net  Mon Nov 26 02:26:38 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 25 Nov 2007 19:26:38 -0600
Subject: [Bug 9414] Not work light of button-led with module b43 in chipset
	broadcom 4318
In-Reply-To: <20071125212527.6645610806E@picon.linux-foundation.org>
References: <20071125212527.6645610806E@picon.linux-foundation.org>
Message-ID: <474A20CE.3020307@lwfinger.net>

Michael and Ivo,

I have done a little looking into the problem of the radio LED not coming on, and have found the
following:

1. The call-back routine b43_rfkill_soft_toggle() is called once. When called, rfkill.registered is
zero and the routine exits immediately.

2. The call-back routine b43_rfkill_poll() is never called, and the switch that controls the radio
is never tested.

3. There is a log message "input: Unspecified device as /class/input/input7", which I think arises
from the rfkill registration.

I have the necessary hardware and am willing to test any suggested changes.

Larry


From johannes at sipsolutions.net  Mon Nov 26 09:56:54 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 26 Nov 2007 09:56:54 +0100
Subject: [Bug 9414] Not work light of button-led with module b43 in
	chipset broadcom 4318
In-Reply-To: <474A20CE.3020307@lwfinger.net>
	(sfid-20071126_012725_498911_251D6C29)
References: <20071125212527.6645610806E@picon.linux-foundation.org>
	<474A20CE.3020307@lwfinger.net> (sfid-20071126_012725_498911_251D6C29)
Message-ID: <1196067415.4149.245.camel@johannes.berg>


> I have done a little looking into the problem of the radio LED not coming on, and have found the
> following:

[...]

Do you have /sys/class/leds/b43-phyN:radio? If so, what does the trigger
file contain? Maybe the LED is registered in the wrong order and the
default name was NULL?

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071126/dda24008/attachment.pgp>

From gmccullagh at gmail.com  Mon Nov 26 11:42:32 2007
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Mon, 26 Nov 2007 10:42:32 +0000
Subject: crash with b43 wireless-2.6
Message-ID: <20071126104232.GC20226@gmail.com>

Hi,

I have a Belkin F5D7011 which contains a bcm4306 chip.  Full lspci is
attached.

I'm using the wireless-2.6 tree, was last updated and recompiled on
7/11/2007.  

This card may suffer from Bug 9414, in that the LEDs don't come on at all
but I'm not so pushed about that.  Curiously my bcm4318 airforce one
doesn't seem to have issues with LEDs.

In the past few minutes I associated it with the open access point in our
building here, then moved to a different room slightly further away from
the access point.  Network manager then seemed to indicate (with the
swirling icon thing) that it had lost contact with the access point.  My
machine froze at this point, mouse not moving, nothing.  I eventually hit
<ctl><alt><sysrq>s, <ctl><alt><sysrq>b.

I'm attaching the syslog information and lspci.  I can report this on
bugzilla but I just thought I'd try to ask first if this issue is known or
fixed and if it is in fact a problem with b43 or with network-manager.  Let
me know if there's any more info which I should report too.

I'm hoping to run a git-pull to update the tree shortly.

Gavin

-------------- next part --------------


=================================================================================
00:00.0 Host bridge: Intel Corporation 440BX/ZX/DX - 82443BX/ZX/DX Host bridge (rev 03)
	Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B-
	Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort+ >SERR- <PERR-
	Latency: 64
	Region 0: Memory at f8000000 (32-bit, prefetchable) [size=64M]
	Capabilities: [a0] AGP version 1.0
		Status: RQ=32 Iso- ArqSz=0 Cal=0 SBA+ ITACoh- GART64- HTrans- 64bit- FW- AGP3- Rate=x1,x2
		Command: RQ=1 ArqSz=0 Cal=0 SBA- AGP- GART64- 64bit- FW- Rate=<none>

00:01.0 PCI bridge: Intel Corporation 440BX/ZX/DX - 82443BX/ZX/DX AGP bridge (rev 03) (prog-if 00 [Normal decode])
	Control: I/O+ Mem+ BusMaster+ SpecCycle+ MemWINV+ VGASnoop- ParErr- Stepping- SERR- FastB2B-
	Status: Cap- 66MHz+ UDF- FastB2B- ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
	Latency: 128
	Bus: primary=00, secondary=01, subordinate=01, sec-latency=64
	I/O behind bridge: 0000e000-0000efff
	Memory behind bridge: fd000000-fecfffff
	Prefetchable memory behind bridge: 28000000-280fffff
	Secondary status: 66MHz+ FastB2B+ ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort+ <SERR- <PERR-
	BridgeCtl: Parity- SERR- NoISA+ VGA+ MAbort- >Reset- FastB2B+

00:07.0 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ISA (rev 02)
	Control: I/O+ Mem+ BusMaster+ SpecCycle+ MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
	Status: Cap- 66MHz- UDF- FastB2B+ ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
	Latency: 0

00:07.1 IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01) (prog-if 80 [Master])
	Control: I/O+ Mem- BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
	Status: Cap- 66MHz- UDF- FastB2B+ ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
	Latency: 64
	Region 0: [virtual] Memory at 000001f0 (32-bit, non-prefetchable) [disabled] [size=8]
	Region 1: [virtual] Memory at 000003f0 (type 3, non-prefetchable) [disabled] [size=1]
	Region 2: [virtual] Memory at 00000170 (32-bit, non-prefetchable) [disabled] [size=8]
	Region 3: [virtual] Memory at 00000370 (type 3, non-prefetchable) [disabled] [size=1]
	Region 4: I/O ports at fcd0 [size=16]

00:07.2 USB Controller: Intel Corporation 82371AB/EB/MB PIIX4 USB (rev 01) (prog-if 00 [UHCI])
	Control: I/O+ Mem- BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
	Status: Cap- 66MHz- UDF- FastB2B+ ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
	Latency: 64
	Interrupt: pin D routed to IRQ 11
	Region 4: I/O ports at fce0 [size=32]

00:07.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)
	Control: I/O+ Mem+ BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
	Status: Cap- 66MHz- UDF- FastB2B+ ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
	Interrupt: pin ? routed to IRQ 9

00:08.0 Multimedia audio controller: Cirrus Logic Crystal CS4281 PCI Audio (rev 01)
	Subsystem: Dell Unknown device 00dc
	Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
	Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
	Latency: 64 (1000ns min, 6000ns max)
	Interrupt: pin A routed to IRQ 10
	Region 0: Memory at fedef000 (32-bit, non-prefetchable) [size=4K]
	Region 1: Memory at fedf0000 (32-bit, non-prefetchable) [size=64K]
	Capabilities: [40] Power Management version 2
		Flags: PMEClk- DSI+ D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold-)
		Status: D0 PME-Enable- DSel=0 DScale=0 PME+

00:0a.0 CardBus bridge: Texas Instruments PCI1410 PC card Cardbus Controller (rev 01)
	Subsystem: Dell Unknown device 00dc
	Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
	Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
	Latency: 168, Cache Line Size: 128 bytes
	Interrupt: pin A routed to IRQ 10
	Region 0: Memory at 28120000 (32-bit, non-prefetchable) [size=4K]
	Bus: primary=00, secondary=02, subordinate=05, sec-latency=176
	Memory window 0: 20000000-23fff000 (prefetchable)
	Memory window 1: 24000000-27fff000
	I/O window 0: 00001000-000010ff
	I/O window 1: 00001400-000014ff
	BridgeCtl: Parity- SERR- ISA- VGA- MAbort- >Reset- 16bInt- PostWrite+
	16-bit legacy interface ports at 0001

00:0d.0 Ethernet controller: 3Com Corporation 3c905C-TX/TX-M [Tornado] (rev 78)
	Subsystem: Dell Unknown device 00dc
	Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV+ VGASnoop- ParErr- Stepping- SERR- FastB2B-
	Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
	Latency: 80 (2500ns min, 2500ns max), Cache Line Size: 32 bytes
	Interrupt: pin A routed to IRQ 10
	Region 0: I/O ports at fc00 [size=128]
	Region 1: Memory at fededc00 (32-bit, non-prefetchable) [size=128]
	[virtual] Expansion ROM at 28100000 [disabled] [size=128K]
	Capabilities: [dc] Power Management version 2
		Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
		Status: D0 PME-Enable- DSel=0 DScale=2 PME-

01:00.0 VGA compatible controller: ATI Technologies Inc Rage Mobility P/M AGP 2x (rev 64) (prog-if 00 [VGA])
	Subsystem: Dell Unknown device 00dc
	Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping+ SERR- FastB2B-
	Status: Cap+ 66MHz- UDF- FastB2B+ ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
	Latency: 66 (2000ns min), Cache Line Size: 32 bytes
	Interrupt: pin A routed to IRQ 10
	Region 0: Memory at fd000000 (32-bit, non-prefetchable) [size=16M]
	Region 1: I/O ports at e800 [size=256]
	Region 2: Memory at fecfe000 (32-bit, non-prefetchable) [size=4K]
	[virtual] Expansion ROM at 28000000 [disabled] [size=128K]
	Capabilities: [50] AGP version 1.0
		Status: RQ=256 Iso- ArqSz=0 Cal=0 SBA+ ITACoh- GART64- HTrans- 64bit- FW- AGP3- Rate=x1,x2
		Command: RQ=1 ArqSz=0 Cal=0 SBA- AGP- GART64- 64bit- FW- Rate=<none>
	Capabilities: [5c] Power Management version 1
		Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)
		Status: D0 PME-Enable- DSel=0 DScale=0 PME-

02:00.0 Network controller: Broadcom Corporation BCM4306 802.11b/g Wireless LAN Controller (rev 03)
	Subsystem: Belkin F5D7011 54g+ Wireless Network card
	Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
	Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
	Latency: 64
	Interrupt: pin A routed to IRQ 10
	Region 0: Memory at 24000000 (32-bit, non-prefetchable) [size=8K]


=================================================================================
Nov 26 10:14:26 tilly NetworkManager: <info>  DHCP daemon state is now 1 (starting) for interface wlan0 
Nov 26 10:14:26 tilly dhclient: DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
Nov 26 10:14:28 tilly dhclient: DHCPOFFER from 192.168.1.1
Nov 26 10:14:28 tilly dhclient: DHCPREQUEST on wlan0 to 255.255.255.255 port 67
Nov 26 10:14:29 tilly dhclient: DHCPACK from 192.168.1.1
Nov 26 10:14:29 tilly avahi-daemon[4769]: Joining mDNS multicast group on interface wlan0.IPv4 with address 192.168.1.4.
Nov 26 10:14:29 tilly avahi-daemon[4769]: New relevant interface wlan0.IPv4 for mDNS.
Nov 26 10:14:29 tilly avahi-daemon[4769]: Registering new address record for 192.168.1.4 on wlan0.IPv4.
Nov 26 10:14:30 tilly NetworkManager: <info>  DHCP daemon state is now 2 (bound) for interface wlan0 
Nov 26 10:14:30 tilly NetworkManager: <info>  Activation (wlan0) Stage 4 of 5 (IP Configure Get) scheduled... 
Nov 26 10:14:30 tilly NetworkManager: <info>  Activation (wlan0) Stage 4 of 5 (IP Configure Get) started... 
Nov 26 10:14:30 tilly dhclient: bound to 192.168.1.4 -- renewal in 37616 seconds.
Nov 26 10:14:30 tilly dhcdbd: message_handler: message handler not found under /com/redhat/dhcp/wlan0 for sub-path wlan0.dbus.get.host_name
Nov 26 10:14:30 tilly dhcdbd: message_handler: message handler not found under /com/redhat/dhcp/wlan0 for sub-path wlan0.dbus.get.domain_name
Nov 26 10:14:30 tilly dhcdbd: message_handler: message handler not found under /com/redhat/dhcp/wlan0 for sub-path wlan0.dbus.get.nis_domain
Nov 26 10:14:30 tilly dhcdbd: message_handler: message handler not found under /com/redhat/dhcp/wlan0 for sub-path wlan0.dbus.get.nis_servers
Nov 26 10:14:30 tilly NetworkManager: <info>  Retrieved the following IP4 configuration from the DHCP daemon: 
Nov 26 10:14:30 tilly NetworkManager: <info>    address 192.168.1.4 
Nov 26 10:14:30 tilly NetworkManager: <info>    netmask 255.255.255.0 
Nov 26 10:14:30 tilly NetworkManager: <info>    broadcast 192.168.1.255 
Nov 26 10:14:30 tilly NetworkManager: <info>    gateway 192.168.1.1 
Nov 26 10:14:30 tilly NetworkManager: <info>    nameserver 192.168.1.1 
Nov 26 10:14:30 tilly NetworkManager: <info>  Activation (wlan0) Stage 5 of 5 (IP Configure Commit) scheduled... 
Nov 26 10:14:30 tilly NetworkManager: <info>  Activation (wlan0) Stage 4 of 5 (IP Configure Get) complete. 
Nov 26 10:14:30 tilly NetworkManager: <info>  Activation (wlan0) Stage 5 of 5 (IP Configure Commit) started... 
Nov 26 10:14:30 tilly avahi-daemon[4769]: Withdrawing address record for 192.168.1.4 on wlan0.
Nov 26 10:14:30 tilly avahi-daemon[4769]: Leaving mDNS multicast group on interface wlan0.IPv4 with address 192.168.1.4.
Nov 26 10:14:30 tilly avahi-daemon[4769]: Interface wlan0.IPv4 no longer relevant for mDNS.
Nov 26 10:14:30 tilly avahi-daemon[4769]: Withdrawing address record for fe80::211:50ff:fe92:fdb8 on wlan0.
Nov 26 10:14:30 tilly avahi-daemon[4769]: Joining mDNS multicast group on interface wlan0.IPv4 with address 192.168.1.4.
Nov 26 10:14:30 tilly avahi-daemon[4769]: New relevant interface wlan0.IPv4 for mDNS.
Nov 26 10:14:30 tilly avahi-daemon[4769]: Registering new address record for 192.168.1.4 on wlan0.IPv4.
Nov 26 10:14:30 tilly kernel: [  183.732585] cpufreq: change failed with new_state 0 and result 0
Nov 26 10:14:31 tilly NetworkManager: <info>  Clearing nscd hosts cache. 
Nov 26 10:14:31 tilly NetworkManager: <WARN>  nm_spawn_process(): nm_spawn_process('/usr/sbin/nscd -i hosts'): could not spawn process. (Failed to execute child process "/usr/sbin/nscd" (No such file or directory))  
Nov 26 10:14:31 tilly NetworkManager: <info>  Activation (wlan0) Finish handler scheduled. 
Nov 26 10:14:31 tilly NetworkManager: <info>  Activation (wlan0) Stage 5 of 5 (IP Configure Commit) complete. 
Nov 26 10:14:31 tilly NetworkManager: <info>  Activation (wlan0) successful, device activated. 
Nov 26 10:14:32 tilly avahi-daemon[4769]: Registering new address record for fe80::211:50ff:fe92:fdb8 on wlan0.*.
Nov 26 10:14:33 tilly kernel: [  187.492665] cpufreq: change failed with new_state 1 and result 0
Nov 26 10:16:13 tilly ntpdate[5505]: step time server 91.189.94.4 offset 98.808040 sec
Nov 26 10:16:20 tilly kernel: [  270.320676] wlan0: no IPv6 routers present
Nov 26 10:16:27 tilly kernel: [  199.001761] cpufreq: change failed with new_state 0 and result 0
Nov 26 10:16:29 tilly kernel: [  200.525058] wlan0: No ProbeResp from current AP 00:18:4d:56:c7:ba - assume out of range
Nov 26 10:16:29 tilly kernel: [  201.760167] cpufreq: change failed with new_state 1 and result 0
Nov 26 10:16:30 tilly kernel: [  282.787003] wlan0: No STA entry for own AP 00:18:4d:56:c7:ba
Nov 26 10:16:35 tilly kernel: [  288.576856] wlan0: No STA entry for own AP 00:18:4d:56:c7:ba
Nov 26 10:16:40 tilly /USR/SBIN/CRON[5549]: (www-data) CMD ([ -f /usr/share/moodle/admin/cron.php ] && /usr/bin/php -f /usr/share/moodle/admin/cron.php > /dev/null)
Nov 26 10:16:41 tilly kernel: [  294.362670] wlan0: No STA entry for own AP 00:18:4d:56:c7:ba
Nov 26 10:16:47 tilly kernel: [  300.152734] wlan0: No STA entry for own AP 00:18:4d:56:c7:ba
Nov 26 10:16:49 tilly NetworkManager: <info>  wlan0: link timed out. 
Nov 26 10:16:49 tilly NetworkManager: <info>  SWITCH: found better connection 'wlan0/hamilton' than current connection 'wlan0/hamilton'.  same_ssid=1, have_link=0 
Nov 26 10:16:49 tilly NetworkManager: <info>  Will activate connection 'wlan0/hamilton'. 
Nov 26 10:16:49 tilly NetworkManager: <info>  Device wlan0 activation scheduled... 
Nov 26 10:16:49 tilly NetworkManager: <info>  Deactivating device wlan0. 
Nov 26 10:16:49 tilly dhclient: There is already a pid file /var/run/dhclient.wlan0.pid with pid 5392
Nov 26 10:16:49 tilly dhclient: killed old client process, removed PID file
Nov 26 10:16:49 tilly dhclient: wmaster0: unknown hardware address type 801
Nov 26 10:16:49 tilly dhclient: wmaster0: unknown hardware address type 801
Nov 26 10:16:49 tilly dhclient: DHCPRELEASE on wlan0 to 192.168.1.1 port 67
Nov 26 10:16:49 tilly avahi-daemon[4769]: Withdrawing address record for 192.168.1.4 on wlan0.
Nov 26 10:16:49 tilly avahi-daemon[4769]: Leaving mDNS multicast group on interface wlan0.IPv4 with address 192.168.1.4.
Nov 26 10:16:49 tilly avahi-daemon[4769]: Interface wlan0.IPv4 no longer relevant for mDNS.
Nov 26 10:16:50 tilly avahi-daemon[4769]: Withdrawing address record for fe80::211:50ff:fe92:fdb8 on wlan0.
Nov 26 10:16:50 tilly NetworkManager: <info>  Activation (wlan0) started... 
Nov 26 10:16:50 tilly NetworkManager: <info>  Activation (wlan0) Stage 1 of 5 (Device Prepare) scheduled... 
Nov 26 10:16:50 tilly NetworkManager: <info>  DHCP daemon state is now 14 (normal exit) for interface wlan0 
Nov 26 10:16:50 tilly NetworkManager: <info>  DHCP daemon state is now 11 (unknown) for interface wlan0 
Nov 26 10:16:50 tilly NetworkManager: <info>  DHCP daemon state is now 14 (normal exit) for interface wlan0 
Nov 26 10:16:50 tilly NetworkManager: <info>  Activation (wlan0) Stage 1 of 5 (Device Prepare) started... 
Nov 26 10:16:50 tilly NetworkManager: <info>  Activation (wlan0) Stage 2 of 5 (Device Configure) scheduled... 
Nov 26 10:16:50 tilly NetworkManager: <info>  Activation (wlan0) Stage 1 of 5 (Device Prepare) complete. 
Nov 26 10:16:50 tilly NetworkManager: <info>  Activation (wlan0) Stage 2 of 5 (Device Configure) starting... 
Nov 26 10:16:50 tilly NetworkManager: <info>  Activation (wlan0/wireless): access point 'hamilton' is unencrypted, no key needed. 
Nov 26 10:16:51 tilly kernel: [  303.912386] ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
Nov 26 10:16:51 tilly NetworkManager: <info>  supplicant_interface_init() - connect to global ctrl socket (0/10). 
Nov 26 10:16:51 tilly kernel: [  303.938855] b43-phy0 debug: Removing Interface type 2
Nov 26 10:16:51 tilly kernel: [  303.951664] b43-phy0 debug: Wireless interface stopped
Nov 26 10:16:51 tilly kernel: [  303.952039] b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 10/64
Nov 26 10:16:51 tilly kernel: [  303.952205] b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
Nov 26 10:16:51 tilly kernel: [  303.958934] b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
Nov 26 10:16:51 tilly kernel: [  303.966887] b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
Nov 26 10:16:51 tilly NetworkManager: <debug> [1196072211.219181] nm_hal_device_removed(): Device removed (hal udi is '/org/freedesktop/Hal/devices/computer_logicaldev_input_0'). 
Nov 26 10:16:51 tilly kernel: [  303.974877] b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
Nov 26 10:16:51 tilly kernel: [  303.982877] b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 18/128
Nov 26 10:16:51 tilly kernel: [  303.990860] b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
Nov 26 10:16:51 tilly NetworkManager: <info>  supplicant_interface_init() - connect to global ctrl socket (1/10). 
Nov 26 10:16:51 tilly NetworkManager: <info>  SUP: sending command 'INTERFACE_ADD wlan0^I^Iwext^I/var/run/wpa_supplicant4^I' 
Nov 26 10:16:51 tilly kernel: [  304.238762] b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
Nov 26 10:16:52 tilly kernel: [  218.980469] cpufreq: change failed with new_state 0 and result 0
Nov 26 10:16:52 tilly kernel: [  219.086558] b43-phy0 debug: Chip initialized
Nov 26 10:16:52 tilly kernel: [  219.087856] b43-phy0 debug: 30-bit DMA initialized
Nov 26 10:16:52 tilly kernel: [  219.089182] BUG: unable to handle kernel NULL pointer dereference at virtual address 00000000
Nov 26 10:16:52 tilly kernel: [  219.089202]  printing eip:
Nov 26 10:16:52 tilly kernel: [  219.089208] c02f5cc5
Nov 26 10:16:52 tilly kernel: [  219.089211] *pde = 00000000
Nov 26 10:16:52 tilly kernel: [  219.089221] Oops: 0002 [#1]
Nov 26 10:16:52 tilly kernel: [  219.089225] SMP 
Nov 26 10:16:52 tilly kernel: [  219.089233] Modules linked in: af_packet rfcomm l2cap bluetooth capability commoncap ppdev ipv6 cpufreq_stats cpufreq_ondemand cpufreq_powersave cpufreq_userspace cpufreq_conservative speedstep_smi freq_table speedstep_lib apm parport_pc lp parport arc4 ecb blkcipher snd_cs4281 gameport rc80211_simple snd_ac97_codec ac97_bus snd_pcm_oss snd_mixer_oss b43 rfkill snd_pcm snd_page_alloc snd_opl3_lib mac80211 snd_hwdep cfg80211 input_polldev snd_seq_dummy ssb snd_seq_oss snd_seq_midi snd_rawmidi snd_seq_midi_event snd_seq joydev pcmcia snd_timer snd_seq_device snd yenta_socket serio_raw i2c_piix4 rsrc_nonstatic shpchp soundcore pcspkr intel_agp agpgart pcmcia_core psmouse pci_hotplug i2c_core evdev ext3 jbd mbcache sg sd_mod ata_piix ata_generic uhci_hcd libata 3c59x floppy usbcore mii scsi_mod fuse
Nov 26 10:16:52 tilly kernel: [  219.089382] CPU:    0
Nov 26 10:16:52 tilly kernel: [  219.089384] EIP:    0060:[__mutex_lock_interruptible_slowpath+53/208]    Not tainted VLI
Nov 26 10:16:52 tilly kernel: [  219.089388] EFLAGS: 00210206   (2.6.23 #2)
Nov 26 10:16:52 tilly kernel: [  219.089423] EIP is at __mutex_lock_interruptible_slowpath+0x35/0xd0
Nov 26 10:16:52 tilly kernel: [  219.089431] eax: c3757dc4   ebx: cbf51c10   ecx: cbf51c18   edx: 00000000
Nov 26 10:16:52 tilly kernel: [  219.089440] esi: cbf51c00   edi: c8d1a000   ebp: cbf51c14   esp: c3757dc0
Nov 26 10:16:52 tilly kernel: [  219.089448] ds: 007b   es: 007b   fs: 00d8  gs: 0033  ss: 0068
Nov 26 10:16:52 tilly kernel: [  219.089457] Process wpa_supplicant (pid: 5588, ti=c3756000 task=c8d1a000 task.ti=c3756000)
Nov 26 10:16:52 tilly kernel: [  219.089463] Stack: cbf51c18 cbf51c18 00000000 d09f5a04 00000000 cbf51c00 00000001 cbf51c10 
Nov 26 10:16:52 tilly kernel: [  219.089481]        d09f4020 00000000 cbf51c00 c8f56e6a c952a800 d09f4488 c952a800 c8f56e6a 
Nov 26 10:16:52 tilly kernel: [  219.089498]        c952a800 d0a14df9 c8f56e40 c8f56ecc d0a27d53 00000001 00000039 0000003a 
Nov 26 10:16:52 tilly kernel: [  219.089515] Call Trace:
Nov 26 10:16:52 tilly kernel: [  219.089540]  [<d09f4020>] rfkill_toggle_radio+0x20/0x70 [rfkill]
Nov 26 10:16:52 tilly kernel: [  219.089572]  [<d09f4488>] rfkill_register+0x48/0xe0 [rfkill]
Nov 26 10:16:52 tilly kernel: [  219.089593]  [<d0a14df9>] b43_key_clear+0x49/0xf0 [b43]
Nov 26 10:16:52 tilly kernel: [  219.089655]  [<d0a27d53>] b43_rfkill_init+0x23/0xa0 [b43]
Nov 26 10:16:52 tilly kernel: [  219.089698]  [<d0a17cc8>] b43_wireless_core_init+0x588/0x780 [b43]
Nov 26 10:16:52 tilly kernel: [  219.089726]  [schedule+457/1536] schedule+0x1c9/0x600
Nov 26 10:16:52 tilly kernel: [  219.089760]  [<d0a18d87>] b43_start+0x77/0x90 [b43]
Nov 26 10:16:52 tilly kernel: [  219.089794]  [<d0d03b16>] ieee80211_open+0x156/0x440 [mac80211]
Nov 26 10:16:52 tilly kernel: [  219.089883]  [cond_resched+42/64] cond_resched+0x2a/0x40
Nov 26 10:16:52 tilly kernel: [  219.089904]  [dev_open+52/128] dev_open+0x34/0x80
Nov 26 10:16:52 tilly kernel: [  219.089925]  [dev_change_flags+318/448] dev_change_flags+0x13e/0x1c0
Nov 26 10:16:52 tilly kernel: [  219.089950]  [devinet_ioctl+1315/1728] devinet_ioctl+0x523/0x6c0
Nov 26 10:16:52 tilly kernel: [  219.089970]  [__dev_get_by_name+113/144] __dev_get_by_name+0x71/0x90
Nov 26 10:16:52 tilly kernel: [  219.090039]  [sock_ioctl+191/528] sock_ioctl+0xbf/0x210
Nov 26 10:16:52 tilly kernel: [  219.090056]  [do_page_fault+397/1824] do_page_fault+0x18d/0x720
Nov 26 10:16:52 tilly kernel: [  219.090073]  [sock_ioctl+0/528] sock_ioctl+0x0/0x210
Nov 26 10:16:52 tilly kernel: [  219.090089]  [do_ioctl+43/144] do_ioctl+0x2b/0x90
Nov 26 10:16:52 tilly kernel: [  219.090111]  [vfs_ioctl+92/656] vfs_ioctl+0x5c/0x290
Nov 26 10:16:52 tilly kernel: [  219.090133]  [sys_ioctl+114/144] sys_ioctl+0x72/0x90
Nov 26 10:16:52 tilly kernel: [  219.090152]  [sysenter_past_esp+107/169] sysenter_past_esp+0x6b/0xa9
Nov 26 10:16:52 tilly kernel: [  219.090202]  =======================
Nov 26 10:16:52 tilly kernel: [  219.090207] Code: ec 10 89 e8 64 8b 3d 00 80 43 c0 e8 b6 0d 00 00 8d 43 08 89 04 24 8b 50 04 8d 44 24 04 8b 0c 24 89 41 04 89 4c 24 04 89 54 24 08 <89> 02 ba ff ff ff ff 89 7c 24 0c 89 d0 87 03 83 e8 01 74 39 87 
Nov 26 10:16:52 tilly kernel: [  219.090288] EIP: [__mutex_lock_interruptible_slowpath+53/208] __mutex_lock_interruptible_slowpath+0x35/0xd0 SS:ESP 0068:c3757dc0
Nov 26 10:16:52 tilly kernel: [  219.187924] BUG: unable to handle kernel paging request at virtual address 8b4b7ee8
Nov 26 10:16:52 tilly kernel: [  219.187942]  printing eip:
Nov 26 10:16:52 tilly kernel: [  219.187947] c029c121
Nov 26 10:16:52 tilly kernel: [  219.187951] *pde = 00000000
Nov 26 10:16:52 tilly kernel: [  219.187961] Oops: 0000 [#2]
Nov 26 10:16:52 tilly kernel: [  219.187965] SMP 
Nov 26 10:16:52 tilly kernel: [  219.187972] Modules linked in: af_packet rfcomm l2cap bluetooth capability commoncap ppdev ipv6 cpufreq_stats cpufreq_ondemand cpufreq_powersave cpufreq_userspace cpufreq_conservative speedstep_smi freq_table speedstep_lib apm parport_pc lp parport arc4 ecb blkcipher snd_cs4281 gameport rc80211_simple snd_ac97_codec ac97_bus snd_pcm_oss snd_mixer_oss b43 rfkill snd_pcm snd_page_alloc snd_opl3_lib mac80211 snd_hwdep cfg80211 input_polldev snd_seq_dummy ssb snd_seq_oss snd_seq_midi snd_rawmidi snd_seq_midi_event snd_seq joydev pcmcia snd_timer snd_seq_device snd yenta_socket serio_raw i2c_piix4 rsrc_nonstatic shpchp soundcore pcspkr intel_agp agpgart pcmcia_core psmouse pci_hotplug i2c_core evdev ext3 jbd mbcache sg sd_mod ata_piix ata_generic uhci_hcd libata 3c59x floppy usbcore mii scsi_mod fuse
Nov 26 10:16:52 tilly kernel: [  219.188122] CPU:    0
Nov 26 10:16:52 tilly kernel: [  219.188124] EIP:    0060:[netlink_update_listeners+81/128]    Tainted: G      D VLI
Nov 26 10:16:52 tilly kernel: [  219.188128] EFLAGS: 00210006   (2.6.23 #2)
Nov 26 10:16:52 tilly kernel: [  219.188149] EIP is at netlink_update_listeners+0x51/0x80
Nov 26 10:16:52 tilly kernel: [  219.188157] eax: 8b4b7ee8   ebx: 00000000   ecx: cbc63fde   edx: 00000000
Nov 26 10:16:52 tilly kernel: [  219.188165] esi: 00000000   edi: 00000000   ebp: c1256000   esp: c3757c18
Nov 26 10:16:52 tilly kernel: [  219.188174] ds: 007b   es: 007b   fs: 00d8  gs: 0000  ss: 0068
Nov 26 10:16:52 tilly kernel: [  219.188183] Process wpa_supplicant (pid: 5588, ti=c3756000 task=c8d1a000 task.ti=c3756000)
Nov 26 10:16:52 tilly kernel: [  219.188190] Stack: 00000001 cbf51c00 c3921d80 c3921da8 c029eb57 00000000 c396ce60 00000000 
Nov 26 10:16:52 tilly kernel: [  219.188207]        c3921d8c c02792bd 00000000 00000000 c3921d80 cd7d6000 c027a4ba c396ce60 
Nov 26 10:16:52 tilly kernel: [  219.188224]        c3921da8 c396ce60 c027a94e cd7d6000 00000008 c017fbd7 00000000 00000000 
Nov 26 10:16:52 tilly kernel: [  219.188241] Call Trace:
Nov 26 10:16:52 tilly kernel: [  219.188255]  [netlink_release+535/592] netlink_release+0x217/0x250
Nov 26 10:16:52 tilly kernel: [  219.188278]  [sock_fasync+189/336] sock_fasync+0xbd/0x150
Nov 26 10:16:52 tilly kernel: [  219.188303]  [sock_release+26/128] sock_release+0x1a/0x80
Nov 26 10:16:52 tilly kernel: [  219.188320]  [sock_close+30/64] sock_close+0x1e/0x40
Nov 26 10:16:52 tilly kernel: [  219.188334]  [__fput+167/400] __fput+0xa7/0x190
Nov 26 10:16:52 tilly kernel: [  219.188365]  [filp_close+71/128] filp_close+0x47/0x80
Nov 26 10:16:52 tilly kernel: [  219.188395]  [put_files_struct+143/176] put_files_struct+0x8f/0xb0
Nov 26 10:16:52 tilly kernel: [  219.188416]  [do_exit+349/2080] do_exit+0x15d/0x820
Nov 26 10:16:52 tilly kernel: [  219.188426]  [common_interrupt+35/48] common_interrupt+0x23/0x30
Nov 26 10:16:52 tilly kernel: [  219.188467]  [die+649/656] die+0x289/0x290
Nov 26 10:16:52 tilly kernel: [  219.188494]  [do_page_fault+1002/1824] do_page_fault+0x3ea/0x720
Nov 26 10:16:52 tilly kernel: [  219.188524]  [update_curr+313/336] update_curr+0x139/0x150
Nov 26 10:16:52 tilly kernel: [  219.188563]  [do_page_fault+0/1824] do_page_fault+0x0/0x720
Nov 26 10:16:52 tilly kernel: [  219.188575]  [error_code+114/128] error_code+0x72/0x80
Nov 26 10:16:52 tilly kernel: [  219.188605]  [__mutex_lock_interruptible_slowpath+53/208] __mutex_lock_interruptible_slowpath+0x35/0xd0
Nov 26 10:16:52 tilly kernel: [  219.188653]  [<d09f4020>] rfkill_toggle_radio+0x20/0x70 [rfkill]
Nov 26 10:16:52 tilly kernel: [  219.188681]  [<d09f4488>] rfkill_register+0x48/0xe0 [rfkill]
Nov 26 10:16:52 tilly kernel: [  219.188702]  [<d0a14df9>] b43_key_clear+0x49/0xf0 [b43]
Nov 26 10:16:52 tilly kernel: [  219.188758]  [<d0a27d53>] b43_rfkill_init+0x23/0xa0 [b43]
Nov 26 10:16:52 tilly kernel: [  219.188799]  [<d0a17cc8>] b43_wireless_core_init+0x588/0x780 [b43]
Nov 26 10:16:52 tilly kernel: [  219.188827]  [schedule+457/1536] schedule+0x1c9/0x600
Nov 26 10:16:52 tilly kernel: [  219.188858]  [<d0a18d87>] b43_start+0x77/0x90 [b43]
Nov 26 10:16:52 tilly kernel: [  219.188892]  [<d0d03b16>] ieee80211_open+0x156/0x440 [mac80211]
Nov 26 10:16:52 tilly kernel: [  219.188976]  [cond_resched+42/64] cond_resched+0x2a/0x40
Nov 26 10:16:52 tilly kernel: [  219.188996]  [dev_open+52/128] dev_open+0x34/0x80
Nov 26 10:16:52 tilly kernel: [  219.189015]  [dev_change_flags+318/448] dev_change_flags+0x13e/0x1c0
Nov 26 10:16:53 tilly kernel: [  219.189039]  [devinet_ioctl+1315/1728] devinet_ioctl+0x523/0x6c0
Nov 26 10:16:53 tilly kernel: [  219.189059]  [__dev_get_by_name+113/144] __dev_get_by_name+0x71/0x90
Nov 26 10:16:53 tilly kernel: [  219.189124]  [sock_ioctl+191/528] sock_ioctl+0xbf/0x210
Nov 26 10:16:53 tilly kernel: [  219.189133]  [do_page_fault+397/1824] do_page_fault+0x18d/0x720
Nov 26 10:16:53 tilly kernel: [  219.189144]  [sock_ioctl+0/528] sock_ioctl+0x0/0x210
Nov 26 10:16:53 tilly kernel: [  219.189159]  [do_ioctl+43/144] do_ioctl+0x2b/0x90
Nov 26 10:16:53 tilly kernel: [  219.189180]  [vfs_ioctl+92/656] vfs_ioctl+0x5c/0x290
Nov 26 10:16:53 tilly kernel: [  219.189200]  [sys_ioctl+114/144] sys_ioctl+0x72/0x90
Nov 26 10:16:53 tilly kernel: [  219.189219]  [sysenter_past_esp+107/169] sysenter_past_esp+0x6b/0xa9
Nov 26 10:16:53 tilly kernel: [  219.189263]  =======================
Nov 26 10:16:53 tilly kernel: [  219.189267] Code: db 85 c0 75 07 eb 49 8d 76 00 89 d0 8b 10 0f 18 02 90 8d 48 f0 8b 81 80 01 00 00 83 c0 1f c1 e8 05 39 f0 76 09 8b 81 84 01 00 00 <0b> 1c 07 85 d2 75 d8 8b 45 20 83 c6 01 89 1c 07 8b 45 28 83 c7 
Nov 26 10:16:53 tilly kernel: [  219.189348] EIP: [netlink_update_listeners+81/128] netlink_update_listeners+0x51/0x80 SS:ESP 0068:c3757c18
Nov 26 10:16:53 tilly kernel: [  219.189373] Fixing recursive fault but reboot is needed!


From mb at bu3sch.de  Mon Nov 26 15:14:21 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 26 Nov 2007 15:14:21 +0100
Subject: [Bug 9414] Not work light of button-led with module b43 in
	chipset broadcom 4318
In-Reply-To: <474A20CE.3020307@lwfinger.net>
References: <20071125212527.6645610806E@picon.linux-foundation.org>
	<474A20CE.3020307@lwfinger.net>
Message-ID: <200711261514.23736.mb@bu3sch.de>

On Monday 26 November 2007 02:26:38 Larry Finger wrote:
> Michael and Ivo,
> 
> I have done a little looking into the problem of the radio LED not coming on, and have found the
> following:
> 
> 1. The call-back routine b43_rfkill_soft_toggle() is called once. When called, rfkill.registered is
> zero and the routine exits immediately.
> 
> 2. The call-back routine b43_rfkill_poll() is never called, and the switch that controls the radio
> is never tested.
> 
> 3. There is a log message "input: Unspecified device as /class/input/input7", which I think arises
> from the rfkill registration.
> 
> I have the necessary hardware and am willing to test any suggested changes.
> 
> Larry
> 
> 

Dunno. That's a poll-input-dev problem then. Do you have all poll-input options enabled?

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Mon Nov 26 15:38:11 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 26 Nov 2007 08:38:11 -0600
Subject: [PATCH V3] b43: Changes to enable BCM4311 rev 02 with wireless core
	revision 13
Message-ID: <474ADA53.808@lwfinger.net>

The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
has not been supported until now. The changes include the following:

(1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
(2) Add PHY revision 9 to the supported list.
(3) Change the 2-bit routing code for address extensions to 0b10 rather
    than the 0b01 used for the 32-bit case.
(4) Remove some magic numbers in the DMA setup.

The DMA implementation for this chip supports full 64-bit addressing with
one exception. Whenever the Descriptor Ring Buffer is in high memory, a
fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
to code to "Bias the placement of kernel pages at lower PFNs". When
commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
this problem is thought to arise from a hardware error.

This patch has been tested on my system, and by C?dric Caumont
<icare40 at hotmail.com> and by Matthieu PATOU <mat at matws.net> on a BCM4312.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This patch is intended for the everything branch of wireless-2.6.

Larry
---

 dma.c  |   30 ++++++++++++++++++++++--------
 main.c |    3 ++-
 wa.c   |    1 +
 3 files changed, 25 insertions(+), 9 deletions(-)

Index: wireless-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/dma.c
+++ wireless-2.6/drivers/net/wireless/b43/dma.c
@@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct
 	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
 	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
 	    >> SSB_DMA_TRANSLATION_SHIFT;
-	addrhi |= ssb_dma_translation(ring->dev->dev);
+	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
 	if (slot == ring->nr_slots - 1)
 		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
 	if (start)
@@ -426,9 +426,21 @@ static inline
 static int alloc_ringmemory(struct b43_dmaring *ring)
 {
 	struct device *dev = ring->dev->dev->dev;
+	gfp_t flags = GFP_KERNEL;

+	/* The specs call for 4K buffers for 30- and 32-bit DMA with 4K
+	 * alignment and 8K buffers for 64-bit DMA with 8K alignment. Testing
+	 * has shown that 4K is sufficient for the latter as long as the buffer
+	 * does not cross an 8K boundary.
+	 *
+	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
+	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
+	 * which accounts for the GFP_DMA flag below.
+	 */
+	if (ring->dma64)
+		flags = GFP_DMA;
 	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
-					    &(ring->dmabase), GFP_KERNEL);
+					    &(ring->dmabase), flags);
 	if (!ring->descbase) {
 		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
 		return -ENOMEM;
@@ -483,7 +495,7 @@ int b43_dmacontroller_rx_reset(struct b4
 	return 0;
 }

-/* Reset the RX DMA channel */
+/* Reset the TX DMA channel */
 int b43_dmacontroller_tx_reset(struct b43_wldev *dev, u16 mmio_base, int dma64)
 {
 	int i;
@@ -647,7 +659,7 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA64_TXRINGHI,
 				      ((ringbase >> 32) &
 				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
+				      | (trans << 1));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);

@@ -680,8 +692,9 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA64_RXRINGHI,
 				      ((ringbase >> 32) &
 				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
-			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
+				      | (trans << 1));
+			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc64));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);

@@ -695,11 +708,12 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA32_RXRING,
 				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
 				      | trans);
-			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
+			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc32));
 		}
 	}

-      out:
+out:
 	return err;
 }

Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -93,6 +93,7 @@ static const struct ssb_device_id b43_ss
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
 	SSB_DEVTABLE_END
 };

@@ -3064,7 +3065,7 @@ static int b43_phy_versioning(struct b43
 			unsupported = 1;
 		break;
 	case B43_PHYTYPE_G:
-		if (phy_rev > 8)
+		if (phy_rev > 9)
 			unsupported = 1;
 		break;
 	default:
Index: wireless-2.6/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
+++ wireless-2.6/drivers/net/wireless/b43/wa.c
@@ -642,6 +642,7 @@ void b43_wa_all(struct b43_wldev *dev)
 		case 6:
 		case 7:
 		case 8:
+		case 9:
 			b43_wa_tr_ltov(dev);
 			b43_wa_crs_ed(dev);
 			b43_wa_rssi_lt(dev);

==========




From larry.finger at lwfinger.net  Mon Nov 26 15:41:37 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 26 Nov 2007 08:41:37 -0600
Subject: [Bug 9414] Not work light of button-led with module b43 in	chipset
	broadcom 4318
In-Reply-To: <1196067415.4149.245.camel@johannes.berg>
References: <20071125212527.6645610806E@picon.linux-foundation.org>	
	<474A20CE.3020307@lwfinger.net>
	(sfid-20071126_012725_498911_251D6C29)
	<1196067415.4149.245.camel@johannes.berg>
Message-ID: <474ADB21.1050809@lwfinger.net>

Johannes Berg wrote:
>> I have done a little looking into the problem of the radio LED not coming on, and have found the
>> following:
> 
> [...]
> 
> Do you have /sys/class/leds/b43-phyN:radio? If so, what does the trigger
> file contain? Maybe the LED is registered in the wrong order and the
> default name was NULL?

File /sys/class/leds/b43-phy0\:rx/trigger contains

none ADP1-online BAT0-charging-or-full BAT0-charging BAT0-full [phy0rx] phy0tx phy0assoc mmc0 rfkill0

and file /sys/class/leds/b43-phy0\:tx/trigger contains

none ADP1-online BAT0-charging-or-full BAT0-charging BAT0-full phy0rx [phy0tx] phy0assoc mmc0 rfkill0

Larry


From mb at bu3sch.de  Mon Nov 26 16:11:52 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 26 Nov 2007 16:11:52 +0100
Subject: [PATCH V3] b43: Changes to enable BCM4311 rev 02 with wireless
	core revision 13
In-Reply-To: <474ADA53.808@lwfinger.net>
References: <474ADA53.808@lwfinger.net>
Message-ID: <200711261611.52975.mb@bu3sch.de>

On Monday 26 November 2007 15:38:11 Larry Finger wrote:
> The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
> has not been supported until now. The changes include the following:
> 
> (1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
> (2) Add PHY revision 9 to the supported list.
> (3) Change the 2-bit routing code for address extensions to 0b10 rather
>     than the 0b01 used for the 32-bit case.
> (4) Remove some magic numbers in the DMA setup.
> 
> The DMA implementation for this chip supports full 64-bit addressing with
> one exception. Whenever the Descriptor Ring Buffer is in high memory, a
> fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
> to code to "Bias the placement of kernel pages at lower PFNs". When
> commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
> use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
> this problem is thought to arise from a hardware error.
> 
> This patch has been tested on my system, and by C?dric Caumont
> <icare40 at hotmail.com> and by Matthieu PATOU <mat at matws.net> on a BCM4312.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>


>  static int alloc_ringmemory(struct b43_dmaring *ring)
>  {
>  	struct device *dev = ring->dev->dev->dev;
> +	gfp_t flags = GFP_KERNEL;
> 
> +	/* The specs call for 4K buffers for 30- and 32-bit DMA with 4K
> +	 * alignment and 8K buffers for 64-bit DMA with 8K alignment. Testing
> +	 * has shown that 4K is sufficient for the latter as long as the buffer
> +	 * does not cross an 8K boundary.
> +	 *
> +	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
> +	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
> +	 * which accounts for the GFP_DMA flag below.
> +	 */
> +	if (ring->dma64)
> +		flags = GFP_DMA;

Whoops, didn't notice this before. This needs to be
	flags |= GFP_DMA;

>  	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
> -					    &(ring->dmabase), GFP_KERNEL);
> +					    &(ring->dmabase), flags);
>  	if (!ring->descbase) {
>  		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
>  		return -ENOMEM;

The rest is acked.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Mon Nov 26 16:13:02 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 26 Nov 2007 09:13:02 -0600
Subject: [Bug 9414] Not work light of button-led with module b43 in chipset
	broadcom 4318
In-Reply-To: <200711261514.23736.mb@bu3sch.de>
References: <20071125212527.6645610806E@picon.linux-foundation.org>
	<474A20CE.3020307@lwfinger.net> <200711261514.23736.mb@bu3sch.de>
Message-ID: <474AE27E.2000407@lwfinger.net>

Michael Buesch wrote:
> 
> Dunno. That's a poll-input-dev problem then. Do you have all poll-input options enabled?
> 

I think so. I have the following in .config:

CONFIG_RFKILL=m
CONFIG_RFKILL_INPUT=m
CONFIG_RFKILL_LEDS=y

....

# Input device support
#
CONFIG_INPUT=y
# CONFIG_INPUT_FF_MEMLESS is not set
CONFIG_INPUT_POLLDEV=m

I also tried it with the three components built in rather than as modules. It did not make a difference.

Because the log has the message "input: Unspecified device as /class/input/input7", I have looked at
the contents of /sys/class. I find that "/sys/class/input/input7/uevent" contains

PRODUCT=0/0/0/0
EV==1
MODALIAS=input:b0000v0000p0000e0000-e0,kramlsfw


whereas /sys/class/input/input6/uevent has

PRODUCT=19/0/1/0
NAME="Power Button (CM)"
PHYS="PNP0C0C/button/input0"
EV==3
KEY==10000000000000 0
MODALIAS=input:b0019v0000p0001e0000-e0,1,k74,ramlsfw

I have no idea how to interpret these data; however, #6 certainly has a lot more information than
#7. I'm pretty sure #7 is associated with the BCM4311.

Larry



From johannes at sipsolutions.net  Mon Nov 26 16:48:23 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 26 Nov 2007 16:48:23 +0100
Subject: [Bug 9414] Not work light of button-led with module b43
	in	chipset broadcom 4318
In-Reply-To: <474ADB21.1050809@lwfinger.net>
References: <20071125212527.6645610806E@picon.linux-foundation.org>
	<474A20CE.3020307@lwfinger.net>
	(sfid-20071126_012725_498911_251D6C29)
	<1196067415.4149.245.camel@johannes.berg>
	<474ADB21.1050809@lwfinger.net>
Message-ID: <1196092103.4149.274.camel@johannes.berg>


> > Do you have /sys/class/leds/b43-phyN:radio? If so, what does the trigger



> File /sys/class/leds/b43-phy0\:rx/trigger contains
> 
> none ADP1-online BAT0-charging-or-full BAT0-charging BAT0-full [phy0rx] phy0tx phy0assoc mmc0 rfkill0
> 
> and file /sys/class/leds/b43-phy0\:tx/trigger contains
> 
> none ADP1-online BAT0-charging-or-full BAT0-charging BAT0-full phy0rx [phy0tx] phy0assoc mmc0 rfkill0

Right. No :radio LED though?

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071126/d90b87df/attachment.pgp>

From icare40 at hotmail.com  Mon Nov 26 16:52:31 2007
From: icare40 at hotmail.com (=?iso-8859-1?Q?C=E9dric_Caumont?=)
Date: Mon, 26 Nov 2007 15:52:31 +0000
Subject: [PATCH V3] b43: Changes to enable BCM4311 rev 02 with wireless
	core	revision 13
In-Reply-To: <474ADA53.808@lwfinger.net>
References: <474ADA53.808@lwfinger.net>
Message-ID: <BAY134-W383251EC52D7A2B85197DEB7750@phx.gbl>







Hello everyone

I have just one question!

I downloaded linux-2.6.24-rc3

cd /usr/src/
ln -sfn linux-2.6.24-rc3 linux
cd linux
patch -p1 < patch_v3.patch

*********************************************************************************************
can't find file to patch at input line 112
Perhaps you used the wrong -p or --strip option?
The text leading up to this was:
--------------------------
|Index: wireless-2.6/drivers/net/wireless/b43/wa.c
|===================================================================
|--- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
|+++ wireless-2.6/drivers/net/wireless/b43/wa.c
--------------------------
File to patch: 
**********************************************************************************************

Where is the wa.c file? Why there is not in the kernel tree?



> Date: Mon, 26 Nov 2007 08:38:11 -0600
> From: larry.finger at lwfinger.net
> To: linville at tuxdriver.com; mb at bu3sch.de
> Subject: [PATCH V3] b43: Changes to enable BCM4311 rev 02 with wireless core	revision 13
> CC: linux-wireless at vger.kernel.org; bcm43xx-dev at lists.berlios.de
> 
> The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
> has not been supported until now. The changes include the following:
> 
> (1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
> (2) Add PHY revision 9 to the supported list.
> (3) Change the 2-bit routing code for address extensions to 0b10 rather
>     than the 0b01 used for the 32-bit case.
> (4) Remove some magic numbers in the DMA setup.
> 
> The DMA implementation for this chip supports full 64-bit addressing with
> one exception. Whenever the Descriptor Ring Buffer is in high memory, a
> fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
> to code to "Bias the placement of kernel pages at lower PFNs". When
> commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
> use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
> this problem is thought to arise from a hardware error.
> 
> This patch has been tested on my system, and by C?dric Caumont
> <icare40 at hotmail.com> and by Matthieu PATOU <mat at matws.net> on a BCM4312.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John,
> 
> This patch is intended for the everything branch of wireless-2.6.
> 
> Larry
> ---
> 
>  dma.c  |   30 ++++++++++++++++++++++--------
>  main.c |    3 ++-
>  wa.c   |    1 +
>  3 files changed, 25 insertions(+), 9 deletions(-)
> 
> Index: wireless-2.6/drivers/net/wireless/b43/dma.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/dma.c
> +++ wireless-2.6/drivers/net/wireless/b43/dma.c
> @@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct
>  	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
>  	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
>  	    >> SSB_DMA_TRANSLATION_SHIFT;
> -	addrhi |= ssb_dma_translation(ring->dev->dev);
> +	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
>  	if (slot == ring->nr_slots - 1)
>  		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
>  	if (start)
> @@ -426,9 +426,21 @@ static inline
>  static int alloc_ringmemory(struct b43_dmaring *ring)
>  {
>  	struct device *dev = ring->dev->dev->dev;
> +	gfp_t flags = GFP_KERNEL;
> 
> +	/* The specs call for 4K buffers for 30- and 32-bit DMA with 4K
> +	 * alignment and 8K buffers for 64-bit DMA with 8K alignment. Testing
> +	 * has shown that 4K is sufficient for the latter as long as the buffer
> +	 * does not cross an 8K boundary.
> +	 *
> +	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
> +	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
> +	 * which accounts for the GFP_DMA flag below.
> +	 */
> +	if (ring->dma64)
> +		flags = GFP_DMA;
>  	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
> -					    &(ring->dmabase), GFP_KERNEL);
> +					    &(ring->dmabase), flags);
>  	if (!ring->descbase) {
>  		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
>  		return -ENOMEM;
> @@ -483,7 +495,7 @@ int b43_dmacontroller_rx_reset(struct b4
>  	return 0;
>  }
> 
> -/* Reset the RX DMA channel */
> +/* Reset the TX DMA channel */
>  int b43_dmacontroller_tx_reset(struct b43_wldev *dev, u16 mmio_base, int dma64)
>  {
>  	int i;
> @@ -647,7 +659,7 @@ static int dmacontroller_setup(struct b4
>  			b43_dma_write(ring, B43_DMA64_TXRINGHI,
>  				      ((ringbase >> 32) &
>  				       ~SSB_DMA_TRANSLATION_MASK)
> -				      | trans);
> +				      | (trans << 1));
>  		} else {
>  			u32 ringbase = (u32) (ring->dmabase);
> 
> @@ -680,8 +692,9 @@ static int dmacontroller_setup(struct b4
>  			b43_dma_write(ring, B43_DMA64_RXRINGHI,
>  				      ((ringbase >> 32) &
>  				       ~SSB_DMA_TRANSLATION_MASK)
> -				      | trans);
> -			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
> +				      | (trans << 1));
> +			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
> +				      sizeof(struct b43_dmadesc64));
>  		} else {
>  			u32 ringbase = (u32) (ring->dmabase);
> 
> @@ -695,11 +708,12 @@ static int dmacontroller_setup(struct b4
>  			b43_dma_write(ring, B43_DMA32_RXRING,
>  				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
>  				      | trans);
> -			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
> +			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
> +				      sizeof(struct b43_dmadesc32));
>  		}
>  	}
> 
> -      out:
> +out:
>  	return err;
>  }
> 
> Index: wireless-2.6/drivers/net/wireless/b43/main.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/main.c
> +++ wireless-2.6/drivers/net/wireless/b43/main.c
> @@ -93,6 +93,7 @@ static const struct ssb_device_id b43_ss
>  	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
>  	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
>  	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
> +	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
>  	SSB_DEVTABLE_END
>  };
> 
> @@ -3064,7 +3065,7 @@ static int b43_phy_versioning(struct b43
>  			unsupported = 1;
>  		break;
>  	case B43_PHYTYPE_G:
> -		if (phy_rev > 8)
> +		if (phy_rev > 9)
>  			unsupported = 1;
>  		break;
>  	default:
> Index: wireless-2.6/drivers/net/wireless/b43/wa.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
> +++ wireless-2.6/drivers/net/wireless/b43/wa.c
> @@ -642,6 +642,7 @@ void b43_wa_all(struct b43_wldev *dev)
>  		case 6:
>  		case 7:
>  		case 8:
> +		case 9:
>  			b43_wa_tr_ltov(dev);
>  			b43_wa_crs_ed(dev);
>  			b43_wa_rssi_lt(dev);
> 
> ==========
> 
> 
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev

_________________________________________________________________
Votez pour vos acteurs de s?ries TV pr?f?r?s et tentez de gagner un voyage ? Hawa? !
http://messengerawards.divertissements.fr.msn.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071126/118f1579/attachment.html>

From Larry.Finger at lwfinger.net  Mon Nov 26 17:00:06 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 26 Nov 2007 10:00:06 -0600
Subject: [PATCH V4] b43: Changes to enable BCM4311 rev 02 with wireless
	core revision 13
Message-ID: <474aed86.NapeoirOR+JdWZ7d%Larry.Finger@lwfinger.net>

The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
has not been supported until now. The changes include the following:

(1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
(2) Add PHY revision 9 to the supported list.
(3) Change the 2-bit routing code for address extensions to 0b10 rather
    than the 0b01 used for the 32-bit case.
(4) Remove some magic numbers in the DMA setup.

The DMA implementation for this chip supports full 64-bit addressing with
one exception. Whenever the Descriptor Ring Buffer is in high memory, a
fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
to code to "Bias the placement of kernel pages at lower PFNs". When
commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
this problem is thought to arise from a hardware error.

This patch has been tested on my system and by C?dric Caumont
<icare40 at hotmail.com>.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This patch is intended for the everything branch of wireless-2.6.

Larry
---

 dma.c  |   30 ++++++++++++++++++++++--------
 main.c |    3 ++-
 wa.c   |    1 +
 3 files changed, 25 insertions(+), 9 deletions(-)

Index: wireless-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/dma.c
+++ wireless-2.6/drivers/net/wireless/b43/dma.c
@@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct 
 	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
 	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
 	    >> SSB_DMA_TRANSLATION_SHIFT;
-	addrhi |= ssb_dma_translation(ring->dev->dev);
+	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
 	if (slot == ring->nr_slots - 1)
 		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
 	if (start)
@@ -426,9 +426,21 @@ static inline
 static int alloc_ringmemory(struct b43_dmaring *ring)
 {
 	struct device *dev = ring->dev->dev->dev;
+	gfp_t flags = GFP_KERNEL;
 
+	/* The specs call for 4K buffers for 30- and 32-bit DMA with 4K
+	 * alignment and 8K buffers for 64-bit DMA with 8K alignment. Testing
+	 * has shown that 4K is sufficient for the latter as long as the buffer
+	 * does not cross an 8K boundary.
+	 *
+	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
+	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
+	 * which accounts for the GFP_DMA flag below.
+	 */
+	if (ring->dma64)
+		flags = GFP_DMA;
 	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
-					    &(ring->dmabase), GFP_KERNEL);
+					    &(ring->dmabase), flags);
 	if (!ring->descbase) {
 		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
 		return -ENOMEM;
@@ -483,7 +495,7 @@ int b43_dmacontroller_rx_reset(struct b4
 	return 0;
 }
 
-/* Reset the RX DMA channel */
+/* Reset the TX DMA channel */
 int b43_dmacontroller_tx_reset(struct b43_wldev *dev, u16 mmio_base, int dma64)
 {
 	int i;
@@ -647,7 +659,7 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA64_TXRINGHI,
 				      ((ringbase >> 32) &
 				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
+				      | (trans << 1));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -680,8 +692,9 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA64_RXRINGHI,
 				      ((ringbase >> 32) &
 				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
-			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
+				      | (trans << 1));
+			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc64));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -695,11 +708,12 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA32_RXRING,
 				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
 				      | trans);
-			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
+			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc32));
 		}
 	}
 
-      out:
+out:
 	return err;
 }
 
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -93,6 +93,7 @@ static const struct ssb_device_id b43_ss
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
 	SSB_DEVTABLE_END
 };
 
@@ -3064,7 +3065,7 @@ static int b43_phy_versioning(struct b43
 			unsupported = 1;
 		break;
 	case B43_PHYTYPE_G:
-		if (phy_rev > 8)
+		if (phy_rev > 9)
 			unsupported = 1;
 		break;
 	default:
Index: wireless-2.6/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
+++ wireless-2.6/drivers/net/wireless/b43/wa.c
@@ -642,6 +642,7 @@ void b43_wa_all(struct b43_wldev *dev)
 		case 6:
 		case 7:
 		case 8:
+		case 9:
 			b43_wa_tr_ltov(dev);
 			b43_wa_crs_ed(dev);
 			b43_wa_rssi_lt(dev);

==========



From larry.finger at lwfinger.net  Mon Nov 26 17:18:42 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 26 Nov 2007 10:18:42 -0600
Subject: [PATCH V3] b43: Changes to enable BCM4311 rev 02 with wireless
	core	revision 13
In-Reply-To: <BAY134-W383251EC52D7A2B85197DEB7750@phx.gbl>
References: <474ADA53.808@lwfinger.net>
	<BAY134-W383251EC52D7A2B85197DEB7750@phx.gbl>
Message-ID: <474AF1E2.4050405@lwfinger.net>

C?dric Caumont wrote:
> Hello everyone
> 
> I have just one question!
> 
> I downloaded linux-2.6.24-rc3
> 
> cd /usr/src/
> ln -sfn linux-2.6.24-rc3 linux
> cd linux
> patch -p1 < patch_v3.patch
> 
> *********************************************************************************************
> can't find file to patch at input line 112
> Perhaps you used the wrong -p or --strip option?
> The text leading up to this was:
> --------------------------
> |Index: wireless-2.6/drivers/net/wireless/b43/wa.c

The patch is for the wireless-2.6 git tree. To use 2.6.24-rc3 from mainline, there are some
additional patches needed. I will generate that patch and send it to you privately.

Larry



From mb at bu3sch.de  Mon Nov 26 17:18:24 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 26 Nov 2007 17:18:24 +0100
Subject: [PATCH V4] b43: Changes to enable BCM4311 rev 02 with wireless
	core revision 13
In-Reply-To: <474aed86.NapeoirOR+JdWZ7d%Larry.Finger@lwfinger.net>
References: <474aed86.NapeoirOR+JdWZ7d%Larry.Finger@lwfinger.net>
Message-ID: <200711261718.25240.mb@bu3sch.de>

On Monday 26 November 2007 17:00:06 Larry Finger wrote:
>  static int alloc_ringmemory(struct b43_dmaring *ring)
>  {
>  	struct device *dev = ring->dev->dev->dev;
> +	gfp_t flags = GFP_KERNEL;
>  
> +	/* The specs call for 4K buffers for 30- and 32-bit DMA with 4K
> +	 * alignment and 8K buffers for 64-bit DMA with 8K alignment. Testing
> +	 * has shown that 4K is sufficient for the latter as long as the buffer
> +	 * does not cross an 8K boundary.
> +	 *
> +	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
> +	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
> +	 * which accounts for the GFP_DMA flag below.
> +	 */
> +	if (ring->dma64)
> +		flags = GFP_DMA;

???


-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Mon Nov 26 17:29:47 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 26 Nov 2007 10:29:47 -0600
Subject: [PATCH V5] b43: Changes to enable BCM4311 rev 02 with wireless
	core revision 13
Message-ID: <474af47b.cWuJogLu6VTKxmSg%Larry.Finger@lwfinger.net>

The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
has not been supported until now. The changes include the following:

(1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
(2) Add PHY revision 9 to the supported list.
(3) Change the 2-bit routing code for address extensions to 0b10 rather
    than the 0b01 used for the 32-bit case.
(4) Remove some magic numbers in the DMA setup.

The DMA implementation for this chip supports full 64-bit addressing with
one exception. Whenever the Descriptor Ring Buffer is in high memory, a
fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
to code to "Bias the placement of kernel pages at lower PFNs". When
commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
this problem is thought to arise from a hardware error.

This patch has been tested on my system and by C?dric Caumont
<icare40 at hotmail.com>.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This patch is intended for the everything branch of wireless-2.6.

Larry
---

 dma.c  |   30 ++++++++++++++++++++++--------
 main.c |    3 ++-
 wa.c   |    1 +
 3 files changed, 25 insertions(+), 9 deletions(-)

Index: wireless-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/dma.c
+++ wireless-2.6/drivers/net/wireless/b43/dma.c
@@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct 
 	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
 	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
 	    >> SSB_DMA_TRANSLATION_SHIFT;
-	addrhi |= ssb_dma_translation(ring->dev->dev);
+	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
 	if (slot == ring->nr_slots - 1)
 		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
 	if (start)
@@ -426,9 +426,21 @@ static inline
 static int alloc_ringmemory(struct b43_dmaring *ring)
 {
 	struct device *dev = ring->dev->dev->dev;
+	gfp_t flags = GFP_KERNEL;
 
+	/* The specs call for 4K buffers for 30- and 32-bit DMA with 4K
+	 * alignment and 8K buffers for 64-bit DMA with 8K alignment. Testing
+	 * has shown that 4K is sufficient for the latter as long as the buffer
+	 * does not cross an 8K boundary.
+	 *
+	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
+	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
+	 * which accounts for the GFP_DMA flag below.
+	 */
+	if (ring->dma64)
+		flags |= GFP_DMA;
 	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
-					    &(ring->dmabase), GFP_KERNEL);
+					    &(ring->dmabase), flags);
 	if (!ring->descbase) {
 		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
 		return -ENOMEM;
@@ -483,7 +495,7 @@ int b43_dmacontroller_rx_reset(struct b4
 	return 0;
 }
 
-/* Reset the RX DMA channel */
+/* Reset the TX DMA channel */
 int b43_dmacontroller_tx_reset(struct b43_wldev *dev, u16 mmio_base, int dma64)
 {
 	int i;
@@ -647,7 +659,7 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA64_TXRINGHI,
 				      ((ringbase >> 32) &
 				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
+				      | (trans << 1));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -680,8 +692,9 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA64_RXRINGHI,
 				      ((ringbase >> 32) &
 				       ~SSB_DMA_TRANSLATION_MASK)
-				      | trans);
-			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
+				      | (trans << 1));
+			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc64));
 		} else {
 			u32 ringbase = (u32) (ring->dmabase);
 
@@ -695,11 +708,12 @@ static int dmacontroller_setup(struct b4
 			b43_dma_write(ring, B43_DMA32_RXRING,
 				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
 				      | trans);
-			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
+			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
+				      sizeof(struct b43_dmadesc32));
 		}
 	}
 
-      out:
+out:
 	return err;
 }
 
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -93,6 +93,7 @@ static const struct ssb_device_id b43_ss
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
 	SSB_DEVTABLE_END
 };
 
@@ -3064,7 +3065,7 @@ static int b43_phy_versioning(struct b43
 			unsupported = 1;
 		break;
 	case B43_PHYTYPE_G:
-		if (phy_rev > 8)
+		if (phy_rev > 9)
 			unsupported = 1;
 		break;
 	default:
Index: wireless-2.6/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
+++ wireless-2.6/drivers/net/wireless/b43/wa.c
@@ -642,6 +642,7 @@ void b43_wa_all(struct b43_wldev *dev)
 		case 6:
 		case 7:
 		case 8:
+		case 9:
 			b43_wa_tr_ltov(dev);
 			b43_wa_crs_ed(dev);
 			b43_wa_rssi_lt(dev);


From Larry.Finger at lwfinger.net  Mon Nov 26 17:45:49 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 26 Nov 2007 10:45:49 -0600
Subject: Patch for 4311/2 to work with mainline 2.6.24-rcX
Message-ID: <474AF83D.1050608@lwfinger.net>

I have created a patch that updates all the SPROM handling and the other code needed to drive the
BCM4311 rev 02 with the mainline code in Linus's tree. Normally, I would have placed this patch on
my FTP server, but that machine will go off-line in the next day, or so. Is there some other
location where this could be made available?

Larry


From mb at bu3sch.de  Mon Nov 26 17:57:47 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 26 Nov 2007 17:57:47 +0100
Subject: [PATCH V5] b43: Changes to enable BCM4311 rev 02 with wireless
	core revision 13
In-Reply-To: <474af47b.cWuJogLu6VTKxmSg%Larry.Finger@lwfinger.net>
References: <474af47b.cWuJogLu6VTKxmSg%Larry.Finger@lwfinger.net>
Message-ID: <200711261757.47923.mb@bu3sch.de>

On Monday 26 November 2007 17:29:47 Larry Finger wrote:
> The BCM94311MCG rev 02 chip has an 802.11 core with revision 13 and
> has not been supported until now. The changes include the following:
> 
> (1) Add the 802.11 rev 13 device to the ssb_device_id table to load b43.
> (2) Add PHY revision 9 to the supported list.
> (3) Change the 2-bit routing code for address extensions to 0b10 rather
>     than the 0b01 used for the 32-bit case.
> (4) Remove some magic numbers in the DMA setup.
> 
> The DMA implementation for this chip supports full 64-bit addressing with
> one exception. Whenever the Descriptor Ring Buffer is in high memory, a
> fatal DMA error occurs. This problem was not present in 2.6.24-rc2 due
> to code to "Bias the placement of kernel pages at lower PFNs". When
> commit 44048d70 reverted that code, the DMA error appeared. As a "fix",
> use the GFP_DMA flag when allocating the buffer for 64-bit DMA. At present,
> this problem is thought to arise from a hardware error.
> 
> This patch has been tested on my system and by C?dric Caumont
> <icare40 at hotmail.com>.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>

Acked-by: Michael Buesch <mb at bu3sch.de>

> ---
> 
> John,
> 
> This patch is intended for the everything branch of wireless-2.6.
> 
> Larry
> ---
> 
>  dma.c  |   30 ++++++++++++++++++++++--------
>  main.c |    3 ++-
>  wa.c   |    1 +
>  3 files changed, 25 insertions(+), 9 deletions(-)
> 
> Index: wireless-2.6/drivers/net/wireless/b43/dma.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/dma.c
> +++ wireless-2.6/drivers/net/wireless/b43/dma.c
> @@ -165,7 +165,7 @@ static void op64_fill_descriptor(struct 
>  	addrhi = (((u64) dmaaddr >> 32) & ~SSB_DMA_TRANSLATION_MASK);
>  	addrext = (((u64) dmaaddr >> 32) & SSB_DMA_TRANSLATION_MASK)
>  	    >> SSB_DMA_TRANSLATION_SHIFT;
> -	addrhi |= ssb_dma_translation(ring->dev->dev);
> +	addrhi |= (ssb_dma_translation(ring->dev->dev) << 1);
>  	if (slot == ring->nr_slots - 1)
>  		ctl0 |= B43_DMA64_DCTL0_DTABLEEND;
>  	if (start)
> @@ -426,9 +426,21 @@ static inline
>  static int alloc_ringmemory(struct b43_dmaring *ring)
>  {
>  	struct device *dev = ring->dev->dev->dev;
> +	gfp_t flags = GFP_KERNEL;
>  
> +	/* The specs call for 4K buffers for 30- and 32-bit DMA with 4K
> +	 * alignment and 8K buffers for 64-bit DMA with 8K alignment. Testing
> +	 * has shown that 4K is sufficient for the latter as long as the buffer
> +	 * does not cross an 8K boundary.
> +	 *
> +	 * For unknown reasons - possibly a hardware error - the BCM4311 rev
> +	 * 02, which uses 64-bit DMA, needs the ring buffer in very low memory,
> +	 * which accounts for the GFP_DMA flag below.
> +	 */
> +	if (ring->dma64)
> +		flags |= GFP_DMA;
>  	ring->descbase = dma_alloc_coherent(dev, B43_DMA_RINGMEMSIZE,
> -					    &(ring->dmabase), GFP_KERNEL);
> +					    &(ring->dmabase), flags);
>  	if (!ring->descbase) {
>  		b43err(ring->dev->wl, "DMA ringmemory allocation failed\n");
>  		return -ENOMEM;
> @@ -483,7 +495,7 @@ int b43_dmacontroller_rx_reset(struct b4
>  	return 0;
>  }
>  
> -/* Reset the RX DMA channel */
> +/* Reset the TX DMA channel */
>  int b43_dmacontroller_tx_reset(struct b43_wldev *dev, u16 mmio_base, int dma64)
>  {
>  	int i;
> @@ -647,7 +659,7 @@ static int dmacontroller_setup(struct b4
>  			b43_dma_write(ring, B43_DMA64_TXRINGHI,
>  				      ((ringbase >> 32) &
>  				       ~SSB_DMA_TRANSLATION_MASK)
> -				      | trans);
> +				      | (trans << 1));
>  		} else {
>  			u32 ringbase = (u32) (ring->dmabase);
>  
> @@ -680,8 +692,9 @@ static int dmacontroller_setup(struct b4
>  			b43_dma_write(ring, B43_DMA64_RXRINGHI,
>  				      ((ringbase >> 32) &
>  				       ~SSB_DMA_TRANSLATION_MASK)
> -				      | trans);
> -			b43_dma_write(ring, B43_DMA64_RXINDEX, 200);
> +				      | (trans << 1));
> +			b43_dma_write(ring, B43_DMA64_RXINDEX, ring->nr_slots *
> +				      sizeof(struct b43_dmadesc64));
>  		} else {
>  			u32 ringbase = (u32) (ring->dmabase);
>  
> @@ -695,11 +708,12 @@ static int dmacontroller_setup(struct b4
>  			b43_dma_write(ring, B43_DMA32_RXRING,
>  				      (ringbase & ~SSB_DMA_TRANSLATION_MASK)
>  				      | trans);
> -			b43_dma_write(ring, B43_DMA32_RXINDEX, 200);
> +			b43_dma_write(ring, B43_DMA32_RXINDEX, ring->nr_slots *
> +				      sizeof(struct b43_dmadesc32));
>  		}
>  	}
>  
> -      out:
> +out:
>  	return err;
>  }
>  
> Index: wireless-2.6/drivers/net/wireless/b43/main.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/main.c
> +++ wireless-2.6/drivers/net/wireless/b43/main.c
> @@ -93,6 +93,7 @@ static const struct ssb_device_id b43_ss
>  	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
>  	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
>  	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
> +	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
>  	SSB_DEVTABLE_END
>  };
>  
> @@ -3064,7 +3065,7 @@ static int b43_phy_versioning(struct b43
>  			unsupported = 1;
>  		break;
>  	case B43_PHYTYPE_G:
> -		if (phy_rev > 8)
> +		if (phy_rev > 9)
>  			unsupported = 1;
>  		break;
>  	default:
> Index: wireless-2.6/drivers/net/wireless/b43/wa.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
> +++ wireless-2.6/drivers/net/wireless/b43/wa.c
> @@ -642,6 +642,7 @@ void b43_wa_all(struct b43_wldev *dev)
>  		case 6:
>  		case 7:
>  		case 8:
> +		case 9:
>  			b43_wa_tr_ltov(dev);
>  			b43_wa_crs_ed(dev);
>  			b43_wa_rssi_lt(dev);
> 
> 



-- 
Greetings Michael.


From johannes at sipsolutions.net  Mon Nov 26 18:10:13 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 26 Nov 2007 18:10:13 +0100
Subject: Patch for 4311/2 to work with mainline 2.6.24-rcX
In-Reply-To: <474AF83D.1050608@lwfinger.net>
	(sfid-20071126_164642_134976_7E658A55)
References: <474AF83D.1050608@lwfinger.net>
	(sfid-20071126_164642_134976_7E658A55)
Message-ID: <1196097013.4149.315.camel@johannes.berg>


On Mon, 2007-11-26 at 10:45 -0600, Larry Finger wrote:
> I have created a patch that updates all the SPROM handling and the other code needed to drive the
> BCM4311 rev 02 with the mainline code in Linus's tree. Normally, I would have placed this patch on
> my FTP server, but that machine will go off-line in the next day, or so. Is there some other
> location where this could be made available?

If you send me an ssh public key I can give you write access to the
download dir on linuxwireless.org.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071126/768396f5/attachment.pgp>

From gavron at wetwork.net  Mon Nov 26 22:23:46 2007
From: gavron at wetwork.net (Ehud Gavron)
Date: Mon, 26 Nov 2007 14:23:46 -0700
Subject: [Bug 9414] Not work light of button-led with module b43 in chipset
	broadcom 4318
In-Reply-To: <474AE27E.2000407@lwfinger.net>
References: <20071125212527.6645610806E@picon.linux-foundation.org>
	<474A20CE.3020307@lwfinger.net> <200711261514.23736.mb@bu3sch.de>
	<474AE27E.2000407@lwfinger.net>
Message-ID: <474B3962.3090002@wetwork.net>

LEDs work with Fedora Kernel 2.6.23.1-42.fc8.
LEDs NOT  with Fedora Kernel 2.6.23.1-49.fc8
LEDs NOT  with everything/2.6.24-rc2
LEDs NOT  with wireless-2.6/2.6.24-rc3

I have the same settings in dot config as Larry does below and I have 
the same info except for ...uevent has a power button but I didn't see 
anything in any ...uevent that looked related to B43.

I'd post a uname -a but you have the kernel names above.
I'd post a dmesg but they are unchanged.
I'd post an iwconfig but they don't matter.  EVERYTHING WORKS except for 
the LEDs except they do work with the earlier Fedora kernel but not the 
latter one.

Ehud

Larry Finger wrote:
> Michael Buesch wrote:
>   
>> Dunno. That's a poll-input-dev problem then. Do you have all poll-input options enabled?
>>
>>     
>
> I think so. I have the following in .config:
>
> CONFIG_RFKILL=m
> CONFIG_RFKILL_INPUT=m
> CONFIG_RFKILL_LEDS=y
>
> ....
>
> # Input device support
> #
> CONFIG_INPUT=y
> # CONFIG_INPUT_FF_MEMLESS is not set
> CONFIG_INPUT_POLLDEV=m
>
> I also tried it with the three components built in rather than as modules. It did not make a difference.
>
> Because the log has the message "input: Unspecified device as /class/input/input7", I have looked at
> the contents of /sys/class. I find that "/sys/class/input/input7/uevent" contains
>
> PRODUCT=0/0/0/0
> EV==1
> MODALIAS=input:b0000v0000p0000e0000-e0,kramlsfw
>
>
> whereas /sys/class/input/input6/uevent has
>
> PRODUCT=19/0/1/0
> NAME="Power Button (CM)"
> PHYS="PNP0C0C/button/input0"
> EV==3
> KEY==10000000000000 0
> MODALIAS=input:b0019v0000p0001e0000-e0,1,k74,ramlsfw
>
> I have no idea how to interpret these data; however, #6 certainly has a lot more information than
> #7. I'm pretty sure #7 is associated with the BCM4311.
>
> Larry
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20071126/780056d6/attachment.html>

From larry.finger at lwfinger.net  Mon Nov 26 23:15:53 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 26 Nov 2007 16:15:53 -0600
Subject: [Bug 9414] Not work light of button-led with module b43 in chipset
	broadcom 4318
In-Reply-To: <474B3962.3090002@wetwork.net>
References: <20071125212527.6645610806E@picon.linux-foundation.org>
	<474A20CE.3020307@lwfinger.net> <200711261514.23736.mb@bu3sch.de>
	<474AE27E.2000407@lwfinger.net> <474B3962.3090002@wetwork.net>
Message-ID: <474B4599.9090007@lwfinger.net>

Based on the code in the rtx200 directories that has a call to input_allocate_device() that was not
present in b43, I made a modification to drivers/net/wireless/b43/rfkill.c as follows:

Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
@@ -133,6 +133,16 @@ void b43_rfkill_init(struct b43_wldev *d
 	rfk->poll_dev->poll = b43_rfkill_poll;
 	rfk->poll_dev->poll_interval = 1000; /* msecs */

+	rfk->poll_dev->input = input_allocate_device();
+	if (!rfk->poll_dev->input)
+		goto err_free_polldev;
+
+	rfk->poll_dev->input->name = rfk->name;
+	rfk->poll_dev->input->id.bustype = BUS_HOST;
+	rfk->poll_dev->input->id.vendor = dev->dev->bus->boardinfo.vendor;
+	rfk->poll_dev->input->evbit[0] = BIT(EV_KEY);
+	set_bit(KEY_WLAN, rfk->poll_dev->input->keybit);
+
 	err = rfkill_register(rfk->rfkill);
 	if (err)
 		goto err_free_polldev;


With this change, the input device is attached to b43. The message now is "input: b43-phy0 as
/class/input/input7" rather than the "input: Unspecified device as /class/input/input7" that I had
before. When the radio switch is toggled, I see the expected output:

b43-phy0: Radio hardware status changed to DISABLED
eth1: No ProbeResp from current AP 00:1a:70:46:ba:b1 - assume out of range
eth1: No STA entry for own AP 00:1a:70:46:ba:b1
b43-phy0: Radio hardware status changed to ENABLED

We then get a locking problem:

=======================================================
[ INFO: possible circular locking dependency detected ]
2.6.24-rc3-L2.6-g65d438bf-dirty #24
-------------------------------------------------------
events/0/9 is trying to acquire lock:
 (&wl->mutex){--..}, at: [<ffffffff882a31e1>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]

but task is already holding lock:
 (&rfkill->mutex){--..}, at: [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d

which lock already depends on the new lock.


the existing dependency chain (in reverse order) is:

-> #2 (&rfkill->mutex){--..}:
       [<ffffffff8025951c>] __lock_acquire+0xb34/0xd47
       [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
       [<ffffffff802597b4>] lock_acquire+0x85/0xa9
       [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
       [<ffffffff8040e32e>] mutex_lock_interruptible_nested+0x113/0x31e
       [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
       [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
       [<ffffffff8040bd64>] rfkill_register+0x9b/0x107
       [<ffffffff882a3040>] b43_rfkill_init+0x15e/0x1cb [b43]
       [<ffffffff88293ad4>] b43_wireless_core_init+0x682/0x784 [b43]
       [<ffffffff882948a6>] b43_op_start+0x33/0x74 [b43]
       [<ffffffff881f2a76>] ieee80211_open+0x1c7/0x3dd [mac80211]
       [<ffffffff803b2fda>] dev_open+0x4e/0x88
       [<ffffffff803b18a2>] dev_change_flags+0xaf/0x16b
       [<ffffffff803b9f9d>] do_setlink+0x27a/0x346
       [<ffffffff8040fa9c>] _read_unlock+0x26/0x2b
       [<ffffffff803bb233>] rtnl_setlink+0xf9/0x11c
       [<ffffffff803bb0d3>] rtnetlink_rcv_msg+0x1b6/0x1d5
       [<ffffffff803baf1d>] rtnetlink_rcv_msg+0x0/0x1d5
       [<ffffffff803c36a5>] netlink_rcv_skb+0x3e/0xaa
       [<ffffffff803baf14>] rtnetlink_rcv+0x20/0x29
       [<ffffffff803c344c>] netlink_unicast+0x1d9/0x23a
       [<ffffffff803ac19e>] __alloc_skb+0x8a/0x138
       [<ffffffff803c3c79>] netlink_sendmsg+0x2aa/0x2bd
       [<ffffffff803a6249>] sock_sendmsg+0xdf/0xf8
       [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
       [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
       [<ffffffff8025970e>] __lock_acquire+0xd26/0xd47
       [<ffffffff803a6b7f>] move_addr_to_kernel+0x40/0x49
       [<ffffffff803ad5b9>] verify_iovec+0x4f/0x8e
       [<ffffffff803a6443>] sys_sendmsg+0x1e1/0x253
       [<ffffffff80250916>] up_read+0x26/0x2a
       [<ffffffff8022581f>] do_page_fault+0x3bf/0x764
       [<ffffffff803a72c4>] sys_getsockname+0x66/0x8c
       [<ffffffff80258540>] trace_hardirqs_on+0x11c/0x147
       [<ffffffff8040f5b8>] trace_hardirqs_on_thunk+0x35/0x3a
       [<ffffffff8020c0de>] system_call+0x7e/0x83
       [<ffffffffffffffff>] 0xffffffffffffffff

-> #1 (rfkill_mutex){--..}:
       [<ffffffff8025951c>] __lock_acquire+0xb34/0xd47
       [<ffffffff8040bd50>] rfkill_register+0x87/0x107
       [<ffffffff802597b4>] lock_acquire+0x85/0xa9
       [<ffffffff8040bd50>] rfkill_register+0x87/0x107
       [<ffffffff8040bd50>] rfkill_register+0x87/0x107
       [<ffffffff8040e78a>] mutex_lock_nested+0x10e/0x2b6
       [<ffffffff8040bd50>] rfkill_register+0x87/0x107
       [<ffffffff882a3040>] b43_rfkill_init+0x15e/0x1cb [b43]
       [<ffffffff88293ad4>] b43_wireless_core_init+0x682/0x784 [b43]
       [<ffffffff882948a6>] b43_op_start+0x33/0x74 [b43]
       [<ffffffff881f2a76>] ieee80211_open+0x1c7/0x3dd [mac80211]
       [<ffffffff803b2fda>] dev_open+0x4e/0x88
       [<ffffffff803b18a2>] dev_change_flags+0xaf/0x16b
       [<ffffffff803b9f9d>] do_setlink+0x27a/0x346
       [<ffffffff8040fa9c>] _read_unlock+0x26/0x2b
       [<ffffffff803bb233>] rtnl_setlink+0xf9/0x11c
       [<ffffffff803bb0d3>] rtnetlink_rcv_msg+0x1b6/0x1d5
       [<ffffffff803baf1d>] rtnetlink_rcv_msg+0x0/0x1d5
       [<ffffffff803c36a5>] netlink_rcv_skb+0x3e/0xaa
       [<ffffffff803baf14>] rtnetlink_rcv+0x20/0x29
       [<ffffffff803c344c>] netlink_unicast+0x1d9/0x23a
       [<ffffffff803ac19e>] __alloc_skb+0x8a/0x138
       [<ffffffff803c3c79>] netlink_sendmsg+0x2aa/0x2bd
       [<ffffffff803a6249>] sock_sendmsg+0xdf/0xf8
       [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
       [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
       [<ffffffff8025970e>] __lock_acquire+0xd26/0xd47
       [<ffffffff803a6b7f>] move_addr_to_kernel+0x40/0x49
       [<ffffffff803ad5b9>] verify_iovec+0x4f/0x8e
       [<ffffffff803a6443>] sys_sendmsg+0x1e1/0x253
       [<ffffffff80250916>] up_read+0x26/0x2a
       [<ffffffff8022581f>] do_page_fault+0x3bf/0x764
       [<ffffffff803a72c4>] sys_getsockname+0x66/0x8c
       [<ffffffff80258540>] trace_hardirqs_on+0x11c/0x147
       [<ffffffff8040f5b8>] trace_hardirqs_on_thunk+0x35/0x3a
       [<ffffffff8020c0de>] system_call+0x7e/0x83
       [<ffffffffffffffff>] 0xffffffffffffffff

-> #0 (&wl->mutex){--..}:
       [<ffffffff80256dd7>] print_circular_bug_entry+0x48/0x4f
       [<ffffffff8025941e>] __lock_acquire+0xa36/0xd47
       [<ffffffff882a31e1>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
       [<ffffffff802597b4>] lock_acquire+0x85/0xa9
       [<ffffffff882a31e1>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
       [<ffffffff882a31e1>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
       [<ffffffff8040e78a>] mutex_lock_nested+0x10e/0x2b6
       [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
       [<ffffffff8040bf6f>] rfkill_task_handler+0x0/0x54
       [<ffffffff882a31e1>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
       [<ffffffff8040b944>] rfkill_toggle_radio+0x3c/0x7d
       [<ffffffff8040be96>] rfkill_switch_all+0x3e/0x78
       [<ffffffff8040bfab>] rfkill_task_handler+0x3c/0x54
       [<ffffffff80249914>] run_workqueue+0xeb/0x200
       [<ffffffff8024a500>] worker_thread+0xed/0xfe
       [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
       [<ffffffff8024a413>] worker_thread+0x0/0xfe
       [<ffffffff8024da6e>] kthread+0x49/0x77
       [<ffffffff8020d018>] child_rip+0xa/0x12
       [<ffffffff8020c72f>] restore_args+0x0/0x30
       [<ffffffff8024da25>] kthread+0x0/0x77
       [<ffffffff8020d00e>] child_rip+0x0/0x12
       [<ffffffffffffffff>] 0xffffffffffffffff

other info that might help us debug this:

5 locks held by events/0/9:
 #0:  (events){--..}, at: [<ffffffff802498c9>] run_workqueue+0xa0/0x200
 #1:  (rfkill_wlan.work){--..}, at: [<ffffffff802498c9>] run_workqueue+0xa0/0x200
 #2:  (rfkill_wlan.mutex){--..}, at: [<ffffffff8040bf8d>] rfkill_task_handler+0x1e/0x54
 #3:  (rfkill_mutex){--..}, at: [<ffffffff8040be74>] rfkill_switch_all+0x1c/0x78
 #4:  (&rfkill->mutex){--..}, at: [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d

stack backtrace:

Call Trace:
 [<ffffffff8025779c>] print_circular_bug_tail+0x70/0x7b
 [<ffffffff80256dd7>] print_circular_bug_entry+0x48/0x4f
 [<ffffffff8025941e>] __lock_acquire+0xa36/0xd47
 [<ffffffff882a31e1>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
 [<ffffffff802597b4>] lock_acquire+0x85/0xa9
 [<ffffffff882a31e1>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
 [<ffffffff882a31e1>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
 [<ffffffff8040e78a>] mutex_lock_nested+0x10e/0x2b6
 [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
 [<ffffffff8040bf6f>] rfkill_task_handler+0x0/0x54
 [<ffffffff882a31e1>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
 [<ffffffff8040b944>] rfkill_toggle_radio+0x3c/0x7d
 [<ffffffff8040be96>] rfkill_switch_all+0x3e/0x78
 [<ffffffff8040bfab>] rfkill_task_handler+0x3c/0x54
 [<ffffffff80249914>] run_workqueue+0xeb/0x200
 [<ffffffff8024a500>] worker_thread+0xed/0xfe
 [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
 [<ffffffff8024a413>] worker_thread+0x0/0xfe
 [<ffffffff8024da6e>] kthread+0x49/0x77
 [<ffffffff8020d018>] child_rip+0xa/0x12
 [<ffffffff8020c72f>] restore_args+0x0/0x30
 [<ffffffff8024da25>] kthread+0x0/0x77
 [<ffffffff8020d00e>] child_rip+0x0/0x12

During all this, the LED is not turned on.

I'm hoping it won't be too difficult to sort this out. I've gotten in a little deeper than I want.

Thanks,

Larry


From mb at bu3sch.de  Tue Nov 27 15:54:36 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 27 Nov 2007 15:54:36 +0100
Subject: [Bug 9414] Not work light of button-led with module b43 in
	chipset broadcom 4318
In-Reply-To: <474B4599.9090007@lwfinger.net>
References: <20071125212527.6645610806E@picon.linux-foundation.org>
	<474B3962.3090002@wetwork.net> <474B4599.9090007@lwfinger.net>
Message-ID: <200711271554.37397.mb@bu3sch.de>

On Monday 26 November 2007 23:15:53 Larry Finger wrote:
> Based on the code in the rtx200 directories that has a call to input_allocate_device() that was not
> present in b43, I made a modification to drivers/net/wireless/b43/rfkill.c as follows:
> 
> Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
> +++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
> @@ -133,6 +133,16 @@ void b43_rfkill_init(struct b43_wldev *d
>  	rfk->poll_dev->poll = b43_rfkill_poll;
>  	rfk->poll_dev->poll_interval = 1000; /* msecs */
> 
> +	rfk->poll_dev->input = input_allocate_device();
> +	if (!rfk->poll_dev->input)
> +		goto err_free_polldev;
> +
> +	rfk->poll_dev->input->name = rfk->name;
> +	rfk->poll_dev->input->id.bustype = BUS_HOST;
> +	rfk->poll_dev->input->id.vendor = dev->dev->bus->boardinfo.vendor;
> +	rfk->poll_dev->input->evbit[0] = BIT(EV_KEY);
> +	set_bit(KEY_WLAN, rfk->poll_dev->input->keybit);
> +

Ehm, you saw a few lines above that we do
input_allocate_polled_device()?

101 struct input_polled_dev *input_allocate_polled_device(void)
102 {
103         struct input_polled_dev *dev;
104 
105         dev = kzalloc(sizeof(struct input_polled_dev), GFP_KERNEL);
106         if (!dev)
107                 return NULL;
108 
109         dev->input = input_allocate_device();
110         if (!dev->input) {
111                 kfree(dev);
112                 return NULL;
113         }
114 
115         return dev;
116 }

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Tue Nov 27 16:59:49 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 27 Nov 2007 09:59:49 -0600
Subject: [Bug 9414] Not work light of button-led with module b43 in chipset
	broadcom 4318
In-Reply-To: <200711271554.37397.mb@bu3sch.de>
References: <20071125212527.6645610806E@picon.linux-foundation.org>
	<474B3962.3090002@wetwork.net> <474B4599.9090007@lwfinger.net>
	<200711271554.37397.mb@bu3sch.de>
Message-ID: <474C3EF5.3090705@lwfinger.net>

Michael Buesch wrote:
> On Monday 26 November 2007 23:15:53 Larry Finger wrote:
>> Based on the code in the rtx200 directories that has a call to input_allocate_device() that was not
>> present in b43, I made a modification to drivers/net/wireless/b43/rfkill.c as follows:
>>
>> Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
>> ===================================================================
>> --- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
>> +++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
>> @@ -133,6 +133,16 @@ void b43_rfkill_init(struct b43_wldev *d
>>  	rfk->poll_dev->poll = b43_rfkill_poll;
>>  	rfk->poll_dev->poll_interval = 1000; /* msecs */
>>
>> +	rfk->poll_dev->input = input_allocate_device();
>> +	if (!rfk->poll_dev->input)
>> +		goto err_free_polldev;
>> +
>> +	rfk->poll_dev->input->name = rfk->name;
>> +	rfk->poll_dev->input->id.bustype = BUS_HOST;
>> +	rfk->poll_dev->input->id.vendor = dev->dev->bus->boardinfo.vendor;
>> +	rfk->poll_dev->input->evbit[0] = BIT(EV_KEY);
>> +	set_bit(KEY_WLAN, rfk->poll_dev->input->keybit);
>> +
> 
> Ehm, you saw a few lines above that we do
> input_allocate_polled_device()?

I had not investigated the details of input_allocate_polled_device(). The part that was missing in
b43 is the initialization of the rfk->poll_dev->input data. I will be posting a patch/hack that
restores the LED behavior that we had before the rfkill code went in.

BTW, there is a bug in rt2x00rfkill.c.

Larry


From Larry.Finger at lwfinger.net  Tue Nov 27 17:03:57 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 27 Nov 2007 10:03:57 -0600
Subject: [RFC/T] b43: Fix Radio On/Off LED action
Message-ID: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>

Since addition of the rfkill callback, the LED associated with the off
switch on the radio has not worked because essential data in the rfkill
structure was missing. This hack adds the necessary data and places direct
calls to turn the leds on/off.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
@@ -23,6 +23,7 @@
 */
 
 #include "rfkill.h"
+#include "leds.h"
 #include "b43.h"
 
 
@@ -57,6 +58,10 @@ static void b43_rfkill_poll(struct input
 		report_change = 1;
 		b43info(wl, "Radio hardware status changed to %s\n",
 			enabled ? "ENABLED" : "DISABLED");
+		if (enabled)
+			b43_led_turn_on(dev, 1, 1);
+		else
+			b43_led_turn_off(dev, 1, 1);
 	}
 	mutex_unlock(&wl->mutex);
 
@@ -70,11 +75,13 @@ static int b43_rfkill_soft_toggle(void *
 	struct b43_wldev *dev = data;
 	struct b43_wl *wl = dev->wl;
 	int err = 0;
+	int lock = mutex_is_locked(&wl->mutex);
 
 	if (!wl->rfkill.registered)
 		return 0;
 
-	mutex_lock(&wl->mutex);
+	if (!lock)
+		mutex_lock(&wl->mutex);
 	B43_WARN_ON(b43_status(dev) < B43_STAT_INITIALIZED);
 	switch (state) {
 	case RFKILL_STATE_ON:
@@ -93,7 +100,8 @@ static int b43_rfkill_soft_toggle(void *
 		break;
 	}
 out_unlock:
-	mutex_unlock(&wl->mutex);
+	if (!lock)
+		mutex_unlock(&wl->mutex);
 
 	return err;
 }
@@ -133,6 +141,12 @@ void b43_rfkill_init(struct b43_wldev *d
 	rfk->poll_dev->poll = b43_rfkill_poll;
 	rfk->poll_dev->poll_interval = 1000; /* msecs */
 
+	rfk->poll_dev->input->name = rfk->name;
+	rfk->poll_dev->input->id.bustype = BUS_HOST;
+	rfk->poll_dev->input->id.vendor = dev->dev->bus->boardinfo.vendor;
+	rfk->poll_dev->input->evbit[0] = BIT(EV_KEY);
+	set_bit(KEY_WLAN, rfk->poll_dev->input->keybit);
+
 	err = rfkill_register(rfk->rfkill);
 	if (err)
 		goto err_free_polldev;
Index: wireless-2.6/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.c
+++ wireless-2.6/drivers/net/wireless/b43/leds.c
@@ -30,7 +30,7 @@
 #include "leds.h"
 
 
-static void b43_led_turn_on(struct b43_wldev *dev, u8 led_index,
+void b43_led_turn_on(struct b43_wldev *dev, u8 led_index,
 			    bool activelow)
 {
 	struct b43_wl *wl = dev->wl;
@@ -47,7 +47,7 @@ static void b43_led_turn_on(struct b43_w
 	spin_unlock_irqrestore(&wl->leds_lock, flags);
 }
 
-static void b43_led_turn_off(struct b43_wldev *dev, u8 led_index,
+void b43_led_turn_off(struct b43_wldev *dev, u8 led_index,
 			     bool activelow)
 {
 	struct b43_wl *wl = dev->wl;
Index: wireless-2.6/drivers/net/wireless/b43/leds.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.h
+++ wireless-2.6/drivers/net/wireless/b43/leds.h
@@ -44,7 +44,10 @@ enum b43_led_behaviour {
 
 void b43_leds_init(struct b43_wldev *dev);
 void b43_leds_exit(struct b43_wldev *dev);
-
+void b43_led_turn_on(struct b43_wldev *dev, u8 led_index,
+			     bool activelow);
+void b43_led_turn_off(struct b43_wldev *dev, u8 led_index,
+			     bool activelow);
 
 #else /* CONFIG_B43_LEDS */
 /* LED support disabled */
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -2799,6 +2799,8 @@ static int b43_op_config(struct ieee8021
 	b43_interrupt_enable(dev, savedirqs);
 	mmiowb();
 	spin_unlock_irqrestore(&wl->irq_lock, flags);
+	if (dev->radio_hw_enable)
+		b43_led_turn_on(dev, 1, 1);
       out_unlock_mutex:
 	mutex_unlock(&wl->mutex);
 


From mb at bu3sch.de  Tue Nov 27 17:13:02 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 27 Nov 2007 17:13:02 +0100
Subject: [RFC/T] b43: Fix Radio On/Off LED action
In-Reply-To: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
Message-ID: <200711271713.02698.mb@bu3sch.de>

On Tuesday 27 November 2007 17:03:57 Larry Finger wrote:
> Since addition of the rfkill callback, the LED associated with the off
> switch on the radio has not worked because essential data in the rfkill
> structure was missing. This hack adds the necessary data and places direct
> calls to turn the leds on/off.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
> +++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
> @@ -23,6 +23,7 @@
>  */
>  
>  #include "rfkill.h"
> +#include "leds.h"
>  #include "b43.h"
>  
>  
> @@ -57,6 +58,10 @@ static void b43_rfkill_poll(struct input
>  		report_change = 1;
>  		b43info(wl, "Radio hardware status changed to %s\n",
>  			enabled ? "ENABLED" : "DISABLED");
> +		if (enabled)
> +			b43_led_turn_on(dev, 1, 1);
> +		else
> +			b43_led_turn_off(dev, 1, 1);
>  	}
>  	mutex_unlock(&wl->mutex);
>  

This is not how led triggers work.
You are shortcutting the whole thing here. So you could as well
remove the whole rfkill and LEDs code.

Please properly register the LED in the leds code and
add a default LED trigger for the rfkill trigger.
This has several advantages to the user, among the possiblility to
reassign a LED to a different trigger.

> @@ -70,11 +75,13 @@ static int b43_rfkill_soft_toggle(void *
>  	struct b43_wldev *dev = data;
>  	struct b43_wl *wl = dev->wl;
>  	int err = 0;
> +	int lock = mutex_is_locked(&wl->mutex);
>  
>  	if (!wl->rfkill.registered)
>  		return 0;
>  
> -	mutex_lock(&wl->mutex);
> +	if (!lock)
> +		mutex_lock(&wl->mutex);

Nah, it shouldn't be locked by "current" in the first place, here.
(I guess that's what you are trying to check here).
That's what the !registered check above is for.
This !lock check is racy.

>  	B43_WARN_ON(b43_status(dev) < B43_STAT_INITIALIZED);
>  	switch (state) {
>  	case RFKILL_STATE_ON:
> @@ -93,7 +100,8 @@ static int b43_rfkill_soft_toggle(void *
>  		break;
>  	}
>  out_unlock:
> -	mutex_unlock(&wl->mutex);
> +	if (!lock)
> +		mutex_unlock(&wl->mutex);
>  
>  	return err;


-- 
Greetings Michael.


From larry.finger at lwfinger.net  Tue Nov 27 17:28:33 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 27 Nov 2007 10:28:33 -0600
Subject: [RFC/T] b43: Fix Radio On/Off LED action
In-Reply-To: <200711271713.02698.mb@bu3sch.de>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711271713.02698.mb@bu3sch.de>
Message-ID: <474C45B1.3050909@lwfinger.net>

Michael Buesch wrote:
> On Tuesday 27 November 2007 17:03:57 Larry Finger wrote:
> This is not how led triggers work.
> You are shortcutting the whole thing here. So you could as well
> remove the whole rfkill and LEDs code.

It just plain doesn't work now. What I'm trying to do is get something to the users that will
restore the behavior they want while we work out the details of the rfkill and LEDs code.

> Please properly register the LED in the leds code and
> add a default LED trigger for the rfkill trigger.
> This has several advantages to the user, among the possiblility to
> reassign a LED to a different trigger.

How do I do that?

>> @@ -70,11 +75,13 @@ static int b43_rfkill_soft_toggle(void *
>>  	struct b43_wldev *dev = data;
>>  	struct b43_wl *wl = dev->wl;
>>  	int err = 0;
>> +	int lock = mutex_is_locked(&wl->mutex);
>>  
>>  	if (!wl->rfkill.registered)
>>  		return 0;
>>  
>> -	mutex_lock(&wl->mutex);
>> +	if (!lock)
>> +		mutex_lock(&wl->mutex);
> 
> Nah, it shouldn't be locked by "current" in the first place, here.
> (I guess that's what you are trying to check here).
> That's what the !registered check above is for.
> This !lock check is racy.

If you recall my message from yesterday, I got a locking error. That is what I'm trying to prevent.
I know it is racy, but I don't know the correct way to do it.

Larry



From Larry.Finger at lwfinger.net  Tue Nov 27 17:34:56 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 27 Nov 2007 10:34:56 -0600
Subject: Patch available to use BCM4311/2 with mainline kernels
Message-ID: <474C4730.7000002@lwfinger.net>

A patch to make the modifications for ssb and b43 necessary to use the BCM94311MCG rev02 and BCM4312
rev02 cards with kernel 2.6.24-rc2 (and later) mainline kernels may be obtained from

http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2

Larry




From mb at bu3sch.de  Tue Nov 27 18:05:09 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 27 Nov 2007 18:05:09 +0100
Subject: [RFC/T] b43: Fix Radio On/Off LED action
In-Reply-To: <474C45B1.3050909@lwfinger.net>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711271713.02698.mb@bu3sch.de> <474C45B1.3050909@lwfinger.net>
Message-ID: <200711271805.09304.mb@bu3sch.de>

On Tuesday 27 November 2007 17:28:33 Larry Finger wrote:
> Michael Buesch wrote:
> > On Tuesday 27 November 2007 17:03:57 Larry Finger wrote:
> > This is not how led triggers work.
> > You are shortcutting the whole thing here. So you could as well
> > remove the whole rfkill and LEDs code.
> 
> It just plain doesn't work now. What I'm trying to do is get something to the users that will
> restore the behavior they want while we work out the details of the rfkill and LEDs code.

Well, ok. But we don't apply this to mainline. As
a temporary patch for users it's OK.

> > Please properly register the LED in the leds code and
> > add a default LED trigger for the rfkill trigger.
> > This has several advantages to the user, among the possiblility to
> > reassign a LED to a different trigger.
> 
> How do I do that?

Well, what you basically have to do it restore the old
mapping in b43_map_led().
Look at the "case B43_LED_RADIO_ALL" (and below) statement.
It maps these LEDs to the rfkill trigger.
So you have to find out which behaviour value your LED has and
map that to the rfkill trigger in this function.

So when the rfkill LED trigger triggers, it will enable/disable this LED.
That's all done behind the scenes.

> >> @@ -70,11 +75,13 @@ static int b43_rfkill_soft_toggle(void *
> >>  	struct b43_wldev *dev = data;
> >>  	struct b43_wl *wl = dev->wl;
> >>  	int err = 0;
> >> +	int lock = mutex_is_locked(&wl->mutex);
> >>  
> >>  	if (!wl->rfkill.registered)
> >>  		return 0;
> >>  
> >> -	mutex_lock(&wl->mutex);
> >> +	if (!lock)
> >> +		mutex_lock(&wl->mutex);
> > 
> > Nah, it shouldn't be locked by "current" in the first place, here.
> > (I guess that's what you are trying to check here).
> > That's what the !registered check above is for.
> > This !lock check is racy.
> 
> If you recall my message from yesterday, I got a locking error. That is what I'm trying to prevent.
> I know it is racy, but I don't know the correct way to do it.

I think RFkill has a bad design regarding this.
It does synchronously call back into the driver from a call made by
the driver. That is broken by design. Maybe it's best to fix this
in rfkill and let it asynchronously call back on rfkill_init.
Synchronous callbacks from calls made by drivers are broken by design
and will lead to recursive lockings. We can not fix this in the driver,
nor work around it in a sane way. We can hack around it, though, which
is what the !registered flag tries to do. Though, it seems it doesn't
work. :)

-- 
Greetings Michael.


From gavron at wetwork.net  Tue Nov 27 19:29:13 2007
From: gavron at wetwork.net (Ehud Gavron)
Date: Tue, 27 Nov 2007 11:29:13 -0700
Subject: [RFC/T] b43: Fix Radio On/Off LED action
In-Reply-To: <200711271805.09304.mb@bu3sch.de>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711271713.02698.mb@bu3sch.de> <474C45B1.3050909@lwfinger.net>
	<200711271805.09304.mb@bu3sch.de>
Message-ID: <474C61F9.2020602@wetwork.net>



Michael Buesch wrote:
> On Tuesday 27 November 2007 17:28:33 Larry Finger wrote:
>   
>> Michael Buesch wrote:
>>     
>>> On Tuesday 27 November 2007 17:03:57 Larry Finger wrote:
>>> This is not how led triggers work.
>>> You are shortcutting the whole thing here. So you could as well
>>> remove the whole rfkill and LEDs code.
>>>       
>> It just plain doesn't work now. What I'm trying to do is get something to the users that will
>> restore the behavior they want while we work out the details of the rfkill and LEDs code.
>>     
>
> Well, ok. But we don't apply this to mainline. As
> a temporary patch for users it's OK.
>   
Yes, it is! :)  Works great!
$ uname -a
Linux egdell.wetwork.net 2.6.24-rc3-LF27NOV2007 #2 SMP Tue Nov 27 
09:19:11 MST 2007 x86_64 x86_64 x86_64 GNU/Linux

E


>   
>>> Please properly register the LED in the leds code and
>>> add a default LED trigger for the rfkill trigger.
>>> This has several advantages to the user, among the possiblility to
>>> reassign a LED to a different trigger.
>>>       
>> How do I do that?
>>     
>
> Well, what you basically have to do it restore the old
> mapping in b43_map_led().
> Look at the "case B43_LED_RADIO_ALL" (and below) statement.
> It maps these LEDs to the rfkill trigger.
> So you have to find out which behaviour value your LED has and
> map that to the rfkill trigger in this function.
>
> So when the rfkill LED trigger triggers, it will enable/disable this LED.
> That's all done behind the scenes.
>
>   
>>>> @@ -70,11 +75,13 @@ static int b43_rfkill_soft_toggle(void *
>>>>  	struct b43_wldev *dev = data;
>>>>  	struct b43_wl *wl = dev->wl;
>>>>  	int err = 0;
>>>> +	int lock = mutex_is_locked(&wl->mutex);
>>>>  
>>>>  	if (!wl->rfkill.registered)
>>>>  		return 0;
>>>>  
>>>> -	mutex_lock(&wl->mutex);
>>>> +	if (!lock)
>>>> +		mutex_lock(&wl->mutex);
>>>>         
>>> Nah, it shouldn't be locked by "current" in the first place, here.
>>> (I guess that's what you are trying to check here).
>>> That's what the !registered check above is for.
>>> This !lock check is racy.
>>>       
>> If you recall my message from yesterday, I got a locking error. That is what I'm trying to prevent.
>> I know it is racy, but I don't know the correct way to do it.
>>     
>
> I think RFkill has a bad design regarding this.
> It does synchronously call back into the driver from a call made by
> the driver. That is broken by design. Maybe it's best to fix this
> in rfkill and let it asynchronously call back on rfkill_init.
> Synchronous callbacks from calls made by drivers are broken by design
> and will lead to recursive lockings. We can not fix this in the driver,
> nor work around it in a sane way. We can hack around it, though, which
> is what the !registered flag tries to do. Though, it seems it doesn't
> work. :)
>
>   


From larry.finger at lwfinger.net  Tue Nov 27 19:33:41 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 27 Nov 2007 12:33:41 -0600
Subject: [Bug 9414] Not work light of button-led with module b43 in chipset
	broadcom 4318
In-Reply-To: <200711272033.11110.IvDoorn@gmail.com>
References: <20071125212527.6645610806E@picon.linux-foundation.org>
	<200711271554.37397.mb@bu3sch.de> <474C3EF5.3090705@lwfinger.net>
	<200711272033.11110.IvDoorn@gmail.com>
Message-ID: <474C6305.6050500@lwfinger.net>

Ivo van Doorn wrote:
> Hi,
> 
>>> On Monday 26 November 2007 23:15:53 Larry Finger wrote:
>>>> Based on the code in the rtx200 directories that has a call to input_allocate_device() that was not
>>>> present in b43, I made a modification to drivers/net/wireless/b43/rfkill.c as follows:
>>>>
>>>> Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
>>>> ===================================================================
>>>> --- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
>>>> +++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
>>>> @@ -133,6 +133,16 @@ void b43_rfkill_init(struct b43_wldev *d
>>>>  	rfk->poll_dev->poll = b43_rfkill_poll;
>>>>  	rfk->poll_dev->poll_interval = 1000; /* msecs */
>>>>
>>>> +	rfk->poll_dev->input = input_allocate_device();
>>>> +	if (!rfk->poll_dev->input)
>>>> +		goto err_free_polldev;
>>>> +
>>>> +	rfk->poll_dev->input->name = rfk->name;
>>>> +	rfk->poll_dev->input->id.bustype = BUS_HOST;
>>>> +	rfk->poll_dev->input->id.vendor = dev->dev->bus->boardinfo.vendor;
>>>> +	rfk->poll_dev->input->evbit[0] = BIT(EV_KEY);
>>>> +	set_bit(KEY_WLAN, rfk->poll_dev->input->keybit);
>>>> +
>>> Ehm, you saw a few lines above that we do
>>> input_allocate_polled_device()?
>> I had not investigated the details of input_allocate_polled_device(). The part that was missing in
>> b43 is the initialization of the rfk->poll_dev->input data. I will be posting a patch/hack that
>> restores the LED behavior that we had before the rfkill code went in.
> 
> The concept of input_allocate_polled_device() was misintepretet by me as well,
> but when allocating the polled device, you also must allocate a input device seperately
> and make sure the poll_dev->input pointer is initialized. Otherwise the polled dev registration
> will fail.

My testing shows that the separate input_allocate_device call is not needed - only the
initialization is required.
> 
>> BTW, there is a bug in rt2x00rfkill.c.
> 
> Where?

It is not a bug as much as redundant code. I posted a patch to clean up the code, which went to the
wireless mailing list and to rt2400-dev. Sorry, I forgot to include you.

Larry


From mb at bu3sch.de  Tue Nov 27 19:50:08 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 27 Nov 2007 19:50:08 +0100
Subject: [Bug 9414] Not work light of button-led with module b43 in
	chipset broadcom 4318
In-Reply-To: <474C6305.6050500@lwfinger.net>
References: <20071125212527.6645610806E@picon.linux-foundation.org>
	<200711272033.11110.IvDoorn@gmail.com>
	<474C6305.6050500@lwfinger.net>
Message-ID: <200711271950.08609.mb@bu3sch.de>

On Tuesday 27 November 2007 19:33:41 Larry Finger wrote:
> Ivo van Doorn wrote:
> > Hi,
> > 
> >>> On Monday 26 November 2007 23:15:53 Larry Finger wrote:
> >>>> Based on the code in the rtx200 directories that has a call to input_allocate_device() that was not
> >>>> present in b43, I made a modification to drivers/net/wireless/b43/rfkill.c as follows:
> >>>>
> >>>> Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
> >>>> ===================================================================
> >>>> --- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
> >>>> +++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
> >>>> @@ -133,6 +133,16 @@ void b43_rfkill_init(struct b43_wldev *d
> >>>>  	rfk->poll_dev->poll = b43_rfkill_poll;
> >>>>  	rfk->poll_dev->poll_interval = 1000; /* msecs */
> >>>>
> >>>> +	rfk->poll_dev->input = input_allocate_device();
> >>>> +	if (!rfk->poll_dev->input)
> >>>> +		goto err_free_polldev;
> >>>> +
> >>>> +	rfk->poll_dev->input->name = rfk->name;
> >>>> +	rfk->poll_dev->input->id.bustype = BUS_HOST;
> >>>> +	rfk->poll_dev->input->id.vendor = dev->dev->bus->boardinfo.vendor;
> >>>> +	rfk->poll_dev->input->evbit[0] = BIT(EV_KEY);
> >>>> +	set_bit(KEY_WLAN, rfk->poll_dev->input->keybit);
> >>>> +
> >>> Ehm, you saw a few lines above that we do
> >>> input_allocate_polled_device()?
> >> I had not investigated the details of input_allocate_polled_device(). The part that was missing in
> >> b43 is the initialization of the rfk->poll_dev->input data. I will be posting a patch/hack that
> >> restores the LED behavior that we had before the rfkill code went in.
> > 
> > The concept of input_allocate_polled_device() was misintepretet by me as well,
> > but when allocating the polled device, you also must allocate a input device seperately
> > and make sure the poll_dev->input pointer is initialized. Otherwise the polled dev registration
> > will fail.
> 
> My testing shows that the separate input_allocate_device call is not needed - only the
> initialization is required.
> > 
> >> BTW, there is a bug in rt2x00rfkill.c.
> > 
> > Where?
> 
> It is not a bug as much as redundant code.

It is a memory leak in rt2x00rfkill.c, as the structure is allocated twice.
Ivo, look at the code of input_allocate_polled_device(). It already
allocates the input dev.

> I posted a patch to clean up the code, which went to the 
> wireless mailing list and to rt2400-dev. Sorry, I forgot to include you.
> 
> Larry
> 
> 



-- 
Greetings Michael.


From larry.finger at lwfinger.net  Tue Nov 27 21:02:47 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 27 Nov 2007 14:02:47 -0600
Subject: [RFC/T V2] b43: Fix Radio On/Off LED action
In-Reply-To: <200711271713.02698.mb@bu3sch.de>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711271713.02698.mb@bu3sch.de>
Message-ID: <474C77E7.9030202@lwfinger.net>

Michael,

I'm getting a little closer. The problem I discovered now is that b43_leds_init() was being called
before b43_rfkill_init(), which prevented registration of the "radio" LED. Now, the LED is flashed
on for about 1 second, then it goes off. Changing the switch does nothing.

This version uses mutex_trylock() to see if the mutex is already locked. It should do until rfkill
is fixed.

Note to testers: This version does not work. I'm sending it out to get comments.

Larry


Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
@@ -70,11 +70,12 @@ static int b43_rfkill_soft_toggle(void *
 	struct b43_wldev *dev = data;
 	struct b43_wl *wl = dev->wl;
 	int err = 0;
+	int have_lock;

 	if (!wl->rfkill.registered)
 		return 0;

-	mutex_lock(&wl->mutex);
+	have_lock = mutex_trylock(&wl->mutex);
 	B43_WARN_ON(b43_status(dev) < B43_STAT_INITIALIZED);
 	switch (state) {
 	case RFKILL_STATE_ON:
@@ -93,7 +94,8 @@ static int b43_rfkill_soft_toggle(void *
 		break;
 	}
 out_unlock:
-	mutex_unlock(&wl->mutex);
+	if (have_lock)
+		mutex_unlock(&wl->mutex);

 	return err;
 }
@@ -133,6 +135,12 @@ void b43_rfkill_init(struct b43_wldev *d
 	rfk->poll_dev->poll = b43_rfkill_poll;
 	rfk->poll_dev->poll_interval = 1000; /* msecs */

+	rfk->poll_dev->input->name = rfk->name;
+	rfk->poll_dev->input->id.bustype = BUS_HOST;
+	rfk->poll_dev->input->id.vendor = dev->dev->bus->boardinfo.vendor;
+	rfk->poll_dev->input->evbit[0] = BIT(EV_KEY);
+	set_bit(KEY_WLAN, rfk->poll_dev->input->keybit);
+
 	err = rfkill_register(rfk->rfkill);
 	if (err)
 		goto err_free_polldev;
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -2184,7 +2184,6 @@ static int b43_chip_init(struct b43_wlde
 	err = b43_gpio_init(dev);
 	if (err)
 		goto out;	/* firmware is released later */
-	b43_leds_init(dev);

 	err = b43_upload_initvals(dev);
 	if (err)
@@ -3411,6 +3410,7 @@ static int b43_wireless_core_init(struct
 	b43_security_init(dev);
 	b43_rfkill_init(dev);
 	b43_rng_init(wl);
+	b43_leds_init(dev);

 	b43_set_status(dev, B43_STAT_INITIALIZED);



======


From mb at bu3sch.de  Tue Nov 27 21:20:44 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 27 Nov 2007 21:20:44 +0100
Subject: [RFC/T V2] b43: Fix Radio On/Off LED action
In-Reply-To: <474C77E7.9030202@lwfinger.net>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711271713.02698.mb@bu3sch.de> <474C77E7.9030202@lwfinger.net>
Message-ID: <200711272120.44575.mb@bu3sch.de>

On Tuesday 27 November 2007 21:02:47 Larry Finger wrote:
> Michael,
> 
> I'm getting a little closer. The problem I discovered now is that b43_leds_init() was being called
> before b43_rfkill_init(), which prevented registration of the "radio" LED. Now, the LED is flashed
> on for about 1 second, then it goes off. Changing the switch does nothing.

Ok, good catch.
Is the switch properly polled and is the status change properly reported upstream?
If yes, you might want to check (add printk to rfkill code) if the LED
is properly triggered.

> This version uses mutex_trylock() to see if the mutex is already locked. It should do until rfkill
> is fixed.

No it doesn't. This still introduces a race.

I'm wondering who causes this deadlock. "registered" should be false if
we are called back from rfkill_initialize, so it should return early before
the lock.

-- 
Greetings Michael.


From zajec5polish at gmail.com  Tue Nov 27 21:28:15 2007
From: zajec5polish at gmail.com (=?UTF-8?Q?Rafa=C5=82_Mi=C5=82ecki?=)
Date: Tue, 27 Nov 2007 21:28:15 +0100
Subject: Patch available to use BCM4311/2 with mainline kernels
In-Reply-To: <474C4730.7000002@lwfinger.net>
References: <474C4730.7000002@lwfinger.net>
Message-ID: <14b026160711271228m2c3417n58547d7f03024a1e@mail.gmail.com>

2007/11/27, Larry Finger <Larry.Finger at lwfinger.net>:
> A patch to make the modifications for ssb and b43 necessary to use the BCM94311MCG rev02 and BCM4312
> rev02 cards with kernel 2.6.24-rc2 (and later) mainline kernels may be obtained from
>
> http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2

Is this possible to say if this patch will be included in 2.6.25 mainline?

-- 
Rafa? Mi?ecki

From Larry.Finger at lwfinger.net  Tue Nov 27 22:09:12 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 27 Nov 2007 15:09:12 -0600
Subject: Patch available to use BCM4311/2 with mainline kernels
In-Reply-To: <14b026160711271227m99b5feaub3b1f0bfd048417f@mail.gmail.com>
References: <474C4730.7000002@lwfinger.net>
	<14b026160711271227m99b5feaub3b1f0bfd048417f@mail.gmail.com>
Message-ID: <474C8778.6090502@lwfinger.net>

Rafa? Mi?ecki wrote:
> 2007/11/27, Larry Finger <Larry.Finger at lwfinger.net>:
>> A patch to make the modifications for ssb and b43 necessary to use the BCM94311MCG rev02 and BCM4312
>> rev02 cards with kernel 2.6.24-rc2 (and later) mainline kernels may be obtained from
>>
>> http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2
> 
> Is this possible to say if this patch will be included in 2.6.25 mainline?

It should make it into wireless-2.6 relatively soon, and will be in 2.6.25-rcX.

Larry



From larry.finger at lwfinger.net  Tue Nov 27 22:22:22 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 27 Nov 2007 15:22:22 -0600
Subject: [RFC/T V2] b43: Fix Radio On/Off LED action
In-Reply-To: <200711272120.44575.mb@bu3sch.de>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711271713.02698.mb@bu3sch.de> <474C77E7.9030202@lwfinger.net>
	<200711272120.44575.mb@bu3sch.de>
Message-ID: <474C8A8E.6070404@lwfinger.net>

Michael Buesch wrote:
> On Tuesday 27 November 2007 21:02:47 Larry Finger wrote:
> Is the switch properly polled and is the status change properly reported upstream?
> If yes, you might want to check (add printk to rfkill code) if the LED
> is properly triggered.

I know that b43_rfkill_poll() is being called as I can see the ENABLED/DISABLED messages in the log.
I'll have to work my way through the things it calls.

> I'm wondering who causes this deadlock. "registered" should be false if
> we are called back from rfkill_initialize, so it should return early before
> the lock.

The following code has the competing lock:

static int rfkill_toggle_radio(struct rfkill *rfkill,
                                enum rfkill_state state)
{
        int retval;

        retval = mutex_lock_interruptible(&rfkill->mutex);
        if (retval)
                return retval;

        if (state != rfkill->state) {
                retval = rfkill->toggle_radio(rfkill->data, state);
                if (!retval) {
                        rfkill->state = state;
                        rfkill_led_trigger(rfkill, state);
                }
        }

        mutex_unlock(&rfkill->mutex);
        return retval;
}

Larry


From zajec5polish at gmail.com  Tue Nov 27 22:41:53 2007
From: zajec5polish at gmail.com (=?UTF-8?Q?Rafa=C5=82_Mi=C5=82ecki?=)
Date: Tue, 27 Nov 2007 22:41:53 +0100
Subject: [BCM4318/02] authentication timed out for channel 13
Message-ID: <14b026160711271341v4f3afab3rfc8c18617e4a0342@mail.gmail.com>

I use openSUSE 10.3 with 2.6.24-rc3 and b43+4.80.53.0 firmware.

I noticed that someone created new AP on my channel (6) so I wanted to
change my AP's channel to 13. I made it and after that I was not able
to connect anymore. I was getting

Nov 27 22:12:35 acer kernel: [  501.221868] wlan0_rename: Initial auth_alg=0
Nov 27 22:12:35 acer kernel: [  501.221880] wlan0_rename: authenticate
with AP 00:14:bf:77:9a:c2
Nov 27 22:12:35 acer kernel: [  501.420773] wlan0_rename: authenticate
with AP 00:14:bf:77:9a:c2
Nov 27 22:12:36 acer kernel: [  501.620605] wlan0_rename: authenticate
with AP 00:14:bf:77:9a:c2
Nov 27 22:12:36 acer kernel: [  501.820432] wlan0_rename:
authentication with AP 00:14:bf:77:9a:c2 timed out

every 5 seconds. After changing channel to 1 b43 connected to my AP
again. So it looks for me like problem with connecting to AP working
on high channel. Could someone with 4318 check how it works for your
broadcom?

-- 
Rafa? Mi?ecki

From larry.finger at lwfinger.net  Tue Nov 27 22:50:16 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 27 Nov 2007 15:50:16 -0600
Subject: [BCM4318/02] authentication timed out for channel 13
In-Reply-To: <14b026160711271341v4f3afab3rfc8c18617e4a0342@mail.gmail.com>
References: <14b026160711271341v4f3afab3rfc8c18617e4a0342@mail.gmail.com>
Message-ID: <474C9118.9000207@lwfinger.net>

Rafa? Mi?ecki wrote:
> 
> every 5 seconds. After changing channel to 1 b43 connected to my AP
> again. So it looks for me like problem with connecting to AP working
> on high channel. Could someone with 4318 check how it works for your
> broadcom?

What happens if you use channel 11 rather than 13? The standard regulatory code used by mac80211 is
set for FCC rules - i.e. channels 1-11. If you didn't change that, your driver would not be able to
transmit on channel 13. It seems that it is receiving though.

Larry





From freggy at gmail.com  Wed Nov 28 00:33:45 2007
From: freggy at gmail.com (Frederik)
Date: Wed, 28 Nov 2007 00:33:45 +0100
Subject: [BCM4318/02] authentication timed out for channel 13
In-Reply-To: <474C9118.9000207@lwfinger.net>
References: <14b026160711271341v4f3afab3rfc8c18617e4a0342@mail.gmail.com>
	<474C9118.9000207@lwfinger.net>
Message-ID: <28d495d10711271533s589a755eu6cad3672ba209472@mail.gmail.com>

On Nov 27, 2007 10:50 PM, Larry Finger <larry.finger at lwfinger.net> wrote:
> Rafa? Mi?ecki wrote:
> >
> > every 5 seconds. After changing channel to 1 b43 connected to my AP
> > again. So it looks for me like problem with connecting to AP working
> > on high channel. Could someone with 4318 check how it works for your
> > broadcom?
>
> What happens if you use channel 11 rather than 13? The standard regulatory code used by mac80211 is
> set for FCC rules - i.e. channels 1-11. If you didn't change that, your driver would not be able to
> transmit on channel 13. It seems that it is receiving though.

Well, according to http://en.wikipedia.org/wiki/List_of_WLAN_channels,
channel 13 would be permitted in Europe (where I live). So mac80211
will never permit this, even if it's legal to use?

I am having the same problem connecting to my wireless access point on
channel 13: iwlist scan finds the device, but any attempt to
associate, times out. I'm not sure if this would be a hardware
limitation, or rather something in the firmware or driver preventing
this. I have one machine (Apple Powermac G4), where I cannot associate
to this AP, neither with bcm43xx, neither with b43. I'm not sure if
this would be a hardware limitation, the firmware, or the Linux driver
who is responsible.

On another machine (i386 with a Broadcom based pc card), I succeed in
associating to the access point on channel 13 with bcm43xx, but it
fails with b43.

Well, even in Windows using channel 13 is confusing: with a Windows
machine having an Intel wireless chipset, with the default Windows
utility, it fails to associate, but with the wireless tools from
Intel, it succeeds...

Maybe I should try with another channel soon to verify if that's
really the reason why it does not work.

-- 
Frederik

From larry.finger at lwfinger.net  Wed Nov 28 04:25:17 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 27 Nov 2007 21:25:17 -0600
Subject: [BCM4318/02] authentication timed out for channel 13
In-Reply-To: <28d495d10711271533s589a755eu6cad3672ba209472@mail.gmail.com>
References: <14b026160711271341v4f3afab3rfc8c18617e4a0342@mail.gmail.com>	<474C9118.9000207@lwfinger.net>
	<28d495d10711271533s589a755eu6cad3672ba209472@mail.gmail.com>
Message-ID: <474CDF9D.8080909@lwfinger.net>

Frederik wrote:
> 
> Well, according to http://en.wikipedia.org/wiki/List_of_WLAN_channels,
> channel 13 would be permitted in Europe (where I live). So mac80211
> will never permit this, even if it's legal to use?
> 
> I am having the same problem connecting to my wireless access point on
> channel 13: iwlist scan finds the device, but any attempt to
> associate, times out. I'm not sure if this would be a hardware
> limitation, or rather something in the firmware or driver preventing
> this. I have one machine (Apple Powermac G4), where I cannot associate
> to this AP, neither with bcm43xx, neither with b43. I'm not sure if
> this would be a hardware limitation, the firmware, or the Linux driver
> who is responsible.
> 
> On another machine (i386 with a Broadcom based pc card), I succeed in
> associating to the access point on channel 13 with bcm43xx, but it
> fails with b43.
> 
> Well, even in Windows using channel 13 is confusing: with a Windows
> machine having an Intel wireless chipset, with the default Windows
> utility, it fails to associate, but with the wireless tools from
> Intel, it succeeds...
> 
> Maybe I should try with another channel soon to verify if that's
> really the reason why it does not work.

In SoftMAC, the regulatory domain code defaulted to the Japanese standard and allowed channels 1-14.
As I said earlier, mac80211 defaults to the FCC standard with channels 1-11. If you want to use
channels 12 or 13, you need to load mac80211 with an 'ieee80211_regdom = 64' option to allow the
extra channels.

Larry



From mb at bu3sch.de  Wed Nov 28 15:11:21 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 28 Nov 2007 15:11:21 +0100
Subject: [RFC/T V2] b43: Fix Radio On/Off LED action
In-Reply-To: <474C8A8E.6070404@lwfinger.net>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711272120.44575.mb@bu3sch.de> <474C8A8E.6070404@lwfinger.net>
Message-ID: <200711281511.22788.mb@bu3sch.de>

On Tuesday 27 November 2007 22:22:22 Larry Finger wrote:
> > I'm wondering who causes this deadlock. "registered" should be false if
> > we are called back from rfkill_initialize, so it should return early before
> > the lock.
> 
> The following code has the competing lock:
> 
> static int rfkill_toggle_radio(struct rfkill *rfkill,
>                                 enum rfkill_state state)
> {
>         int retval;
> 
>         retval = mutex_lock_interruptible(&rfkill->mutex);
>         if (retval)
>                 return retval;
> 
>         if (state != rfkill->state) {
>                 retval = rfkill->toggle_radio(rfkill->data, state);
>                 if (!retval) {
>                         rfkill->state = state;
>                         rfkill_led_trigger(rfkill, state);
>                 }
>         }
> 
>         mutex_unlock(&rfkill->mutex);
>         return retval;
> }

So it's a lock dependency between rfkill->mutex and wl->mutex?
So, now comes the question that really matters. Who is the caller
of rfkill_toggle_radio, in the case where it crashes?

-- 
Greetings Michael.


From freggy at gmail.com  Wed Nov 28 15:55:09 2007
From: freggy at gmail.com (Frederik)
Date: Wed, 28 Nov 2007 15:55:09 +0100
Subject: [BCM4318/02] authentication timed out for channel 13
In-Reply-To: <474CDF9D.8080909@lwfinger.net>
References: <14b026160711271341v4f3afab3rfc8c18617e4a0342@mail.gmail.com>
	<474C9118.9000207@lwfinger.net>
	<28d495d10711271533s589a755eu6cad3672ba209472@mail.gmail.com>
	<474CDF9D.8080909@lwfinger.net>
Message-ID: <28d495d10711280655t56f425ayb1c57a11a9817f4f@mail.gmail.com>

On Nov 28, 2007 4:25 AM, Larry Finger <larry.finger at lwfinger.net> wrote:

> In SoftMAC, the regulatory domain code defaulted to the Japanese standard and allowed channels 1-14.
> As I said earlier, mac80211 defaults to the FCC standard with channels 1-11. If you want to use
> channels 12 or 13, you need to load mac80211 with an 'ieee80211_regdom = 64' option to allow the
> extra channels.

Confirmed. Thanks for the hint: I was able to connect to my AP on
channel 13 for the first time ever, using this option and Linux
2.6.24-rc3-git3 and the b43 driver! This is the Broadcom chip used in
my Powerbook G4:

0001:10:12.0 Network controller [0280]: Broadcom Corporation BCM4306
802.11b/g Wireless LAN Controller [14e4:4320] (rev 03)

-- 
Frederik


From larry.finger at lwfinger.net  Wed Nov 28 16:05:35 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 28 Nov 2007 09:05:35 -0600
Subject: [RFC/T V2] b43: Fix Radio On/Off LED action
In-Reply-To: <200711281511.22788.mb@bu3sch.de>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711272120.44575.mb@bu3sch.de> <474C8A8E.6070404@lwfinger.net>
	<200711281511.22788.mb@bu3sch.de>
Message-ID: <474D83BF.7000102@lwfinger.net>

Michael Buesch wrote:
> 
> So it's a lock dependency between rfkill->mutex and wl->mutex?
> So, now comes the question that really matters. Who is the caller
> of rfkill_toggle_radio, in the case where it crashes?
>

Here is the full dump. It looks to me as if b43_rfkill_soft_toggle() calls rfkill_handler(), which
calls rfkill_toggle_radio() and it is calling b43_rfkill_soft_toggle(). I'd call that a loop.

kernel:
kernel: =======================================================
kernel: [ INFO: possible circular locking dependency detected ]
kernel: 2.6.24-rc3-L2.6-g65d438bf-dirty #24
kernel: -------------------------------------------------------
kernel: events/0/9 is trying to acquire lock:
kernel:  (&wl->mutex){--..}, at: [<ffffffff882a31e1>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
kernel:
kernel: but task is already holding lock:
kernel:  (&rfkill->mutex){--..}, at: [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
kernel:
kernel: which lock already depends on the new lock.
kernel:
kernel:
kernel: the existing dependency chain (in reverse order) is:
kernel:
kernel: -> #2 (&rfkill->mutex){--..}:
kernel:        [<ffffffff8025951c>] __lock_acquire+0xb34/0xd47
kernel:        [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
kernel:        [<ffffffff802597b4>] lock_acquire+0x85/0xa9
kernel:        [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
kernel:        [<ffffffff8040e32e>] mutex_lock_interruptible_nested+0x113/0x31e
kernel:        [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
kernel:        [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
kernel:        [<ffffffff8040bd64>] rfkill_register+0x9b/0x107
kernel:        [<ffffffff882a3040>] b43_rfkill_init+0x15e/0x1cb [b43]
kernel:        [<ffffffff88293ad4>] b43_wireless_core_init+0x682/0x784 [b43]
kernel:        [<ffffffff882948a6>] b43_op_start+0x33/0x74 [b43]
kernel:        [<ffffffff881f2a76>] ieee80211_open+0x1c7/0x3dd [mac80211]
kernel:        [<ffffffff803b2fda>] dev_open+0x4e/0x88
kernel:        [<ffffffff803b18a2>] dev_change_flags+0xaf/0x16b
kernel:        [<ffffffff803b9f9d>] do_setlink+0x27a/0x346
kernel:        [<ffffffff8040fa9c>] _read_unlock+0x26/0x2b
kernel:        [<ffffffff803bb233>] rtnl_setlink+0xf9/0x11c
kernel:        [<ffffffff803bb0d3>] rtnetlink_rcv_msg+0x1b6/0x1d5
kernel:        [<ffffffff803baf1d>] rtnetlink_rcv_msg+0x0/0x1d5
kernel:        [<ffffffff803c36a5>] netlink_rcv_skb+0x3e/0xaa
kernel:        [<ffffffff803baf14>] rtnetlink_rcv+0x20/0x29
kernel:        [<ffffffff803c344c>] netlink_unicast+0x1d9/0x23a
kernel:        [<ffffffff803ac19e>] __alloc_skb+0x8a/0x138
kernel:        [<ffffffff803c3c79>] netlink_sendmsg+0x2aa/0x2bd
kernel:        [<ffffffff803a6249>] sock_sendmsg+0xdf/0xf8
kernel:        [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
kernel:        [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
kernel:        [<ffffffff8025970e>] __lock_acquire+0xd26/0xd47
kernel:        [<ffffffff803a6b7f>] move_addr_to_kernel+0x40/0x49
kernel:        [<ffffffff803ad5b9>] verify_iovec+0x4f/0x8e
kernel:        [<ffffffff803a6443>] sys_sendmsg+0x1e1/0x253
kernel:        [<ffffffff80250916>] up_read+0x26/0x2a
kernel:        [<ffffffff8022581f>] do_page_fault+0x3bf/0x764
kernel:        [<ffffffff803a72c4>] sys_getsockname+0x66/0x8c
kernel:        [<ffffffff80258540>] trace_hardirqs_on+0x11c/0x147
kernel:        [<ffffffff8040f5b8>] trace_hardirqs_on_thunk+0x35/0x3a
kernel:        [<ffffffff8020c0de>] system_call+0x7e/0x83
kernel:        [<ffffffffffffffff>] 0xffffffffffffffff
kernel:
kernel: -> #1 (rfkill_mutex){--..}:
kernel:        [<ffffffff8025951c>] __lock_acquire+0xb34/0xd47
kernel:        [<ffffffff8040bd50>] rfkill_register+0x87/0x107
kernel:        [<ffffffff802597b4>] lock_acquire+0x85/0xa9
kernel:        [<ffffffff8040bd50>] rfkill_register+0x87/0x107
kernel:        [<ffffffff8040bd50>] rfkill_register+0x87/0x107
kernel:        [<ffffffff8040e78a>] mutex_lock_nested+0x10e/0x2b6
kernel:        [<ffffffff8040bd50>] rfkill_register+0x87/0x107
kernel:        [<ffffffff882a3040>] b43_rfkill_init+0x15e/0x1cb [b43]
kernel:        [<ffffffff88293ad4>] b43_wireless_core_init+0x682/0x784 [b43]
kernel:        [<ffffffff882948a6>] b43_op_start+0x33/0x74 [b43]
kernel:        [<ffffffff881f2a76>] ieee80211_open+0x1c7/0x3dd [mac80211]
kernel:        [<ffffffff803b2fda>] dev_open+0x4e/0x88
kernel:        [<ffffffff803b18a2>] dev_change_flags+0xaf/0x16b
kernel:        [<ffffffff803b9f9d>] do_setlink+0x27a/0x346
kernel:        [<ffffffff8040fa9c>] _read_unlock+0x26/0x2b
kernel:        [<ffffffff803bb233>] rtnl_setlink+0xf9/0x11c
kernel:        [<ffffffff803bb0d3>] rtnetlink_rcv_msg+0x1b6/0x1d5
kernel:        [<ffffffff803baf1d>] rtnetlink_rcv_msg+0x0/0x1d5
kernel:        [<ffffffff803c36a5>] netlink_rcv_skb+0x3e/0xaa
kernel:        [<ffffffff803baf14>] rtnetlink_rcv+0x20/0x29
kernel:        [<ffffffff803c344c>] netlink_unicast+0x1d9/0x23a
kernel:        [<ffffffff803ac19e>] __alloc_skb+0x8a/0x138
kernel:        [<ffffffff803c3c79>] netlink_sendmsg+0x2aa/0x2bd
kernel:        [<ffffffff803a6249>] sock_sendmsg+0xdf/0xf8
kernel:        [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
kernel:        [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
kernel:        [<ffffffff8025970e>] __lock_acquire+0xd26/0xd47
kernel:        [<ffffffff803a6b7f>] move_addr_to_kernel+0x40/0x49
kernel:        [<ffffffff803ad5b9>] verify_iovec+0x4f/0x8e
kernel:        [<ffffffff803a6443>] sys_sendmsg+0x1e1/0x253
kernel:        [<ffffffff80250916>] up_read+0x26/0x2a
kernel:        [<ffffffff8022581f>] do_page_fault+0x3bf/0x764
kernel:        [<ffffffff803a72c4>] sys_getsockname+0x66/0x8c
kernel:        [<ffffffff80258540>] trace_hardirqs_on+0x11c/0x147
kernel:        [<ffffffff8040f5b8>] trace_hardirqs_on_thunk+0x35/0x3a
kernel:        [<ffffffff8020c0de>] system_call+0x7e/0x83
kernel:        [<ffffffffffffffff>] 0xffffffffffffffff
kernel:
kernel: -> #0 (&wl->mutex){--..}:
kernel:        [<ffffffff80256dd7>] print_circular_bug_entry+0x48/0x4f
kernel:        [<ffffffff8025941e>] __lock_acquire+0xa36/0xd47
kernel:        [<ffffffff882a31e1>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
kernel:        [<ffffffff802597b4>] lock_acquire+0x85/0xa9
kernel:        [<ffffffff882a31e1>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
kernel:        [<ffffffff882a31e1>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
kernel:        [<ffffffff8040e78a>] mutex_lock_nested+0x10e/0x2b6
kernel:        [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
kernel:        [<ffffffff8040bf6f>] rfkill_task_handler+0x0/0x54
kernel:        [<ffffffff882a31e1>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
kernel:        [<ffffffff8040b944>] rfkill_toggle_radio+0x3c/0x7d
kernel:        [<ffffffff8040be96>] rfkill_switch_all+0x3e/0x78
kernel:        [<ffffffff8040bfab>] rfkill_task_handler+0x3c/0x54
kernel:        [<ffffffff80249914>] run_workqueue+0xeb/0x200
kernel:        [<ffffffff8024a500>] worker_thread+0xed/0xfe
kernel:        [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
kernel:        [<ffffffff8024a413>] worker_thread+0x0/0xfe
kernel:        [<ffffffff8024da6e>] kthread+0x49/0x77
kernel:        [<ffffffff8020d018>] child_rip+0xa/0x12
kernel:        [<ffffffff8020c72f>] restore_args+0x0/0x30
kernel:        [<ffffffff8024da25>] kthread+0x0/0x77
kernel:        [<ffffffff8020d00e>] child_rip+0x0/0x12
kernel:        [<ffffffffffffffff>] 0xffffffffffffffff
kernel:
kernel: other info that might help us debug this:
kernel:
kernel: 5 locks held by events/0/9:
kernel:  #0:  (events){--..}, at: [<ffffffff802498c9>] run_workqueue+0xa0/0x200
kernel:  #1:  (rfkill_wlan.work){--..}, at: [<ffffffff802498c9>] run_workqueue+0xa0/0x200
kernel:  #2:  (rfkill_wlan.mutex){--..}, at: [<ffffffff8040bf8d>] rfkill_task_handler+0x1e/0x54
kernel:  #3:  (rfkill_mutex){--..}, at: [<ffffffff8040be74>] rfkill_switch_all+0x1c/0x78
kernel:  #4:  (&rfkill->mutex){--..}, at: [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
kernel:
kernel: stack backtrace:
kernel:
kernel: Call Trace:
kernel:  [<ffffffff8025779c>] print_circular_bug_tail+0x70/0x7b
kernel:  [<ffffffff80256dd7>] print_circular_bug_entry+0x48/0x4f
kernel:  [<ffffffff8025941e>] __lock_acquire+0xa36/0xd47
kernel:  [<ffffffff882a31e1>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
kernel:  [<ffffffff802597b4>] lock_acquire+0x85/0xa9
kernel:  [<ffffffff882a31e1>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
kernel:  [<ffffffff882a31e1>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
kernel:  [<ffffffff8040e78a>] mutex_lock_nested+0x10e/0x2b6
kernel:  [<ffffffff8040b927>] rfkill_toggle_radio+0x1f/0x7d
kernel:  [<ffffffff8040bf6f>] rfkill_task_handler+0x0/0x54
kernel:  [<ffffffff882a31e1>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
kernel:  [<ffffffff8040b944>] rfkill_toggle_radio+0x3c/0x7d
kernel:  [<ffffffff8040be96>] rfkill_switch_all+0x3e/0x78
kernel:  [<ffffffff8040bfab>] rfkill_task_handler+0x3c/0x54
kernel:  [<ffffffff80249914>] run_workqueue+0xeb/0x200
kernel:  [<ffffffff8024a500>] worker_thread+0xed/0xfe
kernel:  [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
kernel:  [<ffffffff8024a413>] worker_thread+0x0/0xfe
kernel:  [<ffffffff8024da6e>] kthread+0x49/0x77
kernel:  [<ffffffff8020d018>] child_rip+0xa/0x12
kernel:  [<ffffffff8020c72f>] restore_args+0x0/0x30
kernel:  [<ffffffff8024da25>] kthread+0x0/0x77
kernel:  [<ffffffff8020d00e>] child_rip+0x0/0x12



From Larry.Finger at lwfinger.net  Wed Nov 28 16:38:27 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 28 Nov 2007 09:38:27 -0600
Subject: [PATCH] b43: Simple 'fix' for radio switch LED regression
Message-ID: <474d8b73.cCPCkkSQe1GIVt4H%Larry.Finger@lwfinger.net>

Since addition of the rfkill callback, the LED associated with the off/on
switch on the radio has not worked because essential data in the rfkill
structure is missing. When that problem was fixed, difficulties in circular
locking surfaced. This patch fixes part of the regression in that the LED
is turned on if the radio switch is on at startup. Adding the code to toggle
the LED with the switch will be more involved and would likely miss the 2.6.24
window.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John and Michael,

I was able to get the full functionality working, but with two significant
problems: (1) the LED toggled only with a switch off-on sequence, not with
each switch change and (2) the module would no longer unload cleanly due to
circular locking. I will be essentually off-line after today, and I hope that
this hack, which will make the LED appear to work correctly, can be pushed
into 2.6.24 as it is a fix, but has minimal code impact. Nearly all of the
changes are needed just to make the LED on routine available to startup.
Furthermore, I'm certain these changes will be needed when the complete fix
is available.

Larry
---

 leds.c |    3 +--
 leds.h |    1 +
 main.c |    3 +++
 3 files changed, 5 insertions(+), 2 deletions(-)

Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -51,6 +51,7 @@
 #include "xmit.h"
 #include "lo.h"
 #include "pcmcia.h"
+#include "leds.h"
 
 MODULE_DESCRIPTION("Broadcom B43 wireless driver");
 MODULE_AUTHOR("Martin Langer");
@@ -2799,6 +2797,8 @@ static int b43_op_config(struct ieee8021
 	b43_interrupt_enable(dev, savedirqs);
 	mmiowb();
 	spin_unlock_irqrestore(&wl->irq_lock, flags);
+	if (dev->radio_hw_enable)
+		b43_led_turn_on(dev, 1, 1);
       out_unlock_mutex:
 	mutex_unlock(&wl->mutex);
 
Index: wireless-2.6/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.c
+++ wireless-2.6/drivers/net/wireless/b43/leds.c
@@ -30,8 +30,7 @@
 #include "leds.h"
 
 
-static void b43_led_turn_on(struct b43_wldev *dev, u8 led_index,
-			    bool activelow)
+void b43_led_turn_on(struct b43_wldev *dev, u8 led_index, bool activelow)
 {
 	struct b43_wl *wl = dev->wl;
 	unsigned long flags;
Index: wireless-2.6/drivers/net/wireless/b43/leds.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.h
+++ wireless-2.6/drivers/net/wireless/b43/leds.h
@@ -44,6 +44,7 @@ enum b43_led_behaviour {
 
 void b43_leds_init(struct b43_wldev *dev);
 void b43_leds_exit(struct b43_wldev *dev);
+void b43_led_turn_on(struct b43_wldev *dev, u8 led_index, bool activelow);
 
 
 #else /* CONFIG_B43_LEDS */


From mb at bu3sch.de  Wed Nov 28 16:52:05 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 28 Nov 2007 16:52:05 +0100
Subject: [PATCH] b43: Simple 'fix' for radio switch LED regression
In-Reply-To: <474d8b73.cCPCkkSQe1GIVt4H%Larry.Finger@lwfinger.net>
References: <474d8b73.cCPCkkSQe1GIVt4H%Larry.Finger@lwfinger.net>
Message-ID: <200711281652.05627.mb@bu3sch.de>

On Wednesday 28 November 2007 16:38:27 Larry Finger wrote:
> Since addition of the rfkill callback, the LED associated with the off/on
> switch on the radio has not worked because essential data in the rfkill
> structure is missing. When that problem was fixed, difficulties in circular
> locking surfaced. This patch fixes part of the regression in that the LED
> is turned on if the radio switch is on at startup. Adding the code to toggle
> the LED with the switch will be more involved and would likely miss the 2.6.24
> window.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John and Michael,
> 
> I was able to get the full functionality working, but with two significant
> problems: (1) the LED toggled only with a switch off-on sequence, not with
> each switch change and (2) the module would no longer unload cleanly due to
> circular locking. I will be essentually off-line after today, and I hope that
> this hack, which will make the LED appear to work correctly, can be pushed
> into 2.6.24 as it is a fix, but has minimal code impact. Nearly all of the
> changes are needed just to make the LED on routine available to startup.
> Furthermore, I'm certain these changes will be needed when the complete fix
> is available.

That completely shortcuts the "behaviour" logic.
This patch trades one bug for another.
It will get other people upset, because their LEDs don't work as expected anymore.

This is not a showstopper bug and there is no need to introduce dirty
fixes that trade one bug for another.
I'm pretty sure that this patch will break LEDs on my asus card. I didn't
try that, though.

Please don't apply this. We have enough time to develop the correct solution
to this problem.

>  leds.c |    3 +--
>  leds.h |    1 +
>  main.c |    3 +++
>  3 files changed, 5 insertions(+), 2 deletions(-)
> 
> Index: wireless-2.6/drivers/net/wireless/b43/main.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/main.c
> +++ wireless-2.6/drivers/net/wireless/b43/main.c
> @@ -51,6 +51,7 @@
>  #include "xmit.h"
>  #include "lo.h"
>  #include "pcmcia.h"
> +#include "leds.h"
>  
>  MODULE_DESCRIPTION("Broadcom B43 wireless driver");
>  MODULE_AUTHOR("Martin Langer");
> @@ -2799,6 +2797,8 @@ static int b43_op_config(struct ieee8021
>  	b43_interrupt_enable(dev, savedirqs);
>  	mmiowb();
>  	spin_unlock_irqrestore(&wl->irq_lock, flags);
> +	if (dev->radio_hw_enable)
> +		b43_led_turn_on(dev, 1, 1);
>        out_unlock_mutex:
>  	mutex_unlock(&wl->mutex);
>  
> Index: wireless-2.6/drivers/net/wireless/b43/leds.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/leds.c
> +++ wireless-2.6/drivers/net/wireless/b43/leds.c
> @@ -30,8 +30,7 @@
>  #include "leds.h"
>  
>  
> -static void b43_led_turn_on(struct b43_wldev *dev, u8 led_index,
> -			    bool activelow)
> +void b43_led_turn_on(struct b43_wldev *dev, u8 led_index, bool activelow)
>  {
>  	struct b43_wl *wl = dev->wl;
>  	unsigned long flags;
> Index: wireless-2.6/drivers/net/wireless/b43/leds.h
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/leds.h
> +++ wireless-2.6/drivers/net/wireless/b43/leds.h
> @@ -44,6 +44,7 @@ enum b43_led_behaviour {
>  
>  void b43_leds_init(struct b43_wldev *dev);
>  void b43_leds_exit(struct b43_wldev *dev);
> +void b43_led_turn_on(struct b43_wldev *dev, u8 led_index, bool activelow);
>  
>  
>  #else /* CONFIG_B43_LEDS */
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
> 
> 



-- 
Greetings Michael.


From mb at bu3sch.de  Wed Nov 28 17:13:02 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 28 Nov 2007 17:13:02 +0100
Subject: [RFC/T V2] b43: Fix Radio On/Off LED action
In-Reply-To: <474D83BF.7000102@lwfinger.net>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711281511.22788.mb@bu3sch.de> <474D83BF.7000102@lwfinger.net>
Message-ID: <200711281713.02919.mb@bu3sch.de>

On Wednesday 28 November 2007 16:05:35 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > So it's a lock dependency between rfkill->mutex and wl->mutex?
> > So, now comes the question that really matters. Who is the caller
> > of rfkill_toggle_radio, in the case where it crashes?
> >
> 
> Here is the full dump. It looks to me as if b43_rfkill_soft_toggle() calls rfkill_handler(), which
> calls rfkill_toggle_radio() and it is calling b43_rfkill_soft_toggle(). I'd call that a loop.

I think it's a different bug. The backtrace seems corrupted.

Can you try this patch? There is some circular locking in rfkill.

Index: wireless-2.6/net/rfkill/rfkill.c
===================================================================
--- wireless-2.6.orig/net/rfkill/rfkill.c	2007-11-20 19:09:35.000000000 +0100
+++ wireless-2.6/net/rfkill/rfkill.c	2007-11-28 17:09:55.000000000 +0100
@@ -60,11 +60,7 @@ static void rfkill_led_trigger(struct rf
 static int rfkill_toggle_radio(struct rfkill *rfkill,
 				enum rfkill_state state)
 {
-	int retval;
-
-	retval = mutex_lock_interruptible(&rfkill->mutex);
-	if (retval)
-		return retval;
+	int retval = 0;
 
 	if (state != rfkill->state) {
 		retval = rfkill->toggle_radio(rfkill->data, state);
@@ -74,7 +70,6 @@ static int rfkill_toggle_radio(struct rf
 		}
 	}
 
-	mutex_unlock(&rfkill->mutex);
 	return retval;
 }
 
@@ -158,12 +153,13 @@ static ssize_t rfkill_state_store(struct
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
+	if (mutex_lock_interruptible(&rfkill->mutex))
+		return -ERESTARTSYS;
 	error = rfkill_toggle_radio(rfkill,
 			state ? RFKILL_STATE_ON : RFKILL_STATE_OFF);
-	if (error)
-		return error;
+	mutex_unlock(&rfkill->mutex);
 
-	return count;
+	return error ? error : count;
 }
 
 static ssize_t rfkill_claim_show(struct device *dev,

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Wed Nov 28 17:18:53 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 28 Nov 2007 10:18:53 -0600
Subject: [PATCH] b43: Simple 'fix' for radio switch LED regression
In-Reply-To: <200711281652.05627.mb@bu3sch.de>
References: <474d8b73.cCPCkkSQe1GIVt4H%Larry.Finger@lwfinger.net>
	<200711281652.05627.mb@bu3sch.de>
Message-ID: <474D94ED.6050403@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 28 November 2007 16:38:27 Larry Finger wrote:
>> Since addition of the rfkill callback, the LED associated with the off/on
>> switch on the radio has not worked because essential data in the rfkill
>> structure is missing. When that problem was fixed, difficulties in circular
>> locking surfaced. This patch fixes part of the regression in that the LED
>> is turned on if the radio switch is on at startup. Adding the code to toggle
>> the LED with the switch will be more involved and would likely miss the 2.6.24
>> window.
>>
>> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
>> ---
>>
>> John and Michael,
>>
>> I was able to get the full functionality working, but with two significant
>> problems: (1) the LED toggled only with a switch off-on sequence, not with
>> each switch change and (2) the module would no longer unload cleanly due to
>> circular locking. I will be essentually off-line after today, and I hope that
>> this hack, which will make the LED appear to work correctly, can be pushed
>> into 2.6.24 as it is a fix, but has minimal code impact. Nearly all of the
>> changes are needed just to make the LED on routine available to startup.
>> Furthermore, I'm certain these changes will be needed when the complete fix
>> is available.
> 
> That completely shortcuts the "behaviour" logic.
> This patch trades one bug for another.
> It will get other people upset, because their LEDs don't work as expected anymore.
> 
> This is not a showstopper bug and there is no need to introduce dirty
> fixes that trade one bug for another.
> I'm pretty sure that this patch will break LEDs on my asus card. I didn't
> try that, though.

Please try the patch at least enough to see if it breaks the LEDs on your card. I don't think it
will. The reason that part was needed in the more complete code is that there is no key event to
turn the rfkill LED on otherwise.

I agree that this is not a showstopper, but it is annoying. It is, however, your call.

Larry


From mb at bu3sch.de  Wed Nov 28 17:29:04 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 28 Nov 2007 17:29:04 +0100
Subject: [PATCH] b43: Simple 'fix' for radio switch LED regression
In-Reply-To: <474D94ED.6050403@lwfinger.net>
References: <474d8b73.cCPCkkSQe1GIVt4H%Larry.Finger@lwfinger.net>
	<200711281652.05627.mb@bu3sch.de> <474D94ED.6050403@lwfinger.net>
Message-ID: <200711281729.04505.mb@bu3sch.de>

On Wednesday 28 November 2007 17:18:53 Larry Finger wrote:
> Michael Buesch wrote:
> > On Wednesday 28 November 2007 16:38:27 Larry Finger wrote:
> >> Since addition of the rfkill callback, the LED associated with the off/on
> >> switch on the radio has not worked because essential data in the rfkill
> >> structure is missing. When that problem was fixed, difficulties in circular
> >> locking surfaced. This patch fixes part of the regression in that the LED
> >> is turned on if the radio switch is on at startup. Adding the code to toggle
> >> the LED with the switch will be more involved and would likely miss the 2.6.24
> >> window.
> >>
> >> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> >> ---
> >>
> >> John and Michael,
> >>
> >> I was able to get the full functionality working, but with two significant
> >> problems: (1) the LED toggled only with a switch off-on sequence, not with
> >> each switch change and (2) the module would no longer unload cleanly due to
> >> circular locking. I will be essentually off-line after today, and I hope that
> >> this hack, which will make the LED appear to work correctly, can be pushed
> >> into 2.6.24 as it is a fix, but has minimal code impact. Nearly all of the
> >> changes are needed just to make the LED on routine available to startup.
> >> Furthermore, I'm certain these changes will be needed when the complete fix
> >> is available.
> > 
> > That completely shortcuts the "behaviour" logic.
> > This patch trades one bug for another.
> > It will get other people upset, because their LEDs don't work as expected anymore.
> > 
> > This is not a showstopper bug and there is no need to introduce dirty
> > fixes that trade one bug for another.
> > I'm pretty sure that this patch will break LEDs on my asus card. I didn't
> > try that, though.
> 
> Please try the patch at least enough to see if it breaks the LEDs on your card. I don't think it
> will.

There's no need to try this.
Let's summerize what we have and what your patch does:

We have a _nonconstant_ mapping of LEDs to LED behaviours. This mapping
is done in the SPROM or in a special function which takes card types
and revisions and assigns the behaviour to the LED.
So the rfkill LED could be _any_ LED in the LED iospace.

What your patch does now is to hardcode the LED to LED index 1 with
an activelow capability. Why LED 1? Why activelow? Because this is the
case in your particular type of b43 card.

My asus card has two LEDs. One has a "link is up, aka associated" and a
"transmitting data" LED. I don't know from the top of my head which
indices those LEDs are, but let's simply assume they are index 0 and 1.
(Remember this mapping is random and specific to the hardware).

So what we do is poke with some random LED.
Also, I'm pretty sure that these LEDs on my card are activehigh. So
if your patch is applied to such a card it will and up with a "nonworking"
LED. That's what we wanted to fix in the first place, right? ;)

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Wed Nov 28 17:41:42 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 28 Nov 2007 10:41:42 -0600
Subject: [RFC/T V2] b43: Fix Radio On/Off LED action
In-Reply-To: <200711281713.02919.mb@bu3sch.de>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711281511.22788.mb@bu3sch.de> <474D83BF.7000102@lwfinger.net>
	<200711281713.02919.mb@bu3sch.de>
Message-ID: <474D9A46.1020300@lwfinger.net>

Michael Buesch wrote:
> 
> I think it's a different bug. The backtrace seems corrupted.
> 
> Can you try this patch? There is some circular locking in rfkill.

I still get circular locking. The dump is

b43-phy0: Radio hardware status changed to DISABLED
b43-phy0: Radio hardware status changed to ENABLED

=======================================================
[ INFO: possible circular locking dependency detected ]
2.6.24-rc3-L2.6-g65d438bf-dirty #25
-------------------------------------------------------
events/0/9 is trying to acquire lock:
 (&wl->mutex){--..}, at: [<ffffffff882081d9>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]

but task is already holding lock:
 (rfkill_mutex){--..}, at: [<ffffffff8040be7c>] rfkill_switch_all+0x1c/0x78

which lock already depends on the new lock.


the existing dependency chain (in reverse order) is:

-> #1 (rfkill_mutex){--..}:
       [<ffffffff8025951c>] __lock_acquire+0xb34/0xd47
       [<ffffffff8040bd58>] rfkill_register+0x87/0x107
       [<ffffffff802597b4>] lock_acquire+0x85/0xa9
       [<ffffffff8040bd58>] rfkill_register+0x87/0x107
       [<ffffffff8040bd58>] rfkill_register+0x87/0x107
       [<ffffffff8040e78a>] mutex_lock_nested+0x10e/0x2b6
       [<ffffffff8040bd58>] rfkill_register+0x87/0x107
       [<ffffffff88208043>] b43_rfkill_init+0x141/0x1a3 [b43]
       [<ffffffff881f8ac4>] b43_wireless_core_init+0x682/0x78c [b43]
       [<ffffffff881f989e>] b43_op_start+0x33/0x74 [b43]
       [<ffffffff881c7a76>] ieee80211_open+0x1c7/0x3dd [mac80211]
       [<ffffffff803b2fda>] dev_open+0x4e/0x88
       [<ffffffff803b18a2>] dev_change_flags+0xaf/0x16b
       [<ffffffff803b9f9d>] do_setlink+0x27a/0x346
       [<ffffffff8040fa9c>] _read_unlock+0x26/0x2b
       [<ffffffff803bb233>] rtnl_setlink+0xf9/0x11c
       [<ffffffff803bb0d3>] rtnetlink_rcv_msg+0x1b6/0x1d5
       [<ffffffff803baf1d>] rtnetlink_rcv_msg+0x0/0x1d5
       [<ffffffff803c36a5>] netlink_rcv_skb+0x3e/0xaa
       [<ffffffff803baf14>] rtnetlink_rcv+0x20/0x29
       [<ffffffff803c344c>] netlink_unicast+0x1d9/0x23a
       [<ffffffff803ac19e>] __alloc_skb+0x8a/0x138
       [<ffffffff803c3c79>] netlink_sendmsg+0x2aa/0x2bd
       [<ffffffff803a6249>] sock_sendmsg+0xdf/0xf8
       [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
       [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
       [<ffffffff8025970e>] __lock_acquire+0xd26/0xd47
       [<ffffffff803a6b7f>] move_addr_to_kernel+0x40/0x49
       [<ffffffff803ad5b9>] verify_iovec+0x4f/0x8e
       [<ffffffff803a6443>] sys_sendmsg+0x1e1/0x253
       [<ffffffff80250916>] up_read+0x26/0x2a
       [<ffffffff8022581f>] do_page_fault+0x3bf/0x764
       [<ffffffff803a72c4>] sys_getsockname+0x66/0x8c
       [<ffffffff80258540>] trace_hardirqs_on+0x11c/0x147
       [<ffffffff8040f5b8>] trace_hardirqs_on_thunk+0x35/0x3a
       [<ffffffff8020c0de>] system_call+0x7e/0x83
       [<ffffffffffffffff>] 0xffffffffffffffff

-> #0 (&wl->mutex){--..}:
       [<ffffffff8025941e>] __lock_acquire+0xa36/0xd47
       [<ffffffff882081d9>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
       [<ffffffff802597b4>] lock_acquire+0x85/0xa9
       [<ffffffff882081d9>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
       [<ffffffff882081d9>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
       [<ffffffff8040e78a>] mutex_lock_nested+0x10e/0x2b6
       [<ffffffff80255dd2>] debug_mutex_free_waiter+0x5b/0x5f
       [<ffffffff8040bf77>] rfkill_task_handler+0x0/0x54
       [<ffffffff882081d9>] b43_rfkill_soft_toggle+0x33/0xb2 [b43]
       [<ffffffff8040b930>] rfkill_toggle_radio+0x28/0x60
       [<ffffffff8040be9e>] rfkill_switch_all+0x3e/0x78
       [<ffffffff8040bfb3>] rfkill_task_handler+0x3c/0x54
       [<ffffffff80249914>] run_workqueue+0xeb/0x200
       [<ffffffff8024a500>] worker_thread+0xed/0xfe
       [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
       [<ffffffff8024a413>] worker_thread+0x0/0xfe
       [<ffffffff8024da6e>] kthread+0x49/0x77
       [<ffffffff8020d018>] child_rip+0xa/0x12
       [<ffffffff8020c72f>] restore_args+0x0/0x30
       [<ffffffff8024da25>] kthread+0x0/0x77
       [<ffffffff8020d00e>] child_rip+0x0/0x12
       [<ffffffffffffffff>] 0xffffffffffffffff

other info that might help us debug this:

4 locks held by events/0/9:
 #0:  (events){--..}, at: [<ffffffff802498c9>] run_workqueue+0xa0/0x200
 #1:  (rfkill_wlan.work){--..}, at: [<ffffffff802498c9>] run_workqueue+0xa0/0x200
 #2:  (rfkill_wlan.mutex){--..}, at: [<ffffffff8040bf95>] rfkill_task_handler+0x1e/0x54
 #3:  (rfkill_mutex){--..}, at: [<ffffffff8040be7c>] rfkill_switch_all+0x1c/0x78

stack backtrace:

Call Trace:
 [<ffffffff8025779c>] print_circular_bug_tail+0x70/0x7b
 [<ffffffff8025941e>] __lock_acquire+0xa36/0xd47
 [<ffffffff882081d9>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
 [<ffffffff802597b4>] lock_acquire+0x85/0xa9
 [<ffffffff882081d9>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
 [<ffffffff882081d9>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
 [<ffffffff8040e78a>] mutex_lock_nested+0x10e/0x2b6
 [<ffffffff80255dd2>] debug_mutex_free_waiter+0x5b/0x5f
 [<ffffffff8040bf77>] rfkill_task_handler+0x0/0x54
 [<ffffffff882081d9>] :b43:b43_rfkill_soft_toggle+0x33/0xb2
 [<ffffffff8040b930>] rfkill_toggle_radio+0x28/0x60
 [<ffffffff8040be9e>] rfkill_switch_all+0x3e/0x78
 [<ffffffff8040bfb3>] rfkill_task_handler+0x3c/0x54
 [<ffffffff80249914>] run_workqueue+0xeb/0x200
 [<ffffffff8024a500>] worker_thread+0xed/0xfe
 [<ffffffff8024db89>] autoremove_wake_function+0x0/0x38
 [<ffffffff8024a413>] worker_thread+0x0/0xfe
 [<ffffffff8024da6e>] kthread+0x49/0x77
 [<ffffffff8020d018>] child_rip+0xa/0x12
 [<ffffffff8020c72f>] restore_args+0x0/0x30
 [<ffffffff8024da25>] kthread+0x0/0x77
 [<ffffffff8020d00e>] child_rip+0x0/0x12

b43-phy0: Radio hardware status changed to DISABLED


From mb at bu3sch.de  Wed Nov 28 17:46:55 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 28 Nov 2007 17:46:55 +0100
Subject: [RFC/T V2] b43: Fix Radio On/Off LED action
In-Reply-To: <474D9A46.1020300@lwfinger.net>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711281713.02919.mb@bu3sch.de> <474D9A46.1020300@lwfinger.net>
Message-ID: <200711281746.56069.mb@bu3sch.de>

On Wednesday 28 November 2007 17:41:42 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > I think it's a different bug. The backtrace seems corrupted.
> > 
> > Can you try this patch? There is some circular locking in rfkill.
> 
> I still get circular locking. The dump is

Ok.

b43 init:
	mutex_lock(wl->mutex)
	rfkill_init()
		mutex_lock(rfkill->mutex)

in operation:
	rfkill poll (no locks held)
	calls into rfkill
	mutex_lock(rfkill->mutex)
	b43_rfkill_soft_toggle()
		mutex_lock(wl->mutex)

As you can see the lock ordering of the two mutexes
is different. The problem is that we cannot easily drop
the wl->mutex on b43 init, as that would introduce some
race conditions. This is specific to b43 and rt2x00 most
likely doesn't have this requirement.
I'm not sure how to properly fix this.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Wed Nov 28 18:08:17 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 28 Nov 2007 11:08:17 -0600
Subject: [RFC/T V2] b43: Fix Radio On/Off LED action
In-Reply-To: <200711281746.56069.mb@bu3sch.de>
References: <474c3fed.AWsUCELaFNf32i8C%Larry.Finger@lwfinger.net>
	<200711281713.02919.mb@bu3sch.de> <474D9A46.1020300@lwfinger.net>
	<200711281746.56069.mb@bu3sch.de>
Message-ID: <474DA081.7030101@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 28 November 2007 17:41:42 Larry Finger wrote:
>> Michael Buesch wrote:
>>> I think it's a different bug. The backtrace seems corrupted.
>>>
>>> Can you try this patch? There is some circular locking in rfkill.
>> I still get circular locking. The dump is
> 
> Ok.
> 
> b43 init:
> 	mutex_lock(wl->mutex)
> 	rfkill_init()
> 		mutex_lock(rfkill->mutex)
> 
> in operation:
> 	rfkill poll (no locks held)
> 	calls into rfkill
> 	mutex_lock(rfkill->mutex)
> 	b43_rfkill_soft_toggle()
> 		mutex_lock(wl->mutex)
> 
> As you can see the lock ordering of the two mutexes
> is different. The problem is that we cannot easily drop
> the wl->mutex on b43 init, as that would introduce some
> race conditions. This is specific to b43 and rt2x00 most
> likely doesn't have this requirement.
> I'm not sure how to properly fix this.

Your analysis is correct. I wrapped the call to b43_rfkill_init() with an unlock/lock pair of calls
(races be damned) and the circular locking message went away. BTW, that kind of wrapping is already
done for b43_rfkill_exit(). Curious.

Larry


From Larry.Finger at lwfinger.net  Wed Nov 28 19:29:11 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 28 Nov 2007 12:29:11 -0600
Subject: SSB SPROM rev 3 code
In-Reply-To: <200711281738.04988.ssnt2@eng.cam.ac.uk>
References: <200711281738.04988.ssnt2@eng.cam.ac.uk>
Message-ID: <474DB377.70907@lwfinger.net>

Shawn Tan wrote:
> Hi Larry, 
> 
> I found on the list archives that you were interested in SSB SPROM rev 3 
> codes.
> 
0138000071133C100800BE1D0087C42B642A6429642CE73CFF257FC7FFFFFF
FF12430080020000000010001800000000FFFFFFFFFFFFFFFF00003C3CDF1A6FFC45FF3A1A89FC4
1FF00001A005F73A8A1FFFFFFFFFFFFFFFF0000FFFF75F0CF14BEFA7EFEFF83FFFF4A3C6F1C4DFC5
CFF3E78494A020245440C000000FFFF035D
> 
> I'm unable to get B43 or B43LEGACY to work on my laptop. Hope the information 
> helps.
> 
> lspci -vvn:
> 
> 30:00.0 0280: 14e4:4312 (rev 02)

You have a BCM4312 rev02. To get it to work with b43, you need to do the following:

(1) Get 2.6.24-rcX source code from http://www.eu.kernel.org/pub/linux/kernel/v2.6/.

(2) Get the patch file from http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2.

(3) Expand the kernel source, apply the patch, and build a new kernel.

(4) Follow the firmware installation directions at http://linuxwireless.org/en/users/Drivers/b43.

When all these steps have been completed, your BCM4312 should work correctly, except for the LED
associated with the radio on/off switch. We are working on that problem.

If kernel building is beyond your skill level, you will need to wait for your distro to use a 2.6.25
kernel. In that case, only step 4 will need to be done.

Thanks for the SPROM data.

Larry



From ftoledo at docksud.com.ar  Thu Nov 29 00:11:19 2007
From: ftoledo at docksud.com.ar (Fernando Toledo)
Date: Wed, 28 Nov 2007 20:11:19 -0300
Subject: assertions on try connect
Message-ID: <200711282011.19477.ftoledo@docksud.com.ar>

this messages are when i try to connect to the ap,
the log say associted, but i cant get ip:

bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
bcm43xx: Radio turned on
bcm43xx: Radio disabled by hardware
bcm43xx: Chip initialized
bcm43xx: 32-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)
bcm43xx: Radio hardware status changed to enabled
SoftMAC: Associate: Scanning for networks first.
SoftMAC: Scanning finished: scanned 13 channels starting with channel 1
SoftMAC: Queueing Authentication Request to 00:0e:2e:64:77:fd
SoftMAC: Cannot associate without being authenticated, requested 
authentication
SoftMAC: Sent Authentication Request to 00:0e:2e:64:77:fd.
SoftMAC: Open Authentication completed with 00:0e:2e:64:77:fd
SoftMAC: sent association request!
SoftMAC: associated!
SoftMAC: Scanning finished: scanned 13 channels starting with channel 1
SoftMAC: Getting essid from req_essid
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
bcm43xx: ASSERTION FAILED (!ring->suspended) at: 
drivers/net/wireless/bcm43xx/bc                    
m43xx_dma.c:71:request_slot()
SoftMAC: Scanning finished: scanned 13 channels starting with channel 1

-- 
Dock Sud BBS
http://www.docksud.com.ar
telnet://bbs.docksud.com.ar


From Larry.Finger at lwfinger.net  Thu Nov 29 00:48:40 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 28 Nov 2007 17:48:40 -0600
Subject: [PATCH] b43: Fix radio LED problem
Message-ID: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>

Since addition of the rfkill callback, the LED associated with the off
switch on the radio has not worked for several reasons:

(1) Essential data in the rfkill structure were missing.
(2) The rfkill structure was initialized after the LED initialization.
(3) There was a minor memory leak if the radio LED structure was inited.

Once the above problems were fixed, additional difficulties were noted:

(4) The radio LED was in the wrong state at startup.
(5) The radio switch had to be manipulated twice for each state change.
(6) A circular mutex locking situation existed.

This patch fixes all of the above.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John and Michael,

These changes are mostly obvious. The most complicated is the fixing of the
circular locking between the rfkill and wl_dev mutexes. This was acomplished
by moving the rfkill_init() call to the beginning of b43_op_start() and the
rfkill_exit() call to the end of b43_op_stop().

Techically, these changes are fixes for the radio LED regression between
bcm43xx and b43. It doesn't matter to me if they are pushed into 2.6.24, or
left for 2.6.25.

Larry
---

 leds.c   |    1 +
 main.c   |   25 +++++++++++++++----------
 rfkill.c |   14 ++++++++++++--
 3 files changed, 28 insertions(+), 12 deletions(-)


Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
@@ -60,8 +60,12 @@ static void b43_rfkill_poll(struct input
 	}
 	mutex_unlock(&wl->mutex);
 
-	if (unlikely(report_change))
-		input_report_key(poll_dev->input, KEY_WLAN, enabled);
+	/* send the radio switch event to the system - note both a key press
+	 * and a release are required */
+	if (unlikely(report_change)) {
+		input_report_key(poll_dev->input, KEY_WLAN, 1);
+		input_report_key(poll_dev->input, KEY_WLAN, 0);
+	}
 }
 
 /* Called when the RFKILL toggled in software. */
@@ -133,6 +137,12 @@ void b43_rfkill_init(struct b43_wldev *d
 	rfk->poll_dev->poll = b43_rfkill_poll;
 	rfk->poll_dev->poll_interval = 1000; /* msecs */
 
+	rfk->poll_dev->input->name = rfk->name;
+	rfk->poll_dev->input->id.bustype = BUS_HOST;
+	rfk->poll_dev->input->id.vendor = dev->dev->bus->boardinfo.vendor;
+	rfk->poll_dev->input->evbit[0] = BIT(EV_KEY);
+	set_bit(KEY_WLAN, rfk->poll_dev->input->keybit);
+
 	err = rfkill_register(rfk->rfkill);
 	if (err)
 		goto err_free_polldev;
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -2156,7 +2156,6 @@ static void b43_mgmtframe_txantenna(stru
 static void b43_chip_exit(struct b43_wldev *dev)
 {
 	b43_radio_turn_off(dev, 1);
-	b43_leds_exit(dev);
 	b43_gpio_cleanup(dev);
 	/* firmware is released later */
 }
@@ -2184,11 +2183,10 @@ static int b43_chip_init(struct b43_wlde
 	err = b43_gpio_init(dev);
 	if (err)
 		goto out;	/* firmware is released later */
-	b43_leds_init(dev);
 
 	err = b43_upload_initvals(dev);
 	if (err)
-		goto err_leds_exit;
+		goto err_gpio_clean;
 	b43_radio_turn_on(dev);
 
 	b43_write16(dev, 0x03E6, 0x0000);
@@ -2267,8 +2265,7 @@ out:
 
 err_radio_off:
 	b43_radio_turn_off(dev, 1);
-err_leds_exit:
-	b43_leds_exit(dev);
+err_gpio_clean:
 	b43_gpio_cleanup(dev);
 	return err;
 }
@@ -2703,7 +2700,8 @@ static int b43_antenna_from_ieee80211(u8
 static int b43_op_config(struct ieee80211_hw *hw, struct ieee80211_conf *conf)
 {
 	struct b43_wl *wl = hw_to_b43_wl(hw);
-	struct b43_wldev *dev;
+	struct b43_rfkill *rfk = &(wl->rfkill);
+	struct b43_wldev *uninitialized_var(dev);
 	struct b43_phy *phy;
 	unsigned long flags;
 	unsigned int new_phymode = 0xFFFF;
@@ -2802,6 +2800,13 @@ static int b43_op_config(struct ieee8021
       out_unlock_mutex:
 	mutex_unlock(&wl->mutex);
 
+	/* if a LED is devoted to the radio and the switch is on, send
+	 * KEY_WLAN press/release keystrokes */
+	if (!err && dev->radio_hw_enable && &dev->led_radio) {
+		input_report_key(rfk->poll_dev->input, KEY_WLAN, 1);
+		input_report_key(rfk->poll_dev->input, KEY_WLAN, 0);
+	}
+
 	return err;
 }
 
@@ -3284,9 +3289,7 @@ static void b43_wireless_core_exit(struc
 		return;
 	b43_set_status(dev, B43_STAT_UNINIT);
 
-	mutex_unlock(&dev->wl->mutex);
-	b43_rfkill_exit(dev);
-	mutex_lock(&dev->wl->mutex);
+	b43_leds_exit(dev);
 
 	b43_rng_exit(dev->wl);
 	b43_pio_free(dev);
@@ -3409,8 +3412,8 @@ static int b43_wireless_core_init(struct
 	memset(wl->mac_addr, 0, ETH_ALEN);
 	b43_upload_card_macaddress(dev);
 	b43_security_init(dev);
-	b43_rfkill_init(dev);
 	b43_rng_init(wl);
+	b43_leds_init(dev);
 
 	b43_set_status(dev, B43_STAT_INITIALIZED);
 
@@ -3503,6 +3506,7 @@ static int b43_op_start(struct ieee80211
 	int did_init = 0;
 	int err = 0;
 
+	b43_rfkill_init(dev);
 	mutex_lock(&wl->mutex);
 
 	if (b43_status(dev) < B43_STAT_INITIALIZED) {
@@ -3537,6 +3541,7 @@ static void b43_op_stop(struct ieee80211
 		b43_wireless_core_stop(dev);
 	b43_wireless_core_exit(dev);
 	mutex_unlock(&wl->mutex);
+	b43_rfkill_exit(dev);
 }
 
 static int b43_op_set_retry_limit(struct ieee80211_hw *hw,
Index: wireless-2.6/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.c
+++ wireless-2.6/drivers/net/wireless/b43/leds.c
@@ -232,4 +232,5 @@ void b43_leds_exit(struct b43_wldev *dev
 	b43_unregister_led(&dev->led_tx);
 	b43_unregister_led(&dev->led_rx);
 	b43_unregister_led(&dev->led_assoc);
+	b43_unregister_led(&dev->led_radio);
 }


From gavron at wetwork.net  Thu Nov 29 02:38:49 2007
From: gavron at wetwork.net (Ehud Gavron)
Date: Wed, 28 Nov 2007 18:38:49 -0700
Subject: [PATCH] b43: Fix radio LED problem
In-Reply-To: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>
References: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>
Message-ID: <474E1829.4020407@wetwork.net>


This does not correct the LED issue in my Dell Latitude 620.

Let me know how I can help debug this.  I'm available all night and I 
can build a new kernel in about 5 minutes...

Ehud
[root at egdell leds]# ls
b43-phy0:radio  b43-phy0:rx  b43-phy0:tx
[root at egdell leds]# cat */uevent
PHYSDEVPATH=/devices/pci0000:00/0000:00:1c.1/0000:0c:00.0/ssb0:0
PHYSDEVBUS=ssb
PHYSDEVDRIVER=b43
PHYSDEVPATH=/devices/pci0000:00/0000:00:1c.1/0000:0c:00.0/ssb0:0
PHYSDEVBUS=ssb
PHYSDEVDRIVER=b43
PHYSDEVPATH=/devices/pci0000:00/0000:00:1c.1/0000:0c:00.0/ssb0:0
PHYSDEVBUS=ssb
PHYSDEVDRIVER=b43
...
input: b43-phy0 as /class/input/input11
Registered led device: b43-phy0:tx
Registered led device: b43-phy0:rx
Registered led device: b43-phy0:radio
...
[root at egdell input]# more input11/input\:event11/uevent
MAJOR=13
MINOR=75
[root at egdell input]# more input11/uevent
PRODUCT=19/1028/0/0
NAME="b43-phy0"
EV==3
KEY==400000000000 0 0 0
MODALIAS=input:b0019v1028p0000e0000-e0,1,kEE,ramlsfw


Larry Finger wrote:
> Since addition of the rfkill callback, the LED associated with the off
> switch on the radio has not worked for several reasons:
>
> (1) Essential data in the rfkill structure were missing.
> (2) The rfkill structure was initialized after the LED initialization.
> (3) There was a minor memory leak if the radio LED structure was inited.
>
> Once the above problems were fixed, additional difficulties were noted:
>
> (4) The radio LED was in the wrong state at startup.
> (5) The radio switch had to be manipulated twice for each state change.
> (6) A circular mutex locking situation existed.
>
> This patch fixes all of the above.
>
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
>
> John and Michael,
>
> These changes are mostly obvious. The most complicated is the fixing of the
> circular locking between the rfkill and wl_dev mutexes. This was acomplished
> by moving the rfkill_init() call to the beginning of b43_op_start() and the
> rfkill_exit() call to the end of b43_op_stop().
>
> Techically, these changes are fixes for the radio LED regression between
> bcm43xx and b43. It doesn't matter to me if they are pushed into 2.6.24, or
> left for 2.6.25.
>
> Larry
> ---
>
>  leds.c   |    1 +
>  main.c   |   25 +++++++++++++++----------
>  rfkill.c |   14 ++++++++++++--
>  3 files changed, 28 insertions(+), 12 deletions(-)
>
>
> Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
> +++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
> @@ -60,8 +60,12 @@ static void b43_rfkill_poll(struct input
>  	}
>  	mutex_unlock(&wl->mutex);
>  
> -	if (unlikely(report_change))
> -		input_report_key(poll_dev->input, KEY_WLAN, enabled);
> +	/* send the radio switch event to the system - note both a key press
> +	 * and a release are required */
> +	if (unlikely(report_change)) {
> +		input_report_key(poll_dev->input, KEY_WLAN, 1);
> +		input_report_key(poll_dev->input, KEY_WLAN, 0);
> +	}
>  }
>  
>  /* Called when the RFKILL toggled in software. */
> @@ -133,6 +137,12 @@ void b43_rfkill_init(struct b43_wldev *d
>  	rfk->poll_dev->poll = b43_rfkill_poll;
>  	rfk->poll_dev->poll_interval = 1000; /* msecs */
>  
> +	rfk->poll_dev->input->name = rfk->name;
> +	rfk->poll_dev->input->id.bustype = BUS_HOST;
> +	rfk->poll_dev->input->id.vendor = dev->dev->bus->boardinfo.vendor;
> +	rfk->poll_dev->input->evbit[0] = BIT(EV_KEY);
> +	set_bit(KEY_WLAN, rfk->poll_dev->input->keybit);
> +
>  	err = rfkill_register(rfk->rfkill);
>  	if (err)
>  		goto err_free_polldev;
> Index: wireless-2.6/drivers/net/wireless/b43/main.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/main.c
> +++ wireless-2.6/drivers/net/wireless/b43/main.c
> @@ -2156,7 +2156,6 @@ static void b43_mgmtframe_txantenna(stru
>  static void b43_chip_exit(struct b43_wldev *dev)
>  {
>  	b43_radio_turn_off(dev, 1);
> -	b43_leds_exit(dev);
>  	b43_gpio_cleanup(dev);
>  	/* firmware is released later */
>  }
> @@ -2184,11 +2183,10 @@ static int b43_chip_init(struct b43_wlde
>  	err = b43_gpio_init(dev);
>  	if (err)
>  		goto out;	/* firmware is released later */
> -	b43_leds_init(dev);
>  
>  	err = b43_upload_initvals(dev);
>  	if (err)
> -		goto err_leds_exit;
> +		goto err_gpio_clean;
>  	b43_radio_turn_on(dev);
>  
>  	b43_write16(dev, 0x03E6, 0x0000);
> @@ -2267,8 +2265,7 @@ out:
>  
>  err_radio_off:
>  	b43_radio_turn_off(dev, 1);
> -err_leds_exit:
> -	b43_leds_exit(dev);
> +err_gpio_clean:
>  	b43_gpio_cleanup(dev);
>  	return err;
>  }
> @@ -2703,7 +2700,8 @@ static int b43_antenna_from_ieee80211(u8
>  static int b43_op_config(struct ieee80211_hw *hw, struct ieee80211_conf *conf)
>  {
>  	struct b43_wl *wl = hw_to_b43_wl(hw);
> -	struct b43_wldev *dev;
> +	struct b43_rfkill *rfk = &(wl->rfkill);
> +	struct b43_wldev *uninitialized_var(dev);
>  	struct b43_phy *phy;
>  	unsigned long flags;
>  	unsigned int new_phymode = 0xFFFF;
> @@ -2802,6 +2800,13 @@ static int b43_op_config(struct ieee8021
>        out_unlock_mutex:
>  	mutex_unlock(&wl->mutex);
>  
> +	/* if a LED is devoted to the radio and the switch is on, send
> +	 * KEY_WLAN press/release keystrokes */
> +	if (!err && dev->radio_hw_enable && &dev->led_radio) {
> +		input_report_key(rfk->poll_dev->input, KEY_WLAN, 1);
> +		input_report_key(rfk->poll_dev->input, KEY_WLAN, 0);
> +	}
> +
>  	return err;
>  }
>  
> @@ -3284,9 +3289,7 @@ static void b43_wireless_core_exit(struc
>  		return;
>  	b43_set_status(dev, B43_STAT_UNINIT);
>  
> -	mutex_unlock(&dev->wl->mutex);
> -	b43_rfkill_exit(dev);
> -	mutex_lock(&dev->wl->mutex);
> +	b43_leds_exit(dev);
>  
>  	b43_rng_exit(dev->wl);
>  	b43_pio_free(dev);
> @@ -3409,8 +3412,8 @@ static int b43_wireless_core_init(struct
>  	memset(wl->mac_addr, 0, ETH_ALEN);
>  	b43_upload_card_macaddress(dev);
>  	b43_security_init(dev);
> -	b43_rfkill_init(dev);
>  	b43_rng_init(wl);
> +	b43_leds_init(dev);
>  
>  	b43_set_status(dev, B43_STAT_INITIALIZED);
>  
> @@ -3503,6 +3506,7 @@ static int b43_op_start(struct ieee80211
>  	int did_init = 0;
>  	int err = 0;
>  
> +	b43_rfkill_init(dev);
>  	mutex_lock(&wl->mutex);
>  
>  	if (b43_status(dev) < B43_STAT_INITIALIZED) {
> @@ -3537,6 +3541,7 @@ static void b43_op_stop(struct ieee80211
>  		b43_wireless_core_stop(dev);
>  	b43_wireless_core_exit(dev);
>  	mutex_unlock(&wl->mutex);
> +	b43_rfkill_exit(dev);
>  }
>  
>  static int b43_op_set_retry_limit(struct ieee80211_hw *hw,
> Index: wireless-2.6/drivers/net/wireless/b43/leds.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/leds.c
> +++ wireless-2.6/drivers/net/wireless/b43/leds.c
> @@ -232,4 +232,5 @@ void b43_leds_exit(struct b43_wldev *dev
>  	b43_unregister_led(&dev->led_tx);
>  	b43_unregister_led(&dev->led_rx);
>  	b43_unregister_led(&dev->led_assoc);
> +	b43_unregister_led(&dev->led_radio);
>  }
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   


From larry.finger at lwfinger.net  Thu Nov 29 03:18:41 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 28 Nov 2007 20:18:41 -0600
Subject: [PATCH] b43: Fix radio LED problem
In-Reply-To: <474E1829.4020407@wetwork.net>
References: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>
	<474E1829.4020407@wetwork.net>
Message-ID: <474E2181.4090602@lwfinger.net>

Ehud Gavron wrote:
> 
> This does not correct the LED issue in my Dell Latitude 620.
> 
> Let me know how I can help debug this.  I'm available all night and I
> can build a new kernel in about 5 minutes...

When you turn the radio off/on, do you see the following messages?

b43-phy0: Radio hardware status changed to DISABLED
b43-phy0: Radio hardware status changed to ENABLED

Larry



From gavron at wetwork.net  Thu Nov 29 04:13:43 2007
From: gavron at wetwork.net (Ehud Gavron)
Date: Wed, 28 Nov 2007 20:13:43 -0700
Subject: [PATCH] b43: Fix radio LED problem
In-Reply-To: <474E2181.4090602@lwfinger.net>
References: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>
	<474E1829.4020407@wetwork.net> <474E2181.4090602@lwfinger.net>
Message-ID: <474E2E67.3060503@wetwork.net>

Yes.  See below.  The USB device is the BT radio.

Ehud
usb 1-2.4: USB disconnect, address 4
b43-phy0: Radio hardware status changed to DISABLED
usb 1-2.4: new full speed USB device using ehci_hcd and address 7
usb 1-2.4: configuration #1 chosen from 1 choice
b43-phy0: Radio hardware status changed to ENABLED


Larry Finger wrote:
> Ehud Gavron wrote:
>   
>> This does not correct the LED issue in my Dell Latitude 620.
>>
>> Let me know how I can help debug this.  I'm available all night and I
>> can build a new kernel in about 5 minutes...
>>     
>
> When you turn the radio off/on, do you see the following messages?
>
> b43-phy0: Radio hardware status changed to DISABLED
> b43-phy0: Radio hardware status changed to ENABLED
>
> Larry
>   


From stefano.brivio at polimi.it  Thu Nov 29 04:39:57 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Thu, 29 Nov 2007 04:39:57 +0100
Subject: [RFT] [PATCH] b43: fix calc_nrssi_slope
Message-ID: <20071129043957.739b4d3f@morte>

Fix calc_nrssi_slope() which caused PHY TX errors on devices containing a
802.11a PHY. The code is synced to v4 specs and relevant registers are
renamed accordingly.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

Michael, John,
this fixes a not-so-fatal error with bcm4309 and possibly other devices
such as bcm4312 and bcm4319. I actually don't care that much about this
getting to 2.6.24, it's up to you. This still needs testing on other
devices, thanks.

---

Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h
+++ wireless-2.6/drivers/net/wireless/b43/b43.h
@@ -72,11 +72,11 @@
 #define B43_MMIO_PIO4_BASE		0x330
 
 #define B43_MMIO_PHY_VER		0x3E0
-#define B43_MMIO_PHY_RADIO		0x3E2
+#define B43_MMIO_PHY_BBANDCFG		0x3E2
 #define B43_MMIO_PHY0			0x3E6
 #define B43_MMIO_ANTENNA		0x3E8
 #define B43_MMIO_CHANNEL		0x3F0
-#define B43_MMIO_CHANNEL_EXT		0x3F4
+#define B43_MMIO_PHY_TEST		0x3F4
 #define B43_MMIO_RADIO_CONTROL		0x3F6
 #define B43_MMIO_RADIO_DATA_HIGH	0x3F8
 #define B43_MMIO_RADIO_DATA_LOW		0x3FA
@@ -278,20 +278,21 @@ enum {
 #define B43_PHY_ILT_A_CTRL		0x0072
 #define B43_PHY_ILT_A_DATA1		0x0073
 #define B43_PHY_ILT_A_DATA2		0x0074
-#define B43_PHY_G_LO_CONTROL		0x0810
 #define B43_PHY_ILT_G_CTRL		0x0472
 #define B43_PHY_ILT_G_DATA1		0x0473
 #define B43_PHY_ILT_G_DATA2		0x0474
 #define B43_PHY_A_PCTL			0x007B
 #define B43_PHY_G_PCTL			0x0029
-#define B43_PHY_A_CRS			0x0029
 #define B43_PHY_RADIO_BITFIELD		0x0401
-#define B43_PHY_G_CRS			0x0429
 #define B43_PHY_NRSSILT_CTRL		0x0803
 #define B43_PHY_NRSSILT_DATA		0x0804
 
 /* RadioRegisters */
 #define B43_RADIOCTL_ID			0x01
+#define B43_RADIO_2050_RXCTL0		0x007A
+#define B43_RADIO_2050_TXCTL1		0x0052
+#define B43_RADIO_2050_PCTL		0x0043
+
 
 /* MAC Control bitfield */
 #define B43_MACCTL_ENABLED		0x00000001	/* MAC Enabled */
@@ -551,6 +552,9 @@ struct b43_phy {
 
 	/* PHY TX errors counter. */
 	atomic_t txerr_cnt;
+
+	/* Hardware power control enabled? */
+	bool pctl_en;
 };
 
 /* Data structures for DMA transmission, per 80211 core. */
Index: wireless-2.6/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/lo.c
+++ wireless-2.6/drivers/net/wireless/b43/lo.c
@@ -563,7 +563,7 @@ struct lo_g_saved_values {
 	u16 phy_rfoverval;
 	u16 phy_classctl;
 	u16 phy_base_3E;
-	u16 phy_crs0;
+	u16 phy_crs;
 	u16 phy_pgactl;
 	u16 phy_base_2A;
 	u16 phy_syncctl;
@@ -619,13 +619,13 @@ static void lo_measure_setup(struct b43_
 		sav->phy_rfoverval = b43_phy_read(dev, B43_PHY_RFOVERVAL);
 		sav->phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);
 		sav->phy_base_3E = b43_phy_read(dev, B43_PHY_BASE(0x3E));
-		sav->phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);
+		sav->phy_crs = b43_phy_read(dev, B43_PHY_CRS);
 
 		b43_phy_write(dev, B43_PHY_CLASSCTL,
 			      b43_phy_read(dev, B43_PHY_CLASSCTL)
 			      & 0xFFFC);
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0x7FFF);
+		b43_phy_write(dev, B43_PHY_CRS, b43_phy_read(dev, B43_PHY_CRS)
+			      & ~B43_PHY_CRS_EN_ALL);
 		b43_phy_write(dev, B43_PHY_ANALOGOVER,
 			      b43_phy_read(dev, B43_PHY_ANALOGOVER)
 			      | 0x0003);
@@ -766,7 +766,7 @@ static void lo_measure_restore(struct b4
 		b43_phy_write(dev, B43_PHY_RFOVER, sav->phy_rfover);
 		b43_phy_write(dev, B43_PHY_RFOVERVAL, sav->phy_rfoverval);
 		b43_phy_write(dev, B43_PHY_BASE(0x3E), sav->phy_base_3E);
-		b43_phy_write(dev, B43_PHY_CRS0, sav->phy_crs0);
+		b43_phy_write(dev, B43_PHY_CRS, sav->phy_crs);
 	}
 	if (b43_has_hardware_pctl(phy)) {
 		tmp = (sav->phy_lo_mask & 0xBFFF);
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -2271,6 +2271,9 @@ static int b43_chip_init(struct b43_wlde
 	/* PHY TX errors counter. */
 	atomic_set(&phy->txerr_cnt, B43_PHY_TX_BADNESS_LIMIT);
 
+	/* Hardware power control status flag. */
+	phy->pctl_en = 0;
+
 	err = 0;
 	b43dbg(dev->wl, "Chip initialized\n");
 out:
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c
+++ wireless-2.6/drivers/net/wireless/b43/phy.c
@@ -648,6 +648,7 @@ static void b43_hardware_pctl_init(struc
 	}
 	/* Enable hardware pctl in firmware. */
 	b43_hf_write(dev, b43_hf_read(dev) | B43_HF_HWPCTL);
+	phy->pctl_en = 1;
 }
 
 static void b43_hardware_pctl_early_init(struct b43_wldev *dev)
@@ -799,8 +800,8 @@ static void b43_phy_ww(struct b43_wldev 
 	u16 b, curr_s, best_s = 0xFFFF;
 	int i;
 
-	b43_phy_write(dev, B43_PHY_CRS0,
-		b43_phy_read(dev, B43_PHY_CRS0) & ~B43_PHY_CRS0_EN);
+	b43_phy_write(dev, B43_PHY_CRS,
+		b43_phy_read(dev, B43_PHY_CRS) & ~B43_PHY_CRS_EN_ALL);
 	b43_phy_write(dev, B43_PHY_OFDM(0x1B),
 		b43_phy_read(dev, B43_PHY_OFDM(0x1B)) | 0x1000);
 	b43_phy_write(dev, B43_PHY_OFDM(0x82),
@@ -851,8 +852,8 @@ static void b43_phy_ww(struct b43_wldev 
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0E, 0x0011);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0F, 0x0013);
 	b43_phy_write(dev, B43_PHY_OFDM(0x33), 0x5030);
-	b43_phy_write(dev, B43_PHY_CRS0,
-		b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
+	b43_phy_write(dev, B43_PHY_CRS,
+		b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_ALL);
 }
 
 /* Initialize APHY. This is also called for the GPHY in some cases. */
@@ -883,8 +884,8 @@ static void b43_phy_inita(struct b43_wld
 				b43_phy_read(dev, 0x0034) | 0x0001);
 		b43_phy_rssiagc(dev, 0);
 
-		b43_phy_write(dev, B43_PHY_CRS0,
-			b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
+		b43_phy_write(dev, B43_PHY_CRS,
+			b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_ALL);
 
 		b43_radio_init2060(dev);
 
@@ -950,7 +951,7 @@ static void b43_phy_initb2(struct b43_wl
 	b43_phy_write(dev, 0x0026, 0xCC00);
 	if (phy->radio_ver != 0x2050)
 		b43_phy_write(dev, 0x0026, 0xCE00);
-	b43_write16(dev, B43_MMIO_CHANNEL_EXT, 0x1000);
+	b43_write16(dev, B43_MMIO_PHY_TEST, 0x1000);
 	b43_phy_write(dev, 0x002A, 0x88A3);
 	if (phy->radio_ver != 0x2050)
 		b43_phy_write(dev, 0x002A, 0x88C2);
@@ -1001,7 +1002,7 @@ static void b43_phy_initb4(struct b43_wl
 	b43_phy_write(dev, 0x0026, 0xCC00);
 	if (phy->radio_ver == 0x2050)
 		b43_phy_write(dev, 0x0026, 0xCE00);
-	b43_write16(dev, B43_MMIO_CHANNEL_EXT, 0x1100);
+	b43_write16(dev, B43_MMIO_PHY_TEST, 0x1100);
 	b43_phy_write(dev, 0x002A, 0x88A3);
 	if (phy->radio_ver == 0x2050)
 		b43_phy_write(dev, 0x002A, 0x88C2);
@@ -1046,7 +1047,7 @@ static void b43_phy_initb5(struct b43_wl
 					  b43_radio_read16(dev, 0x0051)
 					  | 0x0004);
 		}
-		b43_write16(dev, B43_MMIO_PHY_RADIO, 0x0000);
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG, 0x0000);
 
 		b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) | 0x0100);
 		b43_phy_write(dev, 0x042B, b43_phy_read(dev, 0x042B) | 0x2000);
@@ -1264,7 +1265,7 @@ static void b43_calc_loopback_gain(struc
 	u16 trsw_rx;
 	u16 loop1_outer_done, loop1_inner_done;
 
-	backup_phy[0] = b43_phy_read(dev, B43_PHY_CRS0);
+	backup_phy[0] = b43_phy_read(dev, B43_PHY_CRS);
 	backup_phy[1] = b43_phy_read(dev, B43_PHY_CCKBBANDCFG);
 	backup_phy[2] = b43_phy_read(dev, B43_PHY_RFOVER);
 	backup_phy[3] = b43_phy_read(dev, B43_PHY_RFOVERVAL);
@@ -1287,8 +1288,8 @@ static void b43_calc_loopback_gain(struc
 	backup_radio[1] = b43_radio_read16(dev, 0x43);
 	backup_radio[2] = b43_radio_read16(dev, 0x7A);
 
-	b43_phy_write(dev, B43_PHY_CRS0,
-		      b43_phy_read(dev, B43_PHY_CRS0) & 0x3FFF);
+	b43_phy_write(dev, B43_PHY_CRS,
+		      b43_phy_read(dev, B43_PHY_CRS) & ~B43_PHY_CRS_EN_ALL);
 	b43_phy_write(dev, B43_PHY_CCKBBANDCFG,
 		      b43_phy_read(dev, B43_PHY_CCKBBANDCFG) | 0x8000);
 	b43_phy_write(dev, B43_PHY_RFOVER,
@@ -1448,7 +1449,7 @@ static void b43_calc_loopback_gain(struc
 	udelay(10);
 	b43_phy_write(dev, B43_PHY_RFOVER, backup_phy[2]);
 	b43_phy_write(dev, B43_PHY_RFOVERVAL, backup_phy[3]);
-	b43_phy_write(dev, B43_PHY_CRS0, backup_phy[0]);
+	b43_phy_write(dev, B43_PHY_CRS, backup_phy[0]);
 	b43_phy_write(dev, B43_PHY_CCKBBANDCFG, backup_phy[1]);
 
 	phy->max_lb_gain =
@@ -1570,8 +1571,8 @@ static void b43_phy_initg(struct b43_wld
 	   but OFDM is legal everywhere */
 	if ((dev->dev->bus->chip_id == 0x4306
 	     && dev->dev->bus->chip_package == 2) || 0) {
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0xBFFF);
+		b43_phy_write(dev, B43_PHY_CRS, b43_phy_read(dev, B43_PHY_CRS)
+			      & ~B43_PHY_CRS_EN_0);
 		b43_phy_write(dev, B43_PHY_OFDM(0xC3),
 			      b43_phy_read(dev, B43_PHY_OFDM(0xC3))
 			      & 0x7FFF);
@@ -2332,8 +2333,8 @@ u8 b43_radio_aci_scan(struct b43_wldev *
 	b43_phy_lock(dev, phylock_flags);
 	b43_radio_lock(dev);
 	b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & 0xFFFC);
-	b43_phy_write(dev, B43_PHY_G_CRS,
-		      b43_phy_read(dev, B43_PHY_G_CRS) & 0x7FFF);
+	b43_phy_write(dev, B43_PHY_CRS,
+		      b43_phy_read(dev, B43_PHY_CRS) & ~B43_PHY_CRS_EN_ALL);
 	b43_set_all_gains(dev, 3, 8, 1);
 
 	start = (channel - 5 > 0) ? channel - 5 : 1;
@@ -2347,8 +2348,8 @@ u8 b43_radio_aci_scan(struct b43_wldev *
 	b43_phy_write(dev, 0x0802,
 		      (b43_phy_read(dev, 0x0802) & 0xFFFC) | 0x0003);
 	b43_phy_write(dev, 0x0403, b43_phy_read(dev, 0x0403) & 0xFFF8);
-	b43_phy_write(dev, B43_PHY_G_CRS,
-		      b43_phy_read(dev, B43_PHY_G_CRS) | 0x8000);
+	b43_phy_write(dev, B43_PHY_CRS,
+		      b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_ALL);
 	b43_set_original_gains(dev);
 	for (i = 0; i < 13; i++) {
 		if (!ret[i])
@@ -2593,7 +2594,7 @@ void b43_calc_nrssi_slope(struct b43_wld
 		backup[10] = b43_phy_read(dev, 0x0058);
 		backup[11] = b43_read16(dev, 0x03E2);
 		backup[12] = b43_read16(dev, 0x03E6);
-		backup[13] = b43_read16(dev, B43_MMIO_CHANNEL_EXT);
+		backup[13] = b43_read16(dev, B43_MMIO_PHY_TEST);
 
 		tmp = b43_radio_read16(dev, 0x007A);
 		tmp &= (phy->rev >= 5) ? 0x007F : 0x000F;
@@ -2614,9 +2615,9 @@ void b43_calc_nrssi_slope(struct b43_wld
 		} else if (phy->rev == 0) {
 			b43_write16(dev, 0x03E6, 0x0122);
 		} else {
-			b43_write16(dev, B43_MMIO_CHANNEL_EXT,
+			b43_write16(dev, B43_MMIO_PHY_TEST,
 				    b43_read16(dev,
-					       B43_MMIO_CHANNEL_EXT) & 0x2000);
+					       B43_MMIO_PHY_TEST) & 0x2000);
 		}
 		b43_phy_write(dev, 0x0020, 0x3F3F);
 		b43_phy_write(dev, 0x0015, 0xF330);
@@ -2662,111 +2663,104 @@ void b43_calc_nrssi_slope(struct b43_wld
 		if (phy->radio_rev == 8)
 			b43_calc_nrssi_offset(dev);
 
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      b43_phy_read(dev, B43_PHY_G_CRS) & 0x7FFF);
-		b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & 0xFFFC);
-		backup[7] = b43_read16(dev, 0x03E2);
-		b43_write16(dev, 0x03E2, b43_read16(dev, 0x03E2) | 0x8000);
-		backup[0] = b43_radio_read16(dev, 0x007A);
-		backup[1] = b43_radio_read16(dev, 0x0052);
-		backup[2] = b43_radio_read16(dev, 0x0043);
-		backup[3] = b43_phy_read(dev, 0x0015);
+		b43_phy_write(dev, B43_PHY_CRS,
+			      b43_phy_read(dev, B43_PHY_CRS)
+			       & ~B43_PHY_CRS_EN_ALL);
+		b43_phy_write(dev, B43_PHY_CLASSCTL,
+			      b43_phy_read(dev, B43_PHY_CLASSCTL) &
+			       ~(B43_PHY_CLASSCTL_CCK | B43_PHY_CLASSCTL_OFDM));
+		backup[7] = b43_read16(dev, B43_MMIO_PHY_BBANDCFG);
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG, backup[7] | 0x8000);
+		backup[0] = b43_radio_read16(dev, B43_RADIO_2050_RXCTL0);
+		backup[1] = b43_radio_read16(dev, B43_RADIO_2050_TXCTL1);
+		backup[2] = b43_radio_read16(dev, B43_RADIO_2050_PCTL);
+		backup[3] = b43_phy_read(dev, B43_PHY_PGACTL);
 		backup[4] = b43_phy_read(dev, 0x005A);
 		backup[5] = b43_phy_read(dev, 0x0059);
 		backup[6] = b43_phy_read(dev, 0x0058);
-		backup[8] = b43_read16(dev, 0x03E6);
-		backup[9] = b43_read16(dev, B43_MMIO_CHANNEL_EXT);
-		if (phy->rev >= 3) {
-			backup[10] = b43_phy_read(dev, 0x002E);
-			backup[11] = b43_phy_read(dev, 0x002F);
-			backup[12] = b43_phy_read(dev, 0x080F);
-			backup[13] = b43_phy_read(dev, B43_PHY_G_LO_CONTROL);
-			backup[14] = b43_phy_read(dev, 0x0801);
-			backup[15] = b43_phy_read(dev, 0x0060);
-			backup[16] = b43_phy_read(dev, 0x0014);
-			backup[17] = b43_phy_read(dev, 0x0478);
-			b43_phy_write(dev, 0x002E, 0);
-			b43_phy_write(dev, B43_PHY_G_LO_CONTROL, 0);
-			switch (phy->rev) {
-			case 4:
-			case 6:
-			case 7:
-				b43_phy_write(dev, 0x0478,
-					      b43_phy_read(dev, 0x0478)
-					      | 0x0100);
-				b43_phy_write(dev, 0x0801,
-					      b43_phy_read(dev, 0x0801)
-					      | 0x0040);
-				break;
-			case 3:
-			case 5:
-				b43_phy_write(dev, 0x0801,
-					      b43_phy_read(dev, 0x0801)
-					      & 0xFFBF);
-				break;
-			}
-			b43_phy_write(dev, 0x0060, b43_phy_read(dev, 0x0060)
-				      | 0x0040);
-			b43_phy_write(dev, 0x0014, b43_phy_read(dev, 0x0014)
-				      | 0x0200);
-		}
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x0070);
+		backup[8] = b43_read16(dev, B43_MMIO_PHY0);
+		backup[9] = b43_read16(dev, B43_MMIO_PHY_TEST);
+		if (phy->pctl_en) {
+			backup[10] = b43_phy_read(dev, B43_PHY_TXDC_OFFSET1);
+			backup[11] = b43_phy_read(dev, B43_PHY_TXDC_OFFSET2);
+			backup[12] = b43_phy_read(dev, B43_PHY_LO_MASK);
+			backup[13] = b43_phy_read(dev, B43_PHY_LO_CTL);
+			backup[14] = b43_phy_read(dev, B43_PHY_G_CTL);
+			backup[15] = b43_phy_read(dev, B43_PHY_DACCTL);
+			backup[16] = b43_phy_read(dev, B43_PHY_TR_LT2);
+			backup[17] = b43_phy_read(dev, B43_PHY_HPWR_TSSICTL);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET1, 0);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET2, 0);
+			b43_phy_write(dev, B43_PHY_LO_MASK, 0);
+			b43_phy_write(dev, B43_PHY_LO_CTL, 0);
+			b43_phy_write(dev, B43_PHY_HPWR_TSSICTL, 0);
+			b43_phy_write(dev, B43_PHY_G_CTL, 0);
+			b43_phy_write(dev, B43_PHY_DACCTL, 0);
+			b43_phy_write(dev, B43_PHY_TR_LT2, 0);
+		}
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x0070);
 		b43_set_all_gains(dev, 0, 8, 0);
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) & 0x00F7);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   & 0x00F7);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0811,
-				      (b43_phy_read(dev, 0x0811) & 0xFFCF) |
-				      0x0030);
-			b43_phy_write(dev, 0x0812,
-				      (b43_phy_read(dev, 0x0812) & 0xFFCF) |
-				      0x0010);
+			b43_phy_write(dev, B43_PHY_RFOVER,
+				      b43_phy_read(dev, B43_PHY_RFOVER)
+				       | 0x0030);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF) | 0x0010);
 		}
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x0080);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x0080);
 		udelay(20);
 
-		nrssi0 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
+		nrssi0 = (s16)((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (nrssi0 >= 0x0020)
 			nrssi0 -= 0x0040;
 
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) & 0x007F);
-		if (phy->rev >= 2) {
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   & 0x0080);
+		if (phy->analog >= 2) {
 			b43_phy_write(dev, 0x0003, (b43_phy_read(dev, 0x0003)
 						    & 0xFF9F) | 0x0040);
 		}
 
-		b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-			    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
+		b43_write16(dev, B43_MMIO_PHY_TEST,
+			    b43_read16(dev, B43_MMIO_PHY_TEST)
 			    | 0x2000);
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x000F);
-		b43_phy_write(dev, 0x0015, 0xF330);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x000F);
+		b43_phy_write(dev, B43_PHY_PGACTL, 0xF330);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0812,
-				      (b43_phy_read(dev, 0x0812) & 0xFFCF) |
-				      0x0020);
-			b43_phy_write(dev, 0x0811,
-				      (b43_phy_read(dev, 0x0811) & 0xFFCF) |
-				      0x0020);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF) | 0x0020);
+			b43_phy_write(dev, B43_PHY_RFOVER,
+				      (b43_phy_read(dev, B43_PHY_RFOVER)
+				       & 0xFFCF) | 0x0020);
 		}
-
 		b43_set_all_gains(dev, 3, 0, 1);
-		if (phy->radio_rev == 8) {
-			b43_radio_write16(dev, 0x0043, 0x001F);
-		} else {
-			tmp = b43_radio_read16(dev, 0x0052) & 0xFF0F;
-			b43_radio_write16(dev, 0x0052, tmp | 0x0060);
-			tmp = b43_radio_read16(dev, 0x0043) & 0xFFF0;
-			b43_radio_write16(dev, 0x0043, tmp | 0x0009);
+		if (phy->radio_rev == 8)
+			b43_radio_write16(dev, B43_RADIO_2050_PCTL, 0x001F);
+		else {
+			b43_radio_write16(dev, B43_RADIO_2050_TXCTL1,
+					  (b43_radio_read16(dev, B43_RADIO_2050_TXCTL1)
+					   & 0xFF0F) | 0x0060);
+			b43_radio_write16(dev, B43_RADIO_2050_PCTL,
+					  (b43_radio_read16(dev, B43_RADIO_2050_PCTL)
+					   & 0xFFF0) | 0x0009);
 		}
 		b43_phy_write(dev, 0x005A, 0x0480);
 		b43_phy_write(dev, 0x0059, 0x0810);
 		b43_phy_write(dev, 0x0058, 0x000D);
 		udelay(20);
-		nrssi1 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
+		nrssi1 = (s16)((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (nrssi1 >= 0x0020)
 			nrssi1 -= 0x0040;
 		if (nrssi0 == nrssi1)
@@ -2777,40 +2771,43 @@ void b43_calc_nrssi_slope(struct b43_wld
 			phy->nrssi[0] = nrssi1;
 			phy->nrssi[1] = nrssi0;
 		}
-		if (phy->rev >= 3) {
-			b43_phy_write(dev, 0x002E, backup[10]);
-			b43_phy_write(dev, 0x002F, backup[11]);
-			b43_phy_write(dev, 0x080F, backup[12]);
-			b43_phy_write(dev, B43_PHY_G_LO_CONTROL, backup[13]);
-		}
+		if (phy->pctl_en) {
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET1, backup[10]);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET2, backup[11]);
+			b43_phy_write(dev, B43_PHY_LO_MASK, backup[12]);
+			b43_phy_write(dev, B43_PHY_LO_CTL, backup[13]);
+		}
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0, backup[0]);
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG, backup[7]);
+		b43_phy_write(dev, B43_PHY_PGACTL, backup[3]);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0812,
-				      b43_phy_read(dev, 0x0812) & 0xFFCF);
-			b43_phy_write(dev, 0x0811,
-				      b43_phy_read(dev, 0x0811) & 0xFFCF);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      b43_phy_read(dev, B43_PHY_RFOVER)
+				       & 0xFFCF);
 		}
-
-		b43_radio_write16(dev, 0x007A, backup[0]);
-		b43_radio_write16(dev, 0x0052, backup[1]);
-		b43_radio_write16(dev, 0x0043, backup[2]);
-		b43_write16(dev, 0x03E2, backup[7]);
-		b43_write16(dev, 0x03E6, backup[8]);
-		b43_write16(dev, B43_MMIO_CHANNEL_EXT, backup[9]);
-		b43_phy_write(dev, 0x0015, backup[3]);
+		b43_write16(dev, B43_MMIO_PHY0, backup[8]);
+		b43_write16(dev, B43_MMIO_PHY_TEST, backup[9]);
+		b43_radio_write16(dev, B43_RADIO_2050_TXCTL1, backup[1]);
+		b43_radio_write16(dev, B43_RADIO_2050_PCTL, backup[2]);
 		b43_phy_write(dev, 0x005A, backup[4]);
 		b43_phy_write(dev, 0x0059, backup[5]);
 		b43_phy_write(dev, 0x0058, backup[6]);
 		b43_synth_pu_workaround(dev, phy->channel);
-		b43_phy_write(dev, 0x0802,
-			      b43_phy_read(dev, 0x0802) | (0x0001 | 0x0002));
+		b43_phy_write(dev, B43_PHY_CLASSCTL,
+			      b43_phy_read(dev, B43_PHY_CLASSCTL)
+			       | (B43_PHY_CLASSCTL_CCK | B43_PHY_CLASSCTL_OFDM));
 		b43_set_original_gains(dev);
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      b43_phy_read(dev, B43_PHY_G_CRS) | 0x8000);
-		if (phy->rev >= 3) {
-			b43_phy_write(dev, 0x0801, backup[14]);
-			b43_phy_write(dev, 0x0060, backup[15]);
-			b43_phy_write(dev, 0x0014, backup[16]);
-			b43_phy_write(dev, 0x0478, backup[17]);
+		b43_phy_write(dev, B43_PHY_CRS,
+			      b43_phy_read(dev, B43_PHY_CRS)
+			       | B43_PHY_CRS_EN_ALL);
+		if (phy->pctl_en) {
+			b43_phy_write(dev, B43_PHY_G_CTL, backup[14]);
+			b43_phy_write(dev, B43_PHY_DACCTL, backup[15]);
+			b43_phy_write(dev, B43_PHY_TR_LT2, backup[16]);
+			b43_phy_write(dev, B43_PHY_HPWR_TSSICTL, backup[17]);
 		}
 		b43_nrssi_mem_update(dev);
 		b43_calc_nrssi_threshold(dev);
@@ -3001,9 +2998,9 @@ b43_radio_interference_mitigation_enable
 		if (phy->rev != 1) {
 			b43_phy_write(dev, 0x042B,
 				      b43_phy_read(dev, 0x042B) | 0x0800);
-			b43_phy_write(dev, B43_PHY_G_CRS,
+			b43_phy_write(dev, B43_PHY_CRS,
 				      b43_phy_read(dev,
-						   B43_PHY_G_CRS) & ~0x4000);
+						   B43_PHY_CRS) & ~B43_PHY_CRS_EN_0);
 			break;
 		}
 		radio_stacksave(0x0078);
@@ -3063,7 +3060,7 @@ b43_radio_interference_mitigation_enable
 		phy->aci_enable = 1;
 
 		phy_stacksave(B43_PHY_RADIO_BITFIELD);
-		phy_stacksave(B43_PHY_G_CRS);
+		phy_stacksave(B43_PHY_CRS);
 		if (phy->rev < 2) {
 			phy_stacksave(0x0406);
 		} else {
@@ -3100,8 +3097,8 @@ b43_radio_interference_mitigation_enable
 		b43_phy_write(dev, B43_PHY_RADIO_BITFIELD,
 			      b43_phy_read(dev, B43_PHY_RADIO_BITFIELD)
 			      & ~0x1000);
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      (b43_phy_read(dev, B43_PHY_G_CRS)
+		b43_phy_write(dev, B43_PHY_CRS,
+			      (b43_phy_read(dev, B43_PHY_CRS)
 			       & 0xFFFC) | 0x0002);
 
 		b43_phy_write(dev, 0x0033, 0x0800);
@@ -3203,9 +3200,9 @@ b43_radio_interference_mitigation_disabl
 		if (phy->rev != 1) {
 			b43_phy_write(dev, 0x042B,
 				      b43_phy_read(dev, 0x042B) & ~0x0800);
-			b43_phy_write(dev, B43_PHY_G_CRS,
+			b43_phy_write(dev, B43_PHY_CRS,
 				      b43_phy_read(dev,
-						   B43_PHY_G_CRS) | 0x4000);
+						   B43_PHY_CRS) | B43_PHY_CRS_EN_0);
 			break;
 		}
 		radio_stackrestore(0x0078);
@@ -3217,8 +3214,8 @@ b43_radio_interference_mitigation_disabl
 				      b43_phy_read(dev, B43_PHY_RADIO_BITFIELD)
 				      & ~(1 << 11));
 		}
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      b43_phy_read(dev, B43_PHY_G_CRS) | 0x4000);
+		b43_phy_write(dev, B43_PHY_CRS,
+			      b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_0);
 		phy_stackrestore(0x04A0);
 		phy_stackrestore(0x04A1);
 		phy_stackrestore(0x04A2);
@@ -3238,7 +3235,7 @@ b43_radio_interference_mitigation_disabl
 		phy->aci_enable = 0;
 
 		phy_stackrestore(B43_PHY_RADIO_BITFIELD);
-		phy_stackrestore(B43_PHY_G_CRS);
+		phy_stackrestore(B43_PHY_CRS);
 		phy_stackrestore(0x0033);
 		phy_stackrestore(0x04A3);
 		phy_stackrestore(0x04A9);
@@ -3484,7 +3481,7 @@ struct init2050_saved_values {
 	u16 phy_rfoverval;
 	u16 phy_analogover;
 	u16 phy_analogoverval;
-	u16 phy_crs0;
+	u16 phy_crs;
 	u16 phy_classctl;
 	u16 phy_lo_mask;
 	u16 phy_lo_ctl;
@@ -3523,7 +3520,7 @@ u16 b43_radio_init2050(struct b43_wldev 
 		sav.phy_analogover = b43_phy_read(dev, B43_PHY_ANALOGOVER);
 		sav.phy_analogoverval =
 		    b43_phy_read(dev, B43_PHY_ANALOGOVERVAL);
-		sav.phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);
+		sav.phy_crs = b43_phy_read(dev, B43_PHY_CRS);
 		sav.phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);
 
 		b43_phy_write(dev, B43_PHY_ANALOGOVER,
@@ -3532,8 +3529,8 @@ u16 b43_radio_init2050(struct b43_wldev 
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      b43_phy_read(dev, B43_PHY_ANALOGOVERVAL)
 			      & 0xFFFC);
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0x7FFF);
+		b43_phy_write(dev, B43_PHY_CRS, b43_phy_read(dev, B43_PHY_CRS)
+			      & ~B43_PHY_CRS_EN_ALL);
 		b43_phy_write(dev, B43_PHY_CLASSCTL,
 			      b43_phy_read(dev, B43_PHY_CLASSCTL)
 			      & 0xFFFC);
@@ -3570,8 +3567,8 @@ u16 b43_radio_init2050(struct b43_wldev 
 				      (b43_phy_read(dev, B43_PHY_BASE(0x03))
 				       & 0xFFBF) | 0x40);
 		}
-		b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-			    (b43_read16(dev, B43_MMIO_CHANNEL_EXT) | 0x2000));
+		b43_write16(dev, B43_MMIO_PHY_TEST,
+			    (b43_read16(dev, B43_MMIO_PHY_TEST) | 0x2000));
 	}
 
 	rcc = b43_radio_core_calibration_value(dev);
@@ -3715,15 +3712,15 @@ u16 b43_radio_init2050(struct b43_wldev 
 		b43_phy_write(dev, B43_PHY_BASE(0x30), sav.phy_base_30);
 		b43_write16(dev, 0x3EC, sav.reg_3EC);
 	} else if (phy->gmode) {
-		b43_write16(dev, B43_MMIO_PHY_RADIO,
-			    b43_read16(dev, B43_MMIO_PHY_RADIO)
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG,
+			    b43_read16(dev, B43_MMIO_PHY_BBANDCFG)
 			    & 0x7FFF);
 		b43_phy_write(dev, B43_PHY_RFOVER, sav.phy_rfover);
 		b43_phy_write(dev, B43_PHY_RFOVERVAL, sav.phy_rfoverval);
 		b43_phy_write(dev, B43_PHY_ANALOGOVER, sav.phy_analogover);
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      sav.phy_analogoverval);
-		b43_phy_write(dev, B43_PHY_CRS0, sav.phy_crs0);
+		b43_phy_write(dev, B43_PHY_CRS, sav.phy_crs);
 		b43_phy_write(dev, B43_PHY_CLASSCTL, sav.phy_classctl);
 		if (has_loopback_gain(phy)) {
 			b43_phy_write(dev, B43_PHY_LO_MASK, sav.phy_lo_mask);
@@ -3912,12 +3909,12 @@ int b43_radio_selectchannel(struct b43_w
 			else
 				b43_hf_write(dev,
 					     b43_hf_read(dev) | B43_HF_ACPR);
-			b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-				    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
+			b43_write16(dev, B43_MMIO_PHY_TEST,
+				    b43_read16(dev, B43_MMIO_PHY_TEST)
 				    | (1 << 11));
 		} else {
-			b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-				    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
+			b43_write16(dev, B43_MMIO_PHY_TEST,
+				    b43_read16(dev, B43_MMIO_PHY_TEST)
 				    & 0xF7BF);
 		}
 	}
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h
+++ wireless-2.6/drivers/net/wireless/b43/phy.h
@@ -29,8 +29,9 @@ struct b43_phy;
 #define B43_PHY_LNAHPFCTL		B43_PHY_OFDM(0x1C)	/* LNA/HPF control */
 #define B43_PHY_LPFGAINCTL		B43_PHY_OFDM(0x20)	/* LPF Gain control */
 #define B43_PHY_ADIVRELATED		B43_PHY_OFDM(0x27)	/* FIXME rename */
-#define B43_PHY_CRS0			B43_PHY_OFDM(0x29)	/* Collision resolution signaling */
-#define  B43_PHY_CRS0_EN		0x8000	/* CRS enable */
+#define B43_PHY_CRS			B43_PHY_OFDM(0x29)	/* Collision resolution signaling */
+#define  B43_PHY_CRS_EN_ALL		0x8000			/* CRS enable */
+#define  B43_PHY_CRS_EN_0		0x4000			/* CRS 0 enable */
 #define B43_PHY_PEAK_COUNT		B43_PHY_OFDM(0x30)
 #define B43_PHY_ANTDWELL		B43_PHY_OFDM(0x2B)	/* Antenna dwell */
 #define  B43_PHY_ANTDWELL_AUTODIV1	0x0100	/* Automatic RX diversity start antenna */
@@ -78,11 +79,14 @@ struct b43_phy;
 /* CCK (B) PHY Registers */
 #define B43_PHY_VERSION_CCK		B43_PHY_BASE(0x00)	/* Versioning register for B-PHY */
 #define B43_PHY_CCKBBANDCFG		B43_PHY_BASE(0x01)	/* Contains antenna 0/1 control bit */
+#define B43_PHY_TR_LT2			B43_PHY_BASE(0x14)	/* TR lookup table 2 */
 #define B43_PHY_PGACTL			B43_PHY_BASE(0x15)	/* PGA control */
 #define  B43_PHY_PGACTL_LPF		0x1000	/* Low pass filter (?) */
 #define  B43_PHY_PGACTL_LOWBANDW	0x0040	/* Low bandwidth flag */
 #define  B43_PHY_PGACTL_UNKNOWN		0xEFA0
 #define B43_PHY_FBCTL1			B43_PHY_BASE(0x18)	/* Frequency bandwidth control 1 */
+#define B43_PHY_TXDC_OFFSET1		B43_PHY_BASE(0x2E)
+#define B43_PHY_TXDC_OFFSET2		B43_PHY_BASE(0x2F)
 #define B43_PHY_ITSSI			B43_PHY_BASE(0x29)	/* Idle TSSI */
 #define B43_PHY_LO_LEAKAGE		B43_PHY_BASE(0x2D)	/* Measured LO leakage */
 #define B43_PHY_ENERGY			B43_PHY_BASE(0x33)	/* Energy */
@@ -92,7 +96,10 @@ struct b43_phy;
 #define B43_PHY_RCCALOVER		B43_PHY_BASE(0x78)	/* RC calibration override */
 
 /* Extended G-PHY Registers */
+#define B43_PHY_G_CTL			B43_PHY_EXTG(0x01)	/* G PHY control */
 #define B43_PHY_CLASSCTL		B43_PHY_EXTG(0x02)	/* Classify control */
+#define  B43_PHY_CLASSCTL_CCK		0x0001
+#define  B43_PHY_CLASSCTL_OFDM		0x0002
 #define B43_PHY_GTABCTL			B43_PHY_EXTG(0x03)	/* G-PHY table control (see below) */
 #define  B43_PHY_GTABOFF		0x03FF	/* G-PHY table offset (see below) */
 #define  B43_PHY_GTABNR			0xFC00	/* G-PHY table number (see below) */
Index: wireless-2.6/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
+++ wireless-2.6/drivers/net/wireless/b43/wa.c
@@ -325,8 +325,8 @@ static void b43_wa_crs_ed(struct b43_wld
 
 static void b43_wa_crs_thr(struct b43_wldev *dev)
 {
-	b43_phy_write(dev, B43_PHY_CRS0,
-			(b43_phy_read(dev, B43_PHY_CRS0) & ~0x03C0) | 0xD000);
+	b43_phy_write(dev, B43_PHY_CRS,
+			(b43_phy_read(dev, B43_PHY_CRS) & ~0x03C0) | 0xD000);
 }
 
 static void b43_wa_crs_blank(struct b43_wldev *dev)


-- 
Ciao
Stefano


From larry.finger at lwfinger.net  Thu Nov 29 05:16:37 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 28 Nov 2007 22:16:37 -0600
Subject: [PATCH] b43: Fix radio LED problem
In-Reply-To: <474E2E67.3060503@wetwork.net>
References: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>	<474E1829.4020407@wetwork.net>
	<474E2181.4090602@lwfinger.net> <474E2E67.3060503@wetwork.net>
Message-ID: <474E3D25.1000304@lwfinger.net>

Ehud Gavron wrote:
> Yes.  See below.  The USB device is the BT radio.
> 
> Ehud
> usb 1-2.4: USB disconnect, address 4
> b43-phy0: Radio hardware status changed to DISABLED
> usb 1-2.4: new full speed USB device using ehci_hcd and address 7
> usb 1-2.4: configuration #1 chosen from 1 choice
> b43-phy0: Radio hardware status changed to ENABLED

OK, the system is reacting to the switch, but the LED is not. Could you please run the following two 
commands and send me the file ssb_sprom_copy?

SSB_SPROM=$(find /sys -name ssb_sprom)
sudo cat $SSB_SPROM > ssb_sprom_copy

Thanks,

Larry


From gavron at wetwork.net  Thu Nov 29 05:29:43 2007
From: gavron at wetwork.net (Ehud Gavron)
Date: Wed, 28 Nov 2007 21:29:43 -0700
Subject: [PATCH] b43: Fix radio LED problem
In-Reply-To: <474E3D25.1000304@lwfinger.net>
References: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>
	<474E1829.4020407@wetwork.net> <474E2181.4090602@lwfinger.net>
	<474E2E67.3060503@wetwork.net> <474E3D25.1000304@lwfinger.net>
Message-ID: <474E4037.1060807@wetwork.net>

[root at egdell ~]# SSB_SPROM=$(find /sys -name ssb_sprom)
[root at egdell ~]# sudo cat $SSB_SPROM > ssb_sprom_copy
[root at egdell ~]# more ssb_sprom_copy
01300000070028100800BE0D00FFFFFF11430080020000000010001800000000FFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF1A000E921F40FFFF
FFFFFFFFFFFFFFFFFFFFFFFF36303D15A0FA79FEFF83FFFF4AFFFFFFFFFFFFFF3EFF494A02FFFFFF
0CFFFFFFFFFF021F


Larry Finger wrote:
> Ehud Gavron wrote:
>> Yes.  See below.  The USB device is the BT radio.
>>
>> Ehud
>> usb 1-2.4: USB disconnect, address 4
>> b43-phy0: Radio hardware status changed to DISABLED
>> usb 1-2.4: new full speed USB device using ehci_hcd and address 7
>> usb 1-2.4: configuration #1 chosen from 1 choice
>> b43-phy0: Radio hardware status changed to ENABLED
>
> OK, the system is reacting to the switch, but the LED is not. Could 
> you please run the following two commands and send me the file 
> ssb_sprom_copy?
>
> SSB_SPROM=$(find /sys -name ssb_sprom)
> sudo cat $SSB_SPROM > ssb_sprom_copy
>
> Thanks,
>
> Larry


From larry.finger at lwfinger.net  Thu Nov 29 05:50:27 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 28 Nov 2007 22:50:27 -0600
Subject: [PATCH] b43: Fix radio LED problem
In-Reply-To: <474E4037.1060807@wetwork.net>
References: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>
	<474E1829.4020407@wetwork.net> <474E2181.4090602@lwfinger.net>
	<474E2E67.3060503@wetwork.net> <474E3D25.1000304@lwfinger.net>
	<474E4037.1060807@wetwork.net>
Message-ID: <474E4513.4010001@lwfinger.net>

Ehud Gavron wrote:
> [root at egdell ~]# SSB_SPROM=$(find /sys -name ssb_sprom)
> [root at egdell ~]# sudo cat $SSB_SPROM > ssb_sprom_copy
> [root at egdell ~]# more ssb_sprom_copy
> 01300000070028100800BE0D00FFFFFF11430080020000000010001800000000FFFFFFFFFFFFFFFF 
> 
> FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF1A000E921F40FFFF 
> 
> FFFFFFFFFFFFFFFFFFFFFFFF36303D15A0FA79FEFF83FFFF4AFFFFFFFFFFFFFF3EFF494A02FFFFFF 
> 
> 0CFFFFFFFFFF021F

Your SPROM contains the same LED data as mine does. I have no idea why your LED doesn't toggle the 
way mine does.

I have no idea what to try next. Sorry.

Larry



From gavron at wetwork.net  Thu Nov 29 05:52:07 2007
From: gavron at wetwork.net (Ehud Gavron)
Date: Wed, 28 Nov 2007 21:52:07 -0700
Subject: [PATCH] b43: Fix radio LED problem
In-Reply-To: <474E4513.4010001@lwfinger.net>
References: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>
	<474E1829.4020407@wetwork.net> <474E2181.4090602@lwfinger.net>
	<474E2E67.3060503@wetwork.net> <474E3D25.1000304@lwfinger.net>
	<474E4037.1060807@wetwork.net> <474E4513.4010001@lwfinger.net>
Message-ID: <474E4577.9010001@wetwork.net>

Just as a reminder in the hopes it triggers some thought, Fedora 
2.6.23.1-42.fc8 worked... but 1-49.fc9 didn't, and none of everything or 
wireless-2.6 worked.

If you think of anything I can test... let me know.  It's early. :)

Ehud

Larry Finger wrote:
> Ehud Gavron wrote:
>> [root at egdell ~]# SSB_SPROM=$(find /sys -name ssb_sprom)
>> [root at egdell ~]# sudo cat $SSB_SPROM > ssb_sprom_copy
>> [root at egdell ~]# more ssb_sprom_copy
>> 01300000070028100800BE0D00FFFFFF11430080020000000010001800000000FFFFFFFFFFFFFFFF 
>>
>> FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF1A000E921F40FFFF 
>>
>> FFFFFFFFFFFFFFFFFFFFFFFF36303D15A0FA79FEFF83FFFF4AFFFFFFFFFFFFFF3EFF494A02FFFFFF 
>>
>> 0CFFFFFFFFFF021F
>
> Your SPROM contains the same LED data as mine does. I have no idea why 
> your LED doesn't toggle the way mine does.
>
> I have no idea what to try next. Sorry.
>
> Larry


From larry.finger at lwfinger.net  Thu Nov 29 06:11:31 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 28 Nov 2007 23:11:31 -0600
Subject: [PATCH] b43: Fix radio LED problem
In-Reply-To: <474E4577.9010001@wetwork.net>
References: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>	<474E1829.4020407@wetwork.net>
	<474E2181.4090602@lwfinger.net>	<474E2E67.3060503@wetwork.net>
	<474E3D25.1000304@lwfinger.net>	<474E4037.1060807@wetwork.net>
	<474E4513.4010001@lwfinger.net> <474E4577.9010001@wetwork.net>
Message-ID: <474E4A03.9050803@lwfinger.net>

Ehud Gavron wrote:
> Just as a reminder in the hopes it triggers some thought, Fedora 
> 2.6.23.1-42.fc8 worked... but 1-49.fc9 didn't, and none of everything or 
> wireless-2.6 worked.
> 
> If you think of anything I can test... let me know.  It's early. :)

Kernels without the new LED handling with rfkill work. Those with it do not.

Unfortunately, it is late for me.

Larry


From Larry.Finger at lwfinger.net  Thu Nov 29 14:44:48 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 29 Nov 2007 07:44:48 -0600
Subject: Off-line for now
Message-ID: <474EC250.8060604@lwfinger.net>

Today is the day I start my winter migration to a warmer clime. Until April, my full-time access to 
a broadband line is limited, which is the reason I resigned as maintainer for bcm43xx and b43legacy.

I will not be leaving the bcm43xx community completely as I have joined the reverse engineering 
group. At the moment, my involvement there has been to download the "secret" sources and to start 
learning the MIPS instruction set. Stefano has already asked for some help on the 802.11a section, 
and there is still the entire "Draft N" specification to be worked on - at least enough to get the 
BCM4328 working in 802.11g mode.

It has been a lot of fun working on the driver for the Broadcom hardware. The group has accomplished 
so much in getting a very complicated piece of hardware to function as well as it does with the 
drivers written by Broadcom. In fact, my BCM4311 has higher throughput with the b43 driver than it 
does when I'm running Windows (Yes, my machine does dual-boot, but that is mainly for testing!).

Larry


From stefano.brivio at polimi.it  Thu Nov 29 16:34:49 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Thu, 29 Nov 2007 16:34:49 +0100
Subject: [RFT] [PATCH v2] b43: fix calc_nrssi_slope
In-Reply-To: <20071129043957.739b4d3f@morte>
References: <20071129043957.739b4d3f@morte>
Message-ID: <20071129163449.326e592e@morte>

Fix calc_nrssi_slope() which caused PHY TX errors on devices containing a
802.11a PHY. The code is synced to v4 specs and relevant registers are
renamed accordingly.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

Previous version introduced a duplicated flag and a redundant newline.

---

Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h
+++ wireless-2.6/drivers/net/wireless/b43/b43.h
@@ -72,11 +72,11 @@
 #define B43_MMIO_PIO4_BASE		0x330
 
 #define B43_MMIO_PHY_VER		0x3E0
-#define B43_MMIO_PHY_RADIO		0x3E2
+#define B43_MMIO_PHY_BBANDCFG		0x3E2
 #define B43_MMIO_PHY0			0x3E6
 #define B43_MMIO_ANTENNA		0x3E8
 #define B43_MMIO_CHANNEL		0x3F0
-#define B43_MMIO_CHANNEL_EXT		0x3F4
+#define B43_MMIO_PHY_TEST		0x3F4
 #define B43_MMIO_RADIO_CONTROL		0x3F6
 #define B43_MMIO_RADIO_DATA_HIGH	0x3F8
 #define B43_MMIO_RADIO_DATA_LOW		0x3FA
@@ -278,20 +278,20 @@ enum {
 #define B43_PHY_ILT_A_CTRL		0x0072
 #define B43_PHY_ILT_A_DATA1		0x0073
 #define B43_PHY_ILT_A_DATA2		0x0074
-#define B43_PHY_G_LO_CONTROL		0x0810
 #define B43_PHY_ILT_G_CTRL		0x0472
 #define B43_PHY_ILT_G_DATA1		0x0473
 #define B43_PHY_ILT_G_DATA2		0x0474
 #define B43_PHY_A_PCTL			0x007B
 #define B43_PHY_G_PCTL			0x0029
-#define B43_PHY_A_CRS			0x0029
 #define B43_PHY_RADIO_BITFIELD		0x0401
-#define B43_PHY_G_CRS			0x0429
 #define B43_PHY_NRSSILT_CTRL		0x0803
 #define B43_PHY_NRSSILT_DATA		0x0804
 
 /* RadioRegisters */
 #define B43_RADIOCTL_ID			0x01
+#define B43_RADIO_2050_RXCTL0		0x007A
+#define B43_RADIO_2050_TXCTL1		0x0052
+#define B43_RADIO_2050_PCTL		0x0043
 
 /* MAC Control bitfield */
 #define B43_MACCTL_ENABLED		0x00000001	/* MAC Enabled */
Index: wireless-2.6/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/lo.c
+++ wireless-2.6/drivers/net/wireless/b43/lo.c
@@ -563,7 +563,7 @@ struct lo_g_saved_values {
 	u16 phy_rfoverval;
 	u16 phy_classctl;
 	u16 phy_base_3E;
-	u16 phy_crs0;
+	u16 phy_crs;
 	u16 phy_pgactl;
 	u16 phy_base_2A;
 	u16 phy_syncctl;
@@ -619,13 +619,13 @@ static void lo_measure_setup(struct b43_
 		sav->phy_rfoverval = b43_phy_read(dev, B43_PHY_RFOVERVAL);
 		sav->phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);
 		sav->phy_base_3E = b43_phy_read(dev, B43_PHY_BASE(0x3E));
-		sav->phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);
+		sav->phy_crs = b43_phy_read(dev, B43_PHY_CRS);
 
 		b43_phy_write(dev, B43_PHY_CLASSCTL,
 			      b43_phy_read(dev, B43_PHY_CLASSCTL)
 			      & 0xFFFC);
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0x7FFF);
+		b43_phy_write(dev, B43_PHY_CRS, b43_phy_read(dev, B43_PHY_CRS)
+			      & ~B43_PHY_CRS_EN_ALL);
 		b43_phy_write(dev, B43_PHY_ANALOGOVER,
 			      b43_phy_read(dev, B43_PHY_ANALOGOVER)
 			      | 0x0003);
@@ -766,7 +766,7 @@ static void lo_measure_restore(struct b4
 		b43_phy_write(dev, B43_PHY_RFOVER, sav->phy_rfover);
 		b43_phy_write(dev, B43_PHY_RFOVERVAL, sav->phy_rfoverval);
 		b43_phy_write(dev, B43_PHY_BASE(0x3E), sav->phy_base_3E);
-		b43_phy_write(dev, B43_PHY_CRS0, sav->phy_crs0);
+		b43_phy_write(dev, B43_PHY_CRS, sav->phy_crs);
 	}
 	if (b43_has_hardware_pctl(phy)) {
 		tmp = (sav->phy_lo_mask & 0xBFFF);
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c
+++ wireless-2.6/drivers/net/wireless/b43/phy.c
@@ -799,8 +799,8 @@ static void b43_phy_ww(struct b43_wldev 
 	u16 b, curr_s, best_s = 0xFFFF;
 	int i;
 
-	b43_phy_write(dev, B43_PHY_CRS0,
-		b43_phy_read(dev, B43_PHY_CRS0) & ~B43_PHY_CRS0_EN);
+	b43_phy_write(dev, B43_PHY_CRS,
+		b43_phy_read(dev, B43_PHY_CRS) & ~B43_PHY_CRS_EN_ALL);
 	b43_phy_write(dev, B43_PHY_OFDM(0x1B),
 		b43_phy_read(dev, B43_PHY_OFDM(0x1B)) | 0x1000);
 	b43_phy_write(dev, B43_PHY_OFDM(0x82),
@@ -851,8 +851,8 @@ static void b43_phy_ww(struct b43_wldev 
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0E, 0x0011);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0F, 0x0013);
 	b43_phy_write(dev, B43_PHY_OFDM(0x33), 0x5030);
-	b43_phy_write(dev, B43_PHY_CRS0,
-		b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
+	b43_phy_write(dev, B43_PHY_CRS,
+		b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_ALL);
 }
 
 /* Initialize APHY. This is also called for the GPHY in some cases. */
@@ -883,8 +883,8 @@ static void b43_phy_inita(struct b43_wld
 				b43_phy_read(dev, 0x0034) | 0x0001);
 		b43_phy_rssiagc(dev, 0);
 
-		b43_phy_write(dev, B43_PHY_CRS0,
-			b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
+		b43_phy_write(dev, B43_PHY_CRS,
+			b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_ALL);
 
 		b43_radio_init2060(dev);
 
@@ -950,7 +950,7 @@ static void b43_phy_initb2(struct b43_wl
 	b43_phy_write(dev, 0x0026, 0xCC00);
 	if (phy->radio_ver != 0x2050)
 		b43_phy_write(dev, 0x0026, 0xCE00);
-	b43_write16(dev, B43_MMIO_CHANNEL_EXT, 0x1000);
+	b43_write16(dev, B43_MMIO_PHY_TEST, 0x1000);
 	b43_phy_write(dev, 0x002A, 0x88A3);
 	if (phy->radio_ver != 0x2050)
 		b43_phy_write(dev, 0x002A, 0x88C2);
@@ -1001,7 +1001,7 @@ static void b43_phy_initb4(struct b43_wl
 	b43_phy_write(dev, 0x0026, 0xCC00);
 	if (phy->radio_ver == 0x2050)
 		b43_phy_write(dev, 0x0026, 0xCE00);
-	b43_write16(dev, B43_MMIO_CHANNEL_EXT, 0x1100);
+	b43_write16(dev, B43_MMIO_PHY_TEST, 0x1100);
 	b43_phy_write(dev, 0x002A, 0x88A3);
 	if (phy->radio_ver == 0x2050)
 		b43_phy_write(dev, 0x002A, 0x88C2);
@@ -1046,7 +1046,7 @@ static void b43_phy_initb5(struct b43_wl
 					  b43_radio_read16(dev, 0x0051)
 					  | 0x0004);
 		}
-		b43_write16(dev, B43_MMIO_PHY_RADIO, 0x0000);
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG, 0x0000);
 
 		b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) | 0x0100);
 		b43_phy_write(dev, 0x042B, b43_phy_read(dev, 0x042B) | 0x2000);
@@ -1264,7 +1264,7 @@ static void b43_calc_loopback_gain(struc
 	u16 trsw_rx;
 	u16 loop1_outer_done, loop1_inner_done;
 
-	backup_phy[0] = b43_phy_read(dev, B43_PHY_CRS0);
+	backup_phy[0] = b43_phy_read(dev, B43_PHY_CRS);
 	backup_phy[1] = b43_phy_read(dev, B43_PHY_CCKBBANDCFG);
 	backup_phy[2] = b43_phy_read(dev, B43_PHY_RFOVER);
 	backup_phy[3] = b43_phy_read(dev, B43_PHY_RFOVERVAL);
@@ -1287,8 +1287,8 @@ static void b43_calc_loopback_gain(struc
 	backup_radio[1] = b43_radio_read16(dev, 0x43);
 	backup_radio[2] = b43_radio_read16(dev, 0x7A);
 
-	b43_phy_write(dev, B43_PHY_CRS0,
-		      b43_phy_read(dev, B43_PHY_CRS0) & 0x3FFF);
+	b43_phy_write(dev, B43_PHY_CRS,
+		      b43_phy_read(dev, B43_PHY_CRS) & ~B43_PHY_CRS_EN_ALL);
 	b43_phy_write(dev, B43_PHY_CCKBBANDCFG,
 		      b43_phy_read(dev, B43_PHY_CCKBBANDCFG) | 0x8000);
 	b43_phy_write(dev, B43_PHY_RFOVER,
@@ -1448,7 +1448,7 @@ static void b43_calc_loopback_gain(struc
 	udelay(10);
 	b43_phy_write(dev, B43_PHY_RFOVER, backup_phy[2]);
 	b43_phy_write(dev, B43_PHY_RFOVERVAL, backup_phy[3]);
-	b43_phy_write(dev, B43_PHY_CRS0, backup_phy[0]);
+	b43_phy_write(dev, B43_PHY_CRS, backup_phy[0]);
 	b43_phy_write(dev, B43_PHY_CCKBBANDCFG, backup_phy[1]);
 
 	phy->max_lb_gain =
@@ -1570,8 +1570,8 @@ static void b43_phy_initg(struct b43_wld
 	   but OFDM is legal everywhere */
 	if ((dev->dev->bus->chip_id == 0x4306
 	     && dev->dev->bus->chip_package == 2) || 0) {
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0xBFFF);
+		b43_phy_write(dev, B43_PHY_CRS, b43_phy_read(dev, B43_PHY_CRS)
+			      & ~B43_PHY_CRS_EN_0);
 		b43_phy_write(dev, B43_PHY_OFDM(0xC3),
 			      b43_phy_read(dev, B43_PHY_OFDM(0xC3))
 			      & 0x7FFF);
@@ -2332,8 +2332,8 @@ u8 b43_radio_aci_scan(struct b43_wldev *
 	b43_phy_lock(dev, phylock_flags);
 	b43_radio_lock(dev);
 	b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & 0xFFFC);
-	b43_phy_write(dev, B43_PHY_G_CRS,
-		      b43_phy_read(dev, B43_PHY_G_CRS) & 0x7FFF);
+	b43_phy_write(dev, B43_PHY_CRS,
+		      b43_phy_read(dev, B43_PHY_CRS) & ~B43_PHY_CRS_EN_ALL);
 	b43_set_all_gains(dev, 3, 8, 1);
 
 	start = (channel - 5 > 0) ? channel - 5 : 1;
@@ -2347,8 +2347,8 @@ u8 b43_radio_aci_scan(struct b43_wldev *
 	b43_phy_write(dev, 0x0802,
 		      (b43_phy_read(dev, 0x0802) & 0xFFFC) | 0x0003);
 	b43_phy_write(dev, 0x0403, b43_phy_read(dev, 0x0403) & 0xFFF8);
-	b43_phy_write(dev, B43_PHY_G_CRS,
-		      b43_phy_read(dev, B43_PHY_G_CRS) | 0x8000);
+	b43_phy_write(dev, B43_PHY_CRS,
+		      b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_ALL);
 	b43_set_original_gains(dev);
 	for (i = 0; i < 13; i++) {
 		if (!ret[i])
@@ -2593,7 +2593,7 @@ void b43_calc_nrssi_slope(struct b43_wld
 		backup[10] = b43_phy_read(dev, 0x0058);
 		backup[11] = b43_read16(dev, 0x03E2);
 		backup[12] = b43_read16(dev, 0x03E6);
-		backup[13] = b43_read16(dev, B43_MMIO_CHANNEL_EXT);
+		backup[13] = b43_read16(dev, B43_MMIO_PHY_TEST);
 
 		tmp = b43_radio_read16(dev, 0x007A);
 		tmp &= (phy->rev >= 5) ? 0x007F : 0x000F;
@@ -2614,9 +2614,9 @@ void b43_calc_nrssi_slope(struct b43_wld
 		} else if (phy->rev == 0) {
 			b43_write16(dev, 0x03E6, 0x0122);
 		} else {
-			b43_write16(dev, B43_MMIO_CHANNEL_EXT,
+			b43_write16(dev, B43_MMIO_PHY_TEST,
 				    b43_read16(dev,
-					       B43_MMIO_CHANNEL_EXT) & 0x2000);
+					       B43_MMIO_PHY_TEST) & 0x2000);
 		}
 		b43_phy_write(dev, 0x0020, 0x3F3F);
 		b43_phy_write(dev, 0x0015, 0xF330);
@@ -2662,111 +2662,104 @@ void b43_calc_nrssi_slope(struct b43_wld
 		if (phy->radio_rev == 8)
 			b43_calc_nrssi_offset(dev);
 
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      b43_phy_read(dev, B43_PHY_G_CRS) & 0x7FFF);
-		b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & 0xFFFC);
-		backup[7] = b43_read16(dev, 0x03E2);
-		b43_write16(dev, 0x03E2, b43_read16(dev, 0x03E2) | 0x8000);
-		backup[0] = b43_radio_read16(dev, 0x007A);
-		backup[1] = b43_radio_read16(dev, 0x0052);
-		backup[2] = b43_radio_read16(dev, 0x0043);
-		backup[3] = b43_phy_read(dev, 0x0015);
+		b43_phy_write(dev, B43_PHY_CRS,
+			      b43_phy_read(dev, B43_PHY_CRS)
+			       & ~B43_PHY_CRS_EN_ALL);
+		b43_phy_write(dev, B43_PHY_CLASSCTL,
+			      b43_phy_read(dev, B43_PHY_CLASSCTL) &
+			       ~(B43_PHY_CLASSCTL_CCK | B43_PHY_CLASSCTL_OFDM));
+		backup[7] = b43_read16(dev, B43_MMIO_PHY_BBANDCFG);
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG, backup[7] | 0x8000);
+		backup[0] = b43_radio_read16(dev, B43_RADIO_2050_RXCTL0);
+		backup[1] = b43_radio_read16(dev, B43_RADIO_2050_TXCTL1);
+		backup[2] = b43_radio_read16(dev, B43_RADIO_2050_PCTL);
+		backup[3] = b43_phy_read(dev, B43_PHY_PGACTL);
 		backup[4] = b43_phy_read(dev, 0x005A);
 		backup[5] = b43_phy_read(dev, 0x0059);
 		backup[6] = b43_phy_read(dev, 0x0058);
-		backup[8] = b43_read16(dev, 0x03E6);
-		backup[9] = b43_read16(dev, B43_MMIO_CHANNEL_EXT);
-		if (phy->rev >= 3) {
-			backup[10] = b43_phy_read(dev, 0x002E);
-			backup[11] = b43_phy_read(dev, 0x002F);
-			backup[12] = b43_phy_read(dev, 0x080F);
-			backup[13] = b43_phy_read(dev, B43_PHY_G_LO_CONTROL);
-			backup[14] = b43_phy_read(dev, 0x0801);
-			backup[15] = b43_phy_read(dev, 0x0060);
-			backup[16] = b43_phy_read(dev, 0x0014);
-			backup[17] = b43_phy_read(dev, 0x0478);
-			b43_phy_write(dev, 0x002E, 0);
-			b43_phy_write(dev, B43_PHY_G_LO_CONTROL, 0);
-			switch (phy->rev) {
-			case 4:
-			case 6:
-			case 7:
-				b43_phy_write(dev, 0x0478,
-					      b43_phy_read(dev, 0x0478)
-					      | 0x0100);
-				b43_phy_write(dev, 0x0801,
-					      b43_phy_read(dev, 0x0801)
-					      | 0x0040);
-				break;
-			case 3:
-			case 5:
-				b43_phy_write(dev, 0x0801,
-					      b43_phy_read(dev, 0x0801)
-					      & 0xFFBF);
-				break;
-			}
-			b43_phy_write(dev, 0x0060, b43_phy_read(dev, 0x0060)
-				      | 0x0040);
-			b43_phy_write(dev, 0x0014, b43_phy_read(dev, 0x0014)
-				      | 0x0200);
-		}
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x0070);
+		backup[8] = b43_read16(dev, B43_MMIO_PHY0);
+		backup[9] = b43_read16(dev, B43_MMIO_PHY_TEST);
+		if (phy->hardware_power_control) {
+			backup[10] = b43_phy_read(dev, B43_PHY_TXDC_OFFSET1);
+			backup[11] = b43_phy_read(dev, B43_PHY_TXDC_OFFSET2);
+			backup[12] = b43_phy_read(dev, B43_PHY_LO_MASK);
+			backup[13] = b43_phy_read(dev, B43_PHY_LO_CTL);
+			backup[14] = b43_phy_read(dev, B43_PHY_G_CTL);
+			backup[15] = b43_phy_read(dev, B43_PHY_DACCTL);
+			backup[16] = b43_phy_read(dev, B43_PHY_TR_LT2);
+			backup[17] = b43_phy_read(dev, B43_PHY_HPWR_TSSICTL);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET1, 0);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET2, 0);
+			b43_phy_write(dev, B43_PHY_LO_MASK, 0);
+			b43_phy_write(dev, B43_PHY_LO_CTL, 0);
+			b43_phy_write(dev, B43_PHY_HPWR_TSSICTL, 0);
+			b43_phy_write(dev, B43_PHY_G_CTL, 0);
+			b43_phy_write(dev, B43_PHY_DACCTL, 0);
+			b43_phy_write(dev, B43_PHY_TR_LT2, 0);
+		}
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x0070);
 		b43_set_all_gains(dev, 0, 8, 0);
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) & 0x00F7);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   & 0x00F7);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0811,
-				      (b43_phy_read(dev, 0x0811) & 0xFFCF) |
-				      0x0030);
-			b43_phy_write(dev, 0x0812,
-				      (b43_phy_read(dev, 0x0812) & 0xFFCF) |
-				      0x0010);
+			b43_phy_write(dev, B43_PHY_RFOVER,
+				      b43_phy_read(dev, B43_PHY_RFOVER)
+				       | 0x0030);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF) | 0x0010);
 		}
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x0080);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x0080);
 		udelay(20);
 
-		nrssi0 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
+		nrssi0 = (s16)((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (nrssi0 >= 0x0020)
 			nrssi0 -= 0x0040;
 
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) & 0x007F);
-		if (phy->rev >= 2) {
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   & 0x0080);
+		if (phy->analog >= 2) {
 			b43_phy_write(dev, 0x0003, (b43_phy_read(dev, 0x0003)
 						    & 0xFF9F) | 0x0040);
 		}
 
-		b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-			    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
+		b43_write16(dev, B43_MMIO_PHY_TEST,
+			    b43_read16(dev, B43_MMIO_PHY_TEST)
 			    | 0x2000);
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x000F);
-		b43_phy_write(dev, 0x0015, 0xF330);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x000F);
+		b43_phy_write(dev, B43_PHY_PGACTL, 0xF330);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0812,
-				      (b43_phy_read(dev, 0x0812) & 0xFFCF) |
-				      0x0020);
-			b43_phy_write(dev, 0x0811,
-				      (b43_phy_read(dev, 0x0811) & 0xFFCF) |
-				      0x0020);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF) | 0x0020);
+			b43_phy_write(dev, B43_PHY_RFOVER,
+				      (b43_phy_read(dev, B43_PHY_RFOVER)
+				       & 0xFFCF) | 0x0020);
 		}
-
 		b43_set_all_gains(dev, 3, 0, 1);
-		if (phy->radio_rev == 8) {
-			b43_radio_write16(dev, 0x0043, 0x001F);
-		} else {
-			tmp = b43_radio_read16(dev, 0x0052) & 0xFF0F;
-			b43_radio_write16(dev, 0x0052, tmp | 0x0060);
-			tmp = b43_radio_read16(dev, 0x0043) & 0xFFF0;
-			b43_radio_write16(dev, 0x0043, tmp | 0x0009);
+		if (phy->radio_rev == 8)
+			b43_radio_write16(dev, B43_RADIO_2050_PCTL, 0x001F);
+		else {
+			b43_radio_write16(dev, B43_RADIO_2050_TXCTL1,
+					  (b43_radio_read16(dev, B43_RADIO_2050_TXCTL1)
+					   & 0xFF0F) | 0x0060);
+			b43_radio_write16(dev, B43_RADIO_2050_PCTL,
+					  (b43_radio_read16(dev, B43_RADIO_2050_PCTL)
+					   & 0xFFF0) | 0x0009);
 		}
 		b43_phy_write(dev, 0x005A, 0x0480);
 		b43_phy_write(dev, 0x0059, 0x0810);
 		b43_phy_write(dev, 0x0058, 0x000D);
 		udelay(20);
-		nrssi1 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
+		nrssi1 = (s16)((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (nrssi1 >= 0x0020)
 			nrssi1 -= 0x0040;
 		if (nrssi0 == nrssi1)
@@ -2777,40 +2770,43 @@ void b43_calc_nrssi_slope(struct b43_wld
 			phy->nrssi[0] = nrssi1;
 			phy->nrssi[1] = nrssi0;
 		}
-		if (phy->rev >= 3) {
-			b43_phy_write(dev, 0x002E, backup[10]);
-			b43_phy_write(dev, 0x002F, backup[11]);
-			b43_phy_write(dev, 0x080F, backup[12]);
-			b43_phy_write(dev, B43_PHY_G_LO_CONTROL, backup[13]);
-		}
+		if (phy->hardware_power_control) {
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET1, backup[10]);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET2, backup[11]);
+			b43_phy_write(dev, B43_PHY_LO_MASK, backup[12]);
+			b43_phy_write(dev, B43_PHY_LO_CTL, backup[13]);
+		}
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0, backup[0]);
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG, backup[7]);
+		b43_phy_write(dev, B43_PHY_PGACTL, backup[3]);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0812,
-				      b43_phy_read(dev, 0x0812) & 0xFFCF);
-			b43_phy_write(dev, 0x0811,
-				      b43_phy_read(dev, 0x0811) & 0xFFCF);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      b43_phy_read(dev, B43_PHY_RFOVER)
+				       & 0xFFCF);
 		}
-
-		b43_radio_write16(dev, 0x007A, backup[0]);
-		b43_radio_write16(dev, 0x0052, backup[1]);
-		b43_radio_write16(dev, 0x0043, backup[2]);
-		b43_write16(dev, 0x03E2, backup[7]);
-		b43_write16(dev, 0x03E6, backup[8]);
-		b43_write16(dev, B43_MMIO_CHANNEL_EXT, backup[9]);
-		b43_phy_write(dev, 0x0015, backup[3]);
+		b43_write16(dev, B43_MMIO_PHY0, backup[8]);
+		b43_write16(dev, B43_MMIO_PHY_TEST, backup[9]);
+		b43_radio_write16(dev, B43_RADIO_2050_TXCTL1, backup[1]);
+		b43_radio_write16(dev, B43_RADIO_2050_PCTL, backup[2]);
 		b43_phy_write(dev, 0x005A, backup[4]);
 		b43_phy_write(dev, 0x0059, backup[5]);
 		b43_phy_write(dev, 0x0058, backup[6]);
 		b43_synth_pu_workaround(dev, phy->channel);
-		b43_phy_write(dev, 0x0802,
-			      b43_phy_read(dev, 0x0802) | (0x0001 | 0x0002));
+		b43_phy_write(dev, B43_PHY_CLASSCTL,
+			      b43_phy_read(dev, B43_PHY_CLASSCTL)
+			       | (B43_PHY_CLASSCTL_CCK | B43_PHY_CLASSCTL_OFDM));
 		b43_set_original_gains(dev);
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      b43_phy_read(dev, B43_PHY_G_CRS) | 0x8000);
-		if (phy->rev >= 3) {
-			b43_phy_write(dev, 0x0801, backup[14]);
-			b43_phy_write(dev, 0x0060, backup[15]);
-			b43_phy_write(dev, 0x0014, backup[16]);
-			b43_phy_write(dev, 0x0478, backup[17]);
+		b43_phy_write(dev, B43_PHY_CRS,
+			      b43_phy_read(dev, B43_PHY_CRS)
+			       | B43_PHY_CRS_EN_ALL);
+		if (phy->hardware_power_control) {
+			b43_phy_write(dev, B43_PHY_G_CTL, backup[14]);
+			b43_phy_write(dev, B43_PHY_DACCTL, backup[15]);
+			b43_phy_write(dev, B43_PHY_TR_LT2, backup[16]);
+			b43_phy_write(dev, B43_PHY_HPWR_TSSICTL, backup[17]);
 		}
 		b43_nrssi_mem_update(dev);
 		b43_calc_nrssi_threshold(dev);
@@ -3001,9 +2997,9 @@ b43_radio_interference_mitigation_enable
 		if (phy->rev != 1) {
 			b43_phy_write(dev, 0x042B,
 				      b43_phy_read(dev, 0x042B) | 0x0800);
-			b43_phy_write(dev, B43_PHY_G_CRS,
+			b43_phy_write(dev, B43_PHY_CRS,
 				      b43_phy_read(dev,
-						   B43_PHY_G_CRS) & ~0x4000);
+						   B43_PHY_CRS) & ~B43_PHY_CRS_EN_0);
 			break;
 		}
 		radio_stacksave(0x0078);
@@ -3063,7 +3059,7 @@ b43_radio_interference_mitigation_enable
 		phy->aci_enable = 1;
 
 		phy_stacksave(B43_PHY_RADIO_BITFIELD);
-		phy_stacksave(B43_PHY_G_CRS);
+		phy_stacksave(B43_PHY_CRS);
 		if (phy->rev < 2) {
 			phy_stacksave(0x0406);
 		} else {
@@ -3100,8 +3096,8 @@ b43_radio_interference_mitigation_enable
 		b43_phy_write(dev, B43_PHY_RADIO_BITFIELD,
 			      b43_phy_read(dev, B43_PHY_RADIO_BITFIELD)
 			      & ~0x1000);
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      (b43_phy_read(dev, B43_PHY_G_CRS)
+		b43_phy_write(dev, B43_PHY_CRS,
+			      (b43_phy_read(dev, B43_PHY_CRS)
 			       & 0xFFFC) | 0x0002);
 
 		b43_phy_write(dev, 0x0033, 0x0800);
@@ -3203,9 +3199,9 @@ b43_radio_interference_mitigation_disabl
 		if (phy->rev != 1) {
 			b43_phy_write(dev, 0x042B,
 				      b43_phy_read(dev, 0x042B) & ~0x0800);
-			b43_phy_write(dev, B43_PHY_G_CRS,
+			b43_phy_write(dev, B43_PHY_CRS,
 				      b43_phy_read(dev,
-						   B43_PHY_G_CRS) | 0x4000);
+						   B43_PHY_CRS) | B43_PHY_CRS_EN_0);
 			break;
 		}
 		radio_stackrestore(0x0078);
@@ -3217,8 +3213,8 @@ b43_radio_interference_mitigation_disabl
 				      b43_phy_read(dev, B43_PHY_RADIO_BITFIELD)
 				      & ~(1 << 11));
 		}
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      b43_phy_read(dev, B43_PHY_G_CRS) | 0x4000);
+		b43_phy_write(dev, B43_PHY_CRS,
+			      b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_0);
 		phy_stackrestore(0x04A0);
 		phy_stackrestore(0x04A1);
 		phy_stackrestore(0x04A2);
@@ -3238,7 +3234,7 @@ b43_radio_interference_mitigation_disabl
 		phy->aci_enable = 0;
 
 		phy_stackrestore(B43_PHY_RADIO_BITFIELD);
-		phy_stackrestore(B43_PHY_G_CRS);
+		phy_stackrestore(B43_PHY_CRS);
 		phy_stackrestore(0x0033);
 		phy_stackrestore(0x04A3);
 		phy_stackrestore(0x04A9);
@@ -3484,7 +3480,7 @@ struct init2050_saved_values {
 	u16 phy_rfoverval;
 	u16 phy_analogover;
 	u16 phy_analogoverval;
-	u16 phy_crs0;
+	u16 phy_crs;
 	u16 phy_classctl;
 	u16 phy_lo_mask;
 	u16 phy_lo_ctl;
@@ -3523,7 +3519,7 @@ u16 b43_radio_init2050(struct b43_wldev 
 		sav.phy_analogover = b43_phy_read(dev, B43_PHY_ANALOGOVER);
 		sav.phy_analogoverval =
 		    b43_phy_read(dev, B43_PHY_ANALOGOVERVAL);
-		sav.phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);
+		sav.phy_crs = b43_phy_read(dev, B43_PHY_CRS);
 		sav.phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);
 
 		b43_phy_write(dev, B43_PHY_ANALOGOVER,
@@ -3532,8 +3528,8 @@ u16 b43_radio_init2050(struct b43_wldev 
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      b43_phy_read(dev, B43_PHY_ANALOGOVERVAL)
 			      & 0xFFFC);
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0x7FFF);
+		b43_phy_write(dev, B43_PHY_CRS, b43_phy_read(dev, B43_PHY_CRS)
+			      & ~B43_PHY_CRS_EN_ALL);
 		b43_phy_write(dev, B43_PHY_CLASSCTL,
 			      b43_phy_read(dev, B43_PHY_CLASSCTL)
 			      & 0xFFFC);
@@ -3570,8 +3566,8 @@ u16 b43_radio_init2050(struct b43_wldev 
 				      (b43_phy_read(dev, B43_PHY_BASE(0x03))
 				       & 0xFFBF) | 0x40);
 		}
-		b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-			    (b43_read16(dev, B43_MMIO_CHANNEL_EXT) | 0x2000));
+		b43_write16(dev, B43_MMIO_PHY_TEST,
+			    (b43_read16(dev, B43_MMIO_PHY_TEST) | 0x2000));
 	}
 
 	rcc = b43_radio_core_calibration_value(dev);
@@ -3715,15 +3711,15 @@ u16 b43_radio_init2050(struct b43_wldev 
 		b43_phy_write(dev, B43_PHY_BASE(0x30), sav.phy_base_30);
 		b43_write16(dev, 0x3EC, sav.reg_3EC);
 	} else if (phy->gmode) {
-		b43_write16(dev, B43_MMIO_PHY_RADIO,
-			    b43_read16(dev, B43_MMIO_PHY_RADIO)
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG,
+			    b43_read16(dev, B43_MMIO_PHY_BBANDCFG)
 			    & 0x7FFF);
 		b43_phy_write(dev, B43_PHY_RFOVER, sav.phy_rfover);
 		b43_phy_write(dev, B43_PHY_RFOVERVAL, sav.phy_rfoverval);
 		b43_phy_write(dev, B43_PHY_ANALOGOVER, sav.phy_analogover);
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      sav.phy_analogoverval);
-		b43_phy_write(dev, B43_PHY_CRS0, sav.phy_crs0);
+		b43_phy_write(dev, B43_PHY_CRS, sav.phy_crs);
 		b43_phy_write(dev, B43_PHY_CLASSCTL, sav.phy_classctl);
 		if (has_loopback_gain(phy)) {
 			b43_phy_write(dev, B43_PHY_LO_MASK, sav.phy_lo_mask);
@@ -3912,12 +3908,12 @@ int b43_radio_selectchannel(struct b43_w
 			else
 				b43_hf_write(dev,
 					     b43_hf_read(dev) | B43_HF_ACPR);
-			b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-				    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
+			b43_write16(dev, B43_MMIO_PHY_TEST,
+				    b43_read16(dev, B43_MMIO_PHY_TEST)
 				    | (1 << 11));
 		} else {
-			b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-				    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
+			b43_write16(dev, B43_MMIO_PHY_TEST,
+				    b43_read16(dev, B43_MMIO_PHY_TEST)
 				    & 0xF7BF);
 		}
 	}
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h
+++ wireless-2.6/drivers/net/wireless/b43/phy.h
@@ -29,8 +29,9 @@ struct b43_phy;
 #define B43_PHY_LNAHPFCTL		B43_PHY_OFDM(0x1C)	/* LNA/HPF control */
 #define B43_PHY_LPFGAINCTL		B43_PHY_OFDM(0x20)	/* LPF Gain control */
 #define B43_PHY_ADIVRELATED		B43_PHY_OFDM(0x27)	/* FIXME rename */
-#define B43_PHY_CRS0			B43_PHY_OFDM(0x29)	/* Collision resolution signaling */
-#define  B43_PHY_CRS0_EN		0x8000	/* CRS enable */
+#define B43_PHY_CRS			B43_PHY_OFDM(0x29)	/* Collision resolution signaling */
+#define  B43_PHY_CRS_EN_ALL		0x8000			/* CRS enable */
+#define  B43_PHY_CRS_EN_0		0x4000			/* CRS 0 enable */
 #define B43_PHY_PEAK_COUNT		B43_PHY_OFDM(0x30)
 #define B43_PHY_ANTDWELL		B43_PHY_OFDM(0x2B)	/* Antenna dwell */
 #define  B43_PHY_ANTDWELL_AUTODIV1	0x0100	/* Automatic RX diversity start antenna */
@@ -78,11 +79,14 @@ struct b43_phy;
 /* CCK (B) PHY Registers */
 #define B43_PHY_VERSION_CCK		B43_PHY_BASE(0x00)	/* Versioning register for B-PHY */
 #define B43_PHY_CCKBBANDCFG		B43_PHY_BASE(0x01)	/* Contains antenna 0/1 control bit */
+#define B43_PHY_TR_LT2			B43_PHY_BASE(0x14)	/* TR lookup table 2 */
 #define B43_PHY_PGACTL			B43_PHY_BASE(0x15)	/* PGA control */
 #define  B43_PHY_PGACTL_LPF		0x1000	/* Low pass filter (?) */
 #define  B43_PHY_PGACTL_LOWBANDW	0x0040	/* Low bandwidth flag */
 #define  B43_PHY_PGACTL_UNKNOWN		0xEFA0
 #define B43_PHY_FBCTL1			B43_PHY_BASE(0x18)	/* Frequency bandwidth control 1 */
+#define B43_PHY_TXDC_OFFSET1		B43_PHY_BASE(0x2E)
+#define B43_PHY_TXDC_OFFSET2		B43_PHY_BASE(0x2F)
 #define B43_PHY_ITSSI			B43_PHY_BASE(0x29)	/* Idle TSSI */
 #define B43_PHY_LO_LEAKAGE		B43_PHY_BASE(0x2D)	/* Measured LO leakage */
 #define B43_PHY_ENERGY			B43_PHY_BASE(0x33)	/* Energy */
@@ -92,7 +96,10 @@ struct b43_phy;
 #define B43_PHY_RCCALOVER		B43_PHY_BASE(0x78)	/* RC calibration override */
 
 /* Extended G-PHY Registers */
+#define B43_PHY_G_CTL			B43_PHY_EXTG(0x01)	/* G PHY control */
 #define B43_PHY_CLASSCTL		B43_PHY_EXTG(0x02)	/* Classify control */
+#define  B43_PHY_CLASSCTL_CCK		0x0001
+#define  B43_PHY_CLASSCTL_OFDM		0x0002
 #define B43_PHY_GTABCTL			B43_PHY_EXTG(0x03)	/* G-PHY table control (see below) */
 #define  B43_PHY_GTABOFF		0x03FF	/* G-PHY table offset (see below) */
 #define  B43_PHY_GTABNR			0xFC00	/* G-PHY table number (see below) */
Index: wireless-2.6/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
+++ wireless-2.6/drivers/net/wireless/b43/wa.c
@@ -325,8 +325,8 @@ static void b43_wa_crs_ed(struct b43_wld
 
 static void b43_wa_crs_thr(struct b43_wldev *dev)
 {
-	b43_phy_write(dev, B43_PHY_CRS0,
-			(b43_phy_read(dev, B43_PHY_CRS0) & ~0x03C0) | 0xD000);
+	b43_phy_write(dev, B43_PHY_CRS,
+			(b43_phy_read(dev, B43_PHY_CRS) & ~0x03C0) | 0xD000);
 }
 
 static void b43_wa_crs_blank(struct b43_wldev *dev)


-- 
Ciao
Stefano


From proski at gnu.org  Thu Nov 29 18:11:49 2007
From: proski at gnu.org (Pavel Roskin)
Date: Thu, 29 Nov 2007 12:11:49 -0500
Subject: Off-line for now
In-Reply-To: <474EC250.8060604@lwfinger.net>
References: <474EC250.8060604@lwfinger.net>
Message-ID: <1196356309.26804.5.camel@dv>


On Thu, 2007-11-29 at 07:44 -0600, Larry Finger wrote:
> Today is the day I start my winter migration to a warmer clime. Until April, my full-time access to 
> a broadband line is limited, which is the reason I resigned as maintainer for bcm43xx and b43legacy.
> 
> I will not be leaving the bcm43xx community completely as I have joined the reverse engineering 
> group.

Larry, I think it's a very good decision after you put the driver on the
firm foundation of mac80211.  Better understanding of the hardware is
essential for further improvements.  Good luck with your migration and
with reverse engineering!

> In fact, my BCM4311 has higher throughput with the b43 driver than it 
> does when I'm running Windows (Yes, my machine does dual-boot, but
> that is mainly for testing!).

That's impressive indeed.  I hope it would be true for 4318, and
eventually for 4328.

-- 
Regards,
Pavel Roskin


From mb at bu3sch.de  Thu Nov 29 19:58:45 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 29 Nov 2007 19:58:45 +0100
Subject: [PATCH] b43: Fix radio LED problem
In-Reply-To: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>
References: <474dfe58.85Rcj/BwOPxQm8eE%Larry.Finger@lwfinger.net>
Message-ID: <200711291958.45631.mb@bu3sch.de>

On Thursday 29 November 2007 00:48:40 Larry Finger wrote:

> Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
> +++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
> @@ -60,8 +60,12 @@ static void b43_rfkill_poll(struct input
>  	}
>  	mutex_unlock(&wl->mutex);
>  
> -	if (unlikely(report_change))
> -		input_report_key(poll_dev->input, KEY_WLAN, enabled);
> +	/* send the radio switch event to the system - note both a key press
> +	 * and a release are required */

Ok, nice. Didn't know that.

> +	if (unlikely(report_change)) {
> +		input_report_key(poll_dev->input, KEY_WLAN, 1);
> +		input_report_key(poll_dev->input, KEY_WLAN, 0);
> +	}
>  }
>  
>  /* Called when the RFKILL toggled in software. */
> @@ -133,6 +137,12 @@ void b43_rfkill_init(struct b43_wldev *d
>  	rfk->poll_dev->poll = b43_rfkill_poll;
>  	rfk->poll_dev->poll_interval = 1000; /* msecs */
>  
> +	rfk->poll_dev->input->name = rfk->name;
> +	rfk->poll_dev->input->id.bustype = BUS_HOST;
> +	rfk->poll_dev->input->id.vendor = dev->dev->bus->boardinfo.vendor;
> +	rfk->poll_dev->input->evbit[0] = BIT(EV_KEY);
> +	set_bit(KEY_WLAN, rfk->poll_dev->input->keybit);
> +
>  	err = rfkill_register(rfk->rfkill);
>  	if (err)
>  		goto err_free_polldev;
> Index: wireless-2.6/drivers/net/wireless/b43/main.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/main.c
> +++ wireless-2.6/drivers/net/wireless/b43/main.c
> @@ -2156,7 +2156,6 @@ static void b43_mgmtframe_txantenna(stru
>  static void b43_chip_exit(struct b43_wldev *dev)
>  {
>  	b43_radio_turn_off(dev, 1);
> -	b43_leds_exit(dev);
>  	b43_gpio_cleanup(dev);
>  	/* firmware is released later */
>  }
> @@ -2184,11 +2183,10 @@ static int b43_chip_init(struct b43_wlde
>  	err = b43_gpio_init(dev);
>  	if (err)
>  		goto out;	/* firmware is released later */
> -	b43_leds_init(dev);
>  
>  	err = b43_upload_initvals(dev);
>  	if (err)
> -		goto err_leds_exit;
> +		goto err_gpio_clean;
>  	b43_radio_turn_on(dev);
>  
>  	b43_write16(dev, 0x03E6, 0x0000);
> @@ -2267,8 +2265,7 @@ out:
>  
>  err_radio_off:
>  	b43_radio_turn_off(dev, 1);
> -err_leds_exit:
> -	b43_leds_exit(dev);
> +err_gpio_clean:
>  	b43_gpio_cleanup(dev);
>  	return err;
>  }
> @@ -2703,7 +2700,8 @@ static int b43_antenna_from_ieee80211(u8
>  static int b43_op_config(struct ieee80211_hw *hw, struct ieee80211_conf *conf)
>  {
>  	struct b43_wl *wl = hw_to_b43_wl(hw);
> -	struct b43_wldev *dev;
> +	struct b43_rfkill *rfk = &(wl->rfkill);
> +	struct b43_wldev *uninitialized_var(dev);
>  	struct b43_phy *phy;
>  	unsigned long flags;
>  	unsigned int new_phymode = 0xFFFF;
> @@ -2802,6 +2800,13 @@ static int b43_op_config(struct ieee8021
>        out_unlock_mutex:
>  	mutex_unlock(&wl->mutex);
>  
> +	/* if a LED is devoted to the radio and the switch is on, send
> +	 * KEY_WLAN press/release keystrokes */
> +	if (!err && dev->radio_hw_enable && &dev->led_radio) {
                                            ^^^^^^^^^^^^^^^
This condition is always true.

> +		input_report_key(rfk->poll_dev->input, KEY_WLAN, 1);
> +		input_report_key(rfk->poll_dev->input, KEY_WLAN, 0);
> +	}
> +

Anyway, sending a key event here seems pretty bogus. The comment
doesn't really say anything useful why this is needed.

>  	return err;
>  }
>  
> @@ -3284,9 +3289,7 @@ static void b43_wireless_core_exit(struc
>  		return;
>  	b43_set_status(dev, B43_STAT_UNINIT);
>  
> -	mutex_unlock(&dev->wl->mutex);
> -	b43_rfkill_exit(dev);
> -	mutex_lock(&dev->wl->mutex);
> +	b43_leds_exit(dev);
>  
>  	b43_rng_exit(dev->wl);
>  	b43_pio_free(dev);
> @@ -3409,8 +3412,8 @@ static int b43_wireless_core_init(struct
>  	memset(wl->mac_addr, 0, ETH_ALEN);
>  	b43_upload_card_macaddress(dev);
>  	b43_security_init(dev);
> -	b43_rfkill_init(dev);
>  	b43_rng_init(wl);
> +	b43_leds_init(dev);
>  
>  	b43_set_status(dev, B43_STAT_INITIALIZED);
>  
> @@ -3503,6 +3506,7 @@ static int b43_op_start(struct ieee80211
>  	int did_init = 0;
>  	int err = 0;
>  
> +	b43_rfkill_init(dev);

Init rfkill _after_ the device is up.

>  	mutex_lock(&wl->mutex);
>  
>  	if (b43_status(dev) < B43_STAT_INITIALIZED) {
> @@ -3537,6 +3541,7 @@ static void b43_op_stop(struct ieee80211
>  		b43_wireless_core_stop(dev);
>  	b43_wireless_core_exit(dev);
>  	mutex_unlock(&wl->mutex);
> +	b43_rfkill_exit(dev);

Exit rfkill before the device is going down.

>  }
>  
>  static int b43_op_set_retry_limit(struct ieee80211_hw *hw,
> Index: wireless-2.6/drivers/net/wireless/b43/leds.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/leds.c
> +++ wireless-2.6/drivers/net/wireless/b43/leds.c
> @@ -232,4 +232,5 @@ void b43_leds_exit(struct b43_wldev *dev
>  	b43_unregister_led(&dev->led_tx);
>  	b43_unregister_led(&dev->led_rx);
>  	b43_unregister_led(&dev->led_assoc);
> +	b43_unregister_led(&dev->led_radio);
>  }
> 
> 



-- 
Greetings Michael.


From stefano.brivio at polimi.it  Thu Nov 29 21:51:39 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Thu, 29 Nov 2007 21:51:39 +0100
Subject: [RFT] [PATCH v3] b43: fix calc_nrssi_slope
In-Reply-To: <20071129163449.326e592e@morte>
References: <20071129043957.739b4d3f@morte>
	<20071129163449.326e592e@morte>
Message-ID: <20071129215139.60ae663a@morte>

Fix calc_nrssi_slope() which caused PHY TX errors on devices containing a
802.11a PHY. The code is synced to v4 specs and relevant registers are
renamed accordingly.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

It looks like I got confused by a comment and used
phy->hardware_power_control instead of b43_has_hardware_pctl() in order to
check whether hardware based power control is enabled. Michael, I think
that this comment:

	/* Hardware Power Control enabled? */
	bool hardware_power_control;

should at least be amended ("enabled by userspace" maybe would be better).
But it's obviously up to you. Here comes the correct patch.

---

Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c
+++ wireless-2.6/drivers/net/wireless/b43/phy.c
@@ -2664,77 +2664,68 @@ void b43_calc_nrssi_slope(struct b43_wld
 			b43_calc_nrssi_offset(dev);
 
 		b43_phy_write(dev, B43_PHY_CRS,
-			      b43_phy_read(dev, B43_PHY_CRS) & 0x7FFF);
-		b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & 0xFFFC);
-		backup[7] = b43_read16(dev, 0x03E2);
-		b43_write16(dev, 0x03E2, b43_read16(dev, 0x03E2) | 0x8000);
-		backup[0] = b43_radio_read16(dev, 0x007A);
-		backup[1] = b43_radio_read16(dev, 0x0052);
-		backup[2] = b43_radio_read16(dev, 0x0043);
-		backup[3] = b43_phy_read(dev, 0x0015);
+			      b43_phy_read(dev, B43_PHY_CRS)
+			       & ~B43_PHY_CRS_EN_ALL);
+		b43_phy_write(dev, B43_PHY_CLASSCTL,
+			      b43_phy_read(dev, B43_PHY_CLASSCTL) &
+			       ~(B43_PHY_CLASSCTL_CCK | B43_PHY_CLASSCTL_OFDM));
+		backup[7] = b43_read16(dev, B43_MMIO_PHY_BBANDCFG);
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG, backup[7] | 0x8000);
+		backup[0] = b43_radio_read16(dev, B43_RADIO_2050_RXCTL0);
+		backup[1] = b43_radio_read16(dev, B43_RADIO_2050_TXCTL1);
+		backup[2] = b43_radio_read16(dev, B43_RADIO_2050_PCTL);
+		backup[3] = b43_phy_read(dev, B43_PHY_PGACTL);
 		backup[4] = b43_phy_read(dev, 0x005A);
 		backup[5] = b43_phy_read(dev, 0x0059);
 		backup[6] = b43_phy_read(dev, 0x0058);
-		backup[8] = b43_read16(dev, 0x03E6);
+		backup[8] = b43_read16(dev, B43_MMIO_PHY0);
 		backup[9] = b43_read16(dev, B43_MMIO_PHY_TEST);
-		if (phy->rev >= 3) {
-			backup[10] = b43_phy_read(dev, 0x002E);
-			backup[11] = b43_phy_read(dev, 0x002F);
-			backup[12] = b43_phy_read(dev, 0x080F);
+		if (phy->pctl_en) {
+			backup[10] = b43_phy_read(dev, B43_PHY_TXDC_OFFSET1);
+			backup[11] = b43_phy_read(dev, B43_PHY_TXDC_OFFSET2);
+			backup[12] = b43_phy_read(dev, B43_PHY_LO_MASK);
 			backup[13] = b43_phy_read(dev, B43_PHY_LO_CTL);
-			backup[14] = b43_phy_read(dev, 0x0801);
-			backup[15] = b43_phy_read(dev, 0x0060);
-			backup[16] = b43_phy_read(dev, 0x0014);
-			backup[17] = b43_phy_read(dev, 0x0478);
-			b43_phy_write(dev, 0x002E, 0);
+			backup[14] = b43_phy_read(dev, B43_PHY_G_CTL);
+			backup[15] = b43_phy_read(dev, B43_PHY_DACCTL);
+			backup[16] = b43_phy_read(dev, B43_PHY_TR_LT2);
+			backup[17] = b43_phy_read(dev, B43_PHY_HPWR_TSSICTL);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET1, 0);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET2, 0);
+			b43_phy_write(dev, B43_PHY_LO_MASK, 0);
 			b43_phy_write(dev, B43_PHY_LO_CTL, 0);
-			switch (phy->rev) {
-			case 4:
-			case 6:
-			case 7:
-				b43_phy_write(dev, 0x0478,
-					      b43_phy_read(dev, 0x0478)
-					      | 0x0100);
-				b43_phy_write(dev, 0x0801,
-					      b43_phy_read(dev, 0x0801)
-					      | 0x0040);
-				break;
-			case 3:
-			case 5:
-				b43_phy_write(dev, 0x0801,
-					      b43_phy_read(dev, 0x0801)
-					      & 0xFFBF);
-				break;
-			}
-			b43_phy_write(dev, 0x0060, b43_phy_read(dev, 0x0060)
-				      | 0x0040);
-			b43_phy_write(dev, 0x0014, b43_phy_read(dev, 0x0014)
-				      | 0x0200);
-		}
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x0070);
+			b43_phy_write(dev, B43_PHY_HPWR_TSSICTL, 0);
+			b43_phy_write(dev, B43_PHY_G_CTL, 0);
+			b43_phy_write(dev, B43_PHY_DACCTL, 0);
+			b43_phy_write(dev, B43_PHY_TR_LT2, 0);
+		}
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x0070);
 		b43_set_all_gains(dev, 0, 8, 0);
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) & 0x00F7);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   & 0x00F7);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0811,
-				      (b43_phy_read(dev, 0x0811) & 0xFFCF) |
-				      0x0030);
-			b43_phy_write(dev, 0x0812,
-				      (b43_phy_read(dev, 0x0812) & 0xFFCF) |
-				      0x0010);
+			b43_phy_write(dev, B43_PHY_RFOVER,
+				      b43_phy_read(dev, B43_PHY_RFOVER)
+				       | 0x0030);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF) | 0x0010);
 		}
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x0080);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x0080);
 		udelay(20);
 
-		nrssi0 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
+		nrssi0 = (s16)((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (nrssi0 >= 0x0020)
 			nrssi0 -= 0x0040;
 
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) & 0x007F);
-		if (phy->rev >= 2) {
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   & 0x0080);
+		if (phy->analog >= 2) {
 			b43_phy_write(dev, 0x0003, (b43_phy_read(dev, 0x0003)
 						    & 0xFF9F) | 0x0040);
 		}
@@ -2742,32 +2733,34 @@ void b43_calc_nrssi_slope(struct b43_wld
 		b43_write16(dev, B43_MMIO_PHY_TEST,
 			    b43_read16(dev, B43_MMIO_PHY_TEST)
 			    | 0x2000);
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x000F);
-		b43_phy_write(dev, 0x0015, 0xF330);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x000F);
+		b43_phy_write(dev, B43_PHY_PGACTL, 0xF330);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0812,
-				      (b43_phy_read(dev, 0x0812) & 0xFFCF) |
-				      0x0020);
-			b43_phy_write(dev, 0x0811,
-				      (b43_phy_read(dev, 0x0811) & 0xFFCF) |
-				      0x0020);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF) | 0x0020);
+			b43_phy_write(dev, B43_PHY_RFOVER,
+				      (b43_phy_read(dev, B43_PHY_RFOVER)
+				       & 0xFFCF) | 0x0020);
 		}
-
 		b43_set_all_gains(dev, 3, 0, 1);
-		if (phy->radio_rev == 8) {
-			b43_radio_write16(dev, 0x0043, 0x001F);
-		} else {
-			tmp = b43_radio_read16(dev, 0x0052) & 0xFF0F;
-			b43_radio_write16(dev, 0x0052, tmp | 0x0060);
-			tmp = b43_radio_read16(dev, 0x0043) & 0xFFF0;
-			b43_radio_write16(dev, 0x0043, tmp | 0x0009);
+		if (phy->radio_rev == 8)
+			b43_radio_write16(dev, B43_RADIO_2050_PCTL, 0x001F);
+		else {
+			b43_radio_write16(dev, B43_RADIO_2050_TXCTL1,
+					  (b43_radio_read16(dev, B43_RADIO_2050_TXCTL1)
+					   & 0xFF0F) | 0x0060);
+			b43_radio_write16(dev, B43_RADIO_2050_PCTL,
+					  (b43_radio_read16(dev, B43_RADIO_2050_PCTL)
+					   & 0xFFF0) | 0x0009);
 		}
 		b43_phy_write(dev, 0x005A, 0x0480);
 		b43_phy_write(dev, 0x0059, 0x0810);
 		b43_phy_write(dev, 0x0058, 0x000D);
 		udelay(20);
-		nrssi1 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
+		nrssi1 = (s16)((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (nrssi1 >= 0x0020)
 			nrssi1 -= 0x0040;
 		if (nrssi0 == nrssi1)
@@ -2778,40 +2771,43 @@ void b43_calc_nrssi_slope(struct b43_wld
 			phy->nrssi[0] = nrssi1;
 			phy->nrssi[1] = nrssi0;
 		}
-		if (phy->rev >= 3) {
-			b43_phy_write(dev, 0x002E, backup[10]);
-			b43_phy_write(dev, 0x002F, backup[11]);
-			b43_phy_write(dev, 0x080F, backup[12]);
+		if (phy->pctl_en) {
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET1, backup[10]);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET2, backup[11]);
+			b43_phy_write(dev, B43_PHY_LO_MASK, backup[12]);
 			b43_phy_write(dev, B43_PHY_LO_CTL, backup[13]);
 		}
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0, backup[0]);
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG, backup[7]);
+		b43_phy_write(dev, B43_PHY_PGACTL, backup[3]);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0812,
-				      b43_phy_read(dev, 0x0812) & 0xFFCF);
-			b43_phy_write(dev, 0x0811,
-				      b43_phy_read(dev, 0x0811) & 0xFFCF);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      b43_phy_read(dev, B43_PHY_RFOVER)
+				       & 0xFFCF);
 		}
-
-		b43_radio_write16(dev, 0x007A, backup[0]);
-		b43_radio_write16(dev, 0x0052, backup[1]);
-		b43_radio_write16(dev, 0x0043, backup[2]);
-		b43_write16(dev, 0x03E2, backup[7]);
-		b43_write16(dev, 0x03E6, backup[8]);
+		b43_write16(dev, B43_MMIO_PHY0, backup[8]);
 		b43_write16(dev, B43_MMIO_PHY_TEST, backup[9]);
-		b43_phy_write(dev, 0x0015, backup[3]);
+		b43_radio_write16(dev, B43_RADIO_2050_TXCTL1, backup[1]);
+		b43_radio_write16(dev, B43_RADIO_2050_PCTL, backup[2]);
 		b43_phy_write(dev, 0x005A, backup[4]);
 		b43_phy_write(dev, 0x0059, backup[5]);
 		b43_phy_write(dev, 0x0058, backup[6]);
 		b43_synth_pu_workaround(dev, phy->channel);
-		b43_phy_write(dev, 0x0802,
-			      b43_phy_read(dev, 0x0802) | (0x0001 | 0x0002));
+		b43_phy_write(dev, B43_PHY_CLASSCTL,
+			      b43_phy_read(dev, B43_PHY_CLASSCTL)
+			       | (B43_PHY_CLASSCTL_CCK | B43_PHY_CLASSCTL_OFDM));
 		b43_set_original_gains(dev);
 		b43_phy_write(dev, B43_PHY_CRS,
-			      b43_phy_read(dev, B43_PHY_CRS) | 0x8000);
-		if (phy->rev >= 3) {
-			b43_phy_write(dev, 0x0801, backup[14]);
-			b43_phy_write(dev, 0x0060, backup[15]);
-			b43_phy_write(dev, 0x0014, backup[16]);
-			b43_phy_write(dev, 0x0478, backup[17]);
+			      b43_phy_read(dev, B43_PHY_CRS)
+			       | B43_PHY_CRS_EN_ALL);
+		if (phy->pctl_en) {
+			b43_phy_write(dev, B43_PHY_G_CTL, backup[14]);
+			b43_phy_write(dev, B43_PHY_DACCTL, backup[15]);
+			b43_phy_write(dev, B43_PHY_TR_LT2, backup[16]);
+			b43_phy_write(dev, B43_PHY_HPWR_TSSICTL, backup[17]);
 		}
 		b43_nrssi_mem_update(dev);
 		b43_calc_nrssi_threshold(dev);



-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Thu Nov 29 22:06:54 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Thu, 29 Nov 2007 22:06:54 +0100
Subject: [RFT] [PATCH v4] b43: fix calc_nrssi_slope
In-Reply-To: <20071129215139.60ae663a@morte>
References: <20071129043957.739b4d3f@morte> <20071129163449.326e592e@morte>
	<20071129215139.60ae663a@morte>
Message-ID: <20071129220654.6c0c0d35@morte>

Fix calc_nrssi_slope() which caused PHY TX errors on devices containing a
802.11a PHY. The code is synced to v4 specs and relevant registers are
renamed accordingly.


Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>

---

Sorry, I inlined the wrong file. Hope this is the last retry. :)

---

Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h
+++ wireless-2.6/drivers/net/wireless/b43/b43.h
@@ -72,11 +72,11 @@
 #define B43_MMIO_PIO4_BASE		0x330
 
 #define B43_MMIO_PHY_VER		0x3E0
-#define B43_MMIO_PHY_RADIO		0x3E2
+#define B43_MMIO_PHY_BBANDCFG		0x3E2
 #define B43_MMIO_PHY0			0x3E6
 #define B43_MMIO_ANTENNA		0x3E8
 #define B43_MMIO_CHANNEL		0x3F0
-#define B43_MMIO_CHANNEL_EXT		0x3F4
+#define B43_MMIO_PHY_TEST		0x3F4
 #define B43_MMIO_RADIO_CONTROL		0x3F6
 #define B43_MMIO_RADIO_DATA_HIGH	0x3F8
 #define B43_MMIO_RADIO_DATA_LOW		0x3FA
@@ -278,20 +278,20 @@ enum {
 #define B43_PHY_ILT_A_CTRL		0x0072
 #define B43_PHY_ILT_A_DATA1		0x0073
 #define B43_PHY_ILT_A_DATA2		0x0074
-#define B43_PHY_G_LO_CONTROL		0x0810
 #define B43_PHY_ILT_G_CTRL		0x0472
 #define B43_PHY_ILT_G_DATA1		0x0473
 #define B43_PHY_ILT_G_DATA2		0x0474
 #define B43_PHY_A_PCTL			0x007B
 #define B43_PHY_G_PCTL			0x0029
-#define B43_PHY_A_CRS			0x0029
 #define B43_PHY_RADIO_BITFIELD		0x0401
-#define B43_PHY_G_CRS			0x0429
 #define B43_PHY_NRSSILT_CTRL		0x0803
 #define B43_PHY_NRSSILT_DATA		0x0804
 
 /* RadioRegisters */
 #define B43_RADIOCTL_ID			0x01
+#define B43_RADIO_2050_RXCTL0		0x007A
+#define B43_RADIO_2050_TXCTL1		0x0052
+#define B43_RADIO_2050_PCTL		0x0043
 
 /* MAC Control bitfield */
 #define B43_MACCTL_ENABLED		0x00000001	/* MAC Enabled */
Index: wireless-2.6/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/lo.c
+++ wireless-2.6/drivers/net/wireless/b43/lo.c
@@ -563,7 +563,7 @@ struct lo_g_saved_values {
 	u16 phy_rfoverval;
 	u16 phy_classctl;
 	u16 phy_base_3E;
-	u16 phy_crs0;
+	u16 phy_crs;
 	u16 phy_pgactl;
 	u16 phy_base_2A;
 	u16 phy_syncctl;
@@ -619,13 +619,13 @@ static void lo_measure_setup(struct b43_
 		sav->phy_rfoverval = b43_phy_read(dev, B43_PHY_RFOVERVAL);
 		sav->phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);
 		sav->phy_base_3E = b43_phy_read(dev, B43_PHY_BASE(0x3E));
-		sav->phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);
+		sav->phy_crs = b43_phy_read(dev, B43_PHY_CRS);
 
 		b43_phy_write(dev, B43_PHY_CLASSCTL,
 			      b43_phy_read(dev, B43_PHY_CLASSCTL)
 			      & 0xFFFC);
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0x7FFF);
+		b43_phy_write(dev, B43_PHY_CRS, b43_phy_read(dev, B43_PHY_CRS)
+			      & ~B43_PHY_CRS_EN_ALL);
 		b43_phy_write(dev, B43_PHY_ANALOGOVER,
 			      b43_phy_read(dev, B43_PHY_ANALOGOVER)
 			      | 0x0003);
@@ -766,7 +766,7 @@ static void lo_measure_restore(struct b4
 		b43_phy_write(dev, B43_PHY_RFOVER, sav->phy_rfover);
 		b43_phy_write(dev, B43_PHY_RFOVERVAL, sav->phy_rfoverval);
 		b43_phy_write(dev, B43_PHY_BASE(0x3E), sav->phy_base_3E);
-		b43_phy_write(dev, B43_PHY_CRS0, sav->phy_crs0);
+		b43_phy_write(dev, B43_PHY_CRS, sav->phy_crs);
 	}
 	if (b43_has_hardware_pctl(phy)) {
 		tmp = (sav->phy_lo_mask & 0xBFFF);
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c
+++ wireless-2.6/drivers/net/wireless/b43/phy.c
@@ -799,8 +799,8 @@ static void b43_phy_ww(struct b43_wldev 
 	u16 b, curr_s, best_s = 0xFFFF;
 	int i;
 
-	b43_phy_write(dev, B43_PHY_CRS0,
-		b43_phy_read(dev, B43_PHY_CRS0) & ~B43_PHY_CRS0_EN);
+	b43_phy_write(dev, B43_PHY_CRS,
+		b43_phy_read(dev, B43_PHY_CRS) & ~B43_PHY_CRS_EN_ALL);
 	b43_phy_write(dev, B43_PHY_OFDM(0x1B),
 		b43_phy_read(dev, B43_PHY_OFDM(0x1B)) | 0x1000);
 	b43_phy_write(dev, B43_PHY_OFDM(0x82),
@@ -851,8 +851,8 @@ static void b43_phy_ww(struct b43_wldev 
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0E, 0x0011);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 0x0F, 0x0013);
 	b43_phy_write(dev, B43_PHY_OFDM(0x33), 0x5030);
-	b43_phy_write(dev, B43_PHY_CRS0,
-		b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
+	b43_phy_write(dev, B43_PHY_CRS,
+		b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_ALL);
 }
 
 /* Initialize APHY. This is also called for the GPHY in some cases. */
@@ -883,8 +883,8 @@ static void b43_phy_inita(struct b43_wld
 				b43_phy_read(dev, 0x0034) | 0x0001);
 		b43_phy_rssiagc(dev, 0);
 
-		b43_phy_write(dev, B43_PHY_CRS0,
-			b43_phy_read(dev, B43_PHY_CRS0) | B43_PHY_CRS0_EN);
+		b43_phy_write(dev, B43_PHY_CRS,
+			b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_ALL);
 
 		b43_radio_init2060(dev);
 
@@ -950,7 +950,7 @@ static void b43_phy_initb2(struct b43_wl
 	b43_phy_write(dev, 0x0026, 0xCC00);
 	if (phy->radio_ver != 0x2050)
 		b43_phy_write(dev, 0x0026, 0xCE00);
-	b43_write16(dev, B43_MMIO_CHANNEL_EXT, 0x1000);
+	b43_write16(dev, B43_MMIO_PHY_TEST, 0x1000);
 	b43_phy_write(dev, 0x002A, 0x88A3);
 	if (phy->radio_ver != 0x2050)
 		b43_phy_write(dev, 0x002A, 0x88C2);
@@ -1001,7 +1001,7 @@ static void b43_phy_initb4(struct b43_wl
 	b43_phy_write(dev, 0x0026, 0xCC00);
 	if (phy->radio_ver == 0x2050)
 		b43_phy_write(dev, 0x0026, 0xCE00);
-	b43_write16(dev, B43_MMIO_CHANNEL_EXT, 0x1100);
+	b43_write16(dev, B43_MMIO_PHY_TEST, 0x1100);
 	b43_phy_write(dev, 0x002A, 0x88A3);
 	if (phy->radio_ver == 0x2050)
 		b43_phy_write(dev, 0x002A, 0x88C2);
@@ -1046,7 +1046,7 @@ static void b43_phy_initb5(struct b43_wl
 					  b43_radio_read16(dev, 0x0051)
 					  | 0x0004);
 		}
-		b43_write16(dev, B43_MMIO_PHY_RADIO, 0x0000);
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG, 0x0000);
 
 		b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) | 0x0100);
 		b43_phy_write(dev, 0x042B, b43_phy_read(dev, 0x042B) | 0x2000);
@@ -1264,7 +1264,7 @@ static void b43_calc_loopback_gain(struc
 	u16 trsw_rx;
 	u16 loop1_outer_done, loop1_inner_done;
 
-	backup_phy[0] = b43_phy_read(dev, B43_PHY_CRS0);
+	backup_phy[0] = b43_phy_read(dev, B43_PHY_CRS);
 	backup_phy[1] = b43_phy_read(dev, B43_PHY_CCKBBANDCFG);
 	backup_phy[2] = b43_phy_read(dev, B43_PHY_RFOVER);
 	backup_phy[3] = b43_phy_read(dev, B43_PHY_RFOVERVAL);
@@ -1287,8 +1287,8 @@ static void b43_calc_loopback_gain(struc
 	backup_radio[1] = b43_radio_read16(dev, 0x43);
 	backup_radio[2] = b43_radio_read16(dev, 0x7A);
 
-	b43_phy_write(dev, B43_PHY_CRS0,
-		      b43_phy_read(dev, B43_PHY_CRS0) & 0x3FFF);
+	b43_phy_write(dev, B43_PHY_CRS,
+		      b43_phy_read(dev, B43_PHY_CRS) & ~B43_PHY_CRS_EN_ALL);
 	b43_phy_write(dev, B43_PHY_CCKBBANDCFG,
 		      b43_phy_read(dev, B43_PHY_CCKBBANDCFG) | 0x8000);
 	b43_phy_write(dev, B43_PHY_RFOVER,
@@ -1448,7 +1448,7 @@ static void b43_calc_loopback_gain(struc
 	udelay(10);
 	b43_phy_write(dev, B43_PHY_RFOVER, backup_phy[2]);
 	b43_phy_write(dev, B43_PHY_RFOVERVAL, backup_phy[3]);
-	b43_phy_write(dev, B43_PHY_CRS0, backup_phy[0]);
+	b43_phy_write(dev, B43_PHY_CRS, backup_phy[0]);
 	b43_phy_write(dev, B43_PHY_CCKBBANDCFG, backup_phy[1]);
 
 	phy->max_lb_gain =
@@ -1570,8 +1570,8 @@ static void b43_phy_initg(struct b43_wld
 	   but OFDM is legal everywhere */
 	if ((dev->dev->bus->chip_id == 0x4306
 	     && dev->dev->bus->chip_package == 2) || 0) {
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0xBFFF);
+		b43_phy_write(dev, B43_PHY_CRS, b43_phy_read(dev, B43_PHY_CRS)
+			      & ~B43_PHY_CRS_EN_0);
 		b43_phy_write(dev, B43_PHY_OFDM(0xC3),
 			      b43_phy_read(dev, B43_PHY_OFDM(0xC3))
 			      & 0x7FFF);
@@ -2332,8 +2332,8 @@ u8 b43_radio_aci_scan(struct b43_wldev *
 	b43_phy_lock(dev, phylock_flags);
 	b43_radio_lock(dev);
 	b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & 0xFFFC);
-	b43_phy_write(dev, B43_PHY_G_CRS,
-		      b43_phy_read(dev, B43_PHY_G_CRS) & 0x7FFF);
+	b43_phy_write(dev, B43_PHY_CRS,
+		      b43_phy_read(dev, B43_PHY_CRS) & ~B43_PHY_CRS_EN_ALL);
 	b43_set_all_gains(dev, 3, 8, 1);
 
 	start = (channel - 5 > 0) ? channel - 5 : 1;
@@ -2347,8 +2347,8 @@ u8 b43_radio_aci_scan(struct b43_wldev *
 	b43_phy_write(dev, 0x0802,
 		      (b43_phy_read(dev, 0x0802) & 0xFFFC) | 0x0003);
 	b43_phy_write(dev, 0x0403, b43_phy_read(dev, 0x0403) & 0xFFF8);
-	b43_phy_write(dev, B43_PHY_G_CRS,
-		      b43_phy_read(dev, B43_PHY_G_CRS) | 0x8000);
+	b43_phy_write(dev, B43_PHY_CRS,
+		      b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_ALL);
 	b43_set_original_gains(dev);
 	for (i = 0; i < 13; i++) {
 		if (!ret[i])
@@ -2593,7 +2593,7 @@ void b43_calc_nrssi_slope(struct b43_wld
 		backup[10] = b43_phy_read(dev, 0x0058);
 		backup[11] = b43_read16(dev, 0x03E2);
 		backup[12] = b43_read16(dev, 0x03E6);
-		backup[13] = b43_read16(dev, B43_MMIO_CHANNEL_EXT);
+		backup[13] = b43_read16(dev, B43_MMIO_PHY_TEST);
 
 		tmp = b43_radio_read16(dev, 0x007A);
 		tmp &= (phy->rev >= 5) ? 0x007F : 0x000F;
@@ -2614,9 +2614,9 @@ void b43_calc_nrssi_slope(struct b43_wld
 		} else if (phy->rev == 0) {
 			b43_write16(dev, 0x03E6, 0x0122);
 		} else {
-			b43_write16(dev, B43_MMIO_CHANNEL_EXT,
+			b43_write16(dev, B43_MMIO_PHY_TEST,
 				    b43_read16(dev,
-					       B43_MMIO_CHANNEL_EXT) & 0x2000);
+					       B43_MMIO_PHY_TEST) & 0x2000);
 		}
 		b43_phy_write(dev, 0x0020, 0x3F3F);
 		b43_phy_write(dev, 0x0015, 0xF330);
@@ -2662,111 +2662,104 @@ void b43_calc_nrssi_slope(struct b43_wld
 		if (phy->radio_rev == 8)
 			b43_calc_nrssi_offset(dev);
 
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      b43_phy_read(dev, B43_PHY_G_CRS) & 0x7FFF);
-		b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & 0xFFFC);
-		backup[7] = b43_read16(dev, 0x03E2);
-		b43_write16(dev, 0x03E2, b43_read16(dev, 0x03E2) | 0x8000);
-		backup[0] = b43_radio_read16(dev, 0x007A);
-		backup[1] = b43_radio_read16(dev, 0x0052);
-		backup[2] = b43_radio_read16(dev, 0x0043);
-		backup[3] = b43_phy_read(dev, 0x0015);
+		b43_phy_write(dev, B43_PHY_CRS,
+			      b43_phy_read(dev, B43_PHY_CRS)
+			       & ~B43_PHY_CRS_EN_ALL);
+		b43_phy_write(dev, B43_PHY_CLASSCTL,
+			      b43_phy_read(dev, B43_PHY_CLASSCTL) &
+			       ~(B43_PHY_CLASSCTL_CCK | B43_PHY_CLASSCTL_OFDM));
+		backup[7] = b43_read16(dev, B43_MMIO_PHY_BBANDCFG);
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG, backup[7] | 0x8000);
+		backup[0] = b43_radio_read16(dev, B43_RADIO_2050_RXCTL0);
+		backup[1] = b43_radio_read16(dev, B43_RADIO_2050_TXCTL1);
+		backup[2] = b43_radio_read16(dev, B43_RADIO_2050_PCTL);
+		backup[3] = b43_phy_read(dev, B43_PHY_PGACTL);
 		backup[4] = b43_phy_read(dev, 0x005A);
 		backup[5] = b43_phy_read(dev, 0x0059);
 		backup[6] = b43_phy_read(dev, 0x0058);
-		backup[8] = b43_read16(dev, 0x03E6);
-		backup[9] = b43_read16(dev, B43_MMIO_CHANNEL_EXT);
-		if (phy->rev >= 3) {
-			backup[10] = b43_phy_read(dev, 0x002E);
-			backup[11] = b43_phy_read(dev, 0x002F);
-			backup[12] = b43_phy_read(dev, 0x080F);
-			backup[13] = b43_phy_read(dev, B43_PHY_G_LO_CONTROL);
-			backup[14] = b43_phy_read(dev, 0x0801);
-			backup[15] = b43_phy_read(dev, 0x0060);
-			backup[16] = b43_phy_read(dev, 0x0014);
-			backup[17] = b43_phy_read(dev, 0x0478);
-			b43_phy_write(dev, 0x002E, 0);
-			b43_phy_write(dev, B43_PHY_G_LO_CONTROL, 0);
-			switch (phy->rev) {
-			case 4:
-			case 6:
-			case 7:
-				b43_phy_write(dev, 0x0478,
-					      b43_phy_read(dev, 0x0478)
-					      | 0x0100);
-				b43_phy_write(dev, 0x0801,
-					      b43_phy_read(dev, 0x0801)
-					      | 0x0040);
-				break;
-			case 3:
-			case 5:
-				b43_phy_write(dev, 0x0801,
-					      b43_phy_read(dev, 0x0801)
-					      & 0xFFBF);
-				break;
-			}
-			b43_phy_write(dev, 0x0060, b43_phy_read(dev, 0x0060)
-				      | 0x0040);
-			b43_phy_write(dev, 0x0014, b43_phy_read(dev, 0x0014)
-				      | 0x0200);
-		}
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x0070);
+		backup[8] = b43_read16(dev, B43_MMIO_PHY0);
+		backup[9] = b43_read16(dev, B43_MMIO_PHY_TEST);
+		if (b43_has_hardware_pctl(phy)) {
+			backup[10] = b43_phy_read(dev, B43_PHY_TXDC_OFFSET1);
+			backup[11] = b43_phy_read(dev, B43_PHY_TXDC_OFFSET2);
+			backup[12] = b43_phy_read(dev, B43_PHY_LO_MASK);
+			backup[13] = b43_phy_read(dev, B43_PHY_LO_CTL);
+			backup[14] = b43_phy_read(dev, B43_PHY_G_CTL);
+			backup[15] = b43_phy_read(dev, B43_PHY_DACCTL);
+			backup[16] = b43_phy_read(dev, B43_PHY_TR_LT2);
+			backup[17] = b43_phy_read(dev, B43_PHY_HPWR_TSSICTL);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET1, 0);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET2, 0);
+			b43_phy_write(dev, B43_PHY_LO_MASK, 0);
+			b43_phy_write(dev, B43_PHY_LO_CTL, 0);
+			b43_phy_write(dev, B43_PHY_HPWR_TSSICTL, 0);
+			b43_phy_write(dev, B43_PHY_G_CTL, 0);
+			b43_phy_write(dev, B43_PHY_DACCTL, 0);
+			b43_phy_write(dev, B43_PHY_TR_LT2, 0);
+		}
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x0070);
 		b43_set_all_gains(dev, 0, 8, 0);
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) & 0x00F7);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   & 0x00F7);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0811,
-				      (b43_phy_read(dev, 0x0811) & 0xFFCF) |
-				      0x0030);
-			b43_phy_write(dev, 0x0812,
-				      (b43_phy_read(dev, 0x0812) & 0xFFCF) |
-				      0x0010);
+			b43_phy_write(dev, B43_PHY_RFOVER,
+				      b43_phy_read(dev, B43_PHY_RFOVER)
+				       | 0x0030);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF) | 0x0010);
 		}
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x0080);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x0080);
 		udelay(20);
 
-		nrssi0 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
+		nrssi0 = (s16)((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (nrssi0 >= 0x0020)
 			nrssi0 -= 0x0040;
 
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) & 0x007F);
-		if (phy->rev >= 2) {
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   & 0x0080);
+		if (phy->analog >= 2) {
 			b43_phy_write(dev, 0x0003, (b43_phy_read(dev, 0x0003)
 						    & 0xFF9F) | 0x0040);
 		}
 
-		b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-			    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
+		b43_write16(dev, B43_MMIO_PHY_TEST,
+			    b43_read16(dev, B43_MMIO_PHY_TEST)
 			    | 0x2000);
-		b43_radio_write16(dev, 0x007A,
-				  b43_radio_read16(dev, 0x007A) | 0x000F);
-		b43_phy_write(dev, 0x0015, 0xF330);
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0,
+				  b43_radio_read16(dev, B43_RADIO_2050_RXCTL0)
+				   | 0x000F);
+		b43_phy_write(dev, B43_PHY_PGACTL, 0xF330);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0812,
-				      (b43_phy_read(dev, 0x0812) & 0xFFCF) |
-				      0x0020);
-			b43_phy_write(dev, 0x0811,
-				      (b43_phy_read(dev, 0x0811) & 0xFFCF) |
-				      0x0020);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF) | 0x0020);
+			b43_phy_write(dev, B43_PHY_RFOVER,
+				      (b43_phy_read(dev, B43_PHY_RFOVER)
+				       & 0xFFCF) | 0x0020);
 		}
-
 		b43_set_all_gains(dev, 3, 0, 1);
-		if (phy->radio_rev == 8) {
-			b43_radio_write16(dev, 0x0043, 0x001F);
-		} else {
-			tmp = b43_radio_read16(dev, 0x0052) & 0xFF0F;
-			b43_radio_write16(dev, 0x0052, tmp | 0x0060);
-			tmp = b43_radio_read16(dev, 0x0043) & 0xFFF0;
-			b43_radio_write16(dev, 0x0043, tmp | 0x0009);
+		if (phy->radio_rev == 8)
+			b43_radio_write16(dev, B43_RADIO_2050_PCTL, 0x001F);
+		else {
+			b43_radio_write16(dev, B43_RADIO_2050_TXCTL1,
+					  (b43_radio_read16(dev, B43_RADIO_2050_TXCTL1)
+					   & 0xFF0F) | 0x0060);
+			b43_radio_write16(dev, B43_RADIO_2050_PCTL,
+					  (b43_radio_read16(dev, B43_RADIO_2050_PCTL)
+					   & 0xFFF0) | 0x0009);
 		}
 		b43_phy_write(dev, 0x005A, 0x0480);
 		b43_phy_write(dev, 0x0059, 0x0810);
 		b43_phy_write(dev, 0x0058, 0x000D);
 		udelay(20);
-		nrssi1 = (s16) ((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
+		nrssi1 = (s16)((b43_phy_read(dev, 0x047F) >> 8) & 0x003F);
 		if (nrssi1 >= 0x0020)
 			nrssi1 -= 0x0040;
 		if (nrssi0 == nrssi1)
@@ -2777,40 +2770,43 @@ void b43_calc_nrssi_slope(struct b43_wld
 			phy->nrssi[0] = nrssi1;
 			phy->nrssi[1] = nrssi0;
 		}
-		if (phy->rev >= 3) {
-			b43_phy_write(dev, 0x002E, backup[10]);
-			b43_phy_write(dev, 0x002F, backup[11]);
-			b43_phy_write(dev, 0x080F, backup[12]);
-			b43_phy_write(dev, B43_PHY_G_LO_CONTROL, backup[13]);
-		}
+		if (b43_has_hardware_pctl(phy)) {
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET1, backup[10]);
+			b43_phy_write(dev, B43_PHY_TXDC_OFFSET2, backup[11]);
+			b43_phy_write(dev, B43_PHY_LO_MASK, backup[12]);
+			b43_phy_write(dev, B43_PHY_LO_CTL, backup[13]);
+		}
+		b43_radio_write16(dev, B43_RADIO_2050_RXCTL0, backup[0]);
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG, backup[7]);
+		b43_phy_write(dev, B43_PHY_PGACTL, backup[3]);
 		if (phy->rev >= 2) {
-			b43_phy_write(dev, 0x0812,
-				      b43_phy_read(dev, 0x0812) & 0xFFCF);
-			b43_phy_write(dev, 0x0811,
-				      b43_phy_read(dev, 0x0811) & 0xFFCF);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      b43_phy_read(dev, B43_PHY_RFOVERVAL)
+				       & 0xFFCF);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      b43_phy_read(dev, B43_PHY_RFOVER)
+				       & 0xFFCF);
 		}
-
-		b43_radio_write16(dev, 0x007A, backup[0]);
-		b43_radio_write16(dev, 0x0052, backup[1]);
-		b43_radio_write16(dev, 0x0043, backup[2]);
-		b43_write16(dev, 0x03E2, backup[7]);
-		b43_write16(dev, 0x03E6, backup[8]);
-		b43_write16(dev, B43_MMIO_CHANNEL_EXT, backup[9]);
-		b43_phy_write(dev, 0x0015, backup[3]);
+		b43_write16(dev, B43_MMIO_PHY0, backup[8]);
+		b43_write16(dev, B43_MMIO_PHY_TEST, backup[9]);
+		b43_radio_write16(dev, B43_RADIO_2050_TXCTL1, backup[1]);
+		b43_radio_write16(dev, B43_RADIO_2050_PCTL, backup[2]);
 		b43_phy_write(dev, 0x005A, backup[4]);
 		b43_phy_write(dev, 0x0059, backup[5]);
 		b43_phy_write(dev, 0x0058, backup[6]);
 		b43_synth_pu_workaround(dev, phy->channel);
-		b43_phy_write(dev, 0x0802,
-			      b43_phy_read(dev, 0x0802) | (0x0001 | 0x0002));
+		b43_phy_write(dev, B43_PHY_CLASSCTL,
+			      b43_phy_read(dev, B43_PHY_CLASSCTL)
+			       | (B43_PHY_CLASSCTL_CCK | B43_PHY_CLASSCTL_OFDM));
 		b43_set_original_gains(dev);
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      b43_phy_read(dev, B43_PHY_G_CRS) | 0x8000);
-		if (phy->rev >= 3) {
-			b43_phy_write(dev, 0x0801, backup[14]);
-			b43_phy_write(dev, 0x0060, backup[15]);
-			b43_phy_write(dev, 0x0014, backup[16]);
-			b43_phy_write(dev, 0x0478, backup[17]);
+		b43_phy_write(dev, B43_PHY_CRS,
+			      b43_phy_read(dev, B43_PHY_CRS)
+			       | B43_PHY_CRS_EN_ALL);
+		if (b43_has_hardware_pctl(phy)) {
+			b43_phy_write(dev, B43_PHY_G_CTL, backup[14]);
+			b43_phy_write(dev, B43_PHY_DACCTL, backup[15]);
+			b43_phy_write(dev, B43_PHY_TR_LT2, backup[16]);
+			b43_phy_write(dev, B43_PHY_HPWR_TSSICTL, backup[17]);
 		}
 		b43_nrssi_mem_update(dev);
 		b43_calc_nrssi_threshold(dev);
@@ -3001,9 +2997,9 @@ b43_radio_interference_mitigation_enable
 		if (phy->rev != 1) {
 			b43_phy_write(dev, 0x042B,
 				      b43_phy_read(dev, 0x042B) | 0x0800);
-			b43_phy_write(dev, B43_PHY_G_CRS,
+			b43_phy_write(dev, B43_PHY_CRS,
 				      b43_phy_read(dev,
-						   B43_PHY_G_CRS) & ~0x4000);
+						   B43_PHY_CRS) & ~B43_PHY_CRS_EN_0);
 			break;
 		}
 		radio_stacksave(0x0078);
@@ -3063,7 +3059,7 @@ b43_radio_interference_mitigation_enable
 		phy->aci_enable = 1;
 
 		phy_stacksave(B43_PHY_RADIO_BITFIELD);
-		phy_stacksave(B43_PHY_G_CRS);
+		phy_stacksave(B43_PHY_CRS);
 		if (phy->rev < 2) {
 			phy_stacksave(0x0406);
 		} else {
@@ -3100,8 +3096,8 @@ b43_radio_interference_mitigation_enable
 		b43_phy_write(dev, B43_PHY_RADIO_BITFIELD,
 			      b43_phy_read(dev, B43_PHY_RADIO_BITFIELD)
 			      & ~0x1000);
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      (b43_phy_read(dev, B43_PHY_G_CRS)
+		b43_phy_write(dev, B43_PHY_CRS,
+			      (b43_phy_read(dev, B43_PHY_CRS)
 			       & 0xFFFC) | 0x0002);
 
 		b43_phy_write(dev, 0x0033, 0x0800);
@@ -3203,9 +3199,9 @@ b43_radio_interference_mitigation_disabl
 		if (phy->rev != 1) {
 			b43_phy_write(dev, 0x042B,
 				      b43_phy_read(dev, 0x042B) & ~0x0800);
-			b43_phy_write(dev, B43_PHY_G_CRS,
+			b43_phy_write(dev, B43_PHY_CRS,
 				      b43_phy_read(dev,
-						   B43_PHY_G_CRS) | 0x4000);
+						   B43_PHY_CRS) | B43_PHY_CRS_EN_0);
 			break;
 		}
 		radio_stackrestore(0x0078);
@@ -3217,8 +3213,8 @@ b43_radio_interference_mitigation_disabl
 				      b43_phy_read(dev, B43_PHY_RADIO_BITFIELD)
 				      & ~(1 << 11));
 		}
-		b43_phy_write(dev, B43_PHY_G_CRS,
-			      b43_phy_read(dev, B43_PHY_G_CRS) | 0x4000);
+		b43_phy_write(dev, B43_PHY_CRS,
+			      b43_phy_read(dev, B43_PHY_CRS) | B43_PHY_CRS_EN_0);
 		phy_stackrestore(0x04A0);
 		phy_stackrestore(0x04A1);
 		phy_stackrestore(0x04A2);
@@ -3238,7 +3234,7 @@ b43_radio_interference_mitigation_disabl
 		phy->aci_enable = 0;
 
 		phy_stackrestore(B43_PHY_RADIO_BITFIELD);
-		phy_stackrestore(B43_PHY_G_CRS);
+		phy_stackrestore(B43_PHY_CRS);
 		phy_stackrestore(0x0033);
 		phy_stackrestore(0x04A3);
 		phy_stackrestore(0x04A9);
@@ -3484,7 +3480,7 @@ struct init2050_saved_values {
 	u16 phy_rfoverval;
 	u16 phy_analogover;
 	u16 phy_analogoverval;
-	u16 phy_crs0;
+	u16 phy_crs;
 	u16 phy_classctl;
 	u16 phy_lo_mask;
 	u16 phy_lo_ctl;
@@ -3523,7 +3519,7 @@ u16 b43_radio_init2050(struct b43_wldev 
 		sav.phy_analogover = b43_phy_read(dev, B43_PHY_ANALOGOVER);
 		sav.phy_analogoverval =
 		    b43_phy_read(dev, B43_PHY_ANALOGOVERVAL);
-		sav.phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);
+		sav.phy_crs = b43_phy_read(dev, B43_PHY_CRS);
 		sav.phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);
 
 		b43_phy_write(dev, B43_PHY_ANALOGOVER,
@@ -3532,8 +3528,8 @@ u16 b43_radio_init2050(struct b43_wldev 
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      b43_phy_read(dev, B43_PHY_ANALOGOVERVAL)
 			      & 0xFFFC);
-		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
-			      & 0x7FFF);
+		b43_phy_write(dev, B43_PHY_CRS, b43_phy_read(dev, B43_PHY_CRS)
+			      & ~B43_PHY_CRS_EN_ALL);
 		b43_phy_write(dev, B43_PHY_CLASSCTL,
 			      b43_phy_read(dev, B43_PHY_CLASSCTL)
 			      & 0xFFFC);
@@ -3570,8 +3566,8 @@ u16 b43_radio_init2050(struct b43_wldev 
 				      (b43_phy_read(dev, B43_PHY_BASE(0x03))
 				       & 0xFFBF) | 0x40);
 		}
-		b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-			    (b43_read16(dev, B43_MMIO_CHANNEL_EXT) | 0x2000));
+		b43_write16(dev, B43_MMIO_PHY_TEST,
+			    (b43_read16(dev, B43_MMIO_PHY_TEST) | 0x2000));
 	}
 
 	rcc = b43_radio_core_calibration_value(dev);
@@ -3715,15 +3711,15 @@ u16 b43_radio_init2050(struct b43_wldev 
 		b43_phy_write(dev, B43_PHY_BASE(0x30), sav.phy_base_30);
 		b43_write16(dev, 0x3EC, sav.reg_3EC);
 	} else if (phy->gmode) {
-		b43_write16(dev, B43_MMIO_PHY_RADIO,
-			    b43_read16(dev, B43_MMIO_PHY_RADIO)
+		b43_write16(dev, B43_MMIO_PHY_BBANDCFG,
+			    b43_read16(dev, B43_MMIO_PHY_BBANDCFG)
 			    & 0x7FFF);
 		b43_phy_write(dev, B43_PHY_RFOVER, sav.phy_rfover);
 		b43_phy_write(dev, B43_PHY_RFOVERVAL, sav.phy_rfoverval);
 		b43_phy_write(dev, B43_PHY_ANALOGOVER, sav.phy_analogover);
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      sav.phy_analogoverval);
-		b43_phy_write(dev, B43_PHY_CRS0, sav.phy_crs0);
+		b43_phy_write(dev, B43_PHY_CRS, sav.phy_crs);
 		b43_phy_write(dev, B43_PHY_CLASSCTL, sav.phy_classctl);
 		if (has_loopback_gain(phy)) {
 			b43_phy_write(dev, B43_PHY_LO_MASK, sav.phy_lo_mask);
@@ -3912,12 +3908,12 @@ int b43_radio_selectchannel(struct b43_w
 			else
 				b43_hf_write(dev,
 					     b43_hf_read(dev) | B43_HF_ACPR);
-			b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-				    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
+			b43_write16(dev, B43_MMIO_PHY_TEST,
+				    b43_read16(dev, B43_MMIO_PHY_TEST)
 				    | (1 << 11));
 		} else {
-			b43_write16(dev, B43_MMIO_CHANNEL_EXT,
-				    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
+			b43_write16(dev, B43_MMIO_PHY_TEST,
+				    b43_read16(dev, B43_MMIO_PHY_TEST)
 				    & 0xF7BF);
 		}
 	}
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h
+++ wireless-2.6/drivers/net/wireless/b43/phy.h
@@ -29,8 +29,9 @@ struct b43_phy;
 #define B43_PHY_LNAHPFCTL		B43_PHY_OFDM(0x1C)	/* LNA/HPF control */
 #define B43_PHY_LPFGAINCTL		B43_PHY_OFDM(0x20)	/* LPF Gain control */
 #define B43_PHY_ADIVRELATED		B43_PHY_OFDM(0x27)	/* FIXME rename */
-#define B43_PHY_CRS0			B43_PHY_OFDM(0x29)	/* Collision resolution signaling */
-#define  B43_PHY_CRS0_EN		0x8000	/* CRS enable */
+#define B43_PHY_CRS			B43_PHY_OFDM(0x29)	/* Collision resolution signaling */
+#define  B43_PHY_CRS_EN_ALL		0x8000			/* CRS enable */
+#define  B43_PHY_CRS_EN_0		0x4000			/* CRS 0 enable */
 #define B43_PHY_PEAK_COUNT		B43_PHY_OFDM(0x30)
 #define B43_PHY_ANTDWELL		B43_PHY_OFDM(0x2B)	/* Antenna dwell */
 #define  B43_PHY_ANTDWELL_AUTODIV1	0x0100	/* Automatic RX diversity start antenna */
@@ -78,11 +79,14 @@ struct b43_phy;
 /* CCK (B) PHY Registers */
 #define B43_PHY_VERSION_CCK		B43_PHY_BASE(0x00)	/* Versioning register for B-PHY */
 #define B43_PHY_CCKBBANDCFG		B43_PHY_BASE(0x01)	/* Contains antenna 0/1 control bit */
+#define B43_PHY_TR_LT2			B43_PHY_BASE(0x14)	/* TR lookup table 2 */
 #define B43_PHY_PGACTL			B43_PHY_BASE(0x15)	/* PGA control */
 #define  B43_PHY_PGACTL_LPF		0x1000	/* Low pass filter (?) */
 #define  B43_PHY_PGACTL_LOWBANDW	0x0040	/* Low bandwidth flag */
 #define  B43_PHY_PGACTL_UNKNOWN		0xEFA0
 #define B43_PHY_FBCTL1			B43_PHY_BASE(0x18)	/* Frequency bandwidth control 1 */
+#define B43_PHY_TXDC_OFFSET1		B43_PHY_BASE(0x2E)
+#define B43_PHY_TXDC_OFFSET2		B43_PHY_BASE(0x2F)
 #define B43_PHY_ITSSI			B43_PHY_BASE(0x29)	/* Idle TSSI */
 #define B43_PHY_LO_LEAKAGE		B43_PHY_BASE(0x2D)	/* Measured LO leakage */
 #define B43_PHY_ENERGY			B43_PHY_BASE(0x33)	/* Energy */
@@ -92,7 +96,10 @@ struct b43_phy;
 #define B43_PHY_RCCALOVER		B43_PHY_BASE(0x78)	/* RC calibration override */
 
 /* Extended G-PHY Registers */
+#define B43_PHY_G_CTL			B43_PHY_EXTG(0x01)	/* G PHY control */
 #define B43_PHY_CLASSCTL		B43_PHY_EXTG(0x02)	/* Classify control */
+#define  B43_PHY_CLASSCTL_CCK		0x0001
+#define  B43_PHY_CLASSCTL_OFDM		0x0002
 #define B43_PHY_GTABCTL			B43_PHY_EXTG(0x03)	/* G-PHY table control (see below) */
 #define  B43_PHY_GTABOFF		0x03FF	/* G-PHY table offset (see below) */
 #define  B43_PHY_GTABNR			0xFC00	/* G-PHY table number (see below) */
Index: wireless-2.6/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/wa.c
+++ wireless-2.6/drivers/net/wireless/b43/wa.c
@@ -325,8 +325,8 @@ static void b43_wa_crs_ed(struct b43_wld
 
 static void b43_wa_crs_thr(struct b43_wldev *dev)
 {
-	b43_phy_write(dev, B43_PHY_CRS0,
-			(b43_phy_read(dev, B43_PHY_CRS0) & ~0x03C0) | 0xD000);
+	b43_phy_write(dev, B43_PHY_CRS,
+			(b43_phy_read(dev, B43_PHY_CRS) & ~0x03C0) | 0xD000);
 }
 
 static void b43_wa_crs_blank(struct b43_wldev *dev)



-- 
Ciao
Stefano


From mb at bu3sch.de  Fri Nov 30 17:19:12 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 30 Nov 2007 17:19:12 +0100
Subject: [RFT] [PATCH v4] b43: fix calc_nrssi_slope
In-Reply-To: <20071129220654.6c0c0d35@morte>
References: <20071129043957.739b4d3f@morte> <20071129215139.60ae663a@morte>
	<20071129220654.6c0c0d35@morte>
Message-ID: <200711301719.13245.mb@bu3sch.de>

On Thursday 29 November 2007 22:06:54 Stefano Brivio wrote:
> Fix calc_nrssi_slope() which caused PHY TX errors on devices containing a
> 802.11a PHY. The code is synced to v4 specs and relevant registers are
> renamed accordingly.
> 
> 
> Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
> 
> ---

That patch looks good, though I did not test it, yet.

John, please don't apply this, yet. It needs a lot more testing on
several different devices. In the past we had this kind of rewrite patches
already improve one device and completely break another.

So, people, please try this and check if it causes any regressions.

Thanks.

-- 
Greetings Michael.


