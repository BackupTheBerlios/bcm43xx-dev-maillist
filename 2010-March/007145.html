<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH V3] ssb: Implement virtual SPROM
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/bcm43xx-dev/2010-March/index.html" >
   <LINK REL="made" HREF="mailto:bcm43xx-dev%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20V3%5D%20ssb%3A%20Implement%20virtual%20SPROM&In-Reply-To=%3C4ba912f2./S7YyAUZdz6Kx4tH%25Larry.Finger%40lwfinger.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007143.html">
   <LINK REL="Next"  HREF="007158.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH V3] ssb: Implement virtual SPROM</H1>
    <B>Larry Finger</B> 
    <A HREF="mailto:bcm43xx-dev%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20V3%5D%20ssb%3A%20Implement%20virtual%20SPROM&In-Reply-To=%3C4ba912f2./S7YyAUZdz6Kx4tH%25Larry.Finger%40lwfinger.net%3E"
       TITLE="[PATCH V3] ssb: Implement virtual SPROM">Larry.Finger at lwfinger.net
       </A><BR>
    <I>Tue Mar 23 20:13:54 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="007143.html">[PATCH V2] ssb: Implement virtual SPROM on disk
</A></li>
        <LI>Next message: <A HREF="007158.html">[PATCH V3] ssb: Implement virtual SPROM
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7145">[ date ]</a>
              <a href="thread.html#7145">[ thread ]</a>
              <a href="subject.html#7145">[ subject ]</a>
              <a href="author.html#7145">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Some recent BCM43XX devices lack an on-board SPROM. The pertinent data
from the SPROM could be included in the kernel; however, this presents
a problem in the generation of a unique, reproducible MAC address. The
solution is to use a file in /lib/firmware/ssb, which has some &quot;random&quot;
information generated by /bin/dbus-uuidgen. This file is loaded using the
asynchronous firmware facility and a MAC address is generated from those
data. To prevent multiple devices in a single box from having the same
MAC address, the last two digits are replaced by the bus numbers of the
device.

Signed-off-by: Larry Finger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">Larry.Finger at lwfinger.net</A>&gt;
---

John,

Unless someone comes up with a unique way to generate a MAC address using
only udev rules, I think this is ready.

I suspect it is a little to invasive for 2.6.34. In addition, it fixes
a bug, but not a regression.

Larry
---

V2 - make virtual SPROM loading asynchronous.
V3 - eliminate the need for a special external utility
   - set for unique MAC address even if a box has more than one of these
     devices

Index: wireless-testing/drivers/ssb/pci.c
===================================================================
--- wireless-testing.orig/drivers/ssb/pci.c
+++ wireless-testing/drivers/ssb/pci.c
@@ -19,6 +19,7 @@
 #include &lt;linux/ssb/ssb_regs.h&gt;
 #include &lt;linux/pci.h&gt;
 #include &lt;linux/delay.h&gt;
+#include &lt;linux/firmware.h&gt;
 
 #include &quot;ssb_private.h&quot;
 
@@ -613,6 +614,120 @@ static int sprom_extract(struct ssb_bus
 	return 0;
 }
 
+static void ssb_vsprom_load_failed(void)
+{
+	printk(KERN_ERR &quot;ssb: The BCM43XX device does not have an &quot;
+		    &quot;SPROM built in. Use the command\n&quot;);
+	printk(KERN_ERR &quot;     'mkdir -p /lib/firmware/ssb ; /bin/dbus-uuidgen&quot;
+		    &quot; &gt; /lib/firmware/ssb/mac_addr'\n&quot;);
+	printk(KERN_ERR &quot;     to generate the required file.\n&quot;);
+}
+
+static inline u8 ascii_to_bin(u8 input)
+{
+	/* return the binary value of the ASCII char in the low nibble */
+	return (input &lt;= 0x39) ? input &amp; 0xF : (input - 0x27) &amp; 0xF;
+}
+
+static void ssb_get_vsprom(const struct firmware *fw, void *context)
+{
+	/* Second part of asynchronous firmware load */
+	int i;
+	struct ssb_bus *bus = context;
+	struct ssb_sprom *sprom = &amp;bus-&gt;sprom;
+	u8 buf2[8];
+	char *name;
+
+	if (!fw) {
+		ssb_vsprom_load_failed();
+		return;
+	}
+	/* Get values extracted from SPROM. If sprom_extract_r8() is changed,
+	 * this section must be changed as well. For any device with 5GHz
+	 * capability, some variables will have to be changed.
+	 */
+	sprom-&gt;revision = 8;
+	sprom-&gt;boardflags_lo = 0x0A01;
+	sprom-&gt;boardflags_hi = 0x0006;
+	sprom-&gt;boardflags2_lo = 0x0000;
+	sprom-&gt;boardflags2_hi = 0x0000;
+	sprom-&gt;ant_available_a = 0x00;
+	sprom-&gt;ant_available_bg = 0x03;
+	sprom-&gt;maxpwr_bg = 0x4A;
+	sprom-&gt;itssi_bg = 0x3E;
+	sprom-&gt;maxpwr_a = 0xFF;
+	sprom-&gt;itssi_a = 0xFF;
+	sprom-&gt;maxpwr_ah = 0xFF;
+	sprom-&gt;maxpwr_al = 0xFF;
+	sprom-&gt;gpio0 = 0x83;
+	sprom-&gt;gpio1 = 0xFF;
+	sprom-&gt;gpio2 = 0xFF;
+	sprom-&gt;gpio3 = 0xFF;
+	sprom-&gt;tri2g = 0x6C;
+	sprom-&gt;tri5g = 0x00;
+	sprom-&gt;tri5gl = 0xFF;
+	sprom-&gt;tri5gh = 0xFF;
+	sprom-&gt;rxpo2g = 0xFA;
+	sprom-&gt;rxpo5g = 0xFF;
+	sprom-&gt;rssismf2g = 0x0F;
+	sprom-&gt;rssismc2g = 0x00;
+	sprom-&gt;rssisav2g = 0x00;
+	sprom-&gt;bxa2g = 0x00;
+	sprom-&gt;rssismf5g = 0x0F;
+	sprom-&gt;rssismc5g = 0x0F;
+	sprom-&gt;rssisav5g = 0x07;
+	sprom-&gt;bxa5g = 0x03;
+	sprom-&gt;pa0b0 = 0x1a57;
+	sprom-&gt;pa0b1 = 0xF98A;
+	sprom-&gt;pa0b2 = 0xFE91;
+	sprom-&gt;pa1b0 = 0xFFFF;
+	sprom-&gt;pa1b1 = 0xFFFF;
+	sprom-&gt;pa1b2 = 0xFFFF;
+	sprom-&gt;pa1lob0 = 0xFFFF;
+	sprom-&gt;pa1lob1 = 0xFFFF;
+	sprom-&gt;pa1lob2 = 0xFFFF;
+	sprom-&gt;pa1hib0 = 0xFFFF;
+	sprom-&gt;pa1hib1 = 0xFFFF;
+	sprom-&gt;pa1hib2 = 0xFFFF;
+	sprom-&gt;cck2gpo = 0xFFFF;
+	sprom-&gt;ofdm2gpo = 0x00000002;
+	sprom-&gt;ofdm5glpo = 0xFFFFFFFF;
+	sprom-&gt;ofdm5gpo = 0xFFFFFFFF;
+	sprom-&gt;ofdm5ghpo = 0xFFFFFFFF;
+	memset(sprom-&gt;et0mac, 0xFF, 6);
+	memset(sprom-&gt;et1mac, 0xFF, 6);
+
+	if (fw-&gt;size != 33) {
+		printk(KERN_ERR &quot;ssb: The MAC address file has the wrong&quot;
+		       &quot; size\n&quot;);
+		goto out;
+	}
+	/* Input MAC address data in ASCII - get low nibble in binary */
+	for (i = 0 ; i &lt; 8; i++) {
+		u8 tmp = ascii_to_bin(fw-&gt;data[2 * i]);
+		u8 tmp1 = ascii_to_bin(fw-&gt;data[2 * i + 1]);
+		buf2[i] = tmp &lt;&lt; 4 | tmp1;
+	}
+	/* make sure 2 least significant bits of first byte are clear
+	 * These bits are multicast address and LAA bit, and
+	 * copy the randomized MAC address to the sprom variables
+	 */
+	buf2[0] &amp;= ~(3);
+	memcpy(sprom-&gt;il0mac, buf2, 4);
+
+	/* As there may be more than one such interface on a given box,
+	 * modify the random MAC address in the file with the
+	 * bus information as provided by dev_name(). This will be in
+	 * the form &quot;nnnn:mm:oo.p&quot;. The last two digits of the MAC address
+	 * will be set to oo and mm.
+	 */
+	name = (char *)dev_name(&amp;bus-&gt;host_pci-&gt;dev);
+	sprom-&gt;il0mac[5] = ascii_to_bin(name[5]) &lt;&lt; 4 | ascii_to_bin(name[6]);
+	sprom-&gt;il0mac[4] = ascii_to_bin(name[8]) &lt;&lt; 4 | ascii_to_bin(name[9]);
+out:
+	release_firmware(fw);
+}
+
 static int ssb_pci_sprom_get(struct ssb_bus *bus,
 			     struct ssb_sprom *sprom)
 {
@@ -620,8 +735,18 @@ static int ssb_pci_sprom_get(struct ssb_
 	int err = -ENOMEM;
 	u16 *buf;
 
-	if (!ssb_is_sprom_available(bus))
-		return -ENODEV;
+	if (!ssb_is_sprom_available(bus)) {
+		/* This device has no SPROM. Try for a random MAC address */
+		err = request_firmware_nowait(THIS_MODULE,
+			FW_ACTION_HOTPLUG, &quot;ssb/mac_addr&quot;,
+			&amp;bus-&gt;host_pci-&gt;dev, GFP_KERNEL, bus,
+			ssb_get_vsprom);
+		if (err) {
+			ssb_vsprom_load_failed();
+			return err;
+		}
+		return 0;
+	}
 
 	buf = kcalloc(SSB_SPROMSIZE_WORDS_R123, sizeof(u16), GFP_KERNEL);
 	if (!buf)
Index: wireless-testing/drivers/net/wireless/b43/phy_lp.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_lp.c
+++ wireless-testing/drivers/net/wireless/b43/phy_lp.c
@@ -107,7 +107,8 @@ static void lpphy_read_band_sprom(struct
 		 * opo == ofdm2gpo and we don't know any SSB with LP-PHY
 		 * and SPROM rev below 8.
 		 */
-		B43_WARN_ON(bus-&gt;sprom.revision &lt; 8);
+		if (bus-&gt;sprom.revision &lt; 8)
+			b43err(dev-&gt;wl, &quot;Illegal SPROM Revision\n&quot;);
 		ofdmpo = bus-&gt;sprom.ofdm2gpo;
 		if (cckpo) {
 			for (i = 0; i &lt; 4; i++) {

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007143.html">[PATCH V2] ssb: Implement virtual SPROM on disk
</A></li>
	<LI>Next message: <A HREF="007158.html">[PATCH V3] ssb: Implement virtual SPROM
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7145">[ date ]</a>
              <a href="thread.html#7145">[ thread ]</a>
              <a href="subject.html#7145">[ subject ]</a>
              <a href="author.html#7145">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">More information about the Bcm43xx-dev
mailing list</a><br>
</body></html>
