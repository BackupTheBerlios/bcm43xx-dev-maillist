From Larry.Finger at lwfinger.net  Sun Aug  2 05:32:48 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 01 Aug 2009 22:32:48 -0500
Subject: [PATCH] b43legacy: Work around mac80211 race condition
Message-ID: <4a7508e0.l3Jz6c5c8JgW9wQm%Larry.Finger@lwfinger.net>

As shown in http://thread.gmane.org/gmane.linux.kernel.wireless.general/36497,
mac80211 has a bug that allows a call to the TX routine after the queues have
been stopped. This situation will only occur under extreme stress. Although
b43legacy does not crash when this condition occurs, it does generate a WARN_ON
and also logs a queue overrun message. This patch recognizes b43legacy is not
at fault and logs a message only when the most verbose debugging mode is
enabled. In the unlikely event that the queue is not stopped when the DMA
queue becomes full, then a warning is issued.
    
This patch is based on the one used by b43.
   
Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>

Index: wireless-testing/drivers/net/wireless/b43legacy/dma.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43legacy/dma.c
+++ wireless-testing/drivers/net/wireless/b43legacy/dma.c
@@ -1366,15 +1366,25 @@ int b43legacy_dma_tx(struct b43legacy_wl
 	ring = priority_to_txring(dev, skb_get_queue_mapping(skb));
 	spin_lock_irqsave(&ring->lock, flags);
 	B43legacy_WARN_ON(!ring->tx);
-	if (unlikely(free_slots(ring) < SLOTS_PER_PACKET)) {
-		b43legacywarn(dev->wl, "DMA queue overflow\n");
+
+	if (unlikely(ring->stopped)) {
+		/* We get here only because of a bug in mac80211.
+		 * Because of a race, one packet may be queued after
+		 * the queue is stopped, thus we got called when we shouldn't.
+		 * For now, just refuse the transmit. */
+		if (b43legacy_debug(dev, B43legacy_DBG_DMAVERBOSE))
+			b43legacyerr(dev->wl, "Packet after queue stopped\n");
+		err = -ENOSPC;
+		goto out_unlock;
+	}
+
+	if (unlikely(WARN_ON(free_slots(ring) < SLOTS_PER_PACKET))) {
+		/* If we get here, we have a real error with the queue
+		 * full, but queues not stopped. */
+		b43legacyerr(dev->wl, "DMA queue overflow\n");
 		err = -ENOSPC;
 		goto out_unlock;
 	}
-	/* Check if the queue was stopped in mac80211,
-	 * but we got called nevertheless.
-	 * That would be a mac80211 bug. */
-	B43legacy_BUG_ON(ring->stopped);
 
 	err = dma_tx_fragment(ring, skb);
 	if (unlikely(err == -ENOKEY)) {


From netrolller.3d at gmail.com  Mon Aug  3 00:18:22 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Mon, 03 Aug 2009 00:18:22 +0200
Subject: [PATCH RESEND] b43: implement baseband init for LP-PHY <= rev1
Message-ID: <4A7610AE.5000908@gmail.com>

Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
boardflags_hi values to defines.
Implement b43_phy_copy for easier copying between registers, as needed
by LP-PHY init.

Signed-off-by: G?bor Stefanik<netrolller.3d at gmail.com>
Cc: Michael Buesch<mb at bu3sch.de>
Cc: Larry Finger<larry.finger at lwfinger.net>
---

Hopefully this mail will survive the trip through the arcane world of Gmail's servers...

If this very-very-very-long line (including	a	few	tab	characters) doesn't get mangled, chances are that the mail didn't get mangled. More text to make this line even longer.

  b43.h        |   11 ++++++
  phy_common.c |    7 ++++
  phy_lp.c     |   95 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
  phy_lp.h     |    8 +++-
  phy_n.c      |    3 +
  5 files changed, 120 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
index 4e8ad84..41ca727 100644
--- a/drivers/net/wireless/b43/b43.h
+++ b/drivers/net/wireless/b43/b43.h
@@ -142,6 +142,17 @@
  #define B43_BFL_BTCMOD			0x4000	/* BFL_BTCOEXIST is given in alternate GPIOs */
  #define B43_BFL_ALTIQ			0x8000	/* alternate I/Q settings */

+/* SPROM boardflags_hi values */
+#define B43_BFH_NOPA			0x0001	/* has no PA */
+#define B43_BFH_RSSIINV			0x0002	/* RSSI uses positive slope (not TSSI) */
+#define B43_BFH_PAREF			0x0004	/* uses the PARef LDO */
+#define B43_BFH_3TSWITCH		0x0008	/* uses a triple throw switch shared
+						 * with bluetooth */
+#define B43_BFH_PHASESHIFT		0x0010	/* can support phase shifter */
+#define B43_BFH_BUCKBOOST		0x0020	/* has buck/booster */
+#define B43_BFH_FEM_BT			0x0040	/* has FEM and switch to share antenna
+						 * with bluetooth */
+
  /* GPIO register offset, in both ChipCommon and PCI core. */
  #define B43_GPIO_CONTROL		0x6c

diff --git a/drivers/net/wireless/b43/phy_common.c b/drivers/net/wireless/b43/phy_common.c
index e176b6e..999e0bd 100644
--- a/drivers/net/wireless/b43/phy_common.c
+++ b/drivers/net/wireless/b43/phy_common.c
@@ -240,6 +240,13 @@ void b43_phy_write(struct b43_wldev *dev, u16 reg, u16 value)
  	dev->phy.ops->phy_write(dev, reg, value);
  }

+void b43_phy_copy(struct b43_wldev *dev, u16 srcreg, u16 destreg)
+{
+	assert_mac_suspended(dev);
+	dev->phy.ops->phy_write(dev, destreg,
+		dev->phy.ops->phy_read(dev, srcreg));
+}
+
  void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
  {
  	b43_phy_write(dev, offset,
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 58e319d..dbaa2e4 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -66,7 +66,100 @@ static void lpphy_table_init(struct b43_wldev *dev)

  static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
  {
-	B43_WARN_ON(1);//TODO rev<  2 not supported, yet.
+	struct ssb_bus *bus = dev->dev->bus;
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	u16 tmp, tmp2;
+
+	if (dev->phy.rev == 1&&
+	   (bus->sprom.boardflags_hi&  B43_BFH_FEM_BT)) {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0x3F00, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0400);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xC0FF, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xC0FF, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xC0FF, 0x0B00);
+	} else if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ ||
+		  (bus->boardinfo.type == 0x048A) || ((dev->phy.rev == 0)&&
+		  (bus->sprom.boardflags_lo&  B43_BFL_FEM))) {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0001);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0400);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0001);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0500);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0800);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0A00);
+	} else if (dev->phy.rev == 1 ||
+		  (bus->sprom.boardflags_lo&  B43_BFL_FEM)) {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0004);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0800);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0004);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0C00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0100);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0300);
+	} else {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0006);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0500);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0006);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0700);
+	}
+	if (dev->phy.rev == 1) {
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_1, B43_LPPHY_TR_LOOKUP_5);
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_2, B43_LPPHY_TR_LOOKUP_6);
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_3, B43_LPPHY_TR_LOOKUP_7);
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_4, B43_LPPHY_TR_LOOKUP_8);
+	}
+	if (bus->sprom.boardflags_hi&  B43_BFH_FEM_BT)&&
+	   (bus->chip_id == 0x5354)&&
+	   (bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
+		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
+		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
+		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
+		b43_hf_write(dev, b43_hf_read | 0x0800ULL<<  32);
+	}
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x8000);
+		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0040);
+		b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0x00FF, 0xA400);
+		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xF0FF, 0x0B00);
+		b43_phy_maskset(dev, 0x030, 0xFFF8, 0x0007);
+		b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFF8, 0x0003);
+		b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFC7, 0x0020);
+		b43_phy_mask(dev, B43_LPPHY_IDLEAFTERPKTRXTO, 0x00FF);
+	} else { /* 5GHz */
+		b43_phy_mask(dev, 0x448, 0x7FFF);
+		b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFBF);
+	}
+	if (dev->phy.rev == 1) {
+		tmp = b43_read(dev, B43_LPPHY_CLIPCTRTHRESH);
+		tmp2 = (tmp&  0x03E0)>>  5
+		tmp2 |= tmp<<  5;
+		b43_phy_write(dev, 0x4C3, tmp2);
+		tmp = b43_read(dev, B43_LPPHY_OFDMSYNCTHRESH0);
+		tmp2 = (tmp&  0x1F00)>>  8
+		tmp2 |= tmp<<  5;
+		b43_phy_write(dev, 0x4C4, tmp2);
+		tmp = b43_read(dev, B43_LPPHY_VERYLOWGAINDB);
+		tmp2 = tmp&  0x00FF
+		tmp2 |= tmp<<  8;
+		b43_phy_write(dev, 0x4C5, tmp2);
+	}
  }

  static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 18370b4..d0e67e4 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -273,12 +273,16 @@
  #define B43_LPPHY_AFE_DDFS_POINTER_INIT		B43_PHY_OFDM(0xB8) /* AFE DDFS pointer init */
  #define B43_LPPHY_AFE_DDFS_INCR_INIT		B43_PHY_OFDM(0xB9) /* AFE DDFS incr init */
  #define B43_LPPHY_MRCNOISEREDUCTION		B43_PHY_OFDM(0xBA) /* mrcNoiseReduction */
-#define B43_LPPHY_TRLOOKUP3			B43_PHY_OFDM(0xBB) /* TRLookup3 */
-#define B43_LPPHY_TRLOOKUP4			B43_PHY_OFDM(0xBC) /* TRLookup4 */
+#define B43_LPPHY_TR_LOOKUP_3			B43_PHY_OFDM(0xBB) /* TR Lookup 3 */
+#define B43_LPPHY_TR_LOOKUP_4			B43_PHY_OFDM(0xBC) /* TR Lookup 4 */
  #define B43_LPPHY_RADAR_FIFO_STAT		B43_PHY_OFDM(0xBD) /* Radar FIFO Status */
  #define B43_LPPHY_GPIO_OUTEN			B43_PHY_OFDM(0xBE) /* GPIO Out enable */
  #define B43_LPPHY_GPIO_SELECT			B43_PHY_OFDM(0xBF) /* GPIO Select */
  #define B43_LPPHY_GPIO_OUT			B43_PHY_OFDM(0xC0) /* GPIO Out */
+#define B43_LPPHY_TR_LOOKUP_5			B43_PHY_OFDM(0xC7) /* TR Lookup 5 */
+#define B43_LPPHY_TR_LOOKUP_6			B43_PHY_OFDM(0xC8) /* TR Lookup 6 */
+#define B43_LPPHY_TR_LOOKUP_7			B43_PHY_OFDM(0xC9) /* TR Lookup 7 */
+#define B43_LPPHY_TR_LOOKUP_8			B43_PHY_OFDM(0xCA) /* TR Lookup 8 */



diff --git a/drivers/net/wireless/b43/phy_n.c b/drivers/net/wireless/b43/phy_n.c
index 8bcfda5..14ad95a 100644
--- a/drivers/net/wireless/b43/phy_n.c
+++ b/drivers/net/wireless/b43/phy_n.c
@@ -137,7 +137,8 @@ static void b43_radio_init2055_post(struct b43_wldev *dev)

  	b43_radio_mask(dev, B2055_MASTER1, 0xFFF3);
  	msleep(1);
-	if ((sprom->revision != 4) || !(sprom->boardflags_hi&  0x0002)) {
+	if ((sprom->revision != 4) ||
+	   !(sprom->boardflags_hi&  B43_BFH_RSSIINV)) {
  		if ((binfo->vendor != PCI_VENDOR_ID_BROADCOM) ||
  		    (binfo->type != 0x46D) ||
  		    (binfo->rev<  0x41)) {




From netrolller.3d at gmail.com  Mon Aug  3 00:06:45 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Mon, 03 Aug 2009 00:06:45 +0200
Subject: [PATCH] b43: implement baseband init for LP-PHY <= rev1
Message-ID: <4A760DF5.6050504@gmail.com>

Implement baseband init for rev.0 and rev.1 LP PHYs. Convert 
boardflags_hi values to defines.
Implement b43_phy_copy for easier copying between registers, as needed 
by LP-PHY init.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
Cc: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>
---
  b43.h        |   11 ++++++
  phy_common.c |    7 ++++
  phy_lp.c     |   95 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
  phy_lp.h     |    8 +++-
  phy_n.c      |    3 +
  5 files changed, 120 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
index 4e8ad84..41ca727 100644
--- a/drivers/net/wireless/b43/b43.h
+++ b/drivers/net/wireless/b43/b43.h
@@ -142,6 +142,17 @@
  #define B43_BFL_BTCMOD            0x4000    /* BFL_BTCOEXIST is given 
in alternate GPIOs */
  #define B43_BFL_ALTIQ            0x8000    /* alternate I/Q settings */

+/* SPROM boardflags_hi values */
+#define B43_BFH_NOPA            0x0001    /* has no PA */
+#define B43_BFH_RSSIINV            0x0002    /* RSSI uses positive 
slope (not TSSI) */
+#define B43_BFH_PAREF            0x0004    /* uses the PARef LDO */
+#define B43_BFH_3TSWITCH        0x0008    /* uses a triple throw switch 
shared
+                         * with bluetooth */
+#define B43_BFH_PHASESHIFT        0x0010    /* can support phase shifter */
+#define B43_BFH_BUCKBOOST        0x0020    /* has buck/booster */
+#define B43_BFH_FEM_BT            0x0040    /* has FEM and switch to 
share antenna
+                         * with bluetooth */
+
  /* GPIO register offset, in both ChipCommon and PCI core. */
  #define B43_GPIO_CONTROL        0x6c

diff --git a/drivers/net/wireless/b43/phy_common.c 
b/drivers/net/wireless/b43/phy_common.c
index e176b6e..999e0bd 100644
--- a/drivers/net/wireless/b43/phy_common.c
+++ b/drivers/net/wireless/b43/phy_common.c
@@ -240,6 +240,13 @@ void b43_phy_write(struct b43_wldev *dev, u16 reg, 
u16 value)
      dev->phy.ops->phy_write(dev, reg, value);
  }

+void b43_phy_copy(struct b43_wldev *dev, u16 srcreg, u16 destreg)
+{
+    assert_mac_suspended(dev);
+    dev->phy.ops->phy_write(dev, destreg,
+        dev->phy.ops->phy_read(dev, srcreg));
+}
+
  void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
  {
      b43_phy_write(dev, offset,
diff --git a/drivers/net/wireless/b43/phy_lp.c 
b/drivers/net/wireless/b43/phy_lp.c
index 58e319d..dbaa2e4 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -66,7 +66,100 @@ static void lpphy_table_init(struct b43_wldev *dev)

  static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
  {
-    B43_WARN_ON(1);//TODO rev < 2 not supported, yet.
+    struct ssb_bus *bus = dev->dev->bus;
+    struct b43_phy_lp *lpphy = dev->phy.lp;
+    u16 tmp, tmp2;
+
+    if (dev->phy.rev == 1 &&
+       (bus->sprom.boardflags_hi & B43_BFH_FEM_BT)) {
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0x3F00, 0x0900);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x000A);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0400);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x000A);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0B00);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xFFC0, 0x000A);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xC0FF, 0x0900);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xFFC0, 0x000A);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xC0FF, 0x0B00);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xFFC0, 0x000A);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xC0FF, 0x0900);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xFFC0, 0x000A);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xC0FF, 0x0B00);
+    } else if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ ||
+          (bus->boardinfo.type == 0x048A) || ((dev->phy.rev == 0) &&
+          (bus->sprom.boardflags_lo & B43_BFL_FEM))) {
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0001);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0400);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0001);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0500);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0800);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0A00);
+    } else if (dev->phy.rev == 1 ||
+          (bus->sprom.boardflags_lo & B43_BFL_FEM)) {
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0004);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0800);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0004);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0C00);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0100);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0300);
+    } else {
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0900);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0006);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0500);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0006);
+        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0700);
+    }
+    if (dev->phy.rev == 1) {
+        b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_1, B43_LPPHY_TR_LOOKUP_5);
+        b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_2, B43_LPPHY_TR_LOOKUP_6);
+        b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_3, B43_LPPHY_TR_LOOKUP_7);
+        b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_4, B43_LPPHY_TR_LOOKUP_8);
+    }
+    if (bus->sprom.boardflags_hi & B43_BFH_FEM_BT) &&
+       (bus->chip_id == 0x5354) &&
+       (bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
+        b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
+        b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
+        b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
+        b43_hf_write(dev, b43_hf_read | 0x0800ULL << 32);
+    }
+    if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+        b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x8000);
+        b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0040);
+        b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0x00FF, 0xA400);
+        b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xF0FF, 0x0B00);
+        b43_phy_maskset(dev, 0x030, 0xFFF8, 0x0007);
+        b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFF8, 0x0003);
+        b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFC7, 0x0020);
+        b43_phy_mask(dev, B43_LPPHY_IDLEAFTERPKTRXTO, 0x00FF);
+    } else { /* 5GHz */
+        b43_phy_mask(dev, 0x448, 0x7FFF);
+        b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFBF);
+    }
+    if (dev->phy.rev == 1) {
+        tmp = b43_read(dev, B43_LPPHY_CLIPCTRTHRESH);
+        tmp2 = (tmp & 0x03E0) >> 5
+        tmp2 |= tmp << 5;
+        b43_phy_write(dev, 0x4C3, tmp2);
+        tmp = b43_read(dev, B43_LPPHY_OFDMSYNCTHRESH0);
+        tmp2 = (tmp & 0x1F00) >> 8
+        tmp2 |= tmp << 5;
+        b43_phy_write(dev, 0x4C4, tmp2);
+        tmp = b43_read(dev, B43_LPPHY_VERYLOWGAINDB);
+        tmp2 = tmp & 0x00FF
+        tmp2 |= tmp << 8;
+        b43_phy_write(dev, 0x4C5, tmp2);
+    }
  }

  static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
diff --git a/drivers/net/wireless/b43/phy_lp.h 
b/drivers/net/wireless/b43/phy_lp.h
index 18370b4..d0e67e4 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -273,12 +273,16 @@
  #define B43_LPPHY_AFE_DDFS_POINTER_INIT        B43_PHY_OFDM(0xB8) /* 
AFE DDFS pointer init */
  #define B43_LPPHY_AFE_DDFS_INCR_INIT        B43_PHY_OFDM(0xB9) /* AFE 
DDFS incr init */
  #define B43_LPPHY_MRCNOISEREDUCTION        B43_PHY_OFDM(0xBA) /* 
mrcNoiseReduction */
-#define B43_LPPHY_TRLOOKUP3            B43_PHY_OFDM(0xBB) /* TRLookup3 */
-#define B43_LPPHY_TRLOOKUP4            B43_PHY_OFDM(0xBC) /* TRLookup4 */
+#define B43_LPPHY_TR_LOOKUP_3            B43_PHY_OFDM(0xBB) /* TR 
Lookup 3 */
+#define B43_LPPHY_TR_LOOKUP_4            B43_PHY_OFDM(0xBC) /* TR 
Lookup 4 */
  #define B43_LPPHY_RADAR_FIFO_STAT        B43_PHY_OFDM(0xBD) /* Radar 
FIFO Status */
  #define B43_LPPHY_GPIO_OUTEN            B43_PHY_OFDM(0xBE) /* GPIO Out 
enable */
  #define B43_LPPHY_GPIO_SELECT            B43_PHY_OFDM(0xBF) /* GPIO 
Select */
  #define B43_LPPHY_GPIO_OUT            B43_PHY_OFDM(0xC0) /* GPIO Out */
+#define B43_LPPHY_TR_LOOKUP_5            B43_PHY_OFDM(0xC7) /* TR 
Lookup 5? */
+#define B43_LPPHY_TR_LOOKUP_6            B43_PHY_OFDM(0xC8) /* TR 
Lookup 6? */
+#define B43_LPPHY_TR_LOOKUP_7            B43_PHY_OFDM(0xC9) /* TR 
Lookup 7? */
+#define B43_LPPHY_TR_LOOKUP_8            B43_PHY_OFDM(0xCA) /* TR 
Lookup 8? */



diff --git a/drivers/net/wireless/b43/phy_n.c 
b/drivers/net/wireless/b43/phy_n.c
index 8bcfda5..14ad95a 100644
--- a/drivers/net/wireless/b43/phy_n.c
+++ b/drivers/net/wireless/b43/phy_n.c
@@ -137,7 +137,8 @@ static void b43_radio_init2055_post(struct b43_wldev 
*dev)

      b43_radio_mask(dev, B2055_MASTER1, 0xFFF3);
      msleep(1);
-    if ((sprom->revision != 4) || !(sprom->boardflags_hi & 0x0002)) {
+    if ((sprom->revision != 4) ||
+       !(sprom->boardflags_hi & B43_BFH_RSSIINV)) {
          if ((binfo->vendor != PCI_VENDOR_ID_BROADCOM) ||
              (binfo->type != 0x46D) ||
              (binfo->rev < 0x41)) {



From mb at bu3sch.de  Mon Aug  3 00:10:24 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 3 Aug 2009 00:10:24 +0200
Subject: [PATCH] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <4A760DF5.6050504@gmail.com>
References: <4A760DF5.6050504@gmail.com>
Message-ID: <200908030010.24321.mb@bu3sch.de>

On Monday 03 August 2009 00:06:45 G?bor Stefanik wrote:
> Implement baseband init for rev.0 and rev.1 LP PHYs. Convert 
> boardflags_hi values to defines.
> Implement b43_phy_copy for easier copying between registers, as needed 
> by LP-PHY init.

Please resubmit after coding style compliance checking and after fixing
your mail client to avoid linewrapping damage.

> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> Cc: Michael Buesch <mb at bu3sch.de>
> Cc: Larry Finger <larry.finger at lwfinger.net>
> ---
>   b43.h        |   11 ++++++
>   phy_common.c |    7 ++++
>   phy_lp.c     |   95 
> ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
>   phy_lp.h     |    8 +++-
>   phy_n.c      |    3 +
>   5 files changed, 120 insertions(+), 4 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
> index 4e8ad84..41ca727 100644
> --- a/drivers/net/wireless/b43/b43.h
> +++ b/drivers/net/wireless/b43/b43.h
> @@ -142,6 +142,17 @@
>   #define B43_BFL_BTCMOD            0x4000    /* BFL_BTCOEXIST is given 
> in alternate GPIOs */
>   #define B43_BFL_ALTIQ            0x8000    /* alternate I/Q settings */
> 
> +/* SPROM boardflags_hi values */
> +#define B43_BFH_NOPA            0x0001    /* has no PA */
> +#define B43_BFH_RSSIINV            0x0002    /* RSSI uses positive 
> slope (not TSSI) */
> +#define B43_BFH_PAREF            0x0004    /* uses the PARef LDO */
> +#define B43_BFH_3TSWITCH        0x0008    /* uses a triple throw switch 
> shared
> +                         * with bluetooth */
> +#define B43_BFH_PHASESHIFT        0x0010    /* can support phase shifter */
> +#define B43_BFH_BUCKBOOST        0x0020    /* has buck/booster */
> +#define B43_BFH_FEM_BT            0x0040    /* has FEM and switch to 
> share antenna
> +                         * with bluetooth */
> +
>   /* GPIO register offset, in both ChipCommon and PCI core. */
>   #define B43_GPIO_CONTROL        0x6c
> 
> diff --git a/drivers/net/wireless/b43/phy_common.c 
> b/drivers/net/wireless/b43/phy_common.c
> index e176b6e..999e0bd 100644
> --- a/drivers/net/wireless/b43/phy_common.c
> +++ b/drivers/net/wireless/b43/phy_common.c
> @@ -240,6 +240,13 @@ void b43_phy_write(struct b43_wldev *dev, u16 reg, 
> u16 value)
>       dev->phy.ops->phy_write(dev, reg, value);
>   }
> 
> +void b43_phy_copy(struct b43_wldev *dev, u16 srcreg, u16 destreg)
> +{
> +    assert_mac_suspended(dev);
> +    dev->phy.ops->phy_write(dev, destreg,
> +        dev->phy.ops->phy_read(dev, srcreg));
> +}
> +
>   void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
>   {
>       b43_phy_write(dev, offset,
> diff --git a/drivers/net/wireless/b43/phy_lp.c 
> b/drivers/net/wireless/b43/phy_lp.c
> index 58e319d..dbaa2e4 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -66,7 +66,100 @@ static void lpphy_table_init(struct b43_wldev *dev)
> 
>   static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
>   {
> -    B43_WARN_ON(1);//TODO rev < 2 not supported, yet.
> +    struct ssb_bus *bus = dev->dev->bus;
> +    struct b43_phy_lp *lpphy = dev->phy.lp;
> +    u16 tmp, tmp2;
> +
> +    if (dev->phy.rev == 1 &&
> +       (bus->sprom.boardflags_hi & B43_BFH_FEM_BT)) {
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0x3F00, 0x0900);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x000A);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0400);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x000A);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0B00);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xFFC0, 0x000A);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xC0FF, 0x0900);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xFFC0, 0x000A);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xC0FF, 0x0B00);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xFFC0, 0x000A);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xC0FF, 0x0900);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xFFC0, 0x000A);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xC0FF, 0x0B00);
> +    } else if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ ||
> +          (bus->boardinfo.type == 0x048A) || ((dev->phy.rev == 0) &&
> +          (bus->sprom.boardflags_lo & B43_BFL_FEM))) {
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0001);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0400);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0001);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0500);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0800);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0A00);
> +    } else if (dev->phy.rev == 1 ||
> +          (bus->sprom.boardflags_lo & B43_BFL_FEM)) {
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0004);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0800);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0004);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0C00);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0100);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0300);
> +    } else {
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0900);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0006);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0500);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0006);
> +        b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0700);
> +    }
> +    if (dev->phy.rev == 1) {
> +        b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_1, B43_LPPHY_TR_LOOKUP_5);
> +        b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_2, B43_LPPHY_TR_LOOKUP_6);
> +        b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_3, B43_LPPHY_TR_LOOKUP_7);
> +        b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_4, B43_LPPHY_TR_LOOKUP_8);
> +    }
> +    if (bus->sprom.boardflags_hi & B43_BFH_FEM_BT) &&
> +       (bus->chip_id == 0x5354) &&
> +       (bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
> +        b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
> +        b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
> +        b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
> +        b43_hf_write(dev, b43_hf_read | 0x0800ULL << 32);
> +    }
> +    if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
> +        b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x8000);
> +        b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0040);
> +        b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0x00FF, 0xA400);
> +        b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xF0FF, 0x0B00);
> +        b43_phy_maskset(dev, 0x030, 0xFFF8, 0x0007);
> +        b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFF8, 0x0003);
> +        b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFC7, 0x0020);
> +        b43_phy_mask(dev, B43_LPPHY_IDLEAFTERPKTRXTO, 0x00FF);
> +    } else { /* 5GHz */
> +        b43_phy_mask(dev, 0x448, 0x7FFF);
> +        b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFBF);
> +    }
> +    if (dev->phy.rev == 1) {
> +        tmp = b43_read(dev, B43_LPPHY_CLIPCTRTHRESH);
> +        tmp2 = (tmp & 0x03E0) >> 5
> +        tmp2 |= tmp << 5;
> +        b43_phy_write(dev, 0x4C3, tmp2);
> +        tmp = b43_read(dev, B43_LPPHY_OFDMSYNCTHRESH0);
> +        tmp2 = (tmp & 0x1F00) >> 8
> +        tmp2 |= tmp << 5;
> +        b43_phy_write(dev, 0x4C4, tmp2);
> +        tmp = b43_read(dev, B43_LPPHY_VERYLOWGAINDB);
> +        tmp2 = tmp & 0x00FF
> +        tmp2 |= tmp << 8;
> +        b43_phy_write(dev, 0x4C5, tmp2);
> +    }
>   }
> 
>   static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
> diff --git a/drivers/net/wireless/b43/phy_lp.h 
> b/drivers/net/wireless/b43/phy_lp.h
> index 18370b4..d0e67e4 100644
> --- a/drivers/net/wireless/b43/phy_lp.h
> +++ b/drivers/net/wireless/b43/phy_lp.h
> @@ -273,12 +273,16 @@
>   #define B43_LPPHY_AFE_DDFS_POINTER_INIT        B43_PHY_OFDM(0xB8) /* 
> AFE DDFS pointer init */
>   #define B43_LPPHY_AFE_DDFS_INCR_INIT        B43_PHY_OFDM(0xB9) /* AFE 
> DDFS incr init */
>   #define B43_LPPHY_MRCNOISEREDUCTION        B43_PHY_OFDM(0xBA) /* 
> mrcNoiseReduction */
> -#define B43_LPPHY_TRLOOKUP3            B43_PHY_OFDM(0xBB) /* TRLookup3 */
> -#define B43_LPPHY_TRLOOKUP4            B43_PHY_OFDM(0xBC) /* TRLookup4 */
> +#define B43_LPPHY_TR_LOOKUP_3            B43_PHY_OFDM(0xBB) /* TR 
> Lookup 3 */
> +#define B43_LPPHY_TR_LOOKUP_4            B43_PHY_OFDM(0xBC) /* TR 
> Lookup 4 */
>   #define B43_LPPHY_RADAR_FIFO_STAT        B43_PHY_OFDM(0xBD) /* Radar 
> FIFO Status */
>   #define B43_LPPHY_GPIO_OUTEN            B43_PHY_OFDM(0xBE) /* GPIO Out 
> enable */
>   #define B43_LPPHY_GPIO_SELECT            B43_PHY_OFDM(0xBF) /* GPIO 
> Select */
>   #define B43_LPPHY_GPIO_OUT            B43_PHY_OFDM(0xC0) /* GPIO Out */
> +#define B43_LPPHY_TR_LOOKUP_5            B43_PHY_OFDM(0xC7) /* TR 
> Lookup 5? */
> +#define B43_LPPHY_TR_LOOKUP_6            B43_PHY_OFDM(0xC8) /* TR 
> Lookup 6? */
> +#define B43_LPPHY_TR_LOOKUP_7            B43_PHY_OFDM(0xC9) /* TR 
> Lookup 7? */
> +#define B43_LPPHY_TR_LOOKUP_8            B43_PHY_OFDM(0xCA) /* TR 
> Lookup 8? */
> 
> 
> 
> diff --git a/drivers/net/wireless/b43/phy_n.c 
> b/drivers/net/wireless/b43/phy_n.c
> index 8bcfda5..14ad95a 100644
> --- a/drivers/net/wireless/b43/phy_n.c
> +++ b/drivers/net/wireless/b43/phy_n.c
> @@ -137,7 +137,8 @@ static void b43_radio_init2055_post(struct b43_wldev 
> *dev)
> 
>       b43_radio_mask(dev, B2055_MASTER1, 0xFFF3);
>       msleep(1);
> -    if ((sprom->revision != 4) || !(sprom->boardflags_hi & 0x0002)) {
> +    if ((sprom->revision != 4) ||
> +       !(sprom->boardflags_hi & B43_BFH_RSSIINV)) {
>           if ((binfo->vendor != PCI_VENDOR_ID_BROADCOM) ||
>               (binfo->type != 0x46D) ||
>               (binfo->rev < 0x41)) {
> 
> 
> 



-- 
Greetings, Michael.


From mb at bu3sch.de  Mon Aug  3 00:35:37 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 3 Aug 2009 00:35:37 +0200
Subject: [PATCH RESEND] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <4A7610AE.5000908@gmail.com>
References: <4A7610AE.5000908@gmail.com>
Message-ID: <200908030035.37285.mb@bu3sch.de>

On Monday 03 August 2009 00:18:22 G?bor Stefanik wrote:
> Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
> boardflags_hi values to defines.
> Implement b43_phy_copy for easier copying between registers, as needed
> by LP-PHY init.
> 
> Signed-off-by: G?bor Stefanik<netrolller.3d at gmail.com>
> Cc: Michael Buesch<mb at bu3sch.de>
> Cc: Larry Finger<larry.finger at lwfinger.net>
> ---
> 
> Hopefully this mail will survive the trip through the arcane world of Gmail's servers...
> 
> If this very-very-very-long line (including	a	few	tab	characters) doesn't get mangled, chances are that the mail didn't get mangled. More text to make this line even longer.
> 
>   b43.h        |   11 ++++++
>   phy_common.c |    7 ++++
>   phy_lp.c     |   95 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
>   phy_lp.h     |    8 +++-
>   phy_n.c      |    3 +
>   5 files changed, 120 insertions(+), 4 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
> index 4e8ad84..41ca727 100644
> --- a/drivers/net/wireless/b43/b43.h
> +++ b/drivers/net/wireless/b43/b43.h
> @@ -142,6 +142,17 @@
>   #define B43_BFL_BTCMOD			0x4000	/* BFL_BTCOEXIST is given in alternate GPIOs */
>   #define B43_BFL_ALTIQ			0x8000	/* alternate I/Q settings */
> 
> +/* SPROM boardflags_hi values */
> +#define B43_BFH_NOPA			0x0001	/* has no PA */
> +#define B43_BFH_RSSIINV			0x0002	/* RSSI uses positive slope (not TSSI) */
> +#define B43_BFH_PAREF			0x0004	/* uses the PARef LDO */
> +#define B43_BFH_3TSWITCH		0x0008	/* uses a triple throw switch shared
> +						 * with bluetooth */
> +#define B43_BFH_PHASESHIFT		0x0010	/* can support phase shifter */
> +#define B43_BFH_BUCKBOOST		0x0020	/* has buck/booster */
> +#define B43_BFH_FEM_BT			0x0040	/* has FEM and switch to share antenna
> +						 * with bluetooth */
> +
>   /* GPIO register offset, in both ChipCommon and PCI core. */
>   #define B43_GPIO_CONTROL		0x6c
> 
> diff --git a/drivers/net/wireless/b43/phy_common.c b/drivers/net/wireless/b43/phy_common.c
> index e176b6e..999e0bd 100644
> --- a/drivers/net/wireless/b43/phy_common.c
> +++ b/drivers/net/wireless/b43/phy_common.c
> @@ -240,6 +240,13 @@ void b43_phy_write(struct b43_wldev *dev, u16 reg, u16 value)
>   	dev->phy.ops->phy_write(dev, reg, value);
>   }
> 
> +void b43_phy_copy(struct b43_wldev *dev, u16 srcreg, u16 destreg)
> +{
> +	assert_mac_suspended(dev);
> +	dev->phy.ops->phy_write(dev, destreg,
> +		dev->phy.ops->phy_read(dev, srcreg));
> +}

Hm, can you reverse the srcreg/destreg order?
All C-standard copy functions use func(dest, src).
I think we should stick with it.

> +
>   void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
>   {
>   	b43_phy_write(dev, offset,
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index 58e319d..dbaa2e4 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -66,7 +66,100 @@ static void lpphy_table_init(struct b43_wldev *dev)
> 
>   static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
>   {
> -	B43_WARN_ON(1);//TODO rev<  2 not supported, yet.
> +	struct ssb_bus *bus = dev->dev->bus;
> +	struct b43_phy_lp *lpphy = dev->phy.lp;
> +	u16 tmp, tmp2;
> +
> +	if (dev->phy.rev == 1&&
                             ^
> +	   (bus->sprom.boardflags_hi&  B43_BFH_FEM_BT)) {
                                    ^
whitespaces


> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0x3F00, 0x0900);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x000A);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0400);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x000A);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0B00);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xFFC0, 0x000A);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xC0FF, 0x0900);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xFFC0, 0x000A);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xC0FF, 0x0B00);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xFFC0, 0x000A);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xC0FF, 0x0900);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xFFC0, 0x000A);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xC0FF, 0x0B00);
> +	} else if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ ||
> +		  (bus->boardinfo.type == 0x048A) || ((dev->phy.rev == 0)&&
                                                                         ^
whitespace

> +		  (bus->sprom.boardflags_lo&  B43_BFL_FEM))) {
                                           ^
whitespace

> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0001);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0400);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0001);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0500);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0800);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0A00);
> +	} else if (dev->phy.rev == 1 ||
> +		  (bus->sprom.boardflags_lo&  B43_BFL_FEM)) {
                                           ^
whitespace

> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0004);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0800);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0004);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0C00);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0100);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0300);
> +	} else {
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0900);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0006);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0500);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0006);
> +		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0700);
> +	}
> +	if (dev->phy.rev == 1) {
> +		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_1, B43_LPPHY_TR_LOOKUP_5);
> +		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_2, B43_LPPHY_TR_LOOKUP_6);
> +		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_3, B43_LPPHY_TR_LOOKUP_7);
> +		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_4, B43_LPPHY_TR_LOOKUP_8);

(Reverse them, if you reverse the meaning of b43_phy_copy())

> +	}
> +	if (bus->sprom.boardflags_hi&  B43_BFH_FEM_BT)&&
> +	   (bus->chip_id == 0x5354)&&

Lots of whitespace needed here...

> +	   (bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
> +		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
> +		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
> +		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
> +		b43_hf_write(dev, b43_hf_read | 0x0800ULL<<  32);
                                            ^^           ^  ^
b43_hf_read is not called. You OR the function pointer.
And whitespace at the wrong spot.

> +	}
> +	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
> +		b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x8000);
> +		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0040);
> +		b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0x00FF, 0xA400);
> +		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xF0FF, 0x0B00);
> +		b43_phy_maskset(dev, 0x030, 0xFFF8, 0x0007);

Any chance to define a name for the register?
Even if it's just B43_LPPHY_030 or something like that.

> +		b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFF8, 0x0003);
> +		b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFC7, 0x0020);
> +		b43_phy_mask(dev, B43_LPPHY_IDLEAFTERPKTRXTO, 0x00FF);
> +	} else { /* 5GHz */
> +		b43_phy_mask(dev, 0x448, 0x7FFF);
> +		b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFBF);
> +	}
> +	if (dev->phy.rev == 1) {
> +		tmp = b43_read(dev, B43_LPPHY_CLIPCTRTHRESH);
> +		tmp2 = (tmp&  0x03E0)>>  5
> +		tmp2 |= tmp<<  5;
> +		b43_phy_write(dev, 0x4C3, tmp2);
> +		tmp = b43_read(dev, B43_LPPHY_OFDMSYNCTHRESH0);
> +		tmp2 = (tmp&  0x1F00)>>  8
> +		tmp2 |= tmp<<  5;
> +		b43_phy_write(dev, 0x4C4, tmp2);
> +		tmp = b43_read(dev, B43_LPPHY_VERYLOWGAINDB);
> +		tmp2 = tmp&  0x00FF
> +		tmp2 |= tmp<<  8;
> +		b43_phy_write(dev, 0x4C5, tmp2);

Lots of whitespace problems in this code block.
And please define the registers. Even if you just assign numeric names (like above).
(hint: also use the B43_PHY_OFDM() macro)

> +	}
>   }
> 
>   static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
> diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
> index 18370b4..d0e67e4 100644
> --- a/drivers/net/wireless/b43/phy_lp.h
> +++ b/drivers/net/wireless/b43/phy_lp.h
> @@ -273,12 +273,16 @@
>   #define B43_LPPHY_AFE_DDFS_POINTER_INIT		B43_PHY_OFDM(0xB8) /* AFE DDFS pointer init */
>   #define B43_LPPHY_AFE_DDFS_INCR_INIT		B43_PHY_OFDM(0xB9) /* AFE DDFS incr init */
>   #define B43_LPPHY_MRCNOISEREDUCTION		B43_PHY_OFDM(0xBA) /* mrcNoiseReduction */
> -#define B43_LPPHY_TRLOOKUP3			B43_PHY_OFDM(0xBB) /* TRLookup3 */
> -#define B43_LPPHY_TRLOOKUP4			B43_PHY_OFDM(0xBC) /* TRLookup4 */
> +#define B43_LPPHY_TR_LOOKUP_3			B43_PHY_OFDM(0xBB) /* TR Lookup 3 */
> +#define B43_LPPHY_TR_LOOKUP_4			B43_PHY_OFDM(0xBC) /* TR Lookup 4 */
>   #define B43_LPPHY_RADAR_FIFO_STAT		B43_PHY_OFDM(0xBD) /* Radar FIFO Status */
>   #define B43_LPPHY_GPIO_OUTEN			B43_PHY_OFDM(0xBE) /* GPIO Out enable */
>   #define B43_LPPHY_GPIO_SELECT			B43_PHY_OFDM(0xBF) /* GPIO Select */
>   #define B43_LPPHY_GPIO_OUT			B43_PHY_OFDM(0xC0) /* GPIO Out */
> +#define B43_LPPHY_TR_LOOKUP_5			B43_PHY_OFDM(0xC7) /* TR Lookup 5 */
> +#define B43_LPPHY_TR_LOOKUP_6			B43_PHY_OFDM(0xC8) /* TR Lookup 6 */
> +#define B43_LPPHY_TR_LOOKUP_7			B43_PHY_OFDM(0xC9) /* TR Lookup 7 */
> +#define B43_LPPHY_TR_LOOKUP_8			B43_PHY_OFDM(0xCA) /* TR Lookup 8 */
> 
> 
> 
> diff --git a/drivers/net/wireless/b43/phy_n.c b/drivers/net/wireless/b43/phy_n.c
> index 8bcfda5..14ad95a 100644
> --- a/drivers/net/wireless/b43/phy_n.c
> +++ b/drivers/net/wireless/b43/phy_n.c
> @@ -137,7 +137,8 @@ static void b43_radio_init2055_post(struct b43_wldev *dev)
> 
>   	b43_radio_mask(dev, B2055_MASTER1, 0xFFF3);
>   	msleep(1);
> -	if ((sprom->revision != 4) || !(sprom->boardflags_hi&  0x0002)) {
> +	if ((sprom->revision != 4) ||
> +	   !(sprom->boardflags_hi&  B43_BFH_RSSIINV)) {
                                 ^
whitespace

>   		if ((binfo->vendor != PCI_VENDOR_ID_BROADCOM) ||
>   		    (binfo->type != 0x46D) ||
>   		    (binfo->rev<  0x41)) {
> 
> 
> 
> 



-- 
Greetings, Michael.


From mb at bu3sch.de  Mon Aug  3 11:13:37 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 3 Aug 2009 11:13:37 +0200
Subject: [PATCH RESEND] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <4A7610AE.5000908@gmail.com>
References: <4A7610AE.5000908@gmail.com>
Message-ID: <200908031113.38229.mb@bu3sch.de>

On Monday 03 August 2009 00:18:22 G?bor Stefanik wrote:
> Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
> boardflags_hi values to defines.
> Implement b43_phy_copy for easier copying between registers, as needed
> by LP-PHY init.

> +	if (bus->sprom.boardflags_hi&  B43_BFH_FEM_BT)&&
> +	   (bus->chip_id == 0x5354)&&
> +	   (bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
> +		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
> +		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
> +		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
> +		b43_hf_write(dev, b43_hf_read | 0x0800ULL<<  32);
> +	}

The HF write is wrong. Read the specification:
http://bcm-v4.sipsolutions.net/802.11/Mhf

Patch otherwise looks ok.
-- 
Greetings, Michael.


From mb at bu3sch.de  Mon Aug  3 11:15:12 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 3 Aug 2009 11:15:12 +0200
Subject: [PATCH RESEND] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <200908031113.38229.mb@bu3sch.de>
References: <4A7610AE.5000908@gmail.com> <200908031113.38229.mb@bu3sch.de>
Message-ID: <200908031115.12929.mb@bu3sch.de>

On Monday 03 August 2009 11:13:37 Michael Buesch wrote:
> On Monday 03 August 2009 00:18:22 G?bor Stefanik wrote:
> > Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
> > boardflags_hi values to defines.
> > Implement b43_phy_copy for easier copying between registers, as needed
> > by LP-PHY init.
> 
> > +	if (bus->sprom.boardflags_hi&  B43_BFH_FEM_BT)&&
> > +	   (bus->chip_id == 0x5354)&&
> > +	   (bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
> > +		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
> > +		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
> > +		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
> > +		b43_hf_write(dev, b43_hf_read | 0x0800ULL<<  32);
> > +	}
> 
> The HF write is wrong. Read the specification:
> http://bcm-v4.sipsolutions.net/802.11/Mhf
> 
> Patch otherwise looks ok.

Sorry, I replied to the wrong mail. But this does also apply to V2 patch.

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Mon Aug  3 00:24:29 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 3 Aug 2009 00:24:29 +0200
Subject: [PATCH RESEND] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <4A7610AE.5000908@gmail.com>
References: <4A7610AE.5000908@gmail.com>
Message-ID: <69e28c910908021524r1bf8d0a3s3cab303ff9fc6c0b@mail.gmail.com>

2009/8/3 G?bor Stefanik <netrolller.3d at gmail.com>:
> Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
> boardflags_hi values to defines.
> Implement b43_phy_copy for easier copying between registers, as needed
> by LP-PHY init.
>
> Signed-off-by: G?bor Stefanik<netrolller.3d at gmail.com>
> Cc: Michael Buesch<mb at bu3sch.de>
> Cc: Larry Finger<larry.finger at lwfinger.net>
> ---
>

Looks like this one survived.

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Mon Aug  3 00:08:51 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 3 Aug 2009 00:08:51 +0200
Subject: [PATCH] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <4A760DF5.6050504@gmail.com>
References: <4A760DF5.6050504@gmail.com>
Message-ID: <69e28c910908021508u46a8c807r29f89fd362a6ed49@mail.gmail.com>

Whitespace-damaged, sorry. Resend coming soon.

2009/8/3 G?bor Stefanik <netrolller.3d at gmail.com>:
> Implement baseband init for rev.0 and rev.1 LP PHYs. Convert boardflags_hi
> values to defines.
> Implement b43_phy_copy for easier copying between registers, as needed by
> LP-PHY init.
>
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> Cc: Michael Buesch <mb at bu3sch.de>
> Cc: Larry Finger <larry.finger at lwfinger.net>
> ---
> ?b43.h ? ? ? ?| ? 11 ++++++
> ?phy_common.c | ? ?7 ++++
> ?phy_lp.c ? ? | ? 95
> ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
> ?phy_lp.h ? ? | ? ?8 +++-
> ?phy_n.c ? ? ?| ? ?3 +
> ?5 files changed, 120 insertions(+), 4 deletions(-)
>
> diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
> index 4e8ad84..41ca727 100644
> --- a/drivers/net/wireless/b43/b43.h
> +++ b/drivers/net/wireless/b43/b43.h
> @@ -142,6 +142,17 @@
> ?#define B43_BFL_BTCMOD ? ? ? ? ? ?0x4000 ? ?/* BFL_BTCOEXIST is given in
> alternate GPIOs */
> ?#define B43_BFL_ALTIQ ? ? ? ? ? ?0x8000 ? ?/* alternate I/Q settings */
>
> +/* SPROM boardflags_hi values */
> +#define B43_BFH_NOPA ? ? ? ? ? ?0x0001 ? ?/* has no PA */
> +#define B43_BFH_RSSIINV ? ? ? ? ? ?0x0002 ? ?/* RSSI uses positive slope
> (not TSSI) */
> +#define B43_BFH_PAREF ? ? ? ? ? ?0x0004 ? ?/* uses the PARef LDO */
> +#define B43_BFH_3TSWITCH ? ? ? ?0x0008 ? ?/* uses a triple throw switch
> shared
> + ? ? ? ? ? ? ? ? ? ? ? ? * with bluetooth */
> +#define B43_BFH_PHASESHIFT ? ? ? ?0x0010 ? ?/* can support phase shifter */
> +#define B43_BFH_BUCKBOOST ? ? ? ?0x0020 ? ?/* has buck/booster */
> +#define B43_BFH_FEM_BT ? ? ? ? ? ?0x0040 ? ?/* has FEM and switch to share
> antenna
> + ? ? ? ? ? ? ? ? ? ? ? ? * with bluetooth */
> +
> ?/* GPIO register offset, in both ChipCommon and PCI core. */
> ?#define B43_GPIO_CONTROL ? ? ? ?0x6c
>
> diff --git a/drivers/net/wireless/b43/phy_common.c
> b/drivers/net/wireless/b43/phy_common.c
> index e176b6e..999e0bd 100644
> --- a/drivers/net/wireless/b43/phy_common.c
> +++ b/drivers/net/wireless/b43/phy_common.c
> @@ -240,6 +240,13 @@ void b43_phy_write(struct b43_wldev *dev, u16 reg, u16
> value)
> ? ? dev->phy.ops->phy_write(dev, reg, value);
> ?}
>
> +void b43_phy_copy(struct b43_wldev *dev, u16 srcreg, u16 destreg)
> +{
> + ? ?assert_mac_suspended(dev);
> + ? ?dev->phy.ops->phy_write(dev, destreg,
> + ? ? ? ?dev->phy.ops->phy_read(dev, srcreg));
> +}
> +
> ?void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
> ?{
> ? ? b43_phy_write(dev, offset,
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index 58e319d..dbaa2e4 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -66,7 +66,100 @@ static void lpphy_table_init(struct b43_wldev *dev)
>
> ?static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
> ?{
> - ? ?B43_WARN_ON(1);//TODO rev < 2 not supported, yet.
> + ? ?struct ssb_bus *bus = dev->dev->bus;
> + ? ?struct b43_phy_lp *lpphy = dev->phy.lp;
> + ? ?u16 tmp, tmp2;
> +
> + ? ?if (dev->phy.rev == 1 &&
> + ? ? ? (bus->sprom.boardflags_hi & B43_BFH_FEM_BT)) {
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0x3F00, 0x0900);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x000A);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0400);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x000A);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0B00);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xFFC0, 0x000A);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xC0FF, 0x0900);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xFFC0, 0x000A);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xC0FF, 0x0B00);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xFFC0, 0x000A);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xC0FF, 0x0900);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xFFC0, 0x000A);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xC0FF, 0x0B00);
> + ? ?} else if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ ||
> + ? ? ? ? ?(bus->boardinfo.type == 0x048A) || ((dev->phy.rev == 0) &&
> + ? ? ? ? ?(bus->sprom.boardflags_lo & B43_BFL_FEM))) {
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0001);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0400);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0001);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0500);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0800);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0A00);
> + ? ?} else if (dev->phy.rev == 1 ||
> + ? ? ? ? ?(bus->sprom.boardflags_lo & B43_BFL_FEM)) {
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0004);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0800);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0004);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0C00);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0100);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0300);
> + ? ?} else {
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0900);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0006);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0500);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0006);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0700);
> + ? ?}
> + ? ?if (dev->phy.rev == 1) {
> + ? ? ? ?b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_1, B43_LPPHY_TR_LOOKUP_5);
> + ? ? ? ?b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_2, B43_LPPHY_TR_LOOKUP_6);
> + ? ? ? ?b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_3, B43_LPPHY_TR_LOOKUP_7);
> + ? ? ? ?b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_4, B43_LPPHY_TR_LOOKUP_8);
> + ? ?}
> + ? ?if (bus->sprom.boardflags_hi & B43_BFH_FEM_BT) &&
> + ? ? ? (bus->chip_id == 0x5354) &&
> + ? ? ? (bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
> + ? ? ? ?b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
> + ? ? ? ?b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
> + ? ? ? ?b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
> + ? ? ? ?b43_hf_write(dev, b43_hf_read | 0x0800ULL << 32);
> + ? ?}
> + ? ?if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
> + ? ? ? ?b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x8000);
> + ? ? ? ?b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0040);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0x00FF, 0xA400);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xF0FF, 0x0B00);
> + ? ? ? ?b43_phy_maskset(dev, 0x030, 0xFFF8, 0x0007);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFF8, 0x0003);
> + ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFC7, 0x0020);
> + ? ? ? ?b43_phy_mask(dev, B43_LPPHY_IDLEAFTERPKTRXTO, 0x00FF);
> + ? ?} else { /* 5GHz */
> + ? ? ? ?b43_phy_mask(dev, 0x448, 0x7FFF);
> + ? ? ? ?b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFBF);
> + ? ?}
> + ? ?if (dev->phy.rev == 1) {
> + ? ? ? ?tmp = b43_read(dev, B43_LPPHY_CLIPCTRTHRESH);
> + ? ? ? ?tmp2 = (tmp & 0x03E0) >> 5
> + ? ? ? ?tmp2 |= tmp << 5;
> + ? ? ? ?b43_phy_write(dev, 0x4C3, tmp2);
> + ? ? ? ?tmp = b43_read(dev, B43_LPPHY_OFDMSYNCTHRESH0);
> + ? ? ? ?tmp2 = (tmp & 0x1F00) >> 8
> + ? ? ? ?tmp2 |= tmp << 5;
> + ? ? ? ?b43_phy_write(dev, 0x4C4, tmp2);
> + ? ? ? ?tmp = b43_read(dev, B43_LPPHY_VERYLOWGAINDB);
> + ? ? ? ?tmp2 = tmp & 0x00FF
> + ? ? ? ?tmp2 |= tmp << 8;
> + ? ? ? ?b43_phy_write(dev, 0x4C5, tmp2);
> + ? ?}
> ?}
>
> ?static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
> diff --git a/drivers/net/wireless/b43/phy_lp.h
> b/drivers/net/wireless/b43/phy_lp.h
> index 18370b4..d0e67e4 100644
> --- a/drivers/net/wireless/b43/phy_lp.h
> +++ b/drivers/net/wireless/b43/phy_lp.h
> @@ -273,12 +273,16 @@
> ?#define B43_LPPHY_AFE_DDFS_POINTER_INIT ? ? ? ?B43_PHY_OFDM(0xB8) /* AFE
> DDFS pointer init */
> ?#define B43_LPPHY_AFE_DDFS_INCR_INIT ? ? ? ?B43_PHY_OFDM(0xB9) /* AFE DDFS
> incr init */
> ?#define B43_LPPHY_MRCNOISEREDUCTION ? ? ? ?B43_PHY_OFDM(0xBA) /*
> mrcNoiseReduction */
> -#define B43_LPPHY_TRLOOKUP3 ? ? ? ? ? ?B43_PHY_OFDM(0xBB) /* TRLookup3 */
> -#define B43_LPPHY_TRLOOKUP4 ? ? ? ? ? ?B43_PHY_OFDM(0xBC) /* TRLookup4 */
> +#define B43_LPPHY_TR_LOOKUP_3 ? ? ? ? ? ?B43_PHY_OFDM(0xBB) /* TR Lookup 3
> */
> +#define B43_LPPHY_TR_LOOKUP_4 ? ? ? ? ? ?B43_PHY_OFDM(0xBC) /* TR Lookup 4
> */
> ?#define B43_LPPHY_RADAR_FIFO_STAT ? ? ? ?B43_PHY_OFDM(0xBD) /* Radar FIFO
> Status */
> ?#define B43_LPPHY_GPIO_OUTEN ? ? ? ? ? ?B43_PHY_OFDM(0xBE) /* GPIO Out
> enable */
> ?#define B43_LPPHY_GPIO_SELECT ? ? ? ? ? ?B43_PHY_OFDM(0xBF) /* GPIO Select
> */
> ?#define B43_LPPHY_GPIO_OUT ? ? ? ? ? ?B43_PHY_OFDM(0xC0) /* GPIO Out */
> +#define B43_LPPHY_TR_LOOKUP_5 ? ? ? ? ? ?B43_PHY_OFDM(0xC7) /* TR Lookup 5?
> */
> +#define B43_LPPHY_TR_LOOKUP_6 ? ? ? ? ? ?B43_PHY_OFDM(0xC8) /* TR Lookup 6?
> */
> +#define B43_LPPHY_TR_LOOKUP_7 ? ? ? ? ? ?B43_PHY_OFDM(0xC9) /* TR Lookup 7?
> */
> +#define B43_LPPHY_TR_LOOKUP_8 ? ? ? ? ? ?B43_PHY_OFDM(0xCA) /* TR Lookup 8?
> */
>
>
>
> diff --git a/drivers/net/wireless/b43/phy_n.c
> b/drivers/net/wireless/b43/phy_n.c
> index 8bcfda5..14ad95a 100644
> --- a/drivers/net/wireless/b43/phy_n.c
> +++ b/drivers/net/wireless/b43/phy_n.c
> @@ -137,7 +137,8 @@ static void b43_radio_init2055_post(struct b43_wldev
> *dev)
>
> ? ? b43_radio_mask(dev, B2055_MASTER1, 0xFFF3);
> ? ? msleep(1);
> - ? ?if ((sprom->revision != 4) || !(sprom->boardflags_hi & 0x0002)) {
> + ? ?if ((sprom->revision != 4) ||
> + ? ? ? !(sprom->boardflags_hi & B43_BFH_RSSIINV)) {
> ? ? ? ? if ((binfo->vendor != PCI_VENDOR_ID_BROADCOM) ||
> ? ? ? ? ? ? (binfo->type != 0x46D) ||
> ? ? ? ? ? ? (binfo->rev < 0x41)) {
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Mon Aug  3 01:31:29 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 3 Aug 2009 01:31:29 +0200
Subject: [PATCH V2] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <4A76210C.4040209@gmail.com>
References: <4A76210C.4040209@gmail.com>
Message-ID: <69e28c910908021631g256560c8q364674b6e907f235@mail.gmail.com>

On Mon, Aug 3, 2009 at 1:28 AM, G?bor Stefanik<netrolller.3d at gmail.com> wrote:
> Implement baseband init for rev.0 and rev.1 LP PHYs. Convert boardflags_hi
> values to defines.
> Implement b43_phy_copy for easier copying between registers, as needed by
> LP-PHY init.
>
> Signed-off-by: G?bor Stefanik<netrolller.3d at gmail.com>
> Cc: Michael Buesch<mb at bu3sch.de>
> Cc: Larry Finger<larry.finger at lwfinger.net>
> ---
> V2:
> -Reversed argument order for b43_phy_copy.
> -Named all registers, no more magic numbers.
> -Whitespace errors hopefully fixed (I hope my mailer doesn't re-introduce
> them...)

Phew! No more whitespace corruption, it seems... looks like
Thunderbird doesn't like the Linux coding style. :-)

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From Larry.Finger at lwfinger.net  Mon Aug  3 00:20:36 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 02 Aug 2009 17:20:36 -0500
Subject: [PATCH] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <4A760DF5.6050504@gmail.com>
References: <4A760DF5.6050504@gmail.com>
Message-ID: <4A761134.3010807@lwfinger.net>

G?bor Stefanik wrote:
> Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
> boardflags_hi values to defines.
> Implement b43_phy_copy for easier copying between registers, as needed
> by LP-PHY init.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> Cc: Michael Buesch <mb at bu3sch.de>
> Cc: Larry Finger <larry.finger at lwfinger.net>

Your mailer mangled the white space and wrapped long lines in the patch.

Larry


From netrolller.3d at gmail.com  Mon Aug  3 01:28:12 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Mon, 03 Aug 2009 01:28:12 +0200
Subject: [PATCH V2] b43: implement baseband init for LP-PHY <= rev1
Message-ID: <4A76210C.4040209@gmail.com>

Implement baseband init for rev.0 and rev.1 LP PHYs. Convert boardflags_hi values to defines.
Implement b43_phy_copy for easier copying between registers, as needed by LP-PHY init.

Signed-off-by: G?bor Stefanik<netrolller.3d at gmail.com>
Cc: Michael Buesch<mb at bu3sch.de>
Cc: Larry Finger<larry.finger at lwfinger.net>
---
V2:
-Reversed argument order for b43_phy_copy.
-Named all registers, no more magic numbers.
-Whitespace errors hopefully fixed (I hope my mailer doesn't re-introduce them...)

 b43.h        |   11 ++++++
 phy_common.c |    7 ++++
 phy_common.h |    5 +++
 phy_lp.c     |   94 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 phy_lp.h     |   11 +++++-
 phy_n.c      |    3 +
 6 files changed, 127 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
index 4e8ad84..41ca727 100644
--- a/drivers/net/wireless/b43/b43.h
+++ b/drivers/net/wireless/b43/b43.h
@@ -142,6 +142,17 @@
 #define B43_BFL_BTCMOD			0x4000	/* BFL_BTCOEXIST is given in alternate GPIOs */
 #define B43_BFL_ALTIQ			0x8000	/* alternate I/Q settings */
 
+/* SPROM boardflags_hi values */
+#define B43_BFH_NOPA			0x0001	/* has no PA */
+#define B43_BFH_RSSIINV			0x0002	/* RSSI uses positive slope (not TSSI) */
+#define B43_BFH_PAREF			0x0004	/* uses the PARef LDO */
+#define B43_BFH_3TSWITCH		0x0008	/* uses a triple throw switch shared
+						 * with bluetooth */
+#define B43_BFH_PHASESHIFT		0x0010	/* can support phase shifter */
+#define B43_BFH_BUCKBOOST		0x0020	/* has buck/booster */
+#define B43_BFH_FEM_BT			0x0040	/* has FEM and switch to share antenna
+						 * with bluetooth */
+
 /* GPIO register offset, in both ChipCommon and PCI core. */
 #define B43_GPIO_CONTROL		0x6c
 
diff --git a/drivers/net/wireless/b43/phy_common.c b/drivers/net/wireless/b43/phy_common.c
index e176b6e..1661b03 100644
--- a/drivers/net/wireless/b43/phy_common.c
+++ b/drivers/net/wireless/b43/phy_common.c
@@ -240,6 +240,13 @@ void b43_phy_write(struct b43_wldev *dev, u16 reg, u16 value)
 	dev->phy.ops->phy_write(dev, reg, value);
 }
 
+void b43_phy_copy(struct b43_wldev *dev, u16 destreg, u16 srcreg)
+{
+	assert_mac_suspended(dev);
+	dev->phy.ops->phy_write(dev, destreg,
+		dev->phy.ops->phy_read(dev, srcreg));
+}
+
 void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
 {
 	b43_phy_write(dev, offset,
diff --git a/drivers/net/wireless/b43/phy_common.h b/drivers/net/wireless/b43/phy_common.h
index b2d9910..c7a7d6b 100644
--- a/drivers/net/wireless/b43/phy_common.h
+++ b/drivers/net/wireless/b43/phy_common.h
@@ -291,6 +291,11 @@ u16 b43_phy_read(struct b43_wldev *dev, u16 reg);
 void b43_phy_write(struct b43_wldev *dev, u16 reg, u16 value);
 
 /**
+ * b43_phy_copy - copy contents of 16bit PHY register to another
+ */
+void b43_phy_copy(struct b43_wldev *dev, u16 destreg, u16 srcreg);
+
+/**
  * b43_phy_mask - Mask a PHY register with a mask
  */
 void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask);
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 58e319d..9653b5a 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -66,7 +66,99 @@ static void lpphy_table_init(struct b43_wldev *dev)
 
 static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 {
-	B43_WARN_ON(1);//TODO rev < 2 not supported, yet.
+	struct ssb_bus *bus = dev->dev->bus;
+	u16 tmp, tmp2;
+
+	if (dev->phy.rev == 1 &&
+	   (bus->sprom.boardflags_hi & B43_BFH_FEM_BT)) {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0x3F00, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0400);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xC0FF, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xC0FF, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xC0FF, 0x0B00);
+	} else if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ ||
+		  (bus->boardinfo.type == 0x048A) || ((dev->phy.rev == 0) &&
+		  (bus->sprom.boardflags_lo & B43_BFL_FEM))) {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0001);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0400);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0001);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0500);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0800);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0A00);
+	} else if (dev->phy.rev == 1 ||
+		  (bus->sprom.boardflags_lo & B43_BFL_FEM)) {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0004);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0800);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0004);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0C00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0100);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0300);
+	} else {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0006);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0500);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0006);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0700);
+	}
+	if (dev->phy.rev == 1) {
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_5, B43_LPPHY_TR_LOOKUP_1);
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_6, B43_LPPHY_TR_LOOKUP_2);
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_7, B43_LPPHY_TR_LOOKUP_3);
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_8, B43_LPPHY_TR_LOOKUP_4);
+	}
+	if ((bus->sprom.boardflags_hi & B43_BFH_FEM_BT) &&
+	    (bus->chip_id == 0x5354) &&
+	    (bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
+		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
+		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
+		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
+		b43_hf_write(dev, b43_hf_read(dev) | 0x0800ULL << 32);
+	}
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x8000);
+		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0040);
+		b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0x00FF, 0xA400);
+		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xF0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_SYNCPEAKCNT, 0xFFF8, 0x0007);
+		b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFF8, 0x0003);
+		b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFC7, 0x0020);
+		b43_phy_mask(dev, B43_LPPHY_IDLEAFTERPKTRXTO, 0x00FF);
+	} else { /* 5GHz */
+		b43_phy_mask(dev, B43_LPPHY_LP_PHY_CTL, 0x7FFF);
+		b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFBF);
+	}
+	if (dev->phy.rev == 1) {
+		tmp = b43_phy_read(dev, B43_LPPHY_CLIPCTRTHRESH);
+		tmp2 = (tmp & 0x03E0) >> 5;
+		tmp2 |= tmp << 5;
+		b43_phy_write(dev, B43_LPPHY_4C3, tmp2);
+		tmp = b43_phy_read(dev, B43_LPPHY_OFDMSYNCTHRESH0);
+		tmp2 = (tmp & 0x1F00) >> 8;
+		tmp2 |= tmp << 5;
+		b43_phy_write(dev, B43_LPPHY_4C4, tmp2);
+		tmp = b43_phy_read(dev, B43_LPPHY_VERYLOWGAINDB);
+		tmp2 = tmp & 0x00FF;
+		tmp2 |= tmp << 8;
+		b43_phy_write(dev, B43_LPPHY_4C5, tmp2);
+	}
 }
 
 static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 18370b4..829b2bb 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -273,12 +273,19 @@
 #define B43_LPPHY_AFE_DDFS_POINTER_INIT		B43_PHY_OFDM(0xB8) /* AFE DDFS pointer init */
 #define B43_LPPHY_AFE_DDFS_INCR_INIT		B43_PHY_OFDM(0xB9) /* AFE DDFS incr init */
 #define B43_LPPHY_MRCNOISEREDUCTION		B43_PHY_OFDM(0xBA) /* mrcNoiseReduction */
-#define B43_LPPHY_TRLOOKUP3			B43_PHY_OFDM(0xBB) /* TRLookup3 */
-#define B43_LPPHY_TRLOOKUP4			B43_PHY_OFDM(0xBC) /* TRLookup4 */
+#define B43_LPPHY_TR_LOOKUP_3			B43_PHY_OFDM(0xBB) /* TR Lookup 3 */
+#define B43_LPPHY_TR_LOOKUP_4			B43_PHY_OFDM(0xBC) /* TR Lookup 4 */
 #define B43_LPPHY_RADAR_FIFO_STAT		B43_PHY_OFDM(0xBD) /* Radar FIFO Status */
 #define B43_LPPHY_GPIO_OUTEN			B43_PHY_OFDM(0xBE) /* GPIO Out enable */
 #define B43_LPPHY_GPIO_SELECT			B43_PHY_OFDM(0xBF) /* GPIO Select */
 #define B43_LPPHY_GPIO_OUT			B43_PHY_OFDM(0xC0) /* GPIO Out */
+#define B43_LPPHY_4C3				B43_PHY_OFDM(0xC3) /* unknown, used during BB init */
+#define B43_LPPHY_4C4				B43_PHY_OFDM(0xC4) /* unknown, used during BB init */
+#define B43_LPPHY_4C5				B43_PHY_OFDM(0xC5) /* unknown, used during BB init */
+#define B43_LPPHY_TR_LOOKUP_5			B43_PHY_OFDM(0xC7) /* TR Lookup 5 */
+#define B43_LPPHY_TR_LOOKUP_6			B43_PHY_OFDM(0xC8) /* TR Lookup 6 */
+#define B43_LPPHY_TR_LOOKUP_7			B43_PHY_OFDM(0xC9) /* TR Lookup 7 */
+#define B43_LPPHY_TR_LOOKUP_8			B43_PHY_OFDM(0xCA) /* TR Lookup 8 */
 
 
 
diff --git a/drivers/net/wireless/b43/phy_n.c b/drivers/net/wireless/b43/phy_n.c
index 8bcfda5..14ad95a 100644
--- a/drivers/net/wireless/b43/phy_n.c
+++ b/drivers/net/wireless/b43/phy_n.c
@@ -137,7 +137,8 @@ static void b43_radio_init2055_post(struct b43_wldev *dev)
 
 	b43_radio_mask(dev, B2055_MASTER1, 0xFFF3);
 	msleep(1);
-	if ((sprom->revision != 4) || !(sprom->boardflags_hi & 0x0002)) {
+	if ((sprom->revision != 4) ||
+	   !(sprom->boardflags_hi & B43_BFH_RSSIINV)) {
 		if ((binfo->vendor != PCI_VENDOR_ID_BROADCOM) ||
 		    (binfo->type != 0x46D) ||
 		    (binfo->rev < 0x41)) {




From netrolller.3d at gmail.com  Mon Aug  3 15:55:29 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 3 Aug 2009 15:55:29 +0200
Subject: [PATCH RESEND] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <200908031115.12929.mb@bu3sch.de>
References: <4A7610AE.5000908@gmail.com> <200908031113.38229.mb@bu3sch.de> 
	<200908031115.12929.mb@bu3sch.de>
Message-ID: <69e28c910908030655g4ea70567y30ca2e68a77b872b@mail.gmail.com>

On Mon, Aug 3, 2009 at 11:15 AM, Michael Buesch<mb at bu3sch.de> wrote:
> On Monday 03 August 2009 11:13:37 Michael Buesch wrote:
>> On Monday 03 August 2009 00:18:22 G?bor Stefanik wrote:
>> > Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
>> > boardflags_hi values to defines.
>> > Implement b43_phy_copy for easier copying between registers, as needed
>> > by LP-PHY init.
>>
>> > + ? if (bus->sprom.boardflags_hi& ?B43_BFH_FEM_BT)&&
>> > + ? ? ?(bus->chip_id == 0x5354)&&
>> > + ? ? ?(bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
>> > + ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
>> > + ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
>> > + ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
>> > + ? ? ? ? ? b43_hf_write(dev, b43_hf_read | 0x0800ULL<< ?32);
>> > + ? }
>>
>> The HF write is wrong. Read the specification:
>> http://bcm-v4.sipsolutions.net/802.11/Mhf
>>
>> Patch otherwise looks ok.
>
> Sorry, I replied to the wrong mail. But this does also apply to V2 patch.
>
> --
> Greetings, Michael.
>

In V2, this line is as follows (b43_hf_read corrected):

b43_hf_write(dev, b43_hf_read(dev) | 0x0800ULL << 32)

The command in the specs is this:

mhf(2, 0x800, 0x800, 1)

2 means B43_SHM_SH_HOSTFHI, 0x800 is the bit to set, and 1 is
allbands, which, per Larry, can be ignored in our current
implementation (it is specific to the caching behavior of the mips
driver).


From mb at bu3sch.de  Mon Aug  3 22:38:17 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 3 Aug 2009 22:38:17 +0200
Subject: [PATCH RESEND] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <69e28c910908030655g4ea70567y30ca2e68a77b872b@mail.gmail.com>
References: <4A7610AE.5000908@gmail.com> <200908031115.12929.mb@bu3sch.de>
	<69e28c910908030655g4ea70567y30ca2e68a77b872b@mail.gmail.com>
Message-ID: <200908032238.18030.mb@bu3sch.de>

On Monday 03 August 2009 15:55:29 G?bor Stefanik wrote:
> On Mon, Aug 3, 2009 at 11:15 AM, Michael Buesch<mb at bu3sch.de> wrote:
> > On Monday 03 August 2009 11:13:37 Michael Buesch wrote:
> >> On Monday 03 August 2009 00:18:22 G?bor Stefanik wrote:
> >> > Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
> >> > boardflags_hi values to defines.
> >> > Implement b43_phy_copy for easier copying between registers, as needed
> >> > by LP-PHY init.
> >>
> >> > + ? if (bus->sprom.boardflags_hi& ?B43_BFH_FEM_BT)&&
> >> > + ? ? ?(bus->chip_id == 0x5354)&&
> >> > + ? ? ?(bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
> >> > + ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
> >> > + ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
> >> > + ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
> >> > + ? ? ? ? ? b43_hf_write(dev, b43_hf_read | 0x0800ULL<< ?32);
> >> > + ? }
> >>
> >> The HF write is wrong. Read the specification:
> >> http://bcm-v4.sipsolutions.net/802.11/Mhf
> >>
> >> Patch otherwise looks ok.
> >
> > Sorry, I replied to the wrong mail. But this does also apply to V2 patch.
> >
> > --
> > Greetings, Michael.
> >
> 
> In V2, this line is as follows (b43_hf_read corrected):
> 
> b43_hf_write(dev, b43_hf_read(dev) | 0x0800ULL << 32)
> 
> The command in the specs is this:
> 
> mhf(2, 0x800, 0x800, 1)
> 
> 2 means B43_SHM_SH_HOSTFHI, 0x800 is the bit to set, and 1 is
> allbands, which, per Larry, can be ignored in our current
> implementation (it is specific to the caching behavior of the mips
> driver).
> 
> From what I read in b43_hf_write, writing to HOSTFHI can be achieved
> by left-shifting by 32 (16 for HOSTFMI).
> 
> Is the problem that we write all 3 hostflags registers here?
> 
> (BTW are there any other known host flags? If there are, maybe we
> should #define them.)
> 

My point is that update_mhf does not write to actual hardware, as far
as I understand the code. Larry, can you please explain that part of the
specs?

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Mon Aug  3 22:41:44 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 3 Aug 2009 22:41:44 +0200
Subject: [PATCH RESEND] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <200908032238.18030.mb@bu3sch.de>
References: <4A7610AE.5000908@gmail.com> <200908031115.12929.mb@bu3sch.de> 
	<69e28c910908030655g4ea70567y30ca2e68a77b872b@mail.gmail.com> 
	<200908032238.18030.mb@bu3sch.de>
Message-ID: <69e28c910908031341n439384b4ned41f2983ab1de29@mail.gmail.com>

2009/8/3 Michael Buesch <mb at bu3sch.de>:
> On Monday 03 August 2009 15:55:29 G?bor Stefanik wrote:
>> On Mon, Aug 3, 2009 at 11:15 AM, Michael Buesch<mb at bu3sch.de> wrote:
>> > On Monday 03 August 2009 11:13:37 Michael Buesch wrote:
>> >> On Monday 03 August 2009 00:18:22 G?bor Stefanik wrote:
>> >> > Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
>> >> > boardflags_hi values to defines.
>> >> > Implement b43_phy_copy for easier copying between registers, as needed
>> >> > by LP-PHY init.
>> >>
>> >> > + ? if (bus->sprom.boardflags_hi& ?B43_BFH_FEM_BT)&&
>> >> > + ? ? ?(bus->chip_id == 0x5354)&&
>> >> > + ? ? ?(bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
>> >> > + ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
>> >> > + ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
>> >> > + ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
>> >> > + ? ? ? ? ? b43_hf_write(dev, b43_hf_read | 0x0800ULL<< ?32);
>> >> > + ? }
>> >>
>> >> The HF write is wrong. Read the specification:
>> >> http://bcm-v4.sipsolutions.net/802.11/Mhf
>> >>
>> >> Patch otherwise looks ok.
>> >
>> > Sorry, I replied to the wrong mail. But this does also apply to V2 patch.
>> >
>> > --
>> > Greetings, Michael.
>> >
>>
>> In V2, this line is as follows (b43_hf_read corrected):
>>
>> b43_hf_write(dev, b43_hf_read(dev) | 0x0800ULL << 32)
>>
>> The command in the specs is this:
>>
>> mhf(2, 0x800, 0x800, 1)
>>
>> 2 means B43_SHM_SH_HOSTFHI, 0x800 is the bit to set, and 1 is
>> allbands, which, per Larry, can be ignored in our current
>> implementation (it is specific to the caching behavior of the mips
>> driver).
>>
>> From what I read in b43_hf_write, writing to HOSTFHI can be achieved
>> by left-shifting by 32 (16 for HOSTFMI).
>>
>> Is the problem that we write all 3 hostflags registers here?
>>
>> (BTW are there any other known host flags? If there are, maybe we
>> should #define them.)
>>
>
> My point is that update_mhf does not write to actual hardware, as far
> as I understand the code. Larry, can you please explain that part of the
> specs?
>


From Larry.Finger at lwfinger.net  Mon Aug  3 22:58:30 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 03 Aug 2009 15:58:30 -0500
Subject: [PATCH RESEND] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <69e28c910908031341n439384b4ned41f2983ab1de29@mail.gmail.com>
References: <4A7610AE.5000908@gmail.com> <200908031115.12929.mb@bu3sch.de>
	<69e28c910908030655g4ea70567y30ca2e68a77b872b@mail.gmail.com>
	<200908032238.18030.mb@bu3sch.de>
	<69e28c910908031341n439384b4ned41f2983ab1de29@mail.gmail.com>
Message-ID: <4A774F76.6020207@lwfinger.net>

G?bor Stefanik wrote:
> 2009/8/3 Michael Buesch <mb at bu3sch.de>:
>> On Monday 03 August 2009 15:55:29 G?bor Stefanik wrote:
>>> On Mon, Aug 3, 2009 at 11:15 AM, Michael Buesch<mb at bu3sch.de> wrote:
>>>> On Monday 03 August 2009 11:13:37 Michael Buesch wrote:
>>>>> On Monday 03 August 2009 00:18:22 G?bor Stefanik wrote:
>>>>>> Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
>>>>>> boardflags_hi values to defines.
>>>>>> Implement b43_phy_copy for easier copying between registers, as needed
>>>>>> by LP-PHY init.
>>>>>> +   if (bus->sprom.boardflags_hi&  B43_BFH_FEM_BT)&&
>>>>>> +      (bus->chip_id == 0x5354)&&
>>>>>> +      (bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
>>>>>> +           b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
>>>>>> +           b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
>>>>>> +           b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
>>>>>> +           b43_hf_write(dev, b43_hf_read | 0x0800ULL<<  32);
>>>>>> +   }
>>>>> The HF write is wrong. Read the specification:
>>>>> http://bcm-v4.sipsolutions.net/802.11/Mhf
>>>>>
>>>>> Patch otherwise looks ok.
>>>> Sorry, I replied to the wrong mail. But this does also apply to V2 patch.
>>>>
>>>> --
>>>> Greetings, Michael.
>>>>
>>> In V2, this line is as follows (b43_hf_read corrected):
>>>
>>> b43_hf_write(dev, b43_hf_read(dev) | 0x0800ULL << 32)
>>>
>>> The command in the specs is this:
>>>
>>> mhf(2, 0x800, 0x800, 1)
>>>
>>> 2 means B43_SHM_SH_HOSTFHI, 0x800 is the bit to set, and 1 is
>>> allbands, which, per Larry, can be ignored in our current
>>> implementation (it is specific to the caching behavior of the mips
>>> driver).
>>>
>>> From what I read in b43_hf_write, writing to HOSTFHI can be achieved
>>> by left-shifting by 32 (16 for HOSTFMI).
>>>
>>> Is the problem that we write all 3 hostflags registers here?
>>>
>>> (BTW are there any other known host flags? If there are, maybe we
>>> should #define them.)
>>>
>> My point is that update_mhf does not write to actual hardware, as far
>> as I understand the code. Larry, can you please explain that part of the
>> specs?
>>
> 
>>From 802.11/Mhf:
> "If core->clk is not zero AND band->mhfs[idx] is not equal to tmp:
>    1. Write band->mhfs[idx] to Shared Memory Address addr[idx]"
> 
> This looks to me like it does indeed write to SHM, though the actual
> mhf() tries to avoid writing to SHM if possible, while b43_hf_write
> doesn't perform this optimization. (We don't have a band->mhfs, nor a
> bandstate[] array.)

G?bor states it the way the Broadcom routine is written. They have the
flags divided into 3 16-bit values - high, middle, and low. The values
are kept in arrays - one set is for the current band and the other is
for both bands. When the routine is entered, the appropriate quantity
is saved in a temporary, then the array value is maskset. Only when
the resulting value changes is the shared memory location updated. The
implication is that shared memory writes are expensive. Is that true?

Larry


From mb at bu3sch.de  Mon Aug  3 23:16:30 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 3 Aug 2009 23:16:30 +0200
Subject: [PATCH RESEND] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <4A774F76.6020207@lwfinger.net>
References: <4A7610AE.5000908@gmail.com>
	<69e28c910908031341n439384b4ned41f2983ab1de29@mail.gmail.com>
	<4A774F76.6020207@lwfinger.net>
Message-ID: <200908032316.30237.mb@bu3sch.de>

On Monday 03 August 2009 22:58:30 Larry Finger wrote:
> G?bor states it the way the Broadcom routine is written. They have the
> flags divided into 3 16-bit values - high, middle, and low. The values
> are kept in arrays - one set is for the current band and the other is
> for both bands. When the routine is entered, the appropriate quantity
> is saved in a temporary, then the array value is maskset. Only when
> the resulting value changes is the shared memory location updated. The
> implication is that shared memory writes are expensive. Is that true?

No. I think it has other reasons.

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Mon Aug  3 23:34:09 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 3 Aug 2009 23:34:09 +0200
Subject: [PATCH RESEND] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <200908032316.30237.mb@bu3sch.de>
References: <4A7610AE.5000908@gmail.com>
	<69e28c910908031341n439384b4ned41f2983ab1de29@mail.gmail.com> 
	<4A774F76.6020207@lwfinger.net> <200908032316.30237.mb@bu3sch.de>
Message-ID: <69e28c910908031434q53fd7d6jb346f49927a634a7@mail.gmail.com>

On Mon, Aug 3, 2009 at 11:16 PM, Michael Buesch<mb at bu3sch.de> wrote:
> On Monday 03 August 2009 22:58:30 Larry Finger wrote:
>> G?bor states it the way the Broadcom routine is written. They have the
>> flags divided into 3 16-bit values - high, middle, and low. The values
>> are kept in arrays - one set is for the current band and the other is
>> for both bands. When the routine is entered, the appropriate quantity
>> is saved in a temporary, then the array value is maskset. Only when
>> the resulting value changes is the shared memory location updated. The
>> implication is that shared memory writes are expensive. Is that true?
>
> No. I think it has other reasons.
>
> --
> Greetings, Michael.
>

In that case, is the code correct:

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From linville at tuxdriver.com  Tue Aug  4 18:05:58 2009
From: linville at tuxdriver.com (John W. Linville)
Date: Tue, 4 Aug 2009 12:05:58 -0400
Subject: [PATCH] remove wrong probe_resp_plcp write
In-Reply-To: <200907312238.15705.mb@bu3sch.de>
References: <83a869cd0907311335h3065547aqc736573a663b6d42@mail.gmail.com>
	<200907312238.15705.mb@bu3sch.de>
Message-ID: <20090804160558.GC4995@tuxdriver.com>

On Fri, Jul 31, 2009 at 10:38:14PM +0200, Michael Buesch wrote:
> On Friday 31 July 2009 22:35:49 gregor kowski wrote:
> > The tkip hw support uncovered a bug in b43_write_probe_resp_template : it is
> > writing at the wrong shm offset, it is in the B43_SHM_SH_TKIPTSCTTAK zone. This
> > patch comments these writes.
> > 
> > Signed-off-by: Gregor Kowski <gregor.kowski at gmail.com>
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

  CC [M]  drivers/net/wireless/b43/main.o
drivers/net/wireless/b43/main.c:1432: warning: ?b43_write_probe_resp_plcp? defined but not used

Comment it out too?  Or are you going to fix the block that has been
commented-out here?

John
-- 
John W. Linville		Someday the world will need a hero, and you
linville at tuxdriver.com			might be all we have.  Be ready.
			?Viva Honduras Libre!


From zajec5polish at gmail.com  Tue Aug  4 21:37:36 2009
From: zajec5polish at gmail.com (=?UTF-8?B?UmFmYcWCIE1pxYJlY2tp?=)
Date: Tue, 4 Aug 2009 21:37:36 +0200
Subject: 
In-Reply-To: <4A70F4D9.9020403@lwfinger.net>
References: <a23fe9cc0907290917p1a835dbs8595ce8a8b0330b6@mail.gmail.com>
	<4A707AF7.6070202@lwfinger.net>
	<69e28c910907290946v160800a6lf43e7728a8edc1fd@mail.gmail.com>
	<4A7083BE.9080807@lwfinger.net>
	<a23fe9cc0907291451x72729eecy6865b3ab200973b@mail.gmail.com>
	<4A70F4D9.9020403@lwfinger.net>
Message-ID: <14b026160908041237r6a162e1fm77feb6384df0914d@mail.gmail.com>

2009/7/30 Larry Finger <Larry.Finger at lwfinger.net>:
> Thanks for the info. There is a possibility that your device will not
> work even with compat-wireless-old. If that happens, please let me
> know and I'll make a patch for you to try.

I'd appreciate making your discussion somehow public, if you don't
mind. Brian, can you use "Reply to all" function, please?

-- 
Rafa? Mi?ecki


From mb at bu3sch.de  Tue Aug  4 22:27:45 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Aug 2009 22:27:45 +0200
Subject: [PATCH] remove wrong probe_resp_plcp write
In-Reply-To: <20090804160558.GC4995@tuxdriver.com>
References: <83a869cd0907311335h3065547aqc736573a663b6d42@mail.gmail.com>
	<200907312238.15705.mb@bu3sch.de>
	<20090804160558.GC4995@tuxdriver.com>
Message-ID: <200908042227.46237.mb@bu3sch.de>

On Tuesday 04 August 2009 18:05:58 John W. Linville wrote:
> On Fri, Jul 31, 2009 at 10:38:14PM +0200, Michael Buesch wrote:
> > On Friday 31 July 2009 22:35:49 gregor kowski wrote:
> > > The tkip hw support uncovered a bug in b43_write_probe_resp_template : it is
> > > writing at the wrong shm offset, it is in the B43_SHM_SH_TKIPTSCTTAK zone. This
> > > patch comments these writes.
> > > 
> > > Signed-off-by: Gregor Kowski <gregor.kowski at gmail.com>
> > 
> > Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
>   CC [M]  drivers/net/wireless/b43/main.o
> drivers/net/wireless/b43/main.c:1432: warning: ?b43_write_probe_resp_plcp? defined but not used
> 
> Comment it out too?  Or are you going to fix the block that has been
> commented-out here?

No, please add
#if 0
void b43_write_probe_resp_plcp(...)
{
...
}
#endif /* 0 */

to comment out the function, too.
The probe response offload is currently not supported by mac80211.

-- 
Greetings, Michael.


From johannes at sipsolutions.net  Tue Aug  4 22:33:03 2009
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 04 Aug 2009 22:33:03 +0200
Subject: [PATCH] remove wrong probe_resp_plcp write
In-Reply-To: <200908042227.46237.mb@bu3sch.de>
References: <83a869cd0907311335h3065547aqc736573a663b6d42@mail.gmail.com>
	<200907312238.15705.mb@bu3sch.de> <20090804160558.GC4995@tuxdriver.com>
	<200908042227.46237.mb@bu3sch.de>
Message-ID: <1249417983.24787.8.camel@johannes.local>

On Tue, 2009-08-04 at 22:27 +0200, Michael Buesch wrote:
> On Tuesday 04 August 2009 18:05:58 John W. Linville wrote:
> > On Fri, Jul 31, 2009 at 10:38:14PM +0200, Michael Buesch wrote:
> > > On Friday 31 July 2009 22:35:49 gregor kowski wrote:
> > > > The tkip hw support uncovered a bug in b43_write_probe_resp_template : it is
> > > > writing at the wrong shm offset, it is in the B43_SHM_SH_TKIPTSCTTAK zone. This
> > > > patch comments these writes.
> > > > 
> > > > Signed-off-by: Gregor Kowski <gregor.kowski at gmail.com>
> > > 
> > > Signed-off-by: Michael Buesch <mb at bu3sch.de>
> > 
> >   CC [M]  drivers/net/wireless/b43/main.o
> > drivers/net/wireless/b43/main.c:1432: warning: ?b43_write_probe_resp_plcp? defined but not used
> > 
> > Comment it out too?  Or are you going to fix the block that has been
> > commented-out here?
> 
> No, please add
> #if 0
> void b43_write_probe_resp_plcp(...)
> {
> ...
> }
> #endif /* 0 */
> 
> to comment out the function, too.
> The probe response offload is currently not supported by mac80211.

Just remove it -- if we need it back we can find it in the git archives,
and it's rather unlikely that we're going to add that functionality to
mac80211 and hostapd unless you'll push it.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20090804/6b621e46/attachment.pgp>

From gregor.kowski at gmail.com  Tue Aug  4 23:54:42 2009
From: gregor.kowski at gmail.com (gregor kowski)
Date: Tue, 4 Aug 2009 23:54:42 +0200
Subject: [RESEND] [PATCHv2] b43 add harware tkip
In-Reply-To: <200907312308.31066.mb@bu3sch.de>
References: <83a869cd0907271349h248204at74cc1603419fc83b@mail.gmail.com>
	<200907281808.35906.mb@bu3sch.de>
	<83a869cd0907311404o793c1733p43e936437a923340@mail.gmail.com>
	<200907312308.31066.mb@bu3sch.de>
Message-ID: <83a869cd0908041454i474b0ee4hfb770c7c5166be7f@mail.gmail.com>

On 7/31/09, Michael Buesch <mb at bu3sch.de> wrote:
> On Friday 31 July 2009 23:04:17 gregor kowski wrote:
>> Hi Michael,
>>
>> > It's mapped to 4, because you removed the old API support.
>> > (I'm not sure whether we want to remove that support, yet. Gimme some
>> > time
>> > on it...)
>> >
>> Does the old API still useful ?
>
> Well, I'm not sure. Why do we remove it at all? It just avoids one single
> if condition in your tkip patch, doesn't it?
>
because you ask it : "We should probably remove that new_kidx_api crap
alltogether." [1] :)
There is really bugs in the current code. You could see it by enabling
B43_DBG_KEYS.
With the current code and new API, you will see that 54 pairwise keys
are dumped, not only 50.


[1]
> >> +     /* FIXME : for b43_new_kidx_api, there can be 54 key
> >> +      * instead of 50 in RCMTA and TKIPTSCTTAK.
> >> +      */
> >
> > I don't understand this comment.
> if  b43_new_kidx_api is true :
> - we set max_nr_keys to 58
> - we program B43_MMIO_RCMTA_COUNT to 50
> - in b43_key_write we can allocate key up to index 58 (4 for default,
> 54 for sta)
>
> But there is only 50 entries for TKIPTSCTTAK, and a comment on bcm-v4
> suggest there is 50 entries for RCMTA. So if there more than 50
> station we will overflow RCMTA and TKIPTSCTTAK.

Yeah well. The key handling is pretty weird.
There are 50 pairwise keys available. max_nr_keys includes pairwise
keys, group keys (4)
and another copy of the group keys (4) used with older firmware. So we
end up at 58.

To summarize it, in practice we have 50 pairwise keys and 4 group
keys. You can ignore
the additional 4 "rx keys" as they are not used in recent fw and are
just a copy of the
group keys.

> So the fix will be do to something like
> dev->max_nr_keys = (dev->dev->id.revision >= 5) ? 58 : 20;
> if (b43_new_kidx_api())
> dev->max_nr_keys -= 4;

Hm, I don't think this is correct. There are lots of weird assumptions
all over the code.
We should probably remove that new_kidx_api crap alltogether.


From netrolller.3d at gmail.com  Tue Aug  4 23:57:32 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Tue, 04 Aug 2009 23:57:32 +0200
Subject: [PATCH] b43: Add LP 2063 radio init
Message-ID: <4A78AECC.1090006@gmail.com>

Add B2063 radio init code and tables for LP-PHY.
Rename structures common between B2062 and B2063 to B206X.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---

 phy_lp.c       |   13 +
 tables_lpphy.c |  428 +++++++++++++++++++++++++++++++++++++++++++++++++--------
 tables_lpphy.h |    1 
 3 files changed, 386 insertions(+), 56 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 9653b5a..5d50943 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -333,7 +333,17 @@ static void lpphy_2062_init(struct b43_wldev *dev)
 /* Initialize the 2063 radio. */
 static void lpphy_2063_init(struct b43_wldev *dev)
 {
-	//TODO
+	b2063_upload_init_table(dev);
+	b43_radio_write(dev, B2063_LOGEN_SP5, 0);
+	b43_radio_set(dev, B2063_COMM8, 0x38);
+	b43_radio_write(dev, B2063_REG_SP1, 0x56);
+	b43_radio_mask(dev, B2063_RX_BB_CTL2, ~0x2);
+	b43_radio_write(dev, B2063_PA_SP7, 0);
+	b43_radio_write(dev, B2063_TX_RF_SP6, 0x20);
+	b43_radio_write(dev, B2063_TX_RF_SP9, 0x40);
+	b43_radio_write(dev, B2063_PA_SP3, 0xa0);
+	b43_radio_write(dev, B2063_PA_SP4, 0xa0);
+	b43_radio_write(dev, B2063_PA_SP2, 0x18);
 }
 
 static void lpphy_sync_stx(struct b43_wldev *dev)
@@ -533,6 +543,7 @@ static void lpphy_tx_pctl_init(struct b43_wldev *dev)
 static int b43_lpphy_op_init(struct b43_wldev *dev)
 {
 	/* TODO: band SPROM */
+	/* TODO: tables init */
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
 	//TODO calibrate RC
diff --git a/drivers/net/wireless/b43/tables_lpphy.c b/drivers/net/wireless/b43/tables_lpphy.c
index 4ea734d..cadfe81 100644
--- a/drivers/net/wireless/b43/tables_lpphy.c
+++ b/drivers/net/wireless/b43/tables_lpphy.c
@@ -28,22 +28,22 @@
 #include "phy_lp.h"
 
 
-/* Entry of the 2062 radio init table */
-struct b2062_init_tab_entry {
+/* Entry of the 2062/2063 radio init table */
+struct b206x_init_tab_entry {
 	u16 offset;
 	u16 value_a;
 	u16 value_g;
 	u8 flags;
 };
-#define B2062_FLAG_A	0x01 /* Flag: Init in A mode */
-#define B2062_FLAG_G	0x02 /* Flag: Init in G mode */
+#define B206X_FLAG_A	0x01 /* Flag: Init in A mode */
+#define B206X_FLAG_G	0x02 /* Flag: Init in G mode */
 
-static const struct b2062_init_tab_entry b2062_init_tab[] = {
+static const struct b206x_init_tab_entry b2062_init_tab[] = {
 	/* { .offset = B2062_N_COMM1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = 0x0001, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_COMM2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_COMM3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_N_COMM4, .value_a = 0x0001, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_N_COMM4, .value_a = 0x0001, .value_g = 0x0000, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_N_COMM5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_COMM6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_COMM7, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
@@ -56,42 +56,42 @@ static const struct b2062_init_tab_entry b2062_init_tab[] = {
 	/* { .offset = B2062_N_COMM14, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_COMM15, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_PDN_CTL0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_N_PDN_CTL1, .value_a = 0x0000, .value_g = 0x00CA, .flags = B2062_FLAG_G, },
+	{ .offset = B2062_N_PDN_CTL1, .value_a = 0x0000, .value_g = 0x00CA, .flags = B206X_FLAG_G, },
 	/* { .offset = B2062_N_PDN_CTL2, .value_a = 0x0018, .value_g = 0x0018, .flags = 0, }, */
-	{ .offset = B2062_N_PDN_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_N_PDN_CTL4, .value_a = 0x0015, .value_g = 0x002A, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_N_PDN_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_N_PDN_CTL4, .value_a = 0x0015, .value_g = 0x002A, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_N_GEN_CTL0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_IQ_CALIB, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
-	{ .offset = B2062_N_LGENC, .value_a = 0x00DB, .value_g = 0x00FF, .flags = B2062_FLAG_A, },
+	{ .offset = B2062_N_LGENC, .value_a = 0x00DB, .value_g = 0x00FF, .flags = B206X_FLAG_A, },
 	/* { .offset = B2062_N_LGENA_LPF, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
 	/* { .offset = B2062_N_LGENA_BIAS0, .value_a = 0x0041, .value_g = 0x0041, .flags = 0, }, */
 	/* { .offset = B2062_N_LGNEA_BIAS1, .value_a = 0x0002, .value_g = 0x0002, .flags = 0, }, */
 	/* { .offset = B2062_N_LGENA_CTL0, .value_a = 0x0032, .value_g = 0x0032, .flags = 0, }, */
 	/* { .offset = B2062_N_LGENA_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_LGENA_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_N_LGENA_TUNE0, .value_a = 0x00DD, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_N_LGENA_TUNE0, .value_a = 0x00DD, .value_g = 0x0000, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_N_LGENA_TUNE1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_N_LGENA_TUNE2, .value_a = 0x00DD, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_N_LGENA_TUNE3, .value_a = 0x0077, .value_g = 0x00B5, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_N_LGENA_CTL3, .value_a = 0x0000, .value_g = 0x00FF, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_N_LGENA_TUNE2, .value_a = 0x00DD, .value_g = 0x0000, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_N_LGENA_TUNE3, .value_a = 0x0077, .value_g = 0x00B5, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_N_LGENA_CTL3, .value_a = 0x0000, .value_g = 0x00FF, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_N_LGENA_CTL4, .value_a = 0x001F, .value_g = 0x001F, .flags = 0, }, */
 	/* { .offset = B2062_N_LGENA_CTL5, .value_a = 0x0032, .value_g = 0x0032, .flags = 0, }, */
 	/* { .offset = B2062_N_LGENA_CTL6, .value_a = 0x0032, .value_g = 0x0032, .flags = 0, }, */
-	{ .offset = B2062_N_LGENA_CTL7, .value_a = 0x0033, .value_g = 0x0033, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_N_LGENA_CTL7, .value_a = 0x0033, .value_g = 0x0033, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_N_RXA_CTL0, .value_a = 0x0009, .value_g = 0x0009, .flags = 0, }, */
-	{ .offset = B2062_N_RXA_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = B2062_FLAG_G, },
+	{ .offset = B2062_N_RXA_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_G, },
 	/* { .offset = B2062_N_RXA_CTL2, .value_a = 0x0018, .value_g = 0x0018, .flags = 0, }, */
 	/* { .offset = B2062_N_RXA_CTL3, .value_a = 0x0027, .value_g = 0x0027, .flags = 0, }, */
 	/* { .offset = B2062_N_RXA_CTL4, .value_a = 0x0028, .value_g = 0x0028, .flags = 0, }, */
 	/* { .offset = B2062_N_RXA_CTL5, .value_a = 0x0007, .value_g = 0x0007, .flags = 0, }, */
 	/* { .offset = B2062_N_RXA_CTL6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_RXA_CTL7, .value_a = 0x0008, .value_g = 0x0008, .flags = 0, }, */
-	{ .offset = B2062_N_RXBB_CTL0, .value_a = 0x0082, .value_g = 0x0080, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_N_RXBB_CTL0, .value_a = 0x0082, .value_g = 0x0080, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_N_RXBB_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_RXBB_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_RXBB_GAIN0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_N_RXBB_GAIN1, .value_a = 0x0004, .value_g = 0x0004, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_N_RXBB_GAIN2, .value_a = 0x0000, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_N_RXBB_GAIN1, .value_a = 0x0004, .value_g = 0x0004, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_N_RXBB_GAIN2, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_N_RXBB_GAIN3, .value_a = 0x0011, .value_g = 0x0011, .flags = 0, }, */
 	/* { .offset = B2062_N_RXBB_RSSI0, .value_a = 0x0043, .value_g = 0x0043, .flags = 0, }, */
 	/* { .offset = B2062_N_RXBB_RSSI1, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
@@ -112,8 +112,8 @@ static const struct b2062_init_tab_entry b2062_init_tab[] = {
 	/* { .offset = B2062_N_TX_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_TX_CTL2, .value_a = 0x0084, .value_g = 0x0084, .flags = 0, }, */
 	/* { .offset = B2062_N_TX_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_N_TX_CTL4, .value_a = 0x0003, .value_g = 0x0003, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_N_TX_CTL5, .value_a = 0x0002, .value_g = 0x0002, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_N_TX_CTL4, .value_a = 0x0003, .value_g = 0x0003, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_N_TX_CTL5, .value_a = 0x0002, .value_g = 0x0002, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_N_TX_CTL6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_TX_CTL7, .value_a = 0x0058, .value_g = 0x0058, .flags = 0, }, */
 	/* { .offset = B2062_N_TX_CTL8, .value_a = 0x0082, .value_g = 0x0082, .flags = 0, }, */
@@ -121,7 +121,7 @@ static const struct b2062_init_tab_entry b2062_init_tab[] = {
 	/* { .offset = B2062_N_TX_CTL_A, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_N_TX_GC2G, .value_a = 0x00FF, .value_g = 0x00FF, .flags = 0, }, */
 	/* { .offset = B2062_N_TX_GC5G, .value_a = 0x00FF, .value_g = 0x00FF, .flags = 0, }, */
-	{ .offset = B2062_N_TX_TUNE, .value_a = 0x0088, .value_g = 0x001B, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_N_TX_TUNE, .value_a = 0x0088, .value_g = 0x001B, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_N_TX_PAD, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
 	/* { .offset = B2062_N_TX_PGA, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
 	/* { .offset = B2062_N_TX_PADAUX, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
@@ -150,7 +150,7 @@ static const struct b2062_init_tab_entry b2062_init_tab[] = {
 	/* { .offset = B2062_S_RADIO_ID_CODE, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_COMM2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_COMM3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_S_COMM4, .value_a = 0x0001, .value_g = 0x0000, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_S_COMM4, .value_a = 0x0001, .value_g = 0x0000, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_S_COMM5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_COMM6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_COMM7, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
@@ -162,24 +162,24 @@ static const struct b2062_init_tab_entry b2062_init_tab[] = {
 	/* { .offset = B2062_S_COMM13, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_COMM14, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_COMM15, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_S_PDS_CTL0, .value_a = 0x00FF, .value_g = 0x00FF, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_S_PDS_CTL0, .value_a = 0x00FF, .value_g = 0x00FF, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_S_PDS_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_PDS_CTL2, .value_a = 0x008E, .value_g = 0x008E, .flags = 0, }, */
 	/* { .offset = B2062_S_PDS_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_BG_CTL0, .value_a = 0x0006, .value_g = 0x0006, .flags = 0, }, */
 	/* { .offset = B2062_S_BG_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_BG_CTL2, .value_a = 0x0011, .value_g = 0x0011, .flags = 0, }, */
-	{ .offset = B2062_S_LGENG_CTL0, .value_a = 0x00F8, .value_g = 0x00D8, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_LGENG_CTL1, .value_a = 0x003C, .value_g = 0x0024, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_S_LGENG_CTL0, .value_a = 0x00F8, .value_g = 0x00D8, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_LGENG_CTL1, .value_a = 0x003C, .value_g = 0x0024, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_S_LGENG_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_LGENG_CTL3, .value_a = 0x0041, .value_g = 0x0041, .flags = 0, }, */
 	/* { .offset = B2062_S_LGENG_CTL4, .value_a = 0x0002, .value_g = 0x0002, .flags = 0, }, */
 	/* { .offset = B2062_S_LGENG_CTL5, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
 	/* { .offset = B2062_S_LGENG_CTL6, .value_a = 0x0022, .value_g = 0x0022, .flags = 0, }, */
 	/* { .offset = B2062_S_LGENG_CTL7, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_S_LGENG_CTL8, .value_a = 0x0088, .value_g = 0x0080, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_S_LGENG_CTL8, .value_a = 0x0088, .value_g = 0x0080, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_S_LGENG_CTL9, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
-	{ .offset = B2062_S_LGENG_CTL10, .value_a = 0x0088, .value_g = 0x0080, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_S_LGENG_CTL10, .value_a = 0x0088, .value_g = 0x0080, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_S_LGENG_CTL11, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_REFPLL_CTL0, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_REFPLL_CTL1, .value_a = 0x0007, .value_g = 0x0007, .flags = 0, }, */
@@ -198,41 +198,41 @@ static const struct b2062_init_tab_entry b2062_init_tab[] = {
 	/* { .offset = B2062_S_REFPLL_CTL14, .value_a = 0x0075, .value_g = 0x0075, .flags = 0, }, */
 	/* { .offset = B2062_S_REFPLL_CTL15, .value_a = 0x00B4, .value_g = 0x00B4, .flags = 0, }, */
 	/* { .offset = B2062_S_REFPLL_CTL16, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_S_RFPLL_CTL0, .value_a = 0x0098, .value_g = 0x0098, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL1, .value_a = 0x0010, .value_g = 0x0010, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL0, .value_a = 0x0098, .value_g = 0x0098, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL1, .value_a = 0x0010, .value_g = 0x0010, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_S_RFPLL_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_RFPLL_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_RFPLL_CTL4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_S_RFPLL_CTL5, .value_a = 0x0043, .value_g = 0x0043, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL6, .value_a = 0x0047, .value_g = 0x0047, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL7, .value_a = 0x000C, .value_g = 0x000C, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL8, .value_a = 0x0011, .value_g = 0x0011, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL9, .value_a = 0x0011, .value_g = 0x0011, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL10, .value_a = 0x000E, .value_g = 0x000E, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL11, .value_a = 0x0008, .value_g = 0x0008, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL12, .value_a = 0x0033, .value_g = 0x0033, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL13, .value_a = 0x000A, .value_g = 0x000A, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL14, .value_a = 0x0006, .value_g = 0x0006, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL5, .value_a = 0x0043, .value_g = 0x0043, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL6, .value_a = 0x0047, .value_g = 0x0047, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL7, .value_a = 0x000C, .value_g = 0x000C, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL8, .value_a = 0x0011, .value_g = 0x0011, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL9, .value_a = 0x0011, .value_g = 0x0011, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL10, .value_a = 0x000E, .value_g = 0x000E, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL11, .value_a = 0x0008, .value_g = 0x0008, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL12, .value_a = 0x0033, .value_g = 0x0033, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL13, .value_a = 0x000A, .value_g = 0x000A, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL14, .value_a = 0x0006, .value_g = 0x0006, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_S_RFPLL_CTL15, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_RFPLL_CTL16, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_RFPLL_CTL17, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_S_RFPLL_CTL18, .value_a = 0x003E, .value_g = 0x003E, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL19, .value_a = 0x0013, .value_g = 0x0013, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL18, .value_a = 0x003E, .value_g = 0x003E, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL19, .value_a = 0x0013, .value_g = 0x0013, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_S_RFPLL_CTL20, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_S_RFPLL_CTL21, .value_a = 0x0062, .value_g = 0x0062, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL22, .value_a = 0x0007, .value_g = 0x0007, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL23, .value_a = 0x0016, .value_g = 0x0016, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL24, .value_a = 0x005C, .value_g = 0x005C, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL25, .value_a = 0x0095, .value_g = 0x0095, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL21, .value_a = 0x0062, .value_g = 0x0062, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL22, .value_a = 0x0007, .value_g = 0x0007, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL23, .value_a = 0x0016, .value_g = 0x0016, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL24, .value_a = 0x005C, .value_g = 0x005C, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL25, .value_a = 0x0095, .value_g = 0x0095, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_S_RFPLL_CTL26, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_RFPLL_CTL27, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_RFPLL_CTL28, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_RFPLL_CTL29, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_S_RFPLL_CTL30, .value_a = 0x00A0, .value_g = 0x00A0, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL31, .value_a = 0x0004, .value_g = 0x0004, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL30, .value_a = 0x00A0, .value_g = 0x00A0, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL31, .value_a = 0x0004, .value_g = 0x0004, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_S_RFPLL_CTL32, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
-	{ .offset = B2062_S_RFPLL_CTL33, .value_a = 0x00CC, .value_g = 0x00CC, .flags = B2062_FLAG_A | B2062_FLAG_G, },
-	{ .offset = B2062_S_RFPLL_CTL34, .value_a = 0x0007, .value_g = 0x0007, .flags = B2062_FLAG_A | B2062_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL33, .value_a = 0x00CC, .value_g = 0x00CC, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2062_S_RFPLL_CTL34, .value_a = 0x0007, .value_g = 0x0007, .flags = B206X_FLAG_A | B206X_FLAG_G, },
 	/* { .offset = B2062_S_RXG_CNT0, .value_a = 0x0010, .value_g = 0x0010, .flags = 0, }, */
 	/* { .offset = B2062_S_RXG_CNT1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_RXG_CNT2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
@@ -241,7 +241,7 @@ static const struct b2062_init_tab_entry b2062_init_tab[] = {
 	/* { .offset = B2062_S_RXG_CNT5, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
 	/* { .offset = B2062_S_RXG_CNT6, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
 	/* { .offset = B2062_S_RXG_CNT7, .value_a = 0x0005, .value_g = 0x0005, .flags = 0, }, */
-	{ .offset = B2062_S_RXG_CNT8, .value_a = 0x000F, .value_g = 0x000F, .flags = B2062_FLAG_A, },
+	{ .offset = B2062_S_RXG_CNT8, .value_a = 0x000F, .value_g = 0x000F, .flags = B206X_FLAG_A, },
 	/* { .offset = B2062_S_RXG_CNT9, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
 	/* { .offset = B2062_S_RXG_CNT10, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
 	/* { .offset = B2062_S_RXG_CNT11, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
@@ -253,19 +253,337 @@ static const struct b2062_init_tab_entry b2062_init_tab[] = {
 	/* { .offset = B2062_S_RXG_CNT17, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
 };
 
+static const struct b206x_init_tab_entry b2063_init_tab[] = {
+	{ .offset = B2063_COMM1, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_G, },
+	/* { .offset = B2063_COMM2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_COMM3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_COMM4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_COMM5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_COMM6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_COMM7, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_COMM8, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_COMM9, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_COMM10, .value_a = 0x0001, .value_g = 0x0000, .flags = B206X_FLAG_A, },
+	/* { .offset = B2063_COMM11, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_COMM12, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_COMM13, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_COMM14, .value_a = 0x0006, .value_g = 0x0006, .flags = 0, }, */
+	/* { .offset = B2063_COMM15, .value_a = 0x000f, .value_g = 0x000f, .flags = 0, }, */
+	{ .offset = B2063_COMM16, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_G, },
+	{ .offset = B2063_COMM17, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_G, },
+	{ .offset = B2063_COMM18, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_G, },
+	{ .offset = B2063_COMM19, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_G, },
+	{ .offset = B2063_COMM20, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_G, },
+	{ .offset = B2063_COMM21, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_G, },
+	{ .offset = B2063_COMM22, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_G, },
+	{ .offset = B2063_COMM23, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_G, },
+	{ .offset = B2063_COMM24, .value_a = 0x0000, .value_g = 0x0000, .flags = B206X_FLAG_G, },
+	/* { .offset = B2063_PWR_SWITCH_CTL, .value_a = 0x007f, .value_g = 0x007f, .flags = 0, }, */
+	/* { .offset = B2063_PLL_SP1, .value_a = 0x003f, .value_g = 0x003f, .flags = 0, }, */
+	/* { .offset = B2063_PLL_SP2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_LOGEN_SP1, .value_a = 0x00e8, .value_g = 0x00d4, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2063_LOGEN_SP2, .value_a = 0x00a7, .value_g = 0x0053, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_LOGEN_SP3, .value_a = 0x00ff, .value_g = 0x00ff, .flags = 0, }, */
+	{ .offset = B2063_LOGEN_SP4, .value_a = 0x00f0, .value_g = 0x000f, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_LOGEN_SP5, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
+	{ .offset = B2063_G_RX_SP1, .value_a = 0x001f, .value_g = 0x005e, .flags = B206X_FLAG_G, },
+	{ .offset = B2063_G_RX_SP2, .value_a = 0x007f, .value_g = 0x007e, .flags = B206X_FLAG_G, },
+	{ .offset = B2063_G_RX_SP3, .value_a = 0x0030, .value_g = 0x00f0, .flags = B206X_FLAG_G, },
+	/* { .offset = B2063_G_RX_SP4, .value_a = 0x0035, .value_g = 0x0035, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_SP5, .value_a = 0x003f, .value_g = 0x003f, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_SP6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_G_RX_SP7, .value_a = 0x007f, .value_g = 0x007f, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_G_RX_SP8, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_SP9, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_G_RX_SP10, .value_a = 0x000c, .value_g = 0x000c, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_G_RX_SP11, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_A_RX_SP1, .value_a = 0x003c, .value_g = 0x003f, .flags = B206X_FLAG_A, },
+	{ .offset = B2063_A_RX_SP2, .value_a = 0x00fc, .value_g = 0x00fe, .flags = B206X_FLAG_A, },
+	/* { .offset = B2063_A_RX_SP3, .value_a = 0x00ff, .value_g = 0x00ff, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_SP4, .value_a = 0x00ff, .value_g = 0x00ff, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_SP5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_SP6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_A_RX_SP7, .value_a = 0x0008, .value_g = 0x0008, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_RX_BB_SP1, .value_a = 0x000f, .value_g = 0x000f, .flags = 0, }, */
+	/* { .offset = B2063_RX_BB_SP2, .value_a = 0x0022, .value_g = 0x0022, .flags = 0, }, */
+	/* { .offset = B2063_RX_BB_SP3, .value_a = 0x00a8, .value_g = 0x00a8, .flags = 0, }, */
+	{ .offset = B2063_RX_BB_SP4, .value_a = 0x0060, .value_g = 0x0060, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_RX_BB_SP5, .value_a = 0x0011, .value_g = 0x0011, .flags = 0, }, */
+	/* { .offset = B2063_RX_BB_SP6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_RX_BB_SP7, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_RX_BB_SP8, .value_a = 0x0030, .value_g = 0x0030, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_TX_RF_SP1, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP2, .value_a = 0x0003, .value_g = 0x0003, .flags = 0, }, */
+	{ .offset = B2063_TX_RF_SP3, .value_a = 0x000c, .value_g = 0x000b, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2063_TX_RF_SP4, .value_a = 0x0010, .value_g = 0x000f, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_TX_RF_SP5, .value_a = 0x000f, .value_g = 0x000f, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP6, .value_a = 0x0080, .value_g = 0x0080, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP7, .value_a = 0x0068, .value_g = 0x0068, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP8, .value_a = 0x0068, .value_g = 0x0068, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP9, .value_a = 0x0080, .value_g = 0x0080, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP10, .value_a = 0x00ff, .value_g = 0x00ff, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP11, .value_a = 0x0003, .value_g = 0x0003, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP12, .value_a = 0x0038, .value_g = 0x0038, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP13, .value_a = 0x00ff, .value_g = 0x00ff, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP14, .value_a = 0x0038, .value_g = 0x0038, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP15, .value_a = 0x00c0, .value_g = 0x00c0, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP16, .value_a = 0x00ff, .value_g = 0x00ff, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_SP17, .value_a = 0x00ff, .value_g = 0x00ff, .flags = 0, }, */
+	{ .offset = B2063_PA_SP1, .value_a = 0x003d, .value_g = 0x00fd, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_PA_SP2, .value_a = 0x000c, .value_g = 0x000c, .flags = 0, }, */
+	/* { .offset = B2063_PA_SP3, .value_a = 0x0096, .value_g = 0x0096, .flags = 0, }, */
+	/* { .offset = B2063_PA_SP4, .value_a = 0x005a, .value_g = 0x005a, .flags = 0, }, */
+	/* { .offset = B2063_PA_SP5, .value_a = 0x007f, .value_g = 0x007f, .flags = 0, }, */
+	/* { .offset = B2063_PA_SP6, .value_a = 0x007f, .value_g = 0x007f, .flags = 0, }, */
+	/* { .offset = B2063_PA_SP7, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
+	{ .offset = B2063_TX_BB_SP1, .value_a = 0x0002, .value_g = 0x0002, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_TX_BB_SP2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_TX_BB_SP3, .value_a = 0x0030, .value_g = 0x0030, .flags = 0, }, */
+	/* { .offset = B2063_REG_SP1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_BANDGAP_CTL1, .value_a = 0x0056, .value_g = 0x0056, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_BANDGAP_CTL2, .value_a = 0x0006, .value_g = 0x0006, .flags = 0, }, */
+	/* { .offset = B2063_LPO_CTL1, .value_a = 0x000e, .value_g = 0x000e, .flags = 0, }, */
+	/* { .offset = B2063_RC_CALIB_CTL1, .value_a = 0x007e, .value_g = 0x007e, .flags = 0, }, */
+	/* { .offset = B2063_RC_CALIB_CTL2, .value_a = 0x0015, .value_g = 0x0015, .flags = 0, }, */
+	/* { .offset = B2063_RC_CALIB_CTL3, .value_a = 0x000f, .value_g = 0x000f, .flags = 0, }, */
+	/* { .offset = B2063_RC_CALIB_CTL4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_RC_CALIB_CTL5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_RC_CALIB_CTL6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_RC_CALIB_CTL7, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_RC_CALIB_CTL8, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_RC_CALIB_CTL9, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_RC_CALIB_CTL10, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_CALNRST, .value_a = 0x0004, .value_g = 0x0004, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_IN_PLL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_IN_PLL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_CP1, .value_a = 0x00cf, .value_g = 0x00cf, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_CP2, .value_a = 0x0059, .value_g = 0x0059, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_CP3, .value_a = 0x0007, .value_g = 0x0007, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_CP4, .value_a = 0x0042, .value_g = 0x0042, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_LF1, .value_a = 0x00db, .value_g = 0x00db, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_LF2, .value_a = 0x0094, .value_g = 0x0094, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_LF3, .value_a = 0x0028, .value_g = 0x0028, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_LF4, .value_a = 0x0063, .value_g = 0x0063, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_SG1, .value_a = 0x0007, .value_g = 0x0007, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_SG2, .value_a = 0x00d3, .value_g = 0x00d3, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_SG3, .value_a = 0x00b1, .value_g = 0x00b1, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_SG4, .value_a = 0x003b, .value_g = 0x003b, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_SG5, .value_a = 0x0006, .value_g = 0x0006, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_VCO1, .value_a = 0x0058, .value_g = 0x0058, .flags = 0, }, */
+	{ .offset = B2063_PLL_JTAG_PLL_VCO2, .value_a = 0x00f7, .value_g = 0x00f7, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_PLL_JTAG_PLL_VCO_CALIB1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_VCO_CALIB2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_VCO_CALIB3, .value_a = 0x0002, .value_g = 0x0002, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_VCO_CALIB4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_VCO_CALIB5, .value_a = 0x0009, .value_g = 0x0009, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_VCO_CALIB6, .value_a = 0x0005, .value_g = 0x0005, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_VCO_CALIB7, .value_a = 0x0016, .value_g = 0x0016, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_VCO_CALIB8, .value_a = 0x006b, .value_g = 0x006b, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_VCO_CALIB9, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_VCO_CALIB10, .value_a = 0x00b3, .value_g = 0x00b3, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_XTAL_12, .value_a = 0x0004, .value_g = 0x0004, .flags = 0, }, */
+	/* { .offset = B2063_PLL_JTAG_PLL_XTAL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_ACL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_ACL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_ACL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_ACL4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_ACL5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_INPUTS, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_WAITCNT, .value_a = 0x0002, .value_g = 0x0002, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_OVR1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_OVR2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_OVAL1, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_OVAL2, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_OVAL3, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_OVAL4, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_OVAL5, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_OVAL6, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_OVAL7, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CALVLD1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CALVLD2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CVAL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CVAL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CVAL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CVAL4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CVAL5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CVAL6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LO_CALIB_CVAL7, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_CALIB_EN, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_PEAKDET1, .value_a = 0x00ff, .value_g = 0x00ff, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_RCCR1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_VCOBUF1, .value_a = 0x0060, .value_g = 0x0060, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_MIXER1, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_MIXER2, .value_a = 0x000c, .value_g = 0x000c, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_BUF1, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_BUF2, .value_a = 0x000c, .value_g = 0x000c, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_DIV1, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_DIV2, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_DIV3, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_CBUFRX1, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_CBUFRX2, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_CBUFTX1, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_CBUFTX2, .value_a = 0x0066, .value_g = 0x0066, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_IDAC1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_SPARE1, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_SPARE2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_LOGEN_SPARE3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_1ST1, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_1ST2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_1ST3, .value_a = 0x0005, .value_g = 0x0005, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_2ND1, .value_a = 0x0030, .value_g = 0x0030, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_2ND2, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_2ND3, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_2ND4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_2ND5, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_2ND6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_2ND7, .value_a = 0x0035, .value_g = 0x0035, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_2ND8, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_PS1, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_PS2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_PS3, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_PS4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_PS5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_MIX1, .value_a = 0x0044, .value_g = 0x0044, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_MIX2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_G_RX_MIX3, .value_a = 0x0071, .value_g = 0x0071, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2063_G_RX_MIX4, .value_a = 0x0071, .value_g = 0x0071, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_G_RX_MIX5, .value_a = 0x0003, .value_g = 0x0003, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_MIX6, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_MIX7, .value_a = 0x0044, .value_g = 0x0044, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_MIX8, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_PDET1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_SPARES1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_SPARES2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_G_RX_SPARES3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_1ST1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_A_RX_1ST2, .value_a = 0x00f0, .value_g = 0x0030, .flags = B206X_FLAG_A, },
+	/* { .offset = B2063_A_RX_1ST3, .value_a = 0x0005, .value_g = 0x0005, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_1ST4, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_1ST5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_2ND1, .value_a = 0x0005, .value_g = 0x0005, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_2ND2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_2ND3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_2ND4, .value_a = 0x0005, .value_g = 0x0005, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_2ND5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_2ND6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_2ND7, .value_a = 0x0005, .value_g = 0x0005, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_PS1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_PS2, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_PS3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_PS4, .value_a = 0x0033, .value_g = 0x0033, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_PS5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_A_RX_PS6, .value_a = 0x0077, .value_g = 0x0077, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_A_RX_MIX1, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_MIX2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_MIX3, .value_a = 0x0044, .value_g = 0x0044, .flags = 0, }, */
+	{ .offset = B2063_A_RX_MIX4, .value_a = 0x0003, .value_g = 0x0003, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2063_A_RX_MIX5, .value_a = 0x000f, .value_g = 0x000f, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	{ .offset = B2063_A_RX_MIX6, .value_a = 0x000f, .value_g = 0x000f, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_A_RX_MIX7, .value_a = 0x0044, .value_g = 0x0044, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_MIX8, .value_a = 0x0001, .value_g = 0x0001, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_PWRDET1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_SPARE1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_SPARE2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_A_RX_SPARE3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_RX_TIA_CTL1, .value_a = 0x0077, .value_g = 0x0077, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_RX_TIA_CTL2, .value_a = 0x0058, .value_g = 0x0058, .flags = 0, }, */
+	{ .offset = B2063_RX_TIA_CTL3, .value_a = 0x0077, .value_g = 0x0077, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_RX_TIA_CTL4, .value_a = 0x0058, .value_g = 0x0058, .flags = 0, }, */
+	/* { .offset = B2063_RX_TIA_CTL5, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_RX_TIA_CTL6, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_RX_BB_CTL1, .value_a = 0x0074, .value_g = 0x0074, .flags = 0, }, */
+	{ .offset = B2063_RX_BB_CTL2, .value_a = 0x0004, .value_g = 0x0004, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_RX_BB_CTL3, .value_a = 0x00a2, .value_g = 0x00a2, .flags = 0, }, */
+	/* { .offset = B2063_RX_BB_CTL4, .value_a = 0x00aa, .value_g = 0x00aa, .flags = 0, }, */
+	/* { .offset = B2063_RX_BB_CTL5, .value_a = 0x0024, .value_g = 0x0024, .flags = 0, }, */
+	/* { .offset = B2063_RX_BB_CTL6, .value_a = 0x00a9, .value_g = 0x00a9, .flags = 0, }, */
+	/* { .offset = B2063_RX_BB_CTL7, .value_a = 0x0028, .value_g = 0x0028, .flags = 0, }, */
+	/* { .offset = B2063_RX_BB_CTL8, .value_a = 0x0010, .value_g = 0x0010, .flags = 0, }, */
+	/* { .offset = B2063_RX_BB_CTL9, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL1, .value_a = 0x0080, .value_g = 0x0080, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_IDAC_LO_RF_I, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_IDAC_LO_RF_Q, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_IDAC_LO_BB_I, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_IDAC_LO_BB_Q, .value_a = 0x0088, .value_g = 0x0088, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL2, .value_a = 0x0080, .value_g = 0x0080, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL3, .value_a = 0x0038, .value_g = 0x0038, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL4, .value_a = 0x00b8, .value_g = 0x00b8, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL5, .value_a = 0x0080, .value_g = 0x0080, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL6, .value_a = 0x0038, .value_g = 0x0038, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL7, .value_a = 0x0078, .value_g = 0x0078, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL8, .value_a = 0x00c0, .value_g = 0x00c0, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL9, .value_a = 0x0003, .value_g = 0x0003, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL10, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL14, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_TX_RF_CTL15, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_PA_CTL1, .value_a = 0x0000, .value_g = 0x0004, .flags = B206X_FLAG_A, },
+	/* { .offset = B2063_PA_CTL2, .value_a = 0x000c, .value_g = 0x000c, .flags = 0, }, */
+	/* { .offset = B2063_PA_CTL3, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PA_CTL4, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PA_CTL5, .value_a = 0x0096, .value_g = 0x0096, .flags = 0, }, */
+	/* { .offset = B2063_PA_CTL6, .value_a = 0x0077, .value_g = 0x0077, .flags = 0, }, */
+	/* { .offset = B2063_PA_CTL7, .value_a = 0x005a, .value_g = 0x005a, .flags = 0, }, */
+	/* { .offset = B2063_PA_CTL8, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PA_CTL9, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PA_CTL10, .value_a = 0x0021, .value_g = 0x0021, .flags = 0, }, */
+	/* { .offset = B2063_PA_CTL11, .value_a = 0x0070, .value_g = 0x0070, .flags = 0, }, */
+	/* { .offset = B2063_PA_CTL12, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_PA_CTL13, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_TX_BB_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_TX_BB_CTL2, .value_a = 0x00b3, .value_g = 0x00b3, .flags = 0, }, */
+	/* { .offset = B2063_TX_BB_CTL3, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
+	/* { .offset = B2063_TX_BB_CTL4, .value_a = 0x000b, .value_g = 0x000b, .flags = 0, }, */
+	/* { .offset = B2063_GPIO_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	{ .offset = B2063_VREG_CTL1, .value_a = 0x0003, .value_g = 0x0003, .flags = B206X_FLAG_A | B206X_FLAG_G, },
+	/* { .offset = B2063_AMUX_CTL1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_IQ_CALIB_GVAR, .value_a = 0x00b3, .value_g = 0x00b3, .flags = 0, }, */
+	/* { .offset = B2063_IQ_CALIB_CTL1, .value_a = 0x0055, .value_g = 0x0055, .flags = 0, }, */
+	/* { .offset = B2063_IQ_CALIB_CTL2, .value_a = 0x0030, .value_g = 0x0030, .flags = 0, }, */
+	/* { .offset = B2063_TEMPSENSE_CTL1, .value_a = 0x0046, .value_g = 0x0046, .flags = 0, }, */
+	/* { .offset = B2063_TEMPSENSE_CTL2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_TX_RX_LOOPBACK1, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_TX_RX_LOOPBACK2, .value_a = 0x0000, .value_g = 0x0000, .flags = 0, }, */
+	/* { .offset = B2063_EXT_TSSI_CTL1, .value_a = 0x0021, .value_g = 0x0021, .flags = 0, }, */
+	/* { .offset = B2063_EXT_TSSI_CTL2, .value_a = 0x0023, .value_g = 0x0023, .flags = 0, }, */
+	/* { .offset = B2063_AFE_CTL , .value_a = 0x0002, .value_g = 0x0002, .flags = 0, }, */
+};
+
 void b2062_upload_init_table(struct b43_wldev *dev)
 {
-	const struct b2062_init_tab_entry *e;
+	const struct b206x_init_tab_entry *e;
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(b2062_init_tab); i++) {
 		e = &b2062_init_tab[i];
 		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
-			if (!(e->flags & B2062_FLAG_G))
+			if (!(e->flags & B206X_FLAG_G))
+				continue;
+			b43_radio_write(dev, e->offset, e->value_g);
+		} else {
+			if (!(e->flags & B206X_FLAG_A))
+				continue;
+			b43_radio_write(dev, e->offset, e->value_a);
+		}
+	}
+}
+
+void b2063_upload_init_table(struct b43_wldev *dev)
+{
+	const struct b206x_init_tab_entry *e;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(b2063_init_tab); i++) {
+		e = &b2063_init_tab[i];
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+			if (!(e->flags & B206X_FLAG_G))
 				continue;
 			b43_radio_write(dev, e->offset, e->value_g);
 		} else {
-			if (!(e->flags & B2062_FLAG_A))
+			if (!(e->flags & B206X_FLAG_A))
 				continue;
 			b43_radio_write(dev, e->offset, e->value_a);
 		}
diff --git a/drivers/net/wireless/b43/tables_lpphy.h b/drivers/net/wireless/b43/tables_lpphy.h
index 0b8d028..52ce32f 100644
--- a/drivers/net/wireless/b43/tables_lpphy.h
+++ b/drivers/net/wireless/b43/tables_lpphy.h
@@ -26,6 +26,7 @@ void b43_lptab_write_bulk(struct b43_wldev *dev, u32 offset,
 			  unsigned int nr_elements, const void *data);
 
 void b2062_upload_init_table(struct b43_wldev *dev);
+void b2063_upload_init_table(struct b43_wldev *dev);
 
 
 #endif /* B43_TABLES_LPPHY_H_ */




From mb at bu3sch.de  Tue Aug  4 23:58:15 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Aug 2009 23:58:15 +0200
Subject: [RESEND] [PATCHv2] b43 add harware tkip
In-Reply-To: <83a869cd0908041454i474b0ee4hfb770c7c5166be7f@mail.gmail.com>
References: <83a869cd0907271349h248204at74cc1603419fc83b@mail.gmail.com>
	<200907312308.31066.mb@bu3sch.de>
	<83a869cd0908041454i474b0ee4hfb770c7c5166be7f@mail.gmail.com>
Message-ID: <200908042358.15966.mb@bu3sch.de>

On Tuesday 04 August 2009 23:54:42 gregor kowski wrote:
> On 7/31/09, Michael Buesch <mb at bu3sch.de> wrote:
> > On Friday 31 July 2009 23:04:17 gregor kowski wrote:
> >> Hi Michael,
> >>
> >> > It's mapped to 4, because you removed the old API support.
> >> > (I'm not sure whether we want to remove that support, yet. Gimme some
> >> > time
> >> > on it...)
> >> >
> >> Does the old API still useful ?
> >
> > Well, I'm not sure. Why do we remove it at all? It just avoids one single
> > if condition in your tkip patch, doesn't it?
> >
> because you ask it : "We should probably remove that new_kidx_api crap
> alltogether." [1] :)

<quote> probably </quote>

> There is really bugs in the current code.

You always talk about "bugs". What are these "bugs"? Is it just the wrong
max_nr_keys assignment? That's trivial to fix.


-- 
Greetings, Michael.


From gregor.kowski at gmail.com  Tue Aug  4 23:58:45 2009
From: gregor.kowski at gmail.com (gregor kowski)
Date: Tue, 4 Aug 2009 23:58:45 +0200
Subject: [PATCH] remove wrong probe_resp_plcp write
In-Reply-To: <1249417983.24787.8.camel@johannes.local>
References: <83a869cd0907311335h3065547aqc736573a663b6d42@mail.gmail.com>
	<200907312238.15705.mb@bu3sch.de>
	<20090804160558.GC4995@tuxdriver.com>
	<200908042227.46237.mb@bu3sch.de>
	<1249417983.24787.8.camel@johannes.local>
Message-ID: <83a869cd0908041458n1f23f100pee5a6b3c4c3f11e4@mail.gmail.com>

On 8/4/09, Johannes Berg <johannes at sipsolutions.net> wrote:
> On Tue, 2009-08-04 at 22:27 +0200, Michael Buesch wrote:
>
> Just remove it -- if we need it back we can find it in the git archives,
> and it's rather unlikely that we're going to add that functionality to
> mac80211 and hostapd unless you'll push it.
>
What should be removed ?
b43_write_probe_resp_template and b43_write_probe_resp_plcp ?

Gregor


From mb at bu3sch.de  Wed Aug  5 00:01:08 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 5 Aug 2009 00:01:08 +0200
Subject: [PATCH] b43: Add LP 2063 radio init
In-Reply-To: <4A78AECC.1090006@gmail.com>
References: <4A78AECC.1090006@gmail.com>
Message-ID: <200908050001.08452.mb@bu3sch.de>

On Tuesday 04 August 2009 23:57:32 G?bor Stefanik wrote:
> Add B2063 radio init code and tables for LP-PHY.
> Rename structures common between B2062 and B2063 to B206X.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

ack

-- 
Greetings, Michael.


From gregor.kowski at gmail.com  Wed Aug  5 00:03:11 2009
From: gregor.kowski at gmail.com (gregor kowski)
Date: Wed, 5 Aug 2009 00:03:11 +0200
Subject: [RESEND] [PATCHv2] b43 add harware tkip
In-Reply-To: <200908042358.15966.mb@bu3sch.de>
References: <83a869cd0907271349h248204at74cc1603419fc83b@mail.gmail.com>
	<200907312308.31066.mb@bu3sch.de>
	<83a869cd0908041454i474b0ee4hfb770c7c5166be7f@mail.gmail.com>
	<200908042358.15966.mb@bu3sch.de>
Message-ID: <83a869cd0908041503i74a7bd11uf85706aeaf95b611@mail.gmail.com>

On 8/4/09, Michael Buesch <mb at bu3sch.de> wrote:
> On Tuesday 04 August 2009 23:54:42 gregor kowski wrote:
>> On 7/31/09, Michael Buesch <mb at bu3sch.de> wrote:
>> > On Friday 31 July 2009 23:04:17 gregor kowski wrote:
>> >> Hi Michael,
>
>> There is really bugs in the current code.
>
> You always talk about "bugs". What are these "bugs"? Is it just the wrong
> max_nr_keys assignment? That's trivial to fix.
>
So [1] is ok ?

Thanks,

Gregor

[1]
> So the fix will be do to something like
> dev->max_nr_keys = (dev->dev->id.revision >= 5) ? 58 : 20;
> if (b43_new_kidx_api())
> dev->max_nr_keys -= 4;


From mb at bu3sch.de  Wed Aug  5 00:04:05 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 5 Aug 2009 00:04:05 +0200
Subject: [PATCH] remove wrong probe_resp_plcp write
In-Reply-To: <83a869cd0908041458n1f23f100pee5a6b3c4c3f11e4@mail.gmail.com>
References: <83a869cd0907311335h3065547aqc736573a663b6d42@mail.gmail.com>
	<1249417983.24787.8.camel@johannes.local>
	<83a869cd0908041458n1f23f100pee5a6b3c4c3f11e4@mail.gmail.com>
Message-ID: <200908050004.05429.mb@bu3sch.de>

On Tuesday 04 August 2009 23:58:45 gregor kowski wrote:
> On 8/4/09, Johannes Berg <johannes at sipsolutions.net> wrote:
> > On Tue, 2009-08-04 at 22:27 +0200, Michael Buesch wrote:
> >
> > Just remove it -- if we need it back we can find it in the git archives,
> > and it's rather unlikely that we're going to add that functionality to
> > mac80211 and hostapd unless you'll push it.
> >
> What should be removed ?
> b43_write_probe_resp_template and b43_write_probe_resp_plcp ?

yes

-- 
Greetings, Michael.


From mb at bu3sch.de  Wed Aug  5 00:06:02 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 5 Aug 2009 00:06:02 +0200
Subject: [RESEND] [PATCHv2] b43 add harware tkip
In-Reply-To: <83a869cd0908041503i74a7bd11uf85706aeaf95b611@mail.gmail.com>
References: <83a869cd0907271349h248204at74cc1603419fc83b@mail.gmail.com>
	<200908042358.15966.mb@bu3sch.de>
	<83a869cd0908041503i74a7bd11uf85706aeaf95b611@mail.gmail.com>
Message-ID: <200908050006.02754.mb@bu3sch.de>

On Wednesday 05 August 2009 00:03:11 gregor kowski wrote:
> On 8/4/09, Michael Buesch <mb at bu3sch.de> wrote:
> > On Tuesday 04 August 2009 23:54:42 gregor kowski wrote:
> >> On 7/31/09, Michael Buesch <mb at bu3sch.de> wrote:
> >> > On Friday 31 July 2009 23:04:17 gregor kowski wrote:
> >> >> Hi Michael,
> >
> >> There is really bugs in the current code.
> >
> > You always talk about "bugs". What are these "bugs"? Is it just the wrong
> > max_nr_keys assignment? That's trivial to fix.
> >
> So [1] is ok ?

Could you answer my question?



-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Wed Aug  5 00:10:58 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Wed, 05 Aug 2009 00:10:58 +0200
Subject: [PATCH] b43: Typo fixes & minor cleanup
Message-ID: <4A78B1F2.8050803@gmail.com>

Fix a typo in the HostFlags #defines.
Make use of HostFlags defines in the LP-PHY code.
Fix fallout from the IEEE80211_IF_TYPE to NL80211_IFTYPE change.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---

 drivers/net/wireless/b43/b43.h    |    4 ++--
 drivers/net/wireless/b43/phy_lp.c |    2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
index 41ca727..5d79d10 100644
--- a/drivers/net/wireless/b43/b43.h
+++ b/drivers/net/wireless/b43/b43.h
@@ -300,7 +300,7 @@ enum {
 #define B43_HF_TXBTCHECK	0x000002000000ULL /* Bluetooth check during transmission */
 #define B43_HF_SKCFPUP		0x000004000000ULL /* Skip CFP update */
 #define B43_HF_N40W		0x000008000000ULL /* N PHY 40 MHz workaround (rev >= 13 only) */
-#define B43_HF_ANTSEL		0x000020000000ULL /* Antenna selection (for testing antenna div.) */
+#define B43_HF_ANTSEL		0x000010000000ULL /* Antenna selection (for testing antenna div.) */
 #define B43_HF_BT3COEXT		0x000020000000ULL /* Bluetooth 3-wire coexistence (rev >= 13 only) */
 #define B43_HF_BTCANT		0x000040000000ULL /* Bluetooth coexistence (antenna mode) (rev >= 13 only) */
 #define B43_HF_ANTSELEN		0x000100000000ULL /* Antenna selection enabled (rev >= 13 only) */
@@ -627,7 +627,7 @@ struct b43_wl {
 	u8 mac_addr[ETH_ALEN];
 	/* Current BSSID */
 	u8 bssid[ETH_ALEN];
-	/* Interface type. (IEEE80211_IF_TYPE_XXX) */
+	/* Interface type. (NL80211_IFTYPE_XXX) */
 	int if_type;
 	/* Is the card operating in AP, STA or IBSS mode? */
 	bool operating;
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 5d50943..03a9b50 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -130,7 +130,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
 		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
 		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
-		b43_hf_write(dev, b43_hf_read(dev) | 0x0800ULL << 32);
+		b43_hf_write(dev, b43_hf_read(dev) | B43_HF_PR45960W);
 	}
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
 		b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x8000);
-- 
1.6.2.4





From mb at bu3sch.de  Wed Aug  5 00:17:53 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 5 Aug 2009 00:17:53 +0200
Subject: [PATCH] b43: Typo fixes & minor cleanup
In-Reply-To: <4A78B1F2.8050803@gmail.com>
References: <4A78B1F2.8050803@gmail.com>
Message-ID: <200908050017.53378.mb@bu3sch.de>

On Wednesday 05 August 2009 00:10:58 G?bor Stefanik wrote:
> Fix a typo in the HostFlags #defines.
> Make use of HostFlags defines in the LP-PHY code.
> Fix fallout from the IEEE80211_IF_TYPE to NL80211_IFTYPE change.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> 
>  drivers/net/wireless/b43/b43.h    |    4 ++--
>  drivers/net/wireless/b43/phy_lp.c |    2 +-
>  2 files changed, 3 insertions(+), 3 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
> index 41ca727..5d79d10 100644
> --- a/drivers/net/wireless/b43/b43.h
> +++ b/drivers/net/wireless/b43/b43.h
> @@ -300,7 +300,7 @@ enum {
>  #define B43_HF_TXBTCHECK	0x000002000000ULL /* Bluetooth check during transmission */
>  #define B43_HF_SKCFPUP		0x000004000000ULL /* Skip CFP update */
>  #define B43_HF_N40W		0x000008000000ULL /* N PHY 40 MHz workaround (rev >= 13 only) */
> -#define B43_HF_ANTSEL		0x000020000000ULL /* Antenna selection (for testing antenna div.) */
> +#define B43_HF_ANTSEL		0x000010000000ULL /* Antenna selection (for testing antenna div.) */

Uhm, no?
http://bcm-v4.sipsolutions.net/802.11/Host Flags

The code it correct.

>  #define B43_HF_BT3COEXT		0x000020000000ULL /* Bluetooth 3-wire coexistence (rev >= 13 only) */
>  #define B43_HF_BTCANT		0x000040000000ULL /* Bluetooth coexistence (antenna mode) (rev >= 13 only) */
>  #define B43_HF_ANTSELEN		0x000100000000ULL /* Antenna selection enabled (rev >= 13 only) */
> @@ -627,7 +627,7 @@ struct b43_wl {
>  	u8 mac_addr[ETH_ALEN];
>  	/* Current BSSID */
>  	u8 bssid[ETH_ALEN];
> -	/* Interface type. (IEEE80211_IF_TYPE_XXX) */
> +	/* Interface type. (NL80211_IFTYPE_XXX) */

ack

>  	int if_type;
>  	/* Is the card operating in AP, STA or IBSS mode? */
>  	bool operating;
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index 5d50943..03a9b50 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -130,7 +130,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
>  		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
>  		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
>  		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
> -		b43_hf_write(dev, b43_hf_read(dev) | 0x0800ULL << 32);
> +		b43_hf_write(dev, b43_hf_read(dev) | B43_HF_PR45960W);

ack

>  	}
>  	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
>  		b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x8000);



-- 
Greetings, Michael.


From gregor.kowski at gmail.com  Wed Aug  5 00:23:23 2009
From: gregor.kowski at gmail.com (gregor kowski)
Date: Wed, 5 Aug 2009 00:23:23 +0200
Subject: [RESEND] [PATCHv2] b43 add harware tkip
In-Reply-To: <200908050006.02754.mb@bu3sch.de>
References: <83a869cd0907271349h248204at74cc1603419fc83b@mail.gmail.com>
	<200908042358.15966.mb@bu3sch.de>
	<83a869cd0908041503i74a7bd11uf85706aeaf95b611@mail.gmail.com>
	<200908050006.02754.mb@bu3sch.de>
Message-ID: <83a869cd0908041523m7b2be0c9t4ae21dc2e22c537@mail.gmail.com>

On 8/5/09, Michael Buesch <mb at bu3sch.de> wrote:
> On Wednesday 05 August 2009 00:03:11 gregor kowski wrote:
>> On 8/4/09, Michael Buesch <mb at bu3sch.de> wrote:
>> > On Tuesday 04 August 2009 23:54:42 gregor kowski wrote:
>> >
>> > You always talk about "bugs". What are these "bugs"? Is it just the
>> > wrong
>> > max_nr_keys assignment? That's trivial to fix.
>> >
>> So [1] is ok ?
>
> Could you answer my question?
That's [1]. But may be my description wasn't good.
I will try a new one.
we can have up to 50 pairwise keys (due to RCMTA and tkip stuff).

In the case of new API :
- max_nr_keys is set to 58
- in b43_key_clear we call do_key_write for index in [0 ... 58]
- in do_key_write we call keymac_write for index in [4 ... 58]
- in keymac_write write to RCMTA index [0 ... 54]
We write too much pairwise keys.

- max_nr_keys is set to 58
- b43_key_write generate pairwise keys in [sta_keys_start ...
max_nr_keys] = [0 ... 58] and call do_key_write
- in do_key_write we call keymac_write for index in [4 ... 58]
- in keymac_write write to RCMTA index [0 ... 54]
We write too much pairwise keys.

So max_nr_keys seems wrong in case of new API.

Gregor.
[1]
> if  b43_new_kidx_api is true :
> - we set max_nr_keys to 58
> - we program B43_MMIO_RCMTA_COUNT to 50
> - in b43_key_write we can allocate key up to index 58 (4 for default,
> 54 for sta)
>
> But there is only 50 entries for TKIPTSCTTAK, and a comment on bcm-v4
> suggest there is 50 entries for RCMTA. So if there more than 50
> station we will overflow RCMTA and TKIPTSCTTAK.


From netrolller.3d at gmail.com  Wed Aug  5 00:25:42 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Wed, 05 Aug 2009 00:25:42 +0200
Subject: [PATCH v2] b43: Typo fixes & minor cleanup
Message-ID: <4A78B566.6030408@gmail.com>

Make use of HostFlags defines in the LP-PHY code.
Fix fallout from the IEEE80211_IF_TYPE to NL80211_IFTYPE change.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
v2: Drop incorrect hunk.

 drivers/net/wireless/b43/b43.h    |    2 +-
 drivers/net/wireless/b43/phy_lp.c |    2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
index 41ca727..52fd6d6 100644
--- a/drivers/net/wireless/b43/b43.h
+++ b/drivers/net/wireless/b43/b43.h
@@ -627,7 +627,7 @@ struct b43_wl {
 	u8 mac_addr[ETH_ALEN];
 	/* Current BSSID */
 	u8 bssid[ETH_ALEN];
-	/* Interface type. (IEEE80211_IF_TYPE_XXX) */
+	/* Interface type. (NL80211_IFTYPE_XXX) */
 	int if_type;
 	/* Is the card operating in AP, STA or IBSS mode? */
 	bool operating;
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 5d50943..03a9b50 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -130,7 +130,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
 		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
 		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
-		b43_hf_write(dev, b43_hf_read(dev) | 0x0800ULL << 32);
+		b43_hf_write(dev, b43_hf_read(dev) | B43_HF_PR45960W);
 	}
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
 		b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x8000);
-- 
1.6.2.4





From mb at bu3sch.de  Wed Aug  5 00:27:29 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 5 Aug 2009 00:27:29 +0200
Subject: [RESEND] [PATCHv2] b43 add harware tkip
In-Reply-To: <83a869cd0908041523m7b2be0c9t4ae21dc2e22c537@mail.gmail.com>
References: <83a869cd0907271349h248204at74cc1603419fc83b@mail.gmail.com>
	<200908050006.02754.mb@bu3sch.de>
	<83a869cd0908041523m7b2be0c9t4ae21dc2e22c537@mail.gmail.com>
Message-ID: <200908050027.29829.mb@bu3sch.de>

On Wednesday 05 August 2009 00:23:23 gregor kowski wrote:
> On 8/5/09, Michael Buesch <mb at bu3sch.de> wrote:
> > On Wednesday 05 August 2009 00:03:11 gregor kowski wrote:
> >> On 8/4/09, Michael Buesch <mb at bu3sch.de> wrote:
> >> > On Tuesday 04 August 2009 23:54:42 gregor kowski wrote:
> >> >
> >> > You always talk about "bugs". What are these "bugs"? Is it just the
> >> > wrong
> >> > max_nr_keys assignment? That's trivial to fix.
> >> >
> >> So [1] is ok ?
> >
> > Could you answer my question?
> That's [1]. But may be my description wasn't good.
> I will try a new one.
> we can have up to 50 pairwise keys (due to RCMTA and tkip stuff).
> 
> In the case of new API :
> - max_nr_keys is set to 58
> - in b43_key_clear we call do_key_write for index in [0 ... 58]
> - in do_key_write we call keymac_write for index in [4 ... 58]
> - in keymac_write write to RCMTA index [0 ... 54]
> We write too much pairwise keys.
> 
> - max_nr_keys is set to 58
> - b43_key_write generate pairwise keys in [sta_keys_start ...
> max_nr_keys] = [0 ... 58] and call do_key_write
> - in do_key_write we call keymac_write for index in [4 ... 58]
> - in keymac_write write to RCMTA index [0 ... 54]
> We write too much pairwise keys.

Yeah, I do understand this bug. My question was if that is the only bug.

> So max_nr_keys seems wrong in case of new API.

It's not that simple, actually.
The max_nr_keys thing was never meant to specify which API we're on.
It was invented to do the RCMTA vs *oldcrappymechanismiforgotthenameof*.
max_nr_keys essentially became obsolete and dead code when b43 did not
support <rev5 anymore. I will submit a patch which removes it and cleans up
the code alltogether.

-- 
Greetings, Michael.


From gregor.kowski at gmail.com  Wed Aug  5 00:32:23 2009
From: gregor.kowski at gmail.com (gregor kowski)
Date: Wed, 5 Aug 2009 00:32:23 +0200
Subject: [RESEND] [PATCHv2] b43 add harware tkip
In-Reply-To: <200908050027.29829.mb@bu3sch.de>
References: <83a869cd0907271349h248204at74cc1603419fc83b@mail.gmail.com>
	<200908050006.02754.mb@bu3sch.de>
	<83a869cd0908041523m7b2be0c9t4ae21dc2e22c537@mail.gmail.com>
	<200908050027.29829.mb@bu3sch.de>
Message-ID: <83a869cd0908041532x54ec1116m78c617eaec41cfa9@mail.gmail.com>

>
> Yeah, I do understand this bug. My question was if that is the only bug.
>
Sorry, yes this is the only one.

>> So max_nr_keys seems wrong in case of new API.
>
> It's not that simple, actually.
> The max_nr_keys thing was never meant to specify which API we're on.
> It was invented to do the RCMTA vs *oldcrappymechanismiforgotthenameof*.
> max_nr_keys essentially became obsolete and dead code when b43 did not
> support <rev5 anymore. I will submit a patch which removes it and cleans up
> the code alltogether.
Ok, thanks


From gregor.kowski at gmail.com  Wed Aug  5 00:44:23 2009
From: gregor.kowski at gmail.com (gregor kowski)
Date: Wed, 5 Aug 2009 00:44:23 +0200
Subject: [PATCH V2] remove wrong probe_resp_plcp write
Message-ID: <83a869cd0908041544i304ea12ctdc5777ec8b20a5b7@mail.gmail.com>

The tkip hw support uncovered a bug in b43_write_probe_resp_template : it is
writing at the wrong shm offset, it is in the B43_SHM_SH_TKIPTSCTTAK
zone. Remove b43_write_probe_resp_template,  b43_write_probe_resp_plcp
and b43_write_probe_resp_plcp because the probe response offload is
currently not supported by mac80211.

Signed-off-by: Gregor Kowski <gregor.kowski at gmail.com>

Index: linux-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/main.c	2009-08-04
22:28:09.000000000 +0000
+++ linux-2.6/drivers/net/wireless/b43/main.c	2009-08-04
22:39:59.000000000 +0000
@@ -1431,113 +1431,6 @@
 	b43dbg(dev->wl, "Updated beacon template at 0x%x\n", ram_offset);
 }

-static void b43_write_probe_resp_plcp(struct b43_wldev *dev,
-				      u16 shm_offset, u16 size,
-				      struct ieee80211_rate *rate)
-{
-	struct b43_plcp_hdr4 plcp;
-	u32 tmp;
-	__le16 dur;
-
-	plcp.data = 0;
-	b43_generate_plcp_hdr(&plcp, size + FCS_LEN, rate->hw_value);
-	dur = ieee80211_generic_frame_duration(dev->wl->hw,
-					       dev->wl->vif, size,
-					       rate);
-	/* Write PLCP in two parts and timing for packet transfer */
-	tmp = le32_to_cpu(plcp.data);
-	b43_shm_write16(dev, B43_SHM_SHARED, shm_offset, tmp & 0xFFFF);
-	b43_shm_write16(dev, B43_SHM_SHARED, shm_offset + 2, tmp >> 16);
-	b43_shm_write16(dev, B43_SHM_SHARED, shm_offset + 6, le16_to_cpu(dur));
-}
-
-/* Instead of using custom probe response template, this function
- * just patches custom beacon template by:
- * 1) Changing packet type
- * 2) Patching duration field
- * 3) Stripping TIM
- */
-static const u8 *b43_generate_probe_resp(struct b43_wldev *dev,
-					 u16 *dest_size,
-					 struct ieee80211_rate *rate)
-{
-	const u8 *src_data;
-	u8 *dest_data;
-	u16 src_size, elem_size, src_pos, dest_pos;
-	__le16 dur;
-	struct ieee80211_hdr *hdr;
-	size_t ie_start;
-
-	src_size = dev->wl->current_beacon->len;
-	src_data = (const u8 *)dev->wl->current_beacon->data;
-
-	/* Get the start offset of the variable IEs in the packet. */
-	ie_start = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
-	B43_WARN_ON(ie_start != offsetof(struct ieee80211_mgmt, u.beacon.variable));
-
-	if (B43_WARN_ON(src_size < ie_start))
-		return NULL;
-
-	dest_data = kmalloc(src_size, GFP_ATOMIC);
-	if (unlikely(!dest_data))
-		return NULL;
-
-	/* Copy the static data and all Information Elements, except the TIM. */
-	memcpy(dest_data, src_data, ie_start);
-	src_pos = ie_start;
-	dest_pos = ie_start;
-	for ( ; src_pos < src_size - 2; src_pos += elem_size) {
-		elem_size = src_data[src_pos + 1] + 2;
-		if (src_data[src_pos] == 5) {
-			/* This is the TIM. */
-			continue;
-		}
-		memcpy(dest_data + dest_pos, src_data + src_pos,
-		       elem_size);
-		dest_pos += elem_size;
-	}
-	*dest_size = dest_pos;
-	hdr = (struct ieee80211_hdr *)dest_data;
-
-	/* Set the frame control. */
-	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
-					 IEEE80211_STYPE_PROBE_RESP);
-	dur = ieee80211_generic_frame_duration(dev->wl->hw,
-					       dev->wl->vif, *dest_size,
-					       rate);
-	hdr->duration_id = dur;
-
-	return dest_data;
-}
-
-static void b43_write_probe_resp_template(struct b43_wldev *dev,
-					  u16 ram_offset,
-					  u16 shm_size_offset,
-					  struct ieee80211_rate *rate)
-{
-	const u8 *probe_resp_data;
-	u16 size;
-
-	size = dev->wl->current_beacon->len;
-	probe_resp_data = b43_generate_probe_resp(dev, &size, rate);
-	if (unlikely(!probe_resp_data))
-		return;
-
-	/* Looks like PLCP headers plus packet timings are stored for
-	 * all possible basic rates
-	 */
-	b43_write_probe_resp_plcp(dev, 0x31A, size, &b43_b_ratetable[0]);
-	b43_write_probe_resp_plcp(dev, 0x32C, size, &b43_b_ratetable[1]);
-	b43_write_probe_resp_plcp(dev, 0x33E, size, &b43_b_ratetable[2]);
-	b43_write_probe_resp_plcp(dev, 0x350, size, &b43_b_ratetable[3]);
-
-	size = min((size_t) size, 0x200 - sizeof(struct b43_plcp_hdr6));
-	b43_write_template_common(dev, probe_resp_data,
-				  size, ram_offset, shm_size_offset,
-				  rate->hw_value);
-	kfree(probe_resp_data);
-}
-
 static void b43_upload_beacon0(struct b43_wldev *dev)
 {
 	struct b43_wl *wl = dev->wl;
@@ -1545,10 +1438,6 @@
 	if (wl->beacon0_uploaded)
 		return;
 	b43_write_beacon_template(dev, 0x68, 0x18);
-	/* FIXME: Probe resp upload doesn't really belong here,
-	 *        but we don't use that feature anyway. */
-	b43_write_probe_resp_template(dev, 0x268, 0x4A,
-				      &__b43_ratetable[3]);
 	wl->beacon0_uploaded = 1;
 }


From Larry.Finger at lwfinger.net  Wed Aug  5 01:05:14 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Aug 2009 18:05:14 -0500
Subject: [PATCH] b43: Typo fixes & minor cleanup
In-Reply-To: <200908050017.53378.mb@bu3sch.de>
References: <4A78B1F2.8050803@gmail.com> <200908050017.53378.mb@bu3sch.de>
Message-ID: <4A78BEAA.5040704@lwfinger.net>

Michael Buesch wrote:
> 
> Uhm, no?
> http://bcm-v4.sipsolutions.net/802.11/Host Flags

I just made some changes to that page. The modifications do not affect
the above criticism.

Larry


From netrolller.3d at gmail.com  Wed Aug  5 01:24:38 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Wed, 05 Aug 2009 01:24:38 +0200
Subject: [PATCH V3] b43: implement baseband init for LP-PHY <= rev1
Message-ID: <4A78C336.9000503@gmail.com>

Implement baseband init for rev.0 and rev.1 LP PHYs. Convert boardflags_hi values to defines.
Implement b43_phy_copy for easier copying between registers, as needed by LP-PHY init.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
Cc: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>
---
V3:
-Added FIXME to the b43_hf_write call.
-The b43_hf_write call now uses a #defined value, rather than a magic number.

V2:
-Reversed argument order for b43_phy_copy.
-Named all registers, no more magic numbers.
-Whitespace errors hopefully fixed (I hope my mailer doesn't re-introduce them...)

 drivers/net/wireless/b43/b43.h        |   11 ++++
 drivers/net/wireless/b43/phy_common.c |    7 +++
 drivers/net/wireless/b43/phy_common.h |    5 ++
 drivers/net/wireless/b43/phy_lp.c     |   95 ++++++++++++++++++++++++++++++++-
 drivers/net/wireless/b43/phy_lp.h     |   11 +++-
 drivers/net/wireless/b43/phy_n.c      |    3 +-
 6 files changed, 128 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
index 4e8ad84..41ca727 100644
--- a/drivers/net/wireless/b43/b43.h
+++ b/drivers/net/wireless/b43/b43.h
@@ -142,6 +142,17 @@
 #define B43_BFL_BTCMOD			0x4000	/* BFL_BTCOEXIST is given in alternate GPIOs */
 #define B43_BFL_ALTIQ			0x8000	/* alternate I/Q settings */
 
+/* SPROM boardflags_hi values */
+#define B43_BFH_NOPA			0x0001	/* has no PA */
+#define B43_BFH_RSSIINV			0x0002	/* RSSI uses positive slope (not TSSI) */
+#define B43_BFH_PAREF			0x0004	/* uses the PARef LDO */
+#define B43_BFH_3TSWITCH		0x0008	/* uses a triple throw switch shared
+						 * with bluetooth */
+#define B43_BFH_PHASESHIFT		0x0010	/* can support phase shifter */
+#define B43_BFH_BUCKBOOST		0x0020	/* has buck/booster */
+#define B43_BFH_FEM_BT			0x0040	/* has FEM and switch to share antenna
+						 * with bluetooth */
+
 /* GPIO register offset, in both ChipCommon and PCI core. */
 #define B43_GPIO_CONTROL		0x6c
 
diff --git a/drivers/net/wireless/b43/phy_common.c b/drivers/net/wireless/b43/phy_common.c
index e176b6e..1661b03 100644
--- a/drivers/net/wireless/b43/phy_common.c
+++ b/drivers/net/wireless/b43/phy_common.c
@@ -240,6 +240,13 @@ void b43_phy_write(struct b43_wldev *dev, u16 reg, u16 value)
 	dev->phy.ops->phy_write(dev, reg, value);
 }
 
+void b43_phy_copy(struct b43_wldev *dev, u16 destreg, u16 srcreg)
+{
+	assert_mac_suspended(dev);
+	dev->phy.ops->phy_write(dev, destreg,
+		dev->phy.ops->phy_read(dev, srcreg));
+}
+
 void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
 {
 	b43_phy_write(dev, offset,
diff --git a/drivers/net/wireless/b43/phy_common.h b/drivers/net/wireless/b43/phy_common.h
index b2d9910..c7a7d6b 100644
--- a/drivers/net/wireless/b43/phy_common.h
+++ b/drivers/net/wireless/b43/phy_common.h
@@ -291,6 +291,11 @@ u16 b43_phy_read(struct b43_wldev *dev, u16 reg);
 void b43_phy_write(struct b43_wldev *dev, u16 reg, u16 value);
 
 /**
+ * b43_phy_copy - copy contents of 16bit PHY register to another
+ */
+void b43_phy_copy(struct b43_wldev *dev, u16 destreg, u16 srcreg);
+
+/**
  * b43_phy_mask - Mask a PHY register with a mask
  */
 void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask);
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 58e319d..e47eca6 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -66,7 +66,100 @@ static void lpphy_table_init(struct b43_wldev *dev)
 
 static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 {
-	B43_WARN_ON(1);//TODO rev < 2 not supported, yet.
+	struct ssb_bus *bus = dev->dev->bus;
+	u16 tmp, tmp2;
+
+	if (dev->phy.rev == 1 &&
+	   (bus->sprom.boardflags_hi & B43_BFH_FEM_BT)) {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0x3F00, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0400);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_5, 0xC0FF, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_6, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_7, 0xC0FF, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_8, 0xC0FF, 0x0B00);
+	} else if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ ||
+		  (bus->boardinfo.type == 0x048A) || ((dev->phy.rev == 0) &&
+		  (bus->sprom.boardflags_lo & B43_BFL_FEM))) {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0001);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0400);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0001);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0500);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0800);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0A00);
+	} else if (dev->phy.rev == 1 ||
+		  (bus->sprom.boardflags_lo & B43_BFL_FEM)) {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x0004);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0800);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x0004);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0C00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0100);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0002);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0300);
+	} else {
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xC0FF, 0x0900);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xFFC0, 0x000A);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_2, 0xC0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xFFC0, 0x0006);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_3, 0xC0FF, 0x0500);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0006);
+		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0700);
+	}
+	if (dev->phy.rev == 1) {
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_5, B43_LPPHY_TR_LOOKUP_1);
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_6, B43_LPPHY_TR_LOOKUP_2);
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_7, B43_LPPHY_TR_LOOKUP_3);
+		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_8, B43_LPPHY_TR_LOOKUP_4);
+	}
+	if ((bus->sprom.boardflags_hi & B43_BFH_FEM_BT) &&
+	    (bus->chip_id == 0x5354) &&
+	    (bus->chip_package == SSB_CHIPPACK_BCM4712S)) {
+		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
+		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
+		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
+		b43_hf_write(dev, b43_hf_read(dev) | B43_HF_PR45960W);
+		/* FIXME the spec requires this hf_write to be cached! */
+	}
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x8000);
+		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0040);
+		b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0x00FF, 0xA400);
+		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xF0FF, 0x0B00);
+		b43_phy_maskset(dev, B43_LPPHY_SYNCPEAKCNT, 0xFFF8, 0x0007);
+		b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFF8, 0x0003);
+		b43_phy_maskset(dev, B43_LPPHY_DSSS_CONFIRM_CNT, 0xFFC7, 0x0020);
+		b43_phy_mask(dev, B43_LPPHY_IDLEAFTERPKTRXTO, 0x00FF);
+	} else { /* 5GHz */
+		b43_phy_mask(dev, B43_LPPHY_LP_PHY_CTL, 0x7FFF);
+		b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFBF);
+	}
+	if (dev->phy.rev == 1) {
+		tmp = b43_phy_read(dev, B43_LPPHY_CLIPCTRTHRESH);
+		tmp2 = (tmp & 0x03E0) >> 5;
+		tmp2 |= tmp << 5;
+		b43_phy_write(dev, B43_LPPHY_4C3, tmp2);
+		tmp = b43_phy_read(dev, B43_LPPHY_OFDMSYNCTHRESH0);
+		tmp2 = (tmp & 0x1F00) >> 8;
+		tmp2 |= tmp << 5;
+		b43_phy_write(dev, B43_LPPHY_4C4, tmp2);
+		tmp = b43_phy_read(dev, B43_LPPHY_VERYLOWGAINDB);
+		tmp2 = tmp & 0x00FF;
+		tmp2 |= tmp << 8;
+		b43_phy_write(dev, B43_LPPHY_4C5, tmp2);
+	}
 }
 
 static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 18370b4..829b2bb 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -273,12 +273,19 @@
 #define B43_LPPHY_AFE_DDFS_POINTER_INIT		B43_PHY_OFDM(0xB8) /* AFE DDFS pointer init */
 #define B43_LPPHY_AFE_DDFS_INCR_INIT		B43_PHY_OFDM(0xB9) /* AFE DDFS incr init */
 #define B43_LPPHY_MRCNOISEREDUCTION		B43_PHY_OFDM(0xBA) /* mrcNoiseReduction */
-#define B43_LPPHY_TRLOOKUP3			B43_PHY_OFDM(0xBB) /* TRLookup3 */
-#define B43_LPPHY_TRLOOKUP4			B43_PHY_OFDM(0xBC) /* TRLookup4 */
+#define B43_LPPHY_TR_LOOKUP_3			B43_PHY_OFDM(0xBB) /* TR Lookup 3 */
+#define B43_LPPHY_TR_LOOKUP_4			B43_PHY_OFDM(0xBC) /* TR Lookup 4 */
 #define B43_LPPHY_RADAR_FIFO_STAT		B43_PHY_OFDM(0xBD) /* Radar FIFO Status */
 #define B43_LPPHY_GPIO_OUTEN			B43_PHY_OFDM(0xBE) /* GPIO Out enable */
 #define B43_LPPHY_GPIO_SELECT			B43_PHY_OFDM(0xBF) /* GPIO Select */
 #define B43_LPPHY_GPIO_OUT			B43_PHY_OFDM(0xC0) /* GPIO Out */
+#define B43_LPPHY_4C3				B43_PHY_OFDM(0xC3) /* unknown, used during BB init */
+#define B43_LPPHY_4C4				B43_PHY_OFDM(0xC4) /* unknown, used during BB init */
+#define B43_LPPHY_4C5				B43_PHY_OFDM(0xC5) /* unknown, used during BB init */
+#define B43_LPPHY_TR_LOOKUP_5			B43_PHY_OFDM(0xC7) /* TR Lookup 5 */
+#define B43_LPPHY_TR_LOOKUP_6			B43_PHY_OFDM(0xC8) /* TR Lookup 6 */
+#define B43_LPPHY_TR_LOOKUP_7			B43_PHY_OFDM(0xC9) /* TR Lookup 7 */
+#define B43_LPPHY_TR_LOOKUP_8			B43_PHY_OFDM(0xCA) /* TR Lookup 8 */
 
 
 
diff --git a/drivers/net/wireless/b43/phy_n.c b/drivers/net/wireless/b43/phy_n.c
index 8bcfda5..14ad95a 100644
--- a/drivers/net/wireless/b43/phy_n.c
+++ b/drivers/net/wireless/b43/phy_n.c
@@ -137,7 +137,8 @@ static void b43_radio_init2055_post(struct b43_wldev *dev)
 
 	b43_radio_mask(dev, B2055_MASTER1, 0xFFF3);
 	msleep(1);
-	if ((sprom->revision != 4) || !(sprom->boardflags_hi & 0x0002)) {
+	if ((sprom->revision != 4) ||
+	   !(sprom->boardflags_hi & B43_BFH_RSSIINV)) {
 		if ((binfo->vendor != PCI_VENDOR_ID_BROADCOM) ||
 		    (binfo->type != 0x46D) ||
 		    (binfo->rev < 0x41)) {
-- 
1.6.2.4




From netrolller.3d at gmail.com  Wed Aug  5 01:28:20 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Wed, 05 Aug 2009 01:28:20 +0200
Subject: [PATCH] b43: Fix fallout from the IEEE80211_IF_TYPE to NL80211_IFTYPE
	change.
Message-ID: <4A78C414.7060708@gmail.com>

Update a comment that still says IEEE80211_IF_TYPE instead of NL80211_IFTYPE.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
This patch replaces "b43: Typo fixes and minor cleanup",
the other half of which has been integrated into the LP rev01 init patch.

 drivers/net/wireless/b43/b43.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
index 41ca727..52fd6d6 100644
--- a/drivers/net/wireless/b43/b43.h
+++ b/drivers/net/wireless/b43/b43.h
@@ -627,7 +627,7 @@ struct b43_wl {
 	u8 mac_addr[ETH_ALEN];
 	/* Current BSSID */
 	u8 bssid[ETH_ALEN];
-	/* Interface type. (IEEE80211_IF_TYPE_XXX) */
+	/* Interface type. (NL80211_IFTYPE_XXX) */
 	int if_type;
 	/* Is the card operating in AP, STA or IBSS mode? */
 	bool operating;
-- 
1.6.2.4





From Larry.Finger at lwfinger.net  Wed Aug  5 04:39:24 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Aug 2009 21:39:24 -0500
Subject: [PATCH V3] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <4A78C336.9000503@gmail.com>
References: <4A78C336.9000503@gmail.com>
Message-ID: <4A78F0DC.4070104@lwfinger.net>

G?bor Stefanik wrote:
> Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
> boardflags_hi values to defines.
> Implement b43_phy_copy for easier copying between registers, as needed
> by LP-PHY init.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> Cc: Michael Buesch <mb at bu3sch.de>
> Cc: Larry Finger <larry.finger at lwfinger.net>
> ---
> V3:
> -Added FIXME to the b43_hf_write call.
> -The b43_hf_write call now uses a #defined value, rather than a magic
> number.

It looks to me that V2 was put into wireless-testing. You will need to
prepare a separate patch to make the V2 => V3 changes.

Larry



From netrolller.3d at gmail.com  Wed Aug  5 07:48:25 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Wed, 5 Aug 2009 07:48:25 +0200
Subject: [PATCH V3] b43: implement baseband init for LP-PHY <= rev1
In-Reply-To: <4A78F0DC.4070104@lwfinger.net>
References: <4A78C336.9000503@gmail.com> <4A78F0DC.4070104@lwfinger.net>
Message-ID: <69e28c910908042248m5419a39fl5f370e73e01e8b64@mail.gmail.com>

2009/8/5 Larry Finger <Larry.Finger at lwfinger.net>:
> G?bor Stefanik wrote:
>> Implement baseband init for rev.0 and rev.1 LP PHYs. Convert
>> boardflags_hi values to defines.
>> Implement b43_phy_copy for easier copying between registers, as needed
>> by LP-PHY init.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> Cc: Michael Buesch <mb at bu3sch.de>
>> Cc: Larry Finger <larry.finger at lwfinger.net>
>> ---
>> V3:
>> -Added FIXME to the b43_hf_write call.
>> -The b43_hf_write call now uses a #defined value, rather than a magic
>> number.
>
> It looks to me that V2 was put into wireless-testing. You will need to
> prepare a separate patch to make the V2 => V3 changes.
>
> Larry

OK, I will be sending one today.

Note to John: Please apply the "Fix fallout" patch, but not the
"Cleanups" one. The second part of "Cleanups" will be resubmitted,
combined with other V2->V3 changes.

Larry, my next target is
http://bcm-v4.sipsolutions.net/802.11/PHY/LP/SYNCHSTX - however, what
is the definition of struct lpphy_extstxdata_t? Where does the stx
array get its values (or what are its initial values, if it needs to
be initialized here)?
Also, with Sync-STX, >=rev2 radio init is essentially complete, except
for "with interrupts disabled, do something with backplane (TODO)" -
when can we expect documentation on this step?

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From lemenkov at gmail.com  Wed Aug  5 13:07:47 2009
From: lemenkov at gmail.com (Peter Lemenkov)
Date: Wed, 5 Aug 2009 15:07:47 +0400
Subject: Fwd: [Bug 515668] New: kernel BUG at
	drivers/net/wireless/b43/dma.c:1406! when using openfwwf firmware
In-Reply-To: <bug-515668-184522@bugzilla.redhat.com>
References: <bug-515668-184522@bugzilla.redhat.com>
Message-ID: <adf480660908050407y34157a6ajffe9f71dad827e65@mail.gmail.com>

Hello,All!
Here is a bug report regarding DMA issues with openfwwf ver. 5.2 . I
suspect, that this is a known issue, but anyway, maybe this bugzilla
ticket will add something important.


---------- Forwarded message ----------
From:  <bugzilla at redhat.com>
Date: 2009/8/5
Subject: [Bug 515668] New: kernel BUG at
drivers/net/wireless/b43/dma.c:1406! when using openfwwf firmware
To: lemenkov at gmail.com


Please do not reply directly to this email. All additional
comments should be made in the comments box of this bug.

Summary: kernel BUG at drivers/net/wireless/b43/dma.c:1406! when using
openfwwf firmware

https://bugzilla.redhat.com/show_bug.cgi?id=515668

? ? ? ? ? Summary: kernel BUG at drivers/net/wireless/b43/dma.c:1406!
? ? ? ? ? ? ? ? ? ?when using openfwwf firmware
? ? ? ? ? Product: Fedora
? ? ? ? ? Version: 11
? ? ? ? ?Platform: i686
? ? ? ?OS/Version: Linux
? ? ? ? ? ?Status: NEW
? ? ? ? ?Severity: urgent
? ? ? ? ?Priority: low
? ? ? ? Component: b43-openfwwf
? ? ? ?AssignedTo: lemenkov at gmail.com
? ? ? ?ReportedBy: arethusa26 at gmail.com
? ? ? ? QAContact: extras-qa at fedoraproject.org
? ? ? ? ? ? ? ?CC: lemenkov at gmail.com
? Estimated Hours: 0.0
? ?Classification: Fedora


User-Agent: ? ? ? Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.1.1)
Gecko/20090717 Fedora/3.5.1-3.fc11 Firefox/3.5.1

I am using a Linksys PCMCIA wireless card, which is model WPC54GS at version 2,
on a Fedora 11 system installed on a Thinkpad T42. When I am using the b43
kernel module in conjunction with the b43-openfwwf firmware, I frequently
observe the system panic when there is heavy amounts of network activity on the
wireless card interface. Empirically, this issue only seems to happen when the
card is associated with the residential wireless network broadcast by the
Actiontec MI424WR wireless router, and it does not occur when using the
Broadcom firmware extracted according to the instructions from
http://www.linuxwireless.org/en/users/Drivers/b43#device_firmware. I can most
consistently cause a crash by using the speed testing service at
http://www.speedtest.net/ to stress test the wireless interface.

Reproducible: Always

Steps to Reproduce:
1. Install b43-openfwwf to get the wireless card operational.
2. Visit http://www.speedtest.net/ for an easy way to stress test the card.
3. Start a speed test. The kernel should panic shortly after the test is begun.
Actual Results:
The system halts with a kernel panic.

Expected Results:
The system should not crash.

I captured the resulting kernel panic using netconsole, since the system did
not switch to a text console when the panic occurred. The information from
lspci -vv regarding the card is:

03:00.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 54g]
802.11g Wireless LAN Controller (rev 02)
?Subsystem: Linksys Device 0049
?Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping-
SERR- FastB2B- DisINTx-
?Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort-
<MAbort- >SERR- <PERR- INTx-
?Latency: 64
?Interrupt: pin A routed to IRQ 11
?Region 0: Memory at c4000000 (32-bit, non-prefetchable) [size=8K]
?Kernel driver in use: b43-pci-bridge
?Kernel modules: ssb

--
Configure bugmail: https://bugzilla.redhat.com/userprefs.cgi?tab=email
------- You are receiving this mail because: -------
You are on the CC list for the bug.
You are the assignee for the bug.



-- 
With best regards, Peter Lemenkov.


From francesco.gringoli at ing.unibs.it  Wed Aug  5 13:33:59 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Wed, 5 Aug 2009 13:33:59 +0200
Subject: [Bug 515668] New: kernel BUG at
	drivers/net/wireless/b43/dma.c:1406! when using openfwwf firmware
In-Reply-To: <adf480660908050407y34157a6ajffe9f71dad827e65@mail.gmail.com>
References: <bug-515668-184522@bugzilla.redhat.com>
	<adf480660908050407y34157a6ajffe9f71dad827e65@mail.gmail.com>
Message-ID: <DFFBB817-AB1A-4060-ABA0-89CE19EECEAC@ing.unibs.it>


On Aug 5, 2009, at 1:07 PM, Peter Lemenkov wrote:

> Hello,All!
> Here is a bug report regarding DMA issues with openfwwf ver. 5.2 . I
> suspect, that this is a known issue, but anyway, maybe this bugzilla
> ticket will add something important.
>
>
Hi Peter,

many thanks. I added a note on the website. I have a few cards like  
that, I will do some tests to catch the bug.

Cheers,
-FG

> ---------- Forwarded message ----------
> From:  <bugzilla at redhat.com>
> Date: 2009/8/5
> Subject: [Bug 515668] New: kernel BUG at
> drivers/net/wireless/b43/dma.c:1406! when using openfwwf firmware
> To: lemenkov at gmail.com
>
>
> Please do not reply directly to this email. All additional
> comments should be made in the comments box of this bug.
>
> Summary: kernel BUG at drivers/net/wireless/b43/dma.c:1406! when using
> openfwwf firmware
>
> https://bugzilla.redhat.com/show_bug.cgi?id=515668
>
>           Summary: kernel BUG at drivers/net/wireless/b43/dma.c:1406!
>                    when using openfwwf firmware
>           Product: Fedora
>           Version: 11
>          Platform: i686
>        OS/Version: Linux
>            Status: NEW
>          Severity: urgent
>          Priority: low
>         Component: b43-openfwwf
>        AssignedTo: lemenkov at gmail.com
>        ReportedBy: arethusa26 at gmail.com
>         QAContact: extras-qa at fedoraproject.org
>                CC: lemenkov at gmail.com
>   Estimated Hours: 0.0
>    Classification: Fedora
>
>
> User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.1.1)
> Gecko/20090717 Fedora/3.5.1-3.fc11 Firefox/3.5.1
>
> I am using a Linksys PCMCIA wireless card, which is model WPC54GS at  
> version 2,
> on a Fedora 11 system installed on a Thinkpad T42. When I am using  
> the b43
> kernel module in conjunction with the b43-openfwwf firmware, I  
> frequently
> observe the system panic when there is heavy amounts of network  
> activity on the
> wireless card interface. Empirically, this issue only seems to  
> happen when the
> card is associated with the residential wireless network broadcast  
> by the
> Actiontec MI424WR wireless router, and it does not occur when using  
> the
> Broadcom firmware extracted according to the instructions from
> http://www.linuxwireless.org/en/users/Drivers/b43#device_firmware. I  
> can most
> consistently cause a crash by using the speed testing service at
> http://www.speedtest.net/ to stress test the wireless interface.
>
> Reproducible: Always
>
> Steps to Reproduce:
> 1. Install b43-openfwwf to get the wireless card operational.
> 2. Visit http://www.speedtest.net/ for an easy way to stress test  
> the card.
> 3. Start a speed test. The kernel should panic shortly after the  
> test is begun.
> Actual Results:
> The system halts with a kernel panic.
>
> Expected Results:
> The system should not crash.
>
> I captured the resulting kernel panic using netconsole, since the  
> system did
> not switch to a text console when the panic occurred. The  
> information from
> lspci -vv regarding the card is:
>
> 03:00.0 Network controller: Broadcom Corporation BCM4318 [AirForce  
> One 54g]
> 802.11g Wireless LAN Controller (rev 02)
>  Subsystem: Linksys Device 0049
>  Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-  
> Stepping-
> SERR- FastB2B- DisINTx-
>  Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort-  
> <TAbort-
> <MAbort- >SERR- <PERR- INTx-
>  Latency: 64
>  Interrupt: pin A routed to IRQ 11
>  Region 0: Memory at c4000000 (32-bit, non-prefetchable) [size=8K]
>  Kernel driver in use: b43-pci-bridge
>  Kernel modules: ssb
>
> --
> Configure bugmail: https://bugzilla.redhat.com/userprefs.cgi?tab=email
> ------- You are receiving this mail because: -------
> You are on the CC list for the bug.
> You are the assignee for the bug.
>
>
>
> -- 
> With best regards, Peter Lemenkov.
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev

-------

Francesco Gringoli, PhD - Assistant Professor
Dept. of Electrical Engineering for Automation
University of Brescia
via Branze, 38
25123 Brescia
ITALY

Ph:  ++39.030.3715843
FAX: ++39.030.380014
WWW: http://www.ing.unibs.it/~gringoli







"INFORMATIVA SUL TRATTAMENTO DEI DATI PERSONALI"

I dati utilizzati per l'invio del presente messaggio sono trattati dall' Universita' degli
studi di Brescia esclusivamente per finalita' istituzionali. Informazioni piu' dettagliate
anche in ordine ai diritti dell'interessato sono riposte nell'informativa generale e nelle
notizie pubblicate sul sito web dell'Ateneo nella sezione "privacy".

Il contenuto di questo messaggio e' rivolto unicamente alle persone cui e' indirizzato e puo'
contenere informazioni la cui riservatezza e' tutelata legalmente. Ne sono vietati la
riproduzione, la diffusione e l'uso in mancanza di autorizzazione del destinatario.
Qualora il messaggio fosse pervenuto per errore, preghiamo di eliminarlo.




From Larry.Finger at lwfinger.net  Wed Aug  5 16:41:46 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 05 Aug 2009 09:41:46 -0500
Subject: [Bug 515668] New: kernel BUG
	at	drivers/net/wireless/b43/dma.c:1406! when using openfwwf firmware
In-Reply-To: <DFFBB817-AB1A-4060-ABA0-89CE19EECEAC@ing.unibs.it>
References: <bug-515668-184522@bugzilla.redhat.com>	<adf480660908050407y34157a6ajffe9f71dad827e65@mail.gmail.com>
	<DFFBB817-AB1A-4060-ABA0-89CE19EECEAC@ing.unibs.it>
Message-ID: <4A799A2A.2040107@lwfinger.net>

Francesco Gringoli wrote:
> On Aug 5, 2009, at 1:07 PM, Peter Lemenkov wrote:
> 
>> Hello,All!
>> Here is a bug report regarding DMA issues with openfwwf ver. 5.2 . I
>> suspect, that this is a known issue, but anyway, maybe this bugzilla
>> ticket will add something important.
>>
>>
> Hi Peter,
> 
> many thanks. I added a note on the website. I have a few cards like  
> that, I will do some tests to catch the bug.

Francesco,

This bug is the same as the one I reported for both my 4311 and my
4318. When the TX status interrupt is entered for a particular cookie,
the skb is freed, and the buffer pointer is replaced with a NULL. The
kernel panic reported here is the result of detecting a NULL value for
that buffer pointer. I think the conclusion is that the firmware is
calling the interrupt routine with a cookie that was previously
reported. Why? I don't know. Even with the source to look at, firmware
is a big mystery.

Larry



From francesco.gringoli at ing.unibs.it  Wed Aug  5 17:45:46 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Wed, 5 Aug 2009 17:45:46 +0200
Subject: [Bug 515668] New: kernel BUG
	at	drivers/net/wireless/b43/dma.c:1406! when using openfwwf firmware
In-Reply-To: <4A799A2A.2040107@lwfinger.net>
References: <bug-515668-184522@bugzilla.redhat.com>	<adf480660908050407y34157a6ajffe9f71dad827e65@mail.gmail.com>
	<DFFBB817-AB1A-4060-ABA0-89CE19EECEAC@ing.unibs.it>
	<4A799A2A.2040107@lwfinger.net>
Message-ID: <8C939AF8-0112-4D54-90E1-7FC53266B7D3@ing.unibs.it>


On Aug 5, 2009, at 4:41 PM, Larry Finger wrote:

> Francesco Gringoli wrote:
>> On Aug 5, 2009, at 1:07 PM, Peter Lemenkov wrote:
>>
>>> Hello,All!
>>> Here is a bug report regarding DMA issues with openfwwf ver. 5.2 . I
>>> suspect, that this is a known issue, but anyway, maybe this bugzilla
>>> ticket will add something important.
>>>
>>>
>> Hi Peter,
>>
>> many thanks. I added a note on the website. I have a few cards like
>> that, I will do some tests to catch the bug.
>
> Francesco,
>
> This bug is the same as the one I reported for both my 4311 and my
> 4318. When the TX status interrupt is entered for a particular cookie,
> the skb is freed, and the buffer pointer is replaced with a NULL. The
> kernel panic reported here is the result of detecting a NULL value for
> that buffer pointer. I think the conclusion is that the firmware is
> calling the interrupt routine with a cookie that was previously
> reported. Why? I don't know. Even with the source to look at, firmware
> is a big mystery.
Hi Larry,

D'oh!... so I already had some boards which displayed that behavior!!  
Ok ok, I will have two more (if the two minipci-e I bought will ever  
arrive, I'm still waiting) :-)

Taking back my old laptop with PCMCIA slot.

Cheers,
-Francesco

>
>
> Larry
>




"INFORMATIVA SUL TRATTAMENTO DEI DATI PERSONALI"

I dati utilizzati per l'invio del presente messaggio sono trattati dall' Universita' degli
studi di Brescia esclusivamente per finalita' istituzionali. Informazioni piu' dettagliate
anche in ordine ai diritti dell'interessato sono riposte nell'informativa generale e nelle
notizie pubblicate sul sito web dell'Ateneo nella sezione "privacy".

Il contenuto di questo messaggio e' rivolto unicamente alle persone cui e' indirizzato e puo'
contenere informazioni la cui riservatezza e' tutelata legalmente. Ne sono vietati la
riproduzione, la diffusione e l'uso in mancanza di autorizzazione del destinatario.
Qualora il messaggio fosse pervenuto per errore, preghiamo di eliminarlo.




From roman at rs-labs.com  Thu Aug  6 00:05:32 2009
From: roman at rs-labs.com (Roman Medina-Heigl Hernandez)
Date: Thu, 06 Aug 2009 00:05:32 +0200
Subject: "BCM 4310 USB" (14e4:4315). Any progress?
Message-ID: <4A7A022C.6070208@rs-labs.com>

Hello,

Sorry for pinging this list but I did some searches and I couldn't find
responses...

I've got a new Dell Mini-10 ("Inspiron 1010"), with the following wifi
chipset: "BCM 4310 USB". It's got PCI-ID: 14e4:4315. Despite being marked
as "USB", I suppose it's a  mini-pci (as stated in this list's archives and
some other places).

But looking at:
http://linuxwireless.org/en/users/Drivers/b43#Known_PCI_devices
I can see:

"14e4:4315	not supported	BCM4312 802.11b/g - low power"

So my 1st question is: are BCM4312 and BCM4310 "the same"? Why do they have
the same pci-id?

My second question: at the same page I can read:

"BCM 4310 USB - This device has an LP PHY. We think that means low power.
In any case, previous code does not work. The reverse engineers have
generated specs for the code writers and development is in progress. Note:
This card uses the PCI bus, despite its name."

Please, could you update this info? I don't know whether the comment is up
to date or whether (perhaps) some progress happened since then... any
experimental driver out there?

Thank you.

-- 

Saludos,
-Roman

PGP Fingerprint:
09BB EFCD 21ED 4E79 25FB  29E1 E47F 8A7D EAD5 6742
[Key ID: 0xEAD56742. Available at KeyServ]


From netrolller.3d at gmail.com  Thu Aug  6 00:42:28 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Thu, 6 Aug 2009 00:42:28 +0200
Subject: "BCM 4310 USB" (14e4:4315). Any progress?
In-Reply-To: <4A7A022C.6070208@rs-labs.com>
References: <4A7A022C.6070208@rs-labs.com>
Message-ID: <69e28c910908051542v2cf546d1ja34b14d6c7248d0d@mail.gmail.com>

On Thu, Aug 6, 2009 at 12:05 AM, Roman Medina-Heigl
Hernandez<roman at rs-labs.com> wrote:
> Hello,
>
> Sorry for pinging this list but I did some searches and I couldn't find
> responses...
>
> I've got a new Dell Mini-10 ("Inspiron 1010"), with the following wifi
> chipset: "BCM 4310 USB". It's got PCI-ID: 14e4:4315. Despite being marked
> as "USB", I suppose it's a ?mini-pci (as stated in this list's archives and
> some other places).
>
> But looking at:
> http://linuxwireless.org/en/users/Drivers/b43#Known_PCI_devices
> I can see:
>
> "14e4:4315 ? ? ?not supported ? BCM4312 802.11b/g - low power"
>
> So my 1st question is: are BCM4312 and BCM4310 "the same"? Why do they have
> the same pci-id?

The correct name of the card is BCM4312; some older pci.ids files
incorrectly list it as "BCM4310 USB". Update your pci.ids to fix this.

>
> My second question: at the same page I can read:
>
> "BCM 4310 USB - This device has an LP PHY. We think that means low power.
> In any case, previous code does not work. The reverse engineers have
> generated specs for the code writers and development is in progress. Note:
> This card uses the PCI bus, despite its name."
>
> Please, could you update this info? I don't know whether the comment is up
> to date or whether (perhaps) some progress happened since then... any
> experimental driver out there?
>
> Thank you.

There is no experimental driver yet. I'm currently working on an
implementation, but right now, not even the hardware init code is
complete.

>
> --
>
> Saludos,
> -Roman
>
> PGP Fingerprint:
> 09BB EFCD 21ED 4E79 25FB ?29E1 E47F 8A7D EAD5 6742
> [Key ID: 0xEAD56742. Available at KeyServ]
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From Larry.Finger at lwfinger.net  Thu Aug  6 02:02:49 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 05 Aug 2009 19:02:49 -0500
Subject: "BCM 4310 USB" (14e4:4315). Any progress?
In-Reply-To: <69e28c910908051542v2cf546d1ja34b14d6c7248d0d@mail.gmail.com>
References: <4A7A022C.6070208@rs-labs.com>
	<69e28c910908051542v2cf546d1ja34b14d6c7248d0d@mail.gmail.com>
Message-ID: <4A7A1DA9.2090003@lwfinger.net>

G?bor Stefanik wrote:
> On Thu, Aug 6, 2009 at 12:05 AM, Roman Medina-Heigl
> Hernandez<roman at rs-labs.com> wrote:
>> Hello,
>>
>> Sorry for pinging this list but I did some searches and I couldn't find
>> responses...
>>
>> I've got a new Dell Mini-10 ("Inspiron 1010"), with the following wifi
>> chipset: "BCM 4310 USB". It's got PCI-ID: 14e4:4315. Despite being marked
>> as "USB", I suppose it's a  mini-pci (as stated in this list's archives and
>> some other places).
>>
>> But looking at:
>> http://linuxwireless.org/en/users/Drivers/b43#Known_PCI_devices
>> I can see:
>>
>> "14e4:4315      not supported   BCM4312 802.11b/g - low power"
>>
>> So my 1st question is: are BCM4312 and BCM4310 "the same"? Why do they have
>> the same pci-id?
> 
> The correct name of the card is BCM4312; some older pci.ids files
> incorrectly list it as "BCM4310 USB". Update your pci.ids to fix this.

See below.

>> My second question: at the same page I can read:
>>
>> "BCM 4310 USB - This device has an LP PHY. We think that means low power.
>> In any case, previous code does not work. The reverse engineers have
>> generated specs for the code writers and development is in progress. Note:
>> This card uses the PCI bus, despite its name."
>>
>> Please, could you update this info? I don't know whether the comment is up
>> to date or whether (perhaps) some progress happened since then... any
>> experimental driver out there?

As you have discovered, this info is up to date.

> There is no experimental driver yet. I'm currently working on an
> implementation, but right now, not even the hardware init code is
> complete.

Broadcom really has messed up the naming of the LP devices. For example,

(a) BCM4312 802.11abg devices with ID 14e4:4312 that works with b43
(b) BCM4312 802.11bg devices with ID 14e4:4315 that does not work
(c) BCM4310 USB with ID 14e4:4315 that also does not work with b43

The device in (c) has a USB core that is not enabled. I think Broadcom
was considering a USB implementation; however these have never been
released AFAIK. All of them are built on a PCI base.

Larry


From roman at rs-labs.com  Thu Aug  6 08:38:54 2009
From: roman at rs-labs.com (Roman Medina-Heigl Hernandez)
Date: Thu, 06 Aug 2009 08:38:54 +0200
Subject: "BCM 4310 USB" (14e4:4315). Any progress?
In-Reply-To: <4A7A1DA9.2090003@lwfinger.net>
References: <4A7A022C.6070208@rs-labs.com>
	<69e28c910908051542v2cf546d1ja34b14d6c7248d0d@mail.gmail.com>
	<4A7A1DA9.2090003@lwfinger.net>
Message-ID: <4A7A7A7E.6020400@rs-labs.com>

Larry Finger escribi?:
>>> "BCM 4310 USB - This device has an LP PHY. We think that means low power.
>>> In any case, previous code does not work. The reverse engineers have
>>> generated specs for the code writers and development is in progress. Note:
>>> This card uses the PCI bus, despite its name."
>>>
>>> Please, could you update this info? I don't know whether the comment is up
>>> to date or whether (perhaps) some progress happened since then... any
>>> experimental driver out there?
> 
> As you have discovered, this info is up to date.
> 
>> There is no experimental driver yet. I'm currently working on an
>> implementation, but right now, not even the hardware init code is
>> complete.

Any (aprox.) ETA? End of year perhaps? Meanwhile I think the best choice
for me is this:
http://www.broadcom.com/support/802.11/linux_sta.php
Having sources from vendor, I hope your work gets a little easier and b43
development goes faster so I could use your b43 driver :)

> Broadcom really has messed up the naming of the LP devices. For example,
> 
> (a) BCM4312 802.11abg devices with ID 14e4:4312 that works with b43
> (b) BCM4312 802.11bg devices with ID 14e4:4315 that does not work
> (c) BCM4310 USB with ID 14e4:4315 that also does not work with b43
> 
> The device in (c) has a USB core that is not enabled. I think Broadcom
> was considering a USB implementation; however these have never been
> released AFAIK. All of them are built on a PCI base.

Thank you, G?bor & Larry, for your responses (and to all the team for your
efforts).

Cheers,
-Rom?n


From mb at bu3sch.de  Thu Aug  6 10:36:50 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 6 Aug 2009 10:36:50 +0200
Subject: [PATCH] b43: Fix hardware key index handling
Message-ID: <200908061036.50631.mb@bu3sch.de>

This fixes the hardware encryption keys index and array size handling.

Thanks to Gregor Kowski for reporting this issue.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

This should probably go as a bugfix.
(Does this actually fix the PHY transmission errors? I don't see them anymore...
Note that you need to enable debugging to see them.)


Index: wireless-testing/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/b43.h	2009-08-06 09:58:50.000000000 +0200
+++ wireless-testing/drivers/net/wireless/b43/b43.h	2009-08-06 09:58:53.000000000 +0200
@@ -493,6 +493,10 @@ enum {
 
 /* Max size of a security key */
 #define B43_SEC_KEYSIZE			16
+/* Max number of group keys */
+#define B43_NR_GROUP_KEYS		4
+/* Max number of pairwise keys */
+#define B43_NR_PAIRWISE_KEYS		50
 /* Security algorithms. */
 enum {
 	B43_SEC_ALGO_NONE = 0,	/* unencrypted, as of TX header. */
@@ -819,8 +823,7 @@ struct b43_wldev {
 
 	/* encryption/decryption */
 	u16 ktp;		/* Key table pointer */
-	u8 max_nr_keys;
-	struct b43_key key[58];
+	struct b43_key key[B43_NR_GROUP_KEYS * 2 + B43_NR_PAIRWISE_KEYS];
 
 	/* Firmware data */
 	struct b43_firmware fw;
Index: wireless-testing/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/main.c	2009-08-06 09:58:50.000000000 +0200
+++ wireless-testing/drivers/net/wireless/b43/main.c	2009-08-06 10:28:03.000000000 +0200
@@ -796,18 +796,19 @@ static void key_write(struct b43_wldev *
 static void keymac_write(struct b43_wldev *dev, u8 index, const u8 *addr)
 {
 	u32 addrtmp[2] = { 0, 0, };
-	u8 per_sta_keys_start = 8;
+	u8 pairwise_keys_start = B43_NR_GROUP_KEYS * 2;
 
 	if (b43_new_kidx_api(dev))
-		per_sta_keys_start = 4;
+		pairwise_keys_start = B43_NR_GROUP_KEYS;
 
-	B43_WARN_ON(index < per_sta_keys_start);
-	/* We have two default TX keys and possibly two default RX keys.
+	B43_WARN_ON(index < pairwise_keys_start);
+	/* We have four default TX keys and possibly four default RX keys.
 	 * Physical mac 0 is mapped to physical key 4 or 8, depending
 	 * on the firmware version.
 	 * So we must adjust the index here.
 	 */
-	index -= per_sta_keys_start;
+	index -= pairwise_keys_start;
+	B43_WARN_ON(index >= B43_NR_PAIRWISE_KEYS);
 
 	if (addr) {
 		addrtmp[0] = addr[0];
@@ -818,27 +819,11 @@ static void keymac_write(struct b43_wlde
 		addrtmp[1] |= ((u32) (addr[5]) << 8);
 	}
 
-	if (dev->dev->id.revision >= 5) {
-		/* Receive match transmitter address mechanism */
-		b43_shm_write32(dev, B43_SHM_RCMTA,
-				(index * 2) + 0, addrtmp[0]);
-		b43_shm_write16(dev, B43_SHM_RCMTA,
-				(index * 2) + 1, addrtmp[1]);
-	} else {
-		/* RXE (Receive Engine) and
-		 * PSM (Programmable State Machine) mechanism
-		 */
-		if (index < 8) {
-			/* TODO write to RCM 16, 19, 22 and 25 */
-		} else {
-			b43_shm_write32(dev, B43_SHM_SHARED,
-					B43_SHM_SH_PSM + (index * 6) + 0,
-					addrtmp[0]);
-			b43_shm_write16(dev, B43_SHM_SHARED,
-					B43_SHM_SH_PSM + (index * 6) + 4,
-					addrtmp[1]);
-		}
-	}
+	/* Receive match transmitter address (RCMTA) mechanism */
+	b43_shm_write32(dev, B43_SHM_RCMTA,
+			(index * 2) + 0, addrtmp[0]);
+	b43_shm_write16(dev, B43_SHM_RCMTA,
+			(index * 2) + 1, addrtmp[1]);
 }
 
 static void do_key_write(struct b43_wldev *dev,
@@ -846,20 +831,20 @@ static void do_key_write(struct b43_wlde
 			 const u8 *key, size_t key_len, const u8 *mac_addr)
 {
 	u8 buf[B43_SEC_KEYSIZE] = { 0, };
-	u8 per_sta_keys_start = 8;
+	u8 pairwise_keys_start = B43_NR_GROUP_KEYS * 2;
 
 	if (b43_new_kidx_api(dev))
-		per_sta_keys_start = 4;
+		pairwise_keys_start = B43_NR_GROUP_KEYS;
 
-	B43_WARN_ON(index >= dev->max_nr_keys);
+	B43_WARN_ON(index >= ARRAY_SIZE(dev->key));
 	B43_WARN_ON(key_len > B43_SEC_KEYSIZE);
 
-	if (index >= per_sta_keys_start)
+	if (index >= pairwise_keys_start)
 		keymac_write(dev, index, NULL);	/* First zero out mac. */
 	if (key)
 		memcpy(buf, key, key_len);
 	key_write(dev, index, algorithm, buf);
-	if (index >= per_sta_keys_start)
+	if (index >= pairwise_keys_start)
 		keymac_write(dev, index, mac_addr);
 
 	dev->key[index].algorithm = algorithm;
@@ -872,21 +857,24 @@ static int b43_key_write(struct b43_wlde
 			 struct ieee80211_key_conf *keyconf)
 {
 	int i;
-	int sta_keys_start;
+	int pairwise_keys_start;
 
 	if (key_len > B43_SEC_KEYSIZE)
 		return -EINVAL;
-	for (i = 0; i < dev->max_nr_keys; i++) {
+	for (i = 0; i < ARRAY_SIZE(dev->key); i++) {
 		/* Check that we don't already have this key. */
 		B43_WARN_ON(dev->key[i].keyconf == keyconf);
 	}
 	if (index < 0) {
 		/* Pairwise key. Get an empty slot for the key. */
 		if (b43_new_kidx_api(dev))
-			sta_keys_start = 4;
+			pairwise_keys_start = B43_NR_GROUP_KEYS;
 		else
-			sta_keys_start = 8;
-		for (i = sta_keys_start; i < dev->max_nr_keys; i++) {
+			pairwise_keys_start = B43_NR_GROUP_KEYS * 2;
+		for (i = pairwise_keys_start;
+		     i < pairwise_keys_start + B43_NR_PAIRWISE_KEYS;
+		     i++) {
+			B43_WARN_ON(i >= ARRAY_SIZE(dev->key));
 			if (!dev->key[i].keyconf) {
 				/* found empty */
 				index = i;
@@ -914,7 +902,7 @@ static int b43_key_write(struct b43_wlde
 
 static int b43_key_clear(struct b43_wldev *dev, int index)
 {
-	if (B43_WARN_ON((index < 0) || (index >= dev->max_nr_keys)))
+	if (B43_WARN_ON((index < 0) || (index >= ARRAY_SIZE(dev->key))))
 		return -EINVAL;
 	do_key_write(dev, index, B43_SEC_ALGO_NONE,
 		     NULL, B43_SEC_KEYSIZE, NULL);
@@ -929,15 +917,19 @@ static int b43_key_clear(struct b43_wlde
 
 static void b43_clear_keys(struct b43_wldev *dev)
 {
-	int i;
+	int i, count;
 
-	for (i = 0; i < dev->max_nr_keys; i++)
+	if (b43_new_kidx_api(dev))
+		count = B43_NR_GROUP_KEYS + B43_NR_PAIRWISE_KEYS;
+	else
+		count = B43_NR_GROUP_KEYS * 2 + B43_NR_PAIRWISE_KEYS;
+	for (i = 0; i < count; i++)
 		b43_key_clear(dev, i);
 }
 
 static void b43_dump_keymemory(struct b43_wldev *dev)
 {
-	unsigned int i, index, offset;
+	unsigned int i, index, count, offset, pairwise_keys_start;
 	u8 mac[ETH_ALEN];
 	u16 algo;
 	u32 rcmta0;
@@ -951,7 +943,14 @@ static void b43_dump_keymemory(struct b4
 	hf = b43_hf_read(dev);
 	b43dbg(dev->wl, "Hardware key memory dump:  USEDEFKEYS=%u\n",
 	       !!(hf & B43_HF_USEDEFKEYS));
-	for (index = 0; index < dev->max_nr_keys; index++) {
+	if (b43_new_kidx_api(dev)) {
+		pairwise_keys_start = B43_NR_GROUP_KEYS;
+		count = B43_NR_GROUP_KEYS + B43_NR_PAIRWISE_KEYS;
+	} else {
+		pairwise_keys_start = B43_NR_GROUP_KEYS * 2;
+		count = B43_NR_GROUP_KEYS * 2 + B43_NR_PAIRWISE_KEYS;
+	}
+	for (index = 0; index < count; index++) {
 		key = &(dev->key[index]);
 		printk(KERN_DEBUG "Key slot %02u: %s",
 		       index, (key->keyconf == NULL) ? " " : "*");
@@ -965,11 +964,11 @@ static void b43_dump_keymemory(struct b4
 				      B43_SHM_SH_KEYIDXBLOCK + (index * 2));
 		printk("   Algo: %04X/%02X", algo, key->algorithm);
 
-		if (index >= 4) {
+		if (index >= pairwise_keys_start) {
 			rcmta0 = b43_shm_read32(dev, B43_SHM_RCMTA,
-						((index - 4) * 2) + 0);
+						((index - pairwise_keys_start) * 2) + 0);
 			rcmta1 = b43_shm_read16(dev, B43_SHM_RCMTA,
-						((index - 4) * 2) + 1);
+						((index - pairwise_keys_start) * 2) + 1);
 			*((__le32 *)(&mac[0])) = cpu_to_le32(rcmta0);
 			*((__le16 *)(&mac[4])) = cpu_to_le16(rcmta1);
 			printk("   MAC: %pM", mac);
@@ -2990,17 +2989,14 @@ error:
 
 static void b43_security_init(struct b43_wldev *dev)
 {
-	dev->max_nr_keys = (dev->dev->id.revision >= 5) ? 58 : 20;
-	B43_WARN_ON(dev->max_nr_keys > ARRAY_SIZE(dev->key));
 	dev->ktp = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_KTP);
 	/* KTP is a word address, but we address SHM bytewise.
 	 * So multiply by two.
 	 */
 	dev->ktp *= 2;
-	if (dev->dev->id.revision >= 5) {
-		/* Number of RCMTA address slots */
-		b43_write16(dev, B43_MMIO_RCMTA_COUNT, dev->max_nr_keys - 8);
-	}
+	/* Number of RCMTA address slots */
+	b43_write16(dev, B43_MMIO_RCMTA_COUNT, B43_NR_PAIRWISE_KEYS);
+	/* Clear the key memory. */
 	b43_clear_keys(dev);
 }
 
Index: wireless-testing/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/xmit.c	2009-08-06 09:58:50.000000000 +0200
+++ wireless-testing/drivers/net/wireless/b43/xmit.c	2009-08-06 09:58:53.000000000 +0200
@@ -237,7 +237,7 @@ int b43_generate_txhdr(struct b43_wldev 
 		int wlhdr_len;
 		size_t iv_len;
 
-		B43_WARN_ON(key_idx >= dev->max_nr_keys);
+		B43_WARN_ON(key_idx >= ARRAY_SIZE(dev->key));
 		key = &(dev->key[key_idx]);
 
 		if (unlikely(!key->keyconf)) {
@@ -578,7 +578,7 @@ void b43_rx(struct b43_wldev *dev, struc
 		 * key index, but the ucode passed it slightly different.
 		 */
 		keyidx = b43_kidx_to_raw(dev, keyidx);
-		B43_WARN_ON(keyidx >= dev->max_nr_keys);
+		B43_WARN_ON(keyidx >= ARRAY_SIZE(dev->key));
 
 		if (dev->key[keyidx].algorithm != B43_SEC_ALGO_NONE) {
 			wlhdr_len = ieee80211_hdrlen(fctl);

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Thu Aug  6 16:29:58 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 06 Aug 2009 09:29:58 -0500
Subject: [PATCH] b43: Fix hardware key index handling
In-Reply-To: <200908061036.50631.mb@bu3sch.de>
References: <200908061036.50631.mb@bu3sch.de>
Message-ID: <4A7AE8E6.4050301@lwfinger.net>

Michael Buesch wrote:
> This fixes the hardware encryption keys index and array size handling.
> 
> Thanks to Gregor Kowski for reporting this issue.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> ---
> 
> This should probably go as a bugfix.
> (Does this actually fix the PHY transmission errors? I don't see them anymore...
> Note that you need to enable debugging to see them.)

I still see the PHY transmission errors. I had two of them and a "RX:
packet dropped" debug message within seconds of reloading b43 with
this patch included.

Larry


From mb at bu3sch.de  Thu Aug  6 22:41:00 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 6 Aug 2009 22:41:00 +0200
Subject: [PATCH] b43: Fix hardware key index handling
In-Reply-To: <4A7AE8E6.4050301@lwfinger.net>
References: <200908061036.50631.mb@bu3sch.de> <4A7AE8E6.4050301@lwfinger.net>
Message-ID: <200908062241.00398.mb@bu3sch.de>

On Thursday 06 August 2009 16:29:58 Larry Finger wrote:
> Michael Buesch wrote:
> > This fixes the hardware encryption keys index and array size handling.
> > 
> > Thanks to Gregor Kowski for reporting this issue.
> > 
> > Signed-off-by: Michael Buesch <mb at bu3sch.de>
> > 
> > ---
> > 
> > This should probably go as a bugfix.
> > (Does this actually fix the PHY transmission errors? I don't see them anymore...
> > Note that you need to enable debugging to see them.)
> 
> I still see the PHY transmission errors.

Ah ok. I also have a new AP. Maybe that's why I'm not seeing it here. I'll try
later further away from the AP. That would show them again then...

> I had two of them and a "RX: 
> packet dropped" debug message within seconds of reloading b43 with
> this patch included.

Should be fine. This happens sometimes.
Connection and rekeying does work. (Rekeying might still break if there's
heavy traffic. But that bug always was there. I think it's related to mac80211's
key handling. I also saw it on intel wireless.)

-- 
Greetings, Michael.


From linville at tuxdriver.com  Fri Aug  7 16:37:26 2009
From: linville at tuxdriver.com (John W. Linville)
Date: Fri, 7 Aug 2009 10:37:26 -0400
Subject: [PATCH] b43: Fix hardware key index handling
In-Reply-To: <200908061036.50631.mb@bu3sch.de>
References: <200908061036.50631.mb@bu3sch.de>
Message-ID: <20090807143726.GB7545@tuxdriver.com>

On Thu, Aug 06, 2009 at 10:36:50AM +0200, Michael Buesch wrote:
> This fixes the hardware encryption keys index and array size handling.
> 
> Thanks to Gregor Kowski for reporting this issue.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> ---
> 
> This should probably go as a bugfix.
> (Does this actually fix the PHY transmission errors? I don't see them anymore...
> Note that you need to enable debugging to see them.)

It's getting a bit late in the cycle, especially for a patch so large
and (at least to me) non-obvious.  What is the actual bug being fixed?
What is the effect of leaving it for 2.6.32?

John
-- 
John W. Linville		Someday the world will need a hero, and you
linville at tuxdriver.com			might be all we have.  Be ready.


From mb at bu3sch.de  Fri Aug  7 20:27:09 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 7 Aug 2009 20:27:09 +0200
Subject: [PATCH] b43: Fix hardware key index handling
In-Reply-To: <20090807143726.GB7545@tuxdriver.com>
References: <200908061036.50631.mb@bu3sch.de>
	<20090807143726.GB7545@tuxdriver.com>
Message-ID: <200908072027.09771.mb@bu3sch.de>

On Friday 07 August 2009 16:37:26 John W. Linville wrote:
> On Thu, Aug 06, 2009 at 10:36:50AM +0200, Michael Buesch wrote:
> > This fixes the hardware encryption keys index and array size handling.
> > 
> > Thanks to Gregor Kowski for reporting this issue.
> > 
> > Signed-off-by: Michael Buesch <mb at bu3sch.de>
> > 
> > ---
> > 
> > This should probably go as a bugfix.
> > (Does this actually fix the PHY transmission errors? I don't see them anymore...
> > Note that you need to enable debugging to see them.)
> 
> It's getting a bit late in the cycle, especially for a patch so large
> and (at least to me) non-obvious.  What is the actual bug being fixed?
> What is the effect of leaving it for 2.6.32?

AP mode might break under certain conditions (lots of STAs connected).
Please leave it for .32

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Sun Aug  9 20:15:09 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 09 Aug 2009 20:15:09 +0200
Subject: [PATCH] b43: LP-PHY: Implement STX synchronization
Message-ID: <4A7F122D.3010803@gmail.com>

The v2+ radio init (B2063) is now complete, modulo BCM4325 support.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |   57 +++++++++++++++++++++++++++++++++++-
 1 files changed, 55 insertions(+), 2 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 5d50943..27eadee 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -346,9 +346,60 @@ static void lpphy_2063_init(struct b43_wldev *dev)
 	b43_radio_write(dev, B2063_PA_SP2, 0x18);
 }
 
+struct lpphy_stx_table_entry {
+	u16 phy_offset;
+	u16 phy_shift;
+	u16 rf_addr;
+	u16 rf_shift;
+	u16 mask;
+};
+
+static const struct lpphy_stx_table_entry lpphy_stx_table[] = {
+	{ .phy_offset = 2, .phy_shift = 6, .rf_addr = 0x3d, .rf_shift = 3, .mask = 0x01, },
+	{ .phy_offset = 1, .phy_shift = 12, .rf_addr = 0x4c, .rf_shift = 1, .mask = 0x01, },
+	{ .phy_offset = 1, .phy_shift = 8, .rf_addr = 0x50, .rf_shift = 0, .mask = 0x7f, },
+	{ .phy_offset = 0, .phy_shift = 8, .rf_addr = 0x44, .rf_shift = 0, .mask = 0xff, },
+	{ .phy_offset = 1, .phy_shift = 0, .rf_addr = 0x4a, .rf_shift = 0, .mask = 0xff, },
+	{ .phy_offset = 0, .phy_shift = 4, .rf_addr = 0x4d, .rf_shift = 0, .mask = 0xff, },
+	{ .phy_offset = 1, .phy_shift = 4, .rf_addr = 0x4e, .rf_shift = 0, .mask = 0xff, },
+	{ .phy_offset = 0, .phy_shift = 12, .rf_addr = 0x4f, .rf_shift = 0, .mask = 0x0f, },
+	{ .phy_offset = 1, .phy_shift = 0, .rf_addr = 0x4f, .rf_shift = 4, .mask = 0x0f, },
+	{ .phy_offset = 3, .phy_shift = 0, .rf_addr = 0x49, .rf_shift = 0, .mask = 0x0f, },
+	{ .phy_offset = 4, .phy_shift = 3, .rf_addr = 0x46, .rf_shift = 4, .mask = 0x07, },
+	{ .phy_offset = 3, .phy_shift = 15, .rf_addr = 0x46, .rf_shift = 0, .mask = 0x01, },
+	{ .phy_offset = 4, .phy_shift = 0, .rf_addr = 0x46, .rf_shift = 1, .mask = 0x07, },
+	{ .phy_offset = 3, .phy_shift = 8, .rf_addr = 0x48, .rf_shift = 4, .mask = 0x07, },
+	{ .phy_offset = 3, .phy_shift = 11, .rf_addr = 0x48, .rf_shift = 0, .mask = 0x0f, },
+	{ .phy_offset = 3, .phy_shift = 4, .rf_addr = 0x49, .rf_shift = 4, .mask = 0x0f, },
+	{ .phy_offset = 2, .phy_shift = 15, .rf_addr = 0x45, .rf_shift = 0, .mask = 0x01, },
+	{ .phy_offset = 5, .phy_shift = 13, .rf_addr = 0x52, .rf_shift = 4, .mask = 0x07, },
+	{ .phy_offset = 6, .phy_shift = 0, .rf_addr = 0x52, .rf_shift = 7, .mask = 0x01, },
+	{ .phy_offset = 5, .phy_shift = 3, .rf_addr = 0x41, .rf_shift = 5, .mask = 0x07, },
+	{ .phy_offset = 5, .phy_shift = 6, .rf_addr = 0x41, .rf_shift = 0, .mask = 0x0f, },
+	{ .phy_offset = 5, .phy_shift = 10, .rf_addr = 0x42, .rf_shift = 5, .mask = 0x07, },
+	{ .phy_offset = 4, .phy_shift = 15, .rf_addr = 0x42, .rf_shift = 0, .mask = 0x01, },
+	{ .phy_offset = 5, .phy_shift = 0, .rf_addr = 0x42, .rf_shift = 1, .mask = 0x07, },
+	{ .phy_offset = 4, .phy_shift = 11, .rf_addr = 0x43, .rf_shift = 4, .mask = 0x0f, },
+	{ .phy_offset = 4, .phy_shift = 7, .rf_addr = 0x43, .rf_shift = 0, .mask = 0x0f, },
+	{ .phy_offset = 4, .phy_shift = 6, .rf_addr = 0x45, .rf_shift = 1, .mask = 0x01, },
+	{ .phy_offset = 2, .phy_shift = 7, .rf_addr = 0x40, .rf_shift = 4, .mask = 0x0f, },
+	{ .phy_offset = 2, .phy_shift = 11, .rf_addr = 0x40, .rf_shift = 0, .mask = 0x0f, },
+};
+
 static void lpphy_sync_stx(struct b43_wldev *dev)
 {
-	//TODO
+	const struct lpphy_stx_table_entry *e;
+	unsigned int i;
+	u16 tmp;
+
+	for (i = 0; i < ARRAY_SIZE(lpphy_stx_table); i++) {
+		e = &lpphy_stx_table[i];
+		tmp = b43_radio_read(dev, e->rf_addr);
+		tmp >>= e->rf_shift;
+		tmp <<= e->phy_shift;
+		b43_phy_maskset(dev, B43_PHY_OFDM(0xF2 + e->phy_offset),
+				e->mask << e->phy_shift, tmp);
+	}
 }
 
 static void lpphy_radio_init(struct b43_wldev *dev)
@@ -366,7 +417,9 @@ static void lpphy_radio_init(struct b43_wldev *dev)
 		lpphy_sync_stx(dev);
 		b43_phy_write(dev, B43_PHY_OFDM(0xF0), 0x5F80);
 		b43_phy_write(dev, B43_PHY_OFDM(0xF1), 0);
-		//TODO Do something on the backplane
+		if (dev->dev->bus->chip_id == 0x4325) {
+			// TODO SSB PMU recalibration
+		}
 	}
 }
 
-- 
1.6.2.4




From mb at bu3sch.de  Sun Aug  9 20:17:17 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 9 Aug 2009 20:17:17 +0200
Subject: [PATCH] b43: LP-PHY: Implement STX synchronization
In-Reply-To: <4A7F122D.3010803@gmail.com>
References: <4A7F122D.3010803@gmail.com>
Message-ID: <200908092017.17926.mb@bu3sch.de>

On Sunday 09 August 2009 20:15:09 G?bor Stefanik wrote:
> The v2+ radio init (B2063) is now complete, modulo BCM4325 support.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

ack

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Mon Aug 10 03:00:46 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Mon, 10 Aug 2009 03:00:46 +0200
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
Message-ID: <4A7F713E.8040405@gmail.com>

Implement LP-PHY baseband table init for all revisions.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

---
Sorry for the size; it's difficult to cut short changes like this
(most of the patch is just table data). Please review, there may always be
bugs that I failed to catch while reading through the code. I have added
comments to places that were not quite clear to me.

 phy_lp.c       |   41 
 tables_lpphy.c | 3223 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 tables_lpphy.h |    3 
 3 files changed, 3263 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 27eadee..cf17489 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -59,9 +59,43 @@ static void b43_lpphy_op_free(struct b43_wldev *dev)
 	dev->phy.lp = NULL;
 }
 
+static void lpphy_adjust_gain_table(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	u32 freq = dev->wl->hw->conf.channel->center_freq;
+	u16 temp[3];
+	u16 isolation;
+
+	B43_WARN_ON(dev->phy.rev >= 2);
+
+	if (freq < 2400) /* FIXME Can this ever happen? Should we WARN_ON? */
+		isolation = lpphy->tx_isolation_med_band;
+	else if (freq <= 5320)
+		isolation = lpphy->tx_isolation_low_band;
+	else if (freq <= 5700)
+		isolation = lpphy->tx_isolation_med_band;
+	else
+		isolation = lpphy->tx_isolation_hi_band;
+
+	temp[0] = ((isolation - 26) / 12) << 12;
+	temp[1] = temp[0] + 0x1000;
+	temp[2] = temp[0] + 0x2000;
+
+	b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0), 3, temp);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0), 3, temp);
+}
+
 static void lpphy_table_init(struct b43_wldev *dev)
 {
-	//TODO
+	if (dev->phy.rev < 2)
+		lpphy_rev0_1_table_init(dev);
+	else
+		lpphy_rev2plus_table_init(dev);
+
+	lpphy_init_tx_gain_table(dev);
+
+	if (dev->phy.rev < 2)
+		lpphy_adjust_gain_table(dev);
 }
 
 static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
@@ -596,13 +630,13 @@ static void lpphy_tx_pctl_init(struct b43_wldev *dev)
 static int b43_lpphy_op_init(struct b43_wldev *dev)
 {
 	/* TODO: band SPROM */
-	/* TODO: tables init */
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
 	//TODO calibrate RC
 	//TODO set channel
 	lpphy_tx_pctl_init(dev);
-	//TODO full calib
+	lpphy_calibration(dev);
+	//TODO ACI init
 
 	return 0;
 }
@@ -680,7 +714,6 @@ static enum b43_txpwr_result b43_lpphy_op_recalc_txpower(struct b43_wldev *dev,
 	return B43_TXPWR_RES_DONE;
 }
 
-
 const struct b43_phy_operations b43_phyops_lp = {
 	.allocate		= b43_lpphy_op_allocate,
 	.free			= b43_lpphy_op_free,
diff --git a/drivers/net/wireless/b43/tables_lpphy.c b/drivers/net/wireless/b43/tables_lpphy.c
index cadfe81..8f57bd4 100644
--- a/drivers/net/wireless/b43/tables_lpphy.c
+++ b/drivers/net/wireless/b43/tables_lpphy.c
@@ -710,3 +710,3226 @@ void b43_lptab_write_bulk(struct b43_wldev *dev, u32 offset,
 		offset++;
 	}
 }
+
+static const u8 lpphy_min_sig_sq_table[] = {
+	0xde,
+	0xdc,
+	0xda,
+	0xd8,
+	0xd6,
+	0xd4,
+	0xd2,
+	0xcf,
+	0xcd,
+	0xca,
+	0xc7,
+	0xc4,
+	0xc1,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0x00,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xbe,
+	0xc1,
+	0xc4,
+	0xc7,
+	0xca,
+	0xcd,
+	0xcf,
+	0xd2,
+	0xd4,
+	0xd6,
+	0xd8,
+	0xda,
+	0xdc,
+	0xde,
+};
+
+static const u16 lpphy_rev01_noise_scale_table[] = {
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa400,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0xa4a4,
+	0x00a4,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x4c00,
+	0x2d36,
+	0x0000,
+	0x0000,
+	0x4c00,
+	0x2d36,
+};
+
+static const u16 lpphy_rev2plus_noise_scale_table[] = {
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x0000,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+	0x00a4,
+};
+
+static const u16 lpphy_crs_gain_nft_table[] = {
+	0x0366,
+	0x036a,
+	0x036f,
+	0x0364,
+	0x0367,
+	0x036d,
+	0x0374,
+	0x037f,
+	0x036f,
+	0x037b,
+	0x038a,
+	0x0378,
+	0x0367,
+	0x036d,
+	0x0375,
+	0x0381,
+	0x0374,
+	0x0381,
+	0x0392,
+	0x03a9,
+	0x03c4,
+	0x03e1,
+	0x0001,
+	0x001f,
+	0x0040,
+	0x005e,
+	0x007f,
+	0x009e,
+	0x00bd,
+	0x00dd,
+	0x00fd,
+	0x011d,
+	0x013d,
+};
+
+static const u16 lpphy_rev01_filter_control_table[] = {
+	0xa0fc,
+	0x10fc,
+	0x10db,
+	0x20b7,
+	0xff93,
+	0x10bf,
+	0x109b,
+	0x2077,
+	0xff53,
+	0x0127,
+};
+
+static const u32 lpphy_rev2plus_filter_control_table[] = {
+	0x000141fc,
+	0x000021fc,
+	0x000021b7,
+	0x0000416f,
+	0x0001ff27,
+	0x0000217f,
+	0x00002137,
+	0x000040ef,
+	0x0001fea7,
+	0x0000024f,
+};
+
+static const u32 lpphy_rev01_ps_control_table[] = {
+	0x00010000,
+	0x000000a0,
+	0x00040000,
+	0x00000048,
+	0x08080101,
+	0x00000080,
+	0x08080101,
+	0x00000040,
+	0x08080101,
+	0x000000c0,
+	0x08a81501,
+	0x000000c0,
+	0x0fe8fd01,
+	0x000000c0,
+	0x08300105,
+	0x000000c0,
+	0x08080201,
+	0x000000c0,
+	0x08280205,
+	0x000000c0,
+	0xe80802fe,
+	0x000000c7,
+	0x28080206,
+	0x000000c0,
+	0x08080202,
+	0x000000c0,
+	0x0ba87602,
+	0x000000c0,
+	0x1068013d,
+	0x000000c0,
+	0x10280105,
+	0x000000c0,
+	0x08880102,
+	0x000000c0,
+	0x08280106,
+	0x000000c0,
+	0xe80801fd,
+	0x000000c7,
+	0xa8080115,
+	0x000000c0,
+};
+
+static const u32 lpphy_rev2plus_ps_control_table[] = {
+	0x00e38e08,
+	0x00e08e38,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00002080,
+	0x00006180,
+	0x00003002,
+	0x00000040,
+	0x00002042,
+	0x00180047,
+	0x00080043,
+	0x00000041,
+	0x000020c1,
+	0x00046006,
+	0x00042002,
+	0x00040000,
+	0x00002003,
+	0x00180006,
+	0x00080002,
+};
+
+static const u8 lpphy_pll_fraction_table[] = {
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x00,
+	0x00,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+};
+
+static const u16 lpphy_iq_local_table[] = {
+	0x0200,
+	0x0300,
+	0x0400,
+	0x0600,
+	0x0800,
+	0x0b00,
+	0x1000,
+	0x1001,
+	0x1002,
+	0x1003,
+	0x1004,
+	0x1005,
+	0x1006,
+	0x1007,
+	0x1707,
+	0x2007,
+	0x2d07,
+	0x4007,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0200,
+	0x0300,
+	0x0400,
+	0x0600,
+	0x0800,
+	0x0b00,
+	0x1000,
+	0x1001,
+	0x1002,
+	0x1003,
+	0x1004,
+	0x1005,
+	0x1006,
+	0x1007,
+	0x1707,
+	0x2007,
+	0x2d07,
+	0x4007,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x4000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+};
+
+static const u16 lpphy_ofdm_cck_gain_table[] = {
+	0x5000,
+	0x6000,
+	0x7000,
+	0x0001,
+	0x1001,
+	0x2001,
+	0x3001,
+	0x4001,
+	0x5001,
+	0x6001,
+	0x7001,
+	0x7011,
+	0x7021,
+	0x2035,
+	0x2045,
+	0x2055,
+	0x2065,
+	0x2075,
+	0x006d,
+	0x007d,
+	0x014d,
+	0x015d,
+	0x115d,
+	0x035d,
+	0x135d,
+	0x055d,
+	0x155d,
+	0x0d5d,
+	0x1d5d,
+	0x2d5d,
+	0x555d,
+	0x655d,
+	0x755d,
+};
+
+static const u16 lpphy_gain_delta_table[] = {
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+};
+
+static const u32 lpphy_tx_power_control_table[] = {
+	0x00000050,
+	0x0000004f,
+	0x0000004e,
+	0x0000004d,
+	0x0000004c,
+	0x0000004b,
+	0x0000004a,
+	0x00000049,
+	0x00000048,
+	0x00000047,
+	0x00000046,
+	0x00000045,
+	0x00000044,
+	0x00000043,
+	0x00000042,
+	0x00000041,
+	0x00000040,
+	0x0000003f,
+	0x0000003e,
+	0x0000003d,
+	0x0000003c,
+	0x0000003b,
+	0x0000003a,
+	0x00000039,
+	0x00000038,
+	0x00000037,
+	0x00000036,
+	0x00000035,
+	0x00000034,
+	0x00000033,
+	0x00000032,
+	0x00000031,
+	0x00000030,
+	0x0000002f,
+	0x0000002e,
+	0x0000002d,
+	0x0000002c,
+	0x0000002b,
+	0x0000002a,
+	0x00000029,
+	0x00000028,
+	0x00000027,
+	0x00000026,
+	0x00000025,
+	0x00000024,
+	0x00000023,
+	0x00000022,
+	0x00000021,
+	0x00000020,
+	0x0000001f,
+	0x0000001e,
+	0x0000001d,
+	0x0000001c,
+	0x0000001b,
+	0x0000001a,
+	0x00000019,
+	0x00000018,
+	0x00000017,
+	0x00000016,
+	0x00000015,
+	0x00000014,
+	0x00000013,
+	0x00000012,
+	0x00000011,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x000075a0,
+	0x000075a0,
+	0x000075a1,
+	0x000075a1,
+	0x000075a2,
+	0x000075a2,
+	0x000075a3,
+	0x000075a3,
+	0x000074b0,
+	0x000074b0,
+	0x000074b1,
+	0x000074b1,
+	0x000074b2,
+	0x000074b2,
+	0x000074b3,
+	0x000074b3,
+	0x00006d20,
+	0x00006d20,
+	0x00006d21,
+	0x00006d21,
+	0x00006d22,
+	0x00006d22,
+	0x00006d23,
+	0x00006d23,
+	0x00004660,
+	0x00004660,
+	0x00004661,
+	0x00004661,
+	0x00004662,
+	0x00004662,
+	0x00004663,
+	0x00004663,
+	0x00003e60,
+	0x00003e60,
+	0x00003e61,
+	0x00003e61,
+	0x00003e62,
+	0x00003e62,
+	0x00003e63,
+	0x00003e63,
+	0x00003660,
+	0x00003660,
+	0x00003661,
+	0x00003661,
+	0x00003662,
+	0x00003662,
+	0x00003663,
+	0x00003663,
+	0x00002e60,
+	0x00002e60,
+	0x00002e61,
+	0x00002e61,
+	0x00002e62,
+	0x00002e62,
+	0x00002e63,
+	0x00002e63,
+	0x00002660,
+	0x00002660,
+	0x00002661,
+	0x00002661,
+	0x00002662,
+	0x00002662,
+	0x00002663,
+	0x00002663,
+	0x000025e0,
+	0x000025e0,
+	0x000025e1,
+	0x000025e1,
+	0x000025e2,
+	0x000025e2,
+	0x000025e3,
+	0x000025e3,
+	0x00001de0,
+	0x00001de0,
+	0x00001de1,
+	0x00001de1,
+	0x00001de2,
+	0x00001de2,
+	0x00001de3,
+	0x00001de3,
+	0x00001d60,
+	0x00001d60,
+	0x00001d61,
+	0x00001d61,
+	0x00001d62,
+	0x00001d62,
+	0x00001d63,
+	0x00001d63,
+	0x00001560,
+	0x00001560,
+	0x00001561,
+	0x00001561,
+	0x00001562,
+	0x00001562,
+	0x00001563,
+	0x00001563,
+	0x00000d60,
+	0x00000d60,
+	0x00000d61,
+	0x00000d61,
+	0x00000d62,
+	0x00000d62,
+	0x00000d63,
+	0x00000d63,
+	0x00000ce0,
+	0x00000ce0,
+	0x00000ce1,
+	0x00000ce1,
+	0x00000ce2,
+	0x00000ce2,
+	0x00000ce3,
+	0x00000ce3,
+	0x00000e10,
+	0x00000e10,
+	0x00000e11,
+	0x00000e11,
+	0x00000e12,
+	0x00000e12,
+	0x00000e13,
+	0x00000e13,
+	0x00000bf0,
+	0x00000bf0,
+	0x00000bf1,
+	0x00000bf1,
+	0x00000bf2,
+	0x00000bf2,
+	0x00000bf3,
+	0x00000bf3,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x04200000,
+	0x04000000,
+	0x000000ff,
+	0x000002fc,
+	0x0000fa08,
+	0x00000305,
+	0x00000206,
+	0x00000304,
+	0x0000fb04,
+	0x0000fcff,
+	0x000005fb,
+	0x0000fd01,
+	0x00000401,
+	0x00000006,
+	0x0000ff03,
+	0x000007fc,
+	0x0000fc08,
+	0x00000203,
+	0x0000fffb,
+	0x00000600,
+	0x0000fa01,
+	0x0000fc03,
+	0x0000fe06,
+	0x0000fe00,
+	0x00000102,
+	0x000007fd,
+	0x000004fb,
+	0x000006ff,
+	0x000004fd,
+	0x0000fdfa,
+	0x000007fb,
+	0x0000fdfa,
+	0x0000fa06,
+	0x00000500,
+	0x0000f902,
+	0x000007fa,
+	0x0000fafa,
+	0x00000500,
+	0x000007fa,
+	0x00000700,
+	0x00000305,
+	0x000004ff,
+	0x00000801,
+	0x00000503,
+	0x000005f9,
+	0x00000404,
+	0x0000fb08,
+	0x000005fd,
+	0x00000501,
+	0x00000405,
+	0x0000fb03,
+	0x000007fc,
+	0x00000403,
+	0x00000303,
+	0x00000402,
+	0x0000faff,
+	0x0000fe05,
+	0x000005fd,
+	0x0000fe01,
+	0x000007fa,
+	0x00000202,
+	0x00000504,
+	0x00000102,
+	0x000008fe,
+	0x0000fa04,
+	0x0000fafc,
+	0x0000fe08,
+	0x000000f9,
+	0x000002fa,
+	0x000003fe,
+	0x00000304,
+	0x000004f9,
+	0x00000100,
+	0x0000fd06,
+	0x000008fc,
+	0x00000701,
+	0x00000504,
+	0x0000fdfe,
+	0x0000fdfc,
+	0x000003fe,
+	0x00000704,
+	0x000002fc,
+	0x000004f9,
+	0x0000fdfd,
+	0x0000fa07,
+	0x00000205,
+	0x000003fd,
+	0x000005fb,
+	0x000004f9,
+	0x00000804,
+	0x0000fc06,
+	0x0000fcf9,
+	0x00000100,
+	0x0000fe05,
+	0x00000408,
+	0x0000fb02,
+	0x00000304,
+	0x000006fe,
+	0x000004fa,
+	0x00000305,
+	0x000008fc,
+	0x00000102,
+	0x000001fd,
+	0x000004fc,
+	0x0000fe03,
+	0x00000701,
+	0x000001fb,
+	0x000001f9,
+	0x00000206,
+	0x000006fd,
+	0x00000508,
+	0x00000700,
+	0x00000304,
+	0x000005fe,
+	0x000005ff,
+	0x0000fa04,
+	0x00000303,
+	0x0000fefb,
+	0x000007f9,
+	0x0000fefc,
+	0x000004fd,
+	0x000005fc,
+	0x0000fffd,
+	0x0000fc08,
+	0x0000fbf9,
+	0x0000fd07,
+	0x000008fb,
+	0x0000fe02,
+	0x000006fb,
+	0x00000702,
+};
+
+static const u32 lpphy_gain_idx_table[] = {
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x10000001,
+	0x00000000,
+	0x20000082,
+	0x00000000,
+	0x40000104,
+	0x00000000,
+	0x60004207,
+	0x00000001,
+	0x7000838a,
+	0x00000001,
+	0xd021050d,
+	0x00000001,
+	0xe041c683,
+	0x00000001,
+	0x50828805,
+	0x00000000,
+	0x80e34288,
+	0x00000000,
+	0xb144040b,
+	0x00000000,
+	0xe1a6058e,
+	0x00000000,
+	0x12064711,
+	0x00000001,
+	0xb0a18612,
+	0x00000010,
+	0xe1024794,
+	0x00000010,
+	0x11630915,
+	0x00000011,
+	0x31c3ca1b,
+	0x00000011,
+	0xc1848a9c,
+	0x00000018,
+	0xf1e50da0,
+	0x00000018,
+	0x22468e21,
+	0x00000019,
+	0x4286d023,
+	0x00000019,
+	0xa347d0a4,
+	0x00000019,
+	0xb36811a6,
+	0x00000019,
+	0xf3e89227,
+	0x00000019,
+	0x0408d329,
+	0x0000001a,
+	0x244953aa,
+	0x0000001a,
+	0x346994ab,
+	0x0000001a,
+	0x54aa152c,
+	0x0000001a,
+	0x64ca55ad,
+	0x0000001a,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x10000001,
+	0x00000000,
+	0x20000082,
+	0x00000000,
+	0x40000104,
+	0x00000000,
+	0x60004207,
+	0x00000001,
+	0x7000838a,
+	0x00000001,
+	0xd021050d,
+	0x00000001,
+	0xe041c683,
+	0x00000001,
+	0x50828805,
+	0x00000000,
+	0x80e34288,
+	0x00000000,
+	0xb144040b,
+	0x00000000,
+	0xe1a6058e,
+	0x00000000,
+	0x12064711,
+	0x00000001,
+	0xb0a18612,
+	0x00000010,
+	0xe1024794,
+	0x00000010,
+	0x11630915,
+	0x00000011,
+	0x31c3ca1b,
+	0x00000011,
+	0xc1848a9c,
+	0x00000018,
+	0xf1e50da0,
+	0x00000018,
+	0x22468e21,
+	0x00000019,
+	0x4286d023,
+	0x00000019,
+	0xa347d0a4,
+	0x00000019,
+	0xb36811a6,
+	0x00000019,
+	0xf3e89227,
+	0x00000019,
+	0x0408d329,
+	0x0000001a,
+	0x244953aa,
+	0x0000001a,
+	0x346994ab,
+	0x0000001a,
+	0x54aa152c,
+	0x0000001a,
+	0x64ca55ad,
+	0x0000001a,
+};
+
+static const u16 lpphy_aux_gain_idx_table[] = {
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0001,
+	0x0002,
+	0x0004,
+	0x0016,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0001,
+	0x0002,
+	0x0004,
+	0x0016,
+};
+
+static const u32 lpphy_gain_value_table[] = {
+	0x00000008,
+	0x0000000e,
+	0x00000014,
+	0x0000001a,
+	0x000000fb,
+	0x00000004,
+	0x00000008,
+	0x0000000d,
+	0x00000001,
+	0x00000004,
+	0x00000007,
+	0x0000000a,
+	0x0000000d,
+	0x00000010,
+	0x00000012,
+	0x00000015,
+	0x00000000,
+	0x00000006,
+	0x0000000c,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000012,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000018,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x0000001e,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000003,
+	0x00000006,
+	0x00000009,
+	0x0000000c,
+	0x0000000f,
+	0x00000012,
+	0x00000015,
+	0x00000018,
+	0x0000001b,
+	0x0000001e,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000009,
+	0x000000f1,
+	0x00000000,
+	0x00000000,
+};
+
+static const u16 lpphy_gain_table[] = {
+	0x0000,
+	0x0400,
+	0x0800,
+	0x0802,
+	0x0804,
+	0x0806,
+	0x0807,
+	0x0808,
+	0x080a,
+	0x080b,
+	0x080c,
+	0x080e,
+	0x080f,
+	0x0810,
+	0x0812,
+	0x0813,
+	0x0814,
+	0x0816,
+	0x0817,
+	0x081a,
+	0x081b,
+	0x081f,
+	0x0820,
+	0x0824,
+	0x0830,
+	0x0834,
+	0x0837,
+	0x083b,
+	0x083f,
+	0x0840,
+	0x0844,
+	0x0857,
+	0x085b,
+	0x085f,
+	0x08d7,
+	0x08db,
+	0x08df,
+	0x0957,
+	0x095b,
+	0x095f,
+	0x0b57,
+	0x0b5b,
+	0x0b5f,
+	0x0f5f,
+	0x135f,
+	0x175f,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+};
+
+static const u32 lpphy_a0_gain_idx_table[] = {
+	0x001111e0,
+	0x00652051,
+	0x00606055,
+	0x005b005a,
+	0x00555060,
+	0x00511065,
+	0x004c806b,
+	0x0047d072,
+	0x00444078,
+	0x00400080,
+	0x003ca087,
+	0x0039408f,
+	0x0035e098,
+	0x0032e0a1,
+	0x003030aa,
+	0x002d80b4,
+	0x002ae0bf,
+	0x002880ca,
+	0x002640d6,
+	0x002410e3,
+	0x002220f0,
+	0x002020ff,
+	0x001e510e,
+	0x001ca11e,
+	0x001b012f,
+	0x00199140,
+	0x00182153,
+	0x0016c168,
+	0x0015817d,
+	0x00145193,
+	0x001321ab,
+	0x001211c5,
+	0x001111e0,
+	0x001021fc,
+	0x000f321a,
+	0x000e523a,
+	0x000d925c,
+	0x000cd27f,
+	0x000c12a5,
+	0x000b62cd,
+	0x000ac2f8,
+	0x000a2325,
+	0x00099355,
+	0x00091387,
+	0x000883bd,
+	0x000813f5,
+	0x0007a432,
+	0x00073471,
+	0x0006c4b5,
+	0x000664fc,
+	0x00061547,
+	0x0005b598,
+	0x000565ec,
+	0x00051646,
+	0x0004d6a5,
+	0x0004870a,
+	0x00044775,
+	0x000407e6,
+	0x0003d85e,
+	0x000398dd,
+	0x00036963,
+	0x000339f2,
+	0x00030a89,
+	0x0002db28,
+};
+
+static const u16 lpphy_a0_aux_gain_idx_table[] = {
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0002,
+	0x0014,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0002,
+	0x0014,
+};
+
+static const u32 lpphy_a0_gain_value_table[] = {
+	0x00000008,
+	0x0000000e,
+	0x00000014,
+	0x0000001a,
+	0x000000fb,
+	0x00000004,
+	0x00000008,
+	0x0000000d,
+	0x00000001,
+	0x00000004,
+	0x00000007,
+	0x0000000a,
+	0x0000000d,
+	0x00000010,
+	0x00000012,
+	0x00000015,
+	0x00000000,
+	0x00000006,
+	0x0000000c,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000012,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000018,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x0000001e,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000003,
+	0x00000006,
+	0x00000009,
+	0x0000000c,
+	0x0000000f,
+	0x00000012,
+	0x00000015,
+	0x00000018,
+	0x0000001b,
+	0x0000001e,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x0000000f,
+	0x000000f7,
+	0x00000000,
+	0x00000000,
+};
+
+static const u16 lpphy_a0_gain_table[] = {
+	0x0000,
+	0x0002,
+	0x0004,
+	0x0006,
+	0x0007,
+	0x0008,
+	0x000a,
+	0x000b,
+	0x000c,
+	0x000e,
+	0x000f,
+	0x0010,
+	0x0012,
+	0x0013,
+	0x0014,
+	0x0016,
+	0x0017,
+	0x001a,
+	0x001b,
+	0x001f,
+	0x0020,
+	0x0024,
+	0x0030,
+	0x0034,
+	0x0037,
+	0x003b,
+	0x003f,
+	0x0040,
+	0x0044,
+	0x0057,
+	0x005b,
+	0x005f,
+	0x00d7,
+	0x00db,
+	0x00df,
+	0x0157,
+	0x015b,
+	0x015f,
+	0x0357,
+	0x035b,
+	0x035f,
+	0x075f,
+	0x0b5f,
+	0x0f5f,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+};
+
+static const u16 lpphy_sw_control_table[] = {
+	0x0128,
+	0x0128,
+	0x0009,
+	0x0009,
+	0x0028,
+	0x0028,
+	0x0028,
+	0x0028,
+	0x0128,
+	0x0128,
+	0x0009,
+	0x0009,
+	0x0028,
+	0x0028,
+	0x0028,
+	0x0028,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0018,
+	0x0018,
+	0x0018,
+	0x0018,
+	0x0018,
+	0x0018,
+	0x0018,
+	0x0018,
+	0x0128,
+	0x0128,
+	0x0009,
+	0x0009,
+	0x0028,
+	0x0028,
+	0x0028,
+	0x0028,
+	0x0128,
+	0x0128,
+	0x0009,
+	0x0009,
+	0x0028,
+	0x0028,
+	0x0028,
+	0x0028,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0009,
+	0x0018,
+	0x0018,
+	0x0018,
+	0x0018,
+	0x0018,
+	0x0018,
+	0x0018,
+	0x0018,
+};
+
+static const u8 lpphy_hf_table[] = {
+	0x4b,
+	0x36,
+	0x24,
+	0x18,
+	0x49,
+	0x34,
+	0x23,
+	0x17,
+	0x48,
+	0x33,
+	0x23,
+	0x17,
+	0x48,
+	0x33,
+	0x23,
+	0x17,
+};
+
+static const u32 lpphy_papd_eps_table[] = {
+	0x00000000,
+	0x00013ffc,
+	0x0001dff3,
+	0x0001bff0,
+	0x00023fe9,
+	0x00021fdf,
+	0x00028fdf,
+	0x00033fd2,
+	0x00039fcb,
+	0x00043fc7,
+	0x0004efc2,
+	0x00055fb5,
+	0x0005cfb0,
+	0x00063fa8,
+	0x00068fa3,
+	0x00071f98,
+	0x0007ef92,
+	0x00084f8b,
+	0x0008df82,
+	0x00097f77,
+	0x0009df69,
+	0x000a3f62,
+	0x000adf57,
+	0x000b6f4c,
+	0x000bff41,
+	0x000c9f39,
+	0x000cff30,
+	0x000dbf27,
+	0x000e4f1e,
+	0x000edf16,
+	0x000f7f13,
+	0x00102f11,
+	0x00110f10,
+	0x0011df11,
+	0x0012ef15,
+	0x00143f1c,
+	0x00158f27,
+	0x00172f35,
+	0x00193f47,
+	0x001baf5f,
+	0x001e6f7e,
+	0x0021cfa4,
+	0x0025bfd2,
+	0x002a2008,
+	0x002fb047,
+	0x00360090,
+	0x003d40e0,
+	0x0045c135,
+	0x004fb189,
+	0x005ae1d7,
+	0x0067221d,
+	0x0075025a,
+	0x007ff291,
+	0x007ff2bf,
+	0x007ff2e3,
+	0x007ff2ff,
+	0x007ff315,
+	0x007ff329,
+	0x007ff33f,
+	0x007ff356,
+	0x007ff36e,
+	0x007ff39c,
+	0x007ff441,
+	0x007ff506,
+};
+
+static const u32 lpphy_papd_mult_table[] = {
+	0x001111e0,
+	0x00652051,
+	0x00606055,
+	0x005b005a,
+	0x00555060,
+	0x00511065,
+	0x004c806b,
+	0x0047d072,
+	0x00444078,
+	0x00400080,
+	0x003ca087,
+	0x0039408f,
+	0x0035e098,
+	0x0032e0a1,
+	0x003030aa,
+	0x002d80b4,
+	0x002ae0bf,
+	0x002880ca,
+	0x002640d6,
+	0x002410e3,
+	0x002220f0,
+	0x002020ff,
+	0x001e510e,
+	0x001ca11e,
+	0x001b012f,
+	0x00199140,
+	0x00182153,
+	0x0016c168,
+	0x0015817d,
+	0x00145193,
+	0x001321ab,
+	0x001211c5,
+	0x001111e0,
+	0x001021fc,
+	0x000f321a,
+	0x000e523a,
+	0x000d925c,
+	0x000cd27f,
+	0x000c12a5,
+	0x000b62cd,
+	0x000ac2f8,
+	0x000a2325,
+	0x00099355,
+	0x00091387,
+	0x000883bd,
+	0x000813f5,
+	0x0007a432,
+	0x00073471,
+	0x0006c4b5,
+	0x000664fc,
+	0x00061547,
+	0x0005b598,
+	0x000565ec,
+	0x00051646,
+	0x0004d6a5,
+	0x0004870a,
+	0x00044775,
+	0x000407e6,
+	0x0003d85e,
+	0x000398dd,
+	0x00036963,
+	0x000339f2,
+	0x00030a89,
+	0x0002db28,
+};
+
+struct lpphy_tx_gain_table_entry {
+u8 gm,  pga,  pad,  dac,  bb_mult;
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev0_nopa_tx_gain_table[] = {
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 152, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 147, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 143, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 139, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 135, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 131, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 128, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 124, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 121, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 117, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 114, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 111, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 107, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 104, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 101, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 99, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 96, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 93, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 90, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 88, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 85, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 83, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 81, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 78, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 76, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 74, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 71, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev0_2ghz_tx_gain_table[] = {
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 73, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 73, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 58, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 58, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 57, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 83, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 81, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 78, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 76, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 74, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 72, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev0_5ghz_tx_gain_table[] = {
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 99, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 96, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 93, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 90, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 88, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 85, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 83, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 81, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 78, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 76, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 74, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 55, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 55, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 60, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev1_nopa_tx_gain_table[] = {
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 152, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 147, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 143, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 139, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 135, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 131, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 128, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 124, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 121, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 117, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 114, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 111, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 107, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 104, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 101, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 99, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 96, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 93, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 90, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 88, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 85, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 83, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 81, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 78, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 76, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 74, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 71, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev1_2ghz_tx_gain_table[] = {
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 85, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 81, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 78, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 76, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 74, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 73, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 73, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 58, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 58, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 62, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev1_5ghz_tx_gain_table[] = {
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 99, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 96, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 93, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 90, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 88, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 85, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 83, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 81, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 78, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 76, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 74, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 55, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 55, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 60, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev2_nopa_tx_gain_table[] = {
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 152, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 147, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 143, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 139, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 135, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 131, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 128, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 124, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 121, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 117, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 114, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 111, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 107, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 104, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 101, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 99, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 96, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 93, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 90, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 88, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 85, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 83, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 81, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 78, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 76, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 74, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 72, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 70, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 68, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 66, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 197, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 192, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 186, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 181, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 176, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 171, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 166, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 161, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 157, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 152, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 148, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 144, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 140, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 136, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 132, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 128, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 124, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 121, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 117, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 114, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 111, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 108, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 105, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 102, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 99, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 96, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 93, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 91, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 88, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 86, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 83, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 81, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 79, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 76, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 74, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 72, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 70, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 68, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 66, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 64, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 248, .pad = 64, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 248, .pad = 62, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 241, .pad = 62, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 241, .pad = 60, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 234, .pad = 60, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 234, .pad = 59, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 227, .pad = 59, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 227, .pad = 57, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 221, .pad = 57, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 221, .pad = 55, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 215, .pad = 55, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 215, .pad = 54, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 208, .pad = 54, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 208, .pad = 52, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 203, .pad = 52, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 203, .pad = 51, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 197, .pad = 51, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 197, .pad = 49, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 191, .pad = 49, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 191, .pad = 48, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 186, .pad = 48, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 186, .pad = 47, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 181, .pad = 47, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 181, .pad = 45, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 175, .pad = 45, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 175, .pad = 44, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 170, .pad = 44, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 170, .pad = 43, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 166, .pad = 43, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 166, .pad = 42, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 161, .pad = 42, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 161, .pad = 40, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 156, .pad = 40, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 156, .pad = 39, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 152, .pad = 39, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 152, .pad = 38, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 148, .pad = 38, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 148, .pad = 37, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 143, .pad = 37, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 143, .pad = 36, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 139, .pad = 36, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 139, .pad = 35, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 135, .pad = 35, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 135, .pad = 34, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 132, .pad = 34, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 132, .pad = 33, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 128, .pad = 33, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 128, .pad = 32, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 124, .pad = 32, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 124, .pad = 31, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 121, .pad = 31, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 121, .pad = 30, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 117, .pad = 30, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 117, .pad = 29, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 114, .pad = 29, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 114, .pad = 29, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 111, .pad = 29, .dac = 0, .bb_mult = 64, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev2_2ghz_tx_gain_table[] = {
+	{ .gm = 7, .pga = 99, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 96, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 93, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 90, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 88, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 85, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 83, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 81, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 78, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 76, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 74, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 72, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 70, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 68, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 66, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 62, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 62, .pad = 248, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 60, .pad = 248, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 60, .pad = 241, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 59, .pad = 241, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 59, .pad = 234, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 57, .pad = 234, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 57, .pad = 227, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 55, .pad = 227, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 55, .pad = 221, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 54, .pad = 221, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 54, .pad = 215, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 52, .pad = 215, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 52, .pad = 208, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 51, .pad = 208, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 51, .pad = 203, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 49, .pad = 203, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 49, .pad = 197, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 48, .pad = 197, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 48, .pad = 191, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 47, .pad = 191, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 47, .pad = 186, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 45, .pad = 186, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 45, .pad = 181, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 44, .pad = 181, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 44, .pad = 175, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 43, .pad = 175, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 43, .pad = 170, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 42, .pad = 170, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 42, .pad = 166, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 40, .pad = 166, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 40, .pad = 161, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 39, .pad = 161, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 39, .pad = 156, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 38, .pad = 156, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 38, .pad = 152, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 37, .pad = 152, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 37, .pad = 148, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 36, .pad = 148, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 36, .pad = 143, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 35, .pad = 143, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 35, .pad = 139, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 34, .pad = 139, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 34, .pad = 135, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 33, .pad = 135, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 33, .pad = 132, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 32, .pad = 132, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 32, .pad = 128, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 31, .pad = 128, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 31, .pad = 124, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 30, .pad = 124, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 30, .pad = 121, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 29, .pad = 121, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 29, .pad = 117, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 29, .pad = 117, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 29, .pad = 114, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 28, .pad = 114, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 28, .pad = 111, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 27, .pad = 111, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 27, .pad = 108, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 26, .pad = 108, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 26, .pad = 104, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 25, .pad = 104, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 25, .pad = 102, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 25, .pad = 102, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 25, .pad = 99, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 24, .pad = 99, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 24, .pad = 96, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 23, .pad = 96, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 23, .pad = 93, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 23, .pad = 93, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 23, .pad = 90, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 22, .pad = 90, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 22, .pad = 88, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 21, .pad = 88, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 21, .pad = 85, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 21, .pad = 85, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 21, .pad = 83, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 20, .pad = 83, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 20, .pad = 81, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 20, .pad = 81, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 20, .pad = 78, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 19, .pad = 78, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 19, .pad = 76, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 19, .pad = 76, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 19, .pad = 74, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 18, .pad = 74, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 18, .pad = 72, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 18, .pad = 72, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 18, .pad = 70, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 17, .pad = 70, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 17, .pad = 68, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 17, .pad = 68, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 17, .pad = 66, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 16, .pad = 66, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 16, .pad = 64, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 16, .pad = 64, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 16, .pad = 62, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 62, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 60, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 60, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 59, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 59, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 57, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 57, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 55, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 55, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 54, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 54, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 52, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 52, .dac = 0, .bb_mult = 64, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev2_5ghz_tx_gain_table[] = {
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 152, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 147, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 143, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 139, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 135, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 131, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 128, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 124, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 121, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 117, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 114, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 111, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 107, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 104, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 101, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 99, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 96, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 93, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 90, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 88, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 85, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 83, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 81, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 78, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 76, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 74, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 72, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 70, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 68, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 66, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 248, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 241, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 234, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 227, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 221, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 215, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 208, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 203, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 197, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 191, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 186, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 181, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 175, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 170, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 166, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 161, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 156, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 152, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 148, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 143, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 139, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 135, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 132, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 128, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 124, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 121, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 117, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 114, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 111, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 108, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 104, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 102, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 99, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 96, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 93, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 90, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 88, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 85, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 83, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 81, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 78, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 76, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 74, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 72, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 70, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 68, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 66, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 62, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 62, .pad = 248, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 60, .pad = 248, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 60, .pad = 241, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 59, .pad = 241, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 59, .pad = 234, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 57, .pad = 234, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 57, .pad = 227, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 55, .pad = 227, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 55, .pad = 221, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 54, .pad = 221, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 54, .pad = 215, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 52, .pad = 215, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 52, .pad = 208, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 51, .pad = 208, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 51, .pad = 203, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 49, .pad = 203, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 49, .pad = 197, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 48, .pad = 197, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 48, .pad = 191, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 47, .pad = 191, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 47, .pad = 186, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 45, .pad = 186, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 45, .pad = 181, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 44, .pad = 181, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 44, .pad = 175, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 43, .pad = 175, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 43, .pad = 170, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 42, .pad = 170, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 42, .pad = 166, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 40, .pad = 166, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 40, .pad = 161, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 39, .pad = 161, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 39, .pad = 156, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 38, .pad = 156, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 38, .pad = 152, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 37, .pad = 152, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 37, .pad = 148, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 36, .pad = 148, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 36, .pad = 143, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 35, .pad = 143, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 35, .pad = 139, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 34, .pad = 139, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 34, .pad = 135, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 33, .pad = 135, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 33, .pad = 132, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 32, .pad = 132, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 32, .pad = 128, .dac = 0, .bb_mult = 64, },
+};
+
+void lpphy_rev0_1_table_init(struct b43_wldev *dev)
+{
+	B43_WARN_ON(dev->phy.rev >= 2);
+
+	b43_lptab_write_bulk(dev, B43_LPTAB8(2, 0),
+		ARRAY_SIZE(lpphy_min_sig_sq_table), lpphy_min_sig_sq_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(1, 0),
+		ARRAY_SIZE(lpphy_rev01_noise_scale_table), lpphy_rev01_noise_scale_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(14, 0),
+		ARRAY_SIZE(lpphy_crs_gain_nft_table), lpphy_crs_gain_nft_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(8, 0),
+		ARRAY_SIZE(lpphy_rev01_filter_control_table), lpphy_rev01_filter_control_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(9, 0),
+		ARRAY_SIZE(lpphy_rev01_ps_control_table), lpphy_rev01_ps_control_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB8(6, 0),
+		ARRAY_SIZE(lpphy_pll_fraction_table), lpphy_pll_fraction_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(0, 0),
+		ARRAY_SIZE(lpphy_iq_local_table), lpphy_iq_local_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0),
+		ARRAY_SIZE(lpphy_ofdm_cck_gain_table), lpphy_ofdm_cck_gain_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0),
+		ARRAY_SIZE(lpphy_ofdm_cck_gain_table), lpphy_ofdm_cck_gain_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(15, 0),
+		ARRAY_SIZE(lpphy_gain_delta_table), lpphy_gain_delta_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0),
+		ARRAY_SIZE(lpphy_tx_power_control_table), lpphy_tx_power_control_table);
+}
+
+void lpphy_rev2plus_table_init(struct b43_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+	int i;
+
+	B43_WARN_ON(dev->phy.rev < 2);
+
+	//XXX should this be done using b43_lptab_write_bulk?
+	for (i = 0; i < 704; i++)
+		b43_lptab_write(dev, B43_LPTAB32(7, i), 0);
+
+	b43_lptab_write_bulk(dev, B43_LPTAB8(2, 0),
+		ARRAY_SIZE(lpphy_min_sig_sq_table), lpphy_min_sig_sq_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(1, 0),
+		ARRAY_SIZE(lpphy_rev2plus_noise_scale_table), lpphy_rev2plus_noise_scale_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(11, 0),
+		ARRAY_SIZE(lpphy_rev2plus_filter_control_table), lpphy_rev2plus_filter_control_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(12, 0),
+		ARRAY_SIZE(lpphy_rev2plus_ps_control_table), lpphy_rev2plus_ps_control_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(13, 0),
+		ARRAY_SIZE(lpphy_gain_idx_table), lpphy_gain_idx_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(14, 0),
+		ARRAY_SIZE(lpphy_aux_gain_idx_table), lpphy_aux_gain_idx_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(15, 0),
+		ARRAY_SIZE(lpphy_sw_control_table), lpphy_sw_control_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB8(16, 0),
+		ARRAY_SIZE(lpphy_hf_table), lpphy_hf_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(17, 0),
+		ARRAY_SIZE(lpphy_gain_value_table), lpphy_gain_value_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(18, 0),
+		ARRAY_SIZE(lpphy_gain_table), lpphy_gain_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB8(6, 0),
+		ARRAY_SIZE(lpphy_pll_fraction_table), lpphy_pll_fraction_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(0, 0),
+		ARRAY_SIZE(lpphy_iq_local_table), lpphy_iq_local_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(9, 0),
+		ARRAY_SIZE(lpphy_papd_eps_table), lpphy_papd_eps_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0),
+		ARRAY_SIZE(lpphy_papd_mult_table), lpphy_papd_mult_table);
+
+	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 0)) {
+		b43_lptab_write_bulk(dev, B43_LPTAB32(13, 0),
+			ARRAY_SIZE(lpphy_a0_gain_idx_table), lpphy_a0_gain_idx_table);
+		b43_lptab_write_bulk(dev, B43_LPTAB16(14, 0),
+			ARRAY_SIZE(lpphy_a0_aux_gain_idx_table), lpphy_a0_aux_gain_idx_table);
+		b43_lptab_write_bulk(dev, B43_LPTAB32(17, 0),
+			ARRAY_SIZE(lpphy_a0_gain_value_table), lpphy_a0_gain_value_table);
+		b43_lptab_write_bulk(dev, B43_LPTAB16(18, 0),
+			ARRAY_SIZE(lpphy_a0_gain_table), lpphy_a0_gain_table);
+	}
+}
+
+
+static void lpphy_rev0_1_write_gain_table(struct b43_wldev *dev,
+				struct lpphy_tx_gain_table_entry *table)
+{
+	int i;
+	u32 tmp;
+
+	B43_WARN_ON(dev->phy.rev >= 2);
+
+	for (i = 0; i < 128; i++) {
+		tmp  = table[i].pad << 11;
+		tmp |= table[i].pga << 7;
+		tmp |= table[i].gm  << 4;
+		tmp |= table[i].dac;
+		b43_lptab_write(dev, B43_LPTAB32(10, 0xC0 + i), tmp);
+		tmp  = table[i].bb_mult << 20;
+		b43_lptab_write(dev, B43_LPTAB32(10, 0x140 + i), tmp);
+	}
+}
+
+static void lpphy_rev2plus_write_gain_table(struct b43_wldev *dev,
+				struct lpphy_tx_gain_table_entry *table)
+{
+	int i;
+	u32 tmp;
+
+	B43_WARN_ON(dev->phy.rev < 2);
+
+	for (i = 0; i < 128; i++) {
+		tmp  = table[i].pad << 16;
+		tmp |= table[i].pga << 8;
+		tmp |= table[i].gm;
+		tmp |= 0x7f000000;
+		b43_lptab_write(dev, B43_LPTAB32(7, 0xC0 + i), tmp);
+		tmp  = table[i].bb_mult << 20;
+		tmp |= table[i].dac << 28;
+		b43_lptab_write(dev, B43_LPTAB32(7, 0x140 + i), tmp);
+	}
+}
+
+void lpphy_init_tx_gain_table(struct b43_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+
+	switch (dev->phy.rev) {
+	case 0:
+		if ((bus->sprom.boardflags_hi & B43_BFH_NOPA) ||
+		    (bus->sprom.boardflags_lo & B43_BFL_HGPA))
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev0_nopa_tx_gain_table);
+		else if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev0_2ghz_tx_gain_table);
+		else
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev0_5ghz_tx_gain_table);
+		break;
+	case 1:
+		if ((bus->sprom.boardflags_hi & B43_BFH_NOPA) ||
+		    (bus->sprom.boardflags_lo & B43_BFL_HGPA))
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev1_nopa_tx_gain_table);
+		else if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev1_2ghz_tx_gain_table);
+		else
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev1_5ghz_tx_gain_table);
+		break;
+	default:
+		if (bus->sprom.boardflags_hi & B43_BFH_NOPA)
+			lpphy_rev2plus_write_gain_table(dev,
+					lpphy_rev2_nopa_tx_gain_table);
+		else if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+			lpphy_rev2plus_write_gain_table(dev,
+					lpphy_rev2_2ghz_tx_gain_table);
+		else
+			lpphy_rev2plus_write_gain_table(dev,
+					lpphy_rev2_5ghz_tx_gain_table);
+	}
+}
diff --git a/drivers/net/wireless/b43/tables_lpphy.h b/drivers/net/wireless/b43/tables_lpphy.h
index 52ce32f..b5024b6 100644
--- a/drivers/net/wireless/b43/tables_lpphy.h
+++ b/drivers/net/wireless/b43/tables_lpphy.h
@@ -28,5 +28,8 @@ void b43_lptab_write_bulk(struct b43_wldev *dev, u32 offset,
 void b2062_upload_init_table(struct b43_wldev *dev);
 void b2063_upload_init_table(struct b43_wldev *dev);
 
+void lpphy_rev0_1_table_init(struct b43_wldev *dev);
+void lpphy_rev2plus_table_init(struct b43_wldev *dev);
+void lpphy_init_tx_gain_table(struct b43_wldev *dev);
 
 #endif /* B43_TABLES_LPPHY_H_ */




From Larry.Finger at lwfinger.net  Mon Aug 10 04:08:31 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 09 Aug 2009 21:08:31 -0500
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <4A7F713E.8040405@gmail.com>
References: <4A7F713E.8040405@gmail.com>
Message-ID: <4A7F811F.4070908@lwfinger.net>

G?bor Stefanik wrote:
> Implement LP-PHY baseband table init for all revisions.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> 
> ---
> Sorry for the size; it's difficult to cut short changes like this
> (most of the patch is just table data). Please review, there may always be
> bugs that I failed to catch while reading through the code. I have added
> comments to places that were not quite clear to me.
> 
> phy_lp.c       |   41 tables_lpphy.c | 3223
> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
> tables_lpphy.h |    3 3 files changed, 3263 insertions(+), 4 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index 27eadee..cf17489 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -59,9 +59,43 @@ static void b43_lpphy_op_free(struct b43_wldev *dev)
>     dev->phy.lp = NULL;
> }
> 
> +static void lpphy_adjust_gain_table(struct b43_wldev *dev)
> +{
> +    struct b43_phy_lp *lpphy = dev->phy.lp;
> +    u32 freq = dev->wl->hw->conf.channel->center_freq;
> +    u16 temp[3];
> +    u16 isolation;
> +
> +    B43_WARN_ON(dev->phy.rev >= 2);
> +
> +    if (freq < 2400) /* FIXME Can this ever happen? Should we WARN_ON? */

This was a typo. It should be 2500, not 2400.

> +        isolation = lpphy->tx_isolation_med_band;
> +    else if (freq <= 5320)

--snip --

> +void lpphy_rev2plus_table_init(struct b43_wldev *dev)
> +{
> +    struct ssb_bus *bus = dev->dev->bus;
> +    int i;
> +
> +    B43_WARN_ON(dev->phy.rev < 2);
> +
> +    //XXX should this be done using b43_lptab_write_bulk?
> +    for (i = 0; i < 704; i++)
> +        b43_lptab_write(dev, B43_LPTAB32(7, i), 0);

No. The bulk write is for writing tables with length greater than 1.
In this case, you have 704 different tables each of length 1.

I am still looking through the patch. I'll let you know of any thing I
find.

Larry



From netrolller.3d at gmail.com  Mon Aug 10 13:37:34 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 10 Aug 2009 13:37:34 +0200
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <4A7F811F.4070908@lwfinger.net>
References: <4A7F713E.8040405@gmail.com> <4A7F811F.4070908@lwfinger.net>
Message-ID: <69e28c910908100437n46a04f76tf91876d48ab19cb4@mail.gmail.com>

2009/8/10 Larry Finger <Larry.Finger at lwfinger.net>:
> G?bor Stefanik wrote:
>> Implement LP-PHY baseband table init for all revisions.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>>
>> ---
>> Sorry for the size; it's difficult to cut short changes like this
>> (most of the patch is just table data). Please review, there may always be
>> bugs that I failed to catch while reading through the code. I have added
>> comments to places that were not quite clear to me.
>>
>> phy_lp.c ? ? ? | ? 41 tables_lpphy.c | 3223
>> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
>> tables_lpphy.h | ? ?3 3 files changed, 3263 insertions(+), 4 deletions(-)
>>
>> diff --git a/drivers/net/wireless/b43/phy_lp.c
>> b/drivers/net/wireless/b43/phy_lp.c
>> index 27eadee..cf17489 100644
>> --- a/drivers/net/wireless/b43/phy_lp.c
>> +++ b/drivers/net/wireless/b43/phy_lp.c
>> @@ -59,9 +59,43 @@ static void b43_lpphy_op_free(struct b43_wldev *dev)
>> ? ? dev->phy.lp = NULL;
>> }
>>
>> +static void lpphy_adjust_gain_table(struct b43_wldev *dev)
>> +{
>> + ? ?struct b43_phy_lp *lpphy = dev->phy.lp;
>> + ? ?u32 freq = dev->wl->hw->conf.channel->center_freq;
>> + ? ?u16 temp[3];
>> + ? ?u16 isolation;
>> +
>> + ? ?B43_WARN_ON(dev->phy.rev >= 2);
>> +
>> + ? ?if (freq < 2400) /* FIXME Can this ever happen? Should we WARN_ON? */
>
> This was a typo. It should be 2500, not 2400.

Thanks! So it is actually better to implement this as "if
(b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)"? That would make
it easier to implement non-standard channels similar to how it was
done for ath5k (Richard Farina's frequency patch - assuming the HW is
capable of something like that).

>
>> + ? ? ? ?isolation = lpphy->tx_isolation_med_band;
>> + ? ?else if (freq <= 5320)
>
> --snip --
>
>> +void lpphy_rev2plus_table_init(struct b43_wldev *dev)
>> +{
>> + ? ?struct ssb_bus *bus = dev->dev->bus;
>> + ? ?int i;
>> +
>> + ? ?B43_WARN_ON(dev->phy.rev < 2);
>> +
>> + ? ?//XXX should this be done using b43_lptab_write_bulk?
>> + ? ?for (i = 0; i < 704; i++)
>> + ? ? ? ?b43_lptab_write(dev, B43_LPTAB32(7, i), 0);
>
> No. The bulk write is for writing tables with length greater than 1.
> In this case, you have 704 different tables each of length 1.

By the way, looking at the implementation again, it looks a bit fishy
to me - we write zeros to 4 bytes of table ID 7, then increase the
offset by 1 byte, and again write 4 bytes - 3 of which are the same
bytes we already zeroed in the previous step.

I suspect this would suffice:

for (i = 0; i < 704; i += 4)
           b43_lptab_write(dev, B43_LPTAB32(7, i), 0);

This version cuts the write count in half, and removes redundant byte writes.

Maybe this should be tested once the code is functional.

>
> I am still looking through the patch. I'll let you know of any thing I
> find.
>
> Larry
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Mon Aug 10 14:41:43 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 10 Aug 2009 14:41:43 +0200
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <4A7F713E.8040405@gmail.com>
References: <4A7F713E.8040405@gmail.com>
Message-ID: <200908101441.43480.mb@bu3sch.de>

On Monday 10 August 2009 03:00:46 G?bor Stefanik wrote:
> +static const u16 lpphy_sw_control_table[] = {
> +	0x0128,
> +	0x0128,
> +	0x0009,
> +	0x0009,
> +	0x0028,
> +	0x0028,

Is it possible to use more than one value per line for all these tables?
Make sure to make best use of the 80 columns limit.
This would significantly decrease the patch/file length. (linewise)

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Mon Aug 10 14:49:31 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 10 Aug 2009 14:49:31 +0200
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <200908101441.43480.mb@bu3sch.de>
References: <4A7F713E.8040405@gmail.com> <200908101441.43480.mb@bu3sch.de>
Message-ID: <69e28c910908100549w6af5bd12j568c7f0c2aa31e30@mail.gmail.com>

2009/8/10 Michael Buesch <mb at bu3sch.de>:
> On Monday 10 August 2009 03:00:46 G?bor Stefanik wrote:
>> +static const u16 lpphy_sw_control_table[] = {
>> + ? ? 0x0128,
>> + ? ? 0x0128,
>> + ? ? 0x0009,
>> + ? ? 0x0009,
>> + ? ? 0x0028,
>> + ? ? 0x0028,
>
> Is it possible to use more than one value per line for all these tables?
> Make sure to make best use of the 80 columns limit.
> This would significantly decrease the patch/file length. (linewise)
>
> --
> Greetings, Michael.
>

Well, I converted the tables directly from the Wikitext on
bcm-v4.sipsolutions.net using regex search&replace - if you know a
good regex to convert the tables to use multiple values on each line,
please post it.

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Mon Aug 10 14:52:49 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 10 Aug 2009 14:52:49 +0200
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <69e28c910908100549w6af5bd12j568c7f0c2aa31e30@mail.gmail.com>
References: <4A7F713E.8040405@gmail.com> <200908101441.43480.mb@bu3sch.de>
	<69e28c910908100549w6af5bd12j568c7f0c2aa31e30@mail.gmail.com>
Message-ID: <200908101452.50072.mb@bu3sch.de>

On Monday 10 August 2009 14:49:31 G?bor Stefanik wrote:
> 2009/8/10 Michael Buesch <mb at bu3sch.de>:
> > On Monday 10 August 2009 03:00:46 G?bor Stefanik wrote:
> >> +static const u16 lpphy_sw_control_table[] = {
> >> + ? ? 0x0128,
> >> + ? ? 0x0128,
> >> + ? ? 0x0009,
> >> + ? ? 0x0009,
> >> + ? ? 0x0028,
> >> + ? ? 0x0028,
> >
> > Is it possible to use more than one value per line for all these tables?
> > Make sure to make best use of the 80 columns limit.
> > This would significantly decrease the patch/file length. (linewise)
> >
> > --
> > Greetings, Michael.
> >
> 
> Well, I converted the tables directly from the Wikitext on
> bcm-v4.sipsolutions.net using regex search&replace - if you know a
> good regex to convert the tables to use multiple values on each line,
> please post it.
> 

I have some hacky python scripts to parse and reformat these tables.
I will post them in a few hours. I'll have to leave now. brb.

-- 
Greetings, Michael.


From hs4233 at mail.mn-solutions.de  Mon Aug 10 15:36:47 2009
From: hs4233 at mail.mn-solutions.de (Holger Schurig)
Date: Mon, 10 Aug 2009 15:36:47 +0200
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <69e28c910908100549w6af5bd12j568c7f0c2aa31e30@mail.gmail.com>
References: <4A7F713E.8040405@gmail.com> <200908101441.43480.mb@bu3sch.de>
	<69e28c910908100549w6af5bd12j568c7f0c2aa31e30@mail.gmail.com>
Message-ID: <200908101536.47591.hs4233@mail.mn-solutions.de>

> Well, I converted the tables directly from the Wikitext on
> bcm-v4.sipsolutions.net using regex search&replace - if you
> know a good regex to convert the tables to use multiple values
> on each line, please post it.


An emacs macro ?

Or use any other editor with an macro capability.

-- 
http://www.holgerschurig.de


From Larry.Finger at lwfinger.net  Mon Aug 10 16:55:16 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 10 Aug 2009 09:55:16 -0500
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <69e28c910908100437n46a04f76tf91876d48ab19cb4@mail.gmail.com>
References: <4A7F713E.8040405@gmail.com> <4A7F811F.4070908@lwfinger.net>
	<69e28c910908100437n46a04f76tf91876d48ab19cb4@mail.gmail.com>
Message-ID: <4A8034D4.5030909@lwfinger.net>

G?bor Stefanik wrote:
> 2009/8/10 Larry Finger <Larry.Finger at lwfinger.net>:
>> G?bor Stefanik wrote:
>>> Implement LP-PHY baseband table init for all revisions.
>>>
>>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>>>
>>> ---
>>> Sorry for the size; it's difficult to cut short changes like this
>>> (most of the patch is just table data). Please review, there may always be
>>> bugs that I failed to catch while reading through the code. I have added
>>> comments to places that were not quite clear to me.
>>>
>>> phy_lp.c       |   41 tables_lpphy.c | 3223
>>> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
>>> tables_lpphy.h |    3 3 files changed, 3263 insertions(+), 4 deletions(-)
>>>
>>> diff --git a/drivers/net/wireless/b43/phy_lp.c
>>> b/drivers/net/wireless/b43/phy_lp.c
>>> index 27eadee..cf17489 100644
>>> --- a/drivers/net/wireless/b43/phy_lp.c
>>> +++ b/drivers/net/wireless/b43/phy_lp.c
>>> @@ -59,9 +59,43 @@ static void b43_lpphy_op_free(struct b43_wldev *dev)
>>>     dev->phy.lp = NULL;
>>> }
>>>
>>> +static void lpphy_adjust_gain_table(struct b43_wldev *dev)
>>> +{
>>> +    struct b43_phy_lp *lpphy = dev->phy.lp;
>>> +    u32 freq = dev->wl->hw->conf.channel->center_freq;
>>> +    u16 temp[3];
>>> +    u16 isolation;
>>> +
>>> +    B43_WARN_ON(dev->phy.rev >= 2);
>>> +
>>> +    if (freq < 2400) /* FIXME Can this ever happen? Should we WARN_ON? */
>> This was a typo. It should be 2500, not 2400.
> 
> Thanks! So it is actually better to implement this as "if
> (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)"? That would make
> it easier to implement non-standard channels similar to how it was
> done for ath5k (Richard Farina's frequency patch - assuming the HW is
> capable of something like that).

Yes, that would work for the 2.4 GHz band, and I guess there could be
similar routines or macros to split the 5 GHz band into low, medium
and high channels.

>>> +        isolation = lpphy->tx_isolation_med_band;
>>> +    else if (freq <= 5320)
>> --snip --
>>
>>> +void lpphy_rev2plus_table_init(struct b43_wldev *dev)
>>> +{
>>> +    struct ssb_bus *bus = dev->dev->bus;
>>> +    int i;
>>> +
>>> +    B43_WARN_ON(dev->phy.rev < 2);
>>> +
>>> +    //XXX should this be done using b43_lptab_write_bulk?
>>> +    for (i = 0; i < 704; i++)
>>> +        b43_lptab_write(dev, B43_LPTAB32(7, i), 0);
>> No. The bulk write is for writing tables with length greater than 1.
>> In this case, you have 704 different tables each of length 1.
> 
> By the way, looking at the implementation again, it looks a bit fishy
> to me - we write zeros to 4 bytes of table ID 7, then increase the
> offset by 1 byte, and again write 4 bytes - 3 of which are the same
> bytes we already zeroed in the previous step.
> 
> I suspect this would suffice:
> 
> for (i = 0; i < 704; i += 4)
>            b43_lptab_write(dev, B43_LPTAB32(7, i), 0);
> 
> This version cuts the write count in half, and removes redundant byte writes.
> 
> Maybe this should be tested once the code is functional.

Without knowing what the firmware does with these values, I'm not sure
that the two steps are equivalent, but that can be tested. I'm sure of
the specs in this instance.

Larry


From netrolller.3d at gmail.com  Mon Aug 10 17:42:04 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 10 Aug 2009 17:42:04 +0200
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <4A8034D4.5030909@lwfinger.net>
References: <4A7F713E.8040405@gmail.com> <4A7F811F.4070908@lwfinger.net> 
	<69e28c910908100437n46a04f76tf91876d48ab19cb4@mail.gmail.com> 
	<4A8034D4.5030909@lwfinger.net>
Message-ID: <69e28c910908100842o6eecb131n50ff39fc48566880@mail.gmail.com>

2009/8/10 Larry Finger <Larry.Finger at lwfinger.net>:
> G?bor Stefanik wrote:
>> 2009/8/10 Larry Finger <Larry.Finger at lwfinger.net>:
>>> G?bor Stefanik wrote:
>>>> Implement LP-PHY baseband table init for all revisions.
>>>>
>>>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>>>>
>>>> ---
>>>> Sorry for the size; it's difficult to cut short changes like this
>>>> (most of the patch is just table data). Please review, there may always be
>>>> bugs that I failed to catch while reading through the code. I have added
>>>> comments to places that were not quite clear to me.
>>>>
>>>> phy_lp.c ? ? ? | ? 41 tables_lpphy.c | 3223
>>>> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
>>>> tables_lpphy.h | ? ?3 3 files changed, 3263 insertions(+), 4 deletions(-)
>>>>
>>>> diff --git a/drivers/net/wireless/b43/phy_lp.c
>>>> b/drivers/net/wireless/b43/phy_lp.c
>>>> index 27eadee..cf17489 100644
>>>> --- a/drivers/net/wireless/b43/phy_lp.c
>>>> +++ b/drivers/net/wireless/b43/phy_lp.c
>>>> @@ -59,9 +59,43 @@ static void b43_lpphy_op_free(struct b43_wldev *dev)
>>>> ? ? dev->phy.lp = NULL;
>>>> }
>>>>
>>>> +static void lpphy_adjust_gain_table(struct b43_wldev *dev)
>>>> +{
>>>> + ? ?struct b43_phy_lp *lpphy = dev->phy.lp;
>>>> + ? ?u32 freq = dev->wl->hw->conf.channel->center_freq;
>>>> + ? ?u16 temp[3];
>>>> + ? ?u16 isolation;
>>>> +
>>>> + ? ?B43_WARN_ON(dev->phy.rev >= 2);
>>>> +
>>>> + ? ?if (freq < 2400) /* FIXME Can this ever happen? Should we WARN_ON? */
>>> This was a typo. It should be 2500, not 2400.
>>
>> Thanks! So it is actually better to implement this as "if
>> (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)"? That would make
>> it easier to implement non-standard channels similar to how it was
>> done for ath5k (Richard Farina's frequency patch - assuming the HW is
>> capable of something like that).
>
> Yes, that would work for the 2.4 GHz band, and I guess there could be
> similar routines or macros to split the 5 GHz band into low, medium
> and high channels.

AFAIK there is no need to do that - using current_band for 2GHz is
specifically to ensure that channels in the 2500...3000MHz range don't
get parsed as 5GHz. There is currently no band above 5GHz used for
wlan, so this problem can't show up on 5GHz.

>
>>>> + ? ? ? ?isolation = lpphy->tx_isolation_med_band;
>>>> + ? ?else if (freq <= 5320)
>>> --snip --
>>>
>>>> +void lpphy_rev2plus_table_init(struct b43_wldev *dev)
>>>> +{
>>>> + ? ?struct ssb_bus *bus = dev->dev->bus;
>>>> + ? ?int i;
>>>> +
>>>> + ? ?B43_WARN_ON(dev->phy.rev < 2);
>>>> +
>>>> + ? ?//XXX should this be done using b43_lptab_write_bulk?
>>>> + ? ?for (i = 0; i < 704; i++)
>>>> + ? ? ? ?b43_lptab_write(dev, B43_LPTAB32(7, i), 0);
>>> No. The bulk write is for writing tables with length greater than 1.
>>> In this case, you have 704 different tables each of length 1.
>>
>> By the way, looking at the implementation again, it looks a bit fishy
>> to me - we write zeros to 4 bytes of table ID 7, then increase the
>> offset by 1 byte, and again write 4 bytes - 3 of which are the same
>> bytes we already zeroed in the previous step.
>>
>> I suspect this would suffice:
>>
>> for (i = 0; i < 704; i += 4)
>> ? ? ? ? ? ?b43_lptab_write(dev, B43_LPTAB32(7, i), 0);
>>
>> This version cuts the write count in half, and removes redundant byte writes.
>>
>> Maybe this should be tested once the code is functional.
>
> Without knowing what the firmware does with these values, I'm not sure
> that the two steps are equivalent, but that can be tested. I'm sure of
> the specs in this instance.
>
> Larry
>

Thanks, I have added a big comment to this code so that this won't be forgotten.

I'm gonna re-submit this as a formal patch soon.

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From Larry.Finger at lwfinger.net  Mon Aug 10 18:02:49 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 10 Aug 2009 11:02:49 -0500
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <69e28c910908100842o6eecb131n50ff39fc48566880@mail.gmail.com>
References: <4A7F713E.8040405@gmail.com> <4A7F811F.4070908@lwfinger.net>
	<69e28c910908100437n46a04f76tf91876d48ab19cb4@mail.gmail.com>
	<4A8034D4.5030909@lwfinger.net>
	<69e28c910908100842o6eecb131n50ff39fc48566880@mail.gmail.com>
Message-ID: <4A8044A9.8090600@lwfinger.net>

G?bor Stefanik wrote:
> 2009/8/10 Larry Finger <Larry.Finger at lwfinger.net>:
>> Yes, that would work for the 2.4 GHz band, and I guess there could be
>> similar routines or macros to split the 5 GHz band into low, medium
>> and high channels.
> 
> AFAIK there is no need to do that - using current_band for 2GHz is
> specifically to ensure that channels in the 2500...3000MHz range don't
> get parsed as 5GHz. There is currently no band above 5GHz used for
> wlan, so this problem can't show up on 5GHz.

OK.

> I'm gonna re-submit this as a formal patch soon.

Good.

I just noticed that
http://bcm-v4.sipsolutions.net/802.11/PHY/LP/Calibration is
incomplete. I'll work on that next.

Larry



From peter at stuge.se  Mon Aug 10 18:12:20 2009
From: peter at stuge.se (Peter Stuge)
Date: Mon, 10 Aug 2009 18:12:20 +0200
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <69e28c910908100549w6af5bd12j568c7f0c2aa31e30@mail.gmail.com>
References: <4A7F713E.8040405@gmail.com> <200908101441.43480.mb@bu3sch.de>
	<69e28c910908100549w6af5bd12j568c7f0c2aa31e30@mail.gmail.com>
Message-ID: <20090810161220.28860.qmail@stuge.se>

G?bor Stefanik wrote:
> >> + ? ? 0x0128,
> >> + ? ? 0x0128,
> >> + ? ? 0x0009,
> >> + ? ? 0x0009,
> >> + ? ? 0x0028,
> >> + ? ? 0x0028,
> >
> > Is it possible to use more than one value per line for all these
> > tables?
> 
> if you know a good regex to convert the tables to use multiple
> values on each line, please post it.

Try this:

tr -d ' \n'|sed 's-\(\([^,]*,\)\{9\}\)-\1\n-g'|sed 's,^,     ,'

9 is the number of values you want on each line.


//Peter


From mb at bu3sch.de  Mon Aug 10 19:19:24 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 10 Aug 2009 19:19:24 +0200
Subject: [RFC PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <200908101452.50072.mb@bu3sch.de>
References: <4A7F713E.8040405@gmail.com>
	<69e28c910908100549w6af5bd12j568c7f0c2aa31e30@mail.gmail.com>
	<200908101452.50072.mb@bu3sch.de>
Message-ID: <200908101919.25306.mb@bu3sch.de>

On Monday 10 August 2009 14:52:49 Michael Buesch wrote:
> On Monday 10 August 2009 14:49:31 G?bor Stefanik wrote:
> > 2009/8/10 Michael Buesch <mb at bu3sch.de>:
> > > On Monday 10 August 2009 03:00:46 G?bor Stefanik wrote:
> > >> +static const u16 lpphy_sw_control_table[] = {
> > >> + ? ? 0x0128,
> > >> + ? ? 0x0128,
> > >> + ? ? 0x0009,
> > >> + ? ? 0x0009,
> > >> + ? ? 0x0028,
> > >> + ? ? 0x0028,
> > >
> > > Is it possible to use more than one value per line for all these tables?
> > > Make sure to make best use of the 80 columns limit.
> > > This would significantly decrease the patch/file length. (linewise)
> > >
> > > --
> > > Greetings, Michael.
> > >
> > 
> > Well, I converted the tables directly from the Wikitext on
> > bcm-v4.sipsolutions.net using regex search&replace - if you know a
> > good regex to convert the tables to use multiple values on each line,
> > please post it.
> > 
> 
> I have some hacky python scripts to parse and reformat these tables.
> I will post them in a few hours. I'll have to leave now. brb.
> 

Hm, I don't seem to have the scripts anymore. But python re is fairly simple.
Here's a hacky script to parse a table, perform some transformations on it and
print out the C defines:

#!/usr/bin/env python

import re
import sys

d = file(sys.argv[1]).readlines()


for line in d:
	r = re.compile(r"\|\| `0x([0-9A-Fa-f]+)` \|\| ([\w\s\(\)/]+) \|\|")
	m = r.match(line)
	if m:
		offset = int(m.group(1), 16)
		name = m.group(2)
		name = name.replace("workAround", "workaround")

		origname = name

		name = name.replace("(", " ")
		name = name.replace(")", " ")

		name = name.upper()
		name = name.strip()

		name = name.replace(" ", "_")
		name = name.replace("/", "_")
		name = name.replace("CONTROL", "CTL")
		name = name.replace("COMMON", "COMM")
		name = name.replace("CALIBRATION", "CALIB")
		name = name.replace("DEBUG", "DBG")
		name = name.replace("COUNTER", "CNT")
		name = name.replace("POWER", "PWR")
		name = name.replace("B_PHY", "B")
		name = name.replace("ADDRESS", "ADDR")
		name = name.replace("OUT_ENABLE", "OUTEN")
		name = name.replace("THRESHOLD", "THRES")
		name = name.replace("STATUS", "STAT")
		name = name.replace("COEFFICIENT", "COEFF")
		name = name.replace("INTERVAL", "INT")
		name = name.replace("TIMEOUT", "TO")
		name = name.replace("VALUE", "VAL")
		name = name.replace("SAMPLE", "SMPL")

		name = "B43_LPPHY_" + name

		nr_tabs = 5 - (len(name) / 8)
		tabs = "\t" * nr_tabs

		comment = origname

		if (offset & 0x400):
			accessor = "B43_PHY_OFDM"
		else:
			accessor = "B43_PHY_CCK"
		offset &= ~0x400;
		if (offset & ~0xFF):
			print "offset ERROR %X" % offset
			sys.exit(1)
		sys.stdout.write("#define %s%s%s(0x%02X)" % (name, tabs, accessor, offset))
		if comment:
			sys.stdout.write(" /* %s */" % comment)
		sys.stdout.write("\n")
	else:
		pass
		print "NO match " + line

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Mon Aug 10 20:39:47 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Mon, 10 Aug 2009 20:39:47 +0200
Subject: [PATCH] b43: Implement LP-PHY baseband table initialization
Message-ID: <4A806973.1020109@gmail.com>

Implement LP-PHY baseband table init for all revisions.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Changes from RFC:
-Improved table formatting in the code.
-The 2GHz check in adjust_gain_table now uses b43_current_band.
-Added a comment to rev2plus_table_init about a possible future improvement.

 drivers/net/wireless/b43/phy_lp.c       |   41 +-
 drivers/net/wireless/b43/tables_lpphy.c | 1716 +++++++++++++++++++++++++++++++
 drivers/net/wireless/b43/tables_lpphy.h |    3 +
 3 files changed, 1756 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 27eadee..d2af924 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -59,9 +59,43 @@ static void b43_lpphy_op_free(struct b43_wldev *dev)
 	dev->phy.lp = NULL;
 }
 
+static void lpphy_adjust_gain_table(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	u32 freq = dev->wl->hw->conf.channel->center_freq;
+	u16 temp[3];
+	u16 isolation;
+
+	B43_WARN_ON(dev->phy.rev >= 2);
+
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+		isolation = lpphy->tx_isolation_med_band;
+	else if (freq <= 5320)
+		isolation = lpphy->tx_isolation_low_band;
+	else if (freq <= 5700)
+		isolation = lpphy->tx_isolation_med_band;
+	else
+		isolation = lpphy->tx_isolation_hi_band;
+
+	temp[0] = ((isolation - 26) / 12) << 12;
+	temp[1] = temp[0] + 0x1000;
+	temp[2] = temp[0] + 0x2000;
+
+	b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0), 3, temp);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0), 3, temp);
+}
+
 static void lpphy_table_init(struct b43_wldev *dev)
 {
-	//TODO
+	if (dev->phy.rev < 2)
+		lpphy_rev0_1_table_init(dev);
+	else
+		lpphy_rev2plus_table_init(dev);
+
+	lpphy_init_tx_gain_table(dev);
+
+	if (dev->phy.rev < 2)
+		lpphy_adjust_gain_table(dev);
 }
 
 static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
@@ -596,13 +630,13 @@ static void lpphy_tx_pctl_init(struct b43_wldev *dev)
 static int b43_lpphy_op_init(struct b43_wldev *dev)
 {
 	/* TODO: band SPROM */
-	/* TODO: tables init */
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
 	//TODO calibrate RC
 	//TODO set channel
 	lpphy_tx_pctl_init(dev);
-	//TODO full calib
+	lpphy_calibration(dev);
+	//TODO ACI init
 
 	return 0;
 }
@@ -680,7 +714,6 @@ static enum b43_txpwr_result b43_lpphy_op_recalc_txpower(struct b43_wldev *dev,
 	return B43_TXPWR_RES_DONE;
 }
 
-
 const struct b43_phy_operations b43_phyops_lp = {
 	.allocate		= b43_lpphy_op_allocate,
 	.free			= b43_lpphy_op_free,
diff --git a/drivers/net/wireless/b43/tables_lpphy.c b/drivers/net/wireless/b43/tables_lpphy.c
index cadfe81..141e96d 100644
--- a/drivers/net/wireless/b43/tables_lpphy.c
+++ b/drivers/net/wireless/b43/tables_lpphy.c
@@ -710,3 +710,1719 @@ void b43_lptab_write_bulk(struct b43_wldev *dev, u32 offset,
 		offset++;
 	}
 }
+
+static const u8 lpphy_min_sig_sq_table[] = {
+	0xde, 0xdc, 0xda, 0xd8, 0xd6, 0xd4, 0xd2, 0xcf, 0xcd,
+	0xca, 0xc7, 0xc4, 0xc1, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe,
+	0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0x00,
+	0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe,
+	0xbe, 0xbe, 0xbe, 0xbe, 0xc1, 0xc4, 0xc7, 0xca, 0xcd,
+	0xcf, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
+};
+
+static const u16 lpphy_rev01_noise_scale_table[] = {
+	0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4,
+	0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa400, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4,
+	0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0x00a4,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4c00, 0x2d36,
+	0x0000, 0x0000, 0x4c00, 0x2d36,
+};
+
+static const u16 lpphy_rev2plus_noise_scale_table[] = {
+	0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4,
+	0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4,
+	0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x0000,
+	0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4,
+	0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4,
+	0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4, 0x00a4,
+	0x00a4,
+};
+
+static const u16 lpphy_crs_gain_nft_table[] = {
+	0x0366, 0x036a, 0x036f, 0x0364, 0x0367, 0x036d, 0x0374, 0x037f, 0x036f,
+	0x037b, 0x038a, 0x0378, 0x0367, 0x036d, 0x0375, 0x0381, 0x0374, 0x0381,
+	0x0392, 0x03a9, 0x03c4, 0x03e1, 0x0001, 0x001f, 0x0040, 0x005e, 0x007f,
+	0x009e, 0x00bd, 0x00dd, 0x00fd, 0x011d, 0x013d,
+};
+
+static const u16 lpphy_rev01_filter_control_table[] = {
+	0xa0fc, 0x10fc, 0x10db, 0x20b7, 0xff93, 0x10bf, 0x109b, 0x2077, 0xff53,
+	0x0127,
+};
+
+static const u32 lpphy_rev2plus_filter_control_table[] = {
+	0x000141fc, 0x000021fc, 0x000021b7, 0x0000416f, 0x0001ff27, 0x0000217f,
+	0x00002137, 0x000040ef, 0x0001fea7, 0x0000024f,
+};
+
+static const u32 lpphy_rev01_ps_control_table[] = {
+	0x00010000, 0x000000a0, 0x00040000, 0x00000048, 0x08080101, 0x00000080,
+	0x08080101, 0x00000040, 0x08080101, 0x000000c0, 0x08a81501, 0x000000c0,
+	0x0fe8fd01, 0x000000c0, 0x08300105, 0x000000c0, 0x08080201, 0x000000c0,
+	0x08280205, 0x000000c0, 0xe80802fe, 0x000000c7, 0x28080206, 0x000000c0,
+	0x08080202, 0x000000c0, 0x0ba87602, 0x000000c0, 0x1068013d, 0x000000c0,
+	0x10280105, 0x000000c0, 0x08880102, 0x000000c0, 0x08280106, 0x000000c0,
+	0xe80801fd, 0x000000c7, 0xa8080115, 0x000000c0,
+};
+
+static const u32 lpphy_rev2plus_ps_control_table[] = {
+	0x00e38e08, 0x00e08e38, 0x00000000, 0x00000000, 0x00000000, 0x00002080,
+	0x00006180, 0x00003002, 0x00000040, 0x00002042, 0x00180047, 0x00080043,
+	0x00000041, 0x000020c1, 0x00046006, 0x00042002, 0x00040000, 0x00002003,
+	0x00180006, 0x00080002,
+};
+
+static const u8 lpphy_pll_fraction_table[] = {
+	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80,
+	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+};
+
+static const u16 lpphy_iq_local_table[] = {
+	0x0200, 0x0300, 0x0400, 0x0600, 0x0800, 0x0b00, 0x1000, 0x1001, 0x1002,
+	0x1003, 0x1004, 0x1005, 0x1006, 0x1007, 0x1707, 0x2007, 0x2d07, 0x4007,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0200, 0x0300, 0x0400, 0x0600,
+	0x0800, 0x0b00, 0x1000, 0x1001, 0x1002, 0x1003, 0x1004, 0x1005, 0x1006,
+	0x1007, 0x1707, 0x2007, 0x2d07, 0x4007, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000,
+};
+
+static const u16 lpphy_ofdm_cck_gain_table[] = {
+	0x5000, 0x6000, 0x7000, 0x0001, 0x1001, 0x2001, 0x3001, 0x4001, 0x5001,
+	0x6001, 0x7001, 0x7011, 0x7021, 0x2035, 0x2045, 0x2055, 0x2065, 0x2075,
+	0x006d, 0x007d, 0x014d, 0x015d, 0x115d, 0x035d, 0x135d, 0x055d, 0x155d,
+	0x0d5d, 0x1d5d, 0x2d5d, 0x555d, 0x655d, 0x755d,
+};
+
+static const u16 lpphy_gain_delta_table[] = {
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+};
+
+static const u32 lpphy_tx_power_control_table[] = {
+	0x00000050, 0x0000004f, 0x0000004e, 0x0000004d, 0x0000004c, 0x0000004b,
+	0x0000004a, 0x00000049, 0x00000048, 0x00000047, 0x00000046, 0x00000045,
+	0x00000044, 0x00000043, 0x00000042, 0x00000041, 0x00000040, 0x0000003f,
+	0x0000003e, 0x0000003d, 0x0000003c, 0x0000003b, 0x0000003a, 0x00000039,
+	0x00000038, 0x00000037, 0x00000036, 0x00000035, 0x00000034, 0x00000033,
+	0x00000032, 0x00000031, 0x00000030, 0x0000002f, 0x0000002e, 0x0000002d,
+	0x0000002c, 0x0000002b, 0x0000002a, 0x00000029, 0x00000028, 0x00000027,
+	0x00000026, 0x00000025, 0x00000024, 0x00000023, 0x00000022, 0x00000021,
+	0x00000020, 0x0000001f, 0x0000001e, 0x0000001d, 0x0000001c, 0x0000001b,
+	0x0000001a, 0x00000019, 0x00000018, 0x00000017, 0x00000016, 0x00000015,
+	0x00000014, 0x00000013, 0x00000012, 0x00000011, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x000075a0, 0x000075a0, 0x000075a1, 0x000075a1, 0x000075a2, 0x000075a2,
+	0x000075a3, 0x000075a3, 0x000074b0, 0x000074b0, 0x000074b1, 0x000074b1,
+	0x000074b2, 0x000074b2, 0x000074b3, 0x000074b3, 0x00006d20, 0x00006d20,
+	0x00006d21, 0x00006d21, 0x00006d22, 0x00006d22, 0x00006d23, 0x00006d23,
+	0x00004660, 0x00004660, 0x00004661, 0x00004661, 0x00004662, 0x00004662,
+	0x00004663, 0x00004663, 0x00003e60, 0x00003e60, 0x00003e61, 0x00003e61,
+	0x00003e62, 0x00003e62, 0x00003e63, 0x00003e63, 0x00003660, 0x00003660,
+	0x00003661, 0x00003661, 0x00003662, 0x00003662, 0x00003663, 0x00003663,
+	0x00002e60, 0x00002e60, 0x00002e61, 0x00002e61, 0x00002e62, 0x00002e62,
+	0x00002e63, 0x00002e63, 0x00002660, 0x00002660, 0x00002661, 0x00002661,
+	0x00002662, 0x00002662, 0x00002663, 0x00002663, 0x000025e0, 0x000025e0,
+	0x000025e1, 0x000025e1, 0x000025e2, 0x000025e2, 0x000025e3, 0x000025e3,
+	0x00001de0, 0x00001de0, 0x00001de1, 0x00001de1, 0x00001de2, 0x00001de2,
+	0x00001de3, 0x00001de3, 0x00001d60, 0x00001d60, 0x00001d61, 0x00001d61,
+	0x00001d62, 0x00001d62, 0x00001d63, 0x00001d63, 0x00001560, 0x00001560,
+	0x00001561, 0x00001561, 0x00001562, 0x00001562, 0x00001563, 0x00001563,
+	0x00000d60, 0x00000d60, 0x00000d61, 0x00000d61, 0x00000d62, 0x00000d62,
+	0x00000d63, 0x00000d63, 0x00000ce0, 0x00000ce0, 0x00000ce1, 0x00000ce1,
+	0x00000ce2, 0x00000ce2, 0x00000ce3, 0x00000ce3, 0x00000e10, 0x00000e10,
+	0x00000e11, 0x00000e11, 0x00000e12, 0x00000e12, 0x00000e13, 0x00000e13,
+	0x00000bf0, 0x00000bf0, 0x00000bf1, 0x00000bf1, 0x00000bf2, 0x00000bf2,
+	0x00000bf3, 0x00000bf3, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x04200000, 0x04000000,
+	0x04200000, 0x04000000, 0x04200000, 0x04000000, 0x000000ff, 0x000002fc,
+	0x0000fa08, 0x00000305, 0x00000206, 0x00000304, 0x0000fb04, 0x0000fcff,
+	0x000005fb, 0x0000fd01, 0x00000401, 0x00000006, 0x0000ff03, 0x000007fc,
+	0x0000fc08, 0x00000203, 0x0000fffb, 0x00000600, 0x0000fa01, 0x0000fc03,
+	0x0000fe06, 0x0000fe00, 0x00000102, 0x000007fd, 0x000004fb, 0x000006ff,
+	0x000004fd, 0x0000fdfa, 0x000007fb, 0x0000fdfa, 0x0000fa06, 0x00000500,
+	0x0000f902, 0x000007fa, 0x0000fafa, 0x00000500, 0x000007fa, 0x00000700,
+	0x00000305, 0x000004ff, 0x00000801, 0x00000503, 0x000005f9, 0x00000404,
+	0x0000fb08, 0x000005fd, 0x00000501, 0x00000405, 0x0000fb03, 0x000007fc,
+	0x00000403, 0x00000303, 0x00000402, 0x0000faff, 0x0000fe05, 0x000005fd,
+	0x0000fe01, 0x000007fa, 0x00000202, 0x00000504, 0x00000102, 0x000008fe,
+	0x0000fa04, 0x0000fafc, 0x0000fe08, 0x000000f9, 0x000002fa, 0x000003fe,
+	0x00000304, 0x000004f9, 0x00000100, 0x0000fd06, 0x000008fc, 0x00000701,
+	0x00000504, 0x0000fdfe, 0x0000fdfc, 0x000003fe, 0x00000704, 0x000002fc,
+	0x000004f9, 0x0000fdfd, 0x0000fa07, 0x00000205, 0x000003fd, 0x000005fb,
+	0x000004f9, 0x00000804, 0x0000fc06, 0x0000fcf9, 0x00000100, 0x0000fe05,
+	0x00000408, 0x0000fb02, 0x00000304, 0x000006fe, 0x000004fa, 0x00000305,
+	0x000008fc, 0x00000102, 0x000001fd, 0x000004fc, 0x0000fe03, 0x00000701,
+	0x000001fb, 0x000001f9, 0x00000206, 0x000006fd, 0x00000508, 0x00000700,
+	0x00000304, 0x000005fe, 0x000005ff, 0x0000fa04, 0x00000303, 0x0000fefb,
+	0x000007f9, 0x0000fefc, 0x000004fd, 0x000005fc, 0x0000fffd, 0x0000fc08,
+	0x0000fbf9, 0x0000fd07, 0x000008fb, 0x0000fe02, 0x000006fb, 0x00000702,
+};
+
+static const u32 lpphy_gain_idx_table[] = {
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x10000001, 0x00000000, 0x20000082, 0x00000000, 0x40000104, 0x00000000,
+	0x60004207, 0x00000001, 0x7000838a, 0x00000001, 0xd021050d, 0x00000001,
+	0xe041c683, 0x00000001, 0x50828805, 0x00000000, 0x80e34288, 0x00000000,
+	0xb144040b, 0x00000000, 0xe1a6058e, 0x00000000, 0x12064711, 0x00000001,
+	0xb0a18612, 0x00000010, 0xe1024794, 0x00000010, 0x11630915, 0x00000011,
+	0x31c3ca1b, 0x00000011, 0xc1848a9c, 0x00000018, 0xf1e50da0, 0x00000018,
+	0x22468e21, 0x00000019, 0x4286d023, 0x00000019, 0xa347d0a4, 0x00000019,
+	0xb36811a6, 0x00000019, 0xf3e89227, 0x00000019, 0x0408d329, 0x0000001a,
+	0x244953aa, 0x0000001a, 0x346994ab, 0x0000001a, 0x54aa152c, 0x0000001a,
+	0x64ca55ad, 0x0000001a, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x10000001, 0x00000000, 0x20000082, 0x00000000,
+	0x40000104, 0x00000000, 0x60004207, 0x00000001, 0x7000838a, 0x00000001,
+	0xd021050d, 0x00000001, 0xe041c683, 0x00000001, 0x50828805, 0x00000000,
+	0x80e34288, 0x00000000, 0xb144040b, 0x00000000, 0xe1a6058e, 0x00000000,
+	0x12064711, 0x00000001, 0xb0a18612, 0x00000010, 0xe1024794, 0x00000010,
+	0x11630915, 0x00000011, 0x31c3ca1b, 0x00000011, 0xc1848a9c, 0x00000018,
+	0xf1e50da0, 0x00000018, 0x22468e21, 0x00000019, 0x4286d023, 0x00000019,
+	0xa347d0a4, 0x00000019, 0xb36811a6, 0x00000019, 0xf3e89227, 0x00000019,
+	0x0408d329, 0x0000001a, 0x244953aa, 0x0000001a, 0x346994ab, 0x0000001a,
+	0x54aa152c, 0x0000001a, 0x64ca55ad, 0x0000001a,
+};
+
+static const u16 lpphy_aux_gain_idx_table[] = {
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0001, 0x0002, 0x0004, 0x0016, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0016,
+};
+
+static const u32 lpphy_gain_value_table[] = {
+	0x00000008, 0x0000000e, 0x00000014, 0x0000001a, 0x000000fb, 0x00000004,
+	0x00000008, 0x0000000d, 0x00000001, 0x00000004, 0x00000007, 0x0000000a,
+	0x0000000d, 0x00000010, 0x00000012, 0x00000015, 0x00000000, 0x00000006,
+	0x0000000c, 0x00000000, 0x00000000, 0x00000000, 0x00000012, 0x00000000,
+	0x00000000, 0x00000000, 0x00000018, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0000001e, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000003, 0x00000006, 0x00000009, 0x0000000c, 0x0000000f,
+	0x00000012, 0x00000015, 0x00000018, 0x0000001b, 0x0000001e, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000009, 0x000000f1,
+	0x00000000, 0x00000000,
+};
+
+static const u16 lpphy_gain_table[] = {
+	0x0000, 0x0400, 0x0800, 0x0802, 0x0804, 0x0806, 0x0807, 0x0808, 0x080a,
+	0x080b, 0x080c, 0x080e, 0x080f, 0x0810, 0x0812, 0x0813, 0x0814, 0x0816,
+	0x0817, 0x081a, 0x081b, 0x081f, 0x0820, 0x0824, 0x0830, 0x0834, 0x0837,
+	0x083b, 0x083f, 0x0840, 0x0844, 0x0857, 0x085b, 0x085f, 0x08d7, 0x08db,
+	0x08df, 0x0957, 0x095b, 0x095f, 0x0b57, 0x0b5b, 0x0b5f, 0x0f5f, 0x135f,
+	0x175f, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+};
+
+static const u32 lpphy_a0_gain_idx_table[] = {
+	0x001111e0, 0x00652051, 0x00606055, 0x005b005a, 0x00555060, 0x00511065,
+	0x004c806b, 0x0047d072, 0x00444078, 0x00400080, 0x003ca087, 0x0039408f,
+	0x0035e098, 0x0032e0a1, 0x003030aa, 0x002d80b4, 0x002ae0bf, 0x002880ca,
+	0x002640d6, 0x002410e3, 0x002220f0, 0x002020ff, 0x001e510e, 0x001ca11e,
+	0x001b012f, 0x00199140, 0x00182153, 0x0016c168, 0x0015817d, 0x00145193,
+	0x001321ab, 0x001211c5, 0x001111e0, 0x001021fc, 0x000f321a, 0x000e523a,
+	0x000d925c, 0x000cd27f, 0x000c12a5, 0x000b62cd, 0x000ac2f8, 0x000a2325,
+	0x00099355, 0x00091387, 0x000883bd, 0x000813f5, 0x0007a432, 0x00073471,
+	0x0006c4b5, 0x000664fc, 0x00061547, 0x0005b598, 0x000565ec, 0x00051646,
+	0x0004d6a5, 0x0004870a, 0x00044775, 0x000407e6, 0x0003d85e, 0x000398dd,
+	0x00036963, 0x000339f2, 0x00030a89, 0x0002db28,
+};
+
+static const u16 lpphy_a0_aux_gain_idx_table[] = {
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0002, 0x0014, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0014,
+};
+
+static const u32 lpphy_a0_gain_value_table[] = {
+	0x00000008, 0x0000000e, 0x00000014, 0x0000001a, 0x000000fb, 0x00000004,
+	0x00000008, 0x0000000d, 0x00000001, 0x00000004, 0x00000007, 0x0000000a,
+	0x0000000d, 0x00000010, 0x00000012, 0x00000015, 0x00000000, 0x00000006,
+	0x0000000c, 0x00000000, 0x00000000, 0x00000000, 0x00000012, 0x00000000,
+	0x00000000, 0x00000000, 0x00000018, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0000001e, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000003, 0x00000006, 0x00000009, 0x0000000c, 0x0000000f,
+	0x00000012, 0x00000015, 0x00000018, 0x0000001b, 0x0000001e, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000000f, 0x000000f7,
+	0x00000000, 0x00000000,
+};
+
+static const u16 lpphy_a0_gain_table[] = {
+	0x0000, 0x0002, 0x0004, 0x0006, 0x0007, 0x0008, 0x000a, 0x000b, 0x000c,
+	0x000e, 0x000f, 0x0010, 0x0012, 0x0013, 0x0014, 0x0016, 0x0017, 0x001a,
+	0x001b, 0x001f, 0x0020, 0x0024, 0x0030, 0x0034, 0x0037, 0x003b, 0x003f,
+	0x0040, 0x0044, 0x0057, 0x005b, 0x005f, 0x00d7, 0x00db, 0x00df, 0x0157,
+	0x015b, 0x015f, 0x0357, 0x035b, 0x035f, 0x075f, 0x0b5f, 0x0f5f, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+};
+
+static const u16 lpphy_sw_control_table[] = {
+	0x0128, 0x0128, 0x0009, 0x0009, 0x0028, 0x0028, 0x0028, 0x0028, 0x0128,
+	0x0128, 0x0009, 0x0009, 0x0028, 0x0028, 0x0028, 0x0028, 0x0009, 0x0009,
+	0x0009, 0x0009, 0x0009, 0x0009, 0x0009, 0x0009, 0x0018, 0x0018, 0x0018,
+	0x0018, 0x0018, 0x0018, 0x0018, 0x0018, 0x0128, 0x0128, 0x0009, 0x0009,
+	0x0028, 0x0028, 0x0028, 0x0028, 0x0128, 0x0128, 0x0009, 0x0009, 0x0028,
+	0x0028, 0x0028, 0x0028, 0x0009, 0x0009, 0x0009, 0x0009, 0x0009, 0x0009,
+	0x0009, 0x0009, 0x0018, 0x0018, 0x0018, 0x0018, 0x0018, 0x0018, 0x0018,
+	0x0018,
+};
+
+static const u8 lpphy_hf_table[] = {
+	0x4b, 0x36, 0x24, 0x18, 0x49, 0x34, 0x23, 0x17, 0x48,
+	0x33, 0x23, 0x17, 0x48, 0x33, 0x23, 0x17,
+};
+
+static const u32 lpphy_papd_eps_table[] = {
+	0x00000000, 0x00013ffc, 0x0001dff3, 0x0001bff0, 0x00023fe9, 0x00021fdf,
+	0x00028fdf, 0x00033fd2, 0x00039fcb, 0x00043fc7, 0x0004efc2, 0x00055fb5,
+	0x0005cfb0, 0x00063fa8, 0x00068fa3, 0x00071f98, 0x0007ef92, 0x00084f8b,
+	0x0008df82, 0x00097f77, 0x0009df69, 0x000a3f62, 0x000adf57, 0x000b6f4c,
+	0x000bff41, 0x000c9f39, 0x000cff30, 0x000dbf27, 0x000e4f1e, 0x000edf16,
+	0x000f7f13, 0x00102f11, 0x00110f10, 0x0011df11, 0x0012ef15, 0x00143f1c,
+	0x00158f27, 0x00172f35, 0x00193f47, 0x001baf5f, 0x001e6f7e, 0x0021cfa4,
+	0x0025bfd2, 0x002a2008, 0x002fb047, 0x00360090, 0x003d40e0, 0x0045c135,
+	0x004fb189, 0x005ae1d7, 0x0067221d, 0x0075025a, 0x007ff291, 0x007ff2bf,
+	0x007ff2e3, 0x007ff2ff, 0x007ff315, 0x007ff329, 0x007ff33f, 0x007ff356,
+	0x007ff36e, 0x007ff39c, 0x007ff441, 0x007ff506,
+};
+
+static const u32 lpphy_papd_mult_table[] = {
+	0x001111e0, 0x00652051, 0x00606055, 0x005b005a, 0x00555060, 0x00511065,
+	0x004c806b, 0x0047d072, 0x00444078, 0x00400080, 0x003ca087, 0x0039408f,
+	0x0035e098, 0x0032e0a1, 0x003030aa, 0x002d80b4, 0x002ae0bf, 0x002880ca,
+	0x002640d6, 0x002410e3, 0x002220f0, 0x002020ff, 0x001e510e, 0x001ca11e,
+	0x001b012f, 0x00199140, 0x00182153, 0x0016c168, 0x0015817d, 0x00145193,
+	0x001321ab, 0x001211c5, 0x001111e0, 0x001021fc, 0x000f321a, 0x000e523a,
+	0x000d925c, 0x000cd27f, 0x000c12a5, 0x000b62cd, 0x000ac2f8, 0x000a2325,
+	0x00099355, 0x00091387, 0x000883bd, 0x000813f5, 0x0007a432, 0x00073471,
+	0x0006c4b5, 0x000664fc, 0x00061547, 0x0005b598, 0x000565ec, 0x00051646,
+	0x0004d6a5, 0x0004870a, 0x00044775, 0x000407e6, 0x0003d85e, 0x000398dd,
+	0x00036963, 0x000339f2, 0x00030a89, 0x0002db28,
+};
+
+struct lpphy_tx_gain_table_entry {
+	u8 gm,  pga,  pad,  dac,  bb_mult;
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev0_nopa_tx_gain_table[] = {
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 152, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 147, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 143, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 139, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 135, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 131, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 128, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 124, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 121, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 117, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 114, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 111, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 107, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 104, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 101, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 99, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 96, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 93, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 90, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 88, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 85, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 83, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 81, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 78, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 76, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 74, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 71, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev0_2ghz_tx_gain_table[] = {
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 73, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 73, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 58, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 58, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 57, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 83, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 81, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 78, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 76, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 74, },
+	{ .gm = 4, .pga = 4, .pad = 2, .dac = 0, .bb_mult = 72, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev0_5ghz_tx_gain_table[] = {
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 99, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 96, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 93, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 90, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 88, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 85, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 83, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 81, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 78, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 76, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 74, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 55, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 55, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 60, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev1_nopa_tx_gain_table[] = {
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 152, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 147, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 143, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 139, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 135, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 131, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 128, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 124, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 121, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 117, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 114, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 111, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 107, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 104, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 101, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 99, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 96, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 93, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 90, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 88, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 85, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 83, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 81, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 78, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 76, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 74, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 71, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev1_2ghz_tx_gain_table[] = {
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 85, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 81, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 78, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 76, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 74, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 73, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 73, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 71, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 69, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 58, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 67, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 65, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 63, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 61, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 58, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 62, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev1_5ghz_tx_gain_table[] = {
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 99, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 96, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 93, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 90, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 88, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 85, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 83, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 81, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 78, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 76, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 74, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 55, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 55, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 72, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 73, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 71, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 56, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 14, .pad = 9, .dac = 0, .bb_mult = 58, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 9, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 60, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 13, .pad = 8, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 8, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 12, .pad = 7, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 70, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 68, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 66, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 61, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 59, },
+	{ .gm = 7, .pga = 11, .pad = 7, .dac = 0, .bb_mult = 57, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 69, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 67, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 65, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 63, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 62, },
+	{ .gm = 7, .pga = 11, .pad = 6, .dac = 0, .bb_mult = 60, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev2_nopa_tx_gain_table[] = {
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 152, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 147, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 143, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 139, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 135, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 131, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 128, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 124, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 121, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 117, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 114, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 111, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 107, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 104, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 101, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 99, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 96, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 93, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 90, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 88, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 85, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 83, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 81, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 78, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 76, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 74, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 72, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 70, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 68, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 66, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 197, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 192, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 186, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 181, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 176, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 171, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 166, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 161, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 157, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 152, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 148, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 144, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 140, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 136, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 132, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 128, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 124, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 121, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 117, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 114, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 111, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 108, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 105, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 102, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 99, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 96, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 93, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 91, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 88, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 86, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 83, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 81, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 79, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 76, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 74, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 72, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 70, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 68, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 66, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 64, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 248, .pad = 64, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 248, .pad = 62, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 241, .pad = 62, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 241, .pad = 60, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 234, .pad = 60, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 234, .pad = 59, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 227, .pad = 59, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 227, .pad = 57, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 221, .pad = 57, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 221, .pad = 55, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 215, .pad = 55, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 215, .pad = 54, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 208, .pad = 54, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 208, .pad = 52, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 203, .pad = 52, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 203, .pad = 51, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 197, .pad = 51, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 197, .pad = 49, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 191, .pad = 49, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 191, .pad = 48, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 186, .pad = 48, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 186, .pad = 47, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 181, .pad = 47, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 181, .pad = 45, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 175, .pad = 45, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 175, .pad = 44, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 170, .pad = 44, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 170, .pad = 43, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 166, .pad = 43, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 166, .pad = 42, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 161, .pad = 42, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 161, .pad = 40, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 156, .pad = 40, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 156, .pad = 39, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 152, .pad = 39, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 152, .pad = 38, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 148, .pad = 38, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 148, .pad = 37, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 143, .pad = 37, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 143, .pad = 36, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 139, .pad = 36, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 139, .pad = 35, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 135, .pad = 35, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 135, .pad = 34, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 132, .pad = 34, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 132, .pad = 33, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 128, .pad = 33, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 128, .pad = 32, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 124, .pad = 32, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 124, .pad = 31, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 121, .pad = 31, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 121, .pad = 30, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 117, .pad = 30, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 117, .pad = 29, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 114, .pad = 29, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 114, .pad = 29, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 111, .pad = 29, .dac = 0, .bb_mult = 64, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev2_2ghz_tx_gain_table[] = {
+	{ .gm = 7, .pga = 99, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 96, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 93, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 90, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 88, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 85, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 83, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 81, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 78, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 76, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 74, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 72, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 70, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 68, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 66, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 62, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 62, .pad = 248, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 60, .pad = 248, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 60, .pad = 241, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 59, .pad = 241, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 59, .pad = 234, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 57, .pad = 234, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 57, .pad = 227, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 55, .pad = 227, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 55, .pad = 221, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 54, .pad = 221, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 54, .pad = 215, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 52, .pad = 215, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 52, .pad = 208, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 51, .pad = 208, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 51, .pad = 203, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 49, .pad = 203, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 49, .pad = 197, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 48, .pad = 197, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 48, .pad = 191, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 47, .pad = 191, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 47, .pad = 186, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 45, .pad = 186, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 45, .pad = 181, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 44, .pad = 181, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 44, .pad = 175, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 43, .pad = 175, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 43, .pad = 170, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 42, .pad = 170, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 42, .pad = 166, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 40, .pad = 166, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 40, .pad = 161, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 39, .pad = 161, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 39, .pad = 156, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 38, .pad = 156, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 38, .pad = 152, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 37, .pad = 152, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 37, .pad = 148, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 36, .pad = 148, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 36, .pad = 143, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 35, .pad = 143, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 35, .pad = 139, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 34, .pad = 139, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 34, .pad = 135, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 33, .pad = 135, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 33, .pad = 132, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 32, .pad = 132, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 32, .pad = 128, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 31, .pad = 128, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 31, .pad = 124, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 30, .pad = 124, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 30, .pad = 121, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 29, .pad = 121, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 29, .pad = 117, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 29, .pad = 117, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 29, .pad = 114, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 28, .pad = 114, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 28, .pad = 111, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 27, .pad = 111, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 27, .pad = 108, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 26, .pad = 108, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 26, .pad = 104, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 25, .pad = 104, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 25, .pad = 102, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 25, .pad = 102, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 25, .pad = 99, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 24, .pad = 99, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 24, .pad = 96, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 23, .pad = 96, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 23, .pad = 93, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 23, .pad = 93, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 23, .pad = 90, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 22, .pad = 90, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 22, .pad = 88, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 21, .pad = 88, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 21, .pad = 85, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 21, .pad = 85, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 21, .pad = 83, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 20, .pad = 83, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 20, .pad = 81, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 20, .pad = 81, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 20, .pad = 78, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 19, .pad = 78, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 19, .pad = 76, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 19, .pad = 76, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 19, .pad = 74, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 18, .pad = 74, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 18, .pad = 72, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 18, .pad = 72, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 18, .pad = 70, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 17, .pad = 70, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 17, .pad = 68, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 17, .pad = 68, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 17, .pad = 66, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 16, .pad = 66, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 16, .pad = 64, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 16, .pad = 64, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 16, .pad = 62, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 62, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 60, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 60, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 15, .pad = 59, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 59, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 57, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 57, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 55, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 55, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 14, .pad = 54, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 54, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 52, .dac = 0, .bb_mult = 64, },
+	{ .gm = 7, .pga = 13, .pad = 52, .dac = 0, .bb_mult = 64, },
+};
+
+static struct lpphy_tx_gain_table_entry lpphy_rev2_5ghz_tx_gain_table[] = {
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 152, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 147, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 143, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 139, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 135, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 131, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 128, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 124, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 121, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 117, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 114, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 111, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 107, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 104, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 101, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 99, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 96, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 93, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 90, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 88, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 85, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 83, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 81, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 78, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 76, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 74, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 72, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 70, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 68, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 66, },
+	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 248, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 241, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 234, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 227, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 221, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 215, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 208, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 203, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 197, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 191, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 186, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 181, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 175, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 170, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 166, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 161, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 156, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 152, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 148, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 143, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 139, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 135, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 132, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 128, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 124, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 121, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 117, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 114, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 111, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 108, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 104, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 102, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 99, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 96, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 93, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 90, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 88, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 85, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 83, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 81, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 78, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 76, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 74, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 72, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 70, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 68, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 66, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 62, .pad = 255, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 62, .pad = 248, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 60, .pad = 248, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 60, .pad = 241, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 59, .pad = 241, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 59, .pad = 234, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 57, .pad = 234, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 57, .pad = 227, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 55, .pad = 227, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 55, .pad = 221, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 54, .pad = 221, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 54, .pad = 215, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 52, .pad = 215, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 52, .pad = 208, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 51, .pad = 208, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 51, .pad = 203, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 49, .pad = 203, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 49, .pad = 197, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 48, .pad = 197, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 48, .pad = 191, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 47, .pad = 191, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 47, .pad = 186, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 45, .pad = 186, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 45, .pad = 181, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 44, .pad = 181, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 44, .pad = 175, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 43, .pad = 175, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 43, .pad = 170, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 42, .pad = 170, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 42, .pad = 166, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 40, .pad = 166, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 40, .pad = 161, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 39, .pad = 161, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 39, .pad = 156, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 38, .pad = 156, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 38, .pad = 152, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 37, .pad = 152, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 37, .pad = 148, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 36, .pad = 148, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 36, .pad = 143, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 35, .pad = 143, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 35, .pad = 139, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 34, .pad = 139, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 34, .pad = 135, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 33, .pad = 135, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 33, .pad = 132, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 32, .pad = 132, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 32, .pad = 128, .dac = 0, .bb_mult = 64, },
+};
+
+void lpphy_rev0_1_table_init(struct b43_wldev *dev)
+{
+	B43_WARN_ON(dev->phy.rev >= 2);
+
+	b43_lptab_write_bulk(dev, B43_LPTAB8(2, 0),
+		ARRAY_SIZE(lpphy_min_sig_sq_table), lpphy_min_sig_sq_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(1, 0),
+		ARRAY_SIZE(lpphy_rev01_noise_scale_table), lpphy_rev01_noise_scale_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(14, 0),
+		ARRAY_SIZE(lpphy_crs_gain_nft_table), lpphy_crs_gain_nft_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(8, 0),
+		ARRAY_SIZE(lpphy_rev01_filter_control_table), lpphy_rev01_filter_control_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(9, 0),
+		ARRAY_SIZE(lpphy_rev01_ps_control_table), lpphy_rev01_ps_control_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB8(6, 0),
+		ARRAY_SIZE(lpphy_pll_fraction_table), lpphy_pll_fraction_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(0, 0),
+		ARRAY_SIZE(lpphy_iq_local_table), lpphy_iq_local_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0),
+		ARRAY_SIZE(lpphy_ofdm_cck_gain_table), lpphy_ofdm_cck_gain_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0),
+		ARRAY_SIZE(lpphy_ofdm_cck_gain_table), lpphy_ofdm_cck_gain_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(15, 0),
+		ARRAY_SIZE(lpphy_gain_delta_table), lpphy_gain_delta_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0),
+		ARRAY_SIZE(lpphy_tx_power_control_table), lpphy_tx_power_control_table);
+}
+
+void lpphy_rev2plus_table_init(struct b43_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+	int i;
+
+	B43_WARN_ON(dev->phy.rev < 2);
+
+	/*
+	 * FIXME This code follows the specs, but it looks wrong:
+	 * In each pass, it writes 4 bytes to an offset in table ID 7,
+	 * then increments the offset by 1 for the next pass. This results
+	 * in the first 3 bytes of each pass except the first one getting
+	 * written to a location that has already ben zeroed in the previous
+	 * pass.
+	 * This is what the vendor driver does, but it still looks suspicious.
+	 *
+	 * This should probably suffice:
+	 * 
+	 * for (i = 0; i < 704; i+=4)
+	 * 	b43_lptab_write(dev, B43_LPTAB32(7, i), 0)
+	 *
+	 * This should be tested once the code is functional.
+	 */
+	for (i = 0; i < 704; i++)
+		b43_lptab_write(dev, B43_LPTAB32(7, i), 0);
+
+	b43_lptab_write_bulk(dev, B43_LPTAB8(2, 0),
+		ARRAY_SIZE(lpphy_min_sig_sq_table), lpphy_min_sig_sq_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(1, 0),
+		ARRAY_SIZE(lpphy_rev2plus_noise_scale_table), lpphy_rev2plus_noise_scale_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(11, 0),
+		ARRAY_SIZE(lpphy_rev2plus_filter_control_table), lpphy_rev2plus_filter_control_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(12, 0),
+		ARRAY_SIZE(lpphy_rev2plus_ps_control_table), lpphy_rev2plus_ps_control_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(13, 0),
+		ARRAY_SIZE(lpphy_gain_idx_table), lpphy_gain_idx_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(14, 0),
+		ARRAY_SIZE(lpphy_aux_gain_idx_table), lpphy_aux_gain_idx_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(15, 0),
+		ARRAY_SIZE(lpphy_sw_control_table), lpphy_sw_control_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB8(16, 0),
+		ARRAY_SIZE(lpphy_hf_table), lpphy_hf_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(17, 0),
+		ARRAY_SIZE(lpphy_gain_value_table), lpphy_gain_value_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(18, 0),
+		ARRAY_SIZE(lpphy_gain_table), lpphy_gain_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB8(6, 0),
+		ARRAY_SIZE(lpphy_pll_fraction_table), lpphy_pll_fraction_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(0, 0),
+		ARRAY_SIZE(lpphy_iq_local_table), lpphy_iq_local_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(9, 0),
+		ARRAY_SIZE(lpphy_papd_eps_table), lpphy_papd_eps_table);
+	b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0),
+		ARRAY_SIZE(lpphy_papd_mult_table), lpphy_papd_mult_table);
+
+	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 0)) {
+		b43_lptab_write_bulk(dev, B43_LPTAB32(13, 0),
+			ARRAY_SIZE(lpphy_a0_gain_idx_table), lpphy_a0_gain_idx_table);
+		b43_lptab_write_bulk(dev, B43_LPTAB16(14, 0),
+			ARRAY_SIZE(lpphy_a0_aux_gain_idx_table), lpphy_a0_aux_gain_idx_table);
+		b43_lptab_write_bulk(dev, B43_LPTAB32(17, 0),
+			ARRAY_SIZE(lpphy_a0_gain_value_table), lpphy_a0_gain_value_table);
+		b43_lptab_write_bulk(dev, B43_LPTAB16(18, 0),
+			ARRAY_SIZE(lpphy_a0_gain_table), lpphy_a0_gain_table);
+	}
+}
+
+
+static void lpphy_rev0_1_write_gain_table(struct b43_wldev *dev,
+				struct lpphy_tx_gain_table_entry *table)
+{
+	int i;
+	u32 tmp;
+
+	B43_WARN_ON(dev->phy.rev >= 2);
+
+	for (i = 0; i < 128; i++) {
+		tmp  = table[i].pad << 11;
+		tmp |= table[i].pga << 7;
+		tmp |= table[i].gm  << 4;
+		tmp |= table[i].dac;
+		b43_lptab_write(dev, B43_LPTAB32(10, 0xC0 + i), tmp);
+		tmp  = table[i].bb_mult << 20;
+		b43_lptab_write(dev, B43_LPTAB32(10, 0x140 + i), tmp);
+	}
+}
+
+static void lpphy_rev2plus_write_gain_table(struct b43_wldev *dev,
+				struct lpphy_tx_gain_table_entry *table)
+{
+	int i;
+	u32 tmp;
+
+	B43_WARN_ON(dev->phy.rev < 2);
+
+	for (i = 0; i < 128; i++) {
+		tmp  = table[i].pad << 16;
+		tmp |= table[i].pga << 8;
+		tmp |= table[i].gm;
+		tmp |= 0x7f000000;
+		b43_lptab_write(dev, B43_LPTAB32(7, 0xC0 + i), tmp);
+		tmp  = table[i].bb_mult << 20;
+		tmp |= table[i].dac << 28;
+		b43_lptab_write(dev, B43_LPTAB32(7, 0x140 + i), tmp);
+	}
+}
+
+void lpphy_init_tx_gain_table(struct b43_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+
+	switch (dev->phy.rev) {
+	case 0:
+		if ((bus->sprom.boardflags_hi & B43_BFH_NOPA) ||
+		    (bus->sprom.boardflags_lo & B43_BFL_HGPA))
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev0_nopa_tx_gain_table);
+		else if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev0_2ghz_tx_gain_table);
+		else
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev0_5ghz_tx_gain_table);
+		break;
+	case 1:
+		if ((bus->sprom.boardflags_hi & B43_BFH_NOPA) ||
+		    (bus->sprom.boardflags_lo & B43_BFL_HGPA))
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev1_nopa_tx_gain_table);
+		else if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev1_2ghz_tx_gain_table);
+		else
+			lpphy_rev0_1_write_gain_table(dev,
+					lpphy_rev1_5ghz_tx_gain_table);
+		break;
+	default:
+		if (bus->sprom.boardflags_hi & B43_BFH_NOPA)
+			lpphy_rev2plus_write_gain_table(dev,
+					lpphy_rev2_nopa_tx_gain_table);
+		else if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+			lpphy_rev2plus_write_gain_table(dev,
+					lpphy_rev2_2ghz_tx_gain_table);
+		else
+			lpphy_rev2plus_write_gain_table(dev,
+					lpphy_rev2_5ghz_tx_gain_table);
+	}
+}
diff --git a/drivers/net/wireless/b43/tables_lpphy.h b/drivers/net/wireless/b43/tables_lpphy.h
index 52ce32f..b5024b6 100644
--- a/drivers/net/wireless/b43/tables_lpphy.h
+++ b/drivers/net/wireless/b43/tables_lpphy.h
@@ -28,5 +28,8 @@ void b43_lptab_write_bulk(struct b43_wldev *dev, u32 offset,
 void b2062_upload_init_table(struct b43_wldev *dev);
 void b2063_upload_init_table(struct b43_wldev *dev);
 
+void lpphy_rev0_1_table_init(struct b43_wldev *dev);
+void lpphy_rev2plus_table_init(struct b43_wldev *dev);
+void lpphy_init_tx_gain_table(struct b43_wldev *dev);
 
 #endif /* B43_TABLES_LPPHY_H_ */
-- 
1.6.2.4




From netrolller.3d at gmail.com  Mon Aug 10 20:42:33 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Mon, 10 Aug 2009 20:42:33 +0200
Subject: [PATCH] b43: Update LP-PHY rev2+ baseband init to match the specs
Message-ID: <4A806A19.2070209@gmail.com>

The rev2+ BB init spec has changed behind us, and thus the code is
no longer up to date. Update the code to match the current specs.
Also implement "save/restore dig filt state", as required by the
new specification (implemented as 2 separate functions).

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |   73 +++++++++++++++++++++++++++++++++++--
 drivers/net/wireless/b43/phy_lp.h |    3 ++
 2 files changed, 72 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index d2af924..128d75a 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -195,6 +195,56 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 	}
 }
 
+static void lpphy_save_dig_flt_state(struct b43_wldev *dev)
+{
+	static const u16 addr[] = {
+		B43_PHY_OFDM(0xC1),
+		B43_PHY_OFDM(0xC2),
+		B43_PHY_OFDM(0xC3),
+		B43_PHY_OFDM(0xC4),
+		B43_PHY_OFDM(0xC5),
+		B43_PHY_OFDM(0xC6),
+		B43_PHY_OFDM(0xC7),
+		B43_PHY_OFDM(0xC8),
+		B43_PHY_OFDM(0xCF),
+	};
+
+	static const u16 coeffs[] = {
+		0xDE5E, 0xE832, 0xE331, 0x4D26,
+		0x0026, 0x1420, 0x0020, 0xFE08,
+		0x0008,
+	};
+
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	int i;
+
+	for (i = 0; i < 9; i++) {
+		lpphy->dig_flt_state[i] = b43_phy_read(dev, addr[i]);
+		b43_phy_write(dev, addr[i], coefs[i]);
+	}
+}
+
+static void lpphy_restore_dig_flt_state(struct b43_wldev *dev)
+{
+	static const u16 addr[] = {
+		B43_PHY_OFDM(0xC1),
+		B43_PHY_OFDM(0xC2),
+		B43_PHY_OFDM(0xC3),
+		B43_PHY_OFDM(0xC4),
+		B43_PHY_OFDM(0xC5),
+		B43_PHY_OFDM(0xC6),
+		B43_PHY_OFDM(0xC7),
+		B43_PHY_OFDM(0xC8),
+		B43_PHY_OFDM(0xCF),
+	};
+
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	int i;
+
+	for (i = 0; i < 9; i++)
+		b43_phy_write(dev, addr[i], lpphy->dig_flt_state[i]);
+}
+
 static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 {
 	struct ssb_bus *bus = dev->dev->bus;
@@ -209,7 +259,7 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_write(dev, B43_PHY_OFDM(0xF9), 0);
 	b43_phy_write(dev, B43_LPPHY_TR_LOOKUP_1, 0);
 	b43_phy_set(dev, B43_LPPHY_ADC_COMPENSATION_CTL, 0x10);
-	b43_phy_maskset(dev, B43_LPPHY_OFDMSYNCTHRESH0, 0xFF00, 0x78);
+	b43_phy_maskset(dev, B43_LPPHY_OFDMSYNCTHRESH0, 0xFF00, 0xB4);
 	b43_phy_maskset(dev, B43_LPPHY_DCOFFSETTRANSIENT, 0xF8FF, 0x200);
 	b43_phy_maskset(dev, B43_LPPHY_DCOFFSETTRANSIENT, 0xFF00, 0x7F);
 	b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xFF0F, 0x40);
@@ -217,7 +267,12 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, ~0x4000);
 	b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, ~0x2000);
 	b43_phy_set(dev, B43_PHY_OFDM(0x10A), 0x1);
-	b43_phy_maskset(dev, B43_PHY_OFDM(0x10A), 0xFF01, 0x10);
+	if (bus->boardinfo.rev >= 0x18) {
+		b43_lptab_write(dev, B43_LPTAB32(17, 65), 0xEC);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x10A), 0xFF01, 0x14);
+	} else {
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x10A), 0xFF01, 0x10);
+	}
 	b43_phy_maskset(dev, B43_PHY_OFDM(0xDF), 0xFF00, 0xF4);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0xDF), 0x00FF, 0xF100);
 	b43_phy_write(dev, B43_LPPHY_CLIPTHRESH, 0x48);
@@ -247,8 +302,10 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x12);
 	b43_phy_maskset(dev, B43_LPPHY_GAINMISMATCH, 0x0FFF, 0x9000);
 
-	b43_lptab_write(dev, B43_LPTAB16(0x08, 0x14), 0);
-	b43_lptab_write(dev, B43_LPTAB16(0x08, 0x12), 0x40);
+	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 1)) {
+		b43_lptab_write(dev, B43_LPTAB16(0x08, 0x14), 0);
+		b43_lptab_write(dev, B43_LPTAB16(0x08, 0x12), 0x40);
+	}
 
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
 		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x40);
@@ -268,6 +325,14 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_write(dev, B43_LPPHY_AFE_RSSI_CTL_1,
 		      0x2000 | ((u16)lpphy->rssi_gs << 10) |
 		      ((u16)lpphy->rssi_vc << 4) | lpphy->rssi_vf);
+
+	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 0)) {
+		b43_phy_set(dev, B43_LPPHY_AFE_ADC_CTL_0, 0x1C);
+		b43_phy_maskset(dev, B43_LPPHY_AFE_CTL, 0x00FF, 0x8800);
+		b43_phy_maskset(dev, B43_LPPHY_AFE_ADC_CTL_1, 0xFC3C, 0x0400);
+	}
+
+	lpphy_save_dig_flt_state(dev);
 }
 
 static void lpphy_baseband_init(struct b43_wldev *dev)
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 829b2bb..13d89ea 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -865,6 +865,9 @@ struct b43_phy_lp {
 	/* Transmit iqlocal best coeffs */
 	bool tx_iqloc_best_coeffs_valid;
 	u8 tx_iqloc_best_coeffs[11];
+
+	/* Used for "Save/Restore Dig Filt State" */
+	u16 dig_flt_state[9];
 };
 
 
-- 
1.6.2.4




From mb at bu3sch.de  Mon Aug 10 20:43:51 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 10 Aug 2009 20:43:51 +0200
Subject: [PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <4A806973.1020109@gmail.com>
References: <4A806973.1020109@gmail.com>
Message-ID: <200908102043.51795.mb@bu3sch.de>

On Monday 10 August 2009 20:39:47 G?bor Stefanik wrote:
> Implement LP-PHY baseband table init for all revisions.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> Changes from RFC:
> -Improved table formatting in the code.
> -The 2GHz check in adjust_gain_table now uses b43_current_band.
> -Added a comment to rev2plus_table_init about a possible future improvement.

ack
-- 
Greetings, Michael.


From mb at bu3sch.de  Mon Aug 10 20:46:00 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 10 Aug 2009 20:46:00 +0200
Subject: [PATCH] b43: Update LP-PHY rev2+ baseband init to match the specs
In-Reply-To: <4A806A19.2070209@gmail.com>
References: <4A806A19.2070209@gmail.com>
Message-ID: <200908102046.00427.mb@bu3sch.de>

On Monday 10 August 2009 20:42:33 G?bor Stefanik wrote:
> +static void lpphy_save_dig_flt_state(struct b43_wldev *dev)
> +{
> +	static const u16 addr[] = {
> +		B43_PHY_OFDM(0xC1),
> +		B43_PHY_OFDM(0xC2),
> +		B43_PHY_OFDM(0xC3),
> +		B43_PHY_OFDM(0xC4),
> +		B43_PHY_OFDM(0xC5),
> +		B43_PHY_OFDM(0xC6),
> +		B43_PHY_OFDM(0xC7),
> +		B43_PHY_OFDM(0xC8),
> +		B43_PHY_OFDM(0xCF),
> +	};
> +
> +	static const u16 coeffs[] = {
> +		0xDE5E, 0xE832, 0xE331, 0x4D26,
> +		0x0026, 0x1420, 0x0020, 0xFE08,
> +		0x0008,
> +	};
> +
> +	struct b43_phy_lp *lpphy = dev->phy.lp;
> +	int i;
> +
> +	for (i = 0; i < 9; i++) {

Use ARRAY_SIZE, please.

> +		lpphy->dig_flt_state[i] = b43_phy_read(dev, addr[i]);
> +		b43_phy_write(dev, addr[i], coefs[i]);
> +	}
> +}
> +
> +static void lpphy_restore_dig_flt_state(struct b43_wldev *dev)
> +{
> +	static const u16 addr[] = {
> +		B43_PHY_OFDM(0xC1),
> +		B43_PHY_OFDM(0xC2),
> +		B43_PHY_OFDM(0xC3),
> +		B43_PHY_OFDM(0xC4),
> +		B43_PHY_OFDM(0xC5),
> +		B43_PHY_OFDM(0xC6),
> +		B43_PHY_OFDM(0xC7),
> +		B43_PHY_OFDM(0xC8),
> +		B43_PHY_OFDM(0xCF),
> +	};
> +
> +	struct b43_phy_lp *lpphy = dev->phy.lp;
> +	int i;
> +
> +	for (i = 0; i < 9; i++)

Same here.

> +		b43_phy_write(dev, addr[i], lpphy->dig_flt_state[i]);
> +}
> +


-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Mon Aug 10 20:49:02 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Mon, 10 Aug 2009 20:49:02 +0200
Subject: [PATCH RFC] ssb: Implement the remaining rev.8 SPROM vars needed
	for LP-PHY
Message-ID: <4A806B9E.5010105@gmail.com>

Also add a "SPEX32" macro for extracting 32-bit SPROM variables.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
I'm not quite sure that the SPEX32 macro is sane endianness-wise;
please review it carefully. (In the future, we will probably need
a SPEX64 macro too, to correctly extract boardflags.)

 drivers/ssb/pci.c            |   53 +++++++++++++++++++++++++++++++++-
 include/linux/ssb/ssb.h      |   44 +++++++++++++++++++++++----
 include/linux/ssb/ssb_regs.h |   66 +++++++++++++++++++++++++++++++++++++----
 3 files changed, 148 insertions(+), 15 deletions(-)

diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
index 40ea417..50811e4 100644
--- a/drivers/ssb/pci.c
+++ b/drivers/ssb/pci.c
@@ -169,8 +169,14 @@ err_pci:
 /* Get the word-offset for a SSB_SPROM_XXX define. */
 #define SPOFF(offset)	(((offset) - SSB_SPROM_BASE) / sizeof(u16))
 /* Helper to extract some _offset, which is one of the SSB_SPROM_XXX defines. */
-#define SPEX(_outvar, _offset, _mask, _shift)	\
+#define SPEX16(_outvar, _offset, _mask, _shift)	\
 	out->_outvar = ((in[SPOFF(_offset)] & (_mask)) >> (_shift))
+#define SPEX32(_outvar, _offset, _mask, _shift)	\
+	out->_outvar = ((((in[SPOFF((_offset)+2)] << sizeof(u16)) | \
+			   in[SPOFF(_offset)]) & (_mask)) >> (_shift))
+#define SPEX(_outvar, _offset, _mask, _shift) \
+	SPEX16(_outvar, _offset, _mask, _shift)
+
 
 static inline u8 ssb_crc8(u8 crc, u8 data)
 {
@@ -480,6 +486,8 @@ static void sprom_extract_r8(struct ssb_sprom *out, const u16 *in)
 	SPEX(country_code, SSB_SPROM8_CCODE, 0xFFFF, 0);
 	SPEX(boardflags_lo, SSB_SPROM8_BFLLO, 0xFFFF, 0);
 	SPEX(boardflags_hi, SSB_SPROM8_BFLHI, 0xFFFF, 0);
+	SPEX(boardflags2_lo, SSB_SPROM8_BFL2LO, 0xFFFF, 0);
+	SPEX(boardflags2_hi, SSB_SPROM8_BFL2HI, 0xFFFF, 0);
 	SPEX(ant_available_a, SSB_SPROM8_ANTAVAIL, SSB_SPROM8_ANTAVAIL_A,
 	     SSB_SPROM8_ANTAVAIL_A_SHIFT);
 	SPEX(ant_available_bg, SSB_SPROM8_ANTAVAIL, SSB_SPROM8_ANTAVAIL_BG,
@@ -490,12 +498,55 @@ static void sprom_extract_r8(struct ssb_sprom *out, const u16 *in)
 	SPEX(maxpwr_a, SSB_SPROM8_MAXP_A, SSB_SPROM8_MAXP_A_MASK, 0);
 	SPEX(itssi_a, SSB_SPROM8_MAXP_A, SSB_SPROM8_ITSSI_A,
 	     SSB_SPROM8_ITSSI_A_SHIFT);
+	SPEX(maxpwr_ah, SSB_SPROM8_MAXP_AHL, SSB_SPROM8_MAXP_AH_MASK, 0);
+	SPEX(maxpwr_al, SSB_SPROM8_MAXP_AHL, SSB_SPROM8_MAXP_AL_MASK,
+	     SSB_SPROM8_MAXP_AL_SHIFT);
 	SPEX(gpio0, SSB_SPROM8_GPIOA, SSB_SPROM8_GPIOA_P0, 0);
 	SPEX(gpio1, SSB_SPROM8_GPIOA, SSB_SPROM8_GPIOA_P1,
 	     SSB_SPROM8_GPIOA_P1_SHIFT);
 	SPEX(gpio2, SSB_SPROM8_GPIOB, SSB_SPROM8_GPIOB_P2, 0);
 	SPEX(gpio3, SSB_SPROM8_GPIOB, SSB_SPROM8_GPIOB_P3,
 	     SSB_SPROM8_GPIOB_P3_SHIFT);
+	SPEX(tri2g, SSB_SPROM8_TRI25G, SSB_SPROM8_TRI2G, 0);
+	SPEX(tri5g, SSB_SPROM8_TRI25G, SSB_SPROM8_TRI5G,
+	     SSB_SPROM8_TRI5G_SHIFT);
+	SPEX(tri5gl, SSB_SPROM8_TRI5GHL, SSB_SPROM8_TRI5GL, 0);
+	SPEX(tri5gh, SSB_SPROM8_TRI5GHL, SSB_SPROM8_TRI5GH,
+	     SSB_SPROM8_TRI5GH_SHIFT);
+	SPEX(rxpo2g, SSB_SPROM8_RXPO, SSB_SPROM8_RXPO2G, 0);
+	SPEX(rxpo5g, SSB_SPROM8_RXPO, SSB_SPROM8_RXPO5G,
+	     SSB_SPROM8_RXPO5G_SHIFT);
+	SPEX(rssismf2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_RSSISMF2G, 0);
+	SPEX(rssismc2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_RSSISMC2G,
+	     SSB_SPROM8_RSSISMC2G_SHIFT);
+	SPEX(rssisav2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_RSSISAV2G,
+	     SSB_SPROM8_RSSISAV2G_SHIFT);
+	SPEX(bxa2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_BXA2G,
+	     SSB_SPROM8_BXA2G_SHIFT);
+	SPEX(rssismf5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_RSSISMF5G, 0);
+	SPEX(rssismc5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_RSSISMC5G,
+	     SSB_SPROM8_RSSISMC5G_SHIFT);
+	SPEX(rssisav5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_RSSISAV5G,
+	     SSB_SPROM8_RSSISAV5G_SHIFT);
+	SPEX(bxa5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_BXA5G,
+	     SSB_SPROM8_BXA5G_SHIFT);
+	SPEX(pa0b0, SSB_SPROM8_PA0B0, 0xFFFF, 0);
+	SPEX(pa0b1, SSB_SPROM8_PA0B1, 0xFFFF, 0);
+	SPEX(pa0b2, SSB_SPROM8_PA0B2, 0xFFFF, 0);
+	SPEX(pa1b0, SSB_SPROM8_PA1B0, 0xFFFF, 0);
+	SPEX(pa1b1, SSB_SPROM8_PA1B1, 0xFFFF, 0);
+	SPEX(pa1b2, SSB_SPROM8_PA1B2, 0xFFFF, 0);
+	SPEX(pa1lob0, SSB_SPROM8_PA1LOB0, 0xFFFF, 0);
+	SPEX(pa1lob1, SSB_SPROM8_PA1LOB1, 0xFFFF, 0);
+	SPEX(pa1lob2, SSB_SPROM8_PA1LOB2, 0xFFFF, 0);
+	SPEX(pa1hib0, SSB_SPROM8_PA1HIB0, 0xFFFF, 0);
+	SPEX(pa1hib1, SSB_SPROM8_PA1HIB1, 0xFFFF, 0);
+	SPEX(pa1hib2, SSB_SPROM8_PA1HIB2, 0xFFFF, 0);
+	SPEX(cck2gpo, SSB_SPROM8_CCK2GPO, 0xFFFF, 0);
+	SPEX32(ofdm2gpo, SSB_SPROM8_OFDM2GPO, 0xFFFFFFFF, 0);
+	SPEX32(ofdm5glpo, SSB_SPROM8_OFDM5GLPO, 0xFFFFFFFF, 0);
+	SPEX32(ofdm5gpo, SSB_SPROM8_OFDM5GPO, 0xFFFFFFFF, 0);
+	SPEX32(ofdm5ghpo, SSB_SPROM8_OFDM5GHPO, 0xFFFFFFFF, 0);
 
 	/* Extract the antenna gain values. */
 	SPEX(antenna_gain.ghz24.a0, SSB_SPROM8_AGAIN01,
diff --git a/include/linux/ssb/ssb.h b/include/linux/ssb/ssb.h
index 5ae8fa2..17ffc1f 100644
--- a/include/linux/ssb/ssb.h
+++ b/include/linux/ssb/ssb.h
@@ -27,24 +27,54 @@ struct ssb_sprom {
 	u8 et1mdcport;		/* MDIO for enet1 */
 	u8 board_rev;		/* Board revision number from SPROM. */
 	u8 country_code;	/* Country Code */
-	u8 ant_available_a;	/* A-PHY antenna available bits (up to 4) */
-	u8 ant_available_bg;	/* B/G-PHY antenna available bits (up to 4) */
+	u8 ant_available_a;	/* 2GHz antenna available bits (up to 4) */
+	u8 ant_available_bg;	/* 5GHz antenna available bits (up to 4) */
 	u16 pa0b0;
 	u16 pa0b1;
 	u16 pa0b2;
 	u16 pa1b0;
 	u16 pa1b1;
 	u16 pa1b2;
+	u16 pa1lob0;
+	u16 pa1lob1;
+	u16 pa1lob2;
+	u16 pa1hib0;
+	u16 pa1hib1;
+	u16 pa1hib2;
 	u8 gpio0;		/* GPIO pin 0 */
 	u8 gpio1;		/* GPIO pin 1 */
 	u8 gpio2;		/* GPIO pin 2 */
 	u8 gpio3;		/* GPIO pin 3 */
-	u16 maxpwr_a;		/* A-PHY Amplifier Max Power (in dBm Q5.2) */
-	u16 maxpwr_bg;		/* B/G-PHY Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_bg;		/* 2.4GHz Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_al;		/* 5.2GHz Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_a;		/* 5.3GHz Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_ah;		/* 5.8GHz Amplifier Max Power (in dBm Q5.2) */
 	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
 	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
-	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
-	u16 boardflags_hi;	/* Boardflags (high 16 bits) */
+	u8 tri2g;		/* 2.4GHz TX isolation */
+	u8 tri5gl;		/* 5.2GHz TX isolation */
+	u8 tri5g;		/* 5.3GHz TX isolation */
+	u8 tri5gh;		/* 5.8GHz TX isolation */
+	u8 rxpo2g;		/* 2GHz RX power offset */
+	u8 rxpo5g;		/* 5GHz RX power offset */
+	u8 rssisav2g;		/* 2GHz RSSI params */
+	u8 rssismc2g;
+	u8 rssismf2g;
+	u8 bxa2g;		/* 2GHz BX arch */
+	u8 rssisav5g;		/* 5GHz RSSI params */
+	u8 rssismc5g;
+	u8 rssismf5g;
+	u8 bxa5g;		/* 5GHz BX arch */
+	u16 cck2gpo;		/* CCK power offset */
+	u32 ofdm2gpo;		/* 2.4GHz OFDM power offset */
+	u32 ofdm5glpo;		/* 5.2GHz OFDM power offset */
+	u32 ofdm5gpo;		/* 5.3GHz OFDM power offset */
+	u32 ofdm5ghpo;		/* 5.8GHz OFDM power offset */
+	u16 boardflags_lo;	/* Board flags (bits 0-15) */
+	u16 boardflags_hi;	/* Board flags (bits 16-31) */
+	u16 boardflags2_lo;	/* Board flags (bits 32-47) */
+	u16 boardflags2_hi;	/* Board flags (bits 48-63) */
+	/* TODO store board flags in a single u64 */
 
 	/* Antenna gain values for up to 4 antennas
 	 * on each band. Values in dBm/4 (Q5.2). Negative gain means the
@@ -58,7 +88,7 @@ struct ssb_sprom {
 		} ghz5;		/* 5GHz band */
 	} antenna_gain;
 
-	/* TODO - add any parameters needed from rev 2, 3, or 4 SPROMs */
+	/* TODO - add any parameters needed from rev 2, 3, 4, 5 or 8 SPROMs */
 };
 
 /* Information about the PCB the circuitry is soldered on. */
diff --git a/include/linux/ssb/ssb_regs.h b/include/linux/ssb/ssb_regs.h
index a01b982..9ae9082 100644
--- a/include/linux/ssb/ssb_regs.h
+++ b/include/linux/ssb/ssb_regs.h
@@ -162,7 +162,7 @@
 
 /* SPROM shadow area. If not otherwise noted, fields are
  * two bytes wide. Note that the SPROM can _only_ be read
- * in two-byte quantinies.
+ * in two-byte quantities.
  */
 #define SSB_SPROMSIZE_WORDS		64
 #define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
@@ -327,8 +327,11 @@
 #define  SSB_SPROM5_GPIOB_P3_SHIFT	8
 
 /* SPROM Revision 8 */
-#define SSB_SPROM8_BFLLO		0x1084	/* Boardflags (low 16 bits) */
-#define SSB_SPROM8_BFLHI		0x1086	/* Boardflags Hi */
+#define SSB_SPROM8_BOARDREV		0x1082	/* Board revision */
+#define SSB_SPROM8_BFLLO		0x1084	/* Board flags (bits 0-15) */
+#define SSB_SPROM8_BFLHI		0x1086	/* Board flags (bits 16-31) */
+#define SSB_SPROM8_BFL2LO		0x1088	/* Board flags (bits 32-47) */
+#define SSB_SPROM8_BFL2HI		0x108A	/* Board flags (bits 48-63) */
 #define SSB_SPROM8_IL0MAC		0x108C	/* 6 byte MAC address */
 #define SSB_SPROM8_CCODE		0x1092	/* 2 byte country code */
 #define SSB_SPROM8_ANTAVAIL		0x109C  /* Antenna available bitfields*/
@@ -354,14 +357,63 @@
 #define  SSB_SPROM8_GPIOB_P2		0x00FF	/* Pin 2 */
 #define  SSB_SPROM8_GPIOB_P3		0xFF00	/* Pin 3 */
 #define  SSB_SPROM8_GPIOB_P3_SHIFT	8
-#define SSB_SPROM8_MAXP_BG		0x10C0  /* Max Power BG in path 1 */
-#define  SSB_SPROM8_MAXP_BG_MASK	0x00FF  /* Mask for Max Power BG */
+#define SSB_SPROM8_RSSIPARM2G		0x10A4	/* RSSI params for 2GHz */
+#define  SSB_SPROM8_RSSISMF2G		0x000F
+#define  SSB_SPROM8_RSSISMC2G		0x00F0
+#define  SSB_SPROM8_RSSISMC2G_SHIFT	4
+#define  SSB_SPROM8_RSSISAV2G		0x0700
+#define  SSB_SPROM8_RSSISAV2G_SHIFT	8
+#define  SSB_SPROM8_BXA2G		0x1800
+#define  SSB_SPROM8_BXA2G_SHIFT		11
+#define SSB_SPROM8_RSSIPARM5G		0x10A6	/* RSSI params for 5GHz */
+#define  SSB_SPROM8_RSSISMF5G		0x000F
+#define  SSB_SPROM8_RSSISMC5G		0x00F0
+#define  SSB_SPROM8_RSSISMC5G_SHIFT	4
+#define  SSB_SPROM8_RSSISAV5G		0x0700
+#define  SSB_SPROM8_RSSISAV5G_SHIFT	8
+#define  SSB_SPROM8_BXA5G		0x1800
+#define  SSB_SPROM8_BXA5G_SHIFT		11
+#define SSB_SPROM8_TRI25G		0x10A8	/* TX isolation 2.4&5.3GHz */
+#define  SSB_SPROM8_TRI2G		0x00FF	/* TX isolation 2.4GHz */
+#define  SSB_SPROM8_TRI5G		0xFF00	/* TX isolation 5.3GHz */
+#define  SSB_SPROM8_TRI5G_SHIFT		8
+#define SSB_SPROM8_TRI5GHL		0x10AA	/* TX isolation 5.2/5.8GHz */
+#define  SSB_SPROM8_TRI5GL		0x00FF	/* TX isolation 5.2GHz */
+#define  SSB_SPROM8_TRI5GH		0xFF00	/* TX isolation 5.8GHz */
+#define  SSB_SPROM8_TRI5GH_SHIFT	8
+#define SSB_SPROM8_RXPO			0x10AC  /* RX power offsets */
+#define  SSB_SPROM8_RXPO2G		0x00FF	/* 2GHz RX power offset */
+#define  SSB_SPROM8_RXPO5G		0xFF00	/* 5GHz RX power offset */
+#define  SSB_SPROM8_RXPO5G_SHIFT	8
+#define SSB_SPROM8_MAXP_BG		0x10C0  /* Max Power 2GHz in path 1 */
+#define  SSB_SPROM8_MAXP_BG_MASK	0x00FF  /* Mask for Max Power 2GHz */
 #define  SSB_SPROM8_ITSSI_BG		0xFF00	/* Mask for path 1 itssi_bg */
 #define  SSB_SPROM8_ITSSI_BG_SHIFT	8
-#define SSB_SPROM8_MAXP_A		0x10C8  /* Max Power A in path 1 */
-#define  SSB_SPROM8_MAXP_A_MASK		0x00FF  /* Mask for Max Power A */
+#define SSB_SPROM8_PA0B0		0x10C2	/* 2GHz power amp settings */
+#define SSB_SPROM8_PA0B1		0x10C4
+#define SSB_SPROM8_PA0B2		0x10C6
+#define SSB_SPROM8_MAXP_A		0x10C8  /* Max Power 5.3GHz */
+#define  SSB_SPROM8_MAXP_A_MASK		0x00FF  /* Mask for Max Power 5.3GHz */
 #define  SSB_SPROM8_ITSSI_A		0xFF00	/* Mask for path 1 itssi_a */
 #define  SSB_SPROM8_ITSSI_A_SHIFT	8
+#define SSB_SPROM8_MAXP_AHL		0x10CA  /* Max Power 5.2/5.8GHz */
+#define  SSB_SPROM8_MAXP_AH_MASK	0x00FF  /* Mask for Max Power 5.8GHz */
+#define  SSB_SPROM8_MAXP_AL_MASK	0xFF00  /* Mask for Max Power 5.2GHz */
+#define  SSB_SPROM8_MAXP_AL_SHIFT	8
+#define SSB_SPROM8_PA1B0		0x10CC	/* 5.3GHz power amp settings */
+#define SSB_SPROM8_PA1B1		0x10CE
+#define SSB_SPROM8_PA1B2		0x10D0
+#define SSB_SPROM8_PA1LOB0		0x10D2	/* 5.2GHz power amp settings */
+#define SSB_SPROM8_PA1LOB1		0x10D4
+#define SSB_SPROM8_PA1LOB2		0x10D6
+#define SSB_SPROM8_PA1HIB0		0x10D8	/* 5.8GHz power amp settings */
+#define SSB_SPROM8_PA1HIB1		0x10DA
+#define SSB_SPROM8_PA1HIB2		0x10DC
+#define SSB_SPROM8_CCK2GPO		0x1140	/* CCK power offset */
+#define SSB_SPROM8_OFDM2GPO		0x1142	/* 2.4GHz OFDM power offset */
+#define SSB_SPROM8_OFDM5GPO		0x1146	/* 5.3GHz OFDM power offset */
+#define SSB_SPROM8_OFDM5GLPO		0x114A	/* 5.2GHz OFDM power offset */
+#define SSB_SPROM8_OFDM5GHPO		0x114E	/* 5.8GHz OFDM power offset */
 
 /* Values for SSB_SPROM1_BINF_CCODE */
 enum {
-- 
1.6.2.4




From Larry.Finger at lwfinger.net  Mon Aug 10 20:51:27 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 10 Aug 2009 13:51:27 -0500
Subject: [PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <4A806973.1020109@gmail.com>
References: <4A806973.1020109@gmail.com>
Message-ID: <4A806C2F.9070206@lwfinger.net>

G?bor Stefanik wrote:
> Implement LP-PHY baseband table init for all revisions.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> Changes from RFC:
> -Improved table formatting in the code.
> -The 2GHz check in adjust_gain_table now uses b43_current_band.
> -Added a comment to rev2plus_table_init about a possible future
> improvement.

I like the new table formatting.

The comment in rev2plus_table_init has a typo - "ben" should be
"been". Otherwise it looks good. Thanks for all your work.

Larry


From netrolller.3d at gmail.com  Mon Aug 10 20:57:06 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Mon, 10 Aug 2009 20:57:06 +0200
Subject: [PATCH V2] b43: Update LP-PHY rev2+ baseband init to match the specs
Message-ID: <4A806D82.4010606@gmail.com>

The rev2+ BB init spec has changed behind us, and thus the code is
no longer up to date. Update the code to match the current specs.
Also implement save/restore dig filt state, as required by the
new specification.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
V2: use ARRAY_SIZE for loop counts.

 drivers/net/wireless/b43/phy_lp.c |   73 +++++++++++++++++++++++++++++++++++--
 drivers/net/wireless/b43/phy_lp.h |    3 ++
 2 files changed, 72 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index d2af924..128d75a 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -195,6 +195,56 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 	}
 }
 
+static void lpphy_save_dig_flt_state(struct b43_wldev *dev)
+{
+	static const u16 addr[] = {
+		B43_PHY_OFDM(0xC1),
+		B43_PHY_OFDM(0xC2),
+		B43_PHY_OFDM(0xC3),
+		B43_PHY_OFDM(0xC4),
+		B43_PHY_OFDM(0xC5),
+		B43_PHY_OFDM(0xC6),
+		B43_PHY_OFDM(0xC7),
+		B43_PHY_OFDM(0xC8),
+		B43_PHY_OFDM(0xCF),
+	};
+
+	static const u16 coefs[] = {
+		0xDE5E, 0xE832, 0xE331, 0x4D26,
+		0x0026, 0x1420, 0x0020, 0xFE08,
+		0x0008,
+	};
+
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(addr); i++) {
+		lpphy->dig_flt_state[i] = b43_phy_read(dev, addr[i]);
+		b43_phy_write(dev, addr[i], coefs[i]);
+	}
+}
+
+static void lpphy_restore_dig_flt_state(struct b43_wldev *dev)
+{
+	static const u16 addr[] = {
+		B43_PHY_OFDM(0xC1),
+		B43_PHY_OFDM(0xC2),
+		B43_PHY_OFDM(0xC3),
+		B43_PHY_OFDM(0xC4),
+		B43_PHY_OFDM(0xC5),
+		B43_PHY_OFDM(0xC6),
+		B43_PHY_OFDM(0xC7),
+		B43_PHY_OFDM(0xC8),
+		B43_PHY_OFDM(0xCF),
+	};
+
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(addr); i++)
+		b43_phy_write(dev, addr[i], lpphy->dig_flt_state[i]);
+}
+
 static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 {
 	struct ssb_bus *bus = dev->dev->bus;
@@ -209,7 +259,7 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_write(dev, B43_PHY_OFDM(0xF9), 0);
 	b43_phy_write(dev, B43_LPPHY_TR_LOOKUP_1, 0);
 	b43_phy_set(dev, B43_LPPHY_ADC_COMPENSATION_CTL, 0x10);
-	b43_phy_maskset(dev, B43_LPPHY_OFDMSYNCTHRESH0, 0xFF00, 0x78);
+	b43_phy_maskset(dev, B43_LPPHY_OFDMSYNCTHRESH0, 0xFF00, 0xB4);
 	b43_phy_maskset(dev, B43_LPPHY_DCOFFSETTRANSIENT, 0xF8FF, 0x200);
 	b43_phy_maskset(dev, B43_LPPHY_DCOFFSETTRANSIENT, 0xFF00, 0x7F);
 	b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xFF0F, 0x40);
@@ -217,7 +267,12 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, ~0x4000);
 	b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, ~0x2000);
 	b43_phy_set(dev, B43_PHY_OFDM(0x10A), 0x1);
-	b43_phy_maskset(dev, B43_PHY_OFDM(0x10A), 0xFF01, 0x10);
+	if (bus->boardinfo.rev >= 0x18) {
+		b43_lptab_write(dev, B43_LPTAB32(17, 65), 0xEC);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x10A), 0xFF01, 0x14);
+	} else {
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x10A), 0xFF01, 0x10);
+	}
 	b43_phy_maskset(dev, B43_PHY_OFDM(0xDF), 0xFF00, 0xF4);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0xDF), 0x00FF, 0xF100);
 	b43_phy_write(dev, B43_LPPHY_CLIPTHRESH, 0x48);
@@ -247,8 +302,10 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x12);
 	b43_phy_maskset(dev, B43_LPPHY_GAINMISMATCH, 0x0FFF, 0x9000);
 
-	b43_lptab_write(dev, B43_LPTAB16(0x08, 0x14), 0);
-	b43_lptab_write(dev, B43_LPTAB16(0x08, 0x12), 0x40);
+	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 1)) {
+		b43_lptab_write(dev, B43_LPTAB16(0x08, 0x14), 0);
+		b43_lptab_write(dev, B43_LPTAB16(0x08, 0x12), 0x40);
+	}
 
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
 		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x40);
@@ -268,6 +325,14 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_write(dev, B43_LPPHY_AFE_RSSI_CTL_1,
 		      0x2000 | ((u16)lpphy->rssi_gs << 10) |
 		      ((u16)lpphy->rssi_vc << 4) | lpphy->rssi_vf);
+
+	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 0)) {
+		b43_phy_set(dev, B43_LPPHY_AFE_ADC_CTL_0, 0x1C);
+		b43_phy_maskset(dev, B43_LPPHY_AFE_CTL, 0x00FF, 0x8800);
+		b43_phy_maskset(dev, B43_LPPHY_AFE_ADC_CTL_1, 0xFC3C, 0x0400);
+	}
+
+	lpphy_save_dig_flt_state(dev);
 }
 
 static void lpphy_baseband_init(struct b43_wldev *dev)
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 829b2bb..13d89ea 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -865,6 +865,9 @@ struct b43_phy_lp {
 	/* Transmit iqlocal best coeffs */
 	bool tx_iqloc_best_coeffs_valid;
 	u8 tx_iqloc_best_coeffs[11];
+
+	/* Used for "Save/Restore Dig Filt State" */
+	u16 dig_flt_state[9];
 };
 
 
-- 
1.6.2.4




From netrolller.3d at gmail.com  Mon Aug 10 20:58:44 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 10 Aug 2009 20:58:44 +0200
Subject: [PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <4A806C2F.9070206@lwfinger.net>
References: <4A806973.1020109@gmail.com> <4A806C2F.9070206@lwfinger.net>
Message-ID: <69e28c910908101158nbc9477re66a203657b702f6@mail.gmail.com>

2009/8/10 Larry Finger <Larry.Finger at lwfinger.net>:
> G?bor Stefanik wrote:
>> Implement LP-PHY baseband table init for all revisions.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> Changes from RFC:
>> -Improved table formatting in the code.
>> -The 2GHz check in adjust_gain_table now uses b43_current_band.
>> -Added a comment to rev2plus_table_init about a possible future
>> improvement.
>
> I like the new table formatting.
>
> The comment in rev2plus_table_init has a typo - "ben" should be
> "been". Otherwise it looks good. Thanks for all your work.
>
> Larry
>

John, can you fix that when checking in, or should I resubmit with the
typo fixed?

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Mon Aug 10 21:01:38 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 10 Aug 2009 21:01:38 +0200
Subject: [PATCH RFC] ssb: Implement the remaining rev.8 SPROM vars needed
	for LP-PHY
In-Reply-To: <4A806B9E.5010105@gmail.com>
References: <4A806B9E.5010105@gmail.com>
Message-ID: <200908102101.38698.mb@bu3sch.de>

On Monday 10 August 2009 20:49:02 G?bor Stefanik wrote:
> Also add a "SPEX32" macro for extracting 32-bit SPROM variables.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> I'm not quite sure that the SPEX32 macro is sane endianness-wise;
> please review it carefully. (In the future, we will probably need
> a SPEX64 macro too, to correctly extract boardflags.)
> 
>  drivers/ssb/pci.c            |   53 +++++++++++++++++++++++++++++++++-
>  include/linux/ssb/ssb.h      |   44 +++++++++++++++++++++++----
>  include/linux/ssb/ssb_regs.h |   66 +++++++++++++++++++++++++++++++++++++----
>  3 files changed, 148 insertions(+), 15 deletions(-)
> 
> diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
> index 40ea417..50811e4 100644
> --- a/drivers/ssb/pci.c
> +++ b/drivers/ssb/pci.c
> @@ -169,8 +169,14 @@ err_pci:
>  /* Get the word-offset for a SSB_SPROM_XXX define. */
>  #define SPOFF(offset)	(((offset) - SSB_SPROM_BASE) / sizeof(u16))
>  /* Helper to extract some _offset, which is one of the SSB_SPROM_XXX defines. */
> -#define SPEX(_outvar, _offset, _mask, _shift)	\
> +#define SPEX16(_outvar, _offset, _mask, _shift)	\
>  	out->_outvar = ((in[SPOFF(_offset)] & (_mask)) >> (_shift))
> +#define SPEX32(_outvar, _offset, _mask, _shift)	\
> +	out->_outvar = ((((in[SPOFF((_offset)+2)] << sizeof(u16)) | \
                                                  ^^^^^^^^^^^^^^
This shifts by 2 bit. Did you want 16 bits? Just write  << 16  then.
Also, it seems you need +1 instead of +2 (it is an u16 pointer).
I also usually cast u16 values to u32 before shifting >=16 bits.
The result of shifting a 16bit variable left by 16bits is machine dependent.
It works as expected for every linux architecture, but I prefer the cast anyway.

Your macro extracts the value in littleendian format. I didn't check if this is
correct for your values. But there also are values stored in BE format.


-- 
Greetings, Michael.


From mb at bu3sch.de  Mon Aug 10 21:02:26 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 10 Aug 2009 21:02:26 +0200
Subject: [PATCH V2] b43: Update LP-PHY rev2+ baseband init to match the
	specs
In-Reply-To: <4A806D82.4010606@gmail.com>
References: <4A806D82.4010606@gmail.com>
Message-ID: <200908102102.26416.mb@bu3sch.de>

On Monday 10 August 2009 20:57:06 G?bor Stefanik wrote:
> The rev2+ BB init spec has changed behind us, and thus the code is
> no longer up to date. Update the code to match the current specs.
> Also implement save/restore dig filt state, as required by the
> new specification.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> V2: use ARRAY_SIZE for loop counts.

ack

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Mon Aug 10 21:07:45 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 10 Aug 2009 21:07:45 +0200
Subject: [PATCH RFC] ssb: Implement the remaining rev.8 SPROM vars needed 
	for LP-PHY
In-Reply-To: <200908102101.38698.mb@bu3sch.de>
References: <4A806B9E.5010105@gmail.com> <200908102101.38698.mb@bu3sch.de>
Message-ID: <69e28c910908101207p17139562v55ede047c944dae@mail.gmail.com>

2009/8/10 Michael Buesch <mb at bu3sch.de>:
> On Monday 10 August 2009 20:49:02 G?bor Stefanik wrote:
>> Also add a "SPEX32" macro for extracting 32-bit SPROM variables.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> I'm not quite sure that the SPEX32 macro is sane endianness-wise;
>> please review it carefully. (In the future, we will probably need
>> a SPEX64 macro too, to correctly extract boardflags.)
>>
>> ?drivers/ssb/pci.c ? ? ? ? ? ?| ? 53 +++++++++++++++++++++++++++++++++-
>> ?include/linux/ssb/ssb.h ? ? ?| ? 44 +++++++++++++++++++++++----
>> ?include/linux/ssb/ssb_regs.h | ? 66 +++++++++++++++++++++++++++++++++++++----
>> ?3 files changed, 148 insertions(+), 15 deletions(-)
>>
>> diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
>> index 40ea417..50811e4 100644
>> --- a/drivers/ssb/pci.c
>> +++ b/drivers/ssb/pci.c
>> @@ -169,8 +169,14 @@ err_pci:
>> ?/* Get the word-offset for a SSB_SPROM_XXX define. */
>> ?#define SPOFF(offset) ? ? ? ?(((offset) - SSB_SPROM_BASE) / sizeof(u16))
>> ?/* Helper to extract some _offset, which is one of the SSB_SPROM_XXX defines. */
>> -#define SPEX(_outvar, _offset, _mask, _shift) ? ? ? ?\
>> +#define SPEX16(_outvar, _offset, _mask, _shift) ? ? ?\
>> ? ? ? out->_outvar = ((in[SPOFF(_offset)] & (_mask)) >> (_shift))
>> +#define SPEX32(_outvar, _offset, _mask, _shift) ? ? ?\
>> + ? ? out->_outvar = ((((in[SPOFF((_offset)+2)] << sizeof(u16)) | \
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?^^^^^^^^^^^^^^
> This shifts by 2 bit. Did you want 16 bits? Just write ?<< 16 ?then.
Good catch, thanks!

> Also, it seems you need +1 instead of +2 (it is an u16 pointer).
I'm adding to _offset, not to SPOFF(_offset). AFAICS _offset is not an
u16 pointer, it's a plain #defined number, unlike SPOFF(_offset).

> I also usually cast u16 values to u32 before shifting >=16 bits.
> The result of shifting a 16bit variable left by 16bits is machine dependent.
> It works as expected for every linux architecture, but I prefer the cast anyway.
Will do, thanks.

>
> Your macro extracts the value in littleendian format. I didn't check if this is
> correct for your values. But there also are values stored in BE format.
Larry, do you have any comments on this?

>
>
> --
> Greetings, Michael.
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Mon Aug 10 21:12:09 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 10 Aug 2009 21:12:09 +0200
Subject: [PATCH RFC] ssb: Implement the remaining rev.8 SPROM vars needed
	for LP-PHY
In-Reply-To: <69e28c910908101207p17139562v55ede047c944dae@mail.gmail.com>
References: <4A806B9E.5010105@gmail.com> <200908102101.38698.mb@bu3sch.de>
	<69e28c910908101207p17139562v55ede047c944dae@mail.gmail.com>
Message-ID: <200908102112.09368.mb@bu3sch.de>

On Monday 10 August 2009 21:07:45 G?bor Stefanik wrote:
> > Also, it seems you need +1 instead of +2 (it is an u16 pointer).
> I'm adding to _offset, not to SPOFF(_offset). AFAICS _offset is not an
> u16 pointer, it's a plain #defined number, unlike SPOFF(_offset).

Ah ok. All those parenthesis are a little bit confusing. 8-X

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Mon Aug 10 21:23:08 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Mon, 10 Aug 2009 21:23:08 +0200
Subject: [PATCH] ssb: Implement the remaining rev.8 SPROM vars needed for
	LP-PHY
Message-ID: <4A80739C.2050209@gmail.com>

Also add a "SPEX32" macro for extracting 32-bit SPROM variables.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Changes from RFC:
-Fixed a bug in the SPEX32 macro.
-in[SPOFF...] is now cast to u32 to be extra-safe.

The macro still extracts little-endian, as that is probably
what the driver expects (at least for the regular SPEX macro) -
however, Larry said that SPEX is broken (it should extract big
endian), and the driver may be relying on incorrect behavior.
This should be looked into eventually.

 drivers/ssb/pci.c            |   53 +++++++++++++++++++++++++++++++++-
 include/linux/ssb/ssb.h      |   44 +++++++++++++++++++++++----
 include/linux/ssb/ssb_regs.h |   66 +++++++++++++++++++++++++++++++++++++----
 3 files changed, 148 insertions(+), 15 deletions(-)

diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
index 40ea417..50811e4 100644
--- a/drivers/ssb/pci.c
+++ b/drivers/ssb/pci.c
@@ -169,8 +169,14 @@ err_pci:
 /* Get the word-offset for a SSB_SPROM_XXX define. */
 #define SPOFF(offset)	(((offset) - SSB_SPROM_BASE) / sizeof(u16))
 /* Helper to extract some _offset, which is one of the SSB_SPROM_XXX defines. */
-#define SPEX(_outvar, _offset, _mask, _shift)	\
+#define SPEX16(_outvar, _offset, _mask, _shift)	\
 	out->_outvar = ((in[SPOFF(_offset)] & (_mask)) >> (_shift))
+#define SPEX32(_outvar, _offset, _mask, _shift)	\
+	out->_outvar = (((((u32)in[SPOFF((_offset)+2)] << 16 | \
+			   in[SPOFF(_offset)]) & (_mask)) >> (_shift))
+#define SPEX(_outvar, _offset, _mask, _shift) \
+	SPEX16(_outvar, _offset, _mask, _shift)
+
 
 static inline u8 ssb_crc8(u8 crc, u8 data)
 {
@@ -480,6 +486,8 @@ static void sprom_extract_r8(struct ssb_sprom *out, const u16 *in)
 	SPEX(country_code, SSB_SPROM8_CCODE, 0xFFFF, 0);
 	SPEX(boardflags_lo, SSB_SPROM8_BFLLO, 0xFFFF, 0);
 	SPEX(boardflags_hi, SSB_SPROM8_BFLHI, 0xFFFF, 0);
+	SPEX(boardflags2_lo, SSB_SPROM8_BFL2LO, 0xFFFF, 0);
+	SPEX(boardflags2_hi, SSB_SPROM8_BFL2HI, 0xFFFF, 0);
 	SPEX(ant_available_a, SSB_SPROM8_ANTAVAIL, SSB_SPROM8_ANTAVAIL_A,
 	     SSB_SPROM8_ANTAVAIL_A_SHIFT);
 	SPEX(ant_available_bg, SSB_SPROM8_ANTAVAIL, SSB_SPROM8_ANTAVAIL_BG,
@@ -490,12 +498,55 @@ static void sprom_extract_r8(struct ssb_sprom *out, const u16 *in)
 	SPEX(maxpwr_a, SSB_SPROM8_MAXP_A, SSB_SPROM8_MAXP_A_MASK, 0);
 	SPEX(itssi_a, SSB_SPROM8_MAXP_A, SSB_SPROM8_ITSSI_A,
 	     SSB_SPROM8_ITSSI_A_SHIFT);
+	SPEX(maxpwr_ah, SSB_SPROM8_MAXP_AHL, SSB_SPROM8_MAXP_AH_MASK, 0);
+	SPEX(maxpwr_al, SSB_SPROM8_MAXP_AHL, SSB_SPROM8_MAXP_AL_MASK,
+	     SSB_SPROM8_MAXP_AL_SHIFT);
 	SPEX(gpio0, SSB_SPROM8_GPIOA, SSB_SPROM8_GPIOA_P0, 0);
 	SPEX(gpio1, SSB_SPROM8_GPIOA, SSB_SPROM8_GPIOA_P1,
 	     SSB_SPROM8_GPIOA_P1_SHIFT);
 	SPEX(gpio2, SSB_SPROM8_GPIOB, SSB_SPROM8_GPIOB_P2, 0);
 	SPEX(gpio3, SSB_SPROM8_GPIOB, SSB_SPROM8_GPIOB_P3,
 	     SSB_SPROM8_GPIOB_P3_SHIFT);
+	SPEX(tri2g, SSB_SPROM8_TRI25G, SSB_SPROM8_TRI2G, 0);
+	SPEX(tri5g, SSB_SPROM8_TRI25G, SSB_SPROM8_TRI5G,
+	     SSB_SPROM8_TRI5G_SHIFT);
+	SPEX(tri5gl, SSB_SPROM8_TRI5GHL, SSB_SPROM8_TRI5GL, 0);
+	SPEX(tri5gh, SSB_SPROM8_TRI5GHL, SSB_SPROM8_TRI5GH,
+	     SSB_SPROM8_TRI5GH_SHIFT);
+	SPEX(rxpo2g, SSB_SPROM8_RXPO, SSB_SPROM8_RXPO2G, 0);
+	SPEX(rxpo5g, SSB_SPROM8_RXPO, SSB_SPROM8_RXPO5G,
+	     SSB_SPROM8_RXPO5G_SHIFT);
+	SPEX(rssismf2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_RSSISMF2G, 0);
+	SPEX(rssismc2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_RSSISMC2G,
+	     SSB_SPROM8_RSSISMC2G_SHIFT);
+	SPEX(rssisav2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_RSSISAV2G,
+	     SSB_SPROM8_RSSISAV2G_SHIFT);
+	SPEX(bxa2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_BXA2G,
+	     SSB_SPROM8_BXA2G_SHIFT);
+	SPEX(rssismf5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_RSSISMF5G, 0);
+	SPEX(rssismc5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_RSSISMC5G,
+	     SSB_SPROM8_RSSISMC5G_SHIFT);
+	SPEX(rssisav5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_RSSISAV5G,
+	     SSB_SPROM8_RSSISAV5G_SHIFT);
+	SPEX(bxa5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_BXA5G,
+	     SSB_SPROM8_BXA5G_SHIFT);
+	SPEX(pa0b0, SSB_SPROM8_PA0B0, 0xFFFF, 0);
+	SPEX(pa0b1, SSB_SPROM8_PA0B1, 0xFFFF, 0);
+	SPEX(pa0b2, SSB_SPROM8_PA0B2, 0xFFFF, 0);
+	SPEX(pa1b0, SSB_SPROM8_PA1B0, 0xFFFF, 0);
+	SPEX(pa1b1, SSB_SPROM8_PA1B1, 0xFFFF, 0);
+	SPEX(pa1b2, SSB_SPROM8_PA1B2, 0xFFFF, 0);
+	SPEX(pa1lob0, SSB_SPROM8_PA1LOB0, 0xFFFF, 0);
+	SPEX(pa1lob1, SSB_SPROM8_PA1LOB1, 0xFFFF, 0);
+	SPEX(pa1lob2, SSB_SPROM8_PA1LOB2, 0xFFFF, 0);
+	SPEX(pa1hib0, SSB_SPROM8_PA1HIB0, 0xFFFF, 0);
+	SPEX(pa1hib1, SSB_SPROM8_PA1HIB1, 0xFFFF, 0);
+	SPEX(pa1hib2, SSB_SPROM8_PA1HIB2, 0xFFFF, 0);
+	SPEX(cck2gpo, SSB_SPROM8_CCK2GPO, 0xFFFF, 0);
+	SPEX32(ofdm2gpo, SSB_SPROM8_OFDM2GPO, 0xFFFFFFFF, 0);
+	SPEX32(ofdm5glpo, SSB_SPROM8_OFDM5GLPO, 0xFFFFFFFF, 0);
+	SPEX32(ofdm5gpo, SSB_SPROM8_OFDM5GPO, 0xFFFFFFFF, 0);
+	SPEX32(ofdm5ghpo, SSB_SPROM8_OFDM5GHPO, 0xFFFFFFFF, 0);
 
 	/* Extract the antenna gain values. */
 	SPEX(antenna_gain.ghz24.a0, SSB_SPROM8_AGAIN01,
diff --git a/include/linux/ssb/ssb.h b/include/linux/ssb/ssb.h
index 5ae8fa2..17ffc1f 100644
--- a/include/linux/ssb/ssb.h
+++ b/include/linux/ssb/ssb.h
@@ -27,24 +27,54 @@ struct ssb_sprom {
 	u8 et1mdcport;		/* MDIO for enet1 */
 	u8 board_rev;		/* Board revision number from SPROM. */
 	u8 country_code;	/* Country Code */
-	u8 ant_available_a;	/* A-PHY antenna available bits (up to 4) */
-	u8 ant_available_bg;	/* B/G-PHY antenna available bits (up to 4) */
+	u8 ant_available_a;	/* 2GHz antenna available bits (up to 4) */
+	u8 ant_available_bg;	/* 5GHz antenna available bits (up to 4) */
 	u16 pa0b0;
 	u16 pa0b1;
 	u16 pa0b2;
 	u16 pa1b0;
 	u16 pa1b1;
 	u16 pa1b2;
+	u16 pa1lob0;
+	u16 pa1lob1;
+	u16 pa1lob2;
+	u16 pa1hib0;
+	u16 pa1hib1;
+	u16 pa1hib2;
 	u8 gpio0;		/* GPIO pin 0 */
 	u8 gpio1;		/* GPIO pin 1 */
 	u8 gpio2;		/* GPIO pin 2 */
 	u8 gpio3;		/* GPIO pin 3 */
-	u16 maxpwr_a;		/* A-PHY Amplifier Max Power (in dBm Q5.2) */
-	u16 maxpwr_bg;		/* B/G-PHY Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_bg;		/* 2.4GHz Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_al;		/* 5.2GHz Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_a;		/* 5.3GHz Amplifier Max Power (in dBm Q5.2) */
+	u16 maxpwr_ah;		/* 5.8GHz Amplifier Max Power (in dBm Q5.2) */
 	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
 	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
-	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
-	u16 boardflags_hi;	/* Boardflags (high 16 bits) */
+	u8 tri2g;		/* 2.4GHz TX isolation */
+	u8 tri5gl;		/* 5.2GHz TX isolation */
+	u8 tri5g;		/* 5.3GHz TX isolation */
+	u8 tri5gh;		/* 5.8GHz TX isolation */
+	u8 rxpo2g;		/* 2GHz RX power offset */
+	u8 rxpo5g;		/* 5GHz RX power offset */
+	u8 rssisav2g;		/* 2GHz RSSI params */
+	u8 rssismc2g;
+	u8 rssismf2g;
+	u8 bxa2g;		/* 2GHz BX arch */
+	u8 rssisav5g;		/* 5GHz RSSI params */
+	u8 rssismc5g;
+	u8 rssismf5g;
+	u8 bxa5g;		/* 5GHz BX arch */
+	u16 cck2gpo;		/* CCK power offset */
+	u32 ofdm2gpo;		/* 2.4GHz OFDM power offset */
+	u32 ofdm5glpo;		/* 5.2GHz OFDM power offset */
+	u32 ofdm5gpo;		/* 5.3GHz OFDM power offset */
+	u32 ofdm5ghpo;		/* 5.8GHz OFDM power offset */
+	u16 boardflags_lo;	/* Board flags (bits 0-15) */
+	u16 boardflags_hi;	/* Board flags (bits 16-31) */
+	u16 boardflags2_lo;	/* Board flags (bits 32-47) */
+	u16 boardflags2_hi;	/* Board flags (bits 48-63) */
+	/* TODO store board flags in a single u64 */
 
 	/* Antenna gain values for up to 4 antennas
 	 * on each band. Values in dBm/4 (Q5.2). Negative gain means the
@@ -58,7 +88,7 @@ struct ssb_sprom {
 		} ghz5;		/* 5GHz band */
 	} antenna_gain;
 
-	/* TODO - add any parameters needed from rev 2, 3, or 4 SPROMs */
+	/* TODO - add any parameters needed from rev 2, 3, 4, 5 or 8 SPROMs */
 };
 
 /* Information about the PCB the circuitry is soldered on. */
diff --git a/include/linux/ssb/ssb_regs.h b/include/linux/ssb/ssb_regs.h
index a01b982..9ae9082 100644
--- a/include/linux/ssb/ssb_regs.h
+++ b/include/linux/ssb/ssb_regs.h
@@ -162,7 +162,7 @@
 
 /* SPROM shadow area. If not otherwise noted, fields are
  * two bytes wide. Note that the SPROM can _only_ be read
- * in two-byte quantinies.
+ * in two-byte quantities.
  */
 #define SSB_SPROMSIZE_WORDS		64
 #define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
@@ -327,8 +327,11 @@
 #define  SSB_SPROM5_GPIOB_P3_SHIFT	8
 
 /* SPROM Revision 8 */
-#define SSB_SPROM8_BFLLO		0x1084	/* Boardflags (low 16 bits) */
-#define SSB_SPROM8_BFLHI		0x1086	/* Boardflags Hi */
+#define SSB_SPROM8_BOARDREV		0x1082	/* Board revision */
+#define SSB_SPROM8_BFLLO		0x1084	/* Board flags (bits 0-15) */
+#define SSB_SPROM8_BFLHI		0x1086	/* Board flags (bits 16-31) */
+#define SSB_SPROM8_BFL2LO		0x1088	/* Board flags (bits 32-47) */
+#define SSB_SPROM8_BFL2HI		0x108A	/* Board flags (bits 48-63) */
 #define SSB_SPROM8_IL0MAC		0x108C	/* 6 byte MAC address */
 #define SSB_SPROM8_CCODE		0x1092	/* 2 byte country code */
 #define SSB_SPROM8_ANTAVAIL		0x109C  /* Antenna available bitfields*/
@@ -354,14 +357,63 @@
 #define  SSB_SPROM8_GPIOB_P2		0x00FF	/* Pin 2 */
 #define  SSB_SPROM8_GPIOB_P3		0xFF00	/* Pin 3 */
 #define  SSB_SPROM8_GPIOB_P3_SHIFT	8
-#define SSB_SPROM8_MAXP_BG		0x10C0  /* Max Power BG in path 1 */
-#define  SSB_SPROM8_MAXP_BG_MASK	0x00FF  /* Mask for Max Power BG */
+#define SSB_SPROM8_RSSIPARM2G		0x10A4	/* RSSI params for 2GHz */
+#define  SSB_SPROM8_RSSISMF2G		0x000F
+#define  SSB_SPROM8_RSSISMC2G		0x00F0
+#define  SSB_SPROM8_RSSISMC2G_SHIFT	4
+#define  SSB_SPROM8_RSSISAV2G		0x0700
+#define  SSB_SPROM8_RSSISAV2G_SHIFT	8
+#define  SSB_SPROM8_BXA2G		0x1800
+#define  SSB_SPROM8_BXA2G_SHIFT		11
+#define SSB_SPROM8_RSSIPARM5G		0x10A6	/* RSSI params for 5GHz */
+#define  SSB_SPROM8_RSSISMF5G		0x000F
+#define  SSB_SPROM8_RSSISMC5G		0x00F0
+#define  SSB_SPROM8_RSSISMC5G_SHIFT	4
+#define  SSB_SPROM8_RSSISAV5G		0x0700
+#define  SSB_SPROM8_RSSISAV5G_SHIFT	8
+#define  SSB_SPROM8_BXA5G		0x1800
+#define  SSB_SPROM8_BXA5G_SHIFT		11
+#define SSB_SPROM8_TRI25G		0x10A8	/* TX isolation 2.4&5.3GHz */
+#define  SSB_SPROM8_TRI2G		0x00FF	/* TX isolation 2.4GHz */
+#define  SSB_SPROM8_TRI5G		0xFF00	/* TX isolation 5.3GHz */
+#define  SSB_SPROM8_TRI5G_SHIFT		8
+#define SSB_SPROM8_TRI5GHL		0x10AA	/* TX isolation 5.2/5.8GHz */
+#define  SSB_SPROM8_TRI5GL		0x00FF	/* TX isolation 5.2GHz */
+#define  SSB_SPROM8_TRI5GH		0xFF00	/* TX isolation 5.8GHz */
+#define  SSB_SPROM8_TRI5GH_SHIFT	8
+#define SSB_SPROM8_RXPO			0x10AC  /* RX power offsets */
+#define  SSB_SPROM8_RXPO2G		0x00FF	/* 2GHz RX power offset */
+#define  SSB_SPROM8_RXPO5G		0xFF00	/* 5GHz RX power offset */
+#define  SSB_SPROM8_RXPO5G_SHIFT	8
+#define SSB_SPROM8_MAXP_BG		0x10C0  /* Max Power 2GHz in path 1 */
+#define  SSB_SPROM8_MAXP_BG_MASK	0x00FF  /* Mask for Max Power 2GHz */
 #define  SSB_SPROM8_ITSSI_BG		0xFF00	/* Mask for path 1 itssi_bg */
 #define  SSB_SPROM8_ITSSI_BG_SHIFT	8
-#define SSB_SPROM8_MAXP_A		0x10C8  /* Max Power A in path 1 */
-#define  SSB_SPROM8_MAXP_A_MASK		0x00FF  /* Mask for Max Power A */
+#define SSB_SPROM8_PA0B0		0x10C2	/* 2GHz power amp settings */
+#define SSB_SPROM8_PA0B1		0x10C4
+#define SSB_SPROM8_PA0B2		0x10C6
+#define SSB_SPROM8_MAXP_A		0x10C8  /* Max Power 5.3GHz */
+#define  SSB_SPROM8_MAXP_A_MASK		0x00FF  /* Mask for Max Power 5.3GHz */
 #define  SSB_SPROM8_ITSSI_A		0xFF00	/* Mask for path 1 itssi_a */
 #define  SSB_SPROM8_ITSSI_A_SHIFT	8
+#define SSB_SPROM8_MAXP_AHL		0x10CA  /* Max Power 5.2/5.8GHz */
+#define  SSB_SPROM8_MAXP_AH_MASK	0x00FF  /* Mask for Max Power 5.8GHz */
+#define  SSB_SPROM8_MAXP_AL_MASK	0xFF00  /* Mask for Max Power 5.2GHz */
+#define  SSB_SPROM8_MAXP_AL_SHIFT	8
+#define SSB_SPROM8_PA1B0		0x10CC	/* 5.3GHz power amp settings */
+#define SSB_SPROM8_PA1B1		0x10CE
+#define SSB_SPROM8_PA1B2		0x10D0
+#define SSB_SPROM8_PA1LOB0		0x10D2	/* 5.2GHz power amp settings */
+#define SSB_SPROM8_PA1LOB1		0x10D4
+#define SSB_SPROM8_PA1LOB2		0x10D6
+#define SSB_SPROM8_PA1HIB0		0x10D8	/* 5.8GHz power amp settings */
+#define SSB_SPROM8_PA1HIB1		0x10DA
+#define SSB_SPROM8_PA1HIB2		0x10DC
+#define SSB_SPROM8_CCK2GPO		0x1140	/* CCK power offset */
+#define SSB_SPROM8_OFDM2GPO		0x1142	/* 2.4GHz OFDM power offset */
+#define SSB_SPROM8_OFDM5GPO		0x1146	/* 5.3GHz OFDM power offset */
+#define SSB_SPROM8_OFDM5GLPO		0x114A	/* 5.2GHz OFDM power offset */
+#define SSB_SPROM8_OFDM5GHPO		0x114E	/* 5.8GHz OFDM power offset */
 
 /* Values for SSB_SPROM1_BINF_CCODE */
 enum {
-- 
1.6.2.4




From linville at tuxdriver.com  Mon Aug 10 22:14:32 2009
From: linville at tuxdriver.com (John W. Linville)
Date: Mon, 10 Aug 2009 16:14:32 -0400
Subject: [PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <69e28c910908101158nbc9477re66a203657b702f6@mail.gmail.com>
References: <4A806973.1020109@gmail.com> <4A806C2F.9070206@lwfinger.net>
	<69e28c910908101158nbc9477re66a203657b702f6@mail.gmail.com>
Message-ID: <20090810201431.GA6060@tuxdriver.com>

On Mon, Aug 10, 2009 at 08:58:44PM +0200, G?bor Stefanik wrote:
> 2009/8/10 Larry Finger <Larry.Finger at lwfinger.net>:
> > G?bor Stefanik wrote:
> >> Implement LP-PHY baseband table init for all revisions.
> >>
> >> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> >> ---
> >> Changes from RFC:
> >> -Improved table formatting in the code.
> >> -The 2GHz check in adjust_gain_table now uses b43_current_band.
> >> -Added a comment to rev2plus_table_init about a possible future
> >> improvement.
> >
> > I like the new table formatting.
> >
> > The comment in rev2plus_table_init has a typo - "ben" should be
> > "been". Otherwise it looks good. Thanks for all your work.
> >
> > Larry
> >
> 
> John, can you fix that when checking in, or should I resubmit with the
> typo fixed?

Sure, fine...

-- 
John W. Linville		Someday the world will need a hero, and you
linville at tuxdriver.com			might be all we have.  Be ready.


From netrolller.3d at gmail.com  Mon Aug 10 22:16:58 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 10 Aug 2009 22:16:58 +0200
Subject: [PATCH] b43: Implement LP-PHY baseband table initialization
In-Reply-To: <20090810201431.GA6060@tuxdriver.com>
References: <4A806973.1020109@gmail.com> <4A806C2F.9070206@lwfinger.net> 
	<69e28c910908101158nbc9477re66a203657b702f6@mail.gmail.com> 
	<20090810201431.GA6060@tuxdriver.com>
Message-ID: <69e28c910908101316m66ea76dfq2108144e916a7544@mail.gmail.com>

2009/8/10 John W. Linville <linville at tuxdriver.com>:
> On Mon, Aug 10, 2009 at 08:58:44PM +0200, G?bor Stefanik wrote:
>> 2009/8/10 Larry Finger <Larry.Finger at lwfinger.net>:
>> > G?bor Stefanik wrote:
>> >> Implement LP-PHY baseband table init for all revisions.
>> >>
>> >> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> >> ---
>> >> Changes from RFC:
>> >> -Improved table formatting in the code.
>> >> -The 2GHz check in adjust_gain_table now uses b43_current_band.
>> >> -Added a comment to rev2plus_table_init about a possible future
>> >> improvement.
>> >
>> > I like the new table formatting.
>> >
>> > The comment in rev2plus_table_init has a typo - "ben" should be
>> > "been". Otherwise it looks good. Thanks for all your work.
>> >
>> > Larry
>> >
>>
>> John, can you fix that when checking in, or should I resubmit with the
>> typo fixed?
>
> Sure, fine...
>
> --
> John W. Linville ? ? ? ? ? ? ? ?Someday the world will need a hero, and you
> linville at tuxdriver.com ? ? ? ? ? ? ? ? ?might be all we have. ?Be ready.
>
Thanks!


-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Tue Aug 11 00:37:20 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Tue, 11 Aug 2009 00:37:20 +0200
Subject: [PATCH RFC] b43: LP-PHY: Implement reading band SPROM
Message-ID: <4A80A120.30607@gmail.com>

Some of the new variables in b43_phy_lp appear to be dead code in
the vendor driver; they will be removed if they remain unused when
LP-PHY implementation is finished.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
I've added a few FIXME comments, please review them.
Also please check that I used the correct types (e.g. u16) for the new variables.

Variable name mappings vs. the specification:
cckpo = tmp3
ofdmpo = tmp2
maxpwr = tmp1

The array txpwr_srom_max[3] has been broken up into 3 variables,
each called max_tx_pwr_{low|med|hi}_band. A struct holding 3 named u16s
may also be a good choice, but I am not fond of using an array for this.
 
 drivers/net/wireless/b43/phy_lp.c |   83 ++++++++++++++++++++++++++++++++++++-
 drivers/net/wireless/b43/phy_lp.h |   16 +++++++
 2 files changed, 98 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 43272a8..46fe476 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -59,6 +59,87 @@ static void b43_lpphy_op_free(struct b43_wldev *dev)
 	dev->phy.lp = NULL;
 }
 
+static void lpphy_read_band_sprom(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct ssb_bus *bus = dev->dev->bus;
+	u16 cckpo, maxpwr;
+	u32 ofdmpo;
+	int i;
+
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		lpphy->tx_isolation_med_band = bus->sprom.tri2g;
+		lpphy->bx_arch = bus->sprom.bxa2g;
+		lpphy->rssi_vf = bus->sprom.rssismf2g;
+		lpphy->rssi_vc = bus->sprom.rssismc2g;
+		lpphy->rssi_gs = bus->sprom.rssisav2g;
+		lpphy->txpa[0] = bus->sprom.pa0b0;
+		lpphy->txpa[1] = bus->sprom.pa0b1;
+		lpphy->txpa[2] = bus->sprom.pa0b2;
+		maxpwr = bus->sprom.maxpwr_bg;
+		lpphy->max_tx_pwr_med_band = maxpwr;
+		cckpo = bus->sprom.cck2gpo;
+		ofdmpo = bus->sprom.ofdm2gpo;
+		if (cckpo) {
+			for (i = 0; i < 4; i++) {
+				lpphy->tx_max_rate[i] =
+					maxpwr - (ofdmpo & 0xF) * 2;
+				ofdmpo << 4;
+			}
+			ofdmpo = bus->sprom.ofdm2gpo;
+			for (i = 4; i < 15; i++) {
+				lpphy->tx_max_rate[i] =
+					maxpwr - (ofdmpo & 0xF) * 2;
+				ofdmpo << 4;
+			}
+		} else {
+			ofdmpo &= 0xFF;
+			for (i = 0; i < 4; i++)
+				lpphy->tx_max_rate[i] = maxpwr;
+			for (i = 4; i < 15; i++)
+				lpphy->tx_max_rate[i] = maxpwr - ofdmpo;
+		}
+	} else { /* 5GHz */
+		lpphy->tx_isolation_low_band = bus->sprom.tri5gl;
+		lpphy->tx_isolation_med_band = bus->sprom.tri5g;
+		lpphy->tx_isolation_hi_band = bus->sprom.tri5gh;
+		lpphy->bx_arch = bus->sprom.bxa5g;
+		lpphy->rssi_vf = bus->sprom.rssismf5g;
+		lpphy->rssi_vc = bus->sprom.rssismc5g;
+		lpphy->rssi_gs = bus->sprom.rssisav5g;
+		lpphy->txpa[0] = bus->sprom.pa1b0;
+		lpphy->txpa[1] = bus->sprom.pa1b1;
+		lpphy->txpa[2] = bus->sprom.pa1b2;
+		lpphy->txpal[0] = bus->sprom.pa1lob0;
+		lpphy->txpal[1] = bus->sprom.pa1lob1;
+		lpphy->txpal[2] = bus->sprom.pa1lob2;
+		lpphy->txpah[0] = bus->sprom.pa1hib0;
+		lpphy->txpah[1] = bus->sprom.pa1hib1;
+		lpphy->txpah[2] = bus->sprom.pa1hib2;
+		maxpwr = bus->sprom.maxpwr_al;
+		ofdmpo = bus->sprom.ofdm5glpo;
+		lpphy->max_tx_pwr_low_band = maxpwr;
+		for (i = 4; i < 12; i++) {
+			lpphy->tx_max_ratel[i] = maxpwr - (ofdmpo & 0xF) * 2;
+			ofdmpo << 4;
+		}
+		maxpwr = bus->sprom.maxpwr_a;
+		ofdmpo = bus->sprom.ofdm5gpo;
+		lpphy->max_tx_pwr_med_band = maxpwr;
+		for (i = 4; i < 12; i++) {
+			lpphy->tx_max_rate[i] = maxpwr - (ofdmpo & 0xF) * 2;
+			ofdmpo << 4;
+		}
+		maxpwr = bus->sprom.maxpwr_ah;
+		ofdmpo = bus->sprom.ofdm5ghpo;
+		lpphy->max_tx_pwr_hi_band = maxpwr;
+		for (i = 4; i < 12; i++) {
+			lpphy->tx_max_rateh[i] = maxpwr - (ofdmpo & 0xF) * 2;
+			ofdmpo << 4;
+		}
+	}
+}
+
 static void lpphy_adjust_gain_table(struct b43_wldev *dev)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
@@ -694,7 +775,7 @@ static void lpphy_tx_pctl_init(struct b43_wldev *dev)
 
 static int b43_lpphy_op_init(struct b43_wldev *dev)
 {
-	/* TODO: band SPROM */
+	lpphy_read_band_sprom(dev); //FIXME should this be in prepare_structs?
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
 	//TODO calibrate RC
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 13d89ea..9d0443c 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -831,6 +831,22 @@ struct b43_phy_lp {
 	/* Transmit isolation high band */
 	u8 tx_isolation_hi_band; /* FIXME initial value? */
 
+	/* Max transmit power medium band */
+	u16 max_tx_pwr_med_band;
+	/* Max transmit power low band */
+	u16 max_tx_pwr_low_band;
+	/* Max transmit power high band */
+	u16 max_tx_pwr_hi_band;
+
+	/* FIXME What are these used for? */
+	/* FIXME Is 15 the correct array size? */
+	u16 tx_sprom_max_rate[15];
+	u16 tx_sprom_max_ratel[15];
+	u16 tx_sprom_max_rateh[15];
+
+	/* Transmit power arrays */
+	s16 txpa[3], txpal[3], txpah[3];
+
 	/* Receive power offset */
 	u8 rx_pwr_offset; /* FIXME initial value? */
 
-- 
1.6.2.4




From netrolller.3d at gmail.com  Tue Aug 11 00:54:26 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Tue, 11 Aug 2009 00:54:26 +0200
Subject: [PATCH] b43: Fix a typo in the sync_stx routine
Message-ID: <4A80A522.2020200@gmail.com>

I completely missed the "one's complement" instruction from the specs.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 46fe476..34ad738 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -578,7 +578,7 @@ static void lpphy_sync_stx(struct b43_wldev *dev)
 		tmp >>= e->rf_shift;
 		tmp <<= e->phy_shift;
 		b43_phy_maskset(dev, B43_PHY_OFDM(0xF2 + e->phy_offset),
-				e->mask << e->phy_shift, tmp);
+				~(e->mask << e->phy_shift), tmp);
 	}
 }
 
-- 
1.6.2.4




From Larry.Finger at lwfinger.net  Tue Aug 11 01:14:29 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 10 Aug 2009 18:14:29 -0500
Subject: [PATCH] b43: Fix a typo in the sync_stx routine
In-Reply-To: <4A80A522.2020200@gmail.com>
References: <4A80A522.2020200@gmail.com>
Message-ID: <4A80A9D5.2060704@lwfinger.net>

G?bor Stefanik wrote:
> I completely missed the "one's complement" instruction from the specs.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> drivers/net/wireless/b43/phy_lp.c |    2 +-
> 1 files changed, 1 insertions(+), 1 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index 46fe476..34ad738 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -578,7 +578,7 @@ static void lpphy_sync_stx(struct b43_wldev *dev)
>         tmp >>= e->rf_shift;
>         tmp <<= e->phy_shift;
>         b43_phy_maskset(dev, B43_PHY_OFDM(0xF2 + e->phy_offset),
> -                e->mask << e->phy_shift, tmp);
> +                ~(e->mask << e->phy_shift), tmp);
>     }
> }
> 

I should have caught that one.

When debugging gets started, it might be useful to add a statement

      WARN_ON(mask & set);

at the start of b43_radio_maskset() and b43_phy_maskset(). That way
these kind of mistakes will be caught early.

Larry




From netrolller.3d at gmail.com  Tue Aug 11 14:15:26 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Tue, 11 Aug 2009 14:15:26 +0200
Subject: [PATCH RFC] b43: LP-PHY: Implement reading band SPROM
In-Reply-To: <4A80A120.30607@gmail.com>
References: <4A80A120.30607@gmail.com>
Message-ID: <69e28c910908110515k4e7d8078qe4fe1ae64844ab59@mail.gmail.com>

A few glitches I have noticed have been highlighted below; they will
be fixed in the for-checkin patch.

Nevertheless, the review request still stands.

2009/8/11 G?bor Stefanik <netrolller.3d at gmail.com>:
> Some of the new variables in b43_phy_lp appear to be dead code in
> the vendor driver; they will be removed if they remain unused when
> LP-PHY implementation is finished.
>
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> I've added a few FIXME comments, please review them.
> Also please check that I used the correct types (e.g. u16) for the new
> variables.
>
> Variable name mappings vs. the specification:
> cckpo = tmp3
> ofdmpo = tmp2
> maxpwr = tmp1
>
> The array txpwr_srom_max[3] has been broken up into 3 variables,
> each called max_tx_pwr_{low|med|hi}_band. A struct holding 3 named u16s
> may also be a good choice, but I am not fond of using an array for this.
>
> drivers/net/wireless/b43/phy_lp.c | ? 83
> ++++++++++++++++++++++++++++++++++++-
> drivers/net/wireless/b43/phy_lp.h | ? 16 +++++++
> 2 files changed, 98 insertions(+), 1 deletions(-)
>
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index 43272a8..46fe476 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -59,6 +59,87 @@ static void b43_lpphy_op_free(struct b43_wldev *dev)
> ? ? ? ?dev->phy.lp = NULL;
> }
>
> +static void lpphy_read_band_sprom(struct b43_wldev *dev)
> +{
> + ? ? ? struct b43_phy_lp *lpphy = dev->phy.lp;
> + ? ? ? struct ssb_bus *bus = dev->dev->bus;
> + ? ? ? u16 cckpo, maxpwr;
> + ? ? ? u32 ofdmpo;
> + ? ? ? int i;
> +
> + ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
> + ? ? ? ? ? ? ? lpphy->tx_isolation_med_band = bus->sprom.tri2g;
> + ? ? ? ? ? ? ? lpphy->bx_arch = bus->sprom.bxa2g;
> + ? ? ? ? ? ? ? lpphy->rssi_vf = bus->sprom.rssismf2g;
> + ? ? ? ? ? ? ? lpphy->rssi_vc = bus->sprom.rssismc2g;
> + ? ? ? ? ? ? ? lpphy->rssi_gs = bus->sprom.rssisav2g;
> + ? ? ? ? ? ? ? lpphy->txpa[0] = bus->sprom.pa0b0;
> + ? ? ? ? ? ? ? lpphy->txpa[1] = bus->sprom.pa0b1;
> + ? ? ? ? ? ? ? lpphy->txpa[2] = bus->sprom.pa0b2;
> + ? ? ? ? ? ? ? maxpwr = bus->sprom.maxpwr_bg;
> + ? ? ? ? ? ? ? lpphy->max_tx_pwr_med_band = maxpwr;
> + ? ? ? ? ? ? ? cckpo = bus->sprom.cck2gpo;
> + ? ? ? ? ? ? ? ofdmpo = bus->sprom.ofdm2gpo;
> + ? ? ? ? ? ? ? if (cckpo) {
> + ? ? ? ? ? ? ? ? ? ? ? for (i = 0; i < 4; i++) {
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? lpphy->tx_max_rate[i] =
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? maxpwr - (ofdmpo & 0xF) * 2;
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ofdmpo << 4;

This was meant to be ofdmpo <<= 4;

> + ? ? ? ? ? ? ? ? ? ? ? }
> + ? ? ? ? ? ? ? ? ? ? ? ofdmpo = bus->sprom.ofdm2gpo;
> + ? ? ? ? ? ? ? ? ? ? ? for (i = 4; i < 15; i++) {
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? lpphy->tx_max_rate[i] =
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? maxpwr - (ofdmpo & 0xF) * 2;
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ofdmpo << 4;

Same here.

> + ? ? ? ? ? ? ? ? ? ? ? }
> + ? ? ? ? ? ? ? } else {
> + ? ? ? ? ? ? ? ? ? ? ? ofdmpo &= 0xFF;
> + ? ? ? ? ? ? ? ? ? ? ? for (i = 0; i < 4; i++)
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? lpphy->tx_max_rate[i] = maxpwr;
> + ? ? ? ? ? ? ? ? ? ? ? for (i = 4; i < 15; i++)
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? lpphy->tx_max_rate[i] = maxpwr - ofdmpo;
> + ? ? ? ? ? ? ? }
> + ? ? ? } else { /* 5GHz */
> + ? ? ? ? ? ? ? lpphy->tx_isolation_low_band = bus->sprom.tri5gl;
> + ? ? ? ? ? ? ? lpphy->tx_isolation_med_band = bus->sprom.tri5g;
> + ? ? ? ? ? ? ? lpphy->tx_isolation_hi_band = bus->sprom.tri5gh;
> + ? ? ? ? ? ? ? lpphy->bx_arch = bus->sprom.bxa5g;
> + ? ? ? ? ? ? ? lpphy->rssi_vf = bus->sprom.rssismf5g;
> + ? ? ? ? ? ? ? lpphy->rssi_vc = bus->sprom.rssismc5g;
> + ? ? ? ? ? ? ? lpphy->rssi_gs = bus->sprom.rssisav5g;
> + ? ? ? ? ? ? ? lpphy->txpa[0] = bus->sprom.pa1b0;
> + ? ? ? ? ? ? ? lpphy->txpa[1] = bus->sprom.pa1b1;
> + ? ? ? ? ? ? ? lpphy->txpa[2] = bus->sprom.pa1b2;
> + ? ? ? ? ? ? ? lpphy->txpal[0] = bus->sprom.pa1lob0;
> + ? ? ? ? ? ? ? lpphy->txpal[1] = bus->sprom.pa1lob1;
> + ? ? ? ? ? ? ? lpphy->txpal[2] = bus->sprom.pa1lob2;
> + ? ? ? ? ? ? ? lpphy->txpah[0] = bus->sprom.pa1hib0;
> + ? ? ? ? ? ? ? lpphy->txpah[1] = bus->sprom.pa1hib1;
> + ? ? ? ? ? ? ? lpphy->txpah[2] = bus->sprom.pa1hib2;
> + ? ? ? ? ? ? ? maxpwr = bus->sprom.maxpwr_al;
> + ? ? ? ? ? ? ? ofdmpo = bus->sprom.ofdm5glpo;
> + ? ? ? ? ? ? ? lpphy->max_tx_pwr_low_band = maxpwr;
> + ? ? ? ? ? ? ? for (i = 4; i < 12; i++) {
> + ? ? ? ? ? ? ? ? ? ? ? lpphy->tx_max_ratel[i] = maxpwr - (ofdmpo & 0xF) *
> 2;
> + ? ? ? ? ? ? ? ? ? ? ? ofdmpo << 4;

Ditto.

> + ? ? ? ? ? ? ? }
> + ? ? ? ? ? ? ? maxpwr = bus->sprom.maxpwr_a;
> + ? ? ? ? ? ? ? ofdmpo = bus->sprom.ofdm5gpo;
> + ? ? ? ? ? ? ? lpphy->max_tx_pwr_med_band = maxpwr;
> + ? ? ? ? ? ? ? for (i = 4; i < 12; i++) {
> + ? ? ? ? ? ? ? ? ? ? ? lpphy->tx_max_rate[i] = maxpwr - (ofdmpo & 0xF) * 2;
> + ? ? ? ? ? ? ? ? ? ? ? ofdmpo << 4;

Ditto.

> + ? ? ? ? ? ? ? }
> + ? ? ? ? ? ? ? maxpwr = bus->sprom.maxpwr_ah;
> + ? ? ? ? ? ? ? ofdmpo = bus->sprom.ofdm5ghpo;
> + ? ? ? ? ? ? ? lpphy->max_tx_pwr_hi_band = maxpwr;
> + ? ? ? ? ? ? ? for (i = 4; i < 12; i++) {
> + ? ? ? ? ? ? ? ? ? ? ? lpphy->tx_max_rateh[i] = maxpwr - (ofdmpo & 0xF) *
> 2;
> + ? ? ? ? ? ? ? ? ? ? ? ofdmpo << 4;

Ditto.

> + ? ? ? ? ? ? ? }
> + ? ? ? }
> +}
> +
> static void lpphy_adjust_gain_table(struct b43_wldev *dev)
> {
> ? ? ? ?struct b43_phy_lp *lpphy = dev->phy.lp;
> @@ -694,7 +775,7 @@ static void lpphy_tx_pctl_init(struct b43_wldev *dev)
>
> static int b43_lpphy_op_init(struct b43_wldev *dev)
> {
> - ? ? ? /* TODO: band SPROM */
> + ? ? ? lpphy_read_band_sprom(dev); //FIXME should this be in
> prepare_structs?
> ? ? ? ?lpphy_baseband_init(dev);
> ? ? ? ?lpphy_radio_init(dev);
> ? ? ? ?//TODO calibrate RC
> diff --git a/drivers/net/wireless/b43/phy_lp.h
> b/drivers/net/wireless/b43/phy_lp.h
> index 13d89ea..9d0443c 100644
> --- a/drivers/net/wireless/b43/phy_lp.h
> +++ b/drivers/net/wireless/b43/phy_lp.h
> @@ -831,6 +831,22 @@ struct b43_phy_lp {
> ? ? ? ?/* Transmit isolation high band */
> ? ? ? ?u8 tx_isolation_hi_band; /* FIXME initial value? */
>
> + ? ? ? /* Max transmit power medium band */
> + ? ? ? u16 max_tx_pwr_med_band;
> + ? ? ? /* Max transmit power low band */
> + ? ? ? u16 max_tx_pwr_low_band;
> + ? ? ? /* Max transmit power high band */
> + ? ? ? u16 max_tx_pwr_hi_band;
> +
> + ? ? ? /* FIXME What are these used for? */
> + ? ? ? /* FIXME Is 15 the correct array size? */
> + ? ? ? u16 tx_sprom_max_rate[15];
> + ? ? ? u16 tx_sprom_max_ratel[15];
> + ? ? ? u16 tx_sprom_max_rateh[15];
> +
> + ? ? ? /* Transmit power arrays */
> + ? ? ? s16 txpa[3], txpal[3], txpah[3];
> +
> ? ? ? ?/* Receive power offset */
> ? ? ? ?u8 rx_pwr_offset; /* FIXME initial value? */
>
> --
> 1.6.2.4
>
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Tue Aug 11 21:47:00 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Tue, 11 Aug 2009 21:47:00 +0200
Subject: [PATCH] b43: LP-PHY: Implement reading band SPROM
Message-ID: <4A81CAB4.1090002@gmail.com>

Some of the new variables in b43_phy_lp appear to be dead code in
the vendor driver; they will be removed if they remain unused when
LP-PHY implementation is finished.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Changes from RFC:
-Fixed << vs. >>= confusion.
-Read RX power offset which I missed in the RFC.
-Corrected the names of the tx_max_rate vars in b43_phy_lp.

 phy_lp.c |   85 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 phy_lp.h |   16 +++++++++++
 2 files changed, 100 insertions(+), 1 deletion(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 43272a8..c40b8a0 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -59,6 +59,89 @@ static void b43_lpphy_op_free(struct b43_wldev *dev)
 	dev->phy.lp = NULL;
 }
 
+static void lpphy_read_band_sprom(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct ssb_bus *bus = dev->dev->bus;
+	u16 cckpo, maxpwr;
+	u32 ofdmpo;
+	int i;
+
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		lpphy->tx_isolation_med_band = bus->sprom.tri2g;
+		lpphy->bx_arch = bus->sprom.bxa2g;
+		lpphy->rx_pwr_offset = bus->sprom.rxpo2g;
+		lpphy->rssi_vf = bus->sprom.rssismf2g;
+		lpphy->rssi_vc = bus->sprom.rssismc2g;
+		lpphy->rssi_gs = bus->sprom.rssisav2g;
+		lpphy->txpa[0] = bus->sprom.pa0b0;
+		lpphy->txpa[1] = bus->sprom.pa0b1;
+		lpphy->txpa[2] = bus->sprom.pa0b2;
+		maxpwr = bus->sprom.maxpwr_bg;
+		lpphy->max_tx_pwr_med_band = maxpwr;
+		cckpo = bus->sprom.cck2gpo;
+		ofdmpo = bus->sprom.ofdm2gpo;
+		if (cckpo) {
+			for (i = 0; i < 4; i++) {
+				lpphy->tx_max_rate[i] =
+					maxpwr - (ofdmpo & 0xF) * 2;
+				ofdmpo >>= 4;
+			}
+			ofdmpo = bus->sprom.ofdm2gpo;
+			for (i = 4; i < 15; i++) {
+				lpphy->tx_max_rate[i] =
+					maxpwr - (ofdmpo & 0xF) * 2;
+				ofdmpo >>= 4;
+			}
+		} else {
+			ofdmpo &= 0xFF;
+			for (i = 0; i < 4; i++)
+				lpphy->tx_max_rate[i] = maxpwr;
+			for (i = 4; i < 15; i++)
+				lpphy->tx_max_rate[i] = maxpwr - ofdmpo;
+		}
+	} else { /* 5GHz */
+		lpphy->tx_isolation_low_band = bus->sprom.tri5gl;
+		lpphy->tx_isolation_med_band = bus->sprom.tri5g;
+		lpphy->tx_isolation_hi_band = bus->sprom.tri5gh;
+		lpphy->bx_arch = bus->sprom.bxa5g;
+		lpphy->rx_pwr_offset = bus->sprom.rxpo5g;
+		lpphy->rssi_vf = bus->sprom.rssismf5g;
+		lpphy->rssi_vc = bus->sprom.rssismc5g;
+		lpphy->rssi_gs = bus->sprom.rssisav5g;
+		lpphy->txpa[0] = bus->sprom.pa1b0;
+		lpphy->txpa[1] = bus->sprom.pa1b1;
+		lpphy->txpa[2] = bus->sprom.pa1b2;
+		lpphy->txpal[0] = bus->sprom.pa1lob0;
+		lpphy->txpal[1] = bus->sprom.pa1lob1;
+		lpphy->txpal[2] = bus->sprom.pa1lob2;
+		lpphy->txpah[0] = bus->sprom.pa1hib0;
+		lpphy->txpah[1] = bus->sprom.pa1hib1;
+		lpphy->txpah[2] = bus->sprom.pa1hib2;
+		maxpwr = bus->sprom.maxpwr_al;
+		ofdmpo = bus->sprom.ofdm5glpo;
+		lpphy->max_tx_pwr_low_band = maxpwr;
+		for (i = 4; i < 12; i++) {
+			lpphy->tx_max_ratel[i] = maxpwr - (ofdmpo & 0xF) * 2;
+			ofdmpo >>= 4;
+		}
+		maxpwr = bus->sprom.maxpwr_a;
+		ofdmpo = bus->sprom.ofdm5gpo;
+		lpphy->max_tx_pwr_med_band = maxpwr;
+		for (i = 4; i < 12; i++) {
+			lpphy->tx_max_rate[i] = maxpwr - (ofdmpo & 0xF) * 2;
+			ofdmpo >>= 4;
+		}
+		maxpwr = bus->sprom.maxpwr_ah;
+		ofdmpo = bus->sprom.ofdm5ghpo;
+		lpphy->max_tx_pwr_hi_band = maxpwr;
+		for (i = 4; i < 12; i++) {
+			lpphy->tx_max_rateh[i] = maxpwr - (ofdmpo & 0xF) * 2;
+			ofdmpo >>= 4;
+		}
+	}
+}
+
 static void lpphy_adjust_gain_table(struct b43_wldev *dev)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
@@ -694,7 +777,7 @@ static void lpphy_tx_pctl_init(struct b43_wldev *dev)
 
 static int b43_lpphy_op_init(struct b43_wldev *dev)
 {
-	/* TODO: band SPROM */
+	lpphy_read_band_sprom(dev); //FIXME should this be in prepare_structs?
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
 	//TODO calibrate RC
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 13d89ea..0461d5b 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -831,6 +831,22 @@ struct b43_phy_lp {
 	/* Transmit isolation high band */
 	u8 tx_isolation_hi_band; /* FIXME initial value? */
 
+	/* Max transmit power medium band */
+	u16 max_tx_pwr_med_band;
+	/* Max transmit power low band */
+	u16 max_tx_pwr_low_band;
+	/* Max transmit power high band */
+	u16 max_tx_pwr_hi_band;
+
+	/* FIXME What are these used for? */
+	/* FIXME Is 15 the correct array size? */
+	u16 tx_max_rate[15];
+	u16 tx_max_ratel[15];
+	u16 tx_max_rateh[15];
+
+	/* Transmit power arrays */
+	s16 txpa[3], txpal[3], txpah[3];
+
 	/* Receive power offset */
 	u8 rx_pwr_offset; /* FIXME initial value? */
 
-- 
1.6.2.4




From netrolller.3d at gmail.com  Tue Aug 11 21:53:06 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Tue, 11 Aug 2009 21:53:06 +0200
Subject: [PATCH] b43: Implement RC calibration for rev.2+ LP PHYs
Message-ID: <4A81CC22.9010208@gmail.com>

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Larry,
Rev0/1 RC calibration is missing because the spec needs clarification
(lots of cryptic variable names, a struct that is never defined, etc.),
hence the SPEC FIXME.

 drivers/net/wireless/b43/phy_lp.c |   86 ++++++++++++++++++++++++++++++++++++-
 1 files changed, 85 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 1b4f63a..689c932 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -605,6 +605,90 @@ static void lpphy_radio_init(struct b43_wldev *dev)
 	}
 }
 
+static void lpphy_set_rc_cap(struct b43_wldev *dev)
+{
+	u8 rc_cap = dev->phy.lp->rc_cap;
+
+	b43_radio_write(dev, B2062_N_RXBB_CALIB2, max_t(u8, rc_cap-4, 0x80));
+	b43_radio_write(dev, B2062_N_TX_CTL_A, ((rc_cap & 0x1F) >> 1) | 0x80);
+	b43_radio_write(dev, B2062_S_RXG_CNT16, ((rc_cap & 0x1F) >> 2) | 0x80);
+}
+
+static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
+{
+	//TODO and SPEC FIXME
+}
+
+static void lpphy_rev2plus_rc_calib(struct b43_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
+	u8 tmp = b43_radio_read(dev, B2063_RX_BB_SP8) & 0xFF;
+	int i;
+
+	b43_radio_write(dev, B2063_RX_BB_SP8, 0x0);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
+	b43_radio_mask(dev, B2063_PLL_SP1, 0xF7);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x15);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x70);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x52);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7D);
+
+	for (i = 0; i < 10000; i++) {
+		if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
+			break;
+		msleep(1);
+	}
+
+	if (!(b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2))
+		b43_radio_write(dev, B2063_RX_BB_SP8, tmp);
+
+	tmp = b43_radio_read(dev, B2063_TX_BB_SP3) & 0xFF;
+
+	b43_radio_write(dev, B2063_TX_BB_SP3, 0x0);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x55);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x76);
+
+	if (crystal_freq == 24000000) {
+		b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0xFC);
+		b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x0);
+	} else {
+		b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x13);
+		b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
+	}
+
+	b43_radio_write(dev, B2063_PA_SP7, 0x7D);
+
+	for (i = 0; i < 10000; i++) {
+		if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
+			break;
+		msleep(1);
+	}
+
+	if (!(b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2))
+		b43_radio_write(dev, B2063_TX_BB_SP3, tmp);
+
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
+}
+
+static void lpphy_calibrate_rc(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+
+	if (dev->phy.rev >= 2) {
+		lpphy_rev2plus_rc_calib(dev);
+	} else if (!lpphy->rc_cap) {
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+			lpphy_rev0_1_rc_calib(dev);
+	} else {
+		lpphy_set_rc_cap(dev);
+	}
+}
+
 /* Read the TX power control mode from hardware. */
 static void lpphy_read_tx_pctl_mode_from_hardware(struct b43_wldev *dev)
 {
@@ -780,7 +864,7 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
 	lpphy_read_band_sprom(dev); //FIXME should this be in prepare_structs?
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
-	//TODO calibrate RC
+	lpphy_calibrate_rc(dev);
 	//TODO set channel
 	lpphy_tx_pctl_init(dev);
 	lpphy_calibration(dev);
-- 
1.6.2.4




From netrolller.3d at gmail.com  Tue Aug 11 22:24:22 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Tue, 11 Aug 2009 22:24:22 +0200
Subject: [PATCH] b43: LP-PHY: Refactor TX gain table I/O
Message-ID: <4A81D376.5020405@gmail.com>

Make it possible to write individual gain table entries.
Allow gain table entries to be written outside gain table init.
Add version-agnostic helpers for writing gain tables.
Use the new TX gain table helpers during table init.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/tables_lpphy.c |   85 +++++++++++++++++--------------
 drivers/net/wireless/b43/tables_lpphy.h |    9 +++
 2 files changed, 55 insertions(+), 39 deletions(-)

diff --git a/drivers/net/wireless/b43/tables_lpphy.c b/drivers/net/wireless/b43/tables_lpphy.c
index 3507515..5fdb175 100644
--- a/drivers/net/wireless/b43/tables_lpphy.c
+++ b/drivers/net/wireless/b43/tables_lpphy.c
@@ -1058,10 +1058,6 @@ static const u32 lpphy_papd_mult_table[] = {
 	0x00036963, 0x000339f2, 0x00030a89, 0x0002db28,
 };
 
-struct lpphy_tx_gain_table_entry {
-	u8 gm,  pga,  pad,  dac,  bb_mult;
-};
-
 static struct lpphy_tx_gain_table_entry lpphy_rev0_nopa_tx_gain_table[] = {
 	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 152, },
 	{ .gm = 7, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 147, },
@@ -2345,44 +2341,55 @@ void lpphy_rev2plus_table_init(struct b43_wldev *dev)
 	}
 }
 
-
-static void lpphy_rev0_1_write_gain_table(struct b43_wldev *dev,
-				struct lpphy_tx_gain_table_entry *table)
+static void lpphy_rev0_1_write_gain_table(struct b43_wldev *dev, int offset,
+				struct lpphy_tx_gain_table_entry data)
 {
-	int i;
 	u32 tmp;
 
 	B43_WARN_ON(dev->phy.rev >= 2);
 
-	for (i = 0; i < 128; i++) {
-		tmp  = table[i].pad << 11;
-		tmp |= table[i].pga << 7;
-		tmp |= table[i].gm  << 4;
-		tmp |= table[i].dac;
-		b43_lptab_write(dev, B43_LPTAB32(10, 0xC0 + i), tmp);
-		tmp  = table[i].bb_mult << 20;
-		b43_lptab_write(dev, B43_LPTAB32(10, 0x140 + i), tmp);
-	}
+	tmp  = data.pad << 11;
+	tmp |= data.pga << 7;
+	tmp |= data.gm  << 4;
+	tmp |= data.dac;
+	b43_lptab_write(dev, B43_LPTAB32(10, 0xC0 + offset), tmp);
+	tmp  = data.bb_mult << 20;
+	b43_lptab_write(dev, B43_LPTAB32(10, 0x140 + offset), tmp);
 }
 
-static void lpphy_rev2plus_write_gain_table(struct b43_wldev *dev,
-				struct lpphy_tx_gain_table_entry *table)
+static void lpphy_rev2plus_write_gain_table(struct b43_wldev *dev, int offset,
+				struct lpphy_tx_gain_table_entry data)
 {
-	int i;
 	u32 tmp;
 
 	B43_WARN_ON(dev->phy.rev < 2);
 
-	for (i = 0; i < 128; i++) {
-		tmp  = table[i].pad << 16;
-		tmp |= table[i].pga << 8;
-		tmp |= table[i].gm;
-		tmp |= 0x7f000000;
-		b43_lptab_write(dev, B43_LPTAB32(7, 0xC0 + i), tmp);
-		tmp  = table[i].bb_mult << 20;
-		tmp |= table[i].dac << 28;
-		b43_lptab_write(dev, B43_LPTAB32(7, 0x140 + i), tmp);
-	}
+	tmp  = data.pad << 16;
+	tmp |= data.pga << 8;
+	tmp |= data.gm;
+	tmp |= 0x7f000000;
+	b43_lptab_write(dev, B43_LPTAB32(7, 0xC0 + offset), tmp);
+	tmp  = data.bb_mult << 20;
+	tmp |= data.dac << 28;
+	b43_lptab_write(dev, B43_LPTAB32(7, 0x140 + offset), tmp);
+}
+
+void lpphy_write_gain_table(struct b43_wldev *dev, int offset,
+			    struct lpphy_tx_gain_table_entry data)
+{
+	if (dev->phy.rev >= 2)
+		lpphy_rev2plus_write_gain_table(dev, offset, data);
+	else
+		lpphy_rev0_1_write_gain_table(dev, offset, data);
+}
+
+void lpphy_write_gain_table_bulk(struct b43_wldev *dev, int offset, int count,
+				 struct lpphy_tx_gain_table_entry *table)
+{
+	int i;
+
+	for (i = offset; i < count; i++)
+		lpphy_write_gain_table(dev, i, table[i]);
 }
 
 void lpphy_init_tx_gain_table(struct b43_wldev *dev)
@@ -2393,36 +2400,36 @@ void lpphy_init_tx_gain_table(struct b43_wldev *dev)
 	case 0:
 		if ((bus->sprom.boardflags_hi & B43_BFH_NOPA) ||
 		    (bus->sprom.boardflags_lo & B43_BFL_HGPA))
-			lpphy_rev0_1_write_gain_table(dev,
+			lpphy_write_gain_table_bulk(dev, 0, 128,
 					lpphy_rev0_nopa_tx_gain_table);
 		else if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
-			lpphy_rev0_1_write_gain_table(dev,
+			lpphy_write_gain_table_bulk(dev, 0, 128,
 					lpphy_rev0_2ghz_tx_gain_table);
 		else
-			lpphy_rev0_1_write_gain_table(dev,
+			lpphy_write_gain_table_bulk(dev, 0, 128,
 					lpphy_rev0_5ghz_tx_gain_table);
 		break;
 	case 1:
 		if ((bus->sprom.boardflags_hi & B43_BFH_NOPA) ||
 		    (bus->sprom.boardflags_lo & B43_BFL_HGPA))
-			lpphy_rev0_1_write_gain_table(dev,
+			lpphy_write_gain_table_bulk(dev, 0, 128,
 					lpphy_rev1_nopa_tx_gain_table);
 		else if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
-			lpphy_rev0_1_write_gain_table(dev,
+			lpphy_write_gain_table_bulk(dev, 0, 128,
 					lpphy_rev1_2ghz_tx_gain_table);
 		else
-			lpphy_rev0_1_write_gain_table(dev,
+			lpphy_write_gain_table_bulk(dev, 0, 128,
 					lpphy_rev1_5ghz_tx_gain_table);
 		break;
 	default:
 		if (bus->sprom.boardflags_hi & B43_BFH_NOPA)
-			lpphy_rev2plus_write_gain_table(dev,
+			lpphy_write_gain_table_bulk(dev, 0, 128,
 					lpphy_rev2_nopa_tx_gain_table);
 		else if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
-			lpphy_rev2plus_write_gain_table(dev,
+			lpphy_write_gain_table_bulk(dev, 0, 128,
 					lpphy_rev2_2ghz_tx_gain_table);
 		else
-			lpphy_rev2plus_write_gain_table(dev,
+			lpphy_write_gain_table_bulk(dev, 0, 128,
 					lpphy_rev2_5ghz_tx_gain_table);
 	}
 }
diff --git a/drivers/net/wireless/b43/tables_lpphy.h b/drivers/net/wireless/b43/tables_lpphy.h
index b5024b6..84f1d26 100644
--- a/drivers/net/wireless/b43/tables_lpphy.h
+++ b/drivers/net/wireless/b43/tables_lpphy.h
@@ -28,6 +28,15 @@ void b43_lptab_write_bulk(struct b43_wldev *dev, u32 offset,
 void b2062_upload_init_table(struct b43_wldev *dev);
 void b2063_upload_init_table(struct b43_wldev *dev);
 
+struct lpphy_tx_gain_table_entry {
+	u8 gm,  pga,  pad,  dac,  bb_mult;
+};
+
+void lpphy_write_gain_table(struct b43_wldev *dev, int offset,
+			    struct lpphy_tx_gain_table_entry data);
+void lpphy_write_gain_table_bulk(struct b43_wldev *dev, int offset, int count,
+				 struct lpphy_tx_gain_table_entry *table);
+
 void lpphy_rev0_1_table_init(struct b43_wldev *dev);
 void lpphy_rev2plus_table_init(struct b43_wldev *dev);
 void lpphy_init_tx_gain_table(struct b43_wldev *dev);
-- 
1.6.2.4





From netrolller.3d at gmail.com  Tue Aug 11 23:03:13 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Tue, 11 Aug 2009 23:03:13 +0200
Subject: [RFC] b43: LP-PHY: Initialize SW TX power control
Message-ID: <4A81DC91.8020208@gmail.com>

I'm not sure at all if writing to offset 0 in the TX gain table
is the right thing to do... please clarify.

Not-yet-signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

---
If this is indeed the right thing to do, please inform me,
and I will resubmit this as a formal patch.

 phy_lp.c |   16 ++++++++++++----
 1 file changed, 12 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 689c932..93451c9 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -847,15 +847,23 @@ static void lpphy_calibration(struct b43_wldev *dev)
 /* Initialize TX power control */
 static void lpphy_tx_pctl_init(struct b43_wldev *dev)
 {
+	lpphy_tx_gain_table_entry txgain;
 	if (0/*FIXME HWPCTL capable */) {
 		//TODO
 	} else { /* This device is only software TX power control capable. */
+		txgain.bb_mult = 0x96;
 		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
-			//TODO
+			txgain.gm = 4;
+			txgain.pad = 12;
+			txgain.pga = 12;
+			txgain.dac = 0;
 		} else {
-			//TODO
-		}
-		//TODO set BB multiplier to 0x0096
+			txgain.gm = 7;
+			txgain.pad = 15;
+			txgain.pga = 14;
+			txgain.dac = 0;
+		} // FIXME offset 0 is just a guess!
+		lpphy_write_gain_table(dev, 0, txgain);
 	}
 }
 




From Larry.Finger at lwfinger.net  Wed Aug 12 03:41:18 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 11 Aug 2009 20:41:18 -0500
Subject: [RFC] b43: LP-PHY: Initialize SW TX power control
In-Reply-To: <4A81DC91.8020208@gmail.com>
References: <4A81DC91.8020208@gmail.com>
Message-ID: <4A821DBE.2020508@lwfinger.net>

G?bor Stefanik wrote:
> I'm not sure at all if writing to offset 0 in the TX gain table
> is the right thing to do... please clarify.
> 
> Not-yet-signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> 
> ---
> If this is indeed the right thing to do, please inform me,
> and I will resubmit this as a formal patch.
> 
> phy_lp.c |   16 ++++++++++++----
> 1 file changed, 12 insertions(+), 4 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index 689c932..93451c9 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -847,15 +847,23 @@ static void lpphy_calibration(struct b43_wldev *dev)
> /* Initialize TX power control */
> static void lpphy_tx_pctl_init(struct b43_wldev *dev)
> {
> +    lpphy_tx_gain_table_entry txgain;
>     if (0/*FIXME HWPCTL capable */) {
>         //TODO
>     } else { /* This device is only software TX power control capable. */
> +        txgain.bb_mult = 0x96;
>         if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
> -            //TODO
> +            txgain.gm = 4;
> +            txgain.pad = 12;
> +            txgain.pga = 12;
> +            txgain.dac = 0;
>         } else {
> -            //TODO
> -        }
> -        //TODO set BB multiplier to 0x0096
> +            txgain.gm = 7;
> +            txgain.pad = 15;
> +            txgain.pga = 14;

I found a typo in the specs today. The pad should be 14 and pga should
be 15.

> +            txgain.dac = 0;
> +        } // FIXME offset 0 is just a guess!
> +        lpphy_write_gain_table(dev, 0, txgain);

The link was wrong in the page. The correct routine is
http://bcm-v4.sipsolutions.net/802.11/PHY/LP/SetTXGain. It has one
argument &txgain. I don't think this one has been written yet.

Larry


From netrolller.3d at gmail.com  Wed Aug 12 19:56:25 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Wed, 12 Aug 2009 19:56:25 +0200
Subject: [PATCH] b43: Implement RC calibration for rev.0/1 LP-PHYs
Message-ID: <4A830249.1010005@gmail.com>

Also implement get/set BB mult, get/set TX gain, set RX gain,
disable/restore CRS, run/stop DDFS, RX IQ est and QDIV roundup
in the process.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Larry, please review the "SPEC FIXME" comments!

 drivers/net/wireless/b43/phy_lp.c |  414 ++++++++++++++++++++++++++++++++++++-
 1 files changed, 413 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 689c932..b283b58 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -605,6 +605,8 @@ static void lpphy_radio_init(struct b43_wldev *dev)
 	}
 }
 
+struct lpphy_iq_est { u32 iq_prod, i_pwr, q_pwr; };
+
 static void lpphy_set_rc_cap(struct b43_wldev *dev)
 {
 	u8 rc_cap = dev->phy.lp->rc_cap;
@@ -614,9 +616,419 @@ static void lpphy_set_rc_cap(struct b43_wldev *dev)
 	b43_radio_write(dev, B2062_S_RXG_CNT16, ((rc_cap & 0x1F) >> 2) | 0x80);
 }
 
+static u8 lpphy_get_bb_mult(struct b43_wldev *dev)
+{
+	return (b43_lptab_read(dev, B43_LPTAB16(0, 87)) & 0xFF00) >> 8;
+}
+
+static void lpphy_set_bb_mult(struct b43_wldev *dev, u8 bb_mult)
+{
+	b43_lptab_write(dev, B43_LPTAB16(0, 87), (u16)bb_mult << 8);
+}
+
+static void lpphy_disable_crs(struct b43_wldev *dev)
+{
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x80);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x1);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x4);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFF7);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x10);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFDF);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x20);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFBF);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x7);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x38);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFF3F);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x100);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFDFF);
+	b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL0, 0);
+	b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL1, 1);
+	b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL2, 0x20);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFBFF);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xF7FF);
+	b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL, 0);
+	b43_phy_write(dev, B43_LPPHY_RX_GAIN_CTL_OVERRIDE_VAL, 0x45AF);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0x3FF);
+}
+
+static void lpphy_restore_crs(struct b43_wldev *dev)
+{
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x60);
+	else
+		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x20);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFF80);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFC00);
+}
+
+struct lpphy_tx_gains { u16 gm, pga, pad, dac; };
+
+static struct lpphy_tx_gains lpphy_get_tx_gains(struct b43_wldev *dev)
+{
+	struct lpphy_tx_gains gains;
+	u16 tmp;
+
+	gains.dac = (b43_phy_read(dev, B43_LPPHY_AFE_DAC_CTL) & 0x380) >> 7;
+	if (dev->phy.rev < 2) {
+		tmp = b43_phy_read(dev,
+				   B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL) & 0x7FF;
+		gains.gm = tmp & 0x0007;
+		gains.pga = (tmp & 0x0078) >> 3;
+		gains.pad = (tmp & 0x780) >> 7;
+	} else {
+		tmp = b43_phy_read(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL);
+		gains.pad = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0xFF;
+		gains.gm = tmp & 0xFF;
+		gains.pga = (tmp>>8) & 0xFF;
+	}
+
+	return gains;
+}
+
+static void lpphy_set_dac_gain(struct b43_wldev *dev, u16 dac)
+{
+	u16 ctl = b43_phy_read(dev, B43_LPPHY_AFE_DAC_CTL) & 0xC7F;
+	ctl |= dac << 7;
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DAC_CTL, 0xF000, ctl);
+}
+
+static void lpphy_set_tx_gains(struct b43_wldev *dev,
+			       struct lpphy_tx_gains gains)
+{
+	u16 rf_gain, pa_gain;
+
+	if (dev->phy.rev < 2) {
+		rf_gain = (gains.pad << 7) | (gains.pga << 3) | gains.gm;
+		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+				0xF800, rf_gain);
+	} else {
+		pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x7F00;
+		b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+			      (gains.pga << 8) | gains.gm);
+		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+				0x8000, gains.pad | pa_gain);
+		b43_phy_write(dev, B43_PHY_OFDM(0xFC),
+			      (gains.pga << 8) | gains.gm);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0xFD),
+				0x8000, gains.pad | pa_gain);
+	}
+	lpphy_set_dac_gain(dev, gains.dac);
+	if (dev->phy.rev < 2) {
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF, 1<<8);
+	} else {
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1<<7);
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1<<14);
+	}
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFBF, 1<<4);
+}
+
+static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
+{
+	u16 trsw = gain & 0x1;
+	u16 lna = (gain & 0xFFFC) | ((gain & 0xC) >> 2);
+	u16 ext_lna = (gain & 2) >> 1;
+
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFE, trsw);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFBFF, ext_lna<<10);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xF7FF, ext_lna<<11);
+	b43_phy_write(dev, B43_LPPHY_RX_GAIN_CTL_OVERRIDE_VAL, lna);
+}
+
+static void lpphy_rev2plus_set_rx_gain(struct b43_wldev *dev, u32 gain)
+{
+	u16 low_gain = gain & 0xFFFF;
+	u16 high_gain = (gain >> 16) & 0xF;
+	u16 ext_lna = (gain >> 21) & 0x1;
+	u16 trsw = ~(gain >> 21) & 0x1;
+	u16 tmp;
+	//SPEC FIXME is trsw really just ~(bool)ext_lna for rev2+?
+
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFE, trsw);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFDFF, ext_lna<<9);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFBFF, ext_lna<<10);
+	b43_phy_write(dev, B43_LPPHY_RX_GAIN_CTL_OVERRIDE_VAL, low_gain);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFFF0, high_gain);
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		tmp = (gain >> 2) & 0x3;
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL,
+				0xE7FF, tmp<<11);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0xE6), 0xFFE7, tmp<<3);
+	}
+}
+
+static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
+{
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
+	if (dev->phy.rev >= 2) {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
+		if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
+			return;
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFF7);
+	} else {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
+	}
+}
+
+static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
+{
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
+	if (dev->phy.rev >= 2) {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
+		if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
+			return;
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x8);
+	} else {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
+	}
+}
+
+static void lpphy_set_rx_gain(struct b43_wldev *dev, u32 gain)
+{
+	if (dev->phy.rev < 2)
+		lpphy_rev0_1_set_rx_gain(dev, gain);
+	else
+		lpphy_rev2plus_set_rx_gain(dev, gain);
+	lpphy_enable_rx_gain_override(dev);
+}
+
+static void lpphy_set_rx_gain_by_index(struct b43_wldev *dev, u16 idx)
+{
+	u32 gain = b43_lptab_read(dev, B43_LPTAB16(12, idx));
+	lpphy_set_rx_gain(dev, gain);
+}
+
+static void lpphy_stop_ddfs(struct b43_wldev *dev)
+{
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS, 0xFFFD);
+	b43_phy_mask(dev, B43_LPPHY_LP_PHY_CTL, 0xFFDF);
+}
+
+static void lpphy_run_ddfs(struct b43_wldev *dev, int i_on, int q_on,
+			   int incr1, int incr2, int scale_idx)
+{
+	lpphy_stop_ddfs(dev);
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS_POINTER_INIT, 0xFF80);
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS_POINTER_INIT, 0x80FF);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS_INCR_INIT, 0xFF80, incr1);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS_INCR_INIT, 0x80FF, incr2 << 3);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFFF7, i_on << 3);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFFEF, q_on << 4);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFF9F, scale_idx << 5);
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS, 0xFFFB);
+	b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x2);
+	b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x20);
+}
+
+static bool lpphy_rx_iq_est(struct b43_wldev *dev, u16 samples, u8 time,
+			   struct lpphy_iq_est *iq_est)
+{
+	int i;
+
+	b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFF7);
+	b43_phy_write(dev, B43_LPPHY_IQ_NUM_SMPLS_ADDR, samples);
+	b43_phy_maskset(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFF00, time);
+	b43_phy_mask(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFEFF);
+	b43_phy_set(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFDFF);
+
+	for (i = 0; i < 500; i++) {
+		if (!(b43_phy_read(dev,
+				B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR) & 0x200))
+			break;
+		msleep(1);
+	}
+
+	if ((b43_phy_read(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR) & 0x200)) {
+		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x8);
+		return false;
+	}
+
+	iq_est->iq_prod = b43_phy_read(dev, B43_LPPHY_IQ_ACC_HI_ADDR);
+	iq_est->iq_prod <<= 16;
+	iq_est->iq_prod |= b43_phy_read(dev, B43_LPPHY_IQ_ACC_LO_ADDR);
+
+	iq_est->i_pwr = b43_phy_read(dev, B43_LPPHY_IQ_I_PWR_ACC_HI_ADDR);
+	iq_est->i_pwr <<= 16;
+	iq_est->i_pwr |= b43_phy_read(dev, B43_LPPHY_IQ_I_PWR_ACC_LO_ADDR);
+
+	iq_est->q_pwr = b43_phy_read(dev, B43_LPPHY_IQ_Q_PWR_ACC_HI_ADDR);
+	iq_est->q_pwr <<= 16;
+	iq_est->q_pwr |= b43_phy_read(dev, B43_LPPHY_IQ_Q_PWR_ACC_LO_ADDR);
+
+	b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x8);
+	return true;
+}
+
+static int lpphy_loopback(struct b43_wldev *dev)
+{
+	struct lpphy_iq_est iq_est;
+	int i, index = -1;
+	u32 tmp;
+
+	memset(&iq_est, 0, sizeof(iq_est));
+
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x3);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFFE);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x800);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x800);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x8);
+	b43_radio_write(dev, B2062_N_TX_CTL_A, 0x80);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x80);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x80);
+	for (i = 0; i < 32; i++) {
+		lpphy_set_rx_gain_by_index(dev, i);
+		lpphy_run_ddfs(dev, 1, 1, 5, 5, 0);
+		if (!(lpphy_rx_iq_est(dev, 1000, 32, &iq_est)))
+			continue;
+		tmp = (iq_est.i_pwr + iq_est.q_pwr) / 1000;
+		if ((tmp > 4000) && (tmp < 10000)) {
+			index = i;
+			break;
+		}
+	}
+	lpphy_stop_ddfs(dev);
+	return index;
+}
+
+u32 lpphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
+{
+	u32 quotient, remainder, rbit, roundup, tmp;
+
+	if (divisor == 0) {
+		quotient = 0;
+		remainder = 0;
+	} else {
+		quotient = dividend / divisor;
+		remainder = dividend % divisor;
+	}
+
+	rbit = divisor & 0x1;
+	roundup = (divisor >> 1) + rbit;
+	precision--;
+
+	while (precision != 0xFF) {
+		tmp = remainder - roundup;
+		quotient <<= 1;
+		remainder <<= 1;
+		if (remainder >= roundup) {
+			remainder = (tmp << 1) + rbit;
+			quotient--;
+		}
+		precision--;
+	}
+
+	if (remainder >= roundup)
+		quotient++;
+
+	return quotient;
+}
+
+static void lpphy_set_tx_power_control(struct b43_wldev *dev,
+				       enum b43_lpphy_txpctl_mode mode);
+
 static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 {
-	//TODO and SPEC FIXME
+	u32 ideal_pwr_table[22] = {
+		0x10000, 0x10557, 0x10e2d, 0x113e0, 0x10f22, 0x0ff64,
+		0x0eda2, 0x0e5d4, 0x0efd1, 0x0fbe8, 0x0b7b8, 0x04b35,
+		0x01a5e, 0x00a0b, 0x00444, 0x001fd, 0x000ff, 0x00088,
+		0x0004c, 0x0002c, 0x0001a, 0xc0006,
+	};
+	bool old_txg_ovr;
+	u16 old_rf_ovr, old_rf_ovrval, old_afe_ovr, old_afe_ovrval,
+	    old_rf2_ovr, old_rf2_ovrval, old_phy_ctl, old_txpctl;
+	u8 old_bbmult;
+	struct lpphy_iq_est iq_est;
+	struct lpphy_tx_gains tx_gains;
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	int loopback, i, j, inner_sum;
+	u32 normal_pwr, ideal_pwr, mean_sq_pwr, tmp = 0, mean_sq_pwr_min = 0;
+
+	memset(&iq_est, 0, sizeof(iq_est));
+
+	b43_switch_channel(dev, 7);
+	old_txg_ovr = (b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) >> 6) & 1;
+	old_bbmult = lpphy_get_bb_mult(dev);
+	if (old_txg_ovr)
+		tx_gains = lpphy_get_tx_gains(dev);
+	old_rf_ovr = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_0);
+	old_rf_ovrval = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_VAL_0);
+	old_afe_ovr = b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR);
+	old_afe_ovrval = b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVRVAL);
+	old_rf2_ovr = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2);
+	old_rf2_ovrval = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2_VAL);
+	old_phy_ctl = b43_phy_read(dev, B43_LPPHY_LP_PHY_CTL);
+	old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
+					B43_LPPHY_TX_PWR_CTL_CMD_MODE;
+ 
+ 	lpphy_set_tx_power_control(dev, B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
+	lpphy_disable_crs(dev);
+	loopback = lpphy_loopback(dev);
+	if (loopback == -1)
+		goto finish;
+	lpphy_set_rx_gain_by_index(dev, loopback);
+	b43_phy_maskset(dev, B43_LPPHY_LP_PHY_CTL, 0xFFBF, 0x40);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFFF8, 0x1);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFFC7, 0x8);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFF3F, 0xC0);
+	for (i = 128; i <= 159; i++) {
+		b43_radio_write(dev, B2062_N_RXBB_CALIB2, i);
+  		inner_sum = 0;
+		for (j = 5; j <= 25; j++) {
+			lpphy_run_ddfs(dev, 1, 1, j, j, 0);
+			if (!(lpphy_rx_iq_est(dev, 1000, 32, &iq_est)))
+				goto finish;
+			mean_sq_pwr = iq_est.i_pwr + iq_est.q_pwr;
+			if (j == 5)
+				tmp = mean_sq_pwr;
+			ideal_pwr = ((ideal_pwr_table[j-5] >> 3) + 1) >> 1;
+			normal_pwr = lpphy_qdiv_roundup(mean_sq_pwr, tmp, 12);
+			mean_sq_pwr = ideal_pwr - normal_pwr;
+			mean_sq_pwr *= mean_sq_pwr;
+			inner_sum += mean_sq_pwr;
+			if ((i = 128) || (inner_sum < mean_sq_pwr_min)) {
+				lpphy->rc_cap = i;
+				mean_sq_pwr_min = inner_sum;
+			}
+		}
+	}
+	lpphy_stop_ddfs(dev);
+
+finish:
+	lpphy_restore_crs(dev);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, old_rf_ovrval);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_0, old_rf_ovr);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVRVAL, old_afe_ovrval);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVR, old_afe_ovr);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, old_rf2_ovrval);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, old_rf2_ovr);
+	b43_phy_write(dev, B43_LPPHY_LP_PHY_CTL, old_phy_ctl);
+
+	lpphy_set_bb_mult(dev, old_bbmult);
+	if (old_txg_ovr)
+		/*
+		 * SPEC FIXME: The specs say "get_tx_gains" here, which is
+		 * illogical. According to lwfinger, vendor driver v4.150.10.5
+		 * has a Set here, while v4.174.64.19 has a Get - regression in
+		 * the vendor driver? This should be tested this once the code
+		 * is testable.
+		 */
+		lpphy_set_tx_gains(dev, tx_gains);
+	lpphy_set_tx_power_control(dev, old_txpctl);
+	if (lpphy->rc_cap)
+		lpphy_set_rc_cap(dev);
 }
 
 static void lpphy_rev2plus_rc_calib(struct b43_wldev *dev)
-- 
1.6.2.4





From mb at bu3sch.de  Wed Aug 12 20:08:29 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 12 Aug 2009 20:08:29 +0200
Subject: [PATCH] b43: Implement RC calibration for rev.0/1 LP-PHYs
In-Reply-To: <4A830249.1010005@gmail.com>
References: <4A830249.1010005@gmail.com>
Message-ID: <200908122008.29582.mb@bu3sch.de>

On Wednesday 12 August 2009 19:56:25 G?bor Stefanik wrote:
> +		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF, 1<<8);

> +	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS_INCR_INIT, 0x80FF, incr2 << 3);

Can you try to stick to one style? a << b is our coding style.

> +static void lpphy_run_ddfs(struct b43_wldev *dev, int i_on, int q_on,
> +??????????????????????? ? int incr1, int incr2, int scale_idx)
> +{
> +???????lpphy_stop_ddfs(dev);
> +???????b43_phy_mask(dev, B43_LPPHY_AFE_DDFS_POINTER_INIT, 0xFF80);
> +???????b43_phy_mask(dev, B43_LPPHY_AFE_DDFS_POINTER_INIT, 0x80FF);
> +???????b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS_INCR_INIT, 0xFF80, incr1);
> +???????b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS_INCR_INIT, 0x80FF, incr2 << 3);

3bit shift smells fishy. Did you want 8?

> +u32 lpphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)

static?

> +static void lpphy_set_tx_power_control(struct b43_wldev *dev,
> +				       enum b43_lpphy_txpctl_mode mode);

Can you reorder the code to avoid the forward declaration?

> +	for (i = 128; i <= 159; i++) {
> +		b43_radio_write(dev, B2062_N_RXBB_CALIB2, i);
> +  		inner_sum = 0;
> +		for (j = 5; j <= 25; j++) {
> +			lpphy_run_ddfs(dev, 1, 1, j, j, 0);

(Just by guess) Did you really want j,j instead of i,j or something like that?

> +			if (!(lpphy_rx_iq_est(dev, 1000, 32, &iq_est)))
> +				goto finish;
> +			mean_sq_pwr = iq_est.i_pwr + iq_est.q_pwr;
> +			if (j == 5)
> +				tmp = mean_sq_pwr;
> +			ideal_pwr = ((ideal_pwr_table[j-5] >> 3) + 1) >> 1;
> +			normal_pwr = lpphy_qdiv_roundup(mean_sq_pwr, tmp, 12);
> +			mean_sq_pwr = ideal_pwr - normal_pwr;
> +			mean_sq_pwr *= mean_sq_pwr;
> +			inner_sum += mean_sq_pwr;
> +			if ((i = 128) || (inner_sum < mean_sq_pwr_min)) {
> +				lpphy->rc_cap = i;
> +				mean_sq_pwr_min = inner_sum;
> +			}
> +		}
> +	}
> +	lpphy_stop_ddfs(dev);
> +

> +	if (old_txg_ovr)
> +		/*
> +		 * SPEC FIXME: The specs say "get_tx_gains" here, which is
> +		 * illogical. According to lwfinger, vendor driver v4.150.10.5
> +		 * has a Set here, while v4.174.64.19 has a Get - regression in
> +		 * the vendor driver? This should be tested this once the code
> +		 * is testable.
> +		 */
> +		lpphy_set_tx_gains(dev, tx_gains);

Use curly brackets for multiline indents.

> +	lpphy_set_tx_power_control(dev, old_txpctl);
> +	if (lpphy->rc_cap)
> +		lpphy_set_rc_cap(dev);
>  }
>  
>  static void lpphy_rev2plus_rc_calib(struct b43_wldev *dev)



-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Wed Aug 12 20:41:53 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Wed, 12 Aug 2009 20:41:53 +0200
Subject: [PATCH v2] b43: Implement RC calibration for rev.0/1 LP-PHYs
Message-ID: <4A830CF1.3020907@gmail.com>

Also implement get/set BB mult, get/set TX gain, set RX gain,
disable/restore CRS, run/stop DDFS, RX IQ est and QDIV roundup
in the process.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Changes from v1->v2:
-Coding style fixes as suggested by Michael.
-Added missing static to lpphy_qdiv_roundup.
-Moved set_tx_power_control & related functions before rev0/1 RC calibration,
 and removed forward declaration
-Reordered variable declarations at the start of rev0_1_rc_calib.
-The ideal power table is now static const.

Interdiff v1->v2 available @ http://b43.pastebin.com/f5fe6ba3c for easier review.

 drivers/net/wireless/b43/phy_lp.c |  508 +++++++++++++++++++++++++++++++++----
 1 files changed, 461 insertions(+), 47 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 689c932..e05981b 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -605,6 +605,8 @@ static void lpphy_radio_init(struct b43_wldev *dev)
 	}
 }
 
+struct lpphy_iq_est { u32 iq_prod, i_pwr, q_pwr; };
+
 static void lpphy_set_rc_cap(struct b43_wldev *dev)
 {
 	u8 rc_cap = dev->phy.lp->rc_cap;
@@ -614,79 +616,327 @@ static void lpphy_set_rc_cap(struct b43_wldev *dev)
 	b43_radio_write(dev, B2062_S_RXG_CNT16, ((rc_cap & 0x1F) >> 2) | 0x80);
 }
 
-static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
+static u8 lpphy_get_bb_mult(struct b43_wldev *dev)
 {
-	//TODO and SPEC FIXME
+	return (b43_lptab_read(dev, B43_LPTAB16(0, 87)) & 0xFF00) >> 8;
 }
 
-static void lpphy_rev2plus_rc_calib(struct b43_wldev *dev)
+static void lpphy_set_bb_mult(struct b43_wldev *dev, u8 bb_mult)
 {
-	struct ssb_bus *bus = dev->dev->bus;
-	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
-	u8 tmp = b43_radio_read(dev, B2063_RX_BB_SP8) & 0xFF;
-	int i;
+	b43_lptab_write(dev, B43_LPTAB16(0, 87), (u16)bb_mult << 8);
+}
 
-	b43_radio_write(dev, B2063_RX_BB_SP8, 0x0);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
-	b43_radio_mask(dev, B2063_PLL_SP1, 0xF7);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x15);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x70);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x52);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7D);
+static void lpphy_disable_crs(struct b43_wldev *dev)
+{
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x80);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x1);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x4);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFF7);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x10);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFDF);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x20);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFBF);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x7);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x38);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFF3F);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x100);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFDFF);
+	b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL0, 0);
+	b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL1, 1);
+	b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL2, 0x20);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFBFF);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xF7FF);
+	b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL, 0);
+	b43_phy_write(dev, B43_LPPHY_RX_GAIN_CTL_OVERRIDE_VAL, 0x45AF);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0x3FF);
+}
 
-	for (i = 0; i < 10000; i++) {
-		if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
-			break;
-		msleep(1);
+static void lpphy_restore_crs(struct b43_wldev *dev)
+{
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x60);
+	else
+		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x20);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFF80);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFC00);
+}
+
+struct lpphy_tx_gains { u16 gm, pga, pad, dac; };
+
+static struct lpphy_tx_gains lpphy_get_tx_gains(struct b43_wldev *dev)
+{
+	struct lpphy_tx_gains gains;
+	u16 tmp;
+
+	gains.dac = (b43_phy_read(dev, B43_LPPHY_AFE_DAC_CTL) & 0x380) >> 7;
+	if (dev->phy.rev < 2) {
+		tmp = b43_phy_read(dev,
+				   B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL) & 0x7FF;
+		gains.gm = tmp & 0x0007;
+		gains.pga = (tmp & 0x0078) >> 3;
+		gains.pad = (tmp & 0x780) >> 7;
+	} else {
+		tmp = b43_phy_read(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL);
+		gains.pad = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0xFF;
+		gains.gm = tmp & 0xFF;
+		gains.pga = (tmp >> 8) & 0xFF;
 	}
 
-	if (!(b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2))
-		b43_radio_write(dev, B2063_RX_BB_SP8, tmp);
+	return gains;
+}
 
-	tmp = b43_radio_read(dev, B2063_TX_BB_SP3) & 0xFF;
+static void lpphy_set_dac_gain(struct b43_wldev *dev, u16 dac)
+{
+	u16 ctl = b43_phy_read(dev, B43_LPPHY_AFE_DAC_CTL) & 0xC7F;
+	ctl |= dac << 7;
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DAC_CTL, 0xF000, ctl);
+}
 
-	b43_radio_write(dev, B2063_TX_BB_SP3, 0x0);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x55);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x76);
+static void lpphy_set_tx_gains(struct b43_wldev *dev,
+			       struct lpphy_tx_gains gains)
+{
+	u16 rf_gain, pa_gain;
 
-	if (crystal_freq == 24000000) {
-		b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0xFC);
-		b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x0);
+	if (dev->phy.rev < 2) {
+		rf_gain = (gains.pad << 7) | (gains.pga << 3) | gains.gm;
+		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+				0xF800, rf_gain);
 	} else {
-		b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x13);
-		b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
+		pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x7F00;
+		b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+			      (gains.pga << 8) | gains.gm);
+		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+				0x8000, gains.pad | pa_gain);
+		b43_phy_write(dev, B43_PHY_OFDM(0xFC),
+			      (gains.pga << 8) | gains.gm);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0xFD),
+				0x8000, gains.pad | pa_gain);
+	}
+	lpphy_set_dac_gain(dev, gains.dac);
+	if (dev->phy.rev < 2) {
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF, 1 << 8);
+	} else {
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1 << 7);
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1 << 14);
 	}
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFBF, 1 << 4);
+}
 
-	b43_radio_write(dev, B2063_PA_SP7, 0x7D);
+static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
+{
+	u16 trsw = gain & 0x1;
+	u16 lna = (gain & 0xFFFC) | ((gain & 0xC) >> 2);
+	u16 ext_lna = (gain & 2) >> 1;
+
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFE, trsw);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL,
+			0xFBFF, ext_lna << 10);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL,
+			0xF7FF, ext_lna << 11);
+	b43_phy_write(dev, B43_LPPHY_RX_GAIN_CTL_OVERRIDE_VAL, lna);
+}
 
-	for (i = 0; i < 10000; i++) {
-		if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
+static void lpphy_rev2plus_set_rx_gain(struct b43_wldev *dev, u32 gain)
+{
+	u16 low_gain = gain & 0xFFFF;
+	u16 high_gain = (gain >> 16) & 0xF;
+	u16 ext_lna = (gain >> 21) & 0x1;
+	u16 trsw = ~(gain >> 21) & 0x1;
+	u16 tmp;
+	//SPEC FIXME is trsw really just ~(bool)ext_lna for rev2+?
+
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFE, trsw);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL,
+			0xFDFF, ext_lna << 9);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 
+			0xFBFF, ext_lna << 10);
+	b43_phy_write(dev, B43_LPPHY_RX_GAIN_CTL_OVERRIDE_VAL, low_gain);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFFF0, high_gain);
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		tmp = (gain >> 2) & 0x3;
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL,
+				0xE7FF, tmp<<11);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0xE6), 0xFFE7, tmp << 3);
+	}
+}
+
+static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
+{
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
+	if (dev->phy.rev >= 2) {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
+		if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
+			return;
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFF7);
+	} else {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
+	}
+}
+
+static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
+{
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
+	if (dev->phy.rev >= 2) {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
+		if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
+			return;
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x8);
+	} else {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
+	}
+}
+
+static void lpphy_set_rx_gain(struct b43_wldev *dev, u32 gain)
+{
+	if (dev->phy.rev < 2)
+		lpphy_rev0_1_set_rx_gain(dev, gain);
+	else
+		lpphy_rev2plus_set_rx_gain(dev, gain);
+	lpphy_enable_rx_gain_override(dev);
+}
+
+static void lpphy_set_rx_gain_by_index(struct b43_wldev *dev, u16 idx)
+{
+	u32 gain = b43_lptab_read(dev, B43_LPTAB16(12, idx));
+	lpphy_set_rx_gain(dev, gain);
+}
+
+static void lpphy_stop_ddfs(struct b43_wldev *dev)
+{
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS, 0xFFFD);
+	b43_phy_mask(dev, B43_LPPHY_LP_PHY_CTL, 0xFFDF);
+}
+
+static void lpphy_run_ddfs(struct b43_wldev *dev, int i_on, int q_on,
+			   int incr1, int incr2, int scale_idx)
+{
+	lpphy_stop_ddfs(dev);
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS_POINTER_INIT, 0xFF80);
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS_POINTER_INIT, 0x80FF);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS_INCR_INIT, 0xFF80, incr1);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS_INCR_INIT, 0x80FF, incr2 << 3);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFFF7, i_on << 3);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFFEF, q_on << 4);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFF9F, scale_idx << 5);
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS, 0xFFFB);
+	b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x2);
+	b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x20);
+}
+
+static bool lpphy_rx_iq_est(struct b43_wldev *dev, u16 samples, u8 time,
+			   struct lpphy_iq_est *iq_est)
+{
+	int i;
+
+	b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFF7);
+	b43_phy_write(dev, B43_LPPHY_IQ_NUM_SMPLS_ADDR, samples);
+	b43_phy_maskset(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFF00, time);
+	b43_phy_mask(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFEFF);
+	b43_phy_set(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFDFF);
+
+	for (i = 0; i < 500; i++) {
+		if (!(b43_phy_read(dev,
+				B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR) & 0x200))
 			break;
 		msleep(1);
 	}
 
-	if (!(b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2))
-		b43_radio_write(dev, B2063_TX_BB_SP3, tmp);
+	if ((b43_phy_read(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR) & 0x200)) {
+		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x8);
+		return false;
+	}
 
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
+	iq_est->iq_prod = b43_phy_read(dev, B43_LPPHY_IQ_ACC_HI_ADDR);
+	iq_est->iq_prod <<= 16;
+	iq_est->iq_prod |= b43_phy_read(dev, B43_LPPHY_IQ_ACC_LO_ADDR);
+
+	iq_est->i_pwr = b43_phy_read(dev, B43_LPPHY_IQ_I_PWR_ACC_HI_ADDR);
+	iq_est->i_pwr <<= 16;
+	iq_est->i_pwr |= b43_phy_read(dev, B43_LPPHY_IQ_I_PWR_ACC_LO_ADDR);
+
+	iq_est->q_pwr = b43_phy_read(dev, B43_LPPHY_IQ_Q_PWR_ACC_HI_ADDR);
+	iq_est->q_pwr <<= 16;
+	iq_est->q_pwr |= b43_phy_read(dev, B43_LPPHY_IQ_Q_PWR_ACC_LO_ADDR);
+
+	b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x8);
+	return true;
 }
 
-static void lpphy_calibrate_rc(struct b43_wldev *dev)
+static int lpphy_loopback(struct b43_wldev *dev)
 {
-	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct lpphy_iq_est iq_est;
+	int i, index = -1;
+	u32 tmp;
+
+	memset(&iq_est, 0, sizeof(iq_est));
+
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x3);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFFE);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x800);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x800);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x8);
+	b43_radio_write(dev, B2062_N_TX_CTL_A, 0x80);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x80);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x80);
+	for (i = 0; i < 32; i++) {
+		lpphy_set_rx_gain_by_index(dev, i);
+		lpphy_run_ddfs(dev, 1, 1, 5, 5, 0);
+		if (!(lpphy_rx_iq_est(dev, 1000, 32, &iq_est)))
+			continue;
+		tmp = (iq_est.i_pwr + iq_est.q_pwr) / 1000;
+		if ((tmp > 4000) && (tmp < 10000)) {
+			index = i;
+			break;
+		}
+	}
+	lpphy_stop_ddfs(dev);
+	return index;
+}
 
-	if (dev->phy.rev >= 2) {
-		lpphy_rev2plus_rc_calib(dev);
-	} else if (!lpphy->rc_cap) {
-		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
-			lpphy_rev0_1_rc_calib(dev);
+static u32 lpphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
+{
+	u32 quotient, remainder, rbit, roundup, tmp;
+
+	if (divisor == 0) {
+		quotient = 0;
+		remainder = 0;
 	} else {
-		lpphy_set_rc_cap(dev);
+		quotient = dividend / divisor;
+		remainder = dividend % divisor;
 	}
+
+	rbit = divisor & 0x1;
+	roundup = (divisor >> 1) + rbit;
+	precision--;
+
+	while (precision != 0xFF) {
+		tmp = remainder - roundup;
+		quotient <<= 1;
+		remainder <<= 1;
+		if (remainder >= roundup) {
+			remainder = (tmp << 1) + rbit;
+			quotient--;
+		}
+		precision--;
+	}
+
+	if (remainder >= roundup)
+		quotient++;
+
+	return quotient;
 }
 
 /* Read the TX power control mode from hardware. */
@@ -773,6 +1023,170 @@ static void lpphy_set_tx_power_control(struct b43_wldev *dev,
 	lpphy_write_tx_pctl_mode_to_hardware(dev);
 }
 
+static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct lpphy_iq_est iq_est;
+	struct lpphy_tx_gains tx_gains;
+	static const u32 ideal_pwr_table[22] = {
+		0x10000, 0x10557, 0x10e2d, 0x113e0, 0x10f22, 0x0ff64,
+		0x0eda2, 0x0e5d4, 0x0efd1, 0x0fbe8, 0x0b7b8, 0x04b35,
+		0x01a5e, 0x00a0b, 0x00444, 0x001fd, 0x000ff, 0x00088,
+		0x0004c, 0x0002c, 0x0001a, 0xc0006,
+	};
+	bool old_txg_ovr;
+	u8 old_bbmult;
+	u16 old_rf_ovr, old_rf_ovrval, old_afe_ovr, old_afe_ovrval,
+	    old_rf2_ovr, old_rf2_ovrval, old_phy_ctl, old_txpctl;
+	u32 normal_pwr, ideal_pwr, mean_sq_pwr, tmp = 0, mean_sq_pwr_min = 0;
+	int loopback, i, j, inner_sum;
+
+	memset(&iq_est, 0, sizeof(iq_est));
+
+	b43_switch_channel(dev, 7);
+	old_txg_ovr = (b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) >> 6) & 1;
+	old_bbmult = lpphy_get_bb_mult(dev);
+	if (old_txg_ovr)
+		tx_gains = lpphy_get_tx_gains(dev);
+	old_rf_ovr = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_0);
+	old_rf_ovrval = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_VAL_0);
+	old_afe_ovr = b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR);
+	old_afe_ovrval = b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVRVAL);
+	old_rf2_ovr = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2);
+	old_rf2_ovrval = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2_VAL);
+	old_phy_ctl = b43_phy_read(dev, B43_LPPHY_LP_PHY_CTL);
+	old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
+					B43_LPPHY_TX_PWR_CTL_CMD_MODE;
+ 
+ 	lpphy_set_tx_power_control(dev, B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
+	lpphy_disable_crs(dev);
+	loopback = lpphy_loopback(dev);
+	if (loopback == -1)
+		goto finish;
+	lpphy_set_rx_gain_by_index(dev, loopback);
+	b43_phy_maskset(dev, B43_LPPHY_LP_PHY_CTL, 0xFFBF, 0x40);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFFF8, 0x1);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFFC7, 0x8);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFF3F, 0xC0);
+	for (i = 128; i <= 159; i++) {
+		b43_radio_write(dev, B2062_N_RXBB_CALIB2, i);
+  		inner_sum = 0;
+		for (j = 5; j <= 25; j++) {
+			lpphy_run_ddfs(dev, 1, 1, j, j, 0);
+			if (!(lpphy_rx_iq_est(dev, 1000, 32, &iq_est)))
+				goto finish;
+			mean_sq_pwr = iq_est.i_pwr + iq_est.q_pwr;
+			if (j == 5)
+				tmp = mean_sq_pwr;
+			ideal_pwr = ((ideal_pwr_table[j-5] >> 3) + 1) >> 1;
+			normal_pwr = lpphy_qdiv_roundup(mean_sq_pwr, tmp, 12);
+			mean_sq_pwr = ideal_pwr - normal_pwr;
+			mean_sq_pwr *= mean_sq_pwr;
+			inner_sum += mean_sq_pwr;
+			if ((i = 128) || (inner_sum < mean_sq_pwr_min)) {
+				lpphy->rc_cap = i;
+				mean_sq_pwr_min = inner_sum;
+			}
+		}
+	}
+	lpphy_stop_ddfs(dev);
+
+finish:
+	lpphy_restore_crs(dev);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, old_rf_ovrval);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_0, old_rf_ovr);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVRVAL, old_afe_ovrval);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVR, old_afe_ovr);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, old_rf2_ovrval);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, old_rf2_ovr);
+	b43_phy_write(dev, B43_LPPHY_LP_PHY_CTL, old_phy_ctl);
+
+	lpphy_set_bb_mult(dev, old_bbmult);
+	if (old_txg_ovr) {
+		/*
+		 * SPEC FIXME: The specs say "get_tx_gains" here, which is
+		 * illogical. According to lwfinger, vendor driver v4.150.10.5
+		 * has a Set here, while v4.174.64.19 has a Get - regression in
+		 * the vendor driver? This should be tested this once the code
+		 * is testable.
+		 */
+		lpphy_set_tx_gains(dev, tx_gains);
+	}
+	lpphy_set_tx_power_control(dev, old_txpctl);
+	if (lpphy->rc_cap)
+		lpphy_set_rc_cap(dev);
+}
+
+static void lpphy_rev2plus_rc_calib(struct b43_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
+	u8 tmp = b43_radio_read(dev, B2063_RX_BB_SP8) & 0xFF;
+	int i;
+
+	b43_radio_write(dev, B2063_RX_BB_SP8, 0x0);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
+	b43_radio_mask(dev, B2063_PLL_SP1, 0xF7);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x15);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x70);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x52);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7D);
+
+	for (i = 0; i < 10000; i++) {
+		if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
+			break;
+		msleep(1);
+	}
+
+	if (!(b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2))
+		b43_radio_write(dev, B2063_RX_BB_SP8, tmp);
+
+	tmp = b43_radio_read(dev, B2063_TX_BB_SP3) & 0xFF;
+
+	b43_radio_write(dev, B2063_TX_BB_SP3, 0x0);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x55);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x76);
+
+	if (crystal_freq == 24000000) {
+		b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0xFC);
+		b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x0);
+	} else {
+		b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x13);
+		b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
+	}
+
+	b43_radio_write(dev, B2063_PA_SP7, 0x7D);
+
+	for (i = 0; i < 10000; i++) {
+		if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
+			break;
+		msleep(1);
+	}
+
+	if (!(b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2))
+		b43_radio_write(dev, B2063_TX_BB_SP3, tmp);
+
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
+}
+
+static void lpphy_calibrate_rc(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+
+	if (dev->phy.rev >= 2) {
+		lpphy_rev2plus_rc_calib(dev);
+	} else if (!lpphy->rc_cap) {
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+			lpphy_rev0_1_rc_calib(dev);
+	} else {
+		lpphy_set_rc_cap(dev);
+	}
+}
+
 static void lpphy_set_tx_power_by_index(struct b43_wldev *dev, u8 index)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
-- 
1.6.2.4





From netrolller.3d at gmail.com  Wed Aug 12 22:39:44 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Wed, 12 Aug 2009 22:39:44 +0200
Subject: [PATCH] b43: Update dummy transmission to match V4 specs
Message-ID: <4A832890.9010408@gmail.com>

The V4 dummy transmission function has two extra bools in its
prototype, so add a wrapper function for callers that expect the
V3 version.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/main.c |   60 ++++++++++++++++++++++++++++-----------
 drivers/net/wireless/b43/main.h |    1 +
 2 files changed, 44 insertions(+), 17 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index cb4a871..80bc962 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -683,11 +683,29 @@ static void b43_synchronize_irq(struct b43_wldev *dev)
 	tasklet_kill(&dev->isr_tasklet);
 }
 
-/* DummyTransmission function, as documented on
- * http://bcm-specs.sipsolutions.net/DummyTransmission
+/* Wrapper for callers of the old V3 dummy transmission function
+ * Please don't use this in new code, call the v4 routine directly instead.
  */
 void b43_dummy_transmission(struct b43_wldev *dev)
 {
+	switch (dev->phy.type) {
+	case B43_PHYTYPE_A:
+		b43_dummy_transmission_v4(dev, true, true);
+		break;
+	case B43_PHYTYPE_B:
+	case B43_PHYTYPE_G:
+		b43_dummy_transmission_v4(dev, false, true);
+		break;
+	default:
+		B43_WARN_ON(1);
+	}
+}
+
+/* DummyTransmission function, as documented on
+ * http://bcm-v4.sipsolutions.net/802.11/DummyTransmission
+ */
+void b43_dummy_transmission_v4(struct b43_wldev *dev, bool ofdm, bool pa_on)
+{
 	struct b43_wl *wl = dev->wl;
 	struct b43_phy *phy = &dev->phy;
 	unsigned int i, max_loop;
@@ -700,19 +718,12 @@ void b43_dummy_transmission(struct b43_wldev *dev)
 		0x00000000,
 	};
 
-	switch (phy->type) {
-	case B43_PHYTYPE_A:
+	if (ofdm) {
 		max_loop = 0x1E;
 		buffer[0] = 0x000201CC;
-		break;
-	case B43_PHYTYPE_B:
-	case B43_PHYTYPE_G:
+	} else {
 		max_loop = 0xFA;
 		buffer[0] = 0x000B846E;
-		break;
-	default:
-		B43_WARN_ON(1);
-		return;
 	}
 
 	spin_lock_irq(&wl->irq_lock);
@@ -721,20 +732,35 @@ void b43_dummy_transmission(struct b43_wldev *dev)
 	for (i = 0; i < 5; i++)
 		b43_ram_write(dev, i * 4, buffer[i]);
 
-	/* Commit writes */
-	b43_read32(dev, B43_MMIO_MACCTL);
-
 	b43_write16(dev, 0x0568, 0x0000);
-	b43_write16(dev, 0x07C0, 0x0000);
-	value = ((phy->type == B43_PHYTYPE_A) ? 1 : 0);
+	if (dev->dev->id.revision < 11)
+		b43_write16(dev, 0x07C0, 0x0000);
+	else
+		b43_write16(dev, 0x07C0, 0x0100);
+	value = (ofdm ? 0x41 : 0x40);
 	b43_write16(dev, 0x050C, value);
+	if ((phy->type == B43_PHYTYPE_N) || (phy->type == B43_PHYTYPE_LP))
+		b43_write16(dev, 0x0514, 0x1A02);
 	b43_write16(dev, 0x0508, 0x0000);
 	b43_write16(dev, 0x050A, 0x0000);
 	b43_write16(dev, 0x054C, 0x0000);
 	b43_write16(dev, 0x056A, 0x0014);
 	b43_write16(dev, 0x0568, 0x0826);
 	b43_write16(dev, 0x0500, 0x0000);
-	b43_write16(dev, 0x0502, 0x0030);
+	if (!pa_on && (phy->type == B43_PHYTYPE_N)) {
+		//SPEC TODO
+	}
+
+	switch (phy->type) {
+	case B43_PHYTYPE_N:
+		b43_write16(dev, 0x0502, 0x00D0);
+		break;
+	case B43_PHYTYPE_LP:
+		b43_write16(dev, 0x0502, 0x0050);
+		break;
+	default:
+		b43_write16(dev, 0x0502, 0x0030);
+	}
 
 	if (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5)
 		b43_radio_write16(dev, 0x0051, 0x0017);
diff --git a/drivers/net/wireless/b43/main.h b/drivers/net/wireless/b43/main.h
index 40abcf5..7f26fd9 100644
--- a/drivers/net/wireless/b43/main.h
+++ b/drivers/net/wireless/b43/main.h
@@ -125,6 +125,7 @@ u64 b43_hf_read(struct b43_wldev *dev);
 void b43_hf_write(struct b43_wldev *dev, u64 value);
 
 void b43_dummy_transmission(struct b43_wldev *dev);
+void b43_dummy_transmission_v4(struct b43_wldev *dev, bool ofdm, bool pa_on);
 
 void b43_wireless_core_reset(struct b43_wldev *dev, u32 flags);
 
-- 
1.6.2.4





From netrolller.3d at gmail.com  Wed Aug 12 22:42:40 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Wed, 12 Aug 2009 22:42:40 +0200
Subject: [PATCH] b43: LP-PHY: Initialize TX power control
Message-ID: <4A832940.6000807@gmail.com>

The HW TX power control init still needs work.
The SW init is complete according to the specs.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
This depends on both the rev0/1 RC calibration patch and the
V4 dummy transmission patch I submitted earlier.

Larry, please check the SPEC TODO/SPEC FIXME comments.

 drivers/net/wireless/b43/phy_lp.c |  104 ++++++++++++++++++++++++++++++++++---
 drivers/net/wireless/b43/phy_lp.h |    5 ++
 2 files changed, 102 insertions(+), 7 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index e05981b..6ebaeb2 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1258,18 +1258,108 @@ static void lpphy_calibration(struct b43_wldev *dev)
 	b43_mac_enable(dev);
 }
 
+static void lpphy_set_tssi_mux(struct b43_wldev *dev, enum tssi_mux_mode mode)
+{
+	if (mode != TSSI_MUX_EXT) {
+		b43_radio_set(dev, B2063_PA_SP1, 0x2);
+		b43_phy_set(dev, B43_PHY_OFDM(0xF3), 0x1000);
+		b43_radio_write(dev, B2063_PA_CTL10, 0x51);
+		if (mode == TSSI_MUX_POSTPA) {
+			b43_radio_mask(dev, B2063_PA_SP1, 0xFFFE);
+			b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFC7);
+		} else {
+			b43_radio_maskset(dev, B2063_PA_SP1, 0xFFFE, 0x1);
+			b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVRVAL,
+					0xFFC7, 0x20);
+		}
+	} else {
+		//SPEC TODO
+	}
+}
+
+static void lpphy_tx_pctl_init_hw(struct b43_wldev *dev)
+{
+	u16 tmp;
+	int i;
+
+	//SPEC TODO Call LP PHY Clear TX Power offsets
+	for (i = 0; i < 64; i++) {
+		if (dev->phy.rev >= 2)
+			b43_lptab_write(dev, B43_LPTAB32(7, i+1), i);
+		else
+			b43_lptab_write(dev, B43_LPTAB32(10, i+1), i);
+	}
+
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_NNUM, 0xFF00, 0xFF);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_NNUM, 0x8FFF, 0x5000);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_IDLETSSI, 0xFFC0, 0x1F);
+	if (dev->phy.rev < 2) {
+		b43_phy_mask(dev, B43_LPPHY_LP_PHY_CTL, 0xEFFF);
+		b43_phy_maskset(dev, B43_LPPHY_LP_PHY_CTL, 0xDFFF, 0x2000);
+	} else {
+		b43_phy_mask(dev, B43_PHY_OFDM(0x103), 0xFFFE);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x103), 0xFFFB, 0x4);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x103), 0xFFEF, 0x10);
+		b43_radio_maskset(dev, B2063_IQ_CALIB_CTL2, 0xF3, 0x1);
+		lpphy_set_tssi_mux(dev, TSSI_MUX_POSTPA);
+	}
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_IDLETSSI, 0x7FFF, 0x8000);
+	b43_phy_mask(dev, B43_LPPHY_TX_PWR_CTL_DELTAPWR_LIMIT, 0xFF);
+	b43_phy_write(dev, B43_LPPHY_TX_PWR_CTL_DELTAPWR_LIMIT, 0xA);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_CMD,
+			(u16)~B43_LPPHY_TX_PWR_CTL_CMD_MODE,
+			B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
+	b43_phy_mask(dev, B43_LPPHY_TX_PWR_CTL_NNUM, 0xF8FF);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_CMD,
+			(u16)~B43_LPPHY_TX_PWR_CTL_CMD_MODE,
+			B43_LPPHY_TX_PWR_CTL_CMD_MODE_SW);
+
+	if (dev->phy.rev < 2) {
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_0, 0xEFFF, 0x1000);
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xEFFF);
+	} else {
+		lpphy_set_tx_power_by_index(dev, 0x7F);
+	}
+
+	b43_dummy_transmission_v4(dev, true, true);
+
+	tmp = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_STAT);
+	if (tmp & 0x8000)
+		b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_IDLETSSI,
+				0xFFC0, (tmp & 0xFF) - 32);
+
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xEFFF);
+
+	// (SPEC?) TODO Set "Target TX frequency" variable to 0
+	// SPEC FIXME "Set BB Multiplier to 0xE000" impossible - bb_mult is u8!
+}
+
+static void lpphy_tx_pctl_init_sw(struct b43_wldev *dev)
+{
+	struct lpphy_tx_gains gains;
+
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		gains.gm = 4;
+		gains.pad = 12;
+		gains.pga = 12;
+		gains.dac = 0;
+	} else {
+		gains.gm = 7;
+		gains.pad = 14;
+		gains.pga = 15;
+		gains.dac = 0;
+	}
+	lpphy_set_tx_gains(dev, gains);
+	lpphy_set_bb_mult(dev, 150);
+}
+
 /* Initialize TX power control */
 static void lpphy_tx_pctl_init(struct b43_wldev *dev)
 {
 	if (0/*FIXME HWPCTL capable */) {
-		//TODO
+		lpphy_tx_pctl_init_hw(dev);
 	} else { /* This device is only software TX power control capable. */
-		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
-			//TODO
-		} else {
-			//TODO
-		}
-		//TODO set BB multiplier to 0x0096
+		lpphy_tx_pctl_init_sw(dev);
 	}
 }
 
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 0461d5b..4eab760 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -886,6 +886,11 @@ struct b43_phy_lp {
 	u16 dig_flt_state[9];
 };
 
+enum tssi_mux_mode {
+	TSSI_MUX_PREPA,
+	TSSI_MUX_POSTPA,
+	TSSI_MUX_EXT,
+};
 
 struct b43_phy_operations;
 extern const struct b43_phy_operations b43_phyops_lp;
-- 
1.6.2.4





From Larry.Finger at lwfinger.net  Thu Aug 13 04:19:42 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 12 Aug 2009 21:19:42 -0500
Subject: [PATCH] b43: Implement RC calibration for rev.0/1 LP-PHYs
In-Reply-To: <200908122008.29582.mb@bu3sch.de>
References: <4A830249.1010005@gmail.com> <200908122008.29582.mb@bu3sch.de>
Message-ID: <4A83783E.3000607@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 12 August 2009 19:56:25 G?bor Stefanik wrote:
>> +       b43_phy_mask(dev, B43_LPPHY_AFE_DDFS_POINTER_INIT, 0x80FF);
>> +       b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS_INCR_INIT, 0xFF80, incr1);
>> +       b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS_INCR_INIT, 0x80FF, incr2 << 3);
> 
> 3bit shift smells fishy. Did you want 8?

There was a typo in the specs. It now is changed to 8.

>> +		for (j = 5; j <= 25; j++) {
>> +			lpphy_run_ddfs(dev, 1, 1, j, j, 0);
> 
> (Just by guess) Did you really want j,j instead of i,j or something like that?

No, it definitely is j,j.

Larry



From Larry.Finger at lwfinger.net  Thu Aug 13 04:28:15 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 12 Aug 2009 21:28:15 -0500
Subject: [PATCH v2] b43: Implement RC calibration for rev.0/1 LP-PHYs
In-Reply-To: <4A830CF1.3020907@gmail.com>
References: <4A830CF1.3020907@gmail.com>
Message-ID: <4A837A3F.6050703@lwfinger.net>

G?bor Stefanik wrote:
> Also implement get/set BB mult, get/set TX gain, set RX gain,
> disable/restore CRS, run/stop DDFS, RX IQ est and QDIV roundup
> in the process.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> Changes from v1->v2:
> -Coding style fixes as suggested by Michael.
> -Added missing static to lpphy_qdiv_roundup.
> -Moved set_tx_power_control & related functions before rev0/1 RC
> calibration,
> and removed forward declaration
> -Reordered variable declarations at the start of rev0_1_rc_calib.
> -The ideal power table is now static const.
> 
> Interdiff v1->v2 available @ http://b43.pastebin.com/f5fe6ba3c for
> easier review.
> 
> drivers/net/wireless/b43/phy_lp.c |  508
> +++++++++++++++++++++++++++++++++----
> 1 files changed, 461 insertions(+), 47 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index 689c932..e05981b 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -605,6 +605,8 @@ static void lpphy_radio_init(struct b43_wldev *dev)
>     }
> }
> 
> +struct lpphy_iq_est { u32 iq_prod, i_pwr, q_pwr; };
> +
> static void lpphy_set_rc_cap(struct b43_wldev *dev)
> {
>     u8 rc_cap = dev->phy.lp->rc_cap;
> @@ -614,79 +616,327 @@ static void lpphy_set_rc_cap(struct b43_wldev *dev)
>     b43_radio_write(dev, B2062_S_RXG_CNT16, ((rc_cap & 0x1F) >> 2) | 0x80);
> }
> 
> -static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
> +static u8 lpphy_get_bb_mult(struct b43_wldev *dev)
> {
> -    //TODO and SPEC FIXME
> +    return (b43_lptab_read(dev, B43_LPTAB16(0, 87)) & 0xFF00) >> 8;
> }
> 
> -static void lpphy_rev2plus_rc_calib(struct b43_wldev *dev)
> +static void lpphy_set_bb_mult(struct b43_wldev *dev, u8 bb_mult)
> {
> -    struct ssb_bus *bus = dev->dev->bus;
> -    u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
> -    u8 tmp = b43_radio_read(dev, B2063_RX_BB_SP8) & 0xFF;
> -    int i;
> +    b43_lptab_write(dev, B43_LPTAB16(0, 87), (u16)bb_mult << 8);
> +}
> 
> -    b43_radio_write(dev, B2063_RX_BB_SP8, 0x0);
> -    b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
> -    b43_radio_mask(dev, B2063_PLL_SP1, 0xF7);
> -    b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
> -    b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x15);
> -    b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x70);
> -    b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x52);
> -    b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
> -    b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7D);
> +static void lpphy_disable_crs(struct b43_wldev *dev)
> +{
> +    b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x80);
> +    b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x1);
> +    b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
> +    b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
> +    b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x4);
> +    b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFF7);
> +    b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
> +    b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x10);
> +    b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
> +    b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFDF);
> +    b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x20);
> +    b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFBF);
> +    b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
> +    b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x7);
> +    b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x38);
> +    b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFF3F);
> +    b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x100);
> +    b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFDFF);
> +    b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL0, 0);
> +    b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL1, 1);
> +    b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL2, 0x20);
> +    b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFBFF);
> +    b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xF7FF);
> +    b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL, 0);
> +    b43_phy_write(dev, B43_LPPHY_RX_GAIN_CTL_OVERRIDE_VAL, 0x45AF);
> +    b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0x3FF);
> +}
> 
> -    for (i = 0; i < 10000; i++) {
> -        if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
> -            break;
> -        msleep(1);
> +static void lpphy_restore_crs(struct b43_wldev *dev)
> +{
> +    if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
> +        b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x60);
> +    else
> +        b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x20);
> +    b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFF80);
> +    b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFC00);
> +}
> +
> +struct lpphy_tx_gains { u16 gm, pga, pad, dac; };
> +
> +static struct lpphy_tx_gains lpphy_get_tx_gains(struct b43_wldev *dev)
> +{
> +    struct lpphy_tx_gains gains;
> +    u16 tmp;
> +
> +    gains.dac = (b43_phy_read(dev, B43_LPPHY_AFE_DAC_CTL) & 0x380) >> 7;
> +    if (dev->phy.rev < 2) {
> +        tmp = b43_phy_read(dev,
> +                   B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL) & 0x7FF;
> +        gains.gm = tmp & 0x0007;
> +        gains.pga = (tmp & 0x0078) >> 3;
> +        gains.pad = (tmp & 0x780) >> 7;
> +    } else {
> +        tmp = b43_phy_read(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL);
> +        gains.pad = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0xFF;
> +        gains.gm = tmp & 0xFF;
> +        gains.pga = (tmp >> 8) & 0xFF;
>     }
> 
> -    if (!(b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2))
> -        b43_radio_write(dev, B2063_RX_BB_SP8, tmp);
> +    return gains;
> +}
> 
> -    tmp = b43_radio_read(dev, B2063_TX_BB_SP3) & 0xFF;
> +static void lpphy_set_dac_gain(struct b43_wldev *dev, u16 dac)
> +{
> +    u16 ctl = b43_phy_read(dev, B43_LPPHY_AFE_DAC_CTL) & 0xC7F;
> +    ctl |= dac << 7;
> +    b43_phy_maskset(dev, B43_LPPHY_AFE_DAC_CTL, 0xF000, ctl);
> +}
> 
> -    b43_radio_write(dev, B2063_TX_BB_SP3, 0x0);
> -    b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
> -    b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
> -    b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x55);
> -    b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x76);
> +static void lpphy_set_tx_gains(struct b43_wldev *dev,
> +                   struct lpphy_tx_gains gains)
> +{
> +    u16 rf_gain, pa_gain;
> 
> -    if (crystal_freq == 24000000) {
> -        b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0xFC);
> -        b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x0);
> +    if (dev->phy.rev < 2) {
> +        rf_gain = (gains.pad << 7) | (gains.pga << 3) | gains.gm;
> +        b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
> +                0xF800, rf_gain);
>     } else {
> -        b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x13);
> -        b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
> +        pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x7F00;
> +        b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
> +                  (gains.pga << 8) | gains.gm);
> +        b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
> +                0x8000, gains.pad | pa_gain);
> +        b43_phy_write(dev, B43_PHY_OFDM(0xFC),
> +                  (gains.pga << 8) | gains.gm);
> +        b43_phy_maskset(dev, B43_PHY_OFDM(0xFD),
> +                0x8000, gains.pad | pa_gain);
> +    }
> +    lpphy_set_dac_gain(dev, gains.dac);
> +    if (dev->phy.rev < 2) {
> +        b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF, 1 << 8);
> +    } else {
> +        b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1 << 7);
> +        b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1 << 14);
>     }
> +    b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFBF, 1 << 4);
> +}
> 
> -    b43_radio_write(dev, B2063_PA_SP7, 0x7D);
> +static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
> +{
> +    u16 trsw = gain & 0x1;
> +    u16 lna = (gain & 0xFFFC) | ((gain & 0xC) >> 2);
> +    u16 ext_lna = (gain & 2) >> 1;
> +
> +    b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFE, trsw);
> +    b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL,
> +            0xFBFF, ext_lna << 10);
> +    b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL,
> +            0xF7FF, ext_lna << 11);
> +    b43_phy_write(dev, B43_LPPHY_RX_GAIN_CTL_OVERRIDE_VAL, lna);
> +}
> 
> -    for (i = 0; i < 10000; i++) {
> -        if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
> +static void lpphy_rev2plus_set_rx_gain(struct b43_wldev *dev, u32 gain)
> +{
> +    u16 low_gain = gain & 0xFFFF;
> +    u16 high_gain = (gain >> 16) & 0xF;
> +    u16 ext_lna = (gain >> 21) & 0x1;
> +    u16 trsw = ~(gain >> 21) & 0x1;
                            ==
Should be 20, not 21.

> +    u16 tmp;
> +    //SPEC FIXME is trsw really just ~(bool)ext_lna for rev2+?

No.

Larry



From netrolller.3d at gmail.com  Thu Aug 13 14:19:02 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 13 Aug 2009 14:19:02 +0200
Subject: [PATCH v3] b43: Implement RC calibration for rev.0/1 LP-PHYs
Message-ID: <4A8404B6.2070902@gmail.com>

Also implement get/set BB mult, get/set TX gain, set RX gain,
disable/restore CRS, run/stop DDFS, RX IQ est and QDIV roundup
in the process.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Changes from v2->v3:
-Two small spec updates/typo fixes, as suggested by Larry.

Changes from v1->v2:
-Coding style fixes as suggested by Michael.
-Added missing static to lpphy_qdiv_roundup.
-Moved set_tx_power_control & related functions before rev0/1 RC calibration,
 and removed forward declaration
-Reordered variable declarations at the start of rev0_1_rc_calib.
-The ideal power table is now static const.

Interdiff v1->v2 available @ http://b43.pastebin.com/f5fe6ba3c for easier review.

 drivers/net/wireless/b43/phy_lp.c |  507 +++++++++++++++++++++++++++++++++----
 1 files changed, 460 insertions(+), 47 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 689c932..2441a8d 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -605,6 +605,8 @@ static void lpphy_radio_init(struct b43_wldev *dev)
 	}
 }
 
+struct lpphy_iq_est { u32 iq_prod, i_pwr, q_pwr; };
+
 static void lpphy_set_rc_cap(struct b43_wldev *dev)
 {
 	u8 rc_cap = dev->phy.lp->rc_cap;
@@ -614,79 +616,326 @@ static void lpphy_set_rc_cap(struct b43_wldev *dev)
 	b43_radio_write(dev, B2062_S_RXG_CNT16, ((rc_cap & 0x1F) >> 2) | 0x80);
 }
 
-static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
+static u8 lpphy_get_bb_mult(struct b43_wldev *dev)
 {
-	//TODO and SPEC FIXME
+	return (b43_lptab_read(dev, B43_LPTAB16(0, 87)) & 0xFF00) >> 8;
 }
 
-static void lpphy_rev2plus_rc_calib(struct b43_wldev *dev)
+static void lpphy_set_bb_mult(struct b43_wldev *dev, u8 bb_mult)
 {
-	struct ssb_bus *bus = dev->dev->bus;
-	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
-	u8 tmp = b43_radio_read(dev, B2063_RX_BB_SP8) & 0xFF;
-	int i;
+	b43_lptab_write(dev, B43_LPTAB16(0, 87), (u16)bb_mult << 8);
+}
 
-	b43_radio_write(dev, B2063_RX_BB_SP8, 0x0);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
-	b43_radio_mask(dev, B2063_PLL_SP1, 0xF7);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x15);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x70);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x52);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7D);
+static void lpphy_disable_crs(struct b43_wldev *dev)
+{
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x80);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x1);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x4);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFF7);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x10);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFDF);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x20);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFBF);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x7);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x38);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFF3F);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0x100);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFDFF);
+	b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL0, 0);
+	b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL1, 1);
+	b43_phy_write(dev, B43_LPPHY_PS_CTL_OVERRIDE_VAL2, 0x20);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFBFF);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xF7FF);
+	b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL, 0);
+	b43_phy_write(dev, B43_LPPHY_RX_GAIN_CTL_OVERRIDE_VAL, 0x45AF);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0x3FF);
+}
 
-	for (i = 0; i < 10000; i++) {
-		if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
-			break;
-		msleep(1);
+static void lpphy_restore_crs(struct b43_wldev *dev)
+{
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x60);
+	else
+		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x20);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFF80);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFC00);
+}
+
+struct lpphy_tx_gains { u16 gm, pga, pad, dac; };
+
+static struct lpphy_tx_gains lpphy_get_tx_gains(struct b43_wldev *dev)
+{
+	struct lpphy_tx_gains gains;
+	u16 tmp;
+
+	gains.dac = (b43_phy_read(dev, B43_LPPHY_AFE_DAC_CTL) & 0x380) >> 7;
+	if (dev->phy.rev < 2) {
+		tmp = b43_phy_read(dev,
+				   B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL) & 0x7FF;
+		gains.gm = tmp & 0x0007;
+		gains.pga = (tmp & 0x0078) >> 3;
+		gains.pad = (tmp & 0x780) >> 7;
+	} else {
+		tmp = b43_phy_read(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL);
+		gains.pad = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0xFF;
+		gains.gm = tmp & 0xFF;
+		gains.pga = (tmp >> 8) & 0xFF;
 	}
 
-	if (!(b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2))
-		b43_radio_write(dev, B2063_RX_BB_SP8, tmp);
+	return gains;
+}
 
-	tmp = b43_radio_read(dev, B2063_TX_BB_SP3) & 0xFF;
+static void lpphy_set_dac_gain(struct b43_wldev *dev, u16 dac)
+{
+	u16 ctl = b43_phy_read(dev, B43_LPPHY_AFE_DAC_CTL) & 0xC7F;
+	ctl |= dac << 7;
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DAC_CTL, 0xF000, ctl);
+}
 
-	b43_radio_write(dev, B2063_TX_BB_SP3, 0x0);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x55);
-	b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x76);
+static void lpphy_set_tx_gains(struct b43_wldev *dev,
+			       struct lpphy_tx_gains gains)
+{
+	u16 rf_gain, pa_gain;
 
-	if (crystal_freq == 24000000) {
-		b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0xFC);
-		b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x0);
+	if (dev->phy.rev < 2) {
+		rf_gain = (gains.pad << 7) | (gains.pga << 3) | gains.gm;
+		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+				0xF800, rf_gain);
 	} else {
-		b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x13);
-		b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
+		pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x7F00;
+		b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+			      (gains.pga << 8) | gains.gm);
+		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+				0x8000, gains.pad | pa_gain);
+		b43_phy_write(dev, B43_PHY_OFDM(0xFC),
+			      (gains.pga << 8) | gains.gm);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0xFD),
+				0x8000, gains.pad | pa_gain);
 	}
+	lpphy_set_dac_gain(dev, gains.dac);
+	if (dev->phy.rev < 2) {
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF, 1 << 8);
+	} else {
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1 << 7);
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1 << 14);
+	}
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFBF, 1 << 4);
+}
 
-	b43_radio_write(dev, B2063_PA_SP7, 0x7D);
+static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
+{
+	u16 trsw = gain & 0x1;
+	u16 lna = (gain & 0xFFFC) | ((gain & 0xC) >> 2);
+	u16 ext_lna = (gain & 2) >> 1;
+
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFE, trsw);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL,
+			0xFBFF, ext_lna << 10);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL,
+			0xF7FF, ext_lna << 11);
+	b43_phy_write(dev, B43_LPPHY_RX_GAIN_CTL_OVERRIDE_VAL, lna);
+}
 
-	for (i = 0; i < 10000; i++) {
-		if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
+static void lpphy_rev2plus_set_rx_gain(struct b43_wldev *dev, u32 gain)
+{
+	u16 low_gain = gain & 0xFFFF;
+	u16 high_gain = (gain >> 16) & 0xF;
+	u16 ext_lna = (gain >> 21) & 0x1;
+	u16 trsw = ~(gain >> 20) & 0x1;
+	u16 tmp;
+
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFE, trsw);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL,
+			0xFDFF, ext_lna << 9);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 
+			0xFBFF, ext_lna << 10);
+	b43_phy_write(dev, B43_LPPHY_RX_GAIN_CTL_OVERRIDE_VAL, low_gain);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFFF0, high_gain);
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		tmp = (gain >> 2) & 0x3;
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL,
+				0xE7FF, tmp<<11);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0xE6), 0xFFE7, tmp << 3);
+	}
+}
+
+static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
+{
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
+	if (dev->phy.rev >= 2) {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
+		if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
+			return;
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFF7);
+	} else {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
+	}
+}
+
+static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
+{
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
+	if (dev->phy.rev >= 2) {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
+		if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
+			return;
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x8);
+	} else {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
+	}
+}
+
+static void lpphy_set_rx_gain(struct b43_wldev *dev, u32 gain)
+{
+	if (dev->phy.rev < 2)
+		lpphy_rev0_1_set_rx_gain(dev, gain);
+	else
+		lpphy_rev2plus_set_rx_gain(dev, gain);
+	lpphy_enable_rx_gain_override(dev);
+}
+
+static void lpphy_set_rx_gain_by_index(struct b43_wldev *dev, u16 idx)
+{
+	u32 gain = b43_lptab_read(dev, B43_LPTAB16(12, idx));
+	lpphy_set_rx_gain(dev, gain);
+}
+
+static void lpphy_stop_ddfs(struct b43_wldev *dev)
+{
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS, 0xFFFD);
+	b43_phy_mask(dev, B43_LPPHY_LP_PHY_CTL, 0xFFDF);
+}
+
+static void lpphy_run_ddfs(struct b43_wldev *dev, int i_on, int q_on,
+			   int incr1, int incr2, int scale_idx)
+{
+	lpphy_stop_ddfs(dev);
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS_POINTER_INIT, 0xFF80);
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS_POINTER_INIT, 0x80FF);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS_INCR_INIT, 0xFF80, incr1);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS_INCR_INIT, 0x80FF, incr2 << 8);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFFF7, i_on << 3);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFFEF, q_on << 4);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFF9F, scale_idx << 5);
+	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS, 0xFFFB);
+	b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x2);
+	b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x20);
+}
+
+static bool lpphy_rx_iq_est(struct b43_wldev *dev, u16 samples, u8 time,
+			   struct lpphy_iq_est *iq_est)
+{
+	int i;
+
+	b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFF7);
+	b43_phy_write(dev, B43_LPPHY_IQ_NUM_SMPLS_ADDR, samples);
+	b43_phy_maskset(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFF00, time);
+	b43_phy_mask(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFEFF);
+	b43_phy_set(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFDFF);
+
+	for (i = 0; i < 500; i++) {
+		if (!(b43_phy_read(dev,
+				B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR) & 0x200))
 			break;
 		msleep(1);
 	}
 
-	if (!(b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2))
-		b43_radio_write(dev, B2063_TX_BB_SP3, tmp);
+	if ((b43_phy_read(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR) & 0x200)) {
+		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x8);
+		return false;
+	}
 
-	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
+	iq_est->iq_prod = b43_phy_read(dev, B43_LPPHY_IQ_ACC_HI_ADDR);
+	iq_est->iq_prod <<= 16;
+	iq_est->iq_prod |= b43_phy_read(dev, B43_LPPHY_IQ_ACC_LO_ADDR);
+
+	iq_est->i_pwr = b43_phy_read(dev, B43_LPPHY_IQ_I_PWR_ACC_HI_ADDR);
+	iq_est->i_pwr <<= 16;
+	iq_est->i_pwr |= b43_phy_read(dev, B43_LPPHY_IQ_I_PWR_ACC_LO_ADDR);
+
+	iq_est->q_pwr = b43_phy_read(dev, B43_LPPHY_IQ_Q_PWR_ACC_HI_ADDR);
+	iq_est->q_pwr <<= 16;
+	iq_est->q_pwr |= b43_phy_read(dev, B43_LPPHY_IQ_Q_PWR_ACC_LO_ADDR);
+
+	b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x8);
+	return true;
 }
 
-static void lpphy_calibrate_rc(struct b43_wldev *dev)
+static int lpphy_loopback(struct b43_wldev *dev)
 {
-	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct lpphy_iq_est iq_est;
+	int i, index = -1;
+	u32 tmp;
+
+	memset(&iq_est, 0, sizeof(iq_est));
+
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x3);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFFE);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x800);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x800);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x8);
+	b43_radio_write(dev, B2062_N_TX_CTL_A, 0x80);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x80);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x80);
+	for (i = 0; i < 32; i++) {
+		lpphy_set_rx_gain_by_index(dev, i);
+		lpphy_run_ddfs(dev, 1, 1, 5, 5, 0);
+		if (!(lpphy_rx_iq_est(dev, 1000, 32, &iq_est)))
+			continue;
+		tmp = (iq_est.i_pwr + iq_est.q_pwr) / 1000;
+		if ((tmp > 4000) && (tmp < 10000)) {
+			index = i;
+			break;
+		}
+	}
+	lpphy_stop_ddfs(dev);
+	return index;
+}
 
-	if (dev->phy.rev >= 2) {
-		lpphy_rev2plus_rc_calib(dev);
-	} else if (!lpphy->rc_cap) {
-		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
-			lpphy_rev0_1_rc_calib(dev);
+static u32 lpphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
+{
+	u32 quotient, remainder, rbit, roundup, tmp;
+
+	if (divisor == 0) {
+		quotient = 0;
+		remainder = 0;
 	} else {
-		lpphy_set_rc_cap(dev);
+		quotient = dividend / divisor;
+		remainder = dividend % divisor;
 	}
+
+	rbit = divisor & 0x1;
+	roundup = (divisor >> 1) + rbit;
+	precision--;
+
+	while (precision != 0xFF) {
+		tmp = remainder - roundup;
+		quotient <<= 1;
+		remainder <<= 1;
+		if (remainder >= roundup) {
+			remainder = (tmp << 1) + rbit;
+			quotient--;
+		}
+		precision--;
+	}
+
+	if (remainder >= roundup)
+		quotient++;
+
+	return quotient;
 }
 
 /* Read the TX power control mode from hardware. */
@@ -773,6 +1022,170 @@ static void lpphy_set_tx_power_control(struct b43_wldev *dev,
 	lpphy_write_tx_pctl_mode_to_hardware(dev);
 }
 
+static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct lpphy_iq_est iq_est;
+	struct lpphy_tx_gains tx_gains;
+	static const u32 ideal_pwr_table[22] = {
+		0x10000, 0x10557, 0x10e2d, 0x113e0, 0x10f22, 0x0ff64,
+		0x0eda2, 0x0e5d4, 0x0efd1, 0x0fbe8, 0x0b7b8, 0x04b35,
+		0x01a5e, 0x00a0b, 0x00444, 0x001fd, 0x000ff, 0x00088,
+		0x0004c, 0x0002c, 0x0001a, 0xc0006,
+	};
+	bool old_txg_ovr;
+	u8 old_bbmult;
+	u16 old_rf_ovr, old_rf_ovrval, old_afe_ovr, old_afe_ovrval,
+	    old_rf2_ovr, old_rf2_ovrval, old_phy_ctl, old_txpctl;
+	u32 normal_pwr, ideal_pwr, mean_sq_pwr, tmp = 0, mean_sq_pwr_min = 0;
+	int loopback, i, j, inner_sum;
+
+	memset(&iq_est, 0, sizeof(iq_est));
+
+	b43_switch_channel(dev, 7);
+	old_txg_ovr = (b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) >> 6) & 1;
+	old_bbmult = lpphy_get_bb_mult(dev);
+	if (old_txg_ovr)
+		tx_gains = lpphy_get_tx_gains(dev);
+	old_rf_ovr = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_0);
+	old_rf_ovrval = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_VAL_0);
+	old_afe_ovr = b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR);
+	old_afe_ovrval = b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVRVAL);
+	old_rf2_ovr = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2);
+	old_rf2_ovrval = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2_VAL);
+	old_phy_ctl = b43_phy_read(dev, B43_LPPHY_LP_PHY_CTL);
+	old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
+					B43_LPPHY_TX_PWR_CTL_CMD_MODE;
+ 
+ 	lpphy_set_tx_power_control(dev, B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
+	lpphy_disable_crs(dev);
+	loopback = lpphy_loopback(dev);
+	if (loopback == -1)
+		goto finish;
+	lpphy_set_rx_gain_by_index(dev, loopback);
+	b43_phy_maskset(dev, B43_LPPHY_LP_PHY_CTL, 0xFFBF, 0x40);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFFF8, 0x1);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFFC7, 0x8);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFF3F, 0xC0);
+	for (i = 128; i <= 159; i++) {
+		b43_radio_write(dev, B2062_N_RXBB_CALIB2, i);
+  		inner_sum = 0;
+		for (j = 5; j <= 25; j++) {
+			lpphy_run_ddfs(dev, 1, 1, j, j, 0);
+			if (!(lpphy_rx_iq_est(dev, 1000, 32, &iq_est)))
+				goto finish;
+			mean_sq_pwr = iq_est.i_pwr + iq_est.q_pwr;
+			if (j == 5)
+				tmp = mean_sq_pwr;
+			ideal_pwr = ((ideal_pwr_table[j-5] >> 3) + 1) >> 1;
+			normal_pwr = lpphy_qdiv_roundup(mean_sq_pwr, tmp, 12);
+			mean_sq_pwr = ideal_pwr - normal_pwr;
+			mean_sq_pwr *= mean_sq_pwr;
+			inner_sum += mean_sq_pwr;
+			if ((i = 128) || (inner_sum < mean_sq_pwr_min)) {
+				lpphy->rc_cap = i;
+				mean_sq_pwr_min = inner_sum;
+			}
+		}
+	}
+	lpphy_stop_ddfs(dev);
+
+finish:
+	lpphy_restore_crs(dev);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, old_rf_ovrval);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_0, old_rf_ovr);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVRVAL, old_afe_ovrval);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVR, old_afe_ovr);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, old_rf2_ovrval);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, old_rf2_ovr);
+	b43_phy_write(dev, B43_LPPHY_LP_PHY_CTL, old_phy_ctl);
+
+	lpphy_set_bb_mult(dev, old_bbmult);
+	if (old_txg_ovr) {
+		/*
+		 * SPEC FIXME: The specs say "get_tx_gains" here, which is
+		 * illogical. According to lwfinger, vendor driver v4.150.10.5
+		 * has a Set here, while v4.174.64.19 has a Get - regression in
+		 * the vendor driver? This should be tested this once the code
+		 * is testable.
+		 */
+		lpphy_set_tx_gains(dev, tx_gains);
+	}
+	lpphy_set_tx_power_control(dev, old_txpctl);
+	if (lpphy->rc_cap)
+		lpphy_set_rc_cap(dev);
+}
+
+static void lpphy_rev2plus_rc_calib(struct b43_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
+	u8 tmp = b43_radio_read(dev, B2063_RX_BB_SP8) & 0xFF;
+	int i;
+
+	b43_radio_write(dev, B2063_RX_BB_SP8, 0x0);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
+	b43_radio_mask(dev, B2063_PLL_SP1, 0xF7);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x15);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x70);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x52);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7D);
+
+	for (i = 0; i < 10000; i++) {
+		if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
+			break;
+		msleep(1);
+	}
+
+	if (!(b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2))
+		b43_radio_write(dev, B2063_RX_BB_SP8, tmp);
+
+	tmp = b43_radio_read(dev, B2063_TX_BB_SP3) & 0xFF;
+
+	b43_radio_write(dev, B2063_TX_BB_SP3, 0x0);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7C);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL2, 0x55);
+	b43_radio_write(dev, B2063_RC_CALIB_CTL3, 0x76);
+
+	if (crystal_freq == 24000000) {
+		b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0xFC);
+		b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x0);
+	} else {
+		b43_radio_write(dev, B2063_RC_CALIB_CTL4, 0x13);
+		b43_radio_write(dev, B2063_RC_CALIB_CTL5, 0x1);
+	}
+
+	b43_radio_write(dev, B2063_PA_SP7, 0x7D);
+
+	for (i = 0; i < 10000; i++) {
+		if (b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2)
+			break;
+		msleep(1);
+	}
+
+	if (!(b43_radio_read(dev, B2063_RC_CALIB_CTL6) & 0x2))
+		b43_radio_write(dev, B2063_TX_BB_SP3, tmp);
+
+	b43_radio_write(dev, B2063_RC_CALIB_CTL1, 0x7E);
+}
+
+static void lpphy_calibrate_rc(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+
+	if (dev->phy.rev >= 2) {
+		lpphy_rev2plus_rc_calib(dev);
+	} else if (!lpphy->rc_cap) {
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+			lpphy_rev0_1_rc_calib(dev);
+	} else {
+		lpphy_set_rc_cap(dev);
+	}
+}
+
 static void lpphy_set_tx_power_by_index(struct b43_wldev *dev, u8 index)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
-- 
1.6.2.4





From mb at bu3sch.de  Thu Aug 13 15:10:48 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 13 Aug 2009 15:10:48 +0200
Subject: [PATCH v3] b43: Implement RC calibration for rev.0/1 LP-PHYs
In-Reply-To: <4A8404B6.2070902@gmail.com>
References: <4A8404B6.2070902@gmail.com>
Message-ID: <200908131510.48958.mb@bu3sch.de>

On Thursday 13 August 2009 14:19:02 G?bor Stefanik wrote:
> Also implement get/set BB mult, get/set TX gain, set RX gain,
> disable/restore CRS, run/stop DDFS, RX IQ est and QDIV roundup
> in the process.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> Changes from v2->v3:
> -Two small spec updates/typo fixes, as suggested by Larry.
> 
> Changes from v1->v2:
> -Coding style fixes as suggested by Michael.
> -Added missing static to lpphy_qdiv_roundup.
> -Moved set_tx_power_control & related functions before rev0/1 RC calibration,
>  and removed forward declaration
> -Reordered variable declarations at the start of rev0_1_rc_calib.
> -The ideal power table is now static const.
> 
> Interdiff v1->v2 available @ http://b43.pastebin.com/f5fe6ba3c for easier review.
> 

Acked-by: Michael Buesch <mb at bu3sch.de>


-- 
Greetings, Michael.


From mb at bu3sch.de  Thu Aug 13 15:12:44 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 13 Aug 2009 15:12:44 +0200
Subject: [PATCH] b43: Update dummy transmission to match V4 specs
In-Reply-To: <4A832890.9010408@gmail.com>
References: <4A832890.9010408@gmail.com>
Message-ID: <200908131512.45006.mb@bu3sch.de>

On Wednesday 12 August 2009 22:39:44 G?bor Stefanik wrote:
> The V4 dummy transmission function has two extra bools in its
> prototype, so add a wrapper function for callers that expect the
> V3 version.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

Nah, please just convert all callers instead. There are not that many callers.
It's maybe about 10.

-- 
Greetings, Michael.


From mb at bu3sch.de  Thu Aug 13 15:15:59 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 13 Aug 2009 15:15:59 +0200
Subject: [PATCH] b43: LP-PHY: Initialize TX power control
In-Reply-To: <4A832940.6000807@gmail.com>
References: <4A832940.6000807@gmail.com>
Message-ID: <200908131515.59966.mb@bu3sch.de>

On Wednesday 12 August 2009 22:42:40 G?bor Stefanik wrote:
> The HW TX power control init still needs work.
> The SW init is complete according to the specs.

HW PCTL needs a serious amount of work in the common code, too.
For now I would focus to SW PCTL and fix HW PCTL later.

> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> This depends on both the rev0/1 RC calibration patch and the
> V4 dummy transmission patch I submitted earlier.
> 
> Larry, please check the SPEC TODO/SPEC FIXME comments.
> 
>  drivers/net/wireless/b43/phy_lp.c |  104 ++++++++++++++++++++++++++++++++++---
>  drivers/net/wireless/b43/phy_lp.h |    5 ++
>  2 files changed, 102 insertions(+), 7 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index e05981b..6ebaeb2 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -1258,18 +1258,108 @@ static void lpphy_calibration(struct b43_wldev *dev)
>  	b43_mac_enable(dev);
>  }
>  
> +static void lpphy_set_tssi_mux(struct b43_wldev *dev, enum tssi_mux_mode mode)
> +{
> +	if (mode != TSSI_MUX_EXT) {
> +		b43_radio_set(dev, B2063_PA_SP1, 0x2);
> +		b43_phy_set(dev, B43_PHY_OFDM(0xF3), 0x1000);
> +		b43_radio_write(dev, B2063_PA_CTL10, 0x51);
> +		if (mode == TSSI_MUX_POSTPA) {
> +			b43_radio_mask(dev, B2063_PA_SP1, 0xFFFE);
> +			b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFC7);
> +		} else {
> +			b43_radio_maskset(dev, B2063_PA_SP1, 0xFFFE, 0x1);
> +			b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVRVAL,
> +					0xFFC7, 0x20);
> +		}
> +	} else {
> +		//SPEC TODO
> +	}
> +}
> +
> +static void lpphy_tx_pctl_init_hw(struct b43_wldev *dev)
> +{
> +	u16 tmp;
> +	int i;
> +
> +	//SPEC TODO Call LP PHY Clear TX Power offsets
> +	for (i = 0; i < 64; i++) {
> +		if (dev->phy.rev >= 2)
> +			b43_lptab_write(dev, B43_LPTAB32(7, i+1), i);
                                                            ^^^
Please keep in mind to use spaces all the time. It is our coding style and I think
we should stick with it.

> +	tmp = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_STAT);
> +	if (tmp & 0x8000)
> +		b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_IDLETSSI,
> +				0xFFC0, (tmp & 0xFF) - 32);

Curly brackets for multiline indents, please.


-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Thu Aug 13 16:12:51 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Thu, 13 Aug 2009 16:12:51 +0200
Subject: [PATCH] b43: LP-PHY: Initialize TX power control
In-Reply-To: <200908131515.59966.mb@bu3sch.de>
References: <4A832940.6000807@gmail.com> <200908131515.59966.mb@bu3sch.de>
Message-ID: <69e28c910908130712j28465ca0qae8eaad0a4a490ee@mail.gmail.com>

2009/8/13 Michael Buesch <mb at bu3sch.de>:
> On Wednesday 12 August 2009 22:42:40 G?bor Stefanik wrote:
>> The HW TX power control init still needs work.
>> The SW init is complete according to the specs.
>
> HW PCTL needs a serious amount of work in the common code, too.
> For now I would focus to SW PCTL and fix HW PCTL later.
>
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> This depends on both the rev0/1 RC calibration patch and the
>> V4 dummy transmission patch I submitted earlier.
>>
>> Larry, please check the SPEC TODO/SPEC FIXME comments.
>>
>> ?drivers/net/wireless/b43/phy_lp.c | ?104 ++++++++++++++++++++++++++++++++++---
>> ?drivers/net/wireless/b43/phy_lp.h | ? ?5 ++
>> ?2 files changed, 102 insertions(+), 7 deletions(-)
>>
>> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
>> index e05981b..6ebaeb2 100644
>> --- a/drivers/net/wireless/b43/phy_lp.c
>> +++ b/drivers/net/wireless/b43/phy_lp.c
>> @@ -1258,18 +1258,108 @@ static void lpphy_calibration(struct b43_wldev *dev)
>> ? ? ? b43_mac_enable(dev);
>> ?}
>>
>> +static void lpphy_set_tssi_mux(struct b43_wldev *dev, enum tssi_mux_mode mode)
>> +{
>> + ? ? if (mode != TSSI_MUX_EXT) {
>> + ? ? ? ? ? ? b43_radio_set(dev, B2063_PA_SP1, 0x2);
>> + ? ? ? ? ? ? b43_phy_set(dev, B43_PHY_OFDM(0xF3), 0x1000);
>> + ? ? ? ? ? ? b43_radio_write(dev, B2063_PA_CTL10, 0x51);
>> + ? ? ? ? ? ? if (mode == TSSI_MUX_POSTPA) {
>> + ? ? ? ? ? ? ? ? ? ? b43_radio_mask(dev, B2063_PA_SP1, 0xFFFE);
>> + ? ? ? ? ? ? ? ? ? ? b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFC7);
>> + ? ? ? ? ? ? } else {
>> + ? ? ? ? ? ? ? ? ? ? b43_radio_maskset(dev, B2063_PA_SP1, 0xFFFE, 0x1);
>> + ? ? ? ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVRVAL,
>> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0xFFC7, 0x20);
>> + ? ? ? ? ? ? }
>> + ? ? } else {
>> + ? ? ? ? ? ? //SPEC TODO
>> + ? ? }
>> +}
>> +
>> +static void lpphy_tx_pctl_init_hw(struct b43_wldev *dev)
>> +{
>> + ? ? u16 tmp;
>> + ? ? int i;
>> +
>> + ? ? //SPEC TODO Call LP PHY Clear TX Power offsets
>> + ? ? for (i = 0; i < 64; i++) {
>> + ? ? ? ? ? ? if (dev->phy.rev >= 2)
>> + ? ? ? ? ? ? ? ? ? ? b43_lptab_write(dev, B43_LPTAB32(7, i+1), i);
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?^^^
> Please keep in mind to use spaces all the time. It is our coding style and I think
> we should stick with it.

Will do.

>
>> + ? ? tmp = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_STAT);
>> + ? ? if (tmp & 0x8000)
>> + ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_IDLETSSI,
>> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0xFFC0, (tmp & 0xFF) - 32);
>
> Curly brackets for multiline indents, please.

Will do.
V2 will also be updated for the dummy transmission change.

>
>
> --
> Greetings, Michael.
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Thu Aug 13 16:51:51 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 13 Aug 2009 16:51:51 +0200
Subject: [PATCH v2] b43: Update dummy transmission to match V4 specs
Message-ID: <4A842887.2080109@gmail.com>

The V4 dummy transmission has two extra bools in its prototype,
so update all callers with the 2 bools.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
v2: Convert all callers to v4, and drop the v3->v4 wrapper.

 drivers/net/wireless/b43/lo.c    |    2 +-
 drivers/net/wireless/b43/main.c  |   42 ++++++++++++++++++++++---------------
 drivers/net/wireless/b43/main.h  |    2 +-
 drivers/net/wireless/b43/phy_g.c |    6 ++--
 drivers/net/wireless/b43/wa.c    |    2 +-
 5 files changed, 31 insertions(+), 23 deletions(-)

diff --git a/drivers/net/wireless/b43/lo.c b/drivers/net/wireless/b43/lo.c
index 22d0fbd..976104f 100644
--- a/drivers/net/wireless/b43/lo.c
+++ b/drivers/net/wireless/b43/lo.c
@@ -477,7 +477,7 @@ static void lo_measure_setup(struct b43_wldev *dev,
 	} else
 		b43_phy_write(dev, B43_PHY_CCK(0x2B), 0x0802);
 	if (phy->rev >= 2)
-		b43_dummy_transmission(dev);
+		b43_dummy_transmission(dev, false, true);
 	b43_gphy_channel_switch(dev, 6, 0);
 	b43_radio_read16(dev, 0x51);	/* dummy read */
 	if (phy->type == B43_PHYTYPE_G)
diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index cb4a871..fbcbe4f 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -684,9 +684,9 @@ static void b43_synchronize_irq(struct b43_wldev *dev)
 }
 
 /* DummyTransmission function, as documented on
- * http://bcm-specs.sipsolutions.net/DummyTransmission
+ * http://bcm-v4.sipsolutions.net/802.11/DummyTransmission
  */
-void b43_dummy_transmission(struct b43_wldev *dev)
+void b43_dummy_transmission(struct b43_wldev *dev, bool ofdm, bool pa_on)
 {
 	struct b43_wl *wl = dev->wl;
 	struct b43_phy *phy = &dev->phy;
@@ -700,19 +700,12 @@ void b43_dummy_transmission(struct b43_wldev *dev)
 		0x00000000,
 	};
 
-	switch (phy->type) {
-	case B43_PHYTYPE_A:
+	if (ofdm) {
 		max_loop = 0x1E;
 		buffer[0] = 0x000201CC;
-		break;
-	case B43_PHYTYPE_B:
-	case B43_PHYTYPE_G:
+	} else {
 		max_loop = 0xFA;
 		buffer[0] = 0x000B846E;
-		break;
-	default:
-		B43_WARN_ON(1);
-		return;
 	}
 
 	spin_lock_irq(&wl->irq_lock);
@@ -721,20 +714,35 @@ void b43_dummy_transmission(struct b43_wldev *dev)
 	for (i = 0; i < 5; i++)
 		b43_ram_write(dev, i * 4, buffer[i]);
 
-	/* Commit writes */
-	b43_read32(dev, B43_MMIO_MACCTL);
-
 	b43_write16(dev, 0x0568, 0x0000);
-	b43_write16(dev, 0x07C0, 0x0000);
-	value = ((phy->type == B43_PHYTYPE_A) ? 1 : 0);
+	if (dev->dev->id.revision < 11)
+		b43_write16(dev, 0x07C0, 0x0000);
+	else
+		b43_write16(dev, 0x07C0, 0x0100);
+	value = (ofdm ? 0x41 : 0x40);
 	b43_write16(dev, 0x050C, value);
+	if ((phy->type == B43_PHYTYPE_N) || (phy->type == B43_PHYTYPE_LP))
+		b43_write16(dev, 0x0514, 0x1A02);
 	b43_write16(dev, 0x0508, 0x0000);
 	b43_write16(dev, 0x050A, 0x0000);
 	b43_write16(dev, 0x054C, 0x0000);
 	b43_write16(dev, 0x056A, 0x0014);
 	b43_write16(dev, 0x0568, 0x0826);
 	b43_write16(dev, 0x0500, 0x0000);
-	b43_write16(dev, 0x0502, 0x0030);
+	if (!pa_on && (phy->type == B43_PHYTYPE_N)) {
+		//SPEC TODO
+	}
+
+	switch (phy->type) {
+	case B43_PHYTYPE_N:
+		b43_write16(dev, 0x0502, 0x00D0);
+		break;
+	case B43_PHYTYPE_LP:
+		b43_write16(dev, 0x0502, 0x0050);
+		break;
+	default:
+		b43_write16(dev, 0x0502, 0x0030);
+	}
 
 	if (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5)
 		b43_radio_write16(dev, 0x0051, 0x0017);
diff --git a/drivers/net/wireless/b43/main.h b/drivers/net/wireless/b43/main.h
index 40abcf5..2d23f65 100644
--- a/drivers/net/wireless/b43/main.h
+++ b/drivers/net/wireless/b43/main.h
@@ -124,7 +124,7 @@ void __b43_shm_write16(struct b43_wldev *dev, u16 routing, u16 offset, u16 value
 u64 b43_hf_read(struct b43_wldev *dev);
 void b43_hf_write(struct b43_wldev *dev, u64 value);
 
-void b43_dummy_transmission(struct b43_wldev *dev);
+void b43_dummy_transmission(struct b43_wldev *dev, bool ofdm, bool pa_on);
 
 void b43_wireless_core_reset(struct b43_wldev *dev, u32 flags);
 
diff --git a/drivers/net/wireless/b43/phy_g.c b/drivers/net/wireless/b43/phy_g.c
index e7b98f0..e75a39d 100644
--- a/drivers/net/wireless/b43/phy_g.c
+++ b/drivers/net/wireless/b43/phy_g.c
@@ -333,7 +333,7 @@ static void b43_set_all_gains(struct b43_wldev *dev,
 		b43_phy_maskset(dev, 0x04A1, 0xBFBF, tmp);
 		b43_phy_maskset(dev, 0x04A2, 0xBFBF, tmp);
 	}
-	b43_dummy_transmission(dev);
+	b43_dummy_transmission(dev, false, true);
 }
 
 static void b43_set_original_gains(struct b43_wldev *dev)
@@ -365,7 +365,7 @@ static void b43_set_original_gains(struct b43_wldev *dev)
 	b43_phy_maskset(dev, 0x04A0, 0xBFBF, 0x4040);
 	b43_phy_maskset(dev, 0x04A1, 0xBFBF, 0x4040);
 	b43_phy_maskset(dev, 0x04A2, 0xBFBF, 0x4000);
-	b43_dummy_transmission(dev);
+	b43_dummy_transmission(dev, false, true);
 }
 
 /* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
@@ -1964,7 +1964,7 @@ static void b43_phy_init_pctl(struct b43_wldev *dev)
 			}
 			b43_set_txpower_g(dev, &bbatt, &rfatt, 0);
 		}
-		b43_dummy_transmission(dev);
+		b43_dummy_transmission(dev, false, true);
 		gphy->cur_idle_tssi = b43_phy_read(dev, B43_PHY_ITSSI);
 		if (B43_DEBUG) {
 			/* Current-Idle-TSSI sanity check. */
diff --git a/drivers/net/wireless/b43/wa.c b/drivers/net/wireless/b43/wa.c
index e1e20f6..73e97fa 100644
--- a/drivers/net/wireless/b43/wa.c
+++ b/drivers/net/wireless/b43/wa.c
@@ -37,7 +37,7 @@ static void b43_wa_papd(struct b43_wldev *dev)
 	backup = b43_ofdmtab_read16(dev, B43_OFDMTAB_PWRDYN2, 0);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_PWRDYN2, 0, 7);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_UNKNOWN_APHY, 0, 0);
-	b43_dummy_transmission(dev);
+	b43_dummy_transmission(dev, true, true);
 	b43_ofdmtab_write16(dev, B43_OFDMTAB_PWRDYN2, 0, backup);
 }
 
-- 
1.6.2.4





From netrolller.3d at gmail.com  Thu Aug 13 16:54:44 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 13 Aug 2009 16:54:44 +0200
Subject: [PATCH v2] b43: LP-PHY: Initialize TX power control
Message-ID: <4A842934.2060206@gmail.com>

The HW TX power control init still needs work.
The SW init is complete according to the specs.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
v2: Address Michael's comments, and update for the dummy transmission changes.

This depends on both the rev0/1 RC calibration patch and the
updated V4 dummy transmission patch I submitted earlier.

Larry, please review the SPEC TODO/SPEC FIXME comments!

 drivers/net/wireless/b43/phy_lp.c |  105 ++++++++++++++++++++++++++++++++++---
 drivers/net/wireless/b43/phy_lp.h |    5 ++
 2 files changed, 103 insertions(+), 7 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 2441a8d..b4e51f0 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1257,18 +1257,109 @@ static void lpphy_calibration(struct b43_wldev *dev)
 	b43_mac_enable(dev);
 }
 
+static void lpphy_set_tssi_mux(struct b43_wldev *dev, enum tssi_mux_mode mode)
+{
+	if (mode != TSSI_MUX_EXT) {
+		b43_radio_set(dev, B2063_PA_SP1, 0x2);
+		b43_phy_set(dev, B43_PHY_OFDM(0xF3), 0x1000);
+		b43_radio_write(dev, B2063_PA_CTL10, 0x51);
+		if (mode == TSSI_MUX_POSTPA) {
+			b43_radio_mask(dev, B2063_PA_SP1, 0xFFFE);
+			b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFC7);
+		} else {
+			b43_radio_maskset(dev, B2063_PA_SP1, 0xFFFE, 0x1);
+			b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVRVAL,
+					0xFFC7, 0x20);
+		}
+	} else {
+		//SPEC TODO
+	}
+}
+
+static void lpphy_tx_pctl_init_hw(struct b43_wldev *dev)
+{
+	u16 tmp;
+	int i;
+
+	//SPEC TODO Call LP PHY Clear TX Power offsets
+	for (i = 0; i < 64; i++) {
+		if (dev->phy.rev >= 2)
+			b43_lptab_write(dev, B43_LPTAB32(7, i + 1), i);
+		else
+			b43_lptab_write(dev, B43_LPTAB32(10, i + 1), i);
+	}
+
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_NNUM, 0xFF00, 0xFF);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_NNUM, 0x8FFF, 0x5000);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_IDLETSSI, 0xFFC0, 0x1F);
+	if (dev->phy.rev < 2) {
+		b43_phy_mask(dev, B43_LPPHY_LP_PHY_CTL, 0xEFFF);
+		b43_phy_maskset(dev, B43_LPPHY_LP_PHY_CTL, 0xDFFF, 0x2000);
+	} else {
+		b43_phy_mask(dev, B43_PHY_OFDM(0x103), 0xFFFE);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x103), 0xFFFB, 0x4);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x103), 0xFFEF, 0x10);
+		b43_radio_maskset(dev, B2063_IQ_CALIB_CTL2, 0xF3, 0x1);
+		lpphy_set_tssi_mux(dev, TSSI_MUX_POSTPA);
+	}
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_IDLETSSI, 0x7FFF, 0x8000);
+	b43_phy_mask(dev, B43_LPPHY_TX_PWR_CTL_DELTAPWR_LIMIT, 0xFF);
+	b43_phy_write(dev, B43_LPPHY_TX_PWR_CTL_DELTAPWR_LIMIT, 0xA);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_CMD,
+			(u16)~B43_LPPHY_TX_PWR_CTL_CMD_MODE,
+			B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
+	b43_phy_mask(dev, B43_LPPHY_TX_PWR_CTL_NNUM, 0xF8FF);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_CMD,
+			(u16)~B43_LPPHY_TX_PWR_CTL_CMD_MODE,
+			B43_LPPHY_TX_PWR_CTL_CMD_MODE_SW);
+
+	if (dev->phy.rev < 2) {
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_0, 0xEFFF, 0x1000);
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xEFFF);
+	} else {
+		lpphy_set_tx_power_by_index(dev, 0x7F);
+	}
+
+	b43_dummy_transmission(dev, true, true);
+
+	tmp = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_STAT);
+	if (tmp & 0x8000) {
+		b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_IDLETSSI,
+				0xFFC0, (tmp & 0xFF) - 32);
+	}
+
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xEFFF);
+
+	// (SPEC?) TODO Set "Target TX frequency" variable to 0
+	// SPEC FIXME "Set BB Multiplier to 0xE000" impossible - bb_mult is u8!
+}
+
+static void lpphy_tx_pctl_init_sw(struct b43_wldev *dev)
+{
+	struct lpphy_tx_gains gains;
+
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		gains.gm = 4;
+		gains.pad = 12;
+		gains.pga = 12;
+		gains.dac = 0;
+	} else {
+		gains.gm = 7;
+		gains.pad = 14;
+		gains.pga = 15;
+		gains.dac = 0;
+	}
+	lpphy_set_tx_gains(dev, gains);
+	lpphy_set_bb_mult(dev, 150);
+}
+
 /* Initialize TX power control */
 static void lpphy_tx_pctl_init(struct b43_wldev *dev)
 {
 	if (0/*FIXME HWPCTL capable */) {
-		//TODO
+		lpphy_tx_pctl_init_hw(dev);
 	} else { /* This device is only software TX power control capable. */
-		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
-			//TODO
-		} else {
-			//TODO
-		}
-		//TODO set BB multiplier to 0x0096
+		lpphy_tx_pctl_init_sw(dev);
 	}
 }
 
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 0461d5b..4eab760 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -886,6 +886,11 @@ struct b43_phy_lp {
 	u16 dig_flt_state[9];
 };
 
+enum tssi_mux_mode {
+	TSSI_MUX_PREPA,
+	TSSI_MUX_POSTPA,
+	TSSI_MUX_EXT,
+};
 
 struct b43_phy_operations;
 extern const struct b43_phy_operations b43_phyops_lp;
-- 
1.6.2.4





From netrolller.3d at gmail.com  Thu Aug 13 17:02:21 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 13 Aug 2009 17:02:21 +0200
Subject: [RFC/RFT] b43: LP-PHY: Implement channel switching for rev2+/B2063
	radio
Message-ID: <4A842AFD.1020903@gmail.com>

Rev.2+/B2063 will now hopefully show some signs of life, though
it won't work at full performance, as calibration is still missing.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
If you have an LP-PHY device with the B2063 radio, please test!

Larry&Michael,
There is some pretty arcane stuff in op_switch_channel, please
review it closely!

 drivers/net/wireless/b43/phy_lp.c |  395 ++++++++++++++++++++++++++++++++++++-
 1 files changed, 390 insertions(+), 5 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index b4e51f0..716bb87 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -142,10 +142,9 @@ static void lpphy_read_band_sprom(struct b43_wldev *dev)
 	}
 }
 
-static void lpphy_adjust_gain_table(struct b43_wldev *dev)
+static void lpphy_adjust_gain_table(struct b43_wldev *dev, u32 freq)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
-	u32 freq = dev->wl->hw->conf.channel->center_freq;
 	u16 temp[3];
 	u16 isolation;
 
@@ -170,6 +169,8 @@ static void lpphy_adjust_gain_table(struct b43_wldev *dev)
 
 static void lpphy_table_init(struct b43_wldev *dev)
 {
+	u32 freq = dev->wl->hw->conf.channel->center_freq;
+
 	if (dev->phy.rev < 2)
 		lpphy_rev0_1_table_init(dev);
 	else
@@ -178,7 +179,7 @@ static void lpphy_table_init(struct b43_wldev *dev)
 	lpphy_init_tx_gain_table(dev);
 
 	if (dev->phy.rev < 2)
-		lpphy_adjust_gain_table(dev);
+		lpphy_adjust_gain_table(dev, freq);
 }
 
 static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
@@ -1369,7 +1370,7 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
 	lpphy_calibrate_rc(dev);
-	//TODO set channel
+	b43_switch_channel(dev, dev->wl->hw->conf.channel->hw_value);
 	lpphy_tx_pctl_init(dev);
 	lpphy_calibration(dev);
 	//TODO ACI init
@@ -1419,10 +1420,394 @@ static void b43_lpphy_op_software_rfkill(struct b43_wldev *dev,
 	//TODO
 }
 
+static void lpphy_b2062_tune(struct b43_wldev *dev,
+			     unsigned int channel)
+{
+	//TODO
+}
+
+struct b2063_channel {
+	u8 channel;
+	u16 freq;
+	u8 data[12];
+};
+
+static const struct b2063_channel b2063_chantbl[] = {
+	{ .channel = 1, .freq = 2412, .data[0] = 0x6F, .data[1] = 0x3C,
+	  .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 2, .freq = 2417, .data[0] = 0x6F, .data[1] = 0x3C,
+	  .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 3, .freq = 2422, .data[0] = 0x6F, .data[1] = 0x3C,
+	  .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 4, .freq = 2427, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 5, .freq = 2432, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 6, .freq = 2437, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 7, .freq = 2442, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 8, .freq = 2447, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 9, .freq = 2452, .data[0] = 0x6F, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 10, .freq = 2457, .data[0] = 0x6F, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 11, .freq = 2462, .data[0] = 0x6E, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 12, .freq = 2467, .data[0] = 0x6E, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 13, .freq = 2472, .data[0] = 0x6E, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 14, .freq = 2484, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 34, .freq = 5170, .data[0] = 0x6A, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x02, .data[5] = 0x05,
+	  .data[6] = 0x0D, .data[7] = 0x0D, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 38, .freq = 5190, .data[0] = 0x6A, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
+	  .data[6] = 0x0C, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 42, .freq = 5210, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
+	  .data[6] = 0x0B, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x70,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 46, .freq = 5230, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x03,
+	  .data[6] = 0x0A, .data[7] = 0x0B, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 36, .freq = 5180, .data[0] = 0x6A, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x05,
+	  .data[6] = 0x0D, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 40, .freq = 5200, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
+	  .data[6] = 0x0C, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x70,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 44, .freq = 5220, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x04,
+	  .data[6] = 0x0B, .data[7] = 0x0B, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 48, .freq = 5240, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x03,
+	  .data[6] = 0x0A, .data[7] = 0x0A, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 52, .freq = 5260, .data[0] = 0x68, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x02,
+	  .data[6] = 0x09, .data[7] = 0x09, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 56, .freq = 5280, .data[0] = 0x68, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x01,
+	  .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
+	  .data[10] = 0x10, .data[11] = 0x00, },
+	{ .channel = 60, .freq = 5300, .data[0] = 0x68, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x01,
+	  .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
+	  .data[10] = 0x10, .data[11] = 0x00, },
+	{ .channel = 64, .freq = 5320, .data[0] = 0x67, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
+	  .data[10] = 0x10, .data[11] = 0x00, },
+	{ .channel = 100, .freq = 5500, .data[0] = 0x64, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x02, .data[7] = 0x01, .data[8] = 0x77, .data[9] = 0x20,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 104, .freq = 5520, .data[0] = 0x64, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x01, .data[7] = 0x01, .data[8] = 0x77, .data[9] = 0x20,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 108, .freq = 5540, .data[0] = 0x63, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x01, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 112, .freq = 5560, .data[0] = 0x63, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 116, .freq = 5580, .data[0] = 0x62, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 120, .freq = 5600, .data[0] = 0x62, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 124, .freq = 5620, .data[0] = 0x62, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 128, .freq = 5640, .data[0] = 0x61, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 132, .freq = 5660, .data[0] = 0x61, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 136, .freq = 5680, .data[0] = 0x61, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 140, .freq = 5700, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 149, .freq = 5745, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 153, .freq = 5765, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 157, .freq = 5785, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 161, .freq = 5805, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 165, .freq = 5825, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 184, .freq = 4920, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x09, .data[5] = 0x0E,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xC0,
+	  .data[10] = 0x50, .data[11] = 0x00, },
+	{ .channel = 188, .freq = 4940, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x09, .data[5] = 0x0D,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xB0,
+	  .data[10] = 0x50, .data[11] = 0x00, },
+	{ .channel = 192, .freq = 4960, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0C,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xB0,
+	  .data[10] = 0x50, .data[11] = 0x00, },
+	{ .channel = 196, .freq = 4980, .data[0] = 0x6D, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0C,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 200, .freq = 5000, .data[0] = 0x6D, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0B,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 204, .freq = 5020, .data[0] = 0x6D, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0A,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 208, .freq = 5040, .data[0] = 0x6C, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x07, .data[5] = 0x09,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 212, .freq = 5060, .data[0] = 0x6C, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x06, .data[5] = 0x08,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 216, .freq = 5080, .data[0] = 0x6C, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x05, .data[5] = 0x08,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+};
+
+static void lpphy_b2063_vco_calib(struct b43_wldev *dev)
+{
+	u16 tmp;
+
+	b43_phy_mask(dev, B2063_PLL_SP1, ~0x40);
+	tmp = b43_phy_read(dev, B2063_PLL_JTAG_CALNRST) & 0xF8;
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp);
+	udelay(1);
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x4);
+	udelay(1);
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x6);
+	udelay(1);
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x7);
+	udelay(300);
+	b43_phy_set(dev, B2063_PLL_SP1, 0x40);
+}
+
+static void lpphy_b2063_tune(struct b43_wldev *dev,
+			     unsigned int channel)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+
+	struct b2063_channel chandata;
+	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
+	u32 freqref, vco_freq, val1, val2, val3, timeout, timeoutref, count;
+	u16 old_comm15, scale;
+	u32 tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
+	int i, div = (crystal_freq <= 26000000 ? 1 : 2);
+
+	memset(&chandata, 0, sizeof(chandata));
+
+	for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
+		if (b2063_chantbl[i].channel == channel) {
+			chandata = b2063_chantbl[i];
+			break;
+		}
+	}
+
+	B43_WARN_ON(!chandata.channel);
+
+	b43_radio_write(dev, B2063_LOGEN_VCOBUF1, chandata.data[0]);
+	b43_radio_write(dev, B2063_LOGEN_MIXER2, chandata.data[1]);
+	b43_radio_write(dev, B2063_LOGEN_BUF2, chandata.data[2]);
+	b43_radio_write(dev, B2063_LOGEN_RCCR1, chandata.data[3]);
+	b43_radio_write(dev, B2063_A_RX_1ST3, chandata.data[4]);
+	b43_radio_write(dev, B2063_A_RX_2ND1, chandata.data[5]);
+	b43_radio_write(dev, B2063_A_RX_2ND4, chandata.data[6]);
+	b43_radio_write(dev, B2063_A_RX_2ND7, chandata.data[7]);
+	b43_radio_write(dev, B2063_A_RX_PS6, chandata.data[8]);
+	b43_radio_write(dev, B2063_TX_RF_CTL2, chandata.data[9]);
+	b43_radio_write(dev, B2063_TX_RF_CTL5, chandata.data[10]);
+	b43_radio_write(dev, B2063_PA_CTL11, chandata.data[11]);
+
+	old_comm15 = b43_radio_read(dev, B2063_COMM15);
+	b43_radio_set(dev, B2063_COMM15, 0x1E);
+
+	if (chandata.freq > 4000) /* spec says 2484, but 4000 is safer */
+		vco_freq = chandata.freq << 1;
+	else
+		vco_freq = chandata.freq << 2;
+
+	freqref = crystal_freq * 3;
+	val1 = lpphy_qdiv_roundup(crystal_freq, 1000000, 16);
+	val2 = lpphy_qdiv_roundup(crystal_freq, 1000000 * div, 16);
+	val3 = lpphy_qdiv_roundup(vco_freq, 3, 16);
+	timeout = ((((8 * crystal_freq) / (div * 5000000)) + 1) >> 1) - 1;
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB3, 0x2);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB6,
+			  0xFFF8, timeout >> 2);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB7,
+			  0xFF9F,timeout << 5);
+
+	timeoutref = ((((8 * crystal_freq) / (div * (timeout + 1))) +
+						999999) / 1000000) + 1;
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB5, timeoutref);
+
+	count = lpphy_qdiv_roundup(val3, val2 + 16, 16);
+	count *= (timeout + 1) * (timeoutref + 1);
+	count--;
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB7,
+						0xF0, count >> 8);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB8, count & 0xFF);
+
+	tmp1 = ((val3 * 62500) / freqref) << 4;
+	tmp2 = ((val3 * 62500) % freqref) << 4;
+	while (tmp2 >= freqref) {
+		tmp1++;
+		tmp2 -= freqref;
+	}
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG1, 0xFFE0, tmp1 >> 4);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG2, 0xFE0F, tmp1 << 4);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG2, 0xFFF0, tmp1 >> 16);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_SG3, (tmp2 >> 8) & 0xFF);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_SG4, tmp2 & 0xFF);
+
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF1, 0xB9);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF2, 0x88);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF3, 0x28);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF4, 0x63);
+
+	tmp3 = ((41 * (val3 - 3000)) /1200) + 27;
+	tmp4 = lpphy_qdiv_roundup(132000 * tmp1, 8451, 16);
+
+	if ((tmp4 + tmp3 - 1) / tmp3 > 60) {
+		scale = 1;
+		tmp5 = ((tmp4 + tmp3) / (tmp3 << 1)) - 8;
+	} else {
+		scale = 0;
+		tmp5 = ((tmp4 + (tmp3 >> 1)) / tmp3) - 8;
+	}
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFC0, tmp5);
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFBF, scale << 6);
+
+	tmp6 = lpphy_qdiv_roundup(100 * val1, val3, 16);
+	tmp6 *= (tmp5 * 8) * (scale + 1);
+	if (tmp6 > 150)
+		tmp6 = 0;
+
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFE0, tmp6);
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFDF, scale << 5);
+
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFFFB, 0x4);
+	if (crystal_freq > 26000000)
+		b43_phy_set(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0x2);
+	else
+		b43_phy_mask(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFD);
+
+	if (val1 == 45)
+		b43_phy_set(dev, B2063_PLL_JTAG_PLL_VCO1, 0x2);
+	else
+		b43_phy_mask(dev, B2063_PLL_JTAG_PLL_VCO1, 0xFD);
+
+	b43_phy_set(dev, B2063_PLL_SP2, 0x3);
+	udelay(1);
+	b43_phy_mask(dev, B2063_PLL_SP2, 0xFFFC);
+	lpphy_b2063_vco_calib(dev);
+	b43_radio_write(dev, B2063_COMM15, old_comm15);
+}
+
 static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
 				       unsigned int new_channel)
 {
-	//TODO
+	struct b2063_channel chandata;
+	int i;
+
+	memset(&chandata, 0, sizeof(chandata));
+
+	//FIXME this abuses the 2063 channel table for chan2freq purposes!
+	for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
+		if (b2063_chantbl[i].channel == new_channel) {
+			chandata = b2063_chantbl[i];
+			break;
+		}
+	}
+
+	B43_WARN_ON(!chandata.channel);
+
+	/* FIXME this should be the last thing done, even after generic
+	 * parts - does it matter?
+	 * SPEC FIXME should this write channel, freq, chanspec or cookie?
+	 */
+	b43_write16(dev, B43_MMIO_CHANNEL, new_channel);
+	if (dev->phy.radio_ver == 0x2063) {
+		lpphy_b2063_tune(dev, new_channel);
+	} else {
+		lpphy_b2062_tune(dev, new_channel);
+		//TODO Japan filter
+	}
+	lpphy_adjust_gain_table(dev, chandata.freq);
 	return 0;
 }
 
-- 
1.6.2.4





From Larry.Finger at lwfinger.net  Thu Aug 13 17:06:29 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 13 Aug 2009 10:06:29 -0500
Subject: [PATCH v2] b43: LP-PHY: Initialize TX power control
In-Reply-To: <4A842934.2060206@gmail.com>
References: <4A842934.2060206@gmail.com>
Message-ID: <4A842BF5.8090704@lwfinger.net>

G?bor Stefanik wrote:
> The HW TX power control init still needs work.
> The SW init is complete according to the specs.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> v2: Address Michael's comments, and update for the dummy transmission
> changes.
> 
> This depends on both the rev0/1 RC calibration patch and the
> updated V4 dummy transmission patch I submitted earlier.
> 
> Larry, please review the SPEC TODO/SPEC FIXME comments!
> 
> drivers/net/wireless/b43/phy_lp.c |  105
> ++++++++++++++++++++++++++++++++++---
> drivers/net/wireless/b43/phy_lp.h |    5 ++
> 2 files changed, 103 insertions(+), 7 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index 2441a8d..b4e51f0 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -1257,18 +1257,109 @@ static void lpphy_calibration(struct b43_wldev
> *dev)
>     b43_mac_enable(dev);
> }
> 
> +static void lpphy_set_tssi_mux(struct b43_wldev *dev, enum
> tssi_mux_mode mode)
> +{
> +    if (mode != TSSI_MUX_EXT) {
> +        b43_radio_set(dev, B2063_PA_SP1, 0x2);
> +        b43_phy_set(dev, B43_PHY_OFDM(0xF3), 0x1000);
> +        b43_radio_write(dev, B2063_PA_CTL10, 0x51);
> +        if (mode == TSSI_MUX_POSTPA) {
> +            b43_radio_mask(dev, B2063_PA_SP1, 0xFFFE);
> +            b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFC7);
> +        } else {
> +            b43_radio_maskset(dev, B2063_PA_SP1, 0xFFFE, 0x1);
> +            b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVRVAL,
> +                    0xFFC7, 0x20);
> +        }
> +    } else {
> +        //SPEC TODO

Put a WARN_ON(1) here. This branch would be an error. No, I don't
understand it either!

Larry





From netrolller.3d at gmail.com  Thu Aug 13 17:27:31 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 13 Aug 2009 17:27:31 +0200
Subject: [PATCH v3] b43: LP-PHY: Initialize TX power control
Message-ID: <4A8430E3.5020703@gmail.com>

The HW TX power control init still needs work.
The SW init is complete according to the specs.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
v3: WARN_ON() setting TSSI mux mode to Ext, per Larry's suggestion.
v2: Address Michael's comments, and update for the dummy transmission changes.

This depends on both the rev0/1 RC calibration patch and the
updated V4 dummy transmission patch I submitted earlier.

Larry, please review the SPEC TODO/SPEC FIXME comments!

 drivers/net/wireless/b43/phy_lp.c |  105 ++++++++++++++++++++++++++++++++++---
 drivers/net/wireless/b43/phy_lp.h |    5 ++
 2 files changed, 103 insertions(+), 7 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 2441a8d..b4e51f0 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1257,18 +1257,109 @@ static void lpphy_calibration(struct b43_wldev *dev)
 	b43_mac_enable(dev);
 }
 
+static void lpphy_set_tssi_mux(struct b43_wldev *dev, enum tssi_mux_mode mode)
+{
+	if (mode != TSSI_MUX_EXT) {
+		b43_radio_set(dev, B2063_PA_SP1, 0x2);
+		b43_phy_set(dev, B43_PHY_OFDM(0xF3), 0x1000);
+		b43_radio_write(dev, B2063_PA_CTL10, 0x51);
+		if (mode == TSSI_MUX_POSTPA) {
+			b43_radio_mask(dev, B2063_PA_SP1, 0xFFFE);
+			b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFC7);
+		} else {
+			b43_radio_maskset(dev, B2063_PA_SP1, 0xFFFE, 0x1);
+			b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVRVAL,
+					0xFFC7, 0x20);
+		}
+	} else {
+		B43_WARN_ON(1);
+	}
+}
+
+static void lpphy_tx_pctl_init_hw(struct b43_wldev *dev)
+{
+	u16 tmp;
+	int i;
+
+	//SPEC TODO Call LP PHY Clear TX Power offsets
+	for (i = 0; i < 64; i++) {
+		if (dev->phy.rev >= 2)
+			b43_lptab_write(dev, B43_LPTAB32(7, i + 1), i);
+		else
+			b43_lptab_write(dev, B43_LPTAB32(10, i + 1), i);
+	}
+
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_NNUM, 0xFF00, 0xFF);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_NNUM, 0x8FFF, 0x5000);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_IDLETSSI, 0xFFC0, 0x1F);
+	if (dev->phy.rev < 2) {
+		b43_phy_mask(dev, B43_LPPHY_LP_PHY_CTL, 0xEFFF);
+		b43_phy_maskset(dev, B43_LPPHY_LP_PHY_CTL, 0xDFFF, 0x2000);
+	} else {
+		b43_phy_mask(dev, B43_PHY_OFDM(0x103), 0xFFFE);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x103), 0xFFFB, 0x4);
+		b43_phy_maskset(dev, B43_PHY_OFDM(0x103), 0xFFEF, 0x10);
+		b43_radio_maskset(dev, B2063_IQ_CALIB_CTL2, 0xF3, 0x1);
+		lpphy_set_tssi_mux(dev, TSSI_MUX_POSTPA);
+	}
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_IDLETSSI, 0x7FFF, 0x8000);
+	b43_phy_mask(dev, B43_LPPHY_TX_PWR_CTL_DELTAPWR_LIMIT, 0xFF);
+	b43_phy_write(dev, B43_LPPHY_TX_PWR_CTL_DELTAPWR_LIMIT, 0xA);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_CMD,
+			(u16)~B43_LPPHY_TX_PWR_CTL_CMD_MODE,
+			B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
+	b43_phy_mask(dev, B43_LPPHY_TX_PWR_CTL_NNUM, 0xF8FF);
+	b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_CMD,
+			(u16)~B43_LPPHY_TX_PWR_CTL_CMD_MODE,
+			B43_LPPHY_TX_PWR_CTL_CMD_MODE_SW);
+
+	if (dev->phy.rev < 2) {
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_0, 0xEFFF, 0x1000);
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xEFFF);
+	} else {
+		lpphy_set_tx_power_by_index(dev, 0x7F);
+	}
+
+	b43_dummy_transmission(dev, true, true);
+
+	tmp = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_STAT);
+	if (tmp & 0x8000) {
+		b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_IDLETSSI,
+				0xFFC0, (tmp & 0xFF) - 32);
+	}
+
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xEFFF);
+
+	// (SPEC?) TODO Set "Target TX frequency" variable to 0
+	// SPEC FIXME "Set BB Multiplier to 0xE000" impossible - bb_mult is u8!
+}
+
+static void lpphy_tx_pctl_init_sw(struct b43_wldev *dev)
+{
+	struct lpphy_tx_gains gains;
+
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		gains.gm = 4;
+		gains.pad = 12;
+		gains.pga = 12;
+		gains.dac = 0;
+	} else {
+		gains.gm = 7;
+		gains.pad = 14;
+		gains.pga = 15;
+		gains.dac = 0;
+	}
+	lpphy_set_tx_gains(dev, gains);
+	lpphy_set_bb_mult(dev, 150);
+}
+
 /* Initialize TX power control */
 static void lpphy_tx_pctl_init(struct b43_wldev *dev)
 {
 	if (0/*FIXME HWPCTL capable */) {
-		//TODO
+		lpphy_tx_pctl_init_hw(dev);
 	} else { /* This device is only software TX power control capable. */
-		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
-			//TODO
-		} else {
-			//TODO
-		}
-		//TODO set BB multiplier to 0x0096
+		lpphy_tx_pctl_init_sw(dev);
 	}
 }
 
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 0461d5b..4eab760 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -886,6 +886,11 @@ struct b43_phy_lp {
 	u16 dig_flt_state[9];
 };
 
+enum tssi_mux_mode {
+	TSSI_MUX_PREPA,
+	TSSI_MUX_POSTPA,
+	TSSI_MUX_EXT,
+};
 
 struct b43_phy_operations;
 extern const struct b43_phy_operations b43_phyops_lp;
-- 
1.6.2.4





From Larry.Finger at lwfinger.net  Thu Aug 13 17:45:16 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 13 Aug 2009 10:45:16 -0500
Subject: [RFC/RFT] b43: LP-PHY: Implement channel switching for rev2+/B2063
	radio
In-Reply-To: <4A842AFD.1020903@gmail.com>
References: <4A842AFD.1020903@gmail.com>
Message-ID: <4A84350C.2090903@lwfinger.net>

G?bor Stefanik wrote:
> Rev.2+/B2063 will now hopefully show some signs of life, though
> it won't work at full performance, as calibration is still missing.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> If you have an LP-PHY device with the B2063 radio, please test!
> 
> Larry&Michael,
> There is some pretty arcane stuff in op_switch_channel, please
> review it closely!
> 
> drivers/net/wireless/b43/phy_lp.c |  395
> ++++++++++++++++++++++++++++++++++++-
> 1 files changed, 390 insertions(+), 5 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index b4e51f0..716bb87 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -142,10 +142,9 @@ static void lpphy_read_band_sprom(struct b43_wldev
> *dev)
>     }
> }
> 
> -static void lpphy_adjust_gain_table(struct b43_wldev *dev)
> +static void lpphy_adjust_gain_table(struct b43_wldev *dev, u32 freq)
> {
>     struct b43_phy_lp *lpphy = dev->phy.lp;
> -    u32 freq = dev->wl->hw->conf.channel->center_freq;
>     u16 temp[3];
>     u16 isolation;
> 
> @@ -170,6 +169,8 @@ static void lpphy_adjust_gain_table(struct b43_wldev
> *dev)
> 
> static void lpphy_table_init(struct b43_wldev *dev)
> {
> +    u32 freq = dev->wl->hw->conf.channel->center_freq;
> +
>     if (dev->phy.rev < 2)
>         lpphy_rev0_1_table_init(dev);
>     else
> @@ -178,7 +179,7 @@ static void lpphy_table_init(struct b43_wldev *dev)
>     lpphy_init_tx_gain_table(dev);
> 
>     if (dev->phy.rev < 2)
> -        lpphy_adjust_gain_table(dev);
> +        lpphy_adjust_gain_table(dev, freq);
> }
> 
> static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
> @@ -1369,7 +1370,7 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
>     lpphy_baseband_init(dev);
>     lpphy_radio_init(dev);
>     lpphy_calibrate_rc(dev);
> -    //TODO set channel
> +    b43_switch_channel(dev, dev->wl->hw->conf.channel->hw_value);
>     lpphy_tx_pctl_init(dev);
>     lpphy_calibration(dev);
>     //TODO ACI init
> @@ -1419,10 +1420,394 @@ static void b43_lpphy_op_software_rfkill(struct
> b43_wldev *dev,
>     //TODO
> }
> 
> +static void lpphy_b2062_tune(struct b43_wldev *dev,
> +                 unsigned int channel)
> +{
> +    //TODO
> +}
> +
> +struct b2063_channel {
> +    u8 channel;
> +    u16 freq;
> +    u8 data[12];
> +};
> +
> +static const struct b2063_channel b2063_chantbl[] = {
> +    { .channel = 1, .freq = 2412, .data[0] = 0x6F, .data[1] = 0x3C,
> +      .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 2, .freq = 2417, .data[0] = 0x6F, .data[1] = 0x3C,
> +      .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 3, .freq = 2422, .data[0] = 0x6F, .data[1] = 0x3C,
> +      .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 4, .freq = 2427, .data[0] = 0x6F, .data[1] = 0x2C,
> +      .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 5, .freq = 2432, .data[0] = 0x6F, .data[1] = 0x2C,
> +      .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 6, .freq = 2437, .data[0] = 0x6F, .data[1] = 0x2C,
> +      .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 7, .freq = 2442, .data[0] = 0x6F, .data[1] = 0x2C,
> +      .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 8, .freq = 2447, .data[0] = 0x6F, .data[1] = 0x2C,
> +      .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 9, .freq = 2452, .data[0] = 0x6F, .data[1] = 0x1C,
> +      .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 10, .freq = 2457, .data[0] = 0x6F, .data[1] = 0x1C,
> +      .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 11, .freq = 2462, .data[0] = 0x6E, .data[1] = 0x1C,
> +      .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 12, .freq = 2467, .data[0] = 0x6E, .data[1] = 0x1C,
> +      .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 13, .freq = 2472, .data[0] = 0x6E, .data[1] = 0x1C,
> +      .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 14, .freq = 2484, .data[0] = 0x6E, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
> +      .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x80, .data[11] = 0x70, },
> +    { .channel = 34, .freq = 5170, .data[0] = 0x6A, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x02, .data[5] = 0x05,
> +      .data[6] = 0x0D, .data[7] = 0x0D, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x20, .data[11] = 0x00, },
> +    { .channel = 38, .freq = 5190, .data[0] = 0x6A, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
> +      .data[6] = 0x0C, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x20, .data[11] = 0x00, },
> +    { .channel = 42, .freq = 5210, .data[0] = 0x69, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
> +      .data[6] = 0x0B, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x70,
> +      .data[10] = 0x20, .data[11] = 0x00, },
> +    { .channel = 46, .freq = 5230, .data[0] = 0x69, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x03,
> +      .data[6] = 0x0A, .data[7] = 0x0B, .data[8] = 0x77, .data[9] = 0x60,
> +      .data[10] = 0x20, .data[11] = 0x00, },
> +    { .channel = 36, .freq = 5180, .data[0] = 0x6A, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x05,
> +      .data[6] = 0x0D, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x80,
> +      .data[10] = 0x20, .data[11] = 0x00, },
> +    { .channel = 40, .freq = 5200, .data[0] = 0x69, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
> +      .data[6] = 0x0C, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x70,
> +      .data[10] = 0x20, .data[11] = 0x00, },
> +    { .channel = 44, .freq = 5220, .data[0] = 0x69, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x04,
> +      .data[6] = 0x0B, .data[7] = 0x0B, .data[8] = 0x77, .data[9] = 0x60,
> +      .data[10] = 0x20, .data[11] = 0x00, },
> +    { .channel = 48, .freq = 5240, .data[0] = 0x69, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x03,
> +      .data[6] = 0x0A, .data[7] = 0x0A, .data[8] = 0x77, .data[9] = 0x60,
> +      .data[10] = 0x20, .data[11] = 0x00, },
> +    { .channel = 52, .freq = 5260, .data[0] = 0x68, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x02,
> +      .data[6] = 0x09, .data[7] = 0x09, .data[8] = 0x77, .data[9] = 0x60,
> +      .data[10] = 0x20, .data[11] = 0x00, },
> +    { .channel = 56, .freq = 5280, .data[0] = 0x68, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x01,
> +      .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
> +      .data[10] = 0x10, .data[11] = 0x00, },
> +    { .channel = 60, .freq = 5300, .data[0] = 0x68, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x01,
> +      .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
> +      .data[10] = 0x10, .data[11] = 0x00, },
> +    { .channel = 64, .freq = 5320, .data[0] = 0x67, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
> +      .data[10] = 0x10, .data[11] = 0x00, },
> +    { .channel = 100, .freq = 5500, .data[0] = 0x64, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x02, .data[7] = 0x01, .data[8] = 0x77, .data[9] = 0x20,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 104, .freq = 5520, .data[0] = 0x64, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x01, .data[7] = 0x01, .data[8] = 0x77, .data[9] = 0x20,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 108, .freq = 5540, .data[0] = 0x63, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x01, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 112, .freq = 5560, .data[0] = 0x63, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 116, .freq = 5580, .data[0] = 0x62, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 120, .freq = 5600, .data[0] = 0x62, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 124, .freq = 5620, .data[0] = 0x62, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 128, .freq = 5640, .data[0] = 0x61, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 132, .freq = 5660, .data[0] = 0x61, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 136, .freq = 5680, .data[0] = 0x61, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 140, .freq = 5700, .data[0] = 0x60, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 149, .freq = 5745, .data[0] = 0x60, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 153, .freq = 5765, .data[0] = 0x60, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 157, .freq = 5785, .data[0] = 0x60, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 161, .freq = 5805, .data[0] = 0x60, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 165, .freq = 5825, .data[0] = 0x60, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
> +      .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
> +      .data[10] = 0x00, .data[11] = 0x00, },
> +    { .channel = 184, .freq = 4920, .data[0] = 0x6E, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x09, .data[5] = 0x0E,
> +      .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xC0,
> +      .data[10] = 0x50, .data[11] = 0x00, },
> +    { .channel = 188, .freq = 4940, .data[0] = 0x6E, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x09, .data[5] = 0x0D,
> +      .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xB0,
> +      .data[10] = 0x50, .data[11] = 0x00, },
> +    { .channel = 192, .freq = 4960, .data[0] = 0x6E, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0C,
> +      .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xB0,
> +      .data[10] = 0x50, .data[11] = 0x00, },
> +    { .channel = 196, .freq = 4980, .data[0] = 0x6D, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0C,
> +      .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
> +      .data[10] = 0x40, .data[11] = 0x00, },
> +    { .channel = 200, .freq = 5000, .data[0] = 0x6D, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0B,
> +      .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
> +      .data[10] = 0x40, .data[11] = 0x00, },
> +    { .channel = 204, .freq = 5020, .data[0] = 0x6D, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0A,
> +      .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
> +      .data[10] = 0x40, .data[11] = 0x00, },
> +    { .channel = 208, .freq = 5040, .data[0] = 0x6C, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x07, .data[5] = 0x09,
> +      .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
> +      .data[10] = 0x40, .data[11] = 0x00, },
> +    { .channel = 212, .freq = 5060, .data[0] = 0x6C, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x06, .data[5] = 0x08,
> +      .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
> +      .data[10] = 0x40, .data[11] = 0x00, },
> +    { .channel = 216, .freq = 5080, .data[0] = 0x6C, .data[1] = 0x0C,
> +      .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x05, .data[5] = 0x08,
> +      .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
> +      .data[10] = 0x40, .data[11] = 0x00, },
> +};
> +
> +static void lpphy_b2063_vco_calib(struct b43_wldev *dev)
> +{
> +    u16 tmp;
> +
> +    b43_phy_mask(dev, B2063_PLL_SP1, ~0x40);
> +    tmp = b43_phy_read(dev, B2063_PLL_JTAG_CALNRST) & 0xF8;
> +    b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp);
> +    udelay(1);
> +    b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x4);
> +    udelay(1);
> +    b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x6);
> +    udelay(1);
> +    b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x7);
> +    udelay(300);
> +    b43_phy_set(dev, B2063_PLL_SP1, 0x40);
> +}
> +
> +static void lpphy_b2063_tune(struct b43_wldev *dev,
> +                 unsigned int channel)
> +{
> +    struct ssb_bus *bus = dev->dev->bus;
> +
> +    struct b2063_channel chandata;
> +    u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
> +    u32 freqref, vco_freq, val1, val2, val3, timeout, timeoutref, count;
> +    u16 old_comm15, scale;
> +    u32 tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
> +    int i, div = (crystal_freq <= 26000000 ? 1 : 2);
> +
> +    memset(&chandata, 0, sizeof(chandata));
> +
> +    for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
> +        if (b2063_chantbl[i].channel == channel) {
> +            chandata = b2063_chantbl[i];
> +            break;
> +        }
> +    }
> +
> +    B43_WARN_ON(!chandata.channel);
> +
> +    b43_radio_write(dev, B2063_LOGEN_VCOBUF1, chandata.data[0]);
> +    b43_radio_write(dev, B2063_LOGEN_MIXER2, chandata.data[1]);
> +    b43_radio_write(dev, B2063_LOGEN_BUF2, chandata.data[2]);
> +    b43_radio_write(dev, B2063_LOGEN_RCCR1, chandata.data[3]);
> +    b43_radio_write(dev, B2063_A_RX_1ST3, chandata.data[4]);
> +    b43_radio_write(dev, B2063_A_RX_2ND1, chandata.data[5]);
> +    b43_radio_write(dev, B2063_A_RX_2ND4, chandata.data[6]);
> +    b43_radio_write(dev, B2063_A_RX_2ND7, chandata.data[7]);
> +    b43_radio_write(dev, B2063_A_RX_PS6, chandata.data[8]);
> +    b43_radio_write(dev, B2063_TX_RF_CTL2, chandata.data[9]);
> +    b43_radio_write(dev, B2063_TX_RF_CTL5, chandata.data[10]);
> +    b43_radio_write(dev, B2063_PA_CTL11, chandata.data[11]);
> +
> +    old_comm15 = b43_radio_read(dev, B2063_COMM15);
> +    b43_radio_set(dev, B2063_COMM15, 0x1E);
> +
> +    if (chandata.freq > 4000) /* spec says 2484, but 4000 is safer */
> +        vco_freq = chandata.freq << 1;
> +    else
> +        vco_freq = chandata.freq << 2;
> +
> +    freqref = crystal_freq * 3;
> +    val1 = lpphy_qdiv_roundup(crystal_freq, 1000000, 16);
> +    val2 = lpphy_qdiv_roundup(crystal_freq, 1000000 * div, 16);
> +    val3 = lpphy_qdiv_roundup(vco_freq, 3, 16);
> +    timeout = ((((8 * crystal_freq) / (div * 5000000)) + 1) >> 1) - 1;
> +    b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB3, 0x2);
> +    b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB6,
> +              0xFFF8, timeout >> 2);
> +    b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB7,
> +              0xFF9F,timeout << 5);
> +
> +    timeoutref = ((((8 * crystal_freq) / (div * (timeout + 1))) +
> +                        999999) / 1000000) + 1;
> +    b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB5, timeoutref);
> +
> +    count = lpphy_qdiv_roundup(val3, val2 + 16, 16);
> +    count *= (timeout + 1) * (timeoutref + 1);
> +    count--;
> +    b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB7,
> +                        0xF0, count >> 8);
> +    b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB8, count & 0xFF);
> +
> +    tmp1 = ((val3 * 62500) / freqref) << 4;
> +    tmp2 = ((val3 * 62500) % freqref) << 4;
> +    while (tmp2 >= freqref) {
> +        tmp1++;
> +        tmp2 -= freqref;
> +    }
> +    b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG1, 0xFFE0, tmp1 >> 4);
> +    b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG2, 0xFE0F, tmp1 << 4);
> +    b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG2, 0xFFF0, tmp1 >> 16);
> +    b43_radio_write(dev, B2063_PLL_JTAG_PLL_SG3, (tmp2 >> 8) & 0xFF);
> +    b43_radio_write(dev, B2063_PLL_JTAG_PLL_SG4, tmp2 & 0xFF);
> +
> +    b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF1, 0xB9);
> +    b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF2, 0x88);
> +    b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF3, 0x28);
> +    b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF4, 0x63);
> +
> +    tmp3 = ((41 * (val3 - 3000)) /1200) + 27;
> +    tmp4 = lpphy_qdiv_roundup(132000 * tmp1, 8451, 16);
> +
> +    if ((tmp4 + tmp3 - 1) / tmp3 > 60) {
> +        scale = 1;
> +        tmp5 = ((tmp4 + tmp3) / (tmp3 << 1)) - 8;
> +    } else {
> +        scale = 0;
> +        tmp5 = ((tmp4 + (tmp3 >> 1)) / tmp3) - 8;
> +    }
> +    b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFC0, tmp5);
> +    b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFBF, scale << 6);
> +
> +    tmp6 = lpphy_qdiv_roundup(100 * val1, val3, 16);
> +    tmp6 *= (tmp5 * 8) * (scale + 1);
> +    if (tmp6 > 150)
> +        tmp6 = 0;
> +
> +    b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFE0, tmp6);
> +    b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFDF, scale << 5);
> +
> +    b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFFFB, 0x4);
> +    if (crystal_freq > 26000000)
> +        b43_phy_set(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0x2);
> +    else
> +        b43_phy_mask(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFD);
> +
> +    if (val1 == 45)
> +        b43_phy_set(dev, B2063_PLL_JTAG_PLL_VCO1, 0x2);
> +    else
> +        b43_phy_mask(dev, B2063_PLL_JTAG_PLL_VCO1, 0xFD);
> +
> +    b43_phy_set(dev, B2063_PLL_SP2, 0x3);
> +    udelay(1);
> +    b43_phy_mask(dev, B2063_PLL_SP2, 0xFFFC);
> +    lpphy_b2063_vco_calib(dev);
> +    b43_radio_write(dev, B2063_COMM15, old_comm15);
> +}
> +
> static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
>                        unsigned int new_channel)
> {
> -    //TODO
> +    struct b2063_channel chandata;
> +    int i;
> +
> +    memset(&chandata, 0, sizeof(chandata));
> +
> +    //FIXME this abuses the 2063 channel table for chan2freq purposes!
> +    for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
> +        if (b2063_chantbl[i].channel == new_channel) {
> +            chandata = b2063_chantbl[i];
> +            break;
> +        }
> +    }
> +
> +    B43_WARN_ON(!chandata.channel);
> +
> +    /* FIXME this should be the last thing done, even after generic
> +     * parts - does it matter?
> +     * SPEC FIXME should this write channel, freq, chanspec or cookie?
> +     */
> +    b43_write16(dev, B43_MMIO_CHANNEL, new_channel);

Whenever this hardware register is written, it is always with a channel.

> +    if (dev->phy.radio_ver == 0x2063) {
> +        lpphy_b2063_tune(dev, new_channel);
> +    } else {
> +        lpphy_b2062_tune(dev, new_channel);
> +        //TODO Japan filter
> +    }
> +    lpphy_adjust_gain_table(dev, chandata.freq);
>     return 0;
> }
> 

What SPEC page did you use for this? I only see the tuning calls in
http://bcm-v4.sipsolutions.net/802.11/PHY/LP/SetChanSpecLPPHY, but it
doesn't look like this.

Larry


From mb at bu3sch.de  Thu Aug 13 19:23:29 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 13 Aug 2009 19:23:29 +0200
Subject: [PATCH v2] b43: Update dummy transmission to match V4 specs
In-Reply-To: <4A842887.2080109@gmail.com>
References: <4A842887.2080109@gmail.com>
Message-ID: <200908131923.29847.mb@bu3sch.de>

On Thursday 13 August 2009 16:51:51 G?bor Stefanik wrote:
> The V4 dummy transmission has two extra bools in its prototype,
> so update all callers with the 2 bools.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> v2: Convert all callers to v4, and drop the v3->v4 wrapper.

> -	/* Commit writes */
> -	b43_read32(dev, B43_MMIO_MACCTL);

> -	value = ((phy->type == B43_PHYTYPE_A) ? 1 : 0);
> +	if (dev->dev->id.revision < 11)
> +		b43_write16(dev, 0x07C0, 0x0000);
> +	else
> +		b43_write16(dev, 0x07C0, 0x0100);
> +	value = (ofdm ? 0x41 : 0x40);
>  	b43_write16(dev, 0x050C, value);

This patch changes G-PHY codepaths. Did you test it on (at least one) G-PHY device?

-- 
Greetings, Michael.


From mb at bu3sch.de  Thu Aug 13 19:40:52 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 13 Aug 2009 19:40:52 +0200
Subject: [RFC/RFT] b43: LP-PHY: Implement channel switching for
	rev2+/B2063 radio
In-Reply-To: <4A842AFD.1020903@gmail.com>
References: <4A842AFD.1020903@gmail.com>
Message-ID: <200908131940.52830.mb@bu3sch.de>

On Thursday 13 August 2009 17:02:21 G?bor Stefanik wrote:
> Rev.2+/B2063 will now hopefully show some signs of life, though
> it won't work at full performance, as calibration is still missing.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

>  static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
> @@ -1369,7 +1370,7 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
>  	lpphy_baseband_init(dev);
>  	lpphy_radio_init(dev);
>  	lpphy_calibrate_rc(dev);
> -	//TODO set channel
> +	b43_switch_channel(dev, dev->wl->hw->conf.channel->hw_value);

Does dev->wl->hw->conf.channel->hw_value already have a sane value here?
Also please call b43_lpphy_op_switch_channel() instead of b43_switch_channel().

> +static void lpphy_b2063_tune(struct b43_wldev *dev,
> +			     unsigned int channel)
> +{
> +	struct ssb_bus *bus = dev->dev->bus;
> +
> +	struct b2063_channel chandata;
> +	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
> +	u32 freqref, vco_freq, val1, val2, val3, timeout, timeoutref, count;
> +	u16 old_comm15, scale;
> +	u32 tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
> +	int i, div = (crystal_freq <= 26000000 ? 1 : 2);
> +
> +	memset(&chandata, 0, sizeof(chandata));
> +
> +	for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
> +		if (b2063_chantbl[i].channel == channel) {
> +			chandata = b2063_chantbl[i];

Can you use a const pointer instead of copying the whole data structure?

> +			break;
> +		}
> +	}
> +
> +	B43_WARN_ON(!chandata.channel);

> +
>  static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
>  				       unsigned int new_channel)
>  {
> -	//TODO
> +	struct b2063_channel chandata;
> +	int i;
> +
> +	memset(&chandata, 0, sizeof(chandata));
> +
> +	//FIXME this abuses the 2063 channel table for chan2freq purposes!
> +	for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
> +		if (b2063_chantbl[i].channel == new_channel) {
> +			chandata = b2063_chantbl[i];
> +			break;
> +		}
> +	}
> +
> +	B43_WARN_ON(!chandata.channel);
> +
> +	/* FIXME this should be the last thing done, even after generic
> +	 * parts - does it matter?

It is correct as is.

> +	 * SPEC FIXME should this write channel, freq, chanspec or cookie?
> +	 */

Can you explain this FIXME? What's "chanspec", what's "cookie"?

> +	b43_write16(dev, B43_MMIO_CHANNEL, new_channel);
> +	if (dev->phy.radio_ver == 0x2063) {
> +		lpphy_b2063_tune(dev, new_channel);
> +	} else {
> +		lpphy_b2062_tune(dev, new_channel);
> +		//TODO Japan filter
> +	}
> +	lpphy_adjust_gain_table(dev, chandata.freq);
>  	return 0;
>  }
>  



-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Thu Aug 13 20:00:47 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Thu, 13 Aug 2009 20:00:47 +0200
Subject: [RFC/RFT] b43: LP-PHY: Implement channel switching for 
	rev2+/B2063 radio
In-Reply-To: <200908131955.32283.mb@bu3sch.de>
References: <4A842AFD.1020903@gmail.com> <200908131940.52830.mb@bu3sch.de> 
	<69e28c910908131050m94a0246s63b5aa57c7b25606@mail.gmail.com> 
	<200908131955.32283.mb@bu3sch.de>
Message-ID: <69e28c910908131100h7d403196y3f8be4809fc61d0f@mail.gmail.com>

(List re-CC-ed.)

2009/8/13 Michael Buesch <mb at bu3sch.de>:
> On Thursday 13 August 2009 19:50:16 G?bor Stefanik wrote:
>> 2009/8/13 Michael Buesch <mb at bu3sch.de>:
>> > On Thursday 13 August 2009 17:02:21 G?bor Stefanik wrote:
>> >> Rev.2+/B2063 will now hopefully show some signs of life, though
>> >> it won't work at full performance, as calibration is still missing.
>> >>
>> >> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> >
>> >> ?static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
>> >> @@ -1369,7 +1370,7 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
>> >> ? ? ? lpphy_baseband_init(dev);
>> >> ? ? ? lpphy_radio_init(dev);
>> >> ? ? ? lpphy_calibrate_rc(dev);
>> >> - ? ? //TODO set channel
>> >> + ? ? b43_switch_channel(dev, dev->wl->hw->conf.channel->hw_value);
>> >
>> > Does dev->wl->hw->conf.channel->hw_value already have a sane value here?
>>
>> I think it should - hw->conf.channel was handed to us by mac80211.
>> http://bcm-v4.sipsolutions.net/802.11/PHY/LP/Init says "Set channel
>> with current chanspec as argument", and hw->conf.channel is our
>> equivalent of chanspec.
>
> hw->conf.channel was not handed to us at all. You simply pick it
> from mac80211's conf structure and _assume_ that it is initialized.
> In the other PHY implementations we use phyop_default_channel (or mandatory
> hardcoded channel values) in the PHY init only. I think you should do the
> same here. Mac80211 will make sure to select the correct channel later.

OK, I will use the default channel (though that's not exactly what the
spec says - Larry, is using the default channel correct?)

>
>> > Also please call b43_lpphy_op_switch_channel() instead of b43_switch_channel().
>>
>> No, that would be wrong; the generic parts of b43_switch_channel also
>> need to be executed. See
>
> I don't see why. The generic parts are nothing that should be done at the PHY init.

Well, the spec says that the generic parts need to be run, so I
implemented it as such.

Larry, is this part of the spec correct?

>
> --
> Greetings, Michael.
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Thu Aug 13 20:02:04 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Thu, 13 Aug 2009 20:02:04 +0200
Subject: [PATCH v2] b43: Update dummy transmission to match V4 specs
In-Reply-To: <200908131923.29847.mb@bu3sch.de>
References: <4A842887.2080109@gmail.com> <200908131923.29847.mb@bu3sch.de>
Message-ID: <69e28c910908131102o29273371w4f86d685f6410bf7@mail.gmail.com>

2009/8/13 Michael Buesch <mb at bu3sch.de>:
> On Thursday 13 August 2009 16:51:51 G?bor Stefanik wrote:
>> The V4 dummy transmission has two extra bools in its prototype,
>> so update all callers with the 2 bools.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> v2: Convert all callers to v4, and drop the v3->v4 wrapper.
>
>> - ? ? /* Commit writes */
>> - ? ? b43_read32(dev, B43_MMIO_MACCTL);
>
>> - ? ? value = ((phy->type == B43_PHYTYPE_A) ? 1 : 0);
>> + ? ? if (dev->dev->id.revision < 11)
>> + ? ? ? ? ? ? b43_write16(dev, 0x07C0, 0x0000);
>> + ? ? else
>> + ? ? ? ? ? ? b43_write16(dev, 0x07C0, 0x0100);
>> + ? ? value = (ofdm ? 0x41 : 0x40);
>> ? ? ? b43_write16(dev, 0x050C, value);
>
> This patch changes G-PHY codepaths. Did you test it on (at least one) G-PHY device?

Not yet - if you could test it, I would be grateful.

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Thu Aug 13 20:05:37 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 13 Aug 2009 20:05:37 +0200
Subject: [RFC/RFT] b43: LP-PHY: Implement channel switching for
	rev2+/B2063 radio
In-Reply-To: <69e28c910908131100h7d403196y3f8be4809fc61d0f@mail.gmail.com>
References: <4A842AFD.1020903@gmail.com> <200908131955.32283.mb@bu3sch.de>
	<69e28c910908131100h7d403196y3f8be4809fc61d0f@mail.gmail.com>
Message-ID: <200908132005.37769.mb@bu3sch.de>

On Thursday 13 August 2009 20:00:47 G?bor Stefanik wrote:
> (List re-CC-ed.)
> 
> 2009/8/13 Michael Buesch <mb at bu3sch.de>:
> > On Thursday 13 August 2009 19:50:16 G?bor Stefanik wrote:
> >> 2009/8/13 Michael Buesch <mb at bu3sch.de>:
> >> > On Thursday 13 August 2009 17:02:21 G?bor Stefanik wrote:
> >> >> Rev.2+/B2063 will now hopefully show some signs of life, though
> >> >> it won't work at full performance, as calibration is still missing.
> >> >>
> >> >> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> >> >
> >> >> ?static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
> >> >> @@ -1369,7 +1370,7 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
> >> >> ? ? ? lpphy_baseband_init(dev);
> >> >> ? ? ? lpphy_radio_init(dev);
> >> >> ? ? ? lpphy_calibrate_rc(dev);
> >> >> - ? ? //TODO set channel
> >> >> + ? ? b43_switch_channel(dev, dev->wl->hw->conf.channel->hw_value);
> >> >
> >> > Does dev->wl->hw->conf.channel->hw_value already have a sane value here?
> >>
> >> I think it should - hw->conf.channel was handed to us by mac80211.
> >> http://bcm-v4.sipsolutions.net/802.11/PHY/LP/Init says "Set channel
> >> with current chanspec as argument", and hw->conf.channel is our
> >> equivalent of chanspec.
> >
> > hw->conf.channel was not handed to us at all. You simply pick it
> > from mac80211's conf structure and _assume_ that it is initialized.
> > In the other PHY implementations we use phyop_default_channel (or mandatory
> > hardcoded channel values) in the PHY init only. I think you should do the
> > same here. Mac80211 will make sure to select the correct channel later.
> 
> OK, I will use the default channel (though that's not exactly what the
> spec says - Larry, is using the default channel correct?)

What on earth could be incorrect about it? It's an as arbitrary value as
dev->wl->hw->conf.channel->hw_value would be.

> 
> >
> >> > Also please call b43_lpphy_op_switch_channel() instead of b43_switch_channel().
> >>
> >> No, that would be wrong; the generic parts of b43_switch_channel also
> >> need to be executed. See
> >
> > I don't see why. The generic parts are nothing that should be done at the PHY init.
> 
> Well, the spec says that the generic parts need to be run, so I
> implemented it as such.

We do understand what the generic stuff does and it is not required at this point.

> Larry, is this part of the spec correct?

I'm pretty sure it is. But that does not mean we have to implement the same
bullshit broadcom does ;)

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Thu Aug 13 20:26:39 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 13 Aug 2009 20:26:39 +0200
Subject: [RFC/RFT v2] b43: LP-PHY: Implement channel switching for rev2+/B2063
	radio
Message-ID: <4A845ADF.7070809@gmail.com>

Rev.2+/B2063 will now hopefully show some signs of life, though
it won't work at full performance, as calibration is still missing.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Changes from v1:
-Reordered channel table ascending by channel number.
-Reordered a few functions.
-b43_switch_channel replaced with b43_op_lpphy_switch_channel in init.
-Init now switches to default channel, rather than conf.channel->hw_value.
-Chandata is now a pointer.
-The table-based channel-to-frequency conversion has been broken out
 into a separate function.
-Removed a FIXME that didn't need fixing.

 drivers/net/wireless/b43/phy_lp.c |  418 +++++++++++++++++++++++++++++++++++--
 1 files changed, 400 insertions(+), 18 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index b4e51f0..f4d98cc 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -142,10 +142,9 @@ static void lpphy_read_band_sprom(struct b43_wldev *dev)
 	}
 }
 
-static void lpphy_adjust_gain_table(struct b43_wldev *dev)
+static void lpphy_adjust_gain_table(struct b43_wldev *dev, u32 freq)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
-	u32 freq = dev->wl->hw->conf.channel->center_freq;
 	u16 temp[3];
 	u16 isolation;
 
@@ -170,6 +169,8 @@ static void lpphy_adjust_gain_table(struct b43_wldev *dev)
 
 static void lpphy_table_init(struct b43_wldev *dev)
 {
+	u32 freq = dev->wl->hw->conf.channel->center_freq;
+
 	if (dev->phy.rev < 2)
 		lpphy_rev0_1_table_init(dev);
 	else
@@ -178,7 +179,7 @@ static void lpphy_table_init(struct b43_wldev *dev)
 	lpphy_init_tx_gain_table(dev);
 
 	if (dev->phy.rev < 2)
-		lpphy_adjust_gain_table(dev);
+		lpphy_adjust_gain_table(dev, freq);
 }
 
 static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
@@ -1363,20 +1364,6 @@ static void lpphy_tx_pctl_init(struct b43_wldev *dev)
 	}
 }
 
-static int b43_lpphy_op_init(struct b43_wldev *dev)
-{
-	lpphy_read_band_sprom(dev); //FIXME should this be in prepare_structs?
-	lpphy_baseband_init(dev);
-	lpphy_radio_init(dev);
-	lpphy_calibrate_rc(dev);
-	//TODO set channel
-	lpphy_tx_pctl_init(dev);
-	lpphy_calibration(dev);
-	//TODO ACI init
-
-	return 0;
-}
-
 static u16 b43_lpphy_op_read(struct b43_wldev *dev, u16 reg)
 {
 	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
@@ -1419,10 +1406,391 @@ static void b43_lpphy_op_software_rfkill(struct b43_wldev *dev,
 	//TODO
 }
 
+struct b206x_channel {
+	u8 channel;
+	u16 freq;
+	u8 data[12];
+};
+
+static const struct b206x_channel b2063_chantbl[] = {
+	{ .channel = 1, .freq = 2412, .data[0] = 0x6F, .data[1] = 0x3C,
+	  .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 2, .freq = 2417, .data[0] = 0x6F, .data[1] = 0x3C,
+	  .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 3, .freq = 2422, .data[0] = 0x6F, .data[1] = 0x3C,
+	  .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 4, .freq = 2427, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 5, .freq = 2432, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 6, .freq = 2437, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 7, .freq = 2442, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 8, .freq = 2447, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 9, .freq = 2452, .data[0] = 0x6F, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 10, .freq = 2457, .data[0] = 0x6F, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 11, .freq = 2462, .data[0] = 0x6E, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 12, .freq = 2467, .data[0] = 0x6E, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 13, .freq = 2472, .data[0] = 0x6E, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 14, .freq = 2484, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 34, .freq = 5170, .data[0] = 0x6A, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x02, .data[5] = 0x05,
+	  .data[6] = 0x0D, .data[7] = 0x0D, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 36, .freq = 5180, .data[0] = 0x6A, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x05,
+	  .data[6] = 0x0D, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 38, .freq = 5190, .data[0] = 0x6A, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
+	  .data[6] = 0x0C, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 40, .freq = 5200, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
+	  .data[6] = 0x0C, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x70,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 42, .freq = 5210, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
+	  .data[6] = 0x0B, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x70,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 44, .freq = 5220, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x04,
+	  .data[6] = 0x0B, .data[7] = 0x0B, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 46, .freq = 5230, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x03,
+	  .data[6] = 0x0A, .data[7] = 0x0B, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 48, .freq = 5240, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x03,
+	  .data[6] = 0x0A, .data[7] = 0x0A, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 52, .freq = 5260, .data[0] = 0x68, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x02,
+	  .data[6] = 0x09, .data[7] = 0x09, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 56, .freq = 5280, .data[0] = 0x68, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x01,
+	  .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
+	  .data[10] = 0x10, .data[11] = 0x00, },
+	{ .channel = 60, .freq = 5300, .data[0] = 0x68, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x01,
+	  .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
+	  .data[10] = 0x10, .data[11] = 0x00, },
+	{ .channel = 64, .freq = 5320, .data[0] = 0x67, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
+	  .data[10] = 0x10, .data[11] = 0x00, },
+	{ .channel = 100, .freq = 5500, .data[0] = 0x64, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x02, .data[7] = 0x01, .data[8] = 0x77, .data[9] = 0x20,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 104, .freq = 5520, .data[0] = 0x64, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x01, .data[7] = 0x01, .data[8] = 0x77, .data[9] = 0x20,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 108, .freq = 5540, .data[0] = 0x63, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x01, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 112, .freq = 5560, .data[0] = 0x63, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 116, .freq = 5580, .data[0] = 0x62, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 120, .freq = 5600, .data[0] = 0x62, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 124, .freq = 5620, .data[0] = 0x62, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 128, .freq = 5640, .data[0] = 0x61, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 132, .freq = 5660, .data[0] = 0x61, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 136, .freq = 5680, .data[0] = 0x61, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 140, .freq = 5700, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 149, .freq = 5745, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 153, .freq = 5765, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 157, .freq = 5785, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 161, .freq = 5805, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 165, .freq = 5825, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 184, .freq = 4920, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x09, .data[5] = 0x0E,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xC0,
+	  .data[10] = 0x50, .data[11] = 0x00, },
+	{ .channel = 188, .freq = 4940, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x09, .data[5] = 0x0D,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xB0,
+	  .data[10] = 0x50, .data[11] = 0x00, },
+	{ .channel = 192, .freq = 4960, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0C,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xB0,
+	  .data[10] = 0x50, .data[11] = 0x00, },
+	{ .channel = 196, .freq = 4980, .data[0] = 0x6D, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0C,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 200, .freq = 5000, .data[0] = 0x6D, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0B,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 204, .freq = 5020, .data[0] = 0x6D, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0A,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 208, .freq = 5040, .data[0] = 0x6C, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x07, .data[5] = 0x09,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 212, .freq = 5060, .data[0] = 0x6C, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x06, .data[5] = 0x08,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 216, .freq = 5080, .data[0] = 0x6C, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x05, .data[5] = 0x08,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+};
+
+static int lpphy_channel2freq(int channel)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
+		if (b2063_chantbl[i].channel == channel) {
+			return b2063_chantbl[i].freq;
+		}
+	}
+
+	/* Channel not in table */
+	B43_WARN_ON(1);
+	return 0;
+}
+
+static void lpphy_b2062_tune(struct b43_wldev *dev,
+			     unsigned int channel)
+{
+	//TODO
+}
+
+static void lpphy_b2063_vco_calib(struct b43_wldev *dev)
+{
+	u16 tmp;
+
+	b43_phy_mask(dev, B2063_PLL_SP1, ~0x40);
+	tmp = b43_phy_read(dev, B2063_PLL_JTAG_CALNRST) & 0xF8;
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp);
+	udelay(1);
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x4);
+	udelay(1);
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x6);
+	udelay(1);
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x7);
+	udelay(300);
+	b43_phy_set(dev, B2063_PLL_SP1, 0x40);
+}
+
+static void lpphy_b2063_tune(struct b43_wldev *dev,
+			     unsigned int channel)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+
+	static const struct b206x_channel *chandata;
+	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
+	u32 freqref, vco_freq, val1, val2, val3, timeout, timeoutref, count;
+	u16 old_comm15, scale;
+	u32 tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
+	int i, div = (crystal_freq <= 26000000 ? 1 : 2);
+
+	for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
+		if (b2063_chantbl[i].channel == channel) {
+			chandata = &b2063_chantbl[i];
+			break;
+		}
+	}
+
+	B43_WARN_ON(!chandata);
+
+	b43_radio_write(dev, B2063_LOGEN_VCOBUF1, chandata->data[0]);
+	b43_radio_write(dev, B2063_LOGEN_MIXER2, chandata->data[1]);
+	b43_radio_write(dev, B2063_LOGEN_BUF2, chandata->data[2]);
+	b43_radio_write(dev, B2063_LOGEN_RCCR1, chandata->data[3]);
+	b43_radio_write(dev, B2063_A_RX_1ST3, chandata->data[4]);
+	b43_radio_write(dev, B2063_A_RX_2ND1, chandata->data[5]);
+	b43_radio_write(dev, B2063_A_RX_2ND4, chandata->data[6]);
+	b43_radio_write(dev, B2063_A_RX_2ND7, chandata->data[7]);
+	b43_radio_write(dev, B2063_A_RX_PS6, chandata->data[8]);
+	b43_radio_write(dev, B2063_TX_RF_CTL2, chandata->data[9]);
+	b43_radio_write(dev, B2063_TX_RF_CTL5, chandata->data[10]);
+	b43_radio_write(dev, B2063_PA_CTL11, chandata->data[11]);
+
+	old_comm15 = b43_radio_read(dev, B2063_COMM15);
+	b43_radio_set(dev, B2063_COMM15, 0x1E);
+
+	if (chandata->freq > 4000) /* spec says 2484, but 4000 is safer */
+		vco_freq = chandata->freq << 1;
+	else
+		vco_freq = chandata->freq << 2;
+
+	freqref = crystal_freq * 3;
+	val1 = lpphy_qdiv_roundup(crystal_freq, 1000000, 16);
+	val2 = lpphy_qdiv_roundup(crystal_freq, 1000000 * div, 16);
+	val3 = lpphy_qdiv_roundup(vco_freq, 3, 16);
+	timeout = ((((8 * crystal_freq) / (div * 5000000)) + 1) >> 1) - 1;
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB3, 0x2);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB6,
+			  0xFFF8, timeout >> 2);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB7,
+			  0xFF9F,timeout << 5);
+
+	timeoutref = ((((8 * crystal_freq) / (div * (timeout + 1))) +
+						999999) / 1000000) + 1;
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB5, timeoutref);
+
+	count = lpphy_qdiv_roundup(val3, val2 + 16, 16);
+	count *= (timeout + 1) * (timeoutref + 1);
+	count--;
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB7,
+						0xF0, count >> 8);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB8, count & 0xFF);
+
+	tmp1 = ((val3 * 62500) / freqref) << 4;
+	tmp2 = ((val3 * 62500) % freqref) << 4;
+	while (tmp2 >= freqref) {
+		tmp1++;
+		tmp2 -= freqref;
+	}
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG1, 0xFFE0, tmp1 >> 4);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG2, 0xFE0F, tmp1 << 4);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG2, 0xFFF0, tmp1 >> 16);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_SG3, (tmp2 >> 8) & 0xFF);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_SG4, tmp2 & 0xFF);
+
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF1, 0xB9);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF2, 0x88);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF3, 0x28);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF4, 0x63);
+
+	tmp3 = ((41 * (val3 - 3000)) /1200) + 27;
+	tmp4 = lpphy_qdiv_roundup(132000 * tmp1, 8451, 16);
+
+	if ((tmp4 + tmp3 - 1) / tmp3 > 60) {
+		scale = 1;
+		tmp5 = ((tmp4 + tmp3) / (tmp3 << 1)) - 8;
+	} else {
+		scale = 0;
+		tmp5 = ((tmp4 + (tmp3 >> 1)) / tmp3) - 8;
+	}
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFC0, tmp5);
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFBF, scale << 6);
+
+	tmp6 = lpphy_qdiv_roundup(100 * val1, val3, 16);
+	tmp6 *= (tmp5 * 8) * (scale + 1);
+	if (tmp6 > 150)
+		tmp6 = 0;
+
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFE0, tmp6);
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFDF, scale << 5);
+
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFFFB, 0x4);
+	if (crystal_freq > 26000000)
+		b43_phy_set(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0x2);
+	else
+		b43_phy_mask(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFD);
+
+	if (val1 == 45)
+		b43_phy_set(dev, B2063_PLL_JTAG_PLL_VCO1, 0x2);
+	else
+		b43_phy_mask(dev, B2063_PLL_JTAG_PLL_VCO1, 0xFD);
+
+	b43_phy_set(dev, B2063_PLL_SP2, 0x3);
+	udelay(1);
+	b43_phy_mask(dev, B2063_PLL_SP2, 0xFFFC);
+	lpphy_b2063_vco_calib(dev);
+	b43_radio_write(dev, B2063_COMM15, old_comm15);
+}
+
 static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
 				       unsigned int new_channel)
 {
-	//TODO
+	b43_write16(dev, B43_MMIO_CHANNEL, new_channel);
+
+	if (dev->phy.radio_ver == 0x2063) {
+		lpphy_b2063_tune(dev, new_channel);
+	} else {
+		lpphy_b2062_tune(dev, new_channel);
+		//TODO Japan filter
+	}
+
+	lpphy_adjust_gain_table(dev, lpphy_channel2freq(new_channel));
+
 	return 0;
 }
 
@@ -1433,6 +1801,20 @@ static unsigned int b43_lpphy_op_get_default_chan(struct b43_wldev *dev)
 	return 36;
 }
 
+static int b43_lpphy_op_init(struct b43_wldev *dev)
+{
+	lpphy_read_band_sprom(dev); //FIXME should this be in prepare_structs?
+	lpphy_baseband_init(dev);
+	lpphy_radio_init(dev);
+	lpphy_calibrate_rc(dev);
+	b43_lpphy_op_switch_channel(dev, b43_lpphy_op_get_default_chan(dev));
+	lpphy_tx_pctl_init(dev);
+	lpphy_calibration(dev);
+	//TODO ACI init
+
+	return 0;
+}
+
 static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 {
 	//TODO
-- 
1.6.2.4





From Larry.Finger at lwfinger.net  Thu Aug 13 21:05:02 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 13 Aug 2009 14:05:02 -0500
Subject: [RFC/RFT] b43: LP-PHY: Implement channel switching for rev2+/B2063
	radio
In-Reply-To: <200908132005.37769.mb@bu3sch.de>
References: <4A842AFD.1020903@gmail.com> <200908131955.32283.mb@bu3sch.de>
	<69e28c910908131100h7d403196y3f8be4809fc61d0f@mail.gmail.com>
	<200908132005.37769.mb@bu3sch.de>
Message-ID: <4A8463DE.7060402@lwfinger.net>

Michael Buesch wrote:
> On Thursday 13 August 2009 20:00:47 G?bor Stefanik wrote:
>> (List re-CC-ed.)
>>
>> 2009/8/13 Michael Buesch <mb at bu3sch.de>:
>>> On Thursday 13 August 2009 19:50:16 G?bor Stefanik wrote:
>>>> 2009/8/13 Michael Buesch <mb at bu3sch.de>:
>>>>> On Thursday 13 August 2009 17:02:21 G?bor Stefanik wrote:
>>>>>> Rev.2+/B2063 will now hopefully show some signs of life, though
>>>>>> it won't work at full performance, as calibration is still missing.
>>>>>>
>>>>>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>>>>>>  static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
>>>>>> @@ -1369,7 +1370,7 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
>>>>>>       lpphy_baseband_init(dev);
>>>>>>       lpphy_radio_init(dev);
>>>>>>       lpphy_calibrate_rc(dev);
>>>>>> -     //TODO set channel
>>>>>> +     b43_switch_channel(dev, dev->wl->hw->conf.channel->hw_value);
>>>>> Does dev->wl->hw->conf.channel->hw_value already have a sane value here?
>>>> I think it should - hw->conf.channel was handed to us by mac80211.
>>>> http://bcm-v4.sipsolutions.net/802.11/PHY/LP/Init says "Set channel
>>>> with current chanspec as argument", and hw->conf.channel is our
>>>> equivalent of chanspec.
>>> hw->conf.channel was not handed to us at all. You simply pick it
>>> from mac80211's conf structure and _assume_ that it is initialized.
>>> In the other PHY implementations we use phyop_default_channel (or mandatory
>>> hardcoded channel values) in the PHY init only. I think you should do the
>>> same here. Mac80211 will make sure to select the correct channel later.
>> OK, I will use the default channel (though that's not exactly what the
>> spec says - Larry, is using the default channel correct?)
> 
> What on earth could be incorrect about it? It's an as arbitrary value as
> dev->wl->hw->conf.channel->hw_value would be.

I have not found anything that says what should be used. If the
channel is valid for the selected band, it should be as good as any.
> 
>>>>> Also please call b43_lpphy_op_switch_channel() instead of b43_switch_channel().
>>>> No, that would be wrong; the generic parts of b43_switch_channel also
>>>> need to be executed. See
>>> I don't see why. The generic parts are nothing that should be done at the PHY init.
>> Well, the spec says that the generic parts need to be run, so I
>> implemented it as such.
> 
> We do understand what the generic stuff does and it is not required at this point.
> 
>> Larry, is this part of the spec correct?
> 
> I'm pretty sure it is. But that does not mean we have to implement the same
> bullshit broadcom does ;)

Amen. I have to put it on the web site just in case it is important,
but it must be done that way _ONLY_ if found to be needed for
operation or performance.

Larry


From Larry.Finger at lwfinger.net  Thu Aug 13 21:47:05 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 13 Aug 2009 14:47:05 -0500
Subject: [PATCH v2] b43: Update dummy transmission to match V4 specs
In-Reply-To: <200908131923.29847.mb@bu3sch.de>
References: <4A842887.2080109@gmail.com> <200908131923.29847.mb@bu3sch.de>
Message-ID: <4A846DB9.8080802@lwfinger.net>

Michael Buesch wrote:
> On Thursday 13 August 2009 16:51:51 G?bor Stefanik wrote:
>> The V4 dummy transmission has two extra bools in its prototype,
>> so update all callers with the 2 bools.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> v2: Convert all callers to v4, and drop the v3->v4 wrapper.
> 
>> -	/* Commit writes */
>> -	b43_read32(dev, B43_MMIO_MACCTL);
> 
>> -	value = ((phy->type == B43_PHYTYPE_A) ? 1 : 0);
>> +	if (dev->dev->id.revision < 11)
>> +		b43_write16(dev, 0x07C0, 0x0000);
>> +	else
>> +		b43_write16(dev, 0x07C0, 0x0100);
>> +	value = (ofdm ? 0x41 : 0x40);
>>  	b43_write16(dev, 0x050C, value);
> 
> This patch changes G-PHY codepaths. Did you test it on (at least one) G-PHY device?
> 

My device with the 0x4312 ID still works with this patch applied.

Larry


From netrolller.3d at gmail.com  Thu Aug 13 22:46:30 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 13 Aug 2009 22:46:30 +0200
Subject: [PATCH] b43: LP-PHY: Implement channel switching for rev2+/B2063 radio
Message-ID: <4A847BA6.30803@gmail.com>

Rev.2+/B2063 will now hopefully show some signs of life, though
it won't work at full performance, as calibration is still missing.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Changes since RFC v2:
-Replaced table-based channel2freq with a proper (mathematical) one.
-Removed use of hw->conf.channel everywhere (except b43_current_band).
-Fixed uninitialized chandata pointer.
-Fixed NULL pointer dereference when changing to invalid channel.

Changes between RFC v1->v2:
-Reordered channel table ascending by channel number.
-Reordered a few functions.
-b43_switch_channel replaced with b43_op_lpphy_switch_channel in init.
-Init now switches to default channel, rather than conf.channel->hw_value.
-Chandata is now a pointer.
-The table-based channel-to-frequency conversion has been broken out
into a separate function.
-Removed a FIXME that didn't need fixing.


 drivers/net/wireless/b43/phy_lp.c |  424 +++++++++++++++++++++++++++++++++++--
 1 files changed, 402 insertions(+), 22 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index b4e51f0..992e250 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -29,6 +29,25 @@
 #include "tables_lpphy.h"
 
 
+static inline u16 channel2freq_lp(u8 channel)
+{
+	if (channel < 14)
+		return (2407 + 5 * channel);
+	else if (channel == 14)
+		return 2484;
+	else if (channel < 184)
+		return (5000 + 5 * channel);
+	else
+		return (4000 + 5 * channel);
+}
+
+static unsigned int b43_lpphy_op_get_default_chan(struct b43_wldev *dev)
+{
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+		return 1;
+	return 36;
+}
+
 static int b43_lpphy_op_allocate(struct b43_wldev *dev)
 {
 	struct b43_phy_lp *lpphy;
@@ -142,10 +161,9 @@ static void lpphy_read_band_sprom(struct b43_wldev *dev)
 	}
 }
 
-static void lpphy_adjust_gain_table(struct b43_wldev *dev)
+static void lpphy_adjust_gain_table(struct b43_wldev *dev, u32 freq)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
-	u32 freq = dev->wl->hw->conf.channel->center_freq;
 	u16 temp[3];
 	u16 isolation;
 
@@ -170,6 +188,8 @@ static void lpphy_adjust_gain_table(struct b43_wldev *dev)
 
 static void lpphy_table_init(struct b43_wldev *dev)
 {
+	u32 freq = channel2freq_lp(b43_lpphy_op_get_default_chan(dev));
+
 	if (dev->phy.rev < 2)
 		lpphy_rev0_1_table_init(dev);
 	else
@@ -178,7 +198,7 @@ static void lpphy_table_init(struct b43_wldev *dev)
 	lpphy_init_tx_gain_table(dev);
 
 	if (dev->phy.rev < 2)
-		lpphy_adjust_gain_table(dev);
+		lpphy_adjust_gain_table(dev, freq);
 }
 
 static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
@@ -1363,20 +1383,6 @@ static void lpphy_tx_pctl_init(struct b43_wldev *dev)
 	}
 }
 
-static int b43_lpphy_op_init(struct b43_wldev *dev)
-{
-	lpphy_read_band_sprom(dev); //FIXME should this be in prepare_structs?
-	lpphy_baseband_init(dev);
-	lpphy_radio_init(dev);
-	lpphy_calibrate_rc(dev);
-	//TODO set channel
-	lpphy_tx_pctl_init(dev);
-	lpphy_calibration(dev);
-	//TODO ACI init
-
-	return 0;
-}
-
 static u16 b43_lpphy_op_read(struct b43_wldev *dev, u16 reg)
 {
 	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
@@ -1419,18 +1425,392 @@ static void b43_lpphy_op_software_rfkill(struct b43_wldev *dev,
 	//TODO
 }
 
+struct b206x_channel {
+	u8 channel;
+	u16 freq;
+	u8 data[12];
+};
+
+static const struct b206x_channel b2063_chantbl[] = {
+	{ .channel = 1, .freq = 2412, .data[0] = 0x6F, .data[1] = 0x3C,
+	  .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 2, .freq = 2417, .data[0] = 0x6F, .data[1] = 0x3C,
+	  .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 3, .freq = 2422, .data[0] = 0x6F, .data[1] = 0x3C,
+	  .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 4, .freq = 2427, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 5, .freq = 2432, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 6, .freq = 2437, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 7, .freq = 2442, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 8, .freq = 2447, .data[0] = 0x6F, .data[1] = 0x2C,
+	  .data[2] = 0x2C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 9, .freq = 2452, .data[0] = 0x6F, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 10, .freq = 2457, .data[0] = 0x6F, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 11, .freq = 2462, .data[0] = 0x6E, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 12, .freq = 2467, .data[0] = 0x6E, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 13, .freq = 2472, .data[0] = 0x6E, .data[1] = 0x1C,
+	  .data[2] = 0x1C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 14, .freq = 2484, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
+	  .data[6] = 0x05, .data[7] = 0x05, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x80, .data[11] = 0x70, },
+	{ .channel = 34, .freq = 5170, .data[0] = 0x6A, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x02, .data[5] = 0x05,
+	  .data[6] = 0x0D, .data[7] = 0x0D, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 36, .freq = 5180, .data[0] = 0x6A, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x05,
+	  .data[6] = 0x0D, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 38, .freq = 5190, .data[0] = 0x6A, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
+	  .data[6] = 0x0C, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x80,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 40, .freq = 5200, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
+	  .data[6] = 0x0C, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x70,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 42, .freq = 5210, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x01, .data[5] = 0x04,
+	  .data[6] = 0x0B, .data[7] = 0x0C, .data[8] = 0x77, .data[9] = 0x70,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 44, .freq = 5220, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x04,
+	  .data[6] = 0x0B, .data[7] = 0x0B, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 46, .freq = 5230, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x03,
+	  .data[6] = 0x0A, .data[7] = 0x0B, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 48, .freq = 5240, .data[0] = 0x69, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x03,
+	  .data[6] = 0x0A, .data[7] = 0x0A, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 52, .freq = 5260, .data[0] = 0x68, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x02,
+	  .data[6] = 0x09, .data[7] = 0x09, .data[8] = 0x77, .data[9] = 0x60,
+	  .data[10] = 0x20, .data[11] = 0x00, },
+	{ .channel = 56, .freq = 5280, .data[0] = 0x68, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x01,
+	  .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
+	  .data[10] = 0x10, .data[11] = 0x00, },
+	{ .channel = 60, .freq = 5300, .data[0] = 0x68, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x01,
+	  .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
+	  .data[10] = 0x10, .data[11] = 0x00, },
+	{ .channel = 64, .freq = 5320, .data[0] = 0x67, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x08, .data[7] = 0x08, .data[8] = 0x77, .data[9] = 0x50,
+	  .data[10] = 0x10, .data[11] = 0x00, },
+	{ .channel = 100, .freq = 5500, .data[0] = 0x64, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x02, .data[7] = 0x01, .data[8] = 0x77, .data[9] = 0x20,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 104, .freq = 5520, .data[0] = 0x64, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x01, .data[7] = 0x01, .data[8] = 0x77, .data[9] = 0x20,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 108, .freq = 5540, .data[0] = 0x63, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x01, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 112, .freq = 5560, .data[0] = 0x63, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 116, .freq = 5580, .data[0] = 0x62, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x10,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 120, .freq = 5600, .data[0] = 0x62, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 124, .freq = 5620, .data[0] = 0x62, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 128, .freq = 5640, .data[0] = 0x61, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 132, .freq = 5660, .data[0] = 0x61, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 136, .freq = 5680, .data[0] = 0x61, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 140, .freq = 5700, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 149, .freq = 5745, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 153, .freq = 5765, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 157, .freq = 5785, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 161, .freq = 5805, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 165, .freq = 5825, .data[0] = 0x60, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x00, .data[5] = 0x00,
+	  .data[6] = 0x00, .data[7] = 0x00, .data[8] = 0x77, .data[9] = 0x00,
+	  .data[10] = 0x00, .data[11] = 0x00, },
+	{ .channel = 184, .freq = 4920, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x09, .data[5] = 0x0E,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xC0,
+	  .data[10] = 0x50, .data[11] = 0x00, },
+	{ .channel = 188, .freq = 4940, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x09, .data[5] = 0x0D,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xB0,
+	  .data[10] = 0x50, .data[11] = 0x00, },
+	{ .channel = 192, .freq = 4960, .data[0] = 0x6E, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0C,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xB0,
+	  .data[10] = 0x50, .data[11] = 0x00, },
+	{ .channel = 196, .freq = 4980, .data[0] = 0x6D, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0C,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 200, .freq = 5000, .data[0] = 0x6D, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0B,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 204, .freq = 5020, .data[0] = 0x6D, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x08, .data[5] = 0x0A,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0xA0,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 208, .freq = 5040, .data[0] = 0x6C, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x07, .data[5] = 0x09,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 212, .freq = 5060, .data[0] = 0x6C, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x06, .data[5] = 0x08,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+	{ .channel = 216, .freq = 5080, .data[0] = 0x6C, .data[1] = 0x0C,
+	  .data[2] = 0x0C, .data[3] = 0x00, .data[4] = 0x05, .data[5] = 0x08,
+	  .data[6] = 0x0F, .data[7] = 0x0F, .data[8] = 0x77, .data[9] = 0x90,
+	  .data[10] = 0x40, .data[11] = 0x00, },
+};
+
+static void lpphy_b2062_tune(struct b43_wldev *dev,
+			     unsigned int channel)
+{
+	//TODO
+}
+
+static void lpphy_b2063_vco_calib(struct b43_wldev *dev)
+{
+	u16 tmp;
+
+	b43_phy_mask(dev, B2063_PLL_SP1, ~0x40);
+	tmp = b43_phy_read(dev, B2063_PLL_JTAG_CALNRST) & 0xF8;
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp);
+	udelay(1);
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x4);
+	udelay(1);
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x6);
+	udelay(1);
+	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x7);
+	udelay(300);
+	b43_phy_set(dev, B2063_PLL_SP1, 0x40);
+}
+
+static void lpphy_b2063_tune(struct b43_wldev *dev,
+			     unsigned int channel)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+
+	static const struct b206x_channel *chandata = NULL;
+	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
+	u32 freqref, vco_freq, val1, val2, val3, timeout, timeoutref, count;
+	u16 old_comm15, scale;
+	u32 tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
+	int i, div = (crystal_freq <= 26000000 ? 1 : 2);
+
+	for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
+		if (b2063_chantbl[i].channel == channel) {
+			chandata = &b2063_chantbl[i];
+			break;
+		}
+	}
+
+	if (B43_WARN_ON(!chandata))
+		return;
+
+	b43_radio_write(dev, B2063_LOGEN_VCOBUF1, chandata->data[0]);
+	b43_radio_write(dev, B2063_LOGEN_MIXER2, chandata->data[1]);
+	b43_radio_write(dev, B2063_LOGEN_BUF2, chandata->data[2]);
+	b43_radio_write(dev, B2063_LOGEN_RCCR1, chandata->data[3]);
+	b43_radio_write(dev, B2063_A_RX_1ST3, chandata->data[4]);
+	b43_radio_write(dev, B2063_A_RX_2ND1, chandata->data[5]);
+	b43_radio_write(dev, B2063_A_RX_2ND4, chandata->data[6]);
+	b43_radio_write(dev, B2063_A_RX_2ND7, chandata->data[7]);
+	b43_radio_write(dev, B2063_A_RX_PS6, chandata->data[8]);
+	b43_radio_write(dev, B2063_TX_RF_CTL2, chandata->data[9]);
+	b43_radio_write(dev, B2063_TX_RF_CTL5, chandata->data[10]);
+	b43_radio_write(dev, B2063_PA_CTL11, chandata->data[11]);
+
+	old_comm15 = b43_radio_read(dev, B2063_COMM15);
+	b43_radio_set(dev, B2063_COMM15, 0x1E);
+
+	if (chandata->freq > 4000) /* spec says 2484, but 4000 is safer */
+		vco_freq = chandata->freq << 1;
+	else
+		vco_freq = chandata->freq << 2;
+
+	freqref = crystal_freq * 3;
+	val1 = lpphy_qdiv_roundup(crystal_freq, 1000000, 16);
+	val2 = lpphy_qdiv_roundup(crystal_freq, 1000000 * div, 16);
+	val3 = lpphy_qdiv_roundup(vco_freq, 3, 16);
+	timeout = ((((8 * crystal_freq) / (div * 5000000)) + 1) >> 1) - 1;
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB3, 0x2);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB6,
+			  0xFFF8, timeout >> 2);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB7,
+			  0xFF9F,timeout << 5);
+
+	timeoutref = ((((8 * crystal_freq) / (div * (timeout + 1))) +
+						999999) / 1000000) + 1;
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB5, timeoutref);
+
+	count = lpphy_qdiv_roundup(val3, val2 + 16, 16);
+	count *= (timeout + 1) * (timeoutref + 1);
+	count--;
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_VCO_CALIB7,
+						0xF0, count >> 8);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_VCO_CALIB8, count & 0xFF);
+
+	tmp1 = ((val3 * 62500) / freqref) << 4;
+	tmp2 = ((val3 * 62500) % freqref) << 4;
+	while (tmp2 >= freqref) {
+		tmp1++;
+		tmp2 -= freqref;
+	}
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG1, 0xFFE0, tmp1 >> 4);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG2, 0xFE0F, tmp1 << 4);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG2, 0xFFF0, tmp1 >> 16);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_SG3, (tmp2 >> 8) & 0xFF);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_SG4, tmp2 & 0xFF);
+
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF1, 0xB9);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF2, 0x88);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF3, 0x28);
+	b43_radio_write(dev, B2063_PLL_JTAG_PLL_LF4, 0x63);
+
+	tmp3 = ((41 * (val3 - 3000)) /1200) + 27;
+	tmp4 = lpphy_qdiv_roundup(132000 * tmp1, 8451, 16);
+
+	if ((tmp4 + tmp3 - 1) / tmp3 > 60) {
+		scale = 1;
+		tmp5 = ((tmp4 + tmp3) / (tmp3 << 1)) - 8;
+	} else {
+		scale = 0;
+		tmp5 = ((tmp4 + (tmp3 >> 1)) / tmp3) - 8;
+	}
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFC0, tmp5);
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFBF, scale << 6);
+
+	tmp6 = lpphy_qdiv_roundup(100 * val1, val3, 16);
+	tmp6 *= (tmp5 * 8) * (scale + 1);
+	if (tmp6 > 150)
+		tmp6 = 0;
+
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFE0, tmp6);
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFDF, scale << 5);
+
+	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFFFB, 0x4);
+	if (crystal_freq > 26000000)
+		b43_phy_set(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0x2);
+	else
+		b43_phy_mask(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFD);
+
+	if (val1 == 45)
+		b43_phy_set(dev, B2063_PLL_JTAG_PLL_VCO1, 0x2);
+	else
+		b43_phy_mask(dev, B2063_PLL_JTAG_PLL_VCO1, 0xFD);
+
+	b43_phy_set(dev, B2063_PLL_SP2, 0x3);
+	udelay(1);
+	b43_phy_mask(dev, B2063_PLL_SP2, 0xFFFC);
+	lpphy_b2063_vco_calib(dev);
+	b43_radio_write(dev, B2063_COMM15, old_comm15);
+}
+
 static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
 				       unsigned int new_channel)
 {
-	//TODO
+	b43_write16(dev, B43_MMIO_CHANNEL, new_channel);
+
+	if (dev->phy.radio_ver == 0x2063) {
+		lpphy_b2063_tune(dev, new_channel);
+	} else {
+		lpphy_b2062_tune(dev, new_channel);
+		//TODO Japan filter
+	}
+
+	lpphy_adjust_gain_table(dev, channel2freq_lp(new_channel));
+
 	return 0;
 }
 
-static unsigned int b43_lpphy_op_get_default_chan(struct b43_wldev *dev)
+static int b43_lpphy_op_init(struct b43_wldev *dev)
 {
-	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
-		return 1;
-	return 36;
+	lpphy_read_band_sprom(dev); //FIXME should this be in prepare_structs?
+	lpphy_baseband_init(dev);
+	lpphy_radio_init(dev);
+	lpphy_calibrate_rc(dev);
+	b43_lpphy_op_switch_channel(dev, b43_lpphy_op_get_default_chan(dev));
+	lpphy_tx_pctl_init(dev);
+	lpphy_calibration(dev);
+	//TODO ACI init
+
+	return 0;
 }
 
 static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
-- 
1.6.2.4





From Larry.Finger at lwfinger.net  Fri Aug 14 00:15:07 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 13 Aug 2009 17:15:07 -0500
Subject: [PATCH] b43: Fix sparse warnings
Message-ID: <4a84906b.+IYGhiNLKPSjrrR7%Larry.Finger@lwfinger.net>

The b43 driver generates the following sparse warnings:

  CHECK   drivers/net/wireless/b43/phy_g.c
drivers/net/wireless/b43/phy_g.c:974:35: warning: cast truncates bits from constant value (ffff7fff becomes 7fff)
  CHECK   drivers/net/wireless/b43/wa.c
drivers/net/wireless/b43/wa.c:385:53: warning: cast truncates bits from constant value (ffff00ff becomes ff)
drivers/net/wireless/b43/wa.c:403:48: warning: cast truncates bits from constant value (ffff00ff becomes ff)
drivers/net/wireless/b43/wa.c:405:48: warning: cast truncates bits from constant value (ffff00ff becomes ff)
drivers/net/wireless/b43/wa.c:415:50: warning: cast truncates bits from constant value (ffff0fff becomes fff)

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

There is no hurry for this material.

Larry
---

Index: wireless-testing/drivers/net/wireless/b43/phy_g.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/phy_g.c
+++ wireless-testing/drivers/net/wireless/b43/phy_g.c
@@ -971,7 +971,7 @@ b43_radio_interference_mitigation_enable
 		b43_phy_maskset(dev, 0x04A2, 0xFFF0, 0x000B);
 
 		if (phy->rev >= 3) {
-			b43_phy_mask(dev, 0x048A, (u16)~0x8000);
+			b43_phy_mask(dev, 0x048A, (u16)(~0x8000 & 0xFFFF));
 			b43_phy_maskset(dev, 0x0415, 0x8000, 0x36D8);
 			b43_phy_maskset(dev, 0x0416, 0x8000, 0x36D8);
 			b43_phy_maskset(dev, 0x0417, 0xFE00, 0x016D);
Index: wireless-testing/drivers/net/wireless/b43/wa.c
===================================================================
--- wireless-testing.orig/drivers/net/wireless/b43/wa.c
+++ wireless-testing/drivers/net/wireless/b43/wa.c
@@ -382,7 +382,8 @@ static void b43_wa_altagc(struct b43_wld
 		b43_ofdmtab_write16(dev, B43_OFDMTAB_AGC1, 3, 25);
 	}
 
-	b43_phy_maskset(dev, B43_PHY_CCKSHIFTBITS_WA, (u16)~0xFF00, 0x5700);
+	b43_phy_maskset(dev, B43_PHY_CCKSHIFTBITS_WA, (u16)(~0xFF00 & 0xFFFF),
+			0x5700);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x1A), ~0x007F, 0x000F);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x1A), ~0x3F80, 0x2B80);
 	b43_phy_maskset(dev, B43_PHY_ANTWRSETT, 0xF0FF, 0x0300);
@@ -400,9 +401,9 @@ static void b43_wa_altagc(struct b43_wld
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x89), ~0x00FF, 0x0020);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x89), ~0x3F00, 0x0200);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x82), ~0x00FF, 0x002E);
-	b43_phy_maskset(dev, B43_PHY_OFDM(0x96), (u16)~0xFF00, 0x1A00);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x96), (u16)(~0xFF00 & 0xFFFF), 0x1A00);
 	b43_phy_maskset(dev, B43_PHY_OFDM(0x81), ~0x00FF, 0x0028);
-	b43_phy_maskset(dev, B43_PHY_OFDM(0x81), (u16)~0xFF00, 0x2C00);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0x81), (u16)(~0xFF00 & 0xFFFF), 0x2C00);
 	if (phy->rev == 1) {
 		b43_phy_write(dev, B43_PHY_PEAK_COUNT, 0x092B);
 		b43_phy_maskset(dev, B43_PHY_OFDM(0x1B), ~0x001E, 0x0002);
@@ -412,7 +413,8 @@ static void b43_wa_altagc(struct b43_wld
 		b43_phy_maskset(dev, B43_PHY_LPFGAINCTL, ~0x000F, 0x0004);
 		if (phy->rev >= 6) {
 			b43_phy_write(dev, B43_PHY_OFDM(0x22), 0x287A);
-			b43_phy_maskset(dev, B43_PHY_LPFGAINCTL, (u16)~0xF000, 0x3000);
+			b43_phy_maskset(dev, B43_PHY_LPFGAINCTL, (u16)(~0xF000 &
+					0xFFFF), 0x3000);
 		}
 	}
 	b43_phy_maskset(dev, B43_PHY_DIVSRCHIDX, 0x8080, 0x7874);


From netrolller.3d at gmail.com  Fri Aug 14 00:15:17 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 00:15:17 +0200
Subject: [PATCH] b43: LP-PHY: Implement channel switching for rev0/1/B2062
	radio
Message-ID: <4A849075.7000000@gmail.com>

-Move pdiv from lpphy_2062_init to struct b43_phy_lp.
-Add channel table for the B2062 radio.
-Add code for tuning the B2062 radio to channel.
-Add error handling to op_switch_channel, and use it for both radios.

Rev0/1/B2062 will now hopefully show some signs of life, though
it won't work at full performance, as calibration is still missing.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Larry, this one is for your PHY/radio revision! :-)

 drivers/net/wireless/b43/phy_lp.c |  297 +++++++++++++++++++++++++++++++++++--
 drivers/net/wireless/b43/phy_lp.h |    2 +
 2 files changed, 284 insertions(+), 15 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 992e250..cc27941 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -455,8 +455,9 @@ struct b2062_freqdata {
 /* Initialize the 2062 radio. */
 static void lpphy_2062_init(struct b43_wldev *dev)
 {
+	struct b43_phy_lp *lpphy = dev->phy.lp;
 	struct ssb_bus *bus = dev->dev->bus;
-	u32 crystalfreq, pdiv, tmp, ref;
+	u32 crystalfreq, tmp, ref;
 	unsigned int i;
 	const struct b2062_freqdata *fd = NULL;
 
@@ -496,22 +497,24 @@ static void lpphy_2062_init(struct b43_wldev *dev)
 	B43_WARN_ON(crystalfreq == 0);
 
 	if (crystalfreq >= 30000000) {
-		pdiv = 1;
+		lpphy->pdiv = 1;
 		b43_radio_mask(dev, B2062_S_RFPLL_CTL1, 0xFFFB);
 	} else {
-		pdiv = 2;
+		lpphy->pdiv = 2;
 		b43_radio_set(dev, B2062_S_RFPLL_CTL1, 0x4);
 	}
 
-	tmp = (800000000 * pdiv + crystalfreq) / (32000000 * pdiv);
+	tmp = (800000000 * lpphy->pdiv + crystalfreq) /
+	      (32000000 * lpphy->pdiv);
 	tmp = (tmp - 1) & 0xFF;
 	b43_radio_write(dev, B2062_S_RFPLL_CTL18, tmp);
 
-	tmp = (2 * crystalfreq + 1000000 * pdiv) / (2000000 * pdiv);
+	tmp = (2 * crystalfreq + 1000000 * lpphy->pdiv) /
+	      (2000000 * lpphy->pdiv);
 	tmp = ((tmp & 0xFF) - 1) & 0xFFFF;
 	b43_radio_write(dev, B2062_S_RFPLL_CTL19, tmp);
 
-	ref = (1000 * pdiv + 2 * crystalfreq) / (2000 * pdiv);
+	ref = (1000 * lpphy->pdiv + 2 * crystalfreq) / (2000 * lpphy->pdiv);
 	ref &= 0xFFFF;
 	for (i = 0; i < ARRAY_SIZE(freqdata_tab); i++) {
 		if (ref < freqdata_tab[i].freq) {
@@ -1431,6 +1434,162 @@ struct b206x_channel {
 	u8 data[12];
 };
 
+static const struct b206x_channel b2062_chantbl[] = {
+	{ .channel = 1, .freq = 2412, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 2, .freq = 2417, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 3, .freq = 2422, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 4, .freq = 2427, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 5, .freq = 2432, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 6, .freq = 2437, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 7, .freq = 2442, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 8, .freq = 2447, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 9, .freq = 2452, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 10, .freq = 2457, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 11, .freq = 2462, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 12, .freq = 2467, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 13, .freq = 2472, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 14, .freq = 2484, .data[0] = 0xFF, .data[1] = 0xFF,
+	  .data[2] = 0xB5, .data[3] = 0x1B, .data[4] = 0x24, .data[5] = 0x32,
+	  .data[6] = 0x32, .data[7] = 0x88, .data[8] = 0x88, },
+	{ .channel = 34, .freq = 5170, .data[0] = 0x00, .data[1] = 0x22,
+	  .data[2] = 0x20, .data[3] = 0x84, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 38, .freq = 5190, .data[0] = 0x00, .data[1] = 0x11,
+	  .data[2] = 0x10, .data[3] = 0x83, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 42, .freq = 5210, .data[0] = 0x00, .data[1] = 0x11,
+	  .data[2] = 0x10, .data[3] = 0x83, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 46, .freq = 5230, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x83, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 36, .freq = 5180, .data[0] = 0x00, .data[1] = 0x11,
+	  .data[2] = 0x20, .data[3] = 0x83, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 40, .freq = 5200, .data[0] = 0x00, .data[1] = 0x11,
+	  .data[2] = 0x10, .data[3] = 0x84, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 44, .freq = 5220, .data[0] = 0x00, .data[1] = 0x11,
+	  .data[2] = 0x00, .data[3] = 0x83, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 48, .freq = 5240, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x83, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 52, .freq = 5260, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x83, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 56, .freq = 5280, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x83, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 60, .freq = 5300, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x63, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 64, .freq = 5320, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x62, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 100, .freq = 5500, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x30, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 104, .freq = 5520, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x20, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 108, .freq = 5540, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x20, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 112, .freq = 5560, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x20, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 116, .freq = 5580, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x10, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 120, .freq = 5600, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x00, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 124, .freq = 5620, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x00, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 128, .freq = 5640, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x00, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 132, .freq = 5660, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x00, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 136, .freq = 5680, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x00, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 140, .freq = 5700, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x00, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 149, .freq = 5745, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x00, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 153, .freq = 5765, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x00, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 157, .freq = 5785, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x00, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 161, .freq = 5805, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x00, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 165, .freq = 5825, .data[0] = 0x00, .data[1] = 0x00,
+	  .data[2] = 0x00, .data[3] = 0x00, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x37, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 184, .freq = 4920, .data[0] = 0x55, .data[1] = 0x77,
+	  .data[2] = 0x90, .data[3] = 0xF7, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0xFF, },
+	{ .channel = 188, .freq = 4940, .data[0] = 0x44, .data[1] = 0x77,
+	  .data[2] = 0x80, .data[3] = 0xE7, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0xFF, },
+	{ .channel = 192, .freq = 4960, .data[0] = 0x44, .data[1] = 0x66,
+	  .data[2] = 0x80, .data[3] = 0xE7, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0xFF, },
+	{ .channel = 196, .freq = 4980, .data[0] = 0x33, .data[1] = 0x66,
+	  .data[2] = 0x70, .data[3] = 0xC7, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0xFF, },
+	{ .channel = 200, .freq = 5000, .data[0] = 0x22, .data[1] = 0x55,
+	  .data[2] = 0x60, .data[3] = 0xD7, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0xFF, },
+	{ .channel = 204, .freq = 5020, .data[0] = 0x22, .data[1] = 0x55,
+	  .data[2] = 0x60, .data[3] = 0xC7, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0xFF, },
+	{ .channel = 208, .freq = 5040, .data[0] = 0x22, .data[1] = 0x44,
+	  .data[2] = 0x50, .data[3] = 0xC7, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0xFF, },
+	{ .channel = 212, .freq = 5060, .data[0] = 0x11, .data[1] = 0x44,
+	  .data[2] = 0x50, .data[3] = 0xA5, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+	{ .channel = 216, .freq = 5080, .data[0] = 0x00, .data[1] = 0x44,
+	  .data[2] = 0x40, .data[3] = 0xB6, .data[4] = 0x3C, .data[5] = 0x77,
+	  .data[6] = 0x35, .data[7] = 0xFF, .data[8] = 0x88, },
+};
+
 static const struct b206x_channel b2063_chantbl[] = {
 	{ .channel = 1, .freq = 2412, .data[0] = 0x6F, .data[1] = 0x3C,
 	  .data[2] = 0x3C, .data[3] = 0x04, .data[4] = 0x05, .data[5] = 0x05,
@@ -1638,10 +1797,110 @@ static const struct b206x_channel b2063_chantbl[] = {
 	  .data[10] = 0x40, .data[11] = 0x00, },
 };
 
-static void lpphy_b2062_tune(struct b43_wldev *dev,
-			     unsigned int channel)
+static void lpphy_b2062_reset_pll_bias(struct b43_wldev *dev)
 {
-	//TODO
+	struct ssb_bus *bus = dev->dev->bus;
+
+	b43_radio_write(dev, B2062_S_RFPLL_CTL2, 0xFF);
+	udelay(20);
+	if (bus->chip_id == 0x5354) {
+		b43_radio_write(dev, B2062_N_COMM1, 4);
+		b43_radio_write(dev, B2062_S_RFPLL_CTL2, 4);
+	} else {
+		b43_radio_write(dev, B2062_S_RFPLL_CTL2, 0);
+	}
+	udelay(5);
+}
+
+static void lpphy_b2062_vco_calib(struct b43_wldev *dev)
+{
+	b43_phy_write(dev, B2062_S_RFPLL_CTL21, 0x42);
+	b43_phy_write(dev, B2062_S_RFPLL_CTL21, 0x62);
+	udelay(200);
+}
+
+static int lpphy_b2062_tune(struct b43_wldev *dev,
+			    unsigned int channel)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct ssb_bus *bus = dev->dev->bus;
+	static const struct b206x_channel *chandata = NULL;
+	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
+	u32 tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8, tmp9;
+	int i, err = 0;
+
+	for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
+		if (b2063_chantbl[i].channel == channel) {
+			chandata = &b2063_chantbl[i];
+			break;
+		}
+	}
+
+	if (B43_WARN_ON(!chandata))
+		return -EINVAL;
+
+	b43_radio_set(dev, B2062_S_RFPLL_CTL14, 0x04);
+	b43_radio_write(dev, B2062_N_LGENA_TUNE0, chandata->data[0]);
+	b43_radio_write(dev, B2062_N_LGENA_TUNE2, chandata->data[1]);
+	b43_radio_write(dev, B2062_N_LGENA_TUNE3, chandata->data[2]);
+	b43_radio_write(dev, B2062_N_TX_TUNE, chandata->data[3]);
+	b43_radio_write(dev, B2062_S_LGENG_CTL1, chandata->data[4]);
+	b43_radio_write(dev, B2062_N_LGENA_CTL5, chandata->data[5]);
+	b43_radio_write(dev, B2062_N_LGENA_CTL6, chandata->data[6]);
+	b43_radio_write(dev, B2062_N_TX_PGA, chandata->data[7]);
+	b43_radio_write(dev, B2062_N_TX_PAD, chandata->data[8]);
+	
+	tmp1 = crystal_freq / 1000;
+	tmp2 = lpphy->pdiv * 1000;
+	b43_radio_write(dev, B2062_S_RFPLL_CTL33, 0xCC);
+	b43_radio_write(dev, B2062_S_RFPLL_CTL34, 0x07);
+	lpphy_b2062_reset_pll_bias(dev);
+	tmp3 = tmp2 * channel2freq_lp(channel);
+	if (channel2freq_lp(channel) < 4000)
+		tmp3 *= 2;
+	tmp4 = 48 * tmp1;
+	tmp6 = tmp3 / tmp4;
+	tmp7 = tmp3 % tmp4;
+	b43_radio_write(dev, B2062_S_RFPLL_CTL26, tmp6);
+	tmp5 = tmp7 * 0x100;
+	tmp6 = tmp5 / tmp4;
+	tmp7 = tmp5 % tmp4;
+	b43_radio_write(dev, B2062_S_RFPLL_CTL28, tmp6);
+	tmp5 = tmp7 * 0x100;
+	tmp6 = tmp5 / tmp4;
+	tmp7 = tmp5 % tmp4;
+	b43_radio_write(dev, B2062_S_RFPLL_CTL29, tmp6 + ((2 * tmp7) / tmp4));
+	tmp8 = b43_phy_read(dev, B2062_S_RFPLL_CTL19);
+	tmp9 = ((2 * tmp3 * (tmp8 + 1)) + (3 * tmp1)) / (6 * tmp1);
+	b43_radio_write(dev, B2062_S_RFPLL_CTL23, tmp9 >> 8);
+	b43_radio_write(dev, B2062_S_RFPLL_CTL24, tmp9 & 0xFF);
+	
+	lpphy_b2062_vco_calib(dev);
+	if (b43_radio_read(dev, B2062_S_RFPLL_CTL3) & 0x10) {
+		b43_radio_write(dev, B2062_S_RFPLL_CTL33, 0xFC);
+		b43_radio_write(dev, B2062_S_RFPLL_CTL34, 0);
+		lpphy_b2062_reset_pll_bias(dev);
+		lpphy_b2062_vco_calib(dev);
+		if (b43_radio_read(dev, B2062_S_RFPLL_CTL3) & 0x10)
+			err = -EINVAL;
+	}
+
+	b43_radio_mask(dev, B2062_S_RFPLL_CTL14, ~0x04);
+	return err;
+}
+
+static void lpphy_japan_filter(struct b43_wldev *dev, int channel)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	u16 tmp = (channel == 14); //SPEC FIXME check japanwidefilter!
+
+	if (dev->phy.rev < 2) { //SPEC FIXME Isn't this rev0/1-specific?
+		b43_phy_maskset(dev, B43_LPPHY_LP_PHY_CTL, 0xFCFF, tmp << 9);
+		if ((dev->phy.rev == 1) && (lpphy->rc_cap))
+			lpphy_set_rc_cap(dev);
+	} else {
+		b43_radio_write(dev, B2063_TX_BB_SP3, 0x3F);
+	}
 }
 
 static void lpphy_b2063_vco_calib(struct b43_wldev *dev)
@@ -1661,8 +1920,8 @@ static void lpphy_b2063_vco_calib(struct b43_wldev *dev)
 	b43_phy_set(dev, B2063_PLL_SP1, 0x40);
 }
 
-static void lpphy_b2063_tune(struct b43_wldev *dev,
-			     unsigned int channel)
+static int lpphy_b2063_tune(struct b43_wldev *dev,
+			    unsigned int channel)
 {
 	struct ssb_bus *bus = dev->dev->bus;
 
@@ -1681,7 +1940,7 @@ static void lpphy_b2063_tune(struct b43_wldev *dev,
 	}
 
 	if (B43_WARN_ON(!chandata))
-		return;
+		return -EINVAL;
 
 	b43_radio_write(dev, B2063_LOGEN_VCOBUF1, chandata->data[0]);
 	b43_radio_write(dev, B2063_LOGEN_MIXER2, chandata->data[1]);
@@ -1780,18 +2039,26 @@ static void lpphy_b2063_tune(struct b43_wldev *dev,
 	b43_phy_mask(dev, B2063_PLL_SP2, 0xFFFC);
 	lpphy_b2063_vco_calib(dev);
 	b43_radio_write(dev, B2063_COMM15, old_comm15);
+
+	return 0;
 }
 
 static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
 				       unsigned int new_channel)
 {
+	int err;
+
 	b43_write16(dev, B43_MMIO_CHANNEL, new_channel);
 
 	if (dev->phy.radio_ver == 0x2063) {
-		lpphy_b2063_tune(dev, new_channel);
+		err = lpphy_b2063_tune(dev, new_channel);
+		if (err)
+			return err;
 	} else {
-		lpphy_b2062_tune(dev, new_channel);
-		//TODO Japan filter
+		err = lpphy_b2062_tune(dev, new_channel);
+		if (err)
+			return err;
+		lpphy_japan_filter(dev, new_channel);
 	}
 
 	lpphy_adjust_gain_table(dev, channel2freq_lp(new_channel));
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 4eab760..99cb038 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -884,6 +884,8 @@ struct b43_phy_lp {
 
 	/* Used for "Save/Restore Dig Filt State" */
 	u16 dig_flt_state[9];
+
+	unsigned int pdiv;
 };
 
 enum tssi_mux_mode {
-- 
1.6.2.4





From mark.sf.net at huijgen.tk  Fri Aug 14 12:41:47 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Fri, 14 Aug 2009 12:41:47 +0200
Subject: [PATCH] b43: LP-PHY: Implement channel switching for rev0/1/B2062
	radio
In-Reply-To: <4A849075.7000000@gmail.com>
References: <4A849075.7000000@gmail.com>
Message-ID: <4A853F6B.5010408@huijgen.tk>

G?bor Stefanik wrote:
> Rev0/1/B2062 will now hopefully show some signs of life, though
> it won't work at full performance, as calibration is still missing.
>   

Just compiled wireless-testing.git**, enabled LP phy support in config,
to see how far it gets here:

modprobe b43 verbose=3

[ 1068.690053] b43-phy3: Broadcom 4312 WLAN found (core revision 15)
[ 1068.732048] b43-phy3 debug: Found PHY: Analog 6, Type 5, Revision 1
[ 1068.732062] b43-phy3 debug: Found Radio: Manuf 0x17F, Version 0x2062,
Revision 2
[ 1068.756465] phy3: Selected rate control algorithm 'minstrel'
[ 1068.756581] Broadcom 43xx driver loaded [ Features: PL, Firmware-ID:
FW13 ]


ifconfig wlan0
wlan0     Link encap:Ethernet  HWaddr FF:FF:FF:FF:FF:FF
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)

ifconfig wlan0 up
SIOCSIFFLAGS: Cannot assign requested address

Did some looking around and it seems b43_op_start() is never called, so
its bailing out somewhere in mac80211? Something to do with the mac addr
being alls FF's?

Mark


* Card pci id:
10:00.0 0280: 14e4:4315 (rev 01)
        Subsystem: 103c:137d

** git version:
http://git.kernel.org/?p=linux/kernel/git/linville/wireless-testing.git;a=commit;h=b2004c4a9483b295a7413d41d08604943670ab26


From netrolller.3d at gmail.com  Fri Aug 14 12:51:25 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Fri, 14 Aug 2009 12:51:25 +0200
Subject: [PATCH] b43: LP-PHY: Implement channel switching for rev0/1/B2062
	radio
In-Reply-To: <4A853F6B.5010408@huijgen.tk>
References: <4A849075.7000000@gmail.com> <4A853F6B.5010408@huijgen.tk>
Message-ID: <69e28c910908140351k64681bfav78d746d45e7b62e1@mail.gmail.com>

2009/8/14 Mark Huijgen <mark.sf.net at huijgen.tk>:
> G?bor Stefanik wrote:
>> Rev0/1/B2062 will now hopefully show some signs of life, though
>> it won't work at full performance, as calibration is still missing.
>>
>
> Just compiled wireless-testing.git**, enabled LP phy support in config,
> to see how far it gets here:

Wireless-testing doesn't have all the needed patches yet - apply the
outstanding patches from the list to test the real current state.

>
> modprobe b43 verbose=3
>
> [ 1068.690053] b43-phy3: Broadcom 4312 WLAN found (core revision 15)
> [ 1068.732048] b43-phy3 debug: Found PHY: Analog 6, Type 5, Revision 1
> [ 1068.732062] b43-phy3 debug: Found Radio: Manuf 0x17F, Version 0x2062,
> Revision 2
> [ 1068.756465] phy3: Selected rate control algorithm 'minstrel'
> [ 1068.756581] Broadcom 43xx driver loaded [ Features: PL, Firmware-ID:
> FW13 ]
>
>
> ifconfig wlan0
> wlan0 ? ? Link encap:Ethernet ?HWaddr FF:FF:FF:FF:FF:FF
> ? ? ? ? ?BROADCAST MULTICAST ?MTU:1500 ?Metric:1
> ? ? ? ? ?RX packets:0 errors:0 dropped:0 overruns:0 frame:0
> ? ? ? ? ?TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
> ? ? ? ? ?collisions:0 txqueuelen:1000
> ? ? ? ? ?RX bytes:0 (0.0 b) ?TX bytes:0 (0.0 b)
>
> ifconfig wlan0 up
> SIOCSIFFLAGS: Cannot assign requested address

Uhh, that doesn't look good...

>
> Did some looking around and it seems b43_op_start() is never called, so
> its bailing out somewhere in mac80211? Something to do with the mac addr
> being alls FF's?

Yes, FF:FF:FF:FF:FF:FF is not a valid MAC. Mac80211 refuses to
initialize a card with an invalid MAC address.
Now, the question is, how does the MAC address end up being
FF:FF:FF:FF:FF:FF...? Presumably there is a switch(phy->type) in the
generic (non-LP-specific) code that doesn't have case B43_PHYTYPE_LP
and returns FF:FF:FF:FF:FF:FF as the default. I'll investigate.

BTW could you post the output of "iwconfig wlan0", "iw dev wlan0 info"
and "iw phy phy3 info" (replace phy3 with the phy name from dmesg)?

>
> Mark
>
>
> * Card pci id:
> 10:00.0 0280: 14e4:4315 (rev 01)
> ? ? ? ?Subsystem: 103c:137d
>
> ** git version:
> http://git.kernel.org/?p=linux/kernel/git/linville/wireless-testing.git;a=commit;h=b2004c4a9483b295a7413d41d08604943670ab26
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mark.sf.net at huijgen.tk  Fri Aug 14 13:18:16 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Fri, 14 Aug 2009 13:18:16 +0200
Subject: [PATCH] b43: LP-PHY: Implement channel switching for rev0/1/B2062
	radio
In-Reply-To: <69e28c910908140351k64681bfav78d746d45e7b62e1@mail.gmail.com>
References: <4A849075.7000000@gmail.com> <4A853F6B.5010408@huijgen.tk>
	<69e28c910908140351k64681bfav78d746d45e7b62e1@mail.gmail.com>
Message-ID: <4A8547F8.4050305@huijgen.tk>

G?bor Stefanik wrote:
>>
>> ifconfig wlan0
>> wlan0     Link encap:Ethernet  HWaddr FF:FF:FF:FF:FF:FF
>>          BROADCAST MULTICAST  MTU:1500  Metric:1
>>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>>          collisions:0 txqueuelen:1000
>>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
>>
>> ifconfig wlan0 up
>> SIOCSIFFLAGS: Cannot assign requested address
>>     
>
> Uhh, that doesn't look good...
>   
I've investigated with some SSB debugging:
[ 4895.592113] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor
0x4243)
[ 4895.592125] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F,
vendor 0x4243)
[ 4895.592135] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)
[ 4895.592145] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)
[ 4895.612051] ssb: Found rev 1 PMU (capabilities 0x02A62F01)
[ 4895.620727] ssb: SPROM revision 8 detected.
[ 4895.620732] ssb: MAC ff:ff:ff:ff:ff:ff
[ 4895.642495] ssb: Sonics Silicon Backplane found on PCI device
0000:10:00.0

I added the ssb: MAC line, sprom extraction seems incorrect for this
device (is ssb up to date enough in wireless-testing for this device?).

>   
>> Did some looking around and it seems b43_op_start() is never called, so
>> its bailing out somewhere in mac80211? Something to do with the mac addr
>> being alls FF's?
>>     
>
> Yes, FF:FF:FF:FF:FF:FF is not a valid MAC. Mac80211 refuses to
> initialize a card with an invalid MAC address.
> Now, the question is, how does the MAC address end up being
> FF:FF:FF:FF:FF:FF...? Presumably there is a switch(phy->type) in the
> generic (non-LP-specific) code that doesn't have case B43_PHYTYPE_LP
> and returns FF:FF:FF:FF:FF:FF as the default. I'll investigate.
>
> BTW could you post the output of "iwconfig wlan0", "iw dev wlan0 info"
> and "iw phy phy3 info" (replace phy3 with the phy name from dmesg)?

# iwconfig wlan0
wlan0     IEEE 802.11bg  Mode:Managed  Access Point: Not-Associated
          Tx-Power=0 dBm
          Retry  long limit:7   RTS thr:off   Fragment thr:off
          Encryption key:off
          Power Management:off

# iw dev wlan0 info
Interface wlan0
        ifindex 16
        type managed

# iw phy phy13 info
Wiphy phy13
        Band 1:
                Frequencies:
                        * 2412 MHz [1] (27.0 dBm)
                        * 2417 MHz [2] (27.0 dBm)
                        * 2422 MHz [3] (27.0 dBm)
                        * 2427 MHz [4] (27.0 dBm)
                        * 2432 MHz [5] (27.0 dBm)
                        * 2437 MHz [6] (27.0 dBm)
                        * 2442 MHz [7] (27.0 dBm)
                        * 2447 MHz [8] (27.0 dBm)
                        * 2452 MHz [9] (27.0 dBm)
                        * 2457 MHz [10] (27.0 dBm)
                        * 2462 MHz [11] (27.0 dBm)
                        * 2467 MHz [12] (disabled)
                        * 2472 MHz [13] (disabled)
                        * 2484 MHz [14] (disabled)
                Bitrates (non-HT):
                        * 1.0 Mbps
                        * 2.0 Mbps (short preamble supported)
                        * 5.5 Mbps (short preamble supported)
                        * 11.0 Mbps (short preamble supported)
                        * 6.0 Mbps
                        * 9.0 Mbps
                        * 12.0 Mbps
                        * 18.0 Mbps
                        * 24.0 Mbps
                        * 36.0 Mbps
                        * 48.0 Mbps
                        * 54.0 Mbps
        max # scan SSIDs: 4
        Supported interface modes:
                 * IBSS
                 * managed
                 * AP
                 * AP/VLAN
                 * WDS
                 * monitor






From netrolller.3d at gmail.com  Fri Aug 14 13:34:10 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Fri, 14 Aug 2009 13:34:10 +0200
Subject: [PATCH] b43: LP-PHY: Implement channel switching for rev0/1/B2062
	radio
In-Reply-To: <4A8547F8.4050305@huijgen.tk>
References: <4A849075.7000000@gmail.com> <4A853F6B.5010408@huijgen.tk> 
	<69e28c910908140351k64681bfav78d746d45e7b62e1@mail.gmail.com> 
	<4A8547F8.4050305@huijgen.tk>
Message-ID: <69e28c910908140434p659c471bpa15c8d11f77b3efd@mail.gmail.com>

2009/8/14 Mark Huijgen <mark.sf.net at huijgen.tk>:
> G?bor Stefanik wrote:
>>>
>>> ifconfig wlan0
>>> wlan0 ? ? Link encap:Ethernet ?HWaddr FF:FF:FF:FF:FF:FF
>>> ? ? ? ? ?BROADCAST MULTICAST ?MTU:1500 ?Metric:1
>>> ? ? ? ? ?RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>>> ? ? ? ? ?TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>>> ? ? ? ? ?collisions:0 txqueuelen:1000
>>> ? ? ? ? ?RX bytes:0 (0.0 b) ?TX bytes:0 (0.0 b)
>>>
>>> ifconfig wlan0 up
>>> SIOCSIFFLAGS: Cannot assign requested address
>>>
>>
>> Uhh, that doesn't look good...
>>
> I've investigated with some SSB debugging:
> [ 4895.592113] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor
> 0x4243)
> [ 4895.592125] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F,
> vendor 0x4243)
> [ 4895.592135] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)
> [ 4895.592145] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)
> [ 4895.612051] ssb: Found rev 1 PMU (capabilities 0x02A62F01)
> [ 4895.620727] ssb: SPROM revision 8 detected.
> [ 4895.620732] ssb: MAC ff:ff:ff:ff:ff:ff
> [ 4895.642495] ssb: Sonics Silicon Backplane found on PCI device
> 0000:10:00.0
>
> I added the ssb: MAC line, sprom extraction seems incorrect for this
> device (is ssb up to date enough in wireless-testing for this device?).

Hmm... could you run "sudo cat $(find /sys -name ssb_sprom) >
~/ssb_sprom_copy", then upload ~/ssb_sprom_copy to somewhere?
SSB in wireless-testing is up-to-date to the best of my knowledge - it
definitely handles MAC address extraction.

>
>>
>>> Did some looking around and it seems b43_op_start() is never called, so
>>> its bailing out somewhere in mac80211? Something to do with the mac addr
>>> being alls FF's?
>>>
>>
>> Yes, FF:FF:FF:FF:FF:FF is not a valid MAC. Mac80211 refuses to
>> initialize a card with an invalid MAC address.
>> Now, the question is, how does the MAC address end up being
>> FF:FF:FF:FF:FF:FF...? Presumably there is a switch(phy->type) in the
>> generic (non-LP-specific) code that doesn't have case B43_PHYTYPE_LP
>> and returns FF:FF:FF:FF:FF:FF as the default. I'll investigate.
>>
>> BTW could you post the output of "iwconfig wlan0", "iw dev wlan0 info"
>> and "iw phy phy3 info" (replace phy3 with the phy name from dmesg)?
>
> # iwconfig wlan0
> wlan0 ? ? IEEE 802.11bg ?Mode:Managed ?Access Point: Not-Associated
> ? ? ? ? ?Tx-Power=0 dBm
> ? ? ? ? ?Retry ?long limit:7 ? RTS thr:off ? Fragment thr:off
> ? ? ? ? ?Encryption key:off
> ? ? ? ? ?Power Management:off
>
> # iw dev wlan0 info
> Interface wlan0
> ? ? ? ?ifindex 16
> ? ? ? ?type managed
>
> # iw phy phy13 info
> Wiphy phy13
> ? ? ? ?Band 1:
> ? ? ? ? ? ? ? ?Frequencies:
> ? ? ? ? ? ? ? ? ? ? ? ?* 2412 MHz [1] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2417 MHz [2] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2422 MHz [3] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2427 MHz [4] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2432 MHz [5] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2437 MHz [6] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2442 MHz [7] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2447 MHz [8] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2452 MHz [9] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2457 MHz [10] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2462 MHz [11] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2467 MHz [12] (disabled)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2472 MHz [13] (disabled)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2484 MHz [14] (disabled)
> ? ? ? ? ? ? ? ?Bitrates (non-HT):
> ? ? ? ? ? ? ? ? ? ? ? ?* 1.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 2.0 Mbps (short preamble supported)
> ? ? ? ? ? ? ? ? ? ? ? ?* 5.5 Mbps (short preamble supported)
> ? ? ? ? ? ? ? ? ? ? ? ?* 11.0 Mbps (short preamble supported)
> ? ? ? ? ? ? ? ? ? ? ? ?* 6.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 9.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 12.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 18.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 24.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 36.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 48.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 54.0 Mbps
> ? ? ? ?max # scan SSIDs: 4
> ? ? ? ?Supported interface modes:
> ? ? ? ? ? ? ? ? * IBSS
> ? ? ? ? ? ? ? ? * managed
> ? ? ? ? ? ? ? ? * AP
> ? ? ? ? ? ? ? ? * AP/VLAN
> ? ? ? ? ? ? ? ? * WDS
> ? ? ? ? ? ? ? ? * monitor

That's also wrong - the driver should be registering an 5GHz band as
well (as I haven't yet added a check as to whether the LP-PHY in
question is A/G or G-only - so getting only one band means something
is limiting registration to G mode).

BTW there is another problem that will prevent starting the device
once this is fixed (firmware loading fails) - I'm about to submit a
patch for that one soon.

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mark.sf.net at huijgen.tk  Fri Aug 14 13:51:02 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Fri, 14 Aug 2009 13:51:02 +0200
Subject: [Fwd: Re: [PATCH] b43: LP-PHY: Implement channel switching for
	rev0/1/B2062 radio]
Message-ID: <4A854FA6.1010502@huijgen.tk>

Sent from wrong email address, so didn't made it to the list.

-------- Original Message --------
Subject: 	Re: [PATCH] b43: LP-PHY: Implement channel switching for
rev0/1/B2062 radio
Date: 	Fri, 14 Aug 2009 13:34:34 +0200



Mark Huijgen wrote:
> G?bor Stefanik wrote:
>   
>>> ifconfig wlan0
>>> wlan0     Link encap:Ethernet  HWaddr FF:FF:FF:FF:FF:FF
>>>          BROADCAST MULTICAST  MTU:1500  Metric:1
>>>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>>>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>>>          collisions:0 txqueuelen:1000
>>>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
>>>
>>> ifconfig wlan0 up
>>> SIOCSIFFLAGS: Cannot assign requested address
>>>     
>>>       
>> Uhh, that doesn't look good...
>>   
>>     
> I've investigated with some SSB debugging:
> [ 4895.592113] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor
> 0x4243)
> [ 4895.592125] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F,
> vendor 0x4243)
> [ 4895.592135] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)
> [ 4895.592145] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)
> [ 4895.612051] ssb: Found rev 1 PMU (capabilities 0x02A62F01)
> [ 4895.620727] ssb: SPROM revision 8 detected.
> [ 4895.620732] ssb: MAC ff:ff:ff:ff:ff:ff
> [ 4895.642495] ssb: Sonics Silicon Backplane found on PCI device
> 0000:10:00.0
>
> I added the ssb: MAC line, sprom extraction seems incorrect for this
> device (is ssb up to date enough in wireless-testing for this device?).
>   
Actual mac determined with broadcoms driver:  00:1A:73:E4:F6:89
sprom contents:
012800007D133C107800BE6D0000C42B642A6429642CE73CFF467F47000C4078A000FFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1543008002000000301F001800000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF72530712010A0600000000001A00E47389F645440100FF83FFFFFFFF030002FFFFFFFFFF0F00FFFF6C00FFFFFAFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4A3E571A8AF991FEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF080E

The mac is stored in the string as 1A00E47389F6.


Mark




From netrolller.3d at gmail.com  Fri Aug 14 13:51:59 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 13:51:59 +0200
Subject: [PATCH] b43: Add LP-PHY firmware loading support
Message-ID: <4A854FDF.5020208@gmail.com>

Add support for loading LP-PHY firmware to b43_try_request_fw.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
For anyone hoping that the channel switch patches will make their LP card work - this is also definitely required.

Mark, this doesn't fix your problem specifically, but it will be needed after your problem is fixed.

 drivers/net/wireless/b43/main.c |   24 +++++++++++++++++++++++-
 1 files changed, 23 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index fbcbe4f..1e657fe 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -2062,8 +2062,12 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		filename = "ucode5";
 	else if ((rev >= 11) && (rev <= 12))
 		filename = "ucode11";
-	else if (rev >= 13)
+	else if (rev == 13)
 		filename = "ucode13";
+	else if (rev == 14)
+		filename = "ucode14";
+	else if (rev >= 15)
+		filename = "ucode15";
 	else
 		goto err_no_ucode;
 	err = b43_do_request_fw(ctx, filename, &fw->ucode);
@@ -2111,6 +2115,15 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		else
 			goto err_no_initvals;
 		break;
+	case B43_PHYTYPE_LP:
+		if (rev == 13)
+			filename = "lp0initvals13";
+		else if (rev == 14)
+			filename = "lp0initvals14";
+		else if (rev >= 15)
+			filename = "lp0initvals15";
+		else
+			goto err_no_initvals;
 	default:
 		goto err_no_initvals;
 	}
@@ -2145,6 +2158,15 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		else
 			goto err_no_initvals;
 		break;
+	case B43_PHYTYPE_LP:
+		if (rev == 13)
+			filename = "lp0bsinitvals13";
+		else if (rev == 14)
+			filename = "lp0bsinitvals14";
+		else if (rev >= 15)
+			filename = "lp0bsinitvals15";
+		else
+			goto err_no_initvals;
 	default:
 		goto err_no_initvals;
 	}
-- 
1.6.2.4





From mark.sf.net at huijgen.tk  Fri Aug 14 14:00:42 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Fri, 14 Aug 2009 14:00:42 +0200
Subject: [PATCH] ssb: bugfix MAC extract in r8 sprom
In-Reply-To: <4A854BCA.6080801@huijgen.tk>
References: <4A849075.7000000@gmail.com>
	<4A853F6B.5010408@huijgen.tk>	<69e28c910908140351k64681bfav78d746d45e7b62e1@mail.gmail.com>
	<4A8547F8.4050305@huijgen.tk> <4A854BCA.6080801@huijgen.tk>
Message-ID: <4A8551EA.5030405@huijgen.tk>

This patch fixes mac extraction from rev 8 sproms.

diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
index 593fc61..064930d 100644
--- a/drivers/ssb/pci.c
+++ b/drivers/ssb/pci.c
@@ -480,9 +481,12 @@ static void sprom_extract_r8(struct ssb_sprom *out, const u16 *in)

        /* extract the MAC address */
        for (i = 0; i < 3; i++) {
-               v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
+               v = in[SPOFF(SSB_SPROM8_IL0MAC) + i];
                *(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
        }


# ifconfig wlan0
wlan0     Link encap:Ethernet  HWaddr 00:1A:73:E4:F6:89
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)

# ifconfig wlan0 up
SIOCSIFFLAGS: Operation not supported

But now in log:
[ 2035.736059] b43 ssb0:0: firmware: requesting b43/ucode13.fw
[ 2036.088416] b43-phy2 ERROR: The driver does not know which firmware
(initvals) is required for your device (wl-core rev 15)

So now I probably need the patch just posted by G?bor.


Mark


Mark Huijgen wrote:
> Mark Huijgen wrote:
>   
>> G?bor Stefanik wrote:
>>   
>>     
>>>> ifconfig wlan0
>>>> wlan0     Link encap:Ethernet  HWaddr FF:FF:FF:FF:FF:FF
>>>>          BROADCAST MULTICAST  MTU:1500  Metric:1
>>>>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>>>>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>>>>          collisions:0 txqueuelen:1000
>>>>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
>>>>
>>>> ifconfig wlan0 up
>>>> SIOCSIFFLAGS: Cannot assign requested address
>>>>     
>>>>       
>>>>         
>>> Uhh, that doesn't look good...
>>>   
>>>     
>>>       
>> I've investigated with some SSB debugging:
>> [ 4895.592113] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor
>> 0x4243)
>> [ 4895.592125] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F,
>> vendor 0x4243)
>> [ 4895.592135] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)
>> [ 4895.592145] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)
>> [ 4895.612051] ssb: Found rev 1 PMU (capabilities 0x02A62F01)
>> [ 4895.620727] ssb: SPROM revision 8 detected.
>> [ 4895.620732] ssb: MAC ff:ff:ff:ff:ff:ff
>> [ 4895.642495] ssb: Sonics Silicon Backplane found on PCI device
>> 0000:10:00.0
>>
>> I added the ssb: MAC line, sprom extraction seems incorrect for this
>> device (is ssb up to date enough in wireless-testing for this device?).
>>   
>>     
> Actual mac determined with broadcoms driver:  00:1A:73:E4:F6:89
> sprom contents:
> 012800007D133C107800BE6D0000C42B642A6429642CE73CFF467F47000C4078A000FFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1543008002000000301F001800000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF72530712010A0600000000001A00E47389F645440100FF83FFFFFFFF030002FFFFFFFFFF0F00FFFF6C00FFFFFAFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4A3E571A8AF991FEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF080E
>
> The mac is stored in the string as 1A00E47389F6.
>
>
> Mark
>
>   



From netrolller.3d at gmail.com  Fri Aug 14 14:11:53 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 14:11:53 +0200
Subject: [PATCH] ssb: Fix e typo in the rev8 SPROM extraction routine
Message-ID: <4A855489.6010102@gmail.com>

No comment. :-)

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Mark, this should fix your MAC address bug.
Anyone else testing LP-PHY should also apply this.

 drivers/ssb/pci.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
index 50811e4..335a43f 100644
--- a/drivers/ssb/pci.c
+++ b/drivers/ssb/pci.c
@@ -480,7 +480,7 @@ static void sprom_extract_r8(struct ssb_sprom *out, const u16 *in)
 
 	/* extract the MAC address */
 	for (i = 0; i < 3; i++) {
-		v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
+		v = in[SPOFF(SSB_SPROM8_IL0MAC) + i];
 		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
 	}
 	SPEX(country_code, SSB_SPROM8_CCODE, 0xFFFF, 0);
-- 
1.6.2.4





From mark.sf.net at huijgen.tk  Fri Aug 14 14:11:47 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Fri, 14 Aug 2009 14:11:47 +0200
Subject: [PATCH] b43: Add LP-PHY firmware loading support
In-Reply-To: <4A854FDF.5020208@gmail.com>
References: <4A854FDF.5020208@gmail.com>
Message-ID: <4A855483.8070208@huijgen.tk>

Missing break in initval case switches, see below.

G?bor Stefanik wrote:
> Add support for loading LP-PHY firmware to b43_try_request_fw.
>
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> For anyone hoping that the channel switch patches will make their LP card work - this is also definitely required.
>
> Mark, this doesn't fix your problem specifically, but it will be needed after your problem is fixed.
>
>  drivers/net/wireless/b43/main.c |   24 +++++++++++++++++++++++-
>  1 files changed, 23 insertions(+), 1 deletions(-)
>
> diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
> index fbcbe4f..1e657fe 100644
> --- a/drivers/net/wireless/b43/main.c
> +++ b/drivers/net/wireless/b43/main.c
> @@ -2062,8 +2062,12 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
>  		filename = "ucode5";
>  	else if ((rev >= 11) && (rev <= 12))
>  		filename = "ucode11";
> -	else if (rev >= 13)
> +	else if (rev == 13)
>  		filename = "ucode13";
> +	else if (rev == 14)
> +		filename = "ucode14";
> +	else if (rev >= 15)
> +		filename = "ucode15";
>  	else
>  		goto err_no_ucode;
>  	err = b43_do_request_fw(ctx, filename, &fw->ucode);
> @@ -2111,6 +2115,15 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
>  		else
>  			goto err_no_initvals;
>  		break;
> +	case B43_PHYTYPE_LP:
> +		if (rev == 13)
> +			filename = "lp0initvals13";
> +		else if (rev == 14)
> +			filename = "lp0initvals14";
> +		else if (rev >= 15)
> +			filename = "lp0initvals15";
> +		else
> +			goto err_no_initvals;
>   
break;
>  	default:
>  		goto err_no_initvals;
>  	}
> @@ -2145,6 +2158,15 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
>  		else
>  			goto err_no_initvals;
>  		break;
> +	case B43_PHYTYPE_LP:
> +		if (rev == 13)
> +			filename = "lp0bsinitvals13";
> +		else if (rev == 14)
> +			filename = "lp0bsinitvals14";
> +		else if (rev >= 15)
> +			filename = "lp0bsinitvals15";
> +		else
> +			goto err_no_initvals;
>   
break;
>  	default:
>  		goto err_no_initvals;
>  	}
>   



From netrolller.3d at gmail.com  Fri Aug 14 14:13:27 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Fri, 14 Aug 2009 14:13:27 +0200
Subject: [PATCH] ssb: bugfix MAC extract in r8 sprom
In-Reply-To: <4A8551EA.5030405@huijgen.tk>
References: <4A849075.7000000@gmail.com> <4A853F6B.5010408@huijgen.tk> 
	<69e28c910908140351k64681bfav78d746d45e7b62e1@mail.gmail.com> 
	<4A8547F8.4050305@huijgen.tk> <4A854BCA.6080801@huijgen.tk> 
	<4A8551EA.5030405@huijgen.tk>
Message-ID: <69e28c910908140513s1eeb7c6bn812cb73ff61e3fb3@mail.gmail.com>

Beat me by 11 minutes... though you didn't get the patch format right,
so it can't be applied.

2009/8/14 Mark Huijgen <mark.sf.net at huijgen.tk>:
> This patch fixes mac extraction from rev 8 sproms.
>
> diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
> index 593fc61..064930d 100644
> --- a/drivers/ssb/pci.c
> +++ b/drivers/ssb/pci.c
> @@ -480,9 +481,12 @@ static void sprom_extract_r8(struct ssb_sprom *out, const u16 *in)
>
> ? ? ? ?/* extract the MAC address */
> ? ? ? ?for (i = 0; i < 3; i++) {
> - ? ? ? ? ? ? ? v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
> + ? ? ? ? ? ? ? v = in[SPOFF(SSB_SPROM8_IL0MAC) + i];
> ? ? ? ? ? ? ? ?*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
> ? ? ? ?}
>
>
> # ifconfig wlan0
> wlan0 ? ? Link encap:Ethernet ?HWaddr 00:1A:73:E4:F6:89
> ? ? ? ? ?BROADCAST MULTICAST ?MTU:1500 ?Metric:1
> ? ? ? ? ?RX packets:0 errors:0 dropped:0 overruns:0 frame:0
> ? ? ? ? ?TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
> ? ? ? ? ?collisions:0 txqueuelen:1000
> ? ? ? ? ?RX bytes:0 (0.0 b) ?TX bytes:0 (0.0 b)
>
> # ifconfig wlan0 up
> SIOCSIFFLAGS: Operation not supported
>
> But now in log:
> [ 2035.736059] b43 ssb0:0: firmware: requesting b43/ucode13.fw
> [ 2036.088416] b43-phy2 ERROR: The driver does not know which firmware
> (initvals) is required for your device (wl-core rev 15)
>
> So now I probably need the patch just posted by G?bor.
>
>
> Mark
>
>
> Mark Huijgen wrote:
>> Mark Huijgen wrote:
>>
>>> G?bor Stefanik wrote:
>>>
>>>
>>>>> ifconfig wlan0
>>>>> wlan0 ? ? Link encap:Ethernet ?HWaddr FF:FF:FF:FF:FF:FF
>>>>> ? ? ? ? ?BROADCAST MULTICAST ?MTU:1500 ?Metric:1
>>>>> ? ? ? ? ?RX packets:0 errors:0 dropped:0 overruns:0 frame:0
>>>>> ? ? ? ? ?TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
>>>>> ? ? ? ? ?collisions:0 txqueuelen:1000
>>>>> ? ? ? ? ?RX bytes:0 (0.0 b) ?TX bytes:0 (0.0 b)
>>>>>
>>>>> ifconfig wlan0 up
>>>>> SIOCSIFFLAGS: Cannot assign requested address
>>>>>
>>>>>
>>>>>
>>>> Uhh, that doesn't look good...
>>>>
>>>>
>>>>
>>> I've investigated with some SSB debugging:
>>> [ 4895.592113] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor
>>> 0x4243)
>>> [ 4895.592125] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F,
>>> vendor 0x4243)
>>> [ 4895.592135] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)
>>> [ 4895.592145] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)
>>> [ 4895.612051] ssb: Found rev 1 PMU (capabilities 0x02A62F01)
>>> [ 4895.620727] ssb: SPROM revision 8 detected.
>>> [ 4895.620732] ssb: MAC ff:ff:ff:ff:ff:ff
>>> [ 4895.642495] ssb: Sonics Silicon Backplane found on PCI device
>>> 0000:10:00.0
>>>
>>> I added the ssb: MAC line, sprom extraction seems incorrect for this
>>> device (is ssb up to date enough in wireless-testing for this device?).
>>>
>>>
>> Actual mac determined with broadcoms driver: ?00:1A:73:E4:F6:89
>> sprom contents:
>> 012800007D133C107800BE6D0000C42B642A6429642CE73CFF467F47000C4078A000FFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1543008002000000301F001800000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF72530712010A0600000000001A00E47389F645440100FF83FFFFFFFF030002FFFFFFFFFF0F00FFFF6C00FFFFFAFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4A3E571A8AF991FEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF080E
>>
>> The mac is stored in the string as 1A00E47389F6.
>>
>>
>> Mark
>>
>>
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Fri Aug 14 14:17:57 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 14:17:57 +0200
Subject: [PATCH v2] b43: Add LP-PHY firmware loading support
Message-ID: <4A8555F5.5090603@gmail.com>

Add support for loading LP-PHY firmware to b43_try_request_fw.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/main.c |   25 ++++++++++++++++++++++++-
 1 files changed, 24 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index fbcbe4f..51767fa 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -2062,8 +2062,12 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		filename = "ucode5";
 	else if ((rev >= 11) && (rev <= 12))
 		filename = "ucode11";
-	else if (rev >= 13)
+	else if (rev == 13)
 		filename = "ucode13";
+	else if (rev == 14)
+		filename = "ucode14";
+	else if (rev >= 15)
+		filename = "ucode15";
 	else
 		goto err_no_ucode;
 	err = b43_do_request_fw(ctx, filename, &fw->ucode);
@@ -2111,6 +2115,16 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		else
 			goto err_no_initvals;
 		break;
+	case B43_PHYTYPE_LP:
+		if (rev == 13)
+			filename = "lp0initvals13";
+		else if (rev == 14)
+			filename = "lp0initvals14";
+		else if (rev >= 15)
+			filename = "lp0initvals15";
+		else
+			goto err_no_initvals;
+		break;
 	default:
 		goto err_no_initvals;
 	}
@@ -2145,6 +2159,15 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		else
 			goto err_no_initvals;
 		break;
+	case B43_PHYTYPE_LP:
+		if (rev == 13)
+			filename = "lp0bsinitvals13";
+		else if (rev == 14)
+			filename = "lp0bsinitvals14";
+		else if (rev >= 15)
+			filename = "lp0bsinitvals15";
+		else
+			goto err_no_initvals;
 	default:
 		goto err_no_initvals;
 	}
-- 
1.6.2.4





From mark.sf.net at huijgen.tk  Fri Aug 14 14:20:00 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Fri, 14 Aug 2009 14:20:00 +0200
Subject: [PATCH v2] b43: Add LP-PHY firmware loading support
In-Reply-To: <4A8555F5.5090603@gmail.com>
References: <4A8555F5.5090603@gmail.com>
Message-ID: <4A855670.1090902@huijgen.tk>

Still missing a break in the bandswitch initvals.

Mark

G?bor Stefanik wrote:
> Add support for loading LP-PHY firmware to b43_try_request_fw.
>
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> drivers/net/wireless/b43/main.c |   25 ++++++++++++++++++++++++-
> 1 files changed, 24 insertions(+), 1 deletions(-)
>
> diff --git a/drivers/net/wireless/b43/main.c
> b/drivers/net/wireless/b43/main.c
> index fbcbe4f..51767fa 100644
> --- a/drivers/net/wireless/b43/main.c
> +++ b/drivers/net/wireless/b43/main.c
> @@ -2062,8 +2062,12 @@ static int b43_try_request_fw(struct
> b43_request_fw_context *ctx)
>         filename = "ucode5";
>     else if ((rev >= 11) && (rev <= 12))
>         filename = "ucode11";
> -    else if (rev >= 13)
> +    else if (rev == 13)
>         filename = "ucode13";
> +    else if (rev == 14)
> +        filename = "ucode14";
> +    else if (rev >= 15)
> +        filename = "ucode15";
>     else
>         goto err_no_ucode;
>     err = b43_do_request_fw(ctx, filename, &fw->ucode);
> @@ -2111,6 +2115,16 @@ static int b43_try_request_fw(struct
> b43_request_fw_context *ctx)
>         else
>             goto err_no_initvals;
>         break;
> +    case B43_PHYTYPE_LP:
> +        if (rev == 13)
> +            filename = "lp0initvals13";
> +        else if (rev == 14)
> +            filename = "lp0initvals14";
> +        else if (rev >= 15)
> +            filename = "lp0initvals15";
> +        else
> +            goto err_no_initvals;
> +        break;
>     default:
>         goto err_no_initvals;
>     }
> @@ -2145,6 +2159,15 @@ static int b43_try_request_fw(struct
> b43_request_fw_context *ctx)
>         else
>             goto err_no_initvals;
>         break;
> +    case B43_PHYTYPE_LP:
> +        if (rev == 13)
> +            filename = "lp0bsinitvals13";
> +        else if (rev == 14)
> +            filename = "lp0bsinitvals14";
> +        else if (rev >= 15)
> +            filename = "lp0bsinitvals15";
> +        else
> +            goto err_no_initvals;
>     default:
>         goto err_no_initvals;
>     }



From netrolller.3d at gmail.com  Fri Aug 14 14:23:54 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 14:23:54 +0200
Subject: [PATCH v3] b43: Add LP-PHY firmware loading support
Message-ID: <4A85575A.2050303@gmail.com>

Add support for loading LP-PHY firmware to b43_try_request_fw.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
V3: Add yet another missing "break".
V2: Add a missing "break".

 drivers/net/wireless/b43/main.c |   25 ++++++++++++++++++++++++-
 1 files changed, 24 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index fbcbe4f..51767fa 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -2062,8 +2062,12 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		filename = "ucode5";
 	else if ((rev >= 11) && (rev <= 12))
 		filename = "ucode11";
-	else if (rev >= 13)
+	else if (rev == 13)
 		filename = "ucode13";
+	else if (rev == 14)
+		filename = "ucode14";
+	else if (rev >= 15)
+		filename = "ucode15";
 	else
 		goto err_no_ucode;
 	err = b43_do_request_fw(ctx, filename, &fw->ucode);
@@ -2111,6 +2115,16 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		else
 			goto err_no_initvals;
 		break;
+	case B43_PHYTYPE_LP:
+		if (rev == 13)
+			filename = "lp0initvals13";
+		else if (rev == 14)
+			filename = "lp0initvals14";
+		else if (rev >= 15)
+			filename = "lp0initvals15";
+		else
+			goto err_no_initvals;
+		break;
 	default:
 		goto err_no_initvals;
 	}
@@ -2145,6 +2159,15 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		else
 			goto err_no_initvals;
 		break;
+	case B43_PHYTYPE_LP:
+		if (rev == 13)
+			filename = "lp0bsinitvals13";
+		else if (rev == 14)
+			filename = "lp0bsinitvals14";
+		else if (rev >= 15)
+			filename = "lp0bsinitvals15";
+		else
+			goto err_no_initvals;
 	default:
 		goto err_no_initvals;
 	}
-- 
1.6.2.4





From mark.sf.net at huijgen.tk  Fri Aug 14 14:25:56 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Fri, 14 Aug 2009 14:25:56 +0200
Subject: Initial testing of LPPHY code
Message-ID: <4A8557D4.2050807@huijgen.tk>

After some minor snags with the mac address and firmware loading, the interface comes up. Well, sort of.

# ifconfig wlan0 up
# dmesg
[ 2744.696108] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor 0x4243)                                              
[ 2744.696120] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F, vendor 0x4243)                                             
[ 2744.696130] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)                                                  
[ 2744.696140] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)                                                   
[ 2744.716051] ssb: Found rev 1 PMU (capabilities 0x02A62F01)                                                                 
[ 2744.724785] ssb: SPROM revision 8 detected.                                                                                
[ 2744.724790] ssb: MAC 00:1a:73:e4:f6:89                                                                                     
[ 2744.746474] ssb: Sonics Silicon Backplane found on PCI device 0000:10:00.0                                                 
[ 2744.751576] b43-phy5: Broadcom 4312 WLAN found (core revision 15)                                                          
[ 2744.792046] b43-phy5 debug: Found PHY: Analog 6, Type 5, Revision 1                                                        
[ 2744.792059] b43-phy5 debug: Found Radio: Manuf 0x17F, Version 0x2062, Revision 2                                           
[ 2744.816245] phy5: Selected rate control algorithm 'minstrel'                                                               
[ 2744.816394] Broadcom 43xx driver loaded [ Features: PL, Firmware-ID: FW13 ]                                                                                                                             
[ 2751.196057] b43 ssb0:0: firmware: requesting b43/ucode15.fw                                                                
[ 2751.200562] b43 ssb0:0: firmware: requesting b43/lp0initvals15.fw                                                          
[ 2751.207095] b43 ssb0:0: firmware: requesting b43/lp0bsinitvals15.fw                                                        
[ 2751.348058] b43-phy5: Loading firmware version 410.2160 (2007-05-26 15:32:10)                                              
[ 2751.360071] ------------[ cut here ]------------                                                                           
[ 2751.360088] WARNING: at drivers/net/wireless/b43/phy_lp.c:983 lpphy_set_tx_power_control+0x85/0x100 [b43]()                
[ 2751.360091] Hardware name: HP 530 Notebook PC(KQ630AA#ABH)                                                                 
[ 2751.360094] Modules linked in: b43 ssb snd_pcm_oss snd_mixer_oss snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device snd_hda_codec_conexant snd_hda_intel snd_hda_codec snd_pcm snd_timer snd snd_page_alloc [last unloaded: ssb]                                                                                    
[ 2751.360112] Pid: 17050, comm: ifconfig Not tainted 2.6.31-rc5-wl-simPC-30271-gb2004c4-dirty #1                                                            
[ 2751.360115] Call Trace:                                                                                                                                   
[ 2751.360129]  [<f93200d5>] ? lpphy_set_tx_power_control+0x85/0x100 [b43]                                                                                   
[ 2751.360136]  [<c102d83c>] warn_slowpath_common+0x7c/0xa0                                                                                                  
[ 2751.360148]  [<f93200d5>] ? lpphy_set_tx_power_control+0x85/0x100 [b43]                                                                                   
[ 2751.360152]  [<c102d875>] warn_slowpath_null+0x15/0x20                                                                                                    
[ 2751.360164]  [<f93200d5>] lpphy_set_tx_power_control+0x85/0x100 [b43]                                                                                     
[ 2751.360177]  [<f931829c>] ? b43_phy_read+0x2c/0x60 [b43]                                                                                                  
[ 2751.360189]  [<f9320c7b>] lpphy_calibrate_rc+0x30b/0xa30 [b43]                                                                                            
[ 2751.360202]  [<f9320553>] ? lpphy_radio_init+0x393/0x420 [b43]                                                                                            
[ 2751.360214]  [<f9318248>] ? b43_phy_write+0x38/0x60 [b43]                                                                                                 
[ 2751.360226]  [<f9321a11>] b43_lpphy_op_init+0x651/0x1130 [b43]                                                                                            
[ 2751.360231]  [<c102e64b>] ? printk+0x1b/0x20                                                                                                              
[ 2751.360243]  [<f931861d>] b43_phy_init+0x3d/0xb0 [b43]                                                                                                    
[ 2751.360254]  [<f9314ae7>] b43_chip_init+0x547/0x950 [b43]                                                                                                 
[ 2751.360266]  [<f9315077>] b43_wireless_core_init+0x187/0x760 [b43]                                                                                        
[ 2751.360272]  [<c130b52d>] ? nlmsg_notify+0x3d/0xa0                                                                                                        
[ 2751.360283]  [<f931287d>] ? b43dbg+0x4d/0x60 [b43]                                                                                                        
[ 2751.360294]  [<f93167dc>] b43_op_start+0x19c/0x1c0 [b43]                                                                                                  
[ 2751.360300]  [<c137bb37>] ieee80211_open+0x427/0x700                                                                                                      
[ 2751.360305]  [<c12fcfe2>] dev_open+0xb2/0xe0                                                                                                              
[ 2751.360310]  [<c13a6ef7>] ? _spin_unlock_bh+0x17/0x20                                                                                                     
[ 2751.360314]  [<c12f84ca>] ? dev_set_rx_mode+0x2a/0x40                                                                                                     
[ 2751.360317]  [<c12fab07>] dev_change_flags+0x77/0x190                                                                                                     
[ 2751.360323]  [<c1344ee6>] devinet_ioctl+0x506/0x630                                                                                                       
[ 2751.360328]  [<c1145f75>] ? copy_to_user+0x35/0x50                                                                                                        
[ 2751.360333]  [<c1345b61>] inet_ioctl+0x61/0x80                                                                                                            
[ 2751.360336]  [<c12ed4e1>] sock_ioctl+0xd1/0x240                                                                                                           
[ 2751.360341]  [<c106bc68>] ? __do_fault+0x2e8/0x410                                                                                                        
[ 2751.360345]  [<c12ed410>] ? sock_ioctl+0x0/0x240                                                                                                          
[ 2751.360349]  [<c108ba08>] vfs_ioctl+0x28/0x80                                                                                                             
[ 2751.360353]  [<c108bbca>] do_vfs_ioctl+0x9a/0x570                                                                                                         
[ 2751.360357]  [<c106d46e>] ? handle_mm_fault+0xfe/0x5b0                                                                                                    
[ 2751.360362]  [<c107e701>] ? sys_faccessat+0x141/0x170                                                                                                     
[ 2751.360366]  [<c108c0d9>] sys_ioctl+0x39/0x60                                                                                                             
[ 2751.360370]  [<c1002d84>] sysenter_do_call+0x12/0x26                                                                                                      
[ 2751.360373] ---[ end trace 8d37a8f891044e50 ]---                                                                                                          
[ 2751.364468] ------------[ cut here ]------------                                                                                                          
[ 2751.364482] WARNING: at drivers/net/wireless/b43/phy_lp.c:983 lpphy_set_tx_power_control+0x85/0x100 [b43]()                                               
[ 2751.364485] Hardware name: HP 530 Notebook PC(KQ630AA#ABH)                                                                                                
[ 2751.364487] Modules linked in: b43 ssb snd_pcm_oss snd_mixer_oss snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device snd_hda_codec_conexant snd_hda_intel snd_hda_codec snd_pcm snd_timer snd snd_page_alloc [last unloaded: ssb]                                                                                    
[ 2751.364502] Pid: 17050, comm: ifconfig Tainted: G        W  2.6.31-rc5-wl-simPC-30271-gb2004c4-dirty #1                                                   
[ 2751.364505] Call Trace:                                                                                                                                   
[ 2751.364517]  [<f93200d5>] ? lpphy_set_tx_power_control+0x85/0x100 [b43]                                                                                   
[ 2751.364521]  [<c102d83c>] warn_slowpath_common+0x7c/0xa0                                                                                                  
[ 2751.364533]  [<f93200d5>] ? lpphy_set_tx_power_control+0x85/0x100 [b43]                                                                                   
[ 2751.364538]  [<c102d875>] warn_slowpath_null+0x15/0x20                                                                                                    
[ 2751.364549]  [<f93200d5>] lpphy_set_tx_power_control+0x85/0x100 [b43]                                                                                     
[ 2751.364562]  [<f932270a>] ? b43_lptab_write+0x8a/0x100 [b43]                                                                                              
[ 2751.364574]  [<f932115c>] lpphy_calibrate_rc+0x7ec/0xa30 [b43]                                                                                            
[ 2751.364587]  [<f9320553>] ? lpphy_radio_init+0x393/0x420 [b43]                                                                                            
[ 2751.364599]  [<f9321a11>] b43_lpphy_op_init+0x651/0x1130 [b43]                                                                                            
[ 2751.364603]  [<c102e64b>] ? printk+0x1b/0x20                                                                                                              
[ 2751.364615]  [<f931861d>] b43_phy_init+0x3d/0xb0 [b43]                                                                                                    
[ 2751.364626]  [<f9314ae7>] b43_chip_init+0x547/0x950 [b43]                                                                                                 
[ 2751.364638]  [<f9315077>] b43_wireless_core_init+0x187/0x760 [b43]                                                                                        
[ 2751.364642]  [<c130b52d>] ? nlmsg_notify+0x3d/0xa0                                                                                                        
[ 2751.364653]  [<f931287d>] ? b43dbg+0x4d/0x60 [b43]                                                                                                        
[ 2751.364664]  [<f93167dc>] b43_op_start+0x19c/0x1c0 [b43]                                                                                                  
[ 2751.364669]  [<c137bb37>] ieee80211_open+0x427/0x700                                                                                                      
[ 2751.364674]  [<c12fcfe2>] dev_open+0xb2/0xe0                                                                                                              
[ 2751.364678]  [<c13a6ef7>] ? _spin_unlock_bh+0x17/0x20                                                                                                     
[ 2751.364682]  [<c12f84ca>] ? dev_set_rx_mode+0x2a/0x40                                                                                                     
[ 2751.364685]  [<c12fab07>] dev_change_flags+0x77/0x190                                                                                                     
[ 2751.364690]  [<c1344ee6>] devinet_ioctl+0x506/0x630                                                                                                       
[ 2751.364693]  [<c1145f75>] ? copy_to_user+0x35/0x50                                                                                                        
[ 2751.364698]  [<c1345b61>] inet_ioctl+0x61/0x80                                                                                                            
[ 2751.364702]  [<c12ed4e1>] sock_ioctl+0xd1/0x240                                                                                                           
[ 2751.364706]  [<c106bc68>] ? __do_fault+0x2e8/0x410
[ 2751.364709]  [<c12ed410>] ? sock_ioctl+0x0/0x240
[ 2751.364713]  [<c108ba08>] vfs_ioctl+0x28/0x80
[ 2751.364717]  [<c108bbca>] do_vfs_ioctl+0x9a/0x570
[ 2751.364721]  [<c106d46e>] ? handle_mm_fault+0xfe/0x5b0
[ 2751.364725]  [<c107e701>] ? sys_faccessat+0x141/0x170
[ 2751.364729]  [<c108c0d9>] sys_ioctl+0x39/0x60
[ 2751.364733]  [<c1002d84>] sysenter_do_call+0x12/0x26
[ 2751.364736] ---[ end trace 8d37a8f891044e51 ]---
[ 2751.376061] b43-phy5 debug: Chip initialized
[ 2751.376077] ------------[ cut here ]------------
[ 2751.376089] WARNING: at drivers/net/wireless/b43/main.c:2603 b43_wireless_core_init+0x5a9/0x760 [b43]()
[ 2751.376092] Hardware name: HP 530 Notebook PC(KQ630AA#ABH)
[ 2751.376094] Modules linked in: b43 ssb snd_pcm_oss snd_mixer_oss snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device snd_hda_codec_conexant snd_hda_intel snd_hda_codec snd_pcm snd_timer snd snd_page_alloc [last unloaded: ssb]
[ 2751.376109] Pid: 17050, comm: ifconfig Tainted: G        W  2.6.31-rc5-wl-simPC-30271-gb2004c4-dirty #1
[ 2751.376112] Call Trace:
[ 2751.376123]  [<f9315499>] ? b43_wireless_core_init+0x5a9/0x760 [b43]
[ 2751.376127]  [<c102d83c>] warn_slowpath_common+0x7c/0xa0
[ 2751.376138]  [<f9315499>] ? b43_wireless_core_init+0x5a9/0x760 [b43]
[ 2751.376142]  [<c102d875>] warn_slowpath_null+0x15/0x20
[ 2751.376153]  [<f9315499>] b43_wireless_core_init+0x5a9/0x760 [b43]
[ 2751.376158]  [<c130b52d>] ? nlmsg_notify+0x3d/0xa0
[ 2751.376168]  [<f931287d>] ? b43dbg+0x4d/0x60 [b43]
[ 2751.376179]  [<f93167dc>] b43_op_start+0x19c/0x1c0 [b43]
[ 2751.376184]  [<c137bb37>] ieee80211_open+0x427/0x700
[ 2751.376189]  [<c12fcfe2>] dev_open+0xb2/0xe0
[ 2751.376193]  [<c13a6ef7>] ? _spin_unlock_bh+0x17/0x20
[ 2751.376196]  [<c12f84ca>] ? dev_set_rx_mode+0x2a/0x40
[ 2751.376200]  [<c12fab07>] dev_change_flags+0x77/0x190
[ 2751.376205]  [<c1344ee6>] devinet_ioctl+0x506/0x630
[ 2751.376208]  [<c1145f75>] ? copy_to_user+0x35/0x50
[ 2751.376213]  [<c1345b61>] inet_ioctl+0x61/0x80
[ 2751.376217]  [<c12ed4e1>] sock_ioctl+0xd1/0x240
[ 2751.376221]  [<c106bc68>] ? __do_fault+0x2e8/0x410
[ 2751.376224]  [<c12ed410>] ? sock_ioctl+0x0/0x240
[ 2751.376228]  [<c108ba08>] vfs_ioctl+0x28/0x80
[ 2751.376232]  [<c108bbca>] do_vfs_ioctl+0x9a/0x570
[ 2751.376236]  [<c106d46e>] ? handle_mm_fault+0xfe/0x5b0
[ 2751.376240]  [<c107e701>] ? sys_faccessat+0x141/0x170
[ 2751.376244]  [<c108c0d9>] sys_ioctl+0x39/0x60
[ 2751.376248]  [<c1002d84>] sysenter_do_call+0x12/0x26
[ 2751.376251] ---[ end trace 8d37a8f891044e52 ]---
[ 2751.376402] b43-phy5 debug: 64-bit DMA initialized
[ 2751.397560] Registered led device: b43-phy5::tx
[ 2751.397583] Registered led device: b43-phy5::rx
[ 2751.397606] Registered led device: b43-phy5::radio
[ 2751.397673] b43-phy5 debug: Wireless interface started
[ 2751.397693] b43-phy5 debug: Adding Interface type 2




From netrolller.3d at gmail.com  Fri Aug 14 14:39:53 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 14:39:53 +0200
Subject: [PATCH v3 this time really] b43: Add LP-PHY firmware loading support
Message-ID: <4A855B19.5080900@gmail.com>

Add support for loading LP-PHY firmware to b43_try_request_fw.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
I use Kate, and I added the break, then switched to Kate's
terminal, committed, format-patched - but forgot to click the Save
button before committing. :-)

V3 for real: Add yet another missing "break", this time really.
V3: Accidentally the same as V2.
V2: Add a missing "break".

 drivers/net/wireless/b43/main.c |   26 +++++++++++++++++++++++++-
 1 files changed, 25 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index fbcbe4f..3ca3e93 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -2062,8 +2062,12 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		filename = "ucode5";
 	else if ((rev >= 11) && (rev <= 12))
 		filename = "ucode11";
-	else if (rev >= 13)
+	else if (rev == 13)
 		filename = "ucode13";
+	else if (rev == 14)
+		filename = "ucode14";
+	else if (rev >= 15)
+		filename = "ucode15";
 	else
 		goto err_no_ucode;
 	err = b43_do_request_fw(ctx, filename, &fw->ucode);
@@ -2111,6 +2115,16 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		else
 			goto err_no_initvals;
 		break;
+	case B43_PHYTYPE_LP:
+		if (rev == 13)
+			filename = "lp0initvals13";
+		else if (rev == 14)
+			filename = "lp0initvals14";
+		else if (rev >= 15)
+			filename = "lp0initvals15";
+		else
+			goto err_no_initvals;
+		break;
 	default:
 		goto err_no_initvals;
 	}
@@ -2145,6 +2159,16 @@ static int b43_try_request_fw(struct b43_request_fw_context *ctx)
 		else
 			goto err_no_initvals;
 		break;
+	case B43_PHYTYPE_LP:
+		if (rev == 13)
+			filename = "lp0bsinitvals13";
+		else if (rev == 14)
+			filename = "lp0bsinitvals14";
+		else if (rev >= 15)
+			filename = "lp0bsinitvals15";
+		else
+			goto err_no_initvals;
+		break;
 	default:
 		goto err_no_initvals;
 	}
-- 
1.6.2.4





From netrolller.3d at gmail.com  Fri Aug 14 14:40:58 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Fri, 14 Aug 2009 14:40:58 +0200
Subject: [PATCH] ssb: Fix e typo in the rev8 SPROM extraction routine
In-Reply-To: <4A855489.6010102@gmail.com>
References: <4A855489.6010102@gmail.com>
Message-ID: <69e28c910908140540p55904f27m1d3b609c7b317e12@mail.gmail.com>

John, please fix the typo in the commit name... how ironic this is a
typo fix patch. :-)

2009/8/14 G?bor Stefanik <netrolller.3d at gmail.com>:
> No comment. :-)
>
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> Mark, this should fix your MAC address bug.
> Anyone else testing LP-PHY should also apply this.
>
> drivers/ssb/pci.c | ? ?2 +-
> 1 files changed, 1 insertions(+), 1 deletions(-)
>
> diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
> index 50811e4..335a43f 100644
> --- a/drivers/ssb/pci.c
> +++ b/drivers/ssb/pci.c
> @@ -480,7 +480,7 @@ static void sprom_extract_r8(struct ssb_sprom *out,
> const u16 *in)
>
> ? ? ? ?/* extract the MAC address */
> ? ? ? ?for (i = 0; i < 3; i++) {
> - ? ? ? ? ? ? ? v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
> + ? ? ? ? ? ? ? v = in[SPOFF(SSB_SPROM8_IL0MAC) + i];
> ? ? ? ? ? ? ? ?*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
> ? ? ? ?}
> ? ? ? ?SPEX(country_code, SSB_SPROM8_CCODE, 0xFFFF, 0);
> --
> 1.6.2.4
>
>
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Fri Aug 14 14:54:46 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 14:54:46 +0200
Subject: [PATCH] b43: Make LP-PHY testable
Message-ID: <4A855E96.3090202@gmail.com>

-Enable rate memory init for LP-PHY (same as G and N-PHY).
-Mark rev.2 LP-PHYs with the B2063 radio as supported.
-Allow using the 5GHz band on LP-PHYs.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/main.c |   11 +++++++----
 1 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index 3ca3e93..5559b22 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -2674,6 +2674,7 @@ static void b43_rate_memory_init(struct b43_wldev *dev)
 	case B43_PHYTYPE_A:
 	case B43_PHYTYPE_G:
 	case B43_PHYTYPE_N:
+	case B43_PHYTYPE_LP:
 		b43_rate_memory_write(dev, B43_OFDM_RATE_6MB, 1);
 		b43_rate_memory_write(dev, B43_OFDM_RATE_12MB, 1);
 		b43_rate_memory_write(dev, B43_OFDM_RATE_18MB, 1);
@@ -3888,7 +3889,7 @@ static int b43_phy_versioning(struct b43_wldev *dev)
 #endif
 #ifdef CONFIG_B43_PHY_LP
 	case B43_PHYTYPE_LP:
-		if (phy_rev > 1)
+		if (phy_rev > 2)
 			unsupported = 1;
 		break;
 #endif
@@ -3945,7 +3946,7 @@ static int b43_phy_versioning(struct b43_wldev *dev)
 			unsupported = 1;
 		break;
 	case B43_PHYTYPE_LP:
-		if (radio_ver != 0x2062)
+		if (radio_ver != 0x2062 && radio_ver != 0x2063)
 			unsupported = 1;
 		break;
 	default:
@@ -4588,9 +4589,10 @@ static int b43_wireless_core_attach(struct b43_wldev *dev)
 		case B43_PHYTYPE_A:
 			have_5ghz_phy = 1;
 			break;
+		case B43_PHYTYPE_LP: //FIXME not always!
+			have_5ghz_phy = 1;
 		case B43_PHYTYPE_G:
 		case B43_PHYTYPE_N:
-		case B43_PHYTYPE_LP:
 			have_2ghz_phy = 1;
 			break;
 		default:
@@ -4605,7 +4607,8 @@ static int b43_wireless_core_attach(struct b43_wldev *dev)
 	}
 	if (1 /* disable A-PHY */) {
 		/* FIXME: For now we disable the A-PHY on multi-PHY devices. */
-		if (dev->phy.type != B43_PHYTYPE_N) {
+		if (dev->phy.type != B43_PHYTYPE_N &&
+		    dev->phy.type != B43_PHYTYPE_LP) {
 			have_2ghz_phy = 1;
 			have_5ghz_phy = 0;
 		}
-- 
1.6.2.4





From Larry.Finger at lwfinger.net  Fri Aug 14 15:00:26 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Aug 2009 08:00:26 -0500
Subject: [PATCH] b43: Add LP-PHY firmware loading support
In-Reply-To: <4A854FDF.5020208@gmail.com>
References: <4A854FDF.5020208@gmail.com>
Message-ID: <4A855FEA.7030907@lwfinger.net>

G?bor Stefanik wrote:
> Add support for loading LP-PHY firmware to b43_try_request_fw.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> For anyone hoping that the channel switch patches will make their LP
> card work - this is also definitely required.
> 
> Mark, this doesn't fix your problem specifically, but it will be needed
> after your problem is fixed.
> 
> drivers/net/wireless/b43/main.c |   24 +++++++++++++++++++++++-
> 1 files changed, 23 insertions(+), 1 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/main.c
> b/drivers/net/wireless/b43/main.c
> index fbcbe4f..1e657fe 100644
> --- a/drivers/net/wireless/b43/main.c
> +++ b/drivers/net/wireless/b43/main.c
> @@ -2062,8 +2062,12 @@ static int b43_try_request_fw(struct
> b43_request_fw_context *ctx)
>         filename = "ucode5";
>     else if ((rev >= 11) && (rev <= 12))
>         filename = "ucode11";
> -    else if (rev >= 13)
> +    else if (rev == 13)
>         filename = "ucode13";
> +    else if (rev == 14)
> +        filename = "ucode14";
> +    else if (rev >= 15)
> +        filename = "ucode15";

As shown by http://bcm-v4.sipsolutions.net/802.11/Init/Firmware, one
should also have "ucode16".

>     else
>         goto err_no_ucode;
>     err = b43_do_request_fw(ctx, filename, &fw->ucode);
> @@ -2111,6 +2115,15 @@ static int b43_try_request_fw(struct
> b43_request_fw_context *ctx)
>         else
>             goto err_no_initvals;
>         break;
> +    case B43_PHYTYPE_LP:
> +        if (rev == 13)
> +            filename = "lp0initvals13";
> +        else if (rev == 14)
> +            filename = "lp0initvals14";
> +        else if (rev >= 15)
> +            filename = "lp0initvals15";
> +        else

Same for lp0initvals16.

> +            goto err_no_initvals;
>     default:
>         goto err_no_initvals;
>     }
> @@ -2145,6 +2158,15 @@ static int b43_try_request_fw(struct
> b43_request_fw_context *ctx)
>         else
>             goto err_no_initvals;
>         break;
> +    case B43_PHYTYPE_LP:
> +        if (rev == 13)
> +            filename = "lp0bsinitvals13";
> +        else if (rev == 14)
> +            filename = "lp0bsinitvals14";
> +        else if (rev >= 15)
> +            filename = "lp0bsinitvals15";

and lp0bsinitvals16.

> +        else
> +            goto err_no_initvals;
>     default:
>         goto err_no_initvals;
>     }

Larry


From netrolller.3d at gmail.com  Fri Aug 14 15:02:35 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Fri, 14 Aug 2009 15:02:35 +0200
Subject: [PATCH] b43: Add LP-PHY firmware loading support
In-Reply-To: <4A855FEA.7030907@lwfinger.net>
References: <4A854FDF.5020208@gmail.com> <4A855FEA.7030907@lwfinger.net>
Message-ID: <69e28c910908140602x3873f30bt95b5c148305a5e1e@mail.gmail.com>

2009/8/14 Larry Finger <Larry.Finger at lwfinger.net>:
> G?bor Stefanik wrote:
>> Add support for loading LP-PHY firmware to b43_try_request_fw.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> For anyone hoping that the channel switch patches will make their LP
>> card work - this is also definitely required.
>>
>> Mark, this doesn't fix your problem specifically, but it will be needed
>> after your problem is fixed.
>>
>> drivers/net/wireless/b43/main.c | ? 24 +++++++++++++++++++++++-
>> 1 files changed, 23 insertions(+), 1 deletions(-)
>>
>> diff --git a/drivers/net/wireless/b43/main.c
>> b/drivers/net/wireless/b43/main.c
>> index fbcbe4f..1e657fe 100644
>> --- a/drivers/net/wireless/b43/main.c
>> +++ b/drivers/net/wireless/b43/main.c
>> @@ -2062,8 +2062,12 @@ static int b43_try_request_fw(struct
>> b43_request_fw_context *ctx)
>> ? ? ? ? filename = "ucode5";
>> ? ? else if ((rev >= 11) && (rev <= 12))
>> ? ? ? ? filename = "ucode11";
>> - ? ?else if (rev >= 13)
>> + ? ?else if (rev == 13)
>> ? ? ? ? filename = "ucode13";
>> + ? ?else if (rev == 14)
>> + ? ? ? ?filename = "ucode14";
>> + ? ?else if (rev >= 15)
>> + ? ? ? ?filename = "ucode15";
>
> As shown by http://bcm-v4.sipsolutions.net/802.11/Init/Firmware, one
> should also have "ucode16".
>
>> ? ? else
>> ? ? ? ? goto err_no_ucode;
>> ? ? err = b43_do_request_fw(ctx, filename, &fw->ucode);
>> @@ -2111,6 +2115,15 @@ static int b43_try_request_fw(struct
>> b43_request_fw_context *ctx)
>> ? ? ? ? else
>> ? ? ? ? ? ? goto err_no_initvals;
>> ? ? ? ? break;
>> + ? ?case B43_PHYTYPE_LP:
>> + ? ? ? ?if (rev == 13)
>> + ? ? ? ? ? ?filename = "lp0initvals13";
>> + ? ? ? ?else if (rev == 14)
>> + ? ? ? ? ? ?filename = "lp0initvals14";
>> + ? ? ? ?else if (rev >= 15)
>> + ? ? ? ? ? ?filename = "lp0initvals15";
>> + ? ? ? ?else
>
> Same for lp0initvals16.
>
>> + ? ? ? ? ? ?goto err_no_initvals;
>> ? ? default:
>> ? ? ? ? goto err_no_initvals;
>> ? ? }
>> @@ -2145,6 +2158,15 @@ static int b43_try_request_fw(struct
>> b43_request_fw_context *ctx)
>> ? ? ? ? else
>> ? ? ? ? ? ? goto err_no_initvals;
>> ? ? ? ? break;
>> + ? ?case B43_PHYTYPE_LP:
>> + ? ? ? ?if (rev == 13)
>> + ? ? ? ? ? ?filename = "lp0bsinitvals13";
>> + ? ? ? ?else if (rev == 14)
>> + ? ? ? ? ? ?filename = "lp0bsinitvals14";
>> + ? ? ? ?else if (rev >= 15)
>> + ? ? ? ? ? ?filename = "lp0bsinitvals15";
>
> and lp0bsinitvals16.
>
>> + ? ? ? ?else
>> + ? ? ? ? ? ?goto err_no_initvals;
>> ? ? default:
>> ? ? ? ? goto err_no_initvals;
>> ? ? }
>
> Larry
>

Is rev.16 firmware available anywhere?

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From Larry.Finger at lwfinger.net  Fri Aug 14 15:10:48 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Aug 2009 08:10:48 -0500
Subject: [PATCH] b43: Add LP-PHY firmware loading support
In-Reply-To: <69e28c910908140602x3873f30bt95b5c148305a5e1e@mail.gmail.com>
References: <4A854FDF.5020208@gmail.com> <4A855FEA.7030907@lwfinger.net>
	<69e28c910908140602x3873f30bt95b5c148305a5e1e@mail.gmail.com>
Message-ID: <4A856258.10500@lwfinger.net>

G?bor Stefanik wrote:
> 
> Is rev.16 firmware available anywhere?
> 

finger at larrylap:~/wireless-testing> ls /lib/firmware/b43
a0b0bsinitvals4.fw   a0g1bsinitvals5.fw   b0g0initvals13.fw
lp0initvals13.fw    n0initvals16.fw        ucode15.fw
a0b0gsinitvals5.fw   a0g1bsinitvals9.fw   b0g0initvals13.fw_save
lp0initvals14.fw    pcm4.fw                ucode16.fw
a0g0bsinitvals4.fw   a0g1initvals13.fw    b0g0initvals4.fw
lp0initvals15.fw    pcm5.fw                ucode4.fw
a0g0bsinitvals5.fw   a0g1initvals5.fw     b0g0initvals5.fw
lp0initvals16.fw    sslpn0bsinitvals16.fw  ucode5.fw
a0g0bsinitvals9.fw   a0g1initvals9.fw     b0g0initvals9.fw
n0absinitvals11.fw  sslpn0initvals16.fw    ucode9.fw
a0g0initvals4.fw     b0g0bsinitvals13.fw  lp0bsinitvals13.fw
n0absinitvals13.fw  ucode11.fw
a0g0initvals5.fw     b0g0bsinitvals4.fw   lp0bsinitvals14.fw
n0bsinitvals11.fw   ucode13.fw
a0g0initvals9.fw     b0g0bsinitvals5.fw   lp0bsinitvals15.fw
n0bsinitvals16.fw   ucode13.fw_save
a0g1bsinitvals13.fw  b0g0bsinitvals9.fw   lp0bsinitvals16.fw
n0initvals11.fw     ucode14.fw

I installed my firmware using openSUSE's script called
/usr/sbin/install_bcm43xx_firmware, which uses the driver file
broadcom-wl-4.150.10.5.tar.bz2, and rev 16 firmware is there.

Larry





From netrolller.3d at gmail.com  Fri Aug 14 17:26:48 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Fri, 14 Aug 2009 17:26:48 +0200
Subject: [PATCH] b43: Add LP-PHY firmware loading support
In-Reply-To: <4A85678E.6080205@lwfinger.net>
References: <4A854FDF.5020208@gmail.com> <4A855FEA.7030907@lwfinger.net> 
	<69e28c910908140602x3873f30bt95b5c148305a5e1e@mail.gmail.com> 
	<4A856258.10500@lwfinger.net>
	<69e28c910908140623r6f158a89pcf145bad7b244af8@mail.gmail.com> 
	<4A85678E.6080205@lwfinger.net>
Message-ID: <69e28c910908140826v6725a109u1d6e827869c4ffff@mail.gmail.com>

(Restored CCs.)

2009/8/14 Larry Finger <Larry.Finger at lwfinger.net>:
> G?bor Stefanik wrote:
>>
>> On http://bu3sch.de/gitweb?p=b43-tools.git;a=blob;f=fwcutter/fwcutter_list.h;hb=HEAD,
>> it doesn't look like v4.150.10.5 contains rev16 - there is one version
>> that does have it, but the link to that file is dead.
>
> The rev 16 firmware definitely is in driver 4.174.64.19, but not in
> 4.150.10.5. I'll have to figure out where I got it, and what
> modifications are needed in fwcutter to make it available.
>
> I suggest that you do the mods to the firmware loading. If Broadcom
> has it in their driver, there must be hardware that needs it.
>
> Larry

I would say that's a goal for later - the FIFO sizes are different, so
it would clearly need more work than just loading the firmware  to
support rev16 devices.

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From francesco.gringoli at ing.unibs.it  Fri Aug 14 19:06:23 2009
From: francesco.gringoli at ing.unibs.it (Francesco Gringoli)
Date: Fri, 14 Aug 2009 19:06:23 +0200
Subject: DMA queue overflow
In-Reply-To: <4A72260A.9080501@lwfinger.net>
References: <11878DAD-E42C-4455-8A6B-837BF2D187F2@ing.unibs.it>
	<4A71EE5E.4040407@lwfinger.net>
	<F83D6CFD-D5BF-4080-92E7-401281154EA1@ing.unibs.it>
	<200907302355.47945.mb@bu3sch.de>
	<CD4C5C2E-A808-4E59-9BBB-DDE033E6A95F@ing.unibs.it>
	<4A72260A.9080501@lwfinger.net>
Message-ID: <6F78B595-DC81-4D4C-BAAA-02DB77E43A62@ing.unibs.it>


On Jul 31, 2009, at 1:00 AM, Larry Finger wrote:

> Francesco Gringoli wrote:
>> On Jul 30, 2009, at 11:55 PM, Michael Buesch wrote:
>>
>>> On Thursday 30 July 2009 23:54:17 Francesco Gringoli wrote:
>>>> many thanks. I will surely look into that direction as soon as I  
>>>> get
>>>> the boards. By the way: I never worked with mini-pci-e and I don't
>>>> even have a desktop PC with that bus, so I plan to get some newer
>>>> desktop around in my department and use a pci-e to mini-pci-e  
>>>> adapter.
>>>> Do you know if such adapter can trigger some incompatibility with  
>>>> b43?
>>>> Or is it completely transparent?
>>>
>>> I think it's just a mechanical adapter.
>> Thanks, I will get one immediately.
>
> I saw one on a web site that only has 3 power-regulator chips. It
> couldn't possible do anything but just transfer the signals in a
> mechanical fashion.
>
> Larry
>
>
Hi Larry,

I did some testing with my old notebook and the PCCARD boards. The  
mini-pci-e boards from Hong Kong are still missing, I begin to suspect  
that I should buy others from some other vendor.

The two boards are the same, Belkin F5D7011: they are reported as  
being functional with b43. Unfortunately they have the same behavior,  
they crash the pc also with the proprietary firmware. Could this bug  
due to the Cardbus Controller? I'm using the kernel from wireless- 
testing, downloaded yesterday (2.6.31-rc5-wl).

This is the lspci output

00:00.0 Host bridge: Silicon Integrated Systems [SiS] 645xx (rev 03)
00:01.0 PCI bridge: Silicon Integrated Systems [SiS] Virtual PCI-to- 
PCI bridge (AGP)
00:02.0 ISA bridge: Silicon Integrated Systems [SiS] SiS963 [MuTIOL  
Media IO] (rev 14)
00:02.1 SMBus: Silicon Integrated Systems [SiS] SiS961/2 SMBus  
Controller
00:02.3 FireWire (IEEE 1394): Silicon Integrated Systems [SiS]  
FireWire Controller
00:02.5 IDE interface: Silicon Integrated Systems [SiS] 5513 [IDE]
00:02.6 Modem: Silicon Integrated Systems [SiS] AC'97 Modem Controller  
(rev a0)
00:02.7 Multimedia audio controller: Silicon Integrated Systems [SiS]  
AC'97 Sound Controller (rev a0)
00:03.0 USB Controller: Silicon Integrated Systems [SiS] USB 1.1  
Controller (rev 0f)
00:03.1 USB Controller: Silicon Integrated Systems [SiS] USB 1.1  
Controller (rev 0f)
00:03.2 USB Controller: Silicon Integrated Systems [SiS] USB 1.1  
Controller (rev 0f)
00:03.3 USB Controller: Silicon Integrated Systems [SiS] USB 2.0  
Controller
00:0a.0 CardBus bridge: ENE Technology Inc CB-720/2/4 Cardbus  
Controller (rev 01)
00:0a.1 CardBus bridge: ENE Technology Inc CB-720/2/4 Cardbus  
Controller (rev 01)
00:0a.2 FLASH memory: ENE Technology Inc CB710 Memory Card Reader  
Controller
00:0c.0 Network controller: Broadcom Corporation BCM4318 [AirForce One  
54g] 802.11g Wireless LAN Controller (rev 02)
00:0d.0 Ethernet controller: 3Com Corporation 3c940 10/100/1000Base-T  
[Marvell] (rev 12)
01:00.0 VGA compatible controller: ATI Technologies Inc Radeon RV250  
[Mobility FireGL 9000] (rev 01)
02:00.0 Network controller: Broadcom Corporation BCM4306 802.11b/g  
Wireless LAN Controller (rev 03)

The PCCARD board is the last line, the other board from broadcom is an  
internal minipci.

This is the output of b43 in dmesg (cut)

[  179.987899] b43-phy1: Broadcom 4306 WLAN found (core revision 5)
[  180.025070] b43-phy1 debug: Found PHY: Analog 2, Type 2, Revision 2
[  180.025096] b43-phy1 debug: Found Radio: Manuf 0x17F, Version  
0x2050, Revision 2

I will try to access through the serial console to check if some  
message is reported before crash.

Cheers,
-Francesco




"INFORMATIVA SUL TRATTAMENTO DEI DATI PERSONALI"

I dati utilizzati per l'invio del presente messaggio sono trattati dall' Universita' degli
studi di Brescia esclusivamente per finalita' istituzionali. Informazioni piu' dettagliate
anche in ordine ai diritti dell'interessato sono riposte nell'informativa generale e nelle
notizie pubblicate sul sito web dell'Ateneo nella sezione "privacy".

Il contenuto di questo messaggio e' rivolto unicamente alle persone cui e' indirizzato e puo'
contenere informazioni la cui riservatezza e' tutelata legalmente. Ne sono vietati la
riproduzione, la diffusione e l'uso in mancanza di autorizzazione del destinatario.
Qualora il messaggio fosse pervenuto per errore, preghiamo di eliminarlo.




From Larry.Finger at lwfinger.net  Fri Aug 14 19:34:41 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Aug 2009 12:34:41 -0500
Subject: DMA queue overflow
In-Reply-To: <6F78B595-DC81-4D4C-BAAA-02DB77E43A62@ing.unibs.it>
References: <11878DAD-E42C-4455-8A6B-837BF2D187F2@ing.unibs.it>
	<4A71EE5E.4040407@lwfinger.net>
	<F83D6CFD-D5BF-4080-92E7-401281154EA1@ing.unibs.it>
	<200907302355.47945.mb@bu3sch.de>
	<CD4C5C2E-A808-4E59-9BBB-DDE033E6A95F@ing.unibs.it>
	<4A72260A.9080501@lwfinger.net>
	<6F78B595-DC81-4D4C-BAAA-02DB77E43A62@ing.unibs.it>
Message-ID: <4A85A031.8050909@lwfinger.net>

Francesco Gringoli wrote:
> I will try to access through the serial console to check if some message
> is reported before crash.

The kernel crash may come from b43_dma_handle_txstatus() in
drivers/net/wireless/b43/dma.c. I had to replace the
BUG_ON(!meta->skb) with a WARN_ON. That way the kernel stayed alive.

I did a lot more by checking for a freed skb. If you want my patch,
please let me know. I don't want to spam the list with it.

Larry


From netrolller.3d at gmail.com  Fri Aug 14 19:38:09 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Fri, 14 Aug 2009 19:38:09 +0200
Subject: Initial testing of LPPHY code
In-Reply-To: <4A8557D4.2050807@huijgen.tk>
References: <4A8557D4.2050807@huijgen.tk>
Message-ID: <69e28c910908141038n57d9aef4r435965205c4affb4@mail.gmail.com>

On Fri, Aug 14, 2009 at 2:25 PM, Mark Huijgen<mark.sf.net at huijgen.tk> wrote:
> After some minor snags with the mac address and firmware loading, the interface comes up. Well, sort of.
>
> # ifconfig wlan0 up
> # dmesg
> [ 2744.696108] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor 0x4243)
> [ 2744.696120] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F, vendor 0x4243)
> [ 2744.696130] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)
> [ 2744.696140] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)
> [ 2744.716051] ssb: Found rev 1 PMU (capabilities 0x02A62F01)
> [ 2744.724785] ssb: SPROM revision 8 detected.
> [ 2744.724790] ssb: MAC 00:1a:73:e4:f6:89
> [ 2744.746474] ssb: Sonics Silicon Backplane found on PCI device 0000:10:00.0
> [ 2744.751576] b43-phy5: Broadcom 4312 WLAN found (core revision 15)
> [ 2744.792046] b43-phy5 debug: Found PHY: Analog 6, Type 5, Revision 1
> [ 2744.792059] b43-phy5 debug: Found Radio: Manuf 0x17F, Version 0x2062, Revision 2
> [ 2744.816245] phy5: Selected rate control algorithm 'minstrel'
> [ 2744.816394] Broadcom 43xx driver loaded [ Features: PL, Firmware-ID: FW13 ]
> [ 2751.196057] b43 ssb0:0: firmware: requesting b43/ucode15.fw
> [ 2751.200562] b43 ssb0:0: firmware: requesting b43/lp0initvals15.fw
> [ 2751.207095] b43 ssb0:0: firmware: requesting b43/lp0bsinitvals15.fw
> [ 2751.348058] b43-phy5: Loading firmware version 410.2160 (2007-05-26 15:32:10)
> [ 2751.360071] ------------[ cut here ]------------
> [ 2751.360088] WARNING: at drivers/net/wireless/b43/phy_lp.c:983 lpphy_set_tx_power_control+0x85/0x100 [b43]()

Could you please printk out (ctl & B43_LPPHY_TX_PWR_CTL_CMD_MODE)?

> [ 2751.360091] Hardware name: HP 530 Notebook PC(KQ630AA#ABH)
> [ 2751.360094] Modules linked in: b43 ssb snd_pcm_oss snd_mixer_oss snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device snd_hda_codec_conexant snd_hda_intel snd_hda_codec snd_pcm snd_timer snd snd_page_alloc [last unloaded: ssb]
> [ 2751.360112] Pid: 17050, comm: ifconfig Not tainted 2.6.31-rc5-wl-simPC-30271-gb2004c4-dirty #1
> [ 2751.360115] Call Trace:
> [ 2751.360129] ?[<f93200d5>] ? lpphy_set_tx_power_control+0x85/0x100 [b43]
> [ 2751.360136] ?[<c102d83c>] warn_slowpath_common+0x7c/0xa0
> [ 2751.360148] ?[<f93200d5>] ? lpphy_set_tx_power_control+0x85/0x100 [b43]
> [ 2751.360152] ?[<c102d875>] warn_slowpath_null+0x15/0x20
> [ 2751.360164] ?[<f93200d5>] lpphy_set_tx_power_control+0x85/0x100 [b43]
> [ 2751.360177] ?[<f931829c>] ? b43_phy_read+0x2c/0x60 [b43]
> [ 2751.360189] ?[<f9320c7b>] lpphy_calibrate_rc+0x30b/0xa30 [b43]
> [ 2751.360202] ?[<f9320553>] ? lpphy_radio_init+0x393/0x420 [b43]
> [ 2751.360214] ?[<f9318248>] ? b43_phy_write+0x38/0x60 [b43]
> [ 2751.360226] ?[<f9321a11>] b43_lpphy_op_init+0x651/0x1130 [b43]
> [ 2751.360231] ?[<c102e64b>] ? printk+0x1b/0x20
> [ 2751.360243] ?[<f931861d>] b43_phy_init+0x3d/0xb0 [b43]
> [ 2751.360254] ?[<f9314ae7>] b43_chip_init+0x547/0x950 [b43]
> [ 2751.360266] ?[<f9315077>] b43_wireless_core_init+0x187/0x760 [b43]
> [ 2751.360272] ?[<c130b52d>] ? nlmsg_notify+0x3d/0xa0
> [ 2751.360283] ?[<f931287d>] ? b43dbg+0x4d/0x60 [b43]
> [ 2751.360294] ?[<f93167dc>] b43_op_start+0x19c/0x1c0 [b43]
> [ 2751.360300] ?[<c137bb37>] ieee80211_open+0x427/0x700
> [ 2751.360305] ?[<c12fcfe2>] dev_open+0xb2/0xe0
> [ 2751.360310] ?[<c13a6ef7>] ? _spin_unlock_bh+0x17/0x20
> [ 2751.360314] ?[<c12f84ca>] ? dev_set_rx_mode+0x2a/0x40
> [ 2751.360317] ?[<c12fab07>] dev_change_flags+0x77/0x190
> [ 2751.360323] ?[<c1344ee6>] devinet_ioctl+0x506/0x630
> [ 2751.360328] ?[<c1145f75>] ? copy_to_user+0x35/0x50
> [ 2751.360333] ?[<c1345b61>] inet_ioctl+0x61/0x80
> [ 2751.360336] ?[<c12ed4e1>] sock_ioctl+0xd1/0x240
> [ 2751.360341] ?[<c106bc68>] ? __do_fault+0x2e8/0x410
> [ 2751.360345] ?[<c12ed410>] ? sock_ioctl+0x0/0x240
> [ 2751.360349] ?[<c108ba08>] vfs_ioctl+0x28/0x80
> [ 2751.360353] ?[<c108bbca>] do_vfs_ioctl+0x9a/0x570
> [ 2751.360357] ?[<c106d46e>] ? handle_mm_fault+0xfe/0x5b0
> [ 2751.360362] ?[<c107e701>] ? sys_faccessat+0x141/0x170
> [ 2751.360366] ?[<c108c0d9>] sys_ioctl+0x39/0x60
> [ 2751.360370] ?[<c1002d84>] sysenter_do_call+0x12/0x26
> [ 2751.360373] ---[ end trace 8d37a8f891044e50 ]---
> [ 2751.364468] ------------[ cut here ]------------
> [ 2751.364482] WARNING: at drivers/net/wireless/b43/phy_lp.c:983 lpphy_set_tx_power_control+0x85/0x100 [b43]()
Same here.
> [ 2751.364485] Hardware name: HP 530 Notebook PC(KQ630AA#ABH)
> [ 2751.364487] Modules linked in: b43 ssb snd_pcm_oss snd_mixer_oss snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device snd_hda_codec_conexant snd_hda_intel snd_hda_codec snd_pcm snd_timer snd snd_page_alloc [last unloaded: ssb]
> [ 2751.364502] Pid: 17050, comm: ifconfig Tainted: G ? ? ? ?W ?2.6.31-rc5-wl-simPC-30271-gb2004c4-dirty #1
> [ 2751.364505] Call Trace:
> [ 2751.364517] ?[<f93200d5>] ? lpphy_set_tx_power_control+0x85/0x100 [b43]
> [ 2751.364521] ?[<c102d83c>] warn_slowpath_common+0x7c/0xa0
> [ 2751.364533] ?[<f93200d5>] ? lpphy_set_tx_power_control+0x85/0x100 [b43]
> [ 2751.364538] ?[<c102d875>] warn_slowpath_null+0x15/0x20
> [ 2751.364549] ?[<f93200d5>] lpphy_set_tx_power_control+0x85/0x100 [b43]
> [ 2751.364562] ?[<f932270a>] ? b43_lptab_write+0x8a/0x100 [b43]
> [ 2751.364574] ?[<f932115c>] lpphy_calibrate_rc+0x7ec/0xa30 [b43]
> [ 2751.364587] ?[<f9320553>] ? lpphy_radio_init+0x393/0x420 [b43]
> [ 2751.364599] ?[<f9321a11>] b43_lpphy_op_init+0x651/0x1130 [b43]
> [ 2751.364603] ?[<c102e64b>] ? printk+0x1b/0x20
> [ 2751.364615] ?[<f931861d>] b43_phy_init+0x3d/0xb0 [b43]
> [ 2751.364626] ?[<f9314ae7>] b43_chip_init+0x547/0x950 [b43]
> [ 2751.364638] ?[<f9315077>] b43_wireless_core_init+0x187/0x760 [b43]
> [ 2751.364642] ?[<c130b52d>] ? nlmsg_notify+0x3d/0xa0
> [ 2751.364653] ?[<f931287d>] ? b43dbg+0x4d/0x60 [b43]
> [ 2751.364664] ?[<f93167dc>] b43_op_start+0x19c/0x1c0 [b43]
> [ 2751.364669] ?[<c137bb37>] ieee80211_open+0x427/0x700
> [ 2751.364674] ?[<c12fcfe2>] dev_open+0xb2/0xe0
> [ 2751.364678] ?[<c13a6ef7>] ? _spin_unlock_bh+0x17/0x20
> [ 2751.364682] ?[<c12f84ca>] ? dev_set_rx_mode+0x2a/0x40
> [ 2751.364685] ?[<c12fab07>] dev_change_flags+0x77/0x190
> [ 2751.364690] ?[<c1344ee6>] devinet_ioctl+0x506/0x630
> [ 2751.364693] ?[<c1145f75>] ? copy_to_user+0x35/0x50
> [ 2751.364698] ?[<c1345b61>] inet_ioctl+0x61/0x80
> [ 2751.364702] ?[<c12ed4e1>] sock_ioctl+0xd1/0x240
> [ 2751.364706] ?[<c106bc68>] ? __do_fault+0x2e8/0x410
> [ 2751.364709] ?[<c12ed410>] ? sock_ioctl+0x0/0x240
> [ 2751.364713] ?[<c108ba08>] vfs_ioctl+0x28/0x80
> [ 2751.364717] ?[<c108bbca>] do_vfs_ioctl+0x9a/0x570
> [ 2751.364721] ?[<c106d46e>] ? handle_mm_fault+0xfe/0x5b0
> [ 2751.364725] ?[<c107e701>] ? sys_faccessat+0x141/0x170
> [ 2751.364729] ?[<c108c0d9>] sys_ioctl+0x39/0x60
> [ 2751.364733] ?[<c1002d84>] sysenter_do_call+0x12/0x26
> [ 2751.364736] ---[ end trace 8d37a8f891044e51 ]---
> [ 2751.376061] b43-phy5 debug: Chip initialized
> [ 2751.376077] ------------[ cut here ]------------
> [ 2751.376089] WARNING: at drivers/net/wireless/b43/main.c:2603 b43_wireless_core_init+0x5a9/0x760 [b43]()

This should be fixed by the "make testable" patch.

Also, please test if the device actually works despite the warnings.

> [ 2751.376092] Hardware name: HP 530 Notebook PC(KQ630AA#ABH)
> [ 2751.376094] Modules linked in: b43 ssb snd_pcm_oss snd_mixer_oss snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device snd_hda_codec_conexant snd_hda_intel snd_hda_codec snd_pcm snd_timer snd snd_page_alloc [last unloaded: ssb]
> [ 2751.376109] Pid: 17050, comm: ifconfig Tainted: G ? ? ? ?W ?2.6.31-rc5-wl-simPC-30271-gb2004c4-dirty #1
> [ 2751.376112] Call Trace:
> [ 2751.376123] ?[<f9315499>] ? b43_wireless_core_init+0x5a9/0x760 [b43]
> [ 2751.376127] ?[<c102d83c>] warn_slowpath_common+0x7c/0xa0
> [ 2751.376138] ?[<f9315499>] ? b43_wireless_core_init+0x5a9/0x760 [b43]
> [ 2751.376142] ?[<c102d875>] warn_slowpath_null+0x15/0x20
> [ 2751.376153] ?[<f9315499>] b43_wireless_core_init+0x5a9/0x760 [b43]
> [ 2751.376158] ?[<c130b52d>] ? nlmsg_notify+0x3d/0xa0
> [ 2751.376168] ?[<f931287d>] ? b43dbg+0x4d/0x60 [b43]
> [ 2751.376179] ?[<f93167dc>] b43_op_start+0x19c/0x1c0 [b43]
> [ 2751.376184] ?[<c137bb37>] ieee80211_open+0x427/0x700
> [ 2751.376189] ?[<c12fcfe2>] dev_open+0xb2/0xe0
> [ 2751.376193] ?[<c13a6ef7>] ? _spin_unlock_bh+0x17/0x20
> [ 2751.376196] ?[<c12f84ca>] ? dev_set_rx_mode+0x2a/0x40
> [ 2751.376200] ?[<c12fab07>] dev_change_flags+0x77/0x190
> [ 2751.376205] ?[<c1344ee6>] devinet_ioctl+0x506/0x630
> [ 2751.376208] ?[<c1145f75>] ? copy_to_user+0x35/0x50
> [ 2751.376213] ?[<c1345b61>] inet_ioctl+0x61/0x80
> [ 2751.376217] ?[<c12ed4e1>] sock_ioctl+0xd1/0x240
> [ 2751.376221] ?[<c106bc68>] ? __do_fault+0x2e8/0x410
> [ 2751.376224] ?[<c12ed410>] ? sock_ioctl+0x0/0x240
> [ 2751.376228] ?[<c108ba08>] vfs_ioctl+0x28/0x80
> [ 2751.376232] ?[<c108bbca>] do_vfs_ioctl+0x9a/0x570
> [ 2751.376236] ?[<c106d46e>] ? handle_mm_fault+0xfe/0x5b0
> [ 2751.376240] ?[<c107e701>] ? sys_faccessat+0x141/0x170
> [ 2751.376244] ?[<c108c0d9>] sys_ioctl+0x39/0x60
> [ 2751.376248] ?[<c1002d84>] sysenter_do_call+0x12/0x26
> [ 2751.376251] ---[ end trace 8d37a8f891044e52 ]---
> [ 2751.376402] b43-phy5 debug: 64-bit DMA initialized
> [ 2751.397560] Registered led device: b43-phy5::tx
> [ 2751.397583] Registered led device: b43-phy5::rx
> [ 2751.397606] Registered led device: b43-phy5::radio
> [ 2751.397673] b43-phy5 debug: Wireless interface started
> [ 2751.397693] b43-phy5 debug: Adding Interface type 2
>
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Fri Aug 14 20:29:47 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 20:29:47 +0200
Subject: [PATCH] b43: LP-PHY: Fix reading old mode in the set TX power control
	routine
Message-ID: <4A85AD1B.1060008@gmail.com>

Check the mode the hardware is in, not the mode we used the last time.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Mark, please test if this fixes the TX power control WARN_ON you were seeing.

 drivers/net/wireless/b43/phy_lp.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 292ee51..76457f7 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1015,9 +1015,9 @@ static void lpphy_set_tx_power_control(struct b43_wldev *dev,
 	struct b43_phy_lp *lpphy = dev->phy.lp;
 	enum b43_lpphy_txpctl_mode oldmode;
 
-	oldmode = lpphy->txpctl_mode;
 	lpphy_read_tx_pctl_mode_from_hardware(dev);
-	if (lpphy->txpctl_mode == mode)
+	oldmode = lpphy->txpctl_mode;
+	if (oldmode == mode)
 		return;
 	lpphy->txpctl_mode = mode;
 
-- 
1.6.2.4





From Larry.Finger at lwfinger.net  Fri Aug 14 20:44:36 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Aug 2009 13:44:36 -0500
Subject: [PATCH] b43: LP-PHY: Fix reading old mode in the set TX power
	control routine
In-Reply-To: <4A85AD1B.1060008@gmail.com>
References: <4A85AD1B.1060008@gmail.com>
Message-ID: <4A85B094.6010407@lwfinger.net>

G?bor Stefanik wrote:
> Check the mode the hardware is in, not the mode we used the last time.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> Mark, please test if this fixes the TX power control WARN_ON you were
> seeing.

It does not fix it here. I'll take a look at the specs.

Larry


From netrolller.3d at gmail.com  Fri Aug 14 21:11:59 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 21:11:59 +0200
Subject: [PATCH] b43: LP-PHY: Don't adjust gain table for rev2+ when setting
	channel
Message-ID: <4A85B6FF.8070304@gmail.com>

Rev2+ never needs to have gain tables adjusted according to the spec.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |    3 +--
 1 files changed, 1 insertions(+), 2 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 76457f7..adfa7bf 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -2059,10 +2059,9 @@ static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
 		if (err)
 			return err;
 		lpphy_japan_filter(dev, new_channel);
+		lpphy_adjust_gain_table(dev, channel2freq_lp(new_channel));
 	}
 
-	lpphy_adjust_gain_table(dev, channel2freq_lp(new_channel));
-
 	return 0;
 }
 
-- 
1.6.2.4





From netrolller.3d at gmail.com  Fri Aug 14 21:19:58 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 21:19:58 +0200
Subject: [PATCH] b43: LP-PHY: Fix setting TX power control mode during RC
	calibration
Message-ID: <4A85B8DE.3000704@gmail.com>

Call set_tx_power_control with a LPPHY_TXPCTL rather than an
LPPHY_TX_PWR_CTL_CMD_MODE.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
This should fix the WARN_ON testers were seeing during init.

 drivers/net/wireless/b43/phy_lp.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index adfa7bf..558224b 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1080,7 +1080,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 	old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
 					B43_LPPHY_TX_PWR_CTL_CMD_MODE;
 
-	lpphy_set_tx_power_control(dev, B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
+	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
 	lpphy_disable_crs(dev);
 	loopback = lpphy_loopback(dev);
 	if (loopback == -1)
-- 
1.6.2.4





From netrolller.3d at gmail.com  Fri Aug 14 22:10:34 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 22:10:34 +0200
Subject: [PATCH] b43: LP-PHY: Update TX gain override for a spec typo fix
Message-ID: <4A85C4BA.3070603@gmail.com>

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 558224b..bf89173 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -747,7 +747,7 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
 		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1 << 7);
 		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1 << 14);
 	}
-	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFBF, 1 << 4);
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFBF, 1 << 6);
 }
 
 static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
-- 
1.6.2.4





From mb at bu3sch.de  Fri Aug 14 22:15:37 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Aug 2009 22:15:37 +0200
Subject: [PATCH] b43: Fix sparse warnings
In-Reply-To: <4a84906b.+IYGhiNLKPSjrrR7%Larry.Finger@lwfinger.net>
References: <4a84906b.+IYGhiNLKPSjrrR7%Larry.Finger@lwfinger.net>
Message-ID: <200908142215.38112.mb@bu3sch.de>

On Friday 14 August 2009 00:15:07 Larry Finger wrote:
> The b43 driver generates the following sparse warnings:
> 
>   CHECK   drivers/net/wireless/b43/phy_g.c
> drivers/net/wireless/b43/phy_g.c:974:35: warning: cast truncates bits from constant value (ffff7fff becomes 7fff)
>   CHECK   drivers/net/wireless/b43/wa.c
> drivers/net/wireless/b43/wa.c:385:53: warning: cast truncates bits from constant value (ffff00ff becomes ff)
> drivers/net/wireless/b43/wa.c:403:48: warning: cast truncates bits from constant value (ffff00ff becomes ff)
> drivers/net/wireless/b43/wa.c:405:48: warning: cast truncates bits from constant value (ffff00ff becomes ff)
> drivers/net/wireless/b43/wa.c:415:50: warning: cast truncates bits from constant value (ffff0fff becomes fff)
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John,
> 
> There is no hurry for this material.
> 
> Larry
> ---
> 
> Index: wireless-testing/drivers/net/wireless/b43/phy_g.c
> ===================================================================
> --- wireless-testing.orig/drivers/net/wireless/b43/phy_g.c
> +++ wireless-testing/drivers/net/wireless/b43/phy_g.c
> @@ -971,7 +971,7 @@ b43_radio_interference_mitigation_enable
>  		b43_phy_maskset(dev, 0x04A2, 0xFFF0, 0x000B);
>  
>  		if (phy->rev >= 3) {
> -			b43_phy_mask(dev, 0x048A, (u16)~0x8000);
> +			b43_phy_mask(dev, 0x048A, (u16)(~0x8000 & 0xFFFF));

Uh come on...
The u16 cast already is stupid as hell, but this is becoming braindead.
The code is perfectly fine. Sparse should instead provide an option to disable
this fragile check.

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Aug 14 22:16:31 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Aug 2009 22:16:31 +0200
Subject: [PATCH] b43: LP-PHY: Implement channel switching for rev2+/B2063
	radio
In-Reply-To: <4A847BA6.30803@gmail.com>
References: <4A847BA6.30803@gmail.com>
Message-ID: <200908142216.32215.mb@bu3sch.de>

On Thursday 13 August 2009 22:46:30 G?bor Stefanik wrote:
> Rev.2+/B2063 will now hopefully show some signs of life, though
> it won't work at full performance, as calibration is still missing.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

ack
-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Aug 14 22:16:59 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Aug 2009 22:16:59 +0200
Subject: [PATCH] b43: LP-PHY: Implement channel switching for rev0/1/B2062
	radio
In-Reply-To: <4A849075.7000000@gmail.com>
References: <4A849075.7000000@gmail.com>
Message-ID: <200908142217.00061.mb@bu3sch.de>

On Friday 14 August 2009 00:15:17 G?bor Stefanik wrote:
> -Move pdiv from lpphy_2062_init to struct b43_phy_lp.
> -Add channel table for the B2062 radio.
> -Add code for tuning the B2062 radio to channel.
> -Add error handling to op_switch_channel, and use it for both radios.
> 
> Rev0/1/B2062 will now hopefully show some signs of life, though
> it won't work at full performance, as calibration is still missing.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

ack

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Aug 14 22:17:39 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Aug 2009 22:17:39 +0200
Subject: [PATCH] b43: Add LP-PHY firmware loading support
In-Reply-To: <4A854FDF.5020208@gmail.com>
References: <4A854FDF.5020208@gmail.com>
Message-ID: <200908142217.40004.mb@bu3sch.de>

On Friday 14 August 2009 13:51:59 G?bor Stefanik wrote:
> Add support for loading LP-PHY firmware to b43_try_request_fw.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

ack
-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Fri Aug 14 22:20:55 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Fri, 14 Aug 2009 22:20:55 +0200
Subject: [PATCH] b43: Add LP-PHY firmware loading support
In-Reply-To: <200908142217.40004.mb@bu3sch.de>
References: <4A854FDF.5020208@gmail.com> <200908142217.40004.mb@bu3sch.de>
Message-ID: <69e28c910908141320x12e6988emc2bbdbb5fe1cecbe@mail.gmail.com>

2009/8/14 Michael Buesch <mb at bu3sch.de>:
> On Friday 14 August 2009 13:51:59 G?bor Stefanik wrote:
>> Add support for loading LP-PHY firmware to b43_try_request_fw.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>
> ack
> --
> Greetings, Michael.
>

This version is broken - ack "v3 this time really" instead.

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Fri Aug 14 22:41:03 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Aug 2009 22:41:03 +0200
Subject: [PATCH] b43: Add LP-PHY firmware loading support
In-Reply-To: <69e28c910908141320x12e6988emc2bbdbb5fe1cecbe@mail.gmail.com>
References: <4A854FDF.5020208@gmail.com> <200908142217.40004.mb@bu3sch.de>
	<69e28c910908141320x12e6988emc2bbdbb5fe1cecbe@mail.gmail.com>
Message-ID: <200908142241.03534.mb@bu3sch.de>

On Friday 14 August 2009 22:20:55 G?bor Stefanik wrote:
> 2009/8/14 Michael Buesch <mb at bu3sch.de>:
> > On Friday 14 August 2009 13:51:59 G?bor Stefanik wrote:
> >> Add support for loading LP-PHY firmware to b43_try_request_fw.
> >>
> >> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> >
> > ack
> > --
> > Greetings, Michael.
> >
> 
> This version is broken - ack "v3 this time really" instead.
> 

yeah whatever

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Fri Aug 14 22:43:24 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Aug 2009 15:43:24 -0500
Subject: [PATCH] b43: LP-PHY: Fix setting TX power control mode during
	RC	calibration
In-Reply-To: <4A85B8DE.3000704@gmail.com>
References: <4A85B8DE.3000704@gmail.com>
Message-ID: <4A85CC6C.1030005@lwfinger.net>

G?bor Stefanik wrote:
> Call set_tx_power_control with a LPPHY_TXPCTL rather than an
> LPPHY_TX_PWR_CTL_CMD_MODE.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> This should fix the WARN_ON testers were seeing during init.
> 
>  drivers/net/wireless/b43/phy_lp.c |    2 +-
>  1 files changed, 1 insertions(+), 1 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index adfa7bf..558224b 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -1080,7 +1080,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
>  	old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
>  					B43_LPPHY_TX_PWR_CTL_CMD_MODE;
>  
> -	lpphy_set_tx_power_control(dev, B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
> +	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
>  	lpphy_disable_crs(dev);
>  	loopback = lpphy_loopback(dev);
>  	if (loopback == -1)


With this one, I still get WARNING: at
drivers/net/wireless/b43/phy_lp.c:1006
lpphy_set_tx_power_control+0xbf/0xdd [b43]().

To get rid of them, I need to modify the enum b43_lpphy_txpctl_mode{}
as I wrote earlier.

I'm also seeing the interface stopped and restarted. I'll try to track
that down.

Larry




From netrolller.3d at gmail.com  Fri Aug 14 22:50:41 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Fri, 14 Aug 2009 22:50:41 +0200
Subject: [PATCH] b43: LP-PHY: Fix setting TX power control mode during RC 
	calibration
In-Reply-To: <4A85CC6C.1030005@lwfinger.net>
References: <4A85B8DE.3000704@gmail.com> <4A85CC6C.1030005@lwfinger.net>
Message-ID: <69e28c910908141350i67eca251x4d88d17feaa92e55@mail.gmail.com>

2009/8/14 Larry Finger <Larry.Finger at lwfinger.net>:
> G?bor Stefanik wrote:
>> Call set_tx_power_control with a LPPHY_TXPCTL rather than an
>> LPPHY_TX_PWR_CTL_CMD_MODE.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> This should fix the WARN_ON testers were seeing during init.
>>
>> ?drivers/net/wireless/b43/phy_lp.c | ? ?2 +-
>> ?1 files changed, 1 insertions(+), 1 deletions(-)
>>
>> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
>> index adfa7bf..558224b 100644
>> --- a/drivers/net/wireless/b43/phy_lp.c
>> +++ b/drivers/net/wireless/b43/phy_lp.c
>> @@ -1080,7 +1080,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
>> ? ? ? old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
>> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? B43_LPPHY_TX_PWR_CTL_CMD_MODE;
>>
>> - ? ? lpphy_set_tx_power_control(dev, B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
>> + ? ? lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
>> ? ? ? lpphy_disable_crs(dev);
>> ? ? ? loopback = lpphy_loopback(dev);
>> ? ? ? if (loopback == -1)
>
>
> With this one, I still get WARNING: at
> drivers/net/wireless/b43/phy_lp.c:1006
> lpphy_set_tx_power_control+0xbf/0xdd [b43]().
>
> To get rid of them, I need to modify the enum b43_lpphy_txpctl_mode{}
> as I wrote earlier.

Is ctl still 0? Please check.

>
> I'm also seeing the interface stopped and restarted. I'll try to track
> that down.
>
> Larry
>
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Fri Aug 14 22:53:58 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Aug 2009 22:53:58 +0200
Subject: [PATCH] ssb: Fix e typo in the rev8 SPROM extraction routine
In-Reply-To: <4A855489.6010102@gmail.com>
References: <4A855489.6010102@gmail.com>
Message-ID: <200908142253.58702.mb@bu3sch.de>

On Friday 14 August 2009 14:11:53 G?bor Stefanik wrote:
> No comment. :-)
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> Mark, this should fix your MAC address bug.
> Anyone else testing LP-PHY should also apply this.
> 
>  drivers/ssb/pci.c |    2 +-
>  1 files changed, 1 insertions(+), 1 deletions(-)
> 
> diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
> index 50811e4..335a43f 100644
> --- a/drivers/ssb/pci.c
> +++ b/drivers/ssb/pci.c
> @@ -480,7 +480,7 @@ static void sprom_extract_r8(struct ssb_sprom *out, const u16 *in)
>  
>  	/* extract the MAC address */
>  	for (i = 0; i < 3; i++) {
> -		v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
> +		v = in[SPOFF(SSB_SPROM8_IL0MAC) + i];
>  		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
>  	}
>  	SPEX(country_code, SSB_SPROM8_CCODE, 0xFFFF, 0);

ack

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Aug 14 23:00:01 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Aug 2009 23:00:01 +0200
Subject: [PATCH] b43: Fix sparse warnings
In-Reply-To: <1250283133.8137.16.camel@mj>
References: <4a84906b.+IYGhiNLKPSjrrR7%Larry.Finger@lwfinger.net>
	<200908142215.38112.mb@bu3sch.de> <1250283133.8137.16.camel@mj>
Message-ID: <200908142300.01397.mb@bu3sch.de>

On Friday 14 August 2009 22:52:13 Pavel Roskin wrote:
> On Fri, 2009-08-14 at 22:15 +0200, Michael Buesch wrote:
> 
> > > -			b43_phy_mask(dev, 0x048A, (u16)~0x8000);
> > > +			b43_phy_mask(dev, 0x048A, (u16)(~0x8000 & 0xFFFF));
> > 

> I would just use 0x7fff here.

That does not work if 0x8000 is a #defined bit.

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Fri Aug 14 23:00:32 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 14 Aug 2009 23:00:32 +0200
Subject: [PATCH] b43: LP-PHY: Fix another TX power control abuse
Message-ID: <4A85D070.6070702@gmail.com>

This should fix the remaining WARN_ON.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |    7 ++++---
 1 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index bf89173..3872a31 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1059,7 +1059,8 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 	bool old_txg_ovr;
 	u8 old_bbmult;
 	u16 old_rf_ovr, old_rf_ovrval, old_afe_ovr, old_afe_ovrval,
-	    old_rf2_ovr, old_rf2_ovrval, old_phy_ctl, old_txpctl;
+	    old_rf2_ovr, old_rf2_ovrval, old_phy_ctl;
+	enum b43_lpphy_txpctl_mode old_txpctl;
 	u32 normal_pwr, ideal_pwr, mean_sq_pwr, tmp = 0, mean_sq_pwr_min = 0;
 	int loopback, i, j, inner_sum;
 
@@ -1077,8 +1078,8 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 	old_rf2_ovr = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2);
 	old_rf2_ovrval = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2_VAL);
 	old_phy_ctl = b43_phy_read(dev, B43_LPPHY_LP_PHY_CTL);
-	old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
-					B43_LPPHY_TX_PWR_CTL_CMD_MODE;
+	lpphy_read_tx_pctl_mode_from_hardware(dev);
+	old_txpctl = lpphy->txpctl_mode;
 
 	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
 	lpphy_disable_crs(dev);
-- 
1.6.2.4





From netrolller.3d at gmail.com  Fri Aug 14 23:04:09 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Fri, 14 Aug 2009 23:04:09 +0200
Subject: [PATCH] b43: Fix sparse warnings
In-Reply-To: <200908142300.01397.mb@bu3sch.de>
References: <4a84906b.+IYGhiNLKPSjrrR7%Larry.Finger@lwfinger.net> 
	<200908142215.38112.mb@bu3sch.de> <1250283133.8137.16.camel@mj> 
	<200908142300.01397.mb@bu3sch.de>
Message-ID: <69e28c910908141404q42685aebo93718a7504020c06@mail.gmail.com>

On Fri, Aug 14, 2009 at 11:00 PM, Michael Buesch<mb at bu3sch.de> wrote:
> On Friday 14 August 2009 22:52:13 Pavel Roskin wrote:
>> On Fri, 2009-08-14 at 22:15 +0200, Michael Buesch wrote:
>>
>> > > - ? ? ? ? ? ? ? ? b43_phy_mask(dev, 0x048A, (u16)~0x8000);
>> > > + ? ? ? ? ? ? ? ? b43_phy_mask(dev, 0x048A, (u16)(~0x8000 & 0xFFFF));
>> >
>
>> I would just use 0x7fff here.
>
> That does not work if 0x8000 is a #defined bit.

What about ~((u16)0x8000)? (Or maybe ~(u16)0x8000 is enough, without
the extra parentheses.)

>
> --
> Greetings, Michael.
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From Larry.Finger at lwfinger.net  Fri Aug 14 23:31:15 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Aug 2009 16:31:15 -0500
Subject: [PATCH] b43: LP-PHY: Fix another TX power control abuse
In-Reply-To: <4A85D070.6070702@gmail.com>
References: <4A85D070.6070702@gmail.com>
Message-ID: <4A85D7A3.9020009@lwfinger.net>

G?bor Stefanik wrote:
> This should fix the remaining WARN_ON.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> drivers/net/wireless/b43/phy_lp.c |    7 ++++---
> 1 files changed, 4 insertions(+), 3 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index bf89173..3872a31 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -1059,7 +1059,8 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> *dev)
>     bool old_txg_ovr;
>     u8 old_bbmult;
>     u16 old_rf_ovr, old_rf_ovrval, old_afe_ovr, old_afe_ovrval,
> -        old_rf2_ovr, old_rf2_ovrval, old_phy_ctl, old_txpctl;
> +        old_rf2_ovr, old_rf2_ovrval, old_phy_ctl;
> +    enum b43_lpphy_txpctl_mode old_txpctl;
>     u32 normal_pwr, ideal_pwr, mean_sq_pwr, tmp = 0, mean_sq_pwr_min = 0;
>     int loopback, i, j, inner_sum;
> 
> @@ -1077,8 +1078,8 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> *dev)
>     old_rf2_ovr = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2);
>     old_rf2_ovrval = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2_VAL);
>     old_phy_ctl = b43_phy_read(dev, B43_LPPHY_LP_PHY_CTL);
> -    old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
> -                    B43_LPPHY_TX_PWR_CTL_CMD_MODE;
> +    lpphy_read_tx_pctl_mode_from_hardware(dev);
> +    old_txpctl = lpphy->txpctl_mode;
> 
>     lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
>     lpphy_disable_crs(dev);

Yes, this one got rid of the warnings.

Larry



From Larry.Finger at lwfinger.net  Fri Aug 14 23:33:56 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Aug 2009 16:33:56 -0500
Subject: [PATCH] b43: Fix sparse warnings
In-Reply-To: <200908142215.38112.mb@bu3sch.de>
References: <4a84906b.+IYGhiNLKPSjrrR7%Larry.Finger@lwfinger.net>
	<200908142215.38112.mb@bu3sch.de>
Message-ID: <4A85D844.8040805@lwfinger.net>

Michael Buesch wrote:
> On Friday 14 August 2009 00:15:07 Larry Finger wrote:
>> The b43 driver generates the following sparse warnings:
>>
>>   CHECK   drivers/net/wireless/b43/phy_g.c
>> drivers/net/wireless/b43/phy_g.c:974:35: warning: cast truncates bits from constant value (ffff7fff becomes 7fff)
>>   CHECK   drivers/net/wireless/b43/wa.c
>> drivers/net/wireless/b43/wa.c:385:53: warning: cast truncates bits from constant value (ffff00ff becomes ff)
>> drivers/net/wireless/b43/wa.c:403:48: warning: cast truncates bits from constant value (ffff00ff becomes ff)
>> drivers/net/wireless/b43/wa.c:405:48: warning: cast truncates bits from constant value (ffff00ff becomes ff)
>> drivers/net/wireless/b43/wa.c:415:50: warning: cast truncates bits from constant value (ffff0fff becomes fff)
>>
>> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
>> ---
>>
>> John,
>>
>> There is no hurry for this material.
>>
>> Larry
>> ---
>>
>> Index: wireless-testing/drivers/net/wireless/b43/phy_g.c
>> ===================================================================
>> --- wireless-testing.orig/drivers/net/wireless/b43/phy_g.c
>> +++ wireless-testing/drivers/net/wireless/b43/phy_g.c
>> @@ -971,7 +971,7 @@ b43_radio_interference_mitigation_enable
>>  		b43_phy_maskset(dev, 0x04A2, 0xFFF0, 0x000B);
>>  
>>  		if (phy->rev >= 3) {
>> -			b43_phy_mask(dev, 0x048A, (u16)~0x8000);
>> +			b43_phy_mask(dev, 0x048A, (u16)(~0x8000 & 0xFFFF));
> 
> Uh come on...
> The u16 cast already is stupid as hell, but this is becoming braindead.
> The code is perfectly fine. Sparse should instead provide an option to disable
> this fragile check.

John,

Just drop this patch. The code is OK as is.

Larry


From netrolller.3d at gmail.com  Sat Aug 15 00:00:59 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Sat, 15 Aug 2009 00:00:59 +0200
Subject: [PATCH] b43: LP-PHY: Fix another TX power control abuse
In-Reply-To: <4A85D7A3.9020009@lwfinger.net>
References: <4A85D070.6070702@gmail.com> <4A85D7A3.9020009@lwfinger.net>
Message-ID: <69e28c910908141500s2e6ee71avcebffd6107fe5a1@mail.gmail.com>

2009/8/14 Larry Finger <Larry.Finger at lwfinger.net>:
> G?bor Stefanik wrote:
>> This should fix the remaining WARN_ON.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> drivers/net/wireless/b43/phy_lp.c | ? ?7 ++++---
>> 1 files changed, 4 insertions(+), 3 deletions(-)
>>
>> diff --git a/drivers/net/wireless/b43/phy_lp.c
>> b/drivers/net/wireless/b43/phy_lp.c
>> index bf89173..3872a31 100644
>> --- a/drivers/net/wireless/b43/phy_lp.c
>> +++ b/drivers/net/wireless/b43/phy_lp.c
>> @@ -1059,7 +1059,8 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>> *dev)
>> ? ? bool old_txg_ovr;
>> ? ? u8 old_bbmult;
>> ? ? u16 old_rf_ovr, old_rf_ovrval, old_afe_ovr, old_afe_ovrval,
>> - ? ? ? ?old_rf2_ovr, old_rf2_ovrval, old_phy_ctl, old_txpctl;
>> + ? ? ? ?old_rf2_ovr, old_rf2_ovrval, old_phy_ctl;
>> + ? ?enum b43_lpphy_txpctl_mode old_txpctl;
>> ? ? u32 normal_pwr, ideal_pwr, mean_sq_pwr, tmp = 0, mean_sq_pwr_min = 0;
>> ? ? int loopback, i, j, inner_sum;
>>
>> @@ -1077,8 +1078,8 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>> *dev)
>> ? ? old_rf2_ovr = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2);
>> ? ? old_rf2_ovrval = b43_phy_read(dev, B43_LPPHY_RF_OVERRIDE_2_VAL);
>> ? ? old_phy_ctl = b43_phy_read(dev, B43_LPPHY_LP_PHY_CTL);
>> - ? ?old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
>> - ? ? ? ? ? ? ? ? ? ?B43_LPPHY_TX_PWR_CTL_CMD_MODE;
>> + ? ?lpphy_read_tx_pctl_mode_from_hardware(dev);
>> + ? ?old_txpctl = lpphy->txpctl_mode;
>>
>> ? ? lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
>> ? ? lpphy_disable_crs(dev);
>
> Yes, this one got rid of the warnings.
>
> Larry
>
>

I guess the device still doesn't TX/RX.

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From Larry.Finger at lwfinger.net  Sat Aug 15 00:12:48 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Aug 2009 17:12:48 -0500
Subject: [PATCH] b43: LP-PHY: Fix another TX power control abuse
In-Reply-To: <69e28c910908141500s2e6ee71avcebffd6107fe5a1@mail.gmail.com>
References: <4A85D070.6070702@gmail.com> <4A85D7A3.9020009@lwfinger.net>
	<69e28c910908141500s2e6ee71avcebffd6107fe5a1@mail.gmail.com>
Message-ID: <4A85E160.9080906@lwfinger.net>

G?bor Stefanik wrote:
> 2009/8/14 Larry Finger <Larry.Finger at lwfinger.net>:
>> Yes, this one got rid of the warnings.
>>
>> Larry
>>
>>
> 
> I guess the device still doesn't TX/RX.
> 

Not yet. The fact that it keeps getting shut down/restarted indicates
that the TX operations are not completing. I'm currently tracking the
path of operations.

Larry


From netrolller.3d at gmail.com  Sat Aug 15 00:52:02 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sat, 15 Aug 2009 00:52:02 +0200
Subject: [PATCH] b43: Handle B43_PHYTYPE_LP in RX path
Message-ID: <4A85EA92.80209@gmail.com>

Don't drop all packets received from an LP-PHY with WARN_ON.
Also update a comment with LP-specific information.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/wa.c   |    2 +-
 drivers/net/wireless/b43/xmit.c |    1 +
 2 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/wa.c b/drivers/net/wireless/b43/wa.c
index 73e97fa..97c7916 100644
--- a/drivers/net/wireless/b43/wa.c
+++ b/drivers/net/wireless/b43/wa.c
@@ -628,7 +628,7 @@ void b43_wa_all(struct b43_wldev *dev)
 			B43_WARN_ON(1);
 		}
 		b43_wa_boards_g(dev);
-	} else { /* No N PHY support so far */
+	} else { /* No N PHY support so far, LP PHY is in phy_lp.c */
 		B43_WARN_ON(1);
 	}
 
diff --git a/drivers/net/wireless/b43/xmit.c b/drivers/net/wireless/b43/xmit.c
index 5280ebc..be1c53e 100644
--- a/drivers/net/wireless/b43/xmit.c
+++ b/drivers/net/wireless/b43/xmit.c
@@ -655,6 +655,7 @@ void b43_rx(struct b43_wldev *dev, struct sk_buff *skb, const void *_rxhdr)
 		status.freq = chanid + 2400;
 		break;
 	case B43_PHYTYPE_N:
+	case B43_PHYTYPE_LP:
 		/* chanid is the SHM channel cookie. Which is the plain
 		 * channel number in b43. */
 		if (chanstat & B43_RX_CHAN_5GHZ) {
-- 
1.6.2.4





From mb at bu3sch.de  Sat Aug 15 12:04:10 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 15 Aug 2009 12:04:10 +0200
Subject: [PATCH] b43: Fix sparse warnings
In-Reply-To: <1250285729.8137.48.camel@mj>
References: <4a84906b.+IYGhiNLKPSjrrR7%Larry.Finger@lwfinger.net>
	<69e28c910908141404q42685aebo93718a7504020c06@mail.gmail.com>
	<1250285729.8137.48.camel@mj>
Message-ID: <200908151204.11024.mb@bu3sch.de>

On Friday 14 August 2009 23:35:29 Pavel Roskin wrote:
> On Fri, 2009-08-14 at 23:04 +0200, G?bor Stefanik wrote:
> > On Fri, Aug 14, 2009 at 11:00 PM, Michael Buesch<mb at bu3sch.de> wrote:
> > > On Friday 14 August 2009 22:52:13 Pavel Roskin wrote:
> > >> On Fri, 2009-08-14 at 22:15 +0200, Michael Buesch wrote:
> > >>
> > >> > > -                 b43_phy_mask(dev, 0x048A, (u16)~0x8000);
> > >> > > +                 b43_phy_mask(dev, 0x048A, (u16)(~0x8000 & 0xFFFF));
> > >> >
> > >
> > >> I would just use 0x7fff here.
> > >
> > > That does not work if 0x8000 is a #defined bit.
> > 
> > What about ~((u16)0x8000)?
> 
> phy_g.c:974: warning: large integer implicitly truncated to unsigned
> type
> 
> >  (Or maybe ~(u16)0x8000 is enough, without
> > the extra parentheses.)
> 
> Same thing.  Sparse complains whether the cast is explicit or implicit.
> 

I still do not understand why it does complain about an _explicit_ truncation.
That's simply stupid. If I program an explicit truncation I _do_ mean to truncate the value.

-- 
Greetings, Michael.


From mb at bu3sch.de  Sat Aug 15 12:08:01 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 15 Aug 2009 12:08:01 +0200
Subject: [PATCH] b43: Fix sparse warnings
In-Reply-To: <1250286414.8137.55.camel@mj>
References: <4a84906b.+IYGhiNLKPSjrrR7%Larry.Finger@lwfinger.net>
	<1250285371.8137.44.camel@mj> <1250286414.8137.55.camel@mj>
Message-ID: <200908151208.01349.mb@bu3sch.de>

On Friday 14 August 2009 23:46:54 Pavel Roskin wrote:
> On Fri, 2009-08-14 at 17:29 -0400, Pavel Roskin wrote:
> > On Fri, 2009-08-14 at 23:00 +0200, Michael Buesch wrote:
> > > On Friday 14 August 2009 22:52:13 Pavel Roskin wrote:
> > > > On Fri, 2009-08-14 at 22:15 +0200, Michael Buesch wrote:
> > > > 
> > > > > > -			b43_phy_mask(dev, 0x048A, (u16)~0x8000);
> > > > > > +			b43_phy_mask(dev, 0x048A, (u16)(~0x8000 & 0xFFFF));
> > > > > 
> > > 
> > > > I would just use 0x7fff here.
> > > 
> > > That does not work if 0x8000 is a #defined bit.
> > 
> > One approach would be to use a macro and tell sparse to ignore it
> > 
> > #define NEGATE(x) (__force typeof(x))(~x)
> 
> Scratch that.  It has no change to work for constants unless we hardcode
> the size, e.g. by having NEGATE16, NEGATE32 etc.
> 
> The best I could do is:
> 
> #define NEGATE16(x) (0xFFFF & ~x)
> b43_phy_mask(dev, 0x048A, NEGATE16(0x8000));

I think the real question is whether this does really prevent any bugs or whether
it just introduces new possibilities for bugs.

void my_func(u32 x);

my_func(NEGATE16(0x8000));

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Sat Aug 15 17:26:27 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Sat, 15 Aug 2009 17:26:27 +0200
Subject: BCM4325 question
Message-ID: <69e28c910908150826l70238df1ofaa2b3255ef24e0a@mail.gmail.com>

You asked on the bcm43xx-dev list a year ago if the BCM4325 is
supported - is this question still current?
I am asking because we are implementing LP-PHY support right now
(BCM4325 is an LP-PHY), and will soon need a tester with a revision 2
LP-PHY chip (the 4325 is rev.2, but everyone in the team has only a
rev.0 or rev.1 chip).
Also, where did you obtain a 4325-based wireless solution; is it a
custom-built board with a 4325 chip mounted directly, or some
commercially available BCM4325-based solution? (The team will likely
need one for testing.)

Thanks,
G?bor Stefanik
B43 Linux wireless driver development team

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From Larry.Finger at lwfinger.net  Sat Aug 15 22:33:19 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 15 Aug 2009 15:33:19 -0500
Subject: Question about LDO and SSB
Message-ID: <4A871B8F.9010003@lwfinger.net>

Michael,

I just ran across a couple of routines named sb_pmu_set_ldo_voltage()
and sb_pmu_paref_ldo_enable(). These are no-ops for all chips except
for 0x4328, 0x5354, and 0x4312 and I don't need to be concerned at the
moment, but I will eventually need to deal with them. Do you have any
insights into the LDO?

Thanks,

Larry


From mb at bu3sch.de  Sat Aug 15 22:43:57 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 15 Aug 2009 22:43:57 +0200
Subject: Question about LDO and SSB
In-Reply-To: <4A871B8F.9010003@lwfinger.net>
References: <4A871B8F.9010003@lwfinger.net>
Message-ID: <200908152243.57688.mb@bu3sch.de>

On Saturday 15 August 2009 22:33:19 Larry Finger wrote:
> Michael,
> 
> I just ran across a couple of routines named sb_pmu_set_ldo_voltage()
> and sb_pmu_paref_ldo_enable(). These are no-ops for all chips except
> for 0x4328, 0x5354, and 0x4312 and I don't need to be concerned at the
> moment, but I will eventually need to deal with them. Do you have any
> insights into the LDO?

I think we don't need to care too much about those routines.
They are most likely only needed on embedded devices and there the bootloader
already configured this correctly for us. So they are really always skipped
in the linux kernel bootup. (That's the case for the frequency tuning, if you
keep the default PLL frequency).

But it would be good to have specs nevertheless, if we want to develop our
own bootloader (which I wanted to do, but froze the project for now).

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Sat Aug 15 23:43:08 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Sat, 15 Aug 2009 23:43:08 +0200
Subject: Question about LDO and SSB
In-Reply-To: <4A871B8F.9010003@lwfinger.net>
References: <4A871B8F.9010003@lwfinger.net>
Message-ID: <69e28c910908151443w5520e30s4e8e0ba75b5aadbf@mail.gmail.com>

On Sat, Aug 15, 2009 at 10:33 PM, Larry Finger<Larry.Finger at lwfinger.net> wrote:
> Michael,
>
> I just ran across a couple of routines named sb_pmu_set_ldo_voltage()
> and sb_pmu_paref_ldo_enable(). These are no-ops for all chips except
> for 0x4328, 0x5354, and 0x4312 and I don't need to be concerned at the
> moment

Isn't yours a 4312?

> but I will eventually need to deal with them. Do you have any
> insights into the LDO?
>
> Thanks,
>
> Larry
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Sun Aug 16 00:57:18 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 16 Aug 2009 00:57:18 +0200
Subject: [PATCH] b43: LP-PHY: Update baseband init for recent spec changes
Message-ID: <4A873D4E.6040502@gmail.com>

The spec had some nasty typos, and a large part of the rev0/1 BB
init procedure was also missing. Fix these.

Also make the init-time channel switch debuggable.

(The change from -EINVAL to -EIO is simply to make it possible
to distinguish the PLL charge pump error from a channel-not-found
error.)

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |   71 ++++++++++++++++++++++++++++++++++---
 1 files changed, 66 insertions(+), 5 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 3872a31..72e1d8c 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -204,8 +204,61 @@ static void lpphy_table_init(struct b43_wldev *dev)
 static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 {
 	struct ssb_bus *bus = dev->dev->bus;
+	struct b43_phy_lp *lpphy = dev->phy.lp;
 	u16 tmp, tmp2;
 
+	b43_phy_mask(dev, B43_LPPHY_AFE_DAC_CTL, 0xF7FF);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL, 0);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVR, 0);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_0, 0);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0);
+	b43_phy_set(dev, B43_LPPHY_AFE_DAC_CTL, 0x0004);
+	b43_phy_maskset(dev, B43_LPPHY_OFDMSYNCTHRESH0, 0xFF00, 0x0078);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x5800);
+	b43_phy_write(dev, B43_LPPHY_ADC_COMPENSATION_CTL, 0x0016);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_ADC_CTL_0, 0xFFF8, 0x0004);
+	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0x00FF, 0x5400);
+	b43_phy_maskset(dev, B43_LPPHY_HIGAINDB, 0x00FF, 0x2400);
+	b43_phy_maskset(dev, B43_LPPHY_LOWGAINDB, 0x00FF, 0x2100);
+	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0xFF00, 0x0006);
+	b43_phy_mask(dev, B43_LPPHY_RX_RADIO_CTL, 0xFFFE);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x0005);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC10, 0x0180);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x3800);
+	b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xFFF0, 0x0005);
+	b43_phy_maskset(dev, B43_LPPHY_GAIN_MISMATCH_LIMIT, 0xFFC0, 0x001A);
+	b43_phy_maskset(dev, B43_LPPHY_CRS_ED_THRESH, 0xFF00, 0x00B3);
+	b43_phy_maskset(dev, B43_LPPHY_CRS_ED_THRESH, 0x00FF, 0xAD00);
+	b43_phy_maskset(dev, B43_LPPHY_INPUT_PWRDB,
+			0xFF00, lpphy->rx_pwr_offset);
+	if ((bus->sprom.boardflags_lo & B43_BFL_FEM) &&
+	   ((b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ) ||
+	   (bus->sprom.boardflags_hi & B43_BFH_PAREF))) {
+		/* TODO:
+		 * Set the LDO voltage to 0x0028 - FIXME: What is this?
+		 * Call sb_pmu_set_ldo_voltage with 4 and the LDO voltage
+		 * 	as arguments
+		 * Call sb_pmu_paref_ldo_enable with argument TRUE
+		 */
+		if (dev->phy.rev == 0)
+		       	b43_phy_maskset(dev, B43_LPPHY_LP_RF_SIGNAL_LUT,
+					0xFFCF, 0x0010);
+		b43_lptab_write(dev, B43_LPTAB16(11, 7), 60);
+	} else {
+		//TODO: Call ssb_pmu_paref_ldo_enable with argument FALSE
+		b43_phy_maskset(dev, B43_LPPHY_LP_RF_SIGNAL_LUT,
+				0xFFCF, 0x0020);
+		b43_lptab_write(dev, B43_LPTAB16(11, 7), 100);
+	}
+	tmp = lpphy->rssi_vf | lpphy->rssi_vc << 4 | 0xA000;
+	b43_phy_write(dev, B43_LPPHY_AFE_RSSI_CTL_0, tmp);
+	if (bus->sprom.boardflags_hi & B43_BFH_RSSIINV)
+		b43_phy_maskset(dev, B43_LPPHY_AFE_RSSI_CTL_1, 0xF000, 0x0AAA);
+	else
+		b43_phy_maskset(dev, B43_LPPHY_AFE_RSSI_CTL_1, 0xF000, 0x02AA);
+	b43_lptab_write(dev, B43_LPTAB16(11, 1), 24);
+	b43_phy_maskset(dev, B43_LPPHY_RX_RADIO_CTL,
+			0xFFF9, (lpphy->bx_arch << 1));
 	if (dev->phy.rev == 1 &&
 	   (bus->sprom.boardflags_hi & B43_BFH_FEM_BT)) {
 		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
@@ -255,7 +308,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0006);
 		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0700);
 	}
-	if (dev->phy.rev == 1) {
+	if (dev->phy.rev == 1 && (bus->sprom.boardflags_hi & B43_BFH_PAREF)) {
 		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_5, B43_LPPHY_TR_LOOKUP_1);
 		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_6, B43_LPPHY_TR_LOOKUP_2);
 		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_7, B43_LPPHY_TR_LOOKUP_3);
@@ -267,6 +320,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
 		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
 		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
+		//FIXME the Broadcom driver caches & delays this HF write!
 		b43_hf_write(dev, b43_hf_read(dev) | B43_HF_PR45960W);
 	}
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
@@ -384,7 +438,7 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_maskset(dev, B43_LPPHY_PWR_THRESH1, 0xFFF0, 0x9);
 	b43_phy_mask(dev, B43_LPPHY_GAINDIRECTMISMATCH, ~0xF);
 	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0x00FF, 0x5500);
-	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xF81F, 0xA0);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC1F, 0xA0);
 	b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xE0FF, 0x300);
 	b43_phy_maskset(dev, B43_LPPHY_HIGAINDB, 0x00FF, 0x2A00);
 	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 0)) {
@@ -405,7 +459,7 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x12);
 	b43_phy_maskset(dev, B43_LPPHY_GAINMISMATCH, 0x0FFF, 0x9000);
 
-	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 1)) {
+	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 0)) {
 		b43_lptab_write(dev, B43_LPTAB16(0x08, 0x14), 0);
 		b43_lptab_write(dev, B43_LPTAB16(0x08, 0x12), 0x40);
 	}
@@ -416,6 +470,7 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 		b43_phy_maskset(dev, B43_LPPHY_SYNCPEAKCNT, 0xFFF8, 0x6);
 		b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0x00FF, 0x9D00);
 		b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0xFF00, 0xA1);
+		b43_phy_mask(dev, B43_LPPHY_IDLEAFTERPKTRXTO, 0x00FF);
 	} else /* 5GHz */
 		b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, ~0x40);
 
@@ -1883,7 +1938,7 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
 		lpphy_b2062_reset_pll_bias(dev);
 		lpphy_b2062_vco_calib(dev);
 		if (b43_radio_read(dev, B2062_S_RFPLL_CTL3) & 0x10)
-			err = -EINVAL;
+			err = -EIO;
 	}
 
 	b43_radio_mask(dev, B2062_S_RFPLL_CTL14, ~0x04);
@@ -2068,11 +2123,17 @@ static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
 
 static int b43_lpphy_op_init(struct b43_wldev *dev)
 {
+	int err;
+	
 	lpphy_read_band_sprom(dev); //FIXME should this be in prepare_structs?
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
 	lpphy_calibrate_rc(dev);
-	b43_lpphy_op_switch_channel(dev, b43_lpphy_op_get_default_chan(dev));
+	err = b43_lpphy_op_switch_channel(dev,
+				b43_lpphy_op_get_default_chan(dev));
+	if (err)
+		b43dbg(dev->wl, "Switch to init channel failed, error = %d.\n",
+		       err);
 	lpphy_tx_pctl_init(dev);
 	lpphy_calibration(dev);
 	//TODO ACI init
-- 
1.6.2.4





From netrolller.3d at gmail.com  Sun Aug 16 01:05:04 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 16 Aug 2009 01:05:04 +0200
Subject: [PATCH v2] b43: LP-PHY: Update baseband init for recent spec changes
Message-ID: <4A873F20.4020705@gmail.com>

The spec had some nasty typos, and a large part of the rev0/1 BB
init procedure was also missing. Fix these.

Also make the init-time channel switch debuggable.

(The change from -EINVAL to -EIO is simply to make it possible
to distinguish the PLL charge pump error from a channel-not-found
error.)

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
V2: Coding style fix suggested by Michael on IRC.

 drivers/net/wireless/b43/phy_lp.c |   72 ++++++++++++++++++++++++++++++++++---
 1 files changed, 67 insertions(+), 5 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 3872a31..c7f6c75 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -204,8 +204,62 @@ static void lpphy_table_init(struct b43_wldev *dev)
 static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 {
 	struct ssb_bus *bus = dev->dev->bus;
+	struct b43_phy_lp *lpphy = dev->phy.lp;
 	u16 tmp, tmp2;
 
+	b43_phy_mask(dev, B43_LPPHY_AFE_DAC_CTL, 0xF7FF);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL, 0);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVR, 0);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_0, 0);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0);
+	b43_phy_set(dev, B43_LPPHY_AFE_DAC_CTL, 0x0004);
+	b43_phy_maskset(dev, B43_LPPHY_OFDMSYNCTHRESH0, 0xFF00, 0x0078);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x5800);
+	b43_phy_write(dev, B43_LPPHY_ADC_COMPENSATION_CTL, 0x0016);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_ADC_CTL_0, 0xFFF8, 0x0004);
+	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0x00FF, 0x5400);
+	b43_phy_maskset(dev, B43_LPPHY_HIGAINDB, 0x00FF, 0x2400);
+	b43_phy_maskset(dev, B43_LPPHY_LOWGAINDB, 0x00FF, 0x2100);
+	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0xFF00, 0x0006);
+	b43_phy_mask(dev, B43_LPPHY_RX_RADIO_CTL, 0xFFFE);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x0005);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC10, 0x0180);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x3800);
+	b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xFFF0, 0x0005);
+	b43_phy_maskset(dev, B43_LPPHY_GAIN_MISMATCH_LIMIT, 0xFFC0, 0x001A);
+	b43_phy_maskset(dev, B43_LPPHY_CRS_ED_THRESH, 0xFF00, 0x00B3);
+	b43_phy_maskset(dev, B43_LPPHY_CRS_ED_THRESH, 0x00FF, 0xAD00);
+	b43_phy_maskset(dev, B43_LPPHY_INPUT_PWRDB,
+			0xFF00, lpphy->rx_pwr_offset);
+	if ((bus->sprom.boardflags_lo & B43_BFL_FEM) &&
+	   ((b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ) ||
+	   (bus->sprom.boardflags_hi & B43_BFH_PAREF))) {
+		/* TODO:
+		 * Set the LDO voltage to 0x0028 - FIXME: What is this?
+		 * Call sb_pmu_set_ldo_voltage with 4 and the LDO voltage
+		 * 	as arguments
+		 * Call sb_pmu_paref_ldo_enable with argument TRUE
+		 */
+		if (dev->phy.rev == 0) {
+		       	b43_phy_maskset(dev, B43_LPPHY_LP_RF_SIGNAL_LUT,
+					0xFFCF, 0x0010);
+		}
+		b43_lptab_write(dev, B43_LPTAB16(11, 7), 60);
+	} else {
+		//TODO: Call ssb_pmu_paref_ldo_enable with argument FALSE
+		b43_phy_maskset(dev, B43_LPPHY_LP_RF_SIGNAL_LUT,
+				0xFFCF, 0x0020);
+		b43_lptab_write(dev, B43_LPTAB16(11, 7), 100);
+	}
+	tmp = lpphy->rssi_vf | lpphy->rssi_vc << 4 | 0xA000;
+	b43_phy_write(dev, B43_LPPHY_AFE_RSSI_CTL_0, tmp);
+	if (bus->sprom.boardflags_hi & B43_BFH_RSSIINV)
+		b43_phy_maskset(dev, B43_LPPHY_AFE_RSSI_CTL_1, 0xF000, 0x0AAA);
+	else
+		b43_phy_maskset(dev, B43_LPPHY_AFE_RSSI_CTL_1, 0xF000, 0x02AA);
+	b43_lptab_write(dev, B43_LPTAB16(11, 1), 24);
+	b43_phy_maskset(dev, B43_LPPHY_RX_RADIO_CTL,
+			0xFFF9, (lpphy->bx_arch << 1));
 	if (dev->phy.rev == 1 &&
 	   (bus->sprom.boardflags_hi & B43_BFH_FEM_BT)) {
 		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
@@ -255,7 +309,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0006);
 		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0700);
 	}
-	if (dev->phy.rev == 1) {
+	if (dev->phy.rev == 1 && (bus->sprom.boardflags_hi & B43_BFH_PAREF)) {
 		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_5, B43_LPPHY_TR_LOOKUP_1);
 		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_6, B43_LPPHY_TR_LOOKUP_2);
 		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_7, B43_LPPHY_TR_LOOKUP_3);
@@ -267,6 +321,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
 		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
 		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
+		//FIXME the Broadcom driver caches & delays this HF write!
 		b43_hf_write(dev, b43_hf_read(dev) | B43_HF_PR45960W);
 	}
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
@@ -384,7 +439,7 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_maskset(dev, B43_LPPHY_PWR_THRESH1, 0xFFF0, 0x9);
 	b43_phy_mask(dev, B43_LPPHY_GAINDIRECTMISMATCH, ~0xF);
 	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0x00FF, 0x5500);
-	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xF81F, 0xA0);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC1F, 0xA0);
 	b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xE0FF, 0x300);
 	b43_phy_maskset(dev, B43_LPPHY_HIGAINDB, 0x00FF, 0x2A00);
 	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 0)) {
@@ -405,7 +460,7 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x12);
 	b43_phy_maskset(dev, B43_LPPHY_GAINMISMATCH, 0x0FFF, 0x9000);
 
-	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 1)) {
+	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 0)) {
 		b43_lptab_write(dev, B43_LPTAB16(0x08, 0x14), 0);
 		b43_lptab_write(dev, B43_LPTAB16(0x08, 0x12), 0x40);
 	}
@@ -416,6 +471,7 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 		b43_phy_maskset(dev, B43_LPPHY_SYNCPEAKCNT, 0xFFF8, 0x6);
 		b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0x00FF, 0x9D00);
 		b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0xFF00, 0xA1);
+		b43_phy_mask(dev, B43_LPPHY_IDLEAFTERPKTRXTO, 0x00FF);
 	} else /* 5GHz */
 		b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, ~0x40);
 
@@ -1883,7 +1939,7 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
 		lpphy_b2062_reset_pll_bias(dev);
 		lpphy_b2062_vco_calib(dev);
 		if (b43_radio_read(dev, B2062_S_RFPLL_CTL3) & 0x10)
-			err = -EINVAL;
+			err = -EIO;
 	}
 
 	b43_radio_mask(dev, B2062_S_RFPLL_CTL14, ~0x04);
@@ -2068,11 +2124,17 @@ static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
 
 static int b43_lpphy_op_init(struct b43_wldev *dev)
 {
+	int err;
+	
 	lpphy_read_band_sprom(dev); //FIXME should this be in prepare_structs?
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
 	lpphy_calibrate_rc(dev);
-	b43_lpphy_op_switch_channel(dev, b43_lpphy_op_get_default_chan(dev));
+	err = b43_lpphy_op_switch_channel(dev,
+				b43_lpphy_op_get_default_chan(dev));
+	if (err)
+		b43dbg(dev->wl, "Switch to init channel failed, error = %d.\n",
+		       err);
 	lpphy_tx_pctl_init(dev);
 	lpphy_calibration(dev);
 	//TODO ACI init
-- 
1.6.2.4





From mb at bu3sch.de  Sun Aug 16 01:07:35 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Aug 2009 01:07:35 +0200
Subject: [PATCH v2] b43: LP-PHY: Update baseband init for recent spec
	changes
In-Reply-To: <4A873F20.4020705@gmail.com>
References: <4A873F20.4020705@gmail.com>
Message-ID: <200908160107.35992.mb@bu3sch.de>

On Sunday 16 August 2009 01:05:04 G?bor Stefanik wrote:
> The spec had some nasty typos, and a large part of the rev0/1 BB
> init procedure was also missing. Fix these.
> 
> Also make the init-time channel switch debuggable.
> 
> (The change from -EINVAL to -EIO is simply to make it possible
> to distinguish the PLL charge pump error from a channel-not-found
> error.)
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> V2: Coding style fix suggested by Michael on IRC.

> +	if (err)
> +		b43dbg(dev->wl, "Switch to init channel failed, error = %d.\n",
> +		       err);

Here's still one, but otherwise acked.

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Sun Aug 16 01:15:49 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 16 Aug 2009 01:15:49 +0200
Subject: [PATCH v3] b43: LP-PHY: Update baseband init for recent spec changes
Message-ID: <4A8741A5.1090108@gmail.com>

The spec had some nasty typos, and a large part of the rev0/1 BB
init procedure was also missing. Fix these.

Also make the init-time channel switch debuggable.

(The change from -EINVAL to -EIO is simply to make it possible
to distinguish the PLL charge pump error from a channel-not-found
error.)

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
V2: Coding style fix suggested by Michael on IRC.
V3: Another coding style fix.

 drivers/net/wireless/b43/phy_lp.c |   73 ++++++++++++++++++++++++++++++++++---
 1 files changed, 68 insertions(+), 5 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 3872a31..e4a040b 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -204,8 +204,62 @@ static void lpphy_table_init(struct b43_wldev *dev)
 static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 {
 	struct ssb_bus *bus = dev->dev->bus;
+	struct b43_phy_lp *lpphy = dev->phy.lp;
 	u16 tmp, tmp2;
 
+	b43_phy_mask(dev, B43_LPPHY_AFE_DAC_CTL, 0xF7FF);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL, 0);
+	b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVR, 0);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_0, 0);
+	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0);
+	b43_phy_set(dev, B43_LPPHY_AFE_DAC_CTL, 0x0004);
+	b43_phy_maskset(dev, B43_LPPHY_OFDMSYNCTHRESH0, 0xFF00, 0x0078);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x5800);
+	b43_phy_write(dev, B43_LPPHY_ADC_COMPENSATION_CTL, 0x0016);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_ADC_CTL_0, 0xFFF8, 0x0004);
+	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0x00FF, 0x5400);
+	b43_phy_maskset(dev, B43_LPPHY_HIGAINDB, 0x00FF, 0x2400);
+	b43_phy_maskset(dev, B43_LPPHY_LOWGAINDB, 0x00FF, 0x2100);
+	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0xFF00, 0x0006);
+	b43_phy_mask(dev, B43_LPPHY_RX_RADIO_CTL, 0xFFFE);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x0005);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC10, 0x0180);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x3800);
+	b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xFFF0, 0x0005);
+	b43_phy_maskset(dev, B43_LPPHY_GAIN_MISMATCH_LIMIT, 0xFFC0, 0x001A);
+	b43_phy_maskset(dev, B43_LPPHY_CRS_ED_THRESH, 0xFF00, 0x00B3);
+	b43_phy_maskset(dev, B43_LPPHY_CRS_ED_THRESH, 0x00FF, 0xAD00);
+	b43_phy_maskset(dev, B43_LPPHY_INPUT_PWRDB,
+			0xFF00, lpphy->rx_pwr_offset);
+	if ((bus->sprom.boardflags_lo & B43_BFL_FEM) &&
+	   ((b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ) ||
+	   (bus->sprom.boardflags_hi & B43_BFH_PAREF))) {
+		/* TODO:
+		 * Set the LDO voltage to 0x0028 - FIXME: What is this?
+		 * Call sb_pmu_set_ldo_voltage with 4 and the LDO voltage
+		 * 	as arguments
+		 * Call sb_pmu_paref_ldo_enable with argument TRUE
+		 */
+		if (dev->phy.rev == 0) {
+		       	b43_phy_maskset(dev, B43_LPPHY_LP_RF_SIGNAL_LUT,
+					0xFFCF, 0x0010);
+		}
+		b43_lptab_write(dev, B43_LPTAB16(11, 7), 60);
+	} else {
+		//TODO: Call ssb_pmu_paref_ldo_enable with argument FALSE
+		b43_phy_maskset(dev, B43_LPPHY_LP_RF_SIGNAL_LUT,
+				0xFFCF, 0x0020);
+		b43_lptab_write(dev, B43_LPTAB16(11, 7), 100);
+	}
+	tmp = lpphy->rssi_vf | lpphy->rssi_vc << 4 | 0xA000;
+	b43_phy_write(dev, B43_LPPHY_AFE_RSSI_CTL_0, tmp);
+	if (bus->sprom.boardflags_hi & B43_BFH_RSSIINV)
+		b43_phy_maskset(dev, B43_LPPHY_AFE_RSSI_CTL_1, 0xF000, 0x0AAA);
+	else
+		b43_phy_maskset(dev, B43_LPPHY_AFE_RSSI_CTL_1, 0xF000, 0x02AA);
+	b43_lptab_write(dev, B43_LPTAB16(11, 1), 24);
+	b43_phy_maskset(dev, B43_LPPHY_RX_RADIO_CTL,
+			0xFFF9, (lpphy->bx_arch << 1));
 	if (dev->phy.rev == 1 &&
 	   (bus->sprom.boardflags_hi & B43_BFH_FEM_BT)) {
 		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_1, 0xFFC0, 0x000A);
@@ -255,7 +309,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xFFC0, 0x0006);
 		b43_phy_maskset(dev, B43_LPPHY_TR_LOOKUP_4, 0xC0FF, 0x0700);
 	}
-	if (dev->phy.rev == 1) {
+	if (dev->phy.rev == 1 && (bus->sprom.boardflags_hi & B43_BFH_PAREF)) {
 		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_5, B43_LPPHY_TR_LOOKUP_1);
 		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_6, B43_LPPHY_TR_LOOKUP_2);
 		b43_phy_copy(dev, B43_LPPHY_TR_LOOKUP_7, B43_LPPHY_TR_LOOKUP_3);
@@ -267,6 +321,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 		b43_phy_set(dev, B43_LPPHY_CRSGAIN_CTL, 0x0006);
 		b43_phy_write(dev, B43_LPPHY_GPIO_SELECT, 0x0005);
 		b43_phy_write(dev, B43_LPPHY_GPIO_OUTEN, 0xFFFF);
+		//FIXME the Broadcom driver caches & delays this HF write!
 		b43_hf_write(dev, b43_hf_read(dev) | B43_HF_PR45960W);
 	}
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
@@ -384,7 +439,7 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_maskset(dev, B43_LPPHY_PWR_THRESH1, 0xFFF0, 0x9);
 	b43_phy_mask(dev, B43_LPPHY_GAINDIRECTMISMATCH, ~0xF);
 	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0x00FF, 0x5500);
-	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xF81F, 0xA0);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC1F, 0xA0);
 	b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xE0FF, 0x300);
 	b43_phy_maskset(dev, B43_LPPHY_HIGAINDB, 0x00FF, 0x2A00);
 	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 0)) {
@@ -405,7 +460,7 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x12);
 	b43_phy_maskset(dev, B43_LPPHY_GAINMISMATCH, 0x0FFF, 0x9000);
 
-	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 1)) {
+	if ((bus->chip_id == 0x4325) && (bus->chip_rev == 0)) {
 		b43_lptab_write(dev, B43_LPTAB16(0x08, 0x14), 0);
 		b43_lptab_write(dev, B43_LPTAB16(0x08, 0x12), 0x40);
 	}
@@ -416,6 +471,7 @@ static void lpphy_baseband_rev2plus_init(struct b43_wldev *dev)
 		b43_phy_maskset(dev, B43_LPPHY_SYNCPEAKCNT, 0xFFF8, 0x6);
 		b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0x00FF, 0x9D00);
 		b43_phy_maskset(dev, B43_LPPHY_MINPWR_LEVEL, 0xFF00, 0xA1);
+		b43_phy_mask(dev, B43_LPPHY_IDLEAFTERPKTRXTO, 0x00FF);
 	} else /* 5GHz */
 		b43_phy_mask(dev, B43_LPPHY_CRSGAIN_CTL, ~0x40);
 
@@ -1883,7 +1939,7 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
 		lpphy_b2062_reset_pll_bias(dev);
 		lpphy_b2062_vco_calib(dev);
 		if (b43_radio_read(dev, B2062_S_RFPLL_CTL3) & 0x10)
-			err = -EINVAL;
+			err = -EIO;
 	}
 
 	b43_radio_mask(dev, B2062_S_RFPLL_CTL14, ~0x04);
@@ -2068,11 +2124,18 @@ static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
 
 static int b43_lpphy_op_init(struct b43_wldev *dev)
 {
+	int err;
+	
 	lpphy_read_band_sprom(dev); //FIXME should this be in prepare_structs?
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
 	lpphy_calibrate_rc(dev);
-	b43_lpphy_op_switch_channel(dev, b43_lpphy_op_get_default_chan(dev));
+	err = b43_lpphy_op_switch_channel(dev,
+				b43_lpphy_op_get_default_chan(dev));
+	if (err) {
+		b43dbg(dev->wl, "Switch to init channel failed, error = %d.\n",
+		       err);
+	}
 	lpphy_tx_pctl_init(dev);
 	lpphy_calibration(dev);
 	//TODO ACI init
-- 
1.6.2.4





From netrolller.3d at gmail.com  Sun Aug 16 15:26:37 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 16 Aug 2009 15:26:37 +0200
Subject: [PATCH] b43: LP-PHY: Update code for spec fixes, and fix a few typos
Message-ID: <4A88090D.3070107@gmail.com>

A few typos have been discovered both in the specs in and our code.
This patch fixes them.

Also use lpphy_op_switch_channel consistently, and make all callers
print its return value for easier debugging.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
I think using a forward declaration is justified in this case;
as avoiding the forward decl would require moving around huge
blocks of code, completely breaking any logical ordering.

 drivers/net/wireless/b43/phy_lp.c |   51 ++++++++++++++++++++++++------------
 1 files changed, 34 insertions(+), 17 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index e4a040b..a51da6e 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -552,7 +552,7 @@ static void lpphy_2062_init(struct b43_wldev *dev)
 	B43_WARN_ON(!(bus->chipco.capabilities & SSB_CHIPCO_CAP_PMU));
 	B43_WARN_ON(crystalfreq == 0);
 
-	if (crystalfreq >= 30000000) {
+	if (crystalfreq <= 30000000) {
 		lpphy->pdiv = 1;
 		b43_radio_mask(dev, B2062_S_RFPLL_CTL1, 0xFFFB);
 	} else {
@@ -560,14 +560,16 @@ static void lpphy_2062_init(struct b43_wldev *dev)
 		b43_radio_set(dev, B2062_S_RFPLL_CTL1, 0x4);
 	}
 
-	tmp = (800000000 * lpphy->pdiv + crystalfreq) /
-	      (32000000 * lpphy->pdiv);
-	tmp = (tmp - 1) & 0xFF;
+	tmp = (((800000000 * lpphy->pdiv + crystalfreq) /
+	      (2 * crystalfreq)) - 8) & 0xFF;
+	b43_radio_write(dev, B2062_S_RFPLL_CTL7, tmp);
+
+	tmp = (((100 * crystalfreq + 16000000 * lpphy->pdiv) /
+	      (32000000 * lpphy->pdiv)) - 1) & 0xFF;
 	b43_radio_write(dev, B2062_S_RFPLL_CTL18, tmp);
 
-	tmp = (2 * crystalfreq + 1000000 * lpphy->pdiv) /
-	      (2000000 * lpphy->pdiv);
-	tmp = ((tmp & 0xFF) - 1) & 0xFFFF;
+	tmp = (((2 * crystalfreq + 1000000 * lpphy->pdiv) /
+	      (2000000 * lpphy->pdiv)) - 1) & 0xFF;
 	b43_radio_write(dev, B2062_S_RFPLL_CTL19, tmp);
 
 	ref = (1000 * lpphy->pdiv + 2 * crystalfreq) / (2000 * lpphy->pdiv);
@@ -671,7 +673,7 @@ static void lpphy_radio_init(struct b43_wldev *dev)
 	b43_phy_mask(dev, B43_LPPHY_FOURWIRE_CTL, 0xFFFD);
 	udelay(1);
 
-	if (dev->phy.rev < 2) {
+	if (dev->phy.radio_ver == 0x2062) {
 		lpphy_2062_init(dev);
 	} else {
 		lpphy_2063_init(dev);
@@ -688,11 +690,18 @@ struct lpphy_iq_est { u32 iq_prod, i_pwr, q_pwr; };
 
 static void lpphy_set_rc_cap(struct b43_wldev *dev)
 {
-	u8 rc_cap = dev->phy.lp->rc_cap;
+	struct b43_phy_lp *lpphy = dev->phy.lp;
 
-	b43_radio_write(dev, B2062_N_RXBB_CALIB2, max_t(u8, rc_cap-4, 0x80));
-	b43_radio_write(dev, B2062_N_TX_CTL_A, ((rc_cap & 0x1F) >> 1) | 0x80);
-	b43_radio_write(dev, B2062_S_RXG_CNT16, ((rc_cap & 0x1F) >> 2) | 0x80);
+	u8 rc_cap = (lpphy->rc_cap & 0x1F) >> 1;
+	
+	if (dev->phy.rev == 1) //FIXME check channel 14!
+		rc_cap = max_t(u8, rc_cap + 5, 15);
+
+	b43_radio_write(dev, B2062_N_RXBB_CALIB2,
+			max_t(u8, lpphy->rc_cap - 4, 0x80));
+	b43_radio_write(dev, B2062_N_TX_CTL_A, rc_cap | 0x80);
+	b43_radio_write(dev, B2062_S_RXG_CNT16,
+			((lpphy->rc_cap & 0x1F) >> 2) | 0x80);
 }
 
 static u8 lpphy_get_bb_mult(struct b43_wldev *dev)
@@ -1101,6 +1110,9 @@ static void lpphy_set_tx_power_control(struct b43_wldev *dev,
 	lpphy_write_tx_pctl_mode_to_hardware(dev);
 }
 
+static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
+				       unsigned int new_channel);
+
 static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
@@ -1118,11 +1130,16 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 	    old_rf2_ovr, old_rf2_ovrval, old_phy_ctl;
 	enum b43_lpphy_txpctl_mode old_txpctl;
 	u32 normal_pwr, ideal_pwr, mean_sq_pwr, tmp = 0, mean_sq_pwr_min = 0;
-	int loopback, i, j, inner_sum;
+	int loopback, i, j, inner_sum, err;
 
 	memset(&iq_est, 0, sizeof(iq_est));
 
-	b43_switch_channel(dev, 7);
+	err = b43_lpphy_op_switch_channel(dev, 7);
+	if (err) {
+		b43dbg(dev->wl,
+		       "RC calib: Failed to switch to channel 7, error = %d",
+		       err);
+	}
 	old_txg_ovr = (b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) >> 6) & 1;
 	old_bbmult = lpphy_get_bb_mult(dev);
 	if (old_txg_ovr)
@@ -1881,14 +1898,14 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
 	struct ssb_bus *bus = dev->dev->bus;
-	static const struct b206x_channel *chandata = NULL;
+	const struct b206x_channel *chandata = NULL;
 	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
 	u32 tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8, tmp9;
 	int i, err = 0;
 
-	for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
+	for (i = 0; i < ARRAY_SIZE(b2062_chantbl); i++) {
 		if (b2063_chantbl[i].channel == channel) {
-			chandata = &b2063_chantbl[i];
+			chandata = &b2062_chantbl[i];
 			break;
 		}
 	}
-- 
1.6.2.4





From netrolller.3d at gmail.com  Sun Aug 16 15:32:40 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 16 Aug 2009 15:32:40 +0200
Subject: [PATCH] b43: LP-PHY: Fix a spec error in the B2062 channel switch
	routine
Message-ID: <4A880A78.9050205@gmail.com>

The channel switch routine had a whole instruction missing. Add it.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index a51da6e..3889519 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1939,6 +1939,10 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
 	tmp5 = tmp7 * 0x100;
 	tmp6 = tmp5 / tmp4;
 	tmp7 = tmp5 % tmp4;
+	b43_radio_write(dev, B2062_S_RFPLL_CTL27, tmp6);
+	tmp5 = tmp7 * 0x100;
+	tmp6 = tmp5 / tmp4;
+	tmp7 = tmp5 % tmp4;
 	b43_radio_write(dev, B2062_S_RFPLL_CTL28, tmp6);
 	tmp5 = tmp7 * 0x100;
 	tmp6 = tmp5 / tmp4;
-- 
1.6.2.4





From mb at bu3sch.de  Sun Aug 16 15:39:57 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Aug 2009 15:39:57 +0200
Subject: [RFT] Threaded IRQ handlers for b43
Message-ID: <200908161539.57917.mb@bu3sch.de>

This request-for-test patch converts the b43 driver to use threaded
interrupt handlers. This is needed to support b43 on SDIO. But it also
simplifies the locking by removal of the wl->irq_lock spinlock.

http://bu3sch.de/patches/wireless-testing/20090816-1535/patches/002-b43-threaded-irq-handler.patch

A known regression is a new race between the interrupt handler and the
beacon update handler. But as long as you don't run AP mode, it won't hurt.
I'm working on a solution...

Please test this patch whether it creates other regressions (performance and crashes).

The patch also needs the following hack to the threaded IRQ code:
http://bu3sch.de/patches/wireless-testing/20090816-1535/patches/001-hack-threaded-irqs.patch

-- 
Greetings, Michael.


From mb at bu3sch.de  Sun Aug 16 15:42:41 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Aug 2009 15:42:41 +0200
Subject: [PATCH] b43: LP-PHY: Update code for spec fixes,
	and fix a few typos
In-Reply-To: <4A88090D.3070107@gmail.com>
References: <4A88090D.3070107@gmail.com>
Message-ID: <200908161542.41775.mb@bu3sch.de>

On Sunday 16 August 2009 15:26:37 G?bor Stefanik wrote:
> A few typos have been discovered both in the specs in and our code.
> This patch fixes them.
> 
> Also use lpphy_op_switch_channel consistently, and make all callers
> print its return value for easier debugging.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> I think using a forward declaration is justified in this case;
> as avoiding the forward decl would require moving around huge
> blocks of code, completely breaking any logical ordering.

I don't think so, but I'll ack this anyway.

-- 
Greetings, Michael.


From mb at bu3sch.de  Sun Aug 16 15:43:11 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Aug 2009 15:43:11 +0200
Subject: [PATCH] b43: LP-PHY: Fix a spec error in the B2062 channel switch
	routine
In-Reply-To: <4A880A78.9050205@gmail.com>
References: <4A880A78.9050205@gmail.com>
Message-ID: <200908161543.11499.mb@bu3sch.de>

On Sunday 16 August 2009 15:32:40 G?bor Stefanik wrote:
> The channel switch routine had a whole instruction missing. Add it.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

ack

> ---
>  drivers/net/wireless/b43/phy_lp.c |    4 ++++
>  1 files changed, 4 insertions(+), 0 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index a51da6e..3889519 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -1939,6 +1939,10 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
>  	tmp5 = tmp7 * 0x100;
>  	tmp6 = tmp5 / tmp4;
>  	tmp7 = tmp5 % tmp4;
> +	b43_radio_write(dev, B2062_S_RFPLL_CTL27, tmp6);
> +	tmp5 = tmp7 * 0x100;
> +	tmp6 = tmp5 / tmp4;
> +	tmp7 = tmp5 % tmp4;
>  	b43_radio_write(dev, B2062_S_RFPLL_CTL28, tmp6);
>  	tmp5 = tmp7 * 0x100;
>  	tmp6 = tmp5 / tmp4;



-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Mon Aug 17 04:37:50 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 16 Aug 2009 21:37:50 -0500
Subject: [PATCH] b43: LP-PHY: Update code for spec fixes, and fix a few
	typos
In-Reply-To: <4A88090D.3070107@gmail.com>
References: <4A88090D.3070107@gmail.com>
Message-ID: <4A88C27E.3030000@lwfinger.net>

G?bor Stefanik wrote:
> A few typos have been discovered both in the specs in and our code.
> This patch fixes them.
> 
> Also use lpphy_op_switch_channel consistently, and make all callers
> print its return value for easier debugging.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> I think using a forward declaration is justified in this case;
> as avoiding the forward decl would require moving around huge
> blocks of code, completely breaking any logical ordering.
> 
> drivers/net/wireless/b43/phy_lp.c |   51
> ++++++++++++++++++++++++------------
> 1 files changed, 34 insertions(+), 17 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index e4a040b..a51da6e 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -552,7 +552,7 @@ static void lpphy_2062_init(struct b43_wldev *dev)
>     B43_WARN_ON(!(bus->chipco.capabilities & SSB_CHIPCO_CAP_PMU));
>     B43_WARN_ON(crystalfreq == 0);
> 
> -    if (crystalfreq >= 30000000) {
> +    if (crystalfreq <= 30000000) {
>         lpphy->pdiv = 1;
>         b43_radio_mask(dev, B2062_S_RFPLL_CTL1, 0xFFFB);
>     } else {
> @@ -560,14 +560,16 @@ static void lpphy_2062_init(struct b43_wldev *dev)
>         b43_radio_set(dev, B2062_S_RFPLL_CTL1, 0x4);
>     }
> 
> -    tmp = (800000000 * lpphy->pdiv + crystalfreq) /
> -          (32000000 * lpphy->pdiv);
> -    tmp = (tmp - 1) & 0xFF;
> +    tmp = (((800000000 * lpphy->pdiv + crystalfreq) /
> +          (2 * crystalfreq)) - 8) & 0xFF;
> +    b43_radio_write(dev, B2062_S_RFPLL_CTL7, tmp);
> +
> +    tmp = (((100 * crystalfreq + 16000000 * lpphy->pdiv) /
> +          (32000000 * lpphy->pdiv)) - 1) & 0xFF;
>     b43_radio_write(dev, B2062_S_RFPLL_CTL18, tmp);
> 
> -    tmp = (2 * crystalfreq + 1000000 * lpphy->pdiv) /
> -          (2000000 * lpphy->pdiv);
> -    tmp = ((tmp & 0xFF) - 1) & 0xFFFF;
> +    tmp = (((2 * crystalfreq + 1000000 * lpphy->pdiv) /
> +          (2000000 * lpphy->pdiv)) - 1) & 0xFF;
>     b43_radio_write(dev, B2062_S_RFPLL_CTL19, tmp);
> 
>     ref = (1000 * lpphy->pdiv + 2 * crystalfreq) / (2000 * lpphy->pdiv);
> @@ -671,7 +673,7 @@ static void lpphy_radio_init(struct b43_wldev *dev)
>     b43_phy_mask(dev, B43_LPPHY_FOURWIRE_CTL, 0xFFFD);
>     udelay(1);
> 
> -    if (dev->phy.rev < 2) {
> +    if (dev->phy.radio_ver == 0x2062) {
>         lpphy_2062_init(dev);
>     } else {
>         lpphy_2063_init(dev);
> @@ -688,11 +690,18 @@ struct lpphy_iq_est { u32 iq_prod, i_pwr, q_pwr; };
> 
> static void lpphy_set_rc_cap(struct b43_wldev *dev)
> {
> -    u8 rc_cap = dev->phy.lp->rc_cap;
> +    struct b43_phy_lp *lpphy = dev->phy.lp;
> 
> -    b43_radio_write(dev, B2062_N_RXBB_CALIB2, max_t(u8, rc_cap-4, 0x80));
> -    b43_radio_write(dev, B2062_N_TX_CTL_A, ((rc_cap & 0x1F) >> 1) | 0x80);
> -    b43_radio_write(dev, B2062_S_RXG_CNT16, ((rc_cap & 0x1F) >> 2) |
> 0x80);
> +    u8 rc_cap = (lpphy->rc_cap & 0x1F) >> 1;
> +   
> +    if (dev->phy.rev == 1) //FIXME check channel 14!
> +        rc_cap = max_t(u8, rc_cap + 5, 15);
> +
> +    b43_radio_write(dev, B2062_N_RXBB_CALIB2,
> +            max_t(u8, lpphy->rc_cap - 4, 0x80));
> +    b43_radio_write(dev, B2062_N_TX_CTL_A, rc_cap | 0x80);
> +    b43_radio_write(dev, B2062_S_RXG_CNT16,
> +            ((lpphy->rc_cap & 0x1F) >> 2) | 0x80);
> }
> 
> static u8 lpphy_get_bb_mult(struct b43_wldev *dev)
> @@ -1101,6 +1110,9 @@ static void lpphy_set_tx_power_control(struct
> b43_wldev *dev,
>     lpphy_write_tx_pctl_mode_to_hardware(dev);
> }
> 
> +static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
> +                       unsigned int new_channel);
> +
> static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
> {
>     struct b43_phy_lp *lpphy = dev->phy.lp;
> @@ -1118,11 +1130,16 @@ static void lpphy_rev0_1_rc_calib(struct
> b43_wldev *dev)
>         old_rf2_ovr, old_rf2_ovrval, old_phy_ctl;
>     enum b43_lpphy_txpctl_mode old_txpctl;
>     u32 normal_pwr, ideal_pwr, mean_sq_pwr, tmp = 0, mean_sq_pwr_min = 0;
> -    int loopback, i, j, inner_sum;
> +    int loopback, i, j, inner_sum, err;
> 
>     memset(&iq_est, 0, sizeof(iq_est));
> 
> -    b43_switch_channel(dev, 7);
> +    err = b43_lpphy_op_switch_channel(dev, 7);
> +    if (err) {
> +        b43dbg(dev->wl,
> +               "RC calib: Failed to switch to channel 7, error = %d",
> +               err);
> +    }
>     old_txg_ovr = (b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) >> 6) & 1;
>     old_bbmult = lpphy_get_bb_mult(dev);
>     if (old_txg_ovr)
> @@ -1881,14 +1898,14 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
> {
>     struct b43_phy_lp *lpphy = dev->phy.lp;
>     struct ssb_bus *bus = dev->dev->bus;
> -    static const struct b206x_channel *chandata = NULL;
> +    const struct b206x_channel *chandata = NULL;
>     u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
>     u32 tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8, tmp9;
>     int i, err = 0;
> 
> -    for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
> +    for (i = 0; i < ARRAY_SIZE(b2062_chantbl); i++) {
>         if (b2063_chantbl[i].channel == channel) {
              -----
This should also be b2062. As long as the two tables have the same
channel ordering, this way would work.

> -            chandata = &b2063_chantbl[i];
> +            chandata = &b2062_chantbl[i];
>             break;
>         }
>     }

Larry


From netrolller.3d at gmail.com  Sun Aug 16 18:05:09 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 16 Aug 2009 18:05:09 +0200
Subject: [PATCH v2] b43: LP-PHY: Update code for spec fixes, and fix a few
	typos
Message-ID: <4A882E35.60407@gmail.com>

A few typos have been discovered in both the specs and the code.
This patch fixes them.

Also use lpphy_op_switch_channel consistently, and make all users
of it print its return value for easier debugging.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
V2: Fix one more typo (this time a harmless one).

 drivers/net/wireless/b43/phy_lp.c |   53 ++++++++++++++++++++++++------------
 1 files changed, 35 insertions(+), 18 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index d949cfa..1de4a74 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -554,7 +554,7 @@ static void lpphy_2062_init(struct b43_wldev *dev)
 	B43_WARN_ON(!(bus->chipco.capabilities & SSB_CHIPCO_CAP_PMU));
 	B43_WARN_ON(crystalfreq == 0);
 
-	if (crystalfreq >= 30000000) {
+	if (crystalfreq <= 30000000) {
 		lpphy->pdiv = 1;
 		b43_radio_mask(dev, B2062_S_RFPLL_CTL1, 0xFFFB);
 	} else {
@@ -562,14 +562,16 @@ static void lpphy_2062_init(struct b43_wldev *dev)
 		b43_radio_set(dev, B2062_S_RFPLL_CTL1, 0x4);
 	}
 
-	tmp = (800000000 * lpphy->pdiv + crystalfreq) /
-	      (32000000 * lpphy->pdiv);
-	tmp = (tmp - 1) & 0xFF;
+	tmp = (((800000000 * lpphy->pdiv + crystalfreq) /
+	      (2 * crystalfreq)) - 8) & 0xFF;
+	b43_radio_write(dev, B2062_S_RFPLL_CTL7, tmp);
+
+	tmp = (((100 * crystalfreq + 16000000 * lpphy->pdiv) /
+	      (32000000 * lpphy->pdiv)) - 1) & 0xFF;
 	b43_radio_write(dev, B2062_S_RFPLL_CTL18, tmp);
 
-	tmp = (2 * crystalfreq + 1000000 * lpphy->pdiv) /
-	      (2000000 * lpphy->pdiv);
-	tmp = ((tmp & 0xFF) - 1) & 0xFFFF;
+	tmp = (((2 * crystalfreq + 1000000 * lpphy->pdiv) /
+	      (2000000 * lpphy->pdiv)) - 1) & 0xFF;
 	b43_radio_write(dev, B2062_S_RFPLL_CTL19, tmp);
 
 	ref = (1000 * lpphy->pdiv + 2 * crystalfreq) / (2000 * lpphy->pdiv);
@@ -673,7 +675,7 @@ static void lpphy_radio_init(struct b43_wldev *dev)
 	b43_phy_mask(dev, B43_LPPHY_FOURWIRE_CTL, 0xFFFD);
 	udelay(1);
 
-	if (dev->phy.rev < 2) {
+	if (dev->phy.radio_ver == 0x2062) {
 		lpphy_2062_init(dev);
 	} else {
 		lpphy_2063_init(dev);
@@ -690,11 +692,18 @@ struct lpphy_iq_est { u32 iq_prod, i_pwr, q_pwr; };
 
 static void lpphy_set_rc_cap(struct b43_wldev *dev)
 {
-	u8 rc_cap = dev->phy.lp->rc_cap;
+	struct b43_phy_lp *lpphy = dev->phy.lp;
 
-	b43_radio_write(dev, B2062_N_RXBB_CALIB2, max_t(u8, rc_cap-4, 0x80));
-	b43_radio_write(dev, B2062_N_TX_CTL_A, ((rc_cap & 0x1F) >> 1) | 0x80);
-	b43_radio_write(dev, B2062_S_RXG_CNT16, ((rc_cap & 0x1F) >> 2) | 0x80);
+	u8 rc_cap = (lpphy->rc_cap & 0x1F) >> 1;
+	
+	if (dev->phy.rev == 1) //FIXME check channel 14!
+		rc_cap = max_t(u8, rc_cap + 5, 15);
+
+	b43_radio_write(dev, B2062_N_RXBB_CALIB2,
+			max_t(u8, lpphy->rc_cap - 4, 0x80));
+	b43_radio_write(dev, B2062_N_TX_CTL_A, rc_cap | 0x80);
+	b43_radio_write(dev, B2062_S_RXG_CNT16,
+			((lpphy->rc_cap & 0x1F) >> 2) | 0x80);
 }
 
 static u8 lpphy_get_bb_mult(struct b43_wldev *dev)
@@ -1103,6 +1112,9 @@ static void lpphy_set_tx_power_control(struct b43_wldev *dev,
 	lpphy_write_tx_pctl_mode_to_hardware(dev);
 }
 
+static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
+				       unsigned int new_channel);
+
 static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
@@ -1120,11 +1132,16 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 	    old_rf2_ovr, old_rf2_ovrval, old_phy_ctl;
 	enum b43_lpphy_txpctl_mode old_txpctl;
 	u32 normal_pwr, ideal_pwr, mean_sq_pwr, tmp = 0, mean_sq_pwr_min = 0;
-	int loopback, i, j, inner_sum;
+	int loopback, i, j, inner_sum, err;
 
 	memset(&iq_est, 0, sizeof(iq_est));
 
-	b43_switch_channel(dev, 7);
+	err = b43_lpphy_op_switch_channel(dev, 7);
+	if (err) {
+		b43dbg(dev->wl,
+		       "RC calib: Failed to switch to channel 7, error = %d",
+		       err);
+	}
 	old_txg_ovr = (b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) >> 6) & 1;
 	old_bbmult = lpphy_get_bb_mult(dev);
 	if (old_txg_ovr)
@@ -1883,14 +1900,14 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
 	struct ssb_bus *bus = dev->dev->bus;
-	static const struct b206x_channel *chandata = NULL;
+	const struct b206x_channel *chandata = NULL;
 	u32 crystal_freq = bus->chipco.pmu.crystalfreq * 1000;
 	u32 tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8, tmp9;
 	int i, err = 0;
 
-	for (i = 0; i < ARRAY_SIZE(b2063_chantbl); i++) {
-		if (b2063_chantbl[i].channel == channel) {
-			chandata = &b2063_chantbl[i];
+	for (i = 0; i < ARRAY_SIZE(b2062_chantbl); i++) {
+		if (b2062_chantbl[i].channel == channel) {
+			chandata = &b2062_chantbl[i];
 			break;
 		}
 	}
-- 
1.6.2.4





From netrolller.3d at gmail.com  Sun Aug 16 18:40:09 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 16 Aug 2009 18:40:09 +0200
Subject: [PATCH] b43: LP-PHY: Fix a bug in the B2062 channel tune path
Message-ID: <4A883669.6010504@gmail.com>

I missed the "+16" part of the instruction in the specs.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 1de4a74..5a7b873 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1952,7 +1952,7 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
 	b43_radio_write(dev, B2062_S_RFPLL_CTL29, tmp6 + ((2 * tmp7) / tmp4));
 	tmp8 = b43_phy_read(dev, B2062_S_RFPLL_CTL19);
 	tmp9 = ((2 * tmp3 * (tmp8 + 1)) + (3 * tmp1)) / (6 * tmp1);
-	b43_radio_write(dev, B2062_S_RFPLL_CTL23, tmp9 >> 8);
+	b43_radio_write(dev, B2062_S_RFPLL_CTL23, (tmp9 >> 8) + 16);
 	b43_radio_write(dev, B2062_S_RFPLL_CTL24, tmp9 & 0xFF);
 	
 	lpphy_b2062_vco_calib(dev);
-- 
1.6.2.4





From netrolller.3d at gmail.com  Sun Aug 16 18:42:51 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 16 Aug 2009 18:42:51 +0200
Subject: [PATCH] b43: LP-PHY: Remove BROKEN from B43_PHY_LP
Message-ID: <4A88370B.5090506@gmail.com>

Larry has reported success getting scan data with an LP-PHY device,
so it's probably time to release LP-PHY support for testing.

Also add a temporary BROKEN Kconfig symbol to disable 5GHz support,
as 5GHz currently causes the driver to panic (NULL pointer deref).

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/Kconfig  |   25 +++++++++++++++++++------
 drivers/net/wireless/b43/main.c   |    2 ++
 drivers/net/wireless/b43/phy_lp.c |    2 ++
 3 files changed, 23 insertions(+), 6 deletions(-)

diff --git a/drivers/net/wireless/b43/Kconfig b/drivers/net/wireless/b43/Kconfig
index 67f564e..13414c9 100644
--- a/drivers/net/wireless/b43/Kconfig
+++ b/drivers/net/wireless/b43/Kconfig
@@ -80,16 +80,29 @@ config B43_NPHY
 	  SAY N.
 
 config B43_PHY_LP
-	bool "IEEE 802.11g LP-PHY support (BROKEN)"
-	depends on B43 && EXPERIMENTAL && BROKEN
+	bool "Support for low-power (LP-PHY) devices (VERY EXPERIMENTAL)"
+	depends on B43 && EXPERIMENTAL
 	---help---
 	  Support for the LP-PHY.
-	  The LP-PHY is an IEEE 802.11g based PHY built into some notebooks
-	  and embedded devices.
+	  The LP-PHY is a low-power PHY built into some notebooks
+	  and embedded devices. It supports 802.11a/g
+	  (802.11a support is optional, and currently disabled).
 
-	  THIS IS BROKEN AND DOES NOT WORK YET.
+	  Known LP-PHY devices include the BCM4310, BCM4312 (PCI ID 0x4315),
+	  BCM4325 (currently unsupported), BCM4326 & BCM4328 wireless cards
+	  and the BCM5354 SoC.
 
-	  SAY N.
+	  This is heavily experimental, and probably will not work for you.
+	  Say N unless you want to help debug the driver.
+
+config B43_PHY_LP_5GHZ
+	bool "Enable 802.11a support for LP-PHYs (BROKEN)"
+	depends on B43_PHY_LP && BROKEN
+	---help---
+	  Enable the 5GHz band of LP-PHY devices. Currently, all it
+	  does is cause the driver to panic on startup.
+
+	  Only select this if you are a developer working on this feature.
 
 # This config option automatically enables b43 LEDS support,
 # if it's possible.
diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index 99b41ce..0096d25 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -4514,7 +4514,9 @@ static int b43_wireless_core_attach(struct b43_wldev *dev)
 			have_5ghz_phy = 1;
 			break;
 		case B43_PHYTYPE_LP: //FIXME not always!
+#ifdef CONFIG_B43_PHY_LP_5GHZ
 			have_5ghz_phy = 1;
+#endif
 		case B43_PHYTYPE_G:
 		case B43_PHYTYPE_N:
 			have_2ghz_phy = 1;
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 3889519..c902dd1 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -43,7 +43,9 @@ static inline u16 channel2freq_lp(u8 channel)
 
 static unsigned int b43_lpphy_op_get_default_chan(struct b43_wldev *dev)
 {
+#ifdef CONFIG_B43_PHY_LP_5GHZ
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+#endif
 		return 1;
 	return 36;
 }
-- 
1.6.2.4





From mb at bu3sch.de  Sun Aug 16 19:50:23 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Aug 2009 19:50:23 +0200
Subject: [PATCH] b43: LP-PHY: Remove BROKEN from B43_PHY_LP
In-Reply-To: <4A88370B.5090506@gmail.com>
References: <4A88370B.5090506@gmail.com>
Message-ID: <200908161950.24270.mb@bu3sch.de>

On Sunday 16 August 2009 18:42:51 G?bor Stefanik wrote:
> Larry has reported success getting scan data with an LP-PHY device,
> so it's probably time to release LP-PHY support for testing.
> 
> Also add a temporary BROKEN Kconfig symbol to disable 5GHz support,
> as 5GHz currently causes the driver to panic (NULL pointer deref).
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
>  drivers/net/wireless/b43/Kconfig  |   25 +++++++++++++++++++------
>  drivers/net/wireless/b43/main.c   |    2 ++
>  drivers/net/wireless/b43/phy_lp.c |    2 ++
>  3 files changed, 23 insertions(+), 6 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/Kconfig b/drivers/net/wireless/b43/Kconfig
> index 67f564e..13414c9 100644
> --- a/drivers/net/wireless/b43/Kconfig
> +++ b/drivers/net/wireless/b43/Kconfig
> @@ -80,16 +80,29 @@ config B43_NPHY
>  	  SAY N.
>  
>  config B43_PHY_LP
> -	bool "IEEE 802.11g LP-PHY support (BROKEN)"
> -	depends on B43 && EXPERIMENTAL && BROKEN
> +	bool "Support for low-power (LP-PHY) devices (VERY EXPERIMENTAL)"

Very is a vague term. Just remove it.

> +	depends on B43 && EXPERIMENTAL
>  	---help---
>  	  Support for the LP-PHY.
> -	  The LP-PHY is an IEEE 802.11g based PHY built into some notebooks
> -	  and embedded devices.
> +	  The LP-PHY is a low-power PHY built into some notebooks
> +	  and embedded devices. It supports 802.11a/g
> +	  (802.11a support is optional, and currently disabled).
>  
> -	  THIS IS BROKEN AND DOES NOT WORK YET.
> +	  Known LP-PHY devices include the BCM4310, BCM4312 (PCI ID 0x4315),
> +	  BCM4325 (currently unsupported), BCM4326 & BCM4328 wireless cards
> +	  and the BCM5354 SoC.

It's pointless to list them here, as the list will always be obsolete and never be correct.

>  
> -	  SAY N.
> +	  This is heavily experimental, and probably will not work for you.
> +	  Say N unless you want to help debug the driver.
> +
> +config B43_PHY_LP_5GHZ
> +	bool "Enable 802.11a support for LP-PHYs (BROKEN)"
> +	depends on B43_PHY_LP && BROKEN
> +	---help---
> +	  Enable the 5GHz band of LP-PHY devices. Currently, all it
> +	  does is cause the driver to panic on startup.
> +
> +	  Only select this if you are a developer working on this feature.

I don't think we should introduce another config option. Just hardcode
disable the 802.11a for LP-PHYs. There's no point in enabling an option
that crashes the kernel. And if you fix the crash, there's no point in
leaving it disabled.

>  # This config option automatically enables b43 LEDS support,
>  # if it's possible.
> diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
> index 99b41ce..0096d25 100644
> --- a/drivers/net/wireless/b43/main.c
> +++ b/drivers/net/wireless/b43/main.c
> @@ -4514,7 +4514,9 @@ static int b43_wireless_core_attach(struct b43_wldev *dev)
>  			have_5ghz_phy = 1;
>  			break;
>  		case B43_PHYTYPE_LP: //FIXME not always!
> +#ifdef CONFIG_B43_PHY_LP_5GHZ
>  			have_5ghz_phy = 1;
> +#endif
>  		case B43_PHYTYPE_G:
>  		case B43_PHYTYPE_N:
>  			have_2ghz_phy = 1;
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index 3889519..c902dd1 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -43,7 +43,9 @@ static inline u16 channel2freq_lp(u8 channel)
>  
>  static unsigned int b43_lpphy_op_get_default_chan(struct b43_wldev *dev)
>  {
> +#ifdef CONFIG_B43_PHY_LP_5GHZ
>  	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
> +#endif
>  		return 1;
>  	return 36;
>  }

This is a completely pointless ifdef.



-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Sun Aug 16 20:08:13 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 16 Aug 2009 20:08:13 +0200
Subject: [PATCH] b43: LP-PHY: Update B2062 radio init with recent spec changes
Message-ID: <4A884B0D.5000808@gmail.com>

The spec for initializing the B2062 radio have changed recently,
update the code to match the changes.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 5a7b873..34b7910 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -539,10 +539,15 @@ static void lpphy_2062_init(struct b43_wldev *dev)
 	b43_radio_write(dev, B2062_N_TX_CTL3, 0);
 	b43_radio_write(dev, B2062_N_TX_CTL4, 0);
 	b43_radio_write(dev, B2062_N_TX_CTL5, 0);
+	b43_radio_write(dev, B2062_N_TX_CTL6, 0);
 	b43_radio_write(dev, B2062_N_PDN_CTL0, 0x40);
 	b43_radio_write(dev, B2062_N_PDN_CTL0, 0);
 	b43_radio_write(dev, B2062_N_CALIB_TS, 0x10);
 	b43_radio_write(dev, B2062_N_CALIB_TS, 0);
+	if (dev->phy.rev > 0) {
+		b43_radio_write(dev, B2062_S_BG_CTL1,
+			(b43_radio_read(dev, B2062_N_COMM2) >> 1) | 0x80);
+	}
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
 		b43_radio_set(dev, B2062_N_TSSI_CTL0, 0x1);
 	else
-- 
1.6.2.4





From mb at bu3sch.de  Sun Aug 16 20:09:34 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Aug 2009 20:09:34 +0200
Subject: [PATCH] b43: LP-PHY: Update B2062 radio init with recent spec
	changes
In-Reply-To: <4A884B0D.5000808@gmail.com>
References: <4A884B0D.5000808@gmail.com>
Message-ID: <200908162009.34744.mb@bu3sch.de>

On Sunday 16 August 2009 20:08:13 G?bor Stefanik wrote:
> The spec for initializing the B2062 radio have changed recently,
> update the code to match the changes.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

ack

> ---
>  drivers/net/wireless/b43/phy_lp.c |    5 +++++
>  1 files changed, 5 insertions(+), 0 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index 5a7b873..34b7910 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -539,10 +539,15 @@ static void lpphy_2062_init(struct b43_wldev *dev)
>  	b43_radio_write(dev, B2062_N_TX_CTL3, 0);
>  	b43_radio_write(dev, B2062_N_TX_CTL4, 0);
>  	b43_radio_write(dev, B2062_N_TX_CTL5, 0);
> +	b43_radio_write(dev, B2062_N_TX_CTL6, 0);
>  	b43_radio_write(dev, B2062_N_PDN_CTL0, 0x40);
>  	b43_radio_write(dev, B2062_N_PDN_CTL0, 0);
>  	b43_radio_write(dev, B2062_N_CALIB_TS, 0x10);
>  	b43_radio_write(dev, B2062_N_CALIB_TS, 0);
> +	if (dev->phy.rev > 0) {
> +		b43_radio_write(dev, B2062_S_BG_CTL1,
> +			(b43_radio_read(dev, B2062_N_COMM2) >> 1) | 0x80);
> +	}
>  	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
>  		b43_radio_set(dev, B2062_N_TSSI_CTL0, 0x1);
>  	else



-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Sun Aug 16 20:22:41 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 16 Aug 2009 20:22:41 +0200
Subject: [PATCH v2] b43: LP-PHY: Remove BROKEN from B43_PHY_LP
Message-ID: <4A884E71.6070202@gmail.com>

Larry has reported success getting scan data with an LP-PHY device,
so it's probably time to release LP-PHY support for testing.

Also disable 802.11a support for now, as 802.11a currently causes
the driver to panic on startup (NULL pointer dereference).

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
V2:
-Remove "VERY" from the warning in the symbol name.
-Remove list of known devices.
-Don't create a separate symbol for 5GHz, just disable it in the code.

 drivers/net/wireless/b43/Kconfig |   14 +++++++-------
 drivers/net/wireless/b43/main.c  |    2 ++
 2 files changed, 9 insertions(+), 7 deletions(-)

diff --git a/drivers/net/wireless/b43/Kconfig b/drivers/net/wireless/b43/Kconfig
index 67f564e..237b1aa 100644
--- a/drivers/net/wireless/b43/Kconfig
+++ b/drivers/net/wireless/b43/Kconfig
@@ -80,16 +80,16 @@ config B43_NPHY
 	  SAY N.
 
 config B43_PHY_LP
-	bool "IEEE 802.11g LP-PHY support (BROKEN)"
-	depends on B43 && EXPERIMENTAL && BROKEN
+	bool "Support for low-power (LP-PHY) devices (EXPERIMENTAL)"
+	depends on B43 && EXPERIMENTAL
 	---help---
 	  Support for the LP-PHY.
-	  The LP-PHY is an IEEE 802.11g based PHY built into some notebooks
-	  and embedded devices.
-
-	  THIS IS BROKEN AND DOES NOT WORK YET.
+	  The LP-PHY is a low-power PHY built into some notebooks
+	  and embedded devices. It supports 802.11a/g
+	  (802.11a support is optional, and currently disabled).
 
-	  SAY N.
+	  This is heavily experimental, and probably will not work for you.
+	  Say N unless you want to help debug the driver.
 
 # This config option automatically enables b43 LEDS support,
 # if it's possible.
diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index 99b41ce..c5bece0 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -4514,7 +4514,9 @@ static int b43_wireless_core_attach(struct b43_wldev *dev)
 			have_5ghz_phy = 1;
 			break;
 		case B43_PHYTYPE_LP: //FIXME not always!
+#if 0 //FIXME enabling 5GHz causes a NULL pointer dereference
 			have_5ghz_phy = 1;
+#endif
 		case B43_PHYTYPE_G:
 		case B43_PHYTYPE_N:
 			have_2ghz_phy = 1;
-- 
1.6.2.4





From mb at bu3sch.de  Sun Aug 16 20:28:01 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Aug 2009 20:28:01 +0200
Subject: [PATCH v2] b43: LP-PHY: Remove BROKEN from B43_PHY_LP
In-Reply-To: <4A884E71.6070202@gmail.com>
References: <4A884E71.6070202@gmail.com>
Message-ID: <200908162028.01984.mb@bu3sch.de>

On Sunday 16 August 2009 20:22:41 G?bor Stefanik wrote:
> Larry has reported success getting scan data with an LP-PHY device,
> so it's probably time to release LP-PHY support for testing.
> 
> Also disable 802.11a support for now, as 802.11a currently causes
> the driver to panic on startup (NULL pointer dereference).
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

ack

> ---
> V2:
> -Remove "VERY" from the warning in the symbol name.
> -Remove list of known devices.
> -Don't create a separate symbol for 5GHz, just disable it in the code.
> 
>  drivers/net/wireless/b43/Kconfig |   14 +++++++-------
>  drivers/net/wireless/b43/main.c  |    2 ++
>  2 files changed, 9 insertions(+), 7 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/Kconfig b/drivers/net/wireless/b43/Kconfig
> index 67f564e..237b1aa 100644
> --- a/drivers/net/wireless/b43/Kconfig
> +++ b/drivers/net/wireless/b43/Kconfig
> @@ -80,16 +80,16 @@ config B43_NPHY
>  	  SAY N.
>  
>  config B43_PHY_LP
> -	bool "IEEE 802.11g LP-PHY support (BROKEN)"
> -	depends on B43 && EXPERIMENTAL && BROKEN
> +	bool "Support for low-power (LP-PHY) devices (EXPERIMENTAL)"
> +	depends on B43 && EXPERIMENTAL
>  	---help---
>  	  Support for the LP-PHY.
> -	  The LP-PHY is an IEEE 802.11g based PHY built into some notebooks
> -	  and embedded devices.
> -
> -	  THIS IS BROKEN AND DOES NOT WORK YET.
> +	  The LP-PHY is a low-power PHY built into some notebooks
> +	  and embedded devices. It supports 802.11a/g
> +	  (802.11a support is optional, and currently disabled).
>  
> -	  SAY N.
> +	  This is heavily experimental, and probably will not work for you.
> +	  Say N unless you want to help debug the driver.
>  
>  # This config option automatically enables b43 LEDS support,
>  # if it's possible.
> diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
> index 99b41ce..c5bece0 100644
> --- a/drivers/net/wireless/b43/main.c
> +++ b/drivers/net/wireless/b43/main.c
> @@ -4514,7 +4514,9 @@ static int b43_wireless_core_attach(struct b43_wldev *dev)
>  			have_5ghz_phy = 1;
>  			break;
>  		case B43_PHYTYPE_LP: //FIXME not always!
> +#if 0 //FIXME enabling 5GHz causes a NULL pointer dereference
>  			have_5ghz_phy = 1;
> +#endif
>  		case B43_PHYTYPE_G:
>  		case B43_PHYTYPE_N:
>  			have_2ghz_phy = 1;



-- 
Greetings, Michael.


From mb at bu3sch.de  Mon Aug 17 13:48:04 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 17 Aug 2009 13:48:04 +0200
Subject: [RFT] Threaded IRQ handlers for b43
In-Reply-To: <200908161539.57917.mb@bu3sch.de>
References: <200908161539.57917.mb@bu3sch.de>
Message-ID: <200908171348.04399.mb@bu3sch.de>

On Sunday 16 August 2009 15:39:57 Michael Buesch wrote:
> This request-for-test patch converts the b43 driver to use threaded
> interrupt handlers. This is needed to support b43 on SDIO. But it also
> simplifies the locking by removal of the wl->irq_lock spinlock.
> 
> http://bu3sch.de/patches/wireless-testing/20090816-1535/patches/002-b43-threaded-irq-handler.patch
> 
> A known regression is a new race between the interrupt handler and the
> beacon update handler. But as long as you don't run AP mode, it won't hurt.
> I'm working on a solution...
> 
> Please test this patch whether it creates other regressions (performance and crashes).
> 
> The patch also needs the following hack to the threaded IRQ code:
> http://bu3sch.de/patches/wireless-testing/20090816-1535/patches/001-hack-threaded-irqs.patch
> 

This is the correct fix for the threaded IRQ code. Apply this instead of the hack:
http://bu3sch.de/patches/wireless-testing/20090817-1347/patches/001-fix-irq-thread-wakeup.patch

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Mon Aug 17 21:32:42 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 17 Aug 2009 21:32:42 +0200
Subject: [PATCH] b43: LP-PHY: Fix setting TX power control mode during RC 
	calibration
In-Reply-To: <4A85B8DE.3000704@gmail.com>
References: <4A85B8DE.3000704@gmail.com>
Message-ID: <69e28c910908171232i6828d42bh3aac1d236f789c91@mail.gmail.com>

2009/8/14 G?bor Stefanik <netrolller.3d at gmail.com>:
> Call set_tx_power_control with a LPPHY_TXPCTL rather than an
> LPPHY_TX_PWR_CTL_CMD_MODE.
>
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> This should fix the WARN_ON testers were seeing during init.
>
> drivers/net/wireless/b43/phy_lp.c | ? ?2 +-
> 1 files changed, 1 insertions(+), 1 deletions(-)
>
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index adfa7bf..558224b 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -1080,7 +1080,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> *dev)
> ? ? ? ?old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?B43_LPPHY_TX_PWR_CTL_CMD_MODE;
>
> - ? ? ? lpphy_set_tx_power_control(dev, B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
> + ? ? ? lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
> ? ? ? ?lpphy_disable_crs(dev);
> ? ? ? ?loopback = lpphy_loopback(dev);
> ? ? ? ?if (loopback == -1)
> --
> 1.6.2.4
>

John, any news on this one? I can't see it in wireless testing.

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Mon Aug 17 21:33:06 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 17 Aug 2009 21:33:06 +0200
Subject: [PATCH] b43: LP-PHY: Fix reading old mode in the set TX power 
	control routine
In-Reply-To: <4A85AD1B.1060008@gmail.com>
References: <4A85AD1B.1060008@gmail.com>
Message-ID: <69e28c910908171233l75b4f72cq8981fb048ad8ffbb@mail.gmail.com>

2009/8/14 G?bor Stefanik <netrolller.3d at gmail.com>:
> Check the mode the hardware is in, not the mode we used the last time.
>
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> Mark, please test if this fixes the TX power control WARN_ON you were
> seeing.
>
> drivers/net/wireless/b43/phy_lp.c | ? ?4 ++--
> 1 files changed, 2 insertions(+), 2 deletions(-)
>
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index 292ee51..76457f7 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -1015,9 +1015,9 @@ static void lpphy_set_tx_power_control(struct
> b43_wldev *dev,
> ? ? ? ?struct b43_phy_lp *lpphy = dev->phy.lp;
> ? ? ? ?enum b43_lpphy_txpctl_mode oldmode;
>
> - ? ? ? oldmode = lpphy->txpctl_mode;
> ? ? ? ?lpphy_read_tx_pctl_mode_from_hardware(dev);
> - ? ? ? if (lpphy->txpctl_mode == mode)
> + ? ? ? oldmode = lpphy->txpctl_mode;
> + ? ? ? if (oldmode == mode)
> ? ? ? ? ? ? ? ?return;
> ? ? ? ?lpphy->txpctl_mode = mode;
>
> --
> 1.6.2.4
>

John, any news on this one? I can't see it in wireless testing.

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From linville at tuxdriver.com  Mon Aug 17 21:57:19 2009
From: linville at tuxdriver.com (John W. Linville)
Date: Mon, 17 Aug 2009 15:57:19 -0400
Subject: [PATCH] b43: LP-PHY: Fix setting TX power control mode during
	RC calibration
In-Reply-To: <69e28c910908171232i6828d42bh3aac1d236f789c91@mail.gmail.com>
References: <4A85B8DE.3000704@gmail.com>
	<69e28c910908171232i6828d42bh3aac1d236f789c91@mail.gmail.com>
Message-ID: <20090817195718.GK5500@tuxdriver.com>

On Mon, Aug 17, 2009 at 09:32:42PM +0200, G?bor Stefanik wrote:
> 2009/8/14 G?bor Stefanik <netrolller.3d at gmail.com>:
> > Call set_tx_power_control with a LPPHY_TXPCTL rather than an
> > LPPHY_TX_PWR_CTL_CMD_MODE.
> >
> > Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> > ---
> > This should fix the WARN_ON testers were seeing during init.
> >
> > drivers/net/wireless/b43/phy_lp.c | ? ?2 +-
> > 1 files changed, 1 insertions(+), 1 deletions(-)
> >
> > diff --git a/drivers/net/wireless/b43/phy_lp.c
> > b/drivers/net/wireless/b43/phy_lp.c
> > index adfa7bf..558224b 100644
> > --- a/drivers/net/wireless/b43/phy_lp.c
> > +++ b/drivers/net/wireless/b43/phy_lp.c
> > @@ -1080,7 +1080,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> > *dev)
> > ? ? ? ?old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
> > ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?B43_LPPHY_TX_PWR_CTL_CMD_MODE;
> >
> > - ? ? ? lpphy_set_tx_power_control(dev, B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
> > + ? ? ? lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
> > ? ? ? ?lpphy_disable_crs(dev);
> > ? ? ? ?loopback = lpphy_loopback(dev);
> > ? ? ? ?if (loopback == -1)
> > --
> > 1.6.2.4
> >
> 
> John, any news on this one? I can't see it in wireless testing.

Larry said:

With this one, I still get WARNING: at
drivers/net/wireless/b43/phy_lp.c:1006
lpphy_set_tx_power_control+0xbf/0xdd [b43]().

-- 
John W. Linville		Someday the world will need a hero, and you
linville at tuxdriver.com			might be all we have.  Be ready.


From linville at tuxdriver.com  Mon Aug 17 21:56:07 2009
From: linville at tuxdriver.com (John W. Linville)
Date: Mon, 17 Aug 2009 15:56:07 -0400
Subject: [PATCH] b43: LP-PHY: Fix reading old mode in the set TX power
	control routine
In-Reply-To: <69e28c910908171233l75b4f72cq8981fb048ad8ffbb@mail.gmail.com>
References: <4A85AD1B.1060008@gmail.com>
	<69e28c910908171233l75b4f72cq8981fb048ad8ffbb@mail.gmail.com>
Message-ID: <20090817195607.GJ5500@tuxdriver.com>

On Mon, Aug 17, 2009 at 09:33:06PM +0200, G?bor Stefanik wrote:
> 2009/8/14 G?bor Stefanik <netrolller.3d at gmail.com>:
> > Check the mode the hardware is in, not the mode we used the last time.
> >
> > Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> > ---
> > Mark, please test if this fixes the TX power control WARN_ON you were
> > seeing.
> >
> > drivers/net/wireless/b43/phy_lp.c | ? ?4 ++--
> > 1 files changed, 2 insertions(+), 2 deletions(-)
> >
> > diff --git a/drivers/net/wireless/b43/phy_lp.c
> > b/drivers/net/wireless/b43/phy_lp.c
> > index 292ee51..76457f7 100644
> > --- a/drivers/net/wireless/b43/phy_lp.c
> > +++ b/drivers/net/wireless/b43/phy_lp.c
> > @@ -1015,9 +1015,9 @@ static void lpphy_set_tx_power_control(struct
> > b43_wldev *dev,
> > ? ? ? ?struct b43_phy_lp *lpphy = dev->phy.lp;
> > ? ? ? ?enum b43_lpphy_txpctl_mode oldmode;
> >
> > - ? ? ? oldmode = lpphy->txpctl_mode;
> > ? ? ? ?lpphy_read_tx_pctl_mode_from_hardware(dev);
> > - ? ? ? if (lpphy->txpctl_mode == mode)
> > + ? ? ? oldmode = lpphy->txpctl_mode;
> > + ? ? ? if (oldmode == mode)
> > ? ? ? ? ? ? ? ?return;
> > ? ? ? ?lpphy->txpctl_mode = mode;
> >
> > --
> > 1.6.2.4
> >
> 
> John, any news on this one? I can't see it in wireless testing.

Larry said "It does not fix it here. I'll take a look at the specs"...

-- 
John W. Linville		Someday the world will need a hero, and you
linville at tuxdriver.com			might be all we have.  Be ready.


From netrolller.3d at gmail.com  Mon Aug 17 22:02:14 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 17 Aug 2009 22:02:14 +0200
Subject: [PATCH] b43: LP-PHY: Fix setting TX power control mode during RC 
	calibration
In-Reply-To: <20090817195718.GK5500@tuxdriver.com>
References: <4A85B8DE.3000704@gmail.com>
	<69e28c910908171232i6828d42bh3aac1d236f789c91@mail.gmail.com> 
	<20090817195718.GK5500@tuxdriver.com>
Message-ID: <69e28c910908171302s3aed3181w38ba402ca7dfa13d@mail.gmail.com>

2009/8/17 John W. Linville <linville at tuxdriver.com>:
> On Mon, Aug 17, 2009 at 09:32:42PM +0200, G?bor Stefanik wrote:
>> 2009/8/14 G?bor Stefanik <netrolller.3d at gmail.com>:
>> > Call set_tx_power_control with a LPPHY_TXPCTL rather than an
>> > LPPHY_TX_PWR_CTL_CMD_MODE.
>> >
>> > Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> > ---
>> > This should fix the WARN_ON testers were seeing during init.
>> >
>> > drivers/net/wireless/b43/phy_lp.c | ? ?2 +-
>> > 1 files changed, 1 insertions(+), 1 deletions(-)
>> >
>> > diff --git a/drivers/net/wireless/b43/phy_lp.c
>> > b/drivers/net/wireless/b43/phy_lp.c
>> > index adfa7bf..558224b 100644
>> > --- a/drivers/net/wireless/b43/phy_lp.c
>> > +++ b/drivers/net/wireless/b43/phy_lp.c
>> > @@ -1080,7 +1080,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>> > *dev)
>> > ? ? ? ?old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
>> > ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?B43_LPPHY_TX_PWR_CTL_CMD_MODE;
>> >
>> > - ? ? ? lpphy_set_tx_power_control(dev, B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
>> > + ? ? ? lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
>> > ? ? ? ?lpphy_disable_crs(dev);
>> > ? ? ? ?loopback = lpphy_loopback(dev);
>> > ? ? ? ?if (loopback == -1)
>> > --
>> > 1.6.2.4
>> >
>>
>> John, any news on this one? I can't see it in wireless testing.
>
> Larry said:
>
> With this one, I still get WARNING: at
> drivers/net/wireless/b43/phy_lp.c:1006
> lpphy_set_tx_power_control+0xbf/0xdd [b43]().
>

Previously, he was getting 2 warnings. This fixes one of them, the
other one is handled by commit
1181d724fc2897f11f95bf6ebc86ae111390929c ("Fix another TX power
control abuse").

> --
> John W. Linville ? ? ? ? ? ? ? ?Someday the world will need a hero, and you
> linville at tuxdriver.com ? ? ? ? ? ? ? ? ?might be all we have. ?Be ready.
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Mon Aug 17 22:03:16 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 17 Aug 2009 22:03:16 +0200
Subject: [PATCH] b43: LP-PHY: Fix reading old mode in the set TX power 
	control routine
In-Reply-To: <20090817195607.GJ5500@tuxdriver.com>
References: <4A85AD1B.1060008@gmail.com>
	<69e28c910908171233l75b4f72cq8981fb048ad8ffbb@mail.gmail.com> 
	<20090817195607.GJ5500@tuxdriver.com>
Message-ID: <69e28c910908171303m69a575f0kad6e32592d3184ea@mail.gmail.com>

2009/8/17 John W. Linville <linville at tuxdriver.com>:
> On Mon, Aug 17, 2009 at 09:33:06PM +0200, G?bor Stefanik wrote:
>> 2009/8/14 G?bor Stefanik <netrolller.3d at gmail.com>:
>> > Check the mode the hardware is in, not the mode we used the last time.
>> >
>> > Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> > ---
>> > Mark, please test if this fixes the TX power control WARN_ON you were
>> > seeing.
>> >
>> > drivers/net/wireless/b43/phy_lp.c | ? ?4 ++--
>> > 1 files changed, 2 insertions(+), 2 deletions(-)
>> >
>> > diff --git a/drivers/net/wireless/b43/phy_lp.c
>> > b/drivers/net/wireless/b43/phy_lp.c
>> > index 292ee51..76457f7 100644
>> > --- a/drivers/net/wireless/b43/phy_lp.c
>> > +++ b/drivers/net/wireless/b43/phy_lp.c
>> > @@ -1015,9 +1015,9 @@ static void lpphy_set_tx_power_control(struct
>> > b43_wldev *dev,
>> > ? ? ? ?struct b43_phy_lp *lpphy = dev->phy.lp;
>> > ? ? ? ?enum b43_lpphy_txpctl_mode oldmode;
>> >
>> > - ? ? ? oldmode = lpphy->txpctl_mode;
>> > ? ? ? ?lpphy_read_tx_pctl_mode_from_hardware(dev);
>> > - ? ? ? if (lpphy->txpctl_mode == mode)
>> > + ? ? ? oldmode = lpphy->txpctl_mode;
>> > + ? ? ? if (oldmode == mode)
>> > ? ? ? ? ? ? ? ?return;
>> > ? ? ? ?lpphy->txpctl_mode = mode;
>> >
>> > --
>> > 1.6.2.4
>> >
>>
>> John, any news on this one? I can't see it in wireless testing.
>
> Larry said "It does not fix it here. I'll take a look at the specs"...

It did not fix the warning, but it is nevertheless a legitimate fix.
(I found this bug when I was looking for the source of the WARN_ON -
this is not the source of the WARN_ON, but still a bug.)

>
> --
> John W. Linville ? ? ? ? ? ? ? ?Someday the world will need a hero, and you
> linville at tuxdriver.com ? ? ? ? ? ? ? ? ?might be all we have. ?Be ready.
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From Larry.Finger at lwfinger.net  Mon Aug 17 23:17:54 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 17 Aug 2009 16:17:54 -0500
Subject: [PATCH] b43: LP-PHY: Fix setting TX power control mode during
	RC 	calibration
In-Reply-To: <69e28c910908171302s3aed3181w38ba402ca7dfa13d@mail.gmail.com>
References: <4A85B8DE.3000704@gmail.com>
	<69e28c910908171232i6828d42bh3aac1d236f789c91@mail.gmail.com>
	<20090817195718.GK5500@tuxdriver.com>
	<69e28c910908171302s3aed3181w38ba402ca7dfa13d@mail.gmail.com>
Message-ID: <4A89C902.4030807@lwfinger.net>

G?bor Stefanik wrote:
> 2009/8/17 John W. Linville <linville at tuxdriver.com>:
>> On Mon, Aug 17, 2009 at 09:32:42PM +0200, G?bor Stefanik wrote:
>>> 2009/8/14 G?bor Stefanik <netrolller.3d at gmail.com>:
>>>> Call set_tx_power_control with a LPPHY_TXPCTL rather than an
>>>> LPPHY_TX_PWR_CTL_CMD_MODE.
>>>>
>>>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>>>> ---
>>>> This should fix the WARN_ON testers were seeing during init.
>>>>
>>>> drivers/net/wireless/b43/phy_lp.c |    2 +-
>>>> 1 files changed, 1 insertions(+), 1 deletions(-)
>>>>
>>>> diff --git a/drivers/net/wireless/b43/phy_lp.c
>>>> b/drivers/net/wireless/b43/phy_lp.c
>>>> index adfa7bf..558224b 100644
>>>> --- a/drivers/net/wireless/b43/phy_lp.c
>>>> +++ b/drivers/net/wireless/b43/phy_lp.c
>>>> @@ -1080,7 +1080,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>>>> *dev)
>>>>        old_txpctl = b43_phy_read(dev, B43_LPPHY_TX_PWR_CTL_CMD) &
>>>>                                        B43_LPPHY_TX_PWR_CTL_CMD_MODE;
>>>>
>>>> -       lpphy_set_tx_power_control(dev, B43_LPPHY_TX_PWR_CTL_CMD_MODE_OFF);
>>>> +       lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
>>>>        lpphy_disable_crs(dev);
>>>>        loopback = lpphy_loopback(dev);
>>>>        if (loopback == -1)
>>>> --
>>>> 1.6.2.4
>>>>
>>> John, any news on this one? I can't see it in wireless testing.
>> Larry said:
>>
>> With this one, I still get WARNING: at
>> drivers/net/wireless/b43/phy_lp.c:1006
>> lpphy_set_tx_power_control+0xbf/0xdd [b43]().
>>
> 
> Previously, he was getting 2 warnings. This fixes one of them, the
> other one is handled by commit
> 1181d724fc2897f11f95bf6ebc86ae111390929c ("Fix another TX power
> control abuse").
> 

I need to be more careful with my comments. This pack is needed and
OK. Because of my involvement with the RE, I cannot ack any of these
LP PHY patches.

Larry


From Larry.Finger at lwfinger.net  Mon Aug 17 23:18:54 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 17 Aug 2009 16:18:54 -0500
Subject: [PATCH] b43: LP-PHY: Fix reading old mode in the set TX power
	control routine
In-Reply-To: <69e28c910908171303m69a575f0kad6e32592d3184ea@mail.gmail.com>
References: <4A85AD1B.1060008@gmail.com>
	<69e28c910908171233l75b4f72cq8981fb048ad8ffbb@mail.gmail.com>
	<20090817195607.GJ5500@tuxdriver.com>
	<69e28c910908171303m69a575f0kad6e32592d3184ea@mail.gmail.com>
Message-ID: <4A89C93E.8070705@lwfinger.net>

G?bor Stefanik wrote:
> 2009/8/17 John W. Linville <linville at tuxdriver.com>:
>> On Mon, Aug 17, 2009 at 09:33:06PM +0200, G?bor Stefanik wrote:
>>> 2009/8/14 G?bor Stefanik <netrolller.3d at gmail.com>:
>>>> Check the mode the hardware is in, not the mode we used the last time.
>>>>
>>>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>>>> ---
>>>> Mark, please test if this fixes the TX power control WARN_ON you were
>>>> seeing.
>>>>
>>>> drivers/net/wireless/b43/phy_lp.c |    4 ++--
>>>> 1 files changed, 2 insertions(+), 2 deletions(-)
>>>>
>>>> diff --git a/drivers/net/wireless/b43/phy_lp.c
>>>> b/drivers/net/wireless/b43/phy_lp.c
>>>> index 292ee51..76457f7 100644
>>>> --- a/drivers/net/wireless/b43/phy_lp.c
>>>> +++ b/drivers/net/wireless/b43/phy_lp.c
>>>> @@ -1015,9 +1015,9 @@ static void lpphy_set_tx_power_control(struct
>>>> b43_wldev *dev,
>>>>        struct b43_phy_lp *lpphy = dev->phy.lp;
>>>>        enum b43_lpphy_txpctl_mode oldmode;
>>>>
>>>> -       oldmode = lpphy->txpctl_mode;
>>>>        lpphy_read_tx_pctl_mode_from_hardware(dev);
>>>> -       if (lpphy->txpctl_mode == mode)
>>>> +       oldmode = lpphy->txpctl_mode;
>>>> +       if (oldmode == mode)
>>>>                return;
>>>>        lpphy->txpctl_mode = mode;
>>>>
>>>> --
>>>> 1.6.2.4
>>>>
>>> John, any news on this one? I can't see it in wireless testing.
>> Larry said "It does not fix it here. I'll take a look at the specs"...
> 
> It did not fix the warning, but it is nevertheless a legitimate fix.
> (I found this bug when I was looking for the source of the WARN_ON -
> this is not the source of the WARN_ON, but still a bug.)

This patch is OK.

Larry


From mb at bu3sch.de  Tue Aug 18 15:12:56 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 18 Aug 2009 15:12:56 +0200
Subject: [PATCH] b43: Fix sparse warnings
In-Reply-To: <1250541041.10511.10.camel@mj>
References: <4a84906b.+IYGhiNLKPSjrrR7%Larry.Finger@lwfinger.net>
	<200908151204.11024.mb@bu3sch.de> <1250541041.10511.10.camel@mj>
Message-ID: <200908181512.56841.mb@bu3sch.de>

On Monday 17 August 2009 22:30:41 Pavel Roskin wrote:
> On Sat, 2009-08-15 at 12:04 +0200, Michael Buesch wrote:
> 
> > I still do not understand why it does complain about an _explicit_ truncation.
> > That's simply stupid. If I program an explicit truncation I _do_ mean to truncate the value.
> 
> Actually, it's a bug in sparse.  Sparse acts inconsistently.
> 
> This causes a warning:
> 
> void mask(unsigned short mask);
> static void test(void)
> {
>         mask((unsigned short)0xffff0000);
> }
> 
> test.c:4:30: warning: cast truncates bits from constant value (ffff0000
> becomes 0)
> 
> But this is OK:
> 
> void mask(unsigned short mask);
> static void test(void)
> {
>         mask((unsigned short)0xfffff000);
> }
> 
> Moreover, this is OK, even though the cast changes the value of the
> constant:
> 
> void mask(unsigned short mask);
> static void test(void)
> {
>         mask((unsigned short)0xfffff000U);
> }
> 
> I suggest that we take no action until sparse is fixed.  I'm going to
> report the issue to the sparse mailing list now.
> 

Cool, thanks a lot for tracking this down. :)

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Tue Aug 18 19:18:13 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Tue, 18 Aug 2009 19:18:13 +0200
Subject: [PATCH] b43: LP-PHY: Implement spec updates and remove resolved FIXMEs
Message-ID: <4A8AE255.9030102@gmail.com>

Larry has started re-checking all current routines against a new
version of the Broadcom MIPS driver. This patch implements the first
round of changes he documented on the specs wiki.

Also remove a few FIXMEs regarding missing initial values for variables
with dynamic initial values where reading the values has been implemented.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c       |   98 +++++++++++++++++++------------
 drivers/net/wireless/b43/phy_lp.h       |   18 +++---
 drivers/net/wireless/b43/tables_lpphy.c |   12 ++++-
 3 files changed, 82 insertions(+), 46 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 242338f..6c69cdb 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -719,9 +719,39 @@ static void lpphy_set_bb_mult(struct b43_wldev *dev, u8 bb_mult)
 	b43_lptab_write(dev, B43_LPTAB16(0, 87), (u16)bb_mult << 8);
 }
 
-static void lpphy_disable_crs(struct b43_wldev *dev)
+static void lpphy_set_deaf(struct b43_wldev *dev, bool user)
 {
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+
+	if (user)
+		lpphy->crs_usr_disable = 1;
+	else
+		lpphy->crs_sys_disable = 1;
 	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x80);
+}
+
+static void lpphy_clear_deaf(struct b43_wldev *dev, bool user)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+
+	if (user)
+		lpphy->crs_usr_disable = 0;
+	else
+		lpphy->crs_sys_disable = 0;
+
+	if (!lpphy->crs_usr_disable && !lpphy->crs_sys_disable) {
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
+			b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL,
+					0xFF1F, 0x60);
+		else
+			b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL,
+					0xFF1F, 0x20);
+	}
+}
+
+static void lpphy_disable_crs(struct b43_wldev *dev, bool user)
+{
+	lpphy_set_deaf(dev, user);
 	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x1);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
 	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
@@ -749,12 +779,9 @@ static void lpphy_disable_crs(struct b43_wldev *dev)
 	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0x3FF);
 }
 
-static void lpphy_restore_crs(struct b43_wldev *dev)
+static void lpphy_restore_crs(struct b43_wldev *dev, bool user)
 {
-	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
-		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x60);
-	else
-		b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x20);
+	lpphy_clear_deaf(dev, user);
 	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFF80);
 	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFC00);
 }
@@ -800,10 +827,11 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
 		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
 				0xF800, rf_gain);
 	} else {
-		pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x7F00;
+		pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x1FC0;
+		pa_gain <<= 2;
 		b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
 			      (gains.pga << 8) | gains.gm);
-		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+		b43_phy_maskset(dev, B43_PHY_OFDM(0xFB),
 				0x8000, gains.pad | pa_gain);
 		b43_phy_write(dev, B43_PHY_OFDM(0xFC),
 			      (gains.pga << 8) | gains.gm);
@@ -817,7 +845,7 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
 		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1 << 7);
 		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1 << 14);
 	}
-	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFBF, 1 << 6);
+	b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFBF, 1 << 6);
 }
 
 static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
@@ -857,33 +885,33 @@ static void lpphy_rev2plus_set_rx_gain(struct b43_wldev *dev, u32 gain)
 	}
 }
 
-static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
+static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
 {
 	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
 	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
 	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
 	if (dev->phy.rev >= 2) {
 		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
-		if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
-			return;
-		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
-		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFF7);
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
+			b43_phy_mask(dev, B43_PHY_OFDM(0xE5), 0xFFF7);
+		}
 	} else {
 		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
 	}
 }
 
-static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
+static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
 {
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
 	if (dev->phy.rev >= 2) {
 		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
-		if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
-			return;
-		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
-		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x8);
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
+			b43_phy_set(dev, B43_PHY_OFDM(0xE5), 0x8);
+		}
 	} else {
 		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
 	}
@@ -1002,26 +1030,22 @@ static u32 lpphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
 {
 	u32 quotient, remainder, rbit, roundup, tmp;
 
-	if (divisor == 0) {
-		quotient = 0;
-		remainder = 0;
-	} else {
-		quotient = dividend / divisor;
-		remainder = dividend % divisor;
-	}
+	if (divisor == 0)
+		return 0;
+
+	quotient = dividend / divisor;
+	remainder = dividend % divisor;
 
 	rbit = divisor & 0x1;
 	roundup = (divisor >> 1) + rbit;
-	precision--;
 
-	while (precision != 0xFF) {
+	while (precision != 0) {
 		tmp = remainder - roundup;
 		quotient <<= 1;
-		remainder <<= 1;
-		if (remainder >= roundup) {
+		if (remainder >= roundup)
 			remainder = (tmp << 1) + rbit;
-			quotient--;
-		}
+		else
+			remainder <<= 1;
 		precision--;
 	}
 
@@ -1123,11 +1147,11 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 	struct b43_phy_lp *lpphy = dev->phy.lp;
 	struct lpphy_iq_est iq_est;
 	struct lpphy_tx_gains tx_gains;
-	static const u32 ideal_pwr_table[22] = {
+	static const u32 ideal_pwr_table[21] = {
 		0x10000, 0x10557, 0x10e2d, 0x113e0, 0x10f22, 0x0ff64,
 		0x0eda2, 0x0e5d4, 0x0efd1, 0x0fbe8, 0x0b7b8, 0x04b35,
 		0x01a5e, 0x00a0b, 0x00444, 0x001fd, 0x000ff, 0x00088,
-		0x0004c, 0x0002c, 0x0001a, 0xc0006,
+		0x0004c, 0x0002c, 0x0001a,
 	};
 	bool old_txg_ovr;
 	u8 old_bbmult;
@@ -1145,7 +1169,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 		       "RC calib: Failed to switch to channel 7, error = %d",
 		       err);
 	}
-	old_txg_ovr = (b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) >> 6) & 1;
+	old_txg_ovr = !!(b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40);
 	old_bbmult = lpphy_get_bb_mult(dev);
 	if (old_txg_ovr)
 		tx_gains = lpphy_get_tx_gains(dev);
@@ -1160,7 +1184,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 	old_txpctl = lpphy->txpctl_mode;
 
 	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
-	lpphy_disable_crs(dev);
+	lpphy_disable_crs(dev, true);
 	loopback = lpphy_loopback(dev);
 	if (loopback == -1)
 		goto finish;
@@ -1193,7 +1217,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 	lpphy_stop_ddfs(dev);
 
 finish:
-	lpphy_restore_crs(dev);
+	lpphy_restore_crs(dev, true);
 	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, old_rf_ovrval);
 	b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_0, old_rf_ovr);
 	b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVRVAL, old_afe_ovrval);
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index 99cb038..e158d1f 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -825,11 +825,11 @@ struct b43_phy_lp {
 	enum b43_lpphy_txpctl_mode txpctl_mode;
 
 	/* Transmit isolation medium band */
-	u8 tx_isolation_med_band; /* FIXME initial value? */
+	u8 tx_isolation_med_band;
 	/* Transmit isolation low band */
-	u8 tx_isolation_low_band; /* FIXME initial value? */
+	u8 tx_isolation_low_band;
 	/* Transmit isolation high band */
-	u8 tx_isolation_hi_band; /* FIXME initial value? */
+	u8 tx_isolation_hi_band;
 
 	/* Max transmit power medium band */
 	u16 max_tx_pwr_med_band;
@@ -848,7 +848,7 @@ struct b43_phy_lp {
 	s16 txpa[3], txpal[3], txpah[3];
 
 	/* Receive power offset */
-	u8 rx_pwr_offset; /* FIXME initial value? */
+	u8 rx_pwr_offset;
 
 	/* TSSI transmit count */
 	u16 tssi_tx_count;
@@ -864,16 +864,16 @@ struct b43_phy_lp {
 	s8 tx_pwr_idx_over; /* FIXME initial value? */
 
 	/* RSSI vf */
-	u8 rssi_vf; /* FIXME initial value? */
+	u8 rssi_vf;
 	/* RSSI vc */
-	u8 rssi_vc; /* FIXME initial value? */
+	u8 rssi_vc;
 	/* RSSI gs */
-	u8 rssi_gs; /* FIXME initial value? */
+	u8 rssi_gs;
 
 	/* RC cap */
 	u8 rc_cap; /* FIXME initial value? */
 	/* BX arch */
-	u8 bx_arch; /* FIXME initial value? */
+	u8 bx_arch;
 
 	/* Full calibration channel */
 	u8 full_calib_chan; /* FIXME initial value? */
@@ -885,6 +885,8 @@ struct b43_phy_lp {
 	/* Used for "Save/Restore Dig Filt State" */
 	u16 dig_flt_state[9];
 
+	bool crs_usr_disable, crs_sys_disable;
+
 	unsigned int pdiv;
 };
 
diff --git a/drivers/net/wireless/b43/tables_lpphy.c b/drivers/net/wireless/b43/tables_lpphy.c
index 2721310..60d472f 100644
--- a/drivers/net/wireless/b43/tables_lpphy.c
+++ b/drivers/net/wireless/b43/tables_lpphy.c
@@ -2367,7 +2367,17 @@ static void lpphy_rev2plus_write_gain_table(struct b43_wldev *dev, int offset,
 	tmp  = data.pad << 16;
 	tmp |= data.pga << 8;
 	tmp |= data.gm;
-	tmp |= 0x7f000000;
+	if (dev->phy.rev >= 3) {
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)
+			tmp |= 0x10 << 24;
+		else
+			tmp |= 0x70 << 24;
+	} else {
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)
+			tmp |= 0x14 << 24;
+		else
+			tmp |= 0x7F << 24;
+	}
 	b43_lptab_write(dev, B43_LPTAB32(7, 0xC0 + offset), tmp);
 	tmp  = data.bb_mult << 20;
 	tmp |= data.dac << 28;
-- 
1.6.2.4





From netrolller.3d at gmail.com  Tue Aug 18 22:08:31 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Tue, 18 Aug 2009 22:08:31 +0200
Subject: [PATCH] b43: LP-PHY: Two small spec updates
Message-ID: <4A8B0A3F.6040106@gmail.com>

The specs are beginning to support rev3 LP-PHYs - implement one of
the changes needed for rev3 support.
Also, in the new MIPS driver, the "Japan TX filter" was renamed to
"analog TX filter init" - however, calling it "init" is confusing,
so name it "set analog filter", with a comment for easier future
identification.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |   17 ++++++++++++-----
 1 files changed, 12 insertions(+), 5 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 6c69cdb..65f0010 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -609,9 +609,14 @@ static void lpphy_2063_init(struct b43_wldev *dev)
 	b43_radio_write(dev, B2063_PA_SP7, 0);
 	b43_radio_write(dev, B2063_TX_RF_SP6, 0x20);
 	b43_radio_write(dev, B2063_TX_RF_SP9, 0x40);
-	b43_radio_write(dev, B2063_PA_SP3, 0xa0);
-	b43_radio_write(dev, B2063_PA_SP4, 0xa0);
-	b43_radio_write(dev, B2063_PA_SP2, 0x18);
+	if (dev->phy.rev == 2) {
+		b43_radio_write(dev, B2063_PA_SP3, 0xa0);
+		b43_radio_write(dev, B2063_PA_SP4, 0xa0);
+		b43_radio_write(dev, B2063_PA_SP2, 0x18);
+	} else {
+		b43_radio_write(dev, B2063_PA_SP3, 0x20);
+		b43_radio_write(dev, B2063_PA_SP2, 0x20);
+	}
 }
 
 struct lpphy_stx_table_entry {
@@ -1996,7 +2001,9 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
 	return err;
 }
 
-static void lpphy_japan_filter(struct b43_wldev *dev, int channel)
+
+/* This was previously called lpphy_japan_filter */
+static void lpphy_set_analog_filter(struct b43_wldev *dev, int channel)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
 	u16 tmp = (channel == 14); //SPEC FIXME check japanwidefilter!
@@ -2165,7 +2172,7 @@ static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
 		err = lpphy_b2062_tune(dev, new_channel);
 		if (err)
 			return err;
-		lpphy_japan_filter(dev, new_channel);
+		lpphy_set_analog_filter(dev, new_channel);
 		lpphy_adjust_gain_table(dev, channel2freq_lp(new_channel));
 	}
 
-- 
1.6.2.4





From netrolller.3d at gmail.com  Tue Aug 18 22:29:25 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Tue, 18 Aug 2009 22:29:25 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) now ready for testing!
Message-ID: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>

Hello World!

Great news for Broadcom BCM4310/4312/4315 (PCI 14e4:4315) users:
LP-PHY support is now at the point where it can be tested for functionality!

There are still problems with channel switching (a few patches ago,
only 802.11b/g channels 7 and 8 were working - no tests have been
performed since then) & TX is untested, but Larry has reported that he
can get scan results from channels 7 and 8. He doesn't have any AP on
these channels, so can't test if association works, but it should be
working too. It's also possible that recent patches have fixed the
channel switching bug, as the codepaths for channel switching have
been touched extensively, probably fixing a major miscalculation issue
("Qdiv roundup" was completely wrong).

So, go ahead, give it a try, and let's rock!

Note that the code in wireless-testing is enough to start testing,
however it's recommended that you apply the following 2 pending fixes:
http://marc.info/?l=linux-wireless&m=125061590101156&w=2 and
http://marc.info/?l=linux-wireless&m=125062611720517&w=2

Tomorrow's compat-wireless tarball, together with the above patches,
should also be good for testing. Not sure about today's tarball.

--G?bor

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mcgrof at gmail.com  Wed Aug 19 01:41:20 2009
From: mcgrof at gmail.com (Luis R. Rodriguez)
Date: Tue, 18 Aug 2009 16:41:20 -0700
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) now ready for 
	testing!
In-Reply-To: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>
Message-ID: <43e72e890908181641s2455e7f1me9b4d3bc277f197e@mail.gmail.com>

2009/8/18 G?bor Stefanik <netrolller.3d at gmail.com>:
> Hello World!
>
> Great news for Broadcom BCM4310/4312/4315 (PCI 14e4:4315) users:
> LP-PHY support is now at the point where it can be tested for functionality!

Hey great stuff :)

> There are still problems with channel switching (a few patches ago,
> only 802.11b/g channels 7 and 8 were working - no tests have been
> performed since then) & TX is untested, but Larry has reported that he
> can get scan results from channels 7 and 8. He doesn't have any AP on
> these channels, so can't test if association works, but it should be
> working too. It's also possible that recent patches have fixed the
> channel switching bug, as the codepaths for channel switching have
> been touched extensively, probably fixing a major miscalculation issue
> ("Qdiv roundup" was completely wrong).
>
> So, go ahead, give it a try, and let's rock!
>
> Note that the code in wireless-testing is enough to start testing,
> however it's recommended that you apply the following 2 pending fixes:
> http://marc.info/?l=linux-wireless&m=125061590101156&w=2 and
> http://marc.info/?l=linux-wireless&m=125062611720517&w=2
>
> Tomorrow's compat-wireless tarball, together with the above patches,
> should also be good for testing. Not sure about today's tarball.

Except CONFIG_B43_PHY_LP was not enabled on compat-wireless. But now
it is. I kicked the cronjob and enabled CONFIG_B43_PHY_LP on
config.mk, please report any issues.

http://wireless.kernel.org/en/users/Download/

BTW I think it would be nice for those users looking only for b43 for
us to update scripts/driver-select to have b43 as just one driver
option. Should be easy to add but I don't have time right now. Patch
is greatly welcomed though.

  Luis


From mcgrof at gmail.com  Wed Aug 19 01:42:41 2009
From: mcgrof at gmail.com (Luis R. Rodriguez)
Date: Tue, 18 Aug 2009 16:42:41 -0700
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) now ready for 
	testing!
In-Reply-To: <43e72e890908181641s2455e7f1me9b4d3bc277f197e@mail.gmail.com>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com> 
	<43e72e890908181641s2455e7f1me9b4d3bc277f197e@mail.gmail.com>
Message-ID: <43e72e890908181642t1c11e4aah95b52e878b3e583e@mail.gmail.com>

2009/8/18 Luis R. Rodriguez <mcgrof at gmail.com>:
> 2009/8/18 G?bor Stefanik <netrolller.3d at gmail.com>:
>> Hello World!
>>
>> Great news for Broadcom BCM4310/4312/4315 (PCI 14e4:4315) users:
>> LP-PHY support is now at the point where it can be tested for functionality!
>
> Hey great stuff :)
>
>> There are still problems with channel switching (a few patches ago,
>> only 802.11b/g channels 7 and 8 were working - no tests have been
>> performed since then) & TX is untested, but Larry has reported that he
>> can get scan results from channels 7 and 8. He doesn't have any AP on
>> these channels, so can't test if association works, but it should be
>> working too. It's also possible that recent patches have fixed the
>> channel switching bug, as the codepaths for channel switching have
>> been touched extensively, probably fixing a major miscalculation issue
>> ("Qdiv roundup" was completely wrong).
>>
>> So, go ahead, give it a try, and let's rock!
>>
>> Note that the code in wireless-testing is enough to start testing,
>> however it's recommended that you apply the following 2 pending fixes:
>> http://marc.info/?l=linux-wireless&m=125061590101156&w=2 and
>> http://marc.info/?l=linux-wireless&m=125062611720517&w=2
>>
>> Tomorrow's compat-wireless tarball, together with the above patches,
>> should also be good for testing. Not sure about today's tarball.
>
> Except CONFIG_B43_PHY_LP was not enabled on compat-wireless. But now
> it is. I kicked the cronjob and enabled CONFIG_B43_PHY_LP on
> config.mk, please report any issues.
>
> http://wireless.kernel.org/en/users/Download/


Oh and I forgot the release info:

Origin remote URL:
git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-testing.git
git-describe for wireless-testing.git says: v2.6.31-rc6-31586-g80289f0
This is a bleeding edge compat-wireless release based on: master-2009-08-18
This is compat-release: master-2009-08-18

  Luis


From mark.sf.net at huijgen.tk  Wed Aug 19 10:42:42 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Wed, 19 Aug 2009 10:42:42 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) now ready for
	testing!
In-Reply-To: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>
Message-ID: <4A8BBB02.4020203@huijgen.tk>

G?bor Stefanik wrote:
> Hello World!
>
> Great news for Broadcom BCM4310/4312/4315 (PCI 14e4:4315) users:
> LP-PHY support is now at the point where it can be tested for functionality!
>
> So, go ahead, give it a try, and let's rock!
>   
Patches applied, well manually, cause I wasn't able to extract a working
version from the emails or the weblink provided. Whats the recommended
method to apply these git patches on mailinglists?

Here goes:

# modprobe b43 verbose=3
[ 1596.228088] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor
0x4243)
[ 1596.228100] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F,
vendor 0x4243)
[ 1596.228110] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)
[ 1596.228120] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)
[ 1596.248050] ssb: Found rev 1 PMU (capabilities 0x02A62F01)
[ 1596.256780] ssb: SPROM revision 8 detected.
[ 1596.276093] ssb: Sonics Silicon Backplane found on PCI device
0000:10:00.0
[ 1596.281108] b43-phy2: Broadcom 4312 WLAN found (core revision 15)
[ 1596.324046] b43-phy2 debug: Found PHY: Analog 6, Type 5, Revision 1
[ 1596.324060] b43-phy2 debug: Found Radio: Manuf 0x17F, Version 0x2062,
Revision 2
[ 1596.348233] phy2: Selected rate control algorithm 'minstrel'
[ 1596.348349] Broadcom 43xx driver loaded [ Features: PL, Firmware-ID:
FW13 ]

# ifconfig wlan0 up
SIOCSIFFLAGS: Input/output error

[ 1689.356055] b43 ssb0:0: firmware: requesting b43/ucode15.fw
[ 1689.703918] b43 ssb0:0: firmware: requesting b43/lp0initvals15.fw
[ 1689.710418] b43 ssb0:0: firmware: requesting b43/lp0bsinitvals15.fw
[ 1689.852058] b43-phy2: Loading firmware version 410.2160 (2007-05-26
15:32:10)
[ 1689.854963] b43-phy2 debug: b2062: Using crystal tab entry 19200 kHz.
[ 1689.855468] b43-phy2 debug: RC calib: Failed to switch to channel 7,
error = -5
[ 1689.860016] b43-phy2 debug: Switch to init channel failed, error = -5.
[ 1689.860543] b43-phy2 ERROR: PHY init: Channel switch to default failed

Interface is not coming up, so cannot scan:
# iwlist wlan0 scan
wlan0     Interface doesn't support scanning : Network is down


# iwconfig wlan0
wlan0     IEEE 802.11bg  Mode:Managed  Access Point: Not-Associated
          Tx-Power=0 dBm
          Retry  long limit:7   RTS thr:off   Fragment thr:off
          Encryption key:off
          Power Management:off

# iw dev wlan0 info
Interface wlan0
        ifindex 5
        type managed

# iw phy phy2 info
Wiphy phy2
        Band 1:
                Frequencies:
                        * 2412 MHz [1] (27.0 dBm)
                        * 2417 MHz [2] (27.0 dBm)
                        * 2422 MHz [3] (27.0 dBm)
                        * 2427 MHz [4] (27.0 dBm)
                        * 2432 MHz [5] (27.0 dBm)
                        * 2437 MHz [6] (27.0 dBm)
                        * 2442 MHz [7] (27.0 dBm)
                        * 2447 MHz [8] (27.0 dBm)
                        * 2452 MHz [9] (27.0 dBm)
                        * 2457 MHz [10] (27.0 dBm)
                        * 2462 MHz [11] (27.0 dBm)
                        * 2467 MHz [12] (disabled)
                        * 2472 MHz [13] (disabled)
                        * 2484 MHz [14] (disabled)
                Bitrates (non-HT):
                        * 1.0 Mbps
                        * 2.0 Mbps (short preamble supported)
                        * 5.5 Mbps (short preamble supported)
                        * 11.0 Mbps (short preamble supported)
                        * 6.0 Mbps
                        * 9.0 Mbps
                        * 12.0 Mbps
                        * 18.0 Mbps
                        * 24.0 Mbps
                        * 36.0 Mbps
                        * 48.0 Mbps
                        * 54.0 Mbps
        max # scan SSIDs: 4
        Supported interface modes:
                 * IBSS
                 * managed
                 * AP
                 * AP/VLAN
                 * WDS
                 * monitor
                 * mesh point





From netrolller.3d at gmail.com  Wed Aug 19 13:28:47 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Wed, 19 Aug 2009 13:28:47 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) now ready for 
	testing!
In-Reply-To: <4A8BBB02.4020203@huijgen.tk>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com> 
	<4A8BBB02.4020203@huijgen.tk>
Message-ID: <69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com>

2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
> G?bor Stefanik wrote:
>> Hello World!
>>
>> Great news for Broadcom BCM4310/4312/4315 (PCI 14e4:4315) users:
>> LP-PHY support is now at the point where it can be tested for functionality!
>>
>> So, go ahead, give it a try, and let's rock!
>>
> Patches applied, well manually, cause I wasn't able to extract a working
> version from the emails or the weblink provided. Whats the recommended
> method to apply these git patches on mailinglists?
>
> Here goes:
>
> # modprobe b43 verbose=3
> [ 1596.228088] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor
> 0x4243)
> [ 1596.228100] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F,
> vendor 0x4243)
> [ 1596.228110] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)
> [ 1596.228120] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)
> [ 1596.248050] ssb: Found rev 1 PMU (capabilities 0x02A62F01)
> [ 1596.256780] ssb: SPROM revision 8 detected.
> [ 1596.276093] ssb: Sonics Silicon Backplane found on PCI device
> 0000:10:00.0
> [ 1596.281108] b43-phy2: Broadcom 4312 WLAN found (core revision 15)
> [ 1596.324046] b43-phy2 debug: Found PHY: Analog 6, Type 5, Revision 1
> [ 1596.324060] b43-phy2 debug: Found Radio: Manuf 0x17F, Version 0x2062,
> Revision 2
> [ 1596.348233] phy2: Selected rate control algorithm 'minstrel'
> [ 1596.348349] Broadcom 43xx driver loaded [ Features: PL, Firmware-ID:
> FW13 ]
>
> # ifconfig wlan0 up
> SIOCSIFFLAGS: Input/output error
>
> [ 1689.356055] b43 ssb0:0: firmware: requesting b43/ucode15.fw
> [ 1689.703918] b43 ssb0:0: firmware: requesting b43/lp0initvals15.fw
> [ 1689.710418] b43 ssb0:0: firmware: requesting b43/lp0bsinitvals15.fw
> [ 1689.852058] b43-phy2: Loading firmware version 410.2160 (2007-05-26
> 15:32:10)
> [ 1689.854963] b43-phy2 debug: b2062: Using crystal tab entry 19200 kHz.
> [ 1689.855468] b43-phy2 debug: RC calib: Failed to switch to channel 7,
> error = -5
> [ 1689.860016] b43-phy2 debug: Switch to init channel failed, error = -5.

Hmm, error -5 is EIO, which in the channel switch code is used to
represent "PLL charge pump out of range". This is specifically the
error I was trying to fix... could you try without the 2 extra
patches? Maybe I did something wrong. (Without the 2 patches, channels
1..6 and 9..11 (12...14 not tested) throw this error, but channels 7
and 8 work.)

Also try extracting firmware from
ftp://downloads.netgear.com/files/GPL/WNDR3300-V1.0.29_gpl_src.zip's
wl_apsta.o file (newer than the one on mirror.openwrt.org - you may
need to add the extraction defines to fwcutter first; there is a
script in the fwcutter git tree, probably also in tarballs, that
generates extraction lists.) This is the firmware the specs are
written for; it's possible that the current firmware is simply not
good for LP-PHY (or maybe it needs code based on older specs).

> [ 1689.860543] b43-phy2 ERROR: PHY init: Channel switch to default failed
>
> Interface is not coming up, so cannot scan:
> # iwlist wlan0 scan
> wlan0 ? ? Interface doesn't support scanning : Network is down

When testing mac80211 drivers, always use "iw dev wlan0 scan", not
"iwlist wlan0 scan". (Though this shouldn't affect your results in
this case.)

Try bringing up the interface in monitor mode.
Also, try changing get_default_chan to return 7 instead of 1.

>
>
> # iwconfig wlan0
> wlan0 ? ? IEEE 802.11bg ?Mode:Managed ?Access Point: Not-Associated
> ? ? ? ? ?Tx-Power=0 dBm
> ? ? ? ? ?Retry ?long limit:7 ? RTS thr:off ? Fragment thr:off
> ? ? ? ? ?Encryption key:off
> ? ? ? ? ?Power Management:off
>
> # iw dev wlan0 info
> Interface wlan0
> ? ? ? ?ifindex 5
> ? ? ? ?type managed
>
> # iw phy phy2 info
> Wiphy phy2
> ? ? ? ?Band 1:
> ? ? ? ? ? ? ? ?Frequencies:
> ? ? ? ? ? ? ? ? ? ? ? ?* 2412 MHz [1] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2417 MHz [2] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2422 MHz [3] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2427 MHz [4] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2432 MHz [5] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2437 MHz [6] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2442 MHz [7] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2447 MHz [8] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2452 MHz [9] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2457 MHz [10] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2462 MHz [11] (27.0 dBm)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2467 MHz [12] (disabled)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2472 MHz [13] (disabled)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2484 MHz [14] (disabled)
> ? ? ? ? ? ? ? ?Bitrates (non-HT):
> ? ? ? ? ? ? ? ? ? ? ? ?* 1.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 2.0 Mbps (short preamble supported)
> ? ? ? ? ? ? ? ? ? ? ? ?* 5.5 Mbps (short preamble supported)
> ? ? ? ? ? ? ? ? ? ? ? ?* 11.0 Mbps (short preamble supported)
> ? ? ? ? ? ? ? ? ? ? ? ?* 6.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 9.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 12.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 18.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 24.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 36.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 48.0 Mbps
> ? ? ? ? ? ? ? ? ? ? ? ?* 54.0 Mbps
> ? ? ? ?max # scan SSIDs: 4
> ? ? ? ?Supported interface modes:
> ? ? ? ? ? ? ? ? * IBSS
> ? ? ? ? ? ? ? ? * managed
> ? ? ? ? ? ? ? ? * AP
> ? ? ? ? ? ? ? ? * AP/VLAN
> ? ? ? ? ? ? ? ? * WDS
> ? ? ? ? ? ? ? ? * monitor
> ? ? ? ? ? ? ? ? * mesh point
>
>
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Wed Aug 19 13:30:01 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Wed, 19 Aug 2009 13:30:01 +0200
Subject: [PATCH] b43: LP-PHY: Implement spec updates and remove resolved 
	FIXMEs
In-Reply-To: <4A8AE255.9030102@gmail.com>
References: <4A8AE255.9030102@gmail.com>
Message-ID: <69e28c910908190430x5223cf6al460e8008c36c3111@mail.gmail.com>

John, please hold off this patch for now, it appears to be causing
regressions. I will investigate this.

2009/8/18 G?bor Stefanik <netrolller.3d at gmail.com>:
> Larry has started re-checking all current routines against a new
> version of the Broadcom MIPS driver. This patch implements the first
> round of changes he documented on the specs wiki.
>
> Also remove a few FIXMEs regarding missing initial values for variables
> with dynamic initial values where reading the values has been implemented.
>
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> drivers/net/wireless/b43/phy_lp.c ? ? ? | ? 98
> +++++++++++++++++++------------
> drivers/net/wireless/b43/phy_lp.h ? ? ? | ? 18 +++---
> drivers/net/wireless/b43/tables_lpphy.c | ? 12 ++++-
> 3 files changed, 82 insertions(+), 46 deletions(-)
>
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index 242338f..6c69cdb 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -719,9 +719,39 @@ static void lpphy_set_bb_mult(struct b43_wldev *dev, u8
> bb_mult)
> ? ? ? ?b43_lptab_write(dev, B43_LPTAB16(0, 87), (u16)bb_mult << 8);
> }
>
> -static void lpphy_disable_crs(struct b43_wldev *dev)
> +static void lpphy_set_deaf(struct b43_wldev *dev, bool user)
> {
> + ? ? ? struct b43_phy_lp *lpphy = dev->phy.lp;
> +
> + ? ? ? if (user)
> + ? ? ? ? ? ? ? lpphy->crs_usr_disable = 1;
> + ? ? ? else
> + ? ? ? ? ? ? ? lpphy->crs_sys_disable = 1;
> ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x80);
> +}
> +
> +static void lpphy_clear_deaf(struct b43_wldev *dev, bool user)
> +{
> + ? ? ? struct b43_phy_lp *lpphy = dev->phy.lp;
> +
> + ? ? ? if (user)
> + ? ? ? ? ? ? ? lpphy->crs_usr_disable = 0;
> + ? ? ? else
> + ? ? ? ? ? ? ? lpphy->crs_sys_disable = 0;
> +
> + ? ? ? if (!lpphy->crs_usr_disable && !lpphy->crs_sys_disable) {
> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL,
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0xFF1F, 0x60);
> + ? ? ? ? ? ? ? else
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL,
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0xFF1F, 0x20);
> + ? ? ? }
> +}
> +
> +static void lpphy_disable_crs(struct b43_wldev *dev, bool user)
> +{
> + ? ? ? lpphy_set_deaf(dev, user);
> ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x1);
> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
> @@ -749,12 +779,9 @@ static void lpphy_disable_crs(struct b43_wldev *dev)
> ? ? ? ?b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0x3FF);
> }
>
> -static void lpphy_restore_crs(struct b43_wldev *dev)
> +static void lpphy_restore_crs(struct b43_wldev *dev, bool user)
> {
> - ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
> - ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x60);
> - ? ? ? else
> - ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x20);
> + ? ? ? lpphy_clear_deaf(dev, user);
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFF80);
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFC00);
> }
> @@ -800,10 +827,11 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
> ? ? ? ? ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?0xF800, rf_gain);
> ? ? ? ?} else {
> - ? ? ? ? ? ? ? pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x7F00;
> + ? ? ? ? ? ? ? pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x1FC0;
> + ? ? ? ? ? ? ? pa_gain <<= 2;
> ? ? ? ? ? ? ? ?b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?(gains.pga << 8) | gains.gm);
> - ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
> + ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_PHY_OFDM(0xFB),
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?0x8000, gains.pad | pa_gain);
> ? ? ? ? ? ? ? ?b43_phy_write(dev, B43_PHY_OFDM(0xFC),
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?(gains.pga << 8) | gains.gm);
> @@ -817,7 +845,7 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
> ? ? ? ? ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1 <<
> 7);
> ? ? ? ? ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1 <<
> 14);
> ? ? ? ?}
> - ? ? ? b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFBF, 1 << 6);
> + ? ? ? b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFBF, 1 << 6);
> }
>
> static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
> @@ -857,33 +885,33 @@ static void lpphy_rev2plus_set_rx_gain(struct
> b43_wldev *dev, u32 gain)
> ? ? ? ?}
> }
>
> -static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
> +static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
> {
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
> ? ? ? ?if (dev->phy.rev >= 2) {
> ? ? ? ? ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
> - ? ? ? ? ? ? ? if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
> - ? ? ? ? ? ? ? ? ? ? ? return;
> - ? ? ? ? ? ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
> - ? ? ? ? ? ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFF7);
> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_mask(dev, B43_PHY_OFDM(0xE5), 0xFFF7);
> + ? ? ? ? ? ? ? }
> ? ? ? ?} else {
> ? ? ? ? ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
> ? ? ? ?}
> }
>
> -static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
> +static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
> {
> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
> ? ? ? ?if (dev->phy.rev >= 2) {
> ? ? ? ? ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
> - ? ? ? ? ? ? ? if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
> - ? ? ? ? ? ? ? ? ? ? ? return;
> - ? ? ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
> - ? ? ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x8);
> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_set(dev, B43_PHY_OFDM(0xE5), 0x8);
> + ? ? ? ? ? ? ? }
> ? ? ? ?} else {
> ? ? ? ? ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
> ? ? ? ?}
> @@ -1002,26 +1030,22 @@ static u32 lpphy_qdiv_roundup(u32 dividend, u32
> divisor, u8 precision)
> {
> ? ? ? ?u32 quotient, remainder, rbit, roundup, tmp;
>
> - ? ? ? if (divisor == 0) {
> - ? ? ? ? ? ? ? quotient = 0;
> - ? ? ? ? ? ? ? remainder = 0;
> - ? ? ? } else {
> - ? ? ? ? ? ? ? quotient = dividend / divisor;
> - ? ? ? ? ? ? ? remainder = dividend % divisor;
> - ? ? ? }
> + ? ? ? if (divisor == 0)
> + ? ? ? ? ? ? ? return 0;
> +
> + ? ? ? quotient = dividend / divisor;
> + ? ? ? remainder = dividend % divisor;
>
> ? ? ? ?rbit = divisor & 0x1;
> ? ? ? ?roundup = (divisor >> 1) + rbit;
> - ? ? ? precision--;
>
> - ? ? ? while (precision != 0xFF) {
> + ? ? ? while (precision != 0) {
> ? ? ? ? ? ? ? ?tmp = remainder - roundup;
> ? ? ? ? ? ? ? ?quotient <<= 1;
> - ? ? ? ? ? ? ? remainder <<= 1;
> - ? ? ? ? ? ? ? if (remainder >= roundup) {
> + ? ? ? ? ? ? ? if (remainder >= roundup)
> ? ? ? ? ? ? ? ? ? ? ? ?remainder = (tmp << 1) + rbit;
> - ? ? ? ? ? ? ? ? ? ? ? quotient--;
> - ? ? ? ? ? ? ? }
> + ? ? ? ? ? ? ? else
> + ? ? ? ? ? ? ? ? ? ? ? remainder <<= 1;
> ? ? ? ? ? ? ? ?precision--;
> ? ? ? ?}
>
> @@ -1123,11 +1147,11 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> *dev)
> ? ? ? ?struct b43_phy_lp *lpphy = dev->phy.lp;
> ? ? ? ?struct lpphy_iq_est iq_est;
> ? ? ? ?struct lpphy_tx_gains tx_gains;
> - ? ? ? static const u32 ideal_pwr_table[22] = {
> + ? ? ? static const u32 ideal_pwr_table[21] = {
> ? ? ? ? ? ? ? ?0x10000, 0x10557, 0x10e2d, 0x113e0, 0x10f22, 0x0ff64,
> ? ? ? ? ? ? ? ?0x0eda2, 0x0e5d4, 0x0efd1, 0x0fbe8, 0x0b7b8, 0x04b35,
> ? ? ? ? ? ? ? ?0x01a5e, 0x00a0b, 0x00444, 0x001fd, 0x000ff, 0x00088,
> - ? ? ? ? ? ? ? 0x0004c, 0x0002c, 0x0001a, 0xc0006,
> + ? ? ? ? ? ? ? 0x0004c, 0x0002c, 0x0001a,
> ? ? ? ?};
> ? ? ? ?bool old_txg_ovr;
> ? ? ? ?u8 old_bbmult;
> @@ -1145,7 +1169,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> *dev)
> ? ? ? ? ? ? ? ? ? ? ? "RC calib: Failed to switch to channel 7, error = %d",
> ? ? ? ? ? ? ? ? ? ? ? err);
> ? ? ? ?}
> - ? ? ? old_txg_ovr = (b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) >> 6) & 1;
> + ? ? ? old_txg_ovr = !!(b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40);
> ? ? ? ?old_bbmult = lpphy_get_bb_mult(dev);
> ? ? ? ?if (old_txg_ovr)
> ? ? ? ? ? ? ? ?tx_gains = lpphy_get_tx_gains(dev);
> @@ -1160,7 +1184,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> *dev)
> ? ? ? ?old_txpctl = lpphy->txpctl_mode;
>
> ? ? ? ?lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
> - ? ? ? lpphy_disable_crs(dev);
> + ? ? ? lpphy_disable_crs(dev, true);
> ? ? ? ?loopback = lpphy_loopback(dev);
> ? ? ? ?if (loopback == -1)
> ? ? ? ? ? ? ? ?goto finish;
> @@ -1193,7 +1217,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> *dev)
> ? ? ? ?lpphy_stop_ddfs(dev);
>
> finish:
> - ? ? ? lpphy_restore_crs(dev);
> + ? ? ? lpphy_restore_crs(dev, true);
> ? ? ? ?b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, old_rf_ovrval);
> ? ? ? ?b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_0, old_rf_ovr);
> ? ? ? ?b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVRVAL, old_afe_ovrval);
> diff --git a/drivers/net/wireless/b43/phy_lp.h
> b/drivers/net/wireless/b43/phy_lp.h
> index 99cb038..e158d1f 100644
> --- a/drivers/net/wireless/b43/phy_lp.h
> +++ b/drivers/net/wireless/b43/phy_lp.h
> @@ -825,11 +825,11 @@ struct b43_phy_lp {
> ? ? ? ?enum b43_lpphy_txpctl_mode txpctl_mode;
>
> ? ? ? ?/* Transmit isolation medium band */
> - ? ? ? u8 tx_isolation_med_band; /* FIXME initial value? */
> + ? ? ? u8 tx_isolation_med_band;
> ? ? ? ?/* Transmit isolation low band */
> - ? ? ? u8 tx_isolation_low_band; /* FIXME initial value? */
> + ? ? ? u8 tx_isolation_low_band;
> ? ? ? ?/* Transmit isolation high band */
> - ? ? ? u8 tx_isolation_hi_band; /* FIXME initial value? */
> + ? ? ? u8 tx_isolation_hi_band;
>
> ? ? ? ?/* Max transmit power medium band */
> ? ? ? ?u16 max_tx_pwr_med_band;
> @@ -848,7 +848,7 @@ struct b43_phy_lp {
> ? ? ? ?s16 txpa[3], txpal[3], txpah[3];
>
> ? ? ? ?/* Receive power offset */
> - ? ? ? u8 rx_pwr_offset; /* FIXME initial value? */
> + ? ? ? u8 rx_pwr_offset;
>
> ? ? ? ?/* TSSI transmit count */
> ? ? ? ?u16 tssi_tx_count;
> @@ -864,16 +864,16 @@ struct b43_phy_lp {
> ? ? ? ?s8 tx_pwr_idx_over; /* FIXME initial value? */
>
> ? ? ? ?/* RSSI vf */
> - ? ? ? u8 rssi_vf; /* FIXME initial value? */
> + ? ? ? u8 rssi_vf;
> ? ? ? ?/* RSSI vc */
> - ? ? ? u8 rssi_vc; /* FIXME initial value? */
> + ? ? ? u8 rssi_vc;
> ? ? ? ?/* RSSI gs */
> - ? ? ? u8 rssi_gs; /* FIXME initial value? */
> + ? ? ? u8 rssi_gs;
>
> ? ? ? ?/* RC cap */
> ? ? ? ?u8 rc_cap; /* FIXME initial value? */
> ? ? ? ?/* BX arch */
> - ? ? ? u8 bx_arch; /* FIXME initial value? */
> + ? ? ? u8 bx_arch;
>
> ? ? ? ?/* Full calibration channel */
> ? ? ? ?u8 full_calib_chan; /* FIXME initial value? */
> @@ -885,6 +885,8 @@ struct b43_phy_lp {
> ? ? ? ?/* Used for "Save/Restore Dig Filt State" */
> ? ? ? ?u16 dig_flt_state[9];
>
> + ? ? ? bool crs_usr_disable, crs_sys_disable;
> +
> ? ? ? ?unsigned int pdiv;
> };
>
> diff --git a/drivers/net/wireless/b43/tables_lpphy.c
> b/drivers/net/wireless/b43/tables_lpphy.c
> index 2721310..60d472f 100644
> --- a/drivers/net/wireless/b43/tables_lpphy.c
> +++ b/drivers/net/wireless/b43/tables_lpphy.c
> @@ -2367,7 +2367,17 @@ static void lpphy_rev2plus_write_gain_table(struct
> b43_wldev *dev, int offset,
> ? ? ? ?tmp ?= data.pad << 16;
> ? ? ? ?tmp |= data.pga << 8;
> ? ? ? ?tmp |= data.gm;
> - ? ? ? tmp |= 0x7f000000;
> + ? ? ? if (dev->phy.rev >= 3) {
> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)
> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x10 << 24;
> + ? ? ? ? ? ? ? else
> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x70 << 24;
> + ? ? ? } else {
> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)
> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x14 << 24;
> + ? ? ? ? ? ? ? else
> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x7F << 24;
> + ? ? ? }
> ? ? ? ?b43_lptab_write(dev, B43_LPTAB32(7, 0xC0 + offset), tmp);
> ? ? ? ?tmp ?= data.bb_mult << 20;
> ? ? ? ?tmp |= data.dac << 28;
> --
> 1.6.2.4
>
>
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mark.sf.net at huijgen.tk  Wed Aug 19 14:43:10 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Wed, 19 Aug 2009 14:43:10 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>
	<4A8BBB02.4020203@huijgen.tk>
	<69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com>
Message-ID: <4A8BF35E.1090507@huijgen.tk>

G?bor Stefanik wrote:
> 2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
>   
>> G?bor Stefanik wrote:
>>     
>>> Hello World!
>>>
>>> Great news for Broadcom BCM4310/4312/4315 (PCI 14e4:4315) users:
>>> LP-PHY support is now at the point where it can be tested for functionality!
>>>
>>> So, go ahead, give it a try, and let's rock!
>>>
>>>       
>> Patches applied, well manually, cause I wasn't able to extract a working
>> version from the emails or the weblink provided. Whats the recommended
>> method to apply these git patches on mailinglists?
>>
>> Here goes:
>>
>> # modprobe b43 verbose=3
>> [ 1596.228088] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor
>> 0x4243)
>> [ 1596.228100] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F,
>> vendor 0x4243)
>> [ 1596.228110] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)
>> [ 1596.228120] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)
>> [ 1596.248050] ssb: Found rev 1 PMU (capabilities 0x02A62F01)
>> [ 1596.256780] ssb: SPROM revision 8 detected.
>> [ 1596.276093] ssb: Sonics Silicon Backplane found on PCI device
>> 0000:10:00.0
>> [ 1596.281108] b43-phy2: Broadcom 4312 WLAN found (core revision 15)
>> [ 1596.324046] b43-phy2 debug: Found PHY: Analog 6, Type 5, Revision 1
>> [ 1596.324060] b43-phy2 debug: Found Radio: Manuf 0x17F, Version 0x2062,
>> Revision 2
>> [ 1596.348233] phy2: Selected rate control algorithm 'minstrel'
>> [ 1596.348349] Broadcom 43xx driver loaded [ Features: PL, Firmware-ID:
>> FW13 ]
>>
>> # ifconfig wlan0 up
>> SIOCSIFFLAGS: Input/output error
>>
>> [ 1689.356055] b43 ssb0:0: firmware: requesting b43/ucode15.fw
>> [ 1689.703918] b43 ssb0:0: firmware: requesting b43/lp0initvals15.fw
>> [ 1689.710418] b43 ssb0:0: firmware: requesting b43/lp0bsinitvals15.fw
>> [ 1689.852058] b43-phy2: Loading firmware version 410.2160 (2007-05-26
>> 15:32:10)
>> [ 1689.854963] b43-phy2 debug: b2062: Using crystal tab entry 19200 kHz.
>> [ 1689.855468] b43-phy2 debug: RC calib: Failed to switch to channel 7,
>> error = -5
>> [ 1689.860016] b43-phy2 debug: Switch to init channel failed, error = -5.
>>     
>
> Hmm, error -5 is EIO, which in the channel switch code is used to
> represent "PLL charge pump out of range". This is specifically the
> error I was trying to fix... could you try without the 2 extra
> patches? Maybe I did something wrong. (Without the 2 patches, channels
> 1..6 and 9..11 (12...14 not tested) throw this error, but channels 7
> and 8 work.)
>   
Same error without the patches, but 1 less error in dmesg. The 'RC
calib: Failed to switch to channel 7, error = -5' is gone now.
> Also try extracting firmware from
> ftp://downloads.netgear.com/files/GPL/WNDR3300-V1.0.29_gpl_src.zip's
> wl_apsta.o file (newer than the one on mirror.openwrt.org - you may
> need to add the extraction defines to fwcutter first; there is a
> script in the fwcutter git tree, probably also in tarballs, that
> generates extraction lists.) This is the firmware the specs are
> written for; it's possible that the current firmware is simply not
> good for LP-PHY (or maybe it needs code based on older specs).
>   
After running the included python script, patching the cutter and
extracting firmware, I now get ucode version 478.104 in dmesg. Next test
is also without the 2 patches. Following log is from modprobe+ifconfig
wlan0 up:

[14600.712104] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor
0x4243)
[14600.712116] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F,
vendor 0x4243)
[14600.712126] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)
[14600.712136] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)
[14600.732052] ssb: Found rev 1 PMU (capabilities 0x02A62F01)
[14600.740727] ssb: SPROM revision 8 detected.
[14600.760093] ssb: Sonics Silicon Backplane found on PCI device
0000:10:00.0
[14600.816481] b43-phy5: Broadcom 4312 WLAN found (core revision 15)
[14600.860044] b43-phy5 debug: Found PHY: Analog 6, Type 5, Revision 1
[14600.860058] b43-phy5 debug: Found Radio: Manuf 0x17F, Version 0x2062,
Revision 2
[14600.884250] phy5: Selected rate control algorithm 'minstrel'
[14600.884367] Broadcom 43xx driver loaded [ Features: PL, Firmware-ID:
FW13 ]
[14611.192054] b43 ssb0:0: firmware: requesting b43/ucode15.fw
[14611.206016] b43 ssb0:0: firmware: requesting b43/lp0initvals15.fw
[14611.211387] b43 ssb0:0: firmware: requesting b43/lp0bsinitvals15.fw
[14611.364058] b43-phy5: Loading firmware version 478.104 (2008-07-01
00:50:23)
[14611.367051] b43-phy5 debug: b2062: Using crystal tab entry 19200 kHz.
[14611.371875] b43-phy5 debug: Switch to init channel failed, error = -5.
[14611.372406] b43-phy5 ERROR: PHY init: Channel switch to default failed

Still the "SIOCSIFFLAGS: Input/output error" on ifconfig wlan0 up.


>   
>> [ 1689.860543] b43-phy2 ERROR: PHY init: Channel switch to default failed
>>
>> Interface is not coming up, so cannot scan:
>> # iwlist wlan0 scan
>> wlan0     Interface doesn't support scanning : Network is down
>>     
>
> When testing mac80211 drivers, always use "iw dev wlan0 scan", not
> "iwlist wlan0 scan". (Though this shouldn't affect your results in
> this case.)
>   
OK will do. Never used iw before your other mail about iw phy and friends :)
> Try bringing up the interface in monitor mode.
> Also, try changing get_default_chan to return 7 instead of 1.
>   
Tested default_chan 7, *with* the 2 patches and the interface comes up!
Scan results show a lot of the AP's around here, but only AP's of
channel 6 and higher.
The closest AP here is actually on channel 1 and is not showing. It
seems there is a problem with channel 1?

Dmesg for modprobe+ifconfig wlan0 up:
[  478.516094] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x16, vendor
0x4243)
[  478.516106] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0F,
vendor 0x4243)
[  478.516116] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x0A, vendor 0x4243)
[  478.516125] ssb: Core 3 found: PCI-E (cc 0x820, rev 0x09, vendor 0x4243)
[  478.536053] ssb: Found rev 1 PMU (capabilities 0x02A62F01)
[  478.544729] ssb: SPROM revision 8 detected.
[  478.564094] ssb: Sonics Silicon Backplane found on PCI device
0000:10:00.0
[  478.569257] b43-phy3: Broadcom 4312 WLAN found (core revision 15)
[  478.612046] b43-phy3 debug: Found PHY: Analog 6, Type 5, Revision 1
[  478.612061] b43-phy3 debug: Found Radio: Manuf 0x17F, Version 0x2062,
Revision 2
[  478.636235] phy3: Selected rate control algorithm 'minstrel'
[  478.636347] Broadcom 43xx driver loaded [ Features: PL, Firmware-ID:
FW13 ]
[  483.116055] b43 ssb0:0: firmware: requesting b43/ucode15.fw
[  483.120545] b43 ssb0:0: firmware: requesting b43/lp0initvals15.fw
[  483.127002] b43 ssb0:0: firmware: requesting b43/lp0bsinitvals15.fw
[  483.280059] b43-phy3: Loading firmware version 478.104 (2008-07-01
00:50:23)
[  483.283053] b43-phy3 debug: b2062: Using crystal tab entry 19200 kHz.
[  483.296062] b43-phy3 debug: Chip initialized
[  483.296272] b43-phy3 debug: 64-bit DMA initialized
[  483.317545] Registered led device: b43-phy3::tx
[  483.317568] Registered led device: b43-phy3::rx
[  483.317589] Registered led device: b43-phy3::radio
[  483.317649] b43-phy3 debug: Wireless interface started
[  483.317669] b43-phy3 debug: Adding Interface type 2

# wpa_supplicant -Dwext -i wlan0 -c /etc/wpa_supplicant.conf
ioctl[SIOCSIWAUTH]: Operation not supported
WEXT auth param 4 value 0x0 - Trying to associate with 00:30:f1:f9:10:45
(SSID='default' freq=2462 MHz)
Associated with 00:30:f1:f9:10:45
WPA: Key negotiation completed with 00:30:f1:f9:10:45 [PTK=TKIP GTK=TKIP]
CTRL-EVENT-CONNECTED - Connection to 00:30:f1:f9:10:45 completed (auth)
[id=0 id_str=]

Well, what do you know, it actually does WPA authentication already!
Means TX must be working too.
I am also able to get an IP address with a dhcp client.

dmesg from wpa_supplicant part:
[  618.820622] wlan0: direct probe to AP 00:30:f1:f9:10:45 (try 1)
[  618.824200] wlan0 direct probe responded
[  618.824204] wlan0: authenticate with AP 00:30:f1:f9:10:45 (try 1)
[  618.825886] wlan0: authenticated
[  618.825902] wlan0: associate with AP 00:30:f1:f9:10:45 (try 1)
[  618.828148] wlan0: RX AssocResp from 00:30:f1:f9:10:45 (capab=0x431
status=0 aid=10)
[  618.828151] wlan0: associated

This AP is on channel 11.

I don't have time for further testing today, but results are promising!

Mark


From johannes at sipsolutions.net  Wed Aug 19 15:04:26 2009
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 19 Aug 2009 15:04:26 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <4A8BF35E.1090507@huijgen.tk>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>
	<4A8BBB02.4020203@huijgen.tk>
	<69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com>
	<4A8BF35E.1090507@huijgen.tk>
Message-ID: <1250687066.1067.25.camel@johannes.local>

On Wed, 2009-08-19 at 14:43 +0200, Mark Huijgen wrote:

> After running the included python script, patching the cutter and
> extracting firmware, I now get ucode version 478.104 in dmesg. Next test
> is also without the 2 patches. Following log is from modprobe+ifconfig
> wlan0 up:

Not really surprising, the firmware is for the MAC _only_, it doesn't
really ever touch the PHY, so it's very unlikely to matter.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20090819/3c0c7a9c/attachment.pgp>

From netrolller.3d at gmail.com  Wed Aug 19 15:26:51 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Wed, 19 Aug 2009 15:26:51 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <1250687066.1067.25.camel@johannes.local>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com> 
	<4A8BBB02.4020203@huijgen.tk>
	<69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com> 
	<4A8BF35E.1090507@huijgen.tk> <1250687066.1067.25.camel@johannes.local>
Message-ID: <69e28c910908190626s46fd0bfer5cc9dec9c5bb1c24@mail.gmail.com>

On Wed, Aug 19, 2009 at 3:04 PM, Johannes Berg<johannes at sipsolutions.net> wrote:
> On Wed, 2009-08-19 at 14:43 +0200, Mark Huijgen wrote:
>
>> After running the included python script, patching the cutter and
>> extracting firmware, I now get ucode version 478.104 in dmesg. Next test
>> is also without the 2 patches. Following log is from modprobe+ifconfig
>> wlan0 up:
>
> Not really surprising, the firmware is for the MAC _only_, it doesn't
> really ever touch the PHY, so it's very unlikely to matter.
>
> johannes
>

Actually, the output does change with the new firmware.

Current outputs:
1. Patches not applied, old firmware, default chan = 1: the channel
switch to 7 during calibration works, but nothing else.
2. Patches applied, old firmware, default chan = 1: no channels work
(not even the channel 7 switch in the calibration routine), ifup
fails.
3. Patches not applied, new firmware, default chan = 1 (I got this
from Larry in private mail): only channels 7 and 8 work, but ifup
works(?).
(4. Patches applied, new firmware, default chan = 1: please test!)
(5. Patches not applied, old firmware, default chan = 7: probably ifup
succeeds, but only channel 7 works. Not tested.)
(6. Patches applied, old firmware, default chan = 7: unknown, probably
doesn't work at all.)
(7. Patches not applied, new firmware, default chan = 7: Unknown.)
8. Patches applied, new firmware, default chan = 7: interface comes
up, scans (but only channels 6 and above show results), associates to
WPA AP on channel 11 and gets DHCP address (meaning, both TX and RX
working)!

Notice that 2 and 8 only differ in the FW ver and the default channel,
and in 8 (with new firmware), the switch to channel 7 during RC
calibration (before the switch to default channel) works - in 2, it
fails. Looks like the routines reverse-engineered from the newer
driver depend on the firmware included in that driver; or maybe the
old firmware simply doesn't properly handle LP-PHY. Initvals are also
a possible candidate for this. (Larry, what do you think about this?)

Mark, could you produce a dmesg output with the new firmware, patches
applied, and channel set to 1? Post the output of dmesg after scanning
& probably associating, if possible. (Scan/assoc may produce messages
in dmesg.)

(The news about TX working is great by the way!)

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mark.sf.net at huijgen.tk  Wed Aug 19 15:49:12 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Wed, 19 Aug 2009 15:49:12 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <69e28c910908190626s46fd0bfer5cc9dec9c5bb1c24@mail.gmail.com>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>
	<4A8BBB02.4020203@huijgen.tk>
	<69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com>
	<4A8BF35E.1090507@huijgen.tk>
	<1250687066.1067.25.camel@johannes.local>
	<69e28c910908190626s46fd0bfer5cc9dec9c5bb1c24@mail.gmail.com>
Message-ID: <4A8C02D8.7080309@huijgen.tk>

G?bor Stefanik wrote:
> Mark, could you produce a dmesg output with the new firmware, patches
> applied, and channel set to 1? Post the output of dmesg after scanning
> & probably associating, if possible. (Scan/assoc may produce messages
> in dmesg.)
>   
I tested this already, but with default chan set to 1, I cannot get the
interface up.
This is somewhere in my mail, but it got a bit messy after I noticed
that after
changing some of the code my modules got installed in another directory
(-dirty).

I just restarted the notebook, but now the results are different again...

New firmware, with patches applied and default channel 7:
[   72.160057] b43-phy1: Loading firmware version 478.104 (2008-07-01
00:50:23)
[   72.163484] b43-phy1 debug: RC calib: Failed to switch to channel 7,
error = -5
[   72.168100] b43-phy1 debug: Switch to init channel failed, error = -5.

Recompile module with default chan 1, patches still applied and new
firmware,
# modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up

[  430.259877] b43-phy2 debug: Switch to init channel failed, error = -5.

Recompile again, but with default chan back to 7, still patched and
still new firmware.
So same as in first situation:
# modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up

[  524.748062] b43-phy3 debug: Chip initialized

And I can get my interface up and working!

Without this procedure I have not been able to get a working chip. Seems
the partially
initialized state after each try, allows the next try to get a bit
further. And together with
the default channel switching between 1 and 7, I get a working chip, but
a chip that does
not seem to be able to find my AP thats on channel 1.

If I now change default chan to 1 again, I am getting the same error as
in step 2 above.
I have not been able to get the interface up with default chan set to 1.

Mark



From netrolller.3d at gmail.com  Wed Aug 19 15:54:22 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Wed, 19 Aug 2009 15:54:22 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <4A8C02D8.7080309@huijgen.tk>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com> 
	<4A8BBB02.4020203@huijgen.tk>
	<69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com> 
	<4A8BF35E.1090507@huijgen.tk> <1250687066.1067.25.camel@johannes.local>
	<69e28c910908190626s46fd0bfer5cc9dec9c5bb1c24@mail.gmail.com> 
	<4A8C02D8.7080309@huijgen.tk>
Message-ID: <69e28c910908190654v231d66c7k6a223f481f702c7c@mail.gmail.com>

2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
> G?bor Stefanik wrote:
>> Mark, could you produce a dmesg output with the new firmware, patches
>> applied, and channel set to 1? Post the output of dmesg after scanning
>> & probably associating, if possible. (Scan/assoc may produce messages
>> in dmesg.)
>>
> I tested this already, but with default chan set to 1, I cannot get the
> interface up.
> This is somewhere in my mail, but it got a bit messy after I noticed
> that after
> changing some of the code my modules got installed in another directory
> (-dirty).
>
> I just restarted the notebook, but now the results are different again...
>
> New firmware, with patches applied and default channel 7:
> [ ? 72.160057] b43-phy1: Loading firmware version 478.104 (2008-07-01
> 00:50:23)
> [ ? 72.163484] b43-phy1 debug: RC calib: Failed to switch to channel 7,
> error = -5
> [ ? 72.168100] b43-phy1 debug: Switch to init channel failed, error = -5.
>
> Recompile module with default chan 1, patches still applied and new
> firmware,
> # modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up
>
> [ ?430.259877] b43-phy2 debug: Switch to init channel failed, error = -5.
>
> Recompile again, but with default chan back to 7, still patched and
> still new firmware.
> So same as in first situation:
> # modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up
>
> [ ?524.748062] b43-phy3 debug: Chip initialized
>
> And I can get my interface up and working!
>
> Without this procedure I have not been able to get a working chip. Seems
> the partially
> initialized state after each try, allows the next try to get a bit
> further. And together with
> the default channel switching between 1 and 7, I get a working chip, but
> a chip that does
> not seem to be able to find my AP thats on channel 1.
>
> If I now change default chan to 1 again, I am getting the same error as
> in step 2 above.
> I have not been able to get the interface up with default chan set to 1.
>
> Mark
>
>

What do you see in dmesg after running a scan?

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mark.sf.net at huijgen.tk  Wed Aug 19 16:00:10 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Wed, 19 Aug 2009 16:00:10 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <69e28c910908190654v231d66c7k6a223f481f702c7c@mail.gmail.com>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>
	<4A8BBB02.4020203@huijgen.tk>
	<69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com>
	<4A8BF35E.1090507@huijgen.tk>
	<1250687066.1067.25.camel@johannes.local>
	<69e28c910908190626s46fd0bfer5cc9dec9c5bb1c24@mail.gmail.com>
	<4A8C02D8.7080309@huijgen.tk>
	<69e28c910908190654v231d66c7k6a223f481f702c7c@mail.gmail.com>
Message-ID: <4A8C056A.4050005@huijgen.tk>

G?bor Stefanik wrote:
> 2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
>   
>> G?bor Stefanik wrote:
>>     
>>> Mark, could you produce a dmesg output with the new firmware, patches
>>> applied, and channel set to 1? Post the output of dmesg after scanning
>>> & probably associating, if possible. (Scan/assoc may produce messages
>>> in dmesg.)
>>>
>>>       
>> I tested this already, but with default chan set to 1, I cannot get the
>> interface up.
>> This is somewhere in my mail, but it got a bit messy after I noticed
>> that after
>> changing some of the code my modules got installed in another directory
>> (-dirty).
>>
>> I just restarted the notebook, but now the results are different again...
>>
>> New firmware, with patches applied and default channel 7:
>> [   72.160057] b43-phy1: Loading firmware version 478.104 (2008-07-01
>> 00:50:23)
>> [   72.163484] b43-phy1 debug: RC calib: Failed to switch to channel 7,
>> error = -5
>> [   72.168100] b43-phy1 debug: Switch to init channel failed, error = -5.
>>
>> Recompile module with default chan 1, patches still applied and new
>> firmware,
>> # modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up
>>
>> [  430.259877] b43-phy2 debug: Switch to init channel failed, error = -5.
>>
>> Recompile again, but with default chan back to 7, still patched and
>> still new firmware.
>> So same as in first situation:
>> # modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up
>>
>> [  524.748062] b43-phy3 debug: Chip initialized
>>
>> And I can get my interface up and working!
>>
>> Without this procedure I have not been able to get a working chip. Seems
>> the partially
>> initialized state after each try, allows the next try to get a bit
>> further. And together with
>> the default channel switching between 1 and 7, I get a working chip, but
>> a chip that does
>> not seem to be able to find my AP thats on channel 1.
>>
>> If I now change default chan to 1 again, I am getting the same error as
>> in step 2 above.
>> I have not been able to get the interface up with default chan set to 1.
>>
>> Mark
>>
>>
>>     
>
> What do you see in dmesg after running a scan?
>   
After step 2, interface cannot be brought up:
# iw dev wlan0 scan
command failed: Network is down (-100)

No extra output in dmesg

After step 3 (so with default chan 7 again), interface comes up and I
can scan:
# iw dev wlan0 scan
<<list of scan results>>

No extra output generated in dmesg.

I must add that I do not have debugging messages enabled for any
mac80211 related options, only for b43 module.

Mark




From netrolller.3d at gmail.com  Wed Aug 19 16:03:55 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Wed, 19 Aug 2009 16:03:55 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <4A8C056A.4050005@huijgen.tk>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com> 
	<4A8BBB02.4020203@huijgen.tk>
	<69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com> 
	<4A8BF35E.1090507@huijgen.tk> <1250687066.1067.25.camel@johannes.local>
	<69e28c910908190626s46fd0bfer5cc9dec9c5bb1c24@mail.gmail.com> 
	<4A8C02D8.7080309@huijgen.tk>
	<69e28c910908190654v231d66c7k6a223f481f702c7c@mail.gmail.com> 
	<4A8C056A.4050005@huijgen.tk>
Message-ID: <69e28c910908190703h1ad7e98bqa4fe55a5fe7800e2@mail.gmail.com>

2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
> G?bor Stefanik wrote:
>> 2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
>>
>>> G?bor Stefanik wrote:
>>>
>>>> Mark, could you produce a dmesg output with the new firmware, patches
>>>> applied, and channel set to 1? Post the output of dmesg after scanning
>>>> & probably associating, if possible. (Scan/assoc may produce messages
>>>> in dmesg.)
>>>>
>>>>
>>> I tested this already, but with default chan set to 1, I cannot get the
>>> interface up.
>>> This is somewhere in my mail, but it got a bit messy after I noticed
>>> that after
>>> changing some of the code my modules got installed in another directory
>>> (-dirty).
>>>
>>> I just restarted the notebook, but now the results are different again...
>>>
>>> New firmware, with patches applied and default channel 7:
>>> [ ? 72.160057] b43-phy1: Loading firmware version 478.104 (2008-07-01
>>> 00:50:23)
>>> [ ? 72.163484] b43-phy1 debug: RC calib: Failed to switch to channel 7,
>>> error = -5
>>> [ ? 72.168100] b43-phy1 debug: Switch to init channel failed, error = -5.
>>>
>>> Recompile module with default chan 1, patches still applied and new
>>> firmware,
>>> # modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up
>>>
>>> [ ?430.259877] b43-phy2 debug: Switch to init channel failed, error = -5.
>>>
>>> Recompile again, but with default chan back to 7, still patched and
>>> still new firmware.
>>> So same as in first situation:
>>> # modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up
>>>
>>> [ ?524.748062] b43-phy3 debug: Chip initialized
>>>
>>> And I can get my interface up and working!
>>>
>>> Without this procedure I have not been able to get a working chip. Seems
>>> the partially
>>> initialized state after each try, allows the next try to get a bit
>>> further. And together with
>>> the default channel switching between 1 and 7, I get a working chip, but
>>> a chip that does
>>> not seem to be able to find my AP thats on channel 1.
>>>
>>> If I now change default chan to 1 again, I am getting the same error as
>>> in step 2 above.
>>> I have not been able to get the interface up with default chan set to 1.
>>>
>>> Mark
>>>
>>>
>>>
>>
>> What do you see in dmesg after running a scan?
>>
> After step 2, interface cannot be brought up:
> # iw dev wlan0 scan
> command failed: Network is down (-100)
>
> No extra output in dmesg
>
> After step 3 (so with default chan 7 again), interface comes up and I
> can scan:
> # iw dev wlan0 scan
> <<list of scan results>>
>
> No extra output generated in dmesg.
>
> I must add that I do not have debugging messages enabled for any
> mac80211 related options, only for b43 module.

That's not needed.

However, try "iw dev wlan0 scan trigger".

Also, try switching to all B/G channels manually.

One more thing to try is create a monitor interface and run kismet on
it. In addition, you can use aireplay-ng on the monitor interface to
test TX.

>
> Mark
>
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mark.sf.net at huijgen.tk  Wed Aug 19 16:24:56 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Wed, 19 Aug 2009 16:24:56 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <69e28c910908190703h1ad7e98bqa4fe55a5fe7800e2@mail.gmail.com>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>
	<4A8BBB02.4020203@huijgen.tk>
	<69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com>
	<4A8BF35E.1090507@huijgen.tk>
	<1250687066.1067.25.camel@johannes.local>
	<69e28c910908190626s46fd0bfer5cc9dec9c5bb1c24@mail.gmail.com>
	<4A8C02D8.7080309@huijgen.tk>
	<69e28c910908190654v231d66c7k6a223f481f702c7c@mail.gmail.com>
	<4A8C056A.4050005@huijgen.tk>
	<69e28c910908190703h1ad7e98bqa4fe55a5fe7800e2@mail.gmail.com>
Message-ID: <4A8C0B38.2020402@huijgen.tk>

G?bor Stefanik wrote:
> 2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
>   
>> G?bor Stefanik wrote:
>>     
>>> 2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
>>>
>>>       
>>>> G?bor Stefanik wrote:
>>>>
>>>>         
>>>>> Mark, could you produce a dmesg output with the new firmware, patches
>>>>> applied, and channel set to 1? Post the output of dmesg after scanning
>>>>> & probably associating, if possible. (Scan/assoc may produce messages
>>>>> in dmesg.)
>>>>>
>>>>>
>>>>>           
>>>> I tested this already, but with default chan set to 1, I cannot get the
>>>> interface up.
>>>> This is somewhere in my mail, but it got a bit messy after I noticed
>>>> that after
>>>> changing some of the code my modules got installed in another directory
>>>> (-dirty).
>>>>
>>>> I just restarted the notebook, but now the results are different again...
>>>>
>>>> New firmware, with patches applied and default channel 7:
>>>> [   72.160057] b43-phy1: Loading firmware version 478.104 (2008-07-01
>>>> 00:50:23)
>>>> [   72.163484] b43-phy1 debug: RC calib: Failed to switch to channel 7,
>>>> error = -5
>>>> [   72.168100] b43-phy1 debug: Switch to init channel failed, error = -5.
>>>>
>>>> Recompile module with default chan 1, patches still applied and new
>>>> firmware,
>>>> # modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up
>>>>
>>>> [  430.259877] b43-phy2 debug: Switch to init channel failed, error = -5.
>>>>
>>>> Recompile again, but with default chan back to 7, still patched and
>>>> still new firmware.
>>>> So same as in first situation:
>>>> # modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up
>>>>
>>>> [  524.748062] b43-phy3 debug: Chip initialized
>>>>
>>>> And I can get my interface up and working!
>>>>
>>>> Without this procedure I have not been able to get a working chip. Seems
>>>> the partially
>>>> initialized state after each try, allows the next try to get a bit
>>>> further. And together with
>>>> the default channel switching between 1 and 7, I get a working chip, but
>>>> a chip that does
>>>> not seem to be able to find my AP thats on channel 1.
>>>>
>>>> If I now change default chan to 1 again, I am getting the same error as
>>>> in step 2 above.
>>>> I have not been able to get the interface up with default chan set to 1.
>>>>
>>>> Mark
>>>>
>>>>
>>>>
>>>>         
>>> What do you see in dmesg after running a scan?
>>>
>>>       
>> After step 2, interface cannot be brought up:
>> # iw dev wlan0 scan
>> command failed: Network is down (-100)
>>
>> No extra output in dmesg
>>
>> After step 3 (so with default chan 7 again), interface comes up and I
>> can scan:
>> # iw dev wlan0 scan
>> <<list of scan results>>
>>
>> No extra output generated in dmesg.
>>
>> I must add that I do not have debugging messages enabled for any
>> mac80211 related options, only for b43 module.
>>     
>
> That's not needed.
>
> However, try "iw dev wlan0 scan trigger".
>
> Also, try switching to all B/G channels manually.
>   
To summarize, all cases with patches and new firmware:
case 1: cold boot with default channel 7, RC calib error and 'init
channel failed' error,
case 2: recompile+reload b43 with default channel 1, just 'init channel
failed' error,
case 3: recompile+reload b43 with default channel 7, works


You mean 'iw dev wlan0 set channel 1' for example?

In case 2 (with default chan 1), ifconfig wlan0 gives error
"SIOCSIFFLAGS: Input/output error"

# iw dev wlan0 set channel 1
no output generated, also nothing in dmesg

# iw dev wlan0 scan trigger
command failed: Network is down (-100)
nothing in dmesg.

Both commands do not give any output in dmesg in case 3 either.

Tried channel 1 up to 11, 12 and higher gives 'command failed: Invalid
argument (-22)', which is expected I think.



> One more thing to try is create a monitor interface and run kismet on
> it. In addition, you can use aireplay-ng on the monitor interface to
> test TX.
>   
Never done anything with monitor mode before, so when I have some time
I'll look into it.


From netrolller.3d at gmail.com  Wed Aug 19 16:54:21 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Wed, 19 Aug 2009 16:54:21 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <4A8C0B38.2020402@huijgen.tk>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com> 
	<69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com> 
	<4A8BF35E.1090507@huijgen.tk> <1250687066.1067.25.camel@johannes.local>
	<69e28c910908190626s46fd0bfer5cc9dec9c5bb1c24@mail.gmail.com> 
	<4A8C02D8.7080309@huijgen.tk>
	<69e28c910908190654v231d66c7k6a223f481f702c7c@mail.gmail.com> 
	<4A8C056A.4050005@huijgen.tk>
	<69e28c910908190703h1ad7e98bqa4fe55a5fe7800e2@mail.gmail.com> 
	<4A8C0B38.2020402@huijgen.tk>
Message-ID: <69e28c910908190754p4f96f2ddhec00300a1c287f5c@mail.gmail.com>

2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
> G?bor Stefanik wrote:
>> 2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
>>
>>> G?bor Stefanik wrote:
>>>
>>>> 2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
>>>>
>>>>
>>>>> G?bor Stefanik wrote:
>>>>>
>>>>>
>>>>>> Mark, could you produce a dmesg output with the new firmware, patches
>>>>>> applied, and channel set to 1? Post the output of dmesg after scanning
>>>>>> & probably associating, if possible. (Scan/assoc may produce messages
>>>>>> in dmesg.)
>>>>>>
>>>>>>
>>>>>>
>>>>> I tested this already, but with default chan set to 1, I cannot get the
>>>>> interface up.
>>>>> This is somewhere in my mail, but it got a bit messy after I noticed
>>>>> that after
>>>>> changing some of the code my modules got installed in another directory
>>>>> (-dirty).
>>>>>
>>>>> I just restarted the notebook, but now the results are different again...
>>>>>
>>>>> New firmware, with patches applied and default channel 7:
>>>>> [ ? 72.160057] b43-phy1: Loading firmware version 478.104 (2008-07-01
>>>>> 00:50:23)
>>>>> [ ? 72.163484] b43-phy1 debug: RC calib: Failed to switch to channel 7,
>>>>> error = -5
>>>>> [ ? 72.168100] b43-phy1 debug: Switch to init channel failed, error = -5.
>>>>>
>>>>> Recompile module with default chan 1, patches still applied and new
>>>>> firmware,
>>>>> # modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up
>>>>>
>>>>> [ ?430.259877] b43-phy2 debug: Switch to init channel failed, error = -5.
>>>>>
>>>>> Recompile again, but with default chan back to 7, still patched and
>>>>> still new firmware.
>>>>> So same as in first situation:
>>>>> # modprobe -r b43 && modprobe b43 verbose=3 && ifconfig wlan0 up
>>>>>
>>>>> [ ?524.748062] b43-phy3 debug: Chip initialized
>>>>>
>>>>> And I can get my interface up and working!
>>>>>
>>>>> Without this procedure I have not been able to get a working chip. Seems
>>>>> the partially
>>>>> initialized state after each try, allows the next try to get a bit
>>>>> further. And together with
>>>>> the default channel switching between 1 and 7, I get a working chip, but
>>>>> a chip that does
>>>>> not seem to be able to find my AP thats on channel 1.
>>>>>
>>>>> If I now change default chan to 1 again, I am getting the same error as
>>>>> in step 2 above.
>>>>> I have not been able to get the interface up with default chan set to 1.
>>>>>
>>>>> Mark
>>>>>
>>>>>
>>>>>
>>>>>
>>>> What do you see in dmesg after running a scan?
>>>>
>>>>
>>> After step 2, interface cannot be brought up:
>>> # iw dev wlan0 scan
>>> command failed: Network is down (-100)
>>>
>>> No extra output in dmesg
>>>
>>> After step 3 (so with default chan 7 again), interface comes up and I
>>> can scan:
>>> # iw dev wlan0 scan
>>> <<list of scan results>>
>>>
>>> No extra output generated in dmesg.
>>>
>>> I must add that I do not have debugging messages enabled for any
>>> mac80211 related options, only for b43 module.
>>>
>>
>> That's not needed.
>>
>> However, try "iw dev wlan0 scan trigger".
>>
>> Also, try switching to all B/G channels manually.
>>
> To summarize, all cases with patches and new firmware:
> case 1: cold boot with default channel 7, RC calib error and 'init
> channel failed' error,
> case 2: recompile+reload b43 with default channel 1, just 'init channel
> failed' error,
> case 3: recompile+reload b43 with default channel 7, works
>
>
> You mean 'iw dev wlan0 set channel 1' for example?
>
> In case 2 (with default chan 1), ifconfig wlan0 gives error
> "SIOCSIFFLAGS: Input/output error"
>
> # iw dev wlan0 set channel 1
> no output generated, also nothing in dmesg
>
> # iw dev wlan0 scan trigger
> command failed: Network is down (-100)
> nothing in dmesg.
>
> Both commands do not give any output in dmesg in case 3 either.
>
> Tried channel 1 up to 11, 12 and higher gives 'command failed: Invalid
> argument (-22)', which is expected I think.

Set your regulatory domain to something that allows higher channels
(e.g. iw reg set JP - this one unlocks channels 1-14 (14 is
CCK/802.11b only); or iw reg set HU - channels 1-13) to test channels
14 and up.

Also, test this:

Create a monitor interface (iw dev wlan0 interface add mon0 type monitor)
Up the interface (ifconfig mon0 up)
Set channel to 1 (iwconfig mon0 channel 1 or iw dev wlan0 set channel 1)
Run tcpdump on the interface (tcpdump -i mon0).

Try for other channel values as well. (You don't need to recreate the
interface for each channel, just use the channel-setting command to
switch the channel.) You should see packets on all channels.

Another thing to try: add a printk to b43_lpphy_op_set_channel and
print out new_channel. This will log all channel change requests
(including automatic ones) to dmesg, which can be helpful.

If you set your AP to channel 11, can you connect to it & use it as normal?

>
>
>
>> One more thing to try is create a monitor interface and run kismet on
>> it. In addition, you can use aireplay-ng on the monitor interface to
>> test TX.
>>
> Never done anything with monitor mode before, so when I have some time
> I'll look into it.
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Wed Aug 19 16:57:37 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Wed, 19 Aug 2009 16:57:37 +0200
Subject: [PATCH] b43: LP-PHY: Implement spec updates and remove resolved 
	FIXMEs
In-Reply-To: <69e28c910908190430x5223cf6al460e8008c36c3111@mail.gmail.com>
References: <4A8AE255.9030102@gmail.com>
	<69e28c910908190430x5223cf6al460e8008c36c3111@mail.gmail.com>
Message-ID: <69e28c910908190757j69eb693cia7ea4ff45959fc8c@mail.gmail.com>

False alert, sorry. Feel free to apply. The "regression" apparently
resulted from the use of an incorrect firmware image - when Mark
switched to the same firmware as Larry, his card started working
again.

2009/8/19 G?bor Stefanik <netrolller.3d at gmail.com>:
> John, please hold off this patch for now, it appears to be causing
> regressions. I will investigate this.
>
> 2009/8/18 G?bor Stefanik <netrolller.3d at gmail.com>:
>> Larry has started re-checking all current routines against a new
>> version of the Broadcom MIPS driver. This patch implements the first
>> round of changes he documented on the specs wiki.
>>
>> Also remove a few FIXMEs regarding missing initial values for variables
>> with dynamic initial values where reading the values has been implemented.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> drivers/net/wireless/b43/phy_lp.c ? ? ? | ? 98
>> +++++++++++++++++++------------
>> drivers/net/wireless/b43/phy_lp.h ? ? ? | ? 18 +++---
>> drivers/net/wireless/b43/tables_lpphy.c | ? 12 ++++-
>> 3 files changed, 82 insertions(+), 46 deletions(-)
>>
>> diff --git a/drivers/net/wireless/b43/phy_lp.c
>> b/drivers/net/wireless/b43/phy_lp.c
>> index 242338f..6c69cdb 100644
>> --- a/drivers/net/wireless/b43/phy_lp.c
>> +++ b/drivers/net/wireless/b43/phy_lp.c
>> @@ -719,9 +719,39 @@ static void lpphy_set_bb_mult(struct b43_wldev *dev, u8
>> bb_mult)
>> ? ? ? ?b43_lptab_write(dev, B43_LPTAB16(0, 87), (u16)bb_mult << 8);
>> }
>>
>> -static void lpphy_disable_crs(struct b43_wldev *dev)
>> +static void lpphy_set_deaf(struct b43_wldev *dev, bool user)
>> {
>> + ? ? ? struct b43_phy_lp *lpphy = dev->phy.lp;
>> +
>> + ? ? ? if (user)
>> + ? ? ? ? ? ? ? lpphy->crs_usr_disable = 1;
>> + ? ? ? else
>> + ? ? ? ? ? ? ? lpphy->crs_sys_disable = 1;
>> ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x80);
>> +}
>> +
>> +static void lpphy_clear_deaf(struct b43_wldev *dev, bool user)
>> +{
>> + ? ? ? struct b43_phy_lp *lpphy = dev->phy.lp;
>> +
>> + ? ? ? if (user)
>> + ? ? ? ? ? ? ? lpphy->crs_usr_disable = 0;
>> + ? ? ? else
>> + ? ? ? ? ? ? ? lpphy->crs_sys_disable = 0;
>> +
>> + ? ? ? if (!lpphy->crs_usr_disable && !lpphy->crs_sys_disable) {
>> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
>> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL,
>> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0xFF1F, 0x60);
>> + ? ? ? ? ? ? ? else
>> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL,
>> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0xFF1F, 0x20);
>> + ? ? ? }
>> +}
>> +
>> +static void lpphy_disable_crs(struct b43_wldev *dev, bool user)
>> +{
>> + ? ? ? lpphy_set_deaf(dev, user);
>> ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x1);
>> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
>> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
>> @@ -749,12 +779,9 @@ static void lpphy_disable_crs(struct b43_wldev *dev)
>> ? ? ? ?b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0x3FF);
>> }
>>
>> -static void lpphy_restore_crs(struct b43_wldev *dev)
>> +static void lpphy_restore_crs(struct b43_wldev *dev, bool user)
>> {
>> - ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
>> - ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x60);
>> - ? ? ? else
>> - ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x20);
>> + ? ? ? lpphy_clear_deaf(dev, user);
>> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFF80);
>> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFC00);
>> }
>> @@ -800,10 +827,11 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
>> ? ? ? ? ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
>> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?0xF800, rf_gain);
>> ? ? ? ?} else {
>> - ? ? ? ? ? ? ? pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x7F00;
>> + ? ? ? ? ? ? ? pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x1FC0;
>> + ? ? ? ? ? ? ? pa_gain <<= 2;
>> ? ? ? ? ? ? ? ?b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
>> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?(gains.pga << 8) | gains.gm);
>> - ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
>> + ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_PHY_OFDM(0xFB),
>> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?0x8000, gains.pad | pa_gain);
>> ? ? ? ? ? ? ? ?b43_phy_write(dev, B43_PHY_OFDM(0xFC),
>> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?(gains.pga << 8) | gains.gm);
>> @@ -817,7 +845,7 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
>> ? ? ? ? ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1 <<
>> 7);
>> ? ? ? ? ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1 <<
>> 14);
>> ? ? ? ?}
>> - ? ? ? b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFBF, 1 << 6);
>> + ? ? ? b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFBF, 1 << 6);
>> }
>>
>> static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
>> @@ -857,33 +885,33 @@ static void lpphy_rev2plus_set_rx_gain(struct
>> b43_wldev *dev, u32 gain)
>> ? ? ? ?}
>> }
>>
>> -static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
>> +static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
>> {
>> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
>> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
>> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
>> ? ? ? ?if (dev->phy.rev >= 2) {
>> ? ? ? ? ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
>> - ? ? ? ? ? ? ? if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
>> - ? ? ? ? ? ? ? ? ? ? ? return;
>> - ? ? ? ? ? ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
>> - ? ? ? ? ? ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFF7);
>> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
>> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
>> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_mask(dev, B43_PHY_OFDM(0xE5), 0xFFF7);
>> + ? ? ? ? ? ? ? }
>> ? ? ? ?} else {
>> ? ? ? ? ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
>> ? ? ? ?}
>> }
>>
>> -static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
>> +static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
>> {
>> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
>> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
>> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
>> ? ? ? ?if (dev->phy.rev >= 2) {
>> ? ? ? ? ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
>> - ? ? ? ? ? ? ? if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
>> - ? ? ? ? ? ? ? ? ? ? ? return;
>> - ? ? ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
>> - ? ? ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x8);
>> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
>> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
>> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_set(dev, B43_PHY_OFDM(0xE5), 0x8);
>> + ? ? ? ? ? ? ? }
>> ? ? ? ?} else {
>> ? ? ? ? ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
>> ? ? ? ?}
>> @@ -1002,26 +1030,22 @@ static u32 lpphy_qdiv_roundup(u32 dividend, u32
>> divisor, u8 precision)
>> {
>> ? ? ? ?u32 quotient, remainder, rbit, roundup, tmp;
>>
>> - ? ? ? if (divisor == 0) {
>> - ? ? ? ? ? ? ? quotient = 0;
>> - ? ? ? ? ? ? ? remainder = 0;
>> - ? ? ? } else {
>> - ? ? ? ? ? ? ? quotient = dividend / divisor;
>> - ? ? ? ? ? ? ? remainder = dividend % divisor;
>> - ? ? ? }
>> + ? ? ? if (divisor == 0)
>> + ? ? ? ? ? ? ? return 0;
>> +
>> + ? ? ? quotient = dividend / divisor;
>> + ? ? ? remainder = dividend % divisor;
>>
>> ? ? ? ?rbit = divisor & 0x1;
>> ? ? ? ?roundup = (divisor >> 1) + rbit;
>> - ? ? ? precision--;
>>
>> - ? ? ? while (precision != 0xFF) {
>> + ? ? ? while (precision != 0) {
>> ? ? ? ? ? ? ? ?tmp = remainder - roundup;
>> ? ? ? ? ? ? ? ?quotient <<= 1;
>> - ? ? ? ? ? ? ? remainder <<= 1;
>> - ? ? ? ? ? ? ? if (remainder >= roundup) {
>> + ? ? ? ? ? ? ? if (remainder >= roundup)
>> ? ? ? ? ? ? ? ? ? ? ? ?remainder = (tmp << 1) + rbit;
>> - ? ? ? ? ? ? ? ? ? ? ? quotient--;
>> - ? ? ? ? ? ? ? }
>> + ? ? ? ? ? ? ? else
>> + ? ? ? ? ? ? ? ? ? ? ? remainder <<= 1;
>> ? ? ? ? ? ? ? ?precision--;
>> ? ? ? ?}
>>
>> @@ -1123,11 +1147,11 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>> *dev)
>> ? ? ? ?struct b43_phy_lp *lpphy = dev->phy.lp;
>> ? ? ? ?struct lpphy_iq_est iq_est;
>> ? ? ? ?struct lpphy_tx_gains tx_gains;
>> - ? ? ? static const u32 ideal_pwr_table[22] = {
>> + ? ? ? static const u32 ideal_pwr_table[21] = {
>> ? ? ? ? ? ? ? ?0x10000, 0x10557, 0x10e2d, 0x113e0, 0x10f22, 0x0ff64,
>> ? ? ? ? ? ? ? ?0x0eda2, 0x0e5d4, 0x0efd1, 0x0fbe8, 0x0b7b8, 0x04b35,
>> ? ? ? ? ? ? ? ?0x01a5e, 0x00a0b, 0x00444, 0x001fd, 0x000ff, 0x00088,
>> - ? ? ? ? ? ? ? 0x0004c, 0x0002c, 0x0001a, 0xc0006,
>> + ? ? ? ? ? ? ? 0x0004c, 0x0002c, 0x0001a,
>> ? ? ? ?};
>> ? ? ? ?bool old_txg_ovr;
>> ? ? ? ?u8 old_bbmult;
>> @@ -1145,7 +1169,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>> *dev)
>> ? ? ? ? ? ? ? ? ? ? ? "RC calib: Failed to switch to channel 7, error = %d",
>> ? ? ? ? ? ? ? ? ? ? ? err);
>> ? ? ? ?}
>> - ? ? ? old_txg_ovr = (b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) >> 6) & 1;
>> + ? ? ? old_txg_ovr = !!(b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40);
>> ? ? ? ?old_bbmult = lpphy_get_bb_mult(dev);
>> ? ? ? ?if (old_txg_ovr)
>> ? ? ? ? ? ? ? ?tx_gains = lpphy_get_tx_gains(dev);
>> @@ -1160,7 +1184,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>> *dev)
>> ? ? ? ?old_txpctl = lpphy->txpctl_mode;
>>
>> ? ? ? ?lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
>> - ? ? ? lpphy_disable_crs(dev);
>> + ? ? ? lpphy_disable_crs(dev, true);
>> ? ? ? ?loopback = lpphy_loopback(dev);
>> ? ? ? ?if (loopback == -1)
>> ? ? ? ? ? ? ? ?goto finish;
>> @@ -1193,7 +1217,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>> *dev)
>> ? ? ? ?lpphy_stop_ddfs(dev);
>>
>> finish:
>> - ? ? ? lpphy_restore_crs(dev);
>> + ? ? ? lpphy_restore_crs(dev, true);
>> ? ? ? ?b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, old_rf_ovrval);
>> ? ? ? ?b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_0, old_rf_ovr);
>> ? ? ? ?b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVRVAL, old_afe_ovrval);
>> diff --git a/drivers/net/wireless/b43/phy_lp.h
>> b/drivers/net/wireless/b43/phy_lp.h
>> index 99cb038..e158d1f 100644
>> --- a/drivers/net/wireless/b43/phy_lp.h
>> +++ b/drivers/net/wireless/b43/phy_lp.h
>> @@ -825,11 +825,11 @@ struct b43_phy_lp {
>> ? ? ? ?enum b43_lpphy_txpctl_mode txpctl_mode;
>>
>> ? ? ? ?/* Transmit isolation medium band */
>> - ? ? ? u8 tx_isolation_med_band; /* FIXME initial value? */
>> + ? ? ? u8 tx_isolation_med_band;
>> ? ? ? ?/* Transmit isolation low band */
>> - ? ? ? u8 tx_isolation_low_band; /* FIXME initial value? */
>> + ? ? ? u8 tx_isolation_low_band;
>> ? ? ? ?/* Transmit isolation high band */
>> - ? ? ? u8 tx_isolation_hi_band; /* FIXME initial value? */
>> + ? ? ? u8 tx_isolation_hi_band;
>>
>> ? ? ? ?/* Max transmit power medium band */
>> ? ? ? ?u16 max_tx_pwr_med_band;
>> @@ -848,7 +848,7 @@ struct b43_phy_lp {
>> ? ? ? ?s16 txpa[3], txpal[3], txpah[3];
>>
>> ? ? ? ?/* Receive power offset */
>> - ? ? ? u8 rx_pwr_offset; /* FIXME initial value? */
>> + ? ? ? u8 rx_pwr_offset;
>>
>> ? ? ? ?/* TSSI transmit count */
>> ? ? ? ?u16 tssi_tx_count;
>> @@ -864,16 +864,16 @@ struct b43_phy_lp {
>> ? ? ? ?s8 tx_pwr_idx_over; /* FIXME initial value? */
>>
>> ? ? ? ?/* RSSI vf */
>> - ? ? ? u8 rssi_vf; /* FIXME initial value? */
>> + ? ? ? u8 rssi_vf;
>> ? ? ? ?/* RSSI vc */
>> - ? ? ? u8 rssi_vc; /* FIXME initial value? */
>> + ? ? ? u8 rssi_vc;
>> ? ? ? ?/* RSSI gs */
>> - ? ? ? u8 rssi_gs; /* FIXME initial value? */
>> + ? ? ? u8 rssi_gs;
>>
>> ? ? ? ?/* RC cap */
>> ? ? ? ?u8 rc_cap; /* FIXME initial value? */
>> ? ? ? ?/* BX arch */
>> - ? ? ? u8 bx_arch; /* FIXME initial value? */
>> + ? ? ? u8 bx_arch;
>>
>> ? ? ? ?/* Full calibration channel */
>> ? ? ? ?u8 full_calib_chan; /* FIXME initial value? */
>> @@ -885,6 +885,8 @@ struct b43_phy_lp {
>> ? ? ? ?/* Used for "Save/Restore Dig Filt State" */
>> ? ? ? ?u16 dig_flt_state[9];
>>
>> + ? ? ? bool crs_usr_disable, crs_sys_disable;
>> +
>> ? ? ? ?unsigned int pdiv;
>> };
>>
>> diff --git a/drivers/net/wireless/b43/tables_lpphy.c
>> b/drivers/net/wireless/b43/tables_lpphy.c
>> index 2721310..60d472f 100644
>> --- a/drivers/net/wireless/b43/tables_lpphy.c
>> +++ b/drivers/net/wireless/b43/tables_lpphy.c
>> @@ -2367,7 +2367,17 @@ static void lpphy_rev2plus_write_gain_table(struct
>> b43_wldev *dev, int offset,
>> ? ? ? ?tmp ?= data.pad << 16;
>> ? ? ? ?tmp |= data.pga << 8;
>> ? ? ? ?tmp |= data.gm;
>> - ? ? ? tmp |= 0x7f000000;
>> + ? ? ? if (dev->phy.rev >= 3) {
>> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)
>> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x10 << 24;
>> + ? ? ? ? ? ? ? else
>> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x70 << 24;
>> + ? ? ? } else {
>> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)
>> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x14 << 24;
>> + ? ? ? ? ? ? ? else
>> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x7F << 24;
>> + ? ? ? }
>> ? ? ? ?b43_lptab_write(dev, B43_LPTAB32(7, 0xC0 + offset), tmp);
>> ? ? ? ?tmp ?= data.bb_mult << 20;
>> ? ? ? ?tmp |= data.dac << 28;
>> --
>> 1.6.2.4
>>
>>
>>
>>
>
>
>
> --
> Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From gregor.kowski at gmail.com  Wed Aug 19 22:35:45 2009
From: gregor.kowski at gmail.com (gregor kowski)
Date: Wed, 19 Aug 2009 22:35:45 +0200
Subject: [PATCHv4] b43 add harware tkip
Message-ID: <83a869cd0908191335u723f62c6p119ec4ed8cfb51c5@mail.gmail.com>

Update v4 : add a warn_on in b43_op_update_tkip_key, update to last
driver change (key API).
Update v3 : add a module parameter to enable hw tkip, Coding style
fix, locking fix
Update v2 : work with qos, implement dump key, fix an issue with setting
random value on tkip key clear.

This add hardware tkip for b43.

Signed-off-by: Gregor Kowski <gregor.kowski at gmail.com>

Index: linux-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/dma.c	2009-08-10
20:35:33.000000000 +0000
+++ linux-2.6/drivers/net/wireless/b43/dma.c	2009-08-10 20:35:43.000000000 +0000
@@ -1188,7 +1188,7 @@
 	header = &(ring->txhdr_cache[(slot / TX_SLOTS_PER_FRAME) * hdrsize]);
 	cookie = generate_cookie(ring, slot);
 	err = b43_generate_txhdr(ring->dev, header,
-				 skb->data, skb->len, info, cookie);
+				 skb, info, cookie);
 	if (unlikely(err)) {
 		ring->current_slot = old_top_slot;
 		ring->used_slots = old_used_slots;
Index: linux-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/main.c	2009-08-10
20:35:42.000000000 +0000
+++ linux-2.6/drivers/net/wireless/b43/main.c	2009-08-19
20:31:39.000000000 +0000
@@ -80,6 +80,10 @@
 module_param_named(nohwcrypt, modparam_nohwcrypt, int, 0444);
 MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption.");

+static int modparam_hwtkip;
+module_param_named(hwtkip, modparam_hwtkip, int, 0444);
+MODULE_PARM_DESC(hwtkip, "Enable hardware tkip.");
+
 static int modparam_qos = 1;
 module_param_named(qos, modparam_qos, int, 0444);
 MODULE_PARM_DESC(qos, "Enable QOS support (default on)");
@@ -826,6 +830,85 @@
 			(index * 2) + 1, addrtmp[1]);
 }

+/* The ucode will use phase1 key with TEK key to decrypt rx packets.
+ * When a packet is received, the iv32 is checked.
+ * - if it doesn't the packet is returned without modification (and software
+ *   decryption can be done). That's what happen when iv16 wrap.
+ * - if it does, the rc4 key is computed, and decryption is tried.
+ *   Either it will success and B43_RX_MAC_DEC is returned,
+ *   either it fails and B43_RX_MAC_DEC|B43_RX_MAC_DECERR is returned
+ *   and the packet is not usable (it got modified by the ucode).
+ * So in order to never have B43_RX_MAC_DECERR, we should provide
+ * a iv32 and phase1key that match. Because we drop packets in case of
+ * B43_RX_MAC_DECERR, if we have a correct iv32 but a wrong phase1key, all
+ * packets will be lost without higher layer knowing (ie no resync possible
+ * until next wrap).
+ *
+ * NOTE : this should support 50 key like RCMTA because
+ * (B43_SHM_SH_KEYIDXBLOCK - B43_SHM_SH_TKIPTSCTTAK)/14 = 50
+ */
+static void rx_tkip_phase1_write(struct b43_wldev *dev, u8 index, u32 iv32,
+		u16 *phase1key)
+{
+	unsigned int i;
+	u32 offset;
+	u8 pairwise_keys_start = B43_NR_GROUP_KEYS * 2;
+
+	if (!modparam_hwtkip)
+		return;
+
+	if (b43_new_kidx_api(dev))
+		pairwise_keys_start = B43_NR_GROUP_KEYS;
+
+	B43_WARN_ON(index < pairwise_keys_start);
+	/* We have four default TX keys and possibly four default RX keys.
+	 * Physical mac 0 is mapped to physical key 4 or 8, depending
+	 * on the firmware version.
+	 * So we must adjust the index here.
+	 */
+	index -= pairwise_keys_start;
+	B43_WARN_ON(index >= B43_NR_PAIRWISE_KEYS);
+
+	if (b43_debug(dev, B43_DBG_KEYS)) {
+		b43dbg(dev->wl, "rx_tkip_phase1_write : idx 0x%x, iv32 0x%x\n",
+				index, iv32);
+	}
+	/* Write the key to the  RX tkip shared mem */
+	offset = B43_SHM_SH_TKIPTSCTTAK + index * (10 + 4);
+	for (i = 0; i < 10; i += 2) {
+		b43_shm_write16(dev, B43_SHM_SHARED, offset + i,
+				phase1key ? phase1key[i / 2] : 0);
+	}
+	b43_shm_write16(dev, B43_SHM_SHARED, offset + i, iv32);
+	b43_shm_write16(dev, B43_SHM_SHARED, offset + i + 2, iv32 >> 16);
+}
+
+static void b43_op_update_tkip_key(struct ieee80211_hw *hw,
+			struct ieee80211_key_conf *keyconf, const u8 *addr,
+			u32 iv32, u16 *phase1key)
+{
+	struct b43_wl *wl = hw_to_b43_wl(hw);
+	struct b43_wldev *dev;
+	int index = keyconf->hw_key_idx;
+
+	if (B43_WARN_ON(!modparam_hwtkip))
+		return;
+
+	mutex_lock(&wl->mutex);
+
+	dev = wl->current_dev;
+	if (!dev || b43_status(dev) < B43_STAT_INITIALIZED)
+		goto out_unlock;
+
+	keymac_write(dev, index, NULL);	/* First zero out mac to avoid race */
+
+	rx_tkip_phase1_write(dev, index, iv32, phase1key);
+	keymac_write(dev, index, addr);
+
+out_unlock:
+	mutex_unlock(&wl->mutex);
+}
+
 static void do_key_write(struct b43_wldev *dev,
 			 u8 index, u8 algorithm,
 			 const u8 *key, size_t key_len, const u8 *mac_addr)
@@ -841,6 +924,19 @@

 	if (index >= pairwise_keys_start)
 		keymac_write(dev, index, NULL);	/* First zero out mac. */
+	if (algorithm == B43_SEC_ALGO_TKIP) {
+		/*
+		 * We should provide an initial iv32, phase1key pair.
+		 * We could start with iv32=0 and compute the corresponding
+		 * phase1key, but this means calling ieee80211_get_tkip_key
+		 * with a fake skb (or export other tkip function).
+		 * Because we are lazy we hope iv32 won't start with
+		 * 0xffffffff and let's b43_op_update_tkip_key provide a
+		 * correct pair.
+		 */
+		rx_tkip_phase1_write(dev, index, 0xffffffff, (u16*)buf);
+	} else if (index >= pairwise_keys_start) /* clear it */
+		rx_tkip_phase1_write(dev, index, 0, NULL);
 	if (key)
 		memcpy(buf, key, key_len);
 	key_write(dev, index, algorithm, buf);
@@ -859,6 +955,15 @@
 	int i;
 	int pairwise_keys_start;

+	/* For ALG_TKIP the key is encoded as a 256-bit (32 byte) data block:
+	 * 	- Temporal Encryption Key (128 bits)
+	 * 	- Temporal Authenticator Tx MIC Key (64 bits)
+	 * 	- Temporal Authenticator Rx MIC Key (64 bits)
+	 *
+	 * 	Hardware only store TEK
+	 */
+	if (algorithm == B43_SEC_ALGO_TKIP && key_len == 32)
+		key_len = 16;
 	if (key_len > B43_SEC_KEYSIZE)
 		return -EINVAL;
 	for (i = 0; i < ARRAY_SIZE(dev->key); i++) {
@@ -965,6 +1070,14 @@
 		printk("   Algo: %04X/%02X", algo, key->algorithm);

 		if (index >= pairwise_keys_start) {
+			if (key->algorithm == B43_SEC_ALGO_TKIP) {
+				printk("   TKIP: ");
+				offset = B43_SHM_SH_TKIPTSCTTAK + (index - 4) * (10 + 4);
+				for (i = 0; i < 14; i += 2) {
+					u16 tmp = b43_shm_read16(dev, B43_SHM_SHARED, offset + i);
+					printk("%02X%02X", (tmp & 0xFF), ((tmp >> 8) & 0xFF));
+				}
+			}
 			rcmta0 = b43_shm_read32(dev, B43_SHM_RCMTA,
 						((index - pairwise_keys_start) * 2) + 0);
 			rcmta1 = b43_shm_read16(dev, B43_SHM_RCMTA,
@@ -3587,8 +3700,10 @@

 	switch (cmd) {
 	case SET_KEY:
-		if (algorithm == B43_SEC_ALGO_TKIP) {
-			/* FIXME: No TKIP hardware encryption for now. */
+		if (algorithm == B43_SEC_ALGO_TKIP &&
+		    (!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ||
+		    !modparam_hwtkip)) {
+			/* We support only pairwise key */
 			err = -EOPNOTSUPP;
 			goto out_unlock;
 		}
@@ -3618,6 +3733,8 @@
 				     b43_hf_read(dev) & ~B43_HF_USEDEFKEYS);
 		}
 		key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
+		if (algorithm == B43_SEC_ALGO_TKIP)
+			key->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;
 		break;
 	case DISABLE_KEY: {
 		err = b43_key_clear(dev, key->hw_key_idx);
@@ -4345,6 +4462,7 @@
 	.bss_info_changed	= b43_op_bss_info_changed,
 	.configure_filter	= b43_op_configure_filter,
 	.set_key		= b43_op_set_key,
+	.update_tkip_key	= b43_op_update_tkip_key,
 	.get_stats		= b43_op_get_stats,
 	.get_tx_stats		= b43_op_get_tx_stats,
 	.get_tsf		= b43_op_get_tsf,
Index: linux-2.6/drivers/net/wireless/b43/pio.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/pio.c	2009-08-10
20:35:33.000000000 +0000
+++ linux-2.6/drivers/net/wireless/b43/pio.c	2009-08-10 20:35:43.000000000 +0000
@@ -461,8 +461,8 @@

 	cookie = generate_cookie(q, pack);
 	hdrlen = b43_txhdr_size(q->dev);
-	err = b43_generate_txhdr(q->dev, (u8 *)&txhdr, skb->data,
-				 skb->len, info, cookie);
+	err = b43_generate_txhdr(q->dev, (u8 *)&txhdr, skb,
+				 info, cookie);
 	if (err)
 		return err;

Index: linux-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/xmit.c	2009-08-10
20:35:42.000000000 +0000
+++ linux-2.6/drivers/net/wireless/b43/xmit.c	2009-08-10
20:35:43.000000000 +0000
@@ -180,11 +180,12 @@
 /* Generate a TX data header. */
 int b43_generate_txhdr(struct b43_wldev *dev,
 		       u8 *_txhdr,
-		       const unsigned char *fragment_data,
-		       unsigned int fragment_len,
+		       struct sk_buff *skb_frag,
 		       struct ieee80211_tx_info *info,
 		       u16 cookie)
 {
+	const unsigned char *fragment_data = skb_frag->data;
+	unsigned int fragment_len = skb_frag->len;
 	struct b43_txhdr *txhdr = (struct b43_txhdr *)_txhdr;
 	const struct b43_phy *phy = &dev->phy;
 	const struct ieee80211_hdr *wlhdr =
@@ -258,9 +259,26 @@
 		mac_ctl |= (key->algorithm << B43_TXH_MAC_KEYALG_SHIFT) &
 			   B43_TXH_MAC_KEYALG;
 		wlhdr_len = ieee80211_hdrlen(fctl);
-		iv_len = min((size_t) info->control.hw_key->iv_len,
-			     ARRAY_SIZE(txhdr->iv));
-		memcpy(txhdr->iv, ((u8 *) wlhdr) + wlhdr_len, iv_len);
+		if (key->algorithm == B43_SEC_ALGO_TKIP) {
+			u16 phase1key[5];
+			int i;
+			/* we give the phase1key and iv16 here, the key is stored in
+			 * shm. With that the hardware can do phase 2 and encryption.
+			 */
+			ieee80211_get_tkip_key(info->control.hw_key, skb_frag,
+					IEEE80211_TKIP_P1_KEY, (u8*)phase1key);
+			/* phase1key is in host endian */
+			for (i = 0; i < 5; i++)
+				phase1key[i] = cpu_to_le16(phase1key[i]);
+
+			memcpy(txhdr->iv, phase1key, 10);
+			/* iv16 */
+			memcpy(txhdr->iv + 10, ((u8 *) wlhdr) + wlhdr_len, 3);
+		} else {
+			iv_len = min((size_t) info->control.hw_key->iv_len,
+				     ARRAY_SIZE(txhdr->iv));
+			memcpy(txhdr->iv, ((u8 *) wlhdr) + wlhdr_len, iv_len);
+		}
 	}
 	if (b43_is_old_txhdr_format(dev)) {
 		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->old_format.plcp),
Index: linux-2.6/drivers/net/wireless/b43/xmit.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/xmit.h	2009-08-10
20:35:33.000000000 +0000
+++ linux-2.6/drivers/net/wireless/b43/xmit.h	2009-08-10
20:35:43.000000000 +0000
@@ -176,8 +176,7 @@

 int b43_generate_txhdr(struct b43_wldev *dev,
 		       u8 * txhdr,
-		       const unsigned char *fragment_data,
-		       unsigned int fragment_len,
+		       struct sk_buff *skb_frag,
 		       struct ieee80211_tx_info *txctl, u16 cookie);

 /* Transmit Status */


From netrolller.3d at gmail.com  Thu Aug 20 00:14:13 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Thu, 20 Aug 2009 00:14:13 +0200
Subject: [PATCH] b43: LP-PHY: Implement spec updates and remove resolved 
	FIXMEs
In-Reply-To: <4A8AE255.9030102@gmail.com>
References: <4A8AE255.9030102@gmail.com>
Message-ID: <69e28c910908191514w3073d382x927062038f2bb128@mail.gmail.com>

Seeing that this is still not in wireless-testing - this patch should
be applied, the previously mentioned regressions were false alerts
(Larry tested without this patch and with v478 firmware, which worked;
while Mark applied this patch and used v410 firmware, which didn't
work - when Mark upgraded to v478 firmware, his card too came to
life.) So, please apply.

2009/8/18 G?bor Stefanik <netrolller.3d at gmail.com>:
> Larry has started re-checking all current routines against a new
> version of the Broadcom MIPS driver. This patch implements the first
> round of changes he documented on the specs wiki.
>
> Also remove a few FIXMEs regarding missing initial values for variables
> with dynamic initial values where reading the values has been implemented.
>
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> drivers/net/wireless/b43/phy_lp.c ? ? ? | ? 98
> +++++++++++++++++++------------
> drivers/net/wireless/b43/phy_lp.h ? ? ? | ? 18 +++---
> drivers/net/wireless/b43/tables_lpphy.c | ? 12 ++++-
> 3 files changed, 82 insertions(+), 46 deletions(-)
>
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index 242338f..6c69cdb 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -719,9 +719,39 @@ static void lpphy_set_bb_mult(struct b43_wldev *dev, u8
> bb_mult)
> ? ? ? ?b43_lptab_write(dev, B43_LPTAB16(0, 87), (u16)bb_mult << 8);
> }
>
> -static void lpphy_disable_crs(struct b43_wldev *dev)
> +static void lpphy_set_deaf(struct b43_wldev *dev, bool user)
> {
> + ? ? ? struct b43_phy_lp *lpphy = dev->phy.lp;
> +
> + ? ? ? if (user)
> + ? ? ? ? ? ? ? lpphy->crs_usr_disable = 1;
> + ? ? ? else
> + ? ? ? ? ? ? ? lpphy->crs_sys_disable = 1;
> ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x80);
> +}
> +
> +static void lpphy_clear_deaf(struct b43_wldev *dev, bool user)
> +{
> + ? ? ? struct b43_phy_lp *lpphy = dev->phy.lp;
> +
> + ? ? ? if (user)
> + ? ? ? ? ? ? ? lpphy->crs_usr_disable = 0;
> + ? ? ? else
> + ? ? ? ? ? ? ? lpphy->crs_sys_disable = 0;
> +
> + ? ? ? if (!lpphy->crs_usr_disable && !lpphy->crs_sys_disable) {
> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL,
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0xFF1F, 0x60);
> + ? ? ? ? ? ? ? else
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL,
> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0xFF1F, 0x20);
> + ? ? ? }
> +}
> +
> +static void lpphy_disable_crs(struct b43_wldev *dev, bool user)
> +{
> + ? ? ? lpphy_set_deaf(dev, user);
> ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x1);
> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
> @@ -749,12 +779,9 @@ static void lpphy_disable_crs(struct b43_wldev *dev)
> ? ? ? ?b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0x3FF);
> }
>
> -static void lpphy_restore_crs(struct b43_wldev *dev)
> +static void lpphy_restore_crs(struct b43_wldev *dev, bool user)
> {
> - ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
> - ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x60);
> - ? ? ? else
> - ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x20);
> + ? ? ? lpphy_clear_deaf(dev, user);
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFF80);
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFC00);
> }
> @@ -800,10 +827,11 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
> ? ? ? ? ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?0xF800, rf_gain);
> ? ? ? ?} else {
> - ? ? ? ? ? ? ? pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x7F00;
> + ? ? ? ? ? ? ? pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x1FC0;
> + ? ? ? ? ? ? ? pa_gain <<= 2;
> ? ? ? ? ? ? ? ?b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?(gains.pga << 8) | gains.gm);
> - ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
> + ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_PHY_OFDM(0xFB),
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?0x8000, gains.pad | pa_gain);
> ? ? ? ? ? ? ? ?b43_phy_write(dev, B43_PHY_OFDM(0xFC),
> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?(gains.pga << 8) | gains.gm);
> @@ -817,7 +845,7 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
> ? ? ? ? ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1 <<
> 7);
> ? ? ? ? ? ? ? ?b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1 <<
> 14);
> ? ? ? ?}
> - ? ? ? b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFBF, 1 << 6);
> + ? ? ? b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFBF, 1 << 6);
> }
>
> static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
> @@ -857,33 +885,33 @@ static void lpphy_rev2plus_set_rx_gain(struct
> b43_wldev *dev, u32 gain)
> ? ? ? ?}
> }
>
> -static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
> +static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
> {
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
> ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
> ? ? ? ?if (dev->phy.rev >= 2) {
> ? ? ? ? ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
> - ? ? ? ? ? ? ? if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
> - ? ? ? ? ? ? ? ? ? ? ? return;
> - ? ? ? ? ? ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
> - ? ? ? ? ? ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFF7);
> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_mask(dev, B43_PHY_OFDM(0xE5), 0xFFF7);
> + ? ? ? ? ? ? ? }
> ? ? ? ?} else {
> ? ? ? ? ? ? ? ?b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
> ? ? ? ?}
> }
>
> -static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
> +static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
> {
> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
> ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
> ? ? ? ?if (dev->phy.rev >= 2) {
> ? ? ? ? ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
> - ? ? ? ? ? ? ? if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
> - ? ? ? ? ? ? ? ? ? ? ? return;
> - ? ? ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
> - ? ? ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x8);
> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
> + ? ? ? ? ? ? ? ? ? ? ? b43_phy_set(dev, B43_PHY_OFDM(0xE5), 0x8);
> + ? ? ? ? ? ? ? }
> ? ? ? ?} else {
> ? ? ? ? ? ? ? ?b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
> ? ? ? ?}
> @@ -1002,26 +1030,22 @@ static u32 lpphy_qdiv_roundup(u32 dividend, u32
> divisor, u8 precision)
> {
> ? ? ? ?u32 quotient, remainder, rbit, roundup, tmp;
>
> - ? ? ? if (divisor == 0) {
> - ? ? ? ? ? ? ? quotient = 0;
> - ? ? ? ? ? ? ? remainder = 0;
> - ? ? ? } else {
> - ? ? ? ? ? ? ? quotient = dividend / divisor;
> - ? ? ? ? ? ? ? remainder = dividend % divisor;
> - ? ? ? }
> + ? ? ? if (divisor == 0)
> + ? ? ? ? ? ? ? return 0;
> +
> + ? ? ? quotient = dividend / divisor;
> + ? ? ? remainder = dividend % divisor;
>
> ? ? ? ?rbit = divisor & 0x1;
> ? ? ? ?roundup = (divisor >> 1) + rbit;
> - ? ? ? precision--;
>
> - ? ? ? while (precision != 0xFF) {
> + ? ? ? while (precision != 0) {
> ? ? ? ? ? ? ? ?tmp = remainder - roundup;
> ? ? ? ? ? ? ? ?quotient <<= 1;
> - ? ? ? ? ? ? ? remainder <<= 1;
> - ? ? ? ? ? ? ? if (remainder >= roundup) {
> + ? ? ? ? ? ? ? if (remainder >= roundup)
> ? ? ? ? ? ? ? ? ? ? ? ?remainder = (tmp << 1) + rbit;
> - ? ? ? ? ? ? ? ? ? ? ? quotient--;
> - ? ? ? ? ? ? ? }
> + ? ? ? ? ? ? ? else
> + ? ? ? ? ? ? ? ? ? ? ? remainder <<= 1;
> ? ? ? ? ? ? ? ?precision--;
> ? ? ? ?}
>
> @@ -1123,11 +1147,11 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> *dev)
> ? ? ? ?struct b43_phy_lp *lpphy = dev->phy.lp;
> ? ? ? ?struct lpphy_iq_est iq_est;
> ? ? ? ?struct lpphy_tx_gains tx_gains;
> - ? ? ? static const u32 ideal_pwr_table[22] = {
> + ? ? ? static const u32 ideal_pwr_table[21] = {
> ? ? ? ? ? ? ? ?0x10000, 0x10557, 0x10e2d, 0x113e0, 0x10f22, 0x0ff64,
> ? ? ? ? ? ? ? ?0x0eda2, 0x0e5d4, 0x0efd1, 0x0fbe8, 0x0b7b8, 0x04b35,
> ? ? ? ? ? ? ? ?0x01a5e, 0x00a0b, 0x00444, 0x001fd, 0x000ff, 0x00088,
> - ? ? ? ? ? ? ? 0x0004c, 0x0002c, 0x0001a, 0xc0006,
> + ? ? ? ? ? ? ? 0x0004c, 0x0002c, 0x0001a,
> ? ? ? ?};
> ? ? ? ?bool old_txg_ovr;
> ? ? ? ?u8 old_bbmult;
> @@ -1145,7 +1169,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> *dev)
> ? ? ? ? ? ? ? ? ? ? ? "RC calib: Failed to switch to channel 7, error = %d",
> ? ? ? ? ? ? ? ? ? ? ? err);
> ? ? ? ?}
> - ? ? ? old_txg_ovr = (b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) >> 6) & 1;
> + ? ? ? old_txg_ovr = !!(b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40);
> ? ? ? ?old_bbmult = lpphy_get_bb_mult(dev);
> ? ? ? ?if (old_txg_ovr)
> ? ? ? ? ? ? ? ?tx_gains = lpphy_get_tx_gains(dev);
> @@ -1160,7 +1184,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> *dev)
> ? ? ? ?old_txpctl = lpphy->txpctl_mode;
>
> ? ? ? ?lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
> - ? ? ? lpphy_disable_crs(dev);
> + ? ? ? lpphy_disable_crs(dev, true);
> ? ? ? ?loopback = lpphy_loopback(dev);
> ? ? ? ?if (loopback == -1)
> ? ? ? ? ? ? ? ?goto finish;
> @@ -1193,7 +1217,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
> *dev)
> ? ? ? ?lpphy_stop_ddfs(dev);
>
> finish:
> - ? ? ? lpphy_restore_crs(dev);
> + ? ? ? lpphy_restore_crs(dev, true);
> ? ? ? ?b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, old_rf_ovrval);
> ? ? ? ?b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_0, old_rf_ovr);
> ? ? ? ?b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVRVAL, old_afe_ovrval);
> diff --git a/drivers/net/wireless/b43/phy_lp.h
> b/drivers/net/wireless/b43/phy_lp.h
> index 99cb038..e158d1f 100644
> --- a/drivers/net/wireless/b43/phy_lp.h
> +++ b/drivers/net/wireless/b43/phy_lp.h
> @@ -825,11 +825,11 @@ struct b43_phy_lp {
> ? ? ? ?enum b43_lpphy_txpctl_mode txpctl_mode;
>
> ? ? ? ?/* Transmit isolation medium band */
> - ? ? ? u8 tx_isolation_med_band; /* FIXME initial value? */
> + ? ? ? u8 tx_isolation_med_band;
> ? ? ? ?/* Transmit isolation low band */
> - ? ? ? u8 tx_isolation_low_band; /* FIXME initial value? */
> + ? ? ? u8 tx_isolation_low_band;
> ? ? ? ?/* Transmit isolation high band */
> - ? ? ? u8 tx_isolation_hi_band; /* FIXME initial value? */
> + ? ? ? u8 tx_isolation_hi_band;
>
> ? ? ? ?/* Max transmit power medium band */
> ? ? ? ?u16 max_tx_pwr_med_band;
> @@ -848,7 +848,7 @@ struct b43_phy_lp {
> ? ? ? ?s16 txpa[3], txpal[3], txpah[3];
>
> ? ? ? ?/* Receive power offset */
> - ? ? ? u8 rx_pwr_offset; /* FIXME initial value? */
> + ? ? ? u8 rx_pwr_offset;
>
> ? ? ? ?/* TSSI transmit count */
> ? ? ? ?u16 tssi_tx_count;
> @@ -864,16 +864,16 @@ struct b43_phy_lp {
> ? ? ? ?s8 tx_pwr_idx_over; /* FIXME initial value? */
>
> ? ? ? ?/* RSSI vf */
> - ? ? ? u8 rssi_vf; /* FIXME initial value? */
> + ? ? ? u8 rssi_vf;
> ? ? ? ?/* RSSI vc */
> - ? ? ? u8 rssi_vc; /* FIXME initial value? */
> + ? ? ? u8 rssi_vc;
> ? ? ? ?/* RSSI gs */
> - ? ? ? u8 rssi_gs; /* FIXME initial value? */
> + ? ? ? u8 rssi_gs;
>
> ? ? ? ?/* RC cap */
> ? ? ? ?u8 rc_cap; /* FIXME initial value? */
> ? ? ? ?/* BX arch */
> - ? ? ? u8 bx_arch; /* FIXME initial value? */
> + ? ? ? u8 bx_arch;
>
> ? ? ? ?/* Full calibration channel */
> ? ? ? ?u8 full_calib_chan; /* FIXME initial value? */
> @@ -885,6 +885,8 @@ struct b43_phy_lp {
> ? ? ? ?/* Used for "Save/Restore Dig Filt State" */
> ? ? ? ?u16 dig_flt_state[9];
>
> + ? ? ? bool crs_usr_disable, crs_sys_disable;
> +
> ? ? ? ?unsigned int pdiv;
> };
>
> diff --git a/drivers/net/wireless/b43/tables_lpphy.c
> b/drivers/net/wireless/b43/tables_lpphy.c
> index 2721310..60d472f 100644
> --- a/drivers/net/wireless/b43/tables_lpphy.c
> +++ b/drivers/net/wireless/b43/tables_lpphy.c
> @@ -2367,7 +2367,17 @@ static void lpphy_rev2plus_write_gain_table(struct
> b43_wldev *dev, int offset,
> ? ? ? ?tmp ?= data.pad << 16;
> ? ? ? ?tmp |= data.pga << 8;
> ? ? ? ?tmp |= data.gm;
> - ? ? ? tmp |= 0x7f000000;
> + ? ? ? if (dev->phy.rev >= 3) {
> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)
> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x10 << 24;
> + ? ? ? ? ? ? ? else
> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x70 << 24;
> + ? ? ? } else {
> + ? ? ? ? ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)
> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x14 << 24;
> + ? ? ? ? ? ? ? else
> + ? ? ? ? ? ? ? ? ? ? ? tmp |= 0x7F << 24;
> + ? ? ? }
> ? ? ? ?b43_lptab_write(dev, B43_LPTAB32(7, 0xC0 + offset), tmp);
> ? ? ? ?tmp ?= data.bb_mult << 20;
> ? ? ? ?tmp |= data.dac << 28;
> --
> 1.6.2.4
>
>
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mark.sf.net at huijgen.tk  Thu Aug 20 08:25:06 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Thu, 20 Aug 2009 08:25:06 +0200
Subject: [PATCH] b43: LP-PHY: Implement spec updates and remove resolved
	FIXMEs
In-Reply-To: <69e28c910908191514w3073d382x927062038f2bb128@mail.gmail.com>
References: <4A8AE255.9030102@gmail.com>
	<69e28c910908191514w3073d382x927062038f2bb128@mail.gmail.com>
Message-ID: <4A8CEC42.4010602@huijgen.tk>

G?bor Stefanik wrote:
> Seeing that this is still not in wireless-testing - this patch should
> be applied, the previously mentioned regressions were false alerts
> (Larry tested without this patch and with v478 firmware, which worked;
> while Mark applied this patch and used v410 firmware, which didn't
> work - when Mark upgraded to v478 firmware, his card too came to
> life.) So, please apply.
>   
Just tested again, and this patch also works with v410 firmware.
Still need to load the module 3 times to get a working interface though,
so firmware version does not make any difference at all.

1st with b43_lpphy_op_get_default_chan returning 7:
    [   73.571467] b43-phy1 debug: RC calib: Failed to switch to channel
7, error =
-5                                                                          

    [   73.576016] b43-phy1 debug: Switch to init channel failed, error
=
-5.                                                                                   

    [   73.576543] b43-phy1 ERROR: PHY init: Channel switch to default
failed                                                                                   

2nd load with it returning 1
    [  202.595791] b43-phy2 debug: Switch to init channel failed, error
= -5.
    [  202.596322] b43-phy2 ERROR: PHY init: Channel switch to default
failed
3rd load with returning 7 again.
    [  238.500062] b43-phy3 debug: Chip initialized

After 3rd load I can get the interface up without errors and I am able
to associate, do WPA and dhcp
with an AP on channel 11. Still no channel 1 AP's found here.

Mark

> 2009/8/18 G?bor Stefanik <netrolller.3d at gmail.com>:
>   
>> Larry has started re-checking all current routines against a new
>> version of the Broadcom MIPS driver. This patch implements the first
>> round of changes he documented on the specs wiki.
>>
>> Also remove a few FIXMEs regarding missing initial values for variables
>> with dynamic initial values where reading the values has been implemented.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> drivers/net/wireless/b43/phy_lp.c       |   98
>> +++++++++++++++++++------------
>> drivers/net/wireless/b43/phy_lp.h       |   18 +++---
>> drivers/net/wireless/b43/tables_lpphy.c |   12 ++++-
>> 3 files changed, 82 insertions(+), 46 deletions(-)
>>
>> diff --git a/drivers/net/wireless/b43/phy_lp.c
>> b/drivers/net/wireless/b43/phy_lp.c
>> index 242338f..6c69cdb 100644
>> --- a/drivers/net/wireless/b43/phy_lp.c
>> +++ b/drivers/net/wireless/b43/phy_lp.c
>> @@ -719,9 +719,39 @@ static void lpphy_set_bb_mult(struct b43_wldev *dev, u8
>> bb_mult)
>>        b43_lptab_write(dev, B43_LPTAB16(0, 87), (u16)bb_mult << 8);
>> }
>>
>> -static void lpphy_disable_crs(struct b43_wldev *dev)
>> +static void lpphy_set_deaf(struct b43_wldev *dev, bool user)
>> {
>> +       struct b43_phy_lp *lpphy = dev->phy.lp;
>> +
>> +       if (user)
>> +               lpphy->crs_usr_disable = 1;
>> +       else
>> +               lpphy->crs_sys_disable = 1;
>>        b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x80);
>> +}
>> +
>> +static void lpphy_clear_deaf(struct b43_wldev *dev, bool user)
>> +{
>> +       struct b43_phy_lp *lpphy = dev->phy.lp;
>> +
>> +       if (user)
>> +               lpphy->crs_usr_disable = 0;
>> +       else
>> +               lpphy->crs_sys_disable = 0;
>> +
>> +       if (!lpphy->crs_usr_disable && !lpphy->crs_sys_disable) {
>> +               if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
>> +                       b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL,
>> +                                       0xFF1F, 0x60);
>> +               else
>> +                       b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL,
>> +                                       0xFF1F, 0x20);
>> +       }
>> +}
>> +
>> +static void lpphy_disable_crs(struct b43_wldev *dev, bool user)
>> +{
>> +       lpphy_set_deaf(dev, user);
>>        b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x1);
>>        b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
>>        b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
>> @@ -749,12 +779,9 @@ static void lpphy_disable_crs(struct b43_wldev *dev)
>>        b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_2, 0x3FF);
>> }
>>
>> -static void lpphy_restore_crs(struct b43_wldev *dev)
>> +static void lpphy_restore_crs(struct b43_wldev *dev, bool user)
>> {
>> -       if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
>> -               b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x60);
>> -       else
>> -               b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFF1F, 0x20);
>> +       lpphy_clear_deaf(dev, user);
>>        b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFF80);
>>        b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFC00);
>> }
>> @@ -800,10 +827,11 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
>>                b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
>>                                0xF800, rf_gain);
>>        } else {
>> -               pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x7F00;
>> +               pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x1FC0;
>> +               pa_gain <<= 2;
>>                b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
>>                              (gains.pga << 8) | gains.gm);
>> -               b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
>> +               b43_phy_maskset(dev, B43_PHY_OFDM(0xFB),
>>                                0x8000, gains.pad | pa_gain);
>>                b43_phy_write(dev, B43_PHY_OFDM(0xFC),
>>                              (gains.pga << 8) | gains.gm);
>> @@ -817,7 +845,7 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
>>                b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1 <<
>> 7);
>>                b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1 <<
>> 14);
>>        }
>> -       b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFBF, 1 << 6);
>> +       b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFBF, 1 << 6);
>> }
>>
>> static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
>> @@ -857,33 +885,33 @@ static void lpphy_rev2plus_set_rx_gain(struct
>> b43_wldev *dev, u32 gain)
>>        }
>> }
>>
>> -static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
>> +static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
>> {
>>        b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
>>        b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
>>        b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
>>        if (dev->phy.rev >= 2) {
>>                b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
>> -               if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
>> -                       return;
>> -               b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
>> -               b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFF7);
>> +               if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
>> +                       b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
>> +                       b43_phy_mask(dev, B43_PHY_OFDM(0xE5), 0xFFF7);
>> +               }
>>        } else {
>>                b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
>>        }
>> }
>>
>> -static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
>> +static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
>> {
>>        b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
>>        b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
>>        b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
>>        if (dev->phy.rev >= 2) {
>>                b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
>> -               if (b43_current_band(dev->wl) != IEEE80211_BAND_2GHZ)
>> -                       return;
>> -               b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
>> -               b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x8);
>> +               if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
>> +                       b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
>> +                       b43_phy_set(dev, B43_PHY_OFDM(0xE5), 0x8);
>> +               }
>>        } else {
>>                b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
>>        }
>> @@ -1002,26 +1030,22 @@ static u32 lpphy_qdiv_roundup(u32 dividend, u32
>> divisor, u8 precision)
>> {
>>        u32 quotient, remainder, rbit, roundup, tmp;
>>
>> -       if (divisor == 0) {
>> -               quotient = 0;
>> -               remainder = 0;
>> -       } else {
>> -               quotient = dividend / divisor;
>> -               remainder = dividend % divisor;
>> -       }
>> +       if (divisor == 0)
>> +               return 0;
>> +
>> +       quotient = dividend / divisor;
>> +       remainder = dividend % divisor;
>>
>>        rbit = divisor & 0x1;
>>        roundup = (divisor >> 1) + rbit;
>> -       precision--;
>>
>> -       while (precision != 0xFF) {
>> +       while (precision != 0) {
>>                tmp = remainder - roundup;
>>                quotient <<= 1;
>> -               remainder <<= 1;
>> -               if (remainder >= roundup) {
>> +               if (remainder >= roundup)
>>                        remainder = (tmp << 1) + rbit;
>> -                       quotient--;
>> -               }
>> +               else
>> +                       remainder <<= 1;
>>                precision--;
>>        }
>>
>> @@ -1123,11 +1147,11 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>> *dev)
>>        struct b43_phy_lp *lpphy = dev->phy.lp;
>>        struct lpphy_iq_est iq_est;
>>        struct lpphy_tx_gains tx_gains;
>> -       static const u32 ideal_pwr_table[22] = {
>> +       static const u32 ideal_pwr_table[21] = {
>>                0x10000, 0x10557, 0x10e2d, 0x113e0, 0x10f22, 0x0ff64,
>>                0x0eda2, 0x0e5d4, 0x0efd1, 0x0fbe8, 0x0b7b8, 0x04b35,
>>                0x01a5e, 0x00a0b, 0x00444, 0x001fd, 0x000ff, 0x00088,
>> -               0x0004c, 0x0002c, 0x0001a, 0xc0006,
>> +               0x0004c, 0x0002c, 0x0001a,
>>        };
>>        bool old_txg_ovr;
>>        u8 old_bbmult;
>> @@ -1145,7 +1169,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>> *dev)
>>                       "RC calib: Failed to switch to channel 7, error = %d",
>>                       err);
>>        }
>> -       old_txg_ovr = (b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) >> 6) & 1;
>> +       old_txg_ovr = !!(b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40);
>>        old_bbmult = lpphy_get_bb_mult(dev);
>>        if (old_txg_ovr)
>>                tx_gains = lpphy_get_tx_gains(dev);
>> @@ -1160,7 +1184,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>> *dev)
>>        old_txpctl = lpphy->txpctl_mode;
>>
>>        lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
>> -       lpphy_disable_crs(dev);
>> +       lpphy_disable_crs(dev, true);
>>        loopback = lpphy_loopback(dev);
>>        if (loopback == -1)
>>                goto finish;
>> @@ -1193,7 +1217,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev
>> *dev)
>>        lpphy_stop_ddfs(dev);
>>
>> finish:
>> -       lpphy_restore_crs(dev);
>> +       lpphy_restore_crs(dev, true);
>>        b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, old_rf_ovrval);
>>        b43_phy_write(dev, B43_LPPHY_RF_OVERRIDE_0, old_rf_ovr);
>>        b43_phy_write(dev, B43_LPPHY_AFE_CTL_OVRVAL, old_afe_ovrval);
>> diff --git a/drivers/net/wireless/b43/phy_lp.h
>> b/drivers/net/wireless/b43/phy_lp.h
>> index 99cb038..e158d1f 100644
>> --- a/drivers/net/wireless/b43/phy_lp.h
>> +++ b/drivers/net/wireless/b43/phy_lp.h
>> @@ -825,11 +825,11 @@ struct b43_phy_lp {
>>        enum b43_lpphy_txpctl_mode txpctl_mode;
>>
>>        /* Transmit isolation medium band */
>> -       u8 tx_isolation_med_band; /* FIXME initial value? */
>> +       u8 tx_isolation_med_band;
>>        /* Transmit isolation low band */
>> -       u8 tx_isolation_low_band; /* FIXME initial value? */
>> +       u8 tx_isolation_low_band;
>>        /* Transmit isolation high band */
>> -       u8 tx_isolation_hi_band; /* FIXME initial value? */
>> +       u8 tx_isolation_hi_band;
>>
>>        /* Max transmit power medium band */
>>        u16 max_tx_pwr_med_band;
>> @@ -848,7 +848,7 @@ struct b43_phy_lp {
>>        s16 txpa[3], txpal[3], txpah[3];
>>
>>        /* Receive power offset */
>> -       u8 rx_pwr_offset; /* FIXME initial value? */
>> +       u8 rx_pwr_offset;
>>
>>        /* TSSI transmit count */
>>        u16 tssi_tx_count;
>> @@ -864,16 +864,16 @@ struct b43_phy_lp {
>>        s8 tx_pwr_idx_over; /* FIXME initial value? */
>>
>>        /* RSSI vf */
>> -       u8 rssi_vf; /* FIXME initial value? */
>> +       u8 rssi_vf;
>>        /* RSSI vc */
>> -       u8 rssi_vc; /* FIXME initial value? */
>> +       u8 rssi_vc;
>>        /* RSSI gs */
>> -       u8 rssi_gs; /* FIXME initial value? */
>> +       u8 rssi_gs;
>>
>>        /* RC cap */
>>        u8 rc_cap; /* FIXME initial value? */
>>        /* BX arch */
>> -       u8 bx_arch; /* FIXME initial value? */
>> +       u8 bx_arch;
>>
>>        /* Full calibration channel */
>>        u8 full_calib_chan; /* FIXME initial value? */
>> @@ -885,6 +885,8 @@ struct b43_phy_lp {
>>        /* Used for "Save/Restore Dig Filt State" */
>>        u16 dig_flt_state[9];
>>
>> +       bool crs_usr_disable, crs_sys_disable;
>> +
>>        unsigned int pdiv;
>> };
>>
>> diff --git a/drivers/net/wireless/b43/tables_lpphy.c
>> b/drivers/net/wireless/b43/tables_lpphy.c
>> index 2721310..60d472f 100644
>> --- a/drivers/net/wireless/b43/tables_lpphy.c
>> +++ b/drivers/net/wireless/b43/tables_lpphy.c
>> @@ -2367,7 +2367,17 @@ static void lpphy_rev2plus_write_gain_table(struct
>> b43_wldev *dev, int offset,
>>        tmp  = data.pad << 16;
>>        tmp |= data.pga << 8;
>>        tmp |= data.gm;
>> -       tmp |= 0x7f000000;
>> +       if (dev->phy.rev >= 3) {
>> +               if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)
>> +                       tmp |= 0x10 << 24;
>> +               else
>> +                       tmp |= 0x70 << 24;
>> +       } else {
>> +               if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)
>> +                       tmp |= 0x14 << 24;
>> +               else
>> +                       tmp |= 0x7F << 24;
>> +       }
>>        b43_lptab_write(dev, B43_LPTAB32(7, 0xC0 + offset), tmp);
>>        tmp  = data.bb_mult << 20;
>>        tmp |= data.dac << 28;
>> --
>> 1.6.2.4
>>
>>
>>
>>
>>     
>
>
>
>   



From mark.sf.net at huijgen.tk  Thu Aug 20 09:14:10 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Thu, 20 Aug 2009 09:14:10 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <69e28c910908190754p4f96f2ddhec00300a1c287f5c@mail.gmail.com>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>
	<69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com>
	<4A8BF35E.1090507@huijgen.tk>
	<1250687066.1067.25.camel@johannes.local>
	<69e28c910908190626s46fd0bfer5cc9dec9c5bb1c24@mail.gmail.com>
	<4A8C02D8.7080309@huijgen.tk>
	<69e28c910908190654v231d66c7k6a223f481f702c7c@mail.gmail.com>
	<4A8C056A.4050005@huijgen.tk>
	<69e28c910908190703h1ad7e98bqa4fe55a5fe7800e2@mail.gmail.com>
	<4A8C0B38.2020402@huijgen.tk>
	<69e28c910908190754p4f96f2ddhec00300a1c287f5c@mail.gmail.com>
Message-ID: <4A8CF7C2.30400@huijgen.tk>

G?bor Stefanik wrote:
> 2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
>   
>> To summarize, all cases with patches and new firmware:
>> case 1: cold boot with default channel 7, RC calib error and 'init
>> channel failed' error,
>> case 2: recompile+reload b43 with default channel 1, just 'init channel
>> failed' error,
>> case 3: recompile+reload b43 with default channel 7, works
>>
>>
>> You mean 'iw dev wlan0 set channel 1' for example?
>>
>> In case 2 (with default chan 1), ifconfig wlan0 gives error
>> "SIOCSIFFLAGS: Input/output error"
>>
>> # iw dev wlan0 set channel 1
>> no output generated, also nothing in dmesg
>>
>> # iw dev wlan0 scan trigger
>> command failed: Network is down (-100)
>> nothing in dmesg.
>>
>> Both commands do not give any output in dmesg in case 3 either.
>>
>> Tried channel 1 up to 11, 12 and higher gives 'command failed: Invalid
>> argument (-22)', which is expected I think.
>>     
>
> Set your regulatory domain to something that allows higher channels
> (e.g. iw reg set JP - this one unlocks channels 1-14 (14 is
> CCK/802.11b only); or iw reg set HU - channels 1-13) to test channels
> 14 and up.
>   
# iw reg set JP
[  606.879287] cfg80211: Calling CRDA for country: JP
# iw phy phy5 info
<<snip>>
                        * 2467 MHz [12] (disabled)
                        * 2472 MHz [13] (disabled)
                        * 2484 MHz [14] (disabled)
<<snip>>

# iw dev wlan0 set channel 14
command failed: Invalid argument (-22)



> Also, test this:
>
> Create a monitor interface (iw dev wlan0 interface add mon0 type monitor)
> Up the interface (ifconfig mon0 up)
> Set channel to 1 (iwconfig mon0 channel 1 or iw dev wlan0 set channel 1)
> Run tcpdump on the interface (tcpdump -i mon0).
>   
This produces quite a lot of packages, small snippet:
08:35:31.676268 171437241us tsft 1.0 Mb/s 31 MHz (0x00a0) -82dB signal
0dB noise antenna 0 [0x0000000e] Beacon ESS, PRIVACY
08:35:31.679047 171439995us tsft 1.0 Mb/s 31 MHz (0x00a0) -82dB signal
0dB noise antenna 0 [0x0000000e] Beacon ESS, PRIVACY
08:35:31.691757 171454461us tsft 1.0 Mb/s 31 MHz (0x00a0) -72dB signal
0dB noise antenna 0 [0x0000000e] Data IV:8a27a7 Pad 20 KeyID 1
08:35:31.693722 171457076us tsft 2.0 Mb/s 31 MHz (0x00a0) -58dB signal
0dB noise antenna 0 [0x0000000e] Probe Request () [1.0* 2.0* 5.5* 11.0*
9.0 18.0 36.0 54.0 Mbit]
08:35:31.710293 171472955us tsft 1.0 Mb/s 31 MHz (0x00a0) -59dB signal
0dB noise antenna 0 [0x0000000e] Beacon ESS, PRIVACY

So channel 1 does receive packets it seems. Should I be able to see data
packets from another system thats associated and downloading from my AP
on channel 1? Protected by WPA. Or are they not shown?
I don't see any, only thin I notice is the number of pkgs/second is a
lot less when I'm downloading something on the other system.

If I cycle through the channels with iw dev mon0 set channel N, all
channels give similar output in tcpdump.

> Try for other channel values as well. (You don't need to recreate the
> interface for each channel, just use the channel-setting command to
> switch the channel.) You should see packets on all channels.
>
> Another thing to try: add a printk to b43_lpphy_op_set_channel and
> print out new_channel. This will log all channel change requests
> (including automatic ones) to dmesg, which can be helpful.
>   
Done, see further down in this mail.
> If you set your AP to channel 11, can you connect to it & use it as normal?
>   
After doing my tripple module load/recompile to switch default chan from
7->1->7,
yes, then everything seems to work on channel 11. Then all reloads with
default chan 7 still work fine,
but if I try a default chan of 1 again, it fails to bring the inteface up.

I cannot connect to my AP on channel 1, since it does not show up in the
scan results (on another system right beside it, with another type of
card, it does show up and work).


With the added printk in switch channel:

After cold boot with default chan 1:
[   70.066976] b43-phy1 debug: Switching to channel: 7
[   70.071314] b43-phy1 debug: Switching to channel: 1
[   70.071808] b43-phy1 debug: Switch to init channel failed, error = -5.
[   70.071844] b43-phy1 debug: Switching to channel: 1
[   70.072341] b43-phy1 ERROR: PHY init: Channel switch to default failed

After recompile with default chan 7:
[  226.810985] b43-phy2 debug: Switching to channel: 7
[  226.815320] b43-phy2 debug: Switching to channel: 7
[  226.815632] b43-phy2 debug: Switching to channel: 7
[  226.824062] b43-phy2 debug: Chip initialized
[  226.824274] b43-phy2 debug: 64-bit DMA initialized
[  226.845588] Registered led device: b43-phy2::tx
[  226.845610] Registered led device: b43-phy2::rx
[  226.845630] Registered led device: b43-phy2::radio
[  226.845696] b43-phy2 debug: Wireless interface started
[  226.845717] b43-phy2 debug: Adding Interface type 2
[  226.845812] b43-phy2 debug: Switching to channel: 1

And a working interface.

Another cold boot, this time starting with default chan 7:
[  100.426965] b43-phy1 debug: Switching to channel: 7
[  100.431295] b43-phy1 debug: Switching to channel: 7
[  100.431607] b43-phy1 debug: Switching to channel: 7
[  100.440061] b43-phy1 debug: Chip initialized
[  100.440259] b43-phy1 debug: 64-bit DMA initialized
[  100.461545] Registered led device: b43-phy1::tx
[  100.461567] Registered led device: b43-phy1::rx
[  100.461587] Registered led device: b43-phy1::radio
[  100.461653] b43-phy1 debug: Wireless interface started
[  100.461673] b43-phy1 debug: Adding Interface type 2
[  100.461755] b43-phy1 debug: Switching to channel: 1

Working directly after boot ! Are the printk's slowing something down
enough to make it work better?
Note: phy0 is from autoloading on boot, no interface up attempts done,
just a reload with verbose=3.

Just to be sure I did another reboot, with autoloading disabled. Also
working right away with default channel 7.
Default channel 1 still no go, and also still not seeing any AP's on
channel 1 in scan results.

Mark



From mark.sf.net at huijgen.tk  Thu Aug 20 09:15:32 2009
From: mark.sf.net at huijgen.tk (Mark Huijgen)
Date: Thu, 20 Aug 2009 09:15:32 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <4A8CF7C2.30400@huijgen.tk>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com>
	<69e28c910908190428s46f3d25dnb2f2d8591f99618f@mail.gmail.com>
	<4A8BF35E.1090507@huijgen.tk>
	<1250687066.1067.25.camel@johannes.local>
	<69e28c910908190626s46fd0bfer5cc9dec9c5bb1c24@mail.gmail.com>
	<4A8C02D8.7080309@huijgen.tk>
	<69e28c910908190654v231d66c7k6a223f481f702c7c@mail.gmail.com>
	<4A8C056A.4050005@huijgen.tk>
	<69e28c910908190703h1ad7e98bqa4fe55a5fe7800e2@mail.gmail.com>
	<4A8C0B38.2020402@huijgen.tk>
	<69e28c910908190754p4f96f2ddhec00300a1c287f5c@mail.gmail.com>
	<4A8CF7C2.30400@huijgen.tk>
Message-ID: <4A8CF814.8040009@huijgen.tk>

What I forgot to mention, is that all tests in this mail were done with
the 410 firmware version.

Mark

Mark Huijgen wrote:
> G?bor Stefanik wrote:
>   
>> 2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
>>   
>>     
>>> To summarize, all cases with patches and new firmware:
>>> case 1: cold boot with default channel 7, RC calib error and 'init
>>> channel failed' error,
>>> case 2: recompile+reload b43 with default channel 1, just 'init channel
>>> failed' error,
>>> case 3: recompile+reload b43 with default channel 7, works
>>>
>>>
>>> You mean 'iw dev wlan0 set channel 1' for example?
>>>
>>> In case 2 (with default chan 1), ifconfig wlan0 gives error
>>> "SIOCSIFFLAGS: Input/output error"
>>>
>>> # iw dev wlan0 set channel 1
>>> no output generated, also nothing in dmesg
>>>
>>> # iw dev wlan0 scan trigger
>>> command failed: Network is down (-100)
>>> nothing in dmesg.
>>>
>>> Both commands do not give any output in dmesg in case 3 either.
>>>
>>> Tried channel 1 up to 11, 12 and higher gives 'command failed: Invalid
>>> argument (-22)', which is expected I think.
>>>     
>>>       
>> Set your regulatory domain to something that allows higher channels
>> (e.g. iw reg set JP - this one unlocks channels 1-14 (14 is
>> CCK/802.11b only); or iw reg set HU - channels 1-13) to test channels
>> 14 and up.
>>   
>>     
> # iw reg set JP
> [  606.879287] cfg80211: Calling CRDA for country: JP
> # iw phy phy5 info
> <<snip>>
>                         * 2467 MHz [12] (disabled)
>                         * 2472 MHz [13] (disabled)
>                         * 2484 MHz [14] (disabled)
> <<snip>>
>
> # iw dev wlan0 set channel 14
> command failed: Invalid argument (-22)
>
>
>
>   
>> Also, test this:
>>
>> Create a monitor interface (iw dev wlan0 interface add mon0 type monitor)
>> Up the interface (ifconfig mon0 up)
>> Set channel to 1 (iwconfig mon0 channel 1 or iw dev wlan0 set channel 1)
>> Run tcpdump on the interface (tcpdump -i mon0).
>>   
>>     
> This produces quite a lot of packages, small snippet:
> 08:35:31.676268 171437241us tsft 1.0 Mb/s 31 MHz (0x00a0) -82dB signal
> 0dB noise antenna 0 [0x0000000e] Beacon ESS, PRIVACY
> 08:35:31.679047 171439995us tsft 1.0 Mb/s 31 MHz (0x00a0) -82dB signal
> 0dB noise antenna 0 [0x0000000e] Beacon ESS, PRIVACY
> 08:35:31.691757 171454461us tsft 1.0 Mb/s 31 MHz (0x00a0) -72dB signal
> 0dB noise antenna 0 [0x0000000e] Data IV:8a27a7 Pad 20 KeyID 1
> 08:35:31.693722 171457076us tsft 2.0 Mb/s 31 MHz (0x00a0) -58dB signal
> 0dB noise antenna 0 [0x0000000e] Probe Request () [1.0* 2.0* 5.5* 11.0*
> 9.0 18.0 36.0 54.0 Mbit]
> 08:35:31.710293 171472955us tsft 1.0 Mb/s 31 MHz (0x00a0) -59dB signal
> 0dB noise antenna 0 [0x0000000e] Beacon ESS, PRIVACY
>
> So channel 1 does receive packets it seems. Should I be able to see data
> packets from another system thats associated and downloading from my AP
> on channel 1? Protected by WPA. Or are they not shown?
> I don't see any, only thin I notice is the number of pkgs/second is a
> lot less when I'm downloading something on the other system.
>
> If I cycle through the channels with iw dev mon0 set channel N, all
> channels give similar output in tcpdump.
>
>   
>> Try for other channel values as well. (You don't need to recreate the
>> interface for each channel, just use the channel-setting command to
>> switch the channel.) You should see packets on all channels.
>>
>> Another thing to try: add a printk to b43_lpphy_op_set_channel and
>> print out new_channel. This will log all channel change requests
>> (including automatic ones) to dmesg, which can be helpful.
>>   
>>     
> Done, see further down in this mail.
>   
>> If you set your AP to channel 11, can you connect to it & use it as normal?
>>   
>>     
> After doing my tripple module load/recompile to switch default chan from
> 7->1->7,
> yes, then everything seems to work on channel 11. Then all reloads with
> default chan 7 still work fine,
> but if I try a default chan of 1 again, it fails to bring the inteface up.
>
> I cannot connect to my AP on channel 1, since it does not show up in the
> scan results (on another system right beside it, with another type of
> card, it does show up and work).
>
>
> With the added printk in switch channel:
>
> After cold boot with default chan 1:
> [   70.066976] b43-phy1 debug: Switching to channel: 7
> [   70.071314] b43-phy1 debug: Switching to channel: 1
> [   70.071808] b43-phy1 debug: Switch to init channel failed, error = -5.
> [   70.071844] b43-phy1 debug: Switching to channel: 1
> [   70.072341] b43-phy1 ERROR: PHY init: Channel switch to default failed
>
> After recompile with default chan 7:
> [  226.810985] b43-phy2 debug: Switching to channel: 7
> [  226.815320] b43-phy2 debug: Switching to channel: 7
> [  226.815632] b43-phy2 debug: Switching to channel: 7
> [  226.824062] b43-phy2 debug: Chip initialized
> [  226.824274] b43-phy2 debug: 64-bit DMA initialized
> [  226.845588] Registered led device: b43-phy2::tx
> [  226.845610] Registered led device: b43-phy2::rx
> [  226.845630] Registered led device: b43-phy2::radio
> [  226.845696] b43-phy2 debug: Wireless interface started
> [  226.845717] b43-phy2 debug: Adding Interface type 2
> [  226.845812] b43-phy2 debug: Switching to channel: 1
>
> And a working interface.
>
> Another cold boot, this time starting with default chan 7:
> [  100.426965] b43-phy1 debug: Switching to channel: 7
> [  100.431295] b43-phy1 debug: Switching to channel: 7
> [  100.431607] b43-phy1 debug: Switching to channel: 7
> [  100.440061] b43-phy1 debug: Chip initialized
> [  100.440259] b43-phy1 debug: 64-bit DMA initialized
> [  100.461545] Registered led device: b43-phy1::tx
> [  100.461567] Registered led device: b43-phy1::rx
> [  100.461587] Registered led device: b43-phy1::radio
> [  100.461653] b43-phy1 debug: Wireless interface started
> [  100.461673] b43-phy1 debug: Adding Interface type 2
> [  100.461755] b43-phy1 debug: Switching to channel: 1
>
> Working directly after boot ! Are the printk's slowing something down
> enough to make it work better?
> Note: phy0 is from autoloading on boot, no interface up attempts done,
> just a reload with verbose=3.
>
> Just to be sure I did another reboot, with autoloading disabled. Also
> working right away with default channel 7.
> Default channel 1 still no go, and also still not seeing any AP's on
> channel 1 in scan results.
>
> Mark
>
>
>   



From netrolller.3d at gmail.com  Thu Aug 20 13:45:47 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Thu, 20 Aug 2009 13:45:47 +0200
Subject: [ANN] b43 LP-PHY support (BCM4310/4312/4315) working (partially)!
In-Reply-To: <4A8CF7C2.30400@huijgen.tk>
References: <69e28c910908181329r4b6b7cc8w3c9c0d79dda3730c@mail.gmail.com> 
	<1250687066.1067.25.camel@johannes.local>
	<69e28c910908190626s46fd0bfer5cc9dec9c5bb1c24@mail.gmail.com> 
	<4A8C02D8.7080309@huijgen.tk>
	<69e28c910908190654v231d66c7k6a223f481f702c7c@mail.gmail.com> 
	<4A8C056A.4050005@huijgen.tk>
	<69e28c910908190703h1ad7e98bqa4fe55a5fe7800e2@mail.gmail.com> 
	<4A8C0B38.2020402@huijgen.tk>
	<69e28c910908190754p4f96f2ddhec00300a1c287f5c@mail.gmail.com> 
	<4A8CF7C2.30400@huijgen.tk>
Message-ID: <69e28c910908200445p641bc99l2a2b5dc5b9a1f9dd@mail.gmail.com>

2009/8/20 Mark Huijgen <mark.sf.net at huijgen.tk>:
> G?bor Stefanik wrote:
>> 2009/8/19 Mark Huijgen <mark.sf.net at huijgen.tk>:
>>
>>> To summarize, all cases with patches and new firmware:
>>> case 1: cold boot with default channel 7, RC calib error and 'init
>>> channel failed' error,
>>> case 2: recompile+reload b43 with default channel 1, just 'init channel
>>> failed' error,
>>> case 3: recompile+reload b43 with default channel 7, works
>>>
>>>
>>> You mean 'iw dev wlan0 set channel 1' for example?
>>>
>>> In case 2 (with default chan 1), ifconfig wlan0 gives error
>>> "SIOCSIFFLAGS: Input/output error"
>>>
>>> # iw dev wlan0 set channel 1
>>> no output generated, also nothing in dmesg
>>>
>>> # iw dev wlan0 scan trigger
>>> command failed: Network is down (-100)
>>> nothing in dmesg.
>>>
>>> Both commands do not give any output in dmesg in case 3 either.
>>>
>>> Tried channel 1 up to 11, 12 and higher gives 'command failed: Invalid
>>> argument (-22)', which is expected I think.
>>>
>>
>> Set your regulatory domain to something that allows higher channels
>> (e.g. iw reg set JP - this one unlocks channels 1-14 (14 is
>> CCK/802.11b only); or iw reg set HU - channels 1-13) to test channels
>> 14 and up.
>>
> # iw reg set JP
> [ ?606.879287] cfg80211: Calling CRDA for country: JP
> # iw phy phy5 info
> <<snip>>
> ? ? ? ? ? ? ? ? ? ? ? ?* 2467 MHz [12] (disabled)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2472 MHz [13] (disabled)
> ? ? ? ? ? ? ? ? ? ? ? ?* 2484 MHz [14] (disabled)
> <<snip>>
>
> # iw dev wlan0 set channel 14
> command failed: Invalid argument (-22)
>
>
>
>> Also, test this:
>>
>> Create a monitor interface (iw dev wlan0 interface add mon0 type monitor)
>> Up the interface (ifconfig mon0 up)
>> Set channel to 1 (iwconfig mon0 channel 1 or iw dev wlan0 set channel 1)
>> Run tcpdump on the interface (tcpdump -i mon0).
>>
> This produces quite a lot of packages, small snippet:
> 08:35:31.676268 171437241us tsft 1.0 Mb/s 31 MHz (0x00a0) -82dB signal
> 0dB noise antenna 0 [0x0000000e] Beacon ESS, PRIVACY
> 08:35:31.679047 171439995us tsft 1.0 Mb/s 31 MHz (0x00a0) -82dB signal
> 0dB noise antenna 0 [0x0000000e] Beacon ESS, PRIVACY
> 08:35:31.691757 171454461us tsft 1.0 Mb/s 31 MHz (0x00a0) -72dB signal
> 0dB noise antenna 0 [0x0000000e] Data IV:8a27a7 Pad 20 KeyID 1
> 08:35:31.693722 171457076us tsft 2.0 Mb/s 31 MHz (0x00a0) -58dB signal
> 0dB noise antenna 0 [0x0000000e] Probe Request () [1.0* 2.0* 5.5* 11.0*
> 9.0 18.0 36.0 54.0 Mbit]
> 08:35:31.710293 171472955us tsft 1.0 Mb/s 31 MHz (0x00a0) -59dB signal
> 0dB noise antenna 0 [0x0000000e] Beacon ESS, PRIVACY
>
> So channel 1 does receive packets it seems. Should I be able to see data
> packets from another system thats associated and downloading from my AP
> on channel 1? Protected by WPA. Or are they not shown?
> I don't see any, only thin I notice is the number of pkgs/second is a
> lot less when I'm downloading something on the other system.
>
> If I cycle through the channels with iw dev mon0 set channel N, all
> channels give similar output in tcpdump.
>
>> Try for other channel values as well. (You don't need to recreate the
>> interface for each channel, just use the channel-setting command to
>> switch the channel.) You should see packets on all channels.
>>
>> Another thing to try: add a printk to b43_lpphy_op_set_channel and
>> print out new_channel. This will log all channel change requests
>> (including automatic ones) to dmesg, which can be helpful.
>>
> Done, see further down in this mail.
>> If you set your AP to channel 11, can you connect to it & use it as normal?
>>
> After doing my tripple module load/recompile to switch default chan from
> 7->1->7,
> yes, then everything seems to work on channel 11. Then all reloads with
> default chan 7 still work fine,
> but if I try a default chan of 1 again, it fails to bring the inteface up.
>
> I cannot connect to my AP on channel 1, since it does not show up in the
> scan results (on another system right beside it, with another type of
> card, it does show up and work).
>
>
> With the added printk in switch channel:
>
> After cold boot with default chan 1:
> [ ? 70.066976] b43-phy1 debug: Switching to channel: 7
> [ ? 70.071314] b43-phy1 debug: Switching to channel: 1
> [ ? 70.071808] b43-phy1 debug: Switch to init channel failed, error = -5.
> [ ? 70.071844] b43-phy1 debug: Switching to channel: 1
> [ ? 70.072341] b43-phy1 ERROR: PHY init: Channel switch to default failed
>
> After recompile with default chan 7:
> [ ?226.810985] b43-phy2 debug: Switching to channel: 7
> [ ?226.815320] b43-phy2 debug: Switching to channel: 7
> [ ?226.815632] b43-phy2 debug: Switching to channel: 7
> [ ?226.824062] b43-phy2 debug: Chip initialized
> [ ?226.824274] b43-phy2 debug: 64-bit DMA initialized
> [ ?226.845588] Registered led device: b43-phy2::tx
> [ ?226.845610] Registered led device: b43-phy2::rx
> [ ?226.845630] Registered led device: b43-phy2::radio
> [ ?226.845696] b43-phy2 debug: Wireless interface started
> [ ?226.845717] b43-phy2 debug: Adding Interface type 2
> [ ?226.845812] b43-phy2 debug: Switching to channel: 1
>
> And a working interface.
>
> Another cold boot, this time starting with default chan 7:
> [ ?100.426965] b43-phy1 debug: Switching to channel: 7
> [ ?100.431295] b43-phy1 debug: Switching to channel: 7
> [ ?100.431607] b43-phy1 debug: Switching to channel: 7
> [ ?100.440061] b43-phy1 debug: Chip initialized
> [ ?100.440259] b43-phy1 debug: 64-bit DMA initialized
> [ ?100.461545] Registered led device: b43-phy1::tx
> [ ?100.461567] Registered led device: b43-phy1::rx
> [ ?100.461587] Registered led device: b43-phy1::radio
> [ ?100.461653] b43-phy1 debug: Wireless interface started
> [ ?100.461673] b43-phy1 debug: Adding Interface type 2
> [ ?100.461755] b43-phy1 debug: Switching to channel: 1

Could you add a printk to the error path in the channel tune process
for B2062? I'm not sure at all if this channel switch succeeds or
not...

>
> Working directly after boot ! Are the printk's slowing something down
> enough to make it work better?
> Note: phy0 is from autoloading on boot, no interface up attempts done,
> just a reload with verbose=3.
>
> Just to be sure I did another reboot, with autoloading disabled. Also
> working right away with default channel 7.
> Default channel 1 still no go, and also still not seeing any AP's on
> channel 1 in scan results.
>
> Mark
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Thu Aug 20 15:34:39 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 20 Aug 2009 15:34:39 +0200
Subject: [PATCHv4] b43 add harware tkip
In-Reply-To: <83a869cd0908191335u723f62c6p119ec4ed8cfb51c5@mail.gmail.com>
References: <83a869cd0908191335u723f62c6p119ec4ed8cfb51c5@mail.gmail.com>
Message-ID: <200908201534.39671.mb@bu3sch.de>

On Wednesday 19 August 2009 22:35:45 gregor kowski wrote:
> Update v4 : add a warn_on in b43_op_update_tkip_key, update to last
> driver change (key API).
> Update v3 : add a module parameter to enable hw tkip, Coding style
> fix, locking fix
> Update v2 : work with qos, implement dump key, fix an issue with setting
> random value on tkip key clear.
> 
> This add hardware tkip for b43.
> 
> Signed-off-by: Gregor Kowski <gregor.kowski at gmail.com>

Acked-by: Michael Buesch <mb at bu3sch.de>

-- 
Greetings, Michael.


From linville at tuxdriver.com  Thu Aug 20 16:46:50 2009
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 20 Aug 2009 10:46:50 -0400
Subject: [PATCH] b43: LP-PHY: Implement spec updates and remove
	resolved FIXMEs
In-Reply-To: <69e28c910908191514w3073d382x927062038f2bb128@mail.gmail.com>
References: <4A8AE255.9030102@gmail.com>
	<69e28c910908191514w3073d382x927062038f2bb128@mail.gmail.com>
Message-ID: <20090820144649.GA2657@tuxdriver.com>

On Thu, Aug 20, 2009 at 12:14:13AM +0200, G?bor Stefanik wrote:
> Seeing that this is still not in wireless-testing - this patch should
> be applied, the previously mentioned regressions were false alerts
> (Larry tested without this patch and with v478 firmware, which worked;
> while Mark applied this patch and used v410 firmware, which didn't
> work - when Mark upgraded to v478 firmware, his card too came to
> life.) So, please apply.

You posted the above slightly more than 7 hours after the "false alert"
message below.

> Date: Wed, 19 Aug 2009 16:57:37 +0200
> From: G?bor Stefanik <netrolller.3d at gmail.com>
> To: John Linville <linville at tuxdriver.com>, Michael Buesch <mb at bu3sch.de>,
>         Larry Finger <Larry.Finger at lwfinger.net>
> Cc: Mark Huijgen <mark at huijgen.tk>,
>         Broadcom Wireless <bcm43xx-dev at lists.berlios.de>,
>         linux-wireless <linux-wireless at vger.kernel.org>
> Subject: Re: [PATCH] b43: LP-PHY: Implement spec updates and remove resolved
>         FIXMEs
> 
> False alert, sorry. Feel free to apply. The "regression" apparently
> resulted from the use of an incorrect firmware image - when Mark
> switched to the same firmware as Larry, his card started working
> again.

It seems that you think I am a little gnome that sustains itself on email and
git, but I assure you that I am not.  I have other things to do.

I am truly glad that you have taken-up the cause of LP-PHY support
for b43.  Nevertheless, being heckled by you does nothing to make me
want to merge your patches any faster.

John
-- 
John W. Linville		Someday the world will need a hero, and you
linville at tuxdriver.com			might be all we have.  Be ready.


From linville at tuxdriver.com  Thu Aug 20 16:52:13 2009
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 20 Aug 2009 10:52:13 -0400
Subject: [RESEND] [PATCH] b43 : remove old kidx API
In-Reply-To: <83a869cd0907271343g6111794ejff963258a52f546@mail.gmail.com>
References: <83a869cd0907271343g6111794ejff963258a52f546@mail.gmail.com>
Message-ID: <20090820145213.GB2657@tuxdriver.com>

On Mon, Jul 27, 2009 at 10:43:36PM +0200, gregor kowski wrote:
> Remove old kidx API.
> This simplify the code, and fix a potential key overflow.
> 
> Signed-off-by: Gregor Kowski <gregor.kowski at gmail.com>

Is this patch still relevant?  If so, could you repost a version that
isn't whitespace damaged and that actually applies?

John
-- 
John W. Linville		Someday the world will need a hero, and you
linville at tuxdriver.com			might be all we have.  Be ready.


From mb at bu3sch.de  Thu Aug 20 19:15:13 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 20 Aug 2009 19:15:13 +0200
Subject: [RESEND] [PATCH] b43 : remove old kidx API
In-Reply-To: <20090820145213.GB2657@tuxdriver.com>
References: <83a869cd0907271343g6111794ejff963258a52f546@mail.gmail.com>
	<20090820145213.GB2657@tuxdriver.com>
Message-ID: <200908201915.13498.mb@bu3sch.de>

On Thursday 20 August 2009 16:52:13 John W. Linville wrote:
> On Mon, Jul 27, 2009 at 10:43:36PM +0200, gregor kowski wrote:
> > Remove old kidx API.
> > This simplify the code, and fix a potential key overflow.
> > 
> > Signed-off-by: Gregor Kowski <gregor.kowski at gmail.com>
> 
> Is this patch still relevant?

no 

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Thu Aug 20 19:30:11 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 20 Aug 2009 12:30:11 -0500
Subject: [PATCH 1/2] fwcutter: mklist.py - Update to new library and skip
	some sections
Message-ID: <4a8d8823.Rxh3mPs5jA5wl7Sw%Larry.Finger@lwfinger.net>

Switch from the deprecated md5 library to hashlib.

Detect the ro section that describes the firmware version,
print the address of the data, and and skip some ro sections
that are not of interest.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: fwcutter/mklist.py
===================================================================
--- fwcutter.orig/mklist.py
+++ fwcutter/mklist.py
@@ -30,7 +30,7 @@
 import sys
 import os
 import re
-import md5
+import hashlib
 
 if len(sys.argv) != 2:
 	print "Usage: %s path/to/wl.o" % sys.argv[0]
@@ -55,7 +55,7 @@ if rodata_fileoffset == None:
 	print "ERROR: Could not find .rodata fileoffset"
 	sys.exit(1)
 
-md5sum = md5.md5(file(fn, "r").read())
+md5sum = hashlib.md5(file(fn, "r").read())
 
 print "static struct extract _%s[] =" % md5sum.hexdigest()
 print "{"
@@ -80,6 +80,14 @@ for sym in syms:
 		size -= 8
 	if "pcm" in name:
 		type = "EXT_PCM"
+	if "bommajor" in name:
+		print "\t/* ucode major version at offset 0x%x */" % pos
+		continue
+	if "bomminor" in name:
+		print "\t/* ucode minor version at offset 0x%x */" % pos
+		continue
+	if "ucode_2w" in name:
+		continue
 	m = ucode_re.match(name)
 	if m:
 		corerev = int(m.group(1))




From Larry.Finger at lwfinger.net  Thu Aug 20 19:32:43 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 20 Aug 2009 12:32:43 -0500
Subject: [PATCH 2/2] fwcutter: Add two new sources for 478.104 firmware
Message-ID: <4a8d88bb.SSSlMg2BFVUEaHyt%Larry.Finger@lwfinger.net>

Add 2 new files with 478.104 firmware, which includes Rev 16.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: fwcutter/fwcutter_list.h
===================================================================
--- fwcutter.orig/fwcutter_list.h
+++ fwcutter/fwcutter_list.h
@@ -238,7 +238,106 @@ static struct extract _2dd738b8feb8b3559
 	EXTRACT_LIST_END
 };
 
-/*
+static struct extract _1a258b2d93efa641c32ddf3c3a962028[] =
+{
+	/* { .name = "ucode4", .offset = 0xAFE08, .type = EXT_UCODE_1, .length = 0x4EA0 }, */
+	/* { .name = "pcm4", .offset = 0xE8FE0, .type = EXT_PCM, .length = 0x520 }, */
+	/* { .name = "b0g0initvals4", .offset = 0xA2878, .type = EXT_IV, .length = 0xE80 }, */
+	/* { .name = "a0g0bsinitvals4", .offset = 0xA45C0, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "b0g0bsinitvals4", .offset = 0xA3700, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "a0g0initvals4", .offset = 0xA3738, .type = EXT_IV, .length = 0xE80 }, */
+	{ .name = "ucode5", .offset = 0xB4CAC, .type = EXT_UCODE_2, .length = 0x56F0 },
+	{ .name = "pcm5", .offset = 0xE9504, .type = EXT_PCM, .length = 0x520 },
+	{ .name = "a0g0bsinitvals5", .offset = 0xA6578, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals5", .offset = 0xA5018, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0initvals5", .offset = 0xA5138, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1initvals5", .offset = 0xA5B58, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "b0g0initvals5", .offset = 0xA45F8, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1bsinitvals5", .offset = 0xA6698, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode9", .offset = 0xBA3A0, .type = EXT_UCODE_2, .length = 0x6248 },
+	{ .name = "a0g0bsinitvals9", .offset = 0xA89C0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals9", .offset = 0xA67B8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g1bsinitvals9", .offset = 0xA8AE0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals9", .offset = 0xA72B0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0initvals9", .offset = 0xA73D0, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g1initvals9", .offset = 0xA7EC8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "ucode11", .offset = 0xC05EC, .type = EXT_UCODE_2, .length = 0x8000 },
+	{ .name = "n0initvals11", .offset = 0xA8C00, .type = EXT_IV, .length = 0xBC8 },
+	{ .name = "n0bsinitvals11", .offset = 0xA97D0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0absinitvals11", .offset = 0xA98F0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode13", .offset = 0xC85F0, .type = EXT_UCODE_2, .length = 0x7AC8 },
+	{ .name = "b0g0bsinitvals13", .offset = 0xABA70, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals13", .offset = 0xAAED0, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "a0g1bsinitvals13", .offset = 0xAC730, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g1initvals13", .offset = 0xABB90, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "lp0bsinitvals13", .offset = 0xAADB0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "lp0initvals13", .offset = 0xA9A10, .type = EXT_IV, .length = 0x1398 },
+	{ .name = "ucode14", .offset = 0xD00BC, .type = EXT_UCODE_2, .length = 0x7910 },
+	{ .name = "lp0initvals14", .offset = 0xAC850, .type = EXT_IV, .length = 0xB80 },
+	{ .name = "lp0bsinitvals14", .offset = 0xAD3D8, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode15", .offset = 0xD79D0, .type = EXT_UCODE_3, .length = 0x8768 },
+	{ .name = "lp0initvals15", .offset = 0xAD4F8, .type = EXT_IV, .length = 0xC68 },
+	{ .name = "lp0bsinitvals15", .offset = 0xAE168, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode16", .offset = 0xE013C, .type = EXT_UCODE_3, .length = 0x8EA0 },
+	{ .name = "lp0bsinitvals16", .offset = 0xAFCE8, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0bsinitvals16", .offset = 0xAEF20, .type = EXT_IV, .length = 0x118 },
+	{ .name = "sslpn0initvals16", .offset = 0xAF040, .type = EXT_IV, .length = 0x0 },
+	{ .name = "n0initvals16", .offset = 0xAE288, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "lp0initvals16", .offset = 0xAF050, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "sslpn0bsinitvals16", .offset = 0xAF048, .type = EXT_IV, .length = 0x0 },
+	EXTRACT_LIST_END
+};
+static struct extract _bb8537e3204a1ea5903fe3e66b5e2763[] =
+{
+	/* ucode major version at offset 0xa8b70 */
+	/* ucode minor version at offset 0xa8b74 */
+	/* { .name = "ucode4", .offset = 0xB6108, .type = EXT_UCODE_1, .length = 0x4EA0 }, */
+	/* { .name = "pcm4", .offset = 0xEF2E0, .type = EXT_PCM, .length = 0x520 }, */
+	/* { .name = "b0g0initvals4", .offset = 0xA8B78, .type = EXT_IV, .length = 0xE80 }, */
+	/* { .name = "a0g0bsinitvals4", .offset = 0xAA8C0, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "b0g0bsinitvals4", .offset = 0xA9A00, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "a0g0initvals4", .offset = 0xA9A38, .type = EXT_IV, .length = 0xE80 }, */
+	{ .name = "ucode5", .offset = 0xBAFAC, .type = EXT_UCODE_2, .length = 0x56F0 },
+	{ .name = "pcm5", .offset = 0xEF804, .type = EXT_PCM, .length = 0x520 },
+	{ .name = "b0g0bsinitvals5", .offset = 0xAB318, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0bsinitvals5", .offset = 0xAC878, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals5", .offset = 0xAA8F8, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1initvals5", .offset = 0xABE58, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g0initvals5", .offset = 0xAB438, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1bsinitvals5", .offset = 0xAC998, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode9", .offset = 0xC06A0, .type = EXT_UCODE_2, .length = 0x6248 },
+	{ .name = "a0g1initvals9", .offset = 0xAE1C8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g0bsinitvals9", .offset = 0xAECC0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals9", .offset = 0xAD5B0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals9", .offset = 0xACAB8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g1bsinitvals9", .offset = 0xAEDE0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0initvals9", .offset = 0xAD6D0, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "ucode11", .offset = 0xC68EC, .type = EXT_UCODE_2, .length = 0x8000 },
+	{ .name = "n0bsinitvals11", .offset = 0xAFAD0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0absinitvals11", .offset = 0xAFBF0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0initvals11", .offset = 0xAEF00, .type = EXT_IV, .length = 0xBC8 },
+	{ .name = "ucode13", .offset = 0xCE8F0, .type = EXT_UCODE_2, .length = 0x7AC8 },
+	{ .name = "b0g0initvals13", .offset = 0xB11D0, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "a0g1bsinitvals13", .offset = 0xB2A30, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g1initvals13", .offset = 0xB1E90, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "lp0bsinitvals13", .offset = 0xB10B0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals13", .offset = 0xB1D70, .type = EXT_IV, .length = 0x118 },
+	{ .name = "lp0initvals13", .offset = 0xAFD10, .type = EXT_IV, .length = 0x1398 },
+	{ .name = "ucode14", .offset = 0xD63BC, .type = EXT_UCODE_2, .length = 0x7910 },
+	{ .name = "lp0initvals14", .offset = 0xB2B50, .type = EXT_IV, .length = 0xB80 },
+	{ .name = "lp0bsinitvals14", .offset = 0xB36D8, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode15", .offset = 0xDDCD0, .type = EXT_UCODE_3, .length = 0x8768 },
+	{ .name = "lp0bsinitvals15", .offset = 0xB4468, .type = EXT_IV, .length = 0x118 },
+	{ .name = "lp0initvals15", .offset = 0xB37F8, .type = EXT_IV, .length = 0xC68 },
+	{ .name = "ucode16", .offset = 0xE643C, .type = EXT_UCODE_3, .length = 0x8EA0 },
+	{ .name = "n0bsinitvals16", .offset = 0xB5220, .type = EXT_IV, .length = 0x118 },
+	{ .name = "sslpn0initvals16", .offset = 0xB5340, .type = EXT_IV, .length = 0x0 },
+	{ .name = "n0initvals16", .offset = 0xB4588, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "lp0initvals16", .offset = 0xB5350, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "sslpn0bsinitvals16", .offset = 0xB5348, .type = EXT_IV, .length = 0x0 },
+	{ .name = "lp0bsinitvals16", .offset = 0xB5FE8, .type = EXT_IV, .length = 0x118 },
+	EXTRACT_LIST_END
+};/*
  * Links change, so let's not put them into the README.
  * I still put them here so we know where the file was obtained.
  */
@@ -299,6 +398,24 @@ static const struct file files[] =
 		.flags		= FW_FLAG_LE | FW_FLAG_V4 | FW_FLAG_UNSUPPORTED,
 		.extract	= _2dd738b8feb8b3559fd9d8fbaf3bfffc,
 	},
+	{
+		/* ftp://downloads.netgear.com/files/GPL/WNDR3300-V1.0.29_gpl_src.zip */
+		.name		= "wl_apsta.o",
+		.id		= "FW14",
+		.ucode_version	= "478.104",
+		.md5		= "1a258b2d93efa641c32ddf3c3a962028",
+		.flags		= FW_FLAG_LE | FW_FLAG_V4,
+		.extract	= _1a258b2d93efa641c32ddf3c3a962028,
+	},
+	{
+		/* http://downloads.openwrt.org/sources/broadcom-wl-4.178.10.4.tar.bz2 */
+		.name		= "wl_apsta.o",
+		.id		= "FW14",
+		.ucode_version	= "478.104",
+		.md5		= "bb8537e3204a1ea5903fe3e66b5e2763",
+		.flags		= FW_FLAG_LE | FW_FLAG_V4,
+		.extract	= _bb8537e3204a1ea5903fe3e66b5e2763,
+	},
 };
 
 #define FILES (sizeof(files) / sizeof(files[0]))


From mb at bu3sch.de  Thu Aug 20 20:05:10 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 20 Aug 2009 20:05:10 +0200
Subject: [PATCH 2/2] fwcutter: Add two new sources for 478.104 firmware
In-Reply-To: <4a8d88bb.SSSlMg2BFVUEaHyt%Larry.Finger@lwfinger.net>
References: <4a8d88bb.SSSlMg2BFVUEaHyt%Larry.Finger@lwfinger.net>
Message-ID: <200908202005.10283.mb@bu3sch.de>

On Thursday 20 August 2009 19:32:43 Larry Finger wrote:
> +		.id		= "FW14",

> +		.id		= "FW14",

Is the extracted firmware exactly binary equal to the existing FW14? (We should not
trust their version numbers and doublecheck this)

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Thu Aug 20 20:16:55 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 20 Aug 2009 13:16:55 -0500
Subject: [PATCH 2/2] fwcutter: Add two new sources for 478.104 firmware
In-Reply-To: <200908202005.10283.mb@bu3sch.de>
References: <4a8d88bb.SSSlMg2BFVUEaHyt%Larry.Finger@lwfinger.net>
	<200908202005.10283.mb@bu3sch.de>
Message-ID: <4A8D9317.4030903@lwfinger.net>

Michael Buesch wrote:
> On Thursday 20 August 2009 19:32:43 Larry Finger wrote:
>> +		.id		= "FW14",
> 
>> +		.id		= "FW14",
> 
> Is the extracted firmware exactly binary equal to the existing FW14? (We should not
> trust their version numbers and doublecheck this)

How does one check this? Any way but a binary comparison? These two
files do include the Rev 16 microcode, which was not present in the
4.150.10.15 driver.

As you probably guessed, I just copied these strings from an earlier
driver.

Larry


From mb at bu3sch.de  Thu Aug 20 20:25:14 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 20 Aug 2009 20:25:14 +0200
Subject: [PATCH 2/2] fwcutter: Add two new sources for 478.104 firmware
In-Reply-To: <4A8D9317.4030903@lwfinger.net>
References: <4a8d88bb.SSSlMg2BFVUEaHyt%Larry.Finger@lwfinger.net>
	<200908202005.10283.mb@bu3sch.de> <4A8D9317.4030903@lwfinger.net>
Message-ID: <200908202025.14276.mb@bu3sch.de>

On Thursday 20 August 2009 20:16:55 Larry Finger wrote:
> Michael Buesch wrote:
> > On Thursday 20 August 2009 19:32:43 Larry Finger wrote:
> >> +		.id		= "FW14",
> > 
> >> +		.id		= "FW14",
> > 
> > Is the extracted firmware exactly binary equal to the existing FW14? (We should not
> > trust their version numbers and doublecheck this)
> 
> How does one check this? Any way but a binary comparison? These two
> files do include the Rev 16 microcode, which was not present in the
> 4.150.10.15 driver.

Then these files are not binary equal to FW14, right?
So call them FW15. (If these two added files are in fact identical. Otherwise call them FW15 and FW16).

The FW ID is supposed to be a unique identifier for a set of firmware files.
So the number of files, their names and their content must exactly match to get the same ID.

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Thu Aug 20 22:04:33 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 20 Aug 2009 15:04:33 -0500
Subject: [PATCH 2/2 V2] fwcutter: Add two new sources for 478.104 firmware
Message-ID: <4a8dac51.RGF2gsHfAA3iJ5/v%Larry.Finger@lwfinger.net>

Add 2 new files with 478.104 firmware, which includes Rev 16.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---
V2 - New files are FW15.

Index: fwcutter/fwcutter_list.h
===================================================================
--- fwcutter.orig/fwcutter_list.h
+++ fwcutter/fwcutter_list.h
@@ -238,7 +238,106 @@ static struct extract _2dd738b8feb8b3559
 	EXTRACT_LIST_END
 };
 
-/*
+static struct extract _1a258b2d93efa641c32ddf3c3a962028[] =
+{
+	/* { .name = "ucode4", .offset = 0xAFE08, .type = EXT_UCODE_1, .length = 0x4EA0 }, */
+	/* { .name = "pcm4", .offset = 0xE8FE0, .type = EXT_PCM, .length = 0x520 }, */
+	/* { .name = "b0g0initvals4", .offset = 0xA2878, .type = EXT_IV, .length = 0xE80 }, */
+	/* { .name = "a0g0bsinitvals4", .offset = 0xA45C0, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "b0g0bsinitvals4", .offset = 0xA3700, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "a0g0initvals4", .offset = 0xA3738, .type = EXT_IV, .length = 0xE80 }, */
+	{ .name = "ucode5", .offset = 0xB4CAC, .type = EXT_UCODE_2, .length = 0x56F0 },
+	{ .name = "pcm5", .offset = 0xE9504, .type = EXT_PCM, .length = 0x520 },
+	{ .name = "a0g0bsinitvals5", .offset = 0xA6578, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals5", .offset = 0xA5018, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0initvals5", .offset = 0xA5138, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1initvals5", .offset = 0xA5B58, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "b0g0initvals5", .offset = 0xA45F8, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1bsinitvals5", .offset = 0xA6698, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode9", .offset = 0xBA3A0, .type = EXT_UCODE_2, .length = 0x6248 },
+	{ .name = "a0g0bsinitvals9", .offset = 0xA89C0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals9", .offset = 0xA67B8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g1bsinitvals9", .offset = 0xA8AE0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals9", .offset = 0xA72B0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0initvals9", .offset = 0xA73D0, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g1initvals9", .offset = 0xA7EC8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "ucode11", .offset = 0xC05EC, .type = EXT_UCODE_2, .length = 0x8000 },
+	{ .name = "n0initvals11", .offset = 0xA8C00, .type = EXT_IV, .length = 0xBC8 },
+	{ .name = "n0bsinitvals11", .offset = 0xA97D0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0absinitvals11", .offset = 0xA98F0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode13", .offset = 0xC85F0, .type = EXT_UCODE_2, .length = 0x7AC8 },
+	{ .name = "b0g0bsinitvals13", .offset = 0xABA70, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals13", .offset = 0xAAED0, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "a0g1bsinitvals13", .offset = 0xAC730, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g1initvals13", .offset = 0xABB90, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "lp0bsinitvals13", .offset = 0xAADB0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "lp0initvals13", .offset = 0xA9A10, .type = EXT_IV, .length = 0x1398 },
+	{ .name = "ucode14", .offset = 0xD00BC, .type = EXT_UCODE_2, .length = 0x7910 },
+	{ .name = "lp0initvals14", .offset = 0xAC850, .type = EXT_IV, .length = 0xB80 },
+	{ .name = "lp0bsinitvals14", .offset = 0xAD3D8, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode15", .offset = 0xD79D0, .type = EXT_UCODE_3, .length = 0x8768 },
+	{ .name = "lp0initvals15", .offset = 0xAD4F8, .type = EXT_IV, .length = 0xC68 },
+	{ .name = "lp0bsinitvals15", .offset = 0xAE168, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode16", .offset = 0xE013C, .type = EXT_UCODE_3, .length = 0x8EA0 },
+	{ .name = "lp0bsinitvals16", .offset = 0xAFCE8, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0bsinitvals16", .offset = 0xAEF20, .type = EXT_IV, .length = 0x118 },
+	{ .name = "sslpn0initvals16", .offset = 0xAF040, .type = EXT_IV, .length = 0x0 },
+	{ .name = "n0initvals16", .offset = 0xAE288, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "lp0initvals16", .offset = 0xAF050, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "sslpn0bsinitvals16", .offset = 0xAF048, .type = EXT_IV, .length = 0x0 },
+	EXTRACT_LIST_END
+};
+static struct extract _bb8537e3204a1ea5903fe3e66b5e2763[] =
+{
+	/* ucode major version at offset 0xa8b70 */
+	/* ucode minor version at offset 0xa8b74 */
+	/* { .name = "ucode4", .offset = 0xB6108, .type = EXT_UCODE_1, .length = 0x4EA0 }, */
+	/* { .name = "pcm4", .offset = 0xEF2E0, .type = EXT_PCM, .length = 0x520 }, */
+	/* { .name = "b0g0initvals4", .offset = 0xA8B78, .type = EXT_IV, .length = 0xE80 }, */
+	/* { .name = "a0g0bsinitvals4", .offset = 0xAA8C0, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "b0g0bsinitvals4", .offset = 0xA9A00, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "a0g0initvals4", .offset = 0xA9A38, .type = EXT_IV, .length = 0xE80 }, */
+	{ .name = "ucode5", .offset = 0xBAFAC, .type = EXT_UCODE_2, .length = 0x56F0 },
+	{ .name = "pcm5", .offset = 0xEF804, .type = EXT_PCM, .length = 0x520 },
+	{ .name = "b0g0bsinitvals5", .offset = 0xAB318, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0bsinitvals5", .offset = 0xAC878, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals5", .offset = 0xAA8F8, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1initvals5", .offset = 0xABE58, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g0initvals5", .offset = 0xAB438, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1bsinitvals5", .offset = 0xAC998, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode9", .offset = 0xC06A0, .type = EXT_UCODE_2, .length = 0x6248 },
+	{ .name = "a0g1initvals9", .offset = 0xAE1C8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g0bsinitvals9", .offset = 0xAECC0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals9", .offset = 0xAD5B0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals9", .offset = 0xACAB8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g1bsinitvals9", .offset = 0xAEDE0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0initvals9", .offset = 0xAD6D0, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "ucode11", .offset = 0xC68EC, .type = EXT_UCODE_2, .length = 0x8000 },
+	{ .name = "n0bsinitvals11", .offset = 0xAFAD0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0absinitvals11", .offset = 0xAFBF0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0initvals11", .offset = 0xAEF00, .type = EXT_IV, .length = 0xBC8 },
+	{ .name = "ucode13", .offset = 0xCE8F0, .type = EXT_UCODE_2, .length = 0x7AC8 },
+	{ .name = "b0g0initvals13", .offset = 0xB11D0, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "a0g1bsinitvals13", .offset = 0xB2A30, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g1initvals13", .offset = 0xB1E90, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "lp0bsinitvals13", .offset = 0xB10B0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals13", .offset = 0xB1D70, .type = EXT_IV, .length = 0x118 },
+	{ .name = "lp0initvals13", .offset = 0xAFD10, .type = EXT_IV, .length = 0x1398 },
+	{ .name = "ucode14", .offset = 0xD63BC, .type = EXT_UCODE_2, .length = 0x7910 },
+	{ .name = "lp0initvals14", .offset = 0xB2B50, .type = EXT_IV, .length = 0xB80 },
+	{ .name = "lp0bsinitvals14", .offset = 0xB36D8, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode15", .offset = 0xDDCD0, .type = EXT_UCODE_3, .length = 0x8768 },
+	{ .name = "lp0bsinitvals15", .offset = 0xB4468, .type = EXT_IV, .length = 0x118 },
+	{ .name = "lp0initvals15", .offset = 0xB37F8, .type = EXT_IV, .length = 0xC68 },
+	{ .name = "ucode16", .offset = 0xE643C, .type = EXT_UCODE_3, .length = 0x8EA0 },
+	{ .name = "n0bsinitvals16", .offset = 0xB5220, .type = EXT_IV, .length = 0x118 },
+	{ .name = "sslpn0initvals16", .offset = 0xB5340, .type = EXT_IV, .length = 0x0 },
+	{ .name = "n0initvals16", .offset = 0xB4588, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "lp0initvals16", .offset = 0xB5350, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "sslpn0bsinitvals16", .offset = 0xB5348, .type = EXT_IV, .length = 0x0 },
+	{ .name = "lp0bsinitvals16", .offset = 0xB5FE8, .type = EXT_IV, .length = 0x118 },
+	EXTRACT_LIST_END
+};/*
  * Links change, so let's not put them into the README.
  * I still put them here so we know where the file was obtained.
  */
@@ -299,6 +398,24 @@ static const struct file files[] =
 		.flags		= FW_FLAG_LE | FW_FLAG_V4 | FW_FLAG_UNSUPPORTED,
 		.extract	= _2dd738b8feb8b3559fd9d8fbaf3bfffc,
 	},
+	{
+		/* ftp://downloads.netgear.com/files/GPL/WNDR3300-V1.0.29_gpl_src.zip */
+		.name		= "wl_apsta.o",
+		.id		= "FW15",
+		.ucode_version	= "478.104",
+		.md5		= "1a258b2d93efa641c32ddf3c3a962028",
+		.flags		= FW_FLAG_LE | FW_FLAG_V4,
+		.extract	= _1a258b2d93efa641c32ddf3c3a962028,
+	},
+	{
+		/* http://downloads.openwrt.org/sources/broadcom-wl-4.178.10.4.tar.bz2 */
+		.name		= "wl_apsta.o",
+		.id		= "FW15",
+		.ucode_version	= "478.104",
+		.md5		= "bb8537e3204a1ea5903fe3e66b5e2763",
+		.flags		= FW_FLAG_LE | FW_FLAG_V4,
+		.extract	= _bb8537e3204a1ea5903fe3e66b5e2763,
+	},
 };
 
 #define FILES (sizeof(files) / sizeof(files[0]))


From Larry.Finger at lwfinger.net  Thu Aug 20 23:51:38 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 20 Aug 2009 16:51:38 -0500
Subject: [PATCH 2/2 V2] fwcutter: Add two new sources for 478.104 firmware
Message-ID: <4a8dc56a.VoVfisnS1440Qve6%Larry.Finger@lwfinger.net>

Add 2 new files with 478.104 firmware, which includes Rev 16.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---
V2 - New files are FW15.

Index: fwcutter/fwcutter_list.h
===================================================================
--- fwcutter.orig/fwcutter_list.h
+++ fwcutter/fwcutter_list.h
@@ -238,7 +238,106 @@ static struct extract _2dd738b8feb8b3559
 	EXTRACT_LIST_END
 };
 
-/*
+static struct extract _1a258b2d93efa641c32ddf3c3a962028[] =
+{
+	/* { .name = "ucode4", .offset = 0xAFE08, .type = EXT_UCODE_1, .length = 0x4EA0 }, */
+	/* { .name = "pcm4", .offset = 0xE8FE0, .type = EXT_PCM, .length = 0x520 }, */
+	/* { .name = "b0g0initvals4", .offset = 0xA2878, .type = EXT_IV, .length = 0xE80 }, */
+	/* { .name = "a0g0bsinitvals4", .offset = 0xA45C0, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "b0g0bsinitvals4", .offset = 0xA3700, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "a0g0initvals4", .offset = 0xA3738, .type = EXT_IV, .length = 0xE80 }, */
+	{ .name = "ucode5", .offset = 0xB4CAC, .type = EXT_UCODE_2, .length = 0x56F0 },
+	{ .name = "pcm5", .offset = 0xE9504, .type = EXT_PCM, .length = 0x520 },
+	{ .name = "a0g0bsinitvals5", .offset = 0xA6578, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals5", .offset = 0xA5018, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0initvals5", .offset = 0xA5138, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1initvals5", .offset = 0xA5B58, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "b0g0initvals5", .offset = 0xA45F8, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1bsinitvals5", .offset = 0xA6698, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode9", .offset = 0xBA3A0, .type = EXT_UCODE_2, .length = 0x6248 },
+	{ .name = "a0g0bsinitvals9", .offset = 0xA89C0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals9", .offset = 0xA67B8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g1bsinitvals9", .offset = 0xA8AE0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals9", .offset = 0xA72B0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0initvals9", .offset = 0xA73D0, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g1initvals9", .offset = 0xA7EC8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "ucode11", .offset = 0xC05EC, .type = EXT_UCODE_2, .length = 0x8000 },
+	{ .name = "n0initvals11", .offset = 0xA8C00, .type = EXT_IV, .length = 0xBC8 },
+	{ .name = "n0bsinitvals11", .offset = 0xA97D0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0absinitvals11", .offset = 0xA98F0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode13", .offset = 0xC85F0, .type = EXT_UCODE_2, .length = 0x7AC8 },
+	{ .name = "b0g0bsinitvals13", .offset = 0xABA70, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals13", .offset = 0xAAED0, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "a0g1bsinitvals13", .offset = 0xAC730, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g1initvals13", .offset = 0xABB90, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "lp0bsinitvals13", .offset = 0xAADB0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "lp0initvals13", .offset = 0xA9A10, .type = EXT_IV, .length = 0x1398 },
+	{ .name = "ucode14", .offset = 0xD00BC, .type = EXT_UCODE_2, .length = 0x7910 },
+	{ .name = "lp0initvals14", .offset = 0xAC850, .type = EXT_IV, .length = 0xB80 },
+	{ .name = "lp0bsinitvals14", .offset = 0xAD3D8, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode15", .offset = 0xD79D0, .type = EXT_UCODE_3, .length = 0x8768 },
+	{ .name = "lp0initvals15", .offset = 0xAD4F8, .type = EXT_IV, .length = 0xC68 },
+	{ .name = "lp0bsinitvals15", .offset = 0xAE168, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode16", .offset = 0xE013C, .type = EXT_UCODE_3, .length = 0x8EA0 },
+	{ .name = "lp0bsinitvals16", .offset = 0xAFCE8, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0bsinitvals16", .offset = 0xAEF20, .type = EXT_IV, .length = 0x118 },
+	{ .name = "sslpn0initvals16", .offset = 0xAF040, .type = EXT_IV, .length = 0x0 },
+	{ .name = "n0initvals16", .offset = 0xAE288, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "lp0initvals16", .offset = 0xAF050, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "sslpn0bsinitvals16", .offset = 0xAF048, .type = EXT_IV, .length = 0x0 },
+	EXTRACT_LIST_END
+};
+static struct extract _bb8537e3204a1ea5903fe3e66b5e2763[] =
+{
+	/* ucode major version at offset 0xa8b70 */
+	/* ucode minor version at offset 0xa8b74 */
+	/* { .name = "ucode4", .offset = 0xB6108, .type = EXT_UCODE_1, .length = 0x4EA0 }, */
+	/* { .name = "pcm4", .offset = 0xEF2E0, .type = EXT_PCM, .length = 0x520 }, */
+	/* { .name = "b0g0initvals4", .offset = 0xA8B78, .type = EXT_IV, .length = 0xE80 }, */
+	/* { .name = "a0g0bsinitvals4", .offset = 0xAA8C0, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "b0g0bsinitvals4", .offset = 0xA9A00, .type = EXT_IV, .length = 0x30 }, */
+	/* { .name = "a0g0initvals4", .offset = 0xA9A38, .type = EXT_IV, .length = 0xE80 }, */
+	{ .name = "ucode5", .offset = 0xBAFAC, .type = EXT_UCODE_2, .length = 0x56F0 },
+	{ .name = "pcm5", .offset = 0xEF804, .type = EXT_PCM, .length = 0x520 },
+	{ .name = "b0g0bsinitvals5", .offset = 0xAB318, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0bsinitvals5", .offset = 0xAC878, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals5", .offset = 0xAA8F8, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1initvals5", .offset = 0xABE58, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g0initvals5", .offset = 0xAB438, .type = EXT_IV, .length = 0xA18 },
+	{ .name = "a0g1bsinitvals5", .offset = 0xAC998, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode9", .offset = 0xC06A0, .type = EXT_UCODE_2, .length = 0x6248 },
+	{ .name = "a0g1initvals9", .offset = 0xAE1C8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g0bsinitvals9", .offset = 0xAECC0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals9", .offset = 0xAD5B0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0initvals9", .offset = 0xACAB8, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "a0g1bsinitvals9", .offset = 0xAEDE0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g0initvals9", .offset = 0xAD6D0, .type = EXT_IV, .length = 0xAF0 },
+	{ .name = "ucode11", .offset = 0xC68EC, .type = EXT_UCODE_2, .length = 0x8000 },
+	{ .name = "n0bsinitvals11", .offset = 0xAFAD0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0absinitvals11", .offset = 0xAFBF0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "n0initvals11", .offset = 0xAEF00, .type = EXT_IV, .length = 0xBC8 },
+	{ .name = "ucode13", .offset = 0xCE8F0, .type = EXT_UCODE_2, .length = 0x7AC8 },
+	{ .name = "b0g0initvals13", .offset = 0xB11D0, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "a0g1bsinitvals13", .offset = 0xB2A30, .type = EXT_IV, .length = 0x118 },
+	{ .name = "a0g1initvals13", .offset = 0xB1E90, .type = EXT_IV, .length = 0xB98 },
+	{ .name = "lp0bsinitvals13", .offset = 0xB10B0, .type = EXT_IV, .length = 0x118 },
+	{ .name = "b0g0bsinitvals13", .offset = 0xB1D70, .type = EXT_IV, .length = 0x118 },
+	{ .name = "lp0initvals13", .offset = 0xAFD10, .type = EXT_IV, .length = 0x1398 },
+	{ .name = "ucode14", .offset = 0xD63BC, .type = EXT_UCODE_2, .length = 0x7910 },
+	{ .name = "lp0initvals14", .offset = 0xB2B50, .type = EXT_IV, .length = 0xB80 },
+	{ .name = "lp0bsinitvals14", .offset = 0xB36D8, .type = EXT_IV, .length = 0x118 },
+	{ .name = "ucode15", .offset = 0xDDCD0, .type = EXT_UCODE_3, .length = 0x8768 },
+	{ .name = "lp0bsinitvals15", .offset = 0xB4468, .type = EXT_IV, .length = 0x118 },
+	{ .name = "lp0initvals15", .offset = 0xB37F8, .type = EXT_IV, .length = 0xC68 },
+	{ .name = "ucode16", .offset = 0xE643C, .type = EXT_UCODE_3, .length = 0x8EA0 },
+	{ .name = "n0bsinitvals16", .offset = 0xB5220, .type = EXT_IV, .length = 0x118 },
+	{ .name = "sslpn0initvals16", .offset = 0xB5340, .type = EXT_IV, .length = 0x0 },
+	{ .name = "n0initvals16", .offset = 0xB4588, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "lp0initvals16", .offset = 0xB5350, .type = EXT_IV, .length = 0xC90 },
+	{ .name = "sslpn0bsinitvals16", .offset = 0xB5348, .type = EXT_IV, .length = 0x0 },
+	{ .name = "lp0bsinitvals16", .offset = 0xB5FE8, .type = EXT_IV, .length = 0x118 },
+	EXTRACT_LIST_END
+};/*
  * Links change, so let's not put them into the README.
  * I still put them here so we know where the file was obtained.
  */
@@ -299,6 +398,24 @@ static const struct file files[] =
 		.flags		= FW_FLAG_LE | FW_FLAG_V4 | FW_FLAG_UNSUPPORTED,
 		.extract	= _2dd738b8feb8b3559fd9d8fbaf3bfffc,
 	},
+	{
+		/* ftp://downloads.netgear.com/files/GPL/WNDR3300-V1.0.29_gpl_src.zip */
+		.name		= "wl_apsta.o",
+		.id		= "FW15",
+		.ucode_version	= "478.104",
+		.md5		= "1a258b2d93efa641c32ddf3c3a962028",
+		.flags		= FW_FLAG_LE | FW_FLAG_V4,
+		.extract	= _1a258b2d93efa641c32ddf3c3a962028,
+	},
+	{
+		/* http://downloads.openwrt.org/sources/broadcom-wl-4.178.10.4.tar.bz2 */
+		.name		= "wl_apsta.o",
+		.id		= "FW15",
+		.ucode_version	= "478.104",
+		.md5		= "bb8537e3204a1ea5903fe3e66b5e2763",
+		.flags		= FW_FLAG_LE | FW_FLAG_V4,
+		.extract	= _bb8537e3204a1ea5903fe3e66b5e2763,
+	},
 };
 
 #define FILES (sizeof(files) / sizeof(files[0]))


From mb at bu3sch.de  Fri Aug 21 15:48:45 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 21 Aug 2009 15:48:45 +0200
Subject: [PATCH 2/2 V2] fwcutter: Add two new sources for 478.104 firmware
In-Reply-To: <4a8dc56a.VoVfisnS1440Qve6%Larry.Finger@lwfinger.net>
References: <4a8dc56a.VoVfisnS1440Qve6%Larry.Finger@lwfinger.net>
Message-ID: <200908211548.45770.mb@bu3sch.de>

On Thursday 20 August 2009 23:51:38 Larry Finger wrote:
> Add 2 new files with 478.104 firmware, which includes Rev 16.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> V2 - New files are FW15.

Applied, thanks.

-- 
Greetings, Michael.


From mb at bu3sch.de  Fri Aug 21 15:49:46 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 21 Aug 2009 15:49:46 +0200
Subject: [PATCH 1/2] fwcutter: mklist.py - Update to new library and skip
	some sections
In-Reply-To: <4a8d8823.Rxh3mPs5jA5wl7Sw%Larry.Finger@lwfinger.net>
References: <4a8d8823.Rxh3mPs5jA5wl7Sw%Larry.Finger@lwfinger.net>
Message-ID: <200908211549.46418.mb@bu3sch.de>

On Thursday 20 August 2009 19:30:11 Larry Finger wrote:
> Switch from the deprecated md5 library to hashlib.
> 
> Detect the ro section that describes the firmware version,
> print the address of the data, and and skip some ro sections
> that are not of interest.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>

Applied, thanks.

-- 
Greetings, Michael.


From gregor.kowski at gmail.com  Fri Aug 21 23:43:55 2009
From: gregor.kowski at gmail.com (gregor kowski)
Date: Fri, 21 Aug 2009 23:43:55 +0200
Subject: [PATCHv4] b43 add harware tkip
In-Reply-To: <87eir6tueg.fsf@litku.valot.fi>
References: <83a869cd0908191335u723f62c6p119ec4ed8cfb51c5@mail.gmail.com>
	<87eir6tueg.fsf@litku.valot.fi>
Message-ID: <83a869cd0908211443s1d366f70o202ae768a93b20dc@mail.gmail.com>

This add hardware tkip for b43. This can help to reduce the load a low
powered router and make higher throughput. To enable it, you need to
set "hwtkip" module param.

Signed-off-by: Gregor Kowski <gregor.kowski at gmail.com>
Acked-by: Michael Buesch <mb at bu3sch.de>

Index: linux-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/dma.c	2009-08-10
20:35:33.000000000 +0000
+++ linux-2.6/drivers/net/wireless/b43/dma.c	2009-08-21 21:26:02.000000000 +0000
@@ -1188,7 +1188,7 @@
 	header = &(ring->txhdr_cache[(slot / TX_SLOTS_PER_FRAME) * hdrsize]);
 	cookie = generate_cookie(ring, slot);
 	err = b43_generate_txhdr(ring->dev, header,
-				 skb->data, skb->len, info, cookie);
+				 skb, info, cookie);
 	if (unlikely(err)) {
 		ring->current_slot = old_top_slot;
 		ring->used_slots = old_used_slots;
Index: linux-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/main.c	2009-08-10
20:35:42.000000000 +0000
+++ linux-2.6/drivers/net/wireless/b43/main.c	2009-08-21
21:26:02.000000000 +0000
@@ -80,6 +80,10 @@
 module_param_named(nohwcrypt, modparam_nohwcrypt, int, 0444);
 MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption.");

+static int modparam_hwtkip;
+module_param_named(hwtkip, modparam_hwtkip, int, 0444);
+MODULE_PARM_DESC(hwtkip, "Enable hardware tkip.");
+
 static int modparam_qos = 1;
 module_param_named(qos, modparam_qos, int, 0444);
 MODULE_PARM_DESC(qos, "Enable QOS support (default on)");
@@ -826,6 +830,85 @@
 			(index * 2) + 1, addrtmp[1]);
 }

+/* The ucode will use phase1 key with TEK key to decrypt rx packets.
+ * When a packet is received, the iv32 is checked.
+ * - if it doesn't the packet is returned without modification (and software
+ *   decryption can be done). That's what happen when iv16 wrap.
+ * - if it does, the rc4 key is computed, and decryption is tried.
+ *   Either it will success and B43_RX_MAC_DEC is returned,
+ *   either it fails and B43_RX_MAC_DEC|B43_RX_MAC_DECERR is returned
+ *   and the packet is not usable (it got modified by the ucode).
+ * So in order to never have B43_RX_MAC_DECERR, we should provide
+ * a iv32 and phase1key that match. Because we drop packets in case of
+ * B43_RX_MAC_DECERR, if we have a correct iv32 but a wrong phase1key, all
+ * packets will be lost without higher layer knowing (ie no resync possible
+ * until next wrap).
+ *
+ * NOTE : this should support 50 key like RCMTA because
+ * (B43_SHM_SH_KEYIDXBLOCK - B43_SHM_SH_TKIPTSCTTAK)/14 = 50
+ */
+static void rx_tkip_phase1_write(struct b43_wldev *dev, u8 index, u32 iv32,
+		u16 *phase1key)
+{
+	unsigned int i;
+	u32 offset;
+	u8 pairwise_keys_start = B43_NR_GROUP_KEYS * 2;
+
+	if (!modparam_hwtkip)
+		return;
+
+	if (b43_new_kidx_api(dev))
+		pairwise_keys_start = B43_NR_GROUP_KEYS;
+
+	B43_WARN_ON(index < pairwise_keys_start);
+	/* We have four default TX keys and possibly four default RX keys.
+	 * Physical mac 0 is mapped to physical key 4 or 8, depending
+	 * on the firmware version.
+	 * So we must adjust the index here.
+	 */
+	index -= pairwise_keys_start;
+	B43_WARN_ON(index >= B43_NR_PAIRWISE_KEYS);
+
+	if (b43_debug(dev, B43_DBG_KEYS)) {
+		b43dbg(dev->wl, "rx_tkip_phase1_write : idx 0x%x, iv32 0x%x\n",
+				index, iv32);
+	}
+	/* Write the key to the  RX tkip shared mem */
+	offset = B43_SHM_SH_TKIPTSCTTAK + index * (10 + 4);
+	for (i = 0; i < 10; i += 2) {
+		b43_shm_write16(dev, B43_SHM_SHARED, offset + i,
+				phase1key ? phase1key[i / 2] : 0);
+	}
+	b43_shm_write16(dev, B43_SHM_SHARED, offset + i, iv32);
+	b43_shm_write16(dev, B43_SHM_SHARED, offset + i + 2, iv32 >> 16);
+}
+
+static void b43_op_update_tkip_key(struct ieee80211_hw *hw,
+			struct ieee80211_key_conf *keyconf, const u8 *addr,
+			u32 iv32, u16 *phase1key)
+{
+	struct b43_wl *wl = hw_to_b43_wl(hw);
+	struct b43_wldev *dev;
+	int index = keyconf->hw_key_idx;
+
+	if (B43_WARN_ON(!modparam_hwtkip))
+		return;
+
+	mutex_lock(&wl->mutex);
+
+	dev = wl->current_dev;
+	if (!dev || b43_status(dev) < B43_STAT_INITIALIZED)
+		goto out_unlock;
+
+	keymac_write(dev, index, NULL);	/* First zero out mac to avoid race */
+
+	rx_tkip_phase1_write(dev, index, iv32, phase1key);
+	keymac_write(dev, index, addr);
+
+out_unlock:
+	mutex_unlock(&wl->mutex);
+}
+
 static void do_key_write(struct b43_wldev *dev,
 			 u8 index, u8 algorithm,
 			 const u8 *key, size_t key_len, const u8 *mac_addr)
@@ -841,6 +924,19 @@

 	if (index >= pairwise_keys_start)
 		keymac_write(dev, index, NULL);	/* First zero out mac. */
+	if (algorithm == B43_SEC_ALGO_TKIP) {
+		/*
+		 * We should provide an initial iv32, phase1key pair.
+		 * We could start with iv32=0 and compute the corresponding
+		 * phase1key, but this means calling ieee80211_get_tkip_key
+		 * with a fake skb (or export other tkip function).
+		 * Because we are lazy we hope iv32 won't start with
+		 * 0xffffffff and let's b43_op_update_tkip_key provide a
+		 * correct pair.
+		 */
+		rx_tkip_phase1_write(dev, index, 0xffffffff, (u16*)buf);
+	} else if (index >= pairwise_keys_start) /* clear it */
+		rx_tkip_phase1_write(dev, index, 0, NULL);
 	if (key)
 		memcpy(buf, key, key_len);
 	key_write(dev, index, algorithm, buf);
@@ -859,6 +955,15 @@
 	int i;
 	int pairwise_keys_start;

+	/* For ALG_TKIP the key is encoded as a 256-bit (32 byte) data block:
+	 * 	- Temporal Encryption Key (128 bits)
+	 * 	- Temporal Authenticator Tx MIC Key (64 bits)
+	 * 	- Temporal Authenticator Rx MIC Key (64 bits)
+	 *
+	 * 	Hardware only store TEK
+	 */
+	if (algorithm == B43_SEC_ALGO_TKIP && key_len == 32)
+		key_len = 16;
 	if (key_len > B43_SEC_KEYSIZE)
 		return -EINVAL;
 	for (i = 0; i < ARRAY_SIZE(dev->key); i++) {
@@ -965,6 +1070,14 @@
 		printk("   Algo: %04X/%02X", algo, key->algorithm);

 		if (index >= pairwise_keys_start) {
+			if (key->algorithm == B43_SEC_ALGO_TKIP) {
+				printk("   TKIP: ");
+				offset = B43_SHM_SH_TKIPTSCTTAK + (index - 4) * (10 + 4);
+				for (i = 0; i < 14; i += 2) {
+					u16 tmp = b43_shm_read16(dev, B43_SHM_SHARED, offset + i);
+					printk("%02X%02X", (tmp & 0xFF), ((tmp >> 8) & 0xFF));
+				}
+			}
 			rcmta0 = b43_shm_read32(dev, B43_SHM_RCMTA,
 						((index - pairwise_keys_start) * 2) + 0);
 			rcmta1 = b43_shm_read16(dev, B43_SHM_RCMTA,
@@ -3587,8 +3700,10 @@

 	switch (cmd) {
 	case SET_KEY:
-		if (algorithm == B43_SEC_ALGO_TKIP) {
-			/* FIXME: No TKIP hardware encryption for now. */
+		if (algorithm == B43_SEC_ALGO_TKIP &&
+		    (!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ||
+		    !modparam_hwtkip)) {
+			/* We support only pairwise key */
 			err = -EOPNOTSUPP;
 			goto out_unlock;
 		}
@@ -3618,6 +3733,8 @@
 				     b43_hf_read(dev) & ~B43_HF_USEDEFKEYS);
 		}
 		key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
+		if (algorithm == B43_SEC_ALGO_TKIP)
+			key->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;
 		break;
 	case DISABLE_KEY: {
 		err = b43_key_clear(dev, key->hw_key_idx);
@@ -4345,6 +4462,7 @@
 	.bss_info_changed	= b43_op_bss_info_changed,
 	.configure_filter	= b43_op_configure_filter,
 	.set_key		= b43_op_set_key,
+	.update_tkip_key	= b43_op_update_tkip_key,
 	.get_stats		= b43_op_get_stats,
 	.get_tx_stats		= b43_op_get_tx_stats,
 	.get_tsf		= b43_op_get_tsf,
Index: linux-2.6/drivers/net/wireless/b43/pio.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/pio.c	2009-08-10
20:35:33.000000000 +0000
+++ linux-2.6/drivers/net/wireless/b43/pio.c	2009-08-21 21:26:02.000000000 +0000
@@ -461,8 +461,8 @@

 	cookie = generate_cookie(q, pack);
 	hdrlen = b43_txhdr_size(q->dev);
-	err = b43_generate_txhdr(q->dev, (u8 *)&txhdr, skb->data,
-				 skb->len, info, cookie);
+	err = b43_generate_txhdr(q->dev, (u8 *)&txhdr, skb,
+				 info, cookie);
 	if (err)
 		return err;

Index: linux-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/xmit.c	2009-08-10
20:35:42.000000000 +0000
+++ linux-2.6/drivers/net/wireless/b43/xmit.c	2009-08-21
21:26:02.000000000 +0000
@@ -180,11 +180,12 @@
 /* Generate a TX data header. */
 int b43_generate_txhdr(struct b43_wldev *dev,
 		       u8 *_txhdr,
-		       const unsigned char *fragment_data,
-		       unsigned int fragment_len,
+		       struct sk_buff *skb_frag,
 		       struct ieee80211_tx_info *info,
 		       u16 cookie)
 {
+	const unsigned char *fragment_data = skb_frag->data;
+	unsigned int fragment_len = skb_frag->len;
 	struct b43_txhdr *txhdr = (struct b43_txhdr *)_txhdr;
 	const struct b43_phy *phy = &dev->phy;
 	const struct ieee80211_hdr *wlhdr =
@@ -258,9 +259,26 @@
 		mac_ctl |= (key->algorithm << B43_TXH_MAC_KEYALG_SHIFT) &
 			   B43_TXH_MAC_KEYALG;
 		wlhdr_len = ieee80211_hdrlen(fctl);
-		iv_len = min((size_t) info->control.hw_key->iv_len,
-			     ARRAY_SIZE(txhdr->iv));
-		memcpy(txhdr->iv, ((u8 *) wlhdr) + wlhdr_len, iv_len);
+		if (key->algorithm == B43_SEC_ALGO_TKIP) {
+			u16 phase1key[5];
+			int i;
+			/* we give the phase1key and iv16 here, the key is stored in
+			 * shm. With that the hardware can do phase 2 and encryption.
+			 */
+			ieee80211_get_tkip_key(info->control.hw_key, skb_frag,
+					IEEE80211_TKIP_P1_KEY, (u8*)phase1key);
+			/* phase1key is in host endian */
+			for (i = 0; i < 5; i++)
+				phase1key[i] = cpu_to_le16(phase1key[i]);
+
+			memcpy(txhdr->iv, phase1key, 10);
+			/* iv16 */
+			memcpy(txhdr->iv + 10, ((u8 *) wlhdr) + wlhdr_len, 3);
+		} else {
+			iv_len = min((size_t) info->control.hw_key->iv_len,
+				     ARRAY_SIZE(txhdr->iv));
+			memcpy(txhdr->iv, ((u8 *) wlhdr) + wlhdr_len, iv_len);
+		}
 	}
 	if (b43_is_old_txhdr_format(dev)) {
 		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->old_format.plcp),
Index: linux-2.6/drivers/net/wireless/b43/xmit.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/b43/xmit.h	2009-08-10
20:35:33.000000000 +0000
+++ linux-2.6/drivers/net/wireless/b43/xmit.h	2009-08-21
21:26:02.000000000 +0000
@@ -176,8 +176,7 @@

 int b43_generate_txhdr(struct b43_wldev *dev,
 		       u8 * txhdr,
-		       const unsigned char *fragment_data,
-		       unsigned int fragment_len,
+		       struct sk_buff *skb_frag,
 		       struct ieee80211_tx_info *txctl, u16 cookie);

 /* Transmit Status */


From Larry.Finger at lwfinger.net  Sat Aug 22 06:22:04 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Fri, 21 Aug 2009 23:22:04 -0500
Subject: [PATCH] b43-fwcutter: Update version since adding FW15
Message-ID: <4a8f726c.7O09MgyCwO8eZUkg%Larry.Finger@lwfinger.net>

The program version should have been updated when FW15 was added.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: fwcutter/Makefile
===================================================================
--- fwcutter.orig/Makefile
+++ fwcutter/Makefile
@@ -1,4 +1,4 @@
-VERSION = 012
+VERSION = 013
 
 CC ?= cc
 PREFIX ?= /usr/local


From mb at bu3sch.de  Sat Aug 22 15:52:38 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 22 Aug 2009 15:52:38 +0200
Subject: [PATCH] b43-fwcutter: Update version since adding FW15
In-Reply-To: <4a8f726c.7O09MgyCwO8eZUkg%Larry.Finger@lwfinger.net>
References: <4a8f726c.7O09MgyCwO8eZUkg%Larry.Finger@lwfinger.net>
Message-ID: <200908221552.39002.mb@bu3sch.de>

On Saturday 22 August 2009 06:22:04 Larry Finger wrote:
> The program version should have been updated when FW15 was added.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---

I always do that just before releasing the new version.

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Sat Aug 22 17:14:43 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 22 Aug 2009 10:14:43 -0500
Subject: [PATCH] b43-fwcutter: Update version since adding FW15
In-Reply-To: <200908221552.39002.mb@bu3sch.de>
References: <4a8f726c.7O09MgyCwO8eZUkg%Larry.Finger@lwfinger.net>
	<200908221552.39002.mb@bu3sch.de>
Message-ID: <4A900B63.6010405@lwfinger.net>

Michael Buesch wrote:
> On Saturday 22 August 2009 06:22:04 Larry Finger wrote:
>> The program version should have been updated when FW15 was added.
>>
>> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
>> ---
> 
> I always do that just before releasing the new version.

OK. When you release a new version, I will update the link to the
driver file on the wiki. My impression is that the LP PHY works a
little better with the 478.104 firmware, and it should probably be
used with the latest devices. In any case, that is what is in the
4.174.64.19 driver that is the basis for the latest RE.

Larry


From mb at bu3sch.de  Sun Aug 23 14:48:16 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 23 Aug 2009 14:48:16 +0200
Subject: [RFT] b43: Get rid of spinlocks (version 2)
Message-ID: <200908231448.16550.mb@bu3sch.de>

Hi,

This patchset removes all spinlocks (except the LEDs lock for now) from b43.
There are no known races or bugs added by this patchset.
Please test it a lot, so we can ensure there are no regressions.

It sometimes crashes for me in the lockdep code on module unload, but I'm not
really sure whether that is a b43 or lockdep bug.
Please test test test. :)

Apply the patchset in this order to wireless-testing.git:
http://bu3sch.de/patches/wireless-testing/20090823-1442/patches/001-fix-irq-thread-wakeup.patch
http://bu3sch.de/patches/wireless-testing/20090823-1442/patches/002-b43-threaded-irq-handler.patch
http://bu3sch.de/patches/wireless-testing/20090823-1442/patches/003-b43-remove-tx-lock.patch
http://bu3sch.de/patches/wireless-testing/20090823-1442/patches/004-b43-remove-queue-locks.patch
http://bu3sch.de/patches/wireless-testing/20090823-1442/patches/005-b43-remove-pio-rx-work.patch
http://bu3sch.de/patches/wireless-testing/20090823-1442/patches/006-b43-remove-shm-lock.patch


-- 
Greetings, Michael.


From linville at tuxdriver.com  Mon Aug 24 16:20:09 2009
From: linville at tuxdriver.com (John W. Linville)
Date: Mon, 24 Aug 2009 10:20:09 -0400
Subject: [PATCHv4] b43 add harware tkip
In-Reply-To: <83a869cd0908211443s1d366f70o202ae768a93b20dc@mail.gmail.com>
References: <83a869cd0908191335u723f62c6p119ec4ed8cfb51c5@mail.gmail.com>
	<87eir6tueg.fsf@litku.valot.fi>
	<83a869cd0908211443s1d366f70o202ae768a93b20dc@mail.gmail.com>
Message-ID: <20090824142008.GB8998@tuxdriver.com>

On Fri, Aug 21, 2009 at 11:43:55PM +0200, gregor kowski wrote:
> This add hardware tkip for b43. This can help to reduce the load a low
> powered router and make higher throughput. To enable it, you need to
> set "hwtkip" module param.
> 
> Signed-off-by: Gregor Kowski <gregor.kowski at gmail.com>
> Acked-by: Michael Buesch <mb at bu3sch.de>

An earlier version was already merged.  What is different here?

Please submit a new patch with just the differences.

John
-- 
John W. Linville		Someday the world will need a hero, and you
linville at tuxdriver.com			might be all we have.  Be ready.


From netrolller.3d at gmail.com  Tue Aug 25 16:17:48 2009
From: netrolller.3d at gmail.com (=?utf-8?q?G=C3=A1bor=20Stefanik?=)
Date: Tue, 25 Aug 2009 16:17:48 +0200
Subject: [PATCH] b43: LP-PHY: Fix a few typos in the RC calibration code
Message-ID: <1251209868-7681-1-git-send-email-netrolller.3d@gmail.com>

The RC calibration code has some typos - fix them.
Also, make the default channel 7, as channel 1 is still
broken (only channels 7 and 8, and occasionally 9 work).

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |    7 ++++---
 1 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 2d3a5d8..7e70c07 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -44,7 +44,7 @@ static inline u16 channel2freq_lp(u8 channel)
 static unsigned int b43_lpphy_op_get_default_chan(struct b43_wldev *dev)
 {
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
-		return 1;
+		return 7; //FIXME temporary - channel 1 is broken
 	return 36;
 }
 
@@ -705,7 +705,7 @@ static void lpphy_set_rc_cap(struct b43_wldev *dev)
 	u8 rc_cap = (lpphy->rc_cap & 0x1F) >> 1;
 
 	if (dev->phy.rev == 1) //FIXME check channel 14!
-		rc_cap = max_t(u8, rc_cap + 5, 15);
+		rc_cap = min_t(u8, rc_cap + 5, 15);
 
 	b43_radio_write(dev, B2062_N_RXBB_CALIB2,
 			max_t(u8, lpphy->rc_cap - 4, 0x80));
@@ -1008,6 +1008,7 @@ static int lpphy_loopback(struct b43_wldev *dev)
 
 	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x3);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+	b43_phy_set(dev, B43_LPPHY_AFE_CTL_OVR, 1);
 	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFFE);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x800);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x800);
@@ -1213,7 +1214,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 			mean_sq_pwr = ideal_pwr - normal_pwr;
 			mean_sq_pwr *= mean_sq_pwr;
 			inner_sum += mean_sq_pwr;
-			if ((i = 128) || (inner_sum < mean_sq_pwr_min)) {
+			if ((i == 128) || (inner_sum < mean_sq_pwr_min)) {
 				lpphy->rc_cap = i;
 				mean_sq_pwr_min = inner_sum;
 			}
-- 
1.5.6



From netrolller.3d at gmail.com  Tue Aug 25 16:40:17 2009
From: netrolller.3d at gmail.com (=?utf-8?q?G=C3=A1bor=20Stefanik?=)
Date: Tue, 25 Aug 2009 16:40:17 +0200
Subject: [PATCH] b43: LP-PHY: Fix and simplify Qdiv roundup
Message-ID: <1251211217-7816-1-git-send-email-netrolller.3d@gmail.com>

The Qdiv roundup routine is essentially a fixed-point
division algorithm, using only integer math.
However, the version in the specs had a major error
that has been recently fixed (a missing quotient++).

Replace Qdiv roundup with a rewritten, simplified version.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |   14 ++++----------
 1 files changed, 4 insertions(+), 10 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 7e70c07..d0280d5 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1034,7 +1034,7 @@ static int lpphy_loopback(struct b43_wldev *dev)
 
 static u32 lpphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
 {
-	u32 quotient, remainder, rbit, roundup, tmp;
+	u32 quotient, remainder;
 
 	if (divisor == 0)
 		return 0;
@@ -1042,20 +1042,14 @@ static u32 lpphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
 	quotient = dividend / divisor;
 	remainder = dividend % divisor;
 
-	rbit = divisor & 0x1;
-	roundup = (divisor >> 1) + rbit;
-
 	while (precision != 0) {
-		tmp = remainder - roundup;
 		quotient <<= 1;
-		if (remainder >= roundup)
-			remainder = (tmp << 1) + rbit;
-		else
-			remainder <<= 1;
+		quotient |= (remainder << 1) / divisor;
+		remainder = (remainder << 1) % divisor;
 		precision--;
 	}
 
-	if (remainder >= roundup)
+	if (remainder << 1 >= divisor)
 		quotient++;
 
 	return quotient;
-- 
1.5.6



From mb at bu3sch.de  Tue Aug 25 22:48:47 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 25 Aug 2009 22:48:47 +0200
Subject: [PATCH] b43: LP-PHY: Fix and simplify Qdiv roundup
In-Reply-To: <1251211217-7816-1-git-send-email-netrolller.3d@gmail.com>
References: <1251211217-7816-1-git-send-email-netrolller.3d@gmail.com>
Message-ID: <200908252248.49591.mb@bu3sch.de>

On Tuesday 25 August 2009 16:40:17 G?bor Stefanik wrote:
> The Qdiv roundup routine is essentially a fixed-point
> division algorithm, using only integer math.
> However, the version in the specs had a major error
> that has been recently fixed (a missing quotient++).
> 
> Replace Qdiv roundup with a rewritten, simplified version.

Don't we have some sort of standard library function somewhere in
the kernel for this? If not, what about creating one?

> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
>  drivers/net/wireless/b43/phy_lp.c |   14 ++++----------
>  1 files changed, 4 insertions(+), 10 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index 7e70c07..d0280d5 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -1034,7 +1034,7 @@ static int lpphy_loopback(struct b43_wldev *dev)
>  
>  static u32 lpphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
>  {
> -	u32 quotient, remainder, rbit, roundup, tmp;
> +	u32 quotient, remainder;
>  
>  	if (divisor == 0)
>  		return 0;
> @@ -1042,20 +1042,14 @@ static u32 lpphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
>  	quotient = dividend / divisor;
>  	remainder = dividend % divisor;
>  
> -	rbit = divisor & 0x1;
> -	roundup = (divisor >> 1) + rbit;
> -
>  	while (precision != 0) {
> -		tmp = remainder - roundup;
>  		quotient <<= 1;
> -		if (remainder >= roundup)
> -			remainder = (tmp << 1) + rbit;
> -		else
> -			remainder <<= 1;
> +		quotient |= (remainder << 1) / divisor;
> +		remainder = (remainder << 1) % divisor;
>  		precision--;
>  	}
>  
> -	if (remainder >= roundup)
> +	if (remainder << 1 >= divisor)
>  		quotient++;
>  
>  	return quotient;



-- 
Greetings, Michael.


From mb at bu3sch.de  Tue Aug 25 22:48:56 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 25 Aug 2009 22:48:56 +0200
Subject: [PATCH] b43: LP-PHY: Fix a few typos in the RC calibration code
In-Reply-To: <1251209868-7681-1-git-send-email-netrolller.3d@gmail.com>
References: <1251209868-7681-1-git-send-email-netrolller.3d@gmail.com>
Message-ID: <200908252248.58079.mb@bu3sch.de>

On Tuesday 25 August 2009 16:17:48 G?bor Stefanik wrote:
> The RC calibration code has some typos - fix them.
> Also, make the default channel 7, as channel 1 is still
> broken (only channels 7 and 8, and occasionally 9 work).
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

ack

> ---
>  drivers/net/wireless/b43/phy_lp.c |    7 ++++---
>  1 files changed, 4 insertions(+), 3 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index 2d3a5d8..7e70c07 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -44,7 +44,7 @@ static inline u16 channel2freq_lp(u8 channel)
>  static unsigned int b43_lpphy_op_get_default_chan(struct b43_wldev *dev)
>  {
>  	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
> -		return 1;
> +		return 7; //FIXME temporary - channel 1 is broken
>  	return 36;
>  }
>  
> @@ -705,7 +705,7 @@ static void lpphy_set_rc_cap(struct b43_wldev *dev)
>  	u8 rc_cap = (lpphy->rc_cap & 0x1F) >> 1;
>  
>  	if (dev->phy.rev == 1) //FIXME check channel 14!
> -		rc_cap = max_t(u8, rc_cap + 5, 15);
> +		rc_cap = min_t(u8, rc_cap + 5, 15);
>  
>  	b43_radio_write(dev, B2062_N_RXBB_CALIB2,
>  			max_t(u8, lpphy->rc_cap - 4, 0x80));
> @@ -1008,6 +1008,7 @@ static int lpphy_loopback(struct b43_wldev *dev)
>  
>  	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x3);
>  	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
> +	b43_phy_set(dev, B43_LPPHY_AFE_CTL_OVR, 1);
>  	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFFE);
>  	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x800);
>  	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x800);
> @@ -1213,7 +1214,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
>  			mean_sq_pwr = ideal_pwr - normal_pwr;
>  			mean_sq_pwr *= mean_sq_pwr;
>  			inner_sum += mean_sq_pwr;
> -			if ((i = 128) || (inner_sum < mean_sq_pwr_min)) {
> +			if ((i == 128) || (inner_sum < mean_sq_pwr_min)) {
>  				lpphy->rc_cap = i;
>  				mean_sq_pwr_min = inner_sum;
>  			}



-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Wed Aug 26 20:51:24 2009
From: netrolller.3d at gmail.com (=?utf-8?q?G=C3=A1bor=20Stefanik?=)
Date: Wed, 26 Aug 2009 20:51:24 +0200
Subject: [PATCH v2] b43: LP-PHY: Fix and simplify Qdiv roundup
Message-ID: <1251312686-32067-1-git-send-email-netrolller.3d@gmail.com>

The Qdiv roundup routine is essentially a fixed-point
division algorithm, using only integer math.
However, the version in the specs had a major error
that has been recently fixed (a missing quotient++).

Replace Qdiv roundup with a rewritten, simplified version.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
v2: Remove divide/modulo operations from the inner loop.

 drivers/net/wireless/b43/phy_lp.c |   19 ++++++++-----------
 1 files changed, 8 insertions(+), 11 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 7e70c07..5306f2c 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1032,9 +1032,10 @@ static int lpphy_loopback(struct b43_wldev *dev)
 	return index;
 }
 
+/* Fixed-point division algorithm using only integer math. */
 static u32 lpphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
 {
-	u32 quotient, remainder, rbit, roundup, tmp;
+	u32 quotient, remainder;
 
 	if (divisor == 0)
 		return 0;
@@ -1042,20 +1043,16 @@ static u32 lpphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
 	quotient = dividend / divisor;
 	remainder = dividend % divisor;
 
-	rbit = divisor & 0x1;
-	roundup = (divisor >> 1) + rbit;
-
-	while (precision != 0) {
-		tmp = remainder - roundup;
+	while (precision > 0) {
 		quotient <<= 1;
-		if (remainder >= roundup)
-			remainder = (tmp << 1) + rbit;
-		else
-			remainder <<= 1;
+		if (remainder << 1 >= divisor) {
+			quotient++;
+			remainder = (remainder << 1) - divisor;
+		}
 		precision--;
 	}
 
-	if (remainder >= roundup)
+	if (remainder << 1 >= divisor)
 		quotient++;
 
 	return quotient;
-- 
1.5.6



From netrolller.3d at gmail.com  Wed Aug 26 20:51:26 2009
From: netrolller.3d at gmail.com (=?utf-8?q?G=C3=A1bor=20Stefanik?=)
Date: Wed, 26 Aug 2009 20:51:26 +0200
Subject: [PATCH] ssb: Implement PMU LDO control and use it in b43
In-Reply-To: <1251312686-32067-2-git-send-email-netrolller.3d@gmail.com>
References: <1251312686-32067-1-git-send-email-netrolller.3d@gmail.com>
	<1251312686-32067-2-git-send-email-netrolller.3d@gmail.com>
Message-ID: <1251312686-32067-3-git-send-email-netrolller.3d@gmail.com>

Implement the "PMU LDO set voltage" and "PMU LDO PA ref enable"
functions, and use them during LP-PHY baseband init in b43.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c         |   10 +--
 drivers/ssb/driver_chipcommon_pmu.c       |   94 +++++++++++++++++++++++++++++
 include/linux/ssb/ssb_driver_chipcommon.h |   10 +++
 3 files changed, 107 insertions(+), 7 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 1a57d33..80f245c 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -234,19 +234,15 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 	if ((bus->sprom.boardflags_lo & B43_BFL_FEM) &&
 	   ((b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ) ||
 	   (bus->sprom.boardflags_hi & B43_BFH_PAREF))) {
-		/* TODO:
-		 * Set the LDO voltage to 0x0028 - FIXME: What is this?
-		 * Call sb_pmu_set_ldo_voltage with 4 and the LDO voltage
-		 *      as arguments
-		 * Call sb_pmu_paref_ldo_enable with argument TRUE
-		 */
+		ssb_pmu_set_ldo_voltage(&bus->chipco, LDO_PAREF, 0x28);
+		ssb_pmu_set_ldo_paref(&bus->chipco, true);
 		if (dev->phy.rev == 0) {
 			b43_phy_maskset(dev, B43_LPPHY_LP_RF_SIGNAL_LUT,
 					0xFFCF, 0x0010);
 		}
 		b43_lptab_write(dev, B43_LPTAB16(11, 7), 60);
 	} else {
-		//TODO: Call ssb_pmu_paref_ldo_enable with argument FALSE
+		ssb_pmu_set_ldo_paref(&bus->chipco, false);
 		b43_phy_maskset(dev, B43_LPPHY_LP_RF_SIGNAL_LUT,
 				0xFFCF, 0x0020);
 		b43_lptab_write(dev, B43_LPTAB16(11, 7), 100);
diff --git a/drivers/ssb/driver_chipcommon_pmu.c b/drivers/ssb/driver_chipcommon_pmu.c
index 4aaddee..64abd11 100644
--- a/drivers/ssb/driver_chipcommon_pmu.c
+++ b/drivers/ssb/driver_chipcommon_pmu.c
@@ -28,6 +28,21 @@ static void ssb_chipco_pll_write(struct ssb_chipcommon *cc,
 	chipco_write32(cc, SSB_CHIPCO_PLLCTL_DATA, value);
 }
 
+static void ssb_chipco_regctl_maskset(struct ssb_chipcommon *cc,
+				   u32 offset, u32 mask, u32 set)
+{
+	u32 value;
+
+	chipco_read32(cc, SSB_CHIPCO_REGCTL_ADDR);
+	chipco_write32(cc, SSB_CHIPCO_REGCTL_ADDR, offset);
+	chipco_read32(cc, SSB_CHIPCO_REGCTL_ADDR);
+	value = chipco_read32(cc, SSB_CHIPCO_REGCTL_DATA);
+	value &= mask;
+	value |= set;
+	chipco_write32(cc, SSB_CHIPCO_REGCTL_DATA, value);
+	chipco_read32(cc, SSB_CHIPCO_REGCTL_DATA);
+}
+
 struct pmu0_plltab_entry {
 	u16 freq;	/* Crystal frequency in kHz.*/
 	u8 xf;		/* Crystal frequency value for PMU control */
@@ -506,3 +521,82 @@ void ssb_pmu_init(struct ssb_chipcommon *cc)
 	ssb_pmu_pll_init(cc);
 	ssb_pmu_resources_init(cc);
 }
+
+void ssb_pmu_set_ldo_voltage(struct ssb_chipcommon *cc,
+			     enum ssb_pmu_ldo_volt_id id, u32 voltage)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	u32 addr, shift, mask;
+
+	switch (bus->chip_id) {
+	case 0x4328:
+	case 0x5354:
+		switch (id) {
+		case LDO_VOLT1:
+			addr = 2;
+			shift = 25;
+			mask = 0xF;
+			break;
+		case LDO_VOLT2:
+			addr = 3;
+			shift = 1;
+			mask = 0xF;
+			break;
+		case LDO_VOLT3:
+			addr = 3;
+			shift = 9;
+			mask = 0xF;
+			break;
+		case LDO_PAREF:
+			addr = 3;
+			shift = 17;
+			mask = 0x3F;
+			break;
+		default:
+			SSB_WARN_ON(1);
+			return;
+		}
+		break;
+	case 0x4312:
+		if (SSB_WARN_ON(id != LDO_PAREF))
+			return;
+		addr = 0;
+		shift = 21;
+		mask = 0x3F;
+		break;
+	default:
+		return;
+	}
+
+	ssb_chipco_regctl_maskset(cc, addr, ~(mask << shift),
+				  (voltage & mask) << shift);
+}
+
+void ssb_pmu_set_ldo_paref(struct ssb_chipcommon *cc, bool on)
+{
+	struct ssb_bus *bus = cc->dev->bus;
+	int ldo;
+
+	switch (bus->chip_id) {
+	case 0x4312:
+		ldo = SSB_PMURES_4312_PA_REF_LDO;
+		break;
+	case 0x4328:
+		ldo = SSB_PMURES_4328_PA_REF_LDO;
+		break;
+	case 0x5354:
+		ldo = SSB_PMURES_5354_PA_REF_LDO;
+		break;
+	default:
+		return;
+	}
+
+	if (on)
+		chipco_set32(cc, SSB_CHIPCO_PMU_MINRES_MSK, 1 << ldo);
+	else
+		chipco_mask32(cc, SSB_CHIPCO_PMU_MINRES_MSK, ~(1 << ldo));
+	chipco_read32(cc, SSB_CHIPCO_PMU_MINRES_MSK); //SPEC FIXME found via mmiotrace - dummy read?
+}
+
+EXPORT_SYMBOL(ssb_pmu_set_ldo_voltage);
+EXPORT_SYMBOL(ssb_pmu_set_ldo_paref);
diff --git a/include/linux/ssb/ssb_driver_chipcommon.h b/include/linux/ssb/ssb_driver_chipcommon.h
index d3b1d18..4e27acf 100644
--- a/include/linux/ssb/ssb_driver_chipcommon.h
+++ b/include/linux/ssb/ssb_driver_chipcommon.h
@@ -629,5 +629,15 @@ extern int ssb_chipco_serial_init(struct ssb_chipcommon *cc,
 /* PMU support */
 extern void ssb_pmu_init(struct ssb_chipcommon *cc);
 
+enum ssb_pmu_ldo_volt_id {
+	LDO_PAREF = 0,
+	LDO_VOLT1,
+	LDO_VOLT2,
+	LDO_VOLT3,
+};
+
+void ssb_pmu_set_ldo_voltage(struct ssb_chipcommon *cc,
+			     enum ssb_pmu_ldo_volt_id id, u32 voltage);
+void ssb_pmu_set_ldo_paref(struct ssb_chipcommon *cc, bool on);
 
 #endif /* LINUX_SSB_CHIPCO_H_ */
-- 
1.5.6



From netrolller.3d at gmail.com  Wed Aug 26 20:51:25 2009
From: netrolller.3d at gmail.com (=?utf-8?q?G=C3=A1bor=20Stefanik?=)
Date: Wed, 26 Aug 2009 20:51:25 +0200
Subject: [PATCH] b43: Fix and update LP-PHY code
In-Reply-To: <1251312686-32067-1-git-send-email-netrolller.3d@gmail.com>
References: <1251312686-32067-1-git-send-email-netrolller.3d@gmail.com>
Message-ID: <1251312686-32067-2-git-send-email-netrolller.3d@gmail.com>

-Fix a few nasty typos (b43_phy_* operations instead of b43_radio_*)
 in the channel tune routines.
-Fix some typos & spec errors found by MMIO tracing.
-Optimize b43_phy_write & b43_phy_mask/set/maskset to use
 only the minimal number of MMIO accesses. (Write is possible
 using a single 32-bit MMIO write, while set/mask/maskset can
 be done in 3 16-bit MMIOs).
-Set the default channel back to 1, as the bug forcing us to use
 channel 7 is now fixed.

With this, the device comes up, scans, associates, transmits,
receives, monitors and injects on all channels - in other words,
it's fully functional. Sensitivity and TX power are still sub-optimal,
due to the lack of calibration (that's next on my list).

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_common.c   |   27 +++++++--
 drivers/net/wireless/b43/phy_common.h   |    3 +
 drivers/net/wireless/b43/phy_lp.c       |   91 +++++++++++++++++--------------
 drivers/net/wireless/b43/phy_lp.h       |    3 +
 drivers/net/wireless/b43/tables_lpphy.c |   79 +++++++++++++++------------
 5 files changed, 122 insertions(+), 81 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_common.c b/drivers/net/wireless/b43/phy_common.c
index 51686ec..6e704be 100644
--- a/drivers/net/wireless/b43/phy_common.c
+++ b/drivers/net/wireless/b43/phy_common.c
@@ -249,20 +249,35 @@ void b43_phy_copy(struct b43_wldev *dev, u16 destreg, u16 srcreg)
 
 void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
 {
-	b43_phy_write(dev, offset,
-		      b43_phy_read(dev, offset) & mask);
+	if (dev->phy.ops->phy_maskset) {
+		assert_mac_suspended(dev);
+		dev->phy.ops->phy_maskset(dev, offset, mask, 0);
+	} else {
+		b43_phy_write(dev, offset,
+			      b43_phy_read(dev, offset) & mask);
+	}
 }
 
 void b43_phy_set(struct b43_wldev *dev, u16 offset, u16 set)
 {
-	b43_phy_write(dev, offset,
-		      b43_phy_read(dev, offset) | set);
+	if (dev->phy.ops->phy_maskset) {
+		assert_mac_suspended(dev);
+		dev->phy.ops->phy_maskset(dev, offset, 0xFFFF, set);
+	} else {
+		b43_phy_write(dev, offset,
+			      b43_phy_read(dev, offset) | set);
+	}
 }
 
 void b43_phy_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set)
 {
-	b43_phy_write(dev, offset,
-		      (b43_phy_read(dev, offset) & mask) | set);
+	if (dev->phy.ops->phy_maskset) {
+		assert_mac_suspended(dev);
+		dev->phy.ops->phy_maskset(dev, offset, mask, set);
+	} else {
+		b43_phy_write(dev, offset,
+			      (b43_phy_read(dev, offset) & mask) | set);
+	}
 }
 
 int b43_switch_channel(struct b43_wldev *dev, unsigned int new_channel)
diff --git a/drivers/net/wireless/b43/phy_common.h b/drivers/net/wireless/b43/phy_common.h
index 9f9f23c..b47a0f5 100644
--- a/drivers/net/wireless/b43/phy_common.h
+++ b/drivers/net/wireless/b43/phy_common.h
@@ -95,6 +95,8 @@ enum b43_txpwr_result {
  * 			Must not be NULL.
  * @phy_write:		Write to a PHY register.
  * 			Must not be NULL.
+ * @phy_maskset:	Maskset a PHY register, taking shortcuts.
+ *			If it is NULL, a generic algorithm is used.
  * @radio_read:		Read from a Radio register.
  * 			Must not be NULL.
  * @radio_write:	Write to a Radio register.
@@ -154,6 +156,7 @@ struct b43_phy_operations {
 	/* Register access */
 	u16 (*phy_read)(struct b43_wldev *dev, u16 reg);
 	void (*phy_write)(struct b43_wldev *dev, u16 reg, u16 value);
+	void (*phy_maskset)(struct b43_wldev *dev, u16 reg, u16 mask, u16 set);
 	u16 (*radio_read)(struct b43_wldev *dev, u16 reg);
 	void (*radio_write)(struct b43_wldev *dev, u16 reg, u16 value);
 
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 5306f2c..1a57d33 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -44,7 +44,7 @@ static inline u16 channel2freq_lp(u8 channel)
 static unsigned int b43_lpphy_op_get_default_chan(struct b43_wldev *dev)
 {
 	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
-		return 7; //FIXME temporary - channel 1 is broken
+		return 1;
 	return 36;
 }
 
@@ -182,8 +182,8 @@ static void lpphy_adjust_gain_table(struct b43_wldev *dev, u32 freq)
 	temp[1] = temp[0] + 0x1000;
 	temp[2] = temp[0] + 0x2000;
 
-	b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0), 3, temp);
 	b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0), 3, temp);
+	b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0), 3, temp);
 }
 
 static void lpphy_table_init(struct b43_wldev *dev)
@@ -223,8 +223,8 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0xFF00, 0x0006);
 	b43_phy_mask(dev, B43_LPPHY_RX_RADIO_CTL, 0xFFFE);
 	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x0005);
-	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC10, 0x0180);
-	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x3800);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC1F, 0x0180);
+	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x3C00);
 	b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xFFF0, 0x0005);
 	b43_phy_maskset(dev, B43_LPPHY_GAIN_MISMATCH_LIMIT, 0xFFC0, 0x001A);
 	b43_phy_maskset(dev, B43_LPPHY_CRS_ED_THRESH, 0xFF00, 0x00B3);
@@ -237,7 +237,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 		/* TODO:
 		 * Set the LDO voltage to 0x0028 - FIXME: What is this?
 		 * Call sb_pmu_set_ldo_voltage with 4 and the LDO voltage
-		 * 	as arguments
+		 *      as arguments
 		 * Call sb_pmu_paref_ldo_enable with argument TRUE
 		 */
 		if (dev->phy.rev == 0) {
@@ -340,11 +340,11 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
 	if (dev->phy.rev == 1) {
 		tmp = b43_phy_read(dev, B43_LPPHY_CLIPCTRTHRESH);
 		tmp2 = (tmp & 0x03E0) >> 5;
-		tmp2 |= tmp << 5;
+		tmp2 |= tmp2 << 5;
 		b43_phy_write(dev, B43_LPPHY_4C3, tmp2);
-		tmp = b43_phy_read(dev, B43_LPPHY_OFDMSYNCTHRESH0);
+		tmp = b43_phy_read(dev, B43_LPPHY_GAINDIRECTMISMATCH);
 		tmp2 = (tmp & 0x1F00) >> 8;
-		tmp2 |= tmp << 5;
+		tmp2 |= tmp2 << 5;
 		b43_phy_write(dev, B43_LPPHY_4C4, tmp2);
 		tmp = b43_phy_read(dev, B43_LPPHY_VERYLOWGAINDB);
 		tmp2 = tmp & 0x00FF;
@@ -761,7 +761,7 @@ static void lpphy_disable_crs(struct b43_wldev *dev, bool user)
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
 	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x4);
-	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFF7);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFF7);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x10);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
@@ -956,7 +956,7 @@ static void lpphy_run_ddfs(struct b43_wldev *dev, int i_on, int q_on,
 	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFF9F, scale_idx << 5);
 	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS, 0xFFFB);
 	b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x2);
-	b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x20);
+	b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x20);
 }
 
 static bool lpphy_rx_iq_est(struct b43_wldev *dev, u16 samples, u8 time,
@@ -968,7 +968,7 @@ static bool lpphy_rx_iq_est(struct b43_wldev *dev, u16 samples, u8 time,
 	b43_phy_write(dev, B43_LPPHY_IQ_NUM_SMPLS_ADDR, samples);
 	b43_phy_maskset(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFF00, time);
 	b43_phy_mask(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFEFF);
-	b43_phy_set(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFDFF);
+	b43_phy_set(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0x200);
 
 	for (i = 0; i < 500; i++) {
 		if (!(b43_phy_read(dev,
@@ -1135,9 +1135,9 @@ static void lpphy_set_tx_power_control(struct b43_wldev *dev,
 	}
 	if (dev->phy.rev >= 2) {
 		if (mode == B43_LPPHY_TXPCTL_HW)
-			b43_phy_maskset(dev, B43_PHY_OFDM(0xD0), 0xFD, 0x2);
+			b43_phy_set(dev, B43_PHY_OFDM(0xD0), 0x2);
 		else
-			b43_phy_maskset(dev, B43_PHY_OFDM(0xD0), 0xFD, 0);
+			b43_phy_mask(dev, B43_PHY_OFDM(0xD0), 0xFFFD);
 	}
 	lpphy_write_tx_pctl_mode_to_hardware(dev);
 }
@@ -1169,7 +1169,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
 	err = b43_lpphy_op_switch_channel(dev, 7);
 	if (err) {
 		b43dbg(dev->wl,
-		       "RC calib: Failed to switch to channel 7, error = %d",
+		       "RC calib: Failed to switch to channel 7, error = %d\n",
 		       err);
 	}
 	old_txg_ovr = !!(b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40);
@@ -1500,8 +1500,15 @@ static u16 b43_lpphy_op_read(struct b43_wldev *dev, u16 reg)
 
 static void b43_lpphy_op_write(struct b43_wldev *dev, u16 reg, u16 value)
 {
+	b43_write32(dev, B43_MMIO_PHY_CONTROL, ((u32)value << 16) | reg);
+}
+
+static void b43_lpphy_op_maskset(struct b43_wldev *dev, u16 reg, u16 mask,
+				 u16 set)
+{
 	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-	b43_write16(dev, B43_MMIO_PHY_DATA, value);
+	b43_write16(dev, B43_MMIO_PHY_DATA,
+		    (b43_read16(dev, B43_MMIO_PHY_DATA) & mask) | set);
 }
 
 static u16 b43_lpphy_op_radio_read(struct b43_wldev *dev, u16 reg)
@@ -1920,8 +1927,8 @@ static void lpphy_b2062_reset_pll_bias(struct b43_wldev *dev)
 
 static void lpphy_b2062_vco_calib(struct b43_wldev *dev)
 {
-	b43_phy_write(dev, B2062_S_RFPLL_CTL21, 0x42);
-	b43_phy_write(dev, B2062_S_RFPLL_CTL21, 0x62);
+	b43_radio_write(dev, B2062_S_RFPLL_CTL21, 0x42);
+	b43_radio_write(dev, B2062_S_RFPLL_CTL21, 0x62);
 	udelay(200);
 }
 
@@ -1980,7 +1987,7 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
 	tmp6 = tmp5 / tmp4;
 	tmp7 = tmp5 % tmp4;
 	b43_radio_write(dev, B2062_S_RFPLL_CTL29, tmp6 + ((2 * tmp7) / tmp4));
-	tmp8 = b43_phy_read(dev, B2062_S_RFPLL_CTL19);
+	tmp8 = b43_radio_read(dev, B2062_S_RFPLL_CTL19);
 	tmp9 = ((2 * tmp3 * (tmp8 + 1)) + (3 * tmp1)) / (6 * tmp1);
 	b43_radio_write(dev, B2062_S_RFPLL_CTL23, (tmp9 >> 8) + 16);
 	b43_radio_write(dev, B2062_S_RFPLL_CTL24, tmp9 & 0xFF);
@@ -2019,17 +2026,17 @@ static void lpphy_b2063_vco_calib(struct b43_wldev *dev)
 {
 	u16 tmp;
 
-	b43_phy_mask(dev, B2063_PLL_SP1, ~0x40);
-	tmp = b43_phy_read(dev, B2063_PLL_JTAG_CALNRST) & 0xF8;
-	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp);
+	b43_radio_mask(dev, B2063_PLL_SP1, ~0x40);
+	tmp = b43_radio_read(dev, B2063_PLL_JTAG_CALNRST) & 0xF8;
+	b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp);
 	udelay(1);
-	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x4);
+	b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x4);
 	udelay(1);
-	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x6);
+	b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x6);
 	udelay(1);
-	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x7);
+	b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x7);
 	udelay(300);
-	b43_phy_set(dev, B2063_PLL_SP1, 0x40);
+	b43_radio_set(dev, B2063_PLL_SP1, 0x40);
 }
 
 static int lpphy_b2063_tune(struct b43_wldev *dev,
@@ -2124,31 +2131,31 @@ static int lpphy_b2063_tune(struct b43_wldev *dev,
 		scale = 0;
 		tmp5 = ((tmp4 + (tmp3 >> 1)) / tmp3) - 8;
 	}
-	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFC0, tmp5);
-	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFBF, scale << 6);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFC0, tmp5);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFBF, scale << 6);
 
 	tmp6 = lpphy_qdiv_roundup(100 * val1, val3, 16);
 	tmp6 *= (tmp5 * 8) * (scale + 1);
 	if (tmp6 > 150)
 		tmp6 = 0;
 
-	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFE0, tmp6);
-	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFDF, scale << 5);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFE0, tmp6);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFDF, scale << 5);
 
-	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFFFB, 0x4);
+	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFFFB, 0x4);
 	if (crystal_freq > 26000000)
-		b43_phy_set(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0x2);
+		b43_radio_set(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0x2);
 	else
-		b43_phy_mask(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFD);
+		b43_radio_mask(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFD);
 
 	if (val1 == 45)
-		b43_phy_set(dev, B2063_PLL_JTAG_PLL_VCO1, 0x2);
+		b43_radio_set(dev, B2063_PLL_JTAG_PLL_VCO1, 0x2);
 	else
-		b43_phy_mask(dev, B2063_PLL_JTAG_PLL_VCO1, 0xFD);
+		b43_radio_mask(dev, B2063_PLL_JTAG_PLL_VCO1, 0xFD);
 
-	b43_phy_set(dev, B2063_PLL_SP2, 0x3);
+	b43_radio_set(dev, B2063_PLL_SP2, 0x3);
 	udelay(1);
-	b43_phy_mask(dev, B2063_PLL_SP2, 0xFFFC);
+	b43_radio_mask(dev, B2063_PLL_SP2, 0xFFFC);
 	lpphy_b2063_vco_calib(dev);
 	b43_radio_write(dev, B2063_COMM15, old_comm15);
 
@@ -2158,10 +2165,9 @@ static int lpphy_b2063_tune(struct b43_wldev *dev,
 static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
 				       unsigned int new_channel)
 {
+	struct b43_phy_lp *lpphy = dev->phy.lp;
 	int err;
 
-	b43_write16(dev, B43_MMIO_CHANNEL, new_channel);
-
 	if (dev->phy.radio_ver == 0x2063) {
 		err = lpphy_b2063_tune(dev, new_channel);
 		if (err)
@@ -2174,6 +2180,9 @@ static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
 		lpphy_adjust_gain_table(dev, channel2freq_lp(new_channel));
 	}
 
+	lpphy->channel = new_channel;
+	b43_write16(dev, B43_MMIO_CHANNEL, new_channel);
+
 	return 0;
 }
 
@@ -2185,10 +2194,9 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
 	lpphy_baseband_init(dev);
 	lpphy_radio_init(dev);
 	lpphy_calibrate_rc(dev);
-	err = b43_lpphy_op_switch_channel(dev,
-				b43_lpphy_op_get_default_chan(dev));
+	err = b43_lpphy_op_switch_channel(dev, 7);
 	if (err) {
-		b43dbg(dev->wl, "Switch to init channel failed, error = %d.\n",
+		b43dbg(dev->wl, "Switch to channel 7 failed, error = %d.\n",
 		       err);
 	}
 	lpphy_tx_pctl_init(dev);
@@ -2222,6 +2230,7 @@ const struct b43_phy_operations b43_phyops_lp = {
 	.init			= b43_lpphy_op_init,
 	.phy_read		= b43_lpphy_op_read,
 	.phy_write		= b43_lpphy_op_write,
+	.phy_maskset		= b43_lpphy_op_maskset,
 	.radio_read		= b43_lpphy_op_radio_read,
 	.radio_write		= b43_lpphy_op_radio_write,
 	.software_rfkill	= b43_lpphy_op_software_rfkill,
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index e158d1f..c3232c1 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -888,6 +888,9 @@ struct b43_phy_lp {
 	bool crs_usr_disable, crs_sys_disable;
 
 	unsigned int pdiv;
+
+	/* The channel we are tuned to */
+	u8 channel;
 };
 
 enum tssi_mux_mode {
diff --git a/drivers/net/wireless/b43/tables_lpphy.c b/drivers/net/wireless/b43/tables_lpphy.c
index 60d472f..c784def 100644
--- a/drivers/net/wireless/b43/tables_lpphy.c
+++ b/drivers/net/wireless/b43/tables_lpphy.c
@@ -624,30 +624,35 @@ u32 b43_lptab_read(struct b43_wldev *dev, u32 offset)
 void b43_lptab_read_bulk(struct b43_wldev *dev, u32 offset,
 			 unsigned int nr_elements, void *_data)
 {
-	u32 type, value;
+	u32 type;
 	u8 *data = _data;
 	unsigned int i;
 
 	type = offset & B43_LPTAB_TYPEMASK;
+	offset &= ~B43_LPTAB_TYPEMASK;
+	B43_WARN_ON(offset > 0xFFFF);
+
+	b43_phy_write(dev, B43_LPPHY_TABLE_ADDR, offset);
+
 	for (i = 0; i < nr_elements; i++) {
-		value = b43_lptab_read(dev, offset);
 		switch (type) {
 		case B43_LPTAB_8BIT:
-			*data = value;
+			*data = b43_phy_read(dev, B43_LPPHY_TABLEDATALO) & 0xFF;
 			data++;
 			break;
 		case B43_LPTAB_16BIT:
-			*((u16 *)data) = value;
+			*((u16 *)data) = b43_phy_read(dev, B43_LPPHY_TABLEDATALO);
 			data += 2;
 			break;
 		case B43_LPTAB_32BIT:
-			*((u32 *)data) = value;
+			*((u32 *)data) = b43_phy_read(dev, B43_LPPHY_TABLEDATAHI);
+			*((u32 *)data) <<= 16;
+			*((u32 *)data) |= b43_phy_read(dev, B43_LPPHY_TABLEDATALO);
 			data += 4;
 			break;
 		default:
 			B43_WARN_ON(1);
 		}
-		offset++;
 	}
 }
 
@@ -688,26 +693,34 @@ void b43_lptab_write_bulk(struct b43_wldev *dev, u32 offset,
 	unsigned int i;
 
 	type = offset & B43_LPTAB_TYPEMASK;
+	offset &= ~B43_LPTAB_TYPEMASK;
+	B43_WARN_ON(offset > 0xFFFF);
+
+	b43_phy_write(dev, B43_LPPHY_TABLE_ADDR, offset);
+
 	for (i = 0; i < nr_elements; i++) {
 		switch (type) {
 		case B43_LPTAB_8BIT:
 			value = *data;
 			data++;
+			B43_WARN_ON(value & ~0xFF);
+			b43_phy_write(dev, B43_LPPHY_TABLEDATALO, value);
 			break;
 		case B43_LPTAB_16BIT:
 			value = *((u16 *)data);
 			data += 2;
+			B43_WARN_ON(value & ~0xFFFF);
+			b43_phy_write(dev, B43_LPPHY_TABLEDATALO, value);
 			break;
 		case B43_LPTAB_32BIT:
 			value = *((u32 *)data);
 			data += 4;
+			b43_phy_write(dev, B43_LPPHY_TABLEDATAHI, value >> 16);
+			b43_phy_write(dev, B43_LPPHY_TABLEDATALO, value);
 			break;
 		default:
 			B43_WARN_ON(1);
-			value = 0;
 		}
-		b43_lptab_write(dev, offset, value);
-		offset++;
 	}
 }
 
@@ -777,7 +790,7 @@ static const u8 lpphy_pll_fraction_table[] = {
 	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
 };
 
-static const u16 lpphy_iq_local_table[] = {
+static const u16 lpphy_iqlo_cal_table[] = {
 	0x0200, 0x0300, 0x0400, 0x0600, 0x0800, 0x0b00, 0x1000, 0x1001, 0x1002,
 	0x1003, 0x1004, 0x1005, 0x1006, 0x1007, 0x1707, 0x2007, 0x2d07, 0x4007,
 	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
@@ -789,10 +802,17 @@ static const u16 lpphy_iq_local_table[] = {
 	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4000, 0x0000, 0x0000,
 	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-	0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 };
 
-static const u16 lpphy_ofdm_cck_gain_table[] = {
+static const u16 lpphy_rev0_ofdm_cck_gain_table[] = {
+	0x0001, 0x0001, 0x0001, 0x0001, 0x1001, 0x2001, 0x3001, 0x4001, 0x5001,
+	0x6001, 0x7001, 0x7011, 0x7021, 0x2035, 0x2045, 0x2055, 0x2065, 0x2075,
+	0x006d, 0x007d, 0x014d, 0x015d, 0x115d, 0x035d, 0x135d, 0x055d, 0x155d,
+	0x0d5d, 0x1d5d, 0x2d5d, 0x555d, 0x655d, 0x755d,
+};
+
+static const u16 lpphy_rev1_ofdm_cck_gain_table[] = {
 	0x5000, 0x6000, 0x7000, 0x0001, 0x1001, 0x2001, 0x3001, 0x4001, 0x5001,
 	0x6001, 0x7001, 0x7011, 0x7021, 0x2035, 0x2045, 0x2055, 0x2065, 0x2075,
 	0x006d, 0x007d, 0x014d, 0x015d, 0x115d, 0x035d, 0x135d, 0x055d, 0x155d,
@@ -2263,11 +2283,18 @@ void lpphy_rev0_1_table_init(struct b43_wldev *dev)
 	b43_lptab_write_bulk(dev, B43_LPTAB8(6, 0),
 		ARRAY_SIZE(lpphy_pll_fraction_table), lpphy_pll_fraction_table);
 	b43_lptab_write_bulk(dev, B43_LPTAB16(0, 0),
-		ARRAY_SIZE(lpphy_iq_local_table), lpphy_iq_local_table);
-	b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0),
-		ARRAY_SIZE(lpphy_ofdm_cck_gain_table), lpphy_ofdm_cck_gain_table);
-	b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0),
-		ARRAY_SIZE(lpphy_ofdm_cck_gain_table), lpphy_ofdm_cck_gain_table);
+		ARRAY_SIZE(lpphy_iqlo_cal_table), lpphy_iqlo_cal_table);
+	if (dev->phy.rev == 0) {
+		b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0),
+			ARRAY_SIZE(lpphy_rev0_ofdm_cck_gain_table), lpphy_rev0_ofdm_cck_gain_table);
+		b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0),
+			ARRAY_SIZE(lpphy_rev0_ofdm_cck_gain_table), lpphy_rev0_ofdm_cck_gain_table);
+	} else {
+		b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0),
+			ARRAY_SIZE(lpphy_rev1_ofdm_cck_gain_table), lpphy_rev1_ofdm_cck_gain_table);
+		b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0),
+			ARRAY_SIZE(lpphy_rev1_ofdm_cck_gain_table), lpphy_rev1_ofdm_cck_gain_table);
+}
 	b43_lptab_write_bulk(dev, B43_LPTAB16(15, 0),
 		ARRAY_SIZE(lpphy_gain_delta_table), lpphy_gain_delta_table);
 	b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0),
@@ -2281,22 +2308,6 @@ void lpphy_rev2plus_table_init(struct b43_wldev *dev)
 
 	B43_WARN_ON(dev->phy.rev < 2);
 
-	/*
-	 * FIXME This code follows the specs, but it looks wrong:
-	 * In each pass, it writes 4 bytes to an offset in table ID 7,
-	 * then increments the offset by 1 for the next pass. This results
-	 * in the first 3 bytes of each pass except the first one getting
-	 * written to a location that has already been zeroed in the previous
-	 * pass.
-	 * This is what the vendor driver does, but it still looks suspicious.
-	 *
-	 * This should probably suffice:
-	 *
-	 * for (i = 0; i < 704; i+=4)
-	 * 	b43_lptab_write(dev, B43_LPTAB32(7, i), 0)
-	 *
-	 * This should be tested once the code is functional.
-	 */
 	for (i = 0; i < 704; i++)
 		b43_lptab_write(dev, B43_LPTAB32(7, i), 0);
 
@@ -2323,7 +2334,7 @@ void lpphy_rev2plus_table_init(struct b43_wldev *dev)
 	b43_lptab_write_bulk(dev, B43_LPTAB8(6, 0),
 		ARRAY_SIZE(lpphy_pll_fraction_table), lpphy_pll_fraction_table);
 	b43_lptab_write_bulk(dev, B43_LPTAB16(0, 0),
-		ARRAY_SIZE(lpphy_iq_local_table), lpphy_iq_local_table);
+		ARRAY_SIZE(lpphy_iqlo_cal_table), lpphy_iqlo_cal_table);
 	b43_lptab_write_bulk(dev, B43_LPTAB32(9, 0),
 		ARRAY_SIZE(lpphy_papd_eps_table), lpphy_papd_eps_table);
 	b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0),
-- 
1.5.6



From netrolller.3d at gmail.com  Wed Aug 26 21:48:52 2009
From: netrolller.3d at gmail.com (=?utf-8?q?G=C3=A1bor=20Stefanik?=)
Date: Wed, 26 Aug 2009 21:48:52 +0200
Subject: [PATCH] b43: Remove scary message from LP-PHY's Kconfig
Message-ID: <1251316132-392-1-git-send-email-netrolller.3d@gmail.com>

From: root G?bor Stefanik <netrolller.3d at gmail.com>

The most common LP-PHY device, BCM4312, is now fully functional.
So, no need to say "probably won't work for you" anymore.
It's also not "for debuggers and developers only", as it is
perfectly usable for end-users now (at least for BCM4312).

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
This should only be applied once the "Qdiv roundup" and the "Fix and update"
patches reach the tree, as those 2 patches are needed to make the BCM4312
really work.

 drivers/net/wireless/b43/Kconfig |    3 ---
 1 files changed, 0 insertions(+), 3 deletions(-)

diff --git a/drivers/net/wireless/b43/Kconfig b/drivers/net/wireless/b43/Kconfig
index 87d10c8..1c0999b 100644
--- a/drivers/net/wireless/b43/Kconfig
+++ b/drivers/net/wireless/b43/Kconfig
@@ -88,9 +88,6 @@ config B43_PHY_LP
 	  and embedded devices. It supports 802.11a/g
 	  (802.11a support is optional, and currently disabled).
 
-	  This is heavily experimental, and probably will not work for you.
-	  Say N unless you want to help debug the driver.
-
 # This config option automatically enables b43 LEDS support,
 # if it's possible.
 config B43_LEDS
-- 
1.5.6



From mb at bu3sch.de  Wed Aug 26 22:42:48 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 26 Aug 2009 22:42:48 +0200
Subject: [PATCH] b43: Fix and update LP-PHY code
In-Reply-To: <1251312686-32067-2-git-send-email-netrolller.3d@gmail.com>
References: <1251312686-32067-1-git-send-email-netrolller.3d@gmail.com>
	<1251312686-32067-2-git-send-email-netrolller.3d@gmail.com>
Message-ID: <200908262242.50729.mb@bu3sch.de>

On Wednesday 26 August 2009 20:51:25 G?bor Stefanik wrote:
> -Fix a few nasty typos (b43_phy_* operations instead of b43_radio_*)
>  in the channel tune routines.
> -Fix some typos & spec errors found by MMIO tracing.
> -Optimize b43_phy_write & b43_phy_mask/set/maskset to use
>  only the minimal number of MMIO accesses. (Write is possible
>  using a single 32-bit MMIO write, while set/mask/maskset can
>  be done in 3 16-bit MMIOs).

Why does it matter? PHY access is not done in any hotpath. So why
not prefer simple code over optimized code? 

> -Set the default channel back to 1, as the bug forcing us to use
>  channel 7 is now fixed.

And, everything in its own patch, please. I don't see a reason for
patching unrelated things in one big patch.

> 
> With this, the device comes up, scans, associates, transmits,
> receives, monitors and injects on all channels - in other words,
> it's fully functional. Sensitivity and TX power are still sub-optimal,
> due to the lack of calibration (that's next on my list).
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
>  drivers/net/wireless/b43/phy_common.c   |   27 +++++++--
>  drivers/net/wireless/b43/phy_common.h   |    3 +
>  drivers/net/wireless/b43/phy_lp.c       |   91 +++++++++++++++++--------------
>  drivers/net/wireless/b43/phy_lp.h       |    3 +
>  drivers/net/wireless/b43/tables_lpphy.c |   79 +++++++++++++++------------
>  5 files changed, 122 insertions(+), 81 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_common.c b/drivers/net/wireless/b43/phy_common.c
> index 51686ec..6e704be 100644
> --- a/drivers/net/wireless/b43/phy_common.c
> +++ b/drivers/net/wireless/b43/phy_common.c
> @@ -249,20 +249,35 @@ void b43_phy_copy(struct b43_wldev *dev, u16 destreg, u16 srcreg)
>  
>  void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
>  {
> -	b43_phy_write(dev, offset,
> -		      b43_phy_read(dev, offset) & mask);
> +	if (dev->phy.ops->phy_maskset) {
> +		assert_mac_suspended(dev);
> +		dev->phy.ops->phy_maskset(dev, offset, mask, 0);
> +	} else {
> +		b43_phy_write(dev, offset,
> +			      b43_phy_read(dev, offset) & mask);
> +	}
>  }
>  
>  void b43_phy_set(struct b43_wldev *dev, u16 offset, u16 set)
>  {
> -	b43_phy_write(dev, offset,
> -		      b43_phy_read(dev, offset) | set);
> +	if (dev->phy.ops->phy_maskset) {
> +		assert_mac_suspended(dev);
> +		dev->phy.ops->phy_maskset(dev, offset, 0xFFFF, set);
> +	} else {
> +		b43_phy_write(dev, offset,
> +			      b43_phy_read(dev, offset) | set);
> +	}
>  }
>  
>  void b43_phy_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set)
>  {
> -	b43_phy_write(dev, offset,
> -		      (b43_phy_read(dev, offset) & mask) | set);
> +	if (dev->phy.ops->phy_maskset) {
> +		assert_mac_suspended(dev);
> +		dev->phy.ops->phy_maskset(dev, offset, mask, set);
> +	} else {
> +		b43_phy_write(dev, offset,
> +			      (b43_phy_read(dev, offset) & mask) | set);
> +	}
>  }
>  
>  int b43_switch_channel(struct b43_wldev *dev, unsigned int new_channel)
> diff --git a/drivers/net/wireless/b43/phy_common.h b/drivers/net/wireless/b43/phy_common.h
> index 9f9f23c..b47a0f5 100644
> --- a/drivers/net/wireless/b43/phy_common.h
> +++ b/drivers/net/wireless/b43/phy_common.h
> @@ -95,6 +95,8 @@ enum b43_txpwr_result {
>   * 			Must not be NULL.
>   * @phy_write:		Write to a PHY register.
>   * 			Must not be NULL.
> + * @phy_maskset:	Maskset a PHY register, taking shortcuts.
> + *			If it is NULL, a generic algorithm is used.
>   * @radio_read:		Read from a Radio register.
>   * 			Must not be NULL.
>   * @radio_write:	Write to a Radio register.
> @@ -154,6 +156,7 @@ struct b43_phy_operations {
>  	/* Register access */
>  	u16 (*phy_read)(struct b43_wldev *dev, u16 reg);
>  	void (*phy_write)(struct b43_wldev *dev, u16 reg, u16 value);
> +	void (*phy_maskset)(struct b43_wldev *dev, u16 reg, u16 mask, u16 set);
>  	u16 (*radio_read)(struct b43_wldev *dev, u16 reg);
>  	void (*radio_write)(struct b43_wldev *dev, u16 reg, u16 value);
>  
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index 5306f2c..1a57d33 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -44,7 +44,7 @@ static inline u16 channel2freq_lp(u8 channel)
>  static unsigned int b43_lpphy_op_get_default_chan(struct b43_wldev *dev)
>  {
>  	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
> -		return 7; //FIXME temporary - channel 1 is broken
> +		return 1;
>  	return 36;
>  }
>  
> @@ -182,8 +182,8 @@ static void lpphy_adjust_gain_table(struct b43_wldev *dev, u32 freq)
>  	temp[1] = temp[0] + 0x1000;
>  	temp[2] = temp[0] + 0x2000;
>  
> -	b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0), 3, temp);
>  	b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0), 3, temp);
> +	b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0), 3, temp);
>  }
>  
>  static void lpphy_table_init(struct b43_wldev *dev)
> @@ -223,8 +223,8 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
>  	b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0xFF00, 0x0006);
>  	b43_phy_mask(dev, B43_LPPHY_RX_RADIO_CTL, 0xFFFE);
>  	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x0005);
> -	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC10, 0x0180);
> -	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x3800);
> +	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC1F, 0x0180);
> +	b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x3C00);
>  	b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xFFF0, 0x0005);
>  	b43_phy_maskset(dev, B43_LPPHY_GAIN_MISMATCH_LIMIT, 0xFFC0, 0x001A);
>  	b43_phy_maskset(dev, B43_LPPHY_CRS_ED_THRESH, 0xFF00, 0x00B3);
> @@ -237,7 +237,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
>  		/* TODO:
>  		 * Set the LDO voltage to 0x0028 - FIXME: What is this?
>  		 * Call sb_pmu_set_ldo_voltage with 4 and the LDO voltage
> -		 * 	as arguments
> +		 *      as arguments
>  		 * Call sb_pmu_paref_ldo_enable with argument TRUE
>  		 */
>  		if (dev->phy.rev == 0) {
> @@ -340,11 +340,11 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
>  	if (dev->phy.rev == 1) {
>  		tmp = b43_phy_read(dev, B43_LPPHY_CLIPCTRTHRESH);
>  		tmp2 = (tmp & 0x03E0) >> 5;
> -		tmp2 |= tmp << 5;
> +		tmp2 |= tmp2 << 5;
>  		b43_phy_write(dev, B43_LPPHY_4C3, tmp2);
> -		tmp = b43_phy_read(dev, B43_LPPHY_OFDMSYNCTHRESH0);
> +		tmp = b43_phy_read(dev, B43_LPPHY_GAINDIRECTMISMATCH);
>  		tmp2 = (tmp & 0x1F00) >> 8;
> -		tmp2 |= tmp << 5;
> +		tmp2 |= tmp2 << 5;
>  		b43_phy_write(dev, B43_LPPHY_4C4, tmp2);
>  		tmp = b43_phy_read(dev, B43_LPPHY_VERYLOWGAINDB);
>  		tmp2 = tmp & 0x00FF;
> @@ -761,7 +761,7 @@ static void lpphy_disable_crs(struct b43_wldev *dev, bool user)
>  	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
>  	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
>  	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x4);
> -	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFF7);
> +	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFF7);
>  	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
>  	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x10);
>  	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
> @@ -956,7 +956,7 @@ static void lpphy_run_ddfs(struct b43_wldev *dev, int i_on, int q_on,
>  	b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFF9F, scale_idx << 5);
>  	b43_phy_mask(dev, B43_LPPHY_AFE_DDFS, 0xFFFB);
>  	b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x2);
> -	b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x20);
> +	b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x20);
>  }
>  
>  static bool lpphy_rx_iq_est(struct b43_wldev *dev, u16 samples, u8 time,
> @@ -968,7 +968,7 @@ static bool lpphy_rx_iq_est(struct b43_wldev *dev, u16 samples, u8 time,
>  	b43_phy_write(dev, B43_LPPHY_IQ_NUM_SMPLS_ADDR, samples);
>  	b43_phy_maskset(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFF00, time);
>  	b43_phy_mask(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFEFF);
> -	b43_phy_set(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFDFF);
> +	b43_phy_set(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0x200);
>  
>  	for (i = 0; i < 500; i++) {
>  		if (!(b43_phy_read(dev,
> @@ -1135,9 +1135,9 @@ static void lpphy_set_tx_power_control(struct b43_wldev *dev,
>  	}
>  	if (dev->phy.rev >= 2) {
>  		if (mode == B43_LPPHY_TXPCTL_HW)
> -			b43_phy_maskset(dev, B43_PHY_OFDM(0xD0), 0xFD, 0x2);
> +			b43_phy_set(dev, B43_PHY_OFDM(0xD0), 0x2);
>  		else
> -			b43_phy_maskset(dev, B43_PHY_OFDM(0xD0), 0xFD, 0);
> +			b43_phy_mask(dev, B43_PHY_OFDM(0xD0), 0xFFFD);
>  	}
>  	lpphy_write_tx_pctl_mode_to_hardware(dev);
>  }
> @@ -1169,7 +1169,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
>  	err = b43_lpphy_op_switch_channel(dev, 7);
>  	if (err) {
>  		b43dbg(dev->wl,
> -		       "RC calib: Failed to switch to channel 7, error = %d",
> +		       "RC calib: Failed to switch to channel 7, error = %d\n",
>  		       err);
>  	}
>  	old_txg_ovr = !!(b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40);
> @@ -1500,8 +1500,15 @@ static u16 b43_lpphy_op_read(struct b43_wldev *dev, u16 reg)
>  
>  static void b43_lpphy_op_write(struct b43_wldev *dev, u16 reg, u16 value)
>  {
> +	b43_write32(dev, B43_MMIO_PHY_CONTROL, ((u32)value << 16) | reg);
> +}
> +
> +static void b43_lpphy_op_maskset(struct b43_wldev *dev, u16 reg, u16 mask,
> +				 u16 set)
> +{
>  	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
> -	b43_write16(dev, B43_MMIO_PHY_DATA, value);
> +	b43_write16(dev, B43_MMIO_PHY_DATA,
> +		    (b43_read16(dev, B43_MMIO_PHY_DATA) & mask) | set);
>  }
>  
>  static u16 b43_lpphy_op_radio_read(struct b43_wldev *dev, u16 reg)
> @@ -1920,8 +1927,8 @@ static void lpphy_b2062_reset_pll_bias(struct b43_wldev *dev)
>  
>  static void lpphy_b2062_vco_calib(struct b43_wldev *dev)
>  {
> -	b43_phy_write(dev, B2062_S_RFPLL_CTL21, 0x42);
> -	b43_phy_write(dev, B2062_S_RFPLL_CTL21, 0x62);
> +	b43_radio_write(dev, B2062_S_RFPLL_CTL21, 0x42);
> +	b43_radio_write(dev, B2062_S_RFPLL_CTL21, 0x62);
>  	udelay(200);
>  }
>  
> @@ -1980,7 +1987,7 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
>  	tmp6 = tmp5 / tmp4;
>  	tmp7 = tmp5 % tmp4;
>  	b43_radio_write(dev, B2062_S_RFPLL_CTL29, tmp6 + ((2 * tmp7) / tmp4));
> -	tmp8 = b43_phy_read(dev, B2062_S_RFPLL_CTL19);
> +	tmp8 = b43_radio_read(dev, B2062_S_RFPLL_CTL19);
>  	tmp9 = ((2 * tmp3 * (tmp8 + 1)) + (3 * tmp1)) / (6 * tmp1);
>  	b43_radio_write(dev, B2062_S_RFPLL_CTL23, (tmp9 >> 8) + 16);
>  	b43_radio_write(dev, B2062_S_RFPLL_CTL24, tmp9 & 0xFF);
> @@ -2019,17 +2026,17 @@ static void lpphy_b2063_vco_calib(struct b43_wldev *dev)
>  {
>  	u16 tmp;
>  
> -	b43_phy_mask(dev, B2063_PLL_SP1, ~0x40);
> -	tmp = b43_phy_read(dev, B2063_PLL_JTAG_CALNRST) & 0xF8;
> -	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp);
> +	b43_radio_mask(dev, B2063_PLL_SP1, ~0x40);
> +	tmp = b43_radio_read(dev, B2063_PLL_JTAG_CALNRST) & 0xF8;
> +	b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp);
>  	udelay(1);
> -	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x4);
> +	b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x4);
>  	udelay(1);
> -	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x6);
> +	b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x6);
>  	udelay(1);
> -	b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x7);
> +	b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x7);
>  	udelay(300);
> -	b43_phy_set(dev, B2063_PLL_SP1, 0x40);
> +	b43_radio_set(dev, B2063_PLL_SP1, 0x40);
>  }
>  
>  static int lpphy_b2063_tune(struct b43_wldev *dev,
> @@ -2124,31 +2131,31 @@ static int lpphy_b2063_tune(struct b43_wldev *dev,
>  		scale = 0;
>  		tmp5 = ((tmp4 + (tmp3 >> 1)) / tmp3) - 8;
>  	}
> -	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFC0, tmp5);
> -	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFBF, scale << 6);
> +	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFC0, tmp5);
> +	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFBF, scale << 6);
>  
>  	tmp6 = lpphy_qdiv_roundup(100 * val1, val3, 16);
>  	tmp6 *= (tmp5 * 8) * (scale + 1);
>  	if (tmp6 > 150)
>  		tmp6 = 0;
>  
> -	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFE0, tmp6);
> -	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFDF, scale << 5);
> +	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFE0, tmp6);
> +	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFDF, scale << 5);
>  
> -	b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFFFB, 0x4);
> +	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFFFB, 0x4);
>  	if (crystal_freq > 26000000)
> -		b43_phy_set(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0x2);
> +		b43_radio_set(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0x2);
>  	else
> -		b43_phy_mask(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFD);
> +		b43_radio_mask(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFD);
>  
>  	if (val1 == 45)
> -		b43_phy_set(dev, B2063_PLL_JTAG_PLL_VCO1, 0x2);
> +		b43_radio_set(dev, B2063_PLL_JTAG_PLL_VCO1, 0x2);
>  	else
> -		b43_phy_mask(dev, B2063_PLL_JTAG_PLL_VCO1, 0xFD);
> +		b43_radio_mask(dev, B2063_PLL_JTAG_PLL_VCO1, 0xFD);
>  
> -	b43_phy_set(dev, B2063_PLL_SP2, 0x3);
> +	b43_radio_set(dev, B2063_PLL_SP2, 0x3);
>  	udelay(1);
> -	b43_phy_mask(dev, B2063_PLL_SP2, 0xFFFC);
> +	b43_radio_mask(dev, B2063_PLL_SP2, 0xFFFC);
>  	lpphy_b2063_vco_calib(dev);
>  	b43_radio_write(dev, B2063_COMM15, old_comm15);
>  
> @@ -2158,10 +2165,9 @@ static int lpphy_b2063_tune(struct b43_wldev *dev,
>  static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
>  				       unsigned int new_channel)
>  {
> +	struct b43_phy_lp *lpphy = dev->phy.lp;
>  	int err;
>  
> -	b43_write16(dev, B43_MMIO_CHANNEL, new_channel);
> -
>  	if (dev->phy.radio_ver == 0x2063) {
>  		err = lpphy_b2063_tune(dev, new_channel);
>  		if (err)
> @@ -2174,6 +2180,9 @@ static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
>  		lpphy_adjust_gain_table(dev, channel2freq_lp(new_channel));
>  	}
>  
> +	lpphy->channel = new_channel;
> +	b43_write16(dev, B43_MMIO_CHANNEL, new_channel);
> +
>  	return 0;
>  }
>  
> @@ -2185,10 +2194,9 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
>  	lpphy_baseband_init(dev);
>  	lpphy_radio_init(dev);
>  	lpphy_calibrate_rc(dev);
> -	err = b43_lpphy_op_switch_channel(dev,
> -				b43_lpphy_op_get_default_chan(dev));
> +	err = b43_lpphy_op_switch_channel(dev, 7);
>  	if (err) {
> -		b43dbg(dev->wl, "Switch to init channel failed, error = %d.\n",
> +		b43dbg(dev->wl, "Switch to channel 7 failed, error = %d.\n",
>  		       err);
>  	}
>  	lpphy_tx_pctl_init(dev);
> @@ -2222,6 +2230,7 @@ const struct b43_phy_operations b43_phyops_lp = {
>  	.init			= b43_lpphy_op_init,
>  	.phy_read		= b43_lpphy_op_read,
>  	.phy_write		= b43_lpphy_op_write,
> +	.phy_maskset		= b43_lpphy_op_maskset,
>  	.radio_read		= b43_lpphy_op_radio_read,
>  	.radio_write		= b43_lpphy_op_radio_write,
>  	.software_rfkill	= b43_lpphy_op_software_rfkill,
> diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
> index e158d1f..c3232c1 100644
> --- a/drivers/net/wireless/b43/phy_lp.h
> +++ b/drivers/net/wireless/b43/phy_lp.h
> @@ -888,6 +888,9 @@ struct b43_phy_lp {
>  	bool crs_usr_disable, crs_sys_disable;
>  
>  	unsigned int pdiv;
> +
> +	/* The channel we are tuned to */
> +	u8 channel;
>  };
>  
>  enum tssi_mux_mode {
> diff --git a/drivers/net/wireless/b43/tables_lpphy.c b/drivers/net/wireless/b43/tables_lpphy.c
> index 60d472f..c784def 100644
> --- a/drivers/net/wireless/b43/tables_lpphy.c
> +++ b/drivers/net/wireless/b43/tables_lpphy.c
> @@ -624,30 +624,35 @@ u32 b43_lptab_read(struct b43_wldev *dev, u32 offset)
>  void b43_lptab_read_bulk(struct b43_wldev *dev, u32 offset,
>  			 unsigned int nr_elements, void *_data)
>  {
> -	u32 type, value;
> +	u32 type;
>  	u8 *data = _data;
>  	unsigned int i;
>  
>  	type = offset & B43_LPTAB_TYPEMASK;
> +	offset &= ~B43_LPTAB_TYPEMASK;
> +	B43_WARN_ON(offset > 0xFFFF);
> +
> +	b43_phy_write(dev, B43_LPPHY_TABLE_ADDR, offset);
> +
>  	for (i = 0; i < nr_elements; i++) {
> -		value = b43_lptab_read(dev, offset);
>  		switch (type) {
>  		case B43_LPTAB_8BIT:
> -			*data = value;
> +			*data = b43_phy_read(dev, B43_LPPHY_TABLEDATALO) & 0xFF;
>  			data++;
>  			break;
>  		case B43_LPTAB_16BIT:
> -			*((u16 *)data) = value;
> +			*((u16 *)data) = b43_phy_read(dev, B43_LPPHY_TABLEDATALO);
>  			data += 2;
>  			break;
>  		case B43_LPTAB_32BIT:
> -			*((u32 *)data) = value;
> +			*((u32 *)data) = b43_phy_read(dev, B43_LPPHY_TABLEDATAHI);
> +			*((u32 *)data) <<= 16;
> +			*((u32 *)data) |= b43_phy_read(dev, B43_LPPHY_TABLEDATALO);
>  			data += 4;
>  			break;
>  		default:
>  			B43_WARN_ON(1);
>  		}
> -		offset++;
>  	}
>  }
>  
> @@ -688,26 +693,34 @@ void b43_lptab_write_bulk(struct b43_wldev *dev, u32 offset,
>  	unsigned int i;
>  
>  	type = offset & B43_LPTAB_TYPEMASK;
> +	offset &= ~B43_LPTAB_TYPEMASK;
> +	B43_WARN_ON(offset > 0xFFFF);
> +
> +	b43_phy_write(dev, B43_LPPHY_TABLE_ADDR, offset);
> +
>  	for (i = 0; i < nr_elements; i++) {
>  		switch (type) {
>  		case B43_LPTAB_8BIT:
>  			value = *data;
>  			data++;
> +			B43_WARN_ON(value & ~0xFF);
> +			b43_phy_write(dev, B43_LPPHY_TABLEDATALO, value);
>  			break;
>  		case B43_LPTAB_16BIT:
>  			value = *((u16 *)data);
>  			data += 2;
> +			B43_WARN_ON(value & ~0xFFFF);
> +			b43_phy_write(dev, B43_LPPHY_TABLEDATALO, value);
>  			break;
>  		case B43_LPTAB_32BIT:
>  			value = *((u32 *)data);
>  			data += 4;
> +			b43_phy_write(dev, B43_LPPHY_TABLEDATAHI, value >> 16);
> +			b43_phy_write(dev, B43_LPPHY_TABLEDATALO, value);
>  			break;
>  		default:
>  			B43_WARN_ON(1);
> -			value = 0;
>  		}
> -		b43_lptab_write(dev, offset, value);
> -		offset++;
>  	}
>  }
>  
> @@ -777,7 +790,7 @@ static const u8 lpphy_pll_fraction_table[] = {
>  	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
>  };
>  
> -static const u16 lpphy_iq_local_table[] = {
> +static const u16 lpphy_iqlo_cal_table[] = {
>  	0x0200, 0x0300, 0x0400, 0x0600, 0x0800, 0x0b00, 0x1000, 0x1001, 0x1002,
>  	0x1003, 0x1004, 0x1005, 0x1006, 0x1007, 0x1707, 0x2007, 0x2d07, 0x4007,
>  	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
> @@ -789,10 +802,17 @@ static const u16 lpphy_iq_local_table[] = {
>  	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
>  	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4000, 0x0000, 0x0000,
>  	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
> -	0x0000, 0x0000,
> +	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
>  };
>  
> -static const u16 lpphy_ofdm_cck_gain_table[] = {
> +static const u16 lpphy_rev0_ofdm_cck_gain_table[] = {
> +	0x0001, 0x0001, 0x0001, 0x0001, 0x1001, 0x2001, 0x3001, 0x4001, 0x5001,
> +	0x6001, 0x7001, 0x7011, 0x7021, 0x2035, 0x2045, 0x2055, 0x2065, 0x2075,
> +	0x006d, 0x007d, 0x014d, 0x015d, 0x115d, 0x035d, 0x135d, 0x055d, 0x155d,
> +	0x0d5d, 0x1d5d, 0x2d5d, 0x555d, 0x655d, 0x755d,
> +};
> +
> +static const u16 lpphy_rev1_ofdm_cck_gain_table[] = {
>  	0x5000, 0x6000, 0x7000, 0x0001, 0x1001, 0x2001, 0x3001, 0x4001, 0x5001,
>  	0x6001, 0x7001, 0x7011, 0x7021, 0x2035, 0x2045, 0x2055, 0x2065, 0x2075,
>  	0x006d, 0x007d, 0x014d, 0x015d, 0x115d, 0x035d, 0x135d, 0x055d, 0x155d,
> @@ -2263,11 +2283,18 @@ void lpphy_rev0_1_table_init(struct b43_wldev *dev)
>  	b43_lptab_write_bulk(dev, B43_LPTAB8(6, 0),
>  		ARRAY_SIZE(lpphy_pll_fraction_table), lpphy_pll_fraction_table);
>  	b43_lptab_write_bulk(dev, B43_LPTAB16(0, 0),
> -		ARRAY_SIZE(lpphy_iq_local_table), lpphy_iq_local_table);
> -	b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0),
> -		ARRAY_SIZE(lpphy_ofdm_cck_gain_table), lpphy_ofdm_cck_gain_table);
> -	b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0),
> -		ARRAY_SIZE(lpphy_ofdm_cck_gain_table), lpphy_ofdm_cck_gain_table);
> +		ARRAY_SIZE(lpphy_iqlo_cal_table), lpphy_iqlo_cal_table);
> +	if (dev->phy.rev == 0) {
> +		b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0),
> +			ARRAY_SIZE(lpphy_rev0_ofdm_cck_gain_table), lpphy_rev0_ofdm_cck_gain_table);
> +		b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0),
> +			ARRAY_SIZE(lpphy_rev0_ofdm_cck_gain_table), lpphy_rev0_ofdm_cck_gain_table);
> +	} else {
> +		b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0),
> +			ARRAY_SIZE(lpphy_rev1_ofdm_cck_gain_table), lpphy_rev1_ofdm_cck_gain_table);
> +		b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0),
> +			ARRAY_SIZE(lpphy_rev1_ofdm_cck_gain_table), lpphy_rev1_ofdm_cck_gain_table);
> +}
>  	b43_lptab_write_bulk(dev, B43_LPTAB16(15, 0),
>  		ARRAY_SIZE(lpphy_gain_delta_table), lpphy_gain_delta_table);
>  	b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0),
> @@ -2281,22 +2308,6 @@ void lpphy_rev2plus_table_init(struct b43_wldev *dev)
>  
>  	B43_WARN_ON(dev->phy.rev < 2);
>  
> -	/*
> -	 * FIXME This code follows the specs, but it looks wrong:
> -	 * In each pass, it writes 4 bytes to an offset in table ID 7,
> -	 * then increments the offset by 1 for the next pass. This results
> -	 * in the first 3 bytes of each pass except the first one getting
> -	 * written to a location that has already been zeroed in the previous
> -	 * pass.
> -	 * This is what the vendor driver does, but it still looks suspicious.
> -	 *
> -	 * This should probably suffice:
> -	 *
> -	 * for (i = 0; i < 704; i+=4)
> -	 * 	b43_lptab_write(dev, B43_LPTAB32(7, i), 0)
> -	 *
> -	 * This should be tested once the code is functional.
> -	 */
>  	for (i = 0; i < 704; i++)
>  		b43_lptab_write(dev, B43_LPTAB32(7, i), 0);
>  
> @@ -2323,7 +2334,7 @@ void lpphy_rev2plus_table_init(struct b43_wldev *dev)
>  	b43_lptab_write_bulk(dev, B43_LPTAB8(6, 0),
>  		ARRAY_SIZE(lpphy_pll_fraction_table), lpphy_pll_fraction_table);
>  	b43_lptab_write_bulk(dev, B43_LPTAB16(0, 0),
> -		ARRAY_SIZE(lpphy_iq_local_table), lpphy_iq_local_table);
> +		ARRAY_SIZE(lpphy_iqlo_cal_table), lpphy_iqlo_cal_table);
>  	b43_lptab_write_bulk(dev, B43_LPTAB32(9, 0),
>  		ARRAY_SIZE(lpphy_papd_eps_table), lpphy_papd_eps_table);
>  	b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0),



-- 
Greetings, Michael.


From mb at bu3sch.de  Wed Aug 26 22:46:24 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 26 Aug 2009 22:46:24 +0200
Subject: [PATCH] ssb: Implement PMU LDO control and use it in b43
In-Reply-To: <1251312686-32067-3-git-send-email-netrolller.3d@gmail.com>
References: <1251312686-32067-1-git-send-email-netrolller.3d@gmail.com>
	<1251312686-32067-2-git-send-email-netrolller.3d@gmail.com>
	<1251312686-32067-3-git-send-email-netrolller.3d@gmail.com>
Message-ID: <200908262246.26668.mb@bu3sch.de>

On Wednesday 26 August 2009 20:51:26 G?bor Stefanik wrote:
> Implement the "PMU LDO set voltage" and "PMU LDO PA ref enable"
> functions, and use them during LP-PHY baseband init in b43.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>

ack

-- 
Greetings, Michael.


From mb at bu3sch.de  Wed Aug 26 22:47:05 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 26 Aug 2009 22:47:05 +0200
Subject: [PATCH] b43: Remove scary message from LP-PHY's Kconfig
In-Reply-To: <1251316132-392-1-git-send-email-netrolller.3d@gmail.com>
References: <1251316132-392-1-git-send-email-netrolller.3d@gmail.com>
Message-ID: <200908262247.07735.mb@bu3sch.de>

On Wednesday 26 August 2009 21:48:52 G?bor Stefanik wrote:
> From: root G?bor Stefanik <netrolller.3d at gmail.com>
> 
> The most common LP-PHY device, BCM4312, is now fully functional.
> So, no need to say "probably won't work for you" anymore.
> It's also not "for debuggers and developers only", as it is
> perfectly usable for end-users now (at least for BCM4312).

Please also add
default y

> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> This should only be applied once the "Qdiv roundup" and the "Fix and update"
> patches reach the tree, as those 2 patches are needed to make the BCM4312
> really work.
> 
>  drivers/net/wireless/b43/Kconfig |    3 ---
>  1 files changed, 0 insertions(+), 3 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/Kconfig b/drivers/net/wireless/b43/Kconfig
> index 87d10c8..1c0999b 100644
> --- a/drivers/net/wireless/b43/Kconfig
> +++ b/drivers/net/wireless/b43/Kconfig
> @@ -88,9 +88,6 @@ config B43_PHY_LP
>  	  and embedded devices. It supports 802.11a/g
>  	  (802.11a support is optional, and currently disabled).
>  
> -	  This is heavily experimental, and probably will not work for you.
> -	  Say N unless you want to help debug the driver.
> -
>  # This config option automatically enables b43 LEDS support,
>  # if it's possible.
>  config B43_LEDS



-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Wed Aug 26 22:47:12 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Wed, 26 Aug 2009 22:47:12 +0200
Subject: [PATCH] b43: Fix and update LP-PHY code
In-Reply-To: <200908262242.50729.mb@bu3sch.de>
References: <1251312686-32067-1-git-send-email-netrolller.3d@gmail.com> 
	<1251312686-32067-2-git-send-email-netrolller.3d@gmail.com> 
	<200908262242.50729.mb@bu3sch.de>
Message-ID: <69e28c910908261347u375f2f5cu74672b9f4b073738@mail.gmail.com>

2009/8/26 Michael Buesch <mb at bu3sch.de>:
> On Wednesday 26 August 2009 20:51:25 G?bor Stefanik wrote:
>> -Fix a few nasty typos (b43_phy_* operations instead of b43_radio_*)
>> ?in the channel tune routines.
>> -Fix some typos & spec errors found by MMIO tracing.
>> -Optimize b43_phy_write & b43_phy_mask/set/maskset to use
>> ?only the minimal number of MMIO accesses. (Write is possible
>> ?using a single 32-bit MMIO write, while set/mask/maskset can
>> ?be done in 3 16-bit MMIOs).
>
> Why does it matter? PHY access is not done in any hotpath. So why
> not prefer simple code over optimized code?

This is how the MIPS/hybrid driver does it, I simply updated the code
for parity.

>
>> -Set the default channel back to 1, as the bug forcing us to use
>> ?channel 7 is now fixed.
>
> And, everything in its own patch, please. I don't see a reason for
> patching unrelated things in one big patch.

Well, this patch is already in wireless-testing, so doing that would
now involve reverting this patch, applying a version without the
channel change, and applying the channel change - certainly more
confusing than the status quo.

>
>>
>> With this, the device comes up, scans, associates, transmits,
>> receives, monitors and injects on all channels - in other words,
>> it's fully functional. Sensitivity and TX power are still sub-optimal,
>> due to the lack of calibration (that's next on my list).
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> ?drivers/net/wireless/b43/phy_common.c ? | ? 27 +++++++--
>> ?drivers/net/wireless/b43/phy_common.h ? | ? ?3 +
>> ?drivers/net/wireless/b43/phy_lp.c ? ? ? | ? 91 +++++++++++++++++--------------
>> ?drivers/net/wireless/b43/phy_lp.h ? ? ? | ? ?3 +
>> ?drivers/net/wireless/b43/tables_lpphy.c | ? 79 +++++++++++++++------------
>> ?5 files changed, 122 insertions(+), 81 deletions(-)
>>
>> diff --git a/drivers/net/wireless/b43/phy_common.c b/drivers/net/wireless/b43/phy_common.c
>> index 51686ec..6e704be 100644
>> --- a/drivers/net/wireless/b43/phy_common.c
>> +++ b/drivers/net/wireless/b43/phy_common.c
>> @@ -249,20 +249,35 @@ void b43_phy_copy(struct b43_wldev *dev, u16 destreg, u16 srcreg)
>>
>> ?void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
>> ?{
>> - ? ? b43_phy_write(dev, offset,
>> - ? ? ? ? ? ? ? ? ? b43_phy_read(dev, offset) & mask);
>> + ? ? if (dev->phy.ops->phy_maskset) {
>> + ? ? ? ? ? ? assert_mac_suspended(dev);
>> + ? ? ? ? ? ? dev->phy.ops->phy_maskset(dev, offset, mask, 0);
>> + ? ? } else {
>> + ? ? ? ? ? ? b43_phy_write(dev, offset,
>> + ? ? ? ? ? ? ? ? ? ? ? ? ? b43_phy_read(dev, offset) & mask);
>> + ? ? }
>> ?}
>>
>> ?void b43_phy_set(struct b43_wldev *dev, u16 offset, u16 set)
>> ?{
>> - ? ? b43_phy_write(dev, offset,
>> - ? ? ? ? ? ? ? ? ? b43_phy_read(dev, offset) | set);
>> + ? ? if (dev->phy.ops->phy_maskset) {
>> + ? ? ? ? ? ? assert_mac_suspended(dev);
>> + ? ? ? ? ? ? dev->phy.ops->phy_maskset(dev, offset, 0xFFFF, set);
>> + ? ? } else {
>> + ? ? ? ? ? ? b43_phy_write(dev, offset,
>> + ? ? ? ? ? ? ? ? ? ? ? ? ? b43_phy_read(dev, offset) | set);
>> + ? ? }
>> ?}
>>
>> ?void b43_phy_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set)
>> ?{
>> - ? ? b43_phy_write(dev, offset,
>> - ? ? ? ? ? ? ? ? ? (b43_phy_read(dev, offset) & mask) | set);
>> + ? ? if (dev->phy.ops->phy_maskset) {
>> + ? ? ? ? ? ? assert_mac_suspended(dev);
>> + ? ? ? ? ? ? dev->phy.ops->phy_maskset(dev, offset, mask, set);
>> + ? ? } else {
>> + ? ? ? ? ? ? b43_phy_write(dev, offset,
>> + ? ? ? ? ? ? ? ? ? ? ? ? ? (b43_phy_read(dev, offset) & mask) | set);
>> + ? ? }
>> ?}
>>
>> ?int b43_switch_channel(struct b43_wldev *dev, unsigned int new_channel)
>> diff --git a/drivers/net/wireless/b43/phy_common.h b/drivers/net/wireless/b43/phy_common.h
>> index 9f9f23c..b47a0f5 100644
>> --- a/drivers/net/wireless/b43/phy_common.h
>> +++ b/drivers/net/wireless/b43/phy_common.h
>> @@ -95,6 +95,8 @@ enum b43_txpwr_result {
>> ? * ? ? ? ? ? ? ? ? ? Must not be NULL.
>> ? * @phy_write: ? ? ? ? ? ? ? Write to a PHY register.
>> ? * ? ? ? ? ? ? ? ? ? Must not be NULL.
>> + * @phy_maskset: ? ? Maskset a PHY register, taking shortcuts.
>> + * ? ? ? ? ? ? ? ? ? If it is NULL, a generic algorithm is used.
>> ? * @radio_read: ? ? ? ? ? ? ?Read from a Radio register.
>> ? * ? ? ? ? ? ? ? ? ? Must not be NULL.
>> ? * @radio_write: ? ? Write to a Radio register.
>> @@ -154,6 +156,7 @@ struct b43_phy_operations {
>> ? ? ? /* Register access */
>> ? ? ? u16 (*phy_read)(struct b43_wldev *dev, u16 reg);
>> ? ? ? void (*phy_write)(struct b43_wldev *dev, u16 reg, u16 value);
>> + ? ? void (*phy_maskset)(struct b43_wldev *dev, u16 reg, u16 mask, u16 set);
>> ? ? ? u16 (*radio_read)(struct b43_wldev *dev, u16 reg);
>> ? ? ? void (*radio_write)(struct b43_wldev *dev, u16 reg, u16 value);
>>
>> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
>> index 5306f2c..1a57d33 100644
>> --- a/drivers/net/wireless/b43/phy_lp.c
>> +++ b/drivers/net/wireless/b43/phy_lp.c
>> @@ -44,7 +44,7 @@ static inline u16 channel2freq_lp(u8 channel)
>> ?static unsigned int b43_lpphy_op_get_default_chan(struct b43_wldev *dev)
>> ?{
>> ? ? ? if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)
>> - ? ? ? ? ? ? return 7; //FIXME temporary - channel 1 is broken
>> + ? ? ? ? ? ? return 1;
>> ? ? ? return 36;
>> ?}
>>
>> @@ -182,8 +182,8 @@ static void lpphy_adjust_gain_table(struct b43_wldev *dev, u32 freq)
>> ? ? ? temp[1] = temp[0] + 0x1000;
>> ? ? ? temp[2] = temp[0] + 0x2000;
>>
>> - ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0), 3, temp);
>> ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0), 3, temp);
>> + ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0), 3, temp);
>> ?}
>>
>> ?static void lpphy_table_init(struct b43_wldev *dev)
>> @@ -223,8 +223,8 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
>> ? ? ? b43_phy_maskset(dev, B43_LPPHY_VERYLOWGAINDB, 0xFF00, 0x0006);
>> ? ? ? b43_phy_mask(dev, B43_LPPHY_RX_RADIO_CTL, 0xFFFE);
>> ? ? ? b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFFE0, 0x0005);
>> - ? ? b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC10, 0x0180);
>> - ? ? b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x3800);
>> + ? ? b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0xFC1F, 0x0180);
>> + ? ? b43_phy_maskset(dev, B43_LPPHY_CLIPCTRTHRESH, 0x83FF, 0x3C00);
>> ? ? ? b43_phy_maskset(dev, B43_LPPHY_GAINDIRECTMISMATCH, 0xFFF0, 0x0005);
>> ? ? ? b43_phy_maskset(dev, B43_LPPHY_GAIN_MISMATCH_LIMIT, 0xFFC0, 0x001A);
>> ? ? ? b43_phy_maskset(dev, B43_LPPHY_CRS_ED_THRESH, 0xFF00, 0x00B3);
>> @@ -237,7 +237,7 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
>> ? ? ? ? ? ? ? /* TODO:
>> ? ? ? ? ? ? ? ?* Set the LDO voltage to 0x0028 - FIXME: What is this?
>> ? ? ? ? ? ? ? ?* Call sb_pmu_set_ldo_voltage with 4 and the LDO voltage
>> - ? ? ? ? ? ? ?* ? ? ?as arguments
>> + ? ? ? ? ? ? ?* ? ? ?as arguments
>> ? ? ? ? ? ? ? ?* Call sb_pmu_paref_ldo_enable with argument TRUE
>> ? ? ? ? ? ? ? ?*/
>> ? ? ? ? ? ? ? if (dev->phy.rev == 0) {
>> @@ -340,11 +340,11 @@ static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
>> ? ? ? if (dev->phy.rev == 1) {
>> ? ? ? ? ? ? ? tmp = b43_phy_read(dev, B43_LPPHY_CLIPCTRTHRESH);
>> ? ? ? ? ? ? ? tmp2 = (tmp & 0x03E0) >> 5;
>> - ? ? ? ? ? ? tmp2 |= tmp << 5;
>> + ? ? ? ? ? ? tmp2 |= tmp2 << 5;
>> ? ? ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_4C3, tmp2);
>> - ? ? ? ? ? ? tmp = b43_phy_read(dev, B43_LPPHY_OFDMSYNCTHRESH0);
>> + ? ? ? ? ? ? tmp = b43_phy_read(dev, B43_LPPHY_GAINDIRECTMISMATCH);
>> ? ? ? ? ? ? ? tmp2 = (tmp & 0x1F00) >> 8;
>> - ? ? ? ? ? ? tmp2 |= tmp << 5;
>> + ? ? ? ? ? ? tmp2 |= tmp2 << 5;
>> ? ? ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_4C4, tmp2);
>> ? ? ? ? ? ? ? tmp = b43_phy_read(dev, B43_LPPHY_VERYLOWGAINDB);
>> ? ? ? ? ? ? ? tmp2 = tmp & 0x00FF;
>> @@ -761,7 +761,7 @@ static void lpphy_disable_crs(struct b43_wldev *dev, bool user)
>> ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
>> ? ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
>> ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x4);
>> - ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFF7);
>> + ? ? b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFF7);
>> ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
>> ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x10);
>> ? ? ? b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
>> @@ -956,7 +956,7 @@ static void lpphy_run_ddfs(struct b43_wldev *dev, int i_on, int q_on,
>> ? ? ? b43_phy_maskset(dev, B43_LPPHY_AFE_DDFS, 0xFF9F, scale_idx << 5);
>> ? ? ? b43_phy_mask(dev, B43_LPPHY_AFE_DDFS, 0xFFFB);
>> ? ? ? b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x2);
>> - ? ? b43_phy_set(dev, B43_LPPHY_AFE_DDFS, 0x20);
>> + ? ? b43_phy_set(dev, B43_LPPHY_LP_PHY_CTL, 0x20);
>> ?}
>>
>> ?static bool lpphy_rx_iq_est(struct b43_wldev *dev, u16 samples, u8 time,
>> @@ -968,7 +968,7 @@ static bool lpphy_rx_iq_est(struct b43_wldev *dev, u16 samples, u8 time,
>> ? ? ? b43_phy_write(dev, B43_LPPHY_IQ_NUM_SMPLS_ADDR, samples);
>> ? ? ? b43_phy_maskset(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFF00, time);
>> ? ? ? b43_phy_mask(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFEFF);
>> - ? ? b43_phy_set(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0xFDFF);
>> + ? ? b43_phy_set(dev, B43_LPPHY_IQ_ENABLE_WAIT_TIME_ADDR, 0x200);
>>
>> ? ? ? for (i = 0; i < 500; i++) {
>> ? ? ? ? ? ? ? if (!(b43_phy_read(dev,
>> @@ -1135,9 +1135,9 @@ static void lpphy_set_tx_power_control(struct b43_wldev *dev,
>> ? ? ? }
>> ? ? ? if (dev->phy.rev >= 2) {
>> ? ? ? ? ? ? ? if (mode == B43_LPPHY_TXPCTL_HW)
>> - ? ? ? ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_PHY_OFDM(0xD0), 0xFD, 0x2);
>> + ? ? ? ? ? ? ? ? ? ? b43_phy_set(dev, B43_PHY_OFDM(0xD0), 0x2);
>> ? ? ? ? ? ? ? else
>> - ? ? ? ? ? ? ? ? ? ? b43_phy_maskset(dev, B43_PHY_OFDM(0xD0), 0xFD, 0);
>> + ? ? ? ? ? ? ? ? ? ? b43_phy_mask(dev, B43_PHY_OFDM(0xD0), 0xFFFD);
>> ? ? ? }
>> ? ? ? lpphy_write_tx_pctl_mode_to_hardware(dev);
>> ?}
>> @@ -1169,7 +1169,7 @@ static void lpphy_rev0_1_rc_calib(struct b43_wldev *dev)
>> ? ? ? err = b43_lpphy_op_switch_channel(dev, 7);
>> ? ? ? if (err) {
>> ? ? ? ? ? ? ? b43dbg(dev->wl,
>> - ? ? ? ? ? ? ? ? ? ?"RC calib: Failed to switch to channel 7, error = %d",
>> + ? ? ? ? ? ? ? ? ? ?"RC calib: Failed to switch to channel 7, error = %d\n",
>> ? ? ? ? ? ? ? ? ? ? ?err);
>> ? ? ? }
>> ? ? ? old_txg_ovr = !!(b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40);
>> @@ -1500,8 +1500,15 @@ static u16 b43_lpphy_op_read(struct b43_wldev *dev, u16 reg)
>>
>> ?static void b43_lpphy_op_write(struct b43_wldev *dev, u16 reg, u16 value)
>> ?{
>> + ? ? b43_write32(dev, B43_MMIO_PHY_CONTROL, ((u32)value << 16) | reg);
>> +}
>> +
>> +static void b43_lpphy_op_maskset(struct b43_wldev *dev, u16 reg, u16 mask,
>> + ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?u16 set)
>> +{
>> ? ? ? b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
>> - ? ? b43_write16(dev, B43_MMIO_PHY_DATA, value);
>> + ? ? b43_write16(dev, B43_MMIO_PHY_DATA,
>> + ? ? ? ? ? ? ? ? (b43_read16(dev, B43_MMIO_PHY_DATA) & mask) | set);
>> ?}
>>
>> ?static u16 b43_lpphy_op_radio_read(struct b43_wldev *dev, u16 reg)
>> @@ -1920,8 +1927,8 @@ static void lpphy_b2062_reset_pll_bias(struct b43_wldev *dev)
>>
>> ?static void lpphy_b2062_vco_calib(struct b43_wldev *dev)
>> ?{
>> - ? ? b43_phy_write(dev, B2062_S_RFPLL_CTL21, 0x42);
>> - ? ? b43_phy_write(dev, B2062_S_RFPLL_CTL21, 0x62);
>> + ? ? b43_radio_write(dev, B2062_S_RFPLL_CTL21, 0x42);
>> + ? ? b43_radio_write(dev, B2062_S_RFPLL_CTL21, 0x62);
>> ? ? ? udelay(200);
>> ?}
>>
>> @@ -1980,7 +1987,7 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
>> ? ? ? tmp6 = tmp5 / tmp4;
>> ? ? ? tmp7 = tmp5 % tmp4;
>> ? ? ? b43_radio_write(dev, B2062_S_RFPLL_CTL29, tmp6 + ((2 * tmp7) / tmp4));
>> - ? ? tmp8 = b43_phy_read(dev, B2062_S_RFPLL_CTL19);
>> + ? ? tmp8 = b43_radio_read(dev, B2062_S_RFPLL_CTL19);
>> ? ? ? tmp9 = ((2 * tmp3 * (tmp8 + 1)) + (3 * tmp1)) / (6 * tmp1);
>> ? ? ? b43_radio_write(dev, B2062_S_RFPLL_CTL23, (tmp9 >> 8) + 16);
>> ? ? ? b43_radio_write(dev, B2062_S_RFPLL_CTL24, tmp9 & 0xFF);
>> @@ -2019,17 +2026,17 @@ static void lpphy_b2063_vco_calib(struct b43_wldev *dev)
>> ?{
>> ? ? ? u16 tmp;
>>
>> - ? ? b43_phy_mask(dev, B2063_PLL_SP1, ~0x40);
>> - ? ? tmp = b43_phy_read(dev, B2063_PLL_JTAG_CALNRST) & 0xF8;
>> - ? ? b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp);
>> + ? ? b43_radio_mask(dev, B2063_PLL_SP1, ~0x40);
>> + ? ? tmp = b43_radio_read(dev, B2063_PLL_JTAG_CALNRST) & 0xF8;
>> + ? ? b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp);
>> ? ? ? udelay(1);
>> - ? ? b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x4);
>> + ? ? b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x4);
>> ? ? ? udelay(1);
>> - ? ? b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x6);
>> + ? ? b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x6);
>> ? ? ? udelay(1);
>> - ? ? b43_phy_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x7);
>> + ? ? b43_radio_write(dev, B2063_PLL_JTAG_CALNRST, tmp | 0x7);
>> ? ? ? udelay(300);
>> - ? ? b43_phy_set(dev, B2063_PLL_SP1, 0x40);
>> + ? ? b43_radio_set(dev, B2063_PLL_SP1, 0x40);
>> ?}
>>
>> ?static int lpphy_b2063_tune(struct b43_wldev *dev,
>> @@ -2124,31 +2131,31 @@ static int lpphy_b2063_tune(struct b43_wldev *dev,
>> ? ? ? ? ? ? ? scale = 0;
>> ? ? ? ? ? ? ? tmp5 = ((tmp4 + (tmp3 >> 1)) / tmp3) - 8;
>> ? ? ? }
>> - ? ? b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFC0, tmp5);
>> - ? ? b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFBF, scale << 6);
>> + ? ? b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFC0, tmp5);
>> + ? ? b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP2, 0xFFBF, scale << 6);
>>
>> ? ? ? tmp6 = lpphy_qdiv_roundup(100 * val1, val3, 16);
>> ? ? ? tmp6 *= (tmp5 * 8) * (scale + 1);
>> ? ? ? if (tmp6 > 150)
>> ? ? ? ? ? ? ? tmp6 = 0;
>>
>> - ? ? b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFE0, tmp6);
>> - ? ? b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFDF, scale << 5);
>> + ? ? b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFE0, tmp6);
>> + ? ? b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_CP3, 0xFFDF, scale << 5);
>>
>> - ? ? b43_phy_maskset(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFFFB, 0x4);
>> + ? ? b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFFFB, 0x4);
>> ? ? ? if (crystal_freq > 26000000)
>> - ? ? ? ? ? ? b43_phy_set(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0x2);
>> + ? ? ? ? ? ? b43_radio_set(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0x2);
>> ? ? ? else
>> - ? ? ? ? ? ? b43_phy_mask(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFD);
>> + ? ? ? ? ? ? b43_radio_mask(dev, B2063_PLL_JTAG_PLL_XTAL_12, 0xFD);
>>
>> ? ? ? if (val1 == 45)
>> - ? ? ? ? ? ? b43_phy_set(dev, B2063_PLL_JTAG_PLL_VCO1, 0x2);
>> + ? ? ? ? ? ? b43_radio_set(dev, B2063_PLL_JTAG_PLL_VCO1, 0x2);
>> ? ? ? else
>> - ? ? ? ? ? ? b43_phy_mask(dev, B2063_PLL_JTAG_PLL_VCO1, 0xFD);
>> + ? ? ? ? ? ? b43_radio_mask(dev, B2063_PLL_JTAG_PLL_VCO1, 0xFD);
>>
>> - ? ? b43_phy_set(dev, B2063_PLL_SP2, 0x3);
>> + ? ? b43_radio_set(dev, B2063_PLL_SP2, 0x3);
>> ? ? ? udelay(1);
>> - ? ? b43_phy_mask(dev, B2063_PLL_SP2, 0xFFFC);
>> + ? ? b43_radio_mask(dev, B2063_PLL_SP2, 0xFFFC);
>> ? ? ? lpphy_b2063_vco_calib(dev);
>> ? ? ? b43_radio_write(dev, B2063_COMM15, old_comm15);
>>
>> @@ -2158,10 +2165,9 @@ static int lpphy_b2063_tune(struct b43_wldev *dev,
>> ?static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
>> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?unsigned int new_channel)
>> ?{
>> + ? ? struct b43_phy_lp *lpphy = dev->phy.lp;
>> ? ? ? int err;
>>
>> - ? ? b43_write16(dev, B43_MMIO_CHANNEL, new_channel);
>> -
>> ? ? ? if (dev->phy.radio_ver == 0x2063) {
>> ? ? ? ? ? ? ? err = lpphy_b2063_tune(dev, new_channel);
>> ? ? ? ? ? ? ? if (err)
>> @@ -2174,6 +2180,9 @@ static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
>> ? ? ? ? ? ? ? lpphy_adjust_gain_table(dev, channel2freq_lp(new_channel));
>> ? ? ? }
>>
>> + ? ? lpphy->channel = new_channel;
>> + ? ? b43_write16(dev, B43_MMIO_CHANNEL, new_channel);
>> +
>> ? ? ? return 0;
>> ?}
>>
>> @@ -2185,10 +2194,9 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
>> ? ? ? lpphy_baseband_init(dev);
>> ? ? ? lpphy_radio_init(dev);
>> ? ? ? lpphy_calibrate_rc(dev);
>> - ? ? err = b43_lpphy_op_switch_channel(dev,
>> - ? ? ? ? ? ? ? ? ? ? ? ? ? ? b43_lpphy_op_get_default_chan(dev));
>> + ? ? err = b43_lpphy_op_switch_channel(dev, 7);
>> ? ? ? if (err) {
>> - ? ? ? ? ? ? b43dbg(dev->wl, "Switch to init channel failed, error = %d.\n",
>> + ? ? ? ? ? ? b43dbg(dev->wl, "Switch to channel 7 failed, error = %d.\n",
>> ? ? ? ? ? ? ? ? ? ? ?err);
>> ? ? ? }
>> ? ? ? lpphy_tx_pctl_init(dev);
>> @@ -2222,6 +2230,7 @@ const struct b43_phy_operations b43_phyops_lp = {
>> ? ? ? .init ? ? ? ? ? ? ? ? ? = b43_lpphy_op_init,
>> ? ? ? .phy_read ? ? ? ? ? ? ? = b43_lpphy_op_read,
>> ? ? ? .phy_write ? ? ? ? ? ? ?= b43_lpphy_op_write,
>> + ? ? .phy_maskset ? ? ? ? ? ?= b43_lpphy_op_maskset,
>> ? ? ? .radio_read ? ? ? ? ? ? = b43_lpphy_op_radio_read,
>> ? ? ? .radio_write ? ? ? ? ? ?= b43_lpphy_op_radio_write,
>> ? ? ? .software_rfkill ? ? ? ?= b43_lpphy_op_software_rfkill,
>> diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
>> index e158d1f..c3232c1 100644
>> --- a/drivers/net/wireless/b43/phy_lp.h
>> +++ b/drivers/net/wireless/b43/phy_lp.h
>> @@ -888,6 +888,9 @@ struct b43_phy_lp {
>> ? ? ? bool crs_usr_disable, crs_sys_disable;
>>
>> ? ? ? unsigned int pdiv;
>> +
>> + ? ? /* The channel we are tuned to */
>> + ? ? u8 channel;
>> ?};
>>
>> ?enum tssi_mux_mode {
>> diff --git a/drivers/net/wireless/b43/tables_lpphy.c b/drivers/net/wireless/b43/tables_lpphy.c
>> index 60d472f..c784def 100644
>> --- a/drivers/net/wireless/b43/tables_lpphy.c
>> +++ b/drivers/net/wireless/b43/tables_lpphy.c
>> @@ -624,30 +624,35 @@ u32 b43_lptab_read(struct b43_wldev *dev, u32 offset)
>> ?void b43_lptab_read_bulk(struct b43_wldev *dev, u32 offset,
>> ? ? ? ? ? ? ? ? ? ? ? ?unsigned int nr_elements, void *_data)
>> ?{
>> - ? ? u32 type, value;
>> + ? ? u32 type;
>> ? ? ? u8 *data = _data;
>> ? ? ? unsigned int i;
>>
>> ? ? ? type = offset & B43_LPTAB_TYPEMASK;
>> + ? ? offset &= ~B43_LPTAB_TYPEMASK;
>> + ? ? B43_WARN_ON(offset > 0xFFFF);
>> +
>> + ? ? b43_phy_write(dev, B43_LPPHY_TABLE_ADDR, offset);
>> +
>> ? ? ? for (i = 0; i < nr_elements; i++) {
>> - ? ? ? ? ? ? value = b43_lptab_read(dev, offset);
>> ? ? ? ? ? ? ? switch (type) {
>> ? ? ? ? ? ? ? case B43_LPTAB_8BIT:
>> - ? ? ? ? ? ? ? ? ? ? *data = value;
>> + ? ? ? ? ? ? ? ? ? ? *data = b43_phy_read(dev, B43_LPPHY_TABLEDATALO) & 0xFF;
>> ? ? ? ? ? ? ? ? ? ? ? data++;
>> ? ? ? ? ? ? ? ? ? ? ? break;
>> ? ? ? ? ? ? ? case B43_LPTAB_16BIT:
>> - ? ? ? ? ? ? ? ? ? ? *((u16 *)data) = value;
>> + ? ? ? ? ? ? ? ? ? ? *((u16 *)data) = b43_phy_read(dev, B43_LPPHY_TABLEDATALO);
>> ? ? ? ? ? ? ? ? ? ? ? data += 2;
>> ? ? ? ? ? ? ? ? ? ? ? break;
>> ? ? ? ? ? ? ? case B43_LPTAB_32BIT:
>> - ? ? ? ? ? ? ? ? ? ? *((u32 *)data) = value;
>> + ? ? ? ? ? ? ? ? ? ? *((u32 *)data) = b43_phy_read(dev, B43_LPPHY_TABLEDATAHI);
>> + ? ? ? ? ? ? ? ? ? ? *((u32 *)data) <<= 16;
>> + ? ? ? ? ? ? ? ? ? ? *((u32 *)data) |= b43_phy_read(dev, B43_LPPHY_TABLEDATALO);
>> ? ? ? ? ? ? ? ? ? ? ? data += 4;
>> ? ? ? ? ? ? ? ? ? ? ? break;
>> ? ? ? ? ? ? ? default:
>> ? ? ? ? ? ? ? ? ? ? ? B43_WARN_ON(1);
>> ? ? ? ? ? ? ? }
>> - ? ? ? ? ? ? offset++;
>> ? ? ? }
>> ?}
>>
>> @@ -688,26 +693,34 @@ void b43_lptab_write_bulk(struct b43_wldev *dev, u32 offset,
>> ? ? ? unsigned int i;
>>
>> ? ? ? type = offset & B43_LPTAB_TYPEMASK;
>> + ? ? offset &= ~B43_LPTAB_TYPEMASK;
>> + ? ? B43_WARN_ON(offset > 0xFFFF);
>> +
>> + ? ? b43_phy_write(dev, B43_LPPHY_TABLE_ADDR, offset);
>> +
>> ? ? ? for (i = 0; i < nr_elements; i++) {
>> ? ? ? ? ? ? ? switch (type) {
>> ? ? ? ? ? ? ? case B43_LPTAB_8BIT:
>> ? ? ? ? ? ? ? ? ? ? ? value = *data;
>> ? ? ? ? ? ? ? ? ? ? ? data++;
>> + ? ? ? ? ? ? ? ? ? ? B43_WARN_ON(value & ~0xFF);
>> + ? ? ? ? ? ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_TABLEDATALO, value);
>> ? ? ? ? ? ? ? ? ? ? ? break;
>> ? ? ? ? ? ? ? case B43_LPTAB_16BIT:
>> ? ? ? ? ? ? ? ? ? ? ? value = *((u16 *)data);
>> ? ? ? ? ? ? ? ? ? ? ? data += 2;
>> + ? ? ? ? ? ? ? ? ? ? B43_WARN_ON(value & ~0xFFFF);
>> + ? ? ? ? ? ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_TABLEDATALO, value);
>> ? ? ? ? ? ? ? ? ? ? ? break;
>> ? ? ? ? ? ? ? case B43_LPTAB_32BIT:
>> ? ? ? ? ? ? ? ? ? ? ? value = *((u32 *)data);
>> ? ? ? ? ? ? ? ? ? ? ? data += 4;
>> + ? ? ? ? ? ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_TABLEDATAHI, value >> 16);
>> + ? ? ? ? ? ? ? ? ? ? b43_phy_write(dev, B43_LPPHY_TABLEDATALO, value);
>> ? ? ? ? ? ? ? ? ? ? ? break;
>> ? ? ? ? ? ? ? default:
>> ? ? ? ? ? ? ? ? ? ? ? B43_WARN_ON(1);
>> - ? ? ? ? ? ? ? ? ? ? value = 0;
>> ? ? ? ? ? ? ? }
>> - ? ? ? ? ? ? b43_lptab_write(dev, offset, value);
>> - ? ? ? ? ? ? offset++;
>> ? ? ? }
>> ?}
>>
>> @@ -777,7 +790,7 @@ static const u8 lpphy_pll_fraction_table[] = {
>> ? ? ? 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
>> ?};
>>
>> -static const u16 lpphy_iq_local_table[] = {
>> +static const u16 lpphy_iqlo_cal_table[] = {
>> ? ? ? 0x0200, 0x0300, 0x0400, 0x0600, 0x0800, 0x0b00, 0x1000, 0x1001, 0x1002,
>> ? ? ? 0x1003, 0x1004, 0x1005, 0x1006, 0x1007, 0x1707, 0x2007, 0x2d07, 0x4007,
>> ? ? ? 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
>> @@ -789,10 +802,17 @@ static const u16 lpphy_iq_local_table[] = {
>> ? ? ? 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
>> ? ? ? 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4000, 0x0000, 0x0000,
>> ? ? ? 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
>> - ? ? 0x0000, 0x0000,
>> + ? ? 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
>> ?};
>>
>> -static const u16 lpphy_ofdm_cck_gain_table[] = {
>> +static const u16 lpphy_rev0_ofdm_cck_gain_table[] = {
>> + ? ? 0x0001, 0x0001, 0x0001, 0x0001, 0x1001, 0x2001, 0x3001, 0x4001, 0x5001,
>> + ? ? 0x6001, 0x7001, 0x7011, 0x7021, 0x2035, 0x2045, 0x2055, 0x2065, 0x2075,
>> + ? ? 0x006d, 0x007d, 0x014d, 0x015d, 0x115d, 0x035d, 0x135d, 0x055d, 0x155d,
>> + ? ? 0x0d5d, 0x1d5d, 0x2d5d, 0x555d, 0x655d, 0x755d,
>> +};
>> +
>> +static const u16 lpphy_rev1_ofdm_cck_gain_table[] = {
>> ? ? ? 0x5000, 0x6000, 0x7000, 0x0001, 0x1001, 0x2001, 0x3001, 0x4001, 0x5001,
>> ? ? ? 0x6001, 0x7001, 0x7011, 0x7021, 0x2035, 0x2045, 0x2055, 0x2065, 0x2075,
>> ? ? ? 0x006d, 0x007d, 0x014d, 0x015d, 0x115d, 0x035d, 0x135d, 0x055d, 0x155d,
>> @@ -2263,11 +2283,18 @@ void lpphy_rev0_1_table_init(struct b43_wldev *dev)
>> ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB8(6, 0),
>> ? ? ? ? ? ? ? ARRAY_SIZE(lpphy_pll_fraction_table), lpphy_pll_fraction_table);
>> ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(0, 0),
>> - ? ? ? ? ? ? ARRAY_SIZE(lpphy_iq_local_table), lpphy_iq_local_table);
>> - ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0),
>> - ? ? ? ? ? ? ARRAY_SIZE(lpphy_ofdm_cck_gain_table), lpphy_ofdm_cck_gain_table);
>> - ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0),
>> - ? ? ? ? ? ? ARRAY_SIZE(lpphy_ofdm_cck_gain_table), lpphy_ofdm_cck_gain_table);
>> + ? ? ? ? ? ? ARRAY_SIZE(lpphy_iqlo_cal_table), lpphy_iqlo_cal_table);
>> + ? ? if (dev->phy.rev == 0) {
>> + ? ? ? ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0),
>> + ? ? ? ? ? ? ? ? ? ? ARRAY_SIZE(lpphy_rev0_ofdm_cck_gain_table), lpphy_rev0_ofdm_cck_gain_table);
>> + ? ? ? ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0),
>> + ? ? ? ? ? ? ? ? ? ? ARRAY_SIZE(lpphy_rev0_ofdm_cck_gain_table), lpphy_rev0_ofdm_cck_gain_table);
>> + ? ? } else {
>> + ? ? ? ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(13, 0),
>> + ? ? ? ? ? ? ? ? ? ? ARRAY_SIZE(lpphy_rev1_ofdm_cck_gain_table), lpphy_rev1_ofdm_cck_gain_table);
>> + ? ? ? ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(12, 0),
>> + ? ? ? ? ? ? ? ? ? ? ARRAY_SIZE(lpphy_rev1_ofdm_cck_gain_table), lpphy_rev1_ofdm_cck_gain_table);
>> +}
>> ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(15, 0),
>> ? ? ? ? ? ? ? ARRAY_SIZE(lpphy_gain_delta_table), lpphy_gain_delta_table);
>> ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0),
>> @@ -2281,22 +2308,6 @@ void lpphy_rev2plus_table_init(struct b43_wldev *dev)
>>
>> ? ? ? B43_WARN_ON(dev->phy.rev < 2);
>>
>> - ? ? /*
>> - ? ? ?* FIXME This code follows the specs, but it looks wrong:
>> - ? ? ?* In each pass, it writes 4 bytes to an offset in table ID 7,
>> - ? ? ?* then increments the offset by 1 for the next pass. This results
>> - ? ? ?* in the first 3 bytes of each pass except the first one getting
>> - ? ? ?* written to a location that has already been zeroed in the previous
>> - ? ? ?* pass.
>> - ? ? ?* This is what the vendor driver does, but it still looks suspicious.
>> - ? ? ?*
>> - ? ? ?* This should probably suffice:
>> - ? ? ?*
>> - ? ? ?* for (i = 0; i < 704; i+=4)
>> - ? ? ?* ? ? ?b43_lptab_write(dev, B43_LPTAB32(7, i), 0)
>> - ? ? ?*
>> - ? ? ?* This should be tested once the code is functional.
>> - ? ? ?*/
>> ? ? ? for (i = 0; i < 704; i++)
>> ? ? ? ? ? ? ? b43_lptab_write(dev, B43_LPTAB32(7, i), 0);
>>
>> @@ -2323,7 +2334,7 @@ void lpphy_rev2plus_table_init(struct b43_wldev *dev)
>> ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB8(6, 0),
>> ? ? ? ? ? ? ? ARRAY_SIZE(lpphy_pll_fraction_table), lpphy_pll_fraction_table);
>> ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB16(0, 0),
>> - ? ? ? ? ? ? ARRAY_SIZE(lpphy_iq_local_table), lpphy_iq_local_table);
>> + ? ? ? ? ? ? ARRAY_SIZE(lpphy_iqlo_cal_table), lpphy_iqlo_cal_table);
>> ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB32(9, 0),
>> ? ? ? ? ? ? ? ARRAY_SIZE(lpphy_papd_eps_table), lpphy_papd_eps_table);
>> ? ? ? b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0),
>
>
>
> --
> Greetings, Michael.
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Wed Aug 26 22:49:50 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 26 Aug 2009 22:49:50 +0200
Subject: [PATCH] b43: Fix and update LP-PHY code
In-Reply-To: <69e28c910908261347u375f2f5cu74672b9f4b073738@mail.gmail.com>
References: <1251312686-32067-1-git-send-email-netrolller.3d@gmail.com>
	<200908262242.50729.mb@bu3sch.de>
	<69e28c910908261347u375f2f5cu74672b9f4b073738@mail.gmail.com>
Message-ID: <200908262249.52408.mb@bu3sch.de>

On Wednesday 26 August 2009 22:47:12 G?bor Stefanik wrote:
> 2009/8/26 Michael Buesch <mb at bu3sch.de>:
> > On Wednesday 26 August 2009 20:51:25 G?bor Stefanik wrote:
> >> -Fix a few nasty typos (b43_phy_* operations instead of b43_radio_*)
> >> ?in the channel tune routines.
> >> -Fix some typos & spec errors found by MMIO tracing.
> >> -Optimize b43_phy_write & b43_phy_mask/set/maskset to use
> >> ?only the minimal number of MMIO accesses. (Write is possible
> >> ?using a single 32-bit MMIO write, while set/mask/maskset can
> >> ?be done in 3 16-bit MMIOs).
> >
> > Why does it matter? PHY access is not done in any hotpath. So why
> > not prefer simple code over optimized code?
> 
> This is how the MIPS/hybrid driver does it, I simply updated the code
> for parity.

I think _if_ we do it (I'm not sure if it's worth it), we should certainly
do it in a completely separate patch.

> 
> >
> >> -Set the default channel back to 1, as the bug forcing us to use
> >> ?channel 7 is now fixed.
> >
> > And, everything in its own patch, please. I don't see a reason for
> > patching unrelated things in one big patch.
> 
> Well, this patch is already in wireless-testing, so doing that would

When did I ack it?
Note that I _do_ have a life and I was not able to check mail for the past 9 hours.
So please give me an ack latency of one day, at least.

-- 
Greetings, Michael.


From linville at tuxdriver.com  Wed Aug 26 22:54:03 2009
From: linville at tuxdriver.com (John W. Linville)
Date: Wed, 26 Aug 2009 16:54:03 -0400
Subject: [PATCH] b43: Fix and update LP-PHY code
In-Reply-To: <69e28c910908261347u375f2f5cu74672b9f4b073738@mail.gmail.com>
References: <1251312686-32067-1-git-send-email-netrolller.3d@gmail.com>
	<1251312686-32067-2-git-send-email-netrolller.3d@gmail.com>
	<200908262242.50729.mb@bu3sch.de>
	<69e28c910908261347u375f2f5cu74672b9f4b073738@mail.gmail.com>
Message-ID: <20090826205403.GA30119@tuxdriver.com>

On Wed, Aug 26, 2009 at 10:47:12PM +0200, G?bor Stefanik wrote:
> 2009/8/26 Michael Buesch <mb at bu3sch.de>:
> > And, everything in its own patch, please. I don't see a reason for
> > patching unrelated things in one big patch.
> 
> Well, this patch is already in wireless-testing, so doing that would
> now involve reverting this patch, applying a version without the
> channel change, and applying the channel change - certainly more
> confusing than the status quo.

But it is not in net-next-2.6.  Please submit the patches as Michael
requested and I'll take care of the reorganization.

John
-- 
John W. Linville		Someday the world will need a hero, and you
linville at tuxdriver.com			might be all we have.  Be ready.


From mb at bu3sch.de  Wed Aug 26 23:03:33 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 26 Aug 2009 23:03:33 +0200
Subject: [PATCH] b43: Fix and update LP-PHY code
In-Reply-To: <20090826205403.GA30119@tuxdriver.com>
References: <1251312686-32067-1-git-send-email-netrolller.3d@gmail.com>
	<69e28c910908261347u375f2f5cu74672b9f4b073738@mail.gmail.com>
	<20090826205403.GA30119@tuxdriver.com>
Message-ID: <200908262303.34779.mb@bu3sch.de>

On Wednesday 26 August 2009 22:54:03 John W. Linville wrote:
> On Wed, Aug 26, 2009 at 10:47:12PM +0200, G?bor Stefanik wrote:
> > 2009/8/26 Michael Buesch <mb at bu3sch.de>:
> > > And, everything in its own patch, please. I don't see a reason for
> > > patching unrelated things in one big patch.
> > 
> > Well, this patch is already in wireless-testing, so doing that would
> > now involve reverting this patch, applying a version without the
> > channel change, and applying the channel change - certainly more
> > confusing than the status quo.
> 
> But it is not in net-next-2.6.  Please submit the patches as Michael
> requested and I'll take care of the reorganization.

You can leave it as-is. But for the future please make sure to submit
independent things in independent patches so they can be discussed
and merged independently.

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Wed Aug 26 23:38:48 2009
From: netrolller.3d at gmail.com (=?utf-8?q?G=C3=A1bor=20Stefanik?=)
Date: Wed, 26 Aug 2009 23:38:48 +0200
Subject: [PATCH] b43: LP-PHY: Revert to the original PHY register write routine
Message-ID: <1251322728-7034-1-git-send-email-netrolller.3d@gmail.com>

From: root <root at NR3DMain.NR3D>

After some discussion on IRC about the PHY register write change,
I am not sure anymore if this is the right thing to do.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/phy_lp.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 80f245c..a57c40d 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1496,7 +1496,8 @@ static u16 b43_lpphy_op_read(struct b43_wldev *dev, u16 reg)
 
 static void b43_lpphy_op_write(struct b43_wldev *dev, u16 reg, u16 value)
 {
-	b43_write32(dev, B43_MMIO_PHY_CONTROL, ((u32)value << 16) | reg);
+	b43_write32(dev, B43_MMIO_PHY_CONTROL, reg);
+	b43_write32(dev, B43_MMIO_PHY_DATA, value);
 }
 
 static void b43_lpphy_op_maskset(struct b43_wldev *dev, u16 reg, u16 mask,
-- 
1.5.6



From netrolller.3d at gmail.com  Wed Aug 26 23:42:18 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Wed, 26 Aug 2009 23:42:18 +0200
Subject: [PATCH] b43: LP-PHY: Revert to the original PHY register write 
	routine
In-Reply-To: <1251322728-7034-1-git-send-email-netrolller.3d@gmail.com>
References: <1251322728-7034-1-git-send-email-netrolller.3d@gmail.com>
Message-ID: <69e28c910908261442v655769a8v5bcca3111642d73@mail.gmail.com>

2009/8/26 G?bor Stefanik <netrolller.3d at gmail.com>:
> From: root <root at NR3DMain.NR3D>

The joys of an accidental "sudo git format-patch"... :-)

>
> After some discussion on IRC about the PHY register write change,
> I am not sure anymore if this is the right thing to do.
>
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> ?drivers/net/wireless/b43/phy_lp.c | ? ?3 ++-
> ?1 files changed, 2 insertions(+), 1 deletions(-)
>
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index 80f245c..a57c40d 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -1496,7 +1496,8 @@ static u16 b43_lpphy_op_read(struct b43_wldev *dev, u16 reg)
>
> ?static void b43_lpphy_op_write(struct b43_wldev *dev, u16 reg, u16 value)
> ?{
> - ? ? ? b43_write32(dev, B43_MMIO_PHY_CONTROL, ((u32)value << 16) | reg);
> + ? ? ? b43_write32(dev, B43_MMIO_PHY_CONTROL, reg);
> + ? ? ? b43_write32(dev, B43_MMIO_PHY_DATA, value);
> ?}
>
> ?static void b43_lpphy_op_maskset(struct b43_wldev *dev, u16 reg, u16 mask,
> --
> 1.5.6
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Wed Aug 26 23:44:34 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 26 Aug 2009 23:44:34 +0200
Subject: [PATCH] b43: LP-PHY: Revert to the original PHY register write
	routine
In-Reply-To: <1251322728-7034-1-git-send-email-netrolller.3d@gmail.com>
References: <1251322728-7034-1-git-send-email-netrolller.3d@gmail.com>
Message-ID: <200908262344.36295.mb@bu3sch.de>

On Wednesday 26 August 2009 23:38:48 G?bor Stefanik wrote:
> From: root <root at NR3DMain.NR3D>
> 
> After some discussion on IRC about the PHY register write change,
> I am not sure anymore if this is the right thing to do.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
>  drivers/net/wireless/b43/phy_lp.c |    3 ++-
>  1 files changed, 2 insertions(+), 1 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index 80f245c..a57c40d 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -1496,7 +1496,8 @@ static u16 b43_lpphy_op_read(struct b43_wldev *dev, u16 reg)
>  
>  static void b43_lpphy_op_write(struct b43_wldev *dev, u16 reg, u16 value)
>  {
> -	b43_write32(dev, B43_MMIO_PHY_CONTROL, ((u32)value << 16) | reg);
> +	b43_write32(dev, B43_MMIO_PHY_CONTROL, reg);
> +	b43_write32(dev, B43_MMIO_PHY_DATA, value);

You just introduced a bug (need 16bit write).
As I said. I'm OK with it, if it works. Just submit it as separate patch in the future.

>  }
>  
>  static void b43_lpphy_op_maskset(struct b43_wldev *dev, u16 reg, u16 mask,



-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Wed Aug 26 23:45:10 2009
From: netrolller.3d at gmail.com (=?utf-8?q?G=C3=A1bor=20Stefanik?=)
Date: Wed, 26 Aug 2009 23:45:10 +0200
Subject: [PATCH v2] b43: LP-PHY: Revert to the original PHY register write
	routine
Message-ID: <1251323110-7151-1-git-send-email-netrolller.3d@gmail.com>

After some discussion on IRC about the PHY register write change,
I am not sure anymore if this is the right thing to do.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
v2: No more "From: root".

 drivers/net/wireless/b43/phy_lp.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 80f245c..a57c40d 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1496,7 +1496,8 @@ static u16 b43_lpphy_op_read(struct b43_wldev *dev, u16 reg)
 
 static void b43_lpphy_op_write(struct b43_wldev *dev, u16 reg, u16 value)
 {
-	b43_write32(dev, B43_MMIO_PHY_CONTROL, ((u32)value << 16) | reg);
+	b43_write32(dev, B43_MMIO_PHY_CONTROL, reg);
+	b43_write32(dev, B43_MMIO_PHY_DATA, value);
 }
 
 static void b43_lpphy_op_maskset(struct b43_wldev *dev, u16 reg, u16 mask,
-- 
1.5.6



From netrolller.3d at gmail.com  Wed Aug 26 23:46:18 2009
From: netrolller.3d at gmail.com (=?utf-8?q?G=C3=A1bor=20Stefanik?=)
Date: Wed, 26 Aug 2009 23:46:18 +0200
Subject: [PATCH v3] b43: LP-PHY: Revert to the original PHY register write
	routine
Message-ID: <1251323178-7173-1-git-send-email-netrolller.3d@gmail.com>

After some discussion on IRC about the PHY register write change,
I am not sure anymore if this is the right thing to do.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
v3: Use 16-bit writes.

 drivers/net/wireless/b43/phy_lp.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 80f245c..a57c40d 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1496,7 +1496,8 @@ static u16 b43_lpphy_op_read(struct b43_wldev *dev, u16 reg)
 
 static void b43_lpphy_op_write(struct b43_wldev *dev, u16 reg, u16 value)
 {
-	b43_write32(dev, B43_MMIO_PHY_CONTROL, ((u32)value << 16) | reg);
+	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
+	b43_write16(dev, B43_MMIO_PHY_DATA, value);
 }
 
 static void b43_lpphy_op_maskset(struct b43_wldev *dev, u16 reg, u16 mask,
-- 
1.5.6



From Larry.Finger at lwfinger.net  Thu Aug 27 02:26:16 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 26 Aug 2009 19:26:16 -0500
Subject: Congratulations
In-Reply-To: <1251323178-7173-1-git-send-email-netrolller.3d@gmail.com>
References: <1251323178-7173-1-git-send-email-netrolller.3d@gmail.com>
Message-ID: <4A95D2A8.9090208@lwfinger.net>

G?bor,

Congratulations on your progress. With today's patches my BCM4312
802.11b/g card with PCI ID 14e4:4315 works - I'm using it at the
moment. I'm using WPA2 encryption and have connected to APs on
channels 1 and 11. My logs are clean.

As you noted, performance is a little weak, but I get transmits of
9-11 Mb/s and receive rates up to 18 Mb/s - eminently usable.

I certainly hope that you get the patches approved so that these
changes will be in the 2.6.32 kernel.

Once again, congratulations to you, Michael, and the others members of
the reverse engineering team. Seeing the device comes to life makes
all those hours of staring at MIPS binary code seem very worthwhile.

For those of you with N PHYs, the RE of those devices will be my next
step.

Larry


From netrolller.3d at gmail.com  Thu Aug 27 04:22:08 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Thu, 27 Aug 2009 04:22:08 +0200
Subject: Congratulations
In-Reply-To: <4A95D2A8.9090208@lwfinger.net>
References: <1251323178-7173-1-git-send-email-netrolller.3d@gmail.com> 
	<4A95D2A8.9090208@lwfinger.net>
Message-ID: <69e28c910908261922p5ee551aeobd535fc2ceb2a814@mail.gmail.com>

2009/8/27 Larry Finger <Larry.Finger at lwfinger.net>:
> G?bor,
>
> Congratulations on your progress. With today's patches my BCM4312
> 802.11b/g card with PCI ID 14e4:4315 works - I'm using it at the
> moment. I'm using WPA2 encryption and have connected to APs on
> channels 1 and 11. My logs are clean.

That's good to hear!

>
> As you noted, performance is a little weak, but I get transmits of
> 9-11 Mb/s and receive rates up to 18 Mb/s - eminently usable.

What is your actual RX throughput? For me, it's usable up to 24Mb/s,
but the actual throughput is limited to 1.2Mb/s.

>
> I certainly hope that you get the patches approved so that these
> changes will be in the 2.6.32 kernel.

The patches are already in the tree, actually.

>
> Once again, congratulations to you, Michael, and the others members of
> the reverse engineering team. Seeing the device comes to life makes
> all those hours of staring at MIPS binary code seem very worthwhile.
>
> For those of you with N PHYs, the RE of those devices will be my next
> step.

My next step will be calibration. :-)

(However, calibration specs are still not complete - there are 2 wlc_*
calls in PR41573. But that only matters for rev.0, and apparently all
4312s are rev.1.)

>
> Larry
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From Larry.Finger at lwfinger.net  Thu Aug 27 04:55:49 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 26 Aug 2009 21:55:49 -0500
Subject: Congratulations
In-Reply-To: <69e28c910908261922p5ee551aeobd535fc2ceb2a814@mail.gmail.com>
References: <1251323178-7173-1-git-send-email-netrolller.3d@gmail.com>
	<4A95D2A8.9090208@lwfinger.net>
	<69e28c910908261922p5ee551aeobd535fc2ceb2a814@mail.gmail.com>
Message-ID: <4A95F5B5.2020007@lwfinger.net>

G?bor Stefanik wrote:
> 2009/8/27 Larry Finger <Larry.Finger at lwfinger.net>:
>> G?bor,
>>
>> Congratulations on your progress. With today's patches my BCM4312
>> 802.11b/g card with PCI ID 14e4:4315 works - I'm using it at the
>> moment. I'm using WPA2 encryption and have connected to APs on
>> channels 1 and 11. My logs are clean.
> 
> That's good to hear!
> 
>> As you noted, performance is a little weak, but I get transmits of
>> 9-11 Mb/s and receive rates up to 18 Mb/s - eminently usable.
> 
> What is your actual RX throughput? For me, it's usable up to 24Mb/s,
> but the actual throughput is limited to 1.2Mb/s.

That 18 Mb/s receive rate was observed data transfer from my server
that is wired to the router/AP and over the air to the BCM4312, just
as the 11 Mb/s was observed transfer from the BCM4312 to the server. I
have no idea what bit rate was set into the interface. Every time I
looked, it was at 1 Mb/s, but the throughput is better than that.

--snip--

>> For those of you with N PHYs, the RE of those devices will be my next
>> step.
> 
> My next step will be calibration. :-)
> 
> (However, calibration specs are still not complete - there are 2 wlc_*
> calls in PR41573. But that only matters for rev.0, and apparently all
> 4312s are rev.1.)

I missed those (obviously). Are there any other places in the LP PHY
that need work?

Larry



From netrolller.3d at gmail.com  Thu Aug 27 16:17:22 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 27 Aug 2009 16:17:22 +0200
Subject: [PATCH] b43: Enable LP-PHY support by default and remove Kconfig
	warning
Message-ID: <4A969572.7060807@gmail.com>

The most common LP-PHY device, BCM4312, is now fully functional.
So, no need to say "probably won't work for you" anymore.
It's also not "for debuggers and developers only", as it is
perfectly usable for end-users now (at least for BCM4312).

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
This replaces the "remove scary message" patch.

 drivers/net/wireless/b43/Kconfig |    4 +---
 1 files changed, 1 insertions(+), 3 deletions(-)

diff --git a/drivers/net/wireless/b43/Kconfig b/drivers/net/wireless/b43/Kconfig
index 237b1aa..2af3b35 100644
--- a/drivers/net/wireless/b43/Kconfig
+++ b/drivers/net/wireless/b43/Kconfig
 -82,15 +82,13 @@ config B43_NPHY
 config B43_PHY_LP
 	bool "Support for low-power (LP-PHY) devices (EXPERIMENTAL)"
 	depends on B43 && EXPERIMENTAL
+	default y
 	---help---
 	  Support for the LP-PHY.
 	  The LP-PHY is a low-power PHY built into some notebooks
 	  and embedded devices. It supports 802.11a/g
 	  (802.11a support is optional, and currently disabled).
 
-	  This is heavily experimental, and probably will not work for you.
-	  Say N unless you want to help debug the driver.
-
 # This config option automatically enables b43 LEDS support,
 # if it's possible.
 config B43_LEDS
-- 
1.6.2.4



From Larry.Finger at lwfinger.net  Thu Aug 27 17:11:53 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 27 Aug 2009 10:11:53 -0500
Subject: [PATCH] b43: Enable LP-PHY support by default and remove Kconfig
	warning
In-Reply-To: <4A969572.7060807@gmail.com>
References: <4A969572.7060807@gmail.com>
Message-ID: <4A96A239.9000406@lwfinger.net>

G?bor Stefanik wrote:
> The most common LP-PHY device, BCM4312, is now fully functional.
> So, no need to say "probably won't work for you" anymore.
> It's also not "for debuggers and developers only", as it is
> perfectly usable for end-users now (at least for BCM4312).
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> This replaces the "remove scary message" patch.
> 
> drivers/net/wireless/b43/Kconfig |    4 +---
> 1 files changed, 1 insertions(+), 3 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/Kconfig
> b/drivers/net/wireless/b43/Kconfig
> index 237b1aa..2af3b35 100644
> --- a/drivers/net/wireless/b43/Kconfig
> +++ b/drivers/net/wireless/b43/Kconfig
> -82,15 +82,13 @@ config B43_NPHY
===

My copy of this patch is missing the @@ here. Is that true for everyone?

Larry


From netrolller.3d at gmail.com  Thu Aug 27 17:19:48 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Thu, 27 Aug 2009 17:19:48 +0200
Subject: [PATCH] b43: Enable LP-PHY support by default and remove Kconfig 
	warning
In-Reply-To: <4A96A239.9000406@lwfinger.net>
References: <4A969572.7060807@gmail.com> <4A96A239.9000406@lwfinger.net>
Message-ID: <69e28c910908270819n65745ad3x7346ccb8c4850db9@mail.gmail.com>

2009/8/27 Larry Finger <Larry.Finger at lwfinger.net>:
> G?bor Stefanik wrote:
>> The most common LP-PHY device, BCM4312, is now fully functional.
>> So, no need to say "probably won't work for you" anymore.
>> It's also not "for debuggers and developers only", as it is
>> perfectly usable for end-users now (at least for BCM4312).
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> This replaces the "remove scary message" patch.
>>
>> drivers/net/wireless/b43/Kconfig | ? ?4 +---
>> 1 files changed, 1 insertions(+), 3 deletions(-)
>>
>> diff --git a/drivers/net/wireless/b43/Kconfig
>> b/drivers/net/wireless/b43/Kconfig
>> index 237b1aa..2af3b35 100644
>> --- a/drivers/net/wireless/b43/Kconfig
>> +++ b/drivers/net/wireless/b43/Kconfig
>> -82,15 +82,13 @@ config B43_NPHY
> ===
>
> My copy of this patch is missing the @@ here. Is that true for everyone?
>
> Larry
>

Ah... the joy of Pastebin.

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Thu Aug 27 17:24:23 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 27 Aug 2009 17:24:23 +0200
Subject: [PATCH v2] b43: Enable LP-PHY support by default and remove Kconfig
	warning
Message-ID: <4A96A527.5040605@gmail.com>

The most common LP-PHY device, BCM4312, is now fully functional.
So, no need to say "probably won't work for you" anymore.
It's also not "for debuggers and developers only", as it is
perfectly usable for end-users now (at least for BCM4312).

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
This replaces the "remove scary message" patch.

V2: Fix pastebin damage.

 drivers/net/wireless/b43/Kconfig |    4 +---
 1 files changed, 1 insertions(+), 3 deletions(-)

diff --git a/drivers/net/wireless/b43/Kconfig b/drivers/net/wireless/b43/Kconfig
index 237b1aa..2af3b35 100644
--- a/drivers/net/wireless/b43/Kconfig
+++ b/drivers/net/wireless/b43/Kconfig
@@ -82,15 +82,13 @@ config B43_NPHY
 config B43_PHY_LP
 	bool "Support for low-power (LP-PHY) devices (EXPERIMENTAL)"
 	depends on B43 && EXPERIMENTAL
+	default y
 	---help---
 	  Support for the LP-PHY.
 	  The LP-PHY is a low-power PHY built into some notebooks
 	  and embedded devices. It supports 802.11a/g
 	  (802.11a support is optional, and currently disabled).
 
-	  This is heavily experimental, and probably will not work for you.
-	  Say N unless you want to help debug the driver.
-
 # This config option automatically enables b43 LEDS support,
 # if it's possible.
 config B43_LEDS
-- 
1.6.2.4




From netrolller.3d at gmail.com  Thu Aug 27 20:19:20 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 27 Aug 2009 20:19:20 +0200
Subject: [RFC/RFT] b43: Implement antenna diversity support for LP-PHY
Message-ID: <4A96CE28.3040800@gmail.com>

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
This intentionally deviates slightly from the spec (writing
the antenna ID in one pass instead of two) - please test if
this works. (I don't have the tools to test if it actually
selects the right antenna.)

The A/G-PHY changes are fallout fixes from the enum change,
which in turn allows the LP-PHY code to be much simpler.
The antenna_to_phyctl change is a fix for a potential
existing bug that this patch may otherwise trigger.

 drivers/net/wireless/b43/main.c       |    3 ++-
 drivers/net/wireless/b43/phy_a.c      |    2 +-
 drivers/net/wireless/b43/phy_common.h |   10 +++++-----
 drivers/net/wireless/b43/phy_g.c      |    2 +-
 drivers/net/wireless/b43/phy_lp.c     |   11 ++++++++++-
 5 files changed, 19 insertions(+), 9 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index 289e06c..3b038c9 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -1456,7 +1456,8 @@ static u16 b43_antenna_to_phyctl(int antenna)
 		return B43_TXH_PHY_ANT2;
 	case B43_ANTENNA3:
 		return B43_TXH_PHY_ANT3;
-	case B43_ANTENNA_AUTO:
+	case B43_ANTENNA_AUTO0:
+	case B43_ANTENNA_AUTO1:
 		return B43_TXH_PHY_ANT01AUTO;
 	}
 	B43_WARN_ON(1);
diff --git a/drivers/net/wireless/b43/phy_a.c b/drivers/net/wireless/b43/phy_a.c
index 816e028..809ec97 100644
--- a/drivers/net/wireless/b43/phy_a.c
+++ b/drivers/net/wireless/b43/phy_a.c
@@ -531,7 +531,7 @@ static void b43_aphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 
 	tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
 	tmp &= ~B43_PHY_BBANDCFG_RXANT;
-	tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
+	tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
 	    << B43_PHY_BBANDCFG_RXANT_SHIFT;
 	b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
 
diff --git a/drivers/net/wireless/b43/phy_common.h b/drivers/net/wireless/b43/phy_common.h
index b47a0f5..a6a90df 100644
--- a/drivers/net/wireless/b43/phy_common.h
+++ b/drivers/net/wireless/b43/phy_common.h
@@ -49,11 +49,11 @@ enum b43_interference_mitigation {
 
 /* Antenna identifiers */
 enum {
-	B43_ANTENNA0,		/* Antenna 0 */
-	B43_ANTENNA1,		/* Antenna 0 */
-	B43_ANTENNA_AUTO1,	/* Automatic, starting with antenna 1 */
-	B43_ANTENNA_AUTO0,	/* Automatic, starting with antenna 0 */
-	B43_ANTENNA2,
+	B43_ANTENNA0 = 0,	/* Antenna 0 */
+	B43_ANTENNA1 = 1,	/* Antenna 1 */
+	B43_ANTENNA_AUTO0 = 2,	/* Automatic, starting with antenna 0 */
+	B43_ANTENNA_AUTO1 = 3,	/* Automatic, starting with antenna 1 */
+	B43_ANTENNA2 = 4,
 	B43_ANTENNA3 = 8,
 
 	B43_ANTENNA_AUTO = B43_ANTENNA_AUTO0,
diff --git a/drivers/net/wireless/b43/phy_g.c b/drivers/net/wireless/b43/phy_g.c
index c6c9d2f..c6d639d 100644
--- a/drivers/net/wireless/b43/phy_g.c
+++ b/drivers/net/wireless/b43/phy_g.c
@@ -2651,7 +2651,7 @@ static void b43_gphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 
 	tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
 	tmp &= ~B43_PHY_BBANDCFG_RXANT;
-	tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
+	tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
 			<< B43_PHY_BBANDCFG_RXANT_SHIFT;
 	b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
 
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 837d952..457357a 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -2204,7 +2204,16 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
 
 static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 {
-	//TODO
+	int autodiv = ;
+
+	if (dev->phy.rev >= 2)
+		return; // rev2+ doesn't support antenna diversity
+
+	if (B43_WARN_ON(antenna > B43_ANTENNA_AUTO1))
+		return;
+
+	/* NOTE: The spec breaks this up into 2 writes - please test */
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFC, antenna);
 }
 
 static void b43_lpphy_op_adjust_txpower(struct b43_wldev *dev)
-- 
1.6.2.4





From Larry.Finger at lwfinger.net  Thu Aug 27 20:39:40 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 27 Aug 2009 13:39:40 -0500
Subject: [RFC/RFT] b43: Implement antenna diversity support for LP-PHY
In-Reply-To: <4A96CE28.3040800@gmail.com>
References: <4A96CE28.3040800@gmail.com>
Message-ID: <4A96D2EC.6060906@lwfinger.net>

G?bor Stefanik wrote:
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> This intentionally deviates slightly from the spec (writing
> the antenna ID in one pass instead of two) - please test if
> this works. (I don't have the tools to test if it actually
> selects the right antenna.)
> 
> The A/G-PHY changes are fallout fixes from the enum change,
> which in turn allows the LP-PHY code to be much simpler.
> The antenna_to_phyctl change is a fix for a potential
> existing bug that this patch may otherwise trigger.
> 
> drivers/net/wireless/b43/main.c       |    3 ++-
> drivers/net/wireless/b43/phy_a.c      |    2 +-
> drivers/net/wireless/b43/phy_common.h |   10 +++++-----
> drivers/net/wireless/b43/phy_g.c      |    2 +-
> drivers/net/wireless/b43/phy_lp.c     |   11 ++++++++++-
> 5 files changed, 19 insertions(+), 9 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/main.c
> b/drivers/net/wireless/b43/main.c
> index 289e06c..3b038c9 100644
> --- a/drivers/net/wireless/b43/main.c
> +++ b/drivers/net/wireless/b43/main.c
> @@ -1456,7 +1456,8 @@ static u16 b43_antenna_to_phyctl(int antenna)
>         return B43_TXH_PHY_ANT2;
>     case B43_ANTENNA3:
>         return B43_TXH_PHY_ANT3;
> -    case B43_ANTENNA_AUTO:
> +    case B43_ANTENNA_AUTO0:
> +    case B43_ANTENNA_AUTO1:
>         return B43_TXH_PHY_ANT01AUTO;
>     }
>     B43_WARN_ON(1);
> diff --git a/drivers/net/wireless/b43/phy_a.c
> b/drivers/net/wireless/b43/phy_a.c
> index 816e028..809ec97 100644
> --- a/drivers/net/wireless/b43/phy_a.c
> +++ b/drivers/net/wireless/b43/phy_a.c
> @@ -531,7 +531,7 @@ static void b43_aphy_op_set_rx_antenna(struct
> b43_wldev *dev, int antenna)
> 
>     tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
>     tmp &= ~B43_PHY_BBANDCFG_RXANT;
> -    tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
> +    tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
>         << B43_PHY_BBANDCFG_RXANT_SHIFT;
>     b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
> 
> diff --git a/drivers/net/wireless/b43/phy_common.h
> b/drivers/net/wireless/b43/phy_common.h
> index b47a0f5..a6a90df 100644
> --- a/drivers/net/wireless/b43/phy_common.h
> +++ b/drivers/net/wireless/b43/phy_common.h
> @@ -49,11 +49,11 @@ enum b43_interference_mitigation {
> 
> /* Antenna identifiers */
> enum {
> -    B43_ANTENNA0,        /* Antenna 0 */
> -    B43_ANTENNA1,        /* Antenna 0 */
> -    B43_ANTENNA_AUTO1,    /* Automatic, starting with antenna 1 */
> -    B43_ANTENNA_AUTO0,    /* Automatic, starting with antenna 0 */
> -    B43_ANTENNA2,
> +    B43_ANTENNA0 = 0,    /* Antenna 0 */
> +    B43_ANTENNA1 = 1,    /* Antenna 1 */
> +    B43_ANTENNA_AUTO0 = 2,    /* Automatic, starting with antenna 0 */
> +    B43_ANTENNA_AUTO1 = 3,    /* Automatic, starting with antenna 1 */
> +    B43_ANTENNA2 = 4,
>     B43_ANTENNA3 = 8,
> 
>     B43_ANTENNA_AUTO = B43_ANTENNA_AUTO0,
> diff --git a/drivers/net/wireless/b43/phy_g.c
> b/drivers/net/wireless/b43/phy_g.c
> index c6c9d2f..c6d639d 100644
> --- a/drivers/net/wireless/b43/phy_g.c
> +++ b/drivers/net/wireless/b43/phy_g.c
> @@ -2651,7 +2651,7 @@ static void b43_gphy_op_set_rx_antenna(struct
> b43_wldev *dev, int antenna)
> 
>     tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
>     tmp &= ~B43_PHY_BBANDCFG_RXANT;
> -    tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
> +    tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
>             << B43_PHY_BBANDCFG_RXANT_SHIFT;
>     b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
> 
> diff --git a/drivers/net/wireless/b43/phy_lp.c
> b/drivers/net/wireless/b43/phy_lp.c
> index 837d952..457357a 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -2204,7 +2204,16 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
> 
> static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
> {
> -    //TODO
> +    int autodiv = ;
> +
> +    if (dev->phy.rev >= 2)
> +        return; // rev2+ doesn't support antenna diversity
> +
> +    if (B43_WARN_ON(antenna > B43_ANTENNA_AUTO1))
> +        return;
> +
> +    /* NOTE: The spec breaks this up into 2 writes - please test */
> +    b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFC, antenna);
> }
> 
> static void b43_lpphy_op_adjust_txpower(struct b43_wldev *dev)

Sorry, but the spec for this routine was updated 1.5 hours ago.

As to the two-stage write, the spec does match the original code. Who
knows what happens in the device. As it adds little to the routine, I
would suggest implementing it the way the original code does.

Larry


From netrolller.3d at gmail.com  Thu Aug 27 20:56:22 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 27 Aug 2009 20:56:22 +0200
Subject: [PATCH] b43: Implement antenna diversity support for LP-PHY
Message-ID: <4A96D6D6.3050201@gmail.com>

The A/G-PHY changes are fallout fixes from the enum change,
which in turn allows the LP-PHY code to be much simpler.
The antenna_to_phyctl change is a fix for a potential
existing bug that this patch may otherwise trigger.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Note that according to recent spec changes, the A/G-PHY
antenna diversity routines also need to be updated.
However, I'm not lumping those changes into this patch
(this is for LP-PHY).

 drivers/net/wireless/b43/main.c       |    3 ++-
 drivers/net/wireless/b43/phy_a.c      |    2 +-
 drivers/net/wireless/b43/phy_common.h |   10 +++++-----
 drivers/net/wireless/b43/phy_g.c      |    2 +-
 drivers/net/wireless/b43/phy_lp.c     |   11 ++++++++++-
 5 files changed, 19 insertions(+), 9 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index 289e06c..3b038c9 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -1456,7 +1456,8 @@ static u16 b43_antenna_to_phyctl(int antenna)
 		return B43_TXH_PHY_ANT2;
 	case B43_ANTENNA3:
 		return B43_TXH_PHY_ANT3;
-	case B43_ANTENNA_AUTO:
+	case B43_ANTENNA_AUTO0:
+	case B43_ANTENNA_AUTO1:
 		return B43_TXH_PHY_ANT01AUTO;
 	}
 	B43_WARN_ON(1);
diff --git a/drivers/net/wireless/b43/phy_a.c b/drivers/net/wireless/b43/phy_a.c
index 816e028..809ec97 100644
--- a/drivers/net/wireless/b43/phy_a.c
+++ b/drivers/net/wireless/b43/phy_a.c
@@ -531,7 +531,7 @@ static void b43_aphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 
 	tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
 	tmp &= ~B43_PHY_BBANDCFG_RXANT;
-	tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
+	tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
 	    << B43_PHY_BBANDCFG_RXANT_SHIFT;
 	b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
 
diff --git a/drivers/net/wireless/b43/phy_common.h b/drivers/net/wireless/b43/phy_common.h
index b47a0f5..28e3846 100644
--- a/drivers/net/wireless/b43/phy_common.h
+++ b/drivers/net/wireless/b43/phy_common.h
@@ -49,11 +49,11 @@ enum b43_interference_mitigation {
 
 /* Antenna identifiers */
 enum {
-	B43_ANTENNA0,		/* Antenna 0 */
-	B43_ANTENNA1,		/* Antenna 0 */
-	B43_ANTENNA_AUTO1,	/* Automatic, starting with antenna 1 */
-	B43_ANTENNA_AUTO0,	/* Automatic, starting with antenna 0 */
-	B43_ANTENNA2,
+	B43_ANTENNA0 = 0,	/* Antenna 0 */
+	B43_ANTENNA1 = 1,	/* Antenna 1 */
+	B43_ANTENNA_AUTO0 = 2,	/* Automatic, starting with antenna 0 */
+	B43_ANTENNA_AUTO1 = 3,	/* Automatic, starting with antenna 1 */
+	B43_ANTENNA2 = 4,
 	B43_ANTENNA3 = 8,
 
 	B43_ANTENNA_AUTO = B43_ANTENNA_AUTO0,
diff --git a/drivers/net/wireless/b43/phy_g.c b/drivers/net/wireless/b43/phy_g.c
index c6c9d2f..c6d639d 100644
--- a/drivers/net/wireless/b43/phy_g.c
+++ b/drivers/net/wireless/b43/phy_g.c
@@ -2651,7 +2651,7 @@ static void b43_gphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 
 	tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
 	tmp &= ~B43_PHY_BBANDCFG_RXANT;
-	tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
+	tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
 			<< B43_PHY_BBANDCFG_RXANT_SHIFT;
 	b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
 
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 837d952..055c0f7 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -2204,7 +2204,16 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
 
 static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 {
-	//TODO
+	int autodiv = ;
+
+	if (dev->phy.rev >= 2)
+		return; // rev2+ doesn't support antenna diversity
+
+	if (B43_WARN_ON(antenna > B43_ANTENNA_AUTO1))
+		return;
+
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFD, antenna & 0x2);
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFE, antenna & 0x1);
 }
 
 static void b43_lpphy_op_adjust_txpower(struct b43_wldev *dev)
-- 
1.6.2.4





From mb at bu3sch.de  Thu Aug 27 22:31:17 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 27 Aug 2009 22:31:17 +0200
Subject: [PATCH] b43: Implement antenna diversity support for LP-PHY
In-Reply-To: <4A96D6D6.3050201@gmail.com>
References: <4A96D6D6.3050201@gmail.com>
Message-ID: <200908272231.19632.mb@bu3sch.de>

On Thursday 27 August 2009 20:56:22 G?bor Stefanik wrote:
> The A/G-PHY changes are fallout fixes from the enum change,
> which in turn allows the LP-PHY code to be much simpler.
> The antenna_to_phyctl change is a fix for a potential
> existing bug that this patch may otherwise trigger.
> 
> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
> ---
> Note that according to recent spec changes, the A/G-PHY
> antenna diversity routines also need to be updated.
> However, I'm not lumping those changes into this patch
> (this is for LP-PHY).
> 
>  drivers/net/wireless/b43/main.c       |    3 ++-
>  drivers/net/wireless/b43/phy_a.c      |    2 +-
>  drivers/net/wireless/b43/phy_common.h |   10 +++++-----
>  drivers/net/wireless/b43/phy_g.c      |    2 +-
>  drivers/net/wireless/b43/phy_lp.c     |   11 ++++++++++-
>  5 files changed, 19 insertions(+), 9 deletions(-)
> 
> diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
> index 289e06c..3b038c9 100644
> --- a/drivers/net/wireless/b43/main.c
> +++ b/drivers/net/wireless/b43/main.c
> @@ -1456,7 +1456,8 @@ static u16 b43_antenna_to_phyctl(int antenna)
>  		return B43_TXH_PHY_ANT2;
>  	case B43_ANTENNA3:
>  		return B43_TXH_PHY_ANT3;
> -	case B43_ANTENNA_AUTO:
> +	case B43_ANTENNA_AUTO0:
> +	case B43_ANTENNA_AUTO1:
>  		return B43_TXH_PHY_ANT01AUTO;
>  	}
>  	B43_WARN_ON(1);
> diff --git a/drivers/net/wireless/b43/phy_a.c b/drivers/net/wireless/b43/phy_a.c
> index 816e028..809ec97 100644
> --- a/drivers/net/wireless/b43/phy_a.c
> +++ b/drivers/net/wireless/b43/phy_a.c
> @@ -531,7 +531,7 @@ static void b43_aphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
>  
>  	tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
>  	tmp &= ~B43_PHY_BBANDCFG_RXANT;
> -	tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
> +	tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
>  	    << B43_PHY_BBANDCFG_RXANT_SHIFT;
>  	b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
>  
> diff --git a/drivers/net/wireless/b43/phy_common.h b/drivers/net/wireless/b43/phy_common.h
> index b47a0f5..28e3846 100644
> --- a/drivers/net/wireless/b43/phy_common.h
> +++ b/drivers/net/wireless/b43/phy_common.h
> @@ -49,11 +49,11 @@ enum b43_interference_mitigation {
>  
>  /* Antenna identifiers */
>  enum {
> -	B43_ANTENNA0,		/* Antenna 0 */
> -	B43_ANTENNA1,		/* Antenna 0 */
> -	B43_ANTENNA_AUTO1,	/* Automatic, starting with antenna 1 */
> -	B43_ANTENNA_AUTO0,	/* Automatic, starting with antenna 0 */
> -	B43_ANTENNA2,
> +	B43_ANTENNA0 = 0,	/* Antenna 0 */
> +	B43_ANTENNA1 = 1,	/* Antenna 1 */
> +	B43_ANTENNA_AUTO0 = 2,	/* Automatic, starting with antenna 0 */
> +	B43_ANTENNA_AUTO1 = 3,	/* Automatic, starting with antenna 1 */
> +	B43_ANTENNA2 = 4,
>  	B43_ANTENNA3 = 8,
>  
>  	B43_ANTENNA_AUTO = B43_ANTENNA_AUTO0,
> diff --git a/drivers/net/wireless/b43/phy_g.c b/drivers/net/wireless/b43/phy_g.c
> index c6c9d2f..c6d639d 100644
> --- a/drivers/net/wireless/b43/phy_g.c
> +++ b/drivers/net/wireless/b43/phy_g.c
> @@ -2651,7 +2651,7 @@ static void b43_gphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
>  
>  	tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
>  	tmp &= ~B43_PHY_BBANDCFG_RXANT;
> -	tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
> +	tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
>  			<< B43_PHY_BBANDCFG_RXANT_SHIFT;
>  	b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
>  
> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
> index 837d952..055c0f7 100644
> --- a/drivers/net/wireless/b43/phy_lp.c
> +++ b/drivers/net/wireless/b43/phy_lp.c
> @@ -2204,7 +2204,16 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
>  
>  static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
>  {
> -	//TODO
> +	int autodiv = ;

Does this compile?

> +
> +	if (dev->phy.rev >= 2)
> +		return; // rev2+ doesn't support antenna diversity
> +
> +	if (B43_WARN_ON(antenna > B43_ANTENNA_AUTO1))
> +		return;
> +
> +	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFD, antenna & 0x2);
> +	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFE, antenna & 0x1);
>  }
>  
>  static void b43_lpphy_op_adjust_txpower(struct b43_wldev *dev)



-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Thu Aug 27 22:41:17 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Thu, 27 Aug 2009 22:41:17 +0200
Subject: [PATCH] b43: Implement antenna diversity support for LP-PHY
In-Reply-To: <200908272231.19632.mb@bu3sch.de>
References: <4A96D6D6.3050201@gmail.com> <200908272231.19632.mb@bu3sch.de>
Message-ID: <69e28c910908271341i23fd709ag8444b00bad3c7f48@mail.gmail.com>

2009/8/27 Michael Buesch <mb at bu3sch.de>:
> On Thursday 27 August 2009 20:56:22 G?bor Stefanik wrote:
>> The A/G-PHY changes are fallout fixes from the enum change,
>> which in turn allows the LP-PHY code to be much simpler.
>> The antenna_to_phyctl change is a fix for a potential
>> existing bug that this patch may otherwise trigger.
>>
>> Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
>> ---
>> Note that according to recent spec changes, the A/G-PHY
>> antenna diversity routines also need to be updated.
>> However, I'm not lumping those changes into this patch
>> (this is for LP-PHY).
>>
>> ?drivers/net/wireless/b43/main.c ? ? ? | ? ?3 ++-
>> ?drivers/net/wireless/b43/phy_a.c ? ? ?| ? ?2 +-
>> ?drivers/net/wireless/b43/phy_common.h | ? 10 +++++-----
>> ?drivers/net/wireless/b43/phy_g.c ? ? ?| ? ?2 +-
>> ?drivers/net/wireless/b43/phy_lp.c ? ? | ? 11 ++++++++++-
>> ?5 files changed, 19 insertions(+), 9 deletions(-)
>>
>> diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
>> index 289e06c..3b038c9 100644
>> --- a/drivers/net/wireless/b43/main.c
>> +++ b/drivers/net/wireless/b43/main.c
>> @@ -1456,7 +1456,8 @@ static u16 b43_antenna_to_phyctl(int antenna)
>> ? ? ? ? ? ? ? return B43_TXH_PHY_ANT2;
>> ? ? ? case B43_ANTENNA3:
>> ? ? ? ? ? ? ? return B43_TXH_PHY_ANT3;
>> - ? ? case B43_ANTENNA_AUTO:
>> + ? ? case B43_ANTENNA_AUTO0:
>> + ? ? case B43_ANTENNA_AUTO1:
>> ? ? ? ? ? ? ? return B43_TXH_PHY_ANT01AUTO;
>> ? ? ? }
>> ? ? ? B43_WARN_ON(1);
>> diff --git a/drivers/net/wireless/b43/phy_a.c b/drivers/net/wireless/b43/phy_a.c
>> index 816e028..809ec97 100644
>> --- a/drivers/net/wireless/b43/phy_a.c
>> +++ b/drivers/net/wireless/b43/phy_a.c
>> @@ -531,7 +531,7 @@ static void b43_aphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
>>
>> ? ? ? tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
>> ? ? ? tmp &= ~B43_PHY_BBANDCFG_RXANT;
>> - ? ? tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
>> + ? ? tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
>> ? ? ? ? ? << B43_PHY_BBANDCFG_RXANT_SHIFT;
>> ? ? ? b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
>>
>> diff --git a/drivers/net/wireless/b43/phy_common.h b/drivers/net/wireless/b43/phy_common.h
>> index b47a0f5..28e3846 100644
>> --- a/drivers/net/wireless/b43/phy_common.h
>> +++ b/drivers/net/wireless/b43/phy_common.h
>> @@ -49,11 +49,11 @@ enum b43_interference_mitigation {
>>
>> ?/* Antenna identifiers */
>> ?enum {
>> - ? ? B43_ANTENNA0, ? ? ? ? ? /* Antenna 0 */
>> - ? ? B43_ANTENNA1, ? ? ? ? ? /* Antenna 0 */
>> - ? ? B43_ANTENNA_AUTO1, ? ? ?/* Automatic, starting with antenna 1 */
>> - ? ? B43_ANTENNA_AUTO0, ? ? ?/* Automatic, starting with antenna 0 */
>> - ? ? B43_ANTENNA2,
>> + ? ? B43_ANTENNA0 = 0, ? ? ? /* Antenna 0 */
>> + ? ? B43_ANTENNA1 = 1, ? ? ? /* Antenna 1 */
>> + ? ? B43_ANTENNA_AUTO0 = 2, ?/* Automatic, starting with antenna 0 */
>> + ? ? B43_ANTENNA_AUTO1 = 3, ?/* Automatic, starting with antenna 1 */
>> + ? ? B43_ANTENNA2 = 4,
>> ? ? ? B43_ANTENNA3 = 8,
>>
>> ? ? ? B43_ANTENNA_AUTO = B43_ANTENNA_AUTO0,
>> diff --git a/drivers/net/wireless/b43/phy_g.c b/drivers/net/wireless/b43/phy_g.c
>> index c6c9d2f..c6d639d 100644
>> --- a/drivers/net/wireless/b43/phy_g.c
>> +++ b/drivers/net/wireless/b43/phy_g.c
>> @@ -2651,7 +2651,7 @@ static void b43_gphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
>>
>> ? ? ? tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
>> ? ? ? tmp &= ~B43_PHY_BBANDCFG_RXANT;
>> - ? ? tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
>> + ? ? tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
>> ? ? ? ? ? ? ? ? ? ? ? << B43_PHY_BBANDCFG_RXANT_SHIFT;
>> ? ? ? b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
>>
>> diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
>> index 837d952..055c0f7 100644
>> --- a/drivers/net/wireless/b43/phy_lp.c
>> +++ b/drivers/net/wireless/b43/phy_lp.c
>> @@ -2204,7 +2204,16 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
>>
>> ?static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
>> ?{
>> - ? ? //TODO
>> + ? ? int autodiv = ;
>
> Does this compile?

That's a typo. Also, the autodiv variable shouldn't be there at all.
Will respin.

>
>> +
>> + ? ? if (dev->phy.rev >= 2)
>> + ? ? ? ? ? ? return; // rev2+ doesn't support antenna diversity
>> +
>> + ? ? if (B43_WARN_ON(antenna > B43_ANTENNA_AUTO1))
>> + ? ? ? ? ? ? return;
>> +
>> + ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFD, antenna & 0x2);
>> + ? ? b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFE, antenna & 0x1);
>> ?}
>>
>> ?static void b43_lpphy_op_adjust_txpower(struct b43_wldev *dev)
>
>
>
> --
> Greetings, Michael.
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Thu Aug 27 22:49:49 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Thu, 27 Aug 2009 22:49:49 +0200
Subject: [PATCH v2] b43: Implement antenna diversity support for LP-PHY
Message-ID: <4A96F16D.2020304@gmail.com>

The A/G-PHY changes are fallout fixes from the enum change,
which in turn allows the LP-PHY code to be much simpler.
The antenna_to_phyctl change is a fix for a potential
existing bug that this patch may otherwise trigger.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
v2: Fix a typo.

 drivers/net/wireless/b43/main.c       |    3 ++-
 drivers/net/wireless/b43/phy_a.c      |    2 +-
 drivers/net/wireless/b43/phy_common.h |   10 +++++-----
 drivers/net/wireless/b43/phy_g.c      |    2 +-
 drivers/net/wireless/b43/phy_lp.c     |    9 ++++++++-
 5 files changed, 17 insertions(+), 9 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index 289e06c..3b038c9 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -1456,7 +1456,8 @@ static u16 b43_antenna_to_phyctl(int antenna)
 		return B43_TXH_PHY_ANT2;
 	case B43_ANTENNA3:
 		return B43_TXH_PHY_ANT3;
-	case B43_ANTENNA_AUTO:
+	case B43_ANTENNA_AUTO0:
+	case B43_ANTENNA_AUTO1:
 		return B43_TXH_PHY_ANT01AUTO;
 	}
 	B43_WARN_ON(1);
diff --git a/drivers/net/wireless/b43/phy_a.c b/drivers/net/wireless/b43/phy_a.c
index 816e028..809ec97 100644
--- a/drivers/net/wireless/b43/phy_a.c
+++ b/drivers/net/wireless/b43/phy_a.c
@@ -531,7 +531,7 @@ static void b43_aphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 
 	tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
 	tmp &= ~B43_PHY_BBANDCFG_RXANT;
-	tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
+	tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
 	    << B43_PHY_BBANDCFG_RXANT_SHIFT;
 	b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
 
diff --git a/drivers/net/wireless/b43/phy_common.h b/drivers/net/wireless/b43/phy_common.h
index b47a0f5..28e3846 100644
--- a/drivers/net/wireless/b43/phy_common.h
+++ b/drivers/net/wireless/b43/phy_common.h
@@ -49,11 +49,11 @@ enum b43_interference_mitigation {
 
 /* Antenna identifiers */
 enum {
-	B43_ANTENNA0,		/* Antenna 0 */
-	B43_ANTENNA1,		/* Antenna 0 */
-	B43_ANTENNA_AUTO1,	/* Automatic, starting with antenna 1 */
-	B43_ANTENNA_AUTO0,	/* Automatic, starting with antenna 0 */
-	B43_ANTENNA2,
+	B43_ANTENNA0 = 0,	/* Antenna 0 */
+	B43_ANTENNA1 = 1,	/* Antenna 1 */
+	B43_ANTENNA_AUTO0 = 2,	/* Automatic, starting with antenna 0 */
+	B43_ANTENNA_AUTO1 = 3,	/* Automatic, starting with antenna 1 */
+	B43_ANTENNA2 = 4,
 	B43_ANTENNA3 = 8,
 
 	B43_ANTENNA_AUTO = B43_ANTENNA_AUTO0,
diff --git a/drivers/net/wireless/b43/phy_g.c b/drivers/net/wireless/b43/phy_g.c
index c6c9d2f..c6d639d 100644
--- a/drivers/net/wireless/b43/phy_g.c
+++ b/drivers/net/wireless/b43/phy_g.c
@@ -2651,7 +2651,7 @@ static void b43_gphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 
 	tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
 	tmp &= ~B43_PHY_BBANDCFG_RXANT;
-	tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
+	tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
 			<< B43_PHY_BBANDCFG_RXANT_SHIFT;
 	b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
 
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 837d952..fded6e5 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -2204,7 +2204,14 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
 
 static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 {
-	//TODO
+	if (dev->phy.rev >= 2)
+		return; // rev2+ doesn't support antenna diversity
+
+	if (B43_WARN_ON(antenna > B43_ANTENNA_AUTO1))
+		return;
+
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFD, antenna & 0x2);
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFE, antenna & 0x1);
 }
 
 static void b43_lpphy_op_adjust_txpower(struct b43_wldev *dev)
-- 
1.6.2.4





From Larry.Finger at lwfinger.net  Thu Aug 27 23:01:32 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 27 Aug 2009 16:01:32 -0500
Subject: [PATCH] b43: Implement antenna diversity support for LP-PHY
In-Reply-To: <4A96D6D6.3050201@gmail.com>
References: <4A96D6D6.3050201@gmail.com>
Message-ID: <4A96F42C.30501@lwfinger.net>

G?bor Stefanik wrote:
> static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
> {
> -    //TODO
> +    int autodiv = ;
> +
> +    if (dev->phy.rev >= 2)
> +        return; // rev2+ doesn't support antenna diversity
> +
> +    if (B43_WARN_ON(antenna > B43_ANTENNA_AUTO1))
> +        return;
> +
> +    b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFD, antenna & 0x2);
> +    b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFE, antenna & 0x1);
> }
> 
> static void b43_lpphy_op_adjust_txpower(struct b43_wldev *dev)

I noticed that your code didn't look like the specs, which is why I
thought the recent changes had affected this section.

It took me a while to figure it out, but the code above is correct.
The part that led to confusion is that the vendor uses 3 to indicate
"start with antenna 0", while you use 2 for that state. Even if we get
it wrong later, it shouldn't matter.

Larry


From netrolller.3d at gmail.com  Fri Aug 28 21:37:00 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 28 Aug 2009 21:37:00 +0200
Subject: [PATCH] b43: Refactor and update antenna diversity for A/G-PHY
Message-ID: <4A9831DC.4050802@gmail.com>

-Make use of the b43_phy_set/mask/maskset helpers.
-Fix a few errors in the code.
-Make the code more readable.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
The "phy->analog == 3" to "phy->rev == 3" change in A-PHY is intentional,
it's a bugfix/spec conformance fix.

 drivers/net/wireless/b43/phy_a.c |   48 ++++++++++----------------------
 drivers/net/wireless/b43/phy_g.c |   55 +++++++++++++++----------------------
 2 files changed, 37 insertions(+), 66 deletions(-)

diff --git a/drivers/net/wireless/b43/phy_a.c b/drivers/net/wireless/b43/phy_a.c
index 809ec97..d90217c 100644
--- a/drivers/net/wireless/b43/phy_a.c
+++ b/drivers/net/wireless/b43/phy_a.c
@@ -518,58 +518,40 @@ static unsigned int b43_aphy_op_get_default_chan(struct b43_wldev *dev)
 static void b43_aphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 {//TODO
 	struct b43_phy *phy = &dev->phy;
-	u64 hf;
 	u16 tmp;
 	int autodiv = 0;
 
 	if (antenna == B43_ANTENNA_AUTO0 || antenna == B43_ANTENNA_AUTO1)
 		autodiv = 1;
 
-	hf = b43_hf_read(dev);
-	hf &= ~B43_HF_ANTDIVHELP;
-	b43_hf_write(dev, hf);
+	b43_hf_write(dev, b43_hf_read(dev) & ~B43_HF_ANTDIVHELP);
 
-	tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
-	tmp &= ~B43_PHY_BBANDCFG_RXANT;
-	tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
-	    << B43_PHY_BBANDCFG_RXANT_SHIFT;
-	b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
+	b43_phy_maskset(dev, B43_PHY_BBANDCFG, ~B43_PHY_BBANDCFG_RXANT,
+			(autodiv ? B43_ANTENNA_AUTO1 : antenna) <<
+			B43_PHY_BBANDCFG_RXANT_SHIFT);
 
 	if (autodiv) {
 		tmp = b43_phy_read(dev, B43_PHY_ANTDWELL);
-		if (antenna == B43_ANTENNA_AUTO0)
+		if (antenna == B43_ANTENNA_AUTO1)
 			tmp &= ~B43_PHY_ANTDWELL_AUTODIV1;
 		else
 			tmp |= B43_PHY_ANTDWELL_AUTODIV1;
 		b43_phy_write(dev, B43_PHY_ANTDWELL, tmp);
 	}
-	if (phy->rev < 3) {
-		tmp = b43_phy_read(dev, B43_PHY_ANTDWELL);
-		tmp = (tmp & 0xFF00) | 0x24;
-		b43_phy_write(dev, B43_PHY_ANTDWELL, tmp);
-	} else {
-		tmp = b43_phy_read(dev, B43_PHY_OFDM61);
-		tmp |= 0x10;
-		b43_phy_write(dev, B43_PHY_OFDM61, tmp);
-		if (phy->analog == 3) {
-			b43_phy_write(dev, B43_PHY_CLIPPWRDOWNT,
-				      0x1D);
-			b43_phy_write(dev, B43_PHY_ADIVRELATED,
-				      8);
+	if (phy->rev < 3)
+		b43_phy_maskset(dev, B43_PHY_ANTDWELL, 0xFF00, 0x24);
+	else {
+		b43_phy_set(dev, B43_PHY_OFDM61, 0x10);
+		if (phy->rev == 3) {
+			b43_phy_write(dev, B43_PHY_CLIPPWRDOWNT, 0x1D);
+			b43_phy_write(dev, B43_PHY_ADIVRELATED, 8);
 		} else {
-			b43_phy_write(dev, B43_PHY_CLIPPWRDOWNT,
-				      0x3A);
-			tmp =
-			    b43_phy_read(dev,
-					 B43_PHY_ADIVRELATED);
-			tmp = (tmp & 0xFF00) | 8;
-			b43_phy_write(dev, B43_PHY_ADIVRELATED,
-				      tmp);
+			b43_phy_write(dev, B43_PHY_CLIPPWRDOWNT, 0x3A);
+			b43_phy_maskset(dev, B43_PHY_ADIVRELATED, 0xFF00, 8);
 		}
 	}
 
-	hf |= B43_HF_ANTDIVHELP;
-	b43_hf_write(dev, hf);
+	b43_hf_write(dev, b43_hf_read(dev) | B43_HF_ANTDIVHELP);
 }
 
 static void b43_aphy_op_adjust_txpower(struct b43_wldev *dev)
diff --git a/drivers/net/wireless/b43/phy_g.c b/drivers/net/wireless/b43/phy_g.c
index c6d639d..4b6154b 100644
--- a/drivers/net/wireless/b43/phy_g.c
+++ b/drivers/net/wireless/b43/phy_g.c
@@ -2638,65 +2638,54 @@ static unsigned int b43_gphy_op_get_default_chan(struct b43_wldev *dev)
 static void b43_gphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
 {
 	struct b43_phy *phy = &dev->phy;
-	u64 hf;
 	u16 tmp;
 	int autodiv = 0;
 
 	if (antenna == B43_ANTENNA_AUTO0 || antenna == B43_ANTENNA_AUTO1)
 		autodiv = 1;
 
-	hf = b43_hf_read(dev);
-	hf &= ~B43_HF_ANTDIVHELP;
-	b43_hf_write(dev, hf);
-
-	tmp = b43_phy_read(dev, B43_PHY_BBANDCFG);
-	tmp &= ~B43_PHY_BBANDCFG_RXANT;
-	tmp |= (autodiv ? B43_ANTENNA_AUTO1 : antenna)
-			<< B43_PHY_BBANDCFG_RXANT_SHIFT;
-	b43_phy_write(dev, B43_PHY_BBANDCFG, tmp);
+	b43_hf_write(dev, b43_hf_read(dev) & ~B43_HF_ANTDIVHELP);
 
+	b43_phy_maskset(dev, B43_PHY_BBANDCFG, ~B43_PHY_BBANDCFG_RXANT,
+			(autodiv ? B43_ANTENNA_AUTO1 : antenna) <<
+			B43_PHY_BBANDCFG_RXANT_SHIFT);
+			
 	if (autodiv) {
 		tmp = b43_phy_read(dev, B43_PHY_ANTDWELL);
-		if (antenna == B43_ANTENNA_AUTO0)
+		if (antenna == B43_ANTENNA_AUTO1)
 			tmp &= ~B43_PHY_ANTDWELL_AUTODIV1;
 		else
 			tmp |= B43_PHY_ANTDWELL_AUTODIV1;
 		b43_phy_write(dev, B43_PHY_ANTDWELL, tmp);
 	}
+
 	tmp = b43_phy_read(dev, B43_PHY_ANTWRSETT);
 	if (autodiv)
 		tmp |= B43_PHY_ANTWRSETT_ARXDIV;
 	else
 		tmp &= ~B43_PHY_ANTWRSETT_ARXDIV;
 	b43_phy_write(dev, B43_PHY_ANTWRSETT, tmp);
-	if (phy->rev >= 2) {
-		tmp = b43_phy_read(dev, B43_PHY_OFDM61);
-		tmp |= B43_PHY_OFDM61_10;
-		b43_phy_write(dev, B43_PHY_OFDM61, tmp);
 
-		tmp =
-		    b43_phy_read(dev, B43_PHY_DIVSRCHGAINBACK);
-		tmp = (tmp & 0xFF00) | 0x15;
-		b43_phy_write(dev, B43_PHY_DIVSRCHGAINBACK,
-			      tmp);
+	if (autodiv)
+		b43_phy_set(dev, B43_PHY_ANTWRSETT, B43_PHY_ANTWRSETT_ARXDIV);
+	else {
+		b43_phy_mask(dev, B43_PHY_ANTWRSETT,
+			     B43_PHY_ANTWRSETT_ARXDIV);
+	}
 
-		if (phy->rev == 2) {
-			b43_phy_write(dev, B43_PHY_ADIVRELATED,
-				      8);
-		} else {
-			tmp =
-			    b43_phy_read(dev,
-					 B43_PHY_ADIVRELATED);
-			tmp = (tmp & 0xFF00) | 8;
-			b43_phy_write(dev, B43_PHY_ADIVRELATED,
-				      tmp);
-		}
+	if (phy->rev >= 2) {
+		b43_phy_set(dev, B43_PHY_OFDM61, B43_PHY_OFDM61_10);
+		b43_phy_maskset(dev, B43_PHY_DIVSRCHGAINBACK, 0xFF00, 0x15);
+
+		if (phy->rev == 2)
+			b43_phy_write(dev, B43_PHY_ADIVRELATED, 8);
+		else
+			b43_phy_maskset(dev, B43_PHY_ADIVRELATED, 0xFF00, 8);
 	}
 	if (phy->rev >= 6)
 		b43_phy_write(dev, B43_PHY_OFDM9B, 0xDC);
 
-	hf |= B43_HF_ANTDIVHELP;
-	b43_hf_write(dev, hf);
+	b43_hf_write(dev, b43_hf_read(dev) | B43_HF_ANTDIVHELP);
 }
 
 static int b43_gphy_op_interf_mitigation(struct b43_wldev *dev,
-- 
1.6.2.4





From netrolller.3d at gmail.com  Fri Aug 28 22:32:17 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 28 Aug 2009 22:32:17 +0200
Subject: [PATCH] b43: Add myself to module authors & to LP-PHY file copyright
	notices
Message-ID: <4A983ED1.9040100@gmail.com>

Also mark the LP-PHY driver "802.11a/g" instead of "802.11g",
as LP-PHY is capable of both 2GHz and 5GHz operation.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/main.c         |    1 +
 drivers/net/wireless/b43/phy_lp.c       |    3 ++-
 drivers/net/wireless/b43/tables_lpphy.c |    3 ++-
 3 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index 5cc90a2..f2c5b2d 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -58,6 +58,7 @@ MODULE_DESCRIPTION("Broadcom B43 wireless driver");
 MODULE_AUTHOR("Martin Langer");
 MODULE_AUTHOR("Stefano Brivio");
 MODULE_AUTHOR("Michael Buesch");
+MODULE_AUTHOR("G?bor Stefanik");
 MODULE_LICENSE("GPL");
 
 MODULE_FIRMWARE(B43_SUPPORTED_FIRMWARE_ID);
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index fded6e5..5fff30a 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -1,9 +1,10 @@
 /*
 
   Broadcom B43 wireless driver
-  IEEE 802.11g LP-PHY driver
+  IEEE 802.11a/g LP-PHY driver
 
   Copyright (c) 2008-2009 Michael Buesch <mb at bu3sch.de>
+  Copyright (c) 2009 G?bor Stefanik <netrolller.3d at gmail.com>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
diff --git a/drivers/net/wireless/b43/tables_lpphy.c b/drivers/net/wireless/b43/tables_lpphy.c
index 3464ac0..61027ee 100644
--- a/drivers/net/wireless/b43/tables_lpphy.c
+++ b/drivers/net/wireless/b43/tables_lpphy.c
@@ -1,9 +1,10 @@
 /*
 
   Broadcom B43 wireless driver
-  IEEE 802.11g LP-PHY and radio device data tables
+  IEEE 802.11a/g LP-PHY and radio device data tables
 
   Copyright (c) 2009 Michael Buesch <mb at bu3sch.de>
+  Copyright (c) 2009 G?bor Stefanik <netrolller.3d at gmail.com>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
-- 
1.6.2.4





From netrolller.3d at gmail.com  Fri Aug 28 22:34:21 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 28 Aug 2009 22:34:21 +0200
Subject: [PATCH] b43: Fix typo in modparam_btcoex description
Message-ID: <4A983F4D.90805@gmail.com>

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
 drivers/net/wireless/b43/main.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index 1263f4b..f2c5b2d 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -91,7 +91,7 @@ MODULE_PARM_DESC(qos, "Enable QOS support (default on)");
 
 static int modparam_btcoex = 1;
 module_param_named(btcoex, modparam_btcoex, int, 0444);
-MODULE_PARM_DESC(btcoex, "Enable Bluetooth coexistance (default on)");
+MODULE_PARM_DESC(btcoex, "Enable Bluetooth coexistence (default on)");
 
 int b43_modparam_verbose = B43_VERBOSITY_DEFAULT;
 module_param_named(verbose, b43_modparam_verbose, int, 0644);
-- 
1.6.2.4





From netrolller.3d at gmail.com  Fri Aug 28 22:36:02 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Fri, 28 Aug 2009 22:36:02 +0200
Subject: b43: LP-PHY: Fix TX gain tables
Message-ID: <4A983FB2.2020509@gmail.com>

The rev1 2GHz and rev2 5GHz gain tables were incorrectly documented
on the specs originally. Update these gaintables to match the cor-
rected specs.

Signed-off-by: G?bor Stefanik <netroller.3d at gmail.com>
---
 drivers/net/wireless/b43/tables_lpphy.c |  306 +++++++++++++++---------------
 1 files changed, 153 insertions(+), 153 deletions(-)

diff --git a/drivers/net/wireless/b43/tables_lpphy.c b/drivers/net/wireless/b43/tables_lpphy.c
index b24521c..0312b31 100644
--- a/drivers/net/wireless/b43/tables_lpphy.c
+++ b/drivers/net/wireless/b43/tables_lpphy.c
@@ -1613,11 +1613,62 @@ static struct lpphy_tx_gain_table_entry lpphy_rev1_nopa_tx_gain_table[] = {
 };
 
 static struct lpphy_tx_gain_table_entry lpphy_rev1_2ghz_tx_gain_table[] = {
-	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 85, },
-	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 81, },
-	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 78, },
-	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 76, },
-	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 74, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 90, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 88, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 85, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 83, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 81, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 78, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 76, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 74, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 59, },
+	{ .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 72, },
+	{ .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 70, },
+	{ .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 68, },
+	{ .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 66, },
+	{ .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 64, },
+	{ .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 62, },
+	{ .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 60, },
+	{ .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 59, },
 	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 72, },
 	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
 	{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
@@ -1690,57 +1741,6 @@ static struct lpphy_tx_gain_table_entry lpphy_rev1_2ghz_tx_gain_table[] = {
 	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 64, },
 	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 62, },
 	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 60, },
-	{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 59, },
-	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 72, },
-	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 70, },
-	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 68, },
-	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 66, },
-	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 64, },
-	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 62, },
-	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 60, },
-	{ .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 59, },
-	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 70, },
-	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 68, },
-	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 66, },
-	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 64, },
-	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 63, },
-	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 61, },
-	{ .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 59, },
-	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 71, },
-	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 69, },
-	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 67, },
-	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 65, },
-	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 63, },
-	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 62, },
-	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 60, },
-	{ .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 58, },
-	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 70, },
-	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 68, },
-	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 66, },
-	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 65, },
-	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 63, },
-	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 61, },
-	{ .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 59, },
-	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 68, },
-	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 66, },
-	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 64, },
-	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 62, },
-	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 61, },
-	{ .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 59, },
-	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 67, },
-	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 65, },
-	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 63, },
-	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 62, },
-	{ .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 60, },
-	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 65, },
-	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 63, },
-	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 61, },
-	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 60, },
-	{ .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 58, },
-	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 68, },
-	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 66, },
-	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 64, },
-	{ .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 62, },
 };
 
 static struct lpphy_tx_gain_table_entry lpphy_rev1_5ghz_tx_gain_table[] = {
@@ -2168,103 +2168,103 @@ static struct lpphy_tx_gain_table_entry lpphy_rev2_5ghz_tx_gain_table[] = {
 	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 68, },
 	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 66, },
 	{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 248, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 241, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 234, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 227, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 221, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 215, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 208, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 203, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 197, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 191, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 186, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 181, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 175, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 170, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 166, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 161, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 156, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 152, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 148, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 143, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 139, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 135, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 132, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 128, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 124, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 121, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 117, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 114, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 111, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 108, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 104, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 102, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 99, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 96, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 93, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 90, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 88, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 85, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 83, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 81, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 78, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 76, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 74, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 72, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 70, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 68, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 66, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 62, .pad = 255, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 62, .pad = 248, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 60, .pad = 248, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 60, .pad = 241, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 59, .pad = 241, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 59, .pad = 234, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 57, .pad = 234, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 57, .pad = 227, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 55, .pad = 227, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 55, .pad = 221, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 54, .pad = 221, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 54, .pad = 215, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 52, .pad = 215, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 52, .pad = 208, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 51, .pad = 208, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 51, .pad = 203, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 49, .pad = 203, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 49, .pad = 197, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 48, .pad = 197, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 48, .pad = 191, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 47, .pad = 191, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 47, .pad = 186, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 45, .pad = 186, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 45, .pad = 181, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 44, .pad = 181, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 44, .pad = 175, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 43, .pad = 175, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 43, .pad = 170, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 42, .pad = 170, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 42, .pad = 166, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 40, .pad = 166, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 40, .pad = 161, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 39, .pad = 161, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 39, .pad = 156, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 38, .pad = 156, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 38, .pad = 152, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 37, .pad = 152, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 37, .pad = 148, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 36, .pad = 148, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 36, .pad = 143, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 35, .pad = 143, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 35, .pad = 139, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 34, .pad = 139, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 34, .pad = 135, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 33, .pad = 135, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 33, .pad = 132, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 32, .pad = 132, .dac = 0, .bb_mult = 64, },
-	{ .gm = 255, .pga = 32, .pad = 128, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 248, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 241, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 234, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 227, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 221, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 215, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 208, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 197, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 191, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 186, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 181, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 175, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 170, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 166, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 161, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 156, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 152, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 148, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 143, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 139, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 135, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 132, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 128, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 124, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 121, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 117, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 114, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 111, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 108, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 104, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 102, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 99, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 96, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 93, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 90, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 88, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 85, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 83, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 81, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 78, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 76, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 74, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 72, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 70, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 68, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 66, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 64, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 64, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 255, .pad = 62, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 248, .pad = 62, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 248, .pad = 60, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 241, .pad = 60, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 241, .pad = 59, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 234, .pad = 59, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 234, .pad = 57, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 227, .pad = 57, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 227, .pad = 55, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 221, .pad = 55, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 221, .pad = 54, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 215, .pad = 54, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 215, .pad = 52, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 208, .pad = 52, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 208, .pad = 51, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 203, .pad = 51, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 203, .pad = 49, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 197, .pad = 49, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 197, .pad = 48, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 191, .pad = 48, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 191, .pad = 47, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 186, .pad = 47, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 186, .pad = 45, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 181, .pad = 45, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 181, .pad = 44, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 175, .pad = 44, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 175, .pad = 43, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 170, .pad = 43, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 170, .pad = 42, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 166, .pad = 42, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 166, .pad = 40, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 161, .pad = 40, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 161, .pad = 39, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 156, .pad = 39, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 156, .pad = 38, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 152, .pad = 38, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 152, .pad = 37, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 148, .pad = 37, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 148, .pad = 36, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 143, .pad = 36, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 143, .pad = 35, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 139, .pad = 35, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 139, .pad = 34, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 135, .pad = 34, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 135, .pad = 33, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 132, .pad = 33, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 132, .pad = 32, .dac = 0, .bb_mult = 64, },
+	{ .gm = 255, .pga = 128, .pad = 32, .dac = 0, .bb_mult = 64, },
 };
 
 void lpphy_rev0_1_table_init(struct b43_wldev *dev)
-- 
1.6.2.4





From netrolller.3d at gmail.com  Fri Aug 28 22:37:37 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Fri, 28 Aug 2009 22:37:37 +0200
Subject: [PATCH] b43: LP-PHY: Fix TX gain tables
In-Reply-To: <4A983FB2.2020509@gmail.com>
References: <4A983FB2.2020509@gmail.com>
Message-ID: <69e28c910908281337y63042942k9c8d54b99a17f493@mail.gmail.com>

Just noticed that the [PATCH] tag is accidentally missing on this one
- I hope you can still apply it.

2009/8/28 G?bor Stefanik <netrolller.3d at gmail.com>:
> The rev1 2GHz and rev2 5GHz gain tables were incorrectly documented
> on the specs originally. Update these gaintables to match the cor-
> rected specs.
>
> Signed-off-by: G?bor Stefanik <netroller.3d at gmail.com>
> ---
> drivers/net/wireless/b43/tables_lpphy.c | ?306
> +++++++++++++++---------------
> 1 files changed, 153 insertions(+), 153 deletions(-)
>
> diff --git a/drivers/net/wireless/b43/tables_lpphy.c
> b/drivers/net/wireless/b43/tables_lpphy.c
> index b24521c..0312b31 100644
> --- a/drivers/net/wireless/b43/tables_lpphy.c
> +++ b/drivers/net/wireless/b43/tables_lpphy.c
> @@ -1613,11 +1613,62 @@ static struct lpphy_tx_gain_table_entry
> lpphy_rev1_nopa_tx_gain_table[] = {
> };
>
> static struct lpphy_tx_gain_table_entry lpphy_rev1_2ghz_tx_gain_table[] = {
> - ? ? ? { .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 85, },
> - ? ? ? { .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 81, },
> - ? ? ? { .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 78, },
> - ? ? ? { .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 76, },
> - ? ? ? { .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 74, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 90, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 88, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 85, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 83, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 81, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 78, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 76, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 74, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 72, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 70, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 68, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 66, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 62, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 60, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 15, .dac = 0, .bb_mult = 59, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 72, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 70, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 68, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 66, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 62, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 60, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 14, .dac = 0, .bb_mult = 59, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 72, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 70, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 68, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 66, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 62, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 60, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 13, .dac = 0, .bb_mult = 59, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 72, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 70, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 68, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 66, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 62, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 60, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 12, .dac = 0, .bb_mult = 59, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 72, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 70, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 68, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 66, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 62, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 60, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 11, .dac = 0, .bb_mult = 59, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 72, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 70, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 68, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 66, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 62, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 60, },
> + ? ? ? { .gm = 4, .pga = 15, .pad = 10, .dac = 0, .bb_mult = 59, },
> ? ? ? ?{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 72, },
> ? ? ? ?{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 70, },
> ? ? ? ?{ .gm = 4, .pga = 15, .pad = 9, .dac = 0, .bb_mult = 68, },
> @@ -1690,57 +1741,6 @@ static struct lpphy_tx_gain_table_entry
> lpphy_rev1_2ghz_tx_gain_table[] = {
> ? ? ? ?{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 64, },
> ? ? ? ?{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 62, },
> ? ? ? ?{ .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 60, },
> - ? ? ? { .gm = 4, .pga = 10, .pad = 6, .dac = 0, .bb_mult = 59, },
> - ? ? ? { .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 72, },
> - ? ? ? { .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 70, },
> - ? ? ? { .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 68, },
> - ? ? ? { .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 66, },
> - ? ? ? { .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 62, },
> - ? ? ? { .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 60, },
> - ? ? ? { .gm = 4, .pga = 10, .pad = 5, .dac = 0, .bb_mult = 59, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 70, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 68, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 66, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 63, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 61, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 5, .dac = 0, .bb_mult = 59, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 71, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 69, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 67, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 65, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 63, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 62, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 60, },
> - ? ? ? { .gm = 4, .pga = 9, .pad = 4, .dac = 0, .bb_mult = 58, },
> - ? ? ? { .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 70, },
> - ? ? ? { .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 68, },
> - ? ? ? { .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 66, },
> - ? ? ? { .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 65, },
> - ? ? ? { .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 63, },
> - ? ? ? { .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 61, },
> - ? ? ? { .gm = 4, .pga = 8, .pad = 4, .dac = 0, .bb_mult = 59, },
> - ? ? ? { .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 68, },
> - ? ? ? { .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 66, },
> - ? ? ? { .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 62, },
> - ? ? ? { .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 61, },
> - ? ? ? { .gm = 4, .pga = 7, .pad = 4, .dac = 0, .bb_mult = 59, },
> - ? ? ? { .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 67, },
> - ? ? ? { .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 65, },
> - ? ? ? { .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 63, },
> - ? ? ? { .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 62, },
> - ? ? ? { .gm = 4, .pga = 7, .pad = 3, .dac = 0, .bb_mult = 60, },
> - ? ? ? { .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 65, },
> - ? ? ? { .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 63, },
> - ? ? ? { .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 61, },
> - ? ? ? { .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 60, },
> - ? ? ? { .gm = 4, .pga = 6, .pad = 3, .dac = 0, .bb_mult = 58, },
> - ? ? ? { .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 68, },
> - ? ? ? { .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 66, },
> - ? ? ? { .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 4, .pga = 5, .pad = 3, .dac = 0, .bb_mult = 62, },
> };
>
> static struct lpphy_tx_gain_table_entry lpphy_rev1_5ghz_tx_gain_table[] = {
> @@ -2168,103 +2168,103 @@ static struct lpphy_tx_gain_table_entry
> lpphy_rev2_5ghz_tx_gain_table[] = {
> ? ? ? ?{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 68, },
> ? ? ? ?{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 66, },
> ? ? ? ?{ .gm = 255, .pga = 255, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 248, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 241, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 234, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 227, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 221, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 215, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 208, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 203, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 197, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 191, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 186, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 181, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 175, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 170, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 166, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 161, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 156, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 152, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 148, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 143, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 139, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 135, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 132, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 128, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 124, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 121, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 117, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 114, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 111, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 108, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 104, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 102, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 99, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 96, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 93, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 90, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 88, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 85, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 83, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 81, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 78, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 76, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 74, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 72, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 70, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 68, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 66, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 64, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 62, .pad = 255, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 62, .pad = 248, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 60, .pad = 248, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 60, .pad = 241, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 59, .pad = 241, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 59, .pad = 234, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 57, .pad = 234, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 57, .pad = 227, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 55, .pad = 227, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 55, .pad = 221, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 54, .pad = 221, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 54, .pad = 215, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 52, .pad = 215, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 52, .pad = 208, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 51, .pad = 208, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 51, .pad = 203, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 49, .pad = 203, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 49, .pad = 197, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 48, .pad = 197, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 48, .pad = 191, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 47, .pad = 191, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 47, .pad = 186, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 45, .pad = 186, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 45, .pad = 181, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 44, .pad = 181, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 44, .pad = 175, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 43, .pad = 175, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 43, .pad = 170, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 42, .pad = 170, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 42, .pad = 166, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 40, .pad = 166, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 40, .pad = 161, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 39, .pad = 161, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 39, .pad = 156, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 38, .pad = 156, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 38, .pad = 152, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 37, .pad = 152, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 37, .pad = 148, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 36, .pad = 148, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 36, .pad = 143, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 35, .pad = 143, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 35, .pad = 139, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 34, .pad = 139, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 34, .pad = 135, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 33, .pad = 135, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 33, .pad = 132, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 32, .pad = 132, .dac = 0, .bb_mult = 64, },
> - ? ? ? { .gm = 255, .pga = 32, .pad = 128, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 248, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 241, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 234, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 227, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 221, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 215, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 208, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 203, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 197, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 191, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 186, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 181, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 175, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 170, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 166, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 161, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 156, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 152, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 148, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 143, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 139, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 135, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 132, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 128, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 124, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 121, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 117, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 114, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 111, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 108, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 104, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 102, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 99, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 96, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 93, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 90, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 88, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 85, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 83, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 81, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 78, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 76, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 74, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 72, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 70, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 68, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 66, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 64, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 64, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 255, .pad = 62, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 248, .pad = 62, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 248, .pad = 60, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 241, .pad = 60, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 241, .pad = 59, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 234, .pad = 59, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 234, .pad = 57, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 227, .pad = 57, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 227, .pad = 55, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 221, .pad = 55, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 221, .pad = 54, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 215, .pad = 54, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 215, .pad = 52, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 208, .pad = 52, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 208, .pad = 51, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 203, .pad = 51, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 203, .pad = 49, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 197, .pad = 49, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 197, .pad = 48, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 191, .pad = 48, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 191, .pad = 47, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 186, .pad = 47, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 186, .pad = 45, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 181, .pad = 45, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 181, .pad = 44, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 175, .pad = 44, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 175, .pad = 43, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 170, .pad = 43, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 170, .pad = 42, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 166, .pad = 42, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 166, .pad = 40, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 161, .pad = 40, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 161, .pad = 39, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 156, .pad = 39, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 156, .pad = 38, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 152, .pad = 38, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 152, .pad = 37, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 148, .pad = 37, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 148, .pad = 36, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 143, .pad = 36, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 143, .pad = 35, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 139, .pad = 35, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 139, .pad = 34, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 135, .pad = 34, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 135, .pad = 33, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 132, .pad = 33, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 132, .pad = 32, .dac = 0, .bb_mult = 64, },
> + ? ? ? { .gm = 255, .pga = 128, .pad = 32, .dac = 0, .bb_mult = 64, },
> };
>
> void lpphy_rev0_1_table_init(struct b43_wldev *dev)
> --
> 1.6.2.4
>
>
>
>



-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From mb at bu3sch.de  Fri Aug 28 22:39:43 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 28 Aug 2009 22:39:43 +0200
Subject: b43: LP-PHY: Fix TX gain tables
In-Reply-To: <4A983FB2.2020509@gmail.com>
References: <4A983FB2.2020509@gmail.com>
Message-ID: <200908282239.45007.mb@bu3sch.de>

On Friday 28 August 2009 22:36:02 G?bor Stefanik wrote:
> The rev1 2GHz and rev2 5GHz gain tables were incorrectly documented
> on the specs originally. Update these gaintables to match the cor-
> rected specs.
> 
> Signed-off-by: G?bor Stefanik <netroller.3d at gmail.com>

ack

-- 
Greetings, Michael.


From netrolller.3d at gmail.com  Sun Aug 30 01:20:48 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 30 Aug 2009 01:20:48 +0200
Subject: [PATCH] b43: LP-PHY: Begin implementing calibration & software RFKILL
	support
Message-ID: <4A99B7D0.7050309@gmail.com>

This implements the following calibration functions:
-Set TX IQCC
-Set TX Power by Index
-PR41573 workaround
-Calc RX IQ Comp
-PHY Cordic
-Run Samples
-Start/Stop TX Tone
-part of PAPD Cal TX Power
-RX I/Q Calibration
-The basic structure of the periodic calibration wrapper

Software RFKILL (required by calibration) is also implemented in
this round.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
Larry, please check if I got the math in "PHY Cordic" right!

 drivers/net/wireless/b43/main.c   |    2 +-
 drivers/net/wireless/b43/main.h   |    2 +
 drivers/net/wireless/b43/phy_lp.c |  684 ++++++++++++++++++++++++++++++++-----
 drivers/net/wireless/b43/phy_lp.h |   11 +-
 4 files changed, 611 insertions(+), 88 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index f2c5b2d..59bee02 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -3345,7 +3345,7 @@ static void b43_op_set_tsf(struct ieee80211_hw *hw, u64 tsf)
 	mutex_unlock(&wl->mutex);
 }
 
-static void b43_put_phy_into_reset(struct b43_wldev *dev)
+void b43_put_phy_into_reset(struct b43_wldev *dev)
 {
 	struct ssb_device *sdev = dev->dev;
 	u32 tmslow;
diff --git a/drivers/net/wireless/b43/main.h b/drivers/net/wireless/b43/main.h
index 0406e06..fdbea9a 100644
--- a/drivers/net/wireless/b43/main.h
+++ b/drivers/net/wireless/b43/main.h
@@ -129,6 +129,8 @@ void b43_wireless_core_reset(struct b43_wldev *dev, u32 flags);
 
 void b43_controller_restart(struct b43_wldev *dev, const char *reason);
 
+void b43_put_phy_into_reset(struct b43_wldev *dev);
+
 #define B43_PS_ENABLED	(1 << 0)	/* Force enable hardware power saving */
 #define B43_PS_DISABLED	(1 << 1)	/* Force disable hardware power saving */
 #define B43_PS_AWAKE	(1 << 2)	/* Force device awake */
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 5fff30a..60e8f6f 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -67,6 +67,7 @@ static void b43_lpphy_op_prepare_structs(struct b43_wldev *dev)
 	struct b43_phy_lp *lpphy = phy->lp;
 
 	memset(lpphy, 0, sizeof(*lpphy));
+	lpphy->antenna = B43_ANTENNA_DEFAULT;
 
 	//TODO
 }
@@ -751,11 +752,17 @@ static void lpphy_clear_deaf(struct b43_wldev *dev, bool user)
 	}
 }
 
+static void lpphy_set_trsw_over(struct b43_wldev *dev, bool tx, bool rx)
+{
+	u16 trsw = (tx << 1) | rx;
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, trsw);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+}
+
 static void lpphy_disable_crs(struct b43_wldev *dev, bool user)
 {
 	lpphy_set_deaf(dev, user);
-	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x1);
-	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+	lpphy_set_trsw_over(dev, false, true);
 	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x4);
 	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFF7);
@@ -790,6 +797,60 @@ static void lpphy_restore_crs(struct b43_wldev *dev, bool user)
 
 struct lpphy_tx_gains { u16 gm, pga, pad, dac; };
 
+static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
+{
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
+	if (dev->phy.rev >= 2) {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
+			b43_phy_mask(dev, B43_PHY_OFDM(0xE5), 0xFFF7);
+		}
+	} else {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
+	}
+}
+
+static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
+{
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
+	if (dev->phy.rev >= 2) {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
+			b43_phy_set(dev, B43_PHY_OFDM(0xE5), 0x8);
+		}
+	} else {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
+	}
+}
+
+static void lpphy_disable_tx_gain_override(struct b43_wldev *dev)
+{
+	if (dev->phy.rev < 2)
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
+	else {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F);
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF);
+	}
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFBF);
+}
+
+static void lpphy_enable_tx_gain_override(struct b43_wldev *dev)
+{
+	if (dev->phy.rev < 2)
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
+	else {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x80);
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x4000);
+	}
+	b43_phy_set(dev, B43_LPPHY_AFE_CTL_OVR, 0x40);
+}
+
 static struct lpphy_tx_gains lpphy_get_tx_gains(struct b43_wldev *dev)
 {
 	struct lpphy_tx_gains gains;
@@ -819,6 +880,17 @@ static void lpphy_set_dac_gain(struct b43_wldev *dev, u16 dac)
 	b43_phy_maskset(dev, B43_LPPHY_AFE_DAC_CTL, 0xF000, ctl);
 }
 
+static u16 lpphy_get_pa_gain(struct b43_wldev *dev)
+{
+	return b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x7F;
+}
+
+static void lpphy_set_pa_gain(struct b43_wldev *dev, u16 gain)
+{
+	b43_phy_maskset(dev, B43_PHY_OFDM(0xFB), 0xE03F, gain << 6);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0xFD), 0x80FF, gain << 8);
+}
+
 static void lpphy_set_tx_gains(struct b43_wldev *dev,
 			       struct lpphy_tx_gains gains)
 {
@@ -829,8 +901,7 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
 		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
 				0xF800, rf_gain);
 	} else {
-		pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x1FC0;
-		pa_gain <<= 2;
+		pa_gain = lpphy_get_pa_gain(dev);
 		b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
 			      (gains.pga << 8) | gains.gm);
 		b43_phy_maskset(dev, B43_PHY_OFDM(0xFB),
@@ -841,13 +912,7 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
 				0x8000, gains.pad | pa_gain);
 	}
 	lpphy_set_dac_gain(dev, gains.dac);
-	if (dev->phy.rev < 2) {
-		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF, 1 << 8);
-	} else {
-		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1 << 7);
-		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1 << 14);
-	}
-	b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFBF, 1 << 6);
+	lpphy_enable_tx_gain_override(dev);
 }
 
 static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
@@ -887,38 +952,6 @@ static void lpphy_rev2plus_set_rx_gain(struct b43_wldev *dev, u32 gain)
 	}
 }
 
-static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
-{
-	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
-	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
-	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
-	if (dev->phy.rev >= 2) {
-		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
-		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
-			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
-			b43_phy_mask(dev, B43_PHY_OFDM(0xE5), 0xFFF7);
-		}
-	} else {
-		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
-	}
-}
-
-static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
-{
-	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
-	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
-	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
-	if (dev->phy.rev >= 2) {
-		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
-		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
-			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
-			b43_phy_set(dev, B43_PHY_OFDM(0xE5), 0x8);
-		}
-	} else {
-		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
-	}
-}
-
 static void lpphy_set_rx_gain(struct b43_wldev *dev, u32 gain)
 {
 	if (dev->phy.rev < 2)
@@ -1003,8 +1036,7 @@ static int lpphy_loopback(struct b43_wldev *dev)
 
 	memset(&iq_est, 0, sizeof(iq_est));
 
-	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x3);
-	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+	lpphy_set_trsw_over(dev, true, true);
 	b43_phy_set(dev, B43_LPPHY_AFE_CTL_OVR, 1);
 	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFFE);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x800);
@@ -1126,7 +1158,7 @@ static void lpphy_set_tx_power_control(struct b43_wldev *dev,
 			b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_NNUM,
 					0x8FFF, ((u16)lpphy->tssi_npt << 16));
 			//TODO Set "TSSI Transmit Count" variable to total transmitted frame count
-			//TODO Disable TX gain override
+			lpphy_disable_tx_gain_override(dev);
 			lpphy->tx_pwr_idx_over = -1;
 		}
 	}
@@ -1312,15 +1344,73 @@ static void lpphy_calibrate_rc(struct b43_wldev *dev)
 	}
 }
 
+static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
+{
+	if (dev->phy.rev >= 2)
+		return; // rev2+ doesn't support antenna diversity
+
+	if (B43_WARN_ON(antenna > B43_ANTENNA_AUTO1))
+		return;
+
+	b43_hf_write(dev, b43_hf_read(dev) & ~B43_HF_ANTDIVHELP);
+
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFD, antenna & 0x2);
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFE, antenna & 0x1);
+
+	b43_hf_write(dev, b43_hf_read(dev) | B43_HF_ANTDIVHELP);
+
+	dev->phy.lp->antenna = antenna;
+}
+
+static void lpphy_set_tx_iqcc(struct b43_wldev *dev, u16 a, u16 b)
+{
+	u16 tmp[2];
+
+	tmp[0] = a;
+	tmp[1] = b;
+	b43_lptab_write_bulk(dev, B43_LPTAB16(0, 80), 2, tmp);
+}
+
 static void lpphy_set_tx_power_by_index(struct b43_wldev *dev, u8 index)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct lpphy_tx_gains gains;
+	u32 iq_comp, tx_gain, coeff, rf_power;
 
 	lpphy->tx_pwr_idx_over = index;
+	lpphy_read_tx_pctl_mode_from_hardware(dev);
 	if (lpphy->txpctl_mode != B43_LPPHY_TXPCTL_OFF)
 		lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_SW);
-
-	//TODO
+	if (dev->phy.rev >= 2) {
+		iq_comp = b43_lptab_read(dev, B43_LPTAB32(7, index + 320));
+		tx_gain = b43_lptab_read(dev, B43_LPTAB32(7, index + 192));
+		gains.pad = (tx_gain >> 16) & 0xFF;
+		gains.gm = tx_gain & 0xFF;
+		gains.pga = (tx_gain >> 8) & 0xFF;
+		gains.dac = (iq_comp >> 28) & 0xFF;
+		lpphy_set_tx_gains(dev, gains);
+	} else {
+		iq_comp = b43_lptab_read(dev, B43_LPTAB32(10, index + 320));
+		tx_gain = b43_lptab_read(dev, B43_LPTAB32(10, index + 192));
+		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+				0xF800, (tx_gain >> 4) & 0x7FFF);
+		lpphy_set_dac_gain(dev, tx_gain & 0x7);
+		lpphy_set_pa_gain(dev, (tx_gain >> 24) & 0x7F);
+	}
+	lpphy_set_bb_mult(dev, (iq_comp >> 20) & 0xFF);
+	lpphy_set_tx_iqcc(dev, (iq_comp >> 10) & 0x3FF, iq_comp & 0x3FF);
+	if (dev->phy.rev >= 2) {
+		coeff = b43_lptab_read(dev, B43_LPTAB32(7, index + 448));
+	} else {
+		coeff = b43_lptab_read(dev, B43_LPTAB32(10, index + 448));
+	}
+	b43_lptab_write(dev, B43_LPTAB16(0, 85), coeff & 0xFFFF);
+	if (dev->phy.rev >= 2) {
+		rf_power = b43_lptab_read(dev, B43_LPTAB32(7, index + 576));
+		b43_phy_maskset(dev, B43_LPPHY_RF_PWR_OVERRIDE, 0xFF00,
+				rf_power & 0xFFFF);//SPEC FIXME mask & set != 0
+	}
+	lpphy_enable_tx_gain_override(dev);
 }
 
 static void lpphy_btcoex_override(struct b43_wldev *dev)
@@ -1329,6 +1419,47 @@ static void lpphy_btcoex_override(struct b43_wldev *dev)
 	b43_write16(dev, B43_MMIO_BTCOEX_TXCTL, 0xFF);
 }
 
+static void b43_lpphy_op_software_rfkill(struct b43_wldev *dev,
+					 bool blocked)
+{
+	//TODO check MAC control register
+	if (blocked) {
+		if (dev->phy.rev >= 2) {
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x83FF);
+			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1F00);
+			b43_phy_mask(dev, B43_LPPHY_AFE_DDFS, 0x80FF);
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xDFFF);
+			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x0808);
+		} else {
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xE0FF);
+			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1F00);
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFCFF);
+			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x0018);
+		}
+	} else {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xE0FF);
+		if (dev->phy.rev >= 2)
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xF7F7);
+		else
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFE7);
+	}
+}
+
+/* This was previously called lpphy_japan_filter */
+static void lpphy_set_analog_filter(struct b43_wldev *dev, int channel)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	u16 tmp = (channel == 14); //SPEC FIXME check japanwidefilter!
+
+	if (dev->phy.rev < 2) { //SPEC FIXME Isn't this rev0/1-specific?
+		b43_phy_maskset(dev, B43_LPPHY_LP_PHY_CTL, 0xFCFF, tmp << 9);
+		if ((dev->phy.rev == 1) && (lpphy->rc_cap))
+			lpphy_set_rc_cap(dev);
+	} else {
+		b43_radio_write(dev, B2063_TX_BB_SP3, 0x3F);
+	}
+}
+
 static void lpphy_pr41573_workaround(struct b43_wldev *dev)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
@@ -1357,28 +1488,438 @@ static void lpphy_pr41573_workaround(struct b43_wldev *dev)
 		b43_lptab_read_bulk(dev, B43_LPTAB32(7, 0x140),
 				    saved_tab_size, saved_tab);
 	}
+	b43_put_phy_into_reset(dev);
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFF8);
+	lpphy_table_init(dev); //FIXME is table init needed?
+	lpphy_baseband_init(dev);
+	b43_lpphy_op_software_rfkill(dev, false);
+	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
+	if (dev->phy.rev < 2) {
+		b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0x140),
+				     saved_tab_size, saved_tab);
+	} else {
+		b43_lptab_write_bulk(dev, B43_LPTAB32(7, 0x140),
+				     saved_tab_size, saved_tab);
+	}
+	b43_write16(dev, B43_MMIO_CHANNEL, lpphy->channel);
+	lpphy->tssi_npt = tssi_npt;
+	lpphy->tssi_idx = tssi_idx;
+	lpphy_set_analog_filter(dev, lpphy->channel);
+	if (tx_pwr_idx_over != -1)
+		lpphy_set_tx_power_by_index(dev, tx_pwr_idx_over);
+	if (lpphy->rc_cap)
+		lpphy_set_rc_cap(dev);
+	b43_lpphy_op_set_rx_antenna(dev, lpphy->antenna);
+	lpphy_set_tx_power_control(dev, txpctl_mode);
+	kfree(saved_tab);
+}
+
+struct lpphy_rx_iq_comp { u8 chan; s8 c1, c0; };
+
+static const struct lpphy_rx_iq_comp lpphy_5354_iq_table[] = {
+	{ .chan = 1, .c1 = -66, .c0 = 15, },
+	{ .chan = 2, .c1 = -66, .c0 = 15, },
+	{ .chan = 3, .c1 = -66, .c0 = 15, },
+	{ .chan = 4, .c1 = -66, .c0 = 15, },
+	{ .chan = 5, .c1 = -66, .c0 = 15, },
+	{ .chan = 6, .c1 = -66, .c0 = 15, },
+	{ .chan = 7, .c1 = -66, .c0 = 14, },
+	{ .chan = 8, .c1 = -66, .c0 = 14, },
+	{ .chan = 9, .c1 = -66, .c0 = 14, },
+	{ .chan = 10, .c1 = -66, .c0 = 14, },
+	{ .chan = 11, .c1 = -66, .c0 = 14, },
+	{ .chan = 12, .c1 = -66, .c0 = 13, },
+	{ .chan = 13, .c1 = -66, .c0 = 13, },
+	{ .chan = 14, .c1 = -66, .c0 = 13, },
+};
+
+static const struct lpphy_rx_iq_comp lpphy_rev0_1_iq_table[] = {
+	{ .chan = 1, .c1 = -64, .c0 = 13, },
+	{ .chan = 2, .c1 = -64, .c0 = 13, },
+	{ .chan = 3, .c1 = -64, .c0 = 13, },
+	{ .chan = 4, .c1 = -64, .c0 = 13, },
+	{ .chan = 5, .c1 = -64, .c0 = 12, },
+	{ .chan = 6, .c1 = -64, .c0 = 12, },
+	{ .chan = 7, .c1 = -64, .c0 = 12, },
+	{ .chan = 8, .c1 = -64, .c0 = 12, },
+	{ .chan = 9, .c1 = -64, .c0 = 12, },
+	{ .chan = 10, .c1 = -64, .c0 = 11, },
+	{ .chan = 11, .c1 = -64, .c0 = 11, },
+	{ .chan = 12, .c1 = -64, .c0 = 11, },
+	{ .chan = 13, .c1 = -64, .c0 = 11, },
+	{ .chan = 14, .c1 = -64, .c0 = 10, },
+	{ .chan = 34, .c1 = -62, .c0 = 24, },
+	{ .chan = 38, .c1 = -62, .c0 = 24, },
+	{ .chan = 42, .c1 = -62, .c0 = 24, },
+	{ .chan = 46, .c1 = -62, .c0 = 23, },
+	{ .chan = 36, .c1 = -62, .c0 = 24, },
+	{ .chan = 40, .c1 = -62, .c0 = 24, },
+	{ .chan = 44, .c1 = -62, .c0 = 23, },
+	{ .chan = 48, .c1 = -62, .c0 = 23, },
+	{ .chan = 52, .c1 = -62, .c0 = 23, },
+	{ .chan = 56, .c1 = -62, .c0 = 22, },
+	{ .chan = 60, .c1 = -62, .c0 = 22, },
+	{ .chan = 64, .c1 = -62, .c0 = 22, },
+	{ .chan = 100, .c1 = -62, .c0 = 16, },
+	{ .chan = 104, .c1 = -62, .c0 = 16, },
+	{ .chan = 108, .c1 = -62, .c0 = 15, },
+	{ .chan = 112, .c1 = -62, .c0 = 14, },
+	{ .chan = 116, .c1 = -62, .c0 = 14, },
+	{ .chan = 120, .c1 = -62, .c0 = 13, },
+	{ .chan = 124, .c1 = -62, .c0 = 12, },
+	{ .chan = 128, .c1 = -62, .c0 = 12, },
+	{ .chan = 132, .c1 = -62, .c0 = 12, },
+	{ .chan = 136, .c1 = -62, .c0 = 11, },
+	{ .chan = 140, .c1 = -62, .c0 = 10, },
+	{ .chan = 149, .c1 = -61, .c0 = 9, },
+	{ .chan = 153, .c1 = -61, .c0 = 9, },
+	{ .chan = 157, .c1 = -61, .c0 = 9, },
+	{ .chan = 161, .c1 = -61, .c0 = 8, },
+	{ .chan = 165, .c1 = -61, .c0 = 8, },
+	{ .chan = 184, .c1 = -62, .c0 = 25, },
+	{ .chan = 188, .c1 = -62, .c0 = 25, },
+	{ .chan = 192, .c1 = -62, .c0 = 25, },
+	{ .chan = 196, .c1 = -62, .c0 = 25, },
+	{ .chan = 200, .c1 = -62, .c0 = 25, },
+	{ .chan = 204, .c1 = -62, .c0 = 25, },
+	{ .chan = 208, .c1 = -62, .c0 = 25, },
+	{ .chan = 212, .c1 = -62, .c0 = 25, },
+	{ .chan = 216, .c1 = -62, .c0 = 26, },
+};
+
+static const struct lpphy_rx_iq_comp lpphy_rev2plus_iq_comp = {
+	.chan = 0,
+	.c1 = -64,
+	.c0 = 0,
+};
+
+static u8 lpphy_nbits(s32 val)
+{
+	u32 tmp = abs(val);
+	u8 nbits = 0;
+
+	while (tmp != 0) {
+		nbits++;
+		tmp >>= 1;
+	}
+
+	return nbits;
+}
+
+static int lpphy_calc_rx_iq_comp(struct b43_wldev *dev, u16 samples)
+{
+	struct lpphy_iq_est iq_est;
+	u16 c0, c1;
+	int prod, ipwr, qpwr, prod_msb, q_msb, tmp1, tmp2, tmp3, tmp4, ret;
+
+	c1 = b43_phy_read(dev, B43_LPPHY_RX_COMP_COEFF_S);
+	c0 = c1 >> 8;
+	c1 |= 0xFF;
+
+	b43_phy_maskset(dev, B43_LPPHY_RX_COMP_COEFF_S, 0xFF00, 0x00C0);
+	b43_phy_mask(dev, B43_LPPHY_RX_COMP_COEFF_S, 0x00FF);
+
+	ret = lpphy_rx_iq_est(dev, samples, 32, &iq_est);
+	if (!ret)
+		goto out;
+
+	prod = iq_est.iq_prod;
+	ipwr = iq_est.i_pwr;
+	qpwr = iq_est.q_pwr;
+
+	if (ipwr + qpwr < 2) {
+		ret = 0;
+		goto out;
+	}
+
+	prod_msb = lpphy_nbits(prod);
+	q_msb = lpphy_nbits(qpwr);
+	tmp1 = prod_msb - 20;
+
+	if (tmp1 >= 0) {
+		tmp3 = ((prod << (30 - prod_msb)) + (ipwr >> (1 + tmp1))) /
+			(ipwr >> tmp1);
+	} else {
+		tmp3 = ((prod << (30 - prod_msb)) + (ipwr << (-1 - tmp1))) /
+			(ipwr << -tmp1);
+	}
+
+	tmp2 = q_msb - 11;
+
+	if (tmp2 >= 0)
+		tmp4 = (qpwr << (31 - q_msb)) / (ipwr >> tmp2);
+	else
+		tmp4 = (qpwr << (31 - q_msb)) / (ipwr << -tmp2);
+
+	tmp4 -= tmp3 * tmp3;
+	tmp4 = -int_sqrt(tmp4);
+
+	c0 = tmp3 >> 3;
+	c1 = tmp4 >> 4;
+
+out:
+	b43_phy_maskset(dev, B43_LPPHY_RX_COMP_COEFF_S, 0xFF00, c1);
+	b43_phy_maskset(dev, B43_LPPHY_RX_COMP_COEFF_S, 0x00FF, c0 << 8);
+	return ret;
+}
+
+/* Complex number using 2 32-bit signed integers */
+typedef struct {s32 i, q;} lpphy_c32;
+
+static lpphy_c32 lpphy_cordic(int theta)
+{
+	u32 arctg[] = { 2949120, 1740967, 919879, 466945, 234379, 117304,
+		      58666, 29335, 14668, 7334, 3667, 1833, 917, 458,
+		      229, 115, 57, 29, };
+	int i, tmp, signx = 1, angle = 0;
+	lpphy_c32 ret = { .i = 39797, .q = 0, };
+
+	theta = clamp_t(int, theta, -180, 180);
+
+	if (theta > 90) {
+		theta -= 180;
+		signx = -1;
+	} else if (theta < -90) {
+		theta += 180;
+		signx = -1;
+	}
+
+	for (i = 0; i <= 17; i++) {
+		if (theta > angle) {
+			tmp = ret.i - (ret.q >> i);
+			ret.q += ret.i >> i;
+			ret.i = tmp + arctg[i];
+		} else {
+			tmp = ret.i + (ret.q >> i);
+			ret.q -= ret.i >> i;
+			ret.i = tmp - arctg[i];
+		}
+	}
+
+	ret.i *= signx;
+	ret.q *= signx;
+
+	return ret;
+}
+
+static void lpphy_run_samples(struct b43_wldev *dev, u16 samples, u16 loops,
+			      u16 wait)
+{
+	b43_phy_maskset(dev, B43_LPPHY_SMPL_PLAY_BUFFER_CTL,
+			0xFFC0, samples - 1);
+	if (loops != 0xFFFF)
+		loops--;
+	b43_phy_maskset(dev, B43_LPPHY_SMPL_PLAY_COUNT, 0xF000, loops);
+	b43_phy_maskset(dev, B43_LPPHY_SMPL_PLAY_BUFFER_CTL, 0x3F, wait << 6);
+	b43_phy_set(dev, B43_LPPHY_A_PHY_CTL_ADDR, 0x1);
+}
+
+//SPEC FIXME what does a negative freq mean?
+static void lpphy_start_tx_tone(struct b43_wldev *dev, s32 freq, u16 max)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	u16 buf[64];
+	int i, samples, angle = 0, rotation = (9 * freq) / 500;
+	lpphy_c32 sample;
+
+	lpphy->tx_tone_freq = freq;
+
+	if (freq) {
+		/* Find i for which abs(freq) integrally divides 20000 * i */
+		for (i = 1; samples * abs(freq) != 20000 * i; i++) {
+			samples = (20000 * i) / abs(freq);
+			if(B43_WARN_ON(samples > 63))
+				return;
+		}
+	} else {
+		samples = 2;
+	}
+
+	for (i = 0; i < samples; i++) {
+		sample = lpphy_cordic(angle);
+		angle += rotation;
+		buf[i] = ((sample.i * max) & 0xFF) << 8;
+		buf[i] |= (sample.q * max) & 0xFF;
+	}
+
+	b43_lptab_write_bulk(dev, B43_LPTAB16(5, 0), samples, buf);
+
+	lpphy_run_samples(dev, samples, 0xFFFF, 0);
+}
+
+static void lpphy_stop_tx_tone(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	int i;
+
+	lpphy->tx_tone_freq = 0;
+
+	b43_phy_mask(dev, B43_LPPHY_SMPL_PLAY_COUNT, 0xF000);
+	for (i = 0; i < 31; i++) {
+		if (!(b43_phy_read(dev, B43_LPPHY_A_PHY_CTL_ADDR) & 0x1))
+			break;
+		udelay(100);
+	}
+}
+
+
+static void lpphy_papd_cal(struct b43_wldev *dev, struct lpphy_tx_gains gains,
+			   int mode, bool useindex, u8 index)
+{
 	//TODO
+}
 
-	kfree(saved_tab);
+static void lpphy_papd_cal_txpwr(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct ssb_bus *bus = dev->dev->bus;
+	struct lpphy_tx_gains gains, oldgains;
+	int old_txpctl, old_afe_ovr, old_rf, old_bbmult;
+
+	lpphy_read_tx_pctl_mode_from_hardware(dev);
+	old_txpctl = lpphy->txpctl_mode;
+	old_afe_ovr = b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40;
+	if (old_afe_ovr)
+		oldgains = lpphy_get_tx_gains(dev);
+	old_rf = b43_phy_read(dev, B43_LPPHY_RF_PWR_OVERRIDE) & 0xFF;
+	old_bbmult = lpphy_get_bb_mult(dev);
+
+	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
+
+	if (bus->chip_id == 0x4325 && bus->chip_rev == 0)
+		lpphy_papd_cal(dev, gains, 0, 1, 30);
+	else
+		lpphy_papd_cal(dev, gains, 0, 1, 65);
+
+	if (old_afe_ovr)
+		lpphy_set_tx_gains(dev, oldgains);
+	lpphy_set_bb_mult(dev, old_bbmult);
+	lpphy_set_tx_power_control(dev, old_txpctl);
+	b43_phy_maskset(dev, B43_LPPHY_RF_PWR_OVERRIDE, 0xFF00, old_rf);
+}
+
+static int lpphy_rx_iq_cal(struct b43_wldev *dev, bool noise, bool tx,
+			    bool rx, bool pa, struct lpphy_tx_gains *gains)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct ssb_bus *bus = dev->dev->bus;
+	const struct lpphy_rx_iq_comp *iqcomp = NULL;
+	struct lpphy_tx_gains nogains, oldgains;
+	u16 tmp;
+	int i, ret;
+
+	memset(&nogains, 0, sizeof(nogains));
+	memset(&oldgains, 0, sizeof(oldgains));
+
+	if (bus->chip_id == 0x5354) {
+		for (i = 0; i < ARRAY_SIZE(lpphy_5354_iq_table); i++) {
+			if (lpphy_5354_iq_table[i].chan == lpphy->channel) {
+				iqcomp = &lpphy_5354_iq_table[i];
+			}
+		}
+	} else if (dev->phy.rev >= 2) {
+		iqcomp = &lpphy_rev2plus_iq_comp;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(lpphy_rev0_1_iq_table); i++) {
+			if (lpphy_rev0_1_iq_table[i].chan == lpphy->channel) {
+				iqcomp = &lpphy_rev0_1_iq_table[i];
+			}
+		}
+	}
+
+	if (B43_WARN_ON(!iqcomp))
+		return 0;
+
+	b43_phy_maskset(dev, B43_LPPHY_RX_COMP_COEFF_S, 0xFF00, iqcomp->c1);
+	b43_phy_maskset(dev, B43_LPPHY_RX_COMP_COEFF_S,
+			0x00FF, iqcomp->c0 << 8);
+
+	if (noise) {
+		tx = true;
+		rx = false;
+		pa = false;
+	}
+
+	lpphy_set_trsw_over(dev, tx, rx);
+
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0,
+				0xFFF7, pa << 3);
+	} else {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x20);
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0,
+				0xFFDF, pa << 5);
+	}
+
+	tmp = b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40;
+
+	if (noise)
+		lpphy_set_rx_gain(dev, 0x2D5D);
+	else {
+		if (tmp)
+			oldgains = lpphy_get_tx_gains(dev);
+		if (!gains)
+			gains = &nogains;
+		lpphy_set_tx_gains(dev, *gains);
+	}
+
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFFE);
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFFE);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x800);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x800);
+	lpphy_set_deaf(dev, false);
+	if (noise)
+		ret = lpphy_calc_rx_iq_comp(dev, 0xFFF0);
+	else {
+		lpphy_start_tx_tone(dev, 4000, 100);
+		ret = lpphy_calc_rx_iq_comp(dev, 0x4000);
+		lpphy_stop_tx_tone(dev);
+	}
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFC);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFF7);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFDF);
+	if (!noise) {
+		if (tmp)
+			lpphy_set_tx_gains(dev, oldgains);
+		else
+			lpphy_disable_tx_gain_override(dev);
+	}
+	lpphy_disable_rx_gain_override(dev);
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFFE);
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xF7FF);
+	return ret;
 }
 
 static void lpphy_calibration(struct b43_wldev *dev)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
 	enum b43_lpphy_txpctl_mode saved_pctl_mode;
+	bool full_cal = false;
+
+	if (lpphy->full_calib_chan != lpphy->channel) {
+		full_cal = true;
+		lpphy->full_calib_chan = lpphy->channel;
+	}
 
 	b43_mac_suspend(dev);
 
 	lpphy_btcoex_override(dev);
+	if (dev->phy.rev >= 2)
+		lpphy_save_dig_flt_state(dev);
 	lpphy_read_tx_pctl_mode_from_hardware(dev);
 	saved_pctl_mode = lpphy->txpctl_mode;
 	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
 	//TODO Perform transmit power table I/Q LO calibration
 	if ((dev->phy.rev == 0) && (saved_pctl_mode != B43_LPPHY_TXPCTL_OFF))
 		lpphy_pr41573_workaround(dev);
-	//TODO If a full calibration has not been performed on this channel yet, perform PAPD TX-power calibration
+	if ((dev->phy.rev >= 2) && full_cal) {
+		lpphy_papd_cal_txpwr(dev);
+	}
 	lpphy_set_tx_power_control(dev, saved_pctl_mode);
-	//TODO Perform I/Q calibration with a single control value set
+	if (dev->phy.rev >= 2)
+		lpphy_restore_dig_flt_state(dev);
+	lpphy_rx_iq_cal(dev, true, true, false, false, NULL);
 
 	b43_mac_enable(dev);
 }
@@ -1532,12 +2073,6 @@ static void b43_lpphy_op_radio_write(struct b43_wldev *dev, u16 reg, u16 value)
 	b43_write16(dev, B43_MMIO_RADIO_DATA_LOW, value);
 }
 
-static void b43_lpphy_op_software_rfkill(struct b43_wldev *dev,
-					 bool blocked)
-{
-	//TODO
-}
-
 struct b206x_channel {
 	u8 channel;
 	u16 freq;
@@ -2003,22 +2538,6 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
 	return err;
 }
 
-
-/* This was previously called lpphy_japan_filter */
-static void lpphy_set_analog_filter(struct b43_wldev *dev, int channel)
-{
-	struct b43_phy_lp *lpphy = dev->phy.lp;
-	u16 tmp = (channel == 14); //SPEC FIXME check japanwidefilter!
-
-	if (dev->phy.rev < 2) { //SPEC FIXME Isn't this rev0/1-specific?
-		b43_phy_maskset(dev, B43_LPPHY_LP_PHY_CTL, 0xFCFF, tmp << 9);
-		if ((dev->phy.rev == 1) && (lpphy->rc_cap))
-			lpphy_set_rc_cap(dev);
-	} else {
-		b43_radio_write(dev, B2063_TX_BB_SP3, 0x3F);
-	}
-}
-
 static void lpphy_b2063_vco_calib(struct b43_wldev *dev)
 {
 	u16 tmp;
@@ -2203,18 +2722,6 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
 	return 0;
 }
 
-static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
-{
-	if (dev->phy.rev >= 2)
-		return; // rev2+ doesn't support antenna diversity
-
-	if (B43_WARN_ON(antenna > B43_ANTENNA_AUTO1))
-		return;
-
-	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFD, antenna & 0x2);
-	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFE, antenna & 0x1);
-}
-
 static void b43_lpphy_op_adjust_txpower(struct b43_wldev *dev)
 {
 	//TODO
@@ -2227,6 +2734,11 @@ static enum b43_txpwr_result b43_lpphy_op_recalc_txpower(struct b43_wldev *dev,
 	return B43_TXPWR_RES_DONE;
 }
 
+static void b43_lpphy_op_pwork_15sec(struct b43_wldev *dev)
+{
+	//TODO
+}
+
 const struct b43_phy_operations b43_phyops_lp = {
 	.allocate		= b43_lpphy_op_allocate,
 	.free			= b43_lpphy_op_free,
@@ -2244,4 +2756,6 @@ const struct b43_phy_operations b43_phyops_lp = {
 	.set_rx_antenna		= b43_lpphy_op_set_rx_antenna,
 	.recalc_txpower		= b43_lpphy_op_recalc_txpower,
 	.adjust_txpower		= b43_lpphy_op_adjust_txpower,
+	.pwork_15sec		= b43_lpphy_op_pwork_15sec,
+	.pwork_60sec		= lpphy_calibration,
 };
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index c3232c1..62737f7 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -286,6 +286,7 @@
 #define B43_LPPHY_TR_LOOKUP_6			B43_PHY_OFDM(0xC8) /* TR Lookup 6 */
 #define B43_LPPHY_TR_LOOKUP_7			B43_PHY_OFDM(0xC9) /* TR Lookup 7 */
 #define B43_LPPHY_TR_LOOKUP_8			B43_PHY_OFDM(0xCA) /* TR Lookup 8 */
+#define B43_LPPHY_RF_PWR_OVERRIDE		B43_PHY_OFDM(0xD3) /* RF power override */
 
 
 
@@ -871,12 +872,12 @@ struct b43_phy_lp {
 	u8 rssi_gs;
 
 	/* RC cap */
-	u8 rc_cap; /* FIXME initial value? */
+	u8 rc_cap;
 	/* BX arch */
 	u8 bx_arch;
 
 	/* Full calibration channel */
-	u8 full_calib_chan; /* FIXME initial value? */
+	u8 full_calib_chan;
 
 	/* Transmit iqlocal best coeffs */
 	bool tx_iqloc_best_coeffs_valid;
@@ -891,6 +892,12 @@ struct b43_phy_lp {
 
 	/* The channel we are tuned to */
 	u8 channel;
+
+	/* The active antenna diversity mode */
+	int antenna;
+
+	/* Frequency of the active TX tone */
+	int tx_tone_freq;
 };
 
 enum tssi_mux_mode {
-- 
1.6.2.4





From netrolller.3d at gmail.com  Sun Aug 30 02:15:55 2009
From: netrolller.3d at gmail.com (=?UTF-8?B?R8OhYm9yIFN0ZWZhbmlr?=)
Date: Sun, 30 Aug 2009 02:15:55 +0200
Subject: [PATCH v2] b43: LP-PHY: Begin implementing calibration & software
	RFKILL support
Message-ID: <4A99C4BB.7080806@gmail.com>

This implements the following calibration functions:
-Set TX IQCC
-Set TX Power by Index
-PR41573 workaround
-Calc RX IQ Comp
-PHY Cordic
-Run Samples
-Start/Stop TX Tone
-part of PAPD Cal TX Power
-RX I/Q Calibration
-The basic structure of the periodic calibration wrapper

Software RFKILL (required by calibration) is also implemented in
this round.

Signed-off-by: G?bor Stefanik <netrolller.3d at gmail.com>
---
V2: Fix a mistake I made in the PHY Cordic routine.

 drivers/net/wireless/b43/main.c   |    2 +-
 drivers/net/wireless/b43/main.h   |    2 +
 drivers/net/wireless/b43/phy_lp.c |  686 ++++++++++++++++++++++++++++++++-----
 drivers/net/wireless/b43/phy_lp.h |   11 +-
 4 files changed, 613 insertions(+), 88 deletions(-)

diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index f2c5b2d..59bee02 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -3345,7 +3345,7 @@ static void b43_op_set_tsf(struct ieee80211_hw *hw, u64 tsf)
 	mutex_unlock(&wl->mutex);
 }
 
-static void b43_put_phy_into_reset(struct b43_wldev *dev)
+void b43_put_phy_into_reset(struct b43_wldev *dev)
 {
 	struct ssb_device *sdev = dev->dev;
 	u32 tmslow;
diff --git a/drivers/net/wireless/b43/main.h b/drivers/net/wireless/b43/main.h
index 0406e06..fdbea9a 100644
--- a/drivers/net/wireless/b43/main.h
+++ b/drivers/net/wireless/b43/main.h
@@ -129,6 +129,8 @@ void b43_wireless_core_reset(struct b43_wldev *dev, u32 flags);
 
 void b43_controller_restart(struct b43_wldev *dev, const char *reason);
 
+void b43_put_phy_into_reset(struct b43_wldev *dev);
+
 #define B43_PS_ENABLED	(1 << 0)	/* Force enable hardware power saving */
 #define B43_PS_DISABLED	(1 << 1)	/* Force disable hardware power saving */
 #define B43_PS_AWAKE	(1 << 2)	/* Force device awake */
diff --git a/drivers/net/wireless/b43/phy_lp.c b/drivers/net/wireless/b43/phy_lp.c
index 5fff30a..c13385b 100644
--- a/drivers/net/wireless/b43/phy_lp.c
+++ b/drivers/net/wireless/b43/phy_lp.c
@@ -67,6 +67,7 @@ static void b43_lpphy_op_prepare_structs(struct b43_wldev *dev)
 	struct b43_phy_lp *lpphy = phy->lp;
 
 	memset(lpphy, 0, sizeof(*lpphy));
+	lpphy->antenna = B43_ANTENNA_DEFAULT;
 
 	//TODO
 }
@@ -751,11 +752,17 @@ static void lpphy_clear_deaf(struct b43_wldev *dev, bool user)
 	}
 }
 
+static void lpphy_set_trsw_over(struct b43_wldev *dev, bool tx, bool rx)
+{
+	u16 trsw = (tx << 1) | rx;
+	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, trsw);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+}
+
 static void lpphy_disable_crs(struct b43_wldev *dev, bool user)
 {
 	lpphy_set_deaf(dev, user);
-	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x1);
-	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+	lpphy_set_trsw_over(dev, false, true);
 	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFB);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x4);
 	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFF7);
@@ -790,6 +797,60 @@ static void lpphy_restore_crs(struct b43_wldev *dev, bool user)
 
 struct lpphy_tx_gains { u16 gm, pga, pad, dac; };
 
+static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
+{
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
+	if (dev->phy.rev >= 2) {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
+			b43_phy_mask(dev, B43_PHY_OFDM(0xE5), 0xFFF7);
+		}
+	} else {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
+	}
+}
+
+static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
+{
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
+	if (dev->phy.rev >= 2) {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
+		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
+			b43_phy_set(dev, B43_PHY_OFDM(0xE5), 0x8);
+		}
+	} else {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
+	}
+}
+
+static void lpphy_disable_tx_gain_override(struct b43_wldev *dev)
+{
+	if (dev->phy.rev < 2)
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
+	else {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F);
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF);
+	}
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFBF);
+}
+
+static void lpphy_enable_tx_gain_override(struct b43_wldev *dev)
+{
+	if (dev->phy.rev < 2)
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
+	else {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x80);
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x4000);
+	}
+	b43_phy_set(dev, B43_LPPHY_AFE_CTL_OVR, 0x40);
+}
+
 static struct lpphy_tx_gains lpphy_get_tx_gains(struct b43_wldev *dev)
 {
 	struct lpphy_tx_gains gains;
@@ -819,6 +880,17 @@ static void lpphy_set_dac_gain(struct b43_wldev *dev, u16 dac)
 	b43_phy_maskset(dev, B43_LPPHY_AFE_DAC_CTL, 0xF000, ctl);
 }
 
+static u16 lpphy_get_pa_gain(struct b43_wldev *dev)
+{
+	return b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x7F;
+}
+
+static void lpphy_set_pa_gain(struct b43_wldev *dev, u16 gain)
+{
+	b43_phy_maskset(dev, B43_PHY_OFDM(0xFB), 0xE03F, gain << 6);
+	b43_phy_maskset(dev, B43_PHY_OFDM(0xFD), 0x80FF, gain << 8);
+}
+
 static void lpphy_set_tx_gains(struct b43_wldev *dev,
 			       struct lpphy_tx_gains gains)
 {
@@ -829,8 +901,7 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
 		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
 				0xF800, rf_gain);
 	} else {
-		pa_gain = b43_phy_read(dev, B43_PHY_OFDM(0xFB)) & 0x1FC0;
-		pa_gain <<= 2;
+		pa_gain = lpphy_get_pa_gain(dev);
 		b43_phy_write(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
 			      (gains.pga << 8) | gains.gm);
 		b43_phy_maskset(dev, B43_PHY_OFDM(0xFB),
@@ -841,13 +912,7 @@ static void lpphy_set_tx_gains(struct b43_wldev *dev,
 				0x8000, gains.pad | pa_gain);
 	}
 	lpphy_set_dac_gain(dev, gains.dac);
-	if (dev->phy.rev < 2) {
-		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF, 1 << 8);
-	} else {
-		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFF7F, 1 << 7);
-		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_2, 0xBFFF, 1 << 14);
-	}
-	b43_phy_maskset(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFBF, 1 << 6);
+	lpphy_enable_tx_gain_override(dev);
 }
 
 static void lpphy_rev0_1_set_rx_gain(struct b43_wldev *dev, u32 gain)
@@ -887,38 +952,6 @@ static void lpphy_rev2plus_set_rx_gain(struct b43_wldev *dev, u32 gain)
 	}
 }
 
-static void lpphy_disable_rx_gain_override(struct b43_wldev *dev)
-{
-	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFE);
-	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFEF);
-	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFBF);
-	if (dev->phy.rev >= 2) {
-		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFEFF);
-		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
-			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFBFF);
-			b43_phy_mask(dev, B43_PHY_OFDM(0xE5), 0xFFF7);
-		}
-	} else {
-		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFDFF);
-	}
-}
-
-static void lpphy_enable_rx_gain_override(struct b43_wldev *dev)
-{
-	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1);
-	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x10);
-	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x40);
-	if (dev->phy.rev >= 2) {
-		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x100);
-		if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
-			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x400);
-			b43_phy_set(dev, B43_PHY_OFDM(0xE5), 0x8);
-		}
-	} else {
-		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x200);
-	}
-}
-
 static void lpphy_set_rx_gain(struct b43_wldev *dev, u32 gain)
 {
 	if (dev->phy.rev < 2)
@@ -1003,8 +1036,7 @@ static int lpphy_loopback(struct b43_wldev *dev)
 
 	memset(&iq_est, 0, sizeof(iq_est));
 
-	b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xFFFC, 0x3);
-	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x3);
+	lpphy_set_trsw_over(dev, true, true);
 	b43_phy_set(dev, B43_LPPHY_AFE_CTL_OVR, 1);
 	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFFE);
 	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x800);
@@ -1126,7 +1158,7 @@ static void lpphy_set_tx_power_control(struct b43_wldev *dev,
 			b43_phy_maskset(dev, B43_LPPHY_TX_PWR_CTL_NNUM,
 					0x8FFF, ((u16)lpphy->tssi_npt << 16));
 			//TODO Set "TSSI Transmit Count" variable to total transmitted frame count
-			//TODO Disable TX gain override
+			lpphy_disable_tx_gain_override(dev);
 			lpphy->tx_pwr_idx_over = -1;
 		}
 	}
@@ -1312,15 +1344,73 @@ static void lpphy_calibrate_rc(struct b43_wldev *dev)
 	}
 }
 
+static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
+{
+	if (dev->phy.rev >= 2)
+		return; // rev2+ doesn't support antenna diversity
+
+	if (B43_WARN_ON(antenna > B43_ANTENNA_AUTO1))
+		return;
+
+	b43_hf_write(dev, b43_hf_read(dev) & ~B43_HF_ANTDIVHELP);
+
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFD, antenna & 0x2);
+	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFE, antenna & 0x1);
+
+	b43_hf_write(dev, b43_hf_read(dev) | B43_HF_ANTDIVHELP);
+
+	dev->phy.lp->antenna = antenna;
+}
+
+static void lpphy_set_tx_iqcc(struct b43_wldev *dev, u16 a, u16 b)
+{
+	u16 tmp[2];
+
+	tmp[0] = a;
+	tmp[1] = b;
+	b43_lptab_write_bulk(dev, B43_LPTAB16(0, 80), 2, tmp);
+}
+
 static void lpphy_set_tx_power_by_index(struct b43_wldev *dev, u8 index)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct lpphy_tx_gains gains;
+	u32 iq_comp, tx_gain, coeff, rf_power;
 
 	lpphy->tx_pwr_idx_over = index;
+	lpphy_read_tx_pctl_mode_from_hardware(dev);
 	if (lpphy->txpctl_mode != B43_LPPHY_TXPCTL_OFF)
 		lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_SW);
-
-	//TODO
+	if (dev->phy.rev >= 2) {
+		iq_comp = b43_lptab_read(dev, B43_LPTAB32(7, index + 320));
+		tx_gain = b43_lptab_read(dev, B43_LPTAB32(7, index + 192));
+		gains.pad = (tx_gain >> 16) & 0xFF;
+		gains.gm = tx_gain & 0xFF;
+		gains.pga = (tx_gain >> 8) & 0xFF;
+		gains.dac = (iq_comp >> 28) & 0xFF;
+		lpphy_set_tx_gains(dev, gains);
+	} else {
+		iq_comp = b43_lptab_read(dev, B43_LPTAB32(10, index + 320));
+		tx_gain = b43_lptab_read(dev, B43_LPTAB32(10, index + 192));
+		b43_phy_maskset(dev, B43_LPPHY_TX_GAIN_CTL_OVERRIDE_VAL,
+				0xF800, (tx_gain >> 4) & 0x7FFF);
+		lpphy_set_dac_gain(dev, tx_gain & 0x7);
+		lpphy_set_pa_gain(dev, (tx_gain >> 24) & 0x7F);
+	}
+	lpphy_set_bb_mult(dev, (iq_comp >> 20) & 0xFF);
+	lpphy_set_tx_iqcc(dev, (iq_comp >> 10) & 0x3FF, iq_comp & 0x3FF);
+	if (dev->phy.rev >= 2) {
+		coeff = b43_lptab_read(dev, B43_LPTAB32(7, index + 448));
+	} else {
+		coeff = b43_lptab_read(dev, B43_LPTAB32(10, index + 448));
+	}
+	b43_lptab_write(dev, B43_LPTAB16(0, 85), coeff & 0xFFFF);
+	if (dev->phy.rev >= 2) {
+		rf_power = b43_lptab_read(dev, B43_LPTAB32(7, index + 576));
+		b43_phy_maskset(dev, B43_LPPHY_RF_PWR_OVERRIDE, 0xFF00,
+				rf_power & 0xFFFF);//SPEC FIXME mask & set != 0
+	}
+	lpphy_enable_tx_gain_override(dev);
 }
 
 static void lpphy_btcoex_override(struct b43_wldev *dev)
@@ -1329,6 +1419,47 @@ static void lpphy_btcoex_override(struct b43_wldev *dev)
 	b43_write16(dev, B43_MMIO_BTCOEX_TXCTL, 0xFF);
 }
 
+static void b43_lpphy_op_software_rfkill(struct b43_wldev *dev,
+					 bool blocked)
+{
+	//TODO check MAC control register
+	if (blocked) {
+		if (dev->phy.rev >= 2) {
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x83FF);
+			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1F00);
+			b43_phy_mask(dev, B43_LPPHY_AFE_DDFS, 0x80FF);
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xDFFF);
+			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x0808);
+		} else {
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0xE0FF);
+			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x1F00);
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2_VAL, 0xFCFF);
+			b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_2, 0x0018);
+		}
+	} else {
+		b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xE0FF);
+		if (dev->phy.rev >= 2)
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xF7F7);
+		else
+			b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_2, 0xFFE7);
+	}
+}
+
+/* This was previously called lpphy_japan_filter */
+static void lpphy_set_analog_filter(struct b43_wldev *dev, int channel)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	u16 tmp = (channel == 14); //SPEC FIXME check japanwidefilter!
+
+	if (dev->phy.rev < 2) { //SPEC FIXME Isn't this rev0/1-specific?
+		b43_phy_maskset(dev, B43_LPPHY_LP_PHY_CTL, 0xFCFF, tmp << 9);
+		if ((dev->phy.rev == 1) && (lpphy->rc_cap))
+			lpphy_set_rc_cap(dev);
+	} else {
+		b43_radio_write(dev, B2063_TX_BB_SP3, 0x3F);
+	}
+}
+
 static void lpphy_pr41573_workaround(struct b43_wldev *dev)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
@@ -1357,28 +1488,440 @@ static void lpphy_pr41573_workaround(struct b43_wldev *dev)
 		b43_lptab_read_bulk(dev, B43_LPTAB32(7, 0x140),
 				    saved_tab_size, saved_tab);
 	}
+	b43_put_phy_into_reset(dev);
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFF8);
+	lpphy_table_init(dev); //FIXME is table init needed?
+	lpphy_baseband_init(dev);
+	b43_lpphy_op_software_rfkill(dev, false);
+	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
+	if (dev->phy.rev < 2) {
+		b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0x140),
+				     saved_tab_size, saved_tab);
+	} else {
+		b43_lptab_write_bulk(dev, B43_LPTAB32(7, 0x140),
+				     saved_tab_size, saved_tab);
+	}
+	b43_write16(dev, B43_MMIO_CHANNEL, lpphy->channel);
+	lpphy->tssi_npt = tssi_npt;
+	lpphy->tssi_idx = tssi_idx;
+	lpphy_set_analog_filter(dev, lpphy->channel);
+	if (tx_pwr_idx_over != -1)
+		lpphy_set_tx_power_by_index(dev, tx_pwr_idx_over);
+	if (lpphy->rc_cap)
+		lpphy_set_rc_cap(dev);
+	b43_lpphy_op_set_rx_antenna(dev, lpphy->antenna);
+	lpphy_set_tx_power_control(dev, txpctl_mode);
+	kfree(saved_tab);
+}
+
+struct lpphy_rx_iq_comp { u8 chan; s8 c1, c0; };
+
+static const struct lpphy_rx_iq_comp lpphy_5354_iq_table[] = {
+	{ .chan = 1, .c1 = -66, .c0 = 15, },
+	{ .chan = 2, .c1 = -66, .c0 = 15, },
+	{ .chan = 3, .c1 = -66, .c0 = 15, },
+	{ .chan = 4, .c1 = -66, .c0 = 15, },
+	{ .chan = 5, .c1 = -66, .c0 = 15, },
+	{ .chan = 6, .c1 = -66, .c0 = 15, },
+	{ .chan = 7, .c1 = -66, .c0 = 14, },
+	{ .chan = 8, .c1 = -66, .c0 = 14, },
+	{ .chan = 9, .c1 = -66, .c0 = 14, },
+	{ .chan = 10, .c1 = -66, .c0 = 14, },
+	{ .chan = 11, .c1 = -66, .c0 = 14, },
+	{ .chan = 12, .c1 = -66, .c0 = 13, },
+	{ .chan = 13, .c1 = -66, .c0 = 13, },
+	{ .chan = 14, .c1 = -66, .c0 = 13, },
+};
+
+static const struct lpphy_rx_iq_comp lpphy_rev0_1_iq_table[] = {
+	{ .chan = 1, .c1 = -64, .c0 = 13, },
+	{ .chan = 2, .c1 = -64, .c0 = 13, },
+	{ .chan = 3, .c1 = -64, .c0 = 13, },
+	{ .chan = 4, .c1 = -64, .c0 = 13, },
+	{ .chan = 5, .c1 = -64, .c0 = 12, },
+	{ .chan = 6, .c1 = -64, .c0 = 12, },
+	{ .chan = 7, .c1 = -64, .c0 = 12, },
+	{ .chan = 8, .c1 = -64, .c0 = 12, },
+	{ .chan = 9, .c1 = -64, .c0 = 12, },
+	{ .chan = 10, .c1 = -64, .c0 = 11, },
+	{ .chan = 11, .c1 = -64, .c0 = 11, },
+	{ .chan = 12, .c1 = -64, .c0 = 11, },
+	{ .chan = 13, .c1 = -64, .c0 = 11, },
+	{ .chan = 14, .c1 = -64, .c0 = 10, },
+	{ .chan = 34, .c1 = -62, .c0 = 24, },
+	{ .chan = 38, .c1 = -62, .c0 = 24, },
+	{ .chan = 42, .c1 = -62, .c0 = 24, },
+	{ .chan = 46, .c1 = -62, .c0 = 23, },
+	{ .chan = 36, .c1 = -62, .c0 = 24, },
+	{ .chan = 40, .c1 = -62, .c0 = 24, },
+	{ .chan = 44, .c1 = -62, .c0 = 23, },
+	{ .chan = 48, .c1 = -62, .c0 = 23, },
+	{ .chan = 52, .c1 = -62, .c0 = 23, },
+	{ .chan = 56, .c1 = -62, .c0 = 22, },
+	{ .chan = 60, .c1 = -62, .c0 = 22, },
+	{ .chan = 64, .c1 = -62, .c0 = 22, },
+	{ .chan = 100, .c1 = -62, .c0 = 16, },
+	{ .chan = 104, .c1 = -62, .c0 = 16, },
+	{ .chan = 108, .c1 = -62, .c0 = 15, },
+	{ .chan = 112, .c1 = -62, .c0 = 14, },
+	{ .chan = 116, .c1 = -62, .c0 = 14, },
+	{ .chan = 120, .c1 = -62, .c0 = 13, },
+	{ .chan = 124, .c1 = -62, .c0 = 12, },
+	{ .chan = 128, .c1 = -62, .c0 = 12, },
+	{ .chan = 132, .c1 = -62, .c0 = 12, },
+	{ .chan = 136, .c1 = -62, .c0 = 11, },
+	{ .chan = 140, .c1 = -62, .c0 = 10, },
+	{ .chan = 149, .c1 = -61, .c0 = 9, },
+	{ .chan = 153, .c1 = -61, .c0 = 9, },
+	{ .chan = 157, .c1 = -61, .c0 = 9, },
+	{ .chan = 161, .c1 = -61, .c0 = 8, },
+	{ .chan = 165, .c1 = -61, .c0 = 8, },
+	{ .chan = 184, .c1 = -62, .c0 = 25, },
+	{ .chan = 188, .c1 = -62, .c0 = 25, },
+	{ .chan = 192, .c1 = -62, .c0 = 25, },
+	{ .chan = 196, .c1 = -62, .c0 = 25, },
+	{ .chan = 200, .c1 = -62, .c0 = 25, },
+	{ .chan = 204, .c1 = -62, .c0 = 25, },
+	{ .chan = 208, .c1 = -62, .c0 = 25, },
+	{ .chan = 212, .c1 = -62, .c0 = 25, },
+	{ .chan = 216, .c1 = -62, .c0 = 26, },
+};
+
+static const struct lpphy_rx_iq_comp lpphy_rev2plus_iq_comp = {
+	.chan = 0,
+	.c1 = -64,
+	.c0 = 0,
+};
+
+static u8 lpphy_nbits(s32 val)
+{
+	u32 tmp = abs(val);
+	u8 nbits = 0;
+
+	while (tmp != 0) {
+		nbits++;
+		tmp >>= 1;
+	}
+
+	return nbits;
+}
+
+static int lpphy_calc_rx_iq_comp(struct b43_wldev *dev, u16 samples)
+{
+	struct lpphy_iq_est iq_est;
+	u16 c0, c1;
+	int prod, ipwr, qpwr, prod_msb, q_msb, tmp1, tmp2, tmp3, tmp4, ret;
+
+	c1 = b43_phy_read(dev, B43_LPPHY_RX_COMP_COEFF_S);
+	c0 = c1 >> 8;
+	c1 |= 0xFF;
+
+	b43_phy_maskset(dev, B43_LPPHY_RX_COMP_COEFF_S, 0xFF00, 0x00C0);
+	b43_phy_mask(dev, B43_LPPHY_RX_COMP_COEFF_S, 0x00FF);
+
+	ret = lpphy_rx_iq_est(dev, samples, 32, &iq_est);
+	if (!ret)
+		goto out;
+
+	prod = iq_est.iq_prod;
+	ipwr = iq_est.i_pwr;
+	qpwr = iq_est.q_pwr;
+
+	if (ipwr + qpwr < 2) {
+		ret = 0;
+		goto out;
+	}
+
+	prod_msb = lpphy_nbits(prod);
+	q_msb = lpphy_nbits(qpwr);
+	tmp1 = prod_msb - 20;
+
+	if (tmp1 >= 0) {
+		tmp3 = ((prod << (30 - prod_msb)) + (ipwr >> (1 + tmp1))) /
+			(ipwr >> tmp1);
+	} else {
+		tmp3 = ((prod << (30 - prod_msb)) + (ipwr << (-1 - tmp1))) /
+			(ipwr << -tmp1);
+	}
+
+	tmp2 = q_msb - 11;
+
+	if (tmp2 >= 0)
+		tmp4 = (qpwr << (31 - q_msb)) / (ipwr >> tmp2);
+	else
+		tmp4 = (qpwr << (31 - q_msb)) / (ipwr << -tmp2);
+
+	tmp4 -= tmp3 * tmp3;
+	tmp4 = -int_sqrt(tmp4);
+
+	c0 = tmp3 >> 3;
+	c1 = tmp4 >> 4;
+
+out:
+	b43_phy_maskset(dev, B43_LPPHY_RX_COMP_COEFF_S, 0xFF00, c1);
+	b43_phy_maskset(dev, B43_LPPHY_RX_COMP_COEFF_S, 0x00FF, c0 << 8);
+	return ret;
+}
+
+/* Complex number using 2 32-bit signed integers */
+typedef struct {s32 i, q;} lpphy_c32;
+
+static lpphy_c32 lpphy_cordic(int theta)
+{
+	u32 arctg[] = { 2949120, 1740967, 919879, 466945, 234379, 117304,
+		      58666, 29335, 14668, 7334, 3667, 1833, 917, 458,
+		      229, 115, 57, 29, };
+	int i, tmp, signx = 1, angle = 0;
+	lpphy_c32 ret = { .i = 39797, .q = 0, };
+
+	theta = clamp_t(int, theta, -180, 180);
+
+	if (theta > 90) {
+		theta -= 180;
+		signx = -1;
+	} else if (theta < -90) {
+		theta += 180;
+		signx = -1;
+	}
+
+	for (i = 0; i <= 17; i++) {
+		if (theta > angle) {
+			tmp = ret.i - (ret.q >> i);
+			ret.q += ret.i >> i;
+			ret.i = tmp;
+			angle += arctg[i];
+		} else {
+			tmp = ret.i + (ret.q >> i);
+			ret.q -= ret.i >> i;
+			ret.i = tmp;
+			angle -= arctg[i];
+		}
+	}
+
+	ret.i *= signx;
+	ret.q *= signx;
+
+	return ret;
+}
+
+static void lpphy_run_samples(struct b43_wldev *dev, u16 samples, u16 loops,
+			      u16 wait)
+{
+	b43_phy_maskset(dev, B43_LPPHY_SMPL_PLAY_BUFFER_CTL,
+			0xFFC0, samples - 1);
+	if (loops != 0xFFFF)
+		loops--;
+	b43_phy_maskset(dev, B43_LPPHY_SMPL_PLAY_COUNT, 0xF000, loops);
+	b43_phy_maskset(dev, B43_LPPHY_SMPL_PLAY_BUFFER_CTL, 0x3F, wait << 6);
+	b43_phy_set(dev, B43_LPPHY_A_PHY_CTL_ADDR, 0x1);
+}
+
+//SPEC FIXME what does a negative freq mean?
+static void lpphy_start_tx_tone(struct b43_wldev *dev, s32 freq, u16 max)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	u16 buf[64];
+	int i, samples, angle = 0, rotation = (9 * freq) / 500;
+	lpphy_c32 sample;
+
+	lpphy->tx_tone_freq = freq;
+
+	if (freq) {
+		/* Find i for which abs(freq) integrally divides 20000 * i */
+		for (i = 1; samples * abs(freq) != 20000 * i; i++) {
+			samples = (20000 * i) / abs(freq);
+			if(B43_WARN_ON(samples > 63))
+				return;
+		}
+	} else {
+		samples = 2;
+	}
+
+	for (i = 0; i < samples; i++) {
+		sample = lpphy_cordic(angle);
+		angle += rotation;
+		buf[i] = ((sample.i * max) & 0xFF) << 8;
+		buf[i] |= (sample.q * max) & 0xFF;
+	}
+
+	b43_lptab_write_bulk(dev, B43_LPTAB16(5, 0), samples, buf);
+
+	lpphy_run_samples(dev, samples, 0xFFFF, 0);
+}
+
+static void lpphy_stop_tx_tone(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	int i;
+
+	lpphy->tx_tone_freq = 0;
+
+	b43_phy_mask(dev, B43_LPPHY_SMPL_PLAY_COUNT, 0xF000);
+	for (i = 0; i < 31; i++) {
+		if (!(b43_phy_read(dev, B43_LPPHY_A_PHY_CTL_ADDR) & 0x1))
+			break;
+		udelay(100);
+	}
+}
+
+
+static void lpphy_papd_cal(struct b43_wldev *dev, struct lpphy_tx_gains gains,
+			   int mode, bool useindex, u8 index)
+{
 	//TODO
+}
 
-	kfree(saved_tab);
+static void lpphy_papd_cal_txpwr(struct b43_wldev *dev)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct ssb_bus *bus = dev->dev->bus;
+	struct lpphy_tx_gains gains, oldgains;
+	int old_txpctl, old_afe_ovr, old_rf, old_bbmult;
+
+	lpphy_read_tx_pctl_mode_from_hardware(dev);
+	old_txpctl = lpphy->txpctl_mode;
+	old_afe_ovr = b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40;
+	if (old_afe_ovr)
+		oldgains = lpphy_get_tx_gains(dev);
+	old_rf = b43_phy_read(dev, B43_LPPHY_RF_PWR_OVERRIDE) & 0xFF;
+	old_bbmult = lpphy_get_bb_mult(dev);
+
+	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
+
+	if (bus->chip_id == 0x4325 && bus->chip_rev == 0)
+		lpphy_papd_cal(dev, gains, 0, 1, 30);
+	else
+		lpphy_papd_cal(dev, gains, 0, 1, 65);
+
+	if (old_afe_ovr)
+		lpphy_set_tx_gains(dev, oldgains);
+	lpphy_set_bb_mult(dev, old_bbmult);
+	lpphy_set_tx_power_control(dev, old_txpctl);
+	b43_phy_maskset(dev, B43_LPPHY_RF_PWR_OVERRIDE, 0xFF00, old_rf);
+}
+
+static int lpphy_rx_iq_cal(struct b43_wldev *dev, bool noise, bool tx,
+			    bool rx, bool pa, struct lpphy_tx_gains *gains)
+{
+	struct b43_phy_lp *lpphy = dev->phy.lp;
+	struct ssb_bus *bus = dev->dev->bus;
+	const struct lpphy_rx_iq_comp *iqcomp = NULL;
+	struct lpphy_tx_gains nogains, oldgains;
+	u16 tmp;
+	int i, ret;
+
+	memset(&nogains, 0, sizeof(nogains));
+	memset(&oldgains, 0, sizeof(oldgains));
+
+	if (bus->chip_id == 0x5354) {
+		for (i = 0; i < ARRAY_SIZE(lpphy_5354_iq_table); i++) {
+			if (lpphy_5354_iq_table[i].chan == lpphy->channel) {
+				iqcomp = &lpphy_5354_iq_table[i];
+			}
+		}
+	} else if (dev->phy.rev >= 2) {
+		iqcomp = &lpphy_rev2plus_iq_comp;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(lpphy_rev0_1_iq_table); i++) {
+			if (lpphy_rev0_1_iq_table[i].chan == lpphy->channel) {
+				iqcomp = &lpphy_rev0_1_iq_table[i];
+			}
+		}
+	}
+
+	if (B43_WARN_ON(!iqcomp))
+		return 0;
+
+	b43_phy_maskset(dev, B43_LPPHY_RX_COMP_COEFF_S, 0xFF00, iqcomp->c1);
+	b43_phy_maskset(dev, B43_LPPHY_RX_COMP_COEFF_S,
+			0x00FF, iqcomp->c0 << 8);
+
+	if (noise) {
+		tx = true;
+		rx = false;
+		pa = false;
+	}
+
+	lpphy_set_trsw_over(dev, tx, rx);
+
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x8);
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0,
+				0xFFF7, pa << 3);
+	} else {
+		b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x20);
+		b43_phy_maskset(dev, B43_LPPHY_RF_OVERRIDE_VAL_0,
+				0xFFDF, pa << 5);
+	}
+
+	tmp = b43_phy_read(dev, B43_LPPHY_AFE_CTL_OVR) & 0x40;
+
+	if (noise)
+		lpphy_set_rx_gain(dev, 0x2D5D);
+	else {
+		if (tmp)
+			oldgains = lpphy_get_tx_gains(dev);
+		if (!gains)
+			gains = &nogains;
+		lpphy_set_tx_gains(dev, *gains);
+	}
+
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFFE);
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xFFFE);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_0, 0x800);
+	b43_phy_set(dev, B43_LPPHY_RF_OVERRIDE_VAL_0, 0x800);
+	lpphy_set_deaf(dev, false);
+	if (noise)
+		ret = lpphy_calc_rx_iq_comp(dev, 0xFFF0);
+	else {
+		lpphy_start_tx_tone(dev, 4000, 100);
+		ret = lpphy_calc_rx_iq_comp(dev, 0x4000);
+		lpphy_stop_tx_tone(dev);
+	}
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFFC);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFF7);
+	b43_phy_mask(dev, B43_LPPHY_RF_OVERRIDE_0, 0xFFDF);
+	if (!noise) {
+		if (tmp)
+			lpphy_set_tx_gains(dev, oldgains);
+		else
+			lpphy_disable_tx_gain_override(dev);
+	}
+	lpphy_disable_rx_gain_override(dev);
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFFE);
+	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVRVAL, 0xF7FF);
+	return ret;
 }
 
 static void lpphy_calibration(struct b43_wldev *dev)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
 	enum b43_lpphy_txpctl_mode saved_pctl_mode;
+	bool full_cal = false;
+
+	if (lpphy->full_calib_chan != lpphy->channel) {
+		full_cal = true;
+		lpphy->full_calib_chan = lpphy->channel;
+	}
 
 	b43_mac_suspend(dev);
 
 	lpphy_btcoex_override(dev);
+	if (dev->phy.rev >= 2)
+		lpphy_save_dig_flt_state(dev);
 	lpphy_read_tx_pctl_mode_from_hardware(dev);
 	saved_pctl_mode = lpphy->txpctl_mode;
 	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
 	//TODO Perform transmit power table I/Q LO calibration
 	if ((dev->phy.rev == 0) && (saved_pctl_mode != B43_LPPHY_TXPCTL_OFF))
 		lpphy_pr41573_workaround(dev);
-	//TODO If a full calibration has not been performed on this channel yet, perform PAPD TX-power calibration
+	if ((dev->phy.rev >= 2) && full_cal) {
+		lpphy_papd_cal_txpwr(dev);
+	}
 	lpphy_set_tx_power_control(dev, saved_pctl_mode);
-	//TODO Perform I/Q calibration with a single control value set
+	if (dev->phy.rev >= 2)
+		lpphy_restore_dig_flt_state(dev);
+	lpphy_rx_iq_cal(dev, true, true, false, false, NULL);
 
 	b43_mac_enable(dev);
 }
@@ -1532,12 +2075,6 @@ static void b43_lpphy_op_radio_write(struct b43_wldev *dev, u16 reg, u16 value)
 	b43_write16(dev, B43_MMIO_RADIO_DATA_LOW, value);
 }
 
-static void b43_lpphy_op_software_rfkill(struct b43_wldev *dev,
-					 bool blocked)
-{
-	//TODO
-}
-
 struct b206x_channel {
 	u8 channel;
 	u16 freq;
@@ -2003,22 +2540,6 @@ static int lpphy_b2062_tune(struct b43_wldev *dev,
 	return err;
 }
 
-
-/* This was previously called lpphy_japan_filter */
-static void lpphy_set_analog_filter(struct b43_wldev *dev, int channel)
-{
-	struct b43_phy_lp *lpphy = dev->phy.lp;
-	u16 tmp = (channel == 14); //SPEC FIXME check japanwidefilter!
-
-	if (dev->phy.rev < 2) { //SPEC FIXME Isn't this rev0/1-specific?
-		b43_phy_maskset(dev, B43_LPPHY_LP_PHY_CTL, 0xFCFF, tmp << 9);
-		if ((dev->phy.rev == 1) && (lpphy->rc_cap))
-			lpphy_set_rc_cap(dev);
-	} else {
-		b43_radio_write(dev, B2063_TX_BB_SP3, 0x3F);
-	}
-}
-
 static void lpphy_b2063_vco_calib(struct b43_wldev *dev)
 {
 	u16 tmp;
@@ -2203,18 +2724,6 @@ static int b43_lpphy_op_init(struct b43_wldev *dev)
 	return 0;
 }
 
-static void b43_lpphy_op_set_rx_antenna(struct b43_wldev *dev, int antenna)
-{
-	if (dev->phy.rev >= 2)
-		return; // rev2+ doesn't support antenna diversity
-
-	if (B43_WARN_ON(antenna > B43_ANTENNA_AUTO1))
-		return;
-
-	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFD, antenna & 0x2);
-	b43_phy_maskset(dev, B43_LPPHY_CRSGAIN_CTL, 0xFFFE, antenna & 0x1);
-}
-
 static void b43_lpphy_op_adjust_txpower(struct b43_wldev *dev)
 {
 	//TODO
@@ -2227,6 +2736,11 @@ static enum b43_txpwr_result b43_lpphy_op_recalc_txpower(struct b43_wldev *dev,
 	return B43_TXPWR_RES_DONE;
 }
 
+static void b43_lpphy_op_pwork_15sec(struct b43_wldev *dev)
+{
+	//TODO
+}
+
 const struct b43_phy_operations b43_phyops_lp = {
 	.allocate		= b43_lpphy_op_allocate,
 	.free			= b43_lpphy_op_free,
@@ -2244,4 +2758,6 @@ const struct b43_phy_operations b43_phyops_lp = {
 	.set_rx_antenna		= b43_lpphy_op_set_rx_antenna,
 	.recalc_txpower		= b43_lpphy_op_recalc_txpower,
 	.adjust_txpower		= b43_lpphy_op_adjust_txpower,
+	.pwork_15sec		= b43_lpphy_op_pwork_15sec,
+	.pwork_60sec		= lpphy_calibration,
 };
diff --git a/drivers/net/wireless/b43/phy_lp.h b/drivers/net/wireless/b43/phy_lp.h
index c3232c1..62737f7 100644
--- a/drivers/net/wireless/b43/phy_lp.h
+++ b/drivers/net/wireless/b43/phy_lp.h
@@ -286,6 +286,7 @@
 #define B43_LPPHY_TR_LOOKUP_6			B43_PHY_OFDM(0xC8) /* TR Lookup 6 */
 #define B43_LPPHY_TR_LOOKUP_7			B43_PHY_OFDM(0xC9) /* TR Lookup 7 */
 #define B43_LPPHY_TR_LOOKUP_8			B43_PHY_OFDM(0xCA) /* TR Lookup 8 */
+#define B43_LPPHY_RF_PWR_OVERRIDE		B43_PHY_OFDM(0xD3) /* RF power override */
 
 
 
@@ -871,12 +872,12 @@ struct b43_phy_lp {
 	u8 rssi_gs;
 
 	/* RC cap */
-	u8 rc_cap; /* FIXME initial value? */
+	u8 rc_cap;
 	/* BX arch */
 	u8 bx_arch;
 
 	/* Full calibration channel */
-	u8 full_calib_chan; /* FIXME initial value? */
+	u8 full_calib_chan;
 
 	/* Transmit iqlocal best coeffs */
 	bool tx_iqloc_best_coeffs_valid;
@@ -891,6 +892,12 @@ struct b43_phy_lp {
 
 	/* The channel we are tuned to */
 	u8 channel;
+
+	/* The active antenna diversity mode */
+	int antenna;
+
+	/* Frequency of the active TX tone */
+	int tx_tone_freq;
 };
 
 enum tssi_mux_mode {
-- 
1.6.2.4





From mb at bu3sch.de  Sun Aug 30 12:28:15 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 30 Aug 2009 12:28:15 +0200
Subject: [PATCH v2] b43: LP-PHY: Begin implementing calibration & software
	RFKILL support
In-Reply-To: <4A99C4BB.7080806@gmail.com>
References: <4A99C4BB.7080806@gmail.com>
Message-ID: <200908301228.16845.mb@bu3sch.de>

On Sunday 30 August 2009 02:15:55 G?bor Stefanik wrote:
>  static void lpphy_pr41573_workaround(struct b43_wldev *dev)
>  {
>  	struct b43_phy_lp *lpphy = dev->phy.lp;
> @@ -1357,28 +1488,440 @@ static void lpphy_pr41573_workaround(struct b43_wldev *dev)
>  		b43_lptab_read_bulk(dev, B43_LPTAB32(7, 0x140),
>  				    saved_tab_size, saved_tab);
>  	}
> +	b43_put_phy_into_reset(dev);

Are you sure you really want this?
This function completely disables the PHY on the backplane and keeps the physical
PHY reset pin asserted (even after return from the function).
So the PHY will physically be powered down from this point on. The following
PHY accesses could even hang the machine, because the PHY won't respond to
register accesses anymore.

We currently only use this function on A/G Multi-PHY devices to permanently
hard-disable the PHY that's not used.

> +	b43_phy_mask(dev, B43_LPPHY_AFE_CTL_OVR, 0xFFF8);
> +	lpphy_table_init(dev); //FIXME is table init needed?
> +	lpphy_baseband_init(dev);
> +	b43_lpphy_op_software_rfkill(dev, false);
> +	lpphy_set_tx_power_control(dev, B43_LPPHY_TXPCTL_OFF);
> +	if (dev->phy.rev < 2) {
> +		b43_lptab_write_bulk(dev, B43_LPTAB32(10, 0x140),
> +				     saved_tab_size, saved_tab);
> +	} else {
> +		b43_lptab_write_bulk(dev, B43_LPTAB32(7, 0x140),
> +				     saved_tab_size, saved_tab);
> +	}
> +	b43_write16(dev, B43_MMIO_CHANNEL, lpphy->channel);
> +	lpphy->tssi_npt = tssi_npt;
> +	lpphy->tssi_idx = tssi_idx;
> +	lpphy_set_analog_filter(dev, lpphy->channel);
> +	if (tx_pwr_idx_over != -1)
> +		lpphy_set_tx_power_by_index(dev, tx_pwr_idx_over);
> +	if (lpphy->rc_cap)
> +		lpphy_set_rc_cap(dev);
> +	b43_lpphy_op_set_rx_antenna(dev, lpphy->antenna);
> +	lpphy_set_tx_power_control(dev, txpctl_mode);
> +	kfree(saved_tab);
> +}

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Sun Aug 30 17:10:23 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 30 Aug 2009 10:10:23 -0500
Subject: [PATCH v2] b43: LP-PHY: Begin implementing calibration & software
	RFKILL support
In-Reply-To: <200908301228.16845.mb@bu3sch.de>
References: <4A99C4BB.7080806@gmail.com> <200908301228.16845.mb@bu3sch.de>
Message-ID: <4A9A965F.8020200@lwfinger.net>

Michael Buesch wrote:
> On Sunday 30 August 2009 02:15:55 G?bor Stefanik wrote:
>>  static void lpphy_pr41573_workaround(struct b43_wldev *dev)
>>  {
>>  	struct b43_phy_lp *lpphy = dev->phy.lp;
>> @@ -1357,28 +1488,440 @@ static void lpphy_pr41573_workaround(struct b43_wldev *dev)
>>  		b43_lptab_read_bulk(dev, B43_LPTAB32(7, 0x140),
>>  				    saved_tab_size, saved_tab);
>>  	}
>> +	b43_put_phy_into_reset(dev);
> 
> Are you sure you really want this?
> This function completely disables the PHY on the backplane and keeps the physical
> PHY reset pin asserted (even after return from the function).
> So the PHY will physically be powered down from this point on. The following
> PHY accesses could even hang the machine, because the PHY won't respond to
> register accesses anymore.
> 
> We currently only use this function on A/G Multi-PHY devices to permanently
> hard-disable the PHY that's not used.

The PHY reset routine in
http://bcm-v4.sipsolutions.net/802.11/PHY/Reset, which I just updated
for the latest N PHY changes, appears to be a different routine than
b43_put_phy_into_reset(). The names are confusing.

Larry


From mb at bu3sch.de  Sun Aug 30 17:55:40 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 30 Aug 2009 17:55:40 +0200
Subject: [PATCH v2] b43: LP-PHY: Begin implementing calibration & software
	RFKILL support
In-Reply-To: <4A9A965F.8020200@lwfinger.net>
References: <4A99C4BB.7080806@gmail.com> <200908301228.16845.mb@bu3sch.de>
	<4A9A965F.8020200@lwfinger.net>
Message-ID: <200908301755.40557.mb@bu3sch.de>

On Sunday 30 August 2009 17:10:23 Larry Finger wrote:
> Michael Buesch wrote:
> > On Sunday 30 August 2009 02:15:55 G?bor Stefanik wrote:
> >>  static void lpphy_pr41573_workaround(struct b43_wldev *dev)
> >>  {
> >>  	struct b43_phy_lp *lpphy = dev->phy.lp;
> >> @@ -1357,28 +1488,440 @@ static void lpphy_pr41573_workaround(struct b43_wldev *dev)
> >>  		b43_lptab_read_bulk(dev, B43_LPTAB32(7, 0x140),
> >>  				    saved_tab_size, saved_tab);
> >>  	}
> >> +	b43_put_phy_into_reset(dev);
> > 
> > Are you sure you really want this?
> > This function completely disables the PHY on the backplane and keeps the physical
> > PHY reset pin asserted (even after return from the function).
> > So the PHY will physically be powered down from this point on. The following
> > PHY accesses could even hang the machine, because the PHY won't respond to
> > register accesses anymore.
> > 
> > We currently only use this function on A/G Multi-PHY devices to permanently
> > hard-disable the PHY that's not used.
> 
> The PHY reset routine in
> http://bcm-v4.sipsolutions.net/802.11/PHY/Reset, which I just updated
> for the latest N PHY changes, appears to be a different routine than
> b43_put_phy_into_reset(). The names are confusing.

b43_put_phy_into_reset() is opencoded in the specifications in various init
routines. There's no separate specs page for that function.
But I think the code is straightforward and easy to understand.

-- 
Greetings, Michael.


From linville at tuxdriver.com  Mon Aug 31 19:53:31 2009
From: linville at tuxdriver.com (John W. Linville)
Date: Mon, 31 Aug 2009 13:53:31 -0400
Subject: [PATCH v2] b43: LP-PHY: Begin implementing calibration &
	software RFKILL support
In-Reply-To: <200908301755.40557.mb@bu3sch.de>
References: <4A99C4BB.7080806@gmail.com> <200908301228.16845.mb@bu3sch.de>
	<4A9A965F.8020200@lwfinger.net> <200908301755.40557.mb@bu3sch.de>
Message-ID: <20090831175331.GB5631@tuxdriver.com>

On Sun, Aug 30, 2009 at 05:55:40PM +0200, Michael Buesch wrote:
> On Sunday 30 August 2009 17:10:23 Larry Finger wrote:
> > Michael Buesch wrote:
> > > On Sunday 30 August 2009 02:15:55 G?bor Stefanik wrote:
> > >>  static void lpphy_pr41573_workaround(struct b43_wldev *dev)
> > >>  {
> > >>  	struct b43_phy_lp *lpphy = dev->phy.lp;
> > >> @@ -1357,28 +1488,440 @@ static void lpphy_pr41573_workaround(struct b43_wldev *dev)
> > >>  		b43_lptab_read_bulk(dev, B43_LPTAB32(7, 0x140),
> > >>  				    saved_tab_size, saved_tab);
> > >>  	}
> > >> +	b43_put_phy_into_reset(dev);
> > > 
> > > Are you sure you really want this?
> > > This function completely disables the PHY on the backplane and keeps the physical
> > > PHY reset pin asserted (even after return from the function).
> > > So the PHY will physically be powered down from this point on. The following
> > > PHY accesses could even hang the machine, because the PHY won't respond to
> > > register accesses anymore.
> > > 
> > > We currently only use this function on A/G Multi-PHY devices to permanently
> > > hard-disable the PHY that's not used.
> > 
> > The PHY reset routine in
> > http://bcm-v4.sipsolutions.net/802.11/PHY/Reset, which I just updated
> > for the latest N PHY changes, appears to be a different routine than
> > b43_put_phy_into_reset(). The names are confusing.
> 
> b43_put_phy_into_reset() is opencoded in the specifications in various init
> routines. There's no separate specs page for that function.
> But I think the code is straightforward and easy to understand.

So is this patch right or not?  Should I hold onto it for 2.6.33
(i.e. after the 2.6.32 merge window)?

John
-- 
John W. Linville		Someday the world will need a hero, and you
linville at tuxdriver.com			might be all we have.  Be ready.


From mb at bu3sch.de  Mon Aug 31 21:17:25 2009
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 31 Aug 2009 21:17:25 +0200
Subject: [PATCH v2] b43: LP-PHY: Begin implementing calibration & software
	RFKILL support
In-Reply-To: <20090831175331.GB5631@tuxdriver.com>
References: <4A99C4BB.7080806@gmail.com> <200908301755.40557.mb@bu3sch.de>
	<20090831175331.GB5631@tuxdriver.com>
Message-ID: <200908312117.26915.mb@bu3sch.de>

On Monday 31 August 2009 19:53:31 John W. Linville wrote:
> On Sun, Aug 30, 2009 at 05:55:40PM +0200, Michael Buesch wrote:
> > On Sunday 30 August 2009 17:10:23 Larry Finger wrote:
> > > Michael Buesch wrote:
> > > > On Sunday 30 August 2009 02:15:55 G?bor Stefanik wrote:
> > > >>  static void lpphy_pr41573_workaround(struct b43_wldev *dev)
> > > >>  {
> > > >>  	struct b43_phy_lp *lpphy = dev->phy.lp;
> > > >> @@ -1357,28 +1488,440 @@ static void lpphy_pr41573_workaround(struct b43_wldev *dev)
> > > >>  		b43_lptab_read_bulk(dev, B43_LPTAB32(7, 0x140),
> > > >>  				    saved_tab_size, saved_tab);
> > > >>  	}
> > > >> +	b43_put_phy_into_reset(dev);
> > > > 
> > > > Are you sure you really want this?
> > > > This function completely disables the PHY on the backplane and keeps the physical
> > > > PHY reset pin asserted (even after return from the function).
> > > > So the PHY will physically be powered down from this point on. The following
> > > > PHY accesses could even hang the machine, because the PHY won't respond to
> > > > register accesses anymore.
> > > > 
> > > > We currently only use this function on A/G Multi-PHY devices to permanently
> > > > hard-disable the PHY that's not used.
> > > 
> > > The PHY reset routine in
> > > http://bcm-v4.sipsolutions.net/802.11/PHY/Reset, which I just updated
> > > for the latest N PHY changes, appears to be a different routine than
> > > b43_put_phy_into_reset(). The names are confusing.
> > 
> > b43_put_phy_into_reset() is opencoded in the specifications in various init
> > routines. There's no separate specs page for that function.
> > But I think the code is straightforward and easy to understand.
> 
> So is this patch right or not?  Should I hold onto it for 2.6.33
> (i.e. after the 2.6.32 merge window)?

I'm pretty sure it's incorrect.

-- 
Greetings, Michael.


From Larry.Finger at lwfinger.net  Mon Aug 31 21:23:44 2009
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 31 Aug 2009 14:23:44 -0500
Subject: [PATCH v2] b43: LP-PHY: Begin implementing calibration & software
	RFKILL support
In-Reply-To: <200908312117.26915.mb@bu3sch.de>
References: <4A99C4BB.7080806@gmail.com> <200908301755.40557.mb@bu3sch.de>
	<20090831175331.GB5631@tuxdriver.com>
	<200908312117.26915.mb@bu3sch.de>
Message-ID: <4A9C2340.7060604@lwfinger.net>

Michael Buesch wrote:
> On Monday 31 August 2009 19:53:31 John W. Linville wrote:
>> On Sun, Aug 30, 2009 at 05:55:40PM +0200, Michael Buesch wrote:
>>> On Sunday 30 August 2009 17:10:23 Larry Finger wrote:
>>>> Michael Buesch wrote:
>>>>> On Sunday 30 August 2009 02:15:55 G?bor Stefanik wrote:
>>>>>>  static void lpphy_pr41573_workaround(struct b43_wldev *dev)
>>>>>>  {
>>>>>>  	struct b43_phy_lp *lpphy = dev->phy.lp;
>>>>>> @@ -1357,28 +1488,440 @@ static void lpphy_pr41573_workaround(struct b43_wldev *dev)
>>>>>>  		b43_lptab_read_bulk(dev, B43_LPTAB32(7, 0x140),
>>>>>>  				    saved_tab_size, saved_tab);
>>>>>>  	}
>>>>>> +	b43_put_phy_into_reset(dev);
>>>>> Are you sure you really want this?
>>>>> This function completely disables the PHY on the backplane and keeps the physical
>>>>> PHY reset pin asserted (even after return from the function).
>>>>> So the PHY will physically be powered down from this point on. The following
>>>>> PHY accesses could even hang the machine, because the PHY won't respond to
>>>>> register accesses anymore.
>>>>>
>>>>> We currently only use this function on A/G Multi-PHY devices to permanently
>>>>> hard-disable the PHY that's not used.
>>>> The PHY reset routine in
>>>> http://bcm-v4.sipsolutions.net/802.11/PHY/Reset, which I just updated
>>>> for the latest N PHY changes, appears to be a different routine than
>>>> b43_put_phy_into_reset(). The names are confusing.
>>> b43_put_phy_into_reset() is opencoded in the specifications in various init
>>> routines. There's no separate specs page for that function.
>>> But I think the code is straightforward and easy to understand.
>> So is this patch right or not?  Should I hold onto it for 2.6.33
>> (i.e. after the 2.6.32 merge window)?
> 
> I'm pretty sure it's incorrect.

I agree.

Larry


From netrolller.3d at gmail.com  Mon Aug 31 21:38:28 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 31 Aug 2009 21:38:28 +0200
Subject: [PATCH v2] b43: LP-PHY: Begin implementing calibration & software
	RFKILL support
In-Reply-To: <200908312117.26915.mb@bu3sch.de>
References: <4A99C4BB.7080806@gmail.com> <200908301755.40557.mb@bu3sch.de> 
	<20090831175331.GB5631@tuxdriver.com> <200908312117.26915.mb@bu3sch.de>
Message-ID: <69e28c910908311238r51222506j7bd21e3b7af5b4ad@mail.gmail.com>

On Mon, Aug 31, 2009 at 9:17 PM, Michael Buesch<mb at bu3sch.de> wrote:
> On Monday 31 August 2009 19:53:31 John W. Linville wrote:
>> On Sun, Aug 30, 2009 at 05:55:40PM +0200, Michael Buesch wrote:
>> > On Sunday 30 August 2009 17:10:23 Larry Finger wrote:
>> > > Michael Buesch wrote:
>> > > > On Sunday 30 August 2009 02:15:55 G?bor Stefanik wrote:
>> > > >> ?static void lpphy_pr41573_workaround(struct b43_wldev *dev)
>> > > >> ?{
>> > > >> ? ? ? ?struct b43_phy_lp *lpphy = dev->phy.lp;
>> > > >> @@ -1357,28 +1488,440 @@ static void lpphy_pr41573_workaround(struct b43_wldev *dev)
>> > > >> ? ? ? ? ? ? ? ?b43_lptab_read_bulk(dev, B43_LPTAB32(7, 0x140),
>> > > >> ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?saved_tab_size, saved_tab);
>> > > >> ? ? ? ?}
>> > > >> + ? ? ?b43_put_phy_into_reset(dev);
>> > > >
>> > > > Are you sure you really want this?
>> > > > This function completely disables the PHY on the backplane and keeps the physical
>> > > > PHY reset pin asserted (even after return from the function).
>> > > > So the PHY will physically be powered down from this point on. The following
>> > > > PHY accesses could even hang the machine, because the PHY won't respond to
>> > > > register accesses anymore.
>> > > >
>> > > > We currently only use this function on A/G Multi-PHY devices to permanently
>> > > > hard-disable the PHY that's not used.
>> > >
>> > > The PHY reset routine in
>> > > http://bcm-v4.sipsolutions.net/802.11/PHY/Reset, which I just updated
>> > > for the latest N PHY changes, appears to be a different routine than
>> > > b43_put_phy_into_reset(). The names are confusing.
>> >
>> > b43_put_phy_into_reset() is opencoded in the specifications in various init
>> > routines. There's no separate specs page for that function.
>> > But I think the code is straightforward and easy to understand.
>>
>> So is this patch right or not? ?Should I hold onto it for 2.6.33
>> (i.e. after the 2.6.32 merge window)?
>
> I'm pretty sure it's incorrect.
>
> --
> Greetings, Michael.
>

Do we have the correct reset routine implemented somewhere, or is it a
new routine to add?

-- 
Vista: [V]iruses, [I]ntruders, [S]pyware, [T]rojans and [A]dware. :-)


From netrolller.3d at gmail.com  Mon Aug 31 23:01:50 2009
From: netrolller.3d at gmail.com (=?ISO-8859-1?Q?G=E1bor_Stefanik?=)
Date: Mon, 31 Aug 2009 23:01:50 +0200
Subject: Test message, please ignore.
Message-ID: <69e28c910908311401j70c0ed27h3222d934baf2bf75@mail.gmail.com>

I suspect that this will trigger a response from a spambot.

reset


