<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [RFC 5/10] Port of bcm43xx from softmac to mac80211
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/bcm43xx-dev/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:bcm43xx-dev%40lists.berlios.de?Subject=Re%3A%20%5BRFC%205/10%5D%20Port%20of%20bcm43xx%20from%20softmac%20to%20mac80211&In-Reply-To=%3C46b1fe04.IfveQgM5dSl8zU22%25Larry.Finger%40lwfinger.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001699.html">
   <LINK REL="Next"  HREF="001704.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[RFC 5/10] Port of bcm43xx from softmac to mac80211</H1>
    <B>Larry Finger</B> 
    <A HREF="mailto:bcm43xx-dev%40lists.berlios.de?Subject=Re%3A%20%5BRFC%205/10%5D%20Port%20of%20bcm43xx%20from%20softmac%20to%20mac80211&In-Reply-To=%3C46b1fe04.IfveQgM5dSl8zU22%25Larry.Finger%40lwfinger.net%3E"
       TITLE="[RFC 5/10] Port of bcm43xx from softmac to mac80211">Larry.Finger at lwfinger.net
       </A><BR>
    <I>Thu Aug  2 17:53:40 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001699.html">[RFC 4/10] Port of bcm43xx from softmac to mac80211
</A></li>
        <LI>Next message: <A HREF="001704.html">[RFC 6/10] Port of bcm43xx from softmac to mac80211
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1705">[ date ]</a>
              <a href="thread.html#1705">[ thread ]</a>
              <a href="subject.html#1705">[ subject ]</a>
              <a href="author.html#1705">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This if file 5 of 10 of the port of the bcm43xx driver from softmac
to mac80211.

Signed-off-by: Larry Finger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">Larry.Finger at lwfinger.net</A>&gt;
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -1,32 +1,33 @@
 /*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
+ *
+ *  Broadcom BCM43xx wireless driver
+ *
+ *  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;
+ *  Copyright (c) 2005 Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
+ *  Copyright (c) 2005, 2006 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mb at bu3sch.de</A>&gt;
+ *  Copyright (c) 2005 Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
+ *  Copyright (c) 2005 Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
+ *  Copyright (c) 2007 Larry Finger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">Larry.Finger at lwfinger.net</A>&gt;
+ *
+ *  Some parts of the code in this file are derived from the ipw2200
+ *  driver  Copyright(c) 2003 - 2004 Intel Corporation.
+
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ *
+ */
 
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/init.h&gt;
@@ -39,20 +40,17 @@
 #include &lt;linux/workqueue.h&gt;
 #include &lt;linux/skbuff.h&gt;
 #include &lt;linux/dma-mapping.h&gt;
-#include &lt;net/iw_handler.h&gt;
+#include &lt;net/dst.h&gt;
 
 #include &quot;bcm43xx.h&quot;
 #include &quot;bcm43xx_main.h&quot;
 #include &quot;bcm43xx_debugfs.h&quot;
-#include &quot;bcm43xx_radio.h&quot;
 #include &quot;bcm43xx_phy.h&quot;
 #include &quot;bcm43xx_dma.h&quot;
 #include &quot;bcm43xx_pio.h&quot;
-#include &quot;bcm43xx_power.h&quot;
-#include &quot;bcm43xx_wx.h&quot;
-#include &quot;bcm43xx_ethtool.h&quot;
-#include &quot;bcm43xx_xmit.h&quot;
 #include &quot;bcm43xx_sysfs.h&quot;
+#include &quot;bcm43xx_xmit.h&quot;
+#include &quot;bcm43xx_radio.h&quot;
 
 
 MODULE_DESCRIPTION(&quot;Broadcom BCM43xx wireless driver&quot;);
@@ -83,80 +81,177 @@ static int modparam_long_retry = BCM43xx
 module_param_named(long_retry, modparam_long_retry, int, 0444);
 MODULE_PARM_DESC(long_retry, &quot;Long-Retry-Limit (0 - 15)&quot;);
 
-static int modparam_locale = -1;
-module_param_named(locale, modparam_locale, int, 0444);
-MODULE_PARM_DESC(country, &quot;Select LocaleCode 0-11 (For travelers)&quot;);
-
 static int modparam_noleds;
 module_param_named(noleds, modparam_noleds, int, 0444);
 MODULE_PARM_DESC(noleds, &quot;Turn off all LED activity&quot;);
 
-static char modparam_fwpostfix[64];
-module_param_string(fwpostfix, modparam_fwpostfix, 64, 0444);
-MODULE_PARM_DESC(fwpostfix, &quot;Postfix for .fw files. Useful for using multiple firmware image versions.&quot;);
+static char modparam_fwpostfix[16] = {&quot;.fw3&quot;};
+module_param_string(fwpostfix, modparam_fwpostfix, 16, 0444);
+MODULE_PARM_DESC(fwpostfix, &quot;Postfix for the .fw files to load.&quot;);
+
+static int modparam_mon_keep_bad;
+module_param_named(mon_keep_bad, modparam_mon_keep_bad, int, 0444);
+MODULE_PARM_DESC(mon_keep_bad, &quot;Keep bad frames in monitor mode&quot;);
+
+static int modparam_mon_keep_badplcp;
+module_param_named(mon_keep_badplcp, modparam_mon_keep_bad, int, 0444);
+MODULE_PARM_DESC(mon_keep_badplcp, &quot;Keep frames with bad PLCP in monitor mode&quot;);
+
+
+static const struct ssb_device_id bcm43xx_ssb_tbl[] = {
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, SSB_ANY_REV),
+	SSB_DEVTABLE_END
+};
+MODULE_DEVICE_TABLE(ssb, bcm43xx_ssb_tbl);
 
 
-/* If you want to debug with just a single device, enable this,
- * where the string is the pci device ID (as given by the kernel's
- * pci_name function) of the device to be used.
- */
-//#define DEBUG_SINGLE_DEVICE_ONLY	&quot;0001:11:00.0&quot;
+/* Channel and ratetables are shared for all devices.
+ * They can't be const, because ieee80211 puts some precalculated
+ * data in there. This data is the same for all devices, so we don't
+ * get concurrency issues */
+#define RATETAB_ENT(_rateid, _flags) \
+	{							\
+		.rate	= BCM43xx_RATE_TO_100KBPS(_rateid),	\
+		.val	= (_rateid),				\
+		.val2	= (_rateid),				\
+		.flags	= (_flags),				\
+	}
+static struct ieee80211_rate __bcm43xx_ratetable[] = {
+	RATETAB_ENT(BCM43xx_CCK_RATE_1MB, IEEE80211_RATE_CCK),
+	RATETAB_ENT(BCM43xx_CCK_RATE_2MB, IEEE80211_RATE_CCK_2),
+	RATETAB_ENT(BCM43xx_CCK_RATE_5MB, IEEE80211_RATE_CCK_2),
+	RATETAB_ENT(BCM43xx_CCK_RATE_11MB, IEEE80211_RATE_CCK_2),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_6MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_9MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_12MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_18MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_24MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_36MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_48MB, IEEE80211_RATE_OFDM),
+	RATETAB_ENT(BCM43xx_OFDM_RATE_54MB, IEEE80211_RATE_OFDM),
+};
+#define bcm43xx_a_ratetable		(__bcm43xx_ratetable + 4)
+#define bcm43xx_a_ratetable_size	8
+#define bcm43xx_b_ratetable		(__bcm43xx_ratetable + 0)
+#define bcm43xx_b_ratetable_size	4
+#define bcm43xx_g_ratetable		(__bcm43xx_ratetable + 0)
+#define bcm43xx_g_ratetable_size	12
+
+#define CHANTAB_ENT(_chanid, _freq) \
+	{							\
+		.chan	= (_chanid),				\
+		.freq	= (_freq),				\
+		.val	= (_chanid),				\
+		.flag	= IEEE80211_CHAN_W_SCAN |		\
+			  IEEE80211_CHAN_W_ACTIVE_SCAN |	\
+			  IEEE80211_CHAN_W_IBSS,		\
+		.power_level	= 0xFF,				\
+		.antenna_max	= 0xFF,				\
+	}
+static struct ieee80211_channel bcm43xx_bg_chantable[] = {
+	CHANTAB_ENT(1, 2412),
+	CHANTAB_ENT(2, 2417),
+	CHANTAB_ENT(3, 2422),
+	CHANTAB_ENT(4, 2427),
+	CHANTAB_ENT(5, 2432),
+	CHANTAB_ENT(6, 2437),
+	CHANTAB_ENT(7, 2442),
+	CHANTAB_ENT(8, 2447),
+	CHANTAB_ENT(9, 2452),
+	CHANTAB_ENT(10, 2457),
+	CHANTAB_ENT(11, 2462),
+	CHANTAB_ENT(12, 2467),
+	CHANTAB_ENT(13, 2472),
+	CHANTAB_ENT(14, 2484),
+};
+#define bcm43xx_bg_chantable_size	ARRAY_SIZE(bcm43xx_bg_chantable)
 
-/* If you want to enable printing of each MMIO access, enable this. */
-//#define DEBUG_ENABLE_MMIO_PRINT
+static void bcm43xx_wireless_core_exit(struct bcm43xx_wldev *dev);
+static int bcm43xx_wireless_core_init(struct bcm43xx_wldev *dev);
+static void bcm43xx_wireless_core_stop(struct bcm43xx_wldev *dev);
+static int bcm43xx_wireless_core_start(struct bcm43xx_wldev *dev);
 
-/* If you want to enable printing of MMIO access within
- * ucode/pcm upload, initvals write, enable this.
- */
-//#define DEBUG_ENABLE_UCODE_MMIO_PRINT
 
-/* If you want to enable printing of PCI Config Space access, enable this */
-//#define DEBUG_ENABLE_PCILOG
+static int bcm43xx_ratelimit(struct bcm43xx_wl *wl)
+{
+	if (!wl || !wl-&gt;current_dev)
+		return 1;
+	if (bcm43xx_status(wl-&gt;current_dev) &lt; BCM43xx_STAT_STARTED)
+		return 1;
+	/* We are up and running.
+	 * Ratelimit the messages to avoid DoS over the net. */
+	return net_ratelimit();
+}
+
+void bcminfo(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
 
+	if (!bcm43xx_ratelimit(wl))
+		return;
+	va_start(args, fmt);
+	printk(KERN_INFO &quot;bcm43xx-%s: &quot;,
+	       (wl &amp;&amp; wl-&gt;hw) ? wiphy_name(wl-&gt;hw-&gt;wiphy) : &quot;wlan&quot;);
+	vprintk(fmt, args);
+	va_end(args);
+}
 
-/* Detailed list maintained at:
- * <A HREF="http://openfacts.berlios.de/index-en.phtml?title=Bcm43xxDevices">http://openfacts.berlios.de/index-en.phtml?title=Bcm43xxDevices</A>
- */
-	static struct pci_device_id bcm43xx_pci_tbl[] = {
-	/* Broadcom 4303 802.11b */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4301, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4307 802.11b */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4307, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4311 802.11(a)/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4311, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4312 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4312, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4318 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4318, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4319 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4319, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4306 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4320, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4306 802.11a */
-//	{ PCI_VENDOR_ID_BROADCOM, 0x4321, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4309 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4324, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 43XG 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4325, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ 0 },
-};
-MODULE_DEVICE_TABLE(pci, bcm43xx_pci_tbl);
+void bcmerr(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
+
+	if (!bcm43xx_ratelimit(wl))
+		return;
+	va_start(args, fmt);
+	printk(KERN_ERR &quot;bcm43xx-%s ERROR: &quot;,
+	       (wl &amp;&amp; wl-&gt;hw) ? wiphy_name(wl-&gt;hw-&gt;wiphy) : &quot;wlan&quot;);
+	vprintk(fmt, args);
+	va_end(args);
+}
+
+void bcmwarn(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
+
+	if (!bcm43xx_ratelimit(wl))
+		return;
+	va_start(args, fmt);
+	printk(KERN_WARNING &quot;bcm43xx-%s warning: &quot;,
+	       (wl &amp;&amp; wl-&gt;hw) ? wiphy_name(wl-&gt;hw-&gt;wiphy) : &quot;wlan&quot;);
+	vprintk(fmt, args);
+	va_end(args);
+}
+
+#if BCM43xx_DEBUG
+void bcmdbg(struct bcm43xx_wl *wl, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	printk(KERN_DEBUG &quot;bcm43xx-%s debug: &quot;,
+	       (wl &amp;&amp; wl-&gt;hw) ? wiphy_name(wl-&gt;hw-&gt;wiphy) : &quot;wlan&quot;);
+	vprintk(fmt, args);
+	va_end(args);
+}
+#endif /* DEBUG */
 
-static void bcm43xx_ram_write(struct bcm43xx_private *bcm, u16 offset, u32 val)
+static void bcm43xx_ram_write(struct bcm43xx_wldev *dev, u16 offset, u32 val)
 {
 	u32 status;
 
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	if (!(status &amp; BCM43xx_SBF_XFER_REG_BYTESWAP))
+	BCM43xx_WARN_ON(offset % 4 != 0);
+
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
+	if (status &amp; BCM43xx_SBF_XFER_REG_BYTESWAP)
 		val = swab32(val);
 
-	bcm43xx_write32(bcm, BCM43xx_MMIO_RAM_CONTROL, offset);
+	bcm43xx_write32(dev, BCM43xx_MMIO_RAM_CONTROL, offset);
 	mmiowb();
-	bcm43xx_write32(bcm, BCM43xx_MMIO_RAM_DATA, val);
+	bcm43xx_write32(dev, BCM43xx_MMIO_RAM_DATA, val);
 }
 
 static inline
-void bcm43xx_shm_control_word(struct bcm43xx_private *bcm,
+void bcm43xx_shm_control_word(struct bcm43xx_wldev *dev,
 			      u16 routing, u16 offset)
 {
 	u32 control;
@@ -166,100 +261,134 @@ void bcm43xx_shm_control_word(struct bcm
 	control = routing;
 	control &lt;&lt;= 16;
 	control |= offset;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_CONTROL, control);
+	bcm43xx_write32(dev, BCM43xx_MMIO_SHM_CONTROL, control);
 }
 
-u32 bcm43xx_shm_read32(struct bcm43xx_private *bcm,
+u32 bcm43xx_shm_read32(struct bcm43xx_wldev *dev,
 		       u16 routing, u16 offset)
 {
 	u32 ret;
 
 	if (routing == BCM43xx_SHM_SHARED) {
+		BCM43xx_WARN_ON((offset &amp; 0x0001) != 0);
 		if (offset &amp; 0x0003) {
 			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset &gt;&gt; 2);
-			ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED);
+			bcm43xx_shm_control_word(dev, routing, offset &gt;&gt; 2);
+			ret = bcm43xx_read16(dev,
+					     BCM43xx_MMIO_SHM_DATA_UNALIGNED);
 			ret &lt;&lt;= 16;
-			bcm43xx_shm_control_word(bcm, routing, (offset &gt;&gt; 2) + 1);
-			ret |= bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA);
+			bcm43xx_shm_control_word(dev, routing,
+						 (offset &gt;&gt; 2) + 1);
+			ret |= bcm43xx_read16(dev,
+					      BCM43xx_MMIO_SHM_DATA);
 
 			return ret;
 		}
 		offset &gt;&gt;= 2;
 	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	ret = bcm43xx_read32(bcm, BCM43xx_MMIO_SHM_DATA);
+	bcm43xx_shm_control_word(dev, routing, offset);
+	ret = bcm43xx_read32(dev, BCM43xx_MMIO_SHM_DATA);
 
 	return ret;
 }
 
-u16 bcm43xx_shm_read16(struct bcm43xx_private *bcm,
+u16 bcm43xx_shm_read16(struct bcm43xx_wldev *dev,
 		       u16 routing, u16 offset)
 {
 	u16 ret;
 
 	if (routing == BCM43xx_SHM_SHARED) {
+		BCM43xx_WARN_ON((offset &amp; 0x0001) != 0);
 		if (offset &amp; 0x0003) {
 			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset &gt;&gt; 2);
-			ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED);
+			bcm43xx_shm_control_word(dev, routing, offset &gt;&gt; 2);
+			ret = bcm43xx_read16(dev,
+					     BCM43xx_MMIO_SHM_DATA_UNALIGNED);
 
 			return ret;
 		}
 		offset &gt;&gt;= 2;
 	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA);
+	bcm43xx_shm_control_word(dev, routing, offset);
+	ret = bcm43xx_read16(dev, BCM43xx_MMIO_SHM_DATA);
 
 	return ret;
 }
 
-void bcm43xx_shm_write32(struct bcm43xx_private *bcm,
+void bcm43xx_shm_write32(struct bcm43xx_wldev *dev,
 			 u16 routing, u16 offset,
 			 u32 value)
 {
 	if (routing == BCM43xx_SHM_SHARED) {
+		BCM43xx_WARN_ON((offset &amp; 0x0001) != 0);
 		if (offset &amp; 0x0003) {
 			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset &gt;&gt; 2);
+			bcm43xx_shm_control_word(dev, routing, offset &gt;&gt; 2);
 			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
+			bcm43xx_write16(dev, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
 					(value &gt;&gt; 16) &amp; 0xffff);
 			mmiowb();
-			bcm43xx_shm_control_word(bcm, routing, (offset &gt;&gt; 2) + 1);
+			bcm43xx_shm_control_word(dev, routing,
+						 (offset &gt;&gt; 2) + 1);
 			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA,
+			bcm43xx_write16(dev, BCM43xx_MMIO_SHM_DATA,
 					value &amp; 0xffff);
 			return;
 		}
 		offset &gt;&gt;= 2;
 	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
+	bcm43xx_shm_control_word(dev, routing, offset);
 	mmiowb();
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA, value);
+	bcm43xx_write32(dev, BCM43xx_MMIO_SHM_DATA, value);
 }
 
-void bcm43xx_shm_write16(struct bcm43xx_private *bcm,
+void bcm43xx_shm_write16(struct bcm43xx_wldev *dev,
 			 u16 routing, u16 offset,
 			 u16 value)
 {
 	if (routing == BCM43xx_SHM_SHARED) {
+		BCM43xx_WARN_ON((offset &amp; 0x0001) != 0);
 		if (offset &amp; 0x0003) {
 			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset &gt;&gt; 2);
+			bcm43xx_shm_control_word(dev, routing, offset &gt;&gt; 2);
 			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
+			bcm43xx_write16(dev, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
 					value);
 			return;
 		}
 		offset &gt;&gt;= 2;
 	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
+	bcm43xx_shm_control_word(dev, routing, offset);
 	mmiowb();
-	bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA, value);
+	bcm43xx_write16(dev, BCM43xx_MMIO_SHM_DATA, value);
+}
+
+/* Read HostFlags */
+u32 bcm43xx_hf_read(struct bcm43xx_wldev *dev)
+{
+	u32 ret;
+
+	ret = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				 BCM43xx_SHM_SH_HOSTFHI);
+	ret &lt;&lt;= 16;
+	ret |= bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				  BCM43xx_SHM_SH_HOSTFLO);
+
+	return ret;
+}
+
+/* Write HostFlags */
+void bcm43xx_hf_write(struct bcm43xx_wldev *dev, u32 value)
+{
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_HOSTFLO,
+			    (value &amp; 0x0000FFFF));
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_HOSTFHI,
+			    ((value &amp; 0xFFFF0000) &gt;&gt; 16));
 }
 
-void bcm43xx_tsf_read(struct bcm43xx_private *bcm, u64 *tsf)
+void bcm43xx_tsf_read(struct bcm43xx_wldev *dev, u64 *tsf)
 {
 	/* We need to be careful. As we read the TSF from multiple
 	 * registers, we should take care of register overflows.
@@ -267,13 +396,16 @@ void bcm43xx_tsf_read(struct bcm43xx_pri
 	 * We try to be atomic here, by restaring the read process,
 	 * if any of the high registers changed (overflew).
 	 */
-	if (bcm-&gt;current_core-&gt;rev &gt;= 3) {
+	if (dev-&gt;dev-&gt;id.revision &gt;= 3) {
 		u32 low, high, high2;
 
 		do {
-			high = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
-			low = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW);
-			high2 = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
+			high = bcm43xx_read32(dev,
+					      BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
+			low = bcm43xx_read32(dev,
+					     BCM43xx_MMIO_REV3PLUS_TSF_LOW);
+			high2 = bcm43xx_read32(dev,
+					     BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
 		} while (unlikely(high != high2));
 
 		*tsf = high;
@@ -285,14 +417,14 @@ void bcm43xx_tsf_read(struct bcm43xx_pri
 		u16 test1, test2, test3;
 
 		do {
-			v3 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_3);
-			v2 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_2);
-			v1 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_1);
-			v0 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_0);
-
-			test3 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_3);
-			test2 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_2);
-			test1 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_1);
+			v3 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_3);
+			v2 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_2);
+			v1 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_1);
+			v0 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_0);
+
+			test3 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_3);
+			test2 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_2);
+			test1 = bcm43xx_read16(dev, BCM43xx_MMIO_TSF_1);
 		} while (v3 != test3 || v2 != test2 || v1 != test1);
 
 		*tsf = v3;
@@ -307,172 +439,159 @@ void bcm43xx_tsf_read(struct bcm43xx_pri
 	}
 }
 
-void bcm43xx_tsf_write(struct bcm43xx_private *bcm, u64 tsf)
+static void bcm43xx_time_lock(struct bcm43xx_wldev *dev)
 {
 	u32 status;
 
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 	status |= BCM43xx_SBF_TIME_UPDATE;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, status);
 	mmiowb();
+}
+
+static void bcm43xx_time_unlock(struct bcm43xx_wldev *dev)
+{
+	u32 status;
 
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
+	status &amp;= ~BCM43xx_SBF_TIME_UPDATE;
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, status);
+}
+
+static void bcm43xx_tsf_write_locked(struct bcm43xx_wldev *dev, u64 tsf)
+{
 	/* Be careful with the in-progress timer.
 	 * First zero out the low register, so we have a full
 	 * register-overflow duration to complete the operation.
 	 */
-	if (bcm-&gt;current_core-&gt;rev &gt;= 3) {
+	if (dev-&gt;dev-&gt;id.revision &gt;= 3) {
 		u32 lo = (tsf &amp; 0x00000000FFFFFFFFULL);
 		u32 hi = (tsf &amp; 0xFFFFFFFF00000000ULL) &gt;&gt; 32;
 
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW, 0);
+		bcm43xx_write32(dev, BCM43xx_MMIO_REV3PLUS_TSF_LOW, 0);
 		mmiowb();
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH, hi);
+		bcm43xx_write32(dev, BCM43xx_MMIO_REV3PLUS_TSF_HIGH, hi);
 		mmiowb();
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW, lo);
+		bcm43xx_write32(dev, BCM43xx_MMIO_REV3PLUS_TSF_LOW, lo);
 	} else {
 		u16 v0 = (tsf &amp; 0x000000000000FFFFULL);
 		u16 v1 = (tsf &amp; 0x00000000FFFF0000ULL) &gt;&gt; 16;
 		u16 v2 = (tsf &amp; 0x0000FFFF00000000ULL) &gt;&gt; 32;
 		u16 v3 = (tsf &amp; 0xFFFF000000000000ULL) &gt;&gt; 48;
 
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_0, 0);
+		bcm43xx_write16(dev, BCM43xx_MMIO_TSF_0, 0);
 		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_3, v3);
+		bcm43xx_write16(dev, BCM43xx_MMIO_TSF_3, v3);
 		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_2, v2);
+		bcm43xx_write16(dev, BCM43xx_MMIO_TSF_2, v2);
 		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_1, v1);
+		bcm43xx_write16(dev, BCM43xx_MMIO_TSF_1, v1);
 		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_0, v0);
+		bcm43xx_write16(dev, BCM43xx_MMIO_TSF_0, v0);
 	}
+}
 
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	status &amp;= ~BCM43xx_SBF_TIME_UPDATE;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
+void bcm43xx_tsf_write(struct bcm43xx_wldev *dev, u64 tsf)
+{
+	bcm43xx_time_lock(dev);
+	bcm43xx_tsf_write_locked(dev, tsf);
+	bcm43xx_time_unlock(dev);
 }
 
 static
-void bcm43xx_macfilter_set(struct bcm43xx_private *bcm,
+void bcm43xx_macfilter_set(struct bcm43xx_wldev *dev,
 			   u16 offset,
 			   const u8 *mac)
 {
+	static const u8 zero_addr[ETH_ALEN] = { 0 };
 	u16 data;
 
+	if (!mac)
+		mac = zero_addr;
+
 	offset |= 0x0020;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_CONTROL, offset);
+	bcm43xx_write16(dev, BCM43xx_MMIO_MACFILTER_CONTROL, offset);
 
 	data = mac[0];
 	data |= mac[1] &lt;&lt; 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
+	bcm43xx_write16(dev, BCM43xx_MMIO_MACFILTER_DATA, data);
 	data = mac[2];
 	data |= mac[3] &lt;&lt; 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
+	bcm43xx_write16(dev, BCM43xx_MMIO_MACFILTER_DATA, data);
 	data = mac[4];
 	data |= mac[5] &lt;&lt; 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
-}
-
-static void bcm43xx_macfilter_clear(struct bcm43xx_private *bcm,
-				    u16 offset)
-{
-	const u8 zero_addr[ETH_ALEN] = { 0 };
-
-	bcm43xx_macfilter_set(bcm, offset, zero_addr);
+	bcm43xx_write16(dev, BCM43xx_MMIO_MACFILTER_DATA, data);
 }
 
-static void bcm43xx_write_mac_bssid_templates(struct bcm43xx_private *bcm)
+static void bcm43xx_write_mac_bssid_templates(struct bcm43xx_wldev *dev)
 {
-	const u8 *mac = (const u8 *)(bcm-&gt;net_dev-&gt;dev_addr);
-	const u8 *bssid = (const u8 *)(bcm-&gt;ieee-&gt;bssid);
+	static const u8 zero_addr[ETH_ALEN] = { 0 };
+	const u8 *mac = dev-&gt;wl-&gt;mac_addr;
+	const u8 *bssid = dev-&gt;wl-&gt;bssid;
 	u8 mac_bssid[ETH_ALEN * 2];
 	int i;
+	u32 tmp;
+
+	if (!bssid)
+		bssid = zero_addr;
+	if (!mac)
+		mac = zero_addr;
+
+	bcm43xx_macfilter_set(dev, BCM43xx_MACFILTER_BSSID, bssid);
 
 	memcpy(mac_bssid, mac, ETH_ALEN);
 	memcpy(mac_bssid + ETH_ALEN, bssid, ETH_ALEN);
 
 	/* Write our MAC address and BSSID to template ram */
-	for (i = 0; i &lt; ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x20 + i, *((u32 *)(mac_bssid + i)));
-	for (i = 0; i &lt; ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x78 + i, *((u32 *)(mac_bssid + i)));
-	for (i = 0; i &lt; ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x478 + i, *((u32 *)(mac_bssid + i)));
-}
-
-//FIXME: Well, we should probably call them from somewhere.
-#if 0
-static void bcm43xx_set_slot_time(struct bcm43xx_private *bcm, u16 slot_time)
-{
-	/* slot_time is in usec. */
-	if (bcm43xx_current_phy(bcm)-&gt;type != BCM43xx_PHYTYPE_G)
-		return;
-	bcm43xx_write16(bcm, 0x684, 510 + slot_time);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0010, slot_time);
+	for (i = 0; i &lt; ARRAY_SIZE(mac_bssid); i += sizeof(u32)) {
+		tmp =  (u32)(mac_bssid[i + 0]);
+		tmp |= (u32)(mac_bssid[i + 1]) &lt;&lt; 8;
+		tmp |= (u32)(mac_bssid[i + 2]) &lt;&lt; 16;
+		tmp |= (u32)(mac_bssid[i + 3]) &lt;&lt; 24;
+		bcm43xx_ram_write(dev, 0x20 + i, tmp);
+		bcm43xx_ram_write(dev, 0x78 + i, tmp);
+		bcm43xx_ram_write(dev, 0x478 + i, tmp);
+	}
 }
 
-static void bcm43xx_short_slot_timing_enable(struct bcm43xx_private *bcm)
+static void bcm43xx_upload_card_macaddress(struct bcm43xx_wldev *dev,
+					   const u8 *mac_addr)
 {
-	bcm43xx_set_slot_time(bcm, 9);
+	dev-&gt;wl-&gt;mac_addr = mac_addr;
+	bcm43xx_write_mac_bssid_templates(dev);
+	bcm43xx_macfilter_set(dev, BCM43xx_MACFILTER_SELF, mac_addr);
 }
 
-static void bcm43xx_short_slot_timing_disable(struct bcm43xx_private *bcm)
+static void bcm43xx_set_slot_time(struct bcm43xx_wldev *dev, u16 slot_time)
 {
-	bcm43xx_set_slot_time(bcm, 20);
+	/* slot_time is in usec. */
+	if (dev-&gt;phy.type != BCM43xx_PHYTYPE_G)
+		return;
+	bcm43xx_write16(dev, 0x684, 510 + slot_time);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0010, slot_time);
 }
-#endif
 
-/* FIXME: To get the MAC-filter working, we need to implement the
- *        following functions (and rename them :)
- */
-#if 0
-static void bcm43xx_disassociate(struct bcm43xx_private *bcm)
+static void bcm43xx_short_slot_timing_enable(struct bcm43xx_wldev *dev)
 {
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_macfilter_clear(bcm, BCM43xx_MACFILTER_ASSOC);
-
-	bcm43xx_ram_write(bcm, 0x0026, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0028, 0x0000);
-	bcm43xx_ram_write(bcm, 0x007E, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0080, 0x0000);
-	bcm43xx_ram_write(bcm, 0x047E, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0480, 0x0000);
-
-	if (bcm-&gt;current_core-&gt;rev &lt; 3) {
-		bcm43xx_write16(bcm, 0x0610, 0x8000);
-		bcm43xx_write16(bcm, 0x060E, 0x0000);
-	} else
-		bcm43xx_write32(bcm, 0x0188, 0x80000000);
-
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0004, 0x000003ff);
-
-	if (bcm43xx_current_phy(bcm)-&gt;type == BCM43xx_PHYTYPE_G &amp;&amp;
-	    ieee80211_is_ofdm_rate(bcm-&gt;softmac-&gt;txrates.default_rate))
-		bcm43xx_short_slot_timing_enable(bcm);
-
-	bcm43xx_mac_enable(bcm);
+	bcm43xx_set_slot_time(dev, 9);
+	dev-&gt;short_slot = 1;
 }
 
-static void bcm43xx_associate(struct bcm43xx_private *bcm,
-			      const u8 *mac)
+static void bcm43xx_short_slot_timing_disable(struct bcm43xx_wldev *dev)
 {
-	memcpy(bcm-&gt;ieee-&gt;bssid, mac, ETH_ALEN);
-
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_macfilter_set(bcm, BCM43xx_MACFILTER_ASSOC, mac);
-	bcm43xx_write_mac_bssid_templates(bcm);
-	bcm43xx_mac_enable(bcm);
+	bcm43xx_set_slot_time(dev, 20);
+	dev-&gt;short_slot = 0;
 }
-#endif
 
 /* Enable a Generic IRQ. &quot;mask&quot; is the mask of which IRQs to enable.
  * Returns the _previously_ enabled IRQ mask.
  */
-static inline u32 bcm43xx_interrupt_enable(struct bcm43xx_private *bcm, u32 mask)
+static inline u32 bcm43xx_interrupt_enable(struct bcm43xx_wldev *dev, u32 mask)
 {
 	u32 old_mask;
 
-	old_mask = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask | mask);
+	old_mask = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
+	bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask | mask);
 
 	return old_mask;
 }
@@ -480,12 +599,12 @@ static inline u32 bcm43xx_interrupt_enab
 /* Disable a Generic IRQ. &quot;mask&quot; is the mask of which IRQs to disable.
  * Returns the _previously_ enabled IRQ mask.
  */
-static inline u32 bcm43xx_interrupt_disable(struct bcm43xx_private *bcm, u32 mask)
+static inline u32 bcm43xx_interrupt_disable(struct bcm43xx_wldev *dev, u32 mask)
 {
 	u32 old_mask;
 
-	old_mask = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask &amp; ~mask);
+	old_mask = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
+	bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask &amp; ~mask);
 
 	return old_mask;
 }
@@ -494,982 +613,364 @@ static inline u32 bcm43xx_interrupt_disa
  * IRQs must be masked before calling this.
  * This must not be called with the irq_lock held.
  */
-static void bcm43xx_synchronize_irq(struct bcm43xx_private *bcm)
-{
-	synchronize_irq(bcm-&gt;irq);
-	tasklet_disable(&amp;bcm-&gt;isr_tasklet);
-}
-
-/* Make sure we don't receive more data from the device. */
-static int bcm43xx_disable_interrupts_sync(struct bcm43xx_private *bcm)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (unlikely(bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)) {
-		spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-		return -EBUSY;
-	}
-	bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-	bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK); /* flush */
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	bcm43xx_synchronize_irq(bcm);
-
-	return 0;
-}
-
-static int bcm43xx_read_radioinfo(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u32 radio_id;
-	u16 manufact;
-	u16 version;
-	u8 revision;
-
-	if (bcm-&gt;chip_id == 0x4317) {
-		if (bcm-&gt;chip_rev == 0x00)
-			radio_id = 0x3205017F;
-		else if (bcm-&gt;chip_rev == 0x01)
-			radio_id = 0x4205017F;
-		else
-			radio_id = 0x5205017F;
-	} else {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, BCM43xx_RADIOCTL_ID);
-		radio_id = bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_DATA_HIGH);
-		radio_id &lt;&lt;= 16;
-		bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, BCM43xx_RADIOCTL_ID);
-		radio_id |= bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_DATA_LOW);
-	}
-
-	manufact = (radio_id &amp; 0x00000FFF);
-	version = (radio_id &amp; 0x0FFFF000) &gt;&gt; 12;
-	revision = (radio_id &amp; 0xF0000000) &gt;&gt; 28;
-
-	dprintk(KERN_INFO PFX &quot;Detected Radio: ID: %x (Manuf: %x Ver: %x Rev: %x)\n&quot;,
-		radio_id, manufact, version, revision);
-
-	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-		if ((version != 0x2060) || (revision != 1) || (manufact != 0x17f))
-			goto err_unsupported_radio;
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if ((version &amp; 0xFFF0) != 0x2050)
-			goto err_unsupported_radio;
-		break;
-	case BCM43xx_PHYTYPE_G:
-		if (version != 0x2050)
-			goto err_unsupported_radio;
-		break;
-	}
-
-	radio-&gt;manufact = manufact;
-	radio-&gt;version = version;
-	radio-&gt;revision = revision;
-
-	if (phy-&gt;type == BCM43xx_PHYTYPE_A)
-		radio-&gt;txpower_desired = bcm-&gt;sprom.maxpower_aphy;
-	else
-		radio-&gt;txpower_desired = bcm-&gt;sprom.maxpower_bgphy;
-
-	return 0;
-
-err_unsupported_radio:
-	printk(KERN_ERR PFX &quot;Unsupported Radio connected to the PHY!\n&quot;);
-	return -ENODEV;
-}
-
-static const char * bcm43xx_locale_iso(u8 locale)
-{
-	/* ISO 3166-1 country codes.
-	 * Note that there aren't ISO 3166-1 codes for
-	 * all or locales. (Not all locales are countries)
-	 */
-	switch (locale) {
-	case BCM43xx_LOCALE_WORLD:
-	case BCM43xx_LOCALE_ALL:
-		return &quot;XX&quot;;
-	case BCM43xx_LOCALE_THAILAND:
-		return &quot;TH&quot;;
-	case BCM43xx_LOCALE_ISRAEL:
-		return &quot;IL&quot;;
-	case BCM43xx_LOCALE_JORDAN:
-		return &quot;JO&quot;;
-	case BCM43xx_LOCALE_CHINA:
-		return &quot;CN&quot;;
-	case BCM43xx_LOCALE_JAPAN:
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		return &quot;JP&quot;;
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-	case BCM43xx_LOCALE_USA_LOW:
-		return &quot;US&quot;;
-	case BCM43xx_LOCALE_EUROPE:
-		return &quot;EU&quot;;
-	case BCM43xx_LOCALE_NONE:
-		return &quot;  &quot;;
-	}
-	assert(0);
-	return &quot;  &quot;;
-}
-
-static const char * bcm43xx_locale_string(u8 locale)
-{
-	switch (locale) {
-	case BCM43xx_LOCALE_WORLD:
-		return &quot;World&quot;;
-	case BCM43xx_LOCALE_THAILAND:
-		return &quot;Thailand&quot;;
-	case BCM43xx_LOCALE_ISRAEL:
-		return &quot;Israel&quot;;
-	case BCM43xx_LOCALE_JORDAN:
-		return &quot;Jordan&quot;;
-	case BCM43xx_LOCALE_CHINA:
-		return &quot;China&quot;;
-	case BCM43xx_LOCALE_JAPAN:
-		return &quot;Japan&quot;;
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-		return &quot;USA/Canada/ANZ&quot;;
-	case BCM43xx_LOCALE_EUROPE:
-		return &quot;Europe&quot;;
-	case BCM43xx_LOCALE_USA_LOW:
-		return &quot;USAlow&quot;;
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		return &quot;JapanHigh&quot;;
-	case BCM43xx_LOCALE_ALL:
-		return &quot;All&quot;;
-	case BCM43xx_LOCALE_NONE:
-		return &quot;None&quot;;
-	}
-	assert(0);
-	return &quot;&quot;;
-}
-
-static inline u8 bcm43xx_crc8(u8 crc, u8 data)
-{
-	static const u8 t[] = {
-		0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
-		0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
-		0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
-		0xDE, 0x29, 0x67, 0x90, 0xFB, 0x0C, 0x42, 0xB5,
-		0x7F, 0x88, 0xC6, 0x31, 0x5A, 0xAD, 0xE3, 0x14,
-		0x35, 0xC2, 0x8C, 0x7B, 0x10, 0xE7, 0xA9, 0x5E,
-		0xEB, 0x1C, 0x52, 0xA5, 0xCE, 0x39, 0x77, 0x80,
-		0xA1, 0x56, 0x18, 0xEF, 0x84, 0x73, 0x3D, 0xCA,
-		0xFE, 0x09, 0x47, 0xB0, 0xDB, 0x2C, 0x62, 0x95,
-		0xB4, 0x43, 0x0D, 0xFA, 0x91, 0x66, 0x28, 0xDF,
-		0x6A, 0x9D, 0xD3, 0x24, 0x4F, 0xB8, 0xF6, 0x01,
-		0x20, 0xD7, 0x99, 0x6E, 0x05, 0xF2, 0xBC, 0x4B,
-		0x81, 0x76, 0x38, 0xCF, 0xA4, 0x53, 0x1D, 0xEA,
-		0xCB, 0x3C, 0x72, 0x85, 0xEE, 0x19, 0x57, 0xA0,
-		0x15, 0xE2, 0xAC, 0x5B, 0x30, 0xC7, 0x89, 0x7E,
-		0x5F, 0xA8, 0xE6, 0x11, 0x7A, 0x8D, 0xC3, 0x34,
-		0xAB, 0x5C, 0x12, 0xE5, 0x8E, 0x79, 0x37, 0xC0,
-		0xE1, 0x16, 0x58, 0xAF, 0xC4, 0x33, 0x7D, 0x8A,
-		0x3F, 0xC8, 0x86, 0x71, 0x1A, 0xED, 0xA3, 0x54,
-		0x75, 0x82, 0xCC, 0x3B, 0x50, 0xA7, 0xE9, 0x1E,
-		0xD4, 0x23, 0x6D, 0x9A, 0xF1, 0x06, 0x48, 0xBF,
-		0x9E, 0x69, 0x27, 0xD0, 0xBB, 0x4C, 0x02, 0xF5,
-		0x40, 0xB7, 0xF9, 0x0E, 0x65, 0x92, 0xDC, 0x2B,
-		0x0A, 0xFD, 0xB3, 0x44, 0x2F, 0xD8, 0x96, 0x61,
-		0x55, 0xA2, 0xEC, 0x1B, 0x70, 0x87, 0xC9, 0x3E,
-		0x1F, 0xE8, 0xA6, 0x51, 0x3A, 0xCD, 0x83, 0x74,
-		0xC1, 0x36, 0x78, 0x8F, 0xE4, 0x13, 0x5D, 0xAA,
-		0x8B, 0x7C, 0x32, 0xC5, 0xAE, 0x59, 0x17, 0xE0,
-		0x2A, 0xDD, 0x93, 0x64, 0x0F, 0xF8, 0xB6, 0x41,
-		0x60, 0x97, 0xD9, 0x2E, 0x45, 0xB2, 0xFC, 0x0B,
-		0xBE, 0x49, 0x07, 0xF0, 0x9B, 0x6C, 0x22, 0xD5,
-		0xF4, 0x03, 0x4D, 0xBA, 0xD1, 0x26, 0x68, 0x9F,
-	};
-	return t[crc ^ data];
-}
-
-static u8 bcm43xx_sprom_crc(const u16 *sprom)
-{
-	int word;
-	u8 crc = 0xFF;
-
-	for (word = 0; word &lt; BCM43xx_SPROM_SIZE - 1; word++) {
-		crc = bcm43xx_crc8(crc, sprom[word] &amp; 0x00FF);
-		crc = bcm43xx_crc8(crc, (sprom[word] &amp; 0xFF00) &gt;&gt; 8);
-	}
-	crc = bcm43xx_crc8(crc, sprom[BCM43xx_SPROM_VERSION] &amp; 0x00FF);
-	crc ^= 0xFF;
-
-	return crc;
-}
-
-int bcm43xx_sprom_read(struct bcm43xx_private *bcm, u16 *sprom)
-{
-	int i;
-	u8 crc, expected_crc;
-
-	for (i = 0; i &lt; BCM43xx_SPROM_SIZE; i++)
-		sprom[i] = bcm43xx_read16(bcm, BCM43xx_SPROM_BASE + (i * 2));
-	/* CRC-8 check. */
-	crc = bcm43xx_sprom_crc(sprom);
-	expected_crc = (sprom[BCM43xx_SPROM_VERSION] &amp; 0xFF00) &gt;&gt; 8;
-	if (crc != expected_crc) {
-		printk(KERN_WARNING PFX &quot;WARNING: Invalid SPROM checksum &quot;
-					&quot;(0x%02X, expected: 0x%02X)\n&quot;,
-		       crc, expected_crc);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int bcm43xx_sprom_write(struct bcm43xx_private *bcm, const u16 *sprom)
-{
-	int i, err;
-	u8 crc, expected_crc;
-	u32 spromctl;
-
-	/* CRC-8 validation of the input data. */
-	crc = bcm43xx_sprom_crc(sprom);
-	expected_crc = (sprom[BCM43xx_SPROM_VERSION] &amp; 0xFF00) &gt;&gt; 8;
-	if (crc != expected_crc) {
-		printk(KERN_ERR PFX &quot;SPROM input data: Invalid CRC\n&quot;);
-		return -EINVAL;
-	}
-
-	printk(KERN_INFO PFX &quot;Writing SPROM. Do NOT turn off the power! Please stand by...\n&quot;);
-	err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_SPROMCTL, &amp;spromctl);
-	if (err)
-		goto err_ctlreg;
-	spromctl |= 0x10; /* SPROM WRITE enable. */
-	err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_SPROMCTL, spromctl);
-	if (err)
-		goto err_ctlreg;
-	/* We must burn lots of CPU cycles here, but that does not
-	 * really matter as one does not write the SPROM every other minute...
-	 */
-	printk(KERN_INFO PFX &quot;[ 0%%&quot;);
-	mdelay(500);
-	for (i = 0; i &lt; BCM43xx_SPROM_SIZE; i++) {
-		if (i == 16)
-			printk(&quot;25%%&quot;);
-		else if (i == 32)
-			printk(&quot;50%%&quot;);
-		else if (i == 48)
-			printk(&quot;75%%&quot;);
-		else if (i % 2)
-			printk(&quot;.&quot;);
-		bcm43xx_write16(bcm, BCM43xx_SPROM_BASE + (i * 2), sprom[i]);
-		mmiowb();
-		mdelay(20);
-	}
-	spromctl &amp;= ~0x10; /* SPROM WRITE enable. */
-	err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_SPROMCTL, spromctl);
-	if (err)
-		goto err_ctlreg;
-	mdelay(500);
-	printk(&quot;100%% ]\n&quot;);
-	printk(KERN_INFO PFX &quot;SPROM written.\n&quot;);
-	bcm43xx_controller_restart(bcm, &quot;SPROM update&quot;);
-
-	return 0;
-err_ctlreg:
-	printk(KERN_ERR PFX &quot;Could not access SPROM control register.\n&quot;);
-	return -ENODEV;
-}
-
-static int bcm43xx_sprom_extract(struct bcm43xx_private *bcm)
-{
-	u16 value;
-	u16 *sprom;
-
-	sprom = kzalloc(BCM43xx_SPROM_SIZE * sizeof(u16),
-			GFP_KERNEL);
-	if (!sprom) {
-		printk(KERN_ERR PFX &quot;sprom_extract OOM\n&quot;);
-		return -ENOMEM;
-	}
-	bcm43xx_sprom_read(bcm, sprom);
-
-	/* boardflags2 */
-	value = sprom[BCM43xx_SPROM_BOARDFLAGS2];
-	bcm-&gt;sprom.boardflags2 = value;
-
-	/* il0macaddr */
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 0];
-	*(((u16 *)bcm-&gt;sprom.il0macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 1];
-	*(((u16 *)bcm-&gt;sprom.il0macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 2];
-	*(((u16 *)bcm-&gt;sprom.il0macaddr) + 2) = cpu_to_be16(value);
-
-	/* et0macaddr */
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 0];
-	*(((u16 *)bcm-&gt;sprom.et0macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 1];
-	*(((u16 *)bcm-&gt;sprom.et0macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 2];
-	*(((u16 *)bcm-&gt;sprom.et0macaddr) + 2) = cpu_to_be16(value);
-
-	/* et1macaddr */
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 0];
-	*(((u16 *)bcm-&gt;sprom.et1macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 1];
-	*(((u16 *)bcm-&gt;sprom.et1macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 2];
-	*(((u16 *)bcm-&gt;sprom.et1macaddr) + 2) = cpu_to_be16(value);
-
-	/* ethernet phy settings */
-	value = sprom[BCM43xx_SPROM_ETHPHY];
-	bcm-&gt;sprom.et0phyaddr = (value &amp; 0x001F);
-	bcm-&gt;sprom.et1phyaddr = (value &amp; 0x03E0) &gt;&gt; 5;
-
-	/* boardrev, antennas, locale */
-	value = sprom[BCM43xx_SPROM_BOARDREV];
-	bcm-&gt;sprom.boardrev = (value &amp; 0x00FF);
-	bcm-&gt;sprom.locale = (value &amp; 0x0F00) &gt;&gt; 8;
-	bcm-&gt;sprom.antennas_aphy = (value &amp; 0x3000) &gt;&gt; 12;
-	bcm-&gt;sprom.antennas_bgphy = (value &amp; 0xC000) &gt;&gt; 14;
-	if (modparam_locale != -1) {
-		if (modparam_locale &gt;= 0 &amp;&amp; modparam_locale &lt;= 11) {
-			bcm-&gt;sprom.locale = modparam_locale;
-			printk(KERN_WARNING PFX &quot;Operating with modified &quot;
-						&quot;LocaleCode %u (%s)\n&quot;,
-			       bcm-&gt;sprom.locale,
-			       bcm43xx_locale_string(bcm-&gt;sprom.locale));
-		} else {
-			printk(KERN_WARNING PFX &quot;Module parameter \&quot;locale\&quot; &quot;
-						&quot;invalid value. (0 - 11)\n&quot;);
-		}
-	}
-
-	/* pa0b* */
-	value = sprom[BCM43xx_SPROM_PA0B0];
-	bcm-&gt;sprom.pa0b0 = value;
-	value = sprom[BCM43xx_SPROM_PA0B1];
-	bcm-&gt;sprom.pa0b1 = value;
-	value = sprom[BCM43xx_SPROM_PA0B2];
-	bcm-&gt;sprom.pa0b2 = value;
-
-	/* wl0gpio* */
-	value = sprom[BCM43xx_SPROM_WL0GPIO0];
-	if (value == 0x0000)
-		value = 0xFFFF;
-	bcm-&gt;sprom.wl0gpio0 = value &amp; 0x00FF;
-	bcm-&gt;sprom.wl0gpio1 = (value &amp; 0xFF00) &gt;&gt; 8;
-	value = sprom[BCM43xx_SPROM_WL0GPIO2];
-	if (value == 0x0000)
-		value = 0xFFFF;
-	bcm-&gt;sprom.wl0gpio2 = value &amp; 0x00FF;
-	bcm-&gt;sprom.wl0gpio3 = (value &amp; 0xFF00) &gt;&gt; 8;
-
-	/* maxpower */
-	value = sprom[BCM43xx_SPROM_MAXPWR];
-	bcm-&gt;sprom.maxpower_aphy = (value &amp; 0xFF00) &gt;&gt; 8;
-	bcm-&gt;sprom.maxpower_bgphy = value &amp; 0x00FF;
-
-	/* pa1b* */
-	value = sprom[BCM43xx_SPROM_PA1B0];
-	bcm-&gt;sprom.pa1b0 = value;
-	value = sprom[BCM43xx_SPROM_PA1B1];
-	bcm-&gt;sprom.pa1b1 = value;
-	value = sprom[BCM43xx_SPROM_PA1B2];
-	bcm-&gt;sprom.pa1b2 = value;
-
-	/* idle tssi target */
-	value = sprom[BCM43xx_SPROM_IDL_TSSI_TGT];
-	bcm-&gt;sprom.idle_tssi_tgt_aphy = value &amp; 0x00FF;
-	bcm-&gt;sprom.idle_tssi_tgt_bgphy = (value &amp; 0xFF00) &gt;&gt; 8;
-
-	/* boardflags */
-	value = sprom[BCM43xx_SPROM_BOARDFLAGS];
-	if (value == 0xFFFF)
-		value = 0x0000;
-	bcm-&gt;sprom.boardflags = value;
-	/* boardflags workarounds */
-	if (bcm-&gt;board_vendor == PCI_VENDOR_ID_DELL &amp;&amp;
-	    bcm-&gt;chip_id == 0x4301 &amp;&amp;
-	    bcm-&gt;board_revision == 0x74)
-		bcm-&gt;sprom.boardflags |= BCM43xx_BFL_BTCOEXIST;
-	if (bcm-&gt;board_vendor == PCI_VENDOR_ID_APPLE &amp;&amp;
-	    bcm-&gt;board_type == 0x4E &amp;&amp;
-	    bcm-&gt;board_revision &gt; 0x40)
-		bcm-&gt;sprom.boardflags |= BCM43xx_BFL_PACTRL;
-
-	/* antenna gain */
-	value = sprom[BCM43xx_SPROM_ANTENNA_GAIN];
-	if (value == 0x0000 || value == 0xFFFF)
-		value = 0x0202;
-	/* convert values to Q5.2 */
-	bcm-&gt;sprom.antennagain_aphy = ((value &amp; 0xFF00) &gt;&gt; 8) * 4;
-	bcm-&gt;sprom.antennagain_bgphy = (value &amp; 0x00FF) * 4;
-
-	kfree(sprom);
-
-	return 0;
-}
-
-static int bcm43xx_geo_init(struct bcm43xx_private *bcm)
+static void bcm43xx_synchronize_irq(struct bcm43xx_wldev *dev)
 {
-	struct ieee80211_geo *geo;
-	struct ieee80211_channel *chan;
-	int have_a = 0, have_bg = 0;
-	int i;
-	u8 channel;
-	struct bcm43xx_phyinfo *phy;
-	const char *iso_country;
-	u8 max_bg_channel;
-
-	geo = kzalloc(sizeof(*geo), GFP_KERNEL);
-	if (!geo)
-		return -ENOMEM;
-
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++) {
-		phy = &amp;(bcm-&gt;core_80211_ext[i].phy);
-		switch (phy-&gt;type) {
-		case BCM43xx_PHYTYPE_B:
-		case BCM43xx_PHYTYPE_G:
-			have_bg = 1;
-			break;
-		case BCM43xx_PHYTYPE_A:
-			have_a = 1;
-			break;
-		default:
-			assert(0);
-		}
-	}
-	iso_country = bcm43xx_locale_iso(bcm-&gt;sprom.locale);
-
-/* set the maximum channel based on locale set in sprom or witle locale option */
-	switch (bcm-&gt;sprom.locale) {
-	case BCM43xx_LOCALE_THAILAND:
-	case BCM43xx_LOCALE_ISRAEL:
-	case BCM43xx_LOCALE_JORDAN:
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-	case BCM43xx_LOCALE_USA_LOW:
-		max_bg_channel = 11;
-		break;
-	case BCM43xx_LOCALE_JAPAN:
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		max_bg_channel = 14;
-		break;
-	default:
-		max_bg_channel = 13;
-	}
-
- 	if (have_a) {
-		for (i = 0, channel = IEEE80211_52GHZ_MIN_CHANNEL;
-		      channel &lt;= IEEE80211_52GHZ_MAX_CHANNEL; channel++) {
-			chan = &amp;geo-&gt;a[i++];
-			chan-&gt;freq = bcm43xx_channel_to_freq_a(channel);
-			chan-&gt;channel = channel;
-		}
-		geo-&gt;a_channels = i;
-	}
-	if (have_bg) {
-		for (i = 0, channel = IEEE80211_24GHZ_MIN_CHANNEL;
-		      channel &lt;= max_bg_channel; channel++) {
-			chan = &amp;geo-&gt;bg[i++];
-			chan-&gt;freq = bcm43xx_channel_to_freq_bg(channel);
-			chan-&gt;channel = channel;
-		}
-		geo-&gt;bg_channels = i;
-	}
-	memcpy(geo-&gt;name, iso_country, 2);
-	if (0 /*TODO: Outdoor use only */)
-		geo-&gt;name[2] = 'O';
-	else if (0 /*TODO: Indoor use only */)
-		geo-&gt;name[2] = 'I';
-	else
-		geo-&gt;name[2] = ' ';
-	geo-&gt;name[3] = '\0';
-
-	ieee80211_set_geo(bcm-&gt;ieee, geo);
-	kfree(geo);
-
-	return 0;
+	synchronize_irq(dev-&gt;dev-&gt;irq);
+	tasklet_kill(&amp;dev-&gt;isr_tasklet);
 }
 
-/* DummyTransmission function, as documented on 
+/* DummyTransmission function, as documented on
  * <A HREF="http://bcm-specs.sipsolutions.net/DummyTransmission">http://bcm-specs.sipsolutions.net/DummyTransmission</A>
  */
-void bcm43xx_dummy_transmission(struct bcm43xx_private *bcm)
+void bcm43xx_dummy_transmission(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &amp;dev-&gt;phy;
 	unsigned int i, max_loop;
-	u16 value = 0;
+	u16 value;
 	u32 buffer[5] = {
 		0x00000000,
-		0x0000D400,
+		0x00D40000,
 		0x00000000,
-		0x00000001,
+		0x01000000,
 		0x00000000,
 	};
 
 	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-		max_loop = 0x1E;
-		buffer[0] = 0xCC010200;
-		break;
 	case BCM43xx_PHYTYPE_B:
 	case BCM43xx_PHYTYPE_G:
 		max_loop = 0xFA;
-		buffer[0] = 0x6E840B00; 
+		buffer[0] = 0x000B846E;
 		break;
 	default:
-		assert(0);
+		BCM43xx_BUG_ON(1);
 		return;
 	}
 
 	for (i = 0; i &lt; 5; i++)
-		bcm43xx_ram_write(bcm, i * 4, buffer[i]);
+		bcm43xx_ram_write(dev, i * 4, buffer[i]);
 
-	bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD); /* dummy read */
+	bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD); /* dummy read */
 
-	bcm43xx_write16(bcm, 0x0568, 0x0000);
-	bcm43xx_write16(bcm, 0x07C0, 0x0000);
-	bcm43xx_write16(bcm, 0x050C, ((phy-&gt;type == BCM43xx_PHYTYPE_A) ? 1 : 0));
-	bcm43xx_write16(bcm, 0x0508, 0x0000);
-	bcm43xx_write16(bcm, 0x050A, 0x0000);
-	bcm43xx_write16(bcm, 0x054C, 0x0000);
-	bcm43xx_write16(bcm, 0x056A, 0x0014);
-	bcm43xx_write16(bcm, 0x0568, 0x0826);
-	bcm43xx_write16(bcm, 0x0500, 0x0000);
-	bcm43xx_write16(bcm, 0x0502, 0x0030);
+	bcm43xx_write16(dev, 0x0568, 0x0000);
+	bcm43xx_write16(dev, 0x07C0, 0x0000);
+	bcm43xx_write16(dev, 0x050C, 0x0000);
+	bcm43xx_write16(dev, 0x0508, 0x0000);
+	bcm43xx_write16(dev, 0x050A, 0x0000);
+	bcm43xx_write16(dev, 0x054C, 0x0000);
+	bcm43xx_write16(dev, 0x056A, 0x0014);
+	bcm43xx_write16(dev, 0x0568, 0x0826);
+	bcm43xx_write16(dev, 0x0500, 0x0000);
+	bcm43xx_write16(dev, 0x0502, 0x0030);
 
-	if (radio-&gt;version == 0x2050 &amp;&amp; radio-&gt;revision &lt;= 0x5)
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0017);
+	if (phy-&gt;radio_ver == 0x2050 &amp;&amp; phy-&gt;radio_rev &lt;= 0x5)
+		bcm43xx_radio_write16(dev, 0x0051, 0x0017);
 	for (i = 0x00; i &lt; max_loop; i++) {
-		value = bcm43xx_read16(bcm, 0x050E);
+		value = bcm43xx_read16(dev, 0x050E);
 		if (value &amp; 0x0080)
 			break;
 		udelay(10);
 	}
 	for (i = 0x00; i &lt; 0x0A; i++) {
-		value = bcm43xx_read16(bcm, 0x050E);
+		value = bcm43xx_read16(dev, 0x050E);
 		if (value &amp; 0x0400)
 			break;
 		udelay(10);
 	}
 	for (i = 0x00; i &lt; 0x0A; i++) {
-		value = bcm43xx_read16(bcm, 0x0690);
+		value = bcm43xx_read16(dev, 0x0690);
 		if (!(value &amp; 0x0100))
 			break;
 		udelay(10);
 	}
-	if (radio-&gt;version == 0x2050 &amp;&amp; radio-&gt;revision &lt;= 0x5)
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0037);
+	if (phy-&gt;radio_ver == 0x2050 &amp;&amp; phy-&gt;radio_rev &lt;= 0x5)
+		bcm43xx_radio_write16(dev, 0x0051, 0x0037);
 }
 
-static void key_write(struct bcm43xx_private *bcm,
-		      u8 index, u8 algorithm, const u16 *key)
+static void key_write(struct bcm43xx_wldev *dev,
+		      u8 index, u8 algorithm, const u8 *key)
 {
-	unsigned int i, basic_wep = 0;
+	unsigned int i;
 	u32 offset;
 	u16 value;
- 
-	/* Write associated key information */
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x100 + (index * 2),
-			    ((index &lt;&lt; 4) | (algorithm &amp; 0x0F)));
- 
-	/* The first 4 WEP keys need extra love */
-	if (((algorithm == BCM43xx_SEC_ALGO_WEP) ||
-	    (algorithm == BCM43xx_SEC_ALGO_WEP104)) &amp;&amp; (index &lt; 4))
-		basic_wep = 1;
- 
-	/* Write key payload, 8 little endian words */
-	offset = bcm-&gt;security_offset + (index * BCM43xx_SEC_KEYSIZE);
-	for (i = 0; i &lt; (BCM43xx_SEC_KEYSIZE / sizeof(u16)); i++) {
-		value = cpu_to_le16(key[i]);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    offset + (i * 2), value);
- 
-		if (!basic_wep)
-			continue;
- 
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    offset + (i * 2) + 4 * BCM43xx_SEC_KEYSIZE,
-				    value);
+	u16 kidx;
+
+	/* Key index/algo block */
+	kidx = bcm43xx_kidx_to_fw(dev, index);
+	value = ((kidx &lt;&lt; 4) | algorithm);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_KEYIDXBLOCK +
+			    (kidx * 2), value);
+
+	/* Write the key to the Key Table Pointer offset */
+	offset = dev-&gt;ktp + (index * BCM43xx_SEC_KEYSIZE);
+	for (i = 0; i &lt; BCM43xx_SEC_KEYSIZE; i += 2) {
+		value = key[i];
+		value |= (u16)(key[i + 1]) &lt;&lt; 8;
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+				    offset + i, value);
 	}
 }
 
-static void keymac_write(struct bcm43xx_private *bcm,
-			 u8 index, const u32 *addr)
+static void keymac_write(struct bcm43xx_wldev *dev,
+			 u8 index, const u8 *addr)
 {
 	/* for keys 0-3 there is no associated mac address */
 	if (index &lt; 4)
 		return;
 
 	index -= 4;
-	if (bcm-&gt;current_core-&gt;rev &gt;= 5) {
-		bcm43xx_shm_write32(bcm,
-				    BCM43xx_SHM_HWMAC,
+	if (dev-&gt;dev-&gt;id.revision &gt;= 5) {
+		bcm43xx_shm_write32(dev,
+				    BCM43xx_SHM_HW,
 				    index * 2,
 				    cpu_to_be32(*addr));
-		bcm43xx_shm_write16(bcm,
-				    BCM43xx_SHM_HWMAC,
+		bcm43xx_shm_write16(dev,
+				    BCM43xx_SHM_HW,
 				    (index * 2) + 1,
 				    cpu_to_be16(*((u16 *)(addr + 1))));
 	} else {
-		if (index &lt; 8) {
-			TODO(); /* Put them in the macaddress filter */
+		if (index &lt; 4) {
+			bcm43xx_macfilter_set(dev, BCM43xx_MACFILTER_MAC +
+					      index * 3, addr);
 		} else {
-			TODO();
 			/* Put them BCM43xx_SHM_SHARED, stating index 0x0120.
-			   Keep in mind to update the count of keymacs in 0x003E as well! */
+			   Update the count of keymacs in 0x003E as well */
+			bcm43xx_shm_write32(dev,
+					    BCM43xx_SHM_SHARED,
+					    (index - 4) * 6 + 0x120,
+					    cpu_to_be32(*addr));
+			bcm43xx_shm_write16(dev,
+					    BCM43xx_SHM_SHARED,
+					    (index - 4) * 6 + 0x124,
+					    cpu_to_be16(*((u16 *)(addr + 1))));
+			bcm43xx_shm_write32(dev,	/* update count */
+					    BCM43xx_SHM_SHARED, 0x003E,
+					    bcm43xx_shm_read32(dev,
+					    BCM43xx_SHM_SHARED, 0x003E) + 1);
 		}
 	}
 }
 
-static int bcm43xx_key_write(struct bcm43xx_private *bcm,
-			     u8 index, u8 algorithm,
-			     const u8 *_key, int key_len,
-			     const u8 *mac_addr)
+static void do_key_write(struct bcm43xx_wldev *dev,
+			 u8 index, u8 algorithm,
+			 const u8 *key, size_t key_len,
+			 const u8 *mac_addr)
+{
+	u8 buf[BCM43xx_SEC_KEYSIZE];
+
+	BCM43xx_WARN_ON(index &gt;= dev-&gt;max_nr_keys);
+	BCM43xx_WARN_ON(key_len &gt; BCM43xx_SEC_KEYSIZE);
+
+	memset(buf, 0, sizeof(buf));
+	if (index &gt;= 8)
+		keymac_write(dev, index, buf); /* First zero out mac. */
+	memcpy(buf, key, key_len);
+	key_write(dev, index, algorithm, buf);
+	if (index &gt;= 8)
+		keymac_write(dev, index, mac_addr);
+
+	dev-&gt;key[index].algorithm = algorithm;
+}
+
+static int bcm43xx_key_write(struct bcm43xx_wldev *dev,
+			     int index, u8 algorithm,
+			     const u8 *key, size_t key_len,
+			     const u8 *mac_addr,
+			     struct ieee80211_key_conf *keyconf)
 {
-	u8 key[BCM43xx_SEC_KEYSIZE] = { 0 };
+	int i;
+	int sta_keys_start;
 
-	if (index &gt;= ARRAY_SIZE(bcm-&gt;key))
-		return -EINVAL;
-	if (key_len &gt; ARRAY_SIZE(key))
-		return -EINVAL;
-	if (algorithm &lt; 1 || algorithm &gt; 5)
+	if (key_len &gt; BCM43xx_SEC_KEYSIZE)
 		return -EINVAL;
+	if (index &lt; 0) {
+		/* Per station key with associated MAC address.
+		 * Look if it already exists, if yes update, otherwise
+		 * allocate a new key.
+		 */
+		if (bcm43xx_new_kidx_api(dev))
+			sta_keys_start = 4;
+		else
+			sta_keys_start = 8;
+		for (i = sta_keys_start; i &lt; dev-&gt;max_nr_keys; i++) {
+			if (compare_ether_addr(dev-&gt;key[i].address, mac_addr)
+			     == 0) {
+				/* found existing */
+				index = i;
+				break;
+			}
+		}
+		if (index &lt; 0) {
+			for (i = sta_keys_start; i &lt; dev-&gt;max_nr_keys; i++) {
+				if (!dev-&gt;key[i].enabled) {
+					/* found empty */
+					index = i;
+					break;
+				}
+			}
+		}
+		if (index &lt; 0) {
+			bcmerr(dev-&gt;wl, &quot;Out of hardware key memory\n&quot;);
+			return -ENOBUFS;
+		}
+	} else {
+		BCM43xx_WARN_ON(index &gt; 3);
+	}
 
-	memcpy(key, _key, key_len);
-	key_write(bcm, index, algorithm, (const u16 *)key);
-	keymac_write(bcm, index, (const u32 *)mac_addr);
-
-	bcm-&gt;key[index].algorithm = algorithm;
+	do_key_write(dev, index, algorithm, key, key_len, mac_addr);
+	if ((index &lt;= 3) &amp;&amp; !bcm43xx_new_kidx_api(dev)) {
+		/* Default RX key */
+		BCM43xx_WARN_ON(mac_addr != NULL);
+		do_key_write(dev, index + 4, algorithm, key, key_len, NULL);
+	}
+	keyconf-&gt;hw_key_idx = index;
 
 	return 0;
 }
 
-static void bcm43xx_clear_keys(struct bcm43xx_private *bcm)
+static void bcm43xx_clear_keys(struct bcm43xx_wldev *dev)
 {
-	static const u32 zero_mac[2] = { 0 };
-	unsigned int i,j, nr_keys = 54;
-	u16 offset;
+	static const u8 zero[BCM43xx_SEC_KEYSIZE] = { 0 };
+	unsigned int i;
 
-	if (bcm-&gt;current_core-&gt;rev &lt; 5)
-		nr_keys = 16;
-	assert(nr_keys &lt;= ARRAY_SIZE(bcm-&gt;key));
-
-	for (i = 0; i &lt; nr_keys; i++) {
-		bcm-&gt;key[i].enabled = 0;
-		/* returns for i &lt; 4 immediately */
-		keymac_write(bcm, i, zero_mac);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    0x100 + (i * 2), 0x0000);
-		for (j = 0; j &lt; 8; j++) {
-			offset = bcm-&gt;security_offset + (j * 4) + (i * BCM43xx_SEC_KEYSIZE);
-			bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-					    offset, 0x0000);
-		}
+	BUILD_BUG_ON(BCM43xx_SEC_KEYSIZE &lt; ETH_ALEN);
+	for (i = 0; i &lt; dev-&gt;max_nr_keys; i++) {
+		do_key_write(dev, i, BCM43xx_SEC_ALGO_NONE,
+			     zero, BCM43xx_SEC_KEYSIZE,
+			     zero);
+		dev-&gt;key[i].enabled = 0;
 	}
-	dprintk(KERN_INFO PFX &quot;Keys cleared\n&quot;);
 }
 
-/* Lowlevel core-switch function. This is only to be used in
- * bcm43xx_switch_core() and bcm43xx_probe_cores()
- */
-static int _switch_core(struct bcm43xx_private *bcm, int core)
+/* Turn the Analog ON/OFF */
+static void bcm43xx_switch_analog(struct bcm43xx_wldev *dev, int on)
 {
-	int err;
-	int attempts = 0;
-	u32 current_core;
+	bcm43xx_write16(dev, BCM43xx_MMIO_PHY0, on ? 0 : 0xF4);
+}
 
-	assert(core &gt;= 0);
-	while (1) {
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_ACTIVE_CORE,
-						 (core * 0x1000) + 0x18000000);
-		if (unlikely(err))
-			goto error;
-		err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_ACTIVE_CORE,
-						&amp;current_core);
-		if (unlikely(err))
-			goto error;
-		current_core = (current_core - 0x18000000) / 0x1000;
-		if (current_core == core)
-			break;
+void bcm43xx_wireless_core_reset(struct bcm43xx_wldev *dev, u32 flags)
+{
+	u32 tmslow;
+	u32 macctl;
 
-		if (unlikely(attempts++ &gt; BCM43xx_SWITCH_CORE_MAX_RETRIES))
-			goto error;
-		udelay(10);
-	}
+	flags |= BCM43xx_TMSLOW_PHYCLKEN;
+	flags |= BCM43xx_TMSLOW_PHYRESET;
+	ssb_device_enable(dev-&gt;dev, flags);
+	msleep(2); /* Wait for the PLL to turn on. */
 
-	return 0;
-error:
-	printk(KERN_ERR PFX &quot;Failed to switch to core %d\n&quot;, core);
-	return -ENODEV;
+	/* Now take the PHY out of Reset again */
+	tmslow = ssb_read32(dev-&gt;dev, SSB_TMSLOW);
+	tmslow |= SSB_TMSLOW_FGC;
+	tmslow &amp;= ~BCM43xx_TMSLOW_PHYRESET;
+	ssb_write32(dev-&gt;dev, SSB_TMSLOW, tmslow);
+	ssb_read32(dev-&gt;dev, SSB_TMSLOW); /* flush */
+	msleep(1);
+	tmslow &amp;= ~SSB_TMSLOW_FGC;
+	ssb_write32(dev-&gt;dev, SSB_TMSLOW, tmslow);
+	ssb_read32(dev-&gt;dev, SSB_TMSLOW); /* flush */
+	msleep(1);
+
+	/* Turn Analog ON */
+	bcm43xx_switch_analog(dev, 1);
+
+	macctl = bcm43xx_read32(dev, BCM43xx_MMIO_MACCTL);
+	macctl &amp;= ~BCM43xx_MACCTL_GMODE;
+	if (flags &amp; BCM43xx_TMSLOW_GMODE)
+		macctl |= BCM43xx_MACCTL_GMODE;
+	macctl |= BCM43xx_MACCTL_IHR_ENABLED;
+	bcm43xx_write32(dev, BCM43xx_MMIO_MACCTL, macctl);
 }
 
-int bcm43xx_switch_core(struct bcm43xx_private *bcm, struct bcm43xx_coreinfo *new_core)
+static void handle_irq_transmit_status(struct bcm43xx_wldev *dev)
 {
-	int err;
+	u32 v0;
+	u32 v1;
+	u16 tmp;
+	struct bcm43xx_txstatus stat;
 
-	if (unlikely(!new_core))
-		return 0;
-	if (!new_core-&gt;available)
-		return -ENODEV;
-	if (bcm-&gt;current_core == new_core)
-		return 0;
-	err = _switch_core(bcm, new_core-&gt;index);
-	if (unlikely(err))
-		goto out;
+	while (1) {
+		v0 = bcm43xx_read32(dev, BCM43xx_MMIO_XMITSTAT_0);
+		if (!(v0 &amp; 0x00000001))
+			break;
+		v1 = bcm43xx_read32(dev, BCM43xx_MMIO_XMITSTAT_1);
 
-	bcm-&gt;current_core = new_core;
-out:
-	return err;
+		stat.cookie = (v0 &gt;&gt; 16);
+		stat.seq = (v1 &amp; 0x0000FFFF);
+		stat.phy_stat = ((v1 &amp; 0x00FF0000) &gt;&gt; 16);
+		tmp = (v0 &amp; 0x0000FFFF);
+		stat.frame_count = ((tmp &amp; 0xF000) &gt;&gt; 12);
+		stat.rts_count = ((tmp &amp; 0x0F00) &gt;&gt; 8);
+		stat.supp_reason = ((tmp &amp; 0x001C) &gt;&gt; 2);
+		stat.pm_indicated = !!(tmp &amp; 0x0080);
+		stat.intermediate = !!(tmp &amp; 0x0040);
+		stat.for_ampdu = !!(tmp &amp; 0x0020);
+		stat.acked = !!(tmp &amp; 0x0002);
+
+		bcm43xx_handle_txstatus(dev, &amp;stat);
+	}
 }
 
-static int bcm43xx_core_enabled(struct bcm43xx_private *bcm)
+static void drain_txstatus_queue(struct bcm43xx_wldev *dev)
 {
-	u32 value;
-
-	value = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	value &amp;= BCM43xx_SBTMSTATELOW_CLOCK | BCM43xx_SBTMSTATELOW_RESET
-		 | BCM43xx_SBTMSTATELOW_REJECT;
+	u32 dummy;
 
-	return (value == BCM43xx_SBTMSTATELOW_CLOCK);
+	if (dev-&gt;dev-&gt;id.revision &lt; 5)
+		return;
+	/* Read all entries from the microcode TXstatus FIFO
+	 * and throw them away.
+	 */
+	while (1) {
+		dummy = bcm43xx_read32(dev, BCM43xx_MMIO_XMITSTAT_0);
+		if (!(dummy &amp; 0x00000001))
+			break;
+		dummy = bcm43xx_read32(dev, BCM43xx_MMIO_XMITSTAT_1);
+	}
 }
 
-/* disable current core */
-static int bcm43xx_core_disable(struct bcm43xx_private *bcm, u32 core_flags)
+static u32 bcm43xx_jssi_read(struct bcm43xx_wldev *dev)
 {
-	u32 sbtmstatelow;
-	u32 sbtmstatehigh;
-	int i;
-
-	/* fetch sbtmstatelow from core information registers */
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-
-	/* core is already in reset */
-	if (sbtmstatelow &amp; BCM43xx_SBTMSTATELOW_RESET)
-		goto out;
-
-	if (sbtmstatelow &amp; BCM43xx_SBTMSTATELOW_CLOCK) {
-		sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-			       BCM43xx_SBTMSTATELOW_REJECT;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-
-		for (i = 0; i &lt; 1000; i++) {
-			sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-			if (sbtmstatelow &amp; BCM43xx_SBTMSTATELOW_REJECT) {
-				i = -1;
-				break;
-			}
-			udelay(10);
-		}
-		if (i != -1) {
-			printk(KERN_ERR PFX &quot;Error: core_disable() REJECT timeout!\n&quot;);
-			return -EBUSY;
-		}
-
-		for (i = 0; i &lt; 1000; i++) {
-			sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-			if (!(sbtmstatehigh &amp; BCM43xx_SBTMSTATEHIGH_BUSY)) {
-				i = -1;
-				break;
-			}
-			udelay(10);
-		}
-		if (i != -1) {
-			printk(KERN_ERR PFX &quot;Error: core_disable() BUSY timeout!\n&quot;);
-			return -EBUSY;
-		}
-
-		sbtmstatelow = BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-			       BCM43xx_SBTMSTATELOW_REJECT |
-			       BCM43xx_SBTMSTATELOW_RESET |
-			       BCM43xx_SBTMSTATELOW_CLOCK |
-			       core_flags;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-		udelay(10);
-	}
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_RESET |
-		       BCM43xx_SBTMSTATELOW_REJECT |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-
-out:
-	bcm-&gt;current_core-&gt;enabled = 0;
-
-	return 0;
-}
-
-/* enable (reset) current core */
-static int bcm43xx_core_enable(struct bcm43xx_private *bcm, u32 core_flags)
-{
-	u32 sbtmstatelow;
-	u32 sbtmstatehigh;
-	u32 sbimstate;
-	int err;
-
-	err = bcm43xx_core_disable(bcm, core_flags);
-	if (err)
-		goto out;
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-		       BCM43xx_SBTMSTATELOW_RESET |
-		       BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-	if (sbtmstatehigh &amp; BCM43xx_SBTMSTATEHIGH_SERROR) {
-		sbtmstatehigh = 0x00000000;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATEHIGH, sbtmstatehigh);
-	}
-
-	sbimstate = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMSTATE);
-	if (sbimstate &amp; (BCM43xx_SBIMSTATE_IB_ERROR | BCM43xx_SBIMSTATE_TIMEOUT)) {
-		sbimstate &amp;= ~(BCM43xx_SBIMSTATE_IB_ERROR | BCM43xx_SBIMSTATE_TIMEOUT);
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBIMSTATE, sbimstate);
-	}
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-		       BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK | core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	bcm-&gt;current_core-&gt;enabled = 1;
-	assert(err == 0);
-out:
-	return err;
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/80211CoreReset">http://bcm-specs.sipsolutions.net/80211CoreReset</A> */
-void bcm43xx_wireless_core_reset(struct bcm43xx_private *bcm, int connect_phy)
-{
-	u32 flags = 0x00040000;
-
-	if ((bcm43xx_core_enabled(bcm)) &amp;&amp;
-	    !bcm43xx_using_pio(bcm)) {
-	}
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_SHUTTINGDOWN) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				&amp; ~(BCM43xx_SBF_MAC_ENABLED | 0x00000002));
-	} else {
-		if (connect_phy)
-			flags |= BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_phy_connect(bcm, connect_phy);
-		bcm43xx_core_enable(bcm, flags);
-		bcm43xx_write16(bcm, 0x03E6, 0x0000);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-				bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				| BCM43xx_SBF_400);
-	}
-}
-
-static void bcm43xx_wireless_core_disable(struct bcm43xx_private *bcm)
-{
-	bcm43xx_radio_turn_off(bcm);
-	bcm43xx_write16(bcm, 0x03E6, 0x00F4);
-	bcm43xx_core_disable(bcm, 0);
-}
-
-/* Mark the current 80211 core inactive. */
-static void bcm43xx_wireless_core_mark_inactive(struct bcm43xx_private *bcm)
-{
-	u32 sbtmstatelow;
-
-	bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-	bcm43xx_radio_turn_off(bcm);
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	sbtmstatelow &amp;= 0xDFF5FFFF;
-	sbtmstatelow |= 0x000A0000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	sbtmstatelow &amp;= 0xFFF5FFFF;
-	sbtmstatelow |= 0x00080000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-}
+	u32 val = 0;
 
-static void handle_irq_transmit_status(struct bcm43xx_private *bcm)
-{
-	u32 v0, v1;
-	u16 tmp;
-	struct bcm43xx_xmitstatus stat;
-
-	while (1) {
-		v0 = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_0);
-		if (!v0)
-			break;
-		v1 = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_1);
-
-		stat.cookie = (v0 &gt;&gt; 16) &amp; 0x0000FFFF;
-		tmp = (u16)((v0 &amp; 0xFFF0) | ((v0 &amp; 0xF) &gt;&gt; 1));
-		stat.flags = tmp &amp; 0xFF;
-		stat.cnt1 = (tmp &amp; 0x0F00) &gt;&gt; 8;
-		stat.cnt2 = (tmp &amp; 0xF000) &gt;&gt; 12;
-		stat.seq = (u16)(v1 &amp; 0xFFFF);
-		stat.unknown = (u16)((v1 &gt;&gt; 16) &amp; 0xFF);
-
-		bcm43xx_debugfs_log_txstat(bcm, &amp;stat);
-
-		if (stat.flags &amp; BCM43xx_TXSTAT_FLAG_AMPDU)
-			continue;
-		if (stat.flags &amp; BCM43xx_TXSTAT_FLAG_INTER)
-			continue;
+	val = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x40A);
+	val &lt;&lt;= 16;
+	val |= bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x408);
 
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_handle_xmitstatus(bcm, &amp;stat);
-		else
-			bcm43xx_dma_handle_xmitstatus(bcm, &amp;stat);
-	}
+	return val;
 }
 
-static void drain_txstatus_queue(struct bcm43xx_private *bcm)
+static void bcm43xx_jssi_write(struct bcm43xx_wldev *dev, u32 jssi)
 {
-	u32 dummy;
-
-	if (bcm-&gt;current_core-&gt;rev &lt; 5)
-		return;
-	/* Read all entries from the microcode TXstatus FIFO
-	 * and throw them away.
-	 */
-	while (1) {
-		dummy = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_0);
-		if (!dummy)
-			break;
-		dummy = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_1);
-	}
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x408,
+			    (jssi &amp; 0x0000FFFF));
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x40A,
+			    (jssi &amp; 0xFFFF0000) &gt;&gt; 16);
 }
 
-static void bcm43xx_generate_noise_sample(struct bcm43xx_private *bcm)
+static void bcm43xx_generate_noise_sample(struct bcm43xx_wldev *dev)
 {
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x408, 0x7F7F);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x40A, 0x7F7F);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD) | (1 &lt;&lt; 4));
-	assert(bcm-&gt;noisecalc.core_at_start == bcm-&gt;current_core);
-	assert(bcm-&gt;noisecalc.channel_at_start == bcm43xx_current_radio(bcm)-&gt;channel);
+	bcm43xx_jssi_write(dev, 0x7F7F7F7F);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS2_BITFIELD,
+			bcm43xx_read32(dev, BCM43xx_MMIO_STATUS2_BITFIELD)
+			| (1 &lt;&lt; 4));
+	BCM43xx_WARN_ON(dev-&gt;noisecalc.channel_at_start != dev-&gt;phy.channel);
 }
 
-static void bcm43xx_calculate_link_quality(struct bcm43xx_private *bcm)
+static void bcm43xx_calculate_link_quality(struct bcm43xx_wldev *dev)
 {
 	/* Top half of Link Quality calculation. */
 
-	if (bcm-&gt;noisecalc.calculation_running)
+	if (dev-&gt;noisecalc.calculation_running)
 		return;
-	bcm-&gt;noisecalc.core_at_start = bcm-&gt;current_core;
-	bcm-&gt;noisecalc.channel_at_start = bcm43xx_current_radio(bcm)-&gt;channel;
-	bcm-&gt;noisecalc.calculation_running = 1;
-	bcm-&gt;noisecalc.nr_samples = 0;
+	dev-&gt;noisecalc.channel_at_start = dev-&gt;phy.channel;
+	dev-&gt;noisecalc.calculation_running = 1;
+	dev-&gt;noisecalc.nr_samples = 0;
 
-	bcm43xx_generate_noise_sample(bcm);
+	bcm43xx_generate_noise_sample(dev);
 }
 
-static void handle_irq_noise(struct bcm43xx_private *bcm)
+static void handle_irq_noise(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
+	struct bcm43xx_phy *phy = &amp;dev-&gt;phy;
 	u16 tmp;
 	u8 noise[4];
 	u8 i, j;
@@ -1477,45 +978,38 @@ static void handle_irq_noise(struct bcm4
 
 	/* Bottom half of Link Quality calculation. */
 
-	assert(bcm-&gt;noisecalc.calculation_running);
-	if (bcm-&gt;noisecalc.core_at_start != bcm-&gt;current_core ||
-	    bcm-&gt;noisecalc.channel_at_start != radio-&gt;channel)
+	BCM43xx_WARN_ON(!dev-&gt;noisecalc.calculation_running);
+	if (dev-&gt;noisecalc.channel_at_start != phy-&gt;channel)
 		goto drop_calculation;
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x408);
-	noise[0] = (tmp &amp; 0x00FF);
-	noise[1] = (tmp &amp; 0xFF00) &gt;&gt; 8;
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x40A);
-	noise[2] = (tmp &amp; 0x00FF);
-	noise[3] = (tmp &amp; 0xFF00) &gt;&gt; 8;
+	*((u32 *)noise) = cpu_to_le32(bcm43xx_jssi_read(dev));
 	if (noise[0] == 0x7F || noise[1] == 0x7F ||
 	    noise[2] == 0x7F || noise[3] == 0x7F)
 		goto generate_new;
 
 	/* Get the noise samples. */
-	assert(bcm-&gt;noisecalc.nr_samples &lt; 8);
-	i = bcm-&gt;noisecalc.nr_samples;
-	noise[0] = limit_value(noise[0], 0, ARRAY_SIZE(radio-&gt;nrssi_lt) - 1);
-	noise[1] = limit_value(noise[1], 0, ARRAY_SIZE(radio-&gt;nrssi_lt) - 1);
-	noise[2] = limit_value(noise[2], 0, ARRAY_SIZE(radio-&gt;nrssi_lt) - 1);
-	noise[3] = limit_value(noise[3], 0, ARRAY_SIZE(radio-&gt;nrssi_lt) - 1);
-	bcm-&gt;noisecalc.samples[i][0] = radio-&gt;nrssi_lt[noise[0]];
-	bcm-&gt;noisecalc.samples[i][1] = radio-&gt;nrssi_lt[noise[1]];
-	bcm-&gt;noisecalc.samples[i][2] = radio-&gt;nrssi_lt[noise[2]];
-	bcm-&gt;noisecalc.samples[i][3] = radio-&gt;nrssi_lt[noise[3]];
-	bcm-&gt;noisecalc.nr_samples++;
-	if (bcm-&gt;noisecalc.nr_samples == 8) {
+	BCM43xx_WARN_ON(dev-&gt;noisecalc.nr_samples &gt;= 8);
+	i = dev-&gt;noisecalc.nr_samples;
+	noise[0] = limit_value(noise[0], 0, ARRAY_SIZE(phy-&gt;nrssi_lt) - 1);
+	noise[1] = limit_value(noise[1], 0, ARRAY_SIZE(phy-&gt;nrssi_lt) - 1);
+	noise[2] = limit_value(noise[2], 0, ARRAY_SIZE(phy-&gt;nrssi_lt) - 1);
+	noise[3] = limit_value(noise[3], 0, ARRAY_SIZE(phy-&gt;nrssi_lt) - 1);
+	dev-&gt;noisecalc.samples[i][0] = phy-&gt;nrssi_lt[noise[0]];
+	dev-&gt;noisecalc.samples[i][1] = phy-&gt;nrssi_lt[noise[1]];
+	dev-&gt;noisecalc.samples[i][2] = phy-&gt;nrssi_lt[noise[2]];
+	dev-&gt;noisecalc.samples[i][3] = phy-&gt;nrssi_lt[noise[3]];
+	dev-&gt;noisecalc.nr_samples++;
+	if (dev-&gt;noisecalc.nr_samples == 8) {
 		/* Calculate the Link Quality by the noise samples. */
 		average = 0;
 		for (i = 0; i &lt; 8; i++) {
 			for (j = 0; j &lt; 4; j++)
-				average += bcm-&gt;noisecalc.samples[i][j];
+				average += dev-&gt;noisecalc.samples[i][j];
 		}
 		average /= (8 * 4);
 		average *= 125;
 		average += 64;
 		average /= 128;
-
-		tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x40C);
+		tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED, 0x40C);
 		tmp = (tmp / 128) &amp; 0x1F;
 		if (tmp &gt;= 8)
 			average += 2;
@@ -1526,403 +1020,575 @@ static void handle_irq_noise(struct bcm4
 		else
 			average -= 48;
 
-		bcm-&gt;stats.noise = average;
+		dev-&gt;stats.link_noise = average;
 drop_calculation:
-		bcm-&gt;noisecalc.calculation_running = 0;
+		dev-&gt;noisecalc.calculation_running = 0;
 		return;
 	}
 generate_new:
-	bcm43xx_generate_noise_sample(bcm);
+	bcm43xx_generate_noise_sample(dev);
 }
 
-static void handle_irq_ps(struct bcm43xx_private *bcm)
+static void handle_irq_tbtt_indication(struct bcm43xx_wldev *dev)
 {
-	if (bcm-&gt;ieee-&gt;iw_mode == IW_MODE_MASTER) {
-		///TODO: PS TBTT
+	if (bcm43xx_is_mode(dev-&gt;wl, IEEE80211_IF_TYPE_AP)) {
+		/* TODO: PS TBTT */
 	} else {
 		if (1/*FIXME: the last PSpoll frame was sent successfully */)
-			bcm43xx_power_saving_ctl_bits(bcm, -1, -1);
+			bcm43xx_power_saving_ctl_bits(dev, -1, -1);
 	}
-	if (bcm-&gt;ieee-&gt;iw_mode == IW_MODE_ADHOC)
-		bcm-&gt;reg124_set_0x4 = 1;
-	//FIXME else set to false?
+	dev-&gt;reg124_set_0x4 = 0;
+	if (bcm43xx_is_mode(dev-&gt;wl, IEEE80211_IF_TYPE_IBSS))
+		dev-&gt;reg124_set_0x4 = 1;
 }
 
-static void handle_irq_reg124(struct bcm43xx_private *bcm)
+static void handle_irq_atim_end(struct bcm43xx_wldev *dev)
 {
-	if (!bcm-&gt;reg124_set_0x4)
+	if (!dev-&gt;reg124_set_0x4 /*FIXME rename this variable*/)
 		return;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD)
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS2_BITFIELD,
+			bcm43xx_read32(dev, BCM43xx_MMIO_STATUS2_BITFIELD)
 			| 0x4);
-	//FIXME: reset reg124_set_0x4 to false?
 }
 
-static void handle_irq_pmq(struct bcm43xx_private *bcm)
+static void handle_irq_pmq(struct bcm43xx_wldev *dev)
 {
 	u32 tmp;
 
-	//TODO: AP mode.
+	/* TODO: AP mode. */
 
 	while (1) {
-		tmp = bcm43xx_read32(bcm, BCM43xx_MMIO_PS_STATUS);
+		tmp = bcm43xx_read32(dev, BCM43xx_MMIO_PS_STATUS);
 		if (!(tmp &amp; 0x00000008))
 			break;
 	}
 	/* 16bit write is odd, but correct. */
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PS_STATUS, 0x0002);
+	bcm43xx_write16(dev, BCM43xx_MMIO_PS_STATUS, 0x0002);
 }
 
-static void bcm43xx_generate_beacon_template(struct bcm43xx_private *bcm,
-					     u16 ram_offset, u16 shm_size_offset)
+static void bcm43xx_write_template_common(struct bcm43xx_wldev *dev,
+					  const u8 *data, u16 size,
+					  u16 ram_offset,
+					  u16 shm_size_offset, u8 rate)
 {
-	u32 value;
-	u16 size = 0;
+	u32 i;
+	u32 tmp;
+	struct bcm43xx_plcp_hdr4 plcp;
+
+	plcp.data = 0;
+	bcm43xx_generate_plcp_hdr(&amp;plcp, size + FCS_LEN, rate);
+	bcm43xx_ram_write(dev, ram_offset, le32_to_cpu(plcp.data));
+	ram_offset += sizeof(u32);
+	/* The PLCP is 6 bytes long, but we only wrote 4 bytes, yet.
+	 * So leave the first two bytes of the next write blank.
+	 */
+	tmp = (u32)(data[0]) &lt;&lt; 16;
+	tmp |= (u32)(data[1]) &lt;&lt; 24;
+	bcm43xx_ram_write(dev, ram_offset, tmp);
+	ram_offset += sizeof(u32);
+	for (i = 2; i &lt; size; i += sizeof(u32)) {
+		tmp = (u32)(data[i + 0]);
+		if (i + 1 &lt; size)
+			tmp |= (u32)(data[i + 1]) &lt;&lt; 8;
+		if (i + 2 &lt; size)
+			tmp |= (u32)(data[i + 2]) &lt;&lt; 16;
+		if (i + 3 &lt; size)
+			tmp |= (u32)(data[i + 3]) &lt;&lt; 24;
+		bcm43xx_ram_write(dev, ram_offset + i - 2, tmp);
+	}
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, shm_size_offset,
+			    size + sizeof(struct bcm43xx_plcp_hdr6));
+}
+
+static void bcm43xx_write_beacon_template(struct bcm43xx_wldev *dev,
+					  u16 ram_offset,
+					  u16 shm_size_offset, u8 rate)
+{
+	int len;
+	const u8 *data;
+
+	BCM43xx_WARN_ON(!dev-&gt;cached_beacon);
+	len = min((size_t)dev-&gt;cached_beacon-&gt;len,
+		  0x200 - sizeof(struct bcm43xx_plcp_hdr6));
+	data = (const u8 *)(dev-&gt;cached_beacon-&gt;data);
+	bcm43xx_write_template_common(dev, data,
+				      len, ram_offset,
+				      shm_size_offset, rate);
+}
+
+static void bcm43xx_write_probe_resp_plcp(struct bcm43xx_wldev *dev,
+					  u16 shm_offset, u16 size, u8 rate)
+{
+	struct bcm43xx_plcp_hdr4 plcp;
+	u32 tmp;
+	__le16 dur;
+
+	plcp.data = 0;
+	bcm43xx_generate_plcp_hdr(&amp;plcp, size + FCS_LEN, rate);
+	dur = ieee80211_generic_frame_duration(dev-&gt;wl-&gt;hw,
+					       size,
+					       BCM43xx_RATE_TO_100KBPS(rate));
+	/* Write PLCP in two parts and timing for packet transfer */
+	tmp = le32_to_cpu(plcp.data);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, shm_offset,
+			    tmp &amp; 0xFFFF);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, shm_offset + 2,
+			    tmp &gt;&gt; 16);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, shm_offset + 6,
+			    le16_to_cpu(dur));
+}
+
+/* Instead of using custom probe response template, this function
+ * just patches custom beacon template by:
+ * 1) Changing packet type
+ * 2) Patching duration field
+ * 3) Stripping TIM
+ */
+static u8 *bcm43xx_generate_probe_resp(struct bcm43xx_wldev *dev,
+					u16 *dest_size, u8 rate)
+{
+	const u8 *src_data;
+	u8 *dest_data;
+	u16 src_size;
+	u16 elem_size;
+	u16 src_pos;
+	u16 dest_pos;
+	__le16 dur;
+	struct ieee80211_hdr *hdr;
+
+	BCM43xx_WARN_ON(!dev-&gt;cached_beacon);
+	src_size = dev-&gt;cached_beacon-&gt;len;
+	src_data = (const u8 *)dev-&gt;cached_beacon-&gt;data;
+
+	if (unlikely(src_size &lt; 0x24)) {
+		bcmdbg(dev-&gt;wl, &quot;bcm43xx_generate_probe_resp: &quot;
+		       &quot;invalid beacon\n&quot;);
+		return NULL;
+	}
+
+	dest_data = kmalloc(src_size, GFP_ATOMIC);
+	if (unlikely(!dest_data))
+		return NULL;
+
+	/* 0x24 is offset of first variable-len Information-Element
+	 * in beacon frame.
+	 */
+	memcpy(dest_data, src_data, 0x24);
+	src_pos = 0x24;
+	dest_pos = 0x24;
+	for ( ; src_pos &lt; src_size - 2; src_pos += elem_size) {
+		elem_size = src_data[src_pos + 1] + 2;
+		if (src_data[src_pos] != 0x05) { /* TIM */
+			memcpy(dest_data + dest_pos, src_data + src_pos,
+			       elem_size);
+			dest_pos += elem_size;
+		}
+	}
+	*dest_size = dest_pos;
+	hdr = (struct ieee80211_hdr *)dest_data;
+
+	/* Set the frame control. */
+	hdr-&gt;frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					 IEEE80211_STYPE_PROBE_RESP);
+	dur = ieee80211_generic_frame_duration(dev-&gt;wl-&gt;hw,
+					       *dest_size,
+					       BCM43xx_RATE_TO_100KBPS(rate));
+	hdr-&gt;duration_id = dur;
+
+	return dest_data;
+}
+
+static void bcm43xx_write_probe_resp_template(struct bcm43xx_wldev *dev,
+					      u16 ram_offset,
+					      u16 shm_size_offset, u8 rate)
+{
+	u8 *probe_resp_data;
+	u16 size;
+
+	BCM43xx_WARN_ON(!dev-&gt;cached_beacon);
+	size = dev-&gt;cached_beacon-&gt;len;
+	probe_resp_data = bcm43xx_generate_probe_resp(dev, &amp;size, rate);
+	if (unlikely(!probe_resp_data))
+		return;
 
-	/* Timestamp. */
-	//FIXME: assumption: The chip sets the timestamp
-	value = 0;
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	size += 8;
+	/* Looks like PLCP headers plus packet timings are stored for
+	 * all possible basic rates
+	 */
+	bcm43xx_write_probe_resp_plcp(dev, 0x31A, size,
+				      BCM43xx_CCK_RATE_1MB);
+	bcm43xx_write_probe_resp_plcp(dev, 0x32C, size,
+				      BCM43xx_CCK_RATE_2MB);
+	bcm43xx_write_probe_resp_plcp(dev, 0x33E, size,
+				      BCM43xx_CCK_RATE_5MB);
+	bcm43xx_write_probe_resp_plcp(dev, 0x350, size,
+				      BCM43xx_CCK_RATE_11MB);
+
+	size = min((size_t)size,
+		   0x200 - sizeof(struct bcm43xx_plcp_hdr6));
+	bcm43xx_write_template_common(dev, probe_resp_data,
+				      size, ram_offset,
+				      shm_size_offset, rate);
+	kfree(probe_resp_data);
+}
+
+static int bcm43xx_refresh_cached_beacon(struct bcm43xx_wldev *dev,
+					 struct sk_buff *beacon)
+{
+	if (dev-&gt;cached_beacon)
+		kfree_skb(dev-&gt;cached_beacon);
+	dev-&gt;cached_beacon = beacon;
+
+	return 0;
+}
 
-	/* Beacon Interval / Capability Information */
-	value = 0x0000;//FIXME: Which interval?
-	value |= (1 &lt;&lt; 0) &lt;&lt; 16; /* ESS */
-	value |= (1 &lt;&lt; 2) &lt;&lt; 16; /* CF Pollable */	//FIXME?
-	value |= (1 &lt;&lt; 3) &lt;&lt; 16; /* CF Poll Request */	//FIXME?
-	if (!bcm-&gt;ieee-&gt;open_wep)
-		value |= (1 &lt;&lt; 4) &lt;&lt; 16; /* Privacy */
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	size += 4;
+static void bcm43xx_update_templates(struct bcm43xx_wldev *dev)
+{
+	u32 status;
 
-	/* SSID */
-	//TODO
+	BCM43xx_WARN_ON(!dev-&gt;cached_beacon);
 
-	/* FH Parameter Set */
-	//TODO
+	bcm43xx_write_beacon_template(dev, 0x68, 0x18,
+				      BCM43xx_CCK_RATE_1MB);
+	bcm43xx_write_beacon_template(dev, 0x468, 0x1A,
+				      BCM43xx_CCK_RATE_1MB);
+	bcm43xx_write_probe_resp_template(dev, 0x268, 0x4A,
+					  BCM43xx_CCK_RATE_11MB);
+
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS2_BITFIELD);
+	status |= 0x03;
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS2_BITFIELD, status);
+}
 
-	/* DS Parameter Set */
-	//TODO
+static void bcm43xx_refresh_templates(struct bcm43xx_wldev *dev,
+				      struct sk_buff *beacon)
+{
+	int err;
 
-	/* CF Parameter Set */
-	//TODO
+	err = bcm43xx_refresh_cached_beacon(dev, beacon);
+	if (unlikely(err))
+		return;
+	bcm43xx_update_templates(dev);
+}
 
-	/* TIM */
-	//TODO
+static void bcm43xx_set_ssid(struct bcm43xx_wldev *dev,
+			     const u8 *ssid, u8 ssid_len)
+{
+	u32 tmp;
+	u16 i;
+	u16 len;
 
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, shm_size_offset, size);
+	len = min((u16)ssid_len, (u16)0x100);
+	for (i = 0; i &lt; len; i += sizeof(u32)) {
+		tmp = (u32)(ssid[i + 0]);
+		if (i + 1 &lt; len)
+			tmp |= (u32)(ssid[i + 1]) &lt;&lt; 8;
+		if (i + 2 &lt; len)
+			tmp |= (u32)(ssid[i + 2]) &lt;&lt; 16;
+		if (i + 3 &lt; len)
+			tmp |= (u32)(ssid[i + 3]) &lt;&lt; 24;
+		bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED,
+				    0x380 + i, tmp);
+	}
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    0x48, len);
+}
+
+static void bcm43xx_set_beacon_int(struct bcm43xx_wldev *dev, u16 beacon_int)
+{
+	bcm43xx_time_lock(dev);
+	if (dev-&gt;dev-&gt;id.revision &gt;= 3) {
+		bcm43xx_write32(dev, 0x188, (beacon_int &lt;&lt; 16));
+	} else {
+		bcm43xx_write16(dev, 0x606, (beacon_int &gt;&gt; 6));
+		bcm43xx_write16(dev, 0x610, beacon_int);
+	}
+	bcm43xx_time_unlock(dev);
 }
 
-static void handle_irq_beacon(struct bcm43xx_private *bcm)
+static void handle_irq_beacon(struct bcm43xx_wldev *dev)
 {
 	u32 status;
 
-	bcm-&gt;irq_savedstate &amp;= ~BCM43xx_IRQ_BEACON;
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD);
+	if (!bcm43xx_is_mode(dev-&gt;wl, IEEE80211_IF_TYPE_AP))
+		return;
+
+	dev-&gt;irq_savedstate &amp;= ~BCM43xx_IRQ_BEACON;
+	status = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS2_BITFIELD);
 
-	if ((status &amp; 0x1) &amp;&amp; (status &amp; 0x2)) {
+	if (!dev-&gt;cached_beacon || ((status &amp; 0x1) &amp;&amp; (status &amp; 0x2))) {
 		/* ACK beacon IRQ. */
-		bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON,
+		bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_REASON,
 				BCM43xx_IRQ_BEACON);
-		bcm-&gt;irq_savedstate |= BCM43xx_IRQ_BEACON;
+		dev-&gt;irq_savedstate |= BCM43xx_IRQ_BEACON;
+		if (dev-&gt;cached_beacon)
+			kfree_skb(dev-&gt;cached_beacon);
+		dev-&gt;cached_beacon = NULL;
 		return;
 	}
 	if (!(status &amp; 0x1)) {
-		bcm43xx_generate_beacon_template(bcm, 0x68, 0x18);
+		bcm43xx_write_beacon_template(dev, 0x68, 0x18,
+					      BCM43xx_CCK_RATE_1MB);
 		status |= 0x1;
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD, status);
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS2_BITFIELD,
+				status);
 	}
 	if (!(status &amp; 0x2)) {
-		bcm43xx_generate_beacon_template(bcm, 0x468, 0x1A);
+		bcm43xx_write_beacon_template(dev, 0x468, 0x1A,
+					      BCM43xx_CCK_RATE_1MB);
 		status |= 0x2;
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD, status);
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS2_BITFIELD,
+				status);
 	}
 }
 
+static void handle_irq_ucode_debug(struct bcm43xx_wldev *dev)
+{
+}
+
 /* Interrupt handler bottom-half */
-static void bcm43xx_interrupt_tasklet(struct bcm43xx_private *bcm)
+static void bcm43xx_interrupt_tasklet(struct bcm43xx_wldev *dev)
 {
 	u32 reason;
-	u32 dma_reason[6];
+	u32 dma_reason[ARRAY_SIZE(dev-&gt;dma_reason)];
 	u32 merged_dma_reason = 0;
 	int i, activity = 0;
 	unsigned long flags;
 
-#ifdef CONFIG_BCM43XX_DEBUG
-	u32 _handled = 0x00000000;
-# define bcmirq_handled(irq)	do { _handled |= (irq); } while (0)
-#else
-# define bcmirq_handled(irq)	do { /* nothing */ } while (0)
-#endif /* CONFIG_BCM43XX_DEBUG*/
-
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	reason = bcm-&gt;irq_reason;
-	for (i = 5; i &gt;= 0; i--) {
-		dma_reason[i] = bcm-&gt;dma_reason[i];
-		merged_dma_reason |= dma_reason[i];
-	}
-
-	if (unlikely(reason &amp; BCM43xx_IRQ_XMIT_ERROR)) {
-		/* TX error. We get this when Template Ram is written in wrong endianess
-		 * in dummy_tx(). We also get this if something is wrong with the TX header
-		 * on DMA or PIO queues.
-		 * Maybe we get this in other error conditions, too.
-		 */
-		printkl(KERN_ERR PFX &quot;FATAL ERROR: BCM43xx_IRQ_XMIT_ERROR\n&quot;);
-		bcmirq_handled(BCM43xx_IRQ_XMIT_ERROR);
-	}
-	if (unlikely(merged_dma_reason &amp; BCM43xx_DMAIRQ_FATALMASK)) {
-		printkl(KERN_ERR PFX &quot;FATAL ERROR: Fatal DMA error: &quot;
-				     &quot;0x%08X, 0x%08X, 0x%08X, &quot;
-				     &quot;0x%08X, 0x%08X, 0x%08X\n&quot;,
-		        dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3],
-			dma_reason[4], dma_reason[5]);
-		bcm43xx_controller_restart(bcm, &quot;DMA error&quot;);
-		mmiowb();
-		spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-		return;
-	}
-	if (unlikely(merged_dma_reason &amp; BCM43xx_DMAIRQ_NONFATALMASK)) {
-		printkl(KERN_ERR PFX &quot;DMA error: &quot;
-				     &quot;0x%08X, 0x%08X, 0x%08X, &quot;
-				     &quot;0x%08X, 0x%08X, 0x%08X\n&quot;,
-		        dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3],
-			dma_reason[4], dma_reason[5]);
-	}
-
-	if (reason &amp; BCM43xx_IRQ_PS) {
-		handle_irq_ps(bcm);
-		bcmirq_handled(BCM43xx_IRQ_PS);
-	}
+	spin_lock_irqsave(&amp;dev-&gt;wl-&gt;irq_lock, flags);
 
-	if (reason &amp; BCM43xx_IRQ_REG124) {
-		handle_irq_reg124(bcm);
-		bcmirq_handled(BCM43xx_IRQ_REG124);
-	}
+	BCM43xx_WARN_ON(bcm43xx_status(dev) &lt; BCM43xx_STAT_INITIALIZED);
 
-	if (reason &amp; BCM43xx_IRQ_BEACON) {
-		if (bcm-&gt;ieee-&gt;iw_mode == IW_MODE_MASTER)
-			handle_irq_beacon(bcm);
-		bcmirq_handled(BCM43xx_IRQ_BEACON);
+	reason = dev-&gt;irq_reason;
+	for (i = 0; i &lt; ARRAY_SIZE(dma_reason); i++) {
+		dma_reason[i] = dev-&gt;dma_reason[i];
+		merged_dma_reason |= dma_reason[i];
 	}
 
-	if (reason &amp; BCM43xx_IRQ_PMQ) {
-		handle_irq_pmq(bcm);
-		bcmirq_handled(BCM43xx_IRQ_PMQ);
-	}
+	if (unlikely(reason &amp; BCM43xx_IRQ_MAC_TXERR))
+		bcmerr(dev-&gt;wl, &quot;MAC transmission error\n&quot;);
 
-	if (reason &amp; BCM43xx_IRQ_SCAN) {
-		/*TODO*/
-		//bcmirq_handled(BCM43xx_IRQ_SCAN);
-	}
+	if (unlikely(reason &amp; BCM43xx_IRQ_PHY_TXERR))
+		bcmerr(dev-&gt;wl, &quot;PHY transmission error\n&quot;);
 
-	if (reason &amp; BCM43xx_IRQ_NOISE) {
-		handle_irq_noise(bcm);
-		bcmirq_handled(BCM43xx_IRQ_NOISE);
-	}
+	if (unlikely(merged_dma_reason &amp; (BCM43xx_DMAIRQ_FATALMASK |
+					  BCM43xx_DMAIRQ_NONFATALMASK))) {
+		if (merged_dma_reason &amp; BCM43xx_DMAIRQ_FATALMASK) {
+			bcmerr(dev-&gt;wl, &quot;Fatal DMA error: &quot;
+			       &quot;0x%08X, 0x%08X, 0x%08X, &quot;
+			       &quot;0x%08X, 0x%08X, 0x%08X\n&quot;,
+			       dma_reason[0], dma_reason[1],
+			       dma_reason[2], dma_reason[3],
+			       dma_reason[4], dma_reason[5]);
+			bcm43xx_controller_restart(dev, &quot;DMA error&quot;);
+			mmiowb();
+			spin_unlock_irqrestore(&amp;dev-&gt;wl-&gt;irq_lock, flags);
+			return;
+		}
+		if (merged_dma_reason &amp; BCM43xx_DMAIRQ_NONFATALMASK)
+			bcmerr(dev-&gt;wl, &quot;DMA error: &quot;
+			       &quot;0x%08X, 0x%08X, 0x%08X, &quot;
+			       &quot;0x%08X, 0x%08X, 0x%08X\n&quot;,
+			       dma_reason[0], dma_reason[1],
+			       dma_reason[2], dma_reason[3],
+			       dma_reason[4], dma_reason[5]);
+	}
+
+	if (unlikely(reason &amp; BCM43xx_IRQ_UCODE_DEBUG))
+		handle_irq_ucode_debug(dev);
+	if (reason &amp; BCM43xx_IRQ_TBTT_INDI)
+		handle_irq_tbtt_indication(dev);
+	if (reason &amp; BCM43xx_IRQ_ATIM_END)
+		handle_irq_atim_end(dev);
+	if (reason &amp; BCM43xx_IRQ_BEACON)
+		handle_irq_beacon(dev);
+	if (reason &amp; BCM43xx_IRQ_PMQ)
+		handle_irq_pmq(dev);
+	if (reason &amp; BCM43xx_IRQ_TXFIFO_FLUSH_OK)
+		;/*TODO*/
+	if (reason &amp; BCM43xx_IRQ_NOISESAMPLE_OK)
+		handle_irq_noise(dev);
 
 	/* Check the DMA reason registers for received data. */
 	if (dma_reason[0] &amp; BCM43xx_DMAIRQ_RX_DONE) {
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_rx(bcm43xx_current_pio(bcm)-&gt;queue0);
+		if (bcm43xx_using_pio(dev))
+			bcm43xx_pio_rx(dev-&gt;pio.queue0);
 		else
-			bcm43xx_dma_rx(bcm43xx_current_dma(bcm)-&gt;rx_ring0);
+			bcm43xx_dma_rx(dev-&gt;dma.rx_ring0);
 		/* We intentionally don't set &quot;activity&quot; to 1, here. */
 	}
-	assert(!(dma_reason[1] &amp; BCM43xx_DMAIRQ_RX_DONE));
-	assert(!(dma_reason[2] &amp; BCM43xx_DMAIRQ_RX_DONE));
+	BCM43xx_WARN_ON(dma_reason[1] &amp; BCM43xx_DMAIRQ_RX_DONE);
+	BCM43xx_WARN_ON(dma_reason[2] &amp; BCM43xx_DMAIRQ_RX_DONE);
 	if (dma_reason[3] &amp; BCM43xx_DMAIRQ_RX_DONE) {
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_rx(bcm43xx_current_pio(bcm)-&gt;queue3);
+		if (bcm43xx_using_pio(dev))
+			bcm43xx_pio_rx(dev-&gt;pio.queue3);
 		else
-			bcm43xx_dma_rx(bcm43xx_current_dma(bcm)-&gt;rx_ring3);
+			bcm43xx_dma_rx(dev-&gt;dma.rx_ring3);
 		activity = 1;
 	}
-	assert(!(dma_reason[4] &amp; BCM43xx_DMAIRQ_RX_DONE));
-	assert(!(dma_reason[5] &amp; BCM43xx_DMAIRQ_RX_DONE));
-	bcmirq_handled(BCM43xx_IRQ_RX);
+	BCM43xx_WARN_ON(dma_reason[4] &amp; BCM43xx_DMAIRQ_RX_DONE);
+	BCM43xx_WARN_ON(dma_reason[5] &amp; BCM43xx_DMAIRQ_RX_DONE);
 
-	if (reason &amp; BCM43xx_IRQ_XMIT_STATUS) {
-		handle_irq_transmit_status(bcm);
+	if (reason &amp; BCM43xx_IRQ_TX_OK) {
+		handle_irq_transmit_status(dev);
 		activity = 1;
-		//TODO: In AP mode, this also causes sending of powersave responses.
-		bcmirq_handled(BCM43xx_IRQ_XMIT_STATUS);
+		/* TODO: In AP mode, this also causes sending of powersave
+			 responses. */
 	}
 
-	/* IRQ_PIO_WORKAROUND is handled in the top-half. */
-	bcmirq_handled(BCM43xx_IRQ_PIO_WORKAROUND);
-#ifdef CONFIG_BCM43XX_DEBUG
-	if (unlikely(reason &amp; ~_handled)) {
-		printkl(KERN_WARNING PFX
-			&quot;Unhandled IRQ! Reason: 0x%08x,  Unhandled: 0x%08x,  &quot;
-			&quot;DMA: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n&quot;,
-			reason, (reason &amp; ~_handled),
-			dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3]);
-	}
-#endif
-#undef bcmirq_handled
-
 	if (!modparam_noleds)
-		bcm43xx_leds_update(bcm, activity);
-	bcm43xx_interrupt_enable(bcm, bcm-&gt;irq_savedstate);
+		bcm43xx_leds_update(dev, activity);
+	bcm43xx_interrupt_enable(dev, dev-&gt;irq_savedstate);
 	mmiowb();
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
+	spin_unlock_irqrestore(&amp;dev-&gt;wl-&gt;irq_lock, flags);
 }
 
-static void pio_irq_workaround(struct bcm43xx_private *bcm,
+static void pio_irq_workaround(struct bcm43xx_wldev *dev,
 			       u16 base, int queueidx)
 {
 	u16 rxctl;
 
-	rxctl = bcm43xx_read16(bcm, base + BCM43xx_PIO_RXCTL);
+	rxctl = bcm43xx_read16(dev, base + BCM43xx_PIO_RXCTL);
 	if (rxctl &amp; BCM43xx_PIO_RXCTL_DATAAVAILABLE)
-		bcm-&gt;dma_reason[queueidx] |= BCM43xx_DMAIRQ_RX_DONE;
+		dev-&gt;dma_reason[queueidx] |= BCM43xx_DMAIRQ_RX_DONE;
 	else
-		bcm-&gt;dma_reason[queueidx] &amp;= ~BCM43xx_DMAIRQ_RX_DONE;
+		dev-&gt;dma_reason[queueidx] &amp;= ~BCM43xx_DMAIRQ_RX_DONE;
 }
 
-static void bcm43xx_interrupt_ack(struct bcm43xx_private *bcm, u32 reason)
+static void bcm43xx_interrupt_ack(struct bcm43xx_wldev *dev, u32 reason)
 {
-	if (bcm43xx_using_pio(bcm) &amp;&amp;
-	    (bcm-&gt;current_core-&gt;rev &lt; 3) &amp;&amp;
+	if (bcm43xx_using_pio(dev) &amp;&amp;
+	    (dev-&gt;dev-&gt;id.revision &lt; 3) &amp;&amp;
 	    (!(reason &amp; BCM43xx_IRQ_PIO_WORKAROUND))) {
 		/* Apply a PIO specific workaround to the dma_reasons */
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO1_BASE, 0);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO2_BASE, 1);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO3_BASE, 2);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO4_BASE, 3);
-	}
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, reason);
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA0_REASON,
-			bcm-&gt;dma_reason[0]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA1_REASON,
-			bcm-&gt;dma_reason[1]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA2_REASON,
-			bcm-&gt;dma_reason[2]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA3_REASON,
-			bcm-&gt;dma_reason[3]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA4_REASON,
-			bcm-&gt;dma_reason[4]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA5_REASON,
-			bcm-&gt;dma_reason[5]);
+		pio_irq_workaround(dev, BCM43xx_MMIO_PIO1_BASE, 0);
+		pio_irq_workaround(dev, BCM43xx_MMIO_PIO2_BASE, 1);
+		pio_irq_workaround(dev, BCM43xx_MMIO_PIO3_BASE, 2);
+		pio_irq_workaround(dev, BCM43xx_MMIO_PIO4_BASE, 3);
+	}
+
+	bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_REASON, reason);
+
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA0_REASON,
+			dev-&gt;dma_reason[0]);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA1_REASON,
+			dev-&gt;dma_reason[1]);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA2_REASON,
+			dev-&gt;dma_reason[2]);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA3_REASON,
+			dev-&gt;dma_reason[3]);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA4_REASON,
+			dev-&gt;dma_reason[4]);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA5_REASON,
+			dev-&gt;dma_reason[5]);
 }
 
 /* Interrupt handler top-half */
 static irqreturn_t bcm43xx_interrupt_handler(int irq, void *dev_id)
 {
 	irqreturn_t ret = IRQ_HANDLED;
-	struct bcm43xx_private *bcm = dev_id;
+	struct bcm43xx_wldev *dev = dev_id;
 	u32 reason;
 
-	if (!bcm)
+	if (!dev)
 		return IRQ_NONE;
 
-	spin_lock(&amp;bcm-&gt;irq_lock);
+	spin_lock(&amp;dev-&gt;wl-&gt;irq_lock);
 
-	reason = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-	if (reason == 0xffffffff) {
-		/* irq not for us (shared irq) */
-		ret = IRQ_NONE;
+	if (bcm43xx_status(dev) &lt; BCM43xx_STAT_INITIALIZED)
 		goto out;
-	}
-	reason &amp;= bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
+	reason = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
+	if (reason == 0xffffffff) /* shared IRQ */
+		goto out;
+	reason &amp;= bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK);
 	if (!reason)
 		goto out;
 
-	assert(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED);
-	assert(bcm-&gt;current_core-&gt;id == BCM43xx_COREID_80211);
+	BCM43xx_WARN_ON(bcm43xx_status(dev) &lt; BCM43xx_STAT_INITIALIZED);
 
-	bcm-&gt;dma_reason[0] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA0_REASON)
+	dev-&gt;dma_reason[0] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA0_REASON)
 			     &amp; 0x0001DC00;
-	bcm-&gt;dma_reason[1] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA1_REASON)
+	dev-&gt;dma_reason[1] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA1_REASON)
 			     &amp; 0x0000DC00;
-	bcm-&gt;dma_reason[2] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA2_REASON)
+	dev-&gt;dma_reason[2] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA2_REASON)
 			     &amp; 0x0000DC00;
-	bcm-&gt;dma_reason[3] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA3_REASON)
+	dev-&gt;dma_reason[3] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA3_REASON)
 			     &amp; 0x0001DC00;
-	bcm-&gt;dma_reason[4] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA4_REASON)
+	dev-&gt;dma_reason[4] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA4_REASON)
 			     &amp; 0x0000DC00;
-	bcm-&gt;dma_reason[5] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA5_REASON)
+	dev-&gt;dma_reason[5] = bcm43xx_read32(dev, BCM43xx_MMIO_DMA5_REASON)
 			     &amp; 0x0000DC00;
 
-	bcm43xx_interrupt_ack(bcm, reason);
-
+	bcm43xx_interrupt_ack(dev, reason);
 	/* disable all IRQs. They are enabled again in the bottom half. */
-	bcm-&gt;irq_savedstate = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
+	dev-&gt;irq_savedstate = bcm43xx_interrupt_disable(dev, BCM43xx_IRQ_ALL);
 	/* save the reason code and call our bottom half. */
-	bcm-&gt;irq_reason = reason;
-	tasklet_schedule(&amp;bcm-&gt;isr_tasklet);
-
+	dev-&gt;irq_reason = reason;
+	tasklet_schedule(&amp;dev-&gt;isr_tasklet);
 out:
 	mmiowb();
-	spin_unlock(&amp;bcm-&gt;irq_lock);
+	spin_unlock(&amp;dev-&gt;wl-&gt;irq_lock);
 
 	return ret;
 }
 
-static void bcm43xx_release_firmware(struct bcm43xx_private *bcm, int force)
+static void bcm43xx_release_firmware(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	if (bcm-&gt;firmware_norelease &amp;&amp; !force)
-		return; /* Suspending or controller reset. */
-	release_firmware(phy-&gt;ucode);
-	phy-&gt;ucode = NULL;
-	release_firmware(phy-&gt;pcm);
-	phy-&gt;pcm = NULL;
-	release_firmware(phy-&gt;initvals0);
-	phy-&gt;initvals0 = NULL;
-	release_firmware(phy-&gt;initvals1);
-	phy-&gt;initvals1 = NULL;
+	release_firmware(dev-&gt;fw.ucode);
+	dev-&gt;fw.ucode = NULL;
+	release_firmware(dev-&gt;fw.pcm);
+	dev-&gt;fw.pcm = NULL;
+	release_firmware(dev-&gt;fw.initvals0);
+	dev-&gt;fw.initvals0 = NULL;
+	release_firmware(dev-&gt;fw.initvals1);
+	dev-&gt;fw.initvals1 = NULL;
 }
 
-static int bcm43xx_request_firmware(struct bcm43xx_private *bcm)
+static int bcm43xx_request_firmware(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u8 rev = bcm-&gt;current_core-&gt;rev;
+	u8 rev = dev-&gt;dev-&gt;id.revision;
 	int err = 0;
 	int nr;
 	char buf[22 + sizeof(modparam_fwpostfix) - 1] = { 0 };
 
-	if (!phy-&gt;ucode) {
+	if (!dev-&gt;fw.ucode) {
 		snprintf(buf, ARRAY_SIZE(buf), &quot;bcm43xx_microcode%d%s.fw&quot;,
 			 (rev &gt;= 5 ? 5 : rev),
 			 modparam_fwpostfix);
-		err = request_firmware(&amp;phy-&gt;ucode, buf, &amp;bcm-&gt;pci_dev-&gt;dev);
+		err = request_firmware(&amp;dev-&gt;fw.ucode, buf, dev-&gt;dev-&gt;dev);
 		if (err) {
-			printk(KERN_ERR PFX 
-			       &quot;Error: Microcode \&quot;%s\&quot; not available or load failed.\n&quot;,
-			        buf);
-			goto error;
+			snprintf(buf, ARRAY_SIZE(buf), &quot;bcm43xx_microcode%d.fw&quot;,
+				 (rev &gt;= 5 ? 5 : rev));
+			err = request_firmware(&amp;dev-&gt;fw.ucode, buf,
+					       dev-&gt;dev-&gt;dev);
+			if (err) {
+				bcmerr(dev-&gt;wl, &quot;Microcode \&quot;%s\&quot; not &quot;
+				       &quot;available or load failed.\n&quot;, buf);
+				goto error;
+			}
 		}
+		bcminfo(dev-&gt;wl, &quot;bcm43xx: Microcode %s loaded\n&quot;, buf);
 	}
 
-	if (!phy-&gt;pcm) {
-		snprintf(buf, ARRAY_SIZE(buf),
-			 &quot;bcm43xx_pcm%d%s.fw&quot;,
-			 (rev &lt; 5 ? 4 : 5),
-			 modparam_fwpostfix);
-		err = request_firmware(&amp;phy-&gt;pcm, buf, &amp;bcm-&gt;pci_dev-&gt;dev);
+	if (!dev-&gt;fw.pcm) {
+		snprintf(buf, ARRAY_SIZE(buf), &quot;bcm43xx_pcm%d%s.fw&quot;,
+			 (rev &lt; 5 ? 4 : 5), modparam_fwpostfix);
+		err = request_firmware(&amp;dev-&gt;fw.pcm, buf, dev-&gt;dev-&gt;dev);
 		if (err) {
-			printk(KERN_ERR PFX
-			       &quot;Error: PCM \&quot;%s\&quot; not available or load failed.\n&quot;,
-			       buf);
-			goto error;
+			snprintf(buf, ARRAY_SIZE(buf), &quot;bcm43xx_pcm%d.fw&quot;,
+				 (rev &lt; 5 ? 4 : 5));
+			err = request_firmware(&amp;dev-&gt;fw.pcm, buf,
+					       dev-&gt;dev-&gt;dev);
+			if (err) {
+				bcmerr(dev-&gt;wl, &quot;PCM \&quot;%s\&quot; not available &quot;
+				       &quot;or load failed.\n&quot;, buf);
+				goto error;
+			}
 		}
 	}
 
-	if (!phy-&gt;initvals0) {
+	if (!dev-&gt;fw.initvals0) {
 		if (rev == 2 || rev == 4) {
-			switch (phy-&gt;type) {
-			case BCM43xx_PHYTYPE_A:
-				nr = 3;
-				break;
+			switch (dev-&gt;phy.type) {
 			case BCM43xx_PHYTYPE_B:
 			case BCM43xx_PHYTYPE_G:
 				nr = 1;
@@ -1930,12 +1596,9 @@ static int bcm43xx_request_firmware(stru
 			default:
 				goto err_noinitval;
 			}
-		
+
 		} else if (rev &gt;= 5) {
-			switch (phy-&gt;type) {
-			case BCM43xx_PHYTYPE_A:
-				nr = 7;
-				break;
+			switch (dev-&gt;phy.type) {
 			case BCM43xx_PHYTYPE_B:
 			case BCM43xx_PHYTYPE_G:
 				nr = 5;
@@ -1943,36 +1606,34 @@ static int bcm43xx_request_firmware(stru
 			default:
 				goto err_noinitval;
 			}
-		} else
+		} else {
 			goto err_noinitval;
+		}
 		snprintf(buf, ARRAY_SIZE(buf), &quot;bcm43xx_initval%02d%s.fw&quot;,
 			 nr, modparam_fwpostfix);
 
-		err = request_firmware(&amp;phy-&gt;initvals0, buf, &amp;bcm-&gt;pci_dev-&gt;dev);
+		err = request_firmware(&amp;dev-&gt;fw.initvals0, buf, dev-&gt;dev-&gt;dev);
 		if (err) {
-			printk(KERN_ERR PFX 
-			       &quot;Error: InitVals \&quot;%s\&quot; not available or load failed.\n&quot;,
-			        buf);
-			goto error;
+			snprintf(buf, ARRAY_SIZE(buf), &quot;bcm43xx_initval%02d.fw&quot;,
+				 nr);
+
+			err = request_firmware(&amp;dev-&gt;fw.initvals0, buf,
+					       dev-&gt;dev-&gt;dev);
+			if (err) {
+				bcmerr(dev-&gt;wl, &quot;InitVals \&quot;%s\&quot; not available &quot;
+				       &quot;or load failed.\n&quot;, buf);
+				goto error;
+			}
 		}
-		if (phy-&gt;initvals0-&gt;size % sizeof(struct bcm43xx_initval)) {
-			printk(KERN_ERR PFX &quot;InitVals fileformat error.\n&quot;);
+		if (dev-&gt;fw.initvals0-&gt;size % sizeof(struct bcm43xx_initval)) {
+			bcmerr(dev-&gt;wl, &quot;InitVals fileformat error.\n&quot;);
 			goto error;
 		}
 	}
 
-	if (!phy-&gt;initvals1) {
+	if (!dev-&gt;fw.initvals1) {
 		if (rev &gt;= 5) {
-			u32 sbtmstatehigh;
-
-			switch (phy-&gt;type) {
-			case BCM43xx_PHYTYPE_A:
-				sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-				if (sbtmstatehigh &amp; 0x00010000)
-					nr = 9;
-				else
-					nr = 10;
-				break;
+			switch (dev-&gt;phy.type) {
 			case BCM43xx_PHYTYPE_B:
 			case BCM43xx_PHYTYPE_G:
 					nr = 6;
@@ -1980,18 +1641,28 @@ static int bcm43xx_request_firmware(stru
 			default:
 				goto err_noinitval;
 			}
-			snprintf(buf, ARRAY_SIZE(buf), &quot;bcm43xx_initval%02d%s.fw&quot;,
+			snprintf(buf, ARRAY_SIZE(buf),
+				 &quot;bcm43xx_initval%02d%s.fw&quot;,
 				 nr, modparam_fwpostfix);
 
-			err = request_firmware(&amp;phy-&gt;initvals1, buf, &amp;bcm-&gt;pci_dev-&gt;dev);
+			err = request_firmware(&amp;dev-&gt;fw.initvals1, buf,
+					       dev-&gt;dev-&gt;dev);
 			if (err) {
-				printk(KERN_ERR PFX 
-				       &quot;Error: InitVals \&quot;%s\&quot; not available or load failed.\n&quot;,
-			        	buf);
-				goto error;
+				snprintf(buf, ARRAY_SIZE(buf),
+					 &quot;bcm43xx_initval%02d.fw&quot;, nr);
+
+				err = request_firmware(&amp;dev-&gt;fw.initvals1, buf,
+						       dev-&gt;dev-&gt;dev);
+				if (err) {
+					bcmerr(dev-&gt;wl, &quot;InitVals \&quot;%s\&quot; not &quot;
+					       &quot;available or load failed.\n&quot;,
+					       buf);
+					goto error;
+				}
 			}
-			if (phy-&gt;initvals1-&gt;size % sizeof(struct bcm43xx_initval)) {
-				printk(KERN_ERR PFX &quot;InitVals fileformat error.\n&quot;);
+			if (dev-&gt;fw.initvals1-&gt;size
+				% sizeof(struct bcm43xx_initval)) {
+				bcmerr(dev-&gt;wl, &quot;InitVals format error.\n&quot;);
 				goto error;
 			}
 		}
@@ -2000,44 +1671,102 @@ static int bcm43xx_request_firmware(stru
 out:
 	return err;
 error:
-	bcm43xx_release_firmware(bcm, 1);
+	bcm43xx_release_firmware(dev);
 	goto out;
 err_noinitval:
-	printk(KERN_ERR PFX &quot;Error: No InitVals available!\n&quot;);
+	bcmerr(dev-&gt;wl, &quot;No InitVals available\n&quot;);
 	err = -ENOENT;
 	goto error;
 }
 
-static void bcm43xx_upload_microcode(struct bcm43xx_private *bcm)
+static int bcm43xx_upload_microcode(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	const u32 *data;
-	unsigned int i, len;
+	const __be32 *data;
+	unsigned int i;
+	unsigned int len;
+	u16 fwrev;
+	u16 fwpatch;
+	u16 fwdate;
+	u16 fwtime;
+	u32 tmp;
+	int err = 0;
 
 	/* Upload Microcode. */
-	data = (u32 *)(phy-&gt;ucode-&gt;data);
-	len = phy-&gt;ucode-&gt;size / sizeof(u32);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_UCODE, 0x0000);
+	data = (__be32 *)(dev-&gt;fw.ucode-&gt;data);
+	len = dev-&gt;fw.ucode-&gt;size / sizeof(__be32);
+	bcm43xx_shm_control_word(dev,
+				 BCM43xx_SHM_UCODE | BCM43xx_SHM_AUTOINC_W,
+				 0x0000);
 	for (i = 0; i &lt; len; i++) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA,
+		bcm43xx_write32(dev, BCM43xx_MMIO_SHM_DATA,
 				be32_to_cpu(data[i]));
 		udelay(10);
 	}
 
 	/* Upload PCM data. */
-	data = (u32 *)(phy-&gt;pcm-&gt;data);
-	len = phy-&gt;pcm-&gt;size / sizeof(u32);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_PCM, 0x01ea);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA, 0x00004000);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_PCM, 0x01eb);
+	data = (__be32 *)(dev-&gt;fw.pcm-&gt;data);
+	len = dev-&gt;fw.pcm-&gt;size / sizeof(__be32);
+	bcm43xx_shm_control_word(dev, BCM43xx_SHM_HW, 0x01EA);
+	bcm43xx_write32(dev, BCM43xx_MMIO_SHM_DATA, 0x00004000);
+	/* No need for autoinc bit in SHM_HW */
+	bcm43xx_shm_control_word(dev, BCM43xx_SHM_HW, 0x01EB);
 	for (i = 0; i &lt; len; i++) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA,
+		bcm43xx_write32(dev, BCM43xx_MMIO_SHM_DATA,
 				be32_to_cpu(data[i]));
 		udelay(10);
 	}
+
+	bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_REASON, BCM43xx_IRQ_ALL);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, 0x00020402);
+
+	/* Wait for the microcode to load and respond */
+	i = 0;
+	while (1) {
+		tmp = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
+		if (tmp == BCM43xx_IRQ_MAC_SUSPENDED)
+			break;
+		i++;
+		if (i &gt;= BCM43xx_IRQWAIT_MAX_RETRIES) {
+			bcmerr(dev-&gt;wl, &quot;Microcode not responding\n&quot;);
+			err = -ENODEV;
+			goto out;
+		}
+		udelay(10);
+	}
+	bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
+
+	/* Get and check the revisions. */
+	fwrev = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				   BCM43xx_SHM_SH_UCODEREV);
+	fwpatch = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				     BCM43xx_SHM_SH_UCODEPATCH);
+	fwdate = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				    BCM43xx_SHM_SH_UCODEDATE);
+	fwtime = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				    BCM43xx_SHM_SH_UCODETIME);
+
+	if (fwrev &gt; 0x128) {
+		bcmerr(dev-&gt;wl, &quot;YOUR FIRMWARE IS TOO NEW. Only firmware &quot;
+		       &quot;from binary drivers version 3.x is supported. &quot;
+		       &quot;You must change your firmware files.\n&quot;);
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, 0);
+		err = -EOPNOTSUPP;
+		goto out;
+	}
+	bcmdbg(dev-&gt;wl, &quot;Loading firmware version 0x%X, patch level %u &quot;
+			      &quot;(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\n&quot;,
+	       fwrev, fwpatch,
+	       (fwdate &gt;&gt; 12) &amp; 0xF, (fwdate &gt;&gt; 8) &amp; 0xF, fwdate &amp; 0xFF,
+	       (fwtime &gt;&gt; 11) &amp; 0x1F, (fwtime &gt;&gt; 5) &amp; 0x3F, fwtime &amp; 0x1F);
+
+	dev-&gt;fw.rev = fwrev;
+	dev-&gt;fw.patch = fwpatch;
+
+out:
+	return err;
 }
 
-static int bcm43xx_write_initvals(struct bcm43xx_private *bcm,
+static int bcm43xx_write_initvals(struct bcm43xx_wldev *dev,
 				  const struct bcm43xx_initval *data,
 				  const unsigned int len)
 {
@@ -2055,33 +1784,37 @@ static int bcm43xx_write_initvals(struct
 		if (size == 2) {
 			if (unlikely(value &amp; 0xFFFF0000))
 				goto err_format;
-			bcm43xx_write16(bcm, offset, (u16)value);
+			bcm43xx_write16(dev, offset, (u16)value);
 		} else if (size == 4) {
-			bcm43xx_write32(bcm, offset, value);
-		} else
+			bcm43xx_write32(dev, offset, value);
+		} else {
 			goto err_format;
+		}
 	}
 
 	return 0;
 
 err_format:
-	printk(KERN_ERR PFX &quot;InitVals (bcm43xx_initvalXX.fw) file-format error. &quot;
-			    &quot;Please fix your bcm43xx firmware files.\n&quot;);
+	bcmerr(dev-&gt;wl, &quot;InitVals (bcm43xx_initvalXX.fw) file-format error. &quot;
+	       &quot;Please fix your bcm43xx firmware files.\n&quot;);
 	return -EPROTO;
 }
 
-static int bcm43xx_upload_initvals(struct bcm43xx_private *bcm)
+static int bcm43xx_upload_initvals(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
 	int err;
 
-	err = bcm43xx_write_initvals(bcm, (struct bcm43xx_initval *)phy-&gt;initvals0-&gt;data,
-				     phy-&gt;initvals0-&gt;size / sizeof(struct bcm43xx_initval));
+	err = bcm43xx_write_initvals(dev,
+			     (struct bcm43xx_initval *)dev-&gt;fw.initvals0-&gt;data,
+			     dev-&gt;fw.initvals0-&gt;size /
+			     sizeof(struct bcm43xx_initval));
 	if (err)
 		goto out;
-	if (phy-&gt;initvals1) {
-		err = bcm43xx_write_initvals(bcm, (struct bcm43xx_initval *)phy-&gt;initvals1-&gt;data,
-					     phy-&gt;initvals1-&gt;size / sizeof(struct bcm43xx_initval));
+	if (dev-&gt;fw.initvals1) {
+		err = bcm43xx_write_initvals(dev,
+			     (struct bcm43xx_initval *)dev-&gt;fw.initvals1-&gt;data,
+			     dev-&gt;fw.initvals1-&gt;size /
+			     sizeof(struct bcm43xx_initval));
 		if (err)
 			goto out;
 	}
@@ -2089,2180 +1822,2164 @@ out:
 	return err;
 }
 
-static int bcm43xx_initialize_irq(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	bcm-&gt;irq = bcm-&gt;pci_dev-&gt;irq;
-	err = request_irq(bcm-&gt;irq, bcm43xx_interrupt_handler,
-			  IRQF_SHARED, KBUILD_MODNAME, bcm);
-	if (err)
-		printk(KERN_ERR PFX &quot;Cannot register IRQ%d\n&quot;, bcm-&gt;irq);
-
-	return err;
-}
-
-/* Switch to the core used to write the GPIO register.
- * This is either the ChipCommon, or the PCI core.
- */
-static int switch_to_gpio_core(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	/* Where to find the GPIO register depends on the chipset.
-	 * If it has a ChipCommon, its register at offset 0x6c is the GPIO
-	 * control register. Otherwise the register at offset 0x6c in the
-	 * PCI core is the GPIO control register.
-	 */
-	err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_chipcommon);
-	if (err == -ENODEV) {
-		err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_pci);
-		if (unlikely(err == -ENODEV)) {
-			printk(KERN_ERR PFX &quot;gpio error: &quot;
-			       &quot;Neither ChipCommon nor PCI core available!\n&quot;);
-		}
-	}
-
-	return err;
-}
-
 /* Initialize the GPIOs
  * <A HREF="http://bcm-specs.sipsolutions.net/GPIO">http://bcm-specs.sipsolutions.net/GPIO</A>
  */
-static int bcm43xx_gpio_init(struct bcm43xx_private *bcm)
+static int bcm43xx_gpio_init(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_coreinfo *old_core;
-	int err;
+	struct ssb_bus *bus = dev-&gt;dev-&gt;bus;
+	struct ssb_device *gpiodev, *pcidev = NULL;
 	u32 mask, set;
 
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+			bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD)
 			&amp; 0xFFFF3FFF);
 
-	bcm43xx_leds_switch_all(bcm, 0);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-			bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK) | 0x000F);
+	bcm43xx_leds_switch_all(dev, 0);
+	bcm43xx_write16(dev, BCM43xx_MMIO_GPIO_MASK,
+			bcm43xx_read16(dev, BCM43xx_MMIO_GPIO_MASK)
+			| 0x000F);
 
 	mask = 0x0000001F;
 	set = 0x0000000F;
-	if (bcm-&gt;chip_id == 0x4301) {
+	if (dev-&gt;dev-&gt;bus-&gt;chip_id == 0x4301) {
 		mask |= 0x0060;
 		set |= 0x0060;
 	}
 	if (0 /* FIXME: conditional unknown */) {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-				bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK)
+		bcm43xx_write16(dev, BCM43xx_MMIO_GPIO_MASK,
+				bcm43xx_read16(dev, BCM43xx_MMIO_GPIO_MASK)
 				| 0x0100);
 		mask |= 0x0180;
 		set |= 0x0180;
 	}
-	if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_PACTRL) {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-				bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK)
+	if (dev-&gt;dev-&gt;bus-&gt;sprom.r1.boardflags_lo &amp; BCM43xx_BFL_PACTRL) {
+		bcm43xx_write16(dev, BCM43xx_MMIO_GPIO_MASK,
+				bcm43xx_read16(dev, BCM43xx_MMIO_GPIO_MASK)
 				| 0x0200);
 		mask |= 0x0200;
 		set |= 0x0200;
 	}
-	if (bcm-&gt;current_core-&gt;rev &gt;= 2)
+	if (dev-&gt;dev-&gt;id.revision &gt;= 2)
 		mask  |= 0x0010; /* FIXME: This is redundant. */
 
-	old_core = bcm-&gt;current_core;
-	err = switch_to_gpio_core(bcm);
-	if (err)
-		goto out;
-	bcm43xx_write32(bcm, BCM43xx_GPIO_CONTROL,
-	                (bcm43xx_read32(bcm, BCM43xx_GPIO_CONTROL) &amp; mask) | set);
-	err = bcm43xx_switch_core(bcm, old_core);
-out:
-	return err;
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+	pcidev = bus-&gt;pcicore.dev;
+#endif
+	gpiodev = bus-&gt;chipco.dev ? : pcidev;
+	if (!gpiodev)
+		return 0;
+	ssb_write32(gpiodev, BCM43xx_GPIO_CONTROL,
+		    (ssb_read32(gpiodev, BCM43xx_GPIO_CONTROL)
+		     &amp; mask) | set);
+
+	return 0;
 }
 
 /* Turn off all GPIO stuff. Call this on module unload, for example. */
-static int bcm43xx_gpio_cleanup(struct bcm43xx_private *bcm)
+static void bcm43xx_gpio_cleanup(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_coreinfo *old_core;
-	int err;
-
-	old_core = bcm-&gt;current_core;
-	err = switch_to_gpio_core(bcm);
-	if (err)
-		return err;
-	bcm43xx_write32(bcm, BCM43xx_GPIO_CONTROL, 0x00000000);
-	err = bcm43xx_switch_core(bcm, old_core);
-	assert(err == 0);
+	struct ssb_bus *bus = dev-&gt;dev-&gt;bus;
+	struct ssb_device *gpiodev, *pcidev = NULL;
 
-	return 0;
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+	pcidev = bus-&gt;pcicore.dev;
+#endif
+	gpiodev = bus-&gt;chipco.dev ? : pcidev;
+	if (!gpiodev)
+		return;
+	ssb_write32(gpiodev, BCM43xx_GPIO_CONTROL, 0);
 }
 
 /* <A HREF="http://bcm-specs.sipsolutions.net/EnableMac">http://bcm-specs.sipsolutions.net/EnableMac</A> */
-void bcm43xx_mac_enable(struct bcm43xx_private *bcm)
+void bcm43xx_mac_enable(struct bcm43xx_wldev *dev)
 {
-	bcm-&gt;mac_suspended--;
-	assert(bcm-&gt;mac_suspended &gt;= 0);
-	if (bcm-&gt;mac_suspended == 0) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
+	dev-&gt;mac_suspended--;
+	BCM43xx_WARN_ON(dev-&gt;mac_suspended &lt; 0);
+	if (dev-&gt;mac_suspended == 0) {
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+				bcm43xx_read32(dev,
+				BCM43xx_MMIO_STATUS_BITFIELD)
 				| BCM43xx_SBF_MAC_ENABLED);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, BCM43xx_IRQ_READY);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD); /* dummy read */
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-		bcm43xx_power_saving_ctl_bits(bcm, -1, -1);
+		bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_REASON,
+				BCM43xx_IRQ_MAC_SUSPENDED);
+		/* the next two are dummy reads */
+		bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
+		bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
+		bcm43xx_power_saving_ctl_bits(dev, -1, -1);
 	}
 }
 
 /* <A HREF="http://bcm-specs.sipsolutions.net/SuspendMAC">http://bcm-specs.sipsolutions.net/SuspendMAC</A> */
-void bcm43xx_mac_suspend(struct bcm43xx_private *bcm)
+void bcm43xx_mac_suspend(struct bcm43xx_wldev *dev)
 {
 	int i;
 	u32 tmp;
 
-	assert(bcm-&gt;mac_suspended &gt;= 0);
-	if (bcm-&gt;mac_suspended == 0) {
-		bcm43xx_power_saving_ctl_bits(bcm, -1, 1);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
+	BCM43xx_WARN_ON(dev-&gt;mac_suspended &lt; 0);
+	if (dev-&gt;mac_suspended == 0) {
+		bcm43xx_power_saving_ctl_bits(dev, -1, 1);
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+				bcm43xx_read32(dev,
+				BCM43xx_MMIO_STATUS_BITFIELD)
 				&amp; ~BCM43xx_SBF_MAC_ENABLED);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
+		bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
 		for (i = 10000; i; i--) {
-			tmp = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-			if (tmp &amp; BCM43xx_IRQ_READY)
+			tmp = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
+			if (tmp &amp; BCM43xx_IRQ_MAC_SUSPENDED)
 				goto out;
 			udelay(1);
 		}
-		printkl(KERN_ERR PFX &quot;MAC suspend failed\n&quot;);
+		bcmerr(dev-&gt;wl, &quot;MAC suspend failed\n&quot;);
 	}
 out:
-	bcm-&gt;mac_suspended++;
+	dev-&gt;mac_suspended++;
 }
 
-void bcm43xx_set_iwmode(struct bcm43xx_private *bcm,
-			int iw_mode)
+static void bcm43xx_adjust_opmode(struct bcm43xx_wldev *dev)
 {
-	unsigned long flags;
-	struct net_device *net_dev = bcm-&gt;net_dev;
-	u32 status;
-	u16 value;
-
-	spin_lock_irqsave(&amp;bcm-&gt;ieee-&gt;lock, flags);
-	bcm-&gt;ieee-&gt;iw_mode = iw_mode;
-	spin_unlock_irqrestore(&amp;bcm-&gt;ieee-&gt;lock, flags);
-	if (iw_mode == IW_MODE_MONITOR)
-		net_dev-&gt;type = ARPHRD_IEEE80211;
-	else
-		net_dev-&gt;type = ARPHRD_ETHER;
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	/* Reset status to infrastructured mode */
-	status &amp;= ~(BCM43xx_SBF_MODE_AP | BCM43xx_SBF_MODE_MONITOR);
-	status &amp;= ~BCM43xx_SBF_MODE_PROMISC;
-	status |= BCM43xx_SBF_MODE_NOTADHOC;
-
-/* FIXME: Always enable promisc mode, until we get the MAC filters working correctly. */
-status |= BCM43xx_SBF_MODE_PROMISC;
-
-	switch (iw_mode) {
-	case IW_MODE_MONITOR:
-		status |= BCM43xx_SBF_MODE_MONITOR;
-		status |= BCM43xx_SBF_MODE_PROMISC;
-		break;
-	case IW_MODE_ADHOC:
-		status &amp;= ~BCM43xx_SBF_MODE_NOTADHOC;
-		break;
-	case IW_MODE_MASTER:
-		status |= BCM43xx_SBF_MODE_AP;
-		break;
-	case IW_MODE_SECOND:
-	case IW_MODE_REPEAT:
-		TODO(); /* TODO */
-		break;
-	case IW_MODE_INFRA:
-		/* nothing to be done here... */
-		break;
-	default:
-		dprintk(KERN_ERR PFX &quot;Unknown mode in set_iwmode: %d\n&quot;, iw_mode);
+	struct bcm43xx_wl *wl = dev-&gt;wl;
+	u32 ctl;
+	u16 cfp_pretbtt;
+
+	ctl = bcm43xx_read32(dev, BCM43xx_MMIO_MACCTL);
+	/* Reset status to STA infrastructure mode. */
+	ctl &amp;= ~BCM43xx_MACCTL_AP;
+	ctl &amp;= ~BCM43xx_MACCTL_KEEP_CTL;
+	ctl &amp;= ~BCM43xx_MACCTL_KEEP_BADPLCP;
+	ctl &amp;= ~BCM43xx_MACCTL_KEEP_BAD;
+	ctl &amp;= ~BCM43xx_MACCTL_PROMISC;
+	ctl |= BCM43xx_MACCTL_INFRA;
+
+	if (wl-&gt;operating) {
+		switch (wl-&gt;if_type) {
+		case IEEE80211_IF_TYPE_AP:
+			ctl |= BCM43xx_MACCTL_AP;
+			break;
+		case IEEE80211_IF_TYPE_IBSS:
+			ctl &amp;= ~BCM43xx_MACCTL_INFRA;
+			break;
+		case IEEE80211_IF_TYPE_STA:
+		case IEEE80211_IF_TYPE_MNTR:
+		case IEEE80211_IF_TYPE_WDS:
+			break;
+		default:
+			bcmerr(wl, &quot;Improper value of %d for wl-&gt;if_type\n&quot;,
+			       wl-&gt;if_type);
+		}
 	}
-	if (net_dev-&gt;flags &amp; IFF_PROMISC)
-		status |= BCM43xx_SBF_MODE_PROMISC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-
-	value = 0x0002;
-	if (iw_mode != IW_MODE_ADHOC &amp;&amp; iw_mode != IW_MODE_MASTER) {
-		if (bcm-&gt;chip_id == 0x4306 &amp;&amp; bcm-&gt;chip_rev == 3)
-			value = 0x0064;
+	if (wl-&gt;monitor) {
+		ctl |= BCM43xx_MACCTL_KEEP_CTL;
+		if (modparam_mon_keep_bad)
+			ctl |= BCM43xx_MACCTL_KEEP_BAD;
+		if (modparam_mon_keep_badplcp)
+			ctl |= BCM43xx_MACCTL_KEEP_BADPLCP;
+	}
+	if (wl-&gt;promisc)
+		ctl |= BCM43xx_MACCTL_PROMISC;
+	/* Workaround: On old hardware the HW-MAC-address-filter
+	 * doesn't work properly, so always run promisc in filter
+	 * it in software. */
+	if (dev-&gt;dev-&gt;id.revision &lt;= 4)
+		ctl |= BCM43xx_MACCTL_PROMISC;
+
+	bcm43xx_write32(dev, BCM43xx_MMIO_MACCTL, ctl);
+
+	cfp_pretbtt = 2;
+	if ((ctl &amp; BCM43xx_MACCTL_INFRA) &amp;&amp;
+	    !(ctl &amp; BCM43xx_MACCTL_AP)) {
+		if (dev-&gt;dev-&gt;bus-&gt;chip_id == 0x4306 &amp;&amp;
+		    dev-&gt;dev-&gt;bus-&gt;chip_rev == 3)
+			cfp_pretbtt = 100;
 		else
-			value = 0x0032;
+			cfp_pretbtt = 50;
 	}
-	bcm43xx_write16(bcm, 0x0612, value);
+	bcm43xx_write16(dev, 0x612, cfp_pretbtt);
 }
 
-/* This is the opposite of bcm43xx_chip_init() */
-static void bcm43xx_chip_cleanup(struct bcm43xx_private *bcm)
+static void bcm43xx_rate_memory_write(struct bcm43xx_wldev *dev,
+				      u16 rate,
+				      int is_ofdm)
 {
-	bcm43xx_radio_turn_off(bcm);
-	if (!modparam_noleds)
-		bcm43xx_leds_exit(bcm);
-	bcm43xx_gpio_cleanup(bcm);
-	bcm43xx_release_firmware(bcm, 0);
+	u16 offset;
+
+	if (is_ofdm) {
+		offset = 0x480;
+		offset += (bcm43xx_plcp_get_ratecode_ofdm(rate) &amp; 0x000F) * 2;
+	} else {
+		offset = 0x4C0;
+		offset += (bcm43xx_plcp_get_ratecode_cck(rate) &amp; 0x000F) * 2;
+	}
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, offset + 0x20,
+			    bcm43xx_shm_read16(dev,
+			    BCM43xx_SHM_SHARED, offset));
 }
 
-/* Initialize the chip
- * <A HREF="http://bcm-specs.sipsolutions.net/ChipInit">http://bcm-specs.sipsolutions.net/ChipInit</A>
- */
-static int bcm43xx_chip_init(struct bcm43xx_private *bcm)
+static void bcm43xx_rate_memory_init(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	int err;
-	int i, tmp;
-	u32 value32;
-	u16 value16;
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-			BCM43xx_SBF_CORE_READY
-			| BCM43xx_SBF_400);
-
-	err = bcm43xx_request_firmware(bcm);
-	if (err)
-		goto out;
-	bcm43xx_upload_microcode(bcm);
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, 0xFFFFFFFF);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, 0x00020402);
-	i = 0;
-	while (1) {
-		value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-		if (value32 == BCM43xx_IRQ_READY)
-			break;
-		i++;
-		if (i &gt;= BCM43xx_IRQWAIT_MAX_RETRIES) {
-			printk(KERN_ERR PFX &quot;IRQ_READY timeout\n&quot;);
-			err = -ENODEV;
-			goto err_release_fw;
-		}
-		udelay(10);
+	switch (dev-&gt;phy.type) {
+	case BCM43xx_PHYTYPE_G:
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_6MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_12MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_18MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_24MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_36MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_48MB, 1);
+		bcm43xx_rate_memory_write(dev, BCM43xx_OFDM_RATE_54MB, 1);
+		/* fallthrough */
+	case BCM43xx_PHYTYPE_B:
+		bcm43xx_rate_memory_write(dev, BCM43xx_CCK_RATE_1MB, 0);
+		bcm43xx_rate_memory_write(dev, BCM43xx_CCK_RATE_2MB, 0);
+		bcm43xx_rate_memory_write(dev, BCM43xx_CCK_RATE_5MB, 0);
+		bcm43xx_rate_memory_write(dev, BCM43xx_CCK_RATE_11MB, 0);
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
 	}
-	bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
+}
 
-	value16 = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				     BCM43xx_UCODE_REVISION);
+/* Set the TX-Antenna for management frames sent by firmware. */
+static void bcm43xx_mgmtframe_txantenna(struct bcm43xx_wldev *dev,
+					int antenna)
+{
+	u16 ant = 0;
+	u16 tmp;
 
-	dprintk(KERN_INFO PFX &quot;Microcode rev 0x%x, pl 0x%x &quot;
-		&quot;(20%.2i-%.2i-%.2i  %.2i:%.2i:%.2i)\n&quot;, value16,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_PATCHLEVEL),
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODE_DATE) &gt;&gt; 12) &amp; 0xf,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODE_DATE) &gt;&gt; 8) &amp; 0xf,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_DATE) &amp; 0xff,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) &gt;&gt; 11) &amp; 0x1f,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) &gt;&gt; 5) &amp; 0x3f,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) &amp; 0x1f);
-
-	if ( value16 &gt; 0x128 ) {
-		printk(KERN_ERR PFX
-			&quot;Firmware: no support for microcode extracted &quot;
-			&quot;from version 4.x binary drivers.\n&quot;);
-		err = -EOPNOTSUPP;
-		goto err_release_fw;
+	switch (antenna) {
+	case BCM43xx_ANTENNA0:
+		ant |= BCM43xx_TX4_PHY_ANT0;
+		break;
+	case BCM43xx_ANTENNA1:
+		ant |= BCM43xx_TX4_PHY_ANT1;
+		break;
+	case BCM43xx_ANTENNA_AUTO:
+		ant |= BCM43xx_TX4_PHY_ANTLAST;
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
 	}
 
-	err = bcm43xx_gpio_init(bcm);
+	/* FIXME We also need to set the other flags of the PHY control
+	 * field somewhere. */
+
+	/* For Beacons */
+	tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				 BCM43xx_SHM_SH_BEACPHYCTL);
+	tmp = (tmp &amp; ~BCM43xx_TX4_PHY_ANT) | ant;
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_BEACPHYCTL, tmp);
+	/* For ACK/CTS */
+	tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				 BCM43xx_SHM_SH_ACKCTSPHYCTL);
+	tmp = (tmp &amp; ~BCM43xx_TX4_PHY_ANT) | ant;
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_ACKCTSPHYCTL, tmp);
+	/* For Probe Resposes */
+	tmp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				 BCM43xx_SHM_SH_PRPHYCTL);
+	tmp = (tmp &amp; ~BCM43xx_TX4_PHY_ANT) | ant;
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_PRPHYCTL, tmp);
+}
+
+/* This is the opposite of bcm43xx_chip_init() */
+static void bcm43xx_chip_exit(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_radio_turn_off(dev);
+	if (!modparam_noleds)
+		bcm43xx_leds_exit(dev);
+	bcm43xx_gpio_cleanup(dev);
+	/* firmware is released later */
+}
+
+/* Initialize the chip
+ * <A HREF="http://bcm-specs.sipsolutions.net/ChipInit">http://bcm-specs.sipsolutions.net/ChipInit</A>
+ */
+static int bcm43xx_chip_init(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &amp;dev-&gt;phy;
+	int err;
+	int tmp;
+	u32 value32;
+	u16 value16;
+
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+			BCM43xx_SBF_CORE_READY
+			| BCM43xx_SBF_400);
+
+	err = bcm43xx_request_firmware(dev);
 	if (err)
-		goto err_release_fw;
+		goto out;
+	err = bcm43xx_upload_microcode(dev);
+	if (err)
+		goto out; /* firmware is released later */
 
-	err = bcm43xx_upload_initvals(bcm);
+	err = bcm43xx_gpio_init(dev);
+	if (err)
+		goto out; /* firmware is released later */
+	err = bcm43xx_upload_initvals(dev);
 	if (err)
 		goto err_gpio_cleanup;
-	bcm43xx_radio_turn_on(bcm);
-	bcm-&gt;radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
-	dprintk(KERN_INFO PFX &quot;Radio %s by hardware\n&quot;,
-		(bcm-&gt;radio_hw_enable == 0) ? &quot;disabled&quot; : &quot;enabled&quot;);
+	bcm43xx_radio_turn_on(dev);
+	dev-&gt;radio_hw_enable = bcm43xx_is_hw_radio_enabled(dev);
+	bcmdbg(dev-&gt;wl, &quot;Radio %s by hardware\n&quot;,
+	       (dev-&gt;radio_hw_enable == 0) ? &quot;disabled&quot; : &quot;enabled&quot;);
 
-	bcm43xx_write16(bcm, 0x03E6, 0x0000);
-	err = bcm43xx_phy_init(bcm);
+	bcm43xx_write16(dev, 0x03E6, 0x0000);
+	err = bcm43xx_phy_init(dev);
 	if (err)
 		goto err_radio_off;
 
 	/* Select initial Interference Mitigation. */
-	tmp = radio-&gt;interfmode;
-	radio-&gt;interfmode = BCM43xx_RADIO_INTERFMODE_NONE;
-	bcm43xx_radio_set_interference_mitigation(bcm, tmp);
+	tmp = phy-&gt;interfmode;
+	phy-&gt;interfmode = BCM43xx_INTERFMODE_NONE;
+	bcm43xx_radio_set_interference_mitigation(dev, tmp);
+
+	bcm43xx_phy_set_antenna_diversity(dev);
+	bcm43xx_mgmtframe_txantenna(dev, BCM43xx_ANTENNA_DEFAULT);
 
-	bcm43xx_phy_set_antenna_diversity(bcm);
-	bcm43xx_radio_set_txantenna(bcm, BCM43xx_RADIO_TXANTENNA_DEFAULT);
 	if (phy-&gt;type == BCM43xx_PHYTYPE_B) {
-		value16 = bcm43xx_read16(bcm, 0x005E);
+		value16 = bcm43xx_read16(dev, 0x005E);
 		value16 |= 0x0004;
-		bcm43xx_write16(bcm, 0x005E, value16);
+		bcm43xx_write16(dev, 0x005E, value16);
 	}
-	bcm43xx_write32(bcm, 0x0100, 0x01000000);
-	if (bcm-&gt;current_core-&gt;rev &lt; 5)
-		bcm43xx_write32(bcm, 0x010C, 0x01000000);
+	bcm43xx_write32(dev, 0x0100, 0x01000000);
+	if (dev-&gt;dev-&gt;id.revision &lt; 5)
+		bcm43xx_write32(dev, 0x010C, 0x01000000);
 
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
+	value32 = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 	value32 &amp;= ~ BCM43xx_SBF_MODE_NOTADHOC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, value32);
+	value32 = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 	value32 |= BCM43xx_SBF_MODE_NOTADHOC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, value32);
 
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
+	value32 = bcm43xx_read32(dev, BCM43xx_MMIO_STATUS_BITFIELD);
 	value32 |= 0x100000;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
+	bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD, value32);
 
-	if (bcm43xx_using_pio(bcm)) {
-		bcm43xx_write32(bcm, 0x0210, 0x00000100);
-		bcm43xx_write32(bcm, 0x0230, 0x00000100);
-		bcm43xx_write32(bcm, 0x0250, 0x00000100);
-		bcm43xx_write32(bcm, 0x0270, 0x00000100);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0034, 0x0000);
+	if (bcm43xx_using_pio(dev)) {
+		bcm43xx_write32(dev, 0x0210, 0x00000100);
+		bcm43xx_write32(dev, 0x0230, 0x00000100);
+		bcm43xx_write32(dev, 0x0250, 0x00000100);
+		bcm43xx_write32(dev, 0x0270, 0x00000100);
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0034, 0x0000);
 	}
 
 	/* Probe Response Timeout value */
 	/* FIXME: Default to 0, has to be set by ioctl probably... :-/ */
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0074, 0x0000);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0074, 0x0000);
 
 	/* Initially set the wireless operation mode. */
-	bcm43xx_set_iwmode(bcm, bcm-&gt;ieee-&gt;iw_mode);
+	bcm43xx_adjust_opmode(dev);
 
-	if (bcm-&gt;current_core-&gt;rev &lt; 3) {
-		bcm43xx_write16(bcm, 0x060E, 0x0000);
-		bcm43xx_write16(bcm, 0x0610, 0x8000);
-		bcm43xx_write16(bcm, 0x0604, 0x0000);
-		bcm43xx_write16(bcm, 0x0606, 0x0200);
+	if (dev-&gt;dev-&gt;id.revision &lt; 3) {
+		bcm43xx_write16(dev, 0x060E, 0x0000);
+		bcm43xx_write16(dev, 0x0610, 0x8000);
+		bcm43xx_write16(dev, 0x0604, 0x0000);
+		bcm43xx_write16(dev, 0x0606, 0x0200);
 	} else {
-		bcm43xx_write32(bcm, 0x0188, 0x80000000);
-		bcm43xx_write32(bcm, 0x018C, 0x02000000);
+		bcm43xx_write32(dev, 0x0188, 0x80000000);
+		bcm43xx_write32(dev, 0x018C, 0x02000000);
 	}
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, 0x00004000);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA0_IRQ_MASK, 0x0001DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA1_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA2_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA3_IRQ_MASK, 0x0001DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA4_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA5_IRQ_MASK, 0x0000DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_GEN_IRQ_REASON, 0x00004000);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA0_IRQ_MASK, 0x0001DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA1_IRQ_MASK, 0x0000DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA2_IRQ_MASK, 0x0000DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA3_IRQ_MASK, 0x0001DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA4_IRQ_MASK, 0x0000DC00);
+	bcm43xx_write32(dev, BCM43xx_MMIO_DMA5_IRQ_MASK, 0x0000DC00);
 
-	value32 = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
+	value32 = ssb_read32(dev-&gt;dev, SSB_TMSLOW);
 	value32 |= 0x00100000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, value32);
+	ssb_write32(dev-&gt;dev, SSB_TMSLOW, value32);
 
-	bcm43xx_write16(bcm, BCM43xx_MMIO_POWERUP_DELAY, bcm43xx_pctl_powerup_delay(bcm));
+	bcm43xx_write16(dev, BCM43xx_MMIO_POWERUP_DELAY,
+			dev-&gt;dev-&gt;bus-&gt;chipco.fast_pwrup_delay);
 
-	assert(err == 0);
-	dprintk(KERN_INFO PFX &quot;Chip initialized\n&quot;);
+	BCM43xx_WARN_ON(err != 0);
+	bcmdbg(dev-&gt;wl, &quot;Chip initialized\n&quot;);
 out:
 	return err;
 
 err_radio_off:
-	bcm43xx_radio_turn_off(bcm);
+	bcm43xx_radio_turn_off(dev);
 err_gpio_cleanup:
-	bcm43xx_gpio_cleanup(bcm);
-err_release_fw:
-	bcm43xx_release_firmware(bcm, 1);
+	bcm43xx_gpio_cleanup(dev);
 	goto out;
 }
-	
-/* Validate chip access
- * <A HREF="http://bcm-specs.sipsolutions.net/ValidateChipAccess">http://bcm-specs.sipsolutions.net/ValidateChipAccess</A> */
-static int bcm43xx_validate_chip(struct bcm43xx_private *bcm)
-{
-	u32 value;
-	u32 shm_backup;
-
-	shm_backup = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, 0xAA5555AA);
-	if (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000) != 0xAA5555AA)
-		goto error;
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, 0x55AAAA55);
-	if (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000) != 0x55AAAA55)
-		goto error;
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, shm_backup);
 
-	value = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	if ((value | 0x80000000) != 0x80000400)
-		goto error;
+static void bcm43xx_periodic_every120sec(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &amp;dev-&gt;phy;
 
-	value = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-	if (value != 0x00000000)
-		goto error;
+	if (phy-&gt;type != BCM43xx_PHYTYPE_G || phy-&gt;rev &lt; 2)
+		return;
 
-	return 0;
-error:
-	printk(KERN_ERR PFX &quot;Failed to validate the chipaccess\n&quot;);
-	return -ENODEV;
+	bcm43xx_mac_suspend(dev);
+	bcm43xx_phy_lo_g_measure(dev);
+	bcm43xx_mac_enable(dev);
 }
 
-static void bcm43xx_init_struct_phyinfo(struct bcm43xx_phyinfo *phy)
+static void bcm43xx_periodic_every60sec(struct bcm43xx_wldev *dev)
 {
-	/* Initialize a &quot;phyinfo&quot; structure. The structure is already
-	 * zeroed out.
-	 * This is called on insmod time to initialize members.
-	 */
-	phy-&gt;savedpctlreg = 0xFFFF;
-	spin_lock_init(&amp;phy-&gt;lock);
+	bcm43xx_phy_lo_mark_all_unused(dev);
+	if (dev-&gt;dev-&gt;bus-&gt;sprom.r1.boardflags_lo &amp; BCM43xx_BFL_RSSI) {
+		bcm43xx_mac_suspend(dev);
+		bcm43xx_calc_nrssi_slope(dev);
+		bcm43xx_mac_enable(dev);
+	}
 }
 
-static void bcm43xx_init_struct_radioinfo(struct bcm43xx_radioinfo *radio)
+static void bcm43xx_periodic_every30sec(struct bcm43xx_wldev *dev)
 {
-	/* Initialize a &quot;radioinfo&quot; structure. The structure is already
-	 * zeroed out.
-	 * This is called on insmod time to initialize members.
-	 */
-	radio-&gt;interfmode = BCM43xx_RADIO_INTERFMODE_NONE;
-	radio-&gt;channel = 0xFF;
-	radio-&gt;initial_channel = 0xFF;
-}
-
-static int bcm43xx_probe_cores(struct bcm43xx_private *bcm)
-{
-	int err, i;
-	int current_core;
-	u32 core_vendor, core_id, core_rev;
-	u32 sb_id_hi, chip_id_32 = 0;
-	u16 pci_device, chip_id_16;
-	u8 core_count;
-
-	memset(&amp;bcm-&gt;core_chipcommon, 0, sizeof(struct bcm43xx_coreinfo));
-	memset(&amp;bcm-&gt;core_pci, 0, sizeof(struct bcm43xx_coreinfo));
-	memset(&amp;bcm-&gt;core_80211, 0, sizeof(struct bcm43xx_coreinfo)
-				    * BCM43xx_MAX_80211_CORES);
-	memset(&amp;bcm-&gt;core_80211_ext, 0, sizeof(struct bcm43xx_coreinfo_80211)
-					* BCM43xx_MAX_80211_CORES);
-	bcm-&gt;nr_80211_available = 0;
-	bcm-&gt;current_core = NULL;
-	bcm-&gt;active_80211_core = NULL;
-
-	/* map core 0 */
-	err = _switch_core(bcm, 0);
-	if (err)
-		goto out;
-
-	/* fetch sb_id_hi from core information registers */
-	sb_id_hi = bcm43xx_read32(bcm, BCM43xx_CIR_SB_ID_HI);
-
-	core_id = (sb_id_hi &amp; 0x8FF0) &gt;&gt; 4;
-	core_rev = (sb_id_hi &amp; 0x7000) &gt;&gt; 8;
-	core_rev |= (sb_id_hi &amp; 0xF);
-	core_vendor = (sb_id_hi &amp; 0xFFFF0000) &gt;&gt; 16;
-
-	/* if present, chipcommon is always core 0; read the chipid from it */
-	if (core_id == BCM43xx_COREID_CHIPCOMMON) {
-		chip_id_32 = bcm43xx_read32(bcm, 0);
-		chip_id_16 = chip_id_32 &amp; 0xFFFF;
-		bcm-&gt;core_chipcommon.available = 1;
-		bcm-&gt;core_chipcommon.id = core_id;
-		bcm-&gt;core_chipcommon.rev = core_rev;
-		bcm-&gt;core_chipcommon.index = 0;
-		/* While we are at it, also read the capabilities. */
-		bcm-&gt;chipcommon_capabilities = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_CAPABILITIES);
-	} else {
-		/* without a chipCommon, use a hard coded table. */
-		pci_device = bcm-&gt;pci_dev-&gt;device;
-		if (pci_device == 0x4301)
-			chip_id_16 = 0x4301;
-		else if ((pci_device &gt;= 0x4305) &amp;&amp; (pci_device &lt;= 0x4307))
-			chip_id_16 = 0x4307;
-		else if ((pci_device &gt;= 0x4402) &amp;&amp; (pci_device &lt;= 0x4403))
-			chip_id_16 = 0x4402;
-		else if ((pci_device &gt;= 0x4610) &amp;&amp; (pci_device &lt;= 0x4615))
-			chip_id_16 = 0x4610;
-		else if ((pci_device &gt;= 0x4710) &amp;&amp; (pci_device &lt;= 0x4715))
-			chip_id_16 = 0x4710;
-		else {
-			printk(KERN_ERR PFX &quot;Could not determine Chip ID\n&quot;);
-			return -ENODEV;
-		}
-	}
-
-	/* ChipCommon with Core Rev &gt;=4 encodes number of cores,
-	 * otherwise consult hardcoded table */
-	if ((core_id == BCM43xx_COREID_CHIPCOMMON) &amp;&amp; (core_rev &gt;= 4)) {
-		core_count = (chip_id_32 &amp; 0x0F000000) &gt;&gt; 24;
-	} else {
-		switch (chip_id_16) {
-			case 0x4610:
-			case 0x4704:
-			case 0x4710:
-				core_count = 9;
-				break;
-			case 0x4310:
-				core_count = 8;
-				break;
-			case 0x5365:
-				core_count = 7;
-				break;
-			case 0x4306:
-				core_count = 6;
-				break;
-			case 0x4301:
-			case 0x4307:
-				core_count = 5;
-				break;
-			case 0x4402:
-				core_count = 3;
-				break;
-			default:
-				/* SOL if we get here */
-				assert(0);
-				core_count = 1;
-		}
-	}
-
-	bcm-&gt;chip_id = chip_id_16;
-	bcm-&gt;chip_rev = (chip_id_32 &amp; 0x000F0000) &gt;&gt; 16;
-	bcm-&gt;chip_package = (chip_id_32 &amp; 0x00F00000) &gt;&gt; 20;
-
-	dprintk(KERN_INFO PFX &quot;Chip ID 0x%x, rev 0x%x\n&quot;,
-		bcm-&gt;chip_id, bcm-&gt;chip_rev);
-	dprintk(KERN_INFO PFX &quot;Number of cores: %d\n&quot;, core_count);
-	if (bcm-&gt;core_chipcommon.available) {
-		dprintk(KERN_INFO PFX &quot;Core 0: ID 0x%x, rev 0x%x, vendor 0x%x\n&quot;,
-			core_id, core_rev, core_vendor);
-		current_core = 1;
-	} else
-		current_core = 0;
-	for ( ; current_core &lt; core_count; current_core++) {
-		struct bcm43xx_coreinfo *core;
-		struct bcm43xx_coreinfo_80211 *ext_80211;
-
-		err = _switch_core(bcm, current_core);
-		if (err)
-			goto out;
-		/* Gather information */
-		/* fetch sb_id_hi from core information registers */
-		sb_id_hi = bcm43xx_read32(bcm, BCM43xx_CIR_SB_ID_HI);
-
-		/* extract core_id, core_rev, core_vendor */
-		core_id = (sb_id_hi &amp; 0x8FF0) &gt;&gt; 4;
-		core_rev = ((sb_id_hi &amp; 0xF) | ((sb_id_hi &amp; 0x7000) &gt;&gt; 8));
-		core_vendor = (sb_id_hi &amp; 0xFFFF0000) &gt;&gt; 16;
-
-		dprintk(KERN_INFO PFX &quot;Core %d: ID 0x%x, rev 0x%x, vendor 0x%x\n&quot;,
-			current_core, core_id, core_rev, core_vendor);
-
-		core = NULL;
-		switch (core_id) {
-		case BCM43xx_COREID_PCI:
-		case BCM43xx_COREID_PCIE:
-			core = &amp;bcm-&gt;core_pci;
-			if (core-&gt;available) {
-				printk(KERN_WARNING PFX &quot;Multiple PCI cores found.\n&quot;);
-				continue;
-			}
-			break;
-		case BCM43xx_COREID_80211:
-			for (i = 0; i &lt; BCM43xx_MAX_80211_CORES; i++) {
-				core = &amp;(bcm-&gt;core_80211[i]);
-				ext_80211 = &amp;(bcm-&gt;core_80211_ext[i]);
-				if (!core-&gt;available)
-					break;
-				core = NULL;
-			}
-			if (!core) {
-				printk(KERN_WARNING PFX &quot;More than %d cores of type 802.11 found.\n&quot;,
-				       BCM43xx_MAX_80211_CORES);
-				continue;
-			}
-			if (i != 0) {
-				/* More than one 80211 core is only supported
-				 * by special chips.
-				 * There are chips with two 80211 cores, but with
-				 * dangling pins on the second core. Be careful
-				 * and ignore these cores here.
-				 */
-				if (1 /*bcm-&gt;pci_dev-&gt;device != 0x4324*/ ) {
-				/* TODO: A PHY */
-					dprintk(KERN_INFO PFX &quot;Ignoring additional 802.11a core.\n&quot;);
-					continue;
-				}
-			}
-			switch (core_rev) {
-			case 2:
-			case 4:
-			case 5:
-			case 6:
-			case 7:
-			case 9:
-			case 10:
-				break;
-			default:
-				printk(KERN_WARNING PFX
-				       &quot;Unsupported 80211 core revision %u\n&quot;,
-				       core_rev);
-			}
-			bcm-&gt;nr_80211_available++;
-			core-&gt;priv = ext_80211;
-			bcm43xx_init_struct_phyinfo(&amp;ext_80211-&gt;phy);
-			bcm43xx_init_struct_radioinfo(&amp;ext_80211-&gt;radio);
-			break;
-		case BCM43xx_COREID_CHIPCOMMON:
-			printk(KERN_WARNING PFX &quot;Multiple CHIPCOMMON cores found.\n&quot;);
-			break;
-		}
-		if (core) {
-			core-&gt;available = 1;
-			core-&gt;id = core_id;
-			core-&gt;rev = core_rev;
-			core-&gt;index = current_core;
-		}
-	}
-
-	if (!bcm-&gt;core_80211[0].available) {
-		printk(KERN_ERR PFX &quot;Error: No 80211 core found!\n&quot;);
-		err = -ENODEV;
-		goto out;
-	}
-
-	err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_80211[0]);
-
-	assert(err == 0);
-out:
-	return err;
+	/* Update device statistics. */
+	bcm43xx_calculate_link_quality(dev);
 }
 
-static void bcm43xx_gen_bssid(struct bcm43xx_private *bcm)
+static void bcm43xx_periodic_every15sec(struct bcm43xx_wldev *dev)
 {
-	const u8 *mac = (const u8*)(bcm-&gt;net_dev-&gt;dev_addr);
-	u8 *bssid = bcm-&gt;ieee-&gt;bssid;
-
-	switch (bcm-&gt;ieee-&gt;iw_mode) {
-	case IW_MODE_ADHOC:
-		random_ether_addr(bssid);
-		break;
-	case IW_MODE_MASTER:
-	case IW_MODE_INFRA:
-	case IW_MODE_REPEAT:
-	case IW_MODE_SECOND:
-	case IW_MODE_MONITOR:
-		memcpy(bssid, mac, ETH_ALEN);
-		break;
-	default:
-		assert(0);
-	}
+	bcm43xx_phy_xmitpower(dev); /* FIXME: unless scanning? */
 }
 
-static void bcm43xx_rate_memory_write(struct bcm43xx_private *bcm,
-				      u16 rate,
-				      int is_ofdm)
+static void bcm43xx_periodic_every1sec(struct bcm43xx_wldev *dev)
 {
-	u16 offset;
+	int radio_hw_enable;
 
-	if (is_ofdm) {
-		offset = 0x480;
-		offset += (bcm43xx_plcp_get_ratecode_ofdm(rate) &amp; 0x000F) * 2;
-	}
-	else {
-		offset = 0x4C0;
-		offset += (bcm43xx_plcp_get_ratecode_cck(rate) &amp; 0x000F) * 2;
+	/* check if radio hardware enabled status changed */
+	radio_hw_enable = bcm43xx_is_hw_radio_enabled(dev);
+	if (unlikely(dev-&gt;radio_hw_enable != radio_hw_enable)) {
+		dev-&gt;radio_hw_enable = radio_hw_enable;
+		bcmdbg(dev-&gt;wl, &quot;Radio hardware status changed to %s\n&quot;,
+		       (radio_hw_enable == 0) ? &quot;disabled&quot; : &quot;enabled&quot;);
+		bcm43xx_leds_update(dev, 0);
 	}
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, offset + 0x20,
-			    bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, offset));
 }
 
-static void bcm43xx_rate_memory_init(struct bcm43xx_private *bcm)
+static void do_periodic_work(struct bcm43xx_wldev *dev)
 {
-	switch (bcm43xx_current_phy(bcm)-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-	case BCM43xx_PHYTYPE_G:
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_6MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_12MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_18MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_24MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_36MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_48MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_54MB, 1);
-	case BCM43xx_PHYTYPE_B:
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_1MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_2MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_5MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_11MB, 0);
-		break;
-	default:
-		assert(0);
-	}
+	unsigned int state;
+
+	state = dev-&gt;periodic_state;
+	if (state % 120 == 0)
+		bcm43xx_periodic_every120sec(dev);
+	if (state % 60 == 0)
+		bcm43xx_periodic_every60sec(dev);
+	if (state % 30 == 0)
+		bcm43xx_periodic_every30sec(dev);
+	if (state % 15 == 0)
+		bcm43xx_periodic_every15sec(dev);
+	bcm43xx_periodic_every1sec(dev);
 }
 
-static void bcm43xx_wireless_core_cleanup(struct bcm43xx_private *bcm)
+/* Estimate a &quot;Badness&quot; value based on the periodic work
+ * state-machine state. &quot;Badness&quot; is worse (bigger), if the
+ * periodic work will take longer.
+ */
+static int estimate_periodic_work_badness(unsigned int state)
 {
-	bcm43xx_chip_cleanup(bcm);
-	bcm43xx_pio_free(bcm);
-	bcm43xx_dma_free(bcm);
+	int badness = 0;
+
+	if (state % 120 == 0) /* every 120 sec */
+		badness += 10;
+	if (state % 60 == 0) /* every 60 sec */
+		badness += 5;
+	if (state % 30 == 0) /* every 30 sec */
+		badness += 1;
+	if (state % 15 == 0) /* every 15 sec */
+		badness += 1;
 
-	bcm-&gt;current_core-&gt;initialized = 0;
+#define BADNESS_LIMIT	4
+	return badness;
 }
 
-/* <A HREF="http://bcm-specs.sipsolutions.net/80211Init">http://bcm-specs.sipsolutions.net/80211Init</A> */
-static int bcm43xx_wireless_core_init(struct bcm43xx_private *bcm,
-				      int active_wlcore)
+static void bcm43xx_periodic_work_handler(struct work_struct *work)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u32 ucodeflags;
-	int err;
-	u32 sbimconfiglow;
-	u8 limit;
+	struct bcm43xx_wldev *dev =
+		container_of(work, struct bcm43xx_wldev, periodic_work.work);
+	unsigned long flags;
+	unsigned long delay;
+	u32 savedirqs = 0;
+	int badness;
 
-	if (bcm-&gt;core_pci.rev &lt;= 5 &amp;&amp; bcm-&gt;core_pci.id != BCM43xx_COREID_PCIE) {
-		sbimconfiglow = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMCONFIGLOW);
-		sbimconfiglow &amp;= ~ BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_MASK;
-		sbimconfiglow &amp;= ~ BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_MASK;
-		if (bcm-&gt;bustype == BCM43xx_BUSTYPE_PCI)
-			sbimconfiglow |= 0x32;
-		else
-			sbimconfiglow |= 0x53;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBIMCONFIGLOW, sbimconfiglow);
-	}
+	mutex_lock(&amp;dev-&gt;wl-&gt;mutex);
 
-	bcm43xx_phy_calibrate(bcm);
-	err = bcm43xx_chip_init(bcm);
-	if (err)
+	if (unlikely(bcm43xx_status(dev) != BCM43xx_STAT_STARTED))
 		goto out;
+	if (bcm43xx_debug(dev, BCM43xx_DBG_PWORK_STOP))
+		goto out_requeue;
 
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0016, bcm-&gt;current_core-&gt;rev);
-	ucodeflags = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, BCM43xx_UCODEFLAGS_OFFSET);
-
-	if (0 /*FIXME: which condition has to be used here? */)
-		ucodeflags |= 0x00000010;
+	badness = estimate_periodic_work_badness(dev-&gt;periodic_state);
+	if (badness &gt; BADNESS_LIMIT) {
+		spin_lock_irqsave(&amp;dev-&gt;wl-&gt;irq_lock, flags);
+		/* Suspend TX as we don't want to transmit packets while
+		 * we recalibrate the hardware. */
+		bcm43xx_tx_suspend(dev);
+		savedirqs = bcm43xx_interrupt_disable(dev, BCM43xx_IRQ_ALL);
+		/* Periodic work will take a long time, so we want it to
+		 * be preemtible and release the spinlock. */
+		spin_unlock_irqrestore(&amp;dev-&gt;wl-&gt;irq_lock, flags);
+		bcm43xx_synchronize_irq(dev);
+
+		do_periodic_work(dev);
+
+		spin_lock_irqsave(&amp;dev-&gt;wl-&gt;irq_lock, flags);
+		bcm43xx_interrupt_enable(dev, savedirqs);
+		bcm43xx_tx_resume(dev);
+		mmiowb();
+		spin_unlock_irqrestore(&amp;dev-&gt;wl-&gt;irq_lock, flags);
+	} else {
+		/* Take the global driver lock. This will lock any operation. */
+		spin_lock_irqsave(&amp;dev-&gt;wl-&gt;irq_lock, flags);
 
-	/* HW decryption needs to be set now */
-	ucodeflags |= 0x40000000;
-	
-	if (phy-&gt;type == BCM43xx_PHYTYPE_G) {
-		ucodeflags |= BCM43xx_UCODEFLAG_UNKBGPHY;
-		if (phy-&gt;rev == 1)
-			ucodeflags |= BCM43xx_UCODEFLAG_UNKGPHY;
-		if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_PACTRL)
-			ucodeflags |= BCM43xx_UCODEFLAG_UNKPACTRL;
-	} else if (phy-&gt;type == BCM43xx_PHYTYPE_B) {
-		ucodeflags |= BCM43xx_UCODEFLAG_UNKBGPHY;
-		if (phy-&gt;rev &gt;= 2 &amp;&amp; radio-&gt;version == 0x2050)
-			ucodeflags &amp;= ~BCM43xx_UCODEFLAG_UNKGPHY;
-	}
+		do_periodic_work(dev);
 
-	if (ucodeflags != bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-					     BCM43xx_UCODEFLAGS_OFFSET)) {
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODEFLAGS_OFFSET, ucodeflags);
+		mmiowb();
+		spin_unlock_irqrestore(&amp;dev-&gt;wl-&gt;irq_lock, flags);
 	}
-
-	/* Short/Long Retry Limit.
-	 * The retry-limit is a 4-bit counter. Enforce this to avoid overflowing
-	 * the chip-internal counter.
-	 */
-	limit = limit_value(modparam_short_retry, 0, 0xF);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0006, limit);
-	limit = limit_value(modparam_long_retry, 0, 0xF);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0007, limit);
-
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0044, 3);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0046, 2);
-
-	bcm43xx_rate_memory_init(bcm);
-
-	/* Minimum Contention Window */
-	if (phy-&gt;type == BCM43xx_PHYTYPE_B)
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0003, 0x0000001f);
+	dev-&gt;periodic_state++;
+out_requeue:
+	if (bcm43xx_debug(dev, BCM43xx_DBG_PWORK_FAST))
+		delay = msecs_to_jiffies(50);
 	else
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0003, 0x0000000f);
-	/* Maximum Contention Window */
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0004, 0x000003ff);
-
-	bcm43xx_gen_bssid(bcm);
-	bcm43xx_write_mac_bssid_templates(bcm);
-
-	if (bcm-&gt;current_core-&gt;rev &gt;= 5)
-		bcm43xx_write16(bcm, 0x043C, 0x000C);
-
-	if (active_wlcore) {
-		if (bcm43xx_using_pio(bcm)) {
-			err = bcm43xx_pio_init(bcm);
-		} else {
-			err = bcm43xx_dma_init(bcm);
-			if (err == -ENOSYS)
-				err = bcm43xx_pio_init(bcm);
-		}
-		if (err)
-			goto err_chip_cleanup;
-	}
-	bcm43xx_write16(bcm, 0x0612, 0x0050);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0416, 0x0050);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0414, 0x01F4);
-
-	if (active_wlcore) {
-		if (radio-&gt;initial_channel != 0xFF)
-			bcm43xx_radio_selectchannel(bcm, radio-&gt;initial_channel, 0);
-	}
-
-	/* Don't enable MAC/IRQ here, as it will race with the IRQ handler.
-	 * We enable it later.
-	 */
-	bcm-&gt;current_core-&gt;initialized = 1;
+		delay = round_jiffies(HZ);
+	queue_delayed_work(dev-&gt;wl-&gt;hw-&gt;workqueue,
+			   &amp;dev-&gt;periodic_work, delay);
 out:
-	return err;
-
-err_chip_cleanup:
-	bcm43xx_chip_cleanup(bcm);
-	goto out;
+	mutex_unlock(&amp;dev-&gt;wl-&gt;mutex);
 }
 
-static int bcm43xx_chipset_attach(struct bcm43xx_private *bcm)
+static void bcm43xx_periodic_tasks_delete(struct bcm43xx_wldev *dev)
 {
-	int err;
-	u16 pci_status;
-
-	err = bcm43xx_pctl_set_crystal(bcm, 1);
-	if (err)
-		goto out;
-	err = bcm43xx_pci_read_config16(bcm, PCI_STATUS, &amp;pci_status);
-	if (err)
-		goto out;
-	err = bcm43xx_pci_write_config16(bcm, PCI_STATUS, pci_status &amp; ~PCI_STATUS_SIG_TARGET_ABORT);
-
-out:
-	return err;
+	cancel_rearming_delayed_work(&amp;dev-&gt;periodic_work);
 }
 
-static void bcm43xx_chipset_detach(struct bcm43xx_private *bcm)
+static void bcm43xx_periodic_tasks_setup(struct bcm43xx_wldev *dev)
 {
-	bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_SLOW);
-	bcm43xx_pctl_set_crystal(bcm, 0);
-}
+	struct delayed_work *work = &amp;dev-&gt;periodic_work;
 
-static void bcm43xx_pcicore_broadcast_value(struct bcm43xx_private *bcm,
-					    u32 address,
-					    u32 data)
-{
-	bcm43xx_write32(bcm, BCM43xx_PCICORE_BCAST_ADDR, address);
-	bcm43xx_write32(bcm, BCM43xx_PCICORE_BCAST_DATA, data);
+	dev-&gt;periodic_state = 0;
+	INIT_DELAYED_WORK(work, bcm43xx_periodic_work_handler);
+	queue_delayed_work(dev-&gt;wl-&gt;hw-&gt;workqueue, work, 0);
 }
 
-static int bcm43xx_pcicore_commit_settings(struct bcm43xx_private *bcm)
+/* Validate access to the chip (SHM) */
+static int bcm43xx_validate_chipaccess(struct bcm43xx_wldev *dev)
 {
-	int err = 0;
-
-	bcm-&gt;irq_savedstate = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
+	u32 value;
+	u32 shm_backup;
 
-	if (bcm-&gt;core_chipcommon.available) {
-		err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_chipcommon);
-		if (err)
-			goto out;
+	shm_backup = bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED, 0);
+	bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED, 0, 0xAA5555AA);
+	if (bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED, 0) != 0xAA5555AA)
+		goto error;
+	bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED, 0, 0x55AAAA55);
+	if (bcm43xx_shm_read32(dev, BCM43xx_SHM_SHARED, 0) != 0x55AAAA55)
+		goto error;
+	bcm43xx_shm_write32(dev, BCM43xx_SHM_SHARED, 0, shm_backup);
 
-		bcm43xx_pcicore_broadcast_value(bcm, 0xfd8, 0x00000000);
+	value = bcm43xx_read32(dev, BCM43xx_MMIO_MACCTL);
+	if ((value | BCM43xx_MACCTL_GMODE) !=
+	    (BCM43xx_MACCTL_GMODE | BCM43xx_MACCTL_IHR_ENABLED))
+		goto error;
 
-		/* this function is always called when a PCI core is mapped */
-		err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_pci);
-		if (err)
-			goto out;
-	} else
-		bcm43xx_pcicore_broadcast_value(bcm, 0xfd8, 0x00000000);
+	value = bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_REASON);
+	if (value)
+		goto error;
 
-	bcm43xx_interrupt_enable(bcm, bcm-&gt;irq_savedstate);
+	return 0;
+error:
+	bcmerr(dev-&gt;wl, &quot;Failed to validate the chipaccess\n&quot;);
+	return -ENODEV;
+}
 
-out:
-	return err;
+static void bcm43xx_security_init(struct bcm43xx_wldev *dev)
+{
+	dev-&gt;max_nr_keys = (dev-&gt;dev-&gt;id.revision &gt;= 5) ? 58 : 20;
+	BCM43xx_WARN_ON(dev-&gt;max_nr_keys &gt; ARRAY_SIZE(dev-&gt;key));
+	dev-&gt;ktp = bcm43xx_shm_read16(dev, BCM43xx_SHM_SHARED,
+				      0x0056);
+	/* KTP is a word address, but we address SHM bytewise.
+	 * So multiply by two.
+	 */
+	dev-&gt;ktp *= 2;
+	if (dev-&gt;dev-&gt;id.revision &gt;= 5)
+		/* Number of RCMTA address slots */
+		bcm43xx_write16(dev, BCM43xx_MMIO_RCMTA_COUNT,
+				dev-&gt;max_nr_keys - 8);
+	bcm43xx_clear_keys(dev);
 }
 
-static u32 bcm43xx_pcie_reg_read(struct bcm43xx_private *bcm, u32 address)
+static int bcm43xx_rng_read(struct hwrng *rng, u32 *data)
 {
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_ADDR, address);
-	return bcm43xx_read32(bcm, BCM43xx_PCIECORE_REG_DATA);
+	struct bcm43xx_wl *wl = (struct bcm43xx_wl *)rng-&gt;priv;
+	unsigned long flags;
+
+	/* Don't take wl-&gt;mutex here, as it could deadlock with
+	 * hwrng internal locking. It's not needed to take
+	 * wl-&gt;mutex here, anyway. */
+
+	spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+	*data = bcm43xx_read16(wl-&gt;current_dev, BCM43xx_MMIO_RNG);
+	spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
+
+	return (sizeof(u16));
 }
 
-static void bcm43xx_pcie_reg_write(struct bcm43xx_private *bcm, u32 address,
-				    u32 data)
+static void bcm43xx_rng_exit(struct bcm43xx_wl *wl)
 {
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_ADDR, address);
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_DATA, data);
+	if (wl-&gt;rng_initialized)
+		hwrng_unregister(&amp;wl-&gt;rng);
 }
 
-static void bcm43xx_pcie_mdio_write(struct bcm43xx_private *bcm, u8 dev, u8 reg,
-				    u16 data)
+static int bcm43xx_rng_init(struct bcm43xx_wl *wl)
 {
-	int i;
+	int err;
 
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_CTL, 0x0082);
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_DATA, BCM43xx_PCIE_MDIO_ST |
-			BCM43xx_PCIE_MDIO_WT | (dev &lt;&lt; BCM43xx_PCIE_MDIO_DEV) |
-			(reg &lt;&lt; BCM43xx_PCIE_MDIO_REG) | BCM43xx_PCIE_MDIO_TA |
-			data);
-	udelay(10);
-
-	for (i = 0; i &lt; 10; i++) {
-		if (bcm43xx_read32(bcm, BCM43xx_PCIECORE_MDIO_CTL) &amp;
-		    BCM43xx_PCIE_MDIO_TC)
-			break;
-		msleep(1);
+	snprintf(wl-&gt;rng_name, ARRAY_SIZE(wl-&gt;rng_name),
+		 &quot;%s_%s&quot;, KBUILD_MODNAME, wiphy_name(wl-&gt;hw-&gt;wiphy));
+	wl-&gt;rng.name = wl-&gt;rng_name;
+	wl-&gt;rng.data_read = bcm43xx_rng_read;
+	wl-&gt;rng.priv = (unsigned long)wl;
+	wl-&gt;rng_initialized = 1;
+	err = hwrng_register(&amp;wl-&gt;rng);
+	if (err) {
+		wl-&gt;rng_initialized = 0;
+		bcmerr(wl, &quot;Failed to register the random &quot;
+		       &quot;number generator (%d)\n&quot;, err);
 	}
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_CTL, 0);
+
+	return err;
 }
 
-/* Make an I/O Core usable. &quot;core_mask&quot; is the bitmask of the cores to enable.
- * To enable core 0, pass a core_mask of 1&lt;&lt;0
- */
-static int bcm43xx_setup_backplane_pci_connection(struct bcm43xx_private *bcm,
-						  u32 core_mask)
+static int bcm43xx_tx(struct ieee80211_hw *hw,
+		      struct sk_buff *skb,
+		      struct ieee80211_tx_control *ctl)
 {
-	u32 backplane_flag_nr;
-	u32 value;
-	struct bcm43xx_coreinfo *old_core;
-	int err = 0;
-
-	value = bcm43xx_read32(bcm, BCM43xx_CIR_SBTPSFLAG);
-	backplane_flag_nr = value &amp; BCM43xx_BACKPLANE_FLAG_NR_MASK;
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl-&gt;current_dev;
+	int err = -ENODEV;
+	unsigned long flags;
 
-	old_core = bcm-&gt;current_core;
-	err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_pci);
-	if (err)
+	if (unlikely(!dev))
 		goto out;
-
-	if (bcm-&gt;current_core-&gt;rev &lt; 6 &amp;&amp;
-		bcm-&gt;current_core-&gt;id == BCM43xx_COREID_PCI) {
-		value = bcm43xx_read32(bcm, BCM43xx_CIR_SBINTVEC);
-		value |= (1 &lt;&lt; backplane_flag_nr);
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBINTVEC, value);
+	if (unlikely(bcm43xx_status(dev) &lt; BCM43xx_STAT_STARTED))
+		goto out;
+	/* DMA-TX is done without a global lock. */
+	if (bcm43xx_using_pio(dev)) {
+		spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+		err = bcm43xx_pio_tx(dev, skb, ctl);
+		spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
 	} else {
-		err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_ICR, &amp;value);
-		if (err) {
-			printk(KERN_ERR PFX &quot;Error: ICR setup failure!\n&quot;);
-			goto out_switch_back;
-		}
-		value |= core_mask &lt;&lt; 8;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_ICR, value);
-		if (err) {
-			printk(KERN_ERR PFX &quot;Error: ICR setup failure!\n&quot;);
-			goto out_switch_back;
-		}
+		err = bcm43xx_dma_tx(dev, skb, ctl);
 	}
+out:
+	if (unlikely(err))
+		return NETDEV_TX_BUSY;
+	return NETDEV_TX_OK;
+}
 
-	if (bcm-&gt;current_core-&gt;id == BCM43xx_COREID_PCI) {
-		value = bcm43xx_read32(bcm, BCM43xx_PCICORE_SBTOPCI2);
-		value |= BCM43xx_SBTOPCI2_PREFETCH | BCM43xx_SBTOPCI2_BURST;
-		bcm43xx_write32(bcm, BCM43xx_PCICORE_SBTOPCI2, value);
-
-		if (bcm-&gt;current_core-&gt;rev &lt; 5) {
-			value = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMCONFIGLOW);
-			value |= (2 &lt;&lt; BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_SHIFT)
-				 &amp; BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_MASK;
-			value |= (3 &lt;&lt; BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_SHIFT)
-				 &amp; BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_MASK;
-			bcm43xx_write32(bcm, BCM43xx_CIR_SBIMCONFIGLOW, value);
-			err = bcm43xx_pcicore_commit_settings(bcm);
-			assert(err == 0);
-		} else if (bcm-&gt;current_core-&gt;rev &gt;= 11) {
-			value = bcm43xx_read32(bcm, BCM43xx_PCICORE_SBTOPCI2);
-			value |= BCM43xx_SBTOPCI2_MEMREAD_MULTI;
-			bcm43xx_write32(bcm, BCM43xx_PCICORE_SBTOPCI2, value);
-		}
-	} else {
-		if (bcm-&gt;current_core-&gt;rev == 0 || bcm-&gt;current_core-&gt;rev == 1) {
-			value = bcm43xx_pcie_reg_read(bcm, BCM43xx_PCIE_TLP_WORKAROUND);
-			value |= 0x8;
-			bcm43xx_pcie_reg_write(bcm, BCM43xx_PCIE_TLP_WORKAROUND,
-					       value);
-		}
-		if (bcm-&gt;current_core-&gt;rev == 0) {
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_RXTIMER, 0x8128);
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_CDR, 0x0100);
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_CDR_BW, 0x1466);
-		} else if (bcm-&gt;current_core-&gt;rev == 1) {
-			value = bcm43xx_pcie_reg_read(bcm, BCM43xx_PCIE_DLLP_LINKCTL);
-			value |= 0x40;
-			bcm43xx_pcie_reg_write(bcm, BCM43xx_PCIE_DLLP_LINKCTL,
-					       value);
-		}
+static int bcm43xx_conf_tx(struct ieee80211_hw *hw,
+			   int queue,
+			   const struct ieee80211_tx_queue_params *params)
+{
+	return 0;
+}
+
+static int bcm43xx_get_tx_stats(struct ieee80211_hw *hw,
+				struct ieee80211_tx_queue_stats *stats)
+{
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl-&gt;current_dev;
+	unsigned long flags;
+	int err = -ENODEV;
+
+	if (!dev)
+		goto out;
+	spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+	if (likely(bcm43xx_status(dev) &gt;= BCM43xx_STAT_STARTED)) {
+		if (bcm43xx_using_pio(dev))
+			bcm43xx_pio_get_tx_stats(dev, stats);
+		else
+			bcm43xx_dma_get_tx_stats(dev, stats);
+		err = 0;
 	}
-out_switch_back:
-	err = bcm43xx_switch_core(bcm, old_core);
+	spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
 out:
 	return err;
 }
 
-static void bcm43xx_periodic_every120sec(struct bcm43xx_private *bcm)
+static int bcm43xx_get_stats(struct ieee80211_hw *hw,
+			     struct ieee80211_low_level_stats *stats)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	unsigned long flags;
 
-	if (phy-&gt;type != BCM43xx_PHYTYPE_G || phy-&gt;rev &lt; 2)
-		return;
+	spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+	memcpy(stats, &amp;wl-&gt;ieee_stats, sizeof(*stats));
+	spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
 
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_phy_lo_g_measure(bcm);
-	bcm43xx_mac_enable(bcm);
+	return 0;
 }
 
-static void bcm43xx_periodic_every60sec(struct bcm43xx_private *bcm)
+static int bcm43xx_dev_reset(struct ieee80211_hw *hw)
 {
-	bcm43xx_phy_lo_mark_all_unused(bcm);
-	if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_RSSI) {
-		bcm43xx_mac_suspend(bcm);
-		bcm43xx_calc_nrssi_slope(bcm);
-		bcm43xx_mac_enable(bcm);
-	}
-}
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl-&gt;current_dev;
+	unsigned long flags;
 
-static void bcm43xx_periodic_every30sec(struct bcm43xx_private *bcm)
-{
-	/* Update device statistics. */
-	bcm43xx_calculate_link_quality(bcm);
+	if (!dev)
+		return -ENODEV;
+	spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+	bcm43xx_controller_restart(dev, &quot;Reset by ieee80211 subsystem&quot;);
+	spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
+
+	return 0;
 }
 
-static void bcm43xx_periodic_every15sec(struct bcm43xx_private *bcm)
+static const char *phymode_to_string(unsigned int phymode)
 {
-	bcm43xx_phy_xmitpower(bcm); //FIXME: unless scanning?
-	//TODO for APHY (temperature?)
+	switch (phymode) {
+	case BCM43xx_PHYMODE_B:
+		return &quot;B&quot;;
+	case BCM43xx_PHYMODE_G:
+		return &quot;G&quot;;
+	default:
+		BCM43xx_BUG_ON(1);
+	}
+	return &quot;&quot;;
 }
 
-static void bcm43xx_periodic_every1sec(struct bcm43xx_private *bcm)
+static int find_wldev_for_phymode(struct bcm43xx_wl *wl,
+				  unsigned int phymode,
+				  struct bcm43xx_wldev **dev,
+				  bool *gmode)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	int radio_hw_enable;
+	struct bcm43xx_wldev *d;
 
-	/* check if radio hardware enabled status changed */
-	radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
-	if (unlikely(bcm-&gt;radio_hw_enable != radio_hw_enable)) {
-		bcm-&gt;radio_hw_enable = radio_hw_enable;
-		dprintk(KERN_INFO PFX &quot;Radio hardware status changed to %s\n&quot;,
-		       (radio_hw_enable == 0) ? &quot;disabled&quot; : &quot;enabled&quot;);
-		bcm43xx_leds_update(bcm, 0);
-	}
-	if (phy-&gt;type == BCM43xx_PHYTYPE_G) {
-		//TODO: update_aci_moving_average
-		if (radio-&gt;aci_enable &amp;&amp; radio-&gt;aci_wlan_automatic) {
-			bcm43xx_mac_suspend(bcm);
-			if (!radio-&gt;aci_enable &amp;&amp; 1 /*TODO: not scanning? */) {
-				if (0 /*TODO: bunch of conditions*/) {
-					bcm43xx_radio_set_interference_mitigation(bcm,
-										  BCM43xx_RADIO_INTERFMODE_MANUALWLAN);
-				}
-			} else if (1/*TODO*/) {
-				/*
-				if ((aci_average &gt; 1000) &amp;&amp; !(bcm43xx_radio_aci_scan(bcm))) {
-					bcm43xx_radio_set_interference_mitigation(bcm,
-										  BCM43xx_RADIO_INTERFMODE_NONE);
-				}
-				*/
-			}
-			bcm43xx_mac_enable(bcm);
-		} else if (radio-&gt;interfmode == BCM43xx_RADIO_INTERFMODE_NONWLAN &amp;&amp;
-			   phy-&gt;rev == 1) {
-			//TODO: implement rev1 workaround
+	list_for_each_entry(d, &amp;wl-&gt;devlist, list) {
+		if (d-&gt;phy.possible_phymodes &amp; phymode) {
+			/* Ok, this device supports the PHY-mode.
+			 * Set the gmode bit. */
+			*gmode = 1;
+			*dev = d;
+
+			return 0;
 		}
 	}
+
+	return -ESRCH;
 }
 
-static void do_periodic_work(struct bcm43xx_private *bcm)
+static void bcm43xx_put_phy_into_reset(struct bcm43xx_wldev *dev)
 {
-	if (bcm-&gt;periodic_state % 120 == 0)
-		bcm43xx_periodic_every120sec(bcm);
-	if (bcm-&gt;periodic_state % 60 == 0)
-		bcm43xx_periodic_every60sec(bcm);
-	if (bcm-&gt;periodic_state % 30 == 0)
-		bcm43xx_periodic_every30sec(bcm);
-	if (bcm-&gt;periodic_state % 15 == 0)
-		bcm43xx_periodic_every15sec(bcm);
-	bcm43xx_periodic_every1sec(bcm);
+	struct ssb_device *sdev = dev-&gt;dev;
+	u32 tmslow;
 
-	schedule_delayed_work(&amp;bcm-&gt;periodic_work, HZ);
+	tmslow = ssb_read32(sdev, SSB_TMSLOW);
+	tmslow &amp;= ~BCM43xx_TMSLOW_GMODE;
+	tmslow |= BCM43xx_TMSLOW_PHYRESET;
+	tmslow |= SSB_TMSLOW_FGC;
+	ssb_write32(sdev, SSB_TMSLOW, tmslow);
+	msleep(1);
+
+	tmslow = ssb_read32(sdev, SSB_TMSLOW);
+	tmslow &amp;= ~SSB_TMSLOW_FGC;
+	tmslow |= BCM43xx_TMSLOW_PHYRESET;
+	ssb_write32(sdev, SSB_TMSLOW, tmslow);
+	msleep(1);
 }
 
-static void bcm43xx_periodic_work_handler(struct work_struct *work)
+/* Expects wl-&gt;mutex locked */
+static int bcm43xx_switch_phymode(struct bcm43xx_wl *wl,
+				  unsigned int new_mode)
 {
-	struct bcm43xx_private *bcm =
-		container_of(work, struct bcm43xx_private, periodic_work.work);
-	struct net_device *net_dev = bcm-&gt;net_dev;
-	unsigned long flags;
-	u32 savedirqs = 0;
-	unsigned long orig_trans_start = 0;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	if (unlikely(bcm-&gt;periodic_state % 60 == 0)) {
-		/* Periodic work will take a long time, so we want it to
-		 * be preemtible.
-		 */
+	struct bcm43xx_wldev *up_dev;
+	struct bcm43xx_wldev *down_dev;
+	int err;
+	bool gmode = 0;
+	int prev_status;
 
-		netif_tx_lock_bh(net_dev);
-		/* We must fake a started transmission here, as we are going to
-		 * disable TX. If we wouldn't fake a TX, it would be possible to
-		 * trigger the netdev watchdog, if the last real TX is already
-		 * some time on the past (slightly less than 5secs)
-		 */
-		orig_trans_start = net_dev-&gt;trans_start;
-		net_dev-&gt;trans_start = jiffies;
-		netif_stop_queue(net_dev);
-		netif_tx_unlock_bh(net_dev);
-
-		spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-		bcm43xx_mac_suspend(bcm);
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_freeze_txqueues(bcm);
-		savedirqs = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-		spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-		bcm43xx_synchronize_irq(bcm);
-	} else {
-		/* Periodic work should take short time, so we want low
-		 * locking overhead.
-		 */
-		spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
+	err = find_wldev_for_phymode(wl, new_mode, &amp;up_dev, &amp;gmode);
+	if (err) {
+		bcmerr(wl, &quot;Could not find a device for %s-PHY mode\n&quot;,
+		       phymode_to_string(new_mode));
+		return err;
 	}
-
-	do_periodic_work(bcm);
-
-	if (unlikely(bcm-&gt;periodic_state % 60 == 0)) {
-		spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-		tasklet_enable(&amp;bcm-&gt;isr_tasklet);
-		bcm43xx_interrupt_enable(bcm, savedirqs);
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_thaw_txqueues(bcm);
-		bcm43xx_mac_enable(bcm);
-		netif_wake_queue(bcm-&gt;net_dev);
-		net_dev-&gt;trans_start = orig_trans_start;
+	if ((up_dev == wl-&gt;current_dev) &amp;&amp;
+	    (!!wl-&gt;current_dev-&gt;phy.gmode == !!gmode))
+		/* This device is already running. */
+		return 0;
+	bcmdbg(wl, &quot;Reconfiguring PHYmode to %s-PHY\n&quot;,
+	       phymode_to_string(new_mode));
+	down_dev = wl-&gt;current_dev;
+
+	prev_status = bcm43xx_status(down_dev);
+	/* Shutdown the currently running core. */
+	if (prev_status &gt;= BCM43xx_STAT_STARTED)
+		bcm43xx_wireless_core_stop(down_dev);
+	if (prev_status &gt;= BCM43xx_STAT_INITIALIZED)
+		bcm43xx_wireless_core_exit(down_dev);
+
+	if (down_dev != up_dev)
+		/* We switch to a different core, so we put PHY into
+		 * RESET on the old core. */
+		bcm43xx_put_phy_into_reset(down_dev);
+
+	/* Now start the new core. */
+	up_dev-&gt;phy.gmode = gmode;
+	if (prev_status &gt;= BCM43xx_STAT_INITIALIZED) {
+		err = bcm43xx_wireless_core_init(up_dev);
+		if (err) {
+			bcmerr(wl, &quot;Fatal: Could not initialize device for &quot;
+			       &quot;newly selected %s-PHY mode\n&quot;,
+			       phymode_to_string(new_mode));
+			goto init_failure;
+		}
 	}
-	mmiowb();
-	bcm-&gt;periodic_state++;
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-}
+	if (prev_status &gt;= BCM43xx_STAT_STARTED) {
+		err = bcm43xx_wireless_core_start(up_dev);
+		if (err) {
+			bcmerr(wl, &quot;Fatal: Coult not start device for &quot;
+			       &quot;newly selected %s-PHY mode\n&quot;,
+			       phymode_to_string(new_mode));
+			bcm43xx_wireless_core_exit(up_dev);
+			goto init_failure;
+		}
+	}
+	BCM43xx_WARN_ON(bcm43xx_status(up_dev) != prev_status);
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
-{
-	cancel_rearming_delayed_work(&amp;bcm-&gt;periodic_work);
-}
+	bcm43xx_shm_write32(up_dev, BCM43xx_SHM_SHARED, 0x003E, 0);
 
-void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
-{
-	struct delayed_work *work = &amp;bcm-&gt;periodic_work;
+	wl-&gt;current_dev = up_dev;
 
-	assert(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED);
-	INIT_DELAYED_WORK(work, bcm43xx_periodic_work_handler);
-	schedule_delayed_work(work, 0);
+	return 0;
+init_failure:
+	/* Whoops, failed to init the new core. No core is operating now. */
+	wl-&gt;current_dev = NULL;
+	return err;
 }
 
-static void bcm43xx_security_init(struct bcm43xx_private *bcm)
+static int bcm43xx_antenna_from_ieee80211(u8 antenna)
 {
-	bcm-&gt;security_offset = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-						  0x0056) * 2;
-	bcm43xx_clear_keys(bcm);
+	switch (antenna) {
+	case 0: /* default/diversity */
+		return BCM43xx_ANTENNA_DEFAULT;
+	case 1: /* Antenna 0 */
+		return BCM43xx_ANTENNA0;
+	case 2: /* Antenna 1 */
+		return BCM43xx_ANTENNA1;
+	default:
+		return BCM43xx_ANTENNA_DEFAULT;
+	}
 }
 
-static int bcm43xx_rng_read(struct hwrng *rng, u32 *data)
+static int bcm43xx_dev_config(struct ieee80211_hw *hw,
+			      struct ieee80211_conf *conf)
 {
-	struct bcm43xx_private *bcm = (struct bcm43xx_private *)rng-&gt;priv;
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev;
+	struct bcm43xx_phy *phy;
 	unsigned long flags;
+	unsigned int new_phymode = 0xFFFF;
+	int antenna_tx;
+	int antenna_rx;
+	int err = 0;
+	u32 savedirqs;
 
-	spin_lock_irqsave(&amp;(bcm)-&gt;irq_lock, flags);
-	*data = bcm43xx_read16(bcm, BCM43xx_MMIO_RNG);
-	spin_unlock_irqrestore(&amp;(bcm)-&gt;irq_lock, flags);
-
-	return (sizeof(u16));
-}
-
-static void bcm43xx_rng_exit(struct bcm43xx_private *bcm)
-{
-	hwrng_unregister(&amp;bcm-&gt;rng);
-}
+	antenna_tx = bcm43xx_antenna_from_ieee80211(conf-&gt;antenna_sel_tx);
+	antenna_rx = bcm43xx_antenna_from_ieee80211(conf-&gt;antenna_sel_rx);
 
-static int bcm43xx_rng_init(struct bcm43xx_private *bcm)
-{
-	int err;
+	mutex_lock(&amp;wl-&gt;mutex);
 
-	snprintf(bcm-&gt;rng_name, ARRAY_SIZE(bcm-&gt;rng_name),
-		 &quot;%s_%s&quot;, KBUILD_MODNAME, bcm-&gt;net_dev-&gt;name);
-	bcm-&gt;rng.name = bcm-&gt;rng_name;
-	bcm-&gt;rng.data_read = bcm43xx_rng_read;
-	bcm-&gt;rng.priv = (unsigned long)bcm;
-	err = hwrng_register(&amp;bcm-&gt;rng);
+	/* Switch the PHY mode (if necessary). */
+	switch (conf-&gt;phymode) {
+	case MODE_IEEE80211B:
+		new_phymode = BCM43xx_PHYMODE_B;
+		break;
+	case MODE_IEEE80211G:
+		new_phymode = BCM43xx_PHYMODE_G;
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
+	}
+	err = bcm43xx_switch_phymode(wl, new_phymode);
 	if (err)
-		printk(KERN_ERR PFX &quot;RNG init failed (%d)\n&quot;, err);
-
-	return err;
-}
+		goto out_unlock_mutex;
+	dev = wl-&gt;current_dev;
+	phy = &amp;dev-&gt;phy;
+
+	/* Disable IRQs while reconfiguring the device.
+	 * This makes it possible to drop the spinlock throughout
+	 * the reconfiguration process. */
+	spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+	if (bcm43xx_status(dev) &lt; BCM43xx_STAT_STARTED) {
+		spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
+		goto out_unlock_mutex;
+	}
+	savedirqs = bcm43xx_interrupt_disable(dev, BCM43xx_IRQ_ALL);
+	spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
+	bcm43xx_synchronize_irq(dev);
+
+	/* Switch to the requested channel.
+	 * The firmware takes care of races with the TX handler. */
+	if (conf-&gt;channel_val != phy-&gt;channel)
+		bcm43xx_radio_selectchannel(dev, conf-&gt;channel_val, 0);
+
+	/* Enable/Disable ShortSlot timing. */
+	if ((!!(conf-&gt;flags &amp; IEEE80211_CONF_SHORT_SLOT_TIME))
+	     != dev-&gt;short_slot) {
+		BCM43xx_WARN_ON(phy-&gt;type != BCM43xx_PHYTYPE_G);
+		if (conf-&gt;flags &amp; IEEE80211_CONF_SHORT_SLOT_TIME)
+			bcm43xx_short_slot_timing_enable(dev);
+		else
+			bcm43xx_short_slot_timing_disable(dev);
+	}
 
-static int bcm43xx_shutdown_all_wireless_cores(struct bcm43xx_private *bcm)
-{
-	int ret = 0;
-	int i, err;
-	struct bcm43xx_coreinfo *core;
-
-	bcm43xx_set_status(bcm, BCM43xx_STAT_SHUTTINGDOWN);
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++) {
-		core = &amp;(bcm-&gt;core_80211[i]);
-		assert(core-&gt;available);
-		if (!core-&gt;initialized)
-			continue;
-		err = bcm43xx_switch_core(bcm, core);
-		if (err) {
-			dprintk(KERN_ERR PFX &quot;shutdown_all_wireless_cores &quot;
-					     &quot;switch_core failed (%d)\n&quot;, err);
-			ret = err;
-			continue;
+	/* Adjust the desired TX power level. */
+	if (conf-&gt;power_level != 0) {
+		if (conf-&gt;power_level != phy-&gt;power_level) {
+			phy-&gt;power_level = conf-&gt;power_level;
+			bcm43xx_phy_xmitpower(dev);
 		}
-		bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-		bcm43xx_wireless_core_cleanup(bcm);
-		if (core == bcm-&gt;active_80211_core)
-			bcm-&gt;active_80211_core = NULL;
 	}
-	free_irq(bcm-&gt;irq, bcm);
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
 
-	return ret;
-}
+	/* Hide/Show the SSID (AP mode only). */
+	if (conf-&gt;flags &amp; IEEE80211_CONF_SSID_HIDDEN)
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+				bcm43xx_read32(dev,
+				BCM43xx_MMIO_STATUS_BITFIELD)
+				| BCM43xx_SBF_NO_SSID_BCAST);
+	else
+		bcm43xx_write32(dev, BCM43xx_MMIO_STATUS_BITFIELD,
+				bcm43xx_read32(dev,
+				BCM43xx_MMIO_STATUS_BITFIELD)
+				&amp; ~BCM43xx_SBF_NO_SSID_BCAST);
 
-/* This is the opposite of bcm43xx_init_board() */
-static void bcm43xx_free_board(struct bcm43xx_private *bcm)
-{
-	bcm43xx_rng_exit(bcm);
-	bcm43xx_sysfs_unregister(bcm);
-	bcm43xx_periodic_tasks_delete(bcm);
+	/* Antennas for RX and management frame TX. */
+	bcm43xx_mgmtframe_txantenna(dev, antenna_tx);
 
-	mutex_lock(&amp;(bcm)-&gt;mutex);
-	bcm43xx_shutdown_all_wireless_cores(bcm);
-	bcm43xx_pctl_set_crystal(bcm, 0);
-	mutex_unlock(&amp;(bcm)-&gt;mutex);
-}
+	/* Update templates for AP mode. */
+	if (bcm43xx_is_mode(wl, IEEE80211_IF_TYPE_AP))
+		bcm43xx_set_beacon_int(dev, conf-&gt;beacon_int);
 
-static void prepare_phydata_for_init(struct bcm43xx_phyinfo *phy)
-{
-	phy-&gt;antenna_diversity = 0xFFFF;
-	memset(phy-&gt;minlowsig, 0xFF, sizeof(phy-&gt;minlowsig));
-	memset(phy-&gt;minlowsigpos, 0, sizeof(phy-&gt;minlowsigpos));
 
-	/* Flags */
-	phy-&gt;calibrated = 0;
-	phy-&gt;is_locked = 0;
+	spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+	bcm43xx_interrupt_enable(dev, savedirqs);
+	mmiowb();
+	spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
+out_unlock_mutex:
+	mutex_unlock(&amp;wl-&gt;mutex);
 
-	if (phy-&gt;_lo_pairs) {
-		memset(phy-&gt;_lo_pairs, 0,
-		       sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT);
-	}
-	memset(phy-&gt;loopback_gain, 0, sizeof(phy-&gt;loopback_gain));
+	return err;
 }
 
-static void prepare_radiodata_for_init(struct bcm43xx_private *bcm,
-				       struct bcm43xx_radioinfo *radio)
+static int bcm43xx_dev_set_key(struct ieee80211_hw *hw,
+			       set_key_cmd cmd,
+			       u8 *addr,
+			       struct ieee80211_key_conf *key,
+			       int aid)
 {
-	int i;
-
-	/* Set default attenuation values. */
-	radio-&gt;baseband_atten = bcm43xx_default_baseband_attenuation(bcm);
-	radio-&gt;radio_atten = bcm43xx_default_radio_attenuation(bcm);
-	radio-&gt;txctl1 = bcm43xx_default_txctl1(bcm);
-	radio-&gt;txctl2 = 0xFFFF;
-	radio-&gt;txpwr_offset = 0;
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl-&gt;current_dev;
+	unsigned long flags;
+	u8 algorithm;
+	u8 index;
+	int err = -EINVAL;
 
-	/* NRSSI */
-	radio-&gt;nrssislope = 0;
-	for (i = 0; i &lt; ARRAY_SIZE(radio-&gt;nrssi); i++)
-		radio-&gt;nrssi[i] = -1000;
-	for (i = 0; i &lt; ARRAY_SIZE(radio-&gt;nrssi_lt); i++)
-		radio-&gt;nrssi_lt[i] = i;
+	if (!dev)
+		return -ENODEV;
+	switch (key-&gt;alg) {
+	case ALG_NONE:
+	case ALG_NULL:
+		algorithm = BCM43xx_SEC_ALGO_NONE;
+		break;
+	case ALG_WEP:
+		if (key-&gt;keylen == 5)
+			algorithm = BCM43xx_SEC_ALGO_WEP40;
+		else
+			algorithm = BCM43xx_SEC_ALGO_WEP104;
+		break;
+	case ALG_TKIP:
+		algorithm = BCM43xx_SEC_ALGO_TKIP;
+		break;
+	case ALG_CCMP:
+		algorithm = BCM43xx_SEC_ALGO_AES;
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
+		goto out;
+	}
 
-	radio-&gt;lofcal = 0xFFFF;
-	radio-&gt;initval = 0xFFFF;
+	index = (u8)(key-&gt;keyidx);
+	if (index &gt; 3)
+		goto out;
 
-	radio-&gt;aci_enable = 0;
-	radio-&gt;aci_wlan_automatic = 0;
-	radio-&gt;aci_hw_rssi = 0;
-}
+	mutex_lock(&amp;wl-&gt;mutex);
+	spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
 
-static void prepare_priv_for_init(struct bcm43xx_private *bcm)
-{
-	int i;
-	struct bcm43xx_coreinfo *core;
-	struct bcm43xx_coreinfo_80211 *wlext;
+	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED) {
+		err = -ENODEV;
+		goto out_unlock;
+	}
 
-	assert(!bcm-&gt;active_80211_core);
+	switch (cmd) {
+	case SET_KEY:
+		key-&gt;flags &amp;= ~IEEE80211_KEY_FORCE_SW_ENCRYPT;
+
+		if (algorithm == BCM43xx_SEC_ALGO_TKIP)
+			/* FIXME: No TKIP hardware encryption for now. */
+			key-&gt;flags |= IEEE80211_KEY_FORCE_SW_ENCRYPT;
+
+		if (is_broadcast_ether_addr(addr))
+			/* addr is FF:FF:FF:FF:FF:FF for default keys */
+			err = bcm43xx_key_write(dev, index, algorithm,
+						key-&gt;key, key-&gt;keylen,
+						NULL, key);
+		else
+			err = bcm43xx_key_write(dev, -1, algorithm,
+						key-&gt;key, key-&gt;keylen,
+						addr, key);
+		if (err) {
+			key-&gt;flags |= IEEE80211_KEY_FORCE_SW_ENCRYPT;
+			goto out_unlock;
+		}
+		dev-&gt;key[key-&gt;hw_key_idx].enabled = 1;
 
-	bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZING);
+	case DISABLE_KEY: {
+		static const u8 zero[BCM43xx_SEC_KEYSIZE] = { 0 };
 
-	/* Flags */
-	bcm-&gt;was_initialized = 0;
-	bcm-&gt;reg124_set_0x4 = 0;
+		algorithm = BCM43xx_SEC_ALGO_NONE;
+		if (is_broadcast_ether_addr(addr))
+			err = bcm43xx_key_write(dev, index, algorithm,
+						zero, BCM43xx_SEC_KEYSIZE,
+						NULL, key);
+		else
+			err = bcm43xx_key_write(dev, -1, algorithm,
+						zero, BCM43xx_SEC_KEYSIZE,
+						addr, key);
+		dev-&gt;key[key-&gt;hw_key_idx].enabled = 0;
+		break;
+	}
+	case REMOVE_ALL_KEYS:
+		bcm43xx_clear_keys(dev);
+		err = 0;
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
+	}
+out_unlock:
+	spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
+	mutex_unlock(&amp;wl-&gt;mutex);
+out:
+	if (!err)
+		bcmdbg(wl, &quot;Using %s based encryption for keyidx: %d, &quot;
+		       &quot;mac: &quot; MAC_FMT &quot;\n&quot;,
+		       (key-&gt;flags &amp; IEEE80211_KEY_FORCE_SW_ENCRYPT) ?
+		       &quot;software&quot; : &quot;hardware&quot;,
+		       key-&gt;keyidx, MAC_ARG(addr));
+	return err;
+}
 
-	/* Stats */
-	memset(&amp;bcm-&gt;stats, 0, sizeof(bcm-&gt;stats));
+static void bcm43xx_set_multicast_list(struct ieee80211_hw *hw,
+				       unsigned short netflags,
+				       int mc_count)
+{
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl-&gt;current_dev;
+	unsigned long flags;
 
-	/* Wireless core data */
-	for (i = 0; i &lt; BCM43xx_MAX_80211_CORES; i++) {
-		core = &amp;(bcm-&gt;core_80211[i]);
-		wlext = core-&gt;priv;
+	if (!dev)
+		return;
+	spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+	if (wl-&gt;promisc != !!(netflags &amp; IFF_PROMISC)) {
+		wl-&gt;promisc = !!(netflags &amp; IFF_PROMISC);
+		if (bcm43xx_status(dev) == BCM43xx_STAT_INITIALIZED)
+			bcm43xx_adjust_opmode(dev);
+	}
+	spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
+}
 
-		if (!core-&gt;available)
-			continue;
-		assert(wlext == &amp;(bcm-&gt;core_80211_ext[i]));
+static int bcm43xx_config_interface(struct ieee80211_hw *hw,
+				    int if_id,
+				    struct ieee80211_if_conf *conf)
+{
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev = wl-&gt;current_dev;
+	unsigned long flags;
 
-		prepare_phydata_for_init(&amp;wlext-&gt;phy);
-		prepare_radiodata_for_init(bcm, &amp;wlext-&gt;radio);
+	if (!dev)
+		return -ENODEV;
+	mutex_lock(&amp;wl-&gt;mutex);
+	spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+	if (conf-&gt;type != IEEE80211_IF_TYPE_MNTR) {
+		BCM43xx_WARN_ON(wl-&gt;if_id != if_id);
+		wl-&gt;bssid = conf-&gt;bssid;
+		if (bcm43xx_is_mode(wl, IEEE80211_IF_TYPE_AP)) {
+			BCM43xx_WARN_ON(conf-&gt;type != IEEE80211_IF_TYPE_AP);
+			bcm43xx_set_ssid(dev, conf-&gt;ssid, conf-&gt;ssid_len);
+			if (conf-&gt;beacon)
+				bcm43xx_refresh_templates(dev, conf-&gt;beacon);
+		}
+		bcm43xx_write_mac_bssid_templates(dev);
 	}
+	spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
+	mutex_unlock(&amp;wl-&gt;mutex);
 
-	/* IRQ related flags */
-	bcm-&gt;irq_reason = 0;
-	memset(bcm-&gt;dma_reason, 0, sizeof(bcm-&gt;dma_reason));
-	bcm-&gt;irq_savedstate = BCM43xx_IRQ_INITIAL;
+	return 0;
+}
 
-	bcm-&gt;mac_suspended = 1;
+/* Locking: wl-&gt;mutex */
+static void bcm43xx_wireless_core_stop(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_wl *wl = dev-&gt;wl;
+	unsigned long flags;
 
-	/* Noise calculation context */
-	memset(&amp;bcm-&gt;noisecalc, 0, sizeof(bcm-&gt;noisecalc));
+	if (bcm43xx_status(dev) &lt; BCM43xx_STAT_STARTED)
+		return;
+	bcm43xx_set_status(dev, BCM43xx_STAT_INITIALIZED);
 
-	/* Periodic work context */
-	bcm-&gt;periodic_state = 0;
+	mutex_unlock(&amp;wl-&gt;mutex);
+	/* Must unlock as it would otherwise deadlock. No races here. */
+	bcm43xx_periodic_tasks_delete(dev);
+	flush_workqueue(dev-&gt;wl-&gt;hw-&gt;workqueue);
+	mutex_lock(&amp;wl-&gt;mutex);
+
+	ieee80211_stop_queues(wl-&gt;hw); /* FIXME this could cause a deadlock */
+
+	/* Disable and sync interrupts. */
+	spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+	dev-&gt;irq_savedstate = bcm43xx_interrupt_disable(dev, BCM43xx_IRQ_ALL);
+	bcm43xx_read32(dev, BCM43xx_MMIO_GEN_IRQ_MASK); /* flush */
+	spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
+	bcm43xx_synchronize_irq(dev);
+
+	bcm43xx_mac_suspend(dev);
+	free_irq(dev-&gt;dev-&gt;irq, dev);
+	bcmdbg(wl, &quot;Wireless interface stopped\n&quot;);
 }
 
-static int wireless_core_up(struct bcm43xx_private *bcm,
-			    int active_wlcore)
+/* Locking: wl-&gt;mutex */
+static int bcm43xx_wireless_core_start(struct bcm43xx_wldev *dev)
 {
 	int err;
 
-	if (!bcm43xx_core_enabled(bcm))
-		bcm43xx_wireless_core_reset(bcm, 1);
-	if (!active_wlcore)
-		bcm43xx_wireless_core_mark_inactive(bcm);
-	err = bcm43xx_wireless_core_init(bcm, active_wlcore);
-	if (err)
+	BCM43xx_WARN_ON(bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED);
+
+	drain_txstatus_queue(dev);
+	err = request_irq(dev-&gt;dev-&gt;irq, bcm43xx_interrupt_handler,
+			  IRQF_SHARED, KBUILD_MODNAME, dev);
+	if (err) {
+		bcmerr(dev-&gt;wl, &quot;Cannot request IRQ-%d\n&quot;,
+		       dev-&gt;dev-&gt;irq);
 		goto out;
-	if (!active_wlcore)
-		bcm43xx_radio_turn_off(bcm);
+	}
+	bcm43xx_mac_enable(dev);
+
+	bcm43xx_periodic_tasks_setup(dev);
+
+	ieee80211_start_queues(dev-&gt;wl-&gt;hw);
+	bcm43xx_set_status(dev, BCM43xx_STAT_STARTED);
+	bcm43xx_interrupt_enable(dev, dev-&gt;irq_savedstate);
+	bcmdbg(dev-&gt;wl, &quot;Wireless interface started\n&quot;);
 out:
 	return err;
 }
 
-/* Select and enable the &quot;to be used&quot; wireless core.
- * Locking: bcm-&gt;mutex must be aquired before calling this.
- *          bcm-&gt;irq_lock must not be aquired.
- */
-int bcm43xx_select_wireless_core(struct bcm43xx_private *bcm,
-				 int phytype)
+/* Get PHY and RADIO versioning numbers */
+static int bcm43xx_phy_versioning(struct bcm43xx_wldev *dev)
 {
-	int i, err;
-	struct bcm43xx_coreinfo *active_core = NULL;
-	struct bcm43xx_coreinfo_80211 *active_wlext = NULL;
-	struct bcm43xx_coreinfo *core;
-	struct bcm43xx_coreinfo_80211 *wlext;
-	int adjust_active_sbtmstatelow = 0;
-
-	might_sleep();
-
-	if (phytype &lt; 0) {
-		/* If no phytype is requested, select the first core. */
-		assert(bcm-&gt;core_80211[0].available);
-		wlext = bcm-&gt;core_80211[0].priv;
-		phytype = wlext-&gt;phy.type;
-	}
-	/* Find the requested core. */
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++) {
-		core = &amp;(bcm-&gt;core_80211[i]);
-		wlext = core-&gt;priv;
-		if (wlext-&gt;phy.type == phytype) {
-			active_core = core;
-			active_wlext = wlext;
-			break;
-		}
+	struct bcm43xx_phy *phy = &amp;dev-&gt;phy;
+	u32 tmp;
+	u8 analog_type;
+	u8 phy_type;
+	u8 phy_rev;
+	u16 radio_manuf;
+	u16 radio_ver;
+	u16 radio_rev;
+	int unsupported = 0;
+
+	/* Get PHY versioning */
+	tmp = bcm43xx_read16(dev, BCM43xx_MMIO_PHY_VER);
+	analog_type = (tmp &amp; BCM43xx_PHYVER_ANALOG)
+		      &gt;&gt; BCM43xx_PHYVER_ANALOG_SHIFT;
+	phy_type = (tmp &amp; BCM43xx_PHYVER_TYPE) &gt;&gt; BCM43xx_PHYVER_TYPE_SHIFT;
+	phy_rev = (tmp &amp; BCM43xx_PHYVER_VERSION);
+	switch (phy_type) {
+	case BCM43xx_PHYTYPE_B:
+		if (phy_rev != 2 &amp;&amp; phy_rev != 4
+		    &amp;&amp; phy_rev != 6 &amp;&amp; phy_rev != 7)
+			unsupported = 1;
+		break;
+	case BCM43xx_PHYTYPE_G:
+		if (phy_rev &gt; 8)
+			unsupported = 1;
+		break;
+	default:
+		unsupported = 1;
+	};
+	if (unsupported) {
+		bcmerr(dev-&gt;wl, &quot;FOUND UNSUPPORTED PHY &quot;
+		       &quot;(Analog %u, Type %u, Revision %u)\n&quot;,
+		       analog_type, phy_type, phy_rev);
+		return -EOPNOTSUPP;
+	}
+	bcmdbg(dev-&gt;wl, &quot;Found PHY: Analog %u, Type %u, Revision %u\n&quot;,
+	       analog_type, phy_type, phy_rev);
+
+
+	/* Get RADIO versioning */
+	if (dev-&gt;dev-&gt;bus-&gt;chip_id == 0x4317) {
+		if (dev-&gt;dev-&gt;bus-&gt;chip_rev == 0)
+			tmp = 0x3205017F;
+		else if (dev-&gt;dev-&gt;bus-&gt;chip_rev == 1)
+			tmp = 0x4205017F;
+		else
+			tmp = 0x5205017F;
+	} else {
+		bcm43xx_write16(dev, BCM43xx_MMIO_RADIO_CONTROL,
+				BCM43xx_RADIOCTL_ID);
+		tmp = bcm43xx_read16(dev, BCM43xx_MMIO_RADIO_DATA_HIGH);
+		tmp &lt;&lt;= 16;
+		bcm43xx_write16(dev, BCM43xx_MMIO_RADIO_CONTROL,
+				BCM43xx_RADIOCTL_ID);
+		tmp |= bcm43xx_read16(dev, BCM43xx_MMIO_RADIO_DATA_LOW);
+	}
+	radio_manuf = (tmp &amp; 0x00000FFF);
+	radio_ver = (tmp &amp; 0x0FFFF000) &gt;&gt; 12;
+	radio_rev = (tmp &amp; 0xF0000000) &gt;&gt; 28;
+	switch (phy_type) {
+	case BCM43xx_PHYTYPE_B:
+		if ((radio_ver &amp; 0xFFF0) != 0x2050)
+			unsupported = 1;
+		break;
+	case BCM43xx_PHYTYPE_G:
+		if (radio_ver != 0x2050)
+			unsupported = 1;
+		break;
+	default:
+		BCM43xx_BUG_ON(1);
 	}
-	if (!active_core)
-		return -ESRCH; /* No such PHYTYPE on this board. */
-
-	if (bcm-&gt;active_80211_core) {
-		/* We already selected a wl core in the past.
-		 * So first clean up everything.
-		 */
-		dprintk(KERN_INFO PFX &quot;select_wireless_core: cleanup\n&quot;);
-		ieee80211softmac_stop(bcm-&gt;net_dev);
-		bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZED);
-		err = bcm43xx_disable_interrupts_sync(bcm);
-		assert(!err);
-		tasklet_enable(&amp;bcm-&gt;isr_tasklet);
-		err = bcm43xx_shutdown_all_wireless_cores(bcm);
-		if (err)
-			goto error;
-		/* Ok, everything down, continue to re-initialize. */
-		bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZING);
+	if (unsupported) {
+		bcmerr(dev-&gt;wl, &quot;FOUND UNSUPPORTED RADIO &quot;
+		       &quot;(Manuf 0x%X, Version 0x%X, Revision %u)\n&quot;,
+		       radio_manuf, radio_ver, radio_rev);
+		return -EOPNOTSUPP;
 	}
+	bcmdbg(dev-&gt;wl, &quot;Found Radio: Manuf 0x%X, Version 0x%X, Revision %u\n&quot;,
+	       radio_manuf, radio_ver, radio_rev);
 
-	/* Reset all data structures. */
-	prepare_priv_for_init(bcm);
 
-	err = bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_FAST);
-	if (err)
-		goto error;
+	phy-&gt;radio_manuf = radio_manuf;
+	phy-&gt;radio_ver = radio_ver;
+	phy-&gt;radio_rev = radio_rev;
 
-	/* Mark all unused cores &quot;inactive&quot;. */
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++) {
-		core = &amp;(bcm-&gt;core_80211[i]);
-		wlext = core-&gt;priv;
+	phy-&gt;analog = analog_type;
+	phy-&gt;type = phy_type;
+	phy-&gt;rev = phy_rev;
 
-		if (core == active_core)
-			continue;
-		err = bcm43xx_switch_core(bcm, core);
-		if (err) {
-			dprintk(KERN_ERR PFX &quot;Could not switch to inactive &quot;
-					     &quot;802.11 core (%d)\n&quot;, err);
-			goto error;
-		}
-		err = wireless_core_up(bcm, 0);
-		if (err) {
-			dprintk(KERN_ERR PFX &quot;core_up for inactive 802.11 core &quot;
-					     &quot;failed (%d)\n&quot;, err);
-			goto error;
-		}
-		adjust_active_sbtmstatelow = 1;
-	}
+	return 0;
+}
 
-	/* Now initialize the active 802.11 core. */
-	err = bcm43xx_switch_core(bcm, active_core);
-	if (err) {
-		dprintk(KERN_ERR PFX &quot;Could not switch to active &quot;
-				     &quot;802.11 core (%d)\n&quot;, err);
-		goto error;
-	}
-	if (adjust_active_sbtmstatelow &amp;&amp;
-	    active_wlext-&gt;phy.type == BCM43xx_PHYTYPE_G) {
-		u32 sbtmstatelow;
-
-		sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-		sbtmstatelow |= BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	}
-	err = wireless_core_up(bcm, 1);
-	if (err) {
-		dprintk(KERN_ERR PFX &quot;core_up for active 802.11 core &quot;
-				     &quot;failed (%d)\n&quot;, err);
-		goto error;
-	}
-	err = bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_DYNAMIC);
-	if (err)
-		goto error;
-	bcm-&gt;active_80211_core = active_core;
+static void setup_struct_phy_for_init(struct bcm43xx_wldev *dev,
+				      struct bcm43xx_phy *phy)
+{
+	struct bcm43xx_lopair *lo;
+	int i;
 
-	bcm43xx_macfilter_clear(bcm, BCM43xx_MACFILTER_ASSOC);
-	bcm43xx_macfilter_set(bcm, BCM43xx_MACFILTER_SELF, (u8 *)(bcm-&gt;net_dev-&gt;dev_addr));
-	bcm43xx_security_init(bcm);
-	drain_txstatus_queue(bcm);
-	ieee80211softmac_start(bcm-&gt;net_dev);
+	memset(phy-&gt;minlowsig, 0xFF, sizeof(phy-&gt;minlowsig));
+	memset(phy-&gt;minlowsigpos, 0, sizeof(phy-&gt;minlowsigpos));
 
-	/* Let's go! Be careful after enabling the IRQs.
-	 * Don't switch cores, for example.
-	 */
-	bcm43xx_mac_enable(bcm);
-	bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZED);
-	err = bcm43xx_initialize_irq(bcm);
-	if (err)
-		goto error;
-	bcm43xx_interrupt_enable(bcm, bcm-&gt;irq_savedstate);
+	/* Flags */
+	phy-&gt;locked = 0;
 
-	dprintk(KERN_INFO PFX &quot;Selected 802.11 core (phytype %d)\n&quot;,
-		active_wlext-&gt;phy.type);
+	phy-&gt;savedpctlreg = 0xFFFF;
+	phy-&gt;aci_enable = 0;
+	phy-&gt;aci_wlan_automatic = 0;
+	phy-&gt;aci_hw_rssi = 0;
+
+	lo = phy-&gt;_lo_pairs;
+	if (lo)
+		memset(lo, 0, sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT);
+	phy-&gt;max_lb_gain = 0;
+	phy-&gt;trsw_rx_gain = 0;
 
-	return 0;
+	/* Set default attenuation values. */
+	phy-&gt;bbatt = bcm43xx_default_baseband_attenuation(dev);
+	phy-&gt;rfatt = bcm43xx_default_radio_attenuation(dev);
+	phy-&gt;txctl1 = bcm43xx_default_txctl1(dev);
+	phy-&gt;txpwr_offset = 0;
 
-error:
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-	bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_SLOW);
-	return err;
-}
+	/* NRSSI */
+	phy-&gt;nrssislope = 0;
+	for (i = 0; i &lt; ARRAY_SIZE(phy-&gt;nrssi); i++)
+		phy-&gt;nrssi[i] = -1000;
+	for (i = 0; i &lt; ARRAY_SIZE(phy-&gt;nrssi_lt); i++)
+		phy-&gt;nrssi_lt[i] = i;
 
-static int bcm43xx_init_board(struct bcm43xx_private *bcm)
-{
-	int err;
+	phy-&gt;lofcal = 0xFFFF;
+	phy-&gt;initval = 0xFFFF;
 
-	mutex_lock(&amp;(bcm)-&gt;mutex);
+	spin_lock_init(&amp;phy-&gt;lock);
+	phy-&gt;interfmode = BCM43xx_INTERFMODE_NONE;
+	phy-&gt;channel = 0xFF;
+}
 
-	tasklet_enable(&amp;bcm-&gt;isr_tasklet);
-	err = bcm43xx_pctl_set_crystal(bcm, 1);
-	if (err)
-		goto err_tasklet;
-	err = bcm43xx_pctl_init(bcm);
-	if (err)
-		goto err_crystal_off;
-	err = bcm43xx_select_wireless_core(bcm, -1);
-	if (err)
-		goto err_crystal_off;
-	err = bcm43xx_sysfs_register(bcm);
-	if (err)
-		goto err_wlshutdown;
-	err = bcm43xx_rng_init(bcm);
-	if (err)
-		goto err_sysfs_unreg;
-	bcm43xx_periodic_tasks_setup(bcm);
+static void setup_struct_wldev_for_init(struct bcm43xx_wldev *dev)
+{
+	/* Flags */
+	dev-&gt;reg124_set_0x4 = 0;
 
-	/*FIXME: This should be handled by softmac instead. */
-	schedule_delayed_work(&amp;bcm-&gt;softmac-&gt;associnfo.work, 0);
+	/* Stats */
+	memset(&amp;dev-&gt;stats, 0, sizeof(dev-&gt;stats));
 
-out:
-	mutex_unlock(&amp;(bcm)-&gt;mutex);
+	setup_struct_phy_for_init(dev, &amp;dev-&gt;phy);
 
-	return err;
+	/* IRQ related flags */
+	dev-&gt;irq_reason = 0;
+	memset(dev-&gt;dma_reason, 0, sizeof(dev-&gt;dma_reason));
+	dev-&gt;irq_savedstate = BCM43xx_IRQ_MASKTEMPLATE;
 
-err_sysfs_unreg:
-	bcm43xx_sysfs_unregister(bcm);
-err_wlshutdown:
-	bcm43xx_shutdown_all_wireless_cores(bcm);
-err_crystal_off:
-	bcm43xx_pctl_set_crystal(bcm, 0);
-err_tasklet:
-	tasklet_disable(&amp;bcm-&gt;isr_tasklet);
-	goto out;
+	dev-&gt;mac_suspended = 1;
+
+	/* Noise calculation context */
+	memset(&amp;dev-&gt;noisecalc, 0, sizeof(dev-&gt;noisecalc));
 }
 
-static void bcm43xx_detach_board(struct bcm43xx_private *bcm)
+static void bcm43xx_imcfglo_timeouts_workaround(struct bcm43xx_wldev *dev)
 {
-	struct pci_dev *pci_dev = bcm-&gt;pci_dev;
-	int i;
+#ifdef CONFIG_SSB_DRIVER_PCICORE
+	struct ssb_bus *bus = dev-&gt;dev-&gt;bus;
+	u32 tmp;
 
-	bcm43xx_chipset_detach(bcm);
-	/* Do _not_ access the chip, after it is detached. */
-	pci_iounmap(pci_dev, bcm-&gt;mmio_addr);
-	pci_release_regions(pci_dev);
-	pci_disable_device(pci_dev);
-
-	/* Free allocated structures/fields */
-	for (i = 0; i &lt; BCM43xx_MAX_80211_CORES; i++) {
-		kfree(bcm-&gt;core_80211_ext[i].phy._lo_pairs);
-		if (bcm-&gt;core_80211_ext[i].phy.dyn_tssi_tbl)
-			kfree(bcm-&gt;core_80211_ext[i].phy.tssi2dbm);
+	if (bus-&gt;pcicore.dev &amp;&amp;
+	    bus-&gt;pcicore.dev-&gt;id.coreid == SSB_DEV_PCI &amp;&amp;
+	    bus-&gt;pcicore.dev-&gt;id.revision &lt;= 5) {
+		/* IMCFGLO timeouts workaround. */
+		tmp = ssb_read32(dev-&gt;dev, SSB_IMCFGLO);
+		tmp &amp;= ~SSB_IMCFGLO_REQTO;
+		tmp &amp;= ~SSB_IMCFGLO_SERTO;
+		switch (bus-&gt;bustype) {
+		case SSB_BUSTYPE_PCI:
+		case SSB_BUSTYPE_PCMCIA:
+			tmp |= 0x32;
+			break;
+		case SSB_BUSTYPE_SSB:
+			tmp |= 0x53;
+			break;
+		}
+		ssb_write32(dev-&gt;dev, SSB_IMCFGLO, tmp);
 	}
-}	
+#endif /* CONFIG_SSB_DRIVER_PCICORE */
+}
 
-static int bcm43xx_read_phyinfo(struct bcm43xx_private *bcm)
+/* Shutdown a wireless core */
+static void bcm43xx_wireless_core_exit(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 value;
-	u8 phy_analog;
-	u8 phy_type;
-	u8 phy_rev;
-	int phy_rev_ok = 1;
-	void *p;
+	struct bcm43xx_phy *phy = &amp;dev-&gt;phy;
 
-	value = bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_VER);
+	BCM43xx_WARN_ON(bcm43xx_status(dev) &gt; BCM43xx_STAT_INITIALIZED);
+	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED)
+		return;
 
-	phy_analog = (value &amp; 0xF000) &gt;&gt; 12;
-	phy_type = (value &amp; 0x0F00) &gt;&gt; 8;
-	phy_rev = (value &amp; 0x000F);
+	bcm43xx_rng_exit(dev-&gt;wl);
+	bcm43xx_pio_free(dev);
+	bcm43xx_dma_free(dev);
+	bcm43xx_chip_exit(dev);
+	bcm43xx_radio_turn_off(dev);
+	bcm43xx_switch_analog(dev, 0);
+	if (phy-&gt;dyn_tssi_tbl)
+		kfree(phy-&gt;tssi2dbm);
+	kfree(phy-&gt;lo_control);
+	phy-&gt;lo_control = NULL;
+	ssb_device_disable(dev-&gt;dev, 0);
+	ssb_bus_may_powerdown(dev-&gt;dev-&gt;bus);
+	bcm43xx_set_status(dev, BCM43xx_STAT_UNINIT);
+}
 
-	dprintk(KERN_INFO PFX &quot;Detected PHY: Analog: %x, Type %x, Revision %x\n&quot;,
-		phy_analog, phy_type, phy_rev);
+static void prepare_phy_data_for_init(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &amp;dev-&gt;phy;
+	int i;
 
-	switch (phy_type) {
-	case BCM43xx_PHYTYPE_A:
-		if (phy_rev &gt;= 4)
-			phy_rev_ok = 0;
-		/*FIXME: We need to switch the ieee-&gt;modulation, etc.. flags,
-		 *       if we switch 80211 cores after init is done.
-		 *       As we do not implement on the fly switching between
-		 *       wireless cores, I will leave this as a future task.
-		 */
-		bcm-&gt;ieee-&gt;modulation = IEEE80211_OFDM_MODULATION;
-		bcm-&gt;ieee-&gt;mode = IEEE_A;
-		bcm-&gt;ieee-&gt;freq_band = IEEE80211_52GHZ_BAND |
-				       IEEE80211_24GHZ_BAND;
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if (phy_rev != 2 &amp;&amp; phy_rev != 4 &amp;&amp; phy_rev != 6 &amp;&amp; phy_rev != 7)
-			phy_rev_ok = 0;
-		bcm-&gt;ieee-&gt;modulation = IEEE80211_CCK_MODULATION;
-		bcm-&gt;ieee-&gt;mode = IEEE_B;
-		bcm-&gt;ieee-&gt;freq_band = IEEE80211_24GHZ_BAND;
-		break;
-	case BCM43xx_PHYTYPE_G:
-		if (phy_rev &gt; 8)
-			phy_rev_ok = 0;
-		bcm-&gt;ieee-&gt;modulation = IEEE80211_OFDM_MODULATION |
-					IEEE80211_CCK_MODULATION;
-		bcm-&gt;ieee-&gt;mode = IEEE_G;
-		bcm-&gt;ieee-&gt;freq_band = IEEE80211_24GHZ_BAND;
-		break;
-	default:
-		printk(KERN_ERR PFX &quot;Error: Unknown PHY Type %x\n&quot;,
-		       phy_type);
-		return -ENODEV;
-	};
-	bcm-&gt;ieee-&gt;perfect_rssi = RX_RSSI_MAX;
-	bcm-&gt;ieee-&gt;worst_rssi = 0;
-	if (!phy_rev_ok) {
-		printk(KERN_WARNING PFX &quot;Invalid PHY Revision %x\n&quot;,
-		       phy_rev);
-	}
+	/* Set default attenuation values. */
+	phy-&gt;bbatt = bcm43xx_default_baseband_attenuation(dev);
+	phy-&gt;rfatt = bcm43xx_default_radio_attenuation(dev);
+	phy-&gt;txctl1 = bcm43xx_default_txctl1(dev);
+	phy-&gt;txctl2 = 0xFFFF;
+	phy-&gt;txpwr_offset = 0;
 
-	phy-&gt;analog = phy_analog;
-	phy-&gt;type = phy_type;
-	phy-&gt;rev = phy_rev;
-	if ((phy_type == BCM43xx_PHYTYPE_B) || (phy_type == BCM43xx_PHYTYPE_G)) {
-		p = kzalloc(sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT,
-			    GFP_KERNEL);
-		if (!p)
-			return -ENOMEM;
-		phy-&gt;_lo_pairs = p;
-	}
+	/* NRSSI */
+	phy-&gt;nrssislope = 0;
+	for (i = 0; i &lt; ARRAY_SIZE(phy-&gt;nrssi); i++)
+		phy-&gt;nrssi[i] = -1000;
+	for (i = 0; i &lt; ARRAY_SIZE(phy-&gt;nrssi_lt); i++)
+		phy-&gt;nrssi_lt[i] = i;
+
+	phy-&gt;lofcal = 0xFFFF;
+	phy-&gt;initval = 0xFFFF;
+
+	phy-&gt;aci_enable = 0;
+	phy-&gt;aci_wlan_automatic = 0;
+	phy-&gt;aci_hw_rssi = 0;
 
-	return 0;
+	phy-&gt;antenna_diversity = 0xFFFF;
+	memset(phy-&gt;minlowsig, 0xFF, sizeof(phy-&gt;minlowsig));
+	memset(phy-&gt;minlowsigpos, 0, sizeof(phy-&gt;minlowsigpos));
+
+	/* Flags */
+	phy-&gt;calibrated = 0;
+	phy-&gt;locked = 0;
+
+	if (phy-&gt;_lo_pairs)
+		memset(phy-&gt;_lo_pairs, 0,
+		       sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT);
+	memset(phy-&gt;loopback_gain, 0, sizeof(phy-&gt;loopback_gain));
 }
 
-static int bcm43xx_attach_board(struct bcm43xx_private *bcm)
+/* Initialize a wireless core */
+static int bcm43xx_wireless_core_init(struct bcm43xx_wldev *dev)
 {
-	struct pci_dev *pci_dev = bcm-&gt;pci_dev;
-	struct net_device *net_dev = bcm-&gt;net_dev;
+	struct bcm43xx_wl *wl = dev-&gt;wl;
+	struct ssb_bus *bus = dev-&gt;dev-&gt;bus;
+	struct bcm43xx_phy *phy = &amp;dev-&gt;phy;
+	struct ssb_sprom *sprom = &amp;dev-&gt;dev-&gt;bus-&gt;sprom;
 	int err;
-	int i;
-	u32 coremask;
+	u32 hf;
+	u32 tmp;
 
-	err = pci_enable_device(pci_dev);
-	if (err) {
-		printk(KERN_ERR PFX &quot;pci_enable_device() failed\n&quot;);
+	BCM43xx_WARN_ON(bcm43xx_status(dev) != BCM43xx_STAT_UNINIT);
+
+	err = ssb_bus_powerup(bus, 0);
+	if (err)
 		goto out;
+	if (!ssb_device_is_enabled(dev-&gt;dev)) {
+		tmp = phy-&gt;gmode ? BCM43xx_TMSLOW_GMODE : 0;
+		bcm43xx_wireless_core_reset(dev, tmp);
 	}
-	err = pci_request_regions(pci_dev, KBUILD_MODNAME);
-	if (err) {
-		printk(KERN_ERR PFX &quot;pci_request_regions() failed\n&quot;);
-		goto err_pci_disable;
-	}
-	/* enable PCI bus-mastering */
-	pci_set_master(pci_dev);
-	bcm-&gt;mmio_addr = pci_iomap(pci_dev, 0, ~0UL);
-	if (!bcm-&gt;mmio_addr) {
-		printk(KERN_ERR PFX &quot;pci_iomap() failed\n&quot;);
-		err = -EIO;
-		goto err_pci_release;
+
+	if ((phy-&gt;type == BCM43xx_PHYTYPE_B) ||
+	    (phy-&gt;type == BCM43xx_PHYTYPE_G)) {
+		phy-&gt;_lo_pairs = kzalloc(sizeof(struct bcm43xx_lopair)
+					 * BCM43xx_LO_COUNT,
+					 GFP_KERNEL);
+		if (!phy-&gt;_lo_pairs)
+			return -ENOMEM;
 	}
-	net_dev-&gt;base_addr = (unsigned long)bcm-&gt;mmio_addr;
+	setup_struct_wldev_for_init(dev);
 
-	err = bcm43xx_pci_read_config16(bcm, PCI_SUBSYSTEM_VENDOR_ID,
-	                          &amp;bcm-&gt;board_vendor);
+	err = bcm43xx_phy_init_tssi2dbm_table(dev);
 	if (err)
-		goto err_iounmap;
-	err = bcm43xx_pci_read_config16(bcm, PCI_SUBSYSTEM_ID,
-	                          &amp;bcm-&gt;board_type);
-	if (err)
-		goto err_iounmap;
+		goto err_kfree_lo_control;
 
-	bcm-&gt;board_revision = bcm-&gt;pci_dev-&gt;revision;
+	/* Enable IRQ routing to this device. */
+	ssb_pcicore_dev_irqvecs_enable(&amp;bus-&gt;pcicore, dev-&gt;dev);
 
-	err = bcm43xx_chipset_attach(bcm);
-	if (err)
-		goto err_iounmap;
-	err = bcm43xx_pctl_init(bcm);
+	bcm43xx_imcfglo_timeouts_workaround(dev);
+	prepare_phy_data_for_init(dev);
+	bcm43xx_phy_calibrate(dev);
+	err = bcm43xx_chip_init(dev);
 	if (err)
-		goto err_chipset_detach;
-	err = bcm43xx_probe_cores(bcm);
-	if (err)
-		goto err_chipset_detach;
-	
-	/* Attach all IO cores to the backplane. */
-	coremask = 0;
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++)
-		coremask |= (1 &lt;&lt; bcm-&gt;core_80211[i].index);
-	//FIXME: Also attach some non80211 cores?
-	err = bcm43xx_setup_backplane_pci_connection(bcm, coremask);
-	if (err) {
-		printk(KERN_ERR PFX &quot;Backplane-&gt;PCI connection failed!\n&quot;);
-		goto err_chipset_detach;
+		goto err_kfree_tssitbl;
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    BCM43xx_SHM_SH_WLCOREREV,
+			    dev-&gt;dev-&gt;id.revision);
+	hf = bcm43xx_hf_read(dev);
+	if (phy-&gt;type == BCM43xx_PHYTYPE_G) {
+		hf |= BCM43xx_HF_SYMW;
+		if (phy-&gt;rev == 1)
+			hf |= BCM43xx_HF_GDCW;
+		if (sprom-&gt;r1.boardflags_lo &amp; BCM43xx_BFL_PACTRL)
+			hf |= BCM43xx_HF_OFDMPABOOST;
+	} else if (phy-&gt;type == BCM43xx_PHYTYPE_B) {
+		hf |= BCM43xx_HF_SYMW;
+		if (phy-&gt;rev &gt;= 2 &amp;&amp; phy-&gt;radio_ver == 0x2050)
+			hf &amp;= ~BCM43xx_HF_GDCW;
 	}
+	bcm43xx_hf_write(dev, hf);
 
-	err = bcm43xx_sprom_extract(bcm);
-	if (err)
-		goto err_chipset_detach;
-	err = bcm43xx_leds_init(bcm);
-	if (err)
-		goto err_chipset_detach;
-
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++) {
-		err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_80211[i]);
-		assert(err != -ENODEV);
-		if (err)
-			goto err_80211_unwind;
+	/* Short/Long Retry Limit.
+	 * The retry-limit is a 4-bit counter. Enforce this to avoid overflowing
+	 * the chip-internal counter.
+	 */
+	tmp = limit_value(modparam_short_retry, 0, 0xF);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_WIRELESS,
+			    0x0006, tmp);
+	dev-&gt;short_retry_limit = tmp;
+	tmp = limit_value(modparam_long_retry, 0, 0xF);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_WIRELESS,
+			    0x0007, tmp);
+	dev-&gt;long_retry_limit = tmp;
+
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    0x0044, 3);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED,
+			    0x0046, 2);
 
-		/* Enable the selected wireless core.
-		 * Connect PHY only on the first core.
-		 */
-		bcm43xx_wireless_core_reset(bcm, (i == 0));
+	bcm43xx_rate_memory_init(dev);
 
-		err = bcm43xx_read_phyinfo(bcm);
-		if (err &amp;&amp; (i == 0))
-			goto err_80211_unwind;
-
-		err = bcm43xx_read_radioinfo(bcm);
-		if (err &amp;&amp; (i == 0))
-			goto err_80211_unwind;
-
-		err = bcm43xx_validate_chip(bcm);
-		if (err &amp;&amp; (i == 0))
-			goto err_80211_unwind;
+	/* Minimum Contention Window */
+	if (phy-&gt;type == BCM43xx_PHYTYPE_B)
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_WIRELESS,
+				    0x0003, 31);
+	else
+		bcm43xx_shm_write16(dev, BCM43xx_SHM_WIRELESS,
+				    0x0003, 15);
+	/* Maximum Contention Window */
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_WIRELESS,
+			    0x0004, 1023);
 
-		bcm43xx_radio_turn_off(bcm);
-		err = bcm43xx_phy_init_tssi2dbm_table(bcm);
-		if (err)
-			goto err_80211_unwind;
-		bcm43xx_wireless_core_disable(bcm);
-	}
-	err = bcm43xx_geo_init(bcm);
+	do {
+		if (bcm43xx_using_pio(dev)) {
+			err = bcm43xx_pio_init(dev);
+		} else {
+			err = bcm43xx_dma_init(dev);
+			if (!err)
+				bcm43xx_qos_init(dev);
+		}
+	} while (err == -EAGAIN);
 	if (err)
-		goto err_80211_unwind;
-	bcm43xx_pctl_set_crystal(bcm, 0);
+		goto err_chip_exit;
 
-	/* Set the MAC address in the networking subsystem */
-	if (is_valid_ether_addr(bcm-&gt;sprom.et1macaddr))
-		memcpy(bcm-&gt;net_dev-&gt;dev_addr, bcm-&gt;sprom.et1macaddr, 6);
-	else
-		memcpy(bcm-&gt;net_dev-&gt;dev_addr, bcm-&gt;sprom.il0macaddr, 6);
+	bcm43xx_write16(dev, 0x0612, 0x0050);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0416, 0x0050);
+	bcm43xx_shm_write16(dev, BCM43xx_SHM_SHARED, 0x0414, 0x01F4);
+
+	ssb_bus_powerup(bus, 1); /* Enable dynamic PCTL */
+	wl-&gt;bssid = NULL;
+	bcm43xx_upload_card_macaddress(dev, NULL);
+	bcm43xx_security_init(dev);
+	bcm43xx_rng_init(wl);
 
-	snprintf(bcm-&gt;nick, IW_ESSID_MAX_SIZE,
-		 &quot;Broadcom %04X&quot;, bcm-&gt;chip_id);
+	bcm43xx_set_status(dev, BCM43xx_STAT_INITIALIZED);
 
-	assert(err == 0);
 out:
 	return err;
 
-err_80211_unwind:
-	for (i = 0; i &lt; BCM43xx_MAX_80211_CORES; i++) {
-		kfree(bcm-&gt;core_80211_ext[i].phy._lo_pairs);
-		if (bcm-&gt;core_80211_ext[i].phy.dyn_tssi_tbl)
-			kfree(bcm-&gt;core_80211_ext[i].phy.tssi2dbm);
-	}
-err_chipset_detach:
-	bcm43xx_chipset_detach(bcm);
-err_iounmap:
-	pci_iounmap(pci_dev, bcm-&gt;mmio_addr);
-err_pci_release:
-	pci_release_regions(pci_dev);
-err_pci_disable:
-	pci_disable_device(pci_dev);
-	printk(KERN_ERR PFX &quot;Unable to attach board\n&quot;);
-	goto out;
+err_chip_exit:
+	bcm43xx_chip_exit(dev);
+err_kfree_tssitbl:
+	if (phy-&gt;dyn_tssi_tbl)
+		kfree(phy-&gt;tssi2dbm);
+err_kfree_lo_control:
+	kfree(phy-&gt;lo_control);
+	phy-&gt;lo_control = NULL;
+	ssb_bus_may_powerdown(bus);
+	BCM43xx_WARN_ON(bcm43xx_status(dev) != BCM43xx_STAT_UNINIT);
+	return err;
 }
 
-/* Do the Hardware IO operations to send the txb */
-static inline int bcm43xx_tx(struct bcm43xx_private *bcm,
-			     struct ieee80211_txb *txb)
+static int bcm43xx_add_interface(struct ieee80211_hw *hw,
+				 struct ieee80211_if_init_conf *conf)
 {
-	int err = -ENODEV;
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev;
+	unsigned long flags;
+	int err = -EOPNOTSUPP;
+	int did_init = 0;
 
-	if (bcm43xx_using_pio(bcm))
-		err = bcm43xx_pio_tx(bcm, txb);
-	else
-		err = bcm43xx_dma_tx(bcm, txb);
-	bcm-&gt;net_dev-&gt;trans_start = jiffies;
+	mutex_lock(&amp;wl-&gt;mutex);
+	if ((conf-&gt;type != IEEE80211_IF_TYPE_MNTR) &amp;&amp;
+	    wl-&gt;operating)
+		goto out_mutex_unlock;
+
+	bcmdbg(wl, &quot;Adding Interface type %d\n&quot;, conf-&gt;type);
+
+	dev = wl-&gt;current_dev;
+	if (bcm43xx_status(dev) &lt; BCM43xx_STAT_INITIALIZED) {
+		err = bcm43xx_wireless_core_init(dev);
+		if (err)
+			goto out_mutex_unlock;
+		did_init = 1;
+	}
+	if (bcm43xx_status(dev) &lt; BCM43xx_STAT_STARTED) {
+		err = bcm43xx_wireless_core_start(dev);
+		if (err) {
+			if (did_init)
+				bcm43xx_wireless_core_exit(dev);
+			goto out_mutex_unlock;
+		}
+	}
+
+	spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+	switch (conf-&gt;type) {
+	case IEEE80211_IF_TYPE_MNTR:
+		wl-&gt;monitor++;
+		break;
+	default:
+		wl-&gt;operating = 1;
+		wl-&gt;if_id = conf-&gt;if_id;
+		wl-&gt;if_type = conf-&gt;type;
+		bcm43xx_upload_card_macaddress(dev, conf-&gt;mac_addr);
+	}
+	bcm43xx_adjust_opmode(dev);
+	spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
+
+	err = 0;
+out_mutex_unlock:
+	mutex_unlock(&amp;wl-&gt;mutex);
 
 	return err;
 }
 
-static void bcm43xx_ieee80211_set_chan(struct net_device *net_dev,
-				       u8 channel)
+static void bcm43xx_remove_interface(struct ieee80211_hw *hw,
+				     struct ieee80211_if_init_conf *conf)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct bcm43xx_radioinfo *radio;
+	struct bcm43xx_wl *wl = hw_to_bcm43xx_wl(hw);
+	struct bcm43xx_wldev *dev;
 	unsigned long flags;
 
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm43xx_mac_suspend(bcm);
-		bcm43xx_radio_selectchannel(bcm, channel, 0);
-		bcm43xx_mac_enable(bcm);
+	bcmdbg(wl, &quot;Removing Interface type %d\n&quot;, conf-&gt;type);
+
+	mutex_lock(&amp;wl-&gt;mutex);
+	if (conf-&gt;type == IEEE80211_IF_TYPE_MNTR) {
+		wl-&gt;monitor--;
+		BCM43xx_WARN_ON(wl-&gt;monitor &lt; 0);
 	} else {
-		radio = bcm43xx_current_radio(bcm);
-		radio-&gt;initial_channel = channel;
+		BCM43xx_WARN_ON(!wl-&gt;operating);
+		wl-&gt;operating = 0;
 	}
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
+
+	dev = wl-&gt;current_dev;
+	if (!wl-&gt;operating &amp;&amp; wl-&gt;monitor == 0) {
+		/* No interface left. */
+		if (bcm43xx_status(dev) &gt;= BCM43xx_STAT_STARTED)
+			bcm43xx_wireless_core_stop(dev);
+		bcm43xx_wireless_core_exit(dev);
+	} else {
+		/* Just monitor interfaces left. */
+		spin_lock_irqsave(&amp;wl-&gt;irq_lock, flags);
+		bcm43xx_adjust_opmode(dev);
+		if (!wl-&gt;operating)
+			bcm43xx_upload_card_macaddress(dev, NULL);
+		spin_unlock_irqrestore(&amp;wl-&gt;irq_lock, flags);
+	}
+	mutex_unlock(&amp;wl-&gt;mutex);
 }
 
-/* set_security() callback in struct ieee80211_device */
-static void bcm43xx_ieee80211_set_security(struct net_device *net_dev,
-					   struct ieee80211_security *sec)
+
+static const struct ieee80211_ops bcm43xx_hw_ops = {
+	.tx = bcm43xx_tx,
+	.conf_tx = bcm43xx_conf_tx,
+	.add_interface = bcm43xx_add_interface,
+	.remove_interface = bcm43xx_remove_interface,
+	.reset = bcm43xx_dev_reset,
+	.config = bcm43xx_dev_config,
+	.config_interface = bcm43xx_config_interface,
+	.set_multicast_list = bcm43xx_set_multicast_list,
+	.set_key = bcm43xx_dev_set_key,
+	.get_stats = bcm43xx_get_stats,
+	.get_tx_stats = bcm43xx_get_tx_stats,
+};
+
+/* Hard-reset the chip. Do not call this directly.
+ * Use bcm43xx_controller_restart()
+ */
+static void bcm43xx_chip_reset(struct work_struct *work)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct ieee80211_security *secinfo = &amp;bcm-&gt;ieee-&gt;sec;
-	unsigned long flags;
-	int keyidx;
-	
-	dprintk(KERN_INFO PFX &quot;set security called&quot;);
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-
-	for (keyidx = 0; keyidx&lt;WEP_KEYS; keyidx++)
-		if (sec-&gt;flags &amp; (1&lt;&lt;keyidx)) {
-			secinfo-&gt;encode_alg[keyidx] = sec-&gt;encode_alg[keyidx];
-			secinfo-&gt;key_sizes[keyidx] = sec-&gt;key_sizes[keyidx];
-			memcpy(secinfo-&gt;keys[keyidx], sec-&gt;keys[keyidx], SCM_KEY_LEN);
+	struct bcm43xx_wldev *dev =
+		container_of(work, struct bcm43xx_wldev, restart_work);
+	struct bcm43xx_wl *wl = dev-&gt;wl;
+	int err = 0;
+	int prev_status;
+
+	mutex_lock(&amp;wl-&gt;mutex);
+
+	prev_status = bcm43xx_status(dev);
+	/* Bring the device down... */
+	if (prev_status &gt;= BCM43xx_STAT_STARTED)
+		bcm43xx_wireless_core_stop(dev);
+	if (prev_status &gt;= BCM43xx_STAT_INITIALIZED)
+		bcm43xx_wireless_core_exit(dev);
+
+	/* ...and up again. */
+	if (prev_status &gt;= BCM43xx_STAT_INITIALIZED) {
+		err = bcm43xx_wireless_core_init(dev);
+		if (err)
+			goto out;
+	}
+	if (prev_status &gt;= BCM43xx_STAT_STARTED) {
+		err = bcm43xx_wireless_core_start(dev);
+		if (err) {
+			bcm43xx_wireless_core_exit(dev);
+			goto out;
 		}
-	
-	if (sec-&gt;flags &amp; SEC_ACTIVE_KEY) {
-		secinfo-&gt;active_key = sec-&gt;active_key;
-		dprintk(&quot;, .active_key = %d&quot;, sec-&gt;active_key);
-	}
-	if (sec-&gt;flags &amp; SEC_UNICAST_GROUP) {
-		secinfo-&gt;unicast_uses_group = sec-&gt;unicast_uses_group;
-		dprintk(&quot;, .unicast_uses_group = %d&quot;, sec-&gt;unicast_uses_group);
-	}
-	if (sec-&gt;flags &amp; SEC_LEVEL) {
-		secinfo-&gt;level = sec-&gt;level;
-		dprintk(&quot;, .level = %d&quot;, sec-&gt;level);
-	}
-	if (sec-&gt;flags &amp; SEC_ENABLED) {
-		secinfo-&gt;enabled = sec-&gt;enabled;
-		dprintk(&quot;, .enabled = %d&quot;, sec-&gt;enabled);
-	}
-	if (sec-&gt;flags &amp; SEC_ENCRYPT) {
-		secinfo-&gt;encrypt = sec-&gt;encrypt;
-		dprintk(&quot;, .encrypt = %d&quot;, sec-&gt;encrypt);
-	}
-	if (sec-&gt;flags &amp; SEC_AUTH_MODE) {
-		secinfo-&gt;auth_mode = sec-&gt;auth_mode;
-		dprintk(&quot;, .auth_mode = %d&quot;, sec-&gt;auth_mode);
-	}
-	dprintk(&quot;\n&quot;);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED &amp;&amp;
-	    !bcm-&gt;ieee-&gt;host_encrypt) {
-		if (secinfo-&gt;enabled) {
-			/* upload WEP keys to hardware */
-			char null_address[6] = { 0 };
-			u8 algorithm = 0;
-			for (keyidx = 0; keyidx&lt;WEP_KEYS; keyidx++) {
-				if (!(sec-&gt;flags &amp; (1&lt;&lt;keyidx)))
-					continue;
-				switch (sec-&gt;encode_alg[keyidx]) {
-					case SEC_ALG_NONE: algorithm = BCM43xx_SEC_ALGO_NONE; break;
-					case SEC_ALG_WEP:
-						algorithm = BCM43xx_SEC_ALGO_WEP;
-						if (secinfo-&gt;key_sizes[keyidx] == 13)
-							algorithm = BCM43xx_SEC_ALGO_WEP104;
-						break;
-					case SEC_ALG_TKIP:
-						FIXME();
-						algorithm = BCM43xx_SEC_ALGO_TKIP;
-						break;
-					case SEC_ALG_CCMP:
-						FIXME();
-						algorithm = BCM43xx_SEC_ALGO_AES;
-						break;
-					default:
-						assert(0);
-						break;
-				}
-				bcm43xx_key_write(bcm, keyidx, algorithm, sec-&gt;keys[keyidx], secinfo-&gt;key_sizes[keyidx], &amp;null_address[0]);
-				bcm-&gt;key[keyidx].enabled = 1;
-				bcm-&gt;key[keyidx].algorithm = algorithm;
-			}
-		} else
-				bcm43xx_clear_keys(bcm);
 	}
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
+out:
+	mutex_unlock(&amp;wl-&gt;mutex);
+	if (err)
+		bcmerr(wl, &quot;Controller restart FAILED\n&quot;);
+	else
+		bcminfo(wl, &quot;Controller restarted\n&quot;);
 }
 
-/* hard_start_xmit() callback in struct ieee80211_device */
-static int bcm43xx_ieee80211_hard_start_xmit(struct ieee80211_txb *txb,
-					     struct net_device *net_dev,
-					     int pri)
+static int bcm43xx_setup_modes(struct bcm43xx_wldev *dev,
+			       int have_bphy,
+			       int have_gphy)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err = -ENODEV;
-	unsigned long flags;
+	struct ieee80211_hw *hw = dev-&gt;wl-&gt;hw;
+	struct ieee80211_hw_mode *mode;
+	struct bcm43xx_phy *phy = &amp;dev-&gt;phy;
+	int cnt = 0;
+	int err;
 
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (likely(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED))
-		err = bcm43xx_tx(bcm, txb);
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
+	phy-&gt;possible_phymodes = 0;
+	for ( ; 1; cnt++) {
+		if (have_bphy) {
+			BCM43xx_WARN_ON(cnt &gt;= BCM43xx_MAX_PHYHWMODES);
+			mode = &amp;phy-&gt;hwmodes[cnt];
+
+			mode-&gt;mode = MODE_IEEE80211B;
+			mode-&gt;num_channels = bcm43xx_bg_chantable_size;
+			mode-&gt;channels = bcm43xx_bg_chantable;
+			mode-&gt;num_rates = bcm43xx_b_ratetable_size;
+			mode-&gt;rates = bcm43xx_b_ratetable;
+			err = ieee80211_register_hwmode(hw, mode);
+			if (err)
+				return err;
 
-	if (unlikely(err))
-		return NETDEV_TX_BUSY;
-	return NETDEV_TX_OK;
-}
+			phy-&gt;possible_phymodes |= BCM43xx_PHYMODE_B;
+			have_bphy = 0;
+			continue;
+		}
+		if (have_gphy) {
+			BCM43xx_WARN_ON(cnt &gt;= BCM43xx_MAX_PHYHWMODES);
+			mode = &amp;phy-&gt;hwmodes[cnt];
+
+			mode-&gt;mode = MODE_IEEE80211G;
+			mode-&gt;num_channels = bcm43xx_bg_chantable_size;
+			mode-&gt;channels = bcm43xx_bg_chantable;
+			mode-&gt;num_rates = bcm43xx_g_ratetable_size;
+			mode-&gt;rates = bcm43xx_g_ratetable;
+			err = ieee80211_register_hwmode(hw, mode);
+			if (err)
+				return err;
 
-static void bcm43xx_net_tx_timeout(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
+			phy-&gt;possible_phymodes |= BCM43xx_PHYMODE_G;
+			have_gphy = 0;
+			continue;
+		}
+		break;
+	}
 
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	bcm43xx_controller_restart(bcm, &quot;TX timeout&quot;);
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
+	return 0;
 }
 
-#ifdef CONFIG_NET_POLL_CONTROLLER
-static void bcm43xx_net_poll_controller(struct net_device *net_dev)
+static void bcm43xx_wireless_core_detach(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-
-	local_irq_save(flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED)
-		bcm43xx_interrupt_handler(bcm-&gt;irq, bcm);
-	local_irq_restore(flags);
+	/* We release firmware that late to not be required to re-request
+	 * is all the time when we reinit the core. */
+	bcm43xx_release_firmware(dev);
 }
-#endif /* CONFIG_NET_POLL_CONTROLLER */
 
-static int bcm43xx_net_open(struct net_device *net_dev)
+static int bcm43xx_wireless_core_attach(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
+	struct bcm43xx_wl *wl = dev-&gt;wl;
+	struct ssb_bus *bus = dev-&gt;dev-&gt;bus;
+	struct pci_dev *pdev = bus-&gt;host_pci;
+	int err;
+	int have_bphy = 0;
+	int have_gphy = 0;
+	u32 tmp;
+
+	/* Do NOT do any device initialization here.
+	 * Do it in wireless_core_init() instead.
+	 * This function is for gathering basic information about the HW, only.
+	 * Also some structs may be set up here. But most likely you want to
+	 * have that in core_init(), too.
+	 */
+
+	/* Get the PHY type. */
+	if (dev-&gt;dev-&gt;id.revision &gt;= 5) {
+		u32 tmshigh;
+
+		tmshigh = ssb_read32(dev-&gt;dev, SSB_TMSHIGH);
+		have_gphy = !!(tmshigh &amp; BCM43xx_TMSHIGH_GPHY);
+		if (!have_gphy)
+			have_bphy = 1;
+	} else if (dev-&gt;dev-&gt;id.revision == 4) {
+		have_gphy = 1;
+	} else {
+		have_bphy = 1;
+	}
+
+	/* Initialize LEDs structs. */
+	err = bcm43xx_leds_init(dev);
+	if (err)
+		goto out;
+
+	dev-&gt;phy.gmode = (have_gphy || have_bphy);
+	tmp = dev-&gt;phy.gmode ? BCM43xx_TMSLOW_GMODE : 0;
+	bcm43xx_wireless_core_reset(dev, tmp);
+
+	err = bcm43xx_phy_versioning(dev);
+	if (err)
+		goto err_leds_exit;
+	/* Check if this device supports multiband. */
+	if (!pdev ||
+	    (pdev-&gt;device != 0x4312 &amp;&amp;
+	     pdev-&gt;device != 0x4319 &amp;&amp;
+	     pdev-&gt;device != 0x4324)) {
+		/* No multiband support. */
+		have_bphy = 0;
+		have_gphy = 0;
+		switch (dev-&gt;phy.type) {
+		case BCM43xx_PHYTYPE_B:
+			have_bphy = 1;
+			break;
+		case BCM43xx_PHYTYPE_G:
+			have_gphy = 1;
+			break;
+		default:
+			BCM43xx_BUG_ON(1);
+		}
+	}
+	dev-&gt;phy.gmode = (have_gphy || have_bphy);
+	tmp = dev-&gt;phy.gmode ? BCM43xx_TMSLOW_GMODE : 0;
+	bcm43xx_wireless_core_reset(dev, tmp);
+
+	err = bcm43xx_validate_chipaccess(dev);
+	if (err)
+		goto err_leds_exit;
+	err = bcm43xx_setup_modes(dev, have_bphy, have_gphy);
+	if (err)
+		goto err_leds_exit;
+
+	/* Now set some default &quot;current_dev&quot; */
+	if (!wl-&gt;current_dev)
+		wl-&gt;current_dev = dev;
+	INIT_WORK(&amp;dev-&gt;restart_work, bcm43xx_chip_reset);
+
+	bcm43xx_radio_turn_off(dev);
+	bcm43xx_switch_analog(dev, 0);
+	ssb_device_disable(dev-&gt;dev, 0);
+	ssb_bus_may_powerdown(bus);
 
-	return bcm43xx_init_board(bcm);
+out:
+	return err;
+
+err_leds_exit:
+	bcm43xx_leds_exit(dev);
+	return err;
 }
 
-static int bcm43xx_net_stop(struct net_device *net_dev)
+static void bcm43xx_one_core_detach(struct ssb_device *dev)
 {
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
+	struct bcm43xx_wldev *wldev;
+	struct bcm43xx_wl *wl;
 
-	ieee80211softmac_stop(net_dev);
-	err = bcm43xx_disable_interrupts_sync(bcm);
-	assert(!err);
-	bcm43xx_free_board(bcm);
-	flush_scheduled_work();
+	wldev = ssb_get_drvdata(dev);
+	wl = wldev-&gt;wl;
+	bcm43xx_debugfs_remove_device(wldev);
+	bcm43xx_wireless_core_detach(wldev);
+	list_del(&amp;wldev-&gt;list);
+	wl-&gt;nr_devs--;
+	ssb_set_drvdata(dev, NULL);
+	kfree(wldev);
+}
+
+static int bcm43xx_one_core_attach(struct ssb_device *dev,
+				   struct bcm43xx_wl *wl)
+{
+	struct bcm43xx_wldev *wldev;
+	struct pci_dev *pdev;
+	int err = -ENOMEM;
+
+	if (!list_empty(&amp;wl-&gt;devlist)) {
+		/* We are not the first core on this chip. */
+		pdev = dev-&gt;bus-&gt;host_pci;
+		/* Only special chips support more than one wireless
+		 * core, although some of the other chips have more than
+		 * one wireless core as well. Check for this and
+		 * bail out early.
+		 */
+		if (!pdev ||
+		    ((pdev-&gt;device != 0x4321) &amp;&amp;
+		     (pdev-&gt;device != 0x4313) &amp;&amp;
+		     (pdev-&gt;device != 0x431A))) {
+			bcmdbg(wl, &quot;Ignoring unconnected 802.11 core\n&quot;);
+			return -ENODEV;
+		}
+	}
 
-	return 0;
-}
+	wldev = kzalloc(sizeof(*wldev), GFP_KERNEL);
+	if (!wldev)
+		goto out;
 
-static int bcm43xx_init_private(struct bcm43xx_private *bcm,
-				struct net_device *net_dev,
-				struct pci_dev *pci_dev)
-{
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-	bcm-&gt;ieee = netdev_priv(net_dev);
-	bcm-&gt;softmac = ieee80211_priv(net_dev);
-	bcm-&gt;softmac-&gt;set_channel = bcm43xx_ieee80211_set_chan;
-
-	bcm-&gt;irq_savedstate = BCM43xx_IRQ_INITIAL;
-	bcm-&gt;mac_suspended = 1;
-	bcm-&gt;pci_dev = pci_dev;
-	bcm-&gt;net_dev = net_dev;
-	bcm-&gt;bad_frames_preempt = modparam_bad_frames_preempt;
-	spin_lock_init(&amp;bcm-&gt;irq_lock);
-	spin_lock_init(&amp;bcm-&gt;leds_lock);
-	mutex_init(&amp;bcm-&gt;mutex);
-	tasklet_init(&amp;bcm-&gt;isr_tasklet,
+	wldev-&gt;dev = dev;
+	wldev-&gt;wl = wl;
+	bcm43xx_set_status(wldev, BCM43xx_STAT_UNINIT);
+	wldev-&gt;bad_frames_preempt = modparam_bad_frames_preempt;
+	tasklet_init(&amp;wldev-&gt;isr_tasklet,
 		     (void (*)(unsigned long))bcm43xx_interrupt_tasklet,
-		     (unsigned long)bcm);
-	tasklet_disable_nosync(&amp;bcm-&gt;isr_tasklet);
+		     (unsigned long)wldev);
 	if (modparam_pio)
-		bcm-&gt;__using_pio = 1;
-	bcm-&gt;rts_threshold = BCM43xx_DEFAULT_RTS_THRESHOLD;
+		wldev-&gt;__using_pio = 1;
+	INIT_LIST_HEAD(&amp;wldev-&gt;list);
 
-	/* default to sw encryption for now */
-	bcm-&gt;ieee-&gt;host_build_iv = 0;
-	bcm-&gt;ieee-&gt;host_encrypt = 1;
-	bcm-&gt;ieee-&gt;host_decrypt = 1;
-	
-	bcm-&gt;ieee-&gt;iw_mode = BCM43xx_INITIAL_IWMODE;
-	bcm-&gt;ieee-&gt;tx_headroom = sizeof(struct bcm43xx_txhdr);
-	bcm-&gt;ieee-&gt;set_security = bcm43xx_ieee80211_set_security;
-	bcm-&gt;ieee-&gt;hard_start_xmit = bcm43xx_ieee80211_hard_start_xmit;
+	err = bcm43xx_wireless_core_attach(wldev);
+	if (err)
+		goto err_kfree_wldev;
 
-	return 0;
+	list_add(&amp;wldev-&gt;list, &amp;wl-&gt;devlist);
+	wl-&gt;nr_devs++;
+	ssb_set_drvdata(dev, wldev);
+	bcm43xx_debugfs_add_device(wldev);
+out:
+	return err;
+
+err_kfree_wldev:
+	kfree(wldev);
+	return err;
 }
 
-static int __devinit bcm43xx_init_one(struct pci_dev *pdev,
-				      const struct pci_device_id *ent)
+static void bcm43xx_sprom_fixup(struct ssb_bus *bus)
 {
-	struct net_device *net_dev;
-	struct bcm43xx_private *bcm;
-	int err;
+	/* boardflags workarounds */
+	if (bus-&gt;boardinfo.vendor == PCI_VENDOR_ID_APPLE &amp;&amp;
+	    bus-&gt;boardinfo.type == 0x4E &amp;&amp;
+	    bus-&gt;boardinfo.rev &gt; 0x40)
+		bus-&gt;sprom.r1.boardflags_lo |= BCM43xx_BFL_PACTRL;
 
-#ifdef DEBUG_SINGLE_DEVICE_ONLY
-	if (strcmp(pci_name(pdev), DEBUG_SINGLE_DEVICE_ONLY))
-		return -ENODEV;
-#endif
+	/* Convert Antennagain values to Q5.2 */
+	bus-&gt;sprom.r1.antenna_gain_bg &lt;&lt;= 2;
+}
 
-	net_dev = alloc_ieee80211softmac(sizeof(*bcm));
-	if (!net_dev) {
-		printk(KERN_ERR PFX
-		       &quot;could not allocate ieee80211 device %s\n&quot;,
-		       pci_name(pdev));
-		err = -ENOMEM;
-		goto out;
-	}
-	/* initialize the net_device struct */
-	SET_MODULE_OWNER(net_dev);
-	SET_NETDEV_DEV(net_dev, &amp;pdev-&gt;dev);
-
-	net_dev-&gt;open = bcm43xx_net_open;
-	net_dev-&gt;stop = bcm43xx_net_stop;
-	net_dev-&gt;tx_timeout = bcm43xx_net_tx_timeout;
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	net_dev-&gt;poll_controller = bcm43xx_net_poll_controller;
-#endif
-	net_dev-&gt;wireless_handlers = &amp;bcm43xx_wx_handlers_def;
-	net_dev-&gt;irq = pdev-&gt;irq;
-	SET_ETHTOOL_OPS(net_dev, &amp;bcm43xx_ethtool_ops);
-
-	/* initialize the bcm43xx_private struct */
-	bcm = bcm43xx_priv(net_dev);
-	memset(bcm, 0, sizeof(*bcm));
-	err = bcm43xx_init_private(bcm, net_dev, pdev);
-	if (err)
-		goto err_free_netdev;
+static void bcm43xx_wireless_exit(struct ssb_device *dev,
+				  struct bcm43xx_wl *wl)
+{
+	struct ieee80211_hw *hw = wl-&gt;hw;
 
-	pci_set_drvdata(pdev, net_dev);
+	ssb_set_devtypedata(dev, NULL);
+	ieee80211_free_hw(hw);
+}
 
-	err = bcm43xx_attach_board(bcm);
-	if (err)
-		goto err_free_netdev;
+static int bcm43xx_wireless_init(struct ssb_device *dev)
+{
+	struct ssb_sprom *sprom = &amp;dev-&gt;bus-&gt;sprom;
+	struct ieee80211_hw *hw;
+	struct bcm43xx_wl *wl;
+	int err = -ENOMEM;
 
-	err = register_netdev(net_dev);
-	if (err) {
-		printk(KERN_ERR PFX &quot;Cannot register net device, &quot;
-		       &quot;aborting.\n&quot;);
-		err = -ENOMEM;
-		goto err_detach_board;
+	bcm43xx_sprom_fixup(dev-&gt;bus);
+
+	hw = ieee80211_alloc_hw(sizeof(*wl), &amp;bcm43xx_hw_ops);
+	if (!hw) {
+		bcmerr(NULL, &quot;Could not allocate ieee80211 device\n&quot;);
+		goto out;
 	}
 
-	bcm43xx_debugfs_add_device(bcm);
+	/* fill hw info */
+	hw-&gt;flags = IEEE80211_HW_HOST_GEN_BEACON_TEMPLATE |
+		    IEEE80211_HW_MONITOR_DURING_OPER |
+		    IEEE80211_HW_DEVICE_HIDES_WEP |
+		    IEEE80211_HW_WEP_INCLUDE_IV;
+	hw-&gt;max_signal = 100;
+	hw-&gt;max_rssi = -110;
+	hw-&gt;max_noise = -110;
+	hw-&gt;queues = 1; /* FIXME: hardware has more queues */
+	SET_IEEE80211_DEV(hw, dev-&gt;dev);
+	if (is_valid_ether_addr(sprom-&gt;r1.et1mac))
+		SET_IEEE80211_PERM_ADDR(hw, sprom-&gt;r1.et1mac);
+	else
+		SET_IEEE80211_PERM_ADDR(hw, sprom-&gt;r1.il0mac);
 
-	assert(err == 0);
+	/* Get and initialize struct bcm43xx_wl */
+	wl = hw_to_bcm43xx_wl(hw);
+	memset(wl, 0, sizeof(*wl));
+	wl-&gt;hw = hw;
+	spin_lock_init(&amp;wl-&gt;irq_lock);
+	spin_lock_init(&amp;wl-&gt;leds_lock);
+	mutex_init(&amp;wl-&gt;mutex);
+	INIT_LIST_HEAD(&amp;wl-&gt;devlist);
+
+	ssb_set_devtypedata(dev, wl);
+	bcminfo(wl, &quot;Broadcom %04X WLAN found\n&quot;, dev-&gt;bus-&gt;chip_id);
+	err = 0;
 out:
 	return err;
-
-err_detach_board:
-	bcm43xx_detach_board(bcm);
-err_free_netdev:
-	free_ieee80211softmac(net_dev);
-	goto out;
 }
 
-static void __devexit bcm43xx_remove_one(struct pci_dev *pdev)
+static int bcm43xx_probe(struct ssb_device *dev,
+			 const struct ssb_device_id *id)
 {
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
+	struct bcm43xx_wl *wl;
+	int err;
+	int first = 0;
+
+	wl = ssb_get_devtypedata(dev);
+	if (!wl) {
+		/* Probing the first core - setup common struct bcm43xx_wl */
+		first = 1;
+		err = bcm43xx_wireless_init(dev);
+		if (err)
+			goto out;
+		wl = ssb_get_devtypedata(dev);
+		BCM43xx_WARN_ON(!wl);
+	}
+	err = bcm43xx_one_core_attach(dev, wl);
+	if (err)
+		goto err_wireless_exit;
+
+	if (first) {
+		err = ieee80211_register_hw(wl-&gt;hw);
+		if (err)
+			goto err_one_core_detach;
+	}
+
+out:
+	return err;
 
-	bcm43xx_debugfs_remove_device(bcm);
-	unregister_netdev(net_dev);
-	bcm43xx_detach_board(bcm);
-	free_ieee80211softmac(net_dev);
+err_one_core_detach:
+	bcm43xx_one_core_detach(dev);
+err_wireless_exit:
+	if (first)
+		bcm43xx_wireless_exit(dev, wl);
+	return err;
 }
 
-/* Hard-reset the chip. Do not call this directly.
- * Use bcm43xx_controller_restart()
- */
-static void bcm43xx_chip_reset(struct work_struct *work)
+static void bcm43xx_remove(struct ssb_device *dev)
 {
-	struct bcm43xx_private *bcm =
-		container_of(work, struct bcm43xx_private, restart_work);
-	struct bcm43xx_phyinfo *phy;
-	int err = -ENODEV;
+	struct bcm43xx_wl *wl = ssb_get_devtypedata(dev);
+	struct bcm43xx_wldev *wldev = ssb_get_drvdata(dev);
 
-	mutex_lock(&amp;(bcm)-&gt;mutex);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm43xx_periodic_tasks_delete(bcm);
-		phy = bcm43xx_current_phy(bcm);
-		err = bcm43xx_select_wireless_core(bcm, phy-&gt;type);
-		if (!err)
-			bcm43xx_periodic_tasks_setup(bcm);
-	}
-	mutex_unlock(&amp;(bcm)-&gt;mutex);
+	BCM43xx_WARN_ON(!wl);
+	if (wl-&gt;current_dev == wldev)
+		ieee80211_unregister_hw(wl-&gt;hw);
 
-	printk(KERN_ERR PFX &quot;Controller restart%s\n&quot;,
-	       (err == 0) ? &quot;ed&quot; : &quot; failed&quot;);
+	bcm43xx_one_core_detach(dev);
+
+	if (list_empty(&amp;wl-&gt;devlist))
+		/* Last core on the chip unregistered.
+		 * We can destroy common struct bcm43xx_wl.
+		 */
+		bcm43xx_wireless_exit(dev, wl);
 }
 
 /* Hard-reset the chip.
  * This can be called from interrupt or process context.
- * bcm-&gt;irq_lock must be locked.
+ * dev-&gt;irq_lock must be locked.
  */
-void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason)
+void bcm43xx_controller_restart(struct bcm43xx_wldev *dev, const char *reason)
 {
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)
+	if (bcm43xx_status(dev) != BCM43xx_STAT_INITIALIZED)
 		return;
-	printk(KERN_ERR PFX &quot;Controller RESET (%s) ...\n&quot;, reason);
-	INIT_WORK(&amp;bcm-&gt;restart_work, bcm43xx_chip_reset);
-	schedule_work(&amp;bcm-&gt;restart_work);
+	bcminfo(dev-&gt;wl, &quot;Controller RESET (%s) ...\n&quot;, reason);
+	queue_work(dev-&gt;wl-&gt;hw-&gt;workqueue, &amp;dev-&gt;restart_work);
 }
 
 #ifdef CONFIG_PM
 
-static int bcm43xx_suspend(struct pci_dev *pdev, pm_message_t state)
+static int bcm43xx_suspend(struct ssb_device *dev, pm_message_t state)
 {
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
-
-	dprintk(KERN_INFO PFX &quot;Suspending...\n&quot;);
+	struct bcm43xx_wldev *wldev = ssb_get_drvdata(dev);
+	struct bcm43xx_wl *wl = wldev-&gt;wl;
 
-	netif_device_detach(net_dev);
-	bcm-&gt;was_initialized = 0;
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm-&gt;was_initialized = 1;
-		ieee80211softmac_stop(net_dev);
-		err = bcm43xx_disable_interrupts_sync(bcm);
-		if (unlikely(err)) {
-			dprintk(KERN_ERR PFX &quot;Suspend failed.\n&quot;);
-			return -EAGAIN;
-		}
-		bcm-&gt;firmware_norelease = 1;
-		bcm43xx_free_board(bcm);
-		bcm-&gt;firmware_norelease = 0;
-	}
-	bcm43xx_chipset_detach(bcm);
+	bcmdbg(wl, &quot;Suspending...\n&quot;);
 
-	pci_save_state(pdev);
-	pci_disable_device(pdev);
-	pci_set_power_state(pdev, pci_choose_state(pdev, state));
+	mutex_lock(&amp;wl-&gt;mutex);
+	wldev-&gt;suspend_init_status = bcm43xx_status(wldev);
+	if (wldev-&gt;suspend_init_status &gt;= BCM43xx_STAT_STARTED)
+		bcm43xx_wireless_core_stop(wldev);
+	if (wldev-&gt;suspend_init_status &gt;= BCM43xx_STAT_INITIALIZED)
+		bcm43xx_wireless_core_exit(wldev);
+	mutex_unlock(&amp;wl-&gt;mutex);
 
-	dprintk(KERN_INFO PFX &quot;Device suspended.\n&quot;);
+	bcmdbg(wl, &quot;Device suspended.\n&quot;);
 
 	return 0;
 }
 
-static int bcm43xx_resume(struct pci_dev *pdev)
+static int bcm43xx_resume(struct ssb_device *dev)
 {
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
+	struct bcm43xx_wldev *wldev = ssb_get_drvdata(dev);
+	struct bcm43xx_wl *wl = wldev-&gt;wl;
 	int err = 0;
 
-	dprintk(KERN_INFO PFX &quot;Resuming...\n&quot;);
+	bcmdbg(wl, &quot;Resuming...\n&quot;);
 
-	pci_set_power_state(pdev, 0);
-	err = pci_enable_device(pdev);
-	if (err) {
-		printk(KERN_ERR PFX &quot;Failure with pci_enable_device!\n&quot;);
-		return err;
+	mutex_lock(&amp;wl-&gt;mutex);
+	if (wldev-&gt;suspend_init_status &gt;= BCM43xx_STAT_INITIALIZED) {
+		err = bcm43xx_wireless_core_init(wldev);
+		if (err) {
+			bcmerr(wl, &quot;Resume failed at core init\n&quot;);
+			goto out;
+		}
 	}
-	pci_restore_state(pdev);
-
-	bcm43xx_chipset_attach(bcm);
-	if (bcm-&gt;was_initialized)
-		err = bcm43xx_init_board(bcm);
-	if (err) {
-		printk(KERN_ERR PFX &quot;Resume failed!\n&quot;);
-		return err;
+	if (wldev-&gt;suspend_init_status &gt;= BCM43xx_STAT_STARTED) {
+		err = bcm43xx_wireless_core_start(wldev);
+		if (err) {
+			bcm43xx_wireless_core_exit(wldev);
+			bcmerr(wl, &quot;Resume failed at core start\n&quot;);
+			goto out;
+		}
 	}
-	netif_device_attach(net_dev);
-
-	dprintk(KERN_INFO PFX &quot;Device resumed.\n&quot;);
+	mutex_unlock(&amp;wl-&gt;mutex);
 
-	return 0;
+	bcmdbg(wl, &quot;Device resumed.\n&quot;);
+out:
+	return err;
 }
 
-#endif				/* CONFIG_PM */
+#else	/* CONFIG_PM */
+# define bcm43xx_suspend	NULL
+# define bcm43xx_resume		NULL
+#endif	/* CONFIG_PM */
+
+static struct ssb_driver bcm43xx_ssb_driver = {
+	.name		= KBUILD_MODNAME,
+	.id_table	= bcm43xx_ssb_tbl,
+	.probe		= bcm43xx_probe,
+	.remove		= bcm43xx_remove,
+	.suspend	= bcm43xx_suspend,
+	.resume		= bcm43xx_resume,
+};
+
+/* The PCI frontend stub */
+static const struct pci_device_id bcm43xx_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4307) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4311) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4312) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4318) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4319) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4320) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4321) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4324) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4325) },
+	{ 0 },
+};
+MODULE_DEVICE_TABLE(pci, bcm43xx_pci_tbl);
 
 static struct pci_driver bcm43xx_pci_driver = {
-	.name = KBUILD_MODNAME,
-	.id_table = bcm43xx_pci_tbl,
-	.probe = bcm43xx_init_one,
-	.remove = __devexit_p(bcm43xx_remove_one),
-#ifdef CONFIG_PM
-	.suspend = bcm43xx_suspend,
-	.resume = bcm43xx_resume,
-#endif				/* CONFIG_PM */
+	.name		= &quot;bcm43xx-pci&quot;,
+	.id_table	= bcm43xx_pci_tbl,
 };
 
 static int __init bcm43xx_init(void)
 {
-	printk(KERN_INFO KBUILD_MODNAME &quot; driver\n&quot;);
+	int err;
+
 	bcm43xx_debugfs_init();
-	return pci_register_driver(&amp;bcm43xx_pci_driver);
+	err = ssb_pcihost_register(&amp;bcm43xx_pci_driver);
+	if (err)
+		goto err_dfs_exit;
+	err = ssb_driver_register(&amp;bcm43xx_ssb_driver);
+	if (err)
+		goto err_pci_exit;
+
+	return err;
+
+err_pci_exit:
+	ssb_pcihost_unregister(&amp;bcm43xx_pci_driver);
+err_dfs_exit:
+	bcm43xx_debugfs_exit();
+	return err;
 }
 
 static void __exit bcm43xx_exit(void)
 {
-	pci_unregister_driver(&amp;bcm43xx_pci_driver);
+	ssb_driver_unregister(&amp;bcm43xx_ssb_driver);
+	ssb_pcihost_unregister(&amp;bcm43xx_pci_driver);
 	bcm43xx_debugfs_exit();
 }
 
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
@@ -3,10 +3,11 @@
   Broadcom BCM43xx wireless driver
 
   Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
+  Copyright (c) 2005 Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
+  Copyright (c) 2005, 2006 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mb at bu3sch.de</A>&gt;
+  Copyright (c) 2005  Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
+  Copyright (c) 2005  Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
+  Copyright (c) 2007  Larry Finger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">Larry.Finger at lwfinger.net</A>&gt;
 
   Some parts of the code in this file are derived from the ipw2200
   driver  Copyright(c) 2003 - 2004 Intel Corporation.
@@ -33,6 +34,7 @@
 
 #include &quot;bcm43xx.h&quot;
 
+
 #define P4D_BYT3S(magic, nr_bytes)	u8 __p4dding##magic[nr_bytes]
 #define P4D_BYTES(line, nr_bytes)	P4D_BYT3S(line, nr_bytes)
 /* Magic helper macro to pad structures. Ignore those above. It's magic. */
@@ -41,11 +43,6 @@
 
 /* Lightweight function to convert a frequency (in Mhz) to a channel number. */
 static inline
-u8 bcm43xx_freq_to_channel_a(int freq)
-{
-	return ((freq - 5000) / 5);
-}
-static inline
 u8 bcm43xx_freq_to_channel_bg(int freq)
 {
 	u8 channel;
@@ -58,21 +55,14 @@ u8 bcm43xx_freq_to_channel_bg(int freq)
 	return channel;
 }
 static inline
-u8 bcm43xx_freq_to_channel(struct bcm43xx_private *bcm,
+u8 bcm43xx_freq_to_channel(struct bcm43xx_wldev *dev,
 			   int freq)
 {
-	if (bcm43xx_current_phy(bcm)-&gt;type == BCM43xx_PHYTYPE_A)
-		return bcm43xx_freq_to_channel_a(freq);
 	return bcm43xx_freq_to_channel_bg(freq);
 }
 
 /* Lightweight function to convert a channel number to a frequency (in Mhz). */
 static inline
-int bcm43xx_channel_to_freq_a(u8 channel)
-{
-	return (5000 + (5 * channel));
-}
-static inline
 int bcm43xx_channel_to_freq_bg(u8 channel)
 {
 	int freq;
@@ -84,50 +74,71 @@ int bcm43xx_channel_to_freq_bg(u8 channe
 
 	return freq;
 }
+
 static inline
-int bcm43xx_channel_to_freq(struct bcm43xx_private *bcm,
+int bcm43xx_channel_to_freq(struct bcm43xx_wldev *dev,
 			    u8 channel)
 {
-	if (bcm43xx_current_phy(bcm)-&gt;type == BCM43xx_PHYTYPE_A)
-		return bcm43xx_channel_to_freq_a(channel);
 	return bcm43xx_channel_to_freq_bg(channel);
 }
 
-void bcm43xx_tsf_read(struct bcm43xx_private *bcm, u64 *tsf);
-void bcm43xx_tsf_write(struct bcm43xx_private *bcm, u64 tsf);
+static inline
+int bcm43xx_is_cck_rate(int rate)
+{
+	return (rate == BCM43xx_CCK_RATE_1MB ||
+		rate == BCM43xx_CCK_RATE_2MB ||
+		rate == BCM43xx_CCK_RATE_5MB ||
+		rate == BCM43xx_CCK_RATE_11MB);
+}
+
+static inline
+int bcm43xx_is_ofdm_rate(int rate)
+{
+	return !bcm43xx_is_cck_rate(rate);
+}
+
+static inline
+int bcm43xx_is_hw_radio_enabled(struct bcm43xx_wldev *dev)
+{
+	/* function to return state of hardware enable of radio
+	 * returns 0 if radio disabled, 1 if radio enabled
+	 */
+	struct bcm43xx_phy *phy = &amp;dev-&gt;phy;
 
-void bcm43xx_set_iwmode(struct bcm43xx_private *bcm,
-			int iw_mode);
+	if (phy-&gt;rev &gt;= 3)
+		return ((bcm43xx_read32(dev, BCM43xx_MMIO_RADIO_HWENABLED_HI)
+					&amp; BCM43xx_MMIO_RADIO_HWENABLED_HI_MASK)
+					== 0) ? 1 : 0;
+	else
+		return ((bcm43xx_read16(dev, BCM43xx_MMIO_RADIO_HWENABLED_LO)
+					&amp; BCM43xx_MMIO_RADIO_HWENABLED_LO_MASK)
+					== 0) ? 0 : 1;
+}
+
+void bcm43xx_tsf_read(struct bcm43xx_wldev *dev, u64 *tsf);
+void bcm43xx_tsf_write(struct bcm43xx_wldev *dev, u64 tsf);
 
-u32 bcm43xx_shm_read32(struct bcm43xx_private *bcm,
+u32 bcm43xx_shm_read32(struct bcm43xx_wldev *dev,
 		       u16 routing, u16 offset);
-u16 bcm43xx_shm_read16(struct bcm43xx_private *bcm,
+u16 bcm43xx_shm_read16(struct bcm43xx_wldev *dev,
 		       u16 routing, u16 offset);
-void bcm43xx_shm_write32(struct bcm43xx_private *bcm,
+void bcm43xx_shm_write32(struct bcm43xx_wldev *dev,
 			 u16 routing, u16 offset,
 			 u32 value);
-void bcm43xx_shm_write16(struct bcm43xx_private *bcm,
+void bcm43xx_shm_write16(struct bcm43xx_wldev *dev,
 			 u16 routing, u16 offset,
 			 u16 value);
 
-void bcm43xx_dummy_transmission(struct bcm43xx_private *bcm);
-
-int bcm43xx_switch_core(struct bcm43xx_private *bcm, struct bcm43xx_coreinfo *new_core);
-
-int bcm43xx_select_wireless_core(struct bcm43xx_private *bcm,
-				 int phytype);
-
-void bcm43xx_wireless_core_reset(struct bcm43xx_private *bcm, int connect_phy);
+u32 bcm43xx_hf_read(struct bcm43xx_wldev *dev);
+void bcm43xx_hf_write(struct bcm43xx_wldev *dev, u32 value);
 
-void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
-void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
+void bcm43xx_dummy_transmission(struct bcm43xx_wldev *dev);
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
-void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
+void bcm43xx_wireless_core_reset(struct bcm43xx_wldev *dev, u32 flags);
 
-void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
+void bcm43xx_mac_suspend(struct bcm43xx_wldev *dev);
+void bcm43xx_mac_enable(struct bcm43xx_wldev *dev);
 
-int bcm43xx_sprom_read(struct bcm43xx_private *bcm, u16 *sprom);
-int bcm43xx_sprom_write(struct bcm43xx_private *bcm, const u16 *sprom);
+void bcm43xx_controller_restart(struct bcm43xx_wldev *dev, const char *reason);
 
 #endif /* BCM43xx_MAIN_H_ */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001699.html">[RFC 4/10] Port of bcm43xx from softmac to mac80211
</A></li>
	<LI>Next message: <A HREF="001704.html">[RFC 6/10] Port of bcm43xx from softmac to mac80211
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1705">[ date ]</a>
              <a href="thread.html#1705">[ thread ]</a>
              <a href="subject.html#1705">[ subject ]</a>
              <a href="author.html#1705">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">More information about the Bcm43xx-dev
mailing list</a><br>
</body></html>
