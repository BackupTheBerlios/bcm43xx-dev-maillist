From email at christianhoffmann.info  Tue May  1 20:20:05 2007
From: email at christianhoffmann.info (Christian Hoffmann)
Date: Tue, 1 May 2007 20:20:05 +0200
Subject: A milestone for bcm43xx and a problem
In-Reply-To: <mailman.3565.1177579054.5173.bcm43xx-dev@lists.berlios.de>
References: <mailman.3565.1177579054.5173.bcm43xx-dev@lists.berlios.de>
Message-ID: <200705012020.11336.email@christianhoffmann.info>

Hi,

applying combined-patches against 2.6.21 gives me following problems on 
gentoo:

  CC [M]  net/sctp/sysctl.o
  CC [M]  net/sctp/ipv6.o
  LD [M]  net/sctp/sctp.o
  Building modules, stage 2.
  MODPOST 281 modules
WARNING: "ieee80211_debug_level" [net/ieee80211/ieee80211_crypt_tkip.ko] 
undefined!
WARNING: "ieee80211_debug_level" [net/ieee80211/ieee80211_crypt_ccmp.ko] 
undefined!
make[1]: *** [__modpost] Error 1
make: *** [modules] Error 2
* Gentoo Linux Genkernel; Version 3.4.8
* Running with options: --menuconfig all

and kernel building fails. Any ideas?

Chris
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 827 bytes
Desc: This is a digitally signed message part.
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070501/a70c3d0d/attachment.pgp>

From zajec5polish at gmail.com  Tue May  1 20:45:54 2007
From: zajec5polish at gmail.com (=?UTF-8?Q?Rafa=C5=82_Mi=C5=82ecki?=)
Date: Tue, 1 May 2007 20:45:54 +0200
Subject: A milestone for bcm43xx and a problem
In-Reply-To: <46306D9E.3090009@lwfinger.net>
References: <46306D9E.3090009@lwfinger.net>
Message-ID: <14b026160705011145k67abc6ech8bc3a2a649af82a6@mail.gmail.com>

2007/4/26, Larry Finger <Larry.Finger at lwfinger.net>:
> Where are improvements still needed? Besides the obvious fall-off with increasing rate as seen in
> the above table, we also have a problem when bcm43xx is used in a congested wireless environment.
> This problem has been reported by several people, but I can now reliably reproduce it using my two
> test computers.

Oh, I already announced this problem in teaching center of my
polytechnic school. We have A LOT of wlan networks here and I can not
connect to this one I should be able to. I belived everytihing I need
is patch that will be included in 2.6.22-rc1.

So, since 2.6.22-rc1 is not a cure for this problem is there anything
I could make to help you solve this problem? I'll be in school after a
few days and if it is helpful I can run some tests to provice you a
logs. So... anything I can do?

-- 
Rafa? Mi?ecki

From larry.finger at lwfinger.net  Tue May  1 22:47:20 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 01 May 2007 15:47:20 -0500
Subject: A milestone for bcm43xx and a problem
In-Reply-To: <200705012020.11336.email@christianhoffmann.info>
References: <mailman.3565.1177579054.5173.bcm43xx-dev@lists.berlios.de>
	<200705012020.11336.email@christianhoffmann.info>
Message-ID: <4637A758.4090307@lwfinger.net>

Christian Hoffmann wrote:
> Hi,
> 
> applying combined-patches against 2.6.21 gives me following problems on 
> gentoo:
> 
>   CC [M]  net/sctp/sysctl.o
>   CC [M]  net/sctp/ipv6.o
>   LD [M]  net/sctp/sctp.o
>   Building modules, stage 2.
>   MODPOST 281 modules
> WARNING: "ieee80211_debug_level" [net/ieee80211/ieee80211_crypt_tkip.ko] 
> undefined!
> WARNING: "ieee80211_debug_level" [net/ieee80211/ieee80211_crypt_ccmp.ko] 
> undefined!
> make[1]: *** [__modpost] Error 1
> make: *** [modules] Error 2
> * Gentoo Linux Genkernel; Version 3.4.8
> * Running with options: --menuconfig all
> 
> and kernel building fails. Any ideas?

Yes, You need this patch:

Index: wireless-2.6/net/ieee80211/ieee80211_module.c
===================================================================
--- wireless-2.6.orig/net/ieee80211/ieee80211_module.c
+++ wireless-2.6/net/ieee80211/ieee80211_module.c
@@ -229,6 +229,7 @@ void free_ieee80211(struct net_device *d

  static int debug = 0;
  u32 ieee80211_debug_level = 0;
+EXPORT_SYMBOL_GPL(ieee80211_debug_level);
  static struct proc_dir_entry *ieee80211_proc = NULL;

  static int show_debug_level(char *page, char **start, off_t offset,

Larry



From ubq7 at stud.uni-karlsruhe.de  Tue May  1 13:15:41 2007
From: ubq7 at stud.uni-karlsruhe.de (Hendrik Sattler)
Date: Tue, 1 May 2007 13:15:41 +0200
Subject: BCM4320
In-Reply-To: <1177580982.6814.16.camel@johannes.berg>
References: <20070425021650.GB7974@guug.org> <200704251449.49908.mb@bu3sch.de>
	<1177580982.6814.16.camel@johannes.berg>
Message-ID: <200705011315.41688.ubq7@stud.uni-karlsruhe.de>

Am Donnerstag 26 April 2007 11:49 schrieb Johannes Berg:
> On Wed, 2007-04-25 at 14:49 +0200, Michael Buesch wrote:
> > USB devices are a whole new ballgame for a different, yet to be written,
> > driver.
>
> Which is actually a trivial thing to do for somebody with a windows
> machine, a usb snooper and some knowledge of C code (read the rndis
> driver in Linux)

This just came to debian-devel:
* Package name    : usb-rndis
  Version         : 0.10.0  
  Upstream Author : Ole Andr? Vadla Ravn?s <oleavr at gmail.com>
* URL             : http://www.synce.org/
* License         : GPL
  Programming Lang: C
  Description     : Source for the usb-rndis driver

HS


From andrew.james.barr at gmail.com  Tue May  1 23:20:22 2007
From: andrew.james.barr at gmail.com (Andrew J. Barr)
Date: Tue, 01 May 2007 17:20:22 -0400
Subject: BCM4320
In-Reply-To: <200705011315.41688.ubq7@stud.uni-karlsruhe.de>
References: <20070425021650.GB7974@guug.org>
	<200704251449.49908.mb@bu3sch.de>	<1177580982.6814.16.camel@johannes.berg>
	<200705011315.41688.ubq7@stud.uni-karlsruhe.de>
Message-ID: <4637AF16.7030500@gmail.com>

Hendrik Sattler wrote:
> This just came to debian-devel:
> * Package name    : usb-rndis
>   Version         : 0.10.0  
>   Upstream Author : Ole Andr? Vadla Ravn?s <oleavr at gmail.com>
> * URL             : http://www.synce.org/
> * License         : GPL
>   Programming Lang: C
>   Description     : Source for the usb-rndis driver
> 
> HS

Hmmm, so much for connecting the dots on my part...I was aware of this
(I used to have a PocketPC **shudder** and I still follow the SynCE
project casually) but not that it was what was needed for BCM43xx USB
devices...

-- 
Andrew J. Barr
Thunderbird/1.5.0.10 (compatible; Icedove 1.5; X11; en-US; Linux
2.6.21-rc7 x86_64) Debian/1.5.0.10dfsg.1-3

"Why must I fail at every attempt at masonry?"
	-- Homer Simpson, "Mom and Pop Art" [AABF15]


From Larry.Finger at lwfinger.net  Wed May  2 16:22:51 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 02 May 2007 09:22:51 -0500
Subject: [PATCH] mac80211: Fix for missing global (tcf_destroy_chain) in build
Message-ID: <46389ebb.JZh37v8gJUSOn1+U%Larry.Finger@lwfinger.net>

If MAC80211 is selected in the configuration without also selecting NET_SCHED,
there is a missing global (tcf_destroy_chain) in the build.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/net/mac80211/Kconfig
===================================================================
--- wireless-dev.orig/net/mac80211/Kconfig
+++ wireless-dev/net/mac80211/Kconfig
@@ -9,6 +9,7 @@ config MAC80211
 	select WIRELESS_EXT
 	select CFG80211
 	select NET_SCH_FIFO
+	select NET_SCHED
 	---help---
 	This option enables the hardware independent IEEE 802.11
 	networking stack.

---



From Larry.Finger at lwfinger.net  Wed May  2 16:28:05 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 02 May 2007 09:28:05 -0500
Subject: [PATCH] mac80211: Add support for SIOCGIWRATE ioctl to provide
	rate information
Message-ID: <46389ff5.oRExYGz42A2aZRmj%Larry.Finger@lwfinger.net>

At present, transmission rate information for mac80211 is available only
if verbose debugging is turned on, and then only in the logs. This patch
implements the SIOCGIWRATE ioctl, which adds the current transmission rate to
the output of iwconfig.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/net/mac80211/ieee80211_ioctl.c
===================================================================
--- wireless-dev.orig/net/mac80211/ieee80211_ioctl.c
+++ wireless-dev/net/mac80211/ieee80211_ioctl.c
@@ -2064,6 +2064,22 @@ static int ieee80211_ioctl_giwscan(struc
 }
 
 
+static int ieee80211_ioctl_giwrate(struct net_device *dev,
+				  struct iw_request_info *info,
+				  struct iw_param *rate, char *extra)
+{
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+	struct sta_info * sta;
+	struct ieee80211_sub_if_data * sdata;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	sta = sta_info_get(local, sdata->u.sta.bssid);
+	if (!sta)
+		return -ENODEV;
+	rate->value = local->oper_hw_mode->rates[sta->txrate].rate * 100000;
+	return 0;
+}
+
 static int ieee80211_ioctl_siwrts(struct net_device *dev,
 				  struct iw_request_info *info,
 				  struct iw_param *rts, char *extra)
@@ -3247,7 +3263,7 @@ static const iw_handler ieee80211_handle
 	(iw_handler) NULL,				/* -- hole -- */
 	(iw_handler) NULL,				/* -- hole -- */
 	(iw_handler) NULL,				/* SIOCSIWRATE */
-	(iw_handler) NULL,				/* SIOCGIWRATE */
+	(iw_handler) ieee80211_ioctl_giwrate,		/* SIOCGIWRATE */
 	(iw_handler) ieee80211_ioctl_siwrts,		/* SIOCSIWRTS */
 	(iw_handler) ieee80211_ioctl_giwrts,		/* SIOCGIWRTS */
 	(iw_handler) ieee80211_ioctl_siwfrag,		/* SIOCSIWFRAG */


From Larry.Finger at lwfinger.net  Wed May  2 16:50:04 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 02 May 2007 09:50:04 -0500
Subject: [PATCH V2] mac80211: Add support for SIOCGIWRATE ioctl to provide
	rate information
Message-ID: <4638a51c.ohaY83u2vcHGHvr4%Larry.Finger@lwfinger.net>

At present, transmission rate information for mac80211 is available only
if verbose debugging is turned on, and then only in the logs. This patch
implements the SIOCGIWRATE ioctl, which adds the current transmission rate to
the output of iwconfig.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/net/mac80211/ieee80211_ioctl.c
===================================================================
--- wireless-dev.orig/net/mac80211/ieee80211_ioctl.c
+++ wireless-dev/net/mac80211/ieee80211_ioctl.c
@@ -2013,6 +2013,23 @@ static int ieee80211_ioctl_giwscan(struc
 }
 
 
+static int ieee80211_ioctl_giwrate(struct net_device *dev,
+				  struct iw_request_info *info,
+				  struct iw_param *rate, char *extra)
+{
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+	struct sta_info * sta;
+	struct ieee80211_sub_if_data * sdata;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	sta = sta_info_get(local, sdata->u.sta.bssid);
+	if (!sta)
+		return -ENODEV;
+	rate->value = local->oper_hw_mode->rates[sta->txrate].rate * 100000;
+	sta_info_put(sta);
+	return 0;
+}
+
 static int ieee80211_ioctl_siwrts(struct net_device *dev,
 				  struct iw_request_info *info,
 				  struct iw_param *rts, char *extra)
@@ -3137,7 +3154,7 @@ static const iw_handler ieee80211_handle
 	(iw_handler) NULL,				/* -- hole -- */
 	(iw_handler) NULL,				/* -- hole -- */
 	(iw_handler) NULL,				/* SIOCSIWRATE */
-	(iw_handler) NULL,				/* SIOCGIWRATE */
+	(iw_handler) ieee80211_ioctl_giwrate,		/* SIOCGIWRATE */
 	(iw_handler) ieee80211_ioctl_siwrts,		/* SIOCSIWRTS */
 	(iw_handler) ieee80211_ioctl_giwrts,		/* SIOCGIWRTS */
 	(iw_handler) ieee80211_ioctl_siwfrag,		/* SIOCSIWFRAG */


From larry.finger at lwfinger.net  Wed May  2 17:21:48 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 02 May 2007 10:21:48 -0500
Subject: [PATCH] mac80211: Fix for missing global (tcf_destroy_chain)
	in build
In-Reply-To: <4638A163.8030505@trash.net>
References: <46389ebb.JZh37v8gJUSOn1+U%Larry.Finger@lwfinger.net>
	<4638A163.8030505@trash.net>
Message-ID: <4638AC8C.9060706@lwfinger.net>

Patrick McHardy wrote:
> 
> 
> That pretty much defeats the reason why CONFIG_NET_SCH_FIFO was created.
> So far without CONFIG_NET_SCHED the wme scheduler didn't even register,
> so it seems the proper fix is to get rid of all #ifdef CONFIG_NET_SCHED
> and simply avoid building it.

At least this "fix" lets the system build. Whomever broke it needs to do the proper fix.

Larry


From johannes at sipsolutions.net  Thu May  3 11:13:17 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 03 May 2007 11:13:17 +0200
Subject: [Fwd: finding your own dead "CONFIG_" variables]
Message-ID: <1178183597.13233.78.camel@johannes.berg>

-------- Forwarded Message --------
> From: Robert P. J. Day <rpjday at mindspring.com>
> To: Linux Kernel Mailing List <linux-kernel at vger.kernel.org>
> Cc: netdev at vger.kernel.org
> Subject: finding your own dead "CONFIG_" variables
> Date: Thu, 3 May 2007 04:19:48 -0400 (EDT)
> 
> while there's still a pile of possible dead CONFIG_ variables under
> the fs/ and drivers/ directories i haven't posted yet, you don't need
> to wait for me to generate them.  take a minute and run the script
> yourself:
> 
> http://fsdev.net/wiki/index.php?title=Dead_CONFIG_variables
> 
>   a couple of examples:
> 
> $ ../dead_config.sh net/wanrouter
> ========== WANPIPE_MULTPPP ==========
> net/wanrouter/wanmain.c:#ifdef CONFIG_WANPIPE_MULTPPP
> net/wanrouter/wanmain.c:#ifdef CONFIG_WANPIPE_MULTPPP
> net/wanrouter/wanmain.c:#ifdef CONFIG_WANPIPE_MULTPPP
> 
> $ ../dead_config.sh drivers/net/wireless
> ========== BCM947XX ==========
> drivers/net/wireless/bcm43xx/bcm43xx_dma.c:663:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx_main.h:36:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx_main.c:64:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx_main.c:145:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx_main.c:789:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx_main.c:799:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx_main.c:1228:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx_main.c:1390://FIXME: Do we _really_ want #ifndef CONFIG_BCM947XX here?
> drivers/net/wireless/bcm43xx/bcm43xx_main.c:1392:#ifndef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx_main.c:2143:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx_main.c:2155:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx_main.c:2648:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx_main.c:4147:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx.h:661:#ifdef CONFIG_BCM947XX
> drivers/net/wireless/bcm43xx/bcm43xx.h:792:#ifdef CONFIG_BCM947XX
> $
> 
>   go wild.
> 
> rday
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070503/96daaf53/attachment.pgp>

From oscar.valdez at duraflex.com.sv  Thu May  3 21:53:13 2007
From: oscar.valdez at duraflex.com.sv (Oscar A. Valdez)
Date: Thu, 03 May 2007 13:53:13 -0600
Subject: Is mac80211 generally available for use with bcm43xx?
Message-ID: <1178221993.7465.36.camel@tux.valdez-bicard.com.sv>

Sorry to post to this list, but the support forum at
http://bcm43xx.spugna.org/ is never up.

I understand that the 11Mb/s limitation is imposed by softmac, and that
the mac80211 module removes that limitation.

Is the mac80211 module generally available for use with bcm43xx? If so,
how? I've researched the matter, but haven't figured it out.
-- 
Oscar A. Valdez




From proski at gnu.org  Thu May  3 23:22:08 2007
From: proski at gnu.org (Pavel Roskin)
Date: Thu, 03 May 2007 17:22:08 -0400
Subject: Is mac80211 generally available for use with bcm43xx?
In-Reply-To: <1178221993.7465.36.camel@tux.valdez-bicard.com.sv>
References: <1178221993.7465.36.camel@tux.valdez-bicard.com.sv>
Message-ID: <1178227328.1812.10.camel@dv>

Hello!

On Thu, 2007-05-03 at 13:53 -0600, Oscar A. Valdez wrote:
> Sorry to post to this list, but the support forum at
> http://bcm43xx.spugna.org/ is never up.
> 
> I understand that the 11Mb/s limitation is imposed by softmac, and that
> the mac80211 module removes that limitation.

I'm afraid you are wrong about it.  In fact, the softmac based driver is
supporting rates up to 54 Mbps, although 48 and 54 Mbps rates are not
working well.  24 Mbps is working really well for me.  There is no speed
limitation in softmac.  The limitations are hardware specific.

The mac80211 based driver has some issues with power calibration, so it
works better if the rate is limited.  Larry posted a patch recently that
makes the rate start at 1 Mbps and then go up if the connection is good.
That helps a lot.

> Is the mac80211 module generally available for use with bcm43xx? If so,
> how? I've researched the matter, but haven't figured it out.

Yes, the module is present in the wireless-dev git repository.  It's not
yet in any released version of Linux.  I think it may go to 2.6.22, but
I'm not sure.  It's entirely possible that only those drivers will be
submitted that are more stable and offer support to the hardware not
supported otherwise.

We'll find out very soon, when Linux 2.6.22-rc1 is released.

-- 
Regards,
Pavel Roskin



From linville at tuxdriver.com  Thu May  3 23:57:00 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 3 May 2007 17:57:00 -0400
Subject: Is mac80211 generally available for use with bcm43xx?
In-Reply-To: <1178227328.1812.10.camel@dv>
References: <1178221993.7465.36.camel@tux.valdez-bicard.com.sv>
	<1178227328.1812.10.camel@dv>
Message-ID: <20070503215700.GD20940@tuxdriver.com>

On Thu, May 03, 2007 at 05:22:08PM -0400, Pavel Roskin wrote:
> On Thu, 2007-05-03 at 13:53 -0600, Oscar A. Valdez wrote:

> > Is the mac80211 module generally available for use with bcm43xx? If so,
> > how? I've researched the matter, but haven't figured it out.
> 
> Yes, the module is present in the wireless-dev git repository.  It's not
> yet in any released version of Linux.

FWIW, it should be available in Fedora 7 (due at the end of the month).

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Fri May  4 01:31:21 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 03 May 2007 18:31:21 -0500
Subject: Is mac80211 generally available for use with bcm43xx?
In-Reply-To: <1178221993.7465.36.camel@tux.valdez-bicard.com.sv>
References: <1178221993.7465.36.camel@tux.valdez-bicard.com.sv>
Message-ID: <463A70C9.3070200@lwfinger.net>

Oscar A. Valdez wrote:
> Sorry to post to this list, but the support forum at
> http://bcm43xx.spugna.org/ is never up.
> 
> I understand that the 11Mb/s limitation is imposed by softmac, and that
> the mac80211 module removes that limitation.
> 
> Is the mac80211 module generally available for use with bcm43xx? If so,
> how? I've researched the matter, but haven't figured it out.

There is no 11 Mbs limitation with softmac. The driver still cannot do 54 Mbs, but the fastest 
communication occurs for 24 or 36 Mbs, depending on your model.

There is a special version of bcm43xx for mac80211, which is available in John Linville's 
wireless-dev git tree. You should be aware that I only get a maximum throughput of 1.5 Mbs 
transmitting and 2.5 Mbs receiving with bcm43xx-mac80211 for my BCM4311 and my 4306 and 4318 cannot 
even connect. The equivalent numbers for bcm43xx-softmac on the 4311 are 11.5 and 15.5. YMMV.

Larry




From Larry.Finger at lwfinger.net  Fri May  4 01:52:50 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 03 May 2007 18:52:50 -0500
Subject: Curious behavior with bcm43xx-mac80211
Message-ID: <463A75D2.1040507@lwfinger.net>

I am seeing unusual behavior with bcm43xx-mac80211. When I first load the module and make a 
connection, iwconfig reports a "Signal level" of -33 dBm, a "Link quality' of 115/100, and a Bit 
rate of 11 Mbs. Within 10-15 seconds, the Signal level has gone down to -48 dBm, the Link quality is 
at 53/100, and the Bit rate is 1 Mbs. Tjhis behavior is reproducible.

At first I thought something might be wrong with the periodic work, but the same changes happen even 
if periodic work is disabled. It is clear that the jssi variable in the rx header is diminishing. Is 
the V4 firmware understood well enough to have a guess as to why this might be happening?

Thanks,

Larry


From Larry.Finger at lwfinger.net  Fri May  4 03:01:02 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 03 May 2007 20:01:02 -0500
Subject: [PATCH] bcm43xx: Remove dead configuration variable CONFIG_947XX
Message-ID: <463a85ce.UNBcSKi9Miz2B6RG%Larry.Finger@lwfinger.net>

The CONFIG_BCM947XX configuration variable was designed for use by the
embedded device used by the OpenWRT project. The device has been shifted
to the ssb driver in bcm43xx-mac80211 and will not be used with SoftMAC.
Accordingly, this "dead" configuration variable is removed.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

 bcm43xx.h      |   18 ++----------
 bcm43xx_dma.c  |    4 --
 bcm43xx_main.c |   81 ---------------------------------------------------------
 bcm43xx_main.h |   19 -------------
 4 files changed, 4 insertions(+), 118 deletions(-)

Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx.h
+++ wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
@@ -658,12 +658,6 @@ struct bcm43xx_pio {
 
 #define BCM43xx_MAX_80211_CORES		2
 
-#ifdef CONFIG_BCM947XX
-#define core_offset(bcm) (bcm)->current_core_offset
-#else
-#define core_offset(bcm) 0
-#endif
-
 /* Generic information about a core. */
 struct bcm43xx_coreinfo {
 	u8 available:1,
@@ -789,10 +783,6 @@ struct bcm43xx_private {
 
 	/* The currently active core. */
 	struct bcm43xx_coreinfo *current_core;
-#ifdef CONFIG_BCM947XX
-	/** current core memory offset */
-	u32 current_core_offset;
-#endif
 	struct bcm43xx_coreinfo *active_80211_core;
 	/* coreinfo structs for all possible cores follow.
 	 * Note that a core might not exist.
@@ -943,25 +933,25 @@ struct bcm43xx_lopair * bcm43xx_get_lopa
 static inline
 u16 bcm43xx_read16(struct bcm43xx_private *bcm, u16 offset)
 {
-	return ioread16(bcm->mmio_addr + core_offset(bcm) + offset);
+	return ioread16(bcm->mmio_addr + offset);
 }
 
 static inline
 void bcm43xx_write16(struct bcm43xx_private *bcm, u16 offset, u16 value)
 {
-	iowrite16(value, bcm->mmio_addr + core_offset(bcm) + offset);
+	iowrite16(value, bcm->mmio_addr + offset);
 }
 
 static inline
 u32 bcm43xx_read32(struct bcm43xx_private *bcm, u16 offset)
 {
-	return ioread32(bcm->mmio_addr + core_offset(bcm) + offset);
+	return ioread32(bcm->mmio_addr + offset);
 }
 
 static inline
 void bcm43xx_write32(struct bcm43xx_private *bcm, u16 offset, u32 value)
 {
-	iowrite32(value, bcm->mmio_addr + core_offset(bcm) + offset);
+	iowrite32(value, bcm->mmio_addr + offset);
 }
 
 static inline
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_dma.c
+++ wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_dma.c
@@ -660,10 +660,6 @@ struct bcm43xx_dmaring * bcm43xx_setup_d
 	ring->routing = BCM43xx_DMA32_CLIENTTRANS;
 	if (dma64)
 		ring->routing = BCM43xx_DMA64_CLIENTTRANS;
-#ifdef CONFIG_BCM947XX
-	if (bcm->pci_dev->bus->number == 0)
-		ring->routing = dma64 ? BCM43xx_DMA64_NOTRANS : BCM43xx_DMA32_NOTRANS;
-#endif
 
 	ring->bcm = bcm;
 	ring->nr_slots = nr_slots;
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -61,10 +61,6 @@ MODULE_AUTHOR("Stefano Brivio");
 MODULE_AUTHOR("Michael Buesch");
 MODULE_LICENSE("GPL");
 
-#ifdef CONFIG_BCM947XX
-extern char *nvram_get(char *name);
-#endif
-
 #if defined(CONFIG_BCM43XX_DMA) && defined(CONFIG_BCM43XX_PIO)
 static int modparam_pio;
 module_param_named(pio, modparam_pio, int, 0444);
@@ -142,10 +138,6 @@ MODULE_PARM_DESC(fwpostfix, "Postfix for
 	{ PCI_VENDOR_ID_BROADCOM, 0x4324, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
 	/* Broadcom 43XG 802.11b/g */
 	{ PCI_VENDOR_ID_BROADCOM, 0x4325, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-#ifdef CONFIG_BCM947XX
-	/* SB bus on BCM947xx */
-	{ PCI_VENDOR_ID_BROADCOM, 0x0800, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-#endif
 	{ 0 },
 };
 MODULE_DEVICE_TABLE(pci, bcm43xx_pci_tbl);
@@ -786,9 +778,6 @@ static int bcm43xx_sprom_extract(struct 
 {
 	u16 value;
 	u16 *sprom;
-#ifdef CONFIG_BCM947XX
-	char *c;
-#endif
 
 	sprom = kzalloc(BCM43xx_SPROM_SIZE * sizeof(u16),
 			GFP_KERNEL);
@@ -796,28 +785,7 @@ static int bcm43xx_sprom_extract(struct 
 		printk(KERN_ERR PFX "sprom_extract OOM\n");
 		return -ENOMEM;
 	}
-#ifdef CONFIG_BCM947XX
-	sprom[BCM43xx_SPROM_BOARDFLAGS2] = atoi(nvram_get("boardflags2"));
-	sprom[BCM43xx_SPROM_BOARDFLAGS] = atoi(nvram_get("boardflags"));
-
-	if ((c = nvram_get("il0macaddr")) != NULL)
-		e_aton(c, (char *) &(sprom[BCM43xx_SPROM_IL0MACADDR]));
-
-	if ((c = nvram_get("et1macaddr")) != NULL)
-		e_aton(c, (char *) &(sprom[BCM43xx_SPROM_ET1MACADDR]));
-
-	sprom[BCM43xx_SPROM_PA0B0] = atoi(nvram_get("pa0b0"));
-	sprom[BCM43xx_SPROM_PA0B1] = atoi(nvram_get("pa0b1"));
-	sprom[BCM43xx_SPROM_PA0B2] = atoi(nvram_get("pa0b2"));
-
-	sprom[BCM43xx_SPROM_PA1B0] = atoi(nvram_get("pa1b0"));
-	sprom[BCM43xx_SPROM_PA1B1] = atoi(nvram_get("pa1b1"));
-	sprom[BCM43xx_SPROM_PA1B2] = atoi(nvram_get("pa1b2"));
-
-	sprom[BCM43xx_SPROM_BOARDREV] = atoi(nvram_get("boardrev"));
-#else
 	bcm43xx_sprom_read(bcm, sprom);
-#endif
 
 	/* boardflags2 */
 	value = sprom[BCM43xx_SPROM_BOARDFLAGS2];
@@ -1225,12 +1193,6 @@ static int _switch_core(struct bcm43xx_p
 			goto error;
 		udelay(10);
 	}
-#ifdef CONFIG_BCM947XX
-	if (bcm->pci_dev->bus->number == 0)
-		bcm->current_core_offset = 0x1000 * core;
-	else
-		bcm->current_core_offset = 0;
-#endif
 
 	return 0;
 error:
@@ -1387,19 +1349,6 @@ void bcm43xx_wireless_core_reset(struct 
 
 	if ((bcm43xx_core_enabled(bcm)) &&
 	    !bcm43xx_using_pio(bcm)) {
-//FIXME: Do we _really_ want #ifndef CONFIG_BCM947XX here?
-#if 0
-#ifndef CONFIG_BCM947XX
-		/* reset all used DMA controllers. */
-		bcm43xx_dmacontroller_tx_reset(bcm, BCM43xx_MMIO_DMA1_BASE);
-		bcm43xx_dmacontroller_tx_reset(bcm, BCM43xx_MMIO_DMA2_BASE);
-		bcm43xx_dmacontroller_tx_reset(bcm, BCM43xx_MMIO_DMA3_BASE);
-		bcm43xx_dmacontroller_tx_reset(bcm, BCM43xx_MMIO_DMA4_BASE);
-		bcm43xx_dmacontroller_rx_reset(bcm, BCM43xx_MMIO_DMA1_BASE);
-		if (bcm->current_core->rev < 5)
-			bcm43xx_dmacontroller_rx_reset(bcm, BCM43xx_MMIO_DMA4_BASE);
-#endif
-#endif
 	}
 	if (bcm43xx_status(bcm) == BCM43xx_STAT_SHUTTINGDOWN) {
 		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
@@ -2140,32 +2089,11 @@ out:
 	return err;
 }
 
-#ifdef CONFIG_BCM947XX
-static struct pci_device_id bcm43xx_47xx_ids[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4324) },
-	{ 0 }
-};
-#endif
-
 static int bcm43xx_initialize_irq(struct bcm43xx_private *bcm)
 {
 	int err;
 
 	bcm->irq = bcm->pci_dev->irq;
-#ifdef CONFIG_BCM947XX
-	if (bcm->pci_dev->bus->number == 0) {
-		struct pci_dev *d;
-		struct pci_device_id *id;
-		for (id = bcm43xx_47xx_ids; id->vendor; id++) {
-			d = pci_get_device(id->vendor, id->device, NULL);
-			if (d != NULL) {
-				bcm->irq = d->irq;
-				pci_dev_put(d);
-				break;
-			}
-		}
-	}
-#endif
 	err = request_irq(bcm->irq, bcm43xx_interrupt_handler,
 			  IRQF_SHARED, KBUILD_MODNAME, bcm);
 	if (err)
@@ -2645,10 +2573,6 @@ static int bcm43xx_probe_cores(struct bc
 			chip_id_16 = 0x4610;
 		else if ((pci_device >= 0x4710) && (pci_device <= 0x4715))
 			chip_id_16 = 0x4710;
-#ifdef CONFIG_BCM947XX
-		else if ((pci_device >= 0x4320) && (pci_device <= 0x4325))
-			chip_id_16 = 0x4309;
-#endif
 		else {
 			printk(KERN_ERR PFX "Could not determine Chip ID\n");
 			return -ENODEV;
@@ -4144,11 +4068,6 @@ static int __devinit bcm43xx_init_one(st
 	struct bcm43xx_private *bcm;
 	int err;
 
-#ifdef CONFIG_BCM947XX
-	if ((pdev->bus->number == 0) && (pdev->device != 0x0800))
-		return -ENODEV;
-#endif
-
 #ifdef DEBUG_SINGLE_DEVICE_ONLY
 	if (strcmp(pci_name(pdev), DEBUG_SINGLE_DEVICE_ONLY))
 		return -ENODEV;
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
+++ wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
@@ -33,25 +33,6 @@
 
 #include "bcm43xx.h"
 
-#ifdef CONFIG_BCM947XX
-#define atoi(str) simple_strtoul(((str != NULL) ? str : ""), NULL, 0)
-
-static inline void e_aton(char *str, char *dest)
-{
-	int i = 0;
-	u16 *d = (u16 *) dest;
-
-	for (;;) {
-		dest[i++] = (char) simple_strtoul(str, NULL, 16);
-		str += 2;
-		if (!*str++ || i == 6)
-			break;
-	}
-	for (i = 0; i < 3; i++)
-		d[i] = cpu_to_be16(d[i]);
-}
-#endif
-
 #define P4D_BYT3S(magic, nr_bytes)	u8 __p4dding##magic[nr_bytes]
 #define P4D_BYTES(line, nr_bytes)	P4D_BYT3S(line, nr_bytes)
 /* Magic helper macro to pad structures. Ignore those above. It's magic. */


From Larry.Finger at lwfinger.net  Fri May  4 03:21:22 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 03 May 2007 20:21:22 -0500
Subject: [PATCH V3] mac80211: Add support for SIOCGIWRATE ioctl to provide
	rate information
Message-ID: <463a8a92.jFmmjY4cDnfJeisJ%Larry.Finger@lwfinger.net>

At present, transmission rate information for mac80211 is available only
if verbose debugging is turned on, and then only in the logs. This patch
implements the SIOCGIWRATE ioctl, which adds the current transmission rate to
the output of iwconfig.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/net/mac80211/ieee80211_ioctl.c
===================================================================
--- wireless-dev.orig/net/mac80211/ieee80211_ioctl.c
+++ wireless-dev/net/mac80211/ieee80211_ioctl.c
@@ -2013,6 +2013,27 @@ static int ieee80211_ioctl_giwscan(struc
 }
 
 
+static int ieee80211_ioctl_giwrate(struct net_device *dev,
+				  struct iw_request_info *info,
+				  struct iw_param *rate, char *extra)
+{
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+	struct sta_info * sta;
+	struct ieee80211_sub_if_data * sdata;
+
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	if (sdata->type == IEEE80211_IF_TYPE_STA ||
+	    sdata->type == IEEE80211_IF_TYPE_IBSS)
+		sta = sta_info_get(local, sdata->u.sta.bssid);
+	else
+		return -EOPNOTSUPP;
+	if (!sta)
+		return -ENODEV;
+	rate->value = local->oper_hw_mode->rates[sta->txrate].rate * 100000;
+	sta_info_put(sta);
+	return 0;
+}
+
 static int ieee80211_ioctl_siwrts(struct net_device *dev,
 				  struct iw_request_info *info,
 				  struct iw_param *rts, char *extra)
@@ -3137,7 +3158,7 @@ static const iw_handler ieee80211_handle
 	(iw_handler) NULL,				/* -- hole -- */
 	(iw_handler) NULL,				/* -- hole -- */
 	(iw_handler) NULL,				/* SIOCSIWRATE */
-	(iw_handler) NULL,				/* SIOCGIWRATE */
+	(iw_handler) ieee80211_ioctl_giwrate,		/* SIOCGIWRATE */
 	(iw_handler) ieee80211_ioctl_siwrts,		/* SIOCSIWRTS */
 	(iw_handler) ieee80211_ioctl_giwrts,		/* SIOCGIWRTS */
 	(iw_handler) ieee80211_ioctl_siwfrag,		/* SIOCSIWFRAG */


From gavron at Wetwork.Net  Fri May  4 08:33:29 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Thu, 03 May 2007 23:33:29 -0700
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops; with the
	bcm-softmac-sa fails to associate [4311]
Message-ID: <463AD3B9.40709@Wetwork.Net>

Ok, so I was bored... and installed the 2.6.21 kernel.
I then patch -p1 < combined_2.6.21.patch
make
make modules_install
make install
sync && reboot -f

The bcm43xx modules reports associated... scanning... associated... with 
another message in the middle, about once every half second without 
stopping.
The dmesg shows radio on, link not ready, link associated, radio off, 
[repeats]

At this point it appears to be a race condition to unload the bcm43xx 
module.  A simple ifdown eth1 && rmmod bcm43xx will either succeed, or 
crash (and crash is either the system is frozen, or a kernel panic).  An 
rmmod bcm43xx without the ifdown triggers similar responses.

----------------
tar -jxvf bcm-softmac-sa.tar.bz2
cd bcm-softmac-sa
make
make install
sync && reboot -f

At this point the adapter behaves much like it did back in the 2.6.18 
days.  The essid I give it via iwconfig only shows the first letter, and 
eventually switches to "Broadcom 4311" or the like.  The WEP key remains 
as programmed.  It never associates.  The log shows scanning... 
scanning... never associates.


--------------
One more note.  Prior to installing bcm-softmac-sa the bcm43xx scan 
identifies 13 channels. 
After installing bcm-softw=mac-ca the scan identifies 14 channels. 


I hope I'm not wasting everyone's time with a known issue.  If I'm not, 
kindly let me know what I'm doing wrong so that I can build it correctly 
and get it working to help further the testing process...


Thanks

Ehud
PS I am running the nvidia video driver... but the same symptoms were 
occurring prior to its installation. 

[root at egdell lfinger]# uname -a
Linux egdell.login.com 2.6.21 #1 SMP Thu May 3 22:12:46 MST 2007 i686 
i686 i386 GNU/Linux
[root at egdell lfinger]# lspci -n
00:00.0 0600: 8086:27a0 (rev 03)
00:01.0 0604: 8086:27a1 (rev 03)
00:1b.0 0403: 8086:27d8 (rev 01)
00:1c.0 0604: 8086:27d0 (rev 01)
00:1c.1 0604: 8086:27d2 (rev 01)
00:1c.2 0604: 8086:27d4 (rev 01)
00:1d.0 0c03: 8086:27c8 (rev 01)
00:1d.1 0c03: 8086:27c9 (rev 01)
00:1d.2 0c03: 8086:27ca (rev 01)
00:1d.3 0c03: 8086:27cb (rev 01)
00:1d.7 0c03: 8086:27cc (rev 01)
00:1e.0 0604: 8086:2448 (rev e1)
00:1f.0 0601: 8086:27b9 (rev 01)
00:1f.2 0101: 8086:27c4 (rev 01)
00:1f.3 0c05: 8086:27da (rev 01)
01:00.0 0300: 10de:01d7 (rev a1)
03:01.0 0607: 1217:6972 (rev 40)
09:00.0 0200: 14e4:1600 (rev 02)
0c:00.0 0280: 14e4:4311 (rev 01)

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070503/a5fe8434/attachment.bin>

From johannes at sipsolutions.net  Fri May  4 12:58:32 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 04 May 2007 12:58:32 +0200
Subject: [PATCH V3] mac80211: Add support for SIOCGIWRATE ioctl to
	provide rate information
In-Reply-To: <463a8a92.jFmmjY4cDnfJeisJ%Larry.Finger@lwfinger.net>
References: <463a8a92.jFmmjY4cDnfJeisJ%Larry.Finger@lwfinger.net>
Message-ID: <1178276312.7408.9.camel@johannes.berg>

On Thu, 2007-05-03 at 20:21 -0500, Larry Finger wrote:

> +	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
> +	if (sdata->type == IEEE80211_IF_TYPE_STA ||
> +	    sdata->type == IEEE80211_IF_TYPE_IBSS)
> +		sta = sta_info_get(local, sdata->u.sta.bssid);
> +	else
> +		return -EOPNOTSUPP;

Is this racy if somebody changes the type of the interface at the same
time? Would a fix be to sta_info_get() beforehand? I really don't know
without digging the code, Jiri, Michael?

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070504/8ef51452/attachment.pgp>

From jbenc at suse.cz  Fri May  4 13:00:19 2007
From: jbenc at suse.cz (Jiri Benc)
Date: Fri, 4 May 2007 13:00:19 +0200
Subject: [PATCH V3] mac80211: Add support for SIOCGIWRATE ioctl to
	provide rate information
In-Reply-To: <1178276312.7408.9.camel@johannes.berg>
References: <463a8a92.jFmmjY4cDnfJeisJ%Larry.Finger@lwfinger.net>
	<1178276312.7408.9.camel@johannes.berg>
Message-ID: <20070504130019.2f0911ca@griffin.suse.cz>

On Fri, 04 May 2007 12:58:32 +0200, Johannes Berg wrote:
> Is this racy if somebody changes the type of the interface at the same
> time? Would a fix be to sta_info_get() beforehand? I really don't know
> without digging the code, Jiri, Michael?

It's under rtnl, so that's fine.

 Jiri

-- 
Jiri Benc
SUSE Labs


From johannes at sipsolutions.net  Fri May  4 13:07:13 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 04 May 2007 13:07:13 +0200
Subject: [PATCH V3] mac80211: Add support for SIOCGIWRATE ioctl to 
	provide rate information
In-Reply-To: <20070504130019.2f0911ca@griffin.suse.cz>
References: <463a8a92.jFmmjY4cDnfJeisJ%Larry.Finger@lwfinger.net>
	<1178276312.7408.9.camel@johannes.berg>
	<20070504130019.2f0911ca@griffin.suse.cz>
Message-ID: <1178276834.7408.11.camel@johannes.berg>

On Fri, 2007-05-04 at 13:00 +0200, Jiri Benc wrote:
> On Fri, 04 May 2007 12:58:32 +0200, Johannes Berg wrote:
> > Is this racy if somebody changes the type of the interface at the same
> > time? Would a fix be to sta_info_get() beforehand? I really don't know
> > without digging the code, Jiri, Michael?
> 
> It's under rtnl, so that's fine.

Hah, good point, sorry.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070504/b3a01e1c/attachment.pgp>

From larry.finger at lwfinger.net  Fri May  4 18:09:08 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 04 May 2007 11:09:08 -0500
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops;
	with the	bcm-softmac-sa fails to associate [4311]
In-Reply-To: <463AD3B9.40709@Wetwork.Net>
References: <463AD3B9.40709@Wetwork.Net>
Message-ID: <463B5AA4.6000909@lwfinger.net>

Ehud Gavron wrote:
> Ok, so I was bored... and installed the 2.6.21 kernel.
> I then patch -p1 < combined_2.6.21.patch
> make
> make modules_install
> make install
> sync && reboot -f
> 
> The bcm43xx modules reports associated... scanning... associated... with 
> another message in the middle, about once every half second without 
> stopping.
> The dmesg shows radio on, link not ready, link associated, radio off, 
> [repeats]
> 
> At this point it appears to be a race condition to unload the bcm43xx 
> module.  A simple ifdown eth1 && rmmod bcm43xx will either succeed, or 
> crash (and crash is either the system is frozen, or a kernel panic).  An 
> rmmod bcm43xx without the ifdown triggers similar responses.

I cannot reproduce your problem using my 4311. I downloaded a fresh copy of 2.6.21 and patched it 
with the combined-2.6.21.patch from my FTP site. When I rebooted it came up just fine. In addition, 
I never see the kernel panics when removing the module. I use NetworkManager, which prevents an 
ifdown command, thus I just issue a 'modprobe -r bcm43xx' command. When you get a panic rather than 
a frozen system, please post the kernel panic dump.

I have sometimes seen a problem when switching between bcm43xx-mac80211 and bcm43xx-softmac. The 
symptoms are 'bcm43xx: IRQ_READY timeout' and 'bcm43xx: core_up for active 802.11 core failed (-19)' 
messages, which indicate that the firmware is not running correctly. Sometimes unloading and 
reloading the module will fix this, but it may require powering the system off (cold reboot).

> --------------
> One more note.  Prior to installing bcm-softmac-sa the bcm43xx scan 
> identifies 13 channels. After installing bcm-softw=mac-ca the scan 
> identifies 14 channels.

The standalone version does not have the recent patch that properly sets the channel range based on 
the locale setting. Thanks for noting this.

Larry



From gavron at Wetwork.Net  Sat May  5 06:01:06 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 04 May 2007 21:01:06 -0700
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops; with
	the	bcm-softmac-sa fails to associate [4311]
In-Reply-To: <463B5AA4.6000909@lwfinger.net>
References: <463AD3B9.40709@Wetwork.Net> <463B5AA4.6000909@lwfinger.net>
Message-ID: <463C0182.6030004@Wetwork.Net>

Just to be precise, I repeated everything.  Here it is in gory detail, 
except that I don't know how to capture the panic attack info because 
the system is stuck and I think a camera screenshot would be lame ;)

tar -zxvf linux-2.6.21.tar.gz
mv linux-2.6.21 /usr/src
ln -s /usr/src/linux-2.6.21 /usr/src/linux
cd /usr/src/linux
patch -p1 < ../combined_2.6.21.patch
[all patches applied.  No errors.  No reversed patches. No failure to 
find chunks, etc.]
cp /usr/src/kernels/2.6.20-1.2948.fc6-i686/.config .
make mrproper
make
make modules_install
make
sync && reboot -f

-----
On reboot, it associates immediately.  It even succeeds in getting a 
DHCP address.  I am excited.
But then.
It doesn't work.

Symptom: RX count increases.  tcpdump shows normal incoming packets on 
the wireless... 802.1d, announcements, UPnP, traffic. 
TX count does not increase.  Even if I explicitly ping it does not 
increase. 

Moved to within 2ft (.66M) from the xcvr.  Still TX count not increasing.

ifdown/ifup.  Radio off/radio on.  Associated.  Still no TXcount increase.

-----
Larry since it works for you out of the box with the composite patch, it 
must be something else vestigially left over from my Zod installation.  
Any thoughts on what I can try / what diagnostics I can run to figure 
out where the problem is?

E
PS Can't load bcm43xx_mac80211 (no such module)


Diagnostic information:
- arp shows the original info from the DHCP request/response.  Can't arp 
for anything else.
-


Larry Finger wrote:
> Ehud Gavron wrote:
>   
>> Ok, so I was bored... and installed the 2.6.21 kernel.
>> I then patch -p1 < combined_2.6.21.patch
>> make
>> make modules_install
>> make install
>> sync && reboot -f
>>
>> The bcm43xx modules reports associated... scanning... associated... with 
>> another message in the middle, about once every half second without 
>> stopping.
>> The dmesg shows radio on, link not ready, link associated, radio off, 
>> [repeats]
>>
>> At this point it appears to be a race condition to unload the bcm43xx 
>> module.  A simple ifdown eth1 && rmmod bcm43xx will either succeed, or 
>> crash (and crash is either the system is frozen, or a kernel panic).  An 
>> rmmod bcm43xx without the ifdown triggers similar responses.
>>     
>
> I cannot reproduce your problem using my 4311. I downloaded a fresh copy of 2.6.21 and patched it 
> with the combined-2.6.21.patch from my FTP site. When I rebooted it came up just fine. In addition, 
> I never see the kernel panics when removing the module. I use NetworkManager, which prevents an 
> ifdown command, thus I just issue a 'modprobe -r bcm43xx' command. When you get a panic rather than 
> a frozen system, please post the kernel panic dump.
>
> I have sometimes seen a problem when switching between bcm43xx-mac80211 and bcm43xx-softmac. The 
> symptoms are 'bcm43xx: IRQ_READY timeout' and 'bcm43xx: core_up for active 802.11 core failed (-19)' 
> messages, which indicate that the firmware is not running correctly. Sometimes unloading and 
> reloading the module will fix this, but it may require powering the system off (cold reboot).
>
>   
>> --------------
>> One more note.  Prior to installing bcm-softmac-sa the bcm43xx scan 
>> identifies 13 channels. After installing bcm-softw=mac-ca the scan 
>> identifies 14 channels.
>>     
>
> The standalone version does not have the recent patch that properly sets the channel range based on 
> the locale setting. Thanks for noting this.
>
> Larry
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070504/343bf5c7/attachment.bin>

From gavron at Wetwork.Net  Sat May  5 06:08:58 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 04 May 2007 21:08:58 -0700
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops; with
	the	bcm-softmac-sa fails to associate [4311]
In-Reply-To: <463C0182.6030004@Wetwork.Net>
References: <463AD3B9.40709@Wetwork.Net> <463B5AA4.6000909@lwfinger.net>
	<463C0182.6030004@Wetwork.Net>
Message-ID: <463C035A.1080403@Wetwork.Net>



Ehud Gavron wrote:
> Just to be precise, I repeated everything.  Here it is in gory detail, 
> except that I don't know how to capture the panic attack info because 
> the system is stuck and I think a camera screenshot would be lame ;)
>
> tar -zxvf linux-2.6.21.tar.gz
> mv linux-2.6.21 /usr/src
> ln -s /usr/src/linux-2.6.21 /usr/src/linux
> cd /usr/src/linux
> patch -p1 < ../combined_2.6.21.patch
> [all patches applied.  No errors.  No reversed patches. No failure to 
> find chunks, etc.]
> cp /usr/src/kernels/2.6.20-1.2948.fc6-i686/.config .
> make mrproper
> make
> make modules_install
> make
er, that's "make install"
> sync && reboot -f
>
> -----
> On reboot, it associates immediately.  It even succeeds in getting a 
> DHCP address.  I am excited.
> But then.
> It doesn't work.
>
> Symptom: RX count increases.  tcpdump shows normal incoming packets on 
> the wireless... 802.1d, announcements, UPnP, traffic. TX count does 
> not increase.  Even if I explicitly ping it does not increase.
> Moved to within 2ft (.66M) from the xcvr.  Still TX count not increasing.
>
> ifdown/ifup.  Radio off/radio on.  Associated.  Still no TXcount 
> increase.
>
> -----
> Larry since it works for you out of the box with the composite patch, 
> it must be something else vestigially left over from my Zod 
> installation.  Any thoughts on what I can try / what diagnostics I can 
> run to figure out where the problem is?
>
> E
> PS Can't load bcm43xx_mac80211 (no such module)
>
>
> Diagnostic information:
> - arp shows the original info from the DHCP request/response.  Can't 
> arp for anything else.
> -
>
>
> Larry Finger wrote:
>> Ehud Gavron wrote:
>>  
>>> Ok, so I was bored... and installed the 2.6.21 kernel.
>>> I then patch -p1 < combined_2.6.21.patch
>>> make
>>> make modules_install
>>> make install
>>> sync && reboot -f
>>>
>>> The bcm43xx modules reports associated... scanning... associated... 
>>> with another message in the middle, about once every half second 
>>> without stopping.
>>> The dmesg shows radio on, link not ready, link associated, radio 
>>> off, [repeats]
>>>
>>> At this point it appears to be a race condition to unload the 
>>> bcm43xx module.  A simple ifdown eth1 && rmmod bcm43xx will either 
>>> succeed, or crash (and crash is either the system is frozen, or a 
>>> kernel panic).  An rmmod bcm43xx without the ifdown triggers similar 
>>> responses.
>>>     
>>
>> I cannot reproduce your problem using my 4311. I downloaded a fresh 
>> copy of 2.6.21 and patched it with the combined-2.6.21.patch from my 
>> FTP site. When I rebooted it came up just fine. In addition, I never 
>> see the kernel panics when removing the module. I use NetworkManager, 
>> which prevents an ifdown command, thus I just issue a 'modprobe -r 
>> bcm43xx' command. When you get a panic rather than a frozen system, 
>> please post the kernel panic dump.
>>
>> I have sometimes seen a problem when switching between 
>> bcm43xx-mac80211 and bcm43xx-softmac. The symptoms are 'bcm43xx: 
>> IRQ_READY timeout' and 'bcm43xx: core_up for active 802.11 core 
>> failed (-19)' messages, which indicate that the firmware is not 
>> running correctly. Sometimes unloading and reloading the module will 
>> fix this, but it may require powering the system off (cold reboot).
>>
>>  
>>> --------------
>>> One more note.  Prior to installing bcm-softmac-sa the bcm43xx scan 
>>> identifies 13 channels. After installing bcm-softw=mac-ca the scan 
>>> identifies 14 channels.
>>>     
>>
>> The standalone version does not have the recent patch that properly 
>> sets the channel range based on the locale setting. Thanks for noting 
>> this.
>>
>> Larry
>>
>> _______________________________________________
>> Bcm43xx-dev mailing list
>> Bcm43xx-dev at lists.berlios.de
>> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>>   
> ------------------------------------------------------------------------
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070504/0bf13278/attachment.bin>

From larry.finger at lwfinger.net  Sat May  5 06:16:17 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 04 May 2007 23:16:17 -0500
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops;
	with the	bcm-softmac-sa fails to associate [4311]
In-Reply-To: <463C0182.6030004@Wetwork.Net>
References: <463AD3B9.40709@Wetwork.Net> <463B5AA4.6000909@lwfinger.net>
	<463C0182.6030004@Wetwork.Net>
Message-ID: <463C0511.3070909@lwfinger.net>

Ehud Gavron wrote:
> Just to be precise, I repeated everything.  Here it is in gory detail, 
> except that I don't know how to capture the panic attack info because 
> the system is stuck and I think a camera screenshot would be lame ;)

Do you have the option of using netconsole to capture the message? What I would like to know is what 
the kernel thinks is wrong.

> tar -zxvf linux-2.6.21.tar.gz
> mv linux-2.6.21 /usr/src
> ln -s /usr/src/linux-2.6.21 /usr/src/linux
> cd /usr/src/linux
> patch -p1 < ../combined_2.6.21.patch
> [all patches applied.  No errors.  No reversed patches. No failure to 
> find chunks, etc.]
> cp /usr/src/kernels/2.6.20-1.2948.fc6-i686/.config .
> make mrproper
> make
> make modules_install
> make
> sync && reboot -f
> 
> -----
> On reboot, it associates immediately.  It even succeeds in getting a 
> DHCP address.  I am excited.
> But then.
> It doesn't work.
> 
> Symptom: RX count increases.  tcpdump shows normal incoming packets on 
> the wireless... 802.1d, announcements, UPnP, traffic. TX count does not 
> increase.  Even if I explicitly ping it does not increase.
> Moved to within 2ft (.66M) from the xcvr.  Still TX count not increasing.
> 
> ifdown/ifup.  Radio off/radio on.  Associated.  Still no TXcount increase.
> 
> -----
> Larry since it works for you out of the box with the composite patch, it 
> must be something else vestigially left over from my Zod installation.  
> Any thoughts on what I can try / what diagnostics I can run to figure 
> out where the problem is?
> 
> E
> PS Can't load bcm43xx_mac80211 (no such module)

That module only exists for the mac80211 version.

Please reboot and send me all the lines in the log that start with bcm43xx.

Larry



From gavron at Wetwork.Net  Sat May  5 06:24:04 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 04 May 2007 21:24:04 -0700
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops; with
	the	bcm-softmac-sa fails to associate [4311]
In-Reply-To: <463C0511.3070909@lwfinger.net>
References: <463AD3B9.40709@Wetwork.Net> <463B5AA4.6000909@lwfinger.net>
	<463C0182.6030004@Wetwork.Net> <463C0511.3070909@lwfinger.net>
Message-ID: <463C06E4.20304@Wetwork.Net>



Larry Finger wrote:
> ...
> Do you have the option of using netconsole to capture the message? What I would like to know is what 
> the kernel thinks is wrong.
>   
Well... um... Ok, here's where you find out how little I know.  Google 
told me to go to http://lwn.net/2001/0927/a/netconsole.php3 which has an 
article referencing 2.4.10 and requiring netconsole-client.  My other 
FC6 box on the network [which isn't on wired LAN but I'd have to connect 
to do this, since WLAN is obviously what's having the issues] has a 
netconsole module but no netconsole-client...

> Please reboot and send me all the lines in the log that start with bcm43xx.
>   
Do you mean:
1. Reboot in 2.6.21...
2. Associate or not, do whatever you normally do, wait till it either 
WON'T WORK or CRASHES
3. Reboot in FC6 (2.6.20-1.2948.fc6)
4. Send log file lines starting with bcm..
?

Ehud
> Larry
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070504/697466c1/attachment.bin>

From larry.finger at lwfinger.net  Sat May  5 17:13:57 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 05 May 2007 10:13:57 -0500
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops;
	with the	bcm-softmac-sa fails to associate [4311]
In-Reply-To: <463C06E4.20304@Wetwork.Net>
References: <463AD3B9.40709@Wetwork.Net> <463B5AA4.6000909@lwfinger.net>
	<463C0182.6030004@Wetwork.Net> <463C0511.3070909@lwfinger.net>
	<463C06E4.20304@Wetwork.Net>
Message-ID: <463C9F35.6060109@lwfinger.net>

Ehud Gavron wrote:
>>   
> Do you mean:
> 1. Reboot in 2.6.21...
> 2. Associate or not, do whatever you normally do, wait till it either 
> WON'T WORK or CRASHES
> 3. Reboot in FC6 (2.6.20-1.2948.fc6)
> 4. Send log file lines starting with bcm..

Reboot in 2.6.21 and let it run until if loses communication. At that point, run the command 'dmesg 
| grep bcm43xx > bcm.txt'. After you get communication back, mail me bcm.txt.

For information about netconsole, see Documentation/networking/netconsole.txt.

Larry


From oscar.valdez at duraflex.com.sv  Sat May  5 22:00:43 2007
From: oscar.valdez at duraflex.com.sv (Oscar A. Valdez)
Date: Sat, 05 May 2007 14:00:43 -0600
Subject: Is mac80211 generally available for use with bcm43xx?
In-Reply-To: <1178227328.1812.10.camel@dv>
References: <1178221993.7465.36.camel@tux.valdez-bicard.com.sv>
	<1178227328.1812.10.camel@dv>
Message-ID: <1178395244.2986.10.camel@tux.valdez-bicard.com.sv>

El jue, 03-05-2007 a las 17:22 -0400, Pavel Roskin escribi?:
> On Thu, 2007-05-03 at 13:53 -0600, Oscar A. Valdez wrote:
> > Sorry to post to this list, but the support forum at
> > http://bcm43xx.spugna.org/ is never up.
> > 
> > I understand that the 11Mb/s limitation is imposed by softmac, and that
> > the mac80211 module removes that limitation.
> 
> I'm afraid you are wrong about it.  In fact, the softmac based driver is
> supporting rates up to 54 Mbps, although 48 and 54 Mbps rates are not
> working well.  24 Mbps is working really well for me.  There is no speed
> limitation in softmac.  The limitations are hardware specific.

Hmmm...

I have a Dell laptop with a "Dell Wireless 1390 802.11g Mini Card
54Mbps". The most I get from it is 11Mbps with softmac and the 3.50.21.0
wl.o firmware.

Can anyone suggest ways I can improve my speed?
-- 
Oscar A. Valdez




From larry.finger at lwfinger.net  Sat May  5 23:52:02 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 05 May 2007 16:52:02 -0500
Subject: Is mac80211 generally available for use with bcm43xx?
In-Reply-To: <1178395244.2986.10.camel@tux.valdez-bicard.com.sv>
References: <1178221993.7465.36.camel@tux.valdez-bicard.com.sv>	<1178227328.1812.10.camel@dv>
	<1178395244.2986.10.camel@tux.valdez-bicard.com.sv>
Message-ID: <463CFC82.3060206@lwfinger.net>

Oscar A. Valdez wrote:
> 
> Hmmm...
> 
> I have a Dell laptop with a "Dell Wireless 1390 802.11g Mini Card
> 54Mbps". The most I get from it is 11Mbps with softmac and the 3.50.21.0
> wl.o firmware.
> 
> Can anyone suggest ways I can improve my speed?

What kernel are you using, and what patch level? If you use anything other than the patches on my 
ftp site, your performance will be limited.

Larry




From groups at berebel.com  Sun May  6 02:11:49 2007
From: groups at berebel.com (Denis V Seleznyov)
Date: Sun, 6 May 2007 04:11:49 +0400
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops;
Message-ID: <200705060411.49303.groups@berebel.com>

Ehud Gavron wrote:

> Ok, so I was bored... and installed the 2.6.21 kernel.
> I then patch -p1 < combined_2.6.21.patch
> make
> make modules_install
> make install
> sync && reboot -f
> 
> The bcm43xx modules reports associated... scanning... associated... with
> another message in the middle, about once every half second without
> stopping.
> The dmesg shows radio on, link not ready, link associated, radio off,
> [repeats]

I have similar problem with 4311 (Dell Inspiron 640m with 1390 mini-wireless
module). I didn't noticed neither any problems with kernel module inserting
or removing, nor kernel panic.

Sysinfo:
Gentoo Linux
linux-2.6.21 (almost vanilla) + combined_2.6.21.patch
Asus AM604g adsl router/AP based on Broadcom BCM6348
wpa_supplicant-0.5.7
firmware 3.130.20.0
Network authentication: WPA-PSK with TKIP encryption
wireless card is eth2

wpa_supplicant.conf:

ap_scan=1
network={
        ssid="myssid"
        bssid=02:13:d4:XX:XX:XX
        scan_ssid=1
        proto=WPA
        key_mgmt=WPA-PSK
        pairwise=TKIP
        group=TKIP
        psk="secret"
}

Running
`wpa_supplicant -Dwext -ieth2 -c/etc/wpa_supplicant/wpa_supplicant.conf -d`
gives me following (beware, story continues below):

###################### wpa_supplicant starting ###################

SIOCGIWRANGE: WE(compiled)=22 WE(source)=18 enc_capa=0xf
  capabilities: key_mgmt 0xf enc 0xf
WEXT: Operstate: linkmode=1, operstate=5
Own MAC address: 00:16:ce:7d:8a:c4
wpa_driver_wext_set_wpa
wpa_driver_wext_set_key: alg=0 key_idx=0 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=1 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=2 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=3 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_countermeasures
wpa_driver_wext_set_drop_unencrypted
Setting scan request: 0 sec 100000 usec
ctrl_interface_group=440
Added interface eth2
RTM_NEWLINK: operstate=0 ifi_flags=0x1002 ()
Wireless event: cmd=0x8b06 len=8
RTM_NEWLINK: operstate=0 ifi_flags=0x11043 ([UP][RUNNING][LOWER_UP])
RTM_NEWLINK, IFLA_IFNAME: Interface 'eth2' added
RTM_NEWLINK: operstate=0 ifi_flags=0x11043 ([UP][RUNNING][LOWER_UP])
RTM_NEWLINK, IFLA_IFNAME: Interface 'eth2' added
RTM_NEWLINK: operstate=0 ifi_flags=0x11003 ([UP][LOWER_UP])
RTM_NEWLINK, IFLA_IFNAME: Interface 'eth2' added
State: DISCONNECTED -> SCANNING
############### associating process was here #################
State: ASSOCIATING -> ASSOCIATED
wpa_driver_wext_set_operstate: operstate 0->0 (DORMANT)
WEXT: Operstate: linkmode=-1, operstate=5
Associated to a new BSS: BSSID=02:13:d4:ff:c2:01
No keys have been configured - skip key clearing
Associated with 02:13:d4:ff:c2:01
WPA: Association event - clear replay counter
EAPOL: External notification - portEnabled=0
EAPOL: External notification - portValid=0
EAPOL: External notification - EAP success=0
EAPOL: External notification - portEnabled=1
EAPOL: SUPP_PAE entering state CONNECTING
EAPOL: SUPP_BE entering state IDLE
Setting authentication timeout: 10 sec 0 usec
Cancelling scan request
RX EAPOL from 02:13:d4:ff:c2:01
Setting authentication timeout: 10 sec 0 usec
IEEE 802.1X RX: version=1 type=3 length=95
  EAPOL-Key type=254
  key_info 0x89 (ver=1 keyidx=0 rsvd=0 Pairwise Ack)
  key_length=32 key_data_length=0
  replay_counter - hexdump(len=8): 00 00 00 00 00 00 00 00
  key_nonce - hexdump(len=32): 0f ed f8 e0 f3 18 a2 02 63 ad a0 06 ce 06 ff
0b 5d 3d 56 00 ff 48 93 89 0f 58 51 95 73 0e bb 50
  key_iv - hexdump(len=16): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  key_rsc - hexdump(len=8): 00 00 00 00 00 00 00 00
  key_id (reserved) - hexdump(len=8): 00 00 00 00 00 00 00 00
  key_mic - hexdump(len=16): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
State: ASSOCIATED -> 4WAY_HANDSHAKE
WPA: RX message 1 of 4-Way Handshake from 02:13:d4:ff:c2:01 (ver=1)
WPA: Renewed SNonce - hexdump(len=32): c5 1a b5 8f b9 5f af 76 bd a7 b1 db
44 8f bd d9 42 cb 4f 24 37 4e 77 02 41 64 a4 db a8 ed b0 9a
WPA: PMK - hexdump(len=32): [REMOVED]
WPA: PTK - hexdump(len=64): [REMOVED]
WPA: WPA IE for msg 2/4 - hexdump(len=24): dd 16 00 50 f2 01 01 00 00 50 f2
02 01 00 00 50 f2 02 01 00 00 50 f2 02
WPA: Sending EAPOL-Key 2/4
RX EAPOL from 02:13:d4:ff:c2:01
IEEE 802.1X RX: version=1 type=3 length=121
  EAPOL-Key type=254
  key_info 0x1c9 (ver=1 keyidx=0 rsvd=0 Pairwise Install Ack MIC)
  key_length=32 key_data_length=26
  replay_counter - hexdump(len=8): 00 00 00 00 00 00 00 01
  key_nonce - hexdump(len=32): 0f ed f8 e0 f3 18 a2 02 63 ad a0 06 ce 06 ff
0b 5d 3d 56 00 ff 48 93 89 0f 58 51 95 73 0e bb 50
  key_iv - hexdump(len=16): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  key_rsc - hexdump(len=8): 00 00 00 00 00 00 00 00
  key_id (reserved) - hexdump(len=8): 00 00 00 00 00 00 00 00
  key_mic - hexdump(len=16): 1c 7c 0d 32 4d f7 80 03 4a 06 35 37 32 84 12 c5
State: 4WAY_HANDSHAKE -> 4WAY_HANDSHAKE
WPA: RX message 3 of 4-Way Handshake from 02:13:d4:ff:c2:01 (ver=1)
WPA: IE KeyData - hexdump(len=26): dd 18 00 50 f2 01 01 00 00 50 f2 02 01 00
00 50 f2 02 01 00 00 50 f2 02 00 00
WPA: Sending EAPOL-Key 4/4
WPA: Installing PTK to the driver.
WPA: RSC - hexdump(len=6): 00 00 00 00 00 00
wpa_driver_wext_set_key: alg=2 key_idx=0 set_tx=1 seq_len=6 key_len=32

############## stuble seems to be here #########
ioctl[SIOCSIWENCODEEXT]: Invalid argument
Driver did not support SIOCSIWENCODEEXT
WPA: Failed to set PTK to the driver.
State: 4WAY_HANDSHAKE -> GROUP_HANDSHAKE
EAPOL: startWhen --> 0
EAPOL: SUPP_PAE entering state CONNECTING
EAPOL: txStart
WPA: drop TX EAPOL in non-IEEE 802.1X mode (type=1 len=0)
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
Wireless event: cmd=0x8b15 len=20
Wireless event: new AP: 00:00:00:00:00:00
Setting scan request: 0 sec 100000 usec
Added BSSID 02:13:d4:ff:c2:01 into blacklist
CTRL-EVENT-DISCONNECTED - Disconnect event - remove keys
wpa_driver_wext_set_key: alg=0 key_idx=0 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=1 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=2 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=3 set_tx=0 seq_len=0 key_len=0
wpa_driver_wext_set_key: alg=0 key_idx=0 set_tx=0 seq_len=0 key_len=0
State: GROUP_HANDSHAKE -> DISCONNECTED
wpa_driver_wext_set_operstate: operstate 0->0 (DORMANT)
WEXT: Operstate: linkmode=-1, operstate=5
EAPOL: External notification - portEnabled=0
EAPOL: SUPP_PAE entering state DISCONNECTED
EAPOL: SUPP_BE entering state INITIALIZE
EAPOL: External notification - portValid=0
EAPOL: External notification - EAP success=0
RTM_NEWLINK: operstate=0 ifi_flags=0x1003 ([UP])
RTM_NEWLINK, IFLA_IFNAME: Interface 'eth2' added
State: DISCONNECTED -> SCANNING
################ Loop started ######################


Now, a pieces of strace wpa_supplicant:

###################### eth2 opens here ###################
13622      0.000065 [b7f29410] socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 3
<0.000020>
13622      0.000051 [b7f29410] socket(PF_NETLINK, SOCK_RAW, 0) = 4
<0.000012>
13622      0.000046 [b7f29410] bind(4, {sa_family=AF_NETLINK, pid=0,
groups=00000001}, 12) = 0 <0.000010>
13622      0.000048 [b7f29410] ioctl(3, 0x8b36, 0xbf972a9c) = -1 EOPNOTSUPP
(Operation not supported) <0.000010>
13622      0.000050 [b7f29410] ioctl(3, SIOCSIWMODE, 0xbf972aa0) = 0
<0.000012>
13622      0.000042 [b7f29410] ioctl(3, SIOCGIFFLAGS, {ifr_name="eth2",
ifr_flags=IFF_BROADCAST|IFF_MULTICAST}) = 0 <0.000007>
13622      0.000049 [b7f29410] ioctl(3, SIOCSIFFLAGS, 0xbf972aa0) = 0
<0.336692>
13622      0.336747 [b7f29410] ioctl(3, SIOCGIWRANGE, 0xbf972af8) = 0
<0.016013>
13622      0.016071 [b7f29410] write(1, "SIOCGIWRANGE: WE(compiled)=22
WE(source)=18 enc_capa=0xf\n", 57) = 57 <0.000240>
13622      0.000295 [b7f29410] write(1, "  capabilities: key_mgmt 0xf enc
0xf\n", 37) = 37 <0.000119>

############################ failed ioctl #################################
13622      0.000184 [b7f29410] ioctl(3, 0x8b34, 0xbf971f3c) = -1 EINVAL
(Invalid argument) <0.001710>
13622      0.001751 [b7f29410] dup(2)   = 7 <0.000006>
13622      0.000034 [b7f29410] fcntl64(7, F_GETFL) = 0x2 (flags O_RDWR)
<0.000006>
13622      0.000036 [b7f29410] fstat64(7, {st_dev=makedev(0, 10), st_ino=17,
st_mode=S_IFCHR|0600, st_nlink=1, st_uid=1000, st_gid=5, st_blksize=1024,
st_blocks=0, st_rdev=makedev(136, 15), st_atime=2007/05/05-06:26:05,
st_mtime=2007/05/05-06:26:06, st_ctime=2007/05/05-03:34:50}) = 0 <0.000007>
13622      0.000093 [b7f29410] mmap2(NULL, 4096, PROT_READ|PROT_WRITE,
MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f0c000 <0.000007>
13622      0.000040 [b7f29410] _llseek(7, 0, 0xbf971da8, SEEK_CUR) = -1
ESPIPE (Illegal seek) <0.000006>


############################ explanation from wpa_supplicant ##############
13622      0.000046 [b7f29410] write(7, "ioctl[SIOCSIWENCODEEXT]: Invalid
argument\n", 42) = 42 <0.000119>
13622      0.000161 [b7f29410] close(7) = 0 <0.000006>
13622      0.000030 [b7f29410] munmap(0xb7f0c000, 4096) = 0 <0.000012>
13622      0.000042 [b7f29410] write(1, "Driver did not support
SIOCSIWENCODEEXT\n", 40) = 40 <0.000096>
13622      0.000138 [b7f29410] write(1, "WPA: Failed to set PTK to the
driver.\n", 38) = 38 <0.000095>
13622      0.000137 [b7f29410] write(1, "State: 4WAY_HANDSHAKE ->
GROUP_HANDSHAKE\n", 41) = 41 <0.000095>


If anybody wants to see full strace output (it is really big), or another
info, I'm glad to work on it.


From mb at bu3sch.de  Sun May  6 03:03:17 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 6 May 2007 03:03:17 +0200
Subject: Merging SSB upstream
Message-ID: <200705060303.17594.mb@bu3sch.de>

So, now that mac80211 is merged upstream, I think it's
time to merge SSB and the b44-ssb port upstream.
Note that bcm43xx-mac80211 is _not_ ready for upstream, yet.

What do you think? I'd like to merge ssb as-is, although
the embedded-device parts are not quite finished, yet.
But they don't interfere with the non-embedded parts used
by b44 and the bcm43xx PCI cards.
So we _could_ remove the ssb-mips code, but I don't like to
do that for better maintainability. It doesn't hurt anyone IMO.

Some opinions?

-- 
Greetings Michael.


From mb at bu3sch.de  Sun May  6 03:09:29 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 6 May 2007 03:09:29 +0200
Subject: [PATCH 2/3] fix G LO variables and functions naming
In-Reply-To: <20070423203335.21f6afe0@localhost>
References: <20070423202530.2829f309@localhost>
	<20070423203335.21f6afe0@localhost>
Message-ID: <200705060309.30129.mb@bu3sch.de>

On Monday 23 April 2007 20:33:35 Stefano Brivio wrote:
> Avoid confusion between A and G PHY LocalOscillator-related variables and
> functions.

I applied this patch. Thanks.

-- 
Greetings Michael.


From groups at berebel.com  Sun May  6 04:13:28 2007
From: groups at berebel.com (Denis V Seleznyov)
Date: Sun, 6 May 2007 06:13:28 +0400
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops -
	SOLVED
In-Reply-To: <200705060411.49303.groups@berebel.com>
References: <200705060411.49303.groups@berebel.com>
Message-ID: <200705060613.28752.groups@berebel.com>

On Sunday, 06 May 2007 04:11:49 Denis V Seleznyov wrote:
> Ehud Gavron wrote:
> > The bcm43xx modules reports associated... scanning... associated... with
> > another message in the middle, about once every half second without
> > stopping.
> > The dmesg shows radio on, link not ready, link associated, radio off,
> > [repeats]
>
> I have similar problem with 4311 (Dell Inspiron 640m with 1390
> mini-wireless module). I didn't noticed neither any problems with kernel
> module inserting or removing, nor kernel panic.

> Network authentication: WPA-PSK with TKIP encryption

I don't know how it did happen, but CONFIG_IEEE80211_CRYPT_TKIP was not set.

Thus, it is bug in wpa_supplicant or softmac code rather then in bcm43xx.


From linville at tuxdriver.com  Sun May  6 04:00:51 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Sat, 5 May 2007 22:00:51 -0400
Subject: Merging SSB upstream
In-Reply-To: <200705060303.17594.mb@bu3sch.de>
References: <200705060303.17594.mb@bu3sch.de>
Message-ID: <20070506020051.GA30917@tuxdriver.com>

On Sun, May 06, 2007 at 03:03:17AM +0200, Michael Buesch wrote:
> So, now that mac80211 is merged upstream, I think it's
> time to merge SSB and the b44-ssb port upstream.
> Note that bcm43xx-mac80211 is _not_ ready for upstream, yet.
 
ACK, unfortunately.

> What do you think? I'd like to merge ssb as-is, although
> the embedded-device parts are not quite finished, yet.
> But they don't interfere with the non-embedded parts used
> by b44 and the bcm43xx PCI cards.

How much testing have you (and others) done w/ b44?  I had to remove
the b44 ssb changes from fedora because a) users reported problems;
and b) I was more worried about wireless than b44+ssb. (sorry!)

So, has anyone been using b44 in -mm?

> So we _could_ remove the ssb-mips code, but I don't like to
> do that for better maintainability. It doesn't hurt anyone IMO.

I guess I don't see a problem w/ merging the mips part, as long as the
b44 part has been thoroughly tested.  I wonder if Ralf has an opinion?

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Sun May  6 04:43:46 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 05 May 2007 21:43:46 -0500
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops
	-	SOLVED
In-Reply-To: <200705060613.28752.groups@berebel.com>
References: <200705060411.49303.groups@berebel.com>
	<200705060613.28752.groups@berebel.com>
Message-ID: <463D40E2.2020607@lwfinger.net>

Denis V Seleznyov wrote:
> On Sunday, 06 May 2007 04:11:49 Denis V Seleznyov wrote:
>> Ehud Gavron wrote:
>>> The bcm43xx modules reports associated... scanning... associated... with
>>> another message in the middle, about once every half second without
>>> stopping.
>>> The dmesg shows radio on, link not ready, link associated, radio off,
>>> [repeats]
>> I have similar problem with 4311 (Dell Inspiron 640m with 1390
>> mini-wireless module). I didn't noticed neither any problems with kernel
>> module inserting or removing, nor kernel panic.
> 
>> Network authentication: WPA-PSK with TKIP encryption
> 
> I don't know how it did happen, but CONFIG_IEEE80211_CRYPT_TKIP was not set.
> 
> Thus, it is bug in wpa_supplicant or softmac code rather then in bcm43xx.

This is an operator problem, not a bug. Neither the bcm43xx nor the softmac code has any way to know 
that you wish to use TKIP authentication.

Larry


From mb at bu3sch.de  Sun May  6 11:41:18 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 6 May 2007 11:41:18 +0200
Subject: Merging SSB upstream
In-Reply-To: <463D4770.9060903@garzik.org>
References: <200705060303.17594.mb@bu3sch.de> <463D4770.9060903@garzik.org>
Message-ID: <200705061141.18560.mb@bu3sch.de>

On Sunday 06 May 2007 05:11:44 Jeff Garzik wrote:
> Michael Buesch wrote:
> > So, now that mac80211 is merged upstream, I think it's
> > time to merge SSB and the b44-ssb port upstream.
> > Note that bcm43xx-mac80211 is _not_ ready for upstream, yet.
> > 
> > What do you think? I'd like to merge ssb as-is, although
> > the embedded-device parts are not quite finished, yet.
> > But they don't interfere with the non-embedded parts used
> > by b44 and the bcm43xx PCI cards.
> > So we _could_ remove the ssb-mips code, but I don't like to
> > do that for better maintainability. It doesn't hurt anyone IMO.
> 
> What does Ralf (MIPS maintainer) and Gary (Broadcom maintainer) think?

I don't know. I wanted to get all these opinions with this mail. :)

> For my part, I'm not going to render even a tentative opinion without a 
> link to actual code.

All code is in wireless tree drivers/ssb
http://bu3sch.de/gitweb?p=wireless-dev.git;a=tree;f=drivers/ssb;h=681cd93bf166670efbdec471b78137d3d0f26537;hb=HEAD

-- 
Greetings Michael.


From mb at bu3sch.de  Sun May  6 11:44:27 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 6 May 2007 11:44:27 +0200
Subject: Merging SSB upstream
In-Reply-To: <20070506020051.GA30917@tuxdriver.com>
References: <200705060303.17594.mb@bu3sch.de>
	<20070506020051.GA30917@tuxdriver.com>
Message-ID: <200705061144.27817.mb@bu3sch.de>

On Sunday 06 May 2007 04:00:51 John W. Linville wrote:
> On Sun, May 06, 2007 at 03:03:17AM +0200, Michael Buesch wrote:
> > So, now that mac80211 is merged upstream, I think it's
> > time to merge SSB and the b44-ssb port upstream.
> > Note that bcm43xx-mac80211 is _not_ ready for upstream, yet.
>  
> ACK, unfortunately.
> 
> > What do you think? I'd like to merge ssb as-is, although
> > the embedded-device parts are not quite finished, yet.
> > But they don't interfere with the non-embedded parts used
> > by b44 and the bcm43xx PCI cards.
> 
> How much testing have you (and others) done w/ b44?

Well, it works for me with my b44 card I got from broadcom.
There are really only 2 or 3 different b44 cards, so chances are damn
high it will work for all.

> I had to remove 
> the b44 ssb changes from fedora because a) users reported problems;

Which problems were that? The 2 compile issues?
Trivial to fix if that's the only issue. ;)

-- 
Greetings Michael.


From joerg at alea.gnuu.de  Sun May  6 14:52:18 2007
From: joerg at alea.gnuu.de (=?UTF-8?Q?J=C3=B6rg?= Sommer)
Date: Sun, 6 May 2007 12:52:18 +0000 (UTC)
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops
	-	SOLVED
References: <200705060411.49303.groups@berebel.com>
	<200705060613.28752.groups@berebel.com> <463D40E2.2020607@lwfinger.net>
Message-ID: <slrnf3rjs2.bck.joerg@alea.gnuu.de>

Hallo Larry,

Larry Finger <larry.finger at lwfinger.net> wrote:
> Denis V Seleznyov wrote:
>> On Sunday, 06 May 2007 04:11:49 Denis V Seleznyov wrote:
>>> Ehud Gavron wrote:
>>>> The bcm43xx modules reports associated... scanning... associated... with
>>>> another message in the middle, about once every half second without
>>>> stopping.
>>>> The dmesg shows radio on, link not ready, link associated, radio off,
>>>> [repeats]
>>> I have similar problem with 4311 (Dell Inspiron 640m with 1390
>>> mini-wireless module). I didn't noticed neither any problems with kernel
>>> module inserting or removing, nor kernel panic.
>> 
>>> Network authentication: WPA-PSK with TKIP encryption
>> 
>> I don't know how it did happen, but CONFIG_IEEE80211_CRYPT_TKIP was not set.
>> 
>> Thus, it is bug in wpa_supplicant or softmac code rather then in bcm43xx.
>
> This is an operator problem, not a bug. Neither the bcm43xx nor the
> softmac code has any way to know that you wish to use TKIP
> authentication.

Doesn't wpa_supplicant tell softmac it wants TKIP? Then softmac can
report it doesn't support TKIP.

Bye, J?rg.
-- 
Damit das M?gliche entsteht, mu? immer wieder das Unm?gliche versucht
werden.                                       (Hermann Hesse)


From linville at tuxdriver.com  Sun May  6 19:38:33 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Sun, 6 May 2007 13:38:33 -0400
Subject: Merging SSB upstream
In-Reply-To: <200705061144.27817.mb@bu3sch.de>
References: <200705060303.17594.mb@bu3sch.de>
	<20070506020051.GA30917@tuxdriver.com>
	<200705061144.27817.mb@bu3sch.de>
Message-ID: <20070506173833.GA4717@tuxdriver.com>

On Sun, May 06, 2007 at 11:44:27AM +0200, Michael Buesch wrote:
> On Sunday 06 May 2007 04:00:51 John W. Linville wrote:

> > I had to remove 
> > the b44 ssb changes from fedora because a) users reported problems;
> 
> Which problems were that? The 2 compile issues?
> Trivial to fix if that's the only issue. ;)

I knew you would ask that... :-)

I don't think there was a bugzilla, but Dave Jones forwarded an email
to me from "MASAO TAKAHASHI" in late February.  Takahashi-san (forgive
me if I did that wrong) was complaining about tx timeouts after I
had added the full wireless-dev patchset to rawhide.  Removing the
b44 bits of the patch seemed to remove the problem.

That's all the info I have.  Perhaps Dave or Takahashi-san can add
to the description?

John
-- 
John W. Linville
linville at tuxdriver.com


From mb at bu3sch.de  Sun May  6 20:44:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 6 May 2007 20:44:51 +0200
Subject: Merging SSB upstream
In-Reply-To: <20070506173833.GA4717@tuxdriver.com>
References: <200705060303.17594.mb@bu3sch.de> <200705061144.27817.mb@bu3sch.de>
	<20070506173833.GA4717@tuxdriver.com>
Message-ID: <200705062044.52408.mb@bu3sch.de>

On Sunday 06 May 2007 19:38:33 John W. Linville wrote:
> On Sun, May 06, 2007 at 11:44:27AM +0200, Michael Buesch wrote:
> > On Sunday 06 May 2007 04:00:51 John W. Linville wrote:
> 
> > > I had to remove 
> > > the b44 ssb changes from fedora because a) users reported problems;
> > 
> > Which problems were that? The 2 compile issues?
> > Trivial to fix if that's the only issue. ;)
> 
> I knew you would ask that... :-)

:P

> I don't think there was a bugzilla, but Dave Jones forwarded an email
> to me from "MASAO TAKAHASHI" in late February.  Takahashi-san (forgive
> me if I did that wrong) was complaining about tx timeouts after I
> had added the full wireless-dev patchset to rawhide.  Removing the
> b44 bits of the patch seemed to remove the problem.
> 
> That's all the info I have.  Perhaps Dave or Takahashi-san can add
> to the description?

Hm, interesting issue.
But I'm not convinced that it's caused by the SSB port, though.
What the SSB port essentially does is modifying small areas in the
init and exit paths. The modified things in the TX and RX hotpaths
are really tiny and trivial. TX timeout sounds like something in the
TX/RX paths is going wrong.
But anyway, maybe I got something wrong.
I'll run some burn-in tests on it now.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sun May  6 23:54:45 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 06 May 2007 16:54:45 -0500
Subject: bcm43xx with 2.6.21 vanilla and larry's combined patch loops
	-	SOLVED
In-Reply-To: <slrnf3rjs2.bck.joerg@alea.gnuu.de>
References: <200705060411.49303.groups@berebel.com>	<200705060613.28752.groups@berebel.com>
	<463D40E2.2020607@lwfinger.net> <slrnf3rjs2.bck.joerg@alea.gnuu.de>
Message-ID: <463E4EA5.4060107@lwfinger.net>

J?rg Sommer wrote:
> Hallo Larry,
> 
> Larry Finger <larry.finger at lwfinger.net> wrote:
>> Denis V Seleznyov wrote:
>>> On Sunday, 06 May 2007 04:11:49 Denis V Seleznyov wrote:
>>>> Ehud Gavron wrote:
>>>>> The bcm43xx modules reports associated... scanning... associated... with
>>>>> another message in the middle, about once every half second without
>>>>> stopping.
>>>>> The dmesg shows radio on, link not ready, link associated, radio off,
>>>>> [repeats]
>>>> I have similar problem with 4311 (Dell Inspiron 640m with 1390
>>>> mini-wireless module). I didn't noticed neither any problems with kernel
>>>> module inserting or removing, nor kernel panic.
>>>> Network authentication: WPA-PSK with TKIP encryption
>>> I don't know how it did happen, but CONFIG_IEEE80211_CRYPT_TKIP was not set.
>>>
>>> Thus, it is bug in wpa_supplicant or softmac code rather then in bcm43xx.
>> This is an operator problem, not a bug. Neither the bcm43xx nor the
>> softmac code has any way to know that you wish to use TKIP
>> authentication.
> 
> Doesn't wpa_supplicant tell softmac it wants TKIP? Then softmac can
> report it doesn't support TKIP.

It isn't softmac, it is ieee80211. The following messages were the error indicating that the TKIP 
modules was not available.:

ioctl[SIOCSIWENCODEEXT]: Invalid argument
Driver did not support SIOCSIWENCODEEXT
WPA: Failed to set PTK to the driver.

If you think the error message should be stronger, talk to the Intel guys as they are the 
maintainers of the ieee80211 component.

Larry



From mb at bu3sch.de  Mon May  7 22:35:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 7 May 2007 22:35:58 +0200
Subject: Merging SSB upstream
In-Reply-To: <1178556198.8350.2.camel@dhcp-10-12-136-115.broadcom.com>
References: <200705060303.17594.mb@bu3sch.de> <463D4770.9060903@garzik.org>
	<1178556198.8350.2.camel@dhcp-10-12-136-115.broadcom.com>
Message-ID: <200705072235.58587.mb@bu3sch.de>

On Monday 07 May 2007 18:43:18 Gary Zambrano wrote:
> On Sat, 2007-05-05 at 23:11 -0400, Jeff Garzik wrote:
> > Michael Buesch wrote:
> > > So, now that mac80211 is merged upstream, I think it's
> > > time to merge SSB and the b44-ssb port upstream.
> > > Note that bcm43xx-mac80211 is _not_ ready for upstream, yet.
> > > 
> > > What do you think? I'd like to merge ssb as-is, although
> > > the embedded-device parts are not quite finished, yet.
> > > But they don't interfere with the non-embedded parts used
> > > by b44 and the bcm43xx PCI cards.
> > > So we _could_ remove the ssb-mips code, but I don't like to
> > > do that for better maintainability. It doesn't hurt anyone IMO.
> > 
> > What does Ralf (MIPS maintainer) and Gary (Broadcom maintainer) think?
> > 
> > For my part, I'm not going to render even a tentative opinion without a 
> > link to actual code.
> > 
> > Last I saw of the code, and descriptions in IRC, it sounded sane.
> > 
> > 	Jeff
> > 
> 
> I would like to put some test mileage behind the ssb.
> We had a hard time testing it a while back, so we will try the latest.

Ok, nice to hear. :)
I stresstested latest ssb on my b44 card and it works fine here.
No TX timeouts or something.

-- 
Greetings Michael.


From zero at purdue.edu  Mon May  7 22:17:14 2007
From: zero at purdue.edu (Jacob)
Date: Mon, 07 May 2007 16:17:14 -0400
Subject: bcm43xx using 4311 wireless
Message-ID: <463F894A.5040007@purdue.edu>

Well with the release of the 21 kernel my 4311 will finally connect and 
stay connected to various wireless networks.  Some issues with hidded 
SSIDs.  The WEP seems to work just fine in wpa_supplicant using 
ap_scan=2 but for some reason it doesnt work quite right for wpa 
enterprise.  I first have to use ap_scan=2 which will not connect but 
then if I change to ap_scan=1 and do it it works.  But it seems that I 
must at least run it with 2 before I can connect with 1.

Thanks
Jake


From gavron at Wetwork.Net  Tue May  8 04:04:50 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Mon, 07 May 2007 19:04:50 -0700
Subject: 2.6.21.1 works with ifconfig; fails with ifup
Message-ID: <463FDAC2.7070506@Wetwork.Net>

2.6.21.1 ifup eth1 panics and is repeatable.

Unfortunately I can't get netconsole working because the 2.6.21.1 kernel 
doesn't like my hardwired Ethernet card for no good reason.  TXcount 
increases, RXcount does not.  tcpdump shows nothing.  Rebooting in 
2.6.20-1.2948.fc6 restores full functionality.


FYI I'm running 2.6.21.1 without the latest "complete" patch. 


If I do the following it works flawlessly:
ifconfig eth1 up
iwconfig eth1 key wep-key-here
iwconfig eth1 essid any   (or "real-essid-here")
ifconfig eth1 10.1.1.5 netmask 255.255.255.0
route add -net 0.0.0.0/0 gw 10.1.1.1


If I do the following I get a kernel panic:
ifup eth1

[root at egdell ~]# more /etc/sysconfig/network-scripts/ifcfg-eth1
# Broadcom Corporation BCM4306 802.11b/g Wireless LAN Controller
TYPE=wireless
DEVICE=eth1
ONBOOT=no
BOOTPROTO=static
ADDRESS=10.1.1.5
NETMASK=255.255.255.255
GATEWAY=10.1.1.1
ESSID=wetwork
KEY=xxxa0055ae775e80fd864exxxx
#RATE=24
#CHANNEL=6


While I can't use netconsole, I can use strace.  Accordingly attached is 
the output from
strace ifup eth1 > nothing.txt 2>output.txt

If anyone has any ideas what's wrong with the wired ethernet...
09:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5752 
Gigabit Ethernet PCI Express (rev 02)

If I don't get any better suggestions I'll remake oldconfig but answer N 
to all the new stuff and see if that makes a difference.  There are a 
couple of new GE drivers, some experimental, and I'm guessing (with no 
basis for the guess) that there may be interference there.

Cheers

Ehud

-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: output.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070507/f262ac59/attachment.txt>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070507/f262ac59/attachment.bin>

From rjw at sisk.pl  Tue May  8 11:40:13 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Tue, 8 May 2007 11:40:13 +0200
Subject: How to prevent bcm43xx from switching bit rate
Message-ID: <200705081140.13455.rjw@sisk.pl>

Hi,

Is there any way to force bcm43xx to use specific bit rate (eg. 11 M)?

On my box it tends to automatically switch to 24 M, even if I do

# iwconfig eth1 rate 11M fixed

Greetings,
Rafael


From larry.finger at lwfinger.net  Wed May  9 07:35:09 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 09 May 2007 00:35:09 -0500
Subject: How to prevent bcm43xx from switching bit rate
In-Reply-To: <200705081140.13455.rjw@sisk.pl>
References: <200705081140.13455.rjw@sisk.pl>
Message-ID: <46415D8D.1030005@lwfinger.net>

Rafael J. Wysocki wrote:
> Hi,
> 
> Is there any way to force bcm43xx to use specific bit rate (eg. 11 M)?
> 
> On my box it tends to automatically switch to 24 M, even if I do
> 
> # iwconfig eth1 rate 11M fixed

If you use git, reverting commit bb52a653eaef4aee877b2fa36de8699926f788bd will make your interface 
always use 11 Mbs. In case you don't use git, this patch was the following:

diff --git a/net/ieee80211/softmac/ieee80211softmac_module.c 
b/net/ieee80211/softmac/ieee80211softmac_module.c
index 256207b..770a068 100644
--- a/net/ieee80211/softmac/ieee80211softmac_module.c
+++ b/net/ieee80211/softmac/ieee80211softmac_module.c
@@ -265,17 +265,10 @@ void ieee80211softmac_init_bss(struct ieee80211softmac_device *mac)
         /* Change the default txrate to the highest possible value.
          * The txrate machine will lower it, if it is too high.
          */
-       /* FIXME: We don't correctly handle backing down to lower
-          rates, so 801.11g devices start off at 11M for now. People
-          can manually change it if they really need to, but 11M is
-          more reliable. Note similar logic in
-          ieee80211softmac_wx_set_rate() */
-       if (ieee->modulation & IEEE80211_CCK_MODULATION) {
+       if (ieee->modulation & IEEE80211_OFDM_MODULATION)
+               txrates->user_rate = IEEE80211_OFDM_RATE_24MB;
+       else
                 txrates->user_rate = IEEE80211_CCK_RATE_11MB;
-       } else if (ieee->modulation & IEEE80211_OFDM_MODULATION) {
-               txrates->user_rate = IEEE80211_OFDM_RATE_54MB;
-       } else
-               assert(0);

         txrates->default_rate = IEEE80211_CCK_RATE_1MB;
         change |= IEEE80211SOFTMAC_TXRATECHG_DEFAULT;
diff --git a/net/ieee80211/softmac/ieee80211softmac_wx.c b/net/ieee80211/softmac/ieee80211softmac_wx.c
index fa2f7da..89c83fa 100644
--- a/net/ieee80211/softmac/ieee80211softmac_wx.c
+++ b/net/ieee80211/softmac/ieee80211softmac_wx.c
@@ -177,15 +177,10 @@ ieee80211softmac_wx_set_rate(struct net_device *net_dev,
         int err = -EINVAL;

         if (in_rate == -1) {
-               /* FIXME: We don't correctly handle backing down to lower
-                  rates, so 801.11g devices start off at 11M for now. People
-                  can manually change it if they really need to, but 11M is
-                  more reliable. Note similar logic in
-                  ieee80211softmac_wx_set_rate() */
-               if (ieee->modulation & IEEE80211_CCK_MODULATION)
-                       in_rate = 11000000;
+               if (ieee->modulation & IEEE80211_OFDM_MODULATION)
+                       in_rate = 24000000;
                 else
-                       in_rate = 54000000;
+                       in_rate = 11000000;
         }

         switch (in_rate) {

Larry


From rjw at sisk.pl  Wed May  9 13:24:35 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Wed, 9 May 2007 13:24:35 +0200
Subject: How to prevent bcm43xx from switching bit rate
In-Reply-To: <46415D8D.1030005@lwfinger.net>
References: <200705081140.13455.rjw@sisk.pl> <46415D8D.1030005@lwfinger.net>
Message-ID: <200705091324.35690.rjw@sisk.pl>

On Wednesday, 9 May 2007 07:35, Larry Finger wrote:
> Rafael J. Wysocki wrote:
> > Hi,
> > 
> > Is there any way to force bcm43xx to use specific bit rate (eg. 11 M)?
> > 
> > On my box it tends to automatically switch to 24 M, even if I do
> > 
> > # iwconfig eth1 rate 11M fixed
> 
> If you use git, reverting commit bb52a653eaef4aee877b2fa36de8699926f788bd will make your interface 
> always use 11 Mbs. In case you don't use git, this patch was the following:

Thanks, but I generally use 24 M.  It only doesn't work well with *some* access
points in which cases I use the above command to set 11 M bit rate.  Still, the
card/driver switches back to 24 M after some time and I have to repeat it,
which is sort of tedious.  I thought it would be possible to get rid of this
without patching the kernel. ;-)

Greetings,
Rafael


From zajec5polish at gmail.com  Wed May  9 16:04:13 2007
From: zajec5polish at gmail.com (=?UTF-8?Q?Rafa=C5=82_Mi=C5=82ecki?=)
Date: Wed, 9 May 2007 16:04:13 +0200
Subject: Problem with connecting in some place
Message-ID: <14b026160705090704w497bab4bybd0d7f3b891c162d@mail.gmail.com>

Linux acer 2.6.21-104-default #1 SMP Mon May 7 15:08:57 UTC 2007 i686
athlon i386 GNU/Linux

06:05.0 Network controller: Broadcom Corporation BCM4318 [AirForce One
54g] 802.11g Wireless LAN Controller (rev 02)
        Subsystem: AMBIT Microsystem Corp. Aspire 3022WLMi, 5024WLMi
        Flags: bus master, fast devsel, latency 64, IRQ 21
        Memory at c0204000 (32-bit, non-prefetchable) [size=8K]


I don't have a lot problem with bcm43xx. I am able to connect with
router in my house and in my friend's house. We both have Linksys
routers.

Unfortunately I have problems with connecting do WiFi in my school.
There are a lot of AccessPoints for only 2 networks and there are a
lot of ppl connected to these two networks. I try to connect to
"PUT-student-WiFi" but I can not. This is a network with access base
on WPA+TKIP+cert file

I made a logs of /var/log/messages of two tries of connecting. I hope
it includes some usefull informations so you could manage with this my
problem. Is there something you could do with these infos? Or is there
something more I can do?


-- 
Rafa? Mi?ecki
-------------- next part --------------
A non-text attachment was scrubbed...
Name: bcm1.log
Type: application/octet-stream
Size: 21659 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070509/4fc40763/attachment.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: bcm2.log
Type: application/octet-stream
Size: 15905 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070509/4fc40763/attachment-0001.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: iwlist.log
Type: application/octet-stream
Size: 4275 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070509/4fc40763/attachment-0002.obj>

From johannes at sipsolutions.net  Wed May  9 16:24:13 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 09 May 2007 16:24:13 +0200
Subject: How to prevent bcm43xx from switching bit rate
In-Reply-To: <200705081140.13455.rjw@sisk.pl>
References: <200705081140.13455.rjw@sisk.pl>
Message-ID: <1178720653.3806.11.camel@johannes.berg>

Hi Rafael,

> On my box it tends to automatically switch to 24 M, even if I do
> 
> # iwconfig eth1 rate 11M fixed

That's strange. softmac ought to start at 24M now, and it ignores the
fixed flag since it always uses a fixed bitrate. Did this change some
time? Actually, it may automatically reset the bitrate when you
associate to a new network, and I don't think you can stop it from doing
that right now, precisely because it ignores the fixed flag.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070509/e59d6b97/attachment.pgp>

From larry.finger at lwfinger.net  Wed May  9 16:35:16 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 09 May 2007 09:35:16 -0500
Subject: How to prevent bcm43xx from switching bit rate
In-Reply-To: <200705091324.35690.rjw@sisk.pl>
References: <200705081140.13455.rjw@sisk.pl> <46415D8D.1030005@lwfinger.net>
	<200705091324.35690.rjw@sisk.pl>
Message-ID: <4641DC24.40104@lwfinger.net>

Rafael J. Wysocki wrote:
> On Wednesday, 9 May 2007 07:35, Larry Finger wrote:
>> Rafael J. Wysocki wrote:
>>> Hi,
>>>
>>> Is there any way to force bcm43xx to use specific bit rate (eg. 11 M)?
>>>
>>> On my box it tends to automatically switch to 24 M, even if I do
>>>
>>> # iwconfig eth1 rate 11M fixed
>> If you use git, reverting commit bb52a653eaef4aee877b2fa36de8699926f788bd will make your interface 
>> always use 11 Mbs. In case you don't use git, this patch was the following:
> 
> Thanks, but I generally use 24 M.  It only doesn't work well with *some* access
> points in which cases I use the above command to set 11 M bit rate.  Still, the
> card/driver switches back to 24 M after some time and I have to repeat it,
> which is sort of tedious.  I thought it would be possible to get rid of this
> without patching the kernel. ;-)

When the system reinitializes is when the rate is set back to 24M. That will be prevented _ONLY_ by 
patching. SoftMAC has no automatic rate adjustment.

Larry


From larry.finger at lwfinger.net  Wed May  9 17:11:54 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 09 May 2007 10:11:54 -0500
Subject: Problem with connecting in some place
In-Reply-To: <14b026160705090704w497bab4bybd0d7f3b891c162d@mail.gmail.com>
References: <14b026160705090704w497bab4bybd0d7f3b891c162d@mail.gmail.com>
Message-ID: <4641E4BA.30200@lwfinger.net>

Rafa? Mi?ecki wrote:
> Linux acer 2.6.21-104-default #1 SMP Mon May 7 15:08:57 UTC 2007 i686
> athlon i386 GNU/Linux
> 
> 06:05.0 Network controller: Broadcom Corporation BCM4318 [AirForce One
> 54g] 802.11g Wireless LAN Controller (rev 02)
>        Subsystem: AMBIT Microsystem Corp. Aspire 3022WLMi, 5024WLMi
>        Flags: bus master, fast devsel, latency 64, IRQ 21
>        Memory at c0204000 (32-bit, non-prefetchable) [size=8K]
> 
> 
> I don't have a lot problem with bcm43xx. I am able to connect with
> router in my house and in my friend's house. We both have Linksys
> routers.
> 
> Unfortunately I have problems with connecting do WiFi in my school.
> There are a lot of AccessPoints for only 2 networks and there are a
> lot of ppl connected to these two networks. I try to connect to
> "PUT-student-WiFi" but I can not. This is a network with access base
> on WPA+TKIP+cert file
> 
> I made a logs of /var/log/messages of two tries of connecting. I hope
> it includes some usefull informations so you could manage with this my
> problem. Is there something you could do with these infos? Or is there
> something more I can do?

There are some problems with bcm43xx in a crowded environment; however, I think your problems are 
with signal strength. The iwconfig log shows only very low signal levels. I see that you are using 
2.6.21. Have you patched bcm43xx? If not, that will help some. In addition, your school has designed 
your networks badly. Channels 9 and 13 interfere with each other. If they are going to put all their 
AP's on only 2 channels, they should use 8 and 13.

Larry




From rjw at sisk.pl  Wed May  9 19:02:11 2007
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Wed, 9 May 2007 19:02:11 +0200
Subject: How to prevent bcm43xx from switching bit rate
In-Reply-To: <1178720653.3806.11.camel@johannes.berg>
References: <200705081140.13455.rjw@sisk.pl>
	<1178720653.3806.11.camel@johannes.berg>
Message-ID: <200705091902.12173.rjw@sisk.pl>

On Wednesday, 9 May 2007 16:24, Johannes Berg wrote:
> Hi Rafael,
> 
> > On my box it tends to automatically switch to 24 M, even if I do
> > 

(*)
> > # iwconfig eth1 rate 11M fixed
> 
> That's strange. softmac ought to start at 24M now, and it ignores the
> fixed flag since it always uses a fixed bitrate. Did this change some
> time? Actually, it may automatically reset the bitrate when you
> associate to a new network, and I don't think you can stop it from doing
> that right now, precisely because it ignores the fixed flag.

Well, it works like this:

- I associate with an AP at 11 M
- After some time, the bit rate changes to 24 M
- So I use (*) to set it back to 11 M (and iwconfig prints 11 M pronto)
- After some time, the bit rate changes to 24 M
- etc.

This is all the same AP all the time.

Greetings,
Rafael


From larry.finger at lwfinger.net  Thu May 10 16:56:19 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 10 May 2007 09:56:19 -0500
Subject: [PATCH V3] mac80211: Add support for SIOCGIWRATE ioctl to provide
	rate information
In-Reply-To: <200705100016.45876.flamingice@sourmilk.net>
References: <463a8a92.jFmmjY4cDnfJeisJ%Larry.Finger@lwfinger.net>
	<200705100016.45876.flamingice@sourmilk.net>
Message-ID: <46433293.9010002@lwfinger.net>

Michael Wu wrote:
> On Thursday 03 May 2007 21:21, Larry Finger wrote:
>> +static int ieee80211_ioctl_giwrate(struct net_device *dev,
>> +				  struct iw_request_info *info,
>> +				  struct iw_param *rate, char *extra)
>> +{
>> +	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
>> +	struct sta_info * sta;
>> +	struct ieee80211_sub_if_data * sdata;
> Eliminate the spaces between * and the variable name.
> 
>> +
>> +	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
>> +	if (sdata->type == IEEE80211_IF_TYPE_STA ||
>> +	    sdata->type == IEEE80211_IF_TYPE_IBSS)
>> +		sta = sta_info_get(local, sdata->u.sta.bssid);
>> +	else
>> +		return -EOPNOTSUPP;
>> +	if (!sta)
>> +		return -ENODEV;
>> +	rate->value = local->oper_hw_mode->rates[sta->txrate].rate * 100000;
> The index from sta->txrate needs to be checked to make sure it is less than 
> mode->num_rates.
> 
> Also, this function is safe in adhoc mode.. but it most likely won't do 
> anything useful since all the sta entries have different addresses and it is 
> likely that none of them are the same as the one in sdata->u.sta.bssid.

Why has the review of this patch been so strung out? Everything you comment on here was in versions 
1 & 2, but not mentioned in any review of those versions.

As to the usefulness of this function, I am testing in infrastructure, not ad-hoc, mode, and the 
output matches the average rate in the log files if debugging is enabled. If the address in 
u.sta.bssid is not correct, which address should I be using? I still maintain that the user is 
entitled to know the transmission rate from user space even if debugging is turned off, and that 
this function is needed.

Larry


From mb at bu3sch.de  Fri May 11 12:24:33 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 11 May 2007 12:24:33 +0200
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <20070423203041.46c8e454@localhost>
References: <20070423202530.2829f309@localhost>
	<20070423203041.46c8e454@localhost>
Message-ID: <200705111224.33898.mb@bu3sch.de>

On Monday 23 April 2007 20:30:41 Stefano Brivio wrote:
> This patch fixes A/G PHYs setup and initialization routines. Let's move
> the so-called workarounds in a separate file, in order to avoid clobbering
> bcm43xx_phy.c.

Here's a re-diffed version of this patch against current tree.
I also fixed some bugs and did some cleanup.
But it still horribly breaks transmission, when applied.

> TODO: check this diff:
> http://bcm-v4.sipsolutions.net/802.11/PHY/G/workarounds/alt_AGC?action=diff&rev2=4&rev1=3

This is not addressed, yet.





Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c	2007-05-11 12:19:55.000000000 +0200
@@ -0,0 +1,649 @@
+/*
+
+  Broadcom BCM43xx wireless driver
+
+  PHY workarounds.
+
+  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
+  Copyright (c) 2005-2007 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de>
+  Copyright (c) 2005, 2006 Danny van Dyk <kugelfang at gentoo.org>
+  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+
+*/
+
+#include "bcm43xx.h"
+#include "bcm43xx_main.h"
+#include "bcm43xx_tables.h"
+#include "bcm43xx_phy.h"
+#include "bcm43xx_wa.h"
+
+static void bcm43xx_wa_papd(struct bcm43xx_wldev *dev)
+{
+	u16 backup;
+
+	backup = bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0, 7);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_APHY, 0, 0);
+	bcm43xx_dummy_transmission(dev);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0, backup);
+}
+
+static void bcm43xx_wa_auxclipthr(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E), 0x3800);
+}
+
+static void bcm43xx_wa_afcdac(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x0035, 0x03FF);
+	bcm43xx_phy_write(dev, 0x0036, 0x0400);
+}
+
+static void bcm43xx_wa_txdc_offset(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 0, 0x0051);
+}
+
+void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	bcm43xx_phy_write(dev, BCM43xx_PHY_LNAHPFCTL, 0x1FF9);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+		bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & 0xFF0F);
+	if (phy->rev <= 2)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_LPFGAIN, 0, 0x1FBF);
+	bcm43xx_radio_write16(dev, 0x0002, 0x1FBF);
+
+	bcm43xx_phy_write(dev, 0x0024, 0x4680);
+	bcm43xx_phy_write(dev, 0x0020, 0x0003);
+	bcm43xx_phy_write(dev, 0x001D, 0x0F40);
+	bcm43xx_phy_write(dev, 0x001F, 0x1C00);
+	if (phy->rev <= 3)
+		bcm43xx_phy_write(dev, 0x002A,
+			(bcm43xx_phy_read(dev, 0x002A) & 0x00FF) | 0x0400);
+	else if (phy->rev == 5) {
+		bcm43xx_phy_write(dev, 0x002A,
+			(bcm43xx_phy_read(dev, 0x002A) & 0x00FF) | 0x1A00);
+		bcm43xx_phy_write(dev, 0x00CC, 0x2121);
+	}
+	if (phy->rev >= 3)
+		bcm43xx_phy_write(dev, 0x00BA, 0x3ED5);
+}
+
+static void bcm43xx_wa_divider(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x002B, bcm43xx_phy_read(dev, 0x002B) & ~0x0100);
+	bcm43xx_phy_write(dev, 0x008E, 0x58C1);
+}
+
+static void bcm43xx_wa_gt(struct bcm43xx_wldev *dev) /* Gain table. */
+{
+	if (dev->phy.rev <= 2) {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 0, 15);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 1, 31);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 2, 42);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 3, 48);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 4, 58);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 0, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 1, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 3, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 4, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 5, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 6, 25);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 0, 3);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 1, 3);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 2, 7);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 0, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 1, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 3, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 4, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 5, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 6, 25);
+	}
+}
+
+static void bcm43xx_wa_rssi_lt(struct bcm43xx_wldev *dev) /* RSSI lookup table */
+{
+	int i;
+
+	for (i = 0; i < 8; i++)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_RSSI, i, i + 8);
+	for (i = 8; i < 16; i++)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_RSSI, i, i - 8);
+}
+
+static void bcm43xx_wa_analog(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->rev > 2) {
+		if (phy->type == BCM43xx_PHYTYPE_G)
+				bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, 0x1000);
+		else
+				bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, 0x1808);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 3, 0x1044);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 4, 0x7201);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 6, 0x0040);
+	}
+}
+
+static void bcm43xx_wa_dac(struct bcm43xx_wldev *dev)
+{
+	if (dev->phy.analog == 1)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1,
+			(bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 1) & ~0x0034) | 0x0008);
+	else
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1,
+			(bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 1) & ~0x0078) | 0x0010);
+}
+
+static void bcm43xx_wa_fft(struct bcm43xx_wldev *dev) /* Fine frequency table */
+{
+	int i;
+
+	if (dev->phy.type == BCM43xx_PHYTYPE_A)
+		for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqa[i]);
+	else
+		for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqg[i]);
+}
+
+static void bcm43xx_wa_nft(struct bcm43xx_wldev *dev) /* Noise figure table */
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+	int i;
+
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		if (phy->rev == 2)
+			for (i = 0; i < BCM43xx_TAB_NOISEA2_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea2[i]);
+		else
+			for (i = 0; i < BCM43xx_TAB_NOISEA3_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea3[i]);
+	} else {
+		if (phy->rev == 1)
+			for (i = 0; i < BCM43xx_TAB_NOISEG1_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg1[i]);
+		else
+			for (i = 0; i < BCM43xx_TAB_NOISEG2_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg2[i]);
+	}
+}
+
+static void bcm43xx_wa_rt(struct bcm43xx_wldev *dev) /* Rotor table */
+{
+	int i;
+
+	for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
+		bcm43xx_ofdmtab_write32(dev, BCM43xx_OFDMTAB_ROTOR, i, bcm43xx_tab_rotor[i]);
+}
+
+static void bcm43xx_wa_nst(struct bcm43xx_wldev *dev) /* Noise scale table */
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+	int i;
+
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		if (phy->rev <= 1)
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, 0);
+		else if (phy->rev == 2)
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescalea2[i]);
+		else if (phy->rev == 3)
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescalea3[i]);
+		else
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescaleg3[i]);
+	} else {
+		if (phy->rev >= 6) {
+			if (bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & BCM43xx_PHY_ENCORE_EN)
+				for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+					bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+						i, bcm43xx_tab_noisescaleg3[i]);
+			else
+				for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+					bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+						i, bcm43xx_tab_noisescaleg2[i]);
+		} else {
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescaleg1[i]);
+		}
+	}
+}
+
+static void bcm43xx_wa_art(struct bcm43xx_wldev *dev) /* ADV retard table */
+{
+	int i;
+
+	for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
+			bcm43xx_ofdmtab_write32(dev, BCM43xx_OFDMTAB_ADVRETARD,
+				i, bcm43xx_tab_retard[i]);
+}
+
+static void bcm43xx_wa_txlna_gain(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 13, 0x0000);
+}
+
+static void bcm43xx_wa_crs_reset(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x002C, 0x0064);
+}
+
+static void bcm43xx_wa_2060txlna_gain(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_hf_write(dev, bcm43xx_hf_read(dev) |
+			 BCM43xx_HF_2060W);
+}
+
+static void bcm43xx_wa_lms(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x0055,
+		(bcm43xx_phy_read(dev, 0x0055) & 0xFFC0) | 0x0004);
+}
+
+static void bcm43xx_wa_mixedsignal(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1, 3);
+}
+
+static void bcm43xx_wa_msst(struct bcm43xx_wldev *dev) /* Min sigma square table */
+{
+	int i;
+
+	for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
+		bcm43xx_ofdmtab_write16(dev, 0x5000 /* FIXME */, i,
+					bcm43xx_tab_sigmasqr1[i]);
+}
+
+static void bcm43xx_wa_iqadc(struct bcm43xx_wldev *dev)
+{
+	if (dev->phy.analog == 4)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 0,
+			bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 0) & ~0xF000);
+}
+
+static void bcm43xx_wa_crs_ed(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->rev == 1)
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1, 0x4F19);
+	else if (phy->rev == 2) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1_R1, 0x1861);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES2_R1, 0x0271);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x28),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x28)) | 0x0800);
+	} else {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1_R1, 0x0098);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES2_R1, 0x0070);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xC9), 0x0080);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x28),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x28)) | 0x0800);
+	}
+}
+
+static void bcm43xx_wa_crs_thr(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) & ~0x03C0) | 0xD000);
+}
+
+static void bcm43xx_wa_crs_blank(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x2C), 0x005A);
+}
+
+static void bcm43xx_wa_cck_shiftbits(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS, 0x0026);
+}
+
+static void bcm43xx_wa_wrssi_offset(struct bcm43xx_wldev *dev)
+{
+	int i;
+
+	if (dev->phy.rev == 1)
+		for (i = 0; i < 32; i++)
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_WRSSI_R1,
+						i, 0x0820);
+	else
+		for (i = 4; i < 20; i++)
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_WRSSI,
+						i, 0x0020);
+}
+
+static void bcm43xx_wa_txpuoff_rxpuon(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_0F, 2, 15);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_0F, 3, 20);
+}
+
+static void bcm43xx_wa_altagc(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->rev == 1) {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 0, 254);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 1, 13);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 3, 25);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 0, 0x2710);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 1, 0x9B83);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 2, 0x9B83);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 3, 0x0F8D);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_LMS, 4);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0, 254);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 1, 13);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 3, 25);
+	}
+
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS_WA,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_CCKSHIFTBITS_WA) & ~0xFF00) | 0x5700);
+	bcm43xx_phy_write(dev, 0x001A | BCM43xx_PHYROUTE_OFDM_GPHY,
+		(bcm43xx_phy_read(dev, 0x001A | BCM43xx_PHYROUTE_OFDM_GPHY) & ~0x007F) | 0x000F);
+	bcm43xx_phy_write(dev, 0x001A | BCM43xx_PHYROUTE_OFDM_GPHY,
+		(bcm43xx_phy_read(dev, 0x001A | BCM43xx_PHYROUTE_OFDM_GPHY) & ~0x3F80) | 0x2880);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_ANTWRSETT) & ~0xF000) | 0x7000);
+	bcm43xx_radio_write16(dev, 0x007A,
+		bcm43xx_radio_read16(dev, 0x007A) | 0x0008);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_N1P1GAIN,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_N1P1GAIN) & ~0x000F) | 0x0008);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_P1P2GAIN,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_P1P2GAIN) & ~0x0F00) | 0x0800);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x12),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x12)) & ~0x0F00) | 0x0700);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x10),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x10)) & ~0x0F00) | 0x0100);
+	if (phy->rev == 1)
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x12),
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x12)) & ~0x000F) | 0x0007);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0x00FF) | 0x001C);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0x3F00) | 0x0200);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x96)) & ~0x00FF) | 0x001C);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89)) & ~0x00FF) | 0x0020);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89)) & ~0x3F00) | 0x0200);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82)) & ~0x00FF) | 0x002E);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0xFF00) | 0x1A00);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81)) & ~0x00FF) | 0x0028);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81)) & ~0xFF00) | 0x2C00);
+	/* FIXME: these two writes could be merged, perhaps. */
+	if (phy->rev == 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_PEAK_COUNT, 0x092B);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x001E) | 0x0002);
+	} else {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x001E);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1F), 0x287A);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & ~0x000F) | 0x0004);
+		if (phy->rev >= 6) {
+			bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x22), 0x287A);
+			bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+				(bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & ~0xF000) | 0x3000);
+		}
+	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_DIVSRCHIDX,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_DIVSRCHIDX) & 0x7F7F) | 0x7874);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E) | BCM43xx_PHYROUTE_OFDM_GPHY, 0x1C00);
+	if (phy->rev == 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_DIVSRCHIDX,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_DIVSRCHIDX) & ~0x0F00) | 0x0600);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8B), 0x005E);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_ANTWRSETT) & ~0x00FF) | 0x001E);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8D), 0x0002);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 0, 0);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 1, 7);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 2, 16);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 3, 28);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 0, 0);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 1, 7);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 2, 16);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 3, 28);
+	}
+	if (phy->rev >= 6)
+	{
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x26)) & ~0x0003);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x26)) & ~0x1000);
+	}
+}
+
+static void bcm43xx_wa_tr_ltov(struct bcm43xx_wldev *dev) /* TR Lookup Table Original Values */
+{
+	bcm43xx_gtab_write(dev, BCM43xx_GTAB_ORIGTR, 0, 0xC480);
+}
+
+static void bcm43xx_wa_cpll_nonpilot(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_11, 0, 0);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_11, 1, 0);
+}
+
+static void bcm43xx_wa_rssi_adc(struct bcm43xx_wldev *dev)
+{
+	if (dev->phy.analog == 4)
+		bcm43xx_phy_write(dev, 0x00DC, 0x7454);
+}
+
+static void bcm43xx_wa_boards_a(struct bcm43xx_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+
+	if (bus->board_vendor == SSB_BOARDVENDOR_BCM &&
+	    bus->board_type == SSB_BOARD_BU4306 &&
+	    bus->board_rev < 0x30) {
+		bcm43xx_phy_write(dev, 0x0010, 0xE000);
+		bcm43xx_phy_write(dev, 0x0013, 0x0140);
+		bcm43xx_phy_write(dev, 0x0014, 0x0280);
+	} else {
+		if (bus->board_type == SSB_BOARD_MP4318 &&
+		    bus->board_rev < 0x20) {
+			bcm43xx_phy_write(dev, 0x0013, 0x0210);
+			bcm43xx_phy_write(dev, 0x0014, 0x0840);
+		} else {
+			bcm43xx_phy_write(dev, 0x0013, 0x0140);
+			bcm43xx_phy_write(dev, 0x0014, 0x0280);
+		}
+		if (dev->phy.rev <= 4)
+			bcm43xx_phy_write(dev, 0x0010, 0xE000);
+		else
+			bcm43xx_phy_write(dev, 0x0010, 0x2000);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 1, 0x0039);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_APHY, 7, 0x0040);
+	}
+}
+
+static void bcm43xx_wa_boards_g(struct bcm43xx_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (bus->board_vendor != SSB_BOARDVENDOR_BCM ||//FIXME condition?
+	    bus->board_type != SSB_BOARD_BU4306 ||
+	    bus->board_rev != 0x17) {
+		if (phy->rev < 2) {
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX_R1, 1, 0x0002);
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX_R1, 2, 0x0001);
+		} else {
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 1, 0x0002);
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 2, 0x0001);
+			if (bus->sprom.r1.boardflags_lo & BCM43xx_BFL_EXTLNA &&
+			    phy->rev >= 7) {
+				bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x11),
+					bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x11)) & 0xF7FF);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0020, 0x0001);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0021, 0x0001);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0022, 0x0001);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0023, 0x0000);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0000, 0x0000);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0003, 0x0002);
+			}
+		}
+	}
+	if (bus->sprom.r1.boardflags_lo & BCM43xx_BFL_FEM) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_GTABCTL, 0x3120);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_GTABDATA, 0xC480);
+	}
+}
+
+void bcm43xx_wa_all(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		switch (phy->rev) {
+		case 2:
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_auxclipthr(dev);
+			bcm43xx_wa_afcdac(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_divider(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_fft(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_rt(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_art(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			bcm43xx_wa_crs_reset(dev);
+			bcm43xx_wa_2060txlna_gain(dev);
+			bcm43xx_wa_lms(dev);
+			break;
+		case 3:
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_mixedsignal(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			break;
+		case 5:
+			bcm43xx_wa_iqadc(dev);
+		case 6:
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			break;
+		case 7:
+			bcm43xx_wa_iqadc(dev);
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			bcm43xx_wa_rssi_adc(dev);
+		default:
+			assert(0);
+		}
+		bcm43xx_wa_boards_a(dev);
+	} else { /* No N PHY support so far */
+		switch (phy->rev) {
+		case 1:
+			bcm43xx_wa_crs_ed(dev);
+			bcm43xx_wa_crs_thr(dev);
+			bcm43xx_wa_crs_blank(dev);
+			bcm43xx_wa_cck_shiftbits(dev);
+			bcm43xx_wa_fft(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_rt(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_art(dev);
+			bcm43xx_wa_wrssi_offset(dev);
+			bcm43xx_wa_altagc(dev);
+			break;
+		case 2:
+		case 6:
+		case 7:
+		case 8:
+			bcm43xx_wa_tr_ltov(dev);
+			bcm43xx_wa_crs_ed(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_wrssi_offset(dev);
+			bcm43xx_wa_altagc(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			break;
+		default:
+			assert(0);
+		}
+		bcm43xx_wa_boards_g(dev);
+	}
+
+	bcm43xx_wa_cpll_nonpilot(dev);
+}
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h	2007-05-11 12:15:21.000000000 +0200
@@ -0,0 +1,7 @@
+#ifndef BCM43xx_WA_H_
+#define BCM43xx_WA_H_
+
+void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev);
+void bcm43xx_wa_all(struct bcm43xx_wldev *dev);
+
+#endif /* BCM43xx_WA_H_ */
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c	2007-05-06 12:48:29.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c	2007-05-11 12:16:11.000000000 +0200
@@ -230,7 +230,7 @@ const u16 bcm43xx_tab_noisea2[] = {
 };
 
 const u16 bcm43xx_tab_noisea3[] = {
-	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
+	0x5E5E, 0x5E5E, 0x5E5E, 0x3F48,
 	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
 };
 
@@ -244,6 +244,26 @@ const u16 bcm43xx_tab_noiseg2[] = {
 	0x0000, 0x0000, 0x0000, 0x0000,
 };
 
+const u16 bcm43xx_tab_noisescalea2[] = {
+	0x6767, 0x6767, 0x6767, 0x6767, /* 0 */
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6700, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x6767, 0x6767, /* 16 */
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x0067,
+};
+
+const u16 bcm43xx_tab_noisescalea3[] = {
+	0x2323, 0x2323, 0x2323, 0x2323, /* 0 */
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2300, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x2323, 0x2323, /* 16 */
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x0023,
+};
+
 const u16 bcm43xx_tab_noisescaleg1[] = {
 	0x6C77, 0x5162, 0x3B40, 0x3335, /* 0 */
 	0x2F2D, 0x2A2A, 0x2527, 0x1F21,
@@ -308,6 +328,27 @@ const u16 bcm43xx_tab_sigmasqr2[] = {
 	0x00DE,
 };
 
+const u16 bcm43xx_tab_rssiagc1[] = {
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8, /* 0 */
+	0xFFF8, 0xFFF9, 0xFFFC, 0xFFFE,
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+};
+
+const u16 bcm43xx_tab_rssiagc2[] = {
+	0x0820, 0x0820, 0x0920, 0x0C38, /* 0 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38, /* 16 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38, /* 32 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+};
 
 static inline void assert_sizes(void)
 {
@@ -319,34 +360,54 @@ static inline void assert_sizes(void)
 	BUILD_BUG_ON(BCM43xx_TAB_NOISEA3_SIZE != ARRAY_SIZE(bcm43xx_tab_noisea3));
 	BUILD_BUG_ON(BCM43xx_TAB_NOISEG1_SIZE != ARRAY_SIZE(bcm43xx_tab_noiseg1));
 	BUILD_BUG_ON(BCM43xx_TAB_NOISEG2_SIZE != ARRAY_SIZE(bcm43xx_tab_noiseg2));
-	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg1));
-	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
-	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
+	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg1));
+	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
+	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
 	BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE != ARRAY_SIZE(bcm43xx_tab_sigmasqr1));
 	BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE != ARRAY_SIZE(bcm43xx_tab_sigmasqr2));
+	BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC1_SIZE != ARRAY_SIZE(bcm43xx_tab_rssiagc1));
+	BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC2_SIZE != ARRAY_SIZE(bcm43xx_tab_rssiagc2));
 }
 
 
 u16 bcm43xx_ofdmtab_read16(struct bcm43xx_wldev *dev, u16 table, u16 offset)
 {
+	struct bcm43xx_phy *phy = &dev->phy;
+
 	assert_sizes();
 
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+	if (table + offset - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+		phy->ofdm_valid = 1;
+	}
+	phy->ofdm_addr = table + offset;
+
 	return bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI);
 }
 
 void bcm43xx_ofdmtab_write16(struct bcm43xx_wldev *dev, u16 table,
 			     u16 offset, u16 value)
 {
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (table + offset - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+		phy->ofdm_valid = 2;
+	}
+	phy->ofdm_addr = table + offset;
 	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
 }
 
 u32 bcm43xx_ofdmtab_read32(struct bcm43xx_wldev *dev, u16 table, u16 offset)
 {
+	struct bcm43xx_phy *phy = &dev->phy;
 	u32 ret;
 
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+	if (table + offset - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+		phy->ofdm_valid = 1;
+	}
+	phy->ofdm_addr = table + offset;
 	ret = bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEQ);
 	ret <<= 16;
 	ret |= bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI);
@@ -357,9 +418,15 @@ u32 bcm43xx_ofdmtab_read32(struct bcm43x
 void bcm43xx_ofdmtab_write32(struct bcm43xx_wldev *dev, u16 table,
 			     u16 offset, u32 value)
 {
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (table + offset - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+		phy->ofdm_valid = 2;
+	}
+	phy->ofdm_addr = table + offset;
 	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEQ, (value >> 16));
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
 }
 
 u16 bcm43xx_gtab_read(struct bcm43xx_wldev *dev, u16 table, u16 offset)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h	2007-05-06 13:08:23.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h	2007-05-11 12:15:21.000000000 +0200
@@ -591,6 +591,10 @@ struct bcm43xx_phy {
 	u16 lofcal;
 
 	u16 initval;//FIXME rename?
+
+	/* OFDM address read/write caching for hardware auto-increment. */
+	u16 ofdm_addr;
+	u8 ofdm_valid; /* 0: invalid, 1: read, 2: write */
 };
 
 /* Data structures for DMA transmission, per 80211 core. */
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c	2007-05-06 13:08:23.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c	2007-05-11 12:15:22.000000000 +0200
@@ -3127,6 +3127,9 @@ static void setup_struct_phy_for_init(st
 	spin_lock_init(&phy->lock);
 	phy->interfmode = BCM43xx_INTERFMODE_NONE;
 	phy->channel = 0xFF;
+
+	/* OFDM address caching. */
+	phy->ofdm_valid = 0;
 }
 
 static void setup_struct_wldev_for_init(struct bcm43xx_wldev *dev)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h	2007-05-06 12:48:29.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h	2007-05-11 12:15:22.000000000 +0200
@@ -28,8 +28,11 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_PWRDOWN		BCM43xx_PHY_OFDM(0x03)	/* Powerdown */
 #define BCM43xx_PHY_CRSTHRES1		BCM43xx_PHY_OFDM(0x06)	/* CRS Threshold 1 */
 #define BCM43xx_PHY_LNAHPFCTL		BCM43xx_PHY_OFDM(0x1C)	/* LNA/HPF control */
+#define BCM43xx_PHY_LPFGAINCTL		BCM43xx_PHY_OFDM(0x20)	/* LPF Gain control */
 #define BCM43xx_PHY_ADIVRELATED		BCM43xx_PHY_OFDM(0x27)	/* FIXME rename */
 #define BCM43xx_PHY_CRS0		BCM43xx_PHY_OFDM(0x29)
+#define  BCM43xx_PHY_CRS0_EN		0x4000
+#define BCM43xx_PHY_PEAK_COUNT		BCM43xx_PHY_OFDM(0x30)
 #define BCM43xx_PHY_ANTDWELL		BCM43xx_PHY_OFDM(0x2B)	/* Antenna dwell */
 #define  BCM43xx_PHY_ANTDWELL_AUTODIV1	0x0100			/* Automatic RX diversity start antenna */
 #define BCM43xx_PHY_ENCORE		BCM43xx_PHY_OFDM(0x49)	/* "Encore" (RangeMax / BroadRange) */
@@ -38,6 +41,7 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_OFDM61		BCM43xx_PHY_OFDM(0x61)	/* FIXME rename */
 #define  BCM43xx_PHY_OFDM61_10		0x0010			/* FIXME rename */
 #define BCM43xx_PHY_IQBAL		BCM43xx_PHY_OFDM(0x69)	/* I/Q balance */
+#define BCM43xx_PHY_BBTXDC_BIAS		BCM43xx_PHY_OFDM(0x6B)	/* Baseband TX DC bias */
 #define BCM43xx_PHY_OTABLECTL		BCM43xx_PHY_OFDM(0x72)	/* OFDM table control (see below) */
 #define  BCM43xx_PHY_OTABLEOFF		0x03FF			/* OFDM table offset (see below) */
 #define  BCM43xx_PHY_OTABLENR		0xFC00			/* OFDM table number (see below) */
@@ -45,6 +49,9 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_OTABLEI		BCM43xx_PHY_OFDM(0x73)	/* OFDM table data I */
 #define BCM43xx_PHY_OTABLEQ		BCM43xx_PHY_OFDM(0x74)	/* OFDM table data Q */
 #define BCM43xx_PHY_HPWR_TSSICTL	BCM43xx_PHY_OFDM(0x78)	/* Hardware power TSSI control */
+#define BCM43xx_PHY_ADCCTL		BCM43xx_PHY_OFDM(0x7A)	/* ADC control */
+#define BCM43xx_PHY_IDLE_TSSI		BCM43xx_PHY_OFDM(0x7B)
+#define BCM43xx_PHY_A_TEMP_SENSE	BCM43xx_PHY_OFDM(0x7C)	/* A PHY temperature sense */
 #define BCM43xx_PHY_NRSSITHRES		BCM43xx_PHY_OFDM(0x8A)	/* NRSSI threshold */
 #define BCM43xx_PHY_ANTWRSETT		BCM43xx_PHY_OFDM(0x8C)	/* Antenna WR settle */
 #define  BCM43xx_PHY_ANTWRSETT_ARXDIV	0x2000			/* Automatic RX diversity enabled */
@@ -55,6 +62,8 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_N1N2GAIN		BCM43xx_PHY_OFDM(0xA2)
 #define BCM43xx_PHY_CLIPTHRES		BCM43xx_PHY_OFDM(0xA3)
 #define BCM43xx_PHY_CLIPN1P2THRES	BCM43xx_PHY_OFDM(0xA4)
+#define BCM43xx_PHY_CCKSHIFTBITS_WA	BCM43xx_PHY_OFDM(0xA5)	/* CCK shiftbits workaround, FIXME rename */
+#define BCM43xx_PHY_CCKSHIFTBITS	BCM43xx_PHY_OFDM(0xA7)  /* FIXME rename */
 #define BCM43xx_PHY_DIVSRCHIDX		BCM43xx_PHY_OFDM(0xA8)	/* Divider search gain/index */
 #define BCM43xx_PHY_CLIPP2THRES		BCM43xx_PHY_OFDM(0xA9)
 #define BCM43xx_PHY_CLIPP3THRES		BCM43xx_PHY_OFDM(0xAA)
@@ -128,10 +137,11 @@ struct bcm43xx_wldev;
 #define BCM43xx_OFDMTAB_DC		BCM43xx_OFDMTAB(0x0E, 7)
 #define BCM43xx_OFDMTAB_PWRDYN2		BCM43xx_OFDMTAB(0x0E, 12)
 #define BCM43xx_OFDMTAB_LNAGAIN		BCM43xx_OFDMTAB(0x0E, 13)
-//TODO
+#define BCM43xx_OFDMTAB_UNKNOWN_0F	BCM43xx_OFDMTAB(0x0F, 0)	//TODO rename
+#define BCM43xx_OFDMTAB_UNKNOWN_APHY	BCM43xx_OFDMTAB(0x0F, 7)	//TODO rename
 #define BCM43xx_OFDMTAB_LPFGAIN		BCM43xx_OFDMTAB(0x0F, 12)
 #define BCM43xx_OFDMTAB_RSSI		BCM43xx_OFDMTAB(0x10, 0)
-//TODO
+#define BCM43xx_OFDMTAB_UNKNOWN_11	BCM43xx_OFDMTAB(0x11, 4)	//TODO rename
 #define BCM43xx_OFDMTAB_AGC1_R1		BCM43xx_OFDMTAB(0x13, 0)
 #define BCM43xx_OFDMTAB_GAINX_R1	BCM43xx_OFDMTAB(0x14, 0)	//TODO rename
 #define BCM43xx_OFDMTAB_MINSIGSQ	BCM43xx_OFDMTAB(0x14, 1)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h	2007-05-06 12:48:29.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h	2007-05-11 12:15:22.000000000 +0200
@@ -17,12 +17,18 @@ extern const u16 bcm43xx_tab_noisea3[];
 extern const u16 bcm43xx_tab_noiseg1[];
 #define BCM43xx_TAB_NOISEG2_SIZE	8
 extern const u16 bcm43xx_tab_noiseg2[];
-#define BCM43xx_TAB_NOISESCALEG_SIZE	27
+#define BCM43xx_TAB_NOISESCALE_SIZE	27
+extern const u16 bcm43xx_tab_noisescalea2[];
+extern const u16 bcm43xx_tab_noisescalea3[];
 extern const u16 bcm43xx_tab_noisescaleg1[];
 extern const u16 bcm43xx_tab_noisescaleg2[];
 extern const u16 bcm43xx_tab_noisescaleg3[];
 #define BCM43xx_TAB_SIGMASQR_SIZE	53
 extern const u16 bcm43xx_tab_sigmasqr1[];
 extern const u16 bcm43xx_tab_sigmasqr2[];
+#define BCM43xx_TAB_RSSIAGC1_SIZE	16
+extern const u16 bcm43xx_tab_rssiagc1[];
+#define BCM43xx_TAB_RSSIAGC2_SIZE	48
+extern const u16 bcm43xx_tab_rssiagc2[];
 
 #endif /* BCM43xx_TABLES_H_ */
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c	2007-05-06 12:48:29.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c	2007-05-11 12:15:22.000000000 +0200
@@ -34,6 +34,7 @@
 #include "bcm43xx_tables.h"
 #include "bcm43xx_power.h"
 #include "bcm43xx_lo.h"
+#include "bcm43xx_wa.h"
 
 
 static const s8 bcm43xx_tssi2dbm_b_table[] = {
@@ -559,393 +560,96 @@ static void bcm43xx_phy_init_pctl(struct
 	bcm43xx_shm_clear_tssi(dev);
 }
 
-static void bcm43xx_phy_agcsetup(struct bcm43xx_wldev *dev)
+static void bcm43xx_phy_rssiagc(struct bcm43xx_wldev *dev, u8 enable)
 {
-	struct bcm43xx_phy *phy = &dev->phy;
-	u16 offset = 0x0000;
-
-	if (phy->rev == 1)
-		offset = 0x4C00;
-
-	bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00FE);
-	bcm43xx_ofdmtab_write16(dev, offset, 1, 0x000D);
-	bcm43xx_ofdmtab_write16(dev, offset, 2, 0x0013);
-	bcm43xx_ofdmtab_write16(dev, offset, 3, 0x0019);
-
-	if (phy->rev == 1) {
-		bcm43xx_ofdmtab_write16(dev, 0x1800, 0, 0x2710);
-		bcm43xx_ofdmtab_write16(dev, 0x1801, 0, 0x9B83);
-		bcm43xx_ofdmtab_write16(dev, 0x1802, 0, 0x9B83);
-		bcm43xx_ofdmtab_write16(dev, 0x1803, 0, 0x0F8D);
-		bcm43xx_phy_write(dev, 0x0455, 0x0004);
-	}
-
-	bcm43xx_phy_write(dev, 0x04A5,
-			  (bcm43xx_phy_read(dev, 0x04A5)
-			   & 0x00FF) | 0x5700);
-	bcm43xx_phy_write(dev, 0x041A,
-			  (bcm43xx_phy_read(dev, 0x041A)
-			   & 0xFF80) | 0x000F);
-	bcm43xx_phy_write(dev, 0x041A,
-			  (bcm43xx_phy_read(dev, 0x041A)
-			   & 0xC07F) | 0x2B80);
-	bcm43xx_phy_write(dev, 0x048C,
-			  (bcm43xx_phy_read(dev, 0x048C)
-			   & 0xF0FF) | 0x0300);
-
-	bcm43xx_radio_write16(dev, 0x007A,
-			      bcm43xx_radio_read16(dev, 0x007A)
-			      | 0x0008);
-
-	bcm43xx_phy_write(dev, 0x04A0,
-			  (bcm43xx_phy_read(dev, 0x04A0)
-			   & 0xFFF0) | 0x0008);
-	bcm43xx_phy_write(dev, 0x04A1,
-			  (bcm43xx_phy_read(dev, 0x04A1)
-			   & 0xF0FF) | 0x0600);
-	bcm43xx_phy_write(dev, 0x04A2,
-			  (bcm43xx_phy_read(dev, 0x04A2)
-			   & 0xF0FF) | 0x0700);
-	bcm43xx_phy_write(dev, 0x04A0,
-			  (bcm43xx_phy_read(dev, 0x04A0)
-			   & 0xF0FF) | 0x0100);
-
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(dev, 0x04A2,
-				  (bcm43xx_phy_read(dev, 0x04A2)
-				   & 0xFFF0) | 0x0007);
-	}
-
-	bcm43xx_phy_write(dev, 0x0488,
-			  (bcm43xx_phy_read(dev, 0x0488)
-			   & 0xFF00) | 0x001C);
-	bcm43xx_phy_write(dev, 0x0488,
-			  (bcm43xx_phy_read(dev, 0x0488)
-			   & 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(dev, 0x0496,
-			  (bcm43xx_phy_read(dev, 0x0496)
-			   & 0xFF00) | 0x001C);
-	bcm43xx_phy_write(dev, 0x0489,
-			  (bcm43xx_phy_read(dev, 0x0489)
-			   & 0xFF00) | 0x0020);
-	bcm43xx_phy_write(dev, 0x0489,
-			  (bcm43xx_phy_read(dev, 0x0489)
-			   & 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(dev, 0x0482,
-			  (bcm43xx_phy_read(dev, 0x0482)
-			   & 0xFF00) | 0x002E);
-	bcm43xx_phy_write(dev, 0x0496,
-			  (bcm43xx_phy_read(dev, 0x0496)
-			   & 0x00FF) | 0x1A00);
-	bcm43xx_phy_write(dev, 0x0481,
-			  (bcm43xx_phy_read(dev, 0x0481)
-			   & 0xFF00) | 0x0028);
-	bcm43xx_phy_write(dev, 0x0481,
-			  (bcm43xx_phy_read(dev, 0x0481)
-			   & 0x00FF) | 0x2C00);
-
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(dev, 0x0430, 0x092B);
-		bcm43xx_phy_write(dev, 0x041B,
-				  (bcm43xx_phy_read(dev, 0x041B)
-				   & 0xFFE1) | 0x0002);
-	} else {
-		bcm43xx_phy_write(dev, 0x041B,
-				  bcm43xx_phy_read(dev, 0x041B)
-				  & 0xFFE1);
-		bcm43xx_phy_write(dev, 0x041F, 0x287A);
-		bcm43xx_phy_write(dev, 0x0420,
-				  (bcm43xx_phy_read(dev, 0x0420)
-				   & 0xFFF0) | 0x0004);
-	}
-
-	if (phy->rev >= 6) {
-		bcm43xx_phy_write(dev, 0x0422, 0x287A);
-		bcm43xx_phy_write(dev, 0x0420,
-				  (bcm43xx_phy_read(dev, 0x0420)
-				   & 0x0FFF) | 0x3000);
-	}
-
-	bcm43xx_phy_write(dev, 0x04A8,
-			  (bcm43xx_phy_read(dev, 0x04A8)
-			   & 0x8080) | 0x7874);
-	bcm43xx_phy_write(dev, 0x048E, 0x1C00);
-
-	offset = 0x0800;
-	if (phy->rev == 1) {
-		offset = 0x5400;
-		bcm43xx_phy_write(dev, 0x04AB,
-				  (bcm43xx_phy_read(dev, 0x04AB)
-				   & 0xF0FF) | 0x0600);
-		bcm43xx_phy_write(dev, 0x048B, 0x005E);
-		bcm43xx_phy_write(dev, 0x048C,
-				  (bcm43xx_phy_read(dev, 0x048C)
-				   & 0xFF00) | 0x001E);
-		bcm43xx_phy_write(dev, 0x048D, 0x0002);
-	}
-	bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00);
-	bcm43xx_ofdmtab_write16(dev, offset, 1, 0x07);
-	bcm43xx_ofdmtab_write16(dev, offset, 2, 0x10);
-	bcm43xx_ofdmtab_write16(dev, offset, 3, 0x1C);
-
-	if (phy->rev >= 6) {
-		bcm43xx_phy_write(dev, 0x0426,
-				  bcm43xx_phy_read(dev, 0x0426)
-				  & 0xFFFC);
-		bcm43xx_phy_write(dev, 0x0426,
-				  bcm43xx_phy_read(dev, 0x0426)
-				  & 0xEFFF);
-	}
-}
-
-static void bcm43xx_phy_setupg(struct bcm43xx_wldev *dev)
-{
-	struct ssb_bus *bus = dev->dev->bus;
-	struct bcm43xx_phy *phy = &dev->phy;
-	u16 i;
-
-	assert(phy->type == BCM43xx_PHYTYPE_G);
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(dev, 0x0406, 0x4F19);
-		bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
-				  (bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS) & 0xFC3F) | 0x0340);
-		bcm43xx_phy_write(dev, 0x042C, 0x005A);
-		bcm43xx_phy_write(dev, 0x0427, 0x001A);
-
-		for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5800, i, bcm43xx_tab_finefreqg[i]);
-		for (i = 0; i < BCM43xx_TAB_NOISEG1_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noiseg1[i]);
-		for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x2000, i, bcm43xx_tab_rotor[i]);
-	} else {
-		/* nrssi values are signed 6-bit values. Not sure why we write 0x7654 here... */
-		bcm43xx_nrssi_hw_write(dev, 0xBA98, (s16)0x7654);
-
-		if (phy->rev == 2) {
-			bcm43xx_phy_write(dev, 0x04C0, 0x1861);
-			bcm43xx_phy_write(dev, 0x04C1, 0x0271);
-		} else if (phy->rev > 2) {
-			bcm43xx_phy_write(dev, 0x04C0, 0x0098);
-			bcm43xx_phy_write(dev, 0x04C1, 0x0070);
-			bcm43xx_phy_write(dev, 0x04C9, 0x0080);
-		}
-		bcm43xx_phy_write(dev, 0x042B, bcm43xx_phy_read(dev, 0x042B) | 0x800);
-
-		for (i = 0; i < 64; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x4000, i, i);
-		for (i = 0; i < BCM43xx_TAB_NOISEG2_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noiseg2[i]);
-	}
-
-	if (phy->rev <= 2)
-		for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg1[i]);
-	else if ((phy->rev >= 7) && (bcm43xx_phy_read(dev, 0x0449) & 0x0200))
-		for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg3[i]);
-	else
-		for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg2[i]);
-
-	if (phy->rev == 2)
-		for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5000, i, bcm43xx_tab_sigmasqr1[i]);
-	else if ((phy->rev > 2) && (phy->rev <= 8))
-		for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5000, i, bcm43xx_tab_sigmasqr2[i]);
-
-	if (phy->rev == 1) {
-		for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
-			bcm43xx_ofdmtab_write32(dev, 0x2400, i, bcm43xx_tab_retard[i]);
-		for (i = 0; i < 4; i++) {
-			bcm43xx_ofdmtab_write16(dev, 0x5404, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x5408, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x540C, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x5410, i, 0x0020);
-		}
-		bcm43xx_phy_agcsetup(dev);
-
-		if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-		    (bus->board_type == SSB_BOARD_BU4306) &&
-		    (bus->board_rev == 0x17))
-			return;
-
-		bcm43xx_ofdmtab_write16(dev, 0x5001, 0, 0x0002);
-		bcm43xx_ofdmtab_write16(dev, 0x5002, 0, 0x0001);
-	} else {
-		for (i = 0; i <= 0x2F; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1000, i, 0x0820);
-		bcm43xx_phy_agcsetup(dev);
-		bcm43xx_phy_read(dev, 0x0400); /* dummy read */
-		bcm43xx_phy_write(dev, 0x0403, 0x1000);
-		bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
-
-		if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-		    (bus->board_type == SSB_BOARD_BU4306) &&
-		    (bus->board_rev == 0x17))
-			return;
-
-		bcm43xx_ofdmtab_write16(dev, 0x0401, 0, 0x0002);
-		bcm43xx_ofdmtab_write16(dev, 0x0402, 0, 0x0001);
-	}
-}
-
-/* Initialize the noisescaletable for APHY */
-static void bcm43xx_phy_init_noisescaletbl(struct bcm43xx_wldev *dev)
-{
-	struct bcm43xx_phy *phy = &dev->phy;
 	int i;
 
-	for (i = 0; i < 12; i++) {
-		if (phy->rev == 2)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6767);
+	if (dev->phy.rev < 3) {
+		if (enable)
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_LNAHPFGAIN1, i, 0xFFF8);
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, 0xFFF8);
+			}
 		else
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2323);
-	}
-	if (phy->rev == 2)
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6700);
-	else
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2300);
-	for (i = 0; i < 11; i++) {
-		if (phy->rev == 2)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6767);
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_LNAHPFGAIN1, i, bcm43xx_tab_rssiagc1[i]);
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, bcm43xx_tab_rssiagc1[i]);
+			}
+	} else {
+		if (enable)
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, 0x0820);
 		else
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2323);
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC2_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, bcm43xx_tab_rssiagc2[i]);
 	}
-	if (phy->rev == 2)
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0067);
-	else
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0023);
 }
 
-static void bcm43xx_phy_setupa(struct bcm43xx_wldev *dev)
+static void bcm43xx_phy_ww(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phy *phy = &dev->phy;
-	u16 i;
-
-	assert(phy->type == BCM43xx_PHYTYPE_A);
-	switch (phy->rev) {
-	case 2:
-		bcm43xx_phy_write(dev, 0x008E, 0x3800);
-		bcm43xx_phy_write(dev, 0x0035, 0x03FF);
-		bcm43xx_phy_write(dev, 0x0036, 0x0400);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-		bcm43xx_phy_write(dev, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(dev, 0x0020, bcm43xx_phy_read(dev, 0x0020) & 0xFF0F);
-		bcm43xx_ofdmtab_write16(dev, 0x3C0C, 0, 0x07BF);
-		bcm43xx_radio_write16(dev, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(dev, 0x0024, 0x4680);
-		bcm43xx_phy_write(dev, 0x0020, 0x0003);
-		bcm43xx_phy_write(dev, 0x001D, 0x0F40);
-		bcm43xx_phy_write(dev, 0x001F, 0x1C00);
-
-		bcm43xx_phy_write(dev, 0x002A,
-				  (bcm43xx_phy_read(dev, 0x002A)
-				   & 0x00FF) | 0x0400);
-		bcm43xx_phy_write(dev, 0x002B,
-				  bcm43xx_phy_read(dev, 0x002B)
-				  & 0xFBFF);
-		bcm43xx_phy_write(dev, 0x008E, 0x58C1);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-		bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 1, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 2, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 3, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 4, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 5, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 6, 0x0019);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
-
-		for (i = 0; i < 16; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x4000, i, (0x8 + i) & 0x000F);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3003, 0, 0x1044);
-		bcm43xx_ofdmtab_write16(dev, 0x3004, 0, 0x7201);
-		bcm43xx_ofdmtab_write16(dev, 0x3006, 0, 0x0040);
-		bcm43xx_ofdmtab_write16(dev, 0x3001, 0, (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0x0010) | 0x0008);
-
-		for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5800, i, bcm43xx_tab_finefreqa[i]);
-		for (i = 0; i < BCM43xx_TAB_NOISEA2_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noisea2[i]);
-		for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
-			bcm43xx_ofdmtab_write32(dev, 0x2000, i, bcm43xx_tab_rotor[i]);
-		bcm43xx_phy_init_noisescaletbl(dev);
-		for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
-			bcm43xx_ofdmtab_write32(dev, 0x2400, i, bcm43xx_tab_retard[i]);
-		break;
-	case 3:
-		for (i = 0; i < 64; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x4000, i, i);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-		bcm43xx_phy_write(dev, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(dev, 0x0020,
-				  bcm43xx_phy_read(dev, 0x0020) & 0xFF0F);
-		bcm43xx_radio_write16(dev, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(dev, 0x0024, 0x4680);
-		bcm43xx_phy_write(dev, 0x0020, 0x0003);
-		bcm43xx_phy_write(dev, 0x001D, 0x0F40);
-		bcm43xx_phy_write(dev, 0x001F, 0x1C00);
-		bcm43xx_phy_write(dev, 0x002A,
-				  (bcm43xx_phy_read(dev, 0x002A)
-				   & 0x00FF) | 0x0400);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3000, 1,
-				        (bcm43xx_ofdmtab_read16(dev, 0x3000, 1)
-				        & 0x0010) | 0x0008);
-		for (i = 0; i < BCM43xx_TAB_NOISEA3_SIZE; i++) {
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i,
-						bcm43xx_tab_noisea3[i]);
-		}
-		bcm43xx_phy_init_noisescaletbl(dev);
-		for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++) {
-			bcm43xx_ofdmtab_write16(dev, 0x5000, i,
-						bcm43xx_tab_sigmasqr1[i]);
-		}
-
-		bcm43xx_phy_write(dev, 0x0003, 0x1808);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-		bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0001, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0002, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0003, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0004, 0, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0005, 0, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0006, 0, 0x0019);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
+	u16 b, curr_s, best_s = 0xFFFF;
+	int i;
 
-		bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
-		break;
-	default:
-		assert(0);
-	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+		bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) & ~BCM43xx_PHY_CRS0_EN);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+		bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) | 0x1000);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82)) & 0xF0FF) | 0x0300);
+	bcm43xx_radio_write16(dev, 0x0009,
+		bcm43xx_radio_read16(dev, 0x0009) | 0x0080);
+	bcm43xx_radio_write16(dev, 0x0012,
+		(bcm43xx_radio_read16(dev, 0x0012) & 0xFFFC) | 0x0002);
+	bcm43xx_wa_initgains(dev);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBA), 0x3ED5);
+	b = bcm43xx_phy_read(dev, BCM43xx_PHY_PWRDOWN);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, (b & 0xFFF8) | 0x0005);
+	bcm43xx_radio_write16(dev, 0x0004,
+		bcm43xx_radio_read16(dev, 0x0004) | 0x0004);
+	for (i = 0x10; i <= 0x20; i++) {
+		bcm43xx_radio_write16(dev, 0x0013, i);
+		curr_s = bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEQ) & 0x00FF;
+		if (!curr_s) {
+			best_s = 0x0000;
+			break;
+		} else if (curr_s >= 0x0080)
+			curr_s = 0x0100 - curr_s;
+		if (curr_s < best_s)
+			best_s = curr_s;
+	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, b);
+	bcm43xx_radio_write16(dev, 0x0004,
+		bcm43xx_radio_read16(dev, 0x0004) & 0xFFFB);
+	bcm43xx_radio_write16(dev, 0x0013, best_s);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 0, 0xFFEC);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB7), 0x1E80);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB6), 0x1C00);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB5), 0x0EC0);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB2), 0x00C0);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB9), 0x1FFF);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBB),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0xBB)) & 0xF000) | 0x0053);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM61,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM61 & 0xFE1F)) | 0x0120);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x13),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x13)) & 0x0FFF) | 0x3000);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x14),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x14)) & 0x0FFF) | 0x3000);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 6, 0x0017);
+	for (i = 0; i < 6; i++)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, i, 0x000F);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0D, 0x000E);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0E, 0x0011);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0F, 0x0013);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x33), 0x5030);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+		bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) | BCM43xx_PHY_CRS0_EN);
 }
 
 /* Initialize APHY. This is also called for the GPHY in some cases. */
@@ -953,60 +657,49 @@ static void bcm43xx_phy_inita(struct bcm
 {
 	struct ssb_bus *bus = dev->dev->bus;
 	struct bcm43xx_phy *phy = &dev->phy;
-	u16 tval;
 
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_setupa(dev);
-	} else {
-		bcm43xx_phy_setupg(dev);
-		if (phy->gmode &&
-		    (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_PACTRL))
-			bcm43xx_phy_write(dev, 0x046E, 0x03CF);
-		return;
+	if (phy->rev >= 6) {
+		if (phy->type == BCM43xx_PHYTYPE_A)
+			bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+				bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x1000);
+		if (bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & BCM43xx_PHY_ENCORE_EN)
+			bcm43xx_phy_write(dev, BCM43xx_PHY_ENCORE,
+				bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) | 0x0010);
+		else
+			bcm43xx_phy_write(dev, BCM43xx_PHY_ENCORE,
+				bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & ~0x1010);
 	}
+	bcm43xx_wa_all(dev);
 
-	bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
-	                  (bcm43xx_phy_read(dev, BCM43xx_PHY_A_CRS) & 0xF83C) | 0x0340);
-	bcm43xx_phy_write(dev, 0x0034, 0x0001);
-
-	TODO();//TODO: RSSI AGC
-	bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
-	                  bcm43xx_phy_read(dev, BCM43xx_PHY_A_CRS) | (1 << 14));
-	bcm43xx_radio_init2060(dev);
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		if (phy->gmode &&
+		    (phy->rev < 3))
+			bcm43xx_phy_write(dev, 0x0034,
+				bcm43xx_phy_read(dev, 0x0034) | 0x0001);
 
-	if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-	    ((bus->board_type == SSB_BOARD_BU4306) ||
-	     (bus->board_type == SSB_BOARD_BU4309))) {
-		if (phy->lofcal == 0xFFFF) {
-			TODO();//TODO: LOF Cal
-			bcm43xx_radio_set_tx_iq(dev);
-		} else
-			bcm43xx_radio_write16(dev, 0x001E, phy->lofcal);
-	}
+		bcm43xx_phy_rssiagc(dev, 0);
 
-	bcm43xx_phy_write(dev, 0x007A, 0xF111);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+			bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) | BCM43xx_PHY_CRS0_EN);
 
-	if (phy->cur_idle_tssi == 0) {
-		bcm43xx_radio_write16(dev, 0x0019, 0x0000);
-		bcm43xx_radio_write16(dev, 0x0017, 0x0020);
+		bcm43xx_radio_init2060(dev);
 
-		tval = bcm43xx_ofdmtab_read16(dev, 0x3001, 0);
-		if (phy->rev == 1) {
-			bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
-					  (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0xFF87)
-					  | 0x0058);
-		} else {
-			bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
-					  (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0xFFC3)
-					  | 0x002C);
+		if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
+		    ((bus->board_type == SSB_BOARD_BU4306) ||
+		     (bus->board_type == SSB_BOARD_BU4309))) {
+		     	; //TODO: A PHY LO
 		}
-		bcm43xx_dummy_transmission(dev);
-		phy->cur_idle_tssi = bcm43xx_phy_read(dev, BCM43xx_PHY_A_PCTL);
-		bcm43xx_ofdmtab_write16(dev, 0x3001, 0, tval);
 
-		bcm43xx_radio_set_txpower_a(dev, 0x0018);
+		if (phy->rev >= 3)
+			bcm43xx_phy_ww(dev);
+
+		hardware_pctl_init_aphy(dev);
+
+		//TODO: radar detection
 	}
-	bcm43xx_shm_clear_tssi(dev);
+	if (phy->type == BCM43xx_PHYTYPE_G
+	    && dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_PACTRL)
+	    	bcm43xx_phy_write(dev, 0x046E, 0x03CF);
 }
 
 static void bcm43xx_phy_initb2(struct bcm43xx_wldev *dev)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/Makefile	2007-05-06 12:48:29.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile	2007-05-11 12:15:22.000000000 +0200
@@ -15,4 +15,5 @@ bcm43xx-mac80211-objs := bcm43xx_main.o 
 		         bcm43xx_leds.o \
 		         bcm43xx_xmit.o \
 		         bcm43xx_lo.o \
+		         bcm43xx_wa.o \
 		         $(bcm43xx-mac80211-obj-y)


-- 
Greetings Michael.


From proski at gnu.org  Sat May 12 00:01:28 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 11 May 2007 18:01:28 -0400
Subject: 2.6.21.1 works with ifconfig; fails with ifup
In-Reply-To: <463FDAC2.7070506@Wetwork.Net>
References: <463FDAC2.7070506@Wetwork.Net>
Message-ID: <1178920888.2853.23.camel@dv>

Hello!

On Mon, 2007-05-07 at 19:04 -0700, Ehud Gavron wrote:
> 2.6.21.1 ifup eth1 panics and is repeatable.

I understand it's Fedora Core 6.  /sbin/ifup should be a script.  You
can trace it by running it as

bash -x /sbin/ifup eth1

> Unfortunately I can't get netconsole working because the 2.6.21.1 kernel 
> doesn't like my hardwired Ethernet card for no good reason.  TXcount 
> increases, RXcount does not.  tcpdump shows nothing.  Rebooting in 
> 2.6.20-1.2948.fc6 restores full functionality.

That should go to netdev list or to a list specifically about that
driver.  But I don't think netconsole is the best tool to debug other
networking drivers.

Please see Documentation/oops-tracing.txt in the Linux sources.  If you
have serial console, please use it.  If you can use local console,
that's the second best choice.  Use "dmesg -n 8" to enable all messages
on the console.  Switch to the first virtual console by Ctrl-Alt-F1 if X
Window System is running.  To maximize the number of lines, set the
smallest font, e.g.

setfont drdos8x8

Reproduce the panic and write down the messages.  Or you can make a
photograph of the screen.

Documentation/oops-tracing.txt also suggests kdump.  I haven't tried it,
but I think it would work.

> If I do the following it works flawlessly:
> ifconfig eth1 up
> iwconfig eth1 key wep-key-here
> iwconfig eth1 essid any   (or "real-essid-here")
> ifconfig eth1 10.1.1.5 netmask 255.255.255.0
> route add -net 0.0.0.0/0 gw 10.1.1.1
> 
> 
> If I do the following I get a kernel panic:
> ifup eth1

That's a clear sign that it's caused by something other that bringing
the interface up.

> [root at egdell ~]# more /etc/sysconfig/network-scripts/ifcfg-eth1
> # Broadcom Corporation BCM4306 802.11b/g Wireless LAN Controller
> TYPE=wireless
> DEVICE=eth1
> ONBOOT=no
> BOOTPROTO=static
> ADDRESS=10.1.1.5
> NETMASK=255.255.255.255
> GATEWAY=10.1.1.1
> ESSID=wetwork
> KEY=xxxa0055ae775e80fd864exxxx
> #RATE=24
> #CHANNEL=6

This looks good.

> While I can't use netconsole, I can use strace.  Accordingly attached is 
> the output from
> strace ifup eth1 > nothing.txt 2>output.txt

That's not very useful.  The interesting stuff is done in other
processes.  You could try to follow them by adding "-f" and "-F" flags.
But I think the first priority should be getting the kernel messages.

> If anyone has any ideas what's wrong with the wired ethernet...
> 09:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5752 
> Gigabit Ethernet PCI Express (rev 02)

Please ask in netdev.

> If I don't get any better suggestions I'll remake oldconfig but answer N 
> to all the new stuff and see if that makes a difference.  There are a 
> couple of new GE drivers, some experimental, and I'm guessing (with no 
> basis for the guess) that there may be interference there.

I would not change anything unless all possibilities for tracking down
the bug are exhausted.  The bug can just disappear temporarily to appear
later.

> access("/sbin/ip", X_OK)                = 0
> access("/sbin/ip", R_OK)                = 0
> rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
> _llseek(255, -1124, [9428], SEEK_CUR)   = 0
> clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|
> SIGCHLD, child_tidptr=0xb7f5d918) = 3400
> rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
> rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
> rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
> rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
> rt_sigaction(SIGINT, {0x807a8c0, [], 0}, {SIG_DFL}, 8) = 0
> waitpid(-1, 

Either it was /sbin/ip that triggered the crash, or the end of the log
wasn't written to the hard drive.  Generally, the console is designed to
be more survivable than the storage devices in case of a panic, so using
the console is preferred.

-- 
Regards,
Pavel Roskin



From mb at bu3sch.de  Sat May 12 01:07:01 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 12 May 2007 01:07:01 +0200
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <200705111224.33898.mb@bu3sch.de>
References: <20070423202530.2829f309@localhost>
	<20070423203041.46c8e454@localhost>
	<200705111224.33898.mb@bu3sch.de>
Message-ID: <200705120107.02627.mb@bu3sch.de>

On Friday 11 May 2007 12:24:33 Michael Buesch wrote:
> On Monday 23 April 2007 20:30:41 Stefano Brivio wrote:
> > This patch fixes A/G PHYs setup and initialization routines. Let's move
> > the so-called workarounds in a separate file, in order to avoid clobbering
> > bcm43xx_phy.c.
> 
> Here's a re-diffed version of this patch against current tree.
> I also fixed some bugs and did some cleanup.
> But it still horribly breaks transmission, when applied.
> 
> > TODO: check this diff:
> > http://bcm-v4.sipsolutions.net/802.11/PHY/G/workarounds/alt_AGC?action=diff&rev2=4&rev1=3
> 
> This is not addressed, yet.

Ok, I fixed another bug and throughput is getting better now.
Fixed patch is attached.
Tomorrow I will continue reviewing of this patch. I'll review the workarounds.
Note that I mostly only review the G-PHY stuff now.



Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c	2007-05-12 01:03:22.000000000 +0200
@@ -0,0 +1,649 @@
+/*
+
+  Broadcom BCM43xx wireless driver
+
+  PHY workarounds.
+
+  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
+  Copyright (c) 2005-2007 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de>
+  Copyright (c) 2005, 2006 Danny van Dyk <kugelfang at gentoo.org>
+  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+
+*/
+
+#include "bcm43xx.h"
+#include "bcm43xx_main.h"
+#include "bcm43xx_tables.h"
+#include "bcm43xx_phy.h"
+#include "bcm43xx_wa.h"
+
+static void bcm43xx_wa_papd(struct bcm43xx_wldev *dev)
+{
+	u16 backup;
+
+	backup = bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0, 7);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_APHY, 0, 0);
+	bcm43xx_dummy_transmission(dev);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0, backup);
+}
+
+static void bcm43xx_wa_auxclipthr(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E), 0x3800);
+}
+
+static void bcm43xx_wa_afcdac(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x0035, 0x03FF);
+	bcm43xx_phy_write(dev, 0x0036, 0x0400);
+}
+
+static void bcm43xx_wa_txdc_offset(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 0, 0x0051);
+}
+
+void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	bcm43xx_phy_write(dev, BCM43xx_PHY_LNAHPFCTL, 0x1FF9);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+		bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & 0xFF0F);
+	if (phy->rev <= 2)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_LPFGAIN, 0, 0x1FBF);
+	bcm43xx_radio_write16(dev, 0x0002, 0x1FBF);
+
+	bcm43xx_phy_write(dev, 0x0024, 0x4680);
+	bcm43xx_phy_write(dev, 0x0020, 0x0003);
+	bcm43xx_phy_write(dev, 0x001D, 0x0F40);
+	bcm43xx_phy_write(dev, 0x001F, 0x1C00);
+	if (phy->rev <= 3)
+		bcm43xx_phy_write(dev, 0x002A,
+			(bcm43xx_phy_read(dev, 0x002A) & 0x00FF) | 0x0400);
+	else if (phy->rev == 5) {
+		bcm43xx_phy_write(dev, 0x002A,
+			(bcm43xx_phy_read(dev, 0x002A) & 0x00FF) | 0x1A00);
+		bcm43xx_phy_write(dev, 0x00CC, 0x2121);
+	}
+	if (phy->rev >= 3)
+		bcm43xx_phy_write(dev, 0x00BA, 0x3ED5);
+}
+
+static void bcm43xx_wa_divider(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x002B, bcm43xx_phy_read(dev, 0x002B) & ~0x0100);
+	bcm43xx_phy_write(dev, 0x008E, 0x58C1);
+}
+
+static void bcm43xx_wa_gt(struct bcm43xx_wldev *dev) /* Gain table. */
+{
+	if (dev->phy.rev <= 2) {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 0, 15);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 1, 31);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 2, 42);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 3, 48);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 4, 58);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 0, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 1, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 3, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 4, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 5, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 6, 25);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 0, 3);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 1, 3);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 2, 7);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 0, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 1, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 3, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 4, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 5, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 6, 25);
+	}
+}
+
+static void bcm43xx_wa_rssi_lt(struct bcm43xx_wldev *dev) /* RSSI lookup table */
+{
+	int i;
+
+	for (i = 0; i < 8; i++)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_RSSI, i, i + 8);
+	for (i = 8; i < 16; i++)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_RSSI, i, i - 8);
+}
+
+static void bcm43xx_wa_analog(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->rev > 2) {
+		if (phy->type == BCM43xx_PHYTYPE_G)
+				bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, 0x1000);
+		else
+				bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, 0x1808);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 3, 0x1044);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 4, 0x7201);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 6, 0x0040);
+	}
+}
+
+static void bcm43xx_wa_dac(struct bcm43xx_wldev *dev)
+{
+	if (dev->phy.analog == 1)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1,
+			(bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 1) & ~0x0034) | 0x0008);
+	else
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1,
+			(bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 1) & ~0x0078) | 0x0010);
+}
+
+static void bcm43xx_wa_fft(struct bcm43xx_wldev *dev) /* Fine frequency table */
+{
+	int i;
+
+	if (dev->phy.type == BCM43xx_PHYTYPE_A)
+		for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqa[i]);
+	else
+		for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqg[i]);
+}
+
+static void bcm43xx_wa_nft(struct bcm43xx_wldev *dev) /* Noise figure table */
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+	int i;
+
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		if (phy->rev == 2)
+			for (i = 0; i < BCM43xx_TAB_NOISEA2_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea2[i]);
+		else
+			for (i = 0; i < BCM43xx_TAB_NOISEA3_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea3[i]);
+	} else {
+		if (phy->rev == 1)
+			for (i = 0; i < BCM43xx_TAB_NOISEG1_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg1[i]);
+		else
+			for (i = 0; i < BCM43xx_TAB_NOISEG2_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg2[i]);
+	}
+}
+
+static void bcm43xx_wa_rt(struct bcm43xx_wldev *dev) /* Rotor table */
+{
+	int i;
+
+	for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
+		bcm43xx_ofdmtab_write32(dev, BCM43xx_OFDMTAB_ROTOR, i, bcm43xx_tab_rotor[i]);
+}
+
+static void bcm43xx_wa_nst(struct bcm43xx_wldev *dev) /* Noise scale table */
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+	int i;
+
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		if (phy->rev <= 1)
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, 0);
+		else if (phy->rev == 2)
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescalea2[i]);
+		else if (phy->rev == 3)
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescalea3[i]);
+		else
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescaleg3[i]);
+	} else {
+		if (phy->rev >= 6) {
+			if (bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & BCM43xx_PHY_ENCORE_EN)
+				for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+					bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+						i, bcm43xx_tab_noisescaleg3[i]);
+			else
+				for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+					bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+						i, bcm43xx_tab_noisescaleg2[i]);
+		} else {
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescaleg1[i]);
+		}
+	}
+}
+
+static void bcm43xx_wa_art(struct bcm43xx_wldev *dev) /* ADV retard table */
+{
+	int i;
+
+	for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
+			bcm43xx_ofdmtab_write32(dev, BCM43xx_OFDMTAB_ADVRETARD,
+				i, bcm43xx_tab_retard[i]);
+}
+
+static void bcm43xx_wa_txlna_gain(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 13, 0x0000);
+}
+
+static void bcm43xx_wa_crs_reset(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x002C, 0x0064);
+}
+
+static void bcm43xx_wa_2060txlna_gain(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_hf_write(dev, bcm43xx_hf_read(dev) |
+			 BCM43xx_HF_2060W);
+}
+
+static void bcm43xx_wa_lms(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x0055,
+		(bcm43xx_phy_read(dev, 0x0055) & 0xFFC0) | 0x0004);
+}
+
+static void bcm43xx_wa_mixedsignal(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1, 3);
+}
+
+static void bcm43xx_wa_msst(struct bcm43xx_wldev *dev) /* Min sigma square table */
+{
+	int i;
+
+	for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
+		bcm43xx_ofdmtab_write16(dev, 0x5000 /* FIXME */, i,
+					bcm43xx_tab_sigmasqr1[i]);
+}
+
+static void bcm43xx_wa_iqadc(struct bcm43xx_wldev *dev)
+{
+	if (dev->phy.analog == 4)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 0,
+			bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 0) & ~0xF000);
+}
+
+static void bcm43xx_wa_crs_ed(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->rev == 1)
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1, 0x4F19);
+	else if (phy->rev == 2) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1_R1, 0x1861);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES2_R1, 0x0271);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x28),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x28)) | 0x0800);
+	} else {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1_R1, 0x0098);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES2_R1, 0x0070);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xC9), 0x0080);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x28),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x28)) | 0x0800);
+	}
+}
+
+static void bcm43xx_wa_crs_thr(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) & ~0x03C0) | 0xD000);
+}
+
+static void bcm43xx_wa_crs_blank(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x2C), 0x005A);
+}
+
+static void bcm43xx_wa_cck_shiftbits(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS, 0x0026);
+}
+
+static void bcm43xx_wa_wrssi_offset(struct bcm43xx_wldev *dev)
+{
+	int i;
+
+	if (dev->phy.rev == 1)
+		for (i = 0; i < 32; i++)
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_WRSSI_R1,
+						i, 0x0820);
+	else
+		for (i = 4; i < 20; i++)
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_WRSSI,
+						i, 0x0020);
+}
+
+static void bcm43xx_wa_txpuoff_rxpuon(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_0F, 2, 15);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_0F, 3, 20);
+}
+
+static void bcm43xx_wa_altagc(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->rev == 1) {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 0, 254);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 1, 13);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 3, 25);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 0, 0x2710);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 1, 0x9B83);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 2, 0x9B83);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 3, 0x0F8D);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_LMS, 4);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0, 254);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 1, 13);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 3, 25);
+	}
+
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS_WA,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_CCKSHIFTBITS_WA) & ~0xFF00) | 0x5700);
+	bcm43xx_phy_write(dev, 0x001A | BCM43xx_PHYROUTE_OFDM_GPHY,
+		(bcm43xx_phy_read(dev, 0x001A | BCM43xx_PHYROUTE_OFDM_GPHY) & ~0x007F) | 0x000F);
+	bcm43xx_phy_write(dev, 0x001A | BCM43xx_PHYROUTE_OFDM_GPHY,
+		(bcm43xx_phy_read(dev, 0x001A | BCM43xx_PHYROUTE_OFDM_GPHY) & ~0x3F80) | 0x2880);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_ANTWRSETT) & ~0xF000) | 0x7000);
+	bcm43xx_radio_write16(dev, 0x007A,
+		bcm43xx_radio_read16(dev, 0x007A) | 0x0008);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_N1P1GAIN,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_N1P1GAIN) & ~0x000F) | 0x0008);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_P1P2GAIN,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_P1P2GAIN) & ~0x0F00) | 0x0800);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x12),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x12)) & ~0x0F00) | 0x0700);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x10),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x10)) & ~0x0F00) | 0x0100);
+	if (phy->rev == 1)
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x12),
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x12)) & ~0x000F) | 0x0007);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0x00FF) | 0x001C);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0x3F00) | 0x0200);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x96)) & ~0x00FF) | 0x001C);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89)) & ~0x00FF) | 0x0020);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89)) & ~0x3F00) | 0x0200);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82)) & ~0x00FF) | 0x002E);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0xFF00) | 0x1A00);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81)) & ~0x00FF) | 0x0028);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81)) & ~0xFF00) | 0x2C00);
+	/* FIXME: these two writes could be merged, perhaps. */
+	if (phy->rev == 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_PEAK_COUNT, 0x092B);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x001E) | 0x0002);
+	} else {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x001E);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1F), 0x287A);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & ~0x000F) | 0x0004);
+		if (phy->rev >= 6) {
+			bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x22), 0x287A);
+			bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+				(bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & ~0xF000) | 0x3000);
+		}
+	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_DIVSRCHIDX,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_DIVSRCHIDX) & 0x7F7F) | 0x7874);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E) | BCM43xx_PHYROUTE_OFDM_GPHY, 0x1C00);
+	if (phy->rev == 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_DIVSRCHIDX,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_DIVSRCHIDX) & ~0x0F00) | 0x0600);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8B), 0x005E);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_ANTWRSETT) & ~0x00FF) | 0x001E);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8D), 0x0002);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 0, 0);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 1, 7);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 2, 16);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 3, 28);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 0, 0);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 1, 7);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 2, 16);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 3, 28);
+	}
+	if (phy->rev >= 6)
+	{
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x26)) & ~0x0003);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x26)) & ~0x1000);
+	}
+}
+
+static void bcm43xx_wa_tr_ltov(struct bcm43xx_wldev *dev) /* TR Lookup Table Original Values */
+{
+	bcm43xx_gtab_write(dev, BCM43xx_GTAB_ORIGTR, 0, 0xC480);
+}
+
+static void bcm43xx_wa_cpll_nonpilot(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_11, 0, 0);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_11, 1, 0);
+}
+
+static void bcm43xx_wa_rssi_adc(struct bcm43xx_wldev *dev)
+{
+	if (dev->phy.analog == 4)
+		bcm43xx_phy_write(dev, 0x00DC, 0x7454);
+}
+
+static void bcm43xx_wa_boards_a(struct bcm43xx_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+
+	if (bus->board_vendor == SSB_BOARDVENDOR_BCM &&
+	    bus->board_type == SSB_BOARD_BU4306 &&
+	    bus->board_rev < 0x30) {
+		bcm43xx_phy_write(dev, 0x0010, 0xE000);
+		bcm43xx_phy_write(dev, 0x0013, 0x0140);
+		bcm43xx_phy_write(dev, 0x0014, 0x0280);
+	} else {
+		if (bus->board_type == SSB_BOARD_MP4318 &&
+		    bus->board_rev < 0x20) {
+			bcm43xx_phy_write(dev, 0x0013, 0x0210);
+			bcm43xx_phy_write(dev, 0x0014, 0x0840);
+		} else {
+			bcm43xx_phy_write(dev, 0x0013, 0x0140);
+			bcm43xx_phy_write(dev, 0x0014, 0x0280);
+		}
+		if (dev->phy.rev <= 4)
+			bcm43xx_phy_write(dev, 0x0010, 0xE000);
+		else
+			bcm43xx_phy_write(dev, 0x0010, 0x2000);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 1, 0x0039);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_APHY, 7, 0x0040);
+	}
+}
+
+static void bcm43xx_wa_boards_g(struct bcm43xx_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (bus->board_vendor != SSB_BOARDVENDOR_BCM ||//FIXME condition?
+	    bus->board_type != SSB_BOARD_BU4306 ||
+	    bus->board_rev != 0x17) {
+		if (phy->rev < 2) {
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX_R1, 1, 0x0002);
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX_R1, 2, 0x0001);
+		} else {
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 1, 0x0002);
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 2, 0x0001);
+			if (bus->sprom.r1.boardflags_lo & BCM43xx_BFL_EXTLNA &&
+			    phy->rev >= 7) {
+				bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x11),
+					bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x11)) & 0xF7FF);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0020, 0x0001);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0021, 0x0001);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0022, 0x0001);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0023, 0x0000);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0000, 0x0000);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0003, 0x0002);
+			}
+		}
+	}
+	if (bus->sprom.r1.boardflags_lo & BCM43xx_BFL_FEM) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_GTABCTL, 0x3120);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_GTABDATA, 0xC480);
+	}
+}
+
+void bcm43xx_wa_all(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		switch (phy->rev) {
+		case 2:
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_auxclipthr(dev);
+			bcm43xx_wa_afcdac(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_divider(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_fft(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_rt(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_art(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			bcm43xx_wa_crs_reset(dev);
+			bcm43xx_wa_2060txlna_gain(dev);
+			bcm43xx_wa_lms(dev);
+			break;
+		case 3:
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_mixedsignal(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			break;
+		case 5:
+			bcm43xx_wa_iqadc(dev);
+		case 6:
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			break;
+		case 7:
+			bcm43xx_wa_iqadc(dev);
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			bcm43xx_wa_rssi_adc(dev);
+		default:
+			assert(0);
+		}
+		bcm43xx_wa_boards_a(dev);
+	} else { /* No N PHY support so far */
+		switch (phy->rev) {
+		case 1:
+			bcm43xx_wa_crs_ed(dev);
+			bcm43xx_wa_crs_thr(dev);
+			bcm43xx_wa_crs_blank(dev);
+			bcm43xx_wa_cck_shiftbits(dev);
+			bcm43xx_wa_fft(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_rt(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_art(dev);
+			bcm43xx_wa_wrssi_offset(dev);
+			bcm43xx_wa_altagc(dev);
+			break;
+		case 2:
+		case 6:
+		case 7:
+		case 8:
+			bcm43xx_wa_tr_ltov(dev);
+			bcm43xx_wa_crs_ed(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_wrssi_offset(dev);
+			bcm43xx_wa_altagc(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			break;
+		default:
+			assert(0);
+		}
+		bcm43xx_wa_boards_g(dev);
+	}
+
+	bcm43xx_wa_cpll_nonpilot(dev);
+}
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h	2007-05-12 01:03:22.000000000 +0200
@@ -0,0 +1,7 @@
+#ifndef BCM43xx_WA_H_
+#define BCM43xx_WA_H_
+
+void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev);
+void bcm43xx_wa_all(struct bcm43xx_wldev *dev);
+
+#endif /* BCM43xx_WA_H_ */
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c	2007-05-12 01:02:00.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c	2007-05-12 01:03:22.000000000 +0200
@@ -230,7 +230,7 @@ const u16 bcm43xx_tab_noisea2[] = {
 };
 
 const u16 bcm43xx_tab_noisea3[] = {
-	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
+	0x5E5E, 0x5E5E, 0x5E5E, 0x3F48,
 	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
 };
 
@@ -244,6 +244,26 @@ const u16 bcm43xx_tab_noiseg2[] = {
 	0x0000, 0x0000, 0x0000, 0x0000,
 };
 
+const u16 bcm43xx_tab_noisescalea2[] = {
+	0x6767, 0x6767, 0x6767, 0x6767, /* 0 */
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6700, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x6767, 0x6767, /* 16 */
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x0067,
+};
+
+const u16 bcm43xx_tab_noisescalea3[] = {
+	0x2323, 0x2323, 0x2323, 0x2323, /* 0 */
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2300, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x2323, 0x2323, /* 16 */
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x0023,
+};
+
 const u16 bcm43xx_tab_noisescaleg1[] = {
 	0x6C77, 0x5162, 0x3B40, 0x3335, /* 0 */
 	0x2F2D, 0x2A2A, 0x2527, 0x1F21,
@@ -308,6 +328,27 @@ const u16 bcm43xx_tab_sigmasqr2[] = {
 	0x00DE,
 };
 
+const u16 bcm43xx_tab_rssiagc1[] = {
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8, /* 0 */
+	0xFFF8, 0xFFF9, 0xFFFC, 0xFFFE,
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+};
+
+const u16 bcm43xx_tab_rssiagc2[] = {
+	0x0820, 0x0820, 0x0920, 0x0C38, /* 0 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38, /* 16 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38, /* 32 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+};
 
 static inline void assert_sizes(void)
 {
@@ -319,34 +360,54 @@ static inline void assert_sizes(void)
 	BUILD_BUG_ON(BCM43xx_TAB_NOISEA3_SIZE != ARRAY_SIZE(bcm43xx_tab_noisea3));
 	BUILD_BUG_ON(BCM43xx_TAB_NOISEG1_SIZE != ARRAY_SIZE(bcm43xx_tab_noiseg1));
 	BUILD_BUG_ON(BCM43xx_TAB_NOISEG2_SIZE != ARRAY_SIZE(bcm43xx_tab_noiseg2));
-	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg1));
-	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
-	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
+	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg1));
+	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
+	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
 	BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE != ARRAY_SIZE(bcm43xx_tab_sigmasqr1));
 	BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE != ARRAY_SIZE(bcm43xx_tab_sigmasqr2));
+	BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC1_SIZE != ARRAY_SIZE(bcm43xx_tab_rssiagc1));
+	BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC2_SIZE != ARRAY_SIZE(bcm43xx_tab_rssiagc2));
 }
 
 
 u16 bcm43xx_ofdmtab_read16(struct bcm43xx_wldev *dev, u16 table, u16 offset)
 {
+	struct bcm43xx_phy *phy = &dev->phy;
+
 	assert_sizes();
 
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+	if (table + offset - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+		phy->ofdm_valid = 1;
+	}
+	phy->ofdm_addr = table + offset;
+
 	return bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI);
 }
 
 void bcm43xx_ofdmtab_write16(struct bcm43xx_wldev *dev, u16 table,
 			     u16 offset, u16 value)
 {
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (table + offset - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+		phy->ofdm_valid = 2;
+	}
+	phy->ofdm_addr = table + offset;
 	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
 }
 
 u32 bcm43xx_ofdmtab_read32(struct bcm43xx_wldev *dev, u16 table, u16 offset)
 {
+	struct bcm43xx_phy *phy = &dev->phy;
 	u32 ret;
 
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+	if (table + offset - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+		phy->ofdm_valid = 1;
+	}
+	phy->ofdm_addr = table + offset;
 	ret = bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEQ);
 	ret <<= 16;
 	ret |= bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI);
@@ -357,9 +418,15 @@ u32 bcm43xx_ofdmtab_read32(struct bcm43x
 void bcm43xx_ofdmtab_write32(struct bcm43xx_wldev *dev, u16 table,
 			     u16 offset, u32 value)
 {
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (table + offset - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+		phy->ofdm_valid = 2;
+	}
+	phy->ofdm_addr = table + offset;
 	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEQ, (value >> 16));
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
 }
 
 u16 bcm43xx_gtab_read(struct bcm43xx_wldev *dev, u16 table, u16 offset)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h	2007-05-12 01:02:00.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h	2007-05-12 01:03:22.000000000 +0200
@@ -591,6 +591,10 @@ struct bcm43xx_phy {
 	u16 lofcal;
 
 	u16 initval;//FIXME rename?
+
+	/* OFDM address read/write caching for hardware auto-increment. */
+	u16 ofdm_addr;
+	u8 ofdm_valid; /* 0: invalid, 1: read, 2: write */
 };
 
 /* Data structures for DMA transmission, per 80211 core. */
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c	2007-05-12 01:02:00.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c	2007-05-12 01:03:22.000000000 +0200
@@ -3127,6 +3127,9 @@ static void setup_struct_phy_for_init(st
 	spin_lock_init(&phy->lock);
 	phy->interfmode = BCM43xx_INTERFMODE_NONE;
 	phy->channel = 0xFF;
+
+	/* OFDM address caching. */
+	phy->ofdm_valid = 0;
 }
 
 static void setup_struct_wldev_for_init(struct bcm43xx_wldev *dev)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h	2007-05-12 01:02:00.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h	2007-05-12 01:03:22.000000000 +0200
@@ -28,8 +28,11 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_PWRDOWN		BCM43xx_PHY_OFDM(0x03)	/* Powerdown */
 #define BCM43xx_PHY_CRSTHRES1		BCM43xx_PHY_OFDM(0x06)	/* CRS Threshold 1 */
 #define BCM43xx_PHY_LNAHPFCTL		BCM43xx_PHY_OFDM(0x1C)	/* LNA/HPF control */
+#define BCM43xx_PHY_LPFGAINCTL		BCM43xx_PHY_OFDM(0x20)	/* LPF Gain control */
 #define BCM43xx_PHY_ADIVRELATED		BCM43xx_PHY_OFDM(0x27)	/* FIXME rename */
 #define BCM43xx_PHY_CRS0		BCM43xx_PHY_OFDM(0x29)
+#define  BCM43xx_PHY_CRS0_EN		0x4000
+#define BCM43xx_PHY_PEAK_COUNT		BCM43xx_PHY_OFDM(0x30)
 #define BCM43xx_PHY_ANTDWELL		BCM43xx_PHY_OFDM(0x2B)	/* Antenna dwell */
 #define  BCM43xx_PHY_ANTDWELL_AUTODIV1	0x0100			/* Automatic RX diversity start antenna */
 #define BCM43xx_PHY_ENCORE		BCM43xx_PHY_OFDM(0x49)	/* "Encore" (RangeMax / BroadRange) */
@@ -38,6 +41,7 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_OFDM61		BCM43xx_PHY_OFDM(0x61)	/* FIXME rename */
 #define  BCM43xx_PHY_OFDM61_10		0x0010			/* FIXME rename */
 #define BCM43xx_PHY_IQBAL		BCM43xx_PHY_OFDM(0x69)	/* I/Q balance */
+#define BCM43xx_PHY_BBTXDC_BIAS		BCM43xx_PHY_OFDM(0x6B)	/* Baseband TX DC bias */
 #define BCM43xx_PHY_OTABLECTL		BCM43xx_PHY_OFDM(0x72)	/* OFDM table control (see below) */
 #define  BCM43xx_PHY_OTABLEOFF		0x03FF			/* OFDM table offset (see below) */
 #define  BCM43xx_PHY_OTABLENR		0xFC00			/* OFDM table number (see below) */
@@ -45,6 +49,9 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_OTABLEI		BCM43xx_PHY_OFDM(0x73)	/* OFDM table data I */
 #define BCM43xx_PHY_OTABLEQ		BCM43xx_PHY_OFDM(0x74)	/* OFDM table data Q */
 #define BCM43xx_PHY_HPWR_TSSICTL	BCM43xx_PHY_OFDM(0x78)	/* Hardware power TSSI control */
+#define BCM43xx_PHY_ADCCTL		BCM43xx_PHY_OFDM(0x7A)	/* ADC control */
+#define BCM43xx_PHY_IDLE_TSSI		BCM43xx_PHY_OFDM(0x7B)
+#define BCM43xx_PHY_A_TEMP_SENSE	BCM43xx_PHY_OFDM(0x7C)	/* A PHY temperature sense */
 #define BCM43xx_PHY_NRSSITHRES		BCM43xx_PHY_OFDM(0x8A)	/* NRSSI threshold */
 #define BCM43xx_PHY_ANTWRSETT		BCM43xx_PHY_OFDM(0x8C)	/* Antenna WR settle */
 #define  BCM43xx_PHY_ANTWRSETT_ARXDIV	0x2000			/* Automatic RX diversity enabled */
@@ -55,6 +62,8 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_N1N2GAIN		BCM43xx_PHY_OFDM(0xA2)
 #define BCM43xx_PHY_CLIPTHRES		BCM43xx_PHY_OFDM(0xA3)
 #define BCM43xx_PHY_CLIPN1P2THRES	BCM43xx_PHY_OFDM(0xA4)
+#define BCM43xx_PHY_CCKSHIFTBITS_WA	BCM43xx_PHY_OFDM(0xA5)	/* CCK shiftbits workaround, FIXME rename */
+#define BCM43xx_PHY_CCKSHIFTBITS	BCM43xx_PHY_OFDM(0xA7)  /* FIXME rename */
 #define BCM43xx_PHY_DIVSRCHIDX		BCM43xx_PHY_OFDM(0xA8)	/* Divider search gain/index */
 #define BCM43xx_PHY_CLIPP2THRES		BCM43xx_PHY_OFDM(0xA9)
 #define BCM43xx_PHY_CLIPP3THRES		BCM43xx_PHY_OFDM(0xAA)
@@ -128,10 +137,11 @@ struct bcm43xx_wldev;
 #define BCM43xx_OFDMTAB_DC		BCM43xx_OFDMTAB(0x0E, 7)
 #define BCM43xx_OFDMTAB_PWRDYN2		BCM43xx_OFDMTAB(0x0E, 12)
 #define BCM43xx_OFDMTAB_LNAGAIN		BCM43xx_OFDMTAB(0x0E, 13)
-//TODO
+#define BCM43xx_OFDMTAB_UNKNOWN_0F	BCM43xx_OFDMTAB(0x0F, 0)	//TODO rename
+#define BCM43xx_OFDMTAB_UNKNOWN_APHY	BCM43xx_OFDMTAB(0x0F, 7)	//TODO rename
 #define BCM43xx_OFDMTAB_LPFGAIN		BCM43xx_OFDMTAB(0x0F, 12)
 #define BCM43xx_OFDMTAB_RSSI		BCM43xx_OFDMTAB(0x10, 0)
-//TODO
+#define BCM43xx_OFDMTAB_UNKNOWN_11	BCM43xx_OFDMTAB(0x11, 4)	//TODO rename
 #define BCM43xx_OFDMTAB_AGC1_R1		BCM43xx_OFDMTAB(0x13, 0)
 #define BCM43xx_OFDMTAB_GAINX_R1	BCM43xx_OFDMTAB(0x14, 0)	//TODO rename
 #define BCM43xx_OFDMTAB_MINSIGSQ	BCM43xx_OFDMTAB(0x14, 1)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h	2007-05-12 01:02:00.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h	2007-05-12 01:03:22.000000000 +0200
@@ -17,12 +17,18 @@ extern const u16 bcm43xx_tab_noisea3[];
 extern const u16 bcm43xx_tab_noiseg1[];
 #define BCM43xx_TAB_NOISEG2_SIZE	8
 extern const u16 bcm43xx_tab_noiseg2[];
-#define BCM43xx_TAB_NOISESCALEG_SIZE	27
+#define BCM43xx_TAB_NOISESCALE_SIZE	27
+extern const u16 bcm43xx_tab_noisescalea2[];
+extern const u16 bcm43xx_tab_noisescalea3[];
 extern const u16 bcm43xx_tab_noisescaleg1[];
 extern const u16 bcm43xx_tab_noisescaleg2[];
 extern const u16 bcm43xx_tab_noisescaleg3[];
 #define BCM43xx_TAB_SIGMASQR_SIZE	53
 extern const u16 bcm43xx_tab_sigmasqr1[];
 extern const u16 bcm43xx_tab_sigmasqr2[];
+#define BCM43xx_TAB_RSSIAGC1_SIZE	16
+extern const u16 bcm43xx_tab_rssiagc1[];
+#define BCM43xx_TAB_RSSIAGC2_SIZE	48
+extern const u16 bcm43xx_tab_rssiagc2[];
 
 #endif /* BCM43xx_TABLES_H_ */
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c	2007-05-12 01:02:00.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c	2007-05-12 01:03:22.000000000 +0200
@@ -34,6 +34,7 @@
 #include "bcm43xx_tables.h"
 #include "bcm43xx_power.h"
 #include "bcm43xx_lo.h"
+#include "bcm43xx_wa.h"
 
 
 static const s8 bcm43xx_tssi2dbm_b_table[] = {
@@ -559,393 +560,96 @@ static void bcm43xx_phy_init_pctl(struct
 	bcm43xx_shm_clear_tssi(dev);
 }
 
-static void bcm43xx_phy_agcsetup(struct bcm43xx_wldev *dev)
+static void bcm43xx_phy_rssiagc(struct bcm43xx_wldev *dev, u8 enable)
 {
-	struct bcm43xx_phy *phy = &dev->phy;
-	u16 offset = 0x0000;
-
-	if (phy->rev == 1)
-		offset = 0x4C00;
-
-	bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00FE);
-	bcm43xx_ofdmtab_write16(dev, offset, 1, 0x000D);
-	bcm43xx_ofdmtab_write16(dev, offset, 2, 0x0013);
-	bcm43xx_ofdmtab_write16(dev, offset, 3, 0x0019);
-
-	if (phy->rev == 1) {
-		bcm43xx_ofdmtab_write16(dev, 0x1800, 0, 0x2710);
-		bcm43xx_ofdmtab_write16(dev, 0x1801, 0, 0x9B83);
-		bcm43xx_ofdmtab_write16(dev, 0x1802, 0, 0x9B83);
-		bcm43xx_ofdmtab_write16(dev, 0x1803, 0, 0x0F8D);
-		bcm43xx_phy_write(dev, 0x0455, 0x0004);
-	}
-
-	bcm43xx_phy_write(dev, 0x04A5,
-			  (bcm43xx_phy_read(dev, 0x04A5)
-			   & 0x00FF) | 0x5700);
-	bcm43xx_phy_write(dev, 0x041A,
-			  (bcm43xx_phy_read(dev, 0x041A)
-			   & 0xFF80) | 0x000F);
-	bcm43xx_phy_write(dev, 0x041A,
-			  (bcm43xx_phy_read(dev, 0x041A)
-			   & 0xC07F) | 0x2B80);
-	bcm43xx_phy_write(dev, 0x048C,
-			  (bcm43xx_phy_read(dev, 0x048C)
-			   & 0xF0FF) | 0x0300);
-
-	bcm43xx_radio_write16(dev, 0x007A,
-			      bcm43xx_radio_read16(dev, 0x007A)
-			      | 0x0008);
-
-	bcm43xx_phy_write(dev, 0x04A0,
-			  (bcm43xx_phy_read(dev, 0x04A0)
-			   & 0xFFF0) | 0x0008);
-	bcm43xx_phy_write(dev, 0x04A1,
-			  (bcm43xx_phy_read(dev, 0x04A1)
-			   & 0xF0FF) | 0x0600);
-	bcm43xx_phy_write(dev, 0x04A2,
-			  (bcm43xx_phy_read(dev, 0x04A2)
-			   & 0xF0FF) | 0x0700);
-	bcm43xx_phy_write(dev, 0x04A0,
-			  (bcm43xx_phy_read(dev, 0x04A0)
-			   & 0xF0FF) | 0x0100);
-
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(dev, 0x04A2,
-				  (bcm43xx_phy_read(dev, 0x04A2)
-				   & 0xFFF0) | 0x0007);
-	}
-
-	bcm43xx_phy_write(dev, 0x0488,
-			  (bcm43xx_phy_read(dev, 0x0488)
-			   & 0xFF00) | 0x001C);
-	bcm43xx_phy_write(dev, 0x0488,
-			  (bcm43xx_phy_read(dev, 0x0488)
-			   & 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(dev, 0x0496,
-			  (bcm43xx_phy_read(dev, 0x0496)
-			   & 0xFF00) | 0x001C);
-	bcm43xx_phy_write(dev, 0x0489,
-			  (bcm43xx_phy_read(dev, 0x0489)
-			   & 0xFF00) | 0x0020);
-	bcm43xx_phy_write(dev, 0x0489,
-			  (bcm43xx_phy_read(dev, 0x0489)
-			   & 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(dev, 0x0482,
-			  (bcm43xx_phy_read(dev, 0x0482)
-			   & 0xFF00) | 0x002E);
-	bcm43xx_phy_write(dev, 0x0496,
-			  (bcm43xx_phy_read(dev, 0x0496)
-			   & 0x00FF) | 0x1A00);
-	bcm43xx_phy_write(dev, 0x0481,
-			  (bcm43xx_phy_read(dev, 0x0481)
-			   & 0xFF00) | 0x0028);
-	bcm43xx_phy_write(dev, 0x0481,
-			  (bcm43xx_phy_read(dev, 0x0481)
-			   & 0x00FF) | 0x2C00);
-
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(dev, 0x0430, 0x092B);
-		bcm43xx_phy_write(dev, 0x041B,
-				  (bcm43xx_phy_read(dev, 0x041B)
-				   & 0xFFE1) | 0x0002);
-	} else {
-		bcm43xx_phy_write(dev, 0x041B,
-				  bcm43xx_phy_read(dev, 0x041B)
-				  & 0xFFE1);
-		bcm43xx_phy_write(dev, 0x041F, 0x287A);
-		bcm43xx_phy_write(dev, 0x0420,
-				  (bcm43xx_phy_read(dev, 0x0420)
-				   & 0xFFF0) | 0x0004);
-	}
-
-	if (phy->rev >= 6) {
-		bcm43xx_phy_write(dev, 0x0422, 0x287A);
-		bcm43xx_phy_write(dev, 0x0420,
-				  (bcm43xx_phy_read(dev, 0x0420)
-				   & 0x0FFF) | 0x3000);
-	}
-
-	bcm43xx_phy_write(dev, 0x04A8,
-			  (bcm43xx_phy_read(dev, 0x04A8)
-			   & 0x8080) | 0x7874);
-	bcm43xx_phy_write(dev, 0x048E, 0x1C00);
-
-	offset = 0x0800;
-	if (phy->rev == 1) {
-		offset = 0x5400;
-		bcm43xx_phy_write(dev, 0x04AB,
-				  (bcm43xx_phy_read(dev, 0x04AB)
-				   & 0xF0FF) | 0x0600);
-		bcm43xx_phy_write(dev, 0x048B, 0x005E);
-		bcm43xx_phy_write(dev, 0x048C,
-				  (bcm43xx_phy_read(dev, 0x048C)
-				   & 0xFF00) | 0x001E);
-		bcm43xx_phy_write(dev, 0x048D, 0x0002);
-	}
-	bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00);
-	bcm43xx_ofdmtab_write16(dev, offset, 1, 0x07);
-	bcm43xx_ofdmtab_write16(dev, offset, 2, 0x10);
-	bcm43xx_ofdmtab_write16(dev, offset, 3, 0x1C);
-
-	if (phy->rev >= 6) {
-		bcm43xx_phy_write(dev, 0x0426,
-				  bcm43xx_phy_read(dev, 0x0426)
-				  & 0xFFFC);
-		bcm43xx_phy_write(dev, 0x0426,
-				  bcm43xx_phy_read(dev, 0x0426)
-				  & 0xEFFF);
-	}
-}
-
-static void bcm43xx_phy_setupg(struct bcm43xx_wldev *dev)
-{
-	struct ssb_bus *bus = dev->dev->bus;
-	struct bcm43xx_phy *phy = &dev->phy;
-	u16 i;
-
-	assert(phy->type == BCM43xx_PHYTYPE_G);
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(dev, 0x0406, 0x4F19);
-		bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
-				  (bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS) & 0xFC3F) | 0x0340);
-		bcm43xx_phy_write(dev, 0x042C, 0x005A);
-		bcm43xx_phy_write(dev, 0x0427, 0x001A);
-
-		for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5800, i, bcm43xx_tab_finefreqg[i]);
-		for (i = 0; i < BCM43xx_TAB_NOISEG1_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noiseg1[i]);
-		for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x2000, i, bcm43xx_tab_rotor[i]);
-	} else {
-		/* nrssi values are signed 6-bit values. Not sure why we write 0x7654 here... */
-		bcm43xx_nrssi_hw_write(dev, 0xBA98, (s16)0x7654);
-
-		if (phy->rev == 2) {
-			bcm43xx_phy_write(dev, 0x04C0, 0x1861);
-			bcm43xx_phy_write(dev, 0x04C1, 0x0271);
-		} else if (phy->rev > 2) {
-			bcm43xx_phy_write(dev, 0x04C0, 0x0098);
-			bcm43xx_phy_write(dev, 0x04C1, 0x0070);
-			bcm43xx_phy_write(dev, 0x04C9, 0x0080);
-		}
-		bcm43xx_phy_write(dev, 0x042B, bcm43xx_phy_read(dev, 0x042B) | 0x800);
-
-		for (i = 0; i < 64; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x4000, i, i);
-		for (i = 0; i < BCM43xx_TAB_NOISEG2_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noiseg2[i]);
-	}
-
-	if (phy->rev <= 2)
-		for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg1[i]);
-	else if ((phy->rev >= 7) && (bcm43xx_phy_read(dev, 0x0449) & 0x0200))
-		for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg3[i]);
-	else
-		for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg2[i]);
-
-	if (phy->rev == 2)
-		for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5000, i, bcm43xx_tab_sigmasqr1[i]);
-	else if ((phy->rev > 2) && (phy->rev <= 8))
-		for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5000, i, bcm43xx_tab_sigmasqr2[i]);
-
-	if (phy->rev == 1) {
-		for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
-			bcm43xx_ofdmtab_write32(dev, 0x2400, i, bcm43xx_tab_retard[i]);
-		for (i = 0; i < 4; i++) {
-			bcm43xx_ofdmtab_write16(dev, 0x5404, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x5408, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x540C, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x5410, i, 0x0020);
-		}
-		bcm43xx_phy_agcsetup(dev);
-
-		if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-		    (bus->board_type == SSB_BOARD_BU4306) &&
-		    (bus->board_rev == 0x17))
-			return;
-
-		bcm43xx_ofdmtab_write16(dev, 0x5001, 0, 0x0002);
-		bcm43xx_ofdmtab_write16(dev, 0x5002, 0, 0x0001);
-	} else {
-		for (i = 0; i <= 0x2F; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1000, i, 0x0820);
-		bcm43xx_phy_agcsetup(dev);
-		bcm43xx_phy_read(dev, 0x0400); /* dummy read */
-		bcm43xx_phy_write(dev, 0x0403, 0x1000);
-		bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
-
-		if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-		    (bus->board_type == SSB_BOARD_BU4306) &&
-		    (bus->board_rev == 0x17))
-			return;
-
-		bcm43xx_ofdmtab_write16(dev, 0x0401, 0, 0x0002);
-		bcm43xx_ofdmtab_write16(dev, 0x0402, 0, 0x0001);
-	}
-}
-
-/* Initialize the noisescaletable for APHY */
-static void bcm43xx_phy_init_noisescaletbl(struct bcm43xx_wldev *dev)
-{
-	struct bcm43xx_phy *phy = &dev->phy;
 	int i;
 
-	for (i = 0; i < 12; i++) {
-		if (phy->rev == 2)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6767);
+	if (dev->phy.rev < 3) {
+		if (enable)
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_LNAHPFGAIN1, i, 0xFFF8);
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, 0xFFF8);
+			}
 		else
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2323);
-	}
-	if (phy->rev == 2)
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6700);
-	else
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2300);
-	for (i = 0; i < 11; i++) {
-		if (phy->rev == 2)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6767);
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_LNAHPFGAIN1, i, bcm43xx_tab_rssiagc1[i]);
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, bcm43xx_tab_rssiagc1[i]);
+			}
+	} else {
+		if (enable)
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, 0x0820);
 		else
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2323);
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC2_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, bcm43xx_tab_rssiagc2[i]);
 	}
-	if (phy->rev == 2)
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0067);
-	else
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0023);
 }
 
-static void bcm43xx_phy_setupa(struct bcm43xx_wldev *dev)
+static void bcm43xx_phy_ww(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phy *phy = &dev->phy;
-	u16 i;
-
-	assert(phy->type == BCM43xx_PHYTYPE_A);
-	switch (phy->rev) {
-	case 2:
-		bcm43xx_phy_write(dev, 0x008E, 0x3800);
-		bcm43xx_phy_write(dev, 0x0035, 0x03FF);
-		bcm43xx_phy_write(dev, 0x0036, 0x0400);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-		bcm43xx_phy_write(dev, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(dev, 0x0020, bcm43xx_phy_read(dev, 0x0020) & 0xFF0F);
-		bcm43xx_ofdmtab_write16(dev, 0x3C0C, 0, 0x07BF);
-		bcm43xx_radio_write16(dev, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(dev, 0x0024, 0x4680);
-		bcm43xx_phy_write(dev, 0x0020, 0x0003);
-		bcm43xx_phy_write(dev, 0x001D, 0x0F40);
-		bcm43xx_phy_write(dev, 0x001F, 0x1C00);
-
-		bcm43xx_phy_write(dev, 0x002A,
-				  (bcm43xx_phy_read(dev, 0x002A)
-				   & 0x00FF) | 0x0400);
-		bcm43xx_phy_write(dev, 0x002B,
-				  bcm43xx_phy_read(dev, 0x002B)
-				  & 0xFBFF);
-		bcm43xx_phy_write(dev, 0x008E, 0x58C1);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-		bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 1, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 2, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 3, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 4, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 5, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 6, 0x0019);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
-
-		for (i = 0; i < 16; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x4000, i, (0x8 + i) & 0x000F);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3003, 0, 0x1044);
-		bcm43xx_ofdmtab_write16(dev, 0x3004, 0, 0x7201);
-		bcm43xx_ofdmtab_write16(dev, 0x3006, 0, 0x0040);
-		bcm43xx_ofdmtab_write16(dev, 0x3001, 0, (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0x0010) | 0x0008);
-
-		for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5800, i, bcm43xx_tab_finefreqa[i]);
-		for (i = 0; i < BCM43xx_TAB_NOISEA2_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noisea2[i]);
-		for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
-			bcm43xx_ofdmtab_write32(dev, 0x2000, i, bcm43xx_tab_rotor[i]);
-		bcm43xx_phy_init_noisescaletbl(dev);
-		for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
-			bcm43xx_ofdmtab_write32(dev, 0x2400, i, bcm43xx_tab_retard[i]);
-		break;
-	case 3:
-		for (i = 0; i < 64; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x4000, i, i);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-		bcm43xx_phy_write(dev, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(dev, 0x0020,
-				  bcm43xx_phy_read(dev, 0x0020) & 0xFF0F);
-		bcm43xx_radio_write16(dev, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(dev, 0x0024, 0x4680);
-		bcm43xx_phy_write(dev, 0x0020, 0x0003);
-		bcm43xx_phy_write(dev, 0x001D, 0x0F40);
-		bcm43xx_phy_write(dev, 0x001F, 0x1C00);
-		bcm43xx_phy_write(dev, 0x002A,
-				  (bcm43xx_phy_read(dev, 0x002A)
-				   & 0x00FF) | 0x0400);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3000, 1,
-				        (bcm43xx_ofdmtab_read16(dev, 0x3000, 1)
-				        & 0x0010) | 0x0008);
-		for (i = 0; i < BCM43xx_TAB_NOISEA3_SIZE; i++) {
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i,
-						bcm43xx_tab_noisea3[i]);
-		}
-		bcm43xx_phy_init_noisescaletbl(dev);
-		for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++) {
-			bcm43xx_ofdmtab_write16(dev, 0x5000, i,
-						bcm43xx_tab_sigmasqr1[i]);
-		}
-
-		bcm43xx_phy_write(dev, 0x0003, 0x1808);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-		bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0001, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0002, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0003, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0004, 0, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0005, 0, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0006, 0, 0x0019);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
+	u16 b, curr_s, best_s = 0xFFFF;
+	int i;
 
-		bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
-		break;
-	default:
-		assert(0);
-	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+		bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) & ~BCM43xx_PHY_CRS0_EN);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+		bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) | 0x1000);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82)) & 0xF0FF) | 0x0300);
+	bcm43xx_radio_write16(dev, 0x0009,
+		bcm43xx_radio_read16(dev, 0x0009) | 0x0080);
+	bcm43xx_radio_write16(dev, 0x0012,
+		(bcm43xx_radio_read16(dev, 0x0012) & 0xFFFC) | 0x0002);
+	bcm43xx_wa_initgains(dev);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBA), 0x3ED5);
+	b = bcm43xx_phy_read(dev, BCM43xx_PHY_PWRDOWN);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, (b & 0xFFF8) | 0x0005);
+	bcm43xx_radio_write16(dev, 0x0004,
+		bcm43xx_radio_read16(dev, 0x0004) | 0x0004);
+	for (i = 0x10; i <= 0x20; i++) {
+		bcm43xx_radio_write16(dev, 0x0013, i);
+		curr_s = bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEQ) & 0x00FF;
+		if (!curr_s) {
+			best_s = 0x0000;
+			break;
+		} else if (curr_s >= 0x0080)
+			curr_s = 0x0100 - curr_s;
+		if (curr_s < best_s)
+			best_s = curr_s;
+	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, b);
+	bcm43xx_radio_write16(dev, 0x0004,
+		bcm43xx_radio_read16(dev, 0x0004) & 0xFFFB);
+	bcm43xx_radio_write16(dev, 0x0013, best_s);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 0, 0xFFEC);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB7), 0x1E80);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB6), 0x1C00);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB5), 0x0EC0);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB2), 0x00C0);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB9), 0x1FFF);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBB),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0xBB)) & 0xF000) | 0x0053);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM61,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM61 & 0xFE1F)) | 0x0120);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x13),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x13)) & 0x0FFF) | 0x3000);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x14),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x14)) & 0x0FFF) | 0x3000);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 6, 0x0017);
+	for (i = 0; i < 6; i++)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, i, 0x000F);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0D, 0x000E);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0E, 0x0011);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0F, 0x0013);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x33), 0x5030);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+		bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) | BCM43xx_PHY_CRS0_EN);
 }
 
 /* Initialize APHY. This is also called for the GPHY in some cases. */
@@ -953,60 +657,52 @@ static void bcm43xx_phy_inita(struct bcm
 {
 	struct ssb_bus *bus = dev->dev->bus;
 	struct bcm43xx_phy *phy = &dev->phy;
-	u16 tval;
 
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_setupa(dev);
-	} else {
-		bcm43xx_phy_setupg(dev);
-		if (phy->gmode &&
-		    (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_PACTRL))
-			bcm43xx_phy_write(dev, 0x046E, 0x03CF);
-		return;
+	if (phy->rev >= 6) {
+		if (phy->type == BCM43xx_PHYTYPE_A)
+			bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+				bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x1000);
+		if (bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & BCM43xx_PHY_ENCORE_EN)
+			bcm43xx_phy_write(dev, BCM43xx_PHY_ENCORE,
+				bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) | 0x0010);
+		else
+			bcm43xx_phy_write(dev, BCM43xx_PHY_ENCORE,
+				bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & ~0x1010);
 	}
+	bcm43xx_wa_all(dev);
 
-	bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
-	                  (bcm43xx_phy_read(dev, BCM43xx_PHY_A_CRS) & 0xF83C) | 0x0340);
-	bcm43xx_phy_write(dev, 0x0034, 0x0001);
-
-	TODO();//TODO: RSSI AGC
-	bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
-	                  bcm43xx_phy_read(dev, BCM43xx_PHY_A_CRS) | (1 << 14));
-	bcm43xx_radio_init2060(dev);
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		if (phy->gmode &&
+		    (phy->rev < 3))
+			bcm43xx_phy_write(dev, 0x0034,
+				bcm43xx_phy_read(dev, 0x0034) | 0x0001);
 
-	if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-	    ((bus->board_type == SSB_BOARD_BU4306) ||
-	     (bus->board_type == SSB_BOARD_BU4309))) {
-		if (phy->lofcal == 0xFFFF) {
-			TODO();//TODO: LOF Cal
-			bcm43xx_radio_set_tx_iq(dev);
-		} else
-			bcm43xx_radio_write16(dev, 0x001E, phy->lofcal);
-	}
+		bcm43xx_phy_rssiagc(dev, 0);
 
-	bcm43xx_phy_write(dev, 0x007A, 0xF111);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+			bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) | BCM43xx_PHY_CRS0_EN);
 
-	if (phy->cur_idle_tssi == 0) {
-		bcm43xx_radio_write16(dev, 0x0019, 0x0000);
-		bcm43xx_radio_write16(dev, 0x0017, 0x0020);
+		bcm43xx_radio_init2060(dev);
 
-		tval = bcm43xx_ofdmtab_read16(dev, 0x3001, 0);
-		if (phy->rev == 1) {
-			bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
-					  (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0xFF87)
-					  | 0x0058);
-		} else {
-			bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
-					  (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0xFFC3)
-					  | 0x002C);
+		if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
+		    ((bus->board_type == SSB_BOARD_BU4306) ||
+		     (bus->board_type == SSB_BOARD_BU4309))) {
+		     	; //TODO: A PHY LO
 		}
-		bcm43xx_dummy_transmission(dev);
-		phy->cur_idle_tssi = bcm43xx_phy_read(dev, BCM43xx_PHY_A_PCTL);
-		bcm43xx_ofdmtab_write16(dev, 0x3001, 0, tval);
 
-		bcm43xx_radio_set_txpower_a(dev, 0x0018);
+		if (phy->rev >= 3)
+			bcm43xx_phy_ww(dev);
+
+		hardware_pctl_init_aphy(dev);
+
+		//TODO: radar detection
+	}
+	if ((phy->type == BCM43xx_PHYTYPE_G) &&
+	    (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_PACTRL)) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x6E),
+				  (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x6E))
+				   & 0xE000) | 0x3CF);
 	}
-	bcm43xx_shm_clear_tssi(dev);
 }
 
 static void bcm43xx_phy_initb2(struct bcm43xx_wldev *dev)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/Makefile	2007-05-12 01:02:00.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile	2007-05-12 01:03:22.000000000 +0200
@@ -15,4 +15,5 @@ bcm43xx-mac80211-objs := bcm43xx_main.o 
 		         bcm43xx_leds.o \
 		         bcm43xx_xmit.o \
 		         bcm43xx_lo.o \
+		         bcm43xx_wa.o \
 		         $(bcm43xx-mac80211-obj-y)


-- 
Greetings Michael.


From gavron at Wetwork.Net  Sat May 12 01:10:21 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 11 May 2007 16:10:21 -0700
Subject: 2.6.21.1 works with ifconfig; fails with ifup
In-Reply-To: <1178920888.2853.23.camel@dv>
References: <463FDAC2.7070506@Wetwork.Net> <1178920888.2853.23.camel@dv>
Message-ID: <4644F7DD.6030109@Wetwork.Net>

Pavel, thank you for the detailed response.  I will dedicate some time 
this weekend to capturing using a serial console.

Again, thanks!

Ehud

Pavel Roskin wrote:
> Hello!
>
> On Mon, 2007-05-07 at 19:04 -0700, Ehud Gavron wrote:
>   
>> 2.6.21.1 ifup eth1 panics and is repeatable.
>>     
>
> I understand it's Fedora Core 6.  /sbin/ifup should be a script.  You
> can trace it by running it as
>
> bash -x /sbin/ifup eth1
>
>   
>> Unfortunately I can't get netconsole working because the 2.6.21.1 kernel 
>> doesn't like my hardwired Ethernet card for no good reason.  TXcount 
>> increases, RXcount does not.  tcpdump shows nothing.  Rebooting in 
>> 2.6.20-1.2948.fc6 restores full functionality.
>>     
>
> That should go to netdev list or to a list specifically about that
> driver.  But I don't think netconsole is the best tool to debug other
> networking drivers.
>
> Please see Documentation/oops-tracing.txt in the Linux sources.  If you
> have serial console, please use it.  If you can use local console,
> that's the second best choice.  Use "dmesg -n 8" to enable all messages
> on the console.  Switch to the first virtual console by Ctrl-Alt-F1 if X
> Window System is running.  To maximize the number of lines, set the
> smallest font, e.g.
>
> setfont drdos8x8
>
> Reproduce the panic and write down the messages.  Or you can make a
> photograph of the screen.
>
> Documentation/oops-tracing.txt also suggests kdump.  I haven't tried it,
> but I think it would work.
>
>   
>> If I do the following it works flawlessly:
>> ifconfig eth1 up
>> iwconfig eth1 key wep-key-here
>> iwconfig eth1 essid any   (or "real-essid-here")
>> ifconfig eth1 10.1.1.5 netmask 255.255.255.0
>> route add -net 0.0.0.0/0 gw 10.1.1.1
>>
>>
>> If I do the following I get a kernel panic:
>> ifup eth1
>>     
>
> That's a clear sign that it's caused by something other that bringing
> the interface up.
>
>   
>> [root at egdell ~]# more /etc/sysconfig/network-scripts/ifcfg-eth1
>> # Broadcom Corporation BCM4306 802.11b/g Wireless LAN Controller
>> TYPE=wireless
>> DEVICE=eth1
>> ONBOOT=no
>> BOOTPROTO=static
>> ADDRESS=10.1.1.5
>> NETMASK=255.255.255.255
>> GATEWAY=10.1.1.1
>> ESSID=wetwork
>> KEY=xxxa0055ae775e80fd864exxxx
>> #RATE=24
>> #CHANNEL=6
>>     
>
> This looks good.
>
>   
>> While I can't use netconsole, I can use strace.  Accordingly attached is 
>> the output from
>> strace ifup eth1 > nothing.txt 2>output.txt
>>     
>
> That's not very useful.  The interesting stuff is done in other
> processes.  You could try to follow them by adding "-f" and "-F" flags.
> But I think the first priority should be getting the kernel messages.
>
>   
>> If anyone has any ideas what's wrong with the wired ethernet...
>> 09:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5752 
>> Gigabit Ethernet PCI Express (rev 02)
>>     
>
> Please ask in netdev.
>
>   
>> If I don't get any better suggestions I'll remake oldconfig but answer N 
>> to all the new stuff and see if that makes a difference.  There are a 
>> couple of new GE drivers, some experimental, and I'm guessing (with no 
>> basis for the guess) that there may be interference there.
>>     
>
> I would not change anything unless all possibilities for tracking down
> the bug are exhausted.  The bug can just disappear temporarily to appear
> later.
>
>   
>> access("/sbin/ip", X_OK)                = 0
>> access("/sbin/ip", R_OK)                = 0
>> rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
>> _llseek(255, -1124, [9428], SEEK_CUR)   = 0
>> clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|
>> SIGCHLD, child_tidptr=0xb7f5d918) = 3400
>> rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
>> rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
>> rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
>> rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
>> rt_sigaction(SIGINT, {0x807a8c0, [], 0}, {SIG_DFL}, 8) = 0
>> waitpid(-1, 
>>     
>
> Either it was /sbin/ip that triggered the crash, or the end of the log
> wasn't written to the hard drive.  Generally, the console is designed to
> be more survivable than the storage devices in case of a panic, so using
> the console is preferred.
>
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070511/9925497b/attachment.bin>

From mb at bu3sch.de  Sat May 12 17:50:56 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 12 May 2007 17:50:56 +0200
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <200705120107.02627.mb@bu3sch.de>
References: <20070423202530.2829f309@localhost>
	<200705111224.33898.mb@bu3sch.de> <200705120107.02627.mb@bu3sch.de>
Message-ID: <200705121750.57090.mb@bu3sch.de>

On Saturday 12 May 2007 01:07:01 Michael Buesch wrote:
> On Friday 11 May 2007 12:24:33 Michael Buesch wrote:
> > On Monday 23 April 2007 20:30:41 Stefano Brivio wrote:
> > > This patch fixes A/G PHYs setup and initialization routines. Let's move
> > > the so-called workarounds in a separate file, in order to avoid clobbering
> > > bcm43xx_phy.c.

Here's latest version of the patch.
Yet another few bugs fixed.

Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c	2007-05-12 16:29:05.000000000 +0200
@@ -0,0 +1,668 @@
+/*
+
+  Broadcom BCM43xx wireless driver
+
+  PHY workarounds.
+
+  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
+  Copyright (c) 2005-2007 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de>
+  Copyright (c) 2005, 2006 Danny van Dyk <kugelfang at gentoo.org>
+  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi at waterwave.ch>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+
+*/
+
+#include "bcm43xx.h"
+#include "bcm43xx_main.h"
+#include "bcm43xx_tables.h"
+#include "bcm43xx_phy.h"
+#include "bcm43xx_wa.h"
+
+static void bcm43xx_wa_papd(struct bcm43xx_wldev *dev)
+{
+	u16 backup;
+
+	backup = bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0, 7);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_APHY, 0, 0);
+	bcm43xx_dummy_transmission(dev);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0, backup);
+}
+
+static void bcm43xx_wa_auxclipthr(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E), 0x3800);
+}
+
+static void bcm43xx_wa_afcdac(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x0035, 0x03FF);
+	bcm43xx_phy_write(dev, 0x0036, 0x0400);
+}
+
+static void bcm43xx_wa_txdc_offset(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 0, 0x0051);
+}
+
+void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	bcm43xx_phy_write(dev, BCM43xx_PHY_LNAHPFCTL, 0x1FF9);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+		bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & 0xFF0F);
+	if (phy->rev <= 2)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_LPFGAIN, 0, 0x1FBF);
+	bcm43xx_radio_write16(dev, 0x0002, 0x1FBF);
+
+	bcm43xx_phy_write(dev, 0x0024, 0x4680);
+	bcm43xx_phy_write(dev, 0x0020, 0x0003);
+	bcm43xx_phy_write(dev, 0x001D, 0x0F40);
+	bcm43xx_phy_write(dev, 0x001F, 0x1C00);
+	if (phy->rev <= 3)
+		bcm43xx_phy_write(dev, 0x002A,
+			(bcm43xx_phy_read(dev, 0x002A) & 0x00FF) | 0x0400);
+	else if (phy->rev == 5) {
+		bcm43xx_phy_write(dev, 0x002A,
+			(bcm43xx_phy_read(dev, 0x002A) & 0x00FF) | 0x1A00);
+		bcm43xx_phy_write(dev, 0x00CC, 0x2121);
+	}
+	if (phy->rev >= 3)
+		bcm43xx_phy_write(dev, 0x00BA, 0x3ED5);
+}
+
+static void bcm43xx_wa_divider(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x002B, bcm43xx_phy_read(dev, 0x002B) & ~0x0100);
+	bcm43xx_phy_write(dev, 0x008E, 0x58C1);
+}
+
+static void bcm43xx_wa_gt(struct bcm43xx_wldev *dev) /* Gain table. */
+{
+	if (dev->phy.rev <= 2) {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 0, 15);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 1, 31);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 2, 42);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 3, 48);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 4, 58);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 0, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 1, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 3, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 4, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 5, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 6, 25);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 0, 3);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 1, 3);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 2, 7);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 0, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 1, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 3, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 4, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 5, 21);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 6, 25);
+	}
+}
+
+static void bcm43xx_wa_rssi_lt(struct bcm43xx_wldev *dev) /* RSSI lookup table */
+{
+	int i;
+
+	for (i = 0; i < 8; i++)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_RSSI, i, i + 8);
+	for (i = 8; i < 16; i++)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_RSSI, i, i - 8);
+}
+
+static void bcm43xx_wa_analog(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->analog > 2) {
+		if (phy->type == BCM43xx_PHYTYPE_A)
+			bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, 0x1808);
+		else
+			bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, 0x1000);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 3, 0x1044);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 4, 0x7201);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 6, 0x0040);
+	}
+}
+
+static void bcm43xx_wa_dac(struct bcm43xx_wldev *dev)
+{
+	if (dev->phy.analog == 1)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1,
+			(bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 1) & ~0x0034) | 0x0008);
+	else
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1,
+			(bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 1) & ~0x0078) | 0x0010);
+}
+
+static void bcm43xx_wa_fft(struct bcm43xx_wldev *dev) /* Fine frequency table */
+{
+	int i;
+
+	if (dev->phy.type == BCM43xx_PHYTYPE_A)
+		for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqa[i]);
+	else
+		for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqg[i]);
+}
+
+static void bcm43xx_wa_nft(struct bcm43xx_wldev *dev) /* Noise figure table */
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+	int i;
+
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		if (phy->rev == 2)
+			for (i = 0; i < BCM43xx_TAB_NOISEA2_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea2[i]);
+		else
+			for (i = 0; i < BCM43xx_TAB_NOISEA3_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea3[i]);
+	} else {
+		if (phy->rev == 1)
+			for (i = 0; i < BCM43xx_TAB_NOISEG1_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg1[i]);
+		else
+			for (i = 0; i < BCM43xx_TAB_NOISEG2_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg2[i]);
+	}
+}
+
+static void bcm43xx_wa_rt(struct bcm43xx_wldev *dev) /* Rotor table */
+{
+	int i;
+
+	for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
+		bcm43xx_ofdmtab_write32(dev, BCM43xx_OFDMTAB_ROTOR, i, bcm43xx_tab_rotor[i]);
+}
+
+static void bcm43xx_wa_nst(struct bcm43xx_wldev *dev) /* Noise scale table */
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+	int i;
+
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		if (phy->rev <= 1)
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, 0);
+		else if (phy->rev == 2)
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescalea2[i]);
+		else if (phy->rev == 3)
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescalea3[i]);
+		else
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescaleg3[i]);
+	} else {
+		if (phy->rev >= 6) {
+			if (bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & BCM43xx_PHY_ENCORE_EN)
+				for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+					bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+						i, bcm43xx_tab_noisescaleg3[i]);
+			else
+				for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+					bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+						i, bcm43xx_tab_noisescaleg2[i]);
+		} else {
+			for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+							i, bcm43xx_tab_noisescaleg1[i]);
+		}
+	}
+}
+
+static void bcm43xx_wa_art(struct bcm43xx_wldev *dev) /* ADV retard table */
+{
+	int i;
+
+	for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
+			bcm43xx_ofdmtab_write32(dev, BCM43xx_OFDMTAB_ADVRETARD,
+				i, bcm43xx_tab_retard[i]);
+}
+
+static void bcm43xx_wa_txlna_gain(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 13, 0x0000);
+}
+
+static void bcm43xx_wa_crs_reset(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x002C, 0x0064);
+}
+
+static void bcm43xx_wa_2060txlna_gain(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_hf_write(dev, bcm43xx_hf_read(dev) |
+			 BCM43xx_HF_2060W);
+}
+
+static void bcm43xx_wa_lms(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, 0x0055,
+		(bcm43xx_phy_read(dev, 0x0055) & 0xFFC0) | 0x0004);
+}
+
+static void bcm43xx_wa_mixedsignal(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1, 3);
+}
+
+static void bcm43xx_wa_msst(struct bcm43xx_wldev *dev) /* Min sigma square table */
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+	int i;
+	const u16 *tab;
+
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		tab = bcm43xx_tab_sigmasqr1;
+	} else if (phy->type == BCM43xx_PHYTYPE_G) {
+		tab = bcm43xx_tab_sigmasqr2;
+	} else {
+		assert(0);
+		return;
+	}
+
+	for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++) {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_MINSIGSQ,
+					i, tab[i]);
+	}
+}
+
+static void bcm43xx_wa_iqadc(struct bcm43xx_wldev *dev)
+{
+	if (dev->phy.analog == 4)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 0,
+			bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 0) & ~0xF000);
+}
+
+static void bcm43xx_wa_crs_ed(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->rev == 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1, 0x4F19);
+	} else if (phy->rev == 2) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1_R1, 0x1861);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES2_R1, 0x1861);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_ANTDWELL,
+				  bcm43xx_phy_read(dev, BCM43xx_PHY_ANTDWELL)
+				  | 0x0800);
+	} else {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1_R1, 0x0098);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES2_R1, 0x0070);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xC9), 0x0080);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_ANTDWELL,
+				  bcm43xx_phy_read(dev, BCM43xx_PHY_ANTDWELL)
+				  | 0x0800);
+	}
+}
+
+static void bcm43xx_wa_crs_thr(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) & ~0x03C0) | 0xD000);
+}
+
+static void bcm43xx_wa_crs_blank(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x2C), 0x005A);
+}
+
+static void bcm43xx_wa_cck_shiftbits(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS, 0x0026);
+}
+
+static void bcm43xx_wa_wrssi_offset(struct bcm43xx_wldev *dev)
+{
+	int i;
+
+	if (dev->phy.rev == 1) {
+		for (i = 0; i < 16; i++) {
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_WRSSI_R1,
+						i, 0x0020);
+		}
+	} else {
+		for (i = 0; i < 32; i++) {
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_WRSSI,
+						i, 0x0820);
+		}
+	}
+}
+
+static void bcm43xx_wa_txpuoff_rxpuon(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_0F, 2, 15);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_0F, 3, 20);
+}
+
+static void bcm43xx_wa_altagc(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->rev == 1) {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 0, 254);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 1, 13);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 3, 25);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 0, 0x2710);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 1, 0x9B83);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 2, 0x9B83);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 3, 0x0F8D);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_LMS, 4);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0, 254);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 1, 13);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 2, 19);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 3, 25);
+	}
+
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS_WA,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_CCKSHIFTBITS_WA) & ~0xFF00) | 0x5700);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1A),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1A)) & ~0x007F) | 0x000F);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1A),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1A)) & ~0x3F80) | 0x2B80);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_ANTWRSETT) & 0xF0FF) | 0x0300);
+	bcm43xx_radio_write16(dev, 0x7A,
+		bcm43xx_radio_read16(dev, 0x7A) | 0x0008);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_N1P1GAIN,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_N1P1GAIN) & ~0x000F) | 0x0008);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_P1P2GAIN,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_P1P2GAIN) & ~0x0F00) | 0x0600);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_N1N2GAIN,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_N1N2GAIN) & ~0x0F00) | 0x0700);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_N1P1GAIN,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_N1P1GAIN) & ~0x0F00) | 0x0100);
+	if (phy->rev == 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_N1N2GAIN,
+				  (bcm43xx_phy_read(dev, BCM43xx_PHY_N1N2GAIN)
+				   & ~0x000F) | 0x0007);
+	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0x00FF) | 0x001C);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0x3F00) | 0x0200);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x96)) & ~0x00FF) | 0x001C);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89)) & ~0x00FF) | 0x0020);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89)) & ~0x3F00) | 0x0200);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82)) & ~0x00FF) | 0x002E);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x96)) & ~0xFF00) | 0x1A00);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81)) & ~0x00FF) | 0x0028);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81)) & ~0xFF00) | 0x2C00);
+	if (phy->rev == 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_PEAK_COUNT, 0x092B);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x001E) | 0x0002);
+	} else {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x001E);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1F), 0x287A);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & ~0x000F) | 0x0004);
+		if (phy->rev >= 6) {
+			bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x22), 0x287A);
+			bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+				(bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & ~0xF000) | 0x3000);
+		}
+	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_DIVSRCHIDX,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_DIVSRCHIDX) & 0x7F7F) | 0x7874);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E), 0x1C00);
+	if (phy->rev == 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_DIVP1P2GAIN,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_DIVP1P2GAIN) & ~0x0F00) | 0x0600);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8B), 0x005E);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT,
+			(bcm43xx_phy_read(dev, BCM43xx_PHY_ANTWRSETT) & ~0x00FF) | 0x001E);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8D), 0x0002);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 0, 0);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 1, 7);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 2, 16);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 3, 28);
+	} else {
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 0, 0);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 1, 7);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 2, 16);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 3, 28);
+	}
+	if (phy->rev >= 6) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x26)) & ~0x0003);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
+			bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x26)) & ~0x1000);
+	}
+}
+
+static void bcm43xx_wa_tr_ltov(struct bcm43xx_wldev *dev) /* TR Lookup Table Original Values */
+{
+	bcm43xx_gtab_write(dev, BCM43xx_GTAB_ORIGTR, 0, 0xC480);
+}
+
+static void bcm43xx_wa_cpll_nonpilot(struct bcm43xx_wldev *dev)
+{
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_11, 0, 0);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_11, 1, 0);
+}
+
+static void bcm43xx_wa_rssi_adc(struct bcm43xx_wldev *dev)
+{
+	if (dev->phy.analog == 4)
+		bcm43xx_phy_write(dev, 0x00DC, 0x7454);
+}
+
+static void bcm43xx_wa_boards_a(struct bcm43xx_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+
+	if (bus->board_vendor == SSB_BOARDVENDOR_BCM &&
+	    bus->board_type == SSB_BOARD_BU4306 &&
+	    bus->board_rev < 0x30) {
+		bcm43xx_phy_write(dev, 0x0010, 0xE000);
+		bcm43xx_phy_write(dev, 0x0013, 0x0140);
+		bcm43xx_phy_write(dev, 0x0014, 0x0280);
+	} else {
+		if (bus->board_type == SSB_BOARD_MP4318 &&
+		    bus->board_rev < 0x20) {
+			bcm43xx_phy_write(dev, 0x0013, 0x0210);
+			bcm43xx_phy_write(dev, 0x0014, 0x0840);
+		} else {
+			bcm43xx_phy_write(dev, 0x0013, 0x0140);
+			bcm43xx_phy_write(dev, 0x0014, 0x0280);
+		}
+		if (dev->phy.rev <= 4)
+			bcm43xx_phy_write(dev, 0x0010, 0xE000);
+		else
+			bcm43xx_phy_write(dev, 0x0010, 0x2000);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 1, 0x0039);
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_APHY, 7, 0x0040);
+	}
+}
+
+static void bcm43xx_wa_boards_g(struct bcm43xx_wldev *dev)
+{
+	struct ssb_bus *bus = dev->dev->bus;
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (bus->board_vendor != SSB_BOARDVENDOR_BCM ||
+	    bus->board_type != SSB_BOARD_BU4306 ||
+	    bus->board_rev != 0x17) {
+		if (phy->rev < 2) {
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX_R1, 1, 0x0002);
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX_R1, 2, 0x0001);
+		} else {
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 1, 0x0002);
+			bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 2, 0x0001);
+			if ((bus->sprom.r1.boardflags_lo & BCM43xx_BFL_EXTLNA) &&
+			    (phy->rev >= 7)) {
+				bcm43xx_phy_write(dev, BCM43xx_PHY_EXTG(0x11),
+					bcm43xx_phy_read(dev, BCM43xx_PHY_EXTG(0x11)) & 0xF7FF);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0020, 0x0001);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0021, 0x0001);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0022, 0x0001);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0023, 0x0000);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0000, 0x0000);
+				bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0003, 0x0002);
+			}
+		}
+	}
+	if (bus->sprom.r1.boardflags_lo & BCM43xx_BFL_FEM) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_GTABCTL, 0x3120);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_GTABDATA, 0xC480);
+	}
+}
+
+void bcm43xx_wa_all(struct bcm43xx_wldev *dev)
+{
+	struct bcm43xx_phy *phy = &dev->phy;
+
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		switch (phy->rev) {
+		case 2:
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_auxclipthr(dev);
+			bcm43xx_wa_afcdac(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_divider(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_fft(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_rt(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_art(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			bcm43xx_wa_crs_reset(dev);
+			bcm43xx_wa_2060txlna_gain(dev);
+			bcm43xx_wa_lms(dev);
+			break;
+		case 3:
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_mixedsignal(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			break;
+		case 5:
+			bcm43xx_wa_iqadc(dev);
+		case 6:
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			break;
+		case 7:
+			bcm43xx_wa_iqadc(dev);
+			bcm43xx_wa_papd(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_txdc_offset(dev);
+			bcm43xx_wa_initgains(dev);
+			bcm43xx_wa_dac(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_gt(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			bcm43xx_wa_txlna_gain(dev);
+			bcm43xx_wa_rssi_adc(dev);
+		default:
+			assert(0);
+		}
+		bcm43xx_wa_boards_a(dev);
+	} else if (phy->type == BCM43xx_PHYTYPE_G) {
+		switch (phy->rev) {
+		case 1://XXX review rev1
+			bcm43xx_wa_crs_ed(dev);
+			bcm43xx_wa_crs_thr(dev);
+			bcm43xx_wa_crs_blank(dev);
+			bcm43xx_wa_cck_shiftbits(dev);
+			bcm43xx_wa_fft(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_rt(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_art(dev);
+			bcm43xx_wa_wrssi_offset(dev);
+			bcm43xx_wa_altagc(dev);
+			break;
+		case 2:
+		case 6:
+		case 7:
+		case 8:
+			bcm43xx_wa_tr_ltov(dev);
+			bcm43xx_wa_crs_ed(dev);
+			bcm43xx_wa_rssi_lt(dev);
+			bcm43xx_wa_nft(dev);
+			bcm43xx_wa_nst(dev);
+			bcm43xx_wa_msst(dev);
+			bcm43xx_wa_wrssi_offset(dev);
+			bcm43xx_wa_altagc(dev);
+			bcm43xx_wa_analog(dev);
+			bcm43xx_wa_txpuoff_rxpuon(dev);
+			break;
+		default:
+			assert(0);
+		}
+		bcm43xx_wa_boards_g(dev);
+	} else { /* No N PHY support so far */
+		assert(0);
+	}
+
+	bcm43xx_wa_cpll_nonpilot(dev);
+}
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h	2007-05-12 16:29:05.000000000 +0200
@@ -0,0 +1,7 @@
+#ifndef BCM43xx_WA_H_
+#define BCM43xx_WA_H_
+
+void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev);
+void bcm43xx_wa_all(struct bcm43xx_wldev *dev);
+
+#endif /* BCM43xx_WA_H_ */
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c	2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c	2007-05-12 16:29:05.000000000 +0200
@@ -230,7 +230,7 @@ const u16 bcm43xx_tab_noisea2[] = {
 };
 
 const u16 bcm43xx_tab_noisea3[] = {
-	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
+	0x5E5E, 0x5E5E, 0x5E5E, 0x3F48,
 	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
 };
 
@@ -244,6 +244,26 @@ const u16 bcm43xx_tab_noiseg2[] = {
 	0x0000, 0x0000, 0x0000, 0x0000,
 };
 
+const u16 bcm43xx_tab_noisescalea2[] = {
+	0x6767, 0x6767, 0x6767, 0x6767, /* 0 */
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6700, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x6767, 0x6767, /* 16 */
+	0x6767, 0x6767, 0x6767, 0x6767,
+	0x6767, 0x6767, 0x0067,
+};
+
+const u16 bcm43xx_tab_noisescalea3[] = {
+	0x2323, 0x2323, 0x2323, 0x2323, /* 0 */
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2300, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x2323, 0x2323, /* 16 */
+	0x2323, 0x2323, 0x2323, 0x2323,
+	0x2323, 0x2323, 0x0023,
+};
+
 const u16 bcm43xx_tab_noisescaleg1[] = {
 	0x6C77, 0x5162, 0x3B40, 0x3335, /* 0 */
 	0x2F2D, 0x2A2A, 0x2527, 0x1F21,
@@ -255,7 +275,7 @@ const u16 bcm43xx_tab_noisescaleg1[] = {
 };
 
 const u16 bcm43xx_tab_noisescaleg2[] = {
-	0xD8DD, 0xCBD4, 0xBCC0, 0XB6B7, /* 0 */
+	0xD8DD, 0xCBD4, 0xBCC0, 0xB6B7, /* 0 */
 	0xB2B0, 0xADAD, 0xA7A9, 0x9FA1,
 	0x969B, 0x9195, 0x8F8F, 0x8A8A,
 	0x8A8A, 0x8A00, 0x8A8A, 0x8F8A,
@@ -308,6 +328,27 @@ const u16 bcm43xx_tab_sigmasqr2[] = {
 	0x00DE,
 };
 
+const u16 bcm43xx_tab_rssiagc1[] = {
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8, /* 0 */
+	0xFFF8, 0xFFF9, 0xFFFC, 0xFFFE,
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+	0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+};
+
+const u16 bcm43xx_tab_rssiagc2[] = {
+	0x0820, 0x0820, 0x0920, 0x0C38, /* 0 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38, /* 16 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38, /* 32 */
+	0x0820, 0x0820, 0x0820, 0x0820,
+	0x0820, 0x0820, 0x0920, 0x0A38,
+	0x0820, 0x0820, 0x0820, 0x0820,
+};
 
 static inline void assert_sizes(void)
 {
@@ -319,34 +360,59 @@ static inline void assert_sizes(void)
 	BUILD_BUG_ON(BCM43xx_TAB_NOISEA3_SIZE != ARRAY_SIZE(bcm43xx_tab_noisea3));
 	BUILD_BUG_ON(BCM43xx_TAB_NOISEG1_SIZE != ARRAY_SIZE(bcm43xx_tab_noiseg1));
 	BUILD_BUG_ON(BCM43xx_TAB_NOISEG2_SIZE != ARRAY_SIZE(bcm43xx_tab_noiseg2));
-	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg1));
-	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
-	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
+	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg1));
+	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
+	BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
 	BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE != ARRAY_SIZE(bcm43xx_tab_sigmasqr1));
 	BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE != ARRAY_SIZE(bcm43xx_tab_sigmasqr2));
+	BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC1_SIZE != ARRAY_SIZE(bcm43xx_tab_rssiagc1));
+	BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC2_SIZE != ARRAY_SIZE(bcm43xx_tab_rssiagc2));
 }
 
 
 u16 bcm43xx_ofdmtab_read16(struct bcm43xx_wldev *dev, u16 table, u16 offset)
 {
-	assert_sizes();
+	struct bcm43xx_phy *phy = &dev->phy;
+	u16 addr;
+
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 1;
+	}
+	phy->ofdm_addr = addr;
 
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
 	return bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI);
+	assert_sizes();
 }
 
 void bcm43xx_ofdmtab_write16(struct bcm43xx_wldev *dev, u16 table,
 			     u16 offset, u16 value)
 {
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+	struct bcm43xx_phy *phy = &dev->phy;
+	u16 addr;
+
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 2;
+	}
+	phy->ofdm_addr = addr;
 	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
 }
 
 u32 bcm43xx_ofdmtab_read32(struct bcm43xx_wldev *dev, u16 table, u16 offset)
 {
+	struct bcm43xx_phy *phy = &dev->phy;
 	u32 ret;
+	u16 addr;
 
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 1;
+	}
+	phy->ofdm_addr = addr;
 	ret = bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEQ);
 	ret <<= 16;
 	ret |= bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI);
@@ -357,9 +423,17 @@ u32 bcm43xx_ofdmtab_read32(struct bcm43x
 void bcm43xx_ofdmtab_write32(struct bcm43xx_wldev *dev, u16 table,
 			     u16 offset, u32 value)
 {
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
-	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
+	struct bcm43xx_phy *phy = &dev->phy;
+	u16 addr;
+
+	addr = table + offset;
+	if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr);
+		phy->ofdm_valid = 2;
+	}
+	phy->ofdm_addr = addr;
 	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEQ, (value >> 16));
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
 }
 
 u16 bcm43xx_gtab_read(struct bcm43xx_wldev *dev, u16 table, u16 offset)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h	2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h	2007-05-12 16:29:05.000000000 +0200
@@ -591,6 +591,10 @@ struct bcm43xx_phy {
 	u16 lofcal;
 
 	u16 initval;//FIXME rename?
+
+	/* OFDM address read/write caching for hardware auto-increment. */
+	u16 ofdm_addr;
+	u8 ofdm_valid; /* 0: invalid, 1: read, 2: write */
 };
 
 /* Data structures for DMA transmission, per 80211 core. */
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c	2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c	2007-05-12 16:29:05.000000000 +0200
@@ -3127,6 +3127,9 @@ static void setup_struct_phy_for_init(st
 	spin_lock_init(&phy->lock);
 	phy->interfmode = BCM43xx_INTERFMODE_NONE;
 	phy->channel = 0xFF;
+
+	/* OFDM address caching. */
+	phy->ofdm_valid = 0;
 }
 
 static void setup_struct_wldev_for_init(struct bcm43xx_wldev *dev)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h	2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h	2007-05-12 16:29:05.000000000 +0200
@@ -28,8 +28,11 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_PWRDOWN		BCM43xx_PHY_OFDM(0x03)	/* Powerdown */
 #define BCM43xx_PHY_CRSTHRES1		BCM43xx_PHY_OFDM(0x06)	/* CRS Threshold 1 */
 #define BCM43xx_PHY_LNAHPFCTL		BCM43xx_PHY_OFDM(0x1C)	/* LNA/HPF control */
+#define BCM43xx_PHY_LPFGAINCTL		BCM43xx_PHY_OFDM(0x20)	/* LPF Gain control */
 #define BCM43xx_PHY_ADIVRELATED		BCM43xx_PHY_OFDM(0x27)	/* FIXME rename */
 #define BCM43xx_PHY_CRS0		BCM43xx_PHY_OFDM(0x29)
+#define  BCM43xx_PHY_CRS0_EN		0x4000
+#define BCM43xx_PHY_PEAK_COUNT		BCM43xx_PHY_OFDM(0x30)
 #define BCM43xx_PHY_ANTDWELL		BCM43xx_PHY_OFDM(0x2B)	/* Antenna dwell */
 #define  BCM43xx_PHY_ANTDWELL_AUTODIV1	0x0100			/* Automatic RX diversity start antenna */
 #define BCM43xx_PHY_ENCORE		BCM43xx_PHY_OFDM(0x49)	/* "Encore" (RangeMax / BroadRange) */
@@ -38,6 +41,7 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_OFDM61		BCM43xx_PHY_OFDM(0x61)	/* FIXME rename */
 #define  BCM43xx_PHY_OFDM61_10		0x0010			/* FIXME rename */
 #define BCM43xx_PHY_IQBAL		BCM43xx_PHY_OFDM(0x69)	/* I/Q balance */
+#define BCM43xx_PHY_BBTXDC_BIAS		BCM43xx_PHY_OFDM(0x6B)	/* Baseband TX DC bias */
 #define BCM43xx_PHY_OTABLECTL		BCM43xx_PHY_OFDM(0x72)	/* OFDM table control (see below) */
 #define  BCM43xx_PHY_OTABLEOFF		0x03FF			/* OFDM table offset (see below) */
 #define  BCM43xx_PHY_OTABLENR		0xFC00			/* OFDM table number (see below) */
@@ -45,6 +49,9 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_OTABLEI		BCM43xx_PHY_OFDM(0x73)	/* OFDM table data I */
 #define BCM43xx_PHY_OTABLEQ		BCM43xx_PHY_OFDM(0x74)	/* OFDM table data Q */
 #define BCM43xx_PHY_HPWR_TSSICTL	BCM43xx_PHY_OFDM(0x78)	/* Hardware power TSSI control */
+#define BCM43xx_PHY_ADCCTL		BCM43xx_PHY_OFDM(0x7A)	/* ADC control */
+#define BCM43xx_PHY_IDLE_TSSI		BCM43xx_PHY_OFDM(0x7B)
+#define BCM43xx_PHY_A_TEMP_SENSE	BCM43xx_PHY_OFDM(0x7C)	/* A PHY temperature sense */
 #define BCM43xx_PHY_NRSSITHRES		BCM43xx_PHY_OFDM(0x8A)	/* NRSSI threshold */
 #define BCM43xx_PHY_ANTWRSETT		BCM43xx_PHY_OFDM(0x8C)	/* Antenna WR settle */
 #define  BCM43xx_PHY_ANTWRSETT_ARXDIV	0x2000			/* Automatic RX diversity enabled */
@@ -55,6 +62,8 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_N1N2GAIN		BCM43xx_PHY_OFDM(0xA2)
 #define BCM43xx_PHY_CLIPTHRES		BCM43xx_PHY_OFDM(0xA3)
 #define BCM43xx_PHY_CLIPN1P2THRES	BCM43xx_PHY_OFDM(0xA4)
+#define BCM43xx_PHY_CCKSHIFTBITS_WA	BCM43xx_PHY_OFDM(0xA5)	/* CCK shiftbits workaround, FIXME rename */
+#define BCM43xx_PHY_CCKSHIFTBITS	BCM43xx_PHY_OFDM(0xA7)  /* FIXME rename */
 #define BCM43xx_PHY_DIVSRCHIDX		BCM43xx_PHY_OFDM(0xA8)	/* Divider search gain/index */
 #define BCM43xx_PHY_CLIPP2THRES		BCM43xx_PHY_OFDM(0xA9)
 #define BCM43xx_PHY_CLIPP3THRES		BCM43xx_PHY_OFDM(0xAA)
@@ -128,13 +137,14 @@ struct bcm43xx_wldev;
 #define BCM43xx_OFDMTAB_DC		BCM43xx_OFDMTAB(0x0E, 7)
 #define BCM43xx_OFDMTAB_PWRDYN2		BCM43xx_OFDMTAB(0x0E, 12)
 #define BCM43xx_OFDMTAB_LNAGAIN		BCM43xx_OFDMTAB(0x0E, 13)
-//TODO
+#define BCM43xx_OFDMTAB_UNKNOWN_0F	BCM43xx_OFDMTAB(0x0F, 0)	//TODO rename
+#define BCM43xx_OFDMTAB_UNKNOWN_APHY	BCM43xx_OFDMTAB(0x0F, 7)	//TODO rename
 #define BCM43xx_OFDMTAB_LPFGAIN		BCM43xx_OFDMTAB(0x0F, 12)
 #define BCM43xx_OFDMTAB_RSSI		BCM43xx_OFDMTAB(0x10, 0)
-//TODO
+#define BCM43xx_OFDMTAB_UNKNOWN_11	BCM43xx_OFDMTAB(0x11, 4)	//TODO rename
 #define BCM43xx_OFDMTAB_AGC1_R1		BCM43xx_OFDMTAB(0x13, 0)
-#define BCM43xx_OFDMTAB_GAINX_R1	BCM43xx_OFDMTAB(0x14, 0)	//TODO rename
-#define BCM43xx_OFDMTAB_MINSIGSQ	BCM43xx_OFDMTAB(0x14, 1)
+#define BCM43xx_OFDMTAB_GAINX_R1	BCM43xx_OFDMTAB(0x14, 0)	//TODO remove!
+#define BCM43xx_OFDMTAB_MINSIGSQ	BCM43xx_OFDMTAB(0x14, 0)
 #define BCM43xx_OFDMTAB_AGC3_R1		BCM43xx_OFDMTAB(0x15, 0)
 #define BCM43xx_OFDMTAB_WRSSI_R1	BCM43xx_OFDMTAB(0x15, 4)
 #define BCM43xx_OFDMTAB_TSSI		BCM43xx_OFDMTAB(0x15, 0)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h	2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h	2007-05-12 16:29:05.000000000 +0200
@@ -17,12 +17,18 @@ extern const u16 bcm43xx_tab_noisea3[];
 extern const u16 bcm43xx_tab_noiseg1[];
 #define BCM43xx_TAB_NOISEG2_SIZE	8
 extern const u16 bcm43xx_tab_noiseg2[];
-#define BCM43xx_TAB_NOISESCALEG_SIZE	27
+#define BCM43xx_TAB_NOISESCALE_SIZE	27
+extern const u16 bcm43xx_tab_noisescalea2[];
+extern const u16 bcm43xx_tab_noisescalea3[];
 extern const u16 bcm43xx_tab_noisescaleg1[];
 extern const u16 bcm43xx_tab_noisescaleg2[];
 extern const u16 bcm43xx_tab_noisescaleg3[];
 #define BCM43xx_TAB_SIGMASQR_SIZE	53
 extern const u16 bcm43xx_tab_sigmasqr1[];
 extern const u16 bcm43xx_tab_sigmasqr2[];
+#define BCM43xx_TAB_RSSIAGC1_SIZE	16
+extern const u16 bcm43xx_tab_rssiagc1[];
+#define BCM43xx_TAB_RSSIAGC2_SIZE	48
+extern const u16 bcm43xx_tab_rssiagc2[];
 
 #endif /* BCM43xx_TABLES_H_ */
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c	2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c	2007-05-12 16:29:05.000000000 +0200
@@ -34,6 +34,7 @@
 #include "bcm43xx_tables.h"
 #include "bcm43xx_power.h"
 #include "bcm43xx_lo.h"
+#include "bcm43xx_wa.h"
 
 
 static const s8 bcm43xx_tssi2dbm_b_table[] = {
@@ -559,393 +560,96 @@ static void bcm43xx_phy_init_pctl(struct
 	bcm43xx_shm_clear_tssi(dev);
 }
 
-static void bcm43xx_phy_agcsetup(struct bcm43xx_wldev *dev)
+static void bcm43xx_phy_rssiagc(struct bcm43xx_wldev *dev, u8 enable)
 {
-	struct bcm43xx_phy *phy = &dev->phy;
-	u16 offset = 0x0000;
-
-	if (phy->rev == 1)
-		offset = 0x4C00;
-
-	bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00FE);
-	bcm43xx_ofdmtab_write16(dev, offset, 1, 0x000D);
-	bcm43xx_ofdmtab_write16(dev, offset, 2, 0x0013);
-	bcm43xx_ofdmtab_write16(dev, offset, 3, 0x0019);
-
-	if (phy->rev == 1) {
-		bcm43xx_ofdmtab_write16(dev, 0x1800, 0, 0x2710);
-		bcm43xx_ofdmtab_write16(dev, 0x1801, 0, 0x9B83);
-		bcm43xx_ofdmtab_write16(dev, 0x1802, 0, 0x9B83);
-		bcm43xx_ofdmtab_write16(dev, 0x1803, 0, 0x0F8D);
-		bcm43xx_phy_write(dev, 0x0455, 0x0004);
-	}
-
-	bcm43xx_phy_write(dev, 0x04A5,
-			  (bcm43xx_phy_read(dev, 0x04A5)
-			   & 0x00FF) | 0x5700);
-	bcm43xx_phy_write(dev, 0x041A,
-			  (bcm43xx_phy_read(dev, 0x041A)
-			   & 0xFF80) | 0x000F);
-	bcm43xx_phy_write(dev, 0x041A,
-			  (bcm43xx_phy_read(dev, 0x041A)
-			   & 0xC07F) | 0x2B80);
-	bcm43xx_phy_write(dev, 0x048C,
-			  (bcm43xx_phy_read(dev, 0x048C)
-			   & 0xF0FF) | 0x0300);
-
-	bcm43xx_radio_write16(dev, 0x007A,
-			      bcm43xx_radio_read16(dev, 0x007A)
-			      | 0x0008);
-
-	bcm43xx_phy_write(dev, 0x04A0,
-			  (bcm43xx_phy_read(dev, 0x04A0)
-			   & 0xFFF0) | 0x0008);
-	bcm43xx_phy_write(dev, 0x04A1,
-			  (bcm43xx_phy_read(dev, 0x04A1)
-			   & 0xF0FF) | 0x0600);
-	bcm43xx_phy_write(dev, 0x04A2,
-			  (bcm43xx_phy_read(dev, 0x04A2)
-			   & 0xF0FF) | 0x0700);
-	bcm43xx_phy_write(dev, 0x04A0,
-			  (bcm43xx_phy_read(dev, 0x04A0)
-			   & 0xF0FF) | 0x0100);
-
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(dev, 0x04A2,
-				  (bcm43xx_phy_read(dev, 0x04A2)
-				   & 0xFFF0) | 0x0007);
-	}
-
-	bcm43xx_phy_write(dev, 0x0488,
-			  (bcm43xx_phy_read(dev, 0x0488)
-			   & 0xFF00) | 0x001C);
-	bcm43xx_phy_write(dev, 0x0488,
-			  (bcm43xx_phy_read(dev, 0x0488)
-			   & 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(dev, 0x0496,
-			  (bcm43xx_phy_read(dev, 0x0496)
-			   & 0xFF00) | 0x001C);
-	bcm43xx_phy_write(dev, 0x0489,
-			  (bcm43xx_phy_read(dev, 0x0489)
-			   & 0xFF00) | 0x0020);
-	bcm43xx_phy_write(dev, 0x0489,
-			  (bcm43xx_phy_read(dev, 0x0489)
-			   & 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(dev, 0x0482,
-			  (bcm43xx_phy_read(dev, 0x0482)
-			   & 0xFF00) | 0x002E);
-	bcm43xx_phy_write(dev, 0x0496,
-			  (bcm43xx_phy_read(dev, 0x0496)
-			   & 0x00FF) | 0x1A00);
-	bcm43xx_phy_write(dev, 0x0481,
-			  (bcm43xx_phy_read(dev, 0x0481)
-			   & 0xFF00) | 0x0028);
-	bcm43xx_phy_write(dev, 0x0481,
-			  (bcm43xx_phy_read(dev, 0x0481)
-			   & 0x00FF) | 0x2C00);
-
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(dev, 0x0430, 0x092B);
-		bcm43xx_phy_write(dev, 0x041B,
-				  (bcm43xx_phy_read(dev, 0x041B)
-				   & 0xFFE1) | 0x0002);
-	} else {
-		bcm43xx_phy_write(dev, 0x041B,
-				  bcm43xx_phy_read(dev, 0x041B)
-				  & 0xFFE1);
-		bcm43xx_phy_write(dev, 0x041F, 0x287A);
-		bcm43xx_phy_write(dev, 0x0420,
-				  (bcm43xx_phy_read(dev, 0x0420)
-				   & 0xFFF0) | 0x0004);
-	}
-
-	if (phy->rev >= 6) {
-		bcm43xx_phy_write(dev, 0x0422, 0x287A);
-		bcm43xx_phy_write(dev, 0x0420,
-				  (bcm43xx_phy_read(dev, 0x0420)
-				   & 0x0FFF) | 0x3000);
-	}
-
-	bcm43xx_phy_write(dev, 0x04A8,
-			  (bcm43xx_phy_read(dev, 0x04A8)
-			   & 0x8080) | 0x7874);
-	bcm43xx_phy_write(dev, 0x048E, 0x1C00);
-
-	offset = 0x0800;
-	if (phy->rev == 1) {
-		offset = 0x5400;
-		bcm43xx_phy_write(dev, 0x04AB,
-				  (bcm43xx_phy_read(dev, 0x04AB)
-				   & 0xF0FF) | 0x0600);
-		bcm43xx_phy_write(dev, 0x048B, 0x005E);
-		bcm43xx_phy_write(dev, 0x048C,
-				  (bcm43xx_phy_read(dev, 0x048C)
-				   & 0xFF00) | 0x001E);
-		bcm43xx_phy_write(dev, 0x048D, 0x0002);
-	}
-	bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00);
-	bcm43xx_ofdmtab_write16(dev, offset, 1, 0x07);
-	bcm43xx_ofdmtab_write16(dev, offset, 2, 0x10);
-	bcm43xx_ofdmtab_write16(dev, offset, 3, 0x1C);
-
-	if (phy->rev >= 6) {
-		bcm43xx_phy_write(dev, 0x0426,
-				  bcm43xx_phy_read(dev, 0x0426)
-				  & 0xFFFC);
-		bcm43xx_phy_write(dev, 0x0426,
-				  bcm43xx_phy_read(dev, 0x0426)
-				  & 0xEFFF);
-	}
-}
-
-static void bcm43xx_phy_setupg(struct bcm43xx_wldev *dev)
-{
-	struct ssb_bus *bus = dev->dev->bus;
-	struct bcm43xx_phy *phy = &dev->phy;
-	u16 i;
-
-	assert(phy->type == BCM43xx_PHYTYPE_G);
-	if (phy->rev == 1) {
-		bcm43xx_phy_write(dev, 0x0406, 0x4F19);
-		bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
-				  (bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS) & 0xFC3F) | 0x0340);
-		bcm43xx_phy_write(dev, 0x042C, 0x005A);
-		bcm43xx_phy_write(dev, 0x0427, 0x001A);
-
-		for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5800, i, bcm43xx_tab_finefreqg[i]);
-		for (i = 0; i < BCM43xx_TAB_NOISEG1_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noiseg1[i]);
-		for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x2000, i, bcm43xx_tab_rotor[i]);
-	} else {
-		/* nrssi values are signed 6-bit values. Not sure why we write 0x7654 here... */
-		bcm43xx_nrssi_hw_write(dev, 0xBA98, (s16)0x7654);
-
-		if (phy->rev == 2) {
-			bcm43xx_phy_write(dev, 0x04C0, 0x1861);
-			bcm43xx_phy_write(dev, 0x04C1, 0x0271);
-		} else if (phy->rev > 2) {
-			bcm43xx_phy_write(dev, 0x04C0, 0x0098);
-			bcm43xx_phy_write(dev, 0x04C1, 0x0070);
-			bcm43xx_phy_write(dev, 0x04C9, 0x0080);
-		}
-		bcm43xx_phy_write(dev, 0x042B, bcm43xx_phy_read(dev, 0x042B) | 0x800);
-
-		for (i = 0; i < 64; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x4000, i, i);
-		for (i = 0; i < BCM43xx_TAB_NOISEG2_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noiseg2[i]);
-	}
-
-	if (phy->rev <= 2)
-		for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg1[i]);
-	else if ((phy->rev >= 7) && (bcm43xx_phy_read(dev, 0x0449) & 0x0200))
-		for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg3[i]);
-	else
-		for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg2[i]);
-
-	if (phy->rev == 2)
-		for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5000, i, bcm43xx_tab_sigmasqr1[i]);
-	else if ((phy->rev > 2) && (phy->rev <= 8))
-		for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5000, i, bcm43xx_tab_sigmasqr2[i]);
-
-	if (phy->rev == 1) {
-		for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
-			bcm43xx_ofdmtab_write32(dev, 0x2400, i, bcm43xx_tab_retard[i]);
-		for (i = 0; i < 4; i++) {
-			bcm43xx_ofdmtab_write16(dev, 0x5404, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x5408, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x540C, i, 0x0020);
-			bcm43xx_ofdmtab_write16(dev, 0x5410, i, 0x0020);
-		}
-		bcm43xx_phy_agcsetup(dev);
-
-		if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-		    (bus->board_type == SSB_BOARD_BU4306) &&
-		    (bus->board_rev == 0x17))
-			return;
-
-		bcm43xx_ofdmtab_write16(dev, 0x5001, 0, 0x0002);
-		bcm43xx_ofdmtab_write16(dev, 0x5002, 0, 0x0001);
-	} else {
-		for (i = 0; i <= 0x2F; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1000, i, 0x0820);
-		bcm43xx_phy_agcsetup(dev);
-		bcm43xx_phy_read(dev, 0x0400); /* dummy read */
-		bcm43xx_phy_write(dev, 0x0403, 0x1000);
-		bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
-
-		if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-		    (bus->board_type == SSB_BOARD_BU4306) &&
-		    (bus->board_rev == 0x17))
-			return;
-
-		bcm43xx_ofdmtab_write16(dev, 0x0401, 0, 0x0002);
-		bcm43xx_ofdmtab_write16(dev, 0x0402, 0, 0x0001);
-	}
-}
-
-/* Initialize the noisescaletable for APHY */
-static void bcm43xx_phy_init_noisescaletbl(struct bcm43xx_wldev *dev)
-{
-	struct bcm43xx_phy *phy = &dev->phy;
 	int i;
 
-	for (i = 0; i < 12; i++) {
-		if (phy->rev == 2)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6767);
+	if (dev->phy.rev < 3) {
+		if (enable)
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_LNAHPFGAIN1, i, 0xFFF8);
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, 0xFFF8);
+			}
 		else
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2323);
-	}
-	if (phy->rev == 2)
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6700);
-	else
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2300);
-	for (i = 0; i < 11; i++) {
-		if (phy->rev == 2)
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6767);
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_LNAHPFGAIN1, i, bcm43xx_tab_rssiagc1[i]);
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, bcm43xx_tab_rssiagc1[i]);
+			}
+	} else {
+		if (enable)
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, 0x0820);
 		else
-			bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2323);
+			for (i = 0; i < BCM43xx_TAB_RSSIAGC2_SIZE; i++)
+				bcm43xx_ofdmtab_write16(dev,
+					BCM43xx_OFDMTAB_WRSSI, i, bcm43xx_tab_rssiagc2[i]);
 	}
-	if (phy->rev == 2)
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0067);
-	else
-		bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0023);
 }
 
-static void bcm43xx_phy_setupa(struct bcm43xx_wldev *dev)
+static void bcm43xx_phy_ww(struct bcm43xx_wldev *dev)
 {
-	struct bcm43xx_phy *phy = &dev->phy;
-	u16 i;
-
-	assert(phy->type == BCM43xx_PHYTYPE_A);
-	switch (phy->rev) {
-	case 2:
-		bcm43xx_phy_write(dev, 0x008E, 0x3800);
-		bcm43xx_phy_write(dev, 0x0035, 0x03FF);
-		bcm43xx_phy_write(dev, 0x0036, 0x0400);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-		bcm43xx_phy_write(dev, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(dev, 0x0020, bcm43xx_phy_read(dev, 0x0020) & 0xFF0F);
-		bcm43xx_ofdmtab_write16(dev, 0x3C0C, 0, 0x07BF);
-		bcm43xx_radio_write16(dev, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(dev, 0x0024, 0x4680);
-		bcm43xx_phy_write(dev, 0x0020, 0x0003);
-		bcm43xx_phy_write(dev, 0x001D, 0x0F40);
-		bcm43xx_phy_write(dev, 0x001F, 0x1C00);
-
-		bcm43xx_phy_write(dev, 0x002A,
-				  (bcm43xx_phy_read(dev, 0x002A)
-				   & 0x00FF) | 0x0400);
-		bcm43xx_phy_write(dev, 0x002B,
-				  bcm43xx_phy_read(dev, 0x002B)
-				  & 0xFBFF);
-		bcm43xx_phy_write(dev, 0x008E, 0x58C1);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-		bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 1, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 2, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 3, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 4, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 5, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 6, 0x0019);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
-
-		for (i = 0; i < 16; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x4000, i, (0x8 + i) & 0x000F);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3003, 0, 0x1044);
-		bcm43xx_ofdmtab_write16(dev, 0x3004, 0, 0x7201);
-		bcm43xx_ofdmtab_write16(dev, 0x3006, 0, 0x0040);
-		bcm43xx_ofdmtab_write16(dev, 0x3001, 0, (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0x0010) | 0x0008);
-
-		for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x5800, i, bcm43xx_tab_finefreqa[i]);
-		for (i = 0; i < BCM43xx_TAB_NOISEA2_SIZE; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noisea2[i]);
-		for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
-			bcm43xx_ofdmtab_write32(dev, 0x2000, i, bcm43xx_tab_rotor[i]);
-		bcm43xx_phy_init_noisescaletbl(dev);
-		for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
-			bcm43xx_ofdmtab_write32(dev, 0x2400, i, bcm43xx_tab_retard[i]);
-		break;
-	case 3:
-		for (i = 0; i < 64; i++)
-			bcm43xx_ofdmtab_write16(dev, 0x4000, i, i);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-		bcm43xx_phy_write(dev, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(dev, 0x0020,
-				  bcm43xx_phy_read(dev, 0x0020) & 0xFF0F);
-		bcm43xx_radio_write16(dev, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(dev, 0x0024, 0x4680);
-		bcm43xx_phy_write(dev, 0x0020, 0x0003);
-		bcm43xx_phy_write(dev, 0x001D, 0x0F40);
-		bcm43xx_phy_write(dev, 0x001F, 0x1C00);
-		bcm43xx_phy_write(dev, 0x002A,
-				  (bcm43xx_phy_read(dev, 0x002A)
-				   & 0x00FF) | 0x0400);
-
-		bcm43xx_ofdmtab_write16(dev, 0x3000, 1,
-				        (bcm43xx_ofdmtab_read16(dev, 0x3000, 1)
-				        & 0x0010) | 0x0008);
-		for (i = 0; i < BCM43xx_TAB_NOISEA3_SIZE; i++) {
-			bcm43xx_ofdmtab_write16(dev, 0x1800, i,
-						bcm43xx_tab_noisea3[i]);
-		}
-		bcm43xx_phy_init_noisescaletbl(dev);
-		for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++) {
-			bcm43xx_ofdmtab_write16(dev, 0x5000, i,
-						bcm43xx_tab_sigmasqr1[i]);
-		}
-
-		bcm43xx_phy_write(dev, 0x0003, 0x1808);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-		bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-		bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0001, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0002, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0003, 0, 0x0013);
-		bcm43xx_ofdmtab_write16(dev, 0x0004, 0, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0005, 0, 0x0015);
-		bcm43xx_ofdmtab_write16(dev, 0x0006, 0, 0x0019);
-
-		bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
-		bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
+	u16 b, curr_s, best_s = 0xFFFF;
+	int i;
 
-		bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
-		bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
-		break;
-	default:
-		assert(0);
-	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+		bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) & ~BCM43xx_PHY_CRS0_EN);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+		bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) | 0x1000);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82)) & 0xF0FF) | 0x0300);
+	bcm43xx_radio_write16(dev, 0x0009,
+		bcm43xx_radio_read16(dev, 0x0009) | 0x0080);
+	bcm43xx_radio_write16(dev, 0x0012,
+		(bcm43xx_radio_read16(dev, 0x0012) & 0xFFFC) | 0x0002);
+	bcm43xx_wa_initgains(dev);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBA), 0x3ED5);
+	b = bcm43xx_phy_read(dev, BCM43xx_PHY_PWRDOWN);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, (b & 0xFFF8) | 0x0005);
+	bcm43xx_radio_write16(dev, 0x0004,
+		bcm43xx_radio_read16(dev, 0x0004) | 0x0004);
+	for (i = 0x10; i <= 0x20; i++) {
+		bcm43xx_radio_write16(dev, 0x0013, i);
+		curr_s = bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEQ) & 0x00FF;
+		if (!curr_s) {
+			best_s = 0x0000;
+			break;
+		} else if (curr_s >= 0x0080)
+			curr_s = 0x0100 - curr_s;
+		if (curr_s < best_s)
+			best_s = curr_s;
+	}
+	bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, b);
+	bcm43xx_radio_write16(dev, 0x0004,
+		bcm43xx_radio_read16(dev, 0x0004) & 0xFFFB);
+	bcm43xx_radio_write16(dev, 0x0013, best_s);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 0, 0xFFEC);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB7), 0x1E80);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB6), 0x1C00);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB5), 0x0EC0);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB2), 0x00C0);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB9), 0x1FFF);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBB),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0xBB)) & 0xF000) | 0x0053);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM61,
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM61 & 0xFE1F)) | 0x0120);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x13),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x13)) & 0x0FFF) | 0x3000);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x14),
+		(bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x14)) & 0x0FFF) | 0x3000);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 6, 0x0017);
+	for (i = 0; i < 6; i++)
+		bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, i, 0x000F);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0D, 0x000E);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0E, 0x0011);
+	bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0F, 0x0013);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x33), 0x5030);
+	bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+		bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) | BCM43xx_PHY_CRS0_EN);
 }
 
 /* Initialize APHY. This is also called for the GPHY in some cases. */
@@ -953,60 +657,52 @@ static void bcm43xx_phy_inita(struct bcm
 {
 	struct ssb_bus *bus = dev->dev->bus;
 	struct bcm43xx_phy *phy = &dev->phy;
-	u16 tval;
 
-	if (phy->type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_setupa(dev);
-	} else {
-		bcm43xx_phy_setupg(dev);
-		if (phy->gmode &&
-		    (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_PACTRL))
-			bcm43xx_phy_write(dev, 0x046E, 0x03CF);
-		return;
+	if (phy->rev >= 6) {
+		if (phy->type == BCM43xx_PHYTYPE_A)
+			bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+				bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x1000);
+		if (bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & BCM43xx_PHY_ENCORE_EN)
+			bcm43xx_phy_write(dev, BCM43xx_PHY_ENCORE,
+				bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) | 0x0010);
+		else
+			bcm43xx_phy_write(dev, BCM43xx_PHY_ENCORE,
+				bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & ~0x1010);
 	}
+	bcm43xx_wa_all(dev);
 
-	bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
-	                  (bcm43xx_phy_read(dev, BCM43xx_PHY_A_CRS) & 0xF83C) | 0x0340);
-	bcm43xx_phy_write(dev, 0x0034, 0x0001);
-
-	TODO();//TODO: RSSI AGC
-	bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
-	                  bcm43xx_phy_read(dev, BCM43xx_PHY_A_CRS) | (1 << 14));
-	bcm43xx_radio_init2060(dev);
+	if (phy->type == BCM43xx_PHYTYPE_A) {
+		if (phy->gmode &&
+		    (phy->rev < 3))
+			bcm43xx_phy_write(dev, 0x0034,
+				bcm43xx_phy_read(dev, 0x0034) | 0x0001);
 
-	if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-	    ((bus->board_type == SSB_BOARD_BU4306) ||
-	     (bus->board_type == SSB_BOARD_BU4309))) {
-		if (phy->lofcal == 0xFFFF) {
-			TODO();//TODO: LOF Cal
-			bcm43xx_radio_set_tx_iq(dev);
-		} else
-			bcm43xx_radio_write16(dev, 0x001E, phy->lofcal);
-	}
+		bcm43xx_phy_rssiagc(dev, 0);
 
-	bcm43xx_phy_write(dev, 0x007A, 0xF111);
+		bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+			bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) | BCM43xx_PHY_CRS0_EN);
 
-	if (phy->cur_idle_tssi == 0) {
-		bcm43xx_radio_write16(dev, 0x0019, 0x0000);
-		bcm43xx_radio_write16(dev, 0x0017, 0x0020);
+		bcm43xx_radio_init2060(dev);
 
-		tval = bcm43xx_ofdmtab_read16(dev, 0x3001, 0);
-		if (phy->rev == 1) {
-			bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
-					  (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0xFF87)
-					  | 0x0058);
-		} else {
-			bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
-					  (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0xFFC3)
-					  | 0x002C);
+		if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
+		    ((bus->board_type == SSB_BOARD_BU4306) ||
+		     (bus->board_type == SSB_BOARD_BU4309))) {
+		     	; //TODO: A PHY LO
 		}
-		bcm43xx_dummy_transmission(dev);
-		phy->cur_idle_tssi = bcm43xx_phy_read(dev, BCM43xx_PHY_A_PCTL);
-		bcm43xx_ofdmtab_write16(dev, 0x3001, 0, tval);
 
-		bcm43xx_radio_set_txpower_a(dev, 0x0018);
+		if (phy->rev >= 3)
+			bcm43xx_phy_ww(dev);
+
+		hardware_pctl_init_aphy(dev);
+
+		//TODO: radar detection
+	}
+	if ((phy->type == BCM43xx_PHYTYPE_G) &&
+	    (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_PACTRL)) {
+		bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x6E),
+				  (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x6E))
+				   & 0xE000) | 0x3CF);
 	}
-	bcm43xx_shm_clear_tssi(dev);
 }
 
 static void bcm43xx_phy_initb2(struct bcm43xx_wldev *dev)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/Makefile	2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile	2007-05-12 16:29:05.000000000 +0200
@@ -15,4 +15,5 @@ bcm43xx-mac80211-objs := bcm43xx_main.o 
 		         bcm43xx_leds.o \
 		         bcm43xx_xmit.o \
 		         bcm43xx_lo.o \
+		         bcm43xx_wa.o \
 		         $(bcm43xx-mac80211-obj-y)


-- 
Greetings Michael.


From guillaume.yziquel at free.fr  Sat May 12 18:04:16 2007
From: guillaume.yziquel at free.fr (Guillaume Yziquel)
Date: Sat, 12 May 2007 18:04:16 +0200
Subject: Master Mode.
Message-ID: <4645E580.3020002@free.fr>

Hello list.

I would like to know if it was possible to get my BCM4310 wifi card to
work in Master Mode. I understood this mode was not supported, but I'd
I'd like to know why (which I haven't been able to find on the Internet).

Guillaume Yziquel.


From andrew.james.barr at gmail.com  Sat May 12 19:03:15 2007
From: andrew.james.barr at gmail.com (Andrew J. Barr)
Date: Sat, 12 May 2007 13:03:15 -0400
Subject: Master Mode.
In-Reply-To: <4645E580.3020002@free.fr>
References: <4645E580.3020002@free.fr>
Message-ID: <20070512130315.23837f12@conroe.oakcourt.dyndns.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On Sat, 12 May 2007 18:04:16 +0200
Guillaume Yziquel <guillaume.yziquel at free.fr> wrote:

> Hello list.
> 
> I would like to know if it was possible to get my BCM4310 wifi card to
> work in Master Mode. I understood this mode was not supported, but I'd
> I'd like to know why (which I haven't been able to find on the
> Internet).

It is supported by the mac80211 version of the driver, I believe.

> Guillaume Yziquel.
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev


- -- 
Andrew J. Barr
(614) 581-3537 (Verizon Wireless)

"When fascism comes to America, it will be wrapped in the flag and
carrying the cross." -- Sinclair Lewis, 1935
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)

iD8DBQFGRfNThuM+Z62a52oRAgUmAKDTrlj46wJd76zQ4lZpVk5y7H5GGQCfUOgF
wdrmCM31obBOREzNWPjWttI=
=0pLq
-----END PGP SIGNATURE-----

From johannes at sipsolutions.net  Sat May 12 23:34:02 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Sat, 12 May 2007 23:34:02 +0200
Subject: Master Mode.
In-Reply-To: <20070512130315.23837f12@conroe.oakcourt.dyndns.org>
References: <4645E580.3020002@free.fr>
	<20070512130315.23837f12@conroe.oakcourt.dyndns.org>
Message-ID: <1179005643.2647.19.camel@johannes.berg>


> > I would like to know if it was possible to get my BCM4310 wifi card to
> > work in Master Mode. I understood this mode was not supported, but I'd
> > I'd like to know why (which I haven't been able to find on the
> > Internet).
> 
> It is supported by the mac80211 version of the driver, I believe.

Correct, I've used it in the past. Just configure hostapd and off you go
(you need a devel version though for current mac80211 versions)

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070512/96351d54/attachment.pgp>

From zajec5polish at gmail.com  Sun May 13 15:27:32 2007
From: zajec5polish at gmail.com (=?UTF-8?Q?Rafa=C5=82_Mi=C5=82ecki?=)
Date: Sun, 13 May 2007 15:27:32 +0200
Subject: Kernel 2.6.22-rc1
Message-ID: <14b026160705130627q25ce2b83s1ae5cd77e6e7a7ca@mail.gmail.com>

Does this version of kernel (from today) includes all these important
fixes/patches for bcm43xx?

-- 
Rafa? Mi?ecki

From bcm43xx at jollyrotten.org  Sun May 13 19:02:48 2007
From: bcm43xx at jollyrotten.org (Anthony Durity)
Date: Sun, 13 May 2007 19:02:48 +0200
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <200705121750.57090.mb@bu3sch.de>
References: <20070423202530.2829f309@localhost>
	<200705111224.33898.mb@bu3sch.de> <200705120107.02627.mb@bu3sch.de>
	<200705121750.57090.mb@bu3sch.de>
Message-ID: <b1923f7f0705131002s79d08454k430d2c0051c2d840@mail.gmail.com>

Hi Michael (and everyone else),

I am trying to get my Broadcom wireless working. I met this nice guy at the
Ubuntu
Dev Summit in Sevilla and he told me to
git-clone git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-
dev.git
and then build a custom kernel (a thing I have not had to do in Linux for
many a
year and my my the config options have expanded somewhat). He also suggested
I subscribe to this list and detail any problems I might have.

Here is an lspic -vv of the chipset
03:02.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 54g]
802.11g Wireless LAN Controller (rev 02)
        Subsystem: Hewlett-Packard Company MX6125
        Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
Stepping- SERR- FastB2B-
        Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort-
<TAbort- <MAbort- >SERR- <PERR-
        Latency: 64
        Interrupt: pin A routed to IRQ 21
        Region 0: Memory at b0204000 (32-bit, non-prefetchable) [size=8K]

My laptop is a HP Compaq R4000 - specifically the R4218ea. It's got an
Athlon 64
which is nice.

The thing is that I've seen you posting patches for the bcm43xx to this
list. Should I
be applying these patches to the latest Linville kernel (after I've done a
git-pull to ensure
that I have the latest sources I guess) or not? Is there anything special I
need to do?
Should I disable NetworkManager? Does Avahi interfere? I saw a couple of
posts about
lowering the TX rate, should I do this? What options should I enable in the
wireless kernel
vis-a-vis bcm43xx. Should I use the Improved wireless configuration API?
Should I
enable nl80211 new netlink interface support? Should I enable debugging
output?
I want to be able to help you guys to the best of my ability so any info
pushing me in
the right direction would be greatly appreciated.

All the best,
    Anthony Durity

On 5/12/07, Michael Buesch <mb at bu3sch.de > wrote:
>
> On Saturday 12 May 2007 01:07:01 Michael Buesch wrote:
> > On Friday 11 May 2007 12:24:33 Michael Buesch wrote:
> > > On Monday 23 April 2007 20:30:41 Stefano Brivio wrote:
> > > > This patch fixes A/G PHYs setup and initialization routines. Let's
> move
> > > > the so-called workarounds in a separate file, in order to avoid
> clobbering
> > > > bcm43xx_phy.c.
>
> Here's latest version of the patch.
> Yet another few bugs fixed.
>
> Index:
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c
> ===================================================================
> --- /dev/null   1970-01-01 00:00:00.000000000 +0000
> +++
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c      2007-05-12
> 16:29:05.000000000 +0200
> @@ -0,0 +1,668 @@
> +/*
> +
> +  Broadcom BCM43xx wireless driver
> +
> +  PHY workarounds.
> +
> +  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
> +  Copyright (c) 2005-2007 Stefano Brivio < st3 at riseup.net>
> +  Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de>
> +  Copyright (c) 2005, 2006 Danny van Dyk < kugelfang at gentoo.org>
> +  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi at waterwave.ch>
> +
> +  This program is free software; you can redistribute it and/or modify
> +  it under the terms of the GNU General Public License as published by
> +  the Free Software Foundation; either version 2 of the License, or
> +  (at your option) any later version.
> +
> +  This program is distributed in the hope that it will be useful,
> +  but WITHOUT ANY WARRANTY; without even the implied warranty of
> +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> +  GNU General Public License for more details.
> +
> +  You should have received a copy of the GNU General Public License
> +  along with this program; see the file COPYING.  If not, write to
> +  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
> +  Boston, MA 02110-1301, USA.
> +
> +*/
> +
> +#include "bcm43xx.h "
> +#include "bcm43xx_main.h"
> +#include "bcm43xx_tables.h"
> +#include "bcm43xx_phy.h"
> +#include "bcm43xx_wa.h"
> +
> +static void bcm43xx_wa_papd(struct bcm43xx_wldev *dev)
> +{
> +       u16 backup;
> +
> +       backup = bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0);
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0, 7);
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_APHY, 0, 0);
> +       bcm43xx_dummy_transmission(dev);
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0, backup);
> +}
> +
> +static void bcm43xx_wa_auxclipthr(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E), 0x3800);
> +}
> +
> +static void bcm43xx_wa_afcdac(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_phy_write(dev, 0x0035, 0x03FF);
> +       bcm43xx_phy_write(dev, 0x0036, 0x0400);
> +}
> +
> +static void bcm43xx_wa_txdc_offset(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 0, 0x0051);
> +}
> +
> +void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev)
> +{
> +       struct bcm43xx_phy *phy = &dev->phy;
> +
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_LNAHPFCTL, 0x1FF9);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
> +               bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & 0xFF0F);
> +       if (phy->rev <= 2)
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_LPFGAIN, 0,
> 0x1FBF);
> +       bcm43xx_radio_write16(dev, 0x0002, 0x1FBF);
> +
> +       bcm43xx_phy_write(dev, 0x0024, 0x4680);
> +       bcm43xx_phy_write(dev, 0x0020, 0x0003);
> +       bcm43xx_phy_write(dev, 0x001D, 0x0F40);
> +       bcm43xx_phy_write(dev, 0x001F, 0x1C00);
> +       if (phy->rev <= 3)
> +               bcm43xx_phy_write(dev, 0x002A,
> +                       (bcm43xx_phy_read(dev, 0x002A) & 0x00FF) |
> 0x0400);
> +       else if (phy->rev == 5) {
> +               bcm43xx_phy_write(dev, 0x002A,
> +                       (bcm43xx_phy_read(dev, 0x002A) & 0x00FF) |
> 0x1A00);
> +               bcm43xx_phy_write(dev, 0x00CC, 0x2121);
> +       }
> +       if (phy->rev >= 3)
> +               bcm43xx_phy_write(dev, 0x00BA, 0x3ED5);
> +}
> +
> +static void bcm43xx_wa_divider(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_phy_write(dev, 0x002B, bcm43xx_phy_read(dev, 0x002B) &
> ~0x0100);
> +       bcm43xx_phy_write(dev, 0x008E, 0x58C1);
> +}
> +
> +static void bcm43xx_wa_gt(struct bcm43xx_wldev *dev) /* Gain table. */
> +{
> +       if (dev->phy.rev <= 2) {
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 0,
> 15);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 1,
> 31);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 2,
> 42);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 3,
> 48);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 4,
> 58);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 0,
> 19);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 1,
> 19);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 2,
> 19);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 3,
> 19);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 4,
> 21);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 5,
> 21);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 6,
> 25);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 0, 3);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 1, 3);
>
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 2, 7);
> +       } else {
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 0,
> 19);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 1,
> 19);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 2,
> 19);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 3,
> 19);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 4,
> 21);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 5,
> 21);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 6,
> 25);
> +       }
> +}
> +
> +static void bcm43xx_wa_rssi_lt(struct bcm43xx_wldev *dev) /* RSSI lookup
> table */
> +{
> +       int i;
> +
> +       for (i = 0; i < 8; i++)
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_RSSI, i, i +
> 8);
> +       for (i = 8; i < 16; i++)
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_RSSI, i, i -
> 8);
> +}
> +
> +static void bcm43xx_wa_analog(struct bcm43xx_wldev *dev)
> +{
> +       struct bcm43xx_phy *phy = &dev->phy;
> +
> +       if (phy->analog > 2) {
> +               if (phy->type == BCM43xx_PHYTYPE_A)
> +                       bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN,
> 0x1808);
> +               else
> +                       bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN,
> 0x1000);
> +       } else {
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 3,
> 0x1044);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 4,
> 0x7201);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 6,
> 0x0040);
> +       }
> +}
> +
> +static void bcm43xx_wa_dac(struct bcm43xx_wldev *dev)
> +{
> +       if (dev->phy.analog == 1)
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1,
> +                       (bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC,
> 1) & ~0x0034) | 0x0008);
> +       else
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1,
> +                       (bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC,
> 1) & ~0x0078) | 0x0010);
> +}
> +
> +static void bcm43xx_wa_fft(struct bcm43xx_wldev *dev) /* Fine frequency
> table */
> +{
> +       int i;
> +
> +       if (dev->phy.type == BCM43xx_PHYTYPE_A)
> +               for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
> +                       bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqa[i]);
> +       else
> +               for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
> +                       bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqg[i]);
> +}
> +
> +static void bcm43xx_wa_nft(struct bcm43xx_wldev *dev) /* Noise figure
> table */
> +{
> +       struct bcm43xx_phy *phy = &dev->phy;
> +       int i;
> +
> +       if (phy->type == BCM43xx_PHYTYPE_A) {
> +               if (phy->rev == 2)
> +                       for (i = 0; i < BCM43xx_TAB_NOISEA2_SIZE; i++)
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea2[i]);
> +               else
> +                       for (i = 0; i < BCM43xx_TAB_NOISEA3_SIZE; i++)
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea3[i]);
> +       } else {
> +               if (phy->rev == 1)
> +                       for (i = 0; i < BCM43xx_TAB_NOISEG1_SIZE; i++)
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg1[i]);
> +               else
> +                       for (i = 0; i < BCM43xx_TAB_NOISEG2_SIZE; i++)
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg2[i]);
> +       }
> +}
> +
> +static void bcm43xx_wa_rt(struct bcm43xx_wldev *dev) /* Rotor table */
> +{
> +       int i;
> +
> +       for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
> +               bcm43xx_ofdmtab_write32(dev, BCM43xx_OFDMTAB_ROTOR, i,
> bcm43xx_tab_rotor[i]);
> +}
> +
> +static void bcm43xx_wa_nst(struct bcm43xx_wldev *dev) /* Noise scale
> table */
> +{
> +       struct bcm43xx_phy *phy = &dev->phy;
> +       int i;
> +
> +       if (phy->type == BCM43xx_PHYTYPE_A) {
> +               if (phy->rev <= 1)
> +                       for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_NOISESCALE,
> +                                                       i, 0);
> +               else if (phy->rev == 2)
> +                       for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_NOISESCALE,
> +                                                       i,
> bcm43xx_tab_noisescalea2[i]);
> +               else if (phy->rev == 3)
> +                       for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_NOISESCALE,
> +                                                       i,
> bcm43xx_tab_noisescalea3[i]);
> +               else
> +                       for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_NOISESCALE,
> +                                                       i,
> bcm43xx_tab_noisescaleg3[i]);
> +       } else {
> +               if (phy->rev >= 6) {
> +                       if (bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) &
> BCM43xx_PHY_ENCORE_EN)
> +                               for (i = 0; i <
> BCM43xx_TAB_NOISESCALE_SIZE; i++)
> +                                       bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_NOISESCALE,
> +                                               i,
> bcm43xx_tab_noisescaleg3[i]);
> +                       else
> +                               for (i = 0; i <
> BCM43xx_TAB_NOISESCALE_SIZE; i++)
> +                                       bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_NOISESCALE,
> +                                               i,
> bcm43xx_tab_noisescaleg2[i]);
> +               } else {
> +                       for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_NOISESCALE,
> +                                                       i,
> bcm43xx_tab_noisescaleg1[i]);
> +               }
> +       }
> +}
> +
> +static void bcm43xx_wa_art(struct bcm43xx_wldev *dev) /* ADV retard table
> */
> +{
> +       int i;
> +
> +       for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
> +                       bcm43xx_ofdmtab_write32(dev,
> BCM43xx_OFDMTAB_ADVRETARD,
> +                               i, bcm43xx_tab_retard[i]);
> +}
> +
> +static void bcm43xx_wa_txlna_gain(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 13, 0x0000);
> +}
> +
> +static void bcm43xx_wa_crs_reset(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_phy_write(dev, 0x002C, 0x0064);
> +}
> +
> +static void bcm43xx_wa_2060txlna_gain(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_hf_write(dev, bcm43xx_hf_read(dev) |
> +                        BCM43xx_HF_2060W);
> +}
> +
> +static void bcm43xx_wa_lms(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_phy_write(dev, 0x0055,
> +               (bcm43xx_phy_read(dev, 0x0055) & 0xFFC0) | 0x0004);
> +}
> +
> +static void bcm43xx_wa_mixedsignal(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1, 3);
> +}
> +
> +static void bcm43xx_wa_msst(struct bcm43xx_wldev *dev) /* Min sigma
> square table */
> +{
> +       struct bcm43xx_phy *phy = &dev->phy;
> +       int i;
> +       const u16 *tab;
> +
> +       if (phy->type == BCM43xx_PHYTYPE_A) {
> +               tab = bcm43xx_tab_sigmasqr1;
> +       } else if (phy->type == BCM43xx_PHYTYPE_G) {
> +               tab = bcm43xx_tab_sigmasqr2;
> +       } else {
> +               assert(0);
> +               return;
> +       }
> +
> +       for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++) {
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_MINSIGSQ,
> +                                       i, tab[i]);
> +       }
> +}
> +
> +static void bcm43xx_wa_iqadc(struct bcm43xx_wldev *dev)
> +{
> +       if (dev->phy.analog == 4)
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 0,
> +                       bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC,
> 0) & ~0xF000);
> +}
> +
> +static void bcm43xx_wa_crs_ed(struct bcm43xx_wldev *dev)
> +{
> +       struct bcm43xx_phy *phy = &dev->phy;
> +
> +       if (phy->rev == 1) {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1, 0x4F19);
> +       } else if (phy->rev == 2) {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1_R1, 0x1861);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES2_R1, 0x1861);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_ANTDWELL,
> +                                 bcm43xx_phy_read(dev,
> BCM43xx_PHY_ANTDWELL)
> +                                 | 0x0800);
> +       } else {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1_R1, 0x0098);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES2_R1, 0x0070);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xC9), 0x0080);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_ANTDWELL,
> +                                 bcm43xx_phy_read(dev,
> BCM43xx_PHY_ANTDWELL)
> +                                 | 0x0800);
> +       }
> +}
> +
> +static void bcm43xx_wa_crs_thr(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
> +                       (bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) &
> ~0x03C0) | 0xD000);
> +}
> +
> +static void bcm43xx_wa_crs_blank(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x2C), 0x005A);
> +}
> +
> +static void bcm43xx_wa_cck_shiftbits(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS, 0x0026);
> +}
> +
> +static void bcm43xx_wa_wrssi_offset(struct bcm43xx_wldev *dev)
> +{
> +       int i;
> +
> +       if (dev->phy.rev == 1) {
> +               for (i = 0; i < 16; i++) {
> +                       bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_WRSSI_R1,
> +                                               i, 0x0020);
> +               }
> +       } else {
> +               for (i = 0; i < 32; i++) {
> +                       bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_WRSSI,
> +                                               i, 0x0820);
> +               }
> +       }
> +}
> +
> +static void bcm43xx_wa_txpuoff_rxpuon(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_0F, 2, 15);
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_0F, 3, 20);
> +}
> +
> +static void bcm43xx_wa_altagc(struct bcm43xx_wldev *dev)
> +{
> +       struct bcm43xx_phy *phy = &dev->phy;
> +
> +       if (phy->rev == 1) {
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 0,
> 254);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 1,
> 13);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 2,
> 19);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 3,
> 25);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 0,
> 0x2710);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 1,
> 0x9B83);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 2,
> 0x9B83);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 3,
> 0x0F8D);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_LMS, 4);
> +       } else {
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0,
> 254);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 1, 13);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 2, 19);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 3, 25);
>
> +       }
> +
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS_WA,
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_CCKSHIFTBITS_WA) &
> ~0xFF00) | 0x5700);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1A),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1A)) & ~0x007F)
> | 0x000F);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1A),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1A)) & ~0x3F80)
> | 0x2B80);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT,
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_ANTWRSETT) & 0xF0FF) |
> 0x0300);
> +       bcm43xx_radio_write16(dev, 0x7A,
> +               bcm43xx_radio_read16(dev, 0x7A) | 0x0008);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_N1P1GAIN,
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_N1P1GAIN) & ~0x000F) |
> 0x0008);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_P1P2GAIN,
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_P1P2GAIN) & ~0x0F00) |
> 0x0600);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_N1N2GAIN,
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_N1N2GAIN) & ~0x0F00) |
> 0x0700);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_N1P1GAIN,
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_N1P1GAIN) & ~0x0F00) |
> 0x0100);
> +       if (phy->rev == 1) {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_N1N2GAIN,
> +                                 (bcm43xx_phy_read(dev,
> BCM43xx_PHY_N1N2GAIN)
> +                                  & ~0x000F) | 0x0007);
> +       }
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0x00FF)
> | 0x001C);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0x3F00)
> | 0x0200);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x96)) & ~0x00FF)
> | 0x001C);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89)) & ~0x00FF)
> | 0x0020);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89)) & ~0x3F00)
> | 0x0200);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82)) & ~0x00FF)
> | 0x002E);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x96)) & ~0xFF00)
> | 0x1A00);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81)) & ~0x00FF)
> | 0x0028);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81)) & ~0xFF00)
> | 0x2C00);
> +       if (phy->rev == 1) {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_PEAK_COUNT, 0x092B);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
> +                       (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) &
> ~0x001E) | 0x0002);
> +       } else {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
> +                       bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) &
> ~0x001E);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1F), 0x287A);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
> +                       (bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) &
> ~0x000F) | 0x0004);
> +               if (phy->rev >= 6) {
> +                       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x22),
> 0x287A);
> +                       bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
> +                               (bcm43xx_phy_read(dev,
> BCM43xx_PHY_LPFGAINCTL) & ~0xF000) | 0x3000);
> +               }
> +       }
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_DIVSRCHIDX,
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_DIVSRCHIDX) & 0x7F7F) |
> 0x7874);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E), 0x1C00);
> +       if (phy->rev == 1) {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_DIVP1P2GAIN,
> +                       (bcm43xx_phy_read(dev, BCM43xx_PHY_DIVP1P2GAIN) &
> ~0x0F00) | 0x0600);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8B), 0x005E);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT,
> +                       (bcm43xx_phy_read(dev, BCM43xx_PHY_ANTWRSETT) &
> ~0x00FF) | 0x001E);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8D), 0x0002);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 0,
> 0);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 1,
> 7);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 2,
> 16);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 3,
> 28);
> +       } else {
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 0, 0);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 1, 7);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 2, 16);
>
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 3, 28);
> +       }
> +       if (phy->rev >= 6) {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
> +                       bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x26)) &
> ~0x0003);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
> +                       bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x26)) &
> ~0x1000);
> +       }
> +}
> +
> +static void bcm43xx_wa_tr_ltov(struct bcm43xx_wldev *dev) /* TR Lookup
> Table Original Values */
> +{
> +       bcm43xx_gtab_write(dev, BCM43xx_GTAB_ORIGTR, 0, 0xC480);
> +}
> +
> +static void bcm43xx_wa_cpll_nonpilot(struct bcm43xx_wldev *dev)
> +{
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_11, 0, 0);
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_11, 1, 0);
> +}
> +
> +static void bcm43xx_wa_rssi_adc(struct bcm43xx_wldev *dev)
> +{
> +       if (dev->phy.analog == 4)
> +               bcm43xx_phy_write(dev, 0x00DC, 0x7454);
> +}
> +
> +static void bcm43xx_wa_boards_a(struct bcm43xx_wldev *dev)
> +{
> +       struct ssb_bus *bus = dev->dev->bus;
> +
> +       if (bus->board_vendor == SSB_BOARDVENDOR_BCM &&
> +           bus->board_type == SSB_BOARD_BU4306 &&
> +           bus->board_rev < 0x30) {
> +               bcm43xx_phy_write(dev, 0x0010, 0xE000);
> +               bcm43xx_phy_write(dev, 0x0013, 0x0140);
> +               bcm43xx_phy_write(dev, 0x0014, 0x0280);
> +       } else {
> +               if (bus->board_type == SSB_BOARD_MP4318 &&
> +                   bus->board_rev < 0x20) {
> +                       bcm43xx_phy_write(dev, 0x0013, 0x0210);
> +                       bcm43xx_phy_write(dev, 0x0014, 0x0840);
> +               } else {
> +                       bcm43xx_phy_write(dev, 0x0013, 0x0140);
> +                       bcm43xx_phy_write(dev, 0x0014, 0x0280);
> +               }
> +               if (dev->phy.rev <= 4)
> +                       bcm43xx_phy_write(dev, 0x0010, 0xE000);
> +               else
> +                       bcm43xx_phy_write(dev, 0x0010, 0x2000);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 1,
> 0x0039);
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_APHY,
> 7, 0x0040);
> +       }
> +}
> +
> +static void bcm43xx_wa_boards_g(struct bcm43xx_wldev *dev)
> +{
> +       struct ssb_bus *bus = dev->dev->bus;
> +       struct bcm43xx_phy *phy = &dev->phy;
> +
> +       if (bus->board_vendor != SSB_BOARDVENDOR_BCM ||
> +           bus->board_type != SSB_BOARD_BU4306 ||
> +           bus->board_rev != 0x17) {
> +               if (phy->rev < 2) {
> +                       bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_GAINX_R1, 1, 0x0002);
> +                       bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_GAINX_R1, 2, 0x0001);
> +               } else {
> +                       bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_GAINX, 1, 0x0002);
> +                       bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_GAINX, 2, 0x0001);
> +                       if ((bus-> sprom.r1.boardflags_lo &
> BCM43xx_BFL_EXTLNA) &&
> +                           (phy->rev >= 7)) {
> +                               bcm43xx_phy_write(dev,
> BCM43xx_PHY_EXTG(0x11),
> +                                       bcm43xx_phy_read(dev,
> BCM43xx_PHY_EXTG(0x11)) & 0xF7FF);
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_GAINX, 0x0020, 0x0001);
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_GAINX, 0x0021, 0x0001);
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_GAINX, 0x0022, 0x0001);
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_GAINX, 0x0023, 0x0000);
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_GAINX, 0x0000, 0x0000);
> +                               bcm43xx_ofdmtab_write16(dev,
> BCM43xx_OFDMTAB_GAINX, 0x0003, 0x0002);
> +                       }
> +               }
> +       }
> +       if (bus->sprom.r1.boardflags_lo & BCM43xx_BFL_FEM) {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_GTABCTL, 0x3120);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_GTABDATA, 0xC480);
> +       }
> +}
> +
> +void bcm43xx_wa_all(struct bcm43xx_wldev *dev)
> +{
> +       struct bcm43xx_phy *phy = &dev->phy;
> +
> +       if (phy->type == BCM43xx_PHYTYPE_A) {
> +               switch (phy->rev) {
> +               case 2:
> +                       bcm43xx_wa_papd(dev);
> +                       bcm43xx_wa_auxclipthr(dev);
> +                       bcm43xx_wa_afcdac(dev);
> +                       bcm43xx_wa_txdc_offset(dev);
> +                       bcm43xx_wa_initgains(dev);
> +                       bcm43xx_wa_divider(dev);
> +                       bcm43xx_wa_gt(dev);
> +                       bcm43xx_wa_rssi_lt(dev);
> +                       bcm43xx_wa_analog(dev);
> +                       bcm43xx_wa_dac(dev);
> +                       bcm43xx_wa_fft(dev);
> +                       bcm43xx_wa_nft(dev);
> +                       bcm43xx_wa_rt(dev);
> +                       bcm43xx_wa_nst(dev);
> +                       bcm43xx_wa_art(dev);
> +                       bcm43xx_wa_txlna_gain(dev);
> +                       bcm43xx_wa_crs_reset(dev);
> +                       bcm43xx_wa_2060txlna_gain(dev);
> +                       bcm43xx_wa_lms(dev);
> +                       break;
> +               case 3:
> +                       bcm43xx_wa_papd(dev);
> +                       bcm43xx_wa_mixedsignal(dev);
> +                       bcm43xx_wa_rssi_lt(dev);
> +                       bcm43xx_wa_txdc_offset(dev);
> +                       bcm43xx_wa_initgains(dev);
> +                       bcm43xx_wa_dac(dev);
> +                       bcm43xx_wa_nft(dev);
> +                       bcm43xx_wa_nst(dev);
> +                       bcm43xx_wa_msst(dev);
> +                       bcm43xx_wa_analog(dev);
> +                       bcm43xx_wa_gt(dev);
> +                       bcm43xx_wa_txpuoff_rxpuon(dev);
> +                       bcm43xx_wa_txlna_gain(dev);
> +                       break;
> +               case 5:
> +                       bcm43xx_wa_iqadc(dev);
> +               case 6:
> +                       bcm43xx_wa_papd(dev);
> +                       bcm43xx_wa_rssi_lt(dev);
> +                       bcm43xx_wa_txdc_offset(dev);
> +                       bcm43xx_wa_initgains(dev);
> +                       bcm43xx_wa_dac(dev);
> +                       bcm43xx_wa_nft(dev);
> +                       bcm43xx_wa_nst(dev);
> +                       bcm43xx_wa_msst(dev);
> +                       bcm43xx_wa_analog(dev);
> +                       bcm43xx_wa_gt(dev);
> +                       bcm43xx_wa_txpuoff_rxpuon(dev);
> +                       bcm43xx_wa_txlna_gain(dev);
> +                       break;
> +               case 7:
> +                       bcm43xx_wa_iqadc(dev);
> +                       bcm43xx_wa_papd(dev);
> +                       bcm43xx_wa_rssi_lt(dev);
> +                       bcm43xx_wa_txdc_offset(dev);
> +                       bcm43xx_wa_initgains(dev);
> +                       bcm43xx_wa_dac(dev);
> +                       bcm43xx_wa_nft(dev);
> +                       bcm43xx_wa_nst(dev);
> +                       bcm43xx_wa_msst(dev);
> +                       bcm43xx_wa_analog(dev);
> +                       bcm43xx_wa_gt(dev);
> +                       bcm43xx_wa_txpuoff_rxpuon(dev);
> +                       bcm43xx_wa_txlna_gain(dev);
> +                       bcm43xx_wa_rssi_adc(dev);
> +               default:
> +                       assert(0);
> +               }
> +               bcm43xx_wa_boards_a(dev);
> +       } else if (phy->type == BCM43xx_PHYTYPE_G) {
> +               switch (phy->rev) {
> +               case 1://XXX review rev1
> +                       bcm43xx_wa_crs_ed(dev);
> +                       bcm43xx_wa_crs_thr(dev);
> +                       bcm43xx_wa_crs_blank(dev);
> +                       bcm43xx_wa_cck_shiftbits(dev);
> +                       bcm43xx_wa_fft(dev);
> +                       bcm43xx_wa_nft(dev);
> +                       bcm43xx_wa_rt(dev);
> +                       bcm43xx_wa_nst(dev);
> +                       bcm43xx_wa_art(dev);
> +                       bcm43xx_wa_wrssi_offset(dev);
> +                       bcm43xx_wa_altagc(dev);
> +                       break;
> +               case 2:
> +               case 6:
> +               case 7:
> +               case 8:
> +                       bcm43xx_wa_tr_ltov(dev);
> +                       bcm43xx_wa_crs_ed(dev);
> +                       bcm43xx_wa_rssi_lt(dev);
> +                       bcm43xx_wa_nft(dev);
> +                       bcm43xx_wa_nst(dev);
> +                       bcm43xx_wa_msst(dev);
> +                       bcm43xx_wa_wrssi_offset(dev);
> +                       bcm43xx_wa_altagc(dev);
> +                       bcm43xx_wa_analog(dev);
> +                       bcm43xx_wa_txpuoff_rxpuon(dev);
> +                       break;
> +               default:
> +                       assert(0);
> +               }
> +               bcm43xx_wa_boards_g(dev);
> +       } else { /* No N PHY support so far */
> +               assert(0);
> +       }
> +
> +       bcm43xx_wa_cpll_nonpilot(dev);
> +}
> Index:
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h
> ===================================================================
> --- /dev/null   1970-01-01 00:00:00.000000000 +0000
> +++
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h      2007-05-12
> 16:29: 05.000000000 +0200
> @@ -0,0 +1,7 @@
> +#ifndef BCM43xx_WA_H_
> +#define BCM43xx_WA_H_
> +
> +void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev);
> +void bcm43xx_wa_all(struct bcm43xx_wldev *dev);
> +
> +#endif /* BCM43xx_WA_H_ */
> Index:
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c
> ===================================================================
> --- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c
> 2007-05-12 16:27: 31.000000000 +0200
> +++
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c  2007-05-12
> 16:29:05.000000000 +0200
> @@ -230,7 +230,7 @@ const u16 bcm43xx_tab_noisea2[] = {
> };
>
> const u16 bcm43xx_tab_noisea3[] = {
> -       0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
> +       0x5E5E, 0x5E5E, 0x5E5E, 0x3F48,
>         0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
> };
>
> @@ -244,6 +244,26 @@ const u16 bcm43xx_tab_noiseg2[] = {
>         0x0000, 0x0000, 0x0000, 0x0000,
> };
>
> +const u16 bcm43xx_tab_noisescalea2[] = {
> +       0x6767, 0x6767, 0x6767, 0x6767, /* 0 */
> +       0x6767, 0x6767, 0x6767, 0x6767,
> +       0x6767, 0x6767, 0x6767, 0x6767,
> +       0x6767, 0x6700, 0x6767, 0x6767,
> +       0x6767, 0x6767, 0x6767, 0x6767, /* 16 */
> +       0x6767, 0x6767, 0x6767, 0x6767,
> +       0x6767, 0x6767, 0x0067,
> +};
> +
> +const u16 bcm43xx_tab_noisescalea3[] = {
> +       0x2323, 0x2323, 0x2323, 0x2323, /* 0 */
> +       0x2323, 0x2323, 0x2323, 0x2323,
> +       0x2323, 0x2323, 0x2323, 0x2323,
> +       0x2323, 0x2300, 0x2323, 0x2323,
> +       0x2323, 0x2323, 0x2323, 0x2323, /* 16 */
> +       0x2323, 0x2323, 0x2323, 0x2323,
> +       0x2323, 0x2323, 0x0023,
> +};
> +
> const u16 bcm43xx_tab_noisescaleg1[] = {
>         0x6C77, 0x5162, 0x3B40, 0x3335, /* 0 */
>         0x2F2D, 0x2A2A, 0x2527, 0x1F21,
> @@ -255,7 +275,7 @@ const u16 bcm43xx_tab_noisescaleg1[] = {
> };
>
> const u16 bcm43xx_tab_noisescaleg2[] = {
> -       0xD8DD, 0xCBD4, 0xBCC0, 0XB6B7, /* 0 */
> +       0xD8DD, 0xCBD4, 0xBCC0, 0xB6B7, /* 0 */
>         0xB2B0, 0xADAD, 0xA7A9, 0x9FA1,
>         0x969B, 0x9195, 0x8F8F, 0x8A8A,
>         0x8A8A, 0x8A00, 0x8A8A, 0x8F8A,
> @@ -308,6 +328,27 @@ const u16 bcm43xx_tab_sigmasqr2[] = {
>         0x00DE,
> };
>
> +const u16 bcm43xx_tab_rssiagc1[] = {
> +       0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8, /* 0 */
> +       0xFFF8, 0xFFF9, 0xFFFC, 0xFFFE,
> +       0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
> +       0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
> +};
> +
> +const u16 bcm43xx_tab_rssiagc2[] = {
> +       0x0820, 0x0820, 0x0920, 0x0C38, /* 0 */
> +       0x0820, 0x0820, 0x0820, 0x0820,
> +       0x0820, 0x0820, 0x0920, 0x0A38,
> +       0x0820, 0x0820, 0x0820, 0x0820,
> +       0x0820, 0x0820, 0x0920, 0x0A38, /* 16 */
> +       0x0820, 0x0820, 0x0820, 0x0820,
> +       0x0820, 0x0820, 0x0920, 0x0A38,
> +       0x0820, 0x0820, 0x0820, 0x0820,
> +       0x0820, 0x0820, 0x0920, 0x0A38, /* 32 */
> +       0x0820, 0x0820, 0x0820, 0x0820,
> +       0x0820, 0x0820, 0x0920, 0x0A38,
> +       0x0820, 0x0820, 0x0820, 0x0820,
> +};
>
> static inline void assert_sizes(void)
> {
> @@ -319,34 +360,59 @@ static inline void assert_sizes(void)
>         BUILD_BUG_ON(BCM43xx_TAB_NOISEA3_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_noisea3));
>         BUILD_BUG_ON(BCM43xx_TAB_NOISEG1_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_noiseg1));
>         BUILD_BUG_ON(BCM43xx_TAB_NOISEG2_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_noiseg2));
> -       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_noisescaleg1));
> -       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
> -       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
> +       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_noisescaleg1));
> +       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
> +       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
>         BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_sigmasqr1));
>         BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_sigmasqr2));
> +       BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC1_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_rssiagc1));
> +       BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC2_SIZE !=
> ARRAY_SIZE(bcm43xx_tab_rssiagc2));
> }
>
>
> u16 bcm43xx_ofdmtab_read16(struct bcm43xx_wldev *dev, u16 table, u16
> offset)
> {
> -       assert_sizes();
> +       struct bcm43xx_phy *phy = &dev->phy;
> +       u16 addr;
> +
> +       addr = table + offset;
> +       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr);
> +               phy->ofdm_valid = 1;
> +       }
> +       phy->ofdm_addr = addr;
>
> -       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
>         return bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI);
> +       assert_sizes();
> }
>
> void bcm43xx_ofdmtab_write16(struct bcm43xx_wldev *dev, u16 table,
>                              u16 offset, u16 value)
> {
> -       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
> +       struct bcm43xx_phy *phy = &dev->phy;
> +       u16 addr;
> +
> +       addr = table + offset;
> +       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr);
> +               phy->ofdm_valid = 2;
> +       }
> +       phy->ofdm_addr = addr;
>         bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
> }
>
> u32 bcm43xx_ofdmtab_read32(struct bcm43xx_wldev *dev, u16 table, u16
> offset)
> {
> +       struct bcm43xx_phy *phy = &dev->phy;
>         u32 ret;
> +       u16 addr;
>
> -       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
> +       addr = table + offset;
> +       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr);
> +               phy->ofdm_valid = 1;
> +       }
> +       phy->ofdm_addr = addr;
>         ret = bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEQ);
>         ret <<= 16;
>         ret |= bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI);
> @@ -357,9 +423,17 @@ u32 bcm43xx_ofdmtab_read32(struct bcm43x
> void bcm43xx_ofdmtab_write32(struct bcm43xx_wldev *dev, u16 table,
>                              u16 offset, u32 value)
> {
> -       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
> -       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
> +       struct bcm43xx_phy *phy = &dev->phy;
> +       u16 addr;
> +
> +       addr = table + offset;
> +       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr);
> +               phy->ofdm_valid = 2;
> +       }
> +       phy->ofdm_addr = addr;
>         bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEQ, (value >> 16));
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
> }
>
> u16 bcm43xx_gtab_read(struct bcm43xx_wldev *dev, u16 table, u16 offset)
> Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h
>
> ===================================================================
> --- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h    2007-05-12
> 16:27:31.000000000 +0200
> +++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h
> 2007-05-12 16:29: 05.000000000 +0200
> @@ -591,6 +591,10 @@ struct bcm43xx_phy {
>         u16 lofcal;
>
>         u16 initval;//FIXME rename?
> +
> +       /* OFDM address read/write caching for hardware auto-increment. */
> +       u16 ofdm_addr;
> +       u8 ofdm_valid; /* 0: invalid, 1: read, 2: write */
> };
>
> /* Data structures for DMA transmission, per 80211 core. */
> Index:
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
> ===================================================================
> --- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
> 2007-05-12 16:27:31.000000000 +0200
> +++
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c    2007-05-12
> 16:29: 05.000000000 +0200
> @@ -3127,6 +3127,9 @@ static void setup_struct_phy_for_init(st
>         spin_lock_init(&phy->lock);
>         phy->interfmode = BCM43xx_INTERFMODE_NONE;
>         phy->channel = 0xFF;
> +
> +       /* OFDM address caching. */
> +       phy->ofdm_valid = 0;
> }
>
> static void setup_struct_wldev_for_init(struct bcm43xx_wldev *dev)
> Index:
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h
> ===================================================================
> --- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h        2007-05-12
> 16:27:31.000000000 +0200
> +++
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h
> 2007-05-12 16:29: 05.000000000 +0200
> @@ -28,8 +28,11 @@ struct bcm43xx_wldev;
> #define BCM43xx_PHY_PWRDOWN            BCM43xx_PHY_OFDM(0x03)  /*
> Powerdown */
> #define BCM43xx_PHY_CRSTHRES1          BCM43xx_PHY_OFDM(0x06)  /* CRS
> Threshold 1 */
> #define BCM43xx_PHY_LNAHPFCTL          BCM43xx_PHY_OFDM(0x1C)  /* LNA/HPF
> control */
> +#define BCM43xx_PHY_LPFGAINCTL         BCM43xx_PHY_OFDM(0x20)  /* LPF
> Gain control */
> #define BCM43xx_PHY_ADIVRELATED                BCM43xx_PHY_OFDM(0x27)  /*
> FIXME rename */
> #define BCM43xx_PHY_CRS0               BCM43xx_PHY_OFDM(0x29)
> +#define  BCM43xx_PHY_CRS0_EN           0x4000
> +#define BCM43xx_PHY_PEAK_COUNT         BCM43xx_PHY_OFDM(0x30)
> #define BCM43xx_PHY_ANTDWELL           BCM43xx_PHY_OFDM(0x2B)  /* Antenna
> dwell */
> #define  BCM43xx_PHY_ANTDWELL_AUTODIV1 0x0100                  /*
> Automatic RX diversity start antenna */
> #define BCM43xx_PHY_ENCORE             BCM43xx_PHY_OFDM(0x49)  /* "Encore"
> (RangeMax / BroadRange) */
> @@ -38,6 +41,7 @@ struct bcm43xx_wldev;
> #define BCM43xx_PHY_OFDM61             BCM43xx_PHY_OFDM(0x61)  /* FIXME
> rename */
> #define  BCM43xx_PHY_OFDM61_10         0x0010                  /* FIXME
> rename */
> #define BCM43xx_PHY_IQBAL              BCM43xx_PHY_OFDM(0x69)  /* I/Q
> balance */
> +#define BCM43xx_PHY_BBTXDC_BIAS                BCM43xx_PHY_OFDM(0x6B)  /*
> Baseband TX DC bias */
> #define BCM43xx_PHY_OTABLECTL          BCM43xx_PHY_OFDM(0x72)  /* OFDM
> table control (see below) */
> #define  BCM43xx_PHY_OTABLEOFF         0x03FF                  /* OFDM
> table offset (see below) */
> #define  BCM43xx_PHY_OTABLENR          0xFC00                  /* OFDM
> table number (see below) */
> @@ -45,6 +49,9 @@ struct bcm43xx_wldev;
> #define BCM43xx_PHY_OTABLEI            BCM43xx_PHY_OFDM(0x73)  /* OFDM
> table data I */
> #define BCM43xx_PHY_OTABLEQ            BCM43xx_PHY_OFDM(0x74)  /* OFDM
> table data Q */
> #define BCM43xx_PHY_HPWR_TSSICTL       BCM43xx_PHY_OFDM(0x78)  /* Hardware
> power TSSI control */
> +#define BCM43xx_PHY_ADCCTL             BCM43xx_PHY_OFDM(0x7A)  /* ADC
> control */
> +#define BCM43xx_PHY_IDLE_TSSI          BCM43xx_PHY_OFDM(0x7B)
> +#define BCM43xx_PHY_A_TEMP_SENSE       BCM43xx_PHY_OFDM(0x7C)  /* A PHY
> temperature sense */
> #define BCM43xx_PHY_NRSSITHRES         BCM43xx_PHY_OFDM(0x8A)  /* NRSSI
> threshold */
> #define BCM43xx_PHY_ANTWRSETT          BCM43xx_PHY_OFDM(0x8C)  /* Antenna
> WR settle */
> #define  BCM43xx_PHY_ANTWRSETT_ARXDIV  0x2000                  /*
> Automatic RX diversity enabled */
> @@ -55,6 +62,8 @@ struct bcm43xx_wldev;
> #define BCM43xx_PHY_N1N2GAIN           BCM43xx_PHY_OFDM(0xA2)
> #define BCM43xx_PHY_CLIPTHRES          BCM43xx_PHY_OFDM(0xA3)
> #define BCM43xx_PHY_CLIPN1P2THRES      BCM43xx_PHY_OFDM(0xA4)
> +#define BCM43xx_PHY_CCKSHIFTBITS_WA    BCM43xx_PHY_OFDM(0xA5)  /* CCK
> shiftbits workaround, FIXME rename */
> +#define BCM43xx_PHY_CCKSHIFTBITS       BCM43xx_PHY_OFDM(0xA7)  /* FIXME
> rename */
> #define BCM43xx_PHY_DIVSRCHIDX         BCM43xx_PHY_OFDM(0xA8)  /* Divider
> search gain/index */
> #define BCM43xx_PHY_CLIPP2THRES                BCM43xx_PHY_OFDM(0xA9)
> #define BCM43xx_PHY_CLIPP3THRES                BCM43xx_PHY_OFDM(0xAA)
> @@ -128,13 +137,14 @@ struct bcm43xx_wldev;
> #define BCM43xx_OFDMTAB_DC             BCM43xx_OFDMTAB(0x0E, 7)
> #define BCM43xx_OFDMTAB_PWRDYN2                BCM43xx_OFDMTAB(0x0E, 12)
> #define BCM43xx_OFDMTAB_LNAGAIN                BCM43xx_OFDMTAB(0x0E, 13)
> -//TODO
> +#define BCM43xx_OFDMTAB_UNKNOWN_0F     BCM43xx_OFDMTAB(0x0F,
> 0)        //TODO rename
> +#define BCM43xx_OFDMTAB_UNKNOWN_APHY   BCM43xx_OFDMTAB(0x0F,
> 7)        //TODO rename
> #define BCM43xx_OFDMTAB_LPFGAIN                BCM43xx_OFDMTAB(0x0F, 12)
> #define BCM43xx_OFDMTAB_RSSI           BCM43xx_OFDMTAB(0x10, 0)
> -//TODO
> +#define BCM43xx_OFDMTAB_UNKNOWN_11     BCM43xx_OFDMTAB(0x11,
> 4)        //TODO rename
> #define BCM43xx_OFDMTAB_AGC1_R1                BCM43xx_OFDMTAB(0x13, 0)
> -#define BCM43xx_OFDMTAB_GAINX_R1       BCM43xx_OFDMTAB(0x14,
> 0)        //TODO rename
> -#define BCM43xx_OFDMTAB_MINSIGSQ       BCM43xx_OFDMTAB(0x14, 1)
> +#define BCM43xx_OFDMTAB_GAINX_R1       BCM43xx_OFDMTAB(0x14,
> 0)        //TODO remove!
> +#define BCM43xx_OFDMTAB_MINSIGSQ       BCM43xx_OFDMTAB(0x14, 0)
> #define BCM43xx_OFDMTAB_AGC3_R1                BCM43xx_OFDMTAB(0x15, 0)
> #define BCM43xx_OFDMTAB_WRSSI_R1       BCM43xx_OFDMTAB(0x15, 4)
> #define BCM43xx_OFDMTAB_TSSI           BCM43xx_OFDMTAB(0x15, 0)
> Index:
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h
> ===================================================================
> --- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h
> 2007-05-12 16:27:31.000000000 +0200
> +++
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h  2007-05-12
> 16:29: 05.000000000 +0200
> @@ -17,12 +17,18 @@ extern const u16 bcm43xx_tab_noisea3[];
> extern const u16 bcm43xx_tab_noiseg1[];
> #define BCM43xx_TAB_NOISEG2_SIZE       8
> extern const u16 bcm43xx_tab_noiseg2[];
> -#define BCM43xx_TAB_NOISESCALEG_SIZE   27
> +#define BCM43xx_TAB_NOISESCALE_SIZE    27
> +extern const u16 bcm43xx_tab_noisescalea2[];
> +extern const u16 bcm43xx_tab_noisescalea3[];
> extern const u16 bcm43xx_tab_noisescaleg1[];
> extern const u16 bcm43xx_tab_noisescaleg2[];
> extern const u16 bcm43xx_tab_noisescaleg3[];
> #define BCM43xx_TAB_SIGMASQR_SIZE      53
> extern const u16 bcm43xx_tab_sigmasqr1[];
> extern const u16 bcm43xx_tab_sigmasqr2[];
> +#define BCM43xx_TAB_RSSIAGC1_SIZE      16
> +extern const u16 bcm43xx_tab_rssiagc1[];
> +#define BCM43xx_TAB_RSSIAGC2_SIZE      48
> +extern const u16 bcm43xx_tab_rssiagc2[];
>
> #endif /* BCM43xx_TABLES_H_ */
> Index:
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
> ===================================================================
> --- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c        2007-05-12
> 16:27:31.000000000 +0200
> +++
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
> 2007-05-12 16:29: 05.000000000 +0200
> @@ -34,6 +34,7 @@
> #include "bcm43xx_tables.h"
> #include "bcm43xx_power.h"
> #include "bcm43xx_lo.h"
> +#include "bcm43xx_wa.h"
>
>
> static const s8 bcm43xx_tssi2dbm_b_table[] = {
> @@ -559,393 +560,96 @@ static void bcm43xx_phy_init_pctl(struct
>         bcm43xx_shm_clear_tssi(dev);
> }
>
> -static void bcm43xx_phy_agcsetup(struct bcm43xx_wldev *dev)
> +static void bcm43xx_phy_rssiagc(struct bcm43xx_wldev *dev, u8 enable)
> {
> -       struct bcm43xx_phy *phy = &dev->phy;
> -       u16 offset = 0x0000;
> -
> -       if (phy->rev == 1)
> -               offset = 0x4C00;
> -
> -       bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00FE);
> -       bcm43xx_ofdmtab_write16(dev, offset, 1, 0x000D);
> -       bcm43xx_ofdmtab_write16(dev, offset, 2, 0x0013);
> -       bcm43xx_ofdmtab_write16(dev, offset, 3, 0x0019);
> -
> -       if (phy->rev == 1) {
> -               bcm43xx_ofdmtab_write16(dev, 0x1800, 0, 0x2710);
> -               bcm43xx_ofdmtab_write16(dev, 0x1801, 0, 0x9B83);
> -               bcm43xx_ofdmtab_write16(dev, 0x1802, 0, 0x9B83);
> -               bcm43xx_ofdmtab_write16(dev, 0x1803, 0, 0x0F8D);
> -               bcm43xx_phy_write(dev, 0x0455, 0x0004);
> -       }
> -
> -       bcm43xx_phy_write(dev, 0x04A5,
> -                         (bcm43xx_phy_read(dev, 0x04A5)
> -                          & 0x00FF) | 0x5700);
> -       bcm43xx_phy_write(dev, 0x041A,
> -                         (bcm43xx_phy_read(dev, 0x041A)
> -                          & 0xFF80) | 0x000F);
> -       bcm43xx_phy_write(dev, 0x041A,
> -                         (bcm43xx_phy_read(dev, 0x041A)
> -                          & 0xC07F) | 0x2B80);
> -       bcm43xx_phy_write(dev, 0x048C,
> -                         (bcm43xx_phy_read(dev, 0x048C)
> -                          & 0xF0FF) | 0x0300);
> -
> -       bcm43xx_radio_write16(dev, 0x007A,
> -                             bcm43xx_radio_read16(dev, 0x007A)
> -                             | 0x0008);
> -
> -       bcm43xx_phy_write(dev, 0x04A0,
> -                         (bcm43xx_phy_read(dev, 0x04A0)
> -                          & 0xFFF0) | 0x0008);
> -       bcm43xx_phy_write(dev, 0x04A1,
> -                         (bcm43xx_phy_read(dev, 0x04A1)
> -                          & 0xF0FF) | 0x0600);
> -       bcm43xx_phy_write(dev, 0x04A2,
> -                         (bcm43xx_phy_read(dev, 0x04A2)
> -                          & 0xF0FF) | 0x0700);
> -       bcm43xx_phy_write(dev, 0x04A0,
> -                         (bcm43xx_phy_read(dev, 0x04A0)
> -                          & 0xF0FF) | 0x0100);
> -
> -       if (phy->rev == 1) {
> -               bcm43xx_phy_write(dev, 0x04A2,
> -                                 (bcm43xx_phy_read(dev, 0x04A2)
> -                                  & 0xFFF0) | 0x0007);
> -       }
> -
> -       bcm43xx_phy_write(dev, 0x0488,
> -                         (bcm43xx_phy_read(dev, 0x0488)
> -                          & 0xFF00) | 0x001C);
> -       bcm43xx_phy_write(dev, 0x0488,
> -                         (bcm43xx_phy_read(dev, 0x0488)
> -                          & 0xC0FF) | 0x0200);
> -       bcm43xx_phy_write(dev, 0x0496,
> -                         (bcm43xx_phy_read(dev, 0x0496)
> -                          & 0xFF00) | 0x001C);
> -       bcm43xx_phy_write(dev, 0x0489,
> -                         (bcm43xx_phy_read(dev, 0x0489)
> -                          & 0xFF00) | 0x0020);
> -       bcm43xx_phy_write(dev, 0x0489,
> -                         (bcm43xx_phy_read(dev, 0x0489)
> -                          & 0xC0FF) | 0x0200);
> -       bcm43xx_phy_write(dev, 0x0482,
> -                         (bcm43xx_phy_read(dev, 0x0482)
> -                          & 0xFF00) | 0x002E);
> -       bcm43xx_phy_write(dev, 0x0496,
> -                         (bcm43xx_phy_read(dev, 0x0496)
> -                          & 0x00FF) | 0x1A00);
> -       bcm43xx_phy_write(dev, 0x0481,
> -                         (bcm43xx_phy_read(dev, 0x0481)
> -                          & 0xFF00) | 0x0028);
> -       bcm43xx_phy_write(dev, 0x0481,
> -                         (bcm43xx_phy_read(dev, 0x0481)
> -                          & 0x00FF) | 0x2C00);
> -
> -       if (phy->rev == 1) {
> -               bcm43xx_phy_write(dev, 0x0430, 0x092B);
> -               bcm43xx_phy_write(dev, 0x041B,
> -                                 (bcm43xx_phy_read(dev, 0x041B)
> -                                  & 0xFFE1) | 0x0002);
> -       } else {
> -               bcm43xx_phy_write(dev, 0x041B,
> -                                 bcm43xx_phy_read(dev, 0x041B)
> -                                 & 0xFFE1);
> -               bcm43xx_phy_write(dev, 0x041F, 0x287A);
> -               bcm43xx_phy_write(dev, 0x0420,
> -                                 (bcm43xx_phy_read(dev, 0x0420)
> -                                  & 0xFFF0) | 0x0004);
> -       }
> -
> -       if (phy->rev >= 6) {
> -               bcm43xx_phy_write(dev, 0x0422, 0x287A);
> -               bcm43xx_phy_write(dev, 0x0420,
> -                                 (bcm43xx_phy_read(dev, 0x0420)
> -                                  & 0x0FFF) | 0x3000);
> -       }
> -
> -       bcm43xx_phy_write(dev, 0x04A8,
> -                         (bcm43xx_phy_read(dev, 0x04A8)
> -                          & 0x8080) | 0x7874);
> -       bcm43xx_phy_write(dev, 0x048E, 0x1C00);
> -
> -       offset = 0x0800;
> -       if (phy->rev == 1) {
> -               offset = 0x5400;
> -               bcm43xx_phy_write(dev, 0x04AB,
> -                                 (bcm43xx_phy_read(dev, 0x04AB)
> -                                  & 0xF0FF) | 0x0600);
> -               bcm43xx_phy_write(dev, 0x048B, 0x005E);
> -               bcm43xx_phy_write(dev, 0x048C,
> -                                 (bcm43xx_phy_read(dev, 0x048C)
> -                                  & 0xFF00) | 0x001E);
> -               bcm43xx_phy_write(dev, 0x048D, 0x0002);
> -       }
> -       bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00);
> -       bcm43xx_ofdmtab_write16(dev, offset, 1, 0x07);
> -       bcm43xx_ofdmtab_write16(dev, offset, 2, 0x10);
> -       bcm43xx_ofdmtab_write16(dev, offset, 3, 0x1C);
> -
> -       if (phy->rev >= 6) {
> -               bcm43xx_phy_write(dev, 0x0426,
> -                                 bcm43xx_phy_read(dev, 0x0426)
> -                                 & 0xFFFC);
> -               bcm43xx_phy_write(dev, 0x0426,
> -                                 bcm43xx_phy_read(dev, 0x0426)
> -                                 & 0xEFFF);
> -       }
> -}
> -
> -static void bcm43xx_phy_setupg(struct bcm43xx_wldev *dev)
> -{
> -       struct ssb_bus *bus = dev->dev->bus;
> -       struct bcm43xx_phy *phy = &dev->phy;
> -       u16 i;
> -
> -       assert(phy->type == BCM43xx_PHYTYPE_G);
> -       if (phy->rev == 1) {
> -               bcm43xx_phy_write(dev, 0x0406, 0x4F19);
> -               bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
> -                                 (bcm43xx_phy_read(dev,
> BCM43xx_PHY_G_CRS) & 0xFC3F) | 0x0340);
> -               bcm43xx_phy_write(dev, 0x042C, 0x005A);
> -               bcm43xx_phy_write(dev, 0x0427, 0x001A);
> -
> -               for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x5800, i,
> bcm43xx_tab_finefreqg[i]);
> -               for (i = 0; i < BCM43xx_TAB_NOISEG1_SIZE; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x1800, i,
> bcm43xx_tab_noiseg1[i]);
> -               for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x2000, i,
> bcm43xx_tab_rotor[i]);
> -       } else {
> -               /* nrssi values are signed 6-bit values. Not sure why we
> write 0x7654 here... */
> -               bcm43xx_nrssi_hw_write(dev, 0xBA98, (s16)0x7654);
> -
> -               if (phy->rev == 2) {
> -                       bcm43xx_phy_write(dev, 0x04C0, 0x1861);
> -                       bcm43xx_phy_write(dev, 0x04C1, 0x0271);
> -               } else if (phy->rev > 2) {
> -                       bcm43xx_phy_write(dev, 0x04C0, 0x0098);
> -                       bcm43xx_phy_write(dev, 0x04C1, 0x0070);
> -                       bcm43xx_phy_write(dev, 0x04C9, 0x0080);
> -               }
> -               bcm43xx_phy_write(dev, 0x042B, bcm43xx_phy_read(dev,
> 0x042B) | 0x800);
> -
> -               for (i = 0; i < 64; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x4000, i, i);
> -               for (i = 0; i < BCM43xx_TAB_NOISEG2_SIZE; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x1800, i,
> bcm43xx_tab_noiseg2[i]);
> -       }
> -
> -       if (phy->rev <= 2)
> -               for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x1400, i,
> bcm43xx_tab_noisescaleg1[i]);
> -       else if ((phy->rev >= 7) && (bcm43xx_phy_read(dev, 0x0449) &
> 0x0200))
> -               for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x1400, i,
> bcm43xx_tab_noisescaleg3[i]);
> -       else
> -               for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x1400, i,
> bcm43xx_tab_noisescaleg2[i]);
> -
> -       if (phy->rev == 2)
> -               for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x5000, i,
> bcm43xx_tab_sigmasqr1[i]);
> -       else if ((phy->rev > 2) && (phy->rev <= 8))
> -               for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x5000, i,
> bcm43xx_tab_sigmasqr2[i]);
> -
> -       if (phy->rev == 1) {
> -               for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
> -                       bcm43xx_ofdmtab_write32(dev, 0x2400, i,
> bcm43xx_tab_retard[i]);
> -               for (i = 0; i < 4; i++) {
> -                       bcm43xx_ofdmtab_write16(dev, 0x5404, i, 0x0020);
> -                       bcm43xx_ofdmtab_write16(dev, 0x5408, i, 0x0020);
> -                       bcm43xx_ofdmtab_write16(dev, 0x540C, i, 0x0020);
> -                       bcm43xx_ofdmtab_write16(dev, 0x5410, i, 0x0020);
> -               }
> -               bcm43xx_phy_agcsetup(dev);
> -
> -               if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
> -                   (bus->board_type == SSB_BOARD_BU4306) &&
> -                   (bus->board_rev == 0x17))
> -                       return;
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x5001, 0, 0x0002);
> -               bcm43xx_ofdmtab_write16(dev, 0x5002, 0, 0x0001);
> -       } else {
> -               for (i = 0; i <= 0x2F; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x1000, i, 0x0820);
> -               bcm43xx_phy_agcsetup(dev);
> -               bcm43xx_phy_read(dev, 0x0400); /* dummy read */
> -               bcm43xx_phy_write(dev, 0x0403, 0x1000);
> -               bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
> -               bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
> -
> -               if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
> -                   (bus->board_type == SSB_BOARD_BU4306) &&
> -                   (bus->board_rev == 0x17))
> -                       return;
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x0401, 0, 0x0002);
> -               bcm43xx_ofdmtab_write16(dev, 0x0402, 0, 0x0001);
> -       }
> -}
> -
> -/* Initialize the noisescaletable for APHY */
> -static void bcm43xx_phy_init_noisescaletbl(struct bcm43xx_wldev *dev)
> -{
> -       struct bcm43xx_phy *phy = &dev->phy;
>         int i;
>
> -       for (i = 0; i < 12; i++) {
> -               if (phy->rev == 2)
> -                       bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6767);
> +       if (dev->phy.rev < 3) {
> +               if (enable)
> +                       for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
> +                               bcm43xx_ofdmtab_write16(dev,
> +                                       BCM43xx_OFDMTAB_LNAHPFGAIN1, i,
> 0xFFF8);
> +                               bcm43xx_ofdmtab_write16(dev,
> +                                       BCM43xx_OFDMTAB_WRSSI, i, 0xFFF8);
> +                       }
>                 else
> -                       bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2323);
> -       }
> -       if (phy->rev == 2)
> -               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6700);
> -       else
> -               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2300);
> -       for (i = 0; i < 11; i++) {
> -               if (phy->rev == 2)
> -                       bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6767);
> +                       for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
> +                               bcm43xx_ofdmtab_write16(dev,
> +                                       BCM43xx_OFDMTAB_LNAHPFGAIN1, i,
> bcm43xx_tab_rssiagc1[i]);
> +                               bcm43xx_ofdmtab_write16(dev,
> +                                       BCM43xx_OFDMTAB_WRSSI, i,
> bcm43xx_tab_rssiagc1[i]);
> +                       }
> +       } else {
> +               if (enable)
> +                       for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++)
> +                               bcm43xx_ofdmtab_write16(dev,
> +                                       BCM43xx_OFDMTAB_WRSSI, i, 0x0820);
>                 else
> -                       bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2323);
> +                       for (i = 0; i < BCM43xx_TAB_RSSIAGC2_SIZE; i++)
> +                               bcm43xx_ofdmtab_write16(dev,
> +                                       BCM43xx_OFDMTAB_WRSSI, i,
> bcm43xx_tab_rssiagc2[i]);
>         }
> -       if (phy->rev == 2)
> -               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0067);
> -       else
> -               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0023);
> }
>
> -static void bcm43xx_phy_setupa(struct bcm43xx_wldev *dev)
> +static void bcm43xx_phy_ww(struct bcm43xx_wldev *dev)
> {
> -       struct bcm43xx_phy *phy = &dev->phy;
> -       u16 i;
> -
> -       assert(phy->type == BCM43xx_PHYTYPE_A);
> -       switch (phy->rev) {
> -       case 2:
> -               bcm43xx_phy_write(dev, 0x008E, 0x3800);
> -               bcm43xx_phy_write(dev, 0x0035, 0x03FF);
> -               bcm43xx_phy_write(dev, 0x0036, 0x0400);
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
> -
> -               bcm43xx_phy_write(dev, 0x001C, 0x0FF9);
> -               bcm43xx_phy_write(dev, 0x0020, bcm43xx_phy_read(dev,
> 0x0020) & 0xFF0F);
> -               bcm43xx_ofdmtab_write16(dev, 0x3C0C, 0, 0x07BF);
> -               bcm43xx_radio_write16(dev, 0x0002, 0x07BF);
> -
> -               bcm43xx_phy_write(dev, 0x0024, 0x4680);
> -               bcm43xx_phy_write(dev, 0x0020, 0x0003);
> -               bcm43xx_phy_write(dev, 0x001D, 0x0F40);
> -               bcm43xx_phy_write(dev, 0x001F, 0x1C00);
> -
> -               bcm43xx_phy_write(dev, 0x002A,
> -                                 (bcm43xx_phy_read(dev, 0x002A)
> -                                  & 0x00FF) | 0x0400);
> -               bcm43xx_phy_write(dev, 0x002B,
> -                                 bcm43xx_phy_read(dev, 0x002B)
> -                                 & 0xFBFF);
> -               bcm43xx_phy_write(dev, 0x008E, 0x58C1);
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
> -               bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
> -               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
> -               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
> -               bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
> -               bcm43xx_ofdmtab_write16(dev, 0x0000, 1, 0x0013);
> -               bcm43xx_ofdmtab_write16(dev, 0x0000, 2, 0x0013);
> -               bcm43xx_ofdmtab_write16(dev, 0x0000, 3, 0x0013);
> -               bcm43xx_ofdmtab_write16(dev, 0x0000, 4, 0x0015);
> -               bcm43xx_ofdmtab_write16(dev, 0x0000, 5, 0x0015);
> -               bcm43xx_ofdmtab_write16(dev, 0x0000, 6, 0x0019);
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
> -               bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
> -               bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
> -
> -               for (i = 0; i < 16; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x4000, i, (0x8 + i)
> & 0x000F);
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x3003, 0, 0x1044);
> -               bcm43xx_ofdmtab_write16(dev, 0x3004, 0, 0x7201);
> -               bcm43xx_ofdmtab_write16(dev, 0x3006, 0, 0x0040);
> -               bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
> (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0x0010) | 0x0008);
> -
> -               for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x5800, i,
> bcm43xx_tab_finefreqa[i]);
> -               for (i = 0; i < BCM43xx_TAB_NOISEA2_SIZE; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x1800, i,
> bcm43xx_tab_noisea2[i]);
> -               for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
> -                       bcm43xx_ofdmtab_write32(dev, 0x2000, i,
> bcm43xx_tab_rotor[i]);
> -               bcm43xx_phy_init_noisescaletbl(dev);
> -               for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
> -                       bcm43xx_ofdmtab_write32(dev, 0x2400, i,
> bcm43xx_tab_retard[i]);
> -               break;
> -       case 3:
> -               for (i = 0; i < 64; i++)
> -                       bcm43xx_ofdmtab_write16(dev, 0x4000, i, i);
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
> -
> -               bcm43xx_phy_write(dev, 0x001C, 0x0FF9);
> -               bcm43xx_phy_write(dev, 0x0020,
> -                                 bcm43xx_phy_read(dev, 0x0020) & 0xFF0F);
> -               bcm43xx_radio_write16(dev, 0x0002, 0x07BF);
> -
> -               bcm43xx_phy_write(dev, 0x0024, 0x4680);
> -               bcm43xx_phy_write(dev, 0x0020, 0x0003);
> -               bcm43xx_phy_write(dev, 0x001D, 0x0F40);
> -               bcm43xx_phy_write(dev, 0x001F, 0x1C00);
> -               bcm43xx_phy_write(dev, 0x002A,
> -                                 (bcm43xx_phy_read(dev, 0x002A)
> -                                  & 0x00FF) | 0x0400);
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x3000, 1,
> -                                       (bcm43xx_ofdmtab_read16(dev,
> 0x3000, 1)
> -                                       & 0x0010) | 0x0008);
> -               for (i = 0; i < BCM43xx_TAB_NOISEA3_SIZE; i++) {
> -                       bcm43xx_ofdmtab_write16(dev, 0x1800, i,
> -                                               bcm43xx_tab_noisea3[i]);
> -               }
> -               bcm43xx_phy_init_noisescaletbl(dev);
> -               for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++) {
> -                       bcm43xx_ofdmtab_write16(dev, 0x5000, i,
> -                                               bcm43xx_tab_sigmasqr1[i]);
>
> -               }
> -
> -               bcm43xx_phy_write(dev, 0x0003, 0x1808);
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
> -               bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
> -               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
> -               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
> -               bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
> -               bcm43xx_ofdmtab_write16(dev, 0x0001, 0, 0x0013);
> -               bcm43xx_ofdmtab_write16(dev, 0x0002, 0, 0x0013);
> -               bcm43xx_ofdmtab_write16(dev, 0x0003, 0, 0x0013);
> -               bcm43xx_ofdmtab_write16(dev, 0x0004, 0, 0x0015);
> -               bcm43xx_ofdmtab_write16(dev, 0x0005, 0, 0x0015);
> -               bcm43xx_ofdmtab_write16(dev, 0x0006, 0, 0x0019);
> -
> -               bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
> -               bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
> -               bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
> +       u16 b, curr_s, best_s = 0xFFFF;
> +       int i;
>
> -               bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
> -               bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
> -               break;
> -       default:
> -               assert(0);
> -       }
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
> +               bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) &
> ~BCM43xx_PHY_CRS0_EN);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
> +               bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) | 0x1000);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82)) & 0xF0FF) |
> 0x0300);
> +       bcm43xx_radio_write16(dev, 0x0009,
> +               bcm43xx_radio_read16(dev, 0x0009) | 0x0080);
> +       bcm43xx_radio_write16(dev, 0x0012,
> +               (bcm43xx_radio_read16(dev, 0x0012) & 0xFFFC) | 0x0002);
> +       bcm43xx_wa_initgains(dev);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBA), 0x3ED5);
> +       b = bcm43xx_phy_read(dev, BCM43xx_PHY_PWRDOWN);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, (b & 0xFFF8) |
> 0x0005);
> +       bcm43xx_radio_write16(dev, 0x0004,
> +               bcm43xx_radio_read16(dev, 0x0004) | 0x0004);
> +       for (i = 0x10; i <= 0x20; i++) {
> +               bcm43xx_radio_write16(dev, 0x0013, i);
> +               curr_s = bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEQ) &
> 0x00FF;
> +               if (!curr_s) {
> +                       best_s = 0x0000;
> +                       break;
> +               } else if (curr_s >= 0x0080)
> +                       curr_s = 0x0100 - curr_s;
> +               if (curr_s < best_s)
> +                       best_s = curr_s;
> +       }
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, b);
> +       bcm43xx_radio_write16(dev, 0x0004,
> +               bcm43xx_radio_read16(dev, 0x0004) & 0xFFFB);
> +       bcm43xx_radio_write16(dev, 0x0013, best_s);
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 0, 0xFFEC);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB7), 0x1E80);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB6), 0x1C00);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB5), 0x0EC0);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB2), 0x00C0);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB9), 0x1FFF);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBB),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0xBB)) & 0xF000) |
> 0x0053);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM61,
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM61 & 0xFE1F)) |
> 0x0120);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x13),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x13)) & 0x0FFF) |
> 0x3000);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x14),
> +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x14)) & 0x0FFF) |
> 0x3000);
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 6, 0x0017);
> +       for (i = 0; i < 6; i++)
> +               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, i,
> 0x000F);
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0D, 0x000E);
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0E, 0x0011);
> +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0F, 0x0013);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x33), 0x5030);
> +       bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
> +               bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) |
> BCM43xx_PHY_CRS0_EN);
> }
>
> /* Initialize APHY. This is also called for the GPHY in some cases. */
> @@ -953,60 +657,52 @@ static void bcm43xx_phy_inita(struct bcm
> {
>         struct ssb_bus *bus = dev->dev->bus;
>         struct bcm43xx_phy *phy = &dev->phy;
> -       u16 tval;
>
> -       if (phy->type == BCM43xx_PHYTYPE_A) {
> -               bcm43xx_phy_setupa(dev);
> -       } else {
> -               bcm43xx_phy_setupg(dev);
> -               if (phy->gmode &&
> -                   (dev->dev->bus->sprom.r1.boardflags_lo &
> BCM43xx_BFL_PACTRL))
> -                       bcm43xx_phy_write(dev, 0x046E, 0x03CF);
> -               return;
> +       if (phy->rev >= 6) {
> +               if (phy->type == BCM43xx_PHYTYPE_A)
> +                       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
> +                               bcm43xx_phy_read(dev,
> BCM43xx_PHY_OFDM(0x1B)) & ~0x1000);
> +               if (bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) &
> BCM43xx_PHY_ENCORE_EN)
> +                       bcm43xx_phy_write(dev, BCM43xx_PHY_ENCORE,
> +                               bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE)
> | 0x0010);
> +               else
> +                       bcm43xx_phy_write(dev, BCM43xx_PHY_ENCORE,
> +                               bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE)
> & ~0x1010);
>         }
> +       bcm43xx_wa_all(dev);
>
> -       bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
> -                         (bcm43xx_phy_read(dev, BCM43xx_PHY_A_CRS) &
> 0xF83C) | 0x0340);
> -       bcm43xx_phy_write(dev, 0x0034, 0x0001);
> -
> -       TODO();//TODO: RSSI AGC
> -       bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
> -                         bcm43xx_phy_read(dev, BCM43xx_PHY_A_CRS) | (1 <<
> 14));
> -       bcm43xx_radio_init2060(dev);
> +       if (phy->type == BCM43xx_PHYTYPE_A) {
> +               if (phy->gmode &&
> +                   (phy->rev < 3))
> +                       bcm43xx_phy_write(dev, 0x0034,
> +                               bcm43xx_phy_read(dev, 0x0034) | 0x0001);
>
> -       if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
> -           ((bus->board_type == SSB_BOARD_BU4306) ||
> -            (bus->board_type == SSB_BOARD_BU4309))) {
> -               if (phy->lofcal == 0xFFFF) {
> -                       TODO();//TODO: LOF Cal
> -                       bcm43xx_radio_set_tx_iq(dev);
> -               } else
> -                       bcm43xx_radio_write16(dev, 0x001E, phy->lofcal);
> -       }
> +               bcm43xx_phy_rssiagc(dev, 0);
>
> -       bcm43xx_phy_write(dev, 0x007A, 0xF111);
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
> +                       bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) |
> BCM43xx_PHY_CRS0_EN);
>
> -       if (phy->cur_idle_tssi == 0) {
> -               bcm43xx_radio_write16(dev, 0x0019, 0x0000);
> -               bcm43xx_radio_write16(dev, 0x0017, 0x0020);
> +               bcm43xx_radio_init2060(dev);
>
> -               tval = bcm43xx_ofdmtab_read16(dev, 0x3001, 0);
> -               if (phy->rev == 1) {
> -                       bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
> -                                         (bcm43xx_ofdmtab_read16(dev,
> 0x3001, 0) & 0xFF87)
> -                                         | 0x0058);
> -               } else {
> -                       bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
> -                                         (bcm43xx_ofdmtab_read16(dev,
> 0x3001, 0) & 0xFFC3)
> -                                         | 0x002C);
> +               if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
> +                   ((bus->board_type == SSB_BOARD_BU4306) ||
> +                    (bus->board_type == SSB_BOARD_BU4309))) {
> +                       ; //TODO: A PHY LO
>                 }
> -               bcm43xx_dummy_transmission(dev);
> -               phy->cur_idle_tssi = bcm43xx_phy_read(dev,
> BCM43xx_PHY_A_PCTL);
> -               bcm43xx_ofdmtab_write16(dev, 0x3001, 0, tval);
>
> -               bcm43xx_radio_set_txpower_a(dev, 0x0018);
> +               if (phy->rev >= 3)
> +                       bcm43xx_phy_ww(dev);
> +
> +               hardware_pctl_init_aphy(dev);
> +
> +               //TODO: radar detection
> +       }
> +       if ((phy->type == BCM43xx_PHYTYPE_G) &&
> +           (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_PACTRL))
> {
> +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x6E),
> +                                 (bcm43xx_phy_read(dev,
> BCM43xx_PHY_OFDM(0x6E))
> +                                  & 0xE000) | 0x3CF);
>         }
> -       bcm43xx_shm_clear_tssi(dev);
> }
>
> static void bcm43xx_phy_initb2(struct bcm43xx_wldev *dev)
> Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile
> ===================================================================
> --- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/Makefile
> 2007-05-12 16:27: 31.000000000 +0200
> +++
> bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile  2007-05-12
> 16:29:05.000000000 +0200
> @@ -15,4 +15,5 @@ bcm43xx-mac80211-objs := bcm43xx_main.o
>                          bcm43xx_leds.o \
>                          bcm43xx_xmit.o \
>                          bcm43xx_lo.o \
> +                        bcm43xx_wa.o \
>                          $(bcm43xx-mac80211-obj-y)
>
>
> --
> Greetings Michael.
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070513/5e02b7b7/attachment.html>

From mb at bu3sch.de  Sun May 13 19:24:26 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 13 May 2007 19:24:26 +0200
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <b1923f7f0705131002s79d08454k430d2c0051c2d840@mail.gmail.com>
References: <20070423202530.2829f309@localhost>
	<200705121750.57090.mb@bu3sch.de>
	<b1923f7f0705131002s79d08454k430d2c0051c2d840@mail.gmail.com>
Message-ID: <200705131924.26373.mb@bu3sch.de>

Everybody always follow this rule:
Every patch I post to this list is broken unless I explicitely
state otherwise.

That makes sense, because I wouldn't post it here, but rather
commit it to git instead, if it was ok. ;)

Patches I post here are only for developers and not useful
at all for users to get xyz running.

-- 
Greetings Michael.


From zajec5polish at gmail.com  Sun May 13 21:31:03 2007
From: zajec5polish at gmail.com (=?UTF-8?Q?Rafa=C5=82_Mi=C5=82ecki?=)
Date: Sun, 13 May 2007 21:31:03 +0200
Subject: Kernel 2.6.22-rc1
In-Reply-To: <fb1e10a90705131009l34c9e464re6d8a3b7957ac05c@mail.gmail.com>
References: <14b026160705130627q25ce2b83s1ae5cd77e6e7a7ca@mail.gmail.com>
	<fb1e10a90705131009l34c9e464re6d8a3b7957ac05c@mail.gmail.com>
Message-ID: <14b026160705131231p13a16da5l36351b71cd46bf36@mail.gmail.com>

2007/5/13, Asil Jinn <asil.jinn at gmail.com>:
> Just check the changelog, and search for bcm43xx.. I found around 4 new
> patches for bcm43xx.

Does these patches are important? For me they could include one nice
patch from ftp://lwfinger.dynalias.org/patches and it would be
probably enought ;-)
-- 
Rafa? Mi?ecki

From larry.finger at lwfinger.net  Sun May 13 21:46:01 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 13 May 2007 14:46:01 -0500
Subject: Kernel 2.6.22-rc1
In-Reply-To: <14b026160705130627q25ce2b83s1ae5cd77e6e7a7ca@mail.gmail.com>
References: <14b026160705130627q25ce2b83s1ae5cd77e6e7a7ca@mail.gmail.com>
Message-ID: <46476AF9.7080002@lwfinger.net>

Rafa? Mi?ecki wrote:
> Does this version of kernel (from today) includes all these important
> fixes/patches for bcm43xx?
> 
Yes.

Larry



From geo_saleh at yahoo.com  Tue May 15 12:30:10 2007
From: geo_saleh at yahoo.com (saleh saeed)
Date: Tue, 15 May 2007 03:30:10 -0700 (PDT)
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <b1923f7f0705131002s79d08454k430d2c0051c2d840@mail.gmail.com>
Message-ID: <25658.26952.qm@web61016.mail.yahoo.com>

I am new in linux

I have hp pavilion dv6248eu
with AMD turion 64 x2
and Broadcom 4312 wireless card.
how can I use this patch to make my wireless card working

thanks

Anthony Durity <bcm43xx at jollyrotten.org> wrote: Hi Michael (and everyone else),

I am trying to get my Broadcom wireless working. I met this nice guy at the Ubuntu
Dev Summit in Sevilla and he told me to
git-clone git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless- dev.git
and then build a custom kernel (a thing I have not had to do in Linux for many a
year and my my the config options have expanded somewhat). He also suggested
I subscribe to this list and detail any problems I might have. 

Here is an lspic -vv of the chipset
03:02.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 54g] 802.11g Wireless LAN Controller (rev 02)
        Subsystem: Hewlett-Packard Company MX6125
         Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- 
        Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
        Latency: 64
        Interrupt: pin A routed to IRQ 21
        Region 0: Memory at b0204000 (32-bit, non-prefetchable) [size=8K] 

My laptop is a HP Compaq R4000 - specifically the R4218ea. It's got an Athlon 64
which is nice.

The thing is that I've seen you posting patches for the bcm43xx to this list. Should I
be applying these patches to the latest Linville kernel (after I've done a git-pull to ensure 
that I have the latest sources I guess) or not? Is there anything special I need to do?
Should I disable NetworkManager? Does Avahi interfere? I saw a couple of posts about
lowering the TX rate, should I do this? What options should I enable in the wireless kernel 
vis-a-vis bcm43xx. Should I use the Improved wireless configuration API? Should I
enable nl80211 new netlink interface support? Should I enable debugging output?
I want to be able to help you guys to the best of my ability so any info pushing me in 
the right direction would be greatly appreciated.

All the best,
    Anthony Durity

On 5/12/07, Michael Buesch < mb at bu3sch.de > wrote:On Saturday 12 May 2007 01:07:01 Michael Buesch wrote:
> On Friday 11 May 2007 12:24:33 Michael Buesch wrote: 
> > On Monday 23 April 2007 20:30:41 Stefano Brivio wrote:
> > > This patch fixes A/G PHYs setup and initialization routines. Let's move
> > > the so-called workarounds in a separate file, in order to avoid clobbering 
> > > bcm43xx_phy.c.

Here's latest version of the patch.
Yet another few bugs fixed.

Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c
=================================================================== 
--- /dev/null   1970-01-01 00:00:00.000000000 +0000
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c      2007-05-12 16:29:05.000000000 +0200
@@ -0,0 +1,668 @@
+/*
+
+  Broadcom BCM43xx wireless driver 
+
+  PHY workarounds.
+
+  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
+  Copyright (c) 2005-2007 Stefano Brivio <  st3 at riseup.net>
+  Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de>
+  Copyright (c) 2005, 2006 Danny van Dyk <  kugelfang at gentoo.org>
+  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi at waterwave.ch >
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful, 
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+
+*/
+
+#include "bcm43xx.h  "
+#include "bcm43xx_main.h"
+#include "bcm43xx_tables.h"
+#include "bcm43xx_phy.h"
+#include "bcm43xx_wa.h"
+
+static void bcm43xx_wa_papd(struct bcm43xx_wldev *dev) 
+{
+       u16 backup;
+
+       backup = bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0);
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0, 7);
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_APHY, 0, 0); 
+       bcm43xx_dummy_transmission(dev);
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2, 0, backup);
+}
+
+static void bcm43xx_wa_auxclipthr(struct bcm43xx_wldev *dev)
+{
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E), 0x3800); 
+}
+
+static void bcm43xx_wa_afcdac(struct bcm43xx_wldev *dev)
+{
+       bcm43xx_phy_write(dev, 0x0035, 0x03FF);
+       bcm43xx_phy_write(dev, 0x0036, 0x0400);
+}
+
+static void bcm43xx_wa_txdc_offset(struct bcm43xx_wldev *dev) 
+{
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 0, 0x0051);
+}
+
+void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev)
+{
+       struct bcm43xx_phy *phy = &dev->phy;
+
+       bcm43xx_phy_write(dev, BCM43xx_PHY_LNAHPFCTL, 0x1FF9); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+               bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & 0xFF0F);
+       if (phy->rev <= 2)
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_LPFGAIN, 0, 0x1FBF); 
+       bcm43xx_radio_write16(dev, 0x0002, 0x1FBF);
+
+       bcm43xx_phy_write(dev, 0x0024, 0x4680);
+       bcm43xx_phy_write(dev, 0x0020, 0x0003);
+       bcm43xx_phy_write(dev, 0x001D, 0x0F40);
+       bcm43xx_phy_write(dev, 0x001F, 0x1C00); 
+       if (phy->rev <= 3)
+               bcm43xx_phy_write(dev, 0x002A,
+                       (bcm43xx_phy_read(dev, 0x002A) & 0x00FF) | 0x0400);
+       else if (phy->rev == 5) {
+               bcm43xx_phy_write(dev, 0x002A, 
+                       (bcm43xx_phy_read(dev, 0x002A) & 0x00FF) | 0x1A00);
+               bcm43xx_phy_write(dev, 0x00CC, 0x2121);
+       }
+       if (phy->rev >= 3)
+               bcm43xx_phy_write(dev, 0x00BA, 0x3ED5); 
+}
+
+static void bcm43xx_wa_divider(struct bcm43xx_wldev *dev)
+{
+       bcm43xx_phy_write(dev, 0x002B, bcm43xx_phy_read(dev, 0x002B) & ~0x0100);
+       bcm43xx_phy_write(dev, 0x008E, 0x58C1);
  +}
+
+static void bcm43xx_wa_gt(struct bcm43xx_wldev *dev) /* Gain table. */
+{
+       if (dev->phy.rev <= 2) {
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 0, 15);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 1, 31); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 2, 42);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 3, 48);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN2, 4, 58); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 0, 19);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 1, 19);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 2, 19); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 3, 19);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 4, 21);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 5, 21); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 6, 25);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 0, 3);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 1, 3); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN1, 2, 7);
+       } else {
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 0, 19);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 1, 19); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 2, 19);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 3, 19);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 4, 21); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 5, 21);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAIN0, 6, 25);
+       }
+}
+
+static void bcm43xx_wa_rssi_lt(struct bcm43xx_wldev *dev) /* RSSI lookup table */ 
+{
+       int i;
+
+       for (i = 0; i < 8; i++)
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_RSSI, i, i + 8);
+       for (i = 8; i < 16; i++)
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_RSSI, i, i - 8); 
+}
+
+static void bcm43xx_wa_analog(struct bcm43xx_wldev *dev)
+{
+       struct bcm43xx_phy *phy = &dev->phy;
+
+       if (phy->analog > 2) {
+               if (phy->type == BCM43xx_PHYTYPE_A) 
+                       bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, 0x1808);
+               else
+                       bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, 0x1000);
+       } else {
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 3, 0x1044); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 4, 0x7201);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 6, 0x0040);
+       }
+}
+
+static void bcm43xx_wa_dac(struct bcm43xx_wldev *dev) 
+{
+       if (dev->phy.analog == 1)
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1,
+                       (bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 1) & ~0x0034) | 0x0008); 
+       else
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1,
+                       (bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 1) & ~0x0078) | 0x0010);
+}
+
+static void bcm43xx_wa_fft(struct bcm43xx_wldev *dev) /* Fine frequency table */ 
+{
+       int i;
+
+       if (dev->phy.type == BCM43xx_PHYTYPE_A)
+               for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
+                       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqa[i]); 
+       else
+               for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
+                       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqg[i]);
+}
+
+static void bcm43xx_wa_nft(struct bcm43xx_wldev *dev) /* Noise figure table */ 
+{
+       struct bcm43xx_phy *phy = &dev->phy;
+       int i;
+
+       if (phy->type == BCM43xx_PHYTYPE_A) {
+               if (phy->rev == 2)
+                       for (i = 0; i < BCM43xx_TAB_NOISEA2_SIZE; i++) 
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea2[i]);
+               else
+                       for (i = 0; i < BCM43xx_TAB_NOISEA3_SIZE; i++)
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea3[i]); 
+       } else {
+               if (phy->rev == 1)
+                       for (i = 0; i < BCM43xx_TAB_NOISEG1_SIZE; i++)
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg1[i]); 
+               else
+                       for (i = 0; i < BCM43xx_TAB_NOISEG2_SIZE; i++)
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg2[i]);
+       } 
+}
+
+static void bcm43xx_wa_rt(struct bcm43xx_wldev *dev) /* Rotor table */
+{
+       int i;
+
+       for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
+               bcm43xx_ofdmtab_write32(dev, BCM43xx_OFDMTAB_ROTOR, i, bcm43xx_tab_rotor[i]); 
+}
+
+static void bcm43xx_wa_nst(struct bcm43xx_wldev *dev) /* Noise scale table */
+{
+       struct bcm43xx_phy *phy = &dev->phy;
+       int i;
+
+       if (phy->type == BCM43xx_PHYTYPE_A) { 
+               if (phy->rev <= 1)
+                       for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
 +                                                       i, 0); 
+               else if (phy->rev == 2)
+                       for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
  +                                                       i, bcm43xx_tab_noisescalea2[i]);
+               else if (phy->rev == 3)
+                       for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE, 
+                                                       i, bcm43xx_tab_noisescalea3[i]);
+               else
+                       for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE, 
+                                                       i, bcm43xx_tab_noisescaleg3[i]);
+       } else {
+               if (phy->rev >= 6) {
+                       if (bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & BCM43xx_PHY_ENCORE_EN) 
+                               for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+                                       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
+                                               i, bcm43xx_tab_noisescaleg3[i]); 
+                       else
+                               for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+                                       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE, 
 +                                               i, bcm43xx_tab_noisescaleg2[i]);
+               } else {
+                       for (i = 0; i < BCM43xx_TAB_NOISESCALE_SIZE; i++)
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE, 
+                                                       i, bcm43xx_tab_noisescaleg1[i]);
+               }
+       }
+}
+
+static void bcm43xx_wa_art(struct bcm43xx_wldev *dev) /* ADV retard table */
  +{
+       int i;
+
+       for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
+                       bcm43xx_ofdmtab_write32(dev, BCM43xx_OFDMTAB_ADVRETARD,
+                               i, bcm43xx_tab_retard[i]); 
+}
+
+static void bcm43xx_wa_txlna_gain(struct bcm43xx_wldev *dev)
+{
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 13, 0x0000);
+}
+
+static void bcm43xx_wa_crs_reset(struct bcm43xx_wldev *dev) 
+{
+       bcm43xx_phy_write(dev, 0x002C, 0x0064);
+}
+
+static void bcm43xx_wa_2060txlna_gain(struct bcm43xx_wldev *dev)
+{
+       bcm43xx_hf_write(dev, bcm43xx_hf_read(dev) |
+                        BCM43xx_HF_2060W); 
+}
+
+static void bcm43xx_wa_lms(struct bcm43xx_wldev *dev)
+{
+       bcm43xx_phy_write(dev, 0x0055,
+               (bcm43xx_phy_read(dev, 0x0055) & 0xFFC0) | 0x0004);
+}
+
+static void bcm43xx_wa_mixedsignal(struct bcm43xx_wldev *dev) 
+{
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1, 3);
+}
+
+static void bcm43xx_wa_msst(struct bcm43xx_wldev *dev) /* Min sigma square table */
+{
+       struct bcm43xx_phy *phy = &dev->phy; 
+       int i;
+       const u16 *tab;
+
+       if (phy->type == BCM43xx_PHYTYPE_A) {
+               tab = bcm43xx_tab_sigmasqr1;
+       } else if (phy->type == BCM43xx_PHYTYPE_G) {
+               tab = bcm43xx_tab_sigmasqr2; 
+       } else {
+               assert(0);
+               return;
+       }
+
+       for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++) {
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_MINSIGSQ, 
+                                       i, tab[i]);
+       }
+}
+
+static void bcm43xx_wa_iqadc(struct bcm43xx_wldev *dev)
+{
+       if (dev->phy.analog == 4)
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 0, 
+                       bcm43xx_ofdmtab_read16(dev, BCM43xx_OFDMTAB_DAC, 0) & ~0xF000);
+}
+
+static void bcm43xx_wa_crs_ed(struct bcm43xx_wldev *dev)
+{
+       struct bcm43xx_phy *phy = &dev->phy; 
+
+       if (phy->rev == 1) {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1, 0x4F19);
+       } else if (phy->rev == 2) {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1_R1, 0x1861); 
+               bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES2_R1, 0x1861);
+               bcm43xx_phy_write(dev, BCM43xx_PHY_ANTDWELL,
+                                 bcm43xx_phy_read(dev, BCM43xx_PHY_ANTDWELL) 
+                                 | 0x0800);
+       } else {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1_R1, 0x0098);
+               bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES2_R1, 0x0070); 
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xC9), 0x0080);
+               bcm43xx_phy_write(dev, BCM43xx_PHY_ANTDWELL,
+                                 bcm43xx_phy_read(dev, BCM43xx_PHY_ANTDWELL) 
 +                                 | 0x0800);
+       }
+}
+
+static void bcm43xx_wa_crs_thr(struct bcm43xx_wldev *dev)
+{
+       bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+                       (bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) & ~0x03C0) | 0xD000); 
+}
+
+static void bcm43xx_wa_crs_blank(struct bcm43xx_wldev *dev)
+{
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x2C), 0x005A);
+}
+
+static void bcm43xx_wa_cck_shiftbits(struct bcm43xx_wldev *dev) 
+{
+       bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS, 0x0026);
+}
+
+static void bcm43xx_wa_wrssi_offset(struct bcm43xx_wldev *dev)
+{
+       int i;
+
+       if (dev->phy.rev == 1) { 
+               for (i = 0; i < 16; i++) {
+                       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_WRSSI_R1,
+                                               i, 0x0020);
+               }
+       } else { 
+               for (i = 0; i < 32; i++) {
+                       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_WRSSI,
+                                               i, 0x0820);
+               }
+       } 
+}
+
+static void bcm43xx_wa_txpuoff_rxpuon(struct bcm43xx_wldev *dev)
+{
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_0F, 2, 15);
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_0F, 3, 20); 
+}
+
+static void bcm43xx_wa_altagc(struct bcm43xx_wldev *dev)
+{
+       struct bcm43xx_phy *phy = &dev->phy;
+
+       if (phy->rev == 1) {
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 0, 254); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 1, 13);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 2, 19);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 3, 25); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 0, 0x2710);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 1, 0x9B83);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 2, 0x9B83); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC2, 3, 0x0F8D);
+               bcm43xx_phy_write(dev, BCM43xx_PHY_LMS, 4);
+       } else {
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0, 254); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 1, 13);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 2, 19);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 3, 25); 
+       }
+
+       bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS_WA,
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_CCKSHIFTBITS_WA) & ~0xFF00) | 0x5700);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1A), 
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1A)) & ~0x007F) | 0x000F);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1A),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1A)) & ~0x3F80) | 0x2B80); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT,
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_ANTWRSETT) & 0xF0FF) | 0x0300);
+       bcm43xx_radio_write16(dev, 0x7A,
+               bcm43xx_radio_read16(dev, 0x7A) | 0x0008); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_N1P1GAIN,
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_N1P1GAIN) & ~0x000F) | 0x0008);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_P1P2GAIN,
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_P1P2GAIN) & ~0x0F00) | 0x0600); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_N1N2GAIN,
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_N1N2GAIN) & ~0x0F00) | 0x0700);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_N1P1GAIN,
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_N1P1GAIN) & ~0x0F00) | 0x0100); 
+       if (phy->rev == 1) {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_N1N2GAIN,
+                                 (bcm43xx_phy_read(dev, BCM43xx_PHY_N1N2GAIN)
+                                  & ~0x000F) | 0x0007); 
+       }
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0x00FF) | 0x001C);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88), 
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88)) & ~0x3F00) | 0x0200);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x96)) & ~0x00FF) | 0x001C); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89)) & ~0x00FF) | 0x0020);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89)) & ~0x3F00) | 0x0200); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82)) & ~0x00FF) | 0x002E);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x96)) & ~0xFF00) | 0x1A00); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81)) & ~0x00FF) | 0x0028);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81)) & ~0xFF00) | 0x2C00); 
+       if (phy->rev == 1) {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_PEAK_COUNT, 0x092B);
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+                       (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x001E) | 0x0002); 
+       } else {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+                       bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x001E);
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1F), 0x287A); 
+               bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+                       (bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & ~0x000F) | 0x0004);
+               if (phy->rev >= 6) {
+                       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x22), 0x287A); 
+                       bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
+                               (bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL) & ~0xF000) | 0x3000);
+               }
+       }
 +       bcm43xx_phy_write(dev, BCM43xx_PHY_DIVSRCHIDX, 
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_DIVSRCHIDX) & 0x7F7F) | 0x7874);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E), 0x1C00);
+       if (phy->rev == 1) {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_DIVP1P2GAIN, 
+                       (bcm43xx_phy_read(dev, BCM43xx_PHY_DIVP1P2GAIN) & ~0x0F00) | 0x0600);
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8B), 0x005E);
+               bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT, 
+                       (bcm43xx_phy_read(dev, BCM43xx_PHY_ANTWRSETT) & ~0x00FF) | 0x001E);
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8D), 0x0002);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 0, 0); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 1, 7);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 2, 16);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3_R1, 3, 28); 
+       } else {
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 0, 0);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 1, 7);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 2, 16); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC3, 3, 28);
+       }
+       if (phy->rev >= 6) {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
+                       bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x26)) & ~0x0003); 
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
+                       bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x26)) & ~0x1000);
+       }
+}
+
+static void bcm43xx_wa_tr_ltov(struct bcm43xx_wldev *dev) /* TR Lookup Table Original Values */ 
+{
+       bcm43xx_gtab_write(dev, BCM43xx_GTAB_ORIGTR, 0, 0xC480);
+}
+
+static void bcm43xx_wa_cpll_nonpilot(struct bcm43xx_wldev *dev)
+{
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_11, 0, 0); 
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_11, 1, 0);
+}
+
+static void bcm43xx_wa_rssi_adc(struct bcm43xx_wldev *dev)
+{
+       if (dev->phy.analog == 4)
+               bcm43xx_phy_write(dev, 0x00DC, 0x7454); 
+}
+
+static void bcm43xx_wa_boards_a(struct bcm43xx_wldev *dev)
+{
+       struct ssb_bus *bus = dev->dev->bus;
+
+       if (bus->board_vendor == SSB_BOARDVENDOR_BCM &&
+           bus->board_type == SSB_BOARD_BU4306 && 
+           bus->board_rev < 0x30) {
+               bcm43xx_phy_write(dev, 0x0010, 0xE000);
+               bcm43xx_phy_write(dev, 0x0013, 0x0140);
+               bcm43xx_phy_write(dev, 0x0014, 0x0280); 
+       } else {
+               if (bus->board_type == SSB_BOARD_MP4318 &&
+                   bus->board_rev < 0x20) {
+                       bcm43xx_phy_write(dev, 0x0013, 0x0210);
+                       bcm43xx_phy_write(dev, 0x0014, 0x0840); 
+               } else {
+                       bcm43xx_phy_write(dev, 0x0013, 0x0140);
+                       bcm43xx_phy_write(dev, 0x0014, 0x0280);
+               }
+               if (dev->phy.rev   <= 4)
+                       bcm43xx_phy_write(dev, 0x0010, 0xE000);
+               else
+                       bcm43xx_phy_write(dev, 0x0010, 0x2000);
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 1, 0x0039); 
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_UNKNOWN_APHY, 7, 0x0040);
+       }
+}
+
+static void bcm43xx_wa_boards_g(struct bcm43xx_wldev *dev)
+{
+       struct ssb_bus *bus = dev->dev->bus; 
+       struct bcm43xx_phy *phy = &dev->phy;
+
+       if (bus->board_vendor != SSB_BOARDVENDOR_BCM ||
+           bus->board_type != SSB_BOARD_BU4306 ||
+           bus->board_rev != 0x17) { 
+               if (phy->rev < 2) {
+                       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX_R1, 1, 0x0002);
+                       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX_R1, 2, 0x0001); 
+               } else {
+                       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 1, 0x0002);
+                       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 2, 0x0001);
+                       if ((bus-> sprom.r1.boardflags_lo & BCM43xx_BFL_EXTLNA) &&
+                           (phy->rev >= 7)) {
+                               bcm43xx_phy_write(dev, BCM43xx_PHY_EXTG(0x11),
+                                       bcm43xx_phy_read(dev, BCM43xx_PHY_EXTG(0x11)) & 0xF7FF); 
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0020, 0x0001);
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0021, 0x0001);
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0022, 0x0001); 
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0023, 0x0000);
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0000, 0x0000);
+                               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_GAINX, 0x0003, 0x0002); 
+                       }
+               }
+       }
+       if (bus->sprom.r1.boardflags_lo & BCM43xx_BFL_FEM) {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_GTABCTL, 0x3120);
+               bcm43xx_phy_write(dev, BCM43xx_PHY_GTABDATA, 0xC480); 
+       }
+}
+
+void bcm43xx_wa_all(struct bcm43xx_wldev *dev)
+{
+       struct bcm43xx_phy *phy = &dev->phy;
+
+       if (phy->type == BCM43xx_PHYTYPE_A) {
+               switch (phy->rev) { 
+               case 2:
+                       bcm43xx_wa_papd(dev);
+                       bcm43xx_wa_auxclipthr(dev);
+                       bcm43xx_wa_afcdac(dev);
+                       bcm43xx_wa_txdc_offset(dev); 
+                       bcm43xx_wa_initgains(dev);
+                       bcm43xx_wa_divider(dev);
+                       bcm43xx_wa_gt(dev);
+                       bcm43xx_wa_rssi_lt(dev);
+                       bcm43xx_wa_analog(dev); 
+                       bcm43xx_wa_dac(dev);
+                       bcm43xx_wa_fft(dev);
+                       bcm43xx_wa_nft(dev);
+                       bcm43xx_wa_rt(dev);
+                       bcm43xx_wa_nst(dev); 
+                       bcm43xx_wa_art(dev);
+                       bcm43xx_wa_txlna_gain(dev);
+                       bcm43xx_wa_crs_reset(dev);
+                       bcm43xx_wa_2060txlna_gain(dev);
 +                       bcm43xx_wa_lms(dev); 
+                       break;
+               case 3:
+                       bcm43xx_wa_papd(dev);
+                       bcm43xx_wa_mixedsignal(dev);
+                       bcm43xx_wa_rssi_lt(dev);
  +                       bcm43xx_wa_txdc_offset(dev);
+                       bcm43xx_wa_initgains(dev);
+                       bcm43xx_wa_dac(dev);
+                       bcm43xx_wa_nft(dev);
+                       bcm43xx_wa_nst(dev); 
+                       bcm43xx_wa_msst(dev);
+                       bcm43xx_wa_analog(dev);
+                       bcm43xx_wa_gt(dev);
+                       bcm43xx_wa_txpuoff_rxpuon(dev);
+                       bcm43xx_wa_txlna_gain(dev); 
+                       break;
+               case 5:
+                       bcm43xx_wa_iqadc(dev);
+               case 6:
+                       bcm43xx_wa_papd(dev);
+                       bcm43xx_wa_rssi_lt(dev); 
+                       bcm43xx_wa_txdc_offset(dev);
+                       bcm43xx_wa_initgains(dev);
+                       bcm43xx_wa_dac(dev);
+                       bcm43xx_wa_nft(dev);
+                       bcm43xx_wa_nst(dev); 
+                       bcm43xx_wa_msst(dev);
+                       bcm43xx_wa_analog(dev);
+                       bcm43xx_wa_gt(dev);
+                       bcm43xx_wa_txpuoff_rxpuon(dev);
+                       bcm43xx_wa_txlna_gain(dev); 
+                       break;
+               case 7:
+                       bcm43xx_wa_iqadc(dev);
+                       bcm43xx_wa_papd(dev);
+                       bcm43xx_wa_rssi_lt(dev);
+                       bcm43xx_wa_txdc_offset(dev); 
+                       bcm43xx_wa_initgains(dev);
+                       bcm43xx_wa_dac(dev);
+                       bcm43xx_wa_nft(dev);
+                       bcm43xx_wa_nst(dev);
+                       bcm43xx_wa_msst(dev); 
+                       bcm43xx_wa_analog(dev);
+                       bcm43xx_wa_gt(dev);
+                       bcm43xx_wa_txpuoff_rxpuon(dev);
+                       bcm43xx_wa_txlna_gain(dev);
+                       bcm43xx_wa_rssi_adc(dev); 
+               default:
+                       assert(0);
+               }
+               bcm43xx_wa_boards_a(dev);
+       } else if (phy->type == BCM43xx_PHYTYPE_G) {
+               switch (phy->rev) { 
+               case 1://XXX review rev1
+                       bcm43xx_wa_crs_ed(dev);
+                       bcm43xx_wa_crs_thr(dev);
+                       bcm43xx_wa_crs_blank(dev);
+                       bcm43xx_wa_cck_shiftbits(dev); 
+                       bcm43xx_wa_fft(dev);
+                       bcm43xx_wa_nft(dev);
+                       bcm43xx_wa_rt(dev);
+                       bcm43xx_wa_nst(dev);
+                       bcm43xx_wa_art(dev); 
+                       bcm43xx_wa_wrssi_offset(dev);
+                       bcm43xx_wa_altagc(dev);
+                       break;
+               case 2:
+               case 6:
+               case 7: 
+               case 8:
+                       bcm43xx_wa_tr_ltov(dev);
+                       bcm43xx_wa_crs_ed(dev);
+                       bcm43xx_wa_rssi_lt(dev);
+                       bcm43xx_wa_nft(dev); 
+                       bcm43xx_wa_nst(dev);
+                       bcm43xx_wa_msst(dev);
+                       bcm43xx_wa_wrssi_offset(dev);
+                       bcm43xx_wa_altagc(dev);
+                       bcm43xx_wa_analog(dev); 
+                       bcm43xx_wa_txpuoff_rxpuon(dev);
+                       break;
+               default:
+                       assert(0);
+               }
+               bcm43xx_wa_boards_g(dev); 
+       } else { /* No N PHY support so far */
+               assert(0);
+       }
+
+       bcm43xx_wa_cpll_nonpilot(dev);
+}
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h 
===================================================================
--- /dev/null   1970-01-01 00:00:00.000000000 +0000
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h      2007-05-12 16:29: 05.000000000 +0200
@@ -0,0 +1,7 @@
+#ifndef BCM43xx_WA_H_
+#define BCM43xx_WA_H_
+
+void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev);
+void bcm43xx_wa_all(struct bcm43xx_wldev *dev);
+
+#endif /* BCM43xx_WA_H_ */ 
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c     2007-05-12 16:27: 31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c  2007-05-12 16:29:05.000000000 +0200
@@ -230,7 +230,7 @@ const u16 bcm43xx_tab_noisea2[] = {
 };

 const u16 bcm43xx_tab_noisea3[] = { 
-       0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
+       0x5E5E, 0x5E5E, 0x5E5E, 0x3F48,
        0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
 };

@@ -244,6 +244,26 @@ const u16 bcm43xx_tab_noiseg2[] = {
        0x0000, 0x0000, 0x0000, 0x0000, 
 };

+const u16 bcm43xx_tab_noisescalea2[] = {
+       0x6767, 0x6767, 0x6767, 0x6767, /* 0 */
+       0x6767, 0x6767, 0x6767, 0x6767,
+       0x6767, 0x6767, 0x6767, 0x6767,
+       0x6767, 0x6700, 0x6767, 0x6767, 
+       0x6767, 0x6767, 0x6767, 0x6767, /* 16 */
+       0x6767, 0x6767, 0x6767, 0x6767,
+       0x6767, 0x6767, 0x0067,
+};
+
+const u16 bcm43xx_tab_noisescalea3[] = {
+       0x2323, 0x2323, 0x2323, 0x2323, /* 0 */ 
+       0x2323, 0x2323, 0x2323, 0x2323,
+       0x2323, 0x2323, 0x2323, 0x2323,
+       0x2323, 0x2300, 0x2323, 0x2323,
+       0x2323, 0x2323, 0x2323, 0x2323, /* 16 */
+       0x2323, 0x2323, 0x2323, 0x2323, 
+       0x2323, 0x2323, 0x0023,
+};
+
 const u16 bcm43xx_tab_noisescaleg1[] = {
        0x6C77, 0x5162, 0x3B40, 0x3335, /* 0 */
        0x2F2D, 0x2A2A, 0x2527, 0x1F21,
@@ -255,7 +275,7 @@ const u16 bcm43xx_tab_noisescaleg1[] = { 
 };

 const u16 bcm43xx_tab_noisescaleg2[] = {
-       0xD8DD, 0xCBD4, 0xBCC0, 0XB6B7, /* 0 */
+       0xD8DD, 0xCBD4, 0xBCC0, 0xB6B7, /* 0 */
        0xB2B0, 0xADAD, 0xA7A9, 0x9FA1,
        0x969B, 0x9195, 0x8F8F, 0x8A8A, 
        0x8A8A, 0x8A00, 0x8A8A, 0x8F8A,
@@ -308,6 +328,27 @@ const u16 bcm43xx_tab_sigmasqr2[] = {
        0x00DE,
 };

+const u16 bcm43xx_tab_rssiagc1[] = {
+       0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8, /* 0 */ 
+       0xFFF8, 0xFFF9, 0xFFFC, 0xFFFE,
+       0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+       0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
+};
+
+const u16 bcm43xx_tab_rssiagc2[] = {
+       0x0820, 0x0820, 0x0920, 0x0C38, /* 0 */ 
+       0x0820, 0x0820, 0x0820, 0x0820,
+       0x0820, 0x0820, 0x0920, 0x0A38,
+       0x0820, 0x0820, 0x0820, 0x0820,
+       0x0820, 0x0820, 0x0920, 0x0A38, /* 16 */
+       0x0820, 0x0820, 0x0820, 0x0820, 
+       0x0820, 0x0820, 0x0920, 0x0A38,
+       0x0820, 0x0820, 0x0820, 0x0820,
+       0x0820, 0x0820, 0x0920, 0x0A38, /* 32 */
+       0x0820, 0x0820, 0x0820, 0x0820,
+       0x0820, 0x0820, 0x0920, 0x0A38, 
+       0x0820, 0x0820, 0x0820, 0x0820,
+};

 static inline void assert_sizes(void)
 {
@@ -319,34 +360,59 @@ static inline void assert_sizes(void)
        BUILD_BUG_ON(BCM43xx_TAB_NOISEA3_SIZE != ARRAY_SIZE(bcm43xx_tab_noisea3)); 
        BUILD_BUG_ON(BCM43xx_TAB_NOISEG1_SIZE != ARRAY_SIZE(bcm43xx_tab_noiseg1));
        BUILD_BUG_ON(BCM43xx_TAB_NOISEG2_SIZE != ARRAY_SIZE(bcm43xx_tab_noiseg2));
-       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg1)); 
-       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
-       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
+       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg1)); 
+       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
+       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE != ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
        BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE != ARRAY_SIZE(bcm43xx_tab_sigmasqr1)); 
        BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE != ARRAY_SIZE(bcm43xx_tab_sigmasqr2));
+       BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC1_SIZE != ARRAY_SIZE(bcm43xx_tab_rssiagc1));
+       BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC2_SIZE != ARRAY_SIZE(bcm43xx_tab_rssiagc2)); 
 }


 u16 bcm43xx_ofdmtab_read16(struct bcm43xx_wldev *dev, u16 table, u16 offset)
 {
-       assert_sizes();
+       struct bcm43xx_phy *phy = &dev->phy;
+       u16 addr;
+
+       addr = table + offset; 
+       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr);
+               phy->ofdm_valid = 1;
+       }
+       phy->ofdm_addr = addr; 

-       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
        return bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI);
+       assert_sizes();
 }

 void bcm43xx_ofdmtab_write16(struct bcm43xx_wldev *dev, u16 table, 
                             u16 offset, u16 value)
 {
-       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+       struct bcm43xx_phy *phy = &dev->phy;
+       u16 addr;
+
 +       addr = table + offset; 
+       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr);
+               phy->ofdm_valid = 2;
+       }
+       phy->ofdm_addr = addr; 
        bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
 }

 u32 bcm43xx_ofdmtab_read32(struct bcm43xx_wldev *dev, u16 table, u16 offset)
 {
+       struct bcm43xx_phy *phy = &dev->phy;
        u32 ret; 
+       u16 addr;

-       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset);
+       addr = table + offset;
+       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr); 
+               phy->ofdm_valid = 1;
+       }
+       phy->ofdm_addr = addr;
        ret = bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEQ);
        ret <<= 16;
        ret |= bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI); 
@@ -357,9 +423,17 @@ u32 bcm43xx_ofdmtab_read32(struct bcm43x
 void bcm43xx_ofdmtab_write32(struct bcm43xx_wldev *dev, u16 table,
                             u16 offset, u32 value)
 {
-       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table + offset); 
-       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
+       struct bcm43xx_phy *phy = &dev->phy;
+       u16 addr;
+
+       addr = table + offset;
+       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) { 
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, addr);
+               phy->ofdm_valid = 2;
+       }
+       phy->ofdm_addr = addr;
        bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEQ, (value >> 16)); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
 }

 u16 bcm43xx_gtab_read(struct bcm43xx_wldev *dev, u16 table, u16 offset)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h 
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h    2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h 2007-05-12 16:29: 05.000000000 +0200
@@ -591,6 +591,10 @@ struct bcm43xx_phy {
        u16 lofcal;

        u16 initval;//FIXME rename?
+
+       /* OFDM address read/write caching for hardware auto-increment. */
+       u16 ofdm_addr; 
+       u8 ofdm_valid; /* 0: invalid, 1: read, 2: write */
 };

 /* Data structures for DMA transmission, per 80211 core. */
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c 
 ===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c       2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c    2007-05-12 16:29: 05.000000000 +0200
@@ -3127,6 +3127,9 @@ static void setup_struct_phy_for_init(st
        spin_lock_init(&phy->lock);
        phy->interfmode = BCM43xx_INTERFMODE_NONE;
        phy->channel = 0xFF; 
+
+       /* OFDM address caching. */
+       phy->ofdm_valid = 0;
 }

 static void setup_struct_wldev_for_init(struct bcm43xx_wldev *dev)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h 
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h        2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h     2007-05-12 16:29: 05.000000000 +0200
@@ -28,8 +28,11 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_PWRDOWN            BCM43xx_PHY_OFDM(0x03)  /* Powerdown */
 #define BCM43xx_PHY_CRSTHRES1          BCM43xx_PHY_OFDM(0x06)  /* CRS Threshold 1 */ 
 #define BCM43xx_PHY_LNAHPFCTL          BCM43xx_PHY_OFDM(0x1C)  /* LNA/HPF control */
+#define BCM43xx_PHY_LPFGAINCTL         BCM43xx_PHY_OFDM(0x20)  /* LPF Gain control */
 #define BCM43xx_PHY_ADIVRELATED                BCM43xx_PHY_OFDM(0x27)  /* FIXME rename */ 
 #define BCM43xx_PHY_CRS0               BCM43xx_PHY_OFDM(0x29)
+#define  BCM43xx_PHY_CRS0_EN           0x4000
+#define BCM43xx_PHY_PEAK_COUNT         BCM43xx_PHY_OFDM(0x30)
 #define BCM43xx_PHY_ANTDWELL           BCM43xx_PHY_OFDM(0x2B)  /* Antenna dwell */ 
 #define  BCM43xx_PHY_ANTDWELL_AUTODIV1 0x0100                  /* Automatic RX diversity start antenna */
 #define BCM43xx_PHY_ENCORE             BCM43xx_PHY_OFDM(0x49)  /* "Encore" (RangeMax / BroadRange) */ 
@@ -38,6 +41,7 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_OFDM61             BCM43xx_PHY_OFDM(0x61)  /* FIXME rename */
 #define  BCM43xx_PHY_OFDM61_10         0x0010                  /* FIXME rename */
 #define BCM43xx_PHY_IQBAL              BCM43xx_PHY_OFDM(0x69)  /* I/Q balance */ 
+#define BCM43xx_PHY_BBTXDC_BIAS                BCM43xx_PHY_OFDM(0x6B)  /* Baseband TX DC bias */
 #define BCM43xx_PHY_OTABLECTL          BCM43xx_PHY_OFDM(0x72)  /* OFDM table control (see below) */
 #define  BCM43xx_PHY_OTABLEOFF         0x03FF                  /* OFDM table offset (see below) */ 
 #define  BCM43xx_PHY_OTABLENR          0xFC00                  /* OFDM table number (see below) */
@@ -45,6 +49,9 @@ struct bcm43xx_wldev;
 #define BCM43xx_PHY_OTABLEI            BCM43xx_PHY_OFDM(0x73)  /* OFDM table data I */ 
 #define BCM43xx_PHY_OTABLEQ            BCM43xx_PHY_OFDM(0x74)  /* OFDM table data Q */
 #define BCM43xx_PHY_HPWR_TSSICTL       BCM43xx_PHY_OFDM(0x78)  /* Hardware power TSSI control */
+#define BCM43xx_PHY_ADCCTL             BCM43xx_PHY_OFDM(0x7A)  /* ADC control */ 
+#define BCM43xx_PHY_IDLE_TSSI          BCM43xx_PHY_OFDM(0x7B)
+#define BCM43xx_PHY_A_TEMP_SENSE       BCM43xx_PHY_OFDM(0x7C)  /* A PHY temperature sense */
 #define BCM43xx_PHY_NRSSITHRES         BCM43xx_PHY_OFDM(0x8A)  /* NRSSI threshold */ 
 #define BCM43xx_PHY_ANTWRSETT          BCM43xx_PHY_OFDM(0x8C)  /* Antenna WR settle */
 #define  BCM43xx_PHY_ANTWRSETT_ARXDIV  0x2000                  /* Automatic RX diversity enabled */
@@ -55,6 +62,8 @@ struct bcm43xx_wldev; 
 #define BCM43xx_PHY_N1N2GAIN           BCM43xx_PHY_OFDM(0xA2)
 #define BCM43xx_PHY_CLIPTHRES          BCM43xx_PHY_OFDM(0xA3)
 #define BCM43xx_PHY_CLIPN1P2THRES      BCM43xx_PHY_OFDM(0xA4)
+#define BCM43xx_PHY_CCKSHIFTBITS_WA    BCM43xx_PHY_OFDM(0xA5)  /* CCK shiftbits workaround, FIXME rename */ 
+#define BCM43xx_PHY_CCKSHIFTBITS       BCM43xx_PHY_OFDM(0xA7)  /* FIXME rename */
 #define BCM43xx_PHY_DIVSRCHIDX         BCM43xx_PHY_OFDM(0xA8)  /* Divider search gain/index */
 #define BCM43xx_PHY_CLIPP2THRES                BCM43xx_PHY_OFDM(0xA9) 
 #define BCM43xx_PHY_CLIPP3THRES                BCM43xx_PHY_OFDM(0xAA)
@@ -128,13 +137,14 @@ struct bcm43xx_wldev;
 #define BCM43xx_OFDMTAB_DC             BCM43xx_OFDMTAB(0x0E, 7)
 #define BCM43xx_OFDMTAB_PWRDYN2                BCM43xx_OFDMTAB(0x0E, 12) 
 #define BCM43xx_OFDMTAB_LNAGAIN                BCM43xx_OFDMTAB(0x0E, 13)
-//TODO
+#define BCM43xx_OFDMTAB_UNKNOWN_0F     BCM43xx_OFDMTAB(0x0F, 0)        //TODO rename
+#define BCM43xx_OFDMTAB_UNKNOWN_APHY   BCM43xx_OFDMTAB(0x0F, 7)        //TODO rename 
 #define BCM43xx_OFDMTAB_LPFGAIN                BCM43xx_OFDMTAB(0x0F, 12)
 #define BCM43xx_OFDMTAB_RSSI           BCM43xx_OFDMTAB(0x10, 0)
-//TODO
+#define BCM43xx_OFDMTAB_UNKNOWN_11     BCM43xx_OFDMTAB(0x11, 4)        //TODO rename 
 #define BCM43xx_OFDMTAB_AGC1_R1                BCM43xx_OFDMTAB(0x13, 0)
-#define BCM43xx_OFDMTAB_GAINX_R1       BCM43xx_OFDMTAB(0x14, 0)        //TODO rename
-#define BCM43xx_OFDMTAB_MINSIGSQ       BCM43xx_OFDMTAB(0x14, 1) 
+#define BCM43xx_OFDMTAB_GAINX_R1       BCM43xx_OFDMTAB(0x14, 0)        //TODO remove!
+#define BCM43xx_OFDMTAB_MINSIGSQ       BCM43xx_OFDMTAB(0x14, 0)
 #define BCM43xx_OFDMTAB_AGC3_R1                BCM43xx_OFDMTAB(0x15, 0) 
 #define BCM43xx_OFDMTAB_WRSSI_R1       BCM43xx_OFDMTAB(0x15, 4)
 #define BCM43xx_OFDMTAB_TSSI           BCM43xx_OFDMTAB(0x15, 0)
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h 
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h     2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h  2007-05-12 16:29: 05.000000000 +0200
@@ -17,12 +17,18 @@ extern const u16 bcm43xx_tab_noisea3[];
 extern const u16 bcm43xx_tab_noiseg1[];
 #define BCM43xx_TAB_NOISEG2_SIZE       8
 extern const u16 bcm43xx_tab_noiseg2[];
-#define BCM43xx_TAB_NOISESCALEG_SIZE   27 
+#define BCM43xx_TAB_NOISESCALE_SIZE    27
+extern const u16 bcm43xx_tab_noisescalea2[];
+extern const u16 bcm43xx_tab_noisescalea3[];
 extern const u16 bcm43xx_tab_noisescaleg1[];
 extern const u16 bcm43xx_tab_noisescaleg2[]; 
 extern const u16 bcm43xx_tab_noisescaleg3[];
 #define BCM43xx_TAB_SIGMASQR_SIZE      53
 extern const u16 bcm43xx_tab_sigmasqr1[];
 extern const u16 bcm43xx_tab_sigmasqr2[];
+#define BCM43xx_TAB_RSSIAGC1_SIZE      16 
+extern const u16 bcm43xx_tab_rssiagc1[];
+#define BCM43xx_TAB_RSSIAGC2_SIZE      48
+extern const u16 bcm43xx_tab_rssiagc2[];

 #endif /* BCM43xx_TABLES_H_ */
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c 
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c        2007-05-12 16:27:31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c     2007-05-12 16:29: 05.000000000 +0200
@@ -34,6 +34,7 @@
 #include "bcm43xx_tables.h"
 #include "bcm43xx_power.h"
 #include "bcm43xx_lo.h"
+#include "bcm43xx_wa.h"


 static const s8 bcm43xx_tssi2dbm_b_table[] = { 
@@ -559,393 +560,96 @@ static void bcm43xx_phy_init_pctl(struct
        bcm43xx_shm_clear_tssi(dev);
 }

-static void bcm43xx_phy_agcsetup(struct bcm43xx_wldev *dev)
+static void bcm43xx_phy_rssiagc(struct bcm43xx_wldev *dev, u8 enable) 
 {
-       struct bcm43xx_phy *phy = &dev->phy;
-       u16 offset = 0x0000;
-
-       if (phy->rev == 1)
-               offset = 0x4C00;
-
-       bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00FE); 
-       bcm43xx_ofdmtab_write16(dev, offset, 1, 0x000D);
-       bcm43xx_ofdmtab_write16(dev, offset, 2, 0x0013);
-       bcm43xx_ofdmtab_write16(dev, offset, 3, 0x0019);
-
-       if (phy->rev == 1) { 
 -               bcm43xx_ofdmtab_write16(dev, 0x1800, 0, 0x2710);
-               bcm43xx_ofdmtab_write16(dev, 0x1801, 0, 0x9B83);
-               bcm43xx_ofdmtab_write16(dev, 0x1802, 0, 0x9B83);
-               bcm43xx_ofdmtab_write16(dev, 0x1803, 0, 0x0F8D); 
-               bcm43xx_phy_write(dev, 0x0455, 0x0004);
-       }
-
-       bcm43xx_phy_write(dev, 0x04A5,
-                         (bcm43xx_phy_read(dev, 0x04A5)
-                          & 0x00FF) | 0x5700); 
-       bcm43xx_phy_write(dev, 0x041A,
-                         (bcm43xx_phy_read(dev, 0x041A)
-                          & 0xFF80) | 0x000F);
-       bcm43xx_phy_write(dev, 0x041A,
-                         (bcm43xx_phy_read(dev, 0x041A) 
-                          & 0xC07F) | 0x2B80);
-       bcm43xx_phy_write(dev, 0x048C,
-                         (bcm43xx_phy_read(dev, 0x048C)
-                          & 0xF0FF) | 0x0300);
-
  -       bcm43xx_radio_write16(dev, 0x007A,
-                             bcm43xx_radio_read16(dev, 0x007A)
-                             | 0x0008);
-
-       bcm43xx_phy_write(dev, 0x04A0,
-                         (bcm43xx_phy_read(dev, 0x04A0) 
-                          & 0xFFF0) | 0x0008);
-       bcm43xx_phy_write(dev, 0x04A1,
-                         (bcm43xx_phy_read(dev, 0x04A1)
-                          & 0xF0FF) | 0x0600);
-       bcm43xx_phy_write(dev, 0x04A2, 
-                         (bcm43xx_phy_read(dev, 0x04A2)
-                          & 0xF0FF) | 0x0700);
-       bcm43xx_phy_write(dev, 0x04A0,
-                         (bcm43xx_phy_read(dev, 0x04A0)
  -                          & 0xF0FF) | 0x0100);
-
-       if (phy->rev == 1) {
-               bcm43xx_phy_write(dev, 0x04A2,
-                                 (bcm43xx_phy_read(dev, 0x04A2)
-                                  & 0xFFF0) | 0x0007); 
-       }
-
-       bcm43xx_phy_write(dev, 0x0488,
-                         (bcm43xx_phy_read(dev, 0x0488)
-                          & 0xFF00) | 0x001C);
-       bcm43xx_phy_write(dev, 0x0488,
  -                         (bcm43xx_phy_read(dev, 0x0488)
-                          & 0xC0FF) | 0x0200);
-       bcm43xx_phy_write(dev, 0x0496,
-                         (bcm43xx_phy_read(dev, 0x0496)
-                          & 0xFF00) | 0x001C); 
-       bcm43xx_phy_write(dev, 0x0489,
-                         (bcm43xx_phy_read(dev, 0x0489)
-                          & 0xFF00) | 0x0020);
-       bcm43xx_phy_write(dev, 0x0489,
-                         (bcm43xx_phy_read(dev, 0x0489) 
-                          & 0xC0FF) | 0x0200);
-       bcm43xx_phy_write(dev, 0x0482,
-                         (bcm43xx_phy_read(dev, 0x0482)
-                          & 0xFF00) | 0x002E);
-       bcm43xx_phy_write(dev, 0x0496, 
-                         (bcm43xx_phy_read(dev, 0x0496)
-                          & 0x00FF) | 0x1A00);
-       bcm43xx_phy_write(dev, 0x0481,
-                         (bcm43xx_phy_read(dev, 0x0481)
  -                          & 0xFF00) | 0x0028);
-       bcm43xx_phy_write(dev, 0x0481,
-                         (bcm43xx_phy_read(dev, 0x0481)
-                          & 0x00FF) | 0x2C00);
-
-       if (phy->rev == 1) { 
-               bcm43xx_phy_write(dev, 0x0430, 0x092B);
-               bcm43xx_phy_write(dev, 0x041B,
-                                 (bcm43xx_phy_read(dev, 0x041B)
-                                  & 0xFFE1) | 0x0002); 
-       } else {
-               bcm43xx_phy_write(dev, 0x041B,
-                                 bcm43xx_phy_read(dev, 0x041B)
-                                 & 0xFFE1);
-               bcm43xx_phy_write(dev, 0x041F, 0x287A); 
-               bcm43xx_phy_write(dev, 0x0420,
-                                 (bcm43xx_phy_read(dev, 0x0420)
-                                  & 0xFFF0) | 0x0004);
-       }
-
-       if (phy->rev >= 6) { 
-               bcm43xx_phy_write(dev, 0x0422, 0x287A);
-               bcm43xx_phy_write(dev, 0x0420,
-                                 (bcm43xx_phy_read(dev, 0x0420)
-                                  & 0x0FFF) | 0x3000); 
-       }
-
-       bcm43xx_phy_write(dev, 0x04A8,
-                         (bcm43xx_phy_read(dev, 0x04A8)
-                          & 0x8080) | 0x7874);
-       bcm43xx_phy_write(dev, 0x048E, 0x1C00); 
-
-       offset = 0x0800;
-       if (phy->rev == 1) {
-               offset = 0x5400;
-               bcm43xx_phy_write(dev, 0x04AB,
-                                 (bcm43xx_phy_read(dev, 0x04AB) 
-                                  & 0xF0FF) | 0x0600);
-               bcm43xx_phy_write(dev, 0x048B, 0x005E);
-               bcm43xx_phy_write(dev, 0x048C,
-                                 (bcm43xx_phy_read(dev, 0x048C) 
-                                  & 0xFF00) | 0x001E);
-               bcm43xx_phy_write(dev, 0x048D, 0x0002);
-       }
-       bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00);
-       bcm43xx_ofdmtab_write16(dev, offset, 1, 0x07); 
-       bcm43xx_ofdmtab_write16(dev, offset, 2, 0x10);
-       bcm43xx_ofdmtab_write16(dev, offset, 3, 0x1C);
-
-       if (phy->rev >= 6) {
-               bcm43xx_phy_write(dev, 0x0426,
-                                 bcm43xx_phy_read(dev, 0x0426) 
-                                 & 0xFFFC);
-               bcm43xx_phy_write(dev, 0x0426,
-                                 bcm43xx_phy_read(dev, 0x0426)
-                                 & 0xEFFF); 
-       }
-}
-
-static void bcm43xx_phy_setupg(struct bcm43xx_wldev *dev)
-{
-       struct ssb_bus *bus = dev->dev->bus;
-       struct bcm43xx_phy *phy = &dev->phy;
-       u16 i;
  -
-       assert(phy->type == BCM43xx_PHYTYPE_G);
-       if (phy->rev == 1) {
-               bcm43xx_phy_write(dev, 0x0406, 0x4F19);
-               bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
-                                 (bcm43xx_phy_read(dev, BCM43xx_PHY_G_CRS) & 0xFC3F) | 0x0340); 
-               bcm43xx_phy_write(dev, 0x042C, 0x005A);
-               bcm43xx_phy_write(dev, 0x0427, 0x001A);
-
-               for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
-                       bcm43xx_ofdmtab_write16(dev, 0x5800, i, bcm43xx_tab_finefreqg[i]); 
-               for (i = 0; i < BCM43xx_TAB_NOISEG1_SIZE; i++)
-                       bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noiseg1[i]);
-               for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++) 
-                       bcm43xx_ofdmtab_write16(dev, 0x2000, i, bcm43xx_tab_rotor[i]);
-       } else {
-               /* nrssi values are signed 6-bit values. Not sure why we write 0x7654 here... */
-               bcm43xx_nrssi_hw_write(dev, 0xBA98, (s16)0x7654); 
-
-               if (phy->rev == 2) {
-                       bcm43xx_phy_write(dev, 0x04C0, 0x1861);
-                       bcm43xx_phy_write(dev, 0x04C1, 0x0271);
-               } else if (phy->rev > 2) { 
-                       bcm43xx_phy_write(dev, 0x04C0, 0x0098);
-                       bcm43xx_phy_write(dev, 0x04C1, 0x0070);
-                       bcm43xx_phy_write(dev, 0x04C9, 0x0080);
-               } 
-               bcm43xx_phy_write(dev, 0x042B, bcm43xx_phy_read(dev, 0x042B) | 0x800);
-
-               for (i = 0; i < 64; i++)
-                       bcm43xx_ofdmtab_write16(dev, 0x4000, i, i);
-               for (i = 0; i < BCM43xx_TAB_NOISEG2_SIZE; i++) 
-                       bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noiseg2[i]);
-       }
-
-       if (phy->rev <= 2)
-               for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
  -                       bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg1[i]);
-       else if ((phy->rev >= 7) && (bcm43xx_phy_read(dev, 0x0449) & 0x0200))
-               for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++) 
-                       bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg3[i]);
-       else
-               for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
-                       bcm43xx_ofdmtab_write16(dev, 0x1400, i, bcm43xx_tab_noisescaleg2[i]); 
-
-       if (phy->rev == 2)
-               for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
-                       bcm43xx_ofdmtab_write16(dev, 0x5000, i, bcm43xx_tab_sigmasqr1[i]);
-       else if ((phy->rev > 2) && (phy->rev <= 8)) 
-               for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
-                       bcm43xx_ofdmtab_write16(dev, 0x5000, i, bcm43xx_tab_sigmasqr2[i]);
-
-       if (phy->rev == 1) {
-               for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++) 
-                       bcm43xx_ofdmtab_write32(dev, 0x2400, i, bcm43xx_tab_retard[i]);
-               for (i = 0; i < 4; i++) {
-                       bcm43xx_ofdmtab_write16(dev, 0x5404, i, 0x0020);
-                       bcm43xx_ofdmtab_write16(dev, 0x5408, i, 0x0020); 
-                       bcm43xx_ofdmtab_write16(dev, 0x540C, i, 0x0020);
-                       bcm43xx_ofdmtab_write16(dev, 0x5410, i, 0x0020);
-               }
-               bcm43xx_phy_agcsetup(dev);
  -
-               if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-                   (bus->board_type == SSB_BOARD_BU4306) &&
-                   (bus->board_rev == 0x17))
-                       return; 
-
-               bcm43xx_ofdmtab_write16(dev, 0x5001, 0, 0x0002);
-               bcm43xx_ofdmtab_write16(dev, 0x5002, 0, 0x0001);
-       } else {
-               for (i = 0; i <= 0x2F; i++)
-                       bcm43xx_ofdmtab_write16(dev, 0x1000, i, 0x0820); 
-               bcm43xx_phy_agcsetup(dev);
-               bcm43xx_phy_read(dev, 0x0400); /* dummy read */
-               bcm43xx_phy_write(dev, 0x0403, 0x1000);
-               bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F); 
-               bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
-
-               if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-                   (bus->board_type == SSB_BOARD_BU4306) && 
-                   (bus->board_rev == 0x17))
-                       return;
-
-               bcm43xx_ofdmtab_write16(dev, 0x0401, 0, 0x0002);
-               bcm43xx_ofdmtab_write16(dev, 0x0402, 0, 0x0001); 
-       }
-}
-
-/* Initialize the noisescaletable for APHY */
-static void bcm43xx_phy_init_noisescaletbl(struct bcm43xx_wldev *dev)
-{
-       struct bcm43xx_phy *phy = &dev->phy;
        int i; 

-       for (i = 0; i < 12; i++) {
-               if (phy->rev == 2)
-                       bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6767);
+       if (dev->phy.rev < 3) {
+               if (enable) 
+                       for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
+                               bcm43xx_ofdmtab_write16(dev,
+                                       BCM43xx_OFDMTAB_LNAHPFGAIN1, i, 0xFFF8); 
+                               bcm43xx_ofdmtab_write16(dev,
+                                       BCM43xx_OFDMTAB_WRSSI, i, 0xFFF8);
+                       }
                else
-                       bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2323); 
-       }
-       if (phy->rev == 2)
-               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6700);
-       else
-               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2300);
-       for (i = 0; i < 11; i++) { 
-               if (phy->rev == 2)
-                       bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6767);
+                       for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
+                               bcm43xx_ofdmtab_write16(dev, 
+                                       BCM43xx_OFDMTAB_LNAHPFGAIN1, i, bcm43xx_tab_rssiagc1[i]);
+                               bcm43xx_ofdmtab_write16(dev,
+                                       BCM43xx_OFDMTAB_WRSSI, i, bcm43xx_tab_rssiagc1[i]); 
+                       }
+       } else {
+               if (enable)
+                       for (i = 0; i < BCM43xx_TAB_RSSIAGC1_SIZE; i++)
+                               bcm43xx_ofdmtab_write16(dev, 
+                                       BCM43xx_OFDMTAB_WRSSI, i, 0x0820);
                else
-                       bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2323);
+                       for (i = 0; i < BCM43xx_TAB_RSSIAGC2_SIZE; i++) 
+                               bcm43xx_ofdmtab_write16(dev,
+                                       BCM43xx_OFDMTAB_WRSSI, i, bcm43xx_tab_rssiagc2[i]);
        }
-       if (phy->rev == 2)
-               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0067); 
-       else
-               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0023);
 }

-static void bcm43xx_phy_setupa(struct bcm43xx_wldev *dev)
+static void bcm43xx_phy_ww(struct bcm43xx_wldev *dev)
 { 
 -       struct bcm43xx_phy *phy = &dev->phy;
-       u16 i;
-
-       assert(phy->type == BCM43xx_PHYTYPE_A);
-       switch (phy->rev) {
-       case 2:
-               bcm43xx_phy_write(dev, 0x008E, 0x3800); 
-               bcm43xx_phy_write(dev, 0x0035, 0x03FF);
-               bcm43xx_phy_write(dev, 0x0036, 0x0400);
-
-               bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-               bcm43xx_phy_write(dev, 0x001C, 0x0FF9); 
-               bcm43xx_phy_write(dev, 0x0020, bcm43xx_phy_read(dev, 0x0020) & 0xFF0F);
-               bcm43xx_ofdmtab_write16(dev, 0x3C0C, 0, 0x07BF);
-               bcm43xx_radio_write16(dev, 0x0002, 0x07BF); 
-
-               bcm43xx_phy_write(dev, 0x0024, 0x4680);
-               bcm43xx_phy_write(dev, 0x0020, 0x0003);
-               bcm43xx_phy_write(dev, 0x001D, 0x0F40);
-               bcm43xx_phy_write(dev, 0x001F, 0x1C00); 
-
-               bcm43xx_phy_write(dev, 0x002A,
-                                 (bcm43xx_phy_read(dev, 0x002A)
-                                  & 0x00FF) | 0x0400);
-               bcm43xx_phy_write(dev, 0x002B, 
-                                 bcm43xx_phy_read(dev, 0x002B)
-                                 & 0xFBFF);
-               bcm43xx_phy_write(dev, 0x008E, 0x58C1);
-
-               bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F); 
-               bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
-               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-               bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A); 
-
-               bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
-               bcm43xx_ofdmtab_write16(dev, 0x0000, 1, 0x0013);
-               bcm43xx_ofdmtab_write16(dev, 0x0000, 2, 0x0013);
-               bcm43xx_ofdmtab_write16(dev, 0x0000, 3, 0x0013); 
-               bcm43xx_ofdmtab_write16(dev, 0x0000, 4, 0x0015);
-               bcm43xx_ofdmtab_write16(dev, 0x0000, 5, 0x0015);
-               bcm43xx_ofdmtab_write16(dev, 0x0000, 6, 0x0019);
-
-               bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003); 
-               bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
-               bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
-
-               for (i = 0; i < 16; i++)
-                       bcm43xx_ofdmtab_write16(dev, 0x4000, i, (0x8 + i) & 0x000F); 
-
-               bcm43xx_ofdmtab_write16(dev, 0x3003, 0, 0x1044);
-               bcm43xx_ofdmtab_write16(dev, 0x3004, 0, 0x7201);
-               bcm43xx_ofdmtab_write16(dev, 0x3006, 0, 0x0040);
-               bcm43xx_ofdmtab_write16(dev, 0x3001, 0, (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0x0010) | 0x0008); 
-
-               for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
-                       bcm43xx_ofdmtab_write16(dev, 0x5800, i, bcm43xx_tab_finefreqa[i]);
-               for (i = 0; i < BCM43xx_TAB_NOISEA2_SIZE; i++) 
-                       bcm43xx_ofdmtab_write16(dev, 0x1800, i, bcm43xx_tab_noisea2[i]);
-               for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
-                       bcm43xx_ofdmtab_write32(dev, 0x2000, i, bcm43xx_tab_rotor[i]); 
-               bcm43xx_phy_init_noisescaletbl(dev);
-               for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
-                       bcm43xx_ofdmtab_write32(dev, 0x2400, i, bcm43xx_tab_retard[i]);
-               break; 
-       case 3:
-               for (i = 0; i < 64; i++)
-                       bcm43xx_ofdmtab_write16(dev, 0x4000, i, i);
-
-               bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
-
-               bcm43xx_phy_write(dev, 0x001C, 0x0FF9); 
-               bcm43xx_phy_write(dev, 0x0020,
-                                 bcm43xx_phy_read(dev, 0x0020) & 0xFF0F);
-               bcm43xx_radio_write16(dev, 0x0002, 0x07BF);
-
-               bcm43xx_phy_write(dev, 0x0024, 0x4680); 
-               bcm43xx_phy_write(dev, 0x0020, 0x0003);
-               bcm43xx_phy_write(dev, 0x001D, 0x0F40);
-               bcm43xx_phy_write(dev, 0x001F, 0x1C00);
-               bcm43xx_phy_write(dev, 0x002A, 
-                                 (bcm43xx_phy_read(dev, 0x002A)
-                                  & 0x00FF) | 0x0400);
-
-               bcm43xx_ofdmtab_write16(dev, 0x3000, 1,
-                                       (bcm43xx_ofdmtab_read16(dev, 0x3000, 1) 
-                                       & 0x0010) | 0x0008);
-               for (i = 0; i < BCM43xx_TAB_NOISEA3_SIZE; i++) {
-                       bcm43xx_ofdmtab_write16(dev, 0x1800, i,
-                                               bcm43xx_tab_noisea3[i]); 
-               }
-               bcm43xx_phy_init_noisescaletbl(dev);
-               for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++) {
-                       bcm43xx_ofdmtab_write16(dev, 0x5000, i,
 -                                               bcm43xx_tab_sigmasqr1[i]); 
-               }
-
-               bcm43xx_phy_write(dev, 0x0003, 0x1808);
-
-               bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
-               bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F); 
-               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
-               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
-               bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
-
-               bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013); 
-               bcm43xx_ofdmtab_write16(dev, 0x0001, 0, 0x0013);
-               bcm43xx_ofdmtab_write16(dev, 0x0002, 0, 0x0013);
-               bcm43xx_ofdmtab_write16(dev, 0x0003, 0, 0x0013);
-               bcm43xx_ofdmtab_write16(dev, 0x0004, 0, 0x0015); 
-               bcm43xx_ofdmtab_write16(dev, 0x0005, 0, 0x0015);
-               bcm43xx_ofdmtab_write16(dev, 0x0006, 0, 0x0019);
-
-               bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
-               bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003); 
-               bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
+       u16 b, curr_s, best_s = 0xFFFF;
+       int i;

-               bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
-               bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014); 
-               break;
-       default:
-               assert(0);
-       }
+       bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+               bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) & ~BCM43xx_PHY_CRS0_EN); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+               bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) | 0x1000);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82)) & 0xF0FF) | 0x0300); 
+       bcm43xx_radio_write16(dev, 0x0009,
+               bcm43xx_radio_read16(dev, 0x0009) | 0x0080);
+       bcm43xx_radio_write16(dev, 0x0012,
+               (bcm43xx_radio_read16(dev, 0x0012) & 0xFFFC) | 0x0002); 
+       bcm43xx_wa_initgains(dev);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBA), 0x3ED5);
+       b = bcm43xx_phy_read(dev, BCM43xx_PHY_PWRDOWN);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, (b & 0xFFF8) | 0x0005); 
+       bcm43xx_radio_write16(dev, 0x0004,
+               bcm43xx_radio_read16(dev, 0x0004) | 0x0004);
+       for (i = 0x10; i <= 0x20; i++) {
+               bcm43xx_radio_write16(dev, 0x0013, i);
+               curr_s = bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEQ) & 0x00FF; 
+               if (!curr_s) {
+                       best_s = 0x0000;
+                       break;
+               } else if (curr_s >= 0x0080)
+                       curr_s = 0x0100 - curr_s;
 +               if (curr_s < best_s) 
+                       best_s = curr_s;
+       }
+       bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, b);
+       bcm43xx_radio_write16(dev, 0x0004,
+               bcm43xx_radio_read16(dev, 0x0004) & 0xFFFB); 
+       bcm43xx_radio_write16(dev, 0x0013, best_s);
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1, 0, 0xFFEC);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB7), 0x1E80);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB6), 0x1C00); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB5), 0x0EC0);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB2), 0x00C0);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB9), 0x1FFF);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBB), 
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0xBB)) & 0xF000) | 0x0053);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM61,
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM61 & 0xFE1F)) | 0x0120); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x13),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x13)) & 0x0FFF) | 0x3000);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x14),
+               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x14)) & 0x0FFF) | 0x3000); 
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 6, 0x0017);
+       for (i = 0; i < 6; i++)
+               bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, i, 0x000F);
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0D, 0x000E); 
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0E, 0x0011);
+       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 0x0F, 0x0013);
+       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x33), 0x5030); 
+       bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+               bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) | BCM43xx_PHY_CRS0_EN);
 }

 /* Initialize APHY. This is also called for the GPHY in some cases. */ 
 @@ -953,60 +657,52 @@ static void bcm43xx_phy_inita(struct bcm
 {
        struct ssb_bus *bus = dev->dev->bus;
        struct bcm43xx_phy *phy = &dev->phy;
-       u16 tval;

-       if (phy->type == BCM43xx_PHYTYPE_A) { 
-               bcm43xx_phy_setupa(dev);
-       } else {
-               bcm43xx_phy_setupg(dev);
-               if (phy->gmode &&
-                   (dev->dev->bus->sprom.r1.boardflags_lo   & BCM43xx_BFL_PACTRL))
-                       bcm43xx_phy_write(dev, 0x046E, 0x03CF);
-               return;
+       if (phy->rev >= 6) {
+               if (phy->type == BCM43xx_PHYTYPE_A)
  +                       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
+                               bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B)) & ~0x1000);
+               if (bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & BCM43xx_PHY_ENCORE_EN) 
+                       bcm43xx_phy_write(dev, BCM43xx_PHY_ENCORE,
+                               bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) | 0x0010);
+               else
+                       bcm43xx_phy_write(dev, BCM43xx_PHY_ENCORE, 
+                               bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE) & ~0x1010);
        }
+       bcm43xx_wa_all(dev);

-       bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
-                         (bcm43xx_phy_read(dev, BCM43xx_PHY_A_CRS) & 0xF83C) | 0x0340); 
-       bcm43xx_phy_write(dev, 0x0034, 0x0001);
-
-       TODO();//TODO: RSSI AGC
-       bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
-                         bcm43xx_phy_read(dev, BCM43xx_PHY_A_CRS) | (1 << 14)); 
-       bcm43xx_radio_init2060(dev);
+       if (phy->type == BCM43xx_PHYTYPE_A) {
+               if (phy->gmode &&
+                   (phy->rev < 3))
+                       bcm43xx_phy_write(dev, 0x0034, 
+                               bcm43xx_phy_read(dev, 0x0034) | 0x0001);

-       if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
-           ((bus->board_type == SSB_BOARD_BU4306) ||
-            (bus->board_type == SSB_BOARD_BU4309))) { 
-               if (phy->lofcal == 0xFFFF) {
-                       TODO();//TODO: LOF Cal
-                       bcm43xx_radio_set_tx_iq(dev);
-               } else
-                       bcm43xx_radio_write16(dev, 0x001E, phy->lofcal); 
-       }
+               bcm43xx_phy_rssiagc(dev, 0);

-       bcm43xx_phy_write(dev, 0x007A, 0xF111);
+               bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
+                       bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) | BCM43xx_PHY_CRS0_EN); 

-       if (phy->cur_idle_tssi == 0) {
-               bcm43xx_radio_write16(dev, 0x0019, 0x0000);
-               bcm43xx_radio_write16(dev, 0x0017, 0x0020);
+               bcm43xx_radio_init2060(dev); 

-               tval = bcm43xx_ofdmtab_read16(dev, 0x3001, 0);
-               if (phy->rev == 1) {
-                       bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
-                                         (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0xFF87) 
-                                         | 0x0058);
-               } else {
-                       bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
-                                         (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0xFFC3) 
-                                         | 0x002C);
+               if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
+                   ((bus->board_type == SSB_BOARD_BU4306) ||
+                    (bus->board_type == SSB_BOARD_BU4309))) { 
+                       ; //TODO: A PHY LO
                }
-               bcm43xx_dummy_transmission(dev);
-               phy->cur_idle_tssi = bcm43xx_phy_read(dev, BCM43xx_PHY_A_PCTL);
-               bcm43xx_ofdmtab_write16(dev, 0x3001, 0, tval); 

-               bcm43xx_radio_set_txpower_a(dev, 0x0018);
+               if (phy->rev >= 3)
+                       bcm43xx_phy_ww(dev);
+
+               hardware_pctl_init_aphy(dev);
+
 +               //TODO: radar detection 
+       }
+       if ((phy->type == BCM43xx_PHYTYPE_G) &&
+           (dev->dev->bus->sprom.r1.boardflags_lo & BCM43xx_BFL_PACTRL)) {
+               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x6E), 
+                                 (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x6E))
+                                  & 0xE000) | 0x3CF);
        }
-       bcm43xx_shm_clear_tssi(dev);
 }

 static void bcm43xx_phy_initb2(struct bcm43xx_wldev *dev) 
Index: bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile
===================================================================
--- bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/Makefile     2007-05-12 16:27: 31.000000000 +0200
+++ bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile  2007-05-12 16:29:05.000000000 +0200
@@ -15,4 +15,5 @@ bcm43xx-mac80211-objs := bcm43xx_main.o
                         bcm43xx_leds.o \ 
                         bcm43xx_xmit.o \
                         bcm43xx_lo.o \
+                        bcm43xx_wa.o \
                         $(bcm43xx-mac80211-obj-y)


--
Greetings Michael. 
_______________________________________________
Bcm43xx-dev mailing list
Bcm43xx-dev at lists.berlios.de 
 https://lists.berlios.de/mailman/listinfo/bcm43xx-dev


 _______________________________________________
Bcm43xx-dev mailing list
Bcm43xx-dev at lists.berlios.de
https://lists.berlios.de/mailman/listinfo/bcm43xx-dev


       
---------------------------------
Looking for a deal? Find great prices on flights and hotels with Yahoo! FareChase.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070515/06e5859e/attachment.html>

From fabiannorton at yahoo.de  Tue May 15 13:50:39 2007
From: fabiannorton at yahoo.de (fabiannorton)
Date: Tue, 15 May 2007 13:50:39 +0200
Subject: bcm43xx stopps "monitor" modus
Message-ID: <46499E8F.2010103@yahoo.de>

Hello together :)

thanks for this great Driver!! :)

It works great here - but only one Problem:

If i put the Driver/Card at the "Monitor" Modus (iwconfig eth1 mode 
monitor) it works - but only for maybe 2-5 min.
Then the Card goes back to the "Managed" Mode.

How get i the Card permanently at the "Monitor" Modus??

I'm not connected to any Access Point or set any ESSID.

The output from iwconfig:

-------------------------------
eth1
  IEEE 802.11b/g  ESSID:off/any  Nickname:"Broadcom 4311"
  Mode:Monitor  Frequency=2.472 GHz  Access Point: Invalid
-------------------------------

This is my System configuration:

Notebook: HP nx6325
Card:     Broadcom BCM4310
Linux:    2.6.21.1

Patch: bcm43xx-injection-linux-2.6.20.patch


Thanks for your help and best regards

Fabian Norton


From stefano.brivio at polimi.it  Tue May 15 15:30:29 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 15 May 2007 15:30:29 +0200
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <25658.26952.qm@web61016.mail.yahoo.com>
References: <b1923f7f0705131002s79d08454k430d2c0051c2d840@mail.gmail.com>
	<25658.26952.qm@web61016.mail.yahoo.com>
Message-ID: <20070515153029.5533eeb4@localhost>

On Tue, 15 May 2007 03:30:10 -0700 (PDT)
saleh saeed <geo_saleh at yahoo.com> wrote:

> I am new in linux
> 
> I have hp pavilion dv6248eu
> with AMD turion 64 x2
> and Broadcom 4312 wireless card.
> how can I use this patch to make my wireless card working

I would suggest this patch instead:
http://en.wikibooks.org/wiki/English/Contents


-- 
Ciao
Stefano


From johannes at sipsolutions.net  Tue May 15 15:42:49 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 15 May 2007 15:42:49 +0200
Subject: bcm43xx stopps "monitor" modus
In-Reply-To: <46499E8F.2010103@yahoo.de>
References: <46499E8F.2010103@yahoo.de>
Message-ID: <1179236569.4196.0.camel@johannes.berg>

On Tue, 2007-05-15 at 13:50 +0200, fabiannorton wrote:

> How get i the Card permanently at the "Monitor" Modus??

Learn how to use your system. And then turn off network manager.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070515/242f4281/attachment.pgp>

From geo_saleh at yahoo.com  Tue May 15 18:36:54 2007
From: geo_saleh at yahoo.com (saleh saeed)
Date: Tue, 15 May 2007 09:36:54 -0700 (PDT)
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <20070515153029.5533eeb4@localhost>
Message-ID: <157485.77535.qm@web61013.mail.yahoo.com>

thanks alot 

Stefano Brivio <stefano.brivio at polimi.it> wrote: On Tue, 15 May 2007 03:30:10 -0700 (PDT)
saleh saeed  wrote:

> I am new in linux
> 
> I have hp pavilion dv6248eu
> with AMD turion 64 x2
> and Broadcom 4312 wireless card.
> how can I use this patch to make my wireless card working

I would suggest this patch instead:
http://en.wikibooks.org/wiki/English/Contents


-- 
Ciao
Stefano


       
---------------------------------
Be a better Globetrotter. Get better travel answers from someone who knows.
Yahoo! Answers - Check it out.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070515/7544e381/attachment.html>

From proski at gnu.org  Tue May 15 19:27:46 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 15 May 2007 13:27:46 -0400
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <20070515153029.5533eeb4@localhost>
References: <b1923f7f0705131002s79d08454k430d2c0051c2d840@mail.gmail.com>
	<25658.26952.qm@web61016.mail.yahoo.com>
	<20070515153029.5533eeb4@localhost>
Message-ID: <1179250066.15849.6.camel@dv>

Hello, Stefano!

On Tue, 2007-05-15 at 15:30 +0200, Stefano Brivio wrote:
> On Tue, 15 May 2007 03:30:10 -0700 (PDT)
> saleh saeed <geo_saleh at yahoo.com> wrote:
> 
> > I am new in linux
> > 
> > I have hp pavilion dv6248eu
> > with AMD turion 64 x2
> > and Broadcom 4312 wireless card.
> > how can I use this patch to make my wireless card working
> 
> I would suggest this patch instead:
> http://en.wikibooks.org/wiki/English/Contents

Actually, I've seen people with native English who are also top-posting,
using HTML for e-mail, using "reply" as a shortcut for "post to the
list", asking loaded questions and omitting question marks.

This document would be more helpful:
http://www.catb.org/~esr/faqs/smart-questions.html

Sorry for polluting this thread even further, but I'm not going to post
to it anymore.

-- 
Regards,
Pavel Roskin



From stefano.brivio at polimi.it  Tue May 15 21:01:27 2007
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 15 May 2007 21:01:27 +0200
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <1179250066.15849.6.camel@dv>
References: <b1923f7f0705131002s79d08454k430d2c0051c2d840@mail.gmail.com>
	<25658.26952.qm@web61016.mail.yahoo.com>
	<20070515153029.5533eeb4@localhost> <1179250066.15849.6.camel@dv>
Message-ID: <20070515210127.486f8efa@localhost>

On Tue, 15 May 2007 13:27:46 -0400
Pavel Roskin <proski at gnu.org> wrote:

> Actually, I've seen people with native English who are also top-posting,
> using HTML for e-mail, using "reply" as a shortcut for "post to the
> list", asking loaded questions and omitting question marks.
> 
> This document would be more helpful:
> http://www.catb.org/~esr/faqs/smart-questions.html

Me too, I usually post a link to this. But this time it wasn't about bad
writing, it was about bad (not) reading. :)


--
Ciao
Stefano


From larry.finger at lwfinger.net  Wed May 16 01:50:27 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 15 May 2007 18:50:27 -0500
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <25658.26952.qm@web61016.mail.yahoo.com>
References: <25658.26952.qm@web61016.mail.yahoo.com>
Message-ID: <464A4743.20300@lwfinger.net>

saleh saeed wrote:
> I am new in linux
> 
> I have hp pavilion dv6248eu
> with AMD turion 64 x2
> and Broadcom 4312 wireless card.
> how can I use this patch to make my wireless card working

This patch is not the best way for you to go. You should download v2.6.22-rc1 kernel source, build 
it for your hardware and boot it. You will also need to get a copy of bcm43xx-fwcutter to extract 
firmware from a V3 Windows driver.

Larry



From geekypenguin at gmail.com  Wed May 16 05:10:03 2007
From: geekypenguin at gmail.com (Jory A. Pratt)
Date: Tue, 15 May 2007 22:10:03 -0500
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <25658.26952.qm@web61016.mail.yahoo.com>
References: <25658.26952.qm@web61016.mail.yahoo.com>
Message-ID: <464A760B.1090907@gmail.com>

On 5/12/07, *Michael Buesch* < mb at bu3sch.de <mailto:mb at bu3sch.de>> wrote:
>
>         On Saturday 12 May 2007 01:07:01 Michael Buesch wrote:
>         > On Friday 11 May 2007 12:24:33 Michael Buesch wrote:
>         > > On Monday 23 April 2007 20:30:41 Stefano Brivio wrote:
>         > > > This patch fixes A/G PHYs setup and initialization
>         routines. Let's move
>         > > > the so-called workarounds in a separate file, in order
>         to avoid clobbering
>         > > > bcm43xx_phy.c.
>
>         Here's latest version of the patch.
>         Yet another few bugs fixed.
>
>         Index:
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c
>         ===================================================================
>
>         --- /dev/null   1970-01-01 00:00:00.000000000 +0000
>         +++
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.c      2007-05-12
>         16:29:05.000000000 +0200
>         @@ -0,0 +1,668 @@
>         +/*
>         +
>         +  Broadcom BCM43xx wireless driver
>         +
>         +  PHY workarounds.
>         +
>         +  Copyright (c) 2005 Martin Langer <martin-langer at gmx.de
>         <mailto:martin-langer at gmx.de>>,
>         +  Copyright (c) 2005-2007 Stefano Brivio < st3 at riseup.net
>         <mailto:st3 at riseup.net>>
>         +  Copyright (c) 2005-2007 Michael Buesch <mbuesch at freenet.de
>         <mailto:mbuesch at freenet.de>>
>         +  Copyright (c) 2005, 2006 Danny van Dyk <
>         kugelfang at gentoo.org <mailto:kugelfang at gentoo.org>>
>         +  Copyright (c) 2005, 2006 Andreas Jaggi
>         <andreas.jaggi at waterwave.ch <mailto:andreas.jaggi at waterwave.ch> >
>         +
>         +  This program is free software; you can redistribute it
>         and/or modify
>         +  it under the terms of the GNU General Public License as
>         published by
>         +  the Free Software Foundation; either version 2 of the
>         License, or
>         +  (at your option) any later version.
>         +
>         +  This program is distributed in the hope that it will be
>         useful,
>         +  but WITHOUT ANY WARRANTY; without even the implied warranty of
>         +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>         +  GNU General Public License for more details.
>         +
>         +  You should have received a copy of the GNU General Public
>         License
>         +  along with this program; see the file COPYING.  If not,
>         write to
>         +  the Free Software Foundation, Inc., 51 Franklin Steet,
>         Fifth Floor,
>         +  Boston, MA 02110-1301, USA.
>         +
>         +*/
>         +
>         +#include "bcm43xx.h "
>         +#include "bcm43xx_main.h"
>         +#include "bcm43xx_tables.h"
>         +#include "bcm43xx_phy.h"
>         +#include "bcm43xx_wa.h"
>         +
>         +static void bcm43xx_wa_papd(struct bcm43xx_wldev *dev)
>         +{
>         +       u16 backup;
>         +
>         +       backup = bcm43xx_ofdmtab_read16(dev,
>         BCM43xx_OFDMTAB_PWRDYN2, 0);
>         +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2,
>         0, 7);
>         +       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_UNKNOWN_APHY, 0, 0);
>         +       bcm43xx_dummy_transmission(dev);
>         +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_PWRDYN2,
>         0, backup);
>         +}
>         +
>         +static void bcm43xx_wa_auxclipthr(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E), 0x3800);
>         +}
>         +
>         +static void bcm43xx_wa_afcdac(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_phy_write(dev, 0x0035, 0x03FF);
>         +       bcm43xx_phy_write(dev, 0x0036, 0x0400);
>         +}
>         +
>         +static void bcm43xx_wa_txdc_offset(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 0,
>         0x0051);
>         +}
>         +
>         +void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev)
>         +{
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_LNAHPFCTL, 0x1FF9);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
>         +               bcm43xx_phy_read(dev, BCM43xx_PHY_LPFGAINCTL)
>         & 0xFF0F);
>         +       if (phy->rev <= 2)
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_LPFGAIN, 0, 0x1FBF);
>         +       bcm43xx_radio_write16(dev, 0x0002, 0x1FBF);
>         +
>         +       bcm43xx_phy_write(dev, 0x0024, 0x4680);
>         +       bcm43xx_phy_write(dev, 0x0020, 0x0003);
>         +       bcm43xx_phy_write(dev, 0x001D, 0x0F40);
>         +       bcm43xx_phy_write(dev, 0x001F, 0x1C00);
>         +       if (phy->rev <= 3)
>         +               bcm43xx_phy_write(dev, 0x002A,
>         +                       (bcm43xx_phy_read(dev, 0x002A) &
>         0x00FF) | 0x0400);
>         +       else if (phy->rev == 5) {
>         +               bcm43xx_phy_write(dev, 0x002A,
>         +                       (bcm43xx_phy_read(dev, 0x002A) &
>         0x00FF) | 0x1A00);
>         +               bcm43xx_phy_write(dev, 0x00CC, 0x2121);
>         +       }
>         +       if (phy->rev >= 3)
>         +               bcm43xx_phy_write(dev, 0x00BA, 0x3ED5);
>         +}
>         +
>         +static void bcm43xx_wa_divider(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_phy_write(dev, 0x002B, bcm43xx_phy_read(dev,
>         0x002B) & ~0x0100);
>         +       bcm43xx_phy_write(dev, 0x008E, 0x58C1);
>         +}
>         +
>         +static void bcm43xx_wa_gt(struct bcm43xx_wldev *dev) /* Gain
>         table. */
>         +{
>         +       if (dev->phy.rev <= 2) {
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN2, 0, 15);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN2, 1, 31);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN2, 2, 42);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN2, 3, 48);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN2, 4, 58);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 0, 19);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 1, 19);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 2, 19);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 3, 19);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 4, 21);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 5, 21);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 6, 25);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN1, 0, 3);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN1, 1, 3);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN1, 2, 7);
>         +       } else {
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 0, 19);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 1, 19);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 2, 19);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 3, 19);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 4, 21);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 5, 21);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAIN0, 6, 25);
>         +       }
>         +}
>         +
>         +static void bcm43xx_wa_rssi_lt(struct bcm43xx_wldev *dev) /*
>         RSSI lookup table */
>         +{
>         +       int i;
>         +
>         +       for (i = 0; i < 8; i++)
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_RSSI, i, i + 8);
>         +       for (i = 8; i < 16; i++)
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_RSSI, i, i - 8);
>         +}
>         +
>         +static void bcm43xx_wa_analog(struct bcm43xx_wldev *dev)
>         +{
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +
>         +       if (phy->analog > 2) {
>         +               if (phy->type == BCM43xx_PHYTYPE_A)
>         +                       bcm43xx_phy_write(dev,
>         BCM43xx_PHY_PWRDOWN, 0x1808);
>         +               else
>         +                       bcm43xx_phy_write(dev,
>         BCM43xx_PHY_PWRDOWN, 0x1000);
>         +       } else {
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_DAC, 3, 0x1044);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_DAC, 4, 0x7201);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_DAC, 6, 0x0040);
>         +       }
>         +}
>         +
>         +static void bcm43xx_wa_dac(struct bcm43xx_wldev *dev)
>         +{
>         +       if (dev->phy.analog == 1)
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_DAC, 1,
>         +                       (bcm43xx_ofdmtab_read16(dev,
>         BCM43xx_OFDMTAB_DAC, 1) & ~0x0034) | 0x0008);
>         +       else
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_DAC, 1,
>         +                       (bcm43xx_ofdmtab_read16(dev,
>         BCM43xx_OFDMTAB_DAC, 1) & ~0x0078) | 0x0010);
>         +}
>         +
>         +static void bcm43xx_wa_fft(struct bcm43xx_wldev *dev) /* Fine
>         frequency table */
>         +{
>         +       int i;
>         +
>         +       if (dev->phy.type == BCM43xx_PHYTYPE_A)
>         +               for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
>         +                       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqa[i]);
>         +       else
>         +               for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
>         +                       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_DACRFPABB, i, bcm43xx_tab_finefreqg[i]);
>         +}
>         +
>         +static void bcm43xx_wa_nft(struct bcm43xx_wldev *dev) /*
>         Noise figure table */
>         +{
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +       int i;
>         +
>         +       if (phy->type == BCM43xx_PHYTYPE_A) {
>         +               if (phy->rev == 2)
>         +                       for (i = 0; i <
>         BCM43xx_TAB_NOISEA2_SIZE; i++)
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea2[i]);
>         +               else
>         +                       for (i = 0; i <
>         BCM43xx_TAB_NOISEA3_SIZE; i++)
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noisea3[i]);
>         +       } else {
>         +               if (phy->rev == 1)
>         +                       for (i = 0; i <
>         BCM43xx_TAB_NOISEG1_SIZE; i++)
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg1[i]);
>         +               else
>         +                       for (i = 0; i <
>         BCM43xx_TAB_NOISEG2_SIZE; i++)
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC2, i, bcm43xx_tab_noiseg2[i]);
>         +       }
>         +}
>         +
>         +static void bcm43xx_wa_rt(struct bcm43xx_wldev *dev) /* Rotor
>         table */
>         +{
>         +       int i;
>         +
>         +       for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
>         +               bcm43xx_ofdmtab_write32(dev,
>         BCM43xx_OFDMTAB_ROTOR, i, bcm43xx_tab_rotor[i]);
>         +}
>         +
>         +static void bcm43xx_wa_nst(struct bcm43xx_wldev *dev) /*
>         Noise scale table */
>         +{
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +       int i;
>         +
>         +       if (phy->type == BCM43xx_PHYTYPE_A) {
>         +               if (phy->rev <= 1)
>         +                       for (i = 0; i <
>         BCM43xx_TAB_NOISESCALE_SIZE; i++)
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_NOISESCALE,
>         +                                                       i, 0);
>         +               else if (phy->rev == 2)
>         +                       for (i = 0; i <
>         BCM43xx_TAB_NOISESCALE_SIZE; i++)
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_NOISESCALE,
>         +                                                       i,
>         bcm43xx_tab_noisescalea2[i]);
>         +               else if (phy->rev == 3)
>         +                       for (i = 0; i <
>         BCM43xx_TAB_NOISESCALE_SIZE; i++)
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_NOISESCALE,
>         +                                                       i,
>         bcm43xx_tab_noisescalea3[i]);
>         +               else
>         +                       for (i = 0; i <
>         BCM43xx_TAB_NOISESCALE_SIZE; i++)
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_NOISESCALE,
>         +                                                       i,
>         bcm43xx_tab_noisescaleg3[i]);
>         +       } else {
>         +               if (phy->rev >= 6) {
>         +                       if (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_ENCORE) & BCM43xx_PHY_ENCORE_EN)
>         +                               for (i = 0; i <
>         BCM43xx_TAB_NOISESCALE_SIZE; i++)
>         +                                      
>         bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
>         +                                               i,
>         bcm43xx_tab_noisescaleg3[i]);
>         +                       else
>         +                               for (i = 0; i <
>         BCM43xx_TAB_NOISESCALE_SIZE; i++)
>         +                                      
>         bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_NOISESCALE,
>         +                                               i,
>         bcm43xx_tab_noisescaleg2[i]);
>         +               } else {
>         +                       for (i = 0; i <
>         BCM43xx_TAB_NOISESCALE_SIZE; i++)
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_NOISESCALE,
>         +                                                       i,
>         bcm43xx_tab_noisescaleg1[i]);
>         +               }
>         +       }
>         +}
>         +
>         +static void bcm43xx_wa_art(struct bcm43xx_wldev *dev) /* ADV
>         retard table */
>         +{
>         +       int i;
>         +
>         +       for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
>         +                       bcm43xx_ofdmtab_write32(dev,
>         BCM43xx_OFDMTAB_ADVRETARD,
>         +                               i, bcm43xx_tab_retard[i]);
>         +}
>         +
>         +static void bcm43xx_wa_txlna_gain(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DC, 13,
>         0x0000);
>         +}
>         +
>         +static void bcm43xx_wa_crs_reset(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_phy_write(dev, 0x002C, 0x0064);
>         +}
>         +
>         +static void bcm43xx_wa_2060txlna_gain(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_hf_write(dev, bcm43xx_hf_read(dev) |
>         +                        BCM43xx_HF_2060W);
>         +}
>         +
>         +static void bcm43xx_wa_lms(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_phy_write(dev, 0x0055,
>         +               (bcm43xx_phy_read(dev, 0x0055) & 0xFFC0) |
>         0x0004);
>         +}
>         +
>         +static void bcm43xx_wa_mixedsignal(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_DAC, 1, 3);
>         +}
>         +
>         +static void bcm43xx_wa_msst(struct bcm43xx_wldev *dev) /* Min
>         sigma square table */
>         +{
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +       int i;
>         +       const u16 *tab;
>         +
>         +       if (phy->type == BCM43xx_PHYTYPE_A) {
>         +               tab = bcm43xx_tab_sigmasqr1;
>         +       } else if (phy->type == BCM43xx_PHYTYPE_G) {
>         +               tab = bcm43xx_tab_sigmasqr2;
>         +       } else {
>         +               assert(0);
>         +               return;
>         +       }
>         +
>         +       for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++) {
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_MINSIGSQ,
>         +                                       i, tab[i]);
>         +       }
>         +}
>         +
>         +static void bcm43xx_wa_iqadc(struct bcm43xx_wldev *dev)
>         +{
>         +       if (dev->phy.analog == 4)
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_DAC, 0,
>         +                       bcm43xx_ofdmtab_read16(dev,
>         BCM43xx_OFDMTAB_DAC, 0) & ~0xF000);
>         +}
>         +
>         +static void bcm43xx_wa_crs_ed(struct bcm43xx_wldev *dev)
>         +{
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +
>         +       if (phy->rev == 1) {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_CRSTHRES1,
>         0x4F19);
>         +       } else if (phy->rev == 2) {
>         +               bcm43xx_phy_write(dev,
>         BCM43xx_PHY_CRSTHRES1_R1, 0x1861);
>         +               bcm43xx_phy_write(dev,
>         BCM43xx_PHY_CRSTHRES2_R1, 0x1861);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_ANTDWELL,
>         +                                 bcm43xx_phy_read(dev,
>         BCM43xx_PHY_ANTDWELL)
>         +                                 | 0x0800);
>         +       } else {
>         +               bcm43xx_phy_write(dev,
>         BCM43xx_PHY_CRSTHRES1_R1, 0x0098);
>         +               bcm43xx_phy_write(dev,
>         BCM43xx_PHY_CRSTHRES2_R1, 0x0070);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xC9),
>         0x0080);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_ANTDWELL,
>         +                                 bcm43xx_phy_read(dev,
>         BCM43xx_PHY_ANTDWELL)
>         +                                 | 0x0800);
>         +       }
>         +}
>         +
>         +static void bcm43xx_wa_crs_thr(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
>         +                       (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_CRS0) & ~0x03C0) | 0xD000);
>         +}
>         +
>         +static void bcm43xx_wa_crs_blank(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x2C), 0x005A);
>         +}
>         +
>         +static void bcm43xx_wa_cck_shiftbits(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS, 0x0026);
>         +}
>         +
>         +static void bcm43xx_wa_wrssi_offset(struct bcm43xx_wldev *dev)
>         +{
>         +       int i;
>         +
>         +       if (dev->phy.rev == 1) {
>         +               for (i = 0; i < 16; i++) {
>         +                       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_WRSSI_R1,
>         +                                               i, 0x0020);
>         +               }
>         +       } else {
>         +               for (i = 0; i < 32; i++) {
>         +                       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_WRSSI,
>         +                                               i, 0x0820);
>         +               }
>         +       }
>         +}
>         +
>         +static void bcm43xx_wa_txpuoff_rxpuon(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_UNKNOWN_0F, 2, 15);
>         +       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_UNKNOWN_0F, 3, 20);
>         +}
>         +
>         +static void bcm43xx_wa_altagc(struct bcm43xx_wldev *dev)
>         +{
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +
>         +       if (phy->rev == 1) {
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC1_R1, 0, 254);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC1_R1, 1, 13);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC1_R1, 2, 19);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC1_R1, 3, 25);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC2, 0, 0x2710);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC2, 1, 0x9B83);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC2, 2, 0x9B83);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC2, 3, 0x0F8D);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_LMS, 4);
>         +       } else {
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC1, 0, 254);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC1, 1, 13);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC1, 2, 19);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC1, 3, 25);
>         +       }
>         +
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_CCKSHIFTBITS_WA,
>         +               (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_CCKSHIFTBITS_WA) & ~0xFF00) | 0x5700);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1A),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1A))
>         & ~0x007F) | 0x000F);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1A),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1A))
>         & ~0x3F80) | 0x2B80);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT,
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_ANTWRSETT)
>         & 0xF0FF) | 0x0300);
>         +       bcm43xx_radio_write16(dev, 0x7A,
>         +               bcm43xx_radio_read16(dev, 0x7A) | 0x0008);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_N1P1GAIN,
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_N1P1GAIN) &
>         ~0x000F) | 0x0008);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_P1P2GAIN,
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_P1P2GAIN) &
>         ~0x0F00) | 0x0600);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_N1N2GAIN,
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_N1N2GAIN) &
>         ~0x0F00) | 0x0700);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_N1P1GAIN,
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_N1P1GAIN) &
>         ~0x0F00) | 0x0100);
>         +       if (phy->rev == 1) {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_N1N2GAIN,
>         +                                 (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_N1N2GAIN)
>         +                                  & ~0x000F) | 0x0007);
>         +       }
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88))
>         & ~0x00FF) | 0x001C);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x88),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x88))
>         & ~0x3F00) | 0x0200);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x96))
>         & ~0x00FF) | 0x001C);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89))
>         & ~0x00FF) | 0x0020);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x89),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x89))
>         & ~0x3F00) | 0x0200);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82))
>         & ~0x00FF) | 0x002E);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x96),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x96))
>         & ~0xFF00) | 0x1A00);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81))
>         & ~0x00FF) | 0x0028);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x81),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x81))
>         & ~0xFF00) | 0x2C00);
>         +       if (phy->rev == 1) {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_PEAK_COUNT,
>         0x092B);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
>         +                       (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_OFDM(0x1B)) & ~0x001E) | 0x0002);
>         +       } else {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
>         +                       bcm43xx_phy_read(dev,
>         BCM43xx_PHY_OFDM(0x1B)) & ~0x001E);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1F),
>         0x287A);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_LPFGAINCTL,
>         +                       (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_LPFGAINCTL) & ~0x000F) | 0x0004);
>         +               if (phy->rev >= 6) {
>         +                       bcm43xx_phy_write(dev,
>         BCM43xx_PHY_OFDM(0x22), 0x287A);
>         +                       bcm43xx_phy_write(dev,
>         BCM43xx_PHY_LPFGAINCTL,
>         +                               (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_LPFGAINCTL) & ~0xF000) | 0x3000);
>         +               }
>         +       }
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_DIVSRCHIDX,
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_DIVSRCHIDX)
>         & 0x7F7F) | 0x7874);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8E), 0x1C00);
>         +       if (phy->rev == 1) {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_DIVP1P2GAIN,
>         +                       (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_DIVP1P2GAIN) & ~0x0F00) | 0x0600);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8B),
>         0x005E);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_ANTWRSETT,
>         +                       (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_ANTWRSETT) & ~0x00FF) | 0x001E);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x8D),
>         0x0002);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC3_R1, 0, 0);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC3_R1, 1, 7);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC3_R1, 2, 16);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC3_R1, 3, 28);
>         +       } else {
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC3, 0, 0);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC3, 1, 7);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC3, 2, 16);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC3, 3, 28);
>         +       }
>         +       if (phy->rev >= 6) {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
>         +                       bcm43xx_phy_read(dev,
>         BCM43xx_PHY_OFDM(0x26)) & ~0x0003);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x26),
>         +                       bcm43xx_phy_read(dev,
>         BCM43xx_PHY_OFDM(0x26)) & ~0x1000);
>         +       }
>         +}
>         +
>         +static void bcm43xx_wa_tr_ltov(struct bcm43xx_wldev *dev) /*
>         TR Lookup Table Original Values */
>         +{
>         +       bcm43xx_gtab_write(dev, BCM43xx_GTAB_ORIGTR, 0, 0xC480);
>         +}
>         +
>         +static void bcm43xx_wa_cpll_nonpilot(struct bcm43xx_wldev *dev)
>         +{
>         +       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_UNKNOWN_11, 0, 0);
>         +       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_UNKNOWN_11, 1, 0);
>         +}
>         +
>         +static void bcm43xx_wa_rssi_adc(struct bcm43xx_wldev *dev)
>         +{
>         +       if (dev->phy.analog == 4)
>         +               bcm43xx_phy_write(dev, 0x00DC, 0x7454);
>         +}
>         +
>         +static void bcm43xx_wa_boards_a(struct bcm43xx_wldev *dev)
>         +{
>         +       struct ssb_bus *bus = dev->dev->bus;
>         +
>         +       if (bus->board_vendor == SSB_BOARDVENDOR_BCM &&
>         +           bus->board_type == SSB_BOARD_BU4306 &&
>         +           bus->board_rev < 0x30) {
>         +               bcm43xx_phy_write(dev, 0x0010, 0xE000);
>         +               bcm43xx_phy_write(dev, 0x0013, 0x0140);
>         +               bcm43xx_phy_write(dev, 0x0014, 0x0280);
>         +       } else {
>         +               if (bus->board_type == SSB_BOARD_MP4318 &&
>         +                   bus->board_rev < 0x20) {
>         +                       bcm43xx_phy_write(dev, 0x0013, 0x0210);
>         +                       bcm43xx_phy_write(dev, 0x0014, 0x0840);
>         +               } else {
>         +                       bcm43xx_phy_write(dev, 0x0013, 0x0140);
>         +                       bcm43xx_phy_write(dev, 0x0014, 0x0280);
>         +               }
>         +               if (dev->phy.rev <= 4)
>         +                       bcm43xx_phy_write(dev, 0x0010, 0xE000);
>         +               else
>         +                       bcm43xx_phy_write(dev, 0x0010, 0x2000);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_DC, 1, 0x0039);
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_UNKNOWN_APHY, 7, 0x0040);
>         +       }
>         +}
>         +
>         +static void bcm43xx_wa_boards_g(struct bcm43xx_wldev *dev)
>         +{
>         +       struct ssb_bus *bus = dev->dev->bus;
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +
>         +       if (bus->board_vendor != SSB_BOARDVENDOR_BCM ||
>         +           bus->board_type != SSB_BOARD_BU4306 ||
>         +           bus->board_rev != 0x17) {
>         +               if (phy->rev < 2) {
>         +                       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAINX_R1, 1, 0x0002);
>         +                       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAINX_R1, 2, 0x0001);
>         +               } else {
>         +                       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAINX, 1, 0x0002);
>         +                       bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAINX, 2, 0x0001);
>         +                       if ((bus-> sprom.r1.boardflags_lo &
>         BCM43xx_BFL_EXTLNA) &&
>         +                           (phy->rev >= 7)) {
>         +                               bcm43xx_phy_write(dev,
>         BCM43xx_PHY_EXTG(0x11),
>         +                                       bcm43xx_phy_read(dev,
>         BCM43xx_PHY_EXTG(0x11)) & 0xF7FF);
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAINX, 0x0020, 0x0001);
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAINX, 0x0021, 0x0001);
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAINX, 0x0022, 0x0001);
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAINX, 0x0023, 0x0000);
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAINX, 0x0000, 0x0000);
>         +                               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_GAINX, 0x0003, 0x0002);
>         +                       }
>         +               }
>         +       }
>         +       if (bus->sprom.r1.boardflags_lo & BCM43xx_BFL_FEM) {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_GTABCTL,
>         0x3120);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_GTABDATA,
>         0xC480);
>         +       }
>         +}
>         +
>         +void bcm43xx_wa_all(struct bcm43xx_wldev *dev)
>         +{
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +
>         +       if (phy->type == BCM43xx_PHYTYPE_A) {
>         +               switch (phy->rev) {
>         +               case 2:
>         +                       bcm43xx_wa_papd(dev);
>         +                       bcm43xx_wa_auxclipthr(dev);
>         +                       bcm43xx_wa_afcdac(dev);
>         +                       bcm43xx_wa_txdc_offset(dev);
>         +                       bcm43xx_wa_initgains(dev);
>         +                       bcm43xx_wa_divider(dev);
>         +                       bcm43xx_wa_gt(dev);
>         +                       bcm43xx_wa_rssi_lt(dev);
>         +                       bcm43xx_wa_analog(dev);
>         +                       bcm43xx_wa_dac(dev);
>         +                       bcm43xx_wa_fft(dev);
>         +                       bcm43xx_wa_nft(dev);
>         +                       bcm43xx_wa_rt(dev);
>         +                       bcm43xx_wa_nst(dev);
>         +                       bcm43xx_wa_art(dev);
>         +                       bcm43xx_wa_txlna_gain(dev);
>         +                       bcm43xx_wa_crs_reset(dev);
>         +                       bcm43xx_wa_2060txlna_gain(dev);
>         +                       bcm43xx_wa_lms(dev);
>         +                       break;
>         +               case 3:
>         +                       bcm43xx_wa_papd(dev);
>         +                       bcm43xx_wa_mixedsignal(dev);
>         +                       bcm43xx_wa_rssi_lt(dev);
>         +                       bcm43xx_wa_txdc_offset(dev);
>         +                       bcm43xx_wa_initgains(dev);
>         +                       bcm43xx_wa_dac(dev);
>         +                       bcm43xx_wa_nft(dev);
>         +                       bcm43xx_wa_nst(dev);
>         +                       bcm43xx_wa_msst(dev);
>         +                       bcm43xx_wa_analog(dev);
>         +                       bcm43xx_wa_gt(dev);
>         +                       bcm43xx_wa_txpuoff_rxpuon(dev);
>         +                       bcm43xx_wa_txlna_gain(dev);
>         +                       break;
>         +               case 5:
>         +                       bcm43xx_wa_iqadc(dev);
>         +               case 6:
>         +                       bcm43xx_wa_papd(dev);
>         +                       bcm43xx_wa_rssi_lt(dev);
>         +                       bcm43xx_wa_txdc_offset(dev);
>         +                       bcm43xx_wa_initgains(dev);
>         +                       bcm43xx_wa_dac(dev);
>         +                       bcm43xx_wa_nft(dev);
>         +                       bcm43xx_wa_nst(dev);
>         +                       bcm43xx_wa_msst(dev);
>         +                       bcm43xx_wa_analog(dev);
>         +                       bcm43xx_wa_gt(dev);
>         +                       bcm43xx_wa_txpuoff_rxpuon(dev);
>         +                       bcm43xx_wa_txlna_gain(dev);
>         +                       break;
>         +               case 7:
>         +                       bcm43xx_wa_iqadc(dev);
>         +                       bcm43xx_wa_papd(dev);
>         +                       bcm43xx_wa_rssi_lt(dev);
>         +                       bcm43xx_wa_txdc_offset(dev);
>         +                       bcm43xx_wa_initgains(dev);
>         +                       bcm43xx_wa_dac(dev);
>         +                       bcm43xx_wa_nft(dev);
>         +                       bcm43xx_wa_nst(dev);
>         +                       bcm43xx_wa_msst(dev);
>         +                       bcm43xx_wa_analog(dev);
>         +                       bcm43xx_wa_gt(dev);
>         +                       bcm43xx_wa_txpuoff_rxpuon(dev);
>         +                       bcm43xx_wa_txlna_gain(dev);
>         +                       bcm43xx_wa_rssi_adc(dev);
>         +               default:
>         +                       assert(0);
>         +               }
>         +               bcm43xx_wa_boards_a(dev);
>         +       } else if (phy->type == BCM43xx_PHYTYPE_G) {
>         +               switch (phy->rev) {
>         +               case 1://XXX review rev1
>         +                       bcm43xx_wa_crs_ed(dev);
>         +                       bcm43xx_wa_crs_thr(dev);
>         +                       bcm43xx_wa_crs_blank(dev);
>         +                       bcm43xx_wa_cck_shiftbits(dev);
>         +                       bcm43xx_wa_fft(dev);
>         +                       bcm43xx_wa_nft(dev);
>         +                       bcm43xx_wa_rt(dev);
>         +                       bcm43xx_wa_nst(dev);
>         +                       bcm43xx_wa_art(dev);
>         +                       bcm43xx_wa_wrssi_offset(dev);
>         +                       bcm43xx_wa_altagc(dev);
>         +                       break;
>         +               case 2:
>         +               case 6:
>         +               case 7:
>         +               case 8:
>         +                       bcm43xx_wa_tr_ltov(dev);
>         +                       bcm43xx_wa_crs_ed(dev);
>         +                       bcm43xx_wa_rssi_lt(dev);
>         +                       bcm43xx_wa_nft(dev);
>         +                       bcm43xx_wa_nst(dev);
>         +                       bcm43xx_wa_msst(dev);
>         +                       bcm43xx_wa_wrssi_offset(dev);
>         +                       bcm43xx_wa_altagc(dev);
>         +                       bcm43xx_wa_analog(dev);
>         +                       bcm43xx_wa_txpuoff_rxpuon(dev);
>         +                       break;
>         +               default:
>         +                       assert(0);
>         +               }
>         +               bcm43xx_wa_boards_g(dev);
>         +       } else { /* No N PHY support so far */
>         +               assert(0);
>         +       }
>         +
>         +       bcm43xx_wa_cpll_nonpilot(dev);
>         +}
>         Index:
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h
>
>         ===================================================================
>         --- /dev/null   1970-01-01 00:00:00.000000000 +0000
>         +++
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_wa.h      2007-05-12
>         16:29: 05.000000000 +0200
>         @@ -0,0 +1,7 @@
>         +#ifndef BCM43xx_WA_H_
>         +#define BCM43xx_WA_H_
>         +
>         +void bcm43xx_wa_initgains(struct bcm43xx_wldev *dev);
>         +void bcm43xx_wa_all(struct bcm43xx_wldev *dev);
>         +
>         +#endif /* BCM43xx_WA_H_ */
>         Index:
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c
>         ===================================================================
>         ---
>         bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c    
>         2007-05-12 16:27: 31.000000000 +0200
>         +++
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.c  2007-05-12
>         16:29:05.000000000 +0200
>         @@ -230,7 +230,7 @@ const u16 bcm43xx_tab_noisea2[] = {
>         };
>
>         const u16 bcm43xx_tab_noisea3[] = {
>         -       0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
>         +       0x5E5E, 0x5E5E, 0x5E5E, 0x3F48,
>                 0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
>         };
>
>         @@ -244,6 +244,26 @@ const u16 bcm43xx_tab_noiseg2[] = {
>                 0x0000, 0x0000, 0x0000, 0x0000,
>         };
>
>         +const u16 bcm43xx_tab_noisescalea2[] = {
>         +       0x6767, 0x6767, 0x6767, 0x6767, /* 0 */
>         +       0x6767, 0x6767, 0x6767, 0x6767,
>         +       0x6767, 0x6767, 0x6767, 0x6767,
>         +       0x6767, 0x6700, 0x6767, 0x6767,
>         +       0x6767, 0x6767, 0x6767, 0x6767, /* 16 */
>         +       0x6767, 0x6767, 0x6767, 0x6767,
>         +       0x6767, 0x6767, 0x0067,
>         +};
>         +
>         +const u16 bcm43xx_tab_noisescalea3[] = {
>         +       0x2323, 0x2323, 0x2323, 0x2323, /* 0 */
>         +       0x2323, 0x2323, 0x2323, 0x2323,
>         +       0x2323, 0x2323, 0x2323, 0x2323,
>         +       0x2323, 0x2300, 0x2323, 0x2323,
>         +       0x2323, 0x2323, 0x2323, 0x2323, /* 16 */
>         +       0x2323, 0x2323, 0x2323, 0x2323,
>         +       0x2323, 0x2323, 0x0023,
>         +};
>         +
>         const u16 bcm43xx_tab_noisescaleg1[] = {
>                 0x6C77, 0x5162, 0x3B40, 0x3335, /* 0 */
>                 0x2F2D, 0x2A2A, 0x2527, 0x1F21,
>         @@ -255,7 +275,7 @@ const u16 bcm43xx_tab_noisescaleg1[] = {
>         };
>
>         const u16 bcm43xx_tab_noisescaleg2[] = {
>         -       0xD8DD, 0xCBD4, 0xBCC0, 0XB6B7, /* 0 */
>         +       0xD8DD, 0xCBD4, 0xBCC0, 0xB6B7, /* 0 */
>                 0xB2B0, 0xADAD, 0xA7A9, 0x9FA1,
>                 0x969B, 0x9195, 0x8F8F, 0x8A8A,
>                 0x8A8A, 0x8A00, 0x8A8A, 0x8F8A,
>         @@ -308,6 +328,27 @@ const u16 bcm43xx_tab_sigmasqr2[] = {
>                 0x00DE,
>         };
>
>         +const u16 bcm43xx_tab_rssiagc1[] = {
>         +       0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8, /* 0 */
>         +       0xFFF8, 0xFFF9, 0xFFFC, 0xFFFE,
>         +       0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
>         +       0xFFF8, 0xFFF8, 0xFFF8, 0xFFF8,
>         +};
>         +
>         +const u16 bcm43xx_tab_rssiagc2[] = {
>         +       0x0820, 0x0820, 0x0920, 0x0C38, /* 0 */
>         +       0x0820, 0x0820, 0x0820, 0x0820,
>         +       0x0820, 0x0820, 0x0920, 0x0A38,
>         +       0x0820, 0x0820, 0x0820, 0x0820,
>         +       0x0820, 0x0820, 0x0920, 0x0A38, /* 16 */
>         +       0x0820, 0x0820, 0x0820, 0x0820,
>         +       0x0820, 0x0820, 0x0920, 0x0A38,
>         +       0x0820, 0x0820, 0x0820, 0x0820,
>         +       0x0820, 0x0820, 0x0920, 0x0A38, /* 32 */
>         +       0x0820, 0x0820, 0x0820, 0x0820,
>         +       0x0820, 0x0820, 0x0920, 0x0A38,
>         +       0x0820, 0x0820, 0x0820, 0x0820,
>         +};
>
>         static inline void assert_sizes(void)
>         {
>         @@ -319,34 +360,59 @@ static inline void assert_sizes(void)
>                 BUILD_BUG_ON(BCM43xx_TAB_NOISEA3_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_noisea3));
>                 BUILD_BUG_ON(BCM43xx_TAB_NOISEG1_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_noiseg1));
>                 BUILD_BUG_ON(BCM43xx_TAB_NOISEG2_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_noiseg2));
>         -       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_noisescaleg1));
>         -       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
>         -       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALEG_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
>         +       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_noisescaleg1));
>         +       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_noisescaleg2));
>         +       BUILD_BUG_ON(BCM43xx_TAB_NOISESCALE_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_noisescaleg3));
>                 BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_sigmasqr1));
>                 BUILD_BUG_ON(BCM43xx_TAB_SIGMASQR_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_sigmasqr2));
>         +       BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC1_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_rssiagc1));
>         +       BUILD_BUG_ON(BCM43xx_TAB_RSSIAGC2_SIZE !=
>         ARRAY_SIZE(bcm43xx_tab_rssiagc2));
>         }
>
>
>         u16 bcm43xx_ofdmtab_read16(struct bcm43xx_wldev *dev, u16
>         table, u16 offset)
>         {
>         -       assert_sizes();
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +       u16 addr;
>         +
>         +       addr = table + offset;
>         +       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL,
>         addr);
>         +               phy->ofdm_valid = 1;
>         +       }
>         +       phy->ofdm_addr = addr;
>
>         -       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table +
>         offset);
>                 return bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI);
>         +       assert_sizes();
>         }
>
>         void bcm43xx_ofdmtab_write16(struct bcm43xx_wldev *dev, u16
>         table,
>                                      u16 offset, u16 value)
>         {
>         -       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table +
>         offset);
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +       u16 addr;
>         +
>         +       addr = table + offset;
>         +       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL,
>         addr);
>         +               phy->ofdm_valid = 2;
>         +       }
>         +       phy->ofdm_addr = addr;
>                 bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
>         }
>
>         u32 bcm43xx_ofdmtab_read32(struct bcm43xx_wldev *dev, u16
>         table, u16 offset)
>         {
>         +       struct bcm43xx_phy *phy = &dev->phy;
>                 u32 ret;
>         +       u16 addr;
>
>         -       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table +
>         offset);
>         +       addr = table + offset;
>         +       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 1) {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL,
>         addr);
>         +               phy->ofdm_valid = 1;
>         +       }
>         +       phy->ofdm_addr = addr;
>                 ret = bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEQ);
>                 ret <<= 16;
>                 ret |= bcm43xx_phy_read(dev, BCM43xx_PHY_OTABLEI);
>         @@ -357,9 +423,17 @@ u32 bcm43xx_ofdmtab_read32(struct bcm43x
>         void bcm43xx_ofdmtab_write32(struct bcm43xx_wldev *dev, u16 table,
>                                      u16 offset, u32 value)
>         {
>         -       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL, table +
>         offset);
>         -       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
>         +       struct bcm43xx_phy *phy = &dev->phy;
>         +       u16 addr;
>         +
>         +       addr = table + offset;
>         +       if (addr - 1 != phy->ofdm_addr || phy->ofdm_valid != 2) {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLECTL,
>         addr);
>         +               phy->ofdm_valid = 2;
>         +       }
>         +       phy->ofdm_addr = addr;
>                 bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEQ, (value >>
>         16));
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OTABLEI, value);
>         }
>
>         u16 bcm43xx_gtab_read(struct bcm43xx_wldev *dev, u16 table,
>         u16 offset)
>         Index:
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h
>
>         ===================================================================
>         ---
>         bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h    2007-05-12
>         16:27:31.000000000 +0200
>         +++
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx.h
>         2007-05-12 16:29: 05.000000000 +0200
>         @@ -591,6 +591,10 @@ struct bcm43xx_phy {
>                 u16 lofcal;
>
>                 u16 initval;//FIXME rename?
>         +
>         +       /* OFDM address read/write caching for hardware
>         auto-increment. */
>         +       u16 ofdm_addr;
>         +       u8 ofdm_valid; /* 0: invalid, 1: read, 2: write */
>         };
>
>         /* Data structures for DMA transmission, per 80211 core. */
>         Index:
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c
>
>         ===================================================================
>         ---
>         bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c      
>         2007-05-12 16:27:31.000000000 +0200
>         +++
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c    2007-05-12
>         16:29: 05.000000000 +0200
>         @@ -3127,6 +3127,9 @@ static void setup_struct_phy_for_init(st
>                 spin_lock_init(&phy->lock);
>                 phy->interfmode = BCM43xx_INTERFMODE_NONE;
>                 phy->channel = 0xFF;
>         +
>         +       /* OFDM address caching. */
>         +       phy->ofdm_valid = 0;
>         }
>
>         static void setup_struct_wldev_for_init(struct bcm43xx_wldev *dev)
>         Index:
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h
>
>         ===================================================================
>         ---
>         bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h        2007-05-12
>         16:27:31.000000000 +0200
>         +++
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.h    
>         2007-05-12 16:29: 05.000000000 +0200
>         @@ -28,8 +28,11 @@ struct bcm43xx_wldev;
>         #define
>         BCM43xx_PHY_PWRDOWN            BCM43xx_PHY_OFDM(0x03)  /*
>         Powerdown */
>         #define
>         BCM43xx_PHY_CRSTHRES1          BCM43xx_PHY_OFDM(0x06)  /* CRS
>         Threshold 1 */
>         #define
>         BCM43xx_PHY_LNAHPFCTL          BCM43xx_PHY_OFDM(0x1C)  /*
>         LNA/HPF control */
>         +#define BCM43xx_PHY_LPFGAINCTL        
>         BCM43xx_PHY_OFDM(0x20)  /* LPF Gain control */
>         #define
>         BCM43xx_PHY_ADIVRELATED                BCM43xx_PHY_OFDM(0x27)  /*
>         FIXME rename */
>         #define BCM43xx_PHY_CRS0               BCM43xx_PHY_OFDM(0x29)
>         +#define  BCM43xx_PHY_CRS0_EN           0x4000
>         +#define BCM43xx_PHY_PEAK_COUNT         BCM43xx_PHY_OFDM(0x30)
>         #define BCM43xx_PHY_ANTDWELL          
>         BCM43xx_PHY_OFDM(0x2B)  /* Antenna dwell */
>         #define  BCM43xx_PHY_ANTDWELL_AUTODIV1
>         0x0100                  /* Automatic RX diversity start antenna */
>         #define BCM43xx_PHY_ENCORE            
>         BCM43xx_PHY_OFDM(0x49)  /* "Encore" (RangeMax / BroadRange) */
>         @@ -38,6 +41,7 @@ struct bcm43xx_wldev;
>         #define BCM43xx_PHY_OFDM61            
>         BCM43xx_PHY_OFDM(0x61)  /* FIXME rename */
>         #define  BCM43xx_PHY_OFDM61_10        
>         0x0010                  /* FIXME rename */
>         #define
>         BCM43xx_PHY_IQBAL              BCM43xx_PHY_OFDM(0x69)  /* I/Q
>         balance */
>         +#define
>         BCM43xx_PHY_BBTXDC_BIAS                BCM43xx_PHY_OFDM(0x6B)  /*
>         Baseband TX DC bias */
>         #define
>         BCM43xx_PHY_OTABLECTL          BCM43xx_PHY_OFDM(0x72)  /* OFDM
>         table control (see below) */
>         #define  BCM43xx_PHY_OTABLEOFF        
>         0x03FF                  /* OFDM table offset (see below) */
>         #define  BCM43xx_PHY_OTABLENR          0xFC00                  /*
>         OFDM table number (see below) */
>         @@ -45,6 +49,9 @@ struct bcm43xx_wldev;
>         #define
>         BCM43xx_PHY_OTABLEI            BCM43xx_PHY_OFDM(0x73)  /* OFDM
>         table data I */
>         #define
>         BCM43xx_PHY_OTABLEQ            BCM43xx_PHY_OFDM(0x74)  /* OFDM
>         table data Q */
>         #define BCM43xx_PHY_HPWR_TSSICTL      
>         BCM43xx_PHY_OFDM(0x78)  /* Hardware power TSSI control */
>         +#define BCM43xx_PHY_ADCCTL            
>         BCM43xx_PHY_OFDM(0x7A)  /* ADC control */
>         +#define BCM43xx_PHY_IDLE_TSSI          BCM43xx_PHY_OFDM(0x7B)
>         +#define BCM43xx_PHY_A_TEMP_SENSE      
>         BCM43xx_PHY_OFDM(0x7C)  /* A PHY temperature sense */
>         #define BCM43xx_PHY_NRSSITHRES        
>         BCM43xx_PHY_OFDM(0x8A)  /* NRSSI threshold */
>         #define
>         BCM43xx_PHY_ANTWRSETT          BCM43xx_PHY_OFDM(0x8C)  /*
>         Antenna WR settle */
>         #define  BCM43xx_PHY_ANTWRSETT_ARXDIV  0x2000                  /*
>         Automatic RX diversity enabled */
>         @@ -55,6 +62,8 @@ struct bcm43xx_wldev;
>         #define BCM43xx_PHY_N1N2GAIN           BCM43xx_PHY_OFDM(0xA2)
>         #define BCM43xx_PHY_CLIPTHRES          BCM43xx_PHY_OFDM(0xA3)
>         #define BCM43xx_PHY_CLIPN1P2THRES      BCM43xx_PHY_OFDM(0xA4)
>         +#define
>         BCM43xx_PHY_CCKSHIFTBITS_WA    BCM43xx_PHY_OFDM(0xA5)  /* CCK
>         shiftbits workaround, FIXME rename */
>         +#define BCM43xx_PHY_CCKSHIFTBITS      
>         BCM43xx_PHY_OFDM(0xA7)  /* FIXME rename */
>         #define BCM43xx_PHY_DIVSRCHIDX        
>         BCM43xx_PHY_OFDM(0xA8)  /* Divider search gain/index */
>         #define
>         BCM43xx_PHY_CLIPP2THRES                BCM43xx_PHY_OFDM(0xA9)
>         #define
>         BCM43xx_PHY_CLIPP3THRES                BCM43xx_PHY_OFDM(0xAA)
>         @@ -128,13 +137,14 @@ struct bcm43xx_wldev;
>         #define BCM43xx_OFDMTAB_DC             BCM43xx_OFDMTAB(0x0E, 7)
>         #define
>         BCM43xx_OFDMTAB_PWRDYN2                BCM43xx_OFDMTAB(0x0E, 12)
>         #define
>         BCM43xx_OFDMTAB_LNAGAIN                BCM43xx_OFDMTAB(0x0E, 13)
>         -//TODO
>         +#define BCM43xx_OFDMTAB_UNKNOWN_0F     BCM43xx_OFDMTAB(0x0F,
>         0)        //TODO rename
>         +#define BCM43xx_OFDMTAB_UNKNOWN_APHY   BCM43xx_OFDMTAB(0x0F,
>         7)        //TODO rename
>         #define
>         BCM43xx_OFDMTAB_LPFGAIN                BCM43xx_OFDMTAB(0x0F, 12)
>         #define BCM43xx_OFDMTAB_RSSI           BCM43xx_OFDMTAB(0x10, 0)
>         -//TODO
>         +#define BCM43xx_OFDMTAB_UNKNOWN_11     BCM43xx_OFDMTAB(0x11,
>         4)        //TODO rename
>         #define
>         BCM43xx_OFDMTAB_AGC1_R1                BCM43xx_OFDMTAB(0x13, 0)
>         -#define BCM43xx_OFDMTAB_GAINX_R1       BCM43xx_OFDMTAB(0x14,
>         0)        //TODO rename
>         -#define BCM43xx_OFDMTAB_MINSIGSQ       BCM43xx_OFDMTAB(0x14, 1)
>         +#define BCM43xx_OFDMTAB_GAINX_R1       BCM43xx_OFDMTAB(0x14,
>         0)        //TODO remove!
>         +#define BCM43xx_OFDMTAB_MINSIGSQ       BCM43xx_OFDMTAB(0x14, 0)
>         #define
>         BCM43xx_OFDMTAB_AGC3_R1                BCM43xx_OFDMTAB(0x15, 0)
>         #define BCM43xx_OFDMTAB_WRSSI_R1       BCM43xx_OFDMTAB(0x15, 4)
>         #define BCM43xx_OFDMTAB_TSSI           BCM43xx_OFDMTAB(0x15, 0)
>         Index:
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h
>
>         ===================================================================
>         ---
>         bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h    
>         2007-05-12 16:27:31.000000000 +0200
>         +++
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_tables.h  2007-05-12
>         16:29: 05.000000000 +0200
>         @@ -17,12 +17,18 @@ extern const u16 bcm43xx_tab_noisea3[];
>         extern const u16 bcm43xx_tab_noiseg1[];
>         #define BCM43xx_TAB_NOISEG2_SIZE       8
>         extern const u16 bcm43xx_tab_noiseg2[];
>         -#define BCM43xx_TAB_NOISESCALEG_SIZE   27
>         +#define BCM43xx_TAB_NOISESCALE_SIZE    27
>         +extern const u16 bcm43xx_tab_noisescalea2[];
>         +extern const u16 bcm43xx_tab_noisescalea3[];
>         extern const u16 bcm43xx_tab_noisescaleg1[];
>         extern const u16 bcm43xx_tab_noisescaleg2[];
>         extern const u16 bcm43xx_tab_noisescaleg3[];
>         #define BCM43xx_TAB_SIGMASQR_SIZE      53
>         extern const u16 bcm43xx_tab_sigmasqr1[];
>         extern const u16 bcm43xx_tab_sigmasqr2[];
>         +#define BCM43xx_TAB_RSSIAGC1_SIZE      16
>         +extern const u16 bcm43xx_tab_rssiagc1[];
>         +#define BCM43xx_TAB_RSSIAGC2_SIZE      48
>         +extern const u16 bcm43xx_tab_rssiagc2[];
>
>         #endif /* BCM43xx_TABLES_H_ */
>         Index:
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
>
>         ===================================================================
>         ---
>         bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c        2007-05-12
>         16:27:31.000000000 +0200
>         +++
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c    
>         2007-05-12 16:29: 05.000000000 +0200
>         @@ -34,6 +34,7 @@
>         #include "bcm43xx_tables.h"
>         #include "bcm43xx_power.h"
>         #include "bcm43xx_lo.h"
>         +#include "bcm43xx_wa.h"
>
>
>         static const s8 bcm43xx_tssi2dbm_b_table[] = {
>         @@ -559,393 +560,96 @@ static void bcm43xx_phy_init_pctl(struct
>                 bcm43xx_shm_clear_tssi(dev);
>         }
>
>         -static void bcm43xx_phy_agcsetup(struct bcm43xx_wldev *dev)
>         +static void bcm43xx_phy_rssiagc(struct bcm43xx_wldev *dev, u8
>         enable)
>         {
>         -       struct bcm43xx_phy *phy = &dev->phy;
>         -       u16 offset = 0x0000;
>         -
>         -       if (phy->rev == 1)
>         -               offset = 0x4C00;
>         -
>         -       bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00FE);
>         -       bcm43xx_ofdmtab_write16(dev, offset, 1, 0x000D);
>         -       bcm43xx_ofdmtab_write16(dev, offset, 2, 0x0013);
>         -       bcm43xx_ofdmtab_write16(dev, offset, 3, 0x0019);
>         -
>         -       if (phy->rev == 1) {
>         -               bcm43xx_ofdmtab_write16(dev, 0x1800, 0, 0x2710);
>         -               bcm43xx_ofdmtab_write16(dev, 0x1801, 0, 0x9B83);
>         -               bcm43xx_ofdmtab_write16(dev, 0x1802, 0, 0x9B83);
>         -               bcm43xx_ofdmtab_write16(dev, 0x1803, 0, 0x0F8D);
>         -               bcm43xx_phy_write(dev, 0x0455, 0x0004);
>         -       }
>         -
>         -       bcm43xx_phy_write(dev, 0x04A5,
>         -                         (bcm43xx_phy_read(dev, 0x04A5)
>         -                          & 0x00FF) | 0x5700);
>         -       bcm43xx_phy_write(dev, 0x041A,
>         -                         (bcm43xx_phy_read(dev, 0x041A)
>         -                          & 0xFF80) | 0x000F);
>         -       bcm43xx_phy_write(dev, 0x041A,
>         -                         (bcm43xx_phy_read(dev, 0x041A)
>         -                          & 0xC07F) | 0x2B80);
>         -       bcm43xx_phy_write(dev, 0x048C,
>         -                         (bcm43xx_phy_read(dev, 0x048C)
>         -                          & 0xF0FF) | 0x0300);
>         -
>         -       bcm43xx_radio_write16(dev, 0x007A,
>         -                             bcm43xx_radio_read16(dev, 0x007A)
>         -                             | 0x0008);
>         -
>         -       bcm43xx_phy_write(dev, 0x04A0,
>         -                         (bcm43xx_phy_read(dev, 0x04A0)
>         -                          & 0xFFF0) | 0x0008);
>         -       bcm43xx_phy_write(dev, 0x04A1,
>         -                         (bcm43xx_phy_read(dev, 0x04A1)
>         -                          & 0xF0FF) | 0x0600);
>         -       bcm43xx_phy_write(dev, 0x04A2,
>         -                         (bcm43xx_phy_read(dev, 0x04A2)
>         -                          & 0xF0FF) | 0x0700);
>         -       bcm43xx_phy_write(dev, 0x04A0,
>         -                         (bcm43xx_phy_read(dev, 0x04A0)
>         -                          & 0xF0FF) | 0x0100);
>         -
>         -       if (phy->rev == 1) {
>         -               bcm43xx_phy_write(dev, 0x04A2,
>         -                                 (bcm43xx_phy_read(dev, 0x04A2)
>         -                                  & 0xFFF0) | 0x0007);
>         -       }
>         -
>         -       bcm43xx_phy_write(dev, 0x0488,
>         -                         (bcm43xx_phy_read(dev, 0x0488)
>         -                          & 0xFF00) | 0x001C);
>         -       bcm43xx_phy_write(dev, 0x0488,
>         -                         (bcm43xx_phy_read(dev, 0x0488)
>         -                          & 0xC0FF) | 0x0200);
>         -       bcm43xx_phy_write(dev, 0x0496,
>         -                         (bcm43xx_phy_read(dev, 0x0496)
>         -                          & 0xFF00) | 0x001C);
>         -       bcm43xx_phy_write(dev, 0x0489,
>         -                         (bcm43xx_phy_read(dev, 0x0489)
>         -                          & 0xFF00) | 0x0020);
>         -       bcm43xx_phy_write(dev, 0x0489,
>         -                         (bcm43xx_phy_read(dev, 0x0489)
>         -                          & 0xC0FF) | 0x0200);
>         -       bcm43xx_phy_write(dev, 0x0482,
>         -                         (bcm43xx_phy_read(dev, 0x0482)
>         -                          & 0xFF00) | 0x002E);
>         -       bcm43xx_phy_write(dev, 0x0496,
>         -                         (bcm43xx_phy_read(dev, 0x0496)
>         -                          & 0x00FF) | 0x1A00);
>         -       bcm43xx_phy_write(dev, 0x0481,
>         -                         (bcm43xx_phy_read(dev, 0x0481)
>         -                          & 0xFF00) | 0x0028);
>         -       bcm43xx_phy_write(dev, 0x0481,
>         -                         (bcm43xx_phy_read(dev, 0x0481)
>         -                          & 0x00FF) | 0x2C00);
>         -
>         -       if (phy->rev == 1) {
>         -               bcm43xx_phy_write(dev, 0x0430, 0x092B);
>         -               bcm43xx_phy_write(dev, 0x041B,
>         -                                 (bcm43xx_phy_read(dev, 0x041B)
>         -                                  & 0xFFE1) | 0x0002);
>         -       } else {
>         -               bcm43xx_phy_write(dev, 0x041B,
>         -                                 bcm43xx_phy_read(dev, 0x041B)
>         -                                 & 0xFFE1);
>         -               bcm43xx_phy_write(dev, 0x041F, 0x287A);
>         -               bcm43xx_phy_write(dev, 0x0420,
>         -                                 (bcm43xx_phy_read(dev, 0x0420)
>         -                                  & 0xFFF0) | 0x0004);
>         -       }
>         -
>         -       if (phy->rev >= 6) {
>         -               bcm43xx_phy_write(dev, 0x0422, 0x287A);
>         -               bcm43xx_phy_write(dev, 0x0420,
>         -                                 (bcm43xx_phy_read(dev, 0x0420)
>         -                                  & 0x0FFF) | 0x3000);
>         -       }
>         -
>         -       bcm43xx_phy_write(dev, 0x04A8,
>         -                         (bcm43xx_phy_read(dev, 0x04A8)
>         -                          & 0x8080) | 0x7874);
>         -       bcm43xx_phy_write(dev, 0x048E, 0x1C00);
>         -
>         -       offset = 0x0800;
>         -       if (phy->rev == 1) {
>         -               offset = 0x5400;
>         -               bcm43xx_phy_write(dev, 0x04AB,
>         -                                 (bcm43xx_phy_read(dev, 0x04AB)
>         -                                  & 0xF0FF) | 0x0600);
>         -               bcm43xx_phy_write(dev, 0x048B, 0x005E);
>         -               bcm43xx_phy_write(dev, 0x048C,
>         -                                 (bcm43xx_phy_read(dev, 0x048C)
>         -                                  & 0xFF00) | 0x001E);
>         -               bcm43xx_phy_write(dev, 0x048D, 0x0002);
>         -       }
>         -       bcm43xx_ofdmtab_write16(dev, offset, 0, 0x00);
>         -       bcm43xx_ofdmtab_write16(dev, offset, 1, 0x07);
>         -       bcm43xx_ofdmtab_write16(dev, offset, 2, 0x10);
>         -       bcm43xx_ofdmtab_write16(dev, offset, 3, 0x1C);
>         -
>         -       if (phy->rev >= 6) {
>         -               bcm43xx_phy_write(dev, 0x0426,
>         -                                 bcm43xx_phy_read(dev, 0x0426)
>         -                                 & 0xFFFC);
>         -               bcm43xx_phy_write(dev, 0x0426,
>         -                                 bcm43xx_phy_read(dev, 0x0426)
>         -                                 & 0xEFFF);
>         -       }
>         -}
>         -
>         -static void bcm43xx_phy_setupg(struct bcm43xx_wldev *dev)
>         -{
>         -       struct ssb_bus *bus = dev->dev->bus;
>         -       struct bcm43xx_phy *phy = &dev->phy;
>         -       u16 i;
>         -
>         -       assert(phy->type == BCM43xx_PHYTYPE_G);
>         -       if (phy->rev == 1) {
>         -               bcm43xx_phy_write(dev, 0x0406, 0x4F19);
>         -               bcm43xx_phy_write(dev, BCM43xx_PHY_G_CRS,
>         -                                 (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_G_CRS) & 0xFC3F) | 0x0340);
>         -               bcm43xx_phy_write(dev, 0x042C, 0x005A);
>         -               bcm43xx_phy_write(dev, 0x0427, 0x001A);
>         -
>         -               for (i = 0; i < BCM43xx_TAB_FINEFREQG_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x5800,
>         i, bcm43xx_tab_finefreqg[i]);
>         -               for (i = 0; i < BCM43xx_TAB_NOISEG1_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1800,
>         i, bcm43xx_tab_noiseg1[i]);
>         -               for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x2000,
>         i, bcm43xx_tab_rotor[i]);
>         -       } else {
>         -               /* nrssi values are signed 6-bit values. Not
>         sure why we write 0x7654 here... */
>         -               bcm43xx_nrssi_hw_write(dev, 0xBA98, (s16)0x7654);
>         -
>         -               if (phy->rev == 2) {
>         -                       bcm43xx_phy_write(dev, 0x04C0, 0x1861);
>         -                       bcm43xx_phy_write(dev, 0x04C1, 0x0271);
>         -               } else if (phy->rev > 2) {
>         -                       bcm43xx_phy_write(dev, 0x04C0, 0x0098);
>         -                       bcm43xx_phy_write(dev, 0x04C1, 0x0070);
>         -                       bcm43xx_phy_write(dev, 0x04C9, 0x0080);
>         -               }
>         -               bcm43xx_phy_write(dev, 0x042B,
>         bcm43xx_phy_read(dev, 0x042B) | 0x800);
>         -
>         -               for (i = 0; i < 64; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x4000,
>         i, i);
>         -               for (i = 0; i < BCM43xx_TAB_NOISEG2_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1800,
>         i, bcm43xx_tab_noiseg2[i]);
>         -       }
>         -
>         -       if (phy->rev <= 2)
>         -               for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1400,
>         i, bcm43xx_tab_noisescaleg1[i]);
>         -       else if ((phy->rev >= 7) && (bcm43xx_phy_read(dev,
>         0x0449) & 0x0200))
>         -               for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE;
>         i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1400,
>         i, bcm43xx_tab_noisescaleg3[i]);
>         -       else
>         -               for (i = 0; i < BCM43xx_TAB_NOISESCALEG_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1400,
>         i, bcm43xx_tab_noisescaleg2[i]);
>         -
>         -       if (phy->rev == 2)
>         -               for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x5000,
>         i, bcm43xx_tab_sigmasqr1[i]);
>         -       else if ((phy->rev > 2) && (phy->rev <= 8))
>         -               for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x5000,
>         i, bcm43xx_tab_sigmasqr2[i]);
>         -
>         -       if (phy->rev == 1) {
>         -               for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write32(dev, 0x2400,
>         i, bcm43xx_tab_retard[i]);
>         -               for (i = 0; i < 4; i++) {
>         -                       bcm43xx_ofdmtab_write16(dev, 0x5404,
>         i, 0x0020);
>         -                       bcm43xx_ofdmtab_write16(dev, 0x5408,
>         i, 0x0020);
>         -                       bcm43xx_ofdmtab_write16(dev, 0x540C,
>         i, 0x0020);
>         -                       bcm43xx_ofdmtab_write16(dev, 0x5410,
>         i, 0x0020);
>         -               }
>         -               bcm43xx_phy_agcsetup(dev);
>         -
>         -               if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
>         -                   (bus->board_type == SSB_BOARD_BU4306) &&
>         -                   (bus->board_rev == 0x17))
>         -                       return;
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x5001, 0, 0x0002);
>         -               bcm43xx_ofdmtab_write16(dev, 0x5002, 0, 0x0001);
>         -       } else {
>         -               for (i = 0; i <= 0x2F; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1000,
>         i, 0x0820);
>         -               bcm43xx_phy_agcsetup(dev);
>         -               bcm43xx_phy_read(dev, 0x0400); /* dummy read */
>         -               bcm43xx_phy_write(dev, 0x0403, 0x1000);
>         -               bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
>         -               bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
>         -
>         -               if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
>         -                   (bus->board_type == SSB_BOARD_BU4306) &&
>         -                   (bus->board_rev == 0x17))
>         -                       return;
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x0401, 0, 0x0002);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0402, 0, 0x0001);
>         -       }
>         -}
>         -
>         -/* Initialize the noisescaletable for APHY */
>         -static void bcm43xx_phy_init_noisescaletbl(struct
>         bcm43xx_wldev *dev)
>         -{
>         -       struct bcm43xx_phy *phy = &dev->phy;
>                 int i;
>
>         -       for (i = 0; i < 12; i++) {
>         -               if (phy->rev == 2)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1400,
>         i, 0x6767);
>         +       if (dev->phy.rev < 3) {
>         +               if (enable)
>         +                       for (i = 0; i <
>         BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
>         +                               bcm43xx_ofdmtab_write16(dev,
>         +                                      
>         BCM43xx_OFDMTAB_LNAHPFGAIN1, i, 0xFFF8);
>         +                               bcm43xx_ofdmtab_write16(dev,
>         +                                       BCM43xx_OFDMTAB_WRSSI,
>         i, 0xFFF8);
>         +                       }
>                         else
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1400,
>         i, 0x2323);
>         -       }
>         -       if (phy->rev == 2)
>         -               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x6700);
>         -       else
>         -               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x2300);
>         -       for (i = 0; i < 11; i++) {
>         -               if (phy->rev == 2)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1400,
>         i, 0x6767);
>         +                       for (i = 0; i <
>         BCM43xx_TAB_RSSIAGC1_SIZE; i++) {
>         +                               bcm43xx_ofdmtab_write16(dev,
>         +                                      
>         BCM43xx_OFDMTAB_LNAHPFGAIN1, i, bcm43xx_tab_rssiagc1[i]);
>         +                               bcm43xx_ofdmtab_write16(dev,
>         +                                       BCM43xx_OFDMTAB_WRSSI,
>         i, bcm43xx_tab_rssiagc1[i]);
>         +                       }
>         +       } else {
>         +               if (enable)
>         +                       for (i = 0; i <
>         BCM43xx_TAB_RSSIAGC1_SIZE; i++)
>         +                               bcm43xx_ofdmtab_write16(dev,
>         +                                       BCM43xx_OFDMTAB_WRSSI,
>         i, 0x0820);
>                         else
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1400,
>         i, 0x2323);
>         +                       for (i = 0; i <
>         BCM43xx_TAB_RSSIAGC2_SIZE; i++)
>         +                               bcm43xx_ofdmtab_write16(dev,
>         +                                       BCM43xx_OFDMTAB_WRSSI,
>         i, bcm43xx_tab_rssiagc2[i]);
>                 }
>         -       if (phy->rev == 2)
>         -               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0067);
>         -       else
>         -               bcm43xx_ofdmtab_write16(dev, 0x1400, i, 0x0023);
>         }
>
>         -static void bcm43xx_phy_setupa(struct bcm43xx_wldev *dev)
>         +static void bcm43xx_phy_ww(struct bcm43xx_wldev *dev)
>         {
>         -       struct bcm43xx_phy *phy = &dev->phy;
>         -       u16 i;
>         -
>         -       assert(phy->type == BCM43xx_PHYTYPE_A);
>         -       switch (phy->rev) {
>         -       case 2:
>         -               bcm43xx_phy_write(dev, 0x008E, 0x3800);
>         -               bcm43xx_phy_write(dev, 0x0035, 0x03FF);
>         -               bcm43xx_phy_write(dev, 0x0036, 0x0400);
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
>         -
>         -               bcm43xx_phy_write(dev, 0x001C, 0x0FF9);
>         -               bcm43xx_phy_write(dev, 0x0020,
>         bcm43xx_phy_read(dev, 0x0020) & 0xFF0F);
>         -               bcm43xx_ofdmtab_write16(dev, 0x3C0C, 0, 0x07BF);
>         -               bcm43xx_radio_write16(dev, 0x0002, 0x07BF);
>         -
>         -               bcm43xx_phy_write(dev, 0x0024, 0x4680);
>         -               bcm43xx_phy_write(dev, 0x0020, 0x0003);
>         -               bcm43xx_phy_write(dev, 0x001D, 0x0F40);
>         -               bcm43xx_phy_write(dev, 0x001F, 0x1C00);
>         -
>         -               bcm43xx_phy_write(dev, 0x002A,
>         -                                 (bcm43xx_phy_read(dev, 0x002A)
>         -                                  & 0x00FF) | 0x0400);
>         -               bcm43xx_phy_write(dev, 0x002B,
>         -                                 bcm43xx_phy_read(dev, 0x002B)
>         -                                 & 0xFBFF);
>         -               bcm43xx_phy_write(dev, 0x008E, 0x58C1);
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0000, 1, 0x0013);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0000, 2, 0x0013);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0000, 3, 0x0013);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0000, 4, 0x0015);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0000, 5, 0x0015);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0000, 6, 0x0019);
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
>         -
>         -               for (i = 0; i < 16; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x4000,
>         i, (0x8 + i) & 0x000F);
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x3003, 0, 0x1044);
>         -               bcm43xx_ofdmtab_write16(dev, 0x3004, 0, 0x7201);
>         -               bcm43xx_ofdmtab_write16(dev, 0x3006, 0, 0x0040);
>         -               bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
>         (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0x0010) | 0x0008);
>         -
>         -               for (i = 0; i < BCM43xx_TAB_FINEFREQA_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x5800,
>         i, bcm43xx_tab_finefreqa[i]);
>         -               for (i = 0; i < BCM43xx_TAB_NOISEA2_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1800,
>         i, bcm43xx_tab_noisea2[i]);
>         -               for (i = 0; i < BCM43xx_TAB_ROTOR_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write32(dev, 0x2000,
>         i, bcm43xx_tab_rotor[i]);
>         -               bcm43xx_phy_init_noisescaletbl(dev);
>         -               for (i = 0; i < BCM43xx_TAB_RETARD_SIZE; i++)
>         -                       bcm43xx_ofdmtab_write32(dev, 0x2400,
>         i, bcm43xx_tab_retard[i]);
>         -               break;
>         -       case 3:
>         -               for (i = 0; i < 64; i++)
>         -                       bcm43xx_ofdmtab_write16(dev, 0x4000,
>         i, i);
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x3807, 0, 0x0051);
>         -
>         -               bcm43xx_phy_write(dev, 0x001C, 0x0FF9);
>         -               bcm43xx_phy_write(dev, 0x0020,
>         -                                 bcm43xx_phy_read(dev,
>         0x0020) & 0xFF0F);
>         -               bcm43xx_radio_write16(dev, 0x0002, 0x07BF);
>         -
>         -               bcm43xx_phy_write(dev, 0x0024, 0x4680);
>         -               bcm43xx_phy_write(dev, 0x0020, 0x0003);
>         -               bcm43xx_phy_write(dev, 0x001D, 0x0F40);
>         -               bcm43xx_phy_write(dev, 0x001F, 0x1C00);
>         -               bcm43xx_phy_write(dev, 0x002A,
>         -                                 (bcm43xx_phy_read(dev, 0x002A)
>         -                                  & 0x00FF) | 0x0400);
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x3000, 1,
>         -                                      
>         (bcm43xx_ofdmtab_read16(dev, 0x3000, 1)
>         -                                       & 0x0010) | 0x0008);
>         -               for (i = 0; i < BCM43xx_TAB_NOISEA3_SIZE; i++) {
>         -                       bcm43xx_ofdmtab_write16(dev, 0x1800, i,
>         -                                              
>         bcm43xx_tab_noisea3[i]);
>         -               }
>         -               bcm43xx_phy_init_noisescaletbl(dev);
>         -               for (i = 0; i < BCM43xx_TAB_SIGMASQR_SIZE; i++) {
>         -                       bcm43xx_ofdmtab_write16(dev, 0x5000, i,
>         -                                              
>         bcm43xx_tab_sigmasqr1[i]);
>         -               }
>         -
>         -               bcm43xx_phy_write(dev, 0x0003, 0x1808);
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x0803, 0, 0x000F);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0804, 0, 0x001F);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x002A);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0805, 0, 0x0030);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0807, 0, 0x003A);
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x0000, 0, 0x0013);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0001, 0, 0x0013);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0002, 0, 0x0013);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0003, 0, 0x0013);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0004, 0, 0x0015);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0005, 0, 0x0015);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0006, 0, 0x0019);
>         -
>         -               bcm43xx_ofdmtab_write16(dev, 0x0404, 0, 0x0003);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0405, 0, 0x0003);
>         -               bcm43xx_ofdmtab_write16(dev, 0x0406, 0, 0x0007);
>         +       u16 b, curr_s, best_s = 0xFFFF;
>         +       int i;
>
>         -               bcm43xx_ofdmtab_write16(dev, 0x3C02, 0, 0x000F);
>         -               bcm43xx_ofdmtab_write16(dev, 0x3C03, 0, 0x0014);
>         -               break;
>         -       default:
>         -               assert(0);
>         -       }
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
>         +               bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) &
>         ~BCM43xx_PHY_CRS0_EN);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x1B),
>         +               bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x1B))
>         | 0x1000);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x82),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x82))
>         & 0xF0FF) | 0x0300);
>         +       bcm43xx_radio_write16(dev, 0x0009,
>         +               bcm43xx_radio_read16(dev, 0x0009) | 0x0080);
>         +       bcm43xx_radio_write16(dev, 0x0012,
>         +               (bcm43xx_radio_read16(dev, 0x0012) & 0xFFFC) |
>         0x0002);
>         +       bcm43xx_wa_initgains(dev);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBA), 0x3ED5);
>         +       b = bcm43xx_phy_read(dev, BCM43xx_PHY_PWRDOWN);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, (b &
>         0xFFF8) | 0x0005);
>         +       bcm43xx_radio_write16(dev, 0x0004,
>         +               bcm43xx_radio_read16(dev, 0x0004) | 0x0004);
>         +       for (i = 0x10; i <= 0x20; i++) {
>         +               bcm43xx_radio_write16(dev, 0x0013, i);
>         +               curr_s = bcm43xx_phy_read(dev,
>         BCM43xx_PHY_OTABLEQ) & 0x00FF;
>         +               if (!curr_s) {
>         +                       best_s = 0x0000;
>         +                       break;
>         +               } else if (curr_s >= 0x0080)
>         +                       curr_s = 0x0100 - curr_s;
>         +               if (curr_s < best_s)
>         +                       best_s = curr_s;
>         +       }
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_PWRDOWN, b);
>         +       bcm43xx_radio_write16(dev, 0x0004,
>         +               bcm43xx_radio_read16(dev, 0x0004) & 0xFFFB);
>         +       bcm43xx_radio_write16(dev, 0x0013, best_s);
>         +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1_R1,
>         0, 0xFFEC);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB7), 0x1E80);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB6), 0x1C00);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB5), 0x0EC0);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB2), 0x00C0);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xB9), 0x1FFF);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0xBB),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0xBB))
>         & 0xF000) | 0x0053);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM61,
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM61 &
>         0xFE1F)) | 0x0120);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x13),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x13))
>         & 0x0FFF) | 0x3000);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x14),
>         +               (bcm43xx_phy_read(dev, BCM43xx_PHY_OFDM(0x14))
>         & 0x0FFF) | 0x3000);
>         +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1, 6,
>         0x0017);
>         +       for (i = 0; i < 6; i++)
>         +               bcm43xx_ofdmtab_write16(dev,
>         BCM43xx_OFDMTAB_AGC1, i, 0x000F);
>         +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1,
>         0x0D, 0x000E);
>         +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1,
>         0x0E, 0x0011);
>         +       bcm43xx_ofdmtab_write16(dev, BCM43xx_OFDMTAB_AGC1,
>         0x0F, 0x0013);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x33), 0x5030);
>         +       bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
>         +               bcm43xx_phy_read(dev, BCM43xx_PHY_CRS0) |
>         BCM43xx_PHY_CRS0_EN);
>         }
>
>         /* Initialize APHY. This is also called for the GPHY in some
>         cases. */
>         @@ -953,60 +657,52 @@ static void bcm43xx_phy_inita(struct bcm
>         {
>                 struct ssb_bus *bus = dev->dev->bus;
>                 struct bcm43xx_phy *phy = &dev->phy;
>         -       u16 tval;
>
>         -       if (phy->type == BCM43xx_PHYTYPE_A) {
>         -               bcm43xx_phy_setupa(dev);
>         -       } else {
>         -               bcm43xx_phy_setupg(dev);
>         -               if (phy->gmode &&
>         -                   (dev->dev->bus->sprom.r1.boardflags_lo &
>         BCM43xx_BFL_PACTRL))
>         -                       bcm43xx_phy_write(dev, 0x046E, 0x03CF);
>         -               return;
>         +       if (phy->rev >= 6) {
>         +               if (phy->type == BCM43xx_PHYTYPE_A)
>         +                       bcm43xx_phy_write(dev,
>         BCM43xx_PHY_OFDM(0x1B),
>         +                               bcm43xx_phy_read(dev,
>         BCM43xx_PHY_OFDM(0x1B)) & ~0x1000);
>         +               if (bcm43xx_phy_read(dev, BCM43xx_PHY_ENCORE)
>         & BCM43xx_PHY_ENCORE_EN)
>         +                       bcm43xx_phy_write(dev, BCM43xx_PHY_ENCORE,
>         +                               bcm43xx_phy_read(dev,
>         BCM43xx_PHY_ENCORE) | 0x0010);
>         +               else
>         +                       bcm43xx_phy_write(dev,
>         BCM43xx_PHY_ENCORE,
>         +                               bcm43xx_phy_read(dev,
>         BCM43xx_PHY_ENCORE) & ~0x1010);
>                 }
>         +       bcm43xx_wa_all(dev);
>
>         -       bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
>         -                         (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_A_CRS) & 0xF83C) | 0x0340);
>         -       bcm43xx_phy_write(dev, 0x0034, 0x0001);
>         -
>         -       TODO();//TODO: RSSI AGC
>         -       bcm43xx_phy_write(dev, BCM43xx_PHY_A_CRS,
>         -                         bcm43xx_phy_read(dev,
>         BCM43xx_PHY_A_CRS) | (1 << 14));
>         -       bcm43xx_radio_init2060(dev);
>         +       if (phy->type == BCM43xx_PHYTYPE_A) {
>         +               if (phy->gmode &&
>         +                   (phy->rev < 3))
>         +                       bcm43xx_phy_write(dev, 0x0034,
>         +                               bcm43xx_phy_read(dev, 0x0034)
>         | 0x0001);
>
>         -       if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
>         -           ((bus->board_type == SSB_BOARD_BU4306) ||
>         -            (bus->board_type == SSB_BOARD_BU4309))) {
>         -               if (phy->lofcal == 0xFFFF) {
>         -                       TODO();//TODO: LOF Cal
>         -                       bcm43xx_radio_set_tx_iq(dev);
>         -               } else
>         -                       bcm43xx_radio_write16(dev, 0x001E,
>         phy->lofcal);
>         -       }
>         +               bcm43xx_phy_rssiagc(dev, 0);
>
>         -       bcm43xx_phy_write(dev, 0x007A, 0xF111);
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_CRS0,
>         +                       bcm43xx_phy_read(dev,
>         BCM43xx_PHY_CRS0) | BCM43xx_PHY_CRS0_EN);
>
>         -       if (phy->cur_idle_tssi == 0) {
>         -               bcm43xx_radio_write16(dev, 0x0019, 0x0000);
>         -               bcm43xx_radio_write16(dev, 0x0017, 0x0020);
>         +               bcm43xx_radio_init2060(dev);
>
>         -               tval = bcm43xx_ofdmtab_read16(dev, 0x3001, 0);
>         -               if (phy->rev == 1) {
>         -                       bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
>         -                                        
>         (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0xFF87)
>         -                                         | 0x0058);
>         -               } else {
>         -                       bcm43xx_ofdmtab_write16(dev, 0x3001, 0,
>         -                                        
>         (bcm43xx_ofdmtab_read16(dev, 0x3001, 0) & 0xFFC3)
>         -                                         | 0x002C);
>         +               if ((bus->board_vendor == SSB_BOARDVENDOR_BCM) &&
>         +                   ((bus->board_type == SSB_BOARD_BU4306) ||
>         +                    (bus->board_type == SSB_BOARD_BU4309))) {
>         +                       ; //TODO: A PHY LO
>                         }
>         -               bcm43xx_dummy_transmission(dev);
>         -               phy->cur_idle_tssi = bcm43xx_phy_read(dev,
>         BCM43xx_PHY_A_PCTL);
>         -               bcm43xx_ofdmtab_write16(dev, 0x3001, 0, tval);
>
>         -               bcm43xx_radio_set_txpower_a(dev, 0x0018);
>         +               if (phy->rev >= 3)
>         +                       bcm43xx_phy_ww(dev);
>         +
>         +               hardware_pctl_init_aphy(dev);
>         +
>         +               //TODO: radar detection
>         +       }
>         +       if ((phy->type == BCM43xx_PHYTYPE_G) &&
>         +           (dev->dev->bus->sprom.r1.boardflags_lo &
>         BCM43xx_BFL_PACTRL)) {
>         +               bcm43xx_phy_write(dev, BCM43xx_PHY_OFDM(0x6E),
>         +                                 (bcm43xx_phy_read(dev,
>         BCM43xx_PHY_OFDM(0x6E))
>         +                                  & 0xE000) | 0x3CF);
>                 }
>         -       bcm43xx_shm_clear_tssi(dev);
>         }
>
>         static void bcm43xx_phy_initb2(struct bcm43xx_wldev *dev)
>         Index:
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile
>         ===================================================================
>         ---
>         bu3sch-wireless-dev.orig/drivers/net/wireless/mac80211/bcm43xx/Makefile    
>         2007-05-12 16:27: 31.000000000 +0200
>         +++
>         bu3sch-wireless-dev/drivers/net/wireless/mac80211/bcm43xx/Makefile  2007-05-12
>         16:29:05.000000000 +0200
>         @@ -15,4 +15,5 @@ bcm43xx-mac80211-objs := bcm43xx_main.o
>                                  bcm43xx_leds.o \
>                                  bcm43xx_xmit.o \
>                                  bcm43xx_lo.o \
>         +                        bcm43xx_wa.o \
>                                  $(bcm43xx-mac80211-obj-y)
>
>
>         --
>         Greetings Michael.
>         _______________________________________________
>
This is with my 4318 so your are making progress, hopefully soon you
will have it and we can be done with softmac and v3 firmware which has
many known bugs even in the windows community.

bcm43xx_mac80211: Adding Interface type 2
bcm43xx_mac80211: Found PHY: Analog 3, Type 2, Revision 7
bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 8
ssb: Switching to PCI core, index 2
ssb: Switching to IEEE 802.11 core, index 1
bcm43xx_mac80211: Loading firmware version 351.126 (2006-07-29 05:54:02)
ssb: Switching to ChipCommon core, index 0
ssb: Switching to IEEE 802.11 core, index 1
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: !WARNING! Idle-TSSI phy->cur_idle_tssi measuring
failed. (cur=0, tgt=62). Disabling TX power adjustment.
bcm43xx_mac80211: Chip initialized
bcm43xx_mac80211: 32-bit DMA initialized
bcm43xx_mac80211: Wireless interface started
bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac:
ff:ff:ff:ff:ff:ff
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:18:4d:8d:70:08
wlan0: RX authentication from 00:18:4d:8d:70:08 (alg=0 transaction=2
status=0)
wlan0: authenticated
wlan0: associate with AP 00:18:4d:8d:70:08
wlan0: RX AssocResp from 00:18:4d:8d:70:08 (capab=0x411 status=0 aid=1)
wlan0: associated
bcm43xx_mac80211: Removing Interface type 2
bcm43xx_mac80211: Wireless interface stopped
bcm43xx_mac80211: DMA-32 0x0200 (RX) max used slots: 1/64
bcm43xx_mac80211: DMA-32 0x02A0 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0280 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0260 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0240 (TX) max used slots: 0/128
bcm43xx_mac80211: DMA-32 0x0220 (TX) max used slots: 22/128
bcm43xx_mac80211: DMA-32 0x0200 (TX) max used slots: 0/128
bcm43xx_mac80211: Radio turned off
ssb: Switching to ChipCommon core, index 0
ssb: Switching to IEEE 802.11 core, index 1
bcm43xx_mac80211: Radio turned off

Great work and keep it moving forward as always.

-Jory


From mb at bu3sch.de  Wed May 16 14:51:48 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 16 May 2007 14:51:48 +0200
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <464A760B.1090907@gmail.com>
References: <25658.26952.qm@web61016.mail.yahoo.com>
	<464A760B.1090907@gmail.com>
Message-ID: <200705161451.49114.mb@bu3sch.de>

On Wednesday 16 May 2007 05:10:03 Jory A. Pratt wrote:
> will have it and we can be done with softmac and v3 firmware which has
> many known bugs even in the windows community.

For example?

-- 
Greetings Michael.


From guillaume.yziquel at free.fr  Wed May 16 22:01:42 2007
From: guillaume.yziquel at free.fr (Guillaume Yziquel)
Date: Wed, 16 May 2007 22:01:42 +0200
Subject: Master Mode.
In-Reply-To: <20070512130315.23837f12@conroe.oakcourt.dyndns.org>
References: <4645E580.3020002@free.fr>
	<20070512130315.23837f12@conroe.oakcourt.dyndns.org>
Message-ID: <464B6326.6080300@free.fr>

Andrew J. Barr a ?crit :
> > On Sat, 12 May 2007 18:04:16 +0200
> > Guillaume Yziquel <guillaume.yziquel at free.fr> wrote:
> >
>> >> I would like to know if it was possible to get my BCM4310 wifi
>> >> card to work in Master Mode. I understood this mode was not
>> >> supported, but I'd like to know why (which I haven't been able to
>> >> find on the Internet).
> >
> > It is supported by the mac80211 version of the driver, I believe.

Thank you, Andrew and Johannes, for your answers.

I'm afraid it is not precisely to which I should be asking my enquiries,
since it's called bcm43xx-dev@ and not bcm43xx-users at . Nevertheless, my
repeated unsuccessful attempts at getting this done pushed me to ask you
for more help.

I'm using a Debian Etch on a 2.6.18-4-amd64 linux kernel, on my laptop.
I've been following instructions on

	http://intellinuxwireless.org/?p=mac80211&n=HOWTO-mac80211

in the hope of keeping my first kernel compiling experience as little
painful as possible.

I now get the following message:

>> seldon:/home/yziquel/src/mac80211-7.0.10# make
>> Building modified version in 'modified/' directory:
>> Copying modified/ from origin/...done
>> Applying patches and scripts from pending/.
>>  + Applying: pending/09-range-name-rate.patch
>>         Add WE range, name and rate capabilities
>>  + Applying: pending/10-txpower.patch
>>         Fix user specified TXPOWER from being overridden by stack.
>>  + Applying: pending/20-wireless-dev-qos.patch
>>         This is revised QoS patch target to replace the 20 and 21 pending
>>  + Applying: pending/30-Fix-ieee80211_sta_config_auth-to-select-networks-if.patc h
>>         From c0485efc42bfde16590f25eb8a4d77ee48ccad9d Mon Sep 17 00:00:00 2001
>>  + Applying: pending/30-fixup-giwrate.patch
>>         Fix SIOGIWRATE so it actually returns the most recent rate *or* highest
>>  + Applying: pending/40-export_ieee80211_init_rate_ctrl_alg.patch
>>         diff --git a/origin/net/mac80211/ieee80211.c b/origin/net/mac80211/ieee8 0211.c
>> -----patch failure output-----
>> can't find file to patch at input line 5
>> Perhaps you used the wrong -p or --strip option?
>> The text leading up to this was:
>> --------------------------
>> |diff --git a/origin/net/mac80211/ieee80211.c b/origin/net/mac80211/ieee80211.c
>> |index b5a62b7..0196bba 100644
>> |--- a/origin/net/mac80211/ieee80211.c
>> |+++ b/origin/net/mac80211/ieee80211.c
>> --------------------------
>> File to patch:
>> Skip this patch? [y]
>> Skipping patch.
>> 1 out of 1 hunk ignored
>> 
>> pending/40-export_ieee80211_init_rate_ctrl_alg.patch failed. Terminating.
>> If patch or script failed, check pre/ and post/ for current stage.
>> make: *** [modified] Erreur 1

Any help, or suggestions of things to read, would be highly appreciated.

Sincerely yours,

Guillaume Yziquel.




From news at tecnicaict.com  Wed May 16 23:48:18 2007
From: news at tecnicaict.com (tICT)
Date: Wed, 16 May 2007 23:48:18 +0200
Subject: SNR, Power output
In-Reply-To: <mailman.7853.1179285186.5173.bcm43xx-dev@lists.berlios.de>
References: <mailman.7853.1179285186.5173.bcm43xx-dev@lists.berlios.de>
Message-ID: <464B7C22.2030908@tecnicaict.com>

Hi, I'm a Dell Wireless 1390 user (chipset 4311) and I notice a very low 
output power compared to wrapped drivers.

Link is unstable if I'm not near the AP and, as I can read on my router 
status page, SNR is between 15-20dB (low).

# iwconfig  writes Tx-Power=18 dBm.

2.6.20.9 vanilla kernel patched with Larry's combined_2.6.20.7.patch 
<ftp://lwfinger.dynalias.org/patches/combined_2.6.20.7.patch>

Thanks, best regards
PS: sorry for my english


From larry.finger at lwfinger.net  Thu May 17 01:08:39 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 16 May 2007 18:08:39 -0500
Subject: SNR, Power output
In-Reply-To: <464B7C22.2030908@tecnicaict.com>
References: <mailman.7853.1179285186.5173.bcm43xx-dev@lists.berlios.de>
	<464B7C22.2030908@tecnicaict.com>
Message-ID: <464B8EF7.3010807@lwfinger.net>

tICT wrote:
> Hi, I'm a Dell Wireless 1390 user (chipset 4311) and I notice a very low 
> output power compared to wrapped drivers.
> 
> Link is unstable if I'm not near the AP and, as I can read on my router 
> status page, SNR is between 15-20dB (low).
> 
> # iwconfig  writes Tx-Power=18 dBm.
> 
> 2.6.20.9 vanilla kernel patched with Larry's combined_2.6.20.7.patch 
> <ftp://lwfinger.dynalias.org/patches/combined_2.6.20.7.patch>

This is a known problem. If you can suggest any fixes, we would be happy to entertain them.

Larry


From kbb at texascellnet.com  Thu May 17 19:49:46 2007
From: kbb at texascellnet.com (kbb at texascellnet.com)
Date: Thu, 17 May 2007 12:49:46 -0500 (CDT)
Subject: newbie questions
Message-ID: <46361.143.116.116.200.1179424186.squirrel@webmail.texascellnet.com>

I have been tasked with bringing up a CF card on petalinux.  This project
has no PCI/PCMCIA bus and the CF bus is a massaged store bought core. I am
using 2.4.32 w/ no MMU.


I basically have 3 address spaces for the CF card:
Memory access
I/O access
Attribute access


After RTFM of the documents page I now have enough intelligence to ask
some semi intelligent questions; so here it goes!

I can see the the CIS area under the attribute space and it is:
0001 0002 0000 00FF 001C 0004 0003 00D9
0001 00FF 001D 0004 0003 00D9 0001 00FF
0015 001E 0008 0000 0000 0000 0000 0000
0069 0000 00000000 0000 0000 0000 0000
002E 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 00FF
0020 0004 00D0 0002 0048 0004 0080 0005
0001 00E4 0014 0018 0043 0080 0002 0002
0040 0022 0008 0004 0006 0000 0017 0023
0000 008E 0011 0021 0002 0006 0000 0022
0002 0001 0007 0022 0005 0002 0040 0042
000F 0000 0022 0005 0002 0080 0084 001E
0000 0022 0005 0002 0060 00EC 0053 0000
0022 0005 0002 00C0 00D8 00A7 0000 0022
0005 0002 0080 008D 005B 0000 0022 0005
0002 0040 0054 0089 0000 0022 0005 0002
0000 001B 00B7 0000 0022 0005 0002 0080
00A8 0012 0001 0022 0005 0002 0000 0036
006E 0001 0022 0005 0002 0000 0051 0025
0002 0022 0005 0002 0000 006C 00DC 0002
0022 0005 0002 0080 00F9 0037 0003 0022
0002 0003 0007 0022 0002 0005 0001 001A
0005 0001 0001 0000 0007 000B 001B 0008
00C1 0001 0030 00B0 00FF 00FF 0008 0000
0080 0009 0003 0002 0015 00D4 00FA 00C8
00FE 003E 0052 0080 0002 0005 0000 0080
0002 0006 0003 0080 0002 0007 0000 0080
0003 0008 0048 0070 0080 0005 0009 00FF
00FF 00FF 00FF 0080 0009 0004 0000 0000
0000 0000 0000 0000 0000 0000 00FF 00FF
00FF 00FF 00FF 00FF 00FF 00FF 00FF 00FF
00FF 00FF 00FF 00FF 00FF 00FF 00FF 00FF

The dump of the memory space is as follows:

0000: 4318 0422 0009 0064 0000 0000 0000 0000
0010: 0000 0000 2028 2000 0000 0000 0000 0000
0020: 0000 0000 0000 0000 0000 0000 0000 0000
0030: 0000 0000 0000 0000 0000 0000 0000 0000
0040: 0000 0000 0000 0000 0000 0000 0000 0000
0050: 0000 0000 0000 0000 0000 0000 0000 0000
0060: 00CF 0000 0000 0000 0000 0000 0000 0000
0070: 0000 0000 0000 0000 00CF 0000 0000 0000
0080: 0000 0000 0000 0000 0000 0000 0000 0000
0090: 0000 0000 0000 0000 0000 0000 0000 0000
00A0: 0000 0000 0830 0008 0830 0008 0830 0008
00B0: 0000 0000 0000 0000 0000 0000 0000 0000
00C0: 0003 0000 00C8 00C8 00C8 00C8 00C8 00C8
00D0: 00C8 00C8 00C8 00C8 00C8 00C8 00C8 00C8
00E0: 00C8 00C8 00C8 00C8 00C8 00C8 00C8 00C8
00F0: 00C8 00C8 00C8 00C8 00C8 00C8 00C8 00C8
0100: 00C8 00C8 00C8 00C8 00C8 00C8 00C8 00C8
0110: 00C8 00C8 00C8 00C8 00C8 00C8 00C8 00C8
0120: 00C8 00C8 00C8 00C8 00C8 00C8 00C8 00C8
0130: 00C8 00C8 00C8 00C8 00C8 00C8 00C8 00C8
0140: 00C8 00C8 00C8 00C8 00C8 00C8 00C8 00C8
0150: 00C8 00C8 00C8 00C8 00C8 00C8 00C8 00C8
0160: 00C8 00C8 00C8 00C8 00C8 00C8 00C8 00C8

After looking at the Backplane/MIMO documentation on your website I think
that at memory offset 0x0000 is the:

CHIPID 		0x4318,
REV 			2
PKG OPT		2
NumberOfCores	4

Questions that I have:
 Is this really the CHIPID or something to do with the PCI registers?
 Also after searching thru memory I can not find the value 0x4243 for the
vendor ID of the card.

I can remap the areas of the the card to anywhere but I need more info to
get started.

I can not determine where the core address starts or how many cores I
have.  By the revision number above it seems that the NumberOfCores value
does not mean anything.
Is that correct?


What does the number 0x0830 0008 mean?
Is that the core type?

Any info you can give me to get started would be appreciated.

Thank you,
Kevin



From oscar.valdez at duraflex.com.sv  Thu May 17 22:24:27 2007
From: oscar.valdez at duraflex.com.sv (Oscar A. Valdez)
Date: Thu, 17 May 2007 14:24:27 -0600
Subject: Kernel 2.6.22-rc1
In-Reply-To: <46476AF9.7080002@lwfinger.net>
References: <14b026160705130627q25ce2b83s1ae5cd77e6e7a7ca@mail.gmail.com>
	<46476AF9.7080002@lwfinger.net>
Message-ID: <1179433467.4629.38.camel@tux.valdez-bicard.com.sv>

El dom, 13-05-2007 a las 14:46 -0500, Larry Finger escribi?:
> Rafa? Mi?ecki wrote:
> > Does this version of kernel (from today) includes all these important
> > fixes/patches for bcm43xx?
> > 
> Yes.

Larry:

Would you know if the 2.6.21-rc7 kernel (currently in Fedora 7 Test 4)
include your patches?
-- 
Oscar A. Valdez




From mb at bu3sch.de  Thu May 17 22:34:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 17 May 2007 22:34:58 +0200
Subject: newbie questions
In-Reply-To: <46361.143.116.116.200.1179424186.squirrel@webmail.texascellnet.com>
References: <46361.143.116.116.200.1179424186.squirrel@webmail.texascellnet.com>
Message-ID: <200705172234.58835.mb@bu3sch.de>

On Thursday 17 May 2007 19:49:46 kbb at texascellnet.com wrote:
> I have been tasked with bringing up a CF card on petalinux.

CF cards are currently unsupported and don't work.
But we own such cards and we are going to implement support
for them. Although this has very low (lowest) priority for
obvious reasons.

I began to implement CF support in ssb in the current
wireless-dev tree. So that's the place to look at, if
you are interested. It currently loads until PHY init and
fails there.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Fri May 18 00:25:11 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 17 May 2007 17:25:11 -0500
Subject: Kernel 2.6.22-rc1
In-Reply-To: <1179433467.4629.38.camel@tux.valdez-bicard.com.sv>
References: <14b026160705130627q25ce2b83s1ae5cd77e6e7a7ca@mail.gmail.com>	
	<46476AF9.7080002@lwfinger.net>
	<1179433467.4629.38.camel@tux.valdez-bicard.com.sv>
Message-ID: <464CD647.6020703@lwfinger.net>

Oscar A. Valdez wrote:
> El dom, 13-05-2007 a las 14:46 -0500, Larry Finger escribi?:
>> Rafa? Mi?ecki wrote:
>>> Does this version of kernel (from today) includes all these important
>>> fixes/patches for bcm43xx?
>>>
>> Yes.
> 
> Larry:
> 
> Would you know if the 2.6.21-rc7 kernel (currently in Fedora 7 Test 4)
> include your patches?

Not all of them.

Larry



From kbb at texascellnet.com  Fri May 18 00:47:47 2007
From: kbb at texascellnet.com (kbb at texascellnet.com)
Date: Thu, 17 May 2007 17:47:47 -0500 (CDT)
Subject: RE; newbie
Message-ID: <54681.143.116.116.200.1179442067.squirrel@webmail.texascellnet.com>

I don't understand the "ssb in the current wireless-dev tree" you stated.

Is that in this mailing list?

And if so what are some of the subjects talked about?

Kbb


From andrew.james.barr at gmail.com  Fri May 18 00:58:59 2007
From: andrew.james.barr at gmail.com (Andrew J. Barr)
Date: Thu, 17 May 2007 18:58:59 -0400
Subject: RE; newbie
In-Reply-To: <54681.143.116.116.200.1179442067.squirrel@webmail.texascellnet.com>
References: <54681.143.116.116.200.1179442067.squirrel@webmail.texascellnet.com>
Message-ID: <20070517185859.5c29a3ea@powerbook.oakcourt.dyndns.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On Thu, 17 May 2007 17:47:47 -0500 (CDT)
kbb at texascellnet.com wrote:

> I don't understand the "ssb in the current wireless-dev tree" you
> stated.

http://git.kernel.org/?p=linux/kernel/git/linville/wireless-dev.git;a=summary

> Is that in this mailing list?
> 
> And if so what are some of the subjects talked about?
> 
> Kbb
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev


- -- 
Andrew J. Barr
X-Mailer: Claws Mail 2.9.1 (GTK+ 2.10.12; powerpc-unknown-linux-gnu)

Ronald Reagan: America's answer to Inspector Clouseau
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)

iD8DBQFGTN4zhuM+Z62a52oRAlJdAKDax0+QG+5llgX6BhlEqEGaUf/r9QCfUH6E
P7qdpXWtRAUyJ4VG5mkDRXU=
=4UrR
-----END PGP SIGNATURE-----

From johannes at sipsolutions.net  Fri May 18 09:00:45 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 18 May 2007 09:00:45 +0200
Subject: Master Mode.
In-Reply-To: <464B6326.6080300@free.fr>
References: <4645E580.3020002@free.fr>
	<20070512130315.23837f12@conroe.oakcourt.dyndns.org>
	<464B6326.6080300@free.fr>
Message-ID: <1179471646.3658.8.camel@johannes.berg>

On Wed, 2007-05-16 at 22:01 +0200, Guillaume Yziquel wrote:

> >> seldon:/home/yziquel/src/mac80211-7.0.10# make

> Any help, or suggestions of things to read, would be highly appreciated.

I'd suggest you try using wireless-dev to compile your own kernel
completely and not the out-of-tree version of mac80211, or you contact
Intel about that. Unfortunately, while I'm aware that they are offering
out of tree builds, I cannot at the moment even attemp to support them.
Also, I'm fairly certain that they do not support building on 2.6.18 as
that is too old.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070518/48e5215d/attachment.pgp>

From johannes at sipsolutions.net  Fri May 18 09:01:27 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 18 May 2007 09:01:27 +0200
Subject: [PATCH 1/3] fix A/G PHYs setup and init
In-Reply-To: <200705161451.49114.mb@bu3sch.de>
References: <25658.26952.qm@web61016.mail.yahoo.com>
	<464A760B.1090907@gmail.com>  <200705161451.49114.mb@bu3sch.de>
Message-ID: <1179471687.3658.10.camel@johannes.berg>

On Wed, 2007-05-16 at 14:51 +0200, Michael Buesch wrote:
> On Wednesday 16 May 2007 05:10:03 Jory A. Pratt wrote:
> > will have it and we can be done with softmac and v3 firmware which has
> > many known bugs even in the windows community.
> 
> For example?

Maybe he's referring to the month-of-the-kernel-bug bug in the driver,
not the firmware, which has been confused by many more people before
him?

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070518/e265b750/attachment.pgp>

From guillaume.yziquel at free.fr  Fri May 18 10:28:58 2007
From: guillaume.yziquel at free.fr (Guillaume Yziquel)
Date: Fri, 18 May 2007 10:28:58 +0200
Subject: Master Mode.
In-Reply-To: <1179471646.3658.8.camel@johannes.berg>
References: <4645E580.3020002@free.fr>	
	<20070512130315.23837f12@conroe.oakcourt.dyndns.org>	
	<464B6326.6080300@free.fr> <1179471646.3658.8.camel@johannes.berg>
Message-ID: <464D63CA.3090201@free.fr>

Johannes Berg a ?crit :
> On Wed, 2007-05-16 at 22:01 +0200, Guillaume Yziquel wrote:
> 
> I'd suggest you try using wireless-dev to compile your own kernel
> completely and not the out-of-tree version of mac80211, or you contact
> Intel about that. Unfortunately, while I'm aware that they are offering
> out of tree builds, I cannot at the moment even attemp to support them.
> Also, I'm fairly certain that they do not support building on 2.6.18 as
> that is too old.
> 
> johannes

Thank you Johannes.

On their site,

	http://intellinuxwireless.org/index.php?p=mac80211

they claim that

> This page provides general information about the the mac80211 subsystem.
> The packages hosted here provide a version installable into most kernels
> with a version of 2.6.18 or later. We're working to get the subsystem to
> work in kernels older than 2.6.18, but we aren't there yet.

For contacting Intel, they do not seem to have an electronic address
available on their web site.

I'll try to do as you say. Thank you for pointing this out to me.

Guillaume Yziquel.


From mb at bu3sch.de  Fri May 18 18:14:00 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 18 May 2007 18:14:00 +0200
Subject: Please pull http://bu3sch.de/git/wireless-dev.git/ for-linville
Message-ID: <200705181814.00361.mb@bu3sch.de>

The following changes since commit 0d2d5f7a247d3d734d68f19fd0a7222807cd2b5c:
  Hong Liu:
        mac80211: fix memory leak when defrag fragments

are found in the git repository at:

  http://bu3sch.de/git/wireless-dev.git/ for-linville

Michael Buesch:
      bcm43xx-mac80211: Various PHY fixes.
      bcm43xx-mac80211: Rewrite baseband and radio attenuation adjustment.
      ssb: Set sdev->dev before registering dev
      Merge branch 'master' of git://git.kernel.org/.../linville/wireless-dev
      Merge branch 'master' of git://git.kernel.org/.../linville/wireless-dev
      bcm43xx-mac80211: Rename all GPHY LO functions to avoid namespace collisions with APHY
      ssb: Fix NULL pointer dereferences in init paths.
      Merge branch 'master' of git://git.kernel.org/.../linville/wireless-dev
      bcm43xx-mac80211: Enable hardware MAC-address filters.
      bcm43xx-mac80211: Read and check PHY versioning information in attach stage.

 drivers/net/wireless/mac80211/bcm43xx/bcm43xx_lo.c |   43 ++++----
 drivers/net/wireless/mac80211/bcm43xx/bcm43xx_lo.h |   20 ++--
 .../net/wireless/mac80211/bcm43xx/bcm43xx_main.c   |   17 +--
 .../net/wireless/mac80211/bcm43xx/bcm43xx_phy.c    |  114 +++++++++++++++--------
 drivers/ssb/main.c                                 |   27 +++--
 5 files changed, 129 insertions(+), 92 deletions(-)

-- 
Greetings Michael.


From linolusu at tin.it  Fri May 18 19:51:09 2007
From: linolusu at tin.it (Andrea Lusuardi - UoVoBW)
Date: Fri, 18 May 2007 19:51:09 +0200
Subject: IPV6 autoconf problems
Message-ID: <20070518195109.08a88976@electricsheep>

Hi everyone,
i am using the git wireless-dev tree for both the bcm43xx and the
bcm43xx-mac80211 drivers.
i have both compiled as modules and i am using the 3.130.xxx firmware
for the bcm43xx and the new 4.theonthereadme for the bcm43xx-mac80211.
I get both drivers to work correctly with open system, wep, wpa and
wpa2 (i tested all theese) but i have a problem negotiating the ipv6
address:
with the bcm43xx softmac i simply modprobe the module, ifconfig wlan0
up the card, set the wep cypher and i get immediately the ipv6 address
- i have this for the internal ipv6 net at university - and i can use
it with no problems.
With the mac80211 version of the driver i can use the ipv4 link with no
problems, excellent stability and rates, but i cannot get the ipv6
address - the Scope: Global one - that i get immediately with the
softmac driver.
Also, i noticed my syslog is fill with:

May 18 16:01:35 electricmove kernel: wlan0: duplicate address detected!
May 18 16:03:18 electricmove kernel: wlan0: duplicate address detected!
May 18 16:04:44 electricmove kernel: wlan0: duplicate address detected!
May 18 16:05:34 electricmove kernel: wlan0: duplicate address detected!
May 18 16:07:32 electricmove kernel: wlan0: duplicate address detected!
May 18 16:08:24 electricmove kernel: wlan0: duplicate address detected!
May 18 16:10:19 electricmove kernel: wlan0: duplicate address detected!
May 18 16:11:45 electricmove kernel: wlan0: duplicate address detected!
-a lot of lines snipped-

and it can go on for hours: sometimes the ipv6 is negotiated after 2 or
3 "duoplicate address" messages, sometimes it will take the whole day,
sometimes it will never work.
I could not relate this to the number of other wireless clients on the
net, as with the bcm softmac one i _always_ got the ipv6 complete
address after the first try.
I also tryed forcing the interface this way:

ip link set wlan0 dynamic off && ip link set wlan0 dynamic on

but that makes no difference.
Any help would be highly appreciated, and i have no problem providing
more debug - once i know what to write - or even ssh access to my laptop
- ibook g4 with a bcm4306 card, 

0001:10:12.0 Network controller: Broadcom Corporation BCM4306 802.11b/g
Wireless LAN Controller (rev 03)

for any of the devs.
Thanks,
bye

-- 
           Andrea Lusuardi  -  UoVoBW 
          Registered Linux User #364578
    http://uovobw.homelinux.org/ - GPG: 313C1073
Pavoni di grandezza inusitata, si stagliano nel 
		cielo di Bangkok
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 827 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070518/94e7e6c9/attachment.pgp>

From sb at dod.no  Sat May 19 12:26:26 2007
From: sb at dod.no (Steinar Bang)
Date: Sat, 19 May 2007 12:26:26 +0200
Subject: BCM4318 doesn't get DHCPOFFERS
Message-ID: <87sl9t3y99.fsf@bang.priv.no>

Platform: Intel Pentium M (Dell D610 laptop),
	  Ubuntu Feisty (upgraded from Edgy upgraded from Dapper,
	  originally installed as Breezy)
	  wpasupplicant 0.5.7-0ubuntu2
	  network-manager 0.6.4-6ubuntu7
	  network-manager-gnome 0.6.4-6ubuntu7
	  linux-image-2.6.20-15-386 2.6.20-15.27

When I first upgraded to Feisty I tried connecting to my WEP protected
AP, and immediately succeeded.  Later I've successfully (for the first
time) connected to a WPA protected AP at work.

But now the laptop no longer succeeds in connecting to my home (WEP
protected) AP.  According to the dhclient logs it believes that it
doesn't get any DHCPOFFERS (though the logs on the DHCP server says
it's received a DHCPDISCOVER and sent a DHCPOFFER), retries two times
and gives up, and then network-manager successfully (and unintentioned
by me) connects to an open WLAN in the neighbourhood, with a much
weaker signal (the laptop is 30cm from my own AP when doing the
tests).

According to the logs in the AP the laptop has connected.  And
according to the logs from the DHCP server, a NIC with the MAC of the
broadcom WLAN card has been given a DHCPOFFER (but has never returned
a DHCPACK).

In earlier OS incarnations, both using first ndiswrapper, and later
bcm43xx, I've seen this kind of flaky behaviour, but a shutdown,
followed by a reboot has usually cleared them up.

Any clues as to where I could start digging for clues, and workarounds
I could try, are highly appreciated.

Thanx!

- Steinar

The usual information follows:

lspci -v:

03:03.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 54g] 802.11g Wireless LAN Controller (rev 02)
        Subsystem: Dell Unknown device 0005
        Flags: bus master, fast devsel, latency 64, IRQ 18
        Memory at dfbfe000 (32-bit, non-prefetchable) [size=8K]

uname -r:

2.6.20-15-386



From ubq7 at stud.uni-karlsruhe.de  Sat May 19 12:57:40 2007
From: ubq7 at stud.uni-karlsruhe.de (Hendrik Sattler)
Date: Sat, 19 May 2007 12:57:40 +0200
Subject: BCM4318 doesn't get DHCPOFFERS
In-Reply-To: <87sl9t3y99.fsf@bang.priv.no>
References: <87sl9t3y99.fsf@bang.priv.no>
Message-ID: <200705191257.42666.ubq7@stud.uni-karlsruhe.de>

Am Samstag 19 Mai 2007 12:26 schrieb Steinar Bang:
> Platform: Intel Pentium M (Dell D610 laptop),
> 	  Ubuntu Feisty (upgraded from Edgy upgraded from Dapper,
> 	  originally installed as Breezy)
> 	  wpasupplicant 0.5.7-0ubuntu2
> 	  network-manager 0.6.4-6ubuntu7
> 	  network-manager-gnome 0.6.4-6ubuntu7
> 	  linux-image-2.6.20-15-386 2.6.20-15.27
>
> When I first upgraded to Feisty I tried connecting to my WEP protected
> AP, and immediately succeeded.  Later I've successfully (for the first
> time) connected to a WPA protected AP at work.

I have a similar problem: I cannot connect to those standard DSL WLAN routers 
that the german telephone company Arcor provides. I know three people with 
those and I always have to use the cable.
It doesn't matter if those use WEP or WPA.

Those routers are made by Zyxel.
My AVM DSL WLAN router at home works flawlessly.

HS


From dwmw2 at infradead.org  Tue May 22 02:13:26 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Mon, 21 May 2007 20:13:26 -0400
Subject: IPV6 autoconf problems
In-Reply-To: <20070518195109.08a88976@electricsheep>
References: <20070518195109.08a88976@electricsheep>
Message-ID: <1179792806.2771.108.camel@shinybook.infradead.org>

On Fri, 2007-05-18 at 19:51 +0200, Andrea Lusuardi - UoVoBW wrote:
> 
> but that makes no difference.
> Any help would be highly appreciated, and i have no problem providing
> more debug - once i know what to write - or even ssh access to my
> laptop
> - ibook g4 with a bcm4306 card, 

I've seen the same problem -- it'll be a generic problem with Ethernet
multicast.

Anyone can set up radvd to test this -- they don't even need proper IPv6
connectivity (although that's trivial to arrange too). They can just set
it up with site-local addresses (the fec0::/16 subnet).

On any machine on the subnet, just 'ip -6 addr add fec0::1/64 dev
eth0' (or whatever the equivalent is in your distribution's network
config scripts), install radvd and set up /etc/radvd.conf to look
something like this...

interface eth1
{
        AdvSendAdvert on;
        MinRtrAdvInterval 30;
        MaxRtrAdvInterval 100;
        prefix fec0::/64
        {
                AdvOnLink on;
                AdvAutonomous on;
                AdvRouterAddr off;
        };

};

You'll find that with the softmac bcm43xx driver, you pick up an address
like fec0::20a:95ff:fef3:9992 automatically, fairly reliably. With the
mac80211 version, it works much more rarely, and slowly. You can tcpdump
and watch for the multicast traffic at both ends.
 
-- 
dwmw2



From linolusu at tin.it  Tue May 22 09:08:20 2007
From: linolusu at tin.it (Andrea Lusuardi - UoVoBW)
Date: Tue, 22 May 2007 09:08:20 +0200
Subject: IPV6 autoconf problems
In-Reply-To: <1179792806.2771.108.camel@shinybook.infradead.org>
References: <20070518195109.08a88976@electricsheep>
	<1179792806.2771.108.camel@shinybook.infradead.org>
Message-ID: <20070522090820.29b591fa@electricsheep>

On Mon, 21 May 2007 20:13:26 -0400
David Woodhouse <dwmw2 at infradead.org> wrote:

> You'll find that with the softmac bcm43xx driver, you pick up an
> address like fec0::20a:95ff:fef3:9992 automatically, fairly reliably.
> With the mac80211 version, it works much more rarely, and slowly. You
> can tcpdump and watch for the multicast traffic at both ends.

The debian config of radvd was quite simple and yes, this is true.I set
this up on my access point and it behaved as you described.
How can this be fixed?
is there a way to use radvd to talk to the other radvd - which i asked
and is used to configure ip6 connectivity at my university - ad force
it to send the configurations?
thanks again

-- 
           Andrea Lusuardi  -  UoVoBW 
          Registered Linux User #364578
    http://uovobw.homelinux.org/ - GPG: 313C1073
Pavoni di grandezza inusitata, si stagliano nel 
		cielo di Bangkok
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 827 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070522/9bbefd79/attachment.pgp>

From dwmw2 at infradead.org  Tue May 22 14:32:11 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Tue, 22 May 2007 08:32:11 -0400
Subject: IPV6 autoconf problems
In-Reply-To: <20070522090820.29b591fa@electricsheep>
References: <20070518195109.08a88976@electricsheep>
	<1179792806.2771.108.camel@shinybook.infradead.org>
	<20070522090820.29b591fa@electricsheep>
Message-ID: <1179837131.2771.153.camel@shinybook.infradead.org>

On Tue, 2007-05-22 at 09:08 +0200, Andrea Lusuardi - UoVoBW wrote:
> The debian config of radvd was quite simple and yes, this is true.I set
> this up on my access point and it behaved as you described.
> How can this be fixed?

Well, I'd start by showing the main developers how to reproduce it :)

If you can test it at a time the network is otherwise fairly idle, and
just bring your bcm43xx up with 'ip link set eth1 up' rather than
assigning it a Legacy IP address, then there should be _very_ little
traffic -- but it _should_ do router discovery and pick up an IPv6
address. Use tcpdump at both ends, and compare the results. I have a
very strong suspicion that you'll find there are multicast Ethernet
packets getting lost in transit.

> is there a way to use radvd to talk to the other radvd - which i asked
> and is used to configure ip6 connectivity at my university - ad force
> it to send the configurations?

No. radvd only advertises routes for a single subnet. It advertises the
'prefix' -- the upper 64 bits -- and the lower 64 bits are generated by
the individual station, from a permutation of that station's MAC
address. The station assumes the default route is out via the machine
which was running radvd.

If you want to run radvd with a 'real' global address and provide proper
connectivity, then you have to have a subnet of your own for radvd to
advertise. With '6to4' that's actually dead easy -- you get a whole /48
of IPv6 addresses for every public IPv4 address, which means 65536
separate /64 subnets of your own. It's better to get 'proper' IPv6
connectivity though, if you can -- either through a tunnel such as from
somewhere like sixxs.net, or just ask the university to assign you some
space and tunnel it to you.

-- 
dwmw2



From linolusu at tin.it  Tue May 22 18:58:20 2007
From: linolusu at tin.it (Andrea Lusuardi - UoVoBW)
Date: Tue, 22 May 2007 18:58:20 +0200
Subject: IPV6 autoconf problems
In-Reply-To: <1179837131.2771.153.camel@shinybook.infradead.org>
References: <20070518195109.08a88976@electricsheep>
	<1179792806.2771.108.camel@shinybook.infradead.org>
	<20070522090820.29b591fa@electricsheep>
	<1179837131.2771.153.camel@shinybook.infradead.org>
Message-ID: <20070522185820.70f72c48@electricsheep>

On Tue, 22 May 2007 08:32:11 -0400
David Woodhouse <dwmw2 at infradead.org> wrote:

> If you can test it at a time the network is otherwise fairly idle, and
> just bring your bcm43xx up with 'ip link set eth1 up' rather than
> assigning it a Legacy IP address,

with "legacy ip address" you mean not using dhclient nor static
configuration, i would just:

modprobe bcm43xx-mac80211
ifconfig wlan0 up
iwconfig SETTINGS
 - in the log ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready - 
ip link set wlan0 up

right? or am i supposed to substitute the "ifconfig wlan0 up" with the
ip link command?
i noticed that, if i do not up the card _before_ iwconfig it, it wont
get any association/authentication.
(sorry for theese seemingly stupid questions but i want to provide
useful help and clarity helps, in this)
Also: i cannot test it with tcpdump at home since my fonera - the
router i used earlier to check the delay in ipv6 configuration with
radvd - had a little overheating accident - thanks to lousy fon
hardware - and now the wireless chipset is damaged and won't even
produce beacons...
I will test this as soon as i return to my university, next monday.

> then there should be _very_ little
> traffic -- but it _should_ do router discovery and pick up an IPv6
> address. Use tcpdump at both ends, and compare the results. I have a
> very strong suspicion that you'll find there are multicast Ethernet
> packets getting lost in transit.

as above, will do this - as soon as my doubt is cleared - and post the
results. thanks again.

> If you want to run radvd with a 'real' global address and provide
> proper connectivity, then you have to have a subnet of your own for
> radvd to advertise. With '6to4' that's actually dead easy -- you get
> a whole /48 of IPv6 addresses for every public IPv4 address, which
> means 65536 separate /64 subnets of your own. It's better to get
> 'proper' IPv6 connectivity though, if you can -- either through a
> tunnel such as from somewhere like sixxs.net, or just ask the
> university to assign you some space and tunnel it to you.

that would just be great, but at the moment i think it would be pretty
hard for me to get the uni assign me an ipv6 subnet.
i will anyway ask :)

thanks again

-- 
           Andrea Lusuardi  -  UoVoBW 
          Registered Linux User #364578
    http://uovobw.homelinux.org/ - GPG: 313C1073
Pavoni di grandezza inusitata, si stagliano nel 
		cielo di Bangkok
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 827 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070522/452e2cf8/attachment.pgp>

From linolusu at tin.it  Tue May 22 20:38:09 2007
From: linolusu at tin.it (Andrea Lusuardi - UoVoBW)
Date: Tue, 22 May 2007 20:38:09 +0200
Subject: IPV6 autoconf problems
In-Reply-To: <1179837131.2771.153.camel@shinybook.infradead.org>
References: <20070518195109.08a88976@electricsheep>
	<1179792806.2771.108.camel@shinybook.infradead.org>
	<20070522090820.29b591fa@electricsheep>
	<1179837131.2771.153.camel@shinybook.infradead.org>
Message-ID: <20070522203809.7399853f@electricsheep>

On Tue, 22 May 2007 08:32:11 -0400
David Woodhouse <dwmw2 at infradead.org> wrote:

> If you can test it at a time the network is otherwise fairly idle, and
> just bring your bcm43xx up with 'ip link set eth1 up' rather than
> assigning it a Legacy IP address,

with "legacy ip address" you mean not using dhclient nor static
configuration, i would just:

modprobe bcm43xx-mac80211
ifconfig wlan0 up
iwconfig SETTINGS
 - in the log ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready - 
ip link set wlan0 up

right? or am i supposed to substitute the "ifconfig wlan0 up" with the
ip link command?
i noticed that, if i do not up the card _before_ iwconfig it, it wont
get any association/authentication.
(sorry for theese seemingly stupid questions but i want to provide
useful help and clarity helps, in this)
Also: i cannot test it with tcpdump at home since my fonera - the
router i used earlier to check the delay in ipv6 configuration with
radvd - had a little overheating accident - thanks to lousy fon
hardware - and now the wireless chipset is damaged and won't even
produce beacons...
I will test this as soon as i return to my university, next monday.

> then there should be _very_ little
> traffic -- but it _should_ do router discovery and pick up an IPv6
> address. Use tcpdump at both ends, and compare the results. I have a
> very strong suspicion that you'll find there are multicast Ethernet
> packets getting lost in transit.

as above, will do this - as soon as my doubt is cleared - and post the
results. thanks again.

> If you want to run radvd with a 'real' global address and provide
> proper connectivity, then you have to have a subnet of your own for
> radvd to advertise. With '6to4' that's actually dead easy -- you get
> a whole /48 of IPv6 addresses for every public IPv4 address, which
> means 65536 separate /64 subnets of your own. It's better to get
> 'proper' IPv6 connectivity though, if you can -- either through a
> tunnel such as from somewhere like sixxs.net, or just ask the
> university to assign you some space and tunnel it to you.

that would just be great, but at the moment i think it would be pretty
hard for me to get the uni assign me an ipv6 subnet.
i will anyway ask :)

thanks again

-- 
           Andrea Lusuardi  -  UoVoBW 
          Registered Linux User #364578
    http://uovobw.homelinux.org/ - GPG: 313C1073
Pavoni di grandezza inusitata, si stagliano nel 
		cielo di Bangkok
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 827 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070522/564cf1c6/attachment.pgp>

From dwmw2 at infradead.org  Wed May 23 02:19:10 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Tue, 22 May 2007 20:19:10 -0400
Subject: IPV6 autoconf problems
In-Reply-To: <20070522203809.7399853f@electricsheep>
References: <20070518195109.08a88976@electricsheep>
	<1179792806.2771.108.camel@shinybook.infradead.org>
	<20070522090820.29b591fa@electricsheep>
	<1179837131.2771.153.camel@shinybook.infradead.org>
	<20070522203809.7399853f@electricsheep>
Message-ID: <1179879550.10095.26.camel@shinybook.infradead.org>

On Tue, 2007-05-22 at 20:38 +0200, Andrea Lusuardi - UoVoBW wrote:
> On Tue, 22 May 2007 08:32:11 -0400
> David Woodhouse <dwmw2 at infradead.org> wrote:
> 
> > If you can test it at a time the network is otherwise fairly idle, and
> > just bring your bcm43xx up with 'ip link set eth1 up' rather than
> > assigning it a Legacy IP address,
> 
> with "legacy ip address" you mean not using dhclient nor static
> configuration, i would just:
> 
> modprobe bcm43xx-mac80211
> ifconfig wlan0 up
> iwconfig SETTINGS
>  - in the log ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready - 
> ip link set wlan0 up
> 
> right? or am i supposed to substitute the "ifconfig wlan0 up" with the
> ip link command?

They do the same thing. So you don't need to do it a second time after
running iwconfig.

> i noticed that, if i do not up the card _before_ iwconfig it, it wont
> get any association/authentication.

Hm, that's a bug. The softmac driver used to suffer that too, but it's
fixed now.

-- 
dwmw2



From dwmw2 at infradead.org  Fri May 25 15:28:35 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 25 May 2007 09:28:35 -0400
Subject: IPV6 autoconf problems
In-Reply-To: <20070518195109.08a88976@electricsheep>
References: <20070518195109.08a88976@electricsheep>
Message-ID: <1180099716.8303.204.camel@shinybook.infradead.org>

On Fri, 2007-05-18 at 19:51 +0200, Andrea Lusuardi - UoVoBW wrote:
> May 18 16:08:24 electricmove kernel: wlan0: duplicate address detected!
> May 18 16:10:19 electricmove kernel: wlan0: duplicate address detected!
> May 18 16:11:45 electricmove kernel: wlan0: duplicate address detected!
> -a lot of lines snipped-
> 
> and it can go on for hours: sometimes the ipv6 is negotiated after 2 or
> 3 "duoplicate address" messages, sometimes it will take the whole day,
> sometimes it will never work. 

Steve (Cc'd) has reported something very similar on iwl3945, and has
offered the sane-sounding hypothesis that it's seeing its own outgoing
packets when it shouldn't.

-- 
dwmw2



From johannes at sipsolutions.net  Fri May 25 15:58:11 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 25 May 2007 15:58:11 +0200
Subject: IPV6 autoconf problems
In-Reply-To: <1180099716.8303.204.camel@shinybook.infradead.org>
References: <20070518195109.08a88976@electricsheep>
	<1180099716.8303.204.camel@shinybook.infradead.org>
Message-ID: <1180101491.3604.57.camel@johannes.berg>

On Fri, 2007-05-25 at 09:28 -0400, David Woodhouse wrote:

> Steve (Cc'd) has reported something very similar on iwl3945, and has
> offered the sane-sounding hypothesis that it's seeing its own outgoing
> packets when it shouldn't.

I'd like to have packet dumps of the master interface, a monitor
interface and the actual interface that has the problem simultaneously,
if possible. That should help debug what's going in/out. Instead of the
two from monitor/master having a third station monitor things would be
even better. Unfortunately mac80211/bcm43xx-mac80211 currently locks up
my machine hard and we haven't found the cause yet, so I can't reproduce
this at the moment.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070525/9c6ff21a/attachment.pgp>

From dwmw2 at infradead.org  Sat May 26 01:17:08 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 25 May 2007 19:17:08 -0400
Subject: IPV6 autoconf problems
In-Reply-To: <Pine.LNX.4.64.0705251956190.29153@rivendell.nexusuk.org>
References: <20070518195109.08a88976@electricsheep>
	<1180099716.8303.204.camel@shinybook.infradead.org>
	<1180101491.3604.57.camel@johannes.berg>
	<Pine.LNX.4.64.0705251956190.29153@rivendell.nexusuk.org>
Message-ID: <1180135028.8303.215.camel@shinybook.infradead.org>

On Fri, 2007-05-25 at 20:13 +0100, Steve Hill wrote:
> On Fri, 25 May 2007, Johannes Berg wrote:
> 
> > I'd like to have packet dumps of the master interface, a monitor
> > interface and the actual interface that has the problem simultaneously,
> 
> http://www.nexusuk.org/~steve/iwl3945-ipv6/ap.pcap
> http://www.nexusuk.org/~steve/iwl3945-ipv6/wlan0.pcap
> 
> The set up I have is:
> 
>    Internet=====Router=====AccessPoint-----Notebook
> 
> (===== is 100Mbps ethernet, ----- is 802.11g)
> 
> The router is doing IPv6 router advertisements, the notebook is supposed 
> to be using them to configure the IPv6 address on it's wlan0 interface (an 
> iwl3945).  The access point is a LinkSys WRT54GL running OpenWRT 
> WhiteRussian and is just bridging the wired network to the wireless 
> network.
> 
> So, ap.pcap is a dump from the 802.11 interface on the access point. 
> wlan0.pcap is a dump from the 802.11 interface on the notebook.
> 
> The sequence of events is basically:
> 1. Router sends advertisement
> 2. Notebook receives advertisement
> 3. Notebook picks an IP address and sends a neighbor solicitation to see 
> if anyone else is already using that address.
> 
> (these 3 steps happen twice in these network dumps).
> 
> The dump taken on the access point clearly shows that the notebook sends 
> just one neighbor solicitation for each router advertisement it receives. 
> However, the dump taken on the notebook shows two neighbor solicitation 
> messages for each router advertisement.
> 
> Seems reasonably conclusive - it looks like the notebook is sending a 
> neighbor solicitation and is then receiving it's own data again.

Seems like a reasonable conclusion. Does this 'fix' it?

diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index d8b3645..289375c 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -716,7 +716,7 @@ static void ndisc_recv_ns(struct sk_buff *skb)
 
 		if (ifp->flags & (IFA_F_TENTATIVE|IFA_F_OPTIMISTIC)) {
 			if (dad) {
-				if (dev->type == ARPHRD_IEEE802_TR) {
+				if (1) {
 					const unsigned char *sadr;
 					sadr = skb_mac_header(skb);
 					if (((sadr[8] ^ dev->dev_addr[0]) & 0x7f) == 0 &&

-- 
dwmw2



From will.dyson at gmail.com  Sat May 26 01:37:33 2007
From: will.dyson at gmail.com (Will Dyson)
Date: Fri, 25 May 2007 19:37:33 -0400
Subject: BUG: at net/mac80211/ieee80211.c:1280 ieee80211_tx()
Message-ID: <8e6f94720705251637o71a13d71w70199a3057048592@mail.gmail.com>

Hi all,

First, the good news: bcm43xx-mac80211 in wireless-dev now works about
as well for me as the old driver. Similar connection reliability,
upload speed and download speed. Woo!

But I've got ton's of these in my log:

 BUG: at net/mac80211/ieee80211.c:1280 ieee80211_tx()

 Call Trace:
  [<ffffffff805866a3>] ieee80211_master_start_xmit+0x5f3/0x680
  [<ffffffff804d447d>] dev_hard_start_xmit+0x26d/0x2d0
  [<ffffffff804e4781>] __qdisc_run+0xd1/0x260
  [<ffffffff804d6a87>] dev_queue_xmit+0x1a7/0x370
  [<ffffffff8058a45b>] ieee80211_subif_start_xmit+0x34b/0x590
  [<ffffffff804ce3a7>] kfree_skb+0x17/0x30
  [<ffffffff804d447d>] dev_hard_start_xmit+0x26d/0x2d0
  [<ffffffff804e4781>] __qdisc_run+0xd1/0x260
  [<ffffffff804d6a87>] dev_queue_xmit+0x1a7/0x370
  [<ffffffff804f9bef>] ip_output+0x19f/0x340
  [<ffffffff804f9069>] ip_queue_xmit+0x219/0x430
  [<ffffffff80295fe0>] __pollwait+0x0/0x110
  [<ffffffff8050a82e>] tcp_transmit_skb+0x40e/0x7c0
  [<ffffffff8022ce00>] default_wake_function+0x0/0x10
  [<ffffffff8050c4bb>] __tcp_push_pending_frames+0x11b/0x940
  [<ffffffff8059c6a8>] csum_partial_copy_from_user+0x88/0x120
  [<ffffffff80500b66>] tcp_sendmsg+0x876/0xc80
  [<ffffffff8022ce0d>] default_wake_function+0xd/0x10
  [<ffffffff8022ba37>] __wake_up_common+0x47/0x70
  [<ffffffff8051e795>] inet_sendmsg+0x45/0x80
  [<ffffffff804c7161>] sock_aio_write+0x101/0x110
  [<ffffffff80286071>] do_sync_write+0xf1/0x130
  [<ffffffff80246f80>] autoremove_wake_function+0x0/0x40
  [<ffffffff8023688e>] current_fs_time+0x3e/0x40
  [<ffffffff80286999>] vfs_write+0x159/0x170
  [<ffffffff80286fa0>] sys_write+0x50/0x90
  [<ffffffff8020a1ae>] system_call+0x7e/0x83

Kernel: wireless-dev latest from git
Arch: x86-64

My boot log is attached for full hardware information.

-- 
Will Dyson
-------------- next part --------------
[    0.000000] Linux version 2.6.22-rc2-wifidev0 (will at zod) (gcc version 4.1.3 20070518 (prerelease) (Debian 4.1.2-8)) #1 PREEMPT Tue May 22 21:42:43 EDT 2007
[    0.000000] Command line: root=/dev/sda2 ro console=ttyS0,115200n8r console=tty0 
[    0.000000] BIOS-provided physical RAM map:
[    0.000000]  BIOS-e820: 0000000000000000 - 000000000009f800 (usable)
[    0.000000]  BIOS-e820: 000000000009f800 - 00000000000a0000 (reserved)
[    0.000000]  BIOS-e820: 00000000000f0000 - 0000000000100000 (reserved)
[    0.000000]  BIOS-e820: 0000000000100000 - 00000000bfff0000 (usable)
[    0.000000]  BIOS-e820: 00000000bfff0000 - 00000000bfff3000 (ACPI NVS)
[    0.000000]  BIOS-e820: 00000000bfff3000 - 00000000c0000000 (ACPI data)
[    0.000000]  BIOS-e820: 00000000fec00000 - 0000000100000000 (reserved)
[    0.000000] Entering add_active_range(0, 0, 159) 0 entries of 256 used
[    0.000000] Entering add_active_range(0, 256, 786416) 1 entries of 256 used
[    0.000000] end_pfn_map = 1048576
[    0.000000] DMI 2.2 present.
[    0.000000] ACPI: RSDP 000F8FA0, 0014 (r0 Nvidia)
[    0.000000] ACPI: RSDT BFFF3040, 0034 (r1 Nvidia AWRDACPI 42302E31 AWRD        0)
[    0.000000] ACPI: FACP BFFF30C0, 0074 (r1 Nvidia AWRDACPI 42302E31 AWRD        0)
[    0.000000] ACPI: DSDT BFFF3180, 48C1 (r1 NVIDIA AWRDACPI     1000 MSFT  100000E)
[    0.000000] ACPI: FACS BFFF0000, 0040
[    0.000000] ACPI: SSDT BFFF7B80, 00B5 (r1 PTLTD  POWERNOW        1  LTP        1)
[    0.000000] ACPI: SRAT BFFF7C80, 0090 (r1 AMD    HAMMER          1 AMD         1)
[    0.000000] ACPI: APIC BFFF7AC0, 007C (r1 Nvidia AWRDACPI 42302E31 AWRD        0)
[    0.000000] Entering add_active_range(0, 0, 159) 0 entries of 256 used
[    0.000000] Entering add_active_range(0, 256, 786416) 1 entries of 256 used
[    0.000000] Zone PFN ranges:
[    0.000000]   DMA             0 ->     4096
[    0.000000]   DMA32        4096 ->  1048576
[    0.000000]   Normal    1048576 ->  1048576
[    0.000000] early_node_map[2] active PFN ranges
[    0.000000]     0:        0 ->      159
[    0.000000]     0:      256 ->   786416
[    0.000000] On node 0 totalpages: 786319
[    0.000000]   DMA zone: 56 pages used for memmap
[    0.000000]   DMA zone: 1510 pages reserved
[    0.000000]   DMA zone: 2433 pages, LIFO batch:0
[    0.000000]   DMA32 zone: 10695 pages used for memmap
[    0.000000]   DMA32 zone: 771625 pages, LIFO batch:31
[    0.000000]   Normal zone: 0 pages used for memmap
[    0.000000] Nvidia board detected. Ignoring ACPI timer override.
[    0.000000] If you got timer trouble try acpi_use_timer_override
[    0.000000] ACPI: PM-Timer IO Port: 0x4008
[    0.000000] ACPI: Local APIC address 0xfee00000
[    0.000000] ACPI: LAPIC (acpi_id[0x00] lapic_id[0x00] enabled)
[    0.000000] Processor #0 (Bootup-CPU)
[    0.000000] ACPI: LAPIC (acpi_id[0x01] lapic_id[0x01] disabled)
[    0.000000] ACPI: LAPIC_NMI (acpi_id[0x00] high edge lint[0x1])
[    0.000000] ACPI: LAPIC_NMI (acpi_id[0x01] high edge lint[0x1])
[    0.000000] ACPI: IOAPIC (id[0x02] address[0xfec00000] gsi_base[0])
[    0.000000] IOAPIC[0]: apic_id 2, address 0xfec00000, GSI 0-23
[    0.000000] ACPI: INT_SRC_OVR (bus 0 bus_irq 0 global_irq 2 dfl dfl)
[    0.000000] ACPI: BIOS IRQ0 pin2 override ignored.
[    0.000000] ACPI: INT_SRC_OVR (bus 0 bus_irq 9 global_irq 9 high level)
[    0.000000] ACPI: INT_SRC_OVR (bus 0 bus_irq 14 global_irq 14 high edge)
[    0.000000] ACPI: INT_SRC_OVR (bus 0 bus_irq 15 global_irq 15 high edge)
[    0.000000] ACPI: IRQ9 used by override.
[    0.000000] ACPI: IRQ14 used by override.
[    0.000000] ACPI: IRQ15 used by override.
[    0.000000] Setting APIC routing to flat
[    0.000000] Using ACPI (MADT) for SMP configuration information
[    0.000000] Allocating PCI resources starting at c4000000 (gap: c0000000:3ec00000)
[    0.000000] Built 1 zonelists.  Total pages: 774058
[    0.000000] Kernel command line: root=/dev/sda2 ro console=ttyS0,115200n8r console=tty0 
[    0.000000] Initializing CPU#0
[    0.000000] PID hash table entries: 4096 (order: 12, 32768 bytes)
[   31.075884] time.c: Detected 1808.831 MHz processor.
[   31.076920] Console: colour VGA+ 80x25
[   31.081178] Dentry cache hash table entries: 524288 (order: 10, 4194304 bytes)
[   31.085085] Inode-cache hash table entries: 262144 (order: 9, 2097152 bytes)
[   31.086413] Checking aperture...
[   31.086449] CPU 0: aperture @ f0000000 size 128 MB
[   31.118310] Memory: 3089632k/3145664k available (3723k kernel code, 55316k reserved, 1581k data, 204k init)
[   31.177835] Calibrating delay using timer specific routine.. 3618.69 BogoMIPS (lpj=1809346)
[   31.177945] Mount-cache hash table entries: 256
[   31.178085] CPU: L1 I Cache: 64K (64 bytes/line), D cache 64K (64 bytes/line)
[   31.178121] CPU: L2 Cache: 512K (64 bytes/line)
[   31.178164] CPU: AMD Athlon(tm) 64 Processor 3000+ stepping 00
[   31.178250] ACPI: Core revision 20070126
[   31.192208] Using local APIC timer interrupts.
[   31.247516] result 12561331
[   31.247548] Detected 12.561 MHz APIC timer.
[   31.247925] NET: Registered protocol family 16
[   31.248052] No dock devices found.
[   31.248147] ACPI: bus type pci registered
[   31.248188] PCI: Using configuration type 1
[   31.253257] ACPI: Interpreter enabled
[   31.253294] ACPI: (supports S0 S1 S4 S5)
[   31.253450] ACPI: Using IOAPIC for interrupt routing
[   31.263052] ACPI: PCI Root Bridge [PCI0] (0000:00)
[   31.263093] PCI: Probing PCI hardware (bus 00)
[   31.263690] ACPI: PCI Interrupt Routing Table [\_SB_.PCI0._PRT]
[   31.263880] ACPI: PCI Interrupt Routing Table [\_SB_.PCI0.HUB0._PRT]
[   31.264215] ACPI: PCI Interrupt Routing Table [\_SB_.PCI0.AGPB._PRT]
[   31.321009] ACPI: PCI Interrupt Link [LNK1] (IRQs 3 4 5 6 7 *10 11 12 14 15)
[   31.321488] ACPI: PCI Interrupt Link [LNK2] (IRQs 3 4 5 6 7 10 *11 12 14 15)
[   31.321968] ACPI: PCI Interrupt Link [LNK3] (IRQs 3 4 5 6 7 10 11 12 14 15) *0, disabled.
[   31.322495] ACPI: PCI Interrupt Link [LNK4] (IRQs 3 4 5 6 7 10 *11 12 14 15)
[   31.322974] ACPI: PCI Interrupt Link [LNK5] (IRQs 3 4 *5 6 7 10 11 12 14 15)
[   31.323451] ACPI: PCI Interrupt Link [LUBA] (IRQs *3 4 5 6 7 10 11 12 14 15)
[   31.323929] ACPI: PCI Interrupt Link [LUBB] (IRQs 3 4 *5 6 7 10 11 12 14 15)
[   31.324405] ACPI: PCI Interrupt Link [LMAC] (IRQs *3 4 5 6 7 10 11 12 14 15)
[   31.324883] ACPI: PCI Interrupt Link [LAPU] (IRQs 3 4 5 6 7 10 11 12 14 15) *0, disabled.
[   31.325410] ACPI: PCI Interrupt Link [LACI] (IRQs 3 4 *5 6 7 10 11 12 14 15)
[   31.325893] ACPI: PCI Interrupt Link [LMCI] (IRQs *3 4 5 6 7 10 11 12 14 15)
[   31.326371] ACPI: PCI Interrupt Link [LSMB] (IRQs 3 4 5 6 7 10 *11 12 14 15)
[   31.326850] ACPI: PCI Interrupt Link [LUB2] (IRQs 3 4 5 6 7 *10 11 12 14 15)
[   31.327326] ACPI: PCI Interrupt Link [LFIR] (IRQs 3 4 5 6 7 10 11 12 14 15) *0, disabled.
[   31.327855] ACPI: PCI Interrupt Link [L3CM] (IRQs 3 4 5 6 7 10 11 12 14 15) *0, disabled.
[   31.328382] ACPI: PCI Interrupt Link [LIDE] (IRQs 3 4 5 6 7 10 11 12 14 15) *0, disabled.
[   31.328920] ACPI: PCI Interrupt Link [LSID] (IRQs 3 4 5 6 7 10 *11 12 14 15)
[   31.329409] ACPI: PCI Interrupt Link [LFID] (IRQs 3 4 5 6 7 *10 11 12 14 15)
[   31.329917] ACPI: PCI Interrupt Link [APC1] (IRQs 16) *0
[   31.330232] ACPI: PCI Interrupt Link [APC2] (IRQs 17) *0
[   31.330546] ACPI: PCI Interrupt Link [APC3] (IRQs 18) *0, disabled.
[   31.330887] ACPI: PCI Interrupt Link [APC4] (IRQs 19) *0
[   31.331146] ACPI: PCI Interrupt Link [APC5] (IRQs *16)
[   31.331446] ACPI: PCI Interrupt Link [APCF] (IRQs 20 21 22 23) *0
[   31.331835] ACPI: PCI Interrupt Link [APCG] (IRQs 20 21 22 23) *0
[   31.332221] ACPI: PCI Interrupt Link [APCH] (IRQs 20 21 22 23) *0
[   31.332606] ACPI: PCI Interrupt Link [APCI] (IRQs 20 21 22 23) *0, disabled.
[   31.333017] ACPI: PCI Interrupt Link [APCJ] (IRQs 20 21 22 23) *0
[   31.333403] ACPI: PCI Interrupt Link [APCK] (IRQs 20 21 22 23) *0
[   31.333790] ACPI: PCI Interrupt Link [APCS] (IRQs 20 21 22 23) *0
[   31.334176] ACPI: PCI Interrupt Link [APCL] (IRQs 20 21 22 23) *0
[   31.334561] ACPI: PCI Interrupt Link [APCM] (IRQs 20 21 22 23) *0, disabled.
[   31.334973] ACPI: PCI Interrupt Link [AP3C] (IRQs 20 21 22 23) *0, disabled.
[   31.335381] ACPI: PCI Interrupt Link [APCZ] (IRQs 20 21 22 23) *0, disabled.
[   31.335799] ACPI: PCI Interrupt Link [APSI] (IRQs 20 21 22 23) *0
[   31.336193] ACPI: PCI Interrupt Link [APSJ] (IRQs 20 21 22 23) *0
[   31.336515] ACPI: Power Resource [ISAV] (on)
[   31.336564] Linux Plug and Play Support v0.97 (c) Adam Belay
[   31.336607] pnp: PnP ACPI init
[   31.336646] ACPI: bus type pnp registered
[   31.341119] pnp: PnP ACPI: found 12 devices
[   31.341154] ACPI: ACPI bus type pnp unregistered
[   31.341221] Generic PHY: Registered new driver
[   31.341337] SCSI subsystem initialized
[   31.341392] libata version 2.20 loaded.
[   31.341440] usbcore: registered new interface driver usbfs
[   31.341499] usbcore: registered new interface driver hub
[   31.341559] usbcore: registered new device driver usb
[   31.341632] PCI: Using ACPI for IRQ routing
[   31.341668] PCI: If a device doesn't work, try "pci=routeirq".  If it helps, post a report
[   31.341720] PCI: Cannot allocate resource region 0 of device 0000:00:00.0
[   31.341857] agpgart: Detected AGP bridge 0
[   31.341894] agpgart: Setting up Nforce3 AGP.
[   31.346221] agpgart: AGP aperture is 128M @ 0xf0000000
[   31.346322] ACPI: RTC can wake from S4
[   31.346381] pnp: 00:00: ioport range 0x4000-0x407f has been reserved
[   31.346417] pnp: 00:00: ioport range 0x4080-0x40ff has been reserved
[   31.346454] pnp: 00:00: ioport range 0x4400-0x447f has been reserved
[   31.346490] pnp: 00:00: ioport range 0x4480-0x44ff has been reserved
[   31.346526] pnp: 00:00: ioport range 0x4800-0x487f has been reserved
[   31.346562] pnp: 00:00: ioport range 0x4880-0x48ff has been reserved
[   31.346602] pnp: 00:01: iomem range 0xd0000-0xd3fff has been reserved
[   31.346638] pnp: 00:01: iomem range 0xd5000-0xd7fff has been reserved
[   31.346674] pnp: 00:01: iomem range 0xf0000-0xfbfff could not be reserved
[   31.346710] pnp: 00:01: iomem range 0xfc000-0xfffff could not be reserved
[   31.346771] Time: tsc clocksource has been installed.
[   31.347336] ACPI: PCI Interrupt Link [APC4] enabled at IRQ 19
[   31.347377] ACPI: PCI Interrupt 0000:02:0c.0[A] -> Link [APC4] -> GSI 19 (level, low) -> IRQ 19
[   31.400642] ohci1394: fw-host0: OHCI-1394 1.0 (PCI): IRQ=[19]  MMIO=[fdeff000-fdeff7ff]  Max Packet=[2048]  IR/IT contexts=[4/8]
[   31.407768] PCI: Bridge: 0000:00:0b.0
[   31.407803]   IO window: 9000-9fff
[   31.407838]   MEM window: fdf00000-fdffffff
[   31.407874]   PREFETCH window: e0000000-efffffff
[   31.407911] PCI: Bridge: 0000:00:0e.0
[   31.407945]   IO window: 8000-8fff
[   31.407979]   MEM window: fde00000-fdefffff
[   31.408013]   PREFETCH window: fdd00000-fddfffff
[   31.408053] PCI: Setting latency timer of device 0000:00:0e.0 to 64
[   31.408078] NET: Registered protocol family 2
[   31.416773] IP route cache hash table entries: 131072 (order: 8, 1048576 bytes)
[   31.417480] TCP established hash table entries: 262144 (order: 10, 4194304 bytes)
[   31.421146] TCP bind hash table entries: 65536 (order: 7, 524288 bytes)
[   31.421660] TCP: Hash tables configured (established 262144 bind 65536)
[   31.421697] TCP reno registered
[   31.425313] Total HugeTLB memory allocated, 0
[   31.425508] io scheduler noop registered
[   31.425542] io scheduler anticipatory registered (default)
[   31.425586] io scheduler cfq registered
[   31.469745] Boot video device is 0000:01:00.0
[   31.470119] ACPI: PCI Interrupt Link [APC1] enabled at IRQ 16
[   31.470161] ACPI: PCI Interrupt 0000:01:00.0[A] -> Link [APC1] -> GSI 16 (level, low) -> IRQ 16
[   31.470298] radeonfb: Found Intel x86 BIOS ROM Image
[   31.470334] radeonfb: Retrieved PLL infos from BIOS
[   31.470370] radeonfb: Reference=27.00 MHz (RefDiv=12) Memory=250.00 Mhz, System=200.00 MHz
[   31.470415] radeonfb: PLL min 20000 max 40000
[   31.759268] i2c-adapter i2c-2: unable to read EDID block.
[   31.878225] i2c-adapter i2c-2: unable to read EDID block.
[   31.997181] i2c-adapter i2c-2: unable to read EDID block.
[   32.116250] i2c-adapter i2c-3: unable to read EDID block.
[   32.235206] i2c-adapter i2c-3: unable to read EDID block.
[   32.354162] i2c-adapter i2c-3: unable to read EDID block.
[   32.397399] radeonfb: Monitor 1 type DFP found
[   32.397433] radeonfb: EDID probed
[   32.397465] radeonfb: Monitor 2 type no found
[   32.429101] Console: switching to colour frame buffer device 160x64
[   32.453039] mtrr: base(0xe8000000) is not aligned on a size(0x10000000) boundary
[   32.453234] radeonfb (0000:01:00.0): ATI Radeon Ya 
[   32.453471] input: Power Button (FF) as /class/input/input0
[   32.453624] ACPI: Power Button (FF) [PWRF]
[   32.453785] input: Power Button (CM) as /class/input/input1
[   32.453936] ACPI: Power Button (CM) [PWRB]
[   32.482998] Real Time Clock Driver v1.12ac
[   32.483205] Linux agpgart interface v0.102 (c) Dave Jones
[   32.483385] [drm] Initialized drm 1.1.0 20060810
[   32.483629] [drm] Initialized radeon 1.27.0 20060524 on minor 0
[   32.483798] Serial: 8250/16550 driver $Revision: 1.90 $ 4 ports, IRQ sharing disabled
[   32.484553] 00:09: ttyS0 at I/O 0x3f8 (irq = 4) is a 16550A
[   34.549440] loop: module loaded
[   34.559694] Marvell 88E1101: Registered new driver
[   34.571650] Marvell 88E1111: Registered new driver
[   34.583513] Marvell 88E1145: Registered new driver
[   34.595253] QS6612: Registered new driver
[   34.606337] forcedeth.c: Reverse Engineered nForce ethernet driver. Version 0.60.
[   34.621427] ACPI: PCI Interrupt Link [APCH] enabled at IRQ 23
[   34.634487] ACPI: PCI Interrupt 0000:00:05.0[A] -> Link [APCH] -> GSI 23 (level, high) -> IRQ 23
[   34.650877] PCI: Setting latency timer of device 0000:00:05.0 to 64
[   34.842588] ieee1394: Host added: ID:BUS[0-00:1023]  GUID[0010dc00006c260b]
[   35.162601] eth0: forcedeth.c: subsystem: 01462:0250 bound to 0000:00:05.0
[   35.177206] tun: Universal TUN/TAP device driver, 1.6
[   35.189980] tun: (C) 1999-2004 Max Krasnyansky <maxk at qualcomm.com>
[   35.204060] r8169 Gigabit Ethernet driver 2.2LK-NAPI loaded
[   35.217697] ACPI: PCI Interrupt Link [APC5] enabled at IRQ 16
[   35.231407] ACPI: PCI Interrupt 0000:02:0d.0[A] -> Link [APC5] -> GSI 16 (level, low) -> IRQ 16
[   35.248344] eth1: RTL8169s/8110s at 0xffffc20000014000, 00:11:09:8f:4b:52, IRQ 16
[   35.267157] Uniform Multi-Platform E-IDE driver Revision: 7.00alpha2
[   35.281629] ide: Assuming 33MHz system bus speed for PIO modes; override with idebus=xx
[   35.297723] NFORCE3-250: IDE controller at PCI slot 0000:00:08.0
[   35.311694] NFORCE3-250: chipset revision 162
[   35.323939] NFORCE3-250: not 100% native mode: will probe irqs later
[   35.338316] NFORCE3-250: 0000:00:08.0 (rev a2) UDMA133 controller
[   35.352440]     ide0: BM-DMA at 0xdc00-0xdc07, BIOS settings: hda:DMA, hdb:DMA
[   35.367826]     ide1: BM-DMA at 0xdc08-0xdc0f, BIOS settings: hdc:DMA, hdd:DMA
[   35.383190] Probing IDE interface ide0...
[   36.054129] hda: PLEXTOR DVDR PX-712A, ATAPI CD/DVD-ROM drive
[   36.374065] ide0 at 0x1f0-0x1f7,0x3f6 on irq 14
[   36.388205] Probing IDE interface ide1...
[   36.906783] Probing IDE interface ide1...
[   37.426208] hda: ATAPI 40X DVD-ROM DVD-R CD-R/RW drive, 8192kB Cache, UDMA(33)
[   37.442064] Uniform CD-ROM driver Revision: 3.20
[   37.455887] sata_nv 0000:00:09.0: version 3.3
[   37.456273] ACPI: PCI Interrupt Link [APSI] enabled at IRQ 22
[   37.470259] ACPI: PCI Interrupt 0000:00:09.0[A] -> Link [APSI] -> GSI 22 (level, high) -> IRQ 22
[   37.487460] PCI: Setting latency timer of device 0000:00:09.0 to 64
[   37.487504] scsi0 : sata_nv
[   37.498639] scsi1 : sata_nv
[   37.509670] ata1: SATA max UDMA/133 cmd 0x00000000000109e0 ctl 0x0000000000010be2 bmdma 0x000000000001c800 irq 0
[   37.528385] ata2: SATA max UDMA/133 cmd 0x0000000000010960 ctl 0x0000000000010b62 bmdma 0x000000000001c808 irq 0
[   38.000352] ata1: SATA link up 1.5 Gbps (SStatus 113 SControl 300)
[   38.034729] ata1.00: ata_hpa_resize 1: sectors = 312581808, hpa_sectors = 312581808
[   38.051028] ata1.00: ATA-6: WDC WD1600SD-01KCB0, 08.02D08, max UDMA/133
[   38.066313] ata1.00: 312581808 sectors, multi 16: LBA48 
[   38.085672] ata1.00: ata_hpa_resize 1: sectors = 312581808, hpa_sectors = 312581808
[   38.101900] ata1.00: configured for UDMA/133
[   38.568143] ata2: SATA link up 1.5 Gbps (SStatus 113 SControl 300)
[   38.586156] ata2.00: ata_hpa_resize 1: sectors = 490234752, hpa_sectors = 490234752
[   38.602433] ata2.00: ATA-7: Maxtor 6L250S0, BANC1G10, max UDMA/133
[   38.617284] ata2.00: 490234752 sectors, multi 16: LBA48 NCQ (not used)
[   38.637151] ata2.00: ata_hpa_resize 1: sectors = 490234752, hpa_sectors = 490234752
[   38.653703] ata2.00: configured for UDMA/133
[   38.667032] scsi 0:0:0:0: Direct-Access     ATA      WDC WD1600SD-01K 08.0 PQ: 0 ANSI: 5
[   38.684453] sd 0:0:0:0: [sda] 312581808 512-byte hardware sectors (160042 MB)
[   38.700994] sd 0:0:0:0: [sda] Write Protect is off
[   38.715135] sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
[   38.715147] sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
[   38.733781] sd 0:0:0:0: [sda] 312581808 512-byte hardware sectors (160042 MB)
[   38.750536] sd 0:0:0:0: [sda] Write Protect is off
[   38.764888] sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
[   38.764900] sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
[   38.783597]  sda: sda1 sda2 sda3
[   38.812893] sd 0:0:0:0: [sda] Attached SCSI disk
[   38.827153] sd 0:0:0:0: Attached scsi generic sg0 type 0
[   38.842119] scsi 1:0:0:0: Direct-Access     ATA      Maxtor 6L250S0   BANC PQ: 0 ANSI: 5
[   38.860002] sd 1:0:0:0: [sdb] 490234752 512-byte hardware sectors (251000 MB)
[   38.876940] sd 1:0:0:0: [sdb] Write Protect is off
[   38.891510] sd 1:0:0:0: [sdb] Mode Sense: 00 3a 00 00
[   38.891522] sd 1:0:0:0: [sdb] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
[   38.910518] sd 1:0:0:0: [sdb] 490234752 512-byte hardware sectors (251000 MB)
[   38.927613] sd 1:0:0:0: [sdb] Write Protect is off
[   38.942343] sd 1:0:0:0: [sdb] Mode Sense: 00 3a 00 00
[   38.942355] sd 1:0:0:0: [sdb] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
[   38.961431]  sdb: sdb1 sdb2 sdb3
[   38.995056] sd 1:0:0:0: [sdb] Attached SCSI disk
[   39.009640] sd 1:0:0:0: Attached scsi generic sg1 type 0
[   39.025325] ACPI: PCI Interrupt Link [APSJ] enabled at IRQ 21
[   39.041110] ACPI: PCI Interrupt 0000:00:0a.0[A] -> Link [APSJ] -> GSI 21 (level, high) -> IRQ 21
[   39.060258] PCI: Setting latency timer of device 0000:00:0a.0 to 64
[   39.060288] scsi2 : sata_nv
[   39.073379] scsi3 : sata_nv
[   39.086327] ata3: SATA max UDMA/133 cmd 0x00000000000109f0 ctl 0x0000000000010bf2 bmdma 0x000000000001b000 irq 0
[   39.106864] ata4: SATA max UDMA/133 cmd 0x0000000000010970 ctl 0x0000000000010b72 bmdma 0x000000000001b008 irq 0
[   39.429826] ata3: SATA link down (SStatus 0 SControl 300)
[   39.747708] ata4: SATA link down (SStatus 0 SControl 300)
[   39.763457] ACPI: PCI Interrupt Link [APCL] enabled at IRQ 20
[   39.779205] ACPI: PCI Interrupt 0000:00:02.2[C] -> Link [APCL] -> GSI 20 (level, high) -> IRQ 20
[   39.798177] PCI: Setting latency timer of device 0000:00:02.2 to 64
[   39.798181] ehci_hcd 0000:00:02.2: EHCI Host Controller
[   39.813603] ehci_hcd 0000:00:02.2: new USB bus registered, assigned bus number 1
[   39.831174] ehci_hcd 0000:00:02.2: debug port 1
[   39.845724] PCI: cache line size of 64 is not supported by device 0000:00:02.2
[   39.845733] ehci_hcd 0000:00:02.2: irq 20, io mem 0xfe02d000
[   39.861338] ehci_hcd 0000:00:02.2: USB 2.0 started, EHCI 1.00, driver 10 Dec 2004
[   39.878890] usb usb1: configuration #1 chosen from 1 choice
[   39.894360] hub 1-0:1.0: USB hub found
[   39.907984] hub 1-0:1.0: 8 ports detected
[   40.022675] ohci_hcd: 2006 August 04 USB 1.1 'Open' Host Controller (OHCI) Driver
[   40.022989] ACPI: PCI Interrupt Link [APCF] enabled at IRQ 23
[   40.038592] ACPI: PCI Interrupt 0000:00:02.0[A] -> Link [APCF] -> GSI 23 (level, high) -> IRQ 23
[   40.057390] PCI: Setting latency timer of device 0000:00:02.0 to 64
[   40.057393] ohci_hcd 0000:00:02.0: OHCI Host Controller
[   40.072709] ohci_hcd 0000:00:02.0: new USB bus registered, assigned bus number 2
[   40.090167] ohci_hcd 0000:00:02.0: irq 23, io mem 0xfe02f000
[   40.158646] usb usb2: configuration #1 chosen from 1 choice
[   40.174160] hub 2-0:1.0: USB hub found
[   40.187779] hub 2-0:1.0: 4 ports detected
[   40.302835] ACPI: PCI Interrupt Link [APCG] enabled at IRQ 22
[   40.318338] ACPI: PCI Interrupt 0000:00:02.1[B] -> Link [APCG] -> GSI 22 (level, high) -> IRQ 22
[   40.336969] PCI: Setting latency timer of device 0000:00:02.1 to 64
[   40.336972] ohci_hcd 0000:00:02.1: OHCI Host Controller
[   40.352149] ohci_hcd 0000:00:02.1: new USB bus registered, assigned bus number 3
[   40.369387] ohci_hcd 0000:00:02.1: irq 22, io mem 0xfe02e000
[   40.437541] usb usb3: configuration #1 chosen from 1 choice
[   40.452887] hub 3-0:1.0: USB hub found
[   40.466327] hub 3-0:1.0: 4 ports detected
[   40.874297] usb 2-3: new full speed USB device using ohci_hcd and address 2
[   41.085446] usb 2-3: configuration #1 chosen from 1 choice
[   41.363118] usb 3-3: new low speed USB device using ohci_hcd and address 2
[   41.570293] usb 3-3: configuration #1 chosen from 1 choice
[   41.587303] usbcore: registered new interface driver libusual
[   41.602751] PNP: PS/2 Controller [PNP0303:PS2K] at 0x60,0x64 irq 1
[   41.618547] PNP: PS/2 controller doesn't have AUX irq; using default 12
[   41.885260] serio: i8042 KBD port at 0x60,0x64 irq 1
[   41.899883] mice: PS/2 mouse device common for all mice
[   41.914783] rtc_cmos 00:05: rtc core: registered rtc_cmos as rtc0
[   41.930421] rtc_cmos: probe of 00:05 failed with error -16
[   41.945341] i2c /dev entries driver
[   41.958452] usbcore: registered new interface driver hiddev
[   41.980308] input: Logitech USB-PS/2 Optical Mouse as /class/input/input2
[   41.996537] input: USB HID v1.10 Mouse [Logitech USB-PS/2 Optical Mouse] on usb-0000:00:02.1-3
[   42.014720] usbcore: registered new interface driver usbhid
[   42.029692] drivers/hid/usbhid/hid-core.c: v2.6:USB HID core driver
[   42.045348] Advanced Linux Sound Architecture Driver Version 1.0.14rc4 (Wed May 16 09:45:46 2007 UTC).
[   42.064212] input: AT Translated Set 2 keyboard as /class/input/input3
[   42.080413] ALSA device list:
[   42.092893]   No soundcards found.
[   42.105734] IPv4 over IPv4 tunneling driver
[   42.119382] GRE over IPv4 tunneling driver
[   42.132825] ip_tables: (C) 2000-2006 Netfilter Core Team
[   42.147404] TCP cubic registered
[   42.159838] Initializing XFRM netlink socket
[   42.173252] NET: Registered protocol family 1
[   42.186622] NET: Registered protocol family 10
[   42.200022] lo: Disabled Privacy Extensions
[   42.213133] tunl0: Disabled Privacy Extensions
[   42.226456] IPv6 over IPv4 tunneling driver
[   42.239456] sit0: Disabled Privacy Extensions
[   42.252429] NET: Registered protocol family 17
[   42.265559] NET: Registered protocol family 15
[   42.278484] powernow-k8: Found 1 AMD Athlon(tm) 64 Processor 3000+ processors (version 2.00.00)
[   42.295914] powernow-k8:    0 : fid 0xa (1800 MHz), vid 0x6
[   42.310052] powernow-k8:    1 : fid 0x2 (1000 MHz), vid 0x12
[   42.324499] drivers/rtc/hctosys.c: unable to open rtc device (rtc0)
[   42.359493] ReiserFS: sda2: found reiserfs format "3.6" with standard journal
[   42.375224] ReiserFS: sda2: using ordered data mode
[   42.390775] ReiserFS: sda2: journal params: device sda2, size 8192, journal first block 18, max trans len 1024, max batch 900, max commit age 30, max trans age 30
[   42.424801] ReiserFS: sda2: checking transaction log (sda2)
[   42.472400] ReiserFS: sda2: Using r5 hash to sort names
[   42.486657] VFS: Mounted root (reiserfs filesystem) readonly.
[   42.501437] Freeing unused kernel memory: 204k freed
[   45.632106] i2c-adapter i2c-4: nForce2 SMBus adapter at 0x4c00
[   45.647000] i2c-adapter i2c-5: nForce2 SMBus adapter at 0x4c40
[   45.720888] ACPI: PCI Interrupt Link [APCJ] enabled at IRQ 21
[   45.735768] ACPI: PCI Interrupt 0000:00:06.0[A] -> Link [APCJ] -> GSI 21 (level, high) -> IRQ 21
[   45.753883] PCI: Setting latency timer of device 0000:00:06.0 to 64
[   45.880576] drivers/usb/class/usblp.c: usblp0: USB Bidirectional printer dev 2 if 0 alt 0 proto 2 vid 0x04B8 pid 0x0005
[   45.900990] usbcore: registered new interface driver usblp
[   45.916052] drivers/usb/class/usblp.c: v0.13: USB Printer Device Class driver
[   45.989535] parport_pc 00:0a: reported by Plug and Play ACPI
[   46.004712] parport0: PC-style at 0x378, irq 7 [PCSPP,TRISTATE]
[   46.140509] intel8x0_measure_ac97_clock: measured 50715 usecs
[   46.155762] intel8x0: clocking to 46814
[   46.284556] ACPI: PCI Interrupt Link [APC2] enabled at IRQ 17
[   46.299793] ACPI: PCI Interrupt 0000:02:07.0[A] -> Link [APC2] -> GSI 17 (level, low) -> IRQ 17
[   46.318250] ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x02, vendor 0x4243)
[   46.335079] ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x04, vendor 0x4243)
[   46.351980] ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x01, vendor 0x4243)
[   46.368386] ssb: Core 3 found: V90 (cc 0x807, rev 0x01, vendor 0x4243)
[   46.384510] ssb: Core 4 found: PCI (cc 0x804, rev 0x07, vendor 0x4243)
[   46.400559] ssb: Core 5 found: IEEE 802.11 (cc 0x812, rev 0x04, vendor 0x4243)
[   46.417316] ssb: Ignoring additional 802.11 core
[   46.434678] ssb: Switching to PCI core, index 4
[   46.448692] ssb: Sonics Silicon Backplane found on PCI device 0000:02:07.0
[   46.465130] bcm43xx_mac80211: Broadcom 4306 WLAN found
[   46.479787] ssb: Switching to IEEE 802.11 core, index 1
[   46.501268] bcm43xx_mac80211: Found PHY: Analog 1, Type 2, Revision 1
[   46.517334] bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
[   46.541260] bcm43xx_mac80211: Radio turned off
[   46.555449] wmaster0: Selected rate control algorithm 'simple'
[   47.074260] ACPI: PCI Interrupt 0000:02:0a.0[A] -> Link [APC2] -> GSI 17 (level, low) -> IRQ 17
[   56.413386] w83627hf: Found W83627THF chip at 0x290
[   56.429428] w83627hf w83627hf.656: Reading VID from GPIO5
[   56.551910] device-mapper: ioctl: 4.11.0-ioctl (2006-10-12) initialised: dm-devel at redhat.com
[   57.003895] md: bind<sdb3>
[   57.045167] md: raid1 personality registered for level 1
[   57.061317] raid1: raid set md1 active with 1 out of 2 mirrors
[   57.103692] md: bind<sdb1>
[   57.121320] raid1: raid set md0 active with 1 out of 2 mirrors
[   58.142249] fuse init (API version 7.8)
[   58.195209] ReiserFS: sda3: found reiserfs format "3.6" with standard journal
[   58.195222] ReiserFS: sda3: using ordered data mode
[   58.220745] ReiserFS: sda3: journal params: device sda3, size 8192, journal first block 18, max trans len 1024, max batch 900, max commit age 30, max trans age 30
[   58.222426] ReiserFS: sda3: checking transaction log (sda3)
[   58.286751] ReiserFS: sda3: Using r5 hash to sort names
[   58.327342] kjournald starting.  Commit interval 5 seconds
[   58.327796] EXT3 FS on sdb2, internal journal
[   58.327800] EXT3-fs: mounted filesystem with ordered data mode.
[   58.387473] kjournald starting.  Commit interval 5 seconds
[   58.420715] EXT3 FS on dm-2, internal journal
[   58.420719] EXT3-fs: mounted filesystem with ordered data mode.
[   58.469210] kjournald starting.  Commit interval 5 seconds
[   58.475009] EXT3 FS on dm-1, internal journal
[   58.475013] EXT3-fs: mounted filesystem with ordered data mode.
[   58.503126] Adding 1048568k swap on /dev/vg0/swap.  Priority:-1 extents:1 across:1048568k
[   60.729470] bcm43xx_mac80211: Adding Interface type 2
[   60.744090] ssb: Switching to PCI core, index 4
[   60.744095] ssb: Switching to IEEE 802.11 core, index 1
[   61.036718] bcm43xx_mac80211: Loading firmware version 351.126 (2006-07-29 05:54:02)
[   61.036727] ssb: Switching to ChipCommon core, index 0
[   61.036734] ssb: Switching to IEEE 802.11 core, index 1
[   61.044914] bcm43xx_mac80211: Radio turned on
[   61.044917] bcm43xx_mac80211: Radio enabled by hardware
[   61.062801] bcm43xx_mac80211: Chip initialized
[   61.063091] bcm43xx_mac80211: 30-bit DMA initialized
[   61.063124] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063129] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063132] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063137] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063141] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063145] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063149] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063154] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063157] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063162] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063166] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063170] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063174] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063179] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063182] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.063187] bcm43xx_mac80211: TODO: Incomplete code in keymac_write() at drivers/net/wireless/mac80211/bcm43xx/bcm43xx_main.c:724
[   61.080373] bcm43xx_mac80211: Wireless interface started
[   61.084329] HW CONFIG: channel=1 freq=2412 phymode=3
[   61.095127] ADDRCONF(NETDEV_UP): wlan0: link is not ready
[   62.235543] HW CONFIG: channel=1 freq=2412 phymode=3
[   62.304515] HW CONFIG: channel=2 freq=2417 phymode=3
[   62.381486] HW CONFIG: channel=3 freq=2422 phymode=3
[   62.458461] HW CONFIG: channel=4 freq=2427 phymode=3
[   62.535433] HW CONFIG: channel=5 freq=2432 phymode=3
[   62.612403] HW CONFIG: channel=6 freq=2437 phymode=3
[   62.689375] HW CONFIG: channel=7 freq=2442 phymode=3
[   62.766344] HW CONFIG: channel=8 freq=2447 phymode=3
[   62.843316] HW CONFIG: channel=9 freq=2452 phymode=3
[   62.920288] HW CONFIG: channel=10 freq=2457 phymode=3
[   62.997260] HW CONFIG: channel=11 freq=2462 phymode=3
[   63.074232] HW CONFIG: channel=1 freq=2412 phymode=3
[   63.082479] HW CONFIG: channel=11 freq=2462 phymode=3
[   63.090539] wlan0: Initial auth_alg=0
[   63.090543] wlan0: authenticate with AP 00:0d:0b:fd:86:39
[   63.092108] wlan0: RX authentication from 00:0d:0b:fd:86:39 (alg=0 transaction=2 status=0)
[   63.092112] wlan0: authenticated
[   63.092115] wlan0: associate with AP 00:0d:0b:fd:86:39
[   63.096462] wlan0: RX AssocResp from 00:0d:0b:fd:86:39 (capab=0x431 status=0 aid=2)
[   63.096466] wlan0: associated
[   63.096486] wmaster0: Added STA 00:0d:0b:fd:86:39
[   63.099206] ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
[   67.053817] wlan0: RX deauthentication from 00:0d:0b:fd:86:39 (reason=15)
[   67.053821] wlan0: deauthenticated
[   68.053420] wlan0: authenticate with AP 00:0d:0b:fd:86:39
[   68.054958] wlan0: RX authentication from 00:0d:0b:fd:86:39 (alg=0 transaction=2 status=0)
[   68.054961] wlan0: authenticated
[   68.054964] wlan0: associate with AP 00:0d:0b:fd:86:39
[   68.057426] wlan0: RX ReassocResp from 00:0d:0b:fd:86:39 (capab=0x431 status=0 aid=2)
[   68.057428] wlan0: associated
[   68.087407] HW CONFIG: channel=1 freq=2412 phymode=3
[   68.164377] HW CONFIG: channel=2 freq=2417 phymode=3
[   68.241349] HW CONFIG: channel=3 freq=2422 phymode=3
[   68.318321] HW CONFIG: channel=4 freq=2427 phymode=3
[   68.395293] HW CONFIG: channel=5 freq=2432 phymode=3
[   68.472265] HW CONFIG: channel=6 freq=2437 phymode=3
[   68.549237] HW CONFIG: channel=7 freq=2442 phymode=3
[   68.626209] HW CONFIG: channel=8 freq=2447 phymode=3
[   68.703180] HW CONFIG: channel=9 freq=2452 phymode=3
[   68.780152] HW CONFIG: channel=10 freq=2457 phymode=3
[   68.857125] HW CONFIG: channel=11 freq=2462 phymode=3
[   68.934097] HW CONFIG: channel=11 freq=2462 phymode=3
[   72.021951] wlan0: RX deauthentication from 00:0d:0b:fd:86:39 (reason=15)
[   72.021954] wlan0: deauthenticated
[   73.020611] wlan0: authenticate with AP 00:0d:0b:fd:86:39
[   73.022204] wlan0: RX authentication from 00:0d:0b:fd:86:39 (alg=0 transaction=2 status=0)
[   73.022207] wlan0: authenticated
[   73.022210] wlan0: associate with AP 00:0d:0b:fd:86:39
[   73.025177] wlan0: RX ReassocResp from 00:0d:0b:fd:86:39 (capab=0x431 status=0 aid=2)
[   73.025180] wlan0: associated
[   73.054598] HW CONFIG: channel=1 freq=2412 phymode=3
[   73.131567] HW CONFIG: channel=2 freq=2417 phymode=3
[   73.208539] HW CONFIG: channel=3 freq=2422 phymode=3
[   73.285511] HW CONFIG: channel=4 freq=2427 phymode=3
[   73.362483] HW CONFIG: channel=5 freq=2432 phymode=3
[   73.439455] HW CONFIG: channel=6 freq=2437 phymode=3
[   73.516427] HW CONFIG: channel=7 freq=2442 phymode=3
[   73.593399] HW CONFIG: channel=8 freq=2447 phymode=3
[   73.670371] HW CONFIG: channel=9 freq=2452 phymode=3
[   73.747342] HW CONFIG: channel=10 freq=2457 phymode=3
[   73.824315] HW CONFIG: channel=11 freq=2462 phymode=3
[   73.901287] HW CONFIG: channel=11 freq=2462 phymode=3
[   74.153194] wlan0: no IPv6 routers present
[   76.982900] wlan0: RX deauthentication from 00:0d:0b:fd:86:39 (reason=15)
[   76.982903] wlan0: deauthenticated
[   77.981802] wlan0: authenticate with AP 00:0d:0b:fd:86:39
[   77.994011] wlan0: RX authentication from 00:0d:0b:fd:86:39 (alg=0 transaction=2 status=0)
[   77.994014] wlan0: authenticated
[   77.994016] wlan0: associate with AP 00:0d:0b:fd:86:39
[   77.996499] wlan0: RX ReassocResp from 00:0d:0b:fd:86:39 (capab=0x431 status=0 aid=2)
[   77.996502] wlan0: associated
[   78.025787] HW CONFIG: channel=1 freq=2412 phymode=3
[   78.102755] HW CONFIG: channel=2 freq=2417 phymode=3
[   78.179727] HW CONFIG: channel=3 freq=2422 phymode=3
[   78.256699] HW CONFIG: channel=4 freq=2427 phymode=3
[   78.333672] HW CONFIG: channel=5 freq=2432 phymode=3
[   78.410643] HW CONFIG: channel=6 freq=2437 phymode=3
[   78.487615] HW CONFIG: channel=7 freq=2442 phymode=3
[   78.564587] HW CONFIG: channel=8 freq=2447 phymode=3
[   78.641559] HW CONFIG: channel=9 freq=2452 phymode=3
[   78.718531] HW CONFIG: channel=10 freq=2457 phymode=3
[   78.795503] HW CONFIG: channel=11 freq=2462 phymode=3
[   78.872476] HW CONFIG: channel=11 freq=2462 phymode=3
[   78.995129] bcm43xx_mac80211: Using hardware based encryption for keyidx: 0, mac: 00:0d:0b:fd:86:39
[   89.404270] ppdev: user-space parallel port driver
[   94.598972] Marking TSC unstable due to cpufreq changes
[   94.599379] Time: acpi_pm clocksource has been installed.
[   99.840547] agpgart: Found an AGP 3.0 compliant device at 0000:00:00.0.
[   99.840623] agpgart: Putting AGP V3 device at 0000:00:00.0 into 8x mode
[   99.840660] agpgart: Putting AGP V3 device at 0000:01:00.0 into 8x mode
[   99.991649] [drm] Setting GART location based on new memory map
[   99.991656] [drm] Loading R200 Microcode
[   99.991684] [drm] writeback test succeeded in 1 usecs
[  111.311440] wmaster0: STA 00:0d:0b:fd:86:39 Average rate: 262 (2620/10)
[  152.460495] wmaster0: STA 00:0d:0b:fd:86:39 Average rate: 24 (265/11)
[  187.232837] wmaster0: STA 00:0d:0b:fd:86:39 Average rate: 10 (10/1)

From will.dyson at gmail.com  Sat May 26 06:10:13 2007
From: will.dyson at gmail.com (Will Dyson)
Date: Sat, 26 May 2007 00:10:13 -0400
Subject: BUG: at net/mac80211/ieee80211.c:1280 ieee80211_tx()
In-Reply-To: <200705251805.25696.flamingice@sourmilk.net>
References: <8e6f94720705251637o71a13d71w70199a3057048592@mail.gmail.com>
	<200705251805.25696.flamingice@sourmilk.net>
Message-ID: <8e6f94720705252110k46be0397v5f446aabdf34fe3f@mail.gmail.com>

On 5/25/07, Michael Wu <flamingice at sourmilk.net> wrote:
> On Friday 25 May 2007 16:37, Will Dyson wrote:
> > But I've got ton's of these in my log:
> >
> >  BUG: at net/mac80211/ieee80211.c:1280 ieee80211_tx()
> >
> Do you have CONFIG_NET_SCHED on?

I do not have it set in this kernel. Should I?

-- 
Will Dyson


From mb at bu3sch.de  Sat May 26 07:02:56 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 26 May 2007 07:02:56 +0200
Subject: BUG: at net/mac80211/ieee80211.c:1280 ieee80211_tx()
In-Reply-To: <8e6f94720705251637o71a13d71w70199a3057048592@mail.gmail.com>
References: <8e6f94720705251637o71a13d71w70199a3057048592@mail.gmail.com>
Message-ID: <200705260702.56851.mb@bu3sch.de>

On Saturday 26 May 2007 01:37, Will Dyson wrote:
> Hi all,
> 
> First, the good news: bcm43xx-mac80211 in wireless-dev now works about
> as well for me as the old driver. Similar connection reliability,
> upload speed and download speed. Woo!

Whoo, nice. :)
/me pours a bottle of beer to everybody on the list.

> But I've got ton's of these in my log:
> 
>  BUG: at net/mac80211/ieee80211.c:1280 ieee80211_tx()

Hm, probably mac80211 bug. Not sure. I didn't look at the code, yet.

>  Call Trace:
>   [<ffffffff805866a3>] ieee80211_master_start_xmit+0x5f3/0x680
>   [<ffffffff804d447d>] dev_hard_start_xmit+0x26d/0x2d0
>   [<ffffffff804e4781>] __qdisc_run+0xd1/0x260
>   [<ffffffff804d6a87>] dev_queue_xmit+0x1a7/0x370
>   [<ffffffff8058a45b>] ieee80211_subif_start_xmit+0x34b/0x590
>   [<ffffffff804ce3a7>] kfree_skb+0x17/0x30
>   [<ffffffff804d447d>] dev_hard_start_xmit+0x26d/0x2d0
>   [<ffffffff804e4781>] __qdisc_run+0xd1/0x260
>   [<ffffffff804d6a87>] dev_queue_xmit+0x1a7/0x370
>   [<ffffffff804f9bef>] ip_output+0x19f/0x340
>   [<ffffffff804f9069>] ip_queue_xmit+0x219/0x430
>   [<ffffffff80295fe0>] __pollwait+0x0/0x110
>   [<ffffffff8050a82e>] tcp_transmit_skb+0x40e/0x7c0
>   [<ffffffff8022ce00>] default_wake_function+0x0/0x10
>   [<ffffffff8050c4bb>] __tcp_push_pending_frames+0x11b/0x940
>   [<ffffffff8059c6a8>] csum_partial_copy_from_user+0x88/0x120
>   [<ffffffff80500b66>] tcp_sendmsg+0x876/0xc80
>   [<ffffffff8022ce0d>] default_wake_function+0xd/0x10
>   [<ffffffff8022ba37>] __wake_up_common+0x47/0x70
>   [<ffffffff8051e795>] inet_sendmsg+0x45/0x80
>   [<ffffffff804c7161>] sock_aio_write+0x101/0x110
>   [<ffffffff80286071>] do_sync_write+0xf1/0x130
>   [<ffffffff80246f80>] autoremove_wake_function+0x0/0x40
>   [<ffffffff8023688e>] current_fs_time+0x3e/0x40
>   [<ffffffff80286999>] vfs_write+0x159/0x170
>   [<ffffffff80286fa0>] sys_write+0x50/0x90
>   [<ffffffff8020a1ae>] system_call+0x7e/0x83
> 
> Kernel: wireless-dev latest from git
> Arch: x86-64
> 
> My boot log is attached for full hardware information.
> 


From will.dyson at gmail.com  Sat May 26 17:51:27 2007
From: will.dyson at gmail.com (Will Dyson)
Date: Sat, 26 May 2007 11:51:27 -0400
Subject: BUG: at net/mac80211/ieee80211.c:1280 ieee80211_tx()
In-Reply-To: <200705252224.18457.flamingice@sourmilk.net>
References: <8e6f94720705251637o71a13d71w70199a3057048592@mail.gmail.com>
	<200705251805.25696.flamingice@sourmilk.net>
	<8e6f94720705252110k46be0397v5f446aabdf34fe3f@mail.gmail.com>
	<200705252224.18457.flamingice@sourmilk.net>
Message-ID: <8e6f94720705260851k34c3d1fam16ab96c13375b11d@mail.gmail.com>

On 5/26/07, Michael Wu <flamingice at sourmilk.net> wrote:
> On Friday 25 May 2007 21:10, Will Dyson wrote:
> > On 5/25/07, Michael Wu <flamingice at sourmilk.net> wrote:
> > > On Friday 25 May 2007 16:37, Will Dyson wrote:
> > > > But I've got ton's of these in my log:
> > > >
> > > >  BUG: at net/mac80211/ieee80211.c:1280 ieee80211_tx()
> > >
> > > Do you have CONFIG_NET_SCHED on?
> >
> > I do not have it set in this kernel. Should I?
> It may help. mac80211 didn't work correctly without it before and I'm not
> entirely sure if it works correctly now without that.

Ok. I'll try it.

For what it's worth, I can no-longer reproduce this error (although it
was reproducible across several reboots yesterday).

-- 
Will Dyson


From kaba at kafta.de  Sat May 26 17:58:47 2007
From: kaba at kafta.de (Kay Bach)
Date: Sat, 26 May 2007 17:58:47 +0200
Subject: device for the list
Message-ID: <46585937.3010200@kafta.de>

Hi,

I got the following card working, maybe you could add it to the list:

Vendor: Ravotek
Product: WLC3010 // W54-CS
Chip ID: (probably) 4306
Product ID: 0x4320
Subsystem Vendor ID: 0x144f
Subsystem Product ID: 0x7053

linked with 24Mb/s

--kay


From Larry.Finger at lwfinger.net  Sat May 26 19:09:34 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 26 May 2007 12:09:34 -0500
Subject: [PATCH] bcm43xx-mac80211: Fix for tx_bias equal to 0xFF
Message-ID: <465869ce.8wcEX9q9ZmHxX2m3%Larry.Finger@lwfinger.net>

Index: wireless-mb/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
===================================================================
--- wireless-mb.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
+++ wireless-mb/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
@@ -4122,6 +4122,10 @@ void bcm43xx_radio_set_txpower_bg(struct
 	tx_magn = _tx_magn;
 	phy->bbatt = baseband_attenuation;
 	phy->rfatt = radio_attenuation;
+	if (tx_bias == 0xFF) {
+		bcm43xx_lo_g_measure(dev);
+		tx_bias = phy->lo_control->tx_bias;
+	}
 
 	/* Set Baseband Attenuation on device. */
 	bcm43xx_phy_set_baseband_attenuation(dev, baseband_attenuation);


From mb at bu3sch.de  Sat May 26 19:19:38 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 26 May 2007 19:19:38 +0200
Subject: [PATCH] bcm43xx-mac80211: Fix for tx_bias equal to 0xFF
In-Reply-To: <465869ce.8wcEX9q9ZmHxX2m3%Larry.Finger@lwfinger.net>
References: <465869ce.8wcEX9q9ZmHxX2m3%Larry.Finger@lwfinger.net>
Message-ID: <200705261919.39143.mb@bu3sch.de>

On Saturday 26 May 2007 19:09:34 Larry Finger wrote:
> Index: wireless-mb/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
> ===================================================================
> --- wireless-mb.orig/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
> +++ wireless-mb/drivers/net/wireless/mac80211/bcm43xx/bcm43xx_phy.c
> @@ -4122,6 +4122,10 @@ void bcm43xx_radio_set_txpower_bg(struct
>  	tx_magn = _tx_magn;
>  	phy->bbatt = baseband_attenuation;
>  	phy->rfatt = radio_attenuation;
> +	if (tx_bias == 0xFF) {
> +		bcm43xx_lo_g_measure(dev);
> +		tx_bias = phy->lo_control->tx_bias;
> +	}
>  
>  	/* Set Baseband Attenuation on device. */
>  	bcm43xx_phy_set_baseband_attenuation(dev, baseband_attenuation);

Ok, on which specification bits is this actually based? :)
txpower_bg still needs a rewrite, and I have a patch for that in
the pipeline, but it's still buggy due to missing specs stuff.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sat May 26 19:55:30 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 26 May 2007 12:55:30 -0500
Subject: [PATCH] bcm43xx-mac80211: Fix for tx_bias equal to 0xFF
In-Reply-To: <200705261919.39143.mb@bu3sch.de>
References: <465869ce.8wcEX9q9ZmHxX2m3%Larry.Finger@lwfinger.net>
	<200705261919.39143.mb@bu3sch.de>
Message-ID: <46587492.6070106@lwfinger.net>

Michael Buesch wrote:
> 
> Ok, on which specification bits is this actually based? :)
> txpower_bg still needs a rewrite, and I have a patch for that in
> the pipeline, but it's still buggy due to missing specs stuff.
> 

It is not in the V4 specifications that I have found, but the V3 (softmac) driver does this "fixup". 
With it, my 4311 connects with bcm43xx-mac80211. Without it, no connection.

Larry




From mb at bu3sch.de  Sat May 26 19:56:54 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 26 May 2007 19:56:54 +0200
Subject: [PATCH] bcm43xx-mac80211: Fix for tx_bias equal to 0xFF
In-Reply-To: <46587492.6070106@lwfinger.net>
References: <465869ce.8wcEX9q9ZmHxX2m3%Larry.Finger@lwfinger.net>
	<200705261919.39143.mb@bu3sch.de> <46587492.6070106@lwfinger.net>
Message-ID: <200705261956.54398.mb@bu3sch.de>

On Saturday 26 May 2007 19:55:30 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > Ok, on which specification bits is this actually based? :)
> > txpower_bg still needs a rewrite, and I have a patch for that in
> > the pipeline, but it's still buggy due to missing specs stuff.
> > 
> 
> It is not in the V4 specifications that I have found, but the V3 (softmac) driver does this "fixup". 
> With it, my 4311 connects with bcm43xx-mac80211. Without it, no connection.

Hm, very interesting. I'll take a look at it, then.

-- 
Greetings Michael.


From ftoledo at docksud.com.ar  Sat May 26 20:25:39 2007
From: ftoledo at docksud.com.ar (Fernando Toledo)
Date: Sat, 26 May 2007 15:25:39 -0300
Subject: switching to wireless-dev
Message-ID: <200705261525.41400.ftoledo@docksud.com.ar>

hi all
i test my bcm4311 from my HP nx7400 with the wireless-dev git tree (mac80211) 
and want to report some things:
i found that the speed is very similar to the old softmac driver (Good!)
networkmanager just connect on firstime (Good!)

ragnarok at ntbkragnarok:~$ dmesg |grep bcm
bcm43xx_mac80211: Broadcom 4311 WLAN found
bcm43xx_mac80211: Found PHY: Analog 4, Type 2, Revision 8
bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
bcm43xx_mac80211: Radio turned off
bcm43xx_mac80211: Adding Interface type 2
bcm43xx_mac80211: Loading firmware version 319.102 (2005-10-15 22:46:19)
bcm43xx_mac80211: Radio turned on
bcm43xx_mac80211: Radio enabled by hardware
bcm43xx_mac80211: !WARNING! Idle-TSSI phy->cur_idle_tssi measuring failed. 
(cur=26, tgt=62). Disabling TX power adjustment.
bcm43xx_mac80211: Chip initialized
bcm43xx_mac80211: 32-bit DMA initialized
bcm43xx_mac80211: Wireless interface started

i see above one warning that i dont know what mean .

my interface was change from eth1 to wlan0


-- 
Dock Sud BBS
http://www.docksud.com.ar
telnet://bbs.docksud.com.ar
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070526/3663271a/attachment.pgp>

From larry.finger at lwfinger.net  Sat May 26 21:45:40 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 26 May 2007 14:45:40 -0500
Subject: switching to wireless-dev
In-Reply-To: <200705261525.41400.ftoledo@docksud.com.ar>
References: <200705261525.41400.ftoledo@docksud.com.ar>
Message-ID: <46588E64.5080205@lwfinger.net>

Fernando Toledo wrote:
> hi all
> i test my bcm4311 from my HP nx7400 with the wireless-dev git tree (mac80211) 
> and want to report some things:
> i found that the speed is very similar to the old softmac driver (Good!)
> networkmanager just connect on firstime (Good!)
> 
> ragnarok at ntbkragnarok:~$ dmesg |grep bcm
> bcm43xx_mac80211: Broadcom 4311 WLAN found
> bcm43xx_mac80211: Found PHY: Analog 4, Type 2, Revision 8
> bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> bcm43xx_mac80211: Radio turned off
> bcm43xx_mac80211: Adding Interface type 2
> bcm43xx_mac80211: Loading firmware version 319.102 (2005-10-15 22:46:19)
> bcm43xx_mac80211: Radio turned on
> bcm43xx_mac80211: Radio enabled by hardware
> bcm43xx_mac80211: !WARNING! Idle-TSSI phy->cur_idle_tssi measuring failed. 
> (cur=26, tgt=62). Disabling TX power adjustment.
> bcm43xx_mac80211: Chip initialized
> bcm43xx_mac80211: 32-bit DMA initialized
> bcm43xx_mac80211: Wireless interface started
> 
> i see above one warning that i dont know what mean .

I sent a patch to Michael today that fixes the condition that causes this warning.

> my interface was change from eth1 to wlan0

Your interface should not be renamed if you add a rule to 
/etc/udev/rules.d/30-net_persistent_names.rules that looks like the following (change the address 
fields to match your device - this is the MAC address of my 4311):

SUBSYSTEM=="net", ACTION=="add", SYSFS{address}=="00:1a:73:04:1d:e5", \ 
IMPORT="/lib/udev/rename_netiface %k eth1"

Is it possible for you to use Iperf to test your link? The reason I ask is that my 4311 gets maximum 
transmit and receive rates of 4.16 and 1.60 Mb/s, respectively, using bcm43xx-mac80211. By contrast, 
bcm43xx-softmac gets 14.6 and 12.7 Mb/s using the identical hardware configuration. I would like to 
know if there is something different here.

Larry




From mb at bu3sch.de  Sat May 26 22:18:08 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 26 May 2007 22:18:08 +0200
Subject: [PATCH] bcm43xx-mac80211: Fix for tx_bias equal to 0xFF
In-Reply-To: <46587492.6070106@lwfinger.net>
References: <465869ce.8wcEX9q9ZmHxX2m3%Larry.Finger@lwfinger.net>
	<200705261919.39143.mb@bu3sch.de> <46587492.6070106@lwfinger.net>
Message-ID: <200705262218.08413.mb@bu3sch.de>

On Saturday 26 May 2007 19:55:30 Larry Finger wrote:
> With it, my 4311 connects with bcm43xx-mac80211. Without it, no connection.

Ok, it seems to fix the itssi thing, but that re-enables
txpower adjustment, which reveals the whole bunch of bugs in there. :)
So before I can merge this, I have to fix these bugs there.

-- 
Greetings Michael.


From mb at bu3sch.de  Sat May 26 22:06:53 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 26 May 2007 22:06:53 +0200
Subject: [PATCH] bcm43xx-mac80211: Fix for tx_bias equal to 0xFF
In-Reply-To: <46587492.6070106@lwfinger.net>
References: <465869ce.8wcEX9q9ZmHxX2m3%Larry.Finger@lwfinger.net>
	<200705261919.39143.mb@bu3sch.de> <46587492.6070106@lwfinger.net>
Message-ID: <200705262206.53388.mb@bu3sch.de>

On Saturday 26 May 2007 19:55:30 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > Ok, on which specification bits is this actually based? :)
> > txpower_bg still needs a rewrite, and I have a patch for that in
> > the pipeline, but it's still buggy due to missing specs stuff.
> > 
> 
> It is not in the V4 specifications that I have found, but the V3 (softmac) driver does this "fixup". 

I cannot find this in the sm driver. Can you give me a hint
where to search?

> With it, my 4311 connects with bcm43xx-mac80211. Without it, no connection.

Ok, nice.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sat May 26 23:11:34 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 26 May 2007 16:11:34 -0500
Subject: [PATCH] bcm43xx-mac80211: Fix for tx_bias equal to 0xFF
In-Reply-To: <200705262206.53388.mb@bu3sch.de>
References: <465869ce.8wcEX9q9ZmHxX2m3%Larry.Finger@lwfinger.net>
	<200705261919.39143.mb@bu3sch.de> <46587492.6070106@lwfinger.net>
	<200705262206.53388.mb@bu3sch.de>
Message-ID: <4658A286.1050204@lwfinger.net>

Michael Buesch wrote:
> On Saturday 26 May 2007 19:55:30 Larry Finger wrote:
>> Michael Buesch wrote:
>>> Ok, on which specification bits is this actually based? :)
>>> txpower_bg still needs a rewrite, and I have a patch for that in
>>> the pipeline, but it's still buggy due to missing specs stuff.
>>>
>> It is not in the V4 specifications that I have found, but the V3 (softmac) driver does this "fixup". 
> 
> I cannot find this in the sm driver. Can you give me a hint
> where to search?
> 
>> With it, my 4311 connects with bcm43xx-mac80211. Without it, no connection.
> 
> Ok, nice.
> 

My memory was faulty earlier, but it is coming back. V3 differs in that txctl1 (the equivalent of 
tx_bias) is not initialized to 0xFF, but is given a value of 0-3 in bcm43xx_default_txctl1. I added 
trace code that checked the value being written to radio register 0x52 and dumped the stack when the 
value was still 0xFF. On that basis, I made it look like the code in bcm43xx_phy_initg when tx_bias 
is 0xFF.

Would you prefer the equivalent of bcm43xx_default_txctl1? That wouldn't be difficult.

Are the txpower adjustment bugs a problem with the specs? Is there anything I can do?

Larry

Larry


From mb at bu3sch.de  Sat May 26 23:13:35 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 26 May 2007 23:13:35 +0200
Subject: [PATCH] bcm43xx-mac80211: Fix for tx_bias equal to 0xFF
In-Reply-To: <4658A286.1050204@lwfinger.net>
References: <465869ce.8wcEX9q9ZmHxX2m3%Larry.Finger@lwfinger.net>
	<200705262206.53388.mb@bu3sch.de> <4658A286.1050204@lwfinger.net>
Message-ID: <200705262313.35300.mb@bu3sch.de>

On Saturday 26 May 2007 23:11:34 Larry Finger wrote:
> Michael Buesch wrote:
> > On Saturday 26 May 2007 19:55:30 Larry Finger wrote:
> >> Michael Buesch wrote:
> >>> Ok, on which specification bits is this actually based? :)
> >>> txpower_bg still needs a rewrite, and I have a patch for that in
> >>> the pipeline, but it's still buggy due to missing specs stuff.
> >>>
> >> It is not in the V4 specifications that I have found, but the V3 (softmac) driver does this "fixup". 
> > 
> > I cannot find this in the sm driver. Can you give me a hint
> > where to search?
> > 
> >> With it, my 4311 connects with bcm43xx-mac80211. Without it, no connection.
> > 
> > Ok, nice.
> > 
> 
> My memory was faulty earlier, but it is coming back. V3 differs in that txctl1 (the equivalent of 
> tx_bias) is not initialized to 0xFF, but is given a value of 0-3 in bcm43xx_default_txctl1. I added 
> trace code that checked the value being written to radio register 0x52 and dumped the stack when the 
> value was still 0xFF. On that basis, I made it look like the code in bcm43xx_phy_initg when tx_bias 
> is 0xFF.
> 
> Would you prefer the equivalent of bcm43xx_default_txctl1? That wouldn't be difficult.

Ok, I have patches that are designed to fix this. But still not done.

> Are the txpower adjustment bugs a problem with the specs? Is there anything I can do?

I'm not sure what causes this, yet. It's either a bug in estimating
the current power or in calculating the new attenuation values.

-- 
Greetings Michael.


From josejx at gentoo.org  Sat May 26 23:41:53 2007
From: josejx at gentoo.org (Joseph Jezak)
Date: Sat, 26 May 2007 17:41:53 -0400
Subject: [PATCH] bcm43xx-mac80211: Fix for tx_bias equal to 0xFF
In-Reply-To: <200705262313.35300.mb@bu3sch.de>
References: <465869ce.8wcEX9q9ZmHxX2m3%Larry.Finger@lwfinger.net>	<200705262206.53388.mb@bu3sch.de>
	<4658A286.1050204@lwfinger.net> <200705262313.35300.mb@bu3sch.de>
Message-ID: <4658A9A1.9080800@gentoo.org>

 >> Are the txpower adjustment bugs a problem with the specs? Is
there anything I can do?
> 
> I'm not sure what causes this, yet. It's either a bug in estimating
> the current power or in calculating the new attenuation values.
> 

I'm working on updating the v4 specs for estimating the current
power, hopefully I'll finish for tomorrow.  I think the calculation
fo the new attenuation values is okay, but looking over it again
can't hurt.

-Joe


From Larry.Finger at lwfinger.net  Sun May 27 05:21:29 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 26 May 2007 22:21:29 -0500
Subject: [PATCH] bcm43xx: Fix deviation from specifications in
	set_baseband_attenuation
Message-ID: <4658f939.o0RS7oOgyDNm1a6Y%Larry.Finger@lwfinger.net>

A disagreement between the specifications and the bcm43xx code has just
been discovered and is hereby fixed.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This patch should be applied to wireless-2.6. Although it is a bug fix,
it doesn't seem to have much effect on performance. As a result, do not
bother to send it to upstream-fixes.

Larry

Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
+++ wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
@@ -1638,7 +1638,7 @@ void bcm43xx_phy_set_baseband_attenuatio
 		return;
 	}
 
-	if (phy->analog > 1) {
+	if (phy->analog == 1) {
 		value = bcm43xx_phy_read(bcm, 0x0060) & ~0x003C;
 		value |= (baseband_attenuation << 2) & 0x003C;
 	} else {


From johannes at sipsolutions.net  Sun May 27 15:23:17 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Sun, 27 May 2007 15:23:17 +0200
Subject: IPV6 autoconf problems
In-Reply-To: <20070527.101807.00298019.yoshfuji@linux-ipv6.org>
References: <Pine.LNX.4.64.0705251956190.29153@rivendell.nexusuk.org>
	<1180135028.8303.215.camel@shinybook.infradead.org>
	<Pine.LNX.4.64.0705262258040.4411@rivendell.nexusuk.org>
	<20070527.101807.00298019.yoshfuji@linux-ipv6.org>
Message-ID: <1180272197.3604.61.camel@johannes.berg>

On Sun, 2007-05-27 at 10:18 +0900, YOSHIFUJI Hideaki / ???? wrote:

> It seems this is a kind of "simplex" issue and you should fix
> in your driver.
> Note: we had a similar issue before in madwifi.

Could you elaborate on that? I think that the fix would belong into
mac80211 but I'm not sure what it would entail.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070527/df429c5d/attachment.pgp>

From ftoledo at docksud.com.ar  Mon May 28 01:24:43 2007
From: ftoledo at docksud.com.ar (Fernando Toledo)
Date: Sun, 27 May 2007 20:24:43 -0300
Subject: switching to wireless-dev
In-Reply-To: <46588E64.5080205@lwfinger.net>
References: <200705261525.41400.ftoledo@docksud.com.ar>
	<46588E64.5080205@lwfinger.net>
Message-ID: <200705272024.45555.ftoledo@docksud.com.ar>

El S?bado, 26 de Mayo de 2007 16:45, Larry Finger escribi?:
> Fernando Toledo wrote:
> > i see above one warning that i dont know what mean .
>
> I sent a patch to Michael today that fixes the condition that causes this
> warning.
>
> > my interface was change from eth1 to wlan0
>
> Your interface should not be renamed if you add a rule to
> /etc/udev/rules.d/30-net_persistent_names.rules that looks like the
> following (change the address fields to match your device - this is the MAC
> address of my 4311):
>
> SUBSYSTEM=="net", ACTION=="add", SYSFS{address}=="00:1a:73:04:1d:e5", \
> IMPORT="/lib/udev/rename_netiface %k eth1"
ok , thanks!
>
> Is it possible for you to use Iperf to test your link? The reason I ask is
> that my 4311 gets maximum transmit and receive rates of 4.16 and 1.60 Mb/s,
> respectively, using bcm43xx-mac80211. By contrast, bcm43xx-softmac gets
> 14.6 and 12.7 Mb/s using the identical hardware configuration. I would like
> to know if there is something different here.

ragnarok at ntbkragnarok:~$ iperf -c 192.168.10.20 -p 5000
------------------------------------------------------------
Client connecting to 192.168.10.20, TCP port 5000
TCP window size: 16.0 KByte (default)
------------------------------------------------------------
[  3] local 192.168.10.21 port 43078 connected with 192.168.10.20 port 5000
[  3]  0.0-10.1 sec  6.69 MBytes  5.57 Mbits/sec

i connect to dlink 11mb ap not 54mb
i dont remember now , but i think that on softmac (2.6.21)  i have similar 
results

-- 
Dock Sud BBS
http://www.docksud.com.ar
telnet://bbs.docksud.com.ar
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070527/cd31df02/attachment.pgp>

From larry.finger at lwfinger.net  Mon May 28 02:59:49 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 27 May 2007 19:59:49 -0500
Subject: switching to wireless-dev
In-Reply-To: <200705272024.45555.ftoledo@docksud.com.ar>
References: <200705261525.41400.ftoledo@docksud.com.ar>	<46588E64.5080205@lwfinger.net>
	<200705272024.45555.ftoledo@docksud.com.ar>
Message-ID: <465A2985.6000907@lwfinger.net>

Fernando Toledo wrote:
> 
> ragnarok at ntbkragnarok:~$ iperf -c 192.168.10.20 -p 5000
> ------------------------------------------------------------
> Client connecting to 192.168.10.20, TCP port 5000
> TCP window size: 16.0 KByte (default)
> ------------------------------------------------------------
> [  3] local 192.168.10.21 port 43078 connected with 192.168.10.20 port 5000
> [  3]  0.0-10.1 sec  6.69 MBytes  5.57 Mbits/sec
> 
> i connect to dlink 11mb ap not 54mb
> i dont remember now , but i think that on softmac (2.6.21)  i have similar 
> results

That is about what I get for transmission at 11M. If you add a '-r' switch at the end of the iperf 
command, you will also get the receive rate. On mine, it is about 0.8 Mbits/sec.

Larry



From ftoledo at docksud.com.ar  Mon May 28 06:14:36 2007
From: ftoledo at docksud.com.ar (Fernando Toledo)
Date: Mon, 28 May 2007 01:14:36 -0300
Subject: switching to wireless-dev
In-Reply-To: <465A2985.6000907@lwfinger.net>
References: <200705261525.41400.ftoledo@docksud.com.ar>
	<200705272024.45555.ftoledo@docksud.com.ar>
	<465A2985.6000907@lwfinger.net>
Message-ID: <200705280114.38356.ftoledo@docksud.com.ar>

El Domingo, 27 de Mayo de 2007 21:59, Larry Finger escribi?:
> Fernando Toledo wrote:
> > ragnarok at ntbkragnarok:~$ iperf -c 192.168.10.20 -p 5000
> > ------------------------------------------------------------
> > Client connecting to 192.168.10.20, TCP port 5000
> > TCP window size: 16.0 KByte (default)
> > ------------------------------------------------------------
> > [  3] local 192.168.10.21 port 43078 connected with 192.168.10.20 port
> > 5000 [  3]  0.0-10.1 sec  6.69 MBytes  5.57 Mbits/sec
> >
> > i connect to dlink 11mb ap not 54mb
> > i dont remember now , but i think that on softmac (2.6.21)  i have
> > similar results
>
> That is about what I get for transmission at 11M. If you add a '-r' switch
> at the end of the iperf command, you will also get the receive rate. On
> mine, it is about 0.8 Mbits/sec.
>
> Larry

ragnarok at ntbkragnarok:~$ iperf -c 192.168.10.20 -p 5000 -r  
------------------------------------------------------------
Server listening on TCP port 5000
TCP window size: 85.3 KByte (default)
------------------------------------------------------------
------------------------------------------------------------
Client connecting to 192.168.10.20, TCP port 5000
TCP window size: 16.0 KByte (default)
------------------------------------------------------------
[  5] local 192.168.10.21 port 60530 connected with 192.168.10.20 port 5000
[  5]  0.0-10.1 sec  4.03 MBytes  3.36 Mbits/sec
[  4] local 192.168.10.21 port 5000 connected with 192.168.10.20 port 2927
[  4]  0.0-10.5 sec  1.81 MBytes  1.45 Mbits/sec
ragnarok at ntbkragnarok:~$ 

is 1.45 Mbits/sec the value ?

-- 
Dock Sud BBS
http://www.docksud.com.ar
telnet://bbs.docksud.com.ar
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070528/08ec85e9/attachment.pgp>

From larry.finger at lwfinger.net  Mon May 28 06:48:22 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 27 May 2007 23:48:22 -0500
Subject: switching to wireless-dev
In-Reply-To: <200705280114.38356.ftoledo@docksud.com.ar>
References: <200705261525.41400.ftoledo@docksud.com.ar>
	<200705272024.45555.ftoledo@docksud.com.ar>
	<465A2985.6000907@lwfinger.net>
	<200705280114.38356.ftoledo@docksud.com.ar>
Message-ID: <465A5F16.2080108@lwfinger.net>

Fernando Toledo wrote:
> ragnarok at ntbkragnarok:~$ iperf -c 192.168.10.20 -p 5000 -r  
> ------------------------------------------------------------
> Server listening on TCP port 5000
> TCP window size: 85.3 KByte (default)
> ------------------------------------------------------------
> ------------------------------------------------------------
> Client connecting to 192.168.10.20, TCP port 5000
> TCP window size: 16.0 KByte (default)
> ------------------------------------------------------------
> [  5] local 192.168.10.21 port 60530 connected with 192.168.10.20 port 5000
> [  5]  0.0-10.1 sec  4.03 MBytes  3.36 Mbits/sec
> [  4] local 192.168.10.21 port 5000 connected with 192.168.10.20 port 2927
> [  4]  0.0-10.5 sec  1.81 MBytes  1.45 Mbits/sec
> ragnarok at ntbkragnarok:~$ 
> 
> is 1.45 Mbits/sec the value ?

Yes - 3.36 is the transmit rate and 1.45 Mbits/sec is the receive rate.

Larry


From vincent at xtra-net.org  Tue May 29 21:42:18 2007
From: vincent at xtra-net.org (Vincent Blondel)
Date: Tue, 29 May 2007 21:42:18 +0200 (CEST)
Subject: Belkin Wireless PCMCIA F5D7010.
Message-ID: <37792.172.16.9.1.1180467738.squirrel@www.xtra-net.be>


Hello all,

I am trying to make my brand new Belkin Wireless PCMCIA F5D7010
(Ver.7000df) working on a Debian/Etch distro with my laptop HP Omnibook
6000 but this goes wrong.

When I list the devices I get this :

debian:# lspci -v

06:00.0 Ethernet controller: Belkin Unknown device 701f (rev 20)
        Subsystem: Belkin Unknown device 701f
        Flags: medium devsel, IRQ 10
        I/O ports at 2800 [disabled] [size=256]
        Memory at 26000000 (32-bit, non-prefetchable) [disabled] [size=1K]
        Capabilities: [50] Power Management version 2

I already tried lots of modules like rt2500, ndiswrapper, bcm43xx but it
seems my card is not recognized.

Can somebody help troubleshoot this problem, say me if this problem is
solved by a new version ???

Regards
Vincent.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070529/6c6fdc0d/attachment.html>

From gavron at wetwork.net  Tue May 29 22:28:18 2007
From: gavron at wetwork.net (Ehud Gavron)
Date: Tue, 29 May 2007 13:28:18 -0700
Subject: Belkin Wireless PCMCIA F5D7010.
In-Reply-To: <37792.172.16.9.1.1180467738.squirrel@www.xtra-net.be>
References: <37792.172.16.9.1.1180467738.squirrel@www.xtra-net.be>
Message-ID: <465C8CE2.8070706@wetwork.net>

Vincent Blondel wrote:
> Hello all,
>
> I am trying to make my brand new Belkin Wireless PCMCIA F5D7010
> (Ver.7000df) working on a Debian/Etch distro with my laptop HP Omnibook
> 6000 but this goes wrong.
>   
What goes wrong?
> When I list the devices I get this :
>
> debian:# lspci -v
>
> 06:00.0 Ethernet controller: Belkin Unknown device 701f (rev 20)
>         Subsystem: Belkin Unknown device 701f
>         Flags: medium devsel, IRQ 10
>         I/O ports at 2800 [disabled] [size=256]
>         Memory at 26000000 (32-bit, non-prefetchable) [disabled] [size=1K]
>         Capabilities: [50] Power Management version 2
>
> I already tried lots of modules like rt2500, ndiswrapper, bcm43xx but it
> seems my card is not recognized.
>   
What drivers did you try with ndiswrapper?  What errors did you get?  
Did you try the ones off the CD that came with it?  Did you try the ones 
downloadable from places on the net? 

Different versions of this card use different chipsets including the 
rt2500, rtl8xxx, bcmxxx, etc.  That's why using the drivers that came 
with your HP or identifying the device for certain would be useful.

> Can somebody help troubleshoot this problem, say me if this problem is
> solved by a new version ???
>   
New version of what?  You haven't mentioned which version of the card 
you have... so we don't know.  You haven't mentioned which version of 
which drivers you tried... you haven't mentioned what ndiswrapper -l 
showed or what dmesg showed...   and in three attachments provided only 
an lspci -v, which (while interesting) is not good enough for us to tell 
us how to help you :)

Ehud
> Regards
> Vincent.
>   
>
> ------------------------------------------------------------------------
>
> Hello all,
>
> I am trying to make my brand new Belkin Wireless PCMCIA F5D7010 
> (Ver.7000df) working on a Debian/Etch distro but this is not working.
> ------------------------------------------------------------------------
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070529/a529aeb9/attachment.bin>

From proski at gnu.org  Wed May 30 02:45:39 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 29 May 2007 20:45:39 -0400
Subject: Belkin Wireless PCMCIA F5D7010.
In-Reply-To: <37792.172.16.9.1.1180467738.squirrel@www.xtra-net.be>
References: <37792.172.16.9.1.1180467738.squirrel@www.xtra-net.be>
Message-ID: <1180485939.7204.10.camel@dv>

On Tue, 2007-05-29 at 21:42 +0200, Vincent Blondel wrote:
> Hello all,
> 
> I am trying to make my brand new Belkin Wireless PCMCIA F5D7010
> (Ver.7000df) working on a Debian/Etch distro with my laptop HP Omnibook
> 6000 but this goes wrong.

There is a Windows driver on the Belkin site for this device, called
F5D7010v7000.exe.  In can be unpacked with unzip.  The actual driver,
called BLKWGNv7.sys has this string inside:

Realtek RTL8185 driver

> I already tried lots of modules like rt2500, ndiswrapper, bcm43xx but it
> seems my card is not recognized.

I think next stop should be http://rtl8180-sa2400.sourceforge.net/
There are also Linux hardware compatibility database(s).  There are also
mailing lists for all Linux wireless issues.  Please avoid asking for
help with identification in a mailing list for one specific driver
without a good reason to assume that it's the driver you need.

> Can somebody help troubleshoot this problem, say me if this problem is
> solved by a new version ???

Not me.  And not in this list.

-- 
Regards,
Pavel Roskin



From zajec5polish at gmail.com  Wed May 30 10:24:29 2007
From: zajec5polish at gmail.com (=?UTF-8?Q?Rafa=C5=82_Mi=C5=82ecki?=)
Date: Wed, 30 May 2007 10:24:29 +0200
Subject: Problem with connecting in some place
In-Reply-To: <4641E4BA.30200@lwfinger.net>
References: <14b026160705090704w497bab4bybd0d7f3b891c162d@mail.gmail.com>
	<4641E4BA.30200@lwfinger.net>
Message-ID: <14b026160705300124x335b1864xbbd940db32a0b079@mail.gmail.com>

2007/5/9, Larry Finger <larry.finger at lwfinger.net>:
> There are some problems with bcm43xx in a crowded environment; however, I think your problems are
> with signal strength. The iwconfig log shows only very low signal levels. I see that you are using
> 2.6.21. Have you patched bcm43xx? If not, that will help some. In addition, your school has designed
> your networks badly. Channels 9 and 13 interfere with each other. If they are going to put all their
> AP's on only 2 channels, they should use 8 and 13.

Unfortunately channels of APs didn't change.

I tested this network again, using 2.6.22-rc2-git7-20-default and I
was not able to connect. I made a small log of /var/log/messages,
maybe it contains some usefully info?

Ah, and one more fact. I think I have some problems with iwlist now:


acer:/home/zajec # iwlist scan
lo        Interface doesn't support scanning.

irda0     Interface doesn't support scanning.

eth0      Interface doesn't support scanning.

Warning: Driver for device wlan0 has been compiled with version 22
of Wireless Extension, while this program supports up to version 21.
Some things may be broken...

wlan0     Scan completed :


But on the other hand I can connect to network in 3 not crowded env
without problems...

-- 
Rafa? Mi?ecki
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: bcm.log.txt
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070530/25c8e0d0/attachment.txt>

From larry.finger at lwfinger.net  Wed May 30 15:55:18 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 30 May 2007 08:55:18 -0500
Subject: Problem with connecting in some place
In-Reply-To: <14b026160705300124x335b1864xbbd940db32a0b079@mail.gmail.com>
References: <14b026160705090704w497bab4bybd0d7f3b891c162d@mail.gmail.com>	<4641E4BA.30200@lwfinger.net>
	<14b026160705300124x335b1864xbbd940db32a0b079@mail.gmail.com>
Message-ID: <465D8246.8070902@lwfinger.net>

Rafa? Mi?ecki wrote:
> 2007/5/9, Larry Finger <larry.finger at lwfinger.net>:
>> There are some problems with bcm43xx in a crowded environment; 
>> however, I think your problems are
>> with signal strength. The iwconfig log shows only very low signal 
>> levels. I see that you are using
>> 2.6.21. Have you patched bcm43xx? If not, that will help some. In 
>> addition, your school has designed
>> your networks badly. Channels 9 and 13 interfere with each other. If 
>> they are going to put all their
>> AP's on only 2 channels, they should use 8 and 13.
> 
> Unfortunately channels of APs didn't change.
> 
> I tested this network again, using 2.6.22-rc2-git7-20-default and I
> was not able to connect. I made a small log of /var/log/messages,
> maybe it contains some usefully info?
> 
> Ah, and one more fact. I think I have some problems with iwlist now:
> 
> 
> acer:/home/zajec # iwlist scan
> lo        Interface doesn't support scanning.
> 
> irda0     Interface doesn't support scanning.
> 
> eth0      Interface doesn't support scanning.
> 
> Warning: Driver for device wlan0 has been compiled with version 22
> of Wireless Extension, while this program supports up to version 21.
> Some things may be broken...
> 
> wlan0     Scan completed :
> 
> 
> But on the other hand I can connect to network in 3 not crowded env
> without problems...
> 
> 
> ------------------------------------------------------------------------
> 
> May 30 08:10:42 acer kernel: bcm43xx: Radio turned off
> May 30 08:10:42 acer kernel: bcm43xx: DMA-32 0x0200 (RX) max used slots: 1/64
> May 30 08:10:42 acer kernel: bcm43xx: DMA-32 0x02A0 (TX) max used slots: 0/512
> May 30 08:10:42 acer kernel: bcm43xx: DMA-32 0x0280 (TX) max used slots: 0/512
> May 30 08:10:42 acer kernel: bcm43xx: DMA-32 0x0260 (TX) max used slots: 0/512
> May 30 08:10:42 acer kernel: bcm43xx: DMA-32 0x0240 (TX) max used slots: 0/512
> May 30 08:10:42 acer kernel: bcm43xx: DMA-32 0x0220 (TX) max used slots: 1/512
> May 30 08:10:42 acer kernel: bcm43xx: DMA-32 0x0200 (TX) max used slots: 0/512
> May 30 08:10:42 acer kernel: ACPI: PCI interrupt for device 0000:06:05.0 disabled
> May 30 08:10:43 acer ifdown: Network interface is managed from NetworkManager
> May 30 08:10:43 acer ifdown: NetworkManager cannot be advised to take down an interface. 
> May 30 08:10:43 acer ifdown: Set up another interface instead.
> May 30 08:10:43 acer zmd: NetworkStatus (WARN): Network has been disconnected
> May 30 08:10:43 acer zmd: NetworkStatus (WARN): Network has been disconnected
> May 30 08:10:43 acer zmd: NetworkStatus (WARN): Network has been disconnected
> May 30 08:10:43 acer kernel: bcm43xx driver
> May 30 08:10:43 acer kernel: ACPI: PCI Interrupt 0000:06:05.0[A] -> GSI 21 (level, low) -> IRQ 21
> May 30 08:10:43 acer kernel: bcm43xx: Chip ID 0x4318, rev 0x2
> May 30 08:10:43 acer kernel: bcm43xx: Number of cores: 4
> May 30 08:10:43 acer kernel: bcm43xx: Core 0: ID 0x800, rev 0xd, vendor 0x4243
> May 30 08:10:43 acer kernel: bcm43xx: Core 1: ID 0x812, rev 0x9, vendor 0x4243
> May 30 08:10:43 acer kernel: bcm43xx: Core 2: ID 0x804, rev 0xc, vendor 0x4243
> May 30 08:10:43 acer kernel: bcm43xx: Core 3: ID 0x80d, rev 0x7, vendor 0x4243
> May 30 08:10:43 acer kernel: bcm43xx: PHY connected
> May 30 08:10:43 acer kernel: bcm43xx: Detected PHY: Analog: 3, Type 2, Revision 7
> May 30 08:10:43 acer kernel: bcm43xx: Detected Radio: ID: 8205017f (Manuf: 17f Ver: 2050 Rev: 8)
> May 30 08:10:43 acer kernel: bcm43xx: Radio turned off
> May 30 08:10:43 acer kernel: bcm43xx: Radio turned off
> May 30 08:10:44 acer kernel: eth1 renamed to wlan0
> May 30 08:10:44 acer rename_netiface: oldname eth1 does not exist
> May 30 08:10:44 acer rename_netiface: oldname eth1 does not exist
> May 30 08:10:44 acer ifup: Network interface is managed from NetworkManager
> May 30 08:10:44 acer ifup: NetworkManager will be advised to set up wlan0 
> May 30 08:10:44 acer ifup: but it cannot be assured from here.
> May 30 08:10:44 acer kernel: bcm43xx: PHY connected
> May 30 08:10:44 acer kernel: bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
> May 30 08:10:44 acer kernel: bcm43xx: Radio turned on
> May 30 08:10:44 acer kernel: bcm43xx: Radio enabled by hardware
> May 30 08:10:44 acer kernel: bcm43xx: ASSERTION FAILED (radio_attenuation < 10) at: drivers/net/wireless/bcm43xx/bcm43xx_phy.c:1489:bcm43xx_find_lopair()
> May 30 08:10:44 acer kernel: bcm43xx: ASSERTION FAILED (radio_attenuation < 10) at: drivers/net/wireless/bcm43xx/bcm43xx_phy.c:1489:bcm43xx_find_lopair()
> May 30 08:10:44 acer kernel: bcm43xx: ASSERTION FAILED (radio_attenuation < 10) at: drivers/net/wireless/bcm43xx/bcm43xx_phy.c:1489:bcm43xx_find_lopair()
> May 30 08:10:44 acer kernel: bcm43xx: Chip initialized
> May 30 08:10:44 acer kernel: bcm43xx: 32-bit DMA initialized
> May 30 08:10:44 acer kernel: bcm43xx: Keys cleared
> May 30 08:10:44 acer kernel: bcm43xx: Selected 802.11 core (phytype 2)
> May 30 08:10:45 acer kernel: bcm43xx: ASSERTION FAILED (radio_attenuation < 10) at: drivers/net/wireless/bcm43xx/bcm43xx_phy.c:1489:bcm43xx_find_lopair()
> May 30 08:10:45 acer kernel: ADDRCONF(NETDEV_UP): wlan0: link is not ready
> May 30 08:10:45 acer kernel: SoftMAC: Associate: Scanning for networks first.
> May 30 08:10:45 acer kernel: SoftMAC: Associate: failed to initiate scan. Is device up?
> May 30 08:10:45 acer kernel: bcm43xx: set security called, .level = 0, .enabled = 0, .encrypt = 0
> May 30 08:10:45 acer zmd: NetworkStatus (WARN): Network has been disconnected
> May 30 08:10:45 acer kernel: SoftMAC: Scanning finished: scanned 13 channels starting with channel 1
> May 30 08:10:45 acer kernel: SoftMAC: Associate: Scanning for networks first.
> May 30 08:10:45 acer kernel: SoftMAC: Scanning finished: scanned 13 channels starting with channel 1
> May 30 08:10:45 acer kernel: SoftMAC: Associate: Scanning for networks first.
> May 30 08:10:46 acer kernel: SoftMAC: Scanning finished: scanned 13 channels starting with channel 1
> May 30 08:10:46 acer kernel: SoftMAC: Unable to find matching network after scan!

You can ignore the iwlist warning. The differences between versions 21 and 22 of wireless extensions 
are insignificant. Does iwlist really not show any AP's? If so, that is a problem of signal 
strength, not crowded spectrum.

Larry


From markus at unixforces.net  Wed May 30 22:07:29 2007
From: markus at unixforces.net (Markus Rothe)
Date: Wed, 30 May 2007 22:07:29 +0200
Subject: bcm4306 mini pci trouble
Message-ID: <20070530220729.1cd2c883@localhost>

Hello,

I'm trying to use bcm43xx_mac80211 module from wireless-dev git
(checked out today). Unfortunately I've some problems. The device is
not recognized. I cannot "ifconfig ethx up" for example.

From dmesg:

[...]
ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x04, vendor 0x4243)
ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x05, vendor 0x4243)
ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x02, vendor 0x4243)
ssb: Core 3 found: V90 (cc 0x807, rev 0x02, vendor 0x4243)
ssb: Core 4 found: PCI (cc 0x804, rev 0x09, vendor 0x4243)
ssb: Switching to ChipCommon core, index 0
ssb: Switching to PCI core, index 4
ssb: Sonics Silicon Backplane found on PCI device 0000:02:03.0
bcm43xx_mac80211: Broadcom 4306 WLAN found
ssb: Switching to IEEE 802.11 core, index 1
bcm43xx_mac80211: Found PHY: Analog 2, Type 2, Revision 2
bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
bcm43xx_mac80211: Radio turned off
wmaster0: Failed to select rate control algorithm
wmaster0: Failed to initialize rate control algorithm
bcm43xx_mac80211: probe of ssb0:0 failed with error -2

$ lsmod
Module                  Size  Used by
snd_pcm_oss            32160  0 
snd_mixer_oss          12928  2 snd_pcm_oss
snd_seq_oss            24960  0 
snd_seq_device          5384  1 snd_seq_oss
snd_seq_midi_event      5504  1 snd_seq_oss
snd_seq                37168  4 snd_seq_oss,snd_seq_midi_event
nvidia               4539476  12 
bcm43xx_mac80211      382688  0 
mac80211              114692  1 bcm43xx_mac80211
cfg80211               12936  1 mac80211
snd_intel8x0           26140  1 
snd_ac97_codec         87456  1 snd_intel8x0
ac97_bus                2048  1 snd_ac97_codec
snd_pcm                52232  3 snd_pcm_oss,snd_intel8x0,snd_ac97_codec
snd_timer              15364  2 snd_seq,snd_pcm
snd_page_alloc          7176  2 snd_intel8x0,snd_pcm

$ uname -a
Linux dell 2.6.22-rc3-gcfb44989 #3 Wed May 30 21:45:33 CEST 2007 i686
Intel(R) Pentium(R) 4 Mobile CPU 1.60GHz GenuineIntel GNU/Linux

$ lspci -vvv
[...]
02:03.0 Network controller: Broadcom Corporation BCM4306 802.11b/g
Wireless LAN Controller (rev 03) Subsystem: Broadcom Corporation
Unknown device 0453 Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV-
VGASnoop- ParErr- Stepping- SERR- FastB2B- Status: Cap- 66MHz- UDF-
FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
Latency: 32 Interrupt: pin A routed to IRQ 11
	Region 0: Memory at f8ffc000 (32-bit, non-prefetchable)
[size=8K]

Regards,

Markus Rothe


From mb at bu3sch.de  Wed May 30 22:46:50 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 30 May 2007 22:46:50 +0200
Subject: bcm4306 mini pci trouble
In-Reply-To: <20070530220729.1cd2c883@localhost>
References: <20070530220729.1cd2c883@localhost>
Message-ID: <200705302246.50543.mb@bu3sch.de>

On Wednesday 30 May 2007 22:07:29 Markus Rothe wrote:
> Hello,
> 
> I'm trying to use bcm43xx_mac80211 module from wireless-dev git
> (checked out today). Unfortunately I've some problems. The device is
> not recognized. I cannot "ifconfig ethx up" for example.
> 
> From dmesg:
> 
> [...]
> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x04, vendor 0x4243)
> ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x05, vendor 0x4243)
> ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x02, vendor 0x4243)
> ssb: Core 3 found: V90 (cc 0x807, rev 0x02, vendor 0x4243)
> ssb: Core 4 found: PCI (cc 0x804, rev 0x09, vendor 0x4243)
> ssb: Switching to ChipCommon core, index 0
> ssb: Switching to PCI core, index 4
> ssb: Sonics Silicon Backplane found on PCI device 0000:02:03.0
> bcm43xx_mac80211: Broadcom 4306 WLAN found
> ssb: Switching to IEEE 802.11 core, index 1
> bcm43xx_mac80211: Found PHY: Analog 2, Type 2, Revision 2
> bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> bcm43xx_mac80211: Radio turned off
> wmaster0: Failed to select rate control algorithm
> wmaster0: Failed to initialize rate control algorithm
> bcm43xx_mac80211: probe of ssb0:0 failed with error -2
> 
> $ lsmod
> Module                  Size  Used by
> snd_pcm_oss            32160  0 
> snd_mixer_oss          12928  2 snd_pcm_oss
> snd_seq_oss            24960  0 
> snd_seq_device          5384  1 snd_seq_oss
> snd_seq_midi_event      5504  1 snd_seq_oss
> snd_seq                37168  4 snd_seq_oss,snd_seq_midi_event
> nvidia               4539476  12 
> bcm43xx_mac80211      382688  0 
> mac80211              114692  1 bcm43xx_mac80211
> cfg80211               12936  1 mac80211
> snd_intel8x0           26140  1 
> snd_ac97_codec         87456  1 snd_intel8x0
> ac97_bus                2048  1 snd_ac97_codec
> snd_pcm                52232  3 snd_pcm_oss,snd_intel8x0,snd_ac97_codec
> snd_timer              15364  2 snd_seq,snd_pcm
> snd_page_alloc          7176  2 snd_intel8x0,snd_pcm

You must load the rate control algorithm module
rc80211-simple, for example.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Wed May 30 23:04:48 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 30 May 2007 16:04:48 -0500
Subject: bcm4306 mini pci trouble
In-Reply-To: <200705302246.50543.mb@bu3sch.de>
References: <20070530220729.1cd2c883@localhost>
	<200705302246.50543.mb@bu3sch.de>
Message-ID: <465DE6F0.2040902@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 30 May 2007 22:07:29 Markus Rothe wrote:
>> Hello,
>>
>> I'm trying to use bcm43xx_mac80211 module from wireless-dev git
>> (checked out today). Unfortunately I've some problems. The device is
>> not recognized. I cannot "ifconfig ethx up" for example.
>>
>> From dmesg:
>>
>> [...]
>> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x04, vendor 0x4243)
>> ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x05, vendor 0x4243)
>> ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x02, vendor 0x4243)
>> ssb: Core 3 found: V90 (cc 0x807, rev 0x02, vendor 0x4243)
>> ssb: Core 4 found: PCI (cc 0x804, rev 0x09, vendor 0x4243)
>> ssb: Switching to ChipCommon core, index 0
>> ssb: Switching to PCI core, index 4
>> ssb: Sonics Silicon Backplane found on PCI device 0000:02:03.0
>> bcm43xx_mac80211: Broadcom 4306 WLAN found
>> ssb: Switching to IEEE 802.11 core, index 1
>> bcm43xx_mac80211: Found PHY: Analog 2, Type 2, Revision 2
>> bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
>> bcm43xx_mac80211: Radio turned off
>> wmaster0: Failed to select rate control algorithm
>> wmaster0: Failed to initialize rate control algorithm
>> bcm43xx_mac80211: probe of ssb0:0 failed with error -2
>>
>> $ lsmod
>> Module                  Size  Used by
>> snd_pcm_oss            32160  0 
>> snd_mixer_oss          12928  2 snd_pcm_oss
>> snd_seq_oss            24960  0 
>> snd_seq_device          5384  1 snd_seq_oss
>> snd_seq_midi_event      5504  1 snd_seq_oss
>> snd_seq                37168  4 snd_seq_oss,snd_seq_midi_event
>> nvidia               4539476  12 
>> bcm43xx_mac80211      382688  0 
>> mac80211              114692  1 bcm43xx_mac80211
>> cfg80211               12936  1 mac80211
>> snd_intel8x0           26140  1 
>> snd_ac97_codec         87456  1 snd_intel8x0
>> ac97_bus                2048  1 snd_ac97_codec
>> snd_pcm                52232  3 snd_pcm_oss,snd_intel8x0,snd_ac97_codec
>> snd_timer              15364  2 snd_seq,snd_pcm
>> snd_page_alloc          7176  2 snd_intel8x0,snd_pcm
> 
> You must load the rate control algorithm module
> rc80211-simple, for example.
> 

That loads automatically here.

Why isn't the ssb module shown in the lsmod list?

Larry



From mb at bu3sch.de  Wed May 30 23:05:38 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 30 May 2007 23:05:38 +0200
Subject: bcm4306 mini pci trouble
In-Reply-To: <465DE6F0.2040902@lwfinger.net>
References: <20070530220729.1cd2c883@localhost>
	<200705302246.50543.mb@bu3sch.de> <465DE6F0.2040902@lwfinger.net>
Message-ID: <200705302305.38803.mb@bu3sch.de>

On Wednesday 30 May 2007 23:04:48 Larry Finger wrote:
> Michael Buesch wrote:
> > On Wednesday 30 May 2007 22:07:29 Markus Rothe wrote:
> >> Hello,
> >>
> >> I'm trying to use bcm43xx_mac80211 module from wireless-dev git
> >> (checked out today). Unfortunately I've some problems. The device is
> >> not recognized. I cannot "ifconfig ethx up" for example.
> >>
> >> From dmesg:
> >>
> >> [...]
> >> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x04, vendor 0x4243)
> >> ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x05, vendor 0x4243)
> >> ssb: Core 2 found: PCMCIA (cc 0x80D, rev 0x02, vendor 0x4243)
> >> ssb: Core 3 found: V90 (cc 0x807, rev 0x02, vendor 0x4243)
> >> ssb: Core 4 found: PCI (cc 0x804, rev 0x09, vendor 0x4243)
> >> ssb: Switching to ChipCommon core, index 0
> >> ssb: Switching to PCI core, index 4
> >> ssb: Sonics Silicon Backplane found on PCI device 0000:02:03.0
> >> bcm43xx_mac80211: Broadcom 4306 WLAN found
> >> ssb: Switching to IEEE 802.11 core, index 1
> >> bcm43xx_mac80211: Found PHY: Analog 2, Type 2, Revision 2
> >> bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> >> bcm43xx_mac80211: Radio turned off
> >> wmaster0: Failed to select rate control algorithm
> >> wmaster0: Failed to initialize rate control algorithm
> >> bcm43xx_mac80211: probe of ssb0:0 failed with error -2
> >>
> >> $ lsmod
> >> Module                  Size  Used by
> >> snd_pcm_oss            32160  0 
> >> snd_mixer_oss          12928  2 snd_pcm_oss
> >> snd_seq_oss            24960  0 
> >> snd_seq_device          5384  1 snd_seq_oss
> >> snd_seq_midi_event      5504  1 snd_seq_oss
> >> snd_seq                37168  4 snd_seq_oss,snd_seq_midi_event
> >> nvidia               4539476  12 
> >> bcm43xx_mac80211      382688  0 
> >> mac80211              114692  1 bcm43xx_mac80211
> >> cfg80211               12936  1 mac80211
> >> snd_intel8x0           26140  1 
> >> snd_ac97_codec         87456  1 snd_intel8x0
> >> ac97_bus                2048  1 snd_ac97_codec
> >> snd_pcm                52232  3 snd_pcm_oss,snd_intel8x0,snd_ac97_codec
> >> snd_timer              15364  2 snd_seq,snd_pcm
> >> snd_page_alloc          7176  2 snd_intel8x0,snd_pcm
> > 
> > You must load the rate control algorithm module
> > rc80211-simple, for example.
> > 
> 
> That loads automatically here.
> 
> Why isn't the ssb module shown in the lsmod list?

Must be built-in then.


-- 
Greetings Michael.


From markus at unixforces.net  Thu May 31 08:21:02 2007
From: markus at unixforces.net (Markus Rothe)
Date: Thu, 31 May 2007 08:21:02 +0200
Subject: bcm4306 mini pci trouble
In-Reply-To: <200705302305.38803.mb@bu3sch.de>
References: <20070530220729.1cd2c883@localhost>
	<200705302246.50543.mb@bu3sch.de> <465DE6F0.2040902@lwfinger.net>
	<200705302305.38803.mb@bu3sch.de>
Message-ID: <20070531082102.58e9b958@localhost>

On Wed, 30 May 2007 23:05:38 +0200,
Michael Buesch <mb at bu3sch.de> wrote:
> On Wednesday 30 May 2007 23:04:48 Larry Finger wrote:
> > Michael Buesch wrote:
[snip]
> > That loads automatically here.
> > 
> > Why isn't the ssb module shown in the lsmod list?
> 
> Must be built-in then.

yes, ssb was build in.

On Wed, 30 May 2007 22:46:50 +0200,
Michael Buesch <mb at bu3sch.de> wrote:
> You must load the rate control algorithm module
> rc80211-simple, for example.

That fixed the problem. Shouldn't the module be loaded automatically?
Something like "if no rate control is loaded then load and use
rc80211-simple else use the already loaded module".


Unfortunately I have another problem, which might be access point
or laptop related and not a driver problem (as in "the combination was
bought on ebay recently and newer worked so far, though this is the
first attempt"). I'm getting a timeout when connecting to the AP.

May 31 08:13:44 dell bcm43xx_mac80211: Using hardware based encryption
for keyidx: 0, mac: ff:ff:ff:ff:ff:ff May 31 08:13:45 dell
wlan0_rename: privacy configuration mismatch and mixed-cell disabled -
disassociate May 31 08:13:45 dell bcm43xx_mac80211: Using hardware
based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff May 31 08:13:45
dell wlan0_rename: Initial auth_alg=0 May 31 08:13:45 dell
wlan0_rename: authenticate with AP 00:09:5b:74:7f:5b May 31 08:13:45
dell wlan0_rename: Initial auth_alg=0 May 31 08:13:45 dell
wlan0_rename: authenticate with AP 00:09:5b:74:7f:5b May 31 08:13:45
dell wlan0_rename: Initial auth_alg=0 May 31 08:13:45 dell
wlan0_rename: authenticate with AP 00:09:5b:74:7f:5b May 31 08:13:45
dell wlan0_rename: authenticate with AP 00:09:5b:74:7f:5b May 31
08:13:45 dell wlan0_rename: authenticate with AP 00:09:5b:74:7f:5b May
31 08:13:46 dell wlan0_rename: authentication with AP 00:09:5b:74:7f:5b
timed out


And one last question: Why is eth1 *and* wlan0_rename created?
shouldn't be there only one interface for one device? (I'm using udev
104 if that matters).

Regards,

Markus Rothe

P.S.: Sorry, but there is no such list like "bcm43xx-users" :-/


From zajec5polish at gmail.com  Thu May 31 08:41:22 2007
From: zajec5polish at gmail.com (=?UTF-8?Q?Rafa=C5=82_Mi=C5=82ecki?=)
Date: Thu, 31 May 2007 08:41:22 +0200
Subject: Problem with connecting in some place
In-Reply-To: <465D8246.8070902@lwfinger.net>
References: <14b026160705090704w497bab4bybd0d7f3b891c162d@mail.gmail.com>
	<4641E4BA.30200@lwfinger.net>
	<14b026160705300124x335b1864xbbd940db32a0b079@mail.gmail.com>
	<465D8246.8070902@lwfinger.net>
Message-ID: <14b026160705302341v458dded5te9b659d54981f717@mail.gmail.com>

2007/5/30, Larry Finger <larry.finger at lwfinger.net>:
> You can ignore the iwlist warning. The differences between versions 21 and 22 of wireless extensions
> are insignificant. Does iwlist really not show any AP's? If so, that is a problem of signal
> strength, not crowded spectrum.

iwlist shows AP, I just cut it's output.

My AP is visible in both: iwlist and KNetworkManager. I try to connect
by simply clicking on my AP in KnetworkManager's menu.

-- 
Rafa? Mi?ecki

From markus at unixforces.net  Thu May 31 09:41:40 2007
From: markus at unixforces.net (Markus Rothe)
Date: Thu, 31 May 2007 09:41:40 +0200
Subject: bcm4306 mini pci trouble
In-Reply-To: <20070531082102.58e9b958@localhost>
References: <20070530220729.1cd2c883@localhost>
	<200705302246.50543.mb@bu3sch.de> <465DE6F0.2040902@lwfinger.net>
	<200705302305.38803.mb@bu3sch.de>
	<20070531082102.58e9b958@localhost>
Message-ID: <20070531094140.53552966@localhost>

On Thu, 31 May 2007 08:21:02 +0200,
Markus Rothe <markus at unixforces.net> wrote:
> And one last question: Why is eth1 *and* wlan0_rename created?
> shouldn't be there only one interface for one device? (I'm using udev
> 104 if that matters).

I fixed my udev rules.. Now I have that wlan0 interface I want. So
missing issues are the kernel module loading and authentication with the
AP.

-markus


From yangtze31 at gmail.com  Thu May 31 11:08:14 2007
From: yangtze31 at gmail.com (Bin Zhang)
Date: Thu, 31 May 2007 11:08:14 +0200
Subject: bcm4306 mini pci trouble
In-Reply-To: <20070531094140.53552966@localhost>
References: <20070530220729.1cd2c883@localhost>
	<200705302246.50543.mb@bu3sch.de> <465DE6F0.2040902@lwfinger.net>
	<200705302305.38803.mb@bu3sch.de> <20070531082102.58e9b958@localhost>
	<20070531094140.53552966@localhost>
Message-ID: <51ad2e0d0705310208w1ac73faet4c8950b717e2ff48@mail.gmail.com>

On 5/31/07, Markus Rothe <markus at unixforces.net> wrote:
> On Thu, 31 May 2007 08:21:02 +0200,
> Markus Rothe <markus at unixforces.net> wrote:
> > And one last question: Why is eth1 *and* wlan0_rename created?
> > shouldn't be there only one interface for one device? (I'm using udev
> > 104 if that matters).
>
> I fixed my udev rules.. Now I have that wlan0 interface I want. So
> missing issues are the kernel module loading and authentication with the
> AP.
>

I have a 4306 card:
0001:10:12.0 Network controller: Broadcom Corporation BCM4306
802.11b/g Wireless LAN Controller (rev 03)

bcm43xx_mac80211 stops working with wireless-dev git  29 May 2007.
bcm43xx works.

May 30 22:43:42 localhost kernel: PCI: Enabling device 0001:10:12.0
(0004 -> 0006)
May 30 22:43:42 localhost kernel: ssb: Core 0 found: ChipCommon (cc
0x800, rev 0x04, vendor 0x4243)
May 30 22:43:42 localhost kernel: ssb: Core 1 found: IEEE 802.11 (cc
0x812, rev 0x05, vendor 0x4243)
May 30 22:43:42 localhost kernel: ssb: Core 2 found: PCMCIA (cc 0x80D,
rev 0x02, vendor 0x4243)
May 30 22:43:42 localhost kernel: ssb: Core 3 found: V90 (cc 0x807,
rev 0x02, vendor 0x4243)
May 30 22:43:42 localhost kernel: ssb: Core 4 found: PCI (cc 0x804,
rev 0x09, vendor 0x4243)
May 30 22:43:42 localhost kernel: ssb: Switching to ChipCommon core, index 0
May 30 22:43:42 localhost kernel: ssb: Switching to PCI core, index 4
May 30 22:43:42 localhost kernel: ssb: Sonics Silicon Backplane found
on PCI device 0001:10:12.0
May 30 22:43:42 localhost kernel: bcm43xx_mac80211: Broadcom 4306 WLAN found
May 30 22:43:42 localhost kernel: ssb: Switching to IEEE 802.11 core, index 1
May 30 22:43:42 localhost kernel: bcm43xx_mac80211: Found PHY: Analog
2, Type 2, Revision 2
May 30 22:43:42 localhost kernel: bcm43xx_mac80211: Found Radio: Manuf
0x17F, Version 0x2050, Revision 2
May 30 22:43:42 localhost kernel: bcm43xx_mac80211: Radio turned off
May 30 22:43:42 localhost kernel: Device driver phy0 lacks bus and
class support for being resumed.
May 30 22:43:42 localhost kernel: Device driver wmaster0 lacks bus and
class support for being resumed.
May 30 22:43:43 localhost kernel: wmaster0: Selected rate control
algorithm 'simple'
May 30 22:43:43 localhost kernel: Device driver wlan0 lacks bus and
class support for being resumed.
May 30 22:43:44 localhost kernel: bcm43xx_mac80211: Adding Interface type 2
May 30 22:43:44 localhost kernel: ssb: Switching to PCI core, index 4
May 30 22:43:44 localhost kernel: ssb: Switching to IEEE 802.11 core, index 1
May 30 22:43:44 localhost kernel: Device driver ssb0:0 lacks bus and
class support for being resumed.
May 30 22:43:44 localhost last message repeated 3 times
May 30 22:43:44 localhost kernel: bcm43xx_mac80211: Loading firmware
version 351.126 (2006-07-29 05:54:02)
May 30 22:43:44 localhost kernel: ssb: Switching to ChipCommon core, index 0
May 30 22:43:44 localhost kernel: ssb: Switching to IEEE 802.11 core, index 1
May 30 22:43:44 localhost kernel: bcm43xx_mac80211: Radio turned on
May 30 22:43:44 localhost kernel: bcm43xx_mac80211: Radio enabled by hardware
May 30 22:43:44 localhost kernel: bcm43xx_mac80211: !WARNING!
Idle-TSSI phy->cur_idle_tssi measuring failed. (cur=0, tgt=62).
Disabling TX power adjustment.
May 30 22:43:44 localhost kernel: bcm43xx_mac80211: Chip initialized
May 30 22:43:44 localhost kernel: bcm43xx_mac80211: 30-bit DMA initialized
May 30 22:43:44 localhost kernel: bcm43xx_mac80211: Wireless interface started
May 30 22:43:44 localhost kernel: ADDRCONF(NETDEV_UP): wlan0: link is not ready
May 30 22:43:46 localhost dhclient: Internet Systems Consortium DHCP
Client V3.0.4
May 30 22:43:46 localhost dhclient: Copyright 2004-2006 Internet
Systems Consortium.
May 30 22:43:46 localhost dhclient: All rights reserved.
May 30 22:43:46 localhost dhclient: For info, please visit
http://www.isc.org/sw/dhcp/
May 30 22:43:46 localhost dhclient:
May 30 22:43:46 localhost dhclient: wmaster0: unknown hardware address type 801
May 30 22:43:46 localhost kernel: wlan0: Initial auth_alg=0
May 30 22:43:46 localhost kernel: wlan0: authenticate with AP 00:11:95:36:fc:f7
May 30 22:43:46 localhost kernel: wlan0: RX authentication from
00:11:95:36:fc:f7 (alg=0 transaction=2 status=0)
May 30 22:43:46 localhost kernel: wlan0: authenticated
May 30 22:43:46 localhost kernel: wlan0: associate with AP 00:11:95:36:fc:f7
May 30 22:43:46 localhost kernel: wlan0: RX AssocResp from
00:11:95:36:fc:f7 (capab=0x471 status=0 aid=1)
May 30 22:43:46 localhost kernel: wlan0: associated
May 30 22:43:46 localhost kernel: ADDRCONF(NETDEV_CHANGE): wlan0: link
becomes ready
May 30 22:43:47 localhost dhclient: wmaster0: unknown hardware address type 801
May 30 22:43:47 localhost dhclient: Listening on LPF/wlan0/00:11:24:22:f5:04
May 30 22:43:47 localhost dhclient: Sending on   LPF/wlan0/00:11:24:22:f5:04
May 30 22:43:47 localhost dhclient: Sending on   Socket/fallback
May 30 22:43:50 localhost dhclient: DHCPDISCOVER on wlan0 to
255.255.255.255 port 67 interval 3
May 30 22:43:53 localhost dhclient: DHCPDISCOVER on wlan0 to
255.255.255.255 port 67 interval 4
May 30 22:43:56 localhost kernel: wlan0: no IPv6 routers present
May 30 22:43:57 localhost dhclient: DHCPDISCOVER on wlan0 to
255.255.255.255 port 67 interval 9
May 30 22:44:06 localhost dhclient: DHCPDISCOVER on wlan0 to
255.255.255.255 port 67 interval 11
May 30 22:44:17 localhost dhclient: DHCPDISCOVER on wlan0 to
255.255.255.255 port 67 interval 19
May 30 22:44:23 localhost dhclient: Internet Systems Consortium DHCP
Client V3.0.4
May 30 22:44:23 localhost dhclient: Copyright 2004-2006 Internet
Systems Consortium.
May 30 22:44:23 localhost dhclient: All rights reserved.
May 30 22:44:23 localhost dhclient: For info, please visit
http://www.isc.org/sw/dhcp/
May 30 22:44:23 localhost dhclient:
May 30 22:44:23 localhost dhclient: wmaster0: unknown hardware address type 801
May 30 22:44:23 localhost dhclient: wmaster0: unknown hardware address type 801
May 30 22:44:23 localhost dhclient: Listening on LPF/wlan0/00:11:24:22:f5:04
May 30 22:44:23 localhost dhclient: Sending on   LPF/wlan0/00:11:24:22:f5:04
May 30 22:44:23 localhost dhclient: Sending on   Socket/fallback
May 30 22:44:23 localhost dhclient: DHCPRELEASE on wlan0 to 192.168.0.1 port 67
May 30 22:44:23 localhost dhclient: send_packet: Network is unreachable
May 30 22:44:23 localhost dhclient: send_packet: please consult README
file regarding broadcast address.
May 30 22:44:23 localhost kernel: bcm43xx_mac80211: Removing Interface type 2
May 30 22:44:23 localhost kernel: bcm43xx_mac80211: Wireless interface stopped
May 30 22:44:23 localhost kernel: bcm43xx_mac80211: DMA-32 0x0200 (RX)
max used slots: 1/64
May 30 22:44:23 localhost kernel: bcm43xx_mac80211: DMA-32 0x02A0 (TX)
max used slots: 0/128
May 30 22:44:23 localhost kernel: bcm43xx_mac80211: DMA-32 0x0280 (TX)
max used slots: 0/128
May 30 22:44:23 localhost kernel: bcm43xx_mac80211: DMA-32 0x0260 (TX)
max used slots: 0/128
May 30 22:44:23 localhost kernel: bcm43xx_mac80211: DMA-32 0x0240 (TX)
max used slots: 0/128
May 30 22:44:23 localhost kernel: bcm43xx_mac80211: DMA-32 0x0220 (TX)
max used slots: 22/128
May 30 22:44:23 localhost kernel: bcm43xx_mac80211: DMA-32 0x0200 (TX)
max used slots: 0/128
May 30 22:44:23 localhost kernel: bcm43xx_mac80211: Radio turned off
May 30 22:44:23 localhost kernel: ssb: Switching to ChipCommon core, index 0
May 30 22:44:23 localhost kernel: ssb: Switching to IEEE 802.11 core, index 1
May 30 22:44:23 localhost kernel: bcm43xx_mac80211: Radio turned off
May 30 22:44:28 localhost kernel: ieee80211_crypt: registered algorithm 'NULL'
May 30 22:44:28 localhost kernel: ieee80211: 802.11
data/management/control stack, git-1.1.13
May 30 22:44:28 localhost kernel: ieee80211: Copyright (C) 2004-2005
Intel Corporation <jketreno at linux.intel.com>
May 30 22:44:28 localhost kernel: bcm43xx driver
May 30 22:44:28 localhost kernel: bcm43xx: Chip ID 0x4306, rev 0x3
May 30 22:44:28 localhost kernel: bcm43xx: Number of cores: 5
May 30 22:44:28 localhost kernel: bcm43xx: Core 0: ID 0x800, rev 0x4,
vendor 0x4243
May 30 22:44:28 localhost kernel: bcm43xx: Core 1: ID 0x812, rev 0x5,
vendor 0x4243
May 30 22:44:28 localhost kernel: bcm43xx: Core 2: ID 0x80d, rev 0x2,
vendor 0x4243
May 30 22:44:28 localhost kernel: bcm43xx: Core 3: ID 0x807, rev 0x2,
vendor 0x4243
May 30 22:44:28 localhost kernel: bcm43xx: Core 4: ID 0x804, rev 0x9,
vendor 0x4243
May 30 22:44:28 localhost kernel: bcm43xx: PHY connected
May 30 22:44:28 localhost kernel: bcm43xx: Detected PHY: Analog: 2,
Type 2, Revision 2
May 30 22:44:28 localhost kernel: bcm43xx: Detected Radio: ID:
2205017f (Manuf: 17f Ver: 2050 Rev: 2)
May 30 22:44:28 localhost kernel: bcm43xx: Radio turned off
May 30 22:44:28 localhost kernel: bcm43xx: Radio turned off
May 30 22:44:28 localhost kernel: Device driver eth1 lacks bus and
class support for being resumed.
May 30 22:44:28 localhost kernel: bcm43xx: PHY connected
May 30 22:44:28 localhost kernel: Device driver 0001:10:12.0 lacks bus
and class support for being resumed.
May 30 22:44:28 localhost last message repeated 3 times
May 30 22:44:28 localhost kernel: bcm43xx: Microcode rev 0x127, pl 0xe
(2005-04-18  02:36:27)
May 30 22:44:28 localhost kernel: bcm43xx: Radio turned on
May 30 22:44:28 localhost kernel: bcm43xx: Radio enabled by hardware
May 30 22:44:29 localhost kernel: bcm43xx: Chip initialized
May 30 22:44:29 localhost kernel: bcm43xx: 30-bit DMA initialized
May 30 22:44:29 localhost kernel: bcm43xx: Keys cleared
May 30 22:44:29 localhost kernel: bcm43xx: Selected 802.11 core (phytype 2)
May 30 22:44:29 localhost kernel: ADDRCONF(NETDEV_UP): eth1: link is not ready
May 30 22:44:29 localhost ifd[3284]: executing:
'/usr/share/laptop-net/link-change eth1 unmanaged unknown
up,running,disconnected'
May 30 22:44:30 localhost kernel: bcm43xx: set security called, .level
= 0, .enabled = 0, .encrypt = 0
May 30 22:44:30 localhost last message repeated 3 times
May 30 22:44:30 localhost dhclient: Internet Systems Consortium DHCP
Client V3.0.4
May 30 22:44:30 localhost dhclient: Copyright 2004-2006 Internet
Systems Consortium.
May 30 22:44:30 localhost dhclient: All rights reserved.
May 30 22:44:30 localhost dhclient: For info, please visit
http://www.isc.org/sw/dhcp/
May 30 22:44:30 localhost dhclient:
May 30 22:44:30 localhost kernel: SoftMAC: Open Authentication
completed with 00:11:95:36:fc:f7
May 30 22:44:30 localhost kernel: ADDRCONF(NETDEV_CHANGE): eth1: link
becomes ready
May 30 22:44:30 localhost kernel: ieee80211_crypt: registered algorithm 'TKIP'
May 30 22:44:30 localhost kernel: bcm43xx: set security called,
.active_key = 0, .level = 2, .enabled = 1, .encrypt = 1
May 30 22:44:30 localhost kernel: bcm43xx: set security called,
.enabled = 1, .encrypt = 1
May 30 22:44:31 localhost ifd[3284]: executing:
'/usr/share/laptop-net/link-change eth1 unmanaged
up,running,disconnected up,running,connected'
May 30 22:44:31 localhost dhclient: Listening on LPF/eth1/00:11:24:22:f5:04
May 30 22:44:31 localhost dhclient: Sending on   LPF/eth1/00:11:24:22:f5:04
May 30 22:44:31 localhost dhclient: Sending on   Socket/fallback
May 30 22:44:32 localhost dhclient: DHCPDISCOVER on eth1 to
255.255.255.255 port 67 interval 3
May 30 22:44:32 localhost dhclient: DHCPOFFER from 192.168.0.1
May 30 22:44:32 localhost dhclient: DHCPREQUEST on eth1 to
255.255.255.255 port 67
May 30 22:44:32 localhost dhclient: DHCPACK from 192.168.0.1
May 30 22:44:32 localhost postfix/master[3889]: reload configuration
/etc/postfix
May 30 22:44:32 localhost dhclient: bound to 192.168.0.101 -- renewal
in 271149 seconds.


Best regards,
Bin


> -markus
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>


From mb at bu3sch.de  Thu May 31 11:51:09 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 31 May 2007 11:51:09 +0200
Subject: bcm4306 mini pci trouble
In-Reply-To: <20070531082102.58e9b958@localhost>
References: <20070530220729.1cd2c883@localhost>
	<200705302305.38803.mb@bu3sch.de>
	<20070531082102.58e9b958@localhost>
Message-ID: <200705311151.09592.mb@bu3sch.de>

On Thursday 31 May 2007 08:21:02 Markus Rothe wrote:
> On Wed, 30 May 2007 23:05:38 +0200,
> Michael Buesch <mb at bu3sch.de> wrote:
> > On Wednesday 30 May 2007 23:04:48 Larry Finger wrote:
> > > Michael Buesch wrote:
> [snip]
> > > That loads automatically here.
> > > 
> > > Why isn't the ssb module shown in the lsmod list?
> > 
> > Must be built-in then.
> 
> yes, ssb was build in.
> 
> On Wed, 30 May 2007 22:46:50 +0200,
> Michael Buesch <mb at bu3sch.de> wrote:
> > You must load the rate control algorithm module
> > rc80211-simple, for example.
> 
> That fixed the problem. Shouldn't the module be loaded automatically?
> Something like "if no rate control is loaded then load and use
> rc80211-simple else use the already loaded module".
> 

Do you have module autoload support compiled in?
Because it loads automatically for me (and Larry and all others :) )

> Unfortunately I have another problem, which might be access point
> or laptop related and not a driver problem (as in "the combination was
> bought on ebay recently and newer worked so far, though this is the
> first attempt"). I'm getting a timeout when connecting to the AP.
> 
> May 31 08:13:44 dell bcm43xx_mac80211: Using hardware based encryption
> for keyidx: 0, mac: ff:ff:ff:ff:ff:ff May 31 08:13:45 dell
> wlan0_rename: privacy configuration mismatch and mixed-cell disabled -
> disassociate May 31 08:13:45 dell bcm43xx_mac80211: Using hardware
> based encryption for keyidx: 0, mac: ff:ff:ff:ff:ff:ff May 31 08:13:45
> dell wlan0_rename: Initial auth_alg=0 May 31 08:13:45 dell
> wlan0_rename: authenticate with AP 00:09:5b:74:7f:5b May 31 08:13:45
> dell wlan0_rename: Initial auth_alg=0 May 31 08:13:45 dell
> wlan0_rename: authenticate with AP 00:09:5b:74:7f:5b May 31 08:13:45
> dell wlan0_rename: Initial auth_alg=0 May 31 08:13:45 dell
> wlan0_rename: authenticate with AP 00:09:5b:74:7f:5b May 31 08:13:45
> dell wlan0_rename: authenticate with AP 00:09:5b:74:7f:5b May 31
> 08:13:45 dell wlan0_rename: authenticate with AP 00:09:5b:74:7f:5b May
> 31 08:13:46 dell wlan0_rename: authentication with AP 00:09:5b:74:7f:5b
> timed out

Try to move closer to the AP.

> And one last question: Why is eth1 *and* wlan0_rename created?
> shouldn't be there only one interface for one device? (I'm using udev
> 104 if that matters).

Dunno. Ask your udev configuration.

-- 
Greetings Michael.


From john at betelgeuse.us  Thu May 31 17:54:14 2007
From: john at betelgeuse.us (John W. M. Stevens)
Date: Thu, 31 May 2007 09:54:14 -0600
Subject: Compaq Presario F557US
Message-ID: <20070531155414.GA21433@morningstar.betelgeuse.us>

Hello,

I have a Compaq Presario F557US laptop that has a broadcom wireless chip
in it.  I have installed Linux kernel 2.6.21.3 on it, and the firmware
cut from wl_apsta.o by bcm43xx-fwcutter version 6.

lcpci -vn output:

03:00.0 0280: 14e4:4311 (rev 01)
        Subsystem: 103c:1363
		Flags: bus master, fast devsel, latency 0, IRQ 20
		Memory at b8000000 (32-bit, non-prefetchable) [size=16K]
		Capabilities: [40] Power Management version 2
		Capabilities: [58] Message signalled Interrupts: Mask- 64bit- Queue=0/0 Enable-
		Capabilities: [d0] Express Legacy Endpoint IRQ 0
		Capabilities: [100] Advanced Error Reporting
		Capabilities: [13c] Virtual Channel

The driver *almost* works, in that it comes up with no errors, configures
correctly, and then I can use iwlist to scan the neighborhood, so it is
obviously recieving, but it does not transmit.

When I ask it to establish an IP address by connecting to my wireless
access point (WAP), my wireless signal detector detects no signals coming
from the laptop at all.

Even when placed right next to the antenna of the WAP, no communication
occurs.

I attempted to use the driver firmware from the proper Windows driver
for this laptop (sp34488.exe) from the HP web site, under the theory
that the firmware had changed such that the driver's transmitter
on/off commands were not being properly interpreted.

Unfortunately, when I unpack sp34488.exe, I get files that bcm43xx-fwcutter
verison 6 can't understand.

Does anybody else have this laptop, or know how to modify the
bcm43xx-fwcutter tool to extract firmware from the sp34488.exe files?

Thanks,
John S.


From andrew.james.barr at gmail.com  Thu May 31 18:49:35 2007
From: andrew.james.barr at gmail.com (Andrew J. Barr)
Date: Thu, 31 May 2007 12:49:35 -0400
Subject: Compaq Presario F557US
In-Reply-To: <20070531155414.GA21433@morningstar.betelgeuse.us>
References: <20070531155414.GA21433@morningstar.betelgeuse.us>
Message-ID: <20070531124935.3baad3db@powerbook.oakcourt.dyndns.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On Thu, 31 May 2007 09:54:14 -0600
"John W. M. Stevens" <john at betelgeuse.us> wrote:

> Does anybody else have this laptop, or know how to modify the
> bcm43xx-fwcutter tool to extract firmware from the sp34488.exe files?

Can you tell us exactly what the failure mode of bcm43xx-fwcutter is?
e.g. What is written to stdout when you try to extract the firmware?
There are two major versions of the firmware, version 3 and version 4,
and the driver in the mainline kernel can only understand version 3.
The fwcutter tool, however, should understand both but warn you about
trying to use version 4 firmware.

Also, the initialization messages from the driver would be helpful.
Load the driver and then send us the last several messages printed in
'dmesg'. Specifically, this should tell us exactly what model of
Broadcom chip you have.
- -- 
Andrew J. Barr
X-Mailer: Claws Mail 2.9.1 (GTK+ 2.10.12; powerpc-unknown-linux-gnu)

Ronald Reagan: America's answer to Inspector Clouseau
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)

iD8DBQFGXvyxhuM+Z62a52oRAqI4AJ4lHEKwfAgYvRDKUDUfARvBUOdQ+wCgphje
710ANdZyMJKV+1+E3TroZhk=
=II+l
-----END PGP SIGNATURE-----

From john at betelgeuse.us  Thu May 31 19:02:37 2007
From: john at betelgeuse.us (John W. M. Stevens)
Date: Thu, 31 May 2007 11:02:37 -0600
Subject: Compaq Presario F557US
In-Reply-To: <20070531124935.3baad3db@powerbook.oakcourt.dyndns.org>
References: <20070531155414.GA21433@morningstar.betelgeuse.us>
	<20070531124935.3baad3db@powerbook.oakcourt.dyndns.org>
Message-ID: <20070531170237.GA23244@morningstar.betelgeuse.us>

On Thu, May 31, 2007 at 12:49:35PM -0400, Andrew J. Barr wrote:
> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA1
> 
> On Thu, 31 May 2007 09:54:14 -0600
> "John W. M. Stevens" <john at betelgeuse.us> wrote:
> 
> > Does anybody else have this laptop, or know how to modify the
> > bcm43xx-fwcutter tool to extract firmware from the sp34488.exe files?
> 
> Can you tell us exactly what the failure mode of bcm43xx-fwcutter is?

Sorry, the input file is either wrong or not supported by bcm43xx-fwcutter.
This file has an unknown MD5sum 162475477be5af17346b430446ebdd9d

> e.g. What is written to stdout when you try to extract the firmware?
> There are two major versions of the firmware, version 3 and version 4,
> and the driver in the mainline kernel can only understand version 3.
> The fwcutter tool, however, should understand both but warn you about
> trying to use version 4 firmware.

The above message (with different md5sums) was printed out when
attempting to use the tool against *all* of the files extracted from
sp34488.exe.

> Also, the initialization messages from the driver would be helpful.
> Load the driver and then send us the last several messages printed in
> 'dmesg'. Specifically, this should tell us exactly what model of
> Broadcom chip you have.


These are all the messages from dmesg buffer containing the string: bcm43xx.

bcm43xx driver
bcm43xx: Chip ID 0x4311, rev 0x1
bcm43xx: Number of cores: 4
bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
bcm43xx: PHY connected
bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
bcm43xx: Radio turned off
bcm43xx: Radio turned off
bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, .encrypt = 1
bcm43xx: PHY connected
bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
bcm43xx: Radio turned on
bcm43xx: Radio enabled by hardware
bcm43xx: Chip initialized
bcm43xx: 32-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)
bcm43xx: Radio turned off
bcm43xx: DMA-32 0x0200 (RX) max used slots: 14/64
bcm43xx: DMA-32 0x02A0 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0280 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0260 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0240 (TX) max used slots: 0/512
bcm43xx: DMA-32 0x0220 (TX) max used slots: 4/512
bcm43xx: DMA-32 0x0200 (TX) max used slots: 0/512
bcm43xx: set security called, .level = 0, .enabled = 0, .encrypt = 0
bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
bcm43xx: Radio turned on
bcm43xx: Radio enabled by hardware
bcm43xx: Chip initialized
bcm43xx: 32-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)

Thanks,
John S.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070531/b39b07f1/attachment.pgp>

From andrew.james.barr at gmail.com  Thu May 31 19:10:30 2007
From: andrew.james.barr at gmail.com (Andrew J. Barr)
Date: Thu, 31 May 2007 13:10:30 -0400
Subject: Compaq Presario F557US
In-Reply-To: <20070531170237.GA23244@morningstar.betelgeuse.us>
References: <20070531155414.GA21433@morningstar.betelgeuse.us>
	<20070531124935.3baad3db@powerbook.oakcourt.dyndns.org>
	<20070531170237.GA23244@morningstar.betelgeuse.us>
Message-ID: <20070531131030.6db879ff@powerbook.oakcourt.dyndns.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On Thu, 31 May 2007 11:02:37 -0600
"John W. M. Stevens" <john at betelgeuse.us> wrote:
 
> Sorry, the input file is either wrong or not supported by
> bcm43xx-fwcutter. This file has an unknown MD5sum
> 162475477be5af17346b430446ebdd9d

...

> The above message (with different md5sums) was printed out when
> attempting to use the tool against *all* of the files extracted from
> sp34488.exe.

You need to run it against bcmwl5.sys, if I remember correctly.

How far are you from your AP?

- -- 
Andrew J. Barr
X-Mailer: Claws Mail 2.9.1 (GTK+ 2.10.12; powerpc-unknown-linux-gnu)

Ronald Reagan: America's answer to Inspector Clouseau
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)

iD8DBQFGXwGGhuM+Z62a52oRAjCSAKDFVY51Oz2tyLy97O5NRFTiVg2cbgCg2xkS
90LLnR4mC3NiWE6aOHVcm3c=
=Gtox
-----END PGP SIGNATURE-----

From martin-langer at gmx.de  Thu May 31 19:27:47 2007
From: martin-langer at gmx.de (Martin Langer)
Date: Thu, 31 May 2007 19:27:47 +0200
Subject: Compaq Presario F557US
In-Reply-To: <20070531131030.6db879ff@powerbook.oakcourt.dyndns.org>
References: <20070531155414.GA21433@morningstar.betelgeuse.us>
	<20070531124935.3baad3db@powerbook.oakcourt.dyndns.org>
	<20070531170237.GA23244@morningstar.betelgeuse.us>
	<20070531131030.6db879ff@powerbook.oakcourt.dyndns.org>
Message-ID: <20070531172747.GA3496@tuba>

On Thu, May 31, 2007 at 01:10:30PM -0400, Andrew J. Barr wrote:
> On Thu, 31 May 2007 11:02:37 -0600
> "John W. M. Stevens" <john at betelgeuse.us> wrote:
>  
> > Sorry, the input file is either wrong or not supported by
> > bcm43xx-fwcutter. This file has an unknown MD5sum
> > 162475477be5af17346b430446ebdd9d
> 
> ...
> 
> > The above message (with different md5sums) was printed out when
> > attempting to use the tool against *all* of the files extracted from
> > sp34488.exe.
> 
> You need to run it against bcmwl5.sys, if I remember correctly.

Nope. There it's either bcmwl6.sys or bcmwl664.sys. I think that 
Broadcom increased it from bcmwl5.sys to bcmwl6.sys for the Vista line.

Nevertheless, the driver file is already supported by the SVN version.

  filename   :  bcmwl664.sys
  version    :  4.102.15.61
  MD5        :  97f98e5e6a83585e42b1e1e15716aae8
  microcodes :  4 5 11 13
  pcms       :  4 5


Martin


From larry.finger at lwfinger.net  Thu May 31 20:31:57 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 31 May 2007 13:31:57 -0500
Subject: Compaq Presario F557US
In-Reply-To: <20070531170237.GA23244@morningstar.betelgeuse.us>
References: <20070531155414.GA21433@morningstar.betelgeuse.us>	<20070531124935.3baad3db@powerbook.oakcourt.dyndns.org>
	<20070531170237.GA23244@morningstar.betelgeuse.us>
Message-ID: <465F149D.7070503@lwfinger.net>

John W. M. Stevens wrote:
> These are all the messages from dmesg buffer containing the string: bcm43xx.
> 
> bcm43xx driver
> bcm43xx: Chip ID 0x4311, rev 0x1
> bcm43xx: Number of cores: 4
> bcm43xx: Core 0: ID 0x800, rev 0x11, vendor 0x4243
> bcm43xx: Core 1: ID 0x812, rev 0xa, vendor 0x4243
> bcm43xx: Core 2: ID 0x817, rev 0x3, vendor 0x4243
> bcm43xx: Core 3: ID 0x820, rev 0x1, vendor 0x4243
> bcm43xx: PHY connected
> bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 8
> bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> bcm43xx: Radio turned off
> bcm43xx: Radio turned off
> bcm43xx: set security called, .active_key = 0, .level = 1, .enabled = 1, .encrypt = 1
> bcm43xx: PHY connected
> bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
> bcm43xx: Radio turned on
> bcm43xx: Radio enabled by hardware
> bcm43xx: Chip initialized
> bcm43xx: 32-bit DMA initialized
> bcm43xx: Keys cleared
> bcm43xx: Selected 802.11 core (phytype 2)
> bcm43xx: Radio turned off
> bcm43xx: DMA-32 0x0200 (RX) max used slots: 14/64
> bcm43xx: DMA-32 0x02A0 (TX) max used slots: 0/512
> bcm43xx: DMA-32 0x0280 (TX) max used slots: 0/512
> bcm43xx: DMA-32 0x0260 (TX) max used slots: 0/512
> bcm43xx: DMA-32 0x0240 (TX) max used slots: 0/512
> bcm43xx: DMA-32 0x0220 (TX) max used slots: 4/512
> bcm43xx: DMA-32 0x0200 (TX) max used slots: 0/512
> bcm43xx: set security called, .level = 0, .enabled = 0, .encrypt = 0
> bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
> bcm43xx: Radio turned on
> bcm43xx: Radio enabled by hardware
> bcm43xx: Chip initialized
> bcm43xx: 32-bit DMA initialized
> bcm43xx: Keys cleared
> bcm43xx: Selected 802.11 core (phytype 2)

Your card is exactly what I have. The firmware you have loaded is the very latest version that is 
supported by the mainline version of bcm43xx. For maximum transmit strength, you should either 
switch to kernel 2.6.22-rc3 of install the patch found in 
ftp://lwfinger.dynalias.org/patches/combined_2.6.21.patch. The changes are important.

If this doesn't fix your problem, we also need to see the dmesg output from SoftMAC.

Larry


