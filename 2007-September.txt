From johannes at sipsolutions.net  Sat Sep  1 00:00:00 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Sat, 01 Sep 2007 00:00:00 +0200
Subject: RFC bcm43xx: Fix potential race in shutdown of work queses
In-Reply-To: <200708312029.58948.mb@bu3sch.de>
References: <46d84cbb.FOFfgaTFNALi9I3F%Larry.Finger@lwfinger.net>
	<200708311943.16751.mb@bu3sch.de> <46D8587E.9080303@lwfinger.net>
	<200708312029.58948.mb@bu3sch.de>
Message-ID: <1188597600.7585.47.camel@johannes.berg>

On Fri, 2007-08-31 at 20:29 +0200, Michael Buesch wrote:

> PS: I hate this damn berlios list so much. It always randomly strips
> some CCs.

Seems to be a mailman bug, I get it from linuxppc-dev too.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070901/94f7ae33/attachment.pgp>

From larry.finger at lwfinger.net  Sat Sep  1 00:26:05 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 31 Aug 2007 17:26:05 -0500
Subject: b43legacy woes
In-Reply-To: <BAY128-W312E506592CDC1EF65AF0C86CE0@phx.gbl>
References: <BAY128-W312E506592CDC1EF65AF0C86CE0@phx.gbl>
Message-ID: <46D8957D.2010705@lwfinger.net>

David Ellingsworth wrote:
> I've been using the b43legacy driver since it was first posted to this list.
 > The driver has been relatively stable, but my wireless connection has not.
 > In an environment with approximately 26 wireless access points, I experience
 > frequent disconnects and reconnects with the rate stuck at 1Mb/s. The ranges
 > for signal and noise reported under these conditions were (-53db, -59db) and
 > (-93db, -89db) respectively, with an average difference between the two around 20db.
 > The Windows driver under these conditions quickly scaled to 54Mb/s and maintained a
 > connection. In an environment with a single AP, the b43legacy driver performs very
 > similar to the results above where the rate is limited at 1Mb/s and the Windows driver
 > scales significantly higher.
> 

The poor performance of the BCM4306/2 (your chip/card) is known. There has been a report that this 
is a regression since 2.6.20, or so, has not been confirmed. With a 2.6.21 kernel, I got an iperf 
transmit rate of 4 Mbs, but that quickly dropped to 0.3 Mbs without me changing anything - I just 
repeated the iperf command. I will be doing a bisection on bcm43xx to see if I can indeed find a 
regression.

As for the loss of connection in an environment with lots of AP's, I cannot duplicate that 
environment. Has anyone else seen this with b43, or with some other mac80211 driver. Perhaps we can 
localize the problem component. Is there a possibility of buffer overflow in the scan results with 
that many AP's?

Larry



From dwmw2 at infradead.org  Sat Sep  1 01:55:35 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Sat, 01 Sep 2007 00:55:35 +0100
Subject: b43legacy woes
In-Reply-To: <46D8957D.2010705@lwfinger.net>
References: <BAY128-W312E506592CDC1EF65AF0C86CE0@phx.gbl>
	<46D8957D.2010705@lwfinger.net>
Message-ID: <1188604535.985.277.camel@pmac.infradead.org>

On Fri, 2007-08-31 at 17:26 -0500, Larry Finger wrote:
> The poor performance of the BCM4306/2 (your chip/card) is known. There has been a report that this 
> is a regression since 2.6.20, or so, has not been confirmed. With a 2.6.21 kernel, I got an iperf 
> transmit rate of 4 Mbs, but that quickly dropped to 0.3 Mbs without me changing anything - I just 
> repeated the iperf command. 

That reminds me... I accidentally invented a new wireless test. It's
intended to stream the full OS images to OLPC laptops on the production
line, and does so by multicast -- so there are no link-layer ACKs and
retries compensating for your packet loss; it all gets reported.

It's in git://git.infradead.org/mtd-utils.git; the tools are recv_image
and serve_image.

usage: recv_image <host> <port> <mtddev>
usage: serve_image <host> <port> <image> <erasesize> [<tx_rate>]

A $ dd if=/dev/urandom of=testfile bs=131072 count=50
A $ ./serve_image ff0f::114 12345 testfile 131072 85
	Inter-packet delay (avg): 32858?s
	Transmit rate: 85 KiB/s
	Checking CRC....85a0d369
	Checking block CRCS.... 50/50
	Image size 6400 KiB (0x00640000). 50 blocks at 47 pkts/block
	Estimated transmit time per cycle: 77s
	Sending data block 004e0000 packet  15/70    (85 KiB/s)    


B $ ./recv_image ff0f::114 12345 foo
	MEMGETINFO: Inappropriate ioctl for device
	Receive to file bar with (assumed) erasesize 131072
	Received 750/2350 (31%) in 25s @82KiB/s, 6 lost (0%), 0 dup/xs  

You can use it unicast too, and/or with Legacy IP instead of IPv6.

If your AP sends all multicast at 1Mb/s, then 85 KiB/s is about all
you'll get. If you can configure the Basic Rate set not to include the
slower speeds, or if you can change the multicast rate (which could
actually be _any_ rate in the Basic Rate set), then you can go faster.
I find it works quite nicely at 24Mb/s.

-- 
dwmw2



From mjg59 at srcf.ucam.org  Sat Sep  1 02:05:07 2007
From: mjg59 at srcf.ucam.org (Matthew Garrett)
Date: Sat, 1 Sep 2007 01:05:07 +0100
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <46D86838.2050101@lwfinger.net>
References: <46D84420.8000909@edavies.nildram.co.uk>
	<1188579929.985.213.camel@pmac.infradead.org>
	<46D84F75.4000402@lwfinger.net>
	<46D860F1.5040809@edavies.nildram.co.uk>
	<46D86838.2050101@lwfinger.net>
Message-ID: <20070901000507.GA2815@srcf.ucam.org>

On Fri, Aug 31, 2007 at 02:12:56PM -0500, Larry Finger wrote:

> It is pretty stupid of Ubuntu to move the firmware into this kind of folder. Do they expect the 
> firmware to change the same as modules? If openSUSE did this, I would have to be unpacking or 
> copying my firmware several times a day. I have already run 3 new kernels today.

We don't. Shipped firmware is provided in /lib/firmware/`uname -r` in 
order to ensure that we can keep it in sync with module updates. 
User-installed firmware can stay in /lib/firmware.

-- 
Matthew Garrett | mjg59 at srcf.ucam.org


From larry.finger at lwfinger.net  Sat Sep  1 03:03:09 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 31 Aug 2007 20:03:09 -0500
Subject: Broadcom 4311 on HP 350 laptop
In-Reply-To: <20070901000507.GA2815@srcf.ucam.org>
References: <46D84420.8000909@edavies.nildram.co.uk>
	<1188579929.985.213.camel@pmac.infradead.org>
	<46D84F75.4000402@lwfinger.net>
	<46D860F1.5040809@edavies.nildram.co.uk>
	<46D86838.2050101@lwfinger.net>
	<20070901000507.GA2815@srcf.ucam.org>
Message-ID: <46D8BA4D.7020303@lwfinger.net>

Matthew Garrett wrote:
> On Fri, Aug 31, 2007 at 02:12:56PM -0500, Larry Finger wrote:
> 
> We don't. Shipped firmware is provided in /lib/firmware/`uname -r` in 
> order to ensure that we can keep it in sync with module updates. 
> User-installed firmware can stay in /lib/firmware.
> 

Sorry. I thought that when Ed had his firmware in /lib/firmware, his system couldn't find it. I must 
have read the dump wrong.

The fact remains that you should turn on debugging for bcm43xx. I understand that users want to get 
minimal logs, but the debugging output is minimal and pretty essential for initial trouble shooting.

Larry




From mb at bu3sch.de  Sat Sep  1 14:30:29 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 1 Sep 2007 14:30:29 +0200
Subject: RFC bcm43xx: Fix potential race in shutdown of work queses
In-Reply-To: <200708311943.16751.mb@bu3sch.de>
References: <46d84cbb.FOFfgaTFNALi9I3F%Larry.Finger@lwfinger.net>
	<200708311943.16751.mb@bu3sch.de>
Message-ID: <200709011430.30021.mb@bu3sch.de>

On Friday 31 August 2007 19:43:16 Michael Buesch wrote:
> > @@ -4164,7 +4166,6 @@ static void bcm43xx_chip_reset(struct wo
> >  
> >  	mutex_lock(&(bcm)->mutex);
> >  	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
> > -		bcm43xx_periodic_tasks_delete(bcm);
> 
> Look at the comment below. That also applies here.

> > Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> > ===================================================================
> > --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> > +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> > @@ -327,7 +327,6 @@ static ssize_t bcm43xx_attr_phymode_stor
> >  		goto out;
> >  	}
> >  
> > -	bcm43xx_periodic_tasks_delete(bcm);
> 
> Well, this is tricky crap code.
> This breaks it.
> Look at the !err case below. We re-enable pwork there.
> We only do it for !err. So when core select failed, we
> end up without pwork, which is what we want.
> I think it might be OK to simply remove the delete _and_
> the setup below, as select core sets status to UNINIT when
> it failed. So pwork will bail out early (if you change your
> patch above as I suggested).
> 
> >  	mutex_lock(&(bcm)->mutex);
> >  	err = bcm43xx_select_wireless_core(bcm, phytype);
> >  	if (!err)
> > 
> > 

I thought a bit more about this and it turns out that I was wrong.
The bcm43xx_periodic_tasks_delete() and _setup() calls must both stay there.
Otherwise you will create a race condition.

select_wireless_core() sets status to UNINIT,
pwork runs and cancels because of the UNINIT state,
select_wireless_core() sets the status to INITED again,
pwork does not rearm itself anymore.

So we must first disable pwork, then select the core,
then reenable it again.

Same goes for the chip_reset function.

-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Sun Sep  2 03:24:00 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 01 Sep 2007 20:24:00 -0500
Subject: Asking for BCM4306/2 results
Message-ID: <46DA10B0.8070509@lwfinger.net>

There have been reports that the BCM4306/2 device used to work better than it does in b43legacy. I 
worked Friday night and Saturday trying to discover which kernel versions might work better, but I 
did not succeed. I tested 2.6.18.2, 2.6.19, and 2.6.20. All 3 gave iperf transmission rates of 5 Mbs 
and receive rates of 3 Mbs with a bit rate of 11M. At 24M, I sometimes saw rates up to 2 Mbs, but 
these were transient. The "stable" rate was 0.3 Mbs.

If you have a specific kernel that reliably gets higher rates at 24M than it does at 11M, please 
tell me which version, and what firmware you are using, in case that is important.

Just to reiterate, the card of interest is the one that uses b43legacy, not b43. From what I hear, 
the BCM4306s that use b43 are working OK.

Thanks,

Larry


From Larry.Finger at lwfinger.net  Mon Sep  3 21:28:23 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 03 Sep 2007 14:28:23 -0500
Subject: RFC V2 bcm43xx: Fix potential race in shutdown of work queues
Message-ID: <46dc6057.sXmM4nQhoObu+mF9%Larry.Finger@lwfinger.net>

This patch fixes a problem with work queues during shutdown. The bug
seems to be responsible for the boot-time crashes reported in
http://bugzilla.kernel.org/show_bug.cgi?id=8937.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -3197,6 +3197,9 @@ static void bcm43xx_periodic_work_handle
 	unsigned long orig_trans_start = 0;
 
 	mutex_lock(&bcm->mutex);
+	/* keep from doing and rearming periodic work if shutting down */
+	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
+		goto unlock_mutex;
 	if (unlikely(bcm->periodic_state % 60 == 0)) {
 		/* Periodic work will take a long time, so we want it to
 		 * be preemtible.
@@ -3242,6 +3245,7 @@ static void bcm43xx_periodic_work_handle
 	mmiowb();
 	bcm->periodic_state++;
 	spin_unlock_irqrestore(&bcm->irq_lock, flags);
+unlock_mutex:
 	mutex_unlock(&bcm->mutex);
 }
 
@@ -3338,6 +3342,14 @@ static void bcm43xx_free_board(struct bc
 	bcm43xx_periodic_tasks_delete(bcm);
 
 	mutex_lock(&(bcm)->mutex);
+	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
+	mutex_unlock(&(bcm)->mutex);
+
+	/* next 2 steps must be unlocked, else they may deadlock */
+	cancel_work_sync(&bcm->restart_work);
+	cancel_delayed_work_sync(&bcm->periodic_work);
+
+	mutex_lock(&(bcm)->mutex);
 	bcm43xx_shutdown_all_wireless_cores(bcm);
 	bcm43xx_pctl_set_crystal(bcm, 0);
 	mutex_unlock(&(bcm)->mutex);
@@ -4030,7 +4042,6 @@ static int bcm43xx_net_stop(struct net_d
 	err = bcm43xx_disable_interrupts_sync(bcm);
 	assert(!err);
 	bcm43xx_free_board(bcm);
-	flush_scheduled_work();
 
 	return 0;
 }
@@ -4165,6 +4176,7 @@ static void bcm43xx_chip_reset(struct wo
 	mutex_lock(&(bcm)->mutex);
 	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
 		bcm43xx_periodic_tasks_delete(bcm);
+		bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
 		phy = bcm43xx_current_phy(bcm);
 		err = bcm43xx_select_wireless_core(bcm, phy->type);
 		if (!err)


From barryk+bcm at gmail.com  Mon Sep  3 23:58:19 2007
From: barryk+bcm at gmail.com (Kevin Barry)
Date: Mon, 3 Sep 2007 17:58:19 -0400
Subject: Hardware problem sb_id_hi is 0xffffffff
Message-ID: <c8db6ec20709031458w7bf7852ej1a221571ada1010b@mail.gmail.com>

Hello,

If I just need to buy a new card just let me know. The card does NOT
work in Window any more. But I'm curious.

I have a Broadcom card that reports itself as the 14e4:4320, 4320
which I understand to mean 4306. In the past I successfully used this
card under Linux using both ndiswrapper and the bcm43xx driver. I
would assume it worked under Windows then as well, I never tried until
now when it does not work under ndiswrapper, bcm43xx or Windows.

I had a hard drive failure which required opening up the computer and
it's possible the hard drive failed due to humidity (The computer was
left by an open window during a rain storm while it was on. However
the computer stayed on that whole time and was shut down normally. It
was a few days later when I tried to turn it on that the hard drive
stopped working). Perhaps this is related to the card failure as well,
or perhaps static discharge while I was inside the notebook.


Using the BCM43xx driver I initially get the "Could not determine Chip
ID" error. Manually overriding the chip_id to be 0x4306 gets past that
error, but then it fails to read core #2. The first two cores look
wrong as well (Core 0 is reported as ID 0x34 Rev 0x51 vendor 0x314e).

Finally I outputted the value of sb_id_hi and it appears to be 0xFFFFFFFF.

So perhaps I should just buy a new card. But perhaps I could hack the
driver to work enough to dump the ssb_sprom and then see if that could
be repaired?

Thanks for the help. And thanks for the excellent driver.


From mailinglist at foo-lounge.de  Tue Sep  4 05:31:06 2007
From: mailinglist at foo-lounge.de (Timo Reimann)
Date: Tue, 04 Sep 2007 05:31:06 +0200
Subject: driver dis-associates on laptop lid close
Message-ID: <46DCD17A.6060607@foo-lounge.de>

Hi all,

I'm having the following issue with a Broadcom 4306 802.11b/g mini-PCI
card running under Ubuntu Feisty (7.04) kernel 2.6.20 and 2.6.22 with
the bcm43xx driver on an IBM Thinkpad T40.

Whenever I close my laptop's lid, the wifi interface seems to stop
working as I can tell by trying to ping the machine remotely: It works
right before I close the lid, stops when it's shut, and *mostly* works
again if I re-open. Same thing with any other network service, e.g. ssh.

The *mostly*-part is what is giving me headaches. Although iwconfig
shows that the association to my AP is never dropped and the interface
is still configured in terms of IP address, netmask and such, every now
and then I cannot connect to either LAN or WAN machines, and all I can
do in such a case is re-load the driver and restart the interface. Apart
from that, I'd prefer my laptop to stay connected even when the lid is
closed.

I have two reasons why I suspect the Broadcom driver to be responsible:
First, I have tried my best to make sure no other mechanism may be
blamed for the observed behavior, including disabling ACPI/APM/APIC on
bootup; disabling acpid; making sure no hiberating/suspending takes
place; and checking the BIOS power management settings.

Second, I used to use ndiswrapper for this machine but choose to switch
to the bcm43xx driver since the first would not reliably connect my box
during start-up. If it did connect, however, the link would never fail
during lid closure (while not changing anything else, i.e. same network
configuration tools were used during, before, and after the switch).

Therefore, I'd be glad if anyone has a hint what else I could try to fix
this problem. Especially, I'm curious if any of the bcm43xx module
parameters deal with some power management/suspend control part I could
tweak. (I wasn't able to figure what every `modinfo'-listed argument means.)

Thanks for any help. If I forgot some vital piece of information, please
don't hesitate to ask.


Cheers,

--Timo


From gavron at Wetwork.Net  Tue Sep  4 06:17:01 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Mon, 03 Sep 2007 21:17:01 -0700
Subject: driver dis-associates on laptop lid close
In-Reply-To: <46DCD17A.6060607@foo-lounge.de>
References: <46DCD17A.6060607@foo-lounge.de>
Message-ID: <46DCDC3D.20800@Wetwork.Net>

iwconfig shows the last AP associated, even if there is no association.
You can easily test this... associate, ping, then
iwconfig INTFCNAME essid "this does not exist"
iwconfig

You'll see the AP MAC address is still there.

What looks like is your power mode is set to suspend on lid close.  If 
you fix that you'll find your problem goes away.

In gnome on F7 I go to system->preferences->system->power management and 
change what lid-closed behavior is.

Ehud

Timo Reimann wrote:
> Hi all,
>
> I'm having the following issue with a Broadcom 4306 802.11b/g mini-PCI
> card running under Ubuntu Feisty (7.04) kernel 2.6.20 and 2.6.22 with
> the bcm43xx driver on an IBM Thinkpad T40.
>
> Whenever I close my laptop's lid, the wifi interface seems to stop
> working as I can tell by trying to ping the machine remotely: It works
> right before I close the lid, stops when it's shut, and *mostly* works
> again if I re-open. Same thing with any other network service, e.g. ssh.
>
> The *mostly*-part is what is giving me headaches. Although iwconfig
> shows that the association to my AP is never dropped and the interface
> is still configured in terms of IP address, netmask and such, every now
> and then I cannot connect to either LAN or WAN machines, and all I can
> do in such a case is re-load the driver and restart the interface. Apart
> from that, I'd prefer my laptop to stay connected even when the lid is
> closed.
>
> I have two reasons why I suspect the Broadcom driver to be responsible:
> First, I have tried my best to make sure no other mechanism may be
> blamed for the observed behavior, including disabling ACPI/APM/APIC on
> bootup; disabling acpid; making sure no hiberating/suspending takes
> place; and checking the BIOS power management settings.
>
> Second, I used to use ndiswrapper for this machine but choose to switch
> to the bcm43xx driver since the first would not reliably connect my box
> during start-up. If it did connect, however, the link would never fail
> during lid closure (while not changing anything else, i.e. same network
> configuration tools were used during, before, and after the switch).
>
> Therefore, I'd be glad if anyone has a hint what else I could try to fix
> this problem. Especially, I'm curious if any of the bcm43xx module
> parameters deal with some power management/suspend control part I could
> tweak. (I wasn't able to figure what every `modinfo'-listed argument means.)
>
> Thanks for any help. If I forgot some vital piece of information, please
> don't hesitate to ask.
>
>
> Cheers,
>
> --Timo
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070903/352f310f/attachment.bin>

From mailinglist at foo-lounge.de  Tue Sep  4 13:07:39 2007
From: mailinglist at foo-lounge.de (Timo Reimann)
Date: Tue, 04 Sep 2007 13:07:39 +0200
Subject: driver dis-associates on laptop lid close
In-Reply-To: <46DCDC3D.20800@Wetwork.Net>
References: <46DCD17A.6060607@foo-lounge.de> <46DCDC3D.20800@Wetwork.Net>
Message-ID: <46DD3C7B.6030201@foo-lounge.de>

Hello Ehud,


I figured it out, and it was something very different: My laptop and the
AP were too far away from each other.

For testing purposes, I placed my box directly in front of my AP. Then,
it wouldn't cease networking even if I shut the lid. On the contrary,
when sitting on the couch, I must be at a critical distance.

Still wondering, though, why it would work with ndiswrapper flawlessly.
Could it be that the bcm43xx driver doesn't push the signal level as
much as ndiswrapper possibly did?


Ehud Gavron wrote:
> What looks like is your power mode is set to suspend on lid close.  If
> you fix that you'll find your problem goes away.
> 
> In gnome on F7 I go to system->preferences->system->power management and
> change what lid-closed behavior is.

For the sake of completeness: This laptop uses KDE. Kpowersave was
running but configured not to do anything on lid closure.

Thanks for helping!


Cheers,

--Timo



> Timo Reimann wrote:
>> Hi all,
>>
>> I'm having the following issue with a Broadcom 4306 802.11b/g mini-PCI
>> card running under Ubuntu Feisty (7.04) kernel 2.6.20 and 2.6.22 with
>> the bcm43xx driver on an IBM Thinkpad T40.
>>
>> Whenever I close my laptop's lid, the wifi interface seems to stop
>> working as I can tell by trying to ping the machine remotely: It works
>> right before I close the lid, stops when it's shut, and *mostly* works
>> again if I re-open. Same thing with any other network service, e.g. ssh.
>>
>> The *mostly*-part is what is giving me headaches. Although iwconfig
>> shows that the association to my AP is never dropped and the interface
>> is still configured in terms of IP address, netmask and such, every now
>> and then I cannot connect to either LAN or WAN machines, and all I can
>> do in such a case is re-load the driver and restart the interface. Apart
>> from that, I'd prefer my laptop to stay connected even when the lid is
>> closed.
>>
>> I have two reasons why I suspect the Broadcom driver to be responsible:
>> First, I have tried my best to make sure no other mechanism may be
>> blamed for the observed behavior, including disabling ACPI/APM/APIC on
>> bootup; disabling acpid; making sure no hiberating/suspending takes
>> place; and checking the BIOS power management settings.
>>
>> Second, I used to use ndiswrapper for this machine but choose to switch
>> to the bcm43xx driver since the first would not reliably connect my box
>> during start-up. If it did connect, however, the link would never fail
>> during lid closure (while not changing anything else, i.e. same network
>> configuration tools were used during, before, and after the switch).
>>
>> Therefore, I'd be glad if anyone has a hint what else I could try to fix
>> this problem. Especially, I'm curious if any of the bcm43xx module
>> parameters deal with some power management/suspend control part I could
>> tweak. (I wasn't able to figure what every `modinfo'-listed argument
>> means.)
>>
>> Thanks for any help. If I forgot some vital piece of information, please
>> don't hesitate to ask.
>>
>>
>> Cheers,
>>
>> --Timo
>> _______________________________________________
>> Bcm43xx-dev mailing list
>> Bcm43xx-dev at lists.berlios.de
>> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>>   



From mb at bu3sch.de  Tue Sep  4 15:10:05 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Sep 2007 15:10:05 +0200
Subject: RFC V2 bcm43xx: Fix potential race in shutdown of work queues
In-Reply-To: <46dc6057.sXmM4nQhoObu+mF9%Larry.Finger@lwfinger.net>
References: <46dc6057.sXmM4nQhoObu+mF9%Larry.Finger@lwfinger.net>
Message-ID: <200709041510.05813.mb@bu3sch.de>

On Monday 03 September 2007, Larry Finger wrote:
> This patch fixes a problem with work queues during shutdown. The bug
> seems to be responsible for the boot-time crashes reported in
> http://bugzilla.kernel.org/show_bug.cgi?id=8937.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> ===================================================================
> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> @@ -3197,6 +3197,9 @@ static void bcm43xx_periodic_work_handle
>  	unsigned long orig_trans_start = 0;
>  
>  	mutex_lock(&bcm->mutex);
> +	/* keep from doing and rearming periodic work if shutting down */
> +	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
> +		goto unlock_mutex;
>  	if (unlikely(bcm->periodic_state % 60 == 0)) {
>  		/* Periodic work will take a long time, so we want it to
>  		 * be preemtible.
> @@ -3242,6 +3245,7 @@ static void bcm43xx_periodic_work_handle
>  	mmiowb();
>  	bcm->periodic_state++;
>  	spin_unlock_irqrestore(&bcm->irq_lock, flags);
> +unlock_mutex:
>  	mutex_unlock(&bcm->mutex);
>  }
>  
> @@ -3338,6 +3342,14 @@ static void bcm43xx_free_board(struct bc
>  	bcm43xx_periodic_tasks_delete(bcm);
>  
>  	mutex_lock(&(bcm)->mutex);
> +	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
> +	mutex_unlock(&(bcm)->mutex);
> +
> +	/* next 2 steps must be unlocked, else they may deadlock */
> +	cancel_work_sync(&bcm->restart_work);
> +	cancel_delayed_work_sync(&bcm->periodic_work);
> +
> +	mutex_lock(&(bcm)->mutex);
>  	bcm43xx_shutdown_all_wireless_cores(bcm);
>  	bcm43xx_pctl_set_crystal(bcm, 0);
>  	mutex_unlock(&(bcm)->mutex);
> @@ -4030,7 +4042,6 @@ static int bcm43xx_net_stop(struct net_d
>  	err = bcm43xx_disable_interrupts_sync(bcm);
>  	assert(!err);
>  	bcm43xx_free_board(bcm);
> -	flush_scheduled_work();
>  
>  	return 0;
>  }
> @@ -4165,6 +4176,7 @@ static void bcm43xx_chip_reset(struct wo
>  	mutex_lock(&(bcm)->mutex);
>  	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
>  		bcm43xx_periodic_tasks_delete(bcm);
> +		bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);

No, don't touch that function here. select_wireless_core will take care
of setting the status correctly.
The rest of the patch is OK.

>  		phy = bcm43xx_current_phy(bcm);
>  		err = bcm43xx_select_wireless_core(bcm, phy->type);
>  		if (!err)
> 
> 




From mb at bu3sch.de  Tue Sep  4 15:12:43 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Sep 2007 15:12:43 +0200
Subject: Hardware problem sb_id_hi is 0xffffffff
In-Reply-To: <c8db6ec20709031458w7bf7852ej1a221571ada1010b@mail.gmail.com>
References: <c8db6ec20709031458w7bf7852ej1a221571ada1010b@mail.gmail.com>
Message-ID: <200709041512.43805.mb@bu3sch.de>

On Monday 03 September 2007, Kevin Barry wrote:
> Finally I outputted the value of sb_id_hi and it appears to be 0xFFFFFFFF.
> 
> So perhaps I should just buy a new card.

Yeah.

> But perhaps I could hack the 
> driver to work enough to dump the ssb_sprom and then see if that could
> be repaired?

This has nothing to do with the sprom. sb_id_hi is a backplane
register. I'd say your card is pretty much broken.


From mb at bu3sch.de  Tue Sep  4 15:14:23 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Sep 2007 15:14:23 +0200
Subject: [PATCH] b43: Fix HW key clearing.
Message-ID: <200709041514.23773.mb@bu3sch.de>

This fixes clearing of the HW keys.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-dev/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-08-31 15:37:00.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-08-31 16:01:34.000000000 +0200
@@ -727,7 +727,7 @@ static void key_write(struct b43_wldev *
 
 static void keymac_write(struct b43_wldev *dev, u8 index, const u8 * addr)
 {
-	u32 addrtmp[2];
+	u32 addrtmp[2] = { 0, 0, };
 	u8 per_sta_keys_start = 8;
 
 	if (b43_new_kidx_api(dev))
@@ -741,12 +741,14 @@ static void keymac_write(struct b43_wlde
 	 */
 	index -= per_sta_keys_start;
 
-	addrtmp[0] = addr[0];
-	addrtmp[0] |= ((u32) (addr[1]) << 8);
-	addrtmp[0] |= ((u32) (addr[2]) << 16);
-	addrtmp[0] |= ((u32) (addr[3]) << 24);
-	addrtmp[1] = addr[4];
-	addrtmp[1] |= ((u32) (addr[5]) << 8);
+	if (addr) {
+		addrtmp[0] = addr[0];
+		addrtmp[0] |= ((u32) (addr[1]) << 8);
+		addrtmp[0] |= ((u32) (addr[2]) << 16);
+		addrtmp[0] |= ((u32) (addr[3]) << 24);
+		addrtmp[1] = addr[4];
+		addrtmp[1] |= ((u32) (addr[5]) << 8);
+	}
 
 	if (dev->dev->id.revision >= 5) {
 		/* Receive match transmitter address mechanism */
@@ -776,7 +778,7 @@ static void do_key_write(struct b43_wlde
 			 u8 index, u8 algorithm,
 			 const u8 * key, size_t key_len, const u8 * mac_addr)
 {
-	u8 buf[B43_SEC_KEYSIZE];
+	u8 buf[B43_SEC_KEYSIZE] = { 0, };
 	u8 per_sta_keys_start = 8;
 
 	if (b43_new_kidx_api(dev))
@@ -785,10 +787,10 @@ static void do_key_write(struct b43_wlde
 	B43_WARN_ON(index >= dev->max_nr_keys);
 	B43_WARN_ON(key_len > B43_SEC_KEYSIZE);
 
-	memset(buf, 0, sizeof(buf));
 	if (index >= per_sta_keys_start)
-		keymac_write(dev, index, buf);	/* First zero out mac. */
-	memcpy(buf, key, key_len);
+		keymac_write(dev, index, NULL);	/* First zero out mac. */
+	if (key)
+		memcpy(buf, key, key_len);
 	key_write(dev, index, algorithm, buf);
 	if (index >= per_sta_keys_start)
 		keymac_write(dev, index, mac_addr);
@@ -804,10 +806,13 @@ static int b43_key_write(struct b43_wlde
 {
 	int i;
 	int sta_keys_start;
-	bool removal = 0;
 
 	if (key_len > B43_SEC_KEYSIZE)
 		return -EINVAL;
+	for (i = 0; i < dev->max_nr_keys; i++) {
+		/* Check that we don't already have this key. */
+		B43_WARN_ON(dev->key[i].keyconf == keyconf);
+	}
 	if (index < 0) {
 		/* Either pairwise key or address is 00:00:00:00:00:00
 		 * for transmit-only keys. Search the index. */
@@ -816,24 +821,13 @@ static int b43_key_write(struct b43_wlde
 		else
 			sta_keys_start = 8;
 		for (i = sta_keys_start; i < dev->max_nr_keys; i++) {
-			if (dev->key[i].keyconf == keyconf) {
-				/* we already have this key so we must be
-				 * in removal (there is no update) */
-				removal = 1;
+			if (!dev->key[i].keyconf) {
+				/* found empty */
 				index = i;
 				break;
 			}
 		}
 		if (index < 0) {
-			for (i = sta_keys_start; i < dev->max_nr_keys; i++) {
-				if (!dev->key[i].keyconf) {
-					/* found empty */
-					index = i;
-					break;
-				}
-			}
-		}
-		if (index < 0) {
 			b43err(dev->wl, "Out of hardware key memory\n");
 			return -ENOSPC;
 		}
@@ -847,22 +841,32 @@ static int b43_key_write(struct b43_wlde
 		do_key_write(dev, index + 4, algorithm, key, key_len, NULL);
 	}
 	keyconf->hw_key_idx = index;
-	dev->key[index].keyconf = removal ? NULL : keyconf;
+	dev->key[index].keyconf = keyconf;
+
+	return 0;
+}
+
+static int b43_key_clear(struct b43_wldev *dev, int index)
+{
+	if (B43_WARN_ON((index < 0) || (index >= dev->max_nr_keys)))
+		return -EINVAL;
+	do_key_write(dev, index, B43_SEC_ALGO_NONE,
+		     NULL, B43_SEC_KEYSIZE, NULL);
+	if ((index <= 3) && !b43_new_kidx_api(dev)) {
+		do_key_write(dev, index + 4, B43_SEC_ALGO_NONE,
+			     NULL, B43_SEC_KEYSIZE, NULL);
+	}
+	dev->key[index].keyconf = NULL;
 
 	return 0;
 }
 
 static void b43_clear_keys(struct b43_wldev *dev)
 {
-	static const u8 zero[B43_SEC_KEYSIZE] = { 0 };
-	unsigned int i;
+	int i;
 
-	BUILD_BUG_ON(B43_SEC_KEYSIZE < ETH_ALEN);
-	for (i = 0; i < dev->max_nr_keys; i++) {
-		do_key_write(dev, i, B43_SEC_ALGO_NONE,
-			     zero, B43_SEC_KEYSIZE, zero);
-		dev->key[i].keyconf = NULL;
-	}
+	for (i = 0; i < dev->max_nr_keys; i++)
+		b43_key_clear(dev, i);
 }
 
 void b43_power_saving_ctl_bits(struct b43_wldev *dev, unsigned int ps_flags)
@@ -2962,12 +2966,7 @@ static int b43_dev_set_key(struct ieee80
 		}
 		break;
 	case DISABLE_KEY: {
-		static const u8 zero[B43_SEC_KEYSIZE] = { 0 };
-
-		algorithm = B43_SEC_ALGO_NONE;
-		err = b43_key_write(dev, index, algorithm,
-				    zero, B43_SEC_KEYSIZE,
-				    NULL, key);
+		err = b43_key_clear(dev, key->hw_key_idx);
 		if (err)
 			goto out_unlock;
 		break;


From mb at bu3sch.de  Tue Sep  4 15:16:00 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Sep 2007 15:16:00 +0200
Subject: [PATCH] b43: Add debugfs file to dump microcode registers
Message-ID: <200709041516.01095.mb@bu3sch.de>

This adds a debugfs file to dump all microcode registers.
Note that the dumping is racy, as microcode continues to run
while we loop over each register to dump it.

Cc: Johannes Berg <johannes at sipsolutions.net>
Cc: Larry Finger <larry.finger at lwfinger.net>
Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-dev/drivers/net/wireless/b43/debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/debugfs.c	2007-08-31 16:51:12.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/debugfs.c	2007-08-31 17:39:23.000000000 +0200
@@ -148,6 +148,39 @@ static ssize_t tsf_write_file(struct fil
 	return res;
 }
 
+static ssize_t ucode_regs_read_file(struct file *file, char __user * userbuf,
+				    size_t count, loff_t * ppos)
+{
+	struct b43_wldev *dev = file->private_data;
+	const size_t len = ARRAY_SIZE(big_buffer);
+	char *buf = big_buffer;
+	size_t pos = 0;
+	ssize_t res;
+	unsigned long flags;
+	int i;
+
+	mutex_lock(&big_buffer_mutex);
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (b43_status(dev) < B43_STAT_INITIALIZED) {
+		fappend("Board not initialized.\n");
+		goto out;
+	}
+
+	for (i = 0; i < 64; i++) {
+		fappend("r%d = 0x%04x\n", i,
+			b43_shm_read16(dev, B43_SHM_SCRATCH, i));
+	}
+
+out:
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
+	mutex_unlock(&big_buffer_mutex);
+
+	return res;
+}
+
 static ssize_t txstat_read_file(struct file *file, char __user * userbuf,
 				size_t count, loff_t * ppos)
 {
@@ -470,6 +503,11 @@ static struct file_operations tsf_fops =
 	.open = open_file_generic,
 };
 
+static struct file_operations ucode_regs_fops = {
+	.read = ucode_regs_read_file,
+	.open = open_file_generic,
+};
+
 static struct file_operations txstat_fops = {
 	.read = txstat_read_file,
 	.write = write_file_dummy,
@@ -575,6 +613,10 @@ void b43_debugfs_add_device(struct b43_w
 					    dev, &tsf_fops);
 	if (IS_ERR(e->dentry_tsf))
 		e->dentry_tsf = NULL;
+	e->dentry_ucode_regs = debugfs_create_file("ucode_regs", 0400, e->subdir,
+						   dev, &ucode_regs_fops);
+	if (IS_ERR(e->dentry_ucode_regs))
+		e->dentry_ucode_regs = NULL;
 	e->dentry_txstat = debugfs_create_file("tx_status", 0400, e->subdir,
 					       dev, &txstat_fops);
 	if (IS_ERR(e->dentry_txstat))
@@ -607,6 +649,7 @@ void b43_debugfs_remove_device(struct b4
 	b43_remove_dynamic_debug(dev);
 	debugfs_remove(e->dentry_loctls);
 	debugfs_remove(e->dentry_tsf);
+	debugfs_remove(e->dentry_ucode_regs);
 	debugfs_remove(e->dentry_txstat);
 	debugfs_remove(e->dentry_restart);
 	debugfs_remove(e->dentry_txpower_g);
Index: wireless-dev/drivers/net/wireless/b43/debugfs.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/debugfs.h	2007-08-31 16:51:12.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/debugfs.h	2007-08-31 17:39:23.000000000 +0200
@@ -31,6 +31,7 @@ struct b43_txstatus_log {
 struct b43_dfsentry {
 	struct dentry *subdir;
 	struct dentry *dentry_tsf;
+	struct dentry *dentry_ucode_regs;
 	struct dentry *dentry_txstat;
 	struct dentry *dentry_txpower_g;
 	struct dentry *dentry_restart;


From mb at bu3sch.de  Tue Sep  4 15:17:28 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Sep 2007 15:17:28 +0200
Subject: [PATCH] b43: Add debugfs file to dump SHM
Message-ID: <200709041517.28751.mb@bu3sch.de>

This adds a file to dump the SHM.
Note that SHM dumping is racy, as the microcode continues to run
while we dump the SHM.

Cc: Johannes Berg <johannes at sipsolutions.net>
Cc: Larry Finger <larry.finger at lwfinger.net>
Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-dev/drivers/net/wireless/b43/debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/debugfs.c	2007-08-31 17:32:28.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/debugfs.c	2007-08-31 17:36:52.000000000 +0200
@@ -181,6 +181,42 @@ out:
 	return res;
 }
 
+static ssize_t shm_read_file(struct file *file, char __user * userbuf,
+			     size_t count, loff_t * ppos)
+{
+	struct b43_wldev *dev = file->private_data;
+	const size_t len = ARRAY_SIZE(big_buffer);
+	u8 *buf = big_buffer;
+	__le16 *le16buf = (__le16*)big_buffer;
+	size_t pos = 0;
+	ssize_t res;
+	unsigned long flags;
+	int i;
+	u16 tmp;
+
+	mutex_lock(&big_buffer_mutex);
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (b43_status(dev) < B43_STAT_INITIALIZED) {
+		fappend("Board not initialized.\n");
+		goto out;
+	}
+
+	for (i = 0; i < 0x1000; i++) {
+		tmp = b43_shm_read16(dev, B43_SHM_SHARED, 2 * i);
+		le16buf[i] = cpu_to_le16(tmp);
+		pos += sizeof(tmp);
+	}
+
+out:
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
+	mutex_unlock(&big_buffer_mutex);
+
+	return res;
+}
+
 static ssize_t txstat_read_file(struct file *file, char __user * userbuf,
 				size_t count, loff_t * ppos)
 {
@@ -508,6 +544,11 @@ static struct file_operations ucode_regs
 	.open = open_file_generic,
 };
 
+static struct file_operations shm_fops = {
+	.read = shm_read_file,
+	.open = open_file_generic,
+};
+
 static struct file_operations txstat_fops = {
 	.read = txstat_read_file,
 	.write = write_file_dummy,
@@ -617,6 +658,10 @@ void b43_debugfs_add_device(struct b43_w
 						   dev, &ucode_regs_fops);
 	if (IS_ERR(e->dentry_ucode_regs))
 		e->dentry_ucode_regs = NULL;
+	e->dentry_shm = debugfs_create_file("shm", 0400, e->subdir,
+					    dev, &shm_fops);
+	if (IS_ERR(e->dentry_shm))
+		e->dentry_shm = NULL;
 	e->dentry_txstat = debugfs_create_file("tx_status", 0400, e->subdir,
 					       dev, &txstat_fops);
 	if (IS_ERR(e->dentry_txstat))
@@ -650,6 +695,7 @@ void b43_debugfs_remove_device(struct b4
 	debugfs_remove(e->dentry_loctls);
 	debugfs_remove(e->dentry_tsf);
 	debugfs_remove(e->dentry_ucode_regs);
+	debugfs_remove(e->dentry_shm);
 	debugfs_remove(e->dentry_txstat);
 	debugfs_remove(e->dentry_restart);
 	debugfs_remove(e->dentry_txpower_g);
Index: wireless-dev/drivers/net/wireless/b43/debugfs.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/debugfs.h	2007-08-31 17:32:09.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/debugfs.h	2007-08-31 17:32:44.000000000 +0200
@@ -32,6 +32,7 @@ struct b43_dfsentry {
 	struct dentry *subdir;
 	struct dentry *dentry_tsf;
 	struct dentry *dentry_ucode_regs;
+	struct dentry *dentry_shm;
 	struct dentry *dentry_txstat;
 	struct dentry *dentry_txpower_g;
 	struct dentry *dentry_restart;


From mb at bu3sch.de  Tue Sep  4 15:18:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Sep 2007 15:18:51 +0200
Subject: [PATCH] b43: Always drop crypt-failed packets.
Message-ID: <200709041518.52209.mb@bu3sch.de>

Drop packets for which the firmware was unable to decrypt it,
as we won't be able to decrypt them with the key, too.

Cc: Johannes Berg <johannes at sipsolutions.net>
Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-dev/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/xmit.c	2007-08-31 17:40:05.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/xmit.c	2007-08-31 18:33:38.000000000 +0200
@@ -465,6 +465,12 @@ void b43_rx(struct b43_wldev *dev, struc
 
 	if (macstat & B43_RX_MAC_FCSERR)
 		dev->wl->ieee_stats.dot11FCSErrorCount++;
+	if (macstat & B43_RX_MAC_DECERR) {
+		/* Decryption with the given key failed.
+		 * Drop the packet. We also won't be able to decrypt it with
+		 * the key in software. */
+		goto drop;
+	}
 
 	/* Skip PLCP and padding */
 	padding = (macstat & B43_RX_MAC_PADDING) ? 2 : 0;
@@ -483,7 +489,7 @@ void b43_rx(struct b43_wldev *dev, struc
 	fctl = le16_to_cpu(wlhdr->frame_control);
 	skb_trim(skb, skb->len - FCS_LEN);
 
-	if ((macstat & B43_RX_MAC_DEC) && !(macstat & B43_RX_MAC_DECERR)) {
+	if (macstat & B43_RX_MAC_DEC) {
 		unsigned int keyidx;
 		int wlhdr_len;
 		int iv_len;
@@ -573,7 +579,7 @@ void b43_rx(struct b43_wldev *dev, struc
 	ieee80211_rx_irqsafe(dev->wl->hw, skb, &status);
 
 	return;
-      drop:
+drop:
 	b43dbg(dev->wl, "RX: Packet dropped\n");
 	dev_kfree_skb_any(skb);
 }


From johannes at sipsolutions.net  Tue Sep  4 14:38:39 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 04 Sep 2007 14:38:39 +0200
Subject: mostly reverse engineered r4 microcode
Message-ID: <1188909519.9942.9.camel@johannes.berg>

Hey,

I wanted to know some things about the those pesky external conditions
and thought I could look at the old ucode because that, as you may
remember, uses four RCM matchers for finding crypto keys and I thought
it may be easy to identify that. Since I don't have any rev4 or lower
hardware, I simply matched the instructions in rev5 with those in rev4
and found all instructions that show up in the rev2 and rev4 microcodes
I have.

I'll be publishing my findings in the specs soon, the instruction format
is somewhat more spaced out, you have for example the lowest 6 bits
unused unless it's an external condition jump etc.

The revision 2 microcode I have is just over 2k instructions while the
revision 5 microcode with QoS and hardware crypto is about 2.8k, maybe
the difference helps :)

Larry, are you interested in crypto offload fpr rev4 cores? Revision 2
cores don't support crypto at all, but rev4 do and now that I'm able to
peek into the microcode I should be able to describe how it works.

Below is the instruction set reference I'll upload to the specs.

johannes
-- 
Instruction set reference for the revision 4 and lower Microcode.

[hex numbers have no placeholders but zeroes instead]

 hex  | binary                 | meaning

 00000  000000 0000 010c cccccc  jump on condition c false
 00000  000000 0000 001c cccccc  jump on condition c true
                                 newer microcode seems to have 8 bit conditions?
                                 the new microcode might have different
                                 condition numbers as well

 00400  000000 0001 0000 000000  nap
 00800  000000 0010 0000 000000  call
 00c00  000000 0011 0000 000000  ret

 20200  001000 0000 1000 000000  add
 20240  001000 0000 1001 000000  add + carry 
 20280  001000 0000 1010 000000  add [set carry]
 202c0  001000 0000 1011 000000  add + carry [set carry]

 20000  001000 0000 0000 000000  and
 20040  001000 0000 0001 000000  and ~
 20080  001000 0000 0010 000000  or
 200c0  001000 0000 0011 000000  xor

 20300  001000 0001 1000 000000  sub
 20340  001000 0001 1001 000000  sub + carry 
 20380  001000 0001 1010 000000  sub [set carry]
 203c0  001000 0001 1011 000000  sub + carry [set carry]

 20400  001000 0001 0000 000000  left shift
 20440  001000 0001 0001 000000  ? (unused)
 20480  001000 0001 0010 000000  right shift (unsigned)
 204c0  001000 0001 0011 000000  ? (unused)

 20500  001000 0001 0100 000000  left rotate
 20540  001000 0001 0101 000000  ? (unused)
 20580  001000 0001 0110 000000  right rotate
 205c0  001000 0001 0111 000000  ? (unused)

 28000  001010 mmmm ssss 000000  shift right over two registers
                                 (cf. "2MS" instruction in new ucode)
 2c000  001011 mmmm ssss 000000  or with shift and select
                                 (cf. "3MS" instruction in new ucode)

 30000  001100 0000 0000 000000  jump if (x & y)
 30001  001100 0000 0000 000001  jump if not (x & y)

 30040  001100 0000 0001 000000  jump if ((x & y) == 0)
 30041  001100 0000 0001 000001  jump if ((x & y) != 0)

 30300  001100 0000 1100 000000  jump equal
 30301  001100 0000 1100 000001  jump not equal
 30302  001100 0000 1100 000010  jump less (unsigned)
 30303  001100 0000 1100 000011  jump not less (unsigned)
 30304  001100 0000 1100 000100  jump more (unsigned)
 30305  001100 0000 1100 000101  jump not more (unsigned)
 30306  001100 0000 1100 000110  ? (unused)
 30307  001100 0000 1100 000111  ? (unused)
 30308  001100 0000 1100 001000  ? (unused)
 30309  001100 0000 1100 001001  ? (unused)
 3030a  001100 0000 1100 001010  jump less (signed)
 3030b  001100 0000 1100 001011  jump not less (signed)
 3030c  001100 0000 1100 001100  jump more (signed)
 3030d  001100 0000 1100 001101  jump not more (signed)
 3030e  001100 0000 1100 001110  ? (unused)
 3030f  001100 0000 1100 001111  ? (unused)

 38000  001110 mmmm ssss 000000  jump if zero after shift and mask
                                 jump if ((((yyy << 16 | xxx) >> s) & (1<<(m+1)-1)) == 0)
 38001  001110 mmmm ssss 000001  jump if nonzero after shift and mask
                                 jump if ((((yyy << 16 | xxx) >> s) & (1<<(m+1)-1)) != 0)

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070904/26bc4f07/attachment.pgp>

From johannes at sipsolutions.net  Tue Sep  4 15:45:52 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 04 Sep 2007 15:45:52 +0200
Subject: driver dis-associates on laptop lid close
In-Reply-To: <46DD3C7B.6030201@foo-lounge.de>
References: <46DCD17A.6060607@foo-lounge.de> <46DCDC3D.20800@Wetwork.Net>
	<46DD3C7B.6030201@foo-lounge.de>
Message-ID: <1188913552.9942.20.camel@johannes.berg>

On Tue, 2007-09-04 at 13:07 +0200, Timo Reimann wrote:

> I figured it out, and it was something very different: My laptop and the
> AP were too far away from each other.

Heh. Sounds like you got bitten by having antennas in the lid :)

> Still wondering, though, why it would work with ndiswrapper flawlessly.
> Could it be that the bcm43xx driver doesn't push the signal level as
> much as ndiswrapper possibly did?

Yes, the calibration code is surely not perfect. But it's also a HUGE
pain to reverse engineer.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070904/2bfbf13a/attachment.pgp>

From larry.finger at lwfinger.net  Tue Sep  4 17:21:43 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Sep 2007 10:21:43 -0500
Subject: mostly reverse engineered r4 microcode
In-Reply-To: <1188909519.9942.9.camel@johannes.berg>
References: <1188909519.9942.9.camel@johannes.berg>
Message-ID: <46DD7807.6090603@lwfinger.net>

Johannes Berg wrote:
> 
> Larry, are you interested in crypto offload fpr rev4 cores? Revision 2
> cores don't support crypto at all, but rev4 do and now that I'm able to
> peek into the microcode I should be able to describe how it works.

For completeness, we should probably offer hardware crypto. If I understand correctly, the hardware 
assist would be for WEP only and WPA would still be done in software. As a result, adding the 
hardware crypto will not be worth much effort.

Larry


From johannes at sipsolutions.net  Tue Sep  4 17:25:38 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 04 Sep 2007 17:25:38 +0200
Subject: mostly reverse engineered r4 microcode
In-Reply-To: <46DD7807.6090603@lwfinger.net>
References: <1188909519.9942.9.camel@johannes.berg>
	<46DD7807.6090603@lwfinger.net>
Message-ID: <1188919538.9942.40.camel@johannes.berg>

On Tue, 2007-09-04 at 10:21 -0500, Larry Finger wrote:
> Johannes Berg wrote:

> For completeness, we should probably offer hardware crypto. If I understand correctly, the hardware 
> assist would be for WEP only and WPA would still be done in software. As a result, adding the 
> hardware crypto will not be worth much effort.

I'm fairly sure that both AES and TKIP are supported even in older
hardware, though right now we don't support TKIP at all due to issues
with the phase 1 key mixing.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070904/6d266424/attachment.pgp>

From larry.finger at lwfinger.net  Tue Sep  4 17:34:44 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Sep 2007 10:34:44 -0500
Subject: mostly reverse engineered r4 microcode
In-Reply-To: <1188909519.9942.9.camel@johannes.berg>
References: <1188909519.9942.9.camel@johannes.berg>
Message-ID: <46DD7B14.1080806@lwfinger.net>

Johannes Berg wrote:
  Since I don't have any rev4 or lower
> hardware,

I meant to comment on this in my first reply, but forgot. I have a spare BCM4306/2 PCMCIA card that 
is rev 4. It has been a little damaged - the LEDs no longer work, but the radio and antenna are 
fine. If you want, I could send it to you on a more or less permanent loan. The only reason I would 
ever want it back is if my other rev 4 card were to fail.

Larry


From johannes at sipsolutions.net  Tue Sep  4 17:44:02 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 04 Sep 2007 17:44:02 +0200
Subject: mostly reverse engineered r4 microcode
In-Reply-To: <46DD7B14.1080806@lwfinger.net>
References: <1188909519.9942.9.camel@johannes.berg>
	<46DD7B14.1080806@lwfinger.net>
Message-ID: <1188920642.9942.44.camel@johannes.berg>

On Tue, 2007-09-04 at 10:34 -0500, Larry Finger wrote:

> I meant to comment on this in my first reply, but forgot. I have a spare BCM4306/2 PCMCIA card that 
> is rev 4. It has been a little damaged - the LEDs no longer work, but the radio and antenna are 
> fine. If you want, I could send it to you on a more or less permanent loan. The only reason I would 
> ever want it back is if my other rev 4 card were to fail.

I used to have one in cardbus form factor too but lost it at some point
(together with a bunch of other things :/ ). Not sure how much use it'll
be though, I've got the instruction set covered and I don't think I want
to write firmware for it.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070904/e69343de/attachment.pgp>

From Larry.Finger at lwfinger.net  Tue Sep  4 17:41:24 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Sep 2007 10:41:24 -0500
Subject: RFC V3 bcm43xx: Fix potential race in shutdown of work queues
Message-ID: <46dd7ca4.8UjuObD+8QWUHeuC%Larry.Finger@lwfinger.net>

A crash upon booting that is caused by bcm43xx has been reported [1] and
found to be due to a work queue being reinitialized while work on that
queue is still pending. This fix modifies the shutdown of work queues and
prevents periodic work from being requeued during shutdown. With this patch,
no more crashes on reboot were observed by the original reporter. I do not
get that particular failure on my system; however, when running a large
number of ifdown/ifup sequences, my system would occasionally hang with the
'caps lock' light blinking at roughly a 1 Hz rate. In addition, there were
infrequent failures in the firmware that resulted in 'IRQ READY TIMEOUT'
errors. With this patch, no more of the first type of failure occur, and
incidence of the second type is greatly reduced.

[1] http://bugzilla.kernel.org/show_bug.cgi?id=8937

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Michael,

The version I sent as 'RFC V2' had even more problems than the one you noted
as it suffered from the total crash with the blinking caps lock light. This
patch is a lot more solid.

Larry


 drivers/net/wireless/bcm43xx/bcm43xx_main.c  |   28 +++++++++++++++++++--------
 drivers/net/wireless/bcm43xx/bcm43xx_main.h  |    2 -
 drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c |    3 +-
 3 files changed, 23 insertions(+), 10 deletions(-)

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -3197,6 +3197,9 @@ static void bcm43xx_periodic_work_handle
 	unsigned long orig_trans_start = 0;
 
 	mutex_lock(&bcm->mutex);
+	/* keep from doing and rearming periodic work if shutting down */
+	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
+		goto unlock_mutex;
 	if (unlikely(bcm->periodic_state % 60 == 0)) {
 		/* Periodic work will take a long time, so we want it to
 		 * be preemtible.
@@ -3242,14 +3245,10 @@ static void bcm43xx_periodic_work_handle
 	mmiowb();
 	bcm->periodic_state++;
 	spin_unlock_irqrestore(&bcm->irq_lock, flags);
+unlock_mutex:
 	mutex_unlock(&bcm->mutex);
 }
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
-{
-	cancel_rearming_delayed_work(&bcm->periodic_work);
-}
-
 void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
 {
 	struct delayed_work *work = &bcm->periodic_work;
@@ -3299,6 +3298,14 @@ static int bcm43xx_rng_init(struct bcm43
 	return err;
 }
 
+void bcm43xx_cancel_work(struct bcm43xx_private *bcm)
+{
+	/* The system must be unlocked when this routine is entered.
+	 * If not, the next 2 steps may deadlock */
+	cancel_work_sync(&bcm->restart_work);
+	cancel_delayed_work_sync(&bcm->periodic_work);
+}
+
 static int bcm43xx_shutdown_all_wireless_cores(struct bcm43xx_private *bcm)
 {
 	int ret = 0;
@@ -3335,7 +3342,12 @@ static void bcm43xx_free_board(struct bc
 {
 	bcm43xx_rng_exit(bcm);
 	bcm43xx_sysfs_unregister(bcm);
-	bcm43xx_periodic_tasks_delete(bcm);
+
+	mutex_lock(&(bcm)->mutex);
+	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
+	mutex_unlock(&(bcm)->mutex);
+
+	bcm43xx_cancel_work(bcm);
 
 	mutex_lock(&(bcm)->mutex);
 	bcm43xx_shutdown_all_wireless_cores(bcm);
@@ -4030,7 +4042,7 @@ static int bcm43xx_net_stop(struct net_d
 	err = bcm43xx_disable_interrupts_sync(bcm);
 	assert(!err);
 	bcm43xx_free_board(bcm);
-	flush_scheduled_work();
+	bcm43xx_cancel_work(bcm);
 
 	return 0;
 }
@@ -4162,9 +4174,9 @@ static void bcm43xx_chip_reset(struct wo
 	struct bcm43xx_phyinfo *phy;
 	int err = -ENODEV;
 
+	bcm43xx_cancel_work(bcm);
 	mutex_lock(&(bcm)->mutex);
 	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm43xx_periodic_tasks_delete(bcm);
 		phy = bcm43xx_current_phy(bcm);
 		err = bcm43xx_select_wireless_core(bcm, phy->type);
 		if (!err)
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
@@ -122,7 +122,7 @@ void bcm43xx_wireless_core_reset(struct 
 void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
 void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
+void bcm43xx_cancel_work(struct bcm43xx_private *bcm);
 void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
 
 void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
@@ -327,8 +327,9 @@ static ssize_t bcm43xx_attr_phymode_stor
 		goto out;
 	}
 
-	bcm43xx_periodic_tasks_delete(bcm);
+	bcm43xx_cancel_work(bcm);
 	mutex_lock(&(bcm)->mutex);
+	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
 	err = bcm43xx_select_wireless_core(bcm, phytype);
 	if (!err)
 		bcm43xx_periodic_tasks_setup(bcm);


From mb at bu3sch.de  Tue Sep  4 17:58:53 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Sep 2007 17:58:53 +0200
Subject: RFC V3 bcm43xx: Fix potential race in shutdown of work queues
In-Reply-To: <46dd7ca4.8UjuObD+8QWUHeuC%Larry.Finger@lwfinger.net>
References: <46dd7ca4.8UjuObD+8QWUHeuC%Larry.Finger@lwfinger.net>
Message-ID: <200709041758.53741.mb@bu3sch.de>

On Tuesday 04 September 2007, Larry Finger wrote:
> A crash upon booting that is caused by bcm43xx has been reported [1] and
> found to be due to a work queue being reinitialized while work on that
> queue is still pending. This fix modifies the shutdown of work queues and
> prevents periodic work from being requeued during shutdown. With this patch,
> no more crashes on reboot were observed by the original reporter. I do not
> get that particular failure on my system; however, when running a large
> number of ifdown/ifup sequences, my system would occasionally hang with the
> 'caps lock' light blinking at roughly a 1 Hz rate. In addition, there were
> infrequent failures in the firmware that resulted in 'IRQ READY TIMEOUT'
> errors. With this patch, no more of the first type of failure occur, and
> incidence of the second type is greatly reduced.
> 
> [1] http://bugzilla.kernel.org/show_bug.cgi?id=8937
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> Michael,
> 
> The version I sent as 'RFC V2' had even more problems than the one you noted
> as it suffered from the total crash with the blinking caps lock light. This
> patch is a lot more solid.
> 
> Larry
> 
> 
>  drivers/net/wireless/bcm43xx/bcm43xx_main.c  |   28 +++++++++++++++++++--------
>  drivers/net/wireless/bcm43xx/bcm43xx_main.h  |    2 -
>  drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c |    3 +-
>  3 files changed, 23 insertions(+), 10 deletions(-)
> 
> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> ===================================================================
> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> @@ -3197,6 +3197,9 @@ static void bcm43xx_periodic_work_handle
>  	unsigned long orig_trans_start = 0;
>  
>  	mutex_lock(&bcm->mutex);
> +	/* keep from doing and rearming periodic work if shutting down */
> +	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
> +		goto unlock_mutex;
>  	if (unlikely(bcm->periodic_state % 60 == 0)) {
>  		/* Periodic work will take a long time, so we want it to
>  		 * be preemtible.
> @@ -3242,14 +3245,10 @@ static void bcm43xx_periodic_work_handle
>  	mmiowb();
>  	bcm->periodic_state++;
>  	spin_unlock_irqrestore(&bcm->irq_lock, flags);
> +unlock_mutex:
>  	mutex_unlock(&bcm->mutex);
>  }
>  
> -void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
> -{
> -	cancel_rearming_delayed_work(&bcm->periodic_work);
> -}
> -
>  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
>  {
>  	struct delayed_work *work = &bcm->periodic_work;
> @@ -3299,6 +3298,14 @@ static int bcm43xx_rng_init(struct bcm43
>  	return err;
>  }
>  
> +void bcm43xx_cancel_work(struct bcm43xx_private *bcm)
> +{
> +	/* The system must be unlocked when this routine is entered.
> +	 * If not, the next 2 steps may deadlock */
> +	cancel_work_sync(&bcm->restart_work);
> +	cancel_delayed_work_sync(&bcm->periodic_work);
> +}
> +
>  static int bcm43xx_shutdown_all_wireless_cores(struct bcm43xx_private *bcm)
>  {
>  	int ret = 0;
> @@ -3335,7 +3342,12 @@ static void bcm43xx_free_board(struct bc
>  {
>  	bcm43xx_rng_exit(bcm);
>  	bcm43xx_sysfs_unregister(bcm);
> -	bcm43xx_periodic_tasks_delete(bcm);
> +
> +	mutex_lock(&(bcm)->mutex);
> +	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
> +	mutex_unlock(&(bcm)->mutex);
> +
> +	bcm43xx_cancel_work(bcm);
>  
>  	mutex_lock(&(bcm)->mutex);
>  	bcm43xx_shutdown_all_wireless_cores(bcm);
> @@ -4030,7 +4042,7 @@ static int bcm43xx_net_stop(struct net_d
>  	err = bcm43xx_disable_interrupts_sync(bcm);
>  	assert(!err);
>  	bcm43xx_free_board(bcm);
> -	flush_scheduled_work();
> +	bcm43xx_cancel_work(bcm);
>  
>  	return 0;
>  }
> @@ -4162,9 +4174,9 @@ static void bcm43xx_chip_reset(struct wo
>  	struct bcm43xx_phyinfo *phy;
>  	int err = -ENODEV;
>  
> +	bcm43xx_cancel_work(bcm);
>  	mutex_lock(&(bcm)->mutex);
>  	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
> -		bcm43xx_periodic_tasks_delete(bcm);
>  		phy = bcm43xx_current_phy(bcm);
>  		err = bcm43xx_select_wireless_core(bcm, phy->type);
>  		if (!err)
> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
> ===================================================================
> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
> @@ -122,7 +122,7 @@ void bcm43xx_wireless_core_reset(struct 
>  void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
>  void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
>  
> -void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
> +void bcm43xx_cancel_work(struct bcm43xx_private *bcm);
>  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
>  
>  void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> ===================================================================
> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> @@ -327,8 +327,9 @@ static ssize_t bcm43xx_attr_phymode_stor
>  		goto out;
>  	}
>  
> -	bcm43xx_periodic_tasks_delete(bcm);
> +	bcm43xx_cancel_work(bcm);
>  	mutex_lock(&(bcm)->mutex);
> +	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);

No, Don't change the status.

>  	err = bcm43xx_select_wireless_core(bcm, phytype);
>  	if (!err)
>  		bcm43xx_periodic_tasks_setup(bcm);
> 
> 




From larry.finger at lwfinger.net  Tue Sep  4 17:59:54 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Sep 2007 10:59:54 -0500
Subject: mostly reverse engineered r4 microcode
In-Reply-To: <1188920642.9942.44.camel@johannes.berg>
References: <1188909519.9942.9.camel@johannes.berg>	
	<46DD7B14.1080806@lwfinger.net>
	<1188920642.9942.44.camel@johannes.berg>
Message-ID: <46DD80FA.2010907@lwfinger.net>

Johannes Berg wrote:
> On Tue, 2007-09-04 at 10:34 -0500, Larry Finger wrote:
> 
>> I meant to comment on this in my first reply, but forgot. I have a spare BCM4306/2 PCMCIA card that 
>> is rev 4. It has been a little damaged - the LEDs no longer work, but the radio and antenna are 
>> fine. If you want, I could send it to you on a more or less permanent loan. The only reason I would 
>> ever want it back is if my other rev 4 card were to fail.
> 
> I used to have one in cardbus form factor too but lost it at some point
> (together with a bunch of other things :/ ). Not sure how much use it'll
> be though, I've got the instruction set covered and I don't think I want
> to write firmware for it.

If you change your mind, let me know.

Larry


From larry.finger at lwfinger.net  Tue Sep  4 18:33:09 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Sep 2007 11:33:09 -0500
Subject: RFC V3 bcm43xx: Fix potential race in shutdown of work queues
In-Reply-To: <200709041758.53741.mb@bu3sch.de>
References: <46dd7ca4.8UjuObD+8QWUHeuC%Larry.Finger@lwfinger.net>
	<200709041758.53741.mb@bu3sch.de>
Message-ID: <46DD88C5.5040007@lwfinger.net>

Michael Buesch wrote:
> On Tuesday 04 September 2007, Larry Finger wrote:
>> A crash upon booting that is caused by bcm43xx has been reported [1] and
>> found to be due to a work queue being reinitialized while work on that
>> queue is still pending. This fix modifies the shutdown of work queues and
>> prevents periodic work from being requeued during shutdown. With this patch,
>> no more crashes on reboot were observed by the original reporter. I do not
>> get that particular failure on my system; however, when running a large
>> number of ifdown/ifup sequences, my system would occasionally hang with the
>> 'caps lock' light blinking at roughly a 1 Hz rate. In addition, there were
>> infrequent failures in the firmware that resulted in 'IRQ READY TIMEOUT'
>> errors. With this patch, no more of the first type of failure occur, and
>> incidence of the second type is greatly reduced.
>>
>> [1] http://bugzilla.kernel.org/show_bug.cgi?id=8937
>>
>> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
>> ---
>>
>> Michael,
>>
>> The version I sent as 'RFC V2' had even more problems than the one you noted
>> as it suffered from the total crash with the blinking caps lock light. This
>> patch is a lot more solid.
>>
>> Larry
>>
>>
>>  drivers/net/wireless/bcm43xx/bcm43xx_main.c  |   28 +++++++++++++++++++--------
>>  drivers/net/wireless/bcm43xx/bcm43xx_main.h  |    2 -
>>  drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c |    3 +-
>>  3 files changed, 23 insertions(+), 10 deletions(-)
>>
>> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
>> ===================================================================
>> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
>> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
>> @@ -3197,6 +3197,9 @@ static void bcm43xx_periodic_work_handle
>>  	unsigned long orig_trans_start = 0;
>>  
>>  	mutex_lock(&bcm->mutex);
>> +	/* keep from doing and rearming periodic work if shutting down */
>> +	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
>> +		goto unlock_mutex;
>>  	if (unlikely(bcm->periodic_state % 60 == 0)) {
>>  		/* Periodic work will take a long time, so we want it to
>>  		 * be preemtible.
>> @@ -3242,14 +3245,10 @@ static void bcm43xx_periodic_work_handle
>>  	mmiowb();
>>  	bcm->periodic_state++;
>>  	spin_unlock_irqrestore(&bcm->irq_lock, flags);
>> +unlock_mutex:
>>  	mutex_unlock(&bcm->mutex);
>>  }
>>  
>> -void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
>> -{
>> -	cancel_rearming_delayed_work(&bcm->periodic_work);
>> -}
>> -
>>  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
>>  {
>>  	struct delayed_work *work = &bcm->periodic_work;
>> @@ -3299,6 +3298,14 @@ static int bcm43xx_rng_init(struct bcm43
>>  	return err;
>>  }
>>  
>> +void bcm43xx_cancel_work(struct bcm43xx_private *bcm)
>> +{
>> +	/* The system must be unlocked when this routine is entered.
>> +	 * If not, the next 2 steps may deadlock */
>> +	cancel_work_sync(&bcm->restart_work);
>> +	cancel_delayed_work_sync(&bcm->periodic_work);
>> +}
>> +
>>  static int bcm43xx_shutdown_all_wireless_cores(struct bcm43xx_private *bcm)
>>  {
>>  	int ret = 0;
>> @@ -3335,7 +3342,12 @@ static void bcm43xx_free_board(struct bc
>>  {
>>  	bcm43xx_rng_exit(bcm);
>>  	bcm43xx_sysfs_unregister(bcm);
>> -	bcm43xx_periodic_tasks_delete(bcm);
>> +
>> +	mutex_lock(&(bcm)->mutex);
>> +	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
>> +	mutex_unlock(&(bcm)->mutex);
>> +
>> +	bcm43xx_cancel_work(bcm);
>>  
>>  	mutex_lock(&(bcm)->mutex);
>>  	bcm43xx_shutdown_all_wireless_cores(bcm);
>> @@ -4030,7 +4042,7 @@ static int bcm43xx_net_stop(struct net_d
>>  	err = bcm43xx_disable_interrupts_sync(bcm);
>>  	assert(!err);
>>  	bcm43xx_free_board(bcm);
>> -	flush_scheduled_work();
>> +	bcm43xx_cancel_work(bcm);
>>  
>>  	return 0;
>>  }
>> @@ -4162,9 +4174,9 @@ static void bcm43xx_chip_reset(struct wo
>>  	struct bcm43xx_phyinfo *phy;
>>  	int err = -ENODEV;
>>  
>> +	bcm43xx_cancel_work(bcm);
>>  	mutex_lock(&(bcm)->mutex);
>>  	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
>> -		bcm43xx_periodic_tasks_delete(bcm);
>>  		phy = bcm43xx_current_phy(bcm);
>>  		err = bcm43xx_select_wireless_core(bcm, phy->type);
>>  		if (!err)
>> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
>> ===================================================================
>> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
>> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
>> @@ -122,7 +122,7 @@ void bcm43xx_wireless_core_reset(struct 
>>  void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
>>  void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
>>  
>> -void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
>> +void bcm43xx_cancel_work(struct bcm43xx_private *bcm);
>>  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
>>  
>>  void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
>> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
>> ===================================================================
>> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
>> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
>> @@ -327,8 +327,9 @@ static ssize_t bcm43xx_attr_phymode_stor
>>  		goto out;
>>  	}
>>  
>> -	bcm43xx_periodic_tasks_delete(bcm);
>> +	bcm43xx_cancel_work(bcm);
>>  	mutex_lock(&(bcm)->mutex);
>> +	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
> 
> No, Don't change the status.
> 
I doubt that two many people are changing phy modes anyway. I certainly have not tested this code. 
As the BCM4306/2 devices are having a problem with OFDM rates, would writing a 'b' to this file 
limit those cards to CCCK rates? I'll have to try this one later.

Larry


From mb at bu3sch.de  Tue Sep  4 18:55:20 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Sep 2007 18:55:20 +0200
Subject: RFC V3 bcm43xx: Fix potential race in shutdown of work queues
In-Reply-To: <46DD88C5.5040007@lwfinger.net>
References: <46dd7ca4.8UjuObD+8QWUHeuC%Larry.Finger@lwfinger.net>
	<200709041758.53741.mb@bu3sch.de> <46DD88C5.5040007@lwfinger.net>
Message-ID: <200709041855.20283.mb@bu3sch.de>

On Tuesday 04 September 2007, Larry Finger wrote:
> >> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> >> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> >> @@ -327,8 +327,9 @@ static ssize_t bcm43xx_attr_phymode_stor
> >>  		goto out;
> >>  	}
> >>  
> >> -	bcm43xx_periodic_tasks_delete(bcm);
> >> +	bcm43xx_cancel_work(bcm);
> >>  	mutex_lock(&(bcm)->mutex);
> >> +	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
> > 
> > No, Don't change the status.
> > 
> I doubt that two many people are changing phy modes anyway. I certainly have not tested this code. 
> As the BCM4306/2 devices are having a problem with OFDM rates, would writing a 'b' to this file 
> limit those cards to CCCK rates? I'll have to try this one later.

No, this is basically dead code. So best don't touch it.


From larry.finger at lwfinger.net  Tue Sep  4 19:26:32 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Sep 2007 12:26:32 -0500
Subject: [PATCH] b43: Add debugfs file to dump microcode registers
In-Reply-To: <200709041516.01095.mb@bu3sch.de>
References: <200709041516.01095.mb@bu3sch.de>
Message-ID: <46DD9548.30201@lwfinger.net>

Michael Buesch wrote:
> This adds a debugfs file to dump all microcode registers.
> Note that the dumping is racy, as microcode continues to run
> while we loop over each register to dump it.
> 
> Cc: Johannes Berg <johannes at sipsolutions.net>
> Cc: Larry Finger <larry.finger at lwfinger.net>
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

The V3 specs for SHM do not have a routing value for the microcode registers. Are they accessible 
from the CPU side?

Larry



From mb at bu3sch.de  Tue Sep  4 19:28:38 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Sep 2007 19:28:38 +0200
Subject: [PATCH] b43: Add debugfs file to dump microcode registers
In-Reply-To: <46DD9548.30201@lwfinger.net>
References: <200709041516.01095.mb@bu3sch.de> <46DD9548.30201@lwfinger.net>
Message-ID: <200709041928.38216.mb@bu3sch.de>

On Tuesday 04 September 2007, Larry Finger wrote:
> Michael Buesch wrote:
> > This adds a debugfs file to dump all microcode registers.
> > Note that the dumping is racy, as microcode continues to run
> > while we loop over each register to dump it.
> > 
> > Cc: Johannes Berg <johannes at sipsolutions.net>
> > Cc: Larry Finger <larry.finger at lwfinger.net>
> > Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> The V3 specs for SHM do not have a routing value for the microcode registers. Are they accessible 
> from the CPU side?

It's the same routing there.


From Larry.Finger at lwfinger.net  Tue Sep  4 20:53:34 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Sep 2007 13:53:34 -0500
Subject: [PATCH] bcm43xx: Fix cancellation of work queues crashes
Message-ID: <46dda9ae.rVFA3HPOna+bGyWP%Larry.Finger@lwfinger.net>

A crash upon booting that is caused by bcm43xx has been reported [1] and
found to be due to a work queue being reinitialized while work on that
queue is still pending. This fix modifies the shutdown of work queues and
prevents periodic work from being requeued during shutdown. With this patch,
no more crashes on reboot were observed by the original reporter. I do not
get that particular failure on my system; however, when running a large
number of ifdown/ifup sequences, my system would kernel panic with the
'caps lock' light blinking at roughly a 1 Hz rate. In addition, there were
infrequent failures in the firmware that resulted in 'IRQ READY TIMEOUT'
errors. With this patch, no more of the first type of failure occur, and
incidence of the second type is greatly reduced.

[1] http://bugzilla.kernel.org/show_bug.cgi?id=8937

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This fix should be sent to 2.6.23. Once it it there, I'll send it on to
-stable.

Larry


 drivers/net/wireless/bcm43xx/bcm43xx_main.c  |   28 +++++++++++++++++++--------
 drivers/net/wireless/bcm43xx/bcm43xx_main.h  |    2 -
 drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c |    3 +-
 3 files changed, 23 insertions(+), 10 deletions(-)

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -3197,6 +3197,9 @@ static void bcm43xx_periodic_work_handle
 	unsigned long orig_trans_start = 0;
 
 	mutex_lock(&bcm->mutex);
+	/* keep from doing and rearming periodic work if shutting down */
+	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
+		goto unlock_mutex;
 	if (unlikely(bcm->periodic_state % 60 == 0)) {
 		/* Periodic work will take a long time, so we want it to
 		 * be preemtible.
@@ -3242,14 +3245,10 @@ static void bcm43xx_periodic_work_handle
 	mmiowb();
 	bcm->periodic_state++;
 	spin_unlock_irqrestore(&bcm->irq_lock, flags);
+unlock_mutex:
 	mutex_unlock(&bcm->mutex);
 }
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
-{
-	cancel_rearming_delayed_work(&bcm->periodic_work);
-}
-
 void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
 {
 	struct delayed_work *work = &bcm->periodic_work;
@@ -3299,6 +3298,14 @@ static int bcm43xx_rng_init(struct bcm43
 	return err;
 }
 
+void bcm43xx_cancel_work(struct bcm43xx_private *bcm)
+{
+	/* The system must be unlocked when this routine is entered.
+	 * If not, the next 2 steps may deadlock */
+	cancel_work_sync(&bcm->restart_work);
+	cancel_delayed_work_sync(&bcm->periodic_work);
+}
+
 static int bcm43xx_shutdown_all_wireless_cores(struct bcm43xx_private *bcm)
 {
 	int ret = 0;
@@ -3335,7 +3342,12 @@ static void bcm43xx_free_board(struct bc
 {
 	bcm43xx_rng_exit(bcm);
 	bcm43xx_sysfs_unregister(bcm);
-	bcm43xx_periodic_tasks_delete(bcm);
+
+	mutex_lock(&(bcm)->mutex);
+	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
+	mutex_unlock(&(bcm)->mutex);
+
+	bcm43xx_cancel_work(bcm);
 
 	mutex_lock(&(bcm)->mutex);
 	bcm43xx_shutdown_all_wireless_cores(bcm);
@@ -4030,7 +4042,7 @@ static int bcm43xx_net_stop(struct net_d
 	err = bcm43xx_disable_interrupts_sync(bcm);
 	assert(!err);
 	bcm43xx_free_board(bcm);
-	flush_scheduled_work();
+	bcm43xx_cancel_work(bcm);
 
 	return 0;
 }
@@ -4162,9 +4174,9 @@ static void bcm43xx_chip_reset(struct wo
 	struct bcm43xx_phyinfo *phy;
 	int err = -ENODEV;
 
+	bcm43xx_cancel_work(bcm);
 	mutex_lock(&(bcm)->mutex);
 	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm43xx_periodic_tasks_delete(bcm);
 		phy = bcm43xx_current_phy(bcm);
 		err = bcm43xx_select_wireless_core(bcm, phy->type);
 		if (!err)
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
@@ -122,7 +122,7 @@ void bcm43xx_wireless_core_reset(struct 
 void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
 void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
+void bcm43xx_cancel_work(struct bcm43xx_private *bcm);
 void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
 
 void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
@@ -327,8 +327,9 @@ static ssize_t bcm43xx_attr_phymode_stor
 		goto out;
 	}
 
-	bcm43xx_periodic_tasks_delete(bcm);
+	bcm43xx_cancel_work(bcm);
 	mutex_lock(&(bcm)->mutex);
+	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
 	err = bcm43xx_select_wireless_core(bcm, phytype);
 	if (!err)
 		bcm43xx_periodic_tasks_setup(bcm);


From mb at bu3sch.de  Tue Sep  4 20:59:29 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Sep 2007 20:59:29 +0200
Subject: [PATCH] bcm43xx: Fix cancellation of work queues crashes
In-Reply-To: <46dda9ae.rVFA3HPOna+bGyWP%Larry.Finger@lwfinger.net>
References: <46dda9ae.rVFA3HPOna+bGyWP%Larry.Finger@lwfinger.net>
Message-ID: <200709042059.29433.mb@bu3sch.de>

On Tuesday 04 September 2007, Larry Finger wrote:
> A crash upon booting that is caused by bcm43xx has been reported [1] and
> found to be due to a work queue being reinitialized while work on that
> queue is still pending. This fix modifies the shutdown of work queues and
> prevents periodic work from being requeued during shutdown. With this patch,
> no more crashes on reboot were observed by the original reporter. I do not
> get that particular failure on my system; however, when running a large
> number of ifdown/ifup sequences, my system would kernel panic with the
> 'caps lock' light blinking at roughly a 1 Hz rate. In addition, there were
> infrequent failures in the firmware that resulted in 'IRQ READY TIMEOUT'
> errors. With this patch, no more of the first type of failure occur, and
> incidence of the second type is greatly reduced.
> 
> [1] http://bugzilla.kernel.org/show_bug.cgi?id=8937
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John,
> 
> This fix should be sent to 2.6.23. Once it it there, I'll send it on to
> -stable.
> 
> Larry
> 
> 
>  drivers/net/wireless/bcm43xx/bcm43xx_main.c  |   28 +++++++++++++++++++--------
>  drivers/net/wireless/bcm43xx/bcm43xx_main.h  |    2 -
>  drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c |    3 +-
>  3 files changed, 23 insertions(+), 10 deletions(-)
> 
> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> ===================================================================
> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
> @@ -3197,6 +3197,9 @@ static void bcm43xx_periodic_work_handle
>  	unsigned long orig_trans_start = 0;
>  
>  	mutex_lock(&bcm->mutex);
> +	/* keep from doing and rearming periodic work if shutting down */
> +	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
> +		goto unlock_mutex;
>  	if (unlikely(bcm->periodic_state % 60 == 0)) {
>  		/* Periodic work will take a long time, so we want it to
>  		 * be preemtible.
> @@ -3242,14 +3245,10 @@ static void bcm43xx_periodic_work_handle
>  	mmiowb();
>  	bcm->periodic_state++;
>  	spin_unlock_irqrestore(&bcm->irq_lock, flags);
> +unlock_mutex:
>  	mutex_unlock(&bcm->mutex);
>  }
>  
> -void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
> -{
> -	cancel_rearming_delayed_work(&bcm->periodic_work);
> -}
> -
>  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
>  {
>  	struct delayed_work *work = &bcm->periodic_work;
> @@ -3299,6 +3298,14 @@ static int bcm43xx_rng_init(struct bcm43
>  	return err;
>  }
>  
> +void bcm43xx_cancel_work(struct bcm43xx_private *bcm)
> +{
> +	/* The system must be unlocked when this routine is entered.
> +	 * If not, the next 2 steps may deadlock */
> +	cancel_work_sync(&bcm->restart_work);
> +	cancel_delayed_work_sync(&bcm->periodic_work);
> +}
> +
>  static int bcm43xx_shutdown_all_wireless_cores(struct bcm43xx_private *bcm)
>  {
>  	int ret = 0;
> @@ -3335,7 +3342,12 @@ static void bcm43xx_free_board(struct bc
>  {
>  	bcm43xx_rng_exit(bcm);
>  	bcm43xx_sysfs_unregister(bcm);
> -	bcm43xx_periodic_tasks_delete(bcm);
> +
> +	mutex_lock(&(bcm)->mutex);
> +	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
> +	mutex_unlock(&(bcm)->mutex);
> +
> +	bcm43xx_cancel_work(bcm);
>  
>  	mutex_lock(&(bcm)->mutex);
>  	bcm43xx_shutdown_all_wireless_cores(bcm);
> @@ -4030,7 +4042,7 @@ static int bcm43xx_net_stop(struct net_d
>  	err = bcm43xx_disable_interrupts_sync(bcm);
>  	assert(!err);
>  	bcm43xx_free_board(bcm);
> -	flush_scheduled_work();
> +	bcm43xx_cancel_work(bcm);
>  
>  	return 0;
>  }
> @@ -4162,9 +4174,9 @@ static void bcm43xx_chip_reset(struct wo
>  	struct bcm43xx_phyinfo *phy;
>  	int err = -ENODEV;
>  
> +	bcm43xx_cancel_work(bcm);
>  	mutex_lock(&(bcm)->mutex);
>  	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
> -		bcm43xx_periodic_tasks_delete(bcm);
>  		phy = bcm43xx_current_phy(bcm);
>  		err = bcm43xx_select_wireless_core(bcm, phy->type);
>  		if (!err)
> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
> ===================================================================
> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
> @@ -122,7 +122,7 @@ void bcm43xx_wireless_core_reset(struct 
>  void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
>  void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
>  
> -void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
> +void bcm43xx_cancel_work(struct bcm43xx_private *bcm);
>  void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
>  
>  void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
> Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> ===================================================================
> --- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> +++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
> @@ -327,8 +327,9 @@ static ssize_t bcm43xx_attr_phymode_stor
>  		goto out;
>  	}
>  
> -	bcm43xx_periodic_tasks_delete(bcm);
> +	bcm43xx_cancel_work(bcm);
>  	mutex_lock(&(bcm)->mutex);
> +	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);

Don't change the status here. That is _wrong_.
The rest of the patch is OK.

>  	err = bcm43xx_select_wireless_core(bcm, phytype);
>  	if (!err)
>  		bcm43xx_periodic_tasks_setup(bcm);




From Larry.Finger at lwfinger.net  Tue Sep  4 21:14:20 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Sep 2007 14:14:20 -0500
Subject: [PATCH V2] bcm43xx: Fix cancellation of work queue crashes
Message-ID: <46ddae8c.UPc5+Azm3rCZdJxZ%Larry.Finger@lwfinger.net>

A crash upon booting that is caused by bcm43xx has been reported [1] and
found to be due to a work queue being reinitialized while work on that
queue is still pending. This fix modifies the shutdown of work queues and
prevents periodic work from being requeued during shutdown. With this patch,
no more crashes on reboot were observed by the original reporter. I do not
get that particular failure on my system; however, when running a large
number of ifdown/ifup sequences, my system would kernel panic with the
'caps lock' light blinking at roughly a 1 Hz rate. In addition, there were
infrequent failures in the firmware that resulted in 'IRQ READY TIMEOUT'
errors. With this patch, no more of the first type of failure occur, and
incidence of the second type is greatly reduced.

[1] http://bugzilla.kernel.org/show_bug.cgi?id=8937

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

Sorry, I forgot to refresh the patch before sending.

This fix should be sent to 2.6.23. Once it it there, I'll send it on to
-stable.

Larry


 drivers/net/wireless/bcm43xx/bcm43xx_main.c  |   28 +++++++++++++++++++--------
 drivers/net/wireless/bcm43xx/bcm43xx_main.h  |    2 -
 drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c |    2 +-
 3 files changed, 22 insertions(+), 10 deletions(-)

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -3197,6 +3197,9 @@ static void bcm43xx_periodic_work_handle
 	unsigned long orig_trans_start = 0;
 
 	mutex_lock(&bcm->mutex);
+	/* keep from doing and rearming periodic work if shutting down */
+	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
+		goto unlock_mutex;
 	if (unlikely(bcm->periodic_state % 60 == 0)) {
 		/* Periodic work will take a long time, so we want it to
 		 * be preemtible.
@@ -3242,14 +3245,10 @@ static void bcm43xx_periodic_work_handle
 	mmiowb();
 	bcm->periodic_state++;
 	spin_unlock_irqrestore(&bcm->irq_lock, flags);
+unlock_mutex:
 	mutex_unlock(&bcm->mutex);
 }
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm)
-{
-	cancel_rearming_delayed_work(&bcm->periodic_work);
-}
-
 void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
 {
 	struct delayed_work *work = &bcm->periodic_work;
@@ -3299,6 +3298,14 @@ static int bcm43xx_rng_init(struct bcm43
 	return err;
 }
 
+void bcm43xx_cancel_work(struct bcm43xx_private *bcm)
+{
+	/* The system must be unlocked when this routine is entered.
+	 * If not, the next 2 steps may deadlock */
+	cancel_work_sync(&bcm->restart_work);
+	cancel_delayed_work_sync(&bcm->periodic_work);
+}
+
 static int bcm43xx_shutdown_all_wireless_cores(struct bcm43xx_private *bcm)
 {
 	int ret = 0;
@@ -3335,7 +3342,12 @@ static void bcm43xx_free_board(struct bc
 {
 	bcm43xx_rng_exit(bcm);
 	bcm43xx_sysfs_unregister(bcm);
-	bcm43xx_periodic_tasks_delete(bcm);
+
+	mutex_lock(&(bcm)->mutex);
+	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
+	mutex_unlock(&(bcm)->mutex);
+
+	bcm43xx_cancel_work(bcm);
 
 	mutex_lock(&(bcm)->mutex);
 	bcm43xx_shutdown_all_wireless_cores(bcm);
@@ -4030,7 +4042,7 @@ static int bcm43xx_net_stop(struct net_d
 	err = bcm43xx_disable_interrupts_sync(bcm);
 	assert(!err);
 	bcm43xx_free_board(bcm);
-	flush_scheduled_work();
+	bcm43xx_cancel_work(bcm);
 
 	return 0;
 }
@@ -4162,9 +4174,9 @@ static void bcm43xx_chip_reset(struct wo
 	struct bcm43xx_phyinfo *phy;
 	int err = -ENODEV;
 
+	bcm43xx_cancel_work(bcm);
 	mutex_lock(&(bcm)->mutex);
 	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm43xx_periodic_tasks_delete(bcm);
 		phy = bcm43xx_current_phy(bcm);
 		err = bcm43xx_select_wireless_core(bcm, phy->type);
 		if (!err)
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
@@ -122,7 +122,7 @@ void bcm43xx_wireless_core_reset(struct 
 void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
 void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
 
-void bcm43xx_periodic_tasks_delete(struct bcm43xx_private *bcm);
+void bcm43xx_cancel_work(struct bcm43xx_private *bcm);
 void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
 
 void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
@@ -327,7 +327,7 @@ static ssize_t bcm43xx_attr_phymode_stor
 		goto out;
 	}
 
-	bcm43xx_periodic_tasks_delete(bcm);
+	bcm43xx_cancel_work(bcm);
 	mutex_lock(&(bcm)->mutex);
 	err = bcm43xx_select_wireless_core(bcm, phytype);
 	if (!err)


From mb at bu3sch.de  Tue Sep  4 21:17:49 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 4 Sep 2007 21:17:49 +0200
Subject: [PATCH V2] bcm43xx: Fix cancellation of work queue crashes
In-Reply-To: <46ddae8c.UPc5+Azm3rCZdJxZ%Larry.Finger@lwfinger.net>
References: <46ddae8c.UPc5+Azm3rCZdJxZ%Larry.Finger@lwfinger.net>
Message-ID: <200709042117.50006.mb@bu3sch.de>

On Tuesday 04 September 2007, Larry Finger wrote:
> A crash upon booting that is caused by bcm43xx has been reported [1] and
> found to be due to a work queue being reinitialized while work on that
> queue is still pending. This fix modifies the shutdown of work queues and
> prevents periodic work from being requeued during shutdown. With this patch,
> no more crashes on reboot were observed by the original reporter. I do not
> get that particular failure on my system; however, when running a large
> number of ifdown/ifup sequences, my system would kernel panic with the
> 'caps lock' light blinking at roughly a 1 Hz rate. In addition, there were
> infrequent failures in the firmware that resulted in 'IRQ READY TIMEOUT'
> errors. With this patch, no more of the first type of failure occur, and
> incidence of the second type is greatly reduced.
> 
> [1] http://bugzilla.kernel.org/show_bug.cgi?id=8937
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>

This version of the patch is
Acked-by: Michael Buesch <mb at bu3sch.de>


From celejar at gmail.com  Tue Sep  4 21:52:08 2007
From: celejar at gmail.com (Celejar)
Date: Tue, 4 Sep 2007 15:52:08 -0400
Subject: Screen flicker
Message-ID: <20070904155208.af073560.celejar@gmail.com>

Hi,

I use bcm43xx (Debian Sid 2.6.22) with my laptop's (Acer Aspire
3690-2672) 4318.

'lspci -vn':

> 06:02.0 0280: 14e4:4318 (rev 02)
>         Subsystem: 1468:0312
>         Flags: bus master, fast devsel, latency 64, IRQ 10
>         Memory at d0002000 (32-bit, non-prefetchable) [size=8K]

It works fairly well, but the screen sometimes flickers rapidly
(perhaps dozens of time per second) for several seconds at a time.  Is
this a known bug?  Anything I should try?  I do not see this with
ndiswrapper.  Thanks for your work on the driver

Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator



From larry.finger at lwfinger.net  Tue Sep  4 22:05:48 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Sep 2007 15:05:48 -0500
Subject: [PATCH] b43: Add debugfs file to dump SHM
In-Reply-To: <200709041517.28751.mb@bu3sch.de>
References: <200709041517.28751.mb@bu3sch.de>
Message-ID: <46DDBA9C.7020006@lwfinger.net>

Michael Buesch wrote:
> This adds a file to dump the SHM.
> Note that SHM dumping is racy, as the microcode continues to run
> while we dump the SHM.

Why is this memory dumped in binary? Wouldn't hex be better?

Larry



From larry.finger at lwfinger.net  Tue Sep  4 22:13:29 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Sep 2007 15:13:29 -0500
Subject: Screen flicker
In-Reply-To: <20070904155208.af073560.celejar@gmail.com>
References: <20070904155208.af073560.celejar@gmail.com>
Message-ID: <46DDBC69.9020708@lwfinger.net>

Celejar wrote:
> Hi,
> 
> I use bcm43xx (Debian Sid 2.6.22) with my laptop's (Acer Aspire
> 3690-2672) 4318.
> 
> 'lspci -vn':
> 
>> 06:02.0 0280: 14e4:4318 (rev 02)
>>         Subsystem: 1468:0312
>>         Flags: bus master, fast devsel, latency 64, IRQ 10
>>         Memory at d0002000 (32-bit, non-prefetchable) [size=8K]
> 
> It works fairly well, but the screen sometimes flickers rapidly
> (perhaps dozens of time per second) for several seconds at a time.  Is
> this a known bug?  Anything I should try?  I do not see this with
> ndiswrapper.  Thanks for your work on the driver

This problem has not previously been reported. Please sent the output of a 'cat /proc/interrupts' 
command and the full output from 'lspci -v'. The only idea that comes to mind is some sort of 
interference through a shared interrupt.

Anyone else have any ideas?

Larry


From celejar at gmail.com  Tue Sep  4 22:22:35 2007
From: celejar at gmail.com (Celejar)
Date: Tue, 4 Sep 2007 16:22:35 -0400
Subject: Screen flicker
In-Reply-To: <46DDBC69.9020708@lwfinger.net>
References: <20070904155208.af073560.celejar@gmail.com>
	<46DDBC69.9020708@lwfinger.net>
Message-ID: <20070904162235.0f6383a3.celejar@gmail.com>

On Tue, 04 Sep 2007 15:13:29 -0500
Larry Finger <larry.finger at lwfinger.net> wrote:

> Celejar wrote:
> > Hi,
> > 
> > I use bcm43xx (Debian Sid 2.6.22) with my laptop's (Acer Aspire
> > 3690-2672) 4318.
> > 
> > 'lspci -vn':
> > 
> >> 06:02.0 0280: 14e4:4318 (rev 02)
> >>         Subsystem: 1468:0312
> >>         Flags: bus master, fast devsel, latency 64, IRQ 10
> >>         Memory at d0002000 (32-bit, non-prefetchable) [size=8K]
> > 
> > It works fairly well, but the screen sometimes flickers rapidly
> > (perhaps dozens of time per second) for several seconds at a time.  Is
> > this a known bug?  Anything I should try?  I do not see this with
> > ndiswrapper.  Thanks for your work on the driver
> 
> This problem has not previously been reported. Please sent the output of a 'cat /proc/interrupts' 
> command and the full output from 'lspci -v'. The only idea that comes to mind is some sort of 
> interference through a shared interrupt.
> 
> Anyone else have any ideas?
> 
> Larry

Thanks for the quick reply.

cat /proc/interrupts

>            CPU0       
>   0:    4823605    XT-PIC-XT        timer
>   1:       7327    XT-PIC-XT        i8042
>   2:          0    XT-PIC-XT        cascade
>   5:          0    XT-PIC-XT        uhci_hcd:usb1, ehci_hcd:usb5
>   6:          1    XT-PIC-XT        uhci_hcd:usb4, yenta, i915 at pci:0000:00:02.0
>   8:          0    XT-PIC-XT        rtc
>   9:     810944    XT-PIC-XT        acpi
>  10:     192422    XT-PIC-XT        uhci_hcd:usb3, HDA Intel, bcm43xx
>  11:          0    XT-PIC-XT        uhci_hcd:usb2, sdhci:slot0
>  12:     101670    XT-PIC-XT        i8042
>  14:      67460    XT-PIC-XT        ide0
> NMI:          0 
> ERR:          1

sudo lspci -v

> 00:00.0 Host bridge: Intel Corporation Mobile 945GM/PM/GMS/940GML and 945GT Express Memory Controller Hub (rev 03)
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, fast devsel, latency 0
>         Capabilities: [e0] Vendor Specific Information
> 
> 00:02.0 VGA compatible controller: Intel Corporation Mobile 945GM/GMS/940GML Express Integrated Graphics Controller (rev 03) (prog-if 00 [VGA])
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, fast devsel, latency 0, IRQ 6
>         Memory at d0100000 (32-bit, non-prefetchable) [size=512K]
>         I/O ports at 1800 [size=8]
>         Memory at c0000000 (32-bit, prefetchable) [size=256M]
>         Memory at d0200000 (32-bit, non-prefetchable) [size=256K]
>         Capabilities: [90] Message Signalled Interrupts: Mask- 64bit- Queue=0/0 Enable-
>         Capabilities: [d0] Power Management version 2
> 
> 00:02.1 Display controller: Intel Corporation Mobile 945GM/GMS/940GML Express Integrated Graphics Controller (rev 03)
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, fast devsel, latency 0
>         Memory at d0180000 (32-bit, non-prefetchable) [size=512K]
>         Capabilities: [d0] Power Management version 2
> 
> 00:1b.0 Audio device: Intel Corporation 82801G (ICH7 Family) High Definition Audio Controller (rev 02)
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, fast devsel, latency 0, IRQ 10
>         Memory at d0240000 (64-bit, non-prefetchable) [size=16K]
>         Capabilities: [50] Power Management version 2
>         Capabilities: [60] Message Signalled Interrupts: Mask- 64bit+ Queue=0/0 Enable-
>         Capabilities: [70] Express Unknown type IRQ 0
>         Capabilities: [100] Virtual Channel
>         Capabilities: [130] Unknown (5)
> 
> 00:1c.0 PCI bridge: Intel Corporation 82801G (ICH7 Family) PCI Express Port 1 (rev 02) (prog-if 00 [Normal decode])
>         Flags: bus master, fast devsel, latency 0
>         Bus: primary=00, secondary=02, subordinate=02, sec-latency=0
>         Capabilities: [40] Express Root Port (Slot+) IRQ 0
>         Capabilities: [80] Message Signalled Interrupts: Mask- 64bit- Queue=0/0 Enable-
>         Capabilities: [90] Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Capabilities: [a0] Power Management version 2
>         Capabilities: [100] Virtual Channel
>         Capabilities: [180] Unknown (5)
> 
> 00:1c.1 PCI bridge: Intel Corporation 82801G (ICH7 Family) PCI Express Port 2 (rev 02) (prog-if 00 [Normal decode])
>         Flags: bus master, fast devsel, latency 0
>         Bus: primary=00, secondary=03, subordinate=03, sec-latency=0
>         Capabilities: [40] Express Root Port (Slot+) IRQ 0
>         Capabilities: [80] Message Signalled Interrupts: Mask- 64bit- Queue=0/0 Enable-
>         Capabilities: [90] Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Capabilities: [a0] Power Management version 2
>         Capabilities: [100] Virtual Channel
>         Capabilities: [180] Unknown (5)
> 
> 00:1c.2 PCI bridge: Intel Corporation 82801G (ICH7 Family) PCI Express Port 3 (rev 02) (prog-if 00 [Normal decode])
>         Flags: bus master, fast devsel, latency 0
>         Bus: primary=00, secondary=04, subordinate=04, sec-latency=0
>         Capabilities: [40] Express Root Port (Slot+) IRQ 0
>         Capabilities: [80] Message Signalled Interrupts: Mask- 64bit- Queue=0/0 Enable-
>         Capabilities: [90] Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Capabilities: [a0] Power Management version 2
>         Capabilities: [100] Virtual Channel
>         Capabilities: [180] Unknown (5)
> 
> 00:1c.3 PCI bridge: Intel Corporation 82801G (ICH7 Family) PCI Express Port 4 (rev 02) (prog-if 00 [Normal decode])
>         Flags: bus master, fast devsel, latency 0
>         Bus: primary=00, secondary=05, subordinate=05, sec-latency=0
>         Capabilities: [40] Express Root Port (Slot+) IRQ 0
>         Capabilities: [80] Message Signalled Interrupts: Mask- 64bit- Queue=0/0 Enable-
>         Capabilities: [90] Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Capabilities: [a0] Power Management version 2
>         Capabilities: [100] Virtual Channel
>         Capabilities: [180] Unknown (5)
> 
> 00:1d.0 USB Controller: Intel Corporation 82801G (ICH7 Family) USB UHCI #1 (rev 02) (prog-if 00 [UHCI])
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, medium devsel, latency 0, IRQ 5
>         I/O ports at 1820 [size=32]
> 
> 00:1d.1 USB Controller: Intel Corporation 82801G (ICH7 Family) USB UHCI #2 (rev 02) (prog-if 00 [UHCI])
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, medium devsel, latency 0, IRQ 11
>         I/O ports at 1840 [size=32]
> 
> 00:1d.2 USB Controller: Intel Corporation 82801G (ICH7 Family) USB UHCI #3 (rev 02) (prog-if 00 [UHCI])
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, medium devsel, latency 0, IRQ 10
>         I/O ports at 1860 [size=32]
> 
> 00:1d.3 USB Controller: Intel Corporation 82801G (ICH7 Family) USB UHCI #4 (rev 02) (prog-if 00 [UHCI])
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, medium devsel, latency 0, IRQ 6
>         I/O ports at 1880 [size=32]
> 
> 00:1d.7 USB Controller: Intel Corporation 82801G (ICH7 Family) USB2 EHCI Controller (rev 02) (prog-if 20 [EHCI])
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, medium devsel, latency 0, IRQ 5
>         Memory at d0444000 (32-bit, non-prefetchable) [size=1K]
>         Capabilities: [50] Power Management version 2
>         Capabilities: [58] Debug port
> 
> 00:1e.0 PCI bridge: Intel Corporation 82801 Mobile PCI Bridge (rev e2) (prog-if 01 [Subtractive decode])
>         Flags: bus master, fast devsel, latency 0
>         Bus: primary=00, secondary=06, subordinate=0a, sec-latency=32
>         I/O behind bridge: 00002000-00002fff
>         Memory behind bridge: d0000000-d00fffff
>         Prefetchable memory behind bridge: 0000000030000000-0000000033ffffff
>         Capabilities: [50] Subsystem: Acer Incorporated [ALI] Unknown device 0090
> 
> 00:1f.0 ISA bridge: Intel Corporation 82801GBM (ICH7-M) LPC Interface Bridge (rev 02)
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, medium devsel, latency 0
>         Capabilities: [e0] Vendor Specific Information
> 
> 00:1f.1 IDE interface: Intel Corporation 82801G (ICH7 Family) IDE Controller (rev 02) (prog-if 8a [Master SecP PriP])
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, medium devsel, latency 0, IRQ 11
>         I/O ports at 01f0 [size=8]
>         I/O ports at 03f4 [size=1]
>         I/O ports at 0170 [size=8]
>         I/O ports at 0374 [size=1]
>         I/O ports at 1810 [size=16]
> 
> 00:1f.3 SMBus: Intel Corporation 82801G (ICH7 Family) SMBus Controller (rev 02)
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: medium devsel, IRQ 11
>         I/O ports at 18a0 [size=32]
> 
> 06:01.0 Ethernet controller: Broadcom Corporation BCM4401-B0 100Base-TX (rev 02)
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, fast devsel, latency 64, IRQ 11
>         Memory at d0000000 (32-bit, non-prefetchable) [size=8K]
>         Capabilities: [40] Power Management version 2
> 
> 06:02.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 54g] 802.11g Wireless LAN Controller (rev 02)
>         Subsystem: AMBIT Microsystem Corp. TravelMate 2410
>         Flags: bus master, fast devsel, latency 64, IRQ 10
>         Memory at d0002000 (32-bit, non-prefetchable) [size=8K]
> 
> 06:04.0 CardBus bridge: ENE Technology Inc CB-712/4 Cardbus Controller (rev 10)
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, medium devsel, latency 168, IRQ 6
>         Memory at d0004000 (32-bit, non-prefetchable) [size=4K]
>         Bus: primary=06, secondary=07, subordinate=0a, sec-latency=176
>         Memory window 0: 30000000-33fff000 (prefetchable)
>         Memory window 1: 34000000-37fff000
>         I/O window 0: 00002000-000020ff
>         I/O window 1: 00002400-000024ff
>         16-bit legacy interface ports at 0001
> 
> 06:04.1 FLASH memory: ENE Technology Inc ENE PCI Memory Stick Card Reader Controller (rev 01)
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: medium devsel, IRQ 11
>         Memory at d0005000 (32-bit, non-prefetchable) [disabled] [size=128]
>         Capabilities: [80] Power Management version 2
> 
> 06:04.2 Generic system peripheral [0805]: ENE Technology Inc ENE PCI Secure Digital Card Reader Controller (rev 01) (prog-if 01)
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: bus master, medium devsel, latency 64, IRQ 11
>         Memory at d0005400 (32-bit, non-prefetchable) [size=256]
>         Capabilities: [80] Power Management version 2
> 
> 06:04.3 FLASH memory: ENE Technology Inc FLASH memory: ENE Technology Inc: (rev 01)
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: medium devsel, IRQ 11
>         Memory at d0005800 (32-bit, non-prefetchable) [disabled] [size=128]
>         Capabilities: [80] Power Management version 2
> 
> 06:04.4 FLASH memory: ENE Technology Inc Unknown device 0551 (rev 01)
>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>         Flags: medium devsel, IRQ 255
>         Memory at d0005100 (32-bit, non-prefetchable) [disabled] [size=256]
>         Capabilities: [80] Power Management version 2

Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator



From coomac at gmail.com  Tue Sep  4 22:35:36 2007
From: coomac at gmail.com (Nkoli)
Date: Tue, 4 Sep 2007 16:35:36 -0400
Subject: Screen flicker
In-Reply-To: <46DDBC69.9020708@lwfinger.net>
References: <20070904155208.af073560.celejar@gmail.com>
	<46DDBC69.9020708@lwfinger.net>
Message-ID: <e67787dd0709041335s70651867p4b75e6e1b6b4b459@mail.gmail.com>

On 9/4/07, Larry Finger <larry.finger at lwfinger.net> wrote:
>
> Celejar wrote:
> > Hi,
> >
> > I use bcm43xx (Debian Sid 2.6.22) with my laptop's (Acer Aspire
> > 3690-2672) 4318.
> >
> > 'lspci -vn':
> >
> >> 06:02.0 0280: 14e4:4318 (rev 02)
> >>         Subsystem: 1468:0312
> >>         Flags: bus master, fast devsel, latency 64, IRQ 10
> >>         Memory at d0002000 (32-bit, non-prefetchable) [size=8K]
> >
> > It works fairly well, but the screen sometimes flickers rapidly
> > (perhaps dozens of time per second) for several seconds at a time.  Is
> > this a known bug?  Anything I should try?  I do not see this with
> > ndiswrapper.  Thanks for your work on the driver
>
> This problem has not previously been reported. Please sent the output of a
> 'cat /proc/interrupts'
> command and the full output from 'lspci -v'. The only idea that comes to
> mind is some sort of
> interference through a shared interrupt.
>
> Anyone else have any ideas?
>
> Larry



I've seen this flicker a handful of times on my laptop (acer ferrari 4006).
I haven't experienced it in probably months now, but it seemed to happen
randomly. I always felt it had something to do with hardware rather than
anything on the OS side since it mostly showed up right after I turned on
the laptop, before the boot menu (grub in my case) came up. I've only seen
it once or twice when the laptop was on (coming out of standby after periods
of inactivity) and it never happened while the broadcom card was in use.
Just my experience.


Cheers.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070904/0535255a/attachment.html>

From larry.finger at lwfinger.net  Tue Sep  4 23:27:31 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 04 Sep 2007 16:27:31 -0500
Subject: Screen flicker
In-Reply-To: <20070904162235.0f6383a3.celejar@gmail.com>
References: <20070904155208.af073560.celejar@gmail.com>	<46DDBC69.9020708@lwfinger.net>
	<20070904162235.0f6383a3.celejar@gmail.com>
Message-ID: <46DDCDC3.7080409@lwfinger.net>

Celejar wrote:
> cat /proc/interrupts
> 
>>            CPU0       
>>   0:    4823605    XT-PIC-XT        timer
>>   1:       7327    XT-PIC-XT        i8042
>>   2:          0    XT-PIC-XT        cascade
>>   5:          0    XT-PIC-XT        uhci_hcd:usb1, ehci_hcd:usb5
>>   6:          1    XT-PIC-XT        uhci_hcd:usb4, yenta, i915 at pci:0000:00:02.0
>>   8:          0    XT-PIC-XT        rtc
>>   9:     810944    XT-PIC-XT        acpi
>>  10:     192422    XT-PIC-XT        uhci_hcd:usb3, HDA Intel, bcm43xx
>>  11:          0    XT-PIC-XT        uhci_hcd:usb2, sdhci:slot0
>>  12:     101670    XT-PIC-XT        i8042
>>  14:      67460    XT-PIC-XT        ide0
>> NMI:          0 
>> ERR:          1

>> 00:02.0 VGA compatible controller: Intel Corporation Mobile 945GM/GMS/940GML Express Integrated Graphics Controller (rev 03) (prog-if 00 [VGA])
>>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>>         Flags: bus master, fast devsel, latency 0, IRQ 6
>>         Memory at d0100000 (32-bit, non-prefetchable) [size=512K]
>>         I/O ports at 1800 [size=8]
>>         Memory at c0000000 (32-bit, prefetchable) [size=256M]
>>         Memory at d0200000 (32-bit, non-prefetchable) [size=256K]
>>         Capabilities: [90] Message Signalled Interrupts: Mask- 64bit- Queue=0/0 Enable-
>>         Capabilities: [d0] Power Management version 2

>> 06:02.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 54g] 802.11g Wireless LAN Controller (rev 02)
>>         Subsystem: AMBIT Microsystem Corp. TravelMate 2410
>>         Flags: bus master, fast devsel, latency 64, IRQ 10
>>         Memory at d0002000 (32-bit, non-prefetchable) [size=8K]
>>
>> 06:04.0 CardBus bridge: ENE Technology Inc CB-712/4 Cardbus Controller (rev 10)
>>         Subsystem: Acer Incorporated [ALI] Unknown device 0090
>>         Flags: bus master, medium devsel, latency 168, IRQ 6
>>         Memory at d0004000 (32-bit, non-prefetchable) [size=4K]
>>         Bus: primary=06, secondary=07, subordinate=0a, sec-latency=176
>>         Memory window 0: 30000000-33fff000 (prefetchable)
>>         Memory window 1: 34000000-37fff000
>>         I/O window 0: 00002000-000020ff
>>         I/O window 1: 00002400-000024ff
>>         16-bit legacy interface ports at 0001

One question I forgot to ask. Does this ever happen when the wireless interface is down, or only 
when it is up?

The BCM4318 and your graphics adapter do not share an IRQ, but the CardBus bridge (Yenta in the 
interrupts list) does. I don't know enough about CardBus programming to know if that is significant.

Larry


From johannes at sipsolutions.net  Wed Sep  5 13:20:04 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 05 Sep 2007 13:20:04 +0200
Subject: [PATCH] b43: Add debugfs file to dump SHM
In-Reply-To: <46DDBA9C.7020006@lwfinger.net>
References: <200709041517.28751.mb@bu3sch.de> <46DDBA9C.7020006@lwfinger.net>
Message-ID: <1188991204.9942.91.camel@johannes.berg>

On Tue, 2007-09-04 at 15:05 -0500, Larry Finger wrote:
> Michael Buesch wrote:
> > This adds a file to dump the SHM.
> > Note that SHM dumping is racy, as the microcode continues to run
> > while we dump the SHM.
> 
> Why is this memory dumped in binary? Wouldn't hex be better?

FWIW, I like it this way because then I can use dd to get out only parts
and run it through hexdump myself.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070905/fdefefae/attachment.pgp>

From celejar at gmail.com  Thu Sep  6 20:58:35 2007
From: celejar at gmail.com (Celejar)
Date: Thu, 6 Sep 2007 14:58:35 -0400
Subject: Screen flicker
In-Reply-To: <46DDCDC3.7080409@lwfinger.net>
References: <20070904155208.af073560.celejar@gmail.com>
	<46DDBC69.9020708@lwfinger.net>
	<20070904162235.0f6383a3.celejar@gmail.com>
	<46DDCDC3.7080409@lwfinger.net>
Message-ID: <20070906145835.5d4e7329.celejar@gmail.com>

On Tue, 04 Sep 2007 16:27:31 -0500
Larry Finger <larry.finger at lwfinger.net> wrote:

[snip]

> One question I forgot to ask. Does this ever happen when the wireless interface is down, or only 
> when it is up?

I don't think I've ever seen it with the interface down.  The interface
is usually down; I only bring it up to connect to a hotspot.
Incidentally, now that I think of it, I often run it in monitor mode,
sniffing with kismet, and I don't seem to recall ever seeing the
problem under those circumstances.

> The BCM4318 and your graphics adapter do not share an IRQ, but the CardBus bridge (Yenta in the 
> interrupts list) does. I don't know enough about CardBus programming to know if that is significant.

Incidentally, I forget to mention, in case it is significant, that
keypresses are ignored when in "flicker mode".  They are apparently not
even queued; they are just lost.

> Larry

Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator



From celejar at gmail.com  Thu Sep  6 21:01:10 2007
From: celejar at gmail.com (Celejar)
Date: Thu, 6 Sep 2007 15:01:10 -0400
Subject: Screen flicker
In-Reply-To: <e67787dd0709041335s70651867p4b75e6e1b6b4b459@mail.gmail.com>
References: <20070904155208.af073560.celejar@gmail.com>
	<46DDBC69.9020708@lwfinger.net>
	<e67787dd0709041335s70651867p4b75e6e1b6b4b459@mail.gmail.com>
Message-ID: <20070906150110.8c0874ec.celejar@gmail.com>

On Tue, 4 Sep 2007 16:35:36 -0400
Nkoli <coomac at gmail.com> wrote:

> On 9/4/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> >
> > Celejar wrote:
> > > Hi,
> > >
> > > I use bcm43xx (Debian Sid 2.6.22) with my laptop's (Acer Aspire
> > > 3690-2672) 4318.
> > >
> > > 'lspci -vn':
> > >
> > >> 06:02.0 0280: 14e4:4318 (rev 02)
> > >>         Subsystem: 1468:0312
> > >>         Flags: bus master, fast devsel, latency 64, IRQ 10
> > >>         Memory at d0002000 (32-bit, non-prefetchable) [size=8K]
> > >
> > > It works fairly well, but the screen sometimes flickers rapidly
> > > (perhaps dozens of time per second) for several seconds at a time.  Is
> > > this a known bug?  Anything I should try?  I do not see this with
> > > ndiswrapper.  Thanks for your work on the driver
> >
> > This problem has not previously been reported. Please sent the output of a
> > 'cat /proc/interrupts'
> > command and the full output from 'lspci -v'. The only idea that comes to
> > mind is some sort of
> > interference through a shared interrupt.
> >
> > Anyone else have any ideas?
> >
> > Larry
> 
> 
> 
> I've seen this flicker a handful of times on my laptop (acer ferrari 4006).
> I haven't experienced it in probably months now, but it seemed to happen
> randomly. I always felt it had something to do with hardware rather than
> anything on the OS side since it mostly showed up right after I turned on
> the laptop, before the boot menu (grub in my case) came up. I've only seen
> it once or twice when the laptop was on (coming out of standby after periods
> of inactivity) and it never happened while the broadcom card was in use.
> Just my experience.

My experience: I've *only* seen it with the Broadcom card in use (and
only with bcm43xx, not ndiswrapper), never at boot, and never with the
interface down, as per my response to Larry.

Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator



From coomac at gmail.com  Fri Sep  7 07:16:35 2007
From: coomac at gmail.com (Nkoli)
Date: Fri, 7 Sep 2007 01:16:35 -0400
Subject: Screen flicker
In-Reply-To: <20070906150110.8c0874ec.celejar@gmail.com>
References: <20070904155208.af073560.celejar@gmail.com>
	<46DDBC69.9020708@lwfinger.net>
	<e67787dd0709041335s70651867p4b75e6e1b6b4b459@mail.gmail.com>
	<20070906150110.8c0874ec.celejar@gmail.com>
Message-ID: <e67787dd0709062216i5599a940v8ea0ae64523d882a@mail.gmail.com>

On 9/6/07, Celejar <celejar at gmail.com> wrote:
>
>
> My experience: I've *only* seen it with the Broadcom card in use (and
> only with bcm43xx, not ndiswrapper), never at boot, and never with the
> interface down, as per my response to Larry.
>
> Celejar
> --
>
>
I did a quick google search for acer laptop flicker. It seems,
unfortunately, that flickering is all too common with some acer laptops, as
in here<http://forum.notebookreview.com/showthread.php?s=b22aa0202caf39b754ac5b91e2946f41&t=13038>and
here <http://www.howtofixcomputers.com/bb/ftopic206895.html>. It might be a
different issue in your case. I really wouldn't know. Too bad it's too
random to attempt a reliable reproduction with a different setup
(ndiswrapper, windows, etc).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070907/7265cbe1/attachment.html>

From achrisjo at yahoo.com  Fri Sep  7 14:46:42 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Fri, 7 Sep 2007 05:46:42 -0700 (PDT)
Subject: Any hope ?
Message-ID: <220241.22982.qm@web63712.mail.re1.yahoo.com>

hi all,

Can anyone tell me what chance there might be to get the wi-fi working under Linux for
the following hardware ? ( inserted it below )

I did read something about it on another site, while it wasn't for this particular hardware.

1. As a first step, I just would like to know what odds there may be, as I may not dive
into the spesifics right at the moment because of the following:

2. It has a dual AMD Turion, Microsof Vista premium. Installed Fedora7x86, but it reported
kernel panic, couldn't find the installed software.  I am a bit confused, as it did seem like
it did boot up the first time ? Then tried F7.9_x86, same result. Then F7_i386, with somewhat
the same results. Then tried Fedora core 6-x86_64.  It installed kernel-2.6.18-1.2798.fc6.x86_64,
but Software updated it to kernel-2.6.22.4-45.fc6.x86_64. So, the new kernel cause the problem.
This may seem to have been the case with Fedora 7 as well. The other funny thing with Fedora 7,
was in fact that it halted several times, but would continue booting after pushing power off a
couple of times. ( I haven't figured out what goes wrong, and will have to figure out this first )

3. HP spesifications says it has a Broadcom 4321AGN Wi-Fi Adapter (802.11 a/b/g/ draft-n) w/2
antennas ( guess one part may be blue-tooth ) Haven't found much info, but Broadcom does have
some different parts BC4321?? Else much of the chipset may seem to be nVidia. 
 
Any hope this may play under Linux ? Or should I trade for something else ?
( trouble is, where do you find anything that play Linux without a lot of headache ? )


//ARNE

--sorry about the length..

Compac Presario 6500
P/N: GP645EA

Btw: The HP spec seem to say that it is a Broadcom 4321 device,
not a 4310 as listed below.

//ARNE

And more, anyway here is what lspci -v reports:


00:00.0 RAM memory: nVidia Corporation Unknown device 0547 (rev a2)
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0
    Capabilities: [44] HyperTransport: Slave or Primary Interface
        Command: BaseUnitID=0 UnitCnt=15 MastHost- DefDir- DUL-
        Link Control 0: CFlE- CST- CFE- <LkFail- Init+ EOC- TXO- <CRCErr=0 IsocEn- LSEn+ ExtCTL- 64b-
        Link Config 0: MLWI=16bit DwFcIn- MLWO=16bit DwFcOut- LWI=16bit DwFcInEn- LWO=16bit DwFcOutEn-
        Link Control 1: CFlE- CST- CFE- <LkFail+ Init- EOC+ TXO+ <CRCErr=0 IsocEn- LSEn- ExtCTL- 64b-
        Link Config 1: MLWI=8bit DwFcIn- MLWO=8bit DwFcOut- LWI=8bit DwFcInEn- LWO=8bit DwFcOutEn-
        Revision ID: 1.03
        Link Frequency 0: 800MHz
        Link Error 0: <Prot- <Ovfl- <EOC- CTLTm-
        Link Frequency Capability 0: 200MHz+ 300MHz+ 400MHz+ 500MHz+ 600MHz+ 800MHz+ 1.0GHz+ 1.2GHz- 1.4GHz- 1.6GHz- Vend-
        Feature Capability: IsocFC+ LDTSTOP+ CRCTM- ECTLT- 64bA- UIDRD-
        Link Frequency 1: 200MHz
        Link Error 1: <Prot- <Ovfl- <EOC- CTLTm-
        Link Frequency Capability 1: 200MHz- 300MHz- 400MHz- 500MHz- 600MHz- 800MHz- 1.0GHz- 1.2GHz- 1.4GHz- 1.6GHz- Vend-
        Error Handling: PFlE+ OFlE+ PFE- OFE- EOCFE- RFE- CRCFE- SERRFE- CF- RE- PNFE- ONFE- EOCNFE- RNFE- CRCNFE- SERRNFE-
        Prefetchable memory behind bridge Upper: 00-00
        Bus Number: 00
    Capabilities: [dc] HyperTransport: MSI Mapping

00:01.0 ISA bridge: nVidia Corporation Unknown device 0548 (rev a2)
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O+ Mem+ BusMaster+ SpecCycle+ MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap- 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort+ >SERR- <PERR-
    Latency: 0

00:01.1 SMBus: nVidia Corporation Unknown device 0542 (rev a2)
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O+ Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Interrupt: pin A routed to IRQ 10
    Region 0: I/O ports at 3080 [size=64]
    Region 4: I/O ports at 3040 [size=64]
    Region 5: I/O ports at 3000 [size=64]
    Capabilities: [44] Power Management version 2
        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=0 PME-

00:01.2 RAM memory: nVidia Corporation Unknown device 0541 (rev a2)
    Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap- 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-

00:01.3 Co-processor: nVidia Corporation Unknown device 0543 (rev a2)
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap- 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0 (750ns min, 250ns max)
    Interrupt: pin B routed to IRQ 11
    Region 0: Memory at f6200000 (32-bit, non-prefetchable) [size=512K]

00:02.0 USB Controller: nVidia Corporation Unknown device 055e (rev a2) (prog-if 10 [OHCI])
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0 (750ns min, 250ns max)
    Interrupt: pin A routed to IRQ 16
    Region 0: Memory at f6486000 (32-bit, non-prefetchable) [size=4K]
    Capabilities: [44] Power Management version 2
        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=0 PME-

00:02.1 USB Controller: nVidia Corporation Unknown device 055f (rev a2) (prog-if 20 [EHCI])
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0 (750ns min, 250ns max)
    Interrupt: pin B routed to IRQ 17
    Region 0: Memory at f6489000 (32-bit, non-prefetchable) [size=256]
    Capabilities: [44] Debug port
    Capabilities: [80] Power Management version 2
        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=0 PME-

00:04.0 USB Controller: nVidia Corporation Unknown device 055e (rev a2) (prog-if 10 [OHCI])
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0 (750ns min, 250ns max)
    Interrupt: pin A routed to IRQ 16
    Region 0: Memory at f6487000 (32-bit, non-prefetchable) [size=4K]
    Capabilities: [44] Power Management version 2
        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=0 PME-

00:04.1 USB Controller: nVidia Corporation Unknown device 055f (rev a2) (prog-if 20 [EHCI])
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0 (750ns min, 250ns max)
    Interrupt: pin B routed to IRQ 17
    Region 0: Memory at f6489400 (32-bit, non-prefetchable) [size=256]
    Capabilities: [44] Debug port
    Capabilities: [80] Power Management version 2
        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=0 PME-

00:06.0 IDE interface: nVidia Corporation Unknown device 0560 (rev a1) (prog-if 8a [Master SecP PriP])
    Subsystem: Unknown device f03c:30cf
    Control: I/O+ Mem- BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0 (750ns min, 250ns max)
    Region 0: [virtual] Memory at 000001f0 (32-bit, non-prefetchable) [disabled] [size=8]
    Region 1: [virtual] Memory at 000003f0 (type 3, non-prefetchable) [disabled] [size=1]
    Region 2: [virtual] Memory at 00000170 (32-bit, non-prefetchable) [disabled] [size=8]
    Region 3: [virtual] Memory at 00000370 (type 3, non-prefetchable) [disabled] [size=1]
    Region 4: I/O ports at 30c0 [size=16]
    Capabilities: [44] Power Management version 2
        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)
        Status: D0 PME-Enable- DSel=0 DScale=0 PME-

00:07.0 Audio device: nVidia Corporation Unknown device 055c (rev a1)
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0 (500ns min, 1250ns max)
    Interrupt: pin A routed to IRQ 21
    Region 0: Memory at f6480000 (32-bit, non-prefetchable) [size=16K]
    Capabilities: [44] Power Management version 2
        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=0 PME-
    Capabilities: [50] Message Signalled Interrupts: Mask+ 64bit+ Queue=0/0 Enable-
        Address: 0000000000000000  Data: 0000
        Masking: 00000000  Pending: 00000000
    Capabilities: [6c] HyperTransport: MSI Mapping

00:08.0 PCI bridge: nVidia Corporation Unknown device 0561 (rev a2) (prog-if 01 [Subtractive decode])
    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0
    Bus: primary=00, secondary=02, subordinate=02, sec-latency=64
    I/O behind bridge: 0000f000-00000fff
    Memory behind bridge: f6100000-f61fffff
    Prefetchable memory behind bridge: fff00000-000fffff
    Secondary status: 66MHz- FastB2B+ ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort+ <SERR- <PERR-
    BridgeCtl: Parity- SERR- NoISA+ VGA- MAbort- >Reset- FastB2B-
    Capabilities: [b8] Subsystem: nVidia Corporation Unknown device cb84
    Capabilities: [8c] HyperTransport: MSI Mapping

00:09.0 IDE interface: nVidia Corporation Unknown device 0550 (rev a2) (prog-if 85 [Master SecO PriO])
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0 (750ns min, 250ns max)
    Interrupt: pin A routed to IRQ 18
    Region 0: I/O ports at 30f0 [size=8]
    Region 1: I/O ports at 30e4 [size=4]
    Region 2: I/O ports at 30e8 [size=8]
    Region 3: I/O ports at 30e0 [size=4]
    Region 4: I/O ports at 30d0 [size=16]
    Region 5: Memory at f6484000 (32-bit, non-prefetchable) [size=8K]
    Capabilities: [44] Power Management version 2
        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)
        Status: D0 PME-Enable- DSel=0 DScale=0 PME-
    Capabilities: [8c] #12 [0010]
    Capabilities: [b0] Message Signalled Interrupts: Mask- 64bit+ Queue=0/3 Enable-
        Address: 0000000000000000  Data: 0000
    Capabilities: [cc] HyperTransport: MSI Mapping

00:0a.0 Ethernet controller: nVidia Corporation Unknown device 054c (rev a2)
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0 (250ns min, 5000ns max)
    Interrupt: pin A routed to IRQ 19
    Region 0: Memory at f6488000 (32-bit, non-prefetchable) [size=4K]
    Region 1: I/O ports at 30f8 [size=8]
    Region 2: Memory at f6489c00 (32-bit, non-prefetchable) [size=256]
    Region 3: Memory at f6489800 (32-bit, non-prefetchable) [size=16]
    Capabilities: [44] Power Management version 2
        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable+ DSel=0 DScale=0 PME-
    Capabilities: [50] Message Signalled Interrupts: Mask+ 64bit+ Queue=0/3 Enable-
        Address: 0000000000000000  Data: 0000
        Masking: 00000000  Pending: 00000000
    Capabilities: [6c] HyperTransport: MSI Mapping

00:0c.0 PCI bridge: nVidia Corporation Unknown device 0563 (rev a2) (prog-if 00 [Normal decode])
    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0, Cache Line Size: 64 bytes
    Bus: primary=00, secondary=04, subordinate=05, sec-latency=0
    I/O behind bridge: 00004000-00004fff
    Memory behind bridge: f2000000-f3ffffff
    Prefetchable memory behind bridge: 00000000f0000000-00000000f1ffffff
    Secondary status: 66MHz- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- <SERR- <PERR-
    BridgeCtl: Parity- SERR- NoISA+ VGA- MAbort- >Reset- FastB2B-
    Capabilities: [40] Subsystem: nVidia Corporation Unknown device 0000
    Capabilities: [48] Power Management version 2
        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=0 PME-
    Capabilities: [50] Message Signalled Interrupts: Mask- 64bit+ Queue=0/1 Enable-
        Address: 0000000000000000  Data: 0000
    Capabilities: [60] HyperTransport: MSI Mapping
    Capabilities: [80] Express Root Port (Slot+) IRQ 0
        Device: Supported: MaxPayload 256 bytes, PhantFunc 0, ExtTag+
        Device: Latency L0s <64ns, L1 <1us
        Device: Errors: Correctable+ Non-Fatal+ Fatal+ Unsupported+
        Device: RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+
        Device: MaxPayload 128 bytes, MaxReadReq 512 bytes
        Link: Supported Speed 2.5Gb/s, Width x1, ASPM L0s L1, Port 1
        Link: Latency L0s <512ns, L1 <4us
        Link: ASPM Disabled RCB 64 bytes CommClk- ExtSynch-
        Link: Speed 2.5Gb/s, Width x1
        Slot: AtnBtn- PwrCtrl- MRL- AtnInd- PwrInd- HotPlug- Surpise-
        Slot: Number 2, PowerLimit 10.000000
        Slot: Enabled AtnBtn- PwrFlt- MRL- PresDet- CmdCplt- HPIrq+
        Slot: AttnInd Off, PwrInd On, Power-
        Root: Correctable- Non-Fatal- Fatal- PME-

00:0d.0 PCI bridge: nVidia Corporation Unknown device 0563 (rev a2) (prog-if 00 [Normal decode])
    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0, Cache Line Size: 64 bytes
    Bus: primary=00, secondary=03, subordinate=03, sec-latency=0
    I/O behind bridge: 0000f000-00000fff
    Memory behind bridge: f6000000-f60fffff
    Prefetchable memory behind bridge: 00000000fff00000-00000000000fffff
    Secondary status: 66MHz- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort+ <SERR- <PERR-
    BridgeCtl: Parity- SERR- NoISA+ VGA- MAbort- >Reset- FastB2B-
    Capabilities: [40] Subsystem: nVidia Corporation Unknown device 0000
    Capabilities: [48] Power Management version 2
        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=0 PME-
    Capabilities: [50] Message Signalled Interrupts: Mask- 64bit+ Queue=0/1 Enable-
        Address: 0000000000000000  Data: 0000
    Capabilities: [60] HyperTransport: MSI Mapping
    Capabilities: [80] Express Root Port (Slot+) IRQ 0
        Device: Supported: MaxPayload 256 bytes, PhantFunc 0, ExtTag+
        Device: Latency L0s <64ns, L1 <1us
        Device: Errors: Correctable+ Non-Fatal+ Fatal+ Unsupported+
        Device: RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+
        Device: MaxPayload 128 bytes, MaxReadReq 512 bytes
        Link: Supported Speed 2.5Gb/s, Width x1, ASPM L0s L1, Port 2
        Link: Latency L0s <512ns, L1 <4us
        Link: ASPM Disabled RCB 64 bytes CommClk+ ExtSynch-
        Link: Speed 2.5Gb/s, Width x1
        Slot: AtnBtn- PwrCtrl- MRL- AtnInd- PwrInd- HotPlug- Surpise-
        Slot: Number 3, PowerLimit 10.000000
        Slot: Enabled AtnBtn- PwrFlt- MRL- PresDet- CmdCplt- HPIrq+
        Slot: AttnInd Off, PwrInd On, Power-
        Root: Correctable- Non-Fatal- Fatal- PME-

00:12.0 VGA compatible controller: nVidia Corporation Unknown device 0531 (rev a2) (prog-if 00 [VGA])
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0
    Interrupt: pin A routed to IRQ 22
    Region 0: Memory at f5000000 (32-bit, non-prefetchable) [size=16M]
    Region 1: Memory at d0000000 (64-bit, prefetchable) [size=256M]
    Region 3: Memory at f4000000 (64-bit, non-prefetchable) [size=16M]
    [virtual] Expansion ROM at 88000000 [disabled] [size=128K]
    Capabilities: [48] Power Management version 2
        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)
        Status: D0 PME-Enable- DSel=0 DScale=0 PME-
    Capabilities: [50] Message Signalled Interrupts: Mask- 64bit+ Queue=0/0 Enable-
        Address: 0000000000000000  Data: 0000

00:18.0 Host bridge: Advanced Micro Devices [AMD] K8 [Athlon64/Opteron] HyperTransport Technology Configuration
    Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Capabilities: [80] HyperTransport: Host or Secondary Interface
        !!! Possibly incomplete decoding
        Command: WarmRst+ DblEnd-
        Link Control: CFlE- CST- CFE- <LkFail- Init+ EOC- TXO- <CRCErr=8
        Link Config: MLWI=16bit MLWO=16bit LWI=16bit LWO=16bit
        Revision ID: 1.02

00:18.1 Host bridge: Advanced Micro Devices [AMD] K8 [Athlon64/Opteron] Address Map
    Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-

00:18.2 Host bridge: Advanced Micro Devices [AMD] K8 [Athlon64/Opteron] DRAM Controller
    Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-

00:18.3 Host bridge: Advanced Micro Devices [AMD] K8 [Athlon64/Opteron] Miscellaneous Control
    Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Capabilities: [f0] #0f [0010]

02:05.0 FireWire (IEEE 1394): Ricoh Co Ltd R5C832 IEEE 1394 Controller (rev 05) (prog-if 10 [OHCI])
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 64 (500ns min, 1000ns max), Cache Line Size: 64 bytes
    Interrupt: pin A routed to IRQ 5
    Region 0: Memory at f6100000 (32-bit, non-prefetchable) [size=2K]
    Capabilities: [dc] Power Management version 2
        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=2 PME+

02:05.1 Generic system peripheral [0805]: Ricoh Co Ltd R5C822 SD/SDIO/MMC/MS/MSPro Host Adapter (rev 22)
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 64, Cache Line Size: 64 bytes
    Interrupt: pin B routed to IRQ 7
    Region 0: Memory at f6100800 (32-bit, non-prefetchable) [size=256]
    Capabilities: [80] Power Management version 2
        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=2 PME-

02:05.2 System peripheral: Ricoh Co Ltd Unknown device 0843 (rev 12)
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 64, Cache Line Size: 64 bytes
    Interrupt: pin B routed to IRQ 11
    Region 0: Memory at f6100c00 (32-bit, non-prefetchable) [size=256]
    Capabilities: [80] Power Management version 2
        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=2 PME-

02:05.3 System peripheral: Ricoh Co Ltd R5C592 Memory Stick Bus Host Adapter (rev 12)
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 64, Cache Line Size: 64 bytes
    Interrupt: pin B routed to IRQ 11
    Region 0: Memory at f6101000 (32-bit, non-prefetchable) [size=256]
    Capabilities: [80] Power Management version 2
        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=2 PME-

02:05.4 System peripheral: Ricoh Co Ltd xD-Picture Card Controller (rev 12)
    Subsystem: Hewlett-Packard Company Unknown device 30cf
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 64, Cache Line Size: 64 bytes
    Interrupt: pin B routed to IRQ 11
    Region 0: Memory at f6101400 (32-bit, non-prefetchable) [size=256]
    Capabilities: [80] Power Management version 2
        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+)
        Status: D0 PME-Enable- DSel=0 DScale=2 PME-

03:00.0 Network controller: Broadcom Corporation BCM4310 UART (rev 02)
    Subsystem: Hewlett-Packard Company Unknown device 1371
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
    Latency: 0, Cache Line Size: 64 bytes
    Interrupt: pin A routed to IRQ 20
    Region 0: Memory at f6000000 (64-bit, non-prefetchable) [size=16K]
    Capabilities: [40] Power Management version 3
        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)
        Status: D0 PME-Enable- DSel=0 DScale=2 PME-
    Capabilities: [58] Vendor Specific Information
    Capabilities: [e8] Message Signalled Interrupts: Mask- 64bit+ Queue=0/0 Enable-
        Address: 0000000000000000  Data: 0000
    Capabilities: [d0] Express Endpoint IRQ 0
        Device: Supported: MaxPayload 128 bytes, PhantFunc 0, ExtTag+
        Device: Latency L0s <4us, L1 unlimited
        Device: AtnBtn- AtnInd- PwrInd-
        Device: Errors: Correctable- Non-Fatal- Fatal- Unsupported-
        Device: RlxdOrd- ExtTag- PhantFunc- AuxPwr- NoSnoop-
        Device: MaxPayload 128 bytes, MaxReadReq 128 bytes
        Link: Supported Speed 2.5Gb/s, Width x1, ASPM L0s, Port 0
        Link: Latency L0s <4us, L1 <64us
        Link: ASPM Disabled RCB 64 bytes CommClk+ ExtSynch-
        Link: Speed 2.5Gb/s, Width x1

Devices in Windows Vista:
-------------------------
Name    [00000000] WAN Miniport (L2TP) Adapter Type    Not Available 
Name    [00000001] WAN Miniport (PPTP) 
Adapter Type    Wide Area Network (WAN)
Name    [00000002] WAN Miniport (PPPOE) 
Adapter Type    Wide Area Network (WAN)
Name    [00000003] WAN Miniport (IPv6) 
Adapter Type    Not Available 
Name    [00000004] NVIDIA nForce Networking Controller 
Adapter Type    Ethernet 802.3 
Name    [00000006] WAN Miniport (IP) 
Adapter Type    Not Available 
Name    [00000007] Broadcom 802.11a/b/g WLAN 
Adapter Type    Ethernet 802.3               Service Name    BCM43XX     
Name    [00000009] RAS Async Adapter 
Adapter Type    Not Available 
Name    [00000011] Bluetooth Device (Personal Area Network) 
Adapter Type    Not Available 
Name    [00000012] Microsoft Tun Miniport Adapter 
Adapter Type    Ethernet 802.3     
Name    [00000013] Microsoft ISATAP Adapter 
Adapter Type    Tunnel 
Name    HDAUDIO Soft Data Fax Modem with SmartCP 
PNP Device ID    HDAUDIO\FUNC_02&VEN_14F1&DEV_5045&SUBSYS_103C30CF&REV_1001\4&887B936&0&0002 
Name    NVIDIA MCP67M 
PNP Device ID    PCI\VEN_10DE&DEV_0531&SUBSYS_30CF103C&REV_A2\3&2411E6FE&0&90 
Adapter Type    GeForce 7150M / nForce 630M, NVIDIA compatible 
Adapter Description    NVIDIA MCP67M


       
---------------------------------
Choose the right car based on your needs.  Check out Yahoo! Autos new Car Finder tool.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070907/ccb0a705/attachment.html>

From gene.heskett at verizon.net  Fri Sep  7 15:46:32 2007
From: gene.heskett at verizon.net (Gene Heskett)
Date: Fri, 07 Sep 2007 09:46:32 -0400
Subject: Any hope ?
In-Reply-To: <220241.22982.qm@web63712.mail.re1.yahoo.com>
References: <220241.22982.qm@web63712.mail.re1.yahoo.com>
Message-ID: <200709070946.32435.gene.heskett@verizon.net>

On Friday 07 September 2007, Arne Chr. Jorgensen wrote:

Reply at bottom.

>hi all,
>
>Can anyone tell me what chance there might be to get the wi-fi working under
> Linux for the following hardware ? ( inserted it below )
>
>I did read something about it on another site, while it wasn't for this
> particular hardware.
>
>1. As a first step, I just would like to know what odds there may be, as I
> may not dive into the spesifics right at the moment because of the
> following:
>
>2. It has a dual AMD Turion, Microsof Vista premium. Installed Fedora7x86,
> but it reported kernel panic, couldn't find the installed software.  I am a
> bit confused, as it did seem like it did boot up the first time ? Then
> tried F7.9_x86, same result. Then F7_i386, with somewhat the same results.
> Then tried Fedora core 6-x86_64.  It installed
> kernel-2.6.18-1.2798.fc6.x86_64, but Software updated it to
> kernel-2.6.22.4-45.fc6.x86_64. So, the new kernel cause the problem. This
> may seem to have been the case with Fedora 7 as well. The other funny thing
> with Fedora 7, was in fact that it halted several times, but would continue
> booting after pushing power off a couple of times. ( I haven't figured out
> what goes wrong, and will have to figure out this first )
>
>3. HP spesifications says it has a Broadcom 4321AGN Wi-Fi Adapter (802.11
> a/b/g/ draft-n) w/2 antennas ( guess one part may be blue-tooth ) Haven't
> found much info, but Broadcom does have some different parts BC4321?? Else
> much of the chipset may seem to be nVidia.
>
>Any hope this may play under Linux ? Or should I trade for something else ?
>( trouble is, where do you find anything that play Linux without a lot of
> headache ? )
>
>
>//ARNE
>
>--sorry about the length..
>
>Compac Presario 6500
>P/N: GP645EA
>
>Btw: The HP spec seem to say that it is a Broadcom 4321 device,
>not a 4310 as listed below.
>
>//ARNE
>
>And more, anyway here is what lspci -v reports:
>
>
>00:00.0 RAM memory: nVidia Corporation Unknown device 0547 (rev a2)
>    Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0
>    Capabilities: [44] HyperTransport: Slave or Primary Interface
>        Command: BaseUnitID=0 UnitCnt=15 MastHost- DefDir- DUL-
>        Link Control 0: CFlE- CST- CFE- <LkFail- Init+ EOC- TXO- <CRCErr=0
> IsocEn- LSEn+ ExtCTL- 64b- Link Config 0: MLWI=16bit DwFcIn- MLWO=16bit
> DwFcOut- LWI=16bit DwFcInEn- LWO=16bit DwFcOutEn- Link Control 1: CFlE-
> CST- CFE- <LkFail+ Init- EOC+ TXO+ <CRCErr=0 IsocEn- LSEn- ExtCTL- 64b-
> Link Config 1: MLWI=8bit DwFcIn- MLWO=8bit DwFcOut- LWI=8bit DwFcInEn-
> LWO=8bit DwFcOutEn- Revision ID: 1.03
>        Link Frequency 0: 800MHz
>        Link Error 0: <Prot- <Ovfl- <EOC- CTLTm-
>        Link Frequency Capability 0: 200MHz+ 300MHz+ 400MHz+ 500MHz+ 600MHz+
> 800MHz+ 1.0GHz+ 1.2GHz- 1.4GHz- 1.6GHz- Vend- Feature Capability: IsocFC+
> LDTSTOP+ CRCTM- ECTLT- 64bA- UIDRD- Link Frequency 1: 200MHz
>        Link Error 1: <Prot- <Ovfl- <EOC- CTLTm-
>        Link Frequency Capability 1: 200MHz- 300MHz- 400MHz- 500MHz- 600MHz-
> 800MHz- 1.0GHz- 1.2GHz- 1.4GHz- 1.6GHz- Vend- Error Handling: PFlE+ OFlE+
> PFE- OFE- EOCFE- RFE- CRCFE- SERRFE- CF- RE- PNFE- ONFE- EOCNFE- RNFE-
> CRCNFE- SERRNFE- Prefetchable memory behind bridge Upper: 00-00
>        Bus Number: 00
>    Capabilities: [dc] HyperTransport: MSI Mapping
>
>00:01.0 ISA bridge: nVidia Corporation Unknown device 0548 (rev a2)
>    Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O+ Mem+ BusMaster+ SpecCycle+ MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap- 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort+ >SERR- <PERR- Latency: 0
>
>00:01.1 SMBus: nVidia Corporation Unknown device 0542 (rev a2)
>    Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O+ Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Interrupt: pin A
> routed to IRQ 10
>    Region 0: I/O ports at 3080 [size=64]
>    Region 4: I/O ports at 3040 [size=64]
>    Region 5: I/O ports at 3000 [size=64]
>    Capabilities: [44] Power Management version 2
>        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA
> PME(D0-,D1-,D2-,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=0 PME-
>
>00:01.2 RAM memory: nVidia Corporation Unknown device 0541 (rev a2)
>    Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap- 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
>
>00:01.3 Co-processor: nVidia Corporation Unknown device 0543 (rev a2)
>    Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap- 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0 (750ns min,
> 250ns max)
>    Interrupt: pin B routed to IRQ 11
>    Region 0: Memory at f6200000 (32-bit, non-prefetchable) [size=512K]
>
>00:02.0 USB Controller: nVidia Corporation Unknown device 055e (rev a2)
> (prog-if 10 [OHCI]) Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0 (750ns min,
> 250ns max)
>    Interrupt: pin A routed to IRQ 16
>    Region 0: Memory at f6486000 (32-bit, non-prefetchable) [size=4K]
>    Capabilities: [44] Power Management version 2
>        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=0 PME-
>
>00:02.1 USB Controller: nVidia Corporation Unknown device 055f (rev a2)
> (prog-if 20 [EHCI]) Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0 (750ns min,
> 250ns max)
>    Interrupt: pin B routed to IRQ 17
>    Region 0: Memory at f6489000 (32-bit, non-prefetchable) [size=256]
>    Capabilities: [44] Debug port
>    Capabilities: [80] Power Management version 2
>        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=0 PME-
>
>00:04.0 USB Controller: nVidia Corporation Unknown device 055e (rev a2)
> (prog-if 10 [OHCI]) Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0 (750ns min,
> 250ns max)
>    Interrupt: pin A routed to IRQ 16
>    Region 0: Memory at f6487000 (32-bit, non-prefetchable) [size=4K]
>    Capabilities: [44] Power Management version 2
>        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=0 PME-
>
>00:04.1 USB Controller: nVidia Corporation Unknown device 055f (rev a2)
> (prog-if 20 [EHCI]) Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0 (750ns min,
> 250ns max)
>    Interrupt: pin B routed to IRQ 17
>    Region 0: Memory at f6489400 (32-bit, non-prefetchable) [size=256]
>    Capabilities: [44] Debug port
>    Capabilities: [80] Power Management version 2
>        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=0 PME-
>
>00:06.0 IDE interface: nVidia Corporation Unknown device 0560 (rev a1)
> (prog-if 8a [Master SecP PriP]) Subsystem: Unknown device f03c:30cf
>    Control: I/O+ Mem- BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0 (750ns min,
> 250ns max)
>    Region 0: [virtual] Memory at 000001f0 (32-bit, non-prefetchable)
> [disabled] [size=8] Region 1: [virtual] Memory at 000003f0 (type 3,
> non-prefetchable) [disabled] [size=1] Region 2: [virtual] Memory at
> 00000170 (32-bit, non-prefetchable) [disabled] [size=8] Region 3: [virtual]
> Memory at 00000370 (type 3, non-prefetchable) [disabled] [size=1] Region 4:
> I/O ports at 30c0 [size=16]
>    Capabilities: [44] Power Management version 2
>        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA
> PME(D0-,D1-,D2-,D3hot-,D3cold-) Status: D0 PME-Enable- DSel=0 DScale=0 PME-
>
>00:07.0 Audio device: nVidia Corporation Unknown device 055c (rev a1)
>    Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0 (500ns min,
> 1250ns max)
>    Interrupt: pin A routed to IRQ 21
>    Region 0: Memory at f6480000 (32-bit, non-prefetchable) [size=16K]
>    Capabilities: [44] Power Management version 2
>        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA
> PME(D0-,D1-,D2-,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=0 PME-
>    Capabilities: [50] Message Signalled Interrupts: Mask+ 64bit+ Queue=0/0
> Enable- Address: 0000000000000000  Data: 0000
>        Masking: 00000000  Pending: 00000000
>    Capabilities: [6c] HyperTransport: MSI Mapping
>
>00:08.0 PCI bridge: nVidia Corporation Unknown device 0561 (rev a2) (prog-if
> 01 [Subtractive decode]) Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV-
> VGASnoop- ParErr- Stepping- SERR+ FastB2B- Status: Cap+ 66MHz+ UDF-
> FastB2B+ ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
> Latency: 0
>    Bus: primary=00, secondary=02, subordinate=02, sec-latency=64
>    I/O behind bridge: 0000f000-00000fff
>    Memory behind bridge: f6100000-f61fffff
>    Prefetchable memory behind bridge: fff00000-000fffff
>    Secondary status: 66MHz- FastB2B+ ParErr- DEVSEL=medium >TAbort-
> <TAbort- <MAbort+ <SERR- <PERR- BridgeCtl: Parity- SERR- NoISA+ VGA-
> MAbort- >Reset- FastB2B-
>    Capabilities: [b8] Subsystem: nVidia Corporation Unknown device cb84
>    Capabilities: [8c] HyperTransport: MSI Mapping
>
>00:09.0 IDE interface: nVidia Corporation Unknown device 0550 (rev a2)
> (prog-if 85 [Master SecO PriO]) Subsystem: Hewlett-Packard Company Unknown
> device 30cf
>    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0 (750ns min,
> 250ns max)
>    Interrupt: pin A routed to IRQ 18
>    Region 0: I/O ports at 30f0 [size=8]
>    Region 1: I/O ports at 30e4 [size=4]
>    Region 2: I/O ports at 30e8 [size=8]
>    Region 3: I/O ports at 30e0 [size=4]
>    Region 4: I/O ports at 30d0 [size=16]
>    Region 5: Memory at f6484000 (32-bit, non-prefetchable) [size=8K]
>    Capabilities: [44] Power Management version 2
>        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA
> PME(D0-,D1-,D2-,D3hot-,D3cold-) Status: D0 PME-Enable- DSel=0 DScale=0 PME-
>    Capabilities: [8c] #12 [0010]
>    Capabilities: [b0] Message Signalled Interrupts: Mask- 64bit+ Queue=0/3
> Enable- Address: 0000000000000000  Data: 0000
>    Capabilities: [cc] HyperTransport: MSI Mapping
>
>00:0a.0 Ethernet controller: nVidia Corporation Unknown device 054c (rev a2)
>    Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0 (250ns min,
> 5000ns max)
>    Interrupt: pin A routed to IRQ 19
>    Region 0: Memory at f6488000 (32-bit, non-prefetchable) [size=4K]
>    Region 1: I/O ports at 30f8 [size=8]
>    Region 2: Memory at f6489c00 (32-bit, non-prefetchable) [size=256]
>    Region 3: Memory at f6489800 (32-bit, non-prefetchable) [size=16]
>    Capabilities: [44] Power Management version 2
>        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable+ DSel=0 DScale=0 PME-
>    Capabilities: [50] Message Signalled Interrupts: Mask+ 64bit+ Queue=0/3
> Enable- Address: 0000000000000000  Data: 0000
>        Masking: 00000000  Pending: 00000000
>    Capabilities: [6c] HyperTransport: MSI Mapping
>
>00:0c.0 PCI bridge: nVidia Corporation Unknown device 0563 (rev a2) (prog-if
> 00 [Normal decode]) Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV-
> VGASnoop- ParErr- Stepping- SERR+ FastB2B- Status: Cap+ 66MHz- UDF-
> FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
> Latency: 0, Cache Line Size: 64 bytes
>    Bus: primary=00, secondary=04, subordinate=05, sec-latency=0
>    I/O behind bridge: 00004000-00004fff
>    Memory behind bridge: f2000000-f3ffffff
>    Prefetchable memory behind bridge: 00000000f0000000-00000000f1ffffff
>    Secondary status: 66MHz- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort-
> <MAbort- <SERR- <PERR- BridgeCtl: Parity- SERR- NoISA+ VGA- MAbort- >Reset-
> FastB2B-
>    Capabilities: [40] Subsystem: nVidia Corporation Unknown device 0000
>    Capabilities: [48] Power Management version 2
>        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=0 PME-
>    Capabilities: [50] Message Signalled Interrupts: Mask- 64bit+ Queue=0/1
> Enable- Address: 0000000000000000  Data: 0000
>    Capabilities: [60] HyperTransport: MSI Mapping
>    Capabilities: [80] Express Root Port (Slot+) IRQ 0
>        Device: Supported: MaxPayload 256 bytes, PhantFunc 0, ExtTag+
>        Device: Latency L0s <64ns, L1 <1us
>        Device: Errors: Correctable+ Non-Fatal+ Fatal+ Unsupported+
>        Device: RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+
>        Device: MaxPayload 128 bytes, MaxReadReq 512 bytes
>        Link: Supported Speed 2.5Gb/s, Width x1, ASPM L0s L1, Port 1
>        Link: Latency L0s <512ns, L1 <4us
>        Link: ASPM Disabled RCB 64 bytes CommClk- ExtSynch-
>        Link: Speed 2.5Gb/s, Width x1
>        Slot: AtnBtn- PwrCtrl- MRL- AtnInd- PwrInd- HotPlug- Surpise-
>        Slot: Number 2, PowerLimit 10.000000
>        Slot: Enabled AtnBtn- PwrFlt- MRL- PresDet- CmdCplt- HPIrq+
>        Slot: AttnInd Off, PwrInd On, Power-
>        Root: Correctable- Non-Fatal- Fatal- PME-
>
>00:0d.0 PCI bridge: nVidia Corporation Unknown device 0563 (rev a2) (prog-if
> 00 [Normal decode]) Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV-
> VGASnoop- ParErr- Stepping- SERR+ FastB2B- Status: Cap+ 66MHz- UDF-
> FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
> Latency: 0, Cache Line Size: 64 bytes
>    Bus: primary=00, secondary=03, subordinate=03, sec-latency=0
>    I/O behind bridge: 0000f000-00000fff
>    Memory behind bridge: f6000000-f60fffff
>    Prefetchable memory behind bridge: 00000000fff00000-00000000000fffff
>    Secondary status: 66MHz- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort-
> <MAbort+ <SERR- <PERR- BridgeCtl: Parity- SERR- NoISA+ VGA- MAbort- >Reset-
> FastB2B-
>    Capabilities: [40] Subsystem: nVidia Corporation Unknown device 0000
>    Capabilities: [48] Power Management version 2
>        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=0 PME-
>    Capabilities: [50] Message Signalled Interrupts: Mask- 64bit+ Queue=0/1
> Enable- Address: 0000000000000000  Data: 0000
>    Capabilities: [60] HyperTransport: MSI Mapping
>    Capabilities: [80] Express Root Port (Slot+) IRQ 0
>        Device: Supported: MaxPayload 256 bytes, PhantFunc 0, ExtTag+
>        Device: Latency L0s <64ns, L1 <1us
>        Device: Errors: Correctable+ Non-Fatal+ Fatal+ Unsupported+
>        Device: RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+
>        Device: MaxPayload 128 bytes, MaxReadReq 512 bytes
>        Link: Supported Speed 2.5Gb/s, Width x1, ASPM L0s L1, Port 2
>        Link: Latency L0s <512ns, L1 <4us
>        Link: ASPM Disabled RCB 64 bytes CommClk+ ExtSynch-
>        Link: Speed 2.5Gb/s, Width x1
>        Slot: AtnBtn- PwrCtrl- MRL- AtnInd- PwrInd- HotPlug- Surpise-
>        Slot: Number 3, PowerLimit 10.000000
>        Slot: Enabled AtnBtn- PwrFlt- MRL- PresDet- CmdCplt- HPIrq+
>        Slot: AttnInd Off, PwrInd On, Power-
>        Root: Correctable- Non-Fatal- Fatal- PME-
>
>00:12.0 VGA compatible controller: nVidia Corporation Unknown device 0531
> (rev a2) (prog-if 00 [VGA]) Subsystem: Hewlett-Packard Company Unknown
> device 30cf
>    Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR- FastB2B- Status: Cap+ 66MHz+ UDF- FastB2B+ ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0
>    Interrupt: pin A routed to IRQ 22
>    Region 0: Memory at f5000000 (32-bit, non-prefetchable) [size=16M]
>    Region 1: Memory at d0000000 (64-bit, prefetchable) [size=256M]
>    Region 3: Memory at f4000000 (64-bit, non-prefetchable) [size=16M]
>    [virtual] Expansion ROM at 88000000 [disabled] [size=128K]
>    Capabilities: [48] Power Management version 2
>        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA
> PME(D0-,D1-,D2-,D3hot-,D3cold-) Status: D0 PME-Enable- DSel=0 DScale=0 PME-
>    Capabilities: [50] Message Signalled Interrupts: Mask- 64bit+ Queue=0/0
> Enable- Address: 0000000000000000  Data: 0000
>
>00:18.0 Host bridge: Advanced Micro Devices [AMD] K8 [Athlon64/Opteron]
> HyperTransport Technology Configuration Control: I/O- Mem- BusMaster-
> SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- Status: Cap+
> 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR-
> <PERR- Capabilities: [80] HyperTransport: Host or Secondary Interface
>        !!! Possibly incomplete decoding
>        Command: WarmRst+ DblEnd-
>        Link Control: CFlE- CST- CFE- <LkFail- Init+ EOC- TXO- <CRCErr=8
>        Link Config: MLWI=16bit MLWO=16bit LWI=16bit LWO=16bit
>        Revision ID: 1.02
>
>00:18.1 Host bridge: Advanced Micro Devices [AMD] K8 [Athlon64/Opteron]
> Address Map Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop-
> ParErr- Stepping- SERR- FastB2B- Status: Cap- 66MHz- UDF- FastB2B- ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
>
>00:18.2 Host bridge: Advanced Micro Devices [AMD] K8 [Athlon64/Opteron] DRAM
> Controller Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop-
> ParErr- Stepping- SERR- FastB2B- Status: Cap- 66MHz- UDF- FastB2B- ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
>
>00:18.3 Host bridge: Advanced Micro Devices [AMD] K8 [Athlon64/Opteron]
> Miscellaneous Control Control: I/O- Mem- BusMaster- SpecCycle- MemWINV-
> VGASnoop- ParErr- Stepping- SERR- FastB2B- Status: Cap+ 66MHz- UDF-
> FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
> Capabilities: [f0] #0f [0010]
>
>02:05.0 FireWire (IEEE 1394): Ricoh Co Ltd R5C832 IEEE 1394 Controller (rev
> 05) (prog-if 10 [OHCI]) Subsystem: Hewlett-Packard Company Unknown device
> 30cf
>    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR+ FastB2B- Status: Cap+ 66MHz- UDF- FastB2B- ParErr-
> DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 64 (500ns
> min, 1000ns max), Cache Line Size: 64 bytes
>    Interrupt: pin A routed to IRQ 5
>    Region 0: Memory at f6100000 (32-bit, non-prefetchable) [size=2K]
>    Capabilities: [dc] Power Management version 2
>        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=2 PME+
>
>02:05.1 Generic system peripheral [0805]: Ricoh Co Ltd R5C822
> SD/SDIO/MMC/MS/MSPro Host Adapter (rev 22) Subsystem: Hewlett-Packard
> Company Unknown device 30cf
>    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR+ FastB2B- Status: Cap+ 66MHz- UDF- FastB2B- ParErr-
> DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 64, Cache
> Line Size: 64 bytes
>    Interrupt: pin B routed to IRQ 7
>    Region 0: Memory at f6100800 (32-bit, non-prefetchable) [size=256]
>    Capabilities: [80] Power Management version 2
>        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=2 PME-
>
>02:05.2 System peripheral: Ricoh Co Ltd Unknown device 0843 (rev 12)
>    Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR+ FastB2B- Status: Cap+ 66MHz- UDF- FastB2B- ParErr-
> DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 64, Cache
> Line Size: 64 bytes
>    Interrupt: pin B routed to IRQ 11
>    Region 0: Memory at f6100c00 (32-bit, non-prefetchable) [size=256]
>    Capabilities: [80] Power Management version 2
>        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=2 PME-
>
>02:05.3 System peripheral: Ricoh Co Ltd R5C592 Memory Stick Bus Host Adapter
> (rev 12) Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR+ FastB2B- Status: Cap+ 66MHz- UDF- FastB2B- ParErr-
> DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 64, Cache
> Line Size: 64 bytes
>    Interrupt: pin B routed to IRQ 11
>    Region 0: Memory at f6101000 (32-bit, non-prefetchable) [size=256]
>    Capabilities: [80] Power Management version 2
>        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=2 PME-
>
>02:05.4 System peripheral: Ricoh Co Ltd xD-Picture Card Controller (rev 12)
>    Subsystem: Hewlett-Packard Company Unknown device 30cf
>    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR+ FastB2B- Status: Cap+ 66MHz- UDF- FastB2B- ParErr-
> DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 64, Cache
> Line Size: 64 bytes
>    Interrupt: pin B routed to IRQ 11
>    Region 0: Memory at f6101400 (32-bit, non-prefetchable) [size=256]
>    Capabilities: [80] Power Management version 2
>        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA
> PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 PME-Enable- DSel=0 DScale=2 PME-
>
>03:00.0 Network controller: Broadcom Corporation BCM4310 UART (rev 02)
>    Subsystem: Hewlett-Packard Company Unknown device 1371
>    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr-
> Stepping- SERR+ FastB2B- Status: Cap+ 66MHz- UDF- FastB2B- ParErr-
> DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- Latency: 0, Cache Line
> Size: 64 bytes
>    Interrupt: pin A routed to IRQ 20
>    Region 0: Memory at f6000000 (64-bit, non-prefetchable) [size=16K]
>    Capabilities: [40] Power Management version 3
>        Flags: PMEClk- DSI- D1+ D2+ AuxCurrent=0mA
> PME(D0-,D1-,D2-,D3hot-,D3cold-) Status: D0 PME-Enable- DSel=0 DScale=2 PME-
>    Capabilities: [58] Vendor Specific Information
>    Capabilities: [e8] Message Signalled Interrupts: Mask- 64bit+ Queue=0/0
> Enable- Address: 0000000000000000  Data: 0000
>    Capabilities: [d0] Express Endpoint IRQ 0
>        Device: Supported: MaxPayload 128 bytes, PhantFunc 0, ExtTag+
>        Device: Latency L0s <4us, L1 unlimited
>        Device: AtnBtn- AtnInd- PwrInd-
>        Device: Errors: Correctable- Non-Fatal- Fatal- Unsupported-
>        Device: RlxdOrd- ExtTag- PhantFunc- AuxPwr- NoSnoop-
>        Device: MaxPayload 128 bytes, MaxReadReq 128 bytes
>        Link: Supported Speed 2.5Gb/s, Width x1, ASPM L0s, Port 0
>        Link: Latency L0s <4us, L1 <64us
>        Link: ASPM Disabled RCB 64 bytes CommClk+ ExtSynch-
>        Link: Speed 2.5Gb/s, Width x1
>
>Devices in Windows Vista:
>-------------------------
>Name    [00000000] WAN Miniport (L2TP) Adapter Type    Not Available
>Name    [00000001] WAN Miniport (PPTP)
>Adapter Type    Wide Area Network (WAN)
>Name    [00000002] WAN Miniport (PPPOE)
>Adapter Type    Wide Area Network (WAN)
>Name    [00000003] WAN Miniport (IPv6)
>Adapter Type    Not Available
>Name    [00000004] NVIDIA nForce Networking Controller
>Adapter Type    Ethernet 802.3
>Name    [00000006] WAN Miniport (IP)
>Adapter Type    Not Available
>Name    [00000007] Broadcom 802.11a/b/g WLAN
>Adapter Type    Ethernet 802.3               Service Name    BCM43XX
>Name    [00000009] RAS Async Adapter
>Adapter Type    Not Available
>Name    [00000011] Bluetooth Device (Personal Area Network)
>Adapter Type    Not Available
>Name    [00000012] Microsoft Tun Miniport Adapter
>Adapter Type    Ethernet 802.3
>Name    [00000013] Microsoft ISATAP Adapter
>Adapter Type    Tunnel
>Name    HDAUDIO Soft Data Fax Modem with SmartCP
>PNP Device ID   
> HDAUDIO\FUNC_02&VEN_14F1&DEV_5045&SUBSYS_103C30CF&REV_1001\4&887B936&0&0002
> Name    NVIDIA MCP67M
>PNP Device ID   
> PCI\VEN_10DE&DEV_0531&SUBSYS_30CF103C&REV_A2\3&2411E6FE&0&90 Adapter Type  
>  GeForce 7150M / nForce 630M, NVIDIA compatible
>Adapter Description    NVIDIA MCP67M
>
If you don't get a good answer here, then I would persue the ndiswrapper 
route.  I have a now about 2 years old HP dv5120us lappy, with a bcm4318 
radio in it, and with ndiswrapper, it logs in as fast at bootup as it would 
with a cat5 stuck in the side of it, at a reportedly full 54MB/S connection 
rate, which isn't noticeably slower than my 1.5/256 dsl connection.

Good luck, we seem to need that in copious quantity's anyplace Broadcom is 
mentioned. 

-- 
Cheers, Gene
"There are four boxes to be used in defense of liberty:
 soap, ballot, jury, and ammo. Please use in that order."
-Ed Howdershelt (Author)
It may be that your whole purpose in life is simply to serve as a
warning to others.


From johannes at sipsolutions.net  Fri Sep  7 15:51:35 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 07 Sep 2007 15:51:35 +0200
Subject: Any hope ?
In-Reply-To: <220241.22982.qm@web63712.mail.re1.yahoo.com>
References: <220241.22982.qm@web63712.mail.re1.yahoo.com>
Message-ID: <1189173095.28781.160.camel@johannes.berg>

On Fri, 2007-09-07 at 05:46 -0700, Arne Chr. Jorgensen wrote:

> 3. HP spesifications says it has a Broadcom 4321AGN Wi-Fi Adapter 

>  
> Any hope this may play under Linux ? Or should I trade for something
> else ?

No hope at this time, we haven't had a chance to reverse engineer the
11N stuff from broadcom yet.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070907/4fd5d275/attachment.pgp>

From achrisjo at yahoo.com  Fri Sep  7 16:37:25 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Fri, 7 Sep 2007 07:37:25 -0700 (PDT)
Subject: Fwd: Re: Any hope ?
Message-ID: <892041.62304.qm@web63714.mail.re1.yahoo.com>



Note: forwarded message attached.
       
---------------------------------
Luggage? GPS? Comic books? 
Check out fitting  gifts for grads at Yahoo! Search.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070907/414307d9/attachment.html>
-------------- next part --------------
An embedded message was scrubbed...
From: "Arne Chr. Jorgensen" <achrisjo at yahoo.com>
Subject: Re: Any hope ?
Date: Fri, 7 Sep 2007 07:32:55 -0700 (PDT)
Size: 4503
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070907/414307d9/attachment.mht>

From johannes at sipsolutions.net  Fri Sep  7 16:44:48 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Fri, 07 Sep 2007 16:44:48 +0200
Subject: Any hope ?
In-Reply-To: <748625.67449.qm@web63712.mail.re1.yahoo.com>
References: <748625.67449.qm@web63712.mail.re1.yahoo.com>
Message-ID: <1189176288.28781.178.camel@johannes.berg>

Hi,

Please do not take the list off replies. It is not only unpolite, you're
also very much more likely to get a response if the list is on.

> Possible to explain what the 11N is ?   

11N is a new wireless specification for much higher speeds, your
computer shipped with a Broadcom chipset for that specification.

> Meaning: - I understand that Linux need a driver, but are Broadcom,
> HP, and others, 
> reluctant in supplying needed information ? ( have been in contact
> with HP, nVidia, but not Broadcom yet ) 

Yes. Broadcom is not releasing information on how to program it.

> My spesific situation is that I'll return the damn thing to Compac/HP
> and will go
> to some other supplier. I am in search for hardware that will run
> Linux, but they
> will not give me any clear answer. They don't seem willing to suggest
> any product that
> will meet this criteria either. So ? 

If you can, return it, the wireless in it is dead. You could possibly
swap it out but it might or might not work and it usually takes a lot of
effort.

> Someone mentioned a "Ndiswrapper" - is that the same thing ?

No, its a crappy workaround to run Windows drivers in the Linux kernel.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070907/7ec1c48e/attachment.pgp>

From larry.finger at lwfinger.net  Fri Sep  7 17:35:22 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 07 Sep 2007 10:35:22 -0500
Subject: Fwd: Re: Any hope ?
In-Reply-To: <892041.62304.qm@web63714.mail.re1.yahoo.com>
References: <892041.62304.qm@web63714.mail.re1.yahoo.com>
Message-ID: <46E16FBA.50003@lwfinger.net>

Arne Chr. Jorgensen wrote:
> Possible to explain what the 11N is ?

It is shorthand for 802.11n, which is the latest, and not yet finalized, standard for wireless 
communications.
> 
> I am a bit confused, don't really know how these pieces play together. 
> Broadcom's
> stuff, is that a separate module like a PCMCIA card or something ? Or 
> are we talking
> about a single silicon-chip ?  Why reverse engineer ?

The Broadcom wireless chips require a complicated interaction between the host CPU and the chip's 
processor. The specifications for this interaction have not been published by Broadcom. The 
existance of a native Linux driver has depended on the collaborative effort of two groups. The first 
of them (the reverse engineers) has taken the binary drivers supplied by Broadcom for various 
operating systems, decompiled them, and written a set of specifications for the chip. The second 
group has taken those specifications and written a Linux driver.
> 
> Meaning: - I understand that Linux need a driver, but are Broadcom, HP, 
> and others,
> reluctant in supplying needed information ? ( have been in contact with 
> HP, nVidia, but
> not Broadcom yet )

Broadcom has not supplied any information to any of us.

> My spesific situation is that I'll return the damn thing to Compac/HP 
> and will go
> to some other supplier. I am in search for hardware that will run Linux, 
> but they
> will not give me any clear answer. They don't seem willing to suggest 
> any product that
> will meet this criteria either. So ?

A great many HP/Compaq laptops run Linux very well. For example, I have had an HP dv2125nr for about 
6 months, and I am using openSUSE 10.2 on it. Every piece of hardware works on it using a native 
Linux driver except for the modem and the xD card reader.

> Someone mentioned a "Ndiswrapper" - is that the same thing ?

Ndiswrapper is a Linux driver that encloses the Windows driver for your network device. It works, 
but has two main disadvantages. The first is that you run unchecked Windows binary in the inner-most 
ring of your OS and you have the potential to encounter the same kinds of bugs that cause "Blue 
Screens of Death" in Windows. The second problem is that no Linux developer will even look at any 
Linux kernel crashes because of the first problem.

> Above, I did ask if the Broadcom thing was a seperate module. If so, 
> can't the whole
> module be replaced with something else ?  Something that does run under 
> Linux ?
> Other options for wireless ?

The wireless is likely to be a mini-PCIe card. You could swap it for a BCM4311 card. You can always 
get a USB module that has a chip supported by a native Linux driver.

> Any good tip as to what is the best notebook/laptop to shop for, in 
> order to run Linux ?

Besides the wireless problem, the second area of difficulty is with disk controllers, which I think 
is the reason for the crashes you noted in your first post. Since laptops switched to SATA 
controllers, the changes have been very rapid. My suggestions for a laptop purchase are as follows:

If you really want to be certain, buy a laptop with Linux preinstalled. At the moment, Dell is the 
only mass producer that fits this category.

For the units that come with Windows:

(1) Stay away from the "just-introduced, latest and greatest" models. The model that came out 3 
months ago is more likely to be supported.

(2) If possible, take the installation DVD for F7, F8 (in trial) , openSUSE 10.3 (out in beta), or 
some other recent distro with you to the shop and tell them you won't buy the model unless the 
computer can boot that CD and report the details of the DVD ROM and hard drives. The kernel in that 
DVD should be no earlier than 2.6.21 - the later the better. For test purposes, you can try an i386 
DVD on an x86_64 processor; however, for final installation you should use only the x86_64 version 
if your system supports it. I'll never go back.

(3) For Broadcom wireless, look for BCM4311 or BCM4312 cards. Stay away from pre-N stuff.

Good luck,

Larry





From achrisjo at yahoo.com  Fri Sep  7 22:24:03 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Fri, 7 Sep 2007 13:24:03 -0700 (PDT)
Subject: Thanks...!
Message-ID: <240129.23134.qm@web63702.mail.re1.yahoo.com>

Hi,

Well, first of all - thanks a lot for the informative inputs. 

Larry first:
>
> Stay away from the "just-introduced, latest and greatest" models.
> The model that came out 3 months ago is more likely to be supported.
>

Well, for a half year - I have been using an old Toshiba (486) with RH6? - and 
started seeing the advantage of a laptop ;) got tired of those floppy disks ;)
 
So, I guess that might explain why I didn't pick up the meaning of 11N right away.

johannes:

>
> Yes. Broadcom is not releasing information on how to program it.
>

Hmm...and they have a contract with HP and others, so...else I did see some
Linux drivers on their site - but for what, I don't know.. 

>
> If you can, return it, the wireless in it is dead. You could possibly
> swap it out but it might or might not work and it usually takes a lot
> of effort.
>

Thanks...I have wasted more time then I do care to think of...having had
some odd hardware. 

> >
> > Someone mentioned a "Ndiswrapper" - is that the same thing ?
> >
>
>
> No, its a crappy workaround to run Windows drivers in the Linux kernel.
>

I see.. it may work well, it may not. 


                          ------------------


Larry gave a good description of the effort to get some Linux driver, which was
some of my point when asking "why reverse engineer ?".  No fair competition.

> 
> The Broadcom wireless chips require a complicated interaction......
>

Enough ;)  - or I'll soon take the damn thing apart to look inside ;)

>
> Besides the wireless problem, the second area of difficulty is with
> disk controllers, which I think is the reason for the crashes you noted 
> in your first post. Since laptops switched to SATA controllers, the changes 
> have been very rapid. 
>

Not up to date in that area either. I did notice someone saying something, perhaps
it was when I had a short peek at your archieves ?  Something about ACPI..something
about power control, etc. There seem to be some nVidia chips controlling quite a bit
of it all. With newer kernels, it was like single stepping parts of the boot-up 
sequence, as I would press the power on/off button. Just some thought....

Unfortunatly, I don't know much about the kernel, or kernel drivers, etc. And it has
become harder to keep pace with the development.  On the other hand, I do feel lost
if placed in front of a Microsoft Window ;) ...so, I guess I will have to stick to
some linux boxes...

>
> (3) For Broadcom wireless, look for BCM4311 or BCM4312 cards. Stay away
>  from pre-N stuff.
>

pre..802.11n - is that what you meant ?


johannes said:

>
> If you can, return it, the wireless in it is dead. 
>

Probably what I'll have to do. I have little use of Microsoft....

Thanks guys,

- now...what else are you up to in this place, me wonder..;)


//ARNE
 
       
---------------------------------
Luggage? GPS? Comic books? 
Check out fitting  gifts for grads at Yahoo! Search.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070907/02296f45/attachment.html>

From proski at gnu.org  Fri Sep  7 23:02:43 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 07 Sep 2007 17:02:43 -0400
Subject: Thanks...!
In-Reply-To: <240129.23134.qm@web63702.mail.re1.yahoo.com>
References: <240129.23134.qm@web63702.mail.re1.yahoo.com>
Message-ID: <1189198963.15103.11.camel@dv>

Hello!

Please don't start new threads for the same topic.  Next time please use
"reply" on the appropriate message in the thread.  It's just easier to
read this way.

On Fri, 2007-09-07 at 13:24 -0700, Arne Chr. Jorgensen wrote:

> > (3) For Broadcom wireless, look for BCM4311 or BCM4312 cards. Stay
> away
> >  from pre-N stuff.

> pre..802.11n - is that what you meant ?

Just to avoid possible confusion, this refers only to the devices
implementing any preliminary 802.11n specifications (whether it's
"pre-N" or "draft N"), not to the devices implementing standard
protocols that predate 802.11n, such as 802.11g and 802.11b.

Basically, support for bcm4306 and bcm4311 are quite good, bcm4318 is
getting there, support for anything newer is not even under development.

-- 
Regards,
Pavel Roskin



From achrisjo at yahoo.com  Sat Sep  8 00:30:09 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Fri, 7 Sep 2007 15:30:09 -0700 (PDT)
Subject: Any hope ?
Message-ID: <205363.89067.qm@web63707.mail.re1.yahoo.com>

Hey Larry,


Had a check at HP, is this the one you got ?


--------------------------------------------------------------------------
Product Name     dv2125nr
US Product Number     RG408UA#ABA
Microprocessor     1.6 GHz AMD Turion? 64 X2 Dual-Core Mobile Technology TL-50
Microprocessor Cache     2 X 256KB L2 Cache
Memory     1024MB DDR2 System Memory (2 Dimm)
Memory Max     2048MB
Video Graphics     NVIDIA GeForce Go 6150 (UMA)
Video Memory     up to 128MB (shared)
Hard Drive     120GB 5400RPM (SATA)
Multimedia Drive     LightScribe SuperMulti 8X DVD?RW with Double Layer Support
Display     14.1? WXGA High-Definition BrightView Widescreen Display (1280 x 800)
Fax/Modem     High speed 56k modem
Network Card     Integrated 10/100BASE-T Ethernet LAN (RJ-45 connector)
Wireless Connectivity     802.11b/g WLAN
HP Features     HP Imprint finish & HP Pavilion Integrated Microphone
Sound     Altec Lansing
Keyboard     101-key compatible

2 Quick Launch Buttons (HP Quick Play Menu and DVD buttons)
Pointing Device     Touch Pad with On/Off button and dedicated vertical Scroll Up/Down pad
PC Card Slots     

-----------------------------------------------------------------------------

This does looks close - and it did run with wireless ???
Do adapter/chip do you have ?

                                  ----------------------

You also said:

>
> A great many HP/Compaq laptops run Linux very well. For example, I have
> had an HP dv2125nr for about 6 months, and I am using openSUSE 10.2 on it. 
> Every piece of hardware works on it using a native Linux driver except for the modem and 
> the xD card reader.
>

Does this have blue-tooth ?

Here is what I found told about mine:
--Broadcom 4321AGN Wi-Fi Adapter (802.11 a/b/g/ draft-n) w/2 antennas 
--( guess one part may be blue-tooth - but I don't have a clue )


                                  ----------------------

Now, I can still keep it for a week or more ( have a 30 day return deal on it ) Perhaps you
could guide me through some tests ??  Perhaps it could give some info in return ?

Let's design a chip, call it 777 and what we have from earlier, is a 747 - so we use much of the
same core. This thing above may have some of the same core as the earlier ones. But something is
added to it. 

There was something funny !  I cannot swear it, but during one of my boot-ups, I think I had
wireless working !  I pulled out the network cable, and it did seem like I actually were online.

But the sensitivity on the touchpad, the "tapping" setting, had me screw up everything. I had trouble
with the display settings, and several other things.

I don't know how to set up wlan, the network settings, scripts, etc. 


Well, looking at the hardware listed above - they don't seem that far apart. And I did get this hunch that your machine wouldn't swallow these new kernel updates. Why does it work on the initial kernels ? 

Most of my focus was on the 86_64 capabilities. Would it run that ?  Right now it does on an earlier
Fedora6 kernel. But I didn't have that one back then. Only Fedora7, which did boot up as far as I know, but the software updater would download a newer kernel, which had everything go wrong. Same thing with all the Fedora releases. I don't know why, did notice some different kernel-modules, but else ? I don't know.

As a check, I downloaded OpenSuse 10.2, the 86x64 version, and it did seem okay. But I am unfamiliar
with Suse, don't know where I find the startup scripts, and such...so, confirmed it did run x86_64,
I went back and tried F7.9 test release. 

Well, looking at the hardware listed above - they don't seem that far apart. And I did get this hunch that your machine wouldn't swallow these new kernel updates. Why does it work on the initial kernels ?  

Well, just some idea.  Perhaps I could install Suse, replicate your settings and check it ?

I might be wrong, just to much did happen at the same time in that episode - so I can't say for sure
if it did get the wlan up. What kernel modules to use, etc.. well, I haven't done any good test.



//ARNE


       
---------------------------------
Park yourself in front of a world of choices in alternative vehicles.
Visit the Yahoo! Auto Green Center.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070907/5925969f/attachment.html>

From larry.finger at lwfinger.net  Sat Sep  8 04:50:49 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 07 Sep 2007 21:50:49 -0500
Subject: Any hope ?
In-Reply-To: <205363.89067.qm@web63707.mail.re1.yahoo.com>
References: <205363.89067.qm@web63707.mail.re1.yahoo.com>
Message-ID: <46E20E09.2000909@lwfinger.net>

Arne Chr. Jorgensen wrote:
> Hey Larry,
> 
> 
> Had a check at HP, is this the one you got ?
> 
> 
> --------------------------------------------------------------------------
> Product Name     dv2125nr
> US Product Number     RG408UA#ABA
> Microprocessor     1.6 GHz AMD Turion? 64 X2 Dual-Core Mobile Technology 
> TL-50
> Microprocessor Cache     2 X 256KB L2 Cache
> Memory     1024MB DDR2 System Memory (2 Dimm)
> Memory Max     2048MB
> Video Graphics     NVIDIA GeForce Go 6150 (UMA)
> Video Memory     up to 128MB (shared)
> Hard Drive     120GB 5400RPM (SATA)
> Multimedia Drive     LightScribe SuperMulti 8X DVD?RW with Double Layer 
> Support
> Display     14.1? WXGA High-Definition BrightView Widescreen Display 
> (1280 x 800)
> Fax/Modem     High speed 56k modem
> Network Card     Integrated 10/100BASE-T Ethernet LAN (RJ-45 connector)
> Wireless Connectivity     802.11b/g WLAN
> HP Features     HP Imprint finish & HP Pavilion Integrated Microphone
> Sound     Altec Lansing
> Keyboard     101-key compatible
> 
> 2 Quick Launch Buttons (HP Quick Play Menu and DVD buttons)
> Pointing Device     Touch Pad with On/Off button and dedicated vertical 
> Scroll Up/Down pad
> PC Card Slots    
> 
> -----------------------------------------------------------------------------
> 
> This does looks close - and it did run with wireless ???
> Do adapter/chip do you have ?

This is exactly the computer I have. The wireless is a BCM4311. The only difference with what I have 
is that I bought an extra 1 GB RAM card, which meant I had to pull one of the 512 MB ones, thus I 
have 1.5 GB RAM. The extra was for testing - it isn't needed.

>                                   ----------------------
> 
> You also said:
> 
>  >
>  > A great many HP/Compaq laptops run Linux very well. For example, I have
>  > had an HP dv2125nr for about 6 months, and I am using openSUSE 10.2 
> on it.
>  > Every piece of hardware works on it using a native Linux driver 
> except for the modem and
>  > the xD card reader.
>  >
> 
> Does this have blue-tooth ?

No.

> Here is what I found told about mine:
> --Broadcom 4321AGN Wi-Fi Adapter (802.11 a/b/g/ draft-n) w/2 antennas
> --( guess one part may be blue-tooth - but I don't have a clue )

No - 802.11n uses multiple antennas to get extra speed. I think that is what they mean.

> Now, I can still keep it for a week or more ( have a 30 day return deal 
> on it ) Perhaps you
> could guide me through some tests ??  Perhaps it could give some info in 
> return ?

That draft N BCM card is not going to work with the native driver for quite some time. Our reverse 
engineers have no plans to get to it, and until they do, there will be no driver.
> 
> Let's design a chip, call it 777 and what we have from earlier, is a 747 
> - so we use much of the
> same core. This thing above may have some of the same core as the 
> earlier ones. But something is
> added to it.

Yes, something was added that makes it fly totally differently.

> There was something funny !  I cannot swear it, but during one of my 
> boot-ups, I think I had
> wireless working !  I pulled out the network cable, and it did seem like 
> I actually were online.

I am skeptical.

> But the sensitivity on the touchpad, the "tapping" setting, had me screw 
> up everything. I had trouble
> with the display settings, and several other things.

I always edit the X configuration file and turn off tapping. I hate it. I also modify the 
sensitivity to fit my wants.

> I don't know how to set up wlan, the network settings, scripts, etc.

On openSUSE, all those settings are handled through a configuration tool called YaST Yet another 
Setup Tool). I know where the files live, but I don't need to change them manually anymore. 
Similarly, wireless is configured through NetworkManager, now. The only problem with openSUSE 10.2 
is that the supported kernel is 2.6.18, which is not new enough to properly support BCM43xx 
wireless. The driver didn't really work well in mainline kernels until 2.6.21.

> Well, looking at the hardware listed above - they don't seem that far 
> apart. And I did get this hunch that your machine wouldn't swallow these 
> new kernel updates. Why does it work on the initial kernels ?

My machine can handle any of the latest kernels. What makes you think it won't work with newer ones?

> Most of my focus was on the 86_64 capabilities. Would it run that ?  

I only run an x86_64 system. Wouldn't ever go back to an i386 machine.

> Right now it does on an earlier
> Fedora6 kernel. But I didn't have that one back then. Only Fedora7, 
> which did boot up as far as I know, but the software updater would 
> download a newer kernel, which had everything go wrong. Same thing with 
> all the Fedora releases. I don't know why, did notice some different 
> kernel-modules, but else ? I don't know.

IO don't know why that happened. It shouldn't have.

> As a check, I downloaded OpenSuse 10.2, the 86x64 version, and it did 
> seem okay. But I am unfamiliar
> with Suse, don't know where I find the startup scripts, and such...so, 
> confirmed it did run x86_64,
> I went back and tried F7.9 test release.

To each his own.

> Well, looking at the hardware listed above - they don't seem that far 
> apart. And I did get this hunch that your machine wouldn't swallow these 
> new kernel updates. Why does it work on the initial kernels ? 

My machine is running a 2.6.23-rc5 kernel - the latest there is. For testing purposes, I always use 
the latest one in the Linux mainstream distribution. I still don't know where your hunch came from.

> Well, just some idea.  Perhaps I could install Suse, replicate your 
> settings and check it ?
> 
> I might be wrong, just to much did happen at the same time in that 
> episode - so I can't say for sure
> if it did get the wlan up. What kernel modules to use, etc.. well, I 
> haven't done any good test.

Larry


From sepherosa at gmail.com  Sat Sep  8 09:05:09 2007
From: sepherosa at gmail.com (Sepherosa Ziehau)
Date: Sat, 8 Sep 2007 15:05:09 +0800
Subject: Driver for broadcom wifi chips available in DragonFlyBSD
Message-ID: <ea7b9c170709080005s13a23584w26e271f71b3b2df4@mail.gmail.com>

Hi all,

I have made a driver, which supports broadcom wifi chips, for DragonFlyBSD:
http://leaf.dragonflybsd.org/mailarchive/commits/2007-09/msg00032.html

Thank you for all of your work.
Also thank johill and mb on #bcm-specs very much :)

Best Regards,
sephe

-- 
Live Free or Die


From sepherosa at gmail.com  Sat Sep  8 09:08:36 2007
From: sepherosa at gmail.com (Sepherosa Ziehau)
Date: Sat, 8 Sep 2007 15:08:36 +0800
Subject: [PATCH, fwcutter] add support for DragonFlyBSD
Message-ID: <ea7b9c170709080008s2ca6322djff501a0f8b1405e5@mail.gmail.com>

Hi,

Following patch make b43-fwcutter work on DragonFlyBSD:
http://leaf.dragonflybsd.org/~sephe/fwcutter.diff

Please review it.  If you folks think it is OK, please commit it to
your svn repos.
It was reviewed by johill and mb on #bcm-specs

Thanks,
sephe

-- 
Live Free or Die


From sepherosa at gmail.com  Sat Sep  8 09:15:17 2007
From: sepherosa at gmail.com (Sepherosa Ziehau)
Date: Sat, 8 Sep 2007 15:15:17 +0800
Subject: Propose for relicensing fwcutter under BSD
Message-ID: <ea7b9c170709080015s544e21c6q159ab2c7e628f2a5@mail.gmail.com>

Hi all,

Would you consider relicense fwcutter under BSDL?  The driver in
DragonFlyBSD depends on the firmware files produced by fwcutter and I
don't want to "reinvent the wheel", so I want to put it into our base
system.

I think Johannes and Michael are OK with it.

Best Regards,
sephe

-- 
Live Free or Die


From johannes at sipsolutions.net  Sat Sep  8 09:43:33 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Sat, 08 Sep 2007 09:43:33 +0200
Subject: Propose for relicensing fwcutter under BSD
In-Reply-To: <ea7b9c170709080015s544e21c6q159ab2c7e628f2a5@mail.gmail.com>
References: <ea7b9c170709080015s544e21c6q159ab2c7e628f2a5@mail.gmail.com>
Message-ID: <1189237413.4506.9.camel@johannes.berg>

Hi,

> Would you consider relicense fwcutter under BSDL?  The driver in
> DragonFlyBSD depends on the firmware files produced by fwcutter and I
> don't want to "reinvent the wheel", so I want to put it into our base
> system.
> 
> I think Johannes and Michael are OK with it.

Yeah, I'll relicense my changes under whatever BSD license you want, a
collection of md5 and various other numbers is hardly useful code :)

Do we want anything more formal than just a bunch of mails?

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070908/d6fc4a84/attachment.pgp>

From martin-langer at gmx.de  Sat Sep  8 13:45:53 2007
From: martin-langer at gmx.de (Martin Langer)
Date: Sat, 8 Sep 2007 13:45:53 +0200
Subject: Propose for relicensing fwcutter under BSD
In-Reply-To: <ea7b9c170709080015s544e21c6q159ab2c7e628f2a5@mail.gmail.com>
References: <ea7b9c170709080015s544e21c6q159ab2c7e628f2a5@mail.gmail.com>
Message-ID: <20070908114553.GA3527@tuba>

On Sat, Sep 08, 2007 at 03:15:17PM +0800, Sepherosa Ziehau wrote:
> Hi all,
> 
> Would you consider relicense fwcutter under BSDL?  The driver in
> DragonFlyBSD depends on the firmware files produced by fwcutter and I
> don't want to "reinvent the wheel", so I want to put it into our base
> system.
> 
> I think Johannes and Michael are OK with it.

Same here. No objections from my side.

Have fun!

Martin


From mb at bu3sch.de  Sat Sep  8 16:30:02 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 8 Sep 2007 16:30:02 +0200
Subject: Propose for relicensing fwcutter under BSD
In-Reply-To: <20070908114553.GA3527@tuba>
References: <ea7b9c170709080015s544e21c6q159ab2c7e628f2a5@mail.gmail.com>
	<20070908114553.GA3527@tuba>
Message-ID: <200709081630.03005.mb@bu3sch.de>

On Saturday 08 September 2007 13:45:53 Martin Langer wrote:
> On Sat, Sep 08, 2007 at 03:15:17PM +0800, Sepherosa Ziehau wrote:
> > Hi all,
> > 
> > Would you consider relicense fwcutter under BSDL?  The driver in
> > DragonFlyBSD depends on the firmware files produced by fwcutter and I
> > don't want to "reinvent the wheel", so I want to put it into our base
> > system.
> > 
> > I think Johannes and Michael are OK with it.
> 
> Same here. No objections from my side.

Ok, so I'll patch it.
Sepherosa, is something like the following OK?

 *   Redistribution and use in source and binary forms, with or without
 *   modification, are permitted provided that the following conditions
 *   are met:
 *
 *     1. Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *     2. Redistributions in binary form must reproduce the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer in the documentation and/or other materials provided
 *        with the distribution.
 *
 *   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *   DISCLAIMED. IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY
 *   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 *   OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *   EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-- 
Greetings Michael.


From guillermo at geryon.com.ar  Sat Sep  8 17:16:11 2007
From: guillermo at geryon.com.ar (Guillermo Javier Nardoni)
Date: Sat, 8 Sep 2007 12:16:11 -0300
Subject: BCM43xx and WRT54GL :'(
Message-ID: <20070908122639.5360D18F498@mail.geryon.com.ar>

 
 Hello everyone, my name is Guillermo and i'm from Argentina.-
A few weeks ago, i bought a Linksys WRT54GL v1.1, so it 
includes a bcm4306 wifi card.-
I tried to build kamikaze from scratch with 2.6 kernel but wifi doen't
Work at all, so I extracted the kernel source from your svn tree
I put the source as a kamikaze kernel module package and it compiles fine
No error, but when i load the module into the wrt
it loads fine, no error, but it still doen't work yet.
I also tried to extract and put the firmware from apsta.o and wl.o 
Into /lib/firmware\`uname -r` and many others paths without no
Success.-

So could you help me please, thanks a lot.-


Regards

Guillermo Nardoni
Argentina.-



From larry.finger at lwfinger.net  Sat Sep  8 17:20:15 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 08 Sep 2007 10:20:15 -0500
Subject: BCM43xx and WRT54GL :'(
In-Reply-To: <20070908122639.5360D18F498@mail.geryon.com.ar>
References: <20070908122639.5360D18F498@mail.geryon.com.ar>
Message-ID: <46E2BDAF.6060707@lwfinger.net>

Guillermo Javier Nardoni wrote:
>  
>  Hello everyone, my name is Guillermo and i'm from Argentina.-
> A few weeks ago, i bought a Linksys WRT54GL v1.1, so it 
> includes a bcm4306 wifi card.-
> I tried to build kamikaze from scratch with 2.6 kernel but wifi doen't
> Work at all, so I extracted the kernel source from your svn tree
> I put the source as a kamikaze kernel module package and it compiles fine
> No error, but when i load the module into the wrt
> it loads fine, no error, but it still doen't work yet.
> I also tried to extract and put the firmware from apsta.o and wl.o 
> Into /lib/firmware\`uname -r` and many others paths without no
> Success.-
> 
> So could you help me please, thanks a lot.-

Do you get any logs? Are they secret?


From guillermo at geryon.com.ar  Sat Sep  8 17:24:01 2007
From: guillermo at geryon.com.ar (Guillermo Javier Nardoni)
Date: Sat, 8 Sep 2007 12:24:01 -0300
Subject: BCM4306 and Virtual AP
Message-ID: <20070908123428.41E9018F498@mail.geryon.com.ar>

Hi guys, once again... Me.....

I'm wandering if BCM43xx actually does support for virtual AP, 
What i mean for VAP is to bradcast more than one SSID being in AP mode or
AdHoc mode
For example: PUBLIC_SSID for those who want to connect to the AP and
PRIVATE_SSID (for
nodes links with Encryption)
According to dd-wrt it does actually support.
I've tried showing the SSID of one of them and hidding the other one but i
only see and
Can connect just with one. 
Is about driver issues?, am i doing something wrong?

Thanks again.-

Regards
Guillermo Nardoni



From comphappy at gmail.com  Sat Sep  8 23:31:17 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sat, 8 Sep 2007 14:31:17 -0700
Subject: BCM4306 totally exausted
In-Reply-To: <20070908135937.180EE18F498@mail.geryon.com.ar>
References: <b2d05de20708261602q6b20b2aeqf4b0bb7174f9f928@mail.gmail.com>
	<20070908135937.180EE18F498@mail.geryon.com.ar>
Message-ID: <b2d05de20709081431w59e696e6q442b50f7897a8d56@mail.gmail.com>

Please keep in the mailing list no Private conversations. Made some
responces bellow.

On 9/8/07, Guillermo Javier Nardoni <guillermo at geryon.com.ar> wrote:
>
> > -----Mensaje original-----
> > De: bcm43xx-dev-bounces at lists.berlios.de
> > [mailto:bcm43xx-dev-bounces at lists.berlios.de] En nombre de
> > Brennan Ashton
> > Enviado el: Domingo, 26 de Agosto de 2007 08:02 p.m.
> > Para: gjnardoni at yahoo.com.ar
> > CC: bcm43xx-dev at lists.berlios.de
> > Asunto: Re: BCM4306 totally exausted
> >
> > On 8/26/07, Guillermo Javier Nardoni <guillermo at geryon.com.ar> wrote:
> > > Hi everyone, this is my first time here so i'll give a
> > brief introducing..
> > > My name is Guillermo and i'm from Argentina, i am in a
> > wireless team
> > > group building wifi comunnities but... A few days ago we bought
> > > 2 linksys wrt54gl v1.1 s/N: CL7B... Wich means it is a broadcom
> > > chipset
> > > based.-
> > > Well, we want to put openwrt with 2.6 kernel but it is doesn't have
> > > wireless support yet due to Broadcom.
> > > So, i have searched and readed and watch some tv show too but it is
> > > still doesn't work.
> > > Does anybody tried to compile the driver with linux 2.6
> > vanilla kernel
> > > and work properlly?
> > > De wrt54gl chipset revision is 02
> >
> > Could you post the result of
> >
> > uname -r
> 2.6.22
>
> > ispci | grep Broadcom
> Don't work, i've installed the package from openwrt
> But it shows nothing.... (empty output when i type "lspci -v")
that is lspci with an L not an i, it is a core PCI util so you should
have it, if nothing shows up it would have to be on a different buss?
>
> > dmesg | grep bcm
> When i type dmesg | grep bcm (nothing greped)
> So i copied this...
>
> root at OpenWrt:/lib/modules/2.6.22# clear
> root at OpenWrt:/lib/modules/2.6.22# insmod bcm43xx-mac80211.ko; dmesg
> Linux version 2.6.22 (nbd at ds10) (gcc version 4.1.2) #3 Thu Jul 26 18:00:50
> CEST 2007
> CPU revision is: 00029008
> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x0E, vendor 0x4243)
> ssb: Core 1 found: Fast Ethernet (cc 0x806, rev 0x09, vendor 0x4243)
> ssb: Core 2 found: MIPS 3302 (cc 0x816, rev 0x06, vendor 0x4243)
> ssb: Core 3 found: USB 1.1 Host (cc 0x817, rev 0x02, vendor 0x4243)
> ssb: Core 4 found: MEMC SDRAM (cc 0x80F, rev 0x01, vendor 0x4243)
> ssb: Core 5 found: IEEE 802.11 (cc 0x812, rev 0x09, vendor 0x4243)
> ssb: Core 6 found: Roboswitch (cc 0x81C, rev 0x02, vendor 0x4243)
> ssb: Initializing MIPS core...
> ssb: set_irq: core 0x0806, irq 2 => 2
> ssb: set_irq: core 0x0817, irq 3 => 3
> ssb: set_irq: core 0x0812, irq 4 => 4
> ssb: Sonics Silicon Backplane found at address 0x18000000
> Determined physical RAM map:
>  memory: 01000000 @ 00000000 (usable)
> Initrd not found or empty - disabling initrd
> On node 0 totalpages: 4096
>   Normal zone: 32 pages used for memmap
>   Normal zone: 0 pages reserved
>   Normal zone: 4064 pages, LIFO batch:0
> Built 1 zonelists.  Total pages: 4064
> Kernel command line: root=/dev/mtdblock2 rootfstype=squashfs,jffs2
> init=/etc/preinit noinitrd console=ttyS0,115200
> Primary instruction cache 16kB, physically tagged, 2-way, linesize 16 bytes.
> Primary data cache 8kB, 2-way, linesize 16 bytes.
> Synthesized TLB refill handler (20 instructions).
> Synthesized TLB load handler fastpath (32 instructions).
> Synthesized TLB store handler fastpath (31 instructions).
> Synthesized TLB modify handler fastpath (30 instructions).
> PID hash table entries: 64 (order: 6, 256 bytes)
> Using 100.000 MHz high precision timer.
> Dentry cache hash table entries: 2048 (order: 1, 8192 bytes)
> Inode-cache hash table entries: 1024 (order: 0, 4096 bytes)
> Memory: 13628k/16384k available (2030k kernel code, 2756k reserved, 297k
> data, 120k init, 0k highmem)
> Calibrating delay loop... 199.16 BogoMIPS (lpj=398336)
> Mount-cache hash table entries: 512
> NET: Registered protocol family 16
> Time: MIPS clocksource has been installed.
> NET: Registered protocol family 2
> IP route cache hash table entries: 1024 (order: 0, 4096 bytes)
> TCP established hash table entries: 512 (order: 0, 4096 bytes)
> TCP bind hash table entries: 512 (order: -1, 2048 bytes)
> TCP: Hash tables configured (established 512 bind 512)
> TCP reno registered
> squashfs: version 3.0 (2006/03/15) Phillip Lougher
> Registering mini_fo version $Id$
> JFFS2 version 2.2. (NAND) C 2001-2006 Red Hat, Inc.
> io scheduler noop registered
> io scheduler deadline registered (default)
> Serial: 8250/16550 driver $Revision: 1.90 $ 2 ports, IRQ sharing enabled
> serial8250: ttyS0 at MMIO 0x0 (irq = 3) is a 16550A
> serial8250: ttyS1 at MMIO 0x0 (irq = 3) is a 16550A
> b44.c:v1.01 (Jun 16, 2006)
> eth0: Broadcom 10/100BaseT Ethernet 00:1a:70:6a:d8:c8
> flash init: 0x1c000000 0x02000000
> Physically mapped flash: Found 1 x16 devices at 0x0 in 16-bit bank
> Physically mapped flash: Found an alias at 0x400000 for the chip at 0x0
> Physically mapped flash: Found an alias at 0x800000 for the chip at 0x0
> Physically mapped flash: Found an alias at 0xc00000 for the chip at 0x0
> Physically mapped flash: Found an alias at 0x1000000 for the chip at 0x0
> Physically mapped flash: Found an alias at 0x1400000 for the chip at 0x0
> Physically mapped flash: Found an alias at 0x1800000 for the chip at 0x0
> Physically mapped flash: Found an alias at 0x1c00000 for the chip at 0x0
>  Amd/Fujitsu Extended Query Table at 0x0040
>   Newer Samsung flash detected, should be compatibile with Amd/Fujitsu.
> number of CFI chips: 1
> cfi_cmdset_0002: Disabling erase-suspend-program due to code brokenness.
> Flash device: 0x400000 at 0x1fc00000
> bootloader size: 262144
> Creating 4 MTD partitions on "Physically mapped flash":
> 0x00000000-0x00040000 : "cfe"
> 0x00040000-0x003f0000 : "linux"
> 0x000f8000-0x003f0000 : "rootfs"
> mtd: partition "rootfs" doesn't start on an erase block boundary -- force
> read-only
> 0x00200000-0x003f0000 : "rootfs_data"
> 0x003f0000-0x00400000 : "nvram"
> nf_conntrack version 0.5.0 (128 buckets, 1024 max)
> ip_tables: (C) 2000-2006 Netfilter Core Team
> TCP vegas registered
> NET: Registered protocol family 1
> NET: Registered protocol family 17
> 802.1Q VLAN Support v1.8 Ben Greear <greearb at candelatech.com>
> All bugs added by David S. Miller <davem at redhat.com>
> VFS: Mounted root (squashfs filesystem) readonly.
> Freeing unused kernel memory: 120k freed
> Warning: unable to open an initial console.
> Algorithmics/MIPS FPU Emulator v1.5
> diag: Detected 'Linksys WRT54G/GS/GL'
> b44: eth0: Link is up at 100 Mbps, full duplex.
> b44: eth0: Flow control is off for TX and off for RX.
> Probing device eth0: found!
> mini_fo: using base directory: /
> mini_fo: using storage directory: /jffs
> b44: eth0: Link is up at 100 Mbps, full duplex.
> b44: eth0: Flow control is off for TX and off for RX.
> BFL_ENETADM not set in boardflags. Use force=1 to ignore.
> PPP generic driver version 2.4.2
> wlan: 0.8.4.2 (svn r2568)
> device eth0.0 entered promiscuous mode
> eth0.0: dev_set_promiscuity(master, 1)
> device eth0 entered promiscuous mode
> eth0.0: add 01:00:5e:00:00:01 mcast address to master interface
> br-lan: port 1(eth0.0) entering learning state
> br-lan: topology change detected, propagating
> br-lan: port 1(eth0.0) entering forwarding state
> ath_hal: module license 'Proprietary' taints kernel.
> ath_hal: 0.9.30.13 (AR5210, AR5211, AR5212, AR5416, RF5111, RF5112, RF2413,
> RF5413, RF2133, REGOPS_FUNC)
> ath_rate_minstrel: Minstrel automatic rate control algorithm 1.2 (svn r2568)
> ath_rate_minstrel: look around rate set to 10%
> ath_rate_minstrel: EWMA rolloff level set to 75%
> ath_rate_minstrel: max segment size in the mrr set to 6000 us
> wlan: mac acl policy registered
> ath_pci: 0.9.4.5 (svn r2568)
> eth0.1: add 01:00:5e:00:00:01 mcast address to master interface
> eth0.0: received packet with  own address as source address
> eth0.0: received packet with  own address as source address
> bcm43xx_mac80211: Broadcom 5352 WLAN found
> bcm43xx_mac80211: Found PHY: Analog 2, Type 2, Revision 7
> bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
> bcm43xx_mac80211: Radio turned off
Why is the radio off?
> wmaster0: Selected rate control algorithm 'simple'
> wmaster0: Failed to initialize wep
> bcm43xx_mac80211: probe of ssb0:3 failed with error -12
>
>
> > have you used fwcutter yet, if so what version
> >
> > I believe for that revision you have to use b43-legacy or
> > bcm43xx depending on your kernel version, however i have been
> > out of town during most of the naming changes and am just catching up.
> >
> > --
> > Brennan Ashton
> > Bellingham, Washington
> >
> > "The box said, 'Requires Windows 98 or better'. So I installed Linux"
> > _______________________________________________
> > Bcm43xx-dev mailing list
> > Bcm43xx-dev at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
> >
>
>


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows XP or better'. So I installed Linux"


From sepherosa at gmail.com  Sun Sep  9 05:23:28 2007
From: sepherosa at gmail.com (Sepherosa Ziehau)
Date: Sun, 9 Sep 2007 11:23:28 +0800
Subject: Propose for relicensing fwcutter under BSD
In-Reply-To: <200709081630.03005.mb@bu3sch.de>
References: <ea7b9c170709080015s544e21c6q159ab2c7e628f2a5@mail.gmail.com>
	<20070908114553.GA3527@tuba> <200709081630.03005.mb@bu3sch.de>
Message-ID: <ea7b9c170709082023h437ae68fkab70014cdae87c93@mail.gmail.com>

On 9/8/07, Michael Buesch <mb at bu3sch.de> wrote:
> On Saturday 08 September 2007 13:45:53 Martin Langer wrote:
> > On Sat, Sep 08, 2007 at 03:15:17PM +0800, Sepherosa Ziehau wrote:
> > > Hi all,
> > >
> > > Would you consider relicense fwcutter under BSDL?  The driver in
> > > DragonFlyBSD depends on the firmware files produced by fwcutter and I
> > > don't want to "reinvent the wheel", so I want to put it into our base
> > > system.
> > >
> > > I think Johannes and Michael are OK with it.
> >
> > Same here. No objections from my side.
>
> Ok, so I'll patch it.
> Sepherosa, is something like the following OK?

Yah, thanks!

>
>  *   Redistribution and use in source and binary forms, with or without
>  *   modification, are permitted provided that the following conditions
>  *   are met:
>  *
>  *     1. Redistributions of source code must retain the above copyright
>  *        notice, this list of conditions and the following disclaimer.
>  *     2. Redistributions in binary form must reproduce the above
>  *        copyright notice, this list of conditions and the following
>  *        disclaimer in the documentation and/or other materials provided
>  *        with the distribution.
>  *
>  *   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
>  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
>  *   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
>  *   DISCLAIMED. IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY
>  *   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
>  *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
>  *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
>  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
>  *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
>  *   OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
>  *   EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
>
> --
> Greetings Michael.
>


-- 
Live Free or Die


From proski at gnu.org  Sun Sep  9 06:26:19 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sun, 09 Sep 2007 00:26:19 -0400
Subject: [PATCH, fwcutter] add support for DragonFlyBSD
In-Reply-To: <ea7b9c170709080008s2ca6322djff501a0f8b1405e5@mail.gmail.com>
References: <ea7b9c170709080008s2ca6322djff501a0f8b1405e5@mail.gmail.com>
Message-ID: <1189311979.4809.19.camel@dv>

Hello!

On Sat, 2007-09-08 at 15:08 +0800, Sepherosa Ziehau wrote:

> Following patch make b43-fwcutter work on DragonFlyBSD:
> http://leaf.dragonflybsd.org/~sephe/fwcutter.diff
> 
> Please review it.  If you folks think it is OK, please commit it to
> your svn repos.
> It was reviewed by johill and mb on #bcm-specs

I suggest that you remove all references to DragonFlyBSD and use some
symbol that is defined on all BSD systems.

This way, the program will compile and work with no changes on all BSD
systems as long as the headers are compatible.  And if there are any
incompatibilities, they would likely be minor and fixable without adding
too many ifdefs.

The patch as it is just encourages adding more preprocessor conditionals
if the program is ported to more OSes.

Also, I suggest that you reconsider calling the firmware directories
"v3" and "v4".  Such names are too generic and don't provide information
about the hardware, unlike "b43" and "b43legacy".  It would be easier if
b43-fwcutter just worked the same way on any OS.  You may prefer to do
renaming in a wrapper that installs the firmware.

I would put definitions for bswap_16 and bswap_32 immediately below
"#include <sys/endian.h>", but it's a mater of taste.  Also, I would use
definitions with arguments, as they are more robust and would indicate
use with a wrong number of arguments.

-- 
Regards,
Pavel Roskin



From larry.finger at lwfinger.net  Sun Sep  9 07:39:43 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 09 Sep 2007 00:39:43 -0500
Subject: BCM4306 totally exausted
In-Reply-To: <b2d05de20709081431w59e696e6q442b50f7897a8d56@mail.gmail.com>
References: <b2d05de20708261602q6b20b2aeqf4b0bb7174f9f928@mail.gmail.com>	<20070908135937.180EE18F498@mail.geryon.com.ar>
	<b2d05de20709081431w59e696e6q442b50f7897a8d56@mail.gmail.com>
Message-ID: <46E3871F.7040301@lwfinger.net>

Brennan Ashton wrote:
> On 9/8/07, Guillermo Javier Nardoni <guillermo at geryon.com.ar> wrote:
>> 2.6.22

You should get the 2.6.23 kernel from wireless-dev. It will have the b43 driver that is similar to
bcm43xx-mac80211, but with a number of improvements.

>> root at OpenWrt:/lib/modules/2.6.22# clear
>> root at OpenWrt:/lib/modules/2.6.22# insmod bcm43xx-mac80211.ko; dmesg
>> Linux version 2.6.22 (nbd at ds10) (gcc version 4.1.2) #3 Thu Jul 26 18:00:50
>> CEST 2007
>> CPU revision is: 00029008
>> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x0E, vendor 0x4243)
>> ssb: Core 1 found: Fast Ethernet (cc 0x806, rev 0x09, vendor 0x4243)
>> ssb: Core 2 found: MIPS 3302 (cc 0x816, rev 0x06, vendor 0x4243)
>> ssb: Core 3 found: USB 1.1 Host (cc 0x817, rev 0x02, vendor 0x4243)
>> ssb: Core 4 found: MEMC SDRAM (cc 0x80F, rev 0x01, vendor 0x4243)
>> ssb: Core 5 found: IEEE 802.11 (cc 0x812, rev 0x09, vendor 0x4243)
>> ssb: Core 6 found: Roboswitch (cc 0x81C, rev 0x02, vendor 0x4243)
>> ssb: Initializing MIPS core...
>> ssb: set_irq: core 0x0806, irq 2 => 2
>> ssb: set_irq: core 0x0817, irq 3 => 3
>> ssb: set_irq: core 0x0812, irq 4 => 4
>> ssb: Sonics Silicon Backplane found at address 0x18000000

..snip..

>> bcm43xx_mac80211: Broadcom 5352 WLAN found
>> bcm43xx_mac80211: Found PHY: Analog 2, Type 2, Revision 7
>> bcm43xx_mac80211: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
>> bcm43xx_mac80211: Radio turned off
> Why is the radio off?

The driver always turns the radio off during initialization and turns it on during the ifup step.
This is normal.

>> wmaster0: Selected rate control algorithm 'simple'
>> wmaster0: Failed to initialize wep
>> bcm43xx_mac80211: probe of ssb0:3 failed with error -12

I don't know what this means. Michael?

>>> I believe for that revision you have to use b43-legacy or
>>> bcm43xx depending on your kernel version, however i have been
>>> out of town during most of the naming changes and am just catching up.

No, a rev 9 802.11 core uses b43. Only chips with a rev < 5 use b43legacy.

When you change to b43, you will need to use b43-fwcutter. The firmware files have different names
and occur in different directories than for bcm43xx varieties.

Larry



From sepherosa at gmail.com  Sun Sep  9 07:46:20 2007
From: sepherosa at gmail.com (Sepherosa Ziehau)
Date: Sun, 9 Sep 2007 13:46:20 +0800
Subject: [PATCH, fwcutter] add support for DragonFlyBSD
In-Reply-To: <1189311979.4809.19.camel@dv>
References: <ea7b9c170709080008s2ca6322djff501a0f8b1405e5@mail.gmail.com>
	<1189311979.4809.19.camel@dv>
Message-ID: <ea7b9c170709082246w14a8253fr1102f48a5130e09e@mail.gmail.com>

On 9/9/07, Pavel Roskin <proski at gnu.org> wrote:
> Hello!

Hi,

>
> On Sat, 2007-09-08 at 15:08 +0800, Sepherosa Ziehau wrote:
>
> > Following patch make b43-fwcutter work on DragonFlyBSD:
> > http://leaf.dragonflybsd.org/~sephe/fwcutter.diff
> >
> > Please review it.  If you folks think it is OK, please commit it to
> > your svn repos.
> > It was reviewed by johill and mb on #bcm-specs
>
> I suggest that you remove all references to DragonFlyBSD and use some
> symbol that is defined on all BSD systems.

I follow the way that wpa_supplicant/hostapd does.  And in the current
way I don't need to change Makefile.  'ifdef' in makefile is quite
'make' dependent.  And each BSD seems to have different firmware
loading mechanism, so I don't know whether they would port fwcutter
even if they took the dfly driver.

>
> This way, the program will compile and work with no changes on all BSD
> systems as long as the headers are compatible.  And if there are any
> incompatibilities, they would likely be minor and fixable without adding
> too many ifdefs.
>
> The patch as it is just encourages adding more preprocessor conditionals
> if the program is ported to more OSes.
>
> Also, I suggest that you reconsider calling the firmware directories
> "v3" and "v4".  Such names are too generic and don't provide information

There will be /etc/firmware/bwi directory, v3/ and v4/ will be put in
there.  I think it functions almost as same as b43/b43legacy directory
layout, and v3 firmware seems to work for non-legacy broadcom chips
too.

> about the hardware, unlike "b43" and "b43legacy".  It would be easier if
> b43-fwcutter just worked the same way on any OS.  You may prefer to do
> renaming in a wrapper that installs the firmware.
>
> I would put definitions for bswap_16 and bswap_32 immediately below
> "#include <sys/endian.h>", but it's a mater of taste.  Also, I would use
> definitions with arguments, as they are more robust and would indicate
> use with a wrong number of arguments.

Ah, thanks for the suggestion.  I just did a quick hack :)

Updated patch is at:
http://leaf.dragonflybsd.org/~sephe/fwcutter1.diff

Please review it, thanks.

Best Regards,
sephe

-- 
Live Free or Die


From comphappy at gmail.com  Sun Sep  9 08:46:07 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sat, 8 Sep 2007 22:46:07 -0800
Subject: BCM4306 totally exausted
In-Reply-To: <46E3871F.7040301@lwfinger.net>
References: <b2d05de20708261602q6b20b2aeqf4b0bb7174f9f928@mail.gmail.com>
	<20070908135937.180EE18F498@mail.geryon.com.ar>
	<b2d05de20709081431w59e696e6q442b50f7897a8d56@mail.gmail.com>
	<46E3871F.7040301@lwfinger.net>
Message-ID: <b2d05de20709082346x6e363032s2b7cd8de050bf273@mail.gmail.com>

On 9/8/07, Larry Finger <larry.finger at lwfinger.net> wrote:
> Brennan Ashton wrote:
> > On 9/8/07, Guillermo Javier Nardoni <guillermo at geryon.com.ar> wrote:
<<snip>>
> >>> I believe for that revision you have to use b43-legacy or
> >>> bcm43xx depending on your kernel version, however i have been
> >>> out of town during most of the naming changes and am just catching up.
>
> No, a rev 9 802.11 core uses b43. Only chips with a rev < 5 use b43legacy.
>
Yes, when i said that i was replying to the origional post he made
where he said, "
De wrt54gl chipset revision is 02" I did not yet have this info ">>
ssb: Core 5 found: IEEE 802.11 (cc 0x812, rev 0x09, vendor 0x4243)"
which is why i asked for the output of our standard base info commands
(uname lspci dmesg etc)
> When you change to b43, you will need to use b43-fwcutter. The firmware files have different names
> and occur in different directories than for bcm43xx varieties.
>
> Larry
>
>


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows XP or better'. So I installed Linux"


From mb at bu3sch.de  Sun Sep  9 13:02:25 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 9 Sep 2007 13:02:25 +0200
Subject: BCM4306 totally exausted
In-Reply-To: <46E3871F.7040301@lwfinger.net>
References: <b2d05de20708261602q6b20b2aeqf4b0bb7174f9f928@mail.gmail.com>
	<b2d05de20709081431w59e696e6q442b50f7897a8d56@mail.gmail.com>
	<46E3871F.7040301@lwfinger.net>
Message-ID: <200709091302.26178.mb@bu3sch.de>

On Sunday 09 September 2007 07:39:43 Larry Finger wrote:
> >> wmaster0: Selected rate control algorithm 'simple'
> >> wmaster0: Failed to initialize wep
> >> bcm43xx_mac80211: probe of ssb0:3 failed with error -12
> 
> I don't know what this means. Michael?

-ENOMEM


-- 
Greetings Michael.


From mb at bu3sch.de  Sun Sep  9 13:53:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 9 Sep 2007 13:53:51 +0200
Subject: [PATCH] b43: Simplify and cleanup debugfs infrastructure
Message-ID: <200709091353.52002.mb@bu3sch.de>

This is a major cleanup and simplification of the debugfs
infrastructure. All the debugfs related FS handling code (copy_*_user, etc...)
and the locking is handled in common functions. The debugging implementation
files only have to care about their actual job anymore.
This shrinks the function size.

A few macros were also added to simplify adding new files.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>

Index: wireless-dev/drivers/net/wireless/b43/debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/debugfs.c	2007-09-08 23:56:32.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/debugfs.c	2007-09-09 04:24:14.000000000 +0200
@@ -4,7 +4,7 @@
 
   debugfs driver debugging code
 
-  Copyright (c) 2005 Michael Buesch <mb at bu3sch.de>
+  Copyright (c) 2005-2007 Michael Buesch <mb at bu3sch.de>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -37,308 +37,155 @@
 #include "pio.h"
 #include "xmit.h"
 
-#define REALLY_BIG_BUFFER_SIZE	(1024*256)
 
-static struct b43_debugfs fs;
-static char big_buffer[1024 * 256];
-static DEFINE_MUTEX(big_buffer_mutex);
+/* The root directory. */
+struct dentry *rootdir;
 
-static ssize_t write_file_dummy(struct file *file, const char __user * buf,
-				size_t count, loff_t * ppos)
-{
-	return count;
-}
+struct b43_debugfs_fops {
+	ssize_t (*read)(struct b43_wldev *dev, char *buf, size_t bufsize);
+	int (*write)(struct b43_wldev *dev, const char *buf, size_t count);
+	struct file_operations fops;
+	/* Offset of struct b43_dfs_file in struct b43_dfsentry */
+	size_t file_struct_offset;
+	/* Take wl->irq_lock before calling read/write? */
+	bool take_irqlock;
+};
 
-static int open_file_generic(struct inode *inode, struct file *file)
+static inline
+struct b43_dfs_file * fops_to_dfs_file(struct b43_wldev *dev,
+				       const struct b43_debugfs_fops *dfops)
 {
-	file->private_data = inode->i_private;
-	return 0;
+	void *p;
+
+	p = dev->dfsentry;
+	p += dfops->file_struct_offset;
+
+	return p;
 }
 
-#define fappend(fmt, x...)	pos += snprintf(buf + pos, len - pos, fmt , ##x)
 
-static ssize_t drvinfo_read_file(struct file *file, char __user * userbuf,
-				 size_t count, loff_t * ppos)
+#define fappend(fmt, x...)	\
+	do {							\
+		if (bufsize - count)				\
+			count += snprintf(buf + count,		\
+					  bufsize - count,	\
+					  fmt , ##x);		\
+		else						\
+			printk(KERN_ERR "b43: fappend overflow\n"); \
+	} while (0)
+
+
+/* wl->irq_lock is locked */
+ssize_t tsf_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-
-	mutex_lock(&big_buffer_mutex);
-	/* This is where the information is written to the "driver" file */
-	fappend(KBUILD_MODNAME " driver\n");
-	fappend("Compiled at: %s %s\n", __DATE__, __TIME__);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
-}
-
-static ssize_t tsf_read_file(struct file *file, char __user * userbuf,
-			     size_t count, loff_t * ppos)
-{
-	struct b43_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 	u64 tsf;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_STARTED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
 	b43_tsf_read(dev, &tsf);
 	fappend("0x%08x%08x\n",
 		(unsigned int)((tsf & 0xFFFFFFFF00000000ULL) >> 32),
 		(unsigned int)(tsf & 0xFFFFFFFFULL));
 
-      out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return count;
 }
 
-static ssize_t tsf_write_file(struct file *file, const char __user * user_buf,
-			      size_t count, loff_t * ppos)
+/* wl->irq_lock is locked */
+int tsf_write_file(struct b43_wldev *dev, const char *buf, size_t count)
 {
-	struct b43_wldev *dev = file->private_data;
-	char *buf = big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags;
 	u64 tsf;
 
-	mutex_lock(&big_buffer_mutex);
-	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-		res = -EFAULT;
-		goto out_unlock_bb;
-	}
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_STARTED) {
-		b43err(dev->wl, "debugfs: Board not initialized.\n");
-		res = -EFAULT;
-		goto out_unlock;
-	}
-	if (sscanf(buf, "%llu", (unsigned long long *)(&tsf)) != 1) {
-		b43err(dev->wl, "debugfs: invalid values for \"tsf\"\n");
-		res = -EINVAL;
-		goto out_unlock;
-	}
+	if (sscanf(buf, "%llu", (unsigned long long *)(&tsf)) != 1)
+		return -EINVAL;
 	b43_tsf_write(dev, tsf);
-	mmiowb();
-	res = buf_size;
 
-      out_unlock:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-      out_unlock_bb:
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return 0;
 }
 
-static ssize_t ucode_regs_read_file(struct file *file, char __user * userbuf,
-				    size_t count, loff_t * ppos)
+/* wl->irq_lock is locked */
+ssize_t ucode_regs_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 	int i;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_INITIALIZED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
-
 	for (i = 0; i < 64; i++) {
 		fappend("r%d = 0x%04x\n", i,
 			b43_shm_read16(dev, B43_SHM_SCRATCH, i));
 	}
 
-out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return count;
 }
 
-static ssize_t shm_read_file(struct file *file, char __user * userbuf,
-			     size_t count, loff_t * ppos)
+/* wl->irq_lock is locked */
+ssize_t shm_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	u8 *buf = big_buffer;
-	__le16 *le16buf = (__le16*)big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 	int i;
 	u16 tmp;
-
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_INITIALIZED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
+	__le16 *le16buf = (__le16 *)buf;
 
 	for (i = 0; i < 0x1000; i++) {
+		if (bufsize <= 0)
+			break;
 		tmp = b43_shm_read16(dev, B43_SHM_SHARED, 2 * i);
 		le16buf[i] = cpu_to_le16(tmp);
-		pos += sizeof(tmp);
+		count += sizeof(tmp);
+		bufsize -= sizeof(tmp);
 	}
 
-out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return count;
 }
 
-static ssize_t txstat_read_file(struct file *file, char __user * userbuf,
-				size_t count, loff_t * ppos)
+ssize_t txstat_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43_wldev *dev = file->private_data;
-	struct b43_dfsentry *e = dev->dfsentry;
-	struct b43_txstatus_log *log = &e->txstatlog;
+	struct b43_txstatus_log *log = &dev->dfsentry->txstatlog;
+	ssize_t count = 0;
 	unsigned long flags;
-	char *buf = log->printbuf;
-	const size_t len = ARRAY_SIZE(log->printbuf);
-	size_t pos = 0;
-	ssize_t res;
 	int i, idx;
 	struct b43_txstatus *stat;
 
-	mutex_lock(&big_buffer_mutex);
 	spin_lock_irqsave(&log->lock, flags);
-	if (!log->printing) {
-		log->printing = 1;
-		fappend("b43 TX status reports:\n\n"
-			"index | cookie | seq | phy_stat | frame_count | "
-			"rts_count | supp_reason | pm_indicated | "
-			"intermediate | for_ampdu | acked\n" "---\n");
-		i = log->end + 1;
-		idx = 0;
-		while (1) {
-			if (log->end < 0) {
-				fappend("Nothing transmitted, yet\n");
-				break;
-			}
-			if (i == B43_NR_LOGGED_TXSTATUS)
-				i = 0;
-			stat = &(log->log[i]);
-			if (stat->cookie) {
-				fappend("%03d | "
-					"0x%04X | 0x%04X | 0x%02X | "
-					"0x%X | 0x%X | "
-					"%u | %u | "
-					"%u | %u | %u\n",
-					idx,
-					stat->cookie, stat->seq, stat->phy_stat,
-					stat->frame_count, stat->rts_count,
-					stat->supp_reason, stat->pm_indicated,
-					stat->intermediate, stat->for_ampdu,
-					stat->acked);
-				idx++;
-			}
-			if (i == log->end)
-				break;
-			i++;
+	if (log->end < 0) {
+		fappend("Nothing transmitted, yet\n");
+		goto out_unlock;
+	}
+	fappend("b43 TX status reports:\n\n"
+		"index | cookie | seq | phy_stat | frame_count | "
+		"rts_count | supp_reason | pm_indicated | "
+		"intermediate | for_ampdu | acked\n" "---\n");
+	i = log->end + 1;
+	idx = 0;
+	while (1) {
+		if (i == B43_NR_LOGGED_TXSTATUS)
+			i = 0;
+		stat = &(log->log[i]);
+		if (stat->cookie) {
+			fappend("%03d | "
+				"0x%04X | 0x%04X | 0x%02X | "
+				"0x%X | 0x%X | "
+				"%u | %u | "
+				"%u | %u | %u\n",
+				idx,
+				stat->cookie, stat->seq, stat->phy_stat,
+				stat->frame_count, stat->rts_count,
+				stat->supp_reason, stat->pm_indicated,
+				stat->intermediate, stat->for_ampdu,
+				stat->acked);
+			idx++;
 		}
-		log->buf_avail = pos;
+		if (i == log->end)
+			break;
+		i++;
 	}
-	memcpy(big_buffer, buf, min(log->buf_avail, ARRAY_SIZE(big_buffer)));
+out_unlock:
 	spin_unlock_irqrestore(&log->lock, flags);
 
-	res = simple_read_from_buffer(userbuf, count, ppos,
-				      big_buffer, log->buf_avail);
-	if (*ppos == log->buf_avail) {
-		spin_lock_irqsave(&log->lock, flags);
-		log->printing = 0;
-		spin_unlock_irqrestore(&log->lock, flags);
-	}
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
-}
-
-static ssize_t restart_write_file(struct file *file,
-				  const char __user * user_buf, size_t count,
-				  loff_t * ppos)
-{
-	struct b43_wldev *dev = file->private_data;
-	char *buf = big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags;
-
-	mutex_lock(&big_buffer_mutex);
-	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-		res = -EFAULT;
-		goto out_unlock_bb;
-	}
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_INITIALIZED) {
-		b43err(dev->wl, "debugfs: Board not initialized.\n");
-		res = -EFAULT;
-		goto out_unlock;
-	}
-	if (count > 0 && buf[0] == '1') {
-		b43_controller_restart(dev, "manually restarted");
-		res = count;
-	} else
-		res = -EINVAL;
-
-      out_unlock:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-      out_unlock_bb:
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return count;
 }
 
-static ssize_t txpower_g_read_file(struct file *file, char __user * userbuf,
-				   size_t count, loff_t * ppos)
+ssize_t txpower_g_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_STARTED) {
-		fappend("Not initialized\n");
-		goto out;
-	}
 	if (dev->phy.type != B43_PHYTYPE_G) {
 		fappend("Device is not a G-PHY\n");
 		goto out;
@@ -363,45 +210,22 @@ static ssize_t txpower_g_read_file(struc
 	fappend("Enables manual control with Baseband attenuation 5, "
 		"Radio attenuation 4, No TX Mixer Gain, "
 		"No PA Gain 2dB, With PA Gain 3dB.\n");
-
-      out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+out:
+	return count;
 }
 
-static ssize_t txpower_g_write_file(struct file *file,
-				    const char __user * user_buf, size_t count,
-				    loff_t * ppos)
-{
-	struct b43_wldev *dev = file->private_data;
-	char *buf = big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags, phy_flags;
-
-	mutex_lock(&big_buffer_mutex);
-	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-		res = -EFAULT;
-		goto out_unlock_bb;
-	}
-	mutex_lock(&dev->wl->mutex);
+int txpower_g_write_file(struct b43_wldev *dev, const char *buf, size_t count)
+{
+	unsigned long flags;
+	unsigned long phy_flags;
+	int err = 0;
+
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_STARTED) {
-		b43err(dev->wl, "debugfs: Board not initialized.\n");
-		res = -ENODEV;
-		goto out_unlock;
-	}
 	if (dev->phy.type != B43_PHYTYPE_G) {
-		b43err(dev->wl, "debugfs: Device is not a G-PHY\n");
-		res = -ENODEV;
+		err = -ENODEV;
 		goto out_unlock;
 	}
-	if ((buf_size >= 4) && (memcmp(buf, "auto", 4) == 0)) {
+	if ((count >= 4) && (memcmp(buf, "auto", 4) == 0)) {
 		/* Automatic control */
 		dev->phy.manual_txpower_control = 0;
 		b43_phy_xmitpower(dev);
@@ -410,9 +234,7 @@ static ssize_t txpower_g_write_file(stru
 		/* Manual control */
 		if (sscanf(buf, "%d %d %d %d %d", &bbatt, &rfatt,
 			   &txmix, &pa2db, &pa3db) != 5) {
-			b43err(dev->wl,
-			       "debugfs: invalid value for \"tx_power_g\"\n");
-			res = -EINVAL;
+			err = -EINVAL;
 			goto out_unlock;
 		}
 		b43_put_attenuation_into_ranges(dev, &bbatt, &rfatt);
@@ -433,18 +255,27 @@ static ssize_t txpower_g_write_file(stru
 		b43_radio_unlock(dev);
 		b43_phy_unlock(dev, phy_flags);
 	}
-	res = buf_size;
-      out_unlock:
+out_unlock:
 	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-      out_unlock_bb:
-	mutex_unlock(&big_buffer_mutex);
 
-	return res;
+	return err;
 }
 
-static size_t append_lo_table(size_t pos, char *buf, const size_t len,
-			      struct b43_loctl table[B43_NR_BB][B43_NR_RF])
+/* wl->irq_lock is locked */
+int restart_write_file(struct b43_wldev *dev, const char *buf, size_t count)
+{
+	int err = 0;
+
+	if (count > 0 && buf[0] == '1') {
+		b43_controller_restart(dev, "manually restarted");
+	} else
+		err = -EINVAL;
+
+	return err;
+}
+
+static ssize_t append_lo_table(ssize_t count, char *buf, const size_t bufsize,
+			       struct b43_loctl table[B43_NR_BB][B43_NR_RF])
 {
 	unsigned int i, j;
 	struct b43_loctl *ctl;
@@ -460,33 +291,20 @@ static size_t append_lo_table(size_t pos
 		}
 	}
 
-	return pos;
+	return count;
 }
 
-static ssize_t loctls_read_file(struct file *file, char __user *userbuf,
-				size_t count, loff_t *ppos)
+ssize_t loctls_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 	struct b43_txpower_lo_control *lo;
-	unsigned int i;
+	int i, err = 0;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_INITIALIZED) {
-		fappend("Not initialized\n");
-		goto out;
-	}
 	if (dev->phy.type != B43_PHYTYPE_G) {
 		fappend("Device is not a G-PHY\n");
+		err = -ENODEV;
 		goto out;
 	}
-
 	lo = dev->phy.lo_control;
 	fappend("-- Local Oscillator calibration data --\n\n");
 	fappend("Measured: %d,  Rebuild: %d,  HW-power-control: %d\n",
@@ -499,9 +317,9 @@ static ssize_t loctls_read_file(struct f
 		(unsigned int)((lo->power_vector & 0xFFFFFFFF00000000ULL) >> 32),
 		(unsigned int)(lo->power_vector & 0x00000000FFFFFFFFULL));
 	fappend("\nControl table WITH PADMIX:\n");
-	pos = append_lo_table(pos, buf, len, lo->with_padmix);
+	count = append_lo_table(count, buf, bufsize, lo->with_padmix);
 	fappend("\nControl table WITHOUT PADMIX:\n");
-	pos = append_lo_table(pos, buf, len, lo->no_padmix);
+	count = append_lo_table(count, buf, bufsize, lo->no_padmix);
 	fappend("\nUsed RF attenuation values:  Value(WithPadmix flag)\n");
 	for (i = 0; i < lo->rfatt_list.len; i++) {
 		fappend("%u(%d), ",
@@ -517,59 +335,161 @@ static ssize_t loctls_read_file(struct f
 	fappend("\n");
 
 out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return err ? err : count;
 }
 
 #undef fappend
 
-static struct file_operations drvinfo_fops = {
-	.read = drvinfo_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
+static int b43_debugfs_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
 
-static struct file_operations tsf_fops = {
-	.read = tsf_read_file,
-	.write = tsf_write_file,
-	.open = open_file_generic,
-};
+static ssize_t b43_debugfs_read(struct file *file, char __user *userbuf,
+				size_t count, loff_t *ppos)
+{
+	struct b43_wldev *dev;
+	struct b43_debugfs_fops *dfops;
+	struct b43_dfs_file *dfile;
+	ssize_t ret;
+	char *buf;
+	const size_t bufsize = 1024 * 128;
+	const size_t buforder = get_order(bufsize);
+	int err = 0;
+
+	if (!count)
+		return 0;
+	dev = file->private_data;
+	if (!dev)
+		return -ENODEV;
 
-static struct file_operations ucode_regs_fops = {
-	.read = ucode_regs_read_file,
-	.open = open_file_generic,
-};
+	mutex_lock(&dev->wl->mutex);
+	if (b43_status(dev) < B43_STAT_INITIALIZED) {
+		err = -ENODEV;
+		goto out_unlock;
+	}
 
-static struct file_operations shm_fops = {
-	.read = shm_read_file,
-	.open = open_file_generic,
-};
+	dfops = container_of(file->f_op, struct b43_debugfs_fops, fops);
+	if (!dfops->read) {
+		err = -ENOSYS;
+		goto out_unlock;
+	}
+	dfile = fops_to_dfs_file(dev, dfops);
 
-static struct file_operations txstat_fops = {
-	.read = txstat_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
+	if (!dfile->buffer) {
+		buf = (char *)__get_free_pages(GFP_KERNEL, buforder);
+		if (!buf) {
+			err = -ENOMEM;
+			goto out_unlock;
+		}
+		memset(buf, 0, bufsize);
+		if (dfops->take_irqlock) {
+			spin_lock_irq(&dev->wl->irq_lock);
+			ret = dfops->read(dev, buf, bufsize);
+			spin_unlock_irq(&dev->wl->irq_lock);
+		} else
+			ret = dfops->read(dev, buf, bufsize);
+		if (ret <= 0) {
+			free_pages((unsigned long)buf, buforder);
+			err = ret;
+			goto out_unlock;
+		}
+		dfile->data_len = ret;
+		dfile->buffer = buf;
+	}
 
-static struct file_operations txpower_g_fops = {
-	.read = txpower_g_read_file,
-	.write = txpower_g_write_file,
-	.open = open_file_generic,
-};
+	ret = simple_read_from_buffer(userbuf, count, ppos,
+				      dfile->buffer,
+				      dfile->data_len);
+	if (*ppos >= dfile->data_len) {
+		free_pages((unsigned long)dfile->buffer, buforder);
+		dfile->buffer = NULL;
+		dfile->data_len = 0;
+	}
+out_unlock:
+	mutex_unlock(&dev->wl->mutex);
 
-static struct file_operations restart_fops = {
-	.write = restart_write_file,
-	.open = open_file_generic,
-};
+	return err ? err : ret;
+}
 
-static struct file_operations loctls_fops = {
-	.read = loctls_read_file,
-	.open = open_file_generic,
-};
+static ssize_t b43_debugfs_write(struct file *file,
+				 const char __user *userbuf,
+				 size_t count, loff_t *ppos)
+{
+	struct b43_wldev *dev;
+	struct b43_debugfs_fops *dfops;
+	char *buf;
+	int err = 0;
+
+	if (!count)
+		return 0;
+	if (count > PAGE_SIZE)
+		return -E2BIG;
+	dev = file->private_data;
+	if (!dev)
+		return -ENODEV;
+
+	mutex_lock(&dev->wl->mutex);
+	if (b43_status(dev) < B43_STAT_INITIALIZED) {
+		err = -ENODEV;
+		goto out_unlock;
+	}
+
+	dfops = container_of(file->f_op, struct b43_debugfs_fops, fops);
+	if (!dfops->write) {
+		err = -ENOSYS;
+		goto out_unlock;
+	}
+
+	buf = (char *)get_zeroed_page(GFP_KERNEL);
+	if (!buf) {
+		err = -ENOMEM;
+		goto out_unlock;
+	}
+	if (copy_from_user(buf, userbuf, count)) {
+		err = -EFAULT;
+		goto out_freepage;
+	}
+	if (dfops->take_irqlock) {
+		spin_lock_irq(&dev->wl->irq_lock);
+		err = dfops->write(dev, buf, count);
+		spin_unlock_irq(&dev->wl->irq_lock);
+	} else
+		err = dfops->write(dev, buf, count);
+	if (err)
+		goto out_freepage;
+
+out_freepage:
+	free_page((unsigned long)buf);
+out_unlock:
+	mutex_unlock(&dev->wl->mutex);
+
+	return err ? err : count;
+}
+
+
+#define B43_DEBUGFS_FOPS(name, _read, _write, _take_irqlock)	\
+	static struct b43_debugfs_fops fops_##name = {		\
+		.read	= _read,				\
+		.write	= _write,				\
+		.fops	= {					\
+			.open	= b43_debugfs_open,		\
+			.read	= b43_debugfs_read,		\
+			.write	= b43_debugfs_write,		\
+		},						\
+		.file_struct_offset = offsetof(struct b43_dfsentry, \
+					       file_##name),	\
+		.take_irqlock	= _take_irqlock,		\
+	}
+
+B43_DEBUGFS_FOPS(tsf, tsf_read_file, tsf_write_file, 1);
+B43_DEBUGFS_FOPS(ucode_regs, ucode_regs_read_file, NULL, 1);
+B43_DEBUGFS_FOPS(shm, shm_read_file, NULL, 1);
+B43_DEBUGFS_FOPS(txstat, txstat_read_file, NULL, 0);
+B43_DEBUGFS_FOPS(txpower_g, txpower_g_read_file, txpower_g_write_file, 0);
+B43_DEBUGFS_FOPS(restart, NULL, restart_write_file, 1);
+B43_DEBUGFS_FOPS(loctls, loctls_read_file, NULL, 0);
 
 
 int b43_debug(struct b43_wldev *dev, enum b43_dyndbg feature)
@@ -635,7 +555,7 @@ void b43_debugfs_add_device(struct b43_w
 	dev->dfsentry = e;
 
 	snprintf(devdir, sizeof(devdir), "%s", wiphy_name(dev->wl->hw->wiphy));
-	e->subdir = debugfs_create_dir(devdir, fs.root);
+	e->subdir = debugfs_create_dir(devdir, rootdir);
 	if (!e->subdir || IS_ERR(e->subdir)) {
 		if (e->subdir == ERR_PTR(-ENODEV)) {
 			b43dbg(dev->wl, "DebugFS (CONFIG_DEBUG_FS) not "
@@ -650,34 +570,27 @@ void b43_debugfs_add_device(struct b43_w
 		return;
 	}
 
-	e->dentry_tsf = debugfs_create_file("tsf", 0600, e->subdir,
-					    dev, &tsf_fops);
-	if (IS_ERR(e->dentry_tsf))
-		e->dentry_tsf = NULL;
-	e->dentry_ucode_regs = debugfs_create_file("ucode_regs", 0400, e->subdir,
-						   dev, &ucode_regs_fops);
-	if (IS_ERR(e->dentry_ucode_regs))
-		e->dentry_ucode_regs = NULL;
-	e->dentry_shm = debugfs_create_file("shm", 0400, e->subdir,
-					    dev, &shm_fops);
-	if (IS_ERR(e->dentry_shm))
-		e->dentry_shm = NULL;
-	e->dentry_txstat = debugfs_create_file("tx_status", 0400, e->subdir,
-					       dev, &txstat_fops);
-	if (IS_ERR(e->dentry_txstat))
-		e->dentry_txstat = NULL;
-	e->dentry_txpower_g = debugfs_create_file("tx_power_g", 0600, e->subdir,
-						  dev, &txpower_g_fops);
-	if (IS_ERR(e->dentry_txpower_g))
-		e->dentry_txpower_g = NULL;
-	e->dentry_restart = debugfs_create_file("restart", 0200, e->subdir,
-						dev, &restart_fops);
-	if (IS_ERR(e->dentry_restart))
-		e->dentry_restart = NULL;
-	e->dentry_loctls = debugfs_create_file("loctls", 0400, e->subdir,
-					       dev, &loctls_fops);
-	if (IS_ERR(e->dentry_loctls))
-		e->dentry_loctls = NULL;
+#define ADD_FILE(name, mode)	\
+	do {							\
+		struct dentry *d;				\
+		d = debugfs_create_file(__stringify(name),	\
+					mode, e->subdir, dev,	\
+					&fops_##name.fops);	\
+		e->file_##name.dentry = NULL;			\
+		if (!IS_ERR(d))					\
+			e->file_##name.dentry = d;		\
+	} while (0)
+
+
+	ADD_FILE(tsf, 0600);
+	ADD_FILE(ucode_regs, 0400);
+	ADD_FILE(shm, 0400);
+	ADD_FILE(txstat, 0400);
+	ADD_FILE(txpower_g, 0600);
+	ADD_FILE(restart, 0200);
+	ADD_FILE(loctls, 0400);
+
+#undef ADD_FILE
 
 	b43_add_dynamic_debug(dev);
 }
@@ -692,13 +605,15 @@ void b43_debugfs_remove_device(struct b4
 	if (!e)
 		return;
 	b43_remove_dynamic_debug(dev);
-	debugfs_remove(e->dentry_loctls);
-	debugfs_remove(e->dentry_tsf);
-	debugfs_remove(e->dentry_ucode_regs);
-	debugfs_remove(e->dentry_shm);
-	debugfs_remove(e->dentry_txstat);
-	debugfs_remove(e->dentry_restart);
-	debugfs_remove(e->dentry_txpower_g);
+
+	debugfs_remove(e->file_tsf.dentry);
+	debugfs_remove(e->file_ucode_regs.dentry);
+	debugfs_remove(e->file_shm.dentry);
+	debugfs_remove(e->file_txstat.dentry);
+	debugfs_remove(e->file_txpower_g.dentry);
+	debugfs_remove(e->file_restart.dentry);
+	debugfs_remove(e->file_loctls.dentry);
+
 	debugfs_remove(e->subdir);
 	kfree(e->txstatlog.log);
 	kfree(e);
@@ -728,20 +643,12 @@ void b43_debugfs_log_txstat(struct b43_w
 
 void b43_debugfs_init(void)
 {
-	memset(&fs, 0, sizeof(fs));
-	fs.root = debugfs_create_dir(KBUILD_MODNAME, NULL);
-	if (!fs.root || IS_ERR(fs.root)) {
-		fs.root = NULL;
-		return;
-	}
-	fs.dentry_driverinfo = debugfs_create_file("driver", 0444, fs.root,
-						   NULL, &drvinfo_fops);
-	if (IS_ERR(fs.dentry_driverinfo))
-		fs.dentry_driverinfo = NULL;
+	rootdir = debugfs_create_dir(KBUILD_MODNAME, NULL);
+	if (IS_ERR(rootdir))
+		rootdir = NULL;
 }
 
 void b43_debugfs_exit(void)
 {
-	debugfs_remove(fs.dentry_driverinfo);
-	debugfs_remove(fs.root);
+	debugfs_remove(rootdir);
 }
Index: wireless-dev/drivers/net/wireless/b43/debugfs.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/debugfs.h	2007-09-08 23:56:32.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/debugfs.h	2007-09-09 13:29:41.000000000 +0200
@@ -22,23 +22,26 @@ struct dentry;
 struct b43_txstatus_log {
 	struct b43_txstatus *log;
 	int end;
-	int printing;
-	char printbuf[(B43_NR_LOGGED_TXSTATUS * 70) + 200];
-	size_t buf_avail;
 	spinlock_t lock;
 };
 
+struct b43_dfs_file {
+	struct dentry *dentry;
+	char *buffer;
+	size_t data_len;
+};
+
 struct b43_dfsentry {
+	struct b43_wldev *dev;
 	struct dentry *subdir;
-	struct dentry *dentry_tsf;
-	struct dentry *dentry_ucode_regs;
-	struct dentry *dentry_shm;
-	struct dentry *dentry_txstat;
-	struct dentry *dentry_txpower_g;
-	struct dentry *dentry_restart;
-	struct dentry *dentry_loctls;
 
-	struct b43_wldev *dev;
+	struct b43_dfs_file file_tsf;
+	struct b43_dfs_file file_ucode_regs;
+	struct b43_dfs_file file_shm;
+	struct b43_dfs_file file_txstat;
+	struct b43_dfs_file file_txpower_g;
+	struct b43_dfs_file file_restart;
+	struct b43_dfs_file file_loctls;
 
 	struct b43_txstatus_log txstatlog;
 
@@ -48,11 +51,6 @@ struct b43_dfsentry {
 	struct dentry *dyn_debug_dentries[__B43_NR_DYNDBG];
 };
 
-struct b43_debugfs {
-	struct dentry *root;
-	struct dentry *dentry_driverinfo;
-};
-
 int b43_debug(struct b43_wldev *dev, enum b43_dyndbg feature);
 
 void b43_debugfs_init(void);
@@ -81,31 +79,11 @@ static inline void b43_debugfs_add_devic
 static inline void b43_debugfs_remove_device(struct b43_wldev *dev)
 {
 }
-static inline
-    void b43_debugfs_log_txstat(struct b43_wldev *dev,
-				const struct b43_txstatus *status)
+static inline void b43_debugfs_log_txstat(struct b43_wldev *dev,
+					  const struct b43_txstatus *status)
 {
 }
 
 #endif /* CONFIG_B43_DEBUG */
 
-/* Ugly helper macros to make incomplete code more verbose on runtime */
-#ifdef TODO
-# undef TODO
-#endif
-#define TODO()  \
-	do {									\
-		b43info(NULL, "TODO: Incomplete code in %s() at %s:%d\n",	\
-			__FUNCTION__, __FILE__, __LINE__);			\
-	} while (0)
-
-#ifdef FIXME
-# undef FIXME
-#endif
-#define FIXME()  \
-	do {									\
-		b43info(NULL, "FIXME: Possibly broken code in %s() at %s:%d\n",	\
-			__FUNCTION__, __FILE__, __LINE__);			\
-	} while (0)
-
 #endif /* B43_DEBUGFS_H_ */
Index: wireless-dev/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-09-07 16:36:00.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-09-09 13:27:14.000000000 +0200
@@ -762,7 +762,6 @@ static void keymac_write(struct b43_wlde
 		 */
 		if (index < 8) {
 			/* TODO write to RCM 16, 19, 22 and 25 */
-			TODO();
 		} else {
 			b43_shm_write32(dev, B43_SHM_SHARED,
 					B43_SHM_SH_PSM + (index * 6) + 0,
@@ -3593,19 +3592,23 @@ static void b43_chip_reset(struct work_s
 
 	mutex_lock(&wl->mutex);
 
+printk("RESTART\n");
 	prev_status = b43_status(dev);
 	/* Bring the device down... */
 	if (prev_status >= B43_STAT_STARTED)
 		b43_wireless_core_stop(dev);
+printk("exit\n");
 	if (prev_status >= B43_STAT_INITIALIZED)
 		b43_wireless_core_exit(dev);
 
+printk("init\n");
 	/* ...and up again. */
 	if (prev_status >= B43_STAT_INITIALIZED) {
 		err = b43_wireless_core_init(dev);
 		if (err)
 			goto out;
 	}
+printk("start\n");
 	if (prev_status >= B43_STAT_STARTED) {
 		err = b43_wireless_core_start(dev);
 		if (err) {
@@ -3613,6 +3616,7 @@ static void b43_chip_reset(struct work_s
 			goto out;
 		}
 	}
+printk("done\n");
       out:
 	mutex_unlock(&wl->mutex);
 	if (err)
Index: wireless-dev/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/phy.c	2007-09-07 16:41:46.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/phy.c	2007-09-09 13:28:31.000000000 +0200
@@ -1147,7 +1147,7 @@ static void b43_phy_inita(struct b43_wld
 		      (b43_phy_read(dev, B43_PHY_A_CRS) & 0xF83C) | 0x0340);
 	b43_phy_write(dev, 0x0034, 0x0001);
 
-	TODO();			//TODO: RSSI AGC
+	//TODO: RSSI AGC
 	b43_phy_write(dev, B43_PHY_A_CRS,
 		      b43_phy_read(dev, B43_PHY_A_CRS) | (1 << 14));
 	b43_radio_init2060(dev);
@@ -1156,7 +1156,7 @@ static void b43_phy_inita(struct b43_wld
 	    ((bus->boardinfo.type == SSB_BOARD_BU4306) ||
 	     (bus->boardinfo.type == SSB_BOARD_BU4309))) {
 		if (phy->lofcal == 0xFFFF) {
-			TODO();	//TODO: LOF Cal
+			//TODO: LOF Cal
 			b43_radio_set_tx_iq(dev);
 		} else
 			b43_radio_write16(dev, 0x001E, phy->lofcal);
@@ -1900,7 +1900,7 @@ static s8 b43_phy_estimate_power_out(str
 		tmp += 0x80;
 		tmp = limit_value(tmp, 0x00, 0xFF);
 		dbm = phy->tssi2dbm[tmp];
-		TODO();		//TODO: There's a FIXME on the specs
+		//TODO: There's a FIXME on the specs
 		break;
 	case B43_PHYTYPE_B:
 	case B43_PHYTYPE_G:
@@ -1986,7 +1986,7 @@ void b43_phy_xmitpower(struct b43_wldev 
 	switch (phy->type) {
 	case B43_PHYTYPE_A:{
 
-			TODO();	//TODO: Nothing for A PHYs yet :-/
+			//TODO: Nothing for A PHYs yet :-/
 
 			break;
 		}
@@ -4127,10 +4127,10 @@ int b43_radio_selectchannel(struct b43_w
 		b43_write16(dev, 0x03F0, freq);
 		b43_radio_write16(dev, 0x0008, r8);
 
-		TODO();		//TODO: write max channel TX power? to Radio 0x2D
+		//TODO: write max channel TX power? to Radio 0x2D
 		tmp = b43_radio_read16(dev, 0x002E);
 		tmp &= 0x0080;
-		TODO();		//TODO: OR tmp with the Power out estimation for this channel?
+		//TODO: OR tmp with the Power out estimation for this channel?
 		b43_radio_write16(dev, 0x002E, tmp);
 
 		if (freq >= 4920 && freq <= 5500) {
@@ -4165,7 +4165,7 @@ int b43_radio_selectchannel(struct b43_w
 		b43_radio_write16(dev, 0x0035, (b43_radio_read16(dev, 0x0035)
 						& 0xFFEF) | 0x0010);
 		b43_radio_set_tx_iq(dev);
-		TODO();		//TODO: TSSI2dbm workaround
+		//TODO: TSSI2dbm workaround
 		b43_phy_xmitpower(dev);	//FIXME correct?
 	} else {
 		if ((channel < 1) || (channel > 14))
@@ -4295,7 +4295,6 @@ static void b43_radio_set_txpower_a(stru
 
 	phy->txpwr_offset = txpower;
 
-	TODO();
 	//TODO: FuncPlaceholder (Adjust BB loft cancel)
 }
 


From mb at bu3sch.de  Sun Sep  9 13:55:00 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 9 Sep 2007 13:55:00 +0200
Subject: [PATCH] b43: Don't cancel the restart workqueue in wireless_core_exit
Message-ID: <200709091355.00658.mb@bu3sch.de>

The wq must be canceled later on rmmod. It's nonfatal, if
the wq runs on a device that's not started or down. It will
handle these cases.
But syncing in wireless_core_exit() will cause a deadlock with
the restart_work. (restart work cancels itself)

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>

Index: wireless-dev/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-09-09 13:27:14.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-09-09 13:46:31.000000000 +0200
@@ -3317,7 +3317,6 @@ static void b43_imcfglo_timeouts_workaro
 /* Locking: wl->mutex */
 static void b43_wireless_core_exit(struct b43_wldev *dev)
 {
-	struct b43_wl *wl = dev->wl;
 	struct b43_phy *phy = &dev->phy;
 
 	B43_WARN_ON(b43_status(dev) > B43_STAT_INITIALIZED);
@@ -3325,12 +3324,6 @@ static void b43_wireless_core_exit(struc
 		return;
 	b43_set_status(dev, B43_STAT_UNINIT);
 
-	mutex_unlock(&wl->mutex);
-	/* Must unlock as it would otherwise deadlock. No races here.
-	 * Cancel possibly pending workqueues. */
-	cancel_work_sync(&dev->restart_work);
-	mutex_lock(&wl->mutex);
-
 	b43_rng_exit(dev->wl);
 	b43_pio_free(dev);
 	b43_dma_free(dev);
@@ -3811,6 +3804,7 @@ static void b43_one_core_detach(struct s
 
 	wldev = ssb_get_drvdata(dev);
 	wl = wldev->wl;
+	cancel_work_sync(&wldev->restart_work);
 	b43_debugfs_remove_device(wldev);
 	b43_wireless_core_detach(wldev);
 	list_del(&wldev->list);


From mb at bu3sch.de  Sun Sep  9 14:12:22 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 9 Sep 2007 14:12:22 +0200
Subject: [PATCH] b43: Simplify and cleanup debugfs infrastructure
In-Reply-To: <200709091353.52002.mb@bu3sch.de>
References: <200709091353.52002.mb@bu3sch.de>
Message-ID: <200709091412.22672.mb@bu3sch.de>

On Sunday 09 September 2007 13:53:51 Michael Buesch wrote:
> Index: wireless-dev/drivers/net/wireless/b43/main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-09-07 16:36:00.000000000 +0200
> +++ wireless-dev/drivers/net/wireless/b43/main.c	2007-09-09 13:27:14.000000000 +0200
> @@ -762,7 +762,6 @@ static void keymac_write(struct b43_wlde
>  		 */
>  		if (index < 8) {
>  			/* TODO write to RCM 16, 19, 22 and 25 */
> -			TODO();
>  		} else {
>  			b43_shm_write32(dev, B43_SHM_SHARED,
>  					B43_SHM_SH_PSM + (index * 6) + 0,
> @@ -3593,19 +3592,23 @@ static void b43_chip_reset(struct work_s
>  
>  	mutex_lock(&wl->mutex);
>  
> +printk("RESTART\n");
>  	prev_status = b43_status(dev);
>  	/* Bring the device down... */
>  	if (prev_status >= B43_STAT_STARTED)
>  		b43_wireless_core_stop(dev);
> +printk("exit\n");
>  	if (prev_status >= B43_STAT_INITIALIZED)
>  		b43_wireless_core_exit(dev);
>  
> +printk("init\n");
>  	/* ...and up again. */
>  	if (prev_status >= B43_STAT_INITIALIZED) {
>  		err = b43_wireless_core_init(dev);
>  		if (err)
>  			goto out;
>  	}
> +printk("start\n");
>  	if (prev_status >= B43_STAT_STARTED) {
>  		err = b43_wireless_core_start(dev);
>  		if (err) {
> @@ -3613,6 +3616,7 @@ static void b43_chip_reset(struct work_s
>  			goto out;
>  		}
>  	}
> +printk("done\n");
>        out:
>  	mutex_unlock(&wl->mutex);
>  	if (err)

Whoopsy. Seems like I should remove debugging code before submission :)


-- 
Greetings Michael.


From mb at bu3sch.de  Sun Sep  9 14:17:23 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 9 Sep 2007 14:17:23 +0200
Subject: [PATCH v2] b43: Simplify and cleanup debugfs infrastructure
Message-ID: <200709091417.24918.mb@bu3sch.de>

This is a major cleanup and simplification of the debugfs
infrastructure. All the debugfs related FS handling code (copy_*_user, etc...)
and the locking is handled in common functions. The debugging implementation
files only have to care about their actual job anymore.
This shrinks the function size.

A few macros were also added to simplify adding new files.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>

Index: wireless-dev/drivers/net/wireless/b43/debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/debugfs.c	2007-09-09 13:51:20.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/debugfs.c	2007-09-09 13:51:39.000000000 +0200
@@ -4,7 +4,7 @@
 
   debugfs driver debugging code
 
-  Copyright (c) 2005 Michael Buesch <mb at bu3sch.de>
+  Copyright (c) 2005-2007 Michael Buesch <mb at bu3sch.de>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -37,308 +37,155 @@
 #include "pio.h"
 #include "xmit.h"
 
-#define REALLY_BIG_BUFFER_SIZE	(1024*256)
 
-static struct b43_debugfs fs;
-static char big_buffer[1024 * 256];
-static DEFINE_MUTEX(big_buffer_mutex);
+/* The root directory. */
+struct dentry *rootdir;
 
-static ssize_t write_file_dummy(struct file *file, const char __user * buf,
-				size_t count, loff_t * ppos)
-{
-	return count;
-}
+struct b43_debugfs_fops {
+	ssize_t (*read)(struct b43_wldev *dev, char *buf, size_t bufsize);
+	int (*write)(struct b43_wldev *dev, const char *buf, size_t count);
+	struct file_operations fops;
+	/* Offset of struct b43_dfs_file in struct b43_dfsentry */
+	size_t file_struct_offset;
+	/* Take wl->irq_lock before calling read/write? */
+	bool take_irqlock;
+};
 
-static int open_file_generic(struct inode *inode, struct file *file)
+static inline
+struct b43_dfs_file * fops_to_dfs_file(struct b43_wldev *dev,
+				       const struct b43_debugfs_fops *dfops)
 {
-	file->private_data = inode->i_private;
-	return 0;
+	void *p;
+
+	p = dev->dfsentry;
+	p += dfops->file_struct_offset;
+
+	return p;
 }
 
-#define fappend(fmt, x...)	pos += snprintf(buf + pos, len - pos, fmt , ##x)
 
-static ssize_t drvinfo_read_file(struct file *file, char __user * userbuf,
-				 size_t count, loff_t * ppos)
+#define fappend(fmt, x...)	\
+	do {							\
+		if (bufsize - count)				\
+			count += snprintf(buf + count,		\
+					  bufsize - count,	\
+					  fmt , ##x);		\
+		else						\
+			printk(KERN_ERR "b43: fappend overflow\n"); \
+	} while (0)
+
+
+/* wl->irq_lock is locked */
+ssize_t tsf_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-
-	mutex_lock(&big_buffer_mutex);
-	/* This is where the information is written to the "driver" file */
-	fappend(KBUILD_MODNAME " driver\n");
-	fappend("Compiled at: %s %s\n", __DATE__, __TIME__);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
-}
-
-static ssize_t tsf_read_file(struct file *file, char __user * userbuf,
-			     size_t count, loff_t * ppos)
-{
-	struct b43_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 	u64 tsf;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_STARTED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
 	b43_tsf_read(dev, &tsf);
 	fappend("0x%08x%08x\n",
 		(unsigned int)((tsf & 0xFFFFFFFF00000000ULL) >> 32),
 		(unsigned int)(tsf & 0xFFFFFFFFULL));
 
-      out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return count;
 }
 
-static ssize_t tsf_write_file(struct file *file, const char __user * user_buf,
-			      size_t count, loff_t * ppos)
+/* wl->irq_lock is locked */
+int tsf_write_file(struct b43_wldev *dev, const char *buf, size_t count)
 {
-	struct b43_wldev *dev = file->private_data;
-	char *buf = big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags;
 	u64 tsf;
 
-	mutex_lock(&big_buffer_mutex);
-	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-		res = -EFAULT;
-		goto out_unlock_bb;
-	}
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_STARTED) {
-		b43err(dev->wl, "debugfs: Board not initialized.\n");
-		res = -EFAULT;
-		goto out_unlock;
-	}
-	if (sscanf(buf, "%llu", (unsigned long long *)(&tsf)) != 1) {
-		b43err(dev->wl, "debugfs: invalid values for \"tsf\"\n");
-		res = -EINVAL;
-		goto out_unlock;
-	}
+	if (sscanf(buf, "%llu", (unsigned long long *)(&tsf)) != 1)
+		return -EINVAL;
 	b43_tsf_write(dev, tsf);
-	mmiowb();
-	res = buf_size;
 
-      out_unlock:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-      out_unlock_bb:
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return 0;
 }
 
-static ssize_t ucode_regs_read_file(struct file *file, char __user * userbuf,
-				    size_t count, loff_t * ppos)
+/* wl->irq_lock is locked */
+ssize_t ucode_regs_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 	int i;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_INITIALIZED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
-
 	for (i = 0; i < 64; i++) {
 		fappend("r%d = 0x%04x\n", i,
 			b43_shm_read16(dev, B43_SHM_SCRATCH, i));
 	}
 
-out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return count;
 }
 
-static ssize_t shm_read_file(struct file *file, char __user * userbuf,
-			     size_t count, loff_t * ppos)
+/* wl->irq_lock is locked */
+ssize_t shm_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	u8 *buf = big_buffer;
-	__le16 *le16buf = (__le16*)big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 	int i;
 	u16 tmp;
-
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_INITIALIZED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
+	__le16 *le16buf = (__le16 *)buf;
 
 	for (i = 0; i < 0x1000; i++) {
+		if (bufsize <= 0)
+			break;
 		tmp = b43_shm_read16(dev, B43_SHM_SHARED, 2 * i);
 		le16buf[i] = cpu_to_le16(tmp);
-		pos += sizeof(tmp);
+		count += sizeof(tmp);
+		bufsize -= sizeof(tmp);
 	}
 
-out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return count;
 }
 
-static ssize_t txstat_read_file(struct file *file, char __user * userbuf,
-				size_t count, loff_t * ppos)
+ssize_t txstat_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43_wldev *dev = file->private_data;
-	struct b43_dfsentry *e = dev->dfsentry;
-	struct b43_txstatus_log *log = &e->txstatlog;
+	struct b43_txstatus_log *log = &dev->dfsentry->txstatlog;
+	ssize_t count = 0;
 	unsigned long flags;
-	char *buf = log->printbuf;
-	const size_t len = ARRAY_SIZE(log->printbuf);
-	size_t pos = 0;
-	ssize_t res;
 	int i, idx;
 	struct b43_txstatus *stat;
 
-	mutex_lock(&big_buffer_mutex);
 	spin_lock_irqsave(&log->lock, flags);
-	if (!log->printing) {
-		log->printing = 1;
-		fappend("b43 TX status reports:\n\n"
-			"index | cookie | seq | phy_stat | frame_count | "
-			"rts_count | supp_reason | pm_indicated | "
-			"intermediate | for_ampdu | acked\n" "---\n");
-		i = log->end + 1;
-		idx = 0;
-		while (1) {
-			if (log->end < 0) {
-				fappend("Nothing transmitted, yet\n");
-				break;
-			}
-			if (i == B43_NR_LOGGED_TXSTATUS)
-				i = 0;
-			stat = &(log->log[i]);
-			if (stat->cookie) {
-				fappend("%03d | "
-					"0x%04X | 0x%04X | 0x%02X | "
-					"0x%X | 0x%X | "
-					"%u | %u | "
-					"%u | %u | %u\n",
-					idx,
-					stat->cookie, stat->seq, stat->phy_stat,
-					stat->frame_count, stat->rts_count,
-					stat->supp_reason, stat->pm_indicated,
-					stat->intermediate, stat->for_ampdu,
-					stat->acked);
-				idx++;
-			}
-			if (i == log->end)
-				break;
-			i++;
+	if (log->end < 0) {
+		fappend("Nothing transmitted, yet\n");
+		goto out_unlock;
+	}
+	fappend("b43 TX status reports:\n\n"
+		"index | cookie | seq | phy_stat | frame_count | "
+		"rts_count | supp_reason | pm_indicated | "
+		"intermediate | for_ampdu | acked\n" "---\n");
+	i = log->end + 1;
+	idx = 0;
+	while (1) {
+		if (i == B43_NR_LOGGED_TXSTATUS)
+			i = 0;
+		stat = &(log->log[i]);
+		if (stat->cookie) {
+			fappend("%03d | "
+				"0x%04X | 0x%04X | 0x%02X | "
+				"0x%X | 0x%X | "
+				"%u | %u | "
+				"%u | %u | %u\n",
+				idx,
+				stat->cookie, stat->seq, stat->phy_stat,
+				stat->frame_count, stat->rts_count,
+				stat->supp_reason, stat->pm_indicated,
+				stat->intermediate, stat->for_ampdu,
+				stat->acked);
+			idx++;
 		}
-		log->buf_avail = pos;
+		if (i == log->end)
+			break;
+		i++;
 	}
-	memcpy(big_buffer, buf, min(log->buf_avail, ARRAY_SIZE(big_buffer)));
+out_unlock:
 	spin_unlock_irqrestore(&log->lock, flags);
 
-	res = simple_read_from_buffer(userbuf, count, ppos,
-				      big_buffer, log->buf_avail);
-	if (*ppos == log->buf_avail) {
-		spin_lock_irqsave(&log->lock, flags);
-		log->printing = 0;
-		spin_unlock_irqrestore(&log->lock, flags);
-	}
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
-}
-
-static ssize_t restart_write_file(struct file *file,
-				  const char __user * user_buf, size_t count,
-				  loff_t * ppos)
-{
-	struct b43_wldev *dev = file->private_data;
-	char *buf = big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags;
-
-	mutex_lock(&big_buffer_mutex);
-	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-		res = -EFAULT;
-		goto out_unlock_bb;
-	}
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_INITIALIZED) {
-		b43err(dev->wl, "debugfs: Board not initialized.\n");
-		res = -EFAULT;
-		goto out_unlock;
-	}
-	if (count > 0 && buf[0] == '1') {
-		b43_controller_restart(dev, "manually restarted");
-		res = count;
-	} else
-		res = -EINVAL;
-
-      out_unlock:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-      out_unlock_bb:
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return count;
 }
 
-static ssize_t txpower_g_read_file(struct file *file, char __user * userbuf,
-				   size_t count, loff_t * ppos)
+ssize_t txpower_g_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_STARTED) {
-		fappend("Not initialized\n");
-		goto out;
-	}
 	if (dev->phy.type != B43_PHYTYPE_G) {
 		fappend("Device is not a G-PHY\n");
 		goto out;
@@ -363,45 +210,22 @@ static ssize_t txpower_g_read_file(struc
 	fappend("Enables manual control with Baseband attenuation 5, "
 		"Radio attenuation 4, No TX Mixer Gain, "
 		"No PA Gain 2dB, With PA Gain 3dB.\n");
-
-      out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+out:
+	return count;
 }
 
-static ssize_t txpower_g_write_file(struct file *file,
-				    const char __user * user_buf, size_t count,
-				    loff_t * ppos)
-{
-	struct b43_wldev *dev = file->private_data;
-	char *buf = big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags, phy_flags;
-
-	mutex_lock(&big_buffer_mutex);
-	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-		res = -EFAULT;
-		goto out_unlock_bb;
-	}
-	mutex_lock(&dev->wl->mutex);
+int txpower_g_write_file(struct b43_wldev *dev, const char *buf, size_t count)
+{
+	unsigned long flags;
+	unsigned long phy_flags;
+	int err = 0;
+
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_STARTED) {
-		b43err(dev->wl, "debugfs: Board not initialized.\n");
-		res = -ENODEV;
-		goto out_unlock;
-	}
 	if (dev->phy.type != B43_PHYTYPE_G) {
-		b43err(dev->wl, "debugfs: Device is not a G-PHY\n");
-		res = -ENODEV;
+		err = -ENODEV;
 		goto out_unlock;
 	}
-	if ((buf_size >= 4) && (memcmp(buf, "auto", 4) == 0)) {
+	if ((count >= 4) && (memcmp(buf, "auto", 4) == 0)) {
 		/* Automatic control */
 		dev->phy.manual_txpower_control = 0;
 		b43_phy_xmitpower(dev);
@@ -410,9 +234,7 @@ static ssize_t txpower_g_write_file(stru
 		/* Manual control */
 		if (sscanf(buf, "%d %d %d %d %d", &bbatt, &rfatt,
 			   &txmix, &pa2db, &pa3db) != 5) {
-			b43err(dev->wl,
-			       "debugfs: invalid value for \"tx_power_g\"\n");
-			res = -EINVAL;
+			err = -EINVAL;
 			goto out_unlock;
 		}
 		b43_put_attenuation_into_ranges(dev, &bbatt, &rfatt);
@@ -433,18 +255,27 @@ static ssize_t txpower_g_write_file(stru
 		b43_radio_unlock(dev);
 		b43_phy_unlock(dev, phy_flags);
 	}
-	res = buf_size;
-      out_unlock:
+out_unlock:
 	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-      out_unlock_bb:
-	mutex_unlock(&big_buffer_mutex);
 
-	return res;
+	return err;
 }
 
-static size_t append_lo_table(size_t pos, char *buf, const size_t len,
-			      struct b43_loctl table[B43_NR_BB][B43_NR_RF])
+/* wl->irq_lock is locked */
+int restart_write_file(struct b43_wldev *dev, const char *buf, size_t count)
+{
+	int err = 0;
+
+	if (count > 0 && buf[0] == '1') {
+		b43_controller_restart(dev, "manually restarted");
+	} else
+		err = -EINVAL;
+
+	return err;
+}
+
+static ssize_t append_lo_table(ssize_t count, char *buf, const size_t bufsize,
+			       struct b43_loctl table[B43_NR_BB][B43_NR_RF])
 {
 	unsigned int i, j;
 	struct b43_loctl *ctl;
@@ -460,33 +291,20 @@ static size_t append_lo_table(size_t pos
 		}
 	}
 
-	return pos;
+	return count;
 }
 
-static ssize_t loctls_read_file(struct file *file, char __user *userbuf,
-				size_t count, loff_t *ppos)
+ssize_t loctls_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 	struct b43_txpower_lo_control *lo;
-	unsigned int i;
+	int i, err = 0;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43_status(dev) < B43_STAT_INITIALIZED) {
-		fappend("Not initialized\n");
-		goto out;
-	}
 	if (dev->phy.type != B43_PHYTYPE_G) {
 		fappend("Device is not a G-PHY\n");
+		err = -ENODEV;
 		goto out;
 	}
-
 	lo = dev->phy.lo_control;
 	fappend("-- Local Oscillator calibration data --\n\n");
 	fappend("Measured: %d,  Rebuild: %d,  HW-power-control: %d\n",
@@ -499,9 +317,9 @@ static ssize_t loctls_read_file(struct f
 		(unsigned int)((lo->power_vector & 0xFFFFFFFF00000000ULL) >> 32),
 		(unsigned int)(lo->power_vector & 0x00000000FFFFFFFFULL));
 	fappend("\nControl table WITH PADMIX:\n");
-	pos = append_lo_table(pos, buf, len, lo->with_padmix);
+	count = append_lo_table(count, buf, bufsize, lo->with_padmix);
 	fappend("\nControl table WITHOUT PADMIX:\n");
-	pos = append_lo_table(pos, buf, len, lo->no_padmix);
+	count = append_lo_table(count, buf, bufsize, lo->no_padmix);
 	fappend("\nUsed RF attenuation values:  Value(WithPadmix flag)\n");
 	for (i = 0; i < lo->rfatt_list.len; i++) {
 		fappend("%u(%d), ",
@@ -517,59 +335,161 @@ static ssize_t loctls_read_file(struct f
 	fappend("\n");
 
 out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return err ? err : count;
 }
 
 #undef fappend
 
-static struct file_operations drvinfo_fops = {
-	.read = drvinfo_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
+static int b43_debugfs_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
 
-static struct file_operations tsf_fops = {
-	.read = tsf_read_file,
-	.write = tsf_write_file,
-	.open = open_file_generic,
-};
+static ssize_t b43_debugfs_read(struct file *file, char __user *userbuf,
+				size_t count, loff_t *ppos)
+{
+	struct b43_wldev *dev;
+	struct b43_debugfs_fops *dfops;
+	struct b43_dfs_file *dfile;
+	ssize_t ret;
+	char *buf;
+	const size_t bufsize = 1024 * 128;
+	const size_t buforder = get_order(bufsize);
+	int err = 0;
+
+	if (!count)
+		return 0;
+	dev = file->private_data;
+	if (!dev)
+		return -ENODEV;
 
-static struct file_operations ucode_regs_fops = {
-	.read = ucode_regs_read_file,
-	.open = open_file_generic,
-};
+	mutex_lock(&dev->wl->mutex);
+	if (b43_status(dev) < B43_STAT_INITIALIZED) {
+		err = -ENODEV;
+		goto out_unlock;
+	}
 
-static struct file_operations shm_fops = {
-	.read = shm_read_file,
-	.open = open_file_generic,
-};
+	dfops = container_of(file->f_op, struct b43_debugfs_fops, fops);
+	if (!dfops->read) {
+		err = -ENOSYS;
+		goto out_unlock;
+	}
+	dfile = fops_to_dfs_file(dev, dfops);
 
-static struct file_operations txstat_fops = {
-	.read = txstat_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
+	if (!dfile->buffer) {
+		buf = (char *)__get_free_pages(GFP_KERNEL, buforder);
+		if (!buf) {
+			err = -ENOMEM;
+			goto out_unlock;
+		}
+		memset(buf, 0, bufsize);
+		if (dfops->take_irqlock) {
+			spin_lock_irq(&dev->wl->irq_lock);
+			ret = dfops->read(dev, buf, bufsize);
+			spin_unlock_irq(&dev->wl->irq_lock);
+		} else
+			ret = dfops->read(dev, buf, bufsize);
+		if (ret <= 0) {
+			free_pages((unsigned long)buf, buforder);
+			err = ret;
+			goto out_unlock;
+		}
+		dfile->data_len = ret;
+		dfile->buffer = buf;
+	}
 
-static struct file_operations txpower_g_fops = {
-	.read = txpower_g_read_file,
-	.write = txpower_g_write_file,
-	.open = open_file_generic,
-};
+	ret = simple_read_from_buffer(userbuf, count, ppos,
+				      dfile->buffer,
+				      dfile->data_len);
+	if (*ppos >= dfile->data_len) {
+		free_pages((unsigned long)dfile->buffer, buforder);
+		dfile->buffer = NULL;
+		dfile->data_len = 0;
+	}
+out_unlock:
+	mutex_unlock(&dev->wl->mutex);
 
-static struct file_operations restart_fops = {
-	.write = restart_write_file,
-	.open = open_file_generic,
-};
+	return err ? err : ret;
+}
 
-static struct file_operations loctls_fops = {
-	.read = loctls_read_file,
-	.open = open_file_generic,
-};
+static ssize_t b43_debugfs_write(struct file *file,
+				 const char __user *userbuf,
+				 size_t count, loff_t *ppos)
+{
+	struct b43_wldev *dev;
+	struct b43_debugfs_fops *dfops;
+	char *buf;
+	int err = 0;
+
+	if (!count)
+		return 0;
+	if (count > PAGE_SIZE)
+		return -E2BIG;
+	dev = file->private_data;
+	if (!dev)
+		return -ENODEV;
+
+	mutex_lock(&dev->wl->mutex);
+	if (b43_status(dev) < B43_STAT_INITIALIZED) {
+		err = -ENODEV;
+		goto out_unlock;
+	}
+
+	dfops = container_of(file->f_op, struct b43_debugfs_fops, fops);
+	if (!dfops->write) {
+		err = -ENOSYS;
+		goto out_unlock;
+	}
+
+	buf = (char *)get_zeroed_page(GFP_KERNEL);
+	if (!buf) {
+		err = -ENOMEM;
+		goto out_unlock;
+	}
+	if (copy_from_user(buf, userbuf, count)) {
+		err = -EFAULT;
+		goto out_freepage;
+	}
+	if (dfops->take_irqlock) {
+		spin_lock_irq(&dev->wl->irq_lock);
+		err = dfops->write(dev, buf, count);
+		spin_unlock_irq(&dev->wl->irq_lock);
+	} else
+		err = dfops->write(dev, buf, count);
+	if (err)
+		goto out_freepage;
+
+out_freepage:
+	free_page((unsigned long)buf);
+out_unlock:
+	mutex_unlock(&dev->wl->mutex);
+
+	return err ? err : count;
+}
+
+
+#define B43_DEBUGFS_FOPS(name, _read, _write, _take_irqlock)	\
+	static struct b43_debugfs_fops fops_##name = {		\
+		.read	= _read,				\
+		.write	= _write,				\
+		.fops	= {					\
+			.open	= b43_debugfs_open,		\
+			.read	= b43_debugfs_read,		\
+			.write	= b43_debugfs_write,		\
+		},						\
+		.file_struct_offset = offsetof(struct b43_dfsentry, \
+					       file_##name),	\
+		.take_irqlock	= _take_irqlock,		\
+	}
+
+B43_DEBUGFS_FOPS(tsf, tsf_read_file, tsf_write_file, 1);
+B43_DEBUGFS_FOPS(ucode_regs, ucode_regs_read_file, NULL, 1);
+B43_DEBUGFS_FOPS(shm, shm_read_file, NULL, 1);
+B43_DEBUGFS_FOPS(txstat, txstat_read_file, NULL, 0);
+B43_DEBUGFS_FOPS(txpower_g, txpower_g_read_file, txpower_g_write_file, 0);
+B43_DEBUGFS_FOPS(restart, NULL, restart_write_file, 1);
+B43_DEBUGFS_FOPS(loctls, loctls_read_file, NULL, 0);
 
 
 int b43_debug(struct b43_wldev *dev, enum b43_dyndbg feature)
@@ -635,7 +555,7 @@ void b43_debugfs_add_device(struct b43_w
 	dev->dfsentry = e;
 
 	snprintf(devdir, sizeof(devdir), "%s", wiphy_name(dev->wl->hw->wiphy));
-	e->subdir = debugfs_create_dir(devdir, fs.root);
+	e->subdir = debugfs_create_dir(devdir, rootdir);
 	if (!e->subdir || IS_ERR(e->subdir)) {
 		if (e->subdir == ERR_PTR(-ENODEV)) {
 			b43dbg(dev->wl, "DebugFS (CONFIG_DEBUG_FS) not "
@@ -650,34 +570,27 @@ void b43_debugfs_add_device(struct b43_w
 		return;
 	}
 
-	e->dentry_tsf = debugfs_create_file("tsf", 0600, e->subdir,
-					    dev, &tsf_fops);
-	if (IS_ERR(e->dentry_tsf))
-		e->dentry_tsf = NULL;
-	e->dentry_ucode_regs = debugfs_create_file("ucode_regs", 0400, e->subdir,
-						   dev, &ucode_regs_fops);
-	if (IS_ERR(e->dentry_ucode_regs))
-		e->dentry_ucode_regs = NULL;
-	e->dentry_shm = debugfs_create_file("shm", 0400, e->subdir,
-					    dev, &shm_fops);
-	if (IS_ERR(e->dentry_shm))
-		e->dentry_shm = NULL;
-	e->dentry_txstat = debugfs_create_file("tx_status", 0400, e->subdir,
-					       dev, &txstat_fops);
-	if (IS_ERR(e->dentry_txstat))
-		e->dentry_txstat = NULL;
-	e->dentry_txpower_g = debugfs_create_file("tx_power_g", 0600, e->subdir,
-						  dev, &txpower_g_fops);
-	if (IS_ERR(e->dentry_txpower_g))
-		e->dentry_txpower_g = NULL;
-	e->dentry_restart = debugfs_create_file("restart", 0200, e->subdir,
-						dev, &restart_fops);
-	if (IS_ERR(e->dentry_restart))
-		e->dentry_restart = NULL;
-	e->dentry_loctls = debugfs_create_file("loctls", 0400, e->subdir,
-					       dev, &loctls_fops);
-	if (IS_ERR(e->dentry_loctls))
-		e->dentry_loctls = NULL;
+#define ADD_FILE(name, mode)	\
+	do {							\
+		struct dentry *d;				\
+		d = debugfs_create_file(__stringify(name),	\
+					mode, e->subdir, dev,	\
+					&fops_##name.fops);	\
+		e->file_##name.dentry = NULL;			\
+		if (!IS_ERR(d))					\
+			e->file_##name.dentry = d;		\
+	} while (0)
+
+
+	ADD_FILE(tsf, 0600);
+	ADD_FILE(ucode_regs, 0400);
+	ADD_FILE(shm, 0400);
+	ADD_FILE(txstat, 0400);
+	ADD_FILE(txpower_g, 0600);
+	ADD_FILE(restart, 0200);
+	ADD_FILE(loctls, 0400);
+
+#undef ADD_FILE
 
 	b43_add_dynamic_debug(dev);
 }
@@ -692,13 +605,15 @@ void b43_debugfs_remove_device(struct b4
 	if (!e)
 		return;
 	b43_remove_dynamic_debug(dev);
-	debugfs_remove(e->dentry_loctls);
-	debugfs_remove(e->dentry_tsf);
-	debugfs_remove(e->dentry_ucode_regs);
-	debugfs_remove(e->dentry_shm);
-	debugfs_remove(e->dentry_txstat);
-	debugfs_remove(e->dentry_restart);
-	debugfs_remove(e->dentry_txpower_g);
+
+	debugfs_remove(e->file_tsf.dentry);
+	debugfs_remove(e->file_ucode_regs.dentry);
+	debugfs_remove(e->file_shm.dentry);
+	debugfs_remove(e->file_txstat.dentry);
+	debugfs_remove(e->file_txpower_g.dentry);
+	debugfs_remove(e->file_restart.dentry);
+	debugfs_remove(e->file_loctls.dentry);
+
 	debugfs_remove(e->subdir);
 	kfree(e->txstatlog.log);
 	kfree(e);
@@ -728,20 +643,12 @@ void b43_debugfs_log_txstat(struct b43_w
 
 void b43_debugfs_init(void)
 {
-	memset(&fs, 0, sizeof(fs));
-	fs.root = debugfs_create_dir(KBUILD_MODNAME, NULL);
-	if (!fs.root || IS_ERR(fs.root)) {
-		fs.root = NULL;
-		return;
-	}
-	fs.dentry_driverinfo = debugfs_create_file("driver", 0444, fs.root,
-						   NULL, &drvinfo_fops);
-	if (IS_ERR(fs.dentry_driverinfo))
-		fs.dentry_driverinfo = NULL;
+	rootdir = debugfs_create_dir(KBUILD_MODNAME, NULL);
+	if (IS_ERR(rootdir))
+		rootdir = NULL;
 }
 
 void b43_debugfs_exit(void)
 {
-	debugfs_remove(fs.dentry_driverinfo);
-	debugfs_remove(fs.root);
+	debugfs_remove(rootdir);
 }
Index: wireless-dev/drivers/net/wireless/b43/debugfs.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/debugfs.h	2007-09-09 13:51:20.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/debugfs.h	2007-09-09 13:51:39.000000000 +0200
@@ -22,23 +22,26 @@ struct dentry;
 struct b43_txstatus_log {
 	struct b43_txstatus *log;
 	int end;
-	int printing;
-	char printbuf[(B43_NR_LOGGED_TXSTATUS * 70) + 200];
-	size_t buf_avail;
 	spinlock_t lock;
 };
 
+struct b43_dfs_file {
+	struct dentry *dentry;
+	char *buffer;
+	size_t data_len;
+};
+
 struct b43_dfsentry {
+	struct b43_wldev *dev;
 	struct dentry *subdir;
-	struct dentry *dentry_tsf;
-	struct dentry *dentry_ucode_regs;
-	struct dentry *dentry_shm;
-	struct dentry *dentry_txstat;
-	struct dentry *dentry_txpower_g;
-	struct dentry *dentry_restart;
-	struct dentry *dentry_loctls;
 
-	struct b43_wldev *dev;
+	struct b43_dfs_file file_tsf;
+	struct b43_dfs_file file_ucode_regs;
+	struct b43_dfs_file file_shm;
+	struct b43_dfs_file file_txstat;
+	struct b43_dfs_file file_txpower_g;
+	struct b43_dfs_file file_restart;
+	struct b43_dfs_file file_loctls;
 
 	struct b43_txstatus_log txstatlog;
 
@@ -48,11 +51,6 @@ struct b43_dfsentry {
 	struct dentry *dyn_debug_dentries[__B43_NR_DYNDBG];
 };
 
-struct b43_debugfs {
-	struct dentry *root;
-	struct dentry *dentry_driverinfo;
-};
-
 int b43_debug(struct b43_wldev *dev, enum b43_dyndbg feature);
 
 void b43_debugfs_init(void);
@@ -81,31 +79,11 @@ static inline void b43_debugfs_add_devic
 static inline void b43_debugfs_remove_device(struct b43_wldev *dev)
 {
 }
-static inline
-    void b43_debugfs_log_txstat(struct b43_wldev *dev,
-				const struct b43_txstatus *status)
+static inline void b43_debugfs_log_txstat(struct b43_wldev *dev,
+					  const struct b43_txstatus *status)
 {
 }
 
 #endif /* CONFIG_B43_DEBUG */
 
-/* Ugly helper macros to make incomplete code more verbose on runtime */
-#ifdef TODO
-# undef TODO
-#endif
-#define TODO()  \
-	do {									\
-		b43info(NULL, "TODO: Incomplete code in %s() at %s:%d\n",	\
-			__FUNCTION__, __FILE__, __LINE__);			\
-	} while (0)
-
-#ifdef FIXME
-# undef FIXME
-#endif
-#define FIXME()  \
-	do {									\
-		b43info(NULL, "FIXME: Possibly broken code in %s() at %s:%d\n",	\
-			__FUNCTION__, __FILE__, __LINE__);			\
-	} while (0)
-
 #endif /* B43_DEBUGFS_H_ */
Index: wireless-dev/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-09-09 13:51:24.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-09-09 14:14:32.000000000 +0200
@@ -762,7 +762,6 @@ static void keymac_write(struct b43_wlde
 		 */
 		if (index < 8) {
 			/* TODO write to RCM 16, 19, 22 and 25 */
-			TODO();
 		} else {
 			b43_shm_write32(dev, B43_SHM_SHARED,
 					B43_SHM_SH_PSM + (index * 6) + 0,
Index: wireless-dev/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/phy.c	2007-09-09 13:50:20.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/phy.c	2007-09-09 13:51:39.000000000 +0200
@@ -1147,7 +1147,7 @@ static void b43_phy_inita(struct b43_wld
 		      (b43_phy_read(dev, B43_PHY_A_CRS) & 0xF83C) | 0x0340);
 	b43_phy_write(dev, 0x0034, 0x0001);
 
-	TODO();			//TODO: RSSI AGC
+	//TODO: RSSI AGC
 	b43_phy_write(dev, B43_PHY_A_CRS,
 		      b43_phy_read(dev, B43_PHY_A_CRS) | (1 << 14));
 	b43_radio_init2060(dev);
@@ -1156,7 +1156,7 @@ static void b43_phy_inita(struct b43_wld
 	    ((bus->boardinfo.type == SSB_BOARD_BU4306) ||
 	     (bus->boardinfo.type == SSB_BOARD_BU4309))) {
 		if (phy->lofcal == 0xFFFF) {
-			TODO();	//TODO: LOF Cal
+			//TODO: LOF Cal
 			b43_radio_set_tx_iq(dev);
 		} else
 			b43_radio_write16(dev, 0x001E, phy->lofcal);
@@ -1900,7 +1900,7 @@ static s8 b43_phy_estimate_power_out(str
 		tmp += 0x80;
 		tmp = limit_value(tmp, 0x00, 0xFF);
 		dbm = phy->tssi2dbm[tmp];
-		TODO();		//TODO: There's a FIXME on the specs
+		//TODO: There's a FIXME on the specs
 		break;
 	case B43_PHYTYPE_B:
 	case B43_PHYTYPE_G:
@@ -1986,7 +1986,7 @@ void b43_phy_xmitpower(struct b43_wldev 
 	switch (phy->type) {
 	case B43_PHYTYPE_A:{
 
-			TODO();	//TODO: Nothing for A PHYs yet :-/
+			//TODO: Nothing for A PHYs yet :-/
 
 			break;
 		}
@@ -4127,10 +4127,10 @@ int b43_radio_selectchannel(struct b43_w
 		b43_write16(dev, 0x03F0, freq);
 		b43_radio_write16(dev, 0x0008, r8);
 
-		TODO();		//TODO: write max channel TX power? to Radio 0x2D
+		//TODO: write max channel TX power? to Radio 0x2D
 		tmp = b43_radio_read16(dev, 0x002E);
 		tmp &= 0x0080;
-		TODO();		//TODO: OR tmp with the Power out estimation for this channel?
+		//TODO: OR tmp with the Power out estimation for this channel?
 		b43_radio_write16(dev, 0x002E, tmp);
 
 		if (freq >= 4920 && freq <= 5500) {
@@ -4165,7 +4165,7 @@ int b43_radio_selectchannel(struct b43_w
 		b43_radio_write16(dev, 0x0035, (b43_radio_read16(dev, 0x0035)
 						& 0xFFEF) | 0x0010);
 		b43_radio_set_tx_iq(dev);
-		TODO();		//TODO: TSSI2dbm workaround
+		//TODO: TSSI2dbm workaround
 		b43_phy_xmitpower(dev);	//FIXME correct?
 	} else {
 		if ((channel < 1) || (channel > 14))
@@ -4295,7 +4295,6 @@ static void b43_radio_set_txpower_a(stru
 
 	phy->txpwr_offset = txpower;
 
-	TODO();
 	//TODO: FuncPlaceholder (Adjust BB loft cancel)
 }
 


From celejar at gmail.com  Sun Sep  9 22:20:05 2007
From: celejar at gmail.com (Celejar)
Date: Sun, 9 Sep 2007 16:20:05 -0400
Subject: Screen flicker
In-Reply-To: <e67787dd0709062216i5599a940v8ea0ae64523d882a@mail.gmail.com>
References: <20070904155208.af073560.celejar@gmail.com>
	<46DDBC69.9020708@lwfinger.net>
	<e67787dd0709041335s70651867p4b75e6e1b6b4b459@mail.gmail.com>
	<20070906150110.8c0874ec.celejar@gmail.com>
	<e67787dd0709062216i5599a940v8ea0ae64523d882a@mail.gmail.com>
Message-ID: <20070909162005.3eaa8442.celejar@gmail.com>

On Fri, 7 Sep 2007 01:16:35 -0400
Nkoli <coomac at gmail.com> wrote:

> On 9/6/07, Celejar <celejar at gmail.com> wrote:
> >
> >
> > My experience: I've *only* seen it with the Broadcom card in use (and
> > only with bcm43xx, not ndiswrapper), never at boot, and never with the
> > interface down, as per my response to Larry.
> >
> > Celejar
> > --
> >
> >
> I did a quick google search for acer laptop flicker. It seems,
> unfortunately, that flickering is all too common with some acer laptops, as
> in here<http://forum.notebookreview.com/showthread.php?s=b22aa0202caf39b754ac5b91e2946f41&t=13038>and
> here <http://www.howtofixcomputers.com/bb/ftopic206895.html>. It might be a
> different issue in your case. I really wouldn't know. Too bad it's too
> random to attempt a reliable reproduction with a different setup
> (ndiswrapper, windows, etc).

Thanks for the links.  My problem seems to be more closely related to
the wireless system than those of the posters on those sites; indeed,
that's why I originally posted here, since the flicker seemed to be so
closely coupled to the bcm43xx driver.  It's certainly possible,
though, for anything that I know, that it's a hardware bug that just
happens, on my machine, to be triggered by some perfectly legitimate
bit of the bcm43xx code.

Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator



From achrisjo at yahoo.com  Mon Sep 10 01:24:18 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Sun, 9 Sep 2007 16:24:18 -0700 (PDT)
Subject: Any hope ?
Message-ID: <733659.29949.qm@web63714.mail.re1.yahoo.com>

Hmmm...why didn't yahoo include the list ?.. 

"Arne Chr. Jorgensen" <achrisjo at yahoo.com> wrote: hi,

In my dialog with Larry, I asked:
>
> Well, just some idea.  Perhaps I could install Suse, replicate your 
> settings and check it ?
> 

Now, I am running OpenSuse 10.2, with default x86_86 kernel 2.6.18.2-34.
I am unfamilar with Suse, and a bit unsure as how to set it up. 
At the moment it uses a Vesa frame buffer device, and perhaps I should
try to compile a NVIDIA driver - any suggestions ? 

( did try once, but didn't get it working)

Next, I had to download and install nForceth driver from NVIDIA, as the wire
ethernet wouldn't be recognized. Then I have got some code installed to control the "tapping" feature of the touchpad.

As reported earlier, the Fedora update kernels had the machine go crazy.
So even with the "tapping enabled" in Suse, the behaviour isn't as wild as
it was with Fedora. Perhaps Fedora kernels don't recognize the AMD stuff.

My confusion have had something to do  with the impression that in one particular install - I had wireless up.  I still cannot swear it, I could have been fooled by something it pulled up from the cache, but as I have
said - this wasn't my impression. I have been checking pages all over to figure out this thing. In the end I did open this damn thing, to see what this card looked like. 

Surprise - the chips says BCM4311KFBG... what the heck ?? Checking data at
HP, which says what I have reported earlier. But in the end I found some
partlist that seems to operate with two different part numbers, not saying
what the chip set might be, but there is 2 and 3 wire antenna versions.

Checking registry in Vista - reveals Broadcom..and then 4312 ? 

Larry wrote:
>
> This is exactly the computer I have. The wireless is a BCM4311. 
>

( take it that your wireless is working, that there is some driver for it ?)

If so, then what do I need to do ?

As I  did mention earlier Larry, your hardware didn't seem that far apart from
mine. Perhaps you have some configuration file, what options need to be included in compiling a kernel ?  ( There are a whole lot of options that
I don't have a clue what they are for. )

Oh, by the way - in Suse, I have no sound. (HD Audio-Conexant CX20549-12)
- according to the info pages from HP. ( did come up in Fedora )

Looking at those specifications from HP again - it does say:

"Broadcom 4321AGN Wi-Fi Adapter (802.11 a/b/g/ draft-n) + Bluetooth w/2      antennas"

But as I checked inside, Bluetooth is supported by a separate card. ( Broadcom, as far as I know..does have some designs with Bluetooth - but in
this case, the blue tooth don't seem to have any relation to Broadcom )
Also.. using the Serial number, service number, or any number - will lead
you to this info from HP, - so at least I was made to believe the info  was
correct. 

( Sorry about the length, but - in case someone else got fooled like I have
been )

So.. where do I go from here ?

//ARNE


        

---------------------------------
Luggage? GPS? Comic books? 
 Check out fitting  gifts for grads at Yahoo! Search.

       
---------------------------------
Be a better Globetrotter. Get better travel answers from someone who knows.
Yahoo! Answers - Check it out.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070909/e5c9c00d/attachment.html>

From comphappy at gmail.com  Mon Sep 10 01:49:29 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sun, 9 Sep 2007 16:49:29 -0700
Subject: Any hope ?
In-Reply-To: <733659.29949.qm@web63714.mail.re1.yahoo.com>
References: <733659.29949.qm@web63714.mail.re1.yahoo.com>
Message-ID: <b2d05de20709091649k352dc1a7t1e3d6685eed995f0@mail.gmail.com>

On 9/9/07, Arne Chr. Jorgensen <achrisjo at yahoo.com> wrote:
> Hmmm...why didn't yahoo include the list ?..
>
> "Arne Chr. Jorgensen" <achrisjo at yahoo.com> wrote:
>  hi,
>
> In my dialog with Larry, I asked:
> >
> > Well, just some idea.  Perhaps I could install Suse, replicate your
> > settings and check it ?
> >
>
> Now, I am running OpenSuse 10.2, with default x86_86 kernel 2.6.18.2-34.
> I am unfamilar with Suse, and a bit unsure as how to set it up.
> At the moment it uses a Vesa frame buffer device, and perhaps I should
> try to compile a NVIDIA driver - any suggestions ?
>
> ( did try once, but didn't get it working)
>
> Next, I had to download and install nForceth driver from NVIDIA, as the wire
> ethernet wouldn't be recognized. Then I have got some code installed to
> control the "tapping" feature of the touchpad.
>
> As reported earlier, the Fedora update kernels had the machine go crazy.
> So even with the "tapping enabled" in Suse, the behaviour isn't as wild as
> it was with Fedora. Perhaps Fedora kernels don't recognize the AMD stuff.
>
> My confusion have had something to do with the impression that in one
> particular install - I had wireless up.  I still cannot swear it, I could
> have been fooled by something it pulled up from the cache, but as I have
> said - this wasn't my impression. I have been checking pages all over to
> figure out this thing. In the end I did open this damn thing, to see what
> this card looked like.
>
> Surprise - the chips says BCM4311KFBG... what the heck ?? Checking data at
> HP, which says what I have reported earlier. But in the end I found some
> partlist that seems to operate with two different part numbers, not saying
> what the chip set might be, but there is 2 and 3 wire antenna versions.
>
> Checking registry in Vista - reveals Broadcom..and then 4312 ?
>
> Larry wrote:
> >
> > This is exactly the computer I have. The wireless is a BCM4311.
> >
>
> ( take it that your wireless is working, that there is some driver for it ?)
> Looking at those specifications from HP again - it does say:
>
> "Broadcom 4321AGN Wi-Fi Adapter (802.11 a/b/g/ draft-n) + Bluetooth w/2
> antennas"

As was said before there are no supported Broadcom Wireless draft-n
cards, why DRAFT-n has caught on so much is beond me, its not even the
real deal yet. So you have three options return and get a new laptop,
fight with finding a card that your computer wont reject (some people
have had all kinds of problems tricking there computer to think the
card is the one it came with), or get a USB wireless stick.
> >
> So.. where do I go from here ?
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
>


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows XP or better'. So I installed Linux"


From coomac at gmail.com  Mon Sep 10 02:19:20 2007
From: coomac at gmail.com (Nkoli)
Date: Sun, 9 Sep 2007 20:19:20 -0400
Subject: Any hope ?
In-Reply-To: <733659.29949.qm@web63714.mail.re1.yahoo.com>
References: <733659.29949.qm@web63714.mail.re1.yahoo.com>
Message-ID: <e67787dd0709091719x1875e23cxa67b398571dcaaed@mail.gmail.com>

Hey Arne,

Just a few things about running opensuse 10.2. Suse's tapping recognition
has been excellent on every single laptop I've tried in on, so not quite
sure why you'd need extra code for it. The default kernel is obsolete and
like Larry says, > 2.6.21 is where the good stuff is at. My advice would be
to update the kernel right away... that might fix the lack of sound. Here's
the factory kernel repo:
http://download.opensuse.org/repositories/Kernel:/HEAD/openSUSE_Factory(this
is in development and constantly updated, but I'm using it in
10.3 and haven't had any issues with the current version at least). If that
doesn't help, you might want to check Yast / Hardware / Sound to see what's
going on there.

The nvidia driver is best downloaded from nvidia's website (there may be a
current official repo, but I don't know since I'm stuck with ATI).
Installation is very straightforward and pretty much a breeze. You probably
won't be able to get the bcm43xx driver working with your wireless card, but
if you really want to give it a good shot, fwcutter is in the net install
repo:
http://download.opensuse.org/distribution/SL-OSS-factory/inst-source/suseand
you can get the firmware off the net if you don't already have it. You
can always check Yast / Network Devices / Network Card to see what suse is
doing with your network cards. As Gene said, your best bet to get that
particular card working is probably to use ndiswrapper. Goodluck.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070909/399e7fe4/attachment.html>

From coomac at gmail.com  Mon Sep 10 02:34:45 2007
From: coomac at gmail.com (Nkoli)
Date: Sun, 9 Sep 2007 20:34:45 -0400
Subject: Screen flicker
In-Reply-To: <20070909162005.3eaa8442.celejar@gmail.com>
References: <20070904155208.af073560.celejar@gmail.com>
	<46DDBC69.9020708@lwfinger.net>
	<e67787dd0709041335s70651867p4b75e6e1b6b4b459@mail.gmail.com>
	<20070906150110.8c0874ec.celejar@gmail.com>
	<e67787dd0709062216i5599a940v8ea0ae64523d882a@mail.gmail.com>
	<20070909162005.3eaa8442.celejar@gmail.com>
Message-ID: <e67787dd0709091734v4fd01563n18273adf1a11a4ce@mail.gmail.com>

On 9/9/07, Celejar <celejar at gmail.com> wrote:

> Thanks for the links.  My problem seems to be more closely related to
> the wireless system than those of the posters on those sites; indeed,
> that's why I originally posted here, since the flicker seemed to be so
> closely coupled to the bcm43xx driver.  It's certainly possible,
> though, for anything that I know, that it's a hardware bug that just
> happens, on my machine, to be triggered by some perfectly legitimate
> bit of the bcm43xx code.
>
> Celejar
> --


You're right, it's definitely worth looking into. Please post any clues you
run into... it would be worth finding out whether the driver is exposing the
infamous acer flicker or something else.

Cheers.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070909/dae970c1/attachment.html>

From larry.finger at lwfinger.net  Mon Sep 10 02:38:59 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 09 Sep 2007 19:38:59 -0500
Subject: Any hope ?
In-Reply-To: <733659.29949.qm@web63714.mail.re1.yahoo.com>
References: <733659.29949.qm@web63714.mail.re1.yahoo.com>
Message-ID: <46E49223.8060004@lwfinger.net>

Arne Chr. Jorgensen wrote:
> Hmmm...why didn't yahoo include the list ?..
> 
> */"Arne Chr. Jorgensen" <achrisjo at yahoo.com>/* wrote:
> 
>     hi,
> 
>     In my dialog with Larry, I asked:
>     >
>     > Well, just some idea.  Perhaps I could install Suse, replicate your
>     > settings and check it ?
>     >
> 
>     Now, I am running OpenSuse 10.2, with default x86_86 kernel 2.6.18.2-34.
>     I am unfamilar with Suse, and a bit unsure as how to set it up.
>     At the moment it uses a Vesa frame buffer device, and perhaps I should
>     try to compile a NVIDIA driver - any suggestions ?
> 
>     ( did try once, but didn't get it working)
> 
>     Next, I had to download and install nForceth driver from NVIDIA, as
>     the wire
>     ethernet wouldn't be recognized. Then I have got some code installed
>     to control the "tapping" feature of the touchpad.
> 
>     As reported earlier, the Fedora update kernels had the machine go crazy.
>     So even with the "tapping enabled" in Suse, the behaviour isn't as
>     wild as
>     it was with Fedora. Perhaps Fedora kernels don't recognize the AMD
>     stuff.
> 
>     My confusion have had something to do with the impression that in
>     one particular install - I had wireless up.  I still cannot swear
>     it, I could have been fooled by something it pulled up from the
>     cache, but as I have
>     said - this wasn't my impression. I have been checking pages all
>     over to figure out this thing. In the end I did open this damn
>     thing, to see what this card looked like.
> 
>     Surprise - the chips says BCM4311KFBG... what the heck ?? Checking
>     data at
>     HP, which says what I have reported earlier. But in the end I found some
>     partlist that seems to operate with two different part numbers, not
>     saying
>     what the chip set might be, but there is 2 and 3 wire antenna versions.
> 
>     Checking registry in Vista - reveals Broadcom..and then 4312 ?
> 
>     Larry wrote:
>     >
>     > This is exactly the computer I have. The wireless is a BCM4311.
>     >
> 
>     ( take it that your wireless is working, that there is some driver
>     for it ?)
> 
>     If so, then what do I need to do ?
> 
>     As I did mention earlier Larry, your hardware didn't seem that far
>     apart from
>     mine. Perhaps you have some configuration file, what options need to
>     be included in compiling a kernel ?  ( There are a whole lot of
>     options that
>     I don't have a clue what they are for. )
> 
>     Oh, by the way - in Suse, I have no sound. (HD Audio-Conexant
>     CX20549-12)
>     - according to the info pages from HP. ( did come up in Fedora )
> 
>     Looking at those specifications from HP again - it does say:
> 
>     "Broadcom 4321AGN Wi-Fi Adapter (802.11 a/b/g/ draft-n) + Bluetooth
>     w/2      antennas"
> 
>     But as I checked inside, Bluetooth is supported by a separate card.
>     ( Broadcom, as far as I know..does have some designs with Bluetooth
>     - but in
>     this case, the blue tooth don't seem to have any relation to Broadcom )
>     Also.. using the Serial number, service number, or any number - will
>     lead
>     you to this info from HP, - so at least I was made to believe the
>     info was
>     correct.
> 
>     ( Sorry about the length, but - in case someone else got fooled like
>     I have
>     been )
> 
>     So.. where do I go from here ?

For the most part, I have stopped answering your posts because you don't seem to understand what I
say, and you ramble without making your thoughts clear. I will, however, tell you how to disable
tapping and make your touchpad more easily usable. You need to apply this patch:

Index: /etc/X11/xorg.conf
===================================================================
--- .orig/etc/X11/xorg.conf
+++ /etc/X11/xorg.conf
@@ -79,6 +79,8 @@ Section "InputDevice"
   Option       "SHMConfig" "on"
   Option       "Vendor" "Sysp"
   Option       "ZAxisMapping" "4 5"
+  Option       "HorizScrollDelta" "0"
+  Option       "MaxTapTime" "0"
 EndSection

 Section "InputDevice"
@@ -141,6 +143,7 @@ Section "Device"
   Driver       "nv"
   Identifier   "Device[0]"
   VendorName   "NVidia"
+  Option       "HWCursor" "off"
 EndSection


As you can see, this patch is a change in X11, not the openSUSE stuff directly. FWI, I only use the
frame buffer. I cannot be bothered with having to rebuild the binary module for the closed-source
driver. In addition, the tainted kernel would be the kiss of death for me.

I always disable tapping on every laptop I use. Perhaps it is my internal capacitance or some other
characteristic of mine, but I always get extraneous mouse events when tapping is enabled.

Larry


From achrisjo at yahoo.com  Mon Sep 10 05:36:14 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Sun, 9 Sep 2007 20:36:14 -0700 (PDT)
Subject: Any hope ?
Message-ID: <972181.54396.qm@web63702.mail.re1.yahoo.com>

hi,

I am very sorry !  I am dead tired - have been working for 10 days on these
problems, - constantly. 

Larry wrote:
> For the most part, I have stopped answering your posts because you
> don't seem to understand what I say, and you ramble without making your 
> thoughts clear.

Sorry, see above.  The objective here is the wireless !!

( sorry about the distraction regarding the tapping - as with power button,
other buttons, it wrongly connect to something with recent Fedora kernels. Okay, lets drop it ! )

Documentations from Hewlet-Packard is wrong !  The chip I found inside, IS
a BCM4311KFBG/HDO717 P20 /819737B5.

- Is that understood ?! 

( in my last post - I quoted exactly what HP says, and they are lying ! What
I tried to convey, so others may be warned about it )

Larry wrote earlier:
>    
> This is exactly the computer I have. The wireless is a BCM4311.
>     

I said: if I understood you correctly, you do have this working, and
if so - there is a driver for it ??

( And here I don't mean a ndiswrapper )

                        -----------------------

My last question had to do with kernel configuration for including a driver
for the 4311 or as Vista seem to identify it: 4312.  
What needs to be done ?


//ARNE

- hope this will clear up the issues. 


       
---------------------------------
Got a little couch potato? 
Check out fun summer activities for kids.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070909/a1d83092/attachment.html>

From comphappy at gmail.com  Mon Sep 10 05:59:33 2007
From: comphappy at gmail.com (Brennan Ashton)
Date: Sun, 9 Sep 2007 20:59:33 -0700
Subject: Any hope ?
In-Reply-To: <972181.54396.qm@web63702.mail.re1.yahoo.com>
References: <972181.54396.qm@web63702.mail.re1.yahoo.com>
Message-ID: <b2d05de20709092059wba150ehd1ea9bea76998afb@mail.gmail.com>

On 9/9/07, Arne Chr. Jorgensen <achrisjo at yahoo.com> wrote:
> hi,
>
> I am very sorry !  I am dead tired - have been working for 10 days on these
> problems, - constantly.
>
> Larry wrote:
> > For the most part, I have stopped answering your posts because you
> > don't seem to understand what I say, and you ramble without making your
> > thoughts clear.
>
> Sorry, see above.  The objective here is the wireless !!
>
> ( sorry about the distraction regarding the tapping - as with power button,
> other buttons, it wrongly connect to something with recent Fedora kernels.
> Okay, lets drop it ! )
>
> Documentations from Hewlet-Packard is wrong !  The chip I found inside, IS
> a BCM4311KFBG/HDO717 P20 /819737B5.
>
> - Is that understood ?!
>
> ( in my last post - I quoted exactly what HP says, and they are lying ! What
> I tried to convey, so others may be warned about it )
>
> Larry wrote earlier:
> >
> > This is exactly the computer I have. The wireless is a BCM4311.
> >
>
> I said: if I understood you correctly, you do have this working, and
> if so - there is a driver for it ??

git the wireless dev git-pull
git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-dev.git/
compile with b43 not the b43legacy
get the newer fwcutter from the cvs on the bcm43xx page
get the firmware from here
http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2
and extract it with fwcutter

sorry for be sort of vague but i have given these directions in
various detail various times you can find more in the archives if you
need it. Fedora 7 has given me and others some greef in the past
getting it to work, i found F6 more cooperative.

>
> ( And here I don't mean a ndiswrapper )
>
>                         -----------------------
>
> My last question had to do with kernel configuration for including a driver
> for the 4311 or as Vista seem to identify it: 4312.
> What needs to be done ?
>
>
> //ARNE
>
> - hope this will clear up the issues.
>
>
>
>  ________________________________
> Got a little couch potato?
>  Check out fun summer activities for kids.
>
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
>


-- 
Brennan Ashton
Bellingham, Washington

"The box said, 'Requires Windows XP or better'. So I installed Linux"


From achrisjo at yahoo.com  Mon Sep 10 06:04:25 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Sun, 9 Sep 2007 21:04:25 -0700 (PDT)
Subject: Any hope ?
In-Reply-To: <e67787dd0709091719x1875e23cxa67b398571dcaaed@mail.gmail.com>
Message-ID: <589513.98383.qm@web63703.mail.re1.yahoo.com>

hi,

Thanks Nkoli,

I just downloaded:

kernel-default-2.6.22.5-265.1.x86_64.rpm
kernel-syms, and kernel-source.

One question: there was a kernel-rt    as well  -  is that  a  realtime  kernel  ?

( as unbelieveable it may sound, I did spend years participating in the first real time kernel for Linux.. but I must have lost some braincells since then ;)

//ARNE



       
---------------------------------
Boardwalk for $500? In 2007? Ha! 
Play Monopoly Here and Now (it's updated for today's economy) at Yahoo! Games.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070909/0f571d27/attachment.html>

From johannes at sipsolutions.net  Mon Sep 10 12:57:25 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Mon, 10 Sep 2007 12:57:25 +0200
Subject: [PATCH, fwcutter] add support for DragonFlyBSD
In-Reply-To: <ea7b9c170709082246w14a8253fr1102f48a5130e09e@mail.gmail.com>
References: <ea7b9c170709080008s2ca6322djff501a0f8b1405e5@mail.gmail.com>
	<1189311979.4809.19.camel@dv>
	<ea7b9c170709082246w14a8253fr1102f48a5130e09e@mail.gmail.com>
Message-ID: <1189421845.4506.49.camel@johannes.berg>

On Sun, 2007-09-09 at 13:46 +0800, Sepherosa Ziehau wrote:

> Updated patch is at:
> http://leaf.dragonflybsd.org/~sephe/fwcutter1.diff
> 
> Please review it, thanks.

I think Pavel suggested you collapse it to:

#ifdef __DragonFly__
#include <sys/endian.h>
#define bswap_16(v)	bswap16((v))
#define bswap_32(v)	bswap32((v))
#else
#include <byteswap.h>
#endif

And maybe all BSDs have sys/endian.h so you could do #ifdef __BSD__ or
something?


I would, however, keep the name thing out of the same ifdef and under
DragonFly to indicate that it is what dfly wants at this time.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070910/a40dc089/attachment.pgp>

From mb at bu3sch.de  Mon Sep 10 13:22:26 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 10 Sep 2007 13:22:26 +0200
Subject: Propose for relicensing fwcutter under BSD
In-Reply-To: <ea7b9c170709082023h437ae68fkab70014cdae87c93@mail.gmail.com>
References: <ea7b9c170709080015s544e21c6q159ab2c7e628f2a5@mail.gmail.com>
	<200709081630.03005.mb@bu3sch.de>
	<ea7b9c170709082023h437ae68fkab70014cdae87c93@mail.gmail.com>
Message-ID: <200709101322.26336.mb@bu3sch.de>

On Sunday 09 September 2007 05:23:28 Sepherosa Ziehau wrote:
> On 9/8/07, Michael Buesch <mb at bu3sch.de> wrote:
> > On Saturday 08 September 2007 13:45:53 Martin Langer wrote:
> > > On Sat, Sep 08, 2007 at 03:15:17PM +0800, Sepherosa Ziehau wrote:
> > > > Hi all,
> > > >
> > > > Would you consider relicense fwcutter under BSDL?  The driver in
> > > > DragonFlyBSD depends on the firmware files produced by fwcutter and I
> > > > don't want to "reinvent the wheel", so I want to put it into our base
> > > > system.
> > > >
> > > > I think Johannes and Michael are OK with it.
> > >
> > > Same here. No objections from my side.
> >
> > Ok, so I'll patch it.
> > Sepherosa, is something like the following OK?
> 
> Yah, thanks!

I committed the change.

-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Mon Sep 10 17:32:09 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 10 Sep 2007 10:32:09 -0500
Subject: [PATCH] b43legacy: Add debugfs file to dump microcode registers
Message-ID: <46e56379.mCmo8qy1TlkjFpJ9%Larry.Finger@lwfinger.net>

From: Michael Buesch <mb at bu3sch.de>

This adds a debugfs file to dump all microcode registers.
Note that the dumping is racy, as microcode continues to run
while we loop over each register to dump it.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Signed-off-by: Larry Finger <larry.finger at lwfinger.net>

Index: wireless-dev/drivers/net/wireless/b43legacy/debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/debugfs.c
+++ wireless-dev/drivers/net/wireless/b43legacy/debugfs.c
@@ -151,6 +151,39 @@ out_unlock_bb:
 	return res;
 }
 
+static ssize_t ucode_regs_read_file(struct file *file, char __user * userbuf,
+				    size_t count, loff_t * ppos)
+{
+	struct b43legacy_wldev *dev = file->private_data;
+	const size_t len = ARRAY_SIZE(big_buffer);
+	char *buf = big_buffer;
+	size_t pos = 0;
+	ssize_t res;
+	unsigned long flags;
+	int i;
+
+	mutex_lock(&big_buffer_mutex);
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {
+		fappend("Board not initialized.\n");
+		goto out;
+	}
+
+	for (i = 0; i < 64; i++) {
+		fappend("r%d = 0x%04x\n", i,
+			b43legacy_shm_read16(dev, B43legacy_SHM_WIRELESS, i));
+	}
+
+out:
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
+	mutex_unlock(&big_buffer_mutex);
+
+	return res;
+}
+
 static ssize_t power_read_file(struct file *file, char __user *userbuf,
 			     size_t count, loff_t *ppos)
 {
@@ -344,6 +377,11 @@ static struct file_operations tsf_fops =
 	.open = open_file_generic,
 };
 
+static struct file_operations ucode_regs_fops = {
+	.read = ucode_regs_read_file,
+	.open = open_file_generic,
+};
+
 static struct file_operations txstat_fops = {
 	.read = txstat_read_file,
 	.write = write_file_dummy,
@@ -442,6 +480,10 @@ void b43legacy_debugfs_add_device(struct
 					     dev, &tsf_fops);
 	if (IS_ERR(e->dentry_tsf))
 		e->dentry_tsf = NULL;
+	e->dentry_ucode_regs = debugfs_create_file("ucode_regs", 0400, e->subdir,
+						   dev, &ucode_regs_fops);
+	if (IS_ERR(e->dentry_ucode_regs))
+		e->dentry_ucode_regs = NULL;
 	e->dentry_txstat = debugfs_create_file("tx_status", 0400, e->subdir,
 						dev, &txstat_fops);
 	if (IS_ERR(e->dentry_txstat))
@@ -471,6 +513,7 @@ void b43legacy_debugfs_remove_device(str
 		return;
 	b43legacy_remove_dynamic_debug(dev);
 	debugfs_remove(e->dentry_tsf);
+	debugfs_remove(e->dentry_ucode_regs);
 	debugfs_remove(e->dentry_txstat);
 	debugfs_remove(e->dentry_restart);
 	debugfs_remove(e->dentry_power);
Index: wireless-dev/drivers/net/wireless/b43legacy/debugfs.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/debugfs.h
+++ wireless-dev/drivers/net/wireless/b43legacy/debugfs.h
@@ -32,6 +32,7 @@ struct b43legacy_txstatus_log {
 struct b43legacy_dfsentry {
 	struct dentry *subdir;
 	struct dentry *dentry_tsf;
+	struct dentry *dentry_ucode_regs;
 	struct dentry *dentry_txstat;
 	struct dentry *dentry_restart;
 	struct dentry *dentry_power;


From Larry.Finger at lwfinger.net  Mon Sep 10 17:33:21 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 10 Sep 2007 10:33:21 -0500
Subject: [PATCH] b43legacy: Add debugfs file to dump shared memory
Message-ID: <46e563c1./VcIP+GCZUv+o4RX%Larry.Finger@lwfinger.net>

From: Michael Buesch <mb at bu3sch.de>

This adds a file to dump the SHM.
Note that SHM dumping is racy, as the microcode continues to run
while we dump the SHM.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Signed-off-by: Larry Finger <larry.finger at lwfinger.net>
---

Index: wireless-dev/drivers/net/wireless/b43legacy/debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/debugfs.c
+++ wireless-dev/drivers/net/wireless/b43legacy/debugfs.c
@@ -151,6 +151,42 @@ out_unlock_bb:
 	return res;
 }
 
+static ssize_t shm_read_file(struct file *file, char __user * userbuf,
+			     size_t count, loff_t * ppos)
+{
+	struct b43legacy_wldev *dev = file->private_data;
+	const size_t len = ARRAY_SIZE(big_buffer);
+	u8 *buf = big_buffer;
+	__le16 *le16buf = (__le16*)big_buffer;
+	size_t pos = 0;
+	ssize_t res;
+	unsigned long flags;
+	int i;
+	u16 tmp;
+
+	mutex_lock(&big_buffer_mutex);
+	mutex_lock(&dev->wl->mutex);
+	spin_lock_irqsave(&dev->wl->irq_lock, flags);
+	if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {
+		fappend("Board not initialized.\n");
+		goto out;
+	}
+
+	for (i = 0; i < 0x1000; i++) {
+		tmp = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED, 2 * i);
+		le16buf[i] = cpu_to_le16(tmp);
+		pos += sizeof(tmp);
+	}
+
+out:
+	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
+	mutex_unlock(&dev->wl->mutex);
+	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
+	mutex_unlock(&big_buffer_mutex);
+
+	return res;
+}
+
 static ssize_t ucode_regs_read_file(struct file *file, char __user * userbuf,
 				    size_t count, loff_t * ppos)
 {
@@ -382,6 +418,11 @@ static struct file_operations ucode_regs
 	.open = open_file_generic,
 };
 
+static struct file_operations shm_fops = {
+	.read = shm_read_file,
+	.open = open_file_generic,
+};
+
 static struct file_operations txstat_fops = {
 	.read = txstat_read_file,
 	.write = write_file_dummy,
@@ -484,6 +525,10 @@ void b43legacy_debugfs_add_device(struct
 						   dev, &ucode_regs_fops);
 	if (IS_ERR(e->dentry_ucode_regs))
 		e->dentry_ucode_regs = NULL;
+	e->dentry_shm = debugfs_create_file("shm", 0400, e->subdir,
+					    dev, &shm_fops);
+	if (IS_ERR(e->dentry_shm))
+		e->dentry_shm = NULL;
 	e->dentry_txstat = debugfs_create_file("tx_status", 0400, e->subdir,
 						dev, &txstat_fops);
 	if (IS_ERR(e->dentry_txstat))
@@ -514,6 +559,7 @@ void b43legacy_debugfs_remove_device(str
 	b43legacy_remove_dynamic_debug(dev);
 	debugfs_remove(e->dentry_tsf);
 	debugfs_remove(e->dentry_ucode_regs);
+	debugfs_remove(e->dentry_shm);
 	debugfs_remove(e->dentry_txstat);
 	debugfs_remove(e->dentry_restart);
 	debugfs_remove(e->dentry_power);
Index: wireless-dev/drivers/net/wireless/b43legacy/debugfs.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/debugfs.h
+++ wireless-dev/drivers/net/wireless/b43legacy/debugfs.h
@@ -33,6 +33,7 @@ struct b43legacy_dfsentry {
 	struct dentry *subdir;
 	struct dentry *dentry_tsf;
 	struct dentry *dentry_ucode_regs;
+	struct dentry *dentry_shm;
 	struct dentry *dentry_txstat;
 	struct dentry *dentry_restart;
 	struct dentry *dentry_power;


From Larry.Finger at lwfinger.net  Mon Sep 10 17:35:03 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 10 Sep 2007 10:35:03 -0500
Subject: [PATCH] b43legacy: Simplify debugfs
Message-ID: <46e56427.mxTGpcMPk134swg1%Larry.Finger@lwfinger.net>

From: Michael Buesch <mb at bu3sch.de>

This is a major cleanup and simplification of the debugfs
infrastructure. All the debugfs related FS handling code (copy_*_user, etc...)
and the locking is handled in common functions. The debugging implementation
files only have to care about their actual job anymore.
This shrinks the function size.

A few macros were also added to simplify adding new files.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Signed-off-by: Larry Finger <larry.finger at lwfinger.net>
---

 drivers/net/wireless/b43legacy/debugfs.c |  652 ++++++++++++-------------------
 drivers/net/wireless/b43legacy/debugfs.h |   29 -
 2 files changed, 287 insertions(+), 394 deletions(-)


Index: wireless-dev/drivers/net/wireless/b43legacy/debugfs.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/debugfs.h
+++ wireless-dev/drivers/net/wireless/b43legacy/debugfs.h
@@ -23,22 +23,26 @@ struct dentry;
 struct b43legacy_txstatus_log {
 	struct b43legacy_txstatus *log;
 	int end;
-	int printing;
-	char printbuf[(B43legacy_NR_LOGGED_TXSTATUS * 70) + 200];
-	size_t buf_avail;
 	spinlock_t lock;	/* lock for debugging */
 };
 
+struct b43legacy_dfs_file {
+	struct dentry *dentry;
+	char *buffer;
+	size_t data_len;
+};
+
 struct b43legacy_dfsentry {
+	struct b43legacy_wldev *dev;
 	struct dentry *subdir;
-	struct dentry *dentry_tsf;
-	struct dentry *dentry_ucode_regs;
-	struct dentry *dentry_shm;
-	struct dentry *dentry_txstat;
-	struct dentry *dentry_restart;
-	struct dentry *dentry_power;
 
-	struct b43legacy_wldev *dev;
+	struct b43legacy_dfs_file file_tsf;
+	struct b43legacy_dfs_file file_ucode_regs;
+	struct b43legacy_dfs_file file_shm;
+	struct b43legacy_dfs_file file_txstat;
+	struct b43legacy_dfs_file file_txpower_g;
+	struct b43legacy_dfs_file file_restart;
+	struct b43legacy_dfs_file file_loctls;
 
 	struct b43legacy_txstatus_log txstatlog;
 
@@ -48,11 +52,6 @@ struct b43legacy_dfsentry {
 	struct dentry *dyn_debug_dentries[__B43legacy_NR_DYNDBG];
 };
 
-struct b43legacy_debugfs {
-	struct dentry *root;
-	struct dentry *dentry_driverinfo;
-};
-
 int b43legacy_debug(struct b43legacy_wldev *dev,
 		    enum b43legacy_dyndbg feature);
 
Index: wireless-dev/drivers/net/wireless/b43legacy/debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/debugfs.c
+++ wireless-dev/drivers/net/wireless/b43legacy/debugfs.c
@@ -4,7 +4,7 @@
 
   debugfs driver debugging code
 
-  Copyright (c) 2005 Michael Buesch <mb at bu3sch.de>
+  Copyright (c) 2005-2007 Michael Buesch <mb at bu3sch.de>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -23,8 +23,6 @@
 
 */
 
-
-
 #include <linux/fs.h>
 #include <linux/debugfs.h>
 #include <linux/slab.h>
@@ -39,410 +37,317 @@
 #include "pio.h"
 #include "xmit.h"
 
-#define REALLY_BIG_BUFFER_SIZE	(1024 * 256)
 
-static struct b43legacy_debugfs fs;
-static char big_buffer[REALLY_BIG_BUFFER_SIZE];
-static DEFINE_MUTEX(big_buffer_mutex);
+/* The root directory. */
+struct dentry *rootdir;
 
+struct b43legacy_debugfs_fops {
+	ssize_t (*read)(struct b43legacy_wldev *dev, char *buf, size_t bufsize);
+	int (*write)(struct b43legacy_wldev *dev, const char *buf, size_t count);
+	struct file_operations fops;
+	/* Offset of struct b43legacy_dfs_file in struct b43legacy_dfsentry */
+	size_t file_struct_offset;
+	/* Take wl->irq_lock before calling read/write? */
+	bool take_irqlock;
+};
 
-static ssize_t write_file_dummy(struct file *file, const char __user *buf,
-				size_t count, loff_t *ppos)
+static inline
+struct b43legacy_dfs_file * fops_to_dfs_file(struct b43legacy_wldev *dev,
+				       const struct b43legacy_debugfs_fops *dfops)
 {
-	return count;
-}
+	void *p;
 
-static int open_file_generic(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
+	p = dev->dfsentry;
+	p += dfops->file_struct_offset;
+
+	return p;
 }
 
-#define fappend(fmt, x...)	pos += snprintf(buf + pos, len - pos, fmt , ##x)
 
-static ssize_t drvinfo_read_file(struct file *file, char __user *userbuf,
-				 size_t count, loff_t *ppos)
+#define fappend(fmt, x...)	\
+	do {							\
+		if (bufsize - count)				\
+			count += snprintf(buf + count,		\
+					  bufsize - count,	\
+					  fmt , ##x);		\
+		else						\
+			printk(KERN_ERR "b43legacy: fappend overflow\n"); \
+	} while (0)
+
+
+/* wl->irq_lock is locked */
+ssize_t tsf_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
 {
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-
-	mutex_lock(&big_buffer_mutex);
-	/* This is where the information is written to the "driver" file */
-	fappend(KBUILD_MODNAME " driver\n");
-	fappend("Compiled at: %s %s\n", __DATE__, __TIME__);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
-}
-
-static ssize_t tsf_read_file(struct file *file, char __user *userbuf,
-			     size_t count, loff_t *ppos)
-{
-	struct b43legacy_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 	u64 tsf;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43legacy_status(dev) < B43legacy_STAT_STARTED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
 	b43legacy_tsf_read(dev, &tsf);
 	fappend("0x%08x%08x\n",
 		(unsigned int)((tsf & 0xFFFFFFFF00000000ULL) >> 32),
 		(unsigned int)(tsf & 0xFFFFFFFFULL));
 
-out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return count;
 }
 
-static ssize_t tsf_write_file(struct file *file, const char __user *user_buf,
-			      size_t count, loff_t *ppos)
+/* wl->irq_lock is locked */
+int tsf_write_file(struct b43legacy_wldev *dev, const char *buf, size_t count)
 {
-	struct b43legacy_wldev *dev = file->private_data;
-	char *buf = big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags;
 	u64 tsf;
 
-	mutex_lock(&big_buffer_mutex);
-	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-		res = -EFAULT;
-		goto out_unlock_bb;
-	}
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43legacy_status(dev) < B43legacy_STAT_STARTED) {
-		b43legacyerr(dev->wl, "debugfs: Board not initialized.\n");
-		res = -EFAULT;
-		goto out_unlock;
-	}
-	if (sscanf(buf, "%llu", (unsigned long long *)(&tsf)) != 1) {
-		b43legacyerr(dev->wl, "debugfs: Invalid values for TSF\n");
-		res = -EINVAL;
-		goto out_unlock;
-	}
+	if (sscanf(buf, "%llu", (unsigned long long *)(&tsf)) != 1)
+		return -EINVAL;
 	b43legacy_tsf_write(dev, tsf);
-	mmiowb();
-	res = buf_size;
-
-out_unlock:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-out_unlock_bb:
-	mutex_unlock(&big_buffer_mutex);
 
-	return res;
+	return 0;
 }
 
-static ssize_t shm_read_file(struct file *file, char __user * userbuf,
-			     size_t count, loff_t * ppos)
+/* wl->irq_lock is locked */
+ssize_t ucode_regs_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43legacy_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	u8 *buf = big_buffer;
-	__le16 *le16buf = (__le16*)big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	ssize_t count = 0;
 	int i;
-	u16 tmp;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {
-		fappend("Board not initialized.\n");
-		goto out;
+	for (i = 0; i < 64; i++) {
+		fappend("r%d = 0x%04x\n", i,
+			b43legacy_shm_read16(dev, B43legacy_SHM_WIRELESS, i));
 	}
 
+	return count;
+}
+
+/* wl->irq_lock is locked */
+ssize_t shm_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
+{
+	ssize_t count = 0;
+	int i;
+	u16 tmp;
+	__le16 *le16buf = (__le16 *)buf;
+
 	for (i = 0; i < 0x1000; i++) {
+		if (bufsize <= 0)
+			break;
 		tmp = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED, 2 * i);
 		le16buf[i] = cpu_to_le16(tmp);
-		pos += sizeof(tmp);
+		count += sizeof(tmp);
+		bufsize -= sizeof(tmp);
 	}
 
-out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return count;
 }
 
-static ssize_t ucode_regs_read_file(struct file *file, char __user * userbuf,
-				    size_t count, loff_t * ppos)
+ssize_t txstat_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
 {
-	struct b43legacy_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
+	struct b43legacy_txstatus_log *log = &dev->dfsentry->txstatlog;
+	ssize_t count = 0;
 	unsigned long flags;
-	int i;
+	int i, idx;
+	struct b43legacy_txstatus *stat;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {
-		fappend("Board not initialized.\n");
-		goto out;
+	spin_lock_irqsave(&log->lock, flags);
+	if (log->end < 0) {
+		fappend("Nothing transmitted, yet\n");
+		goto out_unlock;
 	}
-
-	for (i = 0; i < 64; i++) {
-		fappend("r%d = 0x%04x\n", i,
-			b43legacy_shm_read16(dev, B43legacy_SHM_WIRELESS, i));
+	fappend("b43legacy TX status reports:\n\n"
+		"index | cookie | seq | phy_stat | frame_count | "
+		"rts_count | supp_reason | pm_indicated | "
+		"intermediate | for_ampdu | acked\n" "---\n");
+	i = log->end + 1;
+	idx = 0;
+	while (1) {
+		if (i == B43legacy_NR_LOGGED_TXSTATUS)
+			i = 0;
+		stat = &(log->log[i]);
+		if (stat->cookie) {
+			fappend("%03d | "
+				"0x%04X | 0x%04X | 0x%02X | "
+				"0x%X | 0x%X | "
+				"%u | %u | "
+				"%u | %u | %u\n",
+				idx,
+				stat->cookie, stat->seq, stat->phy_stat,
+				stat->frame_count, stat->rts_count,
+				stat->supp_reason, stat->pm_indicated,
+				stat->intermediate, stat->for_ampdu,
+				stat->acked);
+			idx++;
+		}
+		if (i == log->end)
+			break;
+		i++;
 	}
+out_unlock:
+	spin_unlock_irqrestore(&log->lock, flags);
 
-out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
+	return count;
 }
 
-static ssize_t power_read_file(struct file *file, char __user *userbuf,
-			     size_t count, loff_t *ppos)
+/* wl->irq_lock is locked */
+int restart_write_file(struct b43legacy_wldev *dev, const char *buf, size_t count)
 {
-	struct b43legacy_wldev *dev = file->private_data;
-	const size_t len = ARRAY_SIZE(big_buffer);
-	char *buf = big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
+	int err = 0;
 
-	mutex_lock(&big_buffer_mutex);
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43legacy_status(dev) < B43legacy_STAT_STARTED) {
-		fappend("Board not initialized.\n");
-		goto out;
-	}
-	fappend("%d dBm\n", dev->phy.power_level);
+	if (count > 0 && buf[0] == '1') {
+		b43legacy_controller_restart(dev, "manually restarted");
+	} else
+		err = -EINVAL;
 
-out:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	mutex_unlock(&dev->wl->mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	mutex_unlock(&big_buffer_mutex);
+	return err;
+}
+
+#undef fappend
 
-	return res;
+static int b43legacy_debugfs_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
 }
 
-static ssize_t power_write_file(struct file *file, const char __user *user_buf,
-			      size_t count, loff_t *ppos)
+static ssize_t b43legacy_debugfs_read(struct file *file, char __user *userbuf,
+				size_t count, loff_t *ppos)
 {
-	struct b43legacy_wldev *dev = file->private_data;
-	char *buf = big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags;
-	int power;
+	struct b43legacy_wldev *dev;
+	struct b43legacy_debugfs_fops *dfops;
+	struct b43legacy_dfs_file *dfile;
+	ssize_t ret = 0;
+	char *buf;
+	const size_t bufsize = 1024 * 128;
+	const size_t buforder = get_order(bufsize);
+	int err = 0;
+
+	if (!count)
+		return 0;
+	dev = file->private_data;
+	if (!dev)
+		return -ENODEV;
 
-	mutex_lock(&big_buffer_mutex);
-	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-		res = -EFAULT;
-		goto out_unlock_bb;
-	}
 	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43legacy_status(dev) < B43legacy_STAT_STARTED) {
-		b43legacyerr(dev->wl, "debugfs: Board not initialized.\n");
-		res = -EFAULT;
+	if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {
+		err = -ENODEV;
 		goto out_unlock;
 	}
-	if ((sscanf(buf, "%d", &power) != 1) || (power > 18 || power < 5)) {
-		b43legacyerr(dev->wl, "debugfs: Invalid values for power"
-			     " level\n");
-		res = -EINVAL;
+
+	dfops = container_of(file->f_op, struct b43legacy_debugfs_fops, fops);
+	if (!dfops->read) {
+		err = -ENOSYS;
 		goto out_unlock;
 	}
-	dev->phy.power_level = power;
-	res = buf_size;
+	dfile = fops_to_dfs_file(dev, dfops);
 
+	if (!dfile->buffer) {
+		buf = (char *)__get_free_pages(GFP_KERNEL, buforder);
+		if (!buf) {
+			err = -ENOMEM;
+			goto out_unlock;
+		}
+		memset(buf, 0, bufsize);
+		if (dfops->take_irqlock) {
+			spin_lock_irq(&dev->wl->irq_lock);
+			ret = dfops->read(dev, buf, bufsize);
+			spin_unlock_irq(&dev->wl->irq_lock);
+		} else
+			ret = dfops->read(dev, buf, bufsize);
+		if (ret <= 0) {
+			free_pages((unsigned long)buf, buforder);
+			err = ret;
+			goto out_unlock;
+		}
+		dfile->data_len = ret;
+		dfile->buffer = buf;
+	}
+
+	ret = simple_read_from_buffer(userbuf, count, ppos,
+				      dfile->buffer,
+				      dfile->data_len);
+	if (*ppos >= dfile->data_len) {
+		free_pages((unsigned long)dfile->buffer, buforder);
+		dfile->buffer = NULL;
+		dfile->data_len = 0;
+	}
 out_unlock:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
 	mutex_unlock(&dev->wl->mutex);
-out_unlock_bb:
-	mutex_unlock(&big_buffer_mutex);
 
-	return res;
+	return err ? err : ret;
 }
 
-static ssize_t txstat_read_file(struct file *file, char __user *userbuf,
-				size_t count, loff_t *ppos)
+static ssize_t b43legacy_debugfs_write(struct file *file,
+				 const char __user *userbuf,
+				 size_t count, loff_t *ppos)
 {
-	struct b43legacy_wldev *dev = file->private_data;
-	struct b43legacy_dfsentry *e = dev->dfsentry;
-	struct b43legacy_txstatus_log *log = &e->txstatlog;
-	unsigned long flags;
-	char *buf = log->printbuf;
-	const size_t len = ARRAY_SIZE(log->printbuf);
-	size_t pos = 0;
-	ssize_t res;
-	int i;
-	int idx;
-	struct b43legacy_txstatus *stat;
+	struct b43legacy_wldev *dev;
+	struct b43legacy_debugfs_fops *dfops;
+	char *buf;
+	int err = 0;
+
+	if (!count)
+		return 0;
+	if (count > PAGE_SIZE)
+		return -E2BIG;
+	dev = file->private_data;
+	if (!dev)
+		return -ENODEV;
 
-	mutex_lock(&big_buffer_mutex);
-	spin_lock_irqsave(&log->lock, flags);
-	if (!log->printing) {
-		log->printing = 1;
-		fappend("b43legacy TX status reports:\n\n"
-			"index | cookie | seq | phy_stat | frame_count | "
-			"rts_count | supp_reason | pm_indicated | "
-			"intermediate | for_ampdu | acked\n"
-			"---\n");
-		i = log->end + 1;
-		idx = 0;
-		while (1) {
-			if (log->end < 0) {
-				fappend("Nothing transmitted, yet\n");
-				break;
-			}
-			if (i == B43legacy_NR_LOGGED_TXSTATUS)
-				i = 0;
-			stat = &(log->log[i]);
-			if (stat->cookie) {
-				fappend("%03d | "
-					"0x%04X | 0x%04X | 0x%02X | "
-					"0x%X | 0x%X | "
-					"%u | %u | "
-					"%u | %u | %u\n",
-					idx,
-					stat->cookie, stat->seq, stat->phy_stat,
-					stat->frame_count, stat->rts_count,
-					stat->supp_reason, stat->pm_indicated,
-					stat->intermediate, stat->for_ampdu,
-					stat->acked);
-				idx++;
-			}
-			if (i == log->end)
-				break;
-			i++;
-		}
-		log->buf_avail = pos;
+	mutex_lock(&dev->wl->mutex);
+	if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {
+		err = -ENODEV;
+		goto out_unlock;
 	}
-	memcpy(big_buffer, buf,
-	       min(log->buf_avail, ARRAY_SIZE(big_buffer)));
-	spin_unlock_irqrestore(&log->lock, flags);
-
-	res = simple_read_from_buffer(userbuf, count, ppos,
-				      big_buffer,
-				      log->buf_avail);
-	if (*ppos == log->buf_avail) {
-		spin_lock_irqsave(&log->lock, flags);
-		log->printing = 0;
-		spin_unlock_irqrestore(&log->lock, flags);
-	}
-	mutex_unlock(&big_buffer_mutex);
-
-	return res;
-}
-
-static ssize_t restart_write_file(struct file *file,
-				  const char __user *user_buf,
-				  size_t count, loff_t *ppos)
-{
-	struct b43legacy_wldev *dev = file->private_data;
-	char *buf = big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags;
 
-	mutex_lock(&big_buffer_mutex);
-	buf_size = min(count, ARRAY_SIZE(big_buffer) - 1);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-		res = -EFAULT;
-		goto out_unlock_bb;
+	dfops = container_of(file->f_op, struct b43legacy_debugfs_fops, fops);
+	if (!dfops->write) {
+		err = -ENOSYS;
+		goto out_unlock;
 	}
-	mutex_lock(&dev->wl->mutex);
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {
-		b43legacyerr(dev->wl, "debugfs: Board not initialized.\n");
-		res = -EFAULT;
+
+	buf = (char *)get_zeroed_page(GFP_KERNEL);
+	if (!buf) {
+		err = -ENOMEM;
 		goto out_unlock;
 	}
-	if (count > 0 && buf[0] == '1') {
-		b43legacy_controller_restart(dev, "manually restarted");
-		res = count;
+	if (copy_from_user(buf, userbuf, count)) {
+		err = -EFAULT;
+		goto out_freepage;
+	}
+	if (dfops->take_irqlock) {
+		spin_lock_irq(&dev->wl->irq_lock);
+		err = dfops->write(dev, buf, count);
+		spin_unlock_irq(&dev->wl->irq_lock);
 	} else
-		res = -EINVAL;
+		err = dfops->write(dev, buf, count);
+	if (err)
+		goto out_freepage;
 
+out_freepage:
+	free_page((unsigned long)buf);
 out_unlock:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
 	mutex_unlock(&dev->wl->mutex);
-out_unlock_bb:
-	mutex_unlock(&big_buffer_mutex);
 
-	return res;
+	return err ? err : count;
 }
 
-#undef fappend
-
-
-static struct file_operations drvinfo_fops = {
-	.read = drvinfo_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
-
-static struct file_operations tsf_fops = {
-	.read = tsf_read_file,
-	.write = tsf_write_file,
-	.open = open_file_generic,
-};
-
-static struct file_operations ucode_regs_fops = {
-	.read = ucode_regs_read_file,
-	.open = open_file_generic,
-};
-
-static struct file_operations shm_fops = {
-	.read = shm_read_file,
-	.open = open_file_generic,
-};
-
-static struct file_operations txstat_fops = {
-	.read = txstat_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
 
-static struct file_operations restart_fops = {
-	.write = restart_write_file,
-	.open = open_file_generic,
-};
+#define B43legacy_DEBUGFS_FOPS(name, _read, _write, _take_irqlock)	\
+	static struct b43legacy_debugfs_fops fops_##name = {		\
+		.read	= _read,				\
+		.write	= _write,				\
+		.fops	= {					\
+			.open	= b43legacy_debugfs_open,		\
+			.read	= b43legacy_debugfs_read,		\
+			.write	= b43legacy_debugfs_write,		\
+		},						\
+		.file_struct_offset = offsetof(struct b43legacy_dfsentry, \
+					       file_##name),	\
+		.take_irqlock	= _take_irqlock,		\
+	}
 
-static struct file_operations power_fops = {
-	.read = power_read_file,
-	.write = power_write_file,
-	.open = open_file_generic,
-};
+B43legacy_DEBUGFS_FOPS(tsf, tsf_read_file, tsf_write_file, 1);
+B43legacy_DEBUGFS_FOPS(ucode_regs, ucode_regs_read_file, NULL, 1);
+B43legacy_DEBUGFS_FOPS(shm, shm_read_file, NULL, 1);
+B43legacy_DEBUGFS_FOPS(txstat, txstat_read_file, NULL, 0);
+B43legacy_DEBUGFS_FOPS(restart, NULL, restart_write_file, 1);
 
 
-int b43legacy_debug(struct b43legacy_wldev *dev,
-		    enum b43legacy_dyndbg feature)
+int b43legacy_debug(struct b43legacy_wldev *dev, enum b43legacy_dyndbg feature)
 {
 	return !!(dev->dfsentry && dev->dfsentry->dyn_debug[feature]);
 }
@@ -484,20 +389,18 @@ void b43legacy_debugfs_add_device(struct
 	struct b43legacy_txstatus_log *log;
 	char devdir[16];
 
-	B43legacy_BUG_ON(!dev);
+	B43legacy_WARN_ON(!dev);
 	e = kzalloc(sizeof(*e), GFP_KERNEL);
 	if (!e) {
-		b43legacyerr(dev->wl, "debugfs: OOM while adding device\n");
+		b43legacyerr(dev->wl, "debugfs: add device OOM\n");
 		return;
 	}
 	e->dev = dev;
 	log = &e->txstatlog;
 	log->log = kcalloc(B43legacy_NR_LOGGED_TXSTATUS,
-			   sizeof(struct b43legacy_txstatus),
-			   GFP_KERNEL);
+			   sizeof(struct b43legacy_txstatus), GFP_KERNEL);
 	if (!log->log) {
-		b43legacyerr(dev->wl, "debugfs: OOM while adding device"
-			     " txstatus\n");
+		b43legacyerr(dev->wl, "debugfs: add device txstatus OOM\n");
 		kfree(e);
 		return;
 	}
@@ -507,41 +410,40 @@ void b43legacy_debugfs_add_device(struct
 	dev->dfsentry = e;
 
 	snprintf(devdir, sizeof(devdir), "%s", wiphy_name(dev->wl->hw->wiphy));
-	e->subdir = debugfs_create_dir(devdir, fs.root);
+	e->subdir = debugfs_create_dir(devdir, rootdir);
 	if (!e->subdir || IS_ERR(e->subdir)) {
-		b43legacyerr(dev->wl, "debugfs: cannot create %s directory\n",
-		       devdir);
+		if (e->subdir == ERR_PTR(-ENODEV)) {
+			b43legacydbg(dev->wl, "DebugFS (CONFIG_DEBUG_FS) not "
+			       "enabled in kernel config\n");
+		} else {
+			b43legacyerr(dev->wl, "debugfs: cannot create %s directory\n",
+			       devdir);
+		}
 		dev->dfsentry = NULL;
 		kfree(log->log);
 		kfree(e);
 		return;
 	}
 
-	e->dentry_tsf = debugfs_create_file("tsf", 0600, e->subdir,
-					     dev, &tsf_fops);
-	if (IS_ERR(e->dentry_tsf))
-		e->dentry_tsf = NULL;
-	e->dentry_ucode_regs = debugfs_create_file("ucode_regs", 0400, e->subdir,
-						   dev, &ucode_regs_fops);
-	if (IS_ERR(e->dentry_ucode_regs))
-		e->dentry_ucode_regs = NULL;
-	e->dentry_shm = debugfs_create_file("shm", 0400, e->subdir,
-					    dev, &shm_fops);
-	if (IS_ERR(e->dentry_shm))
-		e->dentry_shm = NULL;
-	e->dentry_txstat = debugfs_create_file("tx_status", 0400, e->subdir,
-						dev, &txstat_fops);
-	if (IS_ERR(e->dentry_txstat))
-		e->dentry_txstat = NULL;
-	e->dentry_restart = debugfs_create_file("restart", 0200, e->subdir,
-						dev, &restart_fops);
-	if (IS_ERR(e->dentry_restart))
-		e->dentry_restart = NULL;
-
-	e->dentry_power = debugfs_create_file("power_level", 0600, e->subdir,
-					     dev, &power_fops);
-	if (IS_ERR(e->dentry_power))
-		e->dentry_power = NULL;
+#define ADD_FILE(name, mode)	\
+	do {							\
+		struct dentry *d;				\
+		d = debugfs_create_file(__stringify(name),	\
+					mode, e->subdir, dev,	\
+					&fops_##name.fops);	\
+		e->file_##name.dentry = NULL;			\
+		if (!IS_ERR(d))					\
+			e->file_##name.dentry = d;		\
+	} while (0)
+
+
+	ADD_FILE(tsf, 0600);
+	ADD_FILE(ucode_regs, 0400);
+	ADD_FILE(shm, 0400);
+	ADD_FILE(txstat, 0400);
+	ADD_FILE(restart, 0200);
+
+#undef ADD_FILE
 
 	b43legacy_add_dynamic_debug(dev);
 }
@@ -552,24 +454,24 @@ void b43legacy_debugfs_remove_device(str
 
 	if (!dev)
 		return;
-
 	e = dev->dfsentry;
 	if (!e)
 		return;
 	b43legacy_remove_dynamic_debug(dev);
-	debugfs_remove(e->dentry_tsf);
-	debugfs_remove(e->dentry_ucode_regs);
-	debugfs_remove(e->dentry_shm);
-	debugfs_remove(e->dentry_txstat);
-	debugfs_remove(e->dentry_restart);
-	debugfs_remove(e->dentry_power);
+
+	debugfs_remove(e->file_tsf.dentry);
+	debugfs_remove(e->file_ucode_regs.dentry);
+	debugfs_remove(e->file_shm.dentry);
+	debugfs_remove(e->file_txstat.dentry);
+	debugfs_remove(e->file_restart.dentry);
+
 	debugfs_remove(e->subdir);
 	kfree(e->txstatlog.log);
 	kfree(e);
 }
 
 void b43legacy_debugfs_log_txstat(struct b43legacy_wldev *dev,
-				  const struct b43legacy_txstatus *status)
+			    const struct b43legacy_txstatus *status)
 {
 	struct b43legacy_dfsentry *e = dev->dfsentry;
 	struct b43legacy_txstatus_log *log;
@@ -592,20 +494,12 @@ void b43legacy_debugfs_log_txstat(struct
 
 void b43legacy_debugfs_init(void)
 {
-	memset(&fs, 0, sizeof(fs));
-	fs.root = debugfs_create_dir(KBUILD_MODNAME, NULL);
-	if (!fs.root || IS_ERR(fs.root)) {
-		fs.root = NULL;
-		return;
-	}
-	fs.dentry_driverinfo = debugfs_create_file("driver", 0444, fs.root,
-						   NULL, &drvinfo_fops);
-	if (IS_ERR(fs.dentry_driverinfo))
-		fs.dentry_driverinfo = NULL;
+	rootdir = debugfs_create_dir(KBUILD_MODNAME, NULL);
+	if (IS_ERR(rootdir))
+		rootdir = NULL;
 }
 
 void b43legacy_debugfs_exit(void)
 {
-	debugfs_remove(fs.dentry_driverinfo);
-	debugfs_remove(fs.root);
+	debugfs_remove(rootdir);
 }


From Larry.Finger at lwfinger.net  Mon Sep 10 17:41:38 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 10 Sep 2007 10:41:38 -0500
Subject: [PATCH] b43legacy: Don't cancel the restart workqueue in
	wireless_core_exit
Message-ID: <46e565b2.UeI48jNziAkn2wBs%Larry.Finger@lwfinger.net>

Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -3021,6 +3021,7 @@ static void b43legacy_wireless_core_exit
 	B43legacy_WARN_ON(b43legacy_status(dev) > B43legacy_STAT_INITIALIZED);
 	if (b43legacy_status(dev) != B43legacy_STAT_INITIALIZED)
 		return;
+	b43_set_status(dev, B43_STAT_UNINIT);
 
 	b43legacy_rng_exit(dev->wl);
 	b43legacy_pio_free(dev);
@@ -3520,6 +3521,7 @@ static void b43legacy_one_core_detach(st
 
 	wldev = ssb_get_drvdata(dev);
 	wl = wldev->wl;
+	cancel_work_sync(&wldev->restart_work);
 	b43legacy_debugfs_remove_device(wldev);
 	b43legacy_wireless_core_detach(wldev);
 	list_del(&wldev->list);


From Larry.Finger at lwfinger.net  Mon Sep 10 17:45:01 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 10 Sep 2007 10:45:01 -0500
Subject: [PATCH] b43legacy: remove IEEE80211_CONF_SSID_HIDDEN
Message-ID: <46e5667d.rxqXAWDZOvc/hIty%Larry.Finger@lwfinger.net>

From: Johannes Berg <johannes at sipsolutions.net>

The IEEE80211_CONF_SSID_HIDDEN setting is unclear but does not
match the "closed net" flag b43 hardware has; the flag influences
only the sending of probe responses which is disabled anyway.

From Larry.Finger at lwfinger.net  Mon Sep 10 17:52:39 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 10 Sep 2007 10:52:39 -0500
Subject: [PATCH] b43legacy: Fix most of the sparse warnings
Message-ID: <46e56847.e8NGY1BRpVwK0qe+%Larry.Finger@lwfinger.net>

Fix most of the sparse warnings in b43legacy. Several are generated
in phy.c that cannot easily be fixed.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

Index: wireless-dev/drivers/net/wireless/b43legacy/leds.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/leds.c
+++ wireless-dev/drivers/net/wireless/b43legacy/leds.c
@@ -33,14 +33,13 @@
 static void b43legacy_led_changestate(struct b43legacy_led *led)
 {
 	struct b43legacy_wldev *dev = led->dev;
-	const int index = b43legacy_led_index(led);
-	const u16 mask = (1 << index);
+	const int index = led->index;
 	u16 ledctl;
 
 	B43legacy_WARN_ON(!(index >= 0 && index < B43legacy_NR_LEDS));
 	B43legacy_WARN_ON(!led->blink_interval);
 	ledctl = b43legacy_read16(dev, B43legacy_MMIO_GPIO_CONTROL);
-	ledctl = (ledctl & mask) ? (ledctl & ~mask) : (ledctl | mask);
+	ledctl ^= (1 << index);
 	b43legacy_write16(dev, B43legacy_MMIO_GPIO_CONTROL, ledctl);
 }
 
@@ -72,7 +71,7 @@ static void b43legacy_led_blink_start(st
 static void b43legacy_led_blink_stop(struct b43legacy_led *led, int sync)
 {
 	struct b43legacy_wldev *dev = led->dev;
-	const int index = b43legacy_led_index(led);
+	const int index = led->index;
 	u16 ledctl;
 
 	if (!led->blink_interval)
@@ -142,6 +141,7 @@ int b43legacy_leds_init(struct b43legacy
 
 	for (i = 0; i < B43legacy_NR_LEDS; i++) {
 		led = &(dev->leds[i]);
+		led->index = i;
 		led->dev = dev;
 		setup_timer(&led->blink_timer,
 			    b43legacy_led_blink,
Index: wireless-dev/drivers/net/wireless/b43legacy/leds.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/leds.h
+++ wireless-dev/drivers/net/wireless/b43legacy/leds.h
@@ -6,14 +6,14 @@
 
 
 struct b43legacy_led {
-	u8 behaviour:7;
-	u8 activelow:1;
-
+	u8 behaviour;
+	bool activelow;
+	/* Index in the "leds" array in b43legacy_wldev */
+	u8 index;
 	struct b43legacy_wldev *dev;
 	struct timer_list blink_timer;
 	unsigned long blink_interval;
 };
-#define b43legacy_led_index(led)	((int)((led) - (led)->dev->leds))
 
 /* Delay between state changes when blinking in jiffies */
 #define B43legacy_LEDBLINK_SLOW		(HZ / 1)
Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -848,7 +848,7 @@ static void handle_irq_noise(struct b43l
 	B43legacy_WARN_ON(!dev->noisecalc.calculation_running);
 	if (dev->noisecalc.channel_at_start != phy->channel)
 		goto drop_calculation;
-	*((u32 *)noise) = cpu_to_le32(b43legacy_jssi_read(dev));
+	*((__le32 *)noise) = cpu_to_le32(b43legacy_jssi_read(dev));
 	if (noise[0] == 0x7F || noise[1] == 0x7F ||
 	    noise[2] == 0x7F || noise[3] == 0x7F)
 		goto generate_new;
@@ -1434,8 +1434,7 @@ static int do_request_fw(struct b43legac
 			 const char *name,
 			 const struct firmware **fw)
 {
-	const size_t plen = sizeof(modparam_fwpostfix) + 32;
-	char path[plen];
+	char path[sizeof(modparam_fwpostfix) + 32];
 	struct b43legacy_fw_header *hdr;
 	u32 size;
 	int err;
Index: wireless-dev/drivers/net/wireless/b43legacy/xmit.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/xmit.c
+++ wireless-dev/drivers/net/wireless/b43legacy/xmit.c
@@ -125,10 +125,12 @@ void b43legacy_generate_plcp_hdr(struct 
 	__u8 *raw = plcp->raw;
 
 	if (b43legacy_is_ofdm_rate(bitrate)) {
-		*data = b43legacy_plcp_get_ratecode_ofdm(bitrate);
+		u16 d;
+
+		d = b43legacy_plcp_get_ratecode_ofdm(bitrate);
 		B43legacy_WARN_ON(octets & 0xF000);
-		*data |= (octets << 5);
-		*data = cpu_to_le32(*data);
+		d |= (octets << 5);
+		*data = cpu_to_le32(d);
 	} else {
 		u32 plen;
 
@@ -442,7 +444,7 @@ void b43legacy_rx(struct b43legacy_wldev
 	phystat0 = le16_to_cpu(rxhdr->phy_status0);
 	phystat3 = le16_to_cpu(rxhdr->phy_status3);
 	jssi = rxhdr->jssi;
-	macstat = le32_to_cpu(rxhdr->mac_status);
+	macstat = le16_to_cpu(rxhdr->mac_status);
 	mactime = le16_to_cpu(rxhdr->mac_time);
 	chanstat = le16_to_cpu(rxhdr->channel);
 



From Larry.Finger at lwfinger.net  Mon Sep 10 18:59:20 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Mon, 10 Sep 2007 11:59:20 -0500
Subject: [PATCH V2] b43legacy: Don't cancel the restart workqueue in
	wireless_core_exit
Message-ID: <46e577e8.J3sSMKsbv5F0EAQY%Larry.Finger@lwfinger.net>

From: Michael Buesch <mb at bu3sch.de>

The wq must be canceled later on rmmod. It's nonfatal, if
the wq runs on a device that's not started or down. It will
handle these cases.
But syncing in wireless_core_exit() will cause a deadlock with
the restart_work. (restart work cancels itself)

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Signed-off-by: Larry Finger <larry.finger at lwfinger.net>
---

John,

Sorry, but I sent the bare patch in the first version.

Larry

 drivers/net/wireless/b43legacy/main.c |    2 ++
 1 file changed, 2 insertions(+)

Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -3021,6 +3021,7 @@ static void b43legacy_wireless_core_exit
 	B43legacy_WARN_ON(b43legacy_status(dev) > B43legacy_STAT_INITIALIZED);
 	if (b43legacy_status(dev) != B43legacy_STAT_INITIALIZED)
 		return;
+	b43legacy_set_status(dev, B43legacy_STAT_UNINIT);
 
 	b43legacy_rng_exit(dev->wl);
 	b43legacy_pio_free(dev);
@@ -3520,6 +3521,7 @@ static void b43legacy_one_core_detach(st
 
 	wldev = ssb_get_drvdata(dev);
 	wl = wldev->wl;
+	cancel_work_sync(&wldev->restart_work);
 	b43legacy_debugfs_remove_device(wldev);
 	b43legacy_wireless_core_detach(wldev);
 	list_del(&wldev->list);


From achrisjo at yahoo.com  Mon Sep 10 22:07:41 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Mon, 10 Sep 2007 13:07:41 -0700 (PDT)
Subject: Any hope ?
In-Reply-To: <e67787dd0709100733k565474d8x949307e6b48663e3@mail.gmail.com>
Message-ID: <860663.31336.qm@web63709.mail.re1.yahoo.com>

Thanks,
>
> You might have noticed that yast's package manager is a bit painful to 
> use. I would seriously recommend switching to smart if you care at all 
> about maintaining your sanity. Don't hesitate to ask if you have any 
> questions.
>

Well, everything is a bloody pain, and I sure have a ton of questions :(
I have kept on since last night. Didn't get the kernel-sources I downloaded intact, and what is going on at this site - seems too advanced for me. 
Haven't used Suse since version 6, even then not that much. Things have become so different and unfamiliar. 




Nkoli <coomac at gmail.com> wrote:

    On 9/10/07, Arne Chr. Jorgensen <achrisjo at yahoo.com> wrote:

        hi,

        Thanks Nkoli,

        I just downloaded:

        kernel-default-2.6.22.5-265.1.x86_64.rpm
        kernel-syms, and kernel-source.

        One question: there was a kernel-rt    as well  -  is that  a  realtime  kernel  ? 


    Yep, it is, though I can't vouch for it since I never use it.

        ( as unbelieveable it may sound, I did spend years participating in the first real time kernel for Linux.. but I must have lost some braincells since then ;)

        //ARNE


        Boardwalk for $500? In 2007? Ha!
        Play Monopoly Here and Now (it's updated for today's economy) at Yahoo! Games.


    You might have noticed that yast's package manager is a bit painful to use. I would seriously recommend switching to smart if you care at all about maintaining your sanity. Don't hesitate to ask if you have any questions.

>
>    PS: It sounds like you've spent waaaay too much time on this issue. 
> Setting up a linux box should never take this much effort.. you shouldn't > have to fight with your computer to get it working. 
>

For some reason, this has become a nightmare. Did update packages, the
kernel is 2.6.18-0.5 - but after that it is impossible to get contact with
the wired ethernet again. It will not detect if I plug it in, while if I plug
something in the USB port, it may figure out that the ethercable is there.
Probably need to do another clean install - with all the hazzle that follows.

>
> Since everything else is working, (sound on suse notwithstanding), if the > bcm driver in 2.6.22-5 doesn't succeed in getting you a/b/g speeds, save 
> yourself the headache and use ndiswrapper till Larry and co get around to > hacking the N cards. Just my 10 cents.
>



Well, this card only supports  a/b/g - it's a 4311 chip - else I had given
up. 


( only mentioned if you check spare part numbers. Think there is 4 different cards depending on country, etc. )

It comes with both Intel and AMD, with different bridge-chips, and that may
be part of the trouble. 


//ARNE
 


       
---------------------------------
Choose the right car based on your needs.  Check out Yahoo! Autos new Car Finder tool.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070910/86f74940/attachment.html>

From achrisjo at yahoo.com  Wed Sep 12 07:51:20 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Tue, 11 Sep 2007 22:51:20 -0700 (PDT)
Subject: Any hope ?
Message-ID: <203184.28797.qm@web63709.mail.re1.yahoo.com>

Hi,

In an early post, ........

Larry Finger <larry.finger at lwfinger.net> wrote:

>
> Besides the wireless problem, the second area of difficulty is with
> disk controllers, which I think is the reason for the crashes you 
> noted in your first post. Since laptops switched to SATA 
> controllers, the changes have been very rapid.
>

Came to remember this remark, and you are absolutely right !!

Kernel loads up these:  "processor thermal pata_amd sata_nv fan jbd ext3 edd"
at boot. Times out with no response from the disk.

Any remark as to who/where I should go with this ? 

( kernel: 2.6.22.5-282 from OpenSuse )

Anything changed in later kernels ?

//ARNE


       
---------------------------------
Don't let your dream ride pass you by.    Make it a reality with Yahoo! Autos. 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070911/141b08e1/attachment.html>

From dwmw2 at infradead.org  Wed Sep 12 09:01:02 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Wed, 12 Sep 2007 09:01:02 +0200
Subject: Machine Check on Fedora rawhide kernel.
Message-ID: <1189580462.3570.5.camel@shinybook.infradead.org>

Will poke at it more when I get home at the end of the week...

Sep 12 08:17:22 shinybook NetworkManager: <info>  starting... 
Sep 12 08:17:22 shinybook kernel: Machine check in kernel mode.
Sep 12 08:17:22 shinybook kernel: Caused by (from SRR1=149030): Transfer error ack signal
Sep 12 08:17:22 shinybook kernel: Oops: Machine check, sig: 7 [#1]
Sep 12 08:17:22 shinybook kernel: PowerMac
Sep 12 08:17:22 shinybook kernel: Modules linked in: hci_usb(U) rfcomm(U) l2cap(U) bluetooth(U) ipv6(U) nls_utf8(U) hfsplus(U) dm_mirror(U) dm_mod(U) therm_adt746x(U) sn
d_aoa_i2sbus(U) arc4(U) ecb(U) blkcipher(U) snd_powermac(U) snd_seq_dummy(U) rc80211_simple(U) snd_seq_oss(U) snd_seq_midi_event(U) snd_seq(U) snd_seq_device(U) b43legac
y(U) snd_pcm_oss(U) pmac_zilog(U) snd_mixer_oss(U) snd_pcm(U) mac80211(U) ide_cd(U) cfg80211(U) cdrom(U) snd_timer(U) snd_page_alloc(U) snd(U) soundcore(U) snd_aoa_sound
bus(U) firewire_ohci(U) firewire_core(U) crc_itu_t(U) sungem(U) sungem_phy(U) ssb(U) ext3(U) jbd(U) mbcache(U) ehci_hcd(U) ohci_hcd(U) uhci_hcd(U)
Sep 12 08:17:22 shinybook kernel: NIP: f208e9e8 LR: f2520a74 CTR: f208e994
Sep 12 08:17:22 shinybook kernel: REGS: ef35f8e0 TRAP: 0200   Not tainted  (2.6.23-0.164.rc5.fc7)
Sep 12 08:17:22 shinybook kernel: MSR: 00149030 <EE,ME,IR,DR>  CR: 42000482  XER: 20000000
Sep 12 08:17:22 shinybook kernel: TASK = ee950000[2238] 'NetworkManager' THREAD: ef35e000
Sep 12 08:17:22 shinybook kernel: GPR00: 0000003f ef35f990 ee950000 efbd0430 efbd04ac 0000042b 00000340 00000015 
Sep 12 08:17:22 shinybook kernel: GPR08: 00000000 f2084000 22000082 00001032 00000000 1006ba46 100d0000 00000000 
Sep 12 08:17:22 shinybook kernel: GPR16: 100e04a8 100d0000 100a0000 100d0000 00000000 100dd530 100dff48 00000000 
Sep 12 08:17:22 shinybook kernel: GPR24: efb430cc efb430c8 efbd0430 00000000 efb43078 efb43060 000003fe efbd0430 
Sep 12 08:17:22 shinybook kernel: NIP [f208e9e8] ssb_pci_read16+0x54/0x74 [ssb]
Sep 12 08:17:22 shinybook kernel: LR [f2520a74] b43legacy_phy_read+0x48/0x60 [b43legacy]
Sep 12 08:17:22 shinybook kernel: Call Trace:
Sep 12 08:17:22 shinybook kernel: [ef35f990] [efb43060] 0xefb43060 (unreliable)
Sep 12 08:17:22 shinybook kernel: [ef35f9a0] [f2520a74] b43legacy_phy_read+0x48/0x60 [b43legacy]
Sep 12 08:17:22 shinybook kernel: [ef35f9c0] [f25211e4] b43legacy_phy_initb5+0x16c/0x4b0 [b43legacy]
Sep 12 08:17:22 shinybook kernel: [ef35f9e0] [f2524030] b43legacy_phy_initg+0x28/0xd3c [b43legacy]
Sep 12 08:17:22 shinybook kernel: [ef35fa50] [f2525350] b43legacy_phy_calibrate+0x68/0x94 [b43legacy]
Sep 12 08:17:22 shinybook kernel: [ef35fa60] [f251db40] b43legacy_wireless_core_init+0x360/0x808 [b43legacy]
Sep 12 08:17:22 shinybook kernel: [ef35fa90] [f251e88c] b43legacy_add_interface+0x6c/0x130 [b43legacy]
Sep 12 08:17:22 shinybook kernel: [ef35fab0] [f24b0adc] ieee80211_open+0x2a4/0x440 [mac80211]
Sep 12 08:17:22 shinybook kernel: [ef35faf0] [c026ae10] dev_open+0x60/0xc8
Sep 12 08:17:22 shinybook kernel: [ef35fb10] [c0268c14] dev_change_flags+0xcc/0x1a8
Sep 12 08:17:22 shinybook kernel: [ef35fb30] [c02738c4] do_setlink+0x1c8/0x2b8
Sep 12 08:17:22 shinybook kernel: [ef35fb70] [c0274b84] rtnl_setlink+0xf8/0x130
Sep 12 08:17:22 shinybook kernel: [ef35fbe0] [c027447c] rtnetlink_rcv_msg+0x214/0x240
Sep 12 08:17:23 shinybook kernel: [ef35fc00] [c0284fe4] netlink_run_queue+0x94/0x158
Sep 12 08:17:23 shinybook kernel: [ef35fc20] [c02741e0] rtnetlink_rcv+0x40/0x6c
Sep 12 08:17:23 shinybook kernel: [ef35fc50] [c0285614] netlink_data_ready+0x28/0x84
Sep 12 08:17:23 shinybook kernel: [ef35fc60] [c028402c] netlink_sendskb+0x34/0x70
Sep 12 08:17:23 shinybook kernel: [ef35fc80] [c02855d0] netlink_sendmsg+0x2b0/0x2cc
Sep 12 08:17:23 shinybook kernel: [ef35fcd0] [c025be9c] sock_sendmsg+0xd0/0x100
Sep 12 08:17:23 shinybook kernel: [ef35fdc0] [c025c094] sys_sendmsg+0x1c8/0x254
Sep 12 08:17:23 shinybook kernel: [ef35ff00] [c025d6b8] sys_socketcall+0x1c4/0x1fc
Sep 12 08:17:23 shinybook kernel: [ef35ff40] [c0012c3c] ret_from_syscall+0x0/0x38
Sep 12 08:17:23 shinybook kernel: --- Exception: c01 at 0xfb2f91c
Sep 12 08:17:23 shinybook kernel:     LR = 0xfc03838
Sep 12 08:17:23 shinybook kernel: Instruction dump:
Sep 12 08:17:23 shinybook kernel: 7fe3fb78 7f804800 41be0018 4bffff09 2f830000 38600000 6063ffff 409e0020 
Sep 12 08:17:23 shinybook kernel: 813f0000 7c09f214 7c0004ac 7c00062c <0c000000> 4c00012c 5403043e 80010014 

-- 
dwmw2



From larry.finger at lwfinger.net  Wed Sep 12 16:16:19 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 12 Sep 2007 09:16:19 -0500
Subject: Any hope ?
In-Reply-To: <203184.28797.qm@web63709.mail.re1.yahoo.com>
References: <203184.28797.qm@web63709.mail.re1.yahoo.com>
Message-ID: <46E7F4B3.6000303@lwfinger.net>

Arne Chr. Jorgensen wrote:
> 
> Kernel loads up these:  "processor thermal pata_amd sata_nv fan jbd ext3
> edd"
> at boot. Times out with no response from the disk.
> 
> Any remark as to who/where I should go with this ?
> 
> ( kernel: 2.6.22.5-282 from OpenSuse )
> 
> Anything changed in later kernels ?

Of course, but if you have some combination that boots and is able to access that hard drive, even
if only a live CD, then Linux has the correct driver, and you need to be certain that the driver is
in initrd.

Larry


From Larry.Finger at lwfinger.net  Wed Sep 12 18:41:04 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Wed, 12 Sep 2007 11:41:04 -0500
Subject: Any hope ?
In-Reply-To: <465492.58047.qm@web63709.mail.re1.yahoo.com>
References: <465492.58047.qm@web63709.mail.re1.yahoo.com>
Message-ID: <46E816A0.3000901@lwfinger.net>

Arne Chr. Jorgensen wrote:
> hi,
> hmm...  not sure I understood.  The kernel was built by  "make
> clone_config",
> from the previous kernel source to the new.  The later kernel releases
> fails to
> access the hardware, in this case  I can only narrow it down to "sata_nv".
> No Suse or Fedora will  run  on  this  for  later  releases..
> 
> ( did enter some debug option into the scsi, but without any media to
> dump it
> to, I haven't found a way to get those finer details documented.  )
> 
> So, who should I contact in order to figure this out ?   Have heard of
> bugzilla,
> and such, but I don't know how to report such things. 
> 
> 
> //ARNE
> ( sorry to bother you with this .. but I sure would like to be able to
> enable the
> bcm43xx stuff I did notice )
> 
> Here is the results with a Fedora install iso  - x86_64 :
> 
> - the following is what I have copied manually from screen:
> .
> .
> ata4: SATA link down (SStatus 0 SControl 300)    <====Note !!!
> pata_amd 0000:00:06.0: version 0.3.8
> PCI: Setting latency timer of device 0000:00:06.0 to 64
> scsi4: pata_amd
> scsi5: pata_amd
> ata5: PATA max UDMA/133 cmd 0x00000000000101f0 ctl 0x00000000000103f6
> bmdma 0x00000000000130c0 irq 14
> ata6: PATA max UDMA/133 cmd 0x0000000000010170 ctl 0x0000000000010376
> bmdma 0x00000000000130c8 irq 15
> ata5.00: ATAPI: MATSHITADVD-RAM UJ-851S, 1.50, max MWDMA2
> ata5.00: ATAPI: configured for MWDMA2
> ata6: port disabled. ignoring.
> scsi 4:0:0:0: CD-ROM     MATSHITADVD-RAM UJ-851S, 1.50 PQ: 0 ANSI: 5
> device-mapper: ioctl: 4.11.0-ioctl (2006-10-12) initialised:
> dm-devel at redhat.com
>   Reading all physical volumes. This may take a while...
>   No volume groups found
>   Volume group "VolGroup00" not found
> Unable to access resume device (/dev/VolGroup00/LogVol01)
> mount: could not find filesystem '/dev/root'
> setuproot: moving /dev failed: No such file or directory
> Setuproot: error mounting /proc: No such file or directory
> Setuproot: error mounting /sys: No such file or directory
> switchroot: mount failed: No such file or directory
> Kernel panic - not syncing: Attempting to kill init!

Do you have _ANY_ kernel that can boot and access the hard drive? If so, please boot it and send the
output of 'lsmod'.

Larry




From achrisjo at yahoo.com  Thu Sep 13 00:32:52 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Wed, 12 Sep 2007 15:32:52 -0700 (PDT)
Subject: Any hope ?
In-Reply-To: <46E816A0.3000901@lwfinger.net>
Message-ID: <823184.80224.qm@web63710.mail.re1.yahoo.com>

Hi,

you wrote:
>
> Do you have _ANY_ kernel that can boot and access the hard 
> drive? If so, please boot it and send the
> output of 'lsmod'.
>

right,..

//ARNE
                  ----------------------

Running OpenSuse 10.2 

uname -a Linux compac 2.6.18.2-34-default #1 SMP Mon Nov 27 11:46:27 UTC 2006 x86_64 x86_64 x86_64 GNU/Linux


                  ----------------------  
lsmod

Module                  Size  Used by
bridge                 81328  0 
iptable_filter         19968  0 
ip_tables              39400  1 iptable_filter
x_tables               37384  1 ip_tables
joydev                 28160  0 
af_packet              57356  2 
ipv6                  357728  16 
snd_pcm_oss            71680  0 
snd_mixer_oss          35840  1 snd_pcm_oss
snd_seq                82976  0 
snd_seq_device         26516  1 snd_seq
cpufreq_conservative    25608  0 
cpufreq_ondemand       24592  1 
cpufreq_userspace      24064  0 
cpufreq_powersave      18688  0 
powernow_k8            32416  1 
freq_table             22912  1 powernow_k8
button                 24736  0 
battery                28168  0 
ac                     22792  0 
apparmor               74264  0 
aamatch_pcre           31232  1 apparmor
nls_utf8               18944  2 
ntfs                  209032  2 
loop                   34064  0 
dm_mod                 81872  0 
ohci1394               52040  0 
ehci_hcd               51080  0 
sdhci                  35980  0 
mmc_core               45056  1 sdhci
ohci_hcd               38404  0 
ieee1394              130552  1 ohci1394
usbcore               148064  2 ehci_hcd,ohci_hcd
forcedeth              78864  0 
snd_dummy              30848  1 
snd_pcm               115464  2 snd_pcm_oss,snd_dummy
snd_timer              44680  2 snd_seq,snd_pcm
snd                    89384  9 snd_pcm_oss,snd_mixer_oss,snd_seq,snd_seq_device,snd_dummy,snd_pcm,snd_timer
soundcore              28192  1 snd
snd_page_alloc         27792  1 snd_pcm
ext3                  167696  2 
mbcache                27016  1 ext3
jbd                    90872  1 ext3
edd                    27912  0 
fan                    22408  0 
sg                     55080  0 
sr_mod                 34596  0 
cdrom                  54056  1 sr_mod
sata_nv                30084  5 
pata_amd               31520  0 
libata                145056  2 sata_nv,pata_amd
thermal                33552  0 
processor              53992  2 powernow_k8,thermal
sd_mod                 39296  6 
scsi_mod              173744  4 sg,sr_mod,libata,sd_mod



       
---------------------------------
Got a little couch potato? 
Check out fun summer activities for kids.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070912/d3b62f7a/attachment.html>

From larry.finger at lwfinger.net  Thu Sep 13 01:24:49 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 12 Sep 2007 18:24:49 -0500
Subject: Any hope ?
In-Reply-To: <823184.80224.qm@web63710.mail.re1.yahoo.com>
References: <823184.80224.qm@web63710.mail.re1.yahoo.com>
Message-ID: <46E87541.1090107@lwfinger.net>

Arne Chr. Jorgensen wrote:
> Hi,
> 
> you wrote:
>>
>> Do you have _ANY_ kernel that can boot and access the hard
>> drive? If so, please boot it and send the
>> output of 'lsmod'.
>>
> 
> right,..
> 
> //ARNE
>                   ----------------------
> 
> Running OpenSuse 10.2
> 
> uname -a Linux compac 2.6.18.2-34-default #1 SMP Mon Nov 27 11:46:27 UTC
> 2006 x86_64 x86_64 x86_64 GNU/Linux
> 
> 
>                   ---------------------- 
> lsmod
> 
> Module                  Size  Used by
> bridge                 81328  0
> iptable_filter         19968  0
> ip_tables              39400  1 iptable_filter
> x_tables               37384  1 ip_tables
> joydev                 28160  0
> af_packet              57356  2
> ipv6                  357728  16
> snd_pcm_oss            71680  0
> snd_mixer_oss          35840  1 snd_pcm_oss
> snd_seq                82976  0
> snd_seq_device         26516  1 snd_seq
> cpufreq_conservative    25608  0
> cpufreq_ondemand       24592  1
> cpufreq_userspace      24064  0
> cpufreq_powersave      18688  0
> powernow_k8            32416  1
> freq_table             22912  1 powernow_k8
> button                 24736  0
> battery                28168  0
> ac                     22792  0
> apparmor               74264  0
> aamatch_pcre           31232  1 apparmor
> nls_utf8               18944  2
> ntfs                  209032  2
> loop                   34064  0
> dm_mod                 81872  0
> ohci1394               52040  0
> ehci_hcd               51080  0
> sdhci                  35980  0
> mmc_core               45056  1 sdhci
> ohci_hcd               38404  0
> ieee1394              130552  1 ohci1394
> usbcore               148064  2 ehci_hcd,ohci_hcd
> forcedeth              78864  0
> snd_dummy              30848  1
> snd_pcm               115464  2 snd_pcm_oss,snd_dummy
> snd_timer              44680  2 snd_seq,snd_pcm
> snd                    89384  9
> snd_pcm_oss,snd_mixer_oss,snd_seq,snd_seq_device,snd_dummy,snd_pcm,snd_timer
> soundcore              28192  1 snd
> snd_page_alloc         27792  1 snd_pcm
> ext3                  167696  2
> mbcache                27016  1 ext3
> jbd                    90872  1 ext3
> edd                    27912  0
> fan                    22408  0
> sg                     55080  0
> sr_mod                 34596  0
> cdrom                  54056  1 sr_mod
> sata_nv                30084  5
> pata_amd               31520  0
> libata                145056  2 sata_nv,pata_amd     <==============
> thermal                33552  0
> processor              53992  2 powernow_k8,thermal
> sd_mod                 39296  6
> scsi_mod              173744  4 sg,sr_mod,libata,sd_mod <============

The missing modules are libata and scsi_mod. To get them added to your initrd, you need to use YaST.

From achrisjo at yahoo.com  Thu Sep 13 03:13:50 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Wed, 12 Sep 2007 18:13:50 -0700 (PDT)
Subject: Any hope ?
In-Reply-To: <46E87541.1090107@lwfinger.net>
Message-ID: <134020.85400.qm@web63715.mail.re1.yahoo.com>

hi,

Larry Finger <larry.finger at lwfinger.net> wrote:
>
> The missing modules are libata and scsi_mod
>

Not sure/understand...hmm... what I sent was simply lsmod > lsmod.txt and pasted into the browser.
It was the laptop in quistion, running OpenSuse 10.2 with kernel 2.6.18.2-34-default

"Nkoli" <coomac at gmail.com> was kindly giving me some details as I am not that familiar with OpenSuse.
He told me where to find the kernel and load it. But that crashed the computer as every upgrades in
fedora does. 

But the OpenSuse 10.2 with kernel 2.6.18.2-34-default works, so I downloaded the kernel sources,
- make clone-config
  make 
  make modules_install
  make install

Which should give me an exact copy of my environment, and settings, in order to compare.
( it install initrd, the added kernel in grub, etc. )

As it still crash..
                                   -----------------


Pasting in a section as what I have reported at fedora-test-list recently:  
( I posted the first fedora attempts Sept 04, and god knows how many installs I have tested...worked
constantly ever since, except too few hours of sleep ;)

>
> Identical configured kernels, here OpenSuse 10.2 with kernel 2.6.18.2-34 86x64
> failed on a kernel 2.6.22.5-282 86x64
> 
> Similar to the test I did on Fedora core 6. On Fedora7, Fedora7.9 , as well as the Fedora7-i386,
> all seems to do the same. But with Fedora, there was more crazy stuff - touchpad, keys, well..they > wasn't much user friendly anymore ! ;)  Wondered if the damn thing tried to bite my hand off ;)
> 
>                                  ------------------
>
> The machine specifications:
> http://h10025.www1.hp.com/ewfrf/wc/manualCategory?product=3466328&lc=en&cc=us&dlc=en&lang=en&cc=us
>
> Note - at first it looks like it has a Broadcom 4321AGN Wi-Fi Adapter - but that is false. It is
> a 4311 adapter in my case. ( took some work to figure it out )
>
> ( some of my attempts with Fedora is at the fedora-laptop-list at redhat.com )
>
                                   ------------------

Now, after I did send you the lsmod - I rebooted and did run the cloned and compiled kernel,
and have typed what I am able to read from screeen:

( this should confirm that libata and scsi_mod isn't missing )

So, there are some changes done in recent kernels, that doesn't go along with my hardware.
( and as I can't get up some media or mount to my disks, I don't know how to debug into the kernel
drivers )


//ARNE



! Following is manually retyped as what is shown on screen, OpenSuse 10.2, 
! running 2.6.22.5-282-default  ( cloned from working system 2.6.18.2-34-default )
! It starts up identical after grub selection as far as able to see ( escape splash-screen) 
! but the top lines scrolled out of screen..so I could not type it ...
! As the shell don't have lsmod, did cat/proc/modules instead.
.
.
mice: PS/2 mouse device common for all mice
input: AT Translated Set 2 keyboard as /class/input/input0
input: PC Speaker as /class/input/input1
Synaptics Touchpad, model: 1, fw: 6.3, id: 0x1a0b1, capa: 0xa04713/0x200000
input: SynPS/2 Synaptics TouchPat as /class/input/input2
NET: Registered protocol family 1
Freeing unused kernel memory: 324k freed
Boot logging started on /dev/tty1(/dev/console) at Wed Sep 12 21:55:23 2007
Trying manual resume from /dev/sda5
Creating device nodes with udev
Loading scsi_mod
Loading processor
ACPI: CPU0 (power states: C1[C1] C2[C2] C3[C3])
ACPI: Processor [CPU0] (support 8 throttling states )
ACPI Exception (processor_core-0787): AE_NOT_FOUND, Processor Device is not present [20070126]
ACPI Exception (processor_core-0787): AE_NOT_FOUND, Processor Device is not present [20070126]
Loading thermal
ACPI Exception (thermal-0317): AE_BAD_DATA, No critical threshold [20070126]
Loading libata
Loading pata_amd
scsi0 : pata_amd
scsi1 : pata_amd 
ata1: PATA max UDMA/133 cmd 0x00000000000101f0 ctl 0x00000000000103f6 bmdma 0x00000000000130c0 irq 14
ata2: PATA max UDMA/133 cmd 0x0000000000010170 ctl 0x0000000000010376 bmdma 0x00000000000130c8 irq 15
ata1.00: ATAPI: MATSHITA DVD-RAM UJ-851S, 1.50, max MWDMA2  
ata1.00: configured for MWDMA2
sr 0:0:0:0: CD-ROM            MATSHITA DVD-RAM UJ-851S  1.50 PQ: 0 ANSI: 5 
Loading jbd
Loading mbcache
Loading ext3
resume device /dev/sda not found (ignoring)
Waiting for device /dev/sda7 to appear:..............................not found -- exiting to /bin/sd
sh: no job control in this shell
$cat /proc/modules
ext3 157840 0 - Live 0xffffffff880e9000
mbcache 26248 1 ext3, Live 0xffffffff880e1000
jbd 89336 1 ext3, Live 0xffffffff880ca000
sg 53560 0 - Live 0xffffffff880bb000
edd 27016 0 - Live 0xffffffff880b3000
sr_mod 33572 0 - Live 0xffffffff880a7000
cdrom 52264 1 sr_mod, Live 0xffffffff88099000
fan 22408 0 - Live 0xffffffff88092000
sata_nv 38404 0 - Live 0xffffffff88087000
pata_amd 31876 0 - Live 0xffffffff8807e000
libata 164080 2 sata_nv,pata_amd, Live 0xffffffff88054000
thermal 32144 0 - Live 0xffffffff8804b000
processor 54376 1 thermal, Live 0xffffffff8803c000
sd_mod 45696 0 - Live 0xffffffff8802f000
scsi_mod 177592 4 sg,sr_mod,libata,sd_mod, Live 0xffffffff88002000
$

                                   ----------------------




       
---------------------------------
 Check out  the hottest 2008 models today at Yahoo! Autos.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070912/423c83f2/attachment.html>

From achrisjo at yahoo.com  Thu Sep 13 03:34:13 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Wed, 12 Sep 2007 18:34:13 -0700 (PDT)
Subject: Any hope ?
In-Reply-To: <46E87541.1090107@lwfinger.net>
Message-ID: <155192.75739.qm@web63709.mail.re1.yahoo.com>

hi,

I will be greatful for any suggestions, or if someone knows where I might
get in touch with maintainers and developers of the kernels. 
Anyone knows the MCP67M bridge chipsets ? 
( I would like to see the data-sheets )

( how does an iso install release probe the hardware, as - well, OpenSuse 10.2,
and Fedora 6, with the older kernels - does install and get something going. Not so with new releases )

//ARNE

       
---------------------------------
Looking for a deal? Find great prices on flights and hotels with Yahoo! FareChase.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070912/046135e9/attachment.html>

From larry.finger at lwfinger.net  Thu Sep 13 03:49:12 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 12 Sep 2007 20:49:12 -0500
Subject: Any hope ?
In-Reply-To: <134020.85400.qm@web63715.mail.re1.yahoo.com>
References: <134020.85400.qm@web63715.mail.re1.yahoo.com>
Message-ID: <46E89718.7040402@lwfinger.net>

Arne Chr. Jorgensen wrote:
> hi,
> 
> Larry Finger <larry.finger at lwfinger.net> wrote:
>>
>> The missing modules are libata and scsi_mod
>>
> 
> Not sure/understand...hmm... what I sent was simply lsmod > lsmod.txt
> and pasted into the browser.
> It was the laptop in quistion, running OpenSuse 10.2 with kernel
> 2.6.18.2-34-default

I gave you _VERY_ explicit directions on exactly what to do, and you still cannot do it. Instead,
you want to study the data sheets.

You are now on my black list. I am not going to spend any more wasted time on you. Buy something
other than a BCM43xx card, please.

Larry


From larry.finger at lwfinger.net  Thu Sep 13 21:44:16 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 13 Sep 2007 14:44:16 -0500
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <1189580462.3570.5.camel@shinybook.infradead.org>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
Message-ID: <46E99310.2080605@lwfinger.net>

David Woodhouse wrote:
> Will poke at it more when I get home at the end of the week...
> 
> Sep 12 08:17:22 shinybook NetworkManager: <info>  starting... 
> Sep 12 08:17:22 shinybook kernel: Machine check in kernel mode.
> Sep 12 08:17:22 shinybook kernel: Caused by (from SRR1=149030): Transfer error ack signal
> Sep 12 08:17:22 shinybook kernel: Oops: Machine check, sig: 7 [#1]
> Sep 12 08:17:22 shinybook kernel: PowerMac
> Sep 12 08:17:22 shinybook kernel: Modules linked in: hci_usb(U) rfcomm(U) l2cap(U) bluetooth(U) ipv6(U) nls_utf8(U) hfsplus(U) dm_mirror(U) dm_mod(U) therm_adt746x(U) sn
> d_aoa_i2sbus(U) arc4(U) ecb(U) blkcipher(U) snd_powermac(U) snd_seq_dummy(U) rc80211_simple(U) snd_seq_oss(U) snd_seq_midi_event(U) snd_seq(U) snd_seq_device(U) b43legac
> y(U) snd_pcm_oss(U) pmac_zilog(U) snd_mixer_oss(U) snd_pcm(U) mac80211(U) ide_cd(U) cfg80211(U) cdrom(U) snd_timer(U) snd_page_alloc(U) snd(U) soundcore(U) snd_aoa_sound

David,

Please try the patch below.

Thanks,

Larry

---------------------------

--- a/drivers/net/wireless/b43legacy/main.c
+++ b/drivers/net/wireless/b43legacy/main.c
@@ -738,8 +738,11 @@ void b43legacy_wireless_core_reset(struct b43legacy_wldev *dev, u32 flags)

 	macctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);
 	macctl &= ~B43legacy_MACCTL_GMODE;
-	if (flags & B43legacy_TMSLOW_GMODE)
+	if (flags & B43legacy_TMSLOW_GMODE) {
 		macctl |= B43legacy_MACCTL_GMODE;
+		dev->phy.gmode = 1;
+	} else
+		dev->phy.gmode = 0;
 	macctl |= B43legacy_MACCTL_IHR_ENABLED;
 	b43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);
 }


From dwmw2 at infradead.org  Fri Sep 14 12:32:01 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 14 Sep 2007 12:32:01 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <46E99310.2080605@lwfinger.net>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<46E99310.2080605@lwfinger.net>
Message-ID: <1189765921.3238.2.camel@shinybook.infradead.org>

On Thu, 2007-09-13 at 14:44 -0500, Larry Finger wrote:
> 
> David,
> 
> Please try the patch below.

Differently buggered... now we hit the B43legacy_BUG_ON() in
b43legacy_rx() -- at least that's the _last_ trace I captured from the
screen; there were more further up.

This device is basically identical to the one I handed to John in
Cambridge last week. How do I force the b43 driver to bind to it?

-- 
dwmw2



From dwmw2 at infradead.org  Fri Sep 14 12:49:41 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 14 Sep 2007 12:49:41 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <1189765921.3238.2.camel@shinybook.infradead.org>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<46E99310.2080605@lwfinger.net>
	<1189765921.3238.2.camel@shinybook.infradead.org>
Message-ID: <1189766981.3238.7.camel@shinybook.infradead.org>

On Fri, 2007-09-14 at 12:32 +0200, David Woodhouse wrote:
> This device is basically identical to the one I handed to John in
> Cambridge last week. How do I force the b43 driver to bind to it? 

This (and copying b0g0initvals2 from the b43legacy/ directory to b43/)
didn't work... it seems it can't transmit.
http://david.woodhou.se/b43-not-working.txt

This card is working fine with bcm43xx-mac80211 right now though.

--- drivers/net/wireless/b43/main.c~    2007-09-14 01:05:37.000000000 +0200
+++ drivers/net/wireless/b43/main.c     2007-09-14 12:41:32.000000000 +0200
@@ -109,6 +109,7 @@ module_param_named(nohwcrypt, modparam_n
 MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption.");
 
 static const struct ssb_device_id b43_ssb_tbl[] = {
+       SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 4),
        SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 5),
        SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 6),
        SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
@@ -1648,7 +1649,9 @@ static int b43_request_firmware(struct b
 
        tmshigh = ssb_read32(dev->dev, SSB_TMSHIGH);
        if (!fw->ucode) {
-               if ((rev >= 5) && (rev <= 10))
+               if (rev == 4)
+                       filename = "ucode4";
+               else if ((rev >= 5) && (rev <= 10))
                        filename = "ucode5";
                else if ((rev >= 11) && (rev <= 12))
                        filename = "ucode11";
@@ -1661,7 +1664,9 @@ static int b43_request_firmware(struct b
                        goto err_load;
        }
        if (!fw->pcm) {
-               if ((rev >= 5) && (rev <= 10))
+               if (rev == 4)
+                       filename = "pcm4";
+               else if ((rev >= 5) && (rev <= 10))
                        filename = "pcm5";
                else if (rev >= 11)
                        filename = NULL;
@@ -1683,7 +1688,9 @@ static int b43_request_firmware(struct b
                                goto err_no_initvals;
                        break;
                case B43_PHYTYPE_G:
-                       if ((rev >= 5) && (rev <= 10))
+                       if (rev == 4)
+                               filename = "b0g0initvals2";
+                       else if ((rev >= 5) && (rev <= 10))
                                filename = "b0g0initvals5";
                        else if (rev >= 13)
                                filename = "lp0initvals13";
@@ -1713,7 +1720,7 @@ static int b43_request_firmware(struct b
                case B43_PHYTYPE_G:
                        if ((rev >= 5) && (rev <= 10))
                                filename = "b0g0bsinitvals5";
-                       else if (rev >= 11)
+                       else if (rev == 4 || rev >= 11)
                                filename = NULL;
                        else
                                goto err_no_initvals;

-- 
dwmw2



From mb at bu3sch.de  Fri Sep 14 12:56:56 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Sep 2007 12:56:56 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <1189766981.3238.7.camel@shinybook.infradead.org>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<1189765921.3238.2.camel@shinybook.infradead.org>
	<1189766981.3238.7.camel@shinybook.infradead.org>
Message-ID: <200709141256.56844.mb@bu3sch.de>

On Friday 14 September 2007 12:49:41 David Woodhouse wrote:
> On Fri, 2007-09-14 at 12:32 +0200, David Woodhouse wrote:
> > This device is basically identical to the one I handed to John in
> > Cambridge last week. How do I force the b43 driver to bind to it? 
> 
> This (and copying b0g0initvals2 from the b43legacy/ directory to b43/)
> didn't work... it seems it can't transmit.
> http://david.woodhou.se/b43-not-working.txt
> 
> This card is working fine with bcm43xx-mac80211 right now though.
> 
> --- drivers/net/wireless/b43/main.c~    2007-09-14 01:05:37.000000000 +0200
> +++ drivers/net/wireless/b43/main.c     2007-09-14 12:41:32.000000000 +0200
> @@ -109,6 +109,7 @@ module_param_named(nohwcrypt, modparam_n
>  MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption.");
>  
>  static const struct ssb_device_id b43_ssb_tbl[] = {
> +       SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 4),
>         SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 5),
>         SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 6),
>         SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
> @@ -1648,7 +1649,9 @@ static int b43_request_firmware(struct b

Revisions < 5 are not supported by the driver.

-- 
Greetings Michael.


From dwmw2 at infradead.org  Fri Sep 14 13:08:18 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 14 Sep 2007 13:08:18 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <200709141256.56844.mb@bu3sch.de>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<1189765921.3238.2.camel@shinybook.infradead.org>
	<1189766981.3238.7.camel@shinybook.infradead.org>
	<200709141256.56844.mb@bu3sch.de>
Message-ID: <1189768098.3238.9.camel@shinybook.infradead.org>

On Fri, 2007-09-14 at 12:56 +0200, Michael Buesch wrote:
> Revisions < 5 are not supported by the driver. 

So there's no way to use this device with v4 firmware any more?

-- 
dwmw2



From larry.finger at lwfinger.net  Fri Sep 14 17:07:51 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Sep 2007 10:07:51 -0500
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <1189765921.3238.2.camel@shinybook.infradead.org>
References: <1189580462.3570.5.camel@shinybook.infradead.org>	
	<46E99310.2080605@lwfinger.net>
	<1189765921.3238.2.camel@shinybook.infradead.org>
Message-ID: <46EAA3C7.8040701@lwfinger.net>

David Woodhouse wrote:
> On Thu, 2007-09-13 at 14:44 -0500, Larry Finger wrote:
>> David,
>>
>> Please try the patch below.
> 
> Differently buggered... now we hit the B43legacy_BUG_ON() in
> b43legacy_rx() -- at least that's the _last_ trace I captured from the
> screen; there were more further up.
> 
> This device is basically identical to the one I handed to John in
> Cambridge last week. How do I force the b43 driver to bind to it?
> 

As you saw from Michael's message, basically you cannot. The latest drivers and V4 firmware from
Broadcom have abandoned this device and the BCM4301, which is why b43legacy is needed. It may work
at the moment, but it could fail with any revisions in the specs based on a new Broadcom driver or
with new firmware.

Too bad that the device behaves so differently with ppc architecture. None of these problems happen
on my i386 platform. Performance is bad for OFDM rates, but otherwise the interface is OK.

The only way that b43legacy_rx() could generate a BUG_ON is if the bitrate codes in the received
message are messed up. The attached patch will partially silence those messages and let us see more.
Perhaps we can find the real cause. I certainly appreciate your assistance in debugging these problems.

Larry


-------------- next part --------------
A non-text attachment was scrubbed...
Name: gmode.patch
Type: text/x-patch
Size: 4734 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070914/9c54fe7c/attachment.bin>

From dwmw2 at infradead.org  Fri Sep 14 18:24:24 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 14 Sep 2007 18:24:24 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <46EAA3C7.8040701@lwfinger.net>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<46E99310.2080605@lwfinger.net>
	<1189765921.3238.2.camel@shinybook.infradead.org>
	<46EAA3C7.8040701@lwfinger.net>
Message-ID: <1189787065.4460.4.camel@shinybook.infradead.org>

On Fri, 2007-09-14 at 10:07 -0500, Larry Finger wrote:
> David Woodhouse wrote:
> > On Thu, 2007-09-13 at 14:44 -0500, Larry Finger wrote:
> >> David,
> >>
> >> Please try the patch below.
> > 
> > Differently buggered... now we hit the B43legacy_BUG_ON() in
> > b43legacy_rx() -- at least that's the _last_ trace I captured from the
> > screen; there were more further up.
> > 
> > This device is basically identical to the one I handed to John in
> > Cambridge last week. How do I force the b43 driver to bind to it?
> > 
> 
> As you saw from Michael's message, basically you cannot. The latest drivers and V4 firmware from
> Broadcom have abandoned this device and the BCM4301, which is why b43legacy is needed. It may work
> at the moment, but it could fail with any revisions in the specs based on a new Broadcom driver or
> with new firmware.

OK, I'll concentrate on b43legacy then.

> Too bad that the device behaves so differently with ppc architecture. None of these problems happen
> on my i386 platform. Performance is bad for OFDM rates, but otherwise the interface is OK.

The machine checks only don't show up because your PCI host bridge is
more tolerant -- I bet you _could_ actually configure it to produce an
NMI, if you really want that kind of behaviour when you poke at
non-existent registers. I think that should be _encouraged_, in fact :)
Or I can dust off the patch I used a while back to debug and recover
from the machine checks.

Unless it's endian-related I suspect the BUG() would probably occur on
i386 too, with the CardBus card I gave away last week and the same
revision of the kernel. Perhaps John can confirm that? (I'm using
2.6.23-0.181.rc6.git4.fc8 today)

I'll poke at it some more when I get home this weekend.


-- 
dwmw2



From larry.finger at lwfinger.net  Fri Sep 14 19:36:24 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Sep 2007 12:36:24 -0500
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <1189787065.4460.4.camel@shinybook.infradead.org>
References: <1189580462.3570.5.camel@shinybook.infradead.org>	<46E99310.2080605@lwfinger.net>	<1189765921.3238.2.camel@shinybook.infradead.org>	<46EAA3C7.8040701@lwfinger.net>
	<1189787065.4460.4.camel@shinybook.infradead.org>
Message-ID: <46EAC698.80107@lwfinger.net>

David Woodhouse wrote:
> 
> The machine checks only don't show up because your PCI host bridge is
> more tolerant -- I bet you _could_ actually configure it to produce an
> NMI, if you really want that kind of behaviour when you poke at
> non-existent registers. I think that should be _encouraged_, in fact :)
> Or I can dust off the patch I used a while back to debug and recover
> from the machine checks.

AFAIK, reading a non-existent register should return all 1's, which is how I found the gmode problem
in yesterday's patch. I'm checking all 16- and 32-bit reads and no longer get any hits on the tests
for 0xFFFF, etc.

> Unless it's endian-related I suspect the BUG() would probably occur on
> i386 too, with the CardBus card I gave away last week and the same
> revision of the kernel. Perhaps John can confirm that? (I'm using
> 2.6.23-0.181.rc6.git4.fc8 today)

I am using a BCM4306/2 CardBus card, which should be the same, on my i386 machine, and it is fine.
Endian issues are another matter.

> I'll poke at it some more when I get home this weekend.

I'll keep looking for endian-related stuff.

Larry




From larry.finger at lwfinger.net  Fri Sep 14 21:05:40 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Sep 2007 14:05:40 -0500
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <1189787065.4460.4.camel@shinybook.infradead.org>
References: <1189580462.3570.5.camel@shinybook.infradead.org>	<46E99310.2080605@lwfinger.net>	<1189765921.3238.2.camel@shinybook.infradead.org>	<46EAA3C7.8040701@lwfinger.net>
	<1189787065.4460.4.camel@shinybook.infradead.org>
Message-ID: <46EADB84.5090909@lwfinger.net>

David Woodhouse wrote:
> 
> Unless it's endian-related I suspect the BUG() would probably occur on
> i386 too, with the CardBus card I gave away last week and the same
> revision of the kernel. Perhaps John can confirm that? (I'm using
> 2.6.23-0.181.rc6.git4.fc8 today)

Are you using DMA or PIO? I did find some PIO endian problems, but none with DMA so far.

Larry



From achrisjo at yahoo.com  Fri Sep 14 22:22:05 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Fri, 14 Sep 2007 13:22:05 -0700 (PDT)
Subject: Any hope ?
Message-ID: <739927.88363.qm@web63702.mail.re1.yahoo.com>

hi,

I had some difficulties with Yahoo, some reply got blocked because
of some line disturbances, or what ever. My ISP have checked my line
today - and think the problem is at yahoo.

I did follow Larry's instructions - and I think I managed to send him
a note. If not, - I just want to thank you all for the assistance.

It turns out that it is a known problem with MCP67M device, and it is
first covered in the 2.6.22.6 kernel. 
Some other trouble need to be fixed..but..
 
Anyway, thanks for your support, and I hope to be able to run
the bcm34xx ;) 

Sorry if I have been i pain in the ass, I sure didn't mean to.
Thank you all for the effort and support !

//ARNE


       
---------------------------------
Be a better Heartthrob. Get better relationship answers from someone who knows.
Yahoo! Answers - Check it out. 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070914/0982fef9/attachment.html>

From dwmw2 at infradead.org  Fri Sep 14 22:45:14 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Fri, 14 Sep 2007 22:45:14 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <46EADB84.5090909@lwfinger.net>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<46E99310.2080605@lwfinger.net>
	<1189765921.3238.2.camel@shinybook.infradead.org>
	<46EAA3C7.8040701@lwfinger.net>
	<1189787065.4460.4.camel@shinybook.infradead.org>
	<46EADB84.5090909@lwfinger.net>
Message-ID: <1189802714.4460.5.camel@shinybook.infradead.org>

On Fri, 2007-09-14 at 14:05 -0500, Larry Finger wrote:
> Are you using DMA or PIO? I did find some PIO endian problems, but
> none with DMA so far.

I don't know -- which probably means DMA, right? I don't have > 1GiB of
RAM (I have precisely 1GiB).

-- 
dwmw2



From mb at bu3sch.de  Fri Sep 14 22:51:27 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Sep 2007 22:51:27 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <1189768098.3238.9.camel@shinybook.infradead.org>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<200709141256.56844.mb@bu3sch.de>
	<1189768098.3238.9.camel@shinybook.infradead.org>
Message-ID: <200709142251.28150.mb@bu3sch.de>

On Friday 14 September 2007 13:08:18 David Woodhouse wrote:
> On Fri, 2007-09-14 at 12:56 +0200, Michael Buesch wrote:
> > Revisions < 5 are not supported by the driver. 
> 
> So there's no way to use this device with v4 firmware any more?

No. That's what b43legacy is for.

-- 
Greetings Michael.


From mb at bu3sch.de  Fri Sep 14 23:07:24 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Sep 2007 23:07:24 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <46EADB84.5090909@lwfinger.net>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<1189787065.4460.4.camel@shinybook.infradead.org>
	<46EADB84.5090909@lwfinger.net>
Message-ID: <200709142307.24439.mb@bu3sch.de>

On Friday 14 September 2007 21:05:40 Larry Finger wrote:
> Are you using DMA or PIO? I did find some PIO endian problems,

Where exactly?

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Fri Sep 14 23:19:36 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Sep 2007 16:19:36 -0500
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <1189802714.4460.5.camel@shinybook.infradead.org>
References: <1189580462.3570.5.camel@shinybook.infradead.org>	
	<46E99310.2080605@lwfinger.net>	
	<1189765921.3238.2.camel@shinybook.infradead.org>	
	<46EAA3C7.8040701@lwfinger.net>	
	<1189787065.4460.4.camel@shinybook.infradead.org>	
	<46EADB84.5090909@lwfinger.net>
	<1189802714.4460.5.camel@shinybook.infradead.org>
Message-ID: <46EAFAE8.5010003@lwfinger.net>

David Woodhouse wrote:
> On Fri, 2007-09-14 at 14:05 -0500, Larry Finger wrote:
>> Are you using DMA or PIO? I did find some PIO endian problems, but
>> none with DMA so far.
> 
> I don't know -- which probably means DMA, right? I don't have > 1GiB of
> RAM (I have precisely 1GiB).

Yes, I would expect that you are using DMA. Up to 1 GiB RAM has no problems. AFAIK, even those with
> 1 GiB and 30-bit cards are OK.

I downloaded the newest version of sparse and there are some endian issues with DMA. These have
already been submitted as a patch, but are in Linville's inbox while he catches up. I have attached
a copy of that patch for you. It should be applied on top of the patch sent earlier today.

Larry
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: b43legacy-sparse-warnings
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070914/793aee56/attachment.ksh>

From larry.finger at lwfinger.net  Fri Sep 14 23:22:00 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Sep 2007 16:22:00 -0500
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <200709142307.24439.mb@bu3sch.de>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<1189787065.4460.4.camel@shinybook.infradead.org>
	<46EADB84.5090909@lwfinger.net> <200709142307.24439.mb@bu3sch.de>
Message-ID: <46EAFB78.8050409@lwfinger.net>

Michael Buesch wrote:
> On Friday 14 September 2007 21:05:40 Larry Finger wrote:
>> Are you using DMA or PIO? I did find some PIO endian problems,
> 
> Where exactly?

drivers/net/wireless/b43legacy/pio.c:612:29: warning: incorrect type in assignment (different base
types)
drivers/net/wireless/b43legacy/pio.c:612:29:    expected unsigned short [unsigned] [short]
[usertype] <noident>
drivers/net/wireless/b43legacy/pio.c:612:29:    got restricted unsigned short [usertype] <noident>

These patches clear up the warnings.

Index: wireless-dev/drivers/net/wireless/b43legacy/pio.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/pio.c
+++ wireless-dev/drivers/net/wireless/b43legacy/pio.c
@@ -66,7 +66,7 @@ static u16 tx_get_next_word(const u8 *tx
                source = packet;
                i -= txhdr_size;
        }
-       ret = le16_to_cpu(*((u16 *)(source + i)));
+       ret = le16_to_cpu(*((__le16 *)(source + i)));
        *pos += 2;

        return ret;
@@ -539,7 +539,7 @@ static void pio_rx_error(struct b43legac

 void b43legacy_pio_rx(struct b43legacy_pioqueue *queue)
 {
-       u16 preamble[21] = { 0 };
+       __le16 preamble[21] = { 0 };
        struct b43legacy_rxhdr_fw3 *rxhdr;
        u16 tmp;
        u16 len;
@@ -609,7 +609,7 @@ data_ready:
        skb_put(skb, len);
        for (i = 0; i < len - 1; i += 2) {
                tmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);
-               *((u16 *)(skb->data + i)) = cpu_to_le16(tmp);
+               *((__le16 *)(skb->data + i)) = cpu_to_le16(tmp);
        }
        if (len % 2) {
                tmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);


From mb at bu3sch.de  Fri Sep 14 23:24:34 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Sep 2007 23:24:34 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <46EAFB78.8050409@lwfinger.net>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<200709142307.24439.mb@bu3sch.de> <46EAFB78.8050409@lwfinger.net>
Message-ID: <200709142324.35028.mb@bu3sch.de>

On Friday 14 September 2007 23:22:00 Larry Finger wrote:
> Michael Buesch wrote:
> > On Friday 14 September 2007 21:05:40 Larry Finger wrote:
> >> Are you using DMA or PIO? I did find some PIO endian problems,
> > 
> > Where exactly?
> 
> drivers/net/wireless/b43legacy/pio.c:612:29: warning: incorrect type in assignment (different base
> types)
> drivers/net/wireless/b43legacy/pio.c:612:29:    expected unsigned short [unsigned] [short]
> [usertype] <noident>
> drivers/net/wireless/b43legacy/pio.c:612:29:    got restricted unsigned short [usertype] <noident>
> 
> These patches clear up the warnings.
> 
> Index: wireless-dev/drivers/net/wireless/b43legacy/pio.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/pio.c
> +++ wireless-dev/drivers/net/wireless/b43legacy/pio.c
> @@ -66,7 +66,7 @@ static u16 tx_get_next_word(const u8 *tx
>                 source = packet;
>                 i -= txhdr_size;
>         }
> -       ret = le16_to_cpu(*((u16 *)(source + i)));
> +       ret = le16_to_cpu(*((__le16 *)(source + i)));
>         *pos += 2;
> 
>         return ret;
> @@ -539,7 +539,7 @@ static void pio_rx_error(struct b43legac
> 
>  void b43legacy_pio_rx(struct b43legacy_pioqueue *queue)
>  {
> -       u16 preamble[21] = { 0 };
> +       __le16 preamble[21] = { 0 };
>         struct b43legacy_rxhdr_fw3 *rxhdr;
>         u16 tmp;
>         u16 len;
> @@ -609,7 +609,7 @@ data_ready:
>         skb_put(skb, len);
>         for (i = 0; i < len - 1; i += 2) {
>                 tmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);
> -               *((u16 *)(skb->data + i)) = cpu_to_le16(tmp);
> +               *((__le16 *)(skb->data + i)) = cpu_to_le16(tmp);
>         }
>         if (len % 2) {
>                 tmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);
> 
> 

That are no endianess issues. These are false sparse positives, because
the wrong types were used. The generated code is the same.

-- 
Greetings Michael.


From mb at bu3sch.de  Fri Sep 14 23:33:42 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 14 Sep 2007 23:33:42 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <46EAFAE8.5010003@lwfinger.net>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<1189802714.4460.5.camel@shinybook.infradead.org>
	<46EAFAE8.5010003@lwfinger.net>
Message-ID: <200709142333.42390.mb@bu3sch.de>

On Friday 14 September 2007 23:19:36 Larry Finger wrote:
> David Woodhouse wrote:
> > On Fri, 2007-09-14 at 14:05 -0500, Larry Finger wrote:
> >> Are you using DMA or PIO? I did find some PIO endian problems, but
> >> none with DMA so far.
> > 
> > I don't know -- which probably means DMA, right? I don't have > 1GiB of
> > RAM (I have precisely 1GiB).
> 
> Yes, I would expect that you are using DMA. Up to 1 GiB RAM has no problems. AFAIK, even those with
> > 1 GiB and 30-bit cards are OK.
> 
> I downloaded the newest version of sparse and there are some endian issues with DMA. These have
> already been submitted as a patch, but are in Linville's inbox while he catches up. I have attached
> a copy of that patch for you. It should be applied on top of the patch sent earlier today.

These are all false positives, except this one, where the wrong
converter function was used.

@@ -442,7 +444,7 @@ void b43legacy_rx(struct b43legacy_wldev
        phystat0 = le16_to_cpu(rxhdr->phy_status0);
        phystat3 = le16_to_cpu(rxhdr->phy_status3);
        jssi = rxhdr->jssi;
-       macstat = le32_to_cpu(rxhdr->mac_status);
+       macstat = le16_to_cpu(rxhdr->mac_status);
        mactime = le16_to_cpu(rxhdr->mac_time);
        chanstat = le16_to_cpu(rxhdr->channel);

But I think in this case this also didn't change the actual
result in macstat.

le32_to_cpu would take the lower two bytes of rxhdr->maxstatus
and put them into 0xDDCCBBAA. Where DD and CC are some "random" value.
That value is casted to u16 then
so we end up with 0xBBAA. The upper two bytes will be discarded.
The le16_to_cpu would take the lower two bytes and correctly
convert them to 0xBBAA.

-- 
Greetings Michael.


From proski at gnu.org  Fri Sep 14 23:56:24 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 14 Sep 2007 17:56:24 -0400
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <200709142333.42390.mb@bu3sch.de>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<1189802714.4460.5.camel@shinybook.infradead.org>
	<46EAFAE8.5010003@lwfinger.net>  <200709142333.42390.mb@bu3sch.de>
Message-ID: <1189806984.13270.9.camel@dv>

On Fri, 2007-09-14 at 23:33 +0200, Michael Buesch wrote:

> -       macstat = le32_to_cpu(rxhdr->mac_status);
> +       macstat = le16_to_cpu(rxhdr->mac_status);
>         mactime = le16_to_cpu(rxhdr->mac_time);
>         chanstat = le16_to_cpu(rxhdr->channel);
> 
> But I think in this case this also didn't change the actual
> result in macstat.

I don't think so.  Suppose rxhdr->mac_status is 1.  le32_to_cpu() will
return 0x1000000, which would turn into 0 on conversion to u16.
le16_to_cpu() will return 0x100.  Since rxhdr->mac_status is accessed by
value (not by pointer), it will be 1 whether it's treated as 32-bit or
16-bit.

-- 
Regards,
Pavel Roskin



From larry.finger at lwfinger.net  Sat Sep 15 00:12:00 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 14 Sep 2007 17:12:00 -0500
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <1189806984.13270.9.camel@dv>
References: <1189580462.3570.5.camel@shinybook.infradead.org>	
	<1189802714.4460.5.camel@shinybook.infradead.org>	
	<46EAFAE8.5010003@lwfinger.net>
	<200709142333.42390.mb@bu3sch.de> <1189806984.13270.9.camel@dv>
Message-ID: <46EB0730.8090905@lwfinger.net>

Pavel Roskin wrote:
> On Fri, 2007-09-14 at 23:33 +0200, Michael Buesch wrote:
> 
>> -       macstat = le32_to_cpu(rxhdr->mac_status);
>> +       macstat = le16_to_cpu(rxhdr->mac_status);
>>         mactime = le16_to_cpu(rxhdr->mac_time);
>>         chanstat = le16_to_cpu(rxhdr->channel);
>>
>> But I think in this case this also didn't change the actual
>> result in macstat.
> 
> I don't think so.  Suppose rxhdr->mac_status is 1.  le32_to_cpu() will
> return 0x1000000, which would turn into 0 on conversion to u16.
> le16_to_cpu() will return 0x100.  Since rxhdr->mac_status is accessed by
> value (not by pointer), it will be 1 whether it's treated as 32-bit or
> 16-bit.

If your analysis is correct (and I think it is), that could explain a problem we are having with
b43legacy on a Powerbook. With V4 firmware, rxhdr->mac_status is 32 bit, thus b43 wouldn't have this
problem, and it wouldn't show up on my x86 hardware with b43legacy.

Larry


From mb at bu3sch.de  Sat Sep 15 00:27:38 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 15 Sep 2007 00:27:38 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <46EB0730.8090905@lwfinger.net>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<1189806984.13270.9.camel@dv> <46EB0730.8090905@lwfinger.net>
Message-ID: <200709150027.38602.mb@bu3sch.de>

On Saturday 15 September 2007 00:12:00 Larry Finger wrote:
> Pavel Roskin wrote:
> > On Fri, 2007-09-14 at 23:33 +0200, Michael Buesch wrote:
> > 
> >> -       macstat = le32_to_cpu(rxhdr->mac_status);
> >> +       macstat = le16_to_cpu(rxhdr->mac_status);
> >>         mactime = le16_to_cpu(rxhdr->mac_time);
> >>         chanstat = le16_to_cpu(rxhdr->channel);
> >>
> >> But I think in this case this also didn't change the actual
> >> result in macstat.
> > 
> > I don't think so.  Suppose rxhdr->mac_status is 1.  le32_to_cpu() will
> > return 0x1000000,

How would it return 0x1000000?
if mac_status is 1 in the lowest byte, le32_to_cpu would not put that 1 into
the highest byte of the result.

> > which would turn into 0 on conversion to u16. 
> > le16_to_cpu() will return 0x100.  Since rxhdr->mac_status is accessed by
> > value (not by pointer), it will be 1 whether it's treated as 32-bit or
> > 16-bit.

Ok, I didn't know it's passed by value.
I thought it was casted to pointer inline.
If it's passed to leX_to_cpu by value, of course it's a different story.

> If your analysis is correct (and I think it is), that could explain a problem we are having with
> b43legacy on a Powerbook. With V4 firmware, rxhdr->mac_status is 32 bit, thus b43 wouldn't have this
> problem, and it wouldn't show up on my x86 hardware with b43legacy.

-- 
Greetings Michael.


From proski at gnu.org  Sat Sep 15 05:56:41 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 14 Sep 2007 23:56:41 -0400
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <200709150027.38602.mb@bu3sch.de>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<1189806984.13270.9.camel@dv> <46EB0730.8090905@lwfinger.net>
	<200709150027.38602.mb@bu3sch.de>
Message-ID: <20070914235641.bcwcrs984kcwgos4@webmail.spamcop.net>

Quoting Michael Buesch <mb at bu3sch.de>:

>> > I don't think so.  Suppose rxhdr->mac_status is 1.  le32_to_cpu() will
>> > return 0x1000000,
>
> How would it return 0x1000000?
> if mac_status is 1 in the lowest byte, le32_to_cpu would not put that 1 into
> the highest byte of the result.

Actually, it would.  On big-endian systems, conversion from  
little-endian to CPU order swaps bytes.

Please note that referring to "the lowest byte" can be confusing.  The  
least significant byte and the byte with the least address are not the  
same on big-endian systems.  Besides, mac_status has a meaning for the  
CPU that is different from its meaning for the hardware in the  
hardware is little-endian but the CPU is not.  What the hardware sees  
as 0x1000000, the CPU sees as 1 before the conversion.  What is least  
significant for one is most significant for another, until the  
conversion is done.

>> > which would turn into 0 on conversion to u16.
>> > le16_to_cpu() will return 0x100.  Since rxhdr->mac_status is accessed by
>> > value (not by pointer), it will be 1 whether it's treated as 32-bit or
>> > 16-bit.
>
> Ok, I didn't know it's passed by value.
> I thought it was casted to pointer inline.
> If it's passed to leX_to_cpu by value, of course it's a different story.

OK.  I'll leave my explanation anyway for benefit of other readers.

-- 
Regards,
Pavel Roskin


From dwmw2 at infradead.org  Sat Sep 15 14:36:14 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Sat, 15 Sep 2007 13:36:14 +0100
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <46EAFAE8.5010003@lwfinger.net>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<46E99310.2080605@lwfinger.net>
	<1189765921.3238.2.camel@shinybook.infradead.org>
	<46EAA3C7.8040701@lwfinger.net>
	<1189787065.4460.4.camel@shinybook.infradead.org>
	<46EADB84.5090909@lwfinger.net>
	<1189802714.4460.5.camel@shinybook.infradead.org>
	<46EAFAE8.5010003@lwfinger.net>
Message-ID: <1189859774.4460.49.camel@shinybook.infradead.org>

On Fri, 2007-09-14 at 16:19 -0500, Larry Finger wrote:
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/xmit.c
> +++ wireless-dev/drivers/net/wireless/b43legacy/xmit.c
> @@ -125,10 +125,12 @@ void b43legacy_generate_plcp_hdr(struct 
>         __u8 *raw = plcp->raw;
>  
>         if (b43legacy_is_ofdm_rate(bitrate)) {
> -               *data = b43legacy_plcp_get_ratecode_ofdm(bitrate);
> +               u16 d;
> +
> +               d = b43legacy_plcp_get_ratecode_ofdm(bitrate);
>                 B43legacy_WARN_ON(octets & 0xF000);
> -               *data |= (octets << 5);
> -               *data = cpu_to_le32(*data);
> +               d |= (octets << 5);
> +               *data = cpu_to_le32(d);
>         } else {
>                 u32 plen;

This one doesn't look like a false positive -- but isn't very clear on
whether it's a uint16_t or a uint32_t either.

-- 
dwmw2



From mb at bu3sch.de  Sat Sep 15 14:55:38 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 15 Sep 2007 14:55:38 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <1189859774.4460.49.camel@shinybook.infradead.org>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<46EAFAE8.5010003@lwfinger.net>
	<1189859774.4460.49.camel@shinybook.infradead.org>
Message-ID: <200709151455.39128.mb@bu3sch.de>

On Saturday 15 September 2007 14:36:14 David Woodhouse wrote:
> On Fri, 2007-09-14 at 16:19 -0500, Larry Finger wrote:
> > --- wireless-dev.orig/drivers/net/wireless/b43legacy/xmit.c
> > +++ wireless-dev/drivers/net/wireless/b43legacy/xmit.c
> > @@ -125,10 +125,12 @@ void b43legacy_generate_plcp_hdr(struct 
> >         __u8 *raw = plcp->raw;
> >  
> >         if (b43legacy_is_ofdm_rate(bitrate)) {
> > -               *data = b43legacy_plcp_get_ratecode_ofdm(bitrate);
> > +               u16 d;
> > +
> > +               d = b43legacy_plcp_get_ratecode_ofdm(bitrate);
> >                 B43legacy_WARN_ON(octets & 0xF000);
> > -               *data |= (octets << 5);
> > -               *data = cpu_to_le32(*data);
> > +               d |= (octets << 5);
> > +               *data = cpu_to_le32(d);
> >         } else {
> >                 u32 plen;
> 
> This one doesn't look like a false positive -- but isn't very clear on
> whether it's a uint16_t or a uint32_t either.

Oh, strange. This is a typo.
The code was correct and this actually broke it.
Not sure why sparse didn't complain about this obviously broken code
and did complain about the previous code, which was OK.
d must be u32, of course.

In any case, it it a false positive warning of sparse.
The attempt to fix it is broken, though.

-- 
Greetings Michael.


From dwmw2 at infradead.org  Sat Sep 15 15:07:13 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Sat, 15 Sep 2007 14:07:13 +0100
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <46EAA3C7.8040701@lwfinger.net>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<46E99310.2080605@lwfinger.net>
	<1189765921.3238.2.camel@shinybook.infradead.org>
	<46EAA3C7.8040701@lwfinger.net>
Message-ID: <1189861633.3742.3.camel@shinybook.infradead.org>

On Fri, 2007-09-14 at 10:07 -0500, Larry Finger wrote:
> The only way that b43legacy_rx() could generate a BUG_ON is if the
> bitrate codes in the received
> message are messed up. The attached patch will partially silence those
> messages and let us see more.
> Perhaps we can find the real cause. I certainly appreciate your
> assistance in debugging these problems. 

With this patch and the later le16_to_cpu(rxhdr->mac_status) change, my
device seems to be working with b43legacy:

b43legacy-phy2: Broadcom 4306 WLAN found
b43legacy-phy2 debug: Found PHY: Analog 1, Type 2, Revision 1
b43legacy-phy2 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
b43legacy-phy2 debug: Radio turned off
wmaster0: Selected rate control algorithm 'simple'
net eth1: device_rename: sysfs_create_symlink failed (-17)
b43legacy-phy2 debug: Adding Interface type 2
b43legacy-phy2 debug: Loading firmware version 0x127, patch level 14 (2005-04-18 02:36:27)
b43legacy-phy2 debug: Radio turned on
b43legacy-phy2 debug: Radio enabled by hardware
b43legacy-phy2 debug: Chip initialized
b43legacy-phy2 debug: 30-bit DMA initialized
b43legacy-phy2 debug: Wireless interface started
ADDRCONF(NETDEV_UP): eth1: link is not ready
b43legacy-phy2 debug: Using software based encryption for mac: ff:ff:ff:ff:ff:ff
eth1: Initial auth_alg=0
eth1: authenticate with AP 00:06:25:4b:55:f8
eth1: RX authentication from 00:06:25:4b:55:f8 (alg=0 transaction=2 status=0)
eth1: authenticated
eth1: associate with AP 00:06:25:4b:55:f8
eth1: RX AssocResp from 00:06:25:4b:55:f8 (capab=0x411 status=0 aid=1)
eth1: associated
eth1: switched to short barker preamble (BSSID=00:06:25:4b:55:f8)
ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready


-- 
dwmw2



From mb at bu3sch.de  Sat Sep 15 17:39:00 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 15 Sep 2007 17:39:00 +0200
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <200709151455.39128.mb@bu3sch.de>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<1189859774.4460.49.camel@shinybook.infradead.org>
	<200709151455.39128.mb@bu3sch.de>
Message-ID: <200709151739.00756.mb@bu3sch.de>

On Saturday 15 September 2007 14:55:38 Michael Buesch wrote:
> On Saturday 15 September 2007 14:36:14 David Woodhouse wrote:
> > On Fri, 2007-09-14 at 16:19 -0500, Larry Finger wrote:
> > > --- wireless-dev.orig/drivers/net/wireless/b43legacy/xmit.c
> > > +++ wireless-dev/drivers/net/wireless/b43legacy/xmit.c
> > > @@ -125,10 +125,12 @@ void b43legacy_generate_plcp_hdr(struct 
> > >         __u8 *raw = plcp->raw;
> > >  
> > >         if (b43legacy_is_ofdm_rate(bitrate)) {
> > > -               *data = b43legacy_plcp_get_ratecode_ofdm(bitrate);
> > > +               u16 d;
> > > +
> > > +               d = b43legacy_plcp_get_ratecode_ofdm(bitrate);
> > >                 B43legacy_WARN_ON(octets & 0xF000);
> > > -               *data |= (octets << 5);
> > > -               *data = cpu_to_le32(*data);
> > > +               d |= (octets << 5);
> > > +               *data = cpu_to_le32(d);
> > >         } else {
> > >                 u32 plen;
> > 
> > This one doesn't look like a false positive -- but isn't very clear on
> > whether it's a uint16_t or a uint32_t either.
> 
> Oh, strange. This is a typo.
> The code was correct and this actually broke it.
> Not sure why sparse didn't complain about this obviously broken code
> and did complain about the previous code, which was OK.
> d must be u32, of course.
> 
> In any case, it it a false positive warning of sparse.
> The attempt to fix it is broken, though.
> 

Here's the fix for b43:
http://bu3sch.de/patches/wireless-dev/20070915-1740/patches/010-b43-fix-plcp-type-declaration.patch

-- 
Greetings Michael.


From Larry.Finger at lwfinger.net  Sat Sep 15 19:39:34 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 15 Sep 2007 12:39:34 -0500
Subject: [PATCH] b43legacy: Fix machine check errors for PPC architecture
	with BCM4306/2
Message-ID: <46ec18d6.puwbD1oRuPgUil6/%Larry.Finger@lwfinger.net>

In b43, the variable gmode merely indicates whether the given core
has a GPHY or a BPHY. In b43legacy, this is always true; however,
on a BCM4306/2 it must be set only when the PHY is connected to the
ssb backplane, otherwise, reads of the PHY registers are invalid.
For x86 architecture, these read failures cause no problems; however,
on the ppc architecture, they cause a machine check. This patch has been
tested on an i386 platform using special code to detect these invalid
reads, and on two different Powerbooks.
 
Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This patch fixes a problem with the Fedora Rawhide kernel reported by David
Woodhouse on the bcm43xx mailing list and by Will Woods at 
https://bugzilla.redhat.com/show_bug.cgi?id=233011.

Larry

 drivers/net/wireless/b43legacy/main.c |    5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -738,8 +738,11 @@ void b43legacy_wireless_core_reset(struc
 
 	macctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);
 	macctl &= ~B43legacy_MACCTL_GMODE;
-	if (flags & B43legacy_TMSLOW_GMODE)
+	if (flags & B43legacy_TMSLOW_GMODE) {
 		macctl |= B43legacy_MACCTL_GMODE;
+		dev->phy.gmode = 1;
+	} else
+		dev->phy.gmode = 0;
 	macctl |= B43legacy_MACCTL_IHR_ENABLED;
 	b43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);
 }
@@ -3424,7 +3427,6 @@ static int b43legacy_wireless_core_attac
 	int err;
 	int have_bphy = 0;
 	int have_gphy = 0;
-	u32 tmp;
 
 	/* Do NOT do any device initialization here.
 	 * Do it in wireless_core_init() instead.
@@ -3456,9 +3458,7 @@ static int b43legacy_wireless_core_attac
 	if (err)
 		goto err_powerdown;
 
-	dev->phy.gmode = (have_gphy || have_bphy);
-	tmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;
-	b43legacy_wireless_core_reset(dev, tmp);
+	b43legacy_wireless_core_reset(dev, B43legacy_TMSLOW_GMODE);
 
 	err = b43legacy_phy_versioning(dev);
 	if (err)
@@ -3482,9 +3482,7 @@ static int b43legacy_wireless_core_attac
 			B43legacy_BUG_ON(1);
 		}
 	}
-	dev->phy.gmode = (have_gphy || have_bphy);
-	tmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;
-	b43legacy_wireless_core_reset(dev, tmp);
+	b43legacy_wireless_core_reset(dev, B43legacy_TMSLOW_GMODE);
 
 	err = b43legacy_validate_chipaccess(dev);
 	if (err)
Index: wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/b43legacy.h
+++ wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
@@ -389,7 +389,7 @@ struct b43legacy_lopair {
 struct b43legacy_phy {
 	/* Possible PHYMODEs on this PHY */
 	u8 possible_phymodes;
-	/* GMODE bit enabled? */
+	/* True if PHY connected to ssb backplane */
 	bool gmode;
 	/* Possible ieee80211 subsystem hwmodes for this PHY.
 	 * Which mode is selected, depends on thr GMODE enabled bit */
Index: wireless-dev/drivers/net/wireless/b43legacy/xmit.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/xmit.c
+++ wireless-dev/drivers/net/wireless/b43legacy/xmit.c
@@ -49,8 +49,8 @@ static u8 b43legacy_plcp_get_bitrate_cck
 	case 0x6E:
 		return B43legacy_CCK_RATE_11MB;
 	}
-	B43legacy_BUG_ON(1);
-	return 0;
+	printk(KERN_INFO "b43legacy: Invalid CCK bitrate of 0x%X\n", plcp->raw[0]);
+	return B43legacy_CCK_RATE_1MB;
 }
 
 /* Extract the bitrate out of an OFDM PLCP header. */
@@ -74,8 +74,8 @@ static u8 b43legacy_plcp_get_bitrate_ofd
 	case 0xC:
 		return B43legacy_OFDM_RATE_54MB;
 	}
-	B43legacy_BUG_ON(1);
-	return 0;
+	printk(KERN_INFO "b43legacy: Invalid OFDM bitrate of 0x%X\n", plcp->raw[0] & 0xF);
+	return B43legacy_OFDM_RATE_6MB;
 }
 
 u8 b43legacy_plcp_get_ratecode_cck(const u8 bitrate)
@@ -90,8 +90,8 @@ u8 b43legacy_plcp_get_ratecode_cck(const
 	case B43legacy_CCK_RATE_11MB:
 		return 0x6E;
 	}
-	B43legacy_BUG_ON(1);
-	return 0;
+	printk(KERN_INFO "b43legacy: Invalid CCK ratecode of 0x%X\n", bitrate);
+	return 0x0A;
 }
 
 u8 b43legacy_plcp_get_ratecode_ofdm(const u8 bitrate)
@@ -114,8 +114,8 @@ u8 b43legacy_plcp_get_ratecode_ofdm(cons
 	case B43legacy_OFDM_RATE_54MB:
 		return 0xC;
 	}
-	B43legacy_BUG_ON(1);
-	return 0;
+	printk(KERN_INFO "b43legacy: Invalid OFDM ratecode of 0x%X\n", bitrate);
+	return 0x0B;
 }
 
 void b43legacy_generate_plcp_hdr(struct b43legacy_plcp_hdr4 *plcp,


From mb at bu3sch.de  Sat Sep 15 19:48:46 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 15 Sep 2007 19:48:46 +0200
Subject: [PATCH] b43legacy: Fix machine check errors for PPC architecture
	with BCM4306/2
In-Reply-To: <46ec18d6.puwbD1oRuPgUil6/%Larry.Finger@lwfinger.net>
References: <46ec18d6.puwbD1oRuPgUil6/%Larry.Finger@lwfinger.net>
Message-ID: <200709151948.46667.mb@bu3sch.de>

On Saturday 15 September 2007 19:39:34 Larry Finger wrote:
> In b43, the variable gmode merely indicates whether the given core
> has a GPHY or a BPHY. In b43legacy, this is always true; however,
> on a BCM4306/2 it must be set only when the PHY is connected to the
> ssb backplane, otherwise, reads of the PHY registers are invalid.
> For x86 architecture, these read failures cause no problems; however,
> on the ppc architecture, they cause a machine check. This patch has been
> tested on an i386 platform using special code to detect these invalid
> reads, and on two different Powerbooks.
>  
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John,
> 
> This patch fixes a problem with the Fedora Rawhide kernel reported by David
> Woodhouse on the bcm43xx mailing list and by Will Woods at 
> https://bugzilla.redhat.com/show_bug.cgi?id=233011.
> 
> Larry
> 
>  drivers/net/wireless/b43legacy/main.c |    5 ++++-
>  1 file changed, 4 insertions(+), 1 deletion(-)
> 
> Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
> +++ wireless-dev/drivers/net/wireless/b43legacy/main.c
> @@ -738,8 +738,11 @@ void b43legacy_wireless_core_reset(struc
>  
>  	macctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);
>  	macctl &= ~B43legacy_MACCTL_GMODE;
> -	if (flags & B43legacy_TMSLOW_GMODE)
> +	if (flags & B43legacy_TMSLOW_GMODE) {
>  		macctl |= B43legacy_MACCTL_GMODE;
> +		dev->phy.gmode = 1;
> +	} else
> +		dev->phy.gmode = 0;
>  	macctl |= B43legacy_MACCTL_IHR_ENABLED;
>  	b43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);
>  }
> @@ -3424,7 +3427,6 @@ static int b43legacy_wireless_core_attac
>  	int err;
>  	int have_bphy = 0;
>  	int have_gphy = 0;
> -	u32 tmp;
>  
>  	/* Do NOT do any device initialization here.
>  	 * Do it in wireless_core_init() instead.
> @@ -3456,9 +3458,7 @@ static int b43legacy_wireless_core_attac
>  	if (err)
>  		goto err_powerdown;
>  
> -	dev->phy.gmode = (have_gphy || have_bphy);
> -	tmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;
> -	b43legacy_wireless_core_reset(dev, tmp);
> +	b43legacy_wireless_core_reset(dev, B43legacy_TMSLOW_GMODE);
>  
>  	err = b43legacy_phy_versioning(dev);
>  	if (err)
> @@ -3482,9 +3482,7 @@ static int b43legacy_wireless_core_attac
>  			B43legacy_BUG_ON(1);
>  		}
>  	}
> -	dev->phy.gmode = (have_gphy || have_bphy);
> -	tmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;
> -	b43legacy_wireless_core_reset(dev, tmp);
> +	b43legacy_wireless_core_reset(dev, B43legacy_TMSLOW_GMODE);
>  
>  	err = b43legacy_validate_chipaccess(dev);
>  	if (err)
> Index: wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/b43legacy.h
> +++ wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
> @@ -389,7 +389,7 @@ struct b43legacy_lopair {
>  struct b43legacy_phy {
>  	/* Possible PHYMODEs on this PHY */
>  	u8 possible_phymodes;
> -	/* GMODE bit enabled? */
> +	/* True if PHY connected to ssb backplane */
>  	bool gmode;

Nono, wait. That "PHY Connected" bit never existed. It was a bug
in the specification. It really is "Drive the PHY in G-mode".
It has nothing to do with "connecting" something.
So your changes above are, strictly said, also wrong.
The bit must be enabled, if we want to use the G-mode PHY on the
device and disabled otherwise. This is for multi-phy devices with
an A PHY and a B/G PHY.
So, well. As you won't ever support an A-PHY in the driver, I am
probably OK with always forcing the GMODE bit on (which your above code does,
but I don't see how this could fix anything). Better, yet, fix the _real_
cause why gmode wasn't set (that's what you are trying to fix, no?)
And please don't break the comment above. :)
It _really_ is a "GMODE bit enabled" bit.

Again: This has nothing to do with connecting some PHY to anything.

>  	/* Possible ieee80211 subsystem hwmodes for this PHY.
>  	 * Which mode is selected, depends on thr GMODE enabled bit */
> Index: wireless-dev/drivers/net/wireless/b43legacy/xmit.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/xmit.c
> +++ wireless-dev/drivers/net/wireless/b43legacy/xmit.c
> @@ -49,8 +49,8 @@ static u8 b43legacy_plcp_get_bitrate_cck
>  	case 0x6E:
>  		return B43legacy_CCK_RATE_11MB;
>  	}
> -	B43legacy_BUG_ON(1);
> -	return 0;
> +	printk(KERN_INFO "b43legacy: Invalid CCK bitrate of 0x%X\n", plcp->raw[0]);
> +	return B43legacy_CCK_RATE_1MB;

Please ratelimit this message, if you really want a message here.

>  }
>  
>  /* Extract the bitrate out of an OFDM PLCP header. */
> @@ -74,8 +74,8 @@ static u8 b43legacy_plcp_get_bitrate_ofd
>  	case 0xC:
>  		return B43legacy_OFDM_RATE_54MB;
>  	}
> -	B43legacy_BUG_ON(1);
> -	return 0;
> +	printk(KERN_INFO "b43legacy: Invalid OFDM bitrate of 0x%X\n", plcp->raw[0] & 0xF);
> +	return B43legacy_OFDM_RATE_6MB;
>  }

Same.

>  u8 b43legacy_plcp_get_ratecode_cck(const u8 bitrate)
> @@ -90,8 +90,8 @@ u8 b43legacy_plcp_get_ratecode_cck(const
>  	case B43legacy_CCK_RATE_11MB:
>  		return 0x6E;
>  	}
> -	B43legacy_BUG_ON(1);
> -	return 0;
> +	printk(KERN_INFO "b43legacy: Invalid CCK ratecode of 0x%X\n", bitrate);
> +	return 0x0A;
>  }

Same.

>  u8 b43legacy_plcp_get_ratecode_ofdm(const u8 bitrate)
> @@ -114,8 +114,8 @@ u8 b43legacy_plcp_get_ratecode_ofdm(cons
>  	case B43legacy_OFDM_RATE_54MB:
>  		return 0xC;
>  	}
> -	B43legacy_BUG_ON(1);
> -	return 0;
> +	printk(KERN_INFO "b43legacy: Invalid OFDM ratecode of 0x%X\n", bitrate);
> +	return 0x0B;
>  }

Same.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sat Sep 15 20:07:22 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 15 Sep 2007 13:07:22 -0500
Subject: [PATCH] b43legacy: Fix machine check errors for PPC architecture
	with BCM4306/2
In-Reply-To: <200709151948.46667.mb@bu3sch.de>
References: <46ec18d6.puwbD1oRuPgUil6/%Larry.Finger@lwfinger.net>
	<200709151948.46667.mb@bu3sch.de>
Message-ID: <46EC1F5A.7030800@lwfinger.net>

Michael Buesch wrote:
> On Saturday 15 September 2007 19:39:34 Larry Finger wrote:
>> In b43, the variable gmode merely indicates whether the given core
>> has a GPHY or a BPHY. In b43legacy, this is always true; however,
>> on a BCM4306/2 it must be set only when the PHY is connected to the
>> ssb backplane, otherwise, reads of the PHY registers are invalid.
>> For x86 architecture, these read failures cause no problems; however,
>> on the ppc architecture, they cause a machine check. This patch has been
>> tested on an i386 platform using special code to detect these invalid
>> reads, and on two different Powerbooks.
>>  
>> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
>> ---
>>
>> John,
>>
>> This patch fixes a problem with the Fedora Rawhide kernel reported by David
>> Woodhouse on the bcm43xx mailing list and by Will Woods at 
>> https://bugzilla.redhat.com/show_bug.cgi?id=233011.
>>
>> Larry
>>
>>  drivers/net/wireless/b43legacy/main.c |    5 ++++-
>>  1 file changed, 4 insertions(+), 1 deletion(-)
>>
>> Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
>> ===================================================================
>> --- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
>> +++ wireless-dev/drivers/net/wireless/b43legacy/main.c
>> @@ -738,8 +738,11 @@ void b43legacy_wireless_core_reset(struc
>>  
>>  	macctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);
>>  	macctl &= ~B43legacy_MACCTL_GMODE;
>> -	if (flags & B43legacy_TMSLOW_GMODE)
>> +	if (flags & B43legacy_TMSLOW_GMODE) {
>>  		macctl |= B43legacy_MACCTL_GMODE;
>> +		dev->phy.gmode = 1;
>> +	} else
>> +		dev->phy.gmode = 0;
>>  	macctl |= B43legacy_MACCTL_IHR_ENABLED;
>>  	b43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);
>>  }
>> @@ -3424,7 +3427,6 @@ static int b43legacy_wireless_core_attac
>>  	int err;
>>  	int have_bphy = 0;
>>  	int have_gphy = 0;
>> -	u32 tmp;
>>  
>>  	/* Do NOT do any device initialization here.
>>  	 * Do it in wireless_core_init() instead.
>> @@ -3456,9 +3458,7 @@ static int b43legacy_wireless_core_attac
>>  	if (err)
>>  		goto err_powerdown;
>>  
>> -	dev->phy.gmode = (have_gphy || have_bphy);
>> -	tmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;
>> -	b43legacy_wireless_core_reset(dev, tmp);
>> +	b43legacy_wireless_core_reset(dev, B43legacy_TMSLOW_GMODE);
>>  
>>  	err = b43legacy_phy_versioning(dev);
>>  	if (err)
>> @@ -3482,9 +3482,7 @@ static int b43legacy_wireless_core_attac
>>  			B43legacy_BUG_ON(1);
>>  		}
>>  	}
>> -	dev->phy.gmode = (have_gphy || have_bphy);
>> -	tmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;
>> -	b43legacy_wireless_core_reset(dev, tmp);
>> +	b43legacy_wireless_core_reset(dev, B43legacy_TMSLOW_GMODE);
>>  
>>  	err = b43legacy_validate_chipaccess(dev);
>>  	if (err)
>> Index: wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
>> ===================================================================
>> --- wireless-dev.orig/drivers/net/wireless/b43legacy/b43legacy.h
>> +++ wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
>> @@ -389,7 +389,7 @@ struct b43legacy_lopair {
>>  struct b43legacy_phy {
>>  	/* Possible PHYMODEs on this PHY */
>>  	u8 possible_phymodes;
>> -	/* GMODE bit enabled? */
>> +	/* True if PHY connected to ssb backplane */
>>  	bool gmode;
> 
> Nono, wait. That "PHY Connected" bit never existed. It was a bug
> in the specification. It really is "Drive the PHY in G-mode".
> It has nothing to do with "connecting" something.
> So your changes above are, strictly said, also wrong.
> The bit must be enabled, if we want to use the G-mode PHY on the
> device and disabled otherwise. This is for multi-phy devices with
> an A PHY and a B/G PHY.
> So, well. As you won't ever support an A-PHY in the driver, I am
> probably OK with always forcing the GMODE bit on (which your above code does,
> but I don't see how this could fix anything). Better, yet, fix the _real_
> cause why gmode wasn't set (that's what you are trying to fix, no?)
> And please don't break the comment above. :)
> It _really_ is a "GMODE bit enabled" bit.
> 
> Again: This has nothing to do with connecting some PHY to anything.

Your comments may be correct; however, the fact remains that with a rev 4 BCM4306, the original code
generates many, many machine checks on PPC architecture, and I get reads with all ones on i386
indicating that the read is invalid. These all occur before the firmware is loaded. Making the
"gmode" bit mimic the behavior of the phy_connected variable of bcm43xx gets rid of the problems on
both platforms. The registers that error are not just the extended GPHY registers that caused
problems in the past, but all the PHY registers.

If you can suggest a reordering of the initialization that delays PHY setup until the "magic step"
that eliminates this problem is done on/to the ssb backplane, I will be happy to test it. I was
unable to find such a solution.

Larry



From mb at bu3sch.de  Sat Sep 15 20:10:07 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 15 Sep 2007 20:10:07 +0200
Subject: [PATCH] b43legacy: Fix machine check errors for PPC architecture
	with BCM4306/2
In-Reply-To: <46EC1F5A.7030800@lwfinger.net>
References: <46ec18d6.puwbD1oRuPgUil6/%Larry.Finger@lwfinger.net>
	<200709151948.46667.mb@bu3sch.de> <46EC1F5A.7030800@lwfinger.net>
Message-ID: <200709152010.07647.mb@bu3sch.de>

On Saturday 15 September 2007 20:07:22 Larry Finger wrote:
> Your comments may be correct; however, the fact remains that with a rev 4 BCM4306, the original code
> generates many, many machine checks on PPC architecture, and I get reads with all ones on i386
> indicating that the read is invalid. These all occur before the firmware is loaded. Making the
> "gmode" bit mimic the behavior of the phy_connected variable of bcm43xx gets rid of the problems on
> both platforms.

Sure. But if you workaround this like that, you could
as well get completely rid of the gmode bit, as you always force it on.
But I think that's not what we want. The real fix is simple. See below.

> The registers that error are not just the extended GPHY registers that caused 
> problems in the past, but all the PHY registers.

Nobody is talking about the extG registers.

> If you can suggest a reordering of the initialization that delays PHY setup until the "magic step"
> that eliminates this problem is done on/to the ssb backplane, I will be happy to test it. I was
> unable to find such a solution.

There is no reordering needed.
You just need to find out why phy->gmode was not set.
I think it's set based on the have_gphy and have_bphy bits.
So you need to look there why one of these is not set. That is the real
cause of the issue.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sat Sep 15 21:12:04 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 15 Sep 2007 14:12:04 -0500
Subject: [PATCH] b43legacy: Fix machine check errors for PPC architecture
	with BCM4306/2
In-Reply-To: <200709152010.07647.mb@bu3sch.de>
References: <46ec18d6.puwbD1oRuPgUil6/%Larry.Finger@lwfinger.net>
	<200709151948.46667.mb@bu3sch.de> <46EC1F5A.7030800@lwfinger.net>
	<200709152010.07647.mb@bu3sch.de>
Message-ID: <46EC2E84.4080901@lwfinger.net>

Michael Buesch wrote:
> On Saturday 15 September 2007 20:07:22 Larry Finger wrote:
>> Your comments may be correct; however, the fact remains that with a rev 4 BCM4306, the original code
>> generates many, many machine checks on PPC architecture, and I get reads with all ones on i386
>> indicating that the read is invalid. These all occur before the firmware is loaded. Making the
>> "gmode" bit mimic the behavior of the phy_connected variable of bcm43xx gets rid of the problems on
>> both platforms.
> 
> Sure. But if you workaround this like that, you could
> as well get completely rid of the gmode bit, as you always force it on.
> But I think that's not what we want. The real fix is simple. See below.
> 
> 
>> If you can suggest a reordering of the initialization that delays PHY setup until the "magic step"
>> that eliminates this problem is done on/to the ssb backplane, I will be happy to test it. I was
>> unable to find such a solution.
> 
> There is no reordering needed.
> You just need to find out why phy->gmode was not set.
> I think it's set based on the have_gphy and have_bphy bits.
> So you need to look there why one of these is not set. That is the real
> cause of the issue.

In the original code, have_gphy was true, and phy->gmode was set. These variables were not the cause.

In bcm43xx, the second argument to wireless_core_reset controls the value of phy->connected at exit.
This behavior is missing in the original b43legacy (and in b43). For b43, it seems to have no
consequence, but for the early PHYs, phy->connected controls when certain registers can be
read/written and affects the program flow through the phy and radio initialization. The lack of the
ability to toggle gmode is what leads to the register errors, and this is what my change restores.
The name could be changed, but that seems more intrusive than necessary.

Larry




From mb at bu3sch.de  Sat Sep 15 21:47:57 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 15 Sep 2007 21:47:57 +0200
Subject: [PATCH] b43legacy: Fix machine check errors for PPC architecture
	with BCM4306/2
In-Reply-To: <46EC2E84.4080901@lwfinger.net>
References: <46ec18d6.puwbD1oRuPgUil6/%Larry.Finger@lwfinger.net>
	<200709152010.07647.mb@bu3sch.de> <46EC2E84.4080901@lwfinger.net>
Message-ID: <200709152147.57431.mb@bu3sch.de>

On Saturday 15 September 2007 21:12:04 Larry Finger wrote:
> Michael Buesch wrote:
> > On Saturday 15 September 2007 20:07:22 Larry Finger wrote:
> >> Your comments may be correct; however, the fact remains that with a rev 4 BCM4306, the original code
> >> generates many, many machine checks on PPC architecture, and I get reads with all ones on i386
> >> indicating that the read is invalid. These all occur before the firmware is loaded. Making the
> >> "gmode" bit mimic the behavior of the phy_connected variable of bcm43xx gets rid of the problems on
> >> both platforms.
> > 
> > Sure. But if you workaround this like that, you could
> > as well get completely rid of the gmode bit, as you always force it on.
> > But I think that's not what we want. The real fix is simple. See below.
> > 
> > 
> >> If you can suggest a reordering of the initialization that delays PHY setup until the "magic step"
> >> that eliminates this problem is done on/to the ssb backplane, I will be happy to test it. I was
> >> unable to find such a solution.
> > 
> > There is no reordering needed.
> > You just need to find out why phy->gmode was not set.
> > I think it's set based on the have_gphy and have_bphy bits.
> > So you need to look there why one of these is not set. That is the real
> > cause of the issue.
> 
> In the original code, have_gphy was true, and phy->gmode was set. These variables were not the cause.
> 
> In bcm43xx, the second argument to wireless_core_reset controls the value of phy->connected at exit.
> This behavior is missing in the original b43legacy (and in b43). For b43, it seems to have no
> consequence, but for the early PHYs, phy->connected controls when certain registers can be
> read/written and affects the program flow through the phy and radio initialization. The lack of the
> ability to toggle gmode is what leads to the register errors, and this is what my change restores.
> The name could be changed, but that seems more intrusive than necessary.

No, your patch doesn't restore anything. It rips out the gmode logic.
I just want to make sure you understand what you are actually doing there.
the old phy->connected semantics were completely broken. Forget about them.
The problem here is, that at some point phy->gmode is not set, where
it should be set (or the other way around).
So it's not about renaming or something.

With your patch you remove the "gmode" semantics, so you could
as well remove the whole variable and always assume it's set.
But I don't recommend to go that way. I'd suggest you find the
place in the code where phy->gmode is not set but it should be.
_that_ is the place where the real bug is.

Just want to make sure you understand the consequences of your patch.
You remove a feature with that.
If that feature is really needed in legacy; that is another question.
It's needed if you want to drive APHY devices.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sat Sep 15 23:01:56 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 15 Sep 2007 16:01:56 -0500
Subject: [PATCH] b43legacy: Fix machine check errors for PPC architecture
	with BCM4306/2
In-Reply-To: <200709152147.57431.mb@bu3sch.de>
References: <46ec18d6.puwbD1oRuPgUil6/%Larry.Finger@lwfinger.net>
	<200709152010.07647.mb@bu3sch.de> <46EC2E84.4080901@lwfinger.net>
	<200709152147.57431.mb@bu3sch.de>
Message-ID: <46EC4844.1060003@lwfinger.net>

Michael Buesch wrote:
> With your patch you remove the "gmode" semantics, so you could
> as well remove the whole variable and always assume it's set.
> But I don't recommend to go that way. I'd suggest you find the
> place in the code where phy->gmode is not set but it should be.
> _that_ is the place where the real bug is.
> 
> Just want to make sure you understand the consequences of your patch.
> You remove a feature with that.
> If that feature is really needed in legacy; that is another question.
> It's needed if you want to drive APHY devices.

All of the devices that b43legacy drives have either a BPHY or a GPHY. The current logic always sets
gmode and that feature is meaningless. Anyone overriding the rules that select this driver in order
to operate with an APHY device will hit a BUG_ON in wireless_core_attach.

I have generated and tested a patch that changes back to the old 'connected' variable. That will
avoid the semantics argument and match the V3 specs.

Larry




From Larry.Finger at lwfinger.net  Sat Sep 15 23:22:20 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 15 Sep 2007 16:22:20 -0500
Subject: [PATCH V2] b43legacy: Fix machine check errors for PPC
	architecture with BCM4306/2
Message-ID: <46ec4d0c.PU+VRueOH3Peh6s5%Larry.Finger@lwfinger.net>

In b43legacy, the variable gmode is always set. With a BCM4306/2,
and likely a BCM4301, a variable is needed to control the execution
path through the PHY and radio initialization, otherwise there are
attempts to read from invalid registers. On x86 platforms, these
read failures cause no problems; however they lead to machine check
errors for the ppc architecture. This patch reverts to the variable
and semantics used in the V3 specifications. It has been tested on
an i386 platform using special code to detect these invalid reads,
and on at least one Powerbook.
 
Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This patch fixes a problem with the Fedora Rawhide kernel reported by David
Woodhouse on the bcm43xx mailing list and by Will Woods at 
https://bugzilla.redhat.com/show_bug.cgi?id=233011. 

Larry

 drivers/net/wireless/b43legacy/main.c |    5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -738,8 +738,11 @@ void b43legacy_wireless_core_reset(struc
 
 	macctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);
 	macctl &= ~B43legacy_MACCTL_GMODE;
-	if (flags & B43legacy_TMSLOW_GMODE)
+	if (flags & B43legacy_TMSLOW_GMODE) {
 		macctl |= B43legacy_MACCTL_GMODE;
+		dev->phy.connected = 1;
+	} else
+		dev->phy.connected = 0;
 	macctl |= B43legacy_MACCTL_IHR_ENABLED;
 	b43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);
 }
@@ -2464,15 +2467,15 @@ static const char *phymode_to_string(uns
 static int find_wldev_for_phymode(struct b43legacy_wl *wl,
 				  unsigned int phymode,
 				  struct b43legacy_wldev **dev,
-				  bool *gmode)
+				  bool *connected)
 {
 	struct b43legacy_wldev *d;
 
 	list_for_each_entry(d, &wl->devlist, list) {
 		if (d->phy.possible_phymodes & phymode) {
 			/* Ok, this device supports the PHY-mode.
-			 * Set the gmode bit. */
-			*gmode = 1;
+			 * Set the connected bit. */
+			*connected = 1;
 			*dev = d;
 
 			return 0;
@@ -2508,17 +2511,17 @@ static int b43legacy_switch_phymode(stru
 	struct b43legacy_wldev *up_dev;
 	struct b43legacy_wldev *down_dev;
 	int err;
-	bool gmode = 0;
+	bool connected = 0;
 	int prev_status;
 
-	err = find_wldev_for_phymode(wl, new_mode, &up_dev, &gmode);
+	err = find_wldev_for_phymode(wl, new_mode, &up_dev, &connected);
 	if (err) {
 		b43legacyerr(wl, "Could not find a device for %s-PHY mode\n",
 		       phymode_to_string(new_mode));
 		return err;
 	}
 	if ((up_dev == wl->current_dev) &&
-	    (!!wl->current_dev->phy.gmode == !!gmode))
+	    (!!wl->current_dev->phy.connected == !!connected))
 		/* This device is already running. */
 		return 0;
 	b43legacydbg(wl, "Reconfiguring PHYmode to %s-PHY\n",
@@ -2538,7 +2541,7 @@ static int b43legacy_switch_phymode(stru
 		b43legacy_put_phy_into_reset(down_dev);
 
 	/* Now start the new core. */
-	up_dev->phy.gmode = gmode;
+	up_dev->phy.connected = connected;
 	if (prev_status >= B43legacy_STAT_INITIALIZED) {
 		err = b43legacy_wireless_core_init(up_dev);
 		if (err) {
@@ -3094,7 +3097,7 @@ static int b43legacy_wireless_core_init(
 	if (err)
 		goto out;
 	if (!ssb_device_is_enabled(dev->dev)) {
-		tmp = phy->gmode ? B43legacy_TMSLOW_GMODE : 0;
+		tmp = phy->connected ? B43legacy_TMSLOW_GMODE : 0;
 		b43legacy_wireless_core_reset(dev, tmp);
 	}
 
@@ -3424,7 +3427,6 @@ static int b43legacy_wireless_core_attac
 	int err;
 	int have_bphy = 0;
 	int have_gphy = 0;
-	u32 tmp;
 
 	/* Do NOT do any device initialization here.
 	 * Do it in wireless_core_init() instead.
@@ -3456,9 +3458,7 @@ static int b43legacy_wireless_core_attac
 	if (err)
 		goto err_powerdown;
 
-	dev->phy.gmode = (have_gphy || have_bphy);
-	tmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;
-	b43legacy_wireless_core_reset(dev, tmp);
+	b43legacy_wireless_core_reset(dev, B43legacy_TMSLOW_GMODE);
 
 	err = b43legacy_phy_versioning(dev);
 	if (err)
@@ -3482,9 +3482,7 @@ static int b43legacy_wireless_core_attac
 			B43legacy_BUG_ON(1);
 		}
 	}
-	dev->phy.gmode = (have_gphy || have_bphy);
-	tmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;
-	b43legacy_wireless_core_reset(dev, tmp);
+	b43legacy_wireless_core_reset(dev, B43legacy_TMSLOW_GMODE);
 
 	err = b43legacy_validate_chipaccess(dev);
 	if (err)
Index: wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/b43legacy.h
+++ wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
@@ -389,10 +389,10 @@ struct b43legacy_lopair {
 struct b43legacy_phy {
 	/* Possible PHYMODEs on this PHY */
 	u8 possible_phymodes;
-	/* GMODE bit enabled? */
-	bool gmode;
+	/* true if PHY registers can be accessed */
+	bool connected;
 	/* Possible ieee80211 subsystem hwmodes for this PHY.
-	 * Which mode is selected, depends on thr GMODE enabled bit */
+	 * This will be either G or B mode */
 #define B43legacy_MAX_PHYHWMODES	2
 	struct ieee80211_hw_mode hwmodes[B43legacy_MAX_PHYHWMODES];
 
Index: wireless-dev/drivers/net/wireless/b43legacy/phy.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/phy.c
+++ wireless-dev/drivers/net/wireless/b43legacy/phy.c
@@ -176,7 +176,7 @@ static void b43legacy_phy_init_pctl(stru
 	b43legacy_write16(dev, 0x03E6, b43legacy_read16(dev, 0x03E6) & 0xFFDF);
 
 	if (phy->type == B43legacy_PHYTYPE_G) {
-		if (!phy->gmode)
+		if (!phy->connected)
 			return;
 		b43legacy_phy_write(dev, 0x047A, 0xC111);
 	}
@@ -585,7 +585,7 @@ static void b43legacy_phy_initb5(struct 
 	if (phy->radio_ver == 0x2050)
 		b43legacy_phy_write(dev, 0x0038, 0x0667);
 
-	if (phy->gmode) {
+	if (phy->connected) {
 		if (phy->radio_ver == 0x2050) {
 			b43legacy_radio_write16(dev, 0x007A,
 					b43legacy_radio_read16(dev, 0x007A)
@@ -1024,7 +1024,7 @@ static void b43legacy_phy_initg(struct b
 		b43legacy_phy_initb5(dev);
 	else
 		b43legacy_phy_initb6(dev);
-	if (phy->rev >= 2 || phy->gmode)
+	if (phy->rev >= 2 || phy->connected)
 		b43legacy_phy_inita(dev);
 
 	if (phy->rev >= 2) {
@@ -1039,7 +1039,7 @@ static void b43legacy_phy_initg(struct b
 		b43legacy_phy_write(dev, 0x0811, 0x0400);
 		b43legacy_phy_write(dev, 0x0015, 0x00C0);
 	}
-	if (phy->rev >= 2 || phy->gmode) {
+	if (phy->rev >= 2 || phy->connected) {
 		tmp = b43legacy_phy_read(dev, 0x0400) & 0xFF;
 		if (tmp == 3 || tmp == 5) {
 			b43legacy_phy_write(dev, 0x04C2, 0x1816);
@@ -1058,7 +1058,7 @@ static void b43legacy_phy_initg(struct b
 		b43legacy_phy_write(dev, 0x043E, b43legacy_phy_read(dev, 0x043E)
 				    | 0x0004);
 	}
-	if (phy->rev >= 2 && phy->gmode)
+	if (phy->rev >= 2 && phy->connected)
 		b43legacy_calc_loopback_gain(dev);
 	if (phy->radio_rev != 8) {
 		if (phy->initval == 0xFFFF)
@@ -1092,7 +1092,7 @@ static void b43legacy_phy_initg(struct b
 		else
 			b43legacy_phy_write(dev, 0x002F, 0x0202);
 	}
-	if (phy->gmode || phy->rev >= 2) {
+	if (phy->connected || phy->rev >= 2) {
 		b43legacy_phy_lo_adjust(dev, 0);
 		b43legacy_phy_write(dev, 0x080F, 0x8078);
 	}
@@ -1106,7 +1106,7 @@ static void b43legacy_phy_initg(struct b
 		 */
 		b43legacy_nrssi_hw_update(dev, 0xFFFF);
 		b43legacy_calc_nrssi_threshold(dev);
-	} else if (phy->gmode || phy->rev >= 2) {
+	} else if (phy->connected || phy->rev >= 2) {
 		if (phy->nrssi[0] == -1000) {
 			B43legacy_WARN_ON(phy->nrssi[1] != -1000);
 			b43legacy_calc_nrssi_slope(dev);
@@ -1252,7 +1252,7 @@ u16 b43legacy_phy_lo_g_deviation_subval(
 	unsigned long flags;
 
 	local_irq_save(flags);
-	if (phy->gmode) {
+	if (phy->connected) {
 		b43legacy_phy_write(dev, 0x15, 0xE300);
 		control <<= 8;
 		b43legacy_phy_write(dev, 0x0812, control | 0x00B0);
@@ -1517,7 +1517,7 @@ void b43legacy_phy_lo_g_measure(struct b
 
 	oldchannel = phy->channel;
 	/* Setup */
-	if (phy->gmode) {
+	if (phy->connected) {
 		regstack[0] = b43legacy_phy_read(dev, B43legacy_PHY_G_CRS);
 		regstack[1] = b43legacy_phy_read(dev, 0x0802);
 		b43legacy_phy_write(dev, B43legacy_PHY_G_CRS, regstack[0]
@@ -1534,14 +1534,14 @@ void b43legacy_phy_lo_g_measure(struct b
 	regstack[9] = b43legacy_radio_read16(dev, 0x43);
 	regstack[10] = b43legacy_radio_read16(dev, 0x7A);
 	regstack[11] = b43legacy_radio_read16(dev, 0x52);
-	if (phy->gmode) {
+	if (phy->connected) {
 		regstack[12] = b43legacy_phy_read(dev, 0x0811);
 		regstack[13] = b43legacy_phy_read(dev, 0x0812);
 		regstack[14] = b43legacy_phy_read(dev, 0x0814);
 		regstack[15] = b43legacy_phy_read(dev, 0x0815);
 	}
 	b43legacy_radio_selectchannel(dev, 6, 0);
-	if (phy->gmode) {
+	if (phy->connected) {
 		b43legacy_phy_write(dev, B43legacy_PHY_G_CRS, regstack[0]
 				    & 0x7FFF);
 		b43legacy_phy_write(dev, 0x0802, regstack[1] & 0xFFFC);
@@ -1558,7 +1558,7 @@ void b43legacy_phy_lo_g_measure(struct b
 	b43legacy_radio_write16(dev, 0x007A, regstack[10] & 0xFFF0);
 	b43legacy_phy_write(dev, 0x002B, 0x0203);
 	b43legacy_phy_write(dev, 0x002A, 0x08A3);
-	if (phy->gmode) {
+	if (phy->connected) {
 		b43legacy_phy_write(dev, 0x0814, regstack[14] | 0x0003);
 		b43legacy_phy_write(dev, 0x0815, regstack[15] & 0xFFFC);
 		b43legacy_phy_write(dev, 0x0811, 0x01B3);
@@ -1680,7 +1680,7 @@ void b43legacy_phy_lo_g_measure(struct b
 	}
 
 	/* Restoration */
-	if (phy->gmode) {
+	if (phy->connected) {
 		b43legacy_phy_write(dev, 0x0015, 0xE300);
 		b43legacy_phy_write(dev, 0x0812, (r27 << 8) | 0xA0);
 		udelay(5);
@@ -1692,7 +1692,7 @@ void b43legacy_phy_lo_g_measure(struct b
 		b43legacy_phy_write(dev, 0x0015, r27 | 0xEFA0);
 	b43legacy_phy_lo_adjust(dev, is_initializing);
 	b43legacy_phy_write(dev, 0x002E, 0x807F);
-	if (phy->gmode)
+	if (phy->connected)
 		b43legacy_phy_write(dev, 0x002F, 0x0202);
 	else
 		b43legacy_phy_write(dev, 0x002F, 0x0101);
@@ -1707,7 +1707,7 @@ void b43legacy_phy_lo_g_measure(struct b
 	regstack[11] |= (b43legacy_radio_read16(dev, 0x52) & 0x000F);
 	b43legacy_radio_write16(dev, 0x52, regstack[11]);
 	b43legacy_write16(dev, 0x03E2, regstack[3]);
-	if (phy->gmode) {
+	if (phy->connected) {
 		b43legacy_phy_write(dev, 0x0811, regstack[12]);
 		b43legacy_phy_write(dev, 0x0812, regstack[13]);
 		b43legacy_phy_write(dev, 0x0814, regstack[14]);
Index: wireless-dev/drivers/net/wireless/b43legacy/phy.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/phy.h
+++ wireless-dev/drivers/net/wireless/b43legacy/phy.h
@@ -186,7 +186,7 @@ void b43legacy_raw_phy_unlock(struct b43
 
 /* Card uses the loopback gain stuff */
 #define has_loopback_gain(phy)			 \
-	(((phy)->rev > 1) || ((phy)->gmode))
+	(((phy)->rev > 1) || ((phy)->connected))
 
 u16 b43legacy_phy_read(struct b43legacy_wldev *dev, u16 offset);
 void b43legacy_phy_write(struct b43legacy_wldev *dev, u16 offset, u16 val);
Index: wireless-dev/drivers/net/wireless/b43legacy/radio.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/radio.c
+++ wireless-dev/drivers/net/wireless/b43legacy/radio.c
@@ -856,7 +856,7 @@ void b43legacy_calc_nrssi_threshold(stru
 		break;
 	}
 	case B43legacy_PHYTYPE_G:
-		if (!phy->gmode ||
+		if (!phy->connected ||
 		    !(dev->dev->bus->sprom.r1.boardflags_lo &
 		    B43legacy_BFL_RSSI)) {
 			tmp16 = b43legacy_nrssi_hw_read(dev, 0x20);
@@ -1342,7 +1342,7 @@ int b43legacy_radio_set_interference_mit
 	int currentmode;
 
 	if ((phy->type != B43legacy_PHYTYPE_G) ||
-	    (phy->rev == 0) || (!phy->gmode))
+	    (phy->rev == 0) || (!phy->connected))
 		return -ENODEV;
 
 	phy->aci_wlan_automatic = 0;
@@ -1403,7 +1403,7 @@ static u16 b43legacy_get_812_value(struc
 	u8 loop;
 	u16 extern_lna_control;
 
-	if (!phy->gmode)
+	if (!phy->connected)
 		return 0;
 	if (!has_loopback_gain(phy)) {
 		if (phy->rev < 7 || !(dev->dev->bus->sprom.r1.boardflags_lo
@@ -1515,7 +1515,7 @@ u16 b43legacy_radio_init2050(struct b43l
 		b43legacy_phy_write(dev, 0x0030, 0x00FF);
 		b43legacy_write16(dev, 0x03EC, 0x3F3F);
 	} else {
-		if (phy->gmode) {
+		if (phy->connected) {
 			backup[4] = b43legacy_phy_read(dev, 0x0811);
 			backup[5] = b43legacy_phy_read(dev, 0x0812);
 			backup[6] = b43legacy_phy_read(dev, 0x0814);
@@ -1584,13 +1584,13 @@ u16 b43legacy_radio_init2050(struct b43l
 	if (phy->type == B43legacy_PHYTYPE_B)
 		b43legacy_radio_write16(dev, 0x0078, 0x0026);
 
-	if (phy->gmode)
+	if (phy->connected)
 		b43legacy_phy_write(dev, 0x0812,
 				    b43legacy_get_812_value(dev,
 				    LPD(0, 1, 1)));
 	b43legacy_phy_write(dev, 0x0015, 0xBFAF);
 	b43legacy_phy_write(dev, 0x002B, 0x1403);
-	if (phy->gmode)
+	if (phy->connected)
 		b43legacy_phy_write(dev, 0x0812,
 				    b43legacy_get_812_value(dev,
 				    LPD(0, 0, 1)));
@@ -1612,19 +1612,19 @@ u16 b43legacy_radio_init2050(struct b43l
 		b43legacy_phy_write(dev, 0x005A, 0x0480);
 		b43legacy_phy_write(dev, 0x0059, 0xC810);
 		b43legacy_phy_write(dev, 0x0058, 0x000D);
-		if (phy->gmode)
+		if (phy->connected)
 			b43legacy_phy_write(dev, 0x0812,
 					    b43legacy_get_812_value(dev,
 					    LPD(1, 0, 1)));
 		b43legacy_phy_write(dev, 0x0015, 0xAFB0);
 		udelay(10);
-		if (phy->gmode)
+		if (phy->connected)
 			b43legacy_phy_write(dev, 0x0812,
 					    b43legacy_get_812_value(dev,
 					    LPD(1, 0, 1)));
 		b43legacy_phy_write(dev, 0x0015, 0xEFB0);
 		udelay(10);
-		if (phy->gmode)
+		if (phy->connected)
 			b43legacy_phy_write(dev, 0x0812,
 					    b43legacy_get_812_value(dev,
 					    LPD(1, 0, 0)));
@@ -1632,7 +1632,7 @@ u16 b43legacy_radio_init2050(struct b43l
 		udelay(20);
 		tmp1 += b43legacy_phy_read(dev, 0x002D);
 		b43legacy_phy_write(dev, 0x0058, 0x0000);
-		if (phy->gmode)
+		if (phy->connected)
 			b43legacy_phy_write(dev, 0x0812,
 					    b43legacy_get_812_value(dev,
 					    LPD(1, 0, 1)));
@@ -1653,19 +1653,19 @@ u16 b43legacy_radio_init2050(struct b43l
 			b43legacy_phy_write(dev, 0x005A, 0x0D80);
 			b43legacy_phy_write(dev, 0x0059, 0xC810);
 			b43legacy_phy_write(dev, 0x0058, 0x000D);
-			if (phy->gmode)
+			if (phy->connected)
 				b43legacy_phy_write(dev, 0x0812,
 						    b43legacy_get_812_value(dev,
 						    LPD(1, 0, 1)));
 			b43legacy_phy_write(dev, 0x0015, 0xAFB0);
 			udelay(10);
-			if (phy->gmode)
+			if (phy->connected)
 				b43legacy_phy_write(dev, 0x0812,
 						    b43legacy_get_812_value(dev,
 						    LPD(1, 0, 1)));
 			b43legacy_phy_write(dev, 0x0015, 0xEFB0);
 			udelay(10);
-			if (phy->gmode)
+			if (phy->connected)
 				b43legacy_phy_write(dev, 0x0812,
 						    b43legacy_get_812_value(dev,
 						    LPD(1, 0, 0)));
@@ -1673,7 +1673,7 @@ u16 b43legacy_radio_init2050(struct b43l
 			udelay(10);
 			tmp2 += b43legacy_phy_read(dev, 0x002D);
 			b43legacy_phy_write(dev, 0x0058, 0x0000);
-			if (phy->gmode)
+			if (phy->connected)
 				b43legacy_phy_write(dev, 0x0812,
 						    b43legacy_get_812_value(dev,
 						    LPD(1, 0, 1)));
@@ -1702,7 +1702,7 @@ u16 b43legacy_radio_init2050(struct b43l
 		b43legacy_phy_write(dev, 0x0030, backup[2]);
 		b43legacy_write16(dev, 0x03EC, backup[3]);
 	} else {
-		if (phy->gmode) {
+		if (phy->connected) {
 			b43legacy_write16(dev, B43legacy_MMIO_PHY_RADIO,
 					  (b43legacy_read16(dev,
 					  B43legacy_MMIO_PHY_RADIO) & 0x7FFF));
@@ -2082,7 +2082,7 @@ void b43legacy_radio_turn_on(struct b43l
 		b43legacy_phy_write(dev, 0x0015, 0x8000);
 		b43legacy_phy_write(dev, 0x0015, 0xCC00);
 		b43legacy_phy_write(dev, 0x0015,
-				    (phy->gmode ? 0x00C0 : 0x0000));
+				    (phy->connected ? 0x00C0 : 0x0000));
 		err = b43legacy_radio_selectchannel(dev,
 					B43legacy_RADIO_DEFAULT_CHANNEL_BG, 1);
 		B43legacy_WARN_ON(err != 0);


From mb at bu3sch.de  Sat Sep 15 23:58:08 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 15 Sep 2007 23:58:08 +0200
Subject: [PATCH] b43legacy: Fix machine check errors for PPC architecture
	with BCM4306/2
In-Reply-To: <46EC4844.1060003@lwfinger.net>
References: <46ec18d6.puwbD1oRuPgUil6/%Larry.Finger@lwfinger.net>
	<200709152147.57431.mb@bu3sch.de> <46EC4844.1060003@lwfinger.net>
Message-ID: <200709152358.08887.mb@bu3sch.de>

On Saturday 15 September 2007 23:01:56 Larry Finger wrote:
> I have generated and tested a patch that changes back to the old 'connected' variable. That will
> avoid the semantics argument and match the V3 specs.

There is no such thing as "connected".
The bit is called "gmode". Why do you change it back to the wrong name?
The V3 specs are simply _wrong_. It has nothing to do with the backplane
or anything else like that. The bit just selects between the A-PHY and
the BG-PHY. Of course, if there is no A-PHY it will obviously machine-check
on access, if it's selected.

V3 specs assume that the meaning is "connected", because it was misinterpreted
to be a "PHY connect" flag. But it really is a "PHY select" flag, to select
between two different PHYs. If it's enabled, the G-PHY will be selected (and
the A-PHY otherwise).

Btw, while we are at it: The V3 specs are wrong regarding the gmode (or connected)
bit in other areas as well, because there was even more confusion with
other PHY flags. The PHY specification is pretty broken in the v3 specs.

-- 
Greetings Michael.


From athin at go2.pl  Sun Sep 16 00:03:26 2007
From: athin at go2.pl (Marcin Kosiba)
Date: Sun, 16 Sep 2007 00:03:26 +0200
Subject: software powerup
Message-ID: <200709160003.26098.athin@go2.pl>

Hi all,
	I've just installed a bcm4306 card in an eBox 
(http://www.embeddedpc.net/ebox2300.htm) and I can't get it to power up. 
Before I've had it in my laptop, which obviously had a on/off switch. If 
there is no other choice I can solder the switch onto the bcm4306, but I'd 
like to avoid that if possible.

Cheers,
	Marcin


From mb at bu3sch.de  Sun Sep 16 00:04:27 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Sep 2007 00:04:27 +0200
Subject: [PATCH V2] b43legacy: Fix machine check errors for PPC
	architecture with BCM4306/2
In-Reply-To: <46ec4d0c.PU+VRueOH3Peh6s5%Larry.Finger@lwfinger.net>
References: <46ec4d0c.PU+VRueOH3Peh6s5%Larry.Finger@lwfinger.net>
Message-ID: <200709160004.28018.mb@bu3sch.de>

On Saturday 15 September 2007 23:22:20 Larry Finger wrote:
> In b43legacy, the variable gmode is always set. With a BCM4306/2,
> and likely a BCM4301, a variable is needed to control the execution
> path through the PHY and radio initialization, otherwise there are
> attempts to read from invalid registers. On x86 platforms, these
> read failures cause no problems; however they lead to machine check
> errors for the ppc architecture. This patch reverts to the variable
> and semantics used in the V3 specifications. It has been tested on
> an i386 platform using special code to detect these invalid reads,
> and on at least one Powerbook.
>  
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>

> Index: wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/b43legacy.h
> +++ wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
> @@ -389,10 +389,10 @@ struct b43legacy_lopair {
>  struct b43legacy_phy {
>  	/* Possible PHYMODEs on this PHY */
>  	u8 possible_phymodes;
> -	/* GMODE bit enabled? */
> -	bool gmode;
> +	/* true if PHY registers can be accessed */
> +	bool connected;

I am completely against re-adding the old broken "connected" semantics.
IMO, this is a step backwards. I was happy to finally get rid of
this, as it caused me a lot of headaches.

>  	/* Possible ieee80211 subsystem hwmodes for this PHY.
> -	 * Which mode is selected, depends on thr GMODE enabled bit */
> +	 * This will be either G or B mode */
>  #define B43legacy_MAX_PHYHWMODES	2
>  	struct ieee80211_hw_mode hwmodes[B43legacy_MAX_PHYHWMODES];

Not sure why you change the comment here this way.
If you remove the "gmode" capability, you also limit
the number of hwmodes to one. So no array is needed here anymore.

But in the end, you are the maintainer, so you decide.
I personally would not re-add proven wrong stuff back to my driver.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sun Sep 16 01:26:29 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 15 Sep 2007 18:26:29 -0500
Subject: [PATCH] b43legacy: Fix machine check errors for PPC architecture
	with BCM4306/2
In-Reply-To: <200709152358.08887.mb@bu3sch.de>
References: <46ec18d6.puwbD1oRuPgUil6/%Larry.Finger@lwfinger.net>
	<200709152147.57431.mb@bu3sch.de> <46EC4844.1060003@lwfinger.net>
	<200709152358.08887.mb@bu3sch.de>
Message-ID: <46EC6A25.2010204@lwfinger.net>

Michael Buesch wrote:
> 
> There is no such thing as "connected".
> The bit is called "gmode". Why do you change it back to the wrong name?
> The V3 specs are simply _wrong_. It has nothing to do with the backplane
> or anything else like that. The bit just selects between the A-PHY and
> the BG-PHY. Of course, if there is no A-PHY it will obviously machine-check
> on access, if it's selected.
> 
> V3 specs assume that the meaning is "connected", because it was misinterpreted
> to be a "PHY connect" flag. But it really is a "PHY select" flag, to select
> between two different PHYs. If it's enabled, the G-PHY will be selected (and
> the A-PHY otherwise).
> 
> Btw, while we are at it: The V3 specs are wrong regarding the gmode (or connected)
> bit in other areas as well, because there was even more confusion with
> other PHY flags. The PHY specification is pretty broken in the v3 specs.

The critical part of the legacy code in this regard is from phy_calibrate():

        if (phy->type == B43legacy_PHYTYPE_G && phy->rev == 1) {
                b43legacy_wireless_core_reset(dev, 0);
                b43legacy_phy_initg(dev);
                b43legacy_wireless_core_reset(dev, B43legacy_TMSLOW_GMODE);
        }

If phy_initg is going to work correctly, then gmode has to follow the state of the MACCTL_GMODE bit
in MMIO_MACCTL. Apparently GPHYs with rev > 1 do not care about this bit, but the BCM4306/2 does.
The changes can be accomplished by the following patch:

Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -738,8 +738,11 @@ void b43legacy_wireless_core_reset(struc

        macctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);
        macctl &= ~B43legacy_MACCTL_GMODE;
-       if (flags & B43legacy_TMSLOW_GMODE)
+       if (flags & B43legacy_TMSLOW_GMODE) {
                macctl |= B43legacy_MACCTL_GMODE;
+               dev->phy.gmode = 1;
+       } else
+               dev->phy.gmode = 0;
        macctl |= B43legacy_MACCTL_IHR_ENABLED;
        b43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);
 }

The above patch and a revised comment for the gmode variable will be the contents of V3 of my patch.
I hope that you find it acceptable. In my position as maintainer, I can push stuff through, but I
prefer that you are in agreement.

Larry



From larry.finger at lwfinger.net  Sun Sep 16 01:36:09 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 15 Sep 2007 18:36:09 -0500
Subject: software powerup
In-Reply-To: <200709160003.26098.athin@go2.pl>
References: <200709160003.26098.athin@go2.pl>
Message-ID: <46EC6C69.6070203@lwfinger.net>

Marcin Kosiba wrote:
> Hi all,
> 	I've just installed a bcm4306 card in an eBox 
> (http://www.embeddedpc.net/ebox2300.htm) and I can't get it to power up. 
> Before I've had it in my laptop, which obviously had a on/off switch. If 
> there is no other choice I can solder the switch onto the bcm4306, but I'd 
> like to avoid that if possible.

The only switch associated with any of the BCM cards that I know about is the radio-enable switch.
If that is what you need, it can only be controlled externally. The software can read its state, but
not control it.

What OS are you using? If Linux and the appropriate driver is installed, the output of the dmesg
command will show some details.

Larry


From mb at bu3sch.de  Sun Sep 16 01:58:17 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Sep 2007 01:58:17 +0200
Subject: [PATCH] b43legacy: Fix machine check errors for PPC architecture
	with BCM4306/2
In-Reply-To: <46EC6A25.2010204@lwfinger.net>
References: <46ec18d6.puwbD1oRuPgUil6/%Larry.Finger@lwfinger.net>
	<200709152358.08887.mb@bu3sch.de> <46EC6A25.2010204@lwfinger.net>
Message-ID: <200709160158.17469.mb@bu3sch.de>

On Sunday 16 September 2007 01:26:29 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > There is no such thing as "connected".
> > The bit is called "gmode". Why do you change it back to the wrong name?
> > The V3 specs are simply _wrong_. It has nothing to do with the backplane
> > or anything else like that. The bit just selects between the A-PHY and
> > the BG-PHY. Of course, if there is no A-PHY it will obviously machine-check
> > on access, if it's selected.
> > 
> > V3 specs assume that the meaning is "connected", because it was misinterpreted
> > to be a "PHY connect" flag. But it really is a "PHY select" flag, to select
> > between two different PHYs. If it's enabled, the G-PHY will be selected (and
> > the A-PHY otherwise).
> > 
> > Btw, while we are at it: The V3 specs are wrong regarding the gmode (or connected)
> > bit in other areas as well, because there was even more confusion with
> > other PHY flags. The PHY specification is pretty broken in the v3 specs.
> 
> The critical part of the legacy code in this regard is from phy_calibrate():
> 
>         if (phy->type == B43legacy_PHYTYPE_G && phy->rev == 1) {
>                 b43legacy_wireless_core_reset(dev, 0);
>                 b43legacy_phy_initg(dev);
>                 b43legacy_wireless_core_reset(dev, B43legacy_TMSLOW_GMODE);
>         }

Here's how this was solved in bcm43xx-mac80211:

	if (phy->type == BCM43xx_PHYTYPE_G && phy->rev == 1) {
		/* Workaround: Temporarly disable gmode through the early init
		 * phase, as the gmode stuff is not needed for phy rev 1 */
		phy->gmode = 0;
		bcm43xx_wireless_core_reset(dev, 0);
		bcm43xx_phy_initg(dev);
		phy->gmode = 1;
		bcm43xx_wireless_core_reset(dev, BCM43xx_TMSLOW_GMODE);
	}

> If phy_initg is going to work correctly, then gmode has to follow the state of the MACCTL_GMODE bit
> in MMIO_MACCTL. Apparently GPHYs with rev > 1 do not care about this bit, but the BCM4306/2 does.
> The changes can be accomplished by the following patch:
> 
> Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
> +++ wireless-dev/drivers/net/wireless/b43legacy/main.c
> @@ -738,8 +738,11 @@ void b43legacy_wireless_core_reset(struc
> 
>         macctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);
>         macctl &= ~B43legacy_MACCTL_GMODE;
> -       if (flags & B43legacy_TMSLOW_GMODE)
> +       if (flags & B43legacy_TMSLOW_GMODE) {
>                 macctl |= B43legacy_MACCTL_GMODE;
> +               dev->phy.gmode = 1;
> +       } else
> +               dev->phy.gmode = 0;
>         macctl |= B43legacy_MACCTL_IHR_ENABLED;
>         b43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);
>  }

I think I am OK with both, this and the old bcm43xx-mac80211 fix I pasted above.

> The above patch and a revised comment for the gmode variable will be the contents of V3 of my patch.
> I hope that you find it acceptable. In my position as maintainer, I can push stuff through, but I
> prefer that you are in agreement.

Ok. Anyway. In the end you must work with that stuff and understand it. Not me.
So if you don't like "gmode" for whatever reason, rename it to something you like.
Just keep in mind please, that v4 PHY-specs (which mostly apply to your driver, too)
correctly talk about "gmode" and not "connected" anymore.
Also keep in mind that v3 specs are/were wrong in parts where it says to
check (phy->type == TYPE_G) where it should really test "gmode".
So if you change that back to "connected" the confusion gets even more complicated. :)
At least to me. All that stuff already screwed me a lot, so I am thankful that
it's gone and working correctly (at least for phy.rev > 1 cards) by now.
That's why I asked you to not add that crap back. :)

-- 
Greetings Michael.


From ftoledo at docksud.com.ar  Sun Sep 16 02:19:30 2007
From: ftoledo at docksud.com.ar (Fernando Toledo)
Date: Sat, 15 Sep 2007 21:19:30 -0300
Subject: 4311 hardware death?
Message-ID: <200709152119.32784.ftoledo@docksud.com.ar>

Hi all
i think that mi bcm4311 was death in this week =(
i test with several kernels: debian stock, vanilla and wireless-dev
i test with 2 access points too.
i can scan good, i can connect a auth, but in few minutes die and stops ping 
the ap.
the netwokmanager still show online , the dmesg (using the debug option) show 
all good.
any test o another idea?.. i thiking go to the warranty 

=\


-- 
Dock Sud BBS
http://www.docksud.com.ar
telnet://bbs.docksud.com.ar
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part.
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070915/c4bfbbc6/attachment.pgp>

From gavron at Wetwork.Net  Sun Sep 16 04:00:21 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Sat, 15 Sep 2007 19:00:21 -0700
Subject: 4311 hardware death?
In-Reply-To: <200709152119.32784.ftoledo@docksud.com.ar>
References: <200709152119.32784.ftoledo@docksud.com.ar>
Message-ID: <46EC8E35.2070202@Wetwork.Net>

I have had this problem after moving from AP1 to AP2 (same ESSID, 
different channels, same WEP key).

Try this:
1) Kill the network manager :)

2) sudo iwevent &

3)
sudo modprobe -r b43
sudo moprobe b43

If it doesn't bring the interface up automatically:
4) sudo ifup [interface-name-here, like eth1 or wlan0 or whatever]

Good luck :)

Ehud

Fernando Toledo wrote:
> Hi all
> i think that mi bcm4311 was death in this week =(
> i test with several kernels: debian stock, vanilla and wireless-dev
> i test with 2 access points too.
> i can scan good, i can connect a auth, but in few minutes die and stops ping 
> the ap.
> the netwokmanager still show online , the dmesg (using the debug option) show 
> all good.
> any test o another idea?.. i thiking go to the warranty 
>
> =\
>
>
>   
> ------------------------------------------------------------------------
>
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070915/008103d8/attachment.bin>

From Larry.Finger at lwfinger.net  Sun Sep 16 02:52:11 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sat, 15 Sep 2007 19:52:11 -0500
Subject: [PATCH V3] b43legacy: Fix machine check errors for PPC
	architecture with BCM4306/2
Message-ID: <46ec7e3b.fvdyZ6cbJm24I7PA%Larry.Finger@lwfinger.net>

In b43legacy, the variable gmode is always set. With a BCM4306/2,
a variable is needed to control the execution path through the PHY
and radio initialization, otherwise there are attempts to read from
invalid registers. On x86 platforms, these read failures cause no
problems; however they lead to machine check errors for the ppc
architecture. This problem is fixed by making the variable gmode mimic
the state of the GMODE bit of MACCTL. This patch has been tested on an
i386 platform using special code to detect these invalid reads, and on
at least one Powerbook.
 
Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This patch fixes a problem with the Fedora Rawhide kernel reported by David
Woodhouse on the bcm43xx mailing list and by Will Woods at 
https://bugzilla.redhat.com/show_bug.cgi?id=233011. 

Larry

 drivers/net/wireless/b43legacy/b43legacy.h |    2 +-
 drivers/net/wireless/b43legacy/main.c      |    5 ++++-
 2 files changed, 5 insertions(+), 2 deletions(-)

Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -738,8 +738,11 @@ void b43legacy_wireless_core_reset(struc
 
 	macctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);
 	macctl &= ~B43legacy_MACCTL_GMODE;
-	if (flags & B43legacy_TMSLOW_GMODE)
+	if (flags & B43legacy_TMSLOW_GMODE) {
 		macctl |= B43legacy_MACCTL_GMODE;
+		dev->phy.gmode = 1;
+	} else
+		dev->phy.gmode = 0;
 	macctl |= B43legacy_MACCTL_IHR_ENABLED;
 	b43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);
 }
Index: wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/b43legacy.h
+++ wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
@@ -389,7 +389,7 @@ struct b43legacy_lopair {
 struct b43legacy_phy {
 	/* Possible PHYMODEs on this PHY */
 	u8 possible_phymodes;
-	/* GMODE bit enabled? */
+	/* GMODE bit enabled in MACCTL? */
 	bool gmode;
 	/* Possible ieee80211 subsystem hwmodes for this PHY.
 	 * Which mode is selected, depends on thr GMODE enabled bit */


From mb at bu3sch.de  Sun Sep 16 11:00:51 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Sep 2007 11:00:51 +0200
Subject: [PATCH V3] b43legacy: Fix machine check errors for PPC
	architecture with BCM4306/2
In-Reply-To: <46ec7e3b.fvdyZ6cbJm24I7PA%Larry.Finger@lwfinger.net>
References: <46ec7e3b.fvdyZ6cbJm24I7PA%Larry.Finger@lwfinger.net>
Message-ID: <200709161100.51955.mb@bu3sch.de>

On Sunday 16 September 2007 02:52:11 Larry Finger wrote:
> In b43legacy, the variable gmode is always set. With a BCM4306/2,
> a variable is needed to control the execution path through the PHY
> and radio initialization, otherwise there are attempts to read from
> invalid registers. On x86 platforms, these read failures cause no
> problems; however they lead to machine check errors for the ppc
> architecture. This problem is fixed by making the variable gmode mimic
> the state of the GMODE bit of MACCTL. This patch has been tested on an
> i386 platform using special code to detect these invalid reads, and on
> at least one Powerbook.
>  
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John,
> 
> This patch fixes a problem with the Fedora Rawhide kernel reported by David
> Woodhouse on the bcm43xx mailing list and by Will Woods at 
> https://bugzilla.redhat.com/show_bug.cgi?id=233011. 
> 
> Larry
> 
>  drivers/net/wireless/b43legacy/b43legacy.h |    2 +-
>  drivers/net/wireless/b43legacy/main.c      |    5 ++++-
>  2 files changed, 5 insertions(+), 2 deletions(-)
> 
> Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
> +++ wireless-dev/drivers/net/wireless/b43legacy/main.c
> @@ -738,8 +738,11 @@ void b43legacy_wireless_core_reset(struc
>  
>  	macctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);
>  	macctl &= ~B43legacy_MACCTL_GMODE;
> -	if (flags & B43legacy_TMSLOW_GMODE)
> +	if (flags & B43legacy_TMSLOW_GMODE) {
>  		macctl |= B43legacy_MACCTL_GMODE;
> +		dev->phy.gmode = 1;
> +	} else
> +		dev->phy.gmode = 0;
>  	macctl |= B43legacy_MACCTL_IHR_ENABLED;
>  	b43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);
>  }
> Index: wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/b43legacy.h
> +++ wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
> @@ -389,7 +389,7 @@ struct b43legacy_lopair {
>  struct b43legacy_phy {
>  	/* Possible PHYMODEs on this PHY */
>  	u8 possible_phymodes;
> -	/* GMODE bit enabled? */
> +	/* GMODE bit enabled in MACCTL? */
>  	bool gmode;
>  	/* Possible ieee80211 subsystem hwmodes for this PHY.
>  	 * Which mode is selected, depends on thr GMODE enabled bit */

ACK

-- 
Greetings Michael.


From athin at go2.pl  Sun Sep 16 11:26:21 2007
From: athin at go2.pl (Marcin Kosiba)
Date: Sun, 16 Sep 2007 11:26:21 +0200
Subject: software powerup
In-Reply-To: <46EC6C69.6070203@lwfinger.net>
References: <200709160003.26098.athin@go2.pl> <46EC6C69.6070203@lwfinger.net>
Message-ID: <200709161126.21437.athin@go2.pl>

On Sunday 16 September 2007, Larry Finger wrote:
> The only switch associated with any of the BCM cards that I know about is
> the radio-enable switch. If that is what you need, it can only be
> controlled externally. The software can read its state, but not control it.

not fun - oh well... gotta warm that soldering iron up then...

> What OS are you using? If Linux and the appropriate driver is installed,
> the output of the dmesg command will show some details.

slackware linux 12.0
(uname -a:
Linux ebox 2.6.21.5 #2 Tue Jun 19 15:22:48 CDT 2007 i586 05/00 SiS SiS SiS 
GNU/Linux)

dmesg | grep bcm

bcm43xx: Chip ID 0x4306, rev 0x3
bcm43xx: Number of cores: 5
bcm43xx: Core 0: ID 0x800, rev 0x4, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0x5, vendor 0x4243
bcm43xx: Core 2: ID 0x80d, rev 0x2, vendor 0x4243
bcm43xx: Core 3: ID 0x807, rev 0x2, vendor 0x4243
bcm43xx: Core 4: ID 0x804, rev 0x9, vendor 0x4243
bcm43xx: PHY connected
bcm43xx: Detected PHY: Analog: 2, Type 2, Revision 2
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
bcm43xx: Radio turned off
bcm43xx: Radio turned off

as I've said - off :/


From mb at bu3sch.de  Sun Sep 16 11:49:59 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Sep 2007 11:49:59 +0200
Subject: software powerup
In-Reply-To: <200709161126.21437.athin@go2.pl>
References: <200709160003.26098.athin@go2.pl> <46EC6C69.6070203@lwfinger.net>
	<200709161126.21437.athin@go2.pl>
Message-ID: <200709161149.59683.mb@bu3sch.de>

On Sunday 16 September 2007 11:26:21 Marcin Kosiba wrote:
> On Sunday 16 September 2007, Larry Finger wrote:
> > The only switch associated with any of the BCM cards that I know about is
> > the radio-enable switch. If that is what you need, it can only be
> > controlled externally. The software can read its state, but not control it.
> 
> not fun - oh well... gotta warm that soldering iron up then...
> 
> > What OS are you using? If Linux and the appropriate driver is installed,
> > the output of the dmesg command will show some details.
> 
> slackware linux 12.0
> (uname -a:
> Linux ebox 2.6.21.5 #2 Tue Jun 19 15:22:48 CDT 2007 i586 05/00 SiS SiS SiS 
> GNU/Linux)
> 
> dmesg | grep bcm
> 
> bcm43xx: Chip ID 0x4306, rev 0x3
> bcm43xx: Number of cores: 5
> bcm43xx: Core 0: ID 0x800, rev 0x4, vendor 0x4243
> bcm43xx: Core 1: ID 0x812, rev 0x5, vendor 0x4243
> bcm43xx: Core 2: ID 0x80d, rev 0x2, vendor 0x4243
> bcm43xx: Core 3: ID 0x807, rev 0x2, vendor 0x4243
> bcm43xx: Core 4: ID 0x804, rev 0x9, vendor 0x4243
> bcm43xx: PHY connected
> bcm43xx: Detected PHY: Analog: 2, Type 2, Revision 2
> bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> bcm43xx: Radio turned off
> bcm43xx: Radio turned off
> 
> as I've said - off :/

What about bringing the device up?


-- 
Greetings Michael.


From athin at go2.pl  Sun Sep 16 12:17:50 2007
From: athin at go2.pl (Marcin Kosiba)
Date: Sun, 16 Sep 2007 12:17:50 +0200
Subject: software powerup
In-Reply-To: <200709161149.59683.mb@bu3sch.de>
References: <200709160003.26098.athin@go2.pl> <200709161126.21437.athin@go2.pl>
	<200709161149.59683.mb@bu3sch.de>
Message-ID: <200709161217.50081.athin@go2.pl>

On Sunday 16 September 2007, Michael Buesch wrote:
> On Sunday 16 September 2007 11:26:21 Marcin Kosiba wrote:
> > On Sunday 16 September 2007, Larry Finger wrote:
> > > The only switch associated with any of the BCM cards that I know about
> > > is the radio-enable switch. If that is what you need, it can only be
> > > controlled externally. The software can read its state, but not control
> > > it.
> >
> > not fun - oh well... gotta warm that soldering iron up then...
> >
> > > What OS are you using? If Linux and the appropriate driver is
> > > installed, the output of the dmesg command will show some details.
> >
> > slackware linux 12.0
> > (uname -a:
> > Linux ebox 2.6.21.5 #2 Tue Jun 19 15:22:48 CDT 2007 i586 05/00 SiS SiS
> > SiS GNU/Linux)
> >
> > dmesg | grep bcm
> >
> > bcm43xx: Chip ID 0x4306, rev 0x3
> > bcm43xx: Number of cores: 5
> > bcm43xx: Core 0: ID 0x800, rev 0x4, vendor 0x4243
> > bcm43xx: Core 1: ID 0x812, rev 0x5, vendor 0x4243
> > bcm43xx: Core 2: ID 0x80d, rev 0x2, vendor 0x4243
> > bcm43xx: Core 3: ID 0x807, rev 0x2, vendor 0x4243
> > bcm43xx: Core 4: ID 0x804, rev 0x9, vendor 0x4243
> > bcm43xx: PHY connected
> > bcm43xx: Detected PHY: Analog: 2, Type 2, Revision 2
> > bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> > bcm43xx: Radio turned off
> > bcm43xx: Radio turned off
> >
> > as I've said - off :/
>
> What about bringing the device up?

ok, my bad - had the wrong firmware version up there (seems as though the 
error messages are shown in dmesg only if I load the module manually - if it 
is loaded on startup they probably go somewhere else..)

bcm43xx: Radio turned off
bcm43xx: Radio turned off
bcm43xx: PHY connected
bcm43xx: Microcode rev 0xf5, pl 0x5a (2003-12-22  20:11:25)
bcm43xx: Radio turned on
bcm43xx: Radio enabled by hardware
bcm43xx: Chip initialized
bcm43xx: 30-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)


Cheers,
	Marcin


From mb at bu3sch.de  Sun Sep 16 12:36:21 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 16 Sep 2007 12:36:21 +0200
Subject: software powerup
In-Reply-To: <200709161217.50081.athin@go2.pl>
References: <200709160003.26098.athin@go2.pl> <200709161149.59683.mb@bu3sch.de>
	<200709161217.50081.athin@go2.pl>
Message-ID: <200709161236.21563.mb@bu3sch.de>

On Sunday 16 September 2007 12:17:50 Marcin Kosiba wrote:
> On Sunday 16 September 2007, Michael Buesch wrote:
> > On Sunday 16 September 2007 11:26:21 Marcin Kosiba wrote:
> > > On Sunday 16 September 2007, Larry Finger wrote:
> > > > The only switch associated with any of the BCM cards that I know about
> > > > is the radio-enable switch. If that is what you need, it can only be
> > > > controlled externally. The software can read its state, but not control
> > > > it.
> > >
> > > not fun - oh well... gotta warm that soldering iron up then...
> > >
> > > > What OS are you using? If Linux and the appropriate driver is
> > > > installed, the output of the dmesg command will show some details.
> > >
> > > slackware linux 12.0
> > > (uname -a:
> > > Linux ebox 2.6.21.5 #2 Tue Jun 19 15:22:48 CDT 2007 i586 05/00 SiS SiS
> > > SiS GNU/Linux)
> > >
> > > dmesg | grep bcm
> > >
> > > bcm43xx: Chip ID 0x4306, rev 0x3
> > > bcm43xx: Number of cores: 5
> > > bcm43xx: Core 0: ID 0x800, rev 0x4, vendor 0x4243
> > > bcm43xx: Core 1: ID 0x812, rev 0x5, vendor 0x4243
> > > bcm43xx: Core 2: ID 0x80d, rev 0x2, vendor 0x4243
> > > bcm43xx: Core 3: ID 0x807, rev 0x2, vendor 0x4243
> > > bcm43xx: Core 4: ID 0x804, rev 0x9, vendor 0x4243
> > > bcm43xx: PHY connected
> > > bcm43xx: Detected PHY: Analog: 2, Type 2, Revision 2
> > > bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> > > bcm43xx: Radio turned off
> > > bcm43xx: Radio turned off
> > >
> > > as I've said - off :/
> >
> > What about bringing the device up?
> 
> ok, my bad - had the wrong firmware version up there (seems as though the 
> error messages are shown in dmesg only if I load the module manually - if it 
> is loaded on startup they probably go somewhere else..)
> 
> bcm43xx: Radio turned off
> bcm43xx: Radio turned off
> bcm43xx: PHY connected
> bcm43xx: Microcode rev 0xf5, pl 0x5a (2003-12-22  20:11:25)
> bcm43xx: Radio turned on
> bcm43xx: Radio enabled by hardware
> bcm43xx: Chip initialized
> bcm43xx: 30-bit DMA initialized
> bcm43xx: Keys cleared
> bcm43xx: Selected 802.11 core (phytype 2)

So everything's fine?

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Sun Sep 16 17:33:52 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 16 Sep 2007 10:33:52 -0500
Subject: software powerup
In-Reply-To: <200709161217.50081.athin@go2.pl>
References: <200709160003.26098.athin@go2.pl>
	<200709161126.21437.athin@go2.pl>	<200709161149.59683.mb@bu3sch.de>
	<200709161217.50081.athin@go2.pl>
Message-ID: <46ED4CE0.2050200@lwfinger.net>

Marcin Kosiba wrote:
> 
> ok, my bad - had the wrong firmware version up there (seems as though the 
> error messages are shown in dmesg only if I load the module manually - if it 
> is loaded on startup they probably go somewhere else..)

They are always in dmesg on my system.

> bcm43xx: Radio turned off
> bcm43xx: Radio turned off

For the benefit of others that might read this. The above "Radio turned off" message just means that
the driver has gotten the radio into a known state and is waiting for the user to bring the
interface "up".

> bcm43xx: PHY connected
> bcm43xx: Microcode rev 0xf5, pl 0x5a (2003-12-22  20:11:25)
> bcm43xx: Radio turned on
> bcm43xx: Radio enabled by hardware

This message reports the state of the "radio enable switch". If the card does not have such a
switch, the driver always reports that it is enabled, as is the case here. As you can see, the
firmware must be loaded before this message appears.

> bcm43xx: Chip initialized
> bcm43xx: 30-bit DMA initialized
> bcm43xx: Keys cleared
> bcm43xx: Selected 802.11 core (phytype 2)

Larry



From gavron at wetwork.net  Sun Sep 16 18:50:28 2007
From: gavron at wetwork.net (Ehud Gavron)
Date: Sun, 16 Sep 2007 09:50:28 -0700
Subject: software powerup
In-Reply-To: <46ED4CE0.2050200@lwfinger.net>
References: <200709160003.26098.athin@go2.pl> <200709161126.21437.athin@go2.pl>
	<200709161149.59683.mb@bu3sch.de> <200709161217.50081.athin@go2.pl>
	<46ED4CE0.2050200@lwfinger.net>
Message-ID: <46ED5ED4.9050405@wetwork.net>

Perhaps a couple of changes to the driver messages would help eliminate 
confusion and support repetition?

Larry Finger wrote:
 > bcm43xx: Radio turned off

Perhaps:  bcm43xx: Radio turned off.  Interface must be enabled 
(ifconfig up)
...

 > bcm43xx: Microcode rev 0xf5, p1 ox5a (2003-12-22 20:11:25)

Perhaps if it can't load the microcode:
bcm43xx: Microcode has not been located and loaded.  (URL here)

E
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070916/b92f75b8/attachment.bin>

From martti.huttunen at mail.suomi.net  Sun Sep 16 21:38:55 2007
From: martti.huttunen at mail.suomi.net (Martti Huttunen)
Date: Sun, 16 Sep 2007 22:38:55 +0300
Subject: b43 module and master mode?
In-Reply-To: <46E99310.2080605@lwfinger.net>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<46E99310.2080605@lwfinger.net>
Message-ID: <46ED864F.2000800@mail.suomi.net>

Hi people,

I got the b43 driver up in my machine, using the following card:

00:0b.0 Network controller: Broadcom Corporation BCM4318 [AirForce One
54g] 802.11g Wireless LAN Controller (rev 02)

Is there a way to get it working in master mode?
If so, which kernel version I should be using on Fedora 7?

I would be willing to debug it as well, I have some kernel experience.

-Martti.



From gmccullagh at gmail.com  Sun Sep 16 23:45:02 2007
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Sun, 16 Sep 2007 22:45:02 +0100
Subject: [AirForce One 54g] working
Message-ID: <20070916214502.GA21484@gmail.com>

Hi,

I have a linksys WPC54GS pcmcia wifi card.  lspci details below.  I tried
it with the latest firmware and Ubuntu gutsy's 2.6.22-10-generic and
2.6.22-11-generic kernels.  With the former, I got WPA working
intermittently, but not stably (ie it'd die and need the driver reloading).
With the latter, I could only get it working unencrypted (I didn't debug in
detail, but it seemed like it didn't associate so presumaby the link never
came up -- I can give logs and more detail if it's useful).

I went onto the IRC channel and noted the suggestion that I try the
wireless-dev tree (2.6.23-rc4).  So I did and I'm glad to say successfully.
I'm using it now and have been for the past 6-8 hours on and off without
any reboot or problems.  I guess it's possible it would also work with the
current 2.6.23-rc6 development kernel.  Perhaps I'll try and check that in
due course.

A couple of things worth mentioning.  

1. I've been getting tonnes of syslog errors like this:
	Sep 16 21:46:59 tilly kernel: [ 5171.869169] CCMP: decrypt failed: STA=00:09:5b:d2:f0:2f
	Sep 16 21:46:59 tilly kernel: [ 5171.872336] CCMP: decrypt failed: STA=00:18:84:11:78:d6
	Sep 16 21:47:05 tilly kernel: [ 5174.178449] printk: 122 messages suppressed.
   which all seem to correspond to packets tranferred between my AP and
   a second netgear laptop with an atheros chipset.  So it's not a worry.
   ifconfig shows a collossal packet drop count, which seems to
   approximately equal the number of packets sent+rec'd  by the other
   laptop so I guess it's the same error as above.  Perhaps there's a good
   debug reason for these printk statements, but they have their cost on the
   machine.

2. The quoted signal strength is 50% even when I have the AP and card right
   next to each other.  It doesn't bother me, but I wonder if it's correct
   or not.

I wrote up a howto for Ubuntu here as I suspect others might be interested
to try it out.

https://help.ubuntu.com/community/WifiDocs/Device/Broadcom_BCM4318_%5bAirForce_One_54g%5d_%28Native_Driver%29#preview

Gavin

gavinmc at tilly:~$ lspci -v -s 02:00.0
02:00.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 54g]
802.11g Wireless LAN Controller (rev 02)
        Subsystem: Linksys Unknown device 0049
        Flags: bus master, fast devsel, latency 64, IRQ 10
        Memory at 24000000 (32-bit, non-prefetchable) [size=8K]

gavinmc at tilly:~$ lspci -vn -s 02:00.0
02:00.0 0280: 14e4:4318 (rev 02)
        Subsystem: 1737:0049
        Flags: bus master, fast devsel, latency 64, IRQ 10
        Memory at 24000000 (32-bit, non-prefetchable) [size=8K]




From Larry.Finger at lwfinger.net  Mon Sep 17 00:26:49 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Sun, 16 Sep 2007 17:26:49 -0500
Subject: [PATCH V2] bcm43xx: Change radio hardware switch status printk
	from debug to regular
Message-ID: <46edada9.p7TujTB8lnlVSSMg%Larry.Finger@lwfinger.net>

Some distros ship bcm43xx with debugging printout disabled. For those
BCM43xx devices with radio on/off switches, this makes it impossible
to know if the radio is on or off. This patch changes a pair of debug
printk's into ordinary printk's. It also changes the message that
prints when the radio is initialized to the off state as the old message
seems to confuse users.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This is 2.6.24 material.

Thanks,

Larry

 bcm43xx_main.c  |    4 ++--
 bcm43xx_radio.c |    2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
@@ -2394,7 +2394,7 @@ static int bcm43xx_chip_init(struct bcm4
 		goto err_gpio_cleanup;
 	bcm43xx_radio_turn_on(bcm);
 	bcm->radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
-	dprintk(KERN_INFO PFX "Radio %s by hardware\n",
+	printk(KERN_INFO PFX "Radio %s by hardware\n",
 		(bcm->radio_hw_enable == 0) ? "disabled" : "enabled");
 
 	bcm43xx_write16(bcm, 0x03E6, 0x0000);
@@ -3143,7 +3143,7 @@ static void bcm43xx_periodic_every1sec(s
 	radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
 	if (unlikely(bcm->radio_hw_enable != radio_hw_enable)) {
 		bcm->radio_hw_enable = radio_hw_enable;
-		dprintk(KERN_INFO PFX "Radio hardware status changed to %s\n",
+		printk(KERN_INFO PFX "Radio hardware status changed to %s\n",
 		       (radio_hw_enable == 0) ? "disabled" : "enabled");
 		bcm43xx_leds_update(bcm, 0);
 	}
Index: linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_radio.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_radio.c
+++ linux-2.6/drivers/net/wireless/bcm43xx/bcm43xx_radio.c
@@ -2146,7 +2146,7 @@ void bcm43xx_radio_turn_off(struct bcm43
 	} else
 		bcm43xx_phy_write(bcm, 0x0015, 0xAA00);
 	radio->enabled = 0;
-	dprintk(KERN_INFO PFX "Radio turned off\n");
+	dprintk(KERN_INFO PFX "Radio initialized\n");
 	bcm43xx_leds_update(bcm, 0);
 }
 


From athin at go2.pl  Mon Sep 17 00:44:51 2007
From: athin at go2.pl (Marcin Kosiba)
Date: Mon, 17 Sep 2007 00:44:51 +0200
Subject: software powerup
In-Reply-To: <200709161236.21563.mb@bu3sch.de>
References: <200709160003.26098.athin@go2.pl> <200709161217.50081.athin@go2.pl>
	<200709161236.21563.mb@bu3sch.de>
Message-ID: <200709170044.51590.athin@go2.pl>

On Sunday 16 September 2007, you wrote:
> On Sunday 16 September 2007 12:17:50 Marcin Kosiba wrote:
> > On Sunday 16 September 2007, Michael Buesch wrote:
> > > On Sunday 16 September 2007 11:26:21 Marcin Kosiba wrote:
> > > > On Sunday 16 September 2007, Larry Finger wrote:
> > > > > The only switch associated with any of the BCM cards that I know
> > > > > about is the radio-enable switch. If that is what you need, it can
> > > > > only be controlled externally. The software can read its state, but
> > > > > not control it.
> > > >
> > > > not fun - oh well... gotta warm that soldering iron up then...
> > > >
> > > > > What OS are you using? If Linux and the appropriate driver is
> > > > > installed, the output of the dmesg command will show some details.
> > > >
> > > > slackware linux 12.0
> > > > (uname -a:
> > > > Linux ebox 2.6.21.5 #2 Tue Jun 19 15:22:48 CDT 2007 i586 05/00 SiS
> > > > SiS SiS GNU/Linux)
> > > >
> > > > dmesg | grep bcm
> > > >
> > > > bcm43xx: Chip ID 0x4306, rev 0x3
> > > > bcm43xx: Number of cores: 5
> > > > bcm43xx: Core 0: ID 0x800, rev 0x4, vendor 0x4243
> > > > bcm43xx: Core 1: ID 0x812, rev 0x5, vendor 0x4243
> > > > bcm43xx: Core 2: ID 0x80d, rev 0x2, vendor 0x4243
> > > > bcm43xx: Core 3: ID 0x807, rev 0x2, vendor 0x4243
> > > > bcm43xx: Core 4: ID 0x804, rev 0x9, vendor 0x4243
> > > > bcm43xx: PHY connected
> > > > bcm43xx: Detected PHY: Analog: 2, Type 2, Revision 2
> > > > bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> > > > bcm43xx: Radio turned off
> > > > bcm43xx: Radio turned off
> > > >
> > > > as I've said - off :/
> > >
> > > What about bringing the device up?
> >
> > ok, my bad - had the wrong firmware version up there (seems as though the
> > error messages are shown in dmesg only if I load the module manually - if
> > it is loaded on startup they probably go somewhere else..)
> >
> > bcm43xx: Radio turned off
> > bcm43xx: Radio turned off
> > bcm43xx: PHY connected
> > bcm43xx: Microcode rev 0xf5, pl 0x5a (2003-12-22  20:11:25)
> > bcm43xx: Radio turned on
> > bcm43xx: Radio enabled by hardware
> > bcm43xx: Chip initialized
> > bcm43xx: 30-bit DMA initialized
> > bcm43xx: Keys cleared
> > bcm43xx: Selected 802.11 core (phytype 2)
>
> So everything's fine?

Hard to say really, iwlist scan doesn't get any results and I can't associate 
with the AP which is physically right next to the device. I'll try the newest 
bcm43xx from git and see what happens.

Same thing (no scan results and can't associate with the AP) happens with 
ndiswrapper, though I don't know if the radio is on or off.

Cheers,
	Marcin


From athin at go2.pl  Mon Sep 17 00:54:02 2007
From: athin at go2.pl (Marcin Kosiba)
Date: Mon, 17 Sep 2007 00:54:02 +0200
Subject: software powerup
In-Reply-To: <200709170044.51590.athin@go2.pl>
References: <200709160003.26098.athin@go2.pl> <200709161236.21563.mb@bu3sch.de>
	<200709170044.51590.athin@go2.pl>
Message-ID: <200709170054.02486.athin@go2.pl>

On Monday 17 September 2007, Marcin Kosiba wrote:
> On Sunday 16 September 2007, you wrote:
> > On Sunday 16 September 2007 12:17:50 Marcin Kosiba wrote:
> > > On Sunday 16 September 2007, Michael Buesch wrote:
> > > > On Sunday 16 September 2007 11:26:21 Marcin Kosiba wrote:
> > > > > On Sunday 16 September 2007, Larry Finger wrote:
> > > > > > The only switch associated with any of the BCM cards that I know
> > > > > > about is the radio-enable switch. If that is what you need, it
> > > > > > can only be controlled externally. The software can read its
> > > > > > state, but not control it.
> > > > >
> > > > > not fun - oh well... gotta warm that soldering iron up then...
> > > > >
> > > > > > What OS are you using? If Linux and the appropriate driver is
> > > > > > installed, the output of the dmesg command will show some
> > > > > > details.
> > > > >
> > > > > slackware linux 12.0
> > > > > (uname -a:
> > > > > Linux ebox 2.6.21.5 #2 Tue Jun 19 15:22:48 CDT 2007 i586 05/00 SiS
> > > > > SiS SiS GNU/Linux)
> > > > >
> > > > > dmesg | grep bcm
> > > > >
> > > > > bcm43xx: Chip ID 0x4306, rev 0x3
> > > > > bcm43xx: Number of cores: 5
> > > > > bcm43xx: Core 0: ID 0x800, rev 0x4, vendor 0x4243
> > > > > bcm43xx: Core 1: ID 0x812, rev 0x5, vendor 0x4243
> > > > > bcm43xx: Core 2: ID 0x80d, rev 0x2, vendor 0x4243
> > > > > bcm43xx: Core 3: ID 0x807, rev 0x2, vendor 0x4243
> > > > > bcm43xx: Core 4: ID 0x804, rev 0x9, vendor 0x4243
> > > > > bcm43xx: PHY connected
> > > > > bcm43xx: Detected PHY: Analog: 2, Type 2, Revision 2
> > > > > bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> > > > > bcm43xx: Radio turned off
> > > > > bcm43xx: Radio turned off
> > > > >
> > > > > as I've said - off :/
> > > >
> > > > What about bringing the device up?
> > >
> > > ok, my bad - had the wrong firmware version up there (seems as though
> > > the error messages are shown in dmesg only if I load the module
> > > manually - if it is loaded on startup they probably go somewhere
> > > else..)
> > >
> > > bcm43xx: Radio turned off
> > > bcm43xx: Radio turned off
> > > bcm43xx: PHY connected
> > > bcm43xx: Microcode rev 0xf5, pl 0x5a (2003-12-22  20:11:25)
> > > bcm43xx: Radio turned on
> > > bcm43xx: Radio enabled by hardware
> > > bcm43xx: Chip initialized
> > > bcm43xx: 30-bit DMA initialized
> > > bcm43xx: Keys cleared
> > > bcm43xx: Selected 802.11 core (phytype 2)
> >
> > So everything's fine?
>
> Hard to say really, iwlist scan doesn't get any results and I can't
> associate with the AP which is physically right next to the device. I'll
> try the newest bcm43xx from git and see what happens.
>
> Same thing (no scan results and can't associate with the AP) happens with
> ndiswrapper, though I don't know if the radio is on or off.

after removing some of the casing and unloading and loading the driver i got a 
correct scan result on bcm43xx (but not on ndiswrapper). Seems as though I'll 
need an external antenna - does any one know what is the function of the AUX 
hirose connector (asides from the fact that it enables you to have 2 
antennas)

Cheers,
	Marcin


From larry.finger at lwfinger.net  Mon Sep 17 00:57:13 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 16 Sep 2007 17:57:13 -0500
Subject: software powerup
In-Reply-To: <200709170044.51590.athin@go2.pl>
References: <200709160003.26098.athin@go2.pl>
	<200709161217.50081.athin@go2.pl>	<200709161236.21563.mb@bu3sch.de>
	<200709170044.51590.athin@go2.pl>
Message-ID: <46EDB4C9.9090202@lwfinger.net>

Marcin Kosiba wrote:
> On Sunday 16 September 2007, you wrote:
>> On Sunday 16 September 2007 12:17:50 Marcin Kosiba wrote:
>>> On Sunday 16 September 2007, Michael Buesch wrote:
>>>> On Sunday 16 September 2007 11:26:21 Marcin Kosiba wrote:
>>>>> On Sunday 16 September 2007, Larry Finger wrote:
>>>>>> The only switch associated with any of the BCM cards that I know
>>>>>> about is the radio-enable switch. If that is what you need, it can
>>>>>> only be controlled externally. The software can read its state, but
>>>>>> not control it.
>>>>> not fun - oh well... gotta warm that soldering iron up then...
>>>>>
>>>>>> What OS are you using? If Linux and the appropriate driver is
>>>>>> installed, the output of the dmesg command will show some details.
>>>>> slackware linux 12.0
>>>>> (uname -a:
>>>>> Linux ebox 2.6.21.5 #2 Tue Jun 19 15:22:48 CDT 2007 i586 05/00 SiS
>>>>> SiS SiS GNU/Linux)
>>>>>
>>>>> dmesg | grep bcm
>>>>>
>>>>> bcm43xx: Chip ID 0x4306, rev 0x3
>>>>> bcm43xx: Number of cores: 5
>>>>> bcm43xx: Core 0: ID 0x800, rev 0x4, vendor 0x4243
>>>>> bcm43xx: Core 1: ID 0x812, rev 0x5, vendor 0x4243
>>>>> bcm43xx: Core 2: ID 0x80d, rev 0x2, vendor 0x4243
>>>>> bcm43xx: Core 3: ID 0x807, rev 0x2, vendor 0x4243
>>>>> bcm43xx: Core 4: ID 0x804, rev 0x9, vendor 0x4243
>>>>> bcm43xx: PHY connected
>>>>> bcm43xx: Detected PHY: Analog: 2, Type 2, Revision 2
>>>>> bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
>>>>> bcm43xx: Radio turned off
>>>>> bcm43xx: Radio turned off
>>>>>
>>>>> as I've said - off :/
>>>> What about bringing the device up?
>>> ok, my bad - had the wrong firmware version up there (seems as though the
>>> error messages are shown in dmesg only if I load the module manually - if
>>> it is loaded on startup they probably go somewhere else..)
>>>
>>> bcm43xx: Radio turned off
>>> bcm43xx: Radio turned off
>>> bcm43xx: PHY connected
>>> bcm43xx: Microcode rev 0xf5, pl 0x5a (2003-12-22  20:11:25)
>>> bcm43xx: Radio turned on
>>> bcm43xx: Radio enabled by hardware
>>> bcm43xx: Chip initialized
>>> bcm43xx: 30-bit DMA initialized
>>> bcm43xx: Keys cleared
>>> bcm43xx: Selected 802.11 core (phytype 2)
>> So everything's fine?
> 
> Hard to say really, iwlist scan doesn't get any results and I can't associate 
> with the AP which is physically right next to the device. I'll try the newest 
> bcm43xx from git and see what happens.

If you don't get scan results, it will not associate.
> 
> Same thing (no scan results and can't associate with the AP) happens with 
> ndiswrapper, though I don't know if the radio is on or off.

The radio might be broken, but the software has turned in on, and there is not likely a hardware switch.

One thing you might do is get the latest firmware. The URL is
http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o.

Larry


From linville at tuxdriver.com  Mon Sep 17 17:03:58 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Mon, 17 Sep 2007 11:03:58 -0400
Subject: [PATCH V2] b43legacy: Don't cancel the restart workqueue in
	wireless_core_exit
In-Reply-To: <46e577e8.J3sSMKsbv5F0EAQY%Larry.Finger@lwfinger.net>
References: <46e577e8.J3sSMKsbv5F0EAQY%Larry.Finger@lwfinger.net>
Message-ID: <20070917150358.GC9282@tuxdriver.com>

Is this the correct patch?  The first hunk conflicts with an earlier
patch ("b43legacy: Fix cancellation of work queues").

John

On Mon, Sep 10, 2007 at 11:59:20AM -0500, Larry Finger wrote:
> From: Michael Buesch <mb at bu3sch.de>
> 
> The wq must be canceled later on rmmod. It's nonfatal, if
> the wq runs on a device that's not started or down. It will
> handle these cases.
> But syncing in wireless_core_exit() will cause a deadlock with
> the restart_work. (restart work cancels itself)
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>
> Signed-off-by: Larry Finger <larry.finger at lwfinger.net>
> ---
> 
> John,
> 
> Sorry, but I sent the bare patch in the first version.
> 
> Larry
> 
>  drivers/net/wireless/b43legacy/main.c |    2 ++
>  1 file changed, 2 insertions(+)
> 
> Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
> +++ wireless-dev/drivers/net/wireless/b43legacy/main.c
> @@ -3021,6 +3021,7 @@ static void b43legacy_wireless_core_exit
>  	B43legacy_WARN_ON(b43legacy_status(dev) > B43legacy_STAT_INITIALIZED);
>  	if (b43legacy_status(dev) != B43legacy_STAT_INITIALIZED)
>  		return;
> +	b43legacy_set_status(dev, B43legacy_STAT_UNINIT);
>  
>  	b43legacy_rng_exit(dev->wl);
>  	b43legacy_pio_free(dev);
> @@ -3520,6 +3521,7 @@ static void b43legacy_one_core_detach(st
>  
>  	wldev = ssb_get_drvdata(dev);
>  	wl = wldev->wl;
> +	cancel_work_sync(&wldev->restart_work);
>  	b43legacy_debugfs_remove_device(wldev);
>  	b43legacy_wireless_core_detach(wldev);
>  	list_del(&wldev->list);
> -
> To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
> the body of a message to majordomo at vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html

-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Mon Sep 17 19:05:36 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 17 Sep 2007 12:05:36 -0500
Subject: [PATCH V2] b43legacy: Don't cancel the restart workqueue
	in	wireless_core_exit
In-Reply-To: <20070917150358.GC9282@tuxdriver.com>
References: <46e577e8.J3sSMKsbv5F0EAQY%Larry.Finger@lwfinger.net>
	<20070917150358.GC9282@tuxdriver.com>
Message-ID: <46EEB3E0.4010501@lwfinger.net>

John W. Linville wrote:
> Is this the correct patch?  The first hunk conflicts with an earlier
> patch ("b43legacy: Fix cancellation of work queues").
> 
> John

Yes, this one is correct. The first one was without a commit message, and had an error.

Larry


From larry.finger at lwfinger.net  Mon Sep 17 19:27:13 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 17 Sep 2007 12:27:13 -0500
Subject: 2.6.23-rc regression: bcm43xx does not work after commit 4cf92a3c
In-Reply-To: <20070917165435.GA26926@bougret.hpl.hp.com>
References: <20070917.042418.19962472.yoshfuji@linux-ipv6.org>
	<20070917165435.GA26926@bougret.hpl.hp.com>
Message-ID: <46EEB8F1.5080702@lwfinger.net>

Jean Tourrilhes wrote:
> On Mon, Sep 17, 2007 at 04:24:18AM +0900, YOSHIFUJI Hideaki / ?$B5HF#1QL@ wrote:
>> Hello.
>>
>> With latest git tree, bcm43xx driver does not work.
>> By bisect, I've found the commit 4cf92a3c is the first "bad" commit.
>>
>>     [PATCH] softmac: Fix ESSID problem
>>
>>     Victor Porton reported that the SoftMAC layer had random problem when setting the ESSID :
>>     http://bugzilla.kernel.org/show_bug.cgi?id=8686 After investigation, it turned out to be
>>     worse, the SoftMAC layer is left in an inconsistent state. The fix is pretty trivial.
>>     
>>     Signed-off-by: Jean Tourrilhes <jt at hpl.hp.com>
>>     Acked-by: Michael Buesch <mb at bu3sch.df>
>>     Acked-by: Larry Finger <Larry.Finger at lwfinger.net>
>>     Signed-off-by: John W. Linville <linville at tuxdriver.com>
>>
>> After reverting this commit, the driver starts working again.

Thank you for this thorough, if surprising, bug report.

I would like a few more details about your configuration so that I might be able to reproduce the
problem.

When you say "the latest git tree", do you mean Linus's mainstream tree?

Is your wireless device being controlled by NetworkManager, or by ifconfig up/down?

Which distro do you use?

Which BCM43xx device do you have?

Thanks,

Larry


From linville at tuxdriver.com  Mon Sep 17 19:37:54 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Mon, 17 Sep 2007 13:37:54 -0400
Subject: [PATCH V2] b43legacy: Don't cancel the restart workqueue in
	wireless_core_exit
In-Reply-To: <46EEB3E0.4010501@lwfinger.net>
References: <46e577e8.J3sSMKsbv5F0EAQY%Larry.Finger@lwfinger.net>
	<20070917150358.GC9282@tuxdriver.com>
	<46EEB3E0.4010501@lwfinger.net>
Message-ID: <20070917173754.GD9282@tuxdriver.com>

On Mon, Sep 17, 2007 at 12:05:36PM -0500, Larry Finger wrote:
> John W. Linville wrote:
> > Is this the correct patch?  The first hunk conflicts with an earlier
> > patch ("b43legacy: Fix cancellation of work queues").
> > 
> > John
> 
> Yes, this one is correct. The first one was without a commit message, and had an error.

Hmmmm, not that one.  There was another patch that (looking closer)
you sent me and cc'ed bcm43xx-dev on or about 30 August.  I guess
I'll drop that one and use this one instead.

Thanks,

John
-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Mon Sep 17 20:58:26 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 17 Sep 2007 13:58:26 -0500
Subject: [PATCH V2] b43legacy: Don't cancel the restart workqueue
	in	wireless_core_exit
In-Reply-To: <20070917173754.GD9282@tuxdriver.com>
References: <46e577e8.J3sSMKsbv5F0EAQY%Larry.Finger@lwfinger.net>
	<20070917150358.GC9282@tuxdriver.com>
	<46EEB3E0.4010501@lwfinger.net>
	<20070917173754.GD9282@tuxdriver.com>
Message-ID: <46EECE52.1060206@lwfinger.net>

John W. Linville wrote:
> On Mon, Sep 17, 2007 at 12:05:36PM -0500, Larry Finger wrote:
>> John W. Linville wrote:
>>> Is this the correct patch?  The first hunk conflicts with an earlier
>>> patch ("b43legacy: Fix cancellation of work queues").
>>>
>>> John
>> Yes, this one is correct. The first one was without a commit message, and had an error.
> 
> Hmmmm, not that one.  There was another patch that (looking closer)
> you sent me and cc'ed bcm43xx-dev on or about 30 August.  I guess
> I'll drop that one and use this one instead.

No, the Aug 30 one is needed. Somehow my patch sets got confused. Please apply the August 30 patch
and drop the Sept. 10 one. I'll fix it after your tree gets updated. I don't think it will cause any
problems. As you said, the first hunk is already in the Aug. 30 patch.

Larry


From dwmw2 at infradead.org  Mon Sep 17 22:18:57 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Mon, 17 Sep 2007 21:18:57 +0100
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <200709142333.42390.mb@bu3sch.de>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<1189802714.4460.5.camel@shinybook.infradead.org>
	<46EAFAE8.5010003@lwfinger.net>  <200709142333.42390.mb@bu3sch.de>
Message-ID: <1190060337.9286.0.camel@shinybook.infradead.org>

On Fri, 2007-09-14 at 23:33 +0200, Michael Buesch wrote:
> These are all false positives, except this one, where the wrong
> converter function was used.
> 
> @@ -442,7 +444,7 @@ void b43legacy_rx(struct b43legacy_wldev
>         phystat0 = le16_to_cpu(rxhdr->phy_status0);
>         phystat3 = le16_to_cpu(rxhdr->phy_status3);
>         jssi = rxhdr->jssi;
> -       macstat = le32_to_cpu(rxhdr->mac_status);
> +       macstat = le16_to_cpu(rxhdr->mac_status);
>         mactime = le16_to_cpu(rxhdr->mac_time);
>         chanstat = le16_to_cpu(rxhdr->channel); 

Did this one get committed yet?

-- 
dwmw2



From gmccullagh at gmail.com  Mon Sep 17 22:45:26 2007
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Mon, 17 Sep 2007 21:45:26 +0100
Subject: [AirForce One 54g] working
In-Reply-To: <20070916214502.GA21484@gmail.com>
References: <20070916214502.GA21484@gmail.com>
Message-ID: <20070917204526.GA17766@gmail.com>

Hi,
 
a few more details.

On Sun, 16 Sep 2007, Gavin McCullagh wrote:

> I have a linksys WPC54GS pcmcia wifi card.  lspci details below.  I tried
> it with the latest firmware and Ubuntu gutsy's 2.6.22-10-generic and
> 2.6.22-11-generic kernels.  

> I went onto the IRC channel and noted the suggestion that I try the
> wireless-dev tree (2.6.23-rc4).  So I did and I'm glad to say successfully.
> I'm using it now and have been for the past 6-8 hours on and off without
> any reboot or problems.  

A little more feedback on my experiences with this driver.

The first time I booted up, logged in (to gnome) and then popped in the
pcmcia card.  The key manager prompted for password to unlock it and I got
straight onto the WPA wifi network (192.168.10.0/24).  This worked fine and
continues to.

Later I tried to boot up with the card in.  I logged in and network-manager
connected to an unencrypted network (192.168.182.0/24).  Not wanting that,
I clicked on the network manager and selected the WPA network.  Nothing
much happened, according to the applet and the ip address and essid didn't
change according to iwconfig/ifconfig.  Eventually the applet disappeared
and restarting it didn't work.  In syslog, it showed that NetworkManager
had crashed.   A full log is below.  

It seems there is a problem switching network but as long as I start it on 
the WPA one, all is fine.  I realise this driver is still experimental so
perhaps this behaviour is normal and as I know how to make it work reliably
it's okay.  However, if you need more information let me know.  It seems
pretty reproducible.

Gavin

> gavinmc at tilly:~$ lspci -v -s 02:00.0
> 02:00.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 54g]
> 802.11g Wireless LAN Controller (rev 02)
>         Subsystem: Linksys Unknown device 0049
>         Flags: bus master, fast devsel, latency 64, IRQ 10
>         Memory at 24000000 (32-bit, non-prefetchable) [size=8K]
> 
> gavinmc at tilly:~$ lspci -vn -s 02:00.0
> 02:00.0 0280: 14e4:4318 (rev 02)
>         Subsystem: 1737:0049
>         Flags: bus master, fast devsel, latency 64, IRQ 10
>         Memory at 24000000 (32-bit, non-prefetchable) [size=8K]



Sep 17 20:17:28 tilly kernel: [  106.569612] lo: Disabled Privacy Extensions
Sep 17 20:17:28 tilly kernel: [  106.570443] ADDRCONF(NETDEV_UP): eth0: link is not ready
Sep 17 20:17:28 tilly kernel: [  106.570500] ADDRCONF(NETDEV_UP): eth1: link is not ready
Sep 17 20:17:33 tilly hcid[4838]: Default passkey agent (:1.14, /org/bluez/passkey) registered
Sep 17 20:17:33 tilly hcid[4838]: Default authorization agent (:1.14, /org/bluez/auth) registered
Sep 17 20:17:48 tilly NetworkManager: <info>  Updating allowed wireless network lists. 
Sep 17 20:17:48 tilly NetworkManager: <info>  SWITCH: no current connection, found better connection 'eth1'. 
Sep 17 20:17:48 tilly dhcdbd: message_handler: message handler not found under /com/redhat/dhcp/eth1 for sub-path eth1.dbus.get.reason
Sep 17 20:17:48 tilly NetworkManager: <info>  Will activate connection 'eth1/FON_TEST'. 
Sep 17 20:17:48 tilly NetworkManager: <info>  Device eth1 activation scheduled... 
Sep 17 20:17:48 tilly NetworkManager: <info>  Activation (eth1) started... 
Sep 17 20:17:48 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) scheduled... 
Sep 17 20:17:48 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) started... 
Sep 17 20:17:48 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) scheduled... 
Sep 17 20:17:48 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) complete. 
Sep 17 20:17:48 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) starting... 
Sep 17 20:17:48 tilly NetworkManager: <info>  Activation (eth1/wireless): access point 'FON_TEST' is unencrypted, no key needed. 
Sep 17 20:17:48 tilly NetworkManager: <info>  Old device 'eth1' activating, won't change. 
Sep 17 20:17:49 tilly NetworkManager: <info>  supplicant_interface_init() - connect to global ctrl socket (0/10). 
Sep 17 20:17:49 tilly NetworkManager: <info>  supplicant_interface_init() - connect to global ctrl socket (1/10). 
Sep 17 20:17:50 tilly NetworkManager: <info>  supplicant_interface_init() - connect to global ctrl socket (2/10). 
Sep 17 20:17:50 tilly NetworkManager: <info>  supplicant_interface_init() - connect to global ctrl socket (3/10). 
Sep 17 20:17:50 tilly NetworkManager: <info>  supplicant_interface_init() - connect to global ctrl socket (4/10). 
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: sending command 'INTERFACE_ADD eth1^I^Iwext^I/var/run/wpa_supplicant2^I' 
Sep 17 20:17:50 tilly kernel: [  122.379900] NET: Registered protocol family 17
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:17:50 tilly NetworkManager: <info>  supplicant_init() - connect to device ctrl socket (6/10). 
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: sending command 'AP_SCAN 1' 
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: sending command 'ADD_NETWORK' 
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: response was '0' 
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: sending command 'SET_NETWORK 0 ssid 464f4e5f474156' 
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: sending command 'SET_NETWORK 0 key_mgmt NONE' 
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: sending command 'ENABLE_NETWORK 0' 
Sep 17 20:17:50 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:17:50 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) complete. 
Sep 17 20:17:51 tilly kernel: [  122.725655] SoftMAC: Open Authentication completed with 00:18:84:11:78:d5
Sep 17 20:17:51 tilly NetworkManager: <info>  Activation (eth1/wireless) Stage 2 of 5 (Device Configure) successful.  Connected to access point 'FON_TEST'. 
Sep 17 20:17:51 tilly NetworkManager: <info>  Activation (eth1) Stage 3 of 5 (IP Configure Start) scheduled. 
Sep 17 20:17:51 tilly NetworkManager: <info>  Activation (eth1) Stage 3 of 5 (IP Configure Start) started... 
Sep 17 20:17:51 tilly kernel: [  122.739431] ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready
Sep 17 20:17:52 tilly NetworkManager: <info>  Activation (eth1) Beginning DHCP transaction. 
Sep 17 20:17:52 tilly NetworkManager: <info>  Activation (eth1) Stage 3 of 5 (IP Configure Start) complete. 
Sep 17 20:17:52 tilly NetworkManager: <info>  DHCP daemon state is now 12 (successfully started) for interface eth1 
Sep 17 20:17:52 tilly avahi-daemon[4797]: Registering new address record for fe80::21c:10ff:fe11:5a53 on eth1.*.
Sep 17 20:17:54 tilly NetworkManager: <info>  DHCP daemon state is now 1 (starting) for interface eth1 
Sep 17 20:17:56 tilly NetworkManager: <info>  Old device 'eth1' activating, won't change. 
Sep 17 20:17:57 tilly dhclient: DHCPREQUEST on eth1 to 255.255.255.255 port 67
Sep 17 20:17:57 tilly dhclient: DHCPNAK from 192.168.182.1
Sep 17 20:17:57 tilly avahi-autoipd(eth1)[5311]: Found user 'avahi-autoipd' (UID 109) and group 'avahi-autoipd' (GID 119).
Sep 17 20:17:57 tilly avahi-autoipd(eth1)[5311]: Successfully called chroot().
Sep 17 20:17:57 tilly avahi-autoipd(eth1)[5311]: Successfully dropped root privileges.
Sep 17 20:17:57 tilly avahi-autoipd(eth1)[5311]: Starting with address 169.254.3.119
Sep 17 20:18:01 tilly kernel: [  133.303557] eth1: no IPv6 routers present
Sep 17 20:18:02 tilly avahi-autoipd(eth1)[5311]: Callout BIND, address 169.254.3.119 on interface eth1
Sep 17 20:18:02 tilly avahi-daemon[4797]: Joining mDNS multicast group on interface eth1.IPv4 with address 169.254.3.119.
Sep 17 20:18:02 tilly avahi-daemon[4797]: New relevant interface eth1.IPv4 for mDNS.
Sep 17 20:18:02 tilly avahi-daemon[4797]: Registering new address record for 169.254.3.119 on eth1.IPv4.
Sep 17 20:18:06 tilly avahi-autoipd(eth1)[5311]: Successfully claimed IP address 169.254.3.119
Sep 17 20:18:06 tilly NetworkManager: <info>  DHCP daemon state is now 10 (unknown) for interface eth1 
Sep 17 20:18:06 tilly avahi-autoipd(eth1)[5311]: Got SIGTERM, quitting.
Sep 17 20:18:06 tilly avahi-autoipd(eth1)[5311]: Callout STOP, address 169.254.3.119 on interface eth1
Sep 17 20:18:06 tilly avahi-daemon[4797]: Withdrawing address record for 169.254.3.119 on eth1.
Sep 17 20:18:06 tilly avahi-daemon[4797]: Leaving mDNS multicast group on interface eth1.IPv4 with address 169.254.3.119.
Sep 17 20:18:06 tilly avahi-daemon[4797]: Interface eth1.IPv4 no longer relevant for mDNS.
Sep 17 20:18:06 tilly avahi-autoipd(eth1)[5312]: client: RTNETLINK answers: No such process
Sep 17 20:18:08 tilly NetworkManager: <info>  DHCP daemon state is now 1 (starting) for interface eth1 
Sep 17 20:18:08 tilly dhclient: DHCPDISCOVER on eth1 to 255.255.255.255 port 67 interval 6
Sep 17 20:18:08 tilly dhclient: DHCPOFFER from 192.168.182.1
Sep 17 20:18:08 tilly dhclient: DHCPREQUEST on eth1 to 255.255.255.255 port 67
Sep 17 20:18:08 tilly dhclient: DHCPACK from 192.168.182.1
Sep 17 20:18:08 tilly avahi-daemon[4797]: Joining mDNS multicast group on interface eth1.IPv4 with address 192.168.182.5.
Sep 17 20:18:08 tilly avahi-daemon[4797]: New relevant interface eth1.IPv4 for mDNS.
Sep 17 20:18:08 tilly avahi-daemon[4797]: Registering new address record for 192.168.182.5 on eth1.IPv4.
Sep 17 20:18:08 tilly NetworkManager: <info>  DHCP daemon state is now 2 (bound) for interface eth1 
Sep 17 20:18:08 tilly NetworkManager: <info>  Activation (eth1) Stage 4 of 5 (IP Configure Get) scheduled... 
Sep 17 20:18:08 tilly NetworkManager: <info>  Activation (eth1) Stage 4 of 5 (IP Configure Get) started... 
Sep 17 20:18:08 tilly dhclient: bound to 192.168.182.5 -- renewal in 289 seconds.
Sep 17 20:18:08 tilly dhcdbd: message_handler: message handler not found under /com/redhat/dhcp/eth1 for sub-path eth1.dbus.get.host_name
Sep 17 20:18:08 tilly dhcdbd: message_handler: message handler not found under /com/redhat/dhcp/eth1 for sub-path eth1.dbus.get.nis_domain
Sep 17 20:18:08 tilly dhcdbd: message_handler: message handler not found under /com/redhat/dhcp/eth1 for sub-path eth1.dbus.get.nis_servers
Sep 17 20:18:08 tilly NetworkManager: <info>  Retrieved the following IP4 configuration from the DHCP daemon: 
Sep 17 20:18:08 tilly NetworkManager: <info>    address 192.168.182.5 
Sep 17 20:18:08 tilly NetworkManager: <info>    netmask 255.255.255.0 
Sep 17 20:18:08 tilly NetworkManager: <info>    broadcast 192.168.182.255 
Sep 17 20:18:08 tilly NetworkManager: <info>    gateway 192.168.182.1 
Sep 17 20:18:08 tilly NetworkManager: <info>    nameserver 192.168.10.1 
Sep 17 20:18:08 tilly NetworkManager: <info>    nameserver 192.168.10.1 
Sep 17 20:18:08 tilly NetworkManager: <info>    domain name 'key.chillispot.org' 
Sep 17 20:18:08 tilly NetworkManager: <info>  Activation (eth1) Stage 5 of 5 (IP Configure Commit) scheduled... 
Sep 17 20:18:08 tilly NetworkManager: <info>  Activation (eth1) Stage 4 of 5 (IP Configure Get) complete. 
Sep 17 20:18:08 tilly NetworkManager: <info>  Activation (eth1) Stage 5 of 5 (IP Configure Commit) started... 
Sep 17 20:18:08 tilly avahi-daemon[4797]: Withdrawing address record for 192.168.182.5 on eth1.
Sep 17 20:18:08 tilly avahi-daemon[4797]: Leaving mDNS multicast group on interface eth1.IPv4 with address 192.168.182.5.
Sep 17 20:18:08 tilly avahi-daemon[4797]: Interface eth1.IPv4 no longer relevant for mDNS.
Sep 17 20:18:08 tilly avahi-daemon[4797]: Withdrawing address record for fe80::21c:10ff:fe11:5a53 on eth1.
Sep 17 20:18:08 tilly avahi-daemon[4797]: Joining mDNS multicast group on interface eth1.IPv4 with address 192.168.182.5.
Sep 17 20:18:08 tilly avahi-daemon[4797]: New relevant interface eth1.IPv4 for mDNS.
Sep 17 20:18:08 tilly avahi-daemon[4797]: Registering new address record for 192.168.182.5 on eth1.IPv4.
Sep 17 20:18:09 tilly NetworkManager: <info>  Clearing nscd hosts cache. 
Sep 17 20:18:09 tilly NetworkManager: <WARN>  nm_spawn_process(): nm_spawn_process('/usr/sbin/nscd -i hosts'): could not spawn process. (Failed to execute child process "/usr/sbin/nscd" (No such file or directory))  
Sep 17 20:18:09 tilly NetworkManager: <info>  Activation (eth1) successful, device activated. 
Sep 17 20:18:09 tilly NetworkManager: <info>  Activation (eth1) Finish handler scheduled. 
Sep 17 20:18:09 tilly NetworkManager: <info>  Activation (eth1) Stage 5 of 5 (IP Configure Commit) complete. 
Sep 17 20:18:11 tilly avahi-daemon[4797]: Registering new address record for fe80::21c:10ff:fe11:5a53 on eth1.*.
Sep 17 20:18:14 tilly ntpdate[5403]: no server suitable for synchronization found
Sep 17 20:18:20 tilly kernel: [  142.125999] eth1: no IPv6 routers present
Sep 17 20:18:37 tilly NetworkManager: <debug> [1190056717.239899] nm_device_802_11_wireless_get_activation_ap(): Forcing AP 'TEST' 
Sep 17 20:18:37 tilly NetworkManager: <info>  User Switch: /org/freedesktop/NetworkManager/Devices/eth1 / TEST 
Sep 17 20:18:37 tilly NetworkManager: <info>  Deactivating device eth1. 
Sep 17 20:18:37 tilly dhclient: There is already a pid file /var/run/dhclient.eth1.pid with pid 5279
Sep 17 20:18:37 tilly dhclient: killed old client process, removed PID file
Sep 17 20:18:37 tilly dhclient: DHCPRELEASE on eth1 to 192.168.182.1 port 67
Sep 17 20:18:37 tilly avahi-daemon[4797]: Withdrawing address record for 192.168.182.5 on eth1.
Sep 17 20:18:37 tilly avahi-daemon[4797]: Leaving mDNS multicast group on interface eth1.IPv4 with address 192.168.182.5.
Sep 17 20:18:37 tilly avahi-daemon[4797]: Interface eth1.IPv4 no longer relevant for mDNS.
Sep 17 20:18:38 tilly NetworkManager: <info>  SUP: sending command 'DISABLE_NETWORK 0' 
Sep 17 20:18:48 tilly kernel: [  145.904515] pccard: card ejected from slot 0
Sep 17 20:18:48 tilly kernel: [  145.910081] bcm43xx: Failed to switch to core 0
Sep 17 20:18:48 tilly kernel: [  145.910755] bcm43xx: Failed to switch to core 2
Sep 17 20:18:48 tilly kernel: [  145.910763] bcm43xx: gpio error: Neither ChipCommon nor PCI core available!
Sep 17 20:18:48 tilly kernel: [  145.921468] bcm43xx: Error: Wait on DMA RX status timed out.
Sep 17 20:18:48 tilly kernel: [  145.942884] bcm43xx: Error: Wait on DMA TX status timed out.
Sep 17 20:18:48 tilly kernel: [  145.964157] bcm43xx: Error: Wait on DMA TX status timed out.
Sep 17 20:18:48 tilly kernel: [  145.985452] bcm43xx: Error: Wait on DMA TX status timed out.
Sep 17 20:18:48 tilly kernel: [  146.006738] bcm43xx: Error: Wait on DMA TX status timed out.
Sep 17 20:18:48 tilly kernel: [  146.028020] bcm43xx: Error: Wait on DMA TX status timed out.
Sep 17 20:18:48 tilly kernel: [  146.049315] bcm43xx: Error: Wait on DMA TX status timed out.
Sep 17 20:18:48 tilly kernel: [  146.049995] bcm43xx: Failed to switch to core 0
Sep 17 20:18:48 tilly avahi-daemon[4797]: Withdrawing address record for fe80::21c:10ff:fe11:5a53 on eth1.
Sep 17 20:18:48 tilly kernel: [  146.074167] bcm43xx: Failed to switch to core 0
Sep 17 20:18:48 tilly kernel: [  146.074848] bcm43xx: Failed to switch to core 0
Sep 17 20:18:48 tilly kernel: [  146.076909] ACPI: PCI interrupt for device 0000:02:00.0 disabled
Sep 17 20:18:50 tilly NetworkManager: <info>  SUP: response was 'TIMEOUT[CLI]' 
Sep 17 20:18:50 tilly NetworkManager: <WARN>  nm_utils_supplicant_request_with_check(): supplicant_cleanup: supplicant error for 'DISABLE_NETWORK 0'.  Response: 'TIMEOUT[CLI]' 
Sep 17 20:18:50 tilly NetworkManager: <WARN>  supplicant_cleanup(): supplicant_cleanup - couldn't disable network in supplicant_cleanup 
Sep 17 20:18:50 tilly NetworkManager: <info>  SUP: sending command 'AP_SCAN 0' 
Sep 17 20:19:02 tilly NetworkManager: <info>  SUP: response was 'TIMEOUT[CLI]' 
Sep 17 20:19:02 tilly NetworkManager: <WARN>  nm_utils_supplicant_request_with_check(): supplicant_cleanup: supplicant error for 'AP_SCAN 0'.  Response: 'TIMEOUT[CLI]' 
Sep 17 20:19:02 tilly NetworkManager: <WARN>  supplicant_cleanup(): supplicant_cleanup - couldn't set AP_SCAN 0 
Sep 17 20:19:02 tilly NetworkManager: <info>  SUP: sending command 'TERMINATE' 
Sep 17 20:19:14 tilly NetworkManager: <info>  SUP: response was 'TIMEOUT[CLI]' 
Sep 17 20:19:14 tilly NetworkManager: <WARN>  nm_utils_supplicant_request_with_check(): supplicant_cleanup: supplicant error for 'TERMINATE'.  Response: 'TIMEOUT[CLI]' 
Sep 17 20:19:14 tilly NetworkManager: <WARN>  supplicant_cleanup(): supplicant_cleanup - couldn't terminate wpasupplicant cleanly. 
Sep 17 20:19:16 tilly NetworkManager: <WARN>  nm_device_802_11_wireless_get_mode(): error getting card mode on eth1: No such device 
Sep 17 20:19:16 tilly NetworkManager: <info>  Device eth1 activation scheduled... 
Sep 17 20:19:16 tilly NetworkManager: <debug> [1190056756.468285] nm_hal_device_removed(): Device removed (hal udi is '/org/freedesktop/Hal/devices/net_00_1c_10_11_5a_53'). 
Sep 17 20:19:16 tilly NetworkManager: <info>  Deactivating device eth1. 
Sep 17 20:19:17 tilly NetworkManager: <WARN>  nm_device_802_11_wireless_get_mode(): error getting card mode on eth1: No such device 
Sep 17 20:19:17 tilly NetworkManager: <debug> [1190056757.483675] nm_hal_device_removed(): Device removed (hal udi is '/org/freedesktop/Hal/devices/pci_14e4_4318'). 
Sep 17 20:19:17 tilly NetworkManager: <info>  User request to disable wireless. 
Sep 17 20:19:17 tilly NetworkManager: <info>  Activation (eth1) started... 
Sep 17 20:19:17 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) scheduled... 
Sep 17 20:19:24 tilly kernel: [  158.623219] pccard: CardBus card inserted into slot 0
Sep 17 20:19:24 tilly kernel: [  158.624465] PCI: Enabling device 0000:02:00.0 (0000 -> 0002)
Sep 17 20:19:24 tilly kernel: [  158.625223] ACPI: PCI Interrupt 0000:02:00.0[A] -> Link [LNKA] -> GSI 10 (level, low) -> IRQ 10
Sep 17 20:19:24 tilly kernel: [  158.625261] PCI: Setting latency timer of device 0000:02:00.0 to 64
Sep 17 20:19:24 tilly NetworkManager: <debug> [1190056764.645110] nm_hal_device_added(): New device added (hal udi is '/org/freedesktop/Hal/devices/pci_14e4_4318'). 
Sep 17 20:19:24 tilly NetworkManager: <debug> [1190056764.718135] nm_hal_device_added(): New device added (hal udi is '/org/freedesktop/Hal/devices/net_00_1c_10_11_5a_53'). 
Sep 17 20:19:25 tilly kernel: [  159.286209] ADDRCONF(NETDEV_UP): eth1: link is not ready
Sep 17 20:19:25 tilly NetworkManager: <info>  eth1: Device is fully-supported using driver 'bcm43xx'. 
Sep 17 20:19:25 tilly NetworkManager: <info>  nm_device_init(): waiting for device's worker thread to start 
Sep 17 20:19:25 tilly NetworkManager: <info>  nm_device_init(): device's worker thread started, continuing. 
Sep 17 20:19:25 tilly NetworkManager: <info>  Now managing wireless (802.11) device 'eth1'. 
Sep 17 20:19:25 tilly NetworkManager: <info>  Deactivating device eth1. 
Sep 17 20:19:25 tilly kernel: [  159.611548] SoftMAC: Open Authentication completed with 00:18:84:11:78:d5
Sep 17 20:19:25 tilly kernel: [  159.625887] ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready
Sep 17 20:19:27 tilly avahi-daemon[4797]: Registering new address record for fe80::21c:10ff:fe11:5a53 on eth1.*.
Sep 17 20:19:36 tilly kernel: [  164.541817] eth1: no IPv6 routers present
Sep 17 20:19:39 tilly NetworkManager: <info>  User request to enable wireless. 
Sep 17 20:19:39 tilly NetworkManager: <info>  SWITCH: no current connection, found better connection 'eth1'. 
Sep 17 20:19:39 tilly NetworkManager: <info>  Will activate connection 'eth1/TEST'. 
Sep 17 20:19:39 tilly NetworkManager: <info>  Device eth1 activation scheduled... 
Sep 17 20:19:39 tilly NetworkManager: <info>  Activation (eth1) started... 
Sep 17 20:19:39 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) scheduled... 
Sep 17 20:19:39 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) started... 
Sep 17 20:19:39 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) scheduled... 
Sep 17 20:19:39 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) complete. 
Sep 17 20:19:39 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) starting... 
Sep 17 20:19:39 tilly NetworkManager: <info>  Activation (eth1/wireless): access point 'TEST' is encrypted, but NO valid key exists.  New key needed. 
Sep 17 20:19:39 tilly NetworkManager: <info>  Activation (eth1) New wireless user key requested for network 'TEST'. 
Sep 17 20:19:39 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) complete. 
Sep 17 20:19:45 tilly NetworkManager: <info>  Activation (eth1) New wireless user key for network 'TEST' received. 
Sep 17 20:19:45 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) scheduled... 
Sep 17 20:19:45 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) started... 
Sep 17 20:19:45 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) scheduled... 
Sep 17 20:19:45 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) complete. 
Sep 17 20:19:45 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) starting... 
Sep 17 20:19:45 tilly NetworkManager: <info>  Activation (eth1/wireless): access point 'TEST' is encrypted, and a key exists.  No new key needed. 
Sep 17 20:19:46 tilly NetworkManager: <info>  supplicant_interface_init() - connect to global ctrl socket (0/10). 
Sep 17 20:19:46 tilly NetworkManager: <info>  supplicant_interface_init() - connect to global ctrl socket (1/10). 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: sending command 'INTERFACE_ADD eth1^I^Iwext^I/var/run/wpa_supplicant3^I' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:19:46 tilly NetworkManager: <info>  supplicant_init() - connect to device ctrl socket (3/10). 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: sending command 'AP_SCAN 1' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: sending command 'ADD_NETWORK' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: response was '0' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: sending command 'SET_NETWORK 0 ssid 474156' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: sending command 'SET_NETWORK 0 proto WPA' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: sending command 'SET_NETWORK 0 key_mgmt WPA-PSK' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: sending command 'SET_NETWORK 0 psk <key>' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: sending command 'ENABLE_NETWORK 0' 
Sep 17 20:19:46 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:19:46 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) complete. 
Sep 17 20:19:52 tilly NetworkManager: <info>  Old device 'eth1' activating, won't change. 
Sep 17 20:20:23 tilly last message repeated 3 times
Sep 17 20:20:44 tilly last message repeated 2 times
Sep 17 20:20:46 tilly NetworkManager: <info>  Activation (eth1/wireless): association took too long (>60s), failing activation. 
Sep 17 20:20:46 tilly NetworkManager: <info>  Activation (eth1) failure scheduled... 
Sep 17 20:20:46 tilly NetworkManager: <info>  Activation (eth1) failed for access point (TEST) 
Sep 17 20:20:46 tilly NetworkManager: <info>  Activation (eth1) failed. 
Sep 17 20:20:46 tilly NetworkManager: <info>  Deactivating device eth1. 
Sep 17 20:20:46 tilly NetworkManager: <info>  SUP: sending command 'DISABLE_NETWORK 0' 
Sep 17 20:20:47 tilly kernel: [  194.295258] SoftMAC: Authentication timed out with 00:18:84:11:78:d6
Sep 17 20:20:50 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:20:50 tilly NetworkManager: <info>  SUP: sending command 'AP_SCAN 0' 
Sep 17 20:20:55 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:20:55 tilly NetworkManager: <info>  SUP: sending command 'TERMINATE' 
Sep 17 20:20:56 tilly avahi-daemon[4797]: Withdrawing address record for fe80::21c:10ff:fe11:5a53 on eth1.
Sep 17 20:20:58 tilly kernel: [  195.992783] ADDRCONF(NETDEV_UP): eth1: link is not ready
Sep 17 20:20:58 tilly NetworkManager: <WARN>  nm_utils_supplicant_request_with_check(): nm_device_802_11_wireless_scan: supplicant error for 'SCAN'.  Response: '$' 
Sep 17 20:20:58 tilly NetworkManager: <WARN>  nm_device_802_11_wireless_scan(): could not trigger wireless scan on device eth1: Connection refused 
Sep 17 20:20:59 tilly NetworkManager: <WARN>  nm_utils_supplicant_request_with_check(): nm_device_802_11_wireless_scan: supplicant error for 'SCAN'.  Response: '$' 
Sep 17 20:20:59 tilly NetworkManager: <WARN>  nm_device_802_11_wireless_scan(): could not trigger wireless scan on device eth1: Transport endpoint is not connected 
Sep 17 20:21:07 tilly NetworkManager: <info>  SUP: response was 'TIMEOUT[CLI]' 
Sep 17 20:21:07 tilly NetworkManager: <WARN>  nm_utils_supplicant_request_with_check(): supplicant_cleanup: supplicant error for 'TERMINATE'.  Response: 'TIMEOUT[CLI]' 
Sep 17 20:21:07 tilly NetworkManager: <WARN>  supplicant_cleanup(): supplicant_cleanup - couldn't terminate wpasupplicant cleanly. 
Sep 17 20:21:07 tilly NetworkManager: <info>  SWITCH: no current connection, found better connection 'eth1'. 
Sep 17 20:21:07 tilly NetworkManager: <info>  Will activate connection 'eth1/FON_TEST'. 
Sep 17 20:21:07 tilly NetworkManager: <info>  Device eth1 activation scheduled... 
Sep 17 20:21:07 tilly NetworkManager: <info>  Activation (eth1) started... 
Sep 17 20:21:07 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) scheduled... 
Sep 17 20:21:07 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) started... 
Sep 17 20:21:07 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) scheduled... 
Sep 17 20:21:07 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) complete. 
Sep 17 20:21:07 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) starting... 
Sep 17 20:21:07 tilly NetworkManager: <info>  Activation (eth1/wireless): access point 'FON_TEST' is unencrypted, no key needed. 
Sep 17 20:21:07 tilly kernel: [  197.103896] SoftMAC: Open Authentication completed with 00:18:84:11:78:d5
Sep 17 20:21:07 tilly kernel: [  197.114962] ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready
Sep 17 20:21:08 tilly NetworkManager: <info>  supplicant_interface_init() - connect to global ctrl socket (0/10). 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: sending command 'INTERFACE_ADD eth1^I^Iwext^I/var/run/wpa_supplicant5^I' 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:21:08 tilly NetworkManager: <info>  supplicant_init() - connect to device ctrl socket (2/10). 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: sending command 'AP_SCAN 1' 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: sending command 'ADD_NETWORK' 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: response was '0' 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: sending command 'SET_NETWORK 0 ssid 464f4e5f474156' 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: sending command 'SET_NETWORK 0 key_mgmt NONE' 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: sending command 'ENABLE_NETWORK 0' 
Sep 17 20:21:08 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:21:08 tilly NetworkManager: <info>  Activation (eth1) Stage 2 of 5 (Device Configure) complete. 
Sep 17 20:21:09 tilly avahi-daemon[4797]: Registering new address record for fe80::21c:10ff:fe11:5a53 on eth1.*.
Sep 17 20:21:12 tilly NetworkManager: <info>  Old device 'eth1' activating, won't change. 
Sep 17 20:21:18 tilly kernel: [  198.441579] eth1: no IPv6 routers present
Sep 17 20:21:24 tilly NetworkManager: <info>  Old device 'eth1' activating, won't change. 
Sep 17 20:21:55 tilly last message repeated 3 times
Sep 17 20:22:05 tilly NetworkManager: <info>  Old device 'eth1' activating, won't change. 
Sep 17 20:22:08 tilly NetworkManager: <info>  Activation (eth1/wireless): association took too long (>60s), failing activation. 
Sep 17 20:22:08 tilly NetworkManager: <info>  Activation (eth1) failure scheduled... 
Sep 17 20:22:08 tilly NetworkManager: <info>  Activation (eth1) failed for access point (FON_TEST) 
Sep 17 20:22:08 tilly NetworkManager: <info>  Activation (eth1) failed. 
Sep 17 20:22:08 tilly NetworkManager: <info>  Deactivating device eth1. 
Sep 17 20:22:08 tilly NetworkManager: <info>  SUP: sending command 'DISABLE_NETWORK 0' 
Sep 17 20:22:14 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:22:14 tilly NetworkManager: <info>  SUP: sending command 'AP_SCAN 0' 
Sep 17 20:22:15 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:22:15 tilly NetworkManager: <info>  SUP: sending command 'TERMINATE' 
Sep 17 20:22:15 tilly NetworkManager: <info>  SUP: response was 'OK' 
Sep 17 20:22:15 tilly avahi-daemon[4797]: Withdrawing address record for fe80::21c:10ff:fe11:5a53 on eth1.
Sep 17 20:22:15 tilly kernel: [  202.623088] SoftMAC: Open Authentication completed with 00:18:84:11:78:d5
Sep 17 20:22:15 tilly kernel: [  202.633574] ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready
Sep 17 20:22:24 tilly NetworkManager: <debug> [1190056944.585952] nm_device_802_11_wireless_get_activation_ap(): Forcing AP 'TEST' 
Sep 17 20:22:24 tilly NetworkManager: <info>  User Switch: /org/freedesktop/NetworkManager/Devices/eth1 / TEST 
Sep 17 20:22:24 tilly NetworkManager: <info>  Deactivating device eth1. 
Sep 17 20:22:24 tilly NetworkManager: <info>  Device eth1 activation scheduled... 
Sep 17 20:22:24 tilly NetworkManager: <info>  Activation (eth1) started... 
Sep 17 20:22:24 tilly NetworkManager: <info>  Activation (eth1) Stage 1 of 5 (Device Prepare) scheduled... 
Sep 17 20:22:25 tilly kernel: [  203.519055] ADDRCONF(NETDEV_UP): eth1: link is not ready
Sep 17 20:22:27 tilly NetworkManager: <WARN>  nm_signal_handler(): Caught signal 11.  Generating backtrace... 
Sep 17 20:22:27 tilly NetworkManager: ******************* START **********************************
Sep 17 20:22:27 tilly NetworkManager: (no debugging symbols found)
Sep 17 20:22:28 tilly NetworkManager: Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
Sep 17 20:22:28 tilly NetworkManager: (no debugging symbols found)
Sep 17 20:22:28 tilly last message repeated 13 times
Sep 17 20:22:28 tilly NetworkManager: [Thread debugging using libthread_db enabled]
Sep 17 20:22:28 tilly NetworkManager: [New Thread -1212696912 (LWP 4417)]
Sep 17 20:22:28 tilly NetworkManager: [New Thread -1221092464 (LWP 5534)]
Sep 17 20:22:28 tilly NetworkManager: [New Thread -1229485168 (LWP 5267)]
Sep 17 20:22:28 tilly NetworkManager: [New Thread -1212699760 (LWP 4531)]
Sep 17 20:22:28 tilly NetworkManager: (no debugging symbols found)
Sep 17 20:22:28 tilly last message repeated 3 times
Sep 17 20:22:28 tilly NetworkManager: 0xffffe410 in __kernel_vsyscall ()
Sep 17 20:22:28 tilly NetworkManager: ******************* END **********************************




From linville at tuxdriver.com  Tue Sep 18 01:27:01 2007
From: linville at tuxdriver.com (John W. Linville)
Date: Mon, 17 Sep 2007 19:27:01 -0400
Subject: Machine Check on Fedora rawhide kernel.
In-Reply-To: <1190060337.9286.0.camel@shinybook.infradead.org>
References: <1189580462.3570.5.camel@shinybook.infradead.org>
	<1189802714.4460.5.camel@shinybook.infradead.org>
	<46EAFAE8.5010003@lwfinger.net> <200709142333.42390.mb@bu3sch.de>
	<1190060337.9286.0.camel@shinybook.infradead.org>
Message-ID: <20070917232701.GH9282@tuxdriver.com>

On Mon, Sep 17, 2007 at 09:18:57PM +0100, David Woodhouse wrote:
> On Fri, 2007-09-14 at 23:33 +0200, Michael Buesch wrote:
> > These are all false positives, except this one, where the wrong
> > converter function was used.
> > 
> > @@ -442,7 +444,7 @@ void b43legacy_rx(struct b43legacy_wldev
> >         phystat0 = le16_to_cpu(rxhdr->phy_status0);
> >         phystat3 = le16_to_cpu(rxhdr->phy_status3);
> >         jssi = rxhdr->jssi;
> > -       macstat = le32_to_cpu(rxhdr->mac_status);
> > +       macstat = le16_to_cpu(rxhdr->mac_status);
> >         mactime = le16_to_cpu(rxhdr->mac_time);
> >         chanstat = le16_to_cpu(rxhdr->channel); 
> 
> Did this one get committed yet?

Working on it now...

-- 
John W. Linville
linville at tuxdriver.com


From larry.finger at lwfinger.net  Tue Sep 18 05:25:15 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 17 Sep 2007 22:25:15 -0500
Subject: [AirForce One 54g] working
In-Reply-To: <20070917204526.GA17766@gmail.com>
References: <20070916214502.GA21484@gmail.com>
	<20070917204526.GA17766@gmail.com>
Message-ID: <46EF451B.5090701@lwfinger.net>

Gavin McCullagh wrote:
> Hi,
>  
> a few more details.
> 
> On Sun, 16 Sep 2007, Gavin McCullagh wrote:
> 
>> I have a linksys WPC54GS pcmcia wifi card.  lspci details below.  I tried
>> it with the latest firmware and Ubuntu gutsy's 2.6.22-10-generic and
>> 2.6.22-11-generic kernels.  
> 
>> I went onto the IRC channel and noted the suggestion that I try the
>> wireless-dev tree (2.6.23-rc4).  So I did and I'm glad to say successfully.
>> I'm using it now and have been for the past 6-8 hours on and off without
>> any reboot or problems.  
> 
> A little more feedback on my experiences with this driver.
> 
> The first time I booted up, logged in (to gnome) and then popped in the
> pcmcia card.  The key manager prompted for password to unlock it and I got
> straight onto the WPA wifi network (192.168.10.0/24).  This worked fine and
> continues to.
> 
> Later I tried to boot up with the card in.  I logged in and network-manager
> connected to an unencrypted network (192.168.182.0/24).  Not wanting that,
> I clicked on the network manager and selected the WPA network.  Nothing
> much happened, according to the applet and the ip address and essid didn't
> change according to iwconfig/ifconfig.  Eventually the applet disappeared
> and restarting it didn't work.  In syslog, it showed that NetworkManager
> had crashed.   A full log is below.  
> 
> It seems there is a problem switching network but as long as I start it on 
> the WPA one, all is fine.  I realise this driver is still experimental so
> perhaps this behaviour is normal and as I know how to make it work reliably
> it's okay.  However, if you need more information let me know.  It seems
> pretty reproducible.

As far as I can tell, this is a NetworkManager problem. I have two APs, one with WPA and one with
WEP encryption so that I can test in either mode without affecting my wife's connection. With
NetworkManager 0.6.4, I found that if I wanted to switch networks, I had to "try" to connect to a
third network, which could be another encrypted wireless or my wired interface. Once that was done,
then I could connect to the other wireless network. Now I have upgraded to NM 0.6.5 and I can switch
wireless connections directly. I don't know which version of NM is in Gutsy, but I'm willing to bet
that it is 0.6.4.

Larry





From johannes at sipsolutions.net  Tue Sep 18 12:18:18 2007
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 18 Sep 2007 12:18:18 +0200
Subject: [AirForce One 54g] working
In-Reply-To: <46EF451B.5090701@lwfinger.net>
References: <20070916214502.GA21484@gmail.com>
	<20070917204526.GA17766@gmail.com>  <46EF451B.5090701@lwfinger.net>
Message-ID: <1190110698.23521.38.camel@johannes.berg>

On Mon, 2007-09-17 at 22:25 -0500, Larry Finger wrote:

> As far as I can tell, this is a NetworkManager problem. I have two APs, one with WPA and one with
> WEP encryption so that I can test in either mode without affecting my wife's connection. With
> NetworkManager 0.6.4, I found that if I wanted to switch networks, I had to "try" to connect to a
> third network, which could be another encrypted wireless or my wired interface. Once that was done,
> then I could connect to the other wireless network. Now I have upgraded to NM 0.6.5 and I can switch
> wireless connections directly. I don't know which version of NM is in Gutsy, but I'm willing to bet
> that it is 0.6.4.

I see similar behaviour to what you describe with 0.6.4 with 0.6.5 in
Debian. I'm willing to bet that there's also the wpa_supplicant version
number involved.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 190 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070918/5f130fa7/attachment.pgp>

From larry.finger at lwfinger.net  Tue Sep 18 16:22:26 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 18 Sep 2007 09:22:26 -0500
Subject: [AirForce One 54g] working
In-Reply-To: <1190110698.23521.38.camel@johannes.berg>
References: <20070916214502.GA21484@gmail.com>	
	<20070917204526.GA17766@gmail.com> <46EF451B.5090701@lwfinger.net>
	<1190110698.23521.38.camel@johannes.berg>
Message-ID: <46EFDF22.9080906@lwfinger.net>

Johannes Berg wrote:
> On Mon, 2007-09-17 at 22:25 -0500, Larry Finger wrote:
> 
>> As far as I can tell, this is a NetworkManager problem. I have two APs, one with WPA and one with
>> WEP encryption so that I can test in either mode without affecting my wife's connection. With
>> NetworkManager 0.6.4, I found that if I wanted to switch networks, I had to "try" to connect to a
>> third network, which could be another encrypted wireless or my wired interface. Once that was done,
>> then I could connect to the other wireless network. Now I have upgraded to NM 0.6.5 and I can switch
>> wireless connections directly. I don't know which version of NM is in Gutsy, but I'm willing to bet
>> that it is 0.6.4.
> 
> I see similar behaviour to what you describe with 0.6.4 with 0.6.5 in
> Debian. I'm willing to bet that there's also the wpa_supplicant version
> number involved.

That could be. I'm running wpa_supplicant 0.5.8. When the problem was happening, I noticed what
appeared to be a timing or sequencing error. NM would attempt to scan with the interface down, which
can be detected on my system as the radio LED is off. That doesn't happen now.

Larry


From Larry.Finger at lwfinger.net  Tue Sep 18 17:38:29 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 18 Sep 2007 10:38:29 -0500
Subject: [PATCH] b43legacy: Fix sparse warnings (part 2)
Message-ID: <46eff0f5.pWVUYEYGrM5PdY9K%Larry.Finger@lwfinger.net>

There are additional sparse warnings in b43legacy. None of them result
in program errors, but are fixed for completeness.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

 drivers/net/wireless/b43legacy/debugfs.c |   14 +++++++-------
 drivers/net/wireless/b43legacy/pio.c     |    6 +++---
 2 files changed, 10 insertions(+), 10 deletions(-)

Index: wireless-dev/drivers/net/wireless/b43legacy/debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/debugfs.c
+++ wireless-dev/drivers/net/wireless/b43legacy/debugfs.c
@@ -39,7 +39,7 @@
 
 
 /* The root directory. */
-struct dentry *rootdir;
+static struct dentry *rootdir;
 
 struct b43legacy_debugfs_fops {
 	ssize_t (*read)(struct b43legacy_wldev *dev, char *buf, size_t bufsize);
@@ -76,7 +76,7 @@ struct b43legacy_dfs_file * fops_to_dfs_
 
 
 /* wl->irq_lock is locked */
-ssize_t tsf_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
+static ssize_t tsf_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 	u64 tsf;
@@ -90,7 +90,7 @@ ssize_t tsf_read_file(struct b43legacy_w
 }
 
 /* wl->irq_lock is locked */
-int tsf_write_file(struct b43legacy_wldev *dev, const char *buf, size_t count)
+static int tsf_write_file(struct b43legacy_wldev *dev, const char *buf, size_t count)
 {
 	u64 tsf;
 
@@ -102,7 +102,7 @@ int tsf_write_file(struct b43legacy_wlde
 }
 
 /* wl->irq_lock is locked */
-ssize_t ucode_regs_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
+static ssize_t ucode_regs_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 	int i;
@@ -116,7 +116,7 @@ ssize_t ucode_regs_read_file(struct b43l
 }
 
 /* wl->irq_lock is locked */
-ssize_t shm_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
+static ssize_t shm_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 	int i;
@@ -135,7 +135,7 @@ ssize_t shm_read_file(struct b43legacy_w
 	return count;
 }
 
-ssize_t txstat_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
+static ssize_t txstat_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)
 {
 	struct b43legacy_txstatus_log *log = &dev->dfsentry->txstatlog;
 	ssize_t count = 0;
@@ -183,7 +183,7 @@ out_unlock:
 }
 
 /* wl->irq_lock is locked */
-int restart_write_file(struct b43legacy_wldev *dev, const char *buf, size_t count)
+static int restart_write_file(struct b43legacy_wldev *dev, const char *buf, size_t count)
 {
 	int err = 0;
 
Index: wireless-dev/drivers/net/wireless/b43legacy/pio.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/pio.c
+++ wireless-dev/drivers/net/wireless/b43legacy/pio.c
@@ -66,7 +66,7 @@ static u16 tx_get_next_word(const u8 *tx
 		source = packet;
 		i -= txhdr_size;
 	}
-	ret = le16_to_cpu(*((u16 *)(source + i)));
+	ret = le16_to_cpu(*((__le16 *)(source + i)));
 	*pos += 2;
 
 	return ret;
@@ -539,7 +539,7 @@ static void pio_rx_error(struct b43legac
 
 void b43legacy_pio_rx(struct b43legacy_pioqueue *queue)
 {
-	u16 preamble[21] = { 0 };
+	__le16 preamble[21] = { 0 };
 	struct b43legacy_rxhdr_fw3 *rxhdr;
 	u16 tmp;
 	u16 len;
@@ -609,7 +609,7 @@ data_ready:
 	skb_put(skb, len);
 	for (i = 0; i < len - 1; i += 2) {
 		tmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);
-		*((u16 *)(skb->data + i)) = cpu_to_le16(tmp);
+		*((__le16 *)(skb->data + i)) = cpu_to_le16(tmp);
 	}
 	if (len % 2) {
 		tmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);


From mouw at nl.linux.org  Tue Sep 18 18:47:22 2007
From: mouw at nl.linux.org (Erik Mouw)
Date: Tue, 18 Sep 2007 18:47:22 +0200
Subject: [AirForce One 54g] working
In-Reply-To: <20070916214502.GA21484@gmail.com>
References: <20070916214502.GA21484@gmail.com>
Message-ID: <20070918164722.GC2630@gateway.home>

On Sun, Sep 16, 2007 at 10:45:02PM +0100, Gavin McCullagh wrote:

[success story]

> A couple of things worth mentioning.  

[...]

> 2. The quoted signal strength is 50% even when I have the AP and card right
>    next to each other.  It doesn't bother me, but I wonder if it's correct
>    or not.

Yeah, I see the same with the standard 2.6.22/2.6.23-rc4 driver. Signal
strength never goes above 50% with NetworkManager, though other tools
like the Gnome network interface monitor show 100%. I guess it's a
NetworkManager bug.

> gavinmc at tilly:~$ lspci -v -s 02:00.0
> 02:00.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 54g]
> 802.11g Wireless LAN Controller (rev 02)
>         Subsystem: Linksys Unknown device 0049
>         Flags: bus master, fast devsel, latency 64, IRQ 10
>         Memory at 24000000 (32-bit, non-prefetchable) [size=8K]

Looks like the cardbus card I use. Can't check it though, I left my
laptop at home :(


Erik

-- 
They're all fools. Don't worry. Darwin may be slow, but he'll
eventually get them. -- Matthew Lammers in alt.sysadmin.recovery
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070918/d04949cb/attachment.pgp>

From Larry.Finger at lwfinger.net  Wed Sep 19 05:00:52 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Tue, 18 Sep 2007 22:00:52 -0500
Subject: [PATCH] softmac: Fix inability to associate with WEP networks,
	and the inability to change essid
Message-ID: <46f090e4.wi04CrQ11sG6gLcC%Larry.Finger@lwfinger.net>

Commit 4cf92a3c was submitted as a fix for bug #8686 at bugzilla.kernel.org
(http://bugzilla.kernel.org/show_bug.cgi?id=8686). Unfortunately, the fix led to
a new bug, reported by Yoshifuji Hideaki, that prevented association for WEP
encrypted networks that use ifconfig to control the device. This patch effectively
reverts the earlier commit and does a proper fix for bug #8686.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

John,

This fix replaces my earlier request for reversion of commit 4cf92a3c. As stated
above, it effectively does the reversion, but it also fixes the original bug.

Larry
---

 net/ieee80211/softmac/ieee80211softmac_assoc.c |    2
 net/ieee80211/softmac/ieee80211softmac_wx.c    |   54 +++++++++----------------
 2 files changed, 20 insertions(+), 36 deletions(-)

Index: linux-2.6/net/ieee80211/softmac/ieee80211softmac_assoc.c
===================================================================
--- linux-2.6.orig/net/ieee80211/softmac/ieee80211softmac_assoc.c
+++ linux-2.6/net/ieee80211/softmac/ieee80211softmac_assoc.c
@@ -273,8 +273,6 @@ ieee80211softmac_assoc_work(struct work_
 			ieee80211softmac_notify(mac->dev, IEEE80211SOFTMAC_EVENT_SCAN_FINISHED, ieee80211softmac_assoc_notify_scan, NULL);
 			if (ieee80211softmac_start_scan(mac)) {
 				dprintk(KERN_INFO PFX "Associate: failed to initiate scan. Is device up?\n");
-				mac->associnfo.associating = 0;
-				mac->associnfo.associated = 0;
 			}
 			goto out;
 		} else {
Index: linux-2.6/net/ieee80211/softmac/ieee80211softmac_wx.c
===================================================================
--- linux-2.6.orig/net/ieee80211/softmac/ieee80211softmac_wx.c
+++ linux-2.6/net/ieee80211/softmac/ieee80211softmac_wx.c
@@ -70,44 +70,30 @@ ieee80211softmac_wx_set_essid(struct net
 			      char *extra)
 {
 	struct ieee80211softmac_device *sm = ieee80211_priv(net_dev);
-	struct ieee80211softmac_network *n;
 	struct ieee80211softmac_auth_queue_item *authptr;
 	int length = 0;
 
 check_assoc_again:
 	mutex_lock(&sm->associnfo.mutex);
-	/* Check if we're already associating to this or another network
-	 * If it's another network, cancel and start over with our new network
-	 * If it's our network, ignore the change, we're already doing it!
-	 */
 	if((sm->associnfo.associating || sm->associnfo.associated) &&
 	   (data->essid.flags && data->essid.length)) {
-		/* Get the associating network */
-		n = ieee80211softmac_get_network_by_bssid(sm, sm->associnfo.bssid);
-		if(n && n->essid.len == data->essid.length &&
-		   !memcmp(n->essid.data, extra, n->essid.len)) {
-			dprintk(KERN_INFO PFX "Already associating or associated to "MAC_FMT"\n",
-				MAC_ARG(sm->associnfo.bssid));
-			goto out;
-		} else {
-			dprintk(KERN_INFO PFX "Canceling existing associate request!\n");
-			/* Cancel assoc work */
-			cancel_delayed_work(&sm->associnfo.work);
-			/* We don't have to do this, but it's a little cleaner */
-			list_for_each_entry(authptr, &sm->auth_queue, list)
-				cancel_delayed_work(&authptr->work);
-			sm->associnfo.bssvalid = 0;
-			sm->associnfo.bssfixed = 0;
-			sm->associnfo.associating = 0;
-			sm->associnfo.associated = 0;
-			/* We must unlock to avoid deadlocks with the assoc workqueue
-			 * on the associnfo.mutex */
-			mutex_unlock(&sm->associnfo.mutex);
-			flush_scheduled_work();
-			/* Avoid race! Check assoc status again. Maybe someone started an
-			 * association while we flushed. */
-			goto check_assoc_again;
-		}
+		dprintk(KERN_INFO PFX "Canceling existing associate request!\n");
+		/* Cancel assoc work */
+		cancel_delayed_work(&sm->associnfo.work);
+		/* We don't have to do this, but it's a little cleaner */
+		list_for_each_entry(authptr, &sm->auth_queue, list)
+			cancel_delayed_work(&authptr->work);
+		sm->associnfo.bssvalid = 0;
+		sm->associnfo.bssfixed = 0;
+		sm->associnfo.associating = 0;
+		sm->associnfo.associated = 0;
+		/* We must unlock to avoid deadlocks with the assoc workqueue
+		 * on the associnfo.mutex */
+		mutex_unlock(&sm->associnfo.mutex);
+		flush_scheduled_work();
+		/* Avoid race! Check assoc status again. Maybe someone started an
+		 * association while we flushed. */
+		goto check_assoc_again;
 	}
 
 	sm->associnfo.static_essid = 0;
@@ -153,13 +139,13 @@ ieee80211softmac_wx_get_essid(struct net
 		data->essid.length = sm->associnfo.req_essid.len;
 		data->essid.flags = 1;  /* active */
 		memcpy(extra, sm->associnfo.req_essid.data, sm->associnfo.req_essid.len);
-	}
-
+		dprintk(KERN_INFO PFX "Getting essid from req_essid\n");
+	} else if (sm->associnfo.associated || sm->associnfo.associating) {
 	/* If we're associating/associated, return that */
-	if (sm->associnfo.associated || sm->associnfo.associating) {
 		data->essid.length = sm->associnfo.associate_essid.len;
 		data->essid.flags = 1;  /* active */
 		memcpy(extra, sm->associnfo.associate_essid.data, sm->associnfo.associate_essid.len);
+		dprintk(KERN_INFO PFX "Getting essid from associate_essid\n");
 	}
 	mutex_unlock(&sm->associnfo.mutex);
 


From mb at bu3sch.de  Wed Sep 19 15:48:20 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 19 Sep 2007 15:48:20 +0200
Subject: [PATCH] softmac: Fix inability to associate with WEP networks,
	and the inability to change essid
In-Reply-To: <46f090e4.wi04CrQ11sG6gLcC%Larry.Finger@lwfinger.net>
References: <46f090e4.wi04CrQ11sG6gLcC%Larry.Finger@lwfinger.net>
Message-ID: <200709191548.20528.mb@bu3sch.de>

On Wednesday 19 September 2007 05:00:52 Larry Finger wrote:
> Commit 4cf92a3c was submitted as a fix for bug #8686 at bugzilla.kernel.org
> (http://bugzilla.kernel.org/show_bug.cgi?id=8686). Unfortunately, the fix led to
> a new bug, reported by Yoshifuji Hideaki, that prevented association for WEP
> encrypted networks that use ifconfig to control the device. This patch effectively
> reverts the earlier commit and does a proper fix for bug #8686.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
> ---
> 
> John,
> 
> This fix replaces my earlier request for reversion of commit 4cf92a3c. As stated
> above, it effectively does the reversion, but it also fixes the original bug.

Looks good and might be OK. Though, I won't ack this, as I don't really
understand the statemachine. So if it works and fixes both bugs, please merge
this into mainline and (more important) into -stable.

-- 
Greetings Michael.


From mb at bu3sch.de  Wed Sep 19 18:30:30 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 19 Sep 2007 18:30:30 +0200
Subject: [PATCH] b43: Fix sparse warnings.
Message-ID: <200709191830.30726.mb@bu3sch.de>

The remaining warning in phy.c will be fixed later.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-dev/drivers/net/wireless/b43/pio.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/pio.c	2007-09-19 17:49:20.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/pio.c	2007-09-19 17:50:26.000000000 +0200
@@ -60,7 +60,7 @@ static u16 tx_get_next_word(const u8 * t
 		source = packet;
 		i -= txhdr_size;
 	}
-	ret = le16_to_cpu(*((u16 *) (source + i)));
+	ret = le16_to_cpu(*((__le16 *)(source + i)));
 	*pos += 2;
 
 	return ret;
@@ -104,7 +104,7 @@ static u16 generate_cookie(struct b43_pi
 			   struct b43_pio_txpacket *packet)
 {
 	u16 cookie = 0x0000;
-	int packetindex;
+	u16 packetindex;
 
 	/* We use the upper 4 bits for the PIO
 	 * controller ID and the lower 12 bits
@@ -125,7 +125,7 @@ static u16 generate_cookie(struct b43_pi
 	default:
 		B43_WARN_ON(1);
 	}
-	packetindex = pio_txpacket_getindex(packet);
+	packetindex = packet->index;
 	B43_WARN_ON(packetindex & ~0x0FFF);
 	cookie |= (u16) packetindex;
 
@@ -286,6 +286,7 @@ static void setup_txqueues(struct b43_pi
 
 		packet->queue = queue;
 		INIT_LIST_HEAD(&packet->list);
+		packet->index = i;
 
 		list_add(&packet->list, &queue->txfree);
 	}
@@ -518,9 +519,10 @@ static void pio_rx_error(struct b43_pioq
 
 void b43_pio_rx(struct b43_pioqueue *queue)
 {
-	u16 preamble[21] = { 0 };
+	__le16 preamble[21] = { 0 };
 	struct b43_rxhdr_fw4 *rxhdr;
-	u16 tmp, len, macstat;
+	u16 tmp, len;
+	u32 macstat;
 	int i, preamble_readwords;
 	struct sk_buff *skb;
 
@@ -537,7 +539,7 @@ void b43_pio_rx(struct b43_pioqueue *que
 	}
 	b43dbg(queue->dev->wl, "PIO RX timed out\n");
 	return;
-      data_ready:
+data_ready:
 
 	len = b43_pio_read(queue, B43_PIO_RXDATA);
 	if (unlikely(len > 0x700)) {
@@ -558,7 +560,7 @@ void b43_pio_rx(struct b43_pioqueue *que
 		preamble[i + 1] = cpu_to_le16(tmp);
 	}
 	rxhdr = (struct b43_rxhdr_fw4 *)preamble;
-	macstat = le16_to_cpu(rxhdr->mac_status);
+	macstat = le32_to_cpu(rxhdr->mac_status);
 	if (macstat & B43_RX_MAC_FCSERR) {
 		pio_rx_error(queue,
 			     (queue->mmio_base == B43_MMIO_PIO1_BASE),
@@ -583,7 +585,7 @@ void b43_pio_rx(struct b43_pioqueue *que
 	skb_put(skb, len);
 	for (i = 0; i < len - 1; i += 2) {
 		tmp = b43_pio_read(queue, B43_PIO_RXDATA);
-		*((u16 *) (skb->data + i)) = cpu_to_le16(tmp);
+		*((__le16 *)(skb->data + i)) = cpu_to_le16(tmp);
 	}
 	if (len % 2) {
 		tmp = b43_pio_read(queue, B43_PIO_RXDATA);
Index: wireless-dev/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/xmit.c	2007-09-19 17:49:20.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/xmit.c	2007-09-19 17:50:26.000000000 +0200
@@ -121,10 +121,12 @@ void b43_generate_plcp_hdr(struct b43_pl
 	__u8 *raw = plcp->raw;
 
 	if (b43_is_ofdm_rate(bitrate)) {
-		*data = b43_plcp_get_ratecode_ofdm(bitrate);
+		u32 d;
+
+		d = b43_plcp_get_ratecode_ofdm(bitrate);
 		B43_WARN_ON(octets & 0xF000);
-		*data |= (octets << 5);
-		*data = cpu_to_le32(*data);
+		d |= (octets << 5);
+		*data = cpu_to_le32(d);
 	} else {
 		u32 plen;
 
Index: wireless-dev/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/leds.c	2007-09-19 17:49:20.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/leds.c	2007-09-19 17:50:26.000000000 +0200
@@ -32,14 +32,13 @@
 static void b43_led_changestate(struct b43_led *led)
 {
 	struct b43_wldev *dev = led->dev;
-	const int index = b43_led_index(led);
-	const u16 mask = (1 << index);
+	const int index = led->index;
 	u16 ledctl;
 
 	B43_WARN_ON(!(index >= 0 && index < B43_NR_LEDS));
 	B43_WARN_ON(!led->blink_interval);
 	ledctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);
-	ledctl = (ledctl & mask) ? (ledctl & ~mask) : (ledctl | mask);
+	ledctl ^= (1 << index);
 	b43_write16(dev, B43_MMIO_GPIO_CONTROL, ledctl);
 }
 
@@ -70,7 +69,7 @@ static void b43_led_blink_start(struct b
 static void b43_led_blink_stop(struct b43_led *led, int sync)
 {
 	struct b43_wldev *dev = led->dev;
-	const int index = b43_led_index(led);
+	const int index = led->index;
 	u16 ledctl;
 
 	if (!led->blink_interval)
@@ -139,6 +138,7 @@ int b43_leds_init(struct b43_wldev *dev)
 
 	for (i = 0; i < B43_NR_LEDS; i++) {
 		led = &(dev->leds[i]);
+		led->index = i;
 		led->dev = dev;
 		setup_timer(&led->blink_timer,
 			    b43_led_blink, (unsigned long)led);
Index: wireless-dev/drivers/net/wireless/b43/leds.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/leds.h	2007-09-19 17:49:20.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/leds.h	2007-09-19 17:50:26.000000000 +0200
@@ -5,14 +5,14 @@
 #include <linux/timer.h>
 
 struct b43_led {
-	u8 behaviour:7;
-	u8 activelow:1;
-
+	u8 behaviour;
+	bool activelow;
+	/* Index in the "leds" array in b43_wldev */
+	u8 index;
 	struct b43_wldev *dev;
 	struct timer_list blink_timer;
 	unsigned long blink_interval;
 };
-#define b43_led_index(led)	((int)((led) - (led)->dev->leds))
 
 /* Delay between state changes when blinking in jiffies */
 #define B43_LEDBLINK_SLOW		(HZ / 1)
Index: wireless-dev/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-09-19 17:49:20.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-09-19 17:50:26.000000000 +0200
@@ -1062,7 +1062,7 @@ static void handle_irq_noise(struct b43_
 	B43_WARN_ON(!dev->noisecalc.calculation_running);
 	if (dev->noisecalc.channel_at_start != phy->channel)
 		goto drop_calculation;
-	*((u32 *) noise) = cpu_to_le32(b43_jssi_read(dev));
+	*((__le32 *)noise) = cpu_to_le32(b43_jssi_read(dev));
 	if (noise[0] == 0x7F || noise[1] == 0x7F ||
 	    noise[2] == 0x7F || noise[3] == 0x7F)
 		goto generate_new;
@@ -1598,8 +1598,7 @@ static int do_request_fw(struct b43_wlde
 			 const char *name,
 			 const struct firmware **fw)
 {
-	const size_t plen = sizeof(modparam_fwpostfix) + 32;
-	char path[plen];
+	char path[sizeof(modparam_fwpostfix) + 32];
 	struct b43_fw_header *hdr;
 	u32 size;
 	int err;
Index: wireless-dev/drivers/net/wireless/b43/pcmcia.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/pcmcia.c	2007-09-19 17:49:20.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/pcmcia.c	2007-09-19 17:50:26.000000000 +0200
@@ -21,6 +21,8 @@
 
 */
 
+#include "pcmcia.h"
+
 #include <linux/ssb/ssb.h>
 
 #include <pcmcia/cs_types.h>
@@ -30,6 +32,7 @@
 #include <pcmcia/ds.h>
 #include <pcmcia/cisreg.h>
 
+
 static /*const */ struct pcmcia_device_id b43_pcmcia_tbl[] = {
 	PCMCIA_DEVICE_MANF_CARD(0x2D0, 0x448),
 	PCMCIA_DEVICE_NULL,
Index: wireless-dev/drivers/net/wireless/b43/pio.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/pio.h	2007-09-19 17:49:20.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/pio.h	2007-09-19 17:50:26.000000000 +0200
@@ -39,10 +39,9 @@ struct b43_pio_txpacket {
 	struct sk_buff *skb;
 	struct ieee80211_tx_status txstat;
 	struct list_head list;
+	u16 index; /* Index in the tx_packets_cache */
 };
 
-#define pio_txpacket_getindex(packet) ((int)((packet) - (packet)->queue->tx_packets_cache))
-
 struct b43_pioqueue {
 	struct b43_wldev *dev;
 	u16 mmio_base;
Index: wireless-dev/drivers/net/wireless/b43/debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/debugfs.c	2007-09-19 17:49:20.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/debugfs.c	2007-09-19 18:02:22.000000000 +0200
@@ -39,7 +39,7 @@
 
 
 /* The root directory. */
-struct dentry *rootdir;
+static struct dentry *rootdir;
 
 struct b43_debugfs_fops {
 	ssize_t (*read)(struct b43_wldev *dev, char *buf, size_t bufsize);
@@ -76,7 +76,8 @@ struct b43_dfs_file * fops_to_dfs_file(s
 
 
 /* wl->irq_lock is locked */
-ssize_t tsf_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t tsf_read_file(struct b43_wldev *dev,
+			     char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 	u64 tsf;
@@ -90,7 +91,8 @@ ssize_t tsf_read_file(struct b43_wldev *
 }
 
 /* wl->irq_lock is locked */
-int tsf_write_file(struct b43_wldev *dev, const char *buf, size_t count)
+static int tsf_write_file(struct b43_wldev *dev,
+			  const char *buf, size_t count)
 {
 	u64 tsf;
 
@@ -102,7 +104,8 @@ int tsf_write_file(struct b43_wldev *dev
 }
 
 /* wl->irq_lock is locked */
-ssize_t ucode_regs_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t ucode_regs_read_file(struct b43_wldev *dev,
+				    char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 	int i;
@@ -116,7 +119,8 @@ ssize_t ucode_regs_read_file(struct b43_
 }
 
 /* wl->irq_lock is locked */
-ssize_t shm_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t shm_read_file(struct b43_wldev *dev,
+			     char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 	int i;
@@ -135,7 +139,8 @@ ssize_t shm_read_file(struct b43_wldev *
 	return count;
 }
 
-ssize_t txstat_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t txstat_read_file(struct b43_wldev *dev,
+				char *buf, size_t bufsize)
 {
 	struct b43_txstatus_log *log = &dev->dfsentry->txstatlog;
 	ssize_t count = 0;
@@ -182,7 +187,8 @@ out_unlock:
 	return count;
 }
 
-ssize_t txpower_g_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t txpower_g_read_file(struct b43_wldev *dev,
+				   char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 
@@ -214,7 +220,8 @@ out:
 	return count;
 }
 
-int txpower_g_write_file(struct b43_wldev *dev, const char *buf, size_t count)
+static int txpower_g_write_file(struct b43_wldev *dev,
+				const char *buf, size_t count)
 {
 	unsigned long flags;
 	unsigned long phy_flags;
@@ -262,7 +269,8 @@ out_unlock:
 }
 
 /* wl->irq_lock is locked */
-int restart_write_file(struct b43_wldev *dev, const char *buf, size_t count)
+static int restart_write_file(struct b43_wldev *dev,
+			      const char *buf, size_t count)
 {
 	int err = 0;
 
@@ -294,7 +302,8 @@ static ssize_t append_lo_table(ssize_t c
 	return count;
 }
 
-ssize_t loctls_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t loctls_read_file(struct b43_wldev *dev,
+				char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 	struct b43_txpower_lo_control *lo;
@@ -383,6 +392,8 @@ static ssize_t b43_debugfs_read(struct f
 			err = -ENOMEM;
 			goto out_unlock;
 		}
+		/* Sparse warns about the following memset, because it has a big
+		 * size value. That warning is bogus, so I will ignore it. --mb */
 		memset(buf, 0, bufsize);
 		if (dfops->take_irqlock) {
 			spin_lock_irq(&dev->wl->irq_lock);


From mb at bu3sch.de  Wed Sep 19 18:51:38 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 19 Sep 2007 18:51:38 +0200
Subject: [PATCH] b43: Don't lock irq_lock in debugfs txpower adjust
Message-ID: <200709191851.38740.mb@bu3sch.de>

It's not required and the txpower adjustment must not be in atomic.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-dev/drivers/net/wireless/b43/debugfs.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/debugfs.c	2007-09-19 18:13:49.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/debugfs.c	2007-09-19 18:13:51.000000000 +0200
@@ -223,15 +223,10 @@ out:
 static int txpower_g_write_file(struct b43_wldev *dev,
 				const char *buf, size_t count)
 {
-	unsigned long flags;
 	unsigned long phy_flags;
-	int err = 0;
 
-	spin_lock_irqsave(&dev->wl->irq_lock, flags);
-	if (dev->phy.type != B43_PHYTYPE_G) {
-		err = -ENODEV;
-		goto out_unlock;
-	}
+	if (dev->phy.type != B43_PHYTYPE_G)
+		return -ENODEV;
 	if ((count >= 4) && (memcmp(buf, "auto", 4) == 0)) {
 		/* Automatic control */
 		dev->phy.manual_txpower_control = 0;
@@ -240,10 +235,8 @@ static int txpower_g_write_file(struct b
 		int bbatt = 0, rfatt = 0, txmix = 0, pa2db = 0, pa3db = 0;
 		/* Manual control */
 		if (sscanf(buf, "%d %d %d %d %d", &bbatt, &rfatt,
-			   &txmix, &pa2db, &pa3db) != 5) {
-			err = -EINVAL;
-			goto out_unlock;
-		}
+			   &txmix, &pa2db, &pa3db) != 5)
+			return -EINVAL;
 		b43_put_attenuation_into_ranges(dev, &bbatt, &rfatt);
 		dev->phy.manual_txpower_control = 1;
 		dev->phy.bbatt.att = bbatt;
@@ -262,10 +255,8 @@ static int txpower_g_write_file(struct b
 		b43_radio_unlock(dev);
 		b43_phy_unlock(dev, phy_flags);
 	}
-out_unlock:
-	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
 
-	return err;
+	return 0;
 }
 
 /* wl->irq_lock is locked */


From mb at bu3sch.de  Wed Sep 19 18:53:44 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 19 Sep 2007 18:53:44 +0200
Subject: [PATCH] ssb: Use ioreadX() and iowriteX() for PCI.
Message-ID: <200709191853.44334.mb@bu3sch.de>

On a PCI bus use ioreadX() and iowriteX().
We map the I/O space with pci_iomap(), so we must use the correct
accessor functions, too.
readX() and writeX() are not guaranteed to accept the cookie returned
from pci_iomap() (though, it currently works on most architectures).

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-dev/drivers/ssb/pci.c
===================================================================
--- wireless-dev.orig/drivers/ssb/pci.c	2007-09-19 17:15:58.000000000 +0200
+++ wireless-dev/drivers/ssb/pci.c	2007-09-19 17:31:44.000000000 +0200
@@ -531,7 +531,7 @@ static u16 ssb_pci_read16(struct ssb_dev
 		if (unlikely(ssb_pci_switch_core(bus, dev)))
 			return 0xFFFF;
 	}
-	return readw(bus->mmio + offset);
+	return ioread16(bus->mmio + offset);
 }
 
 static u32 ssb_pci_read32(struct ssb_device *dev, u16 offset)
@@ -544,7 +544,7 @@ static u32 ssb_pci_read32(struct ssb_dev
 		if (unlikely(ssb_pci_switch_core(bus, dev)))
 			return 0xFFFFFFFF;
 	}
-	return readl(bus->mmio + offset);
+	return ioread32(bus->mmio + offset);
 }
 
 static void ssb_pci_write16(struct ssb_device *dev, u16 offset, u16 value)
@@ -557,7 +557,7 @@ static void ssb_pci_write16(struct ssb_d
 		if (unlikely(ssb_pci_switch_core(bus, dev)))
 			return;
 	}
-	writew(value, bus->mmio + offset);
+	iowrite16(value, bus->mmio + offset);
 }
 
 static void ssb_pci_write32(struct ssb_device *dev, u16 offset, u32 value)
@@ -570,7 +570,7 @@ static void ssb_pci_write32(struct ssb_d
 		if (unlikely(ssb_pci_switch_core(bus, dev)))
 			return;
 	}
-	writel(value, bus->mmio + offset);
+	iowrite32(value, bus->mmio + offset);
 }
 
 /* Not "static", as it's used in main.c */


From mb at bu3sch.de  Wed Sep 19 18:55:12 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 19 Sep 2007 18:55:12 +0200
Subject: [PATCH] ssb: Sparse fixes.
Message-ID: <200709191855.12767.mb@bu3sch.de>

This fixes all Sparse warnings in SSB.
No semantics change.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-dev/drivers/ssb/b43_pci_bridge.c
===================================================================
--- wireless-dev.orig/drivers/ssb/b43_pci_bridge.c	2007-09-19 17:15:58.000000000 +0200
+++ wireless-dev/drivers/ssb/b43_pci_bridge.c	2007-09-19 18:23:42.000000000 +0200
@@ -13,6 +13,8 @@
 #include <linux/pci.h>
 #include <linux/ssb/ssb.h>
 
+#include "ssb_private.h"
+
 
 static const struct pci_device_id b43_pci_bridge_tbl[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4301) },
Index: wireless-dev/drivers/ssb/driver_chipcommon.c
===================================================================
--- wireless-dev.orig/drivers/ssb/driver_chipcommon.c	2007-09-19 17:15:58.000000000 +0200
+++ wireless-dev/drivers/ssb/driver_chipcommon.c	2007-09-19 18:22:31.000000000 +0200
@@ -345,8 +345,7 @@ void ssb_chipco_timing_init(struct ssb_c
 }
 
 /* Set chip watchdog reset timer to fire in 'ticks' backplane cycles */
-void
-ssb_chipco_watchdog_timer_set(struct ssb_chipcommon *cc, u32 ticks)
+void ssb_chipco_watchdog_timer_set(struct ssb_chipcommon *cc, u32 ticks)
 {
 	/* instant NMI */
 	chipco_write32(cc, SSB_CHIPCO_WATCHDOG, ticks);
@@ -359,12 +358,12 @@ u32 ssb_chipco_gpio_in(struct ssb_chipco
 
 void ssb_chipco_gpio_out(struct ssb_chipcommon *cc, u32 mask, u32 value)
 {
-	return chipco_write32_masked(cc, SSB_CHIPCO_GPIOOUT, mask, value);
+	chipco_write32_masked(cc, SSB_CHIPCO_GPIOOUT, mask, value);
 }
 
 void ssb_chipco_gpio_outen(struct ssb_chipcommon *cc, u32 mask, u32 value)
 {
-	return chipco_write32_masked(cc, SSB_CHIPCO_GPIOOUTEN, mask, value);
+	chipco_write32_masked(cc, SSB_CHIPCO_GPIOOUTEN, mask, value);
 }
 
 #ifdef CONFIG_SSB_SERIAL
Index: wireless-dev/drivers/ssb/pci.c
===================================================================
--- wireless-dev.orig/drivers/ssb/pci.c	2007-09-19 18:13:57.000000000 +0200
+++ wireless-dev/drivers/ssb/pci.c	2007-09-19 18:19:45.000000000 +0200
@@ -306,15 +306,15 @@ static void sprom_extract_r1(struct ssb_
 	SPEX(pci_pid, SSB_SPROM1_PID, 0xFFFF, 0);
 	for (i = 0; i < 3; i++) {
 		v = in[SPOFF(SSB_SPROM1_IL0MAC) + i];
-		*(((u16 *)out->il0mac) + i) = cpu_to_be16(v);
+		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
 	}
 	for (i = 0; i < 3; i++) {
 		v = in[SPOFF(SSB_SPROM1_ET0MAC) + i];
-		*(((u16 *)out->et0mac) + i) = cpu_to_be16(v);
+		*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
 	}
 	for (i = 0; i < 3; i++) {
 		v = in[SPOFF(SSB_SPROM1_ET1MAC) + i];
-		*(((u16 *)out->et1mac) + i) = cpu_to_be16(v);
+		*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
 	}
 	SPEX(et0phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0A, 0);
 	SPEX(et1phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1A,
@@ -352,7 +352,7 @@ static void sprom_extract_r1(struct ssb_
 	     SSB_SPROM1_AGAIN_BG_SHIFT);
 	for (i = 0; i < 4; i++) {
 		v = in[SPOFF(SSB_SPROM1_OEM) + i];
-		*(((u16 *)out->oem) + i) = cpu_to_le16(v);
+		*(((__le16 *)out->oem) + i) = cpu_to_le16(v);
 	}
 }
 
@@ -374,7 +374,7 @@ static void sprom_extract_r2(struct ssb_
 	SPEX(ofdm_pwr_off, SSB_SPROM2_OPO, SSB_SPROM2_OPO_VALUE, 0);
 	for (i = 0; i < 4; i++) {
 		v = in[SPOFF(SSB_SPROM2_CCODE) + i];
-		*(((u16 *)out->country_str) + i) = cpu_to_le16(v);
+		*(((__le16 *)out->country_str) + i) = cpu_to_le16(v);
 	}
 }
 


From mb at bu3sch.de  Wed Sep 19 18:58:38 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 19 Sep 2007 18:58:38 +0200
Subject: [PATCH] b43: Change loglevel of radio-enable message.
Message-ID: <200709191858.38634.mb@bu3sch.de>

Also cleanup the code a bit and remove the inline.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-dev/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-09-19 18:26:34.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-09-19 18:47:04.000000000 +0200
@@ -2175,6 +2175,21 @@ static void b43_mgmtframe_txantenna(stru
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PRPHYCTL, tmp);
 }
 
+/* Returns TRUE, if the radio is enabled in hardware. */
+static bool b43_is_hw_radio_enabled(struct b43_wldev *dev)
+{
+	if (dev->phy.rev >= 3) {
+		if (!(b43_read32(dev, B43_MMIO_RADIO_HWENABLED_HI)
+		      & B43_MMIO_RADIO_HWENABLED_HI_MASK))
+			return 1;
+	} else {
+		if (b43_read16(dev, B43_MMIO_RADIO_HWENABLED_LO)
+		    & B43_MMIO_RADIO_HWENABLED_LO_MASK)
+			return 1;
+	}
+	return 0;
+}
+
 /* This is the opposite of b43_chip_init() */
 static void b43_chip_exit(struct b43_wldev *dev)
 {
@@ -2214,7 +2229,7 @@ static int b43_chip_init(struct b43_wlde
 	b43_radio_turn_on(dev);
 	dev->radio_hw_enable = b43_is_hw_radio_enabled(dev);
 	b43dbg(dev->wl, "Radio %s by hardware\n",
-	       (dev->radio_hw_enable == 0) ? "disabled" : "enabled");
+	       dev->radio_hw_enable ? "enabled" : "disabled");
 
 	b43_write16(dev, 0x03E6, 0x0000);
 	err = b43_phy_init(dev);
@@ -2373,14 +2388,14 @@ static void b43_periodic_every15sec(stru
 
 static void b43_periodic_every1sec(struct b43_wldev *dev)
 {
-	int radio_hw_enable;
+	bool radio_hw_enable;
 
 	/* check if radio hardware enabled status changed */
 	radio_hw_enable = b43_is_hw_radio_enabled(dev);
 	if (unlikely(dev->radio_hw_enable != radio_hw_enable)) {
 		dev->radio_hw_enable = radio_hw_enable;
-		b43dbg(dev->wl, "Radio hardware status changed to %s\n",
-		       (radio_hw_enable == 0) ? "disabled" : "enabled");
+		b43info(dev->wl, "Radio hardware status changed to %s\n",
+			radio_hw_enable ? "ENABLED" : "DISABLED");
 		b43_leds_update(dev, 0);
 	}
 }
Index: wireless-dev/drivers/net/wireless/b43/main.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/main.h	2007-09-19 17:15:58.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.h	2007-09-19 18:40:57.000000000 +0200
@@ -96,23 +96,6 @@ static inline int b43_is_ofdm_rate(int r
 	return !b43_is_cck_rate(rate);
 }
 
-static inline int b43_is_hw_radio_enabled(struct b43_wldev *dev)
-{
-	/* function to return state of hardware enable of radio
-	 * returns 0 if radio disabled, 1 if radio enabled
-	 */
-	struct b43_phy *phy = &dev->phy;
-
-	if (phy->rev >= 3)
-		return ((b43_read32(dev, B43_MMIO_RADIO_HWENABLED_HI)
-			 & B43_MMIO_RADIO_HWENABLED_HI_MASK)
-			== 0) ? 1 : 0;
-	else
-		return ((b43_read16(dev, B43_MMIO_RADIO_HWENABLED_LO)
-			 & B43_MMIO_RADIO_HWENABLED_LO_MASK)
-			== 0) ? 0 : 1;
-}
-
 void b43_tsf_read(struct b43_wldev *dev, u64 * tsf);
 void b43_tsf_write(struct b43_wldev *dev, u64 tsf);
 


From mb at bu3sch.de  Wed Sep 19 19:10:08 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 19 Sep 2007 19:10:08 +0200
Subject: [PATCH v2 FIXED] b43: Change loglevel of radio-enable message.
Message-ID: <200709191910.08743.mb@bu3sch.de>

Also cleanup the code a bit and remove the inline.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-dev/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-09-19 19:02:24.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-09-19 19:02:27.000000000 +0200
@@ -2175,6 +2175,21 @@ static void b43_mgmtframe_txantenna(stru
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PRPHYCTL, tmp);
 }
 
+/* Returns TRUE, if the radio is enabled in hardware. */
+static bool b43_is_hw_radio_enabled(struct b43_wldev *dev)
+{
+	if (dev->phy.rev >= 3) {
+		if (!(b43_read32(dev, B43_MMIO_RADIO_HWENABLED_HI)
+		      & B43_MMIO_RADIO_HWENABLED_HI_MASK))
+			return 1;
+	} else {
+		if (b43_read16(dev, B43_MMIO_RADIO_HWENABLED_LO)
+		    & B43_MMIO_RADIO_HWENABLED_LO_MASK)
+			return 1;
+	}
+	return 0;
+}
+
 /* This is the opposite of b43_chip_init() */
 static void b43_chip_exit(struct b43_wldev *dev)
 {
@@ -2214,7 +2229,7 @@ static int b43_chip_init(struct b43_wlde
 	b43_radio_turn_on(dev);
 	dev->radio_hw_enable = b43_is_hw_radio_enabled(dev);
 	b43dbg(dev->wl, "Radio %s by hardware\n",
-	       (dev->radio_hw_enable == 0) ? "disabled" : "enabled");
+	       dev->radio_hw_enable ? "enabled" : "disabled");
 
 	b43_write16(dev, 0x03E6, 0x0000);
 	err = b43_phy_init(dev);
@@ -2373,14 +2388,14 @@ static void b43_periodic_every15sec(stru
 
 static void b43_periodic_every1sec(struct b43_wldev *dev)
 {
-	int radio_hw_enable;
+	bool radio_hw_enable;
 
 	/* check if radio hardware enabled status changed */
 	radio_hw_enable = b43_is_hw_radio_enabled(dev);
 	if (unlikely(dev->radio_hw_enable != radio_hw_enable)) {
 		dev->radio_hw_enable = radio_hw_enable;
-		b43dbg(dev->wl, "Radio hardware status changed to %s\n",
-		       (radio_hw_enable == 0) ? "disabled" : "enabled");
+		b43info(dev->wl, "Radio hardware status changed to %s\n",
+			radio_hw_enable ? "ENABLED" : "DISABLED");
 		b43_leds_update(dev, 0);
 	}
 }
Index: wireless-dev/drivers/net/wireless/b43/main.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/main.h	2007-09-19 19:02:24.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.h	2007-09-19 19:02:27.000000000 +0200
@@ -96,23 +96,6 @@ static inline int b43_is_ofdm_rate(int r
 	return !b43_is_cck_rate(rate);
 }
 
-static inline int b43_is_hw_radio_enabled(struct b43_wldev *dev)
-{
-	/* function to return state of hardware enable of radio
-	 * returns 0 if radio disabled, 1 if radio enabled
-	 */
-	struct b43_phy *phy = &dev->phy;
-
-	if (phy->rev >= 3)
-		return ((b43_read32(dev, B43_MMIO_RADIO_HWENABLED_HI)
-			 & B43_MMIO_RADIO_HWENABLED_HI_MASK)
-			== 0) ? 1 : 0;
-	else
-		return ((b43_read16(dev, B43_MMIO_RADIO_HWENABLED_LO)
-			 & B43_MMIO_RADIO_HWENABLED_LO_MASK)
-			== 0) ? 0 : 1;
-}
-
 void b43_tsf_read(struct b43_wldev *dev, u64 * tsf);
 void b43_tsf_write(struct b43_wldev *dev, u64 tsf);
 
Index: wireless-dev/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/leds.c	2007-09-19 18:13:49.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/leds.c	2007-09-19 19:07:45.000000000 +0200
@@ -176,6 +176,7 @@ void b43_leds_update(struct b43_wldev *d
 	unsigned long interval = 0;
 	u16 ledctl;
 	unsigned long flags;
+	bool radio_enabled = (phy->radio_on && dev->radio_hw_enable);
 
 	spin_lock_irqsave(&dev->wl->leds_lock, flags);
 	ledctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);
@@ -195,21 +196,19 @@ void b43_leds_update(struct b43_wldev *d
 			turn_on = activity;
 			break;
 		case B43_LED_RADIO_ALL:
-			turn_on = phy->radio_on && b43_is_hw_radio_enabled(dev);
+			turn_on = radio_enabled;
 			break;
 		case B43_LED_RADIO_A:
-			turn_on = (phy->radio_on && b43_is_hw_radio_enabled(dev)
-				   && phy->type == B43_PHYTYPE_A);
+			turn_on = (radio_enabled && phy->type == B43_PHYTYPE_A);
 			break;
 		case B43_LED_RADIO_B:
-			turn_on = (phy->radio_on && b43_is_hw_radio_enabled(dev)
-				   && (phy->type == B43_PHYTYPE_B
-				       || phy->type == B43_PHYTYPE_G));
+			turn_on = (radio_enabled &&
+				   (phy->type == B43_PHYTYPE_B
+				    || phy->type == B43_PHYTYPE_G));
 			break;
 		case B43_LED_MODE_BG:
 			if (phy->type == B43_PHYTYPE_G
-			    && b43_is_hw_radio_enabled(dev)
-			    && 1 /*FIXME: using G rates. */ )
+			    && radio_enabled)
 				turn_on = 1;
 			break;
 		case B43_LED_TRANSFER:


From larry.finger at lwfinger.net  Wed Sep 19 19:55:59 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 19 Sep 2007 12:55:59 -0500
Subject: [PATCH] b43: Change loglevel of radio-enable message.
In-Reply-To: <200709191858.38634.mb@bu3sch.de>
References: <200709191858.38634.mb@bu3sch.de>
Message-ID: <46F162AF.9050903@lwfinger.net>

Michael Buesch wrote:
> Also cleanup the code a bit and remove the inline.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

> @@ -2214,7 +2229,7 @@ static int b43_chip_init(struct b43_wlde
>  	b43_radio_turn_on(dev);
>  	dev->radio_hw_enable = b43_is_hw_radio_enabled(dev);
>  	b43dbg(dev->wl, "Radio %s by hardware\n",           <========================
> -	       (dev->radio_hw_enable == 0) ? "disabled" : "enabled");
> +	       dev->radio_hw_enable ? "enabled" : "disabled");

Shouldn't this one be b43info rather than b43dbg?

Larry



From mb at bu3sch.de  Wed Sep 19 19:57:59 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 19 Sep 2007 19:57:59 +0200
Subject: [PATCH] b43: Change loglevel of radio-enable message.
In-Reply-To: <46F162AF.9050903@lwfinger.net>
References: <200709191858.38634.mb@bu3sch.de> <46F162AF.9050903@lwfinger.net>
Message-ID: <200709191957.59255.mb@bu3sch.de>

On Wednesday 19 September 2007 19:55:59 Larry Finger wrote:
> Michael Buesch wrote:
> > Also cleanup the code a bit and remove the inline.
> > 
> > Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> > @@ -2214,7 +2229,7 @@ static int b43_chip_init(struct b43_wlde
> >  	b43_radio_turn_on(dev);
> >  	dev->radio_hw_enable = b43_is_hw_radio_enabled(dev);
> >  	b43dbg(dev->wl, "Radio %s by hardware\n",           <========================
> > -	       (dev->radio_hw_enable == 0) ? "disabled" : "enabled");
> > +	       dev->radio_hw_enable ? "enabled" : "disabled");
> 
> Shouldn't this one be b43info rather than b43dbg?

No, I think it's really only interesting to see if it changed
in operation.
If it doesn't work, people will press their rfkill buttons
before even noticing this message on init. :)

-- 
Greetings Michael.


From gmccullagh at gmail.com  Thu Sep 20 11:24:21 2007
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Thu, 20 Sep 2007 10:24:21 +0100
Subject: [AirForce One 54g] working
In-Reply-To: <46EF451B.5090701@lwfinger.net>
References: <20070916214502.GA21484@gmail.com>
	<20070917204526.GA17766@gmail.com> <46EF451B.5090701@lwfinger.net>
Message-ID: <20070920092421.GF6813@gmail.com>

Hi,

On Mon, 17 Sep 2007, Larry Finger wrote:

> As far as I can tell, this is a NetworkManager problem. I have two APs,
> one with WPA and one with WEP encryption so that I can test in either
> mode without affecting my wife's connection.

You may be right.  A friend seems to be having similar trouble with an
atheros card and the same up-to-date version of gutsy.

Gavin




From larry.finger at lwfinger.net  Thu Sep 20 14:55:06 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 20 Sep 2007 07:55:06 -0500
Subject: [PATCH] b43: Change loglevel of radio-enable message.
In-Reply-To: <200709191957.59255.mb@bu3sch.de>
References: <200709191858.38634.mb@bu3sch.de> <46F162AF.9050903@lwfinger.net>
	<200709191957.59255.mb@bu3sch.de>
Message-ID: <46F26DAA.6070909@lwfinger.net>

Michael Buesch wrote:
> On Wednesday 19 September 2007 19:55:59 Larry Finger wrote:
>> Michael Buesch wrote:
>>> Also cleanup the code a bit and remove the inline.
>>>
>>> Signed-off-by: Michael Buesch <mb at bu3sch.de>
>>> @@ -2214,7 +2229,7 @@ static int b43_chip_init(struct b43_wlde
>>>  	b43_radio_turn_on(dev);
>>>  	dev->radio_hw_enable = b43_is_hw_radio_enabled(dev);
>>>  	b43dbg(dev->wl, "Radio %s by hardware\n",           <========================
>>> -	       (dev->radio_hw_enable == 0) ? "disabled" : "enabled");
>>> +	       dev->radio_hw_enable ? "enabled" : "disabled");
>> Shouldn't this one be b43info rather than b43dbg?
> 
> No, I think it's really only interesting to see if it changed
> in operation.
> If it doesn't work, people will press their rfkill buttons
> before even noticing this message on init. :)

I have a suggestion to simplify the whole business of hardware radio control. Why don't we
unconditionally set radio_hw_enable to one here and dispense with this message? That way, people
without the rfkill switch will never see a message and those that do will only get messages if their
switch is off, or if it is toggled.

Larry


From mb at bu3sch.de  Thu Sep 20 15:01:22 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 20 Sep 2007 15:01:22 +0200
Subject: [PATCH] b43: Change loglevel of radio-enable message.
In-Reply-To: <46F26DAA.6070909@lwfinger.net>
References: <200709191858.38634.mb@bu3sch.de> <200709191957.59255.mb@bu3sch.de>
	<46F26DAA.6070909@lwfinger.net>
Message-ID: <200709201501.22977.mb@bu3sch.de>

On Thursday 20 September 2007, Larry Finger wrote:
> Michael Buesch wrote:
> > On Wednesday 19 September 2007 19:55:59 Larry Finger wrote:
> >> Michael Buesch wrote:
> >>> Also cleanup the code a bit and remove the inline.
> >>>
> >>> Signed-off-by: Michael Buesch <mb at bu3sch.de>
> >>> @@ -2214,7 +2229,7 @@ static int b43_chip_init(struct b43_wlde
> >>>  	b43_radio_turn_on(dev);
> >>>  	dev->radio_hw_enable = b43_is_hw_radio_enabled(dev);
> >>>  	b43dbg(dev->wl, "Radio %s by hardware\n",           <========================
> >>> -	       (dev->radio_hw_enable == 0) ? "disabled" : "enabled");
> >>> +	       dev->radio_hw_enable ? "enabled" : "disabled");
> >> Shouldn't this one be b43info rather than b43dbg?
> > 
> > No, I think it's really only interesting to see if it changed
> > in operation.
> > If it doesn't work, people will press their rfkill buttons
> > before even noticing this message on init. :)
> 
> I have a suggestion to simplify the whole business of hardware radio control. Why don't we
> unconditionally set radio_hw_enable to one here and dispense with this message? That way, people
> without the rfkill switch will never see a message and those that do will only get messages if their
> switch is off, or if it is toggled.

Great idea, Larry!
I will implement that in an additional patch later.

Thanks.


From mb at bu3sch.de  Thu Sep 20 22:12:58 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 20 Sep 2007 22:12:58 +0200
Subject: [PATCH] b43: Remove the "radio hw enabled" message on startup.
Message-ID: <200709202212.58455.mb@bu3sch.de>

This message is useless. Only report state changes.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>

Index: wireless-dev/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-09-20 19:39:06.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-09-20 20:06:24.000000000 +0200
@@ -2227,9 +2227,6 @@ static int b43_chip_init(struct b43_wlde
 	if (err)
 		goto err_gpio_cleanup;
 	b43_radio_turn_on(dev);
-	dev->radio_hw_enable = b43_is_hw_radio_enabled(dev);
-	b43dbg(dev->wl, "Radio %s by hardware\n",
-	       dev->radio_hw_enable ? "enabled" : "disabled");
 
 	b43_write16(dev, 0x03E6, 0x0000);
 	err = b43_phy_init(dev);
@@ -3251,6 +3248,9 @@ static void setup_struct_wldev_for_init(
 {
 	/* Flags */
 	dev->reg124_set_0x4 = 0;
+	/* Assume the radio is enabled. If it's not enabled, the state will
+	 * immediately get fixed on the first periodic work run. */
+	dev->radio_hw_enable = 1;
 
 	/* Stats */
 	memset(&dev->stats, 0, sizeof(dev->stats));


From mb at bu3sch.de  Thu Sep 20 22:14:18 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 20 Sep 2007 22:14:18 +0200
Subject: [PATCH] b43: Support for turning the radio off from software.
Message-ID: <200709202214.18759.mb@bu3sch.de>

This adds support for turning the radio off in software.
That's useful in environments, where you don't want the RF
to radiate any signals, but don't want to bring the interface down.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>

Index: wireless-dev/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/b43.h	2007-09-20 19:39:06.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/b43.h	2007-09-20 21:11:02.000000000 +0200
@@ -459,7 +459,6 @@ struct b43_phy {
 	u16 radio_ver;		/* Radio version */
 	u8 radio_rev;		/* Radio revision */
 
-	bool radio_on;		/* Radio switched on/off */
 	bool locked;		/* Only used in b43_phy_{un}lock() */
 	bool dyn_tssi_tbl;	/* tssi2dbm is kmalloc()ed. */
 
@@ -468,6 +467,16 @@ struct b43_phy {
 	bool aci_wlan_automatic;
 	bool aci_hw_rssi;
 
+	/* Radio switched on/off */
+	bool radio_on;
+	struct {
+		/* Values saved when turning the radio off.
+		 * They are needed when turning it on again. */
+		bool valid;
+		u16 rfover;
+		u16 rfoverval;
+	} radio_off_context;
+
 	u16 minlowsig[2];
 	u16 minlowsigpos[2];
 
Index: wireless-dev/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/main.c	2007-09-20 20:06:24.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/main.c	2007-09-20 21:30:40.000000000 +0200
@@ -2874,6 +2874,21 @@ static int b43_dev_config(struct ieee802
 	if (b43_is_mode(wl, IEEE80211_IF_TYPE_AP))
 		b43_set_beacon_int(dev, conf->beacon_int);
 
+	if (!!conf->radio_enabled != phy->radio_on) {
+		if (conf->radio_enabled) {
+			b43_radio_turn_on(dev);
+			b43info(dev->wl, "Radio turned on by software\n");
+			if (!dev->radio_hw_enable) {
+				b43info(dev->wl, "The hardware RF-kill button "
+					"still turns the radio physically off. "
+					"Press the button to turn it on.\n");
+			}
+		} else {
+			b43_radio_turn_off(dev);
+			b43info(dev->wl, "Radio turned off by software\n");
+		}
+	}
+
 	spin_lock_irqsave(&wl->irq_lock, flags);
 	b43_interrupt_enable(dev, savedirqs);
 	mmiowb();
@@ -3217,6 +3232,8 @@ static void setup_struct_phy_for_init(st
 	phy->aci_wlan_automatic = 0;
 	phy->aci_hw_rssi = 0;
 
+	phy->radio_off_context.valid = 0;
+
 	lo = phy->lo_control;
 	if (lo) {
 		memset(lo, 0, sizeof(*(phy->lo_control)));
Index: wireless-dev/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43/phy.c	2007-09-20 19:28:43.000000000 +0200
+++ wireless-dev/drivers/net/wireless/b43/phy.c	2007-09-20 21:16:19.000000000 +0200
@@ -1205,10 +1205,7 @@ static void b43_phy_initb2(struct b43_wl
 		val -= 0x0202;
 	}
 	b43_phy_write(dev, 0x03E4, 0x3000);
-	if (phy->channel == 0xFF)
-		b43_radio_selectchannel(dev, B43_DEFAULT_CHANNEL_BG, 0);
-	else
-		b43_radio_selectchannel(dev, phy->channel, 0);
+	b43_radio_selectchannel(dev, phy->channel, 0);
 	if (phy->radio_ver != 0x2050) {
 		b43_radio_write16(dev, 0x0075, 0x0080);
 		b43_radio_write16(dev, 0x0079, 0x0081);
@@ -1256,10 +1253,7 @@ static void b43_phy_initb4(struct b43_wl
 		val -= 0x0202;
 	}
 	b43_phy_write(dev, 0x03E4, 0x3000);
-	if (phy->channel == 0xFF)
-		b43_radio_selectchannel(dev, B43_DEFAULT_CHANNEL_BG, 0);
-	else
-		b43_radio_selectchannel(dev, phy->channel, 0);
+	b43_radio_selectchannel(dev, phy->channel, 0);
 	if (phy->radio_ver != 0x2050) {
 		b43_radio_write16(dev, 0x0075, 0x0080);
 		b43_radio_write16(dev, 0x0079, 0x0081);
@@ -4110,6 +4104,20 @@ int b43_radio_selectchannel(struct b43_w
 	u16 freq;
 	u16 channelcookie;
 
+	if (channel == 0xFF) {
+		switch (phy->type) {
+		case B43_PHYTYPE_A:
+			channel = B43_DEFAULT_CHANNEL_A;
+			break;
+		case B43_PHYTYPE_B:
+		case B43_PHYTYPE_G:
+			channel = B43_DEFAULT_CHANNEL_BG;
+			break;
+		default:
+			B43_WARN_ON(1);
+		}
+	}
+
 	/* First we set the channel radio code to prevent the
 	 * firmware from sending ghost packets.
 	 */
@@ -4302,6 +4310,7 @@ void b43_radio_turn_on(struct b43_wldev 
 {
 	struct b43_phy *phy = &dev->phy;
 	int err;
+	u8 channel;
 
 	might_sleep();
 
@@ -4321,14 +4330,23 @@ void b43_radio_turn_on(struct b43_wldev 
 		b43_phy_write(dev, 0x0015, 0x8000);
 		b43_phy_write(dev, 0x0015, 0xCC00);
 		b43_phy_write(dev, 0x0015, (phy->gmode ? 0x00C0 : 0x0000));
+		if (phy->radio_off_context.valid) {
+			/* Restore the RFover values. */
+			b43_phy_write(dev, B43_PHY_RFOVER,
+				      phy->radio_off_context.rfover);
+			b43_phy_write(dev, B43_PHY_RFOVERVAL,
+				      phy->radio_off_context.rfoverval);
+			phy->radio_off_context.valid = 0;
+		}
+		channel = phy->channel;
 		err = b43_radio_selectchannel(dev, B43_DEFAULT_CHANNEL_BG, 1);
+		err |= b43_radio_selectchannel(dev, channel, 0);
 		B43_WARN_ON(err);
 		break;
 	default:
 		B43_WARN_ON(1);
 	}
 	phy->radio_on = 1;
-	b43dbg(dev->wl, "Radio turned on\n");
 }
 
 void b43_radio_turn_off(struct b43_wldev *dev)
@@ -4342,10 +4360,16 @@ void b43_radio_turn_off(struct b43_wldev
 		b43_phy_write(dev, 0x0011, b43_phy_read(dev, 0x0011) | 0x0008);
 	}
 	if (phy->type == B43_PHYTYPE_G && dev->dev->id.revision >= 5) {
-		b43_phy_write(dev, 0x0811, b43_phy_read(dev, 0x0811) | 0x008C);
-		b43_phy_write(dev, 0x0812, b43_phy_read(dev, 0x0812) & 0xFF73);
+		u16 rfover, rfoverval;
+
+		rfover = b43_phy_read(dev, B43_PHY_RFOVER);
+		rfoverval = b43_phy_read(dev, B43_PHY_RFOVERVAL);
+		phy->radio_off_context.rfover = rfover;
+		phy->radio_off_context.rfoverval = rfoverval;
+		phy->radio_off_context.valid = 1;
+		b43_phy_write(dev, B43_PHY_RFOVER, rfover | 0x008C);
+		b43_phy_write(dev, B43_PHY_RFOVERVAL, rfoverval & 0xFF73);
 	} else
 		b43_phy_write(dev, 0x0015, 0xAA00);
 	phy->radio_on = 0;
-	b43dbg(dev->wl, "Radio turned off\n");
 }


From Larry.Finger at lwfinger.net  Fri Sep 21 03:10:07 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 20 Sep 2007 20:10:07 -0500
Subject: [PATCH] b43legacy: Change the hardware radio enable logic and
	cleanup code
Message-ID: <46f319ef.8UBDQAjFjjfCblr5%Larry.Finger@lwfinger.net>

This change cleans up the radio-related messages in several ways.

(1) The state of the rfkill switch is assumed to be on, rather than
    tested. Now, any user without such a switch will not see any
    messages. For devices with such a switch, a message will be
    logged only if the initial state is off, or if the switch is toggled.
(2) The routine for testing the switch state is no longer inline.
(3) The LED handling routine is simplified.
(4) The "Radio turned off" message that has confused some users has been
    changed to "Radio initialized".

This patch is patterned after a similar change to b43 by Michael Buesch.

Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>
---

 drivers/net/wireless/b43legacy/leds.c  |   12 ++++--------
 drivers/net/wireless/b43legacy/main.c  |   25 ++++++++++++++++++++-----
 drivers/net/wireless/b43legacy/main.h  |   20 --------------------
 drivers/net/wireless/b43legacy/radio.c |    2 +-
 4 files changed, 25 insertions(+), 34 deletions(-)


Index: wireless-dev/drivers/net/wireless/b43legacy/leds.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/leds.c
+++ wireless-dev/drivers/net/wireless/b43legacy/leds.c
@@ -182,6 +182,7 @@ void b43legacy_leds_update(struct b43leg
 	unsigned long interval = 0;
 	u16 ledctl;
 	unsigned long flags;
+	bool radio_enabled = (phy->radio_on && dev->radio_hw_enable);
 
 	spin_lock_irqsave(&dev->wl->leds_lock, flags);
 	ledctl = b43legacy_read16(dev, B43legacy_MMIO_GPIO_CONTROL);
@@ -201,20 +202,15 @@ void b43legacy_leds_update(struct b43leg
 			turn_on = activity;
 			break;
 		case B43legacy_LED_RADIO_ALL:
-			turn_on = phy->radio_on &&
-				  b43legacy_is_hw_radio_enabled(dev);
+			turn_on = radio_enabled;
 			break;
 		case B43legacy_LED_RADIO_A:
 			break;
 		case B43legacy_LED_RADIO_B:
-			turn_on = (phy->radio_on &&
-				   b43legacy_is_hw_radio_enabled(dev) &&
-				   (phy->type == B43legacy_PHYTYPE_B ||
-				    phy->type == B43legacy_PHYTYPE_G));
+			turn_on = radio_enabled;
 			break;
 		case B43legacy_LED_MODE_BG:
-			if (phy->type == B43legacy_PHYTYPE_G &&
-			    b43legacy_is_hw_radio_enabled(dev))
+			if (phy->type == B43legacy_PHYTYPE_G && radio_enabled)
 				turn_on = 1;
 			break;
 		case B43legacy_LED_TRANSFER:
Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -2008,6 +2008,21 @@ static void b43legacy_mgmtframe_txantenn
 			      B43legacy_SHM_SH_PRPHYCTL, tmp);
 }
 
+/* Returns TRUE, if the radio is enabled in hardware. */
+static bool b43legacy_is_hw_radio_enabled(struct b43legacy_wldev *dev)
+{
+	if (dev->phy.rev >= 3) {
+		if (!(b43legacy_read32(dev, B43legacy_MMIO_RADIO_HWENABLED_HI)
+		      & B43legacy_MMIO_RADIO_HWENABLED_HI_MASK))
+			return 1;
+	} else {
+		if (b43legacy_read16(dev, B43legacy_MMIO_RADIO_HWENABLED_LO)
+		    & B43legacy_MMIO_RADIO_HWENABLED_LO_MASK)
+			return 1;
+	}
+	return 0;
+}
+
 /* This is the opposite of b43legacy_chip_init() */
 static void b43legacy_chip_exit(struct b43legacy_wldev *dev)
 {
@@ -2047,9 +2062,6 @@ static int b43legacy_chip_init(struct b4
 	if (err)
 		goto err_gpio_cleanup;
 	b43legacy_radio_turn_on(dev);
-	dev->radio_hw_enable = b43legacy_is_hw_radio_enabled(dev);
-	b43legacyinfo(dev->wl, "Radio %s by hardware\n",
-	       (dev->radio_hw_enable == 0) ? "disabled" : "enabled");
 
 	b43legacy_write16(dev, 0x03E6, 0x0000);
 	err = b43legacy_phy_init(dev);
@@ -2171,14 +2183,14 @@ static void b43legacy_periodic_every15se
 
 static void b43legacy_periodic_every1sec(struct b43legacy_wldev *dev)
 {
-	int radio_hw_enable;
+	bool radio_hw_enable;
 
 	/* check if radio hardware enabled status changed */
 	radio_hw_enable = b43legacy_is_hw_radio_enabled(dev);
 	if (unlikely(dev->radio_hw_enable != radio_hw_enable)) {
 		dev->radio_hw_enable = radio_hw_enable;
 		b43legacyinfo(dev->wl, "Radio hardware status changed to %s\n",
-		       (radio_hw_enable == 0) ? "disabled" : "enabled");
+		       (radio_hw_enable) ? "enabled" : "disabled");
 		b43legacy_leds_update(dev, 0);
 	}
 }
@@ -2917,6 +2929,9 @@ static void setup_struct_phy_for_init(st
 
 	/* Flags */
 	phy->locked = 0;
+	/* Assume the radio is enabled. If it's not enabled, the state will
+	 * immediately get fixed on the first periodic work run. */
+	dev->radio_hw_enable = 1;
 
 	phy->savedpctlreg = 0xFFFF;
 	phy->aci_enable = 0;
Index: wireless-dev/drivers/net/wireless/b43legacy/main.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.h
+++ wireless-dev/drivers/net/wireless/b43legacy/main.h
@@ -97,26 +97,6 @@ int b43legacy_is_ofdm_rate(int rate)
 	return !b43legacy_is_cck_rate(rate);
 }
 
-static inline
-int b43legacy_is_hw_radio_enabled(struct b43legacy_wldev *dev)
-{
-	/* function to return state of hardware enable of radio
-	 * returns 0 if radio disabled, 1 if radio enabled
-	 */
-	struct b43legacy_phy *phy = &dev->phy;
-
-	if (phy->rev >= 3)
-		return ((b43legacy_read32(dev,
-				B43legacy_MMIO_RADIO_HWENABLED_HI)
-				& B43legacy_MMIO_RADIO_HWENABLED_HI_MASK)
-				== 0) ? 1 : 0;
-	else
-		return ((b43legacy_read16(dev,
-				B43legacy_MMIO_RADIO_HWENABLED_LO)
-				& B43legacy_MMIO_RADIO_HWENABLED_LO_MASK)
-				== 0) ? 0 : 1;
-}
-
 void b43legacy_tsf_read(struct b43legacy_wldev *dev, u64 *tsf);
 void b43legacy_tsf_write(struct b43legacy_wldev *dev, u64 tsf);
 
Index: wireless-dev/drivers/net/wireless/b43legacy/radio.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/radio.c
+++ wireless-dev/drivers/net/wireless/b43legacy/radio.c
@@ -2107,7 +2107,7 @@ void b43legacy_radio_turn_off(struct b43
 	} else
 		b43legacy_phy_write(dev, 0x0015, 0xAA00);
 	phy->radio_on = 0;
-	b43legacydbg(dev->wl, "Radio turned off\n");
+	b43legacydbg(dev->wl, "Radio initialized\n");
 	b43legacy_leds_update(dev, 0);
 }
 


From Larry.Finger at lwfinger.net  Fri Sep 21 04:11:02 2007
From: Larry.Finger at lwfinger.net (Larry Finger)
Date: Thu, 20 Sep 2007 21:11:02 -0500
Subject: [PATCH] b43legacy: Support for turning the radio off from
 software.
Message-ID: <46f32836.SaYVr1nG4+WJSJ9K%Larry.Finger@lwfinger.net>

This adds support for turning the radio off in software.
That's useful in environments, where you don't want the RF
to radiate any signals, but don't want to bring the interface down.

This patch is based on a similar patch of b43 by Michael Buesch.

Signed-off-by: Larry Finger <larry.finger at lwfinger.net>

 drivers/net/wireless/b43legacy/b43legacy.h |   11 +++++++-
 drivers/net/wireless/b43legacy/main.c      |   16 +++++++++++
 drivers/net/wireless/b43legacy/phy.c       |   14 +---------
 drivers/net/wireless/b43legacy/radio.c     |   39 ++++++++++++++++++++++++-----
 4 files changed, 61 insertions(+), 19 deletions(-)

Index: wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/b43legacy.h
+++ wireless-dev/drivers/net/wireless/b43legacy/b43legacy.h
@@ -411,7 +411,6 @@ struct b43legacy_phy {
 	u8 calibrated:1;
 	u8 radio_rev;		/* Radio revision */
 
-	bool radio_on;		/* Radio switched on/off */
 	bool locked;		/* Only used in b43legacy_phy_{un}lock() */
 	bool dyn_tssi_tbl;	/* tssi2dbm is kmalloc()ed. */
 
@@ -420,6 +419,16 @@ struct b43legacy_phy {
 	bool aci_wlan_automatic;
 	bool aci_hw_rssi;
 
+	/* Radio switched on/off */
+	bool radio_on;
+	struct {
+		/* Values saved when turning the radio off.
+		 * They are needed when turning it on again. */
+		bool valid;
+		u16 rfover;
+		u16 rfoverval;
+	} radio_off_context;
+
 	u16 minlowsig[2];
 	u16 minlowsigpos[2];
 
Index: wireless-dev/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-dev/drivers/net/wireless/b43legacy/main.c
@@ -2672,6 +2672,22 @@ static int b43legacy_dev_config(struct i
 		b43legacy_set_beacon_int(dev, conf->beacon_int);
 
 
+	if (!!conf->radio_enabled != phy->radio_on) {
+		if (conf->radio_enabled) {
+			b43legacy_radio_turn_on(dev);
+			b43legacyinfo(dev->wl, "Radio turned on by software\n");
+			if (!dev->radio_hw_enable)
+				b43legacyinfo(dev->wl, "The hardware RF-kill"
+					      " button still turns the radio"
+					      " physically off. Press the"
+					      " button to turn it on.\n");
+		} else {
+			b43legacy_radio_turn_off(dev);
+			b43legacyinfo(dev->wl, "Radio turned off by"
+				      " software\n");
+		}
+	}
+
 	spin_lock_irqsave(&wl->irq_lock, flags);
 	b43legacy_interrupt_enable(dev, savedirqs);
 	mmiowb();
Index: wireless-dev/drivers/net/wireless/b43legacy/phy.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/phy.c
+++ wireless-dev/drivers/net/wireless/b43legacy/phy.c
@@ -462,12 +462,7 @@ static void b43legacy_phy_initb2(struct 
 		val -= 0x0202;
 	}
 	b43legacy_phy_write(dev, 0x03E4, 0x3000);
-	if (phy->channel == 0xFF)
-		b43legacy_radio_selectchannel(dev,
-					B43legacy_RADIO_DEFAULT_CHANNEL_BG,
-					0);
-	else
-		b43legacy_radio_selectchannel(dev, phy->channel, 0);
+	b43legacy_radio_selectchannel(dev, phy->channel, 0);
 	if (phy->radio_ver != 0x2050) {
 		b43legacy_radio_write16(dev, 0x0075, 0x0080);
 		b43legacy_radio_write16(dev, 0x0079, 0x0081);
@@ -516,12 +511,7 @@ static void b43legacy_phy_initb4(struct 
 		val -= 0x0202;
 	}
 	b43legacy_phy_write(dev, 0x03E4, 0x3000);
-	if (phy->channel == 0xFF)
-		b43legacy_radio_selectchannel(dev,
-					B43legacy_RADIO_DEFAULT_CHANNEL_BG,
-					0);
-	else
-		b43legacy_radio_selectchannel(dev, phy->channel, 0);
+	b43legacy_radio_selectchannel(dev, phy->channel, 0);
 	if (phy->radio_ver != 0x2050) {
 		b43legacy_radio_write16(dev, 0x0075, 0x0080);
 		b43legacy_radio_write16(dev, 0x0079, 0x0081);
Index: wireless-dev/drivers/net/wireless/b43legacy/radio.c
===================================================================
--- wireless-dev.orig/drivers/net/wireless/b43legacy/radio.c
+++ wireless-dev/drivers/net/wireless/b43legacy/radio.c
@@ -1767,6 +1767,17 @@ int b43legacy_radio_selectchannel(struct
 {
 	struct b43legacy_phy *phy = &dev->phy;
 
+	if (channel == 0xFF) {
+		switch (phy->type) {
+		case B43legacy_PHYTYPE_B:
+		case B43legacy_PHYTYPE_G:
+			channel = B43legacy_RADIO_DEFAULT_CHANNEL_BG;
+			break;
+		default:
+			B43legacy_WARN_ON(1);
+		}
+	}
+
 /* TODO: Check if channel is valid - return -EINVAL if not */
 	if (synthetic_pu_workaround)
 		b43legacy_synth_pu_workaround(dev, channel);
@@ -2070,6 +2081,7 @@ void b43legacy_radio_turn_on(struct b43l
 {
 	struct b43legacy_phy *phy = &dev->phy;
 	int err;
+	u8 channel;
 
 	might_sleep();
 
@@ -2083,15 +2095,24 @@ void b43legacy_radio_turn_on(struct b43l
 		b43legacy_phy_write(dev, 0x0015, 0xCC00);
 		b43legacy_phy_write(dev, 0x0015,
 				    (phy->gmode ? 0x00C0 : 0x0000));
+		if (phy->radio_off_context.valid) {
+			/* Restore the RFover values. */
+			b43legacy_phy_write(dev, B43legacy_PHY_RFOVER,
+					    phy->radio_off_context.rfover);
+			b43legacy_phy_write(dev, B43legacy_PHY_RFOVERVAL,
+					    phy->radio_off_context.rfoverval);
+			phy->radio_off_context.valid = 0;
+		}
+		channel = phy->channel;
 		err = b43legacy_radio_selectchannel(dev,
 					B43legacy_RADIO_DEFAULT_CHANNEL_BG, 1);
-		B43legacy_WARN_ON(err != 0);
+		err |= b43legacy_radio_selectchannel(dev, channel, 0);
+		B43legacy_WARN_ON(err);
 		break;
 	default:
 		B43legacy_BUG_ON(1);
 	}
 	phy->radio_on = 1;
-	b43legacydbg(dev->wl, "Radio turned on\n");
 	b43legacy_leds_update(dev, 0);
 }
 
@@ -2100,10 +2121,16 @@ void b43legacy_radio_turn_off(struct b43
 	struct b43legacy_phy *phy = &dev->phy;
 
 	if (phy->type == B43legacy_PHYTYPE_G && dev->dev->id.revision >= 5) {
-		b43legacy_phy_write(dev, 0x0811, b43legacy_phy_read(dev, 0x0811)
-				    | 0x008C);
-		b43legacy_phy_write(dev, 0x0812, b43legacy_phy_read(dev, 0x0812)
-				    & 0xFF73);
+		u16 rfover, rfoverval;
+
+		rfover = b43legacy_phy_read(dev, B43legacy_PHY_RFOVER);
+		rfoverval = b43legacy_phy_read(dev, B43legacy_PHY_RFOVERVAL);
+		phy->radio_off_context.rfover = rfover;
+		phy->radio_off_context.rfoverval = rfoverval;
+		phy->radio_off_context.valid = 1;
+		b43legacy_phy_write(dev, B43legacy_PHY_RFOVER, rfover | 0x008C);
+		b43legacy_phy_write(dev, B43legacy_PHY_RFOVERVAL,
+				    rfoverval & 0xFF73);
 	} else
 		b43legacy_phy_write(dev, 0x0015, 0xAA00);
 	phy->radio_on = 0;


From mb at bu3sch.de  Fri Sep 21 15:22:00 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 21 Sep 2007 15:22:00 +0200
Subject: [PATCH] b43legacy: Change the hardware radio enable logic and
	cleanup code
In-Reply-To: <46f319ef.8UBDQAjFjjfCblr5%Larry.Finger@lwfinger.net>
References: <46f319ef.8UBDQAjFjjfCblr5%Larry.Finger@lwfinger.net>
Message-ID: <200709211522.01273.mb@bu3sch.de>

On Friday 21 September 2007 03:10:07 Larry Finger wrote:
> This change cleans up the radio-related messages in several ways.
> 
> (1) The state of the rfkill switch is assumed to be on, rather than
>     tested. Now, any user without such a switch will not see any
>     messages. For devices with such a switch, a message will be
>     logged only if the initial state is off, or if the switch is toggled.
> (2) The routine for testing the switch state is no longer inline.
> (3) The LED handling routine is simplified.
> (4) The "Radio turned off" message that has confused some users has been
>     changed to "Radio initialized".
> 
> This patch is patterned after a similar change to b43 by Michael Buesch.
> 
> Signed-off-by: Larry Finger <Larry.Finger at lwfinger.net>

> Index: wireless-dev/drivers/net/wireless/b43legacy/leds.c
> ===================================================================
> --- wireless-dev.orig/drivers/net/wireless/b43legacy/leds.c
> +++ wireless-dev/drivers/net/wireless/b43legacy/leds.c
> @@ -182,6 +182,7 @@ void b43legacy_leds_update(struct b43leg
>  	unsigned long interval = 0;
>  	u16 ledctl;
>  	unsigned long flags;
> +	bool radio_enabled = (phy->radio_on && dev->radio_hw_enable);

Just that you are aware of it:
This is a racy access to the radio_hw_enable variable, as we don't take
the mutex here (we can't and we don't want). But it's OK, since nobody
cares if the LED is racing for a second and displays the wrong state
for a second.
Same goes for the phy->radio_on access.

The patch is ACKed by me.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Fri Sep 21 17:54:24 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 21 Sep 2007 10:54:24 -0500
Subject: [PATCH] b43legacy: Change the hardware radio enable logic and
	cleanup code
In-Reply-To: <200709211522.01273.mb@bu3sch.de>
References: <46f319ef.8UBDQAjFjjfCblr5%Larry.Finger@lwfinger.net>
	<200709211522.01273.mb@bu3sch.de>
Message-ID: <46F3E930.1050007@lwfinger.net>

Michael Buesch wrote:
> 
> Just that you are aware of it:
> This is a racy access to the radio_hw_enable variable, as we don't take
> the mutex here (we can't and we don't want). But it's OK, since nobody
> cares if the LED is racing for a second and displays the wrong state
> for a second.
> Same goes for the phy->radio_on access.
> 
> The patch is ACKed by me.
> 

Thanks for the heads-up on the raciness of the access. I'm still learning what can and cannot be done.

Larry



From shocky1 at users.sourceforge.net  Sat Sep 22 01:27:48 2007
From: shocky1 at users.sourceforge.net (Shocky)
Date: Fri, 21 Sep 2007 17:27:48 -0600
Subject: Can't get wireless working with bcm43xx driver
Message-ID: <200709211727.49147.shocky1@users.sourceforge.net>

Hi,

I recently bought an HP Pavilion dv2412ca laptop, which came with Vista 
pre-installed. I backed it up, then reformatted and installed Mandriva 
2007.1. 

The laptop has a builtin wireless card that lspci identifies as a "Broadcom 
Corporation Dell Wireless 1390 WLAN Mini-PCI Card (rev 02)". I couldn't get 
it working with either bcm43xx or ndiswrapper using the Vista driver. 

I got an XP driver for it from the HP support web site (sp34152.exe), and was 
able to extract it using wine. I still couldn't get it to work with bcm43xx, 
but I got it sort of working with ndiswrapper. I say "sort of" because it was 
very flakey. It would usually connect when I first booted if the AP was 
within reach, but if it lost the signal there was no way to make it reconnect 
other than rebooting, and it wouldn't reconnect after suspend. This was with 
Mandriva's 2.6.17-13 kernel, and wireless_tools version 28. I upgraded the 
kernel to 2.6.17-15 (the latest available for 2007.1), but that didn't help.

Now I'm trying again with bcm43xx. I downloaded the source tarball for 2.6.22 
from kernel.org and built a custom kernel (and I turned on wireless and 
bcm43xx debugging while I was at it). I also got an SRPM from Mandriva cooker 
for wireless_tools version 29 and built and installed it. 

lspci -vn gives me:

01:00.0 0280: 14e4:4311 (rev 02)
	Subsystem: 103c:1374
	Flags: bus master, fast devsel, latency 0, IRQ 20
	Memory at c3000000 (64-bit, non-prefetchable) [size=16K]
	Capabilities: [40] Power Management version 3
	Capabilities: [58] Vendor Specific Information
	Capabilities: [e8] Message Signalled Interrupts: Mask- 64bit+ Queue=0/0 
Enable-
	Capabilities: [d0] Express Endpoint IRQ 0
	Capabilities: [100] Advanced Error Reporting
	Capabilities: [13c] Virtual Channel
	Capabilities: [160] Device Serial Number 1a-00-5c-ff-ff-73-3d-b9
	Capabilities: [16c] Power Budgeting

I was able to use bcm43xx-fwcutter (version 006) to extract the firmware from 
the XP driver into /lib/firmware:

-rw-r--r-- 1 root root  3672 Sep 19 21:22 bcm43xx_initval01.fw
-rw-r--r-- 1 root root    16 Sep 19 21:22 bcm43xx_initval02.fw
-rw-r--r-- 1 root root  3672 Sep 19 21:22 bcm43xx_initval03.fw
-rw-r--r-- 1 root root    16 Sep 19 21:22 bcm43xx_initval04.fw
-rw-r--r-- 1 root root  2544 Sep 19 21:22 bcm43xx_initval05.fw
-rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval06.fw
-rw-r--r-- 1 root root  2544 Sep 19 21:22 bcm43xx_initval07.fw
-rw-r--r-- 1 root root  2544 Sep 19 21:22 bcm43xx_initval08.fw
-rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval09.fw
-rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval10.fw
-rw-r--r-- 1 root root  2872 Sep 19 21:22 bcm43xx_initval17.fw
-rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval18.fw
-rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval19.fw
-rw-r--r-- 1 root root  2816 Sep 19 21:22 bcm43xx_initval20.fw
-rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval21.fw
-rw-r--r-- 1 root root  2824 Sep 19 21:22 bcm43xx_initval22.fw
-rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval23.fw
-rw-r--r-- 1 root root  2824 Sep 19 21:22 bcm43xx_initval24.fw
-rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval25.fw
-rw-r--r-- 1 root root 27360 Sep 19 21:22 bcm43xx_microcode11.fw
-rw-r--r-- 1 root root 26432 Sep 19 21:22 bcm43xx_microcode13.fw
-rw-r--r-- 1 root root 19912 Sep 19 21:22 bcm43xx_microcode4.fw
-rw-r--r-- 1 root root 21944 Sep 19 21:22 bcm43xx_microcode5.fw
-rw-r--r-- 1 root root  1312 Sep 19 21:22 bcm43xx_pcm4.fw
-rw-r--r-- 1 root root  1312 Sep 19 21:22 bcm43xx_pcm5.fw

I get the following syslog messages during boot:

Sep 20 15:46:33 rllt01 kernel: ieee80211_crypt: registered algorithm 'NULL'
Sep 20 15:46:33 rllt01 kernel: ieee80211: 802.11 data/management/control 
stack, git-1.1.13
Sep 20 15:46:33 rllt01 kernel: ieee80211: Copyright (C) 2004-2005 Intel 
Corporation <jketreno at linux.intel.com>
Sep 20 15:46:33 rllt01 kernel: bcm43xx driver
...
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Chip ID 0x4311, rev 0x2
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Number of cores: 4
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 
0x4243
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 
0x4243
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Unsupported 80211 core revision 13
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Core 2: ID 0x817, rev 0x4, vendor 
0x4243
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Core 3: ID 0x820, rev 0x5, vendor 
0x4243
Sep 20 15:46:33 rllt01 kernel: bcm43xx: PHY connected
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Detected PHY: Analog: 4, Type 2, 
Revision 9
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Invalid PHY Revision 9
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Detected Radio: ID: 2205017f (Manuf: 
17f Ver: 2050 Rev: 2)
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Radio turned off
Sep 20 15:46:33 rllt01 kernel: bcm43xx: Radio turned off
...
Sep 20 15:46:37 rllt01 kernel: bcm43xx: PHY connected
Sep 20 15:46:37 rllt01 kernel: bcm43xx: Microcode rev 0x173, pl 0x425 
(2006-10-04  21:02:04)
Sep 20 15:46:37 rllt01 kernel: bcm43xx: Firmware: no support for microcode 
extracted from version 4.x binary drivers.
Sep 20 15:46:37 rllt01 kernel: bcm43xx: core_up for active 802.11 core failed 
(-95)
Sep 20 15:46:37 rllt01 kernel: bcm43xx: set security called, .level = 
0, .enabled = 0, .encrypt = 0
Sep 20 15:46:37 rllt01 kernel: SoftMAC: Associate: Scanning for networks 
first.
Sep 20 15:46:37 rllt01 kernel: SoftMAC: Associate: failed to initiate scan. Is 
device up?
Sep 20 15:46:37 rllt01 kernel: SoftMAC: Canceling existing associate request!
Sep 20 15:46:37 rllt01 kernel: SoftMAC: Associate: Scanning for networks 
first.
Sep 20 15:46:37 rllt01 kernel: SoftMAC: Associate: failed to initiate scan. Is 
device up?
Sep 20 15:46:37 rllt01 ifplugd(eth2)[2750]: ifplugd 0.28 initializing.
Sep 20 15:46:37 rllt01 kernel: bcm43xx: Microcode rev 0x173, pl 0x425 
(2006-10-04  21:02:04)
Sep 20 15:46:37 rllt01 kernel: bcm43xx: Firmware: no support for microcode 
extracted from version 4.x binary drivers.
Sep 20 15:46:37 rllt01 kernel: bcm43xx: core_up for active 802.11 core failed 
(-95)
Sep 20 15:46:37 rllt01 ifplugd(eth2)[2750]: Using interface 
eth2/00:00:00:1A:73:5C with driver <bcm43xx> (version: 2.6.22-custom1)
Sep 20 15:46:37 rllt01 kernel: bcm43xx: Microcode rev 0x173, pl 0x425 
(2006-10-04  21:02:04)
Sep 20 15:46:37 rllt01 kernel: bcm43xx: Firmware: no support for microcode 
extracted from version 4.x binary drivers.
Sep 20 15:46:37 rllt01 kernel: bcm43xx: core_up for active 802.11 core failed 
(-95)
Sep 20 15:46:37 rllt01 ifplugd(eth2)[2750]: Using detection mode: SIOCETHTOOL
Sep 20 15:46:37 rllt01 ifplugd(eth2)[2750]: Initialization complete, link beat 
not detected.
Sep 20 15:46:38 rllt01 kernel: bcm43xx: Microcode rev 0x173, pl 0x425 
(2006-10-04  21:02:04)
Sep 20 15:46:38 rllt01 kernel: bcm43xx: Firmware: no support for microcode 
extracted from version 4.x binary drivers.
Sep 20 15:46:38 rllt01 kernel: bcm43xx: core_up for active 802.11 core failed 
(-95)
Sep 20 15:46:38 rllt01 kernel: bcm43xx: Microcode rev 0x173, pl 0x425 
(2006-10-04  21:02:04)
Sep 20 15:46:38 rllt01 kernel: bcm43xx: Firmware: no support for microcode 
extracted from version 4.x binary drivers.
Sep 20 15:46:38 rllt01 kernel: bcm43xx: core_up for active 802.11 core failed 
(-95)

These "core up ... failed" messages continue to appear in the log once per 
second. I suspect the message about version 4.x drivers not being supported 
is the problem.

If I try to bring up the interface manually, I get the error "SIOCSIFFLAGS: 
Operation not supported".

Should I try to find an older driver? Is it likely to work with my newer 
hardware? 

I can help try to add support for 4.x drivers if anyone is interested. I am an 
experienced developer, though not on Linux, and especially not on device 
drivers. 

Any suggestions appreciated. Thanks,

Shocky
-- 
These are my opinions. Get your own.


From larry.finger at lwfinger.net  Sat Sep 22 01:52:50 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 21 Sep 2007 18:52:50 -0500
Subject: Can't get wireless working with bcm43xx driver
In-Reply-To: <200709211727.49147.shocky1@users.sourceforge.net>
References: <200709211727.49147.shocky1@users.sourceforge.net>
Message-ID: <46F45952.3020605@lwfinger.net>

Shocky wrote:
> Hi,
> 
> I recently bought an HP Pavilion dv2412ca laptop, which came with Vista 
> pre-installed. I backed it up, then reformatted and installed Mandriva 
> 2007.1. 
> 
> The laptop has a builtin wireless card that lspci identifies as a "Broadcom 
> Corporation Dell Wireless 1390 WLAN Mini-PCI Card (rev 02)". I couldn't get 
> it working with either bcm43xx or ndiswrapper using the Vista driver. 
> 
> I got an XP driver for it from the HP support web site (sp34152.exe), and was 
> able to extract it using wine. I still couldn't get it to work with bcm43xx, 
> but I got it sort of working with ndiswrapper. I say "sort of" because it was 
> very flakey. It would usually connect when I first booted if the AP was 
> within reach, but if it lost the signal there was no way to make it reconnect 
> other than rebooting, and it wouldn't reconnect after suspend. This was with 
> Mandriva's 2.6.17-13 kernel, and wireless_tools version 28. I upgraded the 
> kernel to 2.6.17-15 (the latest available for 2007.1), but that didn't help.
> 
> Now I'm trying again with bcm43xx. I downloaded the source tarball for 2.6.22 
> from kernel.org and built a custom kernel (and I turned on wireless and 
> bcm43xx debugging while I was at it). I also got an SRPM from Mandriva cooker 
> for wireless_tools version 29 and built and installed it. 
> 
> lspci -vn gives me:
> 
> 01:00.0 0280: 14e4:4311 (rev 02)
> 	Subsystem: 103c:1374
> 	Flags: bus master, fast devsel, latency 0, IRQ 20
> 	Memory at c3000000 (64-bit, non-prefetchable) [size=16K]
> 	Capabilities: [40] Power Management version 3
> 	Capabilities: [58] Vendor Specific Information
> 	Capabilities: [e8] Message Signalled Interrupts: Mask- 64bit+ Queue=0/0 
> Enable-
> 	Capabilities: [d0] Express Endpoint IRQ 0
> 	Capabilities: [100] Advanced Error Reporting
> 	Capabilities: [13c] Virtual Channel
> 	Capabilities: [160] Device Serial Number 1a-00-5c-ff-ff-73-3d-b9
> 	Capabilities: [16c] Power Budgeting

..snip..

> ...
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Chip ID 0x4311, rev 0x2
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Number of cores: 4
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 
> 0x4243
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 
> 0x4243
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Unsupported 80211 core revision 13

The above message is pretty clear. We don't support that 80211 core revision (yet). It will not be
properly supported until our reverse engineers have a chance to find out what special programming is
needed for that device. It may, or may not work. I have no way to predict that.

> ...
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: PHY connected
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: Microcode rev 0x173, pl 0x425 
> (2006-10-04  21:02:04)
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: Firmware: no support for microcode 
> extracted from version 4.x binary drivers.

You need to get a version 3.x driver to use bcm43xx. The place to get one is listed below.

> These "core up ... failed" messages continue to appear in the log once per 
> second. I suspect the message about version 4.x drivers not being supported 
> is the problem.

Only part of the problem, but a killer for sure.

> If I try to bring up the interface manually, I get the error "SIOCSIFFLAGS: 
> Operation not supported".
> 
> Should I try to find an older driver? Is it likely to work with my newer 
> hardware? 

Partially.

> I can help try to add support for 4.x drivers if anyone is interested. I am an 
> experienced developer, though not on Linux, and especially not on device 
> drivers. 

Not needed. In the near future, bcm43xx will be replaced by a driver named b43, which supports V4
firmware.

To get a V3 driver, please go to "http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o". Grab
that driver, extract the firmware, and see what happens. Send the bcm43xx messages from the new trial.

Larry



From gavron at Wetwork.Net  Sat Sep 22 02:00:36 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 21 Sep 2007 17:00:36 -0700
Subject: Can't get wireless working with bcm43xx driver
In-Reply-To: <200709211727.49147.shocky1@users.sourceforge.net>
References: <200709211727.49147.shocky1@users.sourceforge.net>
Message-ID: <46F45B24.7010806@Wetwork.Net>

There are two drivers that support the hardware.  The new one (the one 
you want) that works with mac80211 is b43.  It uses v4 firmware.
The older one (the one you don't want) works with ieee80211softmac is 
b43legacy.  It uses v3 firmware.

I would download the latest wireless-dev kernel (2.6.23-rc6)... build it 
and b43... and run that.  It's what I do on a Dell Latitude with the 
same 4311 card ("1390").

 git clone 
git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-dev.g
it everything
 cd everything
 git checkout -b everything origin/everything
 nice make -j3
 nice make -j3 modules_install
 nice make -j3 install
 [reboot and select kernel 2.6.23-rc6]

Works like a charm for me... has since 2.6.22something.

Ehud

Shocky wrote:
> Hi,
>
> I recently bought an HP Pavilion dv2412ca laptop, which came with Vista 
> pre-installed. I backed it up, then reformatted and installed Mandriva 
> 2007.1. 
>
> The laptop has a builtin wireless card that lspci identifies as a "Broadcom 
> Corporation Dell Wireless 1390 WLAN Mini-PCI Card (rev 02)". I couldn't get 
> it working with either bcm43xx or ndiswrapper using the Vista driver. 
>
> I got an XP driver for it from the HP support web site (sp34152.exe), and was 
> able to extract it using wine. I still couldn't get it to work with bcm43xx, 
> but I got it sort of working with ndiswrapper. I say "sort of" because it was 
> very flakey. It would usually connect when I first booted if the AP was 
> within reach, but if it lost the signal there was no way to make it reconnect 
> other than rebooting, and it wouldn't reconnect after suspend. This was with 
> Mandriva's 2.6.17-13 kernel, and wireless_tools version 28. I upgraded the 
> kernel to 2.6.17-15 (the latest available for 2007.1), but that didn't help.
>
> Now I'm trying again with bcm43xx. I downloaded the source tarball for 2.6.22 
> from kernel.org and built a custom kernel (and I turned on wireless and 
> bcm43xx debugging while I was at it). I also got an SRPM from Mandriva cooker 
> for wireless_tools version 29 and built and installed it. 
>
> lspci -vn gives me:
>
> 01:00.0 0280: 14e4:4311 (rev 02)
> 	Subsystem: 103c:1374
> 	Flags: bus master, fast devsel, latency 0, IRQ 20
> 	Memory at c3000000 (64-bit, non-prefetchable) [size=16K]
> 	Capabilities: [40] Power Management version 3
> 	Capabilities: [58] Vendor Specific Information
> 	Capabilities: [e8] Message Signalled Interrupts: Mask- 64bit+ Queue=0/0 
> Enable-
> 	Capabilities: [d0] Express Endpoint IRQ 0
> 	Capabilities: [100] Advanced Error Reporting
> 	Capabilities: [13c] Virtual Channel
> 	Capabilities: [160] Device Serial Number 1a-00-5c-ff-ff-73-3d-b9
> 	Capabilities: [16c] Power Budgeting
>
> I was able to use bcm43xx-fwcutter (version 006) to extract the firmware from 
> the XP driver into /lib/firmware:
>
> -rw-r--r-- 1 root root  3672 Sep 19 21:22 bcm43xx_initval01.fw
> -rw-r--r-- 1 root root    16 Sep 19 21:22 bcm43xx_initval02.fw
> -rw-r--r-- 1 root root  3672 Sep 19 21:22 bcm43xx_initval03.fw
> -rw-r--r-- 1 root root    16 Sep 19 21:22 bcm43xx_initval04.fw
> -rw-r--r-- 1 root root  2544 Sep 19 21:22 bcm43xx_initval05.fw
> -rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval06.fw
> -rw-r--r-- 1 root root  2544 Sep 19 21:22 bcm43xx_initval07.fw
> -rw-r--r-- 1 root root  2544 Sep 19 21:22 bcm43xx_initval08.fw
> -rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval09.fw
> -rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval10.fw
> -rw-r--r-- 1 root root  2872 Sep 19 21:22 bcm43xx_initval17.fw
> -rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval18.fw
> -rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval19.fw
> -rw-r--r-- 1 root root  2816 Sep 19 21:22 bcm43xx_initval20.fw
> -rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval21.fw
> -rw-r--r-- 1 root root  2824 Sep 19 21:22 bcm43xx_initval22.fw
> -rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval23.fw
> -rw-r--r-- 1 root root  2824 Sep 19 21:22 bcm43xx_initval24.fw
> -rw-r--r-- 1 root root   248 Sep 19 21:22 bcm43xx_initval25.fw
> -rw-r--r-- 1 root root 27360 Sep 19 21:22 bcm43xx_microcode11.fw
> -rw-r--r-- 1 root root 26432 Sep 19 21:22 bcm43xx_microcode13.fw
> -rw-r--r-- 1 root root 19912 Sep 19 21:22 bcm43xx_microcode4.fw
> -rw-r--r-- 1 root root 21944 Sep 19 21:22 bcm43xx_microcode5.fw
> -rw-r--r-- 1 root root  1312 Sep 19 21:22 bcm43xx_pcm4.fw
> -rw-r--r-- 1 root root  1312 Sep 19 21:22 bcm43xx_pcm5.fw
>
> I get the following syslog messages during boot:
>
> Sep 20 15:46:33 rllt01 kernel: ieee80211_crypt: registered algorithm 'NULL'
> Sep 20 15:46:33 rllt01 kernel: ieee80211: 802.11 data/management/control 
> stack, git-1.1.13
> Sep 20 15:46:33 rllt01 kernel: ieee80211: Copyright (C) 2004-2005 Intel 
> Corporation <jketreno at linux.intel.com>
> Sep 20 15:46:33 rllt01 kernel: bcm43xx driver
> ...
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Chip ID 0x4311, rev 0x2
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Number of cores: 4
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 
> 0x4243
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 
> 0x4243
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Unsupported 80211 core revision 13
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Core 2: ID 0x817, rev 0x4, vendor 
> 0x4243
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Core 3: ID 0x820, rev 0x5, vendor 
> 0x4243
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: PHY connected
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Detected PHY: Analog: 4, Type 2, 
> Revision 9
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Invalid PHY Revision 9
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Detected Radio: ID: 2205017f (Manuf: 
> 17f Ver: 2050 Rev: 2)
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Radio turned off
> Sep 20 15:46:33 rllt01 kernel: bcm43xx: Radio turned off
> ...
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: PHY connected
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: Microcode rev 0x173, pl 0x425 
> (2006-10-04  21:02:04)
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: Firmware: no support for microcode 
> extracted from version 4.x binary drivers.
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: core_up for active 802.11 core failed 
> (-95)
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: set security called, .level = 
> 0, .enabled = 0, .encrypt = 0
> Sep 20 15:46:37 rllt01 kernel: SoftMAC: Associate: Scanning for networks 
> first.
> Sep 20 15:46:37 rllt01 kernel: SoftMAC: Associate: failed to initiate scan. Is 
> device up?
> Sep 20 15:46:37 rllt01 kernel: SoftMAC: Canceling existing associate request!
> Sep 20 15:46:37 rllt01 kernel: SoftMAC: Associate: Scanning for networks 
> first.
> Sep 20 15:46:37 rllt01 kernel: SoftMAC: Associate: failed to initiate scan. Is 
> device up?
> Sep 20 15:46:37 rllt01 ifplugd(eth2)[2750]: ifplugd 0.28 initializing.
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: Microcode rev 0x173, pl 0x425 
> (2006-10-04  21:02:04)
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: Firmware: no support for microcode 
> extracted from version 4.x binary drivers.
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: core_up for active 802.11 core failed 
> (-95)
> Sep 20 15:46:37 rllt01 ifplugd(eth2)[2750]: Using interface 
> eth2/00:00:00:1A:73:5C with driver <bcm43xx> (version: 2.6.22-custom1)
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: Microcode rev 0x173, pl 0x425 
> (2006-10-04  21:02:04)
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: Firmware: no support for microcode 
> extracted from version 4.x binary drivers.
> Sep 20 15:46:37 rllt01 kernel: bcm43xx: core_up for active 802.11 core failed 
> (-95)
> Sep 20 15:46:37 rllt01 ifplugd(eth2)[2750]: Using detection mode: SIOCETHTOOL
> Sep 20 15:46:37 rllt01 ifplugd(eth2)[2750]: Initialization complete, link beat 
> not detected.
> Sep 20 15:46:38 rllt01 kernel: bcm43xx: Microcode rev 0x173, pl 0x425 
> (2006-10-04  21:02:04)
> Sep 20 15:46:38 rllt01 kernel: bcm43xx: Firmware: no support for microcode 
> extracted from version 4.x binary drivers.
> Sep 20 15:46:38 rllt01 kernel: bcm43xx: core_up for active 802.11 core failed 
> (-95)
> Sep 20 15:46:38 rllt01 kernel: bcm43xx: Microcode rev 0x173, pl 0x425 
> (2006-10-04  21:02:04)
> Sep 20 15:46:38 rllt01 kernel: bcm43xx: Firmware: no support for microcode 
> extracted from version 4.x binary drivers.
> Sep 20 15:46:38 rllt01 kernel: bcm43xx: core_up for active 802.11 core failed 
> (-95)
>
> These "core up ... failed" messages continue to appear in the log once per 
> second. I suspect the message about version 4.x drivers not being supported 
> is the problem.
>
> If I try to bring up the interface manually, I get the error "SIOCSIFFLAGS: 
> Operation not supported".
>
> Should I try to find an older driver? Is it likely to work with my newer 
> hardware? 
>
> I can help try to add support for 4.x drivers if anyone is interested. I am an 
> experienced developer, though not on Linux, and especially not on device 
> drivers. 
>
> Any suggestions appreciated. Thanks,
>
> Shocky
>   
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070921/fe5938be/attachment.bin>

From gavron at Wetwork.Net  Sat Sep 22 02:02:19 2007
From: gavron at Wetwork.Net (Ehud Gavron)
Date: Fri, 21 Sep 2007 17:02:19 -0700
Subject: Can't get wireless working with bcm43xx driver
In-Reply-To: <46F45B24.7010806@Wetwork.Net>
References: <200709211727.49147.shocky1@users.sourceforge.net>
	<46F45B24.7010806@Wetwork.Net>
Message-ID: <46F45B8B.4020204@Wetwork.Net>



Ehud Gavron wrote:
> There are two drivers that support the hardware.  The new one (the one 
> you want) that works with mac80211 is b43.  It uses v4 firmware.
> The older one (the one you don't want) works with ieee80211softmac is 
> b43legacy.  It uses v3 firmware.
Disregard the rest of my answer... I missed:

Larry Finger wrote:
> The above message is pretty clear. We don't support that 80211 core revision (yet). 
My bad. Your hardware is too new for my suggestion.

Ehud
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/x-pkcs7-signature
Size: 3283 bytes
Desc: S/MIME Cryptographic Signature
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070921/fb76f172/attachment.bin>

From john.j35 at gmail.com  Sat Sep 22 04:52:15 2007
From: john.j35 at gmail.com (John Pierce)
Date: Fri, 21 Sep 2007 21:52:15 -0500
Subject: Lost wireless device?
Message-ID: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>

Hello, I just upgraded fedora 7 to the 2.6.22.5-76 kernel last night.
After the update the ndiswrapper quit working.  So I thought I would
give it another shot with the native driver.  I downloaded the version
3 and 4 firmwares and tried the first time with the b43 driver which
did not work, after modprobing the driver the dmesg out indicated that
the radio was turned off.  I then tried the bcm43xx driver with the
version 3 firmware and it output the same thing the radio was turned
off.

I then reinstalled the ndiswrapper and installed the driver that I had
been using, when I did ndiswrapper -l it indicated that the driver was
installed with an alternate driver of ssb.

Now the wireless still does not work and when I used to see lspci
output 4311 at 00:03:0 now the device is not listed by lspci, it is
like the device has just been removed from the machine.  The machine
is an HP DV9208NR with the Dell wlan mini pcie device.

I have looked in the bios and there are not options to turn it off or
on.  Is it possible that the driver somehow turned the card off
completely or maybe some other explanation.

Thanks for any thoughts or assistance.

-- 
John
Registered Linux User 263680, get counted at
http://counter.li.org


From john.j35 at gmail.com  Sat Sep 22 04:57:53 2007
From: john.j35 at gmail.com (John Pierce)
Date: Fri, 21 Sep 2007 21:57:53 -0500
Subject: Lost wireless device?
Message-ID: <aa73b9a0709211957m136929b4ia818561309cb1535@mail.gmail.com>

Hello, I just upgraded fedora 7 to the 2.6.22.5-76 kernel last night.
After the update the ndiswrapper quit working.  So I thought I would
give it another shot with the native driver.  I downloaded the version
3 and 4 firmwares and tried the first time with the b43 driver which
did not work, after modprobing the driver the dmesg out indicated that
the radio was turned off.  I then tried the bcm43xx driver with the
version 3 firmware and it output the same thing the radio was turned
off.

I then reinstalled the ndiswrapper and installed the driver that I had
been using, when I did ndiswrapper -l it indicated that the driver was
installed with an alternate driver of ssb.

Now the wireless still does not work and when I used to see lspci
output 4311 at 00:03:0 now the device is not listed by lspci, it is
like the device has just been removed from the machine.  The machine
is an HP DV9208NR with the Dell wlan mini pcie device.

I have looked in the bios and there are not options to turn it off or
on.  Is it possible that the driver somehow turned the card off
completely or maybe some other explanation.

Thanks for any thoughts or assistance.

-- 
John
Registered Linux User 263680, get counted at
http://counter.li.org


From larry.finger at lwfinger.net  Sat Sep 22 05:19:11 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 21 Sep 2007 22:19:11 -0500
Subject: Lost wireless device?
In-Reply-To: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>
Message-ID: <46F489AF.2020101@lwfinger.net>

John Pierce wrote:
> Hello, I just upgraded fedora 7 to the 2.6.22.5-76 kernel last night.
> After the update the ndiswrapper quit working.  So I thought I would
> give it another shot with the native driver.  I downloaded the version
> 3 and 4 firmwares and tried the first time with the b43 driver which
> did not work, after modprobing the driver the dmesg out indicated that
> the radio was turned off.  I then tried the bcm43xx driver with the
> version 3 firmware and it output the same thing the radio was turned
> off.

That message really means that the radio has been initialized to the off state. You need to bring
the interface "up" to get the radio on.

Please post _ALL_ the b43 or bcm43xx messages from the output of dmesg.

Larry



From larry.finger at lwfinger.net  Sat Sep 22 06:30:23 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 21 Sep 2007 23:30:23 -0500
Subject: Lost wireless device?
In-Reply-To: <aa73b9a0709212105u524736e7ja9b860a4f2b1b5ab@mail.gmail.com>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>	
	<46F489AF.2020101@lwfinger.net>
	<aa73b9a0709212105u524736e7ja9b860a4f2b1b5ab@mail.gmail.com>
Message-ID: <46F49A5F.8020300@lwfinger.net>

John Pierce wrote:
> Ok, I cannot post that output because ifup wlan0 tells me that the
> device is not present and is delaying the initialization.
> 
> I have two of the laptops that are identical, on my wifes the card is
> still present and shows up as this device from lspci
> 
> 03:00.0 Network controller: Broadcom Corporation Dell Wireless 1390
> WLAN Mini-PCI Card (rev 01)
> 
> However, it no longer shows up in my lspci.  It is like the card died
> or something.
> 

When you reply, always "Reply All". This exchange should be on the list.

I don't know what might have happened to your device. Have you powered it down and pulled the
battery to let it completely reset?

Larry


From john.j35 at gmail.com  Sat Sep 22 06:34:26 2007
From: john.j35 at gmail.com (John Pierce)
Date: Fri, 21 Sep 2007 23:34:26 -0500
Subject: Lost wireless device?
In-Reply-To: <46F49A5F.8020300@lwfinger.net>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>
	<46F489AF.2020101@lwfinger.net>
	<aa73b9a0709212105u524736e7ja9b860a4f2b1b5ab@mail.gmail.com>
	<46F49A5F.8020300@lwfinger.net>
Message-ID: <aa73b9a0709212134k5458b799p146c0bd740fe70a4@mail.gmail.com>

> When you reply, always "Reply All". This exchange should be on the list.
>
> I don't know what might have happened to your device. Have you powered it down and pulled the
> battery to let it completely reset?
>
I apologize for the reply issue.

Yes, I powered the machine down completely and gave it about 2 minutes
unplugged with the battery out.

I opened the case and looked at the card and it does not appear to be
burned or any caps ruptured.  I am considering moving the card from my
wife's machine and then put it in my just for a test.

-- 
John
Registered Linux User 263680, get counted at
http://counter.li.org


From ftoledo at docksud.com.ar  Sun Sep 23 00:44:35 2007
From: ftoledo at docksud.com.ar (Fernando Toledo)
Date: Sat, 22 Sep 2007 19:44:35 -0300
Subject: Out of DMA
Message-ID: <200709221944.37235.ftoledo@docksud.com.ar>

ihi all i have that output from mi bcm4311 
im watting to warranty response, i think that my card is death

bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
printk: 3 messages suppressed.
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Radio hardware status changed to enabled
printk: 7 messages suppressed.
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Out of DMA descriptor slots!
bcm43xx: Radio hardware status changed to disabled
bcm43xx: Radio hardware status changed to enabled

-- 
Dock Sud BBS
http://www.docksud.com.ar
telnet://bbs.docksud.com.ar
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part.
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070922/7c6e3913/attachment.pgp>

From collector10 at gmail.com  Sun Sep 23 05:57:33 2007
From: collector10 at gmail.com (Gmail Collector)
Date: Sat, 22 Sep 2007 20:57:33 -0700
Subject: Greetings
Message-ID: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>

Howdy,

Just joined a few minutes ago and was wondering if there was a search
mechanism on the archives that I may have missed.  I would like to find out
more about an error of "bcm43xx: FATAL ERROR: BCM43xx_IRQ_XMIT_ERROR" in my
dmesg output.  I am unable to locate a method to search the bodies of the
messages, and could find no matches in the subjects.

Thanks,
Gary
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070922/67f90b17/attachment.html>

From larry.finger at lwfinger.net  Sun Sep 23 06:19:53 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 22 Sep 2007 23:19:53 -0500
Subject: Greetings
In-Reply-To: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>
Message-ID: <46F5E969.40901@lwfinger.net>

Gmail Collector wrote:
> Howdy,
> 
> Just joined a few minutes ago and was wondering if there was a search
> mechanism on the archives that I may have missed.  I would like to find
> out more about an error of "bcm43xx: FATAL ERROR:
> BCM43xx_IRQ_XMIT_ERROR" in my dmesg output.  I am unable to locate a
> method to search the bodies of the messages, and could find no matches
> in the subjects.

I don't know about searching the archives, but that error usually means a problem with the firmware.
Has this interface worked in the past, or are you just getting started?

Please post the results of 'dmesg | grep bcm'.

Larry


From collector10 at gmail.com  Sun Sep 23 08:06:52 2007
From: collector10 at gmail.com (Gmail Collector)
Date: Sat, 22 Sep 2007 23:06:52 -0700
Subject: Greetings
In-Reply-To: <46F5E969.40901@lwfinger.net>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>
	<46F5E969.40901@lwfinger.net>
Message-ID: <8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>

Results of dmesg:

$ dmesg | grep bcm
bcm43xx driver
bcm43xx: Chip ID 0x4311, rev 0x2
bcm43xx: Number of cores: 4
bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 0x4243
bcm43xx: Unsupported 80211 core revision 13
bcm43xx: Core 2: ID 0x817, rev 0x4, vendor 0x4243
bcm43xx: Core 3: ID 0x820, rev 0x5, vendor 0x4243
bcm43xx: PHY connected
bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 9
bcm43xx: Invalid PHY Revision 9
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
bcm43xx: Radio turned off
bcm43xx: Radio turned off
bcm43xx: PHY connected
bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
bcm43xx: Radio turned on
bcm43xx: Radio enabled by hardware
bcm43xx: Chip initialized
bcm43xx: 64-bit DMA initialized
bcm43xx: Keys cleared
bcm43xx: Selected 802.11 core (phytype 2)
bcm43xx: FATAL ERROR: BCM43xx_IRQ_XMIT_ERROR
bcm43xx: MAC suspend failed
bcm43xx: MAC suspend failed

did you need any further?

Gary



On 9/22/07, Larry Finger <larry.finger at lwfinger.net> wrote:
>
> Gmail Collector wrote:
> > Howdy,
> >
> > Just joined a few minutes ago and was wondering if there was a search
> > mechanism on the archives that I may have missed.  I would like to find
> > out more about an error of "bcm43xx: FATAL ERROR:
> > BCM43xx_IRQ_XMIT_ERROR" in my dmesg output.  I am unable to locate a
> > method to search the bodies of the messages, and could find no matches
> > in the subjects.
>
> I don't know about searching the archives, but that error usually means a
> problem with the firmware.
> Has this interface worked in the past, or are you just getting started?
>
> Please post the results of 'dmesg | grep bcm'.
>
> Larry
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070922/cd51f5f4/attachment.html>

From collector10 at gmail.com  Sun Sep 23 08:11:50 2007
From: collector10 at gmail.com (Gmail Collector)
Date: Sat, 22 Sep 2007 23:11:50 -0700
Subject: Greetings
In-Reply-To: <8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>
	<46F5E969.40901@lwfinger.net>
	<8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>
Message-ID: <8353a5d0709222311o7039a4ffkb0834ab4408fb825@mail.gmail.com>

oops, sorry, wrong button... sorry for premature send.

new install; new equipment.

card kind of works with windows vista, but problem there is a known bug with
vista

Gary



On 9/22/07, Gmail Collector <collector10 at gmail.com> wrote:
>
> Results of dmesg:
>
> $ dmesg | grep bcm
> bcm43xx driver
> bcm43xx: Chip ID 0x4311, rev 0x2
> bcm43xx: Number of cores: 4
> bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 0x4243
> bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 0x4243
> bcm43xx: Unsupported 80211 core revision 13
> bcm43xx: Core 2: ID 0x817, rev 0x4, vendor 0x4243
> bcm43xx: Core 3: ID 0x820, rev 0x5, vendor 0x4243
> bcm43xx: PHY connected
> bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 9
> bcm43xx: Invalid PHY Revision 9
> bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> bcm43xx: Radio turned off
> bcm43xx: Radio turned off
> bcm43xx: PHY connected
> bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
> bcm43xx: Radio turned on
> bcm43xx: Radio enabled by hardware
> bcm43xx: Chip initialized
> bcm43xx: 64-bit DMA initialized
> bcm43xx: Keys cleared
> bcm43xx: Selected 802.11 core (phytype 2)
> bcm43xx: FATAL ERROR: BCM43xx_IRQ_XMIT_ERROR
> bcm43xx: MAC suspend failed
> bcm43xx: MAC suspend failed
>
> did you need any further?
>
> Gary
>
>
>
> On 9/22/07, Larry Finger < larry.finger at lwfinger.net> wrote:
> >
> > Gmail Collector wrote:
> > > Howdy,
> > >
> > > Just joined a few minutes ago and was wondering if there was a search
> > > mechanism on the archives that I may have missed.  I would like to
> > find
> > > out more about an error of "bcm43xx: FATAL ERROR:
> > > BCM43xx_IRQ_XMIT_ERROR" in my dmesg output.  I am unable to locate a
> > > method to search the bodies of the messages, and could find no matches
> > > in the subjects.
> >
> > I don't know about searching the archives, but that error usually means
> > a problem with the firmware.
> > Has this interface worked in the past, or are you just getting started?
> >
> > Please post the results of 'dmesg | grep bcm'.
> >
> > Larry
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070922/5fe97248/attachment.html>

From larry.finger at lwfinger.net  Sun Sep 23 08:53:20 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 23 Sep 2007 01:53:20 -0500
Subject: Greetings
In-Reply-To: <8353a5d0709222311o7039a4ffkb0834ab4408fb825@mail.gmail.com>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>	
	<46F5E969.40901@lwfinger.net>	
	<8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>
	<8353a5d0709222311o7039a4ffkb0834ab4408fb825@mail.gmail.com>
Message-ID: <46F60D60.6010807@lwfinger.net>

Gmail Collector wrote:
> oops, sorry, wrong button... sorry for premature send.
> 
> new install; new equipment.
> 
> card kind of works with windows vista, but problem there is a known bug
> with vista
> 
> Gary
> 
> 
> 
> On 9/22/07, *Gmail Collector* <collector10 at gmail.com
> <mailto:collector10 at gmail.com>> wrote:
> 
>     Results of dmesg:
> 
>     $ dmesg | grep bcm
>     bcm43xx driver
>     bcm43xx: Chip ID 0x4311, rev 0x2
>     bcm43xx: Number of cores: 4
>     bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 0x4243
>     bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 0x4243
>     bcm43xx: Unsupported 80211 core revision 13
>     bcm43xx: Core 2: ID 0x817, rev 0x4, vendor 0x4243
>     bcm43xx: Core 3: ID 0x820, rev 0x5, vendor 0x4243
>     bcm43xx: PHY connected
>     bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 9
>     bcm43xx: Invalid PHY Revision 9                                         <=================
>     bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
>     bcm43xx: Radio turned off
>     bcm43xx: Radio turned off
>     bcm43xx: PHY connected
>     bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
>     bcm43xx: Radio turned on
>     bcm43xx: Radio enabled by hardware
>     bcm43xx: Chip initialized
>     bcm43xx: 64-bit DMA initialized
>     bcm43xx: Keys cleared
>     bcm43xx: Selected 802.11 core (phytype 2)
>     bcm43xx: FATAL ERROR: BCM43xx_IRQ_XMIT_ERROR
>     bcm43xx: MAC suspend failed
>     bcm43xx: MAC suspend failed
> 
>     did you need any further?

No. The problem is seen above - an unsupported PHY revision.

The reverse engineers have not worked out the details required to support PHY revision greater than
8. The only slight possibility of using it in the near future would be to grab the source from the
wireless-dev git tree and try the b43 driver, which uses V4 firmware; however, even with that
version, the code will have to be modified. As even Broadcom is having problems with this version in
Vista, the prognosis isn't too good.

You should investigate the possibility of acquiring a BCM4311/1 PCIe card to replace the BCM4311/2.

Larry


From mansour77 at yahoo.com  Sun Sep 23 21:20:31 2007
From: mansour77 at yahoo.com (Mansour)
Date: Sun, 23 Sep 2007 16:20:31 -0300
Subject: Greetings
In-Reply-To: <46F60D60.6010807@lwfinger.net>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>		<46F5E969.40901@lwfinger.net>		<8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>	<8353a5d0709222311o7039a4ffkb0834ab4408fb825@mail.gmail.com>
	<46F60D60.6010807@lwfinger.net>
Message-ID: <46F6BC7F.9080607@yahoo.com>

I am facing the same issue.

dmesg | grep bcm
bcm43xx driver
bcm43xx: Chip ID 0x4311, rev 0x2
bcm43xx: Number of cores: 4
bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 0x4243
bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 0x4243
bcm43xx: Unsupported 80211 core revision 13
bcm43xx: Core 2: ID 0x817, rev 0x4, vendor 0x4243
bcm43xx: Core 3: ID 0x820, rev 0x5, vendor 0x4243
bcm43xx: PHY connected
bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 9
bcm43xx: Invalid PHY Revision 9
bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
bcm43xx: Radio turned off
bcm43xx: Radio turned off
bcm43xx: PHY connected
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
failed.
bcm43xx: core_up for active 802.11 core failed (-2)
bcm43xx: set security called, .level = 0, .enabled = 0, .encrypt = 0
bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load 
failed.
bcm43xx: core_up for active 802.11 core failed (-2)

I have used b43 to extract the firmware. Now I don't know what to do 
next. My card works fine with Vista.
The new b43 fw-cutter works only with the binaries that are supplied by 
openwrt. I tried to use bcmwl6.sys that came with the pre installed 
vista, but it didn't work. I am using kernel 2.6.22.2

I really need an advice about how to get this to work, as it's really 
frustrating.

Thank you.


Larry Finger wrote:
> Gmail Collector wrote:
>   
>> oops, sorry, wrong button... sorry for premature send.
>>
>> new install; new equipment.
>>
>> card kind of works with windows vista, but problem there is a known bug
>> with vista
>>
>> Gary
>>
>>
>>
>> On 9/22/07, *Gmail Collector* <collector10 at gmail.com
>> <mailto:collector10 at gmail.com>> wrote:
>>
>>     Results of dmesg:
>>
>>     $ dmesg | grep bcm
>>     bcm43xx driver
>>     bcm43xx: Chip ID 0x4311, rev 0x2
>>     bcm43xx: Number of cores: 4
>>     bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 0x4243
>>     bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 0x4243
>>     bcm43xx: Unsupported 80211 core revision 13
>>     bcm43xx: Core 2: ID 0x817, rev 0x4, vendor 0x4243
>>     bcm43xx: Core 3: ID 0x820, rev 0x5, vendor 0x4243
>>     bcm43xx: PHY connected
>>     bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 9
>>     bcm43xx: Invalid PHY Revision 9                                         <=================
>>     bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
>>     bcm43xx: Radio turned off
>>     bcm43xx: Radio turned off
>>     bcm43xx: PHY connected
>>     bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
>>     bcm43xx: Radio turned on
>>     bcm43xx: Radio enabled by hardware
>>     bcm43xx: Chip initialized
>>     bcm43xx: 64-bit DMA initialized
>>     bcm43xx: Keys cleared
>>     bcm43xx: Selected 802.11 core (phytype 2)
>>     bcm43xx: FATAL ERROR: BCM43xx_IRQ_XMIT_ERROR
>>     bcm43xx: MAC suspend failed
>>     bcm43xx: MAC suspend failed
>>
>>     did you need any further?
>>     
>
> No. The problem is seen above - an unsupported PHY revision.
>
> The reverse engineers have not worked out the details required to support PHY revision greater than
> 8. The only slight possibility of using it in the near future would be to grab the source from the
> wireless-dev git tree and try the b43 driver, which uses V4 firmware; however, even with that
> version, the code will have to be modified. As even Broadcom is having problems with this version in
> Vista, the prognosis isn't too good.
>
> You should investigate the possibility of acquiring a BCM4311/1 PCIe card to replace the BCM4311/2.
>
> Larry
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>
>   



From larry.finger at lwfinger.net  Sun Sep 23 21:54:10 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 23 Sep 2007 14:54:10 -0500
Subject: Greetings
In-Reply-To: <8353a5d0709231224g673543a4t940750c39302ebdf@mail.gmail.com>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>	
	<46F5E969.40901@lwfinger.net>	
	<8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>	
	<8353a5d0709222311o7039a4ffkb0834ab4408fb825@mail.gmail.com>	
	<46F60D60.6010807@lwfinger.net>	
	<8353a5d0709230023q768d9001y9f094f8e36682fbd@mail.gmail.com>	
	<46F6790A.9010103@lwfinger.net>
	<8353a5d0709231224g673543a4t940750c39302ebdf@mail.gmail.com>
Message-ID: <46F6C462.2070102@lwfinger.net>

Gmail Collector wrote:
> 
> 
> On 9/23/07, *Larry Finger* <larry.finger at lwfinger.net
> <mailto:larry.finger at lwfinger.net>> wrote:
> 
>     Gmail Collector wrote:
>     > ok, tx for the help, I'll start shopping...
> 
>     How does this card announce itself in a 'lspci -v' output? Is it a
>     DELL 1390 or something else?
> 
>     When you find a replacement for the card, would you consider loaning
>     it to the bcm43xx project?
>     These cards are becoming rather common, and we should be working to
>     support it.
> 
>     Larry
> 
> 
> 
> lspci -v
> 
> 03:00.0 Network controller: Broadcom Corporation Dell Wireless 1390 WLAN
> Mini-PCI Card (rev 02)
>         Subsystem: Hewlett-Packard Company Unknown device 1374
>         Flags: bus master, fast devsel, latency 0, IRQ 9
>         Memory at b6000000 (64-bit, non-prefetchable) [size=16K]
>         Capabilities: [40] Power Management version 3
>         Capabilities: [58] Vendor Specific Information
>         Capabilities: [e8] Message Signalled Interrupts: Mask- 64bit+
> Queue=0/0 Enable-
>         Capabilities: [d0] Express Endpoint IRQ 0
>         Capabilities: [100] Advanced Error Reporting
>         Capabilities: [13c] Virtual Channel
>         Capabilities: [160] Device Serial Number 1a-00-64-ff-ff-73-ce-95
>         Capabilities: [16c] Power Budgeting
> 
> The big difference that I see is (rev 2).  I tried googleing it, with no
> results, so i imagine it is quite new.
> Do you need any further such as a lspci -vv , uname, lsmod, iwconfig or
> any of that other stuff?

No, that is sufficient. Your card is a rev 02 DW1390. For others reading this message, that card
does not work, but a rev 01 does.

Larry


From larry.finger at lwfinger.net  Sun Sep 23 22:39:23 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 23 Sep 2007 15:39:23 -0500
Subject: Greetings
In-Reply-To: <46F6BC7F.9080607@yahoo.com>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>		<46F5E969.40901@lwfinger.net>		<8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>	<8353a5d0709222311o7039a4ffkb0834ab4408fb825@mail.gmail.com>
	<46F60D60.6010807@lwfinger.net> <46F6BC7F.9080607@yahoo.com>
Message-ID: <46F6CEFB.1000109@lwfinger.net>

Mansour wrote:
> I am facing the same issue.
> 
> dmesg | grep bcm
> bcm43xx driver
> bcm43xx: Chip ID 0x4311, rev 0x2
> bcm43xx: Number of cores: 4
> bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 0x4243
> bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 0x4243
> bcm43xx: Unsupported 80211 core revision 13
> bcm43xx: Core 2: ID 0x817, rev 0x4, vendor 0x4243
> bcm43xx: Core 3: ID 0x820, rev 0x5, vendor 0x4243
> bcm43xx: PHY connected
> bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 9
> bcm43xx: Invalid PHY Revision 9
> bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> bcm43xx: Radio turned off
> bcm43xx: Radio turned off
> bcm43xx: PHY connected
> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load
> failed.
> bcm43xx: core_up for active 802.11 core failed (-2)
> bcm43xx: set security called, .level = 0, .enabled = 0, .encrypt = 0
> bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load
> failed.
> bcm43xx: core_up for active 802.11 core failed (-2)
> 
> I have used b43 to extract the firmware. Now I don't know what to do
> next. My card works fine with Vista.
> The new b43 fw-cutter works only with the binaries that are supplied by
> openwrt. I tried to use bcmwl6.sys that came with the pre installed
> vista, but it didn't work. I am using kernel 2.6.22.2
> 
> I really need an advice about how to get this to work, as it's really
> frustrating.

To extract firmware for bcm43xx, you need a V3 driver and bcm43xx-fwcutter.

To extract firmware for b43legacy, you need b43-fwcutter and the V3 driver from
http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o.

To extract firmware for b43, you need b43-fwcutter and the V4 driver from
http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2.

Until the reverse engineers get a chance to look at decompiled code for the rev 9 PHYs, write the
specs, and the code developers can turn those specs into code, it is unlikely that your device will
work. As I stated earlier on this mailing list, your device will never work with bcm43xx. If you
were to get the source code from the wireless-dev git tree, and make a necessary modification, there
is only a slight chance that it might work. Without one to test, there isn't much we can do.

There are 6 DW1390 cards for sale on E-Bay with "Buy-it-now" prices up to $30 + shipping. One must
be careful that it is a rev 1 and not a rev 2.

Larry



From harry.wert at gmail.com  Mon Sep 24 01:06:39 2007
From: harry.wert at gmail.com (Harry Wert)
Date: Sun, 23 Sep 2007 19:06:39 -0400
Subject: Greetings
In-Reply-To: <46F6BC7F.9080607@yahoo.com>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>
	<46F5E969.40901@lwfinger.net>
	<8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>
	<8353a5d0709222311o7039a4ffkb0834ab4408fb825@mail.gmail.com>
	<46F60D60.6010807@lwfinger.net>  <46F6BC7F.9080607@yahoo.com>
Message-ID: <1190588799.6420.15.camel@gutsy-hp>



> Larry Finger wrote:
> > Gmail Collector wrote:
> >   
> >> oops, sorry, wrong button... sorry for premature send.
> >>
> >> new install; new equipment.
> >>
> >> card kind of works with windows vista, but problem there is a known bug
> >> with vista
> >>
> >> Gary
> >>
> >>
> >>
> >> On 9/22/07, *Gmail Collector* <collector10 at gmail.com
> >> <mailto:collector10 at gmail.com>> wrote:
> >>
> >>     Results of dmesg:
> >>
> >>     $ dmesg | grep bcm
> >>     bcm43xx driver
> >>     bcm43xx: Chip ID 0x4311, rev 0x2
> >>     bcm43xx: Number of cores: 4
> >>     bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 0x4243
> >>     bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 0x4243
> >>     bcm43xx: Unsupported 80211 core revision 13
> >>     bcm43xx: Core 2: ID 0x817, rev 0x4, vendor 0x4243
> >>     bcm43xx: Core 3: ID 0x820, rev 0x5, vendor 0x4243
> >>     bcm43xx: PHY connected
> >>     bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 9
> >>     bcm43xx: Invalid PHY Revision 9                                         <=================
> >>     bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> >>     bcm43xx: Radio turned off
> >>     bcm43xx: Radio turned off
> >>     bcm43xx: PHY connected
> >>     bcm43xx: Microcode rev 0x127, pl 0xe (2005-04-18  02:36:27)
> >>     bcm43xx: Radio turned on
> >>     bcm43xx: Radio enabled by hardware
> >>     bcm43xx: Chip initialized
> >>     bcm43xx: 64-bit DMA initialized
> >>     bcm43xx: Keys cleared
> >>     bcm43xx: Selected 802.11 core (phytype 2)
> >>     bcm43xx: FATAL ERROR: BCM43xx_IRQ_XMIT_ERROR
> >>     bcm43xx: MAC suspend failed
> >>     bcm43xx: MAC suspend failed
> >>
> >>     did you need any further?
> >>     
> >
> > No. The problem is seen above - an unsupported PHY revision.
> >
> > The reverse engineers have not worked out the details required to support PHY revision greater than
> > 8. The only slight possibility of using it in the near future would be to grab the source from the
> > wireless-dev git tree and try the b43 driver, which uses V4 firmware; however, even with that
> > version, the code will have to be modified. As even Broadcom is having problems with this version in
> > Vista, the prognosis isn't too good.
> >
> > You should investigate the possibility of acquiring a BCM4311/1 PCIe card to replace the BCM4311/2.
> >
> > Larry

==================================

Don't know if this will help but it might. I am using a HP Pavillion
dv9210 with AMD dual processor 64bit and 2G memory.  It contains a
Broadcom Corporation BCM94311 MCG wlan mini-pci card which states it is
rev 01. It worked well with feisty and works well on gutsy EXCEPT on my
7mb DSL the maximum speed I can get is 118 kbs with gutsy, while it
provided 6 mbs with feisty.

I have been following this thread with interest and have just downloaded
broadcom-wl-4.80.53.0, used  bcm43xx-fwcutter to extract and install the
firmware which produced no error messages.  I rebooted and ran another
internet download speed test but am still stuck at 118 kbs.
The kernel is: "2.6.22-12-generic #1 SMP Sat Sep 22 18:14:28 GMT 2007
i686 GNU/Linux".

Hope this is helpful...

Harry wert
Physicist




From larry.finger at lwfinger.net  Mon Sep 24 01:16:23 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 23 Sep 2007 18:16:23 -0500
Subject: Greetings
In-Reply-To: <1190588799.6420.15.camel@gutsy-hp>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>	
	<46F5E969.40901@lwfinger.net>	
	<8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>	
	<8353a5d0709222311o7039a4ffkb0834ab4408fb825@mail.gmail.com>	
	<46F60D60.6010807@lwfinger.net> <46F6BC7F.9080607@yahoo.com>
	<1190588799.6420.15.camel@gutsy-hp>
Message-ID: <46F6F3C7.6050906@lwfinger.net>

Harry Wert wrote:
> Don't know if this will help but it might. I am using a HP Pavillion
> dv9210 with AMD dual processor 64bit and 2G memory.  It contains a
> Broadcom Corporation BCM94311 MCG wlan mini-pci card which states it is
> rev 01. It worked well with feisty and works well on gutsy EXCEPT on my
> 7mb DSL the maximum speed I can get is 118 kbs with gutsy, while it
> provided 6 mbs with feisty.
> 
> I have been following this thread with interest and have just downloaded
> broadcom-wl-4.80.53.0, used  bcm43xx-fwcutter to extract and install the
> firmware which produced no error messages.  I rebooted and ran another
> internet download speed test but am still stuck at 118 kbs.
> The kernel is: "2.6.22-12-generic #1 SMP Sat Sep 22 18:14:28 GMT 2007
> i686 GNU/Linux".
> 

The rev 01 cards work fine for most people. It is the rev02 ones that are a problem.

As I have stated many times, bcm43xx uses V3 firmware. Getting the V4 driver you listed above will
do nothing for you.

I have no idea what is wrong with that kernel. What information comes from 'dmesg | grep bcm'?

Larry


From larry.finger at lwfinger.net  Mon Sep 24 01:58:52 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 23 Sep 2007 18:58:52 -0500
Subject: Greetings
In-Reply-To: <1190590281.6420.18.camel@gutsy-hp>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>	
	<46F5E969.40901@lwfinger.net>	
	<8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>	
	<8353a5d0709222311o7039a4ffkb0834ab4408fb825@mail.gmail.com>	
	<46F60D60.6010807@lwfinger.net> <46F6BC7F.9080607@yahoo.com>	
	<1190588799.6420.15.camel@gutsy-hp> <46F6F3C7.6050906@lwfinger.net>
	<1190590281.6420.18.camel@gutsy-hp>
Message-ID: <46F6FDBC.40200@lwfinger.net>

Harry Wert wrote:
>> The rev 01 cards work fine for most people. It is the rev02 ones that are a problem.
>>
>> As I have stated many times, bcm43xx uses V3 firmware. Getting the V4 driver you listed above will
>> do nothing for you.
>>
>> I have no idea what is wrong with that kernel. What information comes from 'dmesg | grep bcm'?
>>
>> Larry
> 
> harry at gutsy-hp:~$ dmesg |grep bcm
> [   18.804000] bcm43xx driver

They didn't turn debugging on. At least your firmware is loading OK.

What you need to do is go to www.kernel.org, download and unpack 2.6.22.7, or whatever the latest
version is at the time you do it. Untar it, change to that directory, and 'make oldconfig', then
'make', and 'sudo make modules_install install'. Depending on what your distro wants, you may also
need to 'sudo mkinitrd'. These steps will get you a kernel that should work.

Larry


From collector10 at gmail.com  Mon Sep 24 02:38:20 2007
From: collector10 at gmail.com (Gmail Collector)
Date: Sun, 23 Sep 2007 17:38:20 -0700
Subject: Greetings
In-Reply-To: <46F6CEFB.1000109@lwfinger.net>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>
	<46F5E969.40901@lwfinger.net>
	<8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>
	<8353a5d0709222311o7039a4ffkb0834ab4408fb825@mail.gmail.com>
	<46F60D60.6010807@lwfinger.net> <46F6BC7F.9080607@yahoo.com>
	<46F6CEFB.1000109@lwfinger.net>
Message-ID: <8353a5d0709231738w58940a26uf0f570f45092cdbe@mail.gmail.com>

On 9/23/07, Larry Finger <larry.finger at lwfinger.net> wrote:
>
> Mansour wrote:
> > I am facing the same issue.
> >
> > dmesg | grep bcm
> > bcm43xx driver
> > bcm43xx: Chip ID 0x4311, rev 0x2
> > bcm43xx: Number of cores: 4
> > bcm43xx: Core 0: ID 0x800, rev 0x13, vendor 0x4243
> > bcm43xx: Core 1: ID 0x812, rev 0xd, vendor 0x4243
> > bcm43xx: Unsupported 80211 core revision 13
> > bcm43xx: Core 2: ID 0x817, rev 0x4, vendor 0x4243
> > bcm43xx: Core 3: ID 0x820, rev 0x5, vendor 0x4243
> > bcm43xx: PHY connected
> > bcm43xx: Detected PHY: Analog: 4, Type 2, Revision 9
> > bcm43xx: Invalid PHY Revision 9
> > bcm43xx: Detected Radio: ID: 2205017f (Manuf: 17f Ver: 2050 Rev: 2)
> > bcm43xx: Radio turned off
> > bcm43xx: Radio turned off
> > bcm43xx: PHY connected
> > bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load
> > failed.
> > bcm43xx: core_up for active 802.11 core failed (-2)
> > bcm43xx: set security called, .level = 0, .enabled = 0, .encrypt = 0
> > bcm43xx: Error: Microcode "bcm43xx_microcode5.fw" not available or load
> > failed.
> > bcm43xx: core_up for active 802.11 core failed (-2)
> >
> > I have used b43 to extract the firmware. Now I don't know what to do
> > next. My card works fine with Vista.
> > The new b43 fw-cutter works only with the binaries that are supplied by
> > openwrt. I tried to use bcmwl6.sys that came with the pre installed
> > vista, but it didn't work. I am using kernel 2.6.22.2
> >
> > I really need an advice about how to get this to work, as it's really
> > frustrating.
>
> To extract firmware for bcm43xx, you need a V3 driver and
> bcm43xx-fwcutter.
>
> To extract firmware for b43legacy, you need b43-fwcutter and the V3 driver
> from
> http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o.
>
> To extract firmware for b43, you need b43-fwcutter and the V4 driver from
> http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2.
>
> Until the reverse engineers get a chance to look at decompiled code for
> the rev 9 PHYs, write the
> specs, and the code developers can turn those specs into code, it is
> unlikely that your device will
> work. As I stated earlier on this mailing list, your device will never
> work with bcm43xx. If you
> were to get the source code from the wireless-dev git tree, and make a
> necessary modification, there
> is only a slight chance that it might work. Without one to test, there
> isn't much we can do.
>
> There are 6 DW1390 cards for sale on E-Bay with "Buy-it-now" prices up to
> $30 + shipping. One must
> be careful that it is a rev 1 and not a rev 2.
>
> Larry
>
>
Pardon my ignorance please, but how would one know what rev # the card is?
The ones I see on ebay seem to show a fairly close view of the label, but
I'm not sure what I,m looking for.  For example, is REV A02 = (rev 02)? The
only way I knew what rev # mine was, was the lspci command, I haven't looked
at my card yet, as I was checking ndiswrapper possibilities in the interim.

Gary
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070923/d39f7465/attachment.html>

From collector10 at gmail.com  Mon Sep 24 02:51:49 2007
From: collector10 at gmail.com (Gmail Collector)
Date: Sun, 23 Sep 2007 17:51:49 -0700
Subject: drivers
Message-ID: <8353a5d0709231751s6cc4edd8redc6a581dabd57ee@mail.gmail.com>

Not being a reverse engineer, nor any kind of engineer for that matter, I
was wondering if the driver files for the (rev 02) from my Vista would help
in any way?  If so, I'd be happy to send them as an attachment.


Gary
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070923/e7f2a935/attachment.html>

From john.j35 at gmail.com  Mon Sep 24 02:56:50 2007
From: john.j35 at gmail.com (John Pierce)
Date: Sun, 23 Sep 2007 19:56:50 -0500
Subject: Lost wireless device?
In-Reply-To: <aa73b9a0709212134k5458b799p146c0bd740fe70a4@mail.gmail.com>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>
	<46F489AF.2020101@lwfinger.net>
	<aa73b9a0709212105u524736e7ja9b860a4f2b1b5ab@mail.gmail.com>
	<46F49A5F.8020300@lwfinger.net>
	<aa73b9a0709212134k5458b799p146c0bd740fe70a4@mail.gmail.com>
Message-ID: <aa73b9a0709231756y38a364c2jcaf8135663f0de8c@mail.gmail.com>

Ok, to revisit this issue for a little while.  I powered down my
lappy, removed the pcie wireless card and then place that card in my
wife's identical machine and behold it shows up as the correct device
and functions.

I placed the card from my wife's machine in my machine and booted up,
did lspci and it does not appear in the list of device.

I have searched the bios thoroughly and have found no option to turn
on/off the wireless card.  The only thing I have is a switch on the
front of the machine that will turn off the radio.

I have also regressed back to the previous kernel that worked with my
system and is the one on my wife's computer.  Kernel Version
2.6.22.4-65.fc7

Is there something in the b43/bcm43xx code or firmware that could have
disabled the bios support for the card?

Any thoughts or ideas.

-- 
John
Registered Linux User 263680, get counted at
http://counter.li.org


From larry.finger at lwfinger.net  Mon Sep 24 03:23:49 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 23 Sep 2007 20:23:49 -0500
Subject: Greetings
In-Reply-To: <8353a5d0709231738w58940a26uf0f570f45092cdbe@mail.gmail.com>
References: <8353a5d0709222057q72d2a27yf0976b8ab658f19c@mail.gmail.com>	
	<46F5E969.40901@lwfinger.net>	
	<8353a5d0709222306x22f9f11fyc10fb09377242eec@mail.gmail.com>	
	<8353a5d0709222311o7039a4ffkb0834ab4408fb825@mail.gmail.com>	
	<46F60D60.6010807@lwfinger.net> <46F6BC7F.9080607@yahoo.com>	
	<46F6CEFB.1000109@lwfinger.net>
	<8353a5d0709231738w58940a26uf0f570f45092cdbe@mail.gmail.com>
Message-ID: <46F711A5.9050308@lwfinger.net>

Gmail Collector wrote:
> 
> 
> Pardon my ignorance please, but how would one know what rev # the card
> is?  The ones I see on ebay seem to show a fairly close view of the
> label, but I'm not sure what I,m looking for.  For example, is REV A02 =
> (rev 02)? The only way I knew what rev # mine was, was the lspci
> command, I haven't looked at my card yet, as I was checking ndiswrapper
> possibilities in the interim.

What I would do is send the seller an E-mail asking which version the card is. If they come back and
say they don't know, then ask them to put it in a computer, boot any Linux live CD, and do an lspci.
I'm sure we could tell from the S/N, but I don't know the code.

Larry


From larry.finger at lwfinger.net  Mon Sep 24 03:32:40 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sun, 23 Sep 2007 20:32:40 -0500
Subject: Lost wireless device?
In-Reply-To: <aa73b9a0709231756y38a364c2jcaf8135663f0de8c@mail.gmail.com>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>	
	<46F489AF.2020101@lwfinger.net>	
	<aa73b9a0709212105u524736e7ja9b860a4f2b1b5ab@mail.gmail.com>	
	<46F49A5F.8020300@lwfinger.net>	
	<aa73b9a0709212134k5458b799p146c0bd740fe70a4@mail.gmail.com>
	<aa73b9a0709231756y38a364c2jcaf8135663f0de8c@mail.gmail.com>
Message-ID: <46F713B8.5030806@lwfinger.net>

John Pierce wrote:
> Ok, to revisit this issue for a little while.  I powered down my
> lappy, removed the pcie wireless card and then place that card in my
> wife's identical machine and behold it shows up as the correct device
> and functions.
> 
> I placed the card from my wife's machine in my machine and booted up,
> did lspci and it does not appear in the list of device.
> 
> I have searched the bios thoroughly and have found no option to turn
> on/off the wireless card.  The only thing I have is a switch on the
> front of the machine that will turn off the radio.
> 
> I have also regressed back to the previous kernel that worked with my
> system and is the one on my wife's computer.  Kernel Version
> 2.6.22.4-65.fc7
> 
> Is there something in the b43/bcm43xx code or firmware that could have
> disabled the bios support for the card?

The radio on/off switch does not control access to the PCIe device. There is nothing in any of the
drivers that would have disabled BIOS support.

You should check to make sure that your computer has the same bridge devices as your wife's machine.
One of them could have malfunctioned. You should also compare the dmesg output line by line.

Larry


From john.j35 at gmail.com  Mon Sep 24 04:06:26 2007
From: john.j35 at gmail.com (John Pierce)
Date: Sun, 23 Sep 2007 21:06:26 -0500
Subject: Lost wireless device?
In-Reply-To: <46F713B8.5030806@lwfinger.net>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>
	<46F489AF.2020101@lwfinger.net>
	<aa73b9a0709212105u524736e7ja9b860a4f2b1b5ab@mail.gmail.com>
	<46F49A5F.8020300@lwfinger.net>
	<aa73b9a0709212134k5458b799p146c0bd740fe70a4@mail.gmail.com>
	<aa73b9a0709231756y38a364c2jcaf8135663f0de8c@mail.gmail.com>
	<46F713B8.5030806@lwfinger.net>
Message-ID: <aa73b9a0709231906s3bd7a2a0h3fbf5a751b531488@mail.gmail.com>

Ok, I did a clean boot of both machines with the dmesg -c command
being applied just before the reboot.

So far the only thing that I see different is this line:

Allocate Port Service[0000:00:03.0:pcie03]

This is in the dmesg output from my wifes working machine and the
output of lspci ties this entry to the id number of the wlan card.

-- 
John
Registered Linux User 263680, get counted at
http://counter.li.org


From josejx at gentoo.org  Mon Sep 24 05:29:44 2007
From: josejx at gentoo.org (Joseph Jezak)
Date: Sun, 23 Sep 2007 23:29:44 -0400
Subject: drivers
In-Reply-To: <8353a5d0709231751s6cc4edd8redc6a581dabd57ee@mail.gmail.com>
References: <8353a5d0709231751s6cc4edd8redc6a581dabd57ee@mail.gmail.com>
Message-ID: <46F72F28.1050807@gentoo.org>

Gmail Collector wrote:
> Not being a reverse engineer, nor any kind of engineer for that matter,
> I was wondering if the driver files for the (rev 02) from my Vista would
> help in any way?  If so, I'd be happy to send them as an attachment.
> 
> 
> Gary

No, we've already got a driver that supports these cards, the
reverse engineers (myself and Johannes) haven't gotten around to it
yet.  And please don't ask when we will, it'll happen eventually,
it's just a matter of time.

-Joe


From larry.finger at lwfinger.net  Mon Sep 24 17:01:00 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 24 Sep 2007 10:01:00 -0500
Subject: Lost wireless device?
In-Reply-To: <aa73b9a0709231906s3bd7a2a0h3fbf5a751b531488@mail.gmail.com>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>	
	<46F489AF.2020101@lwfinger.net>	
	<aa73b9a0709212105u524736e7ja9b860a4f2b1b5ab@mail.gmail.com>	
	<46F49A5F.8020300@lwfinger.net>	
	<aa73b9a0709212134k5458b799p146c0bd740fe70a4@mail.gmail.com>	
	<aa73b9a0709231756y38a364c2jcaf8135663f0de8c@mail.gmail.com>	
	<46F713B8.5030806@lwfinger.net>
	<aa73b9a0709231906s3bd7a2a0h3fbf5a751b531488@mail.gmail.com>
Message-ID: <46F7D12C.8010400@lwfinger.net>

John Pierce wrote:
> Ok, I did a clean boot of both machines with the dmesg -c command
> being applied just before the reboot.
> 
> So far the only thing that I see different is this line:
> 
> Allocate Port Service[0000:00:03.0:pcie03]
> 
> This is in the dmesg output from my wifes working machine and the
> output of lspci ties this entry to the id number of the wlan card.

I am almost ready to write to the Linux Kernel Mailing List about this problem, but a couple of
things to check.

(1) Have you reset the BIOS to the default values? If your BIOS is like mine, there aren't many
things to be set, but something could have been corrupted.

(2) If #1 didn't help, we should probably consider reflashing the BIOS.

Larry


From john.j35 at gmail.com  Mon Sep 24 19:24:56 2007
From: john.j35 at gmail.com (John Pierce)
Date: Mon, 24 Sep 2007 12:24:56 -0500
Subject: Lost wireless device?
In-Reply-To: <46F7D12C.8010400@lwfinger.net>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>
	<46F489AF.2020101@lwfinger.net>
	<aa73b9a0709212105u524736e7ja9b860a4f2b1b5ab@mail.gmail.com>
	<46F49A5F.8020300@lwfinger.net>
	<aa73b9a0709212134k5458b799p146c0bd740fe70a4@mail.gmail.com>
	<aa73b9a0709231756y38a364c2jcaf8135663f0de8c@mail.gmail.com>
	<46F713B8.5030806@lwfinger.net>
	<aa73b9a0709231906s3bd7a2a0h3fbf5a751b531488@mail.gmail.com>
	<46F7D12C.8010400@lwfinger.net>
Message-ID: <aa73b9a0709241024o7cbb2bc3m93a539320e507f4f@mail.gmail.com>

> I am almost ready to write to the Linux Kernel Mailing List about this problem, but a couple of
> things to check.
>
> (1) Have you reset the BIOS to the default values? If your BIOS is like mine, there aren't many
> things to be set, but something could have been corrupted.
>
Yes, I did reset the bios to the defaults.  And you are correct, there
are only 3 or 4 items that can be reset.

> (2) If #1 didn't help, we should probably consider reflashing the BIOS.
>
I have considered reflashing the bios, but I would have to clear some
drive space and reinstall vista.  The only flashing program I have
found on HP.com is the winflash utility that is designed to run under
windows vista, they also have an xp version as well.

I did not personally want to reinstall vista, but if necessary I can
move some files around and make the second hard drive the primary for
an installation.

Thanks
-- 
John
Registered Linux User 263680, get counted at
http://counter.li.org


From john.j35 at gmail.com  Tue Sep 25 02:42:52 2007
From: john.j35 at gmail.com (John Pierce)
Date: Mon, 24 Sep 2007 19:42:52 -0500
Subject: Lost wireless device?
In-Reply-To: <aa73b9a0709241024o7cbb2bc3m93a539320e507f4f@mail.gmail.com>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>
	<46F489AF.2020101@lwfinger.net>
	<aa73b9a0709212105u524736e7ja9b860a4f2b1b5ab@mail.gmail.com>
	<46F49A5F.8020300@lwfinger.net>
	<aa73b9a0709212134k5458b799p146c0bd740fe70a4@mail.gmail.com>
	<aa73b9a0709231756y38a364c2jcaf8135663f0de8c@mail.gmail.com>
	<46F713B8.5030806@lwfinger.net>
	<aa73b9a0709231906s3bd7a2a0h3fbf5a751b531488@mail.gmail.com>
	<46F7D12C.8010400@lwfinger.net>
	<aa73b9a0709241024o7cbb2bc3m93a539320e507f4f@mail.gmail.com>
Message-ID: <aa73b9a0709241742g57e8f878nac52d599ade24396@mail.gmail.com>

> I did not personally want to reinstall vista, but if necessary I can
> move some files around and make the second hard drive the primary for
> an installation.
>
Just a status update on my problem.  I took the unused hd out of my
wifes machine and placed it in the primary slot of mine, reinstalled
vista from the recovery dvd and reflashed the bios.

The system still does not have the device listed.  I do not understand
how the bridge could just disappear without some kind of catastrophic
failure of the main board.  I mean if it was a module problem then
reverting back to the previous working kernel the problem should have
gone away.  Every other component is working flawlessly.

I am going to keep searching the kernel lists for a possible solution.

-- 
John
Registered Linux User 263680, get counted at
http://counter.li.org


From larry.finger at lwfinger.net  Tue Sep 25 02:58:39 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 24 Sep 2007 19:58:39 -0500
Subject: Missing PCIe interface in lspci
In-Reply-To: <aa73b9a0709231906s3bd7a2a0h3fbf5a751b531488@mail.gmail.com>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>	
	<46F489AF.2020101@lwfinger.net>	
	<aa73b9a0709212105u524736e7ja9b860a4f2b1b5ab@mail.gmail.com>	
	<46F49A5F.8020300@lwfinger.net>	
	<aa73b9a0709212134k5458b799p146c0bd740fe70a4@mail.gmail.com>	
	<aa73b9a0709231756y38a364c2jcaf8135663f0de8c@mail.gmail.com>	
	<46F713B8.5030806@lwfinger.net>
	<aa73b9a0709231906s3bd7a2a0h3fbf5a751b531488@mail.gmail.com>
Message-ID: <46F85D3F.5010400@lwfinger.net>

In the process of advising a user on getting a BCM4311 wireless device to work with bcm43xx rather
than ndiswrapper, the device stopped appearing in an lspci output. The 'lspci -vn' output
for this device before this failure was:

03:00.0 0280: 14e4:4311 (rev 01)
        Subsystem: 103c:1363
        Flags: fast devsel, IRQ 21
        Memory at b8000000 (32-bit, non-prefetchable) [size=16K]
        Capabilities: [40] Power Management version 2
        Capabilities: [58] Message Signalled Interrupts: Mask- 64bit-
Queue=0/0 Enable-
        Capabilities: [d0] Express Legacy Endpoint IRQ 0

Fortunately, the "customer" has two identical machines. Swapping the wireless cards showed that both
BCM4311s work in the other computer, but neither works in the problem machine. Kernel Version
2.6.22.4-65.fc7 is used on both.

Doing a line-by-line comparison of the dmesg outputs, the only thing that stands out is that the line

Allocate Port Service[0000:00:03.0:pcie03]

is missing on the faulty computer. This is the bridge that should connect to the device in question.

The BIOS has been reset and reflashed without helping the problem.

Is there anything other than some failure on the motherboard that would lead to this situation? Is
there anything that we can try? The BIOS in this machine doesn't have many options.


Thanks,

Larry


From verbalshadow at gmail.com  Tue Sep 25 03:00:13 2007
From: verbalshadow at gmail.com (Joshua Blocher)
Date: Tue, 25 Sep 2007 05:00:13 +0400
Subject: Lost wireless device?
In-Reply-To: <aa73b9a0709241742g57e8f878nac52d599ade24396@mail.gmail.com>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>
	<aa73b9a0709212105u524736e7ja9b860a4f2b1b5ab@mail.gmail.com>
	<46F49A5F.8020300@lwfinger.net>
	<aa73b9a0709212134k5458b799p146c0bd740fe70a4@mail.gmail.com>
	<aa73b9a0709231756y38a364c2jcaf8135663f0de8c@mail.gmail.com>
	<46F713B8.5030806@lwfinger.net>
	<aa73b9a0709231906s3bd7a2a0h3fbf5a751b531488@mail.gmail.com>
	<46F7D12C.8010400@lwfinger.net>
	<aa73b9a0709241024o7cbb2bc3m93a539320e507f4f@mail.gmail.com>
	<aa73b9a0709241742g57e8f878nac52d599ade24396@mail.gmail.com>
Message-ID: <39a6589b0709241800m469be516x504f8c870a2150fb@mail.gmail.com>

In the future if they offer a DOS flash utility then it's easier to
use FreeDOS or if winFlash ReactOS though i have not tried the latter.

Does it even showup it Vista?

On 9/25/07, John Pierce <john.j35 at gmail.com> wrote:
> > I did not personally want to reinstall vista, but if necessary I can
> > move some files around and make the second hard drive the primary for
> > an installation.
> >
> Just a status update on my problem.  I took the unused hd out of my
> wifes machine and placed it in the primary slot of mine, reinstalled
> vista from the recovery dvd and reflashed the bios.
>
> The system still does not have the device listed.  I do not understand
> how the bridge could just disappear without some kind of catastrophic
> failure of the main board.  I mean if it was a module problem then
> reverting back to the previous working kernel the problem should have
> gone away.  Every other component is working flawlessly.
>
> I am going to keep searching the kernel lists for a possible solution.
>
> --
> John
> Registered Linux User 263680, get counted at
> http://counter.li.org
> _______________________________________________
> Bcm43xx-dev mailing list
> Bcm43xx-dev at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/bcm43xx-dev
>


From john.j35 at gmail.com  Tue Sep 25 03:17:17 2007
From: john.j35 at gmail.com (John Pierce)
Date: Mon, 24 Sep 2007 20:17:17 -0500
Subject: Lost wireless device?
In-Reply-To: <39a6589b0709241800m469be516x504f8c870a2150fb@mail.gmail.com>
References: <aa73b9a0709211952n284fa902oa7fe84174f2b53b7@mail.gmail.com>
	<46F49A5F.8020300@lwfinger.net>
	<aa73b9a0709212134k5458b799p146c0bd740fe70a4@mail.gmail.com>
	<aa73b9a0709231756y38a364c2jcaf8135663f0de8c@mail.gmail.com>
	<46F713B8.5030806@lwfinger.net>
	<aa73b9a0709231906s3bd7a2a0h3fbf5a751b531488@mail.gmail.com>
	<46F7D12C.8010400@lwfinger.net>
	<aa73b9a0709241024o7cbb2bc3m93a539320e507f4f@mail.gmail.com>
	<aa73b9a0709241742g57e8f878nac52d599ade24396@mail.gmail.com>
	<39a6589b0709241800m469be516x504f8c870a2150fb@mail.gmail.com>
Message-ID: <aa73b9a0709241817w3f2303ddoe3487c92f865700e@mail.gmail.com>

On 9/24/07, Joshua Blocher <verbalshadow at gmail.com> wrote:
> In the future if they offer a DOS flash utility then it's easier to
> use FreeDOS or if winFlash ReactOS though i have not tried the latter.
>
> Does it even showup it Vista?
>
I searched the site for a dos version of the update utility with no
luck.  I am going to set that drive aside for time being and if
necessary just plug it back in.

To answer the question, no it does not show up in windows.

-- 
John
Registered Linux User 263680, get counted at
http://counter.li.org


From cebbert at redhat.com  Tue Sep 25 19:19:02 2007
From: cebbert at redhat.com (Chuck Ebbert)
Date: Tue, 25 Sep 2007 13:19:02 -0400
Subject: Unsupported bcm43xx adapter: id 0812 rev 0D
Message-ID: <46F94306.4010802@redhat.com>

Is anyone working on support for this adapter?

ssb:v4243id0812rev0D

And also, the ssb driver prints a warning:

Warning at drivers/ssb/main.c:889 ssb_tmslow_reject_bitmask()

Code is looking for either 0 or 1 in the revision field, but there is a 6 there:
    ssb: rev 60000000

Printed with this patch:

        case SSB_IDLOW_SSBREV_23:
                return SSB_TMSLOW_REJECT_23;
        default:
+               printk(KERN_ERR "ssb: rev %x\n",
+                      ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV);
                WARN_ON(1);
        }
        return (SSB_TMSLOW_REJECT_22 | SSB_TMSLOW_REJECT_23);



From larry.finger at lwfinger.net  Tue Sep 25 20:03:46 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Tue, 25 Sep 2007 13:03:46 -0500
Subject: Unsupported bcm43xx adapter: id 0812 rev 0D
In-Reply-To: <46F94306.4010802@redhat.com>
References: <46F94306.4010802@redhat.com>
Message-ID: <46F94D82.6080203@lwfinger.net>

Chuck Ebbert wrote:
> Is anyone working on support for this adapter?
> 
> ssb:v4243id0812rev0D
> 
> And also, the ssb driver prints a warning:
> 
> Warning at drivers/ssb/main.c:889 ssb_tmslow_reject_bitmask()
> 
> Code is looking for either 0 or 1 in the revision field, but there is a 6 there:
>     ssb: rev 60000000

I've just started the process of remote testing to see what we can do with the rev 0D 802.11 cores.
As this one will have a PHY revision newer than anything studied by the reverse engineers, my
efforts may not come to anything, but there are now enough of these BCM4311/2 units that we need to
check. If I get a patch that lets this adapter even limp, I'll publish it here.

I'll let Michael worry about the ssb warning.

Larry



From mb at bu3sch.de  Wed Sep 26 23:54:38 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 26 Sep 2007 23:54:38 +0200
Subject: [PATCH resend] b43: Fix sparse warnings
Message-ID: <200709262354.38917.mb@bu3sch.de>

The remaining warning in phy.c will be fixed later.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

It seems that this patch was lost somewhere, as all patches except
this one are applied to wireless-2.6. So here comes the resend. :P

Index: wireless-2.6/drivers/net/wireless/b43/pio.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/pio.c	2007-09-26 20:31:04.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/pio.c	2007-09-26 23:19:14.000000000 +0200
@@ -60,7 +60,7 @@ static u16 tx_get_next_word(const u8 * t
 		source = packet;
 		i -= txhdr_size;
 	}
-	ret = le16_to_cpu(*((u16 *) (source + i)));
+	ret = le16_to_cpu(*((__le16 *)(source + i)));
 	*pos += 2;
 
 	return ret;
@@ -104,7 +104,7 @@ static u16 generate_cookie(struct b43_pi
 			   struct b43_pio_txpacket *packet)
 {
 	u16 cookie = 0x0000;
-	int packetindex;
+	u16 packetindex;
 
 	/* We use the upper 4 bits for the PIO
 	 * controller ID and the lower 12 bits
@@ -125,7 +125,7 @@ static u16 generate_cookie(struct b43_pi
 	default:
 		B43_WARN_ON(1);
 	}
-	packetindex = pio_txpacket_getindex(packet);
+	packetindex = packet->index;
 	B43_WARN_ON(packetindex & ~0x0FFF);
 	cookie |= (u16) packetindex;
 
@@ -286,6 +286,7 @@ static void setup_txqueues(struct b43_pi
 
 		packet->queue = queue;
 		INIT_LIST_HEAD(&packet->list);
+		packet->index = i;
 
 		list_add(&packet->list, &queue->txfree);
 	}
@@ -518,9 +519,10 @@ static void pio_rx_error(struct b43_pioq
 
 void b43_pio_rx(struct b43_pioqueue *queue)
 {
-	u16 preamble[21] = { 0 };
+	__le16 preamble[21] = { 0 };
 	struct b43_rxhdr_fw4 *rxhdr;
-	u16 tmp, len, macstat;
+	u16 tmp, len;
+	u32 macstat;
 	int i, preamble_readwords;
 	struct sk_buff *skb;
 
@@ -537,7 +539,7 @@ void b43_pio_rx(struct b43_pioqueue *que
 	}
 	b43dbg(queue->dev->wl, "PIO RX timed out\n");
 	return;
-      data_ready:
+data_ready:
 
 	len = b43_pio_read(queue, B43_PIO_RXDATA);
 	if (unlikely(len > 0x700)) {
@@ -558,7 +560,7 @@ void b43_pio_rx(struct b43_pioqueue *que
 		preamble[i + 1] = cpu_to_le16(tmp);
 	}
 	rxhdr = (struct b43_rxhdr_fw4 *)preamble;
-	macstat = le16_to_cpu(rxhdr->mac_status);
+	macstat = le32_to_cpu(rxhdr->mac_status);
 	if (macstat & B43_RX_MAC_FCSERR) {
 		pio_rx_error(queue,
 			     (queue->mmio_base == B43_MMIO_PIO1_BASE),
@@ -583,7 +585,7 @@ void b43_pio_rx(struct b43_pioqueue *que
 	skb_put(skb, len);
 	for (i = 0; i < len - 1; i += 2) {
 		tmp = b43_pio_read(queue, B43_PIO_RXDATA);
-		*((u16 *) (skb->data + i)) = cpu_to_le16(tmp);
+		*((__le16 *)(skb->data + i)) = cpu_to_le16(tmp);
 	}
 	if (len % 2) {
 		tmp = b43_pio_read(queue, B43_PIO_RXDATA);
Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c	2007-09-26 20:31:04.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/xmit.c	2007-09-26 23:19:14.000000000 +0200
@@ -121,10 +121,12 @@ void b43_generate_plcp_hdr(struct b43_pl
 	__u8 *raw = plcp->raw;
 
 	if (b43_is_ofdm_rate(bitrate)) {
-		*data = b43_plcp_get_ratecode_ofdm(bitrate);
+		u32 d;
+
+		d = b43_plcp_get_ratecode_ofdm(bitrate);
 		B43_WARN_ON(octets & 0xF000);
-		*data |= (octets << 5);
-		*data = cpu_to_le32(*data);
+		d |= (octets << 5);
+		*data = cpu_to_le32(d);
 	} else {
 		u32 plen;
 
Index: wireless-2.6/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.c	2007-09-26 20:31:04.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/leds.c	2007-09-26 23:19:14.000000000 +0200
@@ -32,14 +32,13 @@
 static void b43_led_changestate(struct b43_led *led)
 {
 	struct b43_wldev *dev = led->dev;
-	const int index = b43_led_index(led);
-	const u16 mask = (1 << index);
+	const int index = led->index;
 	u16 ledctl;
 
 	B43_WARN_ON(!(index >= 0 && index < B43_NR_LEDS));
 	B43_WARN_ON(!led->blink_interval);
 	ledctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);
-	ledctl = (ledctl & mask) ? (ledctl & ~mask) : (ledctl | mask);
+	ledctl ^= (1 << index);
 	b43_write16(dev, B43_MMIO_GPIO_CONTROL, ledctl);
 }
 
@@ -70,7 +69,7 @@ static void b43_led_blink_start(struct b
 static void b43_led_blink_stop(struct b43_led *led, int sync)
 {
 	struct b43_wldev *dev = led->dev;
-	const int index = b43_led_index(led);
+	const int index = led->index;
 	u16 ledctl;
 
 	if (!led->blink_interval)
@@ -139,6 +138,7 @@ int b43_leds_init(struct b43_wldev *dev)
 
 	for (i = 0; i < B43_NR_LEDS; i++) {
 		led = &(dev->leds[i]);
+		led->index = i;
 		led->dev = dev;
 		setup_timer(&led->blink_timer,
 			    b43_led_blink, (unsigned long)led);
Index: wireless-2.6/drivers/net/wireless/b43/leds.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.h	2007-09-26 20:31:04.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/leds.h	2007-09-26 23:19:14.000000000 +0200
@@ -5,14 +5,14 @@
 #include <linux/timer.h>
 
 struct b43_led {
-	u8 behaviour:7;
-	u8 activelow:1;
-
+	u8 behaviour;
+	bool activelow;
+	/* Index in the "leds" array in b43_wldev */
+	u8 index;
 	struct b43_wldev *dev;
 	struct timer_list blink_timer;
 	unsigned long blink_interval;
 };
-#define b43_led_index(led)	((int)((led) - (led)->dev->leds))
 
 /* Delay between state changes when blinking in jiffies */
 #define B43_LEDBLINK_SLOW		(HZ / 1)
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2007-09-26 20:31:04.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2007-09-26 23:25:32.000000000 +0200
@@ -1062,7 +1062,7 @@ static void handle_irq_noise(struct b43_
 	B43_WARN_ON(!dev->noisecalc.calculation_running);
 	if (dev->noisecalc.channel_at_start != phy->channel)
 		goto drop_calculation;
-	*((u32 *) noise) = cpu_to_le32(b43_jssi_read(dev));
+	*((__le32 *)noise) = cpu_to_le32(b43_jssi_read(dev));
 	if (noise[0] == 0x7F || noise[1] == 0x7F ||
 	    noise[2] == 0x7F || noise[3] == 0x7F)
 		goto generate_new;
@@ -1598,8 +1598,7 @@ static int do_request_fw(struct b43_wlde
 			 const char *name,
 			 const struct firmware **fw)
 {
-	const size_t plen = sizeof(modparam_fwpostfix) + 32;
-	char path[plen];
+	char path[sizeof(modparam_fwpostfix) + 32];
 	struct b43_fw_header *hdr;
 	u32 size;
 	int err;
Index: wireless-2.6/drivers/net/wireless/b43/pcmcia.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/pcmcia.c	2007-09-26 20:31:04.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/pcmcia.c	2007-09-26 23:19:14.000000000 +0200
@@ -21,6 +21,8 @@
 
 */
 
+#include "pcmcia.h"
+
 #include <linux/ssb/ssb.h>
 
 #include <pcmcia/cs_types.h>
@@ -30,6 +32,7 @@
 #include <pcmcia/ds.h>
 #include <pcmcia/cisreg.h>
 
+
 static /*const */ struct pcmcia_device_id b43_pcmcia_tbl[] = {
 	PCMCIA_DEVICE_MANF_CARD(0x2D0, 0x448),
 	PCMCIA_DEVICE_NULL,
Index: wireless-2.6/drivers/net/wireless/b43/pio.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/pio.h	2007-09-26 20:31:04.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/pio.h	2007-09-26 23:19:14.000000000 +0200
@@ -39,10 +39,9 @@ struct b43_pio_txpacket {
 	struct sk_buff *skb;
 	struct ieee80211_tx_status txstat;
 	struct list_head list;
+	u16 index; /* Index in the tx_packets_cache */
 };
 
-#define pio_txpacket_getindex(packet) ((int)((packet) - (packet)->queue->tx_packets_cache))
-
 struct b43_pioqueue {
 	struct b43_wldev *dev;
 	u16 mmio_base;
Index: wireless-2.6/drivers/net/wireless/b43/debugfs.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/debugfs.c	2007-09-26 20:31:04.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/debugfs.c	2007-09-26 23:25:28.000000000 +0200
@@ -39,7 +39,7 @@
 
 
 /* The root directory. */
-struct dentry *rootdir;
+static struct dentry *rootdir;
 
 struct b43_debugfs_fops {
 	ssize_t (*read)(struct b43_wldev *dev, char *buf, size_t bufsize);
@@ -76,7 +76,8 @@ struct b43_dfs_file * fops_to_dfs_file(s
 
 
 /* wl->irq_lock is locked */
-ssize_t tsf_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t tsf_read_file(struct b43_wldev *dev,
+			     char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 	u64 tsf;
@@ -90,7 +91,8 @@ ssize_t tsf_read_file(struct b43_wldev *
 }
 
 /* wl->irq_lock is locked */
-int tsf_write_file(struct b43_wldev *dev, const char *buf, size_t count)
+static int tsf_write_file(struct b43_wldev *dev,
+			  const char *buf, size_t count)
 {
 	u64 tsf;
 
@@ -102,7 +104,8 @@ int tsf_write_file(struct b43_wldev *dev
 }
 
 /* wl->irq_lock is locked */
-ssize_t ucode_regs_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t ucode_regs_read_file(struct b43_wldev *dev,
+				    char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 	int i;
@@ -116,7 +119,8 @@ ssize_t ucode_regs_read_file(struct b43_
 }
 
 /* wl->irq_lock is locked */
-ssize_t shm_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t shm_read_file(struct b43_wldev *dev,
+			     char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 	int i;
@@ -135,7 +139,8 @@ ssize_t shm_read_file(struct b43_wldev *
 	return count;
 }
 
-ssize_t txstat_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t txstat_read_file(struct b43_wldev *dev,
+				char *buf, size_t bufsize)
 {
 	struct b43_txstatus_log *log = &dev->dfsentry->txstatlog;
 	ssize_t count = 0;
@@ -182,7 +187,8 @@ out_unlock:
 	return count;
 }
 
-ssize_t txpower_g_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t txpower_g_read_file(struct b43_wldev *dev,
+				   char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 
@@ -214,7 +220,8 @@ out:
 	return count;
 }
 
-int txpower_g_write_file(struct b43_wldev *dev, const char *buf, size_t count)
+static int txpower_g_write_file(struct b43_wldev *dev,
+				const char *buf, size_t count)
 {
 	unsigned long phy_flags;
 
@@ -253,7 +260,8 @@ int txpower_g_write_file(struct b43_wlde
 }
 
 /* wl->irq_lock is locked */
-int restart_write_file(struct b43_wldev *dev, const char *buf, size_t count)
+static int restart_write_file(struct b43_wldev *dev,
+			      const char *buf, size_t count)
 {
 	int err = 0;
 
@@ -285,7 +293,8 @@ static ssize_t append_lo_table(ssize_t c
 	return count;
 }
 
-ssize_t loctls_read_file(struct b43_wldev *dev, char *buf, size_t bufsize)
+static ssize_t loctls_read_file(struct b43_wldev *dev,
+				char *buf, size_t bufsize)
 {
 	ssize_t count = 0;
 	struct b43_txpower_lo_control *lo;
@@ -374,6 +383,8 @@ static ssize_t b43_debugfs_read(struct f
 			err = -ENOMEM;
 			goto out_unlock;
 		}
+		/* Sparse warns about the following memset, because it has a big
+		 * size value. That warning is bogus, so I will ignore it. --mb */
 		memset(buf, 0, bufsize);
 		if (dfops->take_irqlock) {
 			spin_lock_irq(&dev->wl->irq_lock);


From mb at bu3sch.de  Thu Sep 27 15:31:40 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 27 Sep 2007 15:31:40 +0200
Subject: [PATCH] b43: LED triggers support
Message-ID: <200709271531.42155.mb@bu3sch.de>

Drive the LEDs through the generic LED triggers.

Signed-off-by: Michael Buesch <mb at bu3sch.de>
Cc: Larry Finger <larry.finger at lwfinger.net>

Index: wireless-2.6/drivers/net/wireless/b43/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/Kconfig	2007-09-27 15:00:12.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/Kconfig	2007-09-27 15:06:23.000000000 +0200
@@ -61,6 +61,12 @@ config B43_PCMCIA
 
 	  If unsure, say N.
 
+# LED support
+config B43_LEDS
+	bool
+	depends on MAC80211_LEDS
+	default y
+
 config B43_DEBUG
 	bool "Broadcom 43xx debugging"
 	depends on B43
Index: wireless-2.6/drivers/net/wireless/b43/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/Makefile	2007-09-27 15:00:12.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/Makefile	2007-09-27 15:06:23.000000000 +0200
@@ -3,9 +3,10 @@ b43-y				+= main.o
 b43-y				+= tables.o
 b43-y				+= phy.o
 b43-y				+= sysfs.o
-b43-y				+= leds.o
 b43-y				+= xmit.o
 b43-y				+= lo.o
+# b43 LED support
+b43-$(CONFIG_B43_LEDS)		+= leds.o
 # b43 PCMCIA support
 b43-$(CONFIG_B43_PCMCIA)	+= pcmcia.o
 # b43 debugging
Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h	2007-09-27 15:00:12.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/b43.h	2007-09-27 15:06:23.000000000 +0200
@@ -707,8 +707,10 @@ struct b43_wldev {
 	/* Various statistics about the physical device. */
 	struct b43_stats stats;
 
-#define B43_NR_LEDS		4
-	struct b43_led leds[B43_NR_LEDS];
+	/* The device LEDs. */
+	struct b43_led led_tx;
+	struct b43_led led_rx;
+	struct b43_led led_assoc;
 
 	/* Reason code of the last interrupt. */
 	u32 irq_reason;
Index: wireless-2.6/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.c	2007-09-27 15:00:12.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/leds.c	2007-09-27 15:29:05.000000000 +0200
@@ -1,12 +1,13 @@
 /*
 
   Broadcom B43 wireless driver
+  LED control
 
   Copyright (c) 2005 Martin Langer <martin-langer at gmx.de>,
-                     Stefano Brivio <st3 at riseup.net>
-                     Michael Buesch <mb at bu3sch.de>
-                     Danny van Dyk <kugelfang at gentoo.org>
-                     Andreas Jaggi <andreas.jaggi at waterwave.ch>
+  Copyright (c) 2005 Stefano Brivio <st3 at riseup.net>
+  Copyright (c) 2005-2007 Michael Buesch <mb at bu3sch.de>
+  Copyright (c) 2005 Danny van Dyk <kugelfang at gentoo.org>
+  Copyright (c) 2005 Andreas Jaggi <andreas.jaggi at waterwave.ch>
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -27,272 +28,204 @@
 
 #include "b43.h"
 #include "leds.h"
-#include "main.h"
 
-static void b43_led_changestate(struct b43_led *led)
-{
-	struct b43_wldev *dev = led->dev;
-	const int index = led->index;
-	u16 ledctl;
-
-	B43_WARN_ON(!(index >= 0 && index < B43_NR_LEDS));
-	B43_WARN_ON(!led->blink_interval);
-	ledctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);
-	ledctl ^= (1 << index);
-	b43_write16(dev, B43_MMIO_GPIO_CONTROL, ledctl);
-}
 
-static void b43_led_blink(unsigned long d)
+static void b43_led_turn_on(struct b43_wldev *dev, u8 led_index,
+			    bool activelow)
 {
-	struct b43_led *led = (struct b43_led *)d;
-	struct b43_wldev *dev = led->dev;
+	struct b43_wl *wl = dev->wl;
 	unsigned long flags;
+	u16 ctl;
 
-	spin_lock_irqsave(&dev->wl->leds_lock, flags);
-	if (led->blink_interval) {
-		b43_led_changestate(led);
-		mod_timer(&led->blink_timer, jiffies + led->blink_interval);
-	}
-	spin_unlock_irqrestore(&dev->wl->leds_lock, flags);
+	spin_lock_irqsave(wl->leds_lock, flags);
+	ctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);
+	if (activelow)
+		ctl &= ~(1 << led_index);
+	else
+		ctl |= (1 << led_index);
+	b43_write16(dev, B43_MMIO_GPIO_CONTROL, ctl);
+	spin_unlock_irqrestore(wl->leds_lock, flags);
 }
 
-static void b43_led_blink_start(struct b43_led *led, unsigned long interval)
+static void b43_led_turn_off(struct b43_wldev *dev, u8 led_index,
+			     bool activelow)
 {
-	if (led->blink_interval)
-		return;
-	led->blink_interval = interval;
-	b43_led_changestate(led);
-	led->blink_timer.expires = jiffies + interval;
-	add_timer(&led->blink_timer);
+	struct b43_wl *wl = dev->wl;
+	unsigned long flags;
+	u16 ctl;
+
+	spin_lock_irqsave(wl->leds_lock, flags);
+	ctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);
+	if (activelow)
+		ctl |= (1 << led_index);
+	else
+		ctl &= ~(1 << led_index);
+	b43_write16(dev, B43_MMIO_GPIO_CONTROL, ctl);
+	spin_unlock_irqrestore(wl->leds_lock, flags);
 }
 
-static void b43_led_blink_stop(struct b43_led *led, int sync)
+/* Callback from the LED subsystem. */
+static void b43_led_brightness_set(struct led_classdev *led_dev,
+				   enum led_brightness brightness)
 {
+	struct b43_led *led = container_of(led_dev, struct b43_led, led_dev);
 	struct b43_wldev *dev = led->dev;
-	const int index = led->index;
-	u16 ledctl;
+	bool radio_enabled;
 
-	if (!led->blink_interval)
-		return;
-	if (unlikely(sync))
-		del_timer_sync(&led->blink_timer);
-	else
-		del_timer(&led->blink_timer);
-	led->blink_interval = 0;
+	/* Checking the radio-enabled status here is slightly racy,
+	 * but we want to avoid the locking overhead and we don't care
+	 * whether the LED has the wrong state for a second. */
+	radio_enabled = (dev->phy.radio_on && dev->radio_hw_enable);
 
-	/* Make sure the LED is turned off. */
-	B43_WARN_ON(!(index >= 0 && index < B43_NR_LEDS));
-	ledctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);
-	if (led->activelow)
-		ledctl |= (1 << index);
+	if (brightness == LED_OFF || !radio_enabled)
+		b43_led_turn_off(dev, led->index, led->activelow);
 	else
-		ledctl &= ~(1 << index);
-	b43_write16(dev, B43_MMIO_GPIO_CONTROL, ledctl);
+		b43_led_turn_on(dev, led->index, led->activelow);
 }
 
-static void b43_led_init_hardcoded(struct b43_wldev *dev,
-				   struct b43_led *led, int led_index)
-{
-	struct ssb_bus *bus = dev->dev->bus;
+static int b43_register_led(struct b43_wldev *dev, struct b43_led *led,
+			    const char *name, char *default_trigger,
+			    u8 led_index, bool activelow)
+{
+	int err;
+
+	b43_led_turn_off(dev, led_index, activelow);
+	if (led->dev)
+		return -EEXIST;
+	if (!default_trigger)
+		return -EINVAL;
+	led->dev = dev;
+	led->index = led_index;
+	led->activelow = activelow;
+	strncpy(led->name, name, sizeof(led->name));
+
+	led->led_dev.name = led->name;
+	led->led_dev.default_trigger = default_trigger;
+	led->led_dev.brightness_set = b43_led_brightness_set;
+
+	err = led_classdev_register(dev->dev->dev, &led->led_dev);
+	if (err) {
+		b43warn(dev->wl, "LEDs: Failed to register %s\n", name);
+		led->dev = NULL;
+		return err;
+	}
+	return 0;
+}
 
-	/* This function is called, if the behaviour (and activelow)
-	 * information for a LED is missing in the SPROM.
-	 * We hardcode the behaviour values for various devices here.
-	 * Note that the B43_LED_TEST_XXX behaviour values can
-	 * be used to figure out which led is mapped to which index.
-	 */
-
-	switch (led_index) {
-	case 0:
-		led->behaviour = B43_LED_ACTIVITY;
-		led->activelow = 1;
-		if (bus->boardinfo.vendor == PCI_VENDOR_ID_COMPAQ)
-			led->behaviour = B43_LED_RADIO_ALL;
+static void b43_unregister_led(struct b43_led *led)
+{
+	if (!led->dev)
+		return;
+	led_classdev_unregister(&led->led_dev);
+	b43_led_turn_off(led->dev, led->index, led->activelow);
+	led->dev = NULL;
+}
+
+static void b43_map_led(struct b43_wldev *dev,
+			u8 led_index,
+			enum b43_led_behaviour behaviour,
+			bool activelow)
+{
+	struct ieee80211_hw *hw = dev->wl->hw;
+	char name[B43_LED_MAX_NAME_LEN + 1];
+
+	/* Map the b43 specific LED behaviour value to the
+	 * generic LED triggers. */
+	switch (behaviour) {
+	case B43_LED_INACTIVE:
 		break;
-	case 1:
-		led->behaviour = B43_LED_RADIO_B;
-		if (bus->boardinfo.vendor == PCI_VENDOR_ID_ASUSTEK)
-			led->behaviour = B43_LED_ASSOC;
+	case B43_LED_OFF:
+		b43_led_turn_off(dev, led_index, activelow);
 		break;
-	case 2:
-		led->behaviour = B43_LED_RADIO_A;
+	case B43_LED_ON:
+		b43_led_turn_on(dev, led_index, activelow);
 		break;
-	case 3:
-		led->behaviour = B43_LED_OFF;
+	case B43_LED_ACTIVITY:
+	case B43_LED_TRANSFER:
+	case B43_LED_APTRANSFER:
+		snprintf(name, sizeof(name),
+			 "b43-%s:tx", wiphy_name(hw->wiphy));
+		b43_register_led(dev, &dev->led_tx, name,
+				 ieee80211_get_tx_led_name(hw),
+				 led_index, activelow);
+		snprintf(name, sizeof(name),
+			 "b43-%s:rx", wiphy_name(hw->wiphy));
+		b43_register_led(dev, &dev->led_rx, name,
+				 ieee80211_get_rx_led_name(hw),
+				 led_index, activelow);
+		break;
+	/*FIXME: We need another trigger for the "radio-on" LEDs below.
+	 *       Wiggle that somehow into the rfkill subsystem. */
+	case B43_LED_RADIO_ALL:
+	case B43_LED_RADIO_A:
+	case B43_LED_RADIO_B:
+	case B43_LED_MODE_BG:
+	case B43_LED_WEIRD:
+	case B43_LED_ASSOC:
+		snprintf(name, sizeof(name),
+			 "b43-%s:assoc", wiphy_name(hw->wiphy));
+		b43_register_led(dev, &dev->led_assoc, name,
+				 ieee80211_get_assoc_led_name(hw),
+				 led_index, activelow);
 		break;
 	default:
-		B43_WARN_ON(1);
+		b43warn(dev->wl, "LEDs: Unknown behaviour 0x%02X\n",
+			behaviour);
+		break;
 	}
 }
 
-int b43_leds_init(struct b43_wldev *dev)
+void b43_leds_init(struct b43_wldev *dev)
 {
-	struct b43_led *led;
+	struct ssb_bus *bus = dev->dev->bus;
 	u8 sprom[4];
 	int i;
+	enum b43_led_behaviour behaviour;
+	bool activelow;
 
-	sprom[0] = dev->dev->bus->sprom.r1.gpio0;
-	sprom[1] = dev->dev->bus->sprom.r1.gpio1;
-	sprom[2] = dev->dev->bus->sprom.r1.gpio2;
-	sprom[3] = dev->dev->bus->sprom.r1.gpio3;
-
-	for (i = 0; i < B43_NR_LEDS; i++) {
-		led = &(dev->leds[i]);
-		led->index = i;
-		led->dev = dev;
-		setup_timer(&led->blink_timer,
-			    b43_led_blink, (unsigned long)led);
+	sprom[0] = bus->sprom.r1.gpio0;
+	sprom[1] = bus->sprom.r1.gpio1;
+	sprom[2] = bus->sprom.r1.gpio2;
+	sprom[3] = bus->sprom.r1.gpio3;
 
+	for (i = 0; i < 4; i++) {
 		if (sprom[i] == 0xFF) {
-			b43_led_init_hardcoded(dev, led, i);
+			/* There is no LED information in the SPROM
+			 * for this LED. Hardcode it here. */
+			activelow = 0;
+			switch (i) {
+			case 0:
+				behaviour = B43_LED_ACTIVITY;
+				activelow = 1;
+				if (bus->boardinfo.vendor == PCI_VENDOR_ID_COMPAQ)
+					behaviour = B43_LED_RADIO_ALL;
+				break;
+			case 1:
+				behaviour = B43_LED_RADIO_B;
+				if (bus->boardinfo.vendor == PCI_VENDOR_ID_ASUSTEK)
+					behaviour = B43_LED_ASSOC;
+				break;
+			case 2:
+				behaviour = B43_LED_RADIO_A;
+				break;
+			case 3:
+				behaviour = B43_LED_OFF;
+				break;
+			default:
+				B43_WARN_ON(1);
+				return;
+			}
 		} else {
-			led->behaviour = sprom[i] & B43_LED_BEHAVIOUR;
-			led->activelow = !!(sprom[i] & B43_LED_ACTIVELOW);
+			behaviour = sprom[i] & B43_LED_BEHAVIOUR;
+			activelow = !!(sprom[i] & B43_LED_ACTIVELOW);
 		}
+		b43_map_led(dev, i, behaviour, activelow);
 	}
-
-	return 0;
 }
 
 void b43_leds_exit(struct b43_wldev *dev)
 {
-	struct b43_led *led;
-	int i;
-
-	for (i = 0; i < B43_NR_LEDS; i++) {
-		led = &(dev->leds[i]);
-		b43_led_blink_stop(led, 1);
-	}
-	b43_leds_switch_all(dev, 0);
-}
-
-void b43_leds_update(struct b43_wldev *dev, int activity)
-{
-	struct b43_led *led;
-	struct b43_phy *phy = &dev->phy;
-	const int transferring =
-	    (jiffies - dev->stats.last_tx) < B43_LED_XFER_THRES;
-	int i, turn_on;
-	unsigned long interval = 0;
-	u16 ledctl;
-	unsigned long flags;
-	bool radio_enabled = (phy->radio_on && dev->radio_hw_enable);
-
-	spin_lock_irqsave(&dev->wl->leds_lock, flags);
-	ledctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);
-	for (i = 0; i < B43_NR_LEDS; i++) {
-		led = &(dev->leds[i]);
-
-		turn_on = 0;
-		switch (led->behaviour) {
-		case B43_LED_INACTIVE:
-			continue;
-		case B43_LED_OFF:
-			break;
-		case B43_LED_ON:
-			turn_on = 1;
-			break;
-		case B43_LED_ACTIVITY:
-			turn_on = activity;
-			break;
-		case B43_LED_RADIO_ALL:
-			turn_on = radio_enabled;
-			break;
-		case B43_LED_RADIO_A:
-			turn_on = (radio_enabled && phy->type == B43_PHYTYPE_A);
-			break;
-		case B43_LED_RADIO_B:
-			turn_on = (radio_enabled &&
-				   (phy->type == B43_PHYTYPE_B
-				    || phy->type == B43_PHYTYPE_G));
-			break;
-		case B43_LED_MODE_BG:
-			if (phy->type == B43_PHYTYPE_G
-			    && radio_enabled)
-				turn_on = 1;
-			break;
-		case B43_LED_TRANSFER:
-			if (transferring)
-				b43_led_blink_start(led, B43_LEDBLINK_MEDIUM);
-			else
-				b43_led_blink_stop(led, 0);
-			continue;
-		case B43_LED_APTRANSFER:
-			if (b43_is_mode(dev->wl, IEEE80211_IF_TYPE_AP)) {
-				if (transferring) {
-					interval = B43_LEDBLINK_FAST;
-					turn_on = 1;
-				}
-			} else {
-				turn_on = 1;
-				if (0 /*TODO: not assoc */ )
-					interval = B43_LEDBLINK_SLOW;
-				else if (transferring)
-					interval = B43_LEDBLINK_FAST;
-				else
-					turn_on = 0;
-			}
-			if (turn_on)
-				b43_led_blink_start(led, interval);
-			else
-				b43_led_blink_stop(led, 0);
-			continue;
-		case B43_LED_WEIRD:
-			//TODO
-			break;
-		case B43_LED_ASSOC:
-			if (1 /*dev->softmac->associated */ )
-				turn_on = 1;
-			break;
-#ifdef CONFIG_B43_DEBUG
-		case B43_LED_TEST_BLINKSLOW:
-			b43_led_blink_start(led, B43_LEDBLINK_SLOW);
-			continue;
-		case B43_LED_TEST_BLINKMEDIUM:
-			b43_led_blink_start(led, B43_LEDBLINK_MEDIUM);
-			continue;
-		case B43_LED_TEST_BLINKFAST:
-			b43_led_blink_start(led, B43_LEDBLINK_FAST);
-			continue;
-#endif /* CONFIG_B43_DEBUG */
-		default:
-			B43_WARN_ON(1);
-		};
-
-		if (led->activelow)
-			turn_on = !turn_on;
-		if (turn_on)
-			ledctl |= (1 << i);
-		else
-			ledctl &= ~(1 << i);
-	}
-	b43_write16(dev, B43_MMIO_GPIO_CONTROL, ledctl);
-	spin_unlock_irqrestore(&dev->wl->leds_lock, flags);
-}
-
-void b43_leds_switch_all(struct b43_wldev *dev, int on)
-{
-	struct b43_led *led;
-	u16 ledctl;
-	int i;
-	int bit_on;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dev->wl->leds_lock, flags);
-	ledctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);
-	for (i = 0; i < B43_NR_LEDS; i++) {
-		led = &(dev->leds[i]);
-		if (led->behaviour == B43_LED_INACTIVE)
-			continue;
-		if (on)
-			bit_on = led->activelow ? 0 : 1;
-		else
-			bit_on = led->activelow ? 1 : 0;
-		if (bit_on)
-			ledctl |= (1 << i);
-		else
-			ledctl &= ~(1 << i);
-	}
-	b43_write16(dev, B43_MMIO_GPIO_CONTROL, ledctl);
-	spin_unlock_irqrestore(&dev->wl->leds_lock, flags);
+	b43_unregister_led(&dev->led_tx);
+	b43_unregister_led(&dev->led_rx);
+	b43_unregister_led(&dev->led_assoc);
 }
Index: wireless-2.6/drivers/net/wireless/b43/leds.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.h	2007-09-27 15:00:12.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/leds.h	2007-09-27 15:26:36.000000000 +0200
@@ -1,29 +1,33 @@
 #ifndef B43_LEDS_H_
 #define B43_LEDS_H_
 
+struct b43_wldev;
+
+#ifdef CONFIG_B43_LEDS
+
 #include <linux/types.h>
-#include <linux/timer.h>
+#include <linux/leds.h>
+
+
+#define B43_LED_MAX_NAME_LEN	31
 
 struct b43_led {
-	u8 behaviour;
-	bool activelow;
-	/* Index in the "leds" array in b43_wldev */
-	u8 index;
 	struct b43_wldev *dev;
-	struct timer_list blink_timer;
-	unsigned long blink_interval;
+	/* The LED class device */
+	struct led_classdev led_dev;
+	/* The index number of the LED. */
+	u8 index;
+	/* If activelow is true, the LED is ON if the
+	 * bit is switched off. */
+	bool activelow;
+	/* The unique name string for this LED device. */
+	char name[B43_LED_MAX_NAME_LEN + 1];
 };
 
-/* Delay between state changes when blinking in jiffies */
-#define B43_LEDBLINK_SLOW		(HZ / 1)
-#define B43_LEDBLINK_MEDIUM		(HZ / 4)
-#define B43_LEDBLINK_FAST		(HZ / 8)
-
-#define B43_LED_XFER_THRES		(HZ / 100)
-
 #define B43_LED_BEHAVIOUR		0x7F
 #define B43_LED_ACTIVELOW		0x80
-enum {				/* LED behaviour values */
+/* LED behaviour values */
+enum b43_led_behaviour {
 	B43_LED_OFF,
 	B43_LED_ON,
 	B43_LED_ACTIVITY,
@@ -36,20 +40,25 @@ enum {				/* LED behaviour values */
 	B43_LED_WEIRD,		//FIXME
 	B43_LED_ASSOC,
 	B43_LED_INACTIVE,
-
-	/* Behaviour values for testing.
-	 * With these values it is easier to figure out
-	 * the real behaviour of leds, in case the SPROM
-	 * is missing information.
-	 */
-	B43_LED_TEST_BLINKSLOW,
-	B43_LED_TEST_BLINKMEDIUM,
-	B43_LED_TEST_BLINKFAST,
 };
 
-int b43_leds_init(struct b43_wldev *dev);
+void b43_leds_init(struct b43_wldev *dev);
 void b43_leds_exit(struct b43_wldev *dev);
-void b43_leds_update(struct b43_wldev *dev, int activity);
-void b43_leds_switch_all(struct b43_wldev *dev, int on);
+
+
+#else /* CONFIG_B43_LEDS */
+/* LED support disabled */
+
+struct b43_led {
+	/* empty */
+};
+
+static inline void b43_leds_init(struct b43_wldev *dev)
+{
+}
+static inline void b43_leds_exit(struct b43_wldev *dev)
+{
+}
+#endif /* CONFIG_B43_LEDS */
 
 #endif /* B43_LEDS_H_ */
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2007-09-27 15:00:12.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2007-09-27 15:06:23.000000000 +0200
@@ -84,10 +84,6 @@ static int modparam_long_retry = B43_DEF
 module_param_named(long_retry, modparam_long_retry, int, 0444);
 MODULE_PARM_DESC(long_retry, "Long-Retry-Limit (0 - 15)");
 
-static int modparam_noleds;
-module_param_named(noleds, modparam_noleds, int, 0444);
-MODULE_PARM_DESC(noleds, "Turn off all LED activity");
-
 static char modparam_fwpostfix[16];
 module_param_string(fwpostfix, modparam_fwpostfix, 16, 0444);
 MODULE_PARM_DESC(fwpostfix, "Postfix for the .fw files to load.");
@@ -1423,7 +1419,7 @@ static void b43_interrupt_tasklet(struct
 	u32 reason;
 	u32 dma_reason[ARRAY_SIZE(dev->dma_reason)];
 	u32 merged_dma_reason = 0;
-	int i, activity = 0;
+	int i;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->wl->irq_lock, flags);
@@ -1476,8 +1472,9 @@ static void b43_interrupt_tasklet(struct
 		handle_irq_beacon(dev);
 	if (reason & B43_IRQ_PMQ)
 		handle_irq_pmq(dev);
-	if (reason & B43_IRQ_TXFIFO_FLUSH_OK) ;
-	/*TODO*/ if (reason & B43_IRQ_NOISESAMPLE_OK)
+	if (reason & B43_IRQ_TXFIFO_FLUSH_OK)
+		;/* TODO */
+	if (reason & B43_IRQ_NOISESAMPLE_OK)
 		handle_irq_noise(dev);
 
 	/* Check the DMA reason registers for received data. */
@@ -1486,7 +1483,6 @@ static void b43_interrupt_tasklet(struct
 			b43_pio_rx(dev->pio.queue0);
 		else
 			b43_dma_rx(dev->dma.rx_ring0);
-		/* We intentionally don't set "activity" to 1, here. */
 	}
 	B43_WARN_ON(dma_reason[1] & B43_DMAIRQ_RX_DONE);
 	B43_WARN_ON(dma_reason[2] & B43_DMAIRQ_RX_DONE);
@@ -1495,19 +1491,13 @@ static void b43_interrupt_tasklet(struct
 			b43_pio_rx(dev->pio.queue3);
 		else
 			b43_dma_rx(dev->dma.rx_ring3);
-		activity = 1;
 	}
 	B43_WARN_ON(dma_reason[4] & B43_DMAIRQ_RX_DONE);
 	B43_WARN_ON(dma_reason[5] & B43_DMAIRQ_RX_DONE);
 
-	if (reason & B43_IRQ_TX_OK) {
+	if (reason & B43_IRQ_TX_OK)
 		handle_irq_transmit_status(dev);
-		activity = 1;
-		//TODO: In AP mode, this also causes sending of powersave responses.
-	}
 
-	if (!modparam_noleds)
-		b43_leds_update(dev, activity);
 	b43_interrupt_enable(dev, dev->irq_savedstate);
 	mmiowb();
 	spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
@@ -1959,7 +1949,6 @@ static int b43_gpio_init(struct b43_wlde
 	b43_write32(dev, B43_MMIO_MACCTL, b43_read32(dev, B43_MMIO_MACCTL)
 		    & ~B43_MACCTL_GPOUTSMSK);
 
-	b43_leds_switch_all(dev, 0);
 	b43_write16(dev, B43_MMIO_GPIO_MASK, b43_read16(dev, B43_MMIO_GPIO_MASK)
 		    | 0x000F);
 
@@ -2213,8 +2202,7 @@ static bool b43_is_hw_radio_enabled(stru
 static void b43_chip_exit(struct b43_wldev *dev)
 {
 	b43_radio_turn_off(dev);
-	if (!modparam_noleds)
-		b43_leds_exit(dev);
+	b43_leds_exit(dev);
 	b43_gpio_cleanup(dev);
 	/* firmware is released later */
 }
@@ -2242,9 +2230,11 @@ static int b43_chip_init(struct b43_wlde
 	err = b43_gpio_init(dev);
 	if (err)
 		goto out;	/* firmware is released later */
+	b43_leds_init(dev);
+
 	err = b43_upload_initvals(dev);
 	if (err)
-		goto err_gpio_cleanup;
+		goto err_leds_exit;
 	b43_radio_turn_on(dev);
 
 	b43_write16(dev, 0x03E6, 0x0000);
@@ -2318,14 +2308,15 @@ static int b43_chip_init(struct b43_wlde
 
 	err = 0;
 	b43dbg(dev->wl, "Chip initialized\n");
-      out:
+out:
 	return err;
 
-      err_radio_off:
+err_radio_off:
 	b43_radio_turn_off(dev);
-      err_gpio_cleanup:
+err_leds_exit:
+	b43_leds_exit(dev);
 	b43_gpio_cleanup(dev);
-	goto out;
+	return err;
 }
 
 static void b43_periodic_every120sec(struct b43_wldev *dev)
@@ -2412,7 +2403,6 @@ static void b43_periodic_every1sec(struc
 		dev->radio_hw_enable = radio_hw_enable;
 		b43info(dev->wl, "Radio hardware status changed to %s\n",
 			radio_hw_enable ? "ENABLED" : "DISABLED");
-		b43_leds_update(dev, 0);
 	}
 }
 
@@ -3768,18 +3758,13 @@ static int b43_wireless_core_attach(stru
 	} else
 		have_bphy = 1;
 
-	/* Initialize LEDs structs. */
-	err = b43_leds_init(dev);
-	if (err)
-		goto err_powerdown;
-
 	dev->phy.gmode = (have_gphy || have_bphy);
 	tmp = dev->phy.gmode ? B43_TMSLOW_GMODE : 0;
 	b43_wireless_core_reset(dev, tmp);
 
 	err = b43_phy_versioning(dev);
 	if (err)
-		goto err_leds_exit;
+		goto err_powerdown;
 	/* Check if this device supports multiband. */
 	if (!pdev ||
 	    (pdev->device != 0x4312 &&
@@ -3808,10 +3793,10 @@ static int b43_wireless_core_attach(stru
 
 	err = b43_validate_chipaccess(dev);
 	if (err)
-		goto err_leds_exit;
+		goto err_powerdown;
 	err = b43_setup_modes(dev, have_aphy, have_bphy, have_gphy);
 	if (err)
-		goto err_leds_exit;
+		goto err_powerdown;
 
 	/* Now set some default "current_dev" */
 	if (!wl->current_dev)
@@ -3826,8 +3811,6 @@ static int b43_wireless_core_attach(stru
 out:
 	return err;
 
-err_leds_exit:
-	b43_leds_exit(dev);
 err_powerdown:
 	ssb_bus_may_powerdown(bus);
 	return err;


From achrisjo at yahoo.com  Thu Sep 27 19:00:33 2007
From: achrisjo at yahoo.com (Arne Chr. Jorgensen)
Date: Thu, 27 Sep 2007 10:00:33 -0700 (PDT)
Subject: Any hope ?
In-Reply-To: <46E87541.1090107@lwfinger.net>
Message-ID: <188379.38815.qm@web63710.mail.re1.yahoo.com>

hi,

 A closing note of this thread:   -  I have returned the computer, so ... 
 
With a lot of work, Fedora8-test2 did run, with some exceptions - usb, cardreader,
wasn't supported.

Did complain and had a lot of trouble with the touchpad.  There was clearly something wrong with the drivers. Didn't come around to check the Broadcom
device.  The install problems, the sata driver, ...and a bunch of other things, seem linked to the NVIDIA chipsets.   It may not be supported unless info
is released from NVIDIA.   I have seldom come across anything that has
caused as many problems to get running....

//ARNE



       
---------------------------------
Need a vacation? Get great deals to amazing places on Yahoo! Travel. 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20070927/26beec9f/attachment.html>

From shocky1 at users.sourceforge.net  Thu Sep 27 20:44:36 2007
From: shocky1 at users.sourceforge.net (Shocky)
Date: Thu, 27 Sep 2007 12:44:36 -0600
Subject: drivers
In-Reply-To: <46F72F28.1050807@gentoo.org>
References: <8353a5d0709231751s6cc4edd8redc6a581dabd57ee@mail.gmail.com>
	<46F72F28.1050807@gentoo.org>
Message-ID: <200709271244.36762.shocky1@users.sourceforge.net>

On Sunday 23 September 2007 21:29, Joseph Jezak wrote:
> Gmail Collector wrote:
> > Not being a reverse engineer, nor any kind of engineer for that matter,
> > I was wondering if the driver files for the (rev 02) from my Vista would
> > help in any way?  If so, I'd be happy to send them as an attachment.
> >
> >
> > Gary
>
> No, we've already got a driver that supports these cards, the
> reverse engineers (myself and Johannes) haven't gotten around to it
> yet.  And please don't ask when we will, it'll happen eventually,
> it's just a matter of time.
>
> -Joe

Is there anything I could do to help with this? I haven't done much with 
device drivers before, but I have a lot of experience with reverse 
engineering of old applications (it's become something of a career 
specialty), so I have an idea of what's involved. 

Shocky
-- 
These are my opinions. Get your own.


From mb at bu3sch.de  Thu Sep 27 21:35:34 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 27 Sep 2007 21:35:34 +0200
Subject: [PATCH] b43: RF-kill support
Message-ID: <200709272135.35686.mb@bu3sch.de>

This adds full support for the RFKILL button and
the RFKILL LED trigger.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-2.6/drivers/net/wireless/b43/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/Kconfig	2007-09-27 20:53:39.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/Kconfig	2007-09-27 20:56:53.000000000 +0200
@@ -64,7 +64,13 @@ config B43_PCMCIA
 # LED support
 config B43_LEDS
 	bool
-	depends on MAC80211_LEDS
+	depends on B43 && MAC80211_LEDS
+	default y
+
+# RFKILL support
+config B43_RFKILL
+	bool
+	depends on B43 && RFKILL
 	default y
 
 config B43_DEBUG
Index: wireless-2.6/drivers/net/wireless/b43/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/Makefile	2007-09-27 20:53:39.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/Makefile	2007-09-27 20:56:53.000000000 +0200
@@ -5,6 +5,8 @@ b43-y				+= phy.o
 b43-y				+= sysfs.o
 b43-y				+= xmit.o
 b43-y				+= lo.o
+# b43 RFKILL button support
+b43-$(CONFIG_B43_RFKILL)	+= rfkill.o
 # b43 LED support
 b43-$(CONFIG_B43_LEDS)		+= leds.o
 # b43 PCMCIA support
Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h	2007-09-27 20:53:39.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/b43.h	2007-09-27 20:56:53.000000000 +0200
@@ -10,6 +10,7 @@
 
 #include "debugfs.h"
 #include "leds.h"
+#include "rfkill.h"
 #include "lo.h"
 #include "phy.h"
 
@@ -636,6 +637,9 @@ struct b43_wl {
 	u8 rng_initialized;
 	char rng_name[30 + 1];
 
+	/* The RF-kill button */
+	struct b43_rfkill rfkill;
+
 	/* List of all wireless devices on this chip */
 	struct list_head devlist;
 	u8 nr_devs;
@@ -711,6 +715,7 @@ struct b43_wldev {
 	struct b43_led led_tx;
 	struct b43_led led_rx;
 	struct b43_led led_assoc;
+	struct b43_led led_radio;
 
 	/* Reason code of the last interrupt. */
 	u32 irq_reason;
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2007-09-27 20:53:39.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2007-09-27 20:56:53.000000000 +0200
@@ -2201,7 +2201,7 @@ static bool b43_is_hw_radio_enabled(stru
 /* This is the opposite of b43_chip_init() */
 static void b43_chip_exit(struct b43_wldev *dev)
 {
-	b43_radio_turn_off(dev);
+	b43_radio_turn_off(dev, 1);
 	b43_leds_exit(dev);
 	b43_gpio_cleanup(dev);
 	/* firmware is released later */
@@ -2312,7 +2312,7 @@ out:
 	return err;
 
 err_radio_off:
-	b43_radio_turn_off(dev);
+	b43_radio_turn_off(dev, 1);
 err_leds_exit:
 	b43_leds_exit(dev);
 	b43_gpio_cleanup(dev);
@@ -2401,8 +2401,7 @@ static void b43_periodic_every1sec(struc
 	radio_hw_enable = b43_is_hw_radio_enabled(dev);
 	if (unlikely(dev->radio_hw_enable != radio_hw_enable)) {
 		dev->radio_hw_enable = radio_hw_enable;
-		b43info(dev->wl, "Radio hardware status changed to %s\n",
-			radio_hw_enable ? "ENABLED" : "DISABLED");
+		b43_rfkill_toggled(dev, radio_hw_enable);
 	}
 }
 
@@ -2893,7 +2892,7 @@ static int b43_dev_config(struct ieee802
 					"Press the button to turn it on.\n");
 			}
 		} else {
-			b43_radio_turn_off(dev);
+			b43_radio_turn_off(dev, 0);
 			b43info(dev->wl, "Radio turned off by software\n");
 		}
 	}
@@ -3355,11 +3354,15 @@ static void b43_wireless_core_exit(struc
 		return;
 	b43_set_status(dev, B43_STAT_UNINIT);
 
+	mutex_unlock(&dev->wl->mutex);
+	b43_rfkill_exit(dev);
+	mutex_lock(&dev->wl->mutex);
+
 	b43_rng_exit(dev->wl);
 	b43_pio_free(dev);
 	b43_dma_free(dev);
 	b43_chip_exit(dev);
-	b43_radio_turn_off(dev);
+	b43_radio_turn_off(dev, 1);
 	b43_switch_analog(dev, 0);
 	if (phy->dyn_tssi_tbl)
 		kfree(phy->tssi2dbm);
@@ -3482,6 +3485,7 @@ static int b43_wireless_core_init(struct
 	memset(wl->bssid, 0, ETH_ALEN);
 	b43_upload_card_macaddress(dev, NULL);
 	b43_security_init(dev);
+	b43_rfkill_init(dev);
 	b43_rng_init(wl);
 
 	b43_set_status(dev, B43_STAT_INITIALIZED);
@@ -3803,7 +3807,7 @@ static int b43_wireless_core_attach(stru
 		wl->current_dev = dev;
 	INIT_WORK(&dev->restart_work, b43_chip_reset);
 
-	b43_radio_turn_off(dev);
+	b43_radio_turn_off(dev, 1);
 	b43_switch_analog(dev, 0);
 	ssb_device_disable(dev->dev, 0);
 	ssb_bus_may_powerdown(bus);
Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.c	2007-09-27 21:04:07.000000000 +0200
@@ -0,0 +1,155 @@
+/*
+
+  Broadcom B43 wireless driver
+  RFKILL support
+
+  Copyright (c) 2007 Michael Buesch <mb at bu3sch.de>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+
+*/
+
+#include "rfkill.h"
+#include "b43.h"
+
+
+static void b43_notify_rfkill_press(struct work_struct *work)
+{
+	struct b43_rfkill *rfk = container_of(work, struct b43_rfkill,
+					      notify_work);
+	struct b43_wl *wl = container_of(rfk, struct b43_wl, rfkill);
+	struct b43_wldev *dev;
+	enum rfkill_state state;
+
+	mutex_lock(&wl->mutex);
+	dev = wl->current_dev;
+	if (b43_status(dev) < B43_STAT_INITIALIZED) {
+		mutex_unlock(&wl->mutex);
+		return;
+	}
+	if (dev->radio_hw_enable)
+		state = RFKILL_STATE_ON;
+	else
+		state = RFKILL_STATE_OFF;
+	b43info(wl, "Radio hardware status changed to %s\n",
+		dev->radio_hw_enable ? "ENABLED" : "DISABLED");
+	mutex_unlock(&wl->mutex);
+
+	if (rfk->rfkill) {
+		/* Be careful. This calls back into the software toggle routines.
+		 * So we must unlock before calling. */
+		rfkill_switch_all(rfk->rfkill->type, state);
+	}
+}
+
+/* Called when the RFKILL toggled in hardware.
+ * This is called with the mutex locked. */
+void b43_rfkill_toggled(struct b43_wldev *dev, bool on)
+{
+	struct b43_wl *wl = dev->wl;
+
+	B43_WARN_ON(b43_status(dev) < B43_STAT_INITIALIZED);
+	/* Update the RF status asynchronously, as rfkill will
+	 * call back into the software toggle handler.
+	 * This would deadlock if done synchronously. */
+	queue_work(wl->hw->workqueue, &wl->rfkill.notify_work);
+}
+
+/* Called when the RFKILL toggled in software.
+ * This is called without locking. */
+static int b43_rfkill_soft_toggle(void *data, enum rfkill_state state)
+{
+	struct b43_wldev *dev = data;
+	struct b43_wl *wl = dev->wl;
+	int err = 0;
+
+	mutex_lock(&wl->mutex);
+	if (b43_status(dev) < B43_STAT_INITIALIZED)
+		goto out_unlock;
+
+	switch (state) {
+	case RFKILL_STATE_ON:
+		if (!dev->radio_hw_enable) {
+			/* No luck. We can't toggle the hardware RF-kill
+			 * button from software. */
+			err = -EBUSY;
+			goto out_unlock;
+		}
+		if (!dev->phy.radio_on)
+			b43_radio_turn_on(dev);
+		break;
+	case RFKILL_STATE_OFF:
+		if (dev->phy.radio_on)
+			b43_radio_turn_off(dev, 0);
+		break;
+	}
+
+out_unlock:
+	mutex_unlock(&wl->mutex);
+
+	return err;
+}
+
+char * b43_rfkill_led_name(struct b43_wldev *dev)
+{
+	struct b43_wl *wl = dev->wl;
+
+	if (!wl->rfkill.rfkill)
+		return NULL;
+	return rfkill_get_led_name(wl->rfkill.rfkill);
+}
+
+void b43_rfkill_init(struct b43_wldev *dev)
+{
+	struct b43_wl *wl = dev->wl;
+	struct b43_rfkill *rfk = &(wl->rfkill);
+	int err;
+
+	snprintf(rfk->name, sizeof(rfk->name),
+		 "b43-%s", wiphy_name(wl->hw->wiphy));
+	rfk->rfkill = rfkill_allocate(dev->dev->dev, RFKILL_TYPE_WLAN);
+	if (!rfk->rfkill)
+		goto error;
+	rfk->rfkill->name = rfk->name;
+	rfk->rfkill->state = RFKILL_STATE_ON;
+	rfk->rfkill->data = dev;
+	rfk->rfkill->toggle_radio = b43_rfkill_soft_toggle;
+	rfk->rfkill->user_claim_unsupported = 1;
+
+	INIT_WORK(&rfk->notify_work, b43_notify_rfkill_press);
+
+	err = rfkill_register(rfk->rfkill);
+	if (err)
+		goto error;
+
+	return;
+error:
+	b43warn(dev->wl, "Failed to initialize the RF-kill button\n");
+	rfkill_free(rfk->rfkill);
+	rfk->rfkill = NULL;
+}
+
+void b43_rfkill_exit(struct b43_wldev *dev)
+{
+	struct b43_rfkill *rfk = &(dev->wl->rfkill);
+
+	if (!rfk->rfkill)
+		return;
+	cancel_work_sync(&rfk->notify_work);
+	rfkill_unregister(rfk->rfkill);
+	rfkill_free(rfk->rfkill);
+	rfk->rfkill = NULL;
+}
Index: wireless-2.6/drivers/net/wireless/b43/rfkill.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.h	2007-09-27 20:56:53.000000000 +0200
@@ -0,0 +1,49 @@
+#ifndef B43_RFKILL_H_
+#define B43_RFKILL_H_
+
+struct b43_wldev;
+
+
+#ifdef CONFIG_B43_RFKILL
+
+#include <linux/rfkill.h>
+
+struct b43_rfkill {
+	/* The RFKILL subsystem data structure */
+	struct rfkill *rfkill;
+	/* The unique name of this rfkill switch */
+	char name[32];
+	/* Workqueue for asynchronous notification. */
+	struct work_struct notify_work;
+};
+
+void b43_rfkill_init(struct b43_wldev *dev);
+void b43_rfkill_exit(struct b43_wldev *dev);
+void b43_rfkill_toggled(struct b43_wldev *dev, bool on);
+char * b43_rfkill_led_name(struct b43_wldev *dev);
+
+
+#else /* CONFIG_B43_RFKILL */
+/* No RFKILL support. */
+
+struct b43_rfkill {
+	/* empty */
+};
+
+static inline void b43_rfkill_init(struct b43_wldev *dev)
+{
+}
+static inline void b43_rfkill_exit(struct b43_wldev *dev)
+{
+}
+static inline void b43_rfkill_toggled(struct b43_wldev *dev, bool on)
+{
+}
+static inline char * b43_rfkill_led_name(struct b43_wldev *dev)
+{
+	return NULL;
+}
+
+#endif /* CONFIG_B43_RFKILL */
+
+#endif /* B43_RFKILL_H_ */
Index: wireless-2.6/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.c	2007-09-27 20:53:39.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/leds.c	2007-09-27 20:56:53.000000000 +0200
@@ -154,12 +154,16 @@ static void b43_map_led(struct b43_wldev
 				 ieee80211_get_rx_led_name(hw),
 				 led_index, activelow);
 		break;
-	/*FIXME: We need another trigger for the "radio-on" LEDs below.
-	 *       Wiggle that somehow into the rfkill subsystem. */
 	case B43_LED_RADIO_ALL:
 	case B43_LED_RADIO_A:
 	case B43_LED_RADIO_B:
 	case B43_LED_MODE_BG:
+		snprintf(name, sizeof(name),
+			 "b43-%s:radio", wiphy_name(hw->wiphy));
+		b43_register_led(dev, &dev->led_radio, name,
+				 b43_rfkill_led_name(dev),
+				 led_index, activelow);
+		break;
 	case B43_LED_WEIRD:
 	case B43_LED_ASSOC:
 		snprintf(name, sizeof(name),
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c	2007-09-27 20:53:39.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/phy.c	2007-09-27 20:56:53.000000000 +0200
@@ -4349,10 +4349,13 @@ void b43_radio_turn_on(struct b43_wldev 
 	phy->radio_on = 1;
 }
 
-void b43_radio_turn_off(struct b43_wldev *dev)
+void b43_radio_turn_off(struct b43_wldev *dev, bool force)
 {
 	struct b43_phy *phy = &dev->phy;
 
+	if (!phy->radio_on && !force)
+		return;
+
 	if (phy->type == B43_PHYTYPE_A) {
 		b43_radio_write16(dev, 0x0004, 0x00FF);
 		b43_radio_write16(dev, 0x0005, 0x00FB);
@@ -4364,9 +4367,11 @@ void b43_radio_turn_off(struct b43_wldev
 
 		rfover = b43_phy_read(dev, B43_PHY_RFOVER);
 		rfoverval = b43_phy_read(dev, B43_PHY_RFOVERVAL);
-		phy->radio_off_context.rfover = rfover;
-		phy->radio_off_context.rfoverval = rfoverval;
-		phy->radio_off_context.valid = 1;
+		if (!force) {
+			phy->radio_off_context.rfover = rfover;
+			phy->radio_off_context.rfoverval = rfoverval;
+			phy->radio_off_context.valid = 1;
+		}
 		b43_phy_write(dev, B43_PHY_RFOVER, rfover | 0x008C);
 		b43_phy_write(dev, B43_PHY_RFOVERVAL, rfoverval & 0xFF73);
 	} else
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h	2007-09-27 20:53:39.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/phy.h	2007-09-27 20:56:53.000000000 +0200
@@ -267,7 +267,7 @@ u16 b43_radio_init2050(struct b43_wldev 
 void b43_radio_init2060(struct b43_wldev *dev);
 
 void b43_radio_turn_on(struct b43_wldev *dev);
-void b43_radio_turn_off(struct b43_wldev *dev);
+void b43_radio_turn_off(struct b43_wldev *dev, bool force);
 
 int b43_radio_selectchannel(struct b43_wldev *dev, u8 channel,
 			    int synthetic_pu_workaround);


From mb at bu3sch.de  Thu Sep 27 22:41:06 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 27 Sep 2007 22:41:06 +0200
Subject: [PATCH] b43: RF-kill support
In-Reply-To: <200709272254.44608.IvDoorn@gmail.com>
References: <200709272135.35686.mb@bu3sch.de>
	<200709272254.44608.IvDoorn@gmail.com>
Message-ID: <200709272241.06570.mb@bu3sch.de>

On Thursday 27 September 2007 22:54:44 Ivo van Doorn wrote:
> Hi,
> 
> > @@ -2401,8 +2401,7 @@ static void b43_periodic_every1sec(struc
> >  	radio_hw_enable = b43_is_hw_radio_enabled(dev);
> >  	if (unlikely(dev->radio_hw_enable != radio_hw_enable)) {
> >  		dev->radio_hw_enable = radio_hw_enable;
> > -		b43info(dev->wl, "Radio hardware status changed to %s\n",
> > -			radio_hw_enable ? "ENABLED" : "DISABLED");
> > +		b43_rfkill_toggled(dev, radio_hw_enable);
> 
> Isn't it better to use the input_polldev for scheduled input device checking?
> 
> > +static void b43_notify_rfkill_press(struct work_struct *work)
> > +{
> > +	struct b43_rfkill *rfk = container_of(work, struct b43_rfkill,
> > +					      notify_work);
> > +	struct b43_wl *wl = container_of(rfk, struct b43_wl, rfkill);
> > +	struct b43_wldev *dev;
> > +	enum rfkill_state state;
> 
> Same here, input_polldev was created especially for hardware
> devices that don't trigger interrupts when the button was pressed.

Ah, well. Will change that later. This works for now.

-- 
Greetings Michael.


From mb at bu3sch.de  Thu Sep 27 23:03:56 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 27 Sep 2007 23:03:56 +0200
Subject: [PATCH] b43: RF-kill support
In-Reply-To: <200709272312.43994.IvDoorn@gmail.com>
References: <200709272135.35686.mb@bu3sch.de> <200709272241.06570.mb@bu3sch.de>
	<200709272312.43994.IvDoorn@gmail.com>
Message-ID: <200709272303.57040.mb@bu3sch.de>

On Thursday 27 September 2007 23:12:43 Ivo van Doorn wrote:
> On Thursday 27 September 2007, Michael Buesch wrote:
> > On Thursday 27 September 2007 22:54:44 Ivo van Doorn wrote:
> > > Hi,
> > > 
> > > > @@ -2401,8 +2401,7 @@ static void b43_periodic_every1sec(struc
> > > >  	radio_hw_enable = b43_is_hw_radio_enabled(dev);
> > > >  	if (unlikely(dev->radio_hw_enable != radio_hw_enable)) {
> > > >  		dev->radio_hw_enable = radio_hw_enable;
> > > > -		b43info(dev->wl, "Radio hardware status changed to %s\n",
> > > > -			radio_hw_enable ? "ENABLED" : "DISABLED");
> > > > +		b43_rfkill_toggled(dev, radio_hw_enable);
> > > 
> > > Isn't it better to use the input_polldev for scheduled input device checking?
> > > 
> > > > +static void b43_notify_rfkill_press(struct work_struct *work)
> > > > +{
> > > > +	struct b43_rfkill *rfk = container_of(work, struct b43_rfkill,
> > > > +					      notify_work);
> > > > +	struct b43_wl *wl = container_of(rfk, struct b43_wl, rfkill);
> > > > +	struct b43_wldev *dev;
> > > > +	enum rfkill_state state;
> > > 
> > > Same here, input_polldev was created especially for hardware
> > > devices that don't trigger interrupts when the button was pressed.
> > 
> > Ah, well. Will change that later. This works for now.
> 
> It might work, but this means that userspace is not made aware of
> the key toggling and would thus make rfkill useless in this case.

Yeah, sure. But it's not useless. The other functionality is still available.
I'll fix that. But in a seperate patch. No need to delay this one because
of this (IMO) minor issue.

-- 
Greetings Michael.


From mb at bu3sch.de  Thu Sep 27 23:14:16 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 27 Sep 2007 23:14:16 +0200
Subject: [PATCH] b43: RF-kill support
In-Reply-To: <200709272323.45730.IvDoorn@gmail.com>
References: <200709272135.35686.mb@bu3sch.de> <200709272303.57040.mb@bu3sch.de>
	<200709272323.45730.IvDoorn@gmail.com>
Message-ID: <200709272314.16401.mb@bu3sch.de>

On Thursday 27 September 2007 23:23:45 Ivo van Doorn wrote:
> On Thursday 27 September 2007, Michael Buesch wrote:
> > On Thursday 27 September 2007 23:12:43 Ivo van Doorn wrote:
> > > On Thursday 27 September 2007, Michael Buesch wrote:
> > > > On Thursday 27 September 2007 22:54:44 Ivo van Doorn wrote:
> > > > > Hi,
> > > > > 
> > > > > > @@ -2401,8 +2401,7 @@ static void b43_periodic_every1sec(struc
> > > > > >  	radio_hw_enable = b43_is_hw_radio_enabled(dev);
> > > > > >  	if (unlikely(dev->radio_hw_enable != radio_hw_enable)) {
> > > > > >  		dev->radio_hw_enable = radio_hw_enable;
> > > > > > -		b43info(dev->wl, "Radio hardware status changed to %s\n",
> > > > > > -			radio_hw_enable ? "ENABLED" : "DISABLED");
> > > > > > +		b43_rfkill_toggled(dev, radio_hw_enable);
> > > > > 
> > > > > Isn't it better to use the input_polldev for scheduled input device checking?
> > > > > 
> > > > > > +static void b43_notify_rfkill_press(struct work_struct *work)
> > > > > > +{
> > > > > > +	struct b43_rfkill *rfk = container_of(work, struct b43_rfkill,
> > > > > > +					      notify_work);
> > > > > > +	struct b43_wl *wl = container_of(rfk, struct b43_wl, rfkill);
> > > > > > +	struct b43_wldev *dev;
> > > > > > +	enum rfkill_state state;
> > > > > 
> > > > > Same here, input_polldev was created especially for hardware
> > > > > devices that don't trigger interrupts when the button was pressed.
> > > > 
> > > > Ah, well. Will change that later. This works for now.
> > > 
> > > It might work, but this means that userspace is not made aware of
> > > the key toggling and would thus make rfkill useless in this case.
> > 
> > Yeah, sure. But it's not useless. The other functionality is still available.
> > I'll fix that. But in a seperate patch. No need to delay this one because
> > of this (IMO) minor issue.
> 
> I agree, no need to delay this patch.
> 
> But since I never added proper documentation from the start of rfkill,
> and rt2x00 did it wrong for a while as well, I just wanted to make sure you
> were aware of the correct approach. :)

Yeah, thanks. I thought this was correct.
So if it's not correct to use the "switch" API function from outside, please
remove it from the public header and put it into some private inside of
the net/rfkill directory.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Fri Sep 28 00:17:13 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 27 Sep 2007 17:17:13 -0500
Subject: [PATCH] b43: RF-kill support
In-Reply-To: <200709272303.57040.mb@bu3sch.de>
References: <200709272135.35686.mb@bu3sch.de> <200709272241.06570.mb@bu3sch.de>
	<200709272312.43994.IvDoorn@gmail.com>
	<200709272303.57040.mb@bu3sch.de>
Message-ID: <46FC2BE9.2050705@lwfinger.net>

Michael Buesch wrote:
> 
> Yeah, sure. But it's not useless. The other functionality is still available.
> I'll fix that. But in a seperate patch. No need to delay this one because
> of this (IMO) minor issue.
> 

How long will the delay be? If relatively short, I'll wait for the final one before submitting the
port to b43legacy.

Larry




From mb at bu3sch.de  Fri Sep 28 00:33:35 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 28 Sep 2007 00:33:35 +0200
Subject: [PATCH] b43: RF-kill support
In-Reply-To: <46FC2BE9.2050705@lwfinger.net>
References: <200709272135.35686.mb@bu3sch.de> <200709272303.57040.mb@bu3sch.de>
	<46FC2BE9.2050705@lwfinger.net>
Message-ID: <200709280033.35765.mb@bu3sch.de>

On Friday 28 September 2007 00:17:13 Larry Finger wrote:
> Michael Buesch wrote:
> > 
> > Yeah, sure. But it's not useless. The other functionality is still available.
> > I'll fix that. But in a seperate patch. No need to delay this one because
> > of this (IMO) minor issue.
> > 
> 
> How long will the delay be? If relatively short, I'll wait for the final one before submitting the
> port to b43legacy.

One or two days, maybe.
I'm currently debugging another important bug.
And I guess I'll have to sleep in an hour or two, too. :)

The rfkill fix will be incremental based on this one, then.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Fri Sep 28 01:08:08 2007
From: larry.finger at lwfinger.net (Larry Finger)
Date: Thu, 27 Sep 2007 18:08:08 -0500
Subject: [PATCH] b43: RF-kill support
In-Reply-To: <200709280033.35765.mb@bu3sch.de>
References: <200709272135.35686.mb@bu3sch.de> <200709272303.57040.mb@bu3sch.de>
	<46FC2BE9.2050705@lwfinger.net> <200709280033.35765.mb@bu3sch.de>
Message-ID: <46FC37D8.3000800@lwfinger.net>

Michael Buesch wrote:
> One or two days, maybe.
> I'm currently debugging another important bug.
> And I guess I'll have to sleep in an hour or two, too. :)
> 
> The rfkill fix will be incremental based on this one, then.
> 

That I expected. The way I should have stated the question was "Should I submit the port of this
patch to b43legacy ASAP, or should I wait until the rfkill fix is ready to have only 1 rather than 2
patches for John to handle?" I think the correct answer is to wait. It will probably take me that
long to verify my port of the new LED handler anyway.

Larry



From martti.huttunen at mail.suomi.net  Fri Sep 28 11:08:50 2007
From: martti.huttunen at mail.suomi.net (Martti Huttunen)
Date: Fri, 28 Sep 2007 12:08:50 +0300
Subject: b43, b43legacy and BCM4318
In-Reply-To: <200709262354.38917.mb@bu3sch.de>
References: <200709262354.38917.mb@bu3sch.de>
Message-ID: <46FCC4A2.6030709@mail.suomi.net>

Hi people,

is there a new patch somewhere for the BCM4318 transmit power problem?

As far as I can tell the card works with b43 if you place it within
1 meter of the access point. Otherwise it doesn't even find the AP.

Could I try b43legacy as an alternative solution by just adding the
PCI ID? Since the card works fine with bcm43xx driver as a client,
the problem is in the interaction of the driver and the new firmware?





From schaefer at in.tum.de  Fri Sep 28 13:01:33 2007
From: schaefer at in.tum.de (=?ISO-8859-1?Q?Christian_Sch=E4fer?=)
Date: Fri, 28 Sep 2007 13:01:33 +0200
Subject: Strange warning in ssb
Message-ID: <46FCDF0D.7040901@in.tum.de>

Hi,

I get the following in dmesg:

ssb: WARNING: Invalid SPROM CRC (corrupt SPROM)
ssb: Unsupported SPROM revision 255 detected. Will extract v1
ssb: Sonics Silicon Backplane found on PCI device 0000:02:03.0

Card is a mini-PCI and lspci -vvv tells:

02:03.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 
54g] 802.11g Wireless LAN Controller (rev 02)
         Subsystem: Broadcom Corporation Gateway 7510GX
         Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- 
ParErr- Stepping- SERR- FastB2B-
         Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- 
<TAbort- <MAbort- >SERR- <PERR+
         Latency: 32
         Interrupt: pin A routed to IRQ 11
         Region 0: Memory at f8fd6000 (32-bit, non-prefetchable) [size=8K]

I'm running a 2.6.23-rc8-mm1 kernel. Please tell me if you need more info.

Is my card corrupt?

Bye,
Chris


From mb at bu3sch.de  Fri Sep 28 14:22:33 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 28 Sep 2007 14:22:33 +0200
Subject: [PATCH] b43: Use input-polldev for the rfkill switch
Message-ID: <200709281422.34434.mb@bu3sch.de>

This removes the direct call to rfkill on an rfkill event
and replaces it with an input device. This way userspace is also
notified about the event.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-2.6/drivers/net/wireless/b43/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/Kconfig	2007-09-27 21:31:15.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/Kconfig	2007-09-28 12:34:23.000000000 +0200
@@ -70,7 +70,7 @@ config B43_LEDS
 # RFKILL support
 config B43_RFKILL
 	bool
-	depends on B43 && RFKILL
+	depends on B43 && RFKILL && RFKILL_INPUT && INPUT_POLLDEV
 	default y
 
 config B43_DEBUG
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2007-09-27 21:31:22.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2007-09-28 14:11:11.000000000 +0200
@@ -2183,21 +2183,6 @@ static void b43_mgmtframe_txantenna(stru
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PRPHYCTL, tmp);
 }
 
-/* Returns TRUE, if the radio is enabled in hardware. */
-static bool b43_is_hw_radio_enabled(struct b43_wldev *dev)
-{
-	if (dev->phy.rev >= 3) {
-		if (!(b43_read32(dev, B43_MMIO_RADIO_HWENABLED_HI)
-		      & B43_MMIO_RADIO_HWENABLED_HI_MASK))
-			return 1;
-	} else {
-		if (b43_read16(dev, B43_MMIO_RADIO_HWENABLED_LO)
-		    & B43_MMIO_RADIO_HWENABLED_LO_MASK)
-			return 1;
-	}
-	return 0;
-}
-
 /* This is the opposite of b43_chip_init() */
 static void b43_chip_exit(struct b43_wldev *dev)
 {
@@ -2393,32 +2378,18 @@ static void b43_periodic_every15sec(stru
 	//TODO for APHY (temperature?)
 }
 
-static void b43_periodic_every1sec(struct b43_wldev *dev)
-{
-	bool radio_hw_enable;
-
-	/* check if radio hardware enabled status changed */
-	radio_hw_enable = b43_is_hw_radio_enabled(dev);
-	if (unlikely(dev->radio_hw_enable != radio_hw_enable)) {
-		dev->radio_hw_enable = radio_hw_enable;
-		b43_rfkill_toggled(dev, radio_hw_enable);
-	}
-}
-
 static void do_periodic_work(struct b43_wldev *dev)
 {
 	unsigned int state;
 
 	state = dev->periodic_state;
-	if (state % 120 == 0)
+	if (state % 8 == 0)
 		b43_periodic_every120sec(dev);
-	if (state % 60 == 0)
+	if (state % 4 == 0)
 		b43_periodic_every60sec(dev);
-	if (state % 30 == 0)
+	if (state % 2 == 0)
 		b43_periodic_every30sec(dev);
-	if (state % 15 == 0)
-		b43_periodic_every15sec(dev);
-	b43_periodic_every1sec(dev);
+	b43_periodic_every15sec(dev);
 }
 
 /* Estimate a "Badness" value based on the periodic work
@@ -2429,13 +2400,11 @@ static int estimate_periodic_work_badnes
 {
 	int badness = 0;
 
-	if (state % 120 == 0)	/* every 120 sec */
+	if (state % 8 == 0)	/* every 120 sec */
 		badness += 10;
-	if (state % 60 == 0)	/* every 60 sec */
+	if (state % 4 == 0)	/* every 60 sec */
 		badness += 5;
-	if (state % 30 == 0)	/* every 30 sec */
-		badness += 1;
-	if (state % 15 == 0)	/* every 15 sec */
+	if (state % 2 == 0)	/* every 30 sec */
 		badness += 1;
 
 #define BADNESS_LIMIT	4
@@ -2486,13 +2455,13 @@ static void b43_periodic_work_handler(st
 		spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
 	}
 	dev->periodic_state++;
-      out_requeue:
+out_requeue:
 	if (b43_debug(dev, B43_DBG_PWORK_FAST))
 		delay = msecs_to_jiffies(50);
 	else
-		delay = round_jiffies(HZ);
+		delay = round_jiffies(HZ * 15);
 	queue_delayed_work(dev->wl->hw->workqueue, &dev->periodic_work, delay);
-      out:
+out:
 	mutex_unlock(&dev->wl->mutex);
 }
 
@@ -3721,6 +3690,7 @@ static int b43_setup_modes(struct b43_wl
 
 static void b43_wireless_core_detach(struct b43_wldev *dev)
 {
+	b43_rfkill_free(dev);
 	/* We release firmware that late to not be required to re-request
 	 * is all the time when we reinit the core. */
 	b43_release_firmware(dev);
@@ -3806,6 +3776,7 @@ static int b43_wireless_core_attach(stru
 	if (!wl->current_dev)
 		wl->current_dev = dev;
 	INIT_WORK(&dev->restart_work, b43_chip_reset);
+	b43_rfkill_alloc(dev);
 
 	b43_radio_turn_off(dev, 1);
 	b43_switch_analog(dev, 0);
Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c	2007-09-27 21:31:15.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.c	2007-09-28 14:06:37.000000000 +0200
@@ -26,46 +26,39 @@
 #include "b43.h"
 
 
-static void b43_notify_rfkill_press(struct work_struct *work)
+/* Returns TRUE, if the radio is enabled in hardware. */
+static bool b43_is_hw_radio_enabled(struct b43_wldev *dev)
 {
-	struct b43_rfkill *rfk = container_of(work, struct b43_rfkill,
-					      notify_work);
-	struct b43_wl *wl = container_of(rfk, struct b43_wl, rfkill);
-	struct b43_wldev *dev;
-	enum rfkill_state state;
-
-	mutex_lock(&wl->mutex);
-	dev = wl->current_dev;
-	if (b43_status(dev) < B43_STAT_INITIALIZED) {
-		mutex_unlock(&wl->mutex);
-		return;
-	}
-	if (dev->radio_hw_enable)
-		state = RFKILL_STATE_ON;
-	else
-		state = RFKILL_STATE_OFF;
-	b43info(wl, "Radio hardware status changed to %s\n",
-		dev->radio_hw_enable ? "ENABLED" : "DISABLED");
-	mutex_unlock(&wl->mutex);
-
-	if (rfk->rfkill) {
-		/* Be careful. This calls back into the software toggle routines.
-		 * So we must unlock before calling. */
-		rfkill_switch_all(rfk->rfkill->type, state);
+	if (dev->phy.rev >= 3) {
+		if (!(b43_read32(dev, B43_MMIO_RADIO_HWENABLED_HI)
+		      & B43_MMIO_RADIO_HWENABLED_HI_MASK))
+			return 1;
+	} else {
+		if (b43_read16(dev, B43_MMIO_RADIO_HWENABLED_LO)
+		    & B43_MMIO_RADIO_HWENABLED_LO_MASK)
+			return 1;
 	}
+	return 0;
 }
 
-/* Called when the RFKILL toggled in hardware.
- * This is called with the mutex locked. */
-void b43_rfkill_toggled(struct b43_wldev *dev, bool on)
+/* The poll callback for the hardware button. */
+static void b43_rfkill_poll(struct input_polled_dev *poll_dev)
 {
+	struct b43_wldev *dev = poll_dev->private;
 	struct b43_wl *wl = dev->wl;
+	bool enabled;
 
+	mutex_lock(&wl->mutex);
 	B43_WARN_ON(b43_status(dev) < B43_STAT_INITIALIZED);
-	/* Update the RF status asynchronously, as rfkill will
-	 * call back into the software toggle handler.
-	 * This would deadlock if done synchronously. */
-	queue_work(wl->hw->workqueue, &wl->rfkill.notify_work);
+	enabled = b43_is_hw_radio_enabled(dev);
+	if (unlikely(enabled != dev->radio_hw_enable)) {
+		dev->radio_hw_enable = enabled;
+		b43info(wl, "Radio hardware status changed to %s\n",
+			enabled ? "ENABLED" : "DISABLED");
+		mutex_unlock(&wl->mutex);
+		input_report_key(poll_dev->input, KEY_WLAN, enabled);
+	} else
+		mutex_unlock(&wl->mutex);
 }
 
 /* Called when the RFKILL toggled in software.
@@ -118,38 +111,74 @@ void b43_rfkill_init(struct b43_wldev *d
 	struct b43_rfkill *rfk = &(wl->rfkill);
 	int err;
 
+	if (rfk->rfkill) {
+		err = rfkill_register(rfk->rfkill);
+		if (err) {
+			b43warn(wl, "Failed to register RF-kill button\n");
+			goto err_free_rfk;
+		}
+	}
+	if (rfk->poll_dev) {
+		err = input_register_polled_device(rfk->poll_dev);
+		if (err) {
+			b43warn(wl, "Failed to register RF-kill polldev\n");
+			goto err_free_polldev;
+		}
+	}
+
+	return;
+err_free_rfk:
+	rfkill_free(rfk->rfkill);
+	rfk->rfkill = NULL;
+err_free_polldev:
+	input_free_polled_device(rfk->poll_dev);
+	rfk->poll_dev = NULL;
+}
+
+void b43_rfkill_exit(struct b43_wldev *dev)
+{
+	struct b43_rfkill *rfk = &(dev->wl->rfkill);
+
+	if (rfk->poll_dev)
+		input_unregister_polled_device(rfk->poll_dev);
+	if (rfk->rfkill)
+		rfkill_unregister(rfk->rfkill);
+}
+
+void b43_rfkill_alloc(struct b43_wldev *dev)
+{
+	struct b43_wl *wl = dev->wl;
+	struct b43_rfkill *rfk = &(wl->rfkill);
+
 	snprintf(rfk->name, sizeof(rfk->name),
 		 "b43-%s", wiphy_name(wl->hw->wiphy));
+
 	rfk->rfkill = rfkill_allocate(dev->dev->dev, RFKILL_TYPE_WLAN);
-	if (!rfk->rfkill)
-		goto error;
+	if (!rfk->rfkill) {
+		b43warn(wl, "Failed to allocate RF-kill button\n");
+		return;
+	}
 	rfk->rfkill->name = rfk->name;
 	rfk->rfkill->state = RFKILL_STATE_ON;
 	rfk->rfkill->data = dev;
 	rfk->rfkill->toggle_radio = b43_rfkill_soft_toggle;
 	rfk->rfkill->user_claim_unsupported = 1;
 
-	INIT_WORK(&rfk->notify_work, b43_notify_rfkill_press);
-
-	err = rfkill_register(rfk->rfkill);
-	if (err)
-		goto error;
-
-	return;
-error:
-	b43warn(dev->wl, "Failed to initialize the RF-kill button\n");
-	rfkill_free(rfk->rfkill);
-	rfk->rfkill = NULL;
+	rfk->poll_dev = input_allocate_polled_device();
+	if (rfk->poll_dev) {
+		rfk->poll_dev->private = dev;
+		rfk->poll_dev->poll = b43_rfkill_poll;
+		rfk->poll_dev->poll_interval = 1000; /* msecs */
+	} else
+		b43warn(wl, "Failed to allocate RF-kill polldev\n");
 }
 
-void b43_rfkill_exit(struct b43_wldev *dev)
+void b43_rfkill_free(struct b43_wldev *dev)
 {
 	struct b43_rfkill *rfk = &(dev->wl->rfkill);
 
-	if (!rfk->rfkill)
-		return;
-	cancel_work_sync(&rfk->notify_work);
-	rfkill_unregister(rfk->rfkill);
+	input_free_polled_device(rfk->poll_dev);
+	rfk->poll_dev = NULL;
 	rfkill_free(rfk->rfkill);
 	rfk->rfkill = NULL;
 }
Index: wireless-2.6/drivers/net/wireless/b43/rfkill.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.h	2007-09-27 21:31:15.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.h	2007-09-28 13:52:04.000000000 +0200
@@ -7,19 +7,25 @@ struct b43_wldev;
 #ifdef CONFIG_B43_RFKILL
 
 #include <linux/rfkill.h>
+#include <linux/input-polldev.h>
+
 
 struct b43_rfkill {
 	/* The RFKILL subsystem data structure */
 	struct rfkill *rfkill;
+	/* The poll device for the RFKILL input button */
+	struct input_polled_dev *poll_dev;
 	/* The unique name of this rfkill switch */
 	char name[32];
-	/* Workqueue for asynchronous notification. */
-	struct work_struct notify_work;
 };
 
+/* All the init functions return void, because we are not interested
+ * in failing the b43 init process when rfkill init failed. */
+void b43_rfkill_alloc(struct b43_wldev *dev);
+void b43_rfkill_free(struct b43_wldev *dev);
 void b43_rfkill_init(struct b43_wldev *dev);
 void b43_rfkill_exit(struct b43_wldev *dev);
-void b43_rfkill_toggled(struct b43_wldev *dev, bool on);
+
 char * b43_rfkill_led_name(struct b43_wldev *dev);
 
 
@@ -30,13 +36,16 @@ struct b43_rfkill {
 	/* empty */
 };
 
-static inline void b43_rfkill_init(struct b43_wldev *dev)
+static inline void b43_rfkill_alloc(struct b43_wldev *dev)
 {
 }
-static inline void b43_rfkill_exit(struct b43_wldev *dev)
+static inline void b43_rfkill_free(struct b43_wldev *dev)
 {
 }
-static inline void b43_rfkill_toggled(struct b43_wldev *dev, bool on)
+static inline void b43_rfkill_init(struct b43_wldev *dev)
+{
+}
+static inline void b43_rfkill_exit(struct b43_wldev *dev)
 {
 }
 static inline char * b43_rfkill_led_name(struct b43_wldev *dev)


From mb at bu3sch.de  Fri Sep 28 16:19:03 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 28 Sep 2007 16:19:03 +0200
Subject: [PATCH] b43: Rewrite pwork locking policy.
Message-ID: <200709281619.04154.mb@bu3sch.de>

Implement much easier and more lightweight locking for
the periodic work.
This also removes the last big busywait loop and replaces it
by a sleeping loop.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2007-09-28 14:31:48.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2007-09-28 15:59:40.000000000 +0200
@@ -1989,6 +1989,7 @@ void b43_mac_enable(struct b43_wldev *de
 {
 	dev->mac_suspended--;
 	B43_WARN_ON(dev->mac_suspended < 0);
+	B43_WARN_ON(irqs_disabled());
 	if (dev->mac_suspended == 0) {
 		b43_write32(dev, B43_MMIO_MACCTL,
 			    b43_read32(dev, B43_MMIO_MACCTL)
@@ -1999,6 +2000,11 @@ void b43_mac_enable(struct b43_wldev *de
 		b43_read32(dev, B43_MMIO_MACCTL);
 		b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);
 		b43_power_saving_ctl_bits(dev, 0);
+
+		/* Re-enable IRQs. */
+		spin_lock_irq(&dev->wl->irq_lock);
+		b43_interrupt_enable(dev, dev->irq_savedstate);
+		spin_unlock_irq(&dev->wl->irq_lock);
 	}
 }
 
@@ -2008,23 +2014,34 @@ void b43_mac_suspend(struct b43_wldev *d
 	int i;
 	u32 tmp;
 
+	might_sleep();
+	B43_WARN_ON(irqs_disabled());
 	B43_WARN_ON(dev->mac_suspended < 0);
+
 	if (dev->mac_suspended == 0) {
+		/* Mask IRQs before suspending MAC. Otherwise
+		 * the MAC stays busy and won't suspend. */
+		spin_lock_irq(&dev->wl->irq_lock);
+		tmp = b43_interrupt_disable(dev, B43_IRQ_ALL);
+		spin_unlock_irq(&dev->wl->irq_lock);
+		b43_synchronize_irq(dev);
+		dev->irq_savedstate = tmp;
+
 		b43_power_saving_ctl_bits(dev, B43_PS_AWAKE);
 		b43_write32(dev, B43_MMIO_MACCTL,
 			    b43_read32(dev, B43_MMIO_MACCTL)
 			    & ~B43_MACCTL_ENABLED);
 		/* force pci to flush the write */
 		b43_read32(dev, B43_MMIO_MACCTL);
-		for (i = 10000; i; i--) {
+		for (i = 40; i; i--) {
 			tmp = b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);
 			if (tmp & B43_IRQ_MAC_SUSPENDED)
 				goto out;
-			udelay(1);
+			msleep(1);
 		}
 		b43err(dev->wl, "MAC suspend failed\n");
 	}
-      out:
+out:
 	dev->mac_suspended++;
 }
 
@@ -2373,77 +2390,36 @@ static void do_periodic_work(struct b43_
 	b43_periodic_every15sec(dev);
 }
 
-/* Estimate a "Badness" value based on the periodic work
- * state-machine state. "Badness" is worse (bigger), if the
- * periodic work will take longer.
+/* Periodic work locking policy:
+ * 	The whole periodic work handler is protected by
+ * 	wl->mutex. If another lock is needed somewhere in the
+ * 	pwork callchain, it's aquired in-place, where it's needed.
  */
-static int estimate_periodic_work_badness(unsigned int state)
-{
-	int badness = 0;
-
-	if (state % 8 == 0)	/* every 120 sec */
-		badness += 10;
-	if (state % 4 == 0)	/* every 60 sec */
-		badness += 5;
-	if (state % 2 == 0)	/* every 30 sec */
-		badness += 1;
-
-#define BADNESS_LIMIT	4
-	return badness;
-}
-
 static void b43_periodic_work_handler(struct work_struct *work)
 {
-	struct b43_wldev *dev =
-	    container_of(work, struct b43_wldev, periodic_work.work);
-	unsigned long flags, delay;
-	u32 savedirqs = 0;
-	int badness;
+	struct b43_wldev *dev = container_of(work, struct b43_wldev,
+					     periodic_work.work);
+	struct b43_wl *wl = dev->wl;
+	unsigned long delay;
 
-	mutex_lock(&dev->wl->mutex);
+	mutex_lock(&wl->mutex);
 
 	if (unlikely(b43_status(dev) != B43_STAT_STARTED))
 		goto out;
 	if (b43_debug(dev, B43_DBG_PWORK_STOP))
 		goto out_requeue;
 
-	badness = estimate_periodic_work_badness(dev->periodic_state);
-	if (badness > BADNESS_LIMIT) {
-		spin_lock_irqsave(&dev->wl->irq_lock, flags);
-		/* Suspend TX as we don't want to transmit packets while
-		 * we recalibrate the hardware. */
-		b43_tx_suspend(dev);
-		savedirqs = b43_interrupt_disable(dev, B43_IRQ_ALL);
-		/* Periodic work will take a long time, so we want it to
-		 * be preemtible and release the spinlock. */
-		spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-		b43_synchronize_irq(dev);
-
-		do_periodic_work(dev);
+	do_periodic_work(dev);
 
-		spin_lock_irqsave(&dev->wl->irq_lock, flags);
-		b43_interrupt_enable(dev, savedirqs);
-		b43_tx_resume(dev);
-		mmiowb();
-		spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	} else {
-		/* Take the global driver lock. This will lock any operation. */
-		spin_lock_irqsave(&dev->wl->irq_lock, flags);
-
-		do_periodic_work(dev);
-
-		mmiowb();
-		spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
-	}
 	dev->periodic_state++;
 out_requeue:
 	if (b43_debug(dev, B43_DBG_PWORK_FAST))
 		delay = msecs_to_jiffies(50);
 	else
 		delay = round_jiffies(HZ * 15);
-	queue_delayed_work(dev->wl->hw->workqueue, &dev->periodic_work, delay);
+	queue_delayed_work(wl->hw->workqueue, &dev->periodic_work, delay);
 out:
-	mutex_unlock(&dev->wl->mutex);
+	mutex_unlock(&wl->mutex);
 }
 
 static void b43_periodic_tasks_setup(struct b43_wldev *dev)


From dwmw2 at infradead.org  Sat Sep 29 18:52:48 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Sat, 29 Sep 2007 17:52:48 +0100
Subject: [PATCH] b43: Use input-polldev for the rfkill switch
In-Reply-To: <200709281422.34434.mb@bu3sch.de>
References: <200709281422.34434.mb@bu3sch.de>
Message-ID: <1191084768.8203.10.camel@shinybook.infradead.org>

On Fri, 2007-09-28 at 14:22 +0200, Michael Buesch wrote:
> This removes the direct call to rfkill on an rfkill event
> and replaces it with an input device. This way userspace is also
> notified about the event.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

...

>  static void do_periodic_work(struct b43_wldev *dev)
>  {
>  	unsigned int state;
>  
>  	state = dev->periodic_state;
> -	if (state % 120 == 0)
> +	if (state % 8 == 0)
>  		b43_periodic_every120sec(dev);
> -	if (state % 60 == 0)
> +	if (state % 4 == 0)
>  		b43_periodic_every60sec(dev);
> -	if (state % 30 == 0)
> +	if (state % 2 == 0)
>  		b43_periodic_every30sec(dev);
> -	if (state % 15 == 0)
> -		b43_periodic_every15sec(dev);
> -	b43_periodic_every1sec(dev);
> +	b43_periodic_every15sec(dev);
>  }
>  
>  /* Estimate a "Badness" value based on the periodic work
> @@ -2429,13 +2400,11 @@ static int estimate_periodic_work_badnes
>  {
>  	int badness = 0;
>  
> -	if (state % 120 == 0)	/* every 120 sec */
> +	if (state % 8 == 0)	/* every 120 sec */
>  		badness += 10;
> -	if (state % 60 == 0)	/* every 60 sec */
> +	if (state % 4 == 0)	/* every 60 sec */
>  		badness += 5;
> -	if (state % 30 == 0)	/* every 30 sec */
> -		badness += 1;
> -	if (state % 15 == 0)	/* every 15 sec */
> +	if (state % 2 == 0)	/* every 30 sec */
>  		badness += 1;
>  
>  #define BADNESS_LIMIT	4
> @@ -2486,13 +2455,13 @@ static void b43_periodic_work_handler(st
>  		spin_unlock_irqrestore(&dev->wl->irq_lock, flags);
>  	}
>  	dev->periodic_state++;
> -      out_requeue:
> +out_requeue:
>  	if (b43_debug(dev, B43_DBG_PWORK_FAST))
>  		delay = msecs_to_jiffies(50);
>  	else
> -		delay = round_jiffies(HZ);
> +		delay = round_jiffies(HZ * 15);
>  	queue_delayed_work(dev->wl->hw->workqueue, &dev->periodic_work, delay);
> -      out:
> +out:
>  	mutex_unlock(&dev->wl->mutex);
>  }

Does this bit belong to your other patch?


-- 
dwmw2



From mb at bu3sch.de  Sat Sep 29 19:08:24 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 29 Sep 2007 19:08:24 +0200
Subject: [PATCH] b43: Use input-polldev for the rfkill switch
In-Reply-To: <1191084768.8203.10.camel@shinybook.infradead.org>
References: <200709281422.34434.mb@bu3sch.de>
	<1191084768.8203.10.camel@shinybook.infradead.org>
Message-ID: <200709291908.24758.mb@bu3sch.de>

On Saturday 29 September 2007 18:52:48 David Woodhouse wrote:
> Does this bit belong to your other patch?

I'm not sure what you are trying to ask.

-- 
Greetings Michael.


From dwmw2 at infradead.org  Sat Sep 29 19:14:34 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Sat, 29 Sep 2007 18:14:34 +0100
Subject: [PATCH] b43: Use input-polldev for the rfkill switch
In-Reply-To: <200709291908.24758.mb@bu3sch.de>
References: <200709281422.34434.mb@bu3sch.de>
	<1191084768.8203.10.camel@shinybook.infradead.org>
	<200709291908.24758.mb@bu3sch.de>
Message-ID: <1191086074.8203.18.camel@shinybook.infradead.org>

On Sat, 2007-09-29 at 19:08 +0200, Michael Buesch wrote:
> I'm not sure what you are trying to ask.

The hunks I quoted don't seem relevant to the rfkill switch. They seem
to be related to periodic work, which was the subject of the other patch
you posted at about the same time. Did you get them mixed up?
-- 
dwmw2



From mb at bu3sch.de  Sat Sep 29 19:32:57 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 29 Sep 2007 19:32:57 +0200
Subject: [PATCH] b43: Use input-polldev for the rfkill switch
In-Reply-To: <1191086074.8203.18.camel@shinybook.infradead.org>
References: <200709281422.34434.mb@bu3sch.de> <200709291908.24758.mb@bu3sch.de>
	<1191086074.8203.18.camel@shinybook.infradead.org>
Message-ID: <200709291932.57924.mb@bu3sch.de>

On Saturday 29 September 2007 19:14:34 David Woodhouse wrote:
> On Sat, 2007-09-29 at 19:08 +0200, Michael Buesch wrote:
> > I'm not sure what you are trying to ask.
> 
> The hunks I quoted don't seem relevant to the rfkill switch. They seem
> to be related to periodic work, which was the subject of the other patch
> you posted at about the same time. Did you get them mixed up?

The patch is correct as-is. RF-kill was polled by the periodic work.

-- 
Greetings Michael.


From dwmw2 at infradead.org  Sat Sep 29 20:09:11 2007
From: dwmw2 at infradead.org (David Woodhouse)
Date: Sat, 29 Sep 2007 19:09:11 +0100
Subject: [PATCH] b43: Use input-polldev for the rfkill switch
In-Reply-To: <200709291932.57924.mb@bu3sch.de>
References: <200709281422.34434.mb@bu3sch.de> <200709291908.24758.mb@bu3sch.de>
	<1191086074.8203.18.camel@shinybook.infradead.org>
	<200709291932.57924.mb@bu3sch.de>
Message-ID: <1191089351.2911.0.camel@shinybook.infradead.org>

On Sat, 2007-09-29 at 19:32 +0200, Michael Buesch wrote:
> The patch is correct as-is. RF-kill was polled by the periodic work.

OK, cool. Just checking.

-- 
dwmw2



From mb at bu3sch.de  Sun Sep 30 00:04:36 2007
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 30 Sep 2007 00:04:36 +0200
Subject: [PATCH] b43: Leds spinlock SMP compilefix
Message-ID: <200709300004.36905.mb@bu3sch.de>

This was missing an address operator.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

Index: wireless-2.6/drivers/net/wireless/b43/leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/leds.c	2007-09-29 12:44:08.000000000 +0200
+++ wireless-2.6/drivers/net/wireless/b43/leds.c	2007-09-30 00:02:18.000000000 +0200
@@ -37,14 +37,14 @@ static void b43_led_turn_on(struct b43_w
 	unsigned long flags;
 	u16 ctl;
 
-	spin_lock_irqsave(wl->leds_lock, flags);
+	spin_lock_irqsave(&wl->leds_lock, flags);
 	ctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);
 	if (activelow)
 		ctl &= ~(1 << led_index);
 	else
 		ctl |= (1 << led_index);
 	b43_write16(dev, B43_MMIO_GPIO_CONTROL, ctl);
-	spin_unlock_irqrestore(wl->leds_lock, flags);
+	spin_unlock_irqrestore(&wl->leds_lock, flags);
 }
 
 static void b43_led_turn_off(struct b43_wldev *dev, u8 led_index,
@@ -54,14 +54,14 @@ static void b43_led_turn_off(struct b43_
 	unsigned long flags;
 	u16 ctl;
 
-	spin_lock_irqsave(wl->leds_lock, flags);
+	spin_lock_irqsave(&wl->leds_lock, flags);
 	ctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);
 	if (activelow)
 		ctl |= (1 << led_index);
 	else
 		ctl &= ~(1 << led_index);
 	b43_write16(dev, B43_MMIO_GPIO_CONTROL, ctl);
-	spin_unlock_irqrestore(wl->leds_lock, flags);
+	spin_unlock_irqrestore(&wl->leds_lock, flags);
 }
 
 /* Callback from the LED subsystem. */


