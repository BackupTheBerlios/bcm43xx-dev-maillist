<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] remove bcm43xx
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/bcm43xx-dev/2007-November/index.html" >
   <LINK REL="made" HREF="mailto:bcm43xx-dev%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20remove%20bcm43xx&In-Reply-To=%3C20071119171217.557ea31f%40morte%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002800.html">
   <LINK REL="Next"  HREF="002804.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] remove bcm43xx</H1>
    <B>Stefano Brivio</B> 
    <A HREF="mailto:bcm43xx-dev%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20remove%20bcm43xx&In-Reply-To=%3C20071119171217.557ea31f%40morte%3E"
       TITLE="[PATCH] remove bcm43xx">stefano.brivio at polimi.it
       </A><BR>
    <I>Mon Nov 19 17:12:17 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="002800.html">[Bugme-new] [Bug 9402] New: Not work chipset broadcom 4318
</A></li>
        <LI>Next message: <A HREF="002804.html">[PATCH] remove bcm43xx
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2801">[ date ]</a>
              <a href="thread.html#2801">[ thread ]</a>
              <a href="subject.html#2801">[ subject ]</a>
              <a href="author.html#2801">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Remove bcm43xx. Fix some left-over URLs and ifdefs in b43 and b43legacy
drivers.


Signed-off-by: Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">stefano.brivio at polimi.it</A>&gt;

---

John,
this is for 2.6.25.

---

Index: wireless-2.6/drivers/net/wireless/bcm43xx/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/Kconfig
+++ /dev/null
@@ -1,67 +0,0 @@
-config BCM43XX
-	tristate &quot;Broadcom BCM43xx wireless support&quot;
-	depends on PCI &amp;&amp; IEEE80211 &amp;&amp; IEEE80211_SOFTMAC &amp;&amp; WLAN_80211 &amp;&amp; EXPERIMENTAL
-	select WIRELESS_EXT
-	select FW_LOADER
-	select HW_RANDOM
-	---help---
-	  This is an experimental driver for the Broadcom 43xx wireless chip,
-	  found in the Apple Airport Extreme and various other devices.
-
-config BCM43XX_DEBUG
-	bool &quot;Broadcom BCM43xx debugging (RECOMMENDED)&quot;
-	depends on BCM43XX
-	default y
-	---help---
-	  Broadcom 43xx debugging messages.
-	  Say Y, because the driver is still very experimental and
-	  this will help you get it running.
-
-config BCM43XX_DMA
-	bool
-	depends on BCM43XX
-
-config BCM43XX_PIO
-	bool
-	depends on BCM43XX
-
-choice
-	prompt &quot;BCM43xx data transfer mode&quot;
-	depends on BCM43XX
-	default BCM43XX_DMA_AND_PIO_MODE
-
-config BCM43XX_DMA_AND_PIO_MODE
-	bool &quot;DMA + PIO&quot;
-	select BCM43XX_DMA
-	select BCM43XX_PIO
-	---help---
-	  Include both, Direct Memory Access (DMA) and Programmed I/O (PIO)
-	  data transfer modes.
-	  The actually used mode is selectable through the module
-	  parameter &quot;pio&quot;. If the module parameter is pio=0, DMA is used.
-	  Otherwise PIO is used. DMA is default.
-
-	  If unsure, choose this option.
-
-config BCM43XX_DMA_MODE
-	bool &quot;DMA (Direct Memory Access) only&quot;
-	select BCM43XX_DMA
-	---help---
-	  Only include Direct Memory Access (DMA).
-	  This reduces the size of the driver module, by omitting the PIO code.
-
-config BCM43XX_PIO_MODE
-	bool &quot;PIO (Programmed I/O) only&quot;
-	select BCM43XX_PIO
-	---help---
-	  Only include Programmed I/O (PIO).
-	  This reduces the size of the driver module, by omitting the DMA code.
-	  Please note that PIO transfers are slow (compared to DMA).
-
-	  Also note that not all devices of the 43xx series support PIO.
-	  The 4306 (Apple Airport Extreme and others) supports PIO, while
-	  the 4318 is known to _not_ support PIO.
-
-	  Only use PIO, if DMA does not work for you.
-
-endchoice
Index: wireless-2.6/drivers/net/wireless/bcm43xx/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/Makefile
+++ /dev/null
@@ -1,12 +0,0 @@
-obj-$(CONFIG_BCM43XX) += bcm43xx.o
-bcm43xx-obj-$(CONFIG_BCM43XX_DEBUG) += bcm43xx_debugfs.o
-
-bcm43xx-obj-$(CONFIG_BCM43XX_DMA) += bcm43xx_dma.o
-bcm43xx-obj-$(CONFIG_BCM43XX_PIO) += bcm43xx_pio.o
-
-bcm43xx-objs := bcm43xx_main.o bcm43xx_ilt.o \
-		bcm43xx_radio.o bcm43xx_phy.o \
-		bcm43xx_power.o bcm43xx_wx.o \
-		bcm43xx_leds.o bcm43xx_ethtool.o \
-		bcm43xx_xmit.o bcm43xx_sysfs.o \
-		$(bcm43xx-obj-y)
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx.h
+++ /dev/null
@@ -1,997 +0,0 @@
-#ifndef BCM43xx_H_
-#define BCM43xx_H_
-
-#include &lt;linux/hw_random.h&gt;
-#include &lt;linux/version.h&gt;
-#include &lt;linux/kernel.h&gt;
-#include &lt;linux/spinlock.h&gt;
-#include &lt;linux/interrupt.h&gt;
-#include &lt;linux/stringify.h&gt;
-#include &lt;linux/pci.h&gt;
-#include &lt;net/ieee80211.h&gt;
-#include &lt;net/ieee80211softmac.h&gt;
-#include &lt;asm/atomic.h&gt;
-#include &lt;asm/io.h&gt;
-
-
-#include &quot;bcm43xx_debugfs.h&quot;
-#include &quot;bcm43xx_leds.h&quot;
-
-
-#define PFX				KBUILD_MODNAME &quot;: &quot;
-
-#define BCM43xx_SWITCH_CORE_MAX_RETRIES	50
-#define BCM43xx_IRQWAIT_MAX_RETRIES	100
-
-#define BCM43xx_IO_SIZE			8192
-
-/* Active Core PCI Configuration Register. */
-#define BCM43xx_PCICFG_ACTIVE_CORE	0x80
-/* SPROM control register. */
-#define BCM43xx_PCICFG_SPROMCTL		0x88
-/* Interrupt Control PCI Configuration Register. (Only on PCI cores with rev &gt;= 6) */
-#define BCM43xx_PCICFG_ICR		0x94
-
-/* MMIO offsets */
-#define BCM43xx_MMIO_DMA0_REASON	0x20
-#define BCM43xx_MMIO_DMA0_IRQ_MASK	0x24
-#define BCM43xx_MMIO_DMA1_REASON	0x28
-#define BCM43xx_MMIO_DMA1_IRQ_MASK	0x2C
-#define BCM43xx_MMIO_DMA2_REASON	0x30
-#define BCM43xx_MMIO_DMA2_IRQ_MASK	0x34
-#define BCM43xx_MMIO_DMA3_REASON	0x38
-#define BCM43xx_MMIO_DMA3_IRQ_MASK	0x3C
-#define BCM43xx_MMIO_DMA4_REASON	0x40
-#define BCM43xx_MMIO_DMA4_IRQ_MASK	0x44
-#define BCM43xx_MMIO_DMA5_REASON	0x48
-#define BCM43xx_MMIO_DMA5_IRQ_MASK	0x4C
-#define BCM43xx_MMIO_STATUS_BITFIELD	0x120
-#define BCM43xx_MMIO_STATUS2_BITFIELD	0x124
-#define BCM43xx_MMIO_GEN_IRQ_REASON	0x128
-#define BCM43xx_MMIO_GEN_IRQ_MASK	0x12C
-#define BCM43xx_MMIO_RAM_CONTROL	0x130
-#define BCM43xx_MMIO_RAM_DATA		0x134
-#define BCM43xx_MMIO_PS_STATUS		0x140
-#define BCM43xx_MMIO_RADIO_HWENABLED_HI	0x158
-#define BCM43xx_MMIO_SHM_CONTROL	0x160
-#define BCM43xx_MMIO_SHM_DATA		0x164
-#define BCM43xx_MMIO_SHM_DATA_UNALIGNED	0x166
-#define BCM43xx_MMIO_XMITSTAT_0		0x170
-#define BCM43xx_MMIO_XMITSTAT_1		0x174
-#define BCM43xx_MMIO_REV3PLUS_TSF_LOW	0x180 /* core rev &gt;= 3 only */
-#define BCM43xx_MMIO_REV3PLUS_TSF_HIGH	0x184 /* core rev &gt;= 3 only */
-
-/* 32-bit DMA */
-#define BCM43xx_MMIO_DMA32_BASE0	0x200
-#define BCM43xx_MMIO_DMA32_BASE1	0x220
-#define BCM43xx_MMIO_DMA32_BASE2	0x240
-#define BCM43xx_MMIO_DMA32_BASE3	0x260
-#define BCM43xx_MMIO_DMA32_BASE4	0x280
-#define BCM43xx_MMIO_DMA32_BASE5	0x2A0
-/* 64-bit DMA */
-#define BCM43xx_MMIO_DMA64_BASE0	0x200
-#define BCM43xx_MMIO_DMA64_BASE1	0x240
-#define BCM43xx_MMIO_DMA64_BASE2	0x280
-#define BCM43xx_MMIO_DMA64_BASE3	0x2C0
-#define BCM43xx_MMIO_DMA64_BASE4	0x300
-#define BCM43xx_MMIO_DMA64_BASE5	0x340
-/* PIO */
-#define BCM43xx_MMIO_PIO1_BASE		0x300
-#define BCM43xx_MMIO_PIO2_BASE		0x310
-#define BCM43xx_MMIO_PIO3_BASE		0x320
-#define BCM43xx_MMIO_PIO4_BASE		0x330
-
-#define BCM43xx_MMIO_PHY_VER		0x3E0
-#define BCM43xx_MMIO_PHY_RADIO		0x3E2
-#define BCM43xx_MMIO_ANTENNA		0x3E8
-#define BCM43xx_MMIO_CHANNEL		0x3F0
-#define BCM43xx_MMIO_CHANNEL_EXT	0x3F4
-#define BCM43xx_MMIO_RADIO_CONTROL	0x3F6
-#define BCM43xx_MMIO_RADIO_DATA_HIGH	0x3F8
-#define BCM43xx_MMIO_RADIO_DATA_LOW	0x3FA
-#define BCM43xx_MMIO_PHY_CONTROL	0x3FC
-#define BCM43xx_MMIO_PHY_DATA		0x3FE
-#define BCM43xx_MMIO_MACFILTER_CONTROL	0x420
-#define BCM43xx_MMIO_MACFILTER_DATA	0x422
-#define BCM43xx_MMIO_RADIO_HWENABLED_LO	0x49A
-#define BCM43xx_MMIO_GPIO_CONTROL	0x49C
-#define BCM43xx_MMIO_GPIO_MASK		0x49E
-#define BCM43xx_MMIO_TSF_0		0x632 /* core rev &lt; 3 only */
-#define BCM43xx_MMIO_TSF_1		0x634 /* core rev &lt; 3 only */
-#define BCM43xx_MMIO_TSF_2		0x636 /* core rev &lt; 3 only */
-#define BCM43xx_MMIO_TSF_3		0x638 /* core rev &lt; 3 only */
-#define BCM43xx_MMIO_RNG		0x65A
-#define BCM43xx_MMIO_POWERUP_DELAY	0x6A8
-
-/* SPROM offsets. */
-#define BCM43xx_SPROM_BASE		0x1000
-#define BCM43xx_SPROM_BOARDFLAGS2	0x1c
-#define BCM43xx_SPROM_IL0MACADDR	0x24
-#define BCM43xx_SPROM_ET0MACADDR	0x27
-#define BCM43xx_SPROM_ET1MACADDR	0x2a
-#define BCM43xx_SPROM_ETHPHY		0x2d
-#define BCM43xx_SPROM_BOARDREV		0x2e
-#define BCM43xx_SPROM_PA0B0		0x2f
-#define BCM43xx_SPROM_PA0B1		0x30
-#define BCM43xx_SPROM_PA0B2		0x31
-#define BCM43xx_SPROM_WL0GPIO0		0x32
-#define BCM43xx_SPROM_WL0GPIO2		0x33
-#define BCM43xx_SPROM_MAXPWR		0x34
-#define BCM43xx_SPROM_PA1B0		0x35
-#define BCM43xx_SPROM_PA1B1		0x36
-#define BCM43xx_SPROM_PA1B2		0x37
-#define BCM43xx_SPROM_IDL_TSSI_TGT	0x38
-#define BCM43xx_SPROM_BOARDFLAGS	0x39
-#define BCM43xx_SPROM_ANTENNA_GAIN	0x3a
-#define BCM43xx_SPROM_VERSION		0x3f
-
-/* BCM43xx_SPROM_BOARDFLAGS values */
-#define BCM43xx_BFL_BTCOEXIST		0x0001 /* implements Bluetooth coexistance */
-#define BCM43xx_BFL_PACTRL		0x0002 /* GPIO 9 controlling the PA */
-#define BCM43xx_BFL_AIRLINEMODE		0x0004 /* implements GPIO 13 radio disable indication */
-#define BCM43xx_BFL_RSSI		0x0008 /* software calculates nrssi slope. */
-#define BCM43xx_BFL_ENETSPI		0x0010 /* has ephy roboswitch spi */
-#define BCM43xx_BFL_XTAL_NOSLOW		0x0020 /* no slow clock available */
-#define BCM43xx_BFL_CCKHIPWR		0x0040 /* can do high power CCK transmission */
-#define BCM43xx_BFL_ENETADM		0x0080 /* has ADMtek switch */
-#define BCM43xx_BFL_ENETVLAN		0x0100 /* can do vlan */
-#define BCM43xx_BFL_AFTERBURNER		0x0200 /* supports Afterburner mode */
-#define BCM43xx_BFL_NOPCI		0x0400 /* leaves PCI floating */
-#define BCM43xx_BFL_FEM			0x0800 /* supports the Front End Module */
-#define BCM43xx_BFL_EXTLNA		0x1000 /* has an external LNA */
-#define BCM43xx_BFL_HGPA		0x2000 /* had high gain PA */
-#define BCM43xx_BFL_BTCMOD		0x4000 /* BFL_BTCOEXIST is given in alternate GPIOs */
-#define BCM43xx_BFL_ALTIQ		0x8000 /* alternate I/Q settings */
-
-/* GPIO register offset, in both ChipCommon and PCI core. */
-#define BCM43xx_GPIO_CONTROL		0x6c
-
-/* SHM Routing */
-#define BCM43xx_SHM_SHARED		0x0001
-#define BCM43xx_SHM_WIRELESS		0x0002
-#define BCM43xx_SHM_PCM			0x0003
-#define BCM43xx_SHM_HWMAC		0x0004
-#define BCM43xx_SHM_UCODE		0x0300
-
-/* MacFilter offsets. */
-#define BCM43xx_MACFILTER_SELF		0x0000
-#define BCM43xx_MACFILTER_ASSOC		0x0003
-
-/* Chipcommon registers. */
-#define BCM43xx_CHIPCOMMON_CAPABILITIES 	0x04
-#define BCM43xx_CHIPCOMMON_CTL			0x28
-#define BCM43xx_CHIPCOMMON_PLLONDELAY		0xB0
-#define BCM43xx_CHIPCOMMON_FREFSELDELAY		0xB4
-#define BCM43xx_CHIPCOMMON_SLOWCLKCTL		0xB8
-#define BCM43xx_CHIPCOMMON_SYSCLKCTL		0xC0
-
-/* PCI core specific registers. */
-#define BCM43xx_PCICORE_BCAST_ADDR	0x50
-#define BCM43xx_PCICORE_BCAST_DATA	0x54
-#define BCM43xx_PCICORE_SBTOPCI2	0x108
-
-/* SBTOPCI2 values. */
-#define BCM43xx_SBTOPCI2_PREFETCH	0x4
-#define BCM43xx_SBTOPCI2_BURST		0x8
-#define BCM43xx_SBTOPCI2_MEMREAD_MULTI	0x20
-
-/* PCI-E core registers. */
-#define BCM43xx_PCIECORE_REG_ADDR      0x0130
-#define BCM43xx_PCIECORE_REG_DATA      0x0134
-#define BCM43xx_PCIECORE_MDIO_CTL      0x0128
-#define BCM43xx_PCIECORE_MDIO_DATA     0x012C
-
-/* PCI-E registers. */
-#define BCM43xx_PCIE_TLP_WORKAROUND    0x0004
-#define BCM43xx_PCIE_DLLP_LINKCTL      0x0100
-
-/* PCI-E MDIO bits. */
-#define BCM43xx_PCIE_MDIO_ST   0x40000000
-#define BCM43xx_PCIE_MDIO_WT   0x10000000
-#define BCM43xx_PCIE_MDIO_DEV  22
-#define BCM43xx_PCIE_MDIO_REG  18
-#define BCM43xx_PCIE_MDIO_TA   0x00020000
-#define BCM43xx_PCIE_MDIO_TC   0x0100
-
-/* MDIO devices. */
-#define BCM43xx_MDIO_SERDES_RX	0x1F
-
-/* SERDES RX registers. */
-#define BCM43xx_SERDES_RXTIMER	0x2
-#define BCM43xx_SERDES_CDR	0x6
-#define BCM43xx_SERDES_CDR_BW	0x7
-
-/* Chipcommon capabilities. */
-#define BCM43xx_CAPABILITIES_PCTL		0x00040000
-#define BCM43xx_CAPABILITIES_PLLMASK		0x00030000
-#define BCM43xx_CAPABILITIES_PLLSHIFT		16
-#define BCM43xx_CAPABILITIES_FLASHMASK		0x00000700
-#define BCM43xx_CAPABILITIES_FLASHSHIFT		8
-#define BCM43xx_CAPABILITIES_EXTBUSPRESENT	0x00000040
-#define BCM43xx_CAPABILITIES_UARTGPIO		0x00000020
-#define BCM43xx_CAPABILITIES_UARTCLOCKMASK	0x00000018
-#define BCM43xx_CAPABILITIES_UARTCLOCKSHIFT	3
-#define BCM43xx_CAPABILITIES_MIPSBIGENDIAN	0x00000004
-#define BCM43xx_CAPABILITIES_NRUARTSMASK	0x00000003
-
-/* PowerControl */
-#define BCM43xx_PCTL_IN			0xB0
-#define BCM43xx_PCTL_OUT		0xB4
-#define BCM43xx_PCTL_OUTENABLE		0xB8
-#define BCM43xx_PCTL_XTAL_POWERUP	0x40
-#define BCM43xx_PCTL_PLL_POWERDOWN	0x80
-
-/* PowerControl Clock Modes */
-#define BCM43xx_PCTL_CLK_FAST		0x00
-#define BCM43xx_PCTL_CLK_SLOW		0x01
-#define BCM43xx_PCTL_CLK_DYNAMIC	0x02
-
-#define BCM43xx_PCTL_FORCE_SLOW		0x0800
-#define BCM43xx_PCTL_FORCE_PLL		0x1000
-#define BCM43xx_PCTL_DYN_XTAL		0x2000
-
-/* COREIDs */
-#define BCM43xx_COREID_CHIPCOMMON	0x800
-#define BCM43xx_COREID_ILINE20          0x801
-#define BCM43xx_COREID_SDRAM            0x803
-#define BCM43xx_COREID_PCI		0x804
-#define BCM43xx_COREID_MIPS             0x805
-#define BCM43xx_COREID_ETHERNET         0x806
-#define BCM43xx_COREID_V90		0x807
-#define BCM43xx_COREID_USB11_HOSTDEV    0x80a
-#define BCM43xx_COREID_IPSEC            0x80b
-#define BCM43xx_COREID_PCMCIA		0x80d
-#define BCM43xx_COREID_EXT_IF           0x80f
-#define BCM43xx_COREID_80211		0x812
-#define BCM43xx_COREID_MIPS_3302        0x816
-#define BCM43xx_COREID_USB11_HOST       0x817
-#define BCM43xx_COREID_USB11_DEV        0x818
-#define BCM43xx_COREID_USB20_HOST       0x819
-#define BCM43xx_COREID_USB20_DEV        0x81a
-#define BCM43xx_COREID_SDIO_HOST        0x81b
-#define BCM43xx_COREID_PCIE		0x820
-
-/* Core Information Registers */
-#define BCM43xx_CIR_BASE		0xf00
-#define BCM43xx_CIR_SBTPSFLAG		(BCM43xx_CIR_BASE + 0x18)
-#define BCM43xx_CIR_SBIMSTATE		(BCM43xx_CIR_BASE + 0x90)
-#define BCM43xx_CIR_SBINTVEC		(BCM43xx_CIR_BASE + 0x94)
-#define BCM43xx_CIR_SBTMSTATELOW	(BCM43xx_CIR_BASE + 0x98)
-#define BCM43xx_CIR_SBTMSTATEHIGH	(BCM43xx_CIR_BASE + 0x9c)
-#define BCM43xx_CIR_SBIMCONFIGLOW	(BCM43xx_CIR_BASE + 0xa8)
-#define BCM43xx_CIR_SB_ID_HI		(BCM43xx_CIR_BASE + 0xfc)
-
-/* Mask to get the Backplane Flag Number from SBTPSFLAG. */
-#define BCM43xx_BACKPLANE_FLAG_NR_MASK	0x3f
-
-/* SBIMCONFIGLOW values/masks. */
-#define BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_MASK		0x00000007
-#define BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_SHIFT	0
-#define BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_MASK		0x00000070
-#define BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_SHIFT	4
-#define BCM43xx_SBIMCONFIGLOW_CONNID_MASK		0x00ff0000
-#define BCM43xx_SBIMCONFIGLOW_CONNID_SHIFT		16
-
-/* sbtmstatelow state flags */
-#define BCM43xx_SBTMSTATELOW_RESET		0x01
-#define BCM43xx_SBTMSTATELOW_REJECT		0x02
-#define BCM43xx_SBTMSTATELOW_CLOCK		0x10000
-#define BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK	0x20000
-#define BCM43xx_SBTMSTATELOW_G_MODE_ENABLE	0x20000000
-
-/* sbtmstatehigh state flags */
-#define BCM43xx_SBTMSTATEHIGH_SERROR		0x00000001
-#define BCM43xx_SBTMSTATEHIGH_BUSY		0x00000004
-#define BCM43xx_SBTMSTATEHIGH_TIMEOUT		0x00000020
-#define BCM43xx_SBTMSTATEHIGH_G_PHY_AVAIL	0x00010000
-#define BCM43xx_SBTMSTATEHIGH_A_PHY_AVAIL	0x00020000
-#define BCM43xx_SBTMSTATEHIGH_COREFLAGS		0x1FFF0000
-#define BCM43xx_SBTMSTATEHIGH_DMA64BIT		0x10000000
-#define BCM43xx_SBTMSTATEHIGH_GATEDCLK		0x20000000
-#define BCM43xx_SBTMSTATEHIGH_BISTFAILED	0x40000000
-#define BCM43xx_SBTMSTATEHIGH_BISTCOMPLETE	0x80000000
-
-/* sbimstate flags */
-#define BCM43xx_SBIMSTATE_IB_ERROR		0x20000
-#define BCM43xx_SBIMSTATE_TIMEOUT		0x40000
-
-/* PHYVersioning */
-#define BCM43xx_PHYTYPE_A		0x00
-#define BCM43xx_PHYTYPE_B		0x01
-#define BCM43xx_PHYTYPE_G		0x02
-
-/* PHYRegisters */
-#define BCM43xx_PHY_ILT_A_CTRL		0x0072
-#define BCM43xx_PHY_ILT_A_DATA1		0x0073
-#define BCM43xx_PHY_ILT_A_DATA2		0x0074
-#define BCM43xx_PHY_G_LO_CONTROL	0x0810
-#define BCM43xx_PHY_ILT_G_CTRL		0x0472
-#define BCM43xx_PHY_ILT_G_DATA1		0x0473
-#define BCM43xx_PHY_ILT_G_DATA2		0x0474
-#define BCM43xx_PHY_A_PCTL		0x007B
-#define BCM43xx_PHY_G_PCTL		0x0029
-#define BCM43xx_PHY_A_CRS		0x0029
-#define BCM43xx_PHY_RADIO_BITFIELD	0x0401
-#define BCM43xx_PHY_G_CRS		0x0429
-#define BCM43xx_PHY_NRSSILT_CTRL	0x0803
-#define BCM43xx_PHY_NRSSILT_DATA	0x0804
-
-/* RadioRegisters */
-#define BCM43xx_RADIOCTL_ID		0x01
-
-/* StatusBitField */
-#define BCM43xx_SBF_MAC_ENABLED		0x00000001
-#define BCM43xx_SBF_2			0x00000002 /*FIXME: fix name*/
-#define BCM43xx_SBF_CORE_READY		0x00000004
-#define BCM43xx_SBF_400			0x00000400 /*FIXME: fix name*/
-#define BCM43xx_SBF_4000		0x00004000 /*FIXME: fix name*/
-#define BCM43xx_SBF_8000		0x00008000 /*FIXME: fix name*/
-#define BCM43xx_SBF_XFER_REG_BYTESWAP	0x00010000
-#define BCM43xx_SBF_MODE_NOTADHOC	0x00020000
-#define BCM43xx_SBF_MODE_AP		0x00040000
-#define BCM43xx_SBF_RADIOREG_LOCK	0x00080000
-#define BCM43xx_SBF_MODE_MONITOR	0x00400000
-#define BCM43xx_SBF_MODE_PROMISC	0x01000000
-#define BCM43xx_SBF_PS1			0x02000000
-#define BCM43xx_SBF_PS2			0x04000000
-#define BCM43xx_SBF_NO_SSID_BCAST	0x08000000
-#define BCM43xx_SBF_TIME_UPDATE		0x10000000
-#define BCM43xx_SBF_MODE_G		0x80000000
-
-/* Microcode */
-#define BCM43xx_UCODE_REVISION		0x0000
-#define BCM43xx_UCODE_PATCHLEVEL	0x0002
-#define BCM43xx_UCODE_DATE		0x0004
-#define BCM43xx_UCODE_TIME		0x0006
-#define BCM43xx_UCODE_STATUS		0x0040
-
-/* MicrocodeFlagsBitfield (addr + lo-word values?)*/
-#define BCM43xx_UCODEFLAGS_OFFSET	0x005E
-
-#define BCM43xx_UCODEFLAG_AUTODIV	0x0001
-#define BCM43xx_UCODEFLAG_UNKBGPHY	0x0002
-#define BCM43xx_UCODEFLAG_UNKBPHY	0x0004
-#define BCM43xx_UCODEFLAG_UNKGPHY	0x0020
-#define BCM43xx_UCODEFLAG_UNKPACTRL	0x0040
-#define BCM43xx_UCODEFLAG_JAPAN		0x0080
-
-/* Hardware Radio Enable masks */
-#define BCM43xx_MMIO_RADIO_HWENABLED_HI_MASK (1 &lt;&lt; 16)
-#define BCM43xx_MMIO_RADIO_HWENABLED_LO_MASK (1 &lt;&lt; 4)
-
-/* Generic-Interrupt reasons. */
-#define BCM43xx_IRQ_READY		(1 &lt;&lt; 0)
-#define BCM43xx_IRQ_BEACON		(1 &lt;&lt; 1)
-#define BCM43xx_IRQ_PS			(1 &lt;&lt; 2)
-#define BCM43xx_IRQ_REG124		(1 &lt;&lt; 5)
-#define BCM43xx_IRQ_PMQ			(1 &lt;&lt; 6)
-#define BCM43xx_IRQ_PIO_WORKAROUND	(1 &lt;&lt; 8)
-#define BCM43xx_IRQ_XMIT_ERROR		(1 &lt;&lt; 11)
-#define BCM43xx_IRQ_RX			(1 &lt;&lt; 15)
-#define BCM43xx_IRQ_SCAN		(1 &lt;&lt; 16)
-#define BCM43xx_IRQ_NOISE		(1 &lt;&lt; 18)
-#define BCM43xx_IRQ_XMIT_STATUS		(1 &lt;&lt; 29)
-
-#define BCM43xx_IRQ_ALL			0xffffffff
-#define BCM43xx_IRQ_INITIAL		(BCM43xx_IRQ_PS |		\
-					 BCM43xx_IRQ_REG124 |		\
-					 BCM43xx_IRQ_PMQ |		\
-					 BCM43xx_IRQ_XMIT_ERROR |	\
-					 BCM43xx_IRQ_RX |		\
-					 BCM43xx_IRQ_SCAN |		\
-					 BCM43xx_IRQ_NOISE |		\
-					 BCM43xx_IRQ_XMIT_STATUS)
-					 
-
-/* Initial default iw_mode */
-#define BCM43xx_INITIAL_IWMODE			IW_MODE_INFRA
-
-/* Bus type PCI. */
-#define BCM43xx_BUSTYPE_PCI	0
-/* Bus type Silicone Backplane Bus. */
-#define BCM43xx_BUSTYPE_SB	1
-/* Bus type PCMCIA. */
-#define BCM43xx_BUSTYPE_PCMCIA	2
-
-/* Threshold values. */
-#define BCM43xx_MIN_RTS_THRESHOLD		1U
-#define BCM43xx_MAX_RTS_THRESHOLD		2304U
-#define BCM43xx_DEFAULT_RTS_THRESHOLD		BCM43xx_MAX_RTS_THRESHOLD
-
-#define BCM43xx_DEFAULT_SHORT_RETRY_LIMIT	7
-#define BCM43xx_DEFAULT_LONG_RETRY_LIMIT	4
-
-/* FIXME: the next line is a guess as to what the maximum RSSI value might be */
-#define RX_RSSI_MAX				60
-
-/* Max size of a security key */
-#define BCM43xx_SEC_KEYSIZE			16
-/* Security algorithms. */
-enum {
-	BCM43xx_SEC_ALGO_NONE = 0, /* unencrypted, as of TX header. */
-	BCM43xx_SEC_ALGO_WEP,
-	BCM43xx_SEC_ALGO_UNKNOWN,
-	BCM43xx_SEC_ALGO_AES,
-	BCM43xx_SEC_ALGO_WEP104,
-	BCM43xx_SEC_ALGO_TKIP,
-};
-
-#ifdef assert
-# undef assert
-#endif
-#ifdef CONFIG_BCM43XX_DEBUG
-#define assert(expr) \
-	do {									\
-		if (unlikely(!(expr))) {					\
-		printk(KERN_ERR PFX &quot;ASSERTION FAILED (%s) at: %s:%d:%s()\n&quot;,	\
-			#expr, __FILE__, __LINE__, __FUNCTION__);		\
-		}								\
-	} while (0)
-#else
-#define assert(expr)	do { /* nothing */ } while (0)
-#endif
-
-/* rate limited printk(). */
-#ifdef printkl
-# undef printkl
-#endif
-#define printkl(f, x...)  do { if (printk_ratelimit()) printk(f ,##x); } while (0)
-/* rate limited printk() for debugging */
-#ifdef dprintkl
-# undef dprintkl
-#endif
-#ifdef CONFIG_BCM43XX_DEBUG
-# define dprintkl		printkl
-#else
-# define dprintkl(f, x...)	do { /* nothing */ } while (0)
-#endif
-
-/* Helper macro for if branches.
- * An if branch marked with this macro is only taken in DEBUG mode.
- * Example:
- *	if (DEBUG_ONLY(foo == bar)) {
- *		do something
- *	}
- *	In DEBUG mode, the branch will be taken if (foo == bar).
- *	In non-DEBUG mode, the branch will never be taken.
- */
-#ifdef DEBUG_ONLY
-# undef DEBUG_ONLY
-#endif
-#ifdef CONFIG_BCM43XX_DEBUG
-# define DEBUG_ONLY(x)	(x)
-#else
-# define DEBUG_ONLY(x)	0
-#endif
-
-/* debugging printk() */
-#ifdef dprintk
-# undef dprintk
-#endif
-#ifdef CONFIG_BCM43XX_DEBUG
-# define dprintk(f, x...)  do { printk(f ,##x); } while (0)
-#else
-# define dprintk(f, x...)  do { /* nothing */ } while (0)
-#endif
-
-
-struct net_device;
-struct pci_dev;
-struct bcm43xx_dmaring;
-struct bcm43xx_pioqueue;
-
-struct bcm43xx_initval {
-	u16 offset;
-	u16 size;
-	u32 value;
-} __attribute__((__packed__));
-
-/* Values for bcm430x_sprominfo.locale */
-enum {
-	BCM43xx_LOCALE_WORLD = 0,
-	BCM43xx_LOCALE_THAILAND,
-	BCM43xx_LOCALE_ISRAEL,
-	BCM43xx_LOCALE_JORDAN,
-	BCM43xx_LOCALE_CHINA,
-	BCM43xx_LOCALE_JAPAN,
-	BCM43xx_LOCALE_USA_CANADA_ANZ,
-	BCM43xx_LOCALE_EUROPE,
-	BCM43xx_LOCALE_USA_LOW,
-	BCM43xx_LOCALE_JAPAN_HIGH,
-	BCM43xx_LOCALE_ALL,
-	BCM43xx_LOCALE_NONE,
-};
-
-#define BCM43xx_SPROM_SIZE	64 /* in 16-bit words. */
-struct bcm43xx_sprominfo {
-	u16 boardflags2;
-	u8 il0macaddr[6];
-	u8 et0macaddr[6];
-	u8 et1macaddr[6];
-	u8 et0phyaddr:5;
-	u8 et1phyaddr:5;
-	u8 boardrev;
-	u8 locale:4;
-	u8 antennas_aphy:2;
-	u8 antennas_bgphy:2;
-	u16 pa0b0;
-	u16 pa0b1;
-	u16 pa0b2;
-	u8 wl0gpio0;
-	u8 wl0gpio1;
-	u8 wl0gpio2;
-	u8 wl0gpio3;
-	u8 maxpower_aphy;
-	u8 maxpower_bgphy;
-	u16 pa1b0;
-	u16 pa1b1;
-	u16 pa1b2;
-	u8 idle_tssi_tgt_aphy;
-	u8 idle_tssi_tgt_bgphy;
-	u16 boardflags;
-	u16 antennagain_aphy;
-	u16 antennagain_bgphy;
-};
-
-/* Value pair to measure the LocalOscillator. */
-struct bcm43xx_lopair {
-	s8 low;
-	s8 high;
-	u8 used:1;
-};
-#define BCM43xx_LO_COUNT	(14*4)
-
-struct bcm43xx_phyinfo {
-	/* Hardware Data */
-	u8 analog;
-	u8 type;
-	u8 rev;
-	u16 antenna_diversity;
-	u16 savedpctlreg;
-	u16 minlowsig[2];
-	u16 minlowsigpos[2];
-	u8 connected:1,
-	   calibrated:1,
-	   is_locked:1, /* used in bcm43xx_phy_{un}lock() */
-	   dyn_tssi_tbl:1; /* used in bcm43xx_phy_init_tssi2dbm_table() */
-	/* LO Measurement Data.
-	 * Use bcm43xx_get_lopair() to get a value.
-	 */
-	struct bcm43xx_lopair *_lo_pairs;
-
-	/* TSSI to dBm table in use */
-	const s8 *tssi2dbm;
-	/* idle TSSI value */
-	s8 idle_tssi;
-
-	/* Values from bcm43xx_calc_loopback_gain() */
-	u16 loopback_gain[2];
-
-	/* PHY lock for core.rev &lt; 3
-	 * This lock is only used by bcm43xx_phy_{un}lock()
-	 */
-	spinlock_t lock;
-
-	/* Firmware. */
-	const struct firmware *ucode;
-	const struct firmware *pcm;
-	const struct firmware *initvals0;
-	const struct firmware *initvals1;
-};
-
-
-struct bcm43xx_radioinfo {
-	u16 manufact;
-	u16 version;
-	u8 revision;
-
-	/* Desired TX power in dBm Q5.2 */
-	u16 txpower_desired;
-	/* TX Power control values. */
-	union {
-		/* B/G PHY */
-		struct {
-			u16 baseband_atten;
-			u16 radio_atten;
-			u16 txctl1;
-			u16 txctl2;
-		};
-		/* A PHY */
-		struct {
-			u16 txpwr_offset;
-		};
-	};
-
-	/* Current Interference Mitigation mode */
-	int interfmode;
-	/* Stack of saved values from the Interference Mitigation code.
-	 * Each value in the stack is layed out as follows:
-	 * bit 0-11:  offset
-	 * bit 12-15: register ID
-	 * bit 16-32: value
-	 * register ID is: 0x1 PHY, 0x2 Radio, 0x3 ILT
-	 */
-#define BCM43xx_INTERFSTACK_SIZE	26
-	u32 interfstack[BCM43xx_INTERFSTACK_SIZE];
-
-	/* Saved values from the NRSSI Slope calculation */
-	s16 nrssi[2];
-	s32 nrssislope;
-	/* In memory nrssi lookup table. */
-	s8 nrssi_lt[64];
-
-	/* current channel */
-	u8 channel;
-	u8 initial_channel;
-
-	u16 lofcal;
-
-	u16 initval;
-
-	u8 enabled:1;
-	/* ACI (adjacent channel interference) flags. */
-	u8 aci_enable:1,
-	   aci_wlan_automatic:1,
-	   aci_hw_rssi:1;
-};
-
-/* Data structures for DMA transmission, per 80211 core. */
-struct bcm43xx_dma {
-	struct bcm43xx_dmaring *tx_ring0;
-	struct bcm43xx_dmaring *tx_ring1;
-	struct bcm43xx_dmaring *tx_ring2;
-	struct bcm43xx_dmaring *tx_ring3;
-	struct bcm43xx_dmaring *tx_ring4;
-	struct bcm43xx_dmaring *tx_ring5;
-
-	struct bcm43xx_dmaring *rx_ring0;
-	struct bcm43xx_dmaring *rx_ring3; /* only available on core.rev &lt; 5 */
-};
-
-/* Data structures for PIO transmission, per 80211 core. */
-struct bcm43xx_pio {
-	struct bcm43xx_pioqueue *queue0;
-	struct bcm43xx_pioqueue *queue1;
-	struct bcm43xx_pioqueue *queue2;
-	struct bcm43xx_pioqueue *queue3;
-};
-
-#define BCM43xx_MAX_80211_CORES		2
-
-/* Generic information about a core. */
-struct bcm43xx_coreinfo {
-	u8 available:1,
-	   enabled:1,
-	   initialized:1;
-	/** core_rev revision number */
-	u8 rev;
-	/** Index number for _switch_core() */
-	u8 index;
-	/** core_id ID number */
-	u16 id;
-	/** Core-specific data. */
-	void *priv;
-};
-
-/* Additional information for each 80211 core. */
-struct bcm43xx_coreinfo_80211 {
-	/* PHY device. */
-	struct bcm43xx_phyinfo phy;
-	/* Radio device. */
-	struct bcm43xx_radioinfo radio;
-	union {
-		/* DMA context. */
-		struct bcm43xx_dma dma;
-		/* PIO context. */
-		struct bcm43xx_pio pio;
-	};
-};
-
-/* Context information for a noise calculation (Link Quality). */
-struct bcm43xx_noise_calculation {
-	struct bcm43xx_coreinfo *core_at_start;
-	u8 channel_at_start;
-	u8 calculation_running:1;
-	u8 nr_samples;
-	s8 samples[8][4];
-};
-
-struct bcm43xx_stats {
-	u8 noise;
-	struct iw_statistics wstats;
-	/* Store the last TX/RX times here for updating the leds. */
-	unsigned long last_tx;
-	unsigned long last_rx;
-};
-
-struct bcm43xx_key {
-	u8 enabled:1;
-	u8 algorithm;
-};
-
-/* Driver initialization status. */
-enum {
-	BCM43xx_STAT_UNINIT,		/* Uninitialized. */
-	BCM43xx_STAT_INITIALIZING,	/* init_board() in progress. */
-	BCM43xx_STAT_INITIALIZED,	/* Fully operational. */
-	BCM43xx_STAT_SHUTTINGDOWN,	/* free_board() in progress. */
-	BCM43xx_STAT_RESTARTING,	/* controller_restart() called. */
-};
-#define bcm43xx_status(bcm)		atomic_read(&amp;(bcm)-&gt;init_status)
-#define bcm43xx_set_status(bcm, stat)	do {			\
-		atomic_set(&amp;(bcm)-&gt;init_status, (stat));	\
-		smp_wmb();					\
-					} while (0)
-
-/*    *** THEORY OF LOCKING ***
- *
- * We have two different locks in the bcm43xx driver.
- * =&gt; bcm-&gt;mutex:    General sleeping mutex. Protects struct bcm43xx_private
- *                   and the device registers. This mutex does _not_ protect
- *                   against concurrency from the IRQ handler.
- * =&gt; bcm-&gt;irq_lock: IRQ spinlock. Protects against IRQ handler concurrency.
- *
- * Please note that, if you only take the irq_lock, you are not protected
- * against concurrency from the periodic work handlers.
- * Most times you want to take _both_ locks.
- */
-
-struct bcm43xx_private {
-	struct ieee80211_device *ieee;
-	struct ieee80211softmac_device *softmac;
-
-	struct net_device *net_dev;
-	struct pci_dev *pci_dev;
-	unsigned int irq;
-
-	void __iomem *mmio_addr;
-
-	spinlock_t irq_lock;
-	struct mutex mutex;
-
-	/* Driver initialization status BCM43xx_STAT_*** */
-	atomic_t init_status;
-
-	u16 was_initialized:1,		/* for PCI suspend/resume. */
-	    __using_pio:1,		/* Internal, use bcm43xx_using_pio(). */
-	    bad_frames_preempt:1,	/* Use &quot;Bad Frames Preemption&quot; (default off) */
-	    reg124_set_0x4:1,		/* Some variable to keep track of IRQ stuff. */
-	    short_preamble:1,		/* TRUE, if short preamble is enabled. */
-	    firmware_norelease:1,	/* Do not release the firmware. Used on suspend. */
-	    radio_hw_enable:1;		/* TRUE if radio is hardware enabled */
-
-	struct bcm43xx_stats stats;
-
-	/* Bus type we are connected to.
-	 * This is currently always BCM43xx_BUSTYPE_PCI
-	 */
-	u8 bustype;
-	u64 dma_mask;
-
-	u16 board_vendor;
-	u16 board_type;
-	u16 board_revision;
-
-	u16 chip_id;
-	u8 chip_rev;
-	u8 chip_package;
-
-	struct bcm43xx_sprominfo sprom;
-#define BCM43xx_NR_LEDS		4
-	struct bcm43xx_led leds[BCM43xx_NR_LEDS];
-	spinlock_t leds_lock;
-
-	/* The currently active core. */
-	struct bcm43xx_coreinfo *current_core;
-	struct bcm43xx_coreinfo *active_80211_core;
-	/* coreinfo structs for all possible cores follow.
-	 * Note that a core might not exist.
-	 * So check the coreinfo flags before using it.
-	 */
-	struct bcm43xx_coreinfo core_chipcommon;
-	struct bcm43xx_coreinfo core_pci;
-	struct bcm43xx_coreinfo core_80211[ BCM43xx_MAX_80211_CORES ];
-	/* Additional information, specific to the 80211 cores. */
-	struct bcm43xx_coreinfo_80211 core_80211_ext[ BCM43xx_MAX_80211_CORES ];
-	/* Number of available 80211 cores. */
-	int nr_80211_available;
-
-	u32 chipcommon_capabilities;
-
-	/* Reason code of the last interrupt. */
-	u32 irq_reason;
-	u32 dma_reason[6];
-	/* saved irq enable/disable state bitfield. */
-	u32 irq_savedstate;
-	/* Link Quality calculation context. */
-	struct bcm43xx_noise_calculation noisecalc;
-	/* if &gt; 0 MAC is suspended. if == 0 MAC is enabled. */
-	int mac_suspended;
-
-	/* Threshold values. */
-	//TODO: The RTS thr has to be _used_. Currently, it is only set via WX.
-	u32 rts_threshold;
-
-	/* Interrupt Service Routine tasklet (bottom-half) */
-	struct tasklet_struct isr_tasklet;
-
-	/* Periodic tasks */
-	struct delayed_work periodic_work;
-	unsigned int periodic_state;
-
-	struct work_struct restart_work;
-
-	/* Informational stuff. */
-	char nick[IW_ESSID_MAX_SIZE + 1];
-
-	/* encryption/decryption */
-	u16 security_offset;
-	struct bcm43xx_key key[54];
-	u8 default_key_idx;
-
-	/* Random Number Generator. */
-	struct hwrng rng;
-	char rng_name[20 + 1];
-
-	/* Debugging stuff follows. */
-#ifdef CONFIG_BCM43XX_DEBUG
-	struct bcm43xx_dfsentry *dfsentry;
-#endif
-};
-
-
-static inline
-struct bcm43xx_private * bcm43xx_priv(struct net_device *dev)
-{
-	return ieee80211softmac_priv(dev);
-}
-
-struct device;
-
-static inline
-struct bcm43xx_private * dev_to_bcm(struct device *dev)
-{
-	struct net_device *net_dev;
-	struct bcm43xx_private *bcm;
-
-	net_dev = dev_get_drvdata(dev);
-	bcm = bcm43xx_priv(net_dev);
-
-	return bcm;
-}
-
-
-/* Helper function, which returns a boolean.
- * TRUE, if PIO is used; FALSE, if DMA is used.
- */
-#if defined(CONFIG_BCM43XX_DMA) &amp;&amp; defined(CONFIG_BCM43XX_PIO)
-static inline
-int bcm43xx_using_pio(struct bcm43xx_private *bcm)
-{
-	return bcm-&gt;__using_pio;
-}
-#elif defined(CONFIG_BCM43XX_DMA)
-static inline
-int bcm43xx_using_pio(struct bcm43xx_private *bcm)
-{
-	return 0;
-}
-#elif defined(CONFIG_BCM43XX_PIO)
-static inline
-int bcm43xx_using_pio(struct bcm43xx_private *bcm)
-{
-	return 1;
-}
-#else
-# error &quot;Using neither DMA nor PIO? Confused...&quot;
-#endif
-
-/* Helper functions to access data structures private to the 80211 cores.
- * Note that we _must_ have an 80211 core mapped when calling
- * any of these functions.
- */
-static inline
-struct bcm43xx_coreinfo_80211 *
-bcm43xx_current_80211_priv(struct bcm43xx_private *bcm)
-{
-	assert(bcm-&gt;current_core-&gt;id == BCM43xx_COREID_80211);
-	return bcm-&gt;current_core-&gt;priv;
-}
-static inline
-struct bcm43xx_pio * bcm43xx_current_pio(struct bcm43xx_private *bcm)
-{
-	assert(bcm43xx_using_pio(bcm));
-	return &amp;(bcm43xx_current_80211_priv(bcm)-&gt;pio);
-}
-static inline
-struct bcm43xx_dma * bcm43xx_current_dma(struct bcm43xx_private *bcm)
-{
-	assert(!bcm43xx_using_pio(bcm));
-	return &amp;(bcm43xx_current_80211_priv(bcm)-&gt;dma);
-}
-static inline
-struct bcm43xx_phyinfo * bcm43xx_current_phy(struct bcm43xx_private *bcm)
-{
-	return &amp;(bcm43xx_current_80211_priv(bcm)-&gt;phy);
-}
-static inline
-struct bcm43xx_radioinfo * bcm43xx_current_radio(struct bcm43xx_private *bcm)
-{
-	return &amp;(bcm43xx_current_80211_priv(bcm)-&gt;radio);
-}
-
-
-static inline
-struct bcm43xx_lopair * bcm43xx_get_lopair(struct bcm43xx_phyinfo *phy,
-					   u16 radio_attenuation,
-					   u16 baseband_attenuation)
-{
-	return phy-&gt;_lo_pairs + (radio_attenuation + 14 * (baseband_attenuation / 2));
-}
-
-
-static inline
-u16 bcm43xx_read16(struct bcm43xx_private *bcm, u16 offset)
-{
-	return ioread16(bcm-&gt;mmio_addr + offset);
-}
-
-static inline
-void bcm43xx_write16(struct bcm43xx_private *bcm, u16 offset, u16 value)
-{
-	iowrite16(value, bcm-&gt;mmio_addr + offset);
-}
-
-static inline
-u32 bcm43xx_read32(struct bcm43xx_private *bcm, u16 offset)
-{
-	return ioread32(bcm-&gt;mmio_addr + offset);
-}
-
-static inline
-void bcm43xx_write32(struct bcm43xx_private *bcm, u16 offset, u32 value)
-{
-	iowrite32(value, bcm-&gt;mmio_addr + offset);
-}
-
-static inline
-int bcm43xx_pci_read_config16(struct bcm43xx_private *bcm, int offset, u16 *value)
-{
-	return pci_read_config_word(bcm-&gt;pci_dev, offset, value);
-}
-
-static inline
-int bcm43xx_pci_read_config32(struct bcm43xx_private *bcm, int offset, u32 *value)
-{
-	return pci_read_config_dword(bcm-&gt;pci_dev, offset, value);
-}
-
-static inline
-int bcm43xx_pci_write_config16(struct bcm43xx_private *bcm, int offset, u16 value)
-{
-	return pci_write_config_word(bcm-&gt;pci_dev, offset, value);
-}
-
-static inline
-int bcm43xx_pci_write_config32(struct bcm43xx_private *bcm, int offset, u32 value)
-{
-	return pci_write_config_dword(bcm-&gt;pci_dev, offset, value);
-}
-
-/** Limit a value between two limits */
-#ifdef limit_value
-# undef limit_value
-#endif
-#define limit_value(value, min, max)  \
-	({						\
-		typeof(value) __value = (value);	\
-	 	typeof(value) __min = (min);		\
-	 	typeof(value) __max = (max);		\
-	 	if (__value &lt; __min)			\
-	 		__value = __min;		\
-	 	else if (__value &gt; __max)		\
-	 		__value = __max;		\
-	 	__value;				\
-	})
-
-#endif /* BCM43xx_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.c
+++ /dev/null
@@ -1,556 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  debugfs driver debugging code
-
-  Copyright (c) 2005 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-
-
-#include &lt;linux/fs.h&gt;
-#include &lt;linux/debugfs.h&gt;
-#include &lt;linux/slab.h&gt;
-#include &lt;linux/netdevice.h&gt;
-#include &lt;linux/pci.h&gt;
-#include &lt;asm/io.h&gt;
-
-#include &quot;bcm43xx.h&quot;
-#include &quot;bcm43xx_main.h&quot;
-#include &quot;bcm43xx_debugfs.h&quot;
-#include &quot;bcm43xx_dma.h&quot;
-#include &quot;bcm43xx_pio.h&quot;
-#include &quot;bcm43xx_xmit.h&quot;
-
-#define REALLY_BIG_BUFFER_SIZE	(1024*256)
-
-static struct bcm43xx_debugfs fs;
-static char really_big_buffer[REALLY_BIG_BUFFER_SIZE];
-static DECLARE_MUTEX(big_buffer_sem);
-
-
-static ssize_t write_file_dummy(struct file *file, const char __user *buf,
-				size_t count, loff_t *ppos)
-{
-	return count;
-}
-
-static int open_file_generic(struct inode *inode, struct file *file)
-{
-	file-&gt;private_data = inode-&gt;i_private;
-	return 0;
-}
-
-#define fappend(fmt, x...)	pos += snprintf(buf + pos, len - pos, fmt , ##x)
-
-static ssize_t devinfo_read_file(struct file *file, char __user *userbuf,
-				 size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file-&gt;private_data;
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	struct net_device *net_dev;
-	struct pci_dev *pci_dev;
-	unsigned long flags;
-	u16 tmp16;
-	int i;
-
-	down(&amp;big_buffer_sem);
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		fappend(&quot;Board not initialized.\n&quot;);
-		goto out;
-	}
-	net_dev = bcm-&gt;net_dev;
-	pci_dev = bcm-&gt;pci_dev;
-
-	/* This is where the information is written to the &quot;devinfo&quot; file */
-	fappend(&quot;*** %s devinfo ***\n&quot;, net_dev-&gt;name);
-	fappend(&quot;vendor:           0x%04x   device:           0x%04x\n&quot;,
-		pci_dev-&gt;vendor, pci_dev-&gt;device);
-	fappend(&quot;subsystem_vendor: 0x%04x   subsystem_device: 0x%04x\n&quot;,
-		pci_dev-&gt;subsystem_vendor, pci_dev-&gt;subsystem_device);
-	fappend(&quot;IRQ: %d\n&quot;, bcm-&gt;irq);
-	fappend(&quot;mmio_addr: 0x%p\n&quot;, bcm-&gt;mmio_addr);
-	fappend(&quot;chip_id: 0x%04x   chip_rev: 0x%02x\n&quot;, bcm-&gt;chip_id, bcm-&gt;chip_rev);
-	if ((bcm-&gt;core_80211[0].rev &gt;= 3) &amp;&amp; (bcm43xx_read32(bcm, 0x0158) &amp; (1 &lt;&lt; 16)))
-		fappend(&quot;Radio disabled by hardware!\n&quot;);
-	if ((bcm-&gt;core_80211[0].rev &lt; 3) &amp;&amp; !(bcm43xx_read16(bcm, 0x049A) &amp; (1 &lt;&lt; 4)))
-		fappend(&quot;Radio disabled by hardware!\n&quot;);
-	fappend(&quot;board_vendor: 0x%04x   board_type: 0x%04x\n&quot;, bcm-&gt;board_vendor,
-	        bcm-&gt;board_type);
-
-	fappend(&quot;\nCores:\n&quot;);
-#define fappend_core(name, info) fappend(&quot;core \&quot;&quot; name &quot;\&quot; %s, %s, id: 0x%04x, &quot;	\
-					 &quot;rev: 0x%02x, index: 0x%02x\n&quot;,		\
-					 (info).available				\
-						? &quot;available&quot; : &quot;nonavailable&quot;,		\
-					 (info).enabled					\
-						? &quot;enabled&quot; : &quot;disabled&quot;,		\
-					 (info).id, (info).rev, (info).index)
-	fappend_core(&quot;CHIPCOMMON&quot;, bcm-&gt;core_chipcommon);
-	fappend_core(&quot;PCI&quot;, bcm-&gt;core_pci);
-	fappend_core(&quot;first 80211&quot;, bcm-&gt;core_80211[0]);
-	fappend_core(&quot;second 80211&quot;, bcm-&gt;core_80211[1]);
-#undef fappend_core
-	tmp16 = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
-	fappend(&quot;LEDs: &quot;);
-	for (i = 0; i &lt; BCM43xx_NR_LEDS; i++)
-		fappend(&quot;%d &quot;, !!(tmp16 &amp; (1 &lt;&lt; i)));
-	fappend(&quot;\n&quot;);
-
-out:
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&amp;big_buffer_sem);
-	return res;
-}
-
-static ssize_t drvinfo_read_file(struct file *file, char __user *userbuf,
-				 size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-
-	down(&amp;big_buffer_sem);
-
-	/* This is where the information is written to the &quot;driver&quot; file */
-	fappend(KBUILD_MODNAME &quot; driver\n&quot;);
-	fappend(&quot;Compiled at: %s %s\n&quot;, __DATE__, __TIME__);
-
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&amp;big_buffer_sem);
-	return res;
-}
-
-static ssize_t spromdump_read_file(struct file *file, char __user *userbuf,
-				 size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file-&gt;private_data;
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
-
-	down(&amp;big_buffer_sem);
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		fappend(&quot;Board not initialized.\n&quot;);
-		goto out;
-	}
-
-	/* This is where the information is written to the &quot;sprom_dump&quot; file */
-	fappend(&quot;boardflags: 0x%04x\n&quot;, bcm-&gt;sprom.boardflags);
-
-out:
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&amp;big_buffer_sem);
-	return res;
-}
-
-static ssize_t tsf_read_file(struct file *file, char __user *userbuf,
-			     size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file-&gt;private_data;
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
-	u64 tsf;
-
-	down(&amp;big_buffer_sem);
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		fappend(&quot;Board not initialized.\n&quot;);
-		goto out;
-	}
-	bcm43xx_tsf_read(bcm, &amp;tsf);
-	fappend(&quot;0x%08x%08x\n&quot;,
-		(unsigned int)((tsf &amp; 0xFFFFFFFF00000000ULL) &gt;&gt; 32),
-		(unsigned int)(tsf &amp; 0xFFFFFFFFULL));
-
-out:
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	up(&amp;big_buffer_sem);
-	return res;
-}
-
-static ssize_t tsf_write_file(struct file *file, const char __user *user_buf,
-			      size_t count, loff_t *ppos)
-{
-	struct bcm43xx_private *bcm = file-&gt;private_data;
-	char *buf = really_big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags;
-	u64 tsf;
-
-	buf_size = min(count, sizeof (really_big_buffer) - 1);
-	down(&amp;big_buffer_sem);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-	        res = -EFAULT;
-		goto out_up;
-	}
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		printk(KERN_INFO PFX &quot;debugfs: Board not initialized.\n&quot;);
-		res = -EFAULT;
-		goto out_unlock;
-	}
-	if (sscanf(buf, &quot;%lli&quot;, &amp;tsf) != 1) {
-		printk(KERN_INFO PFX &quot;debugfs: invalid values for \&quot;tsf\&quot;\n&quot;);
-		res = -EINVAL;
-		goto out_unlock;
-	}
-	bcm43xx_tsf_write(bcm, tsf);
-	mmiowb();
-	res = buf_size;
-	
-out_unlock:
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-out_up:
-	up(&amp;big_buffer_sem);
-	return res;
-}
-
-static ssize_t txstat_read_file(struct file *file, char __user *userbuf,
-				size_t count, loff_t *ppos)
-{
-	const size_t len = REALLY_BIG_BUFFER_SIZE;
-
-	struct bcm43xx_private *bcm = file-&gt;private_data;
-	char *buf = really_big_buffer;
-	size_t pos = 0;
-	ssize_t res;
-	unsigned long flags;
-	struct bcm43xx_dfsentry *e;
-	struct bcm43xx_xmitstatus *status;
-	int i, cnt, j = 0;
-
-	down(&amp;big_buffer_sem);
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-
-	fappend(&quot;Last %d logged xmitstatus blobs (Latest first):\n\n&quot;,
-		BCM43xx_NR_LOGGED_XMITSTATUS);
-	e = bcm-&gt;dfsentry;
-	if (e-&gt;xmitstatus_printing == 0) {
-		/* At the beginning, make a copy of all data to avoid
-		 * concurrency, as this function is called multiple
-		 * times for big logs. Without copying, the data might
-		 * change between reads. This would result in total trash.
-		 */
-		e-&gt;xmitstatus_printing = 1;
-		e-&gt;saved_xmitstatus_ptr = e-&gt;xmitstatus_ptr;
-		e-&gt;saved_xmitstatus_cnt = e-&gt;xmitstatus_cnt;
-		memcpy(e-&gt;xmitstatus_print_buffer, e-&gt;xmitstatus_buffer,
-		       BCM43xx_NR_LOGGED_XMITSTATUS * sizeof(*(e-&gt;xmitstatus_buffer)));
-	}
-	i = e-&gt;saved_xmitstatus_ptr - 1;
-	if (i &lt; 0)
-		i = BCM43xx_NR_LOGGED_XMITSTATUS - 1;
-	cnt = e-&gt;saved_xmitstatus_cnt;
-	while (cnt) {
-		status = e-&gt;xmitstatus_print_buffer + i;
-		fappend(&quot;0x%02x:   cookie: 0x%04x,  flags: 0x%02x,  &quot;
-			&quot;cnt1: 0x%02x,  cnt2: 0x%02x,  seq: 0x%04x,  &quot;
-			&quot;unk: 0x%04x\n&quot;, j,
-			status-&gt;cookie, status-&gt;flags,
-			status-&gt;cnt1, status-&gt;cnt2, status-&gt;seq,
-			status-&gt;unknown);
-		j++;
-		cnt--;
-		i--;
-		if (i &lt; 0)
-			i = BCM43xx_NR_LOGGED_XMITSTATUS - 1;
-	}
-
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (*ppos == pos) {
-		/* Done. Drop the copied data. */
-		e-&gt;xmitstatus_printing = 0;
-	}
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-	up(&amp;big_buffer_sem);
-	return res;
-}
-
-static ssize_t restart_write_file(struct file *file, const char __user *user_buf,
-				  size_t count, loff_t *ppos)
-{
-	struct bcm43xx_private *bcm = file-&gt;private_data;
-	char *buf = really_big_buffer;
-	ssize_t buf_size;
-	ssize_t res;
-	unsigned long flags;
-
-	buf_size = min(count, sizeof (really_big_buffer) - 1);
-	down(&amp;big_buffer_sem);
-	if (copy_from_user(buf, user_buf, buf_size)) {
-	        res = -EFAULT;
-		goto out_up;
-	}
-	mutex_lock(&amp;(bcm)-&gt;mutex);
-	spin_lock_irqsave(&amp;(bcm)-&gt;irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED) {
-		printk(KERN_INFO PFX &quot;debugfs: Board not initialized.\n&quot;);
-		res = -EFAULT;
-		goto out_unlock;
-	}
-	if (count &gt; 0 &amp;&amp; buf[0] == '1') {
-		bcm43xx_controller_restart(bcm, &quot;manually restarted&quot;);
-		res = count;
-	} else
-		res = -EINVAL;
-
-out_unlock:
-	spin_unlock_irqrestore(&amp;(bcm)-&gt;irq_lock, flags);
-	mutex_unlock(&amp;(bcm)-&gt;mutex);
-out_up:
-	up(&amp;big_buffer_sem);
-	return res;
-}
-
-#undef fappend
-
-
-static const struct file_operations devinfo_fops = {
-	.read = devinfo_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
-
-static const struct file_operations spromdump_fops = {
-	.read = spromdump_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
-
-static const struct file_operations drvinfo_fops = {
-	.read = drvinfo_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
-
-static const struct file_operations tsf_fops = {
-	.read = tsf_read_file,
-	.write = tsf_write_file,
-	.open = open_file_generic,
-};
-
-static const struct file_operations txstat_fops = {
-	.read = txstat_read_file,
-	.write = write_file_dummy,
-	.open = open_file_generic,
-};
-
-static const struct file_operations restart_fops = {
-	.write = restart_write_file,
-	.open = open_file_generic,
-};
-
-
-void bcm43xx_debugfs_add_device(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_dfsentry *e;
-	char devdir[IFNAMSIZ];
-
-	assert(bcm);
-	e = kzalloc(sizeof(*e), GFP_KERNEL);
-	if (!e) {
-		printk(KERN_ERR PFX &quot;out of memory\n&quot;);
-		return;
-	}
-	e-&gt;bcm = bcm;
-	e-&gt;xmitstatus_buffer = kzalloc(BCM43xx_NR_LOGGED_XMITSTATUS
-				       * sizeof(*(e-&gt;xmitstatus_buffer)),
-				       GFP_KERNEL);
-	if (!e-&gt;xmitstatus_buffer) {
-		printk(KERN_ERR PFX &quot;out of memory\n&quot;);
-		kfree(e);
-		return;
-	}
-	e-&gt;xmitstatus_print_buffer = kzalloc(BCM43xx_NR_LOGGED_XMITSTATUS
-					     * sizeof(*(e-&gt;xmitstatus_buffer)),
-					     GFP_KERNEL);
-	if (!e-&gt;xmitstatus_print_buffer) {
-		printk(KERN_ERR PFX &quot;out of memory\n&quot;);
-		kfree(e);
-		return;
-	}
-
-
-	bcm-&gt;dfsentry = e;
-
-	strncpy(devdir, bcm-&gt;net_dev-&gt;name, ARRAY_SIZE(devdir));
-	e-&gt;subdir = debugfs_create_dir(devdir, fs.root);
-	e-&gt;dentry_devinfo = debugfs_create_file(&quot;devinfo&quot;, 0444, e-&gt;subdir,
-						bcm, &amp;devinfo_fops);
-	if (!e-&gt;dentry_devinfo)
-		printk(KERN_ERR PFX &quot;debugfs: creating \&quot;devinfo\&quot; for \&quot;%s\&quot; failed!\n&quot;, devdir);
-	e-&gt;dentry_spromdump = debugfs_create_file(&quot;sprom_dump&quot;, 0444, e-&gt;subdir,
-						  bcm, &amp;spromdump_fops);
-	if (!e-&gt;dentry_spromdump)
-		printk(KERN_ERR PFX &quot;debugfs: creating \&quot;sprom_dump\&quot; for \&quot;%s\&quot; failed!\n&quot;, devdir);
-	e-&gt;dentry_tsf = debugfs_create_file(&quot;tsf&quot;, 0666, e-&gt;subdir,
-	                                    bcm, &amp;tsf_fops);
-	if (!e-&gt;dentry_tsf)
-		printk(KERN_ERR PFX &quot;debugfs: creating \&quot;tsf\&quot; for \&quot;%s\&quot; failed!\n&quot;, devdir);
-	e-&gt;dentry_txstat = debugfs_create_file(&quot;tx_status&quot;, 0444, e-&gt;subdir,
-						bcm, &amp;txstat_fops);
-	if (!e-&gt;dentry_txstat)
-		printk(KERN_ERR PFX &quot;debugfs: creating \&quot;tx_status\&quot; for \&quot;%s\&quot; failed!\n&quot;, devdir);
-	e-&gt;dentry_restart = debugfs_create_file(&quot;restart&quot;, 0222, e-&gt;subdir,
-						bcm, &amp;restart_fops);
-	if (!e-&gt;dentry_restart)
-		printk(KERN_ERR PFX &quot;debugfs: creating \&quot;restart\&quot; for \&quot;%s\&quot; failed!\n&quot;, devdir);
-}
-
-void bcm43xx_debugfs_remove_device(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_dfsentry *e;
-
-	if (!bcm)
-		return;
-
-	e = bcm-&gt;dfsentry;
-	assert(e);
-	debugfs_remove(e-&gt;dentry_spromdump);
-	debugfs_remove(e-&gt;dentry_devinfo);
-	debugfs_remove(e-&gt;dentry_tsf);
-	debugfs_remove(e-&gt;dentry_txstat);
-	debugfs_remove(e-&gt;dentry_restart);
-	debugfs_remove(e-&gt;subdir);
-	kfree(e-&gt;xmitstatus_buffer);
-	kfree(e-&gt;xmitstatus_print_buffer);
-	kfree(e);
-}
-
-void bcm43xx_debugfs_log_txstat(struct bcm43xx_private *bcm,
-				struct bcm43xx_xmitstatus *status)
-{
-	struct bcm43xx_dfsentry *e;
-	struct bcm43xx_xmitstatus *savedstatus;
-
-	/* This is protected by bcm-&gt;_lock */
-	e = bcm-&gt;dfsentry;
-	assert(e);
-	savedstatus = e-&gt;xmitstatus_buffer + e-&gt;xmitstatus_ptr;
-	memcpy(savedstatus, status, sizeof(*status));
-	e-&gt;xmitstatus_ptr++;
-	if (e-&gt;xmitstatus_ptr &gt;= BCM43xx_NR_LOGGED_XMITSTATUS)
-		e-&gt;xmitstatus_ptr = 0;
-	if (e-&gt;xmitstatus_cnt &lt; BCM43xx_NR_LOGGED_XMITSTATUS)
-		e-&gt;xmitstatus_cnt++;
-}
-
-void bcm43xx_debugfs_init(void)
-{
-	memset(&amp;fs, 0, sizeof(fs));
-	fs.root = debugfs_create_dir(KBUILD_MODNAME, NULL);
-	if (!fs.root)
-		printk(KERN_ERR PFX &quot;debugfs: creating \&quot;&quot; KBUILD_MODNAME &quot;\&quot; subdir failed!\n&quot;);
-	fs.dentry_driverinfo = debugfs_create_file(&quot;driver&quot;, 0444, fs.root, NULL, &amp;drvinfo_fops);
-	if (!fs.dentry_driverinfo)
-		printk(KERN_ERR PFX &quot;debugfs: creating \&quot;&quot; KBUILD_MODNAME &quot;/driver\&quot; failed!\n&quot;);
-}
-
-void bcm43xx_debugfs_exit(void)
-{
-	debugfs_remove(fs.dentry_driverinfo);
-	debugfs_remove(fs.root);
-}
-
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description)
-{
-	size_t i;
-	char c;
-
-	printk(KERN_INFO PFX &quot;Data dump (%s, %zd bytes):&quot;,
-	       description, size);
-	for (i = 0; i &lt; size; i++) {
-		c = data[i];
-		if (i % 8 == 0)
-			printk(&quot;\n&quot; KERN_INFO PFX &quot;0x%08zx:  0x%02x, &quot;, i, c &amp; 0xff);
-		else
-			printk(&quot;0x%02x, &quot;, c &amp; 0xff);
-	}
-	printk(&quot;\n&quot;);
-}
-
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description)
-{
-	size_t i;
-	int j;
-	const unsigned char *d;
-
-	printk(KERN_INFO PFX &quot;*** Bitdump (%s, %zd bytes, %s) ***&quot;,
-	       description, bytes, msb_to_lsb ? &quot;MSB to LSB&quot; : &quot;LSB to MSB&quot;);
-	for (i = 0; i &lt; bytes; i++) {
-		d = data + i;
-		if (i % 8 == 0)
-			printk(&quot;\n&quot; KERN_INFO PFX &quot;0x%08zx:  &quot;, i);
-		if (msb_to_lsb) {
-			for (j = 7; j &gt;= 0; j--) {
-				if (*d &amp; (1 &lt;&lt; j))
-					printk(&quot;1&quot;);
-				else
-					printk(&quot;0&quot;);
-			}
-		} else {
-			for (j = 0; j &lt; 8; j++) {
-				if (*d &amp; (1 &lt;&lt; j))
-					printk(&quot;1&quot;);
-				else
-					printk(&quot;0&quot;);
-			}
-		}
-		printk(&quot; &quot;);
-	}
-	printk(&quot;\n&quot;);
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_debugfs.h
+++ /dev/null
@@ -1,118 +0,0 @@
-#ifndef BCM43xx_DEBUGFS_H_
-#define BCM43xx_DEBUGFS_H_
-
-struct bcm43xx_private;
-struct bcm43xx_xmitstatus;
-
-#ifdef CONFIG_BCM43XX_DEBUG
-
-#include &lt;linux/list.h&gt;
-#include &lt;asm/semaphore.h&gt;
-
-struct dentry;
-
-/* limited by the size of the &quot;really_big_buffer&quot; */
-#define BCM43xx_NR_LOGGED_XMITSTATUS	100
-
-struct bcm43xx_dfsentry {
-	struct dentry *subdir;
-	struct dentry *dentry_devinfo;
-	struct dentry *dentry_spromdump;
-	struct dentry *dentry_tsf;
-	struct dentry *dentry_txstat;
-	struct dentry *dentry_restart;
-
-	struct bcm43xx_private *bcm;
-
-	/* saved xmitstatus. */
-	struct bcm43xx_xmitstatus *xmitstatus_buffer;
-	int xmitstatus_ptr;
-	int xmitstatus_cnt;
-	/* We need a seperate buffer while printing to avoid
-	 * concurrency issues. (New xmitstatus can arrive
-	 * while we are printing).
-	 */
-	struct bcm43xx_xmitstatus *xmitstatus_print_buffer;
-	int saved_xmitstatus_ptr;
-	int saved_xmitstatus_cnt;
-	int xmitstatus_printing;
-};
-
-struct bcm43xx_debugfs {
-	struct dentry *root;
-	struct dentry *dentry_driverinfo;
-};
-
-void bcm43xx_debugfs_init(void);
-void bcm43xx_debugfs_exit(void);
-void bcm43xx_debugfs_add_device(struct bcm43xx_private *bcm);
-void bcm43xx_debugfs_remove_device(struct bcm43xx_private *bcm);
-void bcm43xx_debugfs_log_txstat(struct bcm43xx_private *bcm,
-				struct bcm43xx_xmitstatus *status);
-
-/* Debug helper: Dump binary data through printk. */
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description);
-/* Debug helper: Dump bitwise binary data through printk. */
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description);
-#define bcm43xx_printk_bitdumpt(pointer, msb_to_lsb, description) \
-	do {									\
-		bcm43xx_printk_bitdump((const unsigned char *)(pointer),	\
-				       sizeof(*(pointer)),			\
-				       (msb_to_lsb),				\
-				       (description));				\
-	} while (0)
-
-#else /* CONFIG_BCM43XX_DEBUG*/
-
-static inline
-void bcm43xx_debugfs_init(void) { }
-static inline
-void bcm43xx_debugfs_exit(void) { }
-static inline
-void bcm43xx_debugfs_add_device(struct bcm43xx_private *bcm) { }
-static inline
-void bcm43xx_debugfs_remove_device(struct bcm43xx_private *bcm) { }
-static inline
-void bcm43xx_debugfs_log_txstat(struct bcm43xx_private *bcm,
-				struct bcm43xx_xmitstatus *status) { }
-
-static inline
-void bcm43xx_printk_dump(const char *data,
-			 size_t size,
-			 const char *description)
-{
-}
-static inline
-void bcm43xx_printk_bitdump(const unsigned char *data,
-			    size_t bytes, int msb_to_lsb,
-			    const char *description)
-{
-}
-#define bcm43xx_printk_bitdumpt(pointer, msb_to_lsb, description)  do { /* nothing */ } while (0)
-
-#endif /* CONFIG_BCM43XX_DEBUG*/
-
-/* Ugly helper macros to make incomplete code more verbose on runtime */
-#ifdef TODO
-# undef TODO
-#endif
-#define TODO()  \
-	do {										\
-		printk(KERN_INFO PFX &quot;TODO: Incomplete code in %s() at %s:%d\n&quot;,	\
-		       __FUNCTION__, __FILE__, __LINE__);				\
-	} while (0)
-
-#ifdef FIXME
-# undef FIXME
-#endif
-#define FIXME()  \
-	do {										\
-		printk(KERN_INFO PFX &quot;FIXME: Possibly broken code in %s() at %s:%d\n&quot;,	\
-		       __FUNCTION__, __FILE__, __LINE__);				\
-	} while (0)
-
-#endif /* BCM43xx_DEBUGFS_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_dma.c
+++ /dev/null
@@ -1,1263 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  DMA ringbuffer and descriptor allocation/management
-
-  Copyright (c) 2005, 2006 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-
-  Some code in this file is derived from the b44.c driver
-  Copyright (C) 2002 David S. Miller
-  Copyright (C) Pekka Pietikainen
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &quot;bcm43xx.h&quot;
-#include &quot;bcm43xx_dma.h&quot;
-#include &quot;bcm43xx_main.h&quot;
-#include &quot;bcm43xx_debugfs.h&quot;
-#include &quot;bcm43xx_power.h&quot;
-#include &quot;bcm43xx_xmit.h&quot;
-
-#include &lt;linux/dma-mapping.h&gt;
-#include &lt;linux/pci.h&gt;
-#include &lt;linux/delay.h&gt;
-#include &lt;linux/skbuff.h&gt;
-
-
-static inline int free_slots(struct bcm43xx_dmaring *ring)
-{
-	return (ring-&gt;nr_slots - ring-&gt;used_slots);
-}
-
-static inline int next_slot(struct bcm43xx_dmaring *ring, int slot)
-{
-	assert(slot &gt;= -1 &amp;&amp; slot &lt;= ring-&gt;nr_slots - 1);
-	if (slot == ring-&gt;nr_slots - 1)
-		return 0;
-	return slot + 1;
-}
-
-static inline int prev_slot(struct bcm43xx_dmaring *ring, int slot)
-{
-	assert(slot &gt;= 0 &amp;&amp; slot &lt;= ring-&gt;nr_slots - 1);
-	if (slot == 0)
-		return ring-&gt;nr_slots - 1;
-	return slot - 1;
-}
-
-/* Request a slot for usage. */
-static inline
-int request_slot(struct bcm43xx_dmaring *ring)
-{
-	int slot;
-
-	assert(ring-&gt;tx);
-	assert(!ring-&gt;suspended);
-	assert(free_slots(ring) != 0);
-
-	slot = next_slot(ring, ring-&gt;current_slot);
-	ring-&gt;current_slot = slot;
-	ring-&gt;used_slots++;
-
-	/* Check the number of available slots and suspend TX,
-	 * if we are running low on free slots.
-	 */
-	if (unlikely(free_slots(ring) &lt; ring-&gt;suspend_mark)) {
-		netif_stop_queue(ring-&gt;bcm-&gt;net_dev);
-		ring-&gt;suspended = 1;
-	}
-#ifdef CONFIG_BCM43XX_DEBUG
-	if (ring-&gt;used_slots &gt; ring-&gt;max_used_slots)
-		ring-&gt;max_used_slots = ring-&gt;used_slots;
-#endif /* CONFIG_BCM43XX_DEBUG*/
-
-	return slot;
-}
-
-/* Return a slot to the free slots. */
-static inline
-void return_slot(struct bcm43xx_dmaring *ring, int slot)
-{
-	assert(ring-&gt;tx);
-
-	ring-&gt;used_slots--;
-
-	/* Check if TX is suspended and check if we have
-	 * enough free slots to resume it again.
-	 */
-	if (unlikely(ring-&gt;suspended)) {
-		if (free_slots(ring) &gt;= ring-&gt;resume_mark) {
-			ring-&gt;suspended = 0;
-			netif_wake_queue(ring-&gt;bcm-&gt;net_dev);
-		}
-	}
-}
-
-u16 bcm43xx_dmacontroller_base(int dma64bit, int controller_idx)
-{
-	static const u16 map64[] = {
-		BCM43xx_MMIO_DMA64_BASE0,
-		BCM43xx_MMIO_DMA64_BASE1,
-		BCM43xx_MMIO_DMA64_BASE2,
-		BCM43xx_MMIO_DMA64_BASE3,
-		BCM43xx_MMIO_DMA64_BASE4,
-		BCM43xx_MMIO_DMA64_BASE5,
-	};
-	static const u16 map32[] = {
-		BCM43xx_MMIO_DMA32_BASE0,
-		BCM43xx_MMIO_DMA32_BASE1,
-		BCM43xx_MMIO_DMA32_BASE2,
-		BCM43xx_MMIO_DMA32_BASE3,
-		BCM43xx_MMIO_DMA32_BASE4,
-		BCM43xx_MMIO_DMA32_BASE5,
-	};
-
-	if (dma64bit) {
-		assert(controller_idx &gt;= 0 &amp;&amp;
-		       controller_idx &lt; ARRAY_SIZE(map64));
-		return map64[controller_idx];
-	}
-	assert(controller_idx &gt;= 0 &amp;&amp;
-	       controller_idx &lt; ARRAY_SIZE(map32));
-	return map32[controller_idx];
-}
-
-static inline
-dma_addr_t map_descbuffer(struct bcm43xx_dmaring *ring,
-			  unsigned char *buf,
-			  size_t len,
-			  int tx)
-{
-	dma_addr_t dmaaddr;
-	int direction = PCI_DMA_FROMDEVICE;
-
-	if (tx)
-		direction = PCI_DMA_TODEVICE;
-
-	dmaaddr = pci_map_single(ring-&gt;bcm-&gt;pci_dev,
-					 buf, len,
-					 direction);
-
-	return dmaaddr;
-}
-
-static inline
-void unmap_descbuffer(struct bcm43xx_dmaring *ring,
-		      dma_addr_t addr,
-		      size_t len,
-		      int tx)
-{
-	if (tx) {
-		pci_unmap_single(ring-&gt;bcm-&gt;pci_dev,
-				 addr, len,
-				 PCI_DMA_TODEVICE);
-	} else {
-		pci_unmap_single(ring-&gt;bcm-&gt;pci_dev,
-				 addr, len,
-				 PCI_DMA_FROMDEVICE);
-	}
-}
-
-static inline
-void sync_descbuffer_for_cpu(struct bcm43xx_dmaring *ring,
-			     dma_addr_t addr,
-			     size_t len)
-{
-	assert(!ring-&gt;tx);
-
-	pci_dma_sync_single_for_cpu(ring-&gt;bcm-&gt;pci_dev,
-				    addr, len, PCI_DMA_FROMDEVICE);
-}
-
-static inline
-void sync_descbuffer_for_device(struct bcm43xx_dmaring *ring,
-				dma_addr_t addr,
-				size_t len)
-{
-	assert(!ring-&gt;tx);
-
-	pci_dma_sync_single_for_cpu(ring-&gt;bcm-&gt;pci_dev,
-				    addr, len, PCI_DMA_TODEVICE);
-}
-
-/* Unmap and free a descriptor buffer. */
-static inline
-void free_descriptor_buffer(struct bcm43xx_dmaring *ring,
-			    struct bcm43xx_dmadesc_meta *meta,
-			    int irq_context)
-{
-	assert(meta-&gt;skb);
-	if (irq_context)
-		dev_kfree_skb_irq(meta-&gt;skb);
-	else
-		dev_kfree_skb(meta-&gt;skb);
-	meta-&gt;skb = NULL;
-}
-
-static int alloc_ringmemory(struct bcm43xx_dmaring *ring)
-{
-	ring-&gt;descbase = pci_alloc_consistent(ring-&gt;bcm-&gt;pci_dev, BCM43xx_DMA_RINGMEMSIZE,
-					    &amp;(ring-&gt;dmabase));
-	if (!ring-&gt;descbase) {
-		/* Allocation may have failed due to pci_alloc_consistent
-		   insisting on use of GFP_DMA, which is more restrictive
-		   than necessary...  */
-		struct dma_desc *rx_ring;
-		dma_addr_t rx_ring_dma;
-
-		rx_ring = kzalloc(BCM43xx_DMA_RINGMEMSIZE, GFP_KERNEL);
-		if (!rx_ring)
-			goto out_err;
-
-		rx_ring_dma = pci_map_single(ring-&gt;bcm-&gt;pci_dev, rx_ring,
-					     BCM43xx_DMA_RINGMEMSIZE,
-					     PCI_DMA_BIDIRECTIONAL);
-
-		if (pci_dma_mapping_error(rx_ring_dma) ||
-		    rx_ring_dma + BCM43xx_DMA_RINGMEMSIZE &gt; ring-&gt;bcm-&gt;dma_mask) {
-			/* Sigh... */
-			if (!pci_dma_mapping_error(rx_ring_dma))
-				pci_unmap_single(ring-&gt;bcm-&gt;pci_dev,
-						 rx_ring_dma, BCM43xx_DMA_RINGMEMSIZE,
-						 PCI_DMA_BIDIRECTIONAL);
-			rx_ring_dma = pci_map_single(ring-&gt;bcm-&gt;pci_dev,
-						 rx_ring, BCM43xx_DMA_RINGMEMSIZE,
-						 PCI_DMA_BIDIRECTIONAL);
-			if (pci_dma_mapping_error(rx_ring_dma) ||
-			    rx_ring_dma + BCM43xx_DMA_RINGMEMSIZE &gt; ring-&gt;bcm-&gt;dma_mask) {
-				assert(0);
-				if (!pci_dma_mapping_error(rx_ring_dma))
-					pci_unmap_single(ring-&gt;bcm-&gt;pci_dev,
-							 rx_ring_dma, BCM43xx_DMA_RINGMEMSIZE,
-							 PCI_DMA_BIDIRECTIONAL);
-				goto out_err;
-			}
-                }
-
-                ring-&gt;descbase = rx_ring;
-                ring-&gt;dmabase = rx_ring_dma;
-	}
-	memset(ring-&gt;descbase, 0, BCM43xx_DMA_RINGMEMSIZE);
-
-	return 0;
-out_err:
-	printk(KERN_ERR PFX &quot;DMA ringmemory allocation failed\n&quot;);
-	return -ENOMEM;
-}
-
-static void free_ringmemory(struct bcm43xx_dmaring *ring)
-{
-	struct device *dev = &amp;(ring-&gt;bcm-&gt;pci_dev-&gt;dev);
-
-	dma_free_coherent(dev, BCM43xx_DMA_RINGMEMSIZE,
-			  ring-&gt;descbase, ring-&gt;dmabase);
-}
-
-/* Reset the RX DMA channel */
-int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_private *bcm,
-				   u16 mmio_base, int dma64)
-{
-	int i;
-	u32 value;
-	u16 offset;
-
-	offset = dma64 ? BCM43xx_DMA64_RXCTL : BCM43xx_DMA32_RXCTL;
-	bcm43xx_write32(bcm, mmio_base + offset, 0);
-	for (i = 0; i &lt; 1000; i++) {
-		offset = dma64 ? BCM43xx_DMA64_RXSTATUS : BCM43xx_DMA32_RXSTATUS;
-		value = bcm43xx_read32(bcm, mmio_base + offset);
-		if (dma64) {
-			value &amp;= BCM43xx_DMA64_RXSTAT;
-			if (value == BCM43xx_DMA64_RXSTAT_DISABLED) {
-				i = -1;
-				break;
-			}
-		} else {
-			value &amp;= BCM43xx_DMA32_RXSTATE;
-			if (value == BCM43xx_DMA32_RXSTAT_DISABLED) {
-				i = -1;
-				break;
-			}
-		}
-		udelay(10);
-	}
-	if (i != -1) {
-		printk(KERN_ERR PFX &quot;Error: Wait on DMA RX status timed out.\n&quot;);
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-/* Reset the RX DMA channel */
-int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_private *bcm,
-				   u16 mmio_base, int dma64)
-{
-	int i;
-	u32 value;
-	u16 offset;
-
-	for (i = 0; i &lt; 1000; i++) {
-		offset = dma64 ? BCM43xx_DMA64_TXSTATUS : BCM43xx_DMA32_TXSTATUS;
-		value = bcm43xx_read32(bcm, mmio_base + offset);
-		if (dma64) {
-			value &amp;= BCM43xx_DMA64_TXSTAT;
-			if (value == BCM43xx_DMA64_TXSTAT_DISABLED ||
-			    value == BCM43xx_DMA64_TXSTAT_IDLEWAIT ||
-			    value == BCM43xx_DMA64_TXSTAT_STOPPED)
-				break;
-		} else {
-			value &amp;= BCM43xx_DMA32_TXSTATE;
-			if (value == BCM43xx_DMA32_TXSTAT_DISABLED ||
-			    value == BCM43xx_DMA32_TXSTAT_IDLEWAIT ||
-			    value == BCM43xx_DMA32_TXSTAT_STOPPED)
-				break;
-		}
-		udelay(10);
-	}
-	offset = dma64 ? BCM43xx_DMA64_TXCTL : BCM43xx_DMA32_TXCTL;
-	bcm43xx_write32(bcm, mmio_base + offset, 0);
-	for (i = 0; i &lt; 1000; i++) {
-		offset = dma64 ? BCM43xx_DMA64_TXSTATUS : BCM43xx_DMA32_TXSTATUS;
-		value = bcm43xx_read32(bcm, mmio_base + offset);
-		if (dma64) {
-			value &amp;= BCM43xx_DMA64_TXSTAT;
-			if (value == BCM43xx_DMA64_TXSTAT_DISABLED) {
-				i = -1;
-				break;
-			}
-		} else {
-			value &amp;= BCM43xx_DMA32_TXSTATE;
-			if (value == BCM43xx_DMA32_TXSTAT_DISABLED) {
-				i = -1;
-				break;
-			}
-		}
-		udelay(10);
-	}
-	if (i != -1) {
-		printk(KERN_ERR PFX &quot;Error: Wait on DMA TX status timed out.\n&quot;);
-		return -ENODEV;
-	}
-	/* ensure the reset is completed. */
-	udelay(300);
-
-	return 0;
-}
-
-static void fill_descriptor(struct bcm43xx_dmaring *ring,
-			    struct bcm43xx_dmadesc_generic *desc,
-			    dma_addr_t dmaaddr,
-			    u16 bufsize,
-			    int start, int end, int irq)
-{
-	int slot;
-
-	slot = bcm43xx_dma_desc2idx(ring, desc);
-	assert(slot &gt;= 0 &amp;&amp; slot &lt; ring-&gt;nr_slots);
-
-	if (ring-&gt;dma64) {
-		u32 ctl0 = 0, ctl1 = 0;
-		u32 addrlo, addrhi;
-		u32 addrext;
-
-		addrlo = (u32)(dmaaddr &amp; 0xFFFFFFFF);
-		addrhi = (((u64)dmaaddr &gt;&gt; 32) &amp; ~BCM43xx_DMA64_ROUTING);
-		addrext = (((u64)dmaaddr &gt;&gt; 32) &gt;&gt; BCM43xx_DMA64_ROUTING_SHIFT);
-		addrhi |= ring-&gt;routing;
-		if (slot == ring-&gt;nr_slots - 1)
-			ctl0 |= BCM43xx_DMA64_DCTL0_DTABLEEND;
-		if (start)
-			ctl0 |= BCM43xx_DMA64_DCTL0_FRAMESTART;
-		if (end)
-			ctl0 |= BCM43xx_DMA64_DCTL0_FRAMEEND;
-		if (irq)
-			ctl0 |= BCM43xx_DMA64_DCTL0_IRQ;
-		ctl1 |= (bufsize - ring-&gt;frameoffset)
-			&amp; BCM43xx_DMA64_DCTL1_BYTECNT;
-		ctl1 |= (addrext &lt;&lt; BCM43xx_DMA64_DCTL1_ADDREXT_SHIFT)
-			&amp; BCM43xx_DMA64_DCTL1_ADDREXT_MASK;
-
-		desc-&gt;dma64.control0 = cpu_to_le32(ctl0);
-		desc-&gt;dma64.control1 = cpu_to_le32(ctl1);
-		desc-&gt;dma64.address_low = cpu_to_le32(addrlo);
-		desc-&gt;dma64.address_high = cpu_to_le32(addrhi);
-	} else {
-		u32 ctl;
-		u32 addr;
-		u32 addrext;
-
-		addr = (u32)(dmaaddr &amp; ~BCM43xx_DMA32_ROUTING);
-		addrext = (u32)(dmaaddr &amp; BCM43xx_DMA32_ROUTING)
-			   &gt;&gt; BCM43xx_DMA32_ROUTING_SHIFT;
-		addr |= ring-&gt;routing;
-		ctl = (bufsize - ring-&gt;frameoffset)
-		      &amp; BCM43xx_DMA32_DCTL_BYTECNT;
-		if (slot == ring-&gt;nr_slots - 1)
-			ctl |= BCM43xx_DMA32_DCTL_DTABLEEND;
-		if (start)
-			ctl |= BCM43xx_DMA32_DCTL_FRAMESTART;
-		if (end)
-			ctl |= BCM43xx_DMA32_DCTL_FRAMEEND;
-		if (irq)
-			ctl |= BCM43xx_DMA32_DCTL_IRQ;
-		ctl |= (addrext &lt;&lt; BCM43xx_DMA32_DCTL_ADDREXT_SHIFT)
-		       &amp; BCM43xx_DMA32_DCTL_ADDREXT_MASK;
-
-		desc-&gt;dma32.control = cpu_to_le32(ctl);
-		desc-&gt;dma32.address = cpu_to_le32(addr);
-	}
-}
-
-static int setup_rx_descbuffer(struct bcm43xx_dmaring *ring,
-			       struct bcm43xx_dmadesc_generic *desc,
-			       struct bcm43xx_dmadesc_meta *meta,
-			       gfp_t gfp_flags)
-{
-	struct bcm43xx_rxhdr *rxhdr;
-	struct bcm43xx_hwxmitstatus *xmitstat;
-	dma_addr_t dmaaddr;
-	struct sk_buff *skb;
-
-	assert(!ring-&gt;tx);
-
-	skb = __dev_alloc_skb(ring-&gt;rx_buffersize, gfp_flags);
-	if (unlikely(!skb))
-		return -ENOMEM;
-	dmaaddr = map_descbuffer(ring, skb-&gt;data, ring-&gt;rx_buffersize, 0);
-	/* This hardware bug work-around adapted from the b44 driver.
-	   The chip may be unable to do PCI DMA to/from anything above 1GB */
-	if (pci_dma_mapping_error(dmaaddr) ||
-	    dmaaddr + ring-&gt;rx_buffersize &gt; ring-&gt;bcm-&gt;dma_mask) {
-		/* This one has 30-bit addressing... */
-		if (!pci_dma_mapping_error(dmaaddr))
-			pci_unmap_single(ring-&gt;bcm-&gt;pci_dev,
-					 dmaaddr, ring-&gt;rx_buffersize,
-					 PCI_DMA_FROMDEVICE);
-		dev_kfree_skb_any(skb);
-		skb = __dev_alloc_skb(ring-&gt;rx_buffersize,GFP_DMA);
-		if (skb == NULL)
-			return -ENOMEM;
-		dmaaddr = pci_map_single(ring-&gt;bcm-&gt;pci_dev,
-					 skb-&gt;data, ring-&gt;rx_buffersize,
-					 PCI_DMA_FROMDEVICE);
-		if (pci_dma_mapping_error(dmaaddr) ||
-		    dmaaddr + ring-&gt;rx_buffersize &gt; ring-&gt;bcm-&gt;dma_mask) {
-			assert(0);
-			dev_kfree_skb_any(skb);
-			return -ENOMEM;
-		}
-	}
-	meta-&gt;skb = skb;
-	meta-&gt;dmaaddr = dmaaddr;
-	skb-&gt;dev = ring-&gt;bcm-&gt;net_dev;
-
-	fill_descriptor(ring, desc, dmaaddr,
-			ring-&gt;rx_buffersize, 0, 0, 0);
-
-	rxhdr = (struct bcm43xx_rxhdr *)(skb-&gt;data);
-	rxhdr-&gt;frame_length = 0;
-	rxhdr-&gt;flags1 = 0;
-	xmitstat = (struct bcm43xx_hwxmitstatus *)(skb-&gt;data);
-	xmitstat-&gt;cookie = 0;
-
-	return 0;
-}
-
-/* Allocate the initial descbuffers.
- * This is used for an RX ring only.
- */
-static int alloc_initial_descbuffers(struct bcm43xx_dmaring *ring)
-{
-	int i, err = -ENOMEM;
-	struct bcm43xx_dmadesc_generic *desc;
-	struct bcm43xx_dmadesc_meta *meta;
-
-	for (i = 0; i &lt; ring-&gt;nr_slots; i++) {
-		desc = bcm43xx_dma_idx2desc(ring, i, &amp;meta);
-
-		err = setup_rx_descbuffer(ring, desc, meta, GFP_KERNEL);
-		if (err)
-			goto err_unwind;
-	}
-	mb();
-	ring-&gt;used_slots = ring-&gt;nr_slots;
-	err = 0;
-out:
-	return err;
-
-err_unwind:
-	for (i--; i &gt;= 0; i--) {
-		desc = bcm43xx_dma_idx2desc(ring, i, &amp;meta);
-
-		unmap_descbuffer(ring, meta-&gt;dmaaddr, ring-&gt;rx_buffersize, 0);
-		dev_kfree_skb(meta-&gt;skb);
-	}
-	goto out;
-}
-
-/* Do initial setup of the DMA controller.
- * Reset the controller, write the ring busaddress
- * and switch the &quot;enable&quot; bit on.
- */
-static int dmacontroller_setup(struct bcm43xx_dmaring *ring)
-{
-	int err = 0;
-	u32 value;
-	u32 addrext;
-
-	if (ring-&gt;tx) {
-		if (ring-&gt;dma64) {
-			u64 ringbase = (u64)(ring-&gt;dmabase);
-
-			addrext = ((ringbase &gt;&gt; 32) &gt;&gt; BCM43xx_DMA64_ROUTING_SHIFT);
-			value = BCM43xx_DMA64_TXENABLE;
-			value |= (addrext &lt;&lt; BCM43xx_DMA64_TXADDREXT_SHIFT)
-				&amp; BCM43xx_DMA64_TXADDREXT_MASK;
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXCTL, value);
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGLO,
-					(ringbase &amp; 0xFFFFFFFF));
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGHI,
-					((ringbase &gt;&gt; 32) &amp; ~BCM43xx_DMA64_ROUTING)
-					| ring-&gt;routing);
-		} else {
-			u32 ringbase = (u32)(ring-&gt;dmabase);
-
-			addrext = (ringbase &gt;&gt; BCM43xx_DMA32_ROUTING_SHIFT);
-			value = BCM43xx_DMA32_TXENABLE;
-			value |= (addrext &lt;&lt; BCM43xx_DMA32_TXADDREXT_SHIFT)
-				&amp; BCM43xx_DMA32_TXADDREXT_MASK;
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_TXCTL, value);
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_TXRING,
-					(ringbase &amp; ~BCM43xx_DMA32_ROUTING)
-					| ring-&gt;routing);
-		}
-	} else {
-		err = alloc_initial_descbuffers(ring);
-		if (err)
-			goto out;
-		if (ring-&gt;dma64) {
-			u64 ringbase = (u64)(ring-&gt;dmabase);
-
-			addrext = ((ringbase &gt;&gt; 32) &gt;&gt; BCM43xx_DMA64_ROUTING_SHIFT);
-			value = (ring-&gt;frameoffset &lt;&lt; BCM43xx_DMA64_RXFROFF_SHIFT);
-			value |= BCM43xx_DMA64_RXENABLE;
-			value |= (addrext &lt;&lt; BCM43xx_DMA64_RXADDREXT_SHIFT)
-				&amp; BCM43xx_DMA64_RXADDREXT_MASK;
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXCTL, value);
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGLO,
-					(ringbase &amp; 0xFFFFFFFF));
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGHI,
-					((ringbase &gt;&gt; 32) &amp; ~BCM43xx_DMA64_ROUTING)
-					| ring-&gt;routing);
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXINDEX, 200);
-		} else {
-			u32 ringbase = (u32)(ring-&gt;dmabase);
-
-			addrext = (ringbase &gt;&gt; BCM43xx_DMA32_ROUTING_SHIFT);
-			value = (ring-&gt;frameoffset &lt;&lt; BCM43xx_DMA32_RXFROFF_SHIFT);
-			value |= BCM43xx_DMA32_RXENABLE;
-			value |= (addrext &lt;&lt; BCM43xx_DMA32_RXADDREXT_SHIFT)
-				&amp; BCM43xx_DMA32_RXADDREXT_MASK;
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXCTL, value);
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXRING,
-					(ringbase &amp; ~BCM43xx_DMA32_ROUTING)
-					| ring-&gt;routing);
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXINDEX, 200);
-		}
-	}
-
-out:
-	return err;
-}
-
-/* Shutdown the DMA controller. */
-static void dmacontroller_cleanup(struct bcm43xx_dmaring *ring)
-{
-	if (ring-&gt;tx) {
-		bcm43xx_dmacontroller_tx_reset(ring-&gt;bcm, ring-&gt;mmio_base, ring-&gt;dma64);
-		if (ring-&gt;dma64) {
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGLO, 0);
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_TXRINGHI, 0);
-		} else
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_TXRING, 0);
-	} else {
-		bcm43xx_dmacontroller_rx_reset(ring-&gt;bcm, ring-&gt;mmio_base, ring-&gt;dma64);
-		if (ring-&gt;dma64) {
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGLO, 0);
-			bcm43xx_dma_write(ring, BCM43xx_DMA64_RXRINGHI, 0);
-		} else
-			bcm43xx_dma_write(ring, BCM43xx_DMA32_RXRING, 0);
-	}
-}
-
-static void free_all_descbuffers(struct bcm43xx_dmaring *ring)
-{
-	struct bcm43xx_dmadesc_generic *desc;
-	struct bcm43xx_dmadesc_meta *meta;
-	int i;
-
-	if (!ring-&gt;used_slots)
-		return;
-	for (i = 0; i &lt; ring-&gt;nr_slots; i++) {
-		desc = bcm43xx_dma_idx2desc(ring, i, &amp;meta);
-
-		if (!meta-&gt;skb) {
-			assert(ring-&gt;tx);
-			continue;
-		}
-		if (ring-&gt;tx) {
-			unmap_descbuffer(ring, meta-&gt;dmaaddr,
-					meta-&gt;skb-&gt;len, 1);
-		} else {
-			unmap_descbuffer(ring, meta-&gt;dmaaddr,
-					ring-&gt;rx_buffersize, 0);
-		}
-		free_descriptor_buffer(ring, meta, 0);
-	}
-}
-
-/* Main initialization function. */
-static
-struct bcm43xx_dmaring * bcm43xx_setup_dmaring(struct bcm43xx_private *bcm,
-					       int controller_index,
-					       int for_tx,
-					       int dma64)
-{
-	struct bcm43xx_dmaring *ring;
-	int err;
-	int nr_slots;
-
-	ring = kzalloc(sizeof(*ring), GFP_KERNEL);
-	if (!ring)
-		goto out;
-
-	nr_slots = BCM43xx_RXRING_SLOTS;
-	if (for_tx)
-		nr_slots = BCM43xx_TXRING_SLOTS;
-
-	ring-&gt;meta = kcalloc(nr_slots, sizeof(struct bcm43xx_dmadesc_meta),
-			     GFP_KERNEL);
-	if (!ring-&gt;meta)
-		goto err_kfree_ring;
-
-	ring-&gt;routing = BCM43xx_DMA32_CLIENTTRANS;
-	if (dma64)
-		ring-&gt;routing = BCM43xx_DMA64_CLIENTTRANS;
-
-	ring-&gt;bcm = bcm;
-	ring-&gt;nr_slots = nr_slots;
-	ring-&gt;suspend_mark = ring-&gt;nr_slots * BCM43xx_TXSUSPEND_PERCENT / 100;
-	ring-&gt;resume_mark = ring-&gt;nr_slots * BCM43xx_TXRESUME_PERCENT / 100;
-	assert(ring-&gt;suspend_mark &lt; ring-&gt;resume_mark);
-	ring-&gt;mmio_base = bcm43xx_dmacontroller_base(dma64, controller_index);
-	ring-&gt;index = controller_index;
-	ring-&gt;dma64 = !!dma64;
-	if (for_tx) {
-		ring-&gt;tx = 1;
-		ring-&gt;current_slot = -1;
-	} else {
-		if (ring-&gt;index == 0) {
-			ring-&gt;rx_buffersize = BCM43xx_DMA0_RX_BUFFERSIZE;
-			ring-&gt;frameoffset = BCM43xx_DMA0_RX_FRAMEOFFSET;
-		} else if (ring-&gt;index == 3) {
-			ring-&gt;rx_buffersize = BCM43xx_DMA3_RX_BUFFERSIZE;
-			ring-&gt;frameoffset = BCM43xx_DMA3_RX_FRAMEOFFSET;
-		} else
-			assert(0);
-	}
-
-	err = alloc_ringmemory(ring);
-	if (err)
-		goto err_kfree_meta;
-	err = dmacontroller_setup(ring);
-	if (err)
-		goto err_free_ringmemory;
-	return ring;
-
-out:
-	printk(KERN_ERR PFX &quot;Error in bcm43xx_setup_dmaring\n&quot;);
-	return ring;
-
-err_free_ringmemory:
-	free_ringmemory(ring);
-err_kfree_meta:
-	kfree(ring-&gt;meta);
-err_kfree_ring:
-	kfree(ring);
-	ring = NULL;
-	goto out;
-}
-
-/* Main cleanup function. */
-static void bcm43xx_destroy_dmaring(struct bcm43xx_dmaring *ring)
-{
-	if (!ring)
-		return;
-
-	dprintk(KERN_INFO PFX &quot;DMA-%s 0x%04X (%s) max used slots: %d/%d\n&quot;,
-		(ring-&gt;dma64) ? &quot;64&quot; : &quot;32&quot;,
-		ring-&gt;mmio_base,
-		(ring-&gt;tx) ? &quot;TX&quot; : &quot;RX&quot;,
-		ring-&gt;max_used_slots, ring-&gt;nr_slots);
-	/* Device IRQs are disabled prior entering this function,
-	 * so no need to take care of concurrency with rx handler stuff.
-	 */
-	dmacontroller_cleanup(ring);
-	free_all_descbuffers(ring);
-	free_ringmemory(ring);
-
-	kfree(ring-&gt;meta);
-	kfree(ring);
-}
-
-void bcm43xx_dma_free(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_dma *dma;
-
-	if (bcm43xx_using_pio(bcm))
-		return;
-	dma = bcm43xx_current_dma(bcm);
-
-	bcm43xx_destroy_dmaring(dma-&gt;rx_ring3);
-	dma-&gt;rx_ring3 = NULL;
-	bcm43xx_destroy_dmaring(dma-&gt;rx_ring0);
-	dma-&gt;rx_ring0 = NULL;
-
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring5);
-	dma-&gt;tx_ring5 = NULL;
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring4);
-	dma-&gt;tx_ring4 = NULL;
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring3);
-	dma-&gt;tx_ring3 = NULL;
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring2);
-	dma-&gt;tx_ring2 = NULL;
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring1);
-	dma-&gt;tx_ring1 = NULL;
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring0);
-	dma-&gt;tx_ring0 = NULL;
-}
-
-int bcm43xx_dma_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_dma *dma = bcm43xx_current_dma(bcm);
-	struct bcm43xx_dmaring *ring;
-	int err = -ENOMEM;
-	int dma64 = 0;
-
-	bcm-&gt;dma_mask = bcm43xx_get_supported_dma_mask(bcm);
-	if (bcm-&gt;dma_mask == DMA_64BIT_MASK)
-		dma64 = 1;
-	err = pci_set_dma_mask(bcm-&gt;pci_dev, bcm-&gt;dma_mask);
-	if (err)
-		goto no_dma;
-	err = pci_set_consistent_dma_mask(bcm-&gt;pci_dev, bcm-&gt;dma_mask);
-	if (err)
-		goto no_dma;
-
-	/* setup TX DMA channels. */
-	ring = bcm43xx_setup_dmaring(bcm, 0, 1, dma64);
-	if (!ring)
-		goto out;
-	dma-&gt;tx_ring0 = ring;
-
-	ring = bcm43xx_setup_dmaring(bcm, 1, 1, dma64);
-	if (!ring)
-		goto err_destroy_tx0;
-	dma-&gt;tx_ring1 = ring;
-
-	ring = bcm43xx_setup_dmaring(bcm, 2, 1, dma64);
-	if (!ring)
-		goto err_destroy_tx1;
-	dma-&gt;tx_ring2 = ring;
-
-	ring = bcm43xx_setup_dmaring(bcm, 3, 1, dma64);
-	if (!ring)
-		goto err_destroy_tx2;
-	dma-&gt;tx_ring3 = ring;
-
-	ring = bcm43xx_setup_dmaring(bcm, 4, 1, dma64);
-	if (!ring)
-		goto err_destroy_tx3;
-	dma-&gt;tx_ring4 = ring;
-
-	ring = bcm43xx_setup_dmaring(bcm, 5, 1, dma64);
-	if (!ring)
-		goto err_destroy_tx4;
-	dma-&gt;tx_ring5 = ring;
-
-	/* setup RX DMA channels. */
-	ring = bcm43xx_setup_dmaring(bcm, 0, 0, dma64);
-	if (!ring)
-		goto err_destroy_tx5;
-	dma-&gt;rx_ring0 = ring;
-
-	if (bcm-&gt;current_core-&gt;rev &lt; 5) {
-		ring = bcm43xx_setup_dmaring(bcm, 3, 0, dma64);
-		if (!ring)
-			goto err_destroy_rx0;
-		dma-&gt;rx_ring3 = ring;
-	}
-
-	dprintk(KERN_INFO PFX &quot;%d-bit DMA initialized\n&quot;,
-		(bcm-&gt;dma_mask == DMA_64BIT_MASK) ? 64 :
-		(bcm-&gt;dma_mask == DMA_32BIT_MASK) ? 32 : 30);
-	err = 0;
-out:
-	return err;
-
-err_destroy_rx0:
-	bcm43xx_destroy_dmaring(dma-&gt;rx_ring0);
-	dma-&gt;rx_ring0 = NULL;
-err_destroy_tx5:
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring5);
-	dma-&gt;tx_ring5 = NULL;
-err_destroy_tx4:
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring4);
-	dma-&gt;tx_ring4 = NULL;
-err_destroy_tx3:
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring3);
-	dma-&gt;tx_ring3 = NULL;
-err_destroy_tx2:
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring2);
-	dma-&gt;tx_ring2 = NULL;
-err_destroy_tx1:
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring1);
-	dma-&gt;tx_ring1 = NULL;
-err_destroy_tx0:
-	bcm43xx_destroy_dmaring(dma-&gt;tx_ring0);
-	dma-&gt;tx_ring0 = NULL;
-no_dma:
-#ifdef CONFIG_BCM43XX_PIO
-	printk(KERN_WARNING PFX &quot;DMA not supported on this device.&quot;
-				&quot; Falling back to PIO.\n&quot;);
-	bcm-&gt;__using_pio = 1;
-	return -ENOSYS;
-#else
-	printk(KERN_ERR PFX &quot;FATAL: DMA not supported and PIO not configured. &quot;
-			    &quot;Please recompile the driver with PIO support.\n&quot;);
-	return -ENODEV;
-#endif /* CONFIG_BCM43XX_PIO */
-}
-
-/* Generate a cookie for the TX header. */
-static u16 generate_cookie(struct bcm43xx_dmaring *ring,
-			   int slot)
-{
-	u16 cookie = 0x1000;
-
-	/* Use the upper 4 bits of the cookie as
-	 * DMA controller ID and store the slot number
-	 * in the lower 12 bits.
-	 * Note that the cookie must never be 0, as this
-	 * is a special value used in RX path.
-	 */
-	switch (ring-&gt;index) {
-	case 0:
-		cookie = 0xA000;
-		break;
-	case 1:
-		cookie = 0xB000;
-		break;
-	case 2:
-		cookie = 0xC000;
-		break;
-	case 3:
-		cookie = 0xD000;
-		break;
-	case 4:
-		cookie = 0xE000;
-		break;
-	case 5:
-		cookie = 0xF000;
-		break;
-	}
-	assert(((u16)slot &amp; 0xF000) == 0x0000);
-	cookie |= (u16)slot;
-
-	return cookie;
-}
-
-/* Inspect a cookie and find out to which controller/slot it belongs. */
-static
-struct bcm43xx_dmaring * parse_cookie(struct bcm43xx_private *bcm,
-				      u16 cookie, int *slot)
-{
-	struct bcm43xx_dma *dma = bcm43xx_current_dma(bcm);
-	struct bcm43xx_dmaring *ring = NULL;
-
-	switch (cookie &amp; 0xF000) {
-	case 0xA000:
-		ring = dma-&gt;tx_ring0;
-		break;
-	case 0xB000:
-		ring = dma-&gt;tx_ring1;
-		break;
-	case 0xC000:
-		ring = dma-&gt;tx_ring2;
-		break;
-	case 0xD000:
-		ring = dma-&gt;tx_ring3;
-		break;
-	case 0xE000:
-		ring = dma-&gt;tx_ring4;
-		break;
-	case 0xF000:
-		ring = dma-&gt;tx_ring5;
-		break;
-	default:
-		assert(0);
-	}
-	*slot = (cookie &amp; 0x0FFF);
-	assert(*slot &gt;= 0 &amp;&amp; *slot &lt; ring-&gt;nr_slots);
-
-	return ring;
-}
-
-static void dmacontroller_poke_tx(struct bcm43xx_dmaring *ring,
-				  int slot)
-{
-	u16 offset;
-	int descsize;
-
-	/* Everything is ready to start. Buffers are DMA mapped and
-	 * associated with slots.
-	 * &quot;slot&quot; is the last slot of the new frame we want to transmit.
-	 * Close your seat belts now, please.
-	 */
-	wmb();
-	slot = next_slot(ring, slot);
-	offset = (ring-&gt;dma64) ? BCM43xx_DMA64_TXINDEX : BCM43xx_DMA32_TXINDEX;
-	descsize = (ring-&gt;dma64) ? sizeof(struct bcm43xx_dmadesc64)
-		: sizeof(struct bcm43xx_dmadesc32);
-	bcm43xx_dma_write(ring, offset,
-			(u32)(slot * descsize));
-}
-
-static void dma_tx_fragment(struct bcm43xx_dmaring *ring,
-			    struct sk_buff *skb,
-			    u8 cur_frag)
-{
-	int slot;
-	struct bcm43xx_dmadesc_generic *desc;
-	struct bcm43xx_dmadesc_meta *meta;
-	dma_addr_t dmaaddr;
-	struct sk_buff *bounce_skb;
-
-	assert(skb_shinfo(skb)-&gt;nr_frags == 0);
-
-	slot = request_slot(ring);
-	desc = bcm43xx_dma_idx2desc(ring, slot, &amp;meta);
-
-	/* Add a device specific TX header. */
-	assert(skb_headroom(skb) &gt;= sizeof(struct bcm43xx_txhdr));
-	/* Reserve enough headroom for the device tx header. */
-	__skb_push(skb, sizeof(struct bcm43xx_txhdr));
-	/* Now calculate and add the tx header.
-	 * The tx header includes the PLCP header.
-	 */
-	bcm43xx_generate_txhdr(ring-&gt;bcm,
-			       (struct bcm43xx_txhdr *)skb-&gt;data,
-			       skb-&gt;data + sizeof(struct bcm43xx_txhdr),
-			       skb-&gt;len - sizeof(struct bcm43xx_txhdr),
-			       (cur_frag == 0),
-			       generate_cookie(ring, slot));
-	dmaaddr = map_descbuffer(ring, skb-&gt;data, skb-&gt;len, 1);
-	if (dma_mapping_error(dmaaddr) || dmaaddr + skb-&gt;len &gt; ring-&gt;bcm-&gt;dma_mask) {
-		/* chip cannot handle DMA to/from &gt; 1GB, use bounce buffer (copied from b44 driver) */
-		if (!dma_mapping_error(dmaaddr))
-			unmap_descbuffer(ring, dmaaddr, skb-&gt;len, 1);
-		bounce_skb = __dev_alloc_skb(skb-&gt;len, GFP_ATOMIC|GFP_DMA);
-		if (!bounce_skb)
-			return;
-		dmaaddr = map_descbuffer(ring, bounce_skb-&gt;data, bounce_skb-&gt;len, 1);
-		if (dma_mapping_error(dmaaddr) || dmaaddr + skb-&gt;len &gt; ring-&gt;bcm-&gt;dma_mask) {
-			if (!dma_mapping_error(dmaaddr))
-				unmap_descbuffer(ring, dmaaddr, skb-&gt;len, 1);
-			dev_kfree_skb_any(bounce_skb);
-			assert(0);
-			return;
-		}
-		skb_copy_from_linear_data(skb, skb_put(bounce_skb, skb-&gt;len),
-					  skb-&gt;len);
-		dev_kfree_skb_any(skb);
-		skb = bounce_skb;
-	}
-
-	meta-&gt;skb = skb;
-	meta-&gt;dmaaddr = dmaaddr;
-
-	fill_descriptor(ring, desc, dmaaddr,
-			skb-&gt;len, 1, 1, 1);
-
-	/* Now transfer the whole frame. */
-	dmacontroller_poke_tx(ring, slot);
-}
-
-int bcm43xx_dma_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
-{
-	/* We just received a packet from the kernel network subsystem.
-	 * Add headers and DMA map the memory. Poke
-	 * the device to send the stuff.
-	 * Note that this is called from atomic context.
-	 */
-	struct bcm43xx_dmaring *ring = bcm43xx_current_dma(bcm)-&gt;tx_ring1;
-	u8 i;
-	struct sk_buff *skb;
-
-	assert(ring-&gt;tx);
-	if (unlikely(free_slots(ring) &lt; txb-&gt;nr_frags)) {
-		/* The queue should be stopped,
-		 * if we are low on free slots.
-		 * If this ever triggers, we have to lower the suspend_mark.
-		 */
-		dprintkl(KERN_ERR PFX &quot;Out of DMA descriptor slots!\n&quot;);
-		return -ENOMEM;
-	}
-
-	for (i = 0; i &lt; txb-&gt;nr_frags; i++) {
-		skb = txb-&gt;fragments[i];
-		/* Take skb from ieee80211_txb_free */
-		txb-&gt;fragments[i] = NULL;
-		dma_tx_fragment(ring, skb, i);
-	}
-	ieee80211_txb_free(txb);
-
-	return 0;
-}
-
-void bcm43xx_dma_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
-{
-	struct bcm43xx_dmaring *ring;
-	struct bcm43xx_dmadesc_generic *desc;
-	struct bcm43xx_dmadesc_meta *meta;
-	int is_last_fragment;
-	int slot;
-	u32 tmp;
-
-	ring = parse_cookie(bcm, status-&gt;cookie, &amp;slot);
-	assert(ring);
-	assert(ring-&gt;tx);
-	while (1) {
-		assert(slot &gt;= 0 &amp;&amp; slot &lt; ring-&gt;nr_slots);
-		desc = bcm43xx_dma_idx2desc(ring, slot, &amp;meta);
-
-		if (ring-&gt;dma64) {
-			tmp = le32_to_cpu(desc-&gt;dma64.control0);
-			is_last_fragment = !!(tmp &amp; BCM43xx_DMA64_DCTL0_FRAMEEND);
-		} else {
-			tmp = le32_to_cpu(desc-&gt;dma32.control);
-			is_last_fragment = !!(tmp &amp; BCM43xx_DMA32_DCTL_FRAMEEND);
-		}
-		unmap_descbuffer(ring, meta-&gt;dmaaddr, meta-&gt;skb-&gt;len, 1);
-		free_descriptor_buffer(ring, meta, 1);
-		/* Everything belonging to the slot is unmapped
-		 * and freed, so we can return it.
-		 */
-		return_slot(ring, slot);
-
-		if (is_last_fragment)
-			break;
-		slot = next_slot(ring, slot);
-	}
-	bcm-&gt;stats.last_tx = jiffies;
-}
-
-static void dma_rx(struct bcm43xx_dmaring *ring,
-		   int *slot)
-{
-	struct bcm43xx_dmadesc_generic *desc;
-	struct bcm43xx_dmadesc_meta *meta;
-	struct bcm43xx_rxhdr *rxhdr;
-	struct sk_buff *skb;
-	u16 len;
-	int err;
-	dma_addr_t dmaaddr;
-
-	desc = bcm43xx_dma_idx2desc(ring, *slot, &amp;meta);
-
-	sync_descbuffer_for_cpu(ring, meta-&gt;dmaaddr, ring-&gt;rx_buffersize);
-	skb = meta-&gt;skb;
-
-	if (ring-&gt;index == 3) {
-		/* We received an xmit status. */
-		struct bcm43xx_hwxmitstatus *hw = (struct bcm43xx_hwxmitstatus *)skb-&gt;data;
-		struct bcm43xx_xmitstatus stat;
-		int i = 0;
-
-		stat.cookie = le16_to_cpu(hw-&gt;cookie);
-		while (stat.cookie == 0) {
-			if (unlikely(++i &gt;= 10000)) {
-				assert(0);
-				break;
-			}
-			udelay(2);
-			barrier();
-			stat.cookie = le16_to_cpu(hw-&gt;cookie);
-		}
-		stat.flags = hw-&gt;flags;
-		stat.cnt1 = hw-&gt;cnt1;
-		stat.cnt2 = hw-&gt;cnt2;
-		stat.seq = le16_to_cpu(hw-&gt;seq);
-		stat.unknown = le16_to_cpu(hw-&gt;unknown);
-
-		bcm43xx_debugfs_log_txstat(ring-&gt;bcm, &amp;stat);
-		bcm43xx_dma_handle_xmitstatus(ring-&gt;bcm, &amp;stat);
-		/* recycle the descriptor buffer. */
-		sync_descbuffer_for_device(ring, meta-&gt;dmaaddr, ring-&gt;rx_buffersize);
-
-		return;
-	}
-	rxhdr = (struct bcm43xx_rxhdr *)skb-&gt;data;
-	len = le16_to_cpu(rxhdr-&gt;frame_length);
-	if (len == 0) {
-		int i = 0;
-
-		do {
-			udelay(2);
-			barrier();
-			len = le16_to_cpu(rxhdr-&gt;frame_length);
-		} while (len == 0 &amp;&amp; i++ &lt; 5);
-		if (unlikely(len == 0)) {
-			/* recycle the descriptor buffer. */
-			sync_descbuffer_for_device(ring, meta-&gt;dmaaddr,
-						   ring-&gt;rx_buffersize);
-			goto drop;
-		}
-	}
-	if (unlikely(len &gt; ring-&gt;rx_buffersize)) {
-		/* The data did not fit into one descriptor buffer
-		 * and is split over multiple buffers.
-		 * This should never happen, as we try to allocate buffers
-		 * big enough. So simply ignore this packet.
-		 */
-		int cnt = 0;
-		s32 tmp = len;
-
-		while (1) {
-			desc = bcm43xx_dma_idx2desc(ring, *slot, &amp;meta);
-			/* recycle the descriptor buffer. */
-			sync_descbuffer_for_device(ring, meta-&gt;dmaaddr,
-						   ring-&gt;rx_buffersize);
-			*slot = next_slot(ring, *slot);
-			cnt++;
-			tmp -= ring-&gt;rx_buffersize;
-			if (tmp &lt;= 0)
-				break;
-		}
-		printkl(KERN_ERR PFX &quot;DMA RX buffer too small &quot;
-			&quot;(len: %u, buffer: %u, nr-dropped: %d)\n&quot;,
-			len, ring-&gt;rx_buffersize, cnt);
-		goto drop;
-	}
-	len -= IEEE80211_FCS_LEN;
-
-	dmaaddr = meta-&gt;dmaaddr;
-	err = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);
-	if (unlikely(err)) {
-		dprintkl(KERN_ERR PFX &quot;DMA RX: setup_rx_descbuffer() failed\n&quot;);
-		sync_descbuffer_for_device(ring, dmaaddr,
-					   ring-&gt;rx_buffersize);
-		goto drop;
-	}
-
-	unmap_descbuffer(ring, dmaaddr, ring-&gt;rx_buffersize, 0);
-	skb_put(skb, len + ring-&gt;frameoffset);
-	skb_pull(skb, ring-&gt;frameoffset);
-
-	err = bcm43xx_rx(ring-&gt;bcm, skb, rxhdr);
-	if (err) {
-		dev_kfree_skb_irq(skb);
-		goto drop;
-	}
-
-drop:
-	return;
-}
-
-void bcm43xx_dma_rx(struct bcm43xx_dmaring *ring)
-{
-	u32 status;
-	u16 descptr;
-	int slot, current_slot;
-#ifdef CONFIG_BCM43XX_DEBUG
-	int used_slots = 0;
-#endif
-
-	assert(!ring-&gt;tx);
-	if (ring-&gt;dma64) {
-		status = bcm43xx_dma_read(ring, BCM43xx_DMA64_RXSTATUS);
-		descptr = (status &amp; BCM43xx_DMA64_RXSTATDPTR);
-		current_slot = descptr / sizeof(struct bcm43xx_dmadesc64);
-	} else {
-		status = bcm43xx_dma_read(ring, BCM43xx_DMA32_RXSTATUS);
-		descptr = (status &amp; BCM43xx_DMA32_RXDPTR);
-		current_slot = descptr / sizeof(struct bcm43xx_dmadesc32);
-	}
-	assert(current_slot &gt;= 0 &amp;&amp; current_slot &lt; ring-&gt;nr_slots);
-
-	slot = ring-&gt;current_slot;
-	for ( ; slot != current_slot; slot = next_slot(ring, slot)) {
-		dma_rx(ring, &amp;slot);
-#ifdef CONFIG_BCM43XX_DEBUG
-		if (++used_slots &gt; ring-&gt;max_used_slots)
-			ring-&gt;max_used_slots = used_slots;
-#endif
-	}
-	if (ring-&gt;dma64) {
-		bcm43xx_dma_write(ring, BCM43xx_DMA64_RXINDEX,
-				(u32)(slot * sizeof(struct bcm43xx_dmadesc64)));
-	} else {
-		bcm43xx_dma_write(ring, BCM43xx_DMA32_RXINDEX,
-				(u32)(slot * sizeof(struct bcm43xx_dmadesc32)));
-	}
-	ring-&gt;current_slot = slot;
-}
-
-void bcm43xx_dma_tx_suspend(struct bcm43xx_dmaring *ring)
-{
-	assert(ring-&gt;tx);
-	bcm43xx_power_saving_ctl_bits(ring-&gt;bcm, -1, 1);
-	if (ring-&gt;dma64) {
-		bcm43xx_dma_write(ring, BCM43xx_DMA64_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA64_TXCTL)
-				| BCM43xx_DMA64_TXSUSPEND);
-	} else {
-		bcm43xx_dma_write(ring, BCM43xx_DMA32_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA32_TXCTL)
-				| BCM43xx_DMA32_TXSUSPEND);
-	}
-}
-
-void bcm43xx_dma_tx_resume(struct bcm43xx_dmaring *ring)
-{
-	assert(ring-&gt;tx);
-	if (ring-&gt;dma64) {
-		bcm43xx_dma_write(ring, BCM43xx_DMA64_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA64_TXCTL)
-				&amp; ~BCM43xx_DMA64_TXSUSPEND);
-	} else {
-		bcm43xx_dma_write(ring, BCM43xx_DMA32_TXCTL,
-				bcm43xx_dma_read(ring, BCM43xx_DMA32_TXCTL)
-				&amp; ~BCM43xx_DMA32_TXSUSPEND);
-	}
-	bcm43xx_power_saving_ctl_bits(ring-&gt;bcm, -1, -1);
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_dma.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_dma.h
+++ /dev/null
@@ -1,386 +0,0 @@
-#ifndef BCM43xx_DMA_H_
-#define BCM43xx_DMA_H_
-
-#include &lt;linux/list.h&gt;
-#include &lt;linux/spinlock.h&gt;
-#include &lt;linux/workqueue.h&gt;
-#include &lt;linux/dma-mapping.h&gt;
-#include &lt;linux/linkage.h&gt;
-#include &lt;asm/atomic.h&gt;
-
-
-/* DMA-Interrupt reasons. */
-#define BCM43xx_DMAIRQ_FATALMASK	((1 &lt;&lt; 10) | (1 &lt;&lt; 11) | (1 &lt;&lt; 12) \
-					 | (1 &lt;&lt; 14) | (1 &lt;&lt; 15))
-#define BCM43xx_DMAIRQ_NONFATALMASK	(1 &lt;&lt; 13)
-#define BCM43xx_DMAIRQ_RX_DONE		(1 &lt;&lt; 16)
-
-
-/*** 32-bit DMA Engine. ***/
-
-/* 32-bit DMA controller registers. */
-#define BCM43xx_DMA32_TXCTL				0x00
-#define		BCM43xx_DMA32_TXENABLE			0x00000001
-#define		BCM43xx_DMA32_TXSUSPEND			0x00000002
-#define		BCM43xx_DMA32_TXLOOPBACK		0x00000004
-#define		BCM43xx_DMA32_TXFLUSH			0x00000010
-#define		BCM43xx_DMA32_TXADDREXT_MASK		0x00030000
-#define		BCM43xx_DMA32_TXADDREXT_SHIFT		16
-#define BCM43xx_DMA32_TXRING				0x04
-#define BCM43xx_DMA32_TXINDEX				0x08
-#define BCM43xx_DMA32_TXSTATUS				0x0C
-#define		BCM43xx_DMA32_TXDPTR			0x00000FFF
-#define		BCM43xx_DMA32_TXSTATE			0x0000F000
-#define			BCM43xx_DMA32_TXSTAT_DISABLED	0x00000000
-#define			BCM43xx_DMA32_TXSTAT_ACTIVE	0x00001000
-#define			BCM43xx_DMA32_TXSTAT_IDLEWAIT	0x00002000
-#define			BCM43xx_DMA32_TXSTAT_STOPPED	0x00003000
-#define			BCM43xx_DMA32_TXSTAT_SUSP	0x00004000
-#define		BCM43xx_DMA32_TXERROR			0x000F0000
-#define			BCM43xx_DMA32_TXERR_NOERR	0x00000000
-#define			BCM43xx_DMA32_TXERR_PROT	0x00010000
-#define			BCM43xx_DMA32_TXERR_UNDERRUN	0x00020000
-#define			BCM43xx_DMA32_TXERR_BUFREAD	0x00030000
-#define			BCM43xx_DMA32_TXERR_DESCREAD	0x00040000
-#define		BCM43xx_DMA32_TXACTIVE			0xFFF00000
-#define BCM43xx_DMA32_RXCTL				0x10
-#define		BCM43xx_DMA32_RXENABLE			0x00000001
-#define		BCM43xx_DMA32_RXFROFF_MASK		0x000000FE
-#define		BCM43xx_DMA32_RXFROFF_SHIFT		1
-#define		BCM43xx_DMA32_RXDIRECTFIFO		0x00000100
-#define		BCM43xx_DMA32_RXADDREXT_MASK		0x00030000
-#define		BCM43xx_DMA32_RXADDREXT_SHIFT		16
-#define BCM43xx_DMA32_RXRING				0x14
-#define BCM43xx_DMA32_RXINDEX				0x18
-#define BCM43xx_DMA32_RXSTATUS				0x1C
-#define		BCM43xx_DMA32_RXDPTR			0x00000FFF
-#define		BCM43xx_DMA32_RXSTATE			0x0000F000
-#define			BCM43xx_DMA32_RXSTAT_DISABLED	0x00000000
-#define			BCM43xx_DMA32_RXSTAT_ACTIVE	0x00001000
-#define			BCM43xx_DMA32_RXSTAT_IDLEWAIT	0x00002000
-#define			BCM43xx_DMA32_RXSTAT_STOPPED	0x00003000
-#define		BCM43xx_DMA32_RXERROR			0x000F0000
-#define			BCM43xx_DMA32_RXERR_NOERR	0x00000000
-#define			BCM43xx_DMA32_RXERR_PROT	0x00010000
-#define			BCM43xx_DMA32_RXERR_OVERFLOW	0x00020000
-#define			BCM43xx_DMA32_RXERR_BUFWRITE	0x00030000
-#define			BCM43xx_DMA32_RXERR_DESCREAD	0x00040000
-#define		BCM43xx_DMA32_RXACTIVE			0xFFF00000
-
-/* 32-bit DMA descriptor. */
-struct bcm43xx_dmadesc32 {
-	__le32 control;
-	__le32 address;
-} __attribute__((__packed__));
-#define BCM43xx_DMA32_DCTL_BYTECNT		0x00001FFF
-#define BCM43xx_DMA32_DCTL_ADDREXT_MASK		0x00030000
-#define BCM43xx_DMA32_DCTL_ADDREXT_SHIFT	16
-#define BCM43xx_DMA32_DCTL_DTABLEEND		0x10000000
-#define BCM43xx_DMA32_DCTL_IRQ			0x20000000
-#define BCM43xx_DMA32_DCTL_FRAMEEND		0x40000000
-#define BCM43xx_DMA32_DCTL_FRAMESTART		0x80000000
-
-/* Address field Routing value. */
-#define BCM43xx_DMA32_ROUTING			0xC0000000
-#define BCM43xx_DMA32_ROUTING_SHIFT		30
-#define		BCM43xx_DMA32_NOTRANS		0x00000000
-#define		BCM43xx_DMA32_CLIENTTRANS	0x40000000
-
-
-
-/*** 64-bit DMA Engine. ***/
-
-/* 64-bit DMA controller registers. */
-#define BCM43xx_DMA64_TXCTL				0x00
-#define		BCM43xx_DMA64_TXENABLE			0x00000001
-#define		BCM43xx_DMA64_TXSUSPEND			0x00000002
-#define		BCM43xx_DMA64_TXLOOPBACK		0x00000004
-#define		BCM43xx_DMA64_TXFLUSH			0x00000010
-#define		BCM43xx_DMA64_TXADDREXT_MASK		0x00030000
-#define		BCM43xx_DMA64_TXADDREXT_SHIFT		16
-#define BCM43xx_DMA64_TXINDEX				0x04
-#define BCM43xx_DMA64_TXRINGLO				0x08
-#define BCM43xx_DMA64_TXRINGHI				0x0C
-#define BCM43xx_DMA64_TXSTATUS				0x10
-#define		BCM43xx_DMA64_TXSTATDPTR		0x00001FFF
-#define		BCM43xx_DMA64_TXSTAT			0xF0000000
-#define			BCM43xx_DMA64_TXSTAT_DISABLED	0x00000000
-#define			BCM43xx_DMA64_TXSTAT_ACTIVE	0x10000000
-#define			BCM43xx_DMA64_TXSTAT_IDLEWAIT	0x20000000
-#define			BCM43xx_DMA64_TXSTAT_STOPPED	0x30000000
-#define			BCM43xx_DMA64_TXSTAT_SUSP	0x40000000
-#define BCM43xx_DMA64_TXERROR				0x14
-#define		BCM43xx_DMA64_TXERRDPTR			0x0001FFFF
-#define		BCM43xx_DMA64_TXERR			0xF0000000
-#define			BCM43xx_DMA64_TXERR_NOERR	0x00000000
-#define			BCM43xx_DMA64_TXERR_PROT	0x10000000
-#define			BCM43xx_DMA64_TXERR_UNDERRUN	0x20000000
-#define			BCM43xx_DMA64_TXERR_TRANSFER	0x30000000
-#define			BCM43xx_DMA64_TXERR_DESCREAD	0x40000000
-#define			BCM43xx_DMA64_TXERR_CORE	0x50000000
-#define BCM43xx_DMA64_RXCTL				0x20
-#define		BCM43xx_DMA64_RXENABLE			0x00000001
-#define		BCM43xx_DMA64_RXFROFF_MASK		0x000000FE
-#define		BCM43xx_DMA64_RXFROFF_SHIFT		1
-#define		BCM43xx_DMA64_RXDIRECTFIFO		0x00000100
-#define		BCM43xx_DMA64_RXADDREXT_MASK		0x00030000
-#define		BCM43xx_DMA64_RXADDREXT_SHIFT		16
-#define BCM43xx_DMA64_RXINDEX				0x24
-#define BCM43xx_DMA64_RXRINGLO				0x28
-#define BCM43xx_DMA64_RXRINGHI				0x2C
-#define BCM43xx_DMA64_RXSTATUS				0x30
-#define		BCM43xx_DMA64_RXSTATDPTR		0x00001FFF
-#define		BCM43xx_DMA64_RXSTAT			0xF0000000
-#define			BCM43xx_DMA64_RXSTAT_DISABLED	0x00000000
-#define			BCM43xx_DMA64_RXSTAT_ACTIVE	0x10000000
-#define			BCM43xx_DMA64_RXSTAT_IDLEWAIT	0x20000000
-#define			BCM43xx_DMA64_RXSTAT_STOPPED	0x30000000
-#define			BCM43xx_DMA64_RXSTAT_SUSP	0x40000000
-#define BCM43xx_DMA64_RXERROR				0x34
-#define		BCM43xx_DMA64_RXERRDPTR			0x0001FFFF
-#define		BCM43xx_DMA64_RXERR			0xF0000000
-#define			BCM43xx_DMA64_RXERR_NOERR	0x00000000
-#define			BCM43xx_DMA64_RXERR_PROT	0x10000000
-#define			BCM43xx_DMA64_RXERR_UNDERRUN	0x20000000
-#define			BCM43xx_DMA64_RXERR_TRANSFER	0x30000000
-#define			BCM43xx_DMA64_RXERR_DESCREAD	0x40000000
-#define			BCM43xx_DMA64_RXERR_CORE	0x50000000
-
-/* 64-bit DMA descriptor. */
-struct bcm43xx_dmadesc64 {
-	__le32 control0;
-	__le32 control1;
-	__le32 address_low;
-	__le32 address_high;
-} __attribute__((__packed__));
-#define BCM43xx_DMA64_DCTL0_DTABLEEND		0x10000000
-#define BCM43xx_DMA64_DCTL0_IRQ			0x20000000
-#define BCM43xx_DMA64_DCTL0_FRAMEEND		0x40000000
-#define BCM43xx_DMA64_DCTL0_FRAMESTART		0x80000000
-#define BCM43xx_DMA64_DCTL1_BYTECNT		0x00001FFF
-#define BCM43xx_DMA64_DCTL1_ADDREXT_MASK	0x00030000
-#define BCM43xx_DMA64_DCTL1_ADDREXT_SHIFT	16
-
-/* Address field Routing value. */
-#define BCM43xx_DMA64_ROUTING			0xC0000000
-#define BCM43xx_DMA64_ROUTING_SHIFT		30
-#define		BCM43xx_DMA64_NOTRANS		0x00000000
-#define		BCM43xx_DMA64_CLIENTTRANS	0x80000000
-
-
-
-struct bcm43xx_dmadesc_generic {
-	union {
-		struct bcm43xx_dmadesc32 dma32;
-		struct bcm43xx_dmadesc64 dma64;
-	} __attribute__((__packed__));
-} __attribute__((__packed__));
-
-
-/* Misc DMA constants */
-#define BCM43xx_DMA_RINGMEMSIZE		PAGE_SIZE
-#define BCM43xx_DMA0_RX_FRAMEOFFSET	30
-#define BCM43xx_DMA3_RX_FRAMEOFFSET	0
-
-
-/* DMA engine tuning knobs */
-#define BCM43xx_TXRING_SLOTS		512
-#define BCM43xx_RXRING_SLOTS		64
-#define BCM43xx_DMA0_RX_BUFFERSIZE	(2304 + 100)
-#define BCM43xx_DMA3_RX_BUFFERSIZE	16
-/* Suspend the tx queue, if less than this percent slots are free. */
-#define BCM43xx_TXSUSPEND_PERCENT	20
-/* Resume the tx queue, if more than this percent slots are free. */
-#define BCM43xx_TXRESUME_PERCENT	50
-
-
-
-#ifdef CONFIG_BCM43XX_DMA
-
-
-struct sk_buff;
-struct bcm43xx_private;
-struct bcm43xx_xmitstatus;
-
-
-struct bcm43xx_dmadesc_meta {
-	/* The kernel DMA-able buffer. */
-	struct sk_buff *skb;
-	/* DMA base bus-address of the descriptor buffer. */
-	dma_addr_t dmaaddr;
-};
-
-struct bcm43xx_dmaring {
-	/* Kernel virtual base address of the ring memory. */
-	void *descbase;
-	/* Meta data about all descriptors. */
-	struct bcm43xx_dmadesc_meta *meta;
-	/* DMA Routing value. */
-	u32 routing;
-	/* (Unadjusted) DMA base bus-address of the ring memory. */
-	dma_addr_t dmabase;
-	/* Number of descriptor slots in the ring. */
-	int nr_slots;
-	/* Number of used descriptor slots. */
-	int used_slots;
-	/* Currently used slot in the ring. */
-	int current_slot;
-	/* Marks to suspend/resume the queue. */
-	int suspend_mark;
-	int resume_mark;
-	/* Frameoffset in octets. */
-	u32 frameoffset;
-	/* Descriptor buffer size. */
-	u16 rx_buffersize;
-	/* The MMIO base register of the DMA controller. */
-	u16 mmio_base;
-	/* DMA controller index number (0-5). */
-	int index;
-	/* Boolean. Is this a TX ring? */
-	u8 tx;
-	/* Boolean. 64bit DMA if true, 32bit DMA otherwise. */
-	u8 dma64;
-	/* Boolean. Are transfers suspended on this ring? */
-	u8 suspended;
-	struct bcm43xx_private *bcm;
-#ifdef CONFIG_BCM43XX_DEBUG
-	/* Maximum number of used slots. */
-	int max_used_slots;
-#endif /* CONFIG_BCM43XX_DEBUG*/
-};
-
-
-static inline
-int bcm43xx_dma_desc2idx(struct bcm43xx_dmaring *ring,
-			 struct bcm43xx_dmadesc_generic *desc)
-{
-	if (ring-&gt;dma64) {
-		struct bcm43xx_dmadesc64 *dd64 = ring-&gt;descbase;
-		return (int)(&amp;(desc-&gt;dma64) - dd64);
-	} else {
-		struct bcm43xx_dmadesc32 *dd32 = ring-&gt;descbase;
-		return (int)(&amp;(desc-&gt;dma32) - dd32);
-	}
-}
-
-static inline
-struct bcm43xx_dmadesc_generic * bcm43xx_dma_idx2desc(struct bcm43xx_dmaring *ring,
-						      int slot,
-						      struct bcm43xx_dmadesc_meta **meta)
-{
-	*meta = &amp;(ring-&gt;meta[slot]);
-	if (ring-&gt;dma64) {
-		struct bcm43xx_dmadesc64 *dd64 = ring-&gt;descbase;
-		return (struct bcm43xx_dmadesc_generic *)(&amp;(dd64[slot]));
-	} else {
-		struct bcm43xx_dmadesc32 *dd32 = ring-&gt;descbase;
-		return (struct bcm43xx_dmadesc_generic *)(&amp;(dd32[slot]));
-	}
-}
-
-static inline
-u32 bcm43xx_dma_read(struct bcm43xx_dmaring *ring,
-		     u16 offset)
-{
-	return bcm43xx_read32(ring-&gt;bcm, ring-&gt;mmio_base + offset);
-}
-
-static inline
-void bcm43xx_dma_write(struct bcm43xx_dmaring *ring,
-		       u16 offset, u32 value)
-{
-	bcm43xx_write32(ring-&gt;bcm, ring-&gt;mmio_base + offset, value);
-}
-
-
-int bcm43xx_dma_init(struct bcm43xx_private *bcm);
-void bcm43xx_dma_free(struct bcm43xx_private *bcm);
-
-int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_private *bcm,
-				   u16 dmacontroller_mmio_base,
-				   int dma64);
-int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_private *bcm,
-				   u16 dmacontroller_mmio_base,
-				   int dma64);
-
-u16 bcm43xx_dmacontroller_base(int dma64bit, int dmacontroller_idx);
-
-void bcm43xx_dma_tx_suspend(struct bcm43xx_dmaring *ring);
-void bcm43xx_dma_tx_resume(struct bcm43xx_dmaring *ring);
-
-void bcm43xx_dma_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status);
-
-int bcm43xx_dma_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb);
-void bcm43xx_dma_rx(struct bcm43xx_dmaring *ring);
-
-/* Helper function that returns the dma mask for this device. */
-static inline
-u64 bcm43xx_get_supported_dma_mask(struct bcm43xx_private *bcm)
-{
-	int dma64 = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH) &amp;
-				   BCM43xx_SBTMSTATEHIGH_DMA64BIT;
-	u16 mmio_base = bcm43xx_dmacontroller_base(dma64, 0);
-	u32 mask = BCM43xx_DMA32_TXADDREXT_MASK;
-
-	if (dma64)
-		return DMA_64BIT_MASK;
-	bcm43xx_write32(bcm, mmio_base + BCM43xx_DMA32_TXCTL, mask);
-	if (bcm43xx_read32(bcm, mmio_base + BCM43xx_DMA32_TXCTL) &amp; mask)
-		return DMA_32BIT_MASK;
-	return DMA_30BIT_MASK;
-}
-
-#else /* CONFIG_BCM43XX_DMA */
-
-
-static inline
-int bcm43xx_dma_init(struct bcm43xx_private *bcm)
-{
-	return 0;
-}
-static inline
-void bcm43xx_dma_free(struct bcm43xx_private *bcm)
-{
-}
-static inline
-int bcm43xx_dmacontroller_rx_reset(struct bcm43xx_private *bcm,
-				   u16 dmacontroller_mmio_base,
-				   int dma64)
-{
-	return 0;
-}
-static inline
-int bcm43xx_dmacontroller_tx_reset(struct bcm43xx_private *bcm,
-				   u16 dmacontroller_mmio_base,
-				   int dma64)
-{
-	return 0;
-}
-static inline
-int bcm43xx_dma_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
-{
-	return 0;
-}
-static inline
-void bcm43xx_dma_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
-{
-}
-static inline
-void bcm43xx_dma_rx(struct bcm43xx_dmaring *ring)
-{
-}
-static inline
-void bcm43xx_dma_tx_suspend(struct bcm43xx_dmaring *ring)
-{
-}
-static inline
-void bcm43xx_dma_tx_resume(struct bcm43xx_dmaring *ring)
-{
-}
-
-#endif /* CONFIG_BCM43XX_DMA */
-#endif /* BCM43xx_DMA_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ethtool.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_ethtool.c
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  ethtool support
-
-  Copyright (c) 2006 Jason Lunz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">lunz at falooley.org</A>&gt;
-
-  Some code in this file is derived from the 8139too.c driver
-  Copyright (C) 2002 Jeff Garzik
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &quot;bcm43xx.h&quot;
-#include &quot;bcm43xx_ethtool.h&quot;
-
-#include &lt;linux/netdevice.h&gt;
-#include &lt;linux/pci.h&gt;
-#include &lt;linux/string.h&gt;
-#include &lt;linux/utsname.h&gt;
-
-
-static void bcm43xx_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(dev);
-
-	strncpy(info-&gt;driver, KBUILD_MODNAME, sizeof(info-&gt;driver));
-	strncpy(info-&gt;version, utsname()-&gt;release, sizeof(info-&gt;version));
-	strncpy(info-&gt;bus_info, pci_name(bcm-&gt;pci_dev), ETHTOOL_BUSINFO_LEN);
-}
-
-const struct ethtool_ops bcm43xx_ethtool_ops = {
-	.get_drvinfo = bcm43xx_get_drvinfo,
-	.get_link = ethtool_op_get_link,
-};
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ethtool.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_ethtool.h
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef BCM43xx_ETHTOOL_H_
-#define BCM43xx_ETHTOOL_H_
-
-#include &lt;linux/ethtool.h&gt;
-
-extern const struct ethtool_ops bcm43xx_ethtool_ops;
-
-#endif /* BCM43xx_ETHTOOL_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ilt.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_ilt.c
+++ /dev/null
@@ -1,352 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &quot;bcm43xx.h&quot;
-#include &quot;bcm43xx_ilt.h&quot;
-#include &quot;bcm43xx_phy.h&quot;
-
-
-/**** Initial Internal Lookup Tables ****/
-
-const u32 bcm43xx_ilt_rotor[BCM43xx_ILT_ROTOR_SIZE] = {
-	0xFEB93FFD, 0xFEC63FFD, /* 0 */
-	0xFED23FFD, 0xFEDF3FFD,
-	0xFEEC3FFE, 0xFEF83FFE,
-	0xFF053FFE, 0xFF113FFE,
-	0xFF1E3FFE, 0xFF2A3FFF, /* 8 */
-	0xFF373FFF, 0xFF443FFF,
-	0xFF503FFF, 0xFF5D3FFF,
-	0xFF693FFF, 0xFF763FFF,
-	0xFF824000, 0xFF8F4000, /* 16 */
-	0xFF9B4000, 0xFFA84000,
-	0xFFB54000, 0xFFC14000,
-	0xFFCE4000, 0xFFDA4000,
-	0xFFE74000, 0xFFF34000, /* 24 */
-	0x00004000, 0x000D4000,
-	0x00194000, 0x00264000,
-	0x00324000, 0x003F4000,
-	0x004B4000, 0x00584000, /* 32 */
-	0x00654000, 0x00714000,
-	0x007E4000, 0x008A3FFF,
-	0x00973FFF, 0x00A33FFF,
-	0x00B03FFF, 0x00BC3FFF, /* 40 */
-	0x00C93FFF, 0x00D63FFF,
-	0x00E23FFE, 0x00EF3FFE,
-	0x00FB3FFE, 0x01083FFE,
-	0x01143FFE, 0x01213FFD, /* 48 */
-	0x012E3FFD, 0x013A3FFD,
-	0x01473FFD,
-};
-
-const u32 bcm43xx_ilt_retard[BCM43xx_ILT_RETARD_SIZE] = {
-	0xDB93CB87, 0xD666CF64, /* 0 */
-	0xD1FDD358, 0xCDA6D826,
-	0xCA38DD9F, 0xC729E2B4,
-	0xC469E88E, 0xC26AEE2B,
-	0xC0DEF46C, 0xC073FA62, /* 8 */
-	0xC01D00D5, 0xC0760743,
-	0xC1560D1E, 0xC2E51369,
-	0xC4ED18FF, 0xC7AC1ED7,
-	0xCB2823B2, 0xCEFA28D9, /* 16 */
-	0xD2F62D3F, 0xD7BB3197,
-	0xDCE53568, 0xE1FE3875,
-	0xE7D13B35, 0xED663D35,
-	0xF39B3EC4, 0xF98E3FA7, /* 24 */
-	0x00004000, 0x06723FA7,
-	0x0C653EC4, 0x129A3D35,
-	0x182F3B35, 0x1E023875,
-	0x231B3568, 0x28453197, /* 32 */
-	0x2D0A2D3F, 0x310628D9,
-	0x34D823B2, 0x38541ED7,
-	0x3B1318FF, 0x3D1B1369,
-	0x3EAA0D1E, 0x3F8A0743, /* 40 */
-	0x3FE300D5, 0x3F8DFA62,
-	0x3F22F46C, 0x3D96EE2B,
-	0x3B97E88E, 0x38D7E2B4,
-	0x35C8DD9F, 0x325AD826, /* 48 */
-	0x2E03D358, 0x299ACF64,
-	0x246DCB87,
-};
-
-const u16 bcm43xx_ilt_finefreqa[BCM43xx_ILT_FINEFREQA_SIZE] = {
-	0x0082, 0x0082, 0x0102, 0x0182, /* 0 */
- 	0x0202, 0x0282, 0x0302, 0x0382,
- 	0x0402, 0x0482, 0x0502, 0x0582,
- 	0x05E2, 0x0662, 0x06E2, 0x0762,
- 	0x07E2, 0x0842, 0x08C2, 0x0942, /* 16 */
- 	0x09C2, 0x0A22, 0x0AA2, 0x0B02,
- 	0x0B82, 0x0BE2, 0x0C62, 0x0CC2,
- 	0x0D42, 0x0DA2, 0x0E02, 0x0E62,
- 	0x0EE2, 0x0F42, 0x0FA2, 0x1002, /* 32 */
- 	0x1062, 0x10C2, 0x1122, 0x1182,
- 	0x11E2, 0x1242, 0x12A2, 0x12E2,
- 	0x1342, 0x13A2, 0x1402, 0x1442,
- 	0x14A2, 0x14E2, 0x1542, 0x1582, /* 48 */
- 	0x15E2, 0x1622, 0x1662, 0x16C1,
- 	0x1701, 0x1741, 0x1781, 0x17E1,
- 	0x1821, 0x1861, 0x18A1, 0x18E1,
- 	0x1921, 0x1961, 0x19A1, 0x19E1, /* 64 */
- 	0x1A21, 0x1A61, 0x1AA1, 0x1AC1,
- 	0x1B01, 0x1B41, 0x1B81, 0x1BA1,
- 	0x1BE1, 0x1C21, 0x1C41, 0x1C81,
- 	0x1CA1, 0x1CE1, 0x1D01, 0x1D41, /* 80 */
- 	0x1D61, 0x1DA1, 0x1DC1, 0x1E01,
- 	0x1E21, 0x1E61, 0x1E81, 0x1EA1,
- 	0x1EE1, 0x1F01, 0x1F21, 0x1F41,
- 	0x1F81, 0x1FA1, 0x1FC1, 0x1FE1, /* 96 */
- 	0x2001, 0x2041, 0x2061, 0x2081,
- 	0x20A1, 0x20C1, 0x20E1, 0x2101,
- 	0x2121, 0x2141, 0x2161, 0x2181,
- 	0x21A1, 0x21C1, 0x21E1, 0x2201, /* 112 */
- 	0x2221, 0x2241, 0x2261, 0x2281,
- 	0x22A1, 0x22C1, 0x22C1, 0x22E1,
- 	0x2301, 0x2321, 0x2341, 0x2361,
- 	0x2361, 0x2381, 0x23A1, 0x23C1, /* 128 */
- 	0x23E1, 0x23E1, 0x2401, 0x2421,
- 	0x2441, 0x2441, 0x2461, 0x2481,
- 	0x2481, 0x24A1, 0x24C1, 0x24C1,
- 	0x24E1, 0x2501, 0x2501, 0x2521, /* 144 */
- 	0x2541, 0x2541, 0x2561, 0x2561,
- 	0x2581, 0x25A1, 0x25A1, 0x25C1,
- 	0x25C1, 0x25E1, 0x2601, 0x2601,
- 	0x2621, 0x2621, 0x2641, 0x2641, /* 160 */
- 	0x2661, 0x2661, 0x2681, 0x2681,
- 	0x26A1, 0x26A1, 0x26C1, 0x26C1,
- 	0x26E1, 0x26E1, 0x2701, 0x2701,
- 	0x2721, 0x2721, 0x2740, 0x2740, /* 176 */
- 	0x2760, 0x2760, 0x2780, 0x2780,
- 	0x2780, 0x27A0, 0x27A0, 0x27C0,
- 	0x27C0, 0x27E0, 0x27E0, 0x27E0,
- 	0x2800, 0x2800, 0x2820, 0x2820, /* 192 */
- 	0x2820, 0x2840, 0x2840, 0x2840,
- 	0x2860, 0x2860, 0x2880, 0x2880,
- 	0x2880, 0x28A0, 0x28A0, 0x28A0,
- 	0x28C0, 0x28C0, 0x28C0, 0x28E0, /* 208 */
- 	0x28E0, 0x28E0, 0x2900, 0x2900,
- 	0x2900, 0x2920, 0x2920, 0x2920,
- 	0x2940, 0x2940, 0x2940, 0x2960,
- 	0x2960, 0x2960, 0x2960, 0x2980, /* 224 */
- 	0x2980, 0x2980, 0x29A0, 0x29A0,
- 	0x29A0, 0x29A0, 0x29C0, 0x29C0,
- 	0x29C0, 0x29E0, 0x29E0, 0x29E0,
- 	0x29E0, 0x2A00, 0x2A00, 0x2A00, /* 240 */
- 	0x2A00, 0x2A20, 0x2A20, 0x2A20,
- 	0x2A20, 0x2A40, 0x2A40, 0x2A40,
- 	0x2A40, 0x2A60, 0x2A60, 0x2A60,
-};
-
-const u16 bcm43xx_ilt_finefreqg[BCM43xx_ILT_FINEFREQG_SIZE] = {
-	0x0089, 0x02E9, 0x0409, 0x04E9, /* 0 */
-	0x05A9, 0x0669, 0x0709, 0x0789,
-	0x0829, 0x08A9, 0x0929, 0x0989,
-	0x0A09, 0x0A69, 0x0AC9, 0x0B29,
-	0x0BA9, 0x0BE9, 0x0C49, 0x0CA9, /* 16 */
-	0x0D09, 0x0D69, 0x0DA9, 0x0E09,
-	0x0E69, 0x0EA9, 0x0F09, 0x0F49,
-	0x0FA9, 0x0FE9, 0x1029, 0x1089,
-	0x10C9, 0x1109, 0x1169, 0x11A9, /* 32 */
-	0x11E9, 0x1229, 0x1289, 0x12C9,
-	0x1309, 0x1349, 0x1389, 0x13C9,
-	0x1409, 0x1449, 0x14A9, 0x14E9,
-	0x1529, 0x1569, 0x15A9, 0x15E9, /* 48 */
-	0x1629, 0x1669, 0x16A9, 0x16E8,
-	0x1728, 0x1768, 0x17A8, 0x17E8,
-	0x1828, 0x1868, 0x18A8, 0x18E8,
-	0x1928, 0x1968, 0x19A8, 0x19E8, /* 64 */
-	0x1A28, 0x1A68, 0x1AA8, 0x1AE8,
-	0x1B28, 0x1B68, 0x1BA8, 0x1BE8,
-	0x1C28, 0x1C68, 0x1CA8, 0x1CE8,
-	0x1D28, 0x1D68, 0x1DC8, 0x1E08, /* 80 */
-	0x1E48, 0x1E88, 0x1EC8, 0x1F08,
-	0x1F48, 0x1F88, 0x1FE8, 0x2028,
-	0x2068, 0x20A8, 0x2108, 0x2148,
-	0x2188, 0x21C8, 0x2228, 0x2268, /* 96 */
-	0x22C8, 0x2308, 0x2348, 0x23A8,
-	0x23E8, 0x2448, 0x24A8, 0x24E8,
-	0x2548, 0x25A8, 0x2608, 0x2668,
-	0x26C8, 0x2728, 0x2787, 0x27E7, /* 112 */
-	0x2847, 0x28C7, 0x2947, 0x29A7,
-	0x2A27, 0x2AC7, 0x2B47, 0x2BE7,
-	0x2CA7, 0x2D67, 0x2E47, 0x2F67,
-	0x3247, 0x3526, 0x3646, 0x3726, /* 128 */
-	0x3806, 0x38A6, 0x3946, 0x39E6,
-	0x3A66, 0x3AE6, 0x3B66, 0x3BC6,
-	0x3C45, 0x3CA5, 0x3D05, 0x3D85,
-	0x3DE5, 0x3E45, 0x3EA5, 0x3EE5, /* 144 */
-	0x3F45, 0x3FA5, 0x4005, 0x4045,
-	0x40A5, 0x40E5, 0x4145, 0x4185,
-	0x41E5, 0x4225, 0x4265, 0x42C5,
-	0x4305, 0x4345, 0x43A5, 0x43E5, /* 160 */
-	0x4424, 0x4464, 0x44C4, 0x4504,
-	0x4544, 0x4584, 0x45C4, 0x4604,
-	0x4644, 0x46A4, 0x46E4, 0x4724,
-	0x4764, 0x47A4, 0x47E4, 0x4824, /* 176 */
-	0x4864, 0x48A4, 0x48E4, 0x4924,
-	0x4964, 0x49A4, 0x49E4, 0x4A24,
-	0x4A64, 0x4AA4, 0x4AE4, 0x4B23,
-	0x4B63, 0x4BA3, 0x4BE3, 0x4C23, /* 192 */
-	0x4C63, 0x4CA3, 0x4CE3, 0x4D23,
-	0x4D63, 0x4DA3, 0x4DE3, 0x4E23,
-	0x4E63, 0x4EA3, 0x4EE3, 0x4F23,
-	0x4F63, 0x4FC3, 0x5003, 0x5043, /* 208 */
-	0x5083, 0x50C3, 0x5103, 0x5143,
-	0x5183, 0x51E2, 0x5222, 0x5262,
-	0x52A2, 0x52E2, 0x5342, 0x5382,
-	0x53C2, 0x5402, 0x5462, 0x54A2, /* 224 */
-	0x5502, 0x5542, 0x55A2, 0x55E2,
-	0x5642, 0x5682, 0x56E2, 0x5722,
-	0x5782, 0x57E1, 0x5841, 0x58A1,
-	0x5901, 0x5961, 0x59C1, 0x5A21, /* 240 */
-	0x5AA1, 0x5B01, 0x5B81, 0x5BE1,
-	0x5C61, 0x5D01, 0x5D80, 0x5E20,
-	0x5EE0, 0x5FA0, 0x6080, 0x61C0,
-};
-
-const u16 bcm43xx_ilt_noisea2[BCM43xx_ILT_NOISEA2_SIZE] = {
-	0x0001, 0x0001, 0x0001, 0xFFFE,
-	0xFFFE, 0x3FFF, 0x1000, 0x0393,
-};
-
-const u16 bcm43xx_ilt_noisea3[BCM43xx_ILT_NOISEA3_SIZE] = {
-	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
-	0x4C4C, 0x4C4C, 0x4C4C, 0x2D36,
-};
-
-const u16 bcm43xx_ilt_noiseg1[BCM43xx_ILT_NOISEG1_SIZE] = {
-	0x013C, 0x01F5, 0x031A, 0x0631,
-	0x0001, 0x0001, 0x0001, 0x0001,
-};
-
-const u16 bcm43xx_ilt_noiseg2[BCM43xx_ILT_NOISEG2_SIZE] = {
-	0x5484, 0x3C40, 0x0000, 0x0000,
-	0x0000, 0x0000, 0x0000, 0x0000,
-};
-
-const u16 bcm43xx_ilt_noisescaleg1[BCM43xx_ILT_NOISESCALEG_SIZE] = {
-	0x6C77, 0x5162, 0x3B40, 0x3335, /* 0 */
-	0x2F2D, 0x2A2A, 0x2527, 0x1F21,
-	0x1A1D, 0x1719, 0x1616, 0x1414,
-	0x1414, 0x1400, 0x1414, 0x1614,
-	0x1716, 0x1A19, 0x1F1D, 0x2521, /* 16 */
-	0x2A27, 0x2F2A, 0x332D, 0x3B35,
-	0x5140, 0x6C62, 0x0077,
-};
-
-const u16 bcm43xx_ilt_noisescaleg2[BCM43xx_ILT_NOISESCALEG_SIZE] = {
-	0xD8DD, 0xCBD4, 0xBCC0, 0XB6B7, /* 0 */
-	0xB2B0, 0xADAD, 0xA7A9, 0x9FA1,
-	0x969B, 0x9195, 0x8F8F, 0x8A8A,
-	0x8A8A, 0x8A00, 0x8A8A, 0x8F8A,
-	0x918F, 0x9695, 0x9F9B, 0xA7A1, /* 16 */
-	0xADA9, 0xB2AD, 0xB6B0, 0xBCB7,
-	0xCBC0, 0xD8D4, 0x00DD,
-};
-
-const u16 bcm43xx_ilt_noisescaleg3[BCM43xx_ILT_NOISESCALEG_SIZE] = {
-	0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4, /* 0 */
-	0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4,
-	0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4,
-	0xA4A4, 0xA400, 0xA4A4, 0xA4A4,
-	0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4, /* 16 */
-	0xA4A4, 0xA4A4, 0xA4A4, 0xA4A4,
-	0xA4A4, 0xA4A4, 0x00A4,
-};
-
-const u16 bcm43xx_ilt_sigmasqr1[BCM43xx_ILT_SIGMASQR_SIZE] = {
-	0x007A, 0x0075, 0x0071, 0x006C, /* 0 */
-	0x0067, 0x0063, 0x005E, 0x0059,
-	0x0054, 0x0050, 0x004B, 0x0046,
-	0x0042, 0x003D, 0x003D, 0x003D,
-	0x003D, 0x003D, 0x003D, 0x003D, /* 16 */
-	0x003D, 0x003D, 0x003D, 0x003D,
-	0x003D, 0x003D, 0x0000, 0x003D,
-	0x003D, 0x003D, 0x003D, 0x003D,
-	0x003D, 0x003D, 0x003D, 0x003D, /* 32 */
-	0x003D, 0x003D, 0x003D, 0x003D,
-	0x0042, 0x0046, 0x004B, 0x0050,
-	0x0054, 0x0059, 0x005E, 0x0063,
-	0x0067, 0x006C, 0x0071, 0x0075, /* 48 */
-	0x007A,
-};
-
-const u16 bcm43xx_ilt_sigmasqr2[BCM43xx_ILT_SIGMASQR_SIZE] = {
-	0x00DE, 0x00DC, 0x00DA, 0x00D8, /* 0 */
-	0x00D6, 0x00D4, 0x00D2, 0x00CF,
-	0x00CD, 0x00CA, 0x00C7, 0x00C4,
-	0x00C1, 0x00BE, 0x00BE, 0x00BE,
-	0x00BE, 0x00BE, 0x00BE, 0x00BE, /* 16 */
-	0x00BE, 0x00BE, 0x00BE, 0x00BE,
-	0x00BE, 0x00BE, 0x0000, 0x00BE,
-	0x00BE, 0x00BE, 0x00BE, 0x00BE,
-	0x00BE, 0x00BE, 0x00BE, 0x00BE, /* 32 */
-	0x00BE, 0x00BE, 0x00BE, 0x00BE,
-	0x00C1, 0x00C4, 0x00C7, 0x00CA,
-	0x00CD, 0x00CF, 0x00D2, 0x00D4,
-	0x00D6, 0x00D8, 0x00DA, 0x00DC, /* 48 */
-	0x00DE,
-};
-
-/**** Helper functions to access the device Internal Lookup Tables ****/
-
-void bcm43xx_ilt_write(struct bcm43xx_private *bcm, u16 offset, u16 val)
-{
-	if (bcm43xx_current_phy(bcm)-&gt;type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, val);
-	} else {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_DATA1, val);
-	}
-}
-
-void bcm43xx_ilt_write32(struct bcm43xx_private *bcm, u16 offset, u32 val)
-{
-	if (bcm43xx_current_phy(bcm)-&gt;type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA2, (val &amp; 0xFFFF0000) &gt;&gt; 16);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, val &amp; 0x0000FFFF);
-	} else {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_CTRL, offset);
-		mmiowb();
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_DATA2, (val &amp; 0xFFFF0000) &gt;&gt; 16);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_DATA1, val &amp; 0x0000FFFF);
-	}
-}
-
-u16 bcm43xx_ilt_read(struct bcm43xx_private *bcm, u16 offset)
-{
-	if (bcm43xx_current_phy(bcm)-&gt;type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, offset);
-		return bcm43xx_phy_read(bcm, BCM43xx_PHY_ILT_A_DATA1);
-	} else {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_G_CTRL, offset);
-		return bcm43xx_phy_read(bcm, BCM43xx_PHY_ILT_G_DATA1);
-	}
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_ilt.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_ilt.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#ifndef BCM43xx_ILT_H_
-#define BCM43xx_ILT_H_
-
-#define BCM43xx_ILT_ROTOR_SIZE		53
-extern const u32 bcm43xx_ilt_rotor[BCM43xx_ILT_ROTOR_SIZE];
-#define BCM43xx_ILT_RETARD_SIZE		53
-extern const u32 bcm43xx_ilt_retard[BCM43xx_ILT_RETARD_SIZE];
-#define BCM43xx_ILT_FINEFREQA_SIZE	256
-extern const u16 bcm43xx_ilt_finefreqa[BCM43xx_ILT_FINEFREQA_SIZE];
-#define BCM43xx_ILT_FINEFREQG_SIZE	256
-extern const u16 bcm43xx_ilt_finefreqg[BCM43xx_ILT_FINEFREQG_SIZE];
-#define BCM43xx_ILT_NOISEA2_SIZE	8
-extern const u16 bcm43xx_ilt_noisea2[BCM43xx_ILT_NOISEA2_SIZE];
-#define BCM43xx_ILT_NOISEA3_SIZE	8
-extern const u16 bcm43xx_ilt_noisea3[BCM43xx_ILT_NOISEA3_SIZE];
-#define BCM43xx_ILT_NOISEG1_SIZE	8
-extern const u16 bcm43xx_ilt_noiseg1[BCM43xx_ILT_NOISEG1_SIZE];
-#define BCM43xx_ILT_NOISEG2_SIZE	8
-extern const u16 bcm43xx_ilt_noiseg2[BCM43xx_ILT_NOISEG2_SIZE];
-#define BCM43xx_ILT_NOISESCALEG_SIZE	27
-extern const u16 bcm43xx_ilt_noisescaleg1[BCM43xx_ILT_NOISESCALEG_SIZE];
-extern const u16 bcm43xx_ilt_noisescaleg2[BCM43xx_ILT_NOISESCALEG_SIZE];
-extern const u16 bcm43xx_ilt_noisescaleg3[BCM43xx_ILT_NOISESCALEG_SIZE];
-#define BCM43xx_ILT_SIGMASQR_SIZE	53
-extern const u16 bcm43xx_ilt_sigmasqr1[BCM43xx_ILT_SIGMASQR_SIZE];
-extern const u16 bcm43xx_ilt_sigmasqr2[BCM43xx_ILT_SIGMASQR_SIZE];
-
-
-void bcm43xx_ilt_write(struct bcm43xx_private *bcm, u16 offset, u16 val);
-void bcm43xx_ilt_write32(struct bcm43xx_private *bcm, u16 offset, u32 val);
-u16 bcm43xx_ilt_read(struct bcm43xx_private *bcm, u16 offset);
-
-#endif /* BCM43xx_ILT_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_leds.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_leds.c
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &quot;bcm43xx_leds.h&quot;
-#include &quot;bcm43xx_radio.h&quot;
-#include &quot;bcm43xx.h&quot;
-
-#include &lt;linux/bitops.h&gt;
-
-
-static void bcm43xx_led_changestate(struct bcm43xx_led *led)
-{
-	struct bcm43xx_private *bcm = led-&gt;bcm;
-	const int index = bcm43xx_led_index(led);
-	const u16 mask = (1 &lt;&lt; index);
-	u16 ledctl;
-
-	assert(index &gt;= 0 &amp;&amp; index &lt; BCM43xx_NR_LEDS);
-	assert(led-&gt;blink_interval);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
-	ledctl = (ledctl &amp; mask) ? (ledctl &amp; ~mask) : (ledctl | mask);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
-}
-
-static void bcm43xx_led_blink(unsigned long d)
-{
-	struct bcm43xx_led *led = (struct bcm43xx_led *)d;
-	struct bcm43xx_private *bcm = led-&gt;bcm;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;bcm-&gt;leds_lock, flags);
-	if (led-&gt;blink_interval) {
-		bcm43xx_led_changestate(led);
-		mod_timer(&amp;led-&gt;blink_timer, jiffies + led-&gt;blink_interval);
-	}
-	spin_unlock_irqrestore(&amp;bcm-&gt;leds_lock, flags);
-}
-
-static void bcm43xx_led_blink_start(struct bcm43xx_led *led,
-				    unsigned long interval)
-{
-	if (led-&gt;blink_interval)
-		return;
-	led-&gt;blink_interval = interval;
-	bcm43xx_led_changestate(led);
-	led-&gt;blink_timer.expires = jiffies + interval;
-	add_timer(&amp;led-&gt;blink_timer);
-}
-
-static void bcm43xx_led_blink_stop(struct bcm43xx_led *led, int sync)
-{
-	struct bcm43xx_private *bcm = led-&gt;bcm;
-	const int index = bcm43xx_led_index(led);
-	u16 ledctl;
-
-	if (!led-&gt;blink_interval)
-		return;
-	if (unlikely(sync))
-		del_timer_sync(&amp;led-&gt;blink_timer);
-	else
-		del_timer(&amp;led-&gt;blink_timer);
-	led-&gt;blink_interval = 0;
-
-	/* Make sure the LED is turned off. */
-	assert(index &gt;= 0 &amp;&amp; index &lt; BCM43xx_NR_LEDS);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
-	if (led-&gt;activelow)
-		ledctl |= (1 &lt;&lt; index);
-	else
-		ledctl &amp;= ~(1 &lt;&lt; index);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
-}
-
-static void bcm43xx_led_init_hardcoded(struct bcm43xx_private *bcm,
-				       struct bcm43xx_led *led,
-				       int led_index)
-{
-	/* This function is called, if the behaviour (and activelow)
-	 * information for a LED is missing in the SPROM.
-	 * We hardcode the behaviour values for various devices here.
-	 * Note that the BCM43xx_LED_TEST_XXX behaviour values can
-	 * be used to figure out which led is mapped to which index.
-	 */
-
-	switch (led_index) {
-	case 0:
-		led-&gt;behaviour = BCM43xx_LED_ACTIVITY;
-		led-&gt;activelow = 1;
-		if (bcm-&gt;board_vendor == PCI_VENDOR_ID_COMPAQ)
-			led-&gt;behaviour = BCM43xx_LED_RADIO_ALL;
-		break;
-	case 1:
-		led-&gt;behaviour = BCM43xx_LED_RADIO_B;
-		if (bcm-&gt;board_vendor == PCI_VENDOR_ID_ASUSTEK)
-			led-&gt;behaviour = BCM43xx_LED_ASSOC;
-		break;
-	case 2:
-		led-&gt;behaviour = BCM43xx_LED_RADIO_A;
-		break;
-	case 3:
-		led-&gt;behaviour = BCM43xx_LED_OFF;
-		break;
-	default:
-		assert(0);
-	}
-}
-
-int bcm43xx_leds_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_led *led;
-	u8 sprom[4];
-	int i;
-
-	sprom[0] = bcm-&gt;sprom.wl0gpio0;
-	sprom[1] = bcm-&gt;sprom.wl0gpio1;
-	sprom[2] = bcm-&gt;sprom.wl0gpio2;
-	sprom[3] = bcm-&gt;sprom.wl0gpio3;
-
-	for (i = 0; i &lt; BCM43xx_NR_LEDS; i++) {
-		led = &amp;(bcm-&gt;leds[i]);
-		led-&gt;bcm = bcm;
-		setup_timer(&amp;led-&gt;blink_timer,
-			    bcm43xx_led_blink,
-			    (unsigned long)led);
-
-		if (sprom[i] == 0xFF) {
-			bcm43xx_led_init_hardcoded(bcm, led, i);
-		} else {
-			led-&gt;behaviour = sprom[i] &amp; BCM43xx_LED_BEHAVIOUR;
-			led-&gt;activelow = !!(sprom[i] &amp; BCM43xx_LED_ACTIVELOW);
-		}
-	}
-
-	return 0;
-}
-
-void bcm43xx_leds_exit(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_led *led;
-	int i;
-
-	for (i = 0; i &lt; BCM43xx_NR_LEDS; i++) {
-		led = &amp;(bcm-&gt;leds[i]);
-		bcm43xx_led_blink_stop(led, 1);
-	}
-	bcm43xx_leds_switch_all(bcm, 0);
-}
-
-void bcm43xx_leds_update(struct bcm43xx_private *bcm, int activity)
-{
-	struct bcm43xx_led *led;
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	const int transferring = (jiffies - bcm-&gt;stats.last_tx) &lt; BCM43xx_LED_XFER_THRES;
-	int i, turn_on;
-	unsigned long interval = 0;
-	u16 ledctl;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;bcm-&gt;leds_lock, flags);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
-	for (i = 0; i &lt; BCM43xx_NR_LEDS; i++) {
-		led = &amp;(bcm-&gt;leds[i]);
-
-		turn_on = 0;
-		switch (led-&gt;behaviour) {
-		case BCM43xx_LED_INACTIVE:
-			continue;
-		case BCM43xx_LED_OFF:
-		case BCM43xx_LED_BCM4303_3:
-			break;
-		case BCM43xx_LED_ON:
-			turn_on = 1;
-			break;
-		case BCM43xx_LED_ACTIVITY:
-		case BCM43xx_LED_BCM4303_0:
-			turn_on = activity;
-			break;
-		case BCM43xx_LED_RADIO_ALL:
-			turn_on = radio-&gt;enabled &amp;&amp; bcm43xx_is_hw_radio_enabled(bcm);
-			break;
-		case BCM43xx_LED_RADIO_A:
-		case BCM43xx_LED_BCM4303_2:
-			turn_on = (radio-&gt;enabled &amp;&amp; bcm43xx_is_hw_radio_enabled(bcm) &amp;&amp;
-				   phy-&gt;type == BCM43xx_PHYTYPE_A);
-			break;
-		case BCM43xx_LED_RADIO_B:
-		case BCM43xx_LED_BCM4303_1:
-			turn_on = (radio-&gt;enabled &amp;&amp; bcm43xx_is_hw_radio_enabled(bcm) &amp;&amp;
-				   (phy-&gt;type == BCM43xx_PHYTYPE_B ||
-				    phy-&gt;type == BCM43xx_PHYTYPE_G));
-			break;
-		case BCM43xx_LED_MODE_BG:
-			if (phy-&gt;type == BCM43xx_PHYTYPE_G &amp;&amp; bcm43xx_is_hw_radio_enabled(bcm) &amp;&amp;
-			    1/*FIXME: using G rates.*/)
-				turn_on = 1;
-			break;
-		case BCM43xx_LED_TRANSFER:
-			if (transferring)
-				bcm43xx_led_blink_start(led, BCM43xx_LEDBLINK_MEDIUM);
-			else
-				bcm43xx_led_blink_stop(led, 0);
-			continue;
-		case BCM43xx_LED_APTRANSFER:
-			if (bcm-&gt;ieee-&gt;iw_mode == IW_MODE_MASTER) {
-				if (transferring) {
-					interval = BCM43xx_LEDBLINK_FAST;
-					turn_on = 1;
-				}
-			} else {
-				turn_on = 1;
-				if (0/*TODO: not assoc*/)
-					interval = BCM43xx_LEDBLINK_SLOW;
-				else if (transferring)
-					interval = BCM43xx_LEDBLINK_FAST;
-				else
-					turn_on = 0;
-			}
-			if (turn_on)
-				bcm43xx_led_blink_start(led, interval);
-			else
-				bcm43xx_led_blink_stop(led, 0);
-			continue;
-		case BCM43xx_LED_WEIRD:
-			//TODO
-			break;
-		case BCM43xx_LED_ASSOC:
-			if (bcm-&gt;softmac-&gt;associnfo.associated)
-				turn_on = 1;
-			break;
-#ifdef CONFIG_BCM43XX_DEBUG
-		case BCM43xx_LED_TEST_BLINKSLOW:
-			bcm43xx_led_blink_start(led, BCM43xx_LEDBLINK_SLOW);
-			continue;
-		case BCM43xx_LED_TEST_BLINKMEDIUM:
-			bcm43xx_led_blink_start(led, BCM43xx_LEDBLINK_MEDIUM);
-			continue;
-		case BCM43xx_LED_TEST_BLINKFAST:
-			bcm43xx_led_blink_start(led, BCM43xx_LEDBLINK_FAST);
-			continue;
-#endif /* CONFIG_BCM43XX_DEBUG */
-		default:
-			dprintkl(KERN_INFO PFX &quot;Bad value in leds_update,&quot;
-				&quot; led-&gt;behaviour: 0x%x\n&quot;, led-&gt;behaviour);
-		};
-
-		if (led-&gt;activelow)
-			turn_on = !turn_on;
-		if (turn_on)
-			ledctl |= (1 &lt;&lt; i);
-		else
-			ledctl &amp;= ~(1 &lt;&lt; i);
-	}
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
-	spin_unlock_irqrestore(&amp;bcm-&gt;leds_lock, flags);
-}
-
-void bcm43xx_leds_switch_all(struct bcm43xx_private *bcm, int on)
-{
-	struct bcm43xx_led *led;
-	u16 ledctl;
-	int i;
-	int bit_on;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;bcm-&gt;leds_lock, flags);
-	ledctl = bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_CONTROL);
-	for (i = 0; i &lt; BCM43xx_NR_LEDS; i++) {
-		led = &amp;(bcm-&gt;leds[i]);
-		if (led-&gt;behaviour == BCM43xx_LED_INACTIVE)
-			continue;
-		if (on)
-			bit_on = led-&gt;activelow ? 0 : 1;
-		else
-			bit_on = led-&gt;activelow ? 1 : 0;
-		if (bit_on)
-			ledctl |= (1 &lt;&lt; i);
-		else
-			ledctl &amp;= ~(1 &lt;&lt; i);
-	}
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_CONTROL, ledctl);
-	spin_unlock_irqrestore(&amp;bcm-&gt;leds_lock, flags);
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_leds.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_leds.h
+++ /dev/null
@@ -1,62 +0,0 @@
-#ifndef BCM43xx_LEDS_H_
-#define BCM43xx_LEDS_H_
-
-#include &lt;linux/types.h&gt;
-#include &lt;linux/timer.h&gt;
-
-
-struct bcm43xx_led {
-	u8 behaviour:7;
-	u8 activelow:1;
-
-	struct bcm43xx_private *bcm;
-	struct timer_list blink_timer;
-	unsigned long blink_interval;
-};
-#define bcm43xx_led_index(led)	((int)((led) - (led)-&gt;bcm-&gt;leds))
-
-/* Delay between state changes when blinking in jiffies */
-#define BCM43xx_LEDBLINK_SLOW		(HZ / 1)
-#define BCM43xx_LEDBLINK_MEDIUM		(HZ / 4)
-#define BCM43xx_LEDBLINK_FAST		(HZ / 8)
-
-#define BCM43xx_LED_XFER_THRES		(HZ / 100)
-
-#define BCM43xx_LED_BEHAVIOUR		0x7F
-#define BCM43xx_LED_ACTIVELOW		0x80
-enum { /* LED behaviour values */
-	BCM43xx_LED_OFF,
-	BCM43xx_LED_ON,
-	BCM43xx_LED_ACTIVITY,
-	BCM43xx_LED_RADIO_ALL,
-	BCM43xx_LED_RADIO_A,
-	BCM43xx_LED_RADIO_B,
-	BCM43xx_LED_MODE_BG,
-	BCM43xx_LED_TRANSFER,
-	BCM43xx_LED_APTRANSFER,
-	BCM43xx_LED_WEIRD,//FIXME
-	BCM43xx_LED_ASSOC,
-	BCM43xx_LED_INACTIVE,
-
-	/* Behaviour values for testing.
-	 * With these values it is easier to figure out
-	 * the real behaviour of leds, in case the SPROM
-	 * is missing information.
-	 */
-	BCM43xx_LED_TEST_BLINKSLOW,
-	BCM43xx_LED_TEST_BLINKMEDIUM,
-	BCM43xx_LED_TEST_BLINKFAST,
-
-	/* Misc values for BCM4303 */
-	BCM43xx_LED_BCM4303_0 = 0x2B,
-	BCM43xx_LED_BCM4303_1 = 0x78,
-	BCM43xx_LED_BCM4303_2 = 0x2E,
-	BCM43xx_LED_BCM4303_3 = 0x19,
-};
-
-int bcm43xx_leds_init(struct bcm43xx_private *bcm);
-void bcm43xx_leds_exit(struct bcm43xx_private *bcm);
-void bcm43xx_leds_update(struct bcm43xx_private *bcm, int activity);
-void bcm43xx_leds_switch_all(struct bcm43xx_private *bcm, int on);
-
-#endif /* BCM43xx_LEDS_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.c
+++ /dev/null
@@ -1,4281 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &lt;linux/delay.h&gt;
-#include &lt;linux/init.h&gt;
-#include &lt;linux/moduleparam.h&gt;
-#include &lt;linux/if_arp.h&gt;
-#include &lt;linux/etherdevice.h&gt;
-#include &lt;linux/version.h&gt;
-#include &lt;linux/firmware.h&gt;
-#include &lt;linux/wireless.h&gt;
-#include &lt;linux/workqueue.h&gt;
-#include &lt;linux/skbuff.h&gt;
-#include &lt;linux/dma-mapping.h&gt;
-#include &lt;net/iw_handler.h&gt;
-
-#include &quot;bcm43xx.h&quot;
-#include &quot;bcm43xx_main.h&quot;
-#include &quot;bcm43xx_debugfs.h&quot;
-#include &quot;bcm43xx_radio.h&quot;
-#include &quot;bcm43xx_phy.h&quot;
-#include &quot;bcm43xx_dma.h&quot;
-#include &quot;bcm43xx_pio.h&quot;
-#include &quot;bcm43xx_power.h&quot;
-#include &quot;bcm43xx_wx.h&quot;
-#include &quot;bcm43xx_ethtool.h&quot;
-#include &quot;bcm43xx_xmit.h&quot;
-#include &quot;bcm43xx_sysfs.h&quot;
-
-
-MODULE_DESCRIPTION(&quot;Broadcom BCM43xx wireless driver&quot;);
-MODULE_AUTHOR(&quot;Martin Langer&quot;);
-MODULE_AUTHOR(&quot;Stefano Brivio&quot;);
-MODULE_AUTHOR(&quot;Michael Buesch&quot;);
-MODULE_LICENSE(&quot;GPL&quot;);
-
-#if defined(CONFIG_BCM43XX_DMA) &amp;&amp; defined(CONFIG_BCM43XX_PIO)
-static int modparam_pio;
-module_param_named(pio, modparam_pio, int, 0444);
-MODULE_PARM_DESC(pio, &quot;enable(1) / disable(0) PIO mode&quot;);
-#elif defined(CONFIG_BCM43XX_DMA)
-# define modparam_pio	0
-#elif defined(CONFIG_BCM43XX_PIO)
-# define modparam_pio	1
-#endif
-
-static int modparam_bad_frames_preempt;
-module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
-MODULE_PARM_DESC(bad_frames_preempt, &quot;enable(1) / disable(0) Bad Frames Preemption&quot;);
-
-static int modparam_short_retry = BCM43xx_DEFAULT_SHORT_RETRY_LIMIT;
-module_param_named(short_retry, modparam_short_retry, int, 0444);
-MODULE_PARM_DESC(short_retry, &quot;Short-Retry-Limit (0 - 15)&quot;);
-
-static int modparam_long_retry = BCM43xx_DEFAULT_LONG_RETRY_LIMIT;
-module_param_named(long_retry, modparam_long_retry, int, 0444);
-MODULE_PARM_DESC(long_retry, &quot;Long-Retry-Limit (0 - 15)&quot;);
-
-static int modparam_locale = -1;
-module_param_named(locale, modparam_locale, int, 0444);
-MODULE_PARM_DESC(country, &quot;Select LocaleCode 0-11 (For travelers)&quot;);
-
-static int modparam_noleds;
-module_param_named(noleds, modparam_noleds, int, 0444);
-MODULE_PARM_DESC(noleds, &quot;Turn off all LED activity&quot;);
-
-static char modparam_fwpostfix[64];
-module_param_string(fwpostfix, modparam_fwpostfix, 64, 0444);
-MODULE_PARM_DESC(fwpostfix, &quot;Postfix for .fw files. Useful for using multiple firmware image versions.&quot;);
-
-
-/* If you want to debug with just a single device, enable this,
- * where the string is the pci device ID (as given by the kernel's
- * pci_name function) of the device to be used.
- */
-//#define DEBUG_SINGLE_DEVICE_ONLY	&quot;0001:11:00.0&quot;
-
-/* If you want to enable printing of each MMIO access, enable this. */
-//#define DEBUG_ENABLE_MMIO_PRINT
-
-/* If you want to enable printing of MMIO access within
- * ucode/pcm upload, initvals write, enable this.
- */
-//#define DEBUG_ENABLE_UCODE_MMIO_PRINT
-
-/* If you want to enable printing of PCI Config Space access, enable this */
-//#define DEBUG_ENABLE_PCILOG
-
-
-/* Detailed list maintained at:
- * <A HREF="http://openfacts.berlios.de/index-en.phtml?title=Bcm43xxDevices">http://openfacts.berlios.de/index-en.phtml?title=Bcm43xxDevices</A>
- */
-	static struct pci_device_id bcm43xx_pci_tbl[] = {
-	/* Broadcom 4303 802.11b */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4301, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4307 802.11b */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4307, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4311 802.11(a)/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4311, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4312 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4312, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4318 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4318, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4319 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4319, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4306 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4320, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4306 802.11a */
-//	{ PCI_VENDOR_ID_BROADCOM, 0x4321, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 4309 802.11a/b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4324, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	/* Broadcom 43XG 802.11b/g */
-	{ PCI_VENDOR_ID_BROADCOM, 0x4325, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ 0 },
-};
-MODULE_DEVICE_TABLE(pci, bcm43xx_pci_tbl);
-
-static void bcm43xx_ram_write(struct bcm43xx_private *bcm, u16 offset, u32 val)
-{
-	u32 status;
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	if (!(status &amp; BCM43xx_SBF_XFER_REG_BYTESWAP))
-		val = swab32(val);
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_RAM_CONTROL, offset);
-	mmiowb();
-	bcm43xx_write32(bcm, BCM43xx_MMIO_RAM_DATA, val);
-}
-
-static inline
-void bcm43xx_shm_control_word(struct bcm43xx_private *bcm,
-			      u16 routing, u16 offset)
-{
-	u32 control;
-
-	/* &quot;offset&quot; is the WORD offset. */
-
-	control = routing;
-	control &lt;&lt;= 16;
-	control |= offset;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_CONTROL, control);
-}
-
-u32 bcm43xx_shm_read32(struct bcm43xx_private *bcm,
-		       u16 routing, u16 offset)
-{
-	u32 ret;
-
-	if (routing == BCM43xx_SHM_SHARED) {
-		if (offset &amp; 0x0003) {
-			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset &gt;&gt; 2);
-			ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED);
-			ret &lt;&lt;= 16;
-			bcm43xx_shm_control_word(bcm, routing, (offset &gt;&gt; 2) + 1);
-			ret |= bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA);
-
-			return ret;
-		}
-		offset &gt;&gt;= 2;
-	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	ret = bcm43xx_read32(bcm, BCM43xx_MMIO_SHM_DATA);
-
-	return ret;
-}
-
-u16 bcm43xx_shm_read16(struct bcm43xx_private *bcm,
-		       u16 routing, u16 offset)
-{
-	u16 ret;
-
-	if (routing == BCM43xx_SHM_SHARED) {
-		if (offset &amp; 0x0003) {
-			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset &gt;&gt; 2);
-			ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED);
-
-			return ret;
-		}
-		offset &gt;&gt;= 2;
-	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	ret = bcm43xx_read16(bcm, BCM43xx_MMIO_SHM_DATA);
-
-	return ret;
-}
-
-void bcm43xx_shm_write32(struct bcm43xx_private *bcm,
-			 u16 routing, u16 offset,
-			 u32 value)
-{
-	if (routing == BCM43xx_SHM_SHARED) {
-		if (offset &amp; 0x0003) {
-			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset &gt;&gt; 2);
-			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
-					(value &gt;&gt; 16) &amp; 0xffff);
-			mmiowb();
-			bcm43xx_shm_control_word(bcm, routing, (offset &gt;&gt; 2) + 1);
-			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA,
-					value &amp; 0xffff);
-			return;
-		}
-		offset &gt;&gt;= 2;
-	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	mmiowb();
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA, value);
-}
-
-void bcm43xx_shm_write16(struct bcm43xx_private *bcm,
-			 u16 routing, u16 offset,
-			 u16 value)
-{
-	if (routing == BCM43xx_SHM_SHARED) {
-		if (offset &amp; 0x0003) {
-			/* Unaligned access */
-			bcm43xx_shm_control_word(bcm, routing, offset &gt;&gt; 2);
-			mmiowb();
-			bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA_UNALIGNED,
-					value);
-			return;
-		}
-		offset &gt;&gt;= 2;
-	}
-	bcm43xx_shm_control_word(bcm, routing, offset);
-	mmiowb();
-	bcm43xx_write16(bcm, BCM43xx_MMIO_SHM_DATA, value);
-}
-
-void bcm43xx_tsf_read(struct bcm43xx_private *bcm, u64 *tsf)
-{
-	/* We need to be careful. As we read the TSF from multiple
-	 * registers, we should take care of register overflows.
-	 * In theory, the whole tsf read process should be atomic.
-	 * We try to be atomic here, by restaring the read process,
-	 * if any of the high registers changed (overflew).
-	 */
-	if (bcm-&gt;current_core-&gt;rev &gt;= 3) {
-		u32 low, high, high2;
-
-		do {
-			high = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
-			low = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW);
-			high2 = bcm43xx_read32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH);
-		} while (unlikely(high != high2));
-
-		*tsf = high;
-		*tsf &lt;&lt;= 32;
-		*tsf |= low;
-	} else {
-		u64 tmp;
-		u16 v0, v1, v2, v3;
-		u16 test1, test2, test3;
-
-		do {
-			v3 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_3);
-			v2 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_2);
-			v1 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_1);
-			v0 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_0);
-
-			test3 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_3);
-			test2 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_2);
-			test1 = bcm43xx_read16(bcm, BCM43xx_MMIO_TSF_1);
-		} while (v3 != test3 || v2 != test2 || v1 != test1);
-
-		*tsf = v3;
-		*tsf &lt;&lt;= 48;
-		tmp = v2;
-		tmp &lt;&lt;= 32;
-		*tsf |= tmp;
-		tmp = v1;
-		tmp &lt;&lt;= 16;
-		*tsf |= tmp;
-		*tsf |= v0;
-	}
-}
-
-void bcm43xx_tsf_write(struct bcm43xx_private *bcm, u64 tsf)
-{
-	u32 status;
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	status |= BCM43xx_SBF_TIME_UPDATE;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-	mmiowb();
-
-	/* Be careful with the in-progress timer.
-	 * First zero out the low register, so we have a full
-	 * register-overflow duration to complete the operation.
-	 */
-	if (bcm-&gt;current_core-&gt;rev &gt;= 3) {
-		u32 lo = (tsf &amp; 0x00000000FFFFFFFFULL);
-		u32 hi = (tsf &amp; 0xFFFFFFFF00000000ULL) &gt;&gt; 32;
-
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW, 0);
-		mmiowb();
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_HIGH, hi);
-		mmiowb();
-		bcm43xx_write32(bcm, BCM43xx_MMIO_REV3PLUS_TSF_LOW, lo);
-	} else {
-		u16 v0 = (tsf &amp; 0x000000000000FFFFULL);
-		u16 v1 = (tsf &amp; 0x00000000FFFF0000ULL) &gt;&gt; 16;
-		u16 v2 = (tsf &amp; 0x0000FFFF00000000ULL) &gt;&gt; 32;
-		u16 v3 = (tsf &amp; 0xFFFF000000000000ULL) &gt;&gt; 48;
-
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_0, 0);
-		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_3, v3);
-		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_2, v2);
-		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_1, v1);
-		mmiowb();
-		bcm43xx_write16(bcm, BCM43xx_MMIO_TSF_0, v0);
-	}
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	status &amp;= ~BCM43xx_SBF_TIME_UPDATE;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-}
-
-static
-void bcm43xx_macfilter_set(struct bcm43xx_private *bcm,
-			   u16 offset,
-			   const u8 *mac)
-{
-	u16 data;
-
-	offset |= 0x0020;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_CONTROL, offset);
-
-	data = mac[0];
-	data |= mac[1] &lt;&lt; 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
-	data = mac[2];
-	data |= mac[3] &lt;&lt; 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
-	data = mac[4];
-	data |= mac[5] &lt;&lt; 8;
-	bcm43xx_write16(bcm, BCM43xx_MMIO_MACFILTER_DATA, data);
-}
-
-static void bcm43xx_macfilter_clear(struct bcm43xx_private *bcm,
-				    u16 offset)
-{
-	const u8 zero_addr[ETH_ALEN] = { 0 };
-
-	bcm43xx_macfilter_set(bcm, offset, zero_addr);
-}
-
-static void bcm43xx_write_mac_bssid_templates(struct bcm43xx_private *bcm)
-{
-	const u8 *mac = (const u8 *)(bcm-&gt;net_dev-&gt;dev_addr);
-	const u8 *bssid = (const u8 *)(bcm-&gt;ieee-&gt;bssid);
-	u8 mac_bssid[ETH_ALEN * 2];
-	int i;
-
-	memcpy(mac_bssid, mac, ETH_ALEN);
-	memcpy(mac_bssid + ETH_ALEN, bssid, ETH_ALEN);
-
-	/* Write our MAC address and BSSID to template ram */
-	for (i = 0; i &lt; ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x20 + i, *((u32 *)(mac_bssid + i)));
-	for (i = 0; i &lt; ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x78 + i, *((u32 *)(mac_bssid + i)));
-	for (i = 0; i &lt; ARRAY_SIZE(mac_bssid); i += sizeof(u32))
-		bcm43xx_ram_write(bcm, 0x478 + i, *((u32 *)(mac_bssid + i)));
-}
-
-//FIXME: Well, we should probably call them from somewhere.
-#if 0
-static void bcm43xx_set_slot_time(struct bcm43xx_private *bcm, u16 slot_time)
-{
-	/* slot_time is in usec. */
-	if (bcm43xx_current_phy(bcm)-&gt;type != BCM43xx_PHYTYPE_G)
-		return;
-	bcm43xx_write16(bcm, 0x684, 510 + slot_time);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0010, slot_time);
-}
-
-static void bcm43xx_short_slot_timing_enable(struct bcm43xx_private *bcm)
-{
-	bcm43xx_set_slot_time(bcm, 9);
-}
-
-static void bcm43xx_short_slot_timing_disable(struct bcm43xx_private *bcm)
-{
-	bcm43xx_set_slot_time(bcm, 20);
-}
-#endif
-
-/* FIXME: To get the MAC-filter working, we need to implement the
- *        following functions (and rename them :)
- */
-#if 0
-static void bcm43xx_disassociate(struct bcm43xx_private *bcm)
-{
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_macfilter_clear(bcm, BCM43xx_MACFILTER_ASSOC);
-
-	bcm43xx_ram_write(bcm, 0x0026, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0028, 0x0000);
-	bcm43xx_ram_write(bcm, 0x007E, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0080, 0x0000);
-	bcm43xx_ram_write(bcm, 0x047E, 0x0000);
-	bcm43xx_ram_write(bcm, 0x0480, 0x0000);
-
-	if (bcm-&gt;current_core-&gt;rev &lt; 3) {
-		bcm43xx_write16(bcm, 0x0610, 0x8000);
-		bcm43xx_write16(bcm, 0x060E, 0x0000);
-	} else
-		bcm43xx_write32(bcm, 0x0188, 0x80000000);
-
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0004, 0x000003ff);
-
-	if (bcm43xx_current_phy(bcm)-&gt;type == BCM43xx_PHYTYPE_G &amp;&amp;
-	    ieee80211_is_ofdm_rate(bcm-&gt;softmac-&gt;txrates.default_rate))
-		bcm43xx_short_slot_timing_enable(bcm);
-
-	bcm43xx_mac_enable(bcm);
-}
-
-static void bcm43xx_associate(struct bcm43xx_private *bcm,
-			      const u8 *mac)
-{
-	memcpy(bcm-&gt;ieee-&gt;bssid, mac, ETH_ALEN);
-
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_macfilter_set(bcm, BCM43xx_MACFILTER_ASSOC, mac);
-	bcm43xx_write_mac_bssid_templates(bcm);
-	bcm43xx_mac_enable(bcm);
-}
-#endif
-
-/* Enable a Generic IRQ. &quot;mask&quot; is the mask of which IRQs to enable.
- * Returns the _previously_ enabled IRQ mask.
- */
-static inline u32 bcm43xx_interrupt_enable(struct bcm43xx_private *bcm, u32 mask)
-{
-	u32 old_mask;
-
-	old_mask = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask | mask);
-
-	return old_mask;
-}
-
-/* Disable a Generic IRQ. &quot;mask&quot; is the mask of which IRQs to disable.
- * Returns the _previously_ enabled IRQ mask.
- */
-static inline u32 bcm43xx_interrupt_disable(struct bcm43xx_private *bcm, u32 mask)
-{
-	u32 old_mask;
-
-	old_mask = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK, old_mask &amp; ~mask);
-
-	return old_mask;
-}
-
-/* Synchronize IRQ top- and bottom-half.
- * IRQs must be masked before calling this.
- * This must not be called with the irq_lock held.
- */
-static void bcm43xx_synchronize_irq(struct bcm43xx_private *bcm)
-{
-	synchronize_irq(bcm-&gt;irq);
-	tasklet_disable(&amp;bcm-&gt;isr_tasklet);
-}
-
-/* Make sure we don't receive more data from the device. */
-static int bcm43xx_disable_interrupts_sync(struct bcm43xx_private *bcm)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (unlikely(bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)) {
-		spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-		return -EBUSY;
-	}
-	bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-	bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK); /* flush */
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	bcm43xx_synchronize_irq(bcm);
-
-	return 0;
-}
-
-static int bcm43xx_read_radioinfo(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u32 radio_id;
-	u16 manufact;
-	u16 version;
-	u8 revision;
-
-	if (bcm-&gt;chip_id == 0x4317) {
-		if (bcm-&gt;chip_rev == 0x00)
-			radio_id = 0x3205017F;
-		else if (bcm-&gt;chip_rev == 0x01)
-			radio_id = 0x4205017F;
-		else
-			radio_id = 0x5205017F;
-	} else {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, BCM43xx_RADIOCTL_ID);
-		radio_id = bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_DATA_HIGH);
-		radio_id &lt;&lt;= 16;
-		bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, BCM43xx_RADIOCTL_ID);
-		radio_id |= bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_DATA_LOW);
-	}
-
-	manufact = (radio_id &amp; 0x00000FFF);
-	version = (radio_id &amp; 0x0FFFF000) &gt;&gt; 12;
-	revision = (radio_id &amp; 0xF0000000) &gt;&gt; 28;
-
-	dprintk(KERN_INFO PFX &quot;Detected Radio: ID: %x (Manuf: %x Ver: %x Rev: %x)\n&quot;,
-		radio_id, manufact, version, revision);
-
-	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-		if ((version != 0x2060) || (revision != 1) || (manufact != 0x17f))
-			goto err_unsupported_radio;
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if ((version &amp; 0xFFF0) != 0x2050)
-			goto err_unsupported_radio;
-		break;
-	case BCM43xx_PHYTYPE_G:
-		if (version != 0x2050)
-			goto err_unsupported_radio;
-		break;
-	}
-
-	radio-&gt;manufact = manufact;
-	radio-&gt;version = version;
-	radio-&gt;revision = revision;
-
-	if (phy-&gt;type == BCM43xx_PHYTYPE_A)
-		radio-&gt;txpower_desired = bcm-&gt;sprom.maxpower_aphy;
-	else
-		radio-&gt;txpower_desired = bcm-&gt;sprom.maxpower_bgphy;
-
-	return 0;
-
-err_unsupported_radio:
-	printk(KERN_ERR PFX &quot;Unsupported Radio connected to the PHY!\n&quot;);
-	return -ENODEV;
-}
-
-static const char * bcm43xx_locale_iso(u8 locale)
-{
-	/* ISO 3166-1 country codes.
-	 * Note that there aren't ISO 3166-1 codes for
-	 * all or locales. (Not all locales are countries)
-	 */
-	switch (locale) {
-	case BCM43xx_LOCALE_WORLD:
-	case BCM43xx_LOCALE_ALL:
-		return &quot;XX&quot;;
-	case BCM43xx_LOCALE_THAILAND:
-		return &quot;TH&quot;;
-	case BCM43xx_LOCALE_ISRAEL:
-		return &quot;IL&quot;;
-	case BCM43xx_LOCALE_JORDAN:
-		return &quot;JO&quot;;
-	case BCM43xx_LOCALE_CHINA:
-		return &quot;CN&quot;;
-	case BCM43xx_LOCALE_JAPAN:
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		return &quot;JP&quot;;
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-	case BCM43xx_LOCALE_USA_LOW:
-		return &quot;US&quot;;
-	case BCM43xx_LOCALE_EUROPE:
-		return &quot;EU&quot;;
-	case BCM43xx_LOCALE_NONE:
-		return &quot;  &quot;;
-	}
-	assert(0);
-	return &quot;  &quot;;
-}
-
-static const char * bcm43xx_locale_string(u8 locale)
-{
-	switch (locale) {
-	case BCM43xx_LOCALE_WORLD:
-		return &quot;World&quot;;
-	case BCM43xx_LOCALE_THAILAND:
-		return &quot;Thailand&quot;;
-	case BCM43xx_LOCALE_ISRAEL:
-		return &quot;Israel&quot;;
-	case BCM43xx_LOCALE_JORDAN:
-		return &quot;Jordan&quot;;
-	case BCM43xx_LOCALE_CHINA:
-		return &quot;China&quot;;
-	case BCM43xx_LOCALE_JAPAN:
-		return &quot;Japan&quot;;
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-		return &quot;USA/Canada/ANZ&quot;;
-	case BCM43xx_LOCALE_EUROPE:
-		return &quot;Europe&quot;;
-	case BCM43xx_LOCALE_USA_LOW:
-		return &quot;USAlow&quot;;
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		return &quot;JapanHigh&quot;;
-	case BCM43xx_LOCALE_ALL:
-		return &quot;All&quot;;
-	case BCM43xx_LOCALE_NONE:
-		return &quot;None&quot;;
-	}
-	assert(0);
-	return &quot;&quot;;
-}
-
-static inline u8 bcm43xx_crc8(u8 crc, u8 data)
-{
-	static const u8 t[] = {
-		0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
-		0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
-		0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
-		0xDE, 0x29, 0x67, 0x90, 0xFB, 0x0C, 0x42, 0xB5,
-		0x7F, 0x88, 0xC6, 0x31, 0x5A, 0xAD, 0xE3, 0x14,
-		0x35, 0xC2, 0x8C, 0x7B, 0x10, 0xE7, 0xA9, 0x5E,
-		0xEB, 0x1C, 0x52, 0xA5, 0xCE, 0x39, 0x77, 0x80,
-		0xA1, 0x56, 0x18, 0xEF, 0x84, 0x73, 0x3D, 0xCA,
-		0xFE, 0x09, 0x47, 0xB0, 0xDB, 0x2C, 0x62, 0x95,
-		0xB4, 0x43, 0x0D, 0xFA, 0x91, 0x66, 0x28, 0xDF,
-		0x6A, 0x9D, 0xD3, 0x24, 0x4F, 0xB8, 0xF6, 0x01,
-		0x20, 0xD7, 0x99, 0x6E, 0x05, 0xF2, 0xBC, 0x4B,
-		0x81, 0x76, 0x38, 0xCF, 0xA4, 0x53, 0x1D, 0xEA,
-		0xCB, 0x3C, 0x72, 0x85, 0xEE, 0x19, 0x57, 0xA0,
-		0x15, 0xE2, 0xAC, 0x5B, 0x30, 0xC7, 0x89, 0x7E,
-		0x5F, 0xA8, 0xE6, 0x11, 0x7A, 0x8D, 0xC3, 0x34,
-		0xAB, 0x5C, 0x12, 0xE5, 0x8E, 0x79, 0x37, 0xC0,
-		0xE1, 0x16, 0x58, 0xAF, 0xC4, 0x33, 0x7D, 0x8A,
-		0x3F, 0xC8, 0x86, 0x71, 0x1A, 0xED, 0xA3, 0x54,
-		0x75, 0x82, 0xCC, 0x3B, 0x50, 0xA7, 0xE9, 0x1E,
-		0xD4, 0x23, 0x6D, 0x9A, 0xF1, 0x06, 0x48, 0xBF,
-		0x9E, 0x69, 0x27, 0xD0, 0xBB, 0x4C, 0x02, 0xF5,
-		0x40, 0xB7, 0xF9, 0x0E, 0x65, 0x92, 0xDC, 0x2B,
-		0x0A, 0xFD, 0xB3, 0x44, 0x2F, 0xD8, 0x96, 0x61,
-		0x55, 0xA2, 0xEC, 0x1B, 0x70, 0x87, 0xC9, 0x3E,
-		0x1F, 0xE8, 0xA6, 0x51, 0x3A, 0xCD, 0x83, 0x74,
-		0xC1, 0x36, 0x78, 0x8F, 0xE4, 0x13, 0x5D, 0xAA,
-		0x8B, 0x7C, 0x32, 0xC5, 0xAE, 0x59, 0x17, 0xE0,
-		0x2A, 0xDD, 0x93, 0x64, 0x0F, 0xF8, 0xB6, 0x41,
-		0x60, 0x97, 0xD9, 0x2E, 0x45, 0xB2, 0xFC, 0x0B,
-		0xBE, 0x49, 0x07, 0xF0, 0x9B, 0x6C, 0x22, 0xD5,
-		0xF4, 0x03, 0x4D, 0xBA, 0xD1, 0x26, 0x68, 0x9F,
-	};
-	return t[crc ^ data];
-}
-
-static u8 bcm43xx_sprom_crc(const u16 *sprom)
-{
-	int word;
-	u8 crc = 0xFF;
-
-	for (word = 0; word &lt; BCM43xx_SPROM_SIZE - 1; word++) {
-		crc = bcm43xx_crc8(crc, sprom[word] &amp; 0x00FF);
-		crc = bcm43xx_crc8(crc, (sprom[word] &amp; 0xFF00) &gt;&gt; 8);
-	}
-	crc = bcm43xx_crc8(crc, sprom[BCM43xx_SPROM_VERSION] &amp; 0x00FF);
-	crc ^= 0xFF;
-
-	return crc;
-}
-
-int bcm43xx_sprom_read(struct bcm43xx_private *bcm, u16 *sprom)
-{
-	int i;
-	u8 crc, expected_crc;
-
-	for (i = 0; i &lt; BCM43xx_SPROM_SIZE; i++)
-		sprom[i] = bcm43xx_read16(bcm, BCM43xx_SPROM_BASE + (i * 2));
-	/* CRC-8 check. */
-	crc = bcm43xx_sprom_crc(sprom);
-	expected_crc = (sprom[BCM43xx_SPROM_VERSION] &amp; 0xFF00) &gt;&gt; 8;
-	if (crc != expected_crc) {
-		printk(KERN_WARNING PFX &quot;WARNING: Invalid SPROM checksum &quot;
-					&quot;(0x%02X, expected: 0x%02X)\n&quot;,
-		       crc, expected_crc);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int bcm43xx_sprom_write(struct bcm43xx_private *bcm, const u16 *sprom)
-{
-	int i, err;
-	u8 crc, expected_crc;
-	u32 spromctl;
-
-	/* CRC-8 validation of the input data. */
-	crc = bcm43xx_sprom_crc(sprom);
-	expected_crc = (sprom[BCM43xx_SPROM_VERSION] &amp; 0xFF00) &gt;&gt; 8;
-	if (crc != expected_crc) {
-		printk(KERN_ERR PFX &quot;SPROM input data: Invalid CRC\n&quot;);
-		return -EINVAL;
-	}
-
-	printk(KERN_INFO PFX &quot;Writing SPROM. Do NOT turn off the power! Please stand by...\n&quot;);
-	err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_SPROMCTL, &amp;spromctl);
-	if (err)
-		goto err_ctlreg;
-	spromctl |= 0x10; /* SPROM WRITE enable. */
-	err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_SPROMCTL, spromctl);
-	if (err)
-		goto err_ctlreg;
-	/* We must burn lots of CPU cycles here, but that does not
-	 * really matter as one does not write the SPROM every other minute...
-	 */
-	printk(KERN_INFO PFX &quot;[ 0%%&quot;);
-	mdelay(500);
-	for (i = 0; i &lt; BCM43xx_SPROM_SIZE; i++) {
-		if (i == 16)
-			printk(&quot;25%%&quot;);
-		else if (i == 32)
-			printk(&quot;50%%&quot;);
-		else if (i == 48)
-			printk(&quot;75%%&quot;);
-		else if (i % 2)
-			printk(&quot;.&quot;);
-		bcm43xx_write16(bcm, BCM43xx_SPROM_BASE + (i * 2), sprom[i]);
-		mmiowb();
-		mdelay(20);
-	}
-	spromctl &amp;= ~0x10; /* SPROM WRITE enable. */
-	err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_SPROMCTL, spromctl);
-	if (err)
-		goto err_ctlreg;
-	mdelay(500);
-	printk(&quot;100%% ]\n&quot;);
-	printk(KERN_INFO PFX &quot;SPROM written.\n&quot;);
-	bcm43xx_controller_restart(bcm, &quot;SPROM update&quot;);
-
-	return 0;
-err_ctlreg:
-	printk(KERN_ERR PFX &quot;Could not access SPROM control register.\n&quot;);
-	return -ENODEV;
-}
-
-static int bcm43xx_sprom_extract(struct bcm43xx_private *bcm)
-{
-	u16 value;
-	u16 *sprom;
-
-	sprom = kzalloc(BCM43xx_SPROM_SIZE * sizeof(u16),
-			GFP_KERNEL);
-	if (!sprom) {
-		printk(KERN_ERR PFX &quot;sprom_extract OOM\n&quot;);
-		return -ENOMEM;
-	}
-	bcm43xx_sprom_read(bcm, sprom);
-
-	/* boardflags2 */
-	value = sprom[BCM43xx_SPROM_BOARDFLAGS2];
-	bcm-&gt;sprom.boardflags2 = value;
-
-	/* il0macaddr */
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 0];
-	*(((u16 *)bcm-&gt;sprom.il0macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 1];
-	*(((u16 *)bcm-&gt;sprom.il0macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_IL0MACADDR + 2];
-	*(((u16 *)bcm-&gt;sprom.il0macaddr) + 2) = cpu_to_be16(value);
-
-	/* et0macaddr */
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 0];
-	*(((u16 *)bcm-&gt;sprom.et0macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 1];
-	*(((u16 *)bcm-&gt;sprom.et0macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET0MACADDR + 2];
-	*(((u16 *)bcm-&gt;sprom.et0macaddr) + 2) = cpu_to_be16(value);
-
-	/* et1macaddr */
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 0];
-	*(((u16 *)bcm-&gt;sprom.et1macaddr) + 0) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 1];
-	*(((u16 *)bcm-&gt;sprom.et1macaddr) + 1) = cpu_to_be16(value);
-	value = sprom[BCM43xx_SPROM_ET1MACADDR + 2];
-	*(((u16 *)bcm-&gt;sprom.et1macaddr) + 2) = cpu_to_be16(value);
-
-	/* ethernet phy settings */
-	value = sprom[BCM43xx_SPROM_ETHPHY];
-	bcm-&gt;sprom.et0phyaddr = (value &amp; 0x001F);
-	bcm-&gt;sprom.et1phyaddr = (value &amp; 0x03E0) &gt;&gt; 5;
-
-	/* boardrev, antennas, locale */
-	value = sprom[BCM43xx_SPROM_BOARDREV];
-	bcm-&gt;sprom.boardrev = (value &amp; 0x00FF);
-	bcm-&gt;sprom.locale = (value &amp; 0x0F00) &gt;&gt; 8;
-	bcm-&gt;sprom.antennas_aphy = (value &amp; 0x3000) &gt;&gt; 12;
-	bcm-&gt;sprom.antennas_bgphy = (value &amp; 0xC000) &gt;&gt; 14;
-	if (modparam_locale != -1) {
-		if (modparam_locale &gt;= 0 &amp;&amp; modparam_locale &lt;= 11) {
-			bcm-&gt;sprom.locale = modparam_locale;
-			printk(KERN_WARNING PFX &quot;Operating with modified &quot;
-						&quot;LocaleCode %u (%s)\n&quot;,
-			       bcm-&gt;sprom.locale,
-			       bcm43xx_locale_string(bcm-&gt;sprom.locale));
-		} else {
-			printk(KERN_WARNING PFX &quot;Module parameter \&quot;locale\&quot; &quot;
-						&quot;invalid value. (0 - 11)\n&quot;);
-		}
-	}
-
-	/* pa0b* */
-	value = sprom[BCM43xx_SPROM_PA0B0];
-	bcm-&gt;sprom.pa0b0 = value;
-	value = sprom[BCM43xx_SPROM_PA0B1];
-	bcm-&gt;sprom.pa0b1 = value;
-	value = sprom[BCM43xx_SPROM_PA0B2];
-	bcm-&gt;sprom.pa0b2 = value;
-
-	/* wl0gpio* */
-	value = sprom[BCM43xx_SPROM_WL0GPIO0];
-	if (value == 0x0000)
-		value = 0xFFFF;
-	bcm-&gt;sprom.wl0gpio0 = value &amp; 0x00FF;
-	bcm-&gt;sprom.wl0gpio1 = (value &amp; 0xFF00) &gt;&gt; 8;
-	value = sprom[BCM43xx_SPROM_WL0GPIO2];
-	if (value == 0x0000)
-		value = 0xFFFF;
-	bcm-&gt;sprom.wl0gpio2 = value &amp; 0x00FF;
-	bcm-&gt;sprom.wl0gpio3 = (value &amp; 0xFF00) &gt;&gt; 8;
-
-	/* maxpower */
-	value = sprom[BCM43xx_SPROM_MAXPWR];
-	bcm-&gt;sprom.maxpower_aphy = (value &amp; 0xFF00) &gt;&gt; 8;
-	bcm-&gt;sprom.maxpower_bgphy = value &amp; 0x00FF;
-
-	/* pa1b* */
-	value = sprom[BCM43xx_SPROM_PA1B0];
-	bcm-&gt;sprom.pa1b0 = value;
-	value = sprom[BCM43xx_SPROM_PA1B1];
-	bcm-&gt;sprom.pa1b1 = value;
-	value = sprom[BCM43xx_SPROM_PA1B2];
-	bcm-&gt;sprom.pa1b2 = value;
-
-	/* idle tssi target */
-	value = sprom[BCM43xx_SPROM_IDL_TSSI_TGT];
-	bcm-&gt;sprom.idle_tssi_tgt_aphy = value &amp; 0x00FF;
-	bcm-&gt;sprom.idle_tssi_tgt_bgphy = (value &amp; 0xFF00) &gt;&gt; 8;
-
-	/* boardflags */
-	value = sprom[BCM43xx_SPROM_BOARDFLAGS];
-	if (value == 0xFFFF)
-		value = 0x0000;
-	bcm-&gt;sprom.boardflags = value;
-	/* boardflags workarounds */
-	if (bcm-&gt;board_vendor == PCI_VENDOR_ID_DELL &amp;&amp;
-	    bcm-&gt;chip_id == 0x4301 &amp;&amp;
-	    bcm-&gt;board_revision == 0x74)
-		bcm-&gt;sprom.boardflags |= BCM43xx_BFL_BTCOEXIST;
-	if (bcm-&gt;board_vendor == PCI_VENDOR_ID_APPLE &amp;&amp;
-	    bcm-&gt;board_type == 0x4E &amp;&amp;
-	    bcm-&gt;board_revision &gt; 0x40)
-		bcm-&gt;sprom.boardflags |= BCM43xx_BFL_PACTRL;
-
-	/* antenna gain */
-	value = sprom[BCM43xx_SPROM_ANTENNA_GAIN];
-	if (value == 0x0000 || value == 0xFFFF)
-		value = 0x0202;
-	/* convert values to Q5.2 */
-	bcm-&gt;sprom.antennagain_aphy = ((value &amp; 0xFF00) &gt;&gt; 8) * 4;
-	bcm-&gt;sprom.antennagain_bgphy = (value &amp; 0x00FF) * 4;
-
-	kfree(sprom);
-
-	return 0;
-}
-
-static int bcm43xx_geo_init(struct bcm43xx_private *bcm)
-{
-	struct ieee80211_geo *geo;
-	struct ieee80211_channel *chan;
-	int have_a = 0, have_bg = 0;
-	int i;
-	u8 channel;
-	struct bcm43xx_phyinfo *phy;
-	const char *iso_country;
-	u8 max_bg_channel;
-
-	geo = kzalloc(sizeof(*geo), GFP_KERNEL);
-	if (!geo)
-		return -ENOMEM;
-
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++) {
-		phy = &amp;(bcm-&gt;core_80211_ext[i].phy);
-		switch (phy-&gt;type) {
-		case BCM43xx_PHYTYPE_B:
-		case BCM43xx_PHYTYPE_G:
-			have_bg = 1;
-			break;
-		case BCM43xx_PHYTYPE_A:
-			have_a = 1;
-			break;
-		default:
-			assert(0);
-		}
-	}
-	iso_country = bcm43xx_locale_iso(bcm-&gt;sprom.locale);
-
-/* set the maximum channel based on locale set in sprom or witle locale option */
-	switch (bcm-&gt;sprom.locale) {
-	case BCM43xx_LOCALE_THAILAND:
-	case BCM43xx_LOCALE_ISRAEL:
-	case BCM43xx_LOCALE_JORDAN:
-	case BCM43xx_LOCALE_USA_CANADA_ANZ:
-	case BCM43xx_LOCALE_USA_LOW:
-		max_bg_channel = 11;
-		break;
-	case BCM43xx_LOCALE_JAPAN:
-	case BCM43xx_LOCALE_JAPAN_HIGH:
-		max_bg_channel = 14;
-		break;
-	default:
-		max_bg_channel = 13;
-	}
-
- 	if (have_a) {
-		for (i = 0, channel = IEEE80211_52GHZ_MIN_CHANNEL;
-		      channel &lt;= IEEE80211_52GHZ_MAX_CHANNEL; channel++) {
-			chan = &amp;geo-&gt;a[i++];
-			chan-&gt;freq = bcm43xx_channel_to_freq_a(channel);
-			chan-&gt;channel = channel;
-		}
-		geo-&gt;a_channels = i;
-	}
-	if (have_bg) {
-		for (i = 0, channel = IEEE80211_24GHZ_MIN_CHANNEL;
-		      channel &lt;= max_bg_channel; channel++) {
-			chan = &amp;geo-&gt;bg[i++];
-			chan-&gt;freq = bcm43xx_channel_to_freq_bg(channel);
-			chan-&gt;channel = channel;
-		}
-		geo-&gt;bg_channels = i;
-	}
-	memcpy(geo-&gt;name, iso_country, 2);
-	if (0 /*TODO: Outdoor use only */)
-		geo-&gt;name[2] = 'O';
-	else if (0 /*TODO: Indoor use only */)
-		geo-&gt;name[2] = 'I';
-	else
-		geo-&gt;name[2] = ' ';
-	geo-&gt;name[3] = '\0';
-
-	ieee80211_set_geo(bcm-&gt;ieee, geo);
-	kfree(geo);
-
-	return 0;
-}
-
-/* DummyTransmission function, as documented on 
- * <A HREF="http://bcm-specs.sipsolutions.net/DummyTransmission">http://bcm-specs.sipsolutions.net/DummyTransmission</A>
- */
-void bcm43xx_dummy_transmission(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	unsigned int i, max_loop;
-	u16 value = 0;
-	u32 buffer[5] = {
-		0x00000000,
-		0x0000D400,
-		0x00000000,
-		0x00000001,
-		0x00000000,
-	};
-
-	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-		max_loop = 0x1E;
-		buffer[0] = 0xCC010200;
-		break;
-	case BCM43xx_PHYTYPE_B:
-	case BCM43xx_PHYTYPE_G:
-		max_loop = 0xFA;
-		buffer[0] = 0x6E840B00; 
-		break;
-	default:
-		assert(0);
-		return;
-	}
-
-	for (i = 0; i &lt; 5; i++)
-		bcm43xx_ram_write(bcm, i * 4, buffer[i]);
-
-	bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD); /* dummy read */
-
-	bcm43xx_write16(bcm, 0x0568, 0x0000);
-	bcm43xx_write16(bcm, 0x07C0, 0x0000);
-	bcm43xx_write16(bcm, 0x050C, ((phy-&gt;type == BCM43xx_PHYTYPE_A) ? 1 : 0));
-	bcm43xx_write16(bcm, 0x0508, 0x0000);
-	bcm43xx_write16(bcm, 0x050A, 0x0000);
-	bcm43xx_write16(bcm, 0x054C, 0x0000);
-	bcm43xx_write16(bcm, 0x056A, 0x0014);
-	bcm43xx_write16(bcm, 0x0568, 0x0826);
-	bcm43xx_write16(bcm, 0x0500, 0x0000);
-	bcm43xx_write16(bcm, 0x0502, 0x0030);
-
-	if (radio-&gt;version == 0x2050 &amp;&amp; radio-&gt;revision &lt;= 0x5)
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0017);
-	for (i = 0x00; i &lt; max_loop; i++) {
-		value = bcm43xx_read16(bcm, 0x050E);
-		if (value &amp; 0x0080)
-			break;
-		udelay(10);
-	}
-	for (i = 0x00; i &lt; 0x0A; i++) {
-		value = bcm43xx_read16(bcm, 0x050E);
-		if (value &amp; 0x0400)
-			break;
-		udelay(10);
-	}
-	for (i = 0x00; i &lt; 0x0A; i++) {
-		value = bcm43xx_read16(bcm, 0x0690);
-		if (!(value &amp; 0x0100))
-			break;
-		udelay(10);
-	}
-	if (radio-&gt;version == 0x2050 &amp;&amp; radio-&gt;revision &lt;= 0x5)
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0037);
-}
-
-static void key_write(struct bcm43xx_private *bcm,
-		      u8 index, u8 algorithm, const u16 *key)
-{
-	unsigned int i, basic_wep = 0;
-	u32 offset;
-	u16 value;
- 
-	/* Write associated key information */
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x100 + (index * 2),
-			    ((index &lt;&lt; 4) | (algorithm &amp; 0x0F)));
- 
-	/* The first 4 WEP keys need extra love */
-	if (((algorithm == BCM43xx_SEC_ALGO_WEP) ||
-	    (algorithm == BCM43xx_SEC_ALGO_WEP104)) &amp;&amp; (index &lt; 4))
-		basic_wep = 1;
- 
-	/* Write key payload, 8 little endian words */
-	offset = bcm-&gt;security_offset + (index * BCM43xx_SEC_KEYSIZE);
-	for (i = 0; i &lt; (BCM43xx_SEC_KEYSIZE / sizeof(u16)); i++) {
-		value = cpu_to_le16(key[i]);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    offset + (i * 2), value);
- 
-		if (!basic_wep)
-			continue;
- 
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    offset + (i * 2) + 4 * BCM43xx_SEC_KEYSIZE,
-				    value);
-	}
-}
-
-static void keymac_write(struct bcm43xx_private *bcm,
-			 u8 index, const u32 *addr)
-{
-	/* for keys 0-3 there is no associated mac address */
-	if (index &lt; 4)
-		return;
-
-	index -= 4;
-	if (bcm-&gt;current_core-&gt;rev &gt;= 5) {
-		bcm43xx_shm_write32(bcm,
-				    BCM43xx_SHM_HWMAC,
-				    index * 2,
-				    cpu_to_be32(*addr));
-		bcm43xx_shm_write16(bcm,
-				    BCM43xx_SHM_HWMAC,
-				    (index * 2) + 1,
-				    cpu_to_be16(*((u16 *)(addr + 1))));
-	} else {
-		if (index &lt; 8) {
-			TODO(); /* Put them in the macaddress filter */
-		} else {
-			TODO();
-			/* Put them BCM43xx_SHM_SHARED, stating index 0x0120.
-			   Keep in mind to update the count of keymacs in 0x003E as well! */
-		}
-	}
-}
-
-static int bcm43xx_key_write(struct bcm43xx_private *bcm,
-			     u8 index, u8 algorithm,
-			     const u8 *_key, int key_len,
-			     const u8 *mac_addr)
-{
-	u8 key[BCM43xx_SEC_KEYSIZE] = { 0 };
-
-	if (index &gt;= ARRAY_SIZE(bcm-&gt;key))
-		return -EINVAL;
-	if (key_len &gt; ARRAY_SIZE(key))
-		return -EINVAL;
-	if (algorithm &lt; 1 || algorithm &gt; 5)
-		return -EINVAL;
-
-	memcpy(key, _key, key_len);
-	key_write(bcm, index, algorithm, (const u16 *)key);
-	keymac_write(bcm, index, (const u32 *)mac_addr);
-
-	bcm-&gt;key[index].algorithm = algorithm;
-
-	return 0;
-}
-
-static void bcm43xx_clear_keys(struct bcm43xx_private *bcm)
-{
-	static const u32 zero_mac[2] = { 0 };
-	unsigned int i,j, nr_keys = 54;
-	u16 offset;
-
-	if (bcm-&gt;current_core-&gt;rev &lt; 5)
-		nr_keys = 16;
-	assert(nr_keys &lt;= ARRAY_SIZE(bcm-&gt;key));
-
-	for (i = 0; i &lt; nr_keys; i++) {
-		bcm-&gt;key[i].enabled = 0;
-		/* returns for i &lt; 4 immediately */
-		keymac_write(bcm, i, zero_mac);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-				    0x100 + (i * 2), 0x0000);
-		for (j = 0; j &lt; 8; j++) {
-			offset = bcm-&gt;security_offset + (j * 4) + (i * BCM43xx_SEC_KEYSIZE);
-			bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
-					    offset, 0x0000);
-		}
-	}
-	dprintk(KERN_INFO PFX &quot;Keys cleared\n&quot;);
-}
-
-/* Lowlevel core-switch function. This is only to be used in
- * bcm43xx_switch_core() and bcm43xx_probe_cores()
- */
-static int _switch_core(struct bcm43xx_private *bcm, int core)
-{
-	int err;
-	int attempts = 0;
-	u32 current_core;
-
-	assert(core &gt;= 0);
-	while (1) {
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_ACTIVE_CORE,
-						 (core * 0x1000) + 0x18000000);
-		if (unlikely(err))
-			goto error;
-		err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_ACTIVE_CORE,
-						&amp;current_core);
-		if (unlikely(err))
-			goto error;
-		current_core = (current_core - 0x18000000) / 0x1000;
-		if (current_core == core)
-			break;
-
-		if (unlikely(attempts++ &gt; BCM43xx_SWITCH_CORE_MAX_RETRIES))
-			goto error;
-		udelay(10);
-	}
-
-	return 0;
-error:
-	printk(KERN_ERR PFX &quot;Failed to switch to core %d\n&quot;, core);
-	return -ENODEV;
-}
-
-int bcm43xx_switch_core(struct bcm43xx_private *bcm, struct bcm43xx_coreinfo *new_core)
-{
-	int err;
-
-	if (unlikely(!new_core))
-		return 0;
-	if (!new_core-&gt;available)
-		return -ENODEV;
-	if (bcm-&gt;current_core == new_core)
-		return 0;
-	err = _switch_core(bcm, new_core-&gt;index);
-	if (unlikely(err))
-		goto out;
-
-	bcm-&gt;current_core = new_core;
-out:
-	return err;
-}
-
-static int bcm43xx_core_enabled(struct bcm43xx_private *bcm)
-{
-	u32 value;
-
-	value = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	value &amp;= BCM43xx_SBTMSTATELOW_CLOCK | BCM43xx_SBTMSTATELOW_RESET
-		 | BCM43xx_SBTMSTATELOW_REJECT;
-
-	return (value == BCM43xx_SBTMSTATELOW_CLOCK);
-}
-
-/* disable current core */
-static int bcm43xx_core_disable(struct bcm43xx_private *bcm, u32 core_flags)
-{
-	u32 sbtmstatelow;
-	u32 sbtmstatehigh;
-	int i;
-
-	/* fetch sbtmstatelow from core information registers */
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-
-	/* core is already in reset */
-	if (sbtmstatelow &amp; BCM43xx_SBTMSTATELOW_RESET)
-		goto out;
-
-	if (sbtmstatelow &amp; BCM43xx_SBTMSTATELOW_CLOCK) {
-		sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-			       BCM43xx_SBTMSTATELOW_REJECT;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-
-		for (i = 0; i &lt; 1000; i++) {
-			sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-			if (sbtmstatelow &amp; BCM43xx_SBTMSTATELOW_REJECT) {
-				i = -1;
-				break;
-			}
-			udelay(10);
-		}
-		if (i != -1) {
-			printk(KERN_ERR PFX &quot;Error: core_disable() REJECT timeout!\n&quot;);
-			return -EBUSY;
-		}
-
-		for (i = 0; i &lt; 1000; i++) {
-			sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-			if (!(sbtmstatehigh &amp; BCM43xx_SBTMSTATEHIGH_BUSY)) {
-				i = -1;
-				break;
-			}
-			udelay(10);
-		}
-		if (i != -1) {
-			printk(KERN_ERR PFX &quot;Error: core_disable() BUSY timeout!\n&quot;);
-			return -EBUSY;
-		}
-
-		sbtmstatelow = BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-			       BCM43xx_SBTMSTATELOW_REJECT |
-			       BCM43xx_SBTMSTATELOW_RESET |
-			       BCM43xx_SBTMSTATELOW_CLOCK |
-			       core_flags;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-		udelay(10);
-	}
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_RESET |
-		       BCM43xx_SBTMSTATELOW_REJECT |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-
-out:
-	bcm-&gt;current_core-&gt;enabled = 0;
-
-	return 0;
-}
-
-/* enable (reset) current core */
-static int bcm43xx_core_enable(struct bcm43xx_private *bcm, u32 core_flags)
-{
-	u32 sbtmstatelow;
-	u32 sbtmstatehigh;
-	u32 sbimstate;
-	int err;
-
-	err = bcm43xx_core_disable(bcm, core_flags);
-	if (err)
-		goto out;
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-		       BCM43xx_SBTMSTATELOW_RESET |
-		       BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-	if (sbtmstatehigh &amp; BCM43xx_SBTMSTATEHIGH_SERROR) {
-		sbtmstatehigh = 0x00000000;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATEHIGH, sbtmstatehigh);
-	}
-
-	sbimstate = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMSTATE);
-	if (sbimstate &amp; (BCM43xx_SBIMSTATE_IB_ERROR | BCM43xx_SBIMSTATE_TIMEOUT)) {
-		sbimstate &amp;= ~(BCM43xx_SBIMSTATE_IB_ERROR | BCM43xx_SBIMSTATE_TIMEOUT);
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBIMSTATE, sbimstate);
-	}
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK |
-		       BCM43xx_SBTMSTATELOW_FORCE_GATE_CLOCK |
-		       core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	sbtmstatelow = BCM43xx_SBTMSTATELOW_CLOCK | core_flags;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-
-	bcm-&gt;current_core-&gt;enabled = 1;
-	assert(err == 0);
-out:
-	return err;
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/80211CoreReset">http://bcm-specs.sipsolutions.net/80211CoreReset</A> */
-void bcm43xx_wireless_core_reset(struct bcm43xx_private *bcm, int connect_phy)
-{
-	u32 flags = 0x00040000;
-
-	if ((bcm43xx_core_enabled(bcm)) &amp;&amp;
-	    !bcm43xx_using_pio(bcm)) {
-	}
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_SHUTTINGDOWN) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				&amp; ~(BCM43xx_SBF_MAC_ENABLED | 0x00000002));
-	} else {
-		if (connect_phy)
-			flags |= BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_phy_connect(bcm, connect_phy);
-		bcm43xx_core_enable(bcm, flags);
-		bcm43xx_write16(bcm, 0x03E6, 0x0000);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-				bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				| BCM43xx_SBF_400);
-	}
-}
-
-static void bcm43xx_wireless_core_disable(struct bcm43xx_private *bcm)
-{
-	bcm43xx_radio_turn_off(bcm);
-	bcm43xx_write16(bcm, 0x03E6, 0x00F4);
-	bcm43xx_core_disable(bcm, 0);
-}
-
-/* Mark the current 80211 core inactive. */
-static void bcm43xx_wireless_core_mark_inactive(struct bcm43xx_private *bcm)
-{
-	u32 sbtmstatelow;
-
-	bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-	bcm43xx_radio_turn_off(bcm);
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	sbtmstatelow &amp;= 0xDFF5FFFF;
-	sbtmstatelow |= 0x000A0000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-	sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	sbtmstatelow &amp;= 0xFFF5FFFF;
-	sbtmstatelow |= 0x00080000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	udelay(1);
-}
-
-static void handle_irq_transmit_status(struct bcm43xx_private *bcm)
-{
-	u32 v0, v1;
-	u16 tmp;
-	struct bcm43xx_xmitstatus stat;
-
-	while (1) {
-		v0 = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_0);
-		if (!v0)
-			break;
-		v1 = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_1);
-
-		stat.cookie = (v0 &gt;&gt; 16) &amp; 0x0000FFFF;
-		tmp = (u16)((v0 &amp; 0xFFF0) | ((v0 &amp; 0xF) &gt;&gt; 1));
-		stat.flags = tmp &amp; 0xFF;
-		stat.cnt1 = (tmp &amp; 0x0F00) &gt;&gt; 8;
-		stat.cnt2 = (tmp &amp; 0xF000) &gt;&gt; 12;
-		stat.seq = (u16)(v1 &amp; 0xFFFF);
-		stat.unknown = (u16)((v1 &gt;&gt; 16) &amp; 0xFF);
-
-		bcm43xx_debugfs_log_txstat(bcm, &amp;stat);
-
-		if (stat.flags &amp; BCM43xx_TXSTAT_FLAG_AMPDU)
-			continue;
-		if (stat.flags &amp; BCM43xx_TXSTAT_FLAG_INTER)
-			continue;
-
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_handle_xmitstatus(bcm, &amp;stat);
-		else
-			bcm43xx_dma_handle_xmitstatus(bcm, &amp;stat);
-	}
-}
-
-static void drain_txstatus_queue(struct bcm43xx_private *bcm)
-{
-	u32 dummy;
-
-	if (bcm-&gt;current_core-&gt;rev &lt; 5)
-		return;
-	/* Read all entries from the microcode TXstatus FIFO
-	 * and throw them away.
-	 */
-	while (1) {
-		dummy = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_0);
-		if (!dummy)
-			break;
-		dummy = bcm43xx_read32(bcm, BCM43xx_MMIO_XMITSTAT_1);
-	}
-}
-
-static void bcm43xx_generate_noise_sample(struct bcm43xx_private *bcm)
-{
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x408, 0x7F7F);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x40A, 0x7F7F);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD) | (1 &lt;&lt; 4));
-	assert(bcm-&gt;noisecalc.core_at_start == bcm-&gt;current_core);
-	assert(bcm-&gt;noisecalc.channel_at_start == bcm43xx_current_radio(bcm)-&gt;channel);
-}
-
-static void bcm43xx_calculate_link_quality(struct bcm43xx_private *bcm)
-{
-	/* Top half of Link Quality calculation. */
-
-	if (bcm-&gt;noisecalc.calculation_running)
-		return;
-	bcm-&gt;noisecalc.core_at_start = bcm-&gt;current_core;
-	bcm-&gt;noisecalc.channel_at_start = bcm43xx_current_radio(bcm)-&gt;channel;
-	bcm-&gt;noisecalc.calculation_running = 1;
-	bcm-&gt;noisecalc.nr_samples = 0;
-
-	bcm43xx_generate_noise_sample(bcm);
-}
-
-static void handle_irq_noise(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 tmp;
-	u8 noise[4];
-	u8 i, j;
-	s32 average;
-
-	/* Bottom half of Link Quality calculation. */
-
-	assert(bcm-&gt;noisecalc.calculation_running);
-	if (bcm-&gt;noisecalc.core_at_start != bcm-&gt;current_core ||
-	    bcm-&gt;noisecalc.channel_at_start != radio-&gt;channel)
-		goto drop_calculation;
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x408);
-	noise[0] = (tmp &amp; 0x00FF);
-	noise[1] = (tmp &amp; 0xFF00) &gt;&gt; 8;
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x40A);
-	noise[2] = (tmp &amp; 0x00FF);
-	noise[3] = (tmp &amp; 0xFF00) &gt;&gt; 8;
-	if (noise[0] == 0x7F || noise[1] == 0x7F ||
-	    noise[2] == 0x7F || noise[3] == 0x7F)
-		goto generate_new;
-
-	/* Get the noise samples. */
-	assert(bcm-&gt;noisecalc.nr_samples &lt; 8);
-	i = bcm-&gt;noisecalc.nr_samples;
-	noise[0] = limit_value(noise[0], 0, ARRAY_SIZE(radio-&gt;nrssi_lt) - 1);
-	noise[1] = limit_value(noise[1], 0, ARRAY_SIZE(radio-&gt;nrssi_lt) - 1);
-	noise[2] = limit_value(noise[2], 0, ARRAY_SIZE(radio-&gt;nrssi_lt) - 1);
-	noise[3] = limit_value(noise[3], 0, ARRAY_SIZE(radio-&gt;nrssi_lt) - 1);
-	bcm-&gt;noisecalc.samples[i][0] = radio-&gt;nrssi_lt[noise[0]];
-	bcm-&gt;noisecalc.samples[i][1] = radio-&gt;nrssi_lt[noise[1]];
-	bcm-&gt;noisecalc.samples[i][2] = radio-&gt;nrssi_lt[noise[2]];
-	bcm-&gt;noisecalc.samples[i][3] = radio-&gt;nrssi_lt[noise[3]];
-	bcm-&gt;noisecalc.nr_samples++;
-	if (bcm-&gt;noisecalc.nr_samples == 8) {
-		/* Calculate the Link Quality by the noise samples. */
-		average = 0;
-		for (i = 0; i &lt; 8; i++) {
-			for (j = 0; j &lt; 4; j++)
-				average += bcm-&gt;noisecalc.samples[i][j];
-		}
-		average /= (8 * 4);
-		average *= 125;
-		average += 64;
-		average /= 128;
-
-		tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x40C);
-		tmp = (tmp / 128) &amp; 0x1F;
-		if (tmp &gt;= 8)
-			average += 2;
-		else
-			average -= 25;
-		if (tmp == 8)
-			average -= 72;
-		else
-			average -= 48;
-
-		bcm-&gt;stats.noise = average;
-drop_calculation:
-		bcm-&gt;noisecalc.calculation_running = 0;
-		return;
-	}
-generate_new:
-	bcm43xx_generate_noise_sample(bcm);
-}
-
-static void handle_irq_ps(struct bcm43xx_private *bcm)
-{
-	if (bcm-&gt;ieee-&gt;iw_mode == IW_MODE_MASTER) {
-		///TODO: PS TBTT
-	} else {
-		if (1/*FIXME: the last PSpoll frame was sent successfully */)
-			bcm43xx_power_saving_ctl_bits(bcm, -1, -1);
-	}
-	if (bcm-&gt;ieee-&gt;iw_mode == IW_MODE_ADHOC)
-		bcm-&gt;reg124_set_0x4 = 1;
-	//FIXME else set to false?
-}
-
-static void handle_irq_reg124(struct bcm43xx_private *bcm)
-{
-	if (!bcm-&gt;reg124_set_0x4)
-		return;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD)
-			| 0x4);
-	//FIXME: reset reg124_set_0x4 to false?
-}
-
-static void handle_irq_pmq(struct bcm43xx_private *bcm)
-{
-	u32 tmp;
-
-	//TODO: AP mode.
-
-	while (1) {
-		tmp = bcm43xx_read32(bcm, BCM43xx_MMIO_PS_STATUS);
-		if (!(tmp &amp; 0x00000008))
-			break;
-	}
-	/* 16bit write is odd, but correct. */
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PS_STATUS, 0x0002);
-}
-
-static void bcm43xx_generate_beacon_template(struct bcm43xx_private *bcm,
-					     u16 ram_offset, u16 shm_size_offset)
-{
-	u32 value;
-	u16 size = 0;
-
-	/* Timestamp. */
-	//FIXME: assumption: The chip sets the timestamp
-	value = 0;
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	size += 8;
-
-	/* Beacon Interval / Capability Information */
-	value = 0x0000;//FIXME: Which interval?
-	value |= (1 &lt;&lt; 0) &lt;&lt; 16; /* ESS */
-	value |= (1 &lt;&lt; 2) &lt;&lt; 16; /* CF Pollable */	//FIXME?
-	value |= (1 &lt;&lt; 3) &lt;&lt; 16; /* CF Poll Request */	//FIXME?
-	if (!bcm-&gt;ieee-&gt;open_wep)
-		value |= (1 &lt;&lt; 4) &lt;&lt; 16; /* Privacy */
-	bcm43xx_ram_write(bcm, ram_offset++, value);
-	size += 4;
-
-	/* SSID */
-	//TODO
-
-	/* FH Parameter Set */
-	//TODO
-
-	/* DS Parameter Set */
-	//TODO
-
-	/* CF Parameter Set */
-	//TODO
-
-	/* TIM */
-	//TODO
-
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, shm_size_offset, size);
-}
-
-static void handle_irq_beacon(struct bcm43xx_private *bcm)
-{
-	u32 status;
-
-	bcm-&gt;irq_savedstate &amp;= ~BCM43xx_IRQ_BEACON;
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD);
-
-	if ((status &amp; 0x1) &amp;&amp; (status &amp; 0x2)) {
-		/* ACK beacon IRQ. */
-		bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON,
-				BCM43xx_IRQ_BEACON);
-		bcm-&gt;irq_savedstate |= BCM43xx_IRQ_BEACON;
-		return;
-	}
-	if (!(status &amp; 0x1)) {
-		bcm43xx_generate_beacon_template(bcm, 0x68, 0x18);
-		status |= 0x1;
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD, status);
-	}
-	if (!(status &amp; 0x2)) {
-		bcm43xx_generate_beacon_template(bcm, 0x468, 0x1A);
-		status |= 0x2;
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS2_BITFIELD, status);
-	}
-}
-
-/* Interrupt handler bottom-half */
-static void bcm43xx_interrupt_tasklet(struct bcm43xx_private *bcm)
-{
-	u32 reason;
-	u32 dma_reason[6];
-	u32 merged_dma_reason = 0;
-	int i, activity = 0;
-	unsigned long flags;
-
-#ifdef CONFIG_BCM43XX_DEBUG
-	u32 _handled = 0x00000000;
-# define bcmirq_handled(irq)	do { _handled |= (irq); } while (0)
-#else
-# define bcmirq_handled(irq)	do { /* nothing */ } while (0)
-#endif /* CONFIG_BCM43XX_DEBUG*/
-
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	reason = bcm-&gt;irq_reason;
-	for (i = 5; i &gt;= 0; i--) {
-		dma_reason[i] = bcm-&gt;dma_reason[i];
-		merged_dma_reason |= dma_reason[i];
-	}
-
-	if (unlikely(reason &amp; BCM43xx_IRQ_XMIT_ERROR)) {
-		/* TX error. We get this when Template Ram is written in wrong endianess
-		 * in dummy_tx(). We also get this if something is wrong with the TX header
-		 * on DMA or PIO queues.
-		 * Maybe we get this in other error conditions, too.
-		 */
-		printkl(KERN_ERR PFX &quot;FATAL ERROR: BCM43xx_IRQ_XMIT_ERROR\n&quot;);
-		bcmirq_handled(BCM43xx_IRQ_XMIT_ERROR);
-	}
-	if (unlikely(merged_dma_reason &amp; BCM43xx_DMAIRQ_FATALMASK)) {
-		printkl(KERN_ERR PFX &quot;FATAL ERROR: Fatal DMA error: &quot;
-				     &quot;0x%08X, 0x%08X, 0x%08X, &quot;
-				     &quot;0x%08X, 0x%08X, 0x%08X\n&quot;,
-		        dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3],
-			dma_reason[4], dma_reason[5]);
-		bcm43xx_controller_restart(bcm, &quot;DMA error&quot;);
-		mmiowb();
-		spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-		return;
-	}
-	if (unlikely(merged_dma_reason &amp; BCM43xx_DMAIRQ_NONFATALMASK)) {
-		printkl(KERN_ERR PFX &quot;DMA error: &quot;
-				     &quot;0x%08X, 0x%08X, 0x%08X, &quot;
-				     &quot;0x%08X, 0x%08X, 0x%08X\n&quot;,
-		        dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3],
-			dma_reason[4], dma_reason[5]);
-	}
-
-	if (reason &amp; BCM43xx_IRQ_PS) {
-		handle_irq_ps(bcm);
-		bcmirq_handled(BCM43xx_IRQ_PS);
-	}
-
-	if (reason &amp; BCM43xx_IRQ_REG124) {
-		handle_irq_reg124(bcm);
-		bcmirq_handled(BCM43xx_IRQ_REG124);
-	}
-
-	if (reason &amp; BCM43xx_IRQ_BEACON) {
-		if (bcm-&gt;ieee-&gt;iw_mode == IW_MODE_MASTER)
-			handle_irq_beacon(bcm);
-		bcmirq_handled(BCM43xx_IRQ_BEACON);
-	}
-
-	if (reason &amp; BCM43xx_IRQ_PMQ) {
-		handle_irq_pmq(bcm);
-		bcmirq_handled(BCM43xx_IRQ_PMQ);
-	}
-
-	if (reason &amp; BCM43xx_IRQ_SCAN) {
-		/*TODO*/
-		//bcmirq_handled(BCM43xx_IRQ_SCAN);
-	}
-
-	if (reason &amp; BCM43xx_IRQ_NOISE) {
-		handle_irq_noise(bcm);
-		bcmirq_handled(BCM43xx_IRQ_NOISE);
-	}
-
-	/* Check the DMA reason registers for received data. */
-	if (dma_reason[0] &amp; BCM43xx_DMAIRQ_RX_DONE) {
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_rx(bcm43xx_current_pio(bcm)-&gt;queue0);
-		else
-			bcm43xx_dma_rx(bcm43xx_current_dma(bcm)-&gt;rx_ring0);
-		/* We intentionally don't set &quot;activity&quot; to 1, here. */
-	}
-	assert(!(dma_reason[1] &amp; BCM43xx_DMAIRQ_RX_DONE));
-	assert(!(dma_reason[2] &amp; BCM43xx_DMAIRQ_RX_DONE));
-	if (dma_reason[3] &amp; BCM43xx_DMAIRQ_RX_DONE) {
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_rx(bcm43xx_current_pio(bcm)-&gt;queue3);
-		else
-			bcm43xx_dma_rx(bcm43xx_current_dma(bcm)-&gt;rx_ring3);
-		activity = 1;
-	}
-	assert(!(dma_reason[4] &amp; BCM43xx_DMAIRQ_RX_DONE));
-	assert(!(dma_reason[5] &amp; BCM43xx_DMAIRQ_RX_DONE));
-	bcmirq_handled(BCM43xx_IRQ_RX);
-
-	if (reason &amp; BCM43xx_IRQ_XMIT_STATUS) {
-		handle_irq_transmit_status(bcm);
-		activity = 1;
-		//TODO: In AP mode, this also causes sending of powersave responses.
-		bcmirq_handled(BCM43xx_IRQ_XMIT_STATUS);
-	}
-
-	/* IRQ_PIO_WORKAROUND is handled in the top-half. */
-	bcmirq_handled(BCM43xx_IRQ_PIO_WORKAROUND);
-#ifdef CONFIG_BCM43XX_DEBUG
-	if (unlikely(reason &amp; ~_handled)) {
-		printkl(KERN_WARNING PFX
-			&quot;Unhandled IRQ! Reason: 0x%08x,  Unhandled: 0x%08x,  &quot;
-			&quot;DMA: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n&quot;,
-			reason, (reason &amp; ~_handled),
-			dma_reason[0], dma_reason[1],
-			dma_reason[2], dma_reason[3]);
-	}
-#endif
-#undef bcmirq_handled
-
-	if (!modparam_noleds)
-		bcm43xx_leds_update(bcm, activity);
-	bcm43xx_interrupt_enable(bcm, bcm-&gt;irq_savedstate);
-	mmiowb();
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-}
-
-static void pio_irq_workaround(struct bcm43xx_private *bcm,
-			       u16 base, int queueidx)
-{
-	u16 rxctl;
-
-	rxctl = bcm43xx_read16(bcm, base + BCM43xx_PIO_RXCTL);
-	if (rxctl &amp; BCM43xx_PIO_RXCTL_DATAAVAILABLE)
-		bcm-&gt;dma_reason[queueidx] |= BCM43xx_DMAIRQ_RX_DONE;
-	else
-		bcm-&gt;dma_reason[queueidx] &amp;= ~BCM43xx_DMAIRQ_RX_DONE;
-}
-
-static void bcm43xx_interrupt_ack(struct bcm43xx_private *bcm, u32 reason)
-{
-	if (bcm43xx_using_pio(bcm) &amp;&amp;
-	    (bcm-&gt;current_core-&gt;rev &lt; 3) &amp;&amp;
-	    (!(reason &amp; BCM43xx_IRQ_PIO_WORKAROUND))) {
-		/* Apply a PIO specific workaround to the dma_reasons */
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO1_BASE, 0);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO2_BASE, 1);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO3_BASE, 2);
-		pio_irq_workaround(bcm, BCM43xx_MMIO_PIO4_BASE, 3);
-	}
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, reason);
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA0_REASON,
-			bcm-&gt;dma_reason[0]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA1_REASON,
-			bcm-&gt;dma_reason[1]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA2_REASON,
-			bcm-&gt;dma_reason[2]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA3_REASON,
-			bcm-&gt;dma_reason[3]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA4_REASON,
-			bcm-&gt;dma_reason[4]);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA5_REASON,
-			bcm-&gt;dma_reason[5]);
-}
-
-/* Interrupt handler top-half */
-static irqreturn_t bcm43xx_interrupt_handler(int irq, void *dev_id)
-{
-	irqreturn_t ret = IRQ_HANDLED;
-	struct bcm43xx_private *bcm = dev_id;
-	u32 reason;
-
-	if (!bcm)
-		return IRQ_NONE;
-
-	spin_lock(&amp;bcm-&gt;irq_lock);
-
-	reason = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-	if (reason == 0xffffffff) {
-		/* irq not for us (shared irq) */
-		ret = IRQ_NONE;
-		goto out;
-	}
-	reason &amp;= bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_MASK);
-	if (!reason)
-		goto out;
-
-	assert(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED);
-	assert(bcm-&gt;current_core-&gt;id == BCM43xx_COREID_80211);
-
-	bcm-&gt;dma_reason[0] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA0_REASON)
-			     &amp; 0x0001DC00;
-	bcm-&gt;dma_reason[1] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA1_REASON)
-			     &amp; 0x0000DC00;
-	bcm-&gt;dma_reason[2] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA2_REASON)
-			     &amp; 0x0000DC00;
-	bcm-&gt;dma_reason[3] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA3_REASON)
-			     &amp; 0x0001DC00;
-	bcm-&gt;dma_reason[4] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA4_REASON)
-			     &amp; 0x0000DC00;
-	bcm-&gt;dma_reason[5] = bcm43xx_read32(bcm, BCM43xx_MMIO_DMA5_REASON)
-			     &amp; 0x0000DC00;
-
-	bcm43xx_interrupt_ack(bcm, reason);
-
-	/* disable all IRQs. They are enabled again in the bottom half. */
-	bcm-&gt;irq_savedstate = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-	/* save the reason code and call our bottom half. */
-	bcm-&gt;irq_reason = reason;
-	tasklet_schedule(&amp;bcm-&gt;isr_tasklet);
-
-out:
-	mmiowb();
-	spin_unlock(&amp;bcm-&gt;irq_lock);
-
-	return ret;
-}
-
-static void bcm43xx_release_firmware(struct bcm43xx_private *bcm, int force)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	if (bcm-&gt;firmware_norelease &amp;&amp; !force)
-		return; /* Suspending or controller reset. */
-	release_firmware(phy-&gt;ucode);
-	phy-&gt;ucode = NULL;
-	release_firmware(phy-&gt;pcm);
-	phy-&gt;pcm = NULL;
-	release_firmware(phy-&gt;initvals0);
-	phy-&gt;initvals0 = NULL;
-	release_firmware(phy-&gt;initvals1);
-	phy-&gt;initvals1 = NULL;
-}
-
-static int bcm43xx_request_firmware(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u8 rev = bcm-&gt;current_core-&gt;rev;
-	int err = 0;
-	int nr;
-	char buf[22 + sizeof(modparam_fwpostfix) - 1] = { 0 };
-
-	if (!phy-&gt;ucode) {
-		snprintf(buf, ARRAY_SIZE(buf), &quot;bcm43xx_microcode%d%s.fw&quot;,
-			 (rev &gt;= 5 ? 5 : rev),
-			 modparam_fwpostfix);
-		err = request_firmware(&amp;phy-&gt;ucode, buf, &amp;bcm-&gt;pci_dev-&gt;dev);
-		if (err) {
-			printk(KERN_ERR PFX 
-			       &quot;Error: Microcode \&quot;%s\&quot; not available or load failed.\n&quot;,
-			        buf);
-			goto error;
-		}
-	}
-
-	if (!phy-&gt;pcm) {
-		snprintf(buf, ARRAY_SIZE(buf),
-			 &quot;bcm43xx_pcm%d%s.fw&quot;,
-			 (rev &lt; 5 ? 4 : 5),
-			 modparam_fwpostfix);
-		err = request_firmware(&amp;phy-&gt;pcm, buf, &amp;bcm-&gt;pci_dev-&gt;dev);
-		if (err) {
-			printk(KERN_ERR PFX
-			       &quot;Error: PCM \&quot;%s\&quot; not available or load failed.\n&quot;,
-			       buf);
-			goto error;
-		}
-	}
-
-	if (!phy-&gt;initvals0) {
-		if (rev == 2 || rev == 4) {
-			switch (phy-&gt;type) {
-			case BCM43xx_PHYTYPE_A:
-				nr = 3;
-				break;
-			case BCM43xx_PHYTYPE_B:
-			case BCM43xx_PHYTYPE_G:
-				nr = 1;
-				break;
-			default:
-				goto err_noinitval;
-			}
-		
-		} else if (rev &gt;= 5) {
-			switch (phy-&gt;type) {
-			case BCM43xx_PHYTYPE_A:
-				nr = 7;
-				break;
-			case BCM43xx_PHYTYPE_B:
-			case BCM43xx_PHYTYPE_G:
-				nr = 5;
-				break;
-			default:
-				goto err_noinitval;
-			}
-		} else
-			goto err_noinitval;
-		snprintf(buf, ARRAY_SIZE(buf), &quot;bcm43xx_initval%02d%s.fw&quot;,
-			 nr, modparam_fwpostfix);
-
-		err = request_firmware(&amp;phy-&gt;initvals0, buf, &amp;bcm-&gt;pci_dev-&gt;dev);
-		if (err) {
-			printk(KERN_ERR PFX 
-			       &quot;Error: InitVals \&quot;%s\&quot; not available or load failed.\n&quot;,
-			        buf);
-			goto error;
-		}
-		if (phy-&gt;initvals0-&gt;size % sizeof(struct bcm43xx_initval)) {
-			printk(KERN_ERR PFX &quot;InitVals fileformat error.\n&quot;);
-			goto error;
-		}
-	}
-
-	if (!phy-&gt;initvals1) {
-		if (rev &gt;= 5) {
-			u32 sbtmstatehigh;
-
-			switch (phy-&gt;type) {
-			case BCM43xx_PHYTYPE_A:
-				sbtmstatehigh = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-				if (sbtmstatehigh &amp; 0x00010000)
-					nr = 9;
-				else
-					nr = 10;
-				break;
-			case BCM43xx_PHYTYPE_B:
-			case BCM43xx_PHYTYPE_G:
-					nr = 6;
-				break;
-			default:
-				goto err_noinitval;
-			}
-			snprintf(buf, ARRAY_SIZE(buf), &quot;bcm43xx_initval%02d%s.fw&quot;,
-				 nr, modparam_fwpostfix);
-
-			err = request_firmware(&amp;phy-&gt;initvals1, buf, &amp;bcm-&gt;pci_dev-&gt;dev);
-			if (err) {
-				printk(KERN_ERR PFX 
-				       &quot;Error: InitVals \&quot;%s\&quot; not available or load failed.\n&quot;,
-			        	buf);
-				goto error;
-			}
-			if (phy-&gt;initvals1-&gt;size % sizeof(struct bcm43xx_initval)) {
-				printk(KERN_ERR PFX &quot;InitVals fileformat error.\n&quot;);
-				goto error;
-			}
-		}
-	}
-
-out:
-	return err;
-error:
-	bcm43xx_release_firmware(bcm, 1);
-	goto out;
-err_noinitval:
-	printk(KERN_ERR PFX &quot;Error: No InitVals available!\n&quot;);
-	err = -ENOENT;
-	goto error;
-}
-
-static void bcm43xx_upload_microcode(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	const u32 *data;
-	unsigned int i, len;
-
-	/* Upload Microcode. */
-	data = (u32 *)(phy-&gt;ucode-&gt;data);
-	len = phy-&gt;ucode-&gt;size / sizeof(u32);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_UCODE, 0x0000);
-	for (i = 0; i &lt; len; i++) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA,
-				be32_to_cpu(data[i]));
-		udelay(10);
-	}
-
-	/* Upload PCM data. */
-	data = (u32 *)(phy-&gt;pcm-&gt;data);
-	len = phy-&gt;pcm-&gt;size / sizeof(u32);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_PCM, 0x01ea);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA, 0x00004000);
-	bcm43xx_shm_control_word(bcm, BCM43xx_SHM_PCM, 0x01eb);
-	for (i = 0; i &lt; len; i++) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_SHM_DATA,
-				be32_to_cpu(data[i]));
-		udelay(10);
-	}
-}
-
-static int bcm43xx_write_initvals(struct bcm43xx_private *bcm,
-				  const struct bcm43xx_initval *data,
-				  const unsigned int len)
-{
-	u16 offset, size;
-	u32 value;
-	unsigned int i;
-
-	for (i = 0; i &lt; len; i++) {
-		offset = be16_to_cpu(data[i].offset);
-		size = be16_to_cpu(data[i].size);
-		value = be32_to_cpu(data[i].value);
-
-		if (unlikely(offset &gt;= 0x1000))
-			goto err_format;
-		if (size == 2) {
-			if (unlikely(value &amp; 0xFFFF0000))
-				goto err_format;
-			bcm43xx_write16(bcm, offset, (u16)value);
-		} else if (size == 4) {
-			bcm43xx_write32(bcm, offset, value);
-		} else
-			goto err_format;
-	}
-
-	return 0;
-
-err_format:
-	printk(KERN_ERR PFX &quot;InitVals (bcm43xx_initvalXX.fw) file-format error. &quot;
-			    &quot;Please fix your bcm43xx firmware files.\n&quot;);
-	return -EPROTO;
-}
-
-static int bcm43xx_upload_initvals(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	int err;
-
-	err = bcm43xx_write_initvals(bcm, (struct bcm43xx_initval *)phy-&gt;initvals0-&gt;data,
-				     phy-&gt;initvals0-&gt;size / sizeof(struct bcm43xx_initval));
-	if (err)
-		goto out;
-	if (phy-&gt;initvals1) {
-		err = bcm43xx_write_initvals(bcm, (struct bcm43xx_initval *)phy-&gt;initvals1-&gt;data,
-					     phy-&gt;initvals1-&gt;size / sizeof(struct bcm43xx_initval));
-		if (err)
-			goto out;
-	}
-out:
-	return err;
-}
-
-static int bcm43xx_initialize_irq(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	bcm-&gt;irq = bcm-&gt;pci_dev-&gt;irq;
-	err = request_irq(bcm-&gt;irq, bcm43xx_interrupt_handler,
-			  IRQF_SHARED, KBUILD_MODNAME, bcm);
-	if (err)
-		printk(KERN_ERR PFX &quot;Cannot register IRQ%d\n&quot;, bcm-&gt;irq);
-
-	return err;
-}
-
-/* Switch to the core used to write the GPIO register.
- * This is either the ChipCommon, or the PCI core.
- */
-static int switch_to_gpio_core(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	/* Where to find the GPIO register depends on the chipset.
-	 * If it has a ChipCommon, its register at offset 0x6c is the GPIO
-	 * control register. Otherwise the register at offset 0x6c in the
-	 * PCI core is the GPIO control register.
-	 */
-	err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_chipcommon);
-	if (err == -ENODEV) {
-		err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_pci);
-		if (unlikely(err == -ENODEV)) {
-			printk(KERN_ERR PFX &quot;gpio error: &quot;
-			       &quot;Neither ChipCommon nor PCI core available!\n&quot;);
-		}
-	}
-
-	return err;
-}
-
-/* Initialize the GPIOs
- * <A HREF="http://bcm-specs.sipsolutions.net/GPIO">http://bcm-specs.sipsolutions.net/GPIO</A>
- */
-static int bcm43xx_gpio_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_coreinfo *old_core;
-	int err;
-	u32 mask, set;
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-			bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-			&amp; 0xFFFF3FFF);
-
-	bcm43xx_leds_switch_all(bcm, 0);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-			bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK) | 0x000F);
-
-	mask = 0x0000001F;
-	set = 0x0000000F;
-	if (bcm-&gt;chip_id == 0x4301) {
-		mask |= 0x0060;
-		set |= 0x0060;
-	}
-	if (0 /* FIXME: conditional unknown */) {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-				bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK)
-				| 0x0100);
-		mask |= 0x0180;
-		set |= 0x0180;
-	}
-	if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_PACTRL) {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_GPIO_MASK,
-				bcm43xx_read16(bcm, BCM43xx_MMIO_GPIO_MASK)
-				| 0x0200);
-		mask |= 0x0200;
-		set |= 0x0200;
-	}
-	if (bcm-&gt;current_core-&gt;rev &gt;= 2)
-		mask  |= 0x0010; /* FIXME: This is redundant. */
-
-	old_core = bcm-&gt;current_core;
-	err = switch_to_gpio_core(bcm);
-	if (err)
-		goto out;
-	bcm43xx_write32(bcm, BCM43xx_GPIO_CONTROL,
-	                (bcm43xx_read32(bcm, BCM43xx_GPIO_CONTROL) &amp; mask) | set);
-	err = bcm43xx_switch_core(bcm, old_core);
-out:
-	return err;
-}
-
-/* Turn off all GPIO stuff. Call this on module unload, for example. */
-static int bcm43xx_gpio_cleanup(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_coreinfo *old_core;
-	int err;
-
-	old_core = bcm-&gt;current_core;
-	err = switch_to_gpio_core(bcm);
-	if (err)
-		return err;
-	bcm43xx_write32(bcm, BCM43xx_GPIO_CONTROL, 0x00000000);
-	err = bcm43xx_switch_core(bcm, old_core);
-	assert(err == 0);
-
-	return 0;
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/EnableMac">http://bcm-specs.sipsolutions.net/EnableMac</A> */
-void bcm43xx_mac_enable(struct bcm43xx_private *bcm)
-{
-	bcm-&gt;mac_suspended--;
-	assert(bcm-&gt;mac_suspended &gt;= 0);
-	if (bcm-&gt;mac_suspended == 0) {
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				| BCM43xx_SBF_MAC_ENABLED);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, BCM43xx_IRQ_READY);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD); /* dummy read */
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-		bcm43xx_power_saving_ctl_bits(bcm, -1, -1);
-	}
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/SuspendMAC">http://bcm-specs.sipsolutions.net/SuspendMAC</A> */
-void bcm43xx_mac_suspend(struct bcm43xx_private *bcm)
-{
-	int i;
-	u32 tmp;
-
-	assert(bcm-&gt;mac_suspended &gt;= 0);
-	if (bcm-&gt;mac_suspended == 0) {
-		bcm43xx_power_saving_ctl_bits(bcm, -1, 1);
-		bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-		                bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD)
-				&amp; ~BCM43xx_SBF_MAC_ENABLED);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-		for (i = 10000; i; i--) {
-			tmp = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-			if (tmp &amp; BCM43xx_IRQ_READY)
-				goto out;
-			udelay(1);
-		}
-		printkl(KERN_ERR PFX &quot;MAC suspend failed\n&quot;);
-	}
-out:
-	bcm-&gt;mac_suspended++;
-}
-
-void bcm43xx_set_iwmode(struct bcm43xx_private *bcm,
-			int iw_mode)
-{
-	unsigned long flags;
-	struct net_device *net_dev = bcm-&gt;net_dev;
-	u32 status;
-	u16 value;
-
-	spin_lock_irqsave(&amp;bcm-&gt;ieee-&gt;lock, flags);
-	bcm-&gt;ieee-&gt;iw_mode = iw_mode;
-	spin_unlock_irqrestore(&amp;bcm-&gt;ieee-&gt;lock, flags);
-	if (iw_mode == IW_MODE_MONITOR)
-		net_dev-&gt;type = ARPHRD_IEEE80211;
-	else
-		net_dev-&gt;type = ARPHRD_ETHER;
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	/* Reset status to infrastructured mode */
-	status &amp;= ~(BCM43xx_SBF_MODE_AP | BCM43xx_SBF_MODE_MONITOR);
-	status &amp;= ~BCM43xx_SBF_MODE_PROMISC;
-	status |= BCM43xx_SBF_MODE_NOTADHOC;
-
-/* FIXME: Always enable promisc mode, until we get the MAC filters working correctly. */
-status |= BCM43xx_SBF_MODE_PROMISC;
-
-	switch (iw_mode) {
-	case IW_MODE_MONITOR:
-		status |= BCM43xx_SBF_MODE_MONITOR;
-		status |= BCM43xx_SBF_MODE_PROMISC;
-		break;
-	case IW_MODE_ADHOC:
-		status &amp;= ~BCM43xx_SBF_MODE_NOTADHOC;
-		break;
-	case IW_MODE_MASTER:
-		status |= BCM43xx_SBF_MODE_AP;
-		break;
-	case IW_MODE_SECOND:
-	case IW_MODE_REPEAT:
-		TODO(); /* TODO */
-		break;
-	case IW_MODE_INFRA:
-		/* nothing to be done here... */
-		break;
-	default:
-		dprintk(KERN_ERR PFX &quot;Unknown mode in set_iwmode: %d\n&quot;, iw_mode);
-	}
-	if (net_dev-&gt;flags &amp; IFF_PROMISC)
-		status |= BCM43xx_SBF_MODE_PROMISC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-
-	value = 0x0002;
-	if (iw_mode != IW_MODE_ADHOC &amp;&amp; iw_mode != IW_MODE_MASTER) {
-		if (bcm-&gt;chip_id == 0x4306 &amp;&amp; bcm-&gt;chip_rev == 3)
-			value = 0x0064;
-		else
-			value = 0x0032;
-	}
-	bcm43xx_write16(bcm, 0x0612, value);
-}
-
-/* This is the opposite of bcm43xx_chip_init() */
-static void bcm43xx_chip_cleanup(struct bcm43xx_private *bcm)
-{
-	bcm43xx_radio_turn_off(bcm);
-	if (!modparam_noleds)
-		bcm43xx_leds_exit(bcm);
-	bcm43xx_gpio_cleanup(bcm);
-	bcm43xx_release_firmware(bcm, 0);
-}
-
-/* Initialize the chip
- * <A HREF="http://bcm-specs.sipsolutions.net/ChipInit">http://bcm-specs.sipsolutions.net/ChipInit</A>
- */
-static int bcm43xx_chip_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	int err;
-	int i, tmp;
-	u32 value32;
-	u16 value16;
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD,
-			BCM43xx_SBF_CORE_READY
-			| BCM43xx_SBF_400);
-
-	err = bcm43xx_request_firmware(bcm);
-	if (err)
-		goto out;
-	bcm43xx_upload_microcode(bcm);
-
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, 0xFFFFFFFF);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, 0x00020402);
-	i = 0;
-	while (1) {
-		value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-		if (value32 == BCM43xx_IRQ_READY)
-			break;
-		i++;
-		if (i &gt;= BCM43xx_IRQWAIT_MAX_RETRIES) {
-			printk(KERN_ERR PFX &quot;IRQ_READY timeout\n&quot;);
-			err = -ENODEV;
-			goto err_release_fw;
-		}
-		udelay(10);
-	}
-	bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-
-	value16 = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				     BCM43xx_UCODE_REVISION);
-
-	dprintk(KERN_INFO PFX &quot;Microcode rev 0x%x, pl 0x%x &quot;
-		&quot;(20%.2i-%.2i-%.2i  %.2i:%.2i:%.2i)\n&quot;, value16,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_PATCHLEVEL),
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODE_DATE) &gt;&gt; 12) &amp; 0xf,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODE_DATE) &gt;&gt; 8) &amp; 0xf,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_DATE) &amp; 0xff,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) &gt;&gt; 11) &amp; 0x1f,
-		(bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) &gt;&gt; 5) &amp; 0x3f,
-		bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				   BCM43xx_UCODE_TIME) &amp; 0x1f);
-
-	if ( value16 &gt; 0x128 ) {
-		printk(KERN_ERR PFX
-			&quot;Firmware: no support for microcode extracted &quot;
-			&quot;from version 4.x binary drivers.\n&quot;);
-		err = -EOPNOTSUPP;
-		goto err_release_fw;
-	}
-
-	err = bcm43xx_gpio_init(bcm);
-	if (err)
-		goto err_release_fw;
-
-	err = bcm43xx_upload_initvals(bcm);
-	if (err)
-		goto err_gpio_cleanup;
-	bcm43xx_radio_turn_on(bcm);
-	bcm-&gt;radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
-	printk(KERN_INFO PFX &quot;Radio %s by hardware\n&quot;,
-		(bcm-&gt;radio_hw_enable == 0) ? &quot;disabled&quot; : &quot;enabled&quot;);
-
-	bcm43xx_write16(bcm, 0x03E6, 0x0000);
-	err = bcm43xx_phy_init(bcm);
-	if (err)
-		goto err_radio_off;
-
-	/* Select initial Interference Mitigation. */
-	tmp = radio-&gt;interfmode;
-	radio-&gt;interfmode = BCM43xx_RADIO_INTERFMODE_NONE;
-	bcm43xx_radio_set_interference_mitigation(bcm, tmp);
-
-	bcm43xx_phy_set_antenna_diversity(bcm);
-	bcm43xx_radio_set_txantenna(bcm, BCM43xx_RADIO_TXANTENNA_DEFAULT);
-	if (phy-&gt;type == BCM43xx_PHYTYPE_B) {
-		value16 = bcm43xx_read16(bcm, 0x005E);
-		value16 |= 0x0004;
-		bcm43xx_write16(bcm, 0x005E, value16);
-	}
-	bcm43xx_write32(bcm, 0x0100, 0x01000000);
-	if (bcm-&gt;current_core-&gt;rev &lt; 5)
-		bcm43xx_write32(bcm, 0x010C, 0x01000000);
-
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	value32 &amp;= ~ BCM43xx_SBF_MODE_NOTADHOC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	value32 |= BCM43xx_SBF_MODE_NOTADHOC;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
-
-	value32 = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	value32 |= 0x100000;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value32);
-
-	if (bcm43xx_using_pio(bcm)) {
-		bcm43xx_write32(bcm, 0x0210, 0x00000100);
-		bcm43xx_write32(bcm, 0x0230, 0x00000100);
-		bcm43xx_write32(bcm, 0x0250, 0x00000100);
-		bcm43xx_write32(bcm, 0x0270, 0x00000100);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0034, 0x0000);
-	}
-
-	/* Probe Response Timeout value */
-	/* FIXME: Default to 0, has to be set by ioctl probably... :-/ */
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0074, 0x0000);
-
-	/* Initially set the wireless operation mode. */
-	bcm43xx_set_iwmode(bcm, bcm-&gt;ieee-&gt;iw_mode);
-
-	if (bcm-&gt;current_core-&gt;rev &lt; 3) {
-		bcm43xx_write16(bcm, 0x060E, 0x0000);
-		bcm43xx_write16(bcm, 0x0610, 0x8000);
-		bcm43xx_write16(bcm, 0x0604, 0x0000);
-		bcm43xx_write16(bcm, 0x0606, 0x0200);
-	} else {
-		bcm43xx_write32(bcm, 0x0188, 0x80000000);
-		bcm43xx_write32(bcm, 0x018C, 0x02000000);
-	}
-	bcm43xx_write32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON, 0x00004000);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA0_IRQ_MASK, 0x0001DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA1_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA2_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA3_IRQ_MASK, 0x0001DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA4_IRQ_MASK, 0x0000DC00);
-	bcm43xx_write32(bcm, BCM43xx_MMIO_DMA5_IRQ_MASK, 0x0000DC00);
-
-	value32 = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-	value32 |= 0x00100000;
-	bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, value32);
-
-	bcm43xx_write16(bcm, BCM43xx_MMIO_POWERUP_DELAY, bcm43xx_pctl_powerup_delay(bcm));
-
-	assert(err == 0);
-	dprintk(KERN_INFO PFX &quot;Chip initialized\n&quot;);
-out:
-	return err;
-
-err_radio_off:
-	bcm43xx_radio_turn_off(bcm);
-err_gpio_cleanup:
-	bcm43xx_gpio_cleanup(bcm);
-err_release_fw:
-	bcm43xx_release_firmware(bcm, 1);
-	goto out;
-}
-	
-/* Validate chip access
- * <A HREF="http://bcm-specs.sipsolutions.net/ValidateChipAccess">http://bcm-specs.sipsolutions.net/ValidateChipAccess</A> */
-static int bcm43xx_validate_chip(struct bcm43xx_private *bcm)
-{
-	u32 value;
-	u32 shm_backup;
-
-	shm_backup = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, 0xAA5555AA);
-	if (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000) != 0xAA5555AA)
-		goto error;
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, 0x55AAAA55);
-	if (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0000) != 0x55AAAA55)
-		goto error;
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED, 0x0000, shm_backup);
-
-	value = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	if ((value | 0x80000000) != 0x80000400)
-		goto error;
-
-	value = bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON);
-	if (value != 0x00000000)
-		goto error;
-
-	return 0;
-error:
-	printk(KERN_ERR PFX &quot;Failed to validate the chipaccess\n&quot;);
-	return -ENODEV;
-}
-
-static void bcm43xx_init_struct_phyinfo(struct bcm43xx_phyinfo *phy)
-{
-	/* Initialize a &quot;phyinfo&quot; structure. The structure is already
-	 * zeroed out.
-	 * This is called on insmod time to initialize members.
-	 */
-	phy-&gt;savedpctlreg = 0xFFFF;
-	spin_lock_init(&amp;phy-&gt;lock);
-}
-
-static void bcm43xx_init_struct_radioinfo(struct bcm43xx_radioinfo *radio)
-{
-	/* Initialize a &quot;radioinfo&quot; structure. The structure is already
-	 * zeroed out.
-	 * This is called on insmod time to initialize members.
-	 */
-	radio-&gt;interfmode = BCM43xx_RADIO_INTERFMODE_NONE;
-	radio-&gt;channel = 0xFF;
-	radio-&gt;initial_channel = 0xFF;
-}
-
-static int bcm43xx_probe_cores(struct bcm43xx_private *bcm)
-{
-	int err, i;
-	int current_core;
-	u32 core_vendor, core_id, core_rev;
-	u32 sb_id_hi, chip_id_32 = 0;
-	u16 pci_device, chip_id_16;
-	u8 core_count;
-
-	memset(&amp;bcm-&gt;core_chipcommon, 0, sizeof(struct bcm43xx_coreinfo));
-	memset(&amp;bcm-&gt;core_pci, 0, sizeof(struct bcm43xx_coreinfo));
-	memset(&amp;bcm-&gt;core_80211, 0, sizeof(struct bcm43xx_coreinfo)
-				    * BCM43xx_MAX_80211_CORES);
-	memset(&amp;bcm-&gt;core_80211_ext, 0, sizeof(struct bcm43xx_coreinfo_80211)
-					* BCM43xx_MAX_80211_CORES);
-	bcm-&gt;nr_80211_available = 0;
-	bcm-&gt;current_core = NULL;
-	bcm-&gt;active_80211_core = NULL;
-
-	/* map core 0 */
-	err = _switch_core(bcm, 0);
-	if (err)
-		goto out;
-
-	/* fetch sb_id_hi from core information registers */
-	sb_id_hi = bcm43xx_read32(bcm, BCM43xx_CIR_SB_ID_HI);
-
-	core_id = (sb_id_hi &amp; 0x8FF0) &gt;&gt; 4;
-	core_rev = (sb_id_hi &amp; 0x7000) &gt;&gt; 8;
-	core_rev |= (sb_id_hi &amp; 0xF);
-	core_vendor = (sb_id_hi &amp; 0xFFFF0000) &gt;&gt; 16;
-
-	/* if present, chipcommon is always core 0; read the chipid from it */
-	if (core_id == BCM43xx_COREID_CHIPCOMMON) {
-		chip_id_32 = bcm43xx_read32(bcm, 0);
-		chip_id_16 = chip_id_32 &amp; 0xFFFF;
-		bcm-&gt;core_chipcommon.available = 1;
-		bcm-&gt;core_chipcommon.id = core_id;
-		bcm-&gt;core_chipcommon.rev = core_rev;
-		bcm-&gt;core_chipcommon.index = 0;
-		/* While we are at it, also read the capabilities. */
-		bcm-&gt;chipcommon_capabilities = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_CAPABILITIES);
-	} else {
-		/* without a chipCommon, use a hard coded table. */
-		pci_device = bcm-&gt;pci_dev-&gt;device;
-		if (pci_device == 0x4301)
-			chip_id_16 = 0x4301;
-		else if ((pci_device &gt;= 0x4305) &amp;&amp; (pci_device &lt;= 0x4307))
-			chip_id_16 = 0x4307;
-		else if ((pci_device &gt;= 0x4402) &amp;&amp; (pci_device &lt;= 0x4403))
-			chip_id_16 = 0x4402;
-		else if ((pci_device &gt;= 0x4610) &amp;&amp; (pci_device &lt;= 0x4615))
-			chip_id_16 = 0x4610;
-		else if ((pci_device &gt;= 0x4710) &amp;&amp; (pci_device &lt;= 0x4715))
-			chip_id_16 = 0x4710;
-		else {
-			printk(KERN_ERR PFX &quot;Could not determine Chip ID\n&quot;);
-			return -ENODEV;
-		}
-	}
-
-	/* ChipCommon with Core Rev &gt;=4 encodes number of cores,
-	 * otherwise consult hardcoded table */
-	if ((core_id == BCM43xx_COREID_CHIPCOMMON) &amp;&amp; (core_rev &gt;= 4)) {
-		core_count = (chip_id_32 &amp; 0x0F000000) &gt;&gt; 24;
-	} else {
-		switch (chip_id_16) {
-			case 0x4610:
-			case 0x4704:
-			case 0x4710:
-				core_count = 9;
-				break;
-			case 0x4310:
-				core_count = 8;
-				break;
-			case 0x5365:
-				core_count = 7;
-				break;
-			case 0x4306:
-				core_count = 6;
-				break;
-			case 0x4301:
-			case 0x4307:
-				core_count = 5;
-				break;
-			case 0x4402:
-				core_count = 3;
-				break;
-			default:
-				/* SOL if we get here */
-				assert(0);
-				core_count = 1;
-		}
-	}
-
-	bcm-&gt;chip_id = chip_id_16;
-	bcm-&gt;chip_rev = (chip_id_32 &amp; 0x000F0000) &gt;&gt; 16;
-	bcm-&gt;chip_package = (chip_id_32 &amp; 0x00F00000) &gt;&gt; 20;
-
-	dprintk(KERN_INFO PFX &quot;Chip ID 0x%x, rev 0x%x\n&quot;,
-		bcm-&gt;chip_id, bcm-&gt;chip_rev);
-	dprintk(KERN_INFO PFX &quot;Number of cores: %d\n&quot;, core_count);
-	if (bcm-&gt;core_chipcommon.available) {
-		dprintk(KERN_INFO PFX &quot;Core 0: ID 0x%x, rev 0x%x, vendor 0x%x\n&quot;,
-			core_id, core_rev, core_vendor);
-		current_core = 1;
-	} else
-		current_core = 0;
-	for ( ; current_core &lt; core_count; current_core++) {
-		struct bcm43xx_coreinfo *core;
-		struct bcm43xx_coreinfo_80211 *ext_80211;
-
-		err = _switch_core(bcm, current_core);
-		if (err)
-			goto out;
-		/* Gather information */
-		/* fetch sb_id_hi from core information registers */
-		sb_id_hi = bcm43xx_read32(bcm, BCM43xx_CIR_SB_ID_HI);
-
-		/* extract core_id, core_rev, core_vendor */
-		core_id = (sb_id_hi &amp; 0x8FF0) &gt;&gt; 4;
-		core_rev = ((sb_id_hi &amp; 0xF) | ((sb_id_hi &amp; 0x7000) &gt;&gt; 8));
-		core_vendor = (sb_id_hi &amp; 0xFFFF0000) &gt;&gt; 16;
-
-		dprintk(KERN_INFO PFX &quot;Core %d: ID 0x%x, rev 0x%x, vendor 0x%x\n&quot;,
-			current_core, core_id, core_rev, core_vendor);
-
-		core = NULL;
-		switch (core_id) {
-		case BCM43xx_COREID_PCI:
-		case BCM43xx_COREID_PCIE:
-			core = &amp;bcm-&gt;core_pci;
-			if (core-&gt;available) {
-				printk(KERN_WARNING PFX &quot;Multiple PCI cores found.\n&quot;);
-				continue;
-			}
-			break;
-		case BCM43xx_COREID_80211:
-			for (i = 0; i &lt; BCM43xx_MAX_80211_CORES; i++) {
-				core = &amp;(bcm-&gt;core_80211[i]);
-				ext_80211 = &amp;(bcm-&gt;core_80211_ext[i]);
-				if (!core-&gt;available)
-					break;
-				core = NULL;
-			}
-			if (!core) {
-				printk(KERN_WARNING PFX &quot;More than %d cores of type 802.11 found.\n&quot;,
-				       BCM43xx_MAX_80211_CORES);
-				continue;
-			}
-			if (i != 0) {
-				/* More than one 80211 core is only supported
-				 * by special chips.
-				 * There are chips with two 80211 cores, but with
-				 * dangling pins on the second core. Be careful
-				 * and ignore these cores here.
-				 */
-				if (1 /*bcm-&gt;pci_dev-&gt;device != 0x4324*/ ) {
-				/* TODO: A PHY */
-					dprintk(KERN_INFO PFX &quot;Ignoring additional 802.11a core.\n&quot;);
-					continue;
-				}
-			}
-			switch (core_rev) {
-			case 2:
-			case 4:
-			case 5:
-			case 6:
-			case 7:
-			case 9:
-			case 10:
-				break;
-			default:
-				printk(KERN_WARNING PFX
-				       &quot;Unsupported 80211 core revision %u\n&quot;,
-				       core_rev);
-			}
-			bcm-&gt;nr_80211_available++;
-			core-&gt;priv = ext_80211;
-			bcm43xx_init_struct_phyinfo(&amp;ext_80211-&gt;phy);
-			bcm43xx_init_struct_radioinfo(&amp;ext_80211-&gt;radio);
-			break;
-		case BCM43xx_COREID_CHIPCOMMON:
-			printk(KERN_WARNING PFX &quot;Multiple CHIPCOMMON cores found.\n&quot;);
-			break;
-		}
-		if (core) {
-			core-&gt;available = 1;
-			core-&gt;id = core_id;
-			core-&gt;rev = core_rev;
-			core-&gt;index = current_core;
-		}
-	}
-
-	if (!bcm-&gt;core_80211[0].available) {
-		printk(KERN_ERR PFX &quot;Error: No 80211 core found!\n&quot;);
-		err = -ENODEV;
-		goto out;
-	}
-
-	err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_80211[0]);
-
-	assert(err == 0);
-out:
-	return err;
-}
-
-static void bcm43xx_gen_bssid(struct bcm43xx_private *bcm)
-{
-	const u8 *mac = (const u8*)(bcm-&gt;net_dev-&gt;dev_addr);
-	u8 *bssid = bcm-&gt;ieee-&gt;bssid;
-
-	switch (bcm-&gt;ieee-&gt;iw_mode) {
-	case IW_MODE_ADHOC:
-		random_ether_addr(bssid);
-		break;
-	case IW_MODE_MASTER:
-	case IW_MODE_INFRA:
-	case IW_MODE_REPEAT:
-	case IW_MODE_SECOND:
-	case IW_MODE_MONITOR:
-		memcpy(bssid, mac, ETH_ALEN);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-static void bcm43xx_rate_memory_write(struct bcm43xx_private *bcm,
-				      u16 rate,
-				      int is_ofdm)
-{
-	u16 offset;
-
-	if (is_ofdm) {
-		offset = 0x480;
-		offset += (bcm43xx_plcp_get_ratecode_ofdm(rate) &amp; 0x000F) * 2;
-	}
-	else {
-		offset = 0x4C0;
-		offset += (bcm43xx_plcp_get_ratecode_cck(rate) &amp; 0x000F) * 2;
-	}
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, offset + 0x20,
-			    bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, offset));
-}
-
-static void bcm43xx_rate_memory_init(struct bcm43xx_private *bcm)
-{
-	switch (bcm43xx_current_phy(bcm)-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-	case BCM43xx_PHYTYPE_G:
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_6MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_12MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_18MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_24MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_36MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_48MB, 1);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_OFDM_RATE_54MB, 1);
-	case BCM43xx_PHYTYPE_B:
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_1MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_2MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_5MB, 0);
-		bcm43xx_rate_memory_write(bcm, IEEE80211_CCK_RATE_11MB, 0);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-static void bcm43xx_wireless_core_cleanup(struct bcm43xx_private *bcm)
-{
-	bcm43xx_chip_cleanup(bcm);
-	bcm43xx_pio_free(bcm);
-	bcm43xx_dma_free(bcm);
-
-	bcm-&gt;current_core-&gt;initialized = 0;
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/80211Init">http://bcm-specs.sipsolutions.net/80211Init</A> */
-static int bcm43xx_wireless_core_init(struct bcm43xx_private *bcm,
-				      int active_wlcore)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u32 ucodeflags;
-	int err;
-	u32 sbimconfiglow;
-	u8 limit;
-
-	if (bcm-&gt;core_pci.rev &lt;= 5 &amp;&amp; bcm-&gt;core_pci.id != BCM43xx_COREID_PCIE) {
-		sbimconfiglow = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMCONFIGLOW);
-		sbimconfiglow &amp;= ~ BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_MASK;
-		sbimconfiglow &amp;= ~ BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_MASK;
-		if (bcm-&gt;bustype == BCM43xx_BUSTYPE_PCI)
-			sbimconfiglow |= 0x32;
-		else
-			sbimconfiglow |= 0x53;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBIMCONFIGLOW, sbimconfiglow);
-	}
-
-	bcm43xx_phy_calibrate(bcm);
-	err = bcm43xx_chip_init(bcm);
-	if (err)
-		goto out;
-
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0016, bcm-&gt;current_core-&gt;rev);
-	ucodeflags = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, BCM43xx_UCODEFLAGS_OFFSET);
-
-	if (0 /*FIXME: which condition has to be used here? */)
-		ucodeflags |= 0x00000010;
-
-	/* HW decryption needs to be set now */
-	ucodeflags |= 0x40000000;
-	
-	if (phy-&gt;type == BCM43xx_PHYTYPE_G) {
-		ucodeflags |= BCM43xx_UCODEFLAG_UNKBGPHY;
-		if (phy-&gt;rev == 1)
-			ucodeflags |= BCM43xx_UCODEFLAG_UNKGPHY;
-		if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_PACTRL)
-			ucodeflags |= BCM43xx_UCODEFLAG_UNKPACTRL;
-	} else if (phy-&gt;type == BCM43xx_PHYTYPE_B) {
-		ucodeflags |= BCM43xx_UCODEFLAG_UNKBGPHY;
-		if (phy-&gt;rev &gt;= 2 &amp;&amp; radio-&gt;version == 0x2050)
-			ucodeflags &amp;= ~BCM43xx_UCODEFLAG_UNKGPHY;
-	}
-
-	if (ucodeflags != bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-					     BCM43xx_UCODEFLAGS_OFFSET)) {
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODEFLAGS_OFFSET, ucodeflags);
-	}
-
-	/* Short/Long Retry Limit.
-	 * The retry-limit is a 4-bit counter. Enforce this to avoid overflowing
-	 * the chip-internal counter.
-	 */
-	limit = limit_value(modparam_short_retry, 0, 0xF);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0006, limit);
-	limit = limit_value(modparam_long_retry, 0, 0xF);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0007, limit);
-
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0044, 3);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0046, 2);
-
-	bcm43xx_rate_memory_init(bcm);
-
-	/* Minimum Contention Window */
-	if (phy-&gt;type == BCM43xx_PHYTYPE_B)
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0003, 0x0000001f);
-	else
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0003, 0x0000000f);
-	/* Maximum Contention Window */
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_WIRELESS, 0x0004, 0x000003ff);
-
-	bcm43xx_gen_bssid(bcm);
-	bcm43xx_write_mac_bssid_templates(bcm);
-
-	if (bcm-&gt;current_core-&gt;rev &gt;= 5)
-		bcm43xx_write16(bcm, 0x043C, 0x000C);
-
-	if (active_wlcore) {
-		if (bcm43xx_using_pio(bcm)) {
-			err = bcm43xx_pio_init(bcm);
-		} else {
-			err = bcm43xx_dma_init(bcm);
-			if (err == -ENOSYS)
-				err = bcm43xx_pio_init(bcm);
-		}
-		if (err)
-			goto err_chip_cleanup;
-	}
-	bcm43xx_write16(bcm, 0x0612, 0x0050);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0416, 0x0050);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0414, 0x01F4);
-
-	if (active_wlcore) {
-		if (radio-&gt;initial_channel != 0xFF)
-			bcm43xx_radio_selectchannel(bcm, radio-&gt;initial_channel, 0);
-	}
-
-	/* Don't enable MAC/IRQ here, as it will race with the IRQ handler.
-	 * We enable it later.
-	 */
-	bcm-&gt;current_core-&gt;initialized = 1;
-out:
-	return err;
-
-err_chip_cleanup:
-	bcm43xx_chip_cleanup(bcm);
-	goto out;
-}
-
-static int bcm43xx_chipset_attach(struct bcm43xx_private *bcm)
-{
-	int err;
-	u16 pci_status;
-
-	err = bcm43xx_pctl_set_crystal(bcm, 1);
-	if (err)
-		goto out;
-	err = bcm43xx_pci_read_config16(bcm, PCI_STATUS, &amp;pci_status);
-	if (err)
-		goto out;
-	err = bcm43xx_pci_write_config16(bcm, PCI_STATUS, pci_status &amp; ~PCI_STATUS_SIG_TARGET_ABORT);
-
-out:
-	return err;
-}
-
-static void bcm43xx_chipset_detach(struct bcm43xx_private *bcm)
-{
-	bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_SLOW);
-	bcm43xx_pctl_set_crystal(bcm, 0);
-}
-
-static void bcm43xx_pcicore_broadcast_value(struct bcm43xx_private *bcm,
-					    u32 address,
-					    u32 data)
-{
-	bcm43xx_write32(bcm, BCM43xx_PCICORE_BCAST_ADDR, address);
-	bcm43xx_write32(bcm, BCM43xx_PCICORE_BCAST_DATA, data);
-}
-
-static int bcm43xx_pcicore_commit_settings(struct bcm43xx_private *bcm)
-{
-	int err = 0;
-
-	bcm-&gt;irq_savedstate = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-
-	if (bcm-&gt;core_chipcommon.available) {
-		err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_chipcommon);
-		if (err)
-			goto out;
-
-		bcm43xx_pcicore_broadcast_value(bcm, 0xfd8, 0x00000000);
-
-		/* this function is always called when a PCI core is mapped */
-		err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_pci);
-		if (err)
-			goto out;
-	} else
-		bcm43xx_pcicore_broadcast_value(bcm, 0xfd8, 0x00000000);
-
-	bcm43xx_interrupt_enable(bcm, bcm-&gt;irq_savedstate);
-
-out:
-	return err;
-}
-
-static u32 bcm43xx_pcie_reg_read(struct bcm43xx_private *bcm, u32 address)
-{
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_ADDR, address);
-	return bcm43xx_read32(bcm, BCM43xx_PCIECORE_REG_DATA);
-}
-
-static void bcm43xx_pcie_reg_write(struct bcm43xx_private *bcm, u32 address,
-				    u32 data)
-{
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_ADDR, address);
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_REG_DATA, data);
-}
-
-static void bcm43xx_pcie_mdio_write(struct bcm43xx_private *bcm, u8 dev, u8 reg,
-				    u16 data)
-{
-	int i;
-
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_CTL, 0x0082);
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_DATA, BCM43xx_PCIE_MDIO_ST |
-			BCM43xx_PCIE_MDIO_WT | (dev &lt;&lt; BCM43xx_PCIE_MDIO_DEV) |
-			(reg &lt;&lt; BCM43xx_PCIE_MDIO_REG) | BCM43xx_PCIE_MDIO_TA |
-			data);
-	udelay(10);
-
-	for (i = 0; i &lt; 10; i++) {
-		if (bcm43xx_read32(bcm, BCM43xx_PCIECORE_MDIO_CTL) &amp;
-		    BCM43xx_PCIE_MDIO_TC)
-			break;
-		msleep(1);
-	}
-	bcm43xx_write32(bcm, BCM43xx_PCIECORE_MDIO_CTL, 0);
-}
-
-/* Make an I/O Core usable. &quot;core_mask&quot; is the bitmask of the cores to enable.
- * To enable core 0, pass a core_mask of 1&lt;&lt;0
- */
-static int bcm43xx_setup_backplane_pci_connection(struct bcm43xx_private *bcm,
-						  u32 core_mask)
-{
-	u32 backplane_flag_nr;
-	u32 value;
-	struct bcm43xx_coreinfo *old_core;
-	int err = 0;
-
-	value = bcm43xx_read32(bcm, BCM43xx_CIR_SBTPSFLAG);
-	backplane_flag_nr = value &amp; BCM43xx_BACKPLANE_FLAG_NR_MASK;
-
-	old_core = bcm-&gt;current_core;
-	err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_pci);
-	if (err)
-		goto out;
-
-	if (bcm-&gt;current_core-&gt;rev &lt; 6 &amp;&amp;
-		bcm-&gt;current_core-&gt;id == BCM43xx_COREID_PCI) {
-		value = bcm43xx_read32(bcm, BCM43xx_CIR_SBINTVEC);
-		value |= (1 &lt;&lt; backplane_flag_nr);
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBINTVEC, value);
-	} else {
-		err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCICFG_ICR, &amp;value);
-		if (err) {
-			printk(KERN_ERR PFX &quot;Error: ICR setup failure!\n&quot;);
-			goto out_switch_back;
-		}
-		value |= core_mask &lt;&lt; 8;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCICFG_ICR, value);
-		if (err) {
-			printk(KERN_ERR PFX &quot;Error: ICR setup failure!\n&quot;);
-			goto out_switch_back;
-		}
-	}
-
-	if (bcm-&gt;current_core-&gt;id == BCM43xx_COREID_PCI) {
-		value = bcm43xx_read32(bcm, BCM43xx_PCICORE_SBTOPCI2);
-		value |= BCM43xx_SBTOPCI2_PREFETCH | BCM43xx_SBTOPCI2_BURST;
-		bcm43xx_write32(bcm, BCM43xx_PCICORE_SBTOPCI2, value);
-
-		if (bcm-&gt;current_core-&gt;rev &lt; 5) {
-			value = bcm43xx_read32(bcm, BCM43xx_CIR_SBIMCONFIGLOW);
-			value |= (2 &lt;&lt; BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_SHIFT)
-				 &amp; BCM43xx_SBIMCONFIGLOW_SERVICE_TOUT_MASK;
-			value |= (3 &lt;&lt; BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_SHIFT)
-				 &amp; BCM43xx_SBIMCONFIGLOW_REQUEST_TOUT_MASK;
-			bcm43xx_write32(bcm, BCM43xx_CIR_SBIMCONFIGLOW, value);
-			err = bcm43xx_pcicore_commit_settings(bcm);
-			assert(err == 0);
-		} else if (bcm-&gt;current_core-&gt;rev &gt;= 11) {
-			value = bcm43xx_read32(bcm, BCM43xx_PCICORE_SBTOPCI2);
-			value |= BCM43xx_SBTOPCI2_MEMREAD_MULTI;
-			bcm43xx_write32(bcm, BCM43xx_PCICORE_SBTOPCI2, value);
-		}
-	} else {
-		if (bcm-&gt;current_core-&gt;rev == 0 || bcm-&gt;current_core-&gt;rev == 1) {
-			value = bcm43xx_pcie_reg_read(bcm, BCM43xx_PCIE_TLP_WORKAROUND);
-			value |= 0x8;
-			bcm43xx_pcie_reg_write(bcm, BCM43xx_PCIE_TLP_WORKAROUND,
-					       value);
-		}
-		if (bcm-&gt;current_core-&gt;rev == 0) {
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_RXTIMER, 0x8128);
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_CDR, 0x0100);
-			bcm43xx_pcie_mdio_write(bcm, BCM43xx_MDIO_SERDES_RX,
-						BCM43xx_SERDES_CDR_BW, 0x1466);
-		} else if (bcm-&gt;current_core-&gt;rev == 1) {
-			value = bcm43xx_pcie_reg_read(bcm, BCM43xx_PCIE_DLLP_LINKCTL);
-			value |= 0x40;
-			bcm43xx_pcie_reg_write(bcm, BCM43xx_PCIE_DLLP_LINKCTL,
-					       value);
-		}
-	}
-out_switch_back:
-	err = bcm43xx_switch_core(bcm, old_core);
-out:
-	return err;
-}
-
-static void bcm43xx_periodic_every120sec(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	if (phy-&gt;type != BCM43xx_PHYTYPE_G || phy-&gt;rev &lt; 2)
-		return;
-
-	bcm43xx_mac_suspend(bcm);
-	bcm43xx_phy_lo_g_measure(bcm);
-	bcm43xx_mac_enable(bcm);
-}
-
-static void bcm43xx_periodic_every60sec(struct bcm43xx_private *bcm)
-{
-	bcm43xx_phy_lo_mark_all_unused(bcm);
-	if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_RSSI) {
-		bcm43xx_mac_suspend(bcm);
-		bcm43xx_calc_nrssi_slope(bcm);
-		bcm43xx_mac_enable(bcm);
-	}
-}
-
-static void bcm43xx_periodic_every30sec(struct bcm43xx_private *bcm)
-{
-	/* Update device statistics. */
-	bcm43xx_calculate_link_quality(bcm);
-}
-
-static void bcm43xx_periodic_every15sec(struct bcm43xx_private *bcm)
-{
-	bcm43xx_phy_xmitpower(bcm); //FIXME: unless scanning?
-	//TODO for APHY (temperature?)
-}
-
-static void bcm43xx_periodic_every1sec(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	int radio_hw_enable;
-
-	/* check if radio hardware enabled status changed */
-	radio_hw_enable = bcm43xx_is_hw_radio_enabled(bcm);
-	if (unlikely(bcm-&gt;radio_hw_enable != radio_hw_enable)) {
-		bcm-&gt;radio_hw_enable = radio_hw_enable;
-		printk(KERN_INFO PFX &quot;Radio hardware status changed to %s\n&quot;,
-		       (radio_hw_enable == 0) ? &quot;disabled&quot; : &quot;enabled&quot;);
-		bcm43xx_leds_update(bcm, 0);
-	}
-	if (phy-&gt;type == BCM43xx_PHYTYPE_G) {
-		//TODO: update_aci_moving_average
-		if (radio-&gt;aci_enable &amp;&amp; radio-&gt;aci_wlan_automatic) {
-			bcm43xx_mac_suspend(bcm);
-			if (!radio-&gt;aci_enable &amp;&amp; 1 /*TODO: not scanning? */) {
-				if (0 /*TODO: bunch of conditions*/) {
-					bcm43xx_radio_set_interference_mitigation(bcm,
-										  BCM43xx_RADIO_INTERFMODE_MANUALWLAN);
-				}
-			} else if (1/*TODO*/) {
-				/*
-				if ((aci_average &gt; 1000) &amp;&amp; !(bcm43xx_radio_aci_scan(bcm))) {
-					bcm43xx_radio_set_interference_mitigation(bcm,
-										  BCM43xx_RADIO_INTERFMODE_NONE);
-				}
-				*/
-			}
-			bcm43xx_mac_enable(bcm);
-		} else if (radio-&gt;interfmode == BCM43xx_RADIO_INTERFMODE_NONWLAN &amp;&amp;
-			   phy-&gt;rev == 1) {
-			//TODO: implement rev1 workaround
-		}
-	}
-}
-
-static void do_periodic_work(struct bcm43xx_private *bcm)
-{
-	if (bcm-&gt;periodic_state % 120 == 0)
-		bcm43xx_periodic_every120sec(bcm);
-	if (bcm-&gt;periodic_state % 60 == 0)
-		bcm43xx_periodic_every60sec(bcm);
-	if (bcm-&gt;periodic_state % 30 == 0)
-		bcm43xx_periodic_every30sec(bcm);
-	if (bcm-&gt;periodic_state % 15 == 0)
-		bcm43xx_periodic_every15sec(bcm);
-	bcm43xx_periodic_every1sec(bcm);
-
-	schedule_delayed_work(&amp;bcm-&gt;periodic_work, HZ);
-}
-
-static void bcm43xx_periodic_work_handler(struct work_struct *work)
-{
-	struct bcm43xx_private *bcm =
-		container_of(work, struct bcm43xx_private, periodic_work.work);
-	struct net_device *net_dev = bcm-&gt;net_dev;
-	unsigned long flags;
-	u32 savedirqs = 0;
-	unsigned long orig_trans_start = 0;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	/* keep from doing and rearming periodic work if shutting down */
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_UNINIT)
-		goto unlock_mutex;
-	if (unlikely(bcm-&gt;periodic_state % 60 == 0)) {
-		/* Periodic work will take a long time, so we want it to
-		 * be preemtible.
-		 */
-
-		netif_tx_lock_bh(net_dev);
-		/* We must fake a started transmission here, as we are going to
-		 * disable TX. If we wouldn't fake a TX, it would be possible to
-		 * trigger the netdev watchdog, if the last real TX is already
-		 * some time on the past (slightly less than 5secs)
-		 */
-		orig_trans_start = net_dev-&gt;trans_start;
-		net_dev-&gt;trans_start = jiffies;
-		netif_stop_queue(net_dev);
-		netif_tx_unlock_bh(net_dev);
-
-		spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-		bcm43xx_mac_suspend(bcm);
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_freeze_txqueues(bcm);
-		savedirqs = bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-		spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-		bcm43xx_synchronize_irq(bcm);
-	} else {
-		/* Periodic work should take short time, so we want low
-		 * locking overhead.
-		 */
-		spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	}
-
-	do_periodic_work(bcm);
-
-	if (unlikely(bcm-&gt;periodic_state % 60 == 0)) {
-		spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-		tasklet_enable(&amp;bcm-&gt;isr_tasklet);
-		bcm43xx_interrupt_enable(bcm, savedirqs);
-		if (bcm43xx_using_pio(bcm))
-			bcm43xx_pio_thaw_txqueues(bcm);
-		bcm43xx_mac_enable(bcm);
-		netif_wake_queue(bcm-&gt;net_dev);
-		net_dev-&gt;trans_start = orig_trans_start;
-	}
-	mmiowb();
-	bcm-&gt;periodic_state++;
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-unlock_mutex:
-	mutex_unlock(&amp;bcm-&gt;mutex);
-}
-
-void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm)
-{
-	struct delayed_work *work = &amp;bcm-&gt;periodic_work;
-
-	assert(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED);
-	INIT_DELAYED_WORK(work, bcm43xx_periodic_work_handler);
-	schedule_delayed_work(work, 0);
-}
-
-static void bcm43xx_security_init(struct bcm43xx_private *bcm)
-{
-	bcm-&gt;security_offset = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-						  0x0056) * 2;
-	bcm43xx_clear_keys(bcm);
-}
-
-static int bcm43xx_rng_read(struct hwrng *rng, u32 *data)
-{
-	struct bcm43xx_private *bcm = (struct bcm43xx_private *)rng-&gt;priv;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;(bcm)-&gt;irq_lock, flags);
-	*data = bcm43xx_read16(bcm, BCM43xx_MMIO_RNG);
-	spin_unlock_irqrestore(&amp;(bcm)-&gt;irq_lock, flags);
-
-	return (sizeof(u16));
-}
-
-static void bcm43xx_rng_exit(struct bcm43xx_private *bcm)
-{
-	hwrng_unregister(&amp;bcm-&gt;rng);
-}
-
-static int bcm43xx_rng_init(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	snprintf(bcm-&gt;rng_name, ARRAY_SIZE(bcm-&gt;rng_name),
-		 &quot;%s_%s&quot;, KBUILD_MODNAME, bcm-&gt;net_dev-&gt;name);
-	bcm-&gt;rng.name = bcm-&gt;rng_name;
-	bcm-&gt;rng.data_read = bcm43xx_rng_read;
-	bcm-&gt;rng.priv = (unsigned long)bcm;
-	err = hwrng_register(&amp;bcm-&gt;rng);
-	if (err)
-		printk(KERN_ERR PFX &quot;RNG init failed (%d)\n&quot;, err);
-
-	return err;
-}
-
-void bcm43xx_cancel_work(struct bcm43xx_private *bcm)
-{
-	/* The system must be unlocked when this routine is entered.
-	 * If not, the next 2 steps may deadlock */
-	cancel_work_sync(&amp;bcm-&gt;restart_work);
-	cancel_delayed_work_sync(&amp;bcm-&gt;periodic_work);
-}
-
-static int bcm43xx_shutdown_all_wireless_cores(struct bcm43xx_private *bcm)
-{
-	int ret = 0;
-	int i, err;
-	struct bcm43xx_coreinfo *core;
-
-	bcm43xx_set_status(bcm, BCM43xx_STAT_SHUTTINGDOWN);
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++) {
-		core = &amp;(bcm-&gt;core_80211[i]);
-		assert(core-&gt;available);
-		if (!core-&gt;initialized)
-			continue;
-		err = bcm43xx_switch_core(bcm, core);
-		if (err) {
-			dprintk(KERN_ERR PFX &quot;shutdown_all_wireless_cores &quot;
-					     &quot;switch_core failed (%d)\n&quot;, err);
-			ret = err;
-			continue;
-		}
-		bcm43xx_interrupt_disable(bcm, BCM43xx_IRQ_ALL);
-		bcm43xx_read32(bcm, BCM43xx_MMIO_GEN_IRQ_REASON); /* dummy read */
-		bcm43xx_wireless_core_cleanup(bcm);
-		if (core == bcm-&gt;active_80211_core)
-			bcm-&gt;active_80211_core = NULL;
-	}
-	free_irq(bcm-&gt;irq, bcm);
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-
-	return ret;
-}
-
-/* This is the opposite of bcm43xx_init_board() */
-static void bcm43xx_free_board(struct bcm43xx_private *bcm)
-{
-	bcm43xx_rng_exit(bcm);
-	bcm43xx_sysfs_unregister(bcm);
-
-	mutex_lock(&amp;(bcm)-&gt;mutex);
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-	mutex_unlock(&amp;(bcm)-&gt;mutex);
-
-	bcm43xx_cancel_work(bcm);
-
-	mutex_lock(&amp;(bcm)-&gt;mutex);
-	bcm43xx_shutdown_all_wireless_cores(bcm);
-	bcm43xx_pctl_set_crystal(bcm, 0);
-	mutex_unlock(&amp;(bcm)-&gt;mutex);
-}
-
-static void prepare_phydata_for_init(struct bcm43xx_phyinfo *phy)
-{
-	phy-&gt;antenna_diversity = 0xFFFF;
-	memset(phy-&gt;minlowsig, 0xFF, sizeof(phy-&gt;minlowsig));
-	memset(phy-&gt;minlowsigpos, 0, sizeof(phy-&gt;minlowsigpos));
-
-	/* Flags */
-	phy-&gt;calibrated = 0;
-	phy-&gt;is_locked = 0;
-
-	if (phy-&gt;_lo_pairs) {
-		memset(phy-&gt;_lo_pairs, 0,
-		       sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT);
-	}
-	memset(phy-&gt;loopback_gain, 0, sizeof(phy-&gt;loopback_gain));
-}
-
-static void prepare_radiodata_for_init(struct bcm43xx_private *bcm,
-				       struct bcm43xx_radioinfo *radio)
-{
-	int i;
-
-	/* Set default attenuation values. */
-	radio-&gt;baseband_atten = bcm43xx_default_baseband_attenuation(bcm);
-	radio-&gt;radio_atten = bcm43xx_default_radio_attenuation(bcm);
-	radio-&gt;txctl1 = bcm43xx_default_txctl1(bcm);
-	radio-&gt;txctl2 = 0xFFFF;
-	radio-&gt;txpwr_offset = 0;
-
-	/* NRSSI */
-	radio-&gt;nrssislope = 0;
-	for (i = 0; i &lt; ARRAY_SIZE(radio-&gt;nrssi); i++)
-		radio-&gt;nrssi[i] = -1000;
-	for (i = 0; i &lt; ARRAY_SIZE(radio-&gt;nrssi_lt); i++)
-		radio-&gt;nrssi_lt[i] = i;
-
-	radio-&gt;lofcal = 0xFFFF;
-	radio-&gt;initval = 0xFFFF;
-
-	radio-&gt;aci_enable = 0;
-	radio-&gt;aci_wlan_automatic = 0;
-	radio-&gt;aci_hw_rssi = 0;
-}
-
-static void prepare_priv_for_init(struct bcm43xx_private *bcm)
-{
-	int i;
-	struct bcm43xx_coreinfo *core;
-	struct bcm43xx_coreinfo_80211 *wlext;
-
-	assert(!bcm-&gt;active_80211_core);
-
-	bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZING);
-
-	/* Flags */
-	bcm-&gt;was_initialized = 0;
-	bcm-&gt;reg124_set_0x4 = 0;
-
-	/* Stats */
-	memset(&amp;bcm-&gt;stats, 0, sizeof(bcm-&gt;stats));
-
-	/* Wireless core data */
-	for (i = 0; i &lt; BCM43xx_MAX_80211_CORES; i++) {
-		core = &amp;(bcm-&gt;core_80211[i]);
-		wlext = core-&gt;priv;
-
-		if (!core-&gt;available)
-			continue;
-		assert(wlext == &amp;(bcm-&gt;core_80211_ext[i]));
-
-		prepare_phydata_for_init(&amp;wlext-&gt;phy);
-		prepare_radiodata_for_init(bcm, &amp;wlext-&gt;radio);
-	}
-
-	/* IRQ related flags */
-	bcm-&gt;irq_reason = 0;
-	memset(bcm-&gt;dma_reason, 0, sizeof(bcm-&gt;dma_reason));
-	bcm-&gt;irq_savedstate = BCM43xx_IRQ_INITIAL;
-
-	bcm-&gt;mac_suspended = 1;
-
-	/* Noise calculation context */
-	memset(&amp;bcm-&gt;noisecalc, 0, sizeof(bcm-&gt;noisecalc));
-
-	/* Periodic work context */
-	bcm-&gt;periodic_state = 0;
-}
-
-static int wireless_core_up(struct bcm43xx_private *bcm,
-			    int active_wlcore)
-{
-	int err;
-
-	if (!bcm43xx_core_enabled(bcm))
-		bcm43xx_wireless_core_reset(bcm, 1);
-	if (!active_wlcore)
-		bcm43xx_wireless_core_mark_inactive(bcm);
-	err = bcm43xx_wireless_core_init(bcm, active_wlcore);
-	if (err)
-		goto out;
-	if (!active_wlcore)
-		bcm43xx_radio_turn_off(bcm);
-out:
-	return err;
-}
-
-/* Select and enable the &quot;to be used&quot; wireless core.
- * Locking: bcm-&gt;mutex must be aquired before calling this.
- *          bcm-&gt;irq_lock must not be aquired.
- */
-int bcm43xx_select_wireless_core(struct bcm43xx_private *bcm,
-				 int phytype)
-{
-	int i, err;
-	struct bcm43xx_coreinfo *active_core = NULL;
-	struct bcm43xx_coreinfo_80211 *active_wlext = NULL;
-	struct bcm43xx_coreinfo *core;
-	struct bcm43xx_coreinfo_80211 *wlext;
-	int adjust_active_sbtmstatelow = 0;
-
-	might_sleep();
-
-	if (phytype &lt; 0) {
-		/* If no phytype is requested, select the first core. */
-		assert(bcm-&gt;core_80211[0].available);
-		wlext = bcm-&gt;core_80211[0].priv;
-		phytype = wlext-&gt;phy.type;
-	}
-	/* Find the requested core. */
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++) {
-		core = &amp;(bcm-&gt;core_80211[i]);
-		wlext = core-&gt;priv;
-		if (wlext-&gt;phy.type == phytype) {
-			active_core = core;
-			active_wlext = wlext;
-			break;
-		}
-	}
-	if (!active_core)
-		return -ESRCH; /* No such PHYTYPE on this board. */
-
-	if (bcm-&gt;active_80211_core) {
-		/* We already selected a wl core in the past.
-		 * So first clean up everything.
-		 */
-		dprintk(KERN_INFO PFX &quot;select_wireless_core: cleanup\n&quot;);
-		ieee80211softmac_stop(bcm-&gt;net_dev);
-		bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZED);
-		err = bcm43xx_disable_interrupts_sync(bcm);
-		assert(!err);
-		tasklet_enable(&amp;bcm-&gt;isr_tasklet);
-		err = bcm43xx_shutdown_all_wireless_cores(bcm);
-		if (err)
-			goto error;
-		/* Ok, everything down, continue to re-initialize. */
-		bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZING);
-	}
-
-	/* Reset all data structures. */
-	prepare_priv_for_init(bcm);
-
-	err = bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_FAST);
-	if (err)
-		goto error;
-
-	/* Mark all unused cores &quot;inactive&quot;. */
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++) {
-		core = &amp;(bcm-&gt;core_80211[i]);
-		wlext = core-&gt;priv;
-
-		if (core == active_core)
-			continue;
-		err = bcm43xx_switch_core(bcm, core);
-		if (err) {
-			dprintk(KERN_ERR PFX &quot;Could not switch to inactive &quot;
-					     &quot;802.11 core (%d)\n&quot;, err);
-			goto error;
-		}
-		err = wireless_core_up(bcm, 0);
-		if (err) {
-			dprintk(KERN_ERR PFX &quot;core_up for inactive 802.11 core &quot;
-					     &quot;failed (%d)\n&quot;, err);
-			goto error;
-		}
-		adjust_active_sbtmstatelow = 1;
-	}
-
-	/* Now initialize the active 802.11 core. */
-	err = bcm43xx_switch_core(bcm, active_core);
-	if (err) {
-		dprintk(KERN_ERR PFX &quot;Could not switch to active &quot;
-				     &quot;802.11 core (%d)\n&quot;, err);
-		goto error;
-	}
-	if (adjust_active_sbtmstatelow &amp;&amp;
-	    active_wlext-&gt;phy.type == BCM43xx_PHYTYPE_G) {
-		u32 sbtmstatelow;
-
-		sbtmstatelow = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-		sbtmstatelow |= BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, sbtmstatelow);
-	}
-	err = wireless_core_up(bcm, 1);
-	if (err) {
-		dprintk(KERN_ERR PFX &quot;core_up for active 802.11 core &quot;
-				     &quot;failed (%d)\n&quot;, err);
-		goto error;
-	}
-	err = bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_DYNAMIC);
-	if (err)
-		goto error;
-	bcm-&gt;active_80211_core = active_core;
-
-	bcm43xx_macfilter_clear(bcm, BCM43xx_MACFILTER_ASSOC);
-	bcm43xx_macfilter_set(bcm, BCM43xx_MACFILTER_SELF, (u8 *)(bcm-&gt;net_dev-&gt;dev_addr));
-	bcm43xx_security_init(bcm);
-	drain_txstatus_queue(bcm);
-	ieee80211softmac_start(bcm-&gt;net_dev);
-
-	/* Let's go! Be careful after enabling the IRQs.
-	 * Don't switch cores, for example.
-	 */
-	bcm43xx_mac_enable(bcm);
-	bcm43xx_set_status(bcm, BCM43xx_STAT_INITIALIZED);
-	err = bcm43xx_initialize_irq(bcm);
-	if (err)
-		goto error;
-	bcm43xx_interrupt_enable(bcm, bcm-&gt;irq_savedstate);
-
-	dprintk(KERN_INFO PFX &quot;Selected 802.11 core (phytype %d)\n&quot;,
-		active_wlext-&gt;phy.type);
-
-	return 0;
-
-error:
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-	bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_SLOW);
-	return err;
-}
-
-static int bcm43xx_init_board(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	mutex_lock(&amp;(bcm)-&gt;mutex);
-
-	tasklet_enable(&amp;bcm-&gt;isr_tasklet);
-	err = bcm43xx_pctl_set_crystal(bcm, 1);
-	if (err)
-		goto err_tasklet;
-	err = bcm43xx_pctl_init(bcm);
-	if (err)
-		goto err_crystal_off;
-	err = bcm43xx_select_wireless_core(bcm, -1);
-	if (err)
-		goto err_crystal_off;
-	err = bcm43xx_sysfs_register(bcm);
-	if (err)
-		goto err_wlshutdown;
-	err = bcm43xx_rng_init(bcm);
-	if (err)
-		goto err_sysfs_unreg;
-	bcm43xx_periodic_tasks_setup(bcm);
-
-	/*FIXME: This should be handled by softmac instead. */
-	schedule_delayed_work(&amp;bcm-&gt;softmac-&gt;associnfo.work, 0);
-
-out:
-	mutex_unlock(&amp;(bcm)-&gt;mutex);
-
-	return err;
-
-err_sysfs_unreg:
-	bcm43xx_sysfs_unregister(bcm);
-err_wlshutdown:
-	bcm43xx_shutdown_all_wireless_cores(bcm);
-err_crystal_off:
-	bcm43xx_pctl_set_crystal(bcm, 0);
-err_tasklet:
-	tasklet_disable(&amp;bcm-&gt;isr_tasklet);
-	goto out;
-}
-
-static void bcm43xx_detach_board(struct bcm43xx_private *bcm)
-{
-	struct pci_dev *pci_dev = bcm-&gt;pci_dev;
-	int i;
-
-	bcm43xx_chipset_detach(bcm);
-	/* Do _not_ access the chip, after it is detached. */
-	pci_iounmap(pci_dev, bcm-&gt;mmio_addr);
-	pci_release_regions(pci_dev);
-	pci_disable_device(pci_dev);
-
-	/* Free allocated structures/fields */
-	for (i = 0; i &lt; BCM43xx_MAX_80211_CORES; i++) {
-		kfree(bcm-&gt;core_80211_ext[i].phy._lo_pairs);
-		if (bcm-&gt;core_80211_ext[i].phy.dyn_tssi_tbl)
-			kfree(bcm-&gt;core_80211_ext[i].phy.tssi2dbm);
-	}
-}	
-
-static int bcm43xx_read_phyinfo(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 value;
-	u8 phy_analog;
-	u8 phy_type;
-	u8 phy_rev;
-	int phy_rev_ok = 1;
-	void *p;
-
-	value = bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_VER);
-
-	phy_analog = (value &amp; 0xF000) &gt;&gt; 12;
-	phy_type = (value &amp; 0x0F00) &gt;&gt; 8;
-	phy_rev = (value &amp; 0x000F);
-
-	dprintk(KERN_INFO PFX &quot;Detected PHY: Analog: %x, Type %x, Revision %x\n&quot;,
-		phy_analog, phy_type, phy_rev);
-
-	switch (phy_type) {
-	case BCM43xx_PHYTYPE_A:
-		if (phy_rev &gt;= 4)
-			phy_rev_ok = 0;
-		/*FIXME: We need to switch the ieee-&gt;modulation, etc.. flags,
-		 *       if we switch 80211 cores after init is done.
-		 *       As we do not implement on the fly switching between
-		 *       wireless cores, I will leave this as a future task.
-		 */
-		bcm-&gt;ieee-&gt;modulation = IEEE80211_OFDM_MODULATION;
-		bcm-&gt;ieee-&gt;mode = IEEE_A;
-		bcm-&gt;ieee-&gt;freq_band = IEEE80211_52GHZ_BAND |
-				       IEEE80211_24GHZ_BAND;
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if (phy_rev != 2 &amp;&amp; phy_rev != 4 &amp;&amp; phy_rev != 6 &amp;&amp; phy_rev != 7)
-			phy_rev_ok = 0;
-		bcm-&gt;ieee-&gt;modulation = IEEE80211_CCK_MODULATION;
-		bcm-&gt;ieee-&gt;mode = IEEE_B;
-		bcm-&gt;ieee-&gt;freq_band = IEEE80211_24GHZ_BAND;
-		break;
-	case BCM43xx_PHYTYPE_G:
-		if (phy_rev &gt; 8)
-			phy_rev_ok = 0;
-		bcm-&gt;ieee-&gt;modulation = IEEE80211_OFDM_MODULATION |
-					IEEE80211_CCK_MODULATION;
-		bcm-&gt;ieee-&gt;mode = IEEE_G;
-		bcm-&gt;ieee-&gt;freq_band = IEEE80211_24GHZ_BAND;
-		break;
-	default:
-		printk(KERN_ERR PFX &quot;Error: Unknown PHY Type %x\n&quot;,
-		       phy_type);
-		return -ENODEV;
-	};
-	bcm-&gt;ieee-&gt;perfect_rssi = RX_RSSI_MAX;
-	bcm-&gt;ieee-&gt;worst_rssi = 0;
-	if (!phy_rev_ok) {
-		printk(KERN_WARNING PFX &quot;Invalid PHY Revision %x\n&quot;,
-		       phy_rev);
-	}
-
-	phy-&gt;analog = phy_analog;
-	phy-&gt;type = phy_type;
-	phy-&gt;rev = phy_rev;
-	if ((phy_type == BCM43xx_PHYTYPE_B) || (phy_type == BCM43xx_PHYTYPE_G)) {
-		p = kzalloc(sizeof(struct bcm43xx_lopair) * BCM43xx_LO_COUNT,
-			    GFP_KERNEL);
-		if (!p)
-			return -ENOMEM;
-		phy-&gt;_lo_pairs = p;
-	}
-
-	return 0;
-}
-
-static int bcm43xx_attach_board(struct bcm43xx_private *bcm)
-{
-	struct pci_dev *pci_dev = bcm-&gt;pci_dev;
-	struct net_device *net_dev = bcm-&gt;net_dev;
-	int err;
-	int i;
-	u32 coremask;
-
-	err = pci_enable_device(pci_dev);
-	if (err) {
-		printk(KERN_ERR PFX &quot;pci_enable_device() failed\n&quot;);
-		goto out;
-	}
-	err = pci_request_regions(pci_dev, KBUILD_MODNAME);
-	if (err) {
-		printk(KERN_ERR PFX &quot;pci_request_regions() failed\n&quot;);
-		goto err_pci_disable;
-	}
-	/* enable PCI bus-mastering */
-	pci_set_master(pci_dev);
-	bcm-&gt;mmio_addr = pci_iomap(pci_dev, 0, ~0UL);
-	if (!bcm-&gt;mmio_addr) {
-		printk(KERN_ERR PFX &quot;pci_iomap() failed\n&quot;);
-		err = -EIO;
-		goto err_pci_release;
-	}
-	net_dev-&gt;base_addr = (unsigned long)bcm-&gt;mmio_addr;
-
-	err = bcm43xx_pci_read_config16(bcm, PCI_SUBSYSTEM_VENDOR_ID,
-	                          &amp;bcm-&gt;board_vendor);
-	if (err)
-		goto err_iounmap;
-	err = bcm43xx_pci_read_config16(bcm, PCI_SUBSYSTEM_ID,
-	                          &amp;bcm-&gt;board_type);
-	if (err)
-		goto err_iounmap;
-
-	bcm-&gt;board_revision = bcm-&gt;pci_dev-&gt;revision;
-
-	err = bcm43xx_chipset_attach(bcm);
-	if (err)
-		goto err_iounmap;
-	err = bcm43xx_pctl_init(bcm);
-	if (err)
-		goto err_chipset_detach;
-	err = bcm43xx_probe_cores(bcm);
-	if (err)
-		goto err_chipset_detach;
-	
-	/* Attach all IO cores to the backplane. */
-	coremask = 0;
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++)
-		coremask |= (1 &lt;&lt; bcm-&gt;core_80211[i].index);
-	//FIXME: Also attach some non80211 cores?
-	err = bcm43xx_setup_backplane_pci_connection(bcm, coremask);
-	if (err) {
-		printk(KERN_ERR PFX &quot;Backplane-&gt;PCI connection failed!\n&quot;);
-		goto err_chipset_detach;
-	}
-
-	err = bcm43xx_sprom_extract(bcm);
-	if (err)
-		goto err_chipset_detach;
-	err = bcm43xx_leds_init(bcm);
-	if (err)
-		goto err_chipset_detach;
-
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++) {
-		err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_80211[i]);
-		assert(err != -ENODEV);
-		if (err)
-			goto err_80211_unwind;
-
-		/* Enable the selected wireless core.
-		 * Connect PHY only on the first core.
-		 */
-		bcm43xx_wireless_core_reset(bcm, (i == 0));
-
-		err = bcm43xx_read_phyinfo(bcm);
-		if (err &amp;&amp; (i == 0))
-			goto err_80211_unwind;
-
-		err = bcm43xx_read_radioinfo(bcm);
-		if (err &amp;&amp; (i == 0))
-			goto err_80211_unwind;
-
-		err = bcm43xx_validate_chip(bcm);
-		if (err &amp;&amp; (i == 0))
-			goto err_80211_unwind;
-
-		bcm43xx_radio_turn_off(bcm);
-		err = bcm43xx_phy_init_tssi2dbm_table(bcm);
-		if (err)
-			goto err_80211_unwind;
-		bcm43xx_wireless_core_disable(bcm);
-	}
-	err = bcm43xx_geo_init(bcm);
-	if (err)
-		goto err_80211_unwind;
-	bcm43xx_pctl_set_crystal(bcm, 0);
-
-	/* Set the MAC address in the networking subsystem */
-	if (is_valid_ether_addr(bcm-&gt;sprom.et1macaddr))
-		memcpy(bcm-&gt;net_dev-&gt;dev_addr, bcm-&gt;sprom.et1macaddr, 6);
-	else
-		memcpy(bcm-&gt;net_dev-&gt;dev_addr, bcm-&gt;sprom.il0macaddr, 6);
-
-	snprintf(bcm-&gt;nick, IW_ESSID_MAX_SIZE,
-		 &quot;Broadcom %04X&quot;, bcm-&gt;chip_id);
-
-	assert(err == 0);
-out:
-	return err;
-
-err_80211_unwind:
-	for (i = 0; i &lt; BCM43xx_MAX_80211_CORES; i++) {
-		kfree(bcm-&gt;core_80211_ext[i].phy._lo_pairs);
-		if (bcm-&gt;core_80211_ext[i].phy.dyn_tssi_tbl)
-			kfree(bcm-&gt;core_80211_ext[i].phy.tssi2dbm);
-	}
-err_chipset_detach:
-	bcm43xx_chipset_detach(bcm);
-err_iounmap:
-	pci_iounmap(pci_dev, bcm-&gt;mmio_addr);
-err_pci_release:
-	pci_release_regions(pci_dev);
-err_pci_disable:
-	pci_disable_device(pci_dev);
-	printk(KERN_ERR PFX &quot;Unable to attach board\n&quot;);
-	goto out;
-}
-
-/* Do the Hardware IO operations to send the txb */
-static inline int bcm43xx_tx(struct bcm43xx_private *bcm,
-			     struct ieee80211_txb *txb)
-{
-	int err = -ENODEV;
-
-	if (bcm43xx_using_pio(bcm))
-		err = bcm43xx_pio_tx(bcm, txb);
-	else
-		err = bcm43xx_dma_tx(bcm, txb);
-	bcm-&gt;net_dev-&gt;trans_start = jiffies;
-
-	return err;
-}
-
-static void bcm43xx_ieee80211_set_chan(struct net_device *net_dev,
-				       u8 channel)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct bcm43xx_radioinfo *radio;
-	unsigned long flags;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm43xx_mac_suspend(bcm);
-		bcm43xx_radio_selectchannel(bcm, channel, 0);
-		bcm43xx_mac_enable(bcm);
-	} else {
-		radio = bcm43xx_current_radio(bcm);
-		radio-&gt;initial_channel = channel;
-	}
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-}
-
-/* set_security() callback in struct ieee80211_device */
-static void bcm43xx_ieee80211_set_security(struct net_device *net_dev,
-					   struct ieee80211_security *sec)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct ieee80211_security *secinfo = &amp;bcm-&gt;ieee-&gt;sec;
-	unsigned long flags;
-	int keyidx;
-	
-	dprintk(KERN_INFO PFX &quot;set security called&quot;);
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-
-	for (keyidx = 0; keyidx&lt;WEP_KEYS; keyidx++)
-		if (sec-&gt;flags &amp; (1&lt;&lt;keyidx)) {
-			secinfo-&gt;encode_alg[keyidx] = sec-&gt;encode_alg[keyidx];
-			secinfo-&gt;key_sizes[keyidx] = sec-&gt;key_sizes[keyidx];
-			memcpy(secinfo-&gt;keys[keyidx], sec-&gt;keys[keyidx], SCM_KEY_LEN);
-		}
-	
-	if (sec-&gt;flags &amp; SEC_ACTIVE_KEY) {
-		secinfo-&gt;active_key = sec-&gt;active_key;
-		dprintk(&quot;, .active_key = %d&quot;, sec-&gt;active_key);
-	}
-	if (sec-&gt;flags &amp; SEC_UNICAST_GROUP) {
-		secinfo-&gt;unicast_uses_group = sec-&gt;unicast_uses_group;
-		dprintk(&quot;, .unicast_uses_group = %d&quot;, sec-&gt;unicast_uses_group);
-	}
-	if (sec-&gt;flags &amp; SEC_LEVEL) {
-		secinfo-&gt;level = sec-&gt;level;
-		dprintk(&quot;, .level = %d&quot;, sec-&gt;level);
-	}
-	if (sec-&gt;flags &amp; SEC_ENABLED) {
-		secinfo-&gt;enabled = sec-&gt;enabled;
-		dprintk(&quot;, .enabled = %d&quot;, sec-&gt;enabled);
-	}
-	if (sec-&gt;flags &amp; SEC_ENCRYPT) {
-		secinfo-&gt;encrypt = sec-&gt;encrypt;
-		dprintk(&quot;, .encrypt = %d&quot;, sec-&gt;encrypt);
-	}
-	if (sec-&gt;flags &amp; SEC_AUTH_MODE) {
-		secinfo-&gt;auth_mode = sec-&gt;auth_mode;
-		dprintk(&quot;, .auth_mode = %d&quot;, sec-&gt;auth_mode);
-	}
-	dprintk(&quot;\n&quot;);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED &amp;&amp;
-	    !bcm-&gt;ieee-&gt;host_encrypt) {
-		if (secinfo-&gt;enabled) {
-			/* upload WEP keys to hardware */
-			char null_address[6] = { 0 };
-			u8 algorithm = 0;
-			for (keyidx = 0; keyidx&lt;WEP_KEYS; keyidx++) {
-				if (!(sec-&gt;flags &amp; (1&lt;&lt;keyidx)))
-					continue;
-				switch (sec-&gt;encode_alg[keyidx]) {
-					case SEC_ALG_NONE: algorithm = BCM43xx_SEC_ALGO_NONE; break;
-					case SEC_ALG_WEP:
-						algorithm = BCM43xx_SEC_ALGO_WEP;
-						if (secinfo-&gt;key_sizes[keyidx] == 13)
-							algorithm = BCM43xx_SEC_ALGO_WEP104;
-						break;
-					case SEC_ALG_TKIP:
-						FIXME();
-						algorithm = BCM43xx_SEC_ALGO_TKIP;
-						break;
-					case SEC_ALG_CCMP:
-						FIXME();
-						algorithm = BCM43xx_SEC_ALGO_AES;
-						break;
-					default:
-						assert(0);
-						break;
-				}
-				bcm43xx_key_write(bcm, keyidx, algorithm, sec-&gt;keys[keyidx], secinfo-&gt;key_sizes[keyidx], &amp;null_address[0]);
-				bcm-&gt;key[keyidx].enabled = 1;
-				bcm-&gt;key[keyidx].algorithm = algorithm;
-			}
-		} else
-				bcm43xx_clear_keys(bcm);
-	}
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-}
-
-/* hard_start_xmit() callback in struct ieee80211_device */
-static int bcm43xx_ieee80211_hard_start_xmit(struct ieee80211_txb *txb,
-					     struct net_device *net_dev,
-					     int pri)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err = -ENODEV;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (likely(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED))
-		err = bcm43xx_tx(bcm, txb);
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-
-	if (unlikely(err))
-		return NETDEV_TX_BUSY;
-	return NETDEV_TX_OK;
-}
-
-static void bcm43xx_net_tx_timeout(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	bcm43xx_controller_restart(bcm, &quot;TX timeout&quot;);
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-}
-
-#ifdef CONFIG_NET_POLL_CONTROLLER
-static void bcm43xx_net_poll_controller(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-
-	local_irq_save(flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED)
-		bcm43xx_interrupt_handler(bcm-&gt;irq, bcm);
-	local_irq_restore(flags);
-}
-#endif /* CONFIG_NET_POLL_CONTROLLER */
-
-static int bcm43xx_net_open(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-
-	return bcm43xx_init_board(bcm);
-}
-
-static int bcm43xx_net_stop(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
-
-	ieee80211softmac_stop(net_dev);
-	err = bcm43xx_disable_interrupts_sync(bcm);
-	assert(!err);
-	bcm43xx_free_board(bcm);
-	bcm43xx_cancel_work(bcm);
-
-	return 0;
-}
-
-static int bcm43xx_init_private(struct bcm43xx_private *bcm,
-				struct net_device *net_dev,
-				struct pci_dev *pci_dev)
-{
-	bcm43xx_set_status(bcm, BCM43xx_STAT_UNINIT);
-	bcm-&gt;ieee = netdev_priv(net_dev);
-	bcm-&gt;softmac = ieee80211_priv(net_dev);
-	bcm-&gt;softmac-&gt;set_channel = bcm43xx_ieee80211_set_chan;
-
-	bcm-&gt;irq_savedstate = BCM43xx_IRQ_INITIAL;
-	bcm-&gt;mac_suspended = 1;
-	bcm-&gt;pci_dev = pci_dev;
-	bcm-&gt;net_dev = net_dev;
-	bcm-&gt;bad_frames_preempt = modparam_bad_frames_preempt;
-	spin_lock_init(&amp;bcm-&gt;irq_lock);
-	spin_lock_init(&amp;bcm-&gt;leds_lock);
-	mutex_init(&amp;bcm-&gt;mutex);
-	tasklet_init(&amp;bcm-&gt;isr_tasklet,
-		     (void (*)(unsigned long))bcm43xx_interrupt_tasklet,
-		     (unsigned long)bcm);
-	tasklet_disable_nosync(&amp;bcm-&gt;isr_tasklet);
-	if (modparam_pio)
-		bcm-&gt;__using_pio = 1;
-	bcm-&gt;rts_threshold = BCM43xx_DEFAULT_RTS_THRESHOLD;
-
-	/* default to sw encryption for now */
-	bcm-&gt;ieee-&gt;host_build_iv = 0;
-	bcm-&gt;ieee-&gt;host_encrypt = 1;
-	bcm-&gt;ieee-&gt;host_decrypt = 1;
-	
-	bcm-&gt;ieee-&gt;iw_mode = BCM43xx_INITIAL_IWMODE;
-	bcm-&gt;ieee-&gt;tx_headroom = sizeof(struct bcm43xx_txhdr);
-	bcm-&gt;ieee-&gt;set_security = bcm43xx_ieee80211_set_security;
-	bcm-&gt;ieee-&gt;hard_start_xmit = bcm43xx_ieee80211_hard_start_xmit;
-
-	return 0;
-}
-
-static int __devinit bcm43xx_init_one(struct pci_dev *pdev,
-				      const struct pci_device_id *ent)
-{
-	struct net_device *net_dev;
-	struct bcm43xx_private *bcm;
-	int err;
-
-#ifdef DEBUG_SINGLE_DEVICE_ONLY
-	if (strcmp(pci_name(pdev), DEBUG_SINGLE_DEVICE_ONLY))
-		return -ENODEV;
-#endif
-
-	net_dev = alloc_ieee80211softmac(sizeof(*bcm));
-	if (!net_dev) {
-		printk(KERN_ERR PFX
-		       &quot;could not allocate ieee80211 device %s\n&quot;,
-		       pci_name(pdev));
-		err = -ENOMEM;
-		goto out;
-	}
-	/* initialize the net_device struct */
-	SET_NETDEV_DEV(net_dev, &amp;pdev-&gt;dev);
-
-	net_dev-&gt;open = bcm43xx_net_open;
-	net_dev-&gt;stop = bcm43xx_net_stop;
-	net_dev-&gt;tx_timeout = bcm43xx_net_tx_timeout;
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	net_dev-&gt;poll_controller = bcm43xx_net_poll_controller;
-#endif
-	net_dev-&gt;wireless_handlers = &amp;bcm43xx_wx_handlers_def;
-	net_dev-&gt;irq = pdev-&gt;irq;
-	SET_ETHTOOL_OPS(net_dev, &amp;bcm43xx_ethtool_ops);
-
-	/* initialize the bcm43xx_private struct */
-	bcm = bcm43xx_priv(net_dev);
-	memset(bcm, 0, sizeof(*bcm));
-	err = bcm43xx_init_private(bcm, net_dev, pdev);
-	if (err)
-		goto err_free_netdev;
-
-	pci_set_drvdata(pdev, net_dev);
-
-	err = bcm43xx_attach_board(bcm);
-	if (err)
-		goto err_free_netdev;
-
-	err = register_netdev(net_dev);
-	if (err) {
-		printk(KERN_ERR PFX &quot;Cannot register net device, &quot;
-		       &quot;aborting.\n&quot;);
-		err = -ENOMEM;
-		goto err_detach_board;
-	}
-
-	bcm43xx_debugfs_add_device(bcm);
-
-	assert(err == 0);
-out:
-	return err;
-
-err_detach_board:
-	bcm43xx_detach_board(bcm);
-err_free_netdev:
-	free_ieee80211softmac(net_dev);
-	goto out;
-}
-
-static void __devexit bcm43xx_remove_one(struct pci_dev *pdev)
-{
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-
-	bcm43xx_debugfs_remove_device(bcm);
-	unregister_netdev(net_dev);
-	bcm43xx_detach_board(bcm);
-	free_ieee80211softmac(net_dev);
-}
-
-/* Hard-reset the chip. Do not call this directly.
- * Use bcm43xx_controller_restart()
- */
-static void bcm43xx_chip_reset(struct work_struct *work)
-{
-	struct bcm43xx_private *bcm =
-		container_of(work, struct bcm43xx_private, restart_work);
-	struct bcm43xx_phyinfo *phy;
-	int err = -ENODEV;
-
-	bcm43xx_cancel_work(bcm);
-	mutex_lock(&amp;(bcm)-&gt;mutex);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		phy = bcm43xx_current_phy(bcm);
-		err = bcm43xx_select_wireless_core(bcm, phy-&gt;type);
-		if (!err)
-			bcm43xx_periodic_tasks_setup(bcm);
-	}
-	mutex_unlock(&amp;(bcm)-&gt;mutex);
-
-	printk(KERN_ERR PFX &quot;Controller restart%s\n&quot;,
-	       (err == 0) ? &quot;ed&quot; : &quot; failed&quot;);
-}
-
-/* Hard-reset the chip.
- * This can be called from interrupt or process context.
- * bcm-&gt;irq_lock must be locked.
- */
-void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason)
-{
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)
-		return;
-	printk(KERN_ERR PFX &quot;Controller RESET (%s) ...\n&quot;, reason);
-	INIT_WORK(&amp;bcm-&gt;restart_work, bcm43xx_chip_reset);
-	schedule_work(&amp;bcm-&gt;restart_work);
-}
-
-#ifdef CONFIG_PM
-
-static int bcm43xx_suspend(struct pci_dev *pdev, pm_message_t state)
-{
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
-
-	dprintk(KERN_INFO PFX &quot;Suspending...\n&quot;);
-
-	netif_device_detach(net_dev);
-	bcm-&gt;was_initialized = 0;
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		bcm-&gt;was_initialized = 1;
-		ieee80211softmac_stop(net_dev);
-		err = bcm43xx_disable_interrupts_sync(bcm);
-		if (unlikely(err)) {
-			dprintk(KERN_ERR PFX &quot;Suspend failed.\n&quot;);
-			return -EAGAIN;
-		}
-		bcm-&gt;firmware_norelease = 1;
-		bcm43xx_free_board(bcm);
-		bcm-&gt;firmware_norelease = 0;
-	}
-	bcm43xx_chipset_detach(bcm);
-
-	pci_save_state(pdev);
-	pci_disable_device(pdev);
-	pci_set_power_state(pdev, pci_choose_state(pdev, state));
-
-	dprintk(KERN_INFO PFX &quot;Device suspended.\n&quot;);
-
-	return 0;
-}
-
-static int bcm43xx_resume(struct pci_dev *pdev)
-{
-	struct net_device *net_dev = pci_get_drvdata(pdev);
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err = 0;
-
-	dprintk(KERN_INFO PFX &quot;Resuming...\n&quot;);
-
-	pci_set_power_state(pdev, 0);
-	err = pci_enable_device(pdev);
-	if (err) {
-		printk(KERN_ERR PFX &quot;Failure with pci_enable_device!\n&quot;);
-		return err;
-	}
-	pci_restore_state(pdev);
-
-	bcm43xx_chipset_attach(bcm);
-	if (bcm-&gt;was_initialized)
-		err = bcm43xx_init_board(bcm);
-	if (err) {
-		printk(KERN_ERR PFX &quot;Resume failed!\n&quot;);
-		return err;
-	}
-	netif_device_attach(net_dev);
-
-	dprintk(KERN_INFO PFX &quot;Device resumed.\n&quot;);
-
-	return 0;
-}
-
-#endif				/* CONFIG_PM */
-
-static struct pci_driver bcm43xx_pci_driver = {
-	.name = KBUILD_MODNAME,
-	.id_table = bcm43xx_pci_tbl,
-	.probe = bcm43xx_init_one,
-	.remove = __devexit_p(bcm43xx_remove_one),
-#ifdef CONFIG_PM
-	.suspend = bcm43xx_suspend,
-	.resume = bcm43xx_resume,
-#endif				/* CONFIG_PM */
-};
-
-static int __init bcm43xx_init(void)
-{
-	printk(KERN_INFO KBUILD_MODNAME &quot; driver\n&quot;);
-	bcm43xx_debugfs_init();
-	return pci_register_driver(&amp;bcm43xx_pci_driver);
-}
-
-static void __exit bcm43xx_exit(void)
-{
-	pci_unregister_driver(&amp;bcm43xx_pci_driver);
-	bcm43xx_debugfs_exit();
-}
-
-module_init(bcm43xx_init)
-module_exit(bcm43xx_exit)
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_main.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_main.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef BCM43xx_MAIN_H_
-#define BCM43xx_MAIN_H_
-
-#include &quot;bcm43xx.h&quot;
-
-#define P4D_BYT3S(magic, nr_bytes)	u8 __p4dding##magic[nr_bytes]
-#define P4D_BYTES(line, nr_bytes)	P4D_BYT3S(line, nr_bytes)
-/* Magic helper macro to pad structures. Ignore those above. It's magic. */
-#define PAD_BYTES(nr_bytes)		P4D_BYTES( __LINE__ , (nr_bytes))
-
-
-/* Lightweight function to convert a frequency (in Mhz) to a channel number. */
-static inline
-u8 bcm43xx_freq_to_channel_a(int freq)
-{
-	return ((freq - 5000) / 5);
-}
-static inline
-u8 bcm43xx_freq_to_channel_bg(int freq)
-{
-	u8 channel;
-
-	if (freq == 2484)
-		channel = 14;
-	else
-		channel = (freq - 2407) / 5;
-
-	return channel;
-}
-static inline
-u8 bcm43xx_freq_to_channel(struct bcm43xx_private *bcm,
-			   int freq)
-{
-	if (bcm43xx_current_phy(bcm)-&gt;type == BCM43xx_PHYTYPE_A)
-		return bcm43xx_freq_to_channel_a(freq);
-	return bcm43xx_freq_to_channel_bg(freq);
-}
-
-/* Lightweight function to convert a channel number to a frequency (in Mhz). */
-static inline
-int bcm43xx_channel_to_freq_a(u8 channel)
-{
-	return (5000 + (5 * channel));
-}
-static inline
-int bcm43xx_channel_to_freq_bg(u8 channel)
-{
-	int freq;
-
-	if (channel == 14)
-		freq = 2484;
-	else
-		freq = 2407 + (5 * channel);
-
-	return freq;
-}
-static inline
-int bcm43xx_channel_to_freq(struct bcm43xx_private *bcm,
-			    u8 channel)
-{
-	if (bcm43xx_current_phy(bcm)-&gt;type == BCM43xx_PHYTYPE_A)
-		return bcm43xx_channel_to_freq_a(channel);
-	return bcm43xx_channel_to_freq_bg(channel);
-}
-
-void bcm43xx_tsf_read(struct bcm43xx_private *bcm, u64 *tsf);
-void bcm43xx_tsf_write(struct bcm43xx_private *bcm, u64 tsf);
-
-void bcm43xx_set_iwmode(struct bcm43xx_private *bcm,
-			int iw_mode);
-
-u32 bcm43xx_shm_read32(struct bcm43xx_private *bcm,
-		       u16 routing, u16 offset);
-u16 bcm43xx_shm_read16(struct bcm43xx_private *bcm,
-		       u16 routing, u16 offset);
-void bcm43xx_shm_write32(struct bcm43xx_private *bcm,
-			 u16 routing, u16 offset,
-			 u32 value);
-void bcm43xx_shm_write16(struct bcm43xx_private *bcm,
-			 u16 routing, u16 offset,
-			 u16 value);
-
-void bcm43xx_dummy_transmission(struct bcm43xx_private *bcm);
-
-int bcm43xx_switch_core(struct bcm43xx_private *bcm, struct bcm43xx_coreinfo *new_core);
-
-int bcm43xx_select_wireless_core(struct bcm43xx_private *bcm,
-				 int phytype);
-
-void bcm43xx_wireless_core_reset(struct bcm43xx_private *bcm, int connect_phy);
-
-void bcm43xx_mac_suspend(struct bcm43xx_private *bcm);
-void bcm43xx_mac_enable(struct bcm43xx_private *bcm);
-
-void bcm43xx_cancel_work(struct bcm43xx_private *bcm);
-void bcm43xx_periodic_tasks_setup(struct bcm43xx_private *bcm);
-
-void bcm43xx_controller_restart(struct bcm43xx_private *bcm, const char *reason);
-
-int bcm43xx_sprom_read(struct bcm43xx_private *bcm, u16 *sprom);
-int bcm43xx_sprom_write(struct bcm43xx_private *bcm, const u16 *sprom);
-
-#endif /* BCM43xx_MAIN_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_phy.c
+++ /dev/null
@@ -1,2346 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &lt;linux/delay.h&gt;
-#include &lt;linux/pci.h&gt;
-#include &lt;linux/types.h&gt;
-
-#include &quot;bcm43xx.h&quot;
-#include &quot;bcm43xx_phy.h&quot;
-#include &quot;bcm43xx_main.h&quot;
-#include &quot;bcm43xx_radio.h&quot;
-#include &quot;bcm43xx_ilt.h&quot;
-#include &quot;bcm43xx_power.h&quot;
-
-
-static const s8 bcm43xx_tssi2dbm_b_table[] = {
-	0x4D, 0x4C, 0x4B, 0x4A,
-	0x4A, 0x49, 0x48, 0x47,
-	0x47, 0x46, 0x45, 0x45,
-	0x44, 0x43, 0x42, 0x42,
-	0x41, 0x40, 0x3F, 0x3E,
-	0x3D, 0x3C, 0x3B, 0x3A,
-	0x39, 0x38, 0x37, 0x36,
-	0x35, 0x34, 0x32, 0x31,
-	0x30, 0x2F, 0x2D, 0x2C,
-	0x2B, 0x29, 0x28, 0x26,
-	0x25, 0x23, 0x21, 0x1F,
-	0x1D, 0x1A, 0x17, 0x14,
-	0x10, 0x0C, 0x06, 0x00,
-	  -7,   -7,   -7,   -7,
-	  -7,   -7,   -7,   -7,
-	  -7,   -7,   -7,   -7,
-};
-
-static const s8 bcm43xx_tssi2dbm_g_table[] = {
-	 77,  77,  77,  76,
-	 76,  76,  75,  75,
-	 74,  74,  73,  73,
-	 73,  72,  72,  71,
-	 71,  70,  70,  69,
-	 68,  68,  67,  67,
-	 66,  65,  65,  64,
-	 63,  63,  62,  61,
-	 60,  59,  58,  57,
-	 56,  55,  54,  53,
-	 52,  50,  49,  47,
-	 45,  43,  40,  37,
-	 33,  28,  22,  14,
-	  5,  -7, -20, -20,
-	-20, -20, -20, -20,
-	-20, -20, -20, -20,
-};
-
-static void bcm43xx_phy_initg(struct bcm43xx_private *bcm);
-
-
-static inline
-void bcm43xx_voluntary_preempt(void)
-{
-	assert(!in_atomic() &amp;&amp; !in_irq() &amp;&amp;
-	       !in_interrupt() &amp;&amp; !irqs_disabled());
-#ifndef CONFIG_PREEMPT
-	cond_resched();
-#endif /* CONFIG_PREEMPT */
-}
-
-void bcm43xx_raw_phy_lock(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	assert(irqs_disabled());
-	if (bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD) == 0x00000000) {
-		phy-&gt;is_locked = 0;
-		return;
-	}
-	if (bcm-&gt;current_core-&gt;rev &lt; 3) {
-		bcm43xx_mac_suspend(bcm);
-		spin_lock(&amp;phy-&gt;lock);
-	} else {
-		if (bcm-&gt;ieee-&gt;iw_mode != IW_MODE_MASTER)
-			bcm43xx_power_saving_ctl_bits(bcm, -1, 1);
-	}
-	phy-&gt;is_locked = 1;
-}
-
-void bcm43xx_raw_phy_unlock(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	assert(irqs_disabled());
-	if (bcm-&gt;current_core-&gt;rev &lt; 3) {
-		if (phy-&gt;is_locked) {
-			spin_unlock(&amp;phy-&gt;lock);
-			bcm43xx_mac_enable(bcm);
-		}
-	} else {
-		if (bcm-&gt;ieee-&gt;iw_mode != IW_MODE_MASTER)
-			bcm43xx_power_saving_ctl_bits(bcm, -1, -1);
-	}
-	phy-&gt;is_locked = 0;
-}
-
-u16 bcm43xx_phy_read(struct bcm43xx_private *bcm, u16 offset)
-{
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_CONTROL, offset);
-	return bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_DATA);
-}
-
-void bcm43xx_phy_write(struct bcm43xx_private *bcm, u16 offset, u16 val)
-{
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_CONTROL, offset);
-	mmiowb();
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_DATA, val);
-}
-
-void bcm43xx_phy_calibrate(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD); /* Dummy read. */
-	if (phy-&gt;calibrated)
-		return;
-	if (phy-&gt;type == BCM43xx_PHYTYPE_G &amp;&amp; phy-&gt;rev == 1) {
-		bcm43xx_wireless_core_reset(bcm, 0);
-		bcm43xx_phy_initg(bcm);
-		bcm43xx_wireless_core_reset(bcm, 1);
-	}
-	phy-&gt;calibrated = 1;
-}
-
-/* Connect the PHY 
- * <A HREF="http://bcm-specs.sipsolutions.net/SetPHY">http://bcm-specs.sipsolutions.net/SetPHY</A>
- */
-int bcm43xx_phy_connect(struct bcm43xx_private *bcm, int connect)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u32 flags;
-
-	if (bcm-&gt;current_core-&gt;rev &lt; 5)
-		goto out;
-
-	flags = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATEHIGH);
-	if (connect) {
-		if (!(flags &amp; BCM43xx_SBTMSTATEHIGH_G_PHY_AVAIL))
-			return -ENODEV;
-		flags = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-		flags |= BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, flags);
-	} else {
-		if (!(flags &amp; BCM43xx_SBTMSTATEHIGH_A_PHY_AVAIL))
-			return -ENODEV;
-		flags = bcm43xx_read32(bcm, BCM43xx_CIR_SBTMSTATELOW);
-		flags &amp;= ~BCM43xx_SBTMSTATELOW_G_MODE_ENABLE;
-		bcm43xx_write32(bcm, BCM43xx_CIR_SBTMSTATELOW, flags);
-	}
-out:
-	phy-&gt;connected = connect;
-	if (connect)
-		dprintk(KERN_INFO PFX &quot;PHY connected\n&quot;);
-	else
-		dprintk(KERN_INFO PFX &quot;PHY disconnected\n&quot;);
-
-	return 0;
-}
-
-/* intialize B PHY power control
- * as described in <A HREF="http://bcm-specs.sipsolutions.net/InitPowerControl">http://bcm-specs.sipsolutions.net/InitPowerControl</A>
- */
-static void bcm43xx_phy_init_pctl(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 saved_batt = 0, saved_ratt = 0, saved_txctl1 = 0;
-	int must_reset_txpower = 0;
-
-	assert(phy-&gt;type != BCM43xx_PHYTYPE_A);
-	if ((bcm-&gt;board_vendor == PCI_VENDOR_ID_BROADCOM) &amp;&amp;
-	    (bcm-&gt;board_type == 0x0416))
-		return;
-
-	bcm43xx_phy_write(bcm, 0x0028, 0x8018);
-	bcm43xx_write16(bcm, 0x03E6, bcm43xx_read16(bcm, 0x03E6) &amp; 0xFFDF);
-
-	if (phy-&gt;type == BCM43xx_PHYTYPE_G) {
-		if (!phy-&gt;connected)
-			return;
-		bcm43xx_phy_write(bcm, 0x047A, 0xC111);
-	}
-	if (phy-&gt;savedpctlreg != 0xFFFF)
-		return;
-
-	if (phy-&gt;type == BCM43xx_PHYTYPE_B &amp;&amp;
-	    phy-&gt;rev &gt;= 2 &amp;&amp;
-	    radio-&gt;version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0076,
-				      bcm43xx_radio_read16(bcm, 0x0076) | 0x0084);
-	} else {
-		saved_batt = radio-&gt;baseband_atten;
-		saved_ratt = radio-&gt;radio_atten;
-		saved_txctl1 = radio-&gt;txctl1;
-		if ((radio-&gt;revision &gt;= 6) &amp;&amp; (radio-&gt;revision &lt;= 8)
-		    &amp;&amp; /*FIXME: incomplete specs for 5 &lt; revision &lt; 9 */ 0)
-			bcm43xx_radio_set_txpower_bg(bcm, 0xB, 0x1F, 0);
-		else
-			bcm43xx_radio_set_txpower_bg(bcm, 0xB, 9, 0);
-		must_reset_txpower = 1;
-	}
-	bcm43xx_dummy_transmission(bcm);
-
-	phy-&gt;savedpctlreg = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_PCTL);
-
-	if (must_reset_txpower)
-		bcm43xx_radio_set_txpower_bg(bcm, saved_batt, saved_ratt, saved_txctl1);
-	else
-		bcm43xx_radio_write16(bcm, 0x0076, bcm43xx_radio_read16(bcm, 0x0076) &amp; 0xFF7B);
-	bcm43xx_radio_clear_tssi(bcm);
-}
-
-static void bcm43xx_phy_agcsetup(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 offset = 0x0000;
-
-	if (phy-&gt;rev == 1)
-		offset = 0x4C00;
-
-	bcm43xx_ilt_write(bcm, offset, 0x00FE);
-	bcm43xx_ilt_write(bcm, offset + 1, 0x000D);
-	bcm43xx_ilt_write(bcm, offset + 2, 0x0013);
-	bcm43xx_ilt_write(bcm, offset + 3, 0x0019);
-
-	if (phy-&gt;rev == 1) {
-		bcm43xx_ilt_write(bcm, 0x1800, 0x2710);
-		bcm43xx_ilt_write(bcm, 0x1801, 0x9B83);
-		bcm43xx_ilt_write(bcm, 0x1802, 0x9B83);
-		bcm43xx_ilt_write(bcm, 0x1803, 0x0F8D);
-		bcm43xx_phy_write(bcm, 0x0455, 0x0004);
-	}
-
-	bcm43xx_phy_write(bcm, 0x04A5, (bcm43xx_phy_read(bcm, 0x04A5) &amp; 0x00FF) | 0x5700);
-	bcm43xx_phy_write(bcm, 0x041A, (bcm43xx_phy_read(bcm, 0x041A) &amp; 0xFF80) | 0x000F);
-	bcm43xx_phy_write(bcm, 0x041A, (bcm43xx_phy_read(bcm, 0x041A) &amp; 0xC07F) | 0x2B80);
-	bcm43xx_phy_write(bcm, 0x048C, (bcm43xx_phy_read(bcm, 0x048C) &amp; 0xF0FF) | 0x0300);
-
-	bcm43xx_radio_write16(bcm, 0x007A, bcm43xx_radio_read16(bcm, 0x007A) | 0x0008);
-
-	bcm43xx_phy_write(bcm, 0x04A0, (bcm43xx_phy_read(bcm, 0x04A0) &amp; 0xFFF0) | 0x0008);
-	bcm43xx_phy_write(bcm, 0x04A1, (bcm43xx_phy_read(bcm, 0x04A1) &amp; 0xF0FF) | 0x0600);
-	bcm43xx_phy_write(bcm, 0x04A2, (bcm43xx_phy_read(bcm, 0x04A2) &amp; 0xF0FF) | 0x0700);
-	bcm43xx_phy_write(bcm, 0x04A0, (bcm43xx_phy_read(bcm, 0x04A0) &amp; 0xF0FF) | 0x0100);
-
-	if (phy-&gt;rev == 1)
-		bcm43xx_phy_write(bcm, 0x04A2, (bcm43xx_phy_read(bcm, 0x04A2) &amp; 0xFFF0) | 0x0007);
-
-	bcm43xx_phy_write(bcm, 0x0488, (bcm43xx_phy_read(bcm, 0x0488) &amp; 0xFF00) | 0x001C);
-	bcm43xx_phy_write(bcm, 0x0488, (bcm43xx_phy_read(bcm, 0x0488) &amp; 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(bcm, 0x0496, (bcm43xx_phy_read(bcm, 0x0496) &amp; 0xFF00) | 0x001C);
-	bcm43xx_phy_write(bcm, 0x0489, (bcm43xx_phy_read(bcm, 0x0489) &amp; 0xFF00) | 0x0020);
-	bcm43xx_phy_write(bcm, 0x0489, (bcm43xx_phy_read(bcm, 0x0489) &amp; 0xC0FF) | 0x0200);
-	bcm43xx_phy_write(bcm, 0x0482, (bcm43xx_phy_read(bcm, 0x0482) &amp; 0xFF00) | 0x002E);
-	bcm43xx_phy_write(bcm, 0x0496, (bcm43xx_phy_read(bcm, 0x0496) &amp; 0x00FF) | 0x1A00);
-	bcm43xx_phy_write(bcm, 0x0481, (bcm43xx_phy_read(bcm, 0x0481) &amp; 0xFF00) | 0x0028);
-	bcm43xx_phy_write(bcm, 0x0481, (bcm43xx_phy_read(bcm, 0x0481) &amp; 0x00FF) | 0x2C00);
-
-	if (phy-&gt;rev == 1) {
-		bcm43xx_phy_write(bcm, 0x0430, 0x092B);
-		bcm43xx_phy_write(bcm, 0x041B, (bcm43xx_phy_read(bcm, 0x041B) &amp; 0xFFE1) | 0x0002);
-	} else {
-		bcm43xx_phy_write(bcm, 0x041B, bcm43xx_phy_read(bcm, 0x041B) &amp; 0xFFE1);
-		bcm43xx_phy_write(bcm, 0x041F, 0x287A);
-		bcm43xx_phy_write(bcm, 0x0420, (bcm43xx_phy_read(bcm, 0x0420) &amp; 0xFFF0) | 0x0004);
-	}
-
-	if (phy-&gt;rev &gt; 2) {
-		bcm43xx_phy_write(bcm, 0x0422, 0x287A);
-		bcm43xx_phy_write(bcm, 0x0420, (bcm43xx_phy_read(bcm, 0x0420)
-				  &amp; 0x0FFF) | 0x3000);
-	}
-		
-	bcm43xx_phy_write(bcm, 0x04A8, (bcm43xx_phy_read(bcm, 0x04A8) &amp; 0x8080)
-					| 0x7874);
-	bcm43xx_phy_write(bcm, 0x048E, 0x1C00);
-
-	if (phy-&gt;rev == 1) {
-		bcm43xx_phy_write(bcm, 0x04AB, (bcm43xx_phy_read(bcm, 0x04AB)
-				  &amp; 0xF0FF) | 0x0600);
-		bcm43xx_phy_write(bcm, 0x048B, 0x005E);
-		bcm43xx_phy_write(bcm, 0x048C, (bcm43xx_phy_read(bcm, 0x048C)
-				  &amp; 0xFF00) | 0x001E);
-		bcm43xx_phy_write(bcm, 0x048D, 0x0002);
-	}
-
-	bcm43xx_ilt_write(bcm, offset + 0x0800, 0);
-	bcm43xx_ilt_write(bcm, offset + 0x0801, 7);
-	bcm43xx_ilt_write(bcm, offset + 0x0802, 16);
-	bcm43xx_ilt_write(bcm, offset + 0x0803, 28);
-
-	if (phy-&gt;rev &gt;= 6) {
-		bcm43xx_phy_write(bcm, 0x0426, (bcm43xx_phy_read(bcm, 0x0426)
-				  &amp; 0xFFFC));
-		bcm43xx_phy_write(bcm, 0x0426, (bcm43xx_phy_read(bcm, 0x0426)
-				  &amp; 0xEFFF));
-	}
-}
-
-static void bcm43xx_phy_setupg(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 i;
-
-	assert(phy-&gt;type == BCM43xx_PHYTYPE_G);
-	if (phy-&gt;rev == 1) {
-		bcm43xx_phy_write(bcm, 0x0406, 0x4F19);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  (bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS)
-				  &amp; 0xFC3F) | 0x0340);
-		bcm43xx_phy_write(bcm, 0x042C, 0x005A);
-		bcm43xx_phy_write(bcm, 0x0427, 0x001A);
-
-		for (i = 0; i &lt; BCM43xx_ILT_FINEFREQG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5800 + i, bcm43xx_ilt_finefreqg[i]);
-		for (i = 0; i &lt; BCM43xx_ILT_NOISEG1_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noiseg1[i]);
-		for (i = 0; i &lt; BCM43xx_ILT_ROTOR_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2000 + i, bcm43xx_ilt_rotor[i]);
-	} else {
-		/* nrssi values are signed 6-bit values. Not sure why we write 0x7654 here... */
-		bcm43xx_nrssi_hw_write(bcm, 0xBA98, (s16)0x7654);
-
-		if (phy-&gt;rev == 2) {
-			bcm43xx_phy_write(bcm, 0x04C0, 0x1861);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x0271);
-		} else if (phy-&gt;rev &gt; 2) {
-			bcm43xx_phy_write(bcm, 0x04C0, 0x0098);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x0070);
-			bcm43xx_phy_write(bcm, 0x04C9, 0x0080);
-		}
-		bcm43xx_phy_write(bcm, 0x042B, bcm43xx_phy_read(bcm, 0x042B) | 0x800);
-
-		for (i = 0; i &lt; 64; i++)
-			bcm43xx_ilt_write(bcm, 0x4000 + i, i);
-		for (i = 0; i &lt; BCM43xx_ILT_NOISEG2_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noiseg2[i]);
-	}
-	
-	if (phy-&gt;rev &lt;= 2)
-		for (i = 0; i &lt; BCM43xx_ILT_NOISESCALEG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1400 + i, bcm43xx_ilt_noisescaleg1[i]);
-	else if ((phy-&gt;rev &gt;= 7) &amp;&amp; (bcm43xx_phy_read(bcm, 0x0449) &amp; 0x0200))
-		for (i = 0; i &lt; BCM43xx_ILT_NOISESCALEG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1400 + i, bcm43xx_ilt_noisescaleg3[i]);
-	else
-		for (i = 0; i &lt; BCM43xx_ILT_NOISESCALEG_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1400 + i, bcm43xx_ilt_noisescaleg2[i]);
-	
-	if (phy-&gt;rev == 2)
-		for (i = 0; i &lt; BCM43xx_ILT_SIGMASQR_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5000 + i, bcm43xx_ilt_sigmasqr1[i]);
-	else if ((phy-&gt;rev &gt; 2) &amp;&amp; (phy-&gt;rev &lt;= 8))
-		for (i = 0; i &lt; BCM43xx_ILT_SIGMASQR_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5000 + i, bcm43xx_ilt_sigmasqr2[i]);
-	
-	if (phy-&gt;rev == 1) {
-		for (i = 0; i &lt; BCM43xx_ILT_RETARD_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2400 + i, bcm43xx_ilt_retard[i]);
-		for (i = 0; i &lt; 4; i++) {
-			bcm43xx_ilt_write(bcm, 0x5404 + i, 0x0020);
-			bcm43xx_ilt_write(bcm, 0x5408 + i, 0x0020);
-			bcm43xx_ilt_write(bcm, 0x540C + i, 0x0020);
-			bcm43xx_ilt_write(bcm, 0x5410 + i, 0x0020);
-		}
-		bcm43xx_phy_agcsetup(bcm);
-
-		if ((bcm-&gt;board_vendor == PCI_VENDOR_ID_BROADCOM) &amp;&amp;
-		    (bcm-&gt;board_type == 0x0416) &amp;&amp;
-		    (bcm-&gt;board_revision == 0x0017))
-			return;
-
-		bcm43xx_ilt_write(bcm, 0x5001, 0x0002);
-		bcm43xx_ilt_write(bcm, 0x5002, 0x0001);
-	} else {
-		for (i = 0; i &lt;= 0x2F; i++)
-			bcm43xx_ilt_write(bcm, 0x1000 + i, 0x0820);
-		bcm43xx_phy_agcsetup(bcm);
-		bcm43xx_phy_read(bcm, 0x0400); /* dummy read */
-		bcm43xx_phy_write(bcm, 0x0403, 0x1000);
-		bcm43xx_ilt_write(bcm, 0x3C02, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x3C03, 0x0014);
-
-		if ((bcm-&gt;board_vendor == PCI_VENDOR_ID_BROADCOM) &amp;&amp;
-		    (bcm-&gt;board_type == 0x0416) &amp;&amp;
-		    (bcm-&gt;board_revision == 0x0017))
-			return;
-
-		bcm43xx_ilt_write(bcm, 0x0401, 0x0002);
-		bcm43xx_ilt_write(bcm, 0x0402, 0x0001);
-	}
-}
-
-/* Initialize the noisescaletable for APHY */
-static void bcm43xx_phy_init_noisescaletbl(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	int i;
-
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_CTRL, 0x1400);
-	for (i = 0; i &lt; 12; i++) {
-		if (phy-&gt;rev == 2)
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x6767);
-		else
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x2323);
-	}
-	if (phy-&gt;rev == 2)
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x6700);
-	else
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x2300);
-	for (i = 0; i &lt; 11; i++) {
-		if (phy-&gt;rev == 2)
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x6767);
-		else
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x2323);
-	}
-	if (phy-&gt;rev == 2)
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x0067);
-	else
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_ILT_A_DATA1, 0x0023);
-}
-
-static void bcm43xx_phy_setupa(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 i;
-
-	assert(phy-&gt;type == BCM43xx_PHYTYPE_A);
-	switch (phy-&gt;rev) {
-	case 2:
-		bcm43xx_phy_write(bcm, 0x008E, 0x3800);
-		bcm43xx_phy_write(bcm, 0x0035, 0x03FF);
-		bcm43xx_phy_write(bcm, 0x0036, 0x0400);
-
-		bcm43xx_ilt_write(bcm, 0x3807, 0x0051);
-
-		bcm43xx_phy_write(bcm, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(bcm, 0x0020, bcm43xx_phy_read(bcm, 0x0020) &amp; 0xFF0F);
-		bcm43xx_ilt_write(bcm, 0x3C0C, 0x07BF);
-		bcm43xx_radio_write16(bcm, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(bcm, 0x0024, 0x4680);
-		bcm43xx_phy_write(bcm, 0x0020, 0x0003);
-		bcm43xx_phy_write(bcm, 0x001D, 0x0F40);
-		bcm43xx_phy_write(bcm, 0x001F, 0x1C00);
-
-		bcm43xx_phy_write(bcm, 0x002A, (bcm43xx_phy_read(bcm, 0x002A) &amp; 0x00FF) | 0x0400);
-		bcm43xx_phy_write(bcm, 0x002B, bcm43xx_phy_read(bcm, 0x002B) &amp; 0xFBFF);
-		bcm43xx_phy_write(bcm, 0x008E, 0x58C1);
-
-		bcm43xx_ilt_write(bcm, 0x0803, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x0804, 0x001F);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x002A);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x0030);
-		bcm43xx_ilt_write(bcm, 0x0807, 0x003A);
-
-		bcm43xx_ilt_write(bcm, 0x0000, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0001, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0002, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0003, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0004, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0005, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0006, 0x0019);
-
-		bcm43xx_ilt_write(bcm, 0x0404, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0405, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0406, 0x0007);
-
-		for (i = 0; i &lt; 16; i++)
-			bcm43xx_ilt_write(bcm, 0x4000 + i, (0x8 + i) &amp; 0x000F);
-
-		bcm43xx_ilt_write(bcm, 0x3003, 0x1044);
-		bcm43xx_ilt_write(bcm, 0x3004, 0x7201);
-		bcm43xx_ilt_write(bcm, 0x3006, 0x0040);
-		bcm43xx_ilt_write(bcm, 0x3001, (bcm43xx_ilt_read(bcm, 0x3001) &amp; 0x0010) | 0x0008);
-
-		for (i = 0; i &lt; BCM43xx_ILT_FINEFREQA_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5800 + i, bcm43xx_ilt_finefreqa[i]);
-		for (i = 0; i &lt; BCM43xx_ILT_NOISEA2_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noisea2[i]);
-		for (i = 0; i &lt; BCM43xx_ILT_ROTOR_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2000 + i, bcm43xx_ilt_rotor[i]);
-		bcm43xx_phy_init_noisescaletbl(bcm);
-		for (i = 0; i &lt; BCM43xx_ILT_RETARD_SIZE; i++)
-			bcm43xx_ilt_write32(bcm, 0x2400 + i, bcm43xx_ilt_retard[i]);
-		break;
-	case 3:
-		for (i = 0; i &lt; 64; i++)
-			bcm43xx_ilt_write(bcm, 0x4000 + i, i);
-
-		bcm43xx_ilt_write(bcm, 0x3807, 0x0051);
-
-		bcm43xx_phy_write(bcm, 0x001C, 0x0FF9);
-		bcm43xx_phy_write(bcm, 0x0020, bcm43xx_phy_read(bcm, 0x0020) &amp; 0xFF0F);
-		bcm43xx_radio_write16(bcm, 0x0002, 0x07BF);
-
-		bcm43xx_phy_write(bcm, 0x0024, 0x4680);
-		bcm43xx_phy_write(bcm, 0x0020, 0x0003);
-		bcm43xx_phy_write(bcm, 0x001D, 0x0F40);
-		bcm43xx_phy_write(bcm, 0x001F, 0x1C00);
-		bcm43xx_phy_write(bcm, 0x002A, (bcm43xx_phy_read(bcm, 0x002A) &amp; 0x00FF) | 0x0400);
-
-		bcm43xx_ilt_write(bcm, 0x3001, (bcm43xx_ilt_read(bcm, 0x3001) &amp; 0x0010) | 0x0008);
-		for (i = 0; i &lt; BCM43xx_ILT_NOISEA3_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x1800 + i, bcm43xx_ilt_noisea3[i]);
-		bcm43xx_phy_init_noisescaletbl(bcm);
-		for (i = 0; i &lt; BCM43xx_ILT_SIGMASQR_SIZE; i++)
-			bcm43xx_ilt_write(bcm, 0x5000 + i, bcm43xx_ilt_sigmasqr1[i]);
-
-		bcm43xx_phy_write(bcm, 0x0003, 0x1808);
-
-		bcm43xx_ilt_write(bcm, 0x0803, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x0804, 0x001F);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x002A);
-		bcm43xx_ilt_write(bcm, 0x0805, 0x0030);
-		bcm43xx_ilt_write(bcm, 0x0807, 0x003A);
-
-		bcm43xx_ilt_write(bcm, 0x0000, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0001, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0002, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0003, 0x0013);
-		bcm43xx_ilt_write(bcm, 0x0004, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0005, 0x0015);
-		bcm43xx_ilt_write(bcm, 0x0006, 0x0019);
-
-		bcm43xx_ilt_write(bcm, 0x0404, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0405, 0x0003);
-		bcm43xx_ilt_write(bcm, 0x0406, 0x0007);
-
-		bcm43xx_ilt_write(bcm, 0x3C02, 0x000F);
-		bcm43xx_ilt_write(bcm, 0x3C03, 0x0014);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-/* Initialize APHY. This is also called for the GPHY in some cases. */
-static void bcm43xx_phy_inita(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 tval;
-
-	if (phy-&gt;type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_phy_setupa(bcm);
-	} else {
-		bcm43xx_phy_setupg(bcm);
-		if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_PACTRL)
-			bcm43xx_phy_write(bcm, 0x046E, 0x03CF);
-		return;
-	}
-
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_A_CRS,
-	                  (bcm43xx_phy_read(bcm, BCM43xx_PHY_A_CRS) &amp; 0xF83C) | 0x0340);
-	bcm43xx_phy_write(bcm, 0x0034, 0x0001);
-
-	TODO();//TODO: RSSI AGC
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_A_CRS,
-	                  bcm43xx_phy_read(bcm, BCM43xx_PHY_A_CRS) | (1 &lt;&lt; 14));
-	bcm43xx_radio_init2060(bcm);
-
-	if ((bcm-&gt;board_vendor == PCI_VENDOR_ID_BROADCOM)
-	    &amp;&amp; ((bcm-&gt;board_type == 0x0416) || (bcm-&gt;board_type == 0x040A))) {
-		if (radio-&gt;lofcal == 0xFFFF) {
-			TODO();//TODO: LOF Cal
-			bcm43xx_radio_set_tx_iq(bcm);
-		} else
-			bcm43xx_radio_write16(bcm, 0x001E, radio-&gt;lofcal);
-	}
-
-	bcm43xx_phy_write(bcm, 0x007A, 0xF111);
-
-	if (phy-&gt;savedpctlreg == 0xFFFF) {
-		bcm43xx_radio_write16(bcm, 0x0019, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0017, 0x0020);
-
-		tval = bcm43xx_ilt_read(bcm, 0x3001);
-		if (phy-&gt;rev == 1) {
-			bcm43xx_ilt_write(bcm, 0x3001,
-					  (bcm43xx_ilt_read(bcm, 0x3001) &amp; 0xFF87)
-					  | 0x0058);
-		} else {
-			bcm43xx_ilt_write(bcm, 0x3001,
-					  (bcm43xx_ilt_read(bcm, 0x3001) &amp; 0xFFC3)
-					  | 0x002C);
-		}
-		bcm43xx_dummy_transmission(bcm);
-		phy-&gt;savedpctlreg = bcm43xx_phy_read(bcm, BCM43xx_PHY_A_PCTL);
-		bcm43xx_ilt_write(bcm, 0x3001, tval);
-
-		bcm43xx_radio_set_txpower_a(bcm, 0x0018);
-	}
-	bcm43xx_radio_clear_tssi(bcm);
-}
-
-static void bcm43xx_phy_initb2(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 offset, val;
-
-	bcm43xx_write16(bcm, 0x03EC, 0x3F22);
-	bcm43xx_phy_write(bcm, 0x0020, 0x301C);
-	bcm43xx_phy_write(bcm, 0x0026, 0x0000);
-	bcm43xx_phy_write(bcm, 0x0030, 0x00C6);
-	bcm43xx_phy_write(bcm, 0x0088, 0x3E00);
-	val = 0x3C3D;
-	for (offset = 0x0089; offset &lt; 0x00A7; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
-		val -= 0x0202;
-	}
-	bcm43xx_phy_write(bcm, 0x03E4, 0x3000);
-	if (radio-&gt;channel == 0xFF)
-		bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_BG, 0);
-	else
-		bcm43xx_radio_selectchannel(bcm, radio-&gt;channel, 0);
-	if (radio-&gt;version != 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0075, 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0079, 0x0081);
-	}
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
-	if (radio-&gt;version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
-		bcm43xx_radio_write16(bcm, 0x007A, 0x000F);
-		bcm43xx_phy_write(bcm, 0x0038, 0x0677);
-		bcm43xx_radio_init2050(bcm);
-	}
-	bcm43xx_phy_write(bcm, 0x0014, 0x0080);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CA);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CC);
-	bcm43xx_phy_write(bcm, 0x0035, 0x07C2);
-	bcm43xx_phy_lo_b_measure(bcm);
-	bcm43xx_phy_write(bcm, 0x0026, 0xCC00);
-	if (radio-&gt;version != 0x2050)
-		bcm43xx_phy_write(bcm, 0x0026, 0xCE00);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, 0x1000);
-	bcm43xx_phy_write(bcm, 0x002A, 0x88A3);
-	if (radio-&gt;version != 0x2050)
-		bcm43xx_phy_write(bcm, 0x002A, 0x88C2);
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
-	bcm43xx_phy_init_pctl(bcm);
-}
-
-static void bcm43xx_phy_initb4(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 offset, val;
-
-	bcm43xx_write16(bcm, 0x03EC, 0x3F22);
-	bcm43xx_phy_write(bcm, 0x0020, 0x301C);
-	bcm43xx_phy_write(bcm, 0x0026, 0x0000);
-	bcm43xx_phy_write(bcm, 0x0030, 0x00C6);
-	bcm43xx_phy_write(bcm, 0x0088, 0x3E00);
-	val = 0x3C3D;
-	for (offset = 0x0089; offset &lt; 0x00A7; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
-		val -= 0x0202;
-	}
-	bcm43xx_phy_write(bcm, 0x03E4, 0x3000);
-	if (radio-&gt;channel == 0xFF)
-		bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_BG, 0);
-	else
-		bcm43xx_radio_selectchannel(bcm, radio-&gt;channel, 0);
-	if (radio-&gt;version != 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0075, 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0079, 0x0081);
-	}
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
-	if (radio-&gt;version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
-		bcm43xx_radio_write16(bcm, 0x007A, 0x000F);
-		bcm43xx_phy_write(bcm, 0x0038, 0x0677);
-		bcm43xx_radio_init2050(bcm);
-	}
-	bcm43xx_phy_write(bcm, 0x0014, 0x0080);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CA);
-	if (radio-&gt;version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x0032, 0x00E0);
-	bcm43xx_phy_write(bcm, 0x0035, 0x07C2);
-
-	bcm43xx_phy_lo_b_measure(bcm);
-
-	bcm43xx_phy_write(bcm, 0x0026, 0xCC00);
-	if (radio-&gt;version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x0026, 0xCE00);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, 0x1100);
-	bcm43xx_phy_write(bcm, 0x002A, 0x88A3);
-	if (radio-&gt;version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x002A, 0x88C2);
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
-	if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_RSSI) {
-		bcm43xx_calc_nrssi_slope(bcm);
-		bcm43xx_calc_nrssi_threshold(bcm);
-	}
-	bcm43xx_phy_init_pctl(bcm);
-}
-
-static void bcm43xx_phy_initb5(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 offset;
-	u16 value;
-	u8 old_channel;
-
-	if (phy-&gt;analog == 1)
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A)
-				      | 0x0050);
-	if ((bcm-&gt;board_vendor != PCI_VENDOR_ID_BROADCOM) &amp;&amp;
-	    (bcm-&gt;board_type != 0x0416)) {
-		value = 0x2120;
-		for (offset = 0x00A8 ; offset &lt; 0x00C7; offset++) {
-			bcm43xx_phy_write(bcm, offset, value);
-			value += 0x0202;
-		}
-	}
-	bcm43xx_phy_write(bcm, 0x0035,
-			  (bcm43xx_phy_read(bcm, 0x0035) &amp; 0xF0FF)
-			  | 0x0700);
-	if (radio-&gt;version == 0x2050)
-		bcm43xx_phy_write(bcm, 0x0038, 0x0667);
-
-	if (phy-&gt;connected) {
-		if (radio-&gt;version == 0x2050) {
-			bcm43xx_radio_write16(bcm, 0x007A,
-					      bcm43xx_radio_read16(bcm, 0x007A)
-					      | 0x0020);
-			bcm43xx_radio_write16(bcm, 0x0051,
-					      bcm43xx_radio_read16(bcm, 0x0051)
-					      | 0x0004);
-		}
-		bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_RADIO, 0x0000);
-
-		bcm43xx_phy_write(bcm, 0x0802, bcm43xx_phy_read(bcm, 0x0802) | 0x0100);
-		bcm43xx_phy_write(bcm, 0x042B, bcm43xx_phy_read(bcm, 0x042B) | 0x2000);
-
-		bcm43xx_phy_write(bcm, 0x001C, 0x186A);
-
-		bcm43xx_phy_write(bcm, 0x0013, (bcm43xx_phy_read(bcm, 0x0013) &amp; 0x00FF) | 0x1900);
-		bcm43xx_phy_write(bcm, 0x0035, (bcm43xx_phy_read(bcm, 0x0035) &amp; 0xFFC0) | 0x0064);
-		bcm43xx_phy_write(bcm, 0x005D, (bcm43xx_phy_read(bcm, 0x005D) &amp; 0xFF80) | 0x000A);
-	}
-
-	if (bcm-&gt;bad_frames_preempt) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD) | (1 &lt;&lt; 11));
-	}
-
-	if (phy-&gt;analog == 1) {
-		bcm43xx_phy_write(bcm, 0x0026, 0xCE00);
-		bcm43xx_phy_write(bcm, 0x0021, 0x3763);
-		bcm43xx_phy_write(bcm, 0x0022, 0x1BC3);
-		bcm43xx_phy_write(bcm, 0x0023, 0x06F9);
-		bcm43xx_phy_write(bcm, 0x0024, 0x037E);
-	} else
-		bcm43xx_phy_write(bcm, 0x0026, 0xCC00);
-	bcm43xx_phy_write(bcm, 0x0030, 0x00C6);
-	bcm43xx_write16(bcm, 0x03EC, 0x3F22);
-
-	if (phy-&gt;analog == 1)
-		bcm43xx_phy_write(bcm, 0x0020, 0x3E1C);
-	else
-		bcm43xx_phy_write(bcm, 0x0020, 0x301C);
-
-	if (phy-&gt;analog == 0)
-		bcm43xx_write16(bcm, 0x03E4, 0x3000);
-
-	old_channel = radio-&gt;channel;
-	/* Force to channel 7, even if not supported. */
-	bcm43xx_radio_selectchannel(bcm, 7, 0);
-
-	if (radio-&gt;version != 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0075, 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0079, 0x0081);
-	}
-
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
-
-	if (radio-&gt;version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
-	}
-
-	bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-	bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
-
-	bcm43xx_radio_write16(bcm, 0x007A, bcm43xx_radio_read16(bcm, 0x007A) | 0x0007);
-
-	bcm43xx_radio_selectchannel(bcm, old_channel, 0);
-
-	bcm43xx_phy_write(bcm, 0x0014, 0x0080);
-	bcm43xx_phy_write(bcm, 0x0032, 0x00CA);
-	bcm43xx_phy_write(bcm, 0x002A, 0x88A3);
-
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
-
-	if (radio-&gt;version == 0x2050)
-		bcm43xx_radio_write16(bcm, 0x005D, 0x000D);
-
-	bcm43xx_write16(bcm, 0x03E4, (bcm43xx_read16(bcm, 0x03E4) &amp; 0xFFC0) | 0x0004);
-}
-
-static void bcm43xx_phy_initb6(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 offset, val;
-	u8 old_channel;
-
-	bcm43xx_phy_write(bcm, 0x003E, 0x817A);
-	bcm43xx_radio_write16(bcm, 0x007A,
-	                      (bcm43xx_radio_read16(bcm, 0x007A) | 0x0058));
-	if (radio-&gt;revision == 4 ||
-	     radio-&gt;revision == 5) {
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0037);
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x0053, 0x00B3);
-		bcm43xx_radio_write16(bcm, 0x0054, 0x009B);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005D, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005E, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x007D, 0x0088);
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODEFLAGS_OFFSET,
-				    (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODEFLAGS_OFFSET)
-				    | 0x00000200));
-	}
-	if (radio-&gt;revision == 8) {
-		bcm43xx_radio_write16(bcm, 0x0051, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0040);
-		bcm43xx_radio_write16(bcm, 0x0053, 0x00B7);
-		bcm43xx_radio_write16(bcm, 0x0054, 0x0098);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0088);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x006B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x000F);
-		if (bcm-&gt;sprom.boardflags &amp; 0x8000) {
-			bcm43xx_radio_write16(bcm, 0x005D, 0x00FA);
-			bcm43xx_radio_write16(bcm, 0x005E, 0x00D8);
-		} else {
-			bcm43xx_radio_write16(bcm, 0x005D, 0x00F5);
-			bcm43xx_radio_write16(bcm, 0x005E, 0x00B8);
-		}
-		bcm43xx_radio_write16(bcm, 0x0073, 0x0003);
-		bcm43xx_radio_write16(bcm, 0x007D, 0x00A8);
-		bcm43xx_radio_write16(bcm, 0x007C, 0x0001);
-		bcm43xx_radio_write16(bcm, 0x007E, 0x0008);
-	}
-	val = 0x1E1F;
-	for (offset = 0x0088; offset &lt; 0x0098; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
-		val -= 0x0202;
-	}
-	val = 0x3E3F;
-	for (offset = 0x0098; offset &lt; 0x00A8; offset++) {
-		bcm43xx_phy_write(bcm, offset, val);
-		val -= 0x0202;
-	}
-	val = 0x2120;
-	for (offset = 0x00A8; offset &lt; 0x00C8; offset++) {
-		bcm43xx_phy_write(bcm, offset, (val &amp; 0x3F3F));
-		val += 0x0202;
-	}
-	if (phy-&gt;type == BCM43xx_PHYTYPE_G) {
-		bcm43xx_radio_write16(bcm, 0x007A,
-		                      bcm43xx_radio_read16(bcm, 0x007A) | 0x0020);
-		bcm43xx_radio_write16(bcm, 0x0051,
-		                      bcm43xx_radio_read16(bcm, 0x0051) | 0x0004);
-		bcm43xx_phy_write(bcm, 0x0802,
-		                  bcm43xx_phy_read(bcm, 0x0802) | 0x0100);
-		bcm43xx_phy_write(bcm, 0x042B,
-		                  bcm43xx_phy_read(bcm, 0x042B) | 0x2000);
-		bcm43xx_phy_write(bcm, 0x5B, 0x0000);
-		bcm43xx_phy_write(bcm, 0x5C, 0x0000);
-	}
-
-	old_channel = radio-&gt;channel;
-	if (old_channel &gt;= 8)
-		bcm43xx_radio_selectchannel(bcm, 1, 0);
-	else
-		bcm43xx_radio_selectchannel(bcm, 13, 0);
-
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	bcm43xx_radio_write16(bcm, 0x0050, 0x0023);
-	udelay(40);
-	if (radio-&gt;revision &lt; 6 || radio-&gt; revision == 8) {
-		bcm43xx_radio_write16(bcm, 0x007C, (bcm43xx_radio_read16(bcm, 0x007C)
-				      | 0x0002));
-		bcm43xx_radio_write16(bcm, 0x0050, 0x0020);
-	}
-	if (radio-&gt;revision &lt;= 2) {
-		bcm43xx_radio_write16(bcm, 0x007C, 0x0020);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0070);
-		bcm43xx_radio_write16(bcm, 0x005B, 0x007B);
-		bcm43xx_radio_write16(bcm, 0x005C, 0x00B0);
-	}
-	bcm43xx_radio_write16(bcm, 0x007A,
-	                      (bcm43xx_radio_read16(bcm, 0x007A) &amp; 0x00F8) | 0x0007);
-
-	bcm43xx_radio_selectchannel(bcm, old_channel, 0);
-
-	bcm43xx_phy_write(bcm, 0x0014, 0x0200);
-	if (radio-&gt;revision &gt;= 6)
-		bcm43xx_phy_write(bcm, 0x002A, 0x88C2);
-	else
-		bcm43xx_phy_write(bcm, 0x002A, 0x8AC0);
-	bcm43xx_phy_write(bcm, 0x0038, 0x0668);
-	bcm43xx_radio_set_txpower_bg(bcm, 0xFFFF, 0xFFFF, 0xFFFF);
-	if (radio-&gt;revision &lt;= 5)
-		bcm43xx_phy_write(bcm, 0x005D, (bcm43xx_phy_read(bcm, 0x005D)
-			          &amp; 0xFF80) | 0x0003);
-	if (radio-&gt;revision &lt;= 2)
-		bcm43xx_radio_write16(bcm, 0x005D, 0x000D);
-	
-	if (phy-&gt;analog == 4){
-		bcm43xx_write16(bcm, 0x03E4, 0x0009);
-		bcm43xx_phy_write(bcm, 0x61, bcm43xx_phy_read(bcm, 0x61) &amp; 0xFFF);
-	} else {
-		bcm43xx_phy_write(bcm, 0x0002, (bcm43xx_phy_read(bcm, 0x0002) &amp; 0xFFC0) | 0x0004);
-	}
-	if (phy-&gt;type == BCM43xx_PHYTYPE_G)
-		bcm43xx_write16(bcm, 0x03E6, 0x0);
-	if (phy-&gt;type == BCM43xx_PHYTYPE_B) {
-		bcm43xx_write16(bcm, 0x03E6, 0x8140);
-		bcm43xx_phy_write(bcm, 0x0016, 0x0410);
-		bcm43xx_phy_write(bcm, 0x0017, 0x0820);
-		bcm43xx_phy_write(bcm, 0x0062, 0x0007);
-		bcm43xx_radio_init2050(bcm);
-		bcm43xx_phy_lo_g_measure(bcm);
-		if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_RSSI) {
-			bcm43xx_calc_nrssi_slope(bcm);
-			bcm43xx_calc_nrssi_threshold(bcm);
-		}
-		bcm43xx_phy_init_pctl(bcm);
-	}
-}
-
-static void bcm43xx_calc_loopback_gain(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 backup_phy[15] = {0};
-	u16 backup_radio[3];
-	u16 backup_bband;
-	u16 i;
-	u16 loop1_cnt, loop1_done, loop1_omitted;
-	u16 loop2_done;
-
-	backup_phy[0] = bcm43xx_phy_read(bcm, 0x0429);
-	backup_phy[1] = bcm43xx_phy_read(bcm, 0x0001);
-	backup_phy[2] = bcm43xx_phy_read(bcm, 0x0811);
-	backup_phy[3] = bcm43xx_phy_read(bcm, 0x0812);
-	if (phy-&gt;rev != 1) {
-		backup_phy[4] = bcm43xx_phy_read(bcm, 0x0814);
-		backup_phy[5] = bcm43xx_phy_read(bcm, 0x0815);
-	}
-	backup_phy[6] = bcm43xx_phy_read(bcm, 0x005A);
-	backup_phy[7] = bcm43xx_phy_read(bcm, 0x0059);
-	backup_phy[8] = bcm43xx_phy_read(bcm, 0x0058);
-	backup_phy[9] = bcm43xx_phy_read(bcm, 0x000A);
-	backup_phy[10] = bcm43xx_phy_read(bcm, 0x0003);
-	backup_phy[11] = bcm43xx_phy_read(bcm, 0x080F);
-	backup_phy[12] = bcm43xx_phy_read(bcm, 0x0810);
-	backup_phy[13] = bcm43xx_phy_read(bcm, 0x002B);
-	backup_phy[14] = bcm43xx_phy_read(bcm, 0x0015);
-	bcm43xx_phy_read(bcm, 0x002D); /* dummy read */
-	backup_bband = radio-&gt;baseband_atten;
-	backup_radio[0] = bcm43xx_radio_read16(bcm, 0x0052);
-	backup_radio[1] = bcm43xx_radio_read16(bcm, 0x0043);
-	backup_radio[2] = bcm43xx_radio_read16(bcm, 0x007A);
-
-	bcm43xx_phy_write(bcm, 0x0429,
-			  bcm43xx_phy_read(bcm, 0x0429) &amp; 0x3FFF);
-	bcm43xx_phy_write(bcm, 0x0001,
-			  bcm43xx_phy_read(bcm, 0x0001) &amp; 0x8000);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x0002);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) &amp; 0xFFFD);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x0001);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) &amp; 0xFFFE);
-	if (phy-&gt;rev != 1) {
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0001);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) &amp; 0xFFFE);
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0002);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) &amp; 0xFFFD);
-	}
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x000C);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) | 0x000C);
-
-	bcm43xx_phy_write(bcm, 0x0811,
-			  (bcm43xx_phy_read(bcm, 0x0811)
-			   &amp; 0xFFCF) | 0x0030);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  (bcm43xx_phy_read(bcm, 0x0812)
-			   &amp; 0xFFCF) | 0x0010);
-
-	bcm43xx_phy_write(bcm, 0x005A, 0x0780);
-	bcm43xx_phy_write(bcm, 0x0059, 0xC810);
-	bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-	if (phy-&gt;analog == 0) {
-		bcm43xx_phy_write(bcm, 0x0003, 0x0122);
-	} else {
-		bcm43xx_phy_write(bcm, 0x000A,
-				  bcm43xx_phy_read(bcm, 0x000A)
-				  | 0x2000);
-	}
-	if (phy-&gt;rev != 1) {
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0004);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) &amp; 0xFFFB);
-	}
-	bcm43xx_phy_write(bcm, 0x0003,
-			  (bcm43xx_phy_read(bcm, 0x0003)
-			   &amp; 0xFF9F) | 0x0040);
-	if (radio-&gt;version == 0x2050 &amp;&amp; radio-&gt;revision == 2) {
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      (bcm43xx_radio_read16(bcm, 0x0043)
-				       &amp; 0xFFF0) | 0x0009);
-		loop1_cnt = 9;
-	} else if (radio-&gt;revision == 8) {
-		bcm43xx_radio_write16(bcm, 0x0043, 0x000F);
-		loop1_cnt = 15;
-	} else
-		loop1_cnt = 0;
-
-	bcm43xx_phy_set_baseband_attenuation(bcm, 11);
-
-	if (phy-&gt;rev &gt;= 3)
-		bcm43xx_phy_write(bcm, 0x080F, 0xC020);
-	else
-		bcm43xx_phy_write(bcm, 0x080F, 0x8020);
-	bcm43xx_phy_write(bcm, 0x0810, 0x0000);
-
-	bcm43xx_phy_write(bcm, 0x002B,
-			  (bcm43xx_phy_read(bcm, 0x002B)
-			   &amp; 0xFFC0) | 0x0001);
-	bcm43xx_phy_write(bcm, 0x002B,
-			  (bcm43xx_phy_read(bcm, 0x002B)
-			   &amp; 0xC0FF) | 0x0800);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x0100);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  bcm43xx_phy_read(bcm, 0x0812) &amp; 0xCFFF);
-	if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_EXTLNA) {
-		if (phy-&gt;rev &gt;= 7) {
-			bcm43xx_phy_write(bcm, 0x0811,
-					  bcm43xx_phy_read(bcm, 0x0811)
-					  | 0x0800);
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_phy_read(bcm, 0x0812)
-					  | 0x8000);
-		}
-	}
-	bcm43xx_radio_write16(bcm, 0x007A,
-			      bcm43xx_radio_read16(bcm, 0x007A)
-			      &amp; 0x00F7);
-
-	for (i = 0; i &lt; loop1_cnt; i++) {
-		bcm43xx_radio_write16(bcm, 0x0043, loop1_cnt);
-		bcm43xx_phy_write(bcm, 0x0812,
-				  (bcm43xx_phy_read(bcm, 0x0812)
-				   &amp; 0xF0FF) | (i &lt;&lt; 8));
-		bcm43xx_phy_write(bcm, 0x0015,
-				  (bcm43xx_phy_read(bcm, 0x0015)
-				   &amp; 0x0FFF) | 0xA000);
-		bcm43xx_phy_write(bcm, 0x0015,
-				  (bcm43xx_phy_read(bcm, 0x0015)
-				   &amp; 0x0FFF) | 0xF000);
-		udelay(20);
-		if (bcm43xx_phy_read(bcm, 0x002D) &gt;= 0x0DFC)
-			break;
-	}
-	loop1_done = i;
-	loop1_omitted = loop1_cnt - loop1_done;
-
-	loop2_done = 0;
-	if (loop1_done &gt;= 8) {
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_phy_read(bcm, 0x0812)
-				  | 0x0030);
-		for (i = loop1_done - 8; i &lt; 16; i++) {
-			bcm43xx_phy_write(bcm, 0x0812,
-					  (bcm43xx_phy_read(bcm, 0x0812)
-					   &amp; 0xF0FF) | (i &lt;&lt; 8));
-			bcm43xx_phy_write(bcm, 0x0015,
-					  (bcm43xx_phy_read(bcm, 0x0015)
-					   &amp; 0x0FFF) | 0xA000);
-			bcm43xx_phy_write(bcm, 0x0015,
-					  (bcm43xx_phy_read(bcm, 0x0015)
-					   &amp; 0x0FFF) | 0xF000);
-			udelay(20);
-			if (bcm43xx_phy_read(bcm, 0x002D) &gt;= 0x0DFC)
-				break;
-		}
-	}
-
-	if (phy-&gt;rev != 1) {
-		bcm43xx_phy_write(bcm, 0x0814, backup_phy[4]);
-		bcm43xx_phy_write(bcm, 0x0815, backup_phy[5]);
-	}
-	bcm43xx_phy_write(bcm, 0x005A, backup_phy[6]);
-	bcm43xx_phy_write(bcm, 0x0059, backup_phy[7]);
-	bcm43xx_phy_write(bcm, 0x0058, backup_phy[8]);
-	bcm43xx_phy_write(bcm, 0x000A, backup_phy[9]);
-	bcm43xx_phy_write(bcm, 0x0003, backup_phy[10]);
-	bcm43xx_phy_write(bcm, 0x080F, backup_phy[11]);
-	bcm43xx_phy_write(bcm, 0x0810, backup_phy[12]);
-	bcm43xx_phy_write(bcm, 0x002B, backup_phy[13]);
-	bcm43xx_phy_write(bcm, 0x0015, backup_phy[14]);
-
-	bcm43xx_phy_set_baseband_attenuation(bcm, backup_bband);
-
-	bcm43xx_radio_write16(bcm, 0x0052, backup_radio[0]);
-	bcm43xx_radio_write16(bcm, 0x0043, backup_radio[1]);
-	bcm43xx_radio_write16(bcm, 0x007A, backup_radio[2]);
-
-	bcm43xx_phy_write(bcm, 0x0811, backup_phy[2] | 0x0003);
-	udelay(10);
-	bcm43xx_phy_write(bcm, 0x0811, backup_phy[2]);
-	bcm43xx_phy_write(bcm, 0x0812, backup_phy[3]);
-	bcm43xx_phy_write(bcm, 0x0429, backup_phy[0]);
-	bcm43xx_phy_write(bcm, 0x0001, backup_phy[1]);
-
-	phy-&gt;loopback_gain[0] = ((loop1_done * 6) - (loop1_omitted * 4)) - 11;
-	phy-&gt;loopback_gain[1] = (24 - (3 * loop2_done)) * 2;
-}
-
-static void bcm43xx_phy_initg(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 tmp;
-
-	if (phy-&gt;rev == 1)
-		bcm43xx_phy_initb5(bcm);
-	else
-		bcm43xx_phy_initb6(bcm);
-	if (phy-&gt;rev &gt;= 2 || phy-&gt;connected)
-		bcm43xx_phy_inita(bcm);
-
-	if (phy-&gt;rev &gt;= 2) {
-		bcm43xx_phy_write(bcm, 0x0814, 0x0000);
-		bcm43xx_phy_write(bcm, 0x0815, 0x0000);
-	}
-	if (phy-&gt;rev == 2) {
-		bcm43xx_phy_write(bcm, 0x0811, 0x0000);
-		bcm43xx_phy_write(bcm, 0x0015, 0x00C0);
-	}
-	if (phy-&gt;rev &gt; 5) {
-		bcm43xx_phy_write(bcm, 0x0811, 0x0400);
-		bcm43xx_phy_write(bcm, 0x0015, 0x00C0);
-	}
-	if (phy-&gt;rev &gt;= 2 &amp;&amp; phy-&gt;connected) {
-		tmp = bcm43xx_phy_read(bcm, 0x0400) &amp; 0xFF;
-		if (tmp ==3 || tmp == 5) {
-			bcm43xx_phy_write(bcm, 0x04C2, 0x1816);
-			bcm43xx_phy_write(bcm, 0x04C3, 0x8006);
-			if (tmp == 5) {
-				bcm43xx_phy_write(bcm, 0x04CC,
-						  (bcm43xx_phy_read(bcm, 0x04CC)
-						   &amp; 0x00FF) | 0x1F00);
-			}
-		}
-		bcm43xx_phy_write(bcm, 0x047E, 0x0078);
-	}
-	if (radio-&gt;revision == 8) {
-		bcm43xx_phy_write(bcm, 0x0801, bcm43xx_phy_read(bcm, 0x0801) | 0x0080);
-		bcm43xx_phy_write(bcm, 0x043E, bcm43xx_phy_read(bcm, 0x043E) | 0x0004);
-	}
-	if (phy-&gt;rev &gt;= 2 &amp;&amp; phy-&gt;connected)
-		bcm43xx_calc_loopback_gain(bcm);
-	if (radio-&gt;revision != 8) {
-		if (radio-&gt;initval == 0xFFFF)
-			radio-&gt;initval = bcm43xx_radio_init2050(bcm);
-		else
-			bcm43xx_radio_write16(bcm, 0x0078, radio-&gt;initval);
-	}
-	if (radio-&gt;txctl2 == 0xFFFF) {
-		bcm43xx_phy_lo_g_measure(bcm);
-	} else {
-		if (radio-&gt;version == 0x2050 &amp;&amp; radio-&gt;revision == 8) {
-			bcm43xx_radio_write16(bcm, 0x0052,
-					      (radio-&gt;txctl1 &lt;&lt; 4) | radio-&gt;txctl2);
-		} else {
-			bcm43xx_radio_write16(bcm, 0x0052,
-					      (bcm43xx_radio_read16(bcm, 0x0052)
-					       &amp; 0xFFF0) | radio-&gt;txctl1);
-		}
-		if (phy-&gt;rev &gt;= 6) {
-			bcm43xx_phy_write(bcm, 0x0036,
-					  (bcm43xx_phy_read(bcm, 0x0036)
-					   &amp; 0x0FFF) | (radio-&gt;txctl2 &lt;&lt; 12));
-		}
-		if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_PACTRL)
-			bcm43xx_phy_write(bcm, 0x002E, 0x8075);
-		else
-			bcm43xx_phy_write(bcm, 0x002E, 0x807F);
-		if (phy-&gt;rev &lt; 2)
-			bcm43xx_phy_write(bcm, 0x002F, 0x0101);
-		else
-			bcm43xx_phy_write(bcm, 0x002F, 0x0202);
-	}
-	if (phy-&gt;connected || phy-&gt;rev &gt;= 2) {
-		bcm43xx_phy_lo_adjust(bcm, 0);
-		bcm43xx_phy_write(bcm, 0x080F, 0x8078);
-	}
-
-	if (!(bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_RSSI)) {
-		/* The specs state to update the NRSSI LT with
-		 * the value 0x7FFFFFFF here. I think that is some weird
-		 * compiler optimization in the original driver.
-		 * Essentially, what we do here is resetting all NRSSI LT
-		 * entries to -32 (see the limit_value() in nrssi_hw_update())
-		 */
-		bcm43xx_nrssi_hw_update(bcm, 0xFFFF);
-		bcm43xx_calc_nrssi_threshold(bcm);
-	} else if (phy-&gt;connected || phy-&gt;rev &gt;= 2) {
-		if (radio-&gt;nrssi[0] == -1000) {
-			assert(radio-&gt;nrssi[1] == -1000);
-			bcm43xx_calc_nrssi_slope(bcm);
-		} else {
-			assert(radio-&gt;nrssi[1] != -1000);
-			bcm43xx_calc_nrssi_threshold(bcm);
-		}
-	}
-	if (radio-&gt;revision == 8)
-		bcm43xx_phy_write(bcm, 0x0805, 0x3230);
-	bcm43xx_phy_init_pctl(bcm);
-	if (bcm-&gt;chip_id == 0x4306 &amp;&amp; bcm-&gt;chip_package == 2) {
-		bcm43xx_phy_write(bcm, 0x0429,
-				  bcm43xx_phy_read(bcm, 0x0429) &amp; 0xBFFF);
-		bcm43xx_phy_write(bcm, 0x04C3,
-				  bcm43xx_phy_read(bcm, 0x04C3) &amp; 0x7FFF);
-	}
-}
-
-static u16 bcm43xx_phy_lo_b_r15_loop(struct bcm43xx_private *bcm)
-{
-	int i;
-	u16 ret = 0;
-	unsigned long flags;
-
-	local_irq_save(flags);
-	for (i = 0; i &lt; 10; i++){
-		bcm43xx_phy_write(bcm, 0x0015, 0xAFA0);
-		udelay(1);
-		bcm43xx_phy_write(bcm, 0x0015, 0xEFA0);
-		udelay(10);
-		bcm43xx_phy_write(bcm, 0x0015, 0xFFA0);
-		udelay(40);
-		ret += bcm43xx_phy_read(bcm, 0x002C);
-	}
-	local_irq_restore(flags);
-	bcm43xx_voluntary_preempt();
-
-	return ret;
-}
-
-void bcm43xx_phy_lo_b_measure(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 regstack[12] = { 0 };
-	u16 mls;
-	u16 fval;
-	int i, j;
-
-	regstack[0] = bcm43xx_phy_read(bcm, 0x0015);
-	regstack[1] = bcm43xx_radio_read16(bcm, 0x0052) &amp; 0xFFF0;
-
-	if (radio-&gt;version == 0x2053) {
-		regstack[2] = bcm43xx_phy_read(bcm, 0x000A);
-		regstack[3] = bcm43xx_phy_read(bcm, 0x002A);
-		regstack[4] = bcm43xx_phy_read(bcm, 0x0035);
-		regstack[5] = bcm43xx_phy_read(bcm, 0x0003);
-		regstack[6] = bcm43xx_phy_read(bcm, 0x0001);
-		regstack[7] = bcm43xx_phy_read(bcm, 0x0030);
-
-		regstack[8] = bcm43xx_radio_read16(bcm, 0x0043);
-		regstack[9] = bcm43xx_radio_read16(bcm, 0x007A);
-		regstack[10] = bcm43xx_read16(bcm, 0x03EC);
-		regstack[11] = bcm43xx_radio_read16(bcm, 0x0052) &amp; 0x00F0;
-
-		bcm43xx_phy_write(bcm, 0x0030, 0x00FF);
-		bcm43xx_write16(bcm, 0x03EC, 0x3F3F);
-		bcm43xx_phy_write(bcm, 0x0035, regstack[4] &amp; 0xFF7F);
-		bcm43xx_radio_write16(bcm, 0x007A, regstack[9] &amp; 0xFFF0);
-	}
-	bcm43xx_phy_write(bcm, 0x0015, 0xB000);
-	bcm43xx_phy_write(bcm, 0x002B, 0x0004);
-
-	if (radio-&gt;version == 0x2053) {
-		bcm43xx_phy_write(bcm, 0x002B, 0x0203);
-		bcm43xx_phy_write(bcm, 0x002A, 0x08A3);
-	}
-
-	phy-&gt;minlowsig[0] = 0xFFFF;
-
-	for (i = 0; i &lt; 4; i++) {
-		bcm43xx_radio_write16(bcm, 0x0052, regstack[1] | i);
-		bcm43xx_phy_lo_b_r15_loop(bcm);
-	}
-	for (i = 0; i &lt; 10; i++) {
-		bcm43xx_radio_write16(bcm, 0x0052, regstack[1] | i);
-		mls = bcm43xx_phy_lo_b_r15_loop(bcm) / 10;
-		if (mls &lt; phy-&gt;minlowsig[0]) {
-			phy-&gt;minlowsig[0] = mls;
-			phy-&gt;minlowsigpos[0] = i;
-		}
-	}
-	bcm43xx_radio_write16(bcm, 0x0052, regstack[1] | phy-&gt;minlowsigpos[0]);
-
-	phy-&gt;minlowsig[1] = 0xFFFF;
-
-	for (i = -4; i &lt; 5; i += 2) {
-		for (j = -4; j &lt; 5; j += 2) {
-			if (j &lt; 0)
-				fval = (0x0100 * i) + j + 0x0100;
-			else
-				fval = (0x0100 * i) + j;
-			bcm43xx_phy_write(bcm, 0x002F, fval);
-			mls = bcm43xx_phy_lo_b_r15_loop(bcm) / 10;
-			if (mls &lt; phy-&gt;minlowsig[1]) {
-				phy-&gt;minlowsig[1] = mls;
-				phy-&gt;minlowsigpos[1] = fval;
-			}
-		}
-	}
-	phy-&gt;minlowsigpos[1] += 0x0101;
-
-	bcm43xx_phy_write(bcm, 0x002F, phy-&gt;minlowsigpos[1]);
-	if (radio-&gt;version == 0x2053) {
-		bcm43xx_phy_write(bcm, 0x000A, regstack[2]);
-		bcm43xx_phy_write(bcm, 0x002A, regstack[3]);
-		bcm43xx_phy_write(bcm, 0x0035, regstack[4]);
-		bcm43xx_phy_write(bcm, 0x0003, regstack[5]);
-		bcm43xx_phy_write(bcm, 0x0001, regstack[6]);
-		bcm43xx_phy_write(bcm, 0x0030, regstack[7]);
-
-		bcm43xx_radio_write16(bcm, 0x0043, regstack[8]);
-		bcm43xx_radio_write16(bcm, 0x007A, regstack[9]);
-
-		bcm43xx_radio_write16(bcm, 0x0052,
-		                      (bcm43xx_radio_read16(bcm, 0x0052) &amp; 0x000F)
-				      | regstack[11]);
-
-		bcm43xx_write16(bcm, 0x03EC, regstack[10]);
-	}
-	bcm43xx_phy_write(bcm, 0x0015, regstack[0]);
-}
-
-static inline
-u16 bcm43xx_phy_lo_g_deviation_subval(struct bcm43xx_private *bcm, u16 control)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 ret;
-	unsigned long flags;
-
-	local_irq_save(flags);
-	if (phy-&gt;connected) {
-		bcm43xx_phy_write(bcm, 0x15, 0xE300);
-		control &lt;&lt;= 8;
-		bcm43xx_phy_write(bcm, 0x0812, control | 0x00B0);
-		udelay(5);
-		bcm43xx_phy_write(bcm, 0x0812, control | 0x00B2);
-		udelay(2);
-		bcm43xx_phy_write(bcm, 0x0812, control | 0x00B3);
-		udelay(4);
-		bcm43xx_phy_write(bcm, 0x0015, 0xF300);
-		udelay(8);
-	} else {
-		bcm43xx_phy_write(bcm, 0x0015, control | 0xEFA0);
-		udelay(2);
-		bcm43xx_phy_write(bcm, 0x0015, control | 0xEFE0);
-		udelay(4);
-		bcm43xx_phy_write(bcm, 0x0015, control | 0xFFE0);
-		udelay(8);
-	}
-	ret = bcm43xx_phy_read(bcm, 0x002D);
-	local_irq_restore(flags);
-	bcm43xx_voluntary_preempt();
-
-	return ret;
-}
-
-static u32 bcm43xx_phy_lo_g_singledeviation(struct bcm43xx_private *bcm, u16 control)
-{
-	int i;
-	u32 ret = 0;
-
-	for (i = 0; i &lt; 8; i++)
-		ret += bcm43xx_phy_lo_g_deviation_subval(bcm, control);
-
-	return ret;
-}
-
-/* Write the LocalOscillator CONTROL */
-static inline
-void bcm43xx_lo_write(struct bcm43xx_private *bcm,
-		      struct bcm43xx_lopair *pair)
-{
-	u16 value;
-
-	value = (u8)(pair-&gt;low);
-	value |= ((u8)(pair-&gt;high)) &lt;&lt; 8;
-
-#ifdef CONFIG_BCM43XX_DEBUG
-	/* Sanity check. */
-	if (pair-&gt;low &lt; -8 || pair-&gt;low &gt; 8 ||
-	    pair-&gt;high &lt; -8 || pair-&gt;high &gt; 8) {
-		printk(KERN_WARNING PFX
-		       &quot;WARNING: Writing invalid LOpair &quot;
-		       &quot;(low: %d, high: %d, index: %lu)\n&quot;,
-		       pair-&gt;low, pair-&gt;high,
-		       (unsigned long)(pair - bcm43xx_current_phy(bcm)-&gt;_lo_pairs));
-		dump_stack();
-	}
-#endif
-
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_G_LO_CONTROL, value);
-}
-
-static inline
-struct bcm43xx_lopair * bcm43xx_find_lopair(struct bcm43xx_private *bcm,
-					    u16 baseband_attenuation,
-					    u16 radio_attenuation,
-					    u16 tx)
-{
-	static const u8 dict[10] = { 11, 10, 11, 12, 13, 12, 13, 12, 13, 12 };
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	if (baseband_attenuation &gt; 6)
-		baseband_attenuation = 6;
-	assert(radio_attenuation &lt; 10);
-
-	if (tx == 3) {
-		return bcm43xx_get_lopair(phy,
-					  radio_attenuation,
-					  baseband_attenuation);
-	}
-	return bcm43xx_get_lopair(phy, dict[radio_attenuation], baseband_attenuation);
-}
-
-static inline
-struct bcm43xx_lopair * bcm43xx_current_lopair(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-
-	return bcm43xx_find_lopair(bcm,
-				   radio-&gt;baseband_atten,
-				   radio-&gt;radio_atten,
-				   radio-&gt;txctl1);
-}
-
-/* Adjust B/G LO */
-void bcm43xx_phy_lo_adjust(struct bcm43xx_private *bcm, int fixed)
-{
-	struct bcm43xx_lopair *pair;
-
-	if (fixed) {
-		/* Use fixed values. Only for initialization. */
-		pair = bcm43xx_find_lopair(bcm, 2, 3, 0);
-	} else
-		pair = bcm43xx_current_lopair(bcm);
-	bcm43xx_lo_write(bcm, pair);
-}
-
-static void bcm43xx_phy_lo_g_measure_txctl2(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 txctl2 = 0, i;
-	u32 smallest, tmp;
-
-	bcm43xx_radio_write16(bcm, 0x0052, 0x0000);
-	udelay(10);
-	smallest = bcm43xx_phy_lo_g_singledeviation(bcm, 0);
-	for (i = 0; i &lt; 16; i++) {
-		bcm43xx_radio_write16(bcm, 0x0052, i);
-		udelay(10);
-		tmp = bcm43xx_phy_lo_g_singledeviation(bcm, 0);
-		if (tmp &lt; smallest) {
-			smallest = tmp;
-			txctl2 = i;
-		}
-	}
-	radio-&gt;txctl2 = txctl2;
-}
-
-static
-void bcm43xx_phy_lo_g_state(struct bcm43xx_private *bcm,
-			    const struct bcm43xx_lopair *in_pair,
-			    struct bcm43xx_lopair *out_pair,
-			    u16 r27)
-{
-	static const struct bcm43xx_lopair transitions[8] = {
-		{ .high =  1,  .low =  1, },
-		{ .high =  1,  .low =  0, },
-		{ .high =  1,  .low = -1, },
-		{ .high =  0,  .low = -1, },
-		{ .high = -1,  .low = -1, },
-		{ .high = -1,  .low =  0, },
-		{ .high = -1,  .low =  1, },
-		{ .high =  0,  .low =  1, },
-	};
-	struct bcm43xx_lopair lowest_transition = {
-		.high = in_pair-&gt;high,
-		.low = in_pair-&gt;low,
-	};
-	struct bcm43xx_lopair tmp_pair;
-	struct bcm43xx_lopair transition;
-	int i = 12;
-	int state = 0;
-	int found_lower;
-	int j, begin, end;
-	u32 lowest_deviation;
-	u32 tmp;
-
-	/* Note that in_pair and out_pair can point to the same pair. Be careful. */
-
-	bcm43xx_lo_write(bcm, &amp;lowest_transition);
-	lowest_deviation = bcm43xx_phy_lo_g_singledeviation(bcm, r27);
-	do {
-		found_lower = 0;
-		assert(state &gt;= 0 &amp;&amp; state &lt;= 8);
-		if (state == 0) {
-			begin = 1;
-			end = 8;
-		} else if (state % 2 == 0) {
-			begin = state - 1;
-			end = state + 1;
-		} else {
-			begin = state - 2;
-			end = state + 2;
-		}
-		if (begin &lt; 1)
-			begin += 8;
-		if (end &gt; 8)
-			end -= 8;
-
-		j = begin;
-		tmp_pair.high = lowest_transition.high;
-		tmp_pair.low = lowest_transition.low;
-		while (1) {
-			assert(j &gt;= 1 &amp;&amp; j &lt;= 8);
-			transition.high = tmp_pair.high + transitions[j - 1].high;
-			transition.low = tmp_pair.low + transitions[j - 1].low;
-			if ((abs(transition.low) &lt; 9) &amp;&amp; (abs(transition.high) &lt; 9)) {
-				bcm43xx_lo_write(bcm, &amp;transition);
-				tmp = bcm43xx_phy_lo_g_singledeviation(bcm, r27);
-				if (tmp &lt; lowest_deviation) {
-					lowest_deviation = tmp;
-					state = j;
-					found_lower = 1;
-
-					lowest_transition.high = transition.high;
-					lowest_transition.low = transition.low;
-				}
-			}
-			if (j == end)
-				break;
-			if (j == 8)
-				j = 1;
-			else
-				j++;
-		}
-	} while (i-- &amp;&amp; found_lower);
-
-	out_pair-&gt;high = lowest_transition.high;
-	out_pair-&gt;low = lowest_transition.low;
-}
-
-/* Set the baseband attenuation value on chip. */
-void bcm43xx_phy_set_baseband_attenuation(struct bcm43xx_private *bcm,
-					  u16 baseband_attenuation)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 value;
-
-	if (phy-&gt;analog == 0) {
-		value = (bcm43xx_read16(bcm, 0x03E6) &amp; 0xFFF0);
-		value |= (baseband_attenuation &amp; 0x000F);
-		bcm43xx_write16(bcm, 0x03E6, value);
-		return;
-	}
-
-	if (phy-&gt;analog &gt; 1) {
-		value = bcm43xx_phy_read(bcm, 0x0060) &amp; ~0x003C;
-		value |= (baseband_attenuation &lt;&lt; 2) &amp; 0x003C;
-	} else {
-		value = bcm43xx_phy_read(bcm, 0x0060) &amp; ~0x0078;
-		value |= (baseband_attenuation &lt;&lt; 3) &amp; 0x0078;
-	}
-	bcm43xx_phy_write(bcm, 0x0060, value);
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/LocalOscillator/Measure">http://bcm-specs.sipsolutions.net/LocalOscillator/Measure</A> */
-void bcm43xx_phy_lo_g_measure(struct bcm43xx_private *bcm)
-{
-	static const u8 pairorder[10] = { 3, 1, 5, 7, 9, 2, 0, 4, 6, 8 };
-	const int is_initializing = (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZING);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 h, i, oldi = 0, j;
-	struct bcm43xx_lopair control;
-	struct bcm43xx_lopair *tmp_control;
-	u16 tmp;
-	u16 regstack[16] = { 0 };
-	u8 oldchannel;
-
-	//XXX: What are these?
-	u8 r27 = 0, r31;
-
-	oldchannel = radio-&gt;channel;
-	/* Setup */
-	if (phy-&gt;connected) {
-		regstack[0] = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS);
-		regstack[1] = bcm43xx_phy_read(bcm, 0x0802);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, regstack[0] &amp; 0x7FFF);
-		bcm43xx_phy_write(bcm, 0x0802, regstack[1] &amp; 0xFFFC);
-	}
-	regstack[3] = bcm43xx_read16(bcm, 0x03E2);
-	bcm43xx_write16(bcm, 0x03E2, regstack[3] | 0x8000);
-	regstack[4] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
-	regstack[5] = bcm43xx_phy_read(bcm, 0x15);
-	regstack[6] = bcm43xx_phy_read(bcm, 0x2A);
-	regstack[7] = bcm43xx_phy_read(bcm, 0x35);
-	regstack[8] = bcm43xx_phy_read(bcm, 0x60);
-	regstack[9] = bcm43xx_radio_read16(bcm, 0x43);
-	regstack[10] = bcm43xx_radio_read16(bcm, 0x7A);
-	regstack[11] = bcm43xx_radio_read16(bcm, 0x52);
-	if (phy-&gt;connected) {
-		regstack[12] = bcm43xx_phy_read(bcm, 0x0811);
-		regstack[13] = bcm43xx_phy_read(bcm, 0x0812);
-		regstack[14] = bcm43xx_phy_read(bcm, 0x0814);
-		regstack[15] = bcm43xx_phy_read(bcm, 0x0815);
-	}
-	bcm43xx_radio_selectchannel(bcm, 6, 0);
-	if (phy-&gt;connected) {
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, regstack[0] &amp; 0x7FFF);
-		bcm43xx_phy_write(bcm, 0x0802, regstack[1] &amp; 0xFFFC);
-		bcm43xx_dummy_transmission(bcm);
-	}
-	bcm43xx_radio_write16(bcm, 0x0043, 0x0006);
-
-	bcm43xx_phy_set_baseband_attenuation(bcm, 2);
-
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, 0x0000);
-	bcm43xx_phy_write(bcm, 0x002E, 0x007F);
-	bcm43xx_phy_write(bcm, 0x080F, 0x0078);
-	bcm43xx_phy_write(bcm, 0x0035, regstack[7] &amp; ~(1 &lt;&lt; 7));
-	bcm43xx_radio_write16(bcm, 0x007A, regstack[10] &amp; 0xFFF0);
-	bcm43xx_phy_write(bcm, 0x002B, 0x0203);
-	bcm43xx_phy_write(bcm, 0x002A, 0x08A3);
-	if (phy-&gt;connected) {
-		bcm43xx_phy_write(bcm, 0x0814, regstack[14] | 0x0003);
-		bcm43xx_phy_write(bcm, 0x0815, regstack[15] &amp; 0xFFFC);
-		bcm43xx_phy_write(bcm, 0x0811, 0x01B3);
-		bcm43xx_phy_write(bcm, 0x0812, 0x00B2);
-	}
-	if (is_initializing)
-		bcm43xx_phy_lo_g_measure_txctl2(bcm);
-	bcm43xx_phy_write(bcm, 0x080F, 0x8078);
-
-	/* Measure */
-	control.low = 0;
-	control.high = 0;
-	for (h = 0; h &lt; 10; h++) {
-		/* Loop over each possible RadioAttenuation (0-9) */
-		i = pairorder[h];
-		if (is_initializing) {
-			if (i == 3) {
-				control.low = 0;
-				control.high = 0;
-			} else if (((i % 2 == 1) &amp;&amp; (oldi % 2 == 1)) ||
-				  ((i % 2 == 0) &amp;&amp; (oldi % 2 == 0))) {
-				tmp_control = bcm43xx_get_lopair(phy, oldi, 0);
-				memcpy(&amp;control, tmp_control, sizeof(control));
-			} else {
-				tmp_control = bcm43xx_get_lopair(phy, 3, 0);
-				memcpy(&amp;control, tmp_control, sizeof(control));
-			}
-		}
-		/* Loop over each possible BasebandAttenuation/2 */
-		for (j = 0; j &lt; 4; j++) {
-			if (is_initializing) {
-				tmp = i * 2 + j;
-				r27 = 0;
-				r31 = 0;
-				if (tmp &gt; 14) {
-					r31 = 1;
-					if (tmp &gt; 17)
-						r27 = 1;
-					if (tmp &gt; 19)
-						r27 = 2;
-				}
-			} else {
-				tmp_control = bcm43xx_get_lopair(phy, i, j * 2);
-				if (!tmp_control-&gt;used)
-					continue;
-				memcpy(&amp;control, tmp_control, sizeof(control));
-				r27 = 3;
-				r31 = 0;
-			}
-			bcm43xx_radio_write16(bcm, 0x43, i);
-			bcm43xx_radio_write16(bcm, 0x52, radio-&gt;txctl2);
-			udelay(10);
-			bcm43xx_voluntary_preempt();
-
-			bcm43xx_phy_set_baseband_attenuation(bcm, j * 2);
-
-			tmp = (regstack[10] &amp; 0xFFF0);
-			if (r31)
-				tmp |= 0x0008;
-			bcm43xx_radio_write16(bcm, 0x007A, tmp);
-
-			tmp_control = bcm43xx_get_lopair(phy, i, j * 2);
-			bcm43xx_phy_lo_g_state(bcm, &amp;control, tmp_control, r27);
-		}
-		oldi = i;
-	}
-	/* Loop over each possible RadioAttenuation (10-13) */
-	for (i = 10; i &lt; 14; i++) {
-		/* Loop over each possible BasebandAttenuation/2 */
-		for (j = 0; j &lt; 4; j++) {
-			if (is_initializing) {
-				tmp_control = bcm43xx_get_lopair(phy, i - 9, j * 2);
-				memcpy(&amp;control, tmp_control, sizeof(control));
-				tmp = (i - 9) * 2 + j - 5;//FIXME: This is wrong, as the following if statement can never trigger.
-				r27 = 0;
-				r31 = 0;
-				if (tmp &gt; 14) {
-					r31 = 1;
-					if (tmp &gt; 17)
-						r27 = 1;
-					if (tmp &gt; 19)
-						r27 = 2;
-				}
-			} else {
-				tmp_control = bcm43xx_get_lopair(phy, i - 9, j * 2);
-				if (!tmp_control-&gt;used)
-					continue;
-				memcpy(&amp;control, tmp_control, sizeof(control));
-				r27 = 3;
-				r31 = 0;
-			}
-			bcm43xx_radio_write16(bcm, 0x43, i - 9);
-			bcm43xx_radio_write16(bcm, 0x52,
-					      radio-&gt;txctl2
-					      | (3/*txctl1*/ &lt;&lt; 4));//FIXME: shouldn't txctl1 be zero here and 3 in the loop above?
-			udelay(10);
-			bcm43xx_voluntary_preempt();
-
-			bcm43xx_phy_set_baseband_attenuation(bcm, j * 2);
-
-			tmp = (regstack[10] &amp; 0xFFF0);
-			if (r31)
-				tmp |= 0x0008;
-			bcm43xx_radio_write16(bcm, 0x7A, tmp);
-
-			tmp_control = bcm43xx_get_lopair(phy, i, j * 2);
-			bcm43xx_phy_lo_g_state(bcm, &amp;control, tmp_control, r27);
-		}
-	}
-
-	/* Restoration */
-	if (phy-&gt;connected) {
-		bcm43xx_phy_write(bcm, 0x0015, 0xE300);
-		bcm43xx_phy_write(bcm, 0x0812, (r27 &lt;&lt; 8) | 0xA0);
-		udelay(5);
-		bcm43xx_phy_write(bcm, 0x0812, (r27 &lt;&lt; 8) | 0xA2);
-		udelay(2);
-		bcm43xx_phy_write(bcm, 0x0812, (r27 &lt;&lt; 8) | 0xA3);
-		bcm43xx_voluntary_preempt();
-	} else
-		bcm43xx_phy_write(bcm, 0x0015, r27 | 0xEFA0);
-	bcm43xx_phy_lo_adjust(bcm, is_initializing);
-	bcm43xx_phy_write(bcm, 0x002E, 0x807F);
-	if (phy-&gt;connected)
-		bcm43xx_phy_write(bcm, 0x002F, 0x0202);
-	else
-		bcm43xx_phy_write(bcm, 0x002F, 0x0101);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, regstack[4]);
-	bcm43xx_phy_write(bcm, 0x0015, regstack[5]);
-	bcm43xx_phy_write(bcm, 0x002A, regstack[6]);
-	bcm43xx_phy_write(bcm, 0x0035, regstack[7]);
-	bcm43xx_phy_write(bcm, 0x0060, regstack[8]);
-	bcm43xx_radio_write16(bcm, 0x0043, regstack[9]);
-	bcm43xx_radio_write16(bcm, 0x007A, regstack[10]);
-	regstack[11] &amp;= 0x00F0;
-	regstack[11] |= (bcm43xx_radio_read16(bcm, 0x52) &amp; 0x000F);
-	bcm43xx_radio_write16(bcm, 0x52, regstack[11]);
-	bcm43xx_write16(bcm, 0x03E2, regstack[3]);
-	if (phy-&gt;connected) {
-		bcm43xx_phy_write(bcm, 0x0811, regstack[12]);
-		bcm43xx_phy_write(bcm, 0x0812, regstack[13]);
-		bcm43xx_phy_write(bcm, 0x0814, regstack[14]);
-		bcm43xx_phy_write(bcm, 0x0815, regstack[15]);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, regstack[0]);
-		bcm43xx_phy_write(bcm, 0x0802, regstack[1]);
-	}
-	bcm43xx_radio_selectchannel(bcm, oldchannel, 1);
-
-#ifdef CONFIG_BCM43XX_DEBUG
-	{
-		/* Sanity check for all lopairs. */
-		for (i = 0; i &lt; BCM43xx_LO_COUNT; i++) {
-			tmp_control = phy-&gt;_lo_pairs + i;
-			if (tmp_control-&gt;low &lt; -8 || tmp_control-&gt;low &gt; 8 ||
-			    tmp_control-&gt;high &lt; -8 || tmp_control-&gt;high &gt; 8) {
-				printk(KERN_WARNING PFX
-				       &quot;WARNING: Invalid LOpair (low: %d, high: %d, index: %d)\n&quot;,
-				       tmp_control-&gt;low, tmp_control-&gt;high, i);
-			}
-		}
-	}
-#endif /* CONFIG_BCM43XX_DEBUG */
-}
-
-static
-void bcm43xx_phy_lo_mark_current_used(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_lopair *pair;
-
-	pair = bcm43xx_current_lopair(bcm);
-	pair-&gt;used = 1;
-}
-
-void bcm43xx_phy_lo_mark_all_unused(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_lopair *pair;
-	int i;
-
-	for (i = 0; i &lt; BCM43xx_LO_COUNT; i++) {
-		pair = phy-&gt;_lo_pairs + i;
-		pair-&gt;used = 0;
-	}
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/EstimatePowerOut">http://bcm-specs.sipsolutions.net/EstimatePowerOut</A>
- * This function converts a TSSI value to dBm in Q5.2
- */
-static s8 bcm43xx_phy_estimate_power_out(struct bcm43xx_private *bcm, s8 tssi)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	s8 dbm = 0;
-	s32 tmp;
-
-	tmp = phy-&gt;idle_tssi;
-	tmp += tssi;
-	tmp -= phy-&gt;savedpctlreg;
-
-	switch (phy-&gt;type) {
-		case BCM43xx_PHYTYPE_A:
-			tmp += 0x80;
-			tmp = limit_value(tmp, 0x00, 0xFF);
-			dbm = phy-&gt;tssi2dbm[tmp];
-			TODO(); //TODO: There's a FIXME on the specs
-			break;
-		case BCM43xx_PHYTYPE_B:
-		case BCM43xx_PHYTYPE_G:
-			tmp = limit_value(tmp, 0x00, 0x3F);
-			dbm = phy-&gt;tssi2dbm[tmp];
-			break;
-		default:
-			assert(0);
-	}
-
-	return dbm;
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/RecalculateTransmissionPower">http://bcm-specs.sipsolutions.net/RecalculateTransmissionPower</A> */
-void bcm43xx_phy_xmitpower(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	
-	if (phy-&gt;savedpctlreg == 0xFFFF)
-		return;
-	if ((bcm-&gt;board_type == 0x0416) &amp;&amp;
-	    (bcm-&gt;board_vendor == PCI_VENDOR_ID_BROADCOM))
-		return;
-	
-	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_A: {
-
-		TODO(); //TODO: Nothing for A PHYs yet :-/
-
-		break;
-	}
-	case BCM43xx_PHYTYPE_B:
-	case BCM43xx_PHYTYPE_G: {
-		u16 tmp;
-		u16 txpower;
-		s8 v0, v1, v2, v3;
-		s8 average;
-		u8 max_pwr;
-		s16 desired_pwr, estimated_pwr, pwr_adjust;
-		s16 radio_att_delta, baseband_att_delta;
-		s16 radio_attenuation, baseband_attenuation;
-		unsigned long phylock_flags;
-
-		tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0058);
-		v0 = (s8)(tmp &amp; 0x00FF);
-		v1 = (s8)((tmp &amp; 0xFF00) &gt;&gt; 8);
-		tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x005A);
-		v2 = (s8)(tmp &amp; 0x00FF);
-		v3 = (s8)((tmp &amp; 0xFF00) &gt;&gt; 8);
-		tmp = 0;
-
-		if (v0 == 0x7F || v1 == 0x7F || v2 == 0x7F || v3 == 0x7F) {
-			tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0070);
-			v0 = (s8)(tmp &amp; 0x00FF);
-			v1 = (s8)((tmp &amp; 0xFF00) &gt;&gt; 8);
-			tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0072);
-			v2 = (s8)(tmp &amp; 0x00FF);
-			v3 = (s8)((tmp &amp; 0xFF00) &gt;&gt; 8);
-			if (v0 == 0x7F || v1 == 0x7F || v2 == 0x7F || v3 == 0x7F)
-				return;
-			v0 = (v0 + 0x20) &amp; 0x3F;
-			v1 = (v1 + 0x20) &amp; 0x3F;
-			v2 = (v2 + 0x20) &amp; 0x3F;
-			v3 = (v3 + 0x20) &amp; 0x3F;
-			tmp = 1;
-		}
-		bcm43xx_radio_clear_tssi(bcm);
-
-		average = (v0 + v1 + v2 + v3 + 2) / 4;
-
-		if (tmp &amp;&amp; (bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x005E) &amp; 0x8))
-			average -= 13;
-
-		estimated_pwr = bcm43xx_phy_estimate_power_out(bcm, average);
-
-		max_pwr = bcm-&gt;sprom.maxpower_bgphy;
-
-		if ((bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_PACTRL) &amp;&amp;
-		    (phy-&gt;type == BCM43xx_PHYTYPE_G))
-			max_pwr -= 0x3;
-
-		/*TODO:
-		max_pwr = min(REG - bcm-&gt;sprom.antennagain_bgphy - 0x6, max_pwr)
-			where REG is the max power as per the regulatory domain
-		*/
-
-		desired_pwr = limit_value(radio-&gt;txpower_desired, 0, max_pwr);
-		/* Check if we need to adjust the current power. */
-		pwr_adjust = desired_pwr - estimated_pwr;
-		radio_att_delta = -(pwr_adjust + 7) &gt;&gt; 3;
-		baseband_att_delta = -(pwr_adjust &gt;&gt; 1) - (4 * radio_att_delta);
-		if ((radio_att_delta == 0) &amp;&amp; (baseband_att_delta == 0)) {
-			bcm43xx_phy_lo_mark_current_used(bcm);
-			return;
-		}
-
-		/* Calculate the new attenuation values. */
-		baseband_attenuation = radio-&gt;baseband_atten;
-		baseband_attenuation += baseband_att_delta;
-		radio_attenuation = radio-&gt;radio_atten;
-		radio_attenuation += radio_att_delta;
-
-		/* Get baseband and radio attenuation values into their permitted ranges.
-		 * baseband 0-11, radio 0-9.
-		 * Radio attenuation affects power level 4 times as much as baseband.
-		 */
-		if (radio_attenuation &lt; 0) {
-			baseband_attenuation -= (4 * -radio_attenuation);
-			radio_attenuation = 0;
-		} else if (radio_attenuation &gt; 9) {
-			baseband_attenuation += (4 * (radio_attenuation - 9));
-			radio_attenuation = 9;
-		} else {
-			while (baseband_attenuation &lt; 0 &amp;&amp; radio_attenuation &gt; 0) {
-				baseband_attenuation += 4;
-				radio_attenuation--;
-			}
-			while (baseband_attenuation &gt; 11 &amp;&amp; radio_attenuation &lt; 9) {
-				baseband_attenuation -= 4;
-				radio_attenuation++;
-			}
-		}
-		baseband_attenuation = limit_value(baseband_attenuation, 0, 11);
-
-		txpower = radio-&gt;txctl1;
-		if ((radio-&gt;version == 0x2050) &amp;&amp; (radio-&gt;revision == 2)) {
-			if (radio_attenuation &lt;= 1) {
-				if (txpower == 0) {
-					txpower = 3;
-					radio_attenuation += 2;
-					baseband_attenuation += 2;
-				} else if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_PACTRL) {
-					baseband_attenuation += 4 * (radio_attenuation - 2);
-					radio_attenuation = 2;
-				}
-			} else if (radio_attenuation &gt; 4 &amp;&amp; txpower != 0) {
-				txpower = 0;
-				if (baseband_attenuation &lt; 3) {
-					radio_attenuation -= 3;
-					baseband_attenuation += 2;
-				} else {
-					radio_attenuation -= 2;
-					baseband_attenuation -= 2;
-				}
-			}
-		}
-		radio-&gt;txctl1 = txpower;
-		baseband_attenuation = limit_value(baseband_attenuation, 0, 11);
-		radio_attenuation = limit_value(radio_attenuation, 0, 9);
-
-		bcm43xx_phy_lock(bcm, phylock_flags);
-		bcm43xx_radio_lock(bcm);
-		bcm43xx_radio_set_txpower_bg(bcm, baseband_attenuation,
-					     radio_attenuation, txpower);
-		bcm43xx_phy_lo_mark_current_used(bcm);
-		bcm43xx_radio_unlock(bcm);
-		bcm43xx_phy_unlock(bcm, phylock_flags);
-		break;
-	}
-	default:
-		assert(0);
-	}
-}
-
-static inline
-s32 bcm43xx_tssi2dbm_ad(s32 num, s32 den)
-{
-	if (num &lt; 0)
-		return num/den;
-	else
-		return (num+den/2)/den;
-}
-
-static inline
-s8 bcm43xx_tssi2dbm_entry(s8 entry [], u8 index, s16 pab0, s16 pab1, s16 pab2)
-{
-	s32 m1, m2, f = 256, q, delta;
-	s8 i = 0;
-	
-	m1 = bcm43xx_tssi2dbm_ad(16 * pab0 + index * pab1, 32);
-	m2 = max(bcm43xx_tssi2dbm_ad(32768 + index * pab2, 256), 1);
-	do {
-		if (i &gt; 15)
-			return -EINVAL;
-		q = bcm43xx_tssi2dbm_ad(f * 4096 -
-					bcm43xx_tssi2dbm_ad(m2 * f, 16) * f, 2048);
-		delta = abs(q - f);
-		f = q;
-		i++;
-	} while (delta &gt;= 2);
-	entry[index] = limit_value(bcm43xx_tssi2dbm_ad(m1 * f, 8192), -127, 128);
-	return 0;
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/TSSI_to_DBM_Table">http://bcm-specs.sipsolutions.net/TSSI_to_DBM_Table</A> */
-int bcm43xx_phy_init_tssi2dbm_table(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	s16 pab0, pab1, pab2;
-	u8 idx;
-	s8 *dyn_tssi2dbm;
-	
-	if (phy-&gt;type == BCM43xx_PHYTYPE_A) {
-		pab0 = (s16)(bcm-&gt;sprom.pa1b0);
-		pab1 = (s16)(bcm-&gt;sprom.pa1b1);
-		pab2 = (s16)(bcm-&gt;sprom.pa1b2);
-	} else {
-		pab0 = (s16)(bcm-&gt;sprom.pa0b0);
-		pab1 = (s16)(bcm-&gt;sprom.pa0b1);
-		pab2 = (s16)(bcm-&gt;sprom.pa0b2);
-	}
-
-	if ((bcm-&gt;chip_id == 0x4301) &amp;&amp; (radio-&gt;version != 0x2050)) {
-		phy-&gt;idle_tssi = 0x34;
-		phy-&gt;tssi2dbm = bcm43xx_tssi2dbm_b_table;
-		return 0;
-	}
-
-	if (pab0 != 0 &amp;&amp; pab1 != 0 &amp;&amp; pab2 != 0 &amp;&amp;
-	    pab0 != -1 &amp;&amp; pab1 != -1 &amp;&amp; pab2 != -1) {
-		/* The pabX values are set in SPROM. Use them. */
-		if (phy-&gt;type == BCM43xx_PHYTYPE_A) {
-			if ((s8)bcm-&gt;sprom.idle_tssi_tgt_aphy != 0 &amp;&amp;
-			    (s8)bcm-&gt;sprom.idle_tssi_tgt_aphy != -1)
-				phy-&gt;idle_tssi = (s8)(bcm-&gt;sprom.idle_tssi_tgt_aphy);
-			else
-				phy-&gt;idle_tssi = 62;
-		} else {
-			if ((s8)bcm-&gt;sprom.idle_tssi_tgt_bgphy != 0 &amp;&amp;
-			    (s8)bcm-&gt;sprom.idle_tssi_tgt_bgphy != -1)
-				phy-&gt;idle_tssi = (s8)(bcm-&gt;sprom.idle_tssi_tgt_bgphy);
-			else
-				phy-&gt;idle_tssi = 62;
-		}
-		dyn_tssi2dbm = kmalloc(64, GFP_KERNEL);
-		if (dyn_tssi2dbm == NULL) {
-			printk(KERN_ERR PFX &quot;Could not allocate memory&quot;
-					    &quot;for tssi2dbm table\n&quot;);
-			return -ENOMEM;
-		}
-		for (idx = 0; idx &lt; 64; idx++)
-			if (bcm43xx_tssi2dbm_entry(dyn_tssi2dbm, idx, pab0, pab1, pab2)) {
-				phy-&gt;tssi2dbm = NULL;
-				printk(KERN_ERR PFX &quot;Could not generate &quot;
-						    &quot;tssi2dBm table\n&quot;);
-				kfree(dyn_tssi2dbm);
-				return -ENODEV;
-			}
-		phy-&gt;tssi2dbm = dyn_tssi2dbm;
-		phy-&gt;dyn_tssi_tbl = 1;
-	} else {
-		/* pabX values not set in SPROM. */
-		switch (phy-&gt;type) {
-		case BCM43xx_PHYTYPE_A:
-			/* APHY needs a generated table. */
-			phy-&gt;tssi2dbm = NULL;
-			printk(KERN_ERR PFX &quot;Could not generate tssi2dBm &quot;
-					    &quot;table (wrong SPROM info)!\n&quot;);
-			return -ENODEV;
-		case BCM43xx_PHYTYPE_B:
-			phy-&gt;idle_tssi = 0x34;
-			phy-&gt;tssi2dbm = bcm43xx_tssi2dbm_b_table;
-			break;
-		case BCM43xx_PHYTYPE_G:
-			phy-&gt;idle_tssi = 0x34;
-			phy-&gt;tssi2dbm = bcm43xx_tssi2dbm_g_table;
-			break;
-		}
-	}
-
-	return 0;
-}
-
-int bcm43xx_phy_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	int err = -ENODEV;
-
-	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-		if (phy-&gt;rev == 2 || phy-&gt;rev == 3) {
-			bcm43xx_phy_inita(bcm);
-			err = 0;
-		}
-		break;
-	case BCM43xx_PHYTYPE_B:
-		switch (phy-&gt;rev) {
-		case 2:
-			bcm43xx_phy_initb2(bcm);
-			err = 0;
-			break;
-		case 4:
-			bcm43xx_phy_initb4(bcm);
-			err = 0;
-			break;
-		case 5:
-			bcm43xx_phy_initb5(bcm);
-			err = 0;
-			break;
-		case 6:
-			bcm43xx_phy_initb6(bcm);
-			err = 0;
-			break;
-		}
-		break;
-	case BCM43xx_PHYTYPE_G:
-		bcm43xx_phy_initg(bcm);
-		err = 0;
-		break;
-	}
-	if (err)
-		printk(KERN_WARNING PFX &quot;Unknown PHYTYPE found!\n&quot;);
-
-	return err;
-}
-
-void bcm43xx_phy_set_antenna_diversity(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 antennadiv;
-	u16 offset;
-	u16 value;
-	u32 ucodeflags;
-
-	antennadiv = phy-&gt;antenna_diversity;
-
-	if (antennadiv == 0xFFFF)
-		antennadiv = 3;
-	assert(antennadiv &lt;= 3);
-
-	ucodeflags = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-					BCM43xx_UCODEFLAGS_OFFSET);
-	bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-			    BCM43xx_UCODEFLAGS_OFFSET,
-			    ucodeflags &amp; ~BCM43xx_UCODEFLAG_AUTODIV);
-
-	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-	case BCM43xx_PHYTYPE_G:
-		if (phy-&gt;type == BCM43xx_PHYTYPE_A)
-			offset = 0x0000;
-		else
-			offset = 0x0400;
-
-		if (antennadiv == 2)
-			value = (3/*automatic*/ &lt;&lt; 7);
-		else
-			value = (antennadiv &lt;&lt; 7);
-		bcm43xx_phy_write(bcm, offset + 1,
-				  (bcm43xx_phy_read(bcm, offset + 1)
-				   &amp; 0x7E7F) | value);
-
-		if (antennadiv &gt;= 2) {
-			if (antennadiv == 2)
-				value = (antennadiv &lt;&lt; 7);
-			else
-				value = (0/*force0*/ &lt;&lt; 7);
-			bcm43xx_phy_write(bcm, offset + 0x2B,
-					  (bcm43xx_phy_read(bcm, offset + 0x2B)
-					   &amp; 0xFEFF) | value);
-		}
-
-		if (phy-&gt;type == BCM43xx_PHYTYPE_G) {
-			if (antennadiv &gt;= 2)
-				bcm43xx_phy_write(bcm, 0x048C,
-						  bcm43xx_phy_read(bcm, 0x048C)
-						   | 0x2000);
-			else
-				bcm43xx_phy_write(bcm, 0x048C,
-						  bcm43xx_phy_read(bcm, 0x048C)
-						   &amp; ~0x2000);
-			if (phy-&gt;rev &gt;= 2) {
-				bcm43xx_phy_write(bcm, 0x0461,
-						  bcm43xx_phy_read(bcm, 0x0461)
-						   | 0x0010);
-				bcm43xx_phy_write(bcm, 0x04AD,
-						  (bcm43xx_phy_read(bcm, 0x04AD)
-						   &amp; 0x00FF) | 0x0015);
-				if (phy-&gt;rev == 2)
-					bcm43xx_phy_write(bcm, 0x0427, 0x0008);
-				else
-					bcm43xx_phy_write(bcm, 0x0427,
-						(bcm43xx_phy_read(bcm, 0x0427)
-						 &amp; 0x00FF) | 0x0008);
-			}
-			else if (phy-&gt;rev &gt;= 6)
-				bcm43xx_phy_write(bcm, 0x049B, 0x00DC);
-		} else {
-			if (phy-&gt;rev &lt; 3)
-				bcm43xx_phy_write(bcm, 0x002B,
-						  (bcm43xx_phy_read(bcm, 0x002B)
-						   &amp; 0x00FF) | 0x0024);
-			else {
-				bcm43xx_phy_write(bcm, 0x0061,
-						  bcm43xx_phy_read(bcm, 0x0061)
-						   | 0x0010);
-				if (phy-&gt;rev == 3) {
-					bcm43xx_phy_write(bcm, 0x0093, 0x001D);
-					bcm43xx_phy_write(bcm, 0x0027, 0x0008);
-				} else {
-					bcm43xx_phy_write(bcm, 0x0093, 0x003A);
-					bcm43xx_phy_write(bcm, 0x0027,
-						(bcm43xx_phy_read(bcm, 0x0027)
-						 &amp; 0x00FF) | 0x0008);
-				}
-			}
-		}
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if (bcm-&gt;current_core-&gt;rev == 2)
-			value = (3/*automatic*/ &lt;&lt; 7);
-		else
-			value = (antennadiv &lt;&lt; 7);
-		bcm43xx_phy_write(bcm, 0x03E2,
-				  (bcm43xx_phy_read(bcm, 0x03E2)
-				   &amp; 0xFE7F) | value);
-		break;
-	default:
-		assert(0);
-	}
-
-	if (antennadiv &gt;= 2) {
-		ucodeflags = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-						BCM43xx_UCODEFLAGS_OFFSET);
-		bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODEFLAGS_OFFSET,
-				    ucodeflags | BCM43xx_UCODEFLAG_AUTODIV);
-	}
-
-	phy-&gt;antenna_diversity = antennadiv;
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_phy.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef BCM43xx_PHY_H_
-#define BCM43xx_PHY_H_
-
-#include &lt;linux/types.h&gt;
-
-struct bcm43xx_private;
-
-void bcm43xx_raw_phy_lock(struct bcm43xx_private *bcm);
-#define bcm43xx_phy_lock(bcm, flags) \
-	do {					\
-		local_irq_save(flags);		\
-		bcm43xx_raw_phy_lock(bcm);	\
-	} while (0)
-void bcm43xx_raw_phy_unlock(struct bcm43xx_private *bcm);
-#define bcm43xx_phy_unlock(bcm, flags) \
-	do {					\
-		bcm43xx_raw_phy_unlock(bcm);	\
-		local_irq_restore(flags);	\
-	} while (0)
-
-/* Card uses the loopback gain stuff */
-#define has_loopback_gain(phy) \
-        (((phy)-&gt;rev &gt; 1) || ((phy)-&gt;connected))
-
-u16 bcm43xx_phy_read(struct bcm43xx_private *bcm, u16 offset);
-void bcm43xx_phy_write(struct bcm43xx_private *bcm, u16 offset, u16 val);
-
-int bcm43xx_phy_init_tssi2dbm_table(struct bcm43xx_private *bcm);
-int bcm43xx_phy_init(struct bcm43xx_private *bcm);
-
-void bcm43xx_phy_set_antenna_diversity(struct bcm43xx_private *bcm);
-void bcm43xx_phy_calibrate(struct bcm43xx_private *bcm);
-int bcm43xx_phy_connect(struct bcm43xx_private *bcm, int connect);
-
-void bcm43xx_phy_lo_b_measure(struct bcm43xx_private *bcm);
-void bcm43xx_phy_lo_g_measure(struct bcm43xx_private *bcm);
-void bcm43xx_phy_xmitpower(struct bcm43xx_private *bcm);
-
-/* Adjust the LocalOscillator to the saved values.
- * &quot;fixed&quot; is only set to 1 once in initialization. Set to 0 otherwise.
- */
-void bcm43xx_phy_lo_adjust(struct bcm43xx_private *bcm, int fixed);
-void bcm43xx_phy_lo_mark_all_unused(struct bcm43xx_private *bcm);
-
-void bcm43xx_phy_set_baseband_attenuation(struct bcm43xx_private *bcm,
-					  u16 baseband_attenuation);
-
-#endif /* BCM43xx_PHY_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_pio.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_pio.c
+++ /dev/null
@@ -1,674 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  PIO Transmission
-
-  Copyright (c) 2005 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &quot;bcm43xx.h&quot;
-#include &quot;bcm43xx_pio.h&quot;
-#include &quot;bcm43xx_main.h&quot;
-#include &quot;bcm43xx_xmit.h&quot;
-#include &quot;bcm43xx_power.h&quot;
-
-#include &lt;linux/delay.h&gt;
-
-
-static void tx_start(struct bcm43xx_pioqueue *queue)
-{
-	bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-			  BCM43xx_PIO_TXCTL_INIT);
-}
-
-static void tx_octet(struct bcm43xx_pioqueue *queue,
-		     u8 octet)
-{
-	if (queue-&gt;need_workarounds) {
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA,
-				  octet);
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-				  BCM43xx_PIO_TXCTL_WRITELO);
-	} else {
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-				  BCM43xx_PIO_TXCTL_WRITELO);
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA,
-				  octet);
-	}
-}
-
-static u16 tx_get_next_word(struct bcm43xx_txhdr *txhdr,
-			    const u8 *packet,
-			    unsigned int *pos)
-{
-	const u8 *source;
-	unsigned int i = *pos;
-	u16 ret;
-
-	if (i &lt; sizeof(*txhdr)) {
-		source = (const u8 *)txhdr;
-	} else {
-		source = packet;
-		i -= sizeof(*txhdr);
-	}
-	ret = le16_to_cpu( *((u16 *)(source + i)) );
-	*pos += 2;
-
-	return ret;
-}
-
-static void tx_data(struct bcm43xx_pioqueue *queue,
-		    struct bcm43xx_txhdr *txhdr,
-		    const u8 *packet,
-		    unsigned int octets)
-{
-	u16 data;
-	unsigned int i = 0;
-
-	if (queue-&gt;need_workarounds) {
-		data = tx_get_next_word(txhdr, packet, &amp;i);
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA, data);
-	}
-	bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-			  BCM43xx_PIO_TXCTL_WRITELO |
-			  BCM43xx_PIO_TXCTL_WRITEHI);
-	while (i &lt; octets - 1) {
-		data = tx_get_next_word(txhdr, packet, &amp;i);
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA, data);
-	}
-	if (octets % 2)
-		tx_octet(queue, packet[octets - sizeof(*txhdr) - 1]);
-}
-
-static void tx_complete(struct bcm43xx_pioqueue *queue,
-			struct sk_buff *skb)
-{
-	if (queue-&gt;need_workarounds) {
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXDATA,
-				  skb-&gt;data[skb-&gt;len - 1]);
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-				  BCM43xx_PIO_TXCTL_WRITELO |
-				  BCM43xx_PIO_TXCTL_COMPLETE);
-	} else {
-		bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-				  BCM43xx_PIO_TXCTL_COMPLETE);
-	}
-}
-
-static u16 generate_cookie(struct bcm43xx_pioqueue *queue,
-			   struct bcm43xx_pio_txpacket *packet)
-{
-	u16 cookie = 0x0000;
-	int packetindex;
-
-	/* We use the upper 4 bits for the PIO
-	 * controller ID and the lower 12 bits
-	 * for the packet index (in the cache).
-	 */
-	switch (queue-&gt;mmio_base) {
-	case BCM43xx_MMIO_PIO1_BASE:
-		break;
-	case BCM43xx_MMIO_PIO2_BASE:
-		cookie = 0x1000;
-		break;
-	case BCM43xx_MMIO_PIO3_BASE:
-		cookie = 0x2000;
-		break;
-	case BCM43xx_MMIO_PIO4_BASE:
-		cookie = 0x3000;
-		break;
-	default:
-		assert(0);
-	}
-	packetindex = pio_txpacket_getindex(packet);
-	assert(((u16)packetindex &amp; 0xF000) == 0x0000);
-	cookie |= (u16)packetindex;
-
-	return cookie;
-}
-
-static
-struct bcm43xx_pioqueue * parse_cookie(struct bcm43xx_private *bcm,
-				       u16 cookie,
-				       struct bcm43xx_pio_txpacket **packet)
-{
-	struct bcm43xx_pio *pio = bcm43xx_current_pio(bcm);
-	struct bcm43xx_pioqueue *queue = NULL;
-	int packetindex;
-
-	switch (cookie &amp; 0xF000) {
-	case 0x0000:
-		queue = pio-&gt;queue0;
-		break;
-	case 0x1000:
-		queue = pio-&gt;queue1;
-		break;
-	case 0x2000:
-		queue = pio-&gt;queue2;
-		break;
-	case 0x3000:
-		queue = pio-&gt;queue3;
-		break;
-	default:
-		assert(0);
-	}
-	packetindex = (cookie &amp; 0x0FFF);
-	assert(packetindex &gt;= 0 &amp;&amp; packetindex &lt; BCM43xx_PIO_MAXTXPACKETS);
-	*packet = &amp;(queue-&gt;tx_packets_cache[packetindex]);
-
-	return queue;
-}
-
-static void pio_tx_write_fragment(struct bcm43xx_pioqueue *queue,
-				  struct sk_buff *skb,
-				  struct bcm43xx_pio_txpacket *packet)
-{
-	struct bcm43xx_txhdr txhdr;
-	unsigned int octets;
-
-	assert(skb_shinfo(skb)-&gt;nr_frags == 0);
-	bcm43xx_generate_txhdr(queue-&gt;bcm,
-			       &amp;txhdr, skb-&gt;data, skb-&gt;len,
-			       (packet-&gt;xmitted_frags == 0),
-			       generate_cookie(queue, packet));
-
-	tx_start(queue);
-	octets = skb-&gt;len + sizeof(txhdr);
-	if (queue-&gt;need_workarounds)
-		octets--;
-	tx_data(queue, &amp;txhdr, (u8 *)skb-&gt;data, octets);
-	tx_complete(queue, skb);
-}
-
-static void free_txpacket(struct bcm43xx_pio_txpacket *packet,
-			  int irq_context)
-{
-	struct bcm43xx_pioqueue *queue = packet-&gt;queue;
-
-	ieee80211_txb_free(packet-&gt;txb);
-	list_move(&amp;packet-&gt;list, &amp;queue-&gt;txfree);
-	queue-&gt;nr_txfree++;
-
-	assert(queue-&gt;tx_devq_used &gt;= packet-&gt;xmitted_octets);
-	assert(queue-&gt;tx_devq_packets &gt;= packet-&gt;xmitted_frags);
-	queue-&gt;tx_devq_used -= packet-&gt;xmitted_octets;
-	queue-&gt;tx_devq_packets -= packet-&gt;xmitted_frags;
-}
-
-static int pio_tx_packet(struct bcm43xx_pio_txpacket *packet)
-{
-	struct bcm43xx_pioqueue *queue = packet-&gt;queue;
-	struct ieee80211_txb *txb = packet-&gt;txb;
-	struct sk_buff *skb;
-	u16 octets;
-	int i;
-
-	for (i = packet-&gt;xmitted_frags; i &lt; txb-&gt;nr_frags; i++) {
-		skb = txb-&gt;fragments[i];
-
-		octets = (u16)skb-&gt;len + sizeof(struct bcm43xx_txhdr);
-		assert(queue-&gt;tx_devq_size &gt;= octets);
-		assert(queue-&gt;tx_devq_packets &lt;= BCM43xx_PIO_MAXTXDEVQPACKETS);
-		assert(queue-&gt;tx_devq_used &lt;= queue-&gt;tx_devq_size);
-		/* Check if there is sufficient free space on the device
-		 * TX queue. If not, return and let the TX tasklet
-		 * retry later.
-		 */
-		if (queue-&gt;tx_devq_packets == BCM43xx_PIO_MAXTXDEVQPACKETS)
-			return -EBUSY;
-		if (queue-&gt;tx_devq_used + octets &gt; queue-&gt;tx_devq_size)
-			return -EBUSY;
-		/* Now poke the device. */
-		pio_tx_write_fragment(queue, skb, packet);
-
-		/* Account for the packet size.
-		 * (We must not overflow the device TX queue)
-		 */
-		queue-&gt;tx_devq_packets++;
-		queue-&gt;tx_devq_used += octets;
-
-		assert(packet-&gt;xmitted_frags &lt; packet-&gt;txb-&gt;nr_frags);
-		packet-&gt;xmitted_frags++;
-		packet-&gt;xmitted_octets += octets;
-	}
-	list_move_tail(&amp;packet-&gt;list, &amp;queue-&gt;txrunning);
-
-	return 0;
-}
-
-static void tx_tasklet(unsigned long d)
-{
-	struct bcm43xx_pioqueue *queue = (struct bcm43xx_pioqueue *)d;
-	struct bcm43xx_private *bcm = queue-&gt;bcm;
-	unsigned long flags;
-	struct bcm43xx_pio_txpacket *packet, *tmp_packet;
-	int err;
-	u16 txctl;
-
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-
-	if (queue-&gt;tx_frozen)
-		goto out_unlock;
-	txctl = bcm43xx_pio_read(queue, BCM43xx_PIO_TXCTL);
-	if (txctl &amp; BCM43xx_PIO_TXCTL_SUSPEND)
-		goto out_unlock;
-
-	list_for_each_entry_safe(packet, tmp_packet, &amp;queue-&gt;txqueue, list) {
-		assert(packet-&gt;xmitted_frags &lt; packet-&gt;txb-&gt;nr_frags);
-		if (packet-&gt;xmitted_frags == 0) {
-			int i;
-			struct sk_buff *skb;
-
-			/* Check if the device queue is big
-			 * enough for every fragment. If not, drop the
-			 * whole packet.
-			 */
-			for (i = 0; i &lt; packet-&gt;txb-&gt;nr_frags; i++) {
-				skb = packet-&gt;txb-&gt;fragments[i];
-				if (unlikely(skb-&gt;len &gt; queue-&gt;tx_devq_size)) {
-					dprintkl(KERN_ERR PFX &quot;PIO TX device queue too small. &quot;
-							      &quot;Dropping packet.\n&quot;);
-					free_txpacket(packet, 1);
-					goto next_packet;
-				}
-			}
-		}
-		/* Try to transmit the packet.
-		 * This may not completely succeed.
-		 */
-		err = pio_tx_packet(packet);
-		if (err)
-			break;
-	next_packet:
-		continue;
-	}
-out_unlock:
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-}
-
-static void setup_txqueues(struct bcm43xx_pioqueue *queue)
-{
-	struct bcm43xx_pio_txpacket *packet;
-	int i;
-
-	queue-&gt;nr_txfree = BCM43xx_PIO_MAXTXPACKETS;
-	for (i = 0; i &lt; BCM43xx_PIO_MAXTXPACKETS; i++) {
-		packet = &amp;(queue-&gt;tx_packets_cache[i]);
-
-		packet-&gt;queue = queue;
-		INIT_LIST_HEAD(&amp;packet-&gt;list);
-
-		list_add(&amp;packet-&gt;list, &amp;queue-&gt;txfree);
-	}
-}
-
-static
-struct bcm43xx_pioqueue * bcm43xx_setup_pioqueue(struct bcm43xx_private *bcm,
-						 u16 pio_mmio_base)
-{
-	struct bcm43xx_pioqueue *queue;
-	u32 value;
-	u16 qsize;
-
-	queue = kzalloc(sizeof(*queue), GFP_KERNEL);
-	if (!queue)
-		goto out;
-
-	queue-&gt;bcm = bcm;
-	queue-&gt;mmio_base = pio_mmio_base;
-	queue-&gt;need_workarounds = (bcm-&gt;current_core-&gt;rev &lt; 3);
-
-	INIT_LIST_HEAD(&amp;queue-&gt;txfree);
-	INIT_LIST_HEAD(&amp;queue-&gt;txqueue);
-	INIT_LIST_HEAD(&amp;queue-&gt;txrunning);
-	tasklet_init(&amp;queue-&gt;txtask, tx_tasklet,
-		     (unsigned long)queue);
-
-	value = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	value &amp;= ~BCM43xx_SBF_XFER_REG_BYTESWAP;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, value);
-
-	qsize = bcm43xx_read16(bcm, queue-&gt;mmio_base + BCM43xx_PIO_TXQBUFSIZE);
-	if (qsize == 0) {
-		printk(KERN_ERR PFX &quot;ERROR: This card does not support PIO &quot;
-				    &quot;operation mode. Please use DMA mode &quot;
-				    &quot;(module parameter pio=0).\n&quot;);
-		goto err_freequeue;
-	}
-	if (qsize &lt;= BCM43xx_PIO_TXQADJUST) {
-		printk(KERN_ERR PFX &quot;PIO tx device-queue too small (%u)\n&quot;,
-		       qsize);
-		goto err_freequeue;
-	}
-	qsize -= BCM43xx_PIO_TXQADJUST;
-	queue-&gt;tx_devq_size = qsize;
-
-	setup_txqueues(queue);
-
-out:
-	return queue;
-
-err_freequeue:
-	kfree(queue);
-	queue = NULL;
-	goto out;
-}
-
-static void cancel_transfers(struct bcm43xx_pioqueue *queue)
-{
-	struct bcm43xx_pio_txpacket *packet, *tmp_packet;
-
-	netif_tx_disable(queue-&gt;bcm-&gt;net_dev);
-	tasklet_disable(&amp;queue-&gt;txtask);
-
-	list_for_each_entry_safe(packet, tmp_packet, &amp;queue-&gt;txrunning, list)
-		free_txpacket(packet, 0);
-	list_for_each_entry_safe(packet, tmp_packet, &amp;queue-&gt;txqueue, list)
-		free_txpacket(packet, 0);
-}
-
-static void bcm43xx_destroy_pioqueue(struct bcm43xx_pioqueue *queue)
-{
-	if (!queue)
-		return;
-
-	cancel_transfers(queue);
-	kfree(queue);
-}
-
-void bcm43xx_pio_free(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_pio *pio;
-
-	if (!bcm43xx_using_pio(bcm))
-		return;
-	pio = bcm43xx_current_pio(bcm);
-
-	bcm43xx_destroy_pioqueue(pio-&gt;queue3);
-	pio-&gt;queue3 = NULL;
-	bcm43xx_destroy_pioqueue(pio-&gt;queue2);
-	pio-&gt;queue2 = NULL;
-	bcm43xx_destroy_pioqueue(pio-&gt;queue1);
-	pio-&gt;queue1 = NULL;
-	bcm43xx_destroy_pioqueue(pio-&gt;queue0);
-	pio-&gt;queue0 = NULL;
-}
-
-int bcm43xx_pio_init(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_pio *pio = bcm43xx_current_pio(bcm);
-	struct bcm43xx_pioqueue *queue;
-	int err = -ENOMEM;
-
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO1_BASE);
-	if (!queue)
-		goto out;
-	pio-&gt;queue0 = queue;
-
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO2_BASE);
-	if (!queue)
-		goto err_destroy0;
-	pio-&gt;queue1 = queue;
-
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO3_BASE);
-	if (!queue)
-		goto err_destroy1;
-	pio-&gt;queue2 = queue;
-
-	queue = bcm43xx_setup_pioqueue(bcm, BCM43xx_MMIO_PIO4_BASE);
-	if (!queue)
-		goto err_destroy2;
-	pio-&gt;queue3 = queue;
-
-	if (bcm-&gt;current_core-&gt;rev &lt; 3)
-		bcm-&gt;irq_savedstate |= BCM43xx_IRQ_PIO_WORKAROUND;
-
-	dprintk(KERN_INFO PFX &quot;PIO initialized\n&quot;);
-	err = 0;
-out:
-	return err;
-
-err_destroy2:
-	bcm43xx_destroy_pioqueue(pio-&gt;queue2);
-	pio-&gt;queue2 = NULL;
-err_destroy1:
-	bcm43xx_destroy_pioqueue(pio-&gt;queue1);
-	pio-&gt;queue1 = NULL;
-err_destroy0:
-	bcm43xx_destroy_pioqueue(pio-&gt;queue0);
-	pio-&gt;queue0 = NULL;
-	goto out;
-}
-
-int bcm43xx_pio_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
-{
-	struct bcm43xx_pioqueue *queue = bcm43xx_current_pio(bcm)-&gt;queue1;
-	struct bcm43xx_pio_txpacket *packet;
-
-	assert(!queue-&gt;tx_suspended);
-	assert(!list_empty(&amp;queue-&gt;txfree));
-
-	packet = list_entry(queue-&gt;txfree.next, struct bcm43xx_pio_txpacket, list);
-	packet-&gt;txb = txb;
-	packet-&gt;xmitted_frags = 0;
-	packet-&gt;xmitted_octets = 0;
-	list_move_tail(&amp;packet-&gt;list, &amp;queue-&gt;txqueue);
-	queue-&gt;nr_txfree--;
-	assert(queue-&gt;nr_txfree &lt; BCM43xx_PIO_MAXTXPACKETS);
-
-	/* Suspend TX, if we are out of packets in the &quot;free&quot; queue. */
-	if (list_empty(&amp;queue-&gt;txfree)) {
-		netif_stop_queue(queue-&gt;bcm-&gt;net_dev);
-		queue-&gt;tx_suspended = 1;
-	}
-
-	tasklet_schedule(&amp;queue-&gt;txtask);
-
-	return 0;
-}
-
-void bcm43xx_pio_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
-{
-	struct bcm43xx_pioqueue *queue;
-	struct bcm43xx_pio_txpacket *packet;
-
-	queue = parse_cookie(bcm, status-&gt;cookie, &amp;packet);
-	assert(queue);
-
-	free_txpacket(packet, 1);
-	if (queue-&gt;tx_suspended) {
-		queue-&gt;tx_suspended = 0;
-		netif_wake_queue(queue-&gt;bcm-&gt;net_dev);
-	}
-	/* If there are packets on the txqueue, poke the tasklet
-	 * to transmit them.
-	 */
-	if (!list_empty(&amp;queue-&gt;txqueue))
-		tasklet_schedule(&amp;queue-&gt;txtask);
-}
-
-static void pio_rx_error(struct bcm43xx_pioqueue *queue,
-			 int clear_buffers,
-			 const char *error)
-{
-	int i;
-
-	printkl(&quot;PIO RX error: %s\n&quot;, error);
-	bcm43xx_pio_write(queue, BCM43xx_PIO_RXCTL,
-			  BCM43xx_PIO_RXCTL_READY);
-	if (clear_buffers) {
-		assert(queue-&gt;mmio_base == BCM43xx_MMIO_PIO1_BASE);
-		for (i = 0; i &lt; 15; i++) {
-			/* Dummy read. */
-			bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
-		}
-	}
-}
-
-void bcm43xx_pio_rx(struct bcm43xx_pioqueue *queue)
-{
-	u16 preamble[21] = { 0 };
-	struct bcm43xx_rxhdr *rxhdr;
-	u16 tmp, len, rxflags2;
-	int i, preamble_readwords;
-	struct sk_buff *skb;
-
-	tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXCTL);
-	if (!(tmp &amp; BCM43xx_PIO_RXCTL_DATAAVAILABLE))
-		return;
-	bcm43xx_pio_write(queue, BCM43xx_PIO_RXCTL,
-			  BCM43xx_PIO_RXCTL_DATAAVAILABLE);
-
-	for (i = 0; i &lt; 10; i++) {
-		tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXCTL);
-		if (tmp &amp; BCM43xx_PIO_RXCTL_READY)
-			goto data_ready;
-		udelay(10);
-	}
-	dprintkl(KERN_ERR PFX &quot;PIO RX timed out\n&quot;);
-	return;
-data_ready:
-
-	len = bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
-	if (unlikely(len &gt; 0x700)) {
-		pio_rx_error(queue, 0, &quot;len &gt; 0x700&quot;);
-		return;
-	}
-	if (unlikely(len == 0 &amp;&amp; queue-&gt;mmio_base != BCM43xx_MMIO_PIO4_BASE)) {
-		pio_rx_error(queue, 0, &quot;len == 0&quot;);
-		return;
-	}
-	preamble[0] = cpu_to_le16(len);
-	if (queue-&gt;mmio_base == BCM43xx_MMIO_PIO4_BASE)
-		preamble_readwords = 14 / sizeof(u16);
-	else
-		preamble_readwords = 18 / sizeof(u16);
-	for (i = 0; i &lt; preamble_readwords; i++) {
-		tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
-		preamble[i + 1] = cpu_to_le16(tmp);
-	}
-	rxhdr = (struct bcm43xx_rxhdr *)preamble;
-	rxflags2 = le16_to_cpu(rxhdr-&gt;flags2);
-	if (unlikely(rxflags2 &amp; BCM43xx_RXHDR_FLAGS2_INVALIDFRAME)) {
-		pio_rx_error(queue,
-			     (queue-&gt;mmio_base == BCM43xx_MMIO_PIO1_BASE),
-			     &quot;invalid frame&quot;);
-		return;
-	}
-	if (queue-&gt;mmio_base == BCM43xx_MMIO_PIO4_BASE) {
-		/* We received an xmit status. */
-		struct bcm43xx_hwxmitstatus *hw;
-		struct bcm43xx_xmitstatus stat;
-
-		hw = (struct bcm43xx_hwxmitstatus *)(preamble + 1);
-		stat.cookie = le16_to_cpu(hw-&gt;cookie);
-		stat.flags = hw-&gt;flags;
-		stat.cnt1 = hw-&gt;cnt1;
-		stat.cnt2 = hw-&gt;cnt2;
-		stat.seq = le16_to_cpu(hw-&gt;seq);
-		stat.unknown = le16_to_cpu(hw-&gt;unknown);
-
-		bcm43xx_debugfs_log_txstat(queue-&gt;bcm, &amp;stat);
-		bcm43xx_pio_handle_xmitstatus(queue-&gt;bcm, &amp;stat);
-
-		return;
-	}
-
-	skb = dev_alloc_skb(len);
-	if (unlikely(!skb)) {
-		pio_rx_error(queue, 1, &quot;OOM&quot;);
-		return;
-	}
-	skb_put(skb, len);
-	for (i = 0; i &lt; len - 1; i += 2) {
-		tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
-		*((u16 *)(skb-&gt;data + i)) = cpu_to_le16(tmp);
-	}
-	if (len % 2) {
-		tmp = bcm43xx_pio_read(queue, BCM43xx_PIO_RXDATA);
-		skb-&gt;data[len - 1] = (tmp &amp; 0x00FF);
-/* The specs say the following is required, but
- * it is wrong and corrupts the PLCP. If we don't do
- * this, the PLCP seems to be correct. So ifdef it out for now.
- */
-#if 0
-		if (rxflags2 &amp; BCM43xx_RXHDR_FLAGS2_TYPE2FRAME)
-			skb-&gt;data[2] = (tmp &amp; 0xFF00) &gt;&gt; 8;
-		else
-			skb-&gt;data[0] = (tmp &amp; 0xFF00) &gt;&gt; 8;
-#endif
-	}
-	skb_trim(skb, len - IEEE80211_FCS_LEN);
-	bcm43xx_rx(queue-&gt;bcm, skb, rxhdr);
-}
-
-void bcm43xx_pio_tx_suspend(struct bcm43xx_pioqueue *queue)
-{
-	bcm43xx_power_saving_ctl_bits(queue-&gt;bcm, -1, 1);
-	bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-			  bcm43xx_pio_read(queue, BCM43xx_PIO_TXCTL)
-			  | BCM43xx_PIO_TXCTL_SUSPEND);
-}
-
-void bcm43xx_pio_tx_resume(struct bcm43xx_pioqueue *queue)
-{
-	bcm43xx_pio_write(queue, BCM43xx_PIO_TXCTL,
-			  bcm43xx_pio_read(queue, BCM43xx_PIO_TXCTL)
-			  &amp; ~BCM43xx_PIO_TXCTL_SUSPEND);
-	bcm43xx_power_saving_ctl_bits(queue-&gt;bcm, -1, -1);
-	if (!list_empty(&amp;queue-&gt;txqueue))
-		tasklet_schedule(&amp;queue-&gt;txtask);
-}
-
-void bcm43xx_pio_freeze_txqueues(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_pio *pio;
-
-	assert(bcm43xx_using_pio(bcm));
-	pio = bcm43xx_current_pio(bcm);
-	pio-&gt;queue0-&gt;tx_frozen = 1;
-	pio-&gt;queue1-&gt;tx_frozen = 1;
-	pio-&gt;queue2-&gt;tx_frozen = 1;
-	pio-&gt;queue3-&gt;tx_frozen = 1;
-}
-
-void bcm43xx_pio_thaw_txqueues(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_pio *pio;
-
-	assert(bcm43xx_using_pio(bcm));
-	pio = bcm43xx_current_pio(bcm);
-	pio-&gt;queue0-&gt;tx_frozen = 0;
-	pio-&gt;queue1-&gt;tx_frozen = 0;
-	pio-&gt;queue2-&gt;tx_frozen = 0;
-	pio-&gt;queue3-&gt;tx_frozen = 0;
-	if (!list_empty(&amp;pio-&gt;queue0-&gt;txqueue))
-		tasklet_schedule(&amp;pio-&gt;queue0-&gt;txtask);
-	if (!list_empty(&amp;pio-&gt;queue1-&gt;txqueue))
-		tasklet_schedule(&amp;pio-&gt;queue1-&gt;txtask);
-	if (!list_empty(&amp;pio-&gt;queue2-&gt;txqueue))
-		tasklet_schedule(&amp;pio-&gt;queue2-&gt;txtask);
-	if (!list_empty(&amp;pio-&gt;queue3-&gt;txqueue))
-		tasklet_schedule(&amp;pio-&gt;queue3-&gt;txtask);
-}
-
-
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_pio.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_pio.h
+++ /dev/null
@@ -1,163 +0,0 @@
-#ifndef BCM43xx_PIO_H_
-#define BCM43xx_PIO_H_
-
-#include &quot;bcm43xx.h&quot;
-
-#include &lt;linux/interrupt.h&gt;
-#include &lt;linux/list.h&gt;
-#include &lt;linux/skbuff.h&gt;
-
-
-#define BCM43xx_PIO_TXCTL		0x00
-#define BCM43xx_PIO_TXDATA		0x02
-#define BCM43xx_PIO_TXQBUFSIZE		0x04
-#define BCM43xx_PIO_RXCTL		0x08
-#define BCM43xx_PIO_RXDATA		0x0A
-
-#define BCM43xx_PIO_TXCTL_WRITELO	(1 &lt;&lt; 0)
-#define BCM43xx_PIO_TXCTL_WRITEHI	(1 &lt;&lt; 1)
-#define BCM43xx_PIO_TXCTL_COMPLETE	(1 &lt;&lt; 2)
-#define BCM43xx_PIO_TXCTL_INIT		(1 &lt;&lt; 3)
-#define BCM43xx_PIO_TXCTL_SUSPEND	(1 &lt;&lt; 7)
-
-#define BCM43xx_PIO_RXCTL_DATAAVAILABLE	(1 &lt;&lt; 0)
-#define BCM43xx_PIO_RXCTL_READY		(1 &lt;&lt; 1)
-
-/* PIO constants */
-#define BCM43xx_PIO_MAXTXDEVQPACKETS	31
-#define BCM43xx_PIO_TXQADJUST		80
-
-/* PIO tuning knobs */
-#define BCM43xx_PIO_MAXTXPACKETS	256
-
-
-
-#ifdef CONFIG_BCM43XX_PIO
-
-
-struct bcm43xx_pioqueue;
-struct bcm43xx_xmitstatus;
-
-struct bcm43xx_pio_txpacket {
-	struct bcm43xx_pioqueue *queue;
-	struct ieee80211_txb *txb;
-	struct list_head list;
-
-	u8 xmitted_frags;
-	u16 xmitted_octets;
-};
-
-#define pio_txpacket_getindex(packet) ((int)((packet) - (packet)-&gt;queue-&gt;tx_packets_cache)) 
-
-struct bcm43xx_pioqueue {
-	struct bcm43xx_private *bcm;
-	u16 mmio_base;
-
-	u8 tx_suspended:1,
-	   tx_frozen:1,
-	   need_workarounds:1; /* Workarounds needed for core.rev &lt; 3 */
-
-	/* Adjusted size of the device internal TX buffer. */
-	u16 tx_devq_size;
-	/* Used octets of the device internal TX buffer. */
-	u16 tx_devq_used;
-	/* Used packet slots in the device internal TX buffer. */
-	u8 tx_devq_packets;
-	/* Packets from the txfree list can
-	 * be taken on incoming TX requests.
-	 */
-	struct list_head txfree;
-	unsigned int nr_txfree;
-	/* Packets on the txqueue are queued,
-	 * but not completely written to the chip, yet.
-	 */
-	struct list_head txqueue;
-	/* Packets on the txrunning queue are completely
-	 * posted to the device. We are waiting for the txstatus.
-	 */
-	struct list_head txrunning;
-	/* Total number or packets sent.
-	 * (This counter can obviously wrap).
-	 */
-	unsigned int nr_tx_packets;
-	struct tasklet_struct txtask;
-	struct bcm43xx_pio_txpacket tx_packets_cache[BCM43xx_PIO_MAXTXPACKETS];
-};
-
-static inline
-u16 bcm43xx_pio_read(struct bcm43xx_pioqueue *queue,
-		     u16 offset)
-{
-	return bcm43xx_read16(queue-&gt;bcm, queue-&gt;mmio_base + offset);
-}
-
-static inline
-void bcm43xx_pio_write(struct bcm43xx_pioqueue *queue,
-		       u16 offset, u16 value)
-{
-	bcm43xx_write16(queue-&gt;bcm, queue-&gt;mmio_base + offset, value);
-	mmiowb();
-}
-
-
-int bcm43xx_pio_init(struct bcm43xx_private *bcm);
-void bcm43xx_pio_free(struct bcm43xx_private *bcm);
-
-int bcm43xx_pio_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb);
-void bcm43xx_pio_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status);
-void bcm43xx_pio_rx(struct bcm43xx_pioqueue *queue);
-
-/* Suspend a TX queue on hardware level. */
-void bcm43xx_pio_tx_suspend(struct bcm43xx_pioqueue *queue);
-void bcm43xx_pio_tx_resume(struct bcm43xx_pioqueue *queue);
-/* Suspend (freeze) the TX tasklet (software level). */
-void bcm43xx_pio_freeze_txqueues(struct bcm43xx_private *bcm);
-void bcm43xx_pio_thaw_txqueues(struct bcm43xx_private *bcm);
-
-#else /* CONFIG_BCM43XX_PIO */
-
-static inline
-int bcm43xx_pio_init(struct bcm43xx_private *bcm)
-{
-	return 0;
-}
-static inline
-void bcm43xx_pio_free(struct bcm43xx_private *bcm)
-{
-}
-static inline
-int bcm43xx_pio_tx(struct bcm43xx_private *bcm,
-		   struct ieee80211_txb *txb)
-{
-	return 0;
-}
-static inline
-void bcm43xx_pio_handle_xmitstatus(struct bcm43xx_private *bcm,
-				   struct bcm43xx_xmitstatus *status)
-{
-}
-static inline
-void bcm43xx_pio_rx(struct bcm43xx_pioqueue *queue)
-{
-}
-static inline
-void bcm43xx_pio_tx_suspend(struct bcm43xx_pioqueue *queue)
-{
-}
-static inline
-void bcm43xx_pio_tx_resume(struct bcm43xx_pioqueue *queue)
-{
-}
-static inline
-void bcm43xx_pio_freeze_txqueues(struct bcm43xx_private *bcm)
-{
-}
-static inline
-void bcm43xx_pio_thaw_txqueues(struct bcm43xx_private *bcm)
-{
-}
-
-#endif /* CONFIG_BCM43XX_PIO */
-#endif /* BCM43xx_PIO_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_power.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_power.c
+++ /dev/null
@@ -1,393 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &lt;linux/delay.h&gt;
-
-#include &quot;bcm43xx.h&quot;
-#include &quot;bcm43xx_power.h&quot;
-#include &quot;bcm43xx_main.h&quot;
-
-
-/* Get the Slow Clock Source */
-static int bcm43xx_pctl_get_slowclksrc(struct bcm43xx_private *bcm)
-{
-	u32 tmp;
-	int err;
-
-	assert(bcm-&gt;current_core == &amp;bcm-&gt;core_chipcommon);
-	if (bcm-&gt;current_core-&gt;rev &lt; 6) {
-		if (bcm-&gt;bustype == BCM43xx_BUSTYPE_PCMCIA ||
-		    bcm-&gt;bustype == BCM43xx_BUSTYPE_SB)
-			return BCM43xx_PCTL_CLKSRC_XTALOS;
-		if (bcm-&gt;bustype == BCM43xx_BUSTYPE_PCI) {
-			err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCTL_OUT, &amp;tmp);
-			assert(!err);
-			if (tmp &amp; 0x10)
-				return BCM43xx_PCTL_CLKSRC_PCI;
-			return BCM43xx_PCTL_CLKSRC_XTALOS;
-		}
-	}
-	if (bcm-&gt;current_core-&gt;rev &lt; 10) {
-		tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL);
-		tmp &amp;= 0x7;
-		if (tmp == 0)
-			return BCM43xx_PCTL_CLKSRC_LOPWROS;
-		if (tmp == 1)
-			return BCM43xx_PCTL_CLKSRC_XTALOS;
-		if (tmp == 2)
-			return BCM43xx_PCTL_CLKSRC_PCI;
-	}
-
-	return BCM43xx_PCTL_CLKSRC_XTALOS;
-}
-
-/* Get max/min slowclock frequency
- * as described in <A HREF="http://bcm-specs.sipsolutions.net/PowerControl">http://bcm-specs.sipsolutions.net/PowerControl</A>
- */
-static int bcm43xx_pctl_clockfreqlimit(struct bcm43xx_private *bcm,
-				       int get_max)
-{
-	int limit;
-	int clocksrc;
-	int divisor;
-	u32 tmp;
-
-	assert(bcm-&gt;chipcommon_capabilities &amp; BCM43xx_CAPABILITIES_PCTL);
-	assert(bcm-&gt;current_core == &amp;bcm-&gt;core_chipcommon);
-
-	clocksrc = bcm43xx_pctl_get_slowclksrc(bcm);
-	if (bcm-&gt;current_core-&gt;rev &lt; 6) {
-		switch (clocksrc) {
-		case BCM43xx_PCTL_CLKSRC_PCI:
-			divisor = 64;
-			break;
-		case BCM43xx_PCTL_CLKSRC_XTALOS:
-			divisor = 32;
-			break;
-		default:
-			assert(0);
-			divisor = 1;
-		}
-	} else if (bcm-&gt;current_core-&gt;rev &lt; 10) {
-		switch (clocksrc) {
-		case BCM43xx_PCTL_CLKSRC_LOPWROS:
-			divisor = 1;
-			break;
-		case BCM43xx_PCTL_CLKSRC_XTALOS:
-		case BCM43xx_PCTL_CLKSRC_PCI:
-			tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL);
-			divisor = ((tmp &amp; 0xFFFF0000) &gt;&gt; 16) + 1;
-			divisor *= 4;
-			break;
-		default:
-			assert(0);
-			divisor = 1;
-		}
-	} else {
-		tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SYSCLKCTL);
-		divisor = ((tmp &amp; 0xFFFF0000) &gt;&gt; 16) + 1;
-		divisor *= 4;
-	}
-
-	switch (clocksrc) {
-	case BCM43xx_PCTL_CLKSRC_LOPWROS:
-		if (get_max)
-			limit = 43000;
-		else
-			limit = 25000;
-		break;
-	case BCM43xx_PCTL_CLKSRC_XTALOS:
-		if (get_max)
-			limit = 20200000;
-		else
-			limit = 19800000;
-		break;
-	case BCM43xx_PCTL_CLKSRC_PCI:
-		if (get_max)
-			limit = 34000000;
-		else
-			limit = 25000000;
-		break;
-	default:
-		assert(0);
-		limit = 0;
-	}
-	limit /= divisor;
-
-	return limit;
-}
-
-
-/* init power control
- * as described in <A HREF="http://bcm-specs.sipsolutions.net/PowerControl">http://bcm-specs.sipsolutions.net/PowerControl</A>
- */
-int bcm43xx_pctl_init(struct bcm43xx_private *bcm)
-{
-	int err, maxfreq;
-	struct bcm43xx_coreinfo *old_core;
-
-	old_core = bcm-&gt;current_core;
-	err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_chipcommon);
-	if (err == -ENODEV)
-		return 0;
-	if (err)
-		goto out;
-
-	if (bcm-&gt;chip_id == 0x4321) {
-		if (bcm-&gt;chip_rev == 0)
-			bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_CTL, 0x03A4);
-		if (bcm-&gt;chip_rev == 1)
-			bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_CTL, 0x00A4);
-	}
-
-	if (bcm-&gt;chipcommon_capabilities &amp; BCM43xx_CAPABILITIES_PCTL) {
-		if (bcm-&gt;current_core-&gt;rev &gt;= 10) {
-			/* Set Idle Power clock rate to 1Mhz */
-			bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_SYSCLKCTL,
-				       (bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SYSCLKCTL)
-				       &amp; 0x0000FFFF) | 0x40000);
-		} else {
-			maxfreq = bcm43xx_pctl_clockfreqlimit(bcm, 1);
-			bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_PLLONDELAY,
-				       (maxfreq * 150 + 999999) / 1000000);
-			bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_FREFSELDELAY,
-				       (maxfreq * 15 + 999999) / 1000000);
-		}
-	}
-
-	err = bcm43xx_switch_core(bcm, old_core);
-	assert(err == 0);
-
-out:
-	return err;
-}
-
-u16 bcm43xx_pctl_powerup_delay(struct bcm43xx_private *bcm)
-{
-	u16 delay = 0;
-	int err;
-	u32 pll_on_delay;
-	struct bcm43xx_coreinfo *old_core;
-	int minfreq;
-
-	if (bcm-&gt;bustype != BCM43xx_BUSTYPE_PCI)
-		goto out;
-	if (!(bcm-&gt;chipcommon_capabilities &amp; BCM43xx_CAPABILITIES_PCTL))
-		goto out;
-	old_core = bcm-&gt;current_core;
-	err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_chipcommon);
-	if (err == -ENODEV)
-		goto out;
-
-	minfreq = bcm43xx_pctl_clockfreqlimit(bcm, 0);
-	pll_on_delay = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_PLLONDELAY);
-	delay = (((pll_on_delay + 2) * 1000000) + (minfreq - 1)) / minfreq;
-
-	err = bcm43xx_switch_core(bcm, old_core);
-	assert(err == 0);
-
-out:
-	return delay;
-}
-
-/* set the powercontrol clock
- * as described in <A HREF="http://bcm-specs.sipsolutions.net/PowerControl">http://bcm-specs.sipsolutions.net/PowerControl</A>
- */
-int bcm43xx_pctl_set_clock(struct bcm43xx_private *bcm, u16 mode)
-{
-	int err;
-	struct bcm43xx_coreinfo *old_core;
-	u32 tmp;
-
-	old_core = bcm-&gt;current_core;
-	err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_chipcommon);
-	if (err == -ENODEV)
-		return 0;
-	if (err)
-		goto out;
-	
-	if (bcm-&gt;core_chipcommon.rev &lt; 6) {
-		if (mode == BCM43xx_PCTL_CLK_FAST) {
-			err = bcm43xx_pctl_set_crystal(bcm, 1);
-			if (err)
-				goto out;
-		}
-	} else {
-		if ((bcm-&gt;chipcommon_capabilities &amp; BCM43xx_CAPABILITIES_PCTL) &amp;&amp;
-			(bcm-&gt;core_chipcommon.rev &lt; 10)) {
-			switch (mode) {
-			case BCM43xx_PCTL_CLK_FAST:
-				tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL);
-				tmp = (tmp &amp; ~BCM43xx_PCTL_FORCE_SLOW) | BCM43xx_PCTL_FORCE_PLL;
-				bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL, tmp);
-				break;
-			case BCM43xx_PCTL_CLK_SLOW:
-				tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL);
-				tmp |= BCM43xx_PCTL_FORCE_SLOW;
-				bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL, tmp);
-				break;
-			case BCM43xx_PCTL_CLK_DYNAMIC:
-				tmp = bcm43xx_read32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL);
-				tmp &amp;= ~BCM43xx_PCTL_FORCE_SLOW;
-				tmp |= BCM43xx_PCTL_FORCE_PLL;
-				tmp &amp;= ~BCM43xx_PCTL_DYN_XTAL;
-				bcm43xx_write32(bcm, BCM43xx_CHIPCOMMON_SLOWCLKCTL, tmp);
-			}
-		}
-	}
-	
-	err = bcm43xx_switch_core(bcm, old_core);
-	assert(err == 0);
-
-out:
-	return err;
-}
-
-int bcm43xx_pctl_set_crystal(struct bcm43xx_private *bcm, int on)
-{
-	int err;
-	u32 in, out, outenable;
-
-	err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCTL_IN, &amp;in);
-	if (err)
-		goto err_pci;
-	err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCTL_OUT, &amp;out);
-	if (err)
-		goto err_pci;
-	err = bcm43xx_pci_read_config32(bcm, BCM43xx_PCTL_OUTENABLE, &amp;outenable);
-	if (err)
-		goto err_pci;
-
-	outenable |= (BCM43xx_PCTL_XTAL_POWERUP | BCM43xx_PCTL_PLL_POWERDOWN);
-
-	if (on) {
-		if (in &amp; 0x40)
-			return 0;
-
-		out |= (BCM43xx_PCTL_XTAL_POWERUP | BCM43xx_PCTL_PLL_POWERDOWN);
-
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCTL_OUT, out);
-		if (err)
-			goto err_pci;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCTL_OUTENABLE, outenable);
-		if (err)
-			goto err_pci;
-		udelay(1000);
-
-		out &amp;= ~BCM43xx_PCTL_PLL_POWERDOWN;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCTL_OUT, out);
-		if (err)
-			goto err_pci;
-		udelay(5000);
-	} else {
-		if (bcm-&gt;current_core-&gt;rev &lt; 5)
-			return 0;
-		if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_XTAL_NOSLOW)
-			return 0;
-
-/*		XXX: Why BCM43xx_MMIO_RADIO_HWENABLED_xx can't be read at this time?
- *		err = bcm43xx_switch_core(bcm, bcm-&gt;active_80211_core);
- *		if (err)
- *			return err;
- *		if (((bcm-&gt;current_core-&gt;rev &gt;= 3) &amp;&amp;
- *			(bcm43xx_read32(bcm, BCM43xx_MMIO_RADIO_HWENABLED_HI) &amp; (1 &lt;&lt; 16))) ||
- *		      ((bcm-&gt;current_core-&gt;rev &lt; 3) &amp;&amp;
- *			!(bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_HWENABLED_LO) &amp; (1 &lt;&lt; 4))))
- *			return 0;
- *		err = bcm43xx_switch_core(bcm, &amp;bcm-&gt;core_chipcommon);
- *		if (err)
- *			return err;
- */
-		
-		err = bcm43xx_pctl_set_clock(bcm, BCM43xx_PCTL_CLK_SLOW);
-		if (err)
-			goto out;
-		out &amp;= ~BCM43xx_PCTL_XTAL_POWERUP;
-		out |= BCM43xx_PCTL_PLL_POWERDOWN;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCTL_OUT, out);
-		if (err)
-			goto err_pci;
-		err = bcm43xx_pci_write_config32(bcm, BCM43xx_PCTL_OUTENABLE, outenable);
-		if (err)
-			goto err_pci;
-	}
-
-out:
-	return err;
-
-err_pci:
-	printk(KERN_ERR PFX &quot;Error: pctl_set_clock() could not access PCI config space!\n&quot;);
-	err = -EBUSY;
-	goto out;
-}
-
-/* Set the PowerSavingControlBits.
- * Bitvalues:
- *   0  =&gt; unset the bit
- *   1  =&gt; set the bit
- *   -1 =&gt; calculate the bit
- */
-void bcm43xx_power_saving_ctl_bits(struct bcm43xx_private *bcm,
-				   int bit25, int bit26)
-{
-	int i;
-	u32 status;
-
-//FIXME: Force 25 to off and 26 to on for now:
-bit25 = 0;
-bit26 = 1;
-
-	if (bit25 == -1) {
-		//TODO: If powersave is not off and FIXME is not set and we are not in adhoc
-		//	and thus is not an AP and we are associated, set bit 25
-	}
-	if (bit26 == -1) {
-		//TODO: If the device is awake or this is an AP, or we are scanning, or FIXME,
-		//	or we are associated, or FIXME, or the latest PS-Poll packet sent was
-		//	successful, set bit26
-	}
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	if (bit25)
-		status |= BCM43xx_SBF_PS1;
-	else
-		status &amp;= ~BCM43xx_SBF_PS1;
-	if (bit26)
-		status |= BCM43xx_SBF_PS2;
-	else
-		status &amp;= ~BCM43xx_SBF_PS2;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-	if (bit26 &amp;&amp; bcm-&gt;current_core-&gt;rev &gt;= 5) {
-		for (i = 0; i &lt; 100; i++) {
-			if (bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED, 0x0040) != 4)
-				break;
-			udelay(10);
-		}
-	}
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_power.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_power.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef BCM43xx_POWER_H_
-#define BCM43xx_POWER_H_
-
-#include &lt;linux/types.h&gt;
-
-/* Clock sources */
-enum {
-	/* PCI clock */
-	BCM43xx_PCTL_CLKSRC_PCI,
-	/* Crystal slow clock oscillator */
-	BCM43xx_PCTL_CLKSRC_XTALOS,
-	/* Low power oscillator */
-	BCM43xx_PCTL_CLKSRC_LOPWROS,
-};
-
-struct bcm43xx_private;
-
-int bcm43xx_pctl_init(struct bcm43xx_private *bcm);
-int bcm43xx_pctl_set_clock(struct bcm43xx_private *bcm, u16 mode);
-int bcm43xx_pctl_set_crystal(struct bcm43xx_private *bcm, int on);
-u16 bcm43xx_pctl_powerup_delay(struct bcm43xx_private *bcm);
-
-void bcm43xx_power_saving_ctl_bits(struct bcm43xx_private *bcm,
-				   int bit25, int bit26);
-
-#endif /* BCM43xx_POWER_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_radio.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_radio.c
+++ /dev/null
@@ -1,2170 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &lt;linux/delay.h&gt;
-
-#include &quot;bcm43xx.h&quot;
-#include &quot;bcm43xx_main.h&quot;
-#include &quot;bcm43xx_phy.h&quot;
-#include &quot;bcm43xx_radio.h&quot;
-#include &quot;bcm43xx_ilt.h&quot;
-
-
-/* Table for bcm43xx_radio_calibrationvalue() */
-static const u16 rcc_table[16] = {
-	0x0002, 0x0003, 0x0001, 0x000F,
-	0x0006, 0x0007, 0x0005, 0x000F,
-	0x000A, 0x000B, 0x0009, 0x000F,
-	0x000E, 0x000F, 0x000D, 0x000F,
-};
-
-/* Reverse the bits of a 4bit value.
- * Example:  1101 is flipped 1011
- */
-static u16 flip_4bit(u16 value)
-{
-	u16 flipped = 0x0000;
-
-	assert((value &amp; ~0x000F) == 0x0000);
-
-	flipped |= (value &amp; 0x0001) &lt;&lt; 3;
-	flipped |= (value &amp; 0x0002) &lt;&lt; 1;
-	flipped |= (value &amp; 0x0004) &gt;&gt; 1;
-	flipped |= (value &amp; 0x0008) &gt;&gt; 3;
-
-	return flipped;
-}
-
-/* Get the freq, as it has to be written to the device. */
-static inline
-u16 channel2freq_bg(u8 channel)
-{
-	/* Frequencies are given as frequencies_bg[index] + 2.4GHz
-	 * Starting with channel 1
-	 */
-	static const u16 frequencies_bg[14] = {
-		12, 17, 22, 27,
-		32, 37, 42, 47,
-		52, 57, 62, 67,
-		72, 84,
-	};
-
-	assert(channel &gt;= 1 &amp;&amp; channel &lt;= 14);
-
-	return frequencies_bg[channel - 1];
-}
-
-/* Get the freq, as it has to be written to the device. */
-static inline
-u16 channel2freq_a(u8 channel)
-{
-	assert(channel &lt;= 200);
-
-	return (5000 + 5 * channel);
-}
-
-void bcm43xx_radio_lock(struct bcm43xx_private *bcm)
-{
-	u32 status;
-
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	status |= BCM43xx_SBF_RADIOREG_LOCK;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-	mmiowb();
-	udelay(10);
-}
-
-void bcm43xx_radio_unlock(struct bcm43xx_private *bcm)
-{
-	u32 status;
-
-	bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_VER); /* dummy read */
-	status = bcm43xx_read32(bcm, BCM43xx_MMIO_STATUS_BITFIELD);
-	status &amp;= ~BCM43xx_SBF_RADIOREG_LOCK;
-	bcm43xx_write32(bcm, BCM43xx_MMIO_STATUS_BITFIELD, status);
-	mmiowb();
-}
-
-u16 bcm43xx_radio_read16(struct bcm43xx_private *bcm, u16 offset)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-
-	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-		offset |= 0x0040;
-		break;
-	case BCM43xx_PHYTYPE_B:
-		if (radio-&gt;version == 0x2053) {
-			if (offset &lt; 0x70)
-				offset += 0x80;
-			else if (offset &lt; 0x80)
-				offset += 0x70;
-		} else if (radio-&gt;version == 0x2050) {
-			offset |= 0x80;
-		} else
-			assert(0);
-		break;
-	case BCM43xx_PHYTYPE_G:
-		offset |= 0x80;
-		break;
-	}
-
-	bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, offset);
-	return bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_DATA_LOW);
-}
-
-void bcm43xx_radio_write16(struct bcm43xx_private *bcm, u16 offset, u16 val)
-{
-	bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_CONTROL, offset);
-	mmiowb();
-	bcm43xx_write16(bcm, BCM43xx_MMIO_RADIO_DATA_LOW, val);
-}
-
-static void bcm43xx_set_all_gains(struct bcm43xx_private *bcm,
-				  s16 first, s16 second, s16 third)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 i;
-	u16 start = 0x08, end = 0x18;
-	u16 offset = 0x0400;
-	u16 tmp;
-
-	if (phy-&gt;rev &lt;= 1) {
-		offset = 0x5000;
-		start = 0x10;
-		end = 0x20;
-	}
-
-	for (i = 0; i &lt; 4; i++)
-		bcm43xx_ilt_write(bcm, offset + i, first);
-
-	for (i = start; i &lt; end; i++)
-		bcm43xx_ilt_write(bcm, offset + i, second);
-
-	if (third != -1) {
-		tmp = ((u16)third &lt;&lt; 14) | ((u16)third &lt;&lt; 6);
-		bcm43xx_phy_write(bcm, 0x04A0,
-		                  (bcm43xx_phy_read(bcm, 0x04A0) &amp; 0xBFBF) | tmp);
-		bcm43xx_phy_write(bcm, 0x04A1,
-		                  (bcm43xx_phy_read(bcm, 0x04A1) &amp; 0xBFBF) | tmp);
-		bcm43xx_phy_write(bcm, 0x04A2,
-		                  (bcm43xx_phy_read(bcm, 0x04A2) &amp; 0xBFBF) | tmp);
-	}
-	bcm43xx_dummy_transmission(bcm);
-}
-
-static void bcm43xx_set_original_gains(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 i, tmp;
-	u16 offset = 0x0400;
-	u16 start = 0x0008, end = 0x0018;
-
-	if (phy-&gt;rev &lt;= 1) {
-		offset = 0x5000;
-		start = 0x0010;
-		end = 0x0020;
-	}
-
-	for (i = 0; i &lt; 4; i++) {
-		tmp = (i &amp; 0xFFFC);
-		tmp |= (i &amp; 0x0001) &lt;&lt; 1;
-		tmp |= (i &amp; 0x0002) &gt;&gt; 1;
-
-		bcm43xx_ilt_write(bcm, offset + i, tmp);
-	}
-
-	for (i = start; i &lt; end; i++)
-		bcm43xx_ilt_write(bcm, offset + i, i - start);
-
-	bcm43xx_phy_write(bcm, 0x04A0,
-	                  (bcm43xx_phy_read(bcm, 0x04A0) &amp; 0xBFBF) | 0x4040);
-	bcm43xx_phy_write(bcm, 0x04A1,
-	                  (bcm43xx_phy_read(bcm, 0x04A1) &amp; 0xBFBF) | 0x4040);
-	bcm43xx_phy_write(bcm, 0x04A2,
-	                  (bcm43xx_phy_read(bcm, 0x04A2) &amp; 0xBFBF) | 0x4000);
-	bcm43xx_dummy_transmission(bcm);
-}
-
-/* Synthetic PU workaround */
-static void bcm43xx_synth_pu_workaround(struct bcm43xx_private *bcm, u8 channel)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	
-	if (radio-&gt;version != 0x2050 || radio-&gt;revision &gt;= 6) {
-		/* We do not need the workaround. */
-		return;
-	}
-
-	if (channel &lt;= 10) {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
-				channel2freq_bg(channel + 4));
-	} else {
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
-				channel2freq_bg(1));
-	}
-	udelay(100);
-	bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
-			channel2freq_bg(channel));
-}
-
-u8 bcm43xx_radio_aci_detect(struct bcm43xx_private *bcm, u8 channel)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u8 ret = 0;
-	u16 saved, rssi, temp;
-	int i, j = 0;
-
-	saved = bcm43xx_phy_read(bcm, 0x0403);
-	bcm43xx_radio_selectchannel(bcm, channel, 0);
-	bcm43xx_phy_write(bcm, 0x0403, (saved &amp; 0xFFF8) | 5);
-	if (radio-&gt;aci_hw_rssi)
-		rssi = bcm43xx_phy_read(bcm, 0x048A) &amp; 0x3F;
-	else
-		rssi = saved &amp; 0x3F;
-	/* clamp temp to signed 5bit */
-	if (rssi &gt; 32)
-		rssi -= 64;
-	for (i = 0;i &lt; 100; i++) {
-		temp = (bcm43xx_phy_read(bcm, 0x047F) &gt;&gt; 8) &amp; 0x3F;
-		if (temp &gt; 32)
-			temp -= 64;
-		if (temp &lt; rssi)
-			j++;
-		if (j &gt;= 20)
-			ret = 1;
-	}
-	bcm43xx_phy_write(bcm, 0x0403, saved);
-
-	return ret;
-}
-
-u8 bcm43xx_radio_aci_scan(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u8 ret[13];
-	unsigned int channel = radio-&gt;channel;
-	unsigned int i, j, start, end;
-	unsigned long phylock_flags;
-
-	if (!((phy-&gt;type == BCM43xx_PHYTYPE_G) &amp;&amp; (phy-&gt;rev &gt; 0)))
-		return 0;
-
-	bcm43xx_phy_lock(bcm, phylock_flags);
-	bcm43xx_radio_lock(bcm);
-	bcm43xx_phy_write(bcm, 0x0802,
-	                  bcm43xx_phy_read(bcm, 0x0802) &amp; 0xFFFC);
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-	                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) &amp; 0x7FFF);
-	bcm43xx_set_all_gains(bcm, 3, 8, 1);
-
-	start = (channel - 5 &gt; 0) ? channel - 5 : 1;
-	end = (channel + 5 &lt; 14) ? channel + 5 : 13;
-
-	for (i = start; i &lt;= end; i++) {
-		if (abs(channel - i) &gt; 2)
-			ret[i-1] = bcm43xx_radio_aci_detect(bcm, i);
-	}
-	bcm43xx_radio_selectchannel(bcm, channel, 0);
-	bcm43xx_phy_write(bcm, 0x0802,
-	                  (bcm43xx_phy_read(bcm, 0x0802) &amp; 0xFFFC) | 0x0003);
-	bcm43xx_phy_write(bcm, 0x0403,
-	                  bcm43xx_phy_read(bcm, 0x0403) &amp; 0xFFF8);
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-	                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x8000);
-	bcm43xx_set_original_gains(bcm);
-	for (i = 0; i &lt; 13; i++) {
-		if (!ret[i])
-			continue;
-		end = (i + 5 &lt; 13) ? i + 5 : 13;
-		for (j = i; j &lt; end; j++)
-			ret[j] = 1;
-	}
-	bcm43xx_radio_unlock(bcm);
-	bcm43xx_phy_unlock(bcm, phylock_flags);
-
-	return ret[channel - 1];
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/NRSSILookupTable">http://bcm-specs.sipsolutions.net/NRSSILookupTable</A> */
-void bcm43xx_nrssi_hw_write(struct bcm43xx_private *bcm, u16 offset, s16 val)
-{
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_NRSSILT_CTRL, offset);
-	mmiowb();
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_NRSSILT_DATA, (u16)val);
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/NRSSILookupTable">http://bcm-specs.sipsolutions.net/NRSSILookupTable</A> */
-s16 bcm43xx_nrssi_hw_read(struct bcm43xx_private *bcm, u16 offset)
-{
-	u16 val;
-
-	bcm43xx_phy_write(bcm, BCM43xx_PHY_NRSSILT_CTRL, offset);
-	val = bcm43xx_phy_read(bcm, BCM43xx_PHY_NRSSILT_DATA);
-
-	return (s16)val;
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/NRSSILookupTable">http://bcm-specs.sipsolutions.net/NRSSILookupTable</A> */
-void bcm43xx_nrssi_hw_update(struct bcm43xx_private *bcm, u16 val)
-{
-	u16 i;
-	s16 tmp;
-
-	for (i = 0; i &lt; 64; i++) {
-		tmp = bcm43xx_nrssi_hw_read(bcm, i);
-		tmp -= val;
-		tmp = limit_value(tmp, -32, 31);
-		bcm43xx_nrssi_hw_write(bcm, i, tmp);
-	}
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/NRSSILookupTable">http://bcm-specs.sipsolutions.net/NRSSILookupTable</A> */
-void bcm43xx_nrssi_mem_update(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	s16 i, delta;
-	s32 tmp;
-
-	delta = 0x1F - radio-&gt;nrssi[0];
-	for (i = 0; i &lt; 64; i++) {
-		tmp = (i - delta) * radio-&gt;nrssislope;
-		tmp /= 0x10000;
-		tmp += 0x3A;
-		tmp = limit_value(tmp, 0, 0x3F);
-		radio-&gt;nrssi_lt[i] = tmp;
-	}
-}
-
-static void bcm43xx_calc_nrssi_offset(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	u16 backup[20] = { 0 };
-	s16 v47F;
-	u16 i;
-	u16 saved = 0xFFFF;
-
-	backup[0] = bcm43xx_phy_read(bcm, 0x0001);
-	backup[1] = bcm43xx_phy_read(bcm, 0x0811);
-	backup[2] = bcm43xx_phy_read(bcm, 0x0812);
-	backup[3] = bcm43xx_phy_read(bcm, 0x0814);
-	backup[4] = bcm43xx_phy_read(bcm, 0x0815);
-	backup[5] = bcm43xx_phy_read(bcm, 0x005A);
-	backup[6] = bcm43xx_phy_read(bcm, 0x0059);
-	backup[7] = bcm43xx_phy_read(bcm, 0x0058);
-	backup[8] = bcm43xx_phy_read(bcm, 0x000A);
-	backup[9] = bcm43xx_phy_read(bcm, 0x0003);
-	backup[10] = bcm43xx_radio_read16(bcm, 0x007A);
-	backup[11] = bcm43xx_radio_read16(bcm, 0x0043);
-
-	bcm43xx_phy_write(bcm, 0x0429,
-			  bcm43xx_phy_read(bcm, 0x0429) &amp; 0x7FFF);
-	bcm43xx_phy_write(bcm, 0x0001,
-			  (bcm43xx_phy_read(bcm, 0x0001) &amp; 0x3FFF) | 0x4000);
-	bcm43xx_phy_write(bcm, 0x0811,
-			  bcm43xx_phy_read(bcm, 0x0811) | 0x000C);
-	bcm43xx_phy_write(bcm, 0x0812,
-			  (bcm43xx_phy_read(bcm, 0x0812) &amp; 0xFFF3) | 0x0004);
-	bcm43xx_phy_write(bcm, 0x0802,
-			  bcm43xx_phy_read(bcm, 0x0802) &amp; ~(0x1 | 0x2));
-	if (phy-&gt;rev &gt;= 6) {
-		backup[12] = bcm43xx_phy_read(bcm, 0x002E);
-		backup[13] = bcm43xx_phy_read(bcm, 0x002F);
-		backup[14] = bcm43xx_phy_read(bcm, 0x080F);
-		backup[15] = bcm43xx_phy_read(bcm, 0x0810);
-		backup[16] = bcm43xx_phy_read(bcm, 0x0801);
-		backup[17] = bcm43xx_phy_read(bcm, 0x0060);
-		backup[18] = bcm43xx_phy_read(bcm, 0x0014);
-		backup[19] = bcm43xx_phy_read(bcm, 0x0478);
-
-		bcm43xx_phy_write(bcm, 0x002E, 0);
-		bcm43xx_phy_write(bcm, 0x002F, 0);
-		bcm43xx_phy_write(bcm, 0x080F, 0);
-		bcm43xx_phy_write(bcm, 0x0810, 0);
-		bcm43xx_phy_write(bcm, 0x0478,
-				  bcm43xx_phy_read(bcm, 0x0478) | 0x0100);
-		bcm43xx_phy_write(bcm, 0x0801,
-				  bcm43xx_phy_read(bcm, 0x0801) | 0x0040);
-		bcm43xx_phy_write(bcm, 0x0060,
-				  bcm43xx_phy_read(bcm, 0x0060) | 0x0040);
-		bcm43xx_phy_write(bcm, 0x0014,
-				  bcm43xx_phy_read(bcm, 0x0014) | 0x0200);
-	}
-	bcm43xx_radio_write16(bcm, 0x007A,
-			      bcm43xx_radio_read16(bcm, 0x007A) | 0x0070);
-	bcm43xx_radio_write16(bcm, 0x007A,
-			      bcm43xx_radio_read16(bcm, 0x007A) | 0x0080);
-	udelay(30);
-
-	v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) &gt;&gt; 8) &amp; 0x003F);
-	if (v47F &gt;= 0x20)
-		v47F -= 0x40;
-	if (v47F == 31) {
-		for (i = 7; i &gt;= 4; i--) {
-			bcm43xx_radio_write16(bcm, 0x007B, i);
-			udelay(20);
-			v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) &gt;&gt; 8) &amp; 0x003F);
-			if (v47F &gt;= 0x20)
-				v47F -= 0x40;
-			if (v47F &lt; 31 &amp;&amp; saved == 0xFFFF)
-				saved = i;
-		}
-		if (saved == 0xFFFF)
-			saved = 4;
-	} else {
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) &amp; 0x007F);
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0001);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) &amp; 0xFFFE);
-		bcm43xx_phy_write(bcm, 0x0811,
-				  bcm43xx_phy_read(bcm, 0x0811) | 0x000C);
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_phy_read(bcm, 0x0812) | 0x000C);
-		bcm43xx_phy_write(bcm, 0x0811,
-				  bcm43xx_phy_read(bcm, 0x0811) | 0x0030);
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_phy_read(bcm, 0x0812) | 0x0030);
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0x0810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-		if (phy-&gt;analog == 0) {
-			bcm43xx_phy_write(bcm, 0x0003, 0x0122);
-		} else {
-			bcm43xx_phy_write(bcm, 0x000A,
-					  bcm43xx_phy_read(bcm, 0x000A)
-					  | 0x2000);
-		}
-		bcm43xx_phy_write(bcm, 0x0814,
-				  bcm43xx_phy_read(bcm, 0x0814) | 0x0004);
-		bcm43xx_phy_write(bcm, 0x0815,
-				  bcm43xx_phy_read(bcm, 0x0815) &amp; 0xFFFB);
-		bcm43xx_phy_write(bcm, 0x0003,
-				  (bcm43xx_phy_read(bcm, 0x0003) &amp; 0xFF9F)
-				  | 0x0040);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x000F);
-		bcm43xx_set_all_gains(bcm, 3, 0, 1);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      (bcm43xx_radio_read16(bcm, 0x0043)
-				       &amp; 0x00F0) | 0x000F);
-		udelay(30);
-		v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) &gt;&gt; 8) &amp; 0x003F);
-		if (v47F &gt;= 0x20)
-			v47F -= 0x40;
-		if (v47F == -32) {
-			for (i = 0; i &lt; 4; i++) {
-				bcm43xx_radio_write16(bcm, 0x007B, i);
-				udelay(20);
-				v47F = (s16)((bcm43xx_phy_read(bcm, 0x047F) &gt;&gt; 8) &amp; 0x003F);
-				if (v47F &gt;= 0x20)
-					v47F -= 0x40;
-				if (v47F &gt; -31 &amp;&amp; saved == 0xFFFF)
-					saved = i;
-			}
-			if (saved == 0xFFFF)
-				saved = 3;
-		} else
-			saved = 0;
-	}
-	bcm43xx_radio_write16(bcm, 0x007B, saved);
-
-	if (phy-&gt;rev &gt;= 6) {
-		bcm43xx_phy_write(bcm, 0x002E, backup[12]);
-		bcm43xx_phy_write(bcm, 0x002F, backup[13]);
-		bcm43xx_phy_write(bcm, 0x080F, backup[14]);
-		bcm43xx_phy_write(bcm, 0x0810, backup[15]);
-	}
-	bcm43xx_phy_write(bcm, 0x0814, backup[3]);
-	bcm43xx_phy_write(bcm, 0x0815, backup[4]);
-	bcm43xx_phy_write(bcm, 0x005A, backup[5]);
-	bcm43xx_phy_write(bcm, 0x0059, backup[6]);
-	bcm43xx_phy_write(bcm, 0x0058, backup[7]);
-	bcm43xx_phy_write(bcm, 0x000A, backup[8]);
-	bcm43xx_phy_write(bcm, 0x0003, backup[9]);
-	bcm43xx_radio_write16(bcm, 0x0043, backup[11]);
-	bcm43xx_radio_write16(bcm, 0x007A, backup[10]);
-	bcm43xx_phy_write(bcm, 0x0802,
-			  bcm43xx_phy_read(bcm, 0x0802) | 0x1 | 0x2);
-	bcm43xx_phy_write(bcm, 0x0429,
-			  bcm43xx_phy_read(bcm, 0x0429) | 0x8000);
-	bcm43xx_set_original_gains(bcm);
-	if (phy-&gt;rev &gt;= 6) {
-		bcm43xx_phy_write(bcm, 0x0801, backup[16]);
-		bcm43xx_phy_write(bcm, 0x0060, backup[17]);
-		bcm43xx_phy_write(bcm, 0x0014, backup[18]);
-		bcm43xx_phy_write(bcm, 0x0478, backup[19]);
-	}
-	bcm43xx_phy_write(bcm, 0x0001, backup[0]);
-	bcm43xx_phy_write(bcm, 0x0812, backup[2]);
-	bcm43xx_phy_write(bcm, 0x0811, backup[1]);
-}
-
-void bcm43xx_calc_nrssi_slope(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 backup[18] = { 0 };
-	u16 tmp;
-	s16 nrssi0, nrssi1;
-
-	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_B:
-		backup[0] = bcm43xx_radio_read16(bcm, 0x007A);
-		backup[1] = bcm43xx_radio_read16(bcm, 0x0052);
-		backup[2] = bcm43xx_radio_read16(bcm, 0x0043);
-		backup[3] = bcm43xx_phy_read(bcm, 0x0030);
-		backup[4] = bcm43xx_phy_read(bcm, 0x0026);
-		backup[5] = bcm43xx_phy_read(bcm, 0x0015);
-		backup[6] = bcm43xx_phy_read(bcm, 0x002A);
-		backup[7] = bcm43xx_phy_read(bcm, 0x0020);
-		backup[8] = bcm43xx_phy_read(bcm, 0x005A);
-		backup[9] = bcm43xx_phy_read(bcm, 0x0059);
-		backup[10] = bcm43xx_phy_read(bcm, 0x0058);
-		backup[11] = bcm43xx_read16(bcm, 0x03E2);
-		backup[12] = bcm43xx_read16(bcm, 0x03E6);
-		backup[13] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
-
-		tmp  = bcm43xx_radio_read16(bcm, 0x007A);
-		tmp &amp;= (phy-&gt;rev &gt;= 5) ? 0x007F : 0x000F;
-		bcm43xx_radio_write16(bcm, 0x007A, tmp);
-		bcm43xx_phy_write(bcm, 0x0030, 0x00FF);
-		bcm43xx_write16(bcm, 0x03EC, 0x7F7F);
-		bcm43xx_phy_write(bcm, 0x0026, 0x0000);
-		bcm43xx_phy_write(bcm, 0x0015,
-				  bcm43xx_phy_read(bcm, 0x0015) | 0x0020);
-		bcm43xx_phy_write(bcm, 0x002A, 0x08A3);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x0080);
-
-		nrssi0 = (s16)bcm43xx_phy_read(bcm, 0x0027);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) &amp; 0x007F);
-		if (phy-&gt;analog &gt;= 2) {
-			bcm43xx_write16(bcm, 0x03E6, 0x0040);
-		} else if (phy-&gt;analog == 0) {
-			bcm43xx_write16(bcm, 0x03E6, 0x0122);
-		} else {
-			bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-					bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT) &amp; 0x2000);
-		}
-		bcm43xx_phy_write(bcm, 0x0020, 0x3F3F);
-		bcm43xx_phy_write(bcm, 0x0015, 0xF330);
-		bcm43xx_radio_write16(bcm, 0x005A, 0x0060);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      bcm43xx_radio_read16(bcm, 0x0043) &amp; 0x00F0);
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0x0810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-		udelay(20);
-
-		nrssi1 = (s16)bcm43xx_phy_read(bcm, 0x0027);
-		bcm43xx_phy_write(bcm, 0x0030, backup[3]);
-		bcm43xx_radio_write16(bcm, 0x007A, backup[0]);
-		bcm43xx_write16(bcm, 0x03E2, backup[11]);
-		bcm43xx_phy_write(bcm, 0x0026, backup[4]);
-		bcm43xx_phy_write(bcm, 0x0015, backup[5]);
-		bcm43xx_phy_write(bcm, 0x002A, backup[6]);
-		bcm43xx_synth_pu_workaround(bcm, radio-&gt;channel);
-		if (phy-&gt;analog != 0)
-			bcm43xx_write16(bcm, 0x03F4, backup[13]);
-
-		bcm43xx_phy_write(bcm, 0x0020, backup[7]);
-		bcm43xx_phy_write(bcm, 0x005A, backup[8]);
-		bcm43xx_phy_write(bcm, 0x0059, backup[9]);
-		bcm43xx_phy_write(bcm, 0x0058, backup[10]);
-		bcm43xx_radio_write16(bcm, 0x0052, backup[1]);
-		bcm43xx_radio_write16(bcm, 0x0043, backup[2]);
-
-		if (nrssi0 == nrssi1)
-			radio-&gt;nrssislope = 0x00010000;
-		else 
-			radio-&gt;nrssislope = 0x00400000 / (nrssi0 - nrssi1);
-
-		if (nrssi0 &lt;= -4) {
-			radio-&gt;nrssi[0] = nrssi0;
-			radio-&gt;nrssi[1] = nrssi1;
-		}
-		break;
-	case BCM43xx_PHYTYPE_G:
-		if (radio-&gt;revision &gt;= 9)
-			return;
-		if (radio-&gt;revision == 8)
-			bcm43xx_calc_nrssi_offset(bcm);
-
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) &amp; 0x7FFF);
-		bcm43xx_phy_write(bcm, 0x0802,
-				  bcm43xx_phy_read(bcm, 0x0802) &amp; 0xFFFC);
-		backup[7] = bcm43xx_read16(bcm, 0x03E2);
-		bcm43xx_write16(bcm, 0x03E2,
-				bcm43xx_read16(bcm, 0x03E2) | 0x8000);
-		backup[0] = bcm43xx_radio_read16(bcm, 0x007A);
-		backup[1] = bcm43xx_radio_read16(bcm, 0x0052);
-		backup[2] = bcm43xx_radio_read16(bcm, 0x0043);
-		backup[3] = bcm43xx_phy_read(bcm, 0x0015);
-		backup[4] = bcm43xx_phy_read(bcm, 0x005A);
-		backup[5] = bcm43xx_phy_read(bcm, 0x0059);
-		backup[6] = bcm43xx_phy_read(bcm, 0x0058);
-		backup[8] = bcm43xx_read16(bcm, 0x03E6);
-		backup[9] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
-		if (phy-&gt;rev &gt;= 3) {
-			backup[10] = bcm43xx_phy_read(bcm, 0x002E);
-			backup[11] = bcm43xx_phy_read(bcm, 0x002F);
-			backup[12] = bcm43xx_phy_read(bcm, 0x080F);
-			backup[13] = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_LO_CONTROL);
-			backup[14] = bcm43xx_phy_read(bcm, 0x0801);
-			backup[15] = bcm43xx_phy_read(bcm, 0x0060);
-			backup[16] = bcm43xx_phy_read(bcm, 0x0014);
-			backup[17] = bcm43xx_phy_read(bcm, 0x0478);
-			bcm43xx_phy_write(bcm, 0x002E, 0);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_LO_CONTROL, 0);
-			switch (phy-&gt;rev) {
-			case 4: case 6: case 7:
-				bcm43xx_phy_write(bcm, 0x0478,
-						  bcm43xx_phy_read(bcm, 0x0478)
-						  | 0x0100);
-				bcm43xx_phy_write(bcm, 0x0801,
-						  bcm43xx_phy_read(bcm, 0x0801)
-						  | 0x0040);
-				break;
-			case 3: case 5:
-				bcm43xx_phy_write(bcm, 0x0801,
-						  bcm43xx_phy_read(bcm, 0x0801)
-						  &amp; 0xFFBF);
-				break;
-			}
-			bcm43xx_phy_write(bcm, 0x0060,
-					  bcm43xx_phy_read(bcm, 0x0060)
-					  | 0x0040);
-			bcm43xx_phy_write(bcm, 0x0014,
-					  bcm43xx_phy_read(bcm, 0x0014)
-					  | 0x0200);
-		}
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x0070);
-		bcm43xx_set_all_gains(bcm, 0, 8, 0);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) &amp; 0x00F7);
-		if (phy-&gt;rev &gt;= 2) {
-			bcm43xx_phy_write(bcm, 0x0811,
-					  (bcm43xx_phy_read(bcm, 0x0811) &amp; 0xFFCF) | 0x0030);
-			bcm43xx_phy_write(bcm, 0x0812,
-					  (bcm43xx_phy_read(bcm, 0x0812) &amp; 0xFFCF) | 0x0010);
-		}
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x0080);
-		udelay(20);
-
-		nrssi0 = (s16)((bcm43xx_phy_read(bcm, 0x047F) &gt;&gt; 8) &amp; 0x003F);
-		if (nrssi0 &gt;= 0x0020)
-			nrssi0 -= 0x0040;
-
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) &amp; 0x007F);
-		if (phy-&gt;analog &gt;= 2) {
-			bcm43xx_phy_write(bcm, 0x0003,
-					  (bcm43xx_phy_read(bcm, 0x0003)
-					   &amp; 0xFF9F) | 0x0040);
-		}
-
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-				bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
-				| 0x2000);
-		bcm43xx_radio_write16(bcm, 0x007A,
-				      bcm43xx_radio_read16(bcm, 0x007A) | 0x000F);
-		bcm43xx_phy_write(bcm, 0x0015, 0xF330);
-		if (phy-&gt;rev &gt;= 2) {
-			bcm43xx_phy_write(bcm, 0x0812,
-					  (bcm43xx_phy_read(bcm, 0x0812) &amp; 0xFFCF) | 0x0020);
-			bcm43xx_phy_write(bcm, 0x0811,
-					  (bcm43xx_phy_read(bcm, 0x0811) &amp; 0xFFCF) | 0x0020);
-		}
-
-		bcm43xx_set_all_gains(bcm, 3, 0, 1);
-		if (radio-&gt;revision == 8) {
-			bcm43xx_radio_write16(bcm, 0x0043, 0x001F);
-		} else {
-			tmp = bcm43xx_radio_read16(bcm, 0x0052) &amp; 0xFF0F;
-			bcm43xx_radio_write16(bcm, 0x0052, tmp | 0x0060);
-			tmp = bcm43xx_radio_read16(bcm, 0x0043) &amp; 0xFFF0;
-			bcm43xx_radio_write16(bcm, 0x0043, tmp | 0x0009);
-		}
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0x0810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-		udelay(20);
-		nrssi1 = (s16)((bcm43xx_phy_read(bcm, 0x047F) &gt;&gt; 8) &amp; 0x003F);
-		if (nrssi1 &gt;= 0x0020)
-			nrssi1 -= 0x0040;
-		if (nrssi0 == nrssi1)
-			radio-&gt;nrssislope = 0x00010000;
-		else
-			radio-&gt;nrssislope = 0x00400000 / (nrssi0 - nrssi1);
-		if (nrssi0 &gt;= -4) {
-			radio-&gt;nrssi[0] = nrssi1;
-			radio-&gt;nrssi[1] = nrssi0;
-		}
-		if (phy-&gt;rev &gt;= 3) {
-			bcm43xx_phy_write(bcm, 0x002E, backup[10]);
-			bcm43xx_phy_write(bcm, 0x002F, backup[11]);
-			bcm43xx_phy_write(bcm, 0x080F, backup[12]);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_LO_CONTROL, backup[13]);
-		}
-		if (phy-&gt;rev &gt;= 2) {
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_phy_read(bcm, 0x0812) &amp; 0xFFCF);
-			bcm43xx_phy_write(bcm, 0x0811,
-					  bcm43xx_phy_read(bcm, 0x0811) &amp; 0xFFCF);
-		}
-
-		bcm43xx_radio_write16(bcm, 0x007A, backup[0]);
-		bcm43xx_radio_write16(bcm, 0x0052, backup[1]);
-		bcm43xx_radio_write16(bcm, 0x0043, backup[2]);
-		bcm43xx_write16(bcm, 0x03E2, backup[7]);
-		bcm43xx_write16(bcm, 0x03E6, backup[8]);
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, backup[9]);
-		bcm43xx_phy_write(bcm, 0x0015, backup[3]);
-		bcm43xx_phy_write(bcm, 0x005A, backup[4]);
-		bcm43xx_phy_write(bcm, 0x0059, backup[5]);
-		bcm43xx_phy_write(bcm, 0x0058, backup[6]);
-		bcm43xx_synth_pu_workaround(bcm, radio-&gt;channel);
-		bcm43xx_phy_write(bcm, 0x0802,
-				  bcm43xx_phy_read(bcm, 0x0802) | (0x0001 | 0x0002));
-		bcm43xx_set_original_gains(bcm);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x8000);
-		if (phy-&gt;rev &gt;= 3) {
-			bcm43xx_phy_write(bcm, 0x0801, backup[14]);
-			bcm43xx_phy_write(bcm, 0x0060, backup[15]);
-			bcm43xx_phy_write(bcm, 0x0014, backup[16]);
-			bcm43xx_phy_write(bcm, 0x0478, backup[17]);
-		}
-		bcm43xx_nrssi_mem_update(bcm);
-		bcm43xx_calc_nrssi_threshold(bcm);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-void bcm43xx_calc_nrssi_threshold(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	s32 threshold;
-	s32 a, b;
-	s16 tmp16;
-	u16 tmp_u16;
-
-	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_B: {
-		if (radio-&gt;version != 0x2050)
-			return;
-		if (!(bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_RSSI))
-			return;
-
-		if (radio-&gt;revision &gt;= 6) {
-			threshold = (radio-&gt;nrssi[1] - radio-&gt;nrssi[0]) * 32;
-			threshold += 20 * (radio-&gt;nrssi[0] + 1);
-			threshold /= 40;
-		} else
-			threshold = radio-&gt;nrssi[1] - 5;
-
-		threshold = limit_value(threshold, 0, 0x3E);
-		bcm43xx_phy_read(bcm, 0x0020); /* dummy read */
-		bcm43xx_phy_write(bcm, 0x0020, (((u16)threshold) &lt;&lt; 8) | 0x001C);
-
-		if (radio-&gt;revision &gt;= 6) {
-			bcm43xx_phy_write(bcm, 0x0087, 0x0E0D);
-			bcm43xx_phy_write(bcm, 0x0086, 0x0C0B);
-			bcm43xx_phy_write(bcm, 0x0085, 0x0A09);
-			bcm43xx_phy_write(bcm, 0x0084, 0x0808);
-			bcm43xx_phy_write(bcm, 0x0083, 0x0808);
-			bcm43xx_phy_write(bcm, 0x0082, 0x0604);
-			bcm43xx_phy_write(bcm, 0x0081, 0x0302);
-			bcm43xx_phy_write(bcm, 0x0080, 0x0100);
-		}
-		break;
-	}
-	case BCM43xx_PHYTYPE_G:
-		if (!phy-&gt;connected ||
-		    !(bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_RSSI)) {
-			tmp16 = bcm43xx_nrssi_hw_read(bcm, 0x20);
-			if (tmp16 &gt;= 0x20)
-				tmp16 -= 0x40;
-			if (tmp16 &lt; 3) {
-				bcm43xx_phy_write(bcm, 0x048A,
-						  (bcm43xx_phy_read(bcm, 0x048A)
-						   &amp; 0xF000) | 0x09EB);
-			} else {
-				bcm43xx_phy_write(bcm, 0x048A,
-						  (bcm43xx_phy_read(bcm, 0x048A)
-						   &amp; 0xF000) | 0x0AED);
-			}
-		} else {
-			if (radio-&gt;interfmode == BCM43xx_RADIO_INTERFMODE_NONWLAN) {
-				a = 0xE;
-				b = 0xA;
-			} else if (!radio-&gt;aci_wlan_automatic &amp;&amp; radio-&gt;aci_enable) {
-				a = 0x13;
-				b = 0x12;
-			} else {
-				a = 0xE;
-				b = 0x11;
-			}
-
-			a = a * (radio-&gt;nrssi[1] - radio-&gt;nrssi[0]);
-			a += (radio-&gt;nrssi[0] &lt;&lt; 6);
-			if (a &lt; 32)
-				a += 31;
-			else
-				a += 32;
-			a = a &gt;&gt; 6;
-			a = limit_value(a, -31, 31);
-
-			b = b * (radio-&gt;nrssi[1] - radio-&gt;nrssi[0]);
-			b += (radio-&gt;nrssi[0] &lt;&lt; 6);
-			if (b &lt; 32)
-				b += 31;
-			else
-				b += 32;
-			b = b &gt;&gt; 6;
-			b = limit_value(b, -31, 31);
-
-			tmp_u16 = bcm43xx_phy_read(bcm, 0x048A) &amp; 0xF000;
-			tmp_u16 |= ((u32)b &amp; 0x0000003F);
-			tmp_u16 |= (((u32)a &amp; 0x0000003F) &lt;&lt; 6);
-			bcm43xx_phy_write(bcm, 0x048A, tmp_u16);
-		}
-		break;
-	default:
-		assert(0);
-	}
-}
-
-/* Stack implementation to save/restore values from the
- * interference mitigation code.
- * It is save to restore values in random order.
- */
-static void _stack_save(u32 *_stackptr, size_t *stackidx,
-			u8 id, u16 offset, u16 value)
-{
-	u32 *stackptr = &amp;(_stackptr[*stackidx]);
-
-	assert((offset &amp; 0xE000) == 0x0000);
-	assert((id &amp; 0xF8) == 0x00);
-	*stackptr = offset;
-	*stackptr |= ((u32)id) &lt;&lt; 13;
-	*stackptr |= ((u32)value) &lt;&lt; 16;
-	(*stackidx)++;
-	assert(*stackidx &lt; BCM43xx_INTERFSTACK_SIZE);
-}
-
-static u16 _stack_restore(u32 *stackptr,
-			  u8 id, u16 offset)
-{
-	size_t i;
-
-	assert((offset &amp; 0xE000) == 0x0000);
-	assert((id &amp; 0xF8) == 0x00);
-	for (i = 0; i &lt; BCM43xx_INTERFSTACK_SIZE; i++, stackptr++) {
-		if ((*stackptr &amp; 0x00001FFF) != offset)
-			continue;
-		if (((*stackptr &amp; 0x00007000) &gt;&gt; 13) != id)
-			continue;
-		return ((*stackptr &amp; 0xFFFF0000) &gt;&gt; 16);
-	}
-	assert(0);
-
-	return 0;
-}
-
-#define phy_stacksave(offset)					\
-	do {							\
-		_stack_save(stack, &amp;stackidx, 0x1, (offset),	\
-			    bcm43xx_phy_read(bcm, (offset)));	\
-	} while (0)
-#define phy_stackrestore(offset)				\
-	do {							\
-		bcm43xx_phy_write(bcm, (offset),		\
-				  _stack_restore(stack, 0x1,	\
-					  	 (offset)));	\
-	} while (0)
-#define radio_stacksave(offset)						\
-	do {								\
-		_stack_save(stack, &amp;stackidx, 0x2, (offset),		\
-			    bcm43xx_radio_read16(bcm, (offset)));	\
-	} while (0)
-#define radio_stackrestore(offset)					\
-	do {								\
-		bcm43xx_radio_write16(bcm, (offset),			\
-				      _stack_restore(stack, 0x2,	\
-						     (offset)));	\
-	} while (0)
-#define ilt_stacksave(offset)					\
-	do {							\
-		_stack_save(stack, &amp;stackidx, 0x3, (offset),	\
-			    bcm43xx_ilt_read(bcm, (offset)));	\
-	} while (0)
-#define ilt_stackrestore(offset)				\
-	do {							\
-		bcm43xx_ilt_write(bcm, (offset),		\
-				  _stack_restore(stack, 0x3,	\
-						 (offset)));	\
-	} while (0)
-
-static void
-bcm43xx_radio_interference_mitigation_enable(struct bcm43xx_private *bcm,
-					     int mode)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 tmp, flipped;
-	u32 tmp32;
-	size_t stackidx = 0;
-	u32 *stack = radio-&gt;interfstack;
-
-	switch (mode) {
-	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
-		if (phy-&gt;rev != 1) {
-			bcm43xx_phy_write(bcm, 0x042B,
-			                  bcm43xx_phy_read(bcm, 0x042B) | 0x0800);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-			                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) &amp; ~0x4000);
-			break;
-		}
-		radio_stacksave(0x0078);
-		tmp = (bcm43xx_radio_read16(bcm, 0x0078) &amp; 0x001E);
-		flipped = flip_4bit(tmp);
-		if (flipped &lt; 10 &amp;&amp; flipped &gt;= 8)
-			flipped = 7;
-		else if (flipped &gt;= 10)
-			flipped -= 3;
-		flipped = flip_4bit(flipped);
-		flipped = (flipped &lt;&lt; 1) | 0x0020;
-		bcm43xx_radio_write16(bcm, 0x0078, flipped);
-
-		bcm43xx_calc_nrssi_threshold(bcm);
-
-		phy_stacksave(0x0406);
-		bcm43xx_phy_write(bcm, 0x0406, 0x7E28);
-
-		bcm43xx_phy_write(bcm, 0x042B,
-		                  bcm43xx_phy_read(bcm, 0x042B) | 0x0800);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-		                  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD) | 0x1000);
-
-		phy_stacksave(0x04A0);
-		bcm43xx_phy_write(bcm, 0x04A0,
-		                  (bcm43xx_phy_read(bcm, 0x04A0) &amp; 0xC0C0) | 0x0008);
-		phy_stacksave(0x04A1);
-		bcm43xx_phy_write(bcm, 0x04A1,
-				  (bcm43xx_phy_read(bcm, 0x04A1) &amp; 0xC0C0) | 0x0605);
-		phy_stacksave(0x04A2);
-		bcm43xx_phy_write(bcm, 0x04A2,
-				  (bcm43xx_phy_read(bcm, 0x04A2) &amp; 0xC0C0) | 0x0204);
-		phy_stacksave(0x04A8);
-		bcm43xx_phy_write(bcm, 0x04A8,
-				  (bcm43xx_phy_read(bcm, 0x04A8) &amp; 0xC0C0) | 0x0803);
-		phy_stacksave(0x04AB);
-		bcm43xx_phy_write(bcm, 0x04AB,
-				  (bcm43xx_phy_read(bcm, 0x04AB) &amp; 0xC0C0) | 0x0605);
-
-		phy_stacksave(0x04A7);
-		bcm43xx_phy_write(bcm, 0x04A7, 0x0002);
-		phy_stacksave(0x04A3);
-		bcm43xx_phy_write(bcm, 0x04A3, 0x287A);
-		phy_stacksave(0x04A9);
-		bcm43xx_phy_write(bcm, 0x04A9, 0x2027);
-		phy_stacksave(0x0493);
-		bcm43xx_phy_write(bcm, 0x0493, 0x32F5);
-		phy_stacksave(0x04AA);
-		bcm43xx_phy_write(bcm, 0x04AA, 0x2027);
-		phy_stacksave(0x04AC);
-		bcm43xx_phy_write(bcm, 0x04AC, 0x32F5);
-		break;
-	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		if (bcm43xx_phy_read(bcm, 0x0033) &amp; 0x0800)
-			break;
-
-		radio-&gt;aci_enable = 1;
-
-		phy_stacksave(BCM43xx_PHY_RADIO_BITFIELD);
-		phy_stacksave(BCM43xx_PHY_G_CRS);
-		if (phy-&gt;rev &lt; 2) {
-			phy_stacksave(0x0406);
-		} else {
-			phy_stacksave(0x04C0);
-			phy_stacksave(0x04C1);
-		}
-		phy_stacksave(0x0033);
-		phy_stacksave(0x04A7);
-		phy_stacksave(0x04A3);
-		phy_stacksave(0x04A9);
-		phy_stacksave(0x04AA);
-		phy_stacksave(0x04AC);
-		phy_stacksave(0x0493);
-		phy_stacksave(0x04A1);
-		phy_stacksave(0x04A0);
-		phy_stacksave(0x04A2);
-		phy_stacksave(0x048A);
-		phy_stacksave(0x04A8);
-		phy_stacksave(0x04AB);
-		if (phy-&gt;rev == 2) {
-			phy_stacksave(0x04AD);
-			phy_stacksave(0x04AE);
-		} else if (phy-&gt;rev &gt;= 3) {
-			phy_stacksave(0x04AD);
-			phy_stacksave(0x0415);
-			phy_stacksave(0x0416);
-			phy_stacksave(0x0417);
-			ilt_stacksave(0x1A00 + 0x2);
-			ilt_stacksave(0x1A00 + 0x3);
-		}
-		phy_stacksave(0x042B);
-		phy_stacksave(0x048C);
-
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD)
-				  &amp; ~0x1000);
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  (bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS)
-				   &amp; 0xFFFC) | 0x0002);
-
-		bcm43xx_phy_write(bcm, 0x0033, 0x0800);
-		bcm43xx_phy_write(bcm, 0x04A3, 0x2027);
-		bcm43xx_phy_write(bcm, 0x04A9, 0x1CA8);
-		bcm43xx_phy_write(bcm, 0x0493, 0x287A);
-		bcm43xx_phy_write(bcm, 0x04AA, 0x1CA8);
-		bcm43xx_phy_write(bcm, 0x04AC, 0x287A);
-
-		bcm43xx_phy_write(bcm, 0x04A0,
-				  (bcm43xx_phy_read(bcm, 0x04A0)
-				   &amp; 0xFFC0) | 0x001A);
-		bcm43xx_phy_write(bcm, 0x04A7, 0x000D);
-
-		if (phy-&gt;rev &lt; 2) {
-			bcm43xx_phy_write(bcm, 0x0406, 0xFF0D);
-		} else if (phy-&gt;rev == 2) {
-			bcm43xx_phy_write(bcm, 0x04C0, 0xFFFF);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x00A9);
-		} else {
-			bcm43xx_phy_write(bcm, 0x04C0, 0x00C1);
-			bcm43xx_phy_write(bcm, 0x04C1, 0x0059);
-		}
-
-		bcm43xx_phy_write(bcm, 0x04A1,
-		                  (bcm43xx_phy_read(bcm, 0x04A1)
-				   &amp; 0xC0FF) | 0x1800);
-		bcm43xx_phy_write(bcm, 0x04A1,
-		                  (bcm43xx_phy_read(bcm, 0x04A1)
-				   &amp; 0xFFC0) | 0x0015);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   &amp; 0xCFFF) | 0x1000);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   &amp; 0xF0FF) | 0x0A00);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   &amp; 0xCFFF) | 0x1000);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   &amp; 0xF0FF) | 0x0800);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   &amp; 0xFFCF) | 0x0010);
-		bcm43xx_phy_write(bcm, 0x04AB,
-		                  (bcm43xx_phy_read(bcm, 0x04AB)
-				   &amp; 0xFFF0) | 0x0005);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   &amp; 0xFFCF) | 0x0010);
-		bcm43xx_phy_write(bcm, 0x04A8,
-		                  (bcm43xx_phy_read(bcm, 0x04A8)
-				   &amp; 0xFFF0) | 0x0006);
-		bcm43xx_phy_write(bcm, 0x04A2,
-		                  (bcm43xx_phy_read(bcm, 0x04A2)
-				   &amp; 0xF0FF) | 0x0800);
-		bcm43xx_phy_write(bcm, 0x04A0,
-				  (bcm43xx_phy_read(bcm, 0x04A0)
-				   &amp; 0xF0FF) | 0x0500);
-		bcm43xx_phy_write(bcm, 0x04A2,
-				  (bcm43xx_phy_read(bcm, 0x04A2)
-				   &amp; 0xFFF0) | 0x000B);
-
-		if (phy-&gt;rev &gt;= 3) {
-			bcm43xx_phy_write(bcm, 0x048A,
-					  bcm43xx_phy_read(bcm, 0x048A)
-					  &amp; ~0x8000);
-			bcm43xx_phy_write(bcm, 0x0415,
-					  (bcm43xx_phy_read(bcm, 0x0415)
-					   &amp; 0x8000) | 0x36D8);
-			bcm43xx_phy_write(bcm, 0x0416,
-					  (bcm43xx_phy_read(bcm, 0x0416)
-					   &amp; 0x8000) | 0x36D8);
-			bcm43xx_phy_write(bcm, 0x0417,
-					  (bcm43xx_phy_read(bcm, 0x0417)
-					   &amp; 0xFE00) | 0x016D);
-		} else {
-			bcm43xx_phy_write(bcm, 0x048A,
-					  bcm43xx_phy_read(bcm, 0x048A)
-					  | 0x1000);
-			bcm43xx_phy_write(bcm, 0x048A,
-					  (bcm43xx_phy_read(bcm, 0x048A)
-					   &amp; 0x9FFF) | 0x2000);
-			tmp32 = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-						   BCM43xx_UCODEFLAGS_OFFSET);
-			if (!(tmp32 &amp; 0x800)) {
-				tmp32 |= 0x800;
-				bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-						    BCM43xx_UCODEFLAGS_OFFSET,
-						    tmp32);
-			}
-		}
-		if (phy-&gt;rev &gt;= 2) {
-			bcm43xx_phy_write(bcm, 0x042B,
-					  bcm43xx_phy_read(bcm, 0x042B)
-					  | 0x0800);
-		}
-		bcm43xx_phy_write(bcm, 0x048C,
-				  (bcm43xx_phy_read(bcm, 0x048C)
-				   &amp; 0xF0FF) | 0x0200);
-		if (phy-&gt;rev == 2) {
-			bcm43xx_phy_write(bcm, 0x04AE,
-					  (bcm43xx_phy_read(bcm, 0x04AE)
-					   &amp; 0xFF00) | 0x007F);
-			bcm43xx_phy_write(bcm, 0x04AD,
-					  (bcm43xx_phy_read(bcm, 0x04AD)
-					   &amp; 0x00FF) | 0x1300);
-		} else if (phy-&gt;rev &gt;= 6) {
-			bcm43xx_ilt_write(bcm, 0x1A00 + 0x3, 0x007F);
-			bcm43xx_ilt_write(bcm, 0x1A00 + 0x2, 0x007F);
-			bcm43xx_phy_write(bcm, 0x04AD,
-					  bcm43xx_phy_read(bcm, 0x04AD)
-					  &amp; 0x00FF);
-		}
-		bcm43xx_calc_nrssi_slope(bcm);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-static void
-bcm43xx_radio_interference_mitigation_disable(struct bcm43xx_private *bcm,
-					      int mode)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u32 tmp32;
-	u32 *stack = radio-&gt;interfstack;
-
-	switch (mode) {
-	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
-		if (phy-&gt;rev != 1) {
-			bcm43xx_phy_write(bcm, 0x042B,
-			                  bcm43xx_phy_read(bcm, 0x042B) &amp; ~0x0800);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-			                  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x4000);
-			break;
-		}
-		phy_stackrestore(0x0078);
-		bcm43xx_calc_nrssi_threshold(bcm);
-		phy_stackrestore(0x0406);
-		bcm43xx_phy_write(bcm, 0x042B,
-				  bcm43xx_phy_read(bcm, 0x042B) &amp; ~0x0800);
-		if (!bcm-&gt;bad_frames_preempt) {
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_RADIO_BITFIELD,
-					  bcm43xx_phy_read(bcm, BCM43xx_PHY_RADIO_BITFIELD)
-					  &amp; ~(1 &lt;&lt; 11));
-		}
-		bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-				  bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS) | 0x4000);
-		phy_stackrestore(0x04A0);
-		phy_stackrestore(0x04A1);
-		phy_stackrestore(0x04A2);
-		phy_stackrestore(0x04A8);
-		phy_stackrestore(0x04AB);
-		phy_stackrestore(0x04A7);
-		phy_stackrestore(0x04A3);
-		phy_stackrestore(0x04A9);
-		phy_stackrestore(0x0493);
-		phy_stackrestore(0x04AA);
-		phy_stackrestore(0x04AC);
-		break;
-	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		if (!(bcm43xx_phy_read(bcm, 0x0033) &amp; 0x0800))
-			break;
-
-		radio-&gt;aci_enable = 0;
-
-		phy_stackrestore(BCM43xx_PHY_RADIO_BITFIELD);
-		phy_stackrestore(BCM43xx_PHY_G_CRS);
-		phy_stackrestore(0x0033);
-		phy_stackrestore(0x04A3);
-		phy_stackrestore(0x04A9);
-		phy_stackrestore(0x0493);
-		phy_stackrestore(0x04AA);
-		phy_stackrestore(0x04AC);
-		phy_stackrestore(0x04A0);
-		phy_stackrestore(0x04A7);
-		if (phy-&gt;rev &gt;= 2) {
-			phy_stackrestore(0x04C0);
-			phy_stackrestore(0x04C1);
-		} else
-			phy_stackrestore(0x0406);
-		phy_stackrestore(0x04A1);
-		phy_stackrestore(0x04AB);
-		phy_stackrestore(0x04A8);
-		if (phy-&gt;rev == 2) {
-			phy_stackrestore(0x04AD);
-			phy_stackrestore(0x04AE);
-		} else if (phy-&gt;rev &gt;= 3) {
-			phy_stackrestore(0x04AD);
-			phy_stackrestore(0x0415);
-			phy_stackrestore(0x0416);
-			phy_stackrestore(0x0417);
-			ilt_stackrestore(0x1A00 + 0x2);
-			ilt_stackrestore(0x1A00 + 0x3);
-		}
-		phy_stackrestore(0x04A2);
-		phy_stackrestore(0x04A8);
-		phy_stackrestore(0x042B);
-		phy_stackrestore(0x048C);
-		tmp32 = bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-					   BCM43xx_UCODEFLAGS_OFFSET);
-		if (tmp32 &amp; 0x800) {
-			tmp32 &amp;= ~0x800;
-			bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-					    BCM43xx_UCODEFLAGS_OFFSET,
-					    tmp32);
-		}
-		bcm43xx_calc_nrssi_slope(bcm);
-		break;
-	default:
-		assert(0);
-	}
-}
-
-#undef phy_stacksave
-#undef phy_stackrestore
-#undef radio_stacksave
-#undef radio_stackrestore
-#undef ilt_stacksave
-#undef ilt_stackrestore
-
-int bcm43xx_radio_set_interference_mitigation(struct bcm43xx_private *bcm,
-					      int mode)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	int currentmode;
-
-	if ((phy-&gt;type != BCM43xx_PHYTYPE_G) ||
-	    (phy-&gt;rev == 0) ||
-	    (!phy-&gt;connected))
-		return -ENODEV;
-
-	radio-&gt;aci_wlan_automatic = 0;
-	switch (mode) {
-	case BCM43xx_RADIO_INTERFMODE_AUTOWLAN:
-		radio-&gt;aci_wlan_automatic = 1;
-		if (radio-&gt;aci_enable)
-			mode = BCM43xx_RADIO_INTERFMODE_MANUALWLAN;
-		else
-			mode = BCM43xx_RADIO_INTERFMODE_NONE;
-		break;
-	case BCM43xx_RADIO_INTERFMODE_NONE:
-	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
-	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	currentmode = radio-&gt;interfmode;
-	if (currentmode == mode)
-		return 0;
-	if (currentmode != BCM43xx_RADIO_INTERFMODE_NONE)
-		bcm43xx_radio_interference_mitigation_disable(bcm, currentmode);
-
-	if (mode == BCM43xx_RADIO_INTERFMODE_NONE) {
-		radio-&gt;aci_enable = 0;
-		radio-&gt;aci_hw_rssi = 0;
-	} else
-		bcm43xx_radio_interference_mitigation_enable(bcm, mode);
-	radio-&gt;interfmode = mode;
-
-	return 0;
-}
-
-u16 bcm43xx_radio_calibrationvalue(struct bcm43xx_private *bcm)
-{
-	u16 reg, index, ret;
-
-	reg = bcm43xx_radio_read16(bcm, 0x0060);
-	index = (reg &amp; 0x001E) &gt;&gt; 1;
-	ret = rcc_table[index] &lt;&lt; 1;
-	ret |= (reg &amp; 0x0001);
-	ret |= 0x0020;
-
-	return ret;
-}
-
-#define LPD(L, P, D)    (((L) &lt;&lt; 2) | ((P) &lt;&lt; 1) | ((D) &lt;&lt; 0))
-static u16 bcm43xx_get_812_value(struct bcm43xx_private *bcm, u8 lpd)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 loop_or = 0;
-	u16 adj_loopback_gain = phy-&gt;loopback_gain[0];
-	u8 loop;
-	u16 extern_lna_control;
-
-	if (!phy-&gt;connected)
-		return 0;
-	if (!has_loopback_gain(phy)) {
-		if (phy-&gt;rev &lt; 7 || !(bcm-&gt;sprom.boardflags
-		    &amp; BCM43xx_BFL_EXTLNA)) {
-			switch (lpd) {
-			case LPD(0, 1, 1):
-				return 0x0FB2;
-			case LPD(0, 0, 1):
-				return 0x00B2;
-			case LPD(1, 0, 1):
-				return 0x30B2;
-			case LPD(1, 0, 0):
-				return 0x30B3;
-			default:
-				assert(0);
-			}
-		} else {
-			switch (lpd) {
-			case LPD(0, 1, 1):
-				return 0x8FB2;
-			case LPD(0, 0, 1):
-				return 0x80B2;
-			case LPD(1, 0, 1):
-				return 0x20B2;
-			case LPD(1, 0, 0):
-				return 0x20B3;
-			default:
-				assert(0);
-			}
-		}
-	} else {
-		if (radio-&gt;revision == 8)
-			adj_loopback_gain += 0x003E;
-		else
-			adj_loopback_gain += 0x0026;
-		if (adj_loopback_gain &gt;= 0x46) {
-			adj_loopback_gain -= 0x46;
-			extern_lna_control = 0x3000;
-		} else if (adj_loopback_gain &gt;= 0x3A) {
-			adj_loopback_gain -= 0x3A;
-			extern_lna_control = 0x2000;
-		} else if (adj_loopback_gain &gt;= 0x2E) {
-			adj_loopback_gain -= 0x2E;
-			extern_lna_control = 0x1000;
-		} else {
-			adj_loopback_gain -= 0x10;
-			extern_lna_control = 0x0000;
-		}
-		for (loop = 0; loop &lt; 16; loop++) {
-			u16 tmp = adj_loopback_gain - 6 * loop;
-			if (tmp &lt; 6)
-				break;
-		}
-
-		loop_or = (loop &lt;&lt; 8) | extern_lna_control;
-		if (phy-&gt;rev &gt;= 7 &amp;&amp; bcm-&gt;sprom.boardflags
-		    &amp; BCM43xx_BFL_EXTLNA) {
-			if (extern_lna_control)
-				loop_or |= 0x8000;
-			switch (lpd) {
-			case LPD(0, 1, 1):
-				return 0x8F92;
-			case LPD(0, 0, 1):
-				return (0x8092 | loop_or);
-			case LPD(1, 0, 1):
-				return (0x2092 | loop_or);
-			case LPD(1, 0, 0):
-				return (0x2093 | loop_or);
-			default:
-				assert(0);
-			}
-		} else {
-			switch (lpd) {
-			case LPD(0, 1, 1):
-				return 0x0F92;
-			case LPD(0, 0, 1):
-			case LPD(1, 0, 1):
-				return (0x0092 | loop_or);
-			case LPD(1, 0, 0):
-				return (0x0093 | loop_or);
-			default:
-				assert(0);
-			}
-		}
-	}
-	return 0;
-}
-
-u16 bcm43xx_radio_init2050(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 backup[21] = { 0 };
-	u16 ret;
-	u16 i, j;
-	u32 tmp1 = 0, tmp2 = 0;
-
-	backup[0] = bcm43xx_radio_read16(bcm, 0x0043);
-	backup[14] = bcm43xx_radio_read16(bcm, 0x0051);
-	backup[15] = bcm43xx_radio_read16(bcm, 0x0052);
-	backup[1] = bcm43xx_phy_read(bcm, 0x0015);
-	backup[16] = bcm43xx_phy_read(bcm, 0x005A);
-	backup[17] = bcm43xx_phy_read(bcm, 0x0059);
-	backup[18] = bcm43xx_phy_read(bcm, 0x0058);
-	if (phy-&gt;type == BCM43xx_PHYTYPE_B) {
-		backup[2] = bcm43xx_phy_read(bcm, 0x0030);
-		backup[3] = bcm43xx_read16(bcm, 0x03EC);
-		bcm43xx_phy_write(bcm, 0x0030, 0x00FF);
-		bcm43xx_write16(bcm, 0x03EC, 0x3F3F);
-	} else {
-		if (phy-&gt;connected) {
-			backup[4] = bcm43xx_phy_read(bcm, 0x0811);
-			backup[5] = bcm43xx_phy_read(bcm, 0x0812);
-			backup[6] = bcm43xx_phy_read(bcm, 0x0814);
-			backup[7] = bcm43xx_phy_read(bcm, 0x0815);
-			backup[8] = bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS);
-			backup[9] = bcm43xx_phy_read(bcm, 0x0802);
-			bcm43xx_phy_write(bcm, 0x0814,
-			                  (bcm43xx_phy_read(bcm, 0x0814)
-					  | 0x0003));
-			bcm43xx_phy_write(bcm, 0x0815,
-			                  (bcm43xx_phy_read(bcm, 0x0815)
-					  &amp; 0xFFFC));
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS,
-			                  (bcm43xx_phy_read(bcm, BCM43xx_PHY_G_CRS)
-					  &amp; 0x7FFF));
-			bcm43xx_phy_write(bcm, 0x0802,
-			                  (bcm43xx_phy_read(bcm, 0x0802) &amp; 0xFFFC));
-			if (phy-&gt;rev &gt; 1) { /* loopback gain enabled */
-				backup[19] = bcm43xx_phy_read(bcm, 0x080F);
-				backup[20] = bcm43xx_phy_read(bcm, 0x0810);
-				if (phy-&gt;rev &gt;= 3)
-					bcm43xx_phy_write(bcm, 0x080F, 0xC020);
-				else
-					bcm43xx_phy_write(bcm, 0x080F, 0x8020);
-				bcm43xx_phy_write(bcm, 0x0810, 0x0000);
-			}
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(0, 1, 1)));
-			if (phy-&gt;rev &lt; 7 || !(bcm-&gt;sprom.boardflags
-			    &amp; BCM43xx_BFL_EXTLNA))
-				bcm43xx_phy_write(bcm, 0x0811, 0x01B3);
-			else
-				bcm43xx_phy_write(bcm, 0x0811, 0x09B3);
-		}
-	}
-	bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_RADIO,
-	                (bcm43xx_read16(bcm, BCM43xx_MMIO_PHY_RADIO) | 0x8000));
-	backup[10] = bcm43xx_phy_read(bcm, 0x0035);
-	bcm43xx_phy_write(bcm, 0x0035,
-	                  (bcm43xx_phy_read(bcm, 0x0035) &amp; 0xFF7F));
-	backup[11] = bcm43xx_read16(bcm, 0x03E6);
-	backup[12] = bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT);
-
-	// Initialization
-	if (phy-&gt;analog == 0) {
-		bcm43xx_write16(bcm, 0x03E6, 0x0122);
-	} else {
-		if (phy-&gt;analog &gt;= 2)
-			bcm43xx_phy_write(bcm, 0x0003,
-					  (bcm43xx_phy_read(bcm, 0x0003)
-					  &amp; 0xFFBF) | 0x0040);
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-		                (bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
-				| 0x2000));
-	}
-
-	ret = bcm43xx_radio_calibrationvalue(bcm);
-
-	if (phy-&gt;type == BCM43xx_PHYTYPE_B)
-		bcm43xx_radio_write16(bcm, 0x0078, 0x0026);
-
-	if (phy-&gt;connected)
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_get_812_value(bcm, LPD(0, 1, 1)));
-	bcm43xx_phy_write(bcm, 0x0015, 0xBFAF);
-	bcm43xx_phy_write(bcm, 0x002B, 0x1403);
-	if (phy-&gt;connected)
-		bcm43xx_phy_write(bcm, 0x0812,
-				  bcm43xx_get_812_value(bcm, LPD(0, 0, 1)));
-	bcm43xx_phy_write(bcm, 0x0015, 0xBFA0);
-	bcm43xx_radio_write16(bcm, 0x0051,
-	                      (bcm43xx_radio_read16(bcm, 0x0051) | 0x0004));
-	if (radio-&gt;revision == 8)
-		bcm43xx_radio_write16(bcm, 0x0043, 0x001F);
-	else {
-		bcm43xx_radio_write16(bcm, 0x0052, 0x0000);
-		bcm43xx_radio_write16(bcm, 0x0043,
-				      (bcm43xx_radio_read16(bcm, 0x0043) &amp; 0xFFF0)
-				      | 0x0009);
-	}
-	bcm43xx_phy_write(bcm, 0x0058, 0x0000);
-
-	for (i = 0; i &lt; 16; i++) {
-		bcm43xx_phy_write(bcm, 0x005A, 0x0480);
-		bcm43xx_phy_write(bcm, 0x0059, 0xC810);
-		bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-		if (phy-&gt;connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 1)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
-		udelay(10);
-		if (phy-&gt;connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 1)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xEFB0);
-		udelay(10);
-		if (phy-&gt;connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 0)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xFFF0);
-		udelay(20);
-		tmp1 += bcm43xx_phy_read(bcm, 0x002D);
-		bcm43xx_phy_write(bcm, 0x0058, 0x0000);
-		if (phy-&gt;connected)
-			bcm43xx_phy_write(bcm, 0x0812,
-					  bcm43xx_get_812_value(bcm, LPD(1, 0, 1)));
-		bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
-	}
-
-	tmp1++;
-	tmp1 &gt;&gt;= 9;
-	udelay(10);
-	bcm43xx_phy_write(bcm, 0x0058, 0x0000);
-
-	for (i = 0; i &lt; 16; i++) {
-		bcm43xx_radio_write16(bcm, 0x0078, (flip_4bit(i) &lt;&lt; 1) | 0x0020);
-		backup[13] = bcm43xx_radio_read16(bcm, 0x0078);
-		udelay(10);
-		for (j = 0; j &lt; 16; j++) {
-			bcm43xx_phy_write(bcm, 0x005A, 0x0D80);
-			bcm43xx_phy_write(bcm, 0x0059, 0xC810);
-			bcm43xx_phy_write(bcm, 0x0058, 0x000D);
-			if (phy-&gt;connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
-						  LPD(1, 0, 1)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
-			udelay(10);
-			if (phy-&gt;connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
-						  LPD(1, 0, 1)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xEFB0);
-			udelay(10);
-			if (phy-&gt;connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
-						  LPD(1, 0, 0)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xFFF0);
-			udelay(10);
-			tmp2 += bcm43xx_phy_read(bcm, 0x002D);
-			bcm43xx_phy_write(bcm, 0x0058, 0x0000);
-			if (phy-&gt;connected)
-				bcm43xx_phy_write(bcm, 0x0812,
-						  bcm43xx_get_812_value(bcm,
-						  LPD(1, 0, 1)));
-			bcm43xx_phy_write(bcm, 0x0015, 0xAFB0);
-		}
-		tmp2++;
-		tmp2 &gt;&gt;= 8;
-		if (tmp1 &lt; tmp2)
-			break;
-	}
-
-	/* Restore the registers */
-	bcm43xx_phy_write(bcm, 0x0015, backup[1]);
-	bcm43xx_radio_write16(bcm, 0x0051, backup[14]);
-	bcm43xx_radio_write16(bcm, 0x0052, backup[15]);
-	bcm43xx_radio_write16(bcm, 0x0043, backup[0]);
-	bcm43xx_phy_write(bcm, 0x005A, backup[16]);
-	bcm43xx_phy_write(bcm, 0x0059, backup[17]);
-	bcm43xx_phy_write(bcm, 0x0058, backup[18]);
-	bcm43xx_write16(bcm, 0x03E6, backup[11]);
-	if (phy-&gt;analog != 0)
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT, backup[12]);
-	bcm43xx_phy_write(bcm, 0x0035, backup[10]);
-	bcm43xx_radio_selectchannel(bcm, radio-&gt;channel, 1);
-	if (phy-&gt;type == BCM43xx_PHYTYPE_B) {
-		bcm43xx_phy_write(bcm, 0x0030, backup[2]);
-		bcm43xx_write16(bcm, 0x03EC, backup[3]);
-	} else {
-		if (phy-&gt;connected) {
-			bcm43xx_write16(bcm, BCM43xx_MMIO_PHY_RADIO,
-					(bcm43xx_read16(bcm,
-					BCM43xx_MMIO_PHY_RADIO) &amp; 0x7FFF));
-			bcm43xx_phy_write(bcm, 0x0811, backup[4]);
-			bcm43xx_phy_write(bcm, 0x0812, backup[5]);
-			bcm43xx_phy_write(bcm, 0x0814, backup[6]);
-			bcm43xx_phy_write(bcm, 0x0815, backup[7]);
-			bcm43xx_phy_write(bcm, BCM43xx_PHY_G_CRS, backup[8]);
-			bcm43xx_phy_write(bcm, 0x0802, backup[9]);
-			if (phy-&gt;rev &gt; 1) {
-				bcm43xx_phy_write(bcm, 0x080F, backup[19]);
-				bcm43xx_phy_write(bcm, 0x0810, backup[20]);
-			}
-		}
-	}
-	if (i &gt;= 15)
-		ret = backup[13];
-
-	return ret;
-}
-
-void bcm43xx_radio_init2060(struct bcm43xx_private *bcm)
-{
-	int err;
-
-	bcm43xx_radio_write16(bcm, 0x0004, 0x00C0);
-	bcm43xx_radio_write16(bcm, 0x0005, 0x0008);
-	bcm43xx_radio_write16(bcm, 0x0009, 0x0040);
-	bcm43xx_radio_write16(bcm, 0x0005, 0x00AA);
-	bcm43xx_radio_write16(bcm, 0x0032, 0x008F);
-	bcm43xx_radio_write16(bcm, 0x0006, 0x008F);
-	bcm43xx_radio_write16(bcm, 0x0034, 0x008F);
-	bcm43xx_radio_write16(bcm, 0x002C, 0x0007);
-	bcm43xx_radio_write16(bcm, 0x0082, 0x0080);
-	bcm43xx_radio_write16(bcm, 0x0080, 0x0000);
-	bcm43xx_radio_write16(bcm, 0x003F, 0x00DA);
-	bcm43xx_radio_write16(bcm, 0x0005, bcm43xx_radio_read16(bcm, 0x0005) &amp; ~0x0008);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) &amp; ~0x0010);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) &amp; ~0x0020);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) &amp; ~0x0020);
-	udelay(400);
-
-	bcm43xx_radio_write16(bcm, 0x0081, (bcm43xx_radio_read16(bcm, 0x0081) &amp; ~0x0020) | 0x0010);
-	udelay(400);
-
-	bcm43xx_radio_write16(bcm, 0x0005, (bcm43xx_radio_read16(bcm, 0x0005) &amp; ~0x0008) | 0x0008);
-	bcm43xx_radio_write16(bcm, 0x0085, bcm43xx_radio_read16(bcm, 0x0085) &amp; ~0x0010);
-	bcm43xx_radio_write16(bcm, 0x0005, bcm43xx_radio_read16(bcm, 0x0005) &amp; ~0x0008);
-	bcm43xx_radio_write16(bcm, 0x0081, bcm43xx_radio_read16(bcm, 0x0081) &amp; ~0x0040);
-	bcm43xx_radio_write16(bcm, 0x0081, (bcm43xx_radio_read16(bcm, 0x0081) &amp; ~0x0040) | 0x0040);
-	bcm43xx_radio_write16(bcm, 0x0005, (bcm43xx_radio_read16(bcm, 0x0081) &amp; ~0x0008) | 0x0008);
-	bcm43xx_phy_write(bcm, 0x0063, 0xDDC6);
-	bcm43xx_phy_write(bcm, 0x0069, 0x07BE);
-	bcm43xx_phy_write(bcm, 0x006A, 0x0000);
-
-	err = bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_A, 0);
-	assert(err == 0);
-	udelay(1000);
-}
-
-static inline
-u16 freq_r3A_value(u16 frequency)
-{
-	u16 value;
-
-	if (frequency &lt; 5091)
-		value = 0x0040;
-	else if (frequency &lt; 5321)
-		value = 0x0000;
-	else if (frequency &lt; 5806)
-		value = 0x0080;
-	else
-		value = 0x0040;
-
-	return value;
-}
-
-void bcm43xx_radio_set_tx_iq(struct bcm43xx_private *bcm)
-{
-	static const u8 data_high[5] = { 0x00, 0x40, 0x80, 0x90, 0xD0 };
-	static const u8 data_low[5]  = { 0x00, 0x01, 0x05, 0x06, 0x0A };
-	u16 tmp = bcm43xx_radio_read16(bcm, 0x001E);
-	int i, j;
-	
-	for (i = 0; i &lt; 5; i++) {
-		for (j = 0; j &lt; 5; j++) {
-			if (tmp == (data_high[i] | data_low[j])) {
-				bcm43xx_phy_write(bcm, 0x0069, (i - j) &lt;&lt; 8 | 0x00C0);
-				return;
-			}
-		}
-	}
-}
-
-int bcm43xx_radio_selectchannel(struct bcm43xx_private *bcm,
-				u8 channel,
-				int synthetic_pu_workaround)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 r8, tmp;
-	u16 freq;
-
-	if (!ieee80211_is_valid_channel(bcm-&gt;ieee, channel))
-		return -EINVAL;
-	if ((radio-&gt;manufact == 0x17F) &amp;&amp;
-	    (radio-&gt;version == 0x2060) &amp;&amp;
-	    (radio-&gt;revision == 1)) {
-		freq = channel2freq_a(channel);
-
-		r8 = bcm43xx_radio_read16(bcm, 0x0008);
-		bcm43xx_write16(bcm, 0x03F0, freq);
-		bcm43xx_radio_write16(bcm, 0x0008, r8);
-
-		TODO();//TODO: write max channel TX power? to Radio 0x2D
-		tmp = bcm43xx_radio_read16(bcm, 0x002E);
-		tmp &amp;= 0x0080;
-		TODO();//TODO: OR tmp with the Power out estimation for this channel?
-		bcm43xx_radio_write16(bcm, 0x002E, tmp);
-
-		if (freq &gt;= 4920 &amp;&amp; freq &lt;= 5500) {
-			/* 
-			 * r8 = (((freq * 15 * 0xE1FC780F) &gt;&gt; 32) / 29) &amp; 0x0F;
-			 *    = (freq * 0.025862069
-			 */
-			r8 = 3 * freq / 116; /* is equal to r8 = freq * 0.025862 */
-		}
-		bcm43xx_radio_write16(bcm, 0x0007, (r8 &lt;&lt; 4) | r8);
-		bcm43xx_radio_write16(bcm, 0x0020, (r8 &lt;&lt; 4) | r8);
-		bcm43xx_radio_write16(bcm, 0x0021, (r8 &lt;&lt; 4) | r8);
-		bcm43xx_radio_write16(bcm, 0x0022,
-				      (bcm43xx_radio_read16(bcm, 0x0022)
-				       &amp; 0x000F) | (r8 &lt;&lt; 4));
-		bcm43xx_radio_write16(bcm, 0x002A, (r8 &lt;&lt; 4));
-		bcm43xx_radio_write16(bcm, 0x002B, (r8 &lt;&lt; 4));
-		bcm43xx_radio_write16(bcm, 0x0008,
-				      (bcm43xx_radio_read16(bcm, 0x0008)
-				       &amp; 0x00F0) | (r8 &lt;&lt; 4));
-		bcm43xx_radio_write16(bcm, 0x0029,
-				      (bcm43xx_radio_read16(bcm, 0x0029)
-				       &amp; 0xFF0F) | 0x00B0);
-		bcm43xx_radio_write16(bcm, 0x0035, 0x00AA);
-		bcm43xx_radio_write16(bcm, 0x0036, 0x0085);
-		bcm43xx_radio_write16(bcm, 0x003A,
-				      (bcm43xx_radio_read16(bcm, 0x003A)
-				       &amp; 0xFF20) | freq_r3A_value(freq));
-		bcm43xx_radio_write16(bcm, 0x003D,
-				      bcm43xx_radio_read16(bcm, 0x003D) &amp; 0x00FF);
-		bcm43xx_radio_write16(bcm, 0x0081,
-				      (bcm43xx_radio_read16(bcm, 0x0081)
-				       &amp; 0xFF7F) | 0x0080);
-		bcm43xx_radio_write16(bcm, 0x0035,
-				      bcm43xx_radio_read16(bcm, 0x0035) &amp; 0xFFEF);
-		bcm43xx_radio_write16(bcm, 0x0035,
-				      (bcm43xx_radio_read16(bcm, 0x0035)
-				       &amp; 0xFFEF) | 0x0010);
-		bcm43xx_radio_set_tx_iq(bcm);
-		TODO();	//TODO:	TSSI2dbm workaround
-		bcm43xx_phy_xmitpower(bcm);//FIXME correct?
-	} else {
-		if (synthetic_pu_workaround)
-			bcm43xx_synth_pu_workaround(bcm, channel);
-
-		bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL,
-				channel2freq_bg(channel));
-
-		if (channel == 14) {
-			if (bcm-&gt;sprom.locale == BCM43xx_LOCALE_JAPAN) {
-				bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-						    BCM43xx_UCODEFLAGS_OFFSET,
-						    bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-								       BCM43xx_UCODEFLAGS_OFFSET)
-						    &amp; ~(1 &lt;&lt; 7));
-			} else {
-				bcm43xx_shm_write32(bcm, BCM43xx_SHM_SHARED,
-						    BCM43xx_UCODEFLAGS_OFFSET,
-						    bcm43xx_shm_read32(bcm, BCM43xx_SHM_SHARED,
-								       BCM43xx_UCODEFLAGS_OFFSET)
-						    | (1 &lt;&lt; 7));
-			}
-			bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-					bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
-					| (1 &lt;&lt; 11));
-		} else {
-			bcm43xx_write16(bcm, BCM43xx_MMIO_CHANNEL_EXT,
-					bcm43xx_read16(bcm, BCM43xx_MMIO_CHANNEL_EXT)
-					&amp; 0xF7BF);
-		}
-	}
-
-	radio-&gt;channel = channel;
-	//XXX: Using the longer of 2 timeouts (8000 vs 2000 usecs). Specs states
-	//     that 2000 usecs might suffice.
-	udelay(8000);
-
-	return 0;
-}
-
-void bcm43xx_radio_set_txantenna(struct bcm43xx_private *bcm, u32 val)
-{
-	u16 tmp;
-
-	val &lt;&lt;= 8;
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0022) &amp; 0xFCFF;
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0022, tmp | val);
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x03A8) &amp; 0xFCFF;
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x03A8, tmp | val);
-	tmp = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED, 0x0054) &amp; 0xFCFF;
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0054, tmp | val);
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/TX_Gain_Base_Band">http://bcm-specs.sipsolutions.net/TX_Gain_Base_Band</A> */
-static u16 bcm43xx_get_txgain_base_band(u16 txpower)
-{
-	u16 ret;
-
-	assert(txpower &lt;= 63);
-
-	if (txpower &gt;= 54)
-		ret = 2;
-	else if (txpower &gt;= 49)
-		ret = 4;
-	else if (txpower &gt;= 44)
-		ret = 5;
-	else
-		ret = 6;
-
-	return ret;
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/TX_Gain_Radio_Frequency_Power_Amplifier">http://bcm-specs.sipsolutions.net/TX_Gain_Radio_Frequency_Power_Amplifier</A> */
-static u16 bcm43xx_get_txgain_freq_power_amp(u16 txpower)
-{
-	u16 ret;
-
-	assert(txpower &lt;= 63);
-
-	if (txpower &gt;= 32)
-		ret = 0;
-	else if (txpower &gt;= 25)
-		ret = 1;
-	else if (txpower &gt;= 20)
-		ret = 2;
-	else if (txpower &gt;= 12)
-		ret = 3;
-	else
-		ret = 4;
-
-	return ret;
-}
-
-/* <A HREF="http://bcm-specs.sipsolutions.net/TX_Gain_Digital_Analog_Converter">http://bcm-specs.sipsolutions.net/TX_Gain_Digital_Analog_Converter</A> */
-static u16 bcm43xx_get_txgain_dac(u16 txpower)
-{
-	u16 ret;
-
-	assert(txpower &lt;= 63);
-
-	if (txpower &gt;= 54)
-		ret = txpower - 53;
-	else if (txpower &gt;= 49)
-		ret = txpower - 42;
-	else if (txpower &gt;= 44)
-		ret = txpower - 37;
-	else if (txpower &gt;= 32)
-		ret = txpower - 32;
-	else if (txpower &gt;= 25)
-		ret = txpower - 20;
-	else if (txpower &gt;= 20)
-		ret = txpower - 13;
-	else if (txpower &gt;= 12)
-		ret = txpower - 8;
-	else
-		ret = txpower;
-
-	return ret;
-}
-
-void bcm43xx_radio_set_txpower_a(struct bcm43xx_private *bcm, u16 txpower)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 pamp, base, dac, ilt;
-
-	txpower = limit_value(txpower, 0, 63);
-
-	pamp = bcm43xx_get_txgain_freq_power_amp(txpower);
-	pamp &lt;&lt;= 5;
-	pamp &amp;= 0x00E0;
-	bcm43xx_phy_write(bcm, 0x0019, pamp);
-
-	base = bcm43xx_get_txgain_base_band(txpower);
-	base &amp;= 0x000F;
-	bcm43xx_phy_write(bcm, 0x0017, base | 0x0020);
-
-	ilt = bcm43xx_ilt_read(bcm, 0x3001);
-	ilt &amp;= 0x0007;
-
-	dac = bcm43xx_get_txgain_dac(txpower);
-	dac &lt;&lt;= 3;
-	dac |= ilt;
-
-	bcm43xx_ilt_write(bcm, 0x3001, dac);
-
-	radio-&gt;txpwr_offset = txpower;
-
-	TODO();
-	//TODO: FuncPlaceholder (Adjust BB loft cancel)
-}
-
-void bcm43xx_radio_set_txpower_bg(struct bcm43xx_private *bcm,
-                                 u16 baseband_attenuation, u16 radio_attenuation,
-                                 u16 txpower)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	if (baseband_attenuation == 0xFFFF)
-		baseband_attenuation = radio-&gt;baseband_atten;
-	if (radio_attenuation == 0xFFFF)
-		radio_attenuation = radio-&gt;radio_atten;
-	if (txpower == 0xFFFF)
-		txpower = radio-&gt;txctl1;
-	radio-&gt;baseband_atten = baseband_attenuation;
-	radio-&gt;radio_atten = radio_attenuation;
-	radio-&gt;txctl1 = txpower;
-
-	assert(/*baseband_attenuation &gt;= 0 &amp;&amp;*/ baseband_attenuation &lt;= 11);
-	if (radio-&gt;revision &lt; 6)
-		assert(/*radio_attenuation &gt;= 0 &amp;&amp;*/ radio_attenuation &lt;= 9);
-	else
-		assert(/* radio_attenuation &gt;= 0 &amp;&amp;*/ radio_attenuation &lt;= 31);
-	assert(/*txpower &gt;= 0 &amp;&amp;*/ txpower &lt;= 7);
-
-	bcm43xx_phy_set_baseband_attenuation(bcm, baseband_attenuation);
-	bcm43xx_radio_write16(bcm, 0x0043, radio_attenuation);
-	bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0064, radio_attenuation);
-	if (radio-&gt;version == 0x2050) {
-		bcm43xx_radio_write16(bcm, 0x0052,
-		                      (bcm43xx_radio_read16(bcm, 0x0052) &amp; ~0x0070)
-				       | ((txpower &lt;&lt; 4) &amp; 0x0070));
-	}
-	//FIXME: The spec is very weird and unclear here.
-	if (phy-&gt;type == BCM43xx_PHYTYPE_G)
-		bcm43xx_phy_lo_adjust(bcm, 0);
-}
-
-u16 bcm43xx_default_baseband_attenuation(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-
-	if (radio-&gt;version == 0x2050 &amp;&amp; radio-&gt;revision &lt; 6)
-		return 0;
-	return 2;
-}
-
-u16 bcm43xx_default_radio_attenuation(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	u16 att = 0xFFFF;
-
-	if (phy-&gt;type == BCM43xx_PHYTYPE_A)
-		return 0x60;
-
-	switch (radio-&gt;version) {
-	case 0x2053:
-		switch (radio-&gt;revision) {
-		case 1:
-			att = 6;
-			break;
-		}
-		break;
-	case 0x2050:
-		switch (radio-&gt;revision) {
-		case 0:
-			att = 5;
-			break;
-		case 1:
-			if (phy-&gt;type == BCM43xx_PHYTYPE_G) {
-				if (bcm-&gt;board_vendor == PCI_VENDOR_ID_BROADCOM &amp;&amp;
-				    bcm-&gt;board_type == 0x421 &amp;&amp;
-				    bcm-&gt;board_revision &gt;= 30)
-					att = 3;
-				else if (bcm-&gt;board_vendor == PCI_VENDOR_ID_BROADCOM &amp;&amp;
-					 bcm-&gt;board_type == 0x416)
-					att = 3;
-				else
-					att = 1;
-			} else {
-				if (bcm-&gt;board_vendor == PCI_VENDOR_ID_BROADCOM &amp;&amp;
-				    bcm-&gt;board_type == 0x421 &amp;&amp;
-				    bcm-&gt;board_revision &gt;= 30)
-					att = 7;
-				else
-					att = 6;
-			}
-			break;
-		case 2:
-			if (phy-&gt;type == BCM43xx_PHYTYPE_G) {
-				if (bcm-&gt;board_vendor == PCI_VENDOR_ID_BROADCOM &amp;&amp;
-				    bcm-&gt;board_type == 0x421 &amp;&amp;
-				    bcm-&gt;board_revision &gt;= 30)
-					att = 3;
-				else if (bcm-&gt;board_vendor == PCI_VENDOR_ID_BROADCOM &amp;&amp;
-					 bcm-&gt;board_type == 0x416)
-					att = 5;
-				else if (bcm-&gt;chip_id == 0x4320)
-					att = 4;
-				else
-					att = 3;
-			} else
-				att = 6;
-			break;
-		case 3:
-			att = 5;
-			break;
-		case 4:
-		case 5:
-			att = 1;
-			break;
-		case 6:
-		case 7:
-			att = 5;
-			break;
-		case 8:
-			att = 0x1A;
-			break;
-		case 9:
-		default:
-			att = 5;
-		}
-	}
-	if (bcm-&gt;board_vendor == PCI_VENDOR_ID_BROADCOM &amp;&amp;
-	    bcm-&gt;board_type == 0x421) {
-		if (bcm-&gt;board_revision &lt; 0x43)
-			att = 2;
-		else if (bcm-&gt;board_revision &lt; 0x51)
-			att = 3;
-	}
-	if (att == 0xFFFF)
-		att = 5;
-
-	return att;
-}
-
-u16 bcm43xx_default_txctl1(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-
-	if (radio-&gt;version != 0x2050)
-		return 0;
-	if (radio-&gt;revision == 1)
-		return 3;
-	if (radio-&gt;revision &lt; 6)
-		return 2;
-	if (radio-&gt;revision == 8)
-		return 1;
-	return 0;
-}
-
-void bcm43xx_radio_turn_on(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	int err;
-
-	if (radio-&gt;enabled)
-		return;
-
-	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-		bcm43xx_radio_write16(bcm, 0x0004, 0x00C0);
-		bcm43xx_radio_write16(bcm, 0x0005, 0x0008);
-		bcm43xx_phy_write(bcm, 0x0010, bcm43xx_phy_read(bcm, 0x0010) &amp; 0xFFF7);
-		bcm43xx_phy_write(bcm, 0x0011, bcm43xx_phy_read(bcm, 0x0011) &amp; 0xFFF7);
-		bcm43xx_radio_init2060(bcm);	
-		break;
-	case BCM43xx_PHYTYPE_B:
-	case BCM43xx_PHYTYPE_G:
-		bcm43xx_phy_write(bcm, 0x0015, 0x8000);
-		bcm43xx_phy_write(bcm, 0x0015, 0xCC00);
-		bcm43xx_phy_write(bcm, 0x0015, (phy-&gt;connected ? 0x00C0 : 0x0000));
-		err = bcm43xx_radio_selectchannel(bcm, BCM43xx_RADIO_DEFAULT_CHANNEL_BG, 1);
-		assert(err == 0);
-		break;
-	default:
-		assert(0);
-	}
-	radio-&gt;enabled = 1;
-	dprintk(KERN_INFO PFX &quot;Radio turned on\n&quot;);
-	bcm43xx_leds_update(bcm, 0);
-}
-	
-void bcm43xx_radio_turn_off(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-
-	if (phy-&gt;type == BCM43xx_PHYTYPE_A) {
-		bcm43xx_radio_write16(bcm, 0x0004, 0x00FF);
-		bcm43xx_radio_write16(bcm, 0x0005, 0x00FB);
-		bcm43xx_phy_write(bcm, 0x0010, bcm43xx_phy_read(bcm, 0x0010) | 0x0008);
-		bcm43xx_phy_write(bcm, 0x0011, bcm43xx_phy_read(bcm, 0x0011) | 0x0008);
-	}
-	if (phy-&gt;type == BCM43xx_PHYTYPE_G &amp;&amp; bcm-&gt;current_core-&gt;rev &gt;= 5) {
-		bcm43xx_phy_write(bcm, 0x0811, bcm43xx_phy_read(bcm, 0x0811) | 0x008C);
-		bcm43xx_phy_write(bcm, 0x0812, bcm43xx_phy_read(bcm, 0x0812) &amp; 0xFF73);
-	} else
-		bcm43xx_phy_write(bcm, 0x0015, 0xAA00);
-	radio-&gt;enabled = 0;
-	dprintk(KERN_INFO PFX &quot;Radio initialized\n&quot;);
-	bcm43xx_leds_update(bcm, 0);
-}
-
-void bcm43xx_radio_clear_tssi(struct bcm43xx_private *bcm)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-
-	switch (phy-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0068, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x006a, 0x7F7F);
-		break;
-	case BCM43xx_PHYTYPE_B:
-	case BCM43xx_PHYTYPE_G:
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0058, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x005a, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0070, 0x7F7F);
-		bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED, 0x0072, 0x7F7F);
-		break;
-	}
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_radio.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_radio.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef BCM43xx_RADIO_H_
-#define BCM43xx_RADIO_H_
-
-#include &quot;bcm43xx.h&quot;
-
-
-#define BCM43xx_RADIO_DEFAULT_CHANNEL_A		36
-#define BCM43xx_RADIO_DEFAULT_CHANNEL_BG	6
-
-/* Force antenna 0. */
-#define BCM43xx_RADIO_TXANTENNA_0		0
-/* Force antenna 1. */
-#define BCM43xx_RADIO_TXANTENNA_1		1
-/* Use the RX antenna, that was selected for the most recently
- * received good PLCP header.
- */
-#define BCM43xx_RADIO_TXANTENNA_LASTPLCP	3
-#define BCM43xx_RADIO_TXANTENNA_DEFAULT		BCM43xx_RADIO_TXANTENNA_LASTPLCP
-
-#define BCM43xx_RADIO_INTERFMODE_NONE		0
-#define BCM43xx_RADIO_INTERFMODE_NONWLAN	1
-#define BCM43xx_RADIO_INTERFMODE_MANUALWLAN	2
-#define BCM43xx_RADIO_INTERFMODE_AUTOWLAN	3
-
-
-void bcm43xx_radio_lock(struct bcm43xx_private *bcm);
-void bcm43xx_radio_unlock(struct bcm43xx_private *bcm);
-
-u16 bcm43xx_radio_read16(struct bcm43xx_private *bcm, u16 offset);
-void bcm43xx_radio_write16(struct bcm43xx_private *bcm, u16 offset, u16 val);
-
-u16 bcm43xx_radio_init2050(struct bcm43xx_private *bcm);
-void bcm43xx_radio_init2060(struct bcm43xx_private *bcm);
-
-void bcm43xx_radio_turn_on(struct bcm43xx_private *bcm);
-void bcm43xx_radio_turn_off(struct bcm43xx_private *bcm);
-
-static inline
-int bcm43xx_is_hw_radio_enabled(struct bcm43xx_private *bcm)
-{
-	/* function to return state of hardware enable of radio
-	 * returns 0 if radio disabled, 1 if radio enabled
-	 */
-	if (bcm-&gt;current_core-&gt;rev &gt;= 3)
-		return ((bcm43xx_read32(bcm, BCM43xx_MMIO_RADIO_HWENABLED_HI)
-					&amp; BCM43xx_MMIO_RADIO_HWENABLED_HI_MASK)
-					== 0) ? 1 : 0;
-	else
-		return ((bcm43xx_read16(bcm, BCM43xx_MMIO_RADIO_HWENABLED_LO)
-					&amp; BCM43xx_MMIO_RADIO_HWENABLED_LO_MASK)
-					== 0) ? 0 : 1;
-}
-
-int bcm43xx_radio_selectchannel(struct bcm43xx_private *bcm, u8 channel,
-				int synthetic_pu_workaround);
-
-void bcm43xx_radio_set_txpower_a(struct bcm43xx_private *bcm, u16 txpower);
-void bcm43xx_radio_set_txpower_bg(struct bcm43xx_private *bcm,
-                               u16 baseband_attenuation, u16 attenuation,
-			       u16 txpower);
-
-u16 bcm43xx_default_baseband_attenuation(struct bcm43xx_private *bcm);
-u16 bcm43xx_default_radio_attenuation(struct bcm43xx_private *bcm);
-u16 bcm43xx_default_txctl1(struct bcm43xx_private *bcm);
-
-void bcm43xx_radio_set_txantenna(struct bcm43xx_private *bcm, u32 val);
-
-void bcm43xx_radio_clear_tssi(struct bcm43xx_private *bcm);
-
-u8 bcm43xx_radio_aci_detect(struct bcm43xx_private *bcm, u8 channel);
-u8 bcm43xx_radio_aci_scan(struct bcm43xx_private *bcm);
-
-int bcm43xx_radio_set_interference_mitigation(struct bcm43xx_private *bcm, int mode);
-
-void bcm43xx_calc_nrssi_slope(struct bcm43xx_private *bcm);
-void bcm43xx_calc_nrssi_threshold(struct bcm43xx_private *bcm);
-s16 bcm43xx_nrssi_hw_read(struct bcm43xx_private *bcm, u16 offset);
-void bcm43xx_nrssi_hw_write(struct bcm43xx_private *bcm, u16 offset, s16 val);
-void bcm43xx_nrssi_hw_update(struct bcm43xx_private *bcm, u16 val);
-void bcm43xx_nrssi_mem_update(struct bcm43xx_private *bcm);
-
-void bcm43xx_radio_set_tx_iq(struct bcm43xx_private *bcm);
-u16 bcm43xx_radio_calibrationvalue(struct bcm43xx_private *bcm);
-
-#endif /* BCM43xx_RADIO_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.c
+++ /dev/null
@@ -1,471 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  SYSFS support routines
-
-  Copyright (c) 2006 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &quot;bcm43xx_sysfs.h&quot;
-#include &quot;bcm43xx.h&quot;
-#include &quot;bcm43xx_main.h&quot;
-#include &quot;bcm43xx_radio.h&quot;
-
-#include &lt;linux/capability.h&gt;
-
-
-#define GENERIC_FILESIZE	64
-
-
-static int get_integer(const char *buf, size_t count)
-{
-	char tmp[10 + 1] = { 0 };
-	int ret = -EINVAL;
-
-	if (count == 0)
-		goto out;
-	count = min(count, (size_t)10);
-	memcpy(tmp, buf, count);
-	ret = simple_strtol(tmp, NULL, 10);
-out:
-	return ret;
-}
-
-static int get_boolean(const char *buf, size_t count)
-{
-	if (count != 0) {
-		if (buf[0] == '1')
-			return 1;
-		if (buf[0] == '0')
-			return 0;
-		if (count &gt;= 4 &amp;&amp; memcmp(buf, &quot;true&quot;, 4) == 0)
-			return 1;
-		if (count &gt;= 5 &amp;&amp; memcmp(buf, &quot;false&quot;, 5) == 0)
-			return 0;
-		if (count &gt;= 3 &amp;&amp; memcmp(buf, &quot;yes&quot;, 3) == 0)
-			return 1;
-		if (count &gt;= 2 &amp;&amp; memcmp(buf, &quot;no&quot;, 2) == 0)
-			return 0;
-		if (count &gt;= 2 &amp;&amp; memcmp(buf, &quot;on&quot;, 2) == 0)
-			return 1;
-		if (count &gt;= 3 &amp;&amp; memcmp(buf, &quot;off&quot;, 3) == 0)
-			return 0;
-	}
-	return -EINVAL;
-}
-
-static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len)
-{
-	int i, pos = 0;
-
-	for (i = 0; i &lt; BCM43xx_SPROM_SIZE; i++) {
-		pos += snprintf(buf + pos, buf_len - pos - 1,
-				&quot;%04X&quot;, swab16(sprom[i]) &amp; 0xFFFF);
-	}
-	pos += snprintf(buf + pos, buf_len - pos - 1, &quot;\n&quot;);
-
-	return pos + 1;
-}
-
-static int hex2sprom(u16 *sprom, const char *dump, size_t len)
-{
-	char tmp[5] = { 0 };
-	int cnt = 0;
-	unsigned long parsed;
-
-	if (len &lt; BCM43xx_SPROM_SIZE * sizeof(u16) * 2)
-		return -EINVAL;
-
-	while (cnt &lt; BCM43xx_SPROM_SIZE) {
-		memcpy(tmp, dump, 4);
-		dump += 4;
-		parsed = simple_strtoul(tmp, NULL, 16);
-		sprom[cnt++] = swab16((u16)parsed);
-	}
-
-	return 0;
-}
-
-static ssize_t bcm43xx_attr_sprom_show(struct device *dev,
-				       struct device_attribute *attr,
-				       char *buf)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	u16 *sprom;
-	unsigned long flags;
-	int err;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	assert(BCM43xx_SPROM_SIZE * sizeof(u16) &lt;= PAGE_SIZE);
-	sprom = kmalloc(BCM43xx_SPROM_SIZE * sizeof(*sprom),
-			GFP_KERNEL);
-	if (!sprom)
-		return -ENOMEM;
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	err = bcm43xx_sprom_read(bcm, sprom);
-	if (!err)
-		err = sprom2hex(sprom, buf, PAGE_SIZE);
-	mmiowb();
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-	kfree(sprom);
-
-	return err;
-}
-
-static ssize_t bcm43xx_attr_sprom_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	u16 *sprom;
-	unsigned long flags;
-	int err;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	sprom = kmalloc(BCM43xx_SPROM_SIZE * sizeof(*sprom),
-			GFP_KERNEL);
-	if (!sprom)
-		return -ENOMEM;
-	err = hex2sprom(sprom, buf, count);
-	if (err)
-		goto out_kfree;
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	spin_lock(&amp;bcm-&gt;leds_lock);
-	err = bcm43xx_sprom_write(bcm, sprom);
-	mmiowb();
-	spin_unlock(&amp;bcm-&gt;leds_lock);
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-out_kfree:
-	kfree(sprom);
-
-	return err ? err : count;
-
-}
-
-static DEVICE_ATTR(sprom, 0600,
-		   bcm43xx_attr_sprom_show,
-		   bcm43xx_attr_sprom_store);
-
-static ssize_t bcm43xx_attr_interfmode_show(struct device *dev,
-					    struct device_attribute *attr,
-					    char *buf)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	ssize_t count = 0;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-
-	switch (bcm43xx_current_radio(bcm)-&gt;interfmode) {
-	case BCM43xx_RADIO_INTERFMODE_NONE:
-		count = snprintf(buf, PAGE_SIZE, &quot;0 (No Interference Mitigation)\n&quot;);
-		break;
-	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
-		count = snprintf(buf, PAGE_SIZE, &quot;1 (Non-WLAN Interference Mitigation)\n&quot;);
-		break;
-	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		count = snprintf(buf, PAGE_SIZE, &quot;2 (WLAN Interference Mitigation)\n&quot;);
-		break;
-	default:
-		assert(0);
-	}
-
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return count;
-
-}
-
-static ssize_t bcm43xx_attr_interfmode_store(struct device *dev,
-					     struct device_attribute *attr,
-					     const char *buf, size_t count)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	unsigned long flags;
-	int err;
-	int mode;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	mode = get_integer(buf, count);
-	switch (mode) {
-	case 0:
-		mode = BCM43xx_RADIO_INTERFMODE_NONE;
-		break;
-	case 1:
-		mode = BCM43xx_RADIO_INTERFMODE_NONWLAN;
-		break;
-	case 2:
-		mode = BCM43xx_RADIO_INTERFMODE_MANUALWLAN;
-		break;
-	case 3:
-		mode = BCM43xx_RADIO_INTERFMODE_AUTOWLAN;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-
-	err = bcm43xx_radio_set_interference_mitigation(bcm, mode);
-	if (err) {
-		printk(KERN_ERR PFX &quot;Interference Mitigation not &quot;
-				    &quot;supported by device\n&quot;);
-	}
-	mmiowb();
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return err ? err : count;
-}
-
-static DEVICE_ATTR(interference, 0644,
-		   bcm43xx_attr_interfmode_show,
-		   bcm43xx_attr_interfmode_store);
-
-static ssize_t bcm43xx_attr_preamble_show(struct device *dev,
-					  struct device_attribute *attr,
-					  char *buf)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	ssize_t count;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-
-	if (bcm-&gt;short_preamble)
-		count = snprintf(buf, PAGE_SIZE, &quot;1 (Short Preamble enabled)\n&quot;);
-	else
-		count = snprintf(buf, PAGE_SIZE, &quot;0 (Short Preamble disabled)\n&quot;);
-
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return count;
-}
-
-static ssize_t bcm43xx_attr_preamble_store(struct device *dev,
-					   struct device_attribute *attr,
-					   const char *buf, size_t count)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	unsigned long flags;
-	int value;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	value = get_boolean(buf, count);
-	if (value &lt; 0)
-		return value;
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-
-	bcm-&gt;short_preamble = !!value;
-
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return count;
-}
-
-static DEVICE_ATTR(shortpreamble, 0644,
-		   bcm43xx_attr_preamble_show,
-		   bcm43xx_attr_preamble_store);
-
-static ssize_t bcm43xx_attr_phymode_store(struct device *dev,
-					  struct device_attribute *attr,
-					  const char *buf, size_t count)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	int phytype;
-	int err = -EINVAL;
-
-	if (count &lt; 1)
-		goto out;
-	switch (buf[0]) {
-	case 'a':  case 'A':
-		phytype = BCM43xx_PHYTYPE_A;
-		break;
-	case 'b':  case 'B':
-		phytype = BCM43xx_PHYTYPE_B;
-		break;
-	case 'g':  case 'G':
-		phytype = BCM43xx_PHYTYPE_G;
-		break;
-	default:
-		goto out;
-	}
-
-	bcm43xx_cancel_work(bcm);
-	mutex_lock(&amp;(bcm)-&gt;mutex);
-	err = bcm43xx_select_wireless_core(bcm, phytype);
-	if (!err)
-		bcm43xx_periodic_tasks_setup(bcm);
-	mutex_unlock(&amp;(bcm)-&gt;mutex);
-	if (err == -ESRCH)
-		err = -ENODEV;
-
-out:
-	return err ? err : count;
-}
-
-static ssize_t bcm43xx_attr_phymode_show(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf)
-{
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	ssize_t count = 0;
-
-	mutex_lock(&amp;(bcm)-&gt;mutex);
-	switch (bcm43xx_current_phy(bcm)-&gt;type) {
-	case BCM43xx_PHYTYPE_A:
-		snprintf(buf, PAGE_SIZE, &quot;A&quot;);
-		break;
-	case BCM43xx_PHYTYPE_B:
-		snprintf(buf, PAGE_SIZE, &quot;B&quot;);
-		break;
-	case BCM43xx_PHYTYPE_G:
-		snprintf(buf, PAGE_SIZE, &quot;G&quot;);
-		break;
-	default:
-		assert(0);
-	}
-	mutex_unlock(&amp;(bcm)-&gt;mutex);
-
-	return count;
-}
-
-static DEVICE_ATTR(phymode, 0644,
-		   bcm43xx_attr_phymode_show,
-		   bcm43xx_attr_phymode_store);
-
-static ssize_t bcm43xx_attr_microcode_show(struct device *dev,
-					   struct device_attribute *attr,
-					   char *buf)
-{
-	unsigned long flags;
-	struct bcm43xx_private *bcm = dev_to_bcm(dev);
-	ssize_t count = 0;
-	u16 status;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	mutex_lock(&amp;(bcm)-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	status = bcm43xx_shm_read16(bcm, BCM43xx_SHM_SHARED,
-				    BCM43xx_UCODE_STATUS);
-
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;(bcm)-&gt;mutex);
-	switch (status) {
-	case 0x0000:
-		count = snprintf(buf, PAGE_SIZE, &quot;0x%.4x (invalid)\n&quot;,
-				 status);
-		break;
-	case 0x0001:
-		count = snprintf(buf, PAGE_SIZE, &quot;0x%.4x (init)\n&quot;,
-				 status);
-		break;
-	case 0x0002:
-		count = snprintf(buf, PAGE_SIZE, &quot;0x%.4x (active)\n&quot;,
-				 status);
-		break;
-	case 0x0003:
-		count = snprintf(buf, PAGE_SIZE, &quot;0x%.4x (suspended)\n&quot;,
-				 status);
-		break;
-	case 0x0004:
-		count = snprintf(buf, PAGE_SIZE, &quot;0x%.4x (asleep)\n&quot;,
-				 status);
-		break;
-	default:
-		count = snprintf(buf, PAGE_SIZE, &quot;0x%.4x (unknown)\n&quot;,
-				 status);
-		break;
-	}
-
-	return count;
-}
-
-static DEVICE_ATTR(microcodestatus, 0444,
-		   bcm43xx_attr_microcode_show,
-		   NULL);
-
-int bcm43xx_sysfs_register(struct bcm43xx_private *bcm)
-{
-	struct device *dev = &amp;bcm-&gt;pci_dev-&gt;dev;
-	int err;
-
-	assert(bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED);
-
-	err = device_create_file(dev, &amp;dev_attr_sprom);
-	if (err)
-		goto out;
-	err = device_create_file(dev, &amp;dev_attr_interference);
-	if (err)
-		goto err_remove_sprom;
-	err = device_create_file(dev, &amp;dev_attr_shortpreamble);
-	if (err)
-		goto err_remove_interfmode;
-	err = device_create_file(dev, &amp;dev_attr_phymode);
-	if (err)
-		goto err_remove_shortpreamble;
-	err = device_create_file(dev, &amp;dev_attr_microcodestatus);
-	if (err)
-		goto err_remove_phymode;
-
-out:
-	return err;
-err_remove_phymode:
-	device_remove_file(dev, &amp;dev_attr_phymode);
-err_remove_shortpreamble:
-	device_remove_file(dev, &amp;dev_attr_shortpreamble);
-err_remove_interfmode:
-	device_remove_file(dev, &amp;dev_attr_interference);
-err_remove_sprom:
-	device_remove_file(dev, &amp;dev_attr_sprom);
-	goto out;
-}
-
-void bcm43xx_sysfs_unregister(struct bcm43xx_private *bcm)
-{
-	struct device *dev = &amp;bcm-&gt;pci_dev-&gt;dev;
-
-	device_remove_file(dev, &amp;dev_attr_microcodestatus);
-	device_remove_file(dev, &amp;dev_attr_phymode);
-	device_remove_file(dev, &amp;dev_attr_shortpreamble);
-	device_remove_file(dev, &amp;dev_attr_interference);
-	device_remove_file(dev, &amp;dev_attr_sprom);
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_sysfs.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef BCM43xx_SYSFS_H_
-#define BCM43xx_SYSFS_H_
-
-struct bcm43xx_private;
-
-int bcm43xx_sysfs_register(struct bcm43xx_private *bcm);
-void bcm43xx_sysfs_unregister(struct bcm43xx_private *bcm);
-
-#endif /* BCM43xx_SYSFS_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_wx.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_wx.c
+++ /dev/null
@@ -1,1035 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &lt;linux/wireless.h&gt;
-#include &lt;net/iw_handler.h&gt;
-#include &lt;net/ieee80211softmac.h&gt;
-#include &lt;net/ieee80211softmac_wx.h&gt;
-#include &lt;linux/capability.h&gt;
-#include &lt;linux/delay.h&gt;
-
-#include &quot;bcm43xx.h&quot;
-#include &quot;bcm43xx_wx.h&quot;
-#include &quot;bcm43xx_main.h&quot;
-#include &quot;bcm43xx_radio.h&quot;
-#include &quot;bcm43xx_phy.h&quot;
-
-
-/* The WIRELESS_EXT version, which is implemented by this driver. */
-#define BCM43xx_WX_VERSION	18
-
-#define MAX_WX_STRING		80
-
-static int bcm43xx_wx_get_name(struct net_device *net_dev,
-                               struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int i;
-	struct bcm43xx_phyinfo *phy;
-	char suffix[7] = { 0 };
-	int have_a = 0, have_b = 0, have_g = 0;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	for (i = 0; i &lt; bcm-&gt;nr_80211_available; i++) {
-		phy = &amp;(bcm-&gt;core_80211_ext[i].phy);
-		switch (phy-&gt;type) {
-		case BCM43xx_PHYTYPE_A:
-			have_a = 1;
-			break;
-		case BCM43xx_PHYTYPE_G:
-			have_g = 1;
-		case BCM43xx_PHYTYPE_B:
-			have_b = 1;
-			break;
-		default:
-			assert(0);
-		}
-	}
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	i = 0;
-	if (have_a) {
-		suffix[i++] = 'a';
-		suffix[i++] = '/';
-	}
-	if (have_b) {
-		suffix[i++] = 'b';
-		suffix[i++] = '/';
-	}
-	if (have_g) {
-		suffix[i++] = 'g';
-		suffix[i++] = '/';
-	}
-	if (i != 0) 
-		suffix[i - 1] = '\0';
-
-	snprintf(data-&gt;name, IFNAMSIZ, &quot;IEEE 802.11%s&quot;, suffix);
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_channelfreq(struct net_device *net_dev,
-				      struct iw_request_info *info,
-				      union iwreq_data *data,
-				      char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	u8 channel;
-	s8 expon;
-	int freq;
-	int err = -EINVAL;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-
-	if ((data-&gt;freq.e == 0) &amp;&amp;
-	    (data-&gt;freq.m &gt;= 0) &amp;&amp; (data-&gt;freq.m &lt;= 1000)) {
-		channel = data-&gt;freq.m;
-		freq = bcm43xx_channel_to_freq(bcm, channel);
-	} else {
-		freq = data-&gt;freq.m;
-		expon = 6 - data-&gt;freq.e;
-		while (--expon &gt;= 0)    /* scale down the frequency to MHz */
-			freq /= 10;
-		assert(freq &gt; 1000);
-		channel = bcm43xx_freq_to_channel(bcm, freq);
-	}
-	if (!ieee80211_is_valid_channel(bcm-&gt;ieee, channel))
-		goto out_unlock;
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		//ieee80211softmac_disassoc(softmac, $REASON);
-		bcm43xx_mac_suspend(bcm);
-		err = bcm43xx_radio_selectchannel(bcm, channel, 0);
-		bcm43xx_mac_enable(bcm);
-	} else {
-		bcm43xx_current_radio(bcm)-&gt;initial_channel = channel;
-		err = 0;
-	}
-out_unlock:
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_channelfreq(struct net_device *net_dev,
-				      struct iw_request_info *info,
-				      union iwreq_data *data,
-				      char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct bcm43xx_radioinfo *radio;
-	int err = -ENODEV;
-	u16 channel;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	radio = bcm43xx_current_radio(bcm);
-	channel = radio-&gt;channel;
-	if (channel == 0xFF) {
-		channel = radio-&gt;initial_channel;
-		if (channel == 0xFF)
-			goto out_unlock;
-	}
-	assert(channel &gt; 0 &amp;&amp; channel &lt;= 1000);
-	data-&gt;freq.e = 1;
-	data-&gt;freq.m = bcm43xx_channel_to_freq(bcm, channel) * 100000;
-	data-&gt;freq.flags = 1;
-
-	err = 0;
-out_unlock:
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_set_mode(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int mode;
-
-	mode = data-&gt;mode;
-	if (mode == IW_MODE_AUTO)
-		mode = BCM43xx_INITIAL_IWMODE;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		if (bcm-&gt;ieee-&gt;iw_mode != mode)
-			bcm43xx_set_iwmode(bcm, mode);
-	} else
-		bcm-&gt;ieee-&gt;iw_mode = mode;
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_get_mode(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	data-&gt;mode = bcm-&gt;ieee-&gt;iw_mode;
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_get_rangeparams(struct net_device *net_dev,
-				      struct iw_request_info *info,
-				      union iwreq_data *data,
-				      char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct iw_range *range = (struct iw_range *)extra;
-	const struct ieee80211_geo *geo;
-	int i, j;
-	struct bcm43xx_phyinfo *phy;
-
-	data-&gt;data.length = sizeof(*range);
-	memset(range, 0, sizeof(*range));
-
-	//TODO: What about 802.11b?
-	/* 54Mb/s == ~27Mb/s payload throughput (802.11g) */
-	range-&gt;throughput = 27 * 1000 * 1000;
-
-	range-&gt;max_qual.qual = 100;
-	range-&gt;max_qual.level = 146; /* set floor at -110 dBm (146 - 256) */
-	range-&gt;max_qual.noise = 146;
-	range-&gt;max_qual.updated = IW_QUAL_ALL_UPDATED;
-
-	range-&gt;avg_qual.qual = 50;
-	range-&gt;avg_qual.level = 0;
-	range-&gt;avg_qual.noise = 0;
-	range-&gt;avg_qual.updated = IW_QUAL_ALL_UPDATED;
-
-	range-&gt;min_rts = BCM43xx_MIN_RTS_THRESHOLD;
-	range-&gt;max_rts = BCM43xx_MAX_RTS_THRESHOLD;
-	range-&gt;min_frag = MIN_FRAG_THRESHOLD;
-	range-&gt;max_frag = MAX_FRAG_THRESHOLD;
-
-	range-&gt;encoding_size[0] = 5;
-	range-&gt;encoding_size[1] = 13;
-	range-&gt;num_encoding_sizes = 2;
-	range-&gt;max_encoding_tokens = WEP_KEYS;
-
-	range-&gt;we_version_compiled = WIRELESS_EXT;
-	range-&gt;we_version_source = BCM43xx_WX_VERSION;
-
-	range-&gt;enc_capa = IW_ENC_CAPA_WPA |
-			  IW_ENC_CAPA_WPA2 |
-			  IW_ENC_CAPA_CIPHER_TKIP |
-			  IW_ENC_CAPA_CIPHER_CCMP;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	phy = bcm43xx_current_phy(bcm);
-
-	range-&gt;num_bitrates = 0;
-	i = 0;
-	if (phy-&gt;type == BCM43xx_PHYTYPE_A ||
-	    phy-&gt;type == BCM43xx_PHYTYPE_G) {
-		range-&gt;num_bitrates = 8;
-		range-&gt;bitrate[i++] = IEEE80211_OFDM_RATE_6MB * 500000;
-		range-&gt;bitrate[i++] = IEEE80211_OFDM_RATE_9MB * 500000;
-		range-&gt;bitrate[i++] = IEEE80211_OFDM_RATE_12MB * 500000;
-		range-&gt;bitrate[i++] = IEEE80211_OFDM_RATE_18MB * 500000;
-		range-&gt;bitrate[i++] = IEEE80211_OFDM_RATE_24MB * 500000;
-		range-&gt;bitrate[i++] = IEEE80211_OFDM_RATE_36MB * 500000;
-		range-&gt;bitrate[i++] = IEEE80211_OFDM_RATE_48MB * 500000;
-		range-&gt;bitrate[i++] = IEEE80211_OFDM_RATE_54MB * 500000;
-	}
-	if (phy-&gt;type == BCM43xx_PHYTYPE_B ||
-	    phy-&gt;type == BCM43xx_PHYTYPE_G) {
-		range-&gt;num_bitrates += 4;
-		range-&gt;bitrate[i++] = IEEE80211_CCK_RATE_1MB * 500000;
-		range-&gt;bitrate[i++] = IEEE80211_CCK_RATE_2MB * 500000;
-		range-&gt;bitrate[i++] = IEEE80211_CCK_RATE_5MB * 500000;
-		range-&gt;bitrate[i++] = IEEE80211_CCK_RATE_11MB * 500000;
-	}
-
-	geo = ieee80211_get_geo(bcm-&gt;ieee);
-	range-&gt;num_channels = geo-&gt;a_channels + geo-&gt;bg_channels;
-	j = 0;
-	for (i = 0; i &lt; geo-&gt;a_channels; i++) {
-		if (j == IW_MAX_FREQUENCIES)
-			break;
-		range-&gt;freq[j].i = j + 1;
-		range-&gt;freq[j].m = geo-&gt;a[i].freq * 100000;
-		range-&gt;freq[j].e = 1;
-		j++;
-	}
-	for (i = 0; i &lt; geo-&gt;bg_channels; i++) {
-		if (j == IW_MAX_FREQUENCIES)
-			break;
-		range-&gt;freq[j].i = j + 1;
-		range-&gt;freq[j].m = geo-&gt;bg[i].freq * 100000;
-		range-&gt;freq[j].e = 1;
-		j++;
-	}
-	range-&gt;num_frequency = j;
-
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_nick(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	size_t len;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	len =  min((size_t)data-&gt;data.length, (size_t)IW_ESSID_MAX_SIZE);
-	memcpy(bcm-&gt;nick, extra, len);
-	bcm-&gt;nick[len] = '\0';
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_get_nick(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	size_t len;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	len = strlen(bcm-&gt;nick);
-	memcpy(extra, bcm-&gt;nick, len);
-	data-&gt;data.length = (__u16)len;
-	data-&gt;data.flags = 1;
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_rts(struct net_device *net_dev,
-			      struct iw_request_info *info,
-			      union iwreq_data *data,
-			      char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int err = -EINVAL;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (data-&gt;rts.disabled) {
-		bcm-&gt;rts_threshold = BCM43xx_MAX_RTS_THRESHOLD;
-		err = 0;
-	} else {
-		if (data-&gt;rts.value &gt;= BCM43xx_MIN_RTS_THRESHOLD &amp;&amp;
-		    data-&gt;rts.value &lt;= BCM43xx_MAX_RTS_THRESHOLD) {
-			bcm-&gt;rts_threshold = data-&gt;rts.value;
-			err = 0;
-		}
-	}
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_rts(struct net_device *net_dev,
-			      struct iw_request_info *info,
-			      union iwreq_data *data,
-			      char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	data-&gt;rts.value = bcm-&gt;rts_threshold;
-	data-&gt;rts.fixed = 0;
-	data-&gt;rts.disabled = (bcm-&gt;rts_threshold == BCM43xx_MAX_RTS_THRESHOLD);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_frag(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int err = -EINVAL;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (data-&gt;frag.disabled) {
-		bcm-&gt;ieee-&gt;fts = MAX_FRAG_THRESHOLD;
-		err = 0;
-	} else {
-		if (data-&gt;frag.value &gt;= MIN_FRAG_THRESHOLD &amp;&amp;
-		    data-&gt;frag.value &lt;= MAX_FRAG_THRESHOLD) {
-			bcm-&gt;ieee-&gt;fts = data-&gt;frag.value &amp; ~0x1;
-			err = 0;
-		}
-	}
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_frag(struct net_device *net_dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *data,
-			       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	data-&gt;frag.value = bcm-&gt;ieee-&gt;fts;
-	data-&gt;frag.fixed = 0;
-	data-&gt;frag.disabled = (bcm-&gt;ieee-&gt;fts == MAX_FRAG_THRESHOLD);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_xmitpower(struct net_device *net_dev,
-				    struct iw_request_info *info,
-				    union iwreq_data *data,
-				    char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct bcm43xx_radioinfo *radio;
-	struct bcm43xx_phyinfo *phy;
-	unsigned long flags;
-	int err = -ENODEV;
-	u16 maxpower;
-
-	if ((data-&gt;txpower.flags &amp; IW_TXPOW_TYPE) != IW_TXPOW_DBM) {
-		printk(KERN_ERR PFX &quot;TX power not in dBm.\n&quot;);
-		return -EOPNOTSUPP;
-	}
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)
-		goto out_unlock;
-	radio = bcm43xx_current_radio(bcm);
-	phy = bcm43xx_current_phy(bcm);
-	if (data-&gt;txpower.disabled != (!(radio-&gt;enabled))) {
-		if (data-&gt;txpower.disabled)
-			bcm43xx_radio_turn_off(bcm);
-		else
-			bcm43xx_radio_turn_on(bcm);
-	}
-	if (data-&gt;txpower.value &gt; 0) {
-		/* desired and maxpower dBm values are in Q5.2 */
-		if (phy-&gt;type == BCM43xx_PHYTYPE_A)
-			maxpower = bcm-&gt;sprom.maxpower_aphy;
-		else
-			maxpower = bcm-&gt;sprom.maxpower_bgphy;
-		radio-&gt;txpower_desired = limit_value(data-&gt;txpower.value &lt;&lt; 2,
-						     0, maxpower);
-		bcm43xx_phy_xmitpower(bcm);
-	}
-	err = 0;
-
-out_unlock:
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_xmitpower(struct net_device *net_dev,
-				    struct iw_request_info *info,
-				    union iwreq_data *data,
-				    char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct bcm43xx_radioinfo *radio;
-	int err = -ENODEV;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	if (bcm43xx_status(bcm) != BCM43xx_STAT_INITIALIZED)
-		goto out_unlock;
-	radio = bcm43xx_current_radio(bcm);
-	/* desired dBm value is in Q5.2 */
-	data-&gt;txpower.value = radio-&gt;txpower_desired &gt;&gt; 2;
-	data-&gt;txpower.fixed = 1;
-	data-&gt;txpower.flags = IW_TXPOW_DBM;
-	data-&gt;txpower.disabled = !(radio-&gt;enabled);
-
-	err = 0;
-out_unlock:
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_set_encoding(struct net_device *net_dev,
-				   struct iw_request_info *info,
-				   union iwreq_data *data,
-				   char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
-
-	err = ieee80211_wx_set_encode(bcm-&gt;ieee, info, data, extra);
-
-	return err;
-}
-
-static int bcm43xx_wx_set_encodingext(struct net_device *net_dev,
-                                   struct iw_request_info *info,
-                                   union iwreq_data *data,
-                                   char *extra)
-{
-        struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-        int err;
-
-        err = ieee80211_wx_set_encodeext(bcm-&gt;ieee, info, data, extra);
-
-        return err;
-}
-
-static int bcm43xx_wx_get_encoding(struct net_device *net_dev,
-				   struct iw_request_info *info,
-				   union iwreq_data *data,
-				   char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err;
-
-	err = ieee80211_wx_get_encode(bcm-&gt;ieee, info, data, extra);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_encodingext(struct net_device *net_dev,
-                                   struct iw_request_info *info,
-                                   union iwreq_data *data,
-                                   char *extra)
-{
-        struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-        int err;
-
-        err = ieee80211_wx_get_encodeext(bcm-&gt;ieee, info, data, extra);
-
-        return err;
-}
-
-static int bcm43xx_wx_set_interfmode(struct net_device *net_dev,
-				     struct iw_request_info *info,
-				     union iwreq_data *data,
-				     char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int mode, err = 0;
-
-	mode = *((int *)extra);
-	switch (mode) {
-	case 0:
-		mode = BCM43xx_RADIO_INTERFMODE_NONE;
-		break;
-	case 1:
-		mode = BCM43xx_RADIO_INTERFMODE_NONWLAN;
-		break;
-	case 2:
-		mode = BCM43xx_RADIO_INTERFMODE_MANUALWLAN;
-		break;
-	case 3:
-		mode = BCM43xx_RADIO_INTERFMODE_AUTOWLAN;
-		break;
-	default:
-		printk(KERN_ERR PFX &quot;set_interfmode allowed parameters are: &quot;
-				    &quot;0 =&gt; None,  1 =&gt; Non-WLAN,  2 =&gt; WLAN,  &quot;
-				    &quot;3 =&gt; Auto-WLAN\n&quot;);
-		return -EINVAL;
-	}
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED) {
-		err = bcm43xx_radio_set_interference_mitigation(bcm, mode);
-		if (err) {
-			printk(KERN_ERR PFX &quot;Interference Mitigation not &quot;
-					    &quot;supported by device\n&quot;);
-		}
-	} else {
-		if (mode == BCM43xx_RADIO_INTERFMODE_AUTOWLAN) {
-			printk(KERN_ERR PFX &quot;Interference Mitigation mode Auto-WLAN &quot;
-					    &quot;not supported while the interface is down.\n&quot;);
-			err = -ENODEV;
-		} else
-			bcm43xx_current_radio(bcm)-&gt;interfmode = mode;
-	}
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return err;
-}
-
-static int bcm43xx_wx_get_interfmode(struct net_device *net_dev,
-				     struct iw_request_info *info,
-				     union iwreq_data *data,
-				     char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int mode;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	mode = bcm43xx_current_radio(bcm)-&gt;interfmode;
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	switch (mode) {
-	case BCM43xx_RADIO_INTERFMODE_NONE:
-		strncpy(extra, &quot;0 (No Interference Mitigation)&quot;, MAX_WX_STRING);
-		break;
-	case BCM43xx_RADIO_INTERFMODE_NONWLAN:
-		strncpy(extra, &quot;1 (Non-WLAN Interference Mitigation)&quot;, MAX_WX_STRING);
-		break;
-	case BCM43xx_RADIO_INTERFMODE_MANUALWLAN:
-		strncpy(extra, &quot;2 (WLAN Interference Mitigation)&quot;, MAX_WX_STRING);
-		break;
-	default:
-		assert(0);
-	}
-	data-&gt;data.length = strlen(extra) + 1;
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_shortpreamble(struct net_device *net_dev,
-					struct iw_request_info *info,
-					union iwreq_data *data,
-					char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int on;
-
-	on = *((int *)extra);
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	bcm-&gt;short_preamble = !!on;
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_get_shortpreamble(struct net_device *net_dev,
-					struct iw_request_info *info,
-					union iwreq_data *data,
-					char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int on;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	on = bcm-&gt;short_preamble;
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	if (on)
-		strncpy(extra, &quot;1 (Short Preamble enabled)&quot;, MAX_WX_STRING);
-	else
-		strncpy(extra, &quot;0 (Short Preamble disabled)&quot;, MAX_WX_STRING);
-	data-&gt;data.length = strlen(extra) + 1;
-
-	return 0;
-}
-
-static int bcm43xx_wx_set_swencryption(struct net_device *net_dev,
-				       struct iw_request_info *info,
-				       union iwreq_data *data,
-				       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	unsigned long flags;
-	int on;
-	
-	on = *((int *)extra);
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	bcm-&gt;ieee-&gt;host_encrypt = !!on;
-	bcm-&gt;ieee-&gt;host_decrypt = !!on;
-	bcm-&gt;ieee-&gt;host_build_iv = !on;
-	bcm-&gt;ieee-&gt;host_strip_iv_icv = !on;
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	return 0;
-}
-
-static int bcm43xx_wx_get_swencryption(struct net_device *net_dev,
-				       struct iw_request_info *info,
-				       union iwreq_data *data,
-				       char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int on;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	on = bcm-&gt;ieee-&gt;host_encrypt;
-	mutex_unlock(&amp;bcm-&gt;mutex);
-
-	if (on)
-		strncpy(extra, &quot;1 (SW encryption enabled) &quot;, MAX_WX_STRING);
-	else
-		strncpy(extra, &quot;0 (SW encryption disabled) &quot;, MAX_WX_STRING);
-	data-&gt;data.length = strlen(extra + 1);
-
-	return 0;
-}
-
-/* Enough buffer to hold a hexdump of the sprom data. */
-#define SPROM_BUFFERSIZE	512
-
-static int sprom2hex(const u16 *sprom, char *dump)
-{
-	int i, pos = 0;
-
-	for (i = 0; i &lt; BCM43xx_SPROM_SIZE; i++) {
-		pos += snprintf(dump + pos, SPROM_BUFFERSIZE - pos - 1,
-				&quot;%04X&quot;, swab16(sprom[i]) &amp; 0xFFFF);
-	}
-
-	return pos + 1;
-}
-
-static int hex2sprom(u16 *sprom, const char *dump, unsigned int len)
-{
-	char tmp[5] = { 0 };
-	int cnt = 0;
-	unsigned long parsed;
-
-	if (len &lt; BCM43xx_SPROM_SIZE * sizeof(u16) * 2)
-		return -EINVAL;
-	while (cnt &lt; BCM43xx_SPROM_SIZE) {
-		memcpy(tmp, dump, 4);
-		dump += 4;
-		parsed = simple_strtoul(tmp, NULL, 16);
-		sprom[cnt++] = swab16((u16)parsed);
-	}
-
-	return 0;
-}
-
-static int bcm43xx_wx_sprom_read(struct net_device *net_dev,
-				 struct iw_request_info *info,
-				 union iwreq_data *data,
-				 char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err = -EPERM;
-	u16 *sprom;
-	unsigned long flags;
-
-	if (!capable(CAP_SYS_RAWIO))
-		goto out;
-
-	err = -ENOMEM;
-	sprom = kmalloc(BCM43xx_SPROM_SIZE * sizeof(*sprom),
-			GFP_KERNEL);
-	if (!sprom)
-		goto out;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	err = -ENODEV;
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED)
-		err = bcm43xx_sprom_read(bcm, sprom);
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-	if (!err)
-		data-&gt;data.length = sprom2hex(sprom, extra);
-	kfree(sprom);
-out:
-	return err;
-}
-
-static int bcm43xx_wx_sprom_write(struct net_device *net_dev,
-				  struct iw_request_info *info,
-				  union iwreq_data *data,
-				  char *extra)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	int err = -EPERM;
-	u16 *sprom;
-	unsigned long flags;
-	char *input;
-	unsigned int len;
-
-	if (!capable(CAP_SYS_RAWIO))
-		goto out;
-
-	err = -ENOMEM;
-	sprom = kmalloc(BCM43xx_SPROM_SIZE * sizeof(*sprom),
-			GFP_KERNEL);
-	if (!sprom)
-		goto out;
-
-	len = data-&gt;data.length;
-	extra[len - 1] = '\0';
-	input = strchr(extra, ':');
-	if (input) {
-		input++;
-		len -= input - extra;
-	} else
-		input = extra;
-	err = hex2sprom(sprom, input, len);
-	if (err)
-		goto out_kfree;
-
-	mutex_lock(&amp;bcm-&gt;mutex);
-	spin_lock_irqsave(&amp;bcm-&gt;irq_lock, flags);
-	spin_lock(&amp;bcm-&gt;leds_lock);
-	err = -ENODEV;
-	if (bcm43xx_status(bcm) == BCM43xx_STAT_INITIALIZED)
-		err = bcm43xx_sprom_write(bcm, sprom);
-	spin_unlock(&amp;bcm-&gt;leds_lock);
-	spin_unlock_irqrestore(&amp;bcm-&gt;irq_lock, flags);
-	mutex_unlock(&amp;bcm-&gt;mutex);
-out_kfree:
-	kfree(sprom);
-out:
-	return err;
-}
-
-/* Get wireless statistics.  Called by /proc/net/wireless and by SIOCGIWSTATS */
-
-static struct iw_statistics *bcm43xx_get_wireless_stats(struct net_device *net_dev)
-{
-	struct bcm43xx_private *bcm = bcm43xx_priv(net_dev);
-	struct ieee80211softmac_device *mac = ieee80211_priv(net_dev);
-	struct iw_statistics *wstats;
-	struct ieee80211_network *network = NULL;
-	static int tmp_level = 0;
-	static int tmp_qual = 0;
-	unsigned long flags;
-
-	wstats = &amp;bcm-&gt;stats.wstats;
-	if (!mac-&gt;associnfo.associated) {
-		wstats-&gt;miss.beacon = 0;
-//		bcm-&gt;ieee-&gt;ieee_stats.tx_retry_limit_exceeded = 0; // FIXME: should this be cleared here?
-		wstats-&gt;discard.retries = 0;
-//		bcm-&gt;ieee-&gt;ieee_stats.tx_discards_wrong_sa = 0; // FIXME: same question
-		wstats-&gt;discard.nwid = 0;
-//		bcm-&gt;ieee-&gt;ieee_stats.rx_discards_undecryptable = 0; // FIXME: ditto
-		wstats-&gt;discard.code = 0;
-//		bcm-&gt;ieee-&gt;ieee_stats.rx_fragments = 0;  // FIXME: same here
-		wstats-&gt;discard.fragment = 0;
-		wstats-&gt;discard.misc = 0;
-		wstats-&gt;qual.qual = 0;
-		wstats-&gt;qual.level = 0;
-		wstats-&gt;qual.noise = 0;
-		wstats-&gt;qual.updated = 7;
-		wstats-&gt;qual.updated |= IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
-		return wstats;
-	}
-	/* fill in the real statistics when iface associated */
-	spin_lock_irqsave(&amp;mac-&gt;ieee-&gt;lock, flags);
-	list_for_each_entry(network, &amp;mac-&gt;ieee-&gt;network_list, list) {
-		if (!memcmp(mac-&gt;associnfo.bssid, network-&gt;bssid, ETH_ALEN)) {
-			if (!tmp_level)	{	/* get initial values */
-				tmp_level = network-&gt;stats.signal;
-				tmp_qual = network-&gt;stats.rssi;
-			} else {		/* smooth results */
-				tmp_level = (15 * tmp_level + network-&gt;stats.signal)/16;
-				tmp_qual = (15 * tmp_qual + network-&gt;stats.rssi)/16;
-			}
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&amp;mac-&gt;ieee-&gt;lock, flags);
-	wstats-&gt;qual.level = tmp_level;
-	wstats-&gt;qual.qual = 100 * tmp_qual / RX_RSSI_MAX;
-	wstats-&gt;qual.noise = bcm-&gt;stats.noise;
-	wstats-&gt;qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
-	wstats-&gt;discard.code = bcm-&gt;ieee-&gt;ieee_stats.rx_discards_undecryptable;
-	wstats-&gt;discard.retries = bcm-&gt;ieee-&gt;ieee_stats.tx_retry_limit_exceeded;
-	wstats-&gt;discard.nwid = bcm-&gt;ieee-&gt;ieee_stats.tx_discards_wrong_sa;
-	wstats-&gt;discard.fragment = bcm-&gt;ieee-&gt;ieee_stats.rx_fragments;
-	wstats-&gt;discard.misc = 0;	// FIXME
-	wstats-&gt;miss.beacon = 0;	// FIXME
-	return wstats;
-}
-
-
-#ifdef WX
-# undef WX
-#endif
-#define WX(ioctl)  [(ioctl) - SIOCSIWCOMMIT]
-static const iw_handler bcm43xx_wx_handlers[] = {
-	/* Wireless Identification */
-	WX(SIOCGIWNAME)		= bcm43xx_wx_get_name,
-	/* Basic operations */
-	WX(SIOCSIWFREQ)		= bcm43xx_wx_set_channelfreq,
-	WX(SIOCGIWFREQ)		= bcm43xx_wx_get_channelfreq,
-	WX(SIOCSIWMODE)		= bcm43xx_wx_set_mode,
-	WX(SIOCGIWMODE)		= bcm43xx_wx_get_mode,
-	/* Informative stuff */
-	WX(SIOCGIWRANGE)	= bcm43xx_wx_get_rangeparams,
-	/* Access Point manipulation */
-	WX(SIOCSIWAP)           = ieee80211softmac_wx_set_wap,
-	WX(SIOCGIWAP)           = ieee80211softmac_wx_get_wap,
-	WX(SIOCSIWSCAN)		= ieee80211softmac_wx_trigger_scan,
-	WX(SIOCGIWSCAN)		= ieee80211softmac_wx_get_scan_results,
-	/* 802.11 specific support */
-	WX(SIOCSIWESSID)	= ieee80211softmac_wx_set_essid,
-	WX(SIOCGIWESSID)	= ieee80211softmac_wx_get_essid,
-	WX(SIOCSIWNICKN)	= bcm43xx_wx_set_nick,
-	WX(SIOCGIWNICKN)	= bcm43xx_wx_get_nick,
-	/* Other parameters */
-	WX(SIOCSIWRATE)		= ieee80211softmac_wx_set_rate,
-	WX(SIOCGIWRATE)		= ieee80211softmac_wx_get_rate,
-	WX(SIOCSIWRTS)		= bcm43xx_wx_set_rts,
-	WX(SIOCGIWRTS)		= bcm43xx_wx_get_rts,
-	WX(SIOCSIWFRAG)		= bcm43xx_wx_set_frag,
-	WX(SIOCGIWFRAG)		= bcm43xx_wx_get_frag,
-	WX(SIOCSIWTXPOW)	= bcm43xx_wx_set_xmitpower,
-	WX(SIOCGIWTXPOW)	= bcm43xx_wx_get_xmitpower,
-//TODO	WX(SIOCSIWRETRY)	= bcm43xx_wx_set_retry,
-//TODO	WX(SIOCGIWRETRY)	= bcm43xx_wx_get_retry,
-	/* Encoding */
-	WX(SIOCSIWENCODE)	= bcm43xx_wx_set_encoding,
-	WX(SIOCGIWENCODE)	= bcm43xx_wx_get_encoding,
-	WX(SIOCSIWENCODEEXT)	= bcm43xx_wx_set_encodingext,
-	WX(SIOCGIWENCODEEXT)	= bcm43xx_wx_get_encodingext,
-	/* Power saving */
-//TODO	WX(SIOCSIWPOWER)	= bcm43xx_wx_set_power,
-//TODO	WX(SIOCGIWPOWER)	= bcm43xx_wx_get_power,
-	WX(SIOCSIWGENIE)	= ieee80211softmac_wx_set_genie,
-	WX(SIOCGIWGENIE)	= ieee80211softmac_wx_get_genie,
-	WX(SIOCSIWAUTH)		= ieee80211_wx_set_auth,
-	WX(SIOCGIWAUTH)		= ieee80211_wx_get_auth,
-};
-#undef WX
-
-static const iw_handler bcm43xx_priv_wx_handlers[] = {
-	/* Set Interference Mitigation Mode. */
-	bcm43xx_wx_set_interfmode,
-	/* Get Interference Mitigation Mode. */
-	bcm43xx_wx_get_interfmode,
-	/* Enable/Disable Short Preamble mode. */
-	bcm43xx_wx_set_shortpreamble,
-	/* Get Short Preamble mode. */
-	bcm43xx_wx_get_shortpreamble,
-	/* Enable/Disable Software Encryption mode */
-	bcm43xx_wx_set_swencryption,
-	/* Get Software Encryption mode */
-	bcm43xx_wx_get_swencryption,
-	/* Write SRPROM data. */
-	bcm43xx_wx_sprom_write,
-	/* Read SPROM data. */
-	bcm43xx_wx_sprom_read,
-};
-
-#define PRIV_WX_SET_INTERFMODE		(SIOCIWFIRSTPRIV + 0)
-#define PRIV_WX_GET_INTERFMODE		(SIOCIWFIRSTPRIV + 1)
-#define PRIV_WX_SET_SHORTPREAMBLE	(SIOCIWFIRSTPRIV + 2)
-#define PRIV_WX_GET_SHORTPREAMBLE	(SIOCIWFIRSTPRIV + 3)
-#define PRIV_WX_SET_SWENCRYPTION	(SIOCIWFIRSTPRIV + 4)
-#define PRIV_WX_GET_SWENCRYPTION	(SIOCIWFIRSTPRIV + 5)
-#define PRIV_WX_SPROM_WRITE		(SIOCIWFIRSTPRIV + 6)
-#define PRIV_WX_SPROM_READ		(SIOCIWFIRSTPRIV + 7)
-
-#define PRIV_WX_DUMMY(ioctl)	\
-	{					\
-		.cmd		= (ioctl),	\
-		.name		= &quot;__unused&quot;	\
-	}
-
-static const struct iw_priv_args bcm43xx_priv_wx_args[] = {
-	{
-		.cmd		= PRIV_WX_SET_INTERFMODE,
-		.set_args	= IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
-		.name		= &quot;set_interfmode&quot;,
-	},
-	{
-		.cmd		= PRIV_WX_GET_INTERFMODE,
-		.get_args	= IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_WX_STRING,
-		.name		= &quot;get_interfmode&quot;,
-	},
-	{
-		.cmd		= PRIV_WX_SET_SHORTPREAMBLE,
-		.set_args	= IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
-		.name		= &quot;set_shortpreamb&quot;,
-	},
-	{
-		.cmd		= PRIV_WX_GET_SHORTPREAMBLE,
-		.get_args	= IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_WX_STRING,
-		.name		= &quot;get_shortpreamb&quot;,
-	},
-	{
-		.cmd		= PRIV_WX_SET_SWENCRYPTION,
-		.set_args	= IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
-		.name		= &quot;set_swencrypt&quot;,
-	},
-	{
-		.cmd		= PRIV_WX_GET_SWENCRYPTION,
-		.get_args	= IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_WX_STRING,
-		.name		= &quot;get_swencrypt&quot;,
-	},
-	{
-		.cmd		= PRIV_WX_SPROM_WRITE,
-		.set_args	= IW_PRIV_TYPE_CHAR | SPROM_BUFFERSIZE,
-		.name		= &quot;write_sprom&quot;,
-	},
-	{
-		.cmd		= PRIV_WX_SPROM_READ,
-		.get_args	= IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | SPROM_BUFFERSIZE,
-		.name		= &quot;read_sprom&quot;,
-	},
-};
-
-const struct iw_handler_def bcm43xx_wx_handlers_def = {
-	.standard		= bcm43xx_wx_handlers,
-	.num_standard		= ARRAY_SIZE(bcm43xx_wx_handlers),
-	.num_private		= ARRAY_SIZE(bcm43xx_priv_wx_handlers),
-	.num_private_args	= ARRAY_SIZE(bcm43xx_priv_wx_args),
-	.private		= bcm43xx_priv_wx_handlers,
-	.private_args		= bcm43xx_priv_wx_args,
-	.get_wireless_stats	= bcm43xx_get_wireless_stats,
-};
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_wx.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_wx.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  Some parts of the code in this file are derived from the ipw2200
-  driver  Copyright(c) 2003 - 2004 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef BCM43xx_WX_H_
-#define BCM43xx_WX_H_
-
-extern const struct iw_handler_def bcm43xx_wx_handlers_def;
-
-#endif /* BCM43xx_WX_H_ */
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_xmit.c
+++ /dev/null
@@ -1,565 +0,0 @@
-/*
-
-  Broadcom BCM43xx wireless driver
-
-  Transmission (TX/RX) related functions.
-
-  Copyright (c) 2005 Martin Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">martin-langer at gmx.de</A>&gt;,
-                     Stefano Brivio &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">st3 at riseup.net</A>&gt;
-                     Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">mbuesch at freenet.de</A>&gt;
-                     Danny van Dyk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">kugelfang at gentoo.org</A>&gt;
-                     Andreas Jaggi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">andreas.jaggi at waterwave.ch</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &quot;bcm43xx_xmit.h&quot;
-
-#include &lt;linux/etherdevice.h&gt;
-
-
-/* Extract the bitrate out of a CCK PLCP header. */
-static u8 bcm43xx_plcp_get_bitrate_cck(struct bcm43xx_plcp_hdr4 *plcp)
-{
-	switch (plcp-&gt;raw[0]) {
-	case 0x0A:
-		return IEEE80211_CCK_RATE_1MB;
-	case 0x14:
-		return IEEE80211_CCK_RATE_2MB;
-	case 0x37:
-		return IEEE80211_CCK_RATE_5MB;
-	case 0x6E:
-		return IEEE80211_CCK_RATE_11MB;
-	}
-	assert(0);
-	return 0;
-}
-
-/* Extract the bitrate out of an OFDM PLCP header. */
-static u8 bcm43xx_plcp_get_bitrate_ofdm(struct bcm43xx_plcp_hdr4 *plcp)
-{
-	switch (plcp-&gt;raw[0] &amp; 0xF) {
-	case 0xB:
-		return IEEE80211_OFDM_RATE_6MB;
-	case 0xF:
-		return IEEE80211_OFDM_RATE_9MB;
-	case 0xA:
-		return IEEE80211_OFDM_RATE_12MB;
-	case 0xE:
-		return IEEE80211_OFDM_RATE_18MB;
-	case 0x9:
-		return IEEE80211_OFDM_RATE_24MB;
-	case 0xD:
-		return IEEE80211_OFDM_RATE_36MB;
-	case 0x8:
-		return IEEE80211_OFDM_RATE_48MB;
-	case 0xC:
-		return IEEE80211_OFDM_RATE_54MB;
-	}
-	assert(0);
-	return 0;
-}
-
-u8 bcm43xx_plcp_get_ratecode_cck(const u8 bitrate)
-{
-	switch (bitrate) {
-	case IEEE80211_CCK_RATE_1MB:
-		return 0x0A;
-	case IEEE80211_CCK_RATE_2MB:
-		return 0x14;
-	case IEEE80211_CCK_RATE_5MB:
-		return 0x37;
-	case IEEE80211_CCK_RATE_11MB:
-		return 0x6E;
-	}
-	assert(0);
-	return 0;
-}
-
-u8 bcm43xx_plcp_get_ratecode_ofdm(const u8 bitrate)
-{
-	switch (bitrate) {
-	case IEEE80211_OFDM_RATE_6MB:
-		return 0xB;
-	case IEEE80211_OFDM_RATE_9MB:
-		return 0xF;
-	case IEEE80211_OFDM_RATE_12MB:
-		return 0xA;
-	case IEEE80211_OFDM_RATE_18MB:
-		return 0xE;
-	case IEEE80211_OFDM_RATE_24MB:
-		return 0x9;
-	case IEEE80211_OFDM_RATE_36MB:
-		return 0xD;
-	case IEEE80211_OFDM_RATE_48MB:
-		return 0x8;
-	case IEEE80211_OFDM_RATE_54MB:
-		return 0xC;
-	}
-	assert(0);
-	return 0;
-}
-
-static void bcm43xx_generate_plcp_hdr(struct bcm43xx_plcp_hdr4 *plcp,
-				      const u16 octets, const u8 bitrate,
-				      const int ofdm_modulation)
-{
-	__le32 *data = &amp;(plcp-&gt;data);
-	__u8 *raw = plcp-&gt;raw;
-
-	if (ofdm_modulation) {
-		*data = bcm43xx_plcp_get_ratecode_ofdm(bitrate);
-		assert(!(octets &amp; 0xF000));
-		*data |= (octets &lt;&lt; 5);
-		*data = cpu_to_le32(*data);
-	} else {
-		u32 plen;
-
-		plen = octets * 16 / bitrate;
-		if ((octets * 16 % bitrate) &gt; 0) {
-			plen++;
-			if ((bitrate == IEEE80211_CCK_RATE_11MB)
-			    &amp;&amp; ((octets * 8 % 11) &lt; 4)) {
-				raw[1] = 0x84;
-			} else
-				raw[1] = 0x04;
-		} else
-			raw[1] = 0x04;
-		*data |= cpu_to_le32(plen &lt;&lt; 16);
-		raw[0] = bcm43xx_plcp_get_ratecode_cck(bitrate);
-	}
-}
-
-static u8 bcm43xx_calc_fallback_rate(u8 bitrate)
-{
-	switch (bitrate) {
-	case IEEE80211_CCK_RATE_1MB:
-		return IEEE80211_CCK_RATE_1MB;
-	case IEEE80211_CCK_RATE_2MB:
-		return IEEE80211_CCK_RATE_1MB;
-	case IEEE80211_CCK_RATE_5MB:
-		return IEEE80211_CCK_RATE_2MB;
-	case IEEE80211_CCK_RATE_11MB:
-		return IEEE80211_CCK_RATE_5MB;
-	case IEEE80211_OFDM_RATE_6MB:
-		return IEEE80211_CCK_RATE_5MB;
-	case IEEE80211_OFDM_RATE_9MB:
-		return IEEE80211_OFDM_RATE_6MB;
-	case IEEE80211_OFDM_RATE_12MB:
-		return IEEE80211_OFDM_RATE_9MB;
-	case IEEE80211_OFDM_RATE_18MB:
-		return IEEE80211_OFDM_RATE_12MB;
-	case IEEE80211_OFDM_RATE_24MB:
-		return IEEE80211_OFDM_RATE_18MB;
-	case IEEE80211_OFDM_RATE_36MB:
-		return IEEE80211_OFDM_RATE_24MB;
-	case IEEE80211_OFDM_RATE_48MB:
-		return IEEE80211_OFDM_RATE_36MB;
-	case IEEE80211_OFDM_RATE_54MB:
-		return IEEE80211_OFDM_RATE_48MB;
-	}
-	assert(0);
-	return 0;
-}
-
-static
-__le16 bcm43xx_calc_duration_id(const struct ieee80211_hdr *wireless_header,
-				u8 bitrate)
-{
-	const u16 frame_ctl = le16_to_cpu(wireless_header-&gt;frame_ctl);
-	__le16 duration_id = wireless_header-&gt;duration_id;
-
-	switch (WLAN_FC_GET_TYPE(frame_ctl)) {
-	case IEEE80211_FTYPE_DATA:
-	case IEEE80211_FTYPE_MGMT:
-		//TODO: Steal the code from ieee80211, once it is completed there.
-		break;
-	case IEEE80211_FTYPE_CTL:
-		/* Use the original duration/id. */
-		break;
-	default:
-		assert(0);
-	}
-
-	return duration_id;
-}
-
-static inline
-u16 ceiling_div(u16 dividend, u16 divisor)
-{
-	return ((dividend + divisor - 1) / divisor);
-}
-
-static void bcm43xx_generate_rts(const struct bcm43xx_phyinfo *phy,
-				 struct bcm43xx_txhdr *txhdr,
-				 u16 *flags,
-				 u8 bitrate,
-				 const struct ieee80211_hdr_4addr *wlhdr)
-{
-	u16 fctl;
-	u16 dur;
-	u8 fallback_bitrate;
-	int ofdm_modulation;
-	int fallback_ofdm_modulation;
-//	u8 *sa, *da;
-	u16 flen;
-
-//FIXME	sa = ieee80211_get_SA((struct ieee80211_hdr *)wlhdr);
-//FIXME	da = ieee80211_get_DA((struct ieee80211_hdr *)wlhdr);
-	fallback_bitrate = bcm43xx_calc_fallback_rate(bitrate);
-	ofdm_modulation = !(ieee80211_is_cck_rate(bitrate));
-	fallback_ofdm_modulation = !(ieee80211_is_cck_rate(fallback_bitrate));
-
-	flen = sizeof(u16) + sizeof(u16) + ETH_ALEN + ETH_ALEN + IEEE80211_FCS_LEN,
-	bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)(&amp;txhdr-&gt;rts_cts_plcp),
-				  flen, bitrate,
-				  !ieee80211_is_cck_rate(bitrate));
-	bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)(&amp;txhdr-&gt;rts_cts_fallback_plcp),
-				  flen, fallback_bitrate,
-				  !ieee80211_is_cck_rate(fallback_bitrate));
-	fctl = IEEE80211_FTYPE_CTL;
-	fctl |= IEEE80211_STYPE_RTS;
-	dur = le16_to_cpu(wlhdr-&gt;duration_id);
-/*FIXME: should we test for dur==0 here and let it unmodified in this case?
- *       The following assert checks for this case...
- */
-assert(dur);
-/*FIXME: The duration calculation is not really correct.
- *       I am not 100% sure which bitrate to use. We use the RTS rate here,
- *       but this is likely to be wrong.
- */
-	if (phy-&gt;type == BCM43xx_PHYTYPE_A) {
-		/* Three times SIFS */
-		dur += 16 * 3;
-		/* Add ACK duration. */
-		dur += ceiling_div((16 + 8 * (14 /*bytes*/) + 6) * 10,
-				   bitrate * 4);
-		/* Add CTS duration. */
-		dur += ceiling_div((16 + 8 * (14 /*bytes*/) + 6) * 10,
-				   bitrate * 4);
-	} else {
-		/* Three times SIFS */
-		dur += 10 * 3;
-		/* Add ACK duration. */
-		dur += ceiling_div(8 * (14 /*bytes*/) * 10,
-				   bitrate);
-		/* Add CTS duration. */
-		dur += ceiling_div(8 * (14 /*bytes*/) * 10,
-				   bitrate);
-	}
-
-	txhdr-&gt;rts_cts_frame_control = cpu_to_le16(fctl);
-	txhdr-&gt;rts_cts_dur = cpu_to_le16(dur);
-//printk(BCM43xx_MACFMT &quot;  &quot; BCM43xx_MACFMT &quot;  &quot; BCM43xx_MACFMT &quot;\n&quot;, BCM43xx_MACARG(wlhdr-&gt;addr1), BCM43xx_MACARG(wlhdr-&gt;addr2), BCM43xx_MACARG(wlhdr-&gt;addr3));
-//printk(BCM43xx_MACFMT &quot;  &quot; BCM43xx_MACFMT &quot;\n&quot;, BCM43xx_MACARG(sa), BCM43xx_MACARG(da));
-	memcpy(txhdr-&gt;rts_cts_mac1, wlhdr-&gt;addr1, ETH_ALEN);//FIXME!
-//	memcpy(txhdr-&gt;rts_cts_mac2, sa, ETH_ALEN);
-
-	*flags |= BCM43xx_TXHDRFLAG_RTSCTS;
-	*flags |= BCM43xx_TXHDRFLAG_RTS;
-	if (ofdm_modulation)
-		*flags |= BCM43xx_TXHDRFLAG_RTSCTS_OFDM;
-	if (fallback_ofdm_modulation)
-		*flags |= BCM43xx_TXHDRFLAG_RTSCTSFALLBACK_OFDM;
-}
-				 
-void bcm43xx_generate_txhdr(struct bcm43xx_private *bcm,
-			    struct bcm43xx_txhdr *txhdr,
-			    const unsigned char *fragment_data,
-			    const unsigned int fragment_len,
-			    const int is_first_fragment,
-			    const u16 cookie)
-{
-	const struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	const struct ieee80211_hdr_4addr *wireless_header = (const struct ieee80211_hdr_4addr *)fragment_data;
-	const struct ieee80211_security *secinfo = &amp;bcm-&gt;ieee-&gt;sec;
-	u8 bitrate;
-	u8 fallback_bitrate;
-	int ofdm_modulation;
-	int fallback_ofdm_modulation;
-	u16 plcp_fragment_len = fragment_len;
-	u16 flags = 0;
-	u16 control = 0;
-	u16 wsec_rate = 0;
-	u16 encrypt_frame;
-	const u16 ftype = WLAN_FC_GET_TYPE(le16_to_cpu(wireless_header-&gt;frame_ctl));
-	const int is_mgt = (ftype == IEEE80211_FTYPE_MGMT);
-
-	/* Now construct the TX header. */
-	memset(txhdr, 0, sizeof(*txhdr));
-
-	bitrate = ieee80211softmac_suggest_txrate(bcm-&gt;softmac,
-		is_multicast_ether_addr(wireless_header-&gt;addr1), is_mgt);
-	ofdm_modulation = !(ieee80211_is_cck_rate(bitrate));
-	fallback_bitrate = bcm43xx_calc_fallback_rate(bitrate);
-	fallback_ofdm_modulation = !(ieee80211_is_cck_rate(fallback_bitrate));
-
-	/* Set Frame Control from 80211 header. */
-	txhdr-&gt;frame_control = wireless_header-&gt;frame_ctl;
-	/* Copy address1 from 80211 header. */
-	memcpy(txhdr-&gt;mac1, wireless_header-&gt;addr1, 6);
-	/* Set the fallback duration ID. */
-	txhdr-&gt;fallback_dur_id = bcm43xx_calc_duration_id((const struct ieee80211_hdr *)wireless_header,
-							  fallback_bitrate);
-	/* Set the cookie (used as driver internal ID for the frame) */
-	txhdr-&gt;cookie = cpu_to_le16(cookie);
-
-	/* Hardware appends FCS. */
-	plcp_fragment_len += IEEE80211_FCS_LEN;
-
-	/* Hardware encryption. */
-	encrypt_frame = le16_to_cpup(&amp;wireless_header-&gt;frame_ctl) &amp; IEEE80211_FCTL_PROTECTED;
-	if (encrypt_frame &amp;&amp; !bcm-&gt;ieee-&gt;host_encrypt) {
-		const struct ieee80211_hdr_3addr *hdr = (struct ieee80211_hdr_3addr *)wireless_header;
-		memcpy(txhdr-&gt;wep_iv, hdr-&gt;payload, 4);
-		/* Hardware appends ICV. */
-		plcp_fragment_len += 4;
-
-		wsec_rate |= (bcm-&gt;key[secinfo-&gt;active_key].algorithm &lt;&lt; BCM43xx_TXHDR_WSEC_ALGO_SHIFT)
-			     &amp; BCM43xx_TXHDR_WSEC_ALGO_MASK;
-		wsec_rate |= (secinfo-&gt;active_key &lt;&lt; BCM43xx_TXHDR_WSEC_KEYINDEX_SHIFT)
-			     &amp; BCM43xx_TXHDR_WSEC_KEYINDEX_MASK;
-	}
-
-	/* Generate the PLCP header and the fallback PLCP header. */
-	bcm43xx_generate_plcp_hdr((struct bcm43xx_plcp_hdr4 *)(&amp;txhdr-&gt;plcp),
-				  plcp_fragment_len,
-				  bitrate, ofdm_modulation);
-	bcm43xx_generate_plcp_hdr(&amp;txhdr-&gt;fallback_plcp, plcp_fragment_len,
-				  fallback_bitrate, fallback_ofdm_modulation);
-
-	/* Set the CONTROL field */
-	if (ofdm_modulation)
-		control |= BCM43xx_TXHDRCTL_OFDM;
-	if (bcm-&gt;short_preamble) //FIXME: could be the other way around, please test
-		control |= BCM43xx_TXHDRCTL_SHORT_PREAMBLE;
-	control |= (phy-&gt;antenna_diversity &lt;&lt; BCM43xx_TXHDRCTL_ANTENNADIV_SHIFT)
-		   &amp; BCM43xx_TXHDRCTL_ANTENNADIV_MASK;
-
-	/* Set the FLAGS field */
-	if (!is_multicast_ether_addr(wireless_header-&gt;addr1) &amp;&amp;
-	    !is_broadcast_ether_addr(wireless_header-&gt;addr1))
-		flags |= BCM43xx_TXHDRFLAG_EXPECTACK;
-	if (1 /* FIXME: PS poll?? */)
-		flags |= 0x10; // FIXME: unknown meaning.
-	if (fallback_ofdm_modulation)
-		flags |= BCM43xx_TXHDRFLAG_FALLBACKOFDM;
-	if (is_first_fragment)
-		flags |= BCM43xx_TXHDRFLAG_FIRSTFRAGMENT;
-
-	/* Set WSEC/RATE field */
-	wsec_rate |= (txhdr-&gt;plcp.raw[0] &lt;&lt; BCM43xx_TXHDR_RATE_SHIFT)
-		     &amp; BCM43xx_TXHDR_RATE_MASK;
-
-	/* Generate the RTS/CTS packet, if required. */
-	/* FIXME: We should first try with CTS-to-self,
-	 *        if we are on 80211g. If we get too many
-	 *        failures (hidden nodes), we should switch back to RTS/CTS.
-	 */
-	if (0/*FIXME txctl-&gt;use_rts_cts*/) {
-		bcm43xx_generate_rts(phy, txhdr, &amp;flags,
-				     0/*FIXME txctl-&gt;rts_cts_rate*/,
-				     wireless_header);
-	}
-
-	txhdr-&gt;flags = cpu_to_le16(flags);
-	txhdr-&gt;control = cpu_to_le16(control);
-	txhdr-&gt;wsec_rate = cpu_to_le16(wsec_rate);
-}
-
-static s8 bcm43xx_rssi_postprocess(struct bcm43xx_private *bcm,
-				   u8 in_rssi, int ofdm,
-				   int adjust_2053, int adjust_2050)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	s32 tmp;
-
-	switch (radio-&gt;version) {
-	case 0x2050:
-		if (ofdm) {
-			tmp = in_rssi;
-			if (tmp &gt; 127)
-				tmp -= 256;
-			tmp *= 73;
-			tmp /= 64;
-			if (adjust_2050)
-				tmp += 25;
-			else
-				tmp -= 3;
-		} else {
-			if (bcm-&gt;sprom.boardflags &amp; BCM43xx_BFL_RSSI) {
-				if (in_rssi &gt; 63)
-					in_rssi = 63;
-				tmp = radio-&gt;nrssi_lt[in_rssi];
-				tmp = 31 - tmp;
-				tmp *= -131;
-				tmp /= 128;
-				tmp -= 57;
-			} else {
-				tmp = in_rssi;
-				tmp = 31 - tmp;
-				tmp *= -149;
-				tmp /= 128;
-				tmp -= 68;
-			}
-			if (phy-&gt;type == BCM43xx_PHYTYPE_G &amp;&amp;
-			    adjust_2050)
-				tmp += 25;
-		}
-		break;
-	case 0x2060:
-		if (in_rssi &gt; 127)
-			tmp = in_rssi - 256;
-		else
-			tmp = in_rssi;
-		break;
-	default:
-		tmp = in_rssi;
-		tmp -= 11;
-		tmp *= 103;
-		tmp /= 64;
-		if (adjust_2053)
-			tmp -= 109;
-		else
-			tmp -= 83;
-	}
-
-	return (s8)tmp;
-}
-
-//TODO
-#if 0
-static s8 bcm43xx_rssinoise_postprocess(struct bcm43xx_private *bcm,
-					u8 in_rssi)
-{
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	s8 ret;
-
-	if (phy-&gt;type == BCM43xx_PHYTYPE_A) {
-		//TODO: Incomplete specs.
-		ret = 0;
-	} else
-		ret = bcm43xx_rssi_postprocess(bcm, in_rssi, 0, 1, 1);
-
-	return ret;
-}
-#endif
-
-int bcm43xx_rx(struct bcm43xx_private *bcm,
-	       struct sk_buff *skb,
-	       struct bcm43xx_rxhdr *rxhdr)
-{
-	struct bcm43xx_radioinfo *radio = bcm43xx_current_radio(bcm);
-	struct bcm43xx_phyinfo *phy = bcm43xx_current_phy(bcm);
-	struct bcm43xx_plcp_hdr4 *plcp;
-	struct ieee80211_rx_stats stats;
-	struct ieee80211_hdr_4addr *wlhdr;
-	u16 frame_ctl;
-	int is_packet_for_us = 0;
-	int err = -EINVAL;
-	const u16 rxflags1 = le16_to_cpu(rxhdr-&gt;flags1);
-	const u16 rxflags2 = le16_to_cpu(rxhdr-&gt;flags2);
-	const u16 rxflags3 = le16_to_cpu(rxhdr-&gt;flags3);
-	const int is_ofdm = !!(rxflags1 &amp; BCM43xx_RXHDR_FLAGS1_OFDM);
-
-	if (rxflags2 &amp; BCM43xx_RXHDR_FLAGS2_TYPE2FRAME) {
-		plcp = (struct bcm43xx_plcp_hdr4 *)(skb-&gt;data + 2);
-		/* Skip two unknown bytes and the PLCP header. */
-		skb_pull(skb, 2 + sizeof(struct bcm43xx_plcp_hdr6));
-	} else {
-		plcp = (struct bcm43xx_plcp_hdr4 *)(skb-&gt;data);
-		/* Skip the PLCP header. */
-		skb_pull(skb, sizeof(struct bcm43xx_plcp_hdr6));
-	}
-	/* The SKB contains the PAYLOAD (wireless header + data)
-	 * at this point. The FCS at the end is stripped.
-	 */
-
-	memset(&amp;stats, 0, sizeof(stats));
-	stats.mac_time = le16_to_cpu(rxhdr-&gt;mactime);
-	stats.rssi = rxhdr-&gt;rssi;
-	stats.signal = bcm43xx_rssi_postprocess(bcm, rxhdr-&gt;rssi, is_ofdm,
-					      !!(rxflags1 &amp; BCM43xx_RXHDR_FLAGS1_2053RSSIADJ),
-					      !!(rxflags3 &amp; BCM43xx_RXHDR_FLAGS3_2050RSSIADJ));
-	stats.noise = bcm-&gt;stats.noise;
-	if (is_ofdm)
-		stats.rate = bcm43xx_plcp_get_bitrate_ofdm(plcp);
-	else
-		stats.rate = bcm43xx_plcp_get_bitrate_cck(plcp);
-	stats.received_channel = radio-&gt;channel;
-	stats.mask = IEEE80211_STATMASK_SIGNAL |
-		     IEEE80211_STATMASK_NOISE |
-		     IEEE80211_STATMASK_RATE |
-		     IEEE80211_STATMASK_RSSI;
-	if (phy-&gt;type == BCM43xx_PHYTYPE_A)
-		stats.freq = IEEE80211_52GHZ_BAND;
-	else
-		stats.freq = IEEE80211_24GHZ_BAND;
-	stats.len = skb-&gt;len;
-
-	bcm-&gt;stats.last_rx = jiffies;
-	if (bcm-&gt;ieee-&gt;iw_mode == IW_MODE_MONITOR) {
-		err = ieee80211_rx(bcm-&gt;ieee, skb, &amp;stats);
-		return (err == 0) ? -EINVAL : 0;
-	}
-
-	wlhdr = (struct ieee80211_hdr_4addr *)(skb-&gt;data);
-
-	switch (bcm-&gt;ieee-&gt;iw_mode) {
-	case IW_MODE_ADHOC:
-		if (memcmp(wlhdr-&gt;addr1, bcm-&gt;net_dev-&gt;dev_addr, ETH_ALEN) == 0 ||
-		    memcmp(wlhdr-&gt;addr3, bcm-&gt;ieee-&gt;bssid, ETH_ALEN) == 0 ||
-		    is_broadcast_ether_addr(wlhdr-&gt;addr1) ||
-		    is_multicast_ether_addr(wlhdr-&gt;addr1) ||
-		    bcm-&gt;net_dev-&gt;flags &amp; IFF_PROMISC)
-			is_packet_for_us = 1;
-		break;
-	case IW_MODE_INFRA:
-	default:
-		/* When receiving multicast or broadcast packets, filter out
-		   the packets we send ourself; we shouldn't see those */
-		if (memcmp(wlhdr-&gt;addr3, bcm-&gt;ieee-&gt;bssid, ETH_ALEN) == 0 ||
-		    memcmp(wlhdr-&gt;addr1, bcm-&gt;net_dev-&gt;dev_addr, ETH_ALEN) == 0 ||
-		    (memcmp(wlhdr-&gt;addr3, bcm-&gt;net_dev-&gt;dev_addr, ETH_ALEN) &amp;&amp;
-		     (is_broadcast_ether_addr(wlhdr-&gt;addr1) ||
-		      is_multicast_ether_addr(wlhdr-&gt;addr1) ||
-		      bcm-&gt;net_dev-&gt;flags &amp; IFF_PROMISC)))
-			is_packet_for_us = 1;
-		break;
-	}
-
-	frame_ctl = le16_to_cpu(wlhdr-&gt;frame_ctl);
-	switch (WLAN_FC_GET_TYPE(frame_ctl)) {
-	case IEEE80211_FTYPE_MGMT:
-		ieee80211_rx_mgt(bcm-&gt;ieee, wlhdr, &amp;stats);
-		break;
-	case IEEE80211_FTYPE_DATA:
-		if (is_packet_for_us) {
-			err = ieee80211_rx(bcm-&gt;ieee, skb, &amp;stats);
-			err = (err == 0) ? -EINVAL : 0;
-		}
-		break;
-	case IEEE80211_FTYPE_CTL:
-		break;
-	default:
-		assert(0);
-		return -EINVAL;
-	}
-
-	return err;
-}
Index: wireless-2.6/drivers/net/wireless/bcm43xx/bcm43xx_xmit.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/bcm43xx/bcm43xx_xmit.h
+++ /dev/null
@@ -1,150 +0,0 @@
-#ifndef BCM43xx_XMIT_H_
-#define BCM43xx_XMIT_H_
-
-#include &quot;bcm43xx_main.h&quot;
-
-
-#define _bcm43xx_declare_plcp_hdr(size) \
-	struct bcm43xx_plcp_hdr##size {		\
-		union {				\
-			__le32 data;		\
-			__u8 raw[size];		\
-		} __attribute__((__packed__));	\
-	} __attribute__((__packed__))
-
-/* struct bcm43xx_plcp_hdr4 */
-_bcm43xx_declare_plcp_hdr(4);
-/* struct bcm43xx_plcp_hdr6 */
-_bcm43xx_declare_plcp_hdr(6);
-
-#undef _bcm43xx_declare_plcp_hdr
-
-/* Device specific TX header. To be prepended to TX frames. */
-struct bcm43xx_txhdr {
-	union {
-		struct {
-			__le16 flags;
-			__le16 wsec_rate;
-			__le16 frame_control;
-			u16 unknown_zeroed_0;
-			__le16 control;
-			u8 wep_iv[10];
-			u8 unknown_wsec_tkip_data[3]; //FIXME
-			PAD_BYTES(3);
-			u8 mac1[6];
-			u16 unknown_zeroed_1;
-			struct bcm43xx_plcp_hdr4 rts_cts_fallback_plcp;
-			__le16 rts_cts_dur_fallback;
-			struct bcm43xx_plcp_hdr4 fallback_plcp;
-			__le16 fallback_dur_id;
-			PAD_BYTES(2);
-			__le16 cookie;
-			__le16 unknown_scb_stuff; //FIXME
-			struct bcm43xx_plcp_hdr6 rts_cts_plcp;
-			__le16 rts_cts_frame_control;
-			__le16 rts_cts_dur;
-			u8 rts_cts_mac1[6];
-			u8 rts_cts_mac2[6];
-			PAD_BYTES(2);
-			struct bcm43xx_plcp_hdr6 plcp;
-		} __attribute__((__packed__));
-		u8 raw[82];
-	} __attribute__((__packed__));
-} __attribute__((__packed__));
-
-/* Values/Masks for the device TX header */
-#define BCM43xx_TXHDRFLAG_EXPECTACK		0x0001
-#define BCM43xx_TXHDRFLAG_RTSCTS		0x0002
-#define BCM43xx_TXHDRFLAG_RTS			0x0004
-#define BCM43xx_TXHDRFLAG_FIRSTFRAGMENT		0x0008
-#define BCM43xx_TXHDRFLAG_DESTPSMODE		0x0020
-#define BCM43xx_TXHDRFLAG_RTSCTS_OFDM		0x0080
-#define BCM43xx_TXHDRFLAG_FALLBACKOFDM		0x0100
-#define BCM43xx_TXHDRFLAG_RTSCTSFALLBACK_OFDM	0x0200
-#define BCM43xx_TXHDRFLAG_CTS			0x0400
-#define BCM43xx_TXHDRFLAG_FRAMEBURST		0x0800
-
-#define BCM43xx_TXHDRCTL_OFDM			0x0001
-#define BCM43xx_TXHDRCTL_SHORT_PREAMBLE		0x0010
-#define BCM43xx_TXHDRCTL_ANTENNADIV_MASK	0x0030
-#define BCM43xx_TXHDRCTL_ANTENNADIV_SHIFT	8
-
-#define BCM43xx_TXHDR_RATE_MASK			0x0F00
-#define BCM43xx_TXHDR_RATE_SHIFT		8
-#define BCM43xx_TXHDR_RTSRATE_MASK		0xF000
-#define BCM43xx_TXHDR_RTSRATE_SHIFT		12
-#define BCM43xx_TXHDR_WSEC_KEYINDEX_MASK	0x00F0
-#define BCM43xx_TXHDR_WSEC_KEYINDEX_SHIFT	4
-#define BCM43xx_TXHDR_WSEC_ALGO_MASK		0x0003
-#define BCM43xx_TXHDR_WSEC_ALGO_SHIFT		0
-
-void bcm43xx_generate_txhdr(struct bcm43xx_private *bcm,
-			    struct bcm43xx_txhdr *txhdr,
-			    const unsigned char *fragment_data,
-			    const unsigned int fragment_len,
-			    const int is_first_fragment,
-			    const u16 cookie);
-
-/* RX header as received from the hardware. */
-struct bcm43xx_rxhdr {
-	/* Frame Length. Must be generated explicitly in PIO mode. */
-	__le16 frame_length;
-	PAD_BYTES(2);
-	/* Flags field 1 */
-	__le16 flags1;
-	u8 rssi;
-	u8 signal_quality;
-	PAD_BYTES(2);
-	/* Flags field 3 */
-	__le16 flags3;
-	/* Flags field 2 */
-	__le16 flags2;
-	/* Lower 16bits of the TSF at the time the frame started. */
-	__le16 mactime;
-	PAD_BYTES(14);
-} __attribute__((__packed__));
-
-#define BCM43xx_RXHDR_FLAGS1_OFDM		(1 &lt;&lt; 0)
-/*#define BCM43xx_RXHDR_FLAGS1_SIGNAL???	(1 &lt;&lt; 3) FIXME */
-#define BCM43xx_RXHDR_FLAGS1_SHORTPREAMBLE	(1 &lt;&lt; 7)
-#define BCM43xx_RXHDR_FLAGS1_2053RSSIADJ	(1 &lt;&lt; 14)
-
-#define BCM43xx_RXHDR_FLAGS2_INVALIDFRAME	(1 &lt;&lt; 0)
-#define BCM43xx_RXHDR_FLAGS2_TYPE2FRAME		(1 &lt;&lt; 2)
-/*FIXME: WEP related flags */
-
-#define BCM43xx_RXHDR_FLAGS3_2050RSSIADJ	(1 &lt;&lt; 10)
-
-/* Transmit Status as received from the hardware. */
-struct bcm43xx_hwxmitstatus {
-	PAD_BYTES(4);
-	__le16 cookie;
-	u8 flags;
-	u8 cnt1:4,
-	   cnt2:4;
-	PAD_BYTES(2);
-	__le16 seq;
-	__le16 unknown; //FIXME
-} __attribute__((__packed__));
-
-/* Transmit Status in CPU byteorder. */
-struct bcm43xx_xmitstatus {
-	u16 cookie;
-	u8 flags;
-	u8 cnt1:4,
-	   cnt2:4;
-	u16 seq;
-	u16 unknown; //FIXME
-};
-
-#define BCM43xx_TXSTAT_FLAG_AMPDU	0x10
-#define BCM43xx_TXSTAT_FLAG_INTER	0x20
-
-u8 bcm43xx_plcp_get_ratecode_cck(const u8 bitrate);
-u8 bcm43xx_plcp_get_ratecode_ofdm(const u8 bitrate);
-
-int bcm43xx_rx(struct bcm43xx_private *bcm,
-	       struct sk_buff *skb,
-	       struct bcm43xx_rxhdr *rxhdr);
-
-#endif /* BCM43xx_XMIT_H_ */
Index: wireless-2.6/Documentation/networking/bcm43xx.txt
===================================================================
--- wireless-2.6.orig/Documentation/networking/bcm43xx.txt
+++ /dev/null
@@ -1,89 +0,0 @@
-
-			BCM43xx Linux Driver Project
-			============================
-
-Introduction
-------------
-
-Many of the wireless devices found in modern notebook computers are
-based on the wireless chips produced by Broadcom. These devices have
-been a problem for Linux users as there is no open-source driver
-available. In addition, Broadcom has not released specifications
-for the device, and driver availability has been limited to the
-binary-only form used in the GPL versions of AP hardware such as the
-Linksys WRT54G, and the Windows and OS X drivers.  Before this project
-began, the only way to use these devices were to use the Windows or
-OS X drivers with either the Linuxant or ndiswrapper modules. There
-is a strong penalty if this method is used as loading the binary-only
-module &quot;taints&quot; the kernel, and no kernel developer will help diagnose
-any kernel problems.
-
-Development
------------
-
-This driver has been developed using
-a clean-room technique that is described at
-<A HREF="http://bcm-specs.sipsolutions.net/ReverseEngineeringProcess.">http://bcm-specs.sipsolutions.net/ReverseEngineeringProcess.</A> For legal
-reasons, none of the clean-room crew works on the on the Linux driver,
-and none of the Linux developers sees anything but the specifications,
-which are the ultimate product of the reverse-engineering group.
-
-Software
---------
-
-Since the release of the 2.6.17 kernel, the bcm43xx driver has been
-distributed with the kernel source, and is prebuilt in most, if not
-all, distributions.  There is, however, additional software that is
-required. The firmware used by the chip is the intellectual property
-of Broadcom and they have not given the bcm43xx team redistribution
-rights to this firmware.  Since we cannot legally redistribute
-the firmware we cannot include it with the driver. Furthermore, it
-cannot be placed in the downloadable archives of any distributing
-organization; therefore, the user is responsible for obtaining the
-firmware and placing it in the appropriate location so that the driver
-can find it when initializing.
-
-To help with this process, the bcm43xx developers provide a separate
-program named bcm43xx-fwcutter to &quot;cut&quot; the firmware out of a
-Windows or OS X driver and write the extracted files to the proper
-location. This program is usually provided with the distribution;
-however, it may be downloaded from
-
-<A HREF="http://developer.berlios.de/project/showfiles.php?group_id=4547">http://developer.berlios.de/project/showfiles.php?group_id=4547</A>
-
-The firmware is available in two versions. V3 firmware is used with
-the in-kernel bcm43xx driver that uses a software MAC layer called
-SoftMAC, and will have a microcode revision of 0x127 or smaller. The
-V4 firmware is used by an out-of-kernel driver employing a variation of
-the Devicescape MAC layer known as d80211. Once bcm43xx-d80211 reaches
-a satisfactory level of development, it will replace bcm43xx-softmac
-in the kernel as it is much more flexible and powerful.
-
-A source for the latest V3 firmware is
-
-<A HREF="http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o">http://downloads.openwrt.org/sources/wl_apsta-3.130.20.0.o</A>
-
-Once this file is downloaded, the command
-'bcm43xx-fwcutter -w &lt;dir&gt; &lt;filename&gt;'
-will extract the microcode and write it to directory
-&lt;dir&gt;. The correct directory will depend on your distribution;
-however, most use '/lib/firmware'. Once this step is completed,
-the bcm3xx driver should load when the system is booted. To see
-any messages relating to the driver, issue the command 'dmesg |
-grep bcm43xx' from a terminal window. If there are any problems,
-please send that output to <A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">Bcm43xx-dev at lists.berlios.de.</A>
-
-Although the driver has been in-kernel since 2.6.17, the earliest
-version is quite limited in its capability. Patches that include
-all features of later versions are available for the stable kernel
-versions from 2.6.18. These will be needed if you use a BCM4318,
-or a PCI Express version (BCM4311 and BCM4312). In addition, if you
-have an early BCM4306 and more than 1 GB RAM, your kernel will need
-to be patched.	These patches, which are being updated regularly,
-are available at <A HREF="ftp://lwfinger.dynalias.org/patches.">ftp://lwfinger.dynalias.org/patches.</A> Look for
-combined_2.6.YY.patch. Of course you will need kernel source downloaded
-from kernel.org, or the source from your distribution.
-
-If you build your own kernel, please enable CONFIG_BCM43XX_DEBUG
-and CONFIG_IEEE80211_SOFTMAC_DEBUG. The log information provided is
-essential for solving any problems.
Index: wireless-2.6/MAINTAINERS
===================================================================
--- wireless-2.6.orig/MAINTAINERS
+++ wireless-2.6/MAINTAINERS
@@ -821,15 +821,6 @@ L:	<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">linux-wireless at vger.kernel.org</A>
 W:	<A HREF="http://linuxwireless.org/en/users/Drivers/b43">http://linuxwireless.org/en/users/Drivers/b43</A>
 S:	Maintained
 
-BCM43XX WIRELESS DRIVER (SOFTMAC BASED VERSION)
-P:	Larry Finger
-M:	<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">Larry.Finger at lwfinger.net</A>
-P:	Stefano Brivio
-M:	<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">stefano.brivio at polimi.it</A>
-L:	<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">linux-wireless at vger.kernel.org</A>
-W:	<A HREF="http://bcm43xx.berlios.de/">http://bcm43xx.berlios.de/</A>
-S:	Maintained
-
 BEFS FILE SYSTEM
 P:	Sergey S. Kostyliov
 M:	<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">rathamahata at php4.ru</A>
Index: wireless-2.6/drivers/net/wireless/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/Kconfig
+++ wireless-2.6/drivers/net/wireless/Kconfig
@@ -629,7 +629,6 @@ config ATH5K
 
 source &quot;drivers/net/wireless/iwlwifi/Kconfig&quot;
 source &quot;drivers/net/wireless/hostap/Kconfig&quot;
-source &quot;drivers/net/wireless/bcm43xx/Kconfig&quot;
 source &quot;drivers/net/wireless/b43/Kconfig&quot;
 source &quot;drivers/net/wireless/b43legacy/Kconfig&quot;
 source &quot;drivers/net/wireless/zd1211rw/Kconfig&quot;
Index: wireless-2.6/drivers/net/wireless/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/Makefile
+++ wireless-2.6/drivers/net/wireless/Makefile
@@ -37,7 +37,6 @@ obj-$(CONFIG_USB_ATMEL)	        += at76_
 obj-$(CONFIG_PRISM54)		+= prism54/
 
 obj-$(CONFIG_HOSTAP)		+= hostap/
-obj-$(CONFIG_BCM43XX)		+= bcm43xx/
 obj-$(CONFIG_B43)		+= b43/
 obj-$(CONFIG_B43LEGACY)		+= b43legacy/
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c
+++ wireless-2.6/drivers/net/wireless/b43/main.c
@@ -1558,7 +1558,7 @@ static void b43_release_firmware(struct 
 static void b43_print_fw_helptext(struct b43_wl *wl)
 {
 	b43err(wl, &quot;You must go to &quot;
-	       &quot;<A HREF="http://linuxwireless.org/en/users/Drivers/bcm43xx#devicefirmware">http://linuxwireless.org/en/users/Drivers/bcm43xx#devicefirmware</A> &quot;
+	       &quot;<A HREF="http://linuxwireless.org/en/users/Drivers/b43#devicefirmware">http://linuxwireless.org/en/users/Drivers/b43#devicefirmware</A> &quot;
 	       &quot;and download the correct firmware (version 4).\n&quot;);
 }
 
Index: wireless-2.6/drivers/net/wireless/b43legacy/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/dma.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/dma.c
@@ -996,7 +996,7 @@ int b43legacy_dma_init(struct b43legacy_
 
 	err = ssb_dma_set_mask(dev-&gt;dev, dmamask);
 	if (err) {
-#ifdef BCM43XX_PIO
+#ifdef CONFIG_B43LEGACY_PIO
 		b43legacywarn(dev-&gt;wl, &quot;DMA for this device not supported. &quot;
 			&quot;Falling back to PIO\n&quot;);
 		dev-&gt;__using_pio = 1;
Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c
@@ -1398,7 +1398,7 @@ static void b43legacy_release_firmware(s
 static void b43legacy_print_fw_helptext(struct b43legacy_wl *wl)
 {
 	b43legacyerr(wl, &quot;You must go to <A HREF="http://linuxwireless.org/en/users/">http://linuxwireless.org/en/users/</A>&quot;
-		     &quot;Drivers/bcm43xx#devicefirmware &quot;
+		     &quot;Drivers/b43#devicefirmware &quot;
 		     &quot;and download the correct firmware (version 3).\n&quot;);
 }
 


-- 
Ciao
Stefano

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002800.html">[Bugme-new] [Bug 9402] New: Not work chipset broadcom 4318
</A></li>
	<LI>Next message: <A HREF="002804.html">[PATCH] remove bcm43xx
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2801">[ date ]</a>
              <a href="thread.html#2801">[ thread ]</a>
              <a href="subject.html#2801">[ subject ]</a>
              <a href="author.html#2801">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/bcm43xx-dev">More information about the Bcm43xx-dev
mailing list</a><br>
</body></html>
