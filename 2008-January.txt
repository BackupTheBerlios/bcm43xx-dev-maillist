From mb at bu3sch.de  Wed Jan  2 18:55:53 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 2 Jan 2008 18:55:53 +0100
Subject: [PATCH] b43: Fix rxheader channel parsing
Message-ID: <200801021855.53410.mb@bu3sch.de>

This patch fixes the parsing of the RX data header channel field.

The current code parses the header incorrectly and passes a wrong
channel number and frequency for each frame to mac80211.
The FIXMEs added by this patch don't matter for now as the code
where they live won't get executed anyway. They will be fixed later.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, as this is a bugfix, it should go into 2.6.24 if still possible.

Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c	2007-12-30 20:30:03.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/xmit.c	2008-01-02 18:13:15.000000000 +0100
@@ -549,21 +549,32 @@ void b43_rx(struct b43_wldev *dev, struc
 	switch (chanstat & B43_RX_CHAN_PHYTYPE) {
 	case B43_PHYTYPE_A:
 		status.phymode = MODE_IEEE80211A;
-		status.freq = chanid;
-		status.channel = b43_freq_to_channel_a(chanid);
-		break;
-	case B43_PHYTYPE_B:
-		status.phymode = MODE_IEEE80211B;
-		status.freq = chanid + 2400;
-		status.channel = b43_freq_to_channel_bg(chanid + 2400);
+		B43_WARN_ON(1);
+		/* FIXME: We don't really know which value the "chanid" contains.
+		 *        So the following assignment might be wrong. */
+		status.channel = chanid;
+		status.freq = b43_channel_to_freq_5ghz(status.channel);
 		break;
 	case B43_PHYTYPE_G:
 		status.phymode = MODE_IEEE80211G;
+		/* chanid is the radio channel cookie value as used
+		 * to tune the radio. */
 		status.freq = chanid + 2400;
-		status.channel = b43_freq_to_channel_bg(chanid + 2400);
+		status.channel = b43_freq_to_channel_2ghz(status.freq);
+		break;
+	case B43_PHYTYPE_N:
+		status.phymode = 0xDEAD /*FIXME MODE_IEEE80211N*/;
+		/* chanid is the SHM channel cookie. Which is the plain
+		 * channel number in b43. */
+		status.channel = chanid;
+		if (chanstat & B43_RX_CHAN_5GHZ)
+			status.freq = b43_freq_to_channel_5ghz(status.freq);
+		else
+			status.freq = b43_freq_to_channel_2ghz(status.freq);
 		break;
 	default:
 		B43_WARN_ON(1);
+		goto drop;
 	}
 
 	dev->stats.last_rx = jiffies;
Index: wireless-2.6/drivers/net/wireless/b43/xmit.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.h	2007-12-30 20:30:03.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/xmit.h	2008-01-02 16:42:24.000000000 +0100
@@ -142,49 +142,56 @@ struct b43_rxhdr_fw4 {
 } __attribute__ ((__packed__));
 
 /* PHY RX Status 0 */
-#define B43_RX_PHYST0_GAINCTL	0x4000	/* Gain Control */
-#define B43_RX_PHYST0_PLCPHCF	0x0200
-#define B43_RX_PHYST0_PLCPFV	0x0100
-#define B43_RX_PHYST0_SHORTPRMBL	0x0080	/* Received with Short Preamble */
+#define B43_RX_PHYST0_GAINCTL		0x4000 /* Gain Control */
+#define B43_RX_PHYST0_PLCPHCF		0x0200
+#define B43_RX_PHYST0_PLCPFV		0x0100
+#define B43_RX_PHYST0_SHORTPRMBL	0x0080 /* Received with Short Preamble */
 #define B43_RX_PHYST0_LCRS		0x0040
-#define B43_RX_PHYST0_ANT		0x0020	/* Antenna */
-#define B43_RX_PHYST0_UNSRATE	0x0010
+#define B43_RX_PHYST0_ANT		0x0020 /* Antenna */
+#define B43_RX_PHYST0_UNSRATE		0x0010
 #define B43_RX_PHYST0_CLIP		0x000C
 #define B43_RX_PHYST0_CLIP_SHIFT	2
-#define B43_RX_PHYST0_FTYPE		0x0003	/* Frame type */
-#define  B43_RX_PHYST0_CCK		0x0000	/* Frame type: CCK */
-#define  B43_RX_PHYST0_OFDM		0x0001	/* Frame type: OFDM */
-#define  B43_RX_PHYST0_PRE_N	0x0002	/* Pre-standard N-PHY frame */
-#define  B43_RX_PHYST0_STD_N	0x0003	/* Standard N-PHY frame */
+#define B43_RX_PHYST0_FTYPE		0x0003 /* Frame type */
+#define  B43_RX_PHYST0_CCK		0x0000 /* Frame type: CCK */
+#define  B43_RX_PHYST0_OFDM		0x0001 /* Frame type: OFDM */
+#define  B43_RX_PHYST0_PRE_N		0x0002 /* Pre-standard N-PHY frame */
+#define  B43_RX_PHYST0_STD_N		0x0003 /* Standard N-PHY frame */
 
 /* PHY RX Status 2 */
-#define B43_RX_PHYST2_LNAG		0xC000	/* LNA Gain */
+#define B43_RX_PHYST2_LNAG		0xC000 /* LNA Gain */
 #define B43_RX_PHYST2_LNAG_SHIFT	14
-#define B43_RX_PHYST2_PNAG		0x3C00	/* PNA Gain */
+#define B43_RX_PHYST2_PNAG		0x3C00 /* PNA Gain */
 #define B43_RX_PHYST2_PNAG_SHIFT	10
-#define B43_RX_PHYST2_FOFF		0x03FF	/* F offset */
+#define B43_RX_PHYST2_FOFF		0x03FF /* F offset */
 
 /* PHY RX Status 3 */
-#define B43_RX_PHYST3_DIGG		0x1800	/* DIG Gain */
+#define B43_RX_PHYST3_DIGG		0x1800 /* DIG Gain */
 #define B43_RX_PHYST3_DIGG_SHIFT	11
-#define B43_RX_PHYST3_TRSTATE	0x0400	/* TR state */
+#define B43_RX_PHYST3_TRSTATE		0x0400 /* TR state */
 
 /* MAC RX Status */
-#define B43_RX_MAC_BEACONSENT	0x00008000	/* Beacon send flag */
-#define B43_RX_MAC_KEYIDX		0x000007E0	/* Key index */
-#define B43_RX_MAC_KEYIDX_SHIFT	5
-#define B43_RX_MAC_DECERR		0x00000010	/* Decrypt error */
-#define B43_RX_MAC_DEC		0x00000008	/* Decryption attempted */
-#define B43_RX_MAC_PADDING		0x00000004	/* Pad bytes present */
-#define B43_RX_MAC_RESP		0x00000002	/* Response frame transmitted */
-#define B43_RX_MAC_FCSERR		0x00000001	/* FCS error */
+#define B43_RX_MAC_RXST_VALID		0x01000000 /* PHY RXST valid */
+#define B43_RX_MAC_TKIP_MICERR		0x00100000 /* TKIP MIC error */
+#define B43_RX_MAC_TKIP_MICATT		0x00080000 /* TKIP MIC attempted */
+#define B43_RX_MAC_AGGTYPE		0x00060000 /* Aggregation type */
+#define B43_RX_MAC_AGGTYPE_SHIFT	17
+#define B43_RX_MAC_AMSDU		0x00010000 /* A-MSDU mask */
+#define B43_RX_MAC_BEACONSENT		0x00008000 /* Beacon sent flag */
+#define B43_RX_MAC_KEYIDX		0x000007E0 /* Key index */
+#define B43_RX_MAC_KEYIDX_SHIFT		5
+#define B43_RX_MAC_DECERR		0x00000010 /* Decrypt error */
+#define B43_RX_MAC_DEC			0x00000008 /* Decryption attempted */
+#define B43_RX_MAC_PADDING		0x00000004 /* Pad bytes present */
+#define B43_RX_MAC_RESP			0x00000002 /* Response frame transmitted */
+#define B43_RX_MAC_FCSERR		0x00000001 /* FCS error */
 
 /* RX channel */
-#define B43_RX_CHAN_GAIN		0xFC00	/* Gain */
-#define B43_RX_CHAN_GAIN_SHIFT	10
-#define B43_RX_CHAN_ID		0x03FC	/* Channel ID */
-#define B43_RX_CHAN_ID_SHIFT	2
-#define B43_RX_CHAN_PHYTYPE		0x0003	/* PHY type */
+#define B43_RX_CHAN_40MHZ		0x1000 /* 40 Mhz channel width */
+#define B43_RX_CHAN_5GHZ		0x0800 /* 5 Ghz band */
+#define B43_RX_CHAN_ID			0x07F8 /* Channel ID */
+#define B43_RX_CHAN_ID_SHIFT		3
+#define B43_RX_CHAN_PHYTYPE		0x0007 /* PHY type */
+
 
 u8 b43_plcp_get_ratecode_cck(const u8 bitrate);
 u8 b43_plcp_get_ratecode_ofdm(const u8 bitrate);
Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h	2007-12-28 23:38:44.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/b43.h	2008-01-02 17:23:18.000000000 +0100
@@ -277,6 +277,8 @@ enum {
 #define B43_PHYTYPE_A			0x00
 #define B43_PHYTYPE_B			0x01
 #define B43_PHYTYPE_G			0x02
+#define B43_PHYTYPE_N			0x04
+#define B43_PHYTYPE_LP			0x05
 
 /* PHYRegisters */
 #define B43_PHY_ILT_A_CTRL		0x0072
Index: wireless-2.6/drivers/net/wireless/b43/main.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.h	2007-12-28 23:38:43.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.h	2008-01-02 18:08:39.000000000 +0100
@@ -39,11 +39,11 @@
 #define PAD_BYTES(nr_bytes)		P4D_BYTES( __LINE__ , (nr_bytes))
 
 /* Lightweight function to convert a frequency (in Mhz) to a channel number. */
-static inline u8 b43_freq_to_channel_a(int freq)
+static inline u8 b43_freq_to_channel_5ghz(int freq)
 {
 	return ((freq - 5000) / 5);
 }
-static inline u8 b43_freq_to_channel_bg(int freq)
+static inline u8 b43_freq_to_channel_2ghz(int freq)
 {
 	u8 channel;
 
@@ -54,19 +54,13 @@ static inline u8 b43_freq_to_channel_bg(
 
 	return channel;
 }
-static inline u8 b43_freq_to_channel(struct b43_wldev *dev, int freq)
-{
-	if (dev->phy.type == B43_PHYTYPE_A)
-		return b43_freq_to_channel_a(freq);
-	return b43_freq_to_channel_bg(freq);
-}
 
 /* Lightweight function to convert a channel number to a frequency (in Mhz). */
-static inline int b43_channel_to_freq_a(u8 channel)
+static inline int b43_channel_to_freq_5ghz(u8 channel)
 {
 	return (5000 + (5 * channel));
 }
-static inline int b43_channel_to_freq_bg(u8 channel)
+static inline int b43_channel_to_freq_2ghz(u8 channel)
 {
 	int freq;
 
@@ -77,12 +71,6 @@ static inline int b43_channel_to_freq_bg
 
 	return freq;
 }
-static inline int b43_channel_to_freq(struct b43_wldev *dev, u8 channel)
-{
-	if (dev->phy.type == B43_PHYTYPE_A)
-		return b43_channel_to_freq_a(channel);
-	return b43_channel_to_freq_bg(channel);
-}
 
 static inline int b43_is_cck_rate(int rate)
 {


From larry.finger at lwfinger.net  Wed Jan  2 19:52:08 2008
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 02 Jan 2008 10:52:08 -0800
Subject: [PATCH] b43: Fix rxheader channel parsing
In-Reply-To: <200801021855.53410.mb@bu3sch.de>
References: <200801021855.53410.mb@bu3sch.de>
Message-ID: <477BDD58.9050702@lwfinger.net>

Michael Buesch wrote:
> This patch fixes the parsing of the RX data header channel field.
> 
> The current code parses the header incorrectly and passes a wrong
> channel number and frequency for each frame to mac80211.
> The FIXMEs added by this patch don't matter for now as the code
> where they live won't get executed anyway. They will be fixed later.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> ---
> 
> John, as this is a bugfix, it should go into 2.6.24 if still possible.
> 
> Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c	2007-12-30 20:30:03.000000000 +0100
> +++ wireless-2.6/drivers/net/wireless/b43/xmit.c	2008-01-02 18:13:15.000000000 +0100
> @@ -549,21 +549,32 @@ void b43_rx(struct b43_wldev *dev, struc
>  	switch (chanstat & B43_RX_CHAN_PHYTYPE) {
>  	case B43_PHYTYPE_A:
>  		status.phymode = MODE_IEEE80211A;
> -		status.freq = chanid;
> -		status.channel = b43_freq_to_channel_a(chanid);
> -		break;
> -	case B43_PHYTYPE_B:
> -		status.phymode = MODE_IEEE80211B;
> -		status.freq = chanid + 2400;
> -		status.channel = b43_freq_to_channel_bg(chanid + 2400);
> +		B43_WARN_ON(1);
> +		/* FIXME: We don't really know which value the "chanid" contains.
> +		 *        So the following assignment might be wrong. */
> +		status.channel = chanid;
> +		status.freq = b43_channel_to_freq_5ghz(status.channel);
>  		break;

Shouldn't you just drop this case? No B PHY devices will ever use b43 and the default branch will
issue the WARN_ON anyway.

Larry



From mb at bu3sch.de  Wed Jan  2 20:02:58 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 2 Jan 2008 20:02:58 +0100
Subject: [PATCH] b43: Fix rxheader channel parsing
In-Reply-To: <477BDD58.9050702@lwfinger.net>
References: <200801021855.53410.mb@bu3sch.de> <477BDD58.9050702@lwfinger.net>
Message-ID: <200801022002.58434.mb@bu3sch.de>

On Wednesday 02 January 2008 19:52:08 Larry Finger wrote:
> Michael Buesch wrote:
> > This patch fixes the parsing of the RX data header channel field.
> > 
> > The current code parses the header incorrectly and passes a wrong
> > channel number and frequency for each frame to mac80211.
> > The FIXMEs added by this patch don't matter for now as the code
> > where they live won't get executed anyway. They will be fixed later.
> > 
> > Signed-off-by: Michael Buesch <mb at bu3sch.de>
> > 
> > ---
> > 
> > John, as this is a bugfix, it should go into 2.6.24 if still possible.
> > 
> > Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
> > ===================================================================
> > --- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c	2007-12-30 20:30:03.000000000 +0100
> > +++ wireless-2.6/drivers/net/wireless/b43/xmit.c	2008-01-02 18:13:15.000000000 +0100
> > @@ -549,21 +549,32 @@ void b43_rx(struct b43_wldev *dev, struc
> >  	switch (chanstat & B43_RX_CHAN_PHYTYPE) {
> >  	case B43_PHYTYPE_A:
> >  		status.phymode = MODE_IEEE80211A;
> > -		status.freq = chanid;
> > -		status.channel = b43_freq_to_channel_a(chanid);
> > -		break;
> > -	case B43_PHYTYPE_B:
> > -		status.phymode = MODE_IEEE80211B;
> > -		status.freq = chanid + 2400;
> > -		status.channel = b43_freq_to_channel_bg(chanid + 2400);
> > +		B43_WARN_ON(1);
> > +		/* FIXME: We don't really know which value the "chanid" contains.
> > +		 *        So the following assignment might be wrong. */
> > +		status.channel = chanid;
> > +		status.freq = b43_channel_to_freq_5ghz(status.channel);
> >  		break;
> 
> Shouldn't you just drop this case? No B PHY devices will ever use b43 and the default branch will
> issue the WARN_ON anyway.

I guess you misread the patch.

-- 
Greetings Michael.


From gavron at wetwork.net  Wed Jan  2 20:37:41 2008
From: gavron at wetwork.net (Ehud Gavron)
Date: Wed, 02 Jan 2008 12:37:41 -0700
Subject: [PATCH] b43: Fix rxheader channel parsing
In-Reply-To: <200801022002.58434.mb@bu3sch.de>
References: <200801021855.53410.mb@bu3sch.de> <477BDD58.9050702@lwfinger.net>
	<200801022002.58434.mb@bu3sch.de>
Message-ID: <477BE805.9020500@wetwork.net>

Happy New Year, Michael!

:)

Ehud

Michael Buesch wrote:
> On Wednesday 02 January 2008 19:52:08 Larry Finger wrote:
>   
>> Michael Buesch wrote:
>>     
>>> This patch fixes the parsing of the RX data header channel field.
>>>
>>> The current code parses the header incorrectly and passes a wrong
>>> channel number and frequency for each frame to mac80211.
>>> The FIXMEs added by this patch don't matter for now as the code
>>> where they live won't get executed anyway. They will be fixed later.
>>>
>>> Signed-off-by: Michael Buesch <mb at bu3sch.de>
>>>
>>> ---
>>>
>>> John, as this is a bugfix, it should go into 2.6.24 if still possible.
>>>
>>> Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
>>> ===================================================================
>>> --- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c	2007-12-30 20:30:03.000000000 +0100
>>> +++ wireless-2.6/drivers/net/wireless/b43/xmit.c	2008-01-02 18:13:15.000000000 +0100
>>> @@ -549,21 +549,32 @@ void b43_rx(struct b43_wldev *dev, struc
>>>  	switch (chanstat & B43_RX_CHAN_PHYTYPE) {
>>>  	case B43_PHYTYPE_A:
>>>  		status.phymode = MODE_IEEE80211A;
>>> -		status.freq = chanid;
>>> -		status.channel = b43_freq_to_channel_a(chanid);
>>> -		break;
>>> -	case B43_PHYTYPE_B:
>>> -		status.phymode = MODE_IEEE80211B;
>>> -		status.freq = chanid + 2400;
>>> -		status.channel = b43_freq_to_channel_bg(chanid + 2400);
>>> +		B43_WARN_ON(1);
>>> +		/* FIXME: We don't really know which value the "chanid" contains.
>>> +		 *        So the following assignment might be wrong. */
>>> +		status.channel = chanid;
>>> +		status.freq = b43_channel_to_freq_5ghz(status.channel);
>>>  		break;
>>>       
>> Shouldn't you just drop this case? No B PHY devices will ever use b43 and the default branch will
>> issue the WARN_ON anyway.
>>     
>
> I guess you misread the patch.
>
>   


From larry.finger at lwfinger.net  Wed Jan  2 20:47:52 2008
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 02 Jan 2008 11:47:52 -0800
Subject: [PATCH] b43: Fix rxheader channel parsing
In-Reply-To: <200801022002.58434.mb@bu3sch.de>
References: <200801021855.53410.mb@bu3sch.de> <477BDD58.9050702@lwfinger.net>
	<200801022002.58434.mb@bu3sch.de>
Message-ID: <477BEA68.7090201@lwfinger.net>

Michael Buesch wrote:
>> Shouldn't you just drop this case? No B PHY devices will ever use b43 and the default branch will
>> issue the WARN_ON anyway.
> 
> I guess you misread the patch.
> 

I did indeed. Sorry.

Larry



From mb at bu3sch.de  Wed Jan  2 20:52:39 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 2 Jan 2008 20:52:39 +0100
Subject: [PATCH] b43: Fix rxheader channel parsing
In-Reply-To: <477BE805.9020500@wetwork.net>
References: <200801021855.53410.mb@bu3sch.de> <200801022002.58434.mb@bu3sch.de>
	<477BE805.9020500@wetwork.net>
Message-ID: <200801022052.40138.mb@bu3sch.de>

On Wednesday 02 January 2008 20:37:41 Ehud Gavron wrote:
> Happy New Year, Michael!
> 
> :)

Yeah, thanks. :)

Happy New Year to everyone on the list.
Let's work on making The Linux Wireless Year (tm) out of it.

-- 
Greetings Michael.


From identd_ at hotmail.com  Wed Jan  2 21:18:29 2008
From: identd_ at hotmail.com (David Ellingsworth)
Date: Wed, 2 Jan 2008 15:18:29 -0500
Subject: Device busy error
Message-ID: <BAY128-W1687309A0E6A4DA54DF3A386520@phx.gbl>


While using the b43legacy driver with my 4306 card, wpa_supplicant and iwconfig both report that the device is busy when trying to switch from monitor mode to managed mode after having used kismet or airodump-ng. So far the only resolution to the issue has been to rmmod and then modprobe the driver again. Any help in finding the cause of the error would be appreciated.

Regards,

David Ellingsworth
_________________________________________________________________
Don't get caught with egg on your face. Play Chicktionary!
http://club.live.com/chicktionary.aspx?icid=chick_wlhmtextlink1_dec

From mb at bu3sch.de  Wed Jan  2 22:03:40 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 2 Jan 2008 22:03:40 +0100
Subject: Device busy error
In-Reply-To: <BAY128-W1687309A0E6A4DA54DF3A386520@phx.gbl>
References: <BAY128-W1687309A0E6A4DA54DF3A386520@phx.gbl>
Message-ID: <200801022203.40327.mb@bu3sch.de>

On Wednesday 02 January 2008 21:18:29 David Ellingsworth wrote:
> 
> While using the b43legacy driver with my 4306 card, wpa_supplicant and iwconfig both report that the device is busy when trying to switch from monitor mode to managed mode after having used kismet or airodump-ng. So far the only resolution to the issue has been to rmmod and then modprobe the driver again. Any help in finding the cause of the error would be appreciated.

ifconfig wlanX down
before switching modes.

-- 
Greetings Michael.


From mb at bu3sch.de  Wed Jan  2 22:10:07 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 2 Jan 2008 22:10:07 +0100
Subject: Device busy error
Message-ID: <200801022210.07829.mb@bu3sch.de>

You have a bogus
Reply-To: david at identd.dyndns.org
inside of your mailheaders, which confuses mailclients.
See the attached bounce.

-- 
Greetings Michael.
-------------- next part --------------
This message was created automatically by mail delivery software.

A message that you sent could not be delivered to one or more of its
recipients. This is a permanent error. The following address(es) failed:

  david at identd.dyndns.org
    Unrouteable address

------ This is a copy of the message, including all the headers. ------

Return-path: <mb at bu3sch.de>
Received: from t1fa0.t.pppool.de ([89.55.31.160] helo=powermac.local)
	by vs166246.vserver.de with esmtpa (Exim 4.63)
	(envelope-from <mb at bu3sch.de>)
	id 1JAAl5-0004Yv-Ft; Wed, 02 Jan 2008 21:04:15 +0000
From: Michael Buesch <mb at bu3sch.de>
To: bcm43xx-dev at lists.berlios.de,
 david at identd.dyndns.org
Subject: Re: Device busy error
Date: Wed, 2 Jan 2008 22:03:40 +0100
User-Agent: KMail/1.9.6
References: <BAY128-W1687309A0E6A4DA54DF3A386520 at phx.gbl>
In-Reply-To: <BAY128-W1687309A0E6A4DA54DF3A386520 at phx.gbl>
MIME-Version: 1.0
Content-Type: text/plain;
  charset="iso-8859-1"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline
Message-Id: <200801022203.40327.mb at bu3sch.de>

On Wednesday 02 January 2008 21:18:29 David Ellingsworth wrote:
> 
> While using the b43legacy driver with my 4306 card, wpa_supplicant and iwconfig both report that the device is busy when trying to switch from monitor mode to managed mode after having used kismet or airodump-ng. So far the only resolution to the issue has been to rmmod and then modprobe the driver again. Any help in finding the cause of the error would be appreciated.

ifconfig wlanX down
before switching modes.

-- 
Greetings Michael.


From mb at bu3sch.de  Thu Jan  3 18:59:25 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 3 Jan 2008 18:59:25 +0100
Subject: [PATCH] ssb: Fix probing of PCI cores if PCI and PCIE core is
	available
Message-ID: <200801031859.25596.mb@bu3sch.de>

This will make sure that always the correct core is selected, even if
there are both a PCI and PCI-E core on a PCI or PCI-E card.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, as this is a bugfix it should probably go into 2.6.24.

Index: wireless-2.6/drivers/ssb/scan.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/scan.c	2008-01-02 18:49:22.000000000 +0100
+++ wireless-2.6/drivers/ssb/scan.c	2008-01-03 18:56:30.000000000 +0100
@@ -388,6 +388,17 @@ int ssb_bus_scan(struct ssb_bus *bus,
 		case SSB_DEV_PCI:
 		case SSB_DEV_PCIE:
 #ifdef CONFIG_SSB_DRIVER_PCICORE
+			if (bus->bustype == SSB_BUSTYPE_PCI) {
+				/* Ignore PCI cores on PCI-E cards.
+				 * Ignore PCI-E cores on PCI cards. */
+				if (dev->id.coreid == SSB_DEV_PCI) {
+					if (bus->host_pci->is_pcie)
+						continue;
+				} else {
+					if (!bus->host_pci->is_pcie)
+						continue;
+				}
+			}
 			if (bus->pcicore.dev) {
 				ssb_printk(KERN_WARNING PFX
 					   "WARNING: Multiple PCI(E) cores found\n");


From mb at bu3sch.de  Thu Jan  3 19:03:09 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 3 Jan 2008 19:03:09 +0100
Subject: [PATCH] b43-ssb-bridge: Add PCI ID for BCM43XG
Message-ID: <200801031903.10070.mb@bu3sch.de>

This adds the PCI ID 0x4329 for the BCM43XG.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, this is stuff for 2.6.25

Index: wireless-2.6/drivers/ssb/b43_pci_bridge.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/b43_pci_bridge.c	2007-12-11 01:08:40.000000000 +0100
+++ wireless-2.6/drivers/ssb/b43_pci_bridge.c	2008-01-03 18:08:44.000000000 +0100
@@ -28,6 +28,7 @@ static const struct pci_device_id b43_pc
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4324) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4325) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4328) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4329) },
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, b43_pci_bridge_tbl);


From seandarcy2 at gmail.com  Fri Jan  4 02:17:37 2008
From: seandarcy2 at gmail.com (sean darcy)
Date: Thu, 3 Jan 2008 20:17:37 -0500
Subject: b43 won't connect to access point: deauthentication reason=7 ??
Message-ID: <c195ebf70801031717r7875fba3y9fb058d5dba5e007@mail.gmail.com>

On Fedora 8 I'm having trouble getting my 4311 to connect to the access point:

uname -r
2.6.23.9-85.fc8

lspci -n
04:00.0 Network controller [0280]: Broadcom Corporation BCM94311MCG
wlan mini-PCI [14e4:4311] (rev 01)

cat /etc/sysconfig/network-scripts/ifcfg-wlan0
DEVICE=wlan0
BOOTPROTO=dhcp
ONBOOT=yes
TYPE=Wireless
ESSID=belkin

All the right kmods seem to be loaded:

lsmod | grep b43
b43                   133221  0
rfkill                  9297  2 b43
mac80211              115789  1 b43
input_polldev           7369  1 b43
ssb                    30149  1 b43

and the iw tools work OK:

iwconfig wlan0
wlan0     IEEE 802.11g  ESSID:"belkin"
          Mode:Managed  Frequency:2.412 GHz  Access Point: 00:11:50:22:95:52
          Bit Rate=1 Mb/s   Tx-Power=27 dBm
          Retry min limit:7   RTS thr:off   Fragment thr=2352 B
          Encryption key:off
          Link Quality=65/100  Signal level=-70 dBm  Noise level=-73 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

iwlist wlan0 scan
wlan0     Scan completed :
          Cell 01 - Address: 00:11:50:22:95:52
                    ESSID:"belkin"
                    Mode:Master
                    Channel:1
                    Frequency:2.412 GHz (Channel 1)
                    Quality=81/100  Signal level=-45 dBm  Noise level=-73 dBm
                    Encryption key:off
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s
                              9 Mb/s; 12 Mb/s; 18 Mb/s; 24 Mb/s; 36 Mb/s
                              48 Mb/s; 54 Mb/s
                    Extra:tsf=0000008d74d0946c
          Cell 02 - Address: 00:16:B6:2E:BA:B7
                    ESSID:"paulc"
                    Mode:Master
                    Channel:6
                    Frequency:2.437 GHz (Channel 6)
                    Quality=56/100  Signal level=-83 dBm  Noise level=-73 dBm
                    Encryption key:off
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 18 Mb/s
                              24 Mb/s; 36 Mb/s; 54 Mb/s; 6 Mb/s; 9 Mb/s
                              12 Mb/s; 48 Mb/s
                    Extra:tsf=00000089fb5f7939

but ifup wlan0 fails:

dmesg | grep wlan0
ADDRCONF(NETDEV_UP): wlan0: link is not ready
wlan0: Initial auth_alg=0
wlan0: authenticate with AP 00:11:50:22:95:52
wlan0: RX authentication from 00:11:50:22:95:52 (alg=0 transaction=2 status=0)
wlan0: authenticated
wlan0: associate with AP 00:11:50:22:95:52
wlan0: RX AssocResp from 00:11:50:22:95:52 (capab=0x601 status=0 aid=2)
wlan0: associated
wlan0: switched to short barker preamble (BSSID=00:11:50:22:95:52)
wlan0: WMM queue=2 aci=0 acm=0 aifs=2 cWmin=15 cWmax=1023 burst=32
wlan0: WMM queue=3 aci=1 acm=0 aifs=7 cWmin=15 cWmax=1023 burst=0
wlan0: WMM queue=1 aci=2 acm=0 aifs=2 cWmin=7 cWmax=15 burst=64
wlan0: WMM queue=0 aci=3 acm=0 aifs=2 cWmin=3 cWmax=7 burst=32
ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
wlan0: RX too short data frame payload
wlan0: RX too short data frame payload
wlan0: RX too short data frame payload
ADDRCONF(NETDEV_UP): wlan0: link is not ready
wlan0: switched to short barker preamble (BSSID=00:11:50:22:95:52)
wlan0: RX deauthentication from 00:11:50:22:95:52 (reason=7)
wlan0: deauthenticated

Thanks for any help

sean


From c4rn1val at gmail.com  Fri Jan  4 17:59:20 2008
From: c4rn1val at gmail.com (Mateusz Kozak)
Date: Fri, 4 Jan 2008 17:59:20 +0100
Subject: b43 module 2.6.24-rc6 doesn't work.
Message-ID: <160256ae0801040859o18705959rc010f026d7d2fe27@mail.gmail.com>

I have BCM4311 chipset based WLAN Card on my HP Compaq 6720s notebook..but
it's issue with it...

meal at oziris ~ $ uname -r
2.6.24-rc6
meal at oziris ~ $


meal at oziris ~ $ lsmod
Module                  Size  Used by
b43                   119456  0
ssb                    33284  1 b43
meal at oziris ~ $


meal at oziris ~ $ dmesg | grep ssb
ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x13, vendor 0x4243)
ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0D, vendor 0x4243)
ssb: Core 2 found: USB 1.1 Host (cc 0x817, rev 0x04, vendor 0x4243)
ssb: Core 3 found: PCI-E (cc 0x820, rev 0x05, vendor 0x4243)
WARNING: at drivers/ssb/main.c:883 ssb_tmslow_reject_bitmask()
 [<f89033a5>] ssb_tmslow_reject_bitmask+0x4b/0x56 [ssb]
 [<f8904293>] ssb_device_is_enabled+0x9/0x2d [ssb]
 [<f8906351>] ssb_pcicore_init+0x11/0x35 [ssb]
 [<f8903981>] ssb_attach_queued_buses+0x86/0x283 [ssb]
 [<f8905675>] ssb_pci_xtal+0x1ce/0x1ed [ssb]
 [<f89051df>] ssb_pci_get_invariants+0x293/0x29d [ssb]
 [<f8903e63>] ssb_bus_register+0x124/0x187 [ssb]
 [<f8904f4c>] ssb_pci_get_invariants+0x0/0x29d [ssb]
 [<f8903f67>] ssb_bus_pcibus_register+0x24/0x47 [ssb]
 [<f890579d>] ssb_pcihost_probe+0x5e/0x89 [ssb]
 [<f890d040>] ssb_modinit+0x40/0x56 [ssb]
ssb: Sonics Silicon Backplane found on PCI device 0000:10:00.0
ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x13, vendor 0x4243)
ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0D, vendor 0x4243)
ssb: Core 2 found: USB 1.1 Host (cc 0x817, rev 0x04, vendor 0x4243)
ssb: Core 3 found: PCI-E (cc 0x820, rev 0x05, vendor 0x4243)
WARNING: at drivers/ssb/main.c:883 ssb_tmslow_reject_bitmask()
 [<f89033a5>] ssb_tmslow_reject_bitmask+0x4b/0x56 [ssb]
 [<f8904293>] ssb_device_is_enabled+0x9/0x2d [ssb]
 [<f8906351>] ssb_pcicore_init+0x11/0x35 [ssb]
 [<f8903981>] ssb_attach_queued_buses+0x86/0x283 [ssb]
 [<f8905675>] ssb_pci_xtal+0x1ce/0x1ed [ssb]
 [<f89051df>] ssb_pci_get_invariants+0x293/0x29d [ssb]
 [<f8903e63>] ssb_bus_register+0x124/0x187 [ssb]
 [<f8904f4c>] ssb_pci_get_invariants+0x0/0x29d [ssb]
 [<f8903f67>] ssb_bus_pcibus_register+0x24/0x47 [ssb]
 [<f890579d>] ssb_pcihost_probe+0x5e/0x89 [ssb]
 [<f890f040>] ssb_modinit+0x40/0x56 [ssb]
ssb: Sonics Silicon Backplane found on PCI device 0000:10:00.0
meal at oziris ~ $


meal at oziris ~ $ dmesg | grep b43
meal at oziris ~ $
Yes, empty...

meal at oziris ~ $ cat /boot/config-2.6.24-rc6 | grep SSB
CONFIG_SSB_POSSIBLE=y
CONFIG_SSB=m
CONFIG_SSB_PCIHOST_POSSIBLE=y
CONFIG_SSB_PCIHOST=y
CONFIG_SSB_PCMCIAHOST_POSSIBLE=y
CONFIG_SSB_PCMCIAHOST=y
CONFIG_SSB_DEBUG=y
CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
CONFIG_SSB_DRIVER_PCICORE=y
meal at oziris ~ $


meal at oziris ~ $ cat /boot/config-2.6.24-rc6 | grep B43
CONFIG_B43=m
CONFIG_B43_PCI_AUTOSELECT=y
CONFIG_B43_PCICORE_AUTOSELECT=y
CONFIG_B43_PCMCIA=y
CONFIG_B43_DEBUG=y
CONFIG_B43_DMA=y
# CONFIG_B43_DMA_AND_PIO_MODE is not set
CONFIG_B43_DMA_MODE=y
# CONFIG_B43_PIO_MODE is not set
# CONFIG_B43LEGACY is not set
meal at oziris ~ $


I have no idea what's wrong with it...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20080104/ef53bd30/attachment.html>

From mb at bu3sch.de  Fri Jan  4 17:06:29 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 4 Jan 2008 17:06:29 +0100
Subject: [PATCH] b43: Add NPHY kconfig option
Message-ID: <200801041706.29704.mb@bu3sch.de>

This adds a new Kconfig option for enabling probing of N-PHYs.
This option will be removed again once the stuff works.
For now it is to help in development. This way real users won't
execute the broken N-PHY codepaths, but the developers can easily
enable N-PHY stuff.

To enable N-PHY probing simply remove the BROKEN dependency
and enable the option in the kernel config.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

2.6.25 stuff.

Index: wireless-2.6/drivers/net/wireless/b43/Kconfig
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/Kconfig	2008-01-04 15:01:42.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/Kconfig	2008-01-04 16:59:38.000000000 +0100
@@ -61,6 +61,16 @@ config B43_PCMCIA
 
 	  If unsure, say N.
 
+config B43_NPHY
+	bool "Pre IEEE 802.11n support (BROKEN)"
+	depends on B43 && EXPERIMENTAL && BROKEN
+	---help---
+	  Support for the IEEE 802.11n draft.
+
+	  THIS IS BROKEN AND DOES NOT WORK YET.
+
+	  SAY N.
+
 # This config option automatically enables b43 LEDS support,
 # if it's possible.
 config B43_LEDS
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-04 15:01:42.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-04 16:57:24.000000000 +0100
@@ -81,6 +81,7 @@ static const struct ssb_device_id b43_ss
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 11),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),
 	SSB_DEVTABLE_END
 };
@@ -3097,6 +3098,12 @@ static int b43_phy_versioning(struct b43
 		if (phy_rev > 9)
 			unsupported = 1;
 		break;
+#ifdef CONFIG_B43_NPHY
+	case B43_PHYTYPE_N:
+		if (phy_rev > 1)
+			unsupported = 1;
+		break;
+#endif
 	default:
 		unsupported = 1;
 	};


From mb at bu3sch.de  Fri Jan  4 18:25:32 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 4 Jan 2008 18:25:32 +0100
Subject: [PATCH] b43: Fix any N-PHY related WARN_ON() in the attach stage.
Message-ID: <200801041825.32233.mb@bu3sch.de>

This fixes all WARN_ON()s in the attach stage.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

This is stuff for 2.6.25

Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h	2008-01-04 15:01:42.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/b43.h	2008-01-04 17:28:03.000000000 +0100
@@ -332,17 +332,22 @@ enum {
 #define B43_MACCMD_CCA			0x00000008	/* Clear channel assessment */
 #define B43_MACCMD_BGNOISE		0x00000010	/* Background noise */
 
-/* 802.11 core specific TM State Low flags */
+/* 802.11 core specific TM State Low (SSB_TMSLOW) flags */
 #define B43_TMSLOW_GMODE		0x20000000	/* G Mode Enable */
-#define B43_TMSLOW_PLLREFSEL		0x00200000	/* PLL Frequency Reference Select */
+#define B43_TMSLOW_PHYCLKSPEED		0x00C00000	/* PHY clock speed mask (N-PHY only) */
+#define  B43_TMSLOW_PHYCLKSPEED_40MHZ	0x00000000	/* 40 MHz PHY */
+#define  B43_TMSLOW_PHYCLKSPEED_80MHZ	0x00400000	/* 80 MHz PHY */
+#define  B43_TMSLOW_PHYCLKSPEED_160MHZ	0x00800000	/* 160 MHz PHY */
+#define B43_TMSLOW_PLLREFSEL		0x00200000	/* PLL Frequency Reference Select (rev >= 5) */
 #define B43_TMSLOW_MACPHYCLKEN		0x00100000	/* MAC PHY Clock Control Enable (rev >= 5) */
 #define B43_TMSLOW_PHYRESET		0x00080000	/* PHY Reset */
 #define B43_TMSLOW_PHYCLKEN		0x00040000	/* PHY Clock Enable */
 
-/* 802.11 core specific TM State High flags */
+/* 802.11 core specific TM State High (SSB_TMSHIGH) flags */
+#define B43_TMSHIGH_DUALBAND_PHY	0x00080000	/* Dualband PHY available */
 #define B43_TMSHIGH_FCLOCK		0x00040000	/* Fast Clock Available (rev >= 5) */
-#define B43_TMSHIGH_APHY		0x00020000	/* A-PHY available (rev >= 5) */
-#define B43_TMSHIGH_GPHY		0x00010000	/* G-PHY available (rev >= 5) */
+#define B43_TMSHIGH_HAVE_5GHZ_PHY	0x00020000	/* 5 GHz PHY available (rev >= 5) */
+#define B43_TMSHIGH_HAVE_2GHZ_PHY	0x00010000	/* 2.4 GHz PHY available (rev >= 5) */
 
 /* Generic-Interrupt reasons. */
 #define B43_IRQ_MAC_SUSPENDED		0x00000001
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-04 16:57:24.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-04 18:05:07.000000000 +0100
@@ -132,7 +132,7 @@ static struct ieee80211_rate __b43_ratet
 		.power_level	= 0xFF,				\
 		.antenna_max	= 0xFF,				\
 	}
-static struct ieee80211_channel b43_bg_chantable[] = {
+static struct ieee80211_channel b43_2ghz_chantable[] = {
 	CHANTAB_ENT(1, 2412),
 	CHANTAB_ENT(2, 2417),
 	CHANTAB_ENT(3, 2422),
@@ -148,9 +148,10 @@ static struct ieee80211_channel b43_bg_c
 	CHANTAB_ENT(13, 2472),
 	CHANTAB_ENT(14, 2484),
 };
+#define b43_2ghz_chantable_size	ARRAY_SIZE(b43_2ghz_chantable)
 
-#define b43_bg_chantable_size	ARRAY_SIZE(b43_bg_chantable)
-static struct ieee80211_channel b43_a_chantable[] = {
+#if 0
+static struct ieee80211_channel b43_5ghz_chantable[] = {
 	CHANTAB_ENT(36, 5180),
 	CHANTAB_ENT(40, 5200),
 	CHANTAB_ENT(44, 5220),
@@ -165,8 +166,8 @@ static struct ieee80211_channel b43_a_ch
 	CHANTAB_ENT(161, 5805),
 	CHANTAB_ENT(165, 5825),
 };
-
-#define b43_a_chantable_size	ARRAY_SIZE(b43_a_chantable)
+#define b43_5ghz_chantable_size	ARRAY_SIZE(b43_5ghz_chantable)
+#endif
 
 static void b43_wireless_core_exit(struct b43_wldev *dev);
 static int b43_wireless_core_init(struct b43_wldev *dev);
@@ -1658,7 +1659,7 @@ static int b43_request_firmware(struct b
 		switch (dev->phy.type) {
 		case B43_PHYTYPE_A:
 			if ((rev >= 5) && (rev <= 10)) {
-				if (tmshigh & B43_TMSHIGH_GPHY)
+				if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY)
 					filename = "a0g1initvals5";
 				else
 					filename = "a0g0initvals5";
@@ -1684,7 +1685,7 @@ static int b43_request_firmware(struct b
 		switch (dev->phy.type) {
 		case B43_PHYTYPE_A:
 			if ((rev >= 5) && (rev <= 10)) {
-				if (tmshigh & B43_TMSHIGH_GPHY)
+				if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY)
 					filename = "a0g1bsinitvals5";
 				else
 					filename = "a0g0bsinitvals5";
@@ -3695,72 +3696,30 @@ static void b43_chip_reset(struct work_s
 }
 
 static int b43_setup_modes(struct b43_wldev *dev,
-			   int have_aphy, int have_bphy, int have_gphy)
+			   bool have_2ghz_phy, bool have_5ghz_phy)
 {
 	struct ieee80211_hw *hw = dev->wl->hw;
 	struct ieee80211_hw_mode *mode;
 	struct b43_phy *phy = &dev->phy;
-	int cnt = 0;
 	int err;
 
-/*FIXME: Don't tell ieee80211 about an A-PHY, because we currently don't support A-PHY. */
-	have_aphy = 0;
-
-	phy->possible_phymodes = 0;
-	for (; 1; cnt++) {
-		if (have_aphy) {
-			B43_WARN_ON(cnt >= B43_MAX_PHYHWMODES);
-			mode = &phy->hwmodes[cnt];
-
-			mode->mode = MODE_IEEE80211A;
-			mode->num_channels = b43_a_chantable_size;
-			mode->channels = b43_a_chantable;
-			mode->num_rates = b43_a_ratetable_size;
-			mode->rates = b43_a_ratetable;
-			err = ieee80211_register_hwmode(hw, mode);
-			if (err)
-				return err;
-
-			phy->possible_phymodes |= B43_PHYMODE_A;
-			have_aphy = 0;
-			continue;
-		}
-		if (have_bphy) {
-			B43_WARN_ON(cnt >= B43_MAX_PHYHWMODES);
-			mode = &phy->hwmodes[cnt];
-
-			mode->mode = MODE_IEEE80211B;
-			mode->num_channels = b43_bg_chantable_size;
-			mode->channels = b43_bg_chantable;
-			mode->num_rates = b43_b_ratetable_size;
-			mode->rates = b43_b_ratetable;
-			err = ieee80211_register_hwmode(hw, mode);
-			if (err)
-				return err;
-
-			phy->possible_phymodes |= B43_PHYMODE_B;
-			have_bphy = 0;
-			continue;
-		}
-		if (have_gphy) {
-			B43_WARN_ON(cnt >= B43_MAX_PHYHWMODES);
-			mode = &phy->hwmodes[cnt];
-
-			mode->mode = MODE_IEEE80211G;
-			mode->num_channels = b43_bg_chantable_size;
-			mode->channels = b43_bg_chantable;
-			mode->num_rates = b43_g_ratetable_size;
-			mode->rates = b43_g_ratetable;
-			err = ieee80211_register_hwmode(hw, mode);
-			if (err)
-				return err;
-
-			phy->possible_phymodes |= B43_PHYMODE_G;
-			have_gphy = 0;
-			continue;
-		}
-		break;
-	}
+	/* XXX: This function will go away soon, so this is just a hack,
+	 *      when mac80211 band stuff is rewritten.
+	 *      For now we always only init the GPHY, as there is no
+	 *      support for NPHY and APHY in the device, yet.
+	 *      This assumption is OK, as any B, N or A PHY will already
+	 *      have died a horrible sanity check death earlier. */
+
+	mode = &phy->hwmodes[0];
+	mode->mode = MODE_IEEE80211G;
+	mode->num_channels = b43_2ghz_chantable_size;
+	mode->channels = b43_2ghz_chantable;
+	mode->num_rates = b43_g_ratetable_size;
+	mode->rates = b43_g_ratetable;
+	err = ieee80211_register_hwmode(hw, mode);
+	if (err)
+		return err;
+	phy->possible_phymodes |= B43_PHYMODE_G;
 
 	return 0;
 }
@@ -3778,7 +3737,7 @@ static int b43_wireless_core_attach(stru
 	struct ssb_bus *bus = dev->dev->bus;
 	struct pci_dev *pdev = bus->host_pci;
 	int err;
-	int have_aphy = 0, have_bphy = 0, have_gphy = 0;
+	bool have_2ghz_phy = 0, have_5ghz_phy = 0;
 	u32 tmp;
 
 	/* Do NOT do any device initialization here.
@@ -3798,17 +3757,12 @@ static int b43_wireless_core_attach(stru
 		u32 tmshigh;
 
 		tmshigh = ssb_read32(dev->dev, SSB_TMSHIGH);
-		have_aphy = !!(tmshigh & B43_TMSHIGH_APHY);
-		have_gphy = !!(tmshigh & B43_TMSHIGH_GPHY);
-		if (!have_aphy && !have_gphy)
-			have_bphy = 1;
-	} else if (dev->dev->id.revision == 4) {
-		have_gphy = 1;
-		have_aphy = 1;
+		have_2ghz_phy = !!(tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY);
+		have_5ghz_phy = !!(tmshigh & B43_TMSHIGH_HAVE_5GHZ_PHY);
 	} else
-		have_bphy = 1;
+		B43_WARN_ON(1);
 
-	dev->phy.gmode = (have_gphy || have_bphy);
+	dev->phy.gmode = have_2ghz_phy;
 	tmp = dev->phy.gmode ? B43_TMSLOW_GMODE : 0;
 	b43_wireless_core_reset(dev, tmp);
 
@@ -3820,31 +3774,34 @@ static int b43_wireless_core_attach(stru
 	    (pdev->device != 0x4312 &&
 	     pdev->device != 0x4319 && pdev->device != 0x4324)) {
 		/* No multiband support. */
-		have_aphy = 0;
-		have_bphy = 0;
-		have_gphy = 0;
+		have_2ghz_phy = 0;
+		have_5ghz_phy = 0;
 		switch (dev->phy.type) {
 		case B43_PHYTYPE_A:
-			have_aphy = 1;
-			break;
-		case B43_PHYTYPE_B:
-			have_bphy = 1;
+			have_5ghz_phy = 1;
 			break;
 		case B43_PHYTYPE_G:
-			have_gphy = 1;
+		case B43_PHYTYPE_N:
+			have_2ghz_phy = 1;
 			break;
 		default:
 			B43_WARN_ON(1);
 		}
 	}
-	dev->phy.gmode = (have_gphy || have_bphy);
+	if (dev->phy.type == B43_PHYTYPE_A) {
+		/* FIXME */
+		b43err(wl, "IEEE 802.11a devices are unsupported\n");
+		err = -EOPNOTSUPP;
+		goto err_powerdown;
+	}
+	dev->phy.gmode = have_2ghz_phy;
 	tmp = dev->phy.gmode ? B43_TMSLOW_GMODE : 0;
 	b43_wireless_core_reset(dev, tmp);
 
 	err = b43_validate_chipaccess(dev);
 	if (err)
 		goto err_powerdown;
-	err = b43_setup_modes(dev, have_aphy, have_bphy, have_gphy);
+	err = b43_setup_modes(dev, have_2ghz_phy, have_5ghz_phy);
 	if (err)
 		goto err_powerdown;
 


From larry.finger at lwfinger.net  Fri Jan  4 18:46:48 2008
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 04 Jan 2008 09:46:48 -0800
Subject: b43 module 2.6.24-rc6 doesn't work.
In-Reply-To: <160256ae0801040859o18705959rc010f026d7d2fe27@mail.gmail.com>
References: <160256ae0801040859o18705959rc010f026d7d2fe27@mail.gmail.com>
Message-ID: <477E7108.4040208@lwfinger.net>

Mateusz Kozak wrote:
> I have BCM4311 chipset based WLAN Card on my HP Compaq 6720s
> notebook..but it's issue with it...
> 
> meal at oziris ~ $ uname -r
> 2.6.24-rc6
> meal at oziris ~ $
> 
> 
> meal at oziris ~ $ lsmod
> Module                  Size  Used by
> b43                   119456  0
> ssb                    33284  1 b43
> meal at oziris ~ $
> 
> 
> meal at oziris ~ $ dmesg | grep ssb
> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x13, vendor 0x4243)
> ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0D, vendor 0x4243)
> ssb: Core 2 found: USB 1.1 Host (cc 0x817, rev 0x04, vendor 0x4243)
> ssb: Core 3 found: PCI-E (cc 0x820, rev 0x05, vendor 0x4243)
> WARNING: at drivers/ssb/main.c:883 ssb_tmslow_reject_bitmask()
>  [<f89033a5>] ssb_tmslow_reject_bitmask+0x4b/0x56 [ssb]
>  [<f8904293>] ssb_device_is_enabled+0x9/0x2d [ssb]
>  [<f8906351>] ssb_pcicore_init+0x11/0x35 [ssb]
>  [<f8903981>] ssb_attach_queued_buses+0x86/0x283 [ssb]
>  [<f8905675>] ssb_pci_xtal+0x1ce/0x1ed [ssb]
>  [<f89051df>] ssb_pci_get_invariants+0x293/0x29d [ssb]
>  [<f8903e63>] ssb_bus_register+0x124/0x187 [ssb]
>  [<f8904f4c>] ssb_pci_get_invariants+0x0/0x29d [ssb]
>  [<f8903f67>] ssb_bus_pcibus_register+0x24/0x47 [ssb]
>  [<f890579d>] ssb_pcihost_probe+0x5e/0x89 [ssb]
>  [<f890d040>] ssb_modinit+0x40/0x56 [ssb]
> ssb: Sonics Silicon Backplane found on PCI device 0000:10:00.0
> ssb: Core 0 found: ChipCommon (cc 0x800, rev 0x13, vendor 0x4243)
> ssb: Core 1 found: IEEE 802.11 (cc 0x812, rev 0x0D, vendor 0x4243)
> ssb: Core 2 found: USB 1.1 Host (cc 0x817, rev 0x04, vendor 0x4243)
> ssb: Core 3 found: PCI-E (cc 0x820, rev 0x05, vendor 0x4243)
> WARNING: at drivers/ssb/main.c:883 ssb_tmslow_reject_bitmask()
>  [<f89033a5>] ssb_tmslow_reject_bitmask+0x4b/0x56 [ssb]
>  [<f8904293>] ssb_device_is_enabled+0x9/0x2d [ssb]
>  [<f8906351>] ssb_pcicore_init+0x11/0x35 [ssb]
>  [<f8903981>] ssb_attach_queued_buses+0x86/0x283 [ssb]
>  [<f8905675>] ssb_pci_xtal+0x1ce/0x1ed [ssb]
>  [<f89051df>] ssb_pci_get_invariants+0x293/0x29d [ssb]
>  [<f8903e63>] ssb_bus_register+0x124/0x187 [ssb]
>  [<f8904f4c>] ssb_pci_get_invariants+0x0/0x29d [ssb]
>  [<f8903f67>] ssb_bus_pcibus_register+0x24/0x47 [ssb]
>  [<f890579d>] ssb_pcihost_probe+0x5e/0x89 [ssb]
>  [<f890f040>] ssb_modinit+0x40/0x56 [ssb]
> ssb: Sonics Silicon Backplane found on PCI device 0000:10:00.0
> meal at oziris ~ $
> 
> 
> meal at oziris ~ $ dmesg | grep b43
> meal at oziris ~ $
> Yes, empty...
> 
> meal at oziris ~ $ cat /boot/config-2.6.24-rc6 | grep SSB
> CONFIG_SSB_POSSIBLE=y
> CONFIG_SSB=m
> CONFIG_SSB_PCIHOST_POSSIBLE=y
> CONFIG_SSB_PCIHOST=y
> CONFIG_SSB_PCMCIAHOST_POSSIBLE=y
> CONFIG_SSB_PCMCIAHOST=y
> CONFIG_SSB_DEBUG=y
> CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
> CONFIG_SSB_DRIVER_PCICORE=y
> meal at oziris ~ $
> 
> 
> meal at oziris ~ $ cat /boot/config-2.6.24-rc6 | grep B43
> CONFIG_B43=m
> CONFIG_B43_PCI_AUTOSELECT=y
> CONFIG_B43_PCICORE_AUTOSELECT=y
> CONFIG_B43_PCMCIA=y
> CONFIG_B43_DEBUG=y
> CONFIG_B43_DMA=y
> # CONFIG_B43_DMA_AND_PIO_MODE is not set
> CONFIG_B43_DMA_MODE=y
> # CONFIG_B43_PIO_MODE is not set
> # CONFIG_B43LEGACY is not set
> meal at oziris ~ $
> 
> 
> I have no idea what's wrong with it...

Your card is a BCM4311/2 (see the rev 0x0D for the 802.11 core). This device will not be supported
in mainline kernels until 2.6.25-rc1. You need to download and apply the patch at
http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2.

Larry


From mb at bu3sch.de  Sun Jan  6 00:07:19 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 6 Jan 2008 00:07:19 +0100
Subject: [PATCH] b43: Fix any N-PHY related WARN_ON() in the attach stage.
In-Reply-To: <200801041825.32233.mb@bu3sch.de>
References: <200801041825.32233.mb@bu3sch.de>
Message-ID: <200801060007.19931.mb@bu3sch.de>

On Friday 04 January 2008, Michael Buesch wrote:
> This fixes all WARN_ON()s in the attach stage.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> ---
> 
> This is stuff for 2.6.25

I'm sorry, this patch was the wrong one.
I'll immediately send the correct one.



From mb at bu3sch.de  Sun Jan  6 00:09:46 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 6 Jan 2008 00:09:46 +0100
Subject: [PATCH v2] b43: Fix any N-PHY related WARN_ON() in the attach stage.
Message-ID: <200801060009.46260.mb@bu3sch.de>

This fixes all WARN_ON()s in the attach stage.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

This is stuff for 2.6.25
This is patch version 2. Sorry for the inconvenience.

Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h	2008-01-04 15:01:42.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/b43.h	2008-01-04 17:28:03.000000000 +0100
@@ -332,17 +332,22 @@ enum {
 #define B43_MACCMD_CCA			0x00000008	/* Clear channel assessment */
 #define B43_MACCMD_BGNOISE		0x00000010	/* Background noise */
 
-/* 802.11 core specific TM State Low flags */
+/* 802.11 core specific TM State Low (SSB_TMSLOW) flags */
 #define B43_TMSLOW_GMODE		0x20000000	/* G Mode Enable */
-#define B43_TMSLOW_PLLREFSEL		0x00200000	/* PLL Frequency Reference Select */
+#define B43_TMSLOW_PHYCLKSPEED		0x00C00000	/* PHY clock speed mask (N-PHY only) */
+#define  B43_TMSLOW_PHYCLKSPEED_40MHZ	0x00000000	/* 40 MHz PHY */
+#define  B43_TMSLOW_PHYCLKSPEED_80MHZ	0x00400000	/* 80 MHz PHY */
+#define  B43_TMSLOW_PHYCLKSPEED_160MHZ	0x00800000	/* 160 MHz PHY */
+#define B43_TMSLOW_PLLREFSEL		0x00200000	/* PLL Frequency Reference Select (rev >= 5) */
 #define B43_TMSLOW_MACPHYCLKEN		0x00100000	/* MAC PHY Clock Control Enable (rev >= 5) */
 #define B43_TMSLOW_PHYRESET		0x00080000	/* PHY Reset */
 #define B43_TMSLOW_PHYCLKEN		0x00040000	/* PHY Clock Enable */
 
-/* 802.11 core specific TM State High flags */
+/* 802.11 core specific TM State High (SSB_TMSHIGH) flags */
+#define B43_TMSHIGH_DUALBAND_PHY	0x00080000	/* Dualband PHY available */
 #define B43_TMSHIGH_FCLOCK		0x00040000	/* Fast Clock Available (rev >= 5) */
-#define B43_TMSHIGH_APHY		0x00020000	/* A-PHY available (rev >= 5) */
-#define B43_TMSHIGH_GPHY		0x00010000	/* G-PHY available (rev >= 5) */
+#define B43_TMSHIGH_HAVE_5GHZ_PHY	0x00020000	/* 5 GHz PHY available (rev >= 5) */
+#define B43_TMSHIGH_HAVE_2GHZ_PHY	0x00010000	/* 2.4 GHz PHY available (rev >= 5) */
 
 /* Generic-Interrupt reasons. */
 #define B43_IRQ_MAC_SUSPENDED		0x00000001
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-04 16:57:24.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-06 00:05:04.000000000 +0100
@@ -132,7 +132,7 @@ static struct ieee80211_rate __b43_ratet
 		.power_level	= 0xFF,				\
 		.antenna_max	= 0xFF,				\
 	}
-static struct ieee80211_channel b43_bg_chantable[] = {
+static struct ieee80211_channel b43_2ghz_chantable[] = {
 	CHANTAB_ENT(1, 2412),
 	CHANTAB_ENT(2, 2417),
 	CHANTAB_ENT(3, 2422),
@@ -148,9 +148,10 @@ static struct ieee80211_channel b43_bg_c
 	CHANTAB_ENT(13, 2472),
 	CHANTAB_ENT(14, 2484),
 };
+#define b43_2ghz_chantable_size	ARRAY_SIZE(b43_2ghz_chantable)
 
-#define b43_bg_chantable_size	ARRAY_SIZE(b43_bg_chantable)
-static struct ieee80211_channel b43_a_chantable[] = {
+#if 0
+static struct ieee80211_channel b43_5ghz_chantable[] = {
 	CHANTAB_ENT(36, 5180),
 	CHANTAB_ENT(40, 5200),
 	CHANTAB_ENT(44, 5220),
@@ -165,8 +166,8 @@ static struct ieee80211_channel b43_a_ch
 	CHANTAB_ENT(161, 5805),
 	CHANTAB_ENT(165, 5825),
 };
-
-#define b43_a_chantable_size	ARRAY_SIZE(b43_a_chantable)
+#define b43_5ghz_chantable_size	ARRAY_SIZE(b43_5ghz_chantable)
+#endif
 
 static void b43_wireless_core_exit(struct b43_wldev *dev);
 static int b43_wireless_core_init(struct b43_wldev *dev);
@@ -1658,7 +1659,7 @@ static int b43_request_firmware(struct b
 		switch (dev->phy.type) {
 		case B43_PHYTYPE_A:
 			if ((rev >= 5) && (rev <= 10)) {
-				if (tmshigh & B43_TMSHIGH_GPHY)
+				if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY)
 					filename = "a0g1initvals5";
 				else
 					filename = "a0g0initvals5";
@@ -1684,7 +1685,7 @@ static int b43_request_firmware(struct b
 		switch (dev->phy.type) {
 		case B43_PHYTYPE_A:
 			if ((rev >= 5) && (rev <= 10)) {
-				if (tmshigh & B43_TMSHIGH_GPHY)
+				if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY)
 					filename = "a0g1bsinitvals5";
 				else
 					filename = "a0g0bsinitvals5";
@@ -3134,6 +3135,8 @@ static int b43_phy_versioning(struct b43
 	radio_manuf = (tmp & 0x00000FFF);
 	radio_ver = (tmp & 0x0FFFF000) >> 12;
 	radio_rev = (tmp & 0xF0000000) >> 28;
+	if (radio_manuf != 0x17F /* Broadcom */)
+		unsupported = 1;
 	switch (phy_type) {
 	case B43_PHYTYPE_A:
 		if (radio_ver != 0x2060)
@@ -3151,6 +3154,10 @@ static int b43_phy_versioning(struct b43
 		if (radio_ver != 0x2050)
 			unsupported = 1;
 		break;
+	case B43_PHYTYPE_N:
+		if (radio_ver != 5)
+			unsupported = 1;
+		break;
 	default:
 		B43_WARN_ON(1);
 	}
@@ -3695,72 +3702,30 @@ static void b43_chip_reset(struct work_s
 }
 
 static int b43_setup_modes(struct b43_wldev *dev,
-			   int have_aphy, int have_bphy, int have_gphy)
+			   bool have_2ghz_phy, bool have_5ghz_phy)
 {
 	struct ieee80211_hw *hw = dev->wl->hw;
 	struct ieee80211_hw_mode *mode;
 	struct b43_phy *phy = &dev->phy;
-	int cnt = 0;
 	int err;
 
-/*FIXME: Don't tell ieee80211 about an A-PHY, because we currently don't support A-PHY. */
-	have_aphy = 0;
-
-	phy->possible_phymodes = 0;
-	for (; 1; cnt++) {
-		if (have_aphy) {
-			B43_WARN_ON(cnt >= B43_MAX_PHYHWMODES);
-			mode = &phy->hwmodes[cnt];
-
-			mode->mode = MODE_IEEE80211A;
-			mode->num_channels = b43_a_chantable_size;
-			mode->channels = b43_a_chantable;
-			mode->num_rates = b43_a_ratetable_size;
-			mode->rates = b43_a_ratetable;
-			err = ieee80211_register_hwmode(hw, mode);
-			if (err)
-				return err;
-
-			phy->possible_phymodes |= B43_PHYMODE_A;
-			have_aphy = 0;
-			continue;
-		}
-		if (have_bphy) {
-			B43_WARN_ON(cnt >= B43_MAX_PHYHWMODES);
-			mode = &phy->hwmodes[cnt];
-
-			mode->mode = MODE_IEEE80211B;
-			mode->num_channels = b43_bg_chantable_size;
-			mode->channels = b43_bg_chantable;
-			mode->num_rates = b43_b_ratetable_size;
-			mode->rates = b43_b_ratetable;
-			err = ieee80211_register_hwmode(hw, mode);
-			if (err)
-				return err;
-
-			phy->possible_phymodes |= B43_PHYMODE_B;
-			have_bphy = 0;
-			continue;
-		}
-		if (have_gphy) {
-			B43_WARN_ON(cnt >= B43_MAX_PHYHWMODES);
-			mode = &phy->hwmodes[cnt];
-
-			mode->mode = MODE_IEEE80211G;
-			mode->num_channels = b43_bg_chantable_size;
-			mode->channels = b43_bg_chantable;
-			mode->num_rates = b43_g_ratetable_size;
-			mode->rates = b43_g_ratetable;
-			err = ieee80211_register_hwmode(hw, mode);
-			if (err)
-				return err;
-
-			phy->possible_phymodes |= B43_PHYMODE_G;
-			have_gphy = 0;
-			continue;
-		}
-		break;
-	}
+	/* XXX: This function will go away soon, when mac80211
+	 *      band stuff is rewritten. So this is just a hack.
+	 *      For now we always claim GPHY mode, as there is no
+	 *      support for NPHY and APHY in the device, yet.
+	 *      This assumption is OK, as any B, N or A PHY will already
+	 *      have died a horrible sanity check death earlier. */
+
+	mode = &phy->hwmodes[0];
+	mode->mode = MODE_IEEE80211G;
+	mode->num_channels = b43_2ghz_chantable_size;
+	mode->channels = b43_2ghz_chantable;
+	mode->num_rates = b43_g_ratetable_size;
+	mode->rates = b43_g_ratetable;
+	err = ieee80211_register_hwmode(hw, mode);
+	if (err)
+		return err;
+	phy->possible_phymodes |= B43_PHYMODE_G;
 
 	return 0;
 }
@@ -3778,7 +3743,7 @@ static int b43_wireless_core_attach(stru
 	struct ssb_bus *bus = dev->dev->bus;
 	struct pci_dev *pdev = bus->host_pci;
 	int err;
-	int have_aphy = 0, have_bphy = 0, have_gphy = 0;
+	bool have_2ghz_phy = 0, have_5ghz_phy = 0;
 	u32 tmp;
 
 	/* Do NOT do any device initialization here.
@@ -3798,17 +3763,12 @@ static int b43_wireless_core_attach(stru
 		u32 tmshigh;
 
 		tmshigh = ssb_read32(dev->dev, SSB_TMSHIGH);
-		have_aphy = !!(tmshigh & B43_TMSHIGH_APHY);
-		have_gphy = !!(tmshigh & B43_TMSHIGH_GPHY);
-		if (!have_aphy && !have_gphy)
-			have_bphy = 1;
-	} else if (dev->dev->id.revision == 4) {
-		have_gphy = 1;
-		have_aphy = 1;
+		have_2ghz_phy = !!(tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY);
+		have_5ghz_phy = !!(tmshigh & B43_TMSHIGH_HAVE_5GHZ_PHY);
 	} else
-		have_bphy = 1;
+		B43_WARN_ON(1);
 
-	dev->phy.gmode = (have_gphy || have_bphy);
+	dev->phy.gmode = have_2ghz_phy;
 	tmp = dev->phy.gmode ? B43_TMSLOW_GMODE : 0;
 	b43_wireless_core_reset(dev, tmp);
 
@@ -3820,31 +3780,34 @@ static int b43_wireless_core_attach(stru
 	    (pdev->device != 0x4312 &&
 	     pdev->device != 0x4319 && pdev->device != 0x4324)) {
 		/* No multiband support. */
-		have_aphy = 0;
-		have_bphy = 0;
-		have_gphy = 0;
+		have_2ghz_phy = 0;
+		have_5ghz_phy = 0;
 		switch (dev->phy.type) {
 		case B43_PHYTYPE_A:
-			have_aphy = 1;
-			break;
-		case B43_PHYTYPE_B:
-			have_bphy = 1;
+			have_5ghz_phy = 1;
 			break;
 		case B43_PHYTYPE_G:
-			have_gphy = 1;
+		case B43_PHYTYPE_N:
+			have_2ghz_phy = 1;
 			break;
 		default:
 			B43_WARN_ON(1);
 		}
 	}
-	dev->phy.gmode = (have_gphy || have_bphy);
+	if (dev->phy.type == B43_PHYTYPE_A) {
+		/* FIXME */
+		b43err(wl, "IEEE 802.11a devices are unsupported\n");
+		err = -EOPNOTSUPP;
+		goto err_powerdown;
+	}
+	dev->phy.gmode = have_2ghz_phy;
 	tmp = dev->phy.gmode ? B43_TMSLOW_GMODE : 0;
 	b43_wireless_core_reset(dev, tmp);
 
 	err = b43_validate_chipaccess(dev);
 	if (err)
 		goto err_powerdown;
-	err = b43_setup_modes(dev, have_aphy, have_bphy, have_gphy);
+	err = b43_setup_modes(dev, have_2ghz_phy, have_5ghz_phy);
 	if (err)
 		goto err_powerdown;
 


From gavron at wetwork.net  Sun Jan  6 00:41:26 2008
From: gavron at wetwork.net (Ehud Gavron)
Date: Sat, 05 Jan 2008 16:41:26 -0700
Subject: Speed issue 2.6.24-rc5 after a few days.  Reloading b43 corrects it.
Message-ID: <478015A6.9040502@wetwork.net>

After the system has been up a while -- in this case 5 days -- the data 
transfer rate appears slow and this is confirmed by various tools such 
as ftp and speedtest.net.

Reassociating with the AP has no effect on this symptom.

modprobe -r b43 && modprobe b43 corrects the symptom.

What other diagnostics can I run next time I see this, so that I can 
provide better input as to what the problem is?

Thanks,

Ehud


From mb at bu3sch.de  Sun Jan  6 18:02:38 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 6 Jan 2008 18:02:38 +0100
Subject: b43 will need a firmware upgrade soon
Message-ID: <200801061802.38297.mb@bu3sch.de>

The b43 driver will need an incompatible firmware upgrade, soon.
I'm probably going to do this in 2.6.25 or 2.6.26.

The update will require people to download and extract updated
officially supported firmware. The firmware will be linked to
from the usual place at linuxwireless.org.
The driver will print a verbose error message when it detects
too old firmware and abort initialization.

This is needed in order to add support for new devices (N-PHY).
Broadcom changed the ABI of the firmware, so we are forced to also
change the ABI of the driver.

I'm very sorry for the inconvenience.

-- 
Greetings Michael.


From martin at marquesminen.com.ar  Sun Jan  6 18:33:50 2008
From: martin at marquesminen.com.ar (Martin Marques)
Date: Sun, 06 Jan 2008 15:33:50 -0200
Subject: Speed issue 2.6.24-rc5 after a few days. Reloading b43 corrects
	it.
In-Reply-To: <478015A6.9040502@wetwork.net>
References: <478015A6.9040502@wetwork.net>
Message-ID: <478110FE.1050904@marquesminen.com.ar>

Ehud Gavron escribi?:
> After the system has been up a while -- in this case 5 days -- the data 
> transfer rate appears slow and this is confirmed by various tools such 
> as ftp and speedtest.net.
> 
> Reassociating with the AP has no effect on this symptom.
> 
> modprobe -r b43 && modprobe b43 corrects the symptom.
> 
> What other diagnostics can I run next time I see this, so that I can 
> provide better input as to what the problem is?

I'm at this moment using rc6 kernel from fedora rawhide with excellent 
success. Try to see the performace withh the last rc vanilla kernel.


From post at hendrik-sattler.de  Sun Jan  6 21:05:23 2008
From: post at hendrik-sattler.de (Hendrik Sattler)
Date: Sun, 6 Jan 2008 21:05:23 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801061802.38297.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de>
Message-ID: <200801062105.24007.post@hendrik-sattler.de>

Am Sonntag 06 Januar 2008 schrieb Michael Buesch:
> The b43 driver will need an incompatible firmware upgrade, soon.
> I'm probably going to do this in 2.6.25 or 2.6.26.
>
> The update will require people to download and extract updated
> officially supported firmware. The firmware will be linked to
> from the usual place at linuxwireless.org.
> The driver will print a verbose error message when it detects
> too old firmware and abort initialization.
>
> This is needed in order to add support for new devices (N-PHY).
> Broadcom changed the ABI of the firmware, so we are forced to also
> change the ABI of the driver.
>
> I'm very sorry for the inconvenience.

Do these firmware files go to a different directory then? I would like to run 
my current kernel (b43 from git or 2.6.24) and the new one without having to 
exchange files every time I boot another kernel version.
And yes, WLAN is my _only_ connection to the internet.

Is it impossible to support both ABIs?

HS

PS: I am using Debian testing.



From mb at bu3sch.de  Sun Jan  6 21:58:22 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 6 Jan 2008 21:58:22 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801062105.24007.post@hendrik-sattler.de>
References: <200801061802.38297.mb@bu3sch.de>
	<200801062105.24007.post@hendrik-sattler.de>
Message-ID: <200801062158.22681.mb@bu3sch.de>

On Sunday 06 January 2008 21:05:23 Hendrik Sattler wrote:
> Am Sonntag 06 Januar 2008 schrieb Michael Buesch:
> > The b43 driver will need an incompatible firmware upgrade, soon.
> > I'm probably going to do this in 2.6.25 or 2.6.26.
> >
> > The update will require people to download and extract updated
> > officially supported firmware. The firmware will be linked to
> > from the usual place at linuxwireless.org.
> > The driver will print a verbose error message when it detects
> > too old firmware and abort initialization.
> >
> > This is needed in order to add support for new devices (N-PHY).
> > Broadcom changed the ABI of the firmware, so we are forced to also
> > change the ABI of the driver.
> >
> > I'm very sorry for the inconvenience.
> 
> Do these firmware files go to a different directory then? I would like to run 
> my current kernel (b43 from git or 2.6.24) and the new one without having to 
> exchange files every time I boot another kernel version.
> And yes, WLAN is my _only_ connection to the internet.

see "fwpostfix" module parameter

-- 
Greetings Michael.


From linville at tuxdriver.com  Sun Jan  6 21:34:35 2008
From: linville at tuxdriver.com (John W. Linville)
Date: Sun, 6 Jan 2008 15:34:35 -0500
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801061802.38297.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de>
Message-ID: <20080106203435.GA18833@tuxdriver.com>

On Sun, Jan 06, 2008 at 06:02:38PM +0100, Michael Buesch wrote:

> This is needed in order to add support for new devices (N-PHY).
> Broadcom changed the ABI of the firmware, so we are forced to also
> change the ABI of the driver.

Do we have reasonable confidence that the newer firmware will run
on all the devices currently supported by b43?  Or are we looking at
another b43legacy type of situation?

John
-- 
John W. Linville
linville at tuxdriver.com


From proski at gnu.org  Sun Jan  6 22:35:51 2008
From: proski at gnu.org (Pavel Roskin)
Date: Sun, 06 Jan 2008 16:35:51 -0500
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801062158.22681.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de>
	<200801062105.24007.post@hendrik-sattler.de>
	<200801062158.22681.mb@bu3sch.de>
Message-ID: <20080106163551.kex6o8twu880sk0k@webmail.spamcop.net>

Quoting Michael Buesch <mb at bu3sch.de>:

> see "fwpostfix" module parameter

Can we please avoid this annoyance this time?

It was bad at the bcm43xx/bcm43xx_mac80211 time, but it's going to be  
a bigger annoyance this time, because the driver with the same name  
"b43" will need a different fwprefix for different kernel versions.

I don't think modprobe.conf can be written to use different options  
for different kernel versions.  And if it can, I don't want to force  
everyone to figure it out.

The driver knows which firmware is needs.  It's the driver's  
responsibility to express its requirements, rather that the users'  
responsibility to figure out which firmware this particular version of  
the driver wants.

iwlwifi changed the firmware name when a different firmware was  
needed.  And that's a good example, in my opinion.

-- 
Regards,
Pavel Roskin


From linville at tuxdriver.com  Sun Jan  6 22:25:17 2008
From: linville at tuxdriver.com (John W. Linville)
Date: Sun, 6 Jan 2008 16:25:17 -0500
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801062158.22681.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de>
	<200801062105.24007.post@hendrik-sattler.de>
	<200801062158.22681.mb@bu3sch.de>
Message-ID: <20080106212517.GB3149@tuxdriver.com>

On Sun, Jan 06, 2008 at 09:58:22PM +0100, Michael Buesch wrote:
> On Sunday 06 January 2008 21:05:23 Hendrik Sattler wrote:
> > Do these firmware files go to a different directory then? I would like to run 
> > my current kernel (b43 from git or 2.6.24) and the new one without having to 
> > exchange files every time I boot another kernel version.
> > And yes, WLAN is my _only_ connection to the internet.
> 
> see "fwpostfix" module parameter

Ugh...that works but is a bit ugly.  Is there any way we can version
these firmware ABIs?  I guess it might be as simple as simply setting
a default fwpostfix value...

John
-- 
John W. Linville
linville at tuxdriver.com


From mb at bu3sch.de  Sun Jan  6 22:38:43 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 6 Jan 2008 22:38:43 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <20080106163551.kex6o8twu880sk0k@webmail.spamcop.net>
References: <200801061802.38297.mb@bu3sch.de> <200801062158.22681.mb@bu3sch.de>
	<20080106163551.kex6o8twu880sk0k@webmail.spamcop.net>
Message-ID: <200801062238.43666.mb@bu3sch.de>

On Sunday 06 January 2008 22:35:51 Pavel Roskin wrote:
> Quoting Michael Buesch <mb at bu3sch.de>:
> 
> > see "fwpostfix" module parameter
> 
> Can we please avoid this annoyance this time?

Go and complain at Broadcom please.

-- 
Greetings Michael.


From mb at bu3sch.de  Sun Jan  6 22:38:14 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 6 Jan 2008 22:38:14 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <20080106203435.GA18833@tuxdriver.com>
References: <200801061802.38297.mb@bu3sch.de>
	<20080106203435.GA18833@tuxdriver.com>
Message-ID: <200801062238.14472.mb@bu3sch.de>

On Sunday 06 January 2008 21:34:35 John W. Linville wrote:
> On Sun, Jan 06, 2008 at 06:02:38PM +0100, Michael Buesch wrote:
> 
> > This is needed in order to add support for new devices (N-PHY).
> > Broadcom changed the ABI of the firmware, so we are forced to also
> > change the ABI of the driver.
> 
> Do we have reasonable confidence that the newer firmware will run
> on all the devices currently supported by b43?  Or are we looking at
> another b43legacy type of situation?

We need to check this.
Maybe we can support both firmware images in the driver. Not sure yet.

-- 
Greetings Michael.


From linville at tuxdriver.com  Sun Jan  6 23:01:00 2008
From: linville at tuxdriver.com (John W. Linville)
Date: Sun, 6 Jan 2008 17:01:00 -0500
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801062238.43666.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de> <200801062158.22681.mb@bu3sch.de>
	<20080106163551.kex6o8twu880sk0k@webmail.spamcop.net>
	<200801062238.43666.mb@bu3sch.de>
Message-ID: <20080106220100.GC3149@tuxdriver.com>

On Sun, Jan 06, 2008 at 10:38:43PM +0100, Michael Buesch wrote:
> On Sunday 06 January 2008 22:35:51 Pavel Roskin wrote:
> > Quoting Michael Buesch <mb at bu3sch.de>:
> > 
> > > see "fwpostfix" module parameter
> > 
> > Can we please avoid this annoyance this time?
> 
> Go and complain at Broadcom please.

Broadcom doesn't really have this problem, since they are free to
include the binary firmware in their Windows/Mac/whatever drivers.

If the driver needs different firmware, why not have it ask for
different filenames?  As I suggested elsewhere, this could be as
simple as setting a default value for fwpostfix...

John
-- 
John W. Linville
linville at tuxdriver.com


From post at hendrik-sattler.de  Sun Jan  6 23:41:19 2008
From: post at hendrik-sattler.de (Hendrik Sattler)
Date: Sun, 6 Jan 2008 23:41:19 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801062238.14472.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de>
	<20080106203435.GA18833@tuxdriver.com>
	<200801062238.14472.mb@bu3sch.de>
Message-ID: <200801062341.20626.post@hendrik-sattler.de>

Am Sonntag 06 Januar 2008 schrieb Michael Buesch:
> On Sunday 06 January 2008 21:34:35 John W. Linville wrote:
> > On Sun, Jan 06, 2008 at 06:02:38PM +0100, Michael Buesch wrote:
> > > This is needed in order to add support for new devices (N-PHY).
> > > Broadcom changed the ABI of the firmware, so we are forced to also
> > > change the ABI of the driver.
> >
> > Do we have reasonable confidence that the newer firmware will run
> > on all the devices currently supported by b43?  Or are we looking at
> > another b43legacy type of situation?
>
> We need to check this.
> Maybe we can support both firmware images in the driver. Not sure yet.

As you already mentioned fwpostfix: can the driver somehow do something like 
the soname is for libraries, e.g. increasing a serial number in the firmware 
file names? This would make it possible to install several incompatible 
versions in parallel.
Example: fwcutter unpacks such versions to
  /lib/modules/firmware/b43.${ABIVERSION}
and the driver looks in the directories for whatever kinds of ABIVERSION are 
supported by that version of the driver.

HS


From proski at gnu.org  Sun Jan  6 23:44:42 2008
From: proski at gnu.org (Pavel Roskin)
Date: Sun, 06 Jan 2008 17:44:42 -0500
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801062238.43666.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de> <200801062158.22681.mb@bu3sch.de>
	<20080106163551.kex6o8twu880sk0k@webmail.spamcop.net>
	<200801062238.43666.mb@bu3sch.de>
Message-ID: <20080106174442.wxhybqm2kgs0k448@webmail.spamcop.net>

Quoting Michael Buesch <mb at bu3sch.de>:

> On Sunday 06 January 2008 22:35:51 Pavel Roskin wrote:
>> Quoting Michael Buesch <mb at bu3sch.de>:
>>
>> > see "fwpostfix" module parameter
>>
>> Can we please avoid this annoyance this time?
>
> Go and complain at Broadcom please.

Mind you, there is nothing fundamentally wrong with changing firmware  
or changing its API.

Sure, Broadcom firmware is not under GPL, so we have to keep it in  
separate files rather than link it into the kernel.  But the same  
situation exists for many other drivers, even those where the vendors  
are much more cooperative, such as Intel.

If the firmware is kept outside the kernel, we have a problem of  
synchronization between the driver and the firmware.  It can be  
addressed gracefully, or not so gracefully.  The choice is entirely  
ours, and Broadcom is not to blame for our choice.

-- 
Regards,
Pavel Roskin


From mb at bu3sch.de  Mon Jan  7 00:02:11 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 7 Jan 2008 00:02:11 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <20080106220100.GC3149@tuxdriver.com>
References: <200801061802.38297.mb@bu3sch.de> <200801062238.43666.mb@bu3sch.de>
	<20080106220100.GC3149@tuxdriver.com>
Message-ID: <200801070002.11271.mb@bu3sch.de>

On Sunday 06 January 2008 23:01:00 John W. Linville wrote:
> On Sun, Jan 06, 2008 at 10:38:43PM +0100, Michael Buesch wrote:
> > On Sunday 06 January 2008 22:35:51 Pavel Roskin wrote:
> > > Quoting Michael Buesch <mb at bu3sch.de>:
> > > 
> > > > see "fwpostfix" module parameter
> > > 
> > > Can we please avoid this annoyance this time?
> > 
> > Go and complain at Broadcom please.
> 
> Broadcom doesn't really have this problem, since they are free to
> include the binary firmware in their Windows/Mac/whatever drivers.
> 
> If the driver needs different firmware, why not have it ask for
> different filenames?  As I suggested elsewhere, this could be as
> simple as setting a default value for fwpostfix...

I'm not sure why people are complaining about stuff that's not
done, yet. I just said that we need an update to an incompatible
firmware soon. HOW that happens is an entirely different question.
It seems like we _might_ be able to support both fw versions for some
limited time. If that is not possible for whatever reason, I will
change the fw filenames, of course. (And people will complain about
that, too. Because the rule for broadcom firmware is: Always complain
about whatever you do. ;) )
The _just_ wanted to tell people about a serious change _before_ it
happens. I'm not sure why this results in all kinds of complaints.

Thanks anyway for the feedback.

-- 
Greetings Michael.


From rjw at sisk.pl  Mon Jan  7 00:28:15 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Mon, 7 Jan 2008 00:28:15 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801070002.11271.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de>
	<20080106220100.GC3149@tuxdriver.com>
	<200801070002.11271.mb@bu3sch.de>
Message-ID: <200801070028.15776.rjw@sisk.pl>

On Monday, 7 of January 2008, Michael Buesch wrote:
> On Sunday 06 January 2008 23:01:00 John W. Linville wrote:
> > On Sun, Jan 06, 2008 at 10:38:43PM +0100, Michael Buesch wrote:
> > > On Sunday 06 January 2008 22:35:51 Pavel Roskin wrote:
> > > > Quoting Michael Buesch <mb at bu3sch.de>:
> > > > 
> > > > > see "fwpostfix" module parameter
> > > > 
> > > > Can we please avoid this annoyance this time?
> > > 
> > > Go and complain at Broadcom please.
> > 
> > Broadcom doesn't really have this problem, since they are free to
> > include the binary firmware in their Windows/Mac/whatever drivers.
> > 
> > If the driver needs different firmware, why not have it ask for
> > different filenames?  As I suggested elsewhere, this could be as
> > simple as setting a default value for fwpostfix...
> 
> I'm not sure why people are complaining about stuff that's not
> done, yet. I just said that we need an update to an incompatible
> firmware soon. HOW that happens is an entirely different question.
> It seems like we _might_ be able to support both fw versions for some
> limited time. If that is not possible for whatever reason, I will
> change the fw filenames, of course. (And people will complain about
> that, too. Because the rule for broadcom firmware is: Always complain
> about whatever you do. ;) )
> The _just_ wanted to tell people about a serious change _before_ it
> happens. I'm not sure why this results in all kinds of complaints.

Most probably, because the people don't want that to happen. ;-)

Greetings,
Rafael


From mb at bu3sch.de  Mon Jan  7 00:27:54 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 7 Jan 2008 00:27:54 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801070028.15776.rjw@sisk.pl>
References: <200801061802.38297.mb@bu3sch.de> <200801070002.11271.mb@bu3sch.de>
	<200801070028.15776.rjw@sisk.pl>
Message-ID: <200801070027.54717.mb@bu3sch.de>

On Monday 07 January 2008 00:28:15 Rafael J. Wysocki wrote:
> On Monday, 7 of January 2008, Michael Buesch wrote:
> > On Sunday 06 January 2008 23:01:00 John W. Linville wrote:
> > > On Sun, Jan 06, 2008 at 10:38:43PM +0100, Michael Buesch wrote:
> > > > On Sunday 06 January 2008 22:35:51 Pavel Roskin wrote:
> > > > > Quoting Michael Buesch <mb at bu3sch.de>:
> > > > > 
> > > > > > see "fwpostfix" module parameter
> > > > > 
> > > > > Can we please avoid this annoyance this time?
> > > > 
> > > > Go and complain at Broadcom please.
> > > 
> > > Broadcom doesn't really have this problem, since they are free to
> > > include the binary firmware in their Windows/Mac/whatever drivers.
> > > 
> > > If the driver needs different firmware, why not have it ask for
> > > different filenames?  As I suggested elsewhere, this could be as
> > > simple as setting a default value for fwpostfix...
> > 
> > I'm not sure why people are complaining about stuff that's not
> > done, yet. I just said that we need an update to an incompatible
> > firmware soon. HOW that happens is an entirely different question.
> > It seems like we _might_ be able to support both fw versions for some
> > limited time. If that is not possible for whatever reason, I will
> > change the fw filenames, of course. (And people will complain about
> > that, too. Because the rule for broadcom firmware is: Always complain
> > about whatever you do. ;) )
> > The _just_ wanted to tell people about a serious change _before_ it
> > happens. I'm not sure why this results in all kinds of complaints.
> 
> Most probably, because the people don't want that to happen. ;-)

People don't want N-PHY support?

-- 
Greetings Michael.


From rjw at sisk.pl  Mon Jan  7 00:51:55 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Mon, 7 Jan 2008 00:51:55 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801070027.54717.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de> <200801070028.15776.rjw@sisk.pl>
	<200801070027.54717.mb@bu3sch.de>
Message-ID: <200801070051.55678.rjw@sisk.pl>

On Monday, 7 of January 2008, Michael Buesch wrote:
> On Monday 07 January 2008 00:28:15 Rafael J. Wysocki wrote:
> > On Monday, 7 of January 2008, Michael Buesch wrote:
> > > On Sunday 06 January 2008 23:01:00 John W. Linville wrote:
> > > > On Sun, Jan 06, 2008 at 10:38:43PM +0100, Michael Buesch wrote:
> > > > > On Sunday 06 January 2008 22:35:51 Pavel Roskin wrote:
> > > > > > Quoting Michael Buesch <mb at bu3sch.de>:
> > > > > > 
> > > > > > > see "fwpostfix" module parameter
> > > > > > 
> > > > > > Can we please avoid this annoyance this time?
> > > > > 
> > > > > Go and complain at Broadcom please.
> > > > 
> > > > Broadcom doesn't really have this problem, since they are free to
> > > > include the binary firmware in their Windows/Mac/whatever drivers.
> > > > 
> > > > If the driver needs different firmware, why not have it ask for
> > > > different filenames?  As I suggested elsewhere, this could be as
> > > > simple as setting a default value for fwpostfix...
> > > 
> > > I'm not sure why people are complaining about stuff that's not
> > > done, yet. I just said that we need an update to an incompatible
> > > firmware soon. HOW that happens is an entirely different question.
> > > It seems like we _might_ be able to support both fw versions for some
> > > limited time. If that is not possible for whatever reason, I will
> > > change the fw filenames, of course. (And people will complain about
> > > that, too. Because the rule for broadcom firmware is: Always complain
> > > about whatever you do. ;) )
> > > The _just_ wanted to tell people about a serious change _before_ it
> > > happens. I'm not sure why this results in all kinds of complaints.
> > 
> > Most probably, because the people don't want that to happen. ;-)
> 
> People don't want N-PHY support?

Well, as it sometimes is said "the better is an enemy of the good".  If they
feel comfortable without the N-PHY, why would they want it?

Still, if you can add the support for it as a feature that doesn't affect the
people's working configurations, no one will complain.

Greetings,
Rafael


From proski at gnu.org  Mon Jan  7 01:03:12 2008
From: proski at gnu.org (Pavel Roskin)
Date: Sun, 06 Jan 2008 19:03:12 -0500
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801070051.55678.rjw@sisk.pl>
References: <200801061802.38297.mb@bu3sch.de>
	<200801070028.15776.rjw@sisk.pl> <200801070027.54717.mb@bu3sch.de>
	<200801070051.55678.rjw@sisk.pl>
Message-ID: <20080106190312.t6z7lptrokw00044@webmail.spamcop.net>

Quoting "Rafael J. Wysocki" <rjw at sisk.pl>:

>> People don't want N-PHY support?
>
> Well, as it sometimes is said "the better is an enemy of the good".  If they
> feel comfortable without the N-PHY, why would they want it?
>
> Still, if you can add the support for it as a feature that doesn't affect the
> people's working configurations, no one will complain.

I really want N-PHY and I have hardware to test it on.  It's just the  
word "fwprefix" that makes me allergic.

-- 
Regards,
Pavel Roskin


From mb at bu3sch.de  Mon Jan  7 01:05:16 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 7 Jan 2008 01:05:16 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801070051.55678.rjw@sisk.pl>
References: <200801061802.38297.mb@bu3sch.de> <200801070027.54717.mb@bu3sch.de>
	<200801070051.55678.rjw@sisk.pl>
Message-ID: <200801070105.17070.mb@bu3sch.de>

On Monday 07 January 2008 00:51:55 Rafael J. Wysocki wrote:
> On Monday, 7 of January 2008, Michael Buesch wrote:
> > On Monday 07 January 2008 00:28:15 Rafael J. Wysocki wrote:
> > > On Monday, 7 of January 2008, Michael Buesch wrote:
> > > > On Sunday 06 January 2008 23:01:00 John W. Linville wrote:
> > > > > On Sun, Jan 06, 2008 at 10:38:43PM +0100, Michael Buesch wrote:
> > > > > > On Sunday 06 January 2008 22:35:51 Pavel Roskin wrote:
> > > > > > > Quoting Michael Buesch <mb at bu3sch.de>:
> > > > > > > 
> > > > > > > > see "fwpostfix" module parameter
> > > > > > > 
> > > > > > > Can we please avoid this annoyance this time?
> > > > > > 
> > > > > > Go and complain at Broadcom please.
> > > > > 
> > > > > Broadcom doesn't really have this problem, since they are free to
> > > > > include the binary firmware in their Windows/Mac/whatever drivers.
> > > > > 
> > > > > If the driver needs different firmware, why not have it ask for
> > > > > different filenames?  As I suggested elsewhere, this could be as
> > > > > simple as setting a default value for fwpostfix...
> > > > 
> > > > I'm not sure why people are complaining about stuff that's not
> > > > done, yet. I just said that we need an update to an incompatible
> > > > firmware soon. HOW that happens is an entirely different question.
> > > > It seems like we _might_ be able to support both fw versions for some
> > > > limited time. If that is not possible for whatever reason, I will
> > > > change the fw filenames, of course. (And people will complain about
> > > > that, too. Because the rule for broadcom firmware is: Always complain
> > > > about whatever you do. ;) )
> > > > The _just_ wanted to tell people about a serious change _before_ it
> > > > happens. I'm not sure why this results in all kinds of complaints.
> > > 
> > > Most probably, because the people don't want that to happen. ;-)
> > 
> > People don't want N-PHY support?
> 
> Well, as it sometimes is said "the better is an enemy of the good".  If they
> feel comfortable without the N-PHY, why would they want it?
> 
> Still, if you can add the support for it as a feature that doesn't affect the
> people's working configurations, no one will complain.

Impossible, sorry.
We are going to add support for new firmware, which will be needed for N-PHY,
or we don't.
And I think it's clear which way we are going.
What's the problem with all of this? Other drivers change firmware to incompatible
versions on a regular basis. Look at ipw2200. There was a time when they changed
the firmware basically on every kernel release.
That wasn't a problem. Why would it be a problem here?

How the technical implementation of all that stuff works in the end
is not up to this discussion. Maybe we can support both firmware in one driver
for some limited time. Maybe we rename the firmware files once again.
I think it's likely to end up with a driver supporting 2 fw versions for a few
release cycles. But I simply can not tell you, yet.

I just wanted to tell people that a firmware change is going to happen soon.
Just informational stuff. Nothing people need to complain, suggest or argue about.

-- 
Greetings Michael.


From linville at tuxdriver.com  Mon Jan  7 00:49:24 2008
From: linville at tuxdriver.com (John W. Linville)
Date: Sun, 6 Jan 2008 18:49:24 -0500
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801070002.11271.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de> <200801062238.43666.mb@bu3sch.de>
	<20080106220100.GC3149@tuxdriver.com>
	<200801070002.11271.mb@bu3sch.de>
Message-ID: <20080106234924.GD3149@tuxdriver.com>

On Mon, Jan 07, 2008 at 12:02:11AM +0100, Michael Buesch wrote:

> The _just_ wanted to tell people about a serious change _before_ it
> happens. I'm not sure why this results in all kinds of complaints.

Don't be so inhuman... :-)  (For those just joining us, that is an
inside joke...)

Please don't confuse suggestions (intended to be helpful) with
complaints.

John
-- 
John W. Linville
linville at tuxdriver.com


From zajec5polish at gmail.com  Mon Jan  7 01:12:25 2008
From: zajec5polish at gmail.com (=?UTF-8?Q?Rafa=C5=82_Mi=C5=82ecki?=)
Date: Mon, 7 Jan 2008 01:12:25 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801070027.54717.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de> <200801070002.11271.mb@bu3sch.de>
	<200801070028.15776.rjw@sisk.pl> <200801070027.54717.mb@bu3sch.de>
Message-ID: <14b026160801061612y33006a84sf6f90f2a70dbd7cf@mail.gmail.com>

2008/1/7, Michael Buesch <mb at bu3sch.de>:
> People don't want N-PHY support?

Well, if your definition of people is similar to my one, they
definitely want it! :-) I think we are just a little afraid of
_possible_ problem with a few kernels installed at one time. Sometimes
I need to run basic kernel of my distro and use b43 with is included
in it. On the other hand I want to test the newest kernel with
improved b43 :)

-- 
Rafa? Mi?ecki

From mb at bu3sch.de  Mon Jan  7 01:15:33 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 7 Jan 2008 01:15:33 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <14b026160801061612y33006a84sf6f90f2a70dbd7cf@mail.gmail.com>
References: <200801061802.38297.mb@bu3sch.de> <200801070027.54717.mb@bu3sch.de>
	<14b026160801061612y33006a84sf6f90f2a70dbd7cf@mail.gmail.com>
Message-ID: <200801070115.34161.mb@bu3sch.de>

On Monday 07 January 2008 01:12:25 Rafa? Mi?ecki wrote:
> 2008/1/7, Michael Buesch <mb at bu3sch.de>:
> > People don't want N-PHY support?
> 
> Well, if your definition of people is similar to my one, they
> definitely want it! :-) I think we are just a little afraid of
> _possible_ problem with a few kernels installed at one time. Sometimes
> I need to run basic kernel of my distro and use b43 with is included
> in it. On the other hand I want to test the newest kernel with
> improved b43 :)

Don't worry about that. This will be possible, of course.
Everybody on earth runs a similiar configuration. Even me. ;)

-- 
Greetings Michael.


From stefano.brivio at polimi.it  Mon Jan  7 01:17:37 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Mon, 7 Jan 2008 01:17:37 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <20080106190312.t6z7lptrokw00044@webmail.spamcop.net>
References: <200801061802.38297.mb@bu3sch.de> <200801070028.15776.rjw@sisk.pl>
	<200801070027.54717.mb@bu3sch.de> <200801070051.55678.rjw@sisk.pl>
	<20080106190312.t6z7lptrokw00044@webmail.spamcop.net>
Message-ID: <20080107011737.2390efe6@morte>

On Sun, 06 Jan 2008 19:03:12 -0500
Pavel Roskin <proski at gnu.org> wrote:

> Quoting "Rafael J. Wysocki" <rjw at sisk.pl>:
> 
> >> People don't want N-PHY support?
> >
> > Well, as it sometimes is said "the better is an enemy of the good".  If they
> > feel comfortable without the N-PHY, why would they want it?
> >
> > Still, if you can add the support for it as a feature that doesn't affect the
> > people's working configurations, no one will complain.
> 
> I really want N-PHY and I have hardware to test it on.  It's just the  
> word "fwprefix" that makes me allergic.

Please note that nobody suggested to use "fwpostfix" in order to support
regular migration from a kernel version to another one. That was proposed
as a convenient way in order to switch back and forth between two kernel
versions.

Did anybody ever complain about ipw2200 very frequent firmware changes
between kernel versions (i.e.
http://ipw2200.sourceforge.net/firmware.php)? This would be the second firmware change for bcm43xx/b43.

Please also note then that having b43-fwcutter to rename firmware
according to its capabilities could be disruptive too (as people already
have a lot of fun by downloading unsupported firmwares, and this would
just confuse the users even more). A big fat printk that tells the user that
the firmware found in /lib/firmware is unsupported and displays a
linuxwireless.org URL seems the best solution to me. But again, Michael
wasn't even talking about one particular implementation, he just wanted to
warn in advance about a likely firmware change in the future.

I know that distros out there are having even more fun than users in
messing up this sort of things, but this can't really be claimed to be our
fault.


--
Ciao
Stefano


From post at hendrik-sattler.de  Mon Jan  7 02:25:20 2008
From: post at hendrik-sattler.de (Hendrik Sattler)
Date: Mon, 7 Jan 2008 02:25:20 +0100
Subject: b43 will need a firmware upgrade soon
In-Reply-To: <200801070105.17070.mb@bu3sch.de>
References: <200801061802.38297.mb@bu3sch.de> <200801070051.55678.rjw@sisk.pl>
	<200801070105.17070.mb@bu3sch.de>
Message-ID: <200801070225.21056.post@hendrik-sattler.de>

Am Montag 07 Januar 2008 schrieb Michael Buesch:
> > Still, if you can add the support for it as a feature that doesn't affect
> > the people's working configurations, no one will complain.
>
> Impossible, sorry.
> We are going to add support for new firmware, which will be needed for
> N-PHY, or we don't.
> And I think it's clear which way we are going.

N-PHY support is surely wanted, noone doubts that.

> What's the problem with all of this? Other drivers change firmware to
> incompatible versions on a regular basis. Look at ipw2200. There was a time
> when they changed the firmware basically on every kernel release.
> That wasn't a problem. Why would it be a problem here?

The problem is _not_ to actually need a newer firmware for a newer kernel. 
That can be managed easily and was simple for the change bcm43xx -> b43.
However, being able to use different kernel version painlessly is a major 
feature.

Modprobe cannot use different configs for different kernel versions, so the 
fwpostfix option doesn't help in userspace.

The only work-around would be to change /lib/udev/firmware.agent to also use 
the kernel version when looping over possible firmware directories. Clumsy at 
best, especially since the driver knows best about the difference.

I already suggested to make the ABI part of the directory name (maybe even 
kill fwpostfix for it, anyone actually using that one for real?). That's a 
one-minute change in the driver (one #define and one other one-liner in 
main.c) and an additional table field in fwcutter. You have to update the 
latter anyway to let it know about the new firmware files, anyway.
With that, you can require a different firmware ABI on kernel version change 
and possible noone will complain. And you don't have to support multiple ABIs 
at the same time.

HS


From mb at bu3sch.de  Mon Jan  7 12:55:14 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 7 Jan 2008 12:55:14 +0100
Subject: [PATCH] b43: Add N-PHY related initvals firmware filenames.
Message-ID: <200801071255.15036.mb@bu3sch.de>

This adds the initval filenames for the N-PHY firmware.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Stuff for 2.6.25

Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-06 00:12:08.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-06 00:12:08.000000000 +0100
@@ -1671,12 +1671,18 @@ static int b43_request_firmware(struct b
 				filename = "b0g0initvals5";
 			else if (rev >= 13)
 				filename = "lp0initvals13";
 			else
 				goto err_no_initvals;
 			break;
+		case B43_PHYTYPE_N:
+			if ((rev >= 11) && (rev <= 12))
+				filename = "n0initvals11";
+			else
+				goto err_no_initvals;
+			break;
 		default:
 			goto err_no_initvals;
 		}
 		err = do_request_fw(dev, filename, &fw->initvals);
 		if (err)
 			goto err_load;
@@ -1699,12 +1705,18 @@ static int b43_request_firmware(struct b
 				filename = "b0g0bsinitvals5";
 			else if (rev >= 11)
 				filename = NULL;
 			else
 				goto err_no_initvals;
 			break;
+		case B43_PHYTYPE_N:
+			if ((rev >= 11) && (rev <= 12))
+				filename = "n0bsinitvals11";
+			else
+				goto err_no_initvals;
+			break;
 		default:
 			goto err_no_initvals;
 		}
 		err = do_request_fw(dev, filename, &fw->initvals_band);
 		if (err)
 			goto err_load;


From joerg at alea.gnuu.de  Mon Jan  7 11:44:56 2008
From: joerg at alea.gnuu.de (=?UTF-8?Q?J=C3=B6rg?= Sommer)
Date: Mon, 7 Jan 2008 10:44:56 +0000 (UTC)
Subject: b43 will need a firmware upgrade soon
References: <200801061802.38297.mb@bu3sch.de>
	<200801070051.55678.rjw@sisk.pl> <200801070105.17070.mb@bu3sch.de>
	<200801070225.21056.post@hendrik-sattler.de>
Message-ID: <slrnfo40l9.cgh.joerg@alea.gnuu.de>

Hallo Hendrik,

Hendrik Sattler <post at hendrik-sattler.de> wrote:
> Am Montag 07 Januar 2008 schrieb Michael Buesch:
>> What's the problem with all of this? Other drivers change firmware to
>> incompatible versions on a regular basis. Look at ipw2200. There was a time
>> when they changed the firmware basically on every kernel release.
>> That wasn't a problem. Why would it be a problem here?
>
> Modprobe cannot use different configs for different kernel versions, so the 
> fwpostfix option doesn't help in userspace.

Why not? Put something like this in your modprobe.conf

install b43 case "$(uname -r)" in 2.6.25*) /sbin/insmod b43 fwprefix=new;; /sbin/insmod b43;; esac

It's not tested. It should only illustrate the idea!

Bye, J?rg.
-- 
?UNIX was not designed to stop people from doing stupid things, because
 that would also stop them from doing clever things.?
            (Doug Gwyn)


From dan at f-box.org  Mon Jan  7 22:34:47 2008
From: dan at f-box.org (Daniel)
Date: Mon, 07 Jan 2008 21:34:47 +0000
Subject: b43 Injection?
Message-ID: <47829AF7.50706@f-box.org>

Hello,

I've started tinkering with a patch for the b43 driver to allow 
injection. I just wondered if anyone else has done this yet? And if 
there is some pointers to the differences between bcm43xx and b43 
because I'm not finding it that easy so far ;)


Cheers,

DanBUK.


From dan at f-box.org  Tue Jan  8 00:00:15 2008
From: dan at f-box.org (Daniel Bartlett)
Date: Mon, 07 Jan 2008 23:00:15 +0000
Subject: b43 Injection?
In-Reply-To: <47829AF7.50706@f-box.org>
References: <47829AF7.50706@f-box.org>
Message-ID: <4782AEFF.4060900@f-box.org>

Hello Again,

I guess what is stumping me at the moment is where the

struct ieee80211_tx_control *ctl

comes from that is passed to b43_dma/pio_tx comes from?

I have grep'ed through b43 / ssb and not come up with where it is 
initialised. Any pointers?


Cheers,

DanBUK.


From dan at f-box.org  Tue Jan  8 00:32:19 2008
From: dan at f-box.org (Daniel)
Date: Mon, 07 Jan 2008 23:32:19 +0000
Subject: b43 Injection?
In-Reply-To: <4782B441.5040602@wetwork.net>
References: <47829AF7.50706@f-box.org> <4782AEFF.4060900@f-box.org>
	<4782B441.5040602@wetwork.net>
Message-ID: <4782B683.6060906@f-box.org>

Hello Ehud,

Sorry I meant each function b43_dma_tx b43_pio_tx.

c-box b43 # grep -Hnr b43_dma_tx *
dma.c:1201:int b43_dma_tx(struct b43_wldev *dev,

c-box b43 # grep -Hnr b43_pio_tx *
pio.c:428:int b43_pio_tx(struct b43_wldev *dev,


I am trying to convert the injection patch from bcm43xx which is found here:
http://atros.org/bcm43xx-injection-linux-2.6.22.patch

The issue is the newer b43 is using mac80211 therefore has more 
surrounding it, which I am not finding well docuemented. I have started 
reading http://johannes.sipsolutions.net/files/mac80211/ but it's not 
complete.

I am now thinking that it might be possible to use b43_pio_txpacket and 
possibly dma_tx_fragment

Cheers,

Dan.


From identd_ at hotmail.com  Tue Jan  8 16:31:53 2008
From: identd_ at hotmail.com (David Ellingsworth)
Date: Tue, 8 Jan 2008 10:31:53 -0500
Subject: b43 Injection?
In-Reply-To: <4782B683.6060906@f-box.org>
References: <47829AF7.50706@f-box.org> <4782AEFF.4060900@f-box.org>
	<4782B441.5040602@wetwork.net>  <4782B683.6060906@f-box.org>
Message-ID: <BAY128-W45DFB9A110D523E59BE21486480@phx.gbl>


Dan -

> Sorry I meant each function b43_dma_tx b43_pio_tx.
>
> c-box b43 # grep -Hnr b43_dma_tx *
> dma.c:1201:int b43_dma_tx(struct b43_wldev *dev,
>
> c-box b43 # grep -Hnr b43_pio_tx *
> pio.c:428:int b43_pio_tx(struct b43_wldev *dev,
>

There is a b43_tx function in main.c which calls the above tx methods when appropriate.

> I am trying to convert the injection patch from bcm43xx which is found here:
> http://atros.org/bcm43xx-injection-linux-2.6.22.patch
>
> The issue is the newer b43 is using mac80211 therefore has more
> surrounding it, which I am not finding well docuemented. I have started
> reading http://johannes.sipsolutions.net/files/mac80211/ but it's not
> complete.
>

mac80211 supposedly has support for packet injection. Like you however, I have have not been able to get packet injection to work with the b43/b43legacy drivers and the developers have expressed that they are not interested in supporting packet injection.

> I am now thinking that it might be possible to use b43_pio_txpacket and
> possibly dma_tx_fragment
>
> Cheers,
>
> Dan.

If you do however get packet injection working for the b43 driver, I would be interested in evaluating your patch and possibly porting it to the b43legacy driver.

Regards,

David Ellingsworth
_________________________________________________________________
Share life as it happens with the new Windows Live.
http://www.windowslive.com/share.html?ocid=TXT_TAGHM_Wave2_sharelife_012008

From mb at bu3sch.de  Tue Jan  8 16:57:09 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 8 Jan 2008 16:57:09 +0100
Subject: b43 Injection?
In-Reply-To: <BAY128-W45DFB9A110D523E59BE21486480@phx.gbl>
References: <47829AF7.50706@f-box.org> <4782B683.6060906@f-box.org>
	<BAY128-W45DFB9A110D523E59BE21486480@phx.gbl>
Message-ID: <200801081657.09344.mb@bu3sch.de>

On Tuesday 08 January 2008 16:31:53 David Ellingsworth wrote:
> mac80211 supposedly has support for packet injection. Like you however, I have have not been able to get packet injection to work with the b43/b43legacy drivers and the developers have expressed that they are not interested in supporting packet injection.

mac80211 has support for packet injection and people say it works.
I didn't try it myself, yet. But I don't see a reason for it to work with one
driver but not with b43.

> > I am now thinking that it might be possible to use b43_pio_txpacket and
> > possibly dma_tx_fragment
> >
> > Cheers,
> >
> > Dan.
> 
> If you do however get packet injection working for the b43 driver, I would be interested in evaluating your patch and possibly porting it to the b43legacy driver.

I think there's no patch needed.


-- 
Greetings Michael.


From identd_ at hotmail.com  Tue Jan  8 18:14:00 2008
From: identd_ at hotmail.com (David Ellingsworth)
Date: Tue, 8 Jan 2008 12:14:00 -0500
Subject: b43 Injection?
In-Reply-To: <200801081657.09344.mb@bu3sch.de>
References: <47829AF7.50706@f-box.org> <4782B683.6060906@f-box.org>
	<BAY128-W45DFB9A110D523E59BE21486480@phx.gbl>
	<200801081657.09344.mb@bu3sch.de>
Message-ID: <BAY128-W28C9D58153FC7A220D61C686480@phx.gbl>


Michael -

> On Tuesday 08 January 2008 16:31:53 David Ellingsworth wrote:
>> mac80211 supposedly has support for packet injection. Like you however, I have have not been able to get packet injection to work with the b43/b43legacy drivers and the developers have expressed that they are not interested in supporting packet injection.
>
> mac80211 has support for packet injection and people say it works.
> I didn't try it myself, yet. But I don't see a reason for it to work with one
> driver but not with b43.
>

When tested with the current development version of aireplay-ng I do recieve a sucessful packet injection response with the b43legacy driver, but 29 out of 30 attempts fail during its built-in test. The bcm43xx driver with the patch provided by the aircrack-ng developers has a much better ratio, but ultimately results in out of memory and DMA errors from the driver during my own tests.

>>> I am now thinking that it might be possible to use b43_pio_txpacket and
>>> possibly dma_tx_fragment
>>>
>>> Cheers,
>>>
>>> Dan.
>>
>> If you do however get packet injection working for the b43 driver, I would be interested in evaluating your patch and possibly porting it to the b43legacy driver.
>
> I think there's no patch needed.
>

Agreed, the b43/b43legacy drivers may not be at fault and may not require modification. Unfortunately I am not able to monitor my tests with another wireless card to evaluate the issues I have been experiencing while using the b43legacy driver.

>
> --
> Greetings Michael.


Regards,

David Ellingsworth
_________________________________________________________________
Watch ?Cause Effect,? a show about real people making a real difference.
http://im.live.com/Messenger/IM/MTV/?source=text_watchcause

From johannes at sipsolutions.net  Tue Jan  8 18:25:17 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Tue, 08 Jan 2008 18:25:17 +0100
Subject: b43 Injection?
In-Reply-To: <200801081657.09344.mb@bu3sch.de>
	(sfid-20080108_155906_098147_F68EA1A6)
References: <47829AF7.50706@f-box.org> <4782B683.6060906@f-box.org>
	<BAY128-W45DFB9A110D523E59BE21486480@phx.gbl>
	<200801081657.09344.mb@bu3sch.de>
	(sfid-20080108_155906_098147_F68EA1A6)
Message-ID: <1199813117.6762.10.camel@johannes.berg>



> mac80211 has support for packet injection and people say it works.

works fine, hostapd uses it now. if (as said later in this thread)
aireplay doesn't work it's at fault.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20080108/8358921d/attachment.pgp>

From dan at f-box.org  Tue Jan  8 21:23:18 2008
From: dan at f-box.org (Daniel)
Date: Tue, 08 Jan 2008 20:23:18 +0000
Subject: b43 Injection?
In-Reply-To: <1199813117.6762.10.camel@johannes.berg>
References: <47829AF7.50706@f-box.org>
	<4782B683.6060906@f-box.org>	<BAY128-W45DFB9A110D523E59BE21486480@phx.gbl>	<200801081657.09344.mb@bu3sch.de>	(sfid-20080108_155906_098147_F68EA1A6)
	<1199813117.6762.10.camel@johannes.berg>
Message-ID: <4783DBB6.5020307@f-box.org>

Hello,

Johannes Berg wrote:
>> mac80211 has support for packet injection and people say it works.

This is a very good point, mac80211 (if patched) can handle packet 
injection. I have tested it on 2 aps so far but with no success. I think 
I'm going to add some kernel prints into the sources..

The patch is in the aircrack-ng SVN(maybe their tarballs just I only 
checked the SVN).
http://trac.aircrack-ng.org/svn/trunk/patches/ieee80211_inject.patch

I am not sure if this patch is actually working I'm going to investigate 
further..


Cheers,

DanB UK.

(Now I look at this email I wonder if my patch is even relevant, 
mac80211/ieee80211?? Uhmm the same?)


From mb at bu3sch.de  Tue Jan  8 21:27:10 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 8 Jan 2008 21:27:10 +0100
Subject: b43 Injection?
In-Reply-To: <4783DBB6.5020307@f-box.org>
References: <47829AF7.50706@f-box.org> <1199813117.6762.10.camel@johannes.berg>
	<4783DBB6.5020307@f-box.org>
Message-ID: <200801082127.10442.mb@bu3sch.de>

On Tuesday 08 January 2008 21:23:18 Daniel wrote:
> Hello,
> 
> Johannes Berg wrote:
> >> mac80211 has support for packet injection and people say it works.
> 
> This is a very good point, mac80211 (if patched) can handle packet 
> injection.

It should work without any patches.

> The patch is in the aircrack-ng SVN(maybe their tarballs just I only 
> checked the SVN).
> http://trac.aircrack-ng.org/svn/trunk/patches/ieee80211_inject.patch

This is not a patch against mac80211.

-- 
Greetings Michael.


From dan at f-box.org  Tue Jan  8 21:32:04 2008
From: dan at f-box.org (Daniel Bartlett)
Date: Tue, 08 Jan 2008 20:32:04 +0000
Subject: b43 Injection?
In-Reply-To: <200801082127.10442.mb@bu3sch.de>
References: <47829AF7.50706@f-box.org> <1199813117.6762.10.camel@johannes.berg>
	<4783DBB6.5020307@f-box.org> <200801082127.10442.mb@bu3sch.de>
Message-ID: <4783DDC4.5040700@f-box.org>

Hey,

Michael Buesch wrote:
> On Tuesday 08 January 2008 21:23:18 Daniel wrote:
>> Johannes Berg wrote:
>>>> mac80211 has support for packet injection and people say it works.
>> This is a very good point, mac80211 (if patched) can handle packet 
>> injection.
> 
> It should work without any patches.

 From looking at the aircrack-ng trac site I came across this:

http://trac.aircrack-ng.org/ticket/180

> 
>> The patch is in the aircrack-ng SVN(maybe their tarballs just I only 
>> checked the SVN).
>> http://trac.aircrack-ng.org/svn/trunk/patches/ieee80211_inject.patch
> 
> This is not a patch against mac80211.

I realised at the end of the email, but somehow thought I should note 
down my mistake!

I'll investigate this route further.


Cheers,

Dan.


From dan at f-box.org  Tue Jan  8 23:20:29 2008
From: dan at f-box.org (Daniel)
Date: Tue, 08 Jan 2008 22:20:29 +0000
Subject: b43 Injection? Yes!
In-Reply-To: <4783DDC4.5040700@f-box.org>
References: <47829AF7.50706@f-box.org>
	<1199813117.6762.10.camel@johannes.berg>	<4783DBB6.5020307@f-box.org>
	<200801082127.10442.mb@bu3sch.de> <4783DDC4.5040700@f-box.org>
Message-ID: <4783F72D.6020001@f-box.org>

Hello All,

Daniel Bartlett wrote:
> I'll investigate this route further.

Well indeed I have, and aircrack-ng-1.0-dev injects fine with b43.

Just need to use the SVN copy:

svn co http://trac.aircrack-ng.org/svn/branch/1.0-dev/
cd 1.0-dev/
make install

And there you are! Well unless you want to be careful with your install 
prefix...

c-box aircrack-ng-1.0 # ./sbin/aireplay-ng -9 wlan0
22:16:10  Trying broadcast probe requests...
22:16:10  Injection is working!
22:16:12  Found 1 AP

22:16:12  Trying directed probe requests...
22:16:12  00:90:D0:E3:18:E4 - channel: 3 - 'WEA'
22:16:17  Ping (min/avg/max): 2.402ms/165.070ms/197.719ms Power: 191.81
22:16:17  21/30:  70%


Cheers,

Dan.

PS. Sorry for the pointless noise on the list, well not completely 
pointless hopefully someone might find the reference to b43 inject 
injection aircrack wlan when they hit a search engine!


From identd_ at hotmail.com  Wed Jan  9 01:46:41 2008
From: identd_ at hotmail.com (David Ellingsworth)
Date: Tue, 8 Jan 2008 19:46:41 -0500
Subject: b43 Injection? Yes!
In-Reply-To: <4783F72D.6020001@f-box.org>
References: <47829AF7.50706@f-box.org>
	<1199813117.6762.10.camel@johannes.berg>	<4783DBB6.5020307@f-box.org>
	<200801082127.10442.mb@bu3sch.de> <4783DDC4.5040700@f-box.org> 
	<4783F72D.6020001@f-box.org>
Message-ID: <BAY128-W110B9383A2AA9ABD2D2DAF86490@phx.gbl>


> c-box aircrack-ng-1.0 # ./sbin/aireplay-ng -9 wlan0
> 22:16:10  Trying broadcast probe requests...
> 22:16:10  Injection is working!
> 22:16:12  Found 1 AP
> 
> 22:16:12  Trying directed probe requests...
> 22:16:12  00:90:D0:E3:18:E4 - channel: 3 - 'WEA'
> 22:16:17  Ping (min/avg/max): 2.402ms/165.070ms/197.719ms Power: 191.81
> 22:16:17  21/30:  70%
> 
 
I wish I could say the same for the b43legacy driver.. here are my results from the same version of aireplay:
 
# ./aireplay-ng -9 wlan0
19:27:51  Trying broadcast probe requests...
19:27:53  No Answer...
19:27:53  Found 2 APs
 
19:27:53  Trying directed probe requests...
19:27:53  00:14:D1:43:88:04 - channel: 6 - 'ap1'
19:28:00   0/30:   0%
 
19:28:00  00:06:25:67:1D:14 - channel: 6 - 'ap2'
19:28:06   0/30:   0%
 
Regards,
 
David Ellingsworth
_________________________________________________________________
Make distant family not so distant with Windows Vista? + Windows Live?.
http://www.microsoft.com/windows/digitallife/keepintouch.mspx?ocid=TXT_TAGLM_CPC_VideoChat_distantfamily_012008

From stefano.brivio at polimi.it  Wed Jan  9 11:35:24 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Wed, 9 Jan 2008 11:35:24 +0100
Subject: b43 Injection? Yes!
In-Reply-To: <BAY128-W110B9383A2AA9ABD2D2DAF86490@phx.gbl>
References: <47829AF7.50706@f-box.org> <1199813117.6762.10.camel@johannes.berg>
	<4783DBB6.5020307@f-box.org> <200801082127.10442.mb@bu3sch.de>
	<4783DDC4.5040700@f-box.org> <4783F72D.6020001@f-box.org>
	<BAY128-W110B9383A2AA9ABD2D2DAF86490@phx.gbl>
Message-ID: <20080109113524.0e81d5d6@morte>

On Tue, 8 Jan 2008 19:46:41 -0500
David Ellingsworth <identd_ at hotmail.com> wrote:

> I wish I could say the same for the b43legacy driver.. here are my results from the same version of aireplay:
>  
> # ./aireplay-ng -9 wlan0
> 19:27:51  Trying broadcast probe requests...
> 19:27:53  No Answer...
> 19:27:53  Found 2 APs
>  
> 19:27:53  Trying directed probe requests...
> 19:27:53  00:14:D1:43:88:04 - channel: 6 - 'ap1'
> 19:28:00   0/30:   0%
>  
> 19:28:00  00:06:25:67:1D:14 - channel: 6 - 'ap2'
> 19:28:06   0/30:   0%

Could you try the aireplay-ng test with the same setup but with a different
driver/device? Could you show me some more debugging information?


--
Ciao
Stefano


From identd_ at hotmail.com  Wed Jan  9 14:27:57 2008
From: identd_ at hotmail.com (David Ellingsworth)
Date: Wed, 9 Jan 2008 08:27:57 -0500
Subject: b43 Injection? Yes!
In-Reply-To: <20080109113524.0e81d5d6@morte>
References: <47829AF7.50706@f-box.org>
	<1199813117.6762.10.camel@johannes.berg> <4783DBB6.5020307@f-box.org>
	<200801082127.10442.mb@bu3sch.de> 	<4783DDC4.5040700@f-box.org>
	<4783F72D.6020001@f-box.org>
	<BAY128-W110B9383A2AA9ABD2D2DAF86490@phx.gbl> 
	<20080109113524.0e81d5d6@morte>
Message-ID: <BAY128-W37809217A785C7818AEE786490@phx.gbl>


> On Tue, 8 Jan 2008 19:46:41 -0500
> David Ellingsworth  wrote:
>
>> I wish I could say the same for the b43legacy driver.. here are my results from the same version of aireplay:
>>
>> # ./aireplay-ng -9 wlan0
>> 19:27:51 Trying broadcast probe requests...
>> 19:27:53 No Answer...
>> 19:27:53 Found 2 APs
>>
>> 19:27:53 Trying directed probe requests...
>> 19:27:53 00:14:D1:43:88:04 - channel: 6 - 'ap1'
>> 19:28:00 0/30: 0%
>>
>> 19:28:00 00:06:25:67:1D:14 - channel: 6 - 'ap2'
>> 19:28:06 0/30: 0%
>
> Could you try the aireplay-ng test with the same setup but with a different
> driver/device? Could you show me some more debugging information?
>

I do not have another device on which to test aireplay, but I did start obtaining more successful results after moving closer to the APs that were available. From what I can tell, injection is indeed working as was reported for the b43 driver but the time delay in aireplay from when injected packets are sent and when they are received appears to be too small to be successful under some circumstances.

Regards,

David Ellingsworth
_________________________________________________________________
Share life as it happens with the new Windows Live.
http://www.windowslive.com/share.html?ocid=TXT_TAGHM_Wave2_sharelife_012008

From mb at bu3sch.de  Wed Jan  9 16:13:56 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 9 Jan 2008 16:13:56 +0100
Subject: [PATCH] b43: Add N-PHY register definitions
Message-ID: <200801091613.57304.mb@bu3sch.de>

This patch adds all register definitions for the N-PHY.
This adds two new files: nphy.h and nphy.c
No functional changes to existing code.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

Stuff for 2.6.25

Index: wireless-2.6/drivers/net/wireless/b43/nphy.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ wireless-2.6/drivers/net/wireless/b43/nphy.h	2008-01-09 16:02:31.000000000 +0100
@@ -0,0 +1,706 @@
+#ifndef B43_NPHY_H_
+#define B43_NPHY_H_
+
+#include "phy.h"
+
+
+/* N-PHY registers. */
+
+#define B43_NPHY_BBCFG				B43_PHY_N(0x001) /* BB config */
+#define  B43_NPHY_BBCFG_RSTCCA			0x4000 /* Reset CCA */
+#define  B43_NPHY_BBCFG_RSTRX			0x8000 /* Reset RX */
+#define B43_NPHY_CHANNEL			B43_PHY_N(0x005) /* Channel */
+#define B43_NPHY_TXERR				B43_PHY_N(0x007) /* TX error */
+#define B43_NPHY_BANDCTL			B43_PHY_N(0x009) /* Band control */
+#define B43_NPHY_4WI_ADDR			B43_PHY_N(0x00B) /* Four-wire bus address */
+#define B43_NPHY_4WI_DATAHI			B43_PHY_N(0x00C) /* Four-wire bus data high */
+#define B43_NPHY_4WI_DATALO			B43_PHY_N(0x00D) /* Four-wire bus data low */
+#define B43_NPHY_BIST_STAT0			B43_PHY_N(0x00E) /* Built-in self test status 0 */
+#define B43_NPHY_BIST_STAT1			B43_PHY_N(0x00F) /* Built-in self test status 1 */
+
+#define B43_NPHY_C1_DESPWR			B43_PHY_N(0x018) /* Core 1 desired power */
+#define B43_NPHY_C1_CCK_DESPWR			B43_PHY_N(0x019) /* Core 1 CCK desired power */
+#define B43_NPHY_C1_BCLIPBKOFF			B43_PHY_N(0x01A) /* Core 1 barely clip backoff */
+#define B43_NPHY_C1_CCK_BCLIPBKOFF		B43_PHY_N(0x01B) /* Core 1 CCK barely clip backoff */
+#define B43_NPHY_C1_CGAINI			B43_PHY_N(0x01C) /* Core 1 compute gain info */
+#define  B43_NPHY_C1_CGAINI_GAINBKOFF		0x001F /* Gain backoff */
+#define  B43_NPHY_C1_CGAINI_CLIPGBKOFF		0x03E0 /* Clip gain backoff */
+#define  B43_NPHY_C1_CGAINI_GAINSTEP		0x1C00 /* Gain step */
+#define  B43_NPHY_C1_CGAINI_CL2DETECT		0x2000 /* Clip 2 detect mask */
+#define B43_NPHY_C1_CCK_CGAINI			B43_PHY_N(0x01D) /* Core 1 CCK compute gain info */
+#define  B43_NPHY_C1_CCK_CGAINI_GAINBKOFF	0x001F /* Gain backoff */
+#define  B43_NPHY_C1_CCK_CGAINI_CLIPGBKOFF	0x01E0 /* CCK barely clip gain backoff */
+#define B43_NPHY_C1_MINMAX_GAIN			B43_PHY_N(0x01E) /* Core 1 min/max gain */
+#define  B43_NPHY_C1_MINGAIN			0x00FF /* Minimum gain */
+#define  B43_NPHY_C1_MINGAIN_SHIFT		0
+#define  B43_NPHY_C1_MAXGAIN			0xFF00 /* Maximum gain */
+#define  B43_NPHY_C1_MAXGAIN_SHIFT		8
+#define B43_NPHY_C1_CCK_MINMAX_GAIN		B43_PHY_N(0x01F) /* Core 1 CCK min/max gain */
+#define  B43_NPHY_C1_CCK_MINGAIN		0x00FF /* Minimum gain */
+#define  B43_NPHY_C1_CCK_MINGAIN_SHIFT		0
+#define  B43_NPHY_C1_CCK_MAXGAIN		0xFF00 /* Maximum gain */
+#define  B43_NPHY_C1_CCK_MAXGAIN_SHIFT		8
+#define B43_NPHY_C1_INITGAIN			B43_PHY_N(0x020) /* Core 1 initial gain code */
+#define  B43_NPHY_C1_INITGAIN_EXTLNA		0x0001 /* External LNA index */
+#define  B43_NPHY_C1_INITGAIN_LNA		0x0006 /* LNA index */
+#define  B43_NPHY_C1_INITGAIN_LNAIDX_SHIFT	1
+#define  B43_NPHY_C1_INITGAIN_HPVGA1		0x0078 /* HPVGA1 index */
+#define  B43_NPHY_C1_INITGAIN_HPVGA1_SHIFT	3
+#define  B43_NPHY_C1_INITGAIN_HPVGA2		0x0F80 /* HPVGA2 index */
+#define  B43_NPHY_C1_INITGAIN_HPVGA2_SHIFT	7
+#define  B43_NPHY_C1_INITGAIN_TRRX		0x1000 /* TR RX index */
+#define  B43_NPHY_C1_INITGAIN_TRTX		0x2000 /* TR TX index */
+#define B43_NPHY_C1_CLIP1_HIGAIN		B43_PHY_N(0x021) /* Core 1 clip1 high gain code */
+#define B43_NPHY_C1_CLIP1_MEDGAIN		B43_PHY_N(0x022) /* Core 1 clip1 medium gain code */
+#define B43_NPHY_C1_CLIP1_LOGAIN		B43_PHY_N(0x023) /* Core 1 clip1 low gain code */
+#define B43_NPHY_C1_CLIP2_GAIN			B43_PHY_N(0x024) /* Core 1 clip2 gain code */
+#define B43_NPHY_C1_FILTERGAIN			B43_PHY_N(0x025) /* Core 1 filter gain */
+#define B43_NPHY_C1_LPF_QHPF_BW			B43_PHY_N(0x026) /* Core 1 LPF Q HP F bandwidth */
+#define B43_NPHY_C1_CLIPWBTHRES			B43_PHY_N(0x027) /* Core 1 clip wideband threshold */
+#define  B43_NPHY_C1_CLIPWBTHRES_CLIP2		0x003F /* Clip 2 */
+#define  B43_NPHY_C1_CLIPWBTHRES_CLIP2_SHIFT	0
+#define  B43_NPHY_C1_CLIPWBTHRES_CLIP1		0x0FC0 /* Clip 1 */
+#define  B43_NPHY_C1_CLIPWBTHRES_CLIP1_SHIFT	6
+#define B43_NPHY_C1_W1THRES			B43_PHY_N(0x028) /* Core 1 W1 threshold */
+#define B43_NPHY_C1_EDTHRES			B43_PHY_N(0x029) /* Core 1 ED threshold */
+#define B43_NPHY_C1_SMSIGTHRES			B43_PHY_N(0x02A) /* Core 1 small sig threshold */
+#define B43_NPHY_C1_NBCLIPTHRES			B43_PHY_N(0x02B) /* Core 1 NB clip threshold */
+#define B43_NPHY_C1_CLIP1THRES			B43_PHY_N(0x02C) /* Core 1 clip1 threshold */
+#define B43_NPHY_C1_CLIP2THRES			B43_PHY_N(0x02D) /* Core 1 clip2 threshold */
+
+#define B43_NPHY_C2_DESPWR			B43_PHY_N(0x018 + 22) /* Core 2 desired power */
+#define B43_NPHY_C2_CCK_DESPWR			B43_PHY_N(0x019 + 22) /* Core 2 CCK desired power */
+#define B43_NPHY_C2_BCLIPBKOFF			B43_PHY_N(0x01A + 22) /* Core 2 barely clip backoff */
+#define B43_NPHY_C2_CCK_BCLIPBKOFF		B43_PHY_N(0x01B + 22) /* Core 2 CCK barely clip backoff */
+#define B43_NPHY_C2_CGAINI			B43_PHY_N(0x01C + 22) /* Core 2 compute gain info */
+#define  B43_NPHY_C2_CGAINI_GAINBKOFF		0x001F /* Gain backoff */
+#define  B43_NPHY_C2_CGAINI_CLIPGBKOFF		0x03E0 /* Clip gain backoff */
+#define  B43_NPHY_C2_CGAINI_GAINSTEP		0x1C00 /* Gain step */
+#define  B43_NPHY_C2_CGAINI_CL2DETECT		0x2000 /* Clip 2 detect mask */
+#define B43_NPHY_C2_CCK_CGAINI			B43_PHY_N(0x01D + 22) /* Core 2 CCK compute gain info */
+#define  B43_NPHY_C2_CCK_CGAINI_GAINBKOFF	0x001F /* Gain backoff */
+#define  B43_NPHY_C2_CCK_CGAINI_CLIPGBKOFF	0x01E0 /* CCK barely clip gain backoff */
+#define B43_NPHY_C2_MINMAX_GAIN			B43_PHY_N(0x01E + 22) /* Core 2 min/max gain */
+#define  B43_NPHY_C2_MINGAIN			0x00FF /* Minimum gain */
+#define  B43_NPHY_C2_MINGAIN_SHIFT		0
+#define  B43_NPHY_C2_MAXGAIN			0xFF00 /* Maximum gain */
+#define  B43_NPHY_C2_MAXGAIN_SHIFT		8
+#define B43_NPHY_C2_CCK_MINMAX_GAIN		B43_PHY_N(0x01F + 22) /* Core 2 CCK min/max gain */
+#define  B43_NPHY_C2_CCK_MINGAIN		0x00FF /* Minimum gain */
+#define  B43_NPHY_C2_CCK_MINGAIN_SHIFT		0
+#define  B43_NPHY_C2_CCK_MAXGAIN		0xFF00 /* Maximum gain */
+#define  B43_NPHY_C2_CCK_MAXGAIN_SHIFT		8
+#define B43_NPHY_C2_INITGAIN			B43_PHY_N(0x020 + 22) /* Core 2 initial gain code */
+#define  B43_NPHY_C2_INITGAIN_EXTLNA		0x0001 /* External LNA index */
+#define  B43_NPHY_C2_INITGAIN_LNA		0x0006 /* LNA index */
+#define  B43_NPHY_C2_INITGAIN_LNAIDX_SHIFT	1
+#define  B43_NPHY_C2_INITGAIN_HPVGA1		0x0078 /* HPVGA1 index */
+#define  B43_NPHY_C2_INITGAIN_HPVGA1_SHIFT	3
+#define  B43_NPHY_C2_INITGAIN_HPVGA2		0x0F80 /* HPVGA2 index */
+#define  B43_NPHY_C2_INITGAIN_HPVGA2_SHIFT	7
+#define  B43_NPHY_C2_INITGAIN_TRRX		0x1000 /* TR RX index */
+#define  B43_NPHY_C2_INITGAIN_TRTX		0x2000 /* TR TX index */
+#define B43_NPHY_C2_CLIP1_HIGAIN		B43_PHY_N(0x021 + 22) /* Core 2 clip1 high gain code */
+#define B43_NPHY_C2_CLIP1_MEDGAIN		B43_PHY_N(0x022 + 22) /* Core 2 clip1 medium gain code */
+#define B43_NPHY_C2_CLIP1_LOGAIN		B43_PHY_N(0x023 + 22) /* Core 2 clip1 low gain code */
+#define B43_NPHY_C2_CLIP2_GAIN			B43_PHY_N(0x024 + 22) /* Core 2 clip2 gain code */
+#define B43_NPHY_C2_FILTERGAIN			B43_PHY_N(0x025 + 22) /* Core 2 filter gain */
+#define B43_NPHY_C2_LPF_QHPF_BW			B43_PHY_N(0x026 + 22) /* Core 2 LPF Q HP F bandwidth */
+#define B43_NPHY_C2_CLIPWBTHRES			B43_PHY_N(0x027 + 22) /* Core 2 clip wideband threshold */
+#define  B43_NPHY_C2_CLIPWBTHRES_CLIP2		0x003F /* Clip 2 */
+#define  B43_NPHY_C2_CLIPWBTHRES_CLIP2_SHIFT	0
+#define  B43_NPHY_C2_CLIPWBTHRES_CLIP1		0x0FC0 /* Clip 1 */
+#define  B43_NPHY_C2_CLIPWBTHRES_CLIP1_SHIFT	6
+#define B43_NPHY_C2_W1THRES			B43_PHY_N(0x028 + 22) /* Core 2 W1 threshold */
+#define B43_NPHY_C2_EDTHRES			B43_PHY_N(0x029 + 22) /* Core 2 ED threshold */
+#define B43_NPHY_C2_SMSIGTHRES			B43_PHY_N(0x02A + 22) /* Core 2 small sig threshold */
+#define B43_NPHY_C2_NBCLIPTHRES			B43_PHY_N(0x02B + 22) /* Core 2 NB clip threshold */
+#define B43_NPHY_C2_CLIP1THRES			B43_PHY_N(0x02C + 22) /* Core 2 clip1 threshold */
+#define B43_NPHY_C2_CLIP2THRES			B43_PHY_N(0x02D + 22) /* Core 2 clip2 threshold */
+
+#define B43_NPHY_CRS_THRES1			B43_PHY_N(0x044) /* CRS threshold 1 */
+#define B43_NPHY_CRS_THRES2			B43_PHY_N(0x045) /* CRS threshold 2 */
+#define B43_NPHY_CRS_THRES3			B43_PHY_N(0x046) /* CRS threshold 3 */
+#define B43_NPHY_CRSCTL				B43_PHY_N(0x047) /* CRS control */
+#define B43_NPHY_DCFADDR			B43_PHY_N(0x048) /* DC filter address */
+#define B43_NPHY_RXF20_NUM0			B43_PHY_N(0x049) /* RX filter 20 numerator 0 */
+#define B43_NPHY_RXF20_NUM1			B43_PHY_N(0x04A) /* RX filter 20 numerator 1 */
+#define B43_NPHY_RXF20_NUM2			B43_PHY_N(0x04B) /* RX filter 20 numerator 2 */
+#define B43_NPHY_RXF20_DENOM0			B43_PHY_N(0x04C) /* RX filter 20 denominator 0 */
+#define B43_NPHY_RXF20_DENOM1			B43_PHY_N(0x04D) /* RX filter 20 denominator 1 */
+#define B43_NPHY_RXF20_NUM10			B43_PHY_N(0x04E) /* RX filter 20 numerator 10 */
+#define B43_NPHY_RXF20_NUM11			B43_PHY_N(0x04F) /* RX filter 20 numerator 11 */
+#define B43_NPHY_RXF20_NUM12			B43_PHY_N(0x050) /* RX filter 20 numerator 12 */
+#define B43_NPHY_RXF20_DENOM10			B43_PHY_N(0x051) /* RX filter 20 denominator 10 */
+#define B43_NPHY_RXF20_DENOM11			B43_PHY_N(0x052) /* RX filter 20 denominator 11 */
+#define B43_NPHY_RXF40_NUM0			B43_PHY_N(0x053) /* RX filter 40 numerator 0 */
+#define B43_NPHY_RXF40_NUM1			B43_PHY_N(0x054) /* RX filter 40 numerator 1 */
+#define B43_NPHY_RXF40_NUM2			B43_PHY_N(0x055) /* RX filter 40 numerator 2 */
+#define B43_NPHY_RXF40_DENOM0			B43_PHY_N(0x056) /* RX filter 40 denominator 0 */
+#define B43_NPHY_RXF40_DENOM1			B43_PHY_N(0x057) /* RX filter 40 denominator 1 */
+#define B43_NPHY_RXF40_NUM10			B43_PHY_N(0x058) /* RX filter 40 numerator 10 */
+#define B43_NPHY_RXF40_NUM11			B43_PHY_N(0x059) /* RX filter 40 numerator 11 */
+#define B43_NPHY_RXF40_NUM12			B43_PHY_N(0x05A) /* RX filter 40 numerator 12 */
+#define B43_NPHY_RXF40_DENOM10			B43_PHY_N(0x05B) /* RX filter 40 denominator 10 */
+#define B43_NPHY_RXF40_DENOM11			B43_PHY_N(0x05C) /* RX filter 40 denominator 11 */
+#define B43_NPHY_PPROC_RSTLEN			B43_PHY_N(0x060) /* Packet processing reset length */
+#define B43_NPHY_INITCARR_DLEN			B43_PHY_N(0x061) /* Initial carrier detection length */
+#define B43_NPHY_CLIP1CARR_DLEN			B43_PHY_N(0x062) /* Clip1 carrier detection length */
+#define B43_NPHY_CLIP2CARR_DLEN			B43_PHY_N(0x063) /* Clip2 carrier detection length */
+#define B43_NPHY_INITGAIN_SLEN			B43_PHY_N(0x064) /* Initial gain settle length */
+#define B43_NPHY_CLIP1GAIN_SLEN			B43_PHY_N(0x065) /* Clip1 gain settle length */
+#define B43_NPHY_CLIP2GAIN_SLEN			B43_PHY_N(0x066) /* Clip2 gain settle length */
+#define B43_NPHY_PACKGAIN_SLEN			B43_PHY_N(0x067) /* Packet gain settle length */
+#define B43_NPHY_CARRSRC_TLEN			B43_PHY_N(0x068) /* Carrier search timeout length */
+#define B43_NPHY_TISRC_TLEN			B43_PHY_N(0x069) /* Timing search timeout length */
+#define B43_NPHY_ENDROP_TLEN			B43_PHY_N(0x06A) /* Energy drop timeout length */
+#define B43_NPHY_CLIP1_NBDWELL_LEN		B43_PHY_N(0x06B) /* Clip1 NB dwell length */
+#define B43_NPHY_CLIP2_NBDWELL_LEN		B43_PHY_N(0x06C) /* Clip2 NB dwell length */
+#define B43_NPHY_W1CLIP1_DWELL_LEN		B43_PHY_N(0x06D) /* W1 clip1 dwell length */
+#define B43_NPHY_W1CLIP2_DWELL_LEN		B43_PHY_N(0x06E) /* W1 clip2 dwell length */
+#define B43_NPHY_W2CLIP1_DWELL_LEN		B43_PHY_N(0x06F) /* W2 clip1 dwell length */
+#define B43_NPHY_PLOAD_CSENSE_EXTLEN		B43_PHY_N(0x070) /* Payload carrier sense extension length */
+#define B43_NPHY_EDROP_CSENSE_EXTLEN		B43_PHY_N(0x071) /* Energy drop carrier sense extension length */
+#define B43_NPHY_TABLE_ADDR			B43_PHY_N(0x072) /* Table address */
+#define B43_NPHY_TABLE_DATALO			B43_PHY_N(0x073) /* Table data low */
+#define B43_NPHY_TABLE_DATAHI			B43_PHY_N(0x074) /* Table data high */
+#define B43_NPHY_WWISE_LENIDX			B43_PHY_N(0x075) /* WWiSE length index */
+#define B43_NPHY_TGNSYNC_LENIDX			B43_PHY_N(0x076) /* TGNsync length index */
+#define B43_NPHY_TXMACIF_HOLDOFF		B43_PHY_N(0x077) /* TX MAC IF Hold off */
+#define B43_NPHY_RFCTL_CMD			B43_PHY_N(0x078) /* RF control (command) */
+#define  B43_NPHY_RFCTL_CMD_START		0x0001 /* Start sequence */
+#define  B43_NPHY_RFCTL_CMD_RXTX		0x0002 /* RX/TX */
+#define  B43_NPHY_RFCTL_CMD_CORESEL		0x0038 /* Core select */
+#define  B43_NPHY_RFCTL_CMD_CORESEL_SHIFT	3
+#define  B43_NPHY_RFCTL_CMD_PORFORCE		0x0040 /* POR force */
+#define  B43_NPHY_RFCTL_CMD_OEPORFORCE		0x0080 /* OE POR force */
+#define  B43_NPHY_RFCTL_CMD_RXEN		0x0100 /* RX enable */
+#define  B43_NPHY_RFCTL_CMD_TXEN		0x0200 /* TX enable */
+#define  B43_NPHY_RFCTL_CMD_CHIP0PU		0x0400 /* Chip0 PU */
+#define  B43_NPHY_RFCTL_CMD_SEQENCORE		0xF000 /* Seq en core */
+#define  B43_NPHY_RFCTL_CMD_SEQENCORE_SHIFT	12
+#define B43_NPHY_RFCTL_RSSIO1			B43_PHY_N(0x07A) /* RF control (RSSI others 1) */
+#define  B43_NPHY_RFCTL_RSSIO1_RXPD		0x0001 /* RX PD */
+#define  B43_NPHY_RFCTL_RSSIO1_TXPD		0x0002 /* TX PD */
+#define  B43_NPHY_RFCTL_RSSIO1_PAPD		0x0004 /* PA PD */
+#define  B43_NPHY_RFCTL_RSSIO1_RSSICTL		0x0030 /* RSSI control */
+#define  B43_NPHY_RFCTL_RSSIO1_LPFBW		0x00C0 /* LPF bandwidth */
+#define  B43_NPHY_RFCTL_RSSIO1_HPFBWHI		0x0100 /* HPF bandwidth high */
+#define  B43_NPHY_RFCTL_RSSIO1_HIQDISCO		0x0200 /* HIQ dis core */
+#define B43_NPHY_RFCTL_RXG1			B43_PHY_N(0x07B) /* RF control (RX gain 1) */
+#define B43_NPHY_RFCTL_TXG1			B43_PHY_N(0x07C) /* RF control (TX gain 1) */
+#define B43_NPHY_RFCTL_RSSIO2			B43_PHY_N(0x07D) /* RF control (RSSI others 2) */
+#define  B43_NPHY_RFCTL_RSSIO2_RXPD		0x0001 /* RX PD */
+#define  B43_NPHY_RFCTL_RSSIO2_TXPD		0x0002 /* TX PD */
+#define  B43_NPHY_RFCTL_RSSIO2_PAPD		0x0004 /* PA PD */
+#define  B43_NPHY_RFCTL_RSSIO2_RSSICTL		0x0030 /* RSSI control */
+#define  B43_NPHY_RFCTL_RSSIO2_LPFBW		0x00C0 /* LPF bandwidth */
+#define  B43_NPHY_RFCTL_RSSIO2_HPFBWHI		0x0100 /* HPF bandwidth high */
+#define  B43_NPHY_RFCTL_RSSIO2_HIQDISCO		0x0200 /* HIQ dis core */
+#define B43_NPHY_RFCTL_RXG2			B43_PHY_N(0x07E) /* RF control (RX gain 2) */
+#define B43_NPHY_RFCTL_TXG2			B43_PHY_N(0x07F) /* RF control (TX gain 2) */
+#define B43_NPHY_RFCTL_RSSIO3			B43_PHY_N(0x080) /* RF control (RSSI others 3) */
+#define  B43_NPHY_RFCTL_RSSIO3_RXPD		0x0001 /* RX PD */
+#define  B43_NPHY_RFCTL_RSSIO3_TXPD		0x0002 /* TX PD */
+#define  B43_NPHY_RFCTL_RSSIO3_PAPD		0x0004 /* PA PD */
+#define  B43_NPHY_RFCTL_RSSIO3_RSSICTL		0x0030 /* RSSI control */
+#define  B43_NPHY_RFCTL_RSSIO3_LPFBW		0x00C0 /* LPF bandwidth */
+#define  B43_NPHY_RFCTL_RSSIO3_HPFBWHI		0x0100 /* HPF bandwidth high */
+#define  B43_NPHY_RFCTL_RSSIO3_HIQDISCO		0x0200 /* HIQ dis core */
+#define B43_NPHY_RFCTL_RXG3			B43_PHY_N(0x081) /* RF control (RX gain 3) */
+#define B43_NPHY_RFCTL_TXG3			B43_PHY_N(0x082) /* RF control (TX gain 3) */
+#define B43_NPHY_RFCTL_RSSIO4			B43_PHY_N(0x083) /* RF control (RSSI others 4) */
+#define  B43_NPHY_RFCTL_RSSIO4_RXPD		0x0001 /* RX PD */
+#define  B43_NPHY_RFCTL_RSSIO4_TXPD		0x0002 /* TX PD */
+#define  B43_NPHY_RFCTL_RSSIO4_PAPD		0x0004 /* PA PD */
+#define  B43_NPHY_RFCTL_RSSIO4_RSSICTL		0x0030 /* RSSI control */
+#define  B43_NPHY_RFCTL_RSSIO4_LPFBW		0x00C0 /* LPF bandwidth */
+#define  B43_NPHY_RFCTL_RSSIO4_HPFBWHI		0x0100 /* HPF bandwidth high */
+#define  B43_NPHY_RFCTL_RSSIO4_HIQDISCO		0x0200 /* HIQ dis core */
+#define B43_NPHY_RFCTL_RXG4			B43_PHY_N(0x084) /* RF control (RX gain 4) */
+#define B43_NPHY_RFCTL_TXG4			B43_PHY_N(0x085) /* RF control (TX gain 4) */
+#define B43_NPHY_C1_TXIQ_COMP_OFF		B43_PHY_N(0x087) /* Core 1 TX I/Q comp offset */
+#define B43_NPHY_C2_TXIQ_COMP_OFF		B43_PHY_N(0x088) /* Core 2 TX I/Q comp offset */
+#define B43_NPHY_C1_TXCTL			B43_PHY_N(0x08B) /* Core 1 TX control */
+#define B43_NPHY_C2_TXCTL			B43_PHY_N(0x08C) /* Core 2 TX control */
+#define B43_NPHY_SCRAM_SIGCTL			B43_PHY_N(0x090) /* Scran signal control */
+#define  B43_NPHY_SCRAM_SIGCTL_INITST		0x007F /* Initial state value */
+#define  B43_NPHY_SCRAM_SIGCTL_INITST_SHIFT	0
+#define  B43_NPHY_SCRAM_SIGCTL_SCM		0x0080 /* Scram control mode */
+#define  B43_NPHY_SCRAM_SIGCTL_SICE		0x0100 /* Scram index control enable */
+#define  B43_NPHY_SCRAM_SIGCTL_START		0xFE00 /* Scram start bit */
+#define  B43_NPHY_SCRAM_SIGCTL_START_SHIFT	9
+#define B43_NPHY_RFCTL_INTC1			B43_PHY_N(0x091) /* RF control (intc 1) */
+#define B43_NPHY_RFCTL_INTC2			B43_PHY_N(0x092) /* RF control (intc 2) */
+#define B43_NPHY_RFCTL_INTC3			B43_PHY_N(0x093) /* RF control (intc 3) */
+#define B43_NPHY_RFCTL_INTC4			B43_PHY_N(0x094) /* RF control (intc 4) */
+#define B43_NPHY_NRDTO_WWISE			B43_PHY_N(0x095) /* # datatones WWiSE */
+#define B43_NPHY_NRDTO_TGNSYNC			B43_PHY_N(0x096) /* # datatones TGNsync */
+#define B43_NPHY_SIGFMOD_WWISE			B43_PHY_N(0x097) /* Signal field mod WWiSE */
+#define B43_NPHY_LEG_SIGFMOD_11N		B43_PHY_N(0x098) /* Legacy signal field mod 11n */
+#define B43_NPHY_HT_SIGFMOD_11N			B43_PHY_N(0x099) /* HT signal field mod 11n */
+#define B43_NPHY_C1_RXIQ_COMPA0			B43_PHY_N(0x09A) /* Core 1 RX I/Q comp A0 */
+#define B43_NPHY_C1_RXIQ_COMPB0			B43_PHY_N(0x09B) /* Core 1 RX I/Q comp B0 */
+#define B43_NPHY_C2_RXIQ_COMPA1			B43_PHY_N(0x09C) /* Core 2 RX I/Q comp A1 */
+#define B43_NPHY_C2_RXIQ_COMPB1			B43_PHY_N(0x09D) /* Core 2 RX I/Q comp B1 */
+#define B43_NPHY_RXCTL				B43_PHY_N(0x0A0) /* RX control */
+#define  B43_NPHY_RXCTL_BSELU20			0x0010 /* Band select upper 20 */
+#define  B43_NPHY_RXCTL_RIFSEN			0x0080 /* RIFS enable */
+#define B43_NPHY_RFSEQMODE			B43_PHY_N(0x0A1) /* RF seq mode */
+#define  B43_NPHY_RFSEQMODE_CAOVER		0x0001 /* Core active override */
+#define  B43_NPHY_RFSEQMODE_TROVER		0x0002 /* Trigger override */
+#define B43_NPHY_RFSEQCA			B43_PHY_N(0x0A2) /* RF seq core active */
+#define  B43_NPHY_RFSEQCA_TXEN			0x000F /* TX enable */
+#define  B43_NPHY_RFSEQCA_TXEN_SHIFT		0
+#define  B43_NPHY_RFSEQCA_RXEN			0x00F0 /* RX enable */
+#define  B43_NPHY_RFSEQCA_RXEN_SHIFT		4
+#define  B43_NPHY_RFSEQCA_TXDIS			0x0F00 /* TX disable */
+#define  B43_NPHY_RFSEQCA_TXDIS_SHIFT		8
+#define  B43_NPHY_RFSEQCA_RXDIS			0xF000 /* RX disable */
+#define  B43_NPHY_RFSEQCA_RXDIS_SHIFT		12
+#define B43_NPHY_RFSEQTR			B43_PHY_N(0x0A3) /* RF seq trigger */
+#define  B43_NPHY_RFSEQTR_RX2TX			0x0001 /* RX2TX */
+#define  B43_NPHY_RFSEQTR_TX2RX			0x0002 /* TX2RX */
+#define  B43_NPHY_RFSEQTR_UPGH			0x0004 /* Update gain H */
+#define  B43_NPHY_RFSEQTR_UPGL			0x0008 /* Update gain L */
+#define  B43_NPHY_RFSEQTR_UPGU			0x0010 /* Update gain U */
+#define  B43_NPHY_RFSEQTR_RST2RX		0x0020 /* Reset to RX */
+#define B43_NPHY_RFSEQST			B43_PHY_N(0x0A4) /* RF seq status. Values same as trigger. */
+#define B43_NPHY_AFECTL_OVER			B43_PHY_N(0x0A5) /* AFE control override */
+#define B43_NPHY_AFECTL_C1			B43_PHY_N(0x0A6) /* AFE control core 1 */
+#define B43_NPHY_AFECTL_C2			B43_PHY_N(0x0A7) /* AFE control core 2 */
+#define B43_NPHY_AFECTL_C3			B43_PHY_N(0x0A8) /* AFE control core 3 */
+#define B43_NPHY_AFECTL_C4			B43_PHY_N(0x0A9) /* AFE control core 4 */
+#define B43_NPHY_AFECTL_DACGAIN1		B43_PHY_N(0x0AA) /* AFE control DAC gain 1 */
+#define B43_NPHY_AFECTL_DACGAIN2		B43_PHY_N(0x0AB) /* AFE control DAC gain 2 */
+#define B43_NPHY_AFECTL_DACGAIN3		B43_PHY_N(0x0AC) /* AFE control DAC gain 3 */
+#define B43_NPHY_AFECTL_DACGAIN4		B43_PHY_N(0x0AD) /* AFE control DAC gain 4 */
+#define B43_NPHY_STR_ADDR1			B43_PHY_N(0x0AE) /* STR address 1 */
+#define B43_NPHY_STR_ADDR2			B43_PHY_N(0x0AF) /* STR address 2 */
+#define B43_NPHY_CLASSCTL			B43_PHY_N(0x0B0) /* Classifier control */
+#define  B43_NPHY_CLASSCTL_CCKEN		0x0001 /* CCK enable */
+#define  B43_NPHY_CLASSCTL_OFDMEN		0x0002 /* OFDM enable */
+#define  B43_NPHY_CLASSCTL_WAITEDEN		0x0004 /* Waited enable */
+#define B43_NPHY_IQFLIP				B43_PHY_N(0x0B1) /* I/Q flip */
+#define  B43_NPHY_IQFLIP_ADC1			0x0001 /* ADC1 */
+#define  B43_NPHY_IQFLIP_ADC2			0x0010 /* ADC2 */
+#define B43_NPHY_SISO_SNR_THRES			B43_PHY_N(0x0B2) /* SISO SNR threshold */
+#define B43_NPHY_SIGMA_N_MULT			B43_PHY_N(0x0B3) /* Sigma N multiplier */
+#define B43_NPHY_TXMACDELAY			B43_PHY_N(0x0B4) /* TX MAC delay */
+#define B43_NPHY_TXFRAMEDELAY			B43_PHY_N(0x0B5) /* TX frame delay */
+#define B43_NPHY_MLPARM				B43_PHY_N(0x0B6) /* ML parameters */
+#define B43_NPHY_MLCTL				B43_PHY_N(0x0B7) /* ML control */
+#define B43_NPHY_WWISE_20NCYCDAT		B43_PHY_N(0x0B8) /* WWiSE 20 N cyc data */
+#define B43_NPHY_WWISE_40NCYCDAT		B43_PHY_N(0x0B9) /* WWiSE 40 N cyc data */
+#define B43_NPHY_TGNSYNC_20NCYCDAT		B43_PHY_N(0x0BA) /* TGNsync 20 N cyc data */
+#define B43_NPHY_TGNSYNC_40NCYCDAT		B43_PHY_N(0x0BB) /* TGNsync 40 N cyc data */
+#define B43_NPHY_INITSWIZP			B43_PHY_N(0x0BC) /* Initial swizzle pattern */
+#define B43_NPHY_TXTAILCNT			B43_PHY_N(0x0BD) /* TX tail count value */
+#define B43_NPHY_BPHY_CTL1			B43_PHY_N(0x0BE) /* B PHY control 1 */
+#define B43_NPHY_BPHY_CTL2			B43_PHY_N(0x0BF) /* B PHY control 2 */
+#define  B43_NPHY_BPHY_CTL2_LUT			0x001F /* LUT index */
+#define  B43_NPHY_BPHY_CTL2_LUT_SHIFT		0
+#define  B43_NPHY_BPHY_CTL2_MACDEL		0x7FE0 /* MAC delay */
+#define  B43_NPHY_BPHY_CTL2_MACDEL_SHIFT	5
+#define B43_NPHY_IQLOCAL_CMD			B43_PHY_N(0x0C0) /* I/Q LO cal command */
+#define  B43_NPHY_IQLOCAL_CMD_EN		0x8000
+#define B43_NPHY_IQLOCAL_CMDNNUM		B43_PHY_N(0x0C1) /* I/Q LO cal command N num */
+#define B43_NPHY_IQLOCAL_CMDGCTL		B43_PHY_N(0x0C2) /* I/Q LO cal command G control */
+#define B43_NPHY_SAMP_CMD			B43_PHY_N(0x0C3) /* Sample command */
+#define  B43_NPHY_SAMP_CMD_STOP			0x0002 /* Stop */
+#define B43_NPHY_SAMP_LOOPCNT			B43_PHY_N(0x0C4) /* Sample loop count */
+#define B43_NPHY_SAMP_WAITCNT			B43_PHY_N(0x0C5) /* Sample wait count */
+#define B43_NPHY_SAMP_DEPCNT			B43_PHY_N(0x0C6) /* Sample depth count */
+#define B43_NPHY_SAMP_STAT			B43_PHY_N(0x0C7) /* Sample status */
+#define B43_NPHY_GPIO_LOOEN			B43_PHY_N(0x0C8) /* GPIO low out enable */
+#define B43_NPHY_GPIO_HIOEN			B43_PHY_N(0x0C9) /* GPIO high out enable */
+#define B43_NPHY_GPIO_SEL			B43_PHY_N(0x0CA) /* GPIO select */
+#define B43_NPHY_GPIO_CLKCTL			B43_PHY_N(0x0CB) /* GPIO clock control */
+#define B43_NPHY_TXF_20CO_AS0			B43_PHY_N(0x0CC) /* TX filter 20 coeff A stage 0 */
+#define B43_NPHY_TXF_20CO_AS1			B43_PHY_N(0x0CD) /* TX filter 20 coeff A stage 1 */
+#define B43_NPHY_TXF_20CO_AS2			B43_PHY_N(0x0CE) /* TX filter 20 coeff A stage 2 */
+#define B43_NPHY_TXF_20CO_B32S0			B43_PHY_N(0x0CF) /* TX filter 20 coeff B32 stage 0 */
+#define B43_NPHY_TXF_20CO_B1S0			B43_PHY_N(0x0D0) /* TX filter 20 coeff B1 stage 0 */
+#define B43_NPHY_TXF_20CO_B32S1			B43_PHY_N(0x0D1) /* TX filter 20 coeff B32 stage 1 */
+#define B43_NPHY_TXF_20CO_B1S1			B43_PHY_N(0x0D2) /* TX filter 20 coeff B1 stage 1 */
+#define B43_NPHY_TXF_20CO_B32S2			B43_PHY_N(0x0D3) /* TX filter 20 coeff B32 stage 2 */
+#define B43_NPHY_TXF_20CO_B1S2			B43_PHY_N(0x0D4) /* TX filter 20 coeff B1 stage 2 */
+#define B43_NPHY_SIGFLDTOL			B43_PHY_N(0x0D5) /* Signal fld tolerance */
+#define B43_NPHY_TXSERFLD			B43_PHY_N(0x0D6) /* TX service field */
+#define B43_NPHY_AFESEQ_RX2TX_PUD		B43_PHY_N(0x0D7) /* AFE seq RX2TX power up/down delay */
+#define B43_NPHY_AFESEQ_TX2RX_PUD		B43_PHY_N(0x0D8) /* AFE seq TX2RX power up/down delay */
+#define B43_NPHY_TGNSYNC_SCRAMI0		B43_PHY_N(0x0D9) /* TGNsync scram init 0 */
+#define B43_NPHY_TGNSYNC_SCRAMI1		B43_PHY_N(0x0DA) /* TGNsync scram init 1 */
+#define B43_NPHY_INITSWIZPATTLEG		B43_PHY_N(0x0DB) /* Initial swizzle pattern leg */
+#define B43_NPHY_BPHY_CTL3			B43_PHY_N(0x0DC) /* B PHY control 3 */
+#define  B43_NPHY_BPHY_CTL3_SCALE		0x00FF /* Scale */
+#define  B43_NPHY_BPHY_CTL3_SCALE_SHIFT		0
+#define  B43_NPHY_BPHY_CTL3_FSC			0xFF00 /* Frame start count value */
+#define  B43_NPHY_BPHY_CTL3_FSC_SHIFT		8
+#define B43_NPHY_BPHY_CTL4			B43_PHY_N(0x0DD) /* B PHY control 4 */
+#define B43_NPHY_C1_TXBBMULT			B43_PHY_N(0x0DE) /* Core 1 TX BB multiplier */
+#define B43_NPHY_C2_TXBBMULT			B43_PHY_N(0x0DF) /* Core 2 TX BB multiplier */
+#define B43_NPHY_TXF_40CO_AS0			B43_PHY_N(0x0E1) /* TX filter 40 coeff A stage 0 */
+#define B43_NPHY_TXF_40CO_AS1			B43_PHY_N(0x0E2) /* TX filter 40 coeff A stage 1 */
+#define B43_NPHY_TXF_40CO_AS2			B43_PHY_N(0x0E3) /* TX filter 40 coeff A stage 2 */
+#define B43_NPHY_TXF_40CO_B32S0			B43_PHY_N(0x0E4) /* TX filter 40 coeff B32 stage 0 */
+#define B43_NPHY_TXF_40CO_B1S0			B43_PHY_N(0x0E5) /* TX filter 40 coeff B1 stage 0 */
+#define B43_NPHY_TXF_40CO_B32S1			B43_PHY_N(0x0E6) /* TX filter 40 coeff B32 stage 1 */
+#define B43_NPHY_TXF_40CO_B1S1			B43_PHY_N(0x0E7) /* TX filter 40 coeff B1 stage 1 */
+#define B43_NPHY_TXF_40CO_B32S2			B43_PHY_N(0x0E8) /* TX filter 40 coeff B32 stage 2 */
+#define B43_NPHY_TXF_40CO_B1S2			B43_PHY_N(0x0E9) /* TX filter 40 coeff B1 stage 2 */
+#define B43_NPHY_BIST_STAT2			B43_PHY_N(0x0EA) /* BIST status 2 */
+#define B43_NPHY_BIST_STAT3			B43_PHY_N(0x0EB) /* BIST status 3 */
+#define B43_NPHY_RFCTL_OVER			B43_PHY_N(0x0EC) /* RF control override */
+#define B43_NPHY_MIMOCFG			B43_PHY_N(0x0ED) /* MIMO config */
+#define  B43_NPHY_MIMOCFG_GFMIX			0x0004 /* Greenfield or mixed mode */
+#define  B43_NPHY_MIMOCFG_AUTO			0x0100 /* Greenfield/mixed mode auto */
+#define B43_NPHY_RADAR_BLNKCTL			B43_PHY_N(0x0EE) /* Radar blank control */
+#define B43_NPHY_A0RADAR_FIFOCTL		B43_PHY_N(0x0EF) /* Antenna 0 radar FIFO control */
+#define B43_NPHY_A1RADAR_FIFOCTL		B43_PHY_N(0x0F0) /* Antenna 1 radar FIFO control */
+#define B43_NPHY_A0RADAR_FIFODAT		B43_PHY_N(0x0F1) /* Antenna 0 radar FIFO data */
+#define B43_NPHY_A1RADAR_FIFODAT		B43_PHY_N(0x0F2) /* Antenna 1 radar FIFO data */
+#define B43_NPHY_RADAR_THRES0			B43_PHY_N(0x0F3) /* Radar threshold 0 */
+#define B43_NPHY_RADAR_THRES1			B43_PHY_N(0x0F4) /* Radar threshold 1 */
+#define B43_NPHY_RADAR_THRES0R			B43_PHY_N(0x0F5) /* Radar threshold 0R */
+#define B43_NPHY_RADAR_THRES1R			B43_PHY_N(0x0F6) /* Radar threshold 1R */
+#define B43_NPHY_CSEN_20IN40_DLEN		B43_PHY_N(0x0F7) /* Carrier sense 20 in 40 dwell length */
+#define B43_NPHY_RFCTL_LUT_TRSW_LO1		B43_PHY_N(0x0F8) /* RF control LUT TRSW lower 1 */
+#define B43_NPHY_RFCTL_LUT_TRSW_UP1		B43_PHY_N(0x0F9) /* RF control LUT TRSW upper 1 */
+#define B43_NPHY_RFCTL_LUT_TRSW_LO2		B43_PHY_N(0x0FA) /* RF control LUT TRSW lower 2 */
+#define B43_NPHY_RFCTL_LUT_TRSW_UP2		B43_PHY_N(0x0FB) /* RF control LUT TRSW upper 2 */
+#define B43_NPHY_RFCTL_LUT_TRSW_LO3		B43_PHY_N(0x0FC) /* RF control LUT TRSW lower 3 */
+#define B43_NPHY_RFCTL_LUT_TRSW_UP3		B43_PHY_N(0x0FD) /* RF control LUT TRSW upper 3 */
+#define B43_NPHY_RFCTL_LUT_TRSW_LO4		B43_PHY_N(0x0FE) /* RF control LUT TRSW lower 4 */
+#define B43_NPHY_RFCTL_LUT_TRSW_UP4		B43_PHY_N(0x0FF) /* RF control LUT TRSW upper 4 */
+#define B43_NPHY_RFCTL_LUT_LNAPA1		B43_PHY_N(0x100) /* RF control LUT LNA PA 1 */
+#define B43_NPHY_RFCTL_LUT_LNAPA2		B43_PHY_N(0x101) /* RF control LUT LNA PA 2 */
+#define B43_NPHY_RFCTL_LUT_LNAPA3		B43_PHY_N(0x102) /* RF control LUT LNA PA 3 */
+#define B43_NPHY_RFCTL_LUT_LNAPA4		B43_PHY_N(0x103) /* RF control LUT LNA PA 4 */
+#define B43_NPHY_TGNSYNC_CRCM0			B43_PHY_N(0x104) /* TGNsync CRC mask 0 */
+#define B43_NPHY_TGNSYNC_CRCM1			B43_PHY_N(0x105) /* TGNsync CRC mask 1 */
+#define B43_NPHY_TGNSYNC_CRCM2			B43_PHY_N(0x106) /* TGNsync CRC mask 2 */
+#define B43_NPHY_TGNSYNC_CRCM3			B43_PHY_N(0x107) /* TGNsync CRC mask 3 */
+#define B43_NPHY_TGNSYNC_CRCM4			B43_PHY_N(0x108) /* TGNsync CRC mask 4 */
+#define B43_NPHY_CRCPOLY			B43_PHY_N(0x109) /* CRC polynomial */
+#define B43_NPHY_SIGCNT				B43_PHY_N(0x10A) /* # sig count */
+#define B43_NPHY_SIGSTARTBIT_CTL		B43_PHY_N(0x10B) /* Sig start bit control */
+#define B43_NPHY_CRCPOLY_ORDER			B43_PHY_N(0x10C) /* CRC polynomial order */
+#define B43_NPHY_RFCTL_CST0			B43_PHY_N(0x10D) /* RF control core swap table 0 */
+#define B43_NPHY_RFCTL_CST1			B43_PHY_N(0x10E) /* RF control core swap table 1 */
+#define B43_NPHY_RFCTL_CST2O			B43_PHY_N(0x10F) /* RF control core swap table 2 + others */
+#define B43_NPHY_BPHY_CTL5			B43_PHY_N(0x111) /* B PHY control 5 */
+#define B43_NPHY_RFSEQ_LPFBW			B43_PHY_N(0x112) /* RF seq LPF bandwidth */
+#define B43_NPHY_TSSIBIAS1			B43_PHY_N(0x114) /* TSSI bias val 1 */
+#define B43_NPHY_TSSIBIAS2			B43_PHY_N(0x115) /* TSSI bias val 2 */
+#define  B43_NPHY_TSSIBIAS_BIAS			0x00FF /* Bias */
+#define  B43_NPHY_TSSIBIAS_BIAS_SHIFT		0
+#define  B43_NPHY_TSSIBIAS_VAL			0xFF00 /* Value */
+#define  B43_NPHY_TSSIBIAS_VAL_SHIFT		8
+#define B43_NPHY_ESTPWR1			B43_PHY_N(0x118) /* Estimated power 1 */
+#define B43_NPHY_ESTPWR2			B43_PHY_N(0x119) /* Estimated power 2 */
+#define  B43_NPHY_ESTPWR_PWR			0x00FF /* Estimated power */
+#define  B43_NPHY_ESTPWR_PWR_SHIFT		0
+#define  B43_NPHY_ESTPWR_VALID			0x0100 /* Estimated power valid */
+#define B43_NPHY_TSSI_MAXTXFDT			B43_PHY_N(0x11C) /* TSSI max TX frame delay time */
+#define  B43_NPHY_TSSI_MAXTXFDT_VAL		0x00FF /* max TX frame delay time */
+#define  B43_NPHY_TSSI_MAXTXFDT_VAL_SHIFT	0
+#define B43_NPHY_TSSI_MAXTDT			B43_PHY_N(0x11D) /* TSSI max TSSI delay time */
+#define  B43_NPHY_TSSI_MAXTDT_VAL		0x00FF /* max TSSI delay time */
+#define  B43_NPHY_TSSI_MAXTDT_VAL_SHIFT		0
+#define B43_NPHY_ITSSI1				B43_PHY_N(0x11E) /* TSSI idle 1 */
+#define B43_NPHY_ITSSI2				B43_PHY_N(0x11F) /* TSSI idle 2 */
+#define  B43_NPHY_ITSSI_VAL			0x00FF /* Idle TSSI */
+#define  B43_NPHY_ITSSI_VAL_SHIFT		0
+#define B43_NPHY_TSSIMODE			B43_PHY_N(0x122) /* TSSI mode */
+#define  B43_NPHY_TSSIMODE_EN			0x0001 /* TSSI enable */
+#define  B43_NPHY_TSSIMODE_PDEN			0x0002 /* Power det enable */
+#define B43_NPHY_RXMACIFM			B43_PHY_N(0x123) /* RX Macif mode */
+#define B43_NPHY_CRSIT_COCNT_LO			B43_PHY_N(0x124) /* CRS idle time CRS-on count (low) */
+#define B43_NPHY_CRSIT_COCNT_HI			B43_PHY_N(0x125) /* CRS idle time CRS-on count (high) */
+#define B43_NPHY_CRSIT_MTCNT_LO			B43_PHY_N(0x126) /* CRS idle time measure time count (low) */
+#define B43_NPHY_CRSIT_MTCNT_HI			B43_PHY_N(0x127) /* CRS idle time measure time count (high) */
+#define B43_NPHY_SAMTWC				B43_PHY_N(0x128) /* Sample tail wait count */
+#define B43_NPHY_IQEST_CMD			B43_PHY_N(0x129) /* I/Q estimate command */
+#define  B43_NPHY_IQEST_CMD_START		0x0001 /* Start */
+#define  B43_NPHY_IQEST_CMD_MODE		0x0002 /* Mode */
+#define B43_NPHY_IQEST_WT			B43_PHY_N(0x12A) /* I/Q estimate wait time */
+#define  B43_NPHY_IQEST_WT_VAL			0x00FF /* Wait time */
+#define  B43_NPHY_IQEST_WT_VAL_SHIFT		0
+#define B43_NPHY_IQEST_SAMCNT			B43_PHY_N(0x12B) /* I/Q estimate sample count */
+#define B43_NPHY_IQEST_IQACC_LO0		B43_PHY_N(0x12C) /* I/Q estimate I/Q acc lo 0 */
+#define B43_NPHY_IQEST_IQACC_HI0		B43_PHY_N(0x12D) /* I/Q estimate I/Q acc hi 0 */
+#define B43_NPHY_IQEST_IPACC_LO0		B43_PHY_N(0x12E) /* I/Q estimate I power acc lo 0 */
+#define B43_NPHY_IQEST_IPACC_HI0		B43_PHY_N(0x12F) /* I/Q estimate I power acc hi 0 */
+#define B43_NPHY_IQEST_QPACC_LO0		B43_PHY_N(0x130) /* I/Q estimate Q power acc lo 0 */
+#define B43_NPHY_IQEST_QPACC_HI0		B43_PHY_N(0x131) /* I/Q estimate Q power acc hi 0 */
+#define B43_NPHY_IQEST_IQACC_LO1		B43_PHY_N(0x134) /* I/Q estimate I/Q acc lo 1 */
+#define B43_NPHY_IQEST_IQACC_HI1		B43_PHY_N(0x135) /* I/Q estimate I/Q acc hi 1 */
+#define B43_NPHY_IQEST_IPACC_LO1		B43_PHY_N(0x136) /* I/Q estimate I power acc lo 1 */
+#define B43_NPHY_IQEST_IPACC_HI1		B43_PHY_N(0x137) /* I/Q estimate I power acc hi 1 */
+#define B43_NPHY_IQEST_QPACC_LO1		B43_PHY_N(0x138) /* I/Q estimate Q power acc lo 1 */
+#define B43_NPHY_IQEST_QPACC_HI1		B43_PHY_N(0x139) /* I/Q estimate Q power acc hi 1 */
+#define B43_NPHY_MIMO_CRSTXEXT			B43_PHY_N(0x13A) /* MIMO PHY CRS TX extension */
+#define B43_NPHY_PWRDET1			B43_PHY_N(0x13B) /* Power det 1 */
+#define B43_NPHY_PWRDET2			B43_PHY_N(0x13C) /* Power det 2 */
+#define B43_NPHY_MAXRSSI_DTIME			B43_PHY_N(0x13F) /* RSSI max RSSI delay time */
+#define B43_NPHY_PIL_DW0			B43_PHY_N(0x141) /* Pilot data weight 0 */
+#define B43_NPHY_PIL_DW1			B43_PHY_N(0x142) /* Pilot data weight 1 */
+#define B43_NPHY_PIL_DW2			B43_PHY_N(0x143) /* Pilot data weight 2 */
+#define  B43_NPHY_PIL_DW_BPSK			0x000F /* BPSK */
+#define  B43_NPHY_PIL_DW_BPSK_SHIFT		0
+#define  B43_NPHY_PIL_DW_QPSK			0x00F0 /* QPSK */
+#define  B43_NPHY_PIL_DW_QPSK_SHIFT		4
+#define  B43_NPHY_PIL_DW_16QAM			0x0F00 /* 16-QAM */
+#define  B43_NPHY_PIL_DW_16QAM_SHIFT		8
+#define  B43_NPHY_PIL_DW_64QAM			0xF000 /* 64-QAM */
+#define  B43_NPHY_PIL_DW_64QAM_SHIFT		12
+#define B43_NPHY_FMDEM_CFG			B43_PHY_N(0x144) /* FM demodulation config */
+#define B43_NPHY_PHASETR_A0			B43_PHY_N(0x145) /* Phase track alpha 0 */
+#define B43_NPHY_PHASETR_A1			B43_PHY_N(0x146) /* Phase track alpha 1 */
+#define B43_NPHY_PHASETR_A2			B43_PHY_N(0x147) /* Phase track alpha 2 */
+#define B43_NPHY_PHASETR_B0			B43_PHY_N(0x148) /* Phase track beta 0 */
+#define B43_NPHY_PHASETR_B1			B43_PHY_N(0x149) /* Phase track beta 1 */
+#define B43_NPHY_PHASETR_B2			B43_PHY_N(0x14A) /* Phase track beta 2 */
+#define B43_NPHY_PHASETR_CHG0			B43_PHY_N(0x14B) /* Phase track change 0 */
+#define B43_NPHY_PHASETR_CHG1			B43_PHY_N(0x14C) /* Phase track change 1 */
+#define B43_NPHY_PHASETW_OFF			B43_PHY_N(0x14D) /* Phase track offset */
+#define B43_NPHY_RFCTL_DBG			B43_PHY_N(0x14E) /* RF control debug */
+#define B43_NPHY_CCK_SHIFTB_REF			B43_PHY_N(0x150) /* CCK shiftbits reference var */
+#define B43_NPHY_OVER_DGAIN0			B43_PHY_N(0x152) /* Override digital gain 0 */
+#define B43_NPHY_OVER_DGAIN1			B43_PHY_N(0x153) /* Override digital gain 1 */
+#define  B43_NPHY_OVER_DGAIN_FDGV		0x0007 /* Force digital gain value */
+#define  B43_NPHY_OVER_DGAIN_FDGV_SHIFT		0
+#define  B43_NPHY_OVER_DGAIN_FDGEN		0x0008 /* Force digital gain enable */
+#define  B43_NPHY_OVER_DGAIN_CCKDGECV		0xFF00 /* CCK digital gain enable count value */
+#define  B43_NPHY_OVER_DGAIN_CCKDGECV_SHIFT	8
+#define B43_NPHY_BIST_STAT4			B43_PHY_N(0x156) /* BIST status 4 */
+#define B43_NPHY_RADAR_MAL			B43_PHY_N(0x157) /* Radar MA length */
+#define B43_NPHY_RADAR_SRCCTL			B43_PHY_N(0x158) /* Radar search control */
+#define B43_NPHY_VLD_DTSIG			B43_PHY_N(0x159) /* VLD data tones sig */
+#define B43_NPHY_VLD_DTDAT			B43_PHY_N(0x15A) /* VLD data tones data */
+#define B43_NPHY_C1_BPHY_RXIQCA0		B43_PHY_N(0x15B) /* Core 1 B PHY RX I/Q comp A0 */
+#define B43_NPHY_C1_BPHY_RXIQCB0		B43_PHY_N(0x15C) /* Core 1 B PHY RX I/Q comp B0 */
+#define B43_NPHY_C2_BPHY_RXIQCA1		B43_PHY_N(0x15D) /* Core 2 B PHY RX I/Q comp A1 */
+#define B43_NPHY_C2_BPHY_RXIQCB1		B43_PHY_N(0x15E) /* Core 2 B PHY RX I/Q comp B1 */
+#define B43_NPHY_FREQGAIN0			B43_PHY_N(0x160) /* Frequency gain 0 */
+#define B43_NPHY_FREQGAIN1			B43_PHY_N(0x161) /* Frequency gain 1 */
+#define B43_NPHY_FREQGAIN2			B43_PHY_N(0x162) /* Frequency gain 2 */
+#define B43_NPHY_FREQGAIN3			B43_PHY_N(0x163) /* Frequency gain 3 */
+#define B43_NPHY_FREQGAIN4			B43_PHY_N(0x164) /* Frequency gain 4 */
+#define B43_NPHY_FREQGAIN5			B43_PHY_N(0x165) /* Frequency gain 5 */
+#define B43_NPHY_FREQGAIN6			B43_PHY_N(0x166) /* Frequency gain 6 */
+#define B43_NPHY_FREQGAIN7			B43_PHY_N(0x167) /* Frequency gain 7 */
+#define B43_NPHY_FREQGAIN_BYPASS		B43_PHY_N(0x168) /* Frequency gain bypass */
+#define B43_NPHY_TRLOSS				B43_PHY_N(0x169) /* TR loss value */
+#define B43_NPHY_C1_ADCCLIP			B43_PHY_N(0x16A) /* Core 1 ADC clip */
+#define B43_NPHY_C2_ADCCLIP			B43_PHY_N(0x16B) /* Core 2 ADC clip */
+#define B43_NPHY_LTRN_OFFGAIN			B43_PHY_N(0x16F) /* LTRN offset gain */
+#define B43_NPHY_LTRN_OFF			B43_PHY_N(0x170) /* LTRN offset */
+#define B43_NPHY_NRDATAT_WWISE20SIG		B43_PHY_N(0x171) /* # data tones WWiSE 20 sig */
+#define B43_NPHY_NRDATAT_WWISE40SIG		B43_PHY_N(0x172) /* # data tones WWiSE 40 sig */
+#define B43_NPHY_NRDATAT_TGNSYNC20SIG		B43_PHY_N(0x173) /* # data tones TGNsync 20 sig */
+#define B43_NPHY_NRDATAT_TGNSYNC40SIG		B43_PHY_N(0x174) /* # data tones TGNsync 40 sig */
+#define B43_NPHY_WWISE_CRCM0			B43_PHY_N(0x175) /* WWiSE CRC mask 0 */
+#define B43_NPHY_WWISE_CRCM1			B43_PHY_N(0x176) /* WWiSE CRC mask 1 */
+#define B43_NPHY_WWISE_CRCM2			B43_PHY_N(0x177) /* WWiSE CRC mask 2 */
+#define B43_NPHY_WWISE_CRCM3			B43_PHY_N(0x178) /* WWiSE CRC mask 3 */
+#define B43_NPHY_WWISE_CRCM4			B43_PHY_N(0x179) /* WWiSE CRC mask 4 */
+#define B43_NPHY_CHANEST_CDDSH			B43_PHY_N(0x17A) /* Channel estimate CDD shift */
+#define B43_NPHY_HTAGC_WCNT			B43_PHY_N(0x17B) /* HT ADC wait counters */
+#define B43_NPHY_SQPARM				B43_PHY_N(0x17C) /* SQ params */
+#define B43_NPHY_MCSDUP6M			B43_PHY_N(0x17D) /* MCS dup 6M */
+#define B43_NPHY_NDATAT_DUP40			B43_PHY_N(0x17E) /* # data tones dup 40 */
+#define B43_NPHY_DUP40_TGNSYNC_CYCD		B43_PHY_N(0x17F) /* Dup40 TGNsync cycle data */
+#define B43_NPHY_DUP40_GFBL			B43_PHY_N(0x180) /* Dup40 GF format BL address */
+#define B43_NPHY_DUP40_BL			B43_PHY_N(0x181) /* Dup40 format BL address */
+#define B43_NPHY_LEGDUP_FTA			B43_PHY_N(0x182) /* Legacy dup frm table address */
+#define B43_NPHY_PACPROC_DBG			B43_PHY_N(0x183) /* Packet processing debug */
+#define B43_NPHY_PIL_CYC1			B43_PHY_N(0x184) /* Pilot cycle counter 1 */
+#define B43_NPHY_PIL_CYC2			B43_PHY_N(0x185) /* Pilot cycle counter 2 */
+#define B43_NPHY_TXF_20CO_S0A1			B43_PHY_N(0x186) /* TX filter 20 coeff stage 0 A1 */
+#define B43_NPHY_TXF_20CO_S0A2			B43_PHY_N(0x187) /* TX filter 20 coeff stage 0 A2 */
+#define B43_NPHY_TXF_20CO_S1A1			B43_PHY_N(0x188) /* TX filter 20 coeff stage 1 A1 */
+#define B43_NPHY_TXF_20CO_S1A2			B43_PHY_N(0x189) /* TX filter 20 coeff stage 1 A2 */
+#define B43_NPHY_TXF_20CO_S2A1			B43_PHY_N(0x18A) /* TX filter 20 coeff stage 2 A1 */
+#define B43_NPHY_TXF_20CO_S2A2			B43_PHY_N(0x18B) /* TX filter 20 coeff stage 2 A2 */
+#define B43_NPHY_TXF_20CO_S0B1			B43_PHY_N(0x18C) /* TX filter 20 coeff stage 0 B1 */
+#define B43_NPHY_TXF_20CO_S0B2			B43_PHY_N(0x18D) /* TX filter 20 coeff stage 0 B2 */
+#define B43_NPHY_TXF_20CO_S0B3			B43_PHY_N(0x18E) /* TX filter 20 coeff stage 0 B3 */
+#define B43_NPHY_TXF_20CO_S1B1			B43_PHY_N(0x18F) /* TX filter 20 coeff stage 1 B1 */
+#define B43_NPHY_TXF_20CO_S1B2			B43_PHY_N(0x190) /* TX filter 20 coeff stage 1 B2 */
+#define B43_NPHY_TXF_20CO_S1B3			B43_PHY_N(0x191) /* TX filter 20 coeff stage 1 B3 */
+#define B43_NPHY_TXF_20CO_S2B1			B43_PHY_N(0x192) /* TX filter 20 coeff stage 2 B1 */
+#define B43_NPHY_TXF_20CO_S2B2			B43_PHY_N(0x193) /* TX filter 20 coeff stage 2 B2 */
+#define B43_NPHY_TXF_20CO_S2B3			B43_PHY_N(0x194) /* TX filter 20 coeff stage 2 B3 */
+#define B43_NPHY_TXF_40CO_S0A1			B43_PHY_N(0x195) /* TX filter 40 coeff stage 0 A1 */
+#define B43_NPHY_TXF_40CO_S0A2			B43_PHY_N(0x196) /* TX filter 40 coeff stage 0 A2 */
+#define B43_NPHY_TXF_40CO_S1A1			B43_PHY_N(0x197) /* TX filter 40 coeff stage 1 A1 */
+#define B43_NPHY_TXF_40CO_S1A2			B43_PHY_N(0x198) /* TX filter 40 coeff stage 1 A2 */
+#define B43_NPHY_TXF_40CO_S2A1			B43_PHY_N(0x199) /* TX filter 40 coeff stage 2 A1 */
+#define B43_NPHY_TXF_40CO_S2A2			B43_PHY_N(0x19A) /* TX filter 40 coeff stage 2 A2 */
+#define B43_NPHY_TXF_40CO_S0B1			B43_PHY_N(0x19B) /* TX filter 40 coeff stage 0 B1 */
+#define B43_NPHY_TXF_40CO_S0B2			B43_PHY_N(0x19C) /* TX filter 40 coeff stage 0 B2 */
+#define B43_NPHY_TXF_40CO_S0B3			B43_PHY_N(0x19D) /* TX filter 40 coeff stage 0 B3 */
+#define B43_NPHY_TXF_40CO_S1B1			B43_PHY_N(0x19E) /* TX filter 40 coeff stage 1 B1 */
+#define B43_NPHY_TXF_40CO_S1B2			B43_PHY_N(0x19F) /* TX filter 40 coeff stage 1 B2 */
+#define B43_NPHY_TXF_40CO_S1B3			B43_PHY_N(0x1A0) /* TX filter 40 coeff stage 1 B3 */
+#define B43_NPHY_TXF_40CO_S2B1			B43_PHY_N(0x1A1) /* TX filter 40 coeff stage 2 B1 */
+#define B43_NPHY_TXF_40CO_S2B2			B43_PHY_N(0x1A2) /* TX filter 40 coeff stage 2 B2 */
+#define B43_NPHY_TXF_40CO_S2B3			B43_PHY_N(0x1A3) /* TX filter 40 coeff stage 2 B3 */
+#define B43_NPHY_RSSIMC_0I_RSSI_X		B43_PHY_N(0x1A4) /* RSSI multiplication coefficient 0 I RSSI X */
+#define B43_NPHY_RSSIMC_0I_RSSI_Y		B43_PHY_N(0x1A5) /* RSSI multiplication coefficient 0 I RSSI Y */
+#define B43_NPHY_RSSIMC_0I_RSSI_Z		B43_PHY_N(0x1A6) /* RSSI multiplication coefficient 0 I RSSI Z */
+#define B43_NPHY_RSSIMC_0I_TBD			B43_PHY_N(0x1A7) /* RSSI multiplication coefficient 0 I TBD */
+#define B43_NPHY_RSSIMC_0I_PWRDET		B43_PHY_N(0x1A8) /* RSSI multiplication coefficient 0 I power det */
+#define B43_NPHY_RSSIMC_0I_TSSI			B43_PHY_N(0x1A9) /* RSSI multiplication coefficient 0 I TSSI */
+#define B43_NPHY_RSSIMC_0Q_RSSI_X		B43_PHY_N(0x1AA) /* RSSI multiplication coefficient 0 Q RSSI X */
+#define B43_NPHY_RSSIMC_0Q_RSSI_Y		B43_PHY_N(0x1AB) /* RSSI multiplication coefficient 0 Q RSSI Y */
+#define B43_NPHY_RSSIMC_0Q_RSSI_Z		B43_PHY_N(0x1AC) /* RSSI multiplication coefficient 0 Q RSSI Z */
+#define B43_NPHY_RSSIMC_0Q_TBD			B43_PHY_N(0x1AD) /* RSSI multiplication coefficient 0 Q TBD */
+#define B43_NPHY_RSSIMC_0Q_PWRDET		B43_PHY_N(0x1AE) /* RSSI multiplication coefficient 0 Q power det */
+#define B43_NPHY_RSSIMC_0Q_TSSI			B43_PHY_N(0x1AF) /* RSSI multiplication coefficient 0 Q TSSI */
+#define B43_NPHY_RSSIMC_1I_RSSI_X		B43_PHY_N(0x1B0) /* RSSI multiplication coefficient 1 I RSSI X */
+#define B43_NPHY_RSSIMC_1I_RSSI_Y		B43_PHY_N(0x1B1) /* RSSI multiplication coefficient 1 I RSSI Y */
+#define B43_NPHY_RSSIMC_1I_RSSI_Z		B43_PHY_N(0x1B2) /* RSSI multiplication coefficient 1 I RSSI Z */
+#define B43_NPHY_RSSIMC_1I_TBD			B43_PHY_N(0x1B3) /* RSSI multiplication coefficient 1 I TBD */
+#define B43_NPHY_RSSIMC_1I_PWRDET		B43_PHY_N(0x1B4) /* RSSI multiplication coefficient 1 I power det */
+#define B43_NPHY_RSSIMC_1I_TSSI			B43_PHY_N(0x1B5) /* RSSI multiplication coefficient 1 I TSSI */
+#define B43_NPHY_RSSIMC_1Q_RSSI_X		B43_PHY_N(0x1B6) /* RSSI multiplication coefficient 1 Q RSSI X */
+#define B43_NPHY_RSSIMC_1Q_RSSI_Y		B43_PHY_N(0x1B7) /* RSSI multiplication coefficient 1 Q RSSI Y */
+#define B43_NPHY_RSSIMC_1Q_RSSI_Z		B43_PHY_N(0x1B8) /* RSSI multiplication coefficient 1 Q RSSI Z */
+#define B43_NPHY_RSSIMC_1Q_TBD			B43_PHY_N(0x1B9) /* RSSI multiplication coefficient 1 Q TBD */
+#define B43_NPHY_RSSIMC_1Q_PWRDET		B43_PHY_N(0x1BA) /* RSSI multiplication coefficient 1 Q power det */
+#define B43_NPHY_RSSIMC_1Q_TSSI			B43_PHY_N(0x1BB) /* RSSI multiplication coefficient 1 Q TSSI */
+#define B43_NPHY_SAMC_WCNT			B43_PHY_N(0x1BC) /* Sample collect wait counter */
+#define B43_NPHY_PTHROUGH_CNT			B43_PHY_N(0x1BD) /* Pass-through counter */
+#define B43_NPHY_LTRN_OFF_G20L			B43_PHY_N(0x1C4) /* LTRN offset gain 20L */
+#define B43_NPHY_LTRN_OFF_20L			B43_PHY_N(0x1C5) /* LTRN offset 20L */
+#define B43_NPHY_LTRN_OFF_G20U			B43_PHY_N(0x1C6) /* LTRN offset gain 20U */
+#define B43_NPHY_LTRN_OFF_20U			B43_PHY_N(0x1C7) /* LTRN offset 20U */
+#define B43_NPHY_DSSSCCK_GAINSL			B43_PHY_N(0x1C8) /* DSSS/CCK gain settle length */
+#define B43_NPHY_GPIO_LOOUT			B43_PHY_N(0x1C9) /* GPIO low out */
+#define B43_NPHY_GPIO_HIOUT			B43_PHY_N(0x1CA) /* GPIO high out */
+#define B43_NPHY_CRS_CHECK			B43_PHY_N(0x1CB) /* CRS check */
+#define B43_NPHY_ML_LOGSS_RAT			B43_PHY_N(0x1CC) /* ML/logss ratio */
+#define B43_NPHY_DUPSCALE			B43_PHY_N(0x1CD) /* Dup scale */
+#define B43_NPHY_BW1A				B43_PHY_N(0x1CE) /* BW 1A */
+#define B43_NPHY_BW2				B43_PHY_N(0x1CF) /* BW 2 */
+#define B43_NPHY_BW3				B43_PHY_N(0x1D0) /* BW 3 */
+#define B43_NPHY_BW4				B43_PHY_N(0x1D1) /* BW 4 */
+#define B43_NPHY_BW5				B43_PHY_N(0x1D2) /* BW 5 */
+#define B43_NPHY_BW6				B43_PHY_N(0x1D3) /* BW 6 */
+#define B43_NPHY_COALEN0			B43_PHY_N(0x1D4) /* Coarse length 0 */
+#define B43_NPHY_COALEN1			B43_PHY_N(0x1D5) /* Coarse length 1 */
+#define B43_NPHY_CRSTHRES_1U			B43_PHY_N(0x1D6) /* CRS threshold 1 U */
+#define B43_NPHY_CRSTHRES_2U			B43_PHY_N(0x1D7) /* CRS threshold 2 U */
+#define B43_NPHY_CRSTHRES_3U			B43_PHY_N(0x1D8) /* CRS threshold 3 U */
+#define B43_NPHY_CRSCTL_U			B43_PHY_N(0x1D9) /* CRS control U */
+#define B43_NPHY_CRSTHRES_1L			B43_PHY_N(0x1DA) /* CRS threshold 1 L */
+#define B43_NPHY_CRSTHRES_2L			B43_PHY_N(0x1DB) /* CRS threshold 2 L */
+#define B43_NPHY_CRSTHRES_3L			B43_PHY_N(0x1DC) /* CRS threshold 3 L */
+#define B43_NPHY_CRSCTL_L			B43_PHY_N(0x1DD) /* CRS control L */
+#define B43_NPHY_STRA_1U			B43_PHY_N(0x1DE) /* STR address 1 U */
+#define B43_NPHY_STRA_2U			B43_PHY_N(0x1DF) /* STR address 2 U */
+#define B43_NPHY_STRA_1L			B43_PHY_N(0x1E0) /* STR address 1 L */
+#define B43_NPHY_STRA_2L			B43_PHY_N(0x1E1) /* STR address 2 L */
+#define B43_NPHY_CRSCHECK1			B43_PHY_N(0x1E2) /* CRS check 1 */
+#define B43_NPHY_CRSCHECK2			B43_PHY_N(0x1E3) /* CRS check 2 */
+#define B43_NPHY_CRSCHECK3			B43_PHY_N(0x1E4) /* CRS check 3 */
+#define B43_NPHY_JMPSTP0			B43_PHY_N(0x1E5) /* Jump step 0 */
+#define B43_NPHY_JMPSTP1			B43_PHY_N(0x1E6) /* Jump step 1 */
+#define B43_NPHY_TXPCTL_CMD			B43_PHY_N(0x1E7) /* TX power control command */
+#define  B43_NPHY_TXPCTL_CMD_INIT		0x007F /* Init */
+#define  B43_NPHY_TXPCTL_CMD_INIT_SHIFT		0
+#define  B43_NPHY_TXPCTL_CMD_COEFF		0x2000 /* Power control coefficients */
+#define  B43_NPHY_TXPCTL_CMD_HWPCTLEN		0x4000 /* Hardware TX power control enable */
+#define  B43_NPHY_TXPCTL_CMD_PCTLEN		0x8000 /* TX power control enable */
+#define B43_NPHY_TXPCTL_N			B43_PHY_N(0x1E8) /* TX power control N num */
+#define  B43_NPHY_TXPCTL_N_TSSID		0x00FF /* N TSSI delay */
+#define  B43_NPHY_TXPCTL_N_TSSID_SHIFT		0
+#define  B43_NPHY_TXPCTL_N_NPTIL2		0x0700 /* N PT integer log2 */
+#define  B43_NPHY_TXPCTL_N_NPTIL2_SHIFT		8
+#define B43_NPHY_TXPCTL_ITSSI			B43_PHY_N(0x1E9) /* TX power control idle TSSI */
+#define  B43_NPHY_TXPCTL_ITSSI_0		0x003F /* Idle TSSI 0 */
+#define  B43_NPHY_TXPCTL_ITSSI_0_SHIFT		0
+#define  B43_NPHY_TXPCTL_ITSSI_1		0x3F00 /* Idle TSSI 1 */
+#define  B43_NPHY_TXPCTL_ITSSI_1_SHIFT		8
+#define  B43_NPHY_TXPCTL_ITSSI_BINF		0x8000 /* Raw TSSI offset bin format */
+#define B43_NPHY_TXPCTL_TPWR			B43_PHY_N(0x1EA) /* TX power control target power */
+#define  B43_NPHY_TXPCTL_TPWR_0			0x00FF /* Power 0 */
+#define  B43_NPHY_TXPCTL_TPWR_0_SHIFT		0
+#define  B43_NPHY_TXPCTL_TPWR_1			0xFF00 /* Power 1 */
+#define  B43_NPHY_TXPCTL_TPWR_1_SHIFT		8
+#define B43_NPHY_TXPCTL_BIDX			B43_PHY_N(0x1EB) /* TX power control base index */
+#define  B43_NPHY_TXPCTL_BIDX_0			0x007F /* uC base index 0 */
+#define  B43_NPHY_TXPCTL_BIDX_0_SHIFT		0
+#define  B43_NPHY_TXPCTL_BIDX_1			0x7F00 /* uC base index 1 */
+#define  B43_NPHY_TXPCTL_BIDX_1_SHIFT		8
+#define  B43_NPHY_TXPCTL_BIDX_LOAD		0x8000 /* Load base index */
+#define B43_NPHY_TXPCTL_PIDX			B43_PHY_N(0x1EC) /* TX power control power index */
+#define  B43_NPHY_TXPCTL_PIDX_0			0x007F /* uC power index 0 */
+#define  B43_NPHY_TXPCTL_PIDX_0_SHIFT		0
+#define  B43_NPHY_TXPCTL_PIDX_1			0x7F00 /* uC power index 1 */
+#define  B43_NPHY_TXPCTL_PIDX_1_SHIFT		8
+#define B43_NPHY_C1_TXPCTL_STAT			B43_PHY_N(0x1ED) /* Core 1 TX power control status */
+#define B43_NPHY_C2_TXPCTL_STAT			B43_PHY_N(0x1EE) /* Core 2 TX power control status */
+#define  B43_NPHY_TXPCTL_STAT_EST		0x00FF /* Estimated power */
+#define  B43_NPHY_TXPCTL_STAT_EST_SHIFT		0
+#define  B43_NPHY_TXPCTL_STAT_BIDX		0x7F00 /* Base index */
+#define  B43_NPHY_TXPCTL_STAT_BIDX_SHIFT	8
+#define  B43_NPHY_TXPCTL_STAT_ESTVALID		0x8000 /* Estimated power valid */
+#define B43_NPHY_SMALLSGS_LEN			B43_PHY_N(0x1EF) /* Small sig gain settle length */
+#define B43_NPHY_PHYSTAT_GAIN0			B43_PHY_N(0x1F0) /* PHY stats gain info 0 */
+#define B43_NPHY_PHYSTAT_GAIN1			B43_PHY_N(0x1F1) /* PHY stats gain info 1 */
+#define B43_NPHY_PHYSTAT_FREQEST		B43_PHY_N(0x1F2) /* PHY stats frequency estimate */
+#define B43_NPHY_PHYSTAT_ADVRET			B43_PHY_N(0x1F3) /* PHY stats ADV retard */
+#define B43_NPHY_PHYLB_MODE			B43_PHY_N(0x1F4) /* PHY loopback mode */
+#define B43_NPHY_TONE_MIDX20_1			B43_PHY_N(0x1F5) /* Tone map index 20/1 */
+#define B43_NPHY_TONE_MIDX20_2			B43_PHY_N(0x1F6) /* Tone map index 20/2 */
+#define B43_NPHY_TONE_MIDX20_3			B43_PHY_N(0x1F7) /* Tone map index 20/3 */
+#define B43_NPHY_TONE_MIDX40_1			B43_PHY_N(0x1F8) /* Tone map index 40/1 */
+#define B43_NPHY_TONE_MIDX40_2			B43_PHY_N(0x1F9) /* Tone map index 40/2 */
+#define B43_NPHY_TONE_MIDX40_3			B43_PHY_N(0x1FA) /* Tone map index 40/3 */
+#define B43_NPHY_TONE_MIDX40_4			B43_PHY_N(0x1FB) /* Tone map index 40/4 */
+#define B43_NPHY_PILTONE_MIDX1			B43_PHY_N(0x1FC) /* Pilot tone map index 1 */
+#define B43_NPHY_PILTONE_MIDX2			B43_PHY_N(0x1FD) /* Pilot tone map index 2 */
+#define B43_NPHY_PILTONE_MIDX3			B43_PHY_N(0x1FE) /* Pilot tone map index 3 */
+#define B43_NPHY_TXRIFS_FRDEL			B43_PHY_N(0x1FF) /* TX RIFS frame delay */
+#define B43_NPHY_AFESEQ_RX2TX_PUD_40M		B43_PHY_N(0x200) /* AFE seq rx2tx power up/down delay 40M */
+#define B43_NPHY_AFESEQ_TX2RX_PUD_40M		B43_PHY_N(0x201) /* AFE seq tx2rx power up/down delay 40M */
+#define B43_NPHY_AFESEQ_RX2TX_PUD_20M		B43_PHY_N(0x202) /* AFE seq rx2tx power up/down delay 20M */
+#define B43_NPHY_AFESEQ_TX2RX_PUD_20M		B43_PHY_N(0x203) /* AFE seq tx2rx power up/down delay 20M */
+#define B43_NPHY_RX_SIGCTL			B43_PHY_N(0x204) /* RX signal control */
+#define B43_NPHY_RXPIL_CYCNT0			B43_PHY_N(0x205) /* RX pilot cycle counter 0 */
+#define B43_NPHY_RXPIL_CYCNT1			B43_PHY_N(0x206) /* RX pilot cycle counter 1 */
+#define B43_NPHY_RXPIL_CYCNT2			B43_PHY_N(0x207) /* RX pilot cycle counter 2 */
+#define B43_NPHY_AFESEQ_RX2TX_PUD_10M		B43_PHY_N(0x208) /* AFE seq rx2tx power up/down delay 10M */
+#define B43_NPHY_AFESEQ_TX2RX_PUD_10M		B43_PHY_N(0x209) /* AFE seq tx2rx power up/down delay 10M */
+#define B43_NPHY_DSSSCCK_CRSEXTL		B43_PHY_N(0x20A) /* DSSS/CCK CRS extension length */
+#define B43_NPHY_ML_LOGSS_RATSLOPE		B43_PHY_N(0x20B) /* ML/logss ratio slope */
+#define B43_NPHY_RIFS_SRCTL			B43_PHY_N(0x20C) /* RIFS search timeout length */
+#define B43_NPHY_TXREALFD			B43_PHY_N(0x20D) /* TX real frame delay */
+#define B43_NPHY_HPANT_SWTHRES			B43_PHY_N(0x20E) /* High power antenna switch threshold */
+#define B43_NPHY_EDCRS_ASSTHRES0		B43_PHY_N(0x210) /* ED CRS assert threshold 0 */
+#define B43_NPHY_EDCRS_ASSTHRES1		B43_PHY_N(0x211) /* ED CRS assert threshold 1 */
+#define B43_NPHY_EDCRS_DEASSTHRES0		B43_PHY_N(0x212) /* ED CRS deassert threshold 0 */
+#define B43_NPHY_EDCRS_DEASSTHRES1		B43_PHY_N(0x213) /* ED CRS deassert threshold 1 */
+#define B43_NPHY_STR_WTIME20U			B43_PHY_N(0x214) /* STR wait time 20U */
+#define B43_NPHY_STR_WTIME20L			B43_PHY_N(0x215) /* STR wait time 20L */
+#define B43_NPHY_TONE_MIDX657M			B43_PHY_N(0x216) /* Tone map index 657M */
+#define B43_NPHY_HTSIGTONES			B43_PHY_N(0x217) /* HT signal tones */
+#define B43_NPHY_RSSI1				B43_PHY_N(0x219) /* RSSI value 1 */
+#define B43_NPHY_RSSI2				B43_PHY_N(0x21A) /* RSSI value 2 */
+#define B43_NPHY_CHAN_ESTHANG			B43_PHY_N(0x21D) /* Channel estimate hang */
+#define B43_NPHY_FINERX2_CGC			B43_PHY_N(0x221) /* Fine RX 2 clock gate control */
+#define  B43_NPHY_FINERX2_CGC_DECGC		0x0008 /* Decode gated clocks */
+#define B43_NPHY_TXPCTL_INIT			B43_PHY_N(0x222) /* TX power controll init */
+#define  B43_NPHY_TXPCTL_INIT_PIDXI1		0x00FF /* Power index init 1 */
+#define  B43_NPHY_TXPCTL_INIT_PIDXI1_SHIFT	0
+
+
+struct b43_wldev;
+
+int b43_phy_initn(struct b43_wldev *dev);
+
+#endif /* B43_NPHY_H_ */
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h	2007-12-28 23:36:04.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/phy.h	2008-01-07 18:03:24.000000000 +0100
@@ -6,17 +6,20 @@
 struct b43_wldev;
 struct b43_phy;
 
 /*** PHY Registers ***/
 
 /* Routing */
-#define B43_PHYROUTE_OFDM_GPHY		0x400
-#define B43_PHYROUTE_EXT_GPHY		0x800
+#define B43_PHYROUTE_OFDM_GPHY		0x0400 /* OFDM register routing for G-PHYs */
+#define B43_PHYROUTE_EXT_GPHY		0x0800 /* Extended G-PHY registers */
+#define B43_PHYROUTE_N_BMODE		0x3000 /* N-PHY BMODE registers */
 
 /* Base registers. */
 #define B43_PHY_BASE(reg)		(reg)
+/* N-PHY registers. */
+#define B43_PHY_N(reg)			(reg)
 /* OFDM (A) registers of a G-PHY */
 #define B43_PHY_OFDM(reg)		((reg) | B43_PHYROUTE_OFDM_GPHY)
 /* Extended G-PHY registers */
 #define B43_PHY_EXTG(reg)		((reg) | B43_PHYROUTE_EXT_GPHY)
 
 /* OFDM (A) PHY Registers */
Index: wireless-2.6/drivers/net/wireless/b43/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/Makefile	2008-01-07 13:09:32.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/Makefile	2008-01-09 16:00:24.000000000 +0100
@@ -1,9 +1,10 @@
 b43-y				+= main.o
 b43-y				+= tables.o
 b43-y				+= phy.o
+b43-y				+= nphy.o
 b43-y				+= sysfs.o
 b43-y				+= xmit.o
 b43-y				+= lo.o
 b43-y				+= wa.o
 b43-y				+= dma.o
 b43-$(CONFIG_B43_RFKILL)	+= rfkill.o
Index: wireless-2.6/drivers/net/wireless/b43/nphy.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ wireless-2.6/drivers/net/wireless/b43/nphy.c	2008-01-09 15:59:41.000000000 +0100
@@ -0,0 +1,34 @@
+/*
+
+  Broadcom B43 wireless driver
+  IEEE 802.11n PHY support
+
+  Copyright (c) 2008 Michael Buesch <mb at bu3sch.de>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+
+*/
+
+#include "b43.h"
+#include "nphy.h"
+
+
+int b43_phy_initn(struct b43_wldev *dev)
+{
+	b43err(dev->wl, "IEEE 802.11n devices are not supported, yet.\n");
+
+	return -EOPNOTSUPP;
+}
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c	2007-12-28 23:36:04.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/phy.c	2008-01-09 16:01:33.000000000 +0100
@@ -28,12 +28,13 @@
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/types.h>
 
 #include "b43.h"
 #include "phy.h"
+#include "nphy.h"
 #include "main.h"
 #include "tables.h"
 #include "lo.h"
 #include "wa.h"
 
 
@@ -1971,47 +1972,50 @@ int b43_phy_init_tssi2dbm_table(struct b
 	return 0;
 }
 
 int b43_phy_init(struct b43_wldev *dev)
 {
 	struct b43_phy *phy = &dev->phy;
-	int err = -ENODEV;
+	bool unsupported = 0;
+	int err = 0;
 
 	switch (phy->type) {
 	case B43_PHYTYPE_A:
-		if (phy->rev == 2 || phy->rev == 3) {
+		if (phy->rev == 2 || phy->rev == 3)
 			b43_phy_inita(dev);
-			err = 0;
-		}
+		else
+			unsupported = 1;
 		break;
 	case B43_PHYTYPE_B:
 		switch (phy->rev) {
 		case 2:
 			b43_phy_initb2(dev);
-			err = 0;
 			break;
 		case 4:
 			b43_phy_initb4(dev);
-			err = 0;
 			break;
 		case 5:
 			b43_phy_initb5(dev);
-			err = 0;
 			break;
 		case 6:
 			b43_phy_initb6(dev);
-			err = 0;
 			break;
+		default:
+			unsupported = 1;
 		}
 		break;
 	case B43_PHYTYPE_G:
 		b43_phy_initg(dev);
-		err = 0;
 		break;
+	case B43_PHYTYPE_N:
+		err = b43_phy_initn(dev);
+		break;
+	default:
+		unsupported = 1;
 	}
-	if (err)
+	if (unsupported)
 		b43err(dev->wl, "Unknown PHYTYPE found\n");
 
 	return err;
 }
 
 void b43_set_rx_antenna(struct b43_wldev *dev, int antenna)


From mb at bu3sch.de  Wed Jan  9 18:39:09 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 9 Jan 2008 18:39:09 +0100
Subject: [PATCH] b43: Fix PHY register routing
Message-ID: <200801091839.10076.mb@bu3sch.de>

This fixes the PHY routing bit handling.
This is needed for N-PHY.
No functional change to A-PHY and G-PHY code.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.25.


Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c	2008-01-09 17:51:03.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/phy.c	2008-01-09 18:30:13.000000000 +0100
@@ -271,21 +271,36 @@ void b43_raw_phy_unlock(struct b43_wldev
  */
 static inline u16 adjust_phyreg_for_phytype(struct b43_phy *phy,
 					    u16 offset, struct b43_wldev *dev)
 {
 	if (phy->type == B43_PHYTYPE_A) {
 		/* OFDM registers are base-registers for the A-PHY. */
-		offset &= ~B43_PHYROUTE_OFDM_GPHY;
+		if ((offset & B43_PHYROUTE) == B43_PHYROUTE_OFDM_GPHY) {
+			offset &= ~B43_PHYROUTE;
+			offset |= B43_PHYROUTE_BASE;
+		}
 	}
-	if (offset & B43_PHYROUTE_EXT_GPHY) {
+
+#if B43_DEBUG
+	if ((offset & B43_PHYROUTE) == B43_PHYROUTE_EXT_GPHY) {
 		/* Ext-G registers are only available on G-PHYs */
 		if (phy->type != B43_PHYTYPE_G) {
-			b43dbg(dev->wl, "EXT-G PHY access at "
-			       "0x%04X on %u type PHY\n", offset, phy->type);
+			b43err(dev->wl, "Invalid EXT-G PHY access at "
+			       "0x%04X on PHY type %u\n", offset, phy->type);
+			dump_stack();
+		}
+	}
+	if ((offset & B43_PHYROUTE) == B43_PHYROUTE_N_BMODE) {
+		/* N-BMODE registers are only available on N-PHYs */
+		if (phy->type != B43_PHYTYPE_N) {
+			b43err(dev->wl, "Invalid N-BMODE PHY access at "
+			       "0x%04X on PHY type %u\n", offset, phy->type);
+			dump_stack();
 		}
 	}
+#endif /* B43_DEBUG */
 
 	return offset;
 }
 
 u16 b43_phy_read(struct b43_wldev * dev, u16 offset)
 {
@@ -299,13 +314,12 @@ u16 b43_phy_read(struct b43_wldev * dev,
 void b43_phy_write(struct b43_wldev *dev, u16 offset, u16 val)
 {
 	struct b43_phy *phy = &dev->phy;
 
 	offset = adjust_phyreg_for_phytype(phy, offset, dev);
 	b43_write16(dev, B43_MMIO_PHY_CONTROL, offset);
-	mmiowb();
 	b43_write16(dev, B43_MMIO_PHY_DATA, val);
 }
 
 /* Adjust the transmission power output (G-PHY) */
 void b43_set_txpower_g(struct b43_wldev *dev,
 		       const struct b43_bbatt *bbatt,
@@ -1270,20 +1284,20 @@ static void b43_calc_loopback_gain(struc
 	backup_phy[2] = b43_phy_read(dev, B43_PHY_RFOVER);
 	backup_phy[3] = b43_phy_read(dev, B43_PHY_RFOVERVAL);
 	if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
 		backup_phy[4] = b43_phy_read(dev, B43_PHY_ANALOGOVER);
 		backup_phy[5] = b43_phy_read(dev, B43_PHY_ANALOGOVERVAL);
 	}
-	backup_phy[6] = b43_phy_read(dev, B43_PHY_BASE(0x5A));
-	backup_phy[7] = b43_phy_read(dev, B43_PHY_BASE(0x59));
-	backup_phy[8] = b43_phy_read(dev, B43_PHY_BASE(0x58));
-	backup_phy[9] = b43_phy_read(dev, B43_PHY_BASE(0x0A));
-	backup_phy[10] = b43_phy_read(dev, B43_PHY_BASE(0x03));
+	backup_phy[6] = b43_phy_read(dev, B43_PHY_CCK(0x5A));
+	backup_phy[7] = b43_phy_read(dev, B43_PHY_CCK(0x59));
+	backup_phy[8] = b43_phy_read(dev, B43_PHY_CCK(0x58));
+	backup_phy[9] = b43_phy_read(dev, B43_PHY_CCK(0x0A));
+	backup_phy[10] = b43_phy_read(dev, B43_PHY_CCK(0x03));
 	backup_phy[11] = b43_phy_read(dev, B43_PHY_LO_MASK);
 	backup_phy[12] = b43_phy_read(dev, B43_PHY_LO_CTL);
-	backup_phy[13] = b43_phy_read(dev, B43_PHY_BASE(0x2B));
+	backup_phy[13] = b43_phy_read(dev, B43_PHY_CCK(0x2B));
 	backup_phy[14] = b43_phy_read(dev, B43_PHY_PGACTL);
 	backup_phy[15] = b43_phy_read(dev, B43_PHY_LO_LEAKAGE);
 	backup_bband = phy->bbatt.att;
 	backup_radio[0] = b43_radio_read16(dev, 0x52);
 	backup_radio[1] = b43_radio_read16(dev, 0x43);
 	backup_radio[2] = b43_radio_read16(dev, 0x7A);
@@ -1319,27 +1333,27 @@ static void b43_calc_loopback_gain(struc
 	b43_phy_write(dev, B43_PHY_RFOVER,
 		      b43_phy_read(dev, B43_PHY_RFOVER) | 0x0030);
 	b43_phy_write(dev, B43_PHY_RFOVERVAL,
 		      (b43_phy_read(dev, B43_PHY_RFOVERVAL)
 		       & 0xFFCF) | 0x10);
 
-	b43_phy_write(dev, B43_PHY_BASE(0x5A), 0x0780);
-	b43_phy_write(dev, B43_PHY_BASE(0x59), 0xC810);
-	b43_phy_write(dev, B43_PHY_BASE(0x58), 0x000D);
+	b43_phy_write(dev, B43_PHY_CCK(0x5A), 0x0780);
+	b43_phy_write(dev, B43_PHY_CCK(0x59), 0xC810);
+	b43_phy_write(dev, B43_PHY_CCK(0x58), 0x000D);
 
-	b43_phy_write(dev, B43_PHY_BASE(0x0A),
-		      b43_phy_read(dev, B43_PHY_BASE(0x0A)) | 0x2000);
+	b43_phy_write(dev, B43_PHY_CCK(0x0A),
+		      b43_phy_read(dev, B43_PHY_CCK(0x0A)) | 0x2000);
 	if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
 		b43_phy_write(dev, B43_PHY_ANALOGOVER,
 			      b43_phy_read(dev, B43_PHY_ANALOGOVER) | 0x0004);
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      b43_phy_read(dev,
 					   B43_PHY_ANALOGOVERVAL) & 0xFFFB);
 	}
-	b43_phy_write(dev, B43_PHY_BASE(0x03),
-		      (b43_phy_read(dev, B43_PHY_BASE(0x03))
+	b43_phy_write(dev, B43_PHY_CCK(0x03),
+		      (b43_phy_read(dev, B43_PHY_CCK(0x03))
 		       & 0xFF9F) | 0x40);
 
 	if (phy->radio_rev == 8) {
 		b43_radio_write16(dev, 0x43, 0x000F);
 	} else {
 		b43_radio_write16(dev, 0x52, 0);
@@ -1351,17 +1365,17 @@ static void b43_calc_loopback_gain(struc
 	if (phy->rev >= 3)
 		b43_phy_write(dev, B43_PHY_LO_MASK, 0xC020);
 	else
 		b43_phy_write(dev, B43_PHY_LO_MASK, 0x8020);
 	b43_phy_write(dev, B43_PHY_LO_CTL, 0);
 
-	b43_phy_write(dev, B43_PHY_BASE(0x2B),
-		      (b43_phy_read(dev, B43_PHY_BASE(0x2B))
+	b43_phy_write(dev, B43_PHY_CCK(0x2B),
+		      (b43_phy_read(dev, B43_PHY_CCK(0x2B))
 		       & 0xFFC0) | 0x01);
-	b43_phy_write(dev, B43_PHY_BASE(0x2B),
-		      (b43_phy_read(dev, B43_PHY_BASE(0x2B))
+	b43_phy_write(dev, B43_PHY_CCK(0x2B),
+		      (b43_phy_read(dev, B43_PHY_CCK(0x2B))
 		       & 0xC0FF) | 0x800);
 
 	b43_phy_write(dev, B43_PHY_RFOVER,
 		      b43_phy_read(dev, B43_PHY_RFOVER) | 0x0100);
 	b43_phy_write(dev, B43_PHY_RFOVERVAL,
 		      b43_phy_read(dev, B43_PHY_RFOVERVAL) & 0xCFFF);
@@ -1426,20 +1440,20 @@ static void b43_calc_loopback_gain(struc
       exit_loop2:
 
 	if (phy->rev != 1) {	/* Not in specs, but needed to prevent PPC machine check */
 		b43_phy_write(dev, B43_PHY_ANALOGOVER, backup_phy[4]);
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL, backup_phy[5]);
 	}
-	b43_phy_write(dev, B43_PHY_BASE(0x5A), backup_phy[6]);
-	b43_phy_write(dev, B43_PHY_BASE(0x59), backup_phy[7]);
-	b43_phy_write(dev, B43_PHY_BASE(0x58), backup_phy[8]);
-	b43_phy_write(dev, B43_PHY_BASE(0x0A), backup_phy[9]);
-	b43_phy_write(dev, B43_PHY_BASE(0x03), backup_phy[10]);
+	b43_phy_write(dev, B43_PHY_CCK(0x5A), backup_phy[6]);
+	b43_phy_write(dev, B43_PHY_CCK(0x59), backup_phy[7]);
+	b43_phy_write(dev, B43_PHY_CCK(0x58), backup_phy[8]);
+	b43_phy_write(dev, B43_PHY_CCK(0x0A), backup_phy[9]);
+	b43_phy_write(dev, B43_PHY_CCK(0x03), backup_phy[10]);
 	b43_phy_write(dev, B43_PHY_LO_MASK, backup_phy[11]);
 	b43_phy_write(dev, B43_PHY_LO_CTL, backup_phy[12]);
-	b43_phy_write(dev, B43_PHY_BASE(0x2B), backup_phy[13]);
+	b43_phy_write(dev, B43_PHY_CCK(0x2B), backup_phy[13]);
 	b43_phy_write(dev, B43_PHY_PGACTL, backup_phy[14]);
 
 	b43_phy_set_baseband_attenuation(dev, backup_bband);
 
 	b43_radio_write16(dev, 0x52, backup_radio[0]);
 	b43_radio_write16(dev, 0x43, backup_radio[1]);
@@ -1525,25 +1539,25 @@ static void b43_phy_initg(struct b43_wld
 		} else {
 			b43_radio_write16(dev, 0x52,
 					  (b43_radio_read16(dev, 0x52) & 0xFFF0)
 					  | phy->lo_control->tx_bias);
 		}
 		if (phy->rev >= 6) {
-			b43_phy_write(dev, B43_PHY_BASE(0x36),
-				      (b43_phy_read(dev, B43_PHY_BASE(0x36))
+			b43_phy_write(dev, B43_PHY_CCK(0x36),
+				      (b43_phy_read(dev, B43_PHY_CCK(0x36))
 				       & 0x0FFF) | (phy->lo_control->
 						    tx_bias << 12));
 		}
 		if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_PACTRL)
-			b43_phy_write(dev, B43_PHY_BASE(0x2E), 0x8075);
+			b43_phy_write(dev, B43_PHY_CCK(0x2E), 0x8075);
 		else
-			b43_phy_write(dev, B43_PHY_BASE(0x2E), 0x807F);
+			b43_phy_write(dev, B43_PHY_CCK(0x2E), 0x807F);
 		if (phy->rev < 2)
-			b43_phy_write(dev, B43_PHY_BASE(0x2F), 0x101);
+			b43_phy_write(dev, B43_PHY_CCK(0x2F), 0x101);
 		else
-			b43_phy_write(dev, B43_PHY_BASE(0x2F), 0x202);
+			b43_phy_write(dev, B43_PHY_CCK(0x2F), 0x202);
 	}
 	if (phy->gmode || phy->rev >= 2) {
 		b43_lo_g_adjust(dev);
 		b43_phy_write(dev, B43_PHY_LO_MASK, 0x8078);
 	}
 
@@ -2165,15 +2179,18 @@ void b43_radio_unlock(struct b43_wldev *
 }
 
 u16 b43_radio_read16(struct b43_wldev *dev, u16 offset)
 {
 	struct b43_phy *phy = &dev->phy;
 
+	/* Offset 1 is a 32-bit register. */
+	B43_WARN_ON(offset == 1);
+
 	switch (phy->type) {
 	case B43_PHYTYPE_A:
-		offset |= 0x0040;
+		offset |= 0x40;
 		break;
 	case B43_PHYTYPE_B:
 		if (phy->radio_ver == 0x2053) {
 			if (offset < 0x70)
 				offset += 0x80;
 			else if (offset < 0x80)
@@ -2183,22 +2200,32 @@ u16 b43_radio_read16(struct b43_wldev *d
 		} else
 			B43_WARN_ON(1);
 		break;
 	case B43_PHYTYPE_G:
 		offset |= 0x80;
 		break;
+	case B43_PHYTYPE_N:
+		offset |= 0x100;
+		break;
+	case B43_PHYTYPE_LP:
+		/* No adjustment required. */
+		break;
+	default:
+		B43_WARN_ON(1);
 	}
 
 	b43_write16(dev, B43_MMIO_RADIO_CONTROL, offset);
 	return b43_read16(dev, B43_MMIO_RADIO_DATA_LOW);
 }
 
 void b43_radio_write16(struct b43_wldev *dev, u16 offset, u16 val)
 {
+	/* Offset 1 is a 32-bit register. */
+	B43_WARN_ON(offset == 1);
+
 	b43_write16(dev, B43_MMIO_RADIO_CONTROL, offset);
-	mmiowb();
 	b43_write16(dev, B43_MMIO_RADIO_DATA_LOW, val);
 }
 
 static void b43_set_all_gains(struct b43_wldev *dev,
 			      s16 first, s16 second, s16 third)
 {
@@ -3477,16 +3504,16 @@ struct init2050_saved_values {
 	/* Radio registers */
 	u16 radio_43;
 	u16 radio_51;
 	u16 radio_52;
 	/* PHY registers */
 	u16 phy_pgactl;
-	u16 phy_base_5A;
-	u16 phy_base_59;
-	u16 phy_base_58;
-	u16 phy_base_30;
+	u16 phy_cck_5A;
+	u16 phy_cck_59;
+	u16 phy_cck_58;
+	u16 phy_cck_30;
 	u16 phy_rfover;
 	u16 phy_rfoverval;
 	u16 phy_analogover;
 	u16 phy_analogoverval;
 	u16 phy_crs0;
 	u16 phy_classctl;
@@ -3508,21 +3535,21 @@ u16 b43_radio_init2050(struct b43_wldev 
 	memset(&sav, 0, sizeof(sav));	/* get rid of "may be used uninitialized..." */
 
 	sav.radio_43 = b43_radio_read16(dev, 0x43);
 	sav.radio_51 = b43_radio_read16(dev, 0x51);
 	sav.radio_52 = b43_radio_read16(dev, 0x52);
 	sav.phy_pgactl = b43_phy_read(dev, B43_PHY_PGACTL);
-	sav.phy_base_5A = b43_phy_read(dev, B43_PHY_BASE(0x5A));
-	sav.phy_base_59 = b43_phy_read(dev, B43_PHY_BASE(0x59));
-	sav.phy_base_58 = b43_phy_read(dev, B43_PHY_BASE(0x58));
+	sav.phy_cck_5A = b43_phy_read(dev, B43_PHY_CCK(0x5A));
+	sav.phy_cck_59 = b43_phy_read(dev, B43_PHY_CCK(0x59));
+	sav.phy_cck_58 = b43_phy_read(dev, B43_PHY_CCK(0x58));
 
 	if (phy->type == B43_PHYTYPE_B) {
-		sav.phy_base_30 = b43_phy_read(dev, B43_PHY_BASE(0x30));
+		sav.phy_cck_30 = b43_phy_read(dev, B43_PHY_CCK(0x30));
 		sav.reg_3EC = b43_read16(dev, 0x3EC);
 
-		b43_phy_write(dev, B43_PHY_BASE(0x30), 0xFF);
+		b43_phy_write(dev, B43_PHY_CCK(0x30), 0xFF);
 		b43_write16(dev, 0x3EC, 0x3F3F);
 	} else if (phy->gmode || phy->rev >= 2) {
 		sav.phy_rfover = b43_phy_read(dev, B43_PHY_RFOVER);
 		sav.phy_rfoverval = b43_phy_read(dev, B43_PHY_RFOVERVAL);
 		sav.phy_analogover = b43_phy_read(dev, B43_PHY_ANALOGOVER);
 		sav.phy_analogoverval =
@@ -3567,14 +3594,14 @@ u16 b43_radio_init2050(struct b43_wldev 
 	sav.reg_3F4 = b43_read16(dev, 0x3F4);
 
 	if (phy->analog == 0) {
 		b43_write16(dev, 0x03E6, 0x0122);
 	} else {
 		if (phy->analog >= 2) {
-			b43_phy_write(dev, B43_PHY_BASE(0x03),
-				      (b43_phy_read(dev, B43_PHY_BASE(0x03))
+			b43_phy_write(dev, B43_PHY_CCK(0x03),
+				      (b43_phy_read(dev, B43_PHY_CCK(0x03))
 				       & 0xFFBF) | 0x40);
 		}
 		b43_write16(dev, B43_MMIO_CHANNEL_EXT,
 			    (b43_read16(dev, B43_MMIO_CHANNEL_EXT) | 0x2000));
 	}
 
@@ -3585,13 +3612,13 @@ u16 b43_radio_init2050(struct b43_wldev 
 	if (phy->gmode || phy->rev >= 2) {
 		b43_phy_write(dev, B43_PHY_RFOVERVAL,
 			      radio2050_rfover_val(dev, B43_PHY_RFOVERVAL,
 						   LPD(0, 1, 1)));
 	}
 	b43_phy_write(dev, B43_PHY_PGACTL, 0xBFAF);
-	b43_phy_write(dev, B43_PHY_BASE(0x2B), 0x1403);
+	b43_phy_write(dev, B43_PHY_CCK(0x2B), 0x1403);
 	if (phy->gmode || phy->rev >= 2) {
 		b43_phy_write(dev, B43_PHY_RFOVERVAL,
 			      radio2050_rfover_val(dev, B43_PHY_RFOVERVAL,
 						   LPD(0, 0, 1)));
 	}
 	b43_phy_write(dev, B43_PHY_PGACTL, 0xBFA0);
@@ -3601,18 +3628,18 @@ u16 b43_radio_init2050(struct b43_wldev 
 		b43_radio_write16(dev, 0x43, 0x1F);
 	} else {
 		b43_radio_write16(dev, 0x52, 0);
 		b43_radio_write16(dev, 0x43, (b43_radio_read16(dev, 0x43)
 					      & 0xFFF0) | 0x0009);
 	}
-	b43_phy_write(dev, B43_PHY_BASE(0x58), 0);
+	b43_phy_write(dev, B43_PHY_CCK(0x58), 0);
 
 	for (i = 0; i < 16; i++) {
-		b43_phy_write(dev, B43_PHY_BASE(0x5A), 0x0480);
-		b43_phy_write(dev, B43_PHY_BASE(0x59), 0xC810);
-		b43_phy_write(dev, B43_PHY_BASE(0x58), 0x000D);
+		b43_phy_write(dev, B43_PHY_CCK(0x5A), 0x0480);
+		b43_phy_write(dev, B43_PHY_CCK(0x59), 0xC810);
+		b43_phy_write(dev, B43_PHY_CCK(0x58), 0x000D);
 		if (phy->gmode || phy->rev >= 2) {
 			b43_phy_write(dev, B43_PHY_RFOVERVAL,
 				      radio2050_rfover_val(dev,
 							   B43_PHY_RFOVERVAL,
 							   LPD(1, 0, 1)));
 		}
@@ -3632,35 +3659,35 @@ u16 b43_radio_init2050(struct b43_wldev 
 							   B43_PHY_RFOVERVAL,
 							   LPD(1, 0, 0)));
 		}
 		b43_phy_write(dev, B43_PHY_PGACTL, 0xFFF0);
 		udelay(20);
 		tmp1 += b43_phy_read(dev, B43_PHY_LO_LEAKAGE);
-		b43_phy_write(dev, B43_PHY_BASE(0x58), 0);
+		b43_phy_write(dev, B43_PHY_CCK(0x58), 0);
 		if (phy->gmode || phy->rev >= 2) {
 			b43_phy_write(dev, B43_PHY_RFOVERVAL,
 				      radio2050_rfover_val(dev,
 							   B43_PHY_RFOVERVAL,
 							   LPD(1, 0, 1)));
 		}
 		b43_phy_write(dev, B43_PHY_PGACTL, 0xAFB0);
 	}
 	udelay(10);
 
-	b43_phy_write(dev, B43_PHY_BASE(0x58), 0);
+	b43_phy_write(dev, B43_PHY_CCK(0x58), 0);
 	tmp1++;
 	tmp1 >>= 9;
 
 	for (i = 0; i < 16; i++) {
 		radio78 = ((flip_4bit(i) << 1) | 0x20);
 		b43_radio_write16(dev, 0x78, radio78);
 		udelay(10);
 		for (j = 0; j < 16; j++) {
-			b43_phy_write(dev, B43_PHY_BASE(0x5A), 0x0D80);
-			b43_phy_write(dev, B43_PHY_BASE(0x59), 0xC810);
-			b43_phy_write(dev, B43_PHY_BASE(0x58), 0x000D);
+			b43_phy_write(dev, B43_PHY_CCK(0x5A), 0x0D80);
+			b43_phy_write(dev, B43_PHY_CCK(0x59), 0xC810);
+			b43_phy_write(dev, B43_PHY_CCK(0x58), 0x000D);
 			if (phy->gmode || phy->rev >= 2) {
 				b43_phy_write(dev, B43_PHY_RFOVERVAL,
 					      radio2050_rfover_val(dev,
 								   B43_PHY_RFOVERVAL,
 								   LPD(1, 0,
 								       1)));
@@ -3683,13 +3710,13 @@ u16 b43_radio_init2050(struct b43_wldev 
 								   LPD(1, 0,
 								       0)));
 			}
 			b43_phy_write(dev, B43_PHY_PGACTL, 0xFFF0);
 			udelay(10);
 			tmp2 += b43_phy_read(dev, B43_PHY_LO_LEAKAGE);
-			b43_phy_write(dev, B43_PHY_BASE(0x58), 0);
+			b43_phy_write(dev, B43_PHY_CCK(0x58), 0);
 			if (phy->gmode || phy->rev >= 2) {
 				b43_phy_write(dev, B43_PHY_RFOVERVAL,
 					      radio2050_rfover_val(dev,
 								   B43_PHY_RFOVERVAL,
 								   LPD(1, 0,
 								       1)));
@@ -3704,22 +3731,22 @@ u16 b43_radio_init2050(struct b43_wldev 
 
 	/* Restore the registers */
 	b43_phy_write(dev, B43_PHY_PGACTL, sav.phy_pgactl);
 	b43_radio_write16(dev, 0x51, sav.radio_51);
 	b43_radio_write16(dev, 0x52, sav.radio_52);
 	b43_radio_write16(dev, 0x43, sav.radio_43);
-	b43_phy_write(dev, B43_PHY_BASE(0x5A), sav.phy_base_5A);
-	b43_phy_write(dev, B43_PHY_BASE(0x59), sav.phy_base_59);
-	b43_phy_write(dev, B43_PHY_BASE(0x58), sav.phy_base_58);
+	b43_phy_write(dev, B43_PHY_CCK(0x5A), sav.phy_cck_5A);
+	b43_phy_write(dev, B43_PHY_CCK(0x59), sav.phy_cck_59);
+	b43_phy_write(dev, B43_PHY_CCK(0x58), sav.phy_cck_58);
 	b43_write16(dev, 0x3E6, sav.reg_3E6);
 	if (phy->analog != 0)
 		b43_write16(dev, 0x3F4, sav.reg_3F4);
 	b43_phy_write(dev, B43_PHY_SYNCCTL, sav.phy_syncctl);
 	b43_synth_pu_workaround(dev, phy->channel);
 	if (phy->type == B43_PHYTYPE_B) {
-		b43_phy_write(dev, B43_PHY_BASE(0x30), sav.phy_base_30);
+		b43_phy_write(dev, B43_PHY_CCK(0x30), sav.phy_cck_30);
 		b43_write16(dev, 0x3EC, sav.reg_3EC);
 	} else if (phy->gmode) {
 		b43_write16(dev, B43_MMIO_PHY_RADIO,
 			    b43_read16(dev, B43_MMIO_PHY_RADIO)
 			    & 0x7FFF);
 		b43_phy_write(dev, B43_PHY_RFOVER, sav.phy_rfover);
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h	2008-01-09 17:51:03.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/phy.h	2008-01-09 17:59:17.000000000 +0100
@@ -6,23 +6,27 @@
 struct b43_wldev;
 struct b43_phy;
 
 /*** PHY Registers ***/
 
 /* Routing */
-#define B43_PHYROUTE_OFDM_GPHY		0x0400 /* OFDM register routing for G-PHYs */
-#define B43_PHYROUTE_EXT_GPHY		0x0800 /* Extended G-PHY registers */
-#define B43_PHYROUTE_N_BMODE		0x3000 /* N-PHY BMODE registers */
+#define B43_PHYROUTE			0x0C00 /* PHY register routing bits mask */
+#define  B43_PHYROUTE_BASE		0x0000 /* Base registers */
+#define  B43_PHYROUTE_OFDM_GPHY		0x0400 /* OFDM register routing for G-PHYs */
+#define  B43_PHYROUTE_EXT_GPHY		0x0800 /* Extended G-PHY registers */
+#define  B43_PHYROUTE_N_BMODE		0x0C00 /* N-PHY BMODE registers */
 
-/* Base registers. */
-#define B43_PHY_BASE(reg)		(reg)
+/* CCK (B-PHY) registers. */
+#define B43_PHY_CCK(reg)		((reg) | B43_PHYROUTE_BASE)
 /* N-PHY registers. */
-#define B43_PHY_N(reg)			(reg)
-/* OFDM (A) registers of a G-PHY */
+#define B43_PHY_N(reg)			((reg) | B43_PHYROUTE_BASE)
+/* N-PHY BMODE registers. */
+#define B43_PHY_N_BMODE(reg)		((reg) | B43_PHYROUTE_N_BMODE)
+/* OFDM (A-PHY) registers. */
 #define B43_PHY_OFDM(reg)		((reg) | B43_PHYROUTE_OFDM_GPHY)
-/* Extended G-PHY registers */
+/* Extended G-PHY registers. */
 #define B43_PHY_EXTG(reg)		((reg) | B43_PHYROUTE_EXT_GPHY)
 
 /* OFDM (A) PHY Registers */
 #define B43_PHY_VERSION_OFDM		B43_PHY_OFDM(0x00)	/* Versioning register for A-PHY */
 #define B43_PHY_BBANDCFG		B43_PHY_OFDM(0x01)	/* Baseband config */
 #define  B43_PHY_BBANDCFG_RXANT		0x180	/* RX Antenna selection */
@@ -76,26 +80,26 @@ struct b43_phy;
 #define B43_PHY_CRSTHRES2		B43_PHY_OFDM(0xC1)	/* CRS Threshold 2 (phy.rev >= 2 only) */
 #define B43_PHY_TSSIP_LTBASE		B43_PHY_OFDM(0x380)	/* TSSI power lookup table base */
 #define B43_PHY_DC_LTBASE		B43_PHY_OFDM(0x3A0)	/* DC lookup table base */
 #define B43_PHY_GAIN_LTBASE		B43_PHY_OFDM(0x3C0)	/* Gain lookup table base */
 
 /* CCK (B) PHY Registers */
-#define B43_PHY_VERSION_CCK		B43_PHY_BASE(0x00)	/* Versioning register for B-PHY */
-#define B43_PHY_CCKBBANDCFG		B43_PHY_BASE(0x01)	/* Contains antenna 0/1 control bit */
-#define B43_PHY_PGACTL			B43_PHY_BASE(0x15)	/* PGA control */
+#define B43_PHY_VERSION_CCK		B43_PHY_CCK(0x00)	/* Versioning register for B-PHY */
+#define B43_PHY_CCKBBANDCFG		B43_PHY_CCK(0x01)	/* Contains antenna 0/1 control bit */
+#define B43_PHY_PGACTL			B43_PHY_CCK(0x15)	/* PGA control */
 #define  B43_PHY_PGACTL_LPF		0x1000	/* Low pass filter (?) */
 #define  B43_PHY_PGACTL_LOWBANDW	0x0040	/* Low bandwidth flag */
 #define  B43_PHY_PGACTL_UNKNOWN		0xEFA0
-#define B43_PHY_FBCTL1			B43_PHY_BASE(0x18)	/* Frequency bandwidth control 1 */
-#define B43_PHY_ITSSI			B43_PHY_BASE(0x29)	/* Idle TSSI */
-#define B43_PHY_LO_LEAKAGE		B43_PHY_BASE(0x2D)	/* Measured LO leakage */
-#define B43_PHY_ENERGY			B43_PHY_BASE(0x33)	/* Energy */
-#define B43_PHY_SYNCCTL			B43_PHY_BASE(0x35)
-#define B43_PHY_FBCTL2			B43_PHY_BASE(0x38)	/* Frequency bandwidth control 2 */
-#define B43_PHY_DACCTL			B43_PHY_BASE(0x60)	/* DAC control */
-#define B43_PHY_RCCALOVER		B43_PHY_BASE(0x78)	/* RC calibration override */
+#define B43_PHY_FBCTL1			B43_PHY_CCK(0x18)	/* Frequency bandwidth control 1 */
+#define B43_PHY_ITSSI			B43_PHY_CCK(0x29)	/* Idle TSSI */
+#define B43_PHY_LO_LEAKAGE		B43_PHY_CCK(0x2D)	/* Measured LO leakage */
+#define B43_PHY_ENERGY			B43_PHY_CCK(0x33)	/* Energy */
+#define B43_PHY_SYNCCTL			B43_PHY_CCK(0x35)
+#define B43_PHY_FBCTL2			B43_PHY_CCK(0x38)	/* Frequency bandwidth control 2 */
+#define B43_PHY_DACCTL			B43_PHY_CCK(0x60)	/* DAC control */
+#define B43_PHY_RCCALOVER		B43_PHY_CCK(0x78)	/* RC calibration override */
 
 /* Extended G-PHY Registers */
 #define B43_PHY_CLASSCTL		B43_PHY_EXTG(0x02)	/* Classify control */
 #define B43_PHY_GTABCTL			B43_PHY_EXTG(0x03)	/* G-PHY table control (see below) */
 #define  B43_PHY_GTABOFF		0x03FF	/* G-PHY table offset (see below) */
 #define  B43_PHY_GTABNR			0xFC00	/* G-PHY table number (see below) */
Index: wireless-2.6/drivers/net/wireless/b43/lo.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/lo.c	2007-12-28 23:36:04.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/lo.c	2008-01-09 18:03:14.000000000 +0100
@@ -552,26 +552,26 @@ struct lo_g_saved_values {
 
 	/* PHY registers */
 	u16 phy_lo_mask;
 	u16 phy_extg_01;
 	u16 phy_dacctl_hwpctl;
 	u16 phy_dacctl;
-	u16 phy_base_14;
+	u16 phy_cck_14;
 	u16 phy_hpwr_tssictl;
 	u16 phy_analogover;
 	u16 phy_analogoverval;
 	u16 phy_rfover;
 	u16 phy_rfoverval;
 	u16 phy_classctl;
-	u16 phy_base_3E;
+	u16 phy_cck_3E;
 	u16 phy_crs0;
 	u16 phy_pgactl;
-	u16 phy_base_2A;
+	u16 phy_cck_2A;
 	u16 phy_syncctl;
-	u16 phy_base_30;
-	u16 phy_base_06;
+	u16 phy_cck_30;
+	u16 phy_cck_06;
 
 	/* Radio registers */
 	u16 radio_43;
 	u16 radio_7A;
 	u16 radio_52;
 };
@@ -585,43 +585,43 @@ static void lo_measure_setup(struct b43_
 	u16 tmp;
 
 	if (b43_has_hardware_pctl(phy)) {
 		sav->phy_lo_mask = b43_phy_read(dev, B43_PHY_LO_MASK);
 		sav->phy_extg_01 = b43_phy_read(dev, B43_PHY_EXTG(0x01));
 		sav->phy_dacctl_hwpctl = b43_phy_read(dev, B43_PHY_DACCTL);
-		sav->phy_base_14 = b43_phy_read(dev, B43_PHY_BASE(0x14));
+		sav->phy_cck_14 = b43_phy_read(dev, B43_PHY_CCK(0x14));
 		sav->phy_hpwr_tssictl = b43_phy_read(dev, B43_PHY_HPWR_TSSICTL);
 
 		b43_phy_write(dev, B43_PHY_HPWR_TSSICTL,
 			      b43_phy_read(dev, B43_PHY_HPWR_TSSICTL)
 			      | 0x100);
 		b43_phy_write(dev, B43_PHY_EXTG(0x01),
 			      b43_phy_read(dev, B43_PHY_EXTG(0x01))
 			      | 0x40);
 		b43_phy_write(dev, B43_PHY_DACCTL,
 			      b43_phy_read(dev, B43_PHY_DACCTL)
 			      | 0x40);
-		b43_phy_write(dev, B43_PHY_BASE(0x14),
-			      b43_phy_read(dev, B43_PHY_BASE(0x14))
+		b43_phy_write(dev, B43_PHY_CCK(0x14),
+			      b43_phy_read(dev, B43_PHY_CCK(0x14))
 			      | 0x200);
 	}
 	if (phy->type == B43_PHYTYPE_B &&
 	    phy->radio_ver == 0x2050 && phy->radio_rev < 6) {
-		b43_phy_write(dev, B43_PHY_BASE(0x16), 0x410);
-		b43_phy_write(dev, B43_PHY_BASE(0x17), 0x820);
+		b43_phy_write(dev, B43_PHY_CCK(0x16), 0x410);
+		b43_phy_write(dev, B43_PHY_CCK(0x17), 0x820);
 	}
 	if (!lo->rebuild && b43_has_hardware_pctl(phy))
 		lo_read_power_vector(dev);
 	if (phy->rev >= 2) {
 		sav->phy_analogover = b43_phy_read(dev, B43_PHY_ANALOGOVER);
 		sav->phy_analogoverval =
 		    b43_phy_read(dev, B43_PHY_ANALOGOVERVAL);
 		sav->phy_rfover = b43_phy_read(dev, B43_PHY_RFOVER);
 		sav->phy_rfoverval = b43_phy_read(dev, B43_PHY_RFOVERVAL);
 		sav->phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);
-		sav->phy_base_3E = b43_phy_read(dev, B43_PHY_BASE(0x3E));
+		sav->phy_cck_3E = b43_phy_read(dev, B43_PHY_CCK(0x3E));
 		sav->phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);
 
 		b43_phy_write(dev, B43_PHY_CLASSCTL,
 			      b43_phy_read(dev, B43_PHY_CLASSCTL)
 			      & 0xFFFC);
 		b43_phy_write(dev, B43_PHY_CRS0, b43_phy_read(dev, B43_PHY_CRS0)
@@ -639,68 +639,68 @@ static void lo_measure_setup(struct b43_
 			} else {
 				b43_phy_write(dev, B43_PHY_RFOVER, 0x133);
 			}
 		} else {
 			b43_phy_write(dev, B43_PHY_RFOVER, 0);
 		}
-		b43_phy_write(dev, B43_PHY_BASE(0x3E), 0);
+		b43_phy_write(dev, B43_PHY_CCK(0x3E), 0);
 	}
 	sav->reg_3F4 = b43_read16(dev, 0x3F4);
 	sav->reg_3E2 = b43_read16(dev, 0x3E2);
 	sav->radio_43 = b43_radio_read16(dev, 0x43);
 	sav->radio_7A = b43_radio_read16(dev, 0x7A);
 	sav->phy_pgactl = b43_phy_read(dev, B43_PHY_PGACTL);
-	sav->phy_base_2A = b43_phy_read(dev, B43_PHY_BASE(0x2A));
+	sav->phy_cck_2A = b43_phy_read(dev, B43_PHY_CCK(0x2A));
 	sav->phy_syncctl = b43_phy_read(dev, B43_PHY_SYNCCTL);
 	sav->phy_dacctl = b43_phy_read(dev, B43_PHY_DACCTL);
 
 	if (!has_tx_magnification(phy)) {
 		sav->radio_52 = b43_radio_read16(dev, 0x52);
 		sav->radio_52 &= 0x00F0;
 	}
 	if (phy->type == B43_PHYTYPE_B) {
-		sav->phy_base_30 = b43_phy_read(dev, B43_PHY_BASE(0x30));
-		sav->phy_base_06 = b43_phy_read(dev, B43_PHY_BASE(0x06));
-		b43_phy_write(dev, B43_PHY_BASE(0x30), 0x00FF);
-		b43_phy_write(dev, B43_PHY_BASE(0x06), 0x3F3F);
+		sav->phy_cck_30 = b43_phy_read(dev, B43_PHY_CCK(0x30));
+		sav->phy_cck_06 = b43_phy_read(dev, B43_PHY_CCK(0x06));
+		b43_phy_write(dev, B43_PHY_CCK(0x30), 0x00FF);
+		b43_phy_write(dev, B43_PHY_CCK(0x06), 0x3F3F);
 	} else {
 		b43_write16(dev, 0x3E2, b43_read16(dev, 0x3E2)
 			    | 0x8000);
 	}
 	b43_write16(dev, 0x3F4, b43_read16(dev, 0x3F4)
 		    & 0xF000);
 
 	tmp =
-	    (phy->type == B43_PHYTYPE_G) ? B43_PHY_LO_MASK : B43_PHY_BASE(0x2E);
+	    (phy->type == B43_PHYTYPE_G) ? B43_PHY_LO_MASK : B43_PHY_CCK(0x2E);
 	b43_phy_write(dev, tmp, 0x007F);
 
 	tmp = sav->phy_syncctl;
 	b43_phy_write(dev, B43_PHY_SYNCCTL, tmp & 0xFF7F);
 	tmp = sav->radio_7A;
 	b43_radio_write16(dev, 0x007A, tmp & 0xFFF0);
 
-	b43_phy_write(dev, B43_PHY_BASE(0x2A), 0x8A3);
+	b43_phy_write(dev, B43_PHY_CCK(0x2A), 0x8A3);
 	if (phy->type == B43_PHYTYPE_G ||
 	    (phy->type == B43_PHYTYPE_B &&
 	     phy->radio_ver == 0x2050 && phy->radio_rev >= 6)) {
-		b43_phy_write(dev, B43_PHY_BASE(0x2B), 0x1003);
+		b43_phy_write(dev, B43_PHY_CCK(0x2B), 0x1003);
 	} else
-		b43_phy_write(dev, B43_PHY_BASE(0x2B), 0x0802);
+		b43_phy_write(dev, B43_PHY_CCK(0x2B), 0x0802);
 	if (phy->rev >= 2)
 		b43_dummy_transmission(dev);
 	b43_radio_selectchannel(dev, 6, 0);
 	b43_radio_read16(dev, 0x51);	/* dummy read */
 	if (phy->type == B43_PHYTYPE_G)
-		b43_phy_write(dev, B43_PHY_BASE(0x2F), 0);
+		b43_phy_write(dev, B43_PHY_CCK(0x2F), 0);
 	if (lo->rebuild)
 		lo_measure_txctl_values(dev);
 	if (phy->type == B43_PHYTYPE_G && phy->rev >= 3) {
 		b43_phy_write(dev, B43_PHY_LO_MASK, 0xC078);
 	} else {
 		if (phy->type == B43_PHYTYPE_B)
-			b43_phy_write(dev, B43_PHY_BASE(0x2E), 0x8078);
+			b43_phy_write(dev, B43_PHY_CCK(0x2E), 0x8078);
 		else
 			b43_phy_write(dev, B43_PHY_LO_MASK, 0x8078);
 	}
 }
 
 static void lo_measure_restore(struct b43_wldev *dev,
@@ -729,54 +729,54 @@ static void lo_measure_restore(struct b4
 			b43_lo_g_adjust_to(dev, 3, 2, 0);
 		else
 			b43_lo_g_adjust(dev);
 	}
 	if (phy->type == B43_PHYTYPE_G) {
 		if (phy->rev >= 3)
-			b43_phy_write(dev, B43_PHY_BASE(0x2E), 0xC078);
+			b43_phy_write(dev, B43_PHY_CCK(0x2E), 0xC078);
 		else
-			b43_phy_write(dev, B43_PHY_BASE(0x2E), 0x8078);
+			b43_phy_write(dev, B43_PHY_CCK(0x2E), 0x8078);
 		if (phy->rev >= 2)
-			b43_phy_write(dev, B43_PHY_BASE(0x2F), 0x0202);
+			b43_phy_write(dev, B43_PHY_CCK(0x2F), 0x0202);
 		else
-			b43_phy_write(dev, B43_PHY_BASE(0x2F), 0x0101);
+			b43_phy_write(dev, B43_PHY_CCK(0x2F), 0x0101);
 	}
 	b43_write16(dev, 0x3F4, sav->reg_3F4);
 	b43_phy_write(dev, B43_PHY_PGACTL, sav->phy_pgactl);
-	b43_phy_write(dev, B43_PHY_BASE(0x2A), sav->phy_base_2A);
+	b43_phy_write(dev, B43_PHY_CCK(0x2A), sav->phy_cck_2A);
 	b43_phy_write(dev, B43_PHY_SYNCCTL, sav->phy_syncctl);
 	b43_phy_write(dev, B43_PHY_DACCTL, sav->phy_dacctl);
 	b43_radio_write16(dev, 0x43, sav->radio_43);
 	b43_radio_write16(dev, 0x7A, sav->radio_7A);
 	if (!has_tx_magnification(phy)) {
 		tmp = sav->radio_52;
 		b43_radio_write16(dev, 0x52, (b43_radio_read16(dev, 0x52)
 					      & 0xFF0F) | tmp);
 	}
 	b43_write16(dev, 0x3E2, sav->reg_3E2);
 	if (phy->type == B43_PHYTYPE_B &&
 	    phy->radio_ver == 0x2050 && phy->radio_rev <= 5) {
-		b43_phy_write(dev, B43_PHY_BASE(0x30), sav->phy_base_30);
-		b43_phy_write(dev, B43_PHY_BASE(0x06), sav->phy_base_06);
+		b43_phy_write(dev, B43_PHY_CCK(0x30), sav->phy_cck_30);
+		b43_phy_write(dev, B43_PHY_CCK(0x06), sav->phy_cck_06);
 	}
 	if (phy->rev >= 2) {
 		b43_phy_write(dev, B43_PHY_ANALOGOVER, sav->phy_analogover);
 		b43_phy_write(dev, B43_PHY_ANALOGOVERVAL,
 			      sav->phy_analogoverval);
 		b43_phy_write(dev, B43_PHY_CLASSCTL, sav->phy_classctl);
 		b43_phy_write(dev, B43_PHY_RFOVER, sav->phy_rfover);
 		b43_phy_write(dev, B43_PHY_RFOVERVAL, sav->phy_rfoverval);
-		b43_phy_write(dev, B43_PHY_BASE(0x3E), sav->phy_base_3E);
+		b43_phy_write(dev, B43_PHY_CCK(0x3E), sav->phy_cck_3E);
 		b43_phy_write(dev, B43_PHY_CRS0, sav->phy_crs0);
 	}
 	if (b43_has_hardware_pctl(phy)) {
 		tmp = (sav->phy_lo_mask & 0xBFFF);
 		b43_phy_write(dev, B43_PHY_LO_MASK, tmp);
 		b43_phy_write(dev, B43_PHY_EXTG(0x01), sav->phy_extg_01);
 		b43_phy_write(dev, B43_PHY_DACCTL, sav->phy_dacctl_hwpctl);
-		b43_phy_write(dev, B43_PHY_BASE(0x14), sav->phy_base_14);
+		b43_phy_write(dev, B43_PHY_CCK(0x14), sav->phy_cck_14);
 		b43_phy_write(dev, B43_PHY_HPWR_TSSICTL, sav->phy_hpwr_tssictl);
 	}
 	b43_radio_selectchannel(dev, sav->old_channel, 1);
 }
 
 struct b43_lo_g_statemachine {


From mb at bu3sch.de  Wed Jan  9 19:08:49 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 9 Jan 2008 19:08:49 +0100
Subject: [PATCH] b43: Remove the PHY spinlock
Message-ID: <200801091908.49491.mb@bu3sch.de>

This fixes a sparse warning about weird locking.
The spinlock is not needed, so simply remove it.
This also adds some sanity checks to the PHY and radio locking
to protect against recursive locking.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.25


Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h	2008-01-09 17:06:34.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/b43.h	2008-01-09 18:56:51.000000000 +0100
@@ -477,13 +477,12 @@ struct b43_phy {
 
 	/* Radio versioning */
 	u16 radio_manuf;	/* Radio manufacturer */
 	u16 radio_ver;		/* Radio version */
 	u8 radio_rev;		/* Radio revision */
 
-	bool locked;		/* Only used in b43_phy_{un}lock() */
 	bool dyn_tssi_tbl;	/* tssi2dbm is kmalloc()ed. */
 
 	/* ACI (adjacent channel interference) flags. */
 	bool aci_enable;
 	bool aci_wlan_automatic;
 	bool aci_hw_rssi;
@@ -514,30 +513,23 @@ struct b43_phy {
 	s16 max_lb_gain;	/* Maximum Loopback gain in hdB */
 	s16 trsw_rx_gain;	/* TRSW RX gain in hdB */
 	s16 lna_lod_gain;	/* LNA lod */
 	s16 lna_gain;		/* LNA */
 	s16 pga_gain;		/* PGA */
 
-	/* PHY lock for core.rev < 3
-	 * This lock is only used by b43_phy_{un}lock()
-	 */
-	spinlock_t lock;
-
 	/* Desired TX power level (in dBm).
 	 * This is set by the user and adjusted in b43_phy_xmitpower(). */
 	u8 power_level;
 	/* A-PHY TX Power control value. */
 	u16 txpwr_offset;
 
 	/* Current TX power level attenuation control values */
 	struct b43_bbatt bbatt;
 	struct b43_rfatt rfatt;
 	u8 tx_control;		/* B43_TXCTL_XXX */
-#ifdef CONFIG_B43_DEBUG
-	bool manual_txpower_control;	/* Manual TX-power control enabled? */
-#endif
+
 	/* Hardware Power Control enabled? */
 	bool hardware_power_control;
 
 	/* Current Interference Mitigation mode */
 	int interfmode;
 	/* Stack of saved values from the Interference Mitigation code.
@@ -572,12 +564,19 @@ struct b43_phy {
 	u16 ofdmtab_addr; /* The address currently set in hardware. */
 	enum { /* The last data flow direction. */
 		B43_OFDMTAB_DIRECTION_UNKNOWN = 0,
 		B43_OFDMTAB_DIRECTION_READ,
 		B43_OFDMTAB_DIRECTION_WRITE,
 	} ofdmtab_addr_direction;
+
+#if B43_DEBUG
+	/* Manual TX-power control enabled? */
+	bool manual_txpower_control;
+	/* PHY registers locked by b43_phy_lock()? */
+	bool phy_locked;
+#endif /* B43_DEBUG */
 };
 
 /* Data structures for DMA transmission, per 80211 core. */
 struct b43_dma {
 	struct b43_dmaring *tx_ring0;
 	struct b43_dmaring *tx_ring1;
Index: wireless-2.6/drivers/net/wireless/b43/debugfs.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/debugfs.c	2008-01-09 16:59:33.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/debugfs.c	2008-01-09 18:58:43.000000000 +0100
@@ -219,14 +219,12 @@ out:
 	return count;
 }
 
 static int txpower_g_write_file(struct b43_wldev *dev,
 				const char *buf, size_t count)
 {
-	unsigned long phy_flags;
-
 	if (dev->phy.type != B43_PHYTYPE_G)
 		return -ENODEV;
 	if ((count >= 4) && (memcmp(buf, "auto", 4) == 0)) {
 		/* Automatic control */
 		dev->phy.manual_txpower_control = 0;
 		b43_phy_xmitpower(dev);
@@ -244,18 +242,18 @@ static int txpower_g_write_file(struct b
 		if (txmix)
 			dev->phy.tx_control |= B43_TXCTL_TXMIX;
 		if (pa2db)
 			dev->phy.tx_control |= B43_TXCTL_PA2DB;
 		if (pa3db)
 			dev->phy.tx_control |= B43_TXCTL_PA3DB;
-		b43_phy_lock(dev, phy_flags);
+		b43_phy_lock(dev);
 		b43_radio_lock(dev);
 		b43_set_txpower_g(dev, &dev->phy.bbatt,
 				  &dev->phy.rfatt, dev->phy.tx_control);
 		b43_radio_unlock(dev);
-		b43_phy_unlock(dev, phy_flags);
+		b43_phy_unlock(dev);
 	}
 
 	return 0;
 }
 
 /* wl->irq_lock is locked */
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-09 17:06:34.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-09 18:59:36.000000000 +0100
@@ -3199,15 +3199,12 @@ static void setup_struct_phy_for_init(st
 	struct b43_txpower_lo_control *lo;
 	int i;
 
 	memset(phy->minlowsig, 0xFF, sizeof(phy->minlowsig));
 	memset(phy->minlowsigpos, 0, sizeof(phy->minlowsigpos));
 
-	/* Flags */
-	phy->locked = 0;
-
 	phy->aci_enable = 0;
 	phy->aci_wlan_automatic = 0;
 	phy->aci_hw_rssi = 0;
 
 	phy->radio_off_context.valid = 0;
 
@@ -3228,13 +3225,12 @@ static void setup_struct_phy_for_init(st
 	for (i = 0; i < ARRAY_SIZE(phy->nrssi_lt); i++)
 		phy->nrssi_lt[i] = i;
 
 	phy->lofcal = 0xFFFF;
 	phy->initval = 0xFFFF;
 
-	spin_lock_init(&phy->lock);
 	phy->interfmode = B43_INTERFMODE_NONE;
 	phy->channel = 0xFF;
 
 	phy->hardware_power_control = !!modparam_hwpctl;
 
 	/* PHY TX errors counter. */
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c	2008-01-09 18:30:13.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/phy.c	2008-01-09 19:02:54.000000000 +0100
@@ -225,48 +225,36 @@ static void b43_shm_clear_tssi(struct b4
 		b43_shm_write16(dev, B43_SHM_SHARED, 0x0070, 0x7F7F);
 		b43_shm_write16(dev, B43_SHM_SHARED, 0x0072, 0x7F7F);
 		break;
 	}
 }
 
-void b43_raw_phy_lock(struct b43_wldev *dev)
+/* Lock the PHY registers against concurrent access from the microcode.
+ * This lock is nonrecursive. */
+void b43_phy_lock(struct b43_wldev *dev)
 {
-	struct b43_phy *phy = &dev->phy;
-
-	B43_WARN_ON(!irqs_disabled());
-
-	/* We had a check for MACCTL==0 here, but I think that doesn't
-	 * make sense, as MACCTL is never 0 when this is called.
-	 *      --mb */
-	B43_WARN_ON(b43_read32(dev, B43_MMIO_MACCTL) == 0);
+#if B43_DEBUG
+	B43_WARN_ON(dev->phy.phy_locked);
+	dev->phy.phy_locked = 1;
+#endif
+	B43_WARN_ON(dev->dev->id.revision < 3);
 
-	if (dev->dev->id.revision < 3) {
-		b43_mac_suspend(dev);
-		spin_lock(&phy->lock);
-	} else {
-		if (!b43_is_mode(dev->wl, IEEE80211_IF_TYPE_AP))
-			b43_power_saving_ctl_bits(dev, B43_PS_AWAKE);
-	}
-	phy->locked = 1;
+	if (!b43_is_mode(dev->wl, IEEE80211_IF_TYPE_AP))
+		b43_power_saving_ctl_bits(dev, B43_PS_AWAKE);
 }
 
-void b43_raw_phy_unlock(struct b43_wldev *dev)
+void b43_phy_unlock(struct b43_wldev *dev)
 {
-	struct b43_phy *phy = &dev->phy;
+#if B43_DEBUG
+	B43_WARN_ON(!dev->phy.phy_locked);
+	dev->phy.phy_locked = 0;
+#endif
+	B43_WARN_ON(dev->dev->id.revision < 3);
 
-	B43_WARN_ON(!irqs_disabled());
-	if (dev->dev->id.revision < 3) {
-		if (phy->locked) {
-			spin_unlock(&phy->lock);
-			b43_mac_enable(dev);
-		}
-	} else {
-		if (!b43_is_mode(dev->wl, IEEE80211_IF_TYPE_AP))
-			b43_power_saving_ctl_bits(dev, 0);
-	}
-	phy->locked = 0;
+	if (!b43_is_mode(dev->wl, IEEE80211_IF_TYPE_AP))
+		b43_power_saving_ctl_bits(dev, 0);
 }
 
 /* Different PHYs require different register routing flags.
  * This adjusts (and does sanity checks on) the routing flags.
  */
 static inline u16 adjust_phyreg_for_phytype(struct b43_phy *phy,
@@ -1727,13 +1715,12 @@ void b43_phy_xmitpower(struct b43_wldev 
 			s8 average;
 			int max_pwr;
 			int desired_pwr, estimated_pwr, pwr_adjust;
 			int rfatt_delta, bbatt_delta;
 			int rfatt, bbatt;
 			u8 tx_control;
-			unsigned long phylock_flags;
 
 			tmp = b43_shm_read16(dev, B43_SHM_SHARED, 0x0058);
 			v0 = (s8) (tmp & 0x00FF);
 			v1 = (s8) ((tmp & 0xFF00) >> 8);
 			tmp = b43_shm_read16(dev, B43_SHM_SHARED, 0x005A);
 			v2 = (s8) (tmp & 0x00FF);
@@ -1858,19 +1845,19 @@ void b43_phy_xmitpower(struct b43_wldev 
 			phy->tx_control = tx_control;
 			b43_put_attenuation_into_ranges(dev, &bbatt, &rfatt);
 			phy->rfatt.att = rfatt;
 			phy->bbatt.att = bbatt;
 
 			/* Adjust the hardware */
-			b43_phy_lock(dev, phylock_flags);
+			b43_phy_lock(dev);
 			b43_radio_lock(dev);
 			b43_set_txpower_g(dev, &phy->bbatt, &phy->rfatt,
 					  phy->tx_control);
 			b43_lo_g_ctl_mark_cur_used(dev);
 			b43_radio_unlock(dev);
-			b43_phy_unlock(dev, phylock_flags);
+			b43_phy_unlock(dev);
 			break;
 		}
 	default:
 		B43_WARN_ON(1);
 	}
 }
@@ -2155,12 +2142,13 @@ static inline u16 channel2freq_a(u8 chan
 
 void b43_radio_lock(struct b43_wldev *dev)
 {
 	u32 macctl;
 
 	macctl = b43_read32(dev, B43_MMIO_MACCTL);
+	B43_WARN_ON(macctl & B43_MACCTL_RADIOLOCK);
 	macctl |= B43_MACCTL_RADIOLOCK;
 	b43_write32(dev, B43_MMIO_MACCTL, macctl);
 	/* Commit the write and wait for the device
 	 * to exit any radio register access. */
 	b43_read32(dev, B43_MMIO_MACCTL);
 	udelay(10);
@@ -2171,12 +2159,13 @@ void b43_radio_unlock(struct b43_wldev *
 	u32 macctl;
 
 	/* Commit any write */
 	b43_read16(dev, B43_MMIO_PHY_VER);
 	/* unlock */
 	macctl = b43_read32(dev, B43_MMIO_MACCTL);
+	B43_WARN_ON(!(macctl & B43_MACCTL_RADIOLOCK));
 	macctl &= ~B43_MACCTL_RADIOLOCK;
 	b43_write32(dev, B43_MMIO_MACCTL, macctl);
 }
 
 u16 b43_radio_read16(struct b43_wldev *dev, u16 offset)
 {
@@ -2352,18 +2341,17 @@ u8 b43_radio_aci_detect(struct b43_wldev
 u8 b43_radio_aci_scan(struct b43_wldev * dev)
 {
 	struct b43_phy *phy = &dev->phy;
 	u8 ret[13];
 	unsigned int channel = phy->channel;
 	unsigned int i, j, start, end;
-	unsigned long phylock_flags;
 
 	if (!((phy->type == B43_PHYTYPE_G) && (phy->rev > 0)))
 		return 0;
 
-	b43_phy_lock(dev, phylock_flags);
+	b43_phy_lock(dev);
 	b43_radio_lock(dev);
 	b43_phy_write(dev, 0x0802, b43_phy_read(dev, 0x0802) & 0xFFFC);
 	b43_phy_write(dev, B43_PHY_G_CRS,
 		      b43_phy_read(dev, B43_PHY_G_CRS) & 0x7FFF);
 	b43_set_all_gains(dev, 3, 8, 1);
 
@@ -2386,13 +2374,13 @@ u8 b43_radio_aci_scan(struct b43_wldev *
 			continue;
 		end = (i + 5 < 13) ? i + 5 : 13;
 		for (j = i; j < end; j++)
 			ret[j] = 1;
 	}
 	b43_radio_unlock(dev);
-	b43_phy_unlock(dev, phylock_flags);
+	b43_phy_unlock(dev);
 
 	return ret[channel - 1];
 }
 
 /* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
 void b43_nrssi_hw_write(struct b43_wldev *dev, u16 offset, s16 val)
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h	2008-01-09 17:59:17.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/phy.h	2008-01-09 18:48:42.000000000 +0100
@@ -196,24 +196,14 @@ enum {
 #define B43_PHYVER_ANALOG		0xF000
 #define B43_PHYVER_ANALOG_SHIFT		12
 #define B43_PHYVER_TYPE			0x0F00
 #define B43_PHYVER_TYPE_SHIFT		8
 #define B43_PHYVER_VERSION		0x00FF
 
-void b43_raw_phy_lock(struct b43_wldev *dev);
-#define b43_phy_lock(dev, flags) \
-	do {					\
-		local_irq_save(flags);		\
-		b43_raw_phy_lock(dev);	\
-	} while (0)
-void b43_raw_phy_unlock(struct b43_wldev *dev);
-#define b43_phy_unlock(dev, flags) \
-	do {					\
-		b43_raw_phy_unlock(dev);	\
-		local_irq_restore(flags);	\
-	} while (0)
+void b43_phy_lock(struct b43_wldev *dev);
+void b43_phy_unlock(struct b43_wldev *dev);
 
 u16 b43_phy_read(struct b43_wldev *dev, u16 offset);
 void b43_phy_write(struct b43_wldev *dev, u16 offset, u16 val);
 
 int b43_phy_init_tssi2dbm_table(struct b43_wldev *dev);
 


From mb at bu3sch.de  Wed Jan  9 20:15:31 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 9 Jan 2008 20:15:31 +0100
Subject: [PATCH RFT] b43legacy: Remove the PHY spinlock
Message-ID: <200801092015.32042.mb@bu3sch.de>

This fixes a sparse warning about weird locking.
The spinlock is not needed, so simply remove it.
This also adds some sanity checks to the PHY and radio locking
to protect against recursive locking.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

This patch is only compiletime tested.


Index: wireless-2.6/drivers/net/wireless/b43legacy/b43legacy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/b43legacy.h	2007-12-20 18:53:57.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43legacy/b43legacy.h	2008-01-09 19:56:43.000000000 +0100
@@ -412,13 +412,12 @@ struct b43legacy_phy {
 	/* Radio versioning */
 	u16 radio_manuf;	/* Radio manufacturer */
 	u16 radio_ver;		/* Radio version */
 	u8 calibrated:1;
 	u8 radio_rev;		/* Radio revision */
 
-	bool locked;		/* Only used in b43legacy_phy_{un}lock() */
 	bool dyn_tssi_tbl;	/* tssi2dbm is kmalloc()ed. */
 
 	/* ACI (adjacent channel interference) flags. */
 	bool aci_enable;
 	bool aci_wlan_automatic;
 	bool aci_hw_rssi;
@@ -455,17 +454,12 @@ struct b43legacy_phy {
 	s16 max_lb_gain;	/* Maximum Loopback gain in hdB */
 	s16 trsw_rx_gain;	/* TRSW RX gain in hdB */
 	s16 lna_lod_gain;	/* LNA lod */
 	s16 lna_gain;		/* LNA */
 	s16 pga_gain;		/* PGA */
 
-	/* PHY lock for core.rev < 3
-	 * This lock is only used by b43legacy_phy_{un}lock()
-	 */
-	spinlock_t lock;
-
 	/* Desired TX power level (in dBm). This is set by the user and
 	 * adjusted in b43legacy_phy_xmitpower(). */
 	u8 power_level;
 
 	/* Values from b43legacy_calc_loopback_gain() */
 	u16 loopback_gain[2];
@@ -483,15 +477,12 @@ struct b43legacy_phy {
 	};
 	/* A PHY */
 	struct {
 		u16 txpwr_offset;
 	};
 
-#ifdef CONFIG_B43LEGACY_DEBUG
-	bool manual_txpower_control; /* Manual TX-power control enabled? */
-#endif
 	/* Current Interference Mitigation mode */
 	int interfmode;
 	/* Stack of saved values from the Interference Mitigation code.
 	 * Each value in the stack is layed out as follows:
 	 * bit 0-11:  offset
 	 * bit 12-15: register ID
@@ -513,12 +504,19 @@ struct b43legacy_phy {
 	u16 lofcal;
 
 	u16 initval;
 
 	/* PHY TX errors counter. */
 	atomic_t txerr_cnt;
+
+#if B43legacy_DEBUG
+	/* Manual TX-power control enabled? */
+	bool manual_txpower_control;
+	/* PHY registers locked by b43legacy_phy_lock()? */
+	bool phy_locked;
+#endif /* B43legacy_DEBUG */
 };
 
 /* Data structures for DMA transmission, per 80211 core. */
 struct b43legacy_dma {
 	struct b43legacy_dmaring *tx_ring0;
 	struct b43legacy_dmaring *tx_ring1;
Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c	2008-01-09 16:59:33.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c	2008-01-09 20:03:16.000000000 +0100
@@ -2844,14 +2844,12 @@ static void setup_struct_phy_for_init(st
 	struct b43legacy_lopair *lo;
 	int i;
 
 	memset(phy->minlowsig, 0xFF, sizeof(phy->minlowsig));
 	memset(phy->minlowsigpos, 0, sizeof(phy->minlowsigpos));
 
-	/* Flags */
-	phy->locked = 0;
 	/* Assume the radio is enabled. If it's not enabled, the state will
 	 * immediately get fixed on the first periodic work run. */
 	dev->radio_hw_enable = 1;
 
 	phy->savedpctlreg = 0xFFFF;
 	phy->aci_enable = 0;
@@ -2878,13 +2876,12 @@ static void setup_struct_phy_for_init(st
 	for (i = 0; i < ARRAY_SIZE(phy->nrssi_lt); i++)
 		phy->nrssi_lt[i] = i;
 
 	phy->lofcal = 0xFFFF;
 	phy->initval = 0xFFFF;
 
-	spin_lock_init(&phy->lock);
 	phy->interfmode = B43legacy_INTERFMODE_NONE;
 	phy->channel = 0xFF;
 }
 
 static void setup_struct_wldev_for_init(struct b43legacy_wldev *dev)
 {
@@ -3010,13 +3007,12 @@ static void prepare_phy_data_for_init(st
 	phy->antenna_diversity = 0xFFFF;
 	memset(phy->minlowsig, 0xFF, sizeof(phy->minlowsig));
 	memset(phy->minlowsigpos, 0, sizeof(phy->minlowsigpos));
 
 	/* Flags */
 	phy->calibrated = 0;
-	phy->locked = 0;
 
 	if (phy->_lo_pairs)
 		memset(phy->_lo_pairs, 0,
 		       sizeof(struct b43legacy_lopair) * B43legacy_LO_COUNT);
 	memset(phy->loopback_gain, 0, sizeof(phy->loopback_gain));
 }
Index: wireless-2.6/drivers/net/wireless/b43legacy/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/phy.c	2008-01-09 16:59:33.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43legacy/phy.c	2008-01-09 20:12:58.000000000 +0100
@@ -88,46 +88,42 @@ void b43legacy_voluntary_preempt(void)
 			  !in_interrupt() && !irqs_disabled()));
 #ifndef CONFIG_PREEMPT
 	cond_resched();
 #endif /* CONFIG_PREEMPT */
 }
 
-void b43legacy_raw_phy_lock(struct b43legacy_wldev *dev)
-{
-	struct b43legacy_phy *phy = &dev->phy;
+/* Lock the PHY registers against concurrent access from the microcode.
+ * This lock is nonrecursive. */
+void b43legacy_phy_lock(struct b43legacy_wldev *dev)
+{
+#if B43legacy_DEBUG
+	B43legacy_WARN_ON(dev->phy.phy_locked);
+	dev->phy.phy_locked = 1;
+#endif
 
-	B43legacy_WARN_ON(!irqs_disabled());
-	if (b43legacy_read32(dev, B43legacy_MMIO_STATUS_BITFIELD) == 0) {
-		phy->locked = 0;
-		return;
-	}
 	if (dev->dev->id.revision < 3) {
 		b43legacy_mac_suspend(dev);
-		spin_lock(&phy->lock);
 	} else {
 		if (!b43legacy_is_mode(dev->wl, IEEE80211_IF_TYPE_AP))
 			b43legacy_power_saving_ctl_bits(dev, -1, 1);
 	}
-	phy->locked = 1;
 }
 
-void b43legacy_raw_phy_unlock(struct b43legacy_wldev *dev)
+void b43legacy_phy_unlock(struct b43legacy_wldev *dev)
 {
-	struct b43legacy_phy *phy = &dev->phy;
+#if B43legacy_DEBUG
+	B43legacy_WARN_ON(!dev->phy.phy_locked);
+	dev->phy.phy_locked = 0;
+#endif
 
-	B43legacy_WARN_ON(!irqs_disabled());
 	if (dev->dev->id.revision < 3) {
-		if (phy->locked) {
-			spin_unlock(&phy->lock);
-			b43legacy_mac_enable(dev);
-		}
+		b43legacy_mac_enable(dev);
 	} else {
 		if (!b43legacy_is_mode(dev->wl, IEEE80211_IF_TYPE_AP))
 			b43legacy_power_saving_ctl_bits(dev, -1, -1);
 	}
-	phy->locked = 0;
 }
 
 u16 b43legacy_phy_read(struct b43legacy_wldev *dev, u16 offset)
 {
 	b43legacy_write16(dev, B43legacy_MMIO_PHY_CONTROL, offset);
 	return b43legacy_read16(dev, B43legacy_MMIO_PHY_DATA);
@@ -1786,13 +1782,12 @@ void b43legacy_phy_xmitpower(struct b43l
 	s16 estimated_pwr;
 	s16 pwr_adjust;
 	s16 radio_att_delta;
 	s16 baseband_att_delta;
 	s16 radio_attenuation;
 	s16 baseband_attenuation;
-	unsigned long phylock_flags;
 
 	if (phy->savedpctlreg == 0xFFFF)
 		return;
 	if ((dev->dev->bus->boardinfo.type == 0x0416) &&
 	    is_bcm_board_vendor(dev))
 		return;
@@ -1941,19 +1936,19 @@ void b43legacy_phy_xmitpower(struct b43l
 	baseband_attenuation = limit_value(baseband_attenuation, 0, 11);
 	radio_attenuation = limit_value(radio_attenuation, 0, 9);
 	phy->rfatt = radio_attenuation;
 	phy->bbatt = baseband_attenuation;
 
 	/* Adjust the hardware */
-	b43legacy_phy_lock(dev, phylock_flags);
+	b43legacy_phy_lock(dev);
 	b43legacy_radio_lock(dev);
 	b43legacy_radio_set_txpower_bg(dev, baseband_attenuation,
 				       radio_attenuation, txpower);
 	b43legacy_phy_lo_mark_current_used(dev);
 	b43legacy_radio_unlock(dev);
-	b43legacy_phy_unlock(dev, phylock_flags);
+	b43legacy_phy_unlock(dev);
 }
 
 static inline
 s32 b43legacy_tssi2dbm_ad(s32 num, s32 den)
 {
 	if (num < 0)
Index: wireless-2.6/drivers/net/wireless/b43legacy/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/phy.h	2007-12-11 01:08:40.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43legacy/phy.h	2008-01-09 19:57:56.000000000 +0100
@@ -168,24 +168,14 @@ void b43legacy_put_attenuation_into_rang
 #define B43legacy_PHYVER_TYPE		0x0F00
 #define B43legacy_PHYVER_TYPE_SHIFT	8
 #define B43legacy_PHYVER_VERSION	0x00FF
 
 struct b43legacy_wldev;
 
-void b43legacy_raw_phy_lock(struct b43legacy_wldev *dev);
-#define b43legacy_phy_lock(bcm, flags) 		\
-	do {					\
-		local_irq_save(flags);		\
-		b43legacy_raw_phy_lock(bcm);	\
-	} while (0)
-void b43legacy_raw_phy_unlock(struct b43legacy_wldev *dev);
-#define b43legacy_phy_unlock(bcm, flags)	\
-	do {					\
-		b43legacy_raw_phy_unlock(bcm);	\
-		local_irq_restore(flags);	\
-	} while (0)
+void b43legacy_phy_lock(struct b43legacy_wldev *dev);
+void b43legacy_phy_unlock(struct b43legacy_wldev *dev);
 
 /* Card uses the loopback gain stuff */
 #define has_loopback_gain(phy)			 \
 	(((phy)->rev > 1) || ((phy)->gmode))
 
 u16 b43legacy_phy_read(struct b43legacy_wldev *dev, u16 offset);
Index: wireless-2.6/drivers/net/wireless/b43legacy/radio.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/radio.c	2007-12-11 01:08:40.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43legacy/radio.c	2008-01-09 20:11:46.000000000 +0100
@@ -89,24 +89,26 @@ u16 channel2freq_bg(u8 channel)
 
 void b43legacy_radio_lock(struct b43legacy_wldev *dev)
 {
 	u32 status;
 
 	status = b43legacy_read32(dev, B43legacy_MMIO_STATUS_BITFIELD);
+	B43legacy_WARN_ON(status & B43legacy_SBF_RADIOREG_LOCK);
 	status |= B43legacy_SBF_RADIOREG_LOCK;
 	b43legacy_write32(dev, B43legacy_MMIO_STATUS_BITFIELD, status);
 	mmiowb();
 	udelay(10);
 }
 
 void b43legacy_radio_unlock(struct b43legacy_wldev *dev)
 {
 	u32 status;
 
 	b43legacy_read16(dev, B43legacy_MMIO_PHY_VER); /* dummy read */
 	status = b43legacy_read32(dev, B43legacy_MMIO_STATUS_BITFIELD);
+	B43legacy_WARN_ON(!(status & B43legacy_SBF_RADIOREG_LOCK));
 	status &= ~B43legacy_SBF_RADIOREG_LOCK;
 	b43legacy_write32(dev, B43legacy_MMIO_STATUS_BITFIELD, status);
 	mmiowb();
 }
 
 u16 b43legacy_radio_read16(struct b43legacy_wldev *dev, u16 offset)
@@ -281,18 +283,17 @@ u8 b43legacy_radio_aci_scan(struct b43le
 	u8 ret[13];
 	unsigned int channel = phy->channel;
 	unsigned int i;
 	unsigned int j;
 	unsigned int start;
 	unsigned int end;
-	unsigned long phylock_flags;
 
 	if (!((phy->type == B43legacy_PHYTYPE_G) && (phy->rev > 0)))
 		return 0;
 
-	b43legacy_phy_lock(dev, phylock_flags);
+	b43legacy_phy_lock(dev);
 	b43legacy_radio_lock(dev);
 	b43legacy_phy_write(dev, 0x0802,
 			    b43legacy_phy_read(dev, 0x0802) & 0xFFFC);
 	b43legacy_phy_write(dev, B43legacy_PHY_G_CRS,
 			    b43legacy_phy_read(dev, B43legacy_PHY_G_CRS)
 			    & 0x7FFF);
@@ -320,13 +321,13 @@ u8 b43legacy_radio_aci_scan(struct b43le
 			continue;
 		end = (i + 5 < 13) ? i + 5 : 13;
 		for (j = i; j < end; j++)
 			ret[j] = 1;
 	}
 	b43legacy_radio_unlock(dev);
-	b43legacy_phy_unlock(dev, phylock_flags);
+	b43legacy_phy_unlock(dev);
 
 	return ret[channel - 1];
 }
 
 /* http://bcm-specs.sipsolutions.net/NRSSILookupTable */
 void b43legacy_nrssi_hw_write(struct b43legacy_wldev *dev, u16 offset, s16 val)


From larry.finger at lwfinger.net  Thu Jan 10 02:03:45 2008
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 09 Jan 2008 18:03:45 -0700
Subject: [PATCH RFT] b43legacy: Remove the PHY spinlock
In-Reply-To: <200801092015.32042.mb@bu3sch.de>
References: <200801092015.32042.mb@bu3sch.de>
Message-ID: <47856EF1.9060502@lwfinger.net>

Michael Buesch wrote:
> This fixes a sparse warning about weird locking.
> The spinlock is not needed, so simply remove it.
> This also adds some sanity checks to the PHY and radio locking
> to protect against recursive locking.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>
> 
> ---
> 
> This patch is only compiletime tested.

The patch seems to work here on my BCM4306/2. I'll give it more testing; however, no problems yet.

Larry


From johannes at sipsolutions.net  Wed Jan  9 18:58:12 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 09 Jan 2008 18:58:12 +0100
Subject: [PATCH] b43: Remove PIO support
In-Reply-To: <200712261441.30437.mb@bu3sch.de>
	(sfid-20071226_134936_351777_3A34487A)
References: <200712261441.30437.mb@bu3sch.de>
	(sfid-20071226_134936_351777_3A34487A)
Message-ID: <1199901493.6762.32.camel@johannes.berg>

John,

On Wed, 2007-12-26 at 14:41 +0100, Michael Buesch wrote:
> Remove b43 PIO support.
> DMA works well on all supported devices. There's no reason to use PIO.
> Additionally, new devices don't support PIO in hardware anymore.
> b43 PIO support is dead and unused code.

You merged this patch, but

> After applying this patch please do
> git rm drivers/net/wireless/b43/pio.h
> git rm drivers/net/wireless/b43/pio.c
> to remove the main PIO support code.

forgot this.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20080109/deb8f209/attachment.pgp>

From linville at tuxdriver.com  Thu Jan 10 16:20:49 2008
From: linville at tuxdriver.com (John W. Linville)
Date: Thu, 10 Jan 2008 10:20:49 -0500
Subject: [PATCH] b43: Remove PIO support
In-Reply-To: <1199901493.6762.32.camel@johannes.berg>
References: <200712261441.30437.mb@bu3sch.de>
	<1199901493.6762.32.camel@johannes.berg>
Message-ID: <20080110152049.GA3109@tuxdriver.com>

On Wed, Jan 09, 2008 at 06:58:12PM +0100, Johannes Berg wrote:
> John,
> 
> On Wed, 2007-12-26 at 14:41 +0100, Michael Buesch wrote:
> > Remove b43 PIO support.
> > DMA works well on all supported devices. There's no reason to use PIO.
> > Additionally, new devices don't support PIO in hardware anymore.
> > b43 PIO support is dead and unused code.
> 
> You merged this patch, but
> 
> > After applying this patch please do
> > git rm drivers/net/wireless/b43/pio.h
> > git rm drivers/net/wireless/b43/pio.c
> > to remove the main PIO support code.
> 
> forgot this.

You're right -- thanks for the reminder!

-- 
John W. Linville
linville at tuxdriver.com


From cebbert at redhat.com  Thu Jan 10 18:50:54 2008
From: cebbert at redhat.com (Chuck Ebbert)
Date: Thu, 10 Jan 2008 12:50:54 -0500
Subject: BCM4311 Rev D still doesn't work
Message-ID: <47865AFE.7000505@redhat.com>

Using Fedora 8 kernel 2.6.23.13-104 which was just updated
yesterday with 2.6.25-bound patches, the adapter still drops
every packet sent to it.

wlan0: authenticate with AP ZZZZZZZZZZZZZZZ
wlan0: RX authentication from ZZZZZZZZZZZZZZZZ (alg=0 transaction=2 status=0)
wlan0: authenticated
wlan0: associate with AP ZZZZZZZZZZZZZZZ
wlan0: RX ReassocResp from ZZZZZZZZZZZZZZZZZ (capab=0x431 status=0 aid=178)
wlan0: associated
wlan0: CTS protection enabled (BSSID=ZZZZZZZZZZZZZZZZZZ)
b43-phy0 debug: RX: Packet dropped
b43-phy0 debug: RX: Packet dropped
b43-phy0 debug: RX: Packet dropped
b43-phy0 debug: RX: Packet dropped

Lots of the above, then NetworkManager gives up...



From mb at bu3sch.de  Thu Jan 10 20:08:01 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 10 Jan 2008 20:08:01 +0100
Subject: BCM4311 Rev D still doesn't work
In-Reply-To: <47865AFE.7000505@redhat.com>
References: <47865AFE.7000505@redhat.com>
Message-ID: <200801102008.01277.mb@bu3sch.de>

On Thursday 10 January 2008 18:50:54 Chuck Ebbert wrote:
> Using Fedora 8 kernel 2.6.23.13-104 which was just updated
> yesterday with 2.6.25-bound patches, the adapter still drops
> every packet sent to it.

No it does not. See your log below.

> wlan0: authenticate with AP ZZZZZZZZZZZZZZZ
> wlan0: RX authentication from ZZZZZZZZZZZZZZZZ (alg=0 transaction=2 status=0)
> wlan0: authenticated
> wlan0: associate with AP ZZZZZZZZZZZZZZZ
> wlan0: RX ReassocResp from ZZZZZZZZZZZZZZZZZ (capab=0x431 status=0 aid=178)
> wlan0: associated
> wlan0: CTS protection enabled (BSSID=ZZZZZZZZZZZZZZZZZZ)
> b43-phy0 debug: RX: Packet dropped
> b43-phy0 debug: RX: Packet dropped
> b43-phy0 debug: RX: Packet dropped
> b43-phy0 debug: RX: Packet dropped

It seems that it's unable to decrypt any packets.
Which encryption are you using?

-- 
Greetings Michael.


From mb at bu3sch.de  Thu Jan 10 20:46:56 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 10 Jan 2008 20:46:56 +0100
Subject: [PATCH RFT] b43: Add support for new firmware
Message-ID: <200801102046.56979.mb@bu3sch.de>

This patch adds support for new firmware.
Please test this on old and new firmware.

To get new firmware, go to
ftp://ftp.linksys.com/opensourcecode/wrt150nv11/1.51.3/
and download the tarball. We don't have a smaller tarball, yet.
That will be fixed later.
You can extract firmware out of the "wl_ap.o" file contained
in this tarball using latest fwcutter. You must pass the option
--unsupported to fwcutter.


Index: wireless-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/dma.c	2008-01-09 16:59:33.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/dma.c	2008-01-10 18:00:18.000000000 +0100
@@ -804,44 +804,43 @@ struct b43_dmaring *b43_setup_dmaring(st
 	ring->meta = kcalloc(nr_slots, sizeof(struct b43_dmadesc_meta),
 			     GFP_KERNEL);
 	if (!ring->meta)
 		goto err_kfree_ring;
 	if (for_tx) {
 		ring->txhdr_cache = kcalloc(nr_slots,
-					    sizeof(struct b43_txhdr_fw4),
+					    b43_txhdr_size(dev),
 					    GFP_KERNEL);
 		if (!ring->txhdr_cache)
 			goto err_kfree_meta;
 
 		/* test for ability to dma to txhdr_cache */
 		dma_test = dma_map_single(dev->dev->dev,
 					  ring->txhdr_cache,
-					  sizeof(struct b43_txhdr_fw4),
+					  b43_txhdr_size(dev),
 					  DMA_TO_DEVICE);
 
 		if (dma_mapping_error(dma_test)) {
 			/* ugh realloc */
 			kfree(ring->txhdr_cache);
 			ring->txhdr_cache = kcalloc(nr_slots,
-						    sizeof(struct
-							   b43_txhdr_fw4),
+						    b43_txhdr_size(dev),
 						    GFP_KERNEL | GFP_DMA);
 			if (!ring->txhdr_cache)
 				goto err_kfree_meta;
 
 			dma_test = dma_map_single(dev->dev->dev,
 						  ring->txhdr_cache,
-						  sizeof(struct b43_txhdr_fw4),
+						  b43_txhdr_size(dev),
 						  DMA_TO_DEVICE);
 
 			if (dma_mapping_error(dma_test))
 				goto err_kfree_txhdr_cache;
 		}
 
 		dma_unmap_single(dev->dev->dev,
-				 dma_test, sizeof(struct b43_txhdr_fw4),
+				 dma_test, b43_txhdr_size(dev),
 				 DMA_TO_DEVICE);
 	}
 
 	ring->dev = dev;
 	ring->nr_slots = nr_slots;
 	ring->mmio_base = b43_dmacontroller_base(dma64, controller_index);
@@ -1119,32 +1118,33 @@ static int dma_tx_fragment(struct b43_dm
 	int err;
 	struct b43_dmadesc_generic *desc;
 	struct b43_dmadesc_meta *meta;
 	struct b43_dmadesc_meta *meta_hdr;
 	struct sk_buff *bounce_skb;
 	u16 cookie;
+	size_t hdrsize = b43_txhdr_size(ring->dev);
 
 #define SLOTS_PER_PACKET  2
 	B43_WARN_ON(skb_shinfo(skb)->nr_frags);
 
 	/* Get a slot for the header. */
 	slot = request_slot(ring);
 	desc = ops->idx2desc(ring, slot, &meta_hdr);
 	memset(meta_hdr, 0, sizeof(*meta_hdr));
 
-	header = &(ring->txhdr_cache[slot * sizeof(struct b43_txhdr_fw4)]);
+	header = &(ring->txhdr_cache[slot * hdrsize]);
 	cookie = generate_cookie(ring, slot);
 	b43_generate_txhdr(ring->dev, header,
 			   skb->data, skb->len, ctl, cookie);
 
 	meta_hdr->dmaaddr = map_descbuffer(ring, (unsigned char *)header,
-					   sizeof(struct b43_txhdr_fw4), 1);
+					   hdrsize, 1);
 	if (dma_mapping_error(meta_hdr->dmaaddr))
 		return -EIO;
 	ops->fill_descriptor(ring, desc, meta_hdr->dmaaddr,
-			     sizeof(struct b43_txhdr_fw4), 1, 0, 0);
+			     hdrsize, 1, 0, 0);
 
 	/* Get a slot for the payload. */
 	slot = request_slot(ring);
 	desc = ops->idx2desc(ring, slot, &meta);
 	memset(meta, 0, sizeof(*meta));
 
@@ -1186,13 +1186,13 @@ static int dma_tx_fragment(struct b43_dm
 	return 0;
 
 out_free_bounce:
 	dev_kfree_skb_any(skb);
 out_unmap_hdr:
 	unmap_descbuffer(ring, meta_hdr->dmaaddr,
-			 sizeof(struct b43_txhdr_fw4), 1);
+			 hdrsize, 1);
 	return err;
 }
 
 static inline int should_inject_overflow(struct b43_dmaring *ring)
 {
 #ifdef CONFIG_B43_DEBUG
@@ -1295,13 +1295,13 @@ void b43_dma_handle_txstatus(struct b43_
 
 		if (meta->skb)
 			unmap_descbuffer(ring, meta->dmaaddr, meta->skb->len,
 					 1);
 		else
 			unmap_descbuffer(ring, meta->dmaaddr,
-					 sizeof(struct b43_txhdr_fw4), 1);
+					 b43_txhdr_size(dev), 1);
 
 		if (meta->is_last_fragment) {
 			B43_WARN_ON(!meta->skb);
 			/* Call back to inform the ieee80211 subsystem about the
 			 * status of the transmission.
 			 * Some fields of txstat are already filled in dma_tx().
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-09 20:02:57.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-10 20:39:09.000000000 +0100
@@ -1566,17 +1566,23 @@ static void b43_release_firmware(struct 
 	release_firmware(dev->fw.initvals);
 	dev->fw.initvals = NULL;
 	release_firmware(dev->fw.initvals_band);
 	dev->fw.initvals_band = NULL;
 }
 
-static void b43_print_fw_helptext(struct b43_wl *wl)
+static void b43_print_fw_helptext(struct b43_wl *wl, bool error)
 {
-	b43err(wl, "You must go to "
+	const char *text;
+
+	text = "You must go to "
 	       "http://linuxwireless.org/en/users/Drivers/b43#devicefirmware "
-	       "and download the correct firmware (version 4).\n");
+	       "and download the latest firmware (version 4).\n";
+	if (error)
+		b43err(wl, text);
+	else
+		b43warn(wl, text);
 }
 
 static int do_request_fw(struct b43_wldev *dev,
 			 const char *name,
 			 const struct firmware **fw)
 {
@@ -1722,13 +1728,13 @@ static int b43_request_firmware(struct b
 			goto err_load;
 	}
 
 	return 0;
 
 err_load:
-	b43_print_fw_helptext(dev->wl);
+	b43_print_fw_helptext(dev->wl, 1);
 	goto error;
 
 err_no_ucode:
 	err = -ENODEV;
 	b43err(dev->wl, "No microcode available for core rev %u\n", rev);
 	goto error;
@@ -1792,13 +1798,13 @@ static int b43_upload_microcode(struct b
 		tmp = b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);
 		if (tmp == B43_IRQ_MAC_SUSPENDED)
 			break;
 		i++;
 		if (i >= 50) {
 			b43err(dev->wl, "Microcode not responding\n");
-			b43_print_fw_helptext(dev->wl);
+			b43_print_fw_helptext(dev->wl, 1);
 			err = -ENODEV;
 			goto out;
 		}
 		udelay(10);
 	}
 	b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);	/* dummy read */
@@ -1810,13 +1816,13 @@ static int b43_upload_microcode(struct b
 	fwtime = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_UCODETIME);
 
 	if (fwrev <= 0x128) {
 		b43err(dev->wl, "YOUR FIRMWARE IS TOO OLD. Firmware from "
 		       "binary drivers older than version 4.x is unsupported. "
 		       "You must upgrade your firmware files.\n");
-		b43_print_fw_helptext(dev->wl);
+		b43_print_fw_helptext(dev->wl, 1);
 		b43_write32(dev, B43_MMIO_MACCTL, 0);
 		err = -EOPNOTSUPP;
 		goto out;
 	}
 	b43dbg(dev->wl, "Loading firmware version %u.%u "
 	       "(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\n",
@@ -1824,13 +1830,19 @@ static int b43_upload_microcode(struct b
 	       (fwdate >> 12) & 0xF, (fwdate >> 8) & 0xF, fwdate & 0xFF,
 	       (fwtime >> 11) & 0x1F, (fwtime >> 5) & 0x3F, fwtime & 0x1F);
 
 	dev->fw.rev = fwrev;
 	dev->fw.patch = fwpatch;
 
-      out:
+	if (b43_is_old_txhdr_format(dev)) {
+		b43warn(dev->wl, "You are using an old firmware image. "
+			"Support for old firmware will be removed in July 2008.\n");
+		b43_print_fw_helptext(dev->wl, 0);
+	}
+
+out:
 	return err;
 }
 
 static int b43_write_initvals(struct b43_wldev *dev,
 			      const struct b43_iv *ivals,
 			      size_t count,
@@ -1884,13 +1896,13 @@ static int b43_write_initvals(struct b43
 		goto err_format;
 
 	return 0;
 
 err_format:
 	b43err(dev->wl, "Initial Values Firmware file-format error.\n");
-	b43_print_fw_helptext(dev->wl);
+	b43_print_fw_helptext(dev->wl, 1);
 
 	return -EPROTO;
 }
 
 static int b43_upload_initvals(struct b43_wldev *dev)
 {
@@ -2146,37 +2158,43 @@ static void b43_mgmtframe_txantenna(stru
 {
 	u16 ant = 0;
 	u16 tmp;
 
 	switch (antenna) {
 	case B43_ANTENNA0:
-		ant |= B43_TX4_PHY_ANT0;
+		ant |= B43_TXH_PHY_ANT0;
 		break;
 	case B43_ANTENNA1:
-		ant |= B43_TX4_PHY_ANT1;
+		ant |= B43_TXH_PHY_ANT1;
+		break;
+	case B43_ANTENNA2:
+		ant |= B43_TXH_PHY_ANT2;
+		break;
+	case B43_ANTENNA3:
+		ant |= B43_TXH_PHY_ANT3;
 		break;
 	case B43_ANTENNA_AUTO:
-		ant |= B43_TX4_PHY_ANTLAST;
+		ant |= B43_TXH_PHY_ANT01AUTO;
 		break;
 	default:
 		B43_WARN_ON(1);
 	}
 
 	/* FIXME We also need to set the other flags of the PHY control field somewhere. */
 
 	/* For Beacons */
 	tmp = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
-	tmp = (tmp & ~B43_TX4_PHY_ANT) | ant;
+	tmp = (tmp & ~B43_TXH_PHY_ANT) | ant;
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL, tmp);
 	/* For ACK/CTS */
 	tmp = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_ACKCTSPHYCTL);
-	tmp = (tmp & ~B43_TX4_PHY_ANT) | ant;
+	tmp = (tmp & ~B43_TXH_PHY_ANT) | ant;
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_ACKCTSPHYCTL, tmp);
 	/* For Probe Resposes */
 	tmp = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_PRPHYCTL);
-	tmp = (tmp & ~B43_TX4_PHY_ANT) | ant;
+	tmp = (tmp & ~B43_TXH_PHY_ANT) | ant;
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PRPHYCTL, tmp);
 }
 
 /* This is the opposite of b43_chip_init() */
 static void b43_chip_exit(struct b43_wldev *dev)
 {
@@ -2735,12 +2753,16 @@ static int b43_antenna_from_ieee80211(st
 	case 0:		/* default/diversity */
 		return B43_ANTENNA_DEFAULT;
 	case 1:		/* Antenna 0 */
 		return B43_ANTENNA0;
 	case 2:		/* Antenna 1 */
 		return B43_ANTENNA1;
+	case 3:		/* Antenna 2 */
+		return B43_ANTENNA2;
+	case 4:		/* Antenna 3 */
+		return B43_ANTENNA3;
 	default:
 		return B43_ANTENNA_DEFAULT;
 	}
 }
 
 static int b43_op_config(struct ieee80211_hw *hw, struct ieee80211_conf *conf)
Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c	2008-01-09 16:59:33.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/xmit.c	2008-01-10 20:05:13.000000000 +0100
@@ -174,19 +174,21 @@ static u8 b43_calc_fallback_rate(u8 bitr
 		return B43_OFDM_RATE_48MB;
 	}
 	B43_WARN_ON(1);
 	return 0;
 }
 
-static void generate_txhdr_fw4(struct b43_wldev *dev,
-			       struct b43_txhdr_fw4 *txhdr,
-			       const unsigned char *fragment_data,
-			       unsigned int fragment_len,
-			       const struct ieee80211_tx_control *txctl,
-			       u16 cookie)
+/* Generate a TX data header. */
+void b43_generate_txhdr(struct b43_wldev *dev,
+			u8 *_txhdr,
+			const unsigned char *fragment_data,
+			unsigned int fragment_len,
+			const struct ieee80211_tx_control *txctl,
+			u16 cookie)
 {
+	struct b43_txhdr *txhdr = (struct b43_txhdr *)_txhdr;
 	const struct b43_phy *phy = &dev->phy;
 	const struct ieee80211_hdr *wlhdr =
 	    (const struct ieee80211_hdr *)fragment_data;
 	int use_encryption = (!(txctl->flags & IEEE80211_TXCTL_DO_NOT_ENCRYPT));
 	u16 fctl = le16_to_cpu(wlhdr->frame_control);
 	u8 rate, rate_fb;
@@ -238,135 +240,177 @@ static void generate_txhdr_fw4(struct b4
 		B43_WARN_ON(!key->keyconf);
 
 		/* Hardware appends ICV. */
 		plcp_fragment_len += txctl->icv_len;
 
 		key_idx = b43_kidx_to_fw(dev, key_idx);
-		mac_ctl |= (key_idx << B43_TX4_MAC_KEYIDX_SHIFT) &
-			   B43_TX4_MAC_KEYIDX;
-		mac_ctl |= (key->algorithm << B43_TX4_MAC_KEYALG_SHIFT) &
-			   B43_TX4_MAC_KEYALG;
+		mac_ctl |= (key_idx << B43_TXH_MAC_KEYIDX_SHIFT) &
+			   B43_TXH_MAC_KEYIDX;
+		mac_ctl |= (key->algorithm << B43_TXH_MAC_KEYALG_SHIFT) &
+			   B43_TXH_MAC_KEYALG;
 		wlhdr_len = ieee80211_get_hdrlen(fctl);
 		iv_len = min((size_t) txctl->iv_len,
 			     ARRAY_SIZE(txhdr->iv));
 		memcpy(txhdr->iv, ((u8 *) wlhdr) + wlhdr_len, iv_len);
 	}
-	b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->plcp),
-			      plcp_fragment_len, rate);
+	if (b43_is_old_txhdr_format(dev)) {
+		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->old_format.plcp),
+				      plcp_fragment_len, rate);
+	} else {
+		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->new_format.plcp),
+				      plcp_fragment_len, rate);
+	}
 	b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->plcp_fb),
 			      plcp_fragment_len, rate_fb);
 
 	/* Extra Frame Types */
 	if (rate_fb_ofdm)
-		extra_ft |= B43_TX4_EFT_FBOFDM;
+		extra_ft |= B43_TXH_EFT_FB_OFDM;
+	else
+		extra_ft |= B43_TXH_EFT_FB_CCK;
 
 	/* Set channel radio code. Note that the micrcode ORs 0x100 to
 	 * this value before comparing it to the value in SHM, if this
 	 * is a 5Ghz packet.
 	 */
 	txhdr->chan_radio_code = phy->channel;
 
 	/* PHY TX Control word */
 	if (rate_ofdm)
-		phy_ctl |= B43_TX4_PHY_OFDM;
+		phy_ctl |= B43_TXH_PHY_ENC_OFDM;
+	else
+		phy_ctl |= B43_TXH_PHY_ENC_CCK;
 	if (dev->short_preamble)
-		phy_ctl |= B43_TX4_PHY_SHORTPRMBL;
+		phy_ctl |= B43_TXH_PHY_SHORTPRMBL;
 
 	switch (b43_ieee80211_antenna_sanitize(dev, txctl->antenna_sel_tx)) {
 	case 0: /* Default */
-		phy_ctl |= B43_TX4_PHY_ANTLAST;
+		phy_ctl |= B43_TXH_PHY_ANT01AUTO;
 		break;
 	case 1: /* Antenna 0 */
-		phy_ctl |= B43_TX4_PHY_ANT0;
+		phy_ctl |= B43_TXH_PHY_ANT0;
 		break;
 	case 2: /* Antenna 1 */
-		phy_ctl |= B43_TX4_PHY_ANT1;
+		phy_ctl |= B43_TXH_PHY_ANT1;
+		break;
+	case 3: /* Antenna 2 */
+		phy_ctl |= B43_TXH_PHY_ANT2;
+		break;
+	case 4: /* Antenna 3 */
+		phy_ctl |= B43_TXH_PHY_ANT3;
 		break;
 	default:
 		B43_WARN_ON(1);
 	}
 
 	/* MAC control */
 	if (!(txctl->flags & IEEE80211_TXCTL_NO_ACK))
-		mac_ctl |= B43_TX4_MAC_ACK;
+		mac_ctl |= B43_TXH_MAC_ACK;
 	if (!(((fctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_CTL) &&
 	      ((fctl & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_PSPOLL)))
-		mac_ctl |= B43_TX4_MAC_HWSEQ;
+		mac_ctl |= B43_TXH_MAC_HWSEQ;
 	if (txctl->flags & IEEE80211_TXCTL_FIRST_FRAGMENT)
-		mac_ctl |= B43_TX4_MAC_STMSDU;
+		mac_ctl |= B43_TXH_MAC_STMSDU;
 	if (phy->type == B43_PHYTYPE_A)
-		mac_ctl |= B43_TX4_MAC_5GHZ;
+		mac_ctl |= B43_TXH_MAC_5GHZ;
 	if (txctl->flags & IEEE80211_TXCTL_LONG_RETRY_LIMIT)
-		mac_ctl |= B43_TX4_MAC_LONGFRAME;
+		mac_ctl |= B43_TXH_MAC_LONGFRAME;
 
 	/* Generate the RTS or CTS-to-self frame */
 	if ((txctl->flags & IEEE80211_TXCTL_USE_RTS_CTS) ||
 	    (txctl->flags & IEEE80211_TXCTL_USE_CTS_PROTECT)) {
 		unsigned int len;
 		struct ieee80211_hdr *hdr;
 		int rts_rate, rts_rate_fb;
 		int rts_rate_ofdm, rts_rate_fb_ofdm;
+		struct b43_plcp_hdr6 *plcp;
 
 		rts_rate = txctl->rts_cts_rate;
 		rts_rate_ofdm = b43_is_ofdm_rate(rts_rate);
 		rts_rate_fb = b43_calc_fallback_rate(rts_rate);
 		rts_rate_fb_ofdm = b43_is_ofdm_rate(rts_rate_fb);
 
 		if (txctl->flags & IEEE80211_TXCTL_USE_CTS_PROTECT) {
+			struct ieee80211_cts *cts;
+
+			if (b43_is_old_txhdr_format(dev)) {
+				cts = (struct ieee80211_cts *)
+					(txhdr->old_format.rts_frame);
+			} else {
+				cts = (struct ieee80211_cts *)
+					(txhdr->new_format.rts_frame);
+			}
 			ieee80211_ctstoself_get(dev->wl->hw, txctl->vif,
 						fragment_data, fragment_len,
-						txctl,
-						(struct ieee80211_cts *)(txhdr->
-									 rts_frame));
-			mac_ctl |= B43_TX4_MAC_SENDCTS;
+						txctl, cts);
+			mac_ctl |= B43_TXH_MAC_SENDCTS;
 			len = sizeof(struct ieee80211_cts);
 		} else {
+			struct ieee80211_rts *rts;
+
+			if (b43_is_old_txhdr_format(dev)) {
+				rts = (struct ieee80211_rts *)
+					(txhdr->old_format.rts_frame);
+			} else {
+				rts = (struct ieee80211_rts *)
+					(txhdr->new_format.rts_frame);
+			}
 			ieee80211_rts_get(dev->wl->hw, txctl->vif,
-					  fragment_data, fragment_len, txctl,
-					  (struct ieee80211_rts *)(txhdr->
-								   rts_frame));
-			mac_ctl |= B43_TX4_MAC_SENDRTS;
+					  fragment_data, fragment_len,
+					  txctl, rts);
+			mac_ctl |= B43_TXH_MAC_SENDRTS;
 			len = sizeof(struct ieee80211_rts);
 		}
 		len += FCS_LEN;
-		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->
-							       rts_plcp), len,
-				      rts_rate);
-		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->
-							       rts_plcp_fb),
+
+		/* Generate the PLCP headers for the RTS/CTS frame */
+		if (b43_is_old_txhdr_format(dev))
+			plcp = &txhdr->old_format.rts_plcp;
+		else
+			plcp = &txhdr->new_format.rts_plcp;
+		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)plcp,
+				      len, rts_rate);
+		plcp = &txhdr->rts_plcp_fb;
+		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)plcp,
 				      len, rts_rate_fb);
-		hdr = (struct ieee80211_hdr *)(&txhdr->rts_frame);
+
+		if (b43_is_old_txhdr_format(dev)) {
+			hdr = (struct ieee80211_hdr *)
+				(&txhdr->old_format.rts_frame);
+		} else {
+			hdr = (struct ieee80211_hdr *)
+				(&txhdr->new_format.rts_frame);
+		}
 		txhdr->rts_dur_fb = hdr->duration_id;
+
 		if (rts_rate_ofdm) {
-			extra_ft |= B43_TX4_EFT_RTSOFDM;
+			extra_ft |= B43_TXH_EFT_RTS_OFDM;
 			txhdr->phy_rate_rts =
 			    b43_plcp_get_ratecode_ofdm(rts_rate);
-		} else
+		} else {
+			extra_ft |= B43_TXH_EFT_RTS_CCK;
 			txhdr->phy_rate_rts =
 			    b43_plcp_get_ratecode_cck(rts_rate);
+		}
 		if (rts_rate_fb_ofdm)
-			extra_ft |= B43_TX4_EFT_RTSFBOFDM;
+			extra_ft |= B43_TXH_EFT_RTSFB_OFDM;
+		else
+			extra_ft |= B43_TXH_EFT_RTSFB_CCK;
 	}
 
 	/* Magic cookie */
-	txhdr->cookie = cpu_to_le16(cookie);
+	if (b43_is_old_txhdr_format(dev))
+		txhdr->old_format.cookie = cpu_to_le16(cookie);
+	else
+		txhdr->new_format.cookie = cpu_to_le16(cookie);
 
 	/* Apply the bitfields */
 	txhdr->mac_ctl = cpu_to_le32(mac_ctl);
 	txhdr->phy_ctl = cpu_to_le16(phy_ctl);
 	txhdr->extra_ft = extra_ft;
-}
 
-void b43_generate_txhdr(struct b43_wldev *dev,
-			u8 * txhdr,
-			const unsigned char *fragment_data,
-			unsigned int fragment_len,
-			const struct ieee80211_tx_control *txctl, u16 cookie)
-{
-	generate_txhdr_fw4(dev, (struct b43_txhdr_fw4 *)txhdr,
-			   fragment_data, fragment_len, txctl, cookie);
 }
 
 static s8 b43_rssi_postprocess(struct b43_wldev *dev,
 			       u8 in_rssi, int ofdm,
 			       int adjust_2053, int adjust_2050)
 {
Index: wireless-2.6/drivers/net/wireless/b43/xmit.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.h	2008-01-09 16:59:33.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/xmit.h	2008-01-10 20:23:10.000000000 +0100
@@ -16,74 +16,166 @@ _b43_declare_plcp_hdr(4);
 /* struct b43_plcp_hdr6 */
 _b43_declare_plcp_hdr(6);
 
 #undef _b43_declare_plcp_hdr
 
 /* TX header for v4 firmware */
-struct b43_txhdr_fw4 {
-	__le32 mac_ctl;		/* MAC TX control */
-	__le16 mac_frame_ctl;	/* Copy of the FrameControl field */
+struct b43_txhdr {
+	__le32 mac_ctl;			/* MAC TX control */
+	__le16 mac_frame_ctl;		/* Copy of the FrameControl field */
 	__le16 tx_fes_time_norm;	/* TX FES Time Normal */
-	__le16 phy_ctl;		/* PHY TX control */
-	__le16 phy_ctl_0;	/* Unused */
-	__le16 phy_ctl_1;	/* Unused */
-	__le16 phy_ctl_rts_0;	/* Unused */
-	__le16 phy_ctl_rts_1;	/* Unused */
-	__u8 phy_rate;		/* PHY rate */
-	__u8 phy_rate_rts;	/* PHY rate for RTS/CTS */
-	__u8 extra_ft;		/* Extra Frame Types */
-	__u8 chan_radio_code;	/* Channel Radio Code */
-	__u8 iv[16];		/* Encryption IV */
-	__u8 tx_receiver[6];	/* TX Frame Receiver address */
-	__le16 tx_fes_time_fb;	/* TX FES Time Fallback */
-	struct b43_plcp_hdr6 rts_plcp_fb;	/* RTS fallback PLCP */
-	__le16 rts_dur_fb;	/* RTS fallback duration */
-	struct b43_plcp_hdr6 plcp_fb;	/* Fallback PLCP */
-	__le16 dur_fb;		/* Fallback duration */
-	__le16 mm_dur_time;	/* Unused */
-	__le16 mm_dur_time_fb;	/* Unused */
-	__le32 time_stamp;	/* Timestamp */
-	 PAD_BYTES(2);
-	__le16 cookie;		/* TX frame cookie */
-	__le16 tx_status;	/* TX status */
-	struct b43_plcp_hdr6 rts_plcp;	/* RTS PLCP */
-	__u8 rts_frame[16];	/* The RTS frame (if used) */
-	 PAD_BYTES(2);
-	struct b43_plcp_hdr6 plcp;	/* Main PLCP */
+	__le16 phy_ctl;			/* PHY TX control */
+	__le16 phy_ctl1;		/* PHY TX control word 1 */
+	__le16 phy_ctl1_fb;		/* PHY TX control word 1 for fallback rates */
+	__le16 phy_ctl1_rts;		/* PHY TX control word 1 RTS */
+	__le16 phy_ctl1_rts_fb;		/* PHY TX control word 1 RTS for fallback rates */
+	__u8 phy_rate;			/* PHY rate */
+	__u8 phy_rate_rts;		/* PHY rate for RTS/CTS */
+	__u8 extra_ft;			/* Extra Frame Types */
+	__u8 chan_radio_code;		/* Channel Radio Code */
+	__u8 iv[16];			/* Encryption IV */
+	__u8 tx_receiver[6];		/* TX Frame Receiver address */
+	__le16 tx_fes_time_fb;		/* TX FES Time Fallback */
+	struct b43_plcp_hdr6 rts_plcp_fb; /* RTS fallback PLCP header */
+	__le16 rts_dur_fb;		/* RTS fallback duration */
+	struct b43_plcp_hdr6 plcp_fb;	/* Fallback PLCP header */
+	__le16 dur_fb;			/* Fallback duration */
+	__le16 mimo_modelen;		/* MIMO mode length */
+	__le16 mimo_ratelen_fb;		/* MIMO fallback rate length */
+	__le32 timeout;			/* Timeout */
+
+	union {
+		/* The new r410 format. */
+		struct {
+			__le16 mimo_antenna;		/* MIMO antenna select */
+			__le16 preload_size;		/* Preload size */
+			PAD_BYTES(2);
+			__le16 cookie;			/* TX frame cookie */
+			__le16 tx_status;		/* TX status */
+			struct b43_plcp_hdr6 rts_plcp;	/* RTS PLCP header */
+			__u8 rts_frame[16];		/* The RTS frame (if used) */
+			PAD_BYTES(2);
+			struct b43_plcp_hdr6 plcp;	/* Main PLCP header */
+		} new_format __attribute__ ((__packed__));
+
+		/* The old r351 format. */
+		struct {
+			PAD_BYTES(2);
+			__le16 cookie;			/* TX frame cookie */
+			__le16 tx_status;		/* TX status */
+			struct b43_plcp_hdr6 rts_plcp;	/* RTS PLCP header */
+			__u8 rts_frame[16];		/* The RTS frame (if used) */
+			PAD_BYTES(2);
+			struct b43_plcp_hdr6 plcp;	/* Main PLCP header */
+		} old_format __attribute__ ((__packed__));
+
+	} __attribute__ ((__packed__));
 } __attribute__ ((__packed__));
 
 /* MAC TX control */
-#define B43_TX4_MAC_KEYIDX		0x0FF00000	/* Security key index */
-#define B43_TX4_MAC_KEYIDX_SHIFT	20
-#define B43_TX4_MAC_KEYALG		0x00070000	/* Security key algorithm */
-#define B43_TX4_MAC_KEYALG_SHIFT	16
-#define B43_TX4_MAC_LIFETIME	0x00001000
-#define B43_TX4_MAC_FRAMEBURST	0x00000800
-#define B43_TX4_MAC_SENDCTS		0x00000400
-#define B43_TX4_MAC_AMPDU		0x00000300
-#define B43_TX4_MAC_AMPDU_SHIFT	8
-#define B43_TX4_MAC_5GHZ		0x00000080
-#define B43_TX4_MAC_IGNPMQ		0x00000020
-#define B43_TX4_MAC_HWSEQ		0x00000010	/* Use Hardware Sequence Number */
-#define B43_TX4_MAC_STMSDU		0x00000008	/* Start MSDU */
-#define B43_TX4_MAC_SENDRTS		0x00000004
-#define B43_TX4_MAC_LONGFRAME	0x00000002
-#define B43_TX4_MAC_ACK		0x00000001
+#define B43_TXH_MAC_USEFBR		0x10000000 /* Use fallback rate for this AMPDU */
+#define B43_TXH_MAC_KEYIDX		0x0FF00000 /* Security key index */
+#define B43_TXH_MAC_KEYIDX_SHIFT	20
+#define B43_TXH_MAC_KEYALG		0x00070000 /* Security key algorithm */
+#define B43_TXH_MAC_KEYALG_SHIFT	16
+#define B43_TXH_MAC_AMIC		0x00008000 /* AMIC */
+#define B43_TXH_MAC_RIFS		0x00004000 /* Use RIFS */
+#define B43_TXH_MAC_LIFETIME		0x00002000 /* Lifetime */
+#define B43_TXH_MAC_FRAMEBURST		0x00001000 /* Frameburst */
+#define B43_TXH_MAC_SENDCTS		0x00000800 /* Send CTS-to-self */
+#define B43_TXH_MAC_AMPDU		0x00000600 /* AMPDU status */
+#define  B43_TXH_MAC_AMPDU_MPDU		0x00000000 /* Regular MPDU, not an AMPDU */
+#define  B43_TXH_MAC_AMPDU_FIRST	0x00000200 /* First MPDU or AMPDU */
+#define  B43_TXH_MAC_AMPDU_INTER	0x00000400 /* Intermediate MPDU or AMPDU */
+#define  B43_TXH_MAC_AMPDU_LAST		0x00000600 /* Last (or only) MPDU of AMPDU */
+#define B43_TXH_MAC_40MHZ		0x00000100 /* Use 40 MHz bandwidth */
+#define B43_TXH_MAC_5GHZ		0x00000080 /* 5GHz band */
+#define B43_TXH_MAC_DFCS		0x00000040 /* DFCS */
+#define B43_TXH_MAC_IGNPMQ		0x00000020 /* Ignore PMQ */
+#define B43_TXH_MAC_HWSEQ		0x00000010 /* Use Hardware Sequence Number */
+#define B43_TXH_MAC_STMSDU		0x00000008 /* Start MSDU */
+#define B43_TXH_MAC_SENDRTS		0x00000004 /* Send RTS */
+#define B43_TXH_MAC_LONGFRAME		0x00000002 /* Long frame */
+#define B43_TXH_MAC_ACK			0x00000001 /* Immediate ACK */
 
 /* Extra Frame Types */
-#define B43_TX4_EFT_FBOFDM		0x0001	/* Data frame fallback rate type */
-#define B43_TX4_EFT_RTSOFDM		0x0004	/* RTS/CTS rate type */
-#define B43_TX4_EFT_RTSFBOFDM	0x0010	/* RTS/CTS fallback rate type */
+#define B43_TXH_EFT_FB			0x03 /* Data frame fallback encoding */
+#define  B43_TXH_EFT_FB_CCK		0x00 /* CCK */
+#define  B43_TXH_EFT_FB_OFDM		0x01 /* OFDM */
+#define  B43_TXH_EFT_FB_EWC		0x02 /* EWC */
+#define  B43_TXH_EFT_FB_N		0x03 /* N */
+#define B43_TXH_EFT_RTS			0x0C /* RTS/CTS encoding */
+#define  B43_TXH_EFT_RTS_CCK		0x00 /* CCK */
+#define  B43_TXH_EFT_RTS_OFDM		0x04 /* OFDM */
+#define  B43_TXH_EFT_RTS_EWC		0x08 /* EWC */
+#define  B43_TXH_EFT_RTS_N		0x0C /* N */
+#define B43_TXH_EFT_RTSFB		0x30 /* RTS/CTS fallback encoding */
+#define  B43_TXH_EFT_RTSFB_CCK		0x00 /* CCK */
+#define  B43_TXH_EFT_RTSFB_OFDM		0x10 /* OFDM */
+#define  B43_TXH_EFT_RTSFB_EWC		0x20 /* EWC */
+#define  B43_TXH_EFT_RTSFB_N		0x30 /* N */
 
 /* PHY TX control word */
-#define B43_TX4_PHY_OFDM		0x0001	/* Data frame rate type */
-#define B43_TX4_PHY_SHORTPRMBL	0x0010	/* Use short preamble */
-#define B43_TX4_PHY_ANT		0x03C0	/* Antenna selection */
-#define  B43_TX4_PHY_ANT0		0x0000	/* Use antenna 0 */
-#define  B43_TX4_PHY_ANT1		0x0100	/* Use antenna 1 */
-#define  B43_TX4_PHY_ANTLAST	0x0300	/* Use last used antenna */
+#define B43_TXH_PHY_ENC			0x0003 /* Data frame encoding */
+#define  B43_TXH_PHY_ENC_CCK		0x0000 /* CCK */
+#define  B43_TXH_PHY_ENC_OFDM		0x0001 /* OFDM */
+#define  B43_TXH_PHY_ENC_EWC		0x0002 /* EWC */
+#define  B43_TXH_PHY_ENC_N		0x0003 /* N */
+#define B43_TXH_PHY_SHORTPRMBL		0x0010 /* Use short preamble */
+#define B43_TXH_PHY_ANT			0x03C0 /* Antenna selection */
+#define  B43_TXH_PHY_ANT0		0x0000 /* Use antenna 0 */
+#define  B43_TXH_PHY_ANT1		0x0040 /* Use antenna 1 */
+#define  B43_TXH_PHY_ANT01AUTO		0x00C0 /* Use antenna 0/1 auto */
+#define  B43_TXH_PHY_ANT2		0x0100 /* Use antenna 2 */
+#define  B43_TXH_PHY_ANT3		0x0200 /* Use antenna 3 */
+#define B43_TXH_PHY_TXPWR		0xFC00 /* TX power */
+#define B43_TXH_PHY_TXPWR_SHIFT		10
+
+/* PHY TX control word 1 */
+#define B43_TXH_PHY1_BW			0x0007 /* Bandwidth */
+#define  B43_TXH_PHY1_BW_10		0x0000 /* 10 MHz */
+#define  B43_TXH_PHY1_BW_10U		0x0001 /* 10 MHz upper */
+#define  B43_TXH_PHY1_BW_20		0x0002 /* 20 MHz */
+#define  B43_TXH_PHY1_BW_20U		0x0003 /* 20 MHz upper */
+#define  B43_TXH_PHY1_BW_40		0x0004 /* 40 MHz */
+#define  B43_TXH_PHY1_BW_40DUP		0x0005 /* 50 MHz duplicate */
+#define B43_TXH_PHY1_MODE		0x0038 /* Mode */
+#define  B43_TXH_PHY1_MODE_SISO		0x0000 /* SISO */
+#define  B43_TXH_PHY1_MODE_CDD		0x0008 /* CDD */
+#define  B43_TXH_PHY1_MODE_STBC		0x0010 /* STBC */
+#define  B43_TXH_PHY1_MODE_SDM		0x0018 /* SDM */
+#define B43_TXH_PHY1_CRATE		0x0700 /* Coding rate */
+#define  B43_TXH_PHY1_CRATE_1_2		0x0000 /* 1/2 */
+#define  B43_TXH_PHY1_CRATE_2_3		0x0100 /* 2/3 */
+#define  B43_TXH_PHY1_CRATE_3_4		0x0200 /* 3/4 */
+#define  B43_TXH_PHY1_CRATE_4_5		0x0300 /* 4/5 */
+#define  B43_TXH_PHY1_CRATE_5_6		0x0400 /* 5/6 */
+#define  B43_TXH_PHY1_CRATE_7_8		0x0600 /* 7/8 */
+#define B43_TXH_PHY1_MODUL		0x3800 /* Modulation scheme */
+#define  B43_TXH_PHY1_MODUL_BPSK	0x0000 /* BPSK */
+#define  B43_TXH_PHY1_MODUL_QPSK	0x0800 /* QPSK */
+#define  B43_TXH_PHY1_MODUL_QAM16	0x1000 /* QAM16 */
+#define  B43_TXH_PHY1_MODUL_QAM64	0x1800 /* QAM64 */
+#define  B43_TXH_PHY1_MODUL_QAM256	0x2000 /* QAM256 */
+
+
+/* r351 firmware compatibility stuff. */
+static inline
+bool b43_is_old_txhdr_format(struct b43_wldev *dev)
+{
+	return (dev->fw.rev <= 351);
+}
+
+static inline
+size_t b43_txhdr_size(struct b43_wldev *dev)
+{
+	if (b43_is_old_txhdr_format(dev))
+		return 100 + sizeof(struct b43_plcp_hdr6);
+	return 104 + sizeof(struct b43_plcp_hdr6);
+}
+
 
 void b43_generate_txhdr(struct b43_wldev *dev,
 			u8 * txhdr,
 			const unsigned char *fragment_data,
 			unsigned int fragment_len,
 			const struct ieee80211_tx_control *txctl, u16 cookie);
Index: wireless-2.6/Documentation/feature-removal-schedule.txt
===================================================================
--- wireless-2.6.orig/Documentation/feature-removal-schedule.txt	2007-12-20 18:53:57.000000000 +0100
+++ wireless-2.6/Documentation/feature-removal-schedule.txt	2008-01-10 20:29:48.000000000 +0100
@@ -355,6 +355,15 @@ What:	rc80211-simple rate control algori
 When:	2.6.26
 Files:	net/mac80211/rc80211-simple.c
 Why:	This algorithm was provided for reference but always exhibited bad
 	responsiveness and performance and has some serious flaws. It has been
 	replaced by rc80211-pid.
 Who:	Stefano Brivio <stefano.brivio at polimi.it>
+
+---------------------------
+
+What:	b43 support for firmware revision < 410
+When:	July 2008
+Why:	The support code for the old firmware hurts code readability/maintainability
+	and slightly hurts runtime performance. Bugfixes for the old firmware
+	are not provided by Broadcom anymore.
+Who:	Michael Buesch <mb at bu3sch.de>
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h	2008-01-09 18:48:42.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/phy.h	2008-01-10 19:57:45.000000000 +0100
@@ -177,12 +177,14 @@ void b43_gtab_write(struct b43_wldev *de
 
 enum {
 	B43_ANTENNA0,		/* Antenna 0 */
 	B43_ANTENNA1,		/* Antenna 0 */
 	B43_ANTENNA_AUTO1,	/* Automatic, starting with antenna 1 */
 	B43_ANTENNA_AUTO0,	/* Automatic, starting with antenna 0 */
+	B43_ANTENNA2,
+	B43_ANTENNA3 = 8,
 
 	B43_ANTENNA_AUTO = B43_ANTENNA_AUTO0,
 	B43_ANTENNA_DEFAULT = B43_ANTENNA_AUTO,
 };
 
 enum {


From cebbert at redhat.com  Thu Jan 10 23:10:03 2008
From: cebbert at redhat.com (Chuck Ebbert)
Date: Thu, 10 Jan 2008 17:10:03 -0500
Subject: BCM4311 Rev D still doesn't work
In-Reply-To: <200801102008.01277.mb@bu3sch.de>
References: <47865AFE.7000505@redhat.com> <200801102008.01277.mb@bu3sch.de>
Message-ID: <478697BB.8030806@redhat.com>

On 01/10/2008 02:08 PM, Michael Buesch wrote:
> On Thursday 10 January 2008 18:50:54 Chuck Ebbert wrote:
>> Using Fedora 8 kernel 2.6.23.13-104 which was just updated
>> yesterday with 2.6.25-bound patches, the adapter still drops
>> every packet sent to it.
> 
> No it does not. See your log below.
> 
>> wlan0: authenticate with AP ZZZZZZZZZZZZZZZ
>> wlan0: RX authentication from ZZZZZZZZZZZZZZZZ (alg=0 transaction=2 status=0)
>> wlan0: authenticated
>> wlan0: associate with AP ZZZZZZZZZZZZZZZ
>> wlan0: RX ReassocResp from ZZZZZZZZZZZZZZZZZ (capab=0x431 status=0 aid=178)
>> wlan0: associated
>> wlan0: CTS protection enabled (BSSID=ZZZZZZZZZZZZZZZZZZ)
>> b43-phy0 debug: RX: Packet dropped
>> b43-phy0 debug: RX: Packet dropped
>> b43-phy0 debug: RX: Packet dropped
>> b43-phy0 debug: RX: Packet dropped
> 
> It seems that it's unable to decrypt any packets.
> Which encryption are you using?
> 

I was using the wrong wireless key, and also for some reason the rfkill
drivers weren't loading automatically. I had to turn the radio on and off
a few times after loading the rfkill drivers (was getting PHY transmit errors
at first) and then everything started working. Now the rfkill drivers are
loading automatically at boot, too.

But now after using the wireless network for a few minutes, signal strength
drops to zero.






From cebbert at redhat.com  Fri Jan 11 00:33:13 2008
From: cebbert at redhat.com (Chuck Ebbert)
Date: Thu, 10 Jan 2008 18:33:13 -0500
Subject: BCM4311 Rev D still doesn't work
In-Reply-To: <478697BB.8030806@redhat.com>
References: <47865AFE.7000505@redhat.com> <200801102008.01277.mb@bu3sch.de>
	<478697BB.8030806@redhat.com>
Message-ID: <4786AB39.7030500@redhat.com>

On 01/10/2008 05:10 PM, Chuck Ebbert wrote:
> On 01/10/2008 02:08 PM, Michael Buesch wrote:
>> On Thursday 10 January 2008 18:50:54 Chuck Ebbert wrote:
>>> Using Fedora 8 kernel 2.6.23.13-104 which was just updated
>>> yesterday with 2.6.25-bound patches, the adapter still drops
>>> every packet sent to it.
>> No it does not. See your log below.
>>
>>> wlan0: authenticate with AP ZZZZZZZZZZZZZZZ
>>> wlan0: RX authentication from ZZZZZZZZZZZZZZZZ (alg=0 transaction=2 status=0)
>>> wlan0: authenticated
>>> wlan0: associate with AP ZZZZZZZZZZZZZZZ
>>> wlan0: RX ReassocResp from ZZZZZZZZZZZZZZZZZ (capab=0x431 status=0 aid=178)
>>> wlan0: associated
>>> wlan0: CTS protection enabled (BSSID=ZZZZZZZZZZZZZZZZZZ)
>>> b43-phy0 debug: RX: Packet dropped
>>> b43-phy0 debug: RX: Packet dropped
>>> b43-phy0 debug: RX: Packet dropped
>>> b43-phy0 debug: RX: Packet dropped
>> It seems that it's unable to decrypt any packets.
>> Which encryption are you using?
>>
> 
> I was using the wrong wireless key, and also for some reason the rfkill
> drivers weren't loading automatically. I had to turn the radio on and off
> a few times after loading the rfkill drivers (was getting PHY transmit errors
> at first) and then everything started working. Now the rfkill drivers are
> loading automatically at boot, too.
> 
> But now after using the wireless network for a few minutes, signal strength
> drops to zero.
> 

It also starts to spew "PHY transmission error" and eventually loses
the connection to the AP... NetworkManager very nicely falls back to
the wired network.


From larry.finger at lwfinger.net  Fri Jan 11 17:40:04 2008
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 11 Jan 2008 09:40:04 -0700
Subject: [PATCH RFT] b43: Add support for new firmware
In-Reply-To: <200801102046.56979.mb@bu3sch.de>
References: <200801102046.56979.mb@bu3sch.de>
Message-ID: <47879BE4.7040108@lwfinger.net>

Michael Buesch wrote:
> This patch adds support for new firmware.
> Please test this on old and new firmware.

I have tested this patch with old firmware. It seems to work; however my testing is not complete as
my computer has started hanging with the "Caps Lock" light flashing. The crash is not caused by this
patch as it happened with 2.6.24-rc5, which has run for many days. I do have a suggestion for
changing the patch (see below).

> +static inline
> +size_t b43_txhdr_size(struct b43_wldev *dev)
> +{
> +	if (b43_is_old_txhdr_format(dev))
> +		return 100 + sizeof(struct b43_plcp_hdr6);
> +	return 104 + sizeof(struct b43_plcp_hdr6);
> +}

Why not eliminate most of the magic numbers in this part with

size_t b43_txhdr_size(struct b43_wldev *dev)
{
	if (b43_is_old_txhdr_format(dev))
		return sizeof(struct b43_txhdr) - 4;
	return sizeof(struct b43_txhdr);
}

Larry


From martin at marquesminen.com.ar  Fri Jan 11 17:43:41 2008
From: martin at marquesminen.com.ar (Martin Marques)
Date: Fri, 11 Jan 2008 14:43:41 -0200
Subject: [PATCH RFT] b43: Add support for new firmware
In-Reply-To: <47879BE4.7040108@lwfinger.net>
References: <200801102046.56979.mb@bu3sch.de> <47879BE4.7040108@lwfinger.net>
Message-ID: <47879CBD.8080403@marquesminen.com.ar>

Larry Finger escribi?:
> Michael Buesch wrote:
>> This patch adds support for new firmware.
>> Please test this on old and new firmware.
> 
> I have tested this patch with old firmware. It seems to work; however my testing is not complete as
> my computer has started hanging with the "Caps Lock" light flashing. The crash is not caused by this
> patch as it happened with 2.6.24-rc5, which has run for many days. I do have a suggestion for
> changing the patch (see below).

Sorry if it's a change of subject, but what does the flashing caps hang 
mean? It has happend to me a lot when trying to run 3D apps.


From mb at bu3sch.de  Fri Jan 11 17:47:18 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 11 Jan 2008 17:47:18 +0100
Subject: [PATCH RFT] b43: Add support for new firmware
In-Reply-To: <47879BE4.7040108@lwfinger.net>
References: <200801102046.56979.mb@bu3sch.de> <47879BE4.7040108@lwfinger.net>
Message-ID: <200801111747.18797.mb@bu3sch.de>

On Friday 11 January 2008 17:40:04 Larry Finger wrote:
> Michael Buesch wrote:
> > This patch adds support for new firmware.
> > Please test this on old and new firmware.
> 
> I have tested this patch with old firmware. It seems to work; however my testing is not complete as
> my computer has started hanging with the "Caps Lock" light flashing. The crash is not caused by this
> patch as it happened with 2.6.24-rc5, which has run for many days. I do have a suggestion for
> changing the patch (see below).
> 
> > +static inline
> > +size_t b43_txhdr_size(struct b43_wldev *dev)
> > +{
> > +	if (b43_is_old_txhdr_format(dev))
> > +		return 100 + sizeof(struct b43_plcp_hdr6);
> > +	return 104 + sizeof(struct b43_plcp_hdr6);
> > +}
> 
> Why not eliminate most of the magic numbers in this part with
> 
> size_t b43_txhdr_size(struct b43_wldev *dev)
> {
> 	if (b43_is_old_txhdr_format(dev))
> 		return sizeof(struct b43_txhdr) - 4;
> 	return sizeof(struct b43_txhdr);
> }

Because this is IMO as magic as the above.
The struct b43_txhdr is _not_ meant to be used as an object anymore,
as it now contains this union magic stuff. So we must only use it
as a pointer type. The sizeof, however, uses it as an object.
I'm perfectly fine with the hardcoded constants. And they really
are constants, as they are defined by the hard(firm)ware.
I think this all leads to the same issue as "Should we use
#defines for the PCI IDs in PCI ID tables?".
However, this code will go away in summer anyway. So it doesn't
really matter. It really is just a hack.

-- 
Greetings Michael.


From larry.finger at lwfinger.net  Fri Jan 11 18:17:31 2008
From: larry.finger at lwfinger.net (Larry Finger)
Date: Fri, 11 Jan 2008 10:17:31 -0700
Subject: [PATCH RFT] b43: Add support for new firmware
In-Reply-To: <47879CBD.8080403@marquesminen.com.ar>
References: <200801102046.56979.mb@bu3sch.de> <47879BE4.7040108@lwfinger.net>
	<47879CBD.8080403@marquesminen.com.ar>
Message-ID: <4787A4AB.5060601@lwfinger.net>

Martin Marques wrote:
> 
> Sorry if it's a change of subject, but what does the flashing caps hang
> mean? It has happend to me a lot when trying to run 3D apps.

AFAIK, it indicates an error so severe that the kernel has no chance to recover. Examples might be
stack underflow or a page fault while accessing the stack.

Your crashes when running 3D apps is likely a bug in the driver for your graphics adapter. Are you
using a binary-only driver? If so, complain to the manufacturer. If it is an open-source driver,
then a note to the Linux Kernel Mailing List would be appropriate. You should describe your kernel,
configuration, etc. and list the 3D app that causes the problem.

Larry


From rjw at sisk.pl  Sun Jan 13 00:08:29 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Sun, 13 Jan 2008 00:08:29 +0100
Subject: b43_suspend problem
Message-ID: <200801130008.29996.rjw@sisk.pl>

Hi,

There is a problem with b43_suspend() that it (indirectly) causes
b43_leds_exit() to be called, which attempts to unregister the leds device
objects, which is forbidden (ie. you can't unregister and/or register devices
during a suspend or resume).

The problem is not immediately visible right now (ie. in 2.6.24-rc), because
the PM core doesn't directly enforce this rule, but it will start to do it
shortly and then b43_suspend() will cause suspend/hibernation to deadlock.

Greetings,
Rafael


From mb at bu3sch.de  Sun Jan 13 00:30:44 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 13 Jan 2008 00:30:44 +0100
Subject: b43_suspend problem
In-Reply-To: <200801130008.29996.rjw@sisk.pl>
References: <200801130008.29996.rjw@sisk.pl>
Message-ID: <200801130030.45119.mb@bu3sch.de>

On Sunday 13 January 2008 00:08:29 Rafael J. Wysocki wrote:
> There is a problem with b43_suspend() that it (indirectly) causes
> b43_leds_exit() to be called, which attempts to unregister the leds device
> objects, which is forbidden (ie. you can't unregister and/or register devices
> during a suspend or resume).

Why?

-- 
Greetings Michael.


From rjw at sisk.pl  Sun Jan 13 01:52:31 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Sun, 13 Jan 2008 01:52:31 +0100
Subject: b43_suspend problem
In-Reply-To: <200801130030.45119.mb@bu3sch.de>
References: <200801130008.29996.rjw@sisk.pl> <200801130030.45119.mb@bu3sch.de>
Message-ID: <200801130152.31724.rjw@sisk.pl>

On Sunday, 13 of January 2008, Michael Buesch wrote:
> On Sunday 13 January 2008 00:08:29 Rafael J. Wysocki wrote:
> > There is a problem with b43_suspend() that it (indirectly) causes
> > b43_leds_exit() to be called, which attempts to unregister the leds device
> > objects, which is forbidden (ie. you can't unregister and/or register devices
> > during a suspend or resume).
> 
> Why?

Well, the unregistering itself is not really harmful, provided that the device
is not registered back during the subsequent resume.

The PM core uses a list of active devices that are added to the list in
device_add().  The ordering of this list is important, because it is expected
to reflect the order in which the devices are to be suspended.

This list is manipulated during suspend/resume and devices are moved from it
and back to it, so unregistering devices during a suspend and registering them
during the subsequent resume generally changes its ordering and may lead to
problems during the next suspend/resume cycle.

This is also undesirable if we're going to stop using the freezer for
suspend/resume at one point in the future.

I'm sure Alan can add some more details.

Greetings,
Rafael


From mb at bu3sch.de  Sun Jan 13 14:12:44 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 13 Jan 2008 14:12:44 +0100
Subject: [PATCH] b43: Fix radio ID register reading
Message-ID: <200801131412.44830.mb@bu3sch.de>

This fixes reading of the high 16 bits of the radio ID
on new devices. 2055 radios want lo16 to be read first.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.25

Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-13 13:26:18.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-13 13:59:27.000000000 +0100
@@ -3136,16 +3136,15 @@ static int b43_phy_versioning(struct b43
 		else if (dev->dev->bus->chip_rev == 1)
 			tmp = 0x4205017F;
 		else
 			tmp = 0x5205017F;
 	} else {
 		b43_write16(dev, B43_MMIO_RADIO_CONTROL, B43_RADIOCTL_ID);
-		tmp = b43_read16(dev, B43_MMIO_RADIO_DATA_HIGH);
-		tmp <<= 16;
+		tmp = b43_read16(dev, B43_MMIO_RADIO_DATA_LOW);
 		b43_write16(dev, B43_MMIO_RADIO_CONTROL, B43_RADIOCTL_ID);
-		tmp |= b43_read16(dev, B43_MMIO_RADIO_DATA_LOW);
+		tmp |= (u32)b43_read16(dev, B43_MMIO_RADIO_DATA_HIGH) << 16;
 	}
 	radio_manuf = (tmp & 0x00000FFF);
 	radio_ver = (tmp & 0x0FFFF000) >> 12;
 	radio_rev = (tmp & 0xF0000000) >> 28;
 	if (radio_manuf != 0x17F /* Broadcom */)
 		unsupported = 1;
@@ -3164,13 +3163,13 @@ static int b43_phy_versioning(struct b43
 		break;
 	case B43_PHYTYPE_G:
 		if (radio_ver != 0x2050)
 			unsupported = 1;
 		break;
 	case B43_PHYTYPE_N:
-		if (radio_ver != 5)
+		if (radio_ver != 0x2055)
 			unsupported = 1;
 		break;
 	default:
 		B43_WARN_ON(1);
 	}
 	if (unsupported) {


From mb at bu3sch.de  Sun Jan 13 14:20:52 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 13 Jan 2008 14:20:52 +0100
Subject: [PATCH] b43: Add support for new firmware
Message-ID: <200801131420.52995.mb@bu3sch.de>

This patch adds support for new firmware.
Old firmware is still supported until July 2008.

To get new firmware, go to
ftp://ftp.linksys.com/opensourcecode/wrt150nv11/1.51.3/
and download the tarball. We don't have a smaller tarball, yet.
That will be fixed later.
You can extract firmware out of the "wl_ap.o" file contained
in this tarball using latest fwcutter. You must pass the option
--unsupported to fwcutter.
Fwcutter-010 with official support for a new firmware image will
be released soon.

---

For 2.6.25

Index: wireless-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/dma.c	2008-01-13 13:26:18.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/dma.c	2008-01-13 14:14:29.000000000 +0100
@@ -804,44 +804,43 @@ struct b43_dmaring *b43_setup_dmaring(st
 	ring->meta = kcalloc(nr_slots, sizeof(struct b43_dmadesc_meta),
 			     GFP_KERNEL);
 	if (!ring->meta)
 		goto err_kfree_ring;
 	if (for_tx) {
 		ring->txhdr_cache = kcalloc(nr_slots,
-					    sizeof(struct b43_txhdr_fw4),
+					    b43_txhdr_size(dev),
 					    GFP_KERNEL);
 		if (!ring->txhdr_cache)
 			goto err_kfree_meta;
 
 		/* test for ability to dma to txhdr_cache */
 		dma_test = dma_map_single(dev->dev->dev,
 					  ring->txhdr_cache,
-					  sizeof(struct b43_txhdr_fw4),
+					  b43_txhdr_size(dev),
 					  DMA_TO_DEVICE);
 
 		if (dma_mapping_error(dma_test)) {
 			/* ugh realloc */
 			kfree(ring->txhdr_cache);
 			ring->txhdr_cache = kcalloc(nr_slots,
-						    sizeof(struct
-							   b43_txhdr_fw4),
+						    b43_txhdr_size(dev),
 						    GFP_KERNEL | GFP_DMA);
 			if (!ring->txhdr_cache)
 				goto err_kfree_meta;
 
 			dma_test = dma_map_single(dev->dev->dev,
 						  ring->txhdr_cache,
-						  sizeof(struct b43_txhdr_fw4),
+						  b43_txhdr_size(dev),
 						  DMA_TO_DEVICE);
 
 			if (dma_mapping_error(dma_test))
 				goto err_kfree_txhdr_cache;
 		}
 
 		dma_unmap_single(dev->dev->dev,
-				 dma_test, sizeof(struct b43_txhdr_fw4),
+				 dma_test, b43_txhdr_size(dev),
 				 DMA_TO_DEVICE);
 	}
 
 	ring->dev = dev;
 	ring->nr_slots = nr_slots;
 	ring->mmio_base = b43_dmacontroller_base(dma64, controller_index);
@@ -1119,32 +1118,33 @@ static int dma_tx_fragment(struct b43_dm
 	int err;
 	struct b43_dmadesc_generic *desc;
 	struct b43_dmadesc_meta *meta;
 	struct b43_dmadesc_meta *meta_hdr;
 	struct sk_buff *bounce_skb;
 	u16 cookie;
+	size_t hdrsize = b43_txhdr_size(ring->dev);
 
 #define SLOTS_PER_PACKET  2
 	B43_WARN_ON(skb_shinfo(skb)->nr_frags);
 
 	/* Get a slot for the header. */
 	slot = request_slot(ring);
 	desc = ops->idx2desc(ring, slot, &meta_hdr);
 	memset(meta_hdr, 0, sizeof(*meta_hdr));
 
-	header = &(ring->txhdr_cache[slot * sizeof(struct b43_txhdr_fw4)]);
+	header = &(ring->txhdr_cache[slot * hdrsize]);
 	cookie = generate_cookie(ring, slot);
 	b43_generate_txhdr(ring->dev, header,
 			   skb->data, skb->len, ctl, cookie);
 
 	meta_hdr->dmaaddr = map_descbuffer(ring, (unsigned char *)header,
-					   sizeof(struct b43_txhdr_fw4), 1);
+					   hdrsize, 1);
 	if (dma_mapping_error(meta_hdr->dmaaddr))
 		return -EIO;
 	ops->fill_descriptor(ring, desc, meta_hdr->dmaaddr,
-			     sizeof(struct b43_txhdr_fw4), 1, 0, 0);
+			     hdrsize, 1, 0, 0);
 
 	/* Get a slot for the payload. */
 	slot = request_slot(ring);
 	desc = ops->idx2desc(ring, slot, &meta);
 	memset(meta, 0, sizeof(*meta));
 
@@ -1186,13 +1186,13 @@ static int dma_tx_fragment(struct b43_dm
 	return 0;
 
 out_free_bounce:
 	dev_kfree_skb_any(skb);
 out_unmap_hdr:
 	unmap_descbuffer(ring, meta_hdr->dmaaddr,
-			 sizeof(struct b43_txhdr_fw4), 1);
+			 hdrsize, 1);
 	return err;
 }
 
 static inline int should_inject_overflow(struct b43_dmaring *ring)
 {
 #ifdef CONFIG_B43_DEBUG
@@ -1295,13 +1295,13 @@ void b43_dma_handle_txstatus(struct b43_
 
 		if (meta->skb)
 			unmap_descbuffer(ring, meta->dmaaddr, meta->skb->len,
 					 1);
 		else
 			unmap_descbuffer(ring, meta->dmaaddr,
-					 sizeof(struct b43_txhdr_fw4), 1);
+					 b43_txhdr_size(dev), 1);
 
 		if (meta->is_last_fragment) {
 			B43_WARN_ON(!meta->skb);
 			/* Call back to inform the ieee80211 subsystem about the
 			 * status of the transmission.
 			 * Some fields of txstat are already filled in dma_tx().
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-13 13:59:27.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-13 14:14:29.000000000 +0100
@@ -1566,17 +1566,23 @@ static void b43_release_firmware(struct 
 	release_firmware(dev->fw.initvals);
 	dev->fw.initvals = NULL;
 	release_firmware(dev->fw.initvals_band);
 	dev->fw.initvals_band = NULL;
 }
 
-static void b43_print_fw_helptext(struct b43_wl *wl)
+static void b43_print_fw_helptext(struct b43_wl *wl, bool error)
 {
-	b43err(wl, "You must go to "
+	const char *text;
+
+	text = "You must go to "
 	       "http://linuxwireless.org/en/users/Drivers/b43#devicefirmware "
-	       "and download the correct firmware (version 4).\n");
+	       "and download the latest firmware (version 4).\n";
+	if (error)
+		b43err(wl, text);
+	else
+		b43warn(wl, text);
 }
 
 static int do_request_fw(struct b43_wldev *dev,
 			 const char *name,
 			 const struct firmware **fw)
 {
@@ -1722,13 +1728,13 @@ static int b43_request_firmware(struct b
 			goto err_load;
 	}
 
 	return 0;
 
 err_load:
-	b43_print_fw_helptext(dev->wl);
+	b43_print_fw_helptext(dev->wl, 1);
 	goto error;
 
 err_no_ucode:
 	err = -ENODEV;
 	b43err(dev->wl, "No microcode available for core rev %u\n", rev);
 	goto error;
@@ -1792,13 +1798,13 @@ static int b43_upload_microcode(struct b
 		tmp = b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);
 		if (tmp == B43_IRQ_MAC_SUSPENDED)
 			break;
 		i++;
 		if (i >= 50) {
 			b43err(dev->wl, "Microcode not responding\n");
-			b43_print_fw_helptext(dev->wl);
+			b43_print_fw_helptext(dev->wl, 1);
 			err = -ENODEV;
 			goto out;
 		}
 		udelay(10);
 	}
 	b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);	/* dummy read */
@@ -1810,13 +1816,13 @@ static int b43_upload_microcode(struct b
 	fwtime = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_UCODETIME);
 
 	if (fwrev <= 0x128) {
 		b43err(dev->wl, "YOUR FIRMWARE IS TOO OLD. Firmware from "
 		       "binary drivers older than version 4.x is unsupported. "
 		       "You must upgrade your firmware files.\n");
-		b43_print_fw_helptext(dev->wl);
+		b43_print_fw_helptext(dev->wl, 1);
 		b43_write32(dev, B43_MMIO_MACCTL, 0);
 		err = -EOPNOTSUPP;
 		goto out;
 	}
 	b43dbg(dev->wl, "Loading firmware version %u.%u "
 	       "(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\n",
@@ -1824,13 +1830,19 @@ static int b43_upload_microcode(struct b
 	       (fwdate >> 12) & 0xF, (fwdate >> 8) & 0xF, fwdate & 0xFF,
 	       (fwtime >> 11) & 0x1F, (fwtime >> 5) & 0x3F, fwtime & 0x1F);
 
 	dev->fw.rev = fwrev;
 	dev->fw.patch = fwpatch;
 
-      out:
+	if (b43_is_old_txhdr_format(dev)) {
+		b43warn(dev->wl, "You are using an old firmware image. "
+			"Support for old firmware will be removed in July 2008.\n");
+		b43_print_fw_helptext(dev->wl, 0);
+	}
+
+out:
 	return err;
 }
 
 static int b43_write_initvals(struct b43_wldev *dev,
 			      const struct b43_iv *ivals,
 			      size_t count,
@@ -1884,13 +1896,13 @@ static int b43_write_initvals(struct b43
 		goto err_format;
 
 	return 0;
 
 err_format:
 	b43err(dev->wl, "Initial Values Firmware file-format error.\n");
-	b43_print_fw_helptext(dev->wl);
+	b43_print_fw_helptext(dev->wl, 1);
 
 	return -EPROTO;
 }
 
 static int b43_upload_initvals(struct b43_wldev *dev)
 {
@@ -2146,37 +2158,43 @@ static void b43_mgmtframe_txantenna(stru
 {
 	u16 ant = 0;
 	u16 tmp;
 
 	switch (antenna) {
 	case B43_ANTENNA0:
-		ant |= B43_TX4_PHY_ANT0;
+		ant |= B43_TXH_PHY_ANT0;
 		break;
 	case B43_ANTENNA1:
-		ant |= B43_TX4_PHY_ANT1;
+		ant |= B43_TXH_PHY_ANT1;
+		break;
+	case B43_ANTENNA2:
+		ant |= B43_TXH_PHY_ANT2;
+		break;
+	case B43_ANTENNA3:
+		ant |= B43_TXH_PHY_ANT3;
 		break;
 	case B43_ANTENNA_AUTO:
-		ant |= B43_TX4_PHY_ANTLAST;
+		ant |= B43_TXH_PHY_ANT01AUTO;
 		break;
 	default:
 		B43_WARN_ON(1);
 	}
 
 	/* FIXME We also need to set the other flags of the PHY control field somewhere. */
 
 	/* For Beacons */
 	tmp = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
-	tmp = (tmp & ~B43_TX4_PHY_ANT) | ant;
+	tmp = (tmp & ~B43_TXH_PHY_ANT) | ant;
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL, tmp);
 	/* For ACK/CTS */
 	tmp = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_ACKCTSPHYCTL);
-	tmp = (tmp & ~B43_TX4_PHY_ANT) | ant;
+	tmp = (tmp & ~B43_TXH_PHY_ANT) | ant;
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_ACKCTSPHYCTL, tmp);
 	/* For Probe Resposes */
 	tmp = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_PRPHYCTL);
-	tmp = (tmp & ~B43_TX4_PHY_ANT) | ant;
+	tmp = (tmp & ~B43_TXH_PHY_ANT) | ant;
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PRPHYCTL, tmp);
 }
 
 /* This is the opposite of b43_chip_init() */
 static void b43_chip_exit(struct b43_wldev *dev)
 {
@@ -2735,12 +2753,16 @@ static int b43_antenna_from_ieee80211(st
 	case 0:		/* default/diversity */
 		return B43_ANTENNA_DEFAULT;
 	case 1:		/* Antenna 0 */
 		return B43_ANTENNA0;
 	case 2:		/* Antenna 1 */
 		return B43_ANTENNA1;
+	case 3:		/* Antenna 2 */
+		return B43_ANTENNA2;
+	case 4:		/* Antenna 3 */
+		return B43_ANTENNA3;
 	default:
 		return B43_ANTENNA_DEFAULT;
 	}
 }
 
 static int b43_op_config(struct ieee80211_hw *hw, struct ieee80211_conf *conf)
Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c	2008-01-13 13:26:18.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/xmit.c	2008-01-13 14:14:29.000000000 +0100
@@ -174,19 +174,21 @@ static u8 b43_calc_fallback_rate(u8 bitr
 		return B43_OFDM_RATE_48MB;
 	}
 	B43_WARN_ON(1);
 	return 0;
 }
 
-static void generate_txhdr_fw4(struct b43_wldev *dev,
-			       struct b43_txhdr_fw4 *txhdr,
-			       const unsigned char *fragment_data,
-			       unsigned int fragment_len,
-			       const struct ieee80211_tx_control *txctl,
-			       u16 cookie)
+/* Generate a TX data header. */
+void b43_generate_txhdr(struct b43_wldev *dev,
+			u8 *_txhdr,
+			const unsigned char *fragment_data,
+			unsigned int fragment_len,
+			const struct ieee80211_tx_control *txctl,
+			u16 cookie)
 {
+	struct b43_txhdr *txhdr = (struct b43_txhdr *)_txhdr;
 	const struct b43_phy *phy = &dev->phy;
 	const struct ieee80211_hdr *wlhdr =
 	    (const struct ieee80211_hdr *)fragment_data;
 	int use_encryption = (!(txctl->flags & IEEE80211_TXCTL_DO_NOT_ENCRYPT));
 	u16 fctl = le16_to_cpu(wlhdr->frame_control);
 	u8 rate, rate_fb;
@@ -238,135 +240,177 @@ static void generate_txhdr_fw4(struct b4
 		B43_WARN_ON(!key->keyconf);
 
 		/* Hardware appends ICV. */
 		plcp_fragment_len += txctl->icv_len;
 
 		key_idx = b43_kidx_to_fw(dev, key_idx);
-		mac_ctl |= (key_idx << B43_TX4_MAC_KEYIDX_SHIFT) &
-			   B43_TX4_MAC_KEYIDX;
-		mac_ctl |= (key->algorithm << B43_TX4_MAC_KEYALG_SHIFT) &
-			   B43_TX4_MAC_KEYALG;
+		mac_ctl |= (key_idx << B43_TXH_MAC_KEYIDX_SHIFT) &
+			   B43_TXH_MAC_KEYIDX;
+		mac_ctl |= (key->algorithm << B43_TXH_MAC_KEYALG_SHIFT) &
+			   B43_TXH_MAC_KEYALG;
 		wlhdr_len = ieee80211_get_hdrlen(fctl);
 		iv_len = min((size_t) txctl->iv_len,
 			     ARRAY_SIZE(txhdr->iv));
 		memcpy(txhdr->iv, ((u8 *) wlhdr) + wlhdr_len, iv_len);
 	}
-	b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->plcp),
-			      plcp_fragment_len, rate);
+	if (b43_is_old_txhdr_format(dev)) {
+		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->old_format.plcp),
+				      plcp_fragment_len, rate);
+	} else {
+		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->new_format.plcp),
+				      plcp_fragment_len, rate);
+	}
 	b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->plcp_fb),
 			      plcp_fragment_len, rate_fb);
 
 	/* Extra Frame Types */
 	if (rate_fb_ofdm)
-		extra_ft |= B43_TX4_EFT_FBOFDM;
+		extra_ft |= B43_TXH_EFT_FB_OFDM;
+	else
+		extra_ft |= B43_TXH_EFT_FB_CCK;
 
 	/* Set channel radio code. Note that the micrcode ORs 0x100 to
 	 * this value before comparing it to the value in SHM, if this
 	 * is a 5Ghz packet.
 	 */
 	txhdr->chan_radio_code = phy->channel;
 
 	/* PHY TX Control word */
 	if (rate_ofdm)
-		phy_ctl |= B43_TX4_PHY_OFDM;
+		phy_ctl |= B43_TXH_PHY_ENC_OFDM;
+	else
+		phy_ctl |= B43_TXH_PHY_ENC_CCK;
 	if (dev->short_preamble)
-		phy_ctl |= B43_TX4_PHY_SHORTPRMBL;
+		phy_ctl |= B43_TXH_PHY_SHORTPRMBL;
 
 	switch (b43_ieee80211_antenna_sanitize(dev, txctl->antenna_sel_tx)) {
 	case 0: /* Default */
-		phy_ctl |= B43_TX4_PHY_ANTLAST;
+		phy_ctl |= B43_TXH_PHY_ANT01AUTO;
 		break;
 	case 1: /* Antenna 0 */
-		phy_ctl |= B43_TX4_PHY_ANT0;
+		phy_ctl |= B43_TXH_PHY_ANT0;
 		break;
 	case 2: /* Antenna 1 */
-		phy_ctl |= B43_TX4_PHY_ANT1;
+		phy_ctl |= B43_TXH_PHY_ANT1;
+		break;
+	case 3: /* Antenna 2 */
+		phy_ctl |= B43_TXH_PHY_ANT2;
+		break;
+	case 4: /* Antenna 3 */
+		phy_ctl |= B43_TXH_PHY_ANT3;
 		break;
 	default:
 		B43_WARN_ON(1);
 	}
 
 	/* MAC control */
 	if (!(txctl->flags & IEEE80211_TXCTL_NO_ACK))
-		mac_ctl |= B43_TX4_MAC_ACK;
+		mac_ctl |= B43_TXH_MAC_ACK;
 	if (!(((fctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_CTL) &&
 	      ((fctl & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_PSPOLL)))
-		mac_ctl |= B43_TX4_MAC_HWSEQ;
+		mac_ctl |= B43_TXH_MAC_HWSEQ;
 	if (txctl->flags & IEEE80211_TXCTL_FIRST_FRAGMENT)
-		mac_ctl |= B43_TX4_MAC_STMSDU;
+		mac_ctl |= B43_TXH_MAC_STMSDU;
 	if (phy->type == B43_PHYTYPE_A)
-		mac_ctl |= B43_TX4_MAC_5GHZ;
+		mac_ctl |= B43_TXH_MAC_5GHZ;
 	if (txctl->flags & IEEE80211_TXCTL_LONG_RETRY_LIMIT)
-		mac_ctl |= B43_TX4_MAC_LONGFRAME;
+		mac_ctl |= B43_TXH_MAC_LONGFRAME;
 
 	/* Generate the RTS or CTS-to-self frame */
 	if ((txctl->flags & IEEE80211_TXCTL_USE_RTS_CTS) ||
 	    (txctl->flags & IEEE80211_TXCTL_USE_CTS_PROTECT)) {
 		unsigned int len;
 		struct ieee80211_hdr *hdr;
 		int rts_rate, rts_rate_fb;
 		int rts_rate_ofdm, rts_rate_fb_ofdm;
+		struct b43_plcp_hdr6 *plcp;
 
 		rts_rate = txctl->rts_cts_rate;
 		rts_rate_ofdm = b43_is_ofdm_rate(rts_rate);
 		rts_rate_fb = b43_calc_fallback_rate(rts_rate);
 		rts_rate_fb_ofdm = b43_is_ofdm_rate(rts_rate_fb);
 
 		if (txctl->flags & IEEE80211_TXCTL_USE_CTS_PROTECT) {
+			struct ieee80211_cts *cts;
+
+			if (b43_is_old_txhdr_format(dev)) {
+				cts = (struct ieee80211_cts *)
+					(txhdr->old_format.rts_frame);
+			} else {
+				cts = (struct ieee80211_cts *)
+					(txhdr->new_format.rts_frame);
+			}
 			ieee80211_ctstoself_get(dev->wl->hw, txctl->vif,
 						fragment_data, fragment_len,
-						txctl,
-						(struct ieee80211_cts *)(txhdr->
-									 rts_frame));
-			mac_ctl |= B43_TX4_MAC_SENDCTS;
+						txctl, cts);
+			mac_ctl |= B43_TXH_MAC_SENDCTS;
 			len = sizeof(struct ieee80211_cts);
 		} else {
+			struct ieee80211_rts *rts;
+
+			if (b43_is_old_txhdr_format(dev)) {
+				rts = (struct ieee80211_rts *)
+					(txhdr->old_format.rts_frame);
+			} else {
+				rts = (struct ieee80211_rts *)
+					(txhdr->new_format.rts_frame);
+			}
 			ieee80211_rts_get(dev->wl->hw, txctl->vif,
-					  fragment_data, fragment_len, txctl,
-					  (struct ieee80211_rts *)(txhdr->
-								   rts_frame));
-			mac_ctl |= B43_TX4_MAC_SENDRTS;
+					  fragment_data, fragment_len,
+					  txctl, rts);
+			mac_ctl |= B43_TXH_MAC_SENDRTS;
 			len = sizeof(struct ieee80211_rts);
 		}
 		len += FCS_LEN;
-		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->
-							       rts_plcp), len,
-				      rts_rate);
-		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->
-							       rts_plcp_fb),
+
+		/* Generate the PLCP headers for the RTS/CTS frame */
+		if (b43_is_old_txhdr_format(dev))
+			plcp = &txhdr->old_format.rts_plcp;
+		else
+			plcp = &txhdr->new_format.rts_plcp;
+		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)plcp,
+				      len, rts_rate);
+		plcp = &txhdr->rts_plcp_fb;
+		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)plcp,
 				      len, rts_rate_fb);
-		hdr = (struct ieee80211_hdr *)(&txhdr->rts_frame);
+
+		if (b43_is_old_txhdr_format(dev)) {
+			hdr = (struct ieee80211_hdr *)
+				(&txhdr->old_format.rts_frame);
+		} else {
+			hdr = (struct ieee80211_hdr *)
+				(&txhdr->new_format.rts_frame);
+		}
 		txhdr->rts_dur_fb = hdr->duration_id;
+
 		if (rts_rate_ofdm) {
-			extra_ft |= B43_TX4_EFT_RTSOFDM;
+			extra_ft |= B43_TXH_EFT_RTS_OFDM;
 			txhdr->phy_rate_rts =
 			    b43_plcp_get_ratecode_ofdm(rts_rate);
-		} else
+		} else {
+			extra_ft |= B43_TXH_EFT_RTS_CCK;
 			txhdr->phy_rate_rts =
 			    b43_plcp_get_ratecode_cck(rts_rate);
+		}
 		if (rts_rate_fb_ofdm)
-			extra_ft |= B43_TX4_EFT_RTSFBOFDM;
+			extra_ft |= B43_TXH_EFT_RTSFB_OFDM;
+		else
+			extra_ft |= B43_TXH_EFT_RTSFB_CCK;
 	}
 
 	/* Magic cookie */
-	txhdr->cookie = cpu_to_le16(cookie);
+	if (b43_is_old_txhdr_format(dev))
+		txhdr->old_format.cookie = cpu_to_le16(cookie);
+	else
+		txhdr->new_format.cookie = cpu_to_le16(cookie);
 
 	/* Apply the bitfields */
 	txhdr->mac_ctl = cpu_to_le32(mac_ctl);
 	txhdr->phy_ctl = cpu_to_le16(phy_ctl);
 	txhdr->extra_ft = extra_ft;
-}
 
-void b43_generate_txhdr(struct b43_wldev *dev,
-			u8 * txhdr,
-			const unsigned char *fragment_data,
-			unsigned int fragment_len,
-			const struct ieee80211_tx_control *txctl, u16 cookie)
-{
-	generate_txhdr_fw4(dev, (struct b43_txhdr_fw4 *)txhdr,
-			   fragment_data, fragment_len, txctl, cookie);
 }
 
 static s8 b43_rssi_postprocess(struct b43_wldev *dev,
 			       u8 in_rssi, int ofdm,
 			       int adjust_2053, int adjust_2050)
 {
Index: wireless-2.6/drivers/net/wireless/b43/xmit.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.h	2008-01-13 13:26:18.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/xmit.h	2008-01-13 14:14:29.000000000 +0100
@@ -16,74 +16,166 @@ _b43_declare_plcp_hdr(4);
 /* struct b43_plcp_hdr6 */
 _b43_declare_plcp_hdr(6);
 
 #undef _b43_declare_plcp_hdr
 
 /* TX header for v4 firmware */
-struct b43_txhdr_fw4 {
-	__le32 mac_ctl;		/* MAC TX control */
-	__le16 mac_frame_ctl;	/* Copy of the FrameControl field */
+struct b43_txhdr {
+	__le32 mac_ctl;			/* MAC TX control */
+	__le16 mac_frame_ctl;		/* Copy of the FrameControl field */
 	__le16 tx_fes_time_norm;	/* TX FES Time Normal */
-	__le16 phy_ctl;		/* PHY TX control */
-	__le16 phy_ctl_0;	/* Unused */
-	__le16 phy_ctl_1;	/* Unused */
-	__le16 phy_ctl_rts_0;	/* Unused */
-	__le16 phy_ctl_rts_1;	/* Unused */
-	__u8 phy_rate;		/* PHY rate */
-	__u8 phy_rate_rts;	/* PHY rate for RTS/CTS */
-	__u8 extra_ft;		/* Extra Frame Types */
-	__u8 chan_radio_code;	/* Channel Radio Code */
-	__u8 iv[16];		/* Encryption IV */
-	__u8 tx_receiver[6];	/* TX Frame Receiver address */
-	__le16 tx_fes_time_fb;	/* TX FES Time Fallback */
-	struct b43_plcp_hdr6 rts_plcp_fb;	/* RTS fallback PLCP */
-	__le16 rts_dur_fb;	/* RTS fallback duration */
-	struct b43_plcp_hdr6 plcp_fb;	/* Fallback PLCP */
-	__le16 dur_fb;		/* Fallback duration */
-	__le16 mm_dur_time;	/* Unused */
-	__le16 mm_dur_time_fb;	/* Unused */
-	__le32 time_stamp;	/* Timestamp */
-	 PAD_BYTES(2);
-	__le16 cookie;		/* TX frame cookie */
-	__le16 tx_status;	/* TX status */
-	struct b43_plcp_hdr6 rts_plcp;	/* RTS PLCP */
-	__u8 rts_frame[16];	/* The RTS frame (if used) */
-	 PAD_BYTES(2);
-	struct b43_plcp_hdr6 plcp;	/* Main PLCP */
+	__le16 phy_ctl;			/* PHY TX control */
+	__le16 phy_ctl1;		/* PHY TX control word 1 */
+	__le16 phy_ctl1_fb;		/* PHY TX control word 1 for fallback rates */
+	__le16 phy_ctl1_rts;		/* PHY TX control word 1 RTS */
+	__le16 phy_ctl1_rts_fb;		/* PHY TX control word 1 RTS for fallback rates */
+	__u8 phy_rate;			/* PHY rate */
+	__u8 phy_rate_rts;		/* PHY rate for RTS/CTS */
+	__u8 extra_ft;			/* Extra Frame Types */
+	__u8 chan_radio_code;		/* Channel Radio Code */
+	__u8 iv[16];			/* Encryption IV */
+	__u8 tx_receiver[6];		/* TX Frame Receiver address */
+	__le16 tx_fes_time_fb;		/* TX FES Time Fallback */
+	struct b43_plcp_hdr6 rts_plcp_fb; /* RTS fallback PLCP header */
+	__le16 rts_dur_fb;		/* RTS fallback duration */
+	struct b43_plcp_hdr6 plcp_fb;	/* Fallback PLCP header */
+	__le16 dur_fb;			/* Fallback duration */
+	__le16 mimo_modelen;		/* MIMO mode length */
+	__le16 mimo_ratelen_fb;		/* MIMO fallback rate length */
+	__le32 timeout;			/* Timeout */
+
+	union {
+		/* The new r410 format. */
+		struct {
+			__le16 mimo_antenna;		/* MIMO antenna select */
+			__le16 preload_size;		/* Preload size */
+			PAD_BYTES(2);
+			__le16 cookie;			/* TX frame cookie */
+			__le16 tx_status;		/* TX status */
+			struct b43_plcp_hdr6 rts_plcp;	/* RTS PLCP header */
+			__u8 rts_frame[16];		/* The RTS frame (if used) */
+			PAD_BYTES(2);
+			struct b43_plcp_hdr6 plcp;	/* Main PLCP header */
+		} new_format __attribute__ ((__packed__));
+
+		/* The old r351 format. */
+		struct {
+			PAD_BYTES(2);
+			__le16 cookie;			/* TX frame cookie */
+			__le16 tx_status;		/* TX status */
+			struct b43_plcp_hdr6 rts_plcp;	/* RTS PLCP header */
+			__u8 rts_frame[16];		/* The RTS frame (if used) */
+			PAD_BYTES(2);
+			struct b43_plcp_hdr6 plcp;	/* Main PLCP header */
+		} old_format __attribute__ ((__packed__));
+
+	} __attribute__ ((__packed__));
 } __attribute__ ((__packed__));
 
 /* MAC TX control */
-#define B43_TX4_MAC_KEYIDX		0x0FF00000	/* Security key index */
-#define B43_TX4_MAC_KEYIDX_SHIFT	20
-#define B43_TX4_MAC_KEYALG		0x00070000	/* Security key algorithm */
-#define B43_TX4_MAC_KEYALG_SHIFT	16
-#define B43_TX4_MAC_LIFETIME	0x00001000
-#define B43_TX4_MAC_FRAMEBURST	0x00000800
-#define B43_TX4_MAC_SENDCTS		0x00000400
-#define B43_TX4_MAC_AMPDU		0x00000300
-#define B43_TX4_MAC_AMPDU_SHIFT	8
-#define B43_TX4_MAC_5GHZ		0x00000080
-#define B43_TX4_MAC_IGNPMQ		0x00000020
-#define B43_TX4_MAC_HWSEQ		0x00000010	/* Use Hardware Sequence Number */
-#define B43_TX4_MAC_STMSDU		0x00000008	/* Start MSDU */
-#define B43_TX4_MAC_SENDRTS		0x00000004
-#define B43_TX4_MAC_LONGFRAME	0x00000002
-#define B43_TX4_MAC_ACK		0x00000001
+#define B43_TXH_MAC_USEFBR		0x10000000 /* Use fallback rate for this AMPDU */
+#define B43_TXH_MAC_KEYIDX		0x0FF00000 /* Security key index */
+#define B43_TXH_MAC_KEYIDX_SHIFT	20
+#define B43_TXH_MAC_KEYALG		0x00070000 /* Security key algorithm */
+#define B43_TXH_MAC_KEYALG_SHIFT	16
+#define B43_TXH_MAC_AMIC		0x00008000 /* AMIC */
+#define B43_TXH_MAC_RIFS		0x00004000 /* Use RIFS */
+#define B43_TXH_MAC_LIFETIME		0x00002000 /* Lifetime */
+#define B43_TXH_MAC_FRAMEBURST		0x00001000 /* Frameburst */
+#define B43_TXH_MAC_SENDCTS		0x00000800 /* Send CTS-to-self */
+#define B43_TXH_MAC_AMPDU		0x00000600 /* AMPDU status */
+#define  B43_TXH_MAC_AMPDU_MPDU		0x00000000 /* Regular MPDU, not an AMPDU */
+#define  B43_TXH_MAC_AMPDU_FIRST	0x00000200 /* First MPDU or AMPDU */
+#define  B43_TXH_MAC_AMPDU_INTER	0x00000400 /* Intermediate MPDU or AMPDU */
+#define  B43_TXH_MAC_AMPDU_LAST		0x00000600 /* Last (or only) MPDU of AMPDU */
+#define B43_TXH_MAC_40MHZ		0x00000100 /* Use 40 MHz bandwidth */
+#define B43_TXH_MAC_5GHZ		0x00000080 /* 5GHz band */
+#define B43_TXH_MAC_DFCS		0x00000040 /* DFCS */
+#define B43_TXH_MAC_IGNPMQ		0x00000020 /* Ignore PMQ */
+#define B43_TXH_MAC_HWSEQ		0x00000010 /* Use Hardware Sequence Number */
+#define B43_TXH_MAC_STMSDU		0x00000008 /* Start MSDU */
+#define B43_TXH_MAC_SENDRTS		0x00000004 /* Send RTS */
+#define B43_TXH_MAC_LONGFRAME		0x00000002 /* Long frame */
+#define B43_TXH_MAC_ACK			0x00000001 /* Immediate ACK */
 
 /* Extra Frame Types */
-#define B43_TX4_EFT_FBOFDM		0x0001	/* Data frame fallback rate type */
-#define B43_TX4_EFT_RTSOFDM		0x0004	/* RTS/CTS rate type */
-#define B43_TX4_EFT_RTSFBOFDM	0x0010	/* RTS/CTS fallback rate type */
+#define B43_TXH_EFT_FB			0x03 /* Data frame fallback encoding */
+#define  B43_TXH_EFT_FB_CCK		0x00 /* CCK */
+#define  B43_TXH_EFT_FB_OFDM		0x01 /* OFDM */
+#define  B43_TXH_EFT_FB_EWC		0x02 /* EWC */
+#define  B43_TXH_EFT_FB_N		0x03 /* N */
+#define B43_TXH_EFT_RTS			0x0C /* RTS/CTS encoding */
+#define  B43_TXH_EFT_RTS_CCK		0x00 /* CCK */
+#define  B43_TXH_EFT_RTS_OFDM		0x04 /* OFDM */
+#define  B43_TXH_EFT_RTS_EWC		0x08 /* EWC */
+#define  B43_TXH_EFT_RTS_N		0x0C /* N */
+#define B43_TXH_EFT_RTSFB		0x30 /* RTS/CTS fallback encoding */
+#define  B43_TXH_EFT_RTSFB_CCK		0x00 /* CCK */
+#define  B43_TXH_EFT_RTSFB_OFDM		0x10 /* OFDM */
+#define  B43_TXH_EFT_RTSFB_EWC		0x20 /* EWC */
+#define  B43_TXH_EFT_RTSFB_N		0x30 /* N */
 
 /* PHY TX control word */
-#define B43_TX4_PHY_OFDM		0x0001	/* Data frame rate type */
-#define B43_TX4_PHY_SHORTPRMBL	0x0010	/* Use short preamble */
-#define B43_TX4_PHY_ANT		0x03C0	/* Antenna selection */
-#define  B43_TX4_PHY_ANT0		0x0000	/* Use antenna 0 */
-#define  B43_TX4_PHY_ANT1		0x0100	/* Use antenna 1 */
-#define  B43_TX4_PHY_ANTLAST	0x0300	/* Use last used antenna */
+#define B43_TXH_PHY_ENC			0x0003 /* Data frame encoding */
+#define  B43_TXH_PHY_ENC_CCK		0x0000 /* CCK */
+#define  B43_TXH_PHY_ENC_OFDM		0x0001 /* OFDM */
+#define  B43_TXH_PHY_ENC_EWC		0x0002 /* EWC */
+#define  B43_TXH_PHY_ENC_N		0x0003 /* N */
+#define B43_TXH_PHY_SHORTPRMBL		0x0010 /* Use short preamble */
+#define B43_TXH_PHY_ANT			0x03C0 /* Antenna selection */
+#define  B43_TXH_PHY_ANT0		0x0000 /* Use antenna 0 */
+#define  B43_TXH_PHY_ANT1		0x0040 /* Use antenna 1 */
+#define  B43_TXH_PHY_ANT01AUTO		0x00C0 /* Use antenna 0/1 auto */
+#define  B43_TXH_PHY_ANT2		0x0100 /* Use antenna 2 */
+#define  B43_TXH_PHY_ANT3		0x0200 /* Use antenna 3 */
+#define B43_TXH_PHY_TXPWR		0xFC00 /* TX power */
+#define B43_TXH_PHY_TXPWR_SHIFT		10
+
+/* PHY TX control word 1 */
+#define B43_TXH_PHY1_BW			0x0007 /* Bandwidth */
+#define  B43_TXH_PHY1_BW_10		0x0000 /* 10 MHz */
+#define  B43_TXH_PHY1_BW_10U		0x0001 /* 10 MHz upper */
+#define  B43_TXH_PHY1_BW_20		0x0002 /* 20 MHz */
+#define  B43_TXH_PHY1_BW_20U		0x0003 /* 20 MHz upper */
+#define  B43_TXH_PHY1_BW_40		0x0004 /* 40 MHz */
+#define  B43_TXH_PHY1_BW_40DUP		0x0005 /* 50 MHz duplicate */
+#define B43_TXH_PHY1_MODE		0x0038 /* Mode */
+#define  B43_TXH_PHY1_MODE_SISO		0x0000 /* SISO */
+#define  B43_TXH_PHY1_MODE_CDD		0x0008 /* CDD */
+#define  B43_TXH_PHY1_MODE_STBC		0x0010 /* STBC */
+#define  B43_TXH_PHY1_MODE_SDM		0x0018 /* SDM */
+#define B43_TXH_PHY1_CRATE		0x0700 /* Coding rate */
+#define  B43_TXH_PHY1_CRATE_1_2		0x0000 /* 1/2 */
+#define  B43_TXH_PHY1_CRATE_2_3		0x0100 /* 2/3 */
+#define  B43_TXH_PHY1_CRATE_3_4		0x0200 /* 3/4 */
+#define  B43_TXH_PHY1_CRATE_4_5		0x0300 /* 4/5 */
+#define  B43_TXH_PHY1_CRATE_5_6		0x0400 /* 5/6 */
+#define  B43_TXH_PHY1_CRATE_7_8		0x0600 /* 7/8 */
+#define B43_TXH_PHY1_MODUL		0x3800 /* Modulation scheme */
+#define  B43_TXH_PHY1_MODUL_BPSK	0x0000 /* BPSK */
+#define  B43_TXH_PHY1_MODUL_QPSK	0x0800 /* QPSK */
+#define  B43_TXH_PHY1_MODUL_QAM16	0x1000 /* QAM16 */
+#define  B43_TXH_PHY1_MODUL_QAM64	0x1800 /* QAM64 */
+#define  B43_TXH_PHY1_MODUL_QAM256	0x2000 /* QAM256 */
+
+
+/* r351 firmware compatibility stuff. */
+static inline
+bool b43_is_old_txhdr_format(struct b43_wldev *dev)
+{
+	return (dev->fw.rev <= 351);
+}
+
+static inline
+size_t b43_txhdr_size(struct b43_wldev *dev)
+{
+	if (b43_is_old_txhdr_format(dev))
+		return 100 + sizeof(struct b43_plcp_hdr6);
+	return 104 + sizeof(struct b43_plcp_hdr6);
+}
+
 
 void b43_generate_txhdr(struct b43_wldev *dev,
 			u8 * txhdr,
 			const unsigned char *fragment_data,
 			unsigned int fragment_len,
 			const struct ieee80211_tx_control *txctl, u16 cookie);
Index: wireless-2.6/Documentation/feature-removal-schedule.txt
===================================================================
--- wireless-2.6.orig/Documentation/feature-removal-schedule.txt	2008-01-13 13:26:18.000000000 +0100
+++ wireless-2.6/Documentation/feature-removal-schedule.txt	2008-01-13 14:14:29.000000000 +0100
@@ -355,6 +355,15 @@ What:	rc80211-simple rate control algori
 When:	2.6.26
 Files:	net/mac80211/rc80211-simple.c
 Why:	This algorithm was provided for reference but always exhibited bad
 	responsiveness and performance and has some serious flaws. It has been
 	replaced by rc80211-pid.
 Who:	Stefano Brivio <stefano.brivio at polimi.it>
+
+---------------------------
+
+What:	b43 support for firmware revision < 410
+When:	July 2008
+Why:	The support code for the old firmware hurts code readability/maintainability
+	and slightly hurts runtime performance. Bugfixes for the old firmware
+	are not provided by Broadcom anymore.
+Who:	Michael Buesch <mb at bu3sch.de>
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h	2008-01-13 13:26:18.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/phy.h	2008-01-13 14:14:29.000000000 +0100
@@ -177,12 +177,14 @@ void b43_gtab_write(struct b43_wldev *de
 
 enum {
 	B43_ANTENNA0,		/* Antenna 0 */
 	B43_ANTENNA1,		/* Antenna 0 */
 	B43_ANTENNA_AUTO1,	/* Automatic, starting with antenna 1 */
 	B43_ANTENNA_AUTO0,	/* Automatic, starting with antenna 0 */
+	B43_ANTENNA2,
+	B43_ANTENNA3 = 8,
 
 	B43_ANTENNA_AUTO = B43_ANTENNA_AUTO0,
 	B43_ANTENNA_DEFAULT = B43_ANTENNA_AUTO,
 };
 
 enum {


From mb at bu3sch.de  Sun Jan 13 16:41:23 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 13 Jan 2008 16:41:23 +0100
Subject: [PATCH] b43: Add Broadcom 2055 radio register definitions
Message-ID: <200801131641.23448.mb@bu3sch.de>

Add the register definitions for the Broadcom 2055 N-radio.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.25

Index: wireless-2.6/drivers/net/wireless/b43/nphy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/nphy.h	2008-01-09 17:06:35.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/nphy.h	2008-01-13 16:39:10.000000000 +0100
@@ -696,11 +696,221 @@
 #define  B43_NPHY_FINERX2_CGC_DECGC		0x0008 /* Decode gated clocks */
 #define B43_NPHY_TXPCTL_INIT			B43_PHY_N(0x222) /* TX power controll init */
 #define  B43_NPHY_TXPCTL_INIT_PIDXI1		0x00FF /* Power index init 1 */
 #define  B43_NPHY_TXPCTL_INIT_PIDXI1_SHIFT	0
 
 
+
+/* Broadcom 2055 radio registers */
+
+#define B2055_GEN_SPARE			0x00 /* GEN spare */
+#define B2055_SP_PINPD			0x02 /* SP PIN PD */
+#define B2055_C1_SP_RSSI		0x03 /* SP RSSI Core 1 */
+#define B2055_C1_SP_PDMISC		0x04 /* SP PD MISC Core 1 */
+#define B2055_C2_SP_RSSI		0x05 /* SP RSSI Core 2 */
+#define B2055_C2_SP_PDMISC		0x06 /* SP PD MISC Core 2 */
+#define B2055_C1_SP_RXGC1		0x07 /* SP RX GC1 Core 1 */
+#define B2055_C1_SP_RXGC2		0x08 /* SP RX GC2 Core 1 */
+#define B2055_C2_SP_RXGC1		0x09 /* SP RX GC1 Core 2 */
+#define B2055_C2_SP_RXGC2		0x0A /* SP RX GC2 Core 2 */
+#define B2055_C1_SP_LPFBWSEL		0x0B /* SP LPF BW select Core 1 */
+#define B2055_C2_SP_LPFBWSEL		0x0C /* SP LPF BW select Core 2 */
+#define B2055_C1_SP_TXGC1		0x0D /* SP TX GC1 Core 1 */
+#define B2055_C1_SP_TXGC2		0x0E /* SP TX GC2 Core 1 */
+#define B2055_C2_SP_TXGC1		0x0F /* SP TX GC1 Core 2 */
+#define B2055_C2_SP_TXGC2		0x10 /* SP TX GC2 Core 2 */
+#define B2055_MASTER1			0x11 /* Master control 1 */
+#define B2055_MASTER2			0x12 /* Master control 2 */
+#define B2055_PD_LGEN			0x13 /* PD LGEN */
+#define B2055_PD_PLLTS			0x14 /* PD PLL TS */
+#define B2055_C1_PD_LGBUF		0x15 /* PD Core 1 LGBUF */
+#define B2055_C1_PD_TX			0x16 /* PD Core 1 TX */
+#define B2055_C1_PD_RXTX		0x17 /* PD Core 1 RXTX */
+#define B2055_C1_PD_RSSIMISC		0x18 /* PD Core 1 RSSI MISC */
+#define B2055_C2_PD_LGBUF		0x19 /* PD Core 2 LGBUF */
+#define B2055_C2_PD_TX			0x1A /* PD Core 2 TX */
+#define B2055_C2_PD_RXTX		0x1B /* PD Core 2 RXTX */
+#define B2055_C2_PD_RSSIMISC		0x1C /* PD Core 2 RSSI MISC */
+#define B2055_PWRDET_LGEN		0x1D /* PWRDET LGEN */
+#define B2055_C1_PWRDET_LGBUF		0x1E /* PWRDET LGBUF Core 1 */
+#define B2055_C1_PWRDET_RXTX		0x1F /* PWRDET RXTX Core 1 */
+#define B2055_C2_PWRDET_LGBUF		0x20 /* PWRDET LGBUF Core 2 */
+#define B2055_C2_PWRDET_RXTX		0x21 /* PWRDET RXTX Core 2 */
+#define B2055_RRCCAL_CS			0x22 /* RRCCAL Control spare */
+#define B2055_RRCCAL_NOPTSEL		0x23 /* RRCCAL N OPT SEL */
+#define B2055_CAL_MISC			0x24 /* CAL MISC */
+#define B2055_CAL_COUT			0x25 /* CAL Counter out */
+#define B2055_CAL_COUT2			0x26 /* CAL Counter out 2 */
+#define B2055_CAL_CVARCTL		0x27 /* CAL CVAR Control */
+#define B2055_CAL_RVARCTL		0x28 /* CAL RVAR Control */
+#define B2055_CAL_LPOCTL		0x29 /* CAL LPO Control */
+#define B2055_CAL_TS			0x2A /* CAL TS */
+#define B2055_CAL_RCCALRTS		0x2B /* CAL RCCAL READ TS */
+#define B2055_CAL_RCALRTS		0x2C /* CAL RCAL READ TS */
+#define B2055_PADDRV			0x2D /* PAD driver */
+#define B2055_XOCTL1			0x2E /* XO Control 1 */
+#define B2055_XOCTL2			0x2F /* XO Control 2 */
+#define B2055_XOREGUL			0x30 /* XO Regulator */
+#define B2055_XOMISC			0x31 /* XO misc */
+#define B2055_PLL_LFC1			0x32 /* PLL LF C1 */
+#define B2055_PLL_CALVTH		0x33 /* PLL CAL VTH */
+#define B2055_PLL_LFC2			0x34 /* PLL LF C2 */
+#define B2055_PLL_REF			0x35 /* PLL reference */
+#define B2055_PLL_LFR1			0x36 /* PLL LF R1 */
+#define B2055_PLL_PFDCP			0x37 /* PLL PFD CP */
+#define B2055_PLL_IDAC_CPOPAMP		0x38 /* PLL IDAC CPOPAMP */
+#define B2055_PLL_CPREG			0x39 /* PLL CP Regulator */
+#define B2055_PLL_RCAL			0x3A /* PLL RCAL */
+#define B2055_RF_PLLMOD0		0x3B /* RF PLL MOD0 */
+#define B2055_RF_PLLMOD1		0x3C /* RF PLL MOD1 */
+#define B2055_RF_MMDIDAC1		0x3D /* RF MMD IDAC 1 */
+#define B2055_RF_MMDIDAC0		0x3E /* RF MMD IDAC 0 */
+#define B2055_RF_MMDSP			0x3F /* RF MMD spare */
+#define B2055_VCO_CAL1			0x40 /* VCO cal 1 */
+#define B2055_VCO_CAL2			0x41 /* VCO cal 2 */
+#define B2055_VCO_CAL3			0x42 /* VCO cal 3 */
+#define B2055_VCO_CAL4			0x43 /* VCO cal 4 */
+#define B2055_VCO_CAL5			0x44 /* VCO cal 5 */
+#define B2055_VCO_CAL6			0x45 /* VCO cal 6 */
+#define B2055_VCO_CAL7			0x46 /* VCO cal 7 */
+#define B2055_VCO_CAL8			0x47 /* VCO cal 8 */
+#define B2055_VCO_CAL9			0x48 /* VCO cal 9 */
+#define B2055_VCO_CAL10			0x49 /* VCO cal 10 */
+#define B2055_VCO_CAL11			0x4A /* VCO cal 11 */
+#define B2055_VCO_CAL12			0x4B /* VCO cal 12 */
+#define B2055_VCO_CAL13			0x4C /* VCO cal 13 */
+#define B2055_VCO_CAL14			0x4D /* VCO cal 14 */
+#define B2055_VCO_CAL15			0x4E /* VCO cal 15 */
+#define B2055_VCO_CAL16			0x4F /* VCO cal 16 */
+#define B2055_VCO_KVCO			0x50 /* VCO KVCO */
+#define B2055_VCO_CAPTAIL		0x51 /* VCO CAP TAIL */
+#define B2055_VCO_IDACVCO		0x52 /* VCO IDAC VCO */
+#define B2055_VCO_REG			0x53 /* VCO Regulator */
+#define B2055_PLL_RFVTH			0x54 /* PLL RF VTH */
+#define B2055_LGBUF_CENBUF		0x55 /* LGBUF CEN BUF */
+#define B2055_LGEN_TUNE1		0x56 /* LGEN tune 1 */
+#define B2055_LGEN_TUNE2		0x57 /* LGEN tune 2 */
+#define B2055_LGEN_IDAC1		0x58 /* LGEN IDAC 1 */
+#define B2055_LGEN_IDAC2		0x59 /* LGEN IDAC 2 */
+#define B2055_LGEN_BIASC		0x5A /* LGEN BIAS counter */
+#define B2055_LGEN_BIASIDAC		0x5B /* LGEN BIAS IDAC */
+#define B2055_LGEN_RCAL			0x5C /* LGEN RCAL */
+#define B2055_LGEN_DIV			0x5D /* LGEN div */
+#define B2055_LGEN_SPARE2		0x5E /* LGEN spare 2 */
+#define B2055_C1_LGBUF_ATUNE		0x5F /* Core 1 LGBUF A tune */
+#define B2055_C1_LGBUF_GTUNE		0x60 /* Core 1 LGBUF G tune */
+#define B2055_C1_LGBUF_DIV		0x61 /* Core 1 LGBUF div */
+#define B2055_C1_LGBUF_AIDAC		0x62 /* Core 1 LGBUF A IDAC */
+#define B2055_C1_LGBUF_GIDAC		0x63 /* Core 1 LGBUF G IDAC */
+#define B2055_C1_LGBUF_IDACFO		0x64 /* Core 1 LGBUF IDAC filter override */
+#define B2055_C1_LGBUF_SPARE		0x65 /* Core 1 LGBUF spare */
+#define B2055_C1_RX_RFSPC1		0x66 /* Core 1 RX RF SPC1 */
+#define B2055_C1_RX_RFR1		0x67 /* Core 1 RX RF reg 1 */
+#define B2055_C1_RX_RFR2		0x68 /* Core 1 RX RF reg 2 */
+#define B2055_C1_RX_RFRCAL		0x69 /* Core 1 RX RF RCAL */
+#define B2055_C1_RX_BB_BLCMP		0x6A /* Core 1 RX Baseband BUFI LPF CMP */
+#define B2055_C1_RX_BB_LPF		0x6B /* Core 1 RX Baseband LPF */
+#define B2055_C1_RX_BB_MIDACHP		0x6C /* Core 1 RX Baseband MIDAC High-pass */
+#define B2055_C1_RX_BB_VGA1IDAC		0x6D /* Core 1 RX Baseband VGA1 IDAC */
+#define B2055_C1_RX_BB_VGA2IDAC		0x6E /* Core 1 RX Baseband VGA2 IDAC */
+#define B2055_C1_RX_BB_VGA3IDAC		0x6F /* Core 1 RX Baseband VGA3 IDAC */
+#define B2055_C1_RX_BB_BUFOCTL		0x70 /* Core 1 RX Baseband BUFO Control */
+#define B2055_C1_RX_BB_RCCALCTL		0x71 /* Core 1 RX Baseband RCCAL Control */
+#define B2055_C1_RX_BB_RSSICTL1		0x72 /* Core 1 RX Baseband RSSI Control 1 */
+#define B2055_C1_RX_BB_RSSICTL2		0x73 /* Core 1 RX Baseband RSSI Control 2 */
+#define B2055_C1_RX_BB_RSSICTL3		0x74 /* Core 1 RX Baseband RSSI Control 3 */
+#define B2055_C1_RX_BB_RSSICTL4		0x75 /* Core 1 RX Baseband RSSI Control 4 */
+#define B2055_C1_RX_BB_RSSICTL5		0x76 /* Core 1 RX Baseband RSSI Control 5 */
+#define B2055_C1_RX_BB_REG		0x77 /* Core 1 RX Baseband Regulator */
+#define B2055_C1_RX_BB_SPARE1		0x78 /* Core 1 RX Baseband spare 1 */
+#define B2055_C1_RX_TXBBRCAL		0x79 /* Core 1 RX TX BB RCAL */
+#define B2055_C1_TX_RF_SPGA		0x7A /* Core 1 TX RF SGM PGA */
+#define B2055_C1_TX_RF_SPAD		0x7B /* Core 1 TX RF SGM PAD */
+#define B2055_C1_TX_RF_CNTPGA1		0x7C /* Core 1 TX RF counter PGA 1 */
+#define B2055_C1_TX_RF_CNTPAD1		0x7D /* Core 1 TX RF counter PAD 1 */
+#define B2055_C1_TX_RF_PGAIDAC		0x7E /* Core 1 TX RF PGA IDAC */
+#define B2055_C1_TX_PGAPADTN		0x7F /* Core 1 TX PGA PAD TN */
+#define B2055_C1_TX_PADIDAC1		0x80 /* Core 1 TX PAD IDAC 1 */
+#define B2055_C1_TX_PADIDAC2		0x81 /* Core 1 TX PAD IDAC 2 */
+#define B2055_C1_TX_MXBGTRIM		0x82 /* Core 1 TX MX B/G TRIM */
+#define B2055_C1_TX_RF_RCAL		0x83 /* Core 1 TX RF RCAL */
+#define B2055_C1_TX_RF_PADTSSI1		0x84 /* Core 1 TX RF PAD TSSI1 */
+#define B2055_C1_TX_RF_PADTSSI2		0x85 /* Core 1 TX RF PAD TSSI2 */
+#define B2055_C1_TX_RF_SPARE		0x86 /* Core 1 TX RF spare */
+#define B2055_C1_TX_RF_IQCAL1		0x87 /* Core 1 TX RF I/Q CAL 1 */
+#define B2055_C1_TX_RF_IQCAL2		0x88 /* Core 1 TX RF I/Q CAL 2 */
+#define B2055_C1_TXBB_RCCAL		0x89 /* Core 1 TXBB RC CAL Control */
+#define B2055_C1_TXBB_LPF1		0x8A /* Core 1 TXBB LPF 1 */
+#define B2055_C1_TX_VOSCNCL		0x8B /* Core 1 TX VOS CNCL */
+#define B2055_C1_TX_LPF_MXGMIDAC	0x8C /* Core 1 TX LPF MXGM IDAC */
+#define B2055_C1_TX_BB_MXGM		0x8D /* Core 1 TX BB MXGM */
+#define B2055_C2_LGBUF_ATUNE		0x8E /* Core 2 LGBUF A tune */
+#define B2055_C2_LGBUF_GTUNE		0x8F /* Core 2 LGBUF G tune */
+#define B2055_C2_LGBUF_DIV		0x90 /* Core 2 LGBUF div */
+#define B2055_C2_LGBUF_AIDAC		0x91 /* Core 2 LGBUF A IDAC */
+#define B2055_C2_LGBUF_GIDAC		0x92 /* Core 2 LGBUF G IDAC */
+#define B2055_C2_LGBUF_IDACFO		0x93 /* Core 2 LGBUF IDAC filter override */
+#define B2055_C2_LGBUF_SPARE		0x94 /* Core 2 LGBUF spare */
+#define B2055_C2_RX_RFSPC1		0x95 /* Core 2 RX RF SPC1 */
+#define B2055_C2_RX_RFR1		0x96 /* Core 2 RX RF reg 1 */
+#define B2055_C2_RX_RFR2		0x97 /* Core 2 RX RF reg 2 */
+#define B2055_C2_RX_RFRCAL		0x98 /* Core 2 RX RF RCAL */
+#define B2055_C2_RX_BB_BLCMP		0x99 /* Core 2 RX Baseband BUFI LPF CMP */
+#define B2055_C2_RX_BB_LPF		0x9A /* Core 2 RX Baseband LPF */
+#define B2055_C2_RX_BB_MIDACHP		0x9B /* Core 2 RX Baseband MIDAC High-pass */
+#define B2055_C2_RX_BB_VGA1IDAC		0x9C /* Core 2 RX Baseband VGA1 IDAC */
+#define B2055_C2_RX_BB_VGA2IDAC		0x9D /* Core 2 RX Baseband VGA2 IDAC */
+#define B2055_C2_RX_BB_VGA3IDAC		0x9E /* Core 2 RX Baseband VGA3 IDAC */
+#define B2055_C2_RX_BB_BUFOCTL		0x9F /* Core 2 RX Baseband BUFO Control */
+#define B2055_C2_RX_BB_RCCALCTL		0xA0 /* Core 2 RX Baseband RCCAL Control */
+#define B2055_C2_RX_BB_RSSICTL1		0xA1 /* Core 2 RX Baseband RSSI Control 1 */
+#define B2055_C2_RX_BB_RSSICTL2		0xA2 /* Core 2 RX Baseband RSSI Control 2 */
+#define B2055_C2_RX_BB_RSSICTL3		0xA3 /* Core 2 RX Baseband RSSI Control 3 */
+#define B2055_C2_RX_BB_RSSICTL4		0xA4 /* Core 2 RX Baseband RSSI Control 4 */
+#define B2055_C2_RX_BB_RSSICTL5		0xA5 /* Core 2 RX Baseband RSSI Control 5 */
+#define B2055_C2_RX_BB_REG		0xA6 /* Core 2 RX Baseband Regulator */
+#define B2055_C2_RX_BB_SPARE1		0xA7 /* Core 2 RX Baseband spare 1 */
+#define B2055_C2_RX_TXBBRCAL		0xA8 /* Core 2 RX TX BB RCAL */
+#define B2055_C2_TX_RF_SPGA		0xA9 /* Core 2 TX RF SGM PGA */
+#define B2055_C2_TX_RF_SPAD		0xAA /* Core 2 TX RF SGM PAD */
+#define B2055_C2_TX_RF_CNTPGA1		0xAB /* Core 2 TX RF counter PGA 1 */
+#define B2055_C2_TX_RF_CNTPAD1		0xAC /* Core 2 TX RF counter PAD 1 */
+#define B2055_C2_TX_RF_PGAIDAC		0xAD /* Core 2 TX RF PGA IDAC */
+#define B2055_C2_TX_PGAPADTN		0xAE /* Core 2 TX PGA PAD TN */
+#define B2055_C2_TX_PADIDAC1		0xAF /* Core 2 TX PAD IDAC 1 */
+#define B2055_C2_TX_PADIDAC2		0xB0 /* Core 2 TX PAD IDAC 2 */
+#define B2055_C2_TX_MXBGTRIM		0xB1 /* Core 2 TX MX B/G TRIM */
+#define B2055_C2_TX_RF_RCAL		0xB2 /* Core 2 TX RF RCAL */
+#define B2055_C2_TX_RF_PADTSSI1		0xB3 /* Core 2 TX RF PAD TSSI1 */
+#define B2055_C2_TX_RF_PADTSSI2		0xB4 /* Core 2 TX RF PAD TSSI2 */
+#define B2055_C2_TX_RF_SPARE		0xB5 /* Core 2 TX RF spare */
+#define B2055_C2_TX_RF_IQCAL1		0xB6 /* Core 2 TX RF I/Q CAL 1 */
+#define B2055_C2_TX_RF_IQCAL2		0xB7 /* Core 2 TX RF I/Q CAL 2 */
+#define B2055_C2_TXBB_RCCAL		0xB8 /* Core 2 TXBB RC CAL Control */
+#define B2055_C2_TXBB_LPF1		0xB9 /* Core 2 TXBB LPF 1 */
+#define B2055_C2_TX_VOSCNCL		0xBA /* Core 2 TX VOS CNCL */
+#define B2055_C2_TX_LPF_MXGMIDAC	0xBB /* Core 2 TX LPF MXGM IDAC */
+#define B2055_C2_TX_BB_MXGM		0xBC /* Core 2 TX BB MXGM */
+#define B2055_PRG_GCHP21		0xBD /* PRG GC HPVGA23 21 */
+#define B2055_PRG_GCHP22		0xBE /* PRG GC HPVGA23 22 */
+#define B2055_PRG_GCHP23		0xBF /* PRG GC HPVGA23 23 */
+#define B2055_PRG_GCHP24		0xC0 /* PRG GC HPVGA23 24 */
+#define B2055_PRG_GCHP25		0xC1 /* PRG GC HPVGA23 25 */
+#define B2055_PRG_GCHP26		0xC2 /* PRG GC HPVGA23 26 */
+#define B2055_PRG_GCHP27		0xC3 /* PRG GC HPVGA23 27 */
+#define B2055_PRG_GCHP28		0xC4 /* PRG GC HPVGA23 28 */
+#define B2055_PRG_GCHP29		0xC5 /* PRG GC HPVGA23 29 */
+#define B2055_PRG_GCHP30		0xC6 /* PRG GC HPVGA23 30 */
+#define B2055_C1_LNA_GAINBST		0xCD /* Core 1 LNA GAINBST */
+#define B2055_C1_B0NB_RSSIVCM		0xD2 /* Core 1 B0 narrow-band RSSI VCM */
+#define B2055_C1_GENSPARE2		0xD6 /* Core 1 GEN spare 2 */
+#define B2055_C2_LNA_GAINBST		0xD9 /* Core 2 LNA GAINBST */
+#define B2055_C2_B0NB_RSSIVCM		0xDE /* Core 2 B0 narrow-band RSSI VCM */
+#define B2055_C2_GENSPARE2		0xE2 /* Core 2 GEN spare 2 */
+
+
+
 struct b43_wldev;
 
 int b43_phy_initn(struct b43_wldev *dev);
 
 #endif /* B43_NPHY_H_ */


From mb at bu3sch.de  Sun Jan 13 18:16:14 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 13 Jan 2008 18:16:14 +0100
Subject: b43_suspend problem
In-Reply-To: <Pine.LNX.4.44L0.0801131157290.20625-100000@netrider.rowland.org>
References: <Pine.LNX.4.44L0.0801131157290.20625-100000@netrider.rowland.org>
Message-ID: <200801131816.15278.mb@bu3sch.de>

On Sunday 13 January 2008 18:08:57 Alan Stern wrote:
> On Sun, 13 Jan 2008, Rafael J. Wysocki wrote:
> 
> > On Sunday, 13 of January 2008, Michael Buesch wrote:
> > > On Sunday 13 January 2008 00:08:29 Rafael J. Wysocki wrote:
> > > > There is a problem with b43_suspend() that it (indirectly) causes
> > > > b43_leds_exit() to be called, which attempts to unregister the leds device
> > > > objects, which is forbidden (ie. you can't unregister and/or register devices
> > > > during a suspend or resume).
> > > 
> > > Why?
> > 
> > Well, the unregistering itself is not really harmful, provided that the device
> > is not registered back during the subsequent resume.
> > 
> > The PM core uses a list of active devices that are added to the list in
> > device_add().  The ordering of this list is important, because it is expected
> > to reflect the order in which the devices are to be suspended.
> > 
> > This list is manipulated during suspend/resume and devices are moved from it
> > and back to it, so unregistering devices during a suspend and registering them
> > during the subsequent resume generally changes its ordering and may lead to
> > problems during the next suspend/resume cycle.
> > 
> > This is also undesirable if we're going to stop using the freezer for
> > suspend/resume at one point in the future.
> > 
> > I'm sure Alan can add some more details.
> 
> Indeed.  A system suspend is a delicate operation, and the PM core
> needs to access all the devices in the system.  To have devices being
> registered and unregistered at the same time would cause a lot of
> confusion.  In self defense, the PM core starts out by acquiring all 
> the device semaphores before calling the suspend routines.  This means 
> that if a suspend routine tries to unregister anything, it will 
> deadlock at the point where the driver core tries to acquire the device 
> semaphore prior to invoking the driver's remove method.
> 
> Besides, if you're going to register the device right back again during 
> the subsequent resume, then why go to the trouble of unregistering it 
> during suspend?  Why not just leave it registered the whole time and 
> avoid all the complication (and excess meaningless uevents)?

Well, because not doing it complicates code :)
Currently suspend/resume calls the same code as init/exit.
The b43 init/exit code is really complicated, compared to other
drivers, due to dozens of hardware versions. So I just avoided
having yet other codepaths for suspend/resume. But I will add
a flag to the device structure that's used to avoid unregistering stuff.

-- 
Greetings Michael.


From stefano.brivio at polimi.it  Sun Jan 13 18:30:14 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Sun, 13 Jan 2008 18:30:14 +0100
Subject: [PATCH] b43: fix use-after-free rfkill bug
Message-ID: <20080113183014.675e64a3@morte>

Fix rfkill code which caused a use-after-free bug.

Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
---
Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
+++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
@@ -138,8 +138,11 @@ void b43_rfkill_init(struct b43_wldev *d
 	rfk->rfkill->user_claim_unsupported = 1;
 
 	rfk->poll_dev = input_allocate_polled_device();
-	if (!rfk->poll_dev)
-		goto err_free_rfk;
+	if (!rfk->poll_dev) {
+		rfkill_free(rfk->rfkill);
+		goto err_freed_rfk;
+	}
+
 	rfk->poll_dev->private = dev;
 	rfk->poll_dev->poll = b43_rfkill_poll;
 	rfk->poll_dev->poll_interval = 1000; /* msecs */
@@ -175,8 +178,7 @@ err_unreg_rfk:
 err_free_polldev:
 	input_free_polled_device(rfk->poll_dev);
 	rfk->poll_dev = NULL;
-err_free_rfk:
-	rfkill_free(rfk->rfkill);
+err_freed_rfk:
 	rfk->rfkill = NULL;
 out_error:
 	rfk->registered = 0;
@@ -195,6 +197,5 @@ void b43_rfkill_exit(struct b43_wldev *d
 	rfkill_unregister(rfk->rfkill);
 	input_free_polled_device(rfk->poll_dev);
 	rfk->poll_dev = NULL;
-	rfkill_free(rfk->rfkill);
 	rfk->rfkill = NULL;
 }


--
Ciao
Stefano


From stefano.brivio at polimi.it  Sun Jan 13 18:35:52 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Sun, 13 Jan 2008 18:35:52 +0100
Subject: [PATCH] b43legacy: fix use-after-free rfkill bug
Message-ID: <20080113183552.17885131@morte>

Fix rfkill code which caused a use-after-free bug. Thanks to David
Woodhouse for spotting this out.

Cc: David Woodhouse <dwmw2 at infradead.org>
Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
---
Index: wireless-2.6/drivers/net/wireless/b43legacy/rfkill.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/rfkill.c
+++ wireless-2.6/drivers/net/wireless/b43legacy/rfkill.c
@@ -141,8 +141,11 @@ void b43legacy_rfkill_init(struct b43leg
 	rfk->rfkill->user_claim_unsupported = 1;
 
 	rfk->poll_dev = input_allocate_polled_device();
-	if (!rfk->poll_dev)
-		goto err_free_rfk;
+	if (!rfk->poll_dev) {
+		rfkill_free(rfk->rfkill);
+		goto err_freed_rfk;
+	}
+
 	rfk->poll_dev->private = dev;
 	rfk->poll_dev->poll = b43legacy_rfkill_poll;
 	rfk->poll_dev->poll_interval = 1000; /* msecs */
@@ -178,8 +181,7 @@ err_unreg_rfk:
 err_free_polldev:
 	input_free_polled_device(rfk->poll_dev);
 	rfk->poll_dev = NULL;
-err_free_rfk:
-	rfkill_free(rfk->rfkill);
+err_freed_rfk:
 	rfk->rfkill = NULL;
 out_error:
 	rfk->registered = 0;
@@ -198,7 +200,6 @@ void b43legacy_rfkill_exit(struct b43leg
 	rfkill_unregister(rfk->rfkill);
 	input_free_polled_device(rfk->poll_dev);
 	rfk->poll_dev = NULL;
-	rfkill_free(rfk->rfkill);
 	rfk->rfkill = NULL;
 }


--
Ciao
Stefano


From mb at bu3sch.de  Sun Jan 13 18:41:10 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 13 Jan 2008 18:41:10 +0100
Subject: [PATCH] b43: fix use-after-free rfkill bug
In-Reply-To: <20080113183014.675e64a3@morte>
References: <20080113183014.675e64a3@morte>
Message-ID: <200801131841.10393.mb@bu3sch.de>

On Sunday 13 January 2008 18:30:14 Stefano Brivio wrote:
> Fix rfkill code which caused a use-after-free bug.
> 
> Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
> ---
> Index: wireless-2.6/drivers/net/wireless/b43/rfkill.c
> ===================================================================
> --- wireless-2.6.orig/drivers/net/wireless/b43/rfkill.c
> +++ wireless-2.6/drivers/net/wireless/b43/rfkill.c
> @@ -138,8 +138,11 @@ void b43_rfkill_init(struct b43_wldev *d
>  	rfk->rfkill->user_claim_unsupported = 1;
>  
>  	rfk->poll_dev = input_allocate_polled_device();
> -	if (!rfk->poll_dev)
> -		goto err_free_rfk;
> +	if (!rfk->poll_dev) {
> +		rfkill_free(rfk->rfkill);
> +		goto err_freed_rfk;
> +	}
> +
>  	rfk->poll_dev->private = dev;
>  	rfk->poll_dev->poll = b43_rfkill_poll;
>  	rfk->poll_dev->poll_interval = 1000; /* msecs */
> @@ -175,8 +178,7 @@ err_unreg_rfk:
>  err_free_polldev:
>  	input_free_polled_device(rfk->poll_dev);
>  	rfk->poll_dev = NULL;
> -err_free_rfk:
> -	rfkill_free(rfk->rfkill);
> +err_freed_rfk:
>  	rfk->rfkill = NULL;
>  out_error:
>  	rfk->registered = 0;
> @@ -195,6 +197,5 @@ void b43_rfkill_exit(struct b43_wldev *d
>  	rfkill_unregister(rfk->rfkill);
>  	input_free_polled_device(rfk->poll_dev);
>  	rfk->poll_dev = NULL;
> -	rfkill_free(rfk->rfkill);
>  	rfk->rfkill = NULL;
>  }

Acked-by: Michael Buesch <mb at bu3sch.de>

-- 
Greetings Michael.


From mb at bu3sch.de  Sun Jan 13 21:08:24 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 13 Jan 2008 21:08:24 +0100
Subject: [PATCH] ssb: Add boardflags_hi field to the sprom data structure
Message-ID: <200801132108.24556.mb@bu3sch.de>

Add boardflags-high.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.25

Index: wireless-2.6/drivers/ssb/pci.c
===================================================================
--- wireless-2.6.orig/drivers/ssb/pci.c	2008-01-09 16:59:33.000000000 +0100
+++ wireless-2.6/drivers/ssb/pci.c	2008-01-13 21:01:14.000000000 +0100
@@ -374,12 +374,14 @@ static void sprom_extract_r123(struct ss
 	     SSB_SPROM1_MAXPWR_A_SHIFT);
 	SPEX(maxpwr_bg, SSB_SPROM1_MAXPWR, SSB_SPROM1_MAXPWR_BG, 0);
 	SPEX(itssi_a, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_A,
 	     SSB_SPROM1_ITSSI_A_SHIFT);
 	SPEX(itssi_bg, SSB_SPROM1_ITSSI, SSB_SPROM1_ITSSI_BG, 0);
 	SPEX(boardflags_lo, SSB_SPROM1_BFLLO, 0xFFFF, 0);
+	if (out->revision >= 2)
+		SPEX(boardflags_hi, SSB_SPROM2_BFLHI, 0xFFFF, 0);
 
 	/* Extract the antenna gain values. */
 	gain = r123_extract_antgain(out->revision, in,
 				    SSB_SPROM1_AGAIN_BG,
 				    SSB_SPROM1_AGAIN_BG_SHIFT);
 	out->antenna_gain.ghz24.a0 = gain;
@@ -415,12 +417,13 @@ static void sprom_extract_r4(struct ssb_
 	}
 	SPEX(et0phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET0A, 0);
 	SPEX(et1phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET1A,
 	     SSB_SPROM4_ETHPHY_ET1A_SHIFT);
 	SPEX(country_code, SSB_SPROM4_CCODE, 0xFFFF, 0);
 	SPEX(boardflags_lo, SSB_SPROM4_BFLLO, 0xFFFF, 0);
+	SPEX(boardflags_hi, SSB_SPROM4_BFLHI, 0xFFFF, 0);
 	SPEX(ant_available_a, SSB_SPROM4_ANTAVAIL, SSB_SPROM4_ANTAVAIL_A,
 	     SSB_SPROM4_ANTAVAIL_A_SHIFT);
 	SPEX(ant_available_bg, SSB_SPROM4_ANTAVAIL, SSB_SPROM4_ANTAVAIL_BG,
 	     SSB_SPROM4_ANTAVAIL_BG_SHIFT);
 	SPEX(maxpwr_bg, SSB_SPROM4_MAXP_BG, SSB_SPROM4_MAXP_BG_MASK, 0);
 	SPEX(itssi_bg, SSB_SPROM4_MAXP_BG, SSB_SPROM4_ITSSI_BG,
Index: wireless-2.6/include/linux/ssb/ssb.h
===================================================================
--- wireless-2.6.orig/include/linux/ssb/ssb.h	2008-01-09 16:59:33.000000000 +0100
+++ wireless-2.6/include/linux/ssb/ssb.h	2008-01-13 21:00:39.000000000 +0100
@@ -40,12 +40,13 @@ struct ssb_sprom {
 	u8 gpio3;		/* GPIO pin 3 */
 	u16 maxpwr_a;		/* A-PHY Amplifier Max Power (in dBm Q5.2) */
 	u16 maxpwr_bg;		/* B/G-PHY Amplifier Max Power (in dBm Q5.2) */
 	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
 	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
 	u16 boardflags_lo;	/* Boardflags (low 16 bits) */
+	u16 boardflags_hi;	/* Boardflags (high 16 bits) */
 
 	/* Antenna gain values for up to 4 antennas
 	 * on each band. Values in dBm/4 (Q5.2). Negative gain means the
 	 * loss in the connectors is bigger than the gain. */
 	struct {
 		struct {


From mb at bu3sch.de  Sun Jan 13 21:23:44 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 13 Jan 2008 21:23:44 +0100
Subject: [PATCH] b43: Add NPHY radio init code
Message-ID: <200801132123.45330.mb@bu3sch.de>

This adds some code to init the 2055 radio.
This patch adds two files "tables_nphy.h" and "tables_nphy.c"

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.25.

Index: wireless-2.6/drivers/net/wireless/b43/nphy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/nphy.c	2008-01-13 20:57:36.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/nphy.c	2008-01-13 21:05:54.000000000 +0100
@@ -21,14 +21,110 @@
   Boston, MA 02110-1301, USA.
 
 */
 
 #include "b43.h"
 #include "nphy.h"
+#include "tables_nphy.h"
 
 
+void b43_nphy_set_rxantenna(struct b43_wldev *dev, int antenna)
+{//TODO
+}
+
+void b43_nphy_xmitpower(struct b43_wldev *dev)
+{//TODO
+}
+
+/* Tune the hardware to a new channel. Don't call this directly.
+ * Use b43_radio_selectchannel() */
+void b43_nphy_selectchannel(struct b43_wldev *dev, u8 channel)
+{
+
+//TODO
+}
+
+static void b43_radio_init2055_pre(struct b43_wldev *dev)
+{
+	b43_phy_mask(dev, B43_NPHY_RFCTL_CMD,
+		     ~B43_NPHY_RFCTL_CMD_PORFORCE);
+	b43_phy_set(dev, B43_NPHY_RFCTL_CMD,
+		    B43_NPHY_RFCTL_CMD_CHIP0PU |
+		    B43_NPHY_RFCTL_CMD_OEPORFORCE);
+	b43_phy_set(dev, B43_NPHY_RFCTL_CMD,
+		    B43_NPHY_RFCTL_CMD_PORFORCE);
+}
+
+static void b43_radio_init2055_post(struct b43_wldev *dev)
+{
+	struct ssb_sprom *sprom = &(dev->dev->bus->sprom);
+	struct ssb_boardinfo *binfo = &(dev->dev->bus->boardinfo);
+	int i;
+	u16 val;
+
+	b43_radio_mask(dev, B2055_MASTER1, 0xFFF3);
+	msleep(1);
+	if ((sprom->revision != 4) || !(sprom->boardflags_hi & 0x0002)) {
+		if ((binfo->vendor != PCI_VENDOR_ID_BROADCOM) ||
+		    (binfo->type != 0x46D) ||
+		    (binfo->rev < 0x41)) {
+			b43_radio_mask(dev, B2055_C1_RX_BB_REG, 0x7F);
+			b43_radio_mask(dev, B2055_C1_RX_BB_REG, 0x7F);
+			msleep(1);
+		}
+	}
+	b43_radio_maskset(dev, B2055_RRCCAL_NOPTSEL, 0x3F, 0x2C);
+	msleep(1);
+	b43_radio_write16(dev, B2055_CAL_MISC, 0x3C);
+	msleep(1);
+	b43_radio_mask(dev, B2055_CAL_MISC, 0xFFBE);
+	msleep(1);
+	b43_radio_set(dev, B2055_CAL_LPOCTL, 0x80);
+	msleep(1);
+	b43_radio_set(dev, B2055_CAL_MISC, 0x1);
+	msleep(1);
+	b43_radio_set(dev, B2055_CAL_MISC, 0x40);
+	msleep(1);
+	for (i = 0; i < 100; i++) {
+		val = b43_radio_read16(dev, B2055_CAL_COUT2);
+		if (val & 0x80)
+			break;
+		udelay(10);
+	}
+	msleep(1);
+	b43_radio_mask(dev, B2055_CAL_LPOCTL, 0xFF7F);
+	msleep(1);
+	b43_radio_selectchannel(dev, dev->phy.channel, 0);
+	b43_radio_write16(dev, B2055_C1_RX_BB_LPF, 0x9);
+	b43_radio_write16(dev, B2055_C2_RX_BB_LPF, 0x9);
+	b43_radio_write16(dev, B2055_C1_RX_BB_MIDACHP, 0x83);
+	b43_radio_write16(dev, B2055_C2_RX_BB_MIDACHP, 0x83);
+}
+
+/* Initialize a Broadcom 2055 N-radio */
+static void b43_radio_init2055(struct b43_wldev *dev)
+{
+	b43_radio_init2055_pre(dev);
+	if (b43_status(dev) < B43_STAT_INITIALIZED)
+		b2055_upload_inittab(dev, 0, 1);
+	else
+		b2055_upload_inittab(dev, 0/*FIXME on 5ghz band*/, 0);
+	b43_radio_init2055_post(dev);
+}
+
+void b43_nphy_radio_turn_on(struct b43_wldev *dev)
+{
+	b43_radio_init2055(dev);
+}
+
+void b43_nphy_radio_turn_off(struct b43_wldev *dev)
+{
+	b43_phy_mask(dev, B43_NPHY_RFCTL_CMD,
+		     ~B43_NPHY_RFCTL_CMD_EN);
+}
+
 int b43_phy_initn(struct b43_wldev *dev)
 {
 	b43err(dev->wl, "IEEE 802.11n devices are not supported, yet.\n");
 
-	return -EOPNOTSUPP;
+	return 0;
 }
Index: wireless-2.6/drivers/net/wireless/b43/nphy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/nphy.h	2008-01-13 20:57:36.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/nphy.h	2008-01-13 21:02:46.000000000 +0100
@@ -174,12 +174,13 @@
 #define  B43_NPHY_RFCTL_CMD_CORESEL_SHIFT	3
 #define  B43_NPHY_RFCTL_CMD_PORFORCE		0x0040 /* POR force */
 #define  B43_NPHY_RFCTL_CMD_OEPORFORCE		0x0080 /* OE POR force */
 #define  B43_NPHY_RFCTL_CMD_RXEN		0x0100 /* RX enable */
 #define  B43_NPHY_RFCTL_CMD_TXEN		0x0200 /* TX enable */
 #define  B43_NPHY_RFCTL_CMD_CHIP0PU		0x0400 /* Chip0 PU */
+#define  B43_NPHY_RFCTL_CMD_EN			0x0800 /* Radio enabled */
 #define  B43_NPHY_RFCTL_CMD_SEQENCORE		0xF000 /* Seq en core */
 #define  B43_NPHY_RFCTL_CMD_SEQENCORE_SHIFT	12
 #define B43_NPHY_RFCTL_RSSIO1			B43_PHY_N(0x07A) /* RF control (RSSI others 1) */
 #define  B43_NPHY_RFCTL_RSSIO1_RXPD		0x0001 /* RX PD */
 #define  B43_NPHY_RFCTL_RSSIO1_TXPD		0x0002 /* TX PD */
 #define  B43_NPHY_RFCTL_RSSIO1_PAPD		0x0004 /* PA PD */
@@ -910,7 +911,15 @@
 
 
 struct b43_wldev;
 
 int b43_phy_initn(struct b43_wldev *dev);
 
+void b43_nphy_radio_turn_on(struct b43_wldev *dev);
+void b43_nphy_radio_turn_off(struct b43_wldev *dev);
+
+void b43_nphy_selectchannel(struct b43_wldev *dev, u8 channel);
+
+void b43_nphy_xmitpower(struct b43_wldev *dev);
+void b43_nphy_set_rxantenna(struct b43_wldev *dev, int antenna);
+
 #endif /* B43_NPHY_H_ */
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c	2008-01-13 20:57:36.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/phy.c	2008-01-13 21:02:46.000000000 +0100
@@ -305,12 +305,30 @@ void b43_phy_write(struct b43_wldev *dev
 
 	offset = adjust_phyreg_for_phytype(phy, offset, dev);
 	b43_write16(dev, B43_MMIO_PHY_CONTROL, offset);
 	b43_write16(dev, B43_MMIO_PHY_DATA, val);
 }
 
+void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
+{
+	b43_phy_write(dev, offset,
+		      b43_phy_read(dev, offset) & mask);
+}
+
+void b43_phy_set(struct b43_wldev *dev, u16 offset, u16 set)
+{
+	b43_phy_write(dev, offset,
+		      b43_phy_read(dev, offset) | set);
+}
+
+void b43_phy_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set)
+{
+	b43_phy_write(dev, offset,
+		      (b43_phy_read(dev, offset) & mask) | set);
+}
+
 /* Adjust the transmission power output (G-PHY) */
 void b43_set_txpower_g(struct b43_wldev *dev,
 		       const struct b43_bbatt *bbatt,
 		       const struct b43_rfatt *rfatt, u8 tx_control)
 {
 	struct b43_phy *phy = &dev->phy;
@@ -1854,12 +1872,15 @@ void b43_phy_xmitpower(struct b43_wldev 
 					  phy->tx_control);
 			b43_lo_g_ctl_mark_cur_used(dev);
 			b43_radio_unlock(dev);
 			b43_phy_unlock(dev);
 			break;
 		}
+	case B43_PHYTYPE_N:
+		b43_nphy_xmitpower(dev);
+		break;
 	default:
 		B43_WARN_ON(1);
 	}
 }
 
 static inline s32 b43_tssi2dbm_ad(s32 num, s32 den)
@@ -2113,12 +2134,15 @@ void b43_set_rx_antenna(struct b43_wldev
 		tmp = b43_phy_read(dev, B43_PHY_CCKBBANDCFG);
 		tmp &= ~B43_PHY_BBANDCFG_RXANT;
 		tmp |= (autodiv ? B43_ANTENNA_AUTO0 : antenna)
 		    << B43_PHY_BBANDCFG_RXANT_SHIFT;
 		b43_phy_write(dev, B43_PHY_CCKBBANDCFG, tmp);
 		break;
+	case B43_PHYTYPE_N:
+		b43_nphy_set_rxantenna(dev, antenna);
+		break;
 	default:
 		B43_WARN_ON(1);
 	}
 
 	hf |= B43_HF_ANTDIVHELP;
 	b43_hf_write(dev, hf);
@@ -2212,12 +2236,30 @@ void b43_radio_write16(struct b43_wldev 
 	B43_WARN_ON(offset == 1);
 
 	b43_write16(dev, B43_MMIO_RADIO_CONTROL, offset);
 	b43_write16(dev, B43_MMIO_RADIO_DATA_LOW, val);
 }
 
+void b43_radio_mask(struct b43_wldev *dev, u16 offset, u16 mask)
+{
+	b43_radio_write16(dev, offset,
+			  b43_radio_read16(dev, offset) & mask);
+}
+
+void b43_radio_set(struct b43_wldev *dev, u16 offset, u16 set)
+{
+	b43_radio_write16(dev, offset,
+			  b43_radio_read16(dev, offset) | set);
+}
+
+void b43_radio_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set)
+{
+	b43_radio_write16(dev, offset,
+			  (b43_radio_read16(dev, offset) & mask) | set);
+}
+
 static void b43_set_all_gains(struct b43_wldev *dev,
 			      s16 first, s16 second, s16 third)
 {
 	struct b43_phy *phy = &dev->phy;
 	u16 i;
 	u16 start = 0x08, end = 0x18;
@@ -3849,26 +3891,32 @@ int b43_radio_selectchannel(struct b43_w
 			channel = B43_DEFAULT_CHANNEL_A;
 			break;
 		case B43_PHYTYPE_B:
 		case B43_PHYTYPE_G:
 			channel = B43_DEFAULT_CHANNEL_BG;
 			break;
+		case B43_PHYTYPE_N:
+			//FIXME check if we are on 2.4GHz or 5GHz and set a default channel.
+			channel = 1;
+			break;
 		default:
 			B43_WARN_ON(1);
 		}
 	}
 
 	/* First we set the channel radio code to prevent the
 	 * firmware from sending ghost packets.
 	 */
 	channelcookie = channel;
-	if (phy->type == B43_PHYTYPE_A)
+	if (0 /*FIXME on 5Ghz */)
 		channelcookie |= 0x100;
+	//FIXME set 40Mhz flag if required
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_CHAN, channelcookie);
 
-	if (phy->type == B43_PHYTYPE_A) {
+	switch (phy->type) {
+	case B43_PHYTYPE_A:
 		if (channel > 200)
 			return -EINVAL;
 		freq = channel2freq_a(channel);
 
 		r8 = b43_radio_read16(dev, 0x0008);
 		b43_write16(dev, 0x03F0, freq);
@@ -3911,13 +3959,14 @@ int b43_radio_selectchannel(struct b43_w
 				  b43_radio_read16(dev, 0x0035) & 0xFFEF);
 		b43_radio_write16(dev, 0x0035, (b43_radio_read16(dev, 0x0035)
 						& 0xFFEF) | 0x0010);
 		b43_radio_set_tx_iq(dev);
 		//TODO: TSSI2dbm workaround
 		b43_phy_xmitpower(dev);	//FIXME correct?
-	} else {
+		break;
+	case B43_PHYTYPE_G:
 		if ((channel < 1) || (channel > 14))
 			return -EINVAL;
 
 		if (synthetic_pu_workaround)
 			b43_synth_pu_workaround(dev, channel);
 
@@ -3936,12 +3985,18 @@ int b43_radio_selectchannel(struct b43_w
 				    | (1 << 11));
 		} else {
 			b43_write16(dev, B43_MMIO_CHANNEL_EXT,
 				    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
 				    & 0xF7BF);
 		}
+		break;
+	case B43_PHYTYPE_N:
+		b43_nphy_selectchannel(dev, channel);
+		break;
+	default:
+		B43_WARN_ON(1);
 	}
 
 	phy->channel = channel;
 	/* Wait for the radio to tune to the channel and stabilize. */
 	msleep(8);
 
@@ -3982,12 +4037,15 @@ void b43_radio_turn_on(struct b43_wldev 
 		}
 		channel = phy->channel;
 		err = b43_radio_selectchannel(dev, B43_DEFAULT_CHANNEL_BG, 1);
 		err |= b43_radio_selectchannel(dev, channel, 0);
 		B43_WARN_ON(err);
 		break;
+	case B43_PHYTYPE_N:
+		b43_nphy_radio_turn_on(dev);
+		break;
 	default:
 		B43_WARN_ON(1);
 	}
 	phy->radio_on = 1;
 }
 
@@ -3995,28 +4053,35 @@ void b43_radio_turn_off(struct b43_wldev
 {
 	struct b43_phy *phy = &dev->phy;
 
 	if (!phy->radio_on && !force)
 		return;
 
-	if (phy->type == B43_PHYTYPE_A) {
+	switch (phy->type) {
+	case B43_PHYTYPE_N:
+		b43_nphy_radio_turn_off(dev);
+		break;
+	case B43_PHYTYPE_A:
 		b43_radio_write16(dev, 0x0004, 0x00FF);
 		b43_radio_write16(dev, 0x0005, 0x00FB);
 		b43_phy_write(dev, 0x0010, b43_phy_read(dev, 0x0010) | 0x0008);
 		b43_phy_write(dev, 0x0011, b43_phy_read(dev, 0x0011) | 0x0008);
-	}
-	if (phy->type == B43_PHYTYPE_G && dev->dev->id.revision >= 5) {
+		break;
+	case B43_PHYTYPE_G: {
 		u16 rfover, rfoverval;
 
 		rfover = b43_phy_read(dev, B43_PHY_RFOVER);
 		rfoverval = b43_phy_read(dev, B43_PHY_RFOVERVAL);
 		if (!force) {
 			phy->radio_off_context.rfover = rfover;
 			phy->radio_off_context.rfoverval = rfoverval;
 			phy->radio_off_context.valid = 1;
 		}
 		b43_phy_write(dev, B43_PHY_RFOVER, rfover | 0x008C);
 		b43_phy_write(dev, B43_PHY_RFOVERVAL, rfoverval & 0xFF73);
-	} else
-		b43_phy_write(dev, 0x0015, 0xAA00);
+		break;
+	}
+	default:
+		B43_WARN_ON(1);
+	}
 	phy->radio_on = 0;
 }
Index: wireless-2.6/drivers/net/wireless/b43/phy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.h	2008-01-13 20:57:36.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/phy.h	2008-01-13 21:02:46.000000000 +0100
@@ -201,14 +201,24 @@ enum {
 #define B43_PHYVER_TYPE_SHIFT		8
 #define B43_PHYVER_VERSION		0x00FF
 
 void b43_phy_lock(struct b43_wldev *dev);
 void b43_phy_unlock(struct b43_wldev *dev);
 
+
+/* Read a value from a PHY register */
 u16 b43_phy_read(struct b43_wldev *dev, u16 offset);
+/* Write a value to a PHY register */
 void b43_phy_write(struct b43_wldev *dev, u16 offset, u16 val);
+/* Mask a PHY register with a mask */
+void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask);
+/* OR a PHY register with a bitmap */
+void b43_phy_set(struct b43_wldev *dev, u16 offset, u16 set);
+/* Mask and OR a PHY register with a mask and bitmap */
+void b43_phy_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set);
+
 
 int b43_phy_init_tssi2dbm_table(struct b43_wldev *dev);
 
 void b43_phy_early_init(struct b43_wldev *dev);
 int b43_phy_init(struct b43_wldev *dev);
 
@@ -266,14 +276,24 @@ void b43_phy_set_baseband_attenuation(st
 
 extern const u8 b43_radio_channel_codes_bg[];
 
 void b43_radio_lock(struct b43_wldev *dev);
 void b43_radio_unlock(struct b43_wldev *dev);
 
+
+/* Read a value from a 16bit radio register */
 u16 b43_radio_read16(struct b43_wldev *dev, u16 offset);
+/* Write a value to a 16bit radio register */
 void b43_radio_write16(struct b43_wldev *dev, u16 offset, u16 val);
+/* Mask a 16bit radio register with a mask */
+void b43_radio_mask(struct b43_wldev *dev, u16 offset, u16 mask);
+/* OR a 16bit radio register with a bitmap */
+void b43_radio_set(struct b43_wldev *dev, u16 offset, u16 set);
+/* Mask and OR a PHY register with a mask and bitmap */
+void b43_radio_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set);
+
 
 u16 b43_radio_init2050(struct b43_wldev *dev);
 void b43_radio_init2060(struct b43_wldev *dev);
 
 void b43_radio_turn_on(struct b43_wldev *dev);
 void b43_radio_turn_off(struct b43_wldev *dev, bool force);
Index: wireless-2.6/drivers/net/wireless/b43/Makefile
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/Makefile	2008-01-13 20:57:36.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/Makefile	2008-01-13 21:02:46.000000000 +0100
@@ -1,8 +1,9 @@
 b43-y				+= main.o
 b43-y				+= tables.o
+b43-y				+= tables_nphy.o
 b43-y				+= phy.o
 b43-y				+= nphy.o
 b43-y				+= sysfs.o
 b43-y				+= xmit.o
 b43-y				+= lo.o
 b43-y				+= wa.o
Index: wireless-2.6/drivers/net/wireless/b43/tables_nphy.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ wireless-2.6/drivers/net/wireless/b43/tables_nphy.c	2008-01-13 21:02:46.000000000 +0100
@@ -0,0 +1,292 @@
+/*
+
+  Broadcom B43 wireless driver
+  IEEE 802.11n PHY and radio device data tables
+
+  Copyright (c) 2008 Michael Buesch <mb at bu3sch.de>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+
+*/
+
+#include "b43.h"
+#include "tables_nphy.h"
+#include "phy.h"
+#include "nphy.h"
+
+
+struct b2055_inittab_entry {
+	/* Value to write if we use the 5GHz band. */
+	u16 ghz5;
+	/* Value to write if we use the 2.4GHz band. */
+	u16 ghz2;
+	/* Flags */
+	u8 flags;
+#define B2055_INITTAB_ENTRY_OK	0x01
+#define B2055_INITTAB_UPLOAD	0x02
+};
+#define UPLOAD		.flags = B2055_INITTAB_ENTRY_OK | B2055_INITTAB_UPLOAD
+#define NOUPLOAD	.flags = B2055_INITTAB_ENTRY_OK
+
+static struct b2055_inittab_entry b2055_inittab [] = {
+  [B2055_SP_PINPD]		= { .ghz5 = 0x0080, .ghz2 = 0x0080, NOUPLOAD, },
+  [B2055_C1_SP_RSSI]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C1_SP_PDMISC]		= { .ghz5 = 0x0027, .ghz2 = 0x0027, NOUPLOAD, },
+  [B2055_C2_SP_RSSI]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C2_SP_PDMISC]		= { .ghz5 = 0x0027, .ghz2 = 0x0027, NOUPLOAD, },
+  [B2055_C1_SP_RXGC1]		= { .ghz5 = 0x007F, .ghz2 = 0x007F, UPLOAD, },
+  [B2055_C1_SP_RXGC2]		= { .ghz5 = 0x0007, .ghz2 = 0x0007, UPLOAD, },
+  [B2055_C2_SP_RXGC1]		= { .ghz5 = 0x007F, .ghz2 = 0x007F, UPLOAD, },
+  [B2055_C2_SP_RXGC2]		= { .ghz5 = 0x0007, .ghz2 = 0x0007, UPLOAD, },
+  [B2055_C1_SP_LPFBWSEL]	= { .ghz5 = 0x0015, .ghz2 = 0x0015, NOUPLOAD, },
+  [B2055_C2_SP_LPFBWSEL]	= { .ghz5 = 0x0015, .ghz2 = 0x0015, NOUPLOAD, },
+  [B2055_C1_SP_TXGC1]		= { .ghz5 = 0x004F, .ghz2 = 0x004F, UPLOAD, },
+  [B2055_C1_SP_TXGC2]		= { .ghz5 = 0x0005, .ghz2 = 0x0005, UPLOAD, },
+  [B2055_C2_SP_TXGC1]		= { .ghz5 = 0x004F, .ghz2 = 0x004F, UPLOAD, },
+  [B2055_C2_SP_TXGC2]		= { .ghz5 = 0x0005, .ghz2 = 0x0005, UPLOAD, },
+  [B2055_MASTER1]		= { .ghz5 = 0x00D0, .ghz2 = 0x00D0, NOUPLOAD, },
+  [B2055_MASTER2]		= { .ghz5 = 0x0002, .ghz2 = 0x0002, NOUPLOAD, },
+  [B2055_PD_LGEN]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_PD_PLLTS]		= { .ghz5 = 0x0040, .ghz2 = 0x0040, NOUPLOAD, },
+  [B2055_C1_PD_LGBUF]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C1_PD_TX]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C1_PD_RXTX]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C1_PD_RSSIMISC]	= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C2_PD_LGBUF]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C2_PD_TX]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C2_PD_RXTX]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C2_PD_RSSIMISC]	= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_PWRDET_LGEN]		= { .ghz5 = 0x00C0, .ghz2 = 0x00C0, NOUPLOAD, },
+  [B2055_C1_PWRDET_LGBUF]	= { .ghz5 = 0x00FF, .ghz2 = 0x00FF, NOUPLOAD, },
+  [B2055_C1_PWRDET_RXTX]	= { .ghz5 = 0x00C0, .ghz2 = 0x00C0, NOUPLOAD, },
+  [B2055_C2_PWRDET_LGBUF]	= { .ghz5 = 0x00FF, .ghz2 = 0x00FF, NOUPLOAD, },
+  [B2055_C2_PWRDET_RXTX]	= { .ghz5 = 0x00C0, .ghz2 = 0x00C0, NOUPLOAD, },
+  [B2055_RRCCAL_CS]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_RRCCAL_NOPTSEL]	= { .ghz5 = 0x002C, .ghz2 = 0x002C, NOUPLOAD, },
+  [B2055_CAL_MISC]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_CAL_COUT]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_CAL_COUT2]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_CAL_CVARCTL]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_CAL_RVARCTL]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_CAL_LPOCTL]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_CAL_TS]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_CAL_RCCALRTS]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_CAL_RCALRTS]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_PADDRV]		= { .ghz5 = 0x00A4, .ghz2 = 0x00A4, NOUPLOAD, },
+  [B2055_XOCTL1]		= { .ghz5 = 0x0038, .ghz2 = 0x0038, NOUPLOAD, },
+  [B2055_XOCTL2]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_XOREGUL]		= { .ghz5 = 0x0004, .ghz2 = 0x0004, UPLOAD, },
+  [B2055_XOMISC]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_PLL_LFC1]		= { .ghz5 = 0x000A, .ghz2 = 0x000A, NOUPLOAD, },
+  [B2055_PLL_CALVTH]		= { .ghz5 = 0x0087, .ghz2 = 0x0087, NOUPLOAD, },
+  [B2055_PLL_LFC2]		= { .ghz5 = 0x0009, .ghz2 = 0x0009, NOUPLOAD, },
+  [B2055_PLL_REF]		= { .ghz5 = 0x0070, .ghz2 = 0x0070, NOUPLOAD, },
+  [B2055_PLL_LFR1]		= { .ghz5 = 0x0011, .ghz2 = 0x0011, NOUPLOAD, },
+  [B2055_PLL_PFDCP]		= { .ghz5 = 0x0018, .ghz2 = 0x0018, UPLOAD, },
+  [B2055_PLL_IDAC_CPOPAMP]	= { .ghz5 = 0x0006, .ghz2 = 0x0006, NOUPLOAD, },
+  [B2055_PLL_CPREG]		= { .ghz5 = 0x0004, .ghz2 = 0x0004, UPLOAD, },
+  [B2055_PLL_RCAL]		= { .ghz5 = 0x0006, .ghz2 = 0x0006, NOUPLOAD, },
+  [B2055_RF_PLLMOD0]		= { .ghz5 = 0x009E, .ghz2 = 0x009E, NOUPLOAD, },
+  [B2055_RF_PLLMOD1]		= { .ghz5 = 0x0009, .ghz2 = 0x0009, NOUPLOAD, },
+  [B2055_RF_MMDIDAC1]		= { .ghz5 = 0x00C8, .ghz2 = 0x00C8, UPLOAD, },
+  [B2055_RF_MMDIDAC0]		= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [B2055_RF_MMDSP]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_VCO_CAL1]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_VCO_CAL2]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_VCO_CAL3]		= { .ghz5 = 0x0001, .ghz2 = 0x0001, NOUPLOAD, },
+  [B2055_VCO_CAL4]		= { .ghz5 = 0x0002, .ghz2 = 0x0002, NOUPLOAD, },
+  [B2055_VCO_CAL5]		= { .ghz5 = 0x0096, .ghz2 = 0x0096, NOUPLOAD, },
+  [B2055_VCO_CAL6]		= { .ghz5 = 0x003E, .ghz2 = 0x003E, NOUPLOAD, },
+  [B2055_VCO_CAL7]		= { .ghz5 = 0x003E, .ghz2 = 0x003E, NOUPLOAD, },
+  [B2055_VCO_CAL8]		= { .ghz5 = 0x0013, .ghz2 = 0x0013, NOUPLOAD, },
+  [B2055_VCO_CAL9]		= { .ghz5 = 0x0002, .ghz2 = 0x0002, NOUPLOAD, },
+  [B2055_VCO_CAL10]		= { .ghz5 = 0x0015, .ghz2 = 0x0015, NOUPLOAD, },
+  [B2055_VCO_CAL11]		= { .ghz5 = 0x0007, .ghz2 = 0x0007, NOUPLOAD, },
+  [B2055_VCO_CAL12]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_VCO_CAL13]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_VCO_CAL14]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_VCO_CAL15]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_VCO_CAL16]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_VCO_KVCO]		= { .ghz5 = 0x0008, .ghz2 = 0x0008, NOUPLOAD, },
+  [B2055_VCO_CAPTAIL]		= { .ghz5 = 0x0008, .ghz2 = 0x0008, NOUPLOAD, },
+  [B2055_VCO_IDACVCO]		= { .ghz5 = 0x0006, .ghz2 = 0x0006, NOUPLOAD, },
+  [B2055_VCO_REG]		= { .ghz5 = 0x0084, .ghz2 = 0x0084, UPLOAD, },
+  [B2055_PLL_RFVTH]		= { .ghz5 = 0x00C3, .ghz2 = 0x00C3, NOUPLOAD, },
+  [B2055_LGBUF_CENBUF]		= { .ghz5 = 0x008F, .ghz2 = 0x008F, NOUPLOAD, },
+  [B2055_LGEN_TUNE1]		= { .ghz5 = 0x00FF, .ghz2 = 0x00FF, NOUPLOAD, },
+  [B2055_LGEN_TUNE2]		= { .ghz5 = 0x00FF, .ghz2 = 0x00FF, NOUPLOAD, },
+  [B2055_LGEN_IDAC1]		= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [B2055_LGEN_IDAC2]		= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [B2055_LGEN_BIASC]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_LGEN_BIASIDAC]		= { .ghz5 = 0x00CC, .ghz2 = 0x00CC, NOUPLOAD, },
+  [B2055_LGEN_RCAL]		= { .ghz5 = 0x0006, .ghz2 = 0x0006, NOUPLOAD, },
+  [B2055_LGEN_DIV]		= { .ghz5 = 0x0080, .ghz2 = 0x0080, NOUPLOAD, },
+  [B2055_LGEN_SPARE2]		= { .ghz5 = 0x0080, .ghz2 = 0x0080, NOUPLOAD, },
+  [B2055_C1_LGBUF_ATUNE]	= { .ghz5 = 0x00F8, .ghz2 = 0x00F8, NOUPLOAD, },
+  [B2055_C1_LGBUF_GTUNE]	= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [B2055_C1_LGBUF_DIV]		= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [B2055_C1_LGBUF_AIDAC]	= { .ghz5 = 0x0088, .ghz2 = 0x0008, UPLOAD, },
+  [B2055_C1_LGBUF_GIDAC]	= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [B2055_C1_LGBUF_IDACFO]	= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C1_LGBUF_SPARE]	= { .ghz5 = 0x0001, .ghz2 = 0x0001, UPLOAD, },
+  [B2055_C1_RX_RFSPC1]		= { .ghz5 = 0x008A, .ghz2 = 0x008A, NOUPLOAD, },
+  [B2055_C1_RX_RFR1]		= { .ghz5 = 0x0008, .ghz2 = 0x0008, NOUPLOAD, },
+  [B2055_C1_RX_RFR2]		= { .ghz5 = 0x0083, .ghz2 = 0x0083, NOUPLOAD, },
+  [B2055_C1_RX_RFRCAL]		= { .ghz5 = 0x0006, .ghz2 = 0x0006, NOUPLOAD, },
+  [B2055_C1_RX_BB_BLCMP]	= { .ghz5 = 0x00A0, .ghz2 = 0x00A0, NOUPLOAD, },
+  [B2055_C1_RX_BB_LPF]		= { .ghz5 = 0x000A, .ghz2 = 0x000A, NOUPLOAD, },
+  [B2055_C1_RX_BB_MIDACHP]	= { .ghz5 = 0x0087, .ghz2 = 0x0087, UPLOAD, },
+  [B2055_C1_RX_BB_VGA1IDAC]	= { .ghz5 = 0x002A, .ghz2 = 0x002A, NOUPLOAD, },
+  [B2055_C1_RX_BB_VGA2IDAC]	= { .ghz5 = 0x002A, .ghz2 = 0x002A, NOUPLOAD, },
+  [B2055_C1_RX_BB_VGA3IDAC]	= { .ghz5 = 0x002A, .ghz2 = 0x002A, NOUPLOAD, },
+  [B2055_C1_RX_BB_BUFOCTL]	= { .ghz5 = 0x002A, .ghz2 = 0x002A, NOUPLOAD, },
+  [B2055_C1_RX_BB_RCCALCTL]	= { .ghz5 = 0x0018, .ghz2 = 0x0018, NOUPLOAD, },
+  [B2055_C1_RX_BB_RSSICTL1]	= { .ghz5 = 0x006A, .ghz2 = 0x006A, UPLOAD, },
+  [B2055_C1_RX_BB_RSSICTL2]	= { .ghz5 = 0x00AB, .ghz2 = 0x00AB, UPLOAD, },
+  [B2055_C1_RX_BB_RSSICTL3]	= { .ghz5 = 0x0013, .ghz2 = 0x0013, UPLOAD, },
+  [B2055_C1_RX_BB_RSSICTL4]	= { .ghz5 = 0x00C1, .ghz2 = 0x00C1, UPLOAD, },
+  [B2055_C1_RX_BB_RSSICTL5]	= { .ghz5 = 0x00AA, .ghz2 = 0x00AA, UPLOAD, },
+  [B2055_C1_RX_BB_REG]		= { .ghz5 = 0x0087, .ghz2 = 0x0087, UPLOAD, },
+  [B2055_C1_RX_BB_SPARE1]	= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C1_RX_TXBBRCAL]	= { .ghz5 = 0x0006, .ghz2 = 0x0006, NOUPLOAD, },
+  [B2055_C1_TX_RF_SPGA]		= { .ghz5 = 0x0007, .ghz2 = 0x0007, NOUPLOAD, },
+  [B2055_C1_TX_RF_SPAD]		= { .ghz5 = 0x0007, .ghz2 = 0x0007, NOUPLOAD, },
+  [B2055_C1_TX_RF_CNTPGA1]	= { .ghz5 = 0x0015, .ghz2 = 0x0015, NOUPLOAD, },
+  [B2055_C1_TX_RF_CNTPAD1]	= { .ghz5 = 0x0055, .ghz2 = 0x0055, NOUPLOAD, },
+  [B2055_C1_TX_RF_PGAIDAC]	= { .ghz5 = 0x0097, .ghz2 = 0x0097, UPLOAD, },
+  [B2055_C1_TX_PGAPADTN]	= { .ghz5 = 0x0008, .ghz2 = 0x0008, NOUPLOAD, },
+  [B2055_C1_TX_PADIDAC1]	= { .ghz5 = 0x0014, .ghz2 = 0x0014, UPLOAD, },
+  [B2055_C1_TX_PADIDAC2]	= { .ghz5 = 0x0033, .ghz2 = 0x0033, NOUPLOAD, },
+  [B2055_C1_TX_MXBGTRIM]	= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [B2055_C1_TX_RF_RCAL]		= { .ghz5 = 0x0006, .ghz2 = 0x0006, NOUPLOAD, },
+  [B2055_C1_TX_RF_PADTSSI1]	= { .ghz5 = 0x0003, .ghz2 = 0x0003, UPLOAD, },
+  [B2055_C1_TX_RF_PADTSSI2]	= { .ghz5 = 0x000A, .ghz2 = 0x000A, NOUPLOAD, },
+  [B2055_C1_TX_RF_SPARE]	= { .ghz5 = 0x0003, .ghz2 = 0x0003, UPLOAD, },
+  [B2055_C1_TX_RF_IQCAL1]	= { .ghz5 = 0x002A, .ghz2 = 0x002A, NOUPLOAD, },
+  [B2055_C1_TX_RF_IQCAL2]	= { .ghz5 = 0x00A4, .ghz2 = 0x00A4, NOUPLOAD, },
+  [B2055_C1_TXBB_RCCAL]		= { .ghz5 = 0x0018, .ghz2 = 0x0018, NOUPLOAD, },
+  [B2055_C1_TXBB_LPF1]		= { .ghz5 = 0x0028, .ghz2 = 0x0028, NOUPLOAD, },
+  [B2055_C1_TX_VOSCNCL]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C1_TX_LPF_MXGMIDAC]	= { .ghz5 = 0x004A, .ghz2 = 0x004A, NOUPLOAD, },
+  [B2055_C1_TX_BB_MXGM]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C2_LGBUF_ATUNE]	= { .ghz5 = 0x00F8, .ghz2 = 0x00F8, NOUPLOAD, },
+  [B2055_C2_LGBUF_GTUNE]	= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [B2055_C2_LGBUF_DIV]		= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [B2055_C2_LGBUF_AIDAC]	= { .ghz5 = 0x0088, .ghz2 = 0x0008, UPLOAD, },
+  [B2055_C2_LGBUF_GIDAC]	= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [B2055_C2_LGBUF_IDACFO]	= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C2_LGBUF_SPARE]	= { .ghz5 = 0x0001, .ghz2 = 0x0001, UPLOAD, },
+  [B2055_C2_RX_RFSPC1]		= { .ghz5 = 0x008A, .ghz2 = 0x008A, NOUPLOAD, },
+  [B2055_C2_RX_RFR1]		= { .ghz5 = 0x0008, .ghz2 = 0x0008, NOUPLOAD, },
+  [B2055_C2_RX_RFR2]		= { .ghz5 = 0x0083, .ghz2 = 0x0083, NOUPLOAD, },
+  [B2055_C2_RX_RFRCAL]		= { .ghz5 = 0x0006, .ghz2 = 0x0006, NOUPLOAD, },
+  [B2055_C2_RX_BB_BLCMP]	= { .ghz5 = 0x00A0, .ghz2 = 0x00A0, NOUPLOAD, },
+  [B2055_C2_RX_BB_LPF]		= { .ghz5 = 0x000A, .ghz2 = 0x000A, NOUPLOAD, },
+  [B2055_C2_RX_BB_MIDACHP]	= { .ghz5 = 0x0087, .ghz2 = 0x0087, UPLOAD, },
+  [B2055_C2_RX_BB_VGA1IDAC]	= { .ghz5 = 0x002A, .ghz2 = 0x002A, NOUPLOAD, },
+  [B2055_C2_RX_BB_VGA2IDAC]	= { .ghz5 = 0x002A, .ghz2 = 0x002A, NOUPLOAD, },
+  [B2055_C2_RX_BB_VGA3IDAC]	= { .ghz5 = 0x002A, .ghz2 = 0x002A, NOUPLOAD, },
+  [B2055_C2_RX_BB_BUFOCTL]	= { .ghz5 = 0x002A, .ghz2 = 0x002A, NOUPLOAD, },
+  [B2055_C2_RX_BB_RCCALCTL]	= { .ghz5 = 0x0018, .ghz2 = 0x0018, NOUPLOAD, },
+  [B2055_C2_RX_BB_RSSICTL1]	= { .ghz5 = 0x006A, .ghz2 = 0x006A, UPLOAD, },
+  [B2055_C2_RX_BB_RSSICTL2]	= { .ghz5 = 0x00AB, .ghz2 = 0x00AB, UPLOAD, },
+  [B2055_C2_RX_BB_RSSICTL3]	= { .ghz5 = 0x0013, .ghz2 = 0x0013, UPLOAD, },
+  [B2055_C2_RX_BB_RSSICTL4]	= { .ghz5 = 0x00C1, .ghz2 = 0x00C1, UPLOAD, },
+  [B2055_C2_RX_BB_RSSICTL5]	= { .ghz5 = 0x00AA, .ghz2 = 0x00AA, UPLOAD, },
+  [B2055_C2_RX_BB_REG]		= { .ghz5 = 0x0087, .ghz2 = 0x0087, UPLOAD, },
+  [B2055_C2_RX_BB_SPARE1]	= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C2_RX_TXBBRCAL]	= { .ghz5 = 0x0006, .ghz2 = 0x0006, NOUPLOAD, },
+  [B2055_C2_TX_RF_SPGA]		= { .ghz5 = 0x0007, .ghz2 = 0x0007, NOUPLOAD, },
+  [B2055_C2_TX_RF_SPAD]		= { .ghz5 = 0x0007, .ghz2 = 0x0007, NOUPLOAD, },
+  [B2055_C2_TX_RF_CNTPGA1]	= { .ghz5 = 0x0015, .ghz2 = 0x0015, NOUPLOAD, },
+  [B2055_C2_TX_RF_CNTPAD1]	= { .ghz5 = 0x0055, .ghz2 = 0x0055, NOUPLOAD, },
+  [B2055_C2_TX_RF_PGAIDAC]	= { .ghz5 = 0x0097, .ghz2 = 0x0097, UPLOAD, },
+  [B2055_C2_TX_PGAPADTN]	= { .ghz5 = 0x0008, .ghz2 = 0x0008, NOUPLOAD, },
+  [B2055_C2_TX_PADIDAC1]	= { .ghz5 = 0x0014, .ghz2 = 0x0014, UPLOAD, },
+  [B2055_C2_TX_PADIDAC2]	= { .ghz5 = 0x0033, .ghz2 = 0x0033, NOUPLOAD, },
+  [B2055_C2_TX_MXBGTRIM]	= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [B2055_C2_TX_RF_RCAL]		= { .ghz5 = 0x0006, .ghz2 = 0x0006, NOUPLOAD, },
+  [B2055_C2_TX_RF_PADTSSI1]	= { .ghz5 = 0x0003, .ghz2 = 0x0003, UPLOAD, },
+  [B2055_C2_TX_RF_PADTSSI2]	= { .ghz5 = 0x000A, .ghz2 = 0x000A, NOUPLOAD, },
+  [B2055_C2_TX_RF_SPARE]	= { .ghz5 = 0x0003, .ghz2 = 0x0003, UPLOAD, },
+  [B2055_C2_TX_RF_IQCAL1]	= { .ghz5 = 0x002A, .ghz2 = 0x002A, NOUPLOAD, },
+  [B2055_C2_TX_RF_IQCAL2]	= { .ghz5 = 0x00A4, .ghz2 = 0x00A4, NOUPLOAD, },
+  [B2055_C2_TXBB_RCCAL]		= { .ghz5 = 0x0018, .ghz2 = 0x0018, NOUPLOAD, },
+  [B2055_C2_TXBB_LPF1]		= { .ghz5 = 0x0028, .ghz2 = 0x0028, NOUPLOAD, },
+  [B2055_C2_TX_VOSCNCL]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C2_TX_LPF_MXGMIDAC]	= { .ghz5 = 0x004A, .ghz2 = 0x004A, NOUPLOAD, },
+  [B2055_C2_TX_BB_MXGM]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_PRG_GCHP21]		= { .ghz5 = 0x0071, .ghz2 = 0x0071, NOUPLOAD, },
+  [B2055_PRG_GCHP22]		= { .ghz5 = 0x0072, .ghz2 = 0x0072, NOUPLOAD, },
+  [B2055_PRG_GCHP23]		= { .ghz5 = 0x0073, .ghz2 = 0x0073, NOUPLOAD, },
+  [B2055_PRG_GCHP24]		= { .ghz5 = 0x0074, .ghz2 = 0x0074, NOUPLOAD, },
+  [B2055_PRG_GCHP25]		= { .ghz5 = 0x0075, .ghz2 = 0x0075, NOUPLOAD, },
+  [B2055_PRG_GCHP26]		= { .ghz5 = 0x0076, .ghz2 = 0x0076, NOUPLOAD, },
+  [B2055_PRG_GCHP27]		= { .ghz5 = 0x0077, .ghz2 = 0x0077, NOUPLOAD, },
+  [B2055_PRG_GCHP28]		= { .ghz5 = 0x0078, .ghz2 = 0x0078, NOUPLOAD, },
+  [B2055_PRG_GCHP29]		= { .ghz5 = 0x0079, .ghz2 = 0x0079, NOUPLOAD, },
+  [B2055_PRG_GCHP30]		= { .ghz5 = 0x007A, .ghz2 = 0x007A, NOUPLOAD, },
+  [0xC7]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xC8]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xC9]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xCA]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xCB]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xCC]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C1_LNA_GAINBST]	= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xCE]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xCF]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xD0]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xD1]			= { .ghz5 = 0x0018, .ghz2 = 0x0018, NOUPLOAD, },
+  [B2055_C1_B0NB_RSSIVCM]	= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [0xD3]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xD4]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xD5]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C1_GENSPARE2]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xD7]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xD8]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C2_LNA_GAINBST]	= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xDA]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xDB]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xDC]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xDD]			= { .ghz5 = 0x0018, .ghz2 = 0x0018, NOUPLOAD, },
+  [B2055_C2_B0NB_RSSIVCM]	= { .ghz5 = 0x0088, .ghz2 = 0x0088, NOUPLOAD, },
+  [0xDF]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xE0]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [0xE1]			= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+  [B2055_C2_GENSPARE2]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
+};
+
+
+void b2055_upload_inittab(struct b43_wldev *dev,
+			  bool ghz5, bool ignore_uploadflag)
+{
+	struct b2055_inittab_entry *e;
+	unsigned int i;
+	u16 value;
+
+	for (i = 0; i < ARRAY_SIZE(b2055_inittab); i++) {
+		e = &(b2055_inittab[i]);
+		if (!(e->flags & B2055_INITTAB_ENTRY_OK))
+			continue;
+		if ((e->flags & B2055_INITTAB_UPLOAD) || ignore_uploadflag) {
+			if (ghz5)
+				value = e->ghz5;
+			else
+				value = e->ghz2;
+			b43_radio_write16(dev, i, value);
+		}
+	}
+}
Index: wireless-2.6/drivers/net/wireless/b43/tables_nphy.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ wireless-2.6/drivers/net/wireless/b43/tables_nphy.h	2008-01-13 21:02:46.000000000 +0100
@@ -0,0 +1,17 @@
+#ifndef B43_TABLES_NPHY_H_
+#define B43_TABLES_NPHY_H_
+
+#include <linux/types.h>
+
+
+struct b43_wldev;
+
+/* Upload the default register value table.
+ * If "ghz5" is true, we upload the 5Ghz table. Otherwise the 2.4Ghz
+ * table is uploaded. If "ignore_uploadflag" is true, we upload any value
+ * and ignore the "UPLOAD" flag. */
+void b2055_upload_inittab(struct b43_wldev *dev,
+			  bool ghz5, bool ignore_uploadflag);
+
+
+#endif /* B43_TABLES_NPHY_H_ */
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-13 20:57:36.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-13 21:02:46.000000000 +0100
@@ -2129,12 +2129,13 @@ static void b43_rate_memory_write(struct
 
 static void b43_rate_memory_init(struct b43_wldev *dev)
 {
 	switch (dev->phy.type) {
 	case B43_PHYTYPE_A:
 	case B43_PHYTYPE_G:
+	case B43_PHYTYPE_N:
 		b43_rate_memory_write(dev, B43_OFDM_RATE_6MB, 1);
 		b43_rate_memory_write(dev, B43_OFDM_RATE_12MB, 1);
 		b43_rate_memory_write(dev, B43_OFDM_RATE_18MB, 1);
 		b43_rate_memory_write(dev, B43_OFDM_RATE_24MB, 1);
 		b43_rate_memory_write(dev, B43_OFDM_RATE_36MB, 1);
 		b43_rate_memory_write(dev, B43_OFDM_RATE_48MB, 1);
@@ -2317,12 +2318,14 @@ static void b43_periodic_every120sec(str
 }
 
 static void b43_periodic_every60sec(struct b43_wldev *dev)
 {
 	struct b43_phy *phy = &dev->phy;
 
+	if (phy->type != B43_PHYTYPE_G)
+		return;
 	if (!b43_has_hardware_pctl(phy))
 		b43_lo_g_ctl_mark_all_unused(dev);
 	if (dev->dev->bus->sprom.boardflags_lo & B43_BFL_RSSI) {
 		b43_mac_suspend(dev);
 		b43_calc_nrssi_slope(dev);
 		if ((phy->radio_ver == 0x2050) && (phy->radio_rev == 8)) {


From mb at bu3sch.de  Sun Jan 13 22:28:27 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 13 Jan 2008 22:28:27 +0100
Subject: [PATCH] b43: rfkill use after free
In-Reply-To: <1200259252.4393.22.camel@localhost.localdomain>
References: <1200259252.4393.22.camel@localhost.localdomain>
Message-ID: <200801132228.28234.mb@bu3sch.de>

On Sunday 13 January 2008 22:20:52 Eric Paris wrote:
> inside b43_rfkill_exit() we call rfkill_unregister() which puts the last
> reference and frees the rfkill struct.  Then just 3 lines later the code
> explicitly calls rfkill_free() on the struct we already freed.  This
> showed up as slub corruption (what should have been 6b was showing up as
> 6a) since the rfkill_free had dec'ed the are that should have been the
> use counter.
> 
> stop using the already freed rfkill struct.
> 
> =============================================================================
> BUG kmalloc-1024 (Not tainted): Poison overwritten
> -----------------------------------------------------------------------------
> 
> INFO: 0xf40b89e8-0xf40b89e8. First byte 0x6a instead of 0x6b
> INFO: Allocated in rfkill_allocate+0x1b/0x8b [rfkill] age=231032011 cpu=0 pid=2403
> INFO: Freed in rfkill_release+0xd/0x19 [rfkill] age=366 cpu=0 pid=2403
> INFO: Slab 0xc1b62840 used=6 fp=0xf40b8860 flags=0x400040c3
> INFO: Object 0xf40b8860 @offset=2144 fp=0x00000000
> 
> Signed-off-by: Eric Paris <eparis at redhat.com>
> 
> ---
> 
>  drivers/net/wireless/b43/rfkill.c |    1 -
>  1 file changed, 1 deletion(-)
> 
> diff --git a/drivers/net/wireless/b43/rfkill.c b/drivers/net/wireless/b43/rfkill.c
> index 98cf70c..a19be53 100644
> --- a/drivers/net/wireless/b43/rfkill.c
> +++ b/drivers/net/wireless/b43/rfkill.c
> @@ -195,6 +195,5 @@ void b43_rfkill_exit(struct b43_wldev *dev)
>  	rfkill_unregister(rfk->rfkill);
>  	input_free_polled_device(rfk->poll_dev);
>  	rfk->poll_dev = NULL;
> -	rfkill_free(rfk->rfkill);
>  	rfk->rfkill = NULL;
>  }
> 
> 
> 
> 

NACK.
Better patch available from Stefano.

-- 
Greetings Michael.


From mb at bu3sch.de  Mon Jan 14 00:05:57 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 14 Jan 2008 00:05:57 +0100
Subject: [PATCH] b43: Add NPHY channel switch code
Message-ID: <200801140005.57688.mb@bu3sch.de>

This adds code and table data for channel switching on NPHYs.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.25

Index: wireless-2.6/drivers/net/wireless/b43/tables_nphy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/tables_nphy.c	2008-01-13 23:18:48.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/tables_nphy.c	2008-01-13 23:18:48.000000000 +0100
@@ -38,13 +38,13 @@ struct b2055_inittab_entry {
 #define B2055_INITTAB_ENTRY_OK	0x01
 #define B2055_INITTAB_UPLOAD	0x02
 };
 #define UPLOAD		.flags = B2055_INITTAB_ENTRY_OK | B2055_INITTAB_UPLOAD
 #define NOUPLOAD	.flags = B2055_INITTAB_ENTRY_OK
 
-static struct b2055_inittab_entry b2055_inittab [] = {
+static const struct b2055_inittab_entry b2055_inittab [] = {
   [B2055_SP_PINPD]		= { .ghz5 = 0x0080, .ghz2 = 0x0080, NOUPLOAD, },
   [B2055_C1_SP_RSSI]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
   [B2055_C1_SP_PDMISC]		= { .ghz5 = 0x0027, .ghz2 = 0x0027, NOUPLOAD, },
   [B2055_C2_SP_RSSI]		= { .ghz5 = 0x0000, .ghz2 = 0x0000, NOUPLOAD, },
   [B2055_C2_SP_PDMISC]		= { .ghz5 = 0x0027, .ghz2 = 0x0027, NOUPLOAD, },
   [B2055_C1_SP_RXGC1]		= { .ghz5 = 0x007F, .ghz2 = 0x007F, UPLOAD, },
@@ -270,13 +270,13 @@ static struct b2055_inittab_entry b2055_
 };
 
 
 void b2055_upload_inittab(struct b43_wldev *dev,
 			  bool ghz5, bool ignore_uploadflag)
 {
-	struct b2055_inittab_entry *e;
+	const struct b2055_inittab_entry *e;
 	unsigned int i;
 	u16 value;
 
 	for (i = 0; i < ARRAY_SIZE(b2055_inittab); i++) {
 		e = &(b2055_inittab[i]);
 		if (!(e->flags & B2055_INITTAB_ENTRY_OK))
@@ -287,6 +287,1050 @@ void b2055_upload_inittab(struct b43_wld
 			else
 				value = e->ghz2;
 			b43_radio_write16(dev, i, value);
 		}
 	}
 }
+
+
+#define RADIOREGS(r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, \
+		  r12, r13, r14, r15, r16, r17, r18, r19, r20, r21) \
+	.radio_pll_ref		= r0,	\
+	.radio_rf_pllmod0	= r1,	\
+	.radio_rf_pllmod1	= r2,	\
+	.radio_vco_captail	= r3,	\
+	.radio_vco_cal1		= r4,	\
+	.radio_vco_cal2		= r5,	\
+	.radio_pll_lfc1		= r6,	\
+	.radio_pll_lfr1		= r7,	\
+	.radio_pll_lfc2		= r8,	\
+	.radio_lgbuf_cenbuf	= r9,	\
+	.radio_lgen_tune1	= r10,	\
+	.radio_lgen_tune2	= r11,	\
+	.radio_c1_lgbuf_atune	= r12,	\
+	.radio_c1_lgbuf_gtune	= r13,	\
+	.radio_c1_rx_rfr1	= r14,	\
+	.radio_c1_tx_pgapadtn	= r15,	\
+	.radio_c1_tx_mxbgtrim	= r16,	\
+	.radio_c2_lgbuf_atune	= r17,	\
+	.radio_c2_lgbuf_gtune	= r18,	\
+	.radio_c2_rx_rfr1	= r19,	\
+	.radio_c2_tx_pgapadtn	= r20,	\
+	.radio_c2_tx_mxbgtrim	= r21
+
+#define PHYREGS(r0, r1, r2, r3, r4, r5)	\
+	.phy_bw1a	= r0,		\
+	.phy_bw2	= r1,		\
+	.phy_bw3	= r2,		\
+	.phy_bw4	= r3,		\
+	.phy_bw5	= r4,		\
+	.phy_bw6	= r5
+
+static const struct b43_nphy_channeltab_entry b43_nphy_channeltab[] = {
+  {	.channel		= 184,
+	.freq			= 4920, /* MHz */
+	.unk2			= 3280,
+	RADIOREGS(0x71, 0x01, 0xEC, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xFF, 0xFF, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xB407, 0xB007, 0xAC07, 0x1402, 0x1502, 0x1602),
+  },
+  {	.channel		= 186,
+	.freq			= 4930, /* MHz */
+	.unk2			= 3287,
+	RADIOREGS(0x71, 0x01, 0xED, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xFF, 0xFF, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xB807, 0xB407, 0xB007, 0x1302, 0x1402, 0x1502),
+  },
+  {	.channel		= 188,
+	.freq			= 4940, /* MHz */
+	.unk2			= 3293,
+	RADIOREGS(0x71, 0x01, 0xEE, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xEE, 0xEE, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xBC07, 0xB807, 0xB407, 0x1202, 0x1302, 0x1402),
+  },
+  {	.channel		= 190,
+	.freq			= 4950, /* MHz */
+	.unk2			= 3300,
+	RADIOREGS(0x71, 0x01, 0xEF, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xEE, 0xEE, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xC007, 0xBC07, 0xB807, 0x1102, 0x1202, 0x1302),
+  },
+  {	.channel		= 192,
+	.freq			= 4960, /* MHz */
+	.unk2			= 3307,
+	RADIOREGS(0x71, 0x01, 0xF0, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xEE, 0xEE, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xC407, 0xC007, 0xBC07, 0x0F02, 0x1102, 0x1202),
+  },
+  {	.channel		= 194,
+	.freq			= 4970, /* MHz */
+	.unk2			= 3313,
+	RADIOREGS(0x71, 0x01, 0xF1, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xEE, 0xEE, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xC807, 0xC407, 0xC007, 0x0E02, 0x0F02, 0x1102),
+  },
+  {	.channel		= 196,
+	.freq			= 4980, /* MHz */
+	.unk2			= 3320,
+	RADIOREGS(0x71, 0x01, 0xF2, 0x0E, 0xFF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xDD, 0xDD, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xCC07, 0xC807, 0xC407, 0x0D02, 0x0E02, 0x0F02),
+  },
+  {	.channel		= 198,
+	.freq			= 4990, /* MHz */
+	.unk2			= 3327,
+	RADIOREGS(0x71, 0x01, 0xF3, 0x0E, 0xFF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xDD, 0xDD, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xD007, 0xCC07, 0xC807, 0x0C02, 0x0D02, 0x0E02),
+  },
+  {	.channel		= 200,
+	.freq			= 5000, /* MHz */
+	.unk2			= 3333,
+	RADIOREGS(0x71, 0x01, 0xF4, 0x0E, 0xFF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xDD, 0xDD, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xD407, 0xD007, 0xCC07, 0x0B02, 0x0C02, 0x0D02),
+  },
+  {	.channel		= 202,
+	.freq			= 5010, /* MHz */
+	.unk2			= 3340,
+	RADIOREGS(0x71, 0x01, 0xF5, 0x0E, 0xFF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xDD, 0xDD, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xD807, 0xD407, 0xD007, 0x0A02, 0x0B02, 0x0C02),
+  },
+  {	.channel		= 204,
+	.freq			= 5020, /* MHz */
+	.unk2			= 3347,
+	RADIOREGS(0x71, 0x01, 0xF6, 0x0E, 0xF7, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xCC, 0xCC, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xDC07, 0xD807, 0xD407, 0x0902, 0x0A02, 0x0B02),
+  },
+  {	.channel		= 206,
+	.freq			= 5030, /* MHz */
+	.unk2			= 3353,
+	RADIOREGS(0x71, 0x01, 0xF7, 0x0E, 0xF7, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xCC, 0xCC, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xE007, 0xDC07, 0xD807, 0x0802, 0x0902, 0x0A02),
+  },
+  {	.channel		= 208,
+	.freq			= 5040, /* MHz */
+	.unk2			= 3360,
+	RADIOREGS(0x71, 0x01, 0xF8, 0x0D, 0xEF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xCC, 0xCC, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xE407, 0xE007, 0xDC07, 0x0702, 0x0802, 0x0902),
+  },
+  {	.channel		= 210,
+	.freq			= 5050, /* MHz */
+	.unk2			= 3367,
+	RADIOREGS(0x71, 0x01, 0xF9, 0x0D, 0xEF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xCC, 0xCC, 0xFF, 0x00, 0x0F, 0x0F,
+		  0x8F, 0xFF, 0x00, 0x0F, 0x0F, 0x8F),
+	PHYREGS(0xE807, 0xE407, 0xE007, 0x0602, 0x0702, 0x0802),
+  },
+  {	.channel		= 212,
+	.freq			= 5060, /* MHz */
+	.unk2			= 3373,
+	RADIOREGS(0x71, 0x01, 0xFA, 0x0D, 0xE6, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xBB, 0xBB, 0xFF, 0x00, 0x0E, 0x0F,
+		  0x8E, 0xFF, 0x00, 0x0E, 0x0F, 0x8E),
+	PHYREGS(0xEC07, 0xE807, 0xE407, 0x0502, 0x0602, 0x0702),
+  },
+  {	.channel		= 214,
+	.freq			= 5070, /* MHz */
+	.unk2			= 3380,
+	RADIOREGS(0x71, 0x01, 0xFB, 0x0D, 0xE6, 0x01, 0x04, 0x0A,
+		  0x00, 0x8F, 0xBB, 0xBB, 0xFF, 0x00, 0x0E, 0x0F,
+		  0x8E, 0xFF, 0x00, 0x0E, 0x0F, 0x8E),
+	PHYREGS(0xF007, 0xEC07, 0xE807, 0x0402, 0x0502, 0x0602),
+  },
+  {	.channel		= 216,
+	.freq			= 5080, /* MHz */
+	.unk2			= 3387,
+	RADIOREGS(0x71, 0x01, 0xFC, 0x0D, 0xDE, 0x01, 0x04, 0x0A,
+		  0x00, 0x8E, 0xBB, 0xBB, 0xEE, 0x00, 0x0E, 0x0F,
+		  0x8D, 0xEE, 0x00, 0x0E, 0x0F, 0x8D),
+	PHYREGS(0xF407, 0xF007, 0xEC07, 0x0302, 0x0402, 0x0502),
+  },
+  {	.channel		= 218,
+	.freq			= 5090, /* MHz */
+	.unk2			= 3393,
+	RADIOREGS(0x71, 0x01, 0xFD, 0x0D, 0xDE, 0x01, 0x04, 0x0A,
+		  0x00, 0x8E, 0xBB, 0xBB, 0xEE, 0x00, 0x0E, 0x0F,
+		  0x8D, 0xEE, 0x00, 0x0E, 0x0F, 0x8D),
+	PHYREGS(0xF807, 0xF407, 0xF007, 0x0202, 0x0302, 0x0402),
+  },
+  {	.channel		= 220,
+	.freq			= 5100, /* MHz */
+	.unk2			= 3400,
+	RADIOREGS(0x71, 0x01, 0xFE, 0x0C, 0xD6, 0x01, 0x04, 0x0A,
+		  0x00, 0x8E, 0xAA, 0xAA, 0xEE, 0x00, 0x0D, 0x0F,
+		  0x8D, 0xEE, 0x00, 0x0D, 0x0F, 0x8D),
+	PHYREGS(0xFC07, 0xF807, 0xF407, 0x0102, 0x0202, 0x0302),
+  },
+  {	.channel		= 222,
+	.freq			= 5110, /* MHz */
+	.unk2			= 3407,
+	RADIOREGS(0x71, 0x01, 0xFF, 0x0C, 0xD6, 0x01, 0x04, 0x0A,
+		  0x00, 0x8E, 0xAA, 0xAA, 0xEE, 0x00, 0x0D, 0x0F,
+		  0x8D, 0xEE, 0x00, 0x0D, 0x0F, 0x8D),
+	PHYREGS(0x0008, 0xFC07, 0xF807, 0x0002, 0x0102, 0x0202),
+  },
+  {	.channel		= 224,
+	.freq			= 5120, /* MHz */
+	.unk2			= 3413,
+	RADIOREGS(0x71, 0x02, 0x00, 0x0C, 0xCE, 0x01, 0x04, 0x0A,
+		  0x00, 0x8D, 0xAA, 0xAA, 0xDD, 0x00, 0x0D, 0x0F,
+		  0x8C, 0xDD, 0x00, 0x0D, 0x0F, 0x8C),
+	PHYREGS(0x0408, 0x0008, 0xFC07, 0xFF01, 0x0002, 0x0102),
+  },
+  {	.channel		= 226,
+	.freq			= 5130, /* MHz */
+	.unk2			= 3420,
+	RADIOREGS(0x71, 0x02, 0x01, 0x0C, 0xCE, 0x01, 0x04, 0x0A,
+		  0x00, 0x8D, 0xAA, 0xAA, 0xDD, 0x00, 0x0D, 0x0F,
+		  0x8C, 0xDD, 0x00, 0x0D, 0x0F, 0x8C),
+	PHYREGS(0x0808, 0x0408, 0x0008, 0xFE01, 0xFF01, 0x0002),
+  },
+  {	.channel		= 228,
+	.freq			= 5140, /* MHz */
+	.unk2			= 3427,
+	RADIOREGS(0x71, 0x02, 0x02, 0x0C, 0xC6, 0x01, 0x04, 0x0A,
+		  0x00, 0x8D, 0x99, 0x99, 0xDD, 0x00, 0x0C, 0x0E,
+		  0x8B, 0xDD, 0x00, 0x0C, 0x0E, 0x8B),
+	PHYREGS(0x0C08, 0x0808, 0x0408, 0xFD01, 0xFE01, 0xFF01),
+  },
+  {	.channel		= 32,
+	.freq			= 5160, /* MHz */
+	.unk2			= 3440,
+	RADIOREGS(0x71, 0x02, 0x04, 0x0B, 0xBE, 0x01, 0x04, 0x0A,
+		  0x00, 0x8C, 0x99, 0x99, 0xCC, 0x00, 0x0B, 0x0D,
+		  0x8A, 0xCC, 0x00, 0x0B, 0x0D, 0x8A),
+	PHYREGS(0x1408, 0x1008, 0x0C08, 0xFB01, 0xFC01, 0xFD01),
+  },
+  {	.channel		= 34,
+	.freq			= 5170, /* MHz */
+	.unk2			= 3447,
+	RADIOREGS(0x71, 0x02, 0x05, 0x0B, 0xBE, 0x01, 0x04, 0x0A,
+		  0x00, 0x8C, 0x99, 0x99, 0xCC, 0x00, 0x0B, 0x0D,
+		  0x8A, 0xCC, 0x00, 0x0B, 0x0D, 0x8A),
+	PHYREGS(0x1808, 0x1408, 0x1008, 0xFA01, 0xFB01, 0xFC01),
+  },
+  {	.channel		= 36,
+	.freq			= 5180, /* MHz */
+	.unk2			= 3453,
+	RADIOREGS(0x71, 0x02, 0x06, 0x0B, 0xB6, 0x01, 0x04, 0x0A,
+		  0x00, 0x8C, 0x88, 0x88, 0xCC, 0x00, 0x0B, 0x0C,
+		  0x89, 0xCC, 0x00, 0x0B, 0x0C, 0x89),
+	PHYREGS(0x1C08, 0x1808, 0x1408, 0xF901, 0xFA01, 0xFB01),
+  },
+  {	.channel		= 38,
+	.freq			= 5190, /* MHz */
+	.unk2			= 3460,
+	RADIOREGS(0x71, 0x02, 0x07, 0x0B, 0xB6, 0x01, 0x04, 0x0A,
+		  0x00, 0x8C, 0x88, 0x88, 0xCC, 0x00, 0x0B, 0x0C,
+		  0x89, 0xCC, 0x00, 0x0B, 0x0C, 0x89),
+	PHYREGS(0x2008, 0x1C08, 0x1808, 0xF801, 0xF901, 0xFA01),
+  },
+  {	.channel		= 40,
+	.freq			= 5200, /* MHz */
+	.unk2			= 3467,
+	RADIOREGS(0x71, 0x02, 0x08, 0x0B, 0xAF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8B, 0x88, 0x88, 0xBB, 0x00, 0x0A, 0x0B,
+		  0x89, 0xBB, 0x00, 0x0A, 0x0B, 0x89),
+	PHYREGS(0x2408, 0x2008, 0x1C08, 0xF701, 0xF801, 0xF901),
+  },
+  {	.channel		= 42,
+	.freq			= 5210, /* MHz */
+	.unk2			= 3473,
+	RADIOREGS(0x71, 0x02, 0x09, 0x0B, 0xAF, 0x01, 0x04, 0x0A,
+		  0x00, 0x8B, 0x88, 0x88, 0xBB, 0x00, 0x0A, 0x0B,
+		  0x89, 0xBB, 0x00, 0x0A, 0x0B, 0x89),
+	PHYREGS(0x2808, 0x2408, 0x2008, 0xF601, 0xF701, 0xF801),
+  },
+  {	.channel		= 44,
+	.freq			= 5220, /* MHz */
+	.unk2			= 3480,
+	RADIOREGS(0x71, 0x02, 0x0A, 0x0A, 0xA7, 0x01, 0x04, 0x0A,
+		  0x00, 0x8B, 0x77, 0x77, 0xBB, 0x00, 0x09, 0x0A,
+		  0x88, 0xBB, 0x00, 0x09, 0x0A, 0x88),
+	PHYREGS(0x2C08, 0x2808, 0x2408, 0xF501, 0xF601, 0xF701),
+  },
+  {	.channel		= 46,
+	.freq			= 5230, /* MHz */
+	.unk2			= 3487,
+	RADIOREGS(0x71, 0x02, 0x0B, 0x0A, 0xA7, 0x01, 0x04, 0x0A,
+		  0x00, 0x8B, 0x77, 0x77, 0xBB, 0x00, 0x09, 0x0A,
+		  0x88, 0xBB, 0x00, 0x09, 0x0A, 0x88),
+	PHYREGS(0x3008, 0x2C08, 0x2808, 0xF401, 0xF501, 0xF601),
+  },
+  {	.channel		= 48,
+	.freq			= 5240, /* MHz */
+	.unk2			= 3493,
+	RADIOREGS(0x71, 0x02, 0x0C, 0x0A, 0xA0, 0x01, 0x04, 0x0A,
+		  0x00, 0x8A, 0x77, 0x77, 0xAA, 0x00, 0x09, 0x0A,
+		  0x87, 0xAA, 0x00, 0x09, 0x0A, 0x87),
+	PHYREGS(0x3408, 0x3008, 0x2C08, 0xF301, 0xF401, 0xF501),
+  },
+  {	.channel		= 50,
+	.freq			= 5250, /* MHz */
+	.unk2			= 3500,
+	RADIOREGS(0x71, 0x02, 0x0D, 0x0A, 0xA0, 0x01, 0x04, 0x0A,
+		  0x00, 0x8A, 0x77, 0x77, 0xAA, 0x00, 0x09, 0x0A,
+		  0x87, 0xAA, 0x00, 0x09, 0x0A, 0x87),
+	PHYREGS(0x3808, 0x3408, 0x3008, 0xF201, 0xF301, 0xF401),
+  },
+  {	.channel		= 52,
+	.freq			= 5260, /* MHz */
+	.unk2			= 3507,
+	RADIOREGS(0x71, 0x02, 0x0E, 0x0A, 0x98, 0x01, 0x04, 0x0A,
+		  0x00, 0x8A, 0x66, 0x66, 0xAA, 0x00, 0x08, 0x09,
+		  0x87, 0xAA, 0x00, 0x08, 0x09, 0x87),
+	PHYREGS(0x3C08, 0x3808, 0x3408, 0xF101, 0xF201, 0xF301),
+  },
+  {	.channel		= 54,
+	.freq			= 5270, /* MHz */
+	.unk2			= 3513,
+	RADIOREGS(0x71, 0x02, 0x0F, 0x0A, 0x98, 0x01, 0x04, 0x0A,
+		  0x00, 0x8A, 0x66, 0x66, 0xAA, 0x00, 0x08, 0x09,
+		  0x87, 0xAA, 0x00, 0x08, 0x09, 0x87),
+	PHYREGS(0x4008, 0x3C08, 0x3808, 0xF001, 0xF101, 0xF201),
+  },
+  {	.channel		= 56,
+	.freq			= 5280, /* MHz */
+	.unk2			= 3520,
+	RADIOREGS(0x71, 0x02, 0x10, 0x09, 0x91, 0x01, 0x04, 0x0A,
+		  0x00, 0x89, 0x66, 0x66, 0x99, 0x00, 0x08, 0x08,
+		  0x86, 0x99, 0x00, 0x08, 0x08, 0x86),
+	PHYREGS(0x4408, 0x4008, 0x3C08, 0xF001, 0xF001, 0xF101),
+  },
+  {	.channel		= 58,
+	.freq			= 5290, /* MHz */
+	.unk2			= 3527,
+	RADIOREGS(0x71, 0x02, 0x11, 0x09, 0x91, 0x01, 0x04, 0x0A,
+		  0x00, 0x89, 0x66, 0x66, 0x99, 0x00, 0x08, 0x08,
+		  0x86, 0x99, 0x00, 0x08, 0x08, 0x86),
+	PHYREGS(0x4808, 0x4408, 0x4008, 0xEF01, 0xF001, 0xF001),
+  },
+  {	.channel		= 60,
+	.freq			= 5300, /* MHz */
+	.unk2			= 3533,
+	RADIOREGS(0x71, 0x02, 0x12, 0x09, 0x8A, 0x01, 0x04, 0x0A,
+		  0x00, 0x89, 0x55, 0x55, 0x99, 0x00, 0x08, 0x07,
+		  0x85, 0x99, 0x00, 0x08, 0x07, 0x85),
+	PHYREGS(0x4C08, 0x4808, 0x4408, 0xEE01, 0xEF01, 0xF001),
+  },
+  {	.channel		= 62,
+	.freq			= 5310, /* MHz */
+	.unk2			= 3540,
+	RADIOREGS(0x71, 0x02, 0x13, 0x09, 0x8A, 0x01, 0x04, 0x0A,
+		  0x00, 0x89, 0x55, 0x55, 0x99, 0x00, 0x08, 0x07,
+		  0x85, 0x99, 0x00, 0x08, 0x07, 0x85),
+	PHYREGS(0x5008, 0x4C08, 0x4808, 0xED01, 0xEE01, 0xEF01),
+  },
+  {	.channel		= 64,
+	.freq			= 5320, /* MHz */
+	.unk2			= 3547,
+	RADIOREGS(0x71, 0x02, 0x14, 0x09, 0x83, 0x01, 0x04, 0x0A,
+		  0x00, 0x88, 0x55, 0x55, 0x88, 0x00, 0x07, 0x07,
+		  0x84, 0x88, 0x00, 0x07, 0x07, 0x84),
+	PHYREGS(0x5408, 0x5008, 0x4C08, 0xEC01, 0xED01, 0xEE01),
+  },
+  {	.channel		= 66,
+	.freq			= 5330, /* MHz */
+	.unk2			= 3553,
+	RADIOREGS(0x71, 0x02, 0x15, 0x09, 0x83, 0x01, 0x04, 0x0A,
+		  0x00, 0x88, 0x55, 0x55, 0x88, 0x00, 0x07, 0x07,
+		  0x84, 0x88, 0x00, 0x07, 0x07, 0x84),
+	PHYREGS(0x5808, 0x5408, 0x5008, 0xEB01, 0xEC01, 0xED01),
+  },
+  {	.channel		= 68,
+	.freq			= 5340, /* MHz */
+	.unk2			= 3560,
+	RADIOREGS(0x71, 0x02, 0x16, 0x08, 0x7C, 0x01, 0x04, 0x0A,
+		  0x00, 0x88, 0x44, 0x44, 0x88, 0x00, 0x07, 0x06,
+		  0x84, 0x88, 0x00, 0x07, 0x06, 0x84),
+	PHYREGS(0x5C08, 0x5808, 0x5408, 0xEA01, 0xEB01, 0xEC01),
+  },
+  {	.channel		= 70,
+	.freq			= 5350, /* MHz */
+	.unk2			= 3567,
+	RADIOREGS(0x71, 0x02, 0x17, 0x08, 0x7C, 0x01, 0x04, 0x0A,
+		  0x00, 0x88, 0x44, 0x44, 0x88, 0x00, 0x07, 0x06,
+		  0x84, 0x88, 0x00, 0x07, 0x06, 0x84),
+	PHYREGS(0x6008, 0x5C08, 0x5808, 0xE901, 0xEA01, 0xEB01),
+  },
+  {	.channel		= 72,
+	.freq			= 5360, /* MHz */
+	.unk2			= 3573,
+	RADIOREGS(0x71, 0x02, 0x18, 0x08, 0x75, 0x01, 0x04, 0x0A,
+		  0x00, 0x87, 0x44, 0x44, 0x77, 0x00, 0x06, 0x05,
+		  0x83, 0x77, 0x00, 0x06, 0x05, 0x83),
+	PHYREGS(0x6408, 0x6008, 0x5C08, 0xE801, 0xE901, 0xEA01),
+  },
+  {	.channel		= 74,
+	.freq			= 5370, /* MHz */
+	.unk2			= 3580,
+	RADIOREGS(0x71, 0x02, 0x19, 0x08, 0x75, 0x01, 0x04, 0x0A,
+		  0x00, 0x87, 0x44, 0x44, 0x77, 0x00, 0x06, 0x05,
+		  0x83, 0x77, 0x00, 0x06, 0x05, 0x83),
+	PHYREGS(0x6808, 0x6408, 0x6008, 0xE701, 0xE801, 0xE901),
+  },
+  {	.channel		= 76,
+	.freq			= 5380, /* MHz */
+	.unk2			= 3587,
+	RADIOREGS(0x71, 0x02, 0x1A, 0x08, 0x6E, 0x01, 0x04, 0x0A,
+		  0x00, 0x87, 0x33, 0x33, 0x77, 0x00, 0x06, 0x04,
+		  0x82, 0x77, 0x00, 0x06, 0x04, 0x82),
+	PHYREGS(0x6C08, 0x6808, 0x6408, 0xE601, 0xE701, 0xE801),
+  },
+  {	.channel		= 78,
+	.freq			= 5390, /* MHz */
+	.unk2			= 3593,
+	RADIOREGS(0x71, 0x02, 0x1B, 0x08, 0x6E, 0x01, 0x04, 0x0A,
+		  0x00, 0x87, 0x33, 0x33, 0x77, 0x00, 0x06, 0x04,
+		  0x82, 0x77, 0x00, 0x06, 0x04, 0x82),
+	PHYREGS(0x7008, 0x6C08, 0x6808, 0xE501, 0xE601, 0xE701),
+  },
+  {	.channel		= 80,
+	.freq			= 5400, /* MHz */
+	.unk2			= 3600,
+	RADIOREGS(0x71, 0x02, 0x1C, 0x07, 0x67, 0x01, 0x04, 0x0A,
+		  0x00, 0x86, 0x33, 0x33, 0x66, 0x00, 0x05, 0x04,
+		  0x81, 0x66, 0x00, 0x05, 0x04, 0x81),
+	PHYREGS(0x7408, 0x7008, 0x6C08, 0xE501, 0xE501, 0xE601),
+  },
+  {	.channel		= 82,
+	.freq			= 5410, /* MHz */
+	.unk2			= 3607,
+	RADIOREGS(0x71, 0x02, 0x1D, 0x07, 0x67, 0x01, 0x04, 0x0A,
+		  0x00, 0x86, 0x33, 0x33, 0x66, 0x00, 0x05, 0x04,
+		  0x81, 0x66, 0x00, 0x05, 0x04, 0x81),
+	PHYREGS(0x7808, 0x7408, 0x7008, 0xE401, 0xE501, 0xE501),
+  },
+  {	.channel		= 84,
+	.freq			= 5420, /* MHz */
+	.unk2			= 3613,
+	RADIOREGS(0x71, 0x02, 0x1E, 0x07, 0x61, 0x01, 0x04, 0x0A,
+		  0x00, 0x86, 0x22, 0x22, 0x66, 0x00, 0x05, 0x03,
+		  0x80, 0x66, 0x00, 0x05, 0x03, 0x80),
+	PHYREGS(0x7C08, 0x7808, 0x7408, 0xE301, 0xE401, 0xE501),
+  },
+  {	.channel		= 86,
+	.freq			= 5430, /* MHz */
+	.unk2			= 3620,
+	RADIOREGS(0x71, 0x02, 0x1F, 0x07, 0x61, 0x01, 0x04, 0x0A,
+		  0x00, 0x86, 0x22, 0x22, 0x66, 0x00, 0x05, 0x03,
+		  0x80, 0x66, 0x00, 0x05, 0x03, 0x80),
+	PHYREGS(0x8008, 0x7C08, 0x7808, 0xE201, 0xE301, 0xE401),
+  },
+  {	.channel		= 88,
+	.freq			= 5440, /* MHz */
+	.unk2			= 3627,
+	RADIOREGS(0x71, 0x02, 0x20, 0x07, 0x5A, 0x01, 0x04, 0x0A,
+		  0x00, 0x85, 0x22, 0x22, 0x55, 0x00, 0x04, 0x02,
+		  0x80, 0x55, 0x00, 0x04, 0x02, 0x80),
+	PHYREGS(0x8408, 0x8008, 0x7C08, 0xE101, 0xE201, 0xE301),
+  },
+  {	.channel		= 90,
+	.freq			= 5450, /* MHz */
+	.unk2			= 3633,
+	RADIOREGS(0x71, 0x02, 0x21, 0x07, 0x5A, 0x01, 0x04, 0x0A,
+		  0x00, 0x85, 0x22, 0x22, 0x55, 0x00, 0x04, 0x02,
+		  0x80, 0x55, 0x00, 0x04, 0x02, 0x80),
+	PHYREGS(0x8808, 0x8408, 0x8008, 0xE001, 0xE101, 0xE201),
+  },
+  {	.channel		= 92,
+	.freq			= 5460, /* MHz */
+	.unk2			= 3640,
+	RADIOREGS(0x71, 0x02, 0x22, 0x06, 0x53, 0x01, 0x04, 0x0A,
+		  0x00, 0x85, 0x11, 0x11, 0x55, 0x00, 0x04, 0x01,
+		  0x80, 0x55, 0x00, 0x04, 0x01, 0x80),
+	PHYREGS(0x8C08, 0x8808, 0x8408, 0xDF01, 0xE001, 0xE101),
+  },
+  {	.channel		= 94,
+	.freq			= 5470, /* MHz */
+	.unk2			= 3647,
+	RADIOREGS(0x71, 0x02, 0x23, 0x06, 0x53, 0x01, 0x04, 0x0A,
+		  0x00, 0x85, 0x11, 0x11, 0x55, 0x00, 0x04, 0x01,
+		  0x80, 0x55, 0x00, 0x04, 0x01, 0x80),
+	PHYREGS(0x9008, 0x8C08, 0x8808, 0xDE01, 0xDF01, 0xE001),
+  },
+  {	.channel		= 96,
+	.freq			= 5480, /* MHz */
+	.unk2			= 3653,
+	RADIOREGS(0x71, 0x02, 0x24, 0x06, 0x4D, 0x01, 0x04, 0x0A,
+		  0x00, 0x84, 0x11, 0x11, 0x44, 0x00, 0x03, 0x00,
+		  0x80, 0x44, 0x00, 0x03, 0x00, 0x80),
+	PHYREGS(0x9408, 0x9008, 0x8C08, 0xDD01, 0xDE01, 0xDF01),
+  },
+  {	.channel		= 98,
+	.freq			= 5490, /* MHz */
+	.unk2			= 3660,
+	RADIOREGS(0x71, 0x02, 0x25, 0x06, 0x4D, 0x01, 0x04, 0x0A,
+		  0x00, 0x84, 0x11, 0x11, 0x44, 0x00, 0x03, 0x00,
+		  0x80, 0x44, 0x00, 0x03, 0x00, 0x80),
+	PHYREGS(0x9808, 0x9408, 0x9008, 0xDD01, 0xDD01, 0xDE01),
+  },
+  {	.channel		= 100,
+	.freq			= 5500, /* MHz */
+	.unk2			= 3667,
+	RADIOREGS(0x71, 0x02, 0x26, 0x06, 0x47, 0x01, 0x04, 0x0A,
+		  0x00, 0x84, 0x00, 0x00, 0x44, 0x00, 0x03, 0x00,
+		  0x80, 0x44, 0x00, 0x03, 0x00, 0x80),
+	PHYREGS(0x9C08, 0x9808, 0x9408, 0xDC01, 0xDD01, 0xDD01),
+  },
+  {	.channel		= 102,
+	.freq			= 5510, /* MHz */
+	.unk2			= 3673,
+	RADIOREGS(0x71, 0x02, 0x27, 0x06, 0x47, 0x01, 0x04, 0x0A,
+		  0x00, 0x84, 0x00, 0x00, 0x44, 0x00, 0x03, 0x00,
+		  0x80, 0x44, 0x00, 0x03, 0x00, 0x80),
+	PHYREGS(0xA008, 0x9C08, 0x9808, 0xDB01, 0xDC01, 0xDD01),
+  },
+  {	.channel		= 104,
+	.freq			= 5520, /* MHz */
+	.unk2			= 3680,
+	RADIOREGS(0x71, 0x02, 0x28, 0x05, 0x40, 0x01, 0x04, 0x0A,
+		  0x00, 0x83, 0x00, 0x00, 0x33, 0x00, 0x02, 0x00,
+		  0x80, 0x33, 0x00, 0x02, 0x00, 0x80),
+	PHYREGS(0xA408, 0xA008, 0x9C08, 0xDA01, 0xDB01, 0xDC01),
+  },
+  {	.channel		= 106,
+	.freq			= 5530, /* MHz */
+	.unk2			= 3687,
+	RADIOREGS(0x71, 0x02, 0x29, 0x05, 0x40, 0x01, 0x04, 0x0A,
+		  0x00, 0x83, 0x00, 0x00, 0x33, 0x00, 0x02, 0x00,
+		  0x80, 0x33, 0x00, 0x02, 0x00, 0x80),
+	PHYREGS(0xA808, 0xA408, 0xA008, 0xD901, 0xDA01, 0xDB01),
+  },
+  {	.channel		= 108,
+	.freq			= 5540, /* MHz */
+	.unk2			= 3693,
+	RADIOREGS(0x71, 0x02, 0x2A, 0x05, 0x3A, 0x01, 0x04, 0x0A,
+		  0x00, 0x83, 0x00, 0x00, 0x33, 0x00, 0x02, 0x00,
+		  0x80, 0x33, 0x00, 0x02, 0x00, 0x80),
+	PHYREGS(0xAC08, 0xA808, 0xA408, 0xD801, 0xD901, 0xDA01),
+  },
+  {	.channel		= 110,
+	.freq			= 5550, /* MHz */
+	.unk2			= 3700,
+	RADIOREGS(0x71, 0x02, 0x2B, 0x05, 0x3A, 0x01, 0x04, 0x0A,
+		  0x00, 0x83, 0x00, 0x00, 0x33, 0x00, 0x02, 0x00,
+		  0x80, 0x33, 0x00, 0x02, 0x00, 0x80),
+	PHYREGS(0xB008, 0xAC08, 0xA808, 0xD701, 0xD801, 0xD901),
+  },
+  {	.channel		= 112,
+	.freq			= 5560, /* MHz */
+	.unk2			= 3707,
+	RADIOREGS(0x71, 0x02, 0x2C, 0x05, 0x34, 0x01, 0x04, 0x0A,
+		  0x00, 0x82, 0x00, 0x00, 0x22, 0x00, 0x01, 0x00,
+		  0x80, 0x22, 0x00, 0x01, 0x00, 0x80),
+	PHYREGS(0xB408, 0xB008, 0xAC08, 0xD701, 0xD701, 0xD801),
+  },
+  {	.channel		= 114,
+	.freq			= 5570, /* MHz */
+	.unk2			= 3713,
+	RADIOREGS(0x71, 0x02, 0x2D, 0x05, 0x34, 0x01, 0x04, 0x0A,
+		  0x00, 0x82, 0x00, 0x00, 0x22, 0x00, 0x01, 0x00,
+		  0x80, 0x22, 0x00, 0x01, 0x00, 0x80),
+	PHYREGS(0xB808, 0xB408, 0xB008, 0xD601, 0xD701, 0xD701),
+  },
+  {	.channel		= 116,
+	.freq			= 5580, /* MHz */
+	.unk2			= 3720,
+	RADIOREGS(0x71, 0x02, 0x2E, 0x04, 0x2E, 0x01, 0x04, 0x0A,
+		  0x00, 0x82, 0x00, 0x00, 0x22, 0x00, 0x01, 0x00,
+		  0x80, 0x22, 0x00, 0x01, 0x00, 0x80),
+	PHYREGS(0xBC08, 0xB808, 0xB408, 0xD501, 0xD601, 0xD701),
+  },
+  {	.channel		= 118,
+	.freq			= 5590, /* MHz */
+	.unk2			= 3727,
+	RADIOREGS(0x71, 0x02, 0x2F, 0x04, 0x2E, 0x01, 0x04, 0x0A,
+		  0x00, 0x82, 0x00, 0x00, 0x22, 0x00, 0x01, 0x00,
+		  0x80, 0x22, 0x00, 0x01, 0x00, 0x80),
+	PHYREGS(0xC008, 0xBC08, 0xB808, 0xD401, 0xD501, 0xD601),
+  },
+  {	.channel		= 120,
+	.freq			= 5600, /* MHz */
+	.unk2			= 3733,
+	RADIOREGS(0x71, 0x02, 0x30, 0x04, 0x28, 0x01, 0x04, 0x0A,
+		  0x00, 0x81, 0x00, 0x00, 0x11, 0x00, 0x01, 0x00,
+		  0x80, 0x11, 0x00, 0x01, 0x00, 0x80),
+	PHYREGS(0xC408, 0xC008, 0xBC08, 0xD301, 0xD401, 0xD501),
+  },
+  {	.channel		= 122,
+	.freq			= 5610, /* MHz */
+	.unk2			= 3740,
+	RADIOREGS(0x71, 0x02, 0x31, 0x04, 0x28, 0x01, 0x04, 0x0A,
+		  0x00, 0x81, 0x00, 0x00, 0x11, 0x00, 0x01, 0x00,
+		  0x80, 0x11, 0x00, 0x01, 0x00, 0x80),
+	PHYREGS(0xC808, 0xC408, 0xC008, 0xD201, 0xD301, 0xD401),
+  },
+  {	.channel		= 124,
+	.freq			= 5620, /* MHz */
+	.unk2			= 3747,
+	RADIOREGS(0x71, 0x02, 0x32, 0x04, 0x21, 0x01, 0x04, 0x0A,
+		  0x00, 0x81, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
+		  0x80, 0x11, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xCC08, 0xC808, 0xC408, 0xD201, 0xD201, 0xD301),
+  },
+  {	.channel		= 126,
+	.freq			= 5630, /* MHz */
+	.unk2			= 3753,
+	RADIOREGS(0x71, 0x02, 0x33, 0x04, 0x21, 0x01, 0x04, 0x0A,
+		  0x00, 0x81, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
+		  0x80, 0x11, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xD008, 0xCC08, 0xC808, 0xD101, 0xD201, 0xD201),
+  },
+  {	.channel		= 128,
+	.freq			= 5640, /* MHz */
+	.unk2			= 3760,
+	RADIOREGS(0x71, 0x02, 0x34, 0x03, 0x1C, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xD408, 0xD008, 0xCC08, 0xD001, 0xD101, 0xD201),
+  },
+  {	.channel		= 130,
+	.freq			= 5650, /* MHz */
+	.unk2			= 3767,
+	RADIOREGS(0x71, 0x02, 0x35, 0x03, 0x1C, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xD808, 0xD408, 0xD008, 0xCF01, 0xD001, 0xD101),
+  },
+  {	.channel		= 132,
+	.freq			= 5660, /* MHz */
+	.unk2			= 3773,
+	RADIOREGS(0x71, 0x02, 0x36, 0x03, 0x16, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xDC08, 0xD808, 0xD408, 0xCE01, 0xCF01, 0xD001),
+  },
+  {	.channel		= 134,
+	.freq			= 5670, /* MHz */
+	.unk2			= 3780,
+	RADIOREGS(0x71, 0x02, 0x37, 0x03, 0x16, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xE008, 0xDC08, 0xD808, 0xCE01, 0xCE01, 0xCF01),
+  },
+  {	.channel		= 136,
+	.freq			= 5680, /* MHz */
+	.unk2			= 3787,
+	RADIOREGS(0x71, 0x02, 0x38, 0x03, 0x10, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xE408, 0xE008, 0xDC08, 0xCD01, 0xCE01, 0xCE01),
+  },
+  {	.channel		= 138,
+	.freq			= 5690, /* MHz */
+	.unk2			= 3793,
+	RADIOREGS(0x71, 0x02, 0x39, 0x03, 0x10, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xE808, 0xE408, 0xE008, 0xCC01, 0xCD01, 0xCE01),
+  },
+  {	.channel		= 140,
+	.freq			= 5700, /* MHz */
+	.unk2			= 3800,
+	RADIOREGS(0x71, 0x02, 0x3A, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xEC08, 0xE808, 0xE408, 0xCB01, 0xCC01, 0xCD01),
+  },
+  {	.channel		= 142,
+	.freq			= 5710, /* MHz */
+	.unk2			= 3807,
+	RADIOREGS(0x71, 0x02, 0x3B, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xF008, 0xEC08, 0xE808, 0xCA01, 0xCB01, 0xCC01),
+  },
+  {	.channel		= 144,
+	.freq			= 5720, /* MHz */
+	.unk2			= 3813,
+	RADIOREGS(0x71, 0x02, 0x3C, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xF408, 0xF008, 0xEC08, 0xC901, 0xCA01, 0xCB01),
+  },
+  {	.channel		= 145,
+	.freq			= 5725, /* MHz */
+	.unk2			= 3817,
+	RADIOREGS(0x72, 0x04, 0x79, 0x02, 0x03, 0x01, 0x03, 0x14,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xF608, 0xF208, 0xEE08, 0xC901, 0xCA01, 0xCB01),
+  },
+  {	.channel		= 146,
+	.freq			= 5730, /* MHz */
+	.unk2			= 3820,
+	RADIOREGS(0x71, 0x02, 0x3D, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xF808, 0xF408, 0xF008, 0xC901, 0xC901, 0xCA01),
+  },
+  {	.channel		= 147,
+	.freq			= 5735, /* MHz */
+	.unk2			= 3823,
+	RADIOREGS(0x72, 0x04, 0x7B, 0x02, 0x03, 0x01, 0x03, 0x14,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xFA08, 0xF608, 0xF208, 0xC801, 0xC901, 0xCA01),
+  },
+  {	.channel		= 148,
+	.freq			= 5740, /* MHz */
+	.unk2			= 3827,
+	RADIOREGS(0x71, 0x02, 0x3E, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xFC08, 0xF808, 0xF408, 0xC801, 0xC901, 0xC901),
+  },
+  {	.channel		= 149,
+	.freq			= 5745, /* MHz */
+	.unk2			= 3830,
+	RADIOREGS(0x72, 0x04, 0x7D, 0x02, 0xFE, 0x00, 0x03, 0x14,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0xFE08, 0xFA08, 0xF608, 0xC801, 0xC801, 0xC901),
+  },
+  {	.channel		= 150,
+	.freq			= 5750, /* MHz */
+	.unk2			= 3833,
+	RADIOREGS(0x71, 0x02, 0x3F, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x0009, 0xFC08, 0xF808, 0xC701, 0xC801, 0xC901),
+  },
+  {	.channel		= 151,
+	.freq			= 5755, /* MHz */
+	.unk2			= 3837,
+	RADIOREGS(0x72, 0x04, 0x7F, 0x02, 0xFE, 0x00, 0x03, 0x14,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x0209, 0xFE08, 0xFA08, 0xC701, 0xC801, 0xC801),
+  },
+  {	.channel		= 152,
+	.freq			= 5760, /* MHz */
+	.unk2			= 3840,
+	RADIOREGS(0x71, 0x02, 0x40, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x0409, 0x0009, 0xFC08, 0xC601, 0xC701, 0xC801),
+  },
+  {	.channel		= 153,
+	.freq			= 5765, /* MHz */
+	.unk2			= 3843,
+	RADIOREGS(0x72, 0x04, 0x81, 0x02, 0xF8, 0x00, 0x03, 0x14,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x0609, 0x0209, 0xFE08, 0xC601, 0xC701, 0xC801),
+  },
+  {	.channel		= 154,
+	.freq			= 5770, /* MHz */
+	.unk2			= 3847,
+	RADIOREGS(0x71, 0x02, 0x41, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x0809, 0x0409, 0x0009, 0xC601, 0xC601, 0xC701),
+  },
+  {	.channel		= 155,
+	.freq			= 5775, /* MHz */
+	.unk2			= 3850,
+	RADIOREGS(0x72, 0x04, 0x83, 0x02, 0xF8, 0x00, 0x03, 0x14,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x0A09, 0x0609, 0x0209, 0xC501, 0xC601, 0xC701),
+  },
+  {	.channel		= 156,
+	.freq			= 5780, /* MHz */
+	.unk2			= 3853,
+	RADIOREGS(0x71, 0x02, 0x42, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x0C09, 0x0809, 0x0409, 0xC501, 0xC601, 0xC601),
+  },
+  {	.channel		= 157,
+	.freq			= 5785, /* MHz */
+	.unk2			= 3857,
+	RADIOREGS(0x72, 0x04, 0x85, 0x02, 0xF2, 0x00, 0x03, 0x14,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x0E09, 0x0A09, 0x0609, 0xC401, 0xC501, 0xC601),
+  },
+  {	.channel		= 158,
+	.freq			= 5790, /* MHz */
+	.unk2			= 3860,
+	RADIOREGS(0x71, 0x02, 0x43, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x1009, 0x0C09, 0x0809, 0xC401, 0xC501, 0xC601),
+  },
+  {	.channel		= 159,
+	.freq			= 5795, /* MHz */
+	.unk2			= 3863,
+	RADIOREGS(0x72, 0x04, 0x87, 0x02, 0xF2, 0x00, 0x03, 0x14,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x1209, 0x0E09, 0x0A09, 0xC401, 0xC401, 0xC501),
+  },
+  {	.channel		= 160,
+	.freq			= 5800, /* MHz */
+	.unk2			= 3867,
+	RADIOREGS(0x71, 0x02, 0x44, 0x01, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x1409, 0x1009, 0x0C09, 0xC301, 0xC401, 0xC501),
+  },
+  {	.channel		= 161,
+	.freq			= 5805, /* MHz */
+	.unk2			= 3870,
+	RADIOREGS(0x72, 0x04, 0x89, 0x01, 0xED, 0x00, 0x03, 0x14,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x1609, 0x1209, 0x0E09, 0xC301, 0xC401, 0xC401),
+  },
+  {	.channel		= 162,
+	.freq			= 5810, /* MHz */
+	.unk2			= 3873,
+	RADIOREGS(0x71, 0x02, 0x45, 0x01, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x1809, 0x1409, 0x1009, 0xC201, 0xC301, 0xC401),
+  },
+  {	.channel		= 163,
+	.freq			= 5815, /* MHz */
+	.unk2			= 3877,
+	RADIOREGS(0x72, 0x04, 0x8B, 0x01, 0xED, 0x00, 0x03, 0x14,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x1A09, 0x1609, 0x1209, 0xC201, 0xC301, 0xC401),
+  },
+  {	.channel		= 164,
+	.freq			= 5820, /* MHz */
+	.unk2			= 3880,
+	RADIOREGS(0x71, 0x02, 0x46, 0x01, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x1C09, 0x1809, 0x1409, 0xC201, 0xC201, 0xC301),
+  },
+  {	.channel		= 165,
+	.freq			= 5825, /* MHz */
+	.unk2			= 3883,
+	RADIOREGS(0x72, 0x04, 0x8D, 0x01, 0xED, 0x00, 0x03, 0x14,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x1E09, 0x1A09, 0x1609, 0xC101, 0xC201, 0xC301),
+  },
+  {	.channel		= 166,
+	.freq			= 5830, /* MHz */
+	.unk2			= 3887,
+	RADIOREGS(0x71, 0x02, 0x47, 0x01, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x2009, 0x1C09, 0x1809, 0xC101, 0xC201, 0xC201),
+  },
+  {	.channel		= 168,
+	.freq			= 5840, /* MHz */
+	.unk2			= 3893,
+	RADIOREGS(0x71, 0x02, 0x48, 0x01, 0x0A, 0x01, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x2409, 0x2009, 0x1C09, 0xC001, 0xC101, 0xC201),
+  },
+  {	.channel		= 170,
+	.freq			= 5850, /* MHz */
+	.unk2			= 3900,
+	RADIOREGS(0x71, 0x02, 0x49, 0x01, 0xE0, 0x00, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x2809, 0x2409, 0x2009, 0xBF01, 0xC001, 0xC101),
+  },
+  {	.channel		= 172,
+	.freq			= 5860, /* MHz */
+	.unk2			= 3907,
+	RADIOREGS(0x71, 0x02, 0x4A, 0x01, 0xDE, 0x00, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x2C09, 0x2809, 0x2409, 0xBF01, 0xBF01, 0xC001),
+  },
+  {	.channel		= 174,
+	.freq			= 5870, /* MHz */
+	.unk2			= 3913,
+	RADIOREGS(0x71, 0x02, 0x4B, 0x00, 0xDB, 0x00, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x3009, 0x2C09, 0x2809, 0xBE01, 0xBF01, 0xBF01),
+  },
+  {	.channel		= 176,
+	.freq			= 5880, /* MHz */
+	.unk2			= 3920,
+	RADIOREGS(0x71, 0x02, 0x4C, 0x00, 0xD8, 0x00, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x3409, 0x3009, 0x2C09, 0xBD01, 0xBE01, 0xBF01),
+  },
+  {	.channel		= 178,
+	.freq			= 5890, /* MHz */
+	.unk2			= 3927,
+	RADIOREGS(0x71, 0x02, 0x4D, 0x00, 0xD6, 0x00, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x3809, 0x3409, 0x3009, 0xBC01, 0xBD01, 0xBE01),
+  },
+  {	.channel		= 180,
+	.freq			= 5900, /* MHz */
+	.unk2			= 3933,
+	RADIOREGS(0x71, 0x02, 0x4E, 0x00, 0xD3, 0x00, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x3C09, 0x3809, 0x3409, 0xBC01, 0xBC01, 0xBD01),
+  },
+  {	.channel		= 182,
+	.freq			= 5910, /* MHz */
+	.unk2			= 3940,
+	RADIOREGS(0x71, 0x02, 0x4F, 0x00, 0xD6, 0x00, 0x04, 0x0A,
+		  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x80, 0x00, 0x00, 0x00, 0x00, 0x80),
+	PHYREGS(0x4009, 0x3C09, 0x3809, 0xBB01, 0xBC01, 0xBC01),
+  },
+  {	.channel		= 1,
+	.freq			= 2412, /* MHz */
+	.unk2			= 3216,
+	RADIOREGS(0x73, 0x09, 0x6C, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0D, 0x0C,
+		  0x80, 0xFF, 0x88, 0x0D, 0x0C, 0x80),
+	PHYREGS(0xC903, 0xC503, 0xC103, 0x3A04, 0x3F04, 0x4304),
+  },
+  {	.channel		= 2,
+	.freq			= 2417, /* MHz */
+	.unk2			= 3223,
+	RADIOREGS(0x73, 0x09, 0x71, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0C, 0x0B,
+		  0x80, 0xFF, 0x88, 0x0C, 0x0B, 0x80),
+	PHYREGS(0xCB03, 0xC703, 0xC303, 0x3804, 0x3D04, 0x4104),
+  },
+  {	.channel		= 3,
+	.freq			= 2422, /* MHz */
+	.unk2			= 3229,
+	RADIOREGS(0x73, 0x09, 0x76, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0C, 0x0A,
+		  0x80, 0xFF, 0x88, 0x0C, 0x0A, 0x80),
+	PHYREGS(0xCD03, 0xC903, 0xC503, 0x3604, 0x3A04, 0x3F04),
+  },
+  {	.channel		= 4,
+	.freq			= 2427, /* MHz */
+	.unk2			= 3236,
+	RADIOREGS(0x73, 0x09, 0x7B, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0C, 0x0A,
+		  0x80, 0xFF, 0x88, 0x0C, 0x0A, 0x80),
+	PHYREGS(0xCF03, 0xCB03, 0xC703, 0x3404, 0x3804, 0x3D04),
+  },
+  {	.channel		= 5,
+	.freq			= 2432, /* MHz */
+	.unk2			= 3243,
+	RADIOREGS(0x73, 0x09, 0x80, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0C, 0x09,
+		  0x80, 0xFF, 0x88, 0x0C, 0x09, 0x80),
+	PHYREGS(0xD103, 0xCD03, 0xC903, 0x3104, 0x3604, 0x3A04),
+  },
+  {	.channel		= 6,
+	.freq			= 2437, /* MHz */
+	.unk2			= 3249,
+	RADIOREGS(0x73, 0x09, 0x85, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0B, 0x08,
+		  0x80, 0xFF, 0x88, 0x0B, 0x08, 0x80),
+	PHYREGS(0xD303, 0xCF03, 0xCB03, 0x2F04, 0x3404, 0x3804),
+  },
+  {	.channel		= 7,
+	.freq			= 2442, /* MHz */
+	.unk2			= 3256,
+	RADIOREGS(0x73, 0x09, 0x8A, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0A, 0x07,
+		  0x80, 0xFF, 0x88, 0x0A, 0x07, 0x80),
+	PHYREGS(0xD503, 0xD103, 0xCD03, 0x2D04, 0x3104, 0x3604),
+  },
+  {	.channel		= 8,
+	.freq			= 2447, /* MHz */
+	.unk2			= 3263,
+	RADIOREGS(0x73, 0x09, 0x8F, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0A, 0x06,
+		  0x80, 0xFF, 0x88, 0x0A, 0x06, 0x80),
+	PHYREGS(0xD703, 0xD303, 0xCF03, 0x2B04, 0x2F04, 0x3404),
+  },
+  {	.channel		= 9,
+	.freq			= 2452, /* MHz */
+	.unk2			= 3269,
+	RADIOREGS(0x73, 0x09, 0x94, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x09, 0x06,
+		  0x80, 0xFF, 0x88, 0x09, 0x06, 0x80),
+	PHYREGS(0xD903, 0xD503, 0xD103, 0x2904, 0x2D04, 0x3104),
+  },
+  {	.channel		= 10,
+	.freq			= 2457, /* MHz */
+	.unk2			= 3276,
+	RADIOREGS(0x73, 0x09, 0x99, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x08, 0x05,
+		  0x80, 0xFF, 0x88, 0x08, 0x05, 0x80),
+	PHYREGS(0xDB03, 0xD703, 0xD303, 0x2704, 0x2B04, 0x2F04),
+  },
+  {	.channel		= 11,
+	.freq			= 2462, /* MHz */
+	.unk2			= 3283,
+	RADIOREGS(0x73, 0x09, 0x9E, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x08, 0x04,
+		  0x80, 0xFF, 0x88, 0x08, 0x04, 0x80),
+	PHYREGS(0xDD03, 0xD903, 0xD503, 0x2404, 0x2904, 0x2D04),
+  },
+  {	.channel		= 12,
+	.freq			= 2467, /* MHz */
+	.unk2			= 3289,
+	RADIOREGS(0x73, 0x09, 0xA3, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x08, 0x03,
+		  0x80, 0xFF, 0x88, 0x08, 0x03, 0x80),
+	PHYREGS(0xDF03, 0xDB03, 0xD703, 0x2204, 0x2704, 0x2B04),
+  },
+  {	.channel		= 13,
+	.freq			= 2472, /* MHz */
+	.unk2			= 3296,
+	RADIOREGS(0x73, 0x09, 0xA8, 0x0F, 0x00, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x07, 0x03,
+		  0x80, 0xFF, 0x88, 0x07, 0x03, 0x80),
+	PHYREGS(0xE103, 0xDD03, 0xD903, 0x2004, 0x2404, 0x2904),
+  },
+  {	.channel		= 14,
+	.freq			= 2484, /* MHz */
+	.unk2			= 3312,
+	RADIOREGS(0x73, 0x09, 0xB4, 0x0F, 0xFF, 0x01, 0x07, 0x15,
+		  0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x07, 0x01,
+		  0x80, 0xFF, 0x88, 0x07, 0x01, 0x80),
+	PHYREGS(0xE603, 0xE203, 0xDE03, 0x1B04, 0x1F04, 0x2404),
+  },
+};
+
+const struct b43_nphy_channeltab_entry *
+b43_nphy_get_chantabent(struct b43_wldev *dev, u8 channel)
+{
+	const struct b43_nphy_channeltab_entry *e;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(b43_nphy_channeltab); i++) {
+		e = &(b43_nphy_channeltab[i]);
+		if (e->channel == channel)
+			return e;
+	}
+
+	return NULL;
+}
Index: wireless-2.6/drivers/net/wireless/b43/tables_nphy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/tables_nphy.h	2008-01-13 23:18:48.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/tables_nphy.h	2008-01-13 23:18:48.000000000 +0100
@@ -1,17 +1,63 @@
 #ifndef B43_TABLES_NPHY_H_
 #define B43_TABLES_NPHY_H_
 
 #include <linux/types.h>
 
 
+struct b43_nphy_channeltab_entry {
+	/* The channel number */
+	u8 channel;
+	/* Radio register values on channelswitch */
+	u8 radio_pll_ref;
+	u8 radio_rf_pllmod0;
+	u8 radio_rf_pllmod1;
+	u8 radio_vco_captail;
+	u8 radio_vco_cal1;
+	u8 radio_vco_cal2;
+	u8 radio_pll_lfc1;
+	u8 radio_pll_lfr1;
+	u8 radio_pll_lfc2;
+	u8 radio_lgbuf_cenbuf;
+	u8 radio_lgen_tune1;
+	u8 radio_lgen_tune2;
+	u8 radio_c1_lgbuf_atune;
+	u8 radio_c1_lgbuf_gtune;
+	u8 radio_c1_rx_rfr1;
+	u8 radio_c1_tx_pgapadtn;
+	u8 radio_c1_tx_mxbgtrim;
+	u8 radio_c2_lgbuf_atune;
+	u8 radio_c2_lgbuf_gtune;
+	u8 radio_c2_rx_rfr1;
+	u8 radio_c2_tx_pgapadtn;
+	u8 radio_c2_tx_mxbgtrim;
+	/* PHY register values on channelswitch */
+	u16 phy_bw1a;
+	u16 phy_bw2;
+	u16 phy_bw3;
+	u16 phy_bw4;
+	u16 phy_bw5;
+	u16 phy_bw6;
+	/* The channel frequency in MHz */
+	u16 freq;
+	/* An unknown value */
+	u16 unk2;
+};
+
+
 struct b43_wldev;
 
 /* Upload the default register value table.
  * If "ghz5" is true, we upload the 5Ghz table. Otherwise the 2.4Ghz
  * table is uploaded. If "ignore_uploadflag" is true, we upload any value
  * and ignore the "UPLOAD" flag. */
 void b2055_upload_inittab(struct b43_wldev *dev,
 			  bool ghz5, bool ignore_uploadflag);
 
 
+/* Get the NPHY Channel Switch Table entry for a channel number.
+ * Returns NULL on failure to find an entry. */
+const struct b43_nphy_channeltab_entry *
+b43_nphy_get_chantabent(struct b43_wldev *dev, u8 channel);
+
+
 #endif /* B43_TABLES_NPHY_H_ */
Index: wireless-2.6/drivers/net/wireless/b43/nphy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/nphy.c	2008-01-13 23:18:48.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/nphy.c	2008-01-13 23:57:10.000000000 +0100
@@ -32,18 +32,84 @@ void b43_nphy_set_rxantenna(struct b43_w
 }
 
 void b43_nphy_xmitpower(struct b43_wldev *dev)
 {//TODO
 }
 
+static void b43_chantab_radio_upload(struct b43_wldev *dev,
+				     const struct b43_nphy_channeltab_entry *e)
+{
+	b43_radio_write16(dev, B2055_PLL_REF, e->radio_pll_ref);
+	b43_radio_write16(dev, B2055_RF_PLLMOD0, e->radio_rf_pllmod0);
+	b43_radio_write16(dev, B2055_RF_PLLMOD1, e->radio_rf_pllmod1);
+	b43_radio_write16(dev, B2055_VCO_CAPTAIL, e->radio_vco_captail);
+	b43_radio_write16(dev, B2055_VCO_CAL1, e->radio_vco_cal1);
+	b43_radio_write16(dev, B2055_VCO_CAL2, e->radio_vco_cal2);
+	b43_radio_write16(dev, B2055_PLL_LFC1, e->radio_pll_lfc1);
+	b43_radio_write16(dev, B2055_PLL_LFR1, e->radio_pll_lfr1);
+	b43_radio_write16(dev, B2055_PLL_LFC2, e->radio_pll_lfc2);
+	b43_radio_write16(dev, B2055_LGBUF_CENBUF, e->radio_lgbuf_cenbuf);
+	b43_radio_write16(dev, B2055_LGEN_TUNE1, e->radio_lgen_tune1);
+	b43_radio_write16(dev, B2055_LGEN_TUNE2, e->radio_lgen_tune2);
+	b43_radio_write16(dev, B2055_C1_LGBUF_ATUNE, e->radio_c1_lgbuf_atune);
+	b43_radio_write16(dev, B2055_C1_LGBUF_GTUNE, e->radio_c1_lgbuf_gtune);
+	b43_radio_write16(dev, B2055_C1_RX_RFR1, e->radio_c1_rx_rfr1);
+	b43_radio_write16(dev, B2055_C1_TX_PGAPADTN, e->radio_c1_tx_pgapadtn);
+	b43_radio_write16(dev, B2055_C1_TX_MXBGTRIM, e->radio_c1_tx_mxbgtrim);
+	b43_radio_write16(dev, B2055_C2_LGBUF_ATUNE, e->radio_c2_lgbuf_atune);
+	b43_radio_write16(dev, B2055_C2_LGBUF_GTUNE, e->radio_c2_lgbuf_gtune);
+	b43_radio_write16(dev, B2055_C2_RX_RFR1, e->radio_c2_rx_rfr1);
+	b43_radio_write16(dev, B2055_C2_TX_PGAPADTN, e->radio_c2_tx_pgapadtn);
+	b43_radio_write16(dev, B2055_C2_TX_MXBGTRIM, e->radio_c2_tx_mxbgtrim);
+}
+
+static void b43_chantab_phy_upload(struct b43_wldev *dev,
+				   const struct b43_nphy_channeltab_entry *e)
+{
+	b43_phy_write(dev, B43_NPHY_BW1A, e->phy_bw1a);
+	b43_phy_write(dev, B43_NPHY_BW2, e->phy_bw2);
+	b43_phy_write(dev, B43_NPHY_BW3, e->phy_bw3);
+	b43_phy_write(dev, B43_NPHY_BW4, e->phy_bw4);
+	b43_phy_write(dev, B43_NPHY_BW5, e->phy_bw5);
+	b43_phy_write(dev, B43_NPHY_BW6, e->phy_bw6);
+}
+
+static void b43_nphy_tx_power_fix(struct b43_wldev *dev)
+{
+	//TODO
+}
+
 /* Tune the hardware to a new channel. Don't call this directly.
  * Use b43_radio_selectchannel() */
-void b43_nphy_selectchannel(struct b43_wldev *dev, u8 channel)
+int b43_nphy_selectchannel(struct b43_wldev *dev, u8 channel)
 {
+	const struct b43_nphy_channeltab_entry *tabent;
 
-//TODO
+	tabent = b43_nphy_get_chantabent(dev, channel);
+	if (!tabent)
+		return -ESRCH;
+
+	//FIXME enable/disable band select upper20 in RXCTL
+	if (0 /*FIXME 5Ghz*/)
+		b43_radio_maskset(dev, B2055_MASTER1, 0xFF8F, 0x20);
+	else
+		b43_radio_maskset(dev, B2055_MASTER1, 0xFF8F, 0x50);
+	b43_chantab_radio_upload(dev, tabent);
+	udelay(50);
+	b43_radio_write16(dev, B2055_VCO_CAL10, 5);
+	b43_radio_write16(dev, B2055_VCO_CAL10, 45);
+	b43_radio_write16(dev, B2055_VCO_CAL10, 65);
+	udelay(300);
+	if (0 /*FIXME 5Ghz*/)
+		b43_phy_set(dev, B43_NPHY_BANDCTL, B43_NPHY_BANDCTL_5GHZ);
+	else
+		b43_phy_mask(dev, B43_NPHY_BANDCTL, ~B43_NPHY_BANDCTL_5GHZ);
+	b43_chantab_phy_upload(dev, tabent);
+	b43_nphy_tx_power_fix(dev);
+
+	return 0;
 }
 
 static void b43_radio_init2055_pre(struct b43_wldev *dev)
 {
 	b43_phy_mask(dev, B43_NPHY_RFCTL_CMD,
 		     ~B43_NPHY_RFCTL_CMD_PORFORCE);
Index: wireless-2.6/drivers/net/wireless/b43/nphy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/nphy.h	2008-01-13 23:18:48.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/nphy.h	2008-01-13 23:46:52.000000000 +0100
@@ -9,12 +9,13 @@
 #define B43_NPHY_BBCFG				B43_PHY_N(0x001) /* BB config */
 #define  B43_NPHY_BBCFG_RSTCCA			0x4000 /* Reset CCA */
 #define  B43_NPHY_BBCFG_RSTRX			0x8000 /* Reset RX */
 #define B43_NPHY_CHANNEL			B43_PHY_N(0x005) /* Channel */
 #define B43_NPHY_TXERR				B43_PHY_N(0x007) /* TX error */
 #define B43_NPHY_BANDCTL			B43_PHY_N(0x009) /* Band control */
+#define  B43_NPHY_BANDCTL_5GHZ			0x0001 /* Use the 5GHz band */
 #define B43_NPHY_4WI_ADDR			B43_PHY_N(0x00B) /* Four-wire bus address */
 #define B43_NPHY_4WI_DATAHI			B43_PHY_N(0x00C) /* Four-wire bus data high */
 #define B43_NPHY_4WI_DATALO			B43_PHY_N(0x00D) /* Four-wire bus data low */
 #define B43_NPHY_BIST_STAT0			B43_PHY_N(0x00E) /* Built-in self test status 0 */
 #define B43_NPHY_BIST_STAT1			B43_PHY_N(0x00F) /* Built-in self test status 1 */
 
@@ -914,12 +915,12 @@ struct b43_wldev;
 
 int b43_phy_initn(struct b43_wldev *dev);
 
 void b43_nphy_radio_turn_on(struct b43_wldev *dev);
 void b43_nphy_radio_turn_off(struct b43_wldev *dev);
 
-void b43_nphy_selectchannel(struct b43_wldev *dev, u8 channel);
+int b43_nphy_selectchannel(struct b43_wldev *dev, u8 channel);
 
 void b43_nphy_xmitpower(struct b43_wldev *dev);
 void b43_nphy_set_rxantenna(struct b43_wldev *dev, int antenna);
 
 #endif /* B43_NPHY_H_ */
Index: wireless-2.6/drivers/net/wireless/b43/phy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/phy.c	2008-01-13 23:18:48.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/phy.c	2008-01-14 00:01:18.000000000 +0100
@@ -3880,13 +3880,14 @@ void b43_radio_set_tx_iq(struct b43_wlde
 int b43_radio_selectchannel(struct b43_wldev *dev,
 			    u8 channel, int synthetic_pu_workaround)
 {
 	struct b43_phy *phy = &dev->phy;
 	u16 r8, tmp;
 	u16 freq;
-	u16 channelcookie;
+	u16 channelcookie, savedcookie;
+	int err = 0;
 
 	if (channel == 0xFF) {
 		switch (phy->type) {
 		case B43_PHYTYPE_A:
 			channel = B43_DEFAULT_CHANNEL_A;
 			break;
@@ -3907,18 +3908,21 @@ int b43_radio_selectchannel(struct b43_w
 	 * firmware from sending ghost packets.
 	 */
 	channelcookie = channel;
 	if (0 /*FIXME on 5Ghz */)
 		channelcookie |= 0x100;
 	//FIXME set 40Mhz flag if required
+	savedcookie = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_CHAN);
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_CHAN, channelcookie);
 
 	switch (phy->type) {
 	case B43_PHYTYPE_A:
-		if (channel > 200)
-			return -EINVAL;
+		if (channel > 200) {
+			err = -EINVAL;
+			goto out;
+		}
 		freq = channel2freq_a(channel);
 
 		r8 = b43_radio_read16(dev, 0x0008);
 		b43_write16(dev, 0x03F0, freq);
 		b43_radio_write16(dev, 0x0008, r8);
 
@@ -3961,14 +3965,16 @@ int b43_radio_selectchannel(struct b43_w
 						& 0xFFEF) | 0x0010);
 		b43_radio_set_tx_iq(dev);
 		//TODO: TSSI2dbm workaround
 		b43_phy_xmitpower(dev);	//FIXME correct?
 		break;
 	case B43_PHYTYPE_G:
-		if ((channel < 1) || (channel > 14))
-			return -EINVAL;
+		if ((channel < 1) || (channel > 14)) {
+			err = -EINVAL;
+			goto out;
+		}
 
 		if (synthetic_pu_workaround)
 			b43_synth_pu_workaround(dev, channel);
 
 		b43_write16(dev, B43_MMIO_CHANNEL, channel2freq_bg(channel));
 
@@ -3987,23 +3993,29 @@ int b43_radio_selectchannel(struct b43_w
 			b43_write16(dev, B43_MMIO_CHANNEL_EXT,
 				    b43_read16(dev, B43_MMIO_CHANNEL_EXT)
 				    & 0xF7BF);
 		}
 		break;
 	case B43_PHYTYPE_N:
-		b43_nphy_selectchannel(dev, channel);
+		err = b43_nphy_selectchannel(dev, channel);
+		if (err)
+			goto out;
 		break;
 	default:
 		B43_WARN_ON(1);
 	}
 
 	phy->channel = channel;
 	/* Wait for the radio to tune to the channel and stabilize. */
 	msleep(8);
-
-	return 0;
+out:
+	if (err) {
+		b43_shm_write16(dev, B43_SHM_SHARED,
+				B43_SHM_SH_CHAN, savedcookie);
+	}
+	return err;
 }
 
 void b43_radio_turn_on(struct b43_wldev *dev)
 {
 	struct b43_phy *phy = &dev->phy;
 	int err;


From proski at gnu.org  Tue Jan 15 19:27:42 2008
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 15 Jan 2008 13:27:42 -0500
Subject: [PATCH] b43: Add support for new firmware
In-Reply-To: <200801131420.52995.mb@bu3sch.de>
References: <200801131420.52995.mb@bu3sch.de>
Message-ID: <1200421662.17542.32.camel@dv>


On Sun, 2008-01-13 at 14:20 +0100, Michael Buesch wrote:
> This patch adds support for new firmware.
> Old firmware is still supported until July 2008.
> 
> To get new firmware, go to
> ftp://ftp.linksys.com/opensourcecode/wrt150nv11/1.51.3/
> and download the tarball. We don't have a smaller tarball, yet.
> That will be fixed later.

I have finally found some time and hardware to test it, but the tarball
is overwhelming at its 186M.  And the worst thing, the server
disconnected after 30M and appears to be down right now.  P.S. It's up,
ETA is 48 minutes.

There were two files there.  I hope either is fine.  I'm trying to
download WRT150NV11_v1.51.3_ETSI.tgz

Cannot we petition Linksys to put wl_ap.o outside the tarball?  Or maybe
Broadcom could do it?

Even a zip file would be better.  It's possible to cut a part of the zip
file and uncompress it with gzip.

It's really a travesty of open source.  The file is "available", but you
have do download 186M of useless (for me at least) mips compilers and
other stuff.  And I have a relatively good connection.

> You can extract firmware out of the "wl_ap.o" file contained
> in this tarball using latest fwcutter. You must pass the option
> --unsupported to fwcutter.
> Fwcutter-010 with official support for a new firmware image will
> be released soon.

Do you know that the Subversion repository of fwcutter has no files at
all?  I mean svn://svn.berlios.de/bcm43xx/trunk

Yes, I will try --unsupported, with version 009.

-- 
Regards,
Pavel Roskin


From stefano.brivio at polimi.it  Tue Jan 15 20:15:38 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 15 Jan 2008 20:15:38 +0100
Subject: [PATCH] b43: Add support for new firmware
In-Reply-To: <1200421662.17542.32.camel@dv>
References: <200801131420.52995.mb@bu3sch.de>
	<1200421662.17542.32.camel@dv>
Message-ID: <20080115201538.5e4347f9@morte>

On Tue, 15 Jan 2008 13:27:42 -0500
Pavel Roskin <proski at gnu.org> wrote:

> I have finally found some time and hardware to test it, but the tarball
> is overwhelming at its 186M.  And the worst thing, the server
> disconnected after 30M and appears to be down right now.  P.S. It's up,
> ETA is 48 minutes.
> 
> There were two files there.  I hope either is fine.  I'm trying to
> download WRT150NV11_v1.51.3_ETSI.tgz
> 
> Cannot we petition Linksys to put wl_ap.o outside the tarball?  Or maybe
> Broadcom could do it?

Good luck. ;) The only long-term lasting solution I see is to put more
effort on an open firmware. The instruction set has been figured out, we
just lack people and time there.

> Do you know that the Subversion repository of fwcutter has no files at
> all?  I mean svn://svn.berlios.de/bcm43xx/trunk
> 
> Yes, I will try --unsupported, with version 009.

fwcutter development now happens here:
http://bu3sch.de/gitweb?p=b43-tools.git;a=summary

Maybe we should add this along with git URLs on linuxwireless.org.


--
Ciao
Stefano


From mb at bu3sch.de  Tue Jan 15 23:21:40 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 15 Jan 2008 23:21:40 +0100
Subject: [PATCH] b43: Add support for new firmware
In-Reply-To: <20080115201538.5e4347f9@morte>
References: <200801131420.52995.mb@bu3sch.de> <1200421662.17542.32.camel@dv>
	<20080115201538.5e4347f9@morte>
Message-ID: <200801152321.41073.mb@bu3sch.de>

On Tuesday 15 January 2008 20:15:38 Stefano Brivio wrote:
> On Tue, 15 Jan 2008 13:27:42 -0500
> Pavel Roskin <proski at gnu.org> wrote:
> 
> > I have finally found some time and hardware to test it, but the tarball
> > is overwhelming at its 186M.  And the worst thing, the server
> > disconnected after 30M and appears to be down right now.  P.S. It's up,
> > ETA is 48 minutes.
> > 
> > There were two files there.  I hope either is fine.  I'm trying to
> > download WRT150NV11_v1.51.3_ETSI.tgz
> > 
> > Cannot we petition Linksys to put wl_ap.o outside the tarball?  Or maybe
> > Broadcom could do it?
> 
> Good luck. ;) The only long-term lasting solution I see is to put more
> effort on an open firmware. The instruction set has been figured out, we
> just lack people and time there.

We already have a better file on an openwrt server that will be the
officially supported one soon.
I just have to create a new fwcutter tarball and link from linuxwireless.org
to it. I already added support for the file to fwcutter git.
See Stefano's comment below.

> > Do you know that the Subversion repository of fwcutter has no files at
> > all?  I mean svn://svn.berlios.de/bcm43xx/trunk
> > 
> > Yes, I will try --unsupported, with version 009.
> 
> fwcutter development now happens here:
> http://bu3sch.de/gitweb?p=b43-tools.git;a=summary

Yep, the berlios stuff is dropped completely, except the download
section for the fwcutter tarballs. But that may also change in future.
We will announce that on linuxwireless.org.

> Maybe we should add this along with git URLs on linuxwireless.org.

Please do it, if you feel so.

-- 
Greetings Michael.


From mb at bu3sch.de  Tue Jan 15 23:57:56 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 15 Jan 2008 23:57:56 +0100
Subject: [PATCH] b43: Add support for new firmware
In-Reply-To: <200801152321.41073.mb@bu3sch.de>
References: <200801131420.52995.mb@bu3sch.de> <20080115201538.5e4347f9@morte>
	<200801152321.41073.mb@bu3sch.de>
Message-ID: <200801152357.56730.mb@bu3sch.de>

On Tuesday 15 January 2008 23:21:40 Michael Buesch wrote:
> Yep, the berlios stuff is dropped completely, except the download
> section for the fwcutter tarballs. But that may also change in future.
> We will announce that on linuxwireless.org.

Actually, I think I will change that _now_.
I'll simply put the stuff on my server. berlios is just too annoying.
I'll put the new URLs on the b43 linuxwireless.org page.

-- 
Greetings Michael.


From gmccullagh at gmail.com  Wed Jan 16 02:08:18 2008
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Wed, 16 Jan 2008 01:08:18 +0000
Subject: issues with bcm4306
Message-ID: <20080116010817.GA18042@gmail.com>

Hi,

I'm the proud owner of the following Belkin f5d7011 cardbus card:

02:00.0 Network controller [0280]: Broadcom Corporation BCM4306 802.11b/g Wireless LAN Controller [14e4:4320] (rev 03)
        Subsystem: Belkin F5D7011 54g+ Wireless Network card [1799:7011]
        Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
        Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
        Latency: 64
        Interrupt: pin A routed to IRQ 10
        Region 0: Memory at 24000000 (32-bit, non-prefetchable) [size=8K]

which broadly speaking, works reasonably well.  I just updated to the
latest wireless-2.6 kernel and have a couple of issues to report.

1. Lights stay off on the card, even when it's working and associated.

2. There seems to be some timing issue with a Netgear WGR614 access point
   (but no others I've tried).  If I login with gnome, the network-manager
   tries to connect automatically to the AP as it knows it from previous
   sessions.  This fails unless I have first removed the memory of this
   ESSID from gconf.   
	rm -r .gconf/system/networking/wireless/networks/<ESSID>/
   I can then login, select the ESSID from the list, type in the passphrase
   (it's WPA) and it connects fine.

Attached is a dmesg from the current running system.  I booted, logged in,
got the failure as in [2] above, logged out, reloaded the b43 module,
removed the gconf info, then logged in and successfully joined up to the
access point.

I think both of the above have been mentioned on this list before, but I
thought I should report them.  If someone would like me to debug this
further, I am open to instructions.

I also own a bcm4318 Airforce One card which is slightly less stable
(though its lights do work!) so I might send a separate email regarding
that.  

Thanks for all the code and please let me know if I can be of help giving
up debug info for these cards.

Gavin

-------------- next part --------------
[    0.000000] Linux version 2.6.24-rc7 (gavinmc at tilly) (gcc version 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2)) #2 SMP Tue Jan 15 22:30:02 GMT 2008
[    0.000000] BIOS-provided physical RAM map:
[    0.000000]  BIOS-e820: 0000000000000000 - 000000000009f800 (usable)
[    0.000000]  BIOS-e820: 000000000009f800 - 00000000000a0000 (reserved)
[    0.000000]  BIOS-e820: 00000000000ea000 - 0000000000100000 (reserved)
[    0.000000]  BIOS-e820: 0000000000100000 - 000000000fff0000 (usable)
[    0.000000]  BIOS-e820: 000000000fff0000 - 000000000ffffc00 (ACPI data)
[    0.000000]  BIOS-e820: 000000000ffffc00 - 0000000010000000 (ACPI NVS)
[    0.000000]  BIOS-e820: 00000000fffea000 - 0000000100000000 (reserved)
[    0.000000] 0MB HIGHMEM available.
[    0.000000] 255MB LOWMEM available.
[    0.000000] Entering add_active_range(0, 0, 65520) 0 entries of 256 used
[    0.000000] Zone PFN ranges:
[    0.000000]   DMA             0 ->     4096
[    0.000000]   Normal       4096 ->    65520
[    0.000000]   HighMem     65520 ->    65520
[    0.000000] Movable zone start PFN for each node
[    0.000000] early_node_map[1] active PFN ranges
[    0.000000]     0:        0 ->    65520
[    0.000000] On node 0 totalpages: 65520
[    0.000000]   DMA zone: 32 pages used for memmap
[    0.000000]   DMA zone: 0 pages reserved
[    0.000000]   DMA zone: 4064 pages, LIFO batch:0
[    0.000000]   Normal zone: 479 pages used for memmap
[    0.000000]   Normal zone: 60945 pages, LIFO batch:15
[    0.000000]   HighMem zone: 0 pages used for memmap
[    0.000000]   Movable zone: 0 pages used for memmap
[    0.000000] DMI 2.3 present.
[    0.000000] Allocating PCI resources starting at 20000000 (gap: 10000000:effea000)
[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 65009
[    0.000000] Kernel command line: root=UUID=04b1cbd4-13a4-4a1e-8614-b6198ca3d7fb ro quiet splash acpi=off
[    0.000000] Local APIC disabled by BIOS -- you can enable it with "lapic"
[    0.000000] mapped APIC to ffffb000 (0120b000)
[    0.000000] Enabling fast FPU save and restore... done.
[    0.000000] Enabling unmasked SIMD FPU exception support... done.
[    0.000000] Initializing CPU#0
[    0.000000] PID hash table entries: 1024 (order: 10, 4096 bytes)
[    0.000000] Detected 696.990 MHz processor.
[   14.940697] Console: colour VGA+ 80x25
[   14.940709] console [tty0] enabled
[   14.941231] Dentry cache hash table entries: 32768 (order: 5, 131072 bytes)
[   14.941760] Inode-cache hash table entries: 16384 (order: 4, 65536 bytes)
[   14.968886] Memory: 214144k/262080k available (2025k kernel code, 47360k reserved, 937k data, 340k init, 0k highmem)
[   14.968911] virtual kernel memory layout:
[   14.968915]     fixmap  : 0xfff4c000 - 0xfffff000   ( 716 kB)
[   14.968919]     pkmap   : 0xff800000 - 0xffc00000   (4096 kB)
[   14.968923]     vmalloc : 0xd0800000 - 0xff7fe000   ( 751 MB)
[   14.968926]     lowmem  : 0xc0000000 - 0xcfff0000   ( 255 MB)
[   14.968930]       .init : 0xc03eb000 - 0xc0440000   ( 340 kB)
[   14.968934]       .data : 0xc02fa653 - 0xc03e4d44   ( 937 kB)
[   14.968938]       .text : 0xc0100000 - 0xc02fa653   (2025 kB)
[   14.968948] Checking if this processor honours the WP bit even in supervisor mode... Ok.
[   14.969039] SLUB: Genslabs=11, HWalign=32, Order=0-1, MinObjects=4, CPUs=1, Nodes=1
[   15.049064] Calibrating delay using timer specific routine.. 1395.19 BogoMIPS (lpj=2790389)
[   15.049136] Security Framework initialized
[   15.049157] SELinux:  Disabled at boot.
[   15.049193] Mount-cache hash table entries: 512
[   15.049488] CPU: After generic identify, caps: 0383f9ff 00000000 00000000 00000000 00000000 00000000 00000000 00000000
[   15.049518] CPU: L1 I cache: 16K, L1 D cache: 16K
[   15.049526] CPU: L2 cache: 256K
[   15.049534] CPU: After all inits, caps: 0383f9ff 00000000 00000000 00000040 00000000 00000000 00000000 00000000
[   15.049561] Compat vDSO mapped to ffffe000.
[   15.049595] Checking 'hlt' instruction... OK.
[   15.065671] SMP alternatives: switching to UP code
[   15.066802] Freeing SMP alternatives: 11k freed
[   15.066922] CPU0: Intel Pentium III (Coppermine) stepping 0a
[   15.066937] SMP motherboard not detected.
[   15.066944] Local APIC not detected. Using dummy APIC emulation.
[   15.067074] Brought up 1 CPUs
[   15.067118] CPU0 attaching sched-domain:
[   15.067126]  domain 0: span 01
[   15.067132]   groups: 01
[   15.067691] net_namespace: 64 bytes
[   15.069406] Time:  0:47:33  Date: 01/16/08
[   15.069491] NET: Registered protocol family 16
[   15.070109] EISA bus registered
[   15.073137] PCI: PCI BIOS revision 2.10 entry at 0xfd9c5, last bus=1
[   15.073146] PCI: Using configuration type 1
[   15.073152] Setting up standard PCI resources
[   15.083283] ACPI: Interpreter disabled.
[   15.083295] Linux Plug and Play Support v0.97 (c) Adam Belay
[   15.083388] pnp: PnP ACPI: disabled
[   15.083399] PnPBIOS: Scanning system for PnP BIOS support...
[   15.083468] PnPBIOS: Found PnP BIOS installation structure at 0xc00f7000
[   15.083477] PnPBIOS: PnP BIOS version 1.0, entry 0xf0000:0xacd2, dseg 0x400
[   15.086583] PnPBIOS: 14 nodes reported by PnP BIOS; 14 recorded by driver
[   15.087148] PCI: Probing PCI hardware
[   15.087191] PCI: Probing PCI hardware (bus 00)
[   15.087594] PCI quirk: region 8000-803f claimed by PIIX4 ACPI
[   15.087603] PCI quirk: region 2180-218f claimed by PIIX4 SMB
[   15.087615] PIIX4 devres I PIO at 0398-0399
[   15.089598] PCI: Using IRQ router PIIX/ICH [8086/7110] at 0000:00:07.0
[   15.097264] NET: Registered protocol family 8
[   15.097272] NET: Registered protocol family 20
[   15.097523] system 00:00: ioport range 0x4d0-0x4d1 has been reserved
[   15.097533] system 00:00: ioport range 0x8000-0x803f has been reserved
[   15.097541] system 00:00: ioport range 0x2180-0x218f has been reserved
[   15.097551] system 00:00: ioport range 0x398-0x399 has been reserved
[   15.097561] system 00:00: iomem range 0xfffe0000-0xffffffff could not be reserved
[   15.097583] system 00:01: iomem range 0x0-0x9ffff could not be reserved
[   15.097592] system 00:01: iomem range 0xe8000-0xfffff could not be reserved
[   15.097601] system 00:01: iomem range 0x100000-0xfffffff could not be reserved
[   15.097631] system 00:0a: iomem range 0xdc000-0xdffff has been reserved
[   15.097651] system 00:0b: iomem range 0xd0800-0xd3fff has been reserved
[   15.098899] PCI: Bridge: 0000:00:01.0
[   15.098909]   IO window: e000-efff
[   15.098917]   MEM window: fd000000-fecfffff
[   15.098925]   PREFETCH window: 28000000-280fffff
[   15.098934] PCI: Bus 2, cardbus bridge: 0000:00:0a.0
[   15.098940]   IO window: 00001000-000010ff
[   15.098947]   IO window: 00001400-000014ff
[   15.098955]   PREFETCH window: 20000000-23ffffff
[   15.098963]   MEM window: 24000000-27ffffff
[   15.098998] PCI: setting IRQ 10 as level-triggered
[   15.099005] PCI: Found IRQ 10 for device 0000:00:0a.0
[   15.099023] PCI: Sharing IRQ 10 with 0000:00:0d.0
[   15.099030] PCI: Sharing IRQ 10 with 0000:01:00.0
[   15.099063] NET: Registered protocol family 2
[   15.101064] Time: tsc clocksource has been installed.
[   15.133327] IP route cache hash table entries: 2048 (order: 1, 8192 bytes)
[   15.134025] TCP established hash table entries: 8192 (order: 4, 65536 bytes)
[   15.134232] TCP bind hash table entries: 8192 (order: 4, 65536 bytes)
[   15.134447] TCP: Hash tables configured (established 8192 bind 8192)
[   15.134454] TCP reno registered
[   15.145492] checking if image is initramfs... it is
[   25.163316] Freeing initrd memory: 41221k freed
[   25.164711] audit: initializing netlink socket (disabled)
[   25.164753] audit(1200444463.200:1): initialized
[   25.171183] VFS: Disk quotas dquot_6.5.1
[   25.171448] Dquot-cache hash table entries: 1024 (order 0, 4096 bytes)
[   25.172085] io scheduler noop registered
[   25.172094] io scheduler anticipatory registered
[   25.172100] io scheduler deadline registered
[   25.172145] io scheduler cfq registered (default)
[   25.172220] Limiting direct PCI/PCI transfers.
[   25.172268] Boot video device is 0000:01:00.0
[   25.172958] isapnp: Scanning for PnP cards...
[   25.525845] isapnp: No Plug & Play device found
[   25.601555] Real Time Clock Driver v1.12ac
[   25.601780] Serial: 8250/16550 driver $Revision: 1.90 $ 4 ports, IRQ sharing enabled
[   25.605471] RAMDISK driver initialized: 16 RAM disks of 65536K size 1024 blocksize
[   25.605694] input: Macintosh mouse button emulation as /class/input/input0
[   25.606006] PNP: PS/2 Controller [PNP0303,PNP0f13] at 0x60,0x64 irq 1,12
[   25.611804] serio: i8042 KBD port at 0x60,0x64 irq 1
[   25.611819] serio: i8042 AUX port at 0x60,0x64 irq 12
[   25.620315] mice: PS/2 mouse device common for all mice
[   25.620674] EISA: Probing bus 0 at eisa.0
[   25.620691] Cannot allocate resource for EISA slot 1
[   25.620718] Cannot allocate resource for EISA slot 8
[   25.620724] EISA: Detected 0 cards.
[   25.620969] TCP cubic registered
[   25.621169] NET: Registered protocol family 1
[   25.621258] Using IPI No-Shortcut mode
[   25.621540]   Magic number: 8:402:759
[   25.622944] Freeing unused kernel memory: 340k freed
[   25.664158] input: AT Translated Set 2 keyboard as /class/input/input1
[   27.452208] fuse init (API version 7.9)
[   28.183651] thermal: Unknown symbol acpi_processor_set_thermal_limit
[   32.139784] SCSI subsystem initialized
[   32.251727] usbcore: registered new interface driver usbfs
[   32.251805] usbcore: registered new interface driver hub
[   32.302517] usbcore: registered new device driver usb
[   32.322579] PCI: Found IRQ 10 for device 0000:00:0d.0
[   32.322603] PCI: Sharing IRQ 10 with 0000:00:0a.0
[   32.322613] PCI: Sharing IRQ 10 with 0000:01:00.0
[   32.322626] 3c59x: Donald Becker and others.
[   32.322645] 0000:00:0d.0: 3Com PCI 3c905C Tornado at d086cc00.
[   32.497445] USB Universal Host Controller Interface driver v3.0
[   32.497632] PCI: setting IRQ 11 as level-triggered
[   32.497640] PCI: Found IRQ 11 for device 0000:00:07.2
[   32.497683] uhci_hcd 0000:00:07.2: UHCI Host Controller
[   32.498095] uhci_hcd 0000:00:07.2: new USB bus registered, assigned bus number 1
[   32.498145] uhci_hcd 0000:00:07.2: irq 11, io base 0x0000fce0
[   32.498549] usb usb1: configuration #1 chosen from 1 choice
[   32.498624] hub 1-0:1.0: USB hub found
[   32.498643] hub 1-0:1.0: 2 ports detected
[   32.527544] libata version 3.00 loaded.
[   32.540626] Floppy drive(s): fd0 is 1.44M
[   32.559034] FDC 0 is a National Semiconductor PC87306
[   32.600063] hub 1-0:1.0: over-current change on port 2
[   32.618349] ata_piix 0000:00:07.1: version 2.12
[   32.620368] scsi0 : ata_piix
[   32.622764] scsi1 : ata_piix
[   32.622908] ata1: PATA max UDMA/33 cmd 0x1f0 ctl 0x3f6 bmdma 0xfcd0 irq 14
[   32.622917] ata2: PATA max UDMA/33 cmd 0x170 ctl 0x376 bmdma 0xfcd8 irq 15
[   32.784003] ata1.00: ATA-6: IC25N030ATMR04-0, MOAOAD0A, max UDMA/100
[   32.784017] ata1.00: 58605120 sectors, multi 16: LBA48 
[   32.799924] ata1.00: configured for UDMA/33
[   32.955881] scsi 0:0:0:0: Direct-Access     ATA      IC25N030ATMR04-0 MOAO PQ: 0 ANSI: 5
[   32.981133] Driver 'sd' needs updating - please use bus_type methods
[   32.982910] sd 0:0:0:0: [sda] 58605120 512-byte hardware sectors (30006 MB)
[   32.982957] sd 0:0:0:0: [sda] Write Protect is off
[   32.982966] sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
[   32.983026] sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
[   32.983193] sd 0:0:0:0: [sda] 58605120 512-byte hardware sectors (30006 MB)
[   32.983227] sd 0:0:0:0: [sda] Write Protect is off
[   32.983235] sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
[   32.983293] sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
[   32.983307]  sda: sda1 sda2 sda3
[   33.391762] sd 0:0:0:0: [sda] Attached SCSI disk
[   33.413433] sd 0:0:0:0: Attached scsi generic sg0 type 0
[   33.894365] kjournald starting.  Commit interval 5 seconds
[   33.894406] EXT3-fs: mounted filesystem with ordered data mode.
[   54.001690] Linux agpgart interface v0.102
[   54.269784] pci_hotplug: PCI Hot Plug PCI Core version: 0.5
[   54.408283] shpchp: Standard Hot Plug PCI Controller Driver version: 0.4
[   54.934820] Yenta: CardBus bridge found at 0000:00:0a.0 [1028:00dc]
[   54.934851] Yenta: Enabling burst memory read transactions
[   54.934861] Yenta: Using CSCINT to route CSC interrupts to PCI
[   54.934867] Yenta: Routing CardBus interrupts to PCI
[   54.934876] Yenta TI: socket 0000:00:0a.0, mfunc 0x012c1272, devctl 0x64
[   55.166098] Yenta: ISA IRQ mask 0x02b8, PCI irq 10
[   55.166111] Socket status: 30000020
[   55.183037] agpgart: Detected an Intel 440BX Chipset.
[   55.188873] agpgart: AGP aperture is 64M @ 0xf8000000
[   55.221763] input: PC Speaker as /class/input/input2
[   55.273663] piix4_smbus 0000:00:07.3: Found 0000:00:07.3 device
[   55.821447] pccard: CardBus card inserted into slot 0
[   56.028509] Synaptics Touchpad, model: 1, fw: 4.1, id: 0x8848a1, caps: 0x0/0x0
[   56.064743] input: SynPS/2 Synaptics TouchPad as /class/input/input3
[   56.231111] cs: IO port probe 0x100-0x3af: excluding 0x378-0x37f
[   56.231931] cs: IO port probe 0x3e0-0x4ff: clean.
[   56.232313] cs: IO port probe 0x820-0x8ff: clean.
[   56.232642] cs: IO port probe 0xc00-0xcf7: clean.
[   56.233191] cs: IO port probe 0xa00-0xaff: clean.
[   56.587237] PCI: Enabling device 0000:02:00.0 (0000 -> 0002)
[   56.587270] PCI: Setting latency timer of device 0000:02:00.0 to 64
[   56.609548] ssb: Sonics Silicon Backplane found on PCI device 0000:02:00.0
[   58.084051] b43-phy0: Broadcom 4306 WLAN found
[   58.125215] b43-phy0 debug: Found PHY: Analog 2, Type 2, Revision 2
[   58.125249] b43-phy0 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
[   58.151207] phy0: Selected rate control algorithm 'simple'
[   58.923632] PCI: Found IRQ 10 for device 0000:00:08.0
[   59.631396] gameport: CS4281 Gameport is pci0000:00:08.0/gameport0, speed 2386kHz
[   61.003639] parport0: PC-style at 0x378 [PCSPP]
[   61.098563] lp0: using parport0 (polling).
[   62.454405] cpufreq: change failed with new_state 1 and result 0
[   63.203047] cpufreq: change failed with new_state 0 and result 0
[   63.406202] Adding 498004k swap on /dev/sda2.  Priority:-1 extents:1 across:498004k
[   63.564767] Clocksource tsc unstable (delta = 1500178122 ns)
[   63.568754] Time: pit clocksource has been installed.
[   63.823813] EXT3 FS on sda1, internal journal
[   64.714237] kjournald starting.  Commit interval 5 seconds
[   64.714640] EXT3 FS on sda3, internal journal
[   64.714654] EXT3-fs: mounted filesystem with ordered data mode.
[   70.381811] eth0:  setting half-duplex.
[   70.519920] input: b43-phy0 as /class/input/input4
[   70.933215] b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
[   72.152723] b43-phy0 debug: Chip initialized
[   72.154016] b43-phy0 debug: 30-bit DMA initialized
[   72.159729] b43-phy0 debug: Wireless interface started
[   72.200411] b43-phy0 debug: Adding Interface type 2
[   72.989653] spurious 8259A interrupt: IRQ7.
[   73.862348] NET: Registered protocol family 10
[   73.863446] lo: Disabled Privacy Extensions
[   73.865387] ADDRCONF(NETDEV_UP): eth0: link is not ready
[   73.868264] ADDRCONF(NETDEV_UP): wlan0: link is not ready
[   96.460816] ppdev: user-space parallel port driver
[  124.991701] NET: Registered protocol family 17
[  126.411133] b43-phy0 debug: Removing Interface type 2
[  126.435282] hald-addon-keyb[4259] general protection eip:b7e5e7bc esp:bfe890a8 error:0
[  126.467433] b43-phy0 debug: Wireless interface stopped
[  126.467506] b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
[  126.467647] b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
[  126.475194] b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
[  126.487862] b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
[  126.495166] b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
[  126.503152] b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 2/128
[  126.511121] b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
[  130.850387] ondemand governor failed, too long transition latency of HW, fallback to performance governor
[  132.326919] input: b43-phy0 as /class/input/input5
[  132.535359] b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
[  134.491881] b43-phy0 debug: Chip initialized
[  134.493394] b43-phy0 debug: 30-bit DMA initialized
[  134.499365] b43-phy0 debug: Wireless interface started
[  134.550833] b43-phy0 debug: Adding Interface type 2
[  134.552065] ADDRCONF(NETDEV_UP): wlan0: link is not ready
[  137.093721] Bluetooth: Core ver 2.11
[  137.094228] NET: Registered protocol family 31
[  137.094238] Bluetooth: HCI device and connection manager initialized
[  137.094249] Bluetooth: HCI socket layer initialized
[  137.685463] Bluetooth: L2CAP ver 2.9
[  137.685477] Bluetooth: L2CAP socket layer initialized
[  138.279445] Bluetooth: RFCOMM socket layer initialized
[  138.279496] Bluetooth: RFCOMM TTY layer initialized
[  138.279503] Bluetooth: RFCOMM ver 1.8
[  185.721852] b43-phy0 debug: Removing Interface type 2
[  185.758141] hald-addon-keyb[5070] general protection eip:b7ddd7bc esp:bfc6d688 error:0
[  185.786481] b43-phy0 debug: Wireless interface stopped
[  185.786542] b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
[  185.786686] b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
[  185.793919] b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
[  185.802562] b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
[  185.813614] b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
[  185.821041] b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 2/128
[  185.825825] b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
[  194.657198] input: b43-phy0 as /class/input/input6
[  194.842027] b43-phy0 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
[  196.245778] b43-phy0 debug: Chip initialized
[  196.247431] b43-phy0 debug: 30-bit DMA initialized
[  196.253928] b43-phy0 debug: Wireless interface started
[  196.293186] b43-phy0 debug: Adding Interface type 2
[  196.294604] ADDRCONF(NETDEV_UP): wlan0: link is not ready
[  294.744031] b43-phy0 debug: Removing Interface type 2
[  294.800275] b43-phy0 debug: Wireless interface stopped
[  294.800631] b43-phy0 debug: DMA-32 0x0200 (RX) max used slots: 1/64
[  294.800998] b43-phy0 debug: DMA-32 0x02A0 (TX) max used slots: 0/128
[  294.808592] b43-phy0 debug: DMA-32 0x0280 (TX) max used slots: 0/128
[  294.816067] b43-phy0 debug: DMA-32 0x0260 (TX) max used slots: 0/128
[  294.824026] b43-phy0 debug: DMA-32 0x0240 (TX) max used slots: 0/128
[  294.832024] b43-phy0 debug: DMA-32 0x0220 (TX) max used slots: 2/128
[  294.840129] b43-phy0 debug: DMA-32 0x0200 (TX) max used slots: 0/128
[  298.048541] b43-phy1: Broadcom 4306 WLAN found
[  298.091732] b43-phy1 debug: Found PHY: Analog 2, Type 2, Revision 2
[  298.091769] b43-phy1 debug: Found Radio: Manuf 0x17F, Version 0x2050, Revision 2
[  298.121691] phy1: Selected rate control algorithm 'simple'
[  298.231438] input: b43-phy1 as /class/input/input7
[  298.579182] b43-phy1 debug: Loading firmware version 351.126 (2006-07-29 05:54:02)
[  299.692193] b43-phy1 debug: Chip initialized
[  299.693305] b43-phy1 debug: 30-bit DMA initialized
[  299.699109] b43-phy1 debug: Wireless interface started
[  299.735899] b43-phy1 debug: Adding Interface type 2
[  299.737214] ADDRCONF(NETDEV_UP): wlan0: link is not ready
[  395.851151] wlan0: Initial auth_alg=0
[  395.851170] wlan0: authenticate with AP 00:09:5b:df:7b:b0
[  395.852800] wlan0: RX authentication from 00:09:5b:df:7b:b0 (alg=0 transaction=2 status=0)
[  395.852815] wlan0: authenticated
[  395.852823] wlan0: associate with AP 00:09:5b:df:7b:b0
[  395.855134] wlan0: RX AssocResp from 00:09:5b:df:7b:b0 (capab=0x431 status=0 aid=2)
[  395.855147] wlan0: associated
[  395.855160] wlan0: CTS protection enabled (BSSID=00:09:5b:df:7b:b0)
[  395.855169] wlan0: switched to short barker preamble (BSSID=00:09:5b:df:7b:b0)
[  395.855667] ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
[  411.604903] wlan0: CTS protection disabled (BSSID=00:09:5b:df:7b:b0)
[  412.405474] wlan0: no IPv6 routers present
[  427.985829] wlan0: CTS protection enabled (BSSID=00:09:5b:df:7b:b0)
[  663.672052] wlan0: CTS protection disabled (BSSID=00:09:5b:df:7b:b0)
[  680.053331] wlan0: CTS protection enabled (BSSID=00:09:5b:df:7b:b0)
[  999.796155] wlan0: CTS protection disabled (BSSID=00:09:5b:df:7b:b0)
[ 1016.382214] wlan0: CTS protection enabled (BSSID=00:09:5b:df:7b:b0)
[ 1242.546702] wlan0: CTS protection disabled (BSSID=00:09:5b:df:7b:b0)
[ 1258.931341] wlan0: CTS protection enabled (BSSID=00:09:5b:df:7b:b0)

From mb at bu3sch.de  Wed Jan 16 02:14:23 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 16 Jan 2008 02:14:23 +0100
Subject: [PATCH] b43: Add lots of N-PHY lookup tables
Message-ID: <200801160214.23564.mb@bu3sch.de>

This adds lots of N-PHY related lookup tables.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.25

Index: wireless-2.6/drivers/net/wireless/b43/tables_nphy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/tables_nphy.c	2008-01-15 00:23:51.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/tables_nphy.c	2008-01-16 02:07:59.000000000 +0100
@@ -1331,6 +1331,1146 @@ b43_nphy_get_chantabent(struct b43_wldev
 		if (e->channel == channel)
 			return e;
 	}
 
 	return NULL;
 }
+
+
+const u8 b43_ntab_adjustpower0[] = {
+	0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
+	0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
+	0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,
+	0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07,
+	0x08, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09,
+	0x0A, 0x0A, 0x0A, 0x0A, 0x0B, 0x0B, 0x0B, 0x0B,
+	0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,
+	0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,
+	0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,
+	0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
+	0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
+	0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
+	0x18, 0x18, 0x18, 0x18, 0x19, 0x19, 0x19, 0x19,
+	0x1A, 0x1A, 0x1A, 0x1A, 0x1B, 0x1B, 0x1B, 0x1B,
+	0x1C, 0x1C, 0x1C, 0x1C, 0x1D, 0x1D, 0x1D, 0x1D,
+	0x1E, 0x1E, 0x1E, 0x1E, 0x1F, 0x1F, 0x1F, 0x1F,
+};
+
+const u8 b43_ntab_adjustpower1[] = {
+	0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
+	0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
+	0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,
+	0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07,
+	0x08, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09,
+	0x0A, 0x0A, 0x0A, 0x0A, 0x0B, 0x0B, 0x0B, 0x0B,
+	0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,
+	0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,
+	0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,
+	0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
+	0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
+	0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
+	0x18, 0x18, 0x18, 0x18, 0x19, 0x19, 0x19, 0x19,
+	0x1A, 0x1A, 0x1A, 0x1A, 0x1B, 0x1B, 0x1B, 0x1B,
+	0x1C, 0x1C, 0x1C, 0x1C, 0x1D, 0x1D, 0x1D, 0x1D,
+	0x1E, 0x1E, 0x1E, 0x1E, 0x1F, 0x1F, 0x1F, 0x1F,
+};
+
+const u16 b43_ntab_bdi[] = {
+	0x0070, 0x0126, 0x012C, 0x0246, 0x048D, 0x04D2,
+};
+
+const u32 b43_ntab_channelest[] = {
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x44444444, 0x44444444, 0x44444444, 0x44444444,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+	0x10101010, 0x10101010, 0x10101010, 0x10101010,
+};
+
+const u8 b43_ntab_estimatepowerlt0[] = {
+	0x50, 0x4F, 0x4E, 0x4D, 0x4C, 0x4B, 0x4A, 0x49,
+	0x48, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41,
+	0x40, 0x3F, 0x3E, 0x3D, 0x3C, 0x3B, 0x3A, 0x39,
+	0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31,
+	0x30, 0x2F, 0x2E, 0x2D, 0x2C, 0x2B, 0x2A, 0x29,
+	0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21,
+	0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19,
+	0x18, 0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11,
+};
+
+const u8 b43_ntab_estimatepowerlt1[] = {
+	0x50, 0x4F, 0x4E, 0x4D, 0x4C, 0x4B, 0x4A, 0x49,
+	0x48, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41,
+	0x40, 0x3F, 0x3E, 0x3D, 0x3C, 0x3B, 0x3A, 0x39,
+	0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31,
+	0x30, 0x2F, 0x2E, 0x2D, 0x2C, 0x2B, 0x2A, 0x29,
+	0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21,
+	0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19,
+	0x18, 0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11,
+};
+
+const u8 b43_ntab_framelookup[] = {
+	0x02, 0x04, 0x14, 0x14, 0x03, 0x05, 0x16, 0x16,
+	0x0A, 0x0C, 0x1C, 0x1C, 0x0B, 0x0D, 0x1E, 0x1E,
+	0x06, 0x08, 0x18, 0x18, 0x07, 0x09, 0x1A, 0x1A,
+	0x0E, 0x10, 0x20, 0x28, 0x0F, 0x11, 0x22, 0x2A,
+};
+
+const u32 b43_ntab_framestruct[] = {
+	0x08004A04, 0x00100000, 0x01000A05, 0x00100020,
+	0x09804506, 0x00100030, 0x09804507, 0x00100030,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x08004A0C, 0x00100008, 0x01000A0D, 0x00100028,
+	0x0980450E, 0x00100038, 0x0980450F, 0x00100038,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000A04, 0x00100000, 0x11008A05, 0x00100020,
+	0x1980C506, 0x00100030, 0x21810506, 0x00100030,
+	0x21810506, 0x00100030, 0x01800504, 0x00100030,
+	0x11808505, 0x00100030, 0x29814507, 0x01100030,
+	0x00000A04, 0x00100000, 0x11008A05, 0x00100020,
+	0x21810506, 0x00100030, 0x21810506, 0x00100030,
+	0x29814507, 0x01100030, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000A0C, 0x00100008, 0x11008A0D, 0x00100028,
+	0x1980C50E, 0x00100038, 0x2181050E, 0x00100038,
+	0x2181050E, 0x00100038, 0x0180050C, 0x00100038,
+	0x1180850D, 0x00100038, 0x2981450F, 0x01100038,
+	0x00000A0C, 0x00100008, 0x11008A0D, 0x00100028,
+	0x2181050E, 0x00100038, 0x2181050E, 0x00100038,
+	0x2981450F, 0x01100038, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x08004A04, 0x00100000, 0x01000A05, 0x00100020,
+	0x1980C506, 0x00100030, 0x1980C506, 0x00100030,
+	0x11808504, 0x00100030, 0x3981CA05, 0x00100030,
+	0x29814507, 0x01100030, 0x00000000, 0x00000000,
+	0x10008A04, 0x00100000, 0x3981CA05, 0x00100030,
+	0x1980C506, 0x00100030, 0x29814507, 0x01100030,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x08004A0C, 0x00100008, 0x01000A0D, 0x00100028,
+	0x1980C50E, 0x00100038, 0x1980C50E, 0x00100038,
+	0x1180850C, 0x00100038, 0x3981CA0D, 0x00100038,
+	0x2981450F, 0x01100038, 0x00000000, 0x00000000,
+	0x10008A0C, 0x00100008, 0x3981CA0D, 0x00100038,
+	0x1980C50E, 0x00100038, 0x2981450F, 0x01100038,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x40021404, 0x00100000, 0x02001405, 0x00100040,
+	0x0B004A06, 0x01900060, 0x13008A06, 0x01900060,
+	0x13008A06, 0x01900060, 0x43020A04, 0x00100060,
+	0x1B00CA05, 0x00100060, 0x23010A07, 0x01500060,
+	0x40021404, 0x00100000, 0x1A00D405, 0x00100040,
+	0x13008A06, 0x01900060, 0x13008A06, 0x01900060,
+	0x23010A07, 0x01500060, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4002140C, 0x00100010, 0x0200140D, 0x00100050,
+	0x0B004A0E, 0x01900070, 0x13008A0E, 0x01900070,
+	0x13008A0E, 0x01900070, 0x43020A0C, 0x00100070,
+	0x1B00CA0D, 0x00100070, 0x23010A0F, 0x01500070,
+	0x4002140C, 0x00100010, 0x1A00D40D, 0x00100050,
+	0x13008A0E, 0x01900070, 0x13008A0E, 0x01900070,
+	0x23010A0F, 0x01500070, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x50029404, 0x00100000, 0x32019405, 0x00100040,
+	0x0B004A06, 0x01900060, 0x0B004A06, 0x01900060,
+	0x5B02CA04, 0x00100060, 0x3B01D405, 0x00100060,
+	0x23010A07, 0x01500060, 0x00000000, 0x00000000,
+	0x5802D404, 0x00100000, 0x3B01D405, 0x00100060,
+	0x0B004A06, 0x01900060, 0x23010A07, 0x01500060,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x5002940C, 0x00100010, 0x3201940D, 0x00100050,
+	0x0B004A0E, 0x01900070, 0x0B004A0E, 0x01900070,
+	0x5B02CA0C, 0x00100070, 0x3B01D40D, 0x00100070,
+	0x23010A0F, 0x01500070, 0x00000000, 0x00000000,
+	0x5802D40C, 0x00100010, 0x3B01D40D, 0x00100070,
+	0x0B004A0E, 0x01900070, 0x23010A0F, 0x01500070,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x40021404, 0x000F4800, 0x62031405, 0x00100040,
+	0x53028A06, 0x01900060, 0x53028A07, 0x01900060,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4002140C, 0x000F4810, 0x6203140D, 0x00100050,
+	0x53028A0E, 0x01900070, 0x53028A0F, 0x01900070,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000A0C, 0x00100008, 0x11008A0D, 0x00100028,
+	0x1980C50E, 0x00100038, 0x2181050E, 0x00100038,
+	0x2181050E, 0x00100038, 0x0180050C, 0x00100038,
+	0x1180850D, 0x00100038, 0x1181850D, 0x00100038,
+	0x2981450F, 0x01100038, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000A0C, 0x00100008, 0x11008A0D, 0x00100028,
+	0x2181050E, 0x00100038, 0x2181050E, 0x00100038,
+	0x1181850D, 0x00100038, 0x2981450F, 0x01100038,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x08004A04, 0x00100000, 0x01000A05, 0x00100020,
+	0x0180C506, 0x00100030, 0x0180C506, 0x00100030,
+	0x2180C50C, 0x00100030, 0x49820A0D, 0x0016A130,
+	0x41824A0D, 0x0016A130, 0x2981450F, 0x01100030,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x2000CA0C, 0x00100000, 0x49820A0D, 0x0016A130,
+	0x1980C50E, 0x00100030, 0x41824A0D, 0x0016A130,
+	0x2981450F, 0x01100030, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4002140C, 0x00100010, 0x0200140D, 0x00100050,
+	0x0B004A0E, 0x01900070, 0x13008A0E, 0x01900070,
+	0x13008A0E, 0x01900070, 0x43020A0C, 0x00100070,
+	0x1B00CA0D, 0x00100070, 0x1B014A0D, 0x00100070,
+	0x23010A0F, 0x01500070, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4002140C, 0x00100010, 0x1A00D40D, 0x00100050,
+	0x13008A0E, 0x01900070, 0x13008A0E, 0x01900070,
+	0x1B014A0D, 0x00100070, 0x23010A0F, 0x01500070,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x50029404, 0x00100000, 0x32019405, 0x00100040,
+	0x03004A06, 0x01900060, 0x03004A06, 0x01900060,
+	0x6B030A0C, 0x00100060, 0x4B02140D, 0x0016A160,
+	0x4302540D, 0x0016A160, 0x23010A0F, 0x01500060,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x6B03140C, 0x00100060, 0x4B02140D, 0x0016A160,
+	0x0B004A0E, 0x01900060, 0x4302540D, 0x0016A160,
+	0x23010A0F, 0x01500060, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x40021404, 0x00100000, 0x1A00D405, 0x00100040,
+	0x53028A06, 0x01900060, 0x5B02CA06, 0x01900060,
+	0x5B02CA06, 0x01900060, 0x43020A04, 0x00100060,
+	0x1B00CA05, 0x00100060, 0x53028A07, 0x0190C060,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4002140C, 0x00100010, 0x1A00D40D, 0x00100050,
+	0x53028A0E, 0x01900070, 0x5B02CA0E, 0x01900070,
+	0x5B02CA0E, 0x01900070, 0x43020A0C, 0x00100070,
+	0x1B00CA0D, 0x00100070, 0x53028A0F, 0x0190C070,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x40021404, 0x00100000, 0x1A00D405, 0x00100040,
+	0x5B02CA06, 0x01900060, 0x5B02CA06, 0x01900060,
+	0x53028A07, 0x0190C060, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4002140C, 0x00100010, 0x1A00D40D, 0x00100050,
+	0x5B02CA0E, 0x01900070, 0x5B02CA0E, 0x01900070,
+	0x53028A0F, 0x0190C070, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+};
+
+const u32 b43_ntab_gainctl0[] = {
+	0x007F003F, 0x007E013F, 0x007D023E, 0x007C033E,
+	0x007B043D, 0x007A053D, 0x0079063C, 0x0078073C,
+	0x0077083B, 0x0076093B, 0x00750A3A, 0x00740B3A,
+	0x00730C39, 0x00720D39, 0x00710E38, 0x00700F38,
+	0x006F0037, 0x006E0137, 0x006D0236, 0x006C0336,
+	0x006B0435, 0x006A0535, 0x00690634, 0x00680734,
+	0x00670833, 0x00660933, 0x00650A32, 0x00640B32,
+	0x00630C31, 0x00620D31, 0x00610E30, 0x00600F30,
+	0x005F002F, 0x005E012F, 0x005D022E, 0x005C032E,
+	0x005B042D, 0x005A052D, 0x0059062C, 0x0058072C,
+	0x0057082B, 0x0056092B, 0x00550A2A, 0x00540B2A,
+	0x00530C29, 0x00520D29, 0x00510E28, 0x00500F28,
+	0x004F0027, 0x004E0127, 0x004D0226, 0x004C0326,
+	0x004B0425, 0x004A0525, 0x00490624, 0x00480724,
+	0x00470823, 0x00460923, 0x00450A22, 0x00440B22,
+	0x00430C21, 0x00420D21, 0x00410E20, 0x00400F20,
+	0x003F001F, 0x003E011F, 0x003D021E, 0x003C031E,
+	0x003B041D, 0x003A051D, 0x0039061C, 0x0038071C,
+	0x0037081B, 0x0036091B, 0x00350A1A, 0x00340B1A,
+	0x00330C19, 0x00320D19, 0x00310E18, 0x00300F18,
+	0x002F0017, 0x002E0117, 0x002D0216, 0x002C0316,
+	0x002B0415, 0x002A0515, 0x00290614, 0x00280714,
+	0x00270813, 0x00260913, 0x00250A12, 0x00240B12,
+	0x00230C11, 0x00220D11, 0x00210E10, 0x00200F10,
+	0x001F000F, 0x001E010F, 0x001D020E, 0x001C030E,
+	0x001B040D, 0x001A050D, 0x0019060C, 0x0018070C,
+	0x0017080B, 0x0016090B, 0x00150A0A, 0x00140B0A,
+	0x00130C09, 0x00120D09, 0x00110E08, 0x00100F08,
+	0x000F0007, 0x000E0107, 0x000D0206, 0x000C0306,
+	0x000B0405, 0x000A0505, 0x00090604, 0x00080704,
+	0x00070803, 0x00060903, 0x00050A02, 0x00040B02,
+	0x00030C01, 0x00020D01, 0x00010E00, 0x00000F00,
+};
+
+const u32 b43_ntab_gainctl1[] = {
+	0x007F003F, 0x007E013F, 0x007D023E, 0x007C033E,
+	0x007B043D, 0x007A053D, 0x0079063C, 0x0078073C,
+	0x0077083B, 0x0076093B, 0x00750A3A, 0x00740B3A,
+	0x00730C39, 0x00720D39, 0x00710E38, 0x00700F38,
+	0x006F0037, 0x006E0137, 0x006D0236, 0x006C0336,
+	0x006B0435, 0x006A0535, 0x00690634, 0x00680734,
+	0x00670833, 0x00660933, 0x00650A32, 0x00640B32,
+	0x00630C31, 0x00620D31, 0x00610E30, 0x00600F30,
+	0x005F002F, 0x005E012F, 0x005D022E, 0x005C032E,
+	0x005B042D, 0x005A052D, 0x0059062C, 0x0058072C,
+	0x0057082B, 0x0056092B, 0x00550A2A, 0x00540B2A,
+	0x00530C29, 0x00520D29, 0x00510E28, 0x00500F28,
+	0x004F0027, 0x004E0127, 0x004D0226, 0x004C0326,
+	0x004B0425, 0x004A0525, 0x00490624, 0x00480724,
+	0x00470823, 0x00460923, 0x00450A22, 0x00440B22,
+	0x00430C21, 0x00420D21, 0x00410E20, 0x00400F20,
+	0x003F001F, 0x003E011F, 0x003D021E, 0x003C031E,
+	0x003B041D, 0x003A051D, 0x0039061C, 0x0038071C,
+	0x0037081B, 0x0036091B, 0x00350A1A, 0x00340B1A,
+	0x00330C19, 0x00320D19, 0x00310E18, 0x00300F18,
+	0x002F0017, 0x002E0117, 0x002D0216, 0x002C0316,
+	0x002B0415, 0x002A0515, 0x00290614, 0x00280714,
+	0x00270813, 0x00260913, 0x00250A12, 0x00240B12,
+	0x00230C11, 0x00220D11, 0x00210E10, 0x00200F10,
+	0x001F000F, 0x001E010F, 0x001D020E, 0x001C030E,
+	0x001B040D, 0x001A050D, 0x0019060C, 0x0018070C,
+	0x0017080B, 0x0016090B, 0x00150A0A, 0x00140B0A,
+	0x00130C09, 0x00120D09, 0x00110E08, 0x00100F08,
+	0x000F0007, 0x000E0107, 0x000D0206, 0x000C0306,
+	0x000B0405, 0x000A0505, 0x00090604, 0x00080704,
+	0x00070803, 0x00060903, 0x00050A02, 0x00040B02,
+	0x00030C01, 0x00020D01, 0x00010E00, 0x00000F00,
+};
+
+const u32 b43_ntab_intlevel[] = {
+	0x00802070, 0x0671188D, 0x0A60192C, 0x0A300E46,
+	0x00C1188D, 0x080024D2, 0x00000070,
+};
+
+const u32 b43_ntab_iqlt0[] = {
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+};
+
+const u32 b43_ntab_iqlt1[] = {
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+	0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F,
+};
+
+const u16 b43_ntab_loftlt0[] = {
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103,
+};
+
+const u16 b43_ntab_loftlt1[] = {
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103, 0x0000, 0x0101, 0x0002, 0x0103,
+	0x0000, 0x0101, 0x0002, 0x0103, 0x0000, 0x0101,
+	0x0002, 0x0103,
+};
+
+const u8 b43_ntab_mcs[] = {
+	0x00, 0x08, 0x0A, 0x10, 0x12, 0x19, 0x1A, 0x1C,
+	0x40, 0x48, 0x4A, 0x50, 0x52, 0x59, 0x5A, 0x5C,
+	0x80, 0x88, 0x8A, 0x90, 0x92, 0x99, 0x9A, 0x9C,
+	0xC0, 0xC8, 0xCA, 0xD0, 0xD2, 0xD9, 0xDA, 0xDC,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x01, 0x02, 0x04, 0x08, 0x09, 0x0A, 0x0C,
+	0x10, 0x11, 0x12, 0x14, 0x18, 0x19, 0x1A, 0x1C,
+	0x20, 0x21, 0x22, 0x24, 0x40, 0x41, 0x42, 0x44,
+	0x48, 0x49, 0x4A, 0x4C, 0x50, 0x51, 0x52, 0x54,
+	0x58, 0x59, 0x5A, 0x5C, 0x60, 0x61, 0x62, 0x64,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+const u32 b43_ntab_noisevar10[] = {
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+};
+
+const u32 b43_ntab_noisevar11[] = {
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+	0x020C020C, 0x0000014D, 0x020C020C, 0x0000014D,
+};
+
+const u16 b43_ntab_pilot[] = {
+	0xFF08, 0xFF08, 0xFF08, 0xFF08, 0xFF08, 0xFF08,
+	0xFF08, 0xFF08, 0x80D5, 0x80D5, 0x80D5, 0x80D5,
+	0x80D5, 0x80D5, 0x80D5, 0x80D5, 0xFF0A, 0xFF82,
+	0xFFA0, 0xFF28, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
+	0xFF82, 0xFFA0, 0xFF28, 0xFF0A, 0xFFFF, 0xFFFF,
+	0xFFFF, 0xFFFF, 0xF83F, 0xFA1F, 0xFA97, 0xFAB5,
+	0xF2BD, 0xF0BF, 0xFFFF, 0xFFFF, 0xF017, 0xF815,
+	0xF215, 0xF095, 0xF035, 0xF01D, 0xFFFF, 0xFFFF,
+	0xFF08, 0xFF02, 0xFF80, 0xFF20, 0xFF08, 0xFF02,
+	0xFF80, 0xFF20, 0xF01F, 0xF817, 0xFA15, 0xF295,
+	0xF0B5, 0xF03D, 0xFFFF, 0xFFFF, 0xF82A, 0xFA0A,
+	0xFA82, 0xFAA0, 0xF2A8, 0xF0AA, 0xFFFF, 0xFFFF,
+	0xF002, 0xF800, 0xF200, 0xF080, 0xF020, 0xF008,
+	0xFFFF, 0xFFFF, 0xF00A, 0xF802, 0xFA00, 0xF280,
+	0xF0A0, 0xF028, 0xFFFF, 0xFFFF,
+};
+
+const u32 b43_ntab_pilotlt[] = {
+	0x76540123, 0x62407351, 0x76543201, 0x76540213,
+	0x76540123, 0x76430521,
+};
+
+const u32 b43_ntab_tdi20a0[] = {
+	0x00091226, 0x000A1429, 0x000B56AD, 0x000C58B0,
+	0x000D5AB3, 0x000E9CB6, 0x000F9EBA, 0x0000C13D,
+	0x00020301, 0x00030504, 0x00040708, 0x0005090B,
+	0x00064B8E, 0x00095291, 0x000A5494, 0x000B9718,
+	0x000C9927, 0x000D9B2A, 0x000EDD2E, 0x000FDF31,
+	0x000101B4, 0x000243B7, 0x000345BB, 0x000447BE,
+	0x00058982, 0x00068C05, 0x00099309, 0x000A950C,
+	0x000BD78F, 0x000CD992, 0x000DDB96, 0x000F1D99,
+	0x00005FA8, 0x0001422C, 0x0002842F, 0x00038632,
+	0x00048835, 0x0005CA38, 0x0006CCBC, 0x0009D3BF,
+	0x000B1603, 0x000C1806, 0x000D1A0A, 0x000E1C0D,
+	0x000F5E10, 0x00008093, 0x00018297, 0x0002C49A,
+	0x0003C680, 0x0004C880, 0x00060B00, 0x00070D00,
+	0x00000000, 0x00000000, 0x00000000,
+};
+
+const u32 b43_ntab_tdi20a1[] = {
+	0x00014B26, 0x00028D29, 0x000393AD, 0x00049630,
+	0x0005D833, 0x0006DA36, 0x00099C3A, 0x000A9E3D,
+	0x000BC081, 0x000CC284, 0x000DC488, 0x000F068B,
+	0x0000488E, 0x00018B91, 0x0002D214, 0x0003D418,
+	0x0004D6A7, 0x000618AA, 0x00071AAE, 0x0009DCB1,
+	0x000B1EB4, 0x000C0137, 0x000D033B, 0x000E053E,
+	0x000F4702, 0x00008905, 0x00020C09, 0x0003128C,
+	0x0004148F, 0x00051712, 0x00065916, 0x00091B19,
+	0x000A1D28, 0x000B5F2C, 0x000C41AF, 0x000D43B2,
+	0x000E85B5, 0x000F87B8, 0x0000C9BC, 0x00024CBF,
+	0x00035303, 0x00045506, 0x0005978A, 0x0006998D,
+	0x00095B90, 0x000A5D93, 0x000B9F97, 0x000C821A,
+	0x000D8400, 0x000EC600, 0x000FC800, 0x00010A00,
+	0x00000000, 0x00000000, 0x00000000,
+};
+
+const u32 b43_ntab_tdi40a0[] = {
+	0x0011A346, 0x00136CCF, 0x0014F5D9, 0x001641E2,
+	0x0017CB6B, 0x00195475, 0x001B2383, 0x001CAD0C,
+	0x001E7616, 0x0000821F, 0x00020BA8, 0x0003D4B2,
+	0x00056447, 0x00072DD0, 0x0008B6DA, 0x000A02E3,
+	0x000B8C6C, 0x000D15F6, 0x0011E484, 0x0013AE0D,
+	0x00153717, 0x00168320, 0x00180CA9, 0x00199633,
+	0x001B6548, 0x001CEED1, 0x001EB7DB, 0x0000C3E4,
+	0x00024D6D, 0x000416F7, 0x0005A585, 0x00076F0F,
+	0x0008F818, 0x000A4421, 0x000BCDAB, 0x000D9734,
+	0x00122649, 0x0013EFD2, 0x001578DC, 0x0016C4E5,
+	0x00184E6E, 0x001A17F8, 0x001BA686, 0x001D3010,
+	0x001EF999, 0x00010522, 0x00028EAC, 0x00045835,
+	0x0005E74A, 0x0007B0D3, 0x00093A5D, 0x000A85E6,
+	0x000C0F6F, 0x000DD8F9, 0x00126787, 0x00143111,
+	0x0015BA9A, 0x00170623, 0x00188FAD, 0x001A5936,
+	0x001BE84B, 0x001DB1D4, 0x001F3B5E, 0x000146E7,
+	0x00031070, 0x000499FA, 0x00062888, 0x0007F212,
+	0x00097B9B, 0x000AC7A4, 0x000C50AE, 0x000E1A37,
+	0x0012A94C, 0x001472D5, 0x0015FC5F, 0x00174868,
+	0x0018D171, 0x001A9AFB, 0x001C2989, 0x001DF313,
+	0x001F7C9C, 0x000188A5, 0x000351AF, 0x0004DB38,
+	0x0006AA4D, 0x000833D7, 0x0009BD60, 0x000B0969,
+	0x000C9273, 0x000E5BFC, 0x00132A8A, 0x0014B414,
+	0x00163D9D, 0x001789A6, 0x001912B0, 0x001ADC39,
+	0x001C6BCE, 0x001E34D8, 0x001FBE61, 0x0001CA6A,
+	0x00039374, 0x00051CFD, 0x0006EC0B, 0x00087515,
+	0x0009FE9E, 0x000B4AA7, 0x000CD3B1, 0x000E9D3A,
+	0x00000000, 0x00000000,
+};
+
+const u32 b43_ntab_tdi40a1[] = {
+	0x001EDB36, 0x000129CA, 0x0002B353, 0x00047CDD,
+	0x0005C8E6, 0x000791EF, 0x00091BF9, 0x000AAA07,
+	0x000C3391, 0x000DFD1A, 0x00120923, 0x0013D22D,
+	0x00155C37, 0x0016EACB, 0x00187454, 0x001A3DDE,
+	0x001B89E7, 0x001D12F0, 0x001F1CFA, 0x00016B88,
+	0x00033492, 0x0004BE1B, 0x00060A24, 0x0007D32E,
+	0x00095D38, 0x000AEC4C, 0x000C7555, 0x000E3EDF,
+	0x00124AE8, 0x001413F1, 0x0015A37B, 0x00172C89,
+	0x0018B593, 0x001A419C, 0x001BCB25, 0x001D942F,
+	0x001F63B9, 0x0001AD4D, 0x00037657, 0x0004C260,
+	0x00068BE9, 0x000814F3, 0x0009A47C, 0x000B2D8A,
+	0x000CB694, 0x000E429D, 0x00128C26, 0x001455B0,
+	0x0015E4BA, 0x00176E4E, 0x0018F758, 0x001A8361,
+	0x001C0CEA, 0x001DD674, 0x001FA57D, 0x0001EE8B,
+	0x0003B795, 0x0005039E, 0x0006CD27, 0x000856B1,
+	0x0009E5C6, 0x000B6F4F, 0x000CF859, 0x000E8462,
+	0x00130DEB, 0x00149775, 0x00162603, 0x0017AF8C,
+	0x00193896, 0x001AC49F, 0x001C4E28, 0x001E17B2,
+	0x0000A6C7, 0x00023050, 0x0003F9DA, 0x00054563,
+	0x00070EEC, 0x00089876, 0x000A2704, 0x000BB08D,
+	0x000D3A17, 0x001185A0, 0x00134F29, 0x0014D8B3,
+	0x001667C8, 0x0017F151, 0x00197ADB, 0x001B0664,
+	0x001C8FED, 0x001E5977, 0x0000E805, 0x0002718F,
+	0x00043B18, 0x000586A1, 0x0007502B, 0x0008D9B4,
+	0x000A68C9, 0x000BF252, 0x000DBBDC, 0x0011C7E5,
+	0x001390EE, 0x00151A78, 0x0016A906, 0x00183290,
+	0x0019BC19, 0x001B4822, 0x001CD12C, 0x001E9AB5,
+	0x00000000, 0x00000000,
+};
+
+const u32 b43_ntab_tdtrn[] = {
+	0x061C061C, 0x0050EE68, 0xF592FE36, 0xFE5212F6,
+	0x00000C38, 0xFE5212F6, 0xF592FE36, 0x0050EE68,
+	0x061C061C, 0xEE680050, 0xFE36F592, 0x12F6FE52,
+	0x0C380000, 0x12F6FE52, 0xFE36F592, 0xEE680050,
+	0x061C061C, 0x0050EE68, 0xF592FE36, 0xFE5212F6,
+	0x00000C38, 0xFE5212F6, 0xF592FE36, 0x0050EE68,
+	0x061C061C, 0xEE680050, 0xFE36F592, 0x12F6FE52,
+	0x0C380000, 0x12F6FE52, 0xFE36F592, 0xEE680050,
+	0x05E305E3, 0x004DEF0C, 0xF5F3FE47, 0xFE611246,
+	0x00000BC7, 0xFE611246, 0xF5F3FE47, 0x004DEF0C,
+	0x05E305E3, 0xEF0C004D, 0xFE47F5F3, 0x1246FE61,
+	0x0BC70000, 0x1246FE61, 0xFE47F5F3, 0xEF0C004D,
+	0x05E305E3, 0x004DEF0C, 0xF5F3FE47, 0xFE611246,
+	0x00000BC7, 0xFE611246, 0xF5F3FE47, 0x004DEF0C,
+	0x05E305E3, 0xEF0C004D, 0xFE47F5F3, 0x1246FE61,
+	0x0BC70000, 0x1246FE61, 0xFE47F5F3, 0xEF0C004D,
+	0xFA58FA58, 0xF895043B, 0xFF4C09C0, 0xFBC6FFA8,
+	0xFB84F384, 0x0798F6F9, 0x05760122, 0x058409F6,
+	0x0B500000, 0x05B7F542, 0x08860432, 0x06DDFEE7,
+	0xFB84F384, 0xF9D90664, 0xF7E8025C, 0x00FFF7BD,
+	0x05A805A8, 0xF7BD00FF, 0x025CF7E8, 0x0664F9D9,
+	0xF384FB84, 0xFEE706DD, 0x04320886, 0xF54205B7,
+	0x00000B50, 0x09F60584, 0x01220576, 0xF6F90798,
+	0xF384FB84, 0xFFA8FBC6, 0x09C0FF4C, 0x043BF895,
+	0x02D402D4, 0x07DE0270, 0xFC96079C, 0xF90AFE94,
+	0xFE00FF2C, 0x02D4065D, 0x092A0096, 0x0014FBB8,
+	0xFD2CFD2C, 0x076AFB3C, 0x0096F752, 0xF991FD87,
+	0xFB2C0200, 0xFEB8F960, 0x08E0FC96, 0x049802A8,
+	0xFD2CFD2C, 0x02A80498, 0xFC9608E0, 0xF960FEB8,
+	0x0200FB2C, 0xFD87F991, 0xF7520096, 0xFB3C076A,
+	0xFD2CFD2C, 0xFBB80014, 0x0096092A, 0x065D02D4,
+	0xFF2CFE00, 0xFE94F90A, 0x079CFC96, 0x027007DE,
+	0x02D402D4, 0x027007DE, 0x079CFC96, 0xFE94F90A,
+	0xFF2CFE00, 0x065D02D4, 0x0096092A, 0xFBB80014,
+	0xFD2CFD2C, 0xFB3C076A, 0xF7520096, 0xFD87F991,
+	0x0200FB2C, 0xF960FEB8, 0xFC9608E0, 0x02A80498,
+	0xFD2CFD2C, 0x049802A8, 0x08E0FC96, 0xFEB8F960,
+	0xFB2C0200, 0xF991FD87, 0x0096F752, 0x076AFB3C,
+	0xFD2CFD2C, 0x0014FBB8, 0x092A0096, 0x02D4065D,
+	0xFE00FF2C, 0xF90AFE94, 0xFC96079C, 0x07DE0270,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x062A0000, 0xFEFA0759, 0x08B80908, 0xF396FC2D,
+	0xF9D6045C, 0xFC4EF608, 0xF748F596, 0x07B207BF,
+	0x062A062A, 0xF84EF841, 0xF748F596, 0x03B209F8,
+	0xF9D6045C, 0x0C6A03D3, 0x08B80908, 0x0106F8A7,
+	0x062A0000, 0xFEFAF8A7, 0x08B8F6F8, 0xF39603D3,
+	0xF9D6FBA4, 0xFC4E09F8, 0xF7480A6A, 0x07B2F841,
+	0x062AF9D6, 0xF84E07BF, 0xF7480A6A, 0x03B2F608,
+	0xF9D6FBA4, 0x0C6AFC2D, 0x08B8F6F8, 0x01060759,
+	0x062A0000, 0xFEFA0759, 0x08B80908, 0xF396FC2D,
+	0xF9D6045C, 0xFC4EF608, 0xF748F596, 0x07B207BF,
+	0x062A062A, 0xF84EF841, 0xF748F596, 0x03B209F8,
+	0xF9D6045C, 0x0C6A03D3, 0x08B80908, 0x0106F8A7,
+	0x062A0000, 0xFEFAF8A7, 0x08B8F6F8, 0xF39603D3,
+	0xF9D6FBA4, 0xFC4E09F8, 0xF7480A6A, 0x07B2F841,
+	0x062AF9D6, 0xF84E07BF, 0xF7480A6A, 0x03B2F608,
+	0xF9D6FBA4, 0x0C6AFC2D, 0x08B8F6F8, 0x01060759,
+	0x061C061C, 0xFF30009D, 0xFFB21141, 0xFD87FB54,
+	0xF65DFE59, 0x02EEF99E, 0x0166F03C, 0xFFF809B6,
+	0x000008A4, 0x000AF42B, 0x00EFF577, 0xFA840BF2,
+	0xFC02FF51, 0x08260F67, 0xFFF0036F, 0x0842F9C3,
+	0x00000000, 0x063DF7BE, 0xFC910010, 0xF099F7DA,
+	0x00AF03FE, 0xF40E057C, 0x0A89FF11, 0x0BD5FFF6,
+	0xF75C0000, 0xF64A0008, 0x0FC4FE9A, 0x0662FD12,
+	0x01A709A3, 0x04AC0279, 0xEEBF004E, 0xFF6300D0,
+	0xF9E4F9E4, 0x00D0FF63, 0x004EEEBF, 0x027904AC,
+	0x09A301A7, 0xFD120662, 0xFE9A0FC4, 0x0008F64A,
+	0x0000F75C, 0xFFF60BD5, 0xFF110A89, 0x057CF40E,
+	0x03FE00AF, 0xF7DAF099, 0x0010FC91, 0xF7BE063D,
+	0x00000000, 0xF9C30842, 0x036FFFF0, 0x0F670826,
+	0xFF51FC02, 0x0BF2FA84, 0xF57700EF, 0xF42B000A,
+	0x08A40000, 0x09B6FFF8, 0xF03C0166, 0xF99E02EE,
+	0xFE59F65D, 0xFB54FD87, 0x1141FFB2, 0x009DFF30,
+	0x05E30000, 0xFF060705, 0x085408A0, 0xF425FC59,
+	0xFA1D042A, 0xFC78F67A, 0xF7ACF60E, 0x075A0766,
+	0x05E305E3, 0xF8A6F89A, 0xF7ACF60E, 0x03880986,
+	0xFA1D042A, 0x0BDB03A7, 0x085408A0, 0x00FAF8FB,
+	0x05E30000, 0xFF06F8FB, 0x0854F760, 0xF42503A7,
+	0xFA1DFBD6, 0xFC780986, 0xF7AC09F2, 0x075AF89A,
+	0x05E3FA1D, 0xF8A60766, 0xF7AC09F2, 0x0388F67A,
+	0xFA1DFBD6, 0x0BDBFC59, 0x0854F760, 0x00FA0705,
+	0x05E30000, 0xFF060705, 0x085408A0, 0xF425FC59,
+	0xFA1D042A, 0xFC78F67A, 0xF7ACF60E, 0x075A0766,
+	0x05E305E3, 0xF8A6F89A, 0xF7ACF60E, 0x03880986,
+	0xFA1D042A, 0x0BDB03A7, 0x085408A0, 0x00FAF8FB,
+	0x05E30000, 0xFF06F8FB, 0x0854F760, 0xF42503A7,
+	0xFA1DFBD6, 0xFC780986, 0xF7AC09F2, 0x075AF89A,
+	0x05E3FA1D, 0xF8A60766, 0xF7AC09F2, 0x0388F67A,
+	0xFA1DFBD6, 0x0BDBFC59, 0x0854F760, 0x00FA0705,
+	0xFA58FA58, 0xF8F0FE00, 0x0448073D, 0xFDC9FE46,
+	0xF9910258, 0x089D0407, 0xFD5CF71A, 0x02AFFDE0,
+	0x083E0496, 0xFF5A0740, 0xFF7AFD97, 0x00FE01F1,
+	0x0009082E, 0xFA94FF75, 0xFECDF8EA, 0xFFB0F693,
+	0xFD2CFA58, 0x0433FF16, 0xFBA405DD, 0xFA610341,
+	0x06A606CB, 0x0039FD2D, 0x0677FA97, 0x01FA05E0,
+	0xF896003E, 0x075A068B, 0x012CFC3E, 0xFA23F98D,
+	0xFC7CFD43, 0xFF90FC0D, 0x01C10982, 0x00C601D6,
+	0xFD2CFD2C, 0x01D600C6, 0x098201C1, 0xFC0DFF90,
+	0xFD43FC7C, 0xF98DFA23, 0xFC3E012C, 0x068B075A,
+	0x003EF896, 0x05E001FA, 0xFA970677, 0xFD2D0039,
+	0x06CB06A6, 0x0341FA61, 0x05DDFBA4, 0xFF160433,
+	0xFA58FD2C, 0xF693FFB0, 0xF8EAFECD, 0xFF75FA94,
+	0x082E0009, 0x01F100FE, 0xFD97FF7A, 0x0740FF5A,
+	0x0496083E, 0xFDE002AF, 0xF71AFD5C, 0x0407089D,
+	0x0258F991, 0xFE46FDC9, 0x073D0448, 0xFE00F8F0,
+	0xFD2CFD2C, 0xFCE00500, 0xFC09FDDC, 0xFE680157,
+	0x04C70571, 0xFC3AFF21, 0xFCD70228, 0x056D0277,
+	0x0200FE00, 0x0022F927, 0xFE3C032B, 0xFC44FF3C,
+	0x03E9FBDB, 0x04570313, 0x04C9FF5C, 0x000D03B8,
+	0xFA580000, 0xFBE900D2, 0xF9D0FE0B, 0x0125FDF9,
+	0x042501BF, 0x0328FA2B, 0xFFA902F0, 0xFA250157,
+	0x0200FE00, 0x03740438, 0xFF0405FD, 0x030CFE52,
+	0x0037FB39, 0xFF6904C5, 0x04F8FD23, 0xFD31FC1B,
+	0xFD2CFD2C, 0xFC1BFD31, 0xFD2304F8, 0x04C5FF69,
+	0xFB390037, 0xFE52030C, 0x05FDFF04, 0x04380374,
+	0xFE000200, 0x0157FA25, 0x02F0FFA9, 0xFA2B0328,
+	0x01BF0425, 0xFDF90125, 0xFE0BF9D0, 0x00D2FBE9,
+	0x0000FA58, 0x03B8000D, 0xFF5C04C9, 0x03130457,
+	0xFBDB03E9, 0xFF3CFC44, 0x032BFE3C, 0xF9270022,
+	0xFE000200, 0x0277056D, 0x0228FCD7, 0xFF21FC3A,
+	0x057104C7, 0x0157FE68, 0xFDDCFC09, 0x0500FCE0,
+	0xFD2CFD2C, 0x0500FCE0, 0xFDDCFC09, 0x0157FE68,
+	0x057104C7, 0xFF21FC3A, 0x0228FCD7, 0x0277056D,
+	0xFE000200, 0xF9270022, 0x032BFE3C, 0xFF3CFC44,
+	0xFBDB03E9, 0x03130457, 0xFF5C04C9, 0x03B8000D,
+	0x0000FA58, 0x00D2FBE9, 0xFE0BF9D0, 0xFDF90125,
+	0x01BF0425, 0xFA2B0328, 0x02F0FFA9, 0x0157FA25,
+	0xFE000200, 0x04380374, 0x05FDFF04, 0xFE52030C,
+	0xFB390037, 0x04C5FF69, 0xFD2304F8, 0xFC1BFD31,
+	0xFD2CFD2C, 0xFD31FC1B, 0x04F8FD23, 0xFF6904C5,
+	0x0037FB39, 0x030CFE52, 0xFF0405FD, 0x03740438,
+	0x0200FE00, 0xFA250157, 0xFFA902F0, 0x0328FA2B,
+	0x042501BF, 0x0125FDF9, 0xF9D0FE0B, 0xFBE900D2,
+	0xFA580000, 0x000D03B8, 0x04C9FF5C, 0x04570313,
+	0x03E9FBDB, 0xFC44FF3C, 0xFE3C032B, 0x0022F927,
+	0x0200FE00, 0x056D0277, 0xFCD70228, 0xFC3AFF21,
+	0x04C70571, 0xFE680157, 0xFC09FDDC, 0xFCE00500,
+	0x05A80000, 0xFF1006BE, 0x0800084A, 0xF49CFC7E,
+	0xFA580400, 0xFC9CF6DA, 0xF800F672, 0x0710071C,
+	0x05A805A8, 0xF8F0F8E4, 0xF800F672, 0x03640926,
+	0xFA580400, 0x0B640382, 0x0800084A, 0x00F0F942,
+	0x05A80000, 0xFF10F942, 0x0800F7B6, 0xF49C0382,
+	0xFA58FC00, 0xFC9C0926, 0xF800098E, 0x0710F8E4,
+	0x05A8FA58, 0xF8F0071C, 0xF800098E, 0x0364F6DA,
+	0xFA58FC00, 0x0B64FC7E, 0x0800F7B6, 0x00F006BE,
+	0x05A80000, 0xFF1006BE, 0x0800084A, 0xF49CFC7E,
+	0xFA580400, 0xFC9CF6DA, 0xF800F672, 0x0710071C,
+	0x05A805A8, 0xF8F0F8E4, 0xF800F672, 0x03640926,
+	0xFA580400, 0x0B640382, 0x0800084A, 0x00F0F942,
+	0x05A80000, 0xFF10F942, 0x0800F7B6, 0xF49C0382,
+	0xFA58FC00, 0xFC9C0926, 0xF800098E, 0x0710F8E4,
+	0x05A8FA58, 0xF8F0071C, 0xF800098E, 0x0364F6DA,
+	0xFA58FC00, 0x0B64FC7E, 0x0800F7B6, 0x00F006BE,
+};
+
+const u32 b43_ntab_tmap[] = {
+	0x8A88AA80, 0x8AAAAA8A, 0x8A8A8AA8, 0x00000888,
+	0x88000000, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0xF1111110, 0x11111111, 0x11F11111, 0x00000111,
+	0x11000000, 0x1111F111, 0x11111111, 0x111111F1,
+	0x8A88AA80, 0x8AAAAA8A, 0x8A8A8AA8, 0x000AA888,
+	0x88880000, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0xA1111110, 0x11111111, 0x11C11111, 0x00000111,
+	0x11000000, 0x1111A111, 0x11111111, 0x111111A1,
+	0xA2222220, 0x22222222, 0x22C22222, 0x00000222,
+	0x22000000, 0x2222A222, 0x22222222, 0x222222A2,
+	0xF1111110, 0x11111111, 0x11F11111, 0x00011111,
+	0x11110000, 0x1111F111, 0x11111111, 0x111111F1,
+	0xA8AA88A0, 0xA88888A8, 0xA8A8A88A, 0x00088AAA,
+	0xAAAA0000, 0xA8A8AA88, 0xA88AAAAA, 0xAAAA8A8A,
+	0xAAA8AAA0, 0x8AAA8AAA, 0xAA8A8A8A, 0x000AAA88,
+	0x8AAA0000, 0xAAA8A888, 0x8AA88A8A, 0x8A88A888,
+	0x08080A00, 0x0A08080A, 0x080A0A08, 0x00080808,
+	0x080A0000, 0x080A0808, 0x080A0808, 0x0A0A0A08,
+	0xA0A0A0A0, 0x80A0A080, 0x8080A0A0, 0x00008080,
+	0x80A00000, 0x80A080A0, 0xA080A0A0, 0x8080A0A0,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x99999000, 0x9B9B99BB, 0x9BB99999, 0x9999B9B9,
+	0x9B99BB90, 0x9BBBBB9B, 0x9B9B9BB9, 0x00000999,
+	0x88000000, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0x8A88AA80, 0x8AAAAA8A, 0x8A8A8AA8, 0x00AAA888,
+	0x22000000, 0x2222B222, 0x22222222, 0x222222B2,
+	0xB2222220, 0x22222222, 0x22D22222, 0x00000222,
+	0x11000000, 0x1111A111, 0x11111111, 0x111111A1,
+	0xA1111110, 0x11111111, 0x11C11111, 0x00000111,
+	0x33000000, 0x3333B333, 0x33333333, 0x333333B3,
+	0xB3333330, 0x33333333, 0x33D33333, 0x00000333,
+	0x22000000, 0x2222A222, 0x22222222, 0x222222A2,
+	0xA2222220, 0x22222222, 0x22C22222, 0x00000222,
+	0x99B99B00, 0x9B9B99BB, 0x9BB99999, 0x9999B9B9,
+	0x9B99BB99, 0x9BBBBB9B, 0x9B9B9BB9, 0x00000999,
+	0x88000000, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0x8A88AA88, 0x8AAAAA8A, 0x8A8A8AA8, 0x08AAA888,
+	0x22222200, 0x2222F222, 0x22222222, 0x222222F2,
+	0x22222222, 0x22222222, 0x22F22222, 0x00000222,
+	0x11000000, 0x1111F111, 0x11111111, 0x11111111,
+	0xF1111111, 0x11111111, 0x11F11111, 0x01111111,
+	0xBB9BB900, 0xB9B9BB99, 0xB99BBBBB, 0xBBBB9B9B,
+	0xB9BB99BB, 0xB99999B9, 0xB9B9B99B, 0x00000BBB,
+	0xAA000000, 0xA8A8AA88, 0xA88AAAAA, 0xAAAA8A8A,
+	0xA8AA88AA, 0xA88888A8, 0xA8A8A88A, 0x0A888AAA,
+	0xAA000000, 0xA8A8AA88, 0xA88AAAAA, 0xAAAA8A8A,
+	0xA8AA88A0, 0xA88888A8, 0xA8A8A88A, 0x00000AAA,
+	0x88000000, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0x8A88AA80, 0x8AAAAA8A, 0x8A8A8AA8, 0x00000888,
+	0xBBBBBB00, 0x999BBBBB, 0x9BB99B9B, 0xB9B9B9BB,
+	0xB9B99BBB, 0xB9B9B9BB, 0xB9BB9B99, 0x00000999,
+	0x8A000000, 0xAA88A888, 0xA88888AA, 0xA88A8A88,
+	0xA88AA88A, 0x88A8AAAA, 0xA8AA8AAA, 0x0888A88A,
+	0x0B0B0B00, 0x090B0B0B, 0x0B090B0B, 0x0909090B,
+	0x09090B0B, 0x09090B0B, 0x09090B09, 0x00000909,
+	0x0A000000, 0x0A080808, 0x080A080A, 0x080A0A08,
+	0x080A080A, 0x0808080A, 0x0A0A0A08, 0x0808080A,
+	0xB0B0B000, 0x9090B0B0, 0x90B09090, 0xB0B0B090,
+	0xB0B090B0, 0x90B0B0B0, 0xB0B09090, 0x00000090,
+	0x80000000, 0xA080A080, 0xA08080A0, 0xA0808080,
+	0xA080A080, 0x80A0A0A0, 0xA0A080A0, 0x00A0A0A0,
+	0x22000000, 0x2222F222, 0x22222222, 0x222222F2,
+	0xF2222220, 0x22222222, 0x22F22222, 0x00000222,
+	0x11000000, 0x1111F111, 0x11111111, 0x111111F1,
+	0xF1111110, 0x11111111, 0x11F11111, 0x00000111,
+	0x33000000, 0x3333F333, 0x33333333, 0x333333F3,
+	0xF3333330, 0x33333333, 0x33F33333, 0x00000333,
+	0x22000000, 0x2222F222, 0x22222222, 0x222222F2,
+	0xF2222220, 0x22222222, 0x22F22222, 0x00000222,
+	0x99000000, 0x9B9B99BB, 0x9BB99999, 0x9999B9B9,
+	0x9B99BB90, 0x9BBBBB9B, 0x9B9B9BB9, 0x00000999,
+	0x88000000, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0x8A88AA80, 0x8AAAAA8A, 0x8A8A8AA8, 0x00000888,
+	0x88888000, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0x8A88AA80, 0x8AAAAA8A, 0x8A8A8AA8, 0x00000888,
+	0x88000000, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0x8A88AA80, 0x8AAAAA8A, 0x8A8A8AA8, 0x00AAA888,
+	0x88A88A00, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0x8A88AA88, 0x8AAAAA8A, 0x8A8A8AA8, 0x00000888,
+	0x88000000, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0x8A88AA88, 0x8AAAAA8A, 0x8A8A8AA8, 0x08AAA888,
+	0x11000000, 0x1111A111, 0x11111111, 0x111111A1,
+	0xA1111110, 0x11111111, 0x11C11111, 0x00000111,
+	0x11000000, 0x1111A111, 0x11111111, 0x111111A1,
+	0xA1111110, 0x11111111, 0x11C11111, 0x00000111,
+	0x88000000, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0x8A88AA80, 0x8AAAAA8A, 0x8A8A8AA8, 0x00000888,
+	0x88000000, 0x8A8A88AA, 0x8AA88888, 0x8888A8A8,
+	0x8A88AA80, 0x8AAAAA8A, 0x8A8A8AA8, 0x00000888,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+};
+
+static inline void assert_ntab_array_sizes(void)
+{
+#undef check
+#define check(table, size)	\
+	BUILD_BUG_ON(ARRAY_SIZE(b43_ntab_##table) != B43_NTAB_##size##_SIZE)
+
+	check(adjustpower0, C0_ADJPLT);
+	check(adjustpower1, C1_ADJPLT);
+	check(bdi, BDI);
+	check(channelest, CHANEST);
+	check(estimatepowerlt0, C0_ESTPLT);
+	check(estimatepowerlt1, C1_ESTPLT);
+	check(framelookup, FRAMELT);
+	check(framestruct, FRAMESTRUCT);
+	check(gainctl0, C0_GAINCTL);
+	check(gainctl1, C1_GAINCTL);
+	check(intlevel, INTLEVEL);
+	check(iqlt0, C0_IQLT);
+	check(iqlt1, C1_IQLT);
+	check(loftlt0, C0_LOFEEDTH);
+	check(loftlt1, C1_LOFEEDTH);
+	check(mcs, MCS);
+	check(noisevar10, NOISEVAR10);
+	check(noisevar11, NOISEVAR11);
+	check(pilot, PILOT);
+	check(pilotlt, PILOTLT);
+	check(tdi20a0, TDI20A0);
+	check(tdi20a1, TDI20A1);
+	check(tdi40a0, TDI40A0);
+	check(tdi40a1, TDI40A1);
+	check(tdtrn, TDTRN);
+	check(tmap, TMAP);
+
+#undef check
+}
+
+void b43_ntab_write(struct b43_wldev *dev, u32 offset, u32 value)
+{
+	u32 type;
+
+	type = offset & B43_NTAB_TYPEMASK;
+	offset &= 0xFFFF;
+
+	switch (type) {
+	case B43_NTAB_8BIT:
+		B43_WARN_ON(value & ~0xFF);
+		b43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset);
+		b43_phy_write(dev, B43_NPHY_TABLE_DATALO, value);
+		break;
+	case B43_NTAB_16BIT:
+		B43_WARN_ON(value & ~0xFFFF);
+		b43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset);
+		b43_phy_write(dev, B43_NPHY_TABLE_DATALO, value);
+		break;
+	case B43_NTAB_32BIT:
+		b43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset);
+		b43_phy_write(dev, B43_NPHY_TABLE_DATAHI, value >> 16);
+		b43_phy_write(dev, B43_NPHY_TABLE_DATALO, value & 0xFFFF);
+		break;
+	default:
+		B43_WARN_ON(1);
+	}
+
+	return;
+
+	/* Some compiletime assertions... */
+	assert_ntab_array_sizes();
+}
Index: wireless-2.6/drivers/net/wireless/b43/tables_nphy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/tables_nphy.h	2008-01-15 00:23:51.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/tables_nphy.h	2008-01-16 02:02:17.000000000 +0100
@@ -57,7 +57,103 @@ void b2055_upload_inittab(struct b43_wld
 /* Get the NPHY Channel Switch Table entry for a channel number.
  * Returns NULL on failure to find an entry. */
 const struct b43_nphy_channeltab_entry *
 b43_nphy_get_chantabent(struct b43_wldev *dev, u8 channel);
 
 
+/* The N-PHY tables. */
+
+#define B43_NTAB_TYPEMASK		0xF0000000
+#define B43_NTAB_8BIT			0x10000000
+#define B43_NTAB_16BIT			0x20000000
+#define B43_NTAB_32BIT			0x30000000
+#define B43_NTAB8(table, offset)	(((table) << 10) | (offset) | B43_NTAB_8BIT)
+#define B43_NTAB16(table, offset)	(((table) << 10) | (offset) | B43_NTAB_16BIT)
+#define B43_NTAB32(table, offset)	(((table) << 10) | (offset) | B43_NTAB_32BIT)
+
+/* Static N-PHY tables */
+#define B43_NTAB_FRAMESTRUCT		B43_NTAB32(0x0A, 0x000) /* Frame Struct Table */
+#define B43_NTAB_FRAMESTRUCT_SIZE	832
+#define B43_NTAB_FRAMELT		B43_NTAB8 (0x18, 0x000) /* Frame Lookup Table */
+#define B43_NTAB_FRAMELT_SIZE		32
+#define B43_NTAB_TMAP			B43_NTAB32(0x0C, 0x000) /* T Map Table */
+#define B43_NTAB_TMAP_SIZE		448
+#define B43_NTAB_TDTRN			B43_NTAB32(0x0E, 0x000) /* TDTRN Table */
+#define B43_NTAB_TDTRN_SIZE		704
+#define B43_NTAB_INTLEVEL		B43_NTAB32(0x0D, 0x000) /* Int Level Table */
+#define B43_NTAB_INTLEVEL_SIZE		7
+#define B43_NTAB_PILOT			B43_NTAB16(0x0B, 0x000) /* Pilot Table */
+#define B43_NTAB_PILOT_SIZE		88
+#define B43_NTAB_PILOTLT		B43_NTAB32(0x14, 0x000) /* Pilot Lookup Table */
+#define B43_NTAB_PILOTLT_SIZE		6
+#define B43_NTAB_TDI20A0		B43_NTAB32(0x13, 0x080) /* TDI Table 20 Antenna 0 */
+#define B43_NTAB_TDI20A0_SIZE		55
+#define B43_NTAB_TDI20A1		B43_NTAB32(0x13, 0x100) /* TDI Table 20 Antenna 1 */
+#define B43_NTAB_TDI20A1_SIZE		55
+#define B43_NTAB_TDI40A0		B43_NTAB32(0x13, 0x280) /* TDI Table 40 Antenna 0 */
+#define B43_NTAB_TDI40A0_SIZE		110
+#define B43_NTAB_TDI40A1		B43_NTAB32(0x13, 0x300) /* TDI Table 40 Antenna 1 */
+#define B43_NTAB_TDI40A1_SIZE		110
+#define B43_NTAB_BDI			B43_NTAB16(0x15, 0x000) /* BDI Table */
+#define B43_NTAB_BDI_SIZE		6
+#define B43_NTAB_CHANEST		B43_NTAB32(0x16, 0x000) /* Channel Estimate Table */
+#define B43_NTAB_CHANEST_SIZE		96
+#define B43_NTAB_MCS			B43_NTAB8 (0x12, 0x000) /* MCS Table */
+#define B43_NTAB_MCS_SIZE		128
+
+/* Volatile N-PHY tables */
+#define B43_NTAB_NOISEVAR10		B43_NTAB32(0x10, 0x000) /* Noise Var Table 10 */
+#define B43_NTAB_NOISEVAR10_SIZE	256
+#define B43_NTAB_NOISEVAR11		B43_NTAB32(0x10, 0x080) /* Noise Var Table 11 */
+#define B43_NTAB_NOISEVAR11_SIZE	256
+#define B43_NTAB_C0_ESTPLT		B43_NTAB8 (0x1A, 0x000) /* Estimate Power Lookup Table Core 0 */
+#define B43_NTAB_C0_ESTPLT_SIZE		64
+#define B43_NTAB_C1_ESTPLT		B43_NTAB8 (0x1B, 0x000) /* Estimate Power Lookup Table Core 1 */
+#define B43_NTAB_C1_ESTPLT_SIZE		64
+#define B43_NTAB_C0_ADJPLT		B43_NTAB8 (0x1A, 0x040) /* Adjust Power Lookup Table Core 0 */
+#define B43_NTAB_C0_ADJPLT_SIZE		128
+#define B43_NTAB_C1_ADJPLT		B43_NTAB8 (0x1B, 0x040) /* Adjust Power Lookup Table Core 1 */
+#define B43_NTAB_C1_ADJPLT_SIZE		128
+#define B43_NTAB_C0_GAINCTL		B43_NTAB32(0x1A, 0x0C0) /* Gain Control Lookup Table Core 0 */
+#define B43_NTAB_C0_GAINCTL_SIZE	128
+#define B43_NTAB_C1_GAINCTL		B43_NTAB32(0x1B, 0x0C0) /* Gain Control Lookup Table Core 1 */
+#define B43_NTAB_C1_GAINCTL_SIZE	128
+#define B43_NTAB_C0_IQLT		B43_NTAB32(0x1A, 0x140) /* IQ Lookup Table Core 0 */
+#define B43_NTAB_C0_IQLT_SIZE		128
+#define B43_NTAB_C1_IQLT		B43_NTAB32(0x1B, 0x140) /* IQ Lookup Table Core 1 */
+#define B43_NTAB_C1_IQLT_SIZE		128
+#define B43_NTAB_C0_LOFEEDTH		B43_NTAB16(0x1A, 0x1C0) /* Local Oscillator Feed Through Lookup Table Core 0 */
+#define B43_NTAB_C0_LOFEEDTH_SIZE	128
+#define B43_NTAB_C1_LOFEEDTH		B43_NTAB16(0x1B, 0x1C0) /* Local Oscillator Feed Through Lookup Table Core 1 */
+#define B43_NTAB_C1_LOFEEDTH_SIZE	128
+
+void b43_ntab_write(struct b43_wldev *dev, u32 offset, u32 value);
+
+extern const u8 b43_ntab_adjustpower0[];
+extern const u8 b43_ntab_adjustpower1[];
+extern const u16 b43_ntab_bdi[];
+extern const u32 b43_ntab_channelest[];
+extern const u8 b43_ntab_estimatepowerlt0[];
+extern const u8 b43_ntab_estimatepowerlt1[];
+extern const u8 b43_ntab_framelookup[];
+extern const u32 b43_ntab_framestruct[];
+extern const u32 b43_ntab_gainctl0[];
+extern const u32 b43_ntab_gainctl1[];
+extern const u32 b43_ntab_intlevel[];
+extern const u32 b43_ntab_iqlt0[];
+extern const u32 b43_ntab_iqlt1[];
+extern const u16 b43_ntab_loftlt0[];
+extern const u16 b43_ntab_loftlt1[];
+extern const u8 b43_ntab_mcs[];
+extern const u32 b43_ntab_noisevar10[];
+extern const u32 b43_ntab_noisevar11[];
+extern const u16 b43_ntab_pilot[];
+extern const u32 b43_ntab_pilotlt[];
+extern const u32 b43_ntab_tdi20a0[];
+extern const u32 b43_ntab_tdi20a1[];
+extern const u32 b43_ntab_tdi40a0[];
+extern const u32 b43_ntab_tdi40a1[];
+extern const u32 b43_ntab_tdtrn[];
+extern const u32 b43_ntab_tmap[];
+
+
 #endif /* B43_TABLES_NPHY_H_ */


From mb at bu3sch.de  Wed Jan 16 12:02:08 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 16 Jan 2008 12:02:08 +0100
Subject: [PATCH 2.6.24] b43: Reject new firmware early
Message-ID: <200801161202.09122.mb@bu3sch.de>

We must reject new incompatible firmware early to avoid
running into strange transmission failures.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, this must _only_ be applied to 2.6.24.
2.6.25 does have actual support for the new firmware.



Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-16 11:33:55.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-16 11:44:06.000000000 +0100
@@ -1800,6 +1800,18 @@ static int b43_upload_microcode(struct b
 		err = -EOPNOTSUPP;
 		goto out;
 	}
+	if (fwrev > 351) {
+		b43err(dev->wl, "YOUR FIRMWARE IS TOO NEW. Please downgrade your "
+		       "firmware.\n");
+		b43err(dev->wl, "Use this firmware tarball: "
+		       "http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2\n");
+		b43err(dev->wl, "Use this b43-fwcutter tarball: "
+		       "http://bu3sch.de/b43/fwcutter/b43-fwcutter-009.tar.bz2\n");
+		b43err(dev->wl, "Read, understand and _do_ what this message says, please.\n");
+		b43_write32(dev, B43_MMIO_MACCTL, 0);
+		err = -EOPNOTSUPP;
+		goto out;
+	}
 	b43dbg(dev->wl, "Loading firmware version %u.%u "
 	       "(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\n",
 	       fwrev, fwpatch,

-- 
Greetings Michael.


From johannes at sipsolutions.net  Wed Jan 16 17:03:50 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 16 Jan 2008 17:03:50 +0100
Subject: issues with bcm4306
In-Reply-To: <20080116010817.GA18042@gmail.com>
	(sfid-20080116_011611_612030_132D38C9)
References: <20080116010817.GA18042@gmail.com>
	(sfid-20080116_011611_612030_132D38C9)
Message-ID: <1200499430.8708.6.camel@johannes.berg>

Hi,

> 1. Lights stay off on the card, even when it's working and associated.

Weird. Especially when the 4318 works. Maybe the SPROM is programmed
differently or something.

> 2. There seems to be some timing issue with a Netgear WGR614 access point
>    (but no others I've tried).  If I login with gnome, the network-manager
>    tries to connect automatically to the AP as it knows it from previous
>    sessions.  This fails unless I have first removed the memory of this
>    ESSID from gconf.   
> 	rm -r .gconf/system/networking/wireless/networks/<ESSID>/
>    I can then login, select the ESSID from the list, type in the passphrase
>    (it's WPA) and it connects fine.
> 
> Attached is a dmesg from the current running system.  I booted, logged in,
> got the failure as in [2] above, logged out, reloaded the b43 module,
> removed the gconf info, then logged in and successfully joined up to the
> access point.

There's no indication in your log that NM even tries to associate to the
network before you reloaded the module so that looks more like a bug in
NM or so.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20080116/882de3f4/attachment.pgp>

From larry.finger at lwfinger.net  Wed Jan 16 17:45:57 2008
From: larry.finger at lwfinger.net (Larry Finger)
Date: Wed, 16 Jan 2008 09:45:57 -0700
Subject: issues with bcm4306
In-Reply-To: <20080116010817.GA18042@gmail.com>
References: <20080116010817.GA18042@gmail.com>
Message-ID: <478E34C5.3020005@lwfinger.net>

Gavin McCullagh wrote:
> Hi,
> 
> I'm the proud owner of the following Belkin f5d7011 cardbus card:
> 
> 02:00.0 Network controller [0280]: Broadcom Corporation BCM4306 802.11b/g Wireless LAN Controller [14e4:4320] (rev 03)
>         Subsystem: Belkin F5D7011 54g+ Wireless Network card [1799:7011]
>         Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
>         Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR-
>         Latency: 64
>         Interrupt: pin A routed to IRQ 10
>         Region 0: Memory at 24000000 (32-bit, non-prefetchable) [size=8K]
> 
> which broadly speaking, works reasonably well.  I just updated to the
> latest wireless-2.6 kernel and have a couple of issues to report.
> 
> 1. Lights stay off on the card, even when it's working and associated.
> 
> 2. There seems to be some timing issue with a Netgear WGR614 access point
>    (but no others I've tried).  If I login with gnome, the network-manager
>    tries to connect automatically to the AP as it knows it from previous
>    sessions.  This fails unless I have first removed the memory of this
>    ESSID from gconf.   
> 	rm -r .gconf/system/networking/wireless/networks/<ESSID>/
>    I can then login, select the ESSID from the list, type in the passphrase
>    (it's WPA) and it connects fine.
> 
> Attached is a dmesg from the current running system.  I booted, logged in,
> got the failure as in [2] above, logged out, reloaded the b43 module,
> removed the gconf info, then logged in and successfully joined up to the
> access point.
> 
> I think both of the above have been mentioned on this list before, but I
> thought I should report them.  If someone would like me to debug this
> further, I am open to instructions.
> 
> I also own a bcm4318 Airforce One card which is slightly less stable
> (though its lights do work!) so I might send a separate email regarding
> that.  
> 
> Thanks for all the code and please let me know if I can be of help giving
> up debug info for these cards.

Please check that modules rfkill and rfkill-input are configured and loaded on your system. In your 
dmesg output, you are missing lines that look like

Registered led device: b43-phy0:tx
Registered led device: b43-phy0:rx
Registered led device: b43-phy0:radio

Are you running the panel applet? On my KDE system, I can right click on that icon in the 
lower-right hand corner, and select from any of the AP's in my vicinity.

Larry


From gmccullagh at gmail.com  Wed Jan 16 17:42:28 2008
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Wed, 16 Jan 2008 16:42:28 +0000
Subject: issues with bcm4306
In-Reply-To: <1200499430.8708.6.camel@johannes.berg>
References: <20080116010817.GA18042@gmail.com>
	<1200499430.8708.6.camel@johannes.berg>
Message-ID: <20080116164228.GE2587@gmail.com>

Hi,

On Wed, 16 Jan 2008, Johannes Berg wrote:

> > 1. Lights stay off on the card, even when it's working and associated.
> 
> Weird. Especially when the 4318 works. Maybe the SPROM is programmed
> differently or something.

I'm not that familiar yet with the code, is there somewhere I should be
looking to try to understand this.  I've done some kernel coding before,
though not on drivers.

> There's no indication in your log that NM even tries to associate to the
> network before you reloaded the module so that looks more like a bug in
> NM or so.

I'd go along with that except that it happens on this one AP and not on the
number of others I regularly use.  For that reason I guessed an issue
between the AP and the card.

Is there some more verbose info I can get my hands on?

Gavin



From johannes at sipsolutions.net  Wed Jan 16 17:51:55 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Wed, 16 Jan 2008 17:51:55 +0100
Subject: issues with bcm4306
In-Reply-To: <20080116164228.GE2587@gmail.com>
	(sfid-20080116_165015_167446_7A01BCF9)
References: <20080116010817.GA18042@gmail.com>
	<1200499430.8708.6.camel@johannes.berg>
	<20080116164228.GE2587@gmail.com>
	(sfid-20080116_165015_167446_7A01BCF9)
Message-ID: <1200502315.8708.11.camel@johannes.berg>


> I'd go along with that except that it happens on this one AP and not on the
> number of others I regularly use.  For that reason I guessed an issue
> between the AP and the card.
> 
> Is there some more verbose info I can get my hands on?

Hmm. Maybe run 'iwevent | tee /tmp/iweventlog' from a console while
logging in.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20080116/2ab313d2/attachment.pgp>

From gmccullagh at gmail.com  Wed Jan 16 17:58:26 2008
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Wed, 16 Jan 2008 16:58:26 +0000
Subject: issues with bcm4306
In-Reply-To: <478E34C5.3020005@lwfinger.net>
References: <20080116010817.GA18042@gmail.com> <478E34C5.3020005@lwfinger.net>
Message-ID: <20080116165826.GF2587@gmail.com>

Hi,

On Wed, 16 Jan 2008, Larry Finger wrote:

> Please check that modules rfkill and rfkill-input are configured and loaded 
> on your system. In your dmesg output, you are missing lines that look like
> 
> Registered led device: b43-phy0:tx
> Registered led device: b43-phy0:rx
> Registered led device: b43-phy0:radio

I'll check this properly when I'm at the access point in question, though
when I plug in the card here (different location), rfkill was already
loaded (I have b43 in /etc/modules), rfkill-input loaded automatically and
I got straight on.

	dmesg | grep " led " 

produces no output whatsoever.

> Are you running the panel applet? On my KDE system, I can right click on 
> that icon in the lower-right hand corner, and select from any of the AP's 
> in my vicinity.

I'm using gnome, but I am using the gnome-network-manager panel applet,
yes.  I also get a list of ESSIDs and pick from them.  However, if NM has
knowledge of a network it has previously been on it seems to try and join
that one on its own initiative.  

When the failure happens (eg if I login and let it jump automatically to
the AP in question), the NM applet swirls for a few seconds and then gives
up, dropping to the little red exclamation mark symbol saying it has no
network.  If I then click to pick an ESSID, that ESSID is already selected,
but trying again produces the same brief swirl before it gives up.

Gavin



From gmccullagh at gmail.com  Wed Jan 16 22:49:57 2008
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Wed, 16 Jan 2008 21:49:57 +0000
Subject: issues with bcm4306
In-Reply-To: <20080116165826.GF2587@gmail.com>
References: <20080116010817.GA18042@gmail.com> <478E34C5.3020005@lwfinger.net>
	<20080116165826.GF2587@gmail.com>
Message-ID: <20080116214957.GC10754@gmail.com>

Hi,

On Wed, 16 Jan 2008, Gavin McCullagh wrote:

> > Registered led device: b43-phy0:tx
> > Registered led device: b43-phy0:rx
> > Registered led device: b43-phy0:radio
> 
> I'll check this properly when I'm at the access point in question, 

Sorry, confused myself here as I rushed.  The LEDs fail regardless of AP so
the information below is the response.

> when I plug in the card here (different location), rfkill was already
> loaded (I have b43 in /etc/modules), rfkill-input loaded automatically and
> I got straight on.
> 
>         dmesg | grep " led "
> 
> produces no output whatsoever.

If you need more info on this let me know.

Gavin



From mb at bu3sch.de  Wed Jan 16 22:55:53 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 16 Jan 2008 22:55:53 +0100
Subject: issues with bcm4306
In-Reply-To: <20080116165826.GF2587@gmail.com>
References: <20080116010817.GA18042@gmail.com> <478E34C5.3020005@lwfinger.net>
	<20080116165826.GF2587@gmail.com>
Message-ID: <200801162255.53669.mb@bu3sch.de>

On Wednesday 16 January 2008 17:58:26 Gavin McCullagh wrote:
> Hi,
> 
> On Wed, 16 Jan 2008, Larry Finger wrote:
> 
> > Please check that modules rfkill and rfkill-input are configured and loaded 
> > on your system. In your dmesg output, you are missing lines that look like
> > 
> > Registered led device: b43-phy0:tx
> > Registered led device: b43-phy0:rx
> > Registered led device: b43-phy0:radio
> 
> I'll check this properly when I'm at the access point in question, though
> when I plug in the card here (different location), rfkill was already
> loaded (I have b43 in /etc/modules), rfkill-input loaded automatically and
> I got straight on.
> 
> 	dmesg | grep " led " 
> 
> produces no output whatsoever.

Can you please post the SPROM data?
$> cat $(find /sys -name ssb_sprom)


-- 
Greetings Michael.


From gmccullagh at gmail.com  Wed Jan 16 23:00:09 2008
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Wed, 16 Jan 2008 22:00:09 +0000
Subject: issues with bcm4306
In-Reply-To: <200801162255.53669.mb@bu3sch.de>
References: <20080116010817.GA18042@gmail.com> <478E34C5.3020005@lwfinger.net>
	<20080116165826.GF2587@gmail.com> <200801162255.53669.mb@bu3sch.de>
Message-ID: <20080116220009.GD10754@gmail.com>

Hi,

On Wed, 16 Jan 2008, Michael Buesch wrote:

> > 	dmesg | grep " led " 
> > 
> > produces no output whatsoever.
> 

> Can you please post the SPROM data?
> $> cat $(find /sys -name ssb_sprom)

root at tilly:~# cat $(find /sys -name ssb_sprom)
014000001170991720430080020002000010001881100000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF11009250B8FDFFFFFFFFFFFFFFFFFFFFFFFFFFFF4730531594FA85FEFFFFFFFF4C00FFFFFFFFFFFF3E00490A01FF000010FF00000000023A

Gavin



From mb at bu3sch.de  Wed Jan 16 23:12:37 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 16 Jan 2008 23:12:37 +0100
Subject: issues with bcm4306
In-Reply-To: <20080116220009.GD10754@gmail.com>
References: <20080116010817.GA18042@gmail.com>
	<200801162255.53669.mb@bu3sch.de>
	<20080116220009.GD10754@gmail.com>
Message-ID: <200801162312.37646.mb@bu3sch.de>

On Wednesday 16 January 2008 23:00:09 Gavin McCullagh wrote:
> Hi,
> 
> On Wed, 16 Jan 2008, Michael Buesch wrote:
> 
> > > 	dmesg | grep " led " 
> > > 
> > > produces no output whatsoever.
> > 
> 
> > Can you please post the SPROM data?
> > $> cat $(find /sys -name ssb_sprom)
> 
> root at tilly:~# cat $(find /sys -name ssb_sprom)
> 014000001170991720430080020002000010001881100000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF11009250B8FDFFFFFFFFFFFFFFFFFFFFFFFFFFFF4730531594FA85FEFFFFFFFF4C00FFFFFFFFFFFF3E00490A01FF000010FF00000000023A

So there's no special LEDs information in your SPROM.
That means you must get the messages Larry quoted.

I'm pretty sure that you didn't enable LEDs support
in your kernel. Make sure CONFIG_LEDS_CLASS and CONFIG_MAC80211_LEDS
are enabled. While you are at it also make sure CONFIG_RFKILL,
CONFIG_RFKILL_INPUT and CONFIG_INPUT_POLLDEV are enabled.

-- 
Greetings Michael.


From ftoledo at docksud.com.ar  Thu Jan 17 22:50:11 2008
From: ftoledo at docksud.com.ar (Fernando Toledo)
Date: Thu, 17 Jan 2008 19:50:11 -0200
Subject: testing ad-hoc don't connect (Failed to configure IBSS beacon
	template)
Message-ID: <200801171950.13389.ftoledo@docksud.com.ar>

hi all
i try to connect to another pc in ad-hoc mode
i using b43 module from wireless-dev on (wlan1)
and another pc is linksys wusb54g rev4 (wlan0)
boot pc's are debian testing
in pc 2 (wlan1) have 2.6.22.3-amd64

iwconfig wlan1 mode ad-hoc essid docksud channel 4
ifconfig wlan1 192.168.77.1 up

wlan1     IEEE 802.11g  ESSID:"docksud"  
          Mode:Ad-Hoc  Frequency:2.427 GHz  Cell: F2:37:F0:30:AB:D0   
          Tx-Power=27 dBm   
          Retry min limit:7   RTS thr:off   Fragment thr=2346 B   
          Encryption key:off
          Link Quality:0  Signal level:0  Noise level:0
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

i do scann:
iwlist wlan1 s

wlan1     Scan completed :
          Cell 01 - Address: 06:50:23:CE:FA:00
                    ESSID:"docksud"
                    Mode:Ad-Hoc
                    Channel:4
                    Frequency:2.427 GHz (Channel 4)
                    Quality=95/100  Signal level=-39 dBm  Noise level=-62 dBm
                    Encryption key:off
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s
                              9 Mb/s; 12 Mb/s; 18 Mb/s; 24 Mb/s; 36 Mb/s
                              48 Mb/s; 54 Mb/s
                    Extra:tsf=000000001207f671

i see the other cell.

and the interface on the other machine that is an linksys using rt2500usb have 
the same cell :
root at niniel:~# iwconfig wlan0
wlan0     IEEE 802.11g  ESSID:"docksud"  
          Mode:Ad-Hoc  Frequency:2.427 GHz  Cell: 06:50:23:CE:FA:00   
          Retry min limit:7   RTS thr:off   Fragment thr=2346 B   
          Encryption key:off
          Link Quality:0  Signal level:0  Noise level:0
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

i try to ping and dont get reply's
root at ntbkragnarok:~# ping 192.168.77.2
PING 192.168.77.2 (192.168.77.2) 56(84) bytes of data.
From 192.168.77.1 icmp_seq=2 Destination Host Unreachable
From 192.168.77.1 icmp_seq=3 Destination Host Unreachable
From 192.168.77.1 icmp_seq=4 Destination Host Unreachable



my dmesg (wlan1)
----------
wlan1: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
HW CONFIG: channel=1 freq=2412 phymode=2
HW CONFIG: channel=2 freq=2417 phymode=2
HW CONFIG: channel=3 freq=2422 phymode=2
HW CONFIG: channel=4 freq=2427 phymode=2
HW CONFIG: channel=5 freq=2432 phymode=2
HW CONFIG: channel=6 freq=2437 phymode=2
HW CONFIG: channel=7 freq=2442 phymode=2
HW CONFIG: channel=8 freq=2447 phymode=2
HW CONFIG: channel=9 freq=2452 phymode=2
HW CONFIG: channel=10 freq=2457 phymode=2
HW CONFIG: channel=11 freq=2462 phymode=2
HW CONFIG: channel=4 freq=2427 phymode=2
wlan1: sta_find_ibss (active_ibss=0)
   bssid=0e:46:3e:1e:fa:18 found
   sta_find_ibss: selected 0e:46:3e:1e:fa:18 current f2:37:f0:30:ab:d0
   did not try to join ibss
phy1: Adding new IBSS station 00:12:17:73:13:61 (dev=wlan1)
phy1: Added STA 00:12:17:73:13:61
wlan1: RX ProbeReq SA=00:12:17:73:13:61 DA=ff:ff:ff:ff:ff:ff 
BSSID=ff:ff:ff:ff:ff:ff (tx_last_beacon=1)
wlan1: Sending ProbeResp to 00:12:17:73:13:61
wlan1: RX ProbeReq SA=00:12:17:73:13:61 DA=ff:ff:ff:ff:ff:ff 
BSSID=ff:ff:ff:ff:ff:ff (tx_last_beacon=1)
wlan1: Sending ProbeResp to 00:12:17:73:13:61
wlan1: RX ProbeReq SA=00:12:17:73:13:61 DA=ff:ff:ff:ff:ff:ff 
BSSID=ff:ff:ff:ff:ff:ff (tx_last_beacon=1)
wlan1: Sending ProbeResp to 00:12:17:73:13:61
wlan1: RX ProbeReq SA=00:12:17:73:13:61 DA=ff:ff:ff:ff:ff:ff 
BSSID=ff:ff:ff:ff:ff:ff (tx_last_beacon=1)
wlan1: Sending ProbeResp to 00:12:17:73:13:61
wlan1: RX ProbeReq SA=00:12:17:73:13:61 DA=ff:ff:ff:ff:ff:ff 
BSSID=ff:ff:ff:ff:ff:ff (tx_last_beacon=1)
wlan1: Sending ProbeResp to 00:12:17:73:13:61
wlan1: sta_find_ibss (active_ibss=0)
   bssid=0e:46:3e:1e:fa:18 found
   sta_find_ibss: selected 0e:46:3e:1e:fa:18 current f2:37:f0:30:ab:d0
   did not try to join ibss
wlan1: Trigger new scan to find an IBSS to join
HW CONFIG: channel=1 freq=2412 phymode=2
HW CONFIG: channel=2 freq=2417 phymode=2
HW CONFIG: channel=3 freq=2422 phymode=2
HW CONFIG: channel=4 freq=2427 phymode=2
HW CONFIG: channel=5 freq=2432 phymode=2
HW CONFIG: channel=6 freq=2437 phymode=2
HW CONFIG: channel=7 freq=2442 phymode=2
HW CONFIG: channel=8 freq=2447 phymode=2
HW CONFIG: channel=9 freq=2452 phymode=2
HW CONFIG: channel=10 freq=2457 phymode=2
HW CONFIG: channel=11 freq=2462 phymode=2
HW CONFIG: channel=4 freq=2427 phymode=2
wlan1: sta_find_ibss (active_ibss=0)
   bssid=0e:46:3e:1e:fa:18 found
   sta_find_ibss: selected 0e:46:3e:1e:fa:18 current f2:37:f0:30:ab:d0
   did not try to join ibss
wlan1: Creating new IBSS network, BSSID 0e:e6:8e:61:bd:fd
phy1: Removed STA 00:12:17:73:13:61
HW CONFIG: channel=4 freq=2427 phymode=2
wlan1: Failed to configure IBSS beacon template


the rt2500usb dmegs (wlan0):
-----------------------------------------------
wlan0: Trigger new scan to find an IBSS to join
wlan0: Trigger new scan to find an IBSS to join
wlan0: Trigger new scan to find an IBSS to join
wlan0: Creating new IBSS network, BSSID 06:50:23:ce:fa:00
wlan0: Configured IBSS beacon template based on scan results
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)
wmaster0: Adding new IBSS station 00:14:a5:f5:85:ed (dev=wlan0)
wlan0: expiring inactive STA 00:14:a5:f5:85:ed
wlan0: No active IBSS STAs - trying to scan for other IBSS networks with same 
SSID (merge)

can i forgot some step?
any idea to do more tests?
Thanks!
-- 
Dock Sud BBS
http://www.docksud.com.ar
telnet://bbs.docksud.com.ar
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part.
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20080117/4f0be91c/attachment.pgp>

From mb at bu3sch.de  Fri Jan 18 01:09:25 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 18 Jan 2008 01:09:25 +0100
Subject: [PATCH] b43: Add more N-PHY init code
Message-ID: <200801180109.25938.mb@bu3sch.de>

This also adds lots of TODOs. Oh well. Lots of work. :)

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

For 2.6.25

Index: wireless-2.6/drivers/net/wireless/b43/nphy.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/nphy.c	2008-01-17 00:27:48.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/nphy.c	2008-01-18 00:56:34.000000000 +0100
@@ -23,12 +23,14 @@
 */
 
 #include "b43.h"
 #include "nphy.h"
 #include "tables_nphy.h"
 
+#include <linux/delay.h>
+
 
 void b43_nphy_set_rxantenna(struct b43_wldev *dev, int antenna)
 {//TODO
 }
 
 void b43_nphy_xmitpower(struct b43_wldev *dev)
@@ -185,12 +187,300 @@ void b43_nphy_radio_turn_on(struct b43_w
 void b43_nphy_radio_turn_off(struct b43_wldev *dev)
 {
 	b43_phy_mask(dev, B43_NPHY_RFCTL_CMD,
 		     ~B43_NPHY_RFCTL_CMD_EN);
 }
 
+#define ntab_upload(dev, offset, data) do { \
+		unsigned int i;						\
+		for (i = 0; i < (offset##_SIZE); i++)			\
+			b43_ntab_write(dev, (offset) + i, (data)[i]);	\
+	} while (0)
+
+/* Upload the N-PHY tables. */
+static void b43_nphy_tables_init(struct b43_wldev *dev)
+{
+	/* Static tables */
+	ntab_upload(dev, B43_NTAB_FRAMESTRUCT, b43_ntab_framestruct);
+	ntab_upload(dev, B43_NTAB_FRAMELT, b43_ntab_framelookup);
+	ntab_upload(dev, B43_NTAB_TMAP, b43_ntab_tmap);
+	ntab_upload(dev, B43_NTAB_TDTRN, b43_ntab_tdtrn);
+	ntab_upload(dev, B43_NTAB_INTLEVEL, b43_ntab_intlevel);
+	ntab_upload(dev, B43_NTAB_PILOT, b43_ntab_pilot);
+	ntab_upload(dev, B43_NTAB_PILOTLT, b43_ntab_pilotlt);
+	ntab_upload(dev, B43_NTAB_TDI20A0, b43_ntab_tdi20a0);
+	ntab_upload(dev, B43_NTAB_TDI20A1, b43_ntab_tdi20a1);
+	ntab_upload(dev, B43_NTAB_TDI40A0, b43_ntab_tdi40a0);
+	ntab_upload(dev, B43_NTAB_TDI40A1, b43_ntab_tdi40a1);
+	ntab_upload(dev, B43_NTAB_BDI, b43_ntab_bdi);
+	ntab_upload(dev, B43_NTAB_CHANEST, b43_ntab_channelest);
+	ntab_upload(dev, B43_NTAB_MCS, b43_ntab_mcs);
+
+	/* Volatile tables */
+	ntab_upload(dev, B43_NTAB_NOISEVAR10, b43_ntab_noisevar10);
+	ntab_upload(dev, B43_NTAB_NOISEVAR11, b43_ntab_noisevar11);
+	ntab_upload(dev, B43_NTAB_C0_ESTPLT, b43_ntab_estimatepowerlt0);
+	ntab_upload(dev, B43_NTAB_C1_ESTPLT, b43_ntab_estimatepowerlt1);
+	ntab_upload(dev, B43_NTAB_C0_ADJPLT, b43_ntab_adjustpower0);
+	ntab_upload(dev, B43_NTAB_C1_ADJPLT, b43_ntab_adjustpower1);
+	ntab_upload(dev, B43_NTAB_C0_GAINCTL, b43_ntab_gainctl0);
+	ntab_upload(dev, B43_NTAB_C1_GAINCTL, b43_ntab_gainctl1);
+	ntab_upload(dev, B43_NTAB_C0_IQLT, b43_ntab_iqlt0);
+	ntab_upload(dev, B43_NTAB_C1_IQLT, b43_ntab_iqlt1);
+	ntab_upload(dev, B43_NTAB_C0_LOFEEDTH, b43_ntab_loftlt0);
+	ntab_upload(dev, B43_NTAB_C1_LOFEEDTH, b43_ntab_loftlt1);
+}
+
+static void b43_nphy_workarounds(struct b43_wldev *dev)
+{
+	struct b43_phy *phy = &dev->phy;
+	unsigned int i;
+
+	b43_phy_set(dev, B43_NPHY_IQFLIP,
+		    B43_NPHY_IQFLIP_ADC1 | B43_NPHY_IQFLIP_ADC2);
+	//FIXME the following condition is different in the specs.
+	if (1 /* FIXME band is 2.4GHz */) {
+		b43_phy_set(dev, B43_NPHY_CLASSCTL,
+			    B43_NPHY_CLASSCTL_CCKEN);
+	} else {
+		b43_phy_mask(dev, B43_NPHY_CLASSCTL,
+			     ~B43_NPHY_CLASSCTL_CCKEN);
+	}
+	b43_radio_set(dev, B2055_C1_TX_RF_SPARE, 0x8);
+	b43_phy_write(dev, B43_NPHY_TXFRAMEDELAY, 8);
+
+	/* Fixup some tables */
+	b43_ntab_write(dev, B43_NTAB16(8, 0x00), 0xA);
+	b43_ntab_write(dev, B43_NTAB16(8, 0x10), 0xA);
+	b43_ntab_write(dev, B43_NTAB16(8, 0x02), 0xCDAA);
+	b43_ntab_write(dev, B43_NTAB16(8, 0x12), 0xCDAA);
+	b43_ntab_write(dev, B43_NTAB16(8, 0x08), 0);
+	b43_ntab_write(dev, B43_NTAB16(8, 0x18), 0);
+	b43_ntab_write(dev, B43_NTAB16(8, 0x07), 0x7AAB);
+	b43_ntab_write(dev, B43_NTAB16(8, 0x17), 0x7AAB);
+	b43_ntab_write(dev, B43_NTAB16(8, 0x06), 0x800);
+	b43_ntab_write(dev, B43_NTAB16(8, 0x16), 0x800);
+
+	b43_phy_write(dev, B43_NPHY_RFCTL_LUT_TRSW_LO1, 0x2D8);
+	b43_phy_write(dev, B43_NPHY_RFCTL_LUT_TRSW_UP1, 0x301);
+	b43_phy_write(dev, B43_NPHY_RFCTL_LUT_TRSW_LO2, 0x2D8);
+	b43_phy_write(dev, B43_NPHY_RFCTL_LUT_TRSW_UP2, 0x301);
+
+	//TODO set RF sequence
+
+	/* Set narrowband clip threshold */
+	b43_phy_write(dev, B43_NPHY_C1_NBCLIPTHRES, 66);
+	b43_phy_write(dev, B43_NPHY_C2_NBCLIPTHRES, 66);
+
+	/* Set wideband clip 2 threshold */
+	b43_phy_maskset(dev, B43_NPHY_C1_CLIPWBTHRES,
+			~B43_NPHY_C1_CLIPWBTHRES_CLIP2,
+			21 << B43_NPHY_C1_CLIPWBTHRES_CLIP2_SHIFT);
+	b43_phy_maskset(dev, B43_NPHY_C2_CLIPWBTHRES,
+			~B43_NPHY_C2_CLIPWBTHRES_CLIP2,
+			21 << B43_NPHY_C2_CLIPWBTHRES_CLIP2_SHIFT);
+
+	/* Set Clip 2 detect */
+	b43_phy_set(dev, B43_NPHY_C1_CGAINI,
+		    B43_NPHY_C1_CGAINI_CL2DETECT);
+	b43_phy_set(dev, B43_NPHY_C2_CGAINI,
+		    B43_NPHY_C2_CGAINI_CL2DETECT);
+
+	if (0 /*FIXME*/) {
+		/* Set dwell lengths */
+		b43_phy_write(dev, B43_NPHY_CLIP1_NBDWELL_LEN, 43);
+		b43_phy_write(dev, B43_NPHY_CLIP2_NBDWELL_LEN, 43);
+		b43_phy_write(dev, B43_NPHY_W1CLIP1_DWELL_LEN, 9);
+		b43_phy_write(dev, B43_NPHY_W1CLIP2_DWELL_LEN, 9);
+
+		/* Set gain backoff */
+		b43_phy_maskset(dev, B43_NPHY_C1_CGAINI,
+				~B43_NPHY_C1_CGAINI_GAINBKOFF,
+				1 << B43_NPHY_C1_CGAINI_GAINBKOFF_SHIFT);
+		b43_phy_maskset(dev, B43_NPHY_C2_CGAINI,
+				~B43_NPHY_C2_CGAINI_GAINBKOFF,
+				1 << B43_NPHY_C2_CGAINI_GAINBKOFF_SHIFT);
+
+		/* Set HPVGA2 index */
+		b43_phy_maskset(dev, B43_NPHY_C1_INITGAIN,
+				~B43_NPHY_C1_INITGAIN_HPVGA2,
+				6 << B43_NPHY_C1_INITGAIN_HPVGA2_SHIFT);
+		b43_phy_maskset(dev, B43_NPHY_C2_INITGAIN,
+				~B43_NPHY_C2_INITGAIN_HPVGA2,
+				6 << B43_NPHY_C2_INITGAIN_HPVGA2_SHIFT);
+
+		//FIXME verify that the specs really mean to use autoinc here.
+		for (i = 0; i < 3; i++)
+			b43_ntab_write(dev, B43_NTAB16(7, 0x106) + i, 0x673);
+	}
+
+	/* Set minimum gain value */
+	b43_phy_maskset(dev, B43_NPHY_C1_MINMAX_GAIN,
+			~B43_NPHY_C1_MINGAIN,
+			23 << B43_NPHY_C1_MINGAIN_SHIFT);
+	b43_phy_maskset(dev, B43_NPHY_C2_MINMAX_GAIN,
+			~B43_NPHY_C2_MINGAIN,
+			23 << B43_NPHY_C2_MINGAIN_SHIFT);
+
+	if (phy->rev < 2) {
+		b43_phy_mask(dev, B43_NPHY_SCRAM_SIGCTL,
+			     ~B43_NPHY_SCRAM_SIGCTL_SCM);
+	}
+
+	/* Set phase track alpha and beta */
+	b43_phy_write(dev, B43_NPHY_PHASETR_A0, 0x125);
+	b43_phy_write(dev, B43_NPHY_PHASETR_A1, 0x1B3);
+	b43_phy_write(dev, B43_NPHY_PHASETR_A2, 0x105);
+	b43_phy_write(dev, B43_NPHY_PHASETR_B0, 0x16E);
+	b43_phy_write(dev, B43_NPHY_PHASETR_B1, 0xCD);
+	b43_phy_write(dev, B43_NPHY_PHASETR_B2, 0x20);
+}
+
+static void b43_nphy_reset_cca(struct b43_wldev *dev)
+{
+	u16 bbcfg;
+
+	ssb_write32(dev->dev, SSB_TMSLOW,
+		    ssb_read32(dev->dev, SSB_TMSLOW) | SSB_TMSLOW_FGC);
+	bbcfg = b43_phy_read(dev, B43_NPHY_BBCFG);
+	b43_phy_set(dev, B43_NPHY_BBCFG, B43_NPHY_BBCFG_RSTCCA);
+	b43_phy_write(dev, B43_NPHY_BBCFG,
+		      bbcfg & ~B43_NPHY_BBCFG_RSTCCA);
+	ssb_write32(dev->dev, SSB_TMSLOW,
+		    ssb_read32(dev->dev, SSB_TMSLOW) & ~SSB_TMSLOW_FGC);
+}
+
+enum b43_nphy_rf_sequence {
+	B43_RFSEQ_RX2TX,
+	B43_RFSEQ_TX2RX,
+	B43_RFSEQ_RESET2RX,
+	B43_RFSEQ_UPDATE_GAINH,
+	B43_RFSEQ_UPDATE_GAINL,
+	B43_RFSEQ_UPDATE_GAINU,
+};
+
+static void b43_nphy_force_rf_sequence(struct b43_wldev *dev,
+				       enum b43_nphy_rf_sequence seq)
+{
+	static const u16 trigger[] = {
+		[B43_RFSEQ_RX2TX]		= B43_NPHY_RFSEQTR_RX2TX,
+		[B43_RFSEQ_TX2RX]		= B43_NPHY_RFSEQTR_TX2RX,
+		[B43_RFSEQ_RESET2RX]		= B43_NPHY_RFSEQTR_RST2RX,
+		[B43_RFSEQ_UPDATE_GAINH]	= B43_NPHY_RFSEQTR_UPGH,
+		[B43_RFSEQ_UPDATE_GAINL]	= B43_NPHY_RFSEQTR_UPGL,
+		[B43_RFSEQ_UPDATE_GAINU]	= B43_NPHY_RFSEQTR_UPGU,
+	};
+	int i;
+
+	B43_WARN_ON(seq >= ARRAY_SIZE(trigger));
+
+	b43_phy_set(dev, B43_NPHY_RFSEQMODE,
+		    B43_NPHY_RFSEQMODE_CAOVER | B43_NPHY_RFSEQMODE_TROVER);
+	b43_phy_set(dev, B43_NPHY_RFSEQTR, trigger[seq]);
+	for (i = 0; i < 200; i++) {
+		if (!(b43_phy_read(dev, B43_NPHY_RFSEQST) & trigger[seq]))
+			goto ok;
+		msleep(1);
+	}
+	b43err(dev->wl, "RF sequence status timeout\n");
+ok:
+	b43_phy_mask(dev, B43_NPHY_RFSEQMODE,
+		     ~(B43_NPHY_RFSEQMODE_CAOVER | B43_NPHY_RFSEQMODE_TROVER));
+}
+
+static void b43_nphy_bphy_init(struct b43_wldev *dev)
+{
+	unsigned int i;
+	u16 val;
+
+	val = 0x1E1F;
+	for (i = 0; i < 14; i++) {
+		b43_phy_write(dev, B43_PHY_N_BMODE(0x88 + i), val);
+		val -= 0x202;
+	}
+	val = 0x3E3F;
+	for (i = 0; i < 16; i++) {
+		b43_phy_write(dev, B43_PHY_N_BMODE(0x97 + i), val);
+		val -= 0x202;
+	}
+	b43_phy_write(dev, B43_PHY_N_BMODE(0x38), 0x668);
+}
+
+/* RSSI Calibration */
+static void b43_nphy_rssi_cal(struct b43_wldev *dev, u8 type)
+{
+	//TODO
+}
+
 int b43_phy_initn(struct b43_wldev *dev)
 {
-	b43err(dev->wl, "IEEE 802.11n devices are not supported, yet.\n");
+	struct b43_phy *phy = &dev->phy;
+	u16 tmp;
 
+	//TODO: Spectral management
+	b43_nphy_tables_init(dev);
+
+	/* Clear all overrides */
+	b43_phy_write(dev, B43_NPHY_RFCTL_OVER, 0);
+	b43_phy_write(dev, B43_NPHY_RFCTL_INTC1, 0);
+	b43_phy_write(dev, B43_NPHY_RFCTL_INTC2, 0);
+	b43_phy_write(dev, B43_NPHY_RFCTL_INTC3, 0);
+	b43_phy_write(dev, B43_NPHY_RFCTL_INTC4, 0);
+	b43_phy_mask(dev, B43_NPHY_RFSEQMODE,
+		     ~(B43_NPHY_RFSEQMODE_CAOVER |
+		       B43_NPHY_RFSEQMODE_TROVER));
+	b43_phy_write(dev, B43_NPHY_AFECTL_OVER, 0);
+
+	tmp = (phy->rev < 2) ? 64 : 59;
+	b43_phy_maskset(dev, B43_NPHY_BPHY_CTL3,
+			~B43_NPHY_BPHY_CTL3_SCALE,
+			tmp << B43_NPHY_BPHY_CTL3_SCALE_SHIFT);
+
+	b43_phy_write(dev, B43_NPHY_AFESEQ_TX2RX_PUD_20M, 0x20);
+	b43_phy_write(dev, B43_NPHY_AFESEQ_TX2RX_PUD_40M, 0x20);
+
+	b43_phy_write(dev, B43_NPHY_TXREALFD, 184);
+	b43_phy_write(dev, B43_NPHY_MIMO_CRSTXEXT, 200);
+	b43_phy_write(dev, B43_NPHY_PLOAD_CSENSE_EXTLEN, 80);
+	b43_phy_write(dev, B43_NPHY_C2_BCLIPBKOFF, 511);
+
+	//TODO MIMO-Config
+	//TODO Update TX/RX chain
+
+	if (phy->rev < 2) {
+		b43_phy_write(dev, B43_NPHY_DUP40_GFBL, 0xAA8);
+		b43_phy_write(dev, B43_NPHY_DUP40_BL, 0x9A4);
+	}
+	b43_nphy_workarounds(dev);
+	b43_nphy_reset_cca(dev);
+
+	ssb_write32(dev->dev, SSB_TMSLOW,
+		    ssb_read32(dev->dev, SSB_TMSLOW) | B43_TMSLOW_MACPHYCLKEN);
+	b43_nphy_force_rf_sequence(dev, B43_RFSEQ_RX2TX);
+	b43_nphy_force_rf_sequence(dev, B43_RFSEQ_RESET2RX);
+
+	b43_phy_read(dev, B43_NPHY_CLASSCTL); /* dummy read */
+	//TODO read core1/2 clip1 thres regs
+
+	if (1 /* FIXME Band is 2.4GHz */)
+		b43_nphy_bphy_init(dev);
+	//TODO disable TX power control
+	//TODO Fix the TX power settings
+	//TODO Init periodic calibration with reason 3
+	b43_nphy_rssi_cal(dev, 2);
+	b43_nphy_rssi_cal(dev, 0);
+	b43_nphy_rssi_cal(dev, 1);
+	//TODO get TX gain
+	//TODO init superswitch
+	//TODO calibrate LO
+	//TODO idle TSSI TX pctl
+	//TODO TX power control power setup
+	//TODO table writes
+	//TODO TX power control coefficients
+	//TODO enable TX power control
+	//TODO control antenna selection
+	//TODO init radar detection
+	//TODO reset channel if changed
+
+	b43err(dev->wl, "IEEE 802.11n devices are not supported, yet.\n");
 	return 0;
 }
Index: wireless-2.6/drivers/net/wireless/b43/nphy.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/nphy.h	2008-01-16 23:24:20.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/nphy.h	2008-01-18 00:35:50.000000000 +0100
@@ -22,14 +22,17 @@
 #define B43_NPHY_C1_DESPWR			B43_PHY_N(0x018) /* Core 1 desired power */
 #define B43_NPHY_C1_CCK_DESPWR			B43_PHY_N(0x019) /* Core 1 CCK desired power */
 #define B43_NPHY_C1_BCLIPBKOFF			B43_PHY_N(0x01A) /* Core 1 barely clip backoff */
 #define B43_NPHY_C1_CCK_BCLIPBKOFF		B43_PHY_N(0x01B) /* Core 1 CCK barely clip backoff */
 #define B43_NPHY_C1_CGAINI			B43_PHY_N(0x01C) /* Core 1 compute gain info */
 #define  B43_NPHY_C1_CGAINI_GAINBKOFF		0x001F /* Gain backoff */
+#define  B43_NPHY_C1_CGAINI_GAINBKOFF_SHIFT	0
 #define  B43_NPHY_C1_CGAINI_CLIPGBKOFF		0x03E0 /* Clip gain backoff */
+#define  B43_NPHY_C1_CGAINI_CLIPGBKOFF_SHIFT	5
 #define  B43_NPHY_C1_CGAINI_GAINSTEP		0x1C00 /* Gain step */
+#define  B43_NPHY_C1_CGAINI_GAINSTEP_SHIFT	10
 #define  B43_NPHY_C1_CGAINI_CL2DETECT		0x2000 /* Clip 2 detect mask */
 #define B43_NPHY_C1_CCK_CGAINI			B43_PHY_N(0x01D) /* Core 1 CCK compute gain info */
 #define  B43_NPHY_C1_CCK_CGAINI_GAINBKOFF	0x001F /* Gain backoff */
 #define  B43_NPHY_C1_CCK_CGAINI_CLIPGBKOFF	0x01E0 /* CCK barely clip gain backoff */
 #define B43_NPHY_C1_MINMAX_GAIN			B43_PHY_N(0x01E) /* Core 1 min/max gain */
 #define  B43_NPHY_C1_MINGAIN			0x00FF /* Minimum gain */
@@ -66,61 +69,64 @@
 #define B43_NPHY_C1_EDTHRES			B43_PHY_N(0x029) /* Core 1 ED threshold */
 #define B43_NPHY_C1_SMSIGTHRES			B43_PHY_N(0x02A) /* Core 1 small sig threshold */
 #define B43_NPHY_C1_NBCLIPTHRES			B43_PHY_N(0x02B) /* Core 1 NB clip threshold */
 #define B43_NPHY_C1_CLIP1THRES			B43_PHY_N(0x02C) /* Core 1 clip1 threshold */
 #define B43_NPHY_C1_CLIP2THRES			B43_PHY_N(0x02D) /* Core 1 clip2 threshold */
 
-#define B43_NPHY_C2_DESPWR			B43_PHY_N(0x018 + 22) /* Core 2 desired power */
-#define B43_NPHY_C2_CCK_DESPWR			B43_PHY_N(0x019 + 22) /* Core 2 CCK desired power */
-#define B43_NPHY_C2_BCLIPBKOFF			B43_PHY_N(0x01A + 22) /* Core 2 barely clip backoff */
-#define B43_NPHY_C2_CCK_BCLIPBKOFF		B43_PHY_N(0x01B + 22) /* Core 2 CCK barely clip backoff */
-#define B43_NPHY_C2_CGAINI			B43_PHY_N(0x01C + 22) /* Core 2 compute gain info */
+#define B43_NPHY_C2_DESPWR			B43_PHY_N(0x02E) /* Core 2 desired power */
+#define B43_NPHY_C2_CCK_DESPWR			B43_PHY_N(0x02F) /* Core 2 CCK desired power */
+#define B43_NPHY_C2_BCLIPBKOFF			B43_PHY_N(0x030) /* Core 2 barely clip backoff */
+#define B43_NPHY_C2_CCK_BCLIPBKOFF		B43_PHY_N(0x031) /* Core 2 CCK barely clip backoff */
+#define B43_NPHY_C2_CGAINI			B43_PHY_N(0x032) /* Core 2 compute gain info */
 #define  B43_NPHY_C2_CGAINI_GAINBKOFF		0x001F /* Gain backoff */
+#define  B43_NPHY_C2_CGAINI_GAINBKOFF_SHIFT	0
 #define  B43_NPHY_C2_CGAINI_CLIPGBKOFF		0x03E0 /* Clip gain backoff */
+#define  B43_NPHY_C2_CGAINI_CLIPGBKOFF_SHIFT	5
 #define  B43_NPHY_C2_CGAINI_GAINSTEP		0x1C00 /* Gain step */
+#define  B43_NPHY_C2_CGAINI_GAINSTEP_SHIFT	10
 #define  B43_NPHY_C2_CGAINI_CL2DETECT		0x2000 /* Clip 2 detect mask */
-#define B43_NPHY_C2_CCK_CGAINI			B43_PHY_N(0x01D + 22) /* Core 2 CCK compute gain info */
+#define B43_NPHY_C2_CCK_CGAINI			B43_PHY_N(0x033) /* Core 2 CCK compute gain info */
 #define  B43_NPHY_C2_CCK_CGAINI_GAINBKOFF	0x001F /* Gain backoff */
 #define  B43_NPHY_C2_CCK_CGAINI_CLIPGBKOFF	0x01E0 /* CCK barely clip gain backoff */
-#define B43_NPHY_C2_MINMAX_GAIN			B43_PHY_N(0x01E + 22) /* Core 2 min/max gain */
+#define B43_NPHY_C2_MINMAX_GAIN			B43_PHY_N(0x034) /* Core 2 min/max gain */
 #define  B43_NPHY_C2_MINGAIN			0x00FF /* Minimum gain */
 #define  B43_NPHY_C2_MINGAIN_SHIFT		0
 #define  B43_NPHY_C2_MAXGAIN			0xFF00 /* Maximum gain */
 #define  B43_NPHY_C2_MAXGAIN_SHIFT		8
-#define B43_NPHY_C2_CCK_MINMAX_GAIN		B43_PHY_N(0x01F + 22) /* Core 2 CCK min/max gain */
+#define B43_NPHY_C2_CCK_MINMAX_GAIN		B43_PHY_N(0x035) /* Core 2 CCK min/max gain */
 #define  B43_NPHY_C2_CCK_MINGAIN		0x00FF /* Minimum gain */
 #define  B43_NPHY_C2_CCK_MINGAIN_SHIFT		0
 #define  B43_NPHY_C2_CCK_MAXGAIN		0xFF00 /* Maximum gain */
 #define  B43_NPHY_C2_CCK_MAXGAIN_SHIFT		8
-#define B43_NPHY_C2_INITGAIN			B43_PHY_N(0x020 + 22) /* Core 2 initial gain code */
+#define B43_NPHY_C2_INITGAIN			B43_PHY_N(0x036) /* Core 2 initial gain code */
 #define  B43_NPHY_C2_INITGAIN_EXTLNA		0x0001 /* External LNA index */
 #define  B43_NPHY_C2_INITGAIN_LNA		0x0006 /* LNA index */
 #define  B43_NPHY_C2_INITGAIN_LNAIDX_SHIFT	1
 #define  B43_NPHY_C2_INITGAIN_HPVGA1		0x0078 /* HPVGA1 index */
 #define  B43_NPHY_C2_INITGAIN_HPVGA1_SHIFT	3
 #define  B43_NPHY_C2_INITGAIN_HPVGA2		0x0F80 /* HPVGA2 index */
 #define  B43_NPHY_C2_INITGAIN_HPVGA2_SHIFT	7
 #define  B43_NPHY_C2_INITGAIN_TRRX		0x1000 /* TR RX index */
 #define  B43_NPHY_C2_INITGAIN_TRTX		0x2000 /* TR TX index */
-#define B43_NPHY_C2_CLIP1_HIGAIN		B43_PHY_N(0x021 + 22) /* Core 2 clip1 high gain code */
-#define B43_NPHY_C2_CLIP1_MEDGAIN		B43_PHY_N(0x022 + 22) /* Core 2 clip1 medium gain code */
-#define B43_NPHY_C2_CLIP1_LOGAIN		B43_PHY_N(0x023 + 22) /* Core 2 clip1 low gain code */
-#define B43_NPHY_C2_CLIP2_GAIN			B43_PHY_N(0x024 + 22) /* Core 2 clip2 gain code */
-#define B43_NPHY_C2_FILTERGAIN			B43_PHY_N(0x025 + 22) /* Core 2 filter gain */
-#define B43_NPHY_C2_LPF_QHPF_BW			B43_PHY_N(0x026 + 22) /* Core 2 LPF Q HP F bandwidth */
-#define B43_NPHY_C2_CLIPWBTHRES			B43_PHY_N(0x027 + 22) /* Core 2 clip wideband threshold */
+#define B43_NPHY_C2_CLIP1_HIGAIN		B43_PHY_N(0x037) /* Core 2 clip1 high gain code */
+#define B43_NPHY_C2_CLIP1_MEDGAIN		B43_PHY_N(0x038) /* Core 2 clip1 medium gain code */
+#define B43_NPHY_C2_CLIP1_LOGAIN		B43_PHY_N(0x039) /* Core 2 clip1 low gain code */
+#define B43_NPHY_C2_CLIP2_GAIN			B43_PHY_N(0x03A) /* Core 2 clip2 gain code */
+#define B43_NPHY_C2_FILTERGAIN			B43_PHY_N(0x03B) /* Core 2 filter gain */
+#define B43_NPHY_C2_LPF_QHPF_BW			B43_PHY_N(0x03C) /* Core 2 LPF Q HP F bandwidth */
+#define B43_NPHY_C2_CLIPWBTHRES			B43_PHY_N(0x03D) /* Core 2 clip wideband threshold */
 #define  B43_NPHY_C2_CLIPWBTHRES_CLIP2		0x003F /* Clip 2 */
 #define  B43_NPHY_C2_CLIPWBTHRES_CLIP2_SHIFT	0
 #define  B43_NPHY_C2_CLIPWBTHRES_CLIP1		0x0FC0 /* Clip 1 */
 #define  B43_NPHY_C2_CLIPWBTHRES_CLIP1_SHIFT	6
-#define B43_NPHY_C2_W1THRES			B43_PHY_N(0x028 + 22) /* Core 2 W1 threshold */
-#define B43_NPHY_C2_EDTHRES			B43_PHY_N(0x029 + 22) /* Core 2 ED threshold */
-#define B43_NPHY_C2_SMSIGTHRES			B43_PHY_N(0x02A + 22) /* Core 2 small sig threshold */
-#define B43_NPHY_C2_NBCLIPTHRES			B43_PHY_N(0x02B + 22) /* Core 2 NB clip threshold */
-#define B43_NPHY_C2_CLIP1THRES			B43_PHY_N(0x02C + 22) /* Core 2 clip1 threshold */
-#define B43_NPHY_C2_CLIP2THRES			B43_PHY_N(0x02D + 22) /* Core 2 clip2 threshold */
+#define B43_NPHY_C2_W1THRES			B43_PHY_N(0x03E) /* Core 2 W1 threshold */
+#define B43_NPHY_C2_EDTHRES			B43_PHY_N(0x03F) /* Core 2 ED threshold */
+#define B43_NPHY_C2_SMSIGTHRES			B43_PHY_N(0x040) /* Core 2 small sig threshold */
+#define B43_NPHY_C2_NBCLIPTHRES			B43_PHY_N(0x041) /* Core 2 NB clip threshold */
+#define B43_NPHY_C2_CLIP1THRES			B43_PHY_N(0x042) /* Core 2 clip1 threshold */
+#define B43_NPHY_C2_CLIP2THRES			B43_PHY_N(0x043) /* Core 2 clip2 threshold */
 
 #define B43_NPHY_CRS_THRES1			B43_PHY_N(0x044) /* CRS threshold 1 */
 #define B43_NPHY_CRS_THRES2			B43_PHY_N(0x045) /* CRS threshold 2 */
 #define B43_NPHY_CRS_THRES3			B43_PHY_N(0x046) /* CRS threshold 3 */
 #define B43_NPHY_CRSCTL				B43_PHY_N(0x047) /* CRS control */
 #define B43_NPHY_DCFADDR			B43_PHY_N(0x048) /* DC filter address */
@@ -222,13 +228,13 @@
 #define B43_NPHY_RFCTL_RXG4			B43_PHY_N(0x084) /* RF control (RX gain 4) */
 #define B43_NPHY_RFCTL_TXG4			B43_PHY_N(0x085) /* RF control (TX gain 4) */
 #define B43_NPHY_C1_TXIQ_COMP_OFF		B43_PHY_N(0x087) /* Core 1 TX I/Q comp offset */
 #define B43_NPHY_C2_TXIQ_COMP_OFF		B43_PHY_N(0x088) /* Core 2 TX I/Q comp offset */
 #define B43_NPHY_C1_TXCTL			B43_PHY_N(0x08B) /* Core 1 TX control */
 #define B43_NPHY_C2_TXCTL			B43_PHY_N(0x08C) /* Core 2 TX control */
-#define B43_NPHY_SCRAM_SIGCTL			B43_PHY_N(0x090) /* Scran signal control */
+#define B43_NPHY_SCRAM_SIGCTL			B43_PHY_N(0x090) /* Scram signal control */
 #define  B43_NPHY_SCRAM_SIGCTL_INITST		0x007F /* Initial state value */
 #define  B43_NPHY_SCRAM_SIGCTL_INITST_SHIFT	0
 #define  B43_NPHY_SCRAM_SIGCTL_SCM		0x0080 /* Scram control mode */
 #define  B43_NPHY_SCRAM_SIGCTL_SICE		0x0100 /* Scram index control enable */
 #define  B43_NPHY_SCRAM_SIGCTL_START		0xFE00 /* Scram start bit */
 #define  B43_NPHY_SCRAM_SIGCTL_START_SHIFT	9


From gmccullagh at gmail.com  Fri Jan 18 13:20:11 2008
From: gmccullagh at gmail.com (Gavin McCullagh)
Date: Fri, 18 Jan 2008 12:20:11 +0000
Subject: issues with bcm4306
In-Reply-To: <200801162312.37646.mb@bu3sch.de>
References: <20080116010817.GA18042@gmail.com>
	<200801162255.53669.mb@bu3sch.de>
	<20080116220009.GD10754@gmail.com>
	<200801162312.37646.mb@bu3sch.de>
Message-ID: <20080118122011.GD23273@gmail.com>

Hi,

On Wed, 16 Jan 2008, Michael Buesch wrote:

> So there's no special LEDs information in your SPROM.
> That means you must get the messages Larry quoted.
> 
> I'm pretty sure that you didn't enable LEDs support
> in your kernel. Make sure CONFIG_LEDS_CLASS and CONFIG_MAC80211_LEDS
> are enabled. While you are at it also make sure CONFIG_RFKILL,
> CONFIG_RFKILL_INPUT and CONFIG_INPUT_POLLDEV are enabled.

leds_class, rfkill and rfkill_input were all modules.  I loaded leds_class
manually but that didn't seem to help.

I then recompiled the kernel (wireless-2.6 tree)  with all of these set to
'y' rather than 'm'.  I still don't seem to get any lights though.

Gavin



From rjw at sisk.pl  Sun Jan 20 02:20:28 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Sun, 20 Jan 2008 02:20:28 +0100
Subject: b43_suspend problem
In-Reply-To: <Pine.LNX.4.44L0.0801131634380.28667-100000@netrider.rowland.org>
References: <Pine.LNX.4.44L0.0801131634380.28667-100000@netrider.rowland.org>
Message-ID: <200801200220.29640.rjw@sisk.pl>

On Sunday, 13 of January 2008, Alan Stern wrote:
> On Sun, 13 Jan 2008, Michael Buesch wrote:
> 
> > > Besides, if you're going to register the device right back again during 
> > > the subsequent resume, then why go to the trouble of unregistering it 
> > > during suspend?  Why not just leave it registered the whole time and 
> > > avoid all the complication (and excess meaningless uevents)?
> > 
> > Well, because not doing it complicates code :)
> > Currently suspend/resume calls the same code as init/exit.
> > The b43 init/exit code is really complicated, compared to other
> > drivers, due to dozens of hardware versions. So I just avoided
> > having yet other codepaths for suspend/resume. But I will add
> > a flag to the device structure that's used to avoid unregistering stuff.
> 
> Instead of adding an extra flag you should refactor the code.  Have a
> common "enable" subroutine that can be called for both init and resume,
> and a common "disable" subroutine that can be called for both exit and
> suspend.  Then the method routines themselves will contain only the
> portions unique to their particular functions, making them shorter and
> simpler.

Well, it doesn't seem to be that easy.

I tried to fix the issue myself and finally obtained the appended, apparently
working, patch (against 2.6.24-rc8-mm1).  Well, it should have been a series
of patches against multiple subsystems, but I thought it would be instructive
to put everything needed into one bigger patch for starters.

Greetings,
Rafael

---
 drivers/base/power/main.c       |    1 
 drivers/base/power/power.h      |    1 
 drivers/char/hw_random/core.c   |   10 ++++-----
 drivers/char/misc.c             |   13 ++++++++----
 drivers/leds/led-class.c        |   13 ++++++++----
 drivers/net/wireless/b43/leds.c |   17 +++++++++------
 drivers/net/wireless/b43/leds.h |   14 +++++++++++--
 drivers/net/wireless/b43/main.c |   43 +++++++++++++++++++++++++++++-----------
 include/linux/device.h          |    6 +++++
 include/linux/hw_random.h       |   10 ++++++++-
 include/linux/leds.h            |   10 ++++++++-
 include/linux/miscdevice.h      |   10 ++++++++-
 12 files changed, 111 insertions(+), 37 deletions(-)

Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/main.c
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
@@ -2470,10 +2470,15 @@ static int b43_rng_read(struct hwrng *rn
 	return (sizeof(u16));
 }
 
-static void b43_rng_exit(struct b43_wl *wl)
+static void __b43_rng_exit(struct b43_wl *wl, bool suspended)
 {
 	if (wl->rng_initialized)
-		hwrng_unregister(&wl->rng);
+		__hwrng_unregister(&wl->rng, suspended);
+}
+
+static void b43_rng_exit(struct b43_wl *wl)
+{
+	__b43_rng_exit(wl, false);
 }
 
 static int b43_rng_init(struct b43_wl *wl)
@@ -3289,7 +3294,7 @@ static void b43_set_retry_limits(struct 
 
 /* Shutdown a wireless core */
 /* Locking: wl->mutex */
-static void b43_wireless_core_exit(struct b43_wldev *dev)
+static void __b43_wireless_core_exit(struct b43_wldev *dev, bool no_suspend)
 {
 	struct b43_phy *phy = &dev->phy;
 
@@ -3298,8 +3303,10 @@ static void b43_wireless_core_exit(struc
 		return;
 	b43_set_status(dev, B43_STAT_UNINIT);
 
-	b43_leds_exit(dev);
-	b43_rng_exit(dev->wl);
+	if (no_suspend) {
+		b43_leds_exit(dev);
+		b43_rng_exit(dev->wl);
+	}
 	b43_pio_free(dev);
 	b43_dma_free(dev);
 	b43_chip_exit(dev);
@@ -3313,8 +3320,13 @@ static void b43_wireless_core_exit(struc
 	ssb_bus_may_powerdown(dev->dev->bus);
 }
 
+static void b43_wireless_core_exit(struct b43_wldev *dev)
+{
+	__b43_wireless_core_exit(dev, true);
+}
+
 /* Initialize a wireless core */
-static int b43_wireless_core_init(struct b43_wldev *dev)
+static int __b43_wireless_core_init(struct b43_wldev *dev, bool no_suspend)
 {
 	struct b43_wl *wl = dev->wl;
 	struct ssb_bus *bus = dev->dev->bus;
@@ -3420,11 +3432,13 @@ static int b43_wireless_core_init(struct
 	memset(wl->mac_addr, 0, ETH_ALEN);
 	b43_upload_card_macaddress(dev);
 	b43_security_init(dev);
-	b43_rng_init(wl);
+	if (no_suspend)
+		b43_rng_init(wl);
 
 	b43_set_status(dev, B43_STAT_INITIALIZED);
 
-	b43_leds_init(dev);
+	if (no_suspend)
+		b43_leds_init(dev);
 out:
 	return err;
 
@@ -3442,6 +3456,11 @@ out:
 	return err;
 }
 
+static int b43_wireless_core_init(struct b43_wldev *dev)
+{
+	return __b43_wireless_core_init(dev, true);
+}
+
 static int b43_op_add_interface(struct ieee80211_hw *hw,
 				struct ieee80211_if_init_conf *conf)
 {
@@ -4028,7 +4047,7 @@ static int b43_suspend(struct ssb_device
 	if (wldev->suspend_init_status >= B43_STAT_STARTED)
 		b43_wireless_core_stop(wldev);
 	if (wldev->suspend_init_status >= B43_STAT_INITIALIZED)
-		b43_wireless_core_exit(wldev);
+		__b43_wireless_core_exit(wldev, false);
 	mutex_unlock(&wl->mutex);
 
 	b43dbg(wl, "Device suspended.\n");
@@ -4046,7 +4065,7 @@ static int b43_resume(struct ssb_device 
 
 	mutex_lock(&wl->mutex);
 	if (wldev->suspend_init_status >= B43_STAT_INITIALIZED) {
-		err = b43_wireless_core_init(wldev);
+		err = __b43_wireless_core_init(wldev, false);
 		if (err) {
 			b43err(wl, "Resume failed at core init\n");
 			goto out;
@@ -4055,7 +4074,9 @@ static int b43_resume(struct ssb_device 
 	if (wldev->suspend_init_status >= B43_STAT_STARTED) {
 		err = b43_wireless_core_start(wldev);
 		if (err) {
-			b43_wireless_core_exit(wldev);
+			b43_leds_resume_exit(wldev);
+			__b43_rng_exit(wldev->wl, true);
+			__b43_wireless_core_exit(wldev, false);
 			b43err(wl, "Resume failed at core start\n");
 			goto out;
 		}
Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/leds.h
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.h
@@ -43,8 +43,15 @@ enum b43_led_behaviour {
 };
 
 void b43_leds_init(struct b43_wldev *dev);
-void b43_leds_exit(struct b43_wldev *dev);
-
+void __b43_leds_exit(struct b43_wldev *dev, bool suspended);
+static inline void b43_leds_exit(struct b43_wldev *dev)
+{
+	__b43_leds_exit(dev, false);
+}
+static inline void b43_leds_resume_exit(struct b43_wldev *dev)
+{
+	__b43_leds_exit(dev, true);
+}
 
 #else /* CONFIG_B43_LEDS */
 /* LED support disabled */
@@ -59,6 +66,9 @@ static inline void b43_leds_init(struct 
 static inline void b43_leds_exit(struct b43_wldev *dev)
 {
 }
+static inline void b43_leds_resume_exit(struct b43_wldev *dev)
+{
+}
 #endif /* CONFIG_B43_LEDS */
 
 #endif /* B43_LEDS_H_ */
Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/leds.c
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.c
@@ -112,11 +112,14 @@ static int b43_register_led(struct b43_w
 	return 0;
 }
 
-static void b43_unregister_led(struct b43_led *led)
+static void b43_unregister_led(struct b43_led *led, bool suspended)
 {
 	if (!led->dev)
 		return;
-	led_classdev_unregister(&led->led_dev);
+	if (suspended)
+		led_classdev_unregister_suspended(&led->led_dev);
+	else
+		led_classdev_unregister(&led->led_dev);
 	b43_led_turn_off(led->dev, led->index, led->activelow);
 	led->dev = NULL;
 }
@@ -230,10 +233,10 @@ void b43_leds_init(struct b43_wldev *dev
 	}
 }
 
-void b43_leds_exit(struct b43_wldev *dev)
+void __b43_leds_exit(struct b43_wldev *dev, bool suspended)
 {
-	b43_unregister_led(&dev->led_tx);
-	b43_unregister_led(&dev->led_rx);
-	b43_unregister_led(&dev->led_assoc);
-	b43_unregister_led(&dev->led_radio);
+	b43_unregister_led(&dev->led_tx, suspended);
+	b43_unregister_led(&dev->led_rx, suspended);
+	b43_unregister_led(&dev->led_assoc, suspended);
+	b43_unregister_led(&dev->led_radio, suspended);
 }
Index: linux-2.6.24-rc8-mm1/drivers/leds/led-class.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/leds/led-class.c
+++ linux-2.6.24-rc8-mm1/drivers/leds/led-class.c
@@ -137,12 +137,14 @@ err_out:
 EXPORT_SYMBOL_GPL(led_classdev_register);
 
 /**
- * led_classdev_unregister - unregisters a object of led_properties class.
+ * __led_classdev_unregister - unregisters a object of led_properties class.
  * @led_cdev: the led device to unregister
+ * @suspended: indicates whether system-wide suspend or resume is in progress
  *
  * Unregisters a previously registered via led_classdev_register object.
  */
-void led_classdev_unregister(struct led_classdev *led_cdev)
+void __led_classdev_unregister(struct led_classdev *led_cdev,
+				      bool suspended)
 {
 	device_remove_file(led_cdev->dev, &dev_attr_brightness);
 #ifdef CONFIG_LEDS_TRIGGERS
@@ -153,13 +155,16 @@ void led_classdev_unregister(struct led_
 	up_write(&led_cdev->trigger_lock);
 #endif
 
-	device_unregister(led_cdev->dev);
+	if (suspended)
+		device_pm_schedule_removal(led_cdev->dev);
+	else
+		device_unregister(led_cdev->dev);
 
 	down_write(&leds_list_lock);
 	list_del(&led_cdev->node);
 	up_write(&leds_list_lock);
 }
-EXPORT_SYMBOL_GPL(led_classdev_unregister);
+EXPORT_SYMBOL_GPL(__led_classdev_unregister);
 
 static int __init leds_init(void)
 {
Index: linux-2.6.24-rc8-mm1/include/linux/leds.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/leds.h
+++ linux-2.6.24-rc8-mm1/include/linux/leds.h
@@ -59,7 +59,15 @@ struct led_classdev {
 
 extern int led_classdev_register(struct device *parent,
 				 struct led_classdev *led_cdev);
-extern void led_classdev_unregister(struct led_classdev *led_cdev);
+extern void __led_classdev_unregister(struct led_classdev *led_cdev, bool sus);
+static inline void led_classdev_unregister(struct led_classdev *lcd)
+{
+	__led_classdev_unregister(lcd, false);
+}
+static inline void led_classdev_unregister_suspended(struct led_classdev *lcd)
+{
+	__led_classdev_unregister(lcd, true);
+}
 extern void led_classdev_suspend(struct led_classdev *led_cdev);
 extern void led_classdev_resume(struct led_classdev *led_cdev);
 
Index: linux-2.6.24-rc8-mm1/drivers/base/power/main.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/base/power/main.c
+++ linux-2.6.24-rc8-mm1/drivers/base/power/main.c
@@ -129,6 +129,7 @@ void device_pm_schedule_removal(struct d
 	list_move_tail(&dev->power.entry, &dpm_destroy);
 	mutex_unlock(&dpm_list_mtx);
 }
+EXPORT_SYMBOL_GPL(device_pm_schedule_removal);
 
 /**
  *	pm_sleep_lock - mutual exclusion for registration and suspend
Index: linux-2.6.24-rc8-mm1/include/linux/device.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/device.h
+++ linux-2.6.24-rc8-mm1/include/linux/device.h
@@ -532,11 +532,17 @@ extern struct device *device_create(stru
 extern void device_destroy(struct class *cls, dev_t devt);
 #ifdef CONFIG_PM_SLEEP
 extern void destroy_suspended_device(struct class *cls, dev_t devt);
+extern void device_pm_schedule_removal(struct device *);
 #else /* !CONFIG_PM_SLEEP */
 static inline void destroy_suspended_device(struct class *cls, dev_t devt)
 {
 	device_destroy(cls, devt);
 }
+
+static inline void device_pm_schedule_removal(struct device *dev)
+{
+	device_unregister(dev);
+}
 #endif /* !CONFIG_PM_SLEEP */
 
 /*
Index: linux-2.6.24-rc8-mm1/drivers/base/power/power.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/base/power/power.h
+++ linux-2.6.24-rc8-mm1/drivers/base/power/power.h
@@ -13,7 +13,6 @@ static inline struct device *to_device(s
 
 extern void device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
-extern void device_pm_schedule_removal(struct device *);
 extern int pm_sleep_lock(void);
 extern void pm_sleep_unlock(void);
 
Index: linux-2.6.24-rc8-mm1/drivers/char/misc.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/char/misc.c
+++ linux-2.6.24-rc8-mm1/drivers/char/misc.c
@@ -232,8 +232,9 @@ int misc_register(struct miscdevice * mi
 }
 
 /**
- *	misc_deregister - unregister a miscellaneous device
+ *	__misc_deregister - unregister a miscellaneous device
  *	@misc: device to unregister
+ *	@suspended: to be set if the function is used during suspend/resume
  *
  *	Unregister a miscellaneous device that was previously
  *	successfully registered with misc_register(). Success
@@ -241,7 +242,7 @@ int misc_register(struct miscdevice * mi
  *	indicates an error.
  */
 
-int misc_deregister(struct miscdevice * misc)
+int __misc_deregister(struct miscdevice *misc, bool suspended)
 {
 	int i = misc->minor;
 
@@ -250,7 +251,11 @@ int misc_deregister(struct miscdevice * 
 
 	mutex_lock(&misc_mtx);
 	list_del(&misc->list);
-	device_destroy(misc_class, MKDEV(MISC_MAJOR, misc->minor));
+	if (suspended)
+		destroy_suspended_device(misc_class,
+					MKDEV(MISC_MAJOR, misc->minor));
+	else
+		device_destroy(misc_class, MKDEV(MISC_MAJOR, misc->minor));
 	if (i < DYNAMIC_MINORS && i>0) {
 		misc_minors[i>>3] &= ~(1 << (misc->minor & 7));
 	}
@@ -259,7 +264,7 @@ int misc_deregister(struct miscdevice * 
 }
 
 EXPORT_SYMBOL(misc_register);
-EXPORT_SYMBOL(misc_deregister);
+EXPORT_SYMBOL(__misc_deregister);
 
 static int __init misc_init(void)
 {
Index: linux-2.6.24-rc8-mm1/include/linux/miscdevice.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/miscdevice.h
+++ linux-2.6.24-rc8-mm1/include/linux/miscdevice.h
@@ -43,7 +43,15 @@ struct miscdevice  {
 };
 
 extern int misc_register(struct miscdevice * misc);
-extern int misc_deregister(struct miscdevice * misc);
+extern int __misc_deregister(struct miscdevice *misc, bool suspended);
+static inline int misc_deregister(struct miscdevice *misc)
+{
+	return __misc_deregister(misc, false);
+}
+static inline int misc_deregister_suspended(struct miscdevice *misc)
+{
+	return __misc_deregister(misc, true);
+}
 
 #define MODULE_ALIAS_MISCDEV(minor)				\
 	MODULE_ALIAS("char-major-" __stringify(MISC_MAJOR)	\
Index: linux-2.6.24-rc8-mm1/drivers/char/hw_random/core.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/char/hw_random/core.c
+++ linux-2.6.24-rc8-mm1/drivers/char/hw_random/core.c
@@ -234,11 +234,11 @@ static DEVICE_ATTR(rng_available, S_IRUG
 		   NULL);
 
 
-static void unregister_miscdev(void)
+static void unregister_miscdev(bool suspended)
 {
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_available);
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
-	misc_deregister(&rng_miscdev);
+	__misc_deregister(&rng_miscdev, suspended);
 }
 
 static int register_miscdev(void)
@@ -313,7 +313,7 @@ out:
 }
 EXPORT_SYMBOL_GPL(hwrng_register);
 
-void hwrng_unregister(struct hwrng *rng)
+void __hwrng_unregister(struct hwrng *rng, bool suspended)
 {
 	int err;
 
@@ -332,11 +332,11 @@ void hwrng_unregister(struct hwrng *rng)
 		}
 	}
 	if (list_empty(&rng_list))
-		unregister_miscdev();
+		unregister_miscdev(suspended);
 
 	mutex_unlock(&rng_mutex);
 }
-EXPORT_SYMBOL_GPL(hwrng_unregister);
+EXPORT_SYMBOL_GPL(__hwrng_unregister);
 
 
 MODULE_DESCRIPTION("H/W Random Number Generator (RNG) driver");
Index: linux-2.6.24-rc8-mm1/include/linux/hw_random.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/hw_random.h
+++ linux-2.6.24-rc8-mm1/include/linux/hw_random.h
@@ -44,7 +44,15 @@ struct hwrng {
 /** Register a new Hardware Random Number Generator driver. */
 extern int hwrng_register(struct hwrng *rng);
 /** Unregister a Hardware Random Number Generator driver. */
-extern void hwrng_unregister(struct hwrng *rng);
+extern void __hwrng_unregister(struct hwrng *rng, bool suspended);
+static inline void hwrng_unregister(struct hwrng *rng)
+{
+	__hwrng_unregister(rng, false);
+}
+static inline void hwrng_unregister_suspended(struct hwrng *rng)
+{
+	__hwrng_unregister(rng, true);
+}
 
 #endif /* __KERNEL__ */
 #endif /* LINUX_HWRANDOM_H_ */


From mb at bu3sch.de  Sun Jan 20 13:33:09 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 20 Jan 2008 13:33:09 +0100
Subject: b43_suspend problem
In-Reply-To: <200801200220.29640.rjw@sisk.pl>
References: <Pine.LNX.4.44L0.0801131634380.28667-100000@netrider.rowland.org>
	<200801200220.29640.rjw@sisk.pl>
Message-ID: <200801201333.10123.mb@bu3sch.de>

On Sunday 20 January 2008, Rafael J. Wysocki wrote:
> On Sunday, 13 of January 2008, Alan Stern wrote:
> > On Sun, 13 Jan 2008, Michael Buesch wrote:
> > 
> > > > Besides, if you're going to register the device right back again during 
> > > > the subsequent resume, then why go to the trouble of unregistering it 
> > > > during suspend?  Why not just leave it registered the whole time and 
> > > > avoid all the complication (and excess meaningless uevents)?
> > > 
> > > Well, because not doing it complicates code :)
> > > Currently suspend/resume calls the same code as init/exit.
> > > The b43 init/exit code is really complicated, compared to other
> > > drivers, due to dozens of hardware versions. So I just avoided
> > > having yet other codepaths for suspend/resume. But I will add
> > > a flag to the device structure that's used to avoid unregistering stuff.
> > 
> > Instead of adding an extra flag you should refactor the code.  Have a
> > common "enable" subroutine that can be called for both init and resume,
> > and a common "disable" subroutine that can be called for both exit and
> > suspend.  Then the method routines themselves will contain only the
> > portions unique to their particular functions, making them shorter and
> > simpler.
> 
> Well, it doesn't seem to be that easy.
> 
> I tried to fix the issue myself and finally obtained the appended, apparently
> working, patch (against 2.6.24-rc8-mm1).  Well, it should have been a series
> of patches against multiple subsystems, but I thought it would be instructive
> to put everything needed into one bigger patch for starters.
> 
> Greetings,
> Rafael
> 
> ---
>  drivers/base/power/main.c       |    1 
>  drivers/base/power/power.h      |    1 
>  drivers/char/hw_random/core.c   |   10 ++++-----
>  drivers/char/misc.c             |   13 ++++++++----
>  drivers/leds/led-class.c        |   13 ++++++++----
>  drivers/net/wireless/b43/leds.c |   17 +++++++++------
>  drivers/net/wireless/b43/leds.h |   14 +++++++++++--
>  drivers/net/wireless/b43/main.c |   43 +++++++++++++++++++++++++++++-----------
>  include/linux/device.h          |    6 +++++
>  include/linux/hw_random.h       |   10 ++++++++-
>  include/linux/leds.h            |   10 ++++++++-
>  include/linux/miscdevice.h      |   10 ++++++++-
>  12 files changed, 111 insertions(+), 37 deletions(-)
> 
> Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/main.c
> +++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
> @@ -2470,10 +2470,15 @@ static int b43_rng_read(struct hwrng *rn
>  	return (sizeof(u16));
>  }
>  
> -static void b43_rng_exit(struct b43_wl *wl)
> +static void __b43_rng_exit(struct b43_wl *wl, bool suspended)
>  {
>  	if (wl->rng_initialized)
> -		hwrng_unregister(&wl->rng);
> +		__hwrng_unregister(&wl->rng, suspended);
> +}
> +
> +static void b43_rng_exit(struct b43_wl *wl)
> +{
> +	__b43_rng_exit(wl, false);
>  }
>  
>  static int b43_rng_init(struct b43_wl *wl)
> @@ -3289,7 +3294,7 @@ static void b43_set_retry_limits(struct 
>  
>  /* Shutdown a wireless core */
>  /* Locking: wl->mutex */
> -static void b43_wireless_core_exit(struct b43_wldev *dev)
> +static void __b43_wireless_core_exit(struct b43_wldev *dev, bool no_suspend)
>  {
>  	struct b43_phy *phy = &dev->phy;
>  
> @@ -3298,8 +3303,10 @@ static void b43_wireless_core_exit(struc
>  		return;
>  	b43_set_status(dev, B43_STAT_UNINIT);
>  
> -	b43_leds_exit(dev);
> -	b43_rng_exit(dev->wl);
> +	if (no_suspend) {
> +		b43_leds_exit(dev);
> +		b43_rng_exit(dev->wl);
> +	}
>  	b43_pio_free(dev);
>  	b43_dma_free(dev);
>  	b43_chip_exit(dev);
> @@ -3313,8 +3320,13 @@ static void b43_wireless_core_exit(struc
>  	ssb_bus_may_powerdown(dev->dev->bus);
>  }
>  
> +static void b43_wireless_core_exit(struct b43_wldev *dev)
> +{
> +	__b43_wireless_core_exit(dev, true);
> +}

Nah, please don't obfuscate the code.
Better add a flag to struct b43_wldev and check that in the few places
that need different behaviour.

>  /* Initialize a wireless core */
> -static int b43_wireless_core_init(struct b43_wldev *dev)
> +static int __b43_wireless_core_init(struct b43_wldev *dev, bool no_suspend)
>  {
>  	struct b43_wl *wl = dev->wl;
>  	struct ssb_bus *bus = dev->dev->bus;
> @@ -3420,11 +3432,13 @@ static int b43_wireless_core_init(struct
>  	memset(wl->mac_addr, 0, ETH_ALEN);
>  	b43_upload_card_macaddress(dev);
>  	b43_security_init(dev);
> -	b43_rng_init(wl);
> +	if (no_suspend)
> +		b43_rng_init(wl);
>  
>  	b43_set_status(dev, B43_STAT_INITIALIZED);
>  
> -	b43_leds_init(dev);
> +	if (no_suspend)
> +		b43_leds_init(dev);
>  out:
>  	return err;
>  
> @@ -3442,6 +3456,11 @@ out:
>  	return err;
>  }
>  
> +static int b43_wireless_core_init(struct b43_wldev *dev)
> +{
> +	return __b43_wireless_core_init(dev, true);
> +}
> +
>  static int b43_op_add_interface(struct ieee80211_hw *hw,
>  				struct ieee80211_if_init_conf *conf)
>  {
> @@ -4028,7 +4047,7 @@ static int b43_suspend(struct ssb_device
>  	if (wldev->suspend_init_status >= B43_STAT_STARTED)
>  		b43_wireless_core_stop(wldev);
>  	if (wldev->suspend_init_status >= B43_STAT_INITIALIZED)
> -		b43_wireless_core_exit(wldev);
> +		__b43_wireless_core_exit(wldev, false);
>  	mutex_unlock(&wl->mutex);
>  
>  	b43dbg(wl, "Device suspended.\n");
> @@ -4046,7 +4065,7 @@ static int b43_resume(struct ssb_device 
>  
>  	mutex_lock(&wl->mutex);
>  	if (wldev->suspend_init_status >= B43_STAT_INITIALIZED) {
> -		err = b43_wireless_core_init(wldev);
> +		err = __b43_wireless_core_init(wldev, false);
>  		if (err) {
>  			b43err(wl, "Resume failed at core init\n");
>  			goto out;
> @@ -4055,7 +4074,9 @@ static int b43_resume(struct ssb_device 
>  	if (wldev->suspend_init_status >= B43_STAT_STARTED) {
>  		err = b43_wireless_core_start(wldev);
>  		if (err) {
> -			b43_wireless_core_exit(wldev);
> +			b43_leds_resume_exit(wldev);
> +			__b43_rng_exit(wldev->wl, true);
> +			__b43_wireless_core_exit(wldev, false);
>  			b43err(wl, "Resume failed at core start\n");
>  			goto out;
>  		}
> Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.h
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/leds.h
> +++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.h
> @@ -43,8 +43,15 @@ enum b43_led_behaviour {
>  };
>  
>  void b43_leds_init(struct b43_wldev *dev);
> -void b43_leds_exit(struct b43_wldev *dev);
> -
> +void __b43_leds_exit(struct b43_wldev *dev, bool suspended);
> +static inline void b43_leds_exit(struct b43_wldev *dev)
> +{
> +	__b43_leds_exit(dev, false);
> +}
> +static inline void b43_leds_resume_exit(struct b43_wldev *dev)
> +{
> +	__b43_leds_exit(dev, true);
> +}

No obfuscation please.

>  #else /* CONFIG_B43_LEDS */
>  /* LED support disabled */
> @@ -59,6 +66,9 @@ static inline void b43_leds_init(struct 
>  static inline void b43_leds_exit(struct b43_wldev *dev)
>  {
>  }
> +static inline void b43_leds_resume_exit(struct b43_wldev *dev)
> +{
> +}
>  #endif /* CONFIG_B43_LEDS */
>  
>  #endif /* B43_LEDS_H_ */
> Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.c
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/leds.c
> +++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.c
> @@ -112,11 +112,14 @@ static int b43_register_led(struct b43_w
>  	return 0;
>  }
>  
> -static void b43_unregister_led(struct b43_led *led)
> +static void b43_unregister_led(struct b43_led *led, bool suspended)
>  {
>  	if (!led->dev)
>  		return;
> -	led_classdev_unregister(&led->led_dev);
> +	if (suspended)
> +		led_classdev_unregister_suspended(&led->led_dev);
> +	else
> +		led_classdev_unregister(&led->led_dev);
>  	b43_led_turn_off(led->dev, led->index, led->activelow);
>  	led->dev = NULL;
>  }
> @@ -230,10 +233,10 @@ void b43_leds_init(struct b43_wldev *dev
>  	}
>  }
>  
> -void b43_leds_exit(struct b43_wldev *dev)
> +void __b43_leds_exit(struct b43_wldev *dev, bool suspended)
>  {
> -	b43_unregister_led(&dev->led_tx);
> -	b43_unregister_led(&dev->led_rx);
> -	b43_unregister_led(&dev->led_assoc);
> -	b43_unregister_led(&dev->led_radio);
> +	b43_unregister_led(&dev->led_tx, suspended);
> +	b43_unregister_led(&dev->led_rx, suspended);
> +	b43_unregister_led(&dev->led_assoc, suspended);
> +	b43_unregister_led(&dev->led_radio, suspended);
>  }
> Index: linux-2.6.24-rc8-mm1/drivers/leds/led-class.c
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/drivers/leds/led-class.c
> +++ linux-2.6.24-rc8-mm1/drivers/leds/led-class.c
> @@ -137,12 +137,14 @@ err_out:
>  EXPORT_SYMBOL_GPL(led_classdev_register);
>  
>  /**
> - * led_classdev_unregister - unregisters a object of led_properties class.
> + * __led_classdev_unregister - unregisters a object of led_properties class.
>   * @led_cdev: the led device to unregister
> + * @suspended: indicates whether system-wide suspend or resume is in progress
>   *
>   * Unregisters a previously registered via led_classdev_register object.
>   */
> -void led_classdev_unregister(struct led_classdev *led_cdev)
> +void __led_classdev_unregister(struct led_classdev *led_cdev,
> +				      bool suspended)
>  {
>  	device_remove_file(led_cdev->dev, &dev_attr_brightness);
>  #ifdef CONFIG_LEDS_TRIGGERS
> @@ -153,13 +155,16 @@ void led_classdev_unregister(struct led_
>  	up_write(&led_cdev->trigger_lock);
>  #endif
>  
> -	device_unregister(led_cdev->dev);
> +	if (suspended)
> +		device_pm_schedule_removal(led_cdev->dev);
> +	else
> +		device_unregister(led_cdev->dev);
>  
>  	down_write(&leds_list_lock);
>  	list_del(&led_cdev->node);
>  	up_write(&leds_list_lock);
>  }
> -EXPORT_SYMBOL_GPL(led_classdev_unregister);
> +EXPORT_SYMBOL_GPL(__led_classdev_unregister);
>  
>  static int __init leds_init(void)
>  {
> Index: linux-2.6.24-rc8-mm1/include/linux/leds.h
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/include/linux/leds.h
> +++ linux-2.6.24-rc8-mm1/include/linux/leds.h
> @@ -59,7 +59,15 @@ struct led_classdev {
>  
>  extern int led_classdev_register(struct device *parent,
>  				 struct led_classdev *led_cdev);
> -extern void led_classdev_unregister(struct led_classdev *led_cdev);
> +extern void __led_classdev_unregister(struct led_classdev *led_cdev, bool sus);
> +static inline void led_classdev_unregister(struct led_classdev *lcd)
> +{
> +	__led_classdev_unregister(lcd, false);
> +}
> +static inline void led_classdev_unregister_suspended(struct led_classdev *lcd)
> +{
> +	__led_classdev_unregister(lcd, true);
> +}
>  extern void led_classdev_suspend(struct led_classdev *led_cdev);
>  extern void led_classdev_resume(struct led_classdev *led_cdev);
>  
> Index: linux-2.6.24-rc8-mm1/drivers/base/power/main.c
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/drivers/base/power/main.c
> +++ linux-2.6.24-rc8-mm1/drivers/base/power/main.c
> @@ -129,6 +129,7 @@ void device_pm_schedule_removal(struct d
>  	list_move_tail(&dev->power.entry, &dpm_destroy);
>  	mutex_unlock(&dpm_list_mtx);
>  }
> +EXPORT_SYMBOL_GPL(device_pm_schedule_removal);
>  
>  /**
>   *	pm_sleep_lock - mutual exclusion for registration and suspend
> Index: linux-2.6.24-rc8-mm1/include/linux/device.h
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/include/linux/device.h
> +++ linux-2.6.24-rc8-mm1/include/linux/device.h
> @@ -532,11 +532,17 @@ extern struct device *device_create(stru
>  extern void device_destroy(struct class *cls, dev_t devt);
>  #ifdef CONFIG_PM_SLEEP
>  extern void destroy_suspended_device(struct class *cls, dev_t devt);
> +extern void device_pm_schedule_removal(struct device *);
>  #else /* !CONFIG_PM_SLEEP */
>  static inline void destroy_suspended_device(struct class *cls, dev_t devt)
>  {
>  	device_destroy(cls, devt);
>  }
> +
> +static inline void device_pm_schedule_removal(struct device *dev)
> +{
> +	device_unregister(dev);
> +}
>  #endif /* !CONFIG_PM_SLEEP */
>  
>  /*
> Index: linux-2.6.24-rc8-mm1/drivers/base/power/power.h
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/drivers/base/power/power.h
> +++ linux-2.6.24-rc8-mm1/drivers/base/power/power.h
> @@ -13,7 +13,6 @@ static inline struct device *to_device(s
>  
>  extern void device_pm_add(struct device *);
>  extern void device_pm_remove(struct device *);
> -extern void device_pm_schedule_removal(struct device *);
>  extern int pm_sleep_lock(void);
>  extern void pm_sleep_unlock(void);
>  
> Index: linux-2.6.24-rc8-mm1/drivers/char/misc.c
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/drivers/char/misc.c
> +++ linux-2.6.24-rc8-mm1/drivers/char/misc.c
> @@ -232,8 +232,9 @@ int misc_register(struct miscdevice * mi
>  }
>  
>  /**
> - *	misc_deregister - unregister a miscellaneous device
> + *	__misc_deregister - unregister a miscellaneous device
>   *	@misc: device to unregister
> + *	@suspended: to be set if the function is used during suspend/resume
>   *
>   *	Unregister a miscellaneous device that was previously
>   *	successfully registered with misc_register(). Success
> @@ -241,7 +242,7 @@ int misc_register(struct miscdevice * mi
>   *	indicates an error.
>   */
>  
> -int misc_deregister(struct miscdevice * misc)
> +int __misc_deregister(struct miscdevice *misc, bool suspended)
>  {
>  	int i = misc->minor;
>  
> @@ -250,7 +251,11 @@ int misc_deregister(struct miscdevice * 
>  
>  	mutex_lock(&misc_mtx);
>  	list_del(&misc->list);
> -	device_destroy(misc_class, MKDEV(MISC_MAJOR, misc->minor));
> +	if (suspended)
> +		destroy_suspended_device(misc_class,
> +					MKDEV(MISC_MAJOR, misc->minor));
> +	else
> +		device_destroy(misc_class, MKDEV(MISC_MAJOR, misc->minor));
>  	if (i < DYNAMIC_MINORS && i>0) {
>  		misc_minors[i>>3] &= ~(1 << (misc->minor & 7));
>  	}
> @@ -259,7 +264,7 @@ int misc_deregister(struct miscdevice * 
>  }
>  
>  EXPORT_SYMBOL(misc_register);
> -EXPORT_SYMBOL(misc_deregister);
> +EXPORT_SYMBOL(__misc_deregister);
>  
>  static int __init misc_init(void)
>  {
> Index: linux-2.6.24-rc8-mm1/include/linux/miscdevice.h
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/include/linux/miscdevice.h
> +++ linux-2.6.24-rc8-mm1/include/linux/miscdevice.h
> @@ -43,7 +43,15 @@ struct miscdevice  {
>  };
>  
>  extern int misc_register(struct miscdevice * misc);
> -extern int misc_deregister(struct miscdevice * misc);
> +extern int __misc_deregister(struct miscdevice *misc, bool suspended);
> +static inline int misc_deregister(struct miscdevice *misc)
> +{
> +	return __misc_deregister(misc, false);
> +}
> +static inline int misc_deregister_suspended(struct miscdevice *misc)
> +{
> +	return __misc_deregister(misc, true);
> +}
>  
>  #define MODULE_ALIAS_MISCDEV(minor)				\
>  	MODULE_ALIAS("char-major-" __stringify(MISC_MAJOR)	\
> Index: linux-2.6.24-rc8-mm1/drivers/char/hw_random/core.c
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/drivers/char/hw_random/core.c
> +++ linux-2.6.24-rc8-mm1/drivers/char/hw_random/core.c
> @@ -234,11 +234,11 @@ static DEVICE_ATTR(rng_available, S_IRUG
>  		   NULL);
>  
>  
> -static void unregister_miscdev(void)
> +static void unregister_miscdev(bool suspended)
>  {
>  	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_available);
>  	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
> -	misc_deregister(&rng_miscdev);
> +	__misc_deregister(&rng_miscdev, suspended);
>  }
>  
>  static int register_miscdev(void)
> @@ -313,7 +313,7 @@ out:
>  }
>  EXPORT_SYMBOL_GPL(hwrng_register);
>  
> -void hwrng_unregister(struct hwrng *rng)
> +void __hwrng_unregister(struct hwrng *rng, bool suspended)
>  {
>  	int err;
>  
> @@ -332,11 +332,11 @@ void hwrng_unregister(struct hwrng *rng)
>  		}
>  	}
>  	if (list_empty(&rng_list))
> -		unregister_miscdev();
> +		unregister_miscdev(suspended);
>  
>  	mutex_unlock(&rng_mutex);
>  }
> -EXPORT_SYMBOL_GPL(hwrng_unregister);
> +EXPORT_SYMBOL_GPL(__hwrng_unregister);
>  
>  
>  MODULE_DESCRIPTION("H/W Random Number Generator (RNG) driver");
> Index: linux-2.6.24-rc8-mm1/include/linux/hw_random.h
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/include/linux/hw_random.h
> +++ linux-2.6.24-rc8-mm1/include/linux/hw_random.h
> @@ -44,7 +44,15 @@ struct hwrng {
>  /** Register a new Hardware Random Number Generator driver. */
>  extern int hwrng_register(struct hwrng *rng);
>  /** Unregister a Hardware Random Number Generator driver. */
> -extern void hwrng_unregister(struct hwrng *rng);
> +extern void __hwrng_unregister(struct hwrng *rng, bool suspended);
> +static inline void hwrng_unregister(struct hwrng *rng)
> +{
> +	__hwrng_unregister(rng, false);
> +}
> +static inline void hwrng_unregister_suspended(struct hwrng *rng)
> +{
> +	__hwrng_unregister(rng, true);
> +}
>  
>  #endif /* __KERNEL__ */
>  #endif /* LINUX_HWRANDOM_H_ */
> 
> 




From rjw at sisk.pl  Sun Jan 20 19:26:55 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Sun, 20 Jan 2008 19:26:55 +0100
Subject: b43_suspend problem
In-Reply-To: <200801201333.10123.mb@bu3sch.de>
References: <Pine.LNX.4.44L0.0801131634380.28667-100000@netrider.rowland.org>
	<200801200220.29640.rjw@sisk.pl> <200801201333.10123.mb@bu3sch.de>
Message-ID: <200801201926.56363.rjw@sisk.pl>

On Sunday, 20 of January 2008, Michael Buesch wrote:
> On Sunday 20 January 2008, Rafael J. Wysocki wrote:
> > On Sunday, 13 of January 2008, Alan Stern wrote:
> > > On Sun, 13 Jan 2008, Michael Buesch wrote:
> > > 
> > > > > Besides, if you're going to register the device right back again during 
> > > > > the subsequent resume, then why go to the trouble of unregistering it 
> > > > > during suspend?  Why not just leave it registered the whole time and 
> > > > > avoid all the complication (and excess meaningless uevents)?
> > > > 
> > > > Well, because not doing it complicates code :)
> > > > Currently suspend/resume calls the same code as init/exit.
> > > > The b43 init/exit code is really complicated, compared to other
> > > > drivers, due to dozens of hardware versions. So I just avoided
> > > > having yet other codepaths for suspend/resume. But I will add
> > > > a flag to the device structure that's used to avoid unregistering stuff.
> > > 
> > > Instead of adding an extra flag you should refactor the code.  Have a
> > > common "enable" subroutine that can be called for both init and resume,
> > > and a common "disable" subroutine that can be called for both exit and
> > > suspend.  Then the method routines themselves will contain only the
> > > portions unique to their particular functions, making them shorter and
> > > simpler.
> > 
> > Well, it doesn't seem to be that easy.
> > 
> > I tried to fix the issue myself and finally obtained the appended, apparently
> > working, patch (against 2.6.24-rc8-mm1).  Well, it should have been a series
> > of patches against multiple subsystems, but I thought it would be instructive
> > to put everything needed into one bigger patch for starters.
> > 
> > Greetings,
> > Rafael
> > 
> > ---
> >  drivers/base/power/main.c       |    1 
> >  drivers/base/power/power.h      |    1 
> >  drivers/char/hw_random/core.c   |   10 ++++-----
> >  drivers/char/misc.c             |   13 ++++++++----
> >  drivers/leds/led-class.c        |   13 ++++++++----
> >  drivers/net/wireless/b43/leds.c |   17 +++++++++------
> >  drivers/net/wireless/b43/leds.h |   14 +++++++++++--
> >  drivers/net/wireless/b43/main.c |   43 +++++++++++++++++++++++++++++-----------
> >  include/linux/device.h          |    6 +++++
> >  include/linux/hw_random.h       |   10 ++++++++-
> >  include/linux/leds.h            |   10 ++++++++-
> >  include/linux/miscdevice.h      |   10 ++++++++-
> >  12 files changed, 111 insertions(+), 37 deletions(-)
> > 
> > Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
> > ===================================================================
> > --- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/main.c
> > +++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
> > @@ -2470,10 +2470,15 @@ static int b43_rng_read(struct hwrng *rn
> >  	return (sizeof(u16));
> >  }
> >  
> > -static void b43_rng_exit(struct b43_wl *wl)
> > +static void __b43_rng_exit(struct b43_wl *wl, bool suspended)
> >  {
> >  	if (wl->rng_initialized)
> > -		hwrng_unregister(&wl->rng);
> > +		__hwrng_unregister(&wl->rng, suspended);
> > +}
> > +
> > +static void b43_rng_exit(struct b43_wl *wl)
> > +{
> > +	__b43_rng_exit(wl, false);
> >  }
> >  
> >  static int b43_rng_init(struct b43_wl *wl)
> > @@ -3289,7 +3294,7 @@ static void b43_set_retry_limits(struct 
> >  
> >  /* Shutdown a wireless core */
> >  /* Locking: wl->mutex */
> > -static void b43_wireless_core_exit(struct b43_wldev *dev)
> > +static void __b43_wireless_core_exit(struct b43_wldev *dev, bool no_suspend)
> >  {
> >  	struct b43_phy *phy = &dev->phy;
> >  
> > @@ -3298,8 +3303,10 @@ static void b43_wireless_core_exit(struc
> >  		return;
> >  	b43_set_status(dev, B43_STAT_UNINIT);
> >  
> > -	b43_leds_exit(dev);
> > -	b43_rng_exit(dev->wl);
> > +	if (no_suspend) {
> > +		b43_leds_exit(dev);
> > +		b43_rng_exit(dev->wl);
> > +	}
> >  	b43_pio_free(dev);
> >  	b43_dma_free(dev);
> >  	b43_chip_exit(dev);
> > @@ -3313,8 +3320,13 @@ static void b43_wireless_core_exit(struc
> >  	ssb_bus_may_powerdown(dev->dev->bus);
> >  }
> >  
> > +static void b43_wireless_core_exit(struct b43_wldev *dev)
> > +{
> > +	__b43_wireless_core_exit(dev, true);
> > +}
> 
> Nah, please don't obfuscate the code.
> Better add a flag to struct b43_wldev and check that in the few places
> that need different behaviour.

I can do that, if you prefer, but that will look worse, IMHO.

Thanks,
Rafael


From mb at bu3sch.de  Sun Jan 20 21:10:36 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sun, 20 Jan 2008 21:10:36 +0100
Subject: b43_suspend problem
In-Reply-To: <200801201926.56363.rjw@sisk.pl>
References: <Pine.LNX.4.44L0.0801131634380.28667-100000@netrider.rowland.org>
	<200801201333.10123.mb@bu3sch.de> <200801201926.56363.rjw@sisk.pl>
Message-ID: <200801202110.36556.mb@bu3sch.de>

On Sunday 20 January 2008, Rafael J. Wysocki wrote:
> > Nah, please don't obfuscate the code.
> > Better add a flag to struct b43_wldev and check that in the few places
> > that need different behaviour.
> 
> I can do that, if you prefer, but that will look worse, IMHO.

I'm pretty sure it won't. We had such a flag in the past for firmware.
(Fixed that differently now).
You simply have do do dev->suspending = 1; at the beginning of suspend/resume
and dev->suspending = 0; at the end. The if() checks in the code remain the same.
The only thing that this approach won't do it clutter the (already hard
to understand) interface up/down API. And that is good. We already have
enough special cases for this stuff due to device weirdness. Let's not make it worse.
I had a hard time to make a sane API for this (look at bcm43xx to compare to
the old crap that doesn't work on lots of devices. ;) )

Thanks for doing this patch.


From rjw at sisk.pl  Mon Jan 21 01:09:56 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Mon, 21 Jan 2008 01:09:56 +0100
Subject: b43_suspend problem
In-Reply-To: <200801202110.36556.mb@bu3sch.de>
References: <Pine.LNX.4.44L0.0801131634380.28667-100000@netrider.rowland.org>
	<200801201926.56363.rjw@sisk.pl> <200801202110.36556.mb@bu3sch.de>
Message-ID: <200801210109.57359.rjw@sisk.pl>

On Sunday, 20 of January 2008, Michael Buesch wrote:
> On Sunday 20 January 2008, Rafael J. Wysocki wrote:
> > > Nah, please don't obfuscate the code.
> > > Better add a flag to struct b43_wldev and check that in the few places
> > > that need different behaviour.
> > 
> > I can do that, if you prefer, but that will look worse, IMHO.
> 
> I'm pretty sure it won't. We had such a flag in the past for firmware.
> (Fixed that differently now).
> You simply have do do dev->suspending = 1; at the beginning of suspend/resume
> and dev->suspending = 0; at the end. The if() checks in the code remain the same.
> The only thing that this approach won't do it clutter the (already hard
> to understand) interface up/down API. And that is good. We already have
> enough special cases for this stuff due to device weirdness. Let's not make it worse.
> I had a hard time to make a sane API for this (look at bcm43xx to compare to
> the old crap that doesn't work on lots of devices. ;) )

I modified the patch to implement something like this.  This still is one big
patch against everything what's necessary.  [BTW, in the current version
of the code, b43_resume() may leave wl->mutex locked in the error paths,
which also is fixed by the patch.]

Please have a look.
 
> Thanks for doing this patch.

You're welcome. :-)

Thanks,
Rafael

---
 drivers/base/power/main.c       |    1 +
 drivers/base/power/power.h      |    1 -
 drivers/char/hw_random/core.c   |   10 +++++-----
 drivers/char/misc.c             |   13 +++++++++----
 drivers/leds/led-class.c        |   13 +++++++++----
 drivers/net/wireless/b43/b43.h  |    1 +
 drivers/net/wireless/b43/leds.c |   17 ++++++++++-------
 drivers/net/wireless/b43/leds.h |   14 ++++++++++++--
 drivers/net/wireless/b43/main.c |   25 ++++++++++++++++---------
 include/linux/device.h          |    6 ++++++
 include/linux/hw_random.h       |   10 +++++++++-
 include/linux/leds.h            |   10 +++++++++-
 include/linux/miscdevice.h      |   10 +++++++++-
 13 files changed, 96 insertions(+), 35 deletions(-)

Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/main.c
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
@@ -2470,10 +2470,10 @@ static int b43_rng_read(struct hwrng *rn
 	return (sizeof(u16));
 }
 
-static void b43_rng_exit(struct b43_wl *wl)
+static void b43_rng_exit(struct b43_wl *wl, bool suspended)
 {
 	if (wl->rng_initialized)
-		hwrng_unregister(&wl->rng);
+		__hwrng_unregister(&wl->rng, suspended);
 }
 
 static int b43_rng_init(struct b43_wl *wl)
@@ -3298,8 +3298,10 @@ static void b43_wireless_core_exit(struc
 		return;
 	b43_set_status(dev, B43_STAT_UNINIT);
 
-	b43_leds_exit(dev);
-	b43_rng_exit(dev->wl);
+	if (!dev->suspend_in_progress) {
+		b43_leds_exit(dev);
+		b43_rng_exit(dev->wl, false);
+	}
 	b43_pio_free(dev);
 	b43_dma_free(dev);
 	b43_chip_exit(dev);
@@ -3420,11 +3422,13 @@ static int b43_wireless_core_init(struct
 	memset(wl->mac_addr, 0, ETH_ALEN);
 	b43_upload_card_macaddress(dev);
 	b43_security_init(dev);
-	b43_rng_init(wl);
+	if (!dev->suspend_in_progress)
+		b43_rng_init(wl);
 
 	b43_set_status(dev, B43_STAT_INITIALIZED);
 
-	b43_leds_init(dev);
+	if (!dev->suspend_in_progress)
+		b43_leds_init(dev);
 out:
 	return err;
 
@@ -4024,6 +4028,7 @@ static int b43_suspend(struct ssb_device
 	b43dbg(wl, "Suspending...\n");
 
 	mutex_lock(&wl->mutex);
+	wldev->suspend_in_progress = true;
 	wldev->suspend_init_status = b43_status(wldev);
 	if (wldev->suspend_init_status >= B43_STAT_STARTED)
 		b43_wireless_core_stop(wldev);
@@ -4055,15 +4060,17 @@ static int b43_resume(struct ssb_device 
 	if (wldev->suspend_init_status >= B43_STAT_STARTED) {
 		err = b43_wireless_core_start(wldev);
 		if (err) {
+			b43_leds_resume_exit(wldev);
+			b43_rng_exit(wldev->wl, true);
 			b43_wireless_core_exit(wldev);
 			b43err(wl, "Resume failed at core start\n");
 			goto out;
 		}
 	}
-	mutex_unlock(&wl->mutex);
-
 	b43dbg(wl, "Device resumed.\n");
-      out:
+ out:
+	wldev->suspend_in_progress = false;
+	mutex_unlock(&wl->mutex);
 	return err;
 }
 
Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/leds.h
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.h
@@ -43,8 +43,15 @@ enum b43_led_behaviour {
 };
 
 void b43_leds_init(struct b43_wldev *dev);
-void b43_leds_exit(struct b43_wldev *dev);
-
+void __b43_leds_exit(struct b43_wldev *dev, bool suspended);
+static inline void b43_leds_exit(struct b43_wldev *dev)
+{
+	__b43_leds_exit(dev, false);
+}
+static inline void b43_leds_resume_exit(struct b43_wldev *dev)
+{
+	__b43_leds_exit(dev, true);
+}
 
 #else /* CONFIG_B43_LEDS */
 /* LED support disabled */
@@ -59,6 +66,9 @@ static inline void b43_leds_init(struct 
 static inline void b43_leds_exit(struct b43_wldev *dev)
 {
 }
+static inline void b43_leds_resume_exit(struct b43_wldev *dev)
+{
+}
 #endif /* CONFIG_B43_LEDS */
 
 #endif /* B43_LEDS_H_ */
Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/leds.c
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.c
@@ -112,11 +112,14 @@ static int b43_register_led(struct b43_w
 	return 0;
 }
 
-static void b43_unregister_led(struct b43_led *led)
+static void b43_unregister_led(struct b43_led *led, bool suspended)
 {
 	if (!led->dev)
 		return;
-	led_classdev_unregister(&led->led_dev);
+	if (suspended)
+		led_classdev_unregister_suspended(&led->led_dev);
+	else
+		led_classdev_unregister(&led->led_dev);
 	b43_led_turn_off(led->dev, led->index, led->activelow);
 	led->dev = NULL;
 }
@@ -230,10 +233,10 @@ void b43_leds_init(struct b43_wldev *dev
 	}
 }
 
-void b43_leds_exit(struct b43_wldev *dev)
+void __b43_leds_exit(struct b43_wldev *dev, bool suspended)
 {
-	b43_unregister_led(&dev->led_tx);
-	b43_unregister_led(&dev->led_rx);
-	b43_unregister_led(&dev->led_assoc);
-	b43_unregister_led(&dev->led_radio);
+	b43_unregister_led(&dev->led_tx, suspended);
+	b43_unregister_led(&dev->led_rx, suspended);
+	b43_unregister_led(&dev->led_assoc, suspended);
+	b43_unregister_led(&dev->led_radio, suspended);
 }
Index: linux-2.6.24-rc8-mm1/drivers/leds/led-class.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/leds/led-class.c
+++ linux-2.6.24-rc8-mm1/drivers/leds/led-class.c
@@ -137,12 +137,14 @@ err_out:
 EXPORT_SYMBOL_GPL(led_classdev_register);
 
 /**
- * led_classdev_unregister - unregisters a object of led_properties class.
+ * __led_classdev_unregister - unregisters a object of led_properties class.
  * @led_cdev: the led device to unregister
+ * @suspended: indicates whether system-wide suspend or resume is in progress
  *
  * Unregisters a previously registered via led_classdev_register object.
  */
-void led_classdev_unregister(struct led_classdev *led_cdev)
+void __led_classdev_unregister(struct led_classdev *led_cdev,
+				      bool suspended)
 {
 	device_remove_file(led_cdev->dev, &dev_attr_brightness);
 #ifdef CONFIG_LEDS_TRIGGERS
@@ -153,13 +155,16 @@ void led_classdev_unregister(struct led_
 	up_write(&led_cdev->trigger_lock);
 #endif
 
-	device_unregister(led_cdev->dev);
+	if (suspended)
+		device_pm_schedule_removal(led_cdev->dev);
+	else
+		device_unregister(led_cdev->dev);
 
 	down_write(&leds_list_lock);
 	list_del(&led_cdev->node);
 	up_write(&leds_list_lock);
 }
-EXPORT_SYMBOL_GPL(led_classdev_unregister);
+EXPORT_SYMBOL_GPL(__led_classdev_unregister);
 
 static int __init leds_init(void)
 {
Index: linux-2.6.24-rc8-mm1/include/linux/leds.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/leds.h
+++ linux-2.6.24-rc8-mm1/include/linux/leds.h
@@ -59,7 +59,15 @@ struct led_classdev {
 
 extern int led_classdev_register(struct device *parent,
 				 struct led_classdev *led_cdev);
-extern void led_classdev_unregister(struct led_classdev *led_cdev);
+extern void __led_classdev_unregister(struct led_classdev *led_cdev, bool sus);
+static inline void led_classdev_unregister(struct led_classdev *lcd)
+{
+	__led_classdev_unregister(lcd, false);
+}
+static inline void led_classdev_unregister_suspended(struct led_classdev *lcd)
+{
+	__led_classdev_unregister(lcd, true);
+}
 extern void led_classdev_suspend(struct led_classdev *led_cdev);
 extern void led_classdev_resume(struct led_classdev *led_cdev);
 
Index: linux-2.6.24-rc8-mm1/drivers/base/power/main.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/base/power/main.c
+++ linux-2.6.24-rc8-mm1/drivers/base/power/main.c
@@ -129,6 +129,7 @@ void device_pm_schedule_removal(struct d
 	list_move_tail(&dev->power.entry, &dpm_destroy);
 	mutex_unlock(&dpm_list_mtx);
 }
+EXPORT_SYMBOL_GPL(device_pm_schedule_removal);
 
 /**
  *	pm_sleep_lock - mutual exclusion for registration and suspend
Index: linux-2.6.24-rc8-mm1/include/linux/device.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/device.h
+++ linux-2.6.24-rc8-mm1/include/linux/device.h
@@ -532,11 +532,17 @@ extern struct device *device_create(stru
 extern void device_destroy(struct class *cls, dev_t devt);
 #ifdef CONFIG_PM_SLEEP
 extern void destroy_suspended_device(struct class *cls, dev_t devt);
+extern void device_pm_schedule_removal(struct device *);
 #else /* !CONFIG_PM_SLEEP */
 static inline void destroy_suspended_device(struct class *cls, dev_t devt)
 {
 	device_destroy(cls, devt);
 }
+
+static inline void device_pm_schedule_removal(struct device *dev)
+{
+	device_unregister(dev);
+}
 #endif /* !CONFIG_PM_SLEEP */
 
 /*
Index: linux-2.6.24-rc8-mm1/drivers/base/power/power.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/base/power/power.h
+++ linux-2.6.24-rc8-mm1/drivers/base/power/power.h
@@ -13,7 +13,6 @@ static inline struct device *to_device(s
 
 extern void device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
-extern void device_pm_schedule_removal(struct device *);
 extern int pm_sleep_lock(void);
 extern void pm_sleep_unlock(void);
 
Index: linux-2.6.24-rc8-mm1/drivers/char/misc.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/char/misc.c
+++ linux-2.6.24-rc8-mm1/drivers/char/misc.c
@@ -232,8 +232,9 @@ int misc_register(struct miscdevice * mi
 }
 
 /**
- *	misc_deregister - unregister a miscellaneous device
+ *	__misc_deregister - unregister a miscellaneous device
  *	@misc: device to unregister
+ *	@suspended: to be set if the function is used during suspend/resume
  *
  *	Unregister a miscellaneous device that was previously
  *	successfully registered with misc_register(). Success
@@ -241,7 +242,7 @@ int misc_register(struct miscdevice * mi
  *	indicates an error.
  */
 
-int misc_deregister(struct miscdevice * misc)
+int __misc_deregister(struct miscdevice *misc, bool suspended)
 {
 	int i = misc->minor;
 
@@ -250,7 +251,11 @@ int misc_deregister(struct miscdevice * 
 
 	mutex_lock(&misc_mtx);
 	list_del(&misc->list);
-	device_destroy(misc_class, MKDEV(MISC_MAJOR, misc->minor));
+	if (suspended)
+		destroy_suspended_device(misc_class,
+					MKDEV(MISC_MAJOR, misc->minor));
+	else
+		device_destroy(misc_class, MKDEV(MISC_MAJOR, misc->minor));
 	if (i < DYNAMIC_MINORS && i>0) {
 		misc_minors[i>>3] &= ~(1 << (misc->minor & 7));
 	}
@@ -259,7 +264,7 @@ int misc_deregister(struct miscdevice * 
 }
 
 EXPORT_SYMBOL(misc_register);
-EXPORT_SYMBOL(misc_deregister);
+EXPORT_SYMBOL(__misc_deregister);
 
 static int __init misc_init(void)
 {
Index: linux-2.6.24-rc8-mm1/include/linux/miscdevice.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/miscdevice.h
+++ linux-2.6.24-rc8-mm1/include/linux/miscdevice.h
@@ -43,7 +43,15 @@ struct miscdevice  {
 };
 
 extern int misc_register(struct miscdevice * misc);
-extern int misc_deregister(struct miscdevice * misc);
+extern int __misc_deregister(struct miscdevice *misc, bool suspended);
+static inline int misc_deregister(struct miscdevice *misc)
+{
+	return __misc_deregister(misc, false);
+}
+static inline int misc_deregister_suspended(struct miscdevice *misc)
+{
+	return __misc_deregister(misc, true);
+}
 
 #define MODULE_ALIAS_MISCDEV(minor)				\
 	MODULE_ALIAS("char-major-" __stringify(MISC_MAJOR)	\
Index: linux-2.6.24-rc8-mm1/drivers/char/hw_random/core.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/char/hw_random/core.c
+++ linux-2.6.24-rc8-mm1/drivers/char/hw_random/core.c
@@ -234,11 +234,11 @@ static DEVICE_ATTR(rng_available, S_IRUG
 		   NULL);
 
 
-static void unregister_miscdev(void)
+static void unregister_miscdev(bool suspended)
 {
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_available);
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
-	misc_deregister(&rng_miscdev);
+	__misc_deregister(&rng_miscdev, suspended);
 }
 
 static int register_miscdev(void)
@@ -313,7 +313,7 @@ out:
 }
 EXPORT_SYMBOL_GPL(hwrng_register);
 
-void hwrng_unregister(struct hwrng *rng)
+void __hwrng_unregister(struct hwrng *rng, bool suspended)
 {
 	int err;
 
@@ -332,11 +332,11 @@ void hwrng_unregister(struct hwrng *rng)
 		}
 	}
 	if (list_empty(&rng_list))
-		unregister_miscdev();
+		unregister_miscdev(suspended);
 
 	mutex_unlock(&rng_mutex);
 }
-EXPORT_SYMBOL_GPL(hwrng_unregister);
+EXPORT_SYMBOL_GPL(__hwrng_unregister);
 
 
 MODULE_DESCRIPTION("H/W Random Number Generator (RNG) driver");
Index: linux-2.6.24-rc8-mm1/include/linux/hw_random.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/hw_random.h
+++ linux-2.6.24-rc8-mm1/include/linux/hw_random.h
@@ -44,7 +44,15 @@ struct hwrng {
 /** Register a new Hardware Random Number Generator driver. */
 extern int hwrng_register(struct hwrng *rng);
 /** Unregister a Hardware Random Number Generator driver. */
-extern void hwrng_unregister(struct hwrng *rng);
+extern void __hwrng_unregister(struct hwrng *rng, bool suspended);
+static inline void hwrng_unregister(struct hwrng *rng)
+{
+	__hwrng_unregister(rng, false);
+}
+static inline void hwrng_unregister_suspended(struct hwrng *rng)
+{
+	__hwrng_unregister(rng, true);
+}
 
 #endif /* __KERNEL__ */
 #endif /* LINUX_HWRANDOM_H_ */
Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/b43.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/b43.h
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/b43.h
@@ -706,6 +706,7 @@ struct b43_wldev {
 	bool short_preamble;	/* TRUE, if short preamble is enabled. */
 	bool short_slot;	/* TRUE, if short slot timing is enabled. */
 	bool radio_hw_enable;	/* saved state of radio hardware enabled state */
+	bool suspend_in_progress;
 
 	/* PHY/Radio device. */
 	struct b43_phy phy;


From mb at bu3sch.de  Mon Jan 21 16:05:10 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 21 Jan 2008 16:05:10 +0100
Subject: b43_suspend problem
In-Reply-To: <200801210109.57359.rjw@sisk.pl>
References: <Pine.LNX.4.44L0.0801131634380.28667-100000@netrider.rowland.org>
	<200801202110.36556.mb@bu3sch.de> <200801210109.57359.rjw@sisk.pl>
Message-ID: <200801211605.10446.mb@bu3sch.de>

On Monday 21 January 2008, Rafael J. Wysocki wrote:
> I modified the patch to implement something like this.  This still is one big
> patch against everything what's necessary.  [BTW, in the current version
> of the code, b43_resume() may leave wl->mutex locked in the error paths,
> which also is fixed by the patch.]

Whoopsy, thanks for catching this.

> Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/main.c
> +++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
> @@ -2470,10 +2470,10 @@ static int b43_rng_read(struct hwrng *rn
>  	return (sizeof(u16));
>  }
>  
> -static void b43_rng_exit(struct b43_wl *wl)
> +static void b43_rng_exit(struct b43_wl *wl, bool suspended)
>  {
>  	if (wl->rng_initialized)
> -		hwrng_unregister(&wl->rng);
> +		__hwrng_unregister(&wl->rng, suspended);
>  }
>  
>  static int b43_rng_init(struct b43_wl *wl)
> @@ -3298,8 +3298,10 @@ static void b43_wireless_core_exit(struc
>  		return;
>  	b43_set_status(dev, B43_STAT_UNINIT);
>  
> -	b43_leds_exit(dev);
> -	b43_rng_exit(dev->wl);
> +	if (!dev->suspend_in_progress) {
> +		b43_leds_exit(dev);
> +		b43_rng_exit(dev->wl, false);
> +	}
>  	b43_pio_free(dev);
>  	b43_dma_free(dev);
>  	b43_chip_exit(dev);
> @@ -3420,11 +3422,13 @@ static int b43_wireless_core_init(struct
>  	memset(wl->mac_addr, 0, ETH_ALEN);
>  	b43_upload_card_macaddress(dev);
>  	b43_security_init(dev);
> -	b43_rng_init(wl);
> +	if (!dev->suspend_in_progress)
> +		b43_rng_init(wl);
>  
>  	b43_set_status(dev, B43_STAT_INITIALIZED);
>  
> -	b43_leds_init(dev);
> +	if (!dev->suspend_in_progress)
> +		b43_leds_init(dev);
>  out:
>  	return err;
>  
> @@ -4024,6 +4028,7 @@ static int b43_suspend(struct ssb_device
>  	b43dbg(wl, "Suspending...\n");
>  
>  	mutex_lock(&wl->mutex);
> +	wldev->suspend_in_progress = true;
>  	wldev->suspend_init_status = b43_status(wldev);
>  	if (wldev->suspend_init_status >= B43_STAT_STARTED)
>  		b43_wireless_core_stop(wldev);
> @@ -4055,15 +4060,17 @@ static int b43_resume(struct ssb_device 
>  	if (wldev->suspend_init_status >= B43_STAT_STARTED) {
>  		err = b43_wireless_core_start(wldev);
>  		if (err) {
> +			b43_leds_resume_exit(wldev);
> +			b43_rng_exit(wldev->wl, true);
>  			b43_wireless_core_exit(wldev);
>  			b43err(wl, "Resume failed at core start\n");
>  			goto out;
>  		}
>  	}
> -	mutex_unlock(&wl->mutex);
> -
>  	b43dbg(wl, "Device resumed.\n");
> -      out:
> + out:
> +	wldev->suspend_in_progress = false;
> +	mutex_unlock(&wl->mutex);
>  	return err;
>  }
>

This part looks OK.

> Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.h
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/leds.h
> +++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.h
> @@ -43,8 +43,15 @@ enum b43_led_behaviour {
>  };
>  
>  void b43_leds_init(struct b43_wldev *dev);
> -void b43_leds_exit(struct b43_wldev *dev);
> -
> +void __b43_leds_exit(struct b43_wldev *dev, bool suspended);
> +static inline void b43_leds_exit(struct b43_wldev *dev)
> +{
> +	__b43_leds_exit(dev, false);
> +}
> +static inline void b43_leds_resume_exit(struct b43_wldev *dev)
> +{
> +	__b43_leds_exit(dev, true);
> +}

I still don't like this function wrapping.
I'm pretty sure the additional parameter to the function is not
needed. We can check dev->suspend_in_progress to find out
if we are in a up/down or in a suspend/resume cycle.

> -static void b43_unregister_led(struct b43_led *led)
> +static void b43_unregister_led(struct b43_led *led, bool suspended)
>  {
>  	if (!led->dev)
>  		return;
> -	led_classdev_unregister(&led->led_dev);
> +	if (suspended)

You can check led->dev->suspend_in_progress here.

> +		led_classdev_unregister_suspended(&led->led_dev);
> +	else
> +		led_classdev_unregister(&led->led_dev);
>  	b43_led_turn_off(led->dev, led->index, led->activelow);
>  	led->dev = NULL;
>  }
> @@ -230,10 +233,10 @@ void b43_leds_init(struct b43_wldev *dev
>  	}
>  }
>  
> -void b43_leds_exit(struct b43_wldev *dev)
> +void __b43_leds_exit(struct b43_wldev *dev, bool suspended)
>  {
> -	b43_unregister_led(&dev->led_tx);
> -	b43_unregister_led(&dev->led_rx);
> -	b43_unregister_led(&dev->led_assoc);
> -	b43_unregister_led(&dev->led_radio);
> +	b43_unregister_led(&dev->led_tx, suspended);
> +	b43_unregister_led(&dev->led_rx, suspended);
> +	b43_unregister_led(&dev->led_assoc, suspended);
> +	b43_unregister_led(&dev->led_radio, suspended);
>  }

Don't need this hunk. Check led->dev->suspend_in_progress in
b43_unregister_led.

>  #endif /* __KERNEL__ */
>  #endif /* LINUX_HWRANDOM_H_ */
> Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/b43.h
> ===================================================================
> --- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/b43.h
> +++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/b43.h
> @@ -706,6 +706,7 @@ struct b43_wldev {
>  	bool short_preamble;	/* TRUE, if short preamble is enabled. */
>  	bool short_slot;	/* TRUE, if short slot timing is enabled. */
>  	bool radio_hw_enable;	/* saved state of radio hardware enabled state */
> +	bool suspend_in_progress;

Please add a comment like: /* TRUE, if we are in a suspend/resume cycle */

I like comments. Can never have enough of them. _Especially_ for data structures. :)


From mb at bu3sch.de  Mon Jan 21 19:55:09 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Mon, 21 Jan 2008 19:55:09 +0100
Subject: [PATCH] b43: Fix firmware caching
Message-ID: <200801211955.09594.mb@bu3sch.de>

We must also store the ID string (filename) for the cached firmware blobs
and verify that we really have the right firmware cached before using it.
If we don't have the right fw cached, we must free it and request the
correct blobs.

This fixes bandswitch on A/B/G multi-PHY devices.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, as we don't support A-PHY operation, yet, we don't need to
apply this patch to 2.6.24. Please queue this patch for 2.6.25.



Index: wireless-2.6/drivers/net/wireless/b43/b43.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/b43.h	2008-01-16 23:26:30.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/b43.h	2008-01-21 18:38:33.000000000 +0100
@@ -663,22 +663,29 @@ struct b43_wl {
 	 * This beacon stuff is protected by the irq_lock. */
 	struct sk_buff *current_beacon;
 	bool beacon0_uploaded;
 	bool beacon1_uploaded;
 };
 
+/* In-memory representation of a cached microcode file. */
+struct b43_firmware_file {
+	const char *filename;
+	const struct firmware *data;
+};
+
 /* Pointers to the firmware data and meta information about it. */
 struct b43_firmware {
 	/* Microcode */
-	const struct firmware *ucode;
+	struct b43_firmware_file ucode;
 	/* PCM code */
-	const struct firmware *pcm;
+	struct b43_firmware_file pcm;
 	/* Initial MMIO values for the firmware */
-	const struct firmware *initvals;
+	struct b43_firmware_file initvals;
 	/* Initial MMIO values for the firmware, band-specific */
-	const struct firmware *initvals_band;
+	struct b43_firmware_file initvals_band;
+
 	/* Firmware revision */
 	u16 rev;
 	/* Firmware patchlevel */
 	u16 patch;
 };
 
Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-21 18:28:36.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-21 19:42:15.000000000 +0100
@@ -1554,22 +1554,25 @@ static irqreturn_t b43_interrupt_handler
 	mmiowb();
 	spin_unlock(&dev->wl->irq_lock);
 
 	return ret;
 }
 
+static void do_release_fw(struct b43_firmware_file *fw)
+{
+	release_firmware(fw->data);
+	fw->data = NULL;
+	fw->filename = NULL;
+}
+
 static void b43_release_firmware(struct b43_wldev *dev)
 {
-	release_firmware(dev->fw.ucode);
-	dev->fw.ucode = NULL;
-	release_firmware(dev->fw.pcm);
-	dev->fw.pcm = NULL;
-	release_firmware(dev->fw.initvals);
-	dev->fw.initvals = NULL;
-	release_firmware(dev->fw.initvals_band);
-	dev->fw.initvals_band = NULL;
+	do_release_fw(&dev->fw.ucode);
+	do_release_fw(&dev->fw.pcm);
+	do_release_fw(&dev->fw.initvals);
+	do_release_fw(&dev->fw.initvals_band);
 }
 
 static void b43_print_fw_helptext(struct b43_wl *wl, bool error)
 {
 	const char *text;
 
@@ -1581,155 +1584,169 @@ static void b43_print_fw_helptext(struct
 	else
 		b43warn(wl, text);
 }
 
 static int do_request_fw(struct b43_wldev *dev,
 			 const char *name,
-			 const struct firmware **fw)
+			 struct b43_firmware_file *fw)
 {
 	char path[sizeof(modparam_fwpostfix) + 32];
+	const struct firmware *blob;
 	struct b43_fw_header *hdr;
 	u32 size;
 	int err;
 
-	if (!name)
+	if (!name) {
+		/* Don't fetch anything. Free possibly cached firmware. */
+		do_release_fw(fw);
 		return 0;
+	}
+	if (fw->filename) {
+		if (strcmp(fw->filename, name) == 0)
+			return 0; /* Already have this fw. */
+		/* Free the cached firmware first. */
+		do_release_fw(fw);
+	}
 
 	snprintf(path, ARRAY_SIZE(path),
 		 "b43%s/%s.fw",
 		 modparam_fwpostfix, name);
-	err = request_firmware(fw, path, dev->dev->dev);
+	err = request_firmware(&blob, path, dev->dev->dev);
 	if (err) {
 		b43err(dev->wl, "Firmware file \"%s\" not found "
 		       "or load failed.\n", path);
 		return err;
 	}
-	if ((*fw)->size < sizeof(struct b43_fw_header))
+	if (blob->size < sizeof(struct b43_fw_header))
 		goto err_format;
-	hdr = (struct b43_fw_header *)((*fw)->data);
+	hdr = (struct b43_fw_header *)(blob->data);
 	switch (hdr->type) {
 	case B43_FW_TYPE_UCODE:
 	case B43_FW_TYPE_PCM:
 		size = be32_to_cpu(hdr->size);
-		if (size != (*fw)->size - sizeof(struct b43_fw_header))
+		if (size != blob->size - sizeof(struct b43_fw_header))
 			goto err_format;
 		/* fallthrough */
 	case B43_FW_TYPE_IV:
 		if (hdr->ver != 1)
 			goto err_format;
 		break;
 	default:
 		goto err_format;
 	}
 
-	return err;
+	fw->data = blob;
+	fw->filename = name;
+
+	return 0;
 
 err_format:
 	b43err(dev->wl, "Firmware file \"%s\" format error.\n", path);
+	release_firmware(blob);
+
 	return -EPROTO;
 }
 
 static int b43_request_firmware(struct b43_wldev *dev)
 {
 	struct b43_firmware *fw = &dev->fw;
 	const u8 rev = dev->dev->id.revision;
 	const char *filename;
 	u32 tmshigh;
 	int err;
 
+	/* Get microcode */
 	tmshigh = ssb_read32(dev->dev, SSB_TMSHIGH);
-	if (!fw->ucode) {
+	if ((rev >= 5) && (rev <= 10))
+		filename = "ucode5";
+	else if ((rev >= 11) && (rev <= 12))
+		filename = "ucode11";
+	else if (rev >= 13)
+		filename = "ucode13";
+	else
+		goto err_no_ucode;
+	err = do_request_fw(dev, filename, &fw->ucode);
+	if (err)
+		goto err_load;
+
+	/* Get PCM code */
+	if ((rev >= 5) && (rev <= 10))
+		filename = "pcm5";
+	else if (rev >= 11)
+		filename = NULL;
+	else
+		goto err_no_pcm;
+	err = do_request_fw(dev, filename, &fw->pcm);
+	if (err)
+		goto err_load;
+
+	/* Get initvals */
+	switch (dev->phy.type) {
+	case B43_PHYTYPE_A:
+		if ((rev >= 5) && (rev <= 10)) {
+			if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY)
+				filename = "a0g1initvals5";
+			else
+				filename = "a0g0initvals5";
+		} else
+			goto err_no_initvals;
+		break;
+	case B43_PHYTYPE_G:
 		if ((rev >= 5) && (rev <= 10))
-			filename = "ucode5";
-		else if ((rev >= 11) && (rev <= 12))
-			filename = "ucode11";
+			filename = "b0g0initvals5";
 		else if (rev >= 13)
-			filename = "ucode13";
+			filename = "lp0initvals13";
 		else
-			goto err_no_ucode;
-		err = do_request_fw(dev, filename, &fw->ucode);
-		if (err)
-			goto err_load;
+			goto err_no_initvals;
+		break;
+	case B43_PHYTYPE_N:
+		if ((rev >= 11) && (rev <= 12))
+			filename = "n0initvals11";
+		else
+			goto err_no_initvals;
+		break;
+	default:
+		goto err_no_initvals;
 	}
-	if (!fw->pcm) {
+	err = do_request_fw(dev, filename, &fw->initvals);
+	if (err)
+		goto err_load;
+
+	/* Get bandswitch initvals */
+	switch (dev->phy.type) {
+	case B43_PHYTYPE_A:
+		if ((rev >= 5) && (rev <= 10)) {
+			if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY)
+				filename = "a0g1bsinitvals5";
+			else
+				filename = "a0g0bsinitvals5";
+		} else if (rev >= 11)
+			filename = NULL;
+		else
+			goto err_no_initvals;
+		break;
+	case B43_PHYTYPE_G:
 		if ((rev >= 5) && (rev <= 10))
-			filename = "pcm5";
+			filename = "b0g0bsinitvals5";
 		else if (rev >= 11)
 			filename = NULL;
 		else
-			goto err_no_pcm;
-		err = do_request_fw(dev, filename, &fw->pcm);
-		if (err)
-			goto err_load;
-	}
-	if (!fw->initvals) {
-		switch (dev->phy.type) {
-		case B43_PHYTYPE_A:
-			if ((rev >= 5) && (rev <= 10)) {
-				if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY)
-					filename = "a0g1initvals5";
-				else
-					filename = "a0g0initvals5";
-			} else
-				goto err_no_initvals;
-			break;
-		case B43_PHYTYPE_G:
-			if ((rev >= 5) && (rev <= 10))
-				filename = "b0g0initvals5";
-			else if (rev >= 13)
-				filename = "lp0initvals13";
-			else
-				goto err_no_initvals;
-			break;
-		case B43_PHYTYPE_N:
-			if ((rev >= 11) && (rev <= 12))
-				filename = "n0initvals11";
-			else
-				goto err_no_initvals;
-			break;
-		default:
 			goto err_no_initvals;
-		}
-		err = do_request_fw(dev, filename, &fw->initvals);
-		if (err)
-			goto err_load;
-	}
-	if (!fw->initvals_band) {
-		switch (dev->phy.type) {
-		case B43_PHYTYPE_A:
-			if ((rev >= 5) && (rev <= 10)) {
-				if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY)
-					filename = "a0g1bsinitvals5";
-				else
-					filename = "a0g0bsinitvals5";
-			} else if (rev >= 11)
-				filename = NULL;
-			else
-				goto err_no_initvals;
-			break;
-		case B43_PHYTYPE_G:
-			if ((rev >= 5) && (rev <= 10))
-				filename = "b0g0bsinitvals5";
-			else if (rev >= 11)
-				filename = NULL;
-			else
-				goto err_no_initvals;
-			break;
-		case B43_PHYTYPE_N:
-			if ((rev >= 11) && (rev <= 12))
-				filename = "n0bsinitvals11";
-			else
-				goto err_no_initvals;
-			break;
-		default:
+		break;
+	case B43_PHYTYPE_N:
+		if ((rev >= 11) && (rev <= 12))
+			filename = "n0bsinitvals11";
+		else
 			goto err_no_initvals;
-		}
-		err = do_request_fw(dev, filename, &fw->initvals_band);
-		if (err)
-			goto err_load;
+		break;
+	default:
+		goto err_no_initvals;
 	}
+	err = do_request_fw(dev, filename, &fw->initvals_band);
+	if (err)
+		goto err_load;
 
 	return 0;
 
 err_load:
 	b43_print_fw_helptext(dev->wl, 1);
 	goto error;
@@ -1762,24 +1779,24 @@ static int b43_upload_microcode(struct b
 	unsigned int i, len;
 	u16 fwrev, fwpatch, fwdate, fwtime;
 	u32 tmp;
 	int err = 0;
 
 	/* Upload Microcode. */
-	data = (__be32 *) (dev->fw.ucode->data + hdr_len);
-	len = (dev->fw.ucode->size - hdr_len) / sizeof(__be32);
+	data = (__be32 *) (dev->fw.ucode.data->data + hdr_len);
+	len = (dev->fw.ucode.data->size - hdr_len) / sizeof(__be32);
 	b43_shm_control_word(dev, B43_SHM_UCODE | B43_SHM_AUTOINC_W, 0x0000);
 	for (i = 0; i < len; i++) {
 		b43_write32(dev, B43_MMIO_SHM_DATA, be32_to_cpu(data[i]));
 		udelay(10);
 	}
 
-	if (dev->fw.pcm) {
+	if (dev->fw.pcm.data) {
 		/* Upload PCM data. */
-		data = (__be32 *) (dev->fw.pcm->data + hdr_len);
-		len = (dev->fw.pcm->size - hdr_len) / sizeof(__be32);
+		data = (__be32 *) (dev->fw.pcm.data->data + hdr_len);
+		len = (dev->fw.pcm.data->size - hdr_len) / sizeof(__be32);
 		b43_shm_control_word(dev, B43_SHM_HW, 0x01EA);
 		b43_write32(dev, B43_MMIO_SHM_DATA, 0x00004000);
 		/* No need for autoinc bit in SHM_HW */
 		b43_shm_control_word(dev, B43_SHM_HW, 0x01EB);
 		for (i = 0; i < len; i++) {
 			b43_write32(dev, B43_MMIO_SHM_DATA, be32_to_cpu(data[i]));
@@ -1910,25 +1927,25 @@ static int b43_upload_initvals(struct b4
 	const struct b43_fw_header *hdr;
 	struct b43_firmware *fw = &dev->fw;
 	const struct b43_iv *ivals;
 	size_t count;
 	int err;
 
-	hdr = (const struct b43_fw_header *)(fw->initvals->data);
-	ivals = (const struct b43_iv *)(fw->initvals->data + hdr_len);
+	hdr = (const struct b43_fw_header *)(fw->initvals.data->data);
+	ivals = (const struct b43_iv *)(fw->initvals.data->data + hdr_len);
 	count = be32_to_cpu(hdr->size);
 	err = b43_write_initvals(dev, ivals, count,
-				 fw->initvals->size - hdr_len);
+				 fw->initvals.data->size - hdr_len);
 	if (err)
 		goto out;
-	if (fw->initvals_band) {
-		hdr = (const struct b43_fw_header *)(fw->initvals_band->data);
-		ivals = (const struct b43_iv *)(fw->initvals_band->data + hdr_len);
+	if (fw->initvals_band.data) {
+		hdr = (const struct b43_fw_header *)(fw->initvals_band.data->data);
+		ivals = (const struct b43_iv *)(fw->initvals_band.data->data + hdr_len);
 		count = be32_to_cpu(hdr->size);
 		err = b43_write_initvals(dev, ivals, count,
-					 fw->initvals_band->size - hdr_len);
+					 fw->initvals_band.data->size - hdr_len);
 		if (err)
 			goto out;
 	}
 out:
 
 	return err;


From rjw at sisk.pl  Tue Jan 22 00:36:45 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Tue, 22 Jan 2008 00:36:45 +0100
Subject: b43_suspend problem
In-Reply-To: <200801211605.10446.mb@bu3sch.de>
References: <Pine.LNX.4.44L0.0801131634380.28667-100000@netrider.rowland.org>
	<200801210109.57359.rjw@sisk.pl> <200801211605.10446.mb@bu3sch.de>
Message-ID: <200801220036.46505.rjw@sisk.pl>

On Monday, 21 of January 2008, Michael Buesch wrote:
> On Monday 21 January 2008, Rafael J. Wysocki wrote:
[--snip--]
> 
> > Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.h
> > ===================================================================
> > --- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/leds.h
> > +++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.h
> > @@ -43,8 +43,15 @@ enum b43_led_behaviour {
> >  };
> >  
> >  void b43_leds_init(struct b43_wldev *dev);
> > -void b43_leds_exit(struct b43_wldev *dev);
> > -
> > +void __b43_leds_exit(struct b43_wldev *dev, bool suspended);
> > +static inline void b43_leds_exit(struct b43_wldev *dev)
> > +{
> > +	__b43_leds_exit(dev, false);
> > +}
> > +static inline void b43_leds_resume_exit(struct b43_wldev *dev)
> > +{
> > +	__b43_leds_exit(dev, true);
> > +}
> 
> I still don't like this function wrapping.
> I'm pretty sure the additional parameter to the function is not
> needed. We can check dev->suspend_in_progress to find out
> if we are in a up/down or in a suspend/resume cycle.

You're right, I overlooked that.

> > -static void b43_unregister_led(struct b43_led *led)
> > +static void b43_unregister_led(struct b43_led *led, bool suspended)
> >  {
> >  	if (!led->dev)
> >  		return;
> > -	led_classdev_unregister(&led->led_dev);
> > +	if (suspended)
> 
> You can check led->dev->suspend_in_progress here.
> 
> > +		led_classdev_unregister_suspended(&led->led_dev);
> > +	else
> > +		led_classdev_unregister(&led->led_dev);
> >  	b43_led_turn_off(led->dev, led->index, led->activelow);
> >  	led->dev = NULL;
> >  }
> > @@ -230,10 +233,10 @@ void b43_leds_init(struct b43_wldev *dev
> >  	}
> >  }
> >  
> > -void b43_leds_exit(struct b43_wldev *dev)
> > +void __b43_leds_exit(struct b43_wldev *dev, bool suspended)
> >  {
> > -	b43_unregister_led(&dev->led_tx);
> > -	b43_unregister_led(&dev->led_rx);
> > -	b43_unregister_led(&dev->led_assoc);
> > -	b43_unregister_led(&dev->led_radio);
> > +	b43_unregister_led(&dev->led_tx, suspended);
> > +	b43_unregister_led(&dev->led_rx, suspended);
> > +	b43_unregister_led(&dev->led_assoc, suspended);
> > +	b43_unregister_led(&dev->led_radio, suspended);
> >  }
> 
> Don't need this hunk. Check led->dev->suspend_in_progress in
> b43_unregister_led.
> 
> >  #endif /* __KERNEL__ */
> >  #endif /* LINUX_HWRANDOM_H_ */
> > Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/b43.h
> > ===================================================================
> > --- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/b43.h
> > +++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/b43.h
> > @@ -706,6 +706,7 @@ struct b43_wldev {
> >  	bool short_preamble;	/* TRUE, if short preamble is enabled. */
> >  	bool short_slot;	/* TRUE, if short slot timing is enabled. */
> >  	bool radio_hw_enable;	/* saved state of radio hardware enabled state */
> > +	bool suspend_in_progress;
> 
> Please add a comment like: /* TRUE, if we are in a suspend/resume cycle */

Sure, I just didn't know what to write in the comment. :-)

Revised patch below, please have a look.

Thanks,
Rafael

---
 drivers/base/power/main.c       |    1 +
 drivers/base/power/power.h      |    1 -
 drivers/char/hw_random/core.c   |   10 +++++-----
 drivers/char/misc.c             |   13 +++++++++----
 drivers/leds/led-class.c        |   13 +++++++++----
 drivers/net/wireless/b43/b43.h  |    1 +
 drivers/net/wireless/b43/leds.c |    5 ++++-
 drivers/net/wireless/b43/main.c |   25 ++++++++++++++++---------
 include/linux/device.h          |    6 ++++++
 include/linux/hw_random.h       |   10 +++++++++-
 include/linux/leds.h            |   10 +++++++++-
 include/linux/miscdevice.h      |   10 +++++++++-
 12 files changed, 78 insertions(+), 27 deletions(-)

Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/main.c
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
@@ -2470,10 +2470,10 @@ static int b43_rng_read(struct hwrng *rn
 	return (sizeof(u16));
 }
 
-static void b43_rng_exit(struct b43_wl *wl)
+static void b43_rng_exit(struct b43_wl *wl, bool suspended)
 {
 	if (wl->rng_initialized)
-		hwrng_unregister(&wl->rng);
+		__hwrng_unregister(&wl->rng, suspended);
 }
 
 static int b43_rng_init(struct b43_wl *wl)
@@ -3298,8 +3298,10 @@ static void b43_wireless_core_exit(struc
 		return;
 	b43_set_status(dev, B43_STAT_UNINIT);
 
-	b43_leds_exit(dev);
-	b43_rng_exit(dev->wl);
+	if (!dev->suspend_in_progress) {
+		b43_leds_exit(dev);
+		b43_rng_exit(dev->wl, false);
+	}
 	b43_pio_free(dev);
 	b43_dma_free(dev);
 	b43_chip_exit(dev);
@@ -3420,11 +3422,13 @@ static int b43_wireless_core_init(struct
 	memset(wl->mac_addr, 0, ETH_ALEN);
 	b43_upload_card_macaddress(dev);
 	b43_security_init(dev);
-	b43_rng_init(wl);
+	if (!dev->suspend_in_progress)
+		b43_rng_init(wl);
 
 	b43_set_status(dev, B43_STAT_INITIALIZED);
 
-	b43_leds_init(dev);
+	if (!dev->suspend_in_progress)
+		b43_leds_init(dev);
 out:
 	return err;
 
@@ -4024,6 +4028,7 @@ static int b43_suspend(struct ssb_device
 	b43dbg(wl, "Suspending...\n");
 
 	mutex_lock(&wl->mutex);
+	wldev->suspend_in_progress = true;
 	wldev->suspend_init_status = b43_status(wldev);
 	if (wldev->suspend_init_status >= B43_STAT_STARTED)
 		b43_wireless_core_stop(wldev);
@@ -4055,15 +4060,17 @@ static int b43_resume(struct ssb_device 
 	if (wldev->suspend_init_status >= B43_STAT_STARTED) {
 		err = b43_wireless_core_start(wldev);
 		if (err) {
+			b43_leds_exit(wldev);
+			b43_rng_exit(wldev->wl, true);
 			b43_wireless_core_exit(wldev);
 			b43err(wl, "Resume failed at core start\n");
 			goto out;
 		}
 	}
-	mutex_unlock(&wl->mutex);
-
 	b43dbg(wl, "Device resumed.\n");
-      out:
+ out:
+	wldev->suspend_in_progress = false;
+	mutex_unlock(&wl->mutex);
 	return err;
 }
 
Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/leds.c
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.c
@@ -116,7 +116,10 @@ static void b43_unregister_led(struct b4
 {
 	if (!led->dev)
 		return;
-	led_classdev_unregister(&led->led_dev);
+	if (led->dev->suspend_in_progress)
+		led_classdev_unregister_suspended(&led->led_dev);
+	else
+		led_classdev_unregister(&led->led_dev);
 	b43_led_turn_off(led->dev, led->index, led->activelow);
 	led->dev = NULL;
 }
Index: linux-2.6.24-rc8-mm1/drivers/leds/led-class.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/leds/led-class.c
+++ linux-2.6.24-rc8-mm1/drivers/leds/led-class.c
@@ -137,12 +137,14 @@ err_out:
 EXPORT_SYMBOL_GPL(led_classdev_register);
 
 /**
- * led_classdev_unregister - unregisters a object of led_properties class.
+ * __led_classdev_unregister - unregisters a object of led_properties class.
  * @led_cdev: the led device to unregister
+ * @suspended: indicates whether system-wide suspend or resume is in progress
  *
  * Unregisters a previously registered via led_classdev_register object.
  */
-void led_classdev_unregister(struct led_classdev *led_cdev)
+void __led_classdev_unregister(struct led_classdev *led_cdev,
+				      bool suspended)
 {
 	device_remove_file(led_cdev->dev, &dev_attr_brightness);
 #ifdef CONFIG_LEDS_TRIGGERS
@@ -153,13 +155,16 @@ void led_classdev_unregister(struct led_
 	up_write(&led_cdev->trigger_lock);
 #endif
 
-	device_unregister(led_cdev->dev);
+	if (suspended)
+		device_pm_schedule_removal(led_cdev->dev);
+	else
+		device_unregister(led_cdev->dev);
 
 	down_write(&leds_list_lock);
 	list_del(&led_cdev->node);
 	up_write(&leds_list_lock);
 }
-EXPORT_SYMBOL_GPL(led_classdev_unregister);
+EXPORT_SYMBOL_GPL(__led_classdev_unregister);
 
 static int __init leds_init(void)
 {
Index: linux-2.6.24-rc8-mm1/include/linux/leds.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/leds.h
+++ linux-2.6.24-rc8-mm1/include/linux/leds.h
@@ -59,7 +59,15 @@ struct led_classdev {
 
 extern int led_classdev_register(struct device *parent,
 				 struct led_classdev *led_cdev);
-extern void led_classdev_unregister(struct led_classdev *led_cdev);
+extern void __led_classdev_unregister(struct led_classdev *led_cdev, bool sus);
+static inline void led_classdev_unregister(struct led_classdev *lcd)
+{
+	__led_classdev_unregister(lcd, false);
+}
+static inline void led_classdev_unregister_suspended(struct led_classdev *lcd)
+{
+	__led_classdev_unregister(lcd, true);
+}
 extern void led_classdev_suspend(struct led_classdev *led_cdev);
 extern void led_classdev_resume(struct led_classdev *led_cdev);
 
Index: linux-2.6.24-rc8-mm1/drivers/base/power/main.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/base/power/main.c
+++ linux-2.6.24-rc8-mm1/drivers/base/power/main.c
@@ -129,6 +129,7 @@ void device_pm_schedule_removal(struct d
 	list_move_tail(&dev->power.entry, &dpm_destroy);
 	mutex_unlock(&dpm_list_mtx);
 }
+EXPORT_SYMBOL_GPL(device_pm_schedule_removal);
 
 /**
  *	pm_sleep_lock - mutual exclusion for registration and suspend
Index: linux-2.6.24-rc8-mm1/include/linux/device.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/device.h
+++ linux-2.6.24-rc8-mm1/include/linux/device.h
@@ -532,11 +532,17 @@ extern struct device *device_create(stru
 extern void device_destroy(struct class *cls, dev_t devt);
 #ifdef CONFIG_PM_SLEEP
 extern void destroy_suspended_device(struct class *cls, dev_t devt);
+extern void device_pm_schedule_removal(struct device *);
 #else /* !CONFIG_PM_SLEEP */
 static inline void destroy_suspended_device(struct class *cls, dev_t devt)
 {
 	device_destroy(cls, devt);
 }
+
+static inline void device_pm_schedule_removal(struct device *dev)
+{
+	device_unregister(dev);
+}
 #endif /* !CONFIG_PM_SLEEP */
 
 /*
Index: linux-2.6.24-rc8-mm1/drivers/base/power/power.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/base/power/power.h
+++ linux-2.6.24-rc8-mm1/drivers/base/power/power.h
@@ -13,7 +13,6 @@ static inline struct device *to_device(s
 
 extern void device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
-extern void device_pm_schedule_removal(struct device *);
 extern int pm_sleep_lock(void);
 extern void pm_sleep_unlock(void);
 
Index: linux-2.6.24-rc8-mm1/drivers/char/misc.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/char/misc.c
+++ linux-2.6.24-rc8-mm1/drivers/char/misc.c
@@ -232,8 +232,9 @@ int misc_register(struct miscdevice * mi
 }
 
 /**
- *	misc_deregister - unregister a miscellaneous device
+ *	__misc_deregister - unregister a miscellaneous device
  *	@misc: device to unregister
+ *	@suspended: to be set if the function is used during suspend/resume
  *
  *	Unregister a miscellaneous device that was previously
  *	successfully registered with misc_register(). Success
@@ -241,7 +242,7 @@ int misc_register(struct miscdevice * mi
  *	indicates an error.
  */
 
-int misc_deregister(struct miscdevice * misc)
+int __misc_deregister(struct miscdevice *misc, bool suspended)
 {
 	int i = misc->minor;
 
@@ -250,7 +251,11 @@ int misc_deregister(struct miscdevice * 
 
 	mutex_lock(&misc_mtx);
 	list_del(&misc->list);
-	device_destroy(misc_class, MKDEV(MISC_MAJOR, misc->minor));
+	if (suspended)
+		destroy_suspended_device(misc_class,
+					MKDEV(MISC_MAJOR, misc->minor));
+	else
+		device_destroy(misc_class, MKDEV(MISC_MAJOR, misc->minor));
 	if (i < DYNAMIC_MINORS && i>0) {
 		misc_minors[i>>3] &= ~(1 << (misc->minor & 7));
 	}
@@ -259,7 +264,7 @@ int misc_deregister(struct miscdevice * 
 }
 
 EXPORT_SYMBOL(misc_register);
-EXPORT_SYMBOL(misc_deregister);
+EXPORT_SYMBOL(__misc_deregister);
 
 static int __init misc_init(void)
 {
Index: linux-2.6.24-rc8-mm1/include/linux/miscdevice.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/miscdevice.h
+++ linux-2.6.24-rc8-mm1/include/linux/miscdevice.h
@@ -43,7 +43,15 @@ struct miscdevice  {
 };
 
 extern int misc_register(struct miscdevice * misc);
-extern int misc_deregister(struct miscdevice * misc);
+extern int __misc_deregister(struct miscdevice *misc, bool suspended);
+static inline int misc_deregister(struct miscdevice *misc)
+{
+	return __misc_deregister(misc, false);
+}
+static inline int misc_deregister_suspended(struct miscdevice *misc)
+{
+	return __misc_deregister(misc, true);
+}
 
 #define MODULE_ALIAS_MISCDEV(minor)				\
 	MODULE_ALIAS("char-major-" __stringify(MISC_MAJOR)	\
Index: linux-2.6.24-rc8-mm1/drivers/char/hw_random/core.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/char/hw_random/core.c
+++ linux-2.6.24-rc8-mm1/drivers/char/hw_random/core.c
@@ -234,11 +234,11 @@ static DEVICE_ATTR(rng_available, S_IRUG
 		   NULL);
 
 
-static void unregister_miscdev(void)
+static void unregister_miscdev(bool suspended)
 {
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_available);
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
-	misc_deregister(&rng_miscdev);
+	__misc_deregister(&rng_miscdev, suspended);
 }
 
 static int register_miscdev(void)
@@ -313,7 +313,7 @@ out:
 }
 EXPORT_SYMBOL_GPL(hwrng_register);
 
-void hwrng_unregister(struct hwrng *rng)
+void __hwrng_unregister(struct hwrng *rng, bool suspended)
 {
 	int err;
 
@@ -332,11 +332,11 @@ void hwrng_unregister(struct hwrng *rng)
 		}
 	}
 	if (list_empty(&rng_list))
-		unregister_miscdev();
+		unregister_miscdev(suspended);
 
 	mutex_unlock(&rng_mutex);
 }
-EXPORT_SYMBOL_GPL(hwrng_unregister);
+EXPORT_SYMBOL_GPL(__hwrng_unregister);
 
 
 MODULE_DESCRIPTION("H/W Random Number Generator (RNG) driver");
Index: linux-2.6.24-rc8-mm1/include/linux/hw_random.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/hw_random.h
+++ linux-2.6.24-rc8-mm1/include/linux/hw_random.h
@@ -44,7 +44,15 @@ struct hwrng {
 /** Register a new Hardware Random Number Generator driver. */
 extern int hwrng_register(struct hwrng *rng);
 /** Unregister a Hardware Random Number Generator driver. */
-extern void hwrng_unregister(struct hwrng *rng);
+extern void __hwrng_unregister(struct hwrng *rng, bool suspended);
+static inline void hwrng_unregister(struct hwrng *rng)
+{
+	__hwrng_unregister(rng, false);
+}
+static inline void hwrng_unregister_suspended(struct hwrng *rng)
+{
+	__hwrng_unregister(rng, true);
+}
 
 #endif /* __KERNEL__ */
 #endif /* LINUX_HWRANDOM_H_ */
Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/b43.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/b43.h
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/b43.h
@@ -706,6 +706,7 @@ struct b43_wldev {
 	bool short_preamble;	/* TRUE, if short preamble is enabled. */
 	bool short_slot;	/* TRUE, if short slot timing is enabled. */
 	bool radio_hw_enable;	/* saved state of radio hardware enabled state */
+	bool suspend_in_progress;	/* TRUE, if we are in a suspend/resume cycle */
 
 	/* PHY/Radio device. */
 	struct b43_phy phy;


From mb at bu3sch.de  Tue Jan 22 16:53:18 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 22 Jan 2008 16:53:18 +0100
Subject: b43_suspend problem
In-Reply-To: <200801220036.46505.rjw@sisk.pl>
References: <Pine.LNX.4.44L0.0801131634380.28667-100000@netrider.rowland.org>
	<200801211605.10446.mb@bu3sch.de> <200801220036.46505.rjw@sisk.pl>
Message-ID: <200801221653.18897.mb@bu3sch.de>

On Tuesday 22 January 2008 00:36:45 Rafael J. Wysocki wrote:
> > I still don't like this function wrapping.
> > I'm pretty sure the additional parameter to the function is not
> > needed. We can check dev->suspend_in_progress to find out
> > if we are in a up/down or in a suspend/resume cycle.
> 
> You're right, I overlooked that.
[snip]

The patch looks good. Did you try it on b43 hardware?

-- 
Greetings Michael.


From mb at bu3sch.de  Tue Jan 22 20:23:34 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Tue, 22 Jan 2008 20:23:34 +0100
Subject: [PATCH] b43: Fix MAC control and microcode init
Message-ID: <200801222023.35131.mb@bu3sch.de>

This zeros out all microcode related memory before loading
the microcode.

This also fixes initialization of the MAC control register.
The _only_ place where we overwrite the contents of the MAC control
register is at the beginning of b43_chip_init().
All other places must do read() -> mask/set -> write() to not
overwrite existing bits.

This also adds a longer delay for waiting for the microcode
to initialize itself. It seems that the current timeout is sufficient
on all available devices, but there's no real reason why we shouldn't
wait for up to one second. Slow embedded devices might exist.
Better safe than sorry.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, this bugfix should go into 2.6.24.
Stefano, this must be ported to b43legacy.



Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-22 19:23:50.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-22 20:00:00.000000000 +0100
@@ -1775,15 +1775,26 @@ error:
 static int b43_upload_microcode(struct b43_wldev *dev)
 {
 	const size_t hdr_len = sizeof(struct b43_fw_header);
 	const __be32 *data;
 	unsigned int i, len;
 	u16 fwrev, fwpatch, fwdate, fwtime;
-	u32 tmp;
+	u32 tmp, macctl;
 	int err = 0;
 
+	/* Jump the microcode PSM to offset 0 */
+	macctl = b43_read32(dev, B43_MMIO_MACCTL);
+	B43_WARN_ON(macctl & B43_MACCTL_PSM_RUN);
+	macctl |= B43_MACCTL_PSM_JMP0;
+	b43_write32(dev, B43_MMIO_MACCTL, macctl);
+	/* Zero out all microcode PSM registers and shared memory. */
+	for (i = 0; i < 64; i++)
+		b43_shm_write16(dev, B43_SHM_SCRATCH, i, 0);
+	for (i = 0; i < 4096; i += 2)
+		b43_shm_write16(dev, B43_SHM_SHARED, i, 0);
+
 	/* Upload Microcode. */
 	data = (__be32 *) (dev->fw.ucode.data->data + hdr_len);
 	len = (dev->fw.ucode.data->size - hdr_len) / sizeof(__be32);
 	b43_shm_control_word(dev, B43_SHM_UCODE | B43_SHM_AUTOINC_W, 0x0000);
 	for (i = 0; i < len; i++) {
 		b43_write32(dev, B43_MMIO_SHM_DATA, be32_to_cpu(data[i]));
@@ -1802,30 +1813,37 @@ static int b43_upload_microcode(struct b
 			b43_write32(dev, B43_MMIO_SHM_DATA, be32_to_cpu(data[i]));
 			udelay(10);
 		}
 	}
 
 	b43_write32(dev, B43_MMIO_GEN_IRQ_REASON, B43_IRQ_ALL);
-	b43_write32(dev, B43_MMIO_MACCTL,
-		    B43_MACCTL_PSM_RUN |
-		    B43_MACCTL_IHR_ENABLED | B43_MACCTL_INFRA);
+
+	/* Start the microcode PSM */
+	macctl = b43_read32(dev, B43_MMIO_MACCTL);
+	macctl &= ~B43_MACCTL_PSM_JMP0;
+	macctl |= B43_MACCTL_PSM_RUN;
+	b43_write32(dev, B43_MMIO_MACCTL, macctl);
 
 	/* Wait for the microcode to load and respond */
 	i = 0;
 	while (1) {
 		tmp = b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);
 		if (tmp == B43_IRQ_MAC_SUSPENDED)
 			break;
 		i++;
-		if (i >= 50) {
+		if (i >= 20) {
 			b43err(dev->wl, "Microcode not responding\n");
 			b43_print_fw_helptext(dev->wl, 1);
 			err = -ENODEV;
-			goto out;
+			goto error;
+		}
+		msleep_interruptible(50);
+		if (signal_pending(current)) {
+			err = -EINTR;
+			goto error;
 		}
-		udelay(10);
 	}
 	b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);	/* dummy read */
 
 	/* Get and check the revisions. */
 	fwrev = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_UCODEREV);
 	fwpatch = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_UCODEPATCH);
@@ -1834,15 +1852,14 @@ static int b43_upload_microcode(struct b
 
 	if (fwrev <= 0x128) {
 		b43err(dev->wl, "YOUR FIRMWARE IS TOO OLD. Firmware from "
 		       "binary drivers older than version 4.x is unsupported. "
 		       "You must upgrade your firmware files.\n");
 		b43_print_fw_helptext(dev->wl, 1);
-		b43_write32(dev, B43_MMIO_MACCTL, 0);
 		err = -EOPNOTSUPP;
-		goto out;
+		goto error;
 	}
 	b43dbg(dev->wl, "Loading firmware version %u.%u "
 	       "(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\n",
 	       fwrev, fwpatch,
 	       (fwdate >> 12) & 0xF, (fwdate >> 8) & 0xF, fwdate & 0xFF,
 	       (fwtime >> 11) & 0x1F, (fwtime >> 5) & 0x3F, fwtime & 0x1F);
@@ -1853,13 +1870,20 @@ static int b43_upload_microcode(struct b
 	if (b43_is_old_txhdr_format(dev)) {
 		b43warn(dev->wl, "You are using an old firmware image. "
 			"Support for old firmware will be removed in July 2008.\n");
 		b43_print_fw_helptext(dev->wl, 0);
 	}
 
-out:
+	return 0;
+
+error:
+	macctl = b43_read32(dev, B43_MMIO_MACCTL);
+	macctl &= ~B43_MACCTL_PSM_RUN;
+	macctl |= B43_MACCTL_PSM_JMP0;
+	b43_write32(dev, B43_MMIO_MACCTL, macctl);
+
 	return err;
 }
 
 static int b43_write_initvals(struct b43_wldev *dev,
 			      const struct b43_iv *ivals,
 			      size_t count,
@@ -2225,17 +2249,21 @@ static void b43_chip_exit(struct b43_wld
  * http://bcm-specs.sipsolutions.net/ChipInit
  */
 static int b43_chip_init(struct b43_wldev *dev)
 {
 	struct b43_phy *phy = &dev->phy;
 	int err, tmp;
-	u32 value32;
+	u32 value32, macctl;
 	u16 value16;
 
-	b43_write32(dev, B43_MMIO_MACCTL,
-		    B43_MACCTL_PSM_JMP0 | B43_MACCTL_IHR_ENABLED);
+	/* Initialize the MAC control */
+	macctl = B43_MACCTL_IHR_ENABLED | B43_MACCTL_SHM_ENABLED;
+	if (dev->phy.gmode)
+		macctl |= B43_MACCTL_GMODE;
+	macctl |= B43_MACCTL_INFRA;
+	b43_write32(dev, B43_MMIO_MACCTL, macctl);
 
 	err = b43_request_firmware(dev);
 	if (err)
 		goto out;
 	err = b43_upload_microcode(dev);
 	if (err)
@@ -3373,18 +3401,25 @@ static void b43_set_retry_limits(struct 
 
 /* Shutdown a wireless core */
 /* Locking: wl->mutex */
 static void b43_wireless_core_exit(struct b43_wldev *dev)
 {
 	struct b43_phy *phy = &dev->phy;
+	u32 macctl;
 
 	B43_WARN_ON(b43_status(dev) > B43_STAT_INITIALIZED);
 	if (b43_status(dev) != B43_STAT_INITIALIZED)
 		return;
 	b43_set_status(dev, B43_STAT_UNINIT);
 
+	/* Stop the microcode PSM. */
+	macctl = b43_read32(dev, B43_MMIO_MACCTL);
+	macctl &= ~B43_MACCTL_PSM_RUN;
+	macctl |= B43_MACCTL_PSM_JMP0;
+	b43_write32(dev, B43_MMIO_MACCTL, macctl);
+
 	b43_leds_exit(dev);
 	b43_rng_exit(dev->wl);
 	b43_dma_free(dev);
 	b43_chip_exit(dev);
 	b43_radio_turn_off(dev, 1);
 	b43_switch_analog(dev, 0);


From celejar at gmail.com  Wed Jan 23 02:45:04 2008
From: celejar at gmail.com (Celejar)
Date: Tue, 22 Jan 2008 20:45:04 -0500
Subject: resuming from suspend to disk not working with b43
Message-ID: <20080122204504.854f41a5.celejar@gmail.com>

Hi,

I know there's an ongoing long thread about suspend in b43, but
the technical level has been above me, and I don't know if anything
there is relevant to me.

When I suspend to disk ('s2disk' from uswsusp), the resume fails if b43
is loaded.  The screen stays blank, although I see a cursor flashing.
'modprobe -r b43' before suspending makes the resume work fine, but if I
subsequently load b43 after the resume the machine freezes.

I am using Debian Sid, b43 from vanilla kernels from kernel.org (2.6.24
isn't in Debian yet).  I have had this problem with -rc4 and -rc8. the
only two I've tried.  HW is a 4318 Air Force One, in an Acer Aspire
3690-2672.  Is there any debugging info I can provide?  Is this a known
problem?  Is there anything I should try?

This issue aside, the driver works quite well for me.  Thanks!

Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator



From mb at bu3sch.de  Wed Jan 23 12:02:35 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 23 Jan 2008 12:02:35 +0100
Subject: [PATCH] b43: Fix rfkill allocation leakage in error paths
Message-ID: <200801231202.36073.mb@bu3sch.de>

We must kill rfkill in any error paths that trigger after rfkill init.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, please try to push this for 2.6.24. Seems quite important,
as it leaks resources and might crash the kernel.


Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-23 11:52:50.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-23 11:55:17.000000000 +0100
@@ -3626,38 +3626,45 @@ static void b43_op_remove_interface(stru
 static int b43_op_start(struct ieee80211_hw *hw)
 {
 	struct b43_wl *wl = hw_to_b43_wl(hw);
 	struct b43_wldev *dev = wl->current_dev;
 	int did_init = 0;
 	int err = 0;
+	bool do_rfkill_exit = 0;
 
 	/* First register RFkill.
 	 * LEDs that are registered later depend on it. */
 	b43_rfkill_init(dev);
 
 	mutex_lock(&wl->mutex);
 
 	if (b43_status(dev) < B43_STAT_INITIALIZED) {
 		err = b43_wireless_core_init(dev);
-		if (err)
+		if (err) {
+			do_rfkill_exit = 1;
 			goto out_mutex_unlock;
+		}
 		did_init = 1;
 	}
 
 	if (b43_status(dev) < B43_STAT_STARTED) {
 		err = b43_wireless_core_start(dev);
 		if (err) {
 			if (did_init)
 				b43_wireless_core_exit(dev);
+			do_rfkill_exit = 1;
 			goto out_mutex_unlock;
 		}
 	}
 
  out_mutex_unlock:
 	mutex_unlock(&wl->mutex);
 
+	if (do_rfkill_exit)
+		b43_rfkill_exit(dev);
+
 	return err;
 }
 
 static void b43_op_stop(struct ieee80211_hw *hw)
 {
 	struct b43_wl *wl = hw_to_b43_wl(hw);


From mb at bu3sch.de  Wed Jan 23 12:15:38 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 23 Jan 2008 12:15:38 +0100
Subject: [PATCH] b43legacy: Fix rfkill allocation leakage in error paths
Message-ID: <200801231215.38768.mb@bu3sch.de>

We must kill rfkill in any error paths that trigger after rfkill init.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, please try to push this for 2.6.24. Seems quite important,
as it leaks resources and might crash the kernel.


Index: wireless-2.6/drivers/net/wireless/b43legacy/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43legacy/main.c	2008-01-16 23:28:50.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43legacy/main.c	2008-01-23 12:04:41.000000000 +0100
@@ -3218,38 +3218,45 @@ static void b43legacy_op_remove_interfac
 static int b43legacy_op_start(struct ieee80211_hw *hw)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);
 	struct b43legacy_wldev *dev = wl->current_dev;
 	int did_init = 0;
 	int err = 0;
+	bool do_rfkill_exit = 0;
 
 	/* First register RFkill.
 	 * LEDs that are registered later depend on it. */
 	b43legacy_rfkill_init(dev);
 
 	mutex_lock(&wl->mutex);
 
 	if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {
 		err = b43legacy_wireless_core_init(dev);
-		if (err)
+		if (err) {
+			do_rfkill_exit = 1;
 			goto out_mutex_unlock;
+		}
 		did_init = 1;
 	}
 
 	if (b43legacy_status(dev) < B43legacy_STAT_STARTED) {
 		err = b43legacy_wireless_core_start(dev);
 		if (err) {
 			if (did_init)
 				b43legacy_wireless_core_exit(dev);
+			do_rfkill_exit = 1;
 			goto out_mutex_unlock;
 		}
 	}
 
 out_mutex_unlock:
 	mutex_unlock(&wl->mutex);
 
+	if (do_rfkill_exit)
+		b43legacy_rfkill_exit(dev);
+
 	return err;
 }
 
 static void b43legacy_op_stop(struct ieee80211_hw *hw)
 {
 	struct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);


From stefano.brivio at polimi.it  Wed Jan 23 13:55:09 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Wed, 23 Jan 2008 13:55:09 +0100
Subject: [PATCH] b43legacy: Fix rfkill allocation leakage in error paths
In-Reply-To: <200801231215.38768.mb@bu3sch.de>
References: <200801231215.38768.mb@bu3sch.de>
Message-ID: <20080123135509.539f645f@morte>

On Wed, 23 Jan 2008 12:15:38 +0100
Michael Buesch <mb at bu3sch.de> wrote:

> We must kill rfkill in any error paths that trigger after rfkill init.
> 
> Signed-off-by: Michael Buesch <mb at bu3sch.de>

Acked-by: Stefano Brivio <stefano.brivio at polimi.it>


--
Ciao
Stefano


From rjw at sisk.pl  Wed Jan 23 16:00:15 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Wed, 23 Jan 2008 16:00:15 +0100
Subject: resuming from suspend to disk not working with b43
In-Reply-To: <20080122204504.854f41a5.celejar@gmail.com>
References: <20080122204504.854f41a5.celejar@gmail.com>
Message-ID: <200801231600.16275.rjw@sisk.pl>

On Wednesday, 23 of January 2008, Celejar wrote:
> Hi,

Hi,
 
> I know there's an ongoing long thread about suspend in b43, but
> the technical level has been above me, and I don't know if anything
> there is relevant to me.
> 
> When I suspend to disk ('s2disk' from uswsusp), the resume fails if b43
> is loaded.  The screen stays blank, although I see a cursor flashing.
> 'modprobe -r b43' before suspending makes the resume work fine, but if I
> subsequently load b43 after the resume the machine freezes.

Hm, I use b43 w/ s2disk on a regular basis and it works, but openSUSE has a
userland suspend hook that disables NetworkManager before  a suspend.

> I am using Debian Sid, b43 from vanilla kernels from kernel.org (2.6.24
> isn't in Debian yet).  I have had this problem with -rc4 and -rc8. the
> only two I've tried.  HW is a 4318 Air Force One, in an Acer Aspire
> 3690-2672.  Is there any debugging info I can provide?  Is this a known
> problem?  Is there anything I should try?

Please try to switch off the interface before suspend without unloading the
module.

Also, does s2ram work on your box?

Rafael


From mb at bu3sch.de  Wed Jan 23 21:10:56 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 23 Jan 2008 21:10:56 +0100
Subject: [PATCH] b43: Fix suspend/resume
Message-ID: <200801232110.57017.mb@bu3sch.de>

This fixes suspend/resume.

We must not overwrite the MAC addresses on resume. Otherwise
the card won't ACK any packets anymore.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

John, this is a bugfix that makes suspend/resume working. Without this
people need to do an interface up/down cycle after each resume.
Please try to push it for 2.6.24.

Stefano, this might need porting to legacy.


Index: wireless-2.6/drivers/net/wireless/b43/main.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/main.c	2008-01-23 21:01:44.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/main.c	2008-01-23 21:02:16.000000000 +0100
@@ -3528,14 +3528,12 @@ static int b43_wireless_core_init(struct
 	/* Set the pre-wakeup for synthetic PU (in microseconds). */
 	b43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_SPUWKUP, 500);
 
 	b43_bluetooth_coext_enable(dev);
 
 	ssb_bus_powerup(bus, 1);	/* Enable dynamic PCTL */
-	memset(wl->bssid, 0, ETH_ALEN);
-	memset(wl->mac_addr, 0, ETH_ALEN);
 	b43_upload_card_macaddress(dev);
 	b43_security_init(dev);
 	b43_rng_init(wl);
 
 	b43_set_status(dev, B43_STAT_INITIALIZED);
 
@@ -3628,12 +3626,20 @@ static int b43_op_start(struct ieee80211
 	struct b43_wl *wl = hw_to_b43_wl(hw);
 	struct b43_wldev *dev = wl->current_dev;
 	int did_init = 0;
 	int err = 0;
 	bool do_rfkill_exit = 0;
 
+	/* Kill all old instance specific information to make sure
+	 * the card won't use it in the short timeframe between start
+	 * and mac80211 reconfiguring it. */
+	memset(wl->bssid, 0, ETH_ALEN);
+	memset(wl->mac_addr, 0, ETH_ALEN);
+	wl->filter_flags = 0;
+	wl->radiotap_enabled = 0;
+
 	/* First register RFkill.
 	 * LEDs that are registered later depend on it. */
 	b43_rfkill_init(dev);
 
 	mutex_lock(&wl->mutex);
 
Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c	2008-01-23 21:01:44.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/xmit.c	2008-01-23 21:02:16.000000000 +0100
@@ -234,26 +234,29 @@ void b43_generate_txhdr(struct b43_wldev
 		struct b43_key *key;
 		int wlhdr_len;
 		size_t iv_len;
 
 		B43_WARN_ON(key_idx >= dev->max_nr_keys);
 		key = &(dev->key[key_idx]);
-		B43_WARN_ON(!key->keyconf);
 
-		/* Hardware appends ICV. */
-		plcp_fragment_len += txctl->icv_len;
+		if (likely(key->keyconf)) {
+			/* This key is valid. Use it for encryption. */
 
-		key_idx = b43_kidx_to_fw(dev, key_idx);
-		mac_ctl |= (key_idx << B43_TXH_MAC_KEYIDX_SHIFT) &
-			   B43_TXH_MAC_KEYIDX;
-		mac_ctl |= (key->algorithm << B43_TXH_MAC_KEYALG_SHIFT) &
-			   B43_TXH_MAC_KEYALG;
-		wlhdr_len = ieee80211_get_hdrlen(fctl);
-		iv_len = min((size_t) txctl->iv_len,
-			     ARRAY_SIZE(txhdr->iv));
-		memcpy(txhdr->iv, ((u8 *) wlhdr) + wlhdr_len, iv_len);
+			/* Hardware appends ICV. */
+			plcp_fragment_len += txctl->icv_len;
+
+			key_idx = b43_kidx_to_fw(dev, key_idx);
+			mac_ctl |= (key_idx << B43_TXH_MAC_KEYIDX_SHIFT) &
+				   B43_TXH_MAC_KEYIDX;
+			mac_ctl |= (key->algorithm << B43_TXH_MAC_KEYALG_SHIFT) &
+				   B43_TXH_MAC_KEYALG;
+			wlhdr_len = ieee80211_get_hdrlen(fctl);
+			iv_len = min((size_t) txctl->iv_len,
+				     ARRAY_SIZE(txhdr->iv));
+			memcpy(txhdr->iv, ((u8 *) wlhdr) + wlhdr_len, iv_len);
+		}
 	}
 	if (b43_is_old_txhdr_format(dev)) {
 		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->old_format.plcp),
 				      plcp_fragment_len, rate);
 	} else {
 		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->new_format.plcp),


From celejar at gmail.com  Wed Jan 23 21:27:36 2008
From: celejar at gmail.com (Celejar)
Date: Wed, 23 Jan 2008 15:27:36 -0500
Subject: resuming from suspend to disk not working with b43
In-Reply-To: <200801231600.16275.rjw@sisk.pl>
References: <20080122204504.854f41a5.celejar@gmail.com>
	<200801231600.16275.rjw@sisk.pl>
Message-ID: <20080123152736.c3a0833b.celejar@gmail.com>

On Wed, 23 Jan 2008 16:00:15 +0100
"Rafael J. Wysocki" <rjw at sisk.pl> wrote:

> On Wednesday, 23 of January 2008, Celejar wrote:
> > Hi,
> 
> Hi,
>  
> > I know there's an ongoing long thread about suspend in b43, but
> > the technical level has been above me, and I don't know if anything
> > there is relevant to me.
> > 
> > When I suspend to disk ('s2disk' from uswsusp), the resume fails if b43
> > is loaded.  The screen stays blank, although I see a cursor flashing.
> > 'modprobe -r b43' before suspending makes the resume work fine, but if I
> > subsequently load b43 after the resume the machine freezes.
> 
> Hm, I use b43 w/ s2disk on a regular basis and it works, but openSUSE has a
> userland suspend hook that disables NetworkManager before  a suspend.
> 
> > I am using Debian Sid, b43 from vanilla kernels from kernel.org (2.6.24
> > isn't in Debian yet).  I have had this problem with -rc4 and -rc8. the
> > only two I've tried.  HW is a 4318 Air Force One, in an Acer Aspire
> > 3690-2672.  Is there any debugging info I can provide?  Is this a known
> > problem?  Is there anything I should try?
> 
> Please try to switch off the interface before suspend without unloading the
> module.

I did 'ifdown eth0' followed by 'ifconfig eth0 down'; I assume that's
what you meant.  I do have some sort of HW switch, but I never touch it.

The machine came up okay.  'ifconfig -a' shows eth0 (unconfigured), but
'ifup eth0' and even 'ifconfig eth0 up' returns 'SIOCSIFFLAGS: no such
device.  lsmod shows that b43 is still there.  When I then did
'modprobe -r b43' followed by 'modprobe b43', the machine froze - no
screen output after the module insertion.


> Also, does s2ram work on your box?

I've never gotten it to resume correctly.  I tried at one time
many / most of the s2ram option suggestions from the
README.s2ram-whitelist, but nothing worked, and I eventually ran out of
patience for the sort of experimenting that required constant hard
power offs and reboots.


> Rafael

Thanks for the help,
Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator



From mb at bu3sch.de  Wed Jan 23 21:44:15 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Wed, 23 Jan 2008 21:44:15 +0100
Subject: [PATCH] b43: Drop packets that we are not able to encrypt
Message-ID: <200801232144.15455.mb@bu3sch.de>

We must not transmit packets we're not able to encrypt.

This fixes a bug where in a tiny timeframe after machine resume
packets can get sent unencrypted and might leak information.

This also fixes three small resource leakages I spotted while fixing
the security problem. Properly deallocate the DMA slots in any DMA
allocation error path.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

This is _not_ only a theoretical problem. I saw a few packets hitting
this race condition.

John, please try to push for 2.6.24, as this is a security fix.

Stefano, this might need porting to legacy.


Index: wireless-2.6/drivers/net/wireless/b43/dma.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/dma.c	2008-01-22 18:43:47.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/dma.c	2008-01-23 21:34:42.000000000 +0100
@@ -1111,38 +1111,49 @@ struct b43_dmaring *parse_cookie(struct 
 static int dma_tx_fragment(struct b43_dmaring *ring,
 			   struct sk_buff *skb,
 			   struct ieee80211_tx_control *ctl)
 {
 	const struct b43_dma_ops *ops = ring->ops;
 	u8 *header;
-	int slot;
+	int slot, old_top_slot, old_used_slots;
 	int err;
 	struct b43_dmadesc_generic *desc;
 	struct b43_dmadesc_meta *meta;
 	struct b43_dmadesc_meta *meta_hdr;
 	struct sk_buff *bounce_skb;
 	u16 cookie;
 	size_t hdrsize = b43_txhdr_size(ring->dev);
 
 #define SLOTS_PER_PACKET  2
 	B43_WARN_ON(skb_shinfo(skb)->nr_frags);
 
+	old_top_slot = ring->current_slot;
+	old_used_slots = ring->used_slots;
+
 	/* Get a slot for the header. */
 	slot = request_slot(ring);
 	desc = ops->idx2desc(ring, slot, &meta_hdr);
 	memset(meta_hdr, 0, sizeof(*meta_hdr));
 
 	header = &(ring->txhdr_cache[slot * hdrsize]);
 	cookie = generate_cookie(ring, slot);
-	b43_generate_txhdr(ring->dev, header,
-			   skb->data, skb->len, ctl, cookie);
+	err = b43_generate_txhdr(ring->dev, header,
+				 skb->data, skb->len, ctl, cookie);
+	if (unlikely(err)) {
+		ring->current_slot = old_top_slot;
+		ring->used_slots = old_used_slots;
+		return err;
+	}
 
 	meta_hdr->dmaaddr = map_descbuffer(ring, (unsigned char *)header,
 					   hdrsize, 1);
-	if (dma_mapping_error(meta_hdr->dmaaddr))
+	if (dma_mapping_error(meta_hdr->dmaaddr)) {
+		ring->current_slot = old_top_slot;
+		ring->used_slots = old_used_slots;
 		return -EIO;
+	}
 	ops->fill_descriptor(ring, desc, meta_hdr->dmaaddr,
 			     hdrsize, 1, 0, 0);
 
 	/* Get a slot for the payload. */
 	slot = request_slot(ring);
 	desc = ops->idx2desc(ring, slot, &meta);
@@ -1154,22 +1165,26 @@ static int dma_tx_fragment(struct b43_dm
 
 	meta->dmaaddr = map_descbuffer(ring, skb->data, skb->len, 1);
 	/* create a bounce buffer in zone_dma on mapping failure. */
 	if (dma_mapping_error(meta->dmaaddr)) {
 		bounce_skb = __dev_alloc_skb(skb->len, GFP_ATOMIC | GFP_DMA);
 		if (!bounce_skb) {
+			ring->current_slot = old_top_slot;
+			ring->used_slots = old_used_slots;
 			err = -ENOMEM;
 			goto out_unmap_hdr;
 		}
 
 		memcpy(skb_put(bounce_skb, skb->len), skb->data, skb->len);
 		dev_kfree_skb_any(skb);
 		skb = bounce_skb;
 		meta->skb = skb;
 		meta->dmaaddr = map_descbuffer(ring, skb->data, skb->len, 1);
 		if (dma_mapping_error(meta->dmaaddr)) {
+			ring->current_slot = old_top_slot;
+			ring->used_slots = old_used_slots;
 			err = -EIO;
 			goto out_free_bounce;
 		}
 	}
 
 	ops->fill_descriptor(ring, desc, meta->dmaaddr, skb->len, 0, 1, 1);
@@ -1249,12 +1264,19 @@ int b43_dma_tx(struct b43_wldev *dev,
 	/* Check if the queue was stopped in mac80211,
 	 * but we got called nevertheless.
 	 * That would be a mac80211 bug. */
 	B43_WARN_ON(ring->stopped);
 
 	err = dma_tx_fragment(ring, skb, ctl);
+	if (unlikely(err == -ENOKEY)) {
+		/* Drop this packet, as we don't have the encryption key
+		 * anymore and must not transmit it unencrypted. */
+		dev_kfree_skb_any(skb);
+		err = 0;
+		goto out_unlock;
+	}
 	if (unlikely(err)) {
 		b43err(dev->wl, "DMA tx mapping failure\n");
 		goto out_unlock;
 	}
 	ring->nr_tx_packets++;
 	if ((free_slots(ring) < SLOTS_PER_PACKET) ||
Index: wireless-2.6/drivers/net/wireless/b43/xmit.c
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.c	2008-01-23 21:02:16.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/xmit.c	2008-01-23 21:34:53.000000000 +0100
@@ -175,18 +175,18 @@ static u8 b43_calc_fallback_rate(u8 bitr
 	}
 	B43_WARN_ON(1);
 	return 0;
 }
 
 /* Generate a TX data header. */
-void b43_generate_txhdr(struct b43_wldev *dev,
-			u8 *_txhdr,
-			const unsigned char *fragment_data,
-			unsigned int fragment_len,
-			const struct ieee80211_tx_control *txctl,
-			u16 cookie)
+int b43_generate_txhdr(struct b43_wldev *dev,
+		       u8 *_txhdr,
+		       const unsigned char *fragment_data,
+		       unsigned int fragment_len,
+		       const struct ieee80211_tx_control *txctl,
+		       u16 cookie)
 {
 	struct b43_txhdr *txhdr = (struct b43_txhdr *)_txhdr;
 	const struct b43_phy *phy = &dev->phy;
 	const struct ieee80211_hdr *wlhdr =
 	    (const struct ieee80211_hdr *)fragment_data;
 	int use_encryption = (!(txctl->flags & IEEE80211_TXCTL_DO_NOT_ENCRYPT));
@@ -235,28 +235,33 @@ void b43_generate_txhdr(struct b43_wldev
 		int wlhdr_len;
 		size_t iv_len;
 
 		B43_WARN_ON(key_idx >= dev->max_nr_keys);
 		key = &(dev->key[key_idx]);
 
-		if (likely(key->keyconf)) {
-			/* This key is valid. Use it for encryption. */
+		if (unlikely(!key->keyconf)) {
+			/* This key is invalid. This might only happen
+			 * in a short timeframe after machine resume before
+			 * we were able to reconfigure keys.
+			 * Drop this packet completely. Do not transmit it
+			 * unencrypted to avoid leaking information. */
+			return -ENOKEY;
+		}
 
-			/* Hardware appends ICV. */
-			plcp_fragment_len += txctl->icv_len;
+		/* Hardware appends ICV. */
+		plcp_fragment_len += txctl->icv_len;
 
-			key_idx = b43_kidx_to_fw(dev, key_idx);
-			mac_ctl |= (key_idx << B43_TXH_MAC_KEYIDX_SHIFT) &
-				   B43_TXH_MAC_KEYIDX;
-			mac_ctl |= (key->algorithm << B43_TXH_MAC_KEYALG_SHIFT) &
-				   B43_TXH_MAC_KEYALG;
-			wlhdr_len = ieee80211_get_hdrlen(fctl);
-			iv_len = min((size_t) txctl->iv_len,
-				     ARRAY_SIZE(txhdr->iv));
-			memcpy(txhdr->iv, ((u8 *) wlhdr) + wlhdr_len, iv_len);
-		}
+		key_idx = b43_kidx_to_fw(dev, key_idx);
+		mac_ctl |= (key_idx << B43_TXH_MAC_KEYIDX_SHIFT) &
+			   B43_TXH_MAC_KEYIDX;
+		mac_ctl |= (key->algorithm << B43_TXH_MAC_KEYALG_SHIFT) &
+			   B43_TXH_MAC_KEYALG;
+		wlhdr_len = ieee80211_get_hdrlen(fctl);
+		iv_len = min((size_t) txctl->iv_len,
+			     ARRAY_SIZE(txhdr->iv));
+		memcpy(txhdr->iv, ((u8 *) wlhdr) + wlhdr_len, iv_len);
 	}
 	if (b43_is_old_txhdr_format(dev)) {
 		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->old_format.plcp),
 				      plcp_fragment_len, rate);
 	} else {
 		b43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->new_format.plcp),
@@ -408,12 +413,13 @@ void b43_generate_txhdr(struct b43_wldev
 
 	/* Apply the bitfields */
 	txhdr->mac_ctl = cpu_to_le32(mac_ctl);
 	txhdr->phy_ctl = cpu_to_le16(phy_ctl);
 	txhdr->extra_ft = extra_ft;
 
+	return 0;
 }
 
 static s8 b43_rssi_postprocess(struct b43_wldev *dev,
 			       u8 in_rssi, int ofdm,
 			       int adjust_2053, int adjust_2050)
 {
Index: wireless-2.6/drivers/net/wireless/b43/xmit.h
===================================================================
--- wireless-2.6.orig/drivers/net/wireless/b43/xmit.h	2008-01-23 12:38:42.000000000 +0100
+++ wireless-2.6/drivers/net/wireless/b43/xmit.h	2008-01-23 21:13:02.000000000 +0100
@@ -171,17 +171,17 @@ size_t b43_txhdr_size(struct b43_wldev *
 	if (b43_is_old_txhdr_format(dev))
 		return 100 + sizeof(struct b43_plcp_hdr6);
 	return 104 + sizeof(struct b43_plcp_hdr6);
 }
 
 
-void b43_generate_txhdr(struct b43_wldev *dev,
-			u8 * txhdr,
-			const unsigned char *fragment_data,
-			unsigned int fragment_len,
-			const struct ieee80211_tx_control *txctl, u16 cookie);
+int b43_generate_txhdr(struct b43_wldev *dev,
+		       u8 * txhdr,
+		       const unsigned char *fragment_data,
+		       unsigned int fragment_len,
+		       const struct ieee80211_tx_control *txctl, u16 cookie);
 
 /* Transmit Status */
 struct b43_txstatus {
 	u16 cookie;		/* The cookie from the txhdr */
 	u16 seq;		/* Sequence number */
 	u8 phy_stat;		/* PHY TX status */


From rjw at sisk.pl  Thu Jan 24 00:18:00 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Thu, 24 Jan 2008 00:18:00 +0100
Subject: resuming from suspend to disk not working with b43
In-Reply-To: <20080123152736.c3a0833b.celejar@gmail.com>
References: <20080122204504.854f41a5.celejar@gmail.com>
	<200801231600.16275.rjw@sisk.pl>
	<20080123152736.c3a0833b.celejar@gmail.com>
Message-ID: <200801240018.00930.rjw@sisk.pl>

On Wednesday, 23 of January 2008, Celejar wrote:
> On Wed, 23 Jan 2008 16:00:15 +0100
> "Rafael J. Wysocki" <rjw at sisk.pl> wrote:
> 
> > On Wednesday, 23 of January 2008, Celejar wrote:
> > > Hi,
> > 
> > Hi,
> >  
> > > I know there's an ongoing long thread about suspend in b43, but
> > > the technical level has been above me, and I don't know if anything
> > > there is relevant to me.
> > > 
> > > When I suspend to disk ('s2disk' from uswsusp), the resume fails if b43
> > > is loaded.  The screen stays blank, although I see a cursor flashing.
> > > 'modprobe -r b43' before suspending makes the resume work fine, but if I
> > > subsequently load b43 after the resume the machine freezes.
> > 
> > Hm, I use b43 w/ s2disk on a regular basis and it works, but openSUSE has a
> > userland suspend hook that disables NetworkManager before  a suspend.
> > 
> > > I am using Debian Sid, b43 from vanilla kernels from kernel.org (2.6.24
> > > isn't in Debian yet).  I have had this problem with -rc4 and -rc8. the
> > > only two I've tried.  HW is a 4318 Air Force One, in an Acer Aspire
> > > 3690-2672.  Is there any debugging info I can provide?  Is this a known
> > > problem?  Is there anything I should try?
> > 
> > Please try to switch off the interface before suspend without unloading the
> > module.
> 
> I did 'ifdown eth0' followed by 'ifconfig eth0 down'; I assume that's
> what you meant.  I do have some sort of HW switch, but I never touch it.
> 
> The machine came up okay.  'ifconfig -a' shows eth0 (unconfigured), but
> 'ifup eth0' and even 'ifconfig eth0 up' returns 'SIOCSIFFLAGS: no such
> device.  lsmod shows that b43 is still there.  When I then did
> 'modprobe -r b43' followed by 'modprobe b43', the machine froze - no
> screen output after the module insertion.

When 2.6.24 is out, please test it, but make sure you don't set
USB_OHCI_HCD_SSB.

> > Also, does s2ram work on your box?
> 
> I've never gotten it to resume correctly.  I tried at one time
> many / most of the s2ram option suggestions from the
> README.s2ram-whitelist, but nothing worked, and I eventually ran out of
> patience for the sort of experimenting that required constant hard
> power offs and reboots.

There are some suspend debug patches scheduled for 2.6.25 time frame.  If they
get merged, we'll be able to check what's going wrong here.

Thanks,
Rafael


From johannes at sipsolutions.net  Thu Jan 24 10:13:01 2008
From: johannes at sipsolutions.net (Johannes Berg)
Date: Thu, 24 Jan 2008 10:13:01 +0100
Subject: [PATCH] b43: Fix MAC control and microcode init
In-Reply-To: <200801222023.35131.mb@bu3sch.de>
	(sfid-20080122_192602_244741_E21941C1)
References: <200801222023.35131.mb@bu3sch.de>
	(sfid-20080122_192602_244741_E21941C1)
Message-ID: <1201165981.3454.49.camel@johannes.berg>


> This also adds a longer delay for waiting for the microcode
> to initialize itself. It seems that the current timeout is sufficient
> on all available devices, but there's no real reason why we shouldn't
> wait for up to one second. Slow embedded devices might exist.

Your decision, but I very much doubt you can make the MAC any slower
than on the old devices, in fact, on new chips it runs considerably
faster I think.

johannes
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 828 bytes
Desc: This is a digitally signed message part
URL: <https://lists.berlios.de/pipermail/bcm43xx-dev/attachments/20080124/deb36d70/attachment.pgp>

From mb at bu3sch.de  Thu Jan 24 23:03:36 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Thu, 24 Jan 2008 23:03:36 +0100
Subject: [PATCH] b43: Fix MAC control and microcode init
In-Reply-To: <1201165981.3454.49.camel@johannes.berg>
References: <200801222023.35131.mb@bu3sch.de>
	<1201165981.3454.49.camel@johannes.berg>
Message-ID: <200801242303.36694.mb@bu3sch.de>

On Thursday 24 January 2008 10:13:01 Johannes Berg wrote:
> 
> > This also adds a longer delay for waiting for the microcode
> > to initialize itself. It seems that the current timeout is sufficient
> > on all available devices, but there's no real reason why we shouldn't
> > wait for up to one second. Slow embedded devices might exist.
> 
> Your decision, but I very much doubt you can make the MAC any slower
> than on the old devices, in fact, on new chips it runs considerably
> faster I think.

Ok, well. But the host machine does get faster. In theory we only
gave the microcode 500 microseconds of time to initialize. I think
that is is a pretty tiny timeframe. In practice the time was higher,
because we had a loop that checked MMIO and delayed for 10usec.
Of course this all has overhead. But as machines get faster and faster
I think we can't assume to have more than 500 microseconds of time.

So, increasing the delay to one second doesn't hurt anyone. In
all common cases it will continue after a few milliseconds. That's fine.
Even if there is something going wrong (wrong firmware) you can
interrupt the one second delay by hitting ^C.

I think the specs originally sayed to use a much longer delay than
we were using. But we did use a shorter delay, because in some old
bcm43xx code this ran unter spinlock as far as I remember. So we didn't
want to spin several milliseconds and lockup the system, if something
goes wrong in firmware. These times are gone and now we can sleep
in this part of the code.

-- 
Greetings Michael.


From rjw at sisk.pl  Fri Jan 25 01:27:20 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Fri, 25 Jan 2008 01:27:20 +0100
Subject: [PATCH -mm 0/5] b43: Fix suspend/resume deadlock
Message-ID: <200801250127.21966.rjw@sisk.pl>

Hi,

The following series of patches is intended to fix the suspend/resume deadlock
occuring as a result of unregistering device objects, locked by the PM core,
during suspend/resume cycles by the b43 driver.

In short, the b43 driver is modified to avoid unregistering device objects
during suspend/resume cycles except for the resume code path, in which the
devices are unregistered using the recently introduced suspend-safe method.
For this purpose, it is necessary to introduce the possibility to safely remove
misc devices, leds classdevs and hwrng devices during suspend/resume cycles
(patches 2/5, 4/5, 3/5, respectively).

Please consider for applying.

Thanks,
Rafael



From rjw at sisk.pl  Fri Jan 25 01:30:25 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Fri, 25 Jan 2008 01:30:25 +0100
Subject: [PATCH -mm 1/5] PM: Export device_pm_schedule_removal
In-Reply-To: <200801250127.21966.rjw@sisk.pl>
References: <200801250127.21966.rjw@sisk.pl>
Message-ID: <200801250130.26591.rjw@sisk.pl>

From: Rafael J. Wysocki <rjw at sisk.pl>

Move the declaration of device_pm_schedule_removal() to device.h
and make it exported, as it will be used directly by some drivers
for unregistering device objects during suspend/resume cycles in a
safe way.

Signed-off-by: Rafael J. Wysocki <rjw at sisk.pl>
---
 drivers/base/power/main.c  |    1 +
 drivers/base/power/power.h |    1 -
 include/linux/device.h     |    6 ++++++
 3 files changed, 7 insertions(+), 1 deletion(-)

Index: linux-2.6.24-rc8-mm1/drivers/base/power/main.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/base/power/main.c
+++ linux-2.6.24-rc8-mm1/drivers/base/power/main.c
@@ -129,6 +129,7 @@ void device_pm_schedule_removal(struct d
 	list_move_tail(&dev->power.entry, &dpm_destroy);
 	mutex_unlock(&dpm_list_mtx);
 }
+EXPORT_SYMBOL_GPL(device_pm_schedule_removal);
 
 /**
  *	pm_sleep_lock - mutual exclusion for registration and suspend
Index: linux-2.6.24-rc8-mm1/include/linux/device.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/device.h
+++ linux-2.6.24-rc8-mm1/include/linux/device.h
@@ -532,11 +532,17 @@ extern struct device *device_create(stru
 extern void device_destroy(struct class *cls, dev_t devt);
 #ifdef CONFIG_PM_SLEEP
 extern void destroy_suspended_device(struct class *cls, dev_t devt);
+extern void device_pm_schedule_removal(struct device *);
 #else /* !CONFIG_PM_SLEEP */
 static inline void destroy_suspended_device(struct class *cls, dev_t devt)
 {
 	device_destroy(cls, devt);
 }
+
+static inline void device_pm_schedule_removal(struct device *dev)
+{
+	device_unregister(dev);
+}
 #endif /* !CONFIG_PM_SLEEP */
 
 /*
Index: linux-2.6.24-rc8-mm1/drivers/base/power/power.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/base/power/power.h
+++ linux-2.6.24-rc8-mm1/drivers/base/power/power.h
@@ -13,7 +13,6 @@ static inline struct device *to_device(s
 
 extern void device_pm_add(struct device *);
 extern void device_pm_remove(struct device *);
-extern void device_pm_schedule_removal(struct device *);
 extern int pm_sleep_lock(void);
 extern void pm_sleep_unlock(void);
 


From rjw at sisk.pl  Fri Jan 25 01:37:33 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Fri, 25 Jan 2008 01:37:33 +0100
Subject: [PATCH -mm 5/5] b43: Avoid unregistering device objects during suspend
In-Reply-To: <200801250127.21966.rjw@sisk.pl>
References: <200801250127.21966.rjw@sisk.pl>
Message-ID: <200801250137.34275.rjw@sisk.pl>

From: Rafael J. Wysocki <rjw at sisk.pl>

Modify the b43 driver to avoid deadlocking suspend and resume,
which happens as a result of attempting to unregister device objects
locked by the PM core during suspend/resume cycles.  Also, make it
use a suspend-safe method of unregistering device object in the
resume error path.

Signed-off-by: Rafael J. Wysocki <rjw at sisk.pl>
Acked-by: Michael Buesch <mb at bu3sch.de>
---
 drivers/net/wireless/b43/b43.h  |    1 +
 drivers/net/wireless/b43/leds.c |    5 ++++-
 drivers/net/wireless/b43/main.c |   25 ++++++++++++++++---------
 3 files changed, 21 insertions(+), 10 deletions(-)

Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/b43.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/b43.h
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/b43.h
@@ -706,6 +706,7 @@ struct b43_wldev {
 	bool short_preamble;	/* TRUE, if short preamble is enabled. */
 	bool short_slot;	/* TRUE, if short slot timing is enabled. */
 	bool radio_hw_enable;	/* saved state of radio hardware enabled state */
+	bool suspend_in_progress;	/* TRUE, if we are in a suspend/resume cycle */
 
 	/* PHY/Radio device. */
 	struct b43_phy phy;
Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/main.c
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/main.c
@@ -2470,10 +2470,10 @@ static int b43_rng_read(struct hwrng *rn
 	return (sizeof(u16));
 }
 
-static void b43_rng_exit(struct b43_wl *wl)
+static void b43_rng_exit(struct b43_wl *wl, bool suspended)
 {
 	if (wl->rng_initialized)
-		hwrng_unregister(&wl->rng);
+		__hwrng_unregister(&wl->rng, suspended);
 }
 
 static int b43_rng_init(struct b43_wl *wl)
@@ -3298,8 +3298,10 @@ static void b43_wireless_core_exit(struc
 		return;
 	b43_set_status(dev, B43_STAT_UNINIT);
 
-	b43_leds_exit(dev);
-	b43_rng_exit(dev->wl);
+	if (!dev->suspend_in_progress) {
+		b43_leds_exit(dev);
+		b43_rng_exit(dev->wl, false);
+	}
 	b43_pio_free(dev);
 	b43_dma_free(dev);
 	b43_chip_exit(dev);
@@ -3420,11 +3422,13 @@ static int b43_wireless_core_init(struct
 	memset(wl->mac_addr, 0, ETH_ALEN);
 	b43_upload_card_macaddress(dev);
 	b43_security_init(dev);
-	b43_rng_init(wl);
+	if (!dev->suspend_in_progress)
+		b43_rng_init(wl);
 
 	b43_set_status(dev, B43_STAT_INITIALIZED);
 
-	b43_leds_init(dev);
+	if (!dev->suspend_in_progress)
+		b43_leds_init(dev);
 out:
 	return err;
 
@@ -4024,6 +4028,7 @@ static int b43_suspend(struct ssb_device
 	b43dbg(wl, "Suspending...\n");
 
 	mutex_lock(&wl->mutex);
+	wldev->suspend_in_progress = true;
 	wldev->suspend_init_status = b43_status(wldev);
 	if (wldev->suspend_init_status >= B43_STAT_STARTED)
 		b43_wireless_core_stop(wldev);
@@ -4055,15 +4060,17 @@ static int b43_resume(struct ssb_device 
 	if (wldev->suspend_init_status >= B43_STAT_STARTED) {
 		err = b43_wireless_core_start(wldev);
 		if (err) {
+			b43_leds_exit(wldev);
+			b43_rng_exit(wldev->wl, true);
 			b43_wireless_core_exit(wldev);
 			b43err(wl, "Resume failed at core start\n");
 			goto out;
 		}
 	}
-	mutex_unlock(&wl->mutex);
-
 	b43dbg(wl, "Device resumed.\n");
-      out:
+ out:
+	wldev->suspend_in_progress = false;
+	mutex_unlock(&wl->mutex);
 	return err;
 }
 
Index: linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/net/wireless/b43/leds.c
+++ linux-2.6.24-rc8-mm1/drivers/net/wireless/b43/leds.c
@@ -116,7 +116,10 @@ static void b43_unregister_led(struct b4
 {
 	if (!led->dev)
 		return;
-	led_classdev_unregister(&led->led_dev);
+	if (led->dev->suspend_in_progress)
+		led_classdev_unregister_suspended(&led->led_dev);
+	else
+		led_classdev_unregister(&led->led_dev);
 	b43_led_turn_off(led->dev, led->index, led->activelow);
 	led->dev = NULL;
 }


From rjw at sisk.pl  Fri Jan 25 01:35:24 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Fri, 25 Jan 2008 01:35:24 +0100
Subject: [PATCH -mm 3/5] HWRNG: Add possibility to remove hwrng devices during
	suspend/resume
In-Reply-To: <200801250127.21966.rjw@sisk.pl>
References: <200801250127.21966.rjw@sisk.pl>
Message-ID: <200801250135.26009.rjw@sisk.pl>

From: Rafael J. Wysocki <rjw at sisk.pl>

Make it possible to unregister a Hardware Random Number Generator
device object in a safe way during a suspend/resume cycle.

Signed-off-by: Rafael J. Wysocki <rjw at sisk.pl>
Acked-by: Michael Buesch <mb at bu3sch.de>
---
 drivers/char/hw_random/core.c |   10 +++++-----
 include/linux/hw_random.h     |   10 +++++++++-
 2 files changed, 14 insertions(+), 6 deletions(-)

Index: linux-2.6.24-rc8-mm1/drivers/char/hw_random/core.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/char/hw_random/core.c
+++ linux-2.6.24-rc8-mm1/drivers/char/hw_random/core.c
@@ -234,11 +234,11 @@ static DEVICE_ATTR(rng_available, S_IRUG
 		   NULL);
 
 
-static void unregister_miscdev(void)
+static void unregister_miscdev(bool suspended)
 {
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_available);
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
-	misc_deregister(&rng_miscdev);
+	__misc_deregister(&rng_miscdev, suspended);
 }
 
 static int register_miscdev(void)
@@ -313,7 +313,7 @@ out:
 }
 EXPORT_SYMBOL_GPL(hwrng_register);
 
-void hwrng_unregister(struct hwrng *rng)
+void __hwrng_unregister(struct hwrng *rng, bool suspended)
 {
 	int err;
 
@@ -332,11 +332,11 @@ void hwrng_unregister(struct hwrng *rng)
 		}
 	}
 	if (list_empty(&rng_list))
-		unregister_miscdev();
+		unregister_miscdev(suspended);
 
 	mutex_unlock(&rng_mutex);
 }
-EXPORT_SYMBOL_GPL(hwrng_unregister);
+EXPORT_SYMBOL_GPL(__hwrng_unregister);
 
 
 MODULE_DESCRIPTION("H/W Random Number Generator (RNG) driver");
Index: linux-2.6.24-rc8-mm1/include/linux/hw_random.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/hw_random.h
+++ linux-2.6.24-rc8-mm1/include/linux/hw_random.h
@@ -44,7 +44,15 @@ struct hwrng {
 /** Register a new Hardware Random Number Generator driver. */
 extern int hwrng_register(struct hwrng *rng);
 /** Unregister a Hardware Random Number Generator driver. */
-extern void hwrng_unregister(struct hwrng *rng);
+extern void __hwrng_unregister(struct hwrng *rng, bool suspended);
+static inline void hwrng_unregister(struct hwrng *rng)
+{
+	__hwrng_unregister(rng, false);
+}
+static inline void hwrng_unregister_suspended(struct hwrng *rng)
+{
+	__hwrng_unregister(rng, true);
+}
 
 #endif /* __KERNEL__ */
 #endif /* LINUX_HWRANDOM_H_ */



From rjw at sisk.pl  Fri Jan 25 01:36:29 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Fri, 25 Jan 2008 01:36:29 +0100
Subject: [PATCH -mm 4/5] Leds: Add possibility to remove leds classdevs during
	suspend/resume
In-Reply-To: <200801250127.21966.rjw@sisk.pl>
References: <200801250127.21966.rjw@sisk.pl>
Message-ID: <200801250136.30292.rjw@sisk.pl>

From: Rafael J. Wysocki <rjw at sisk.pl>

Make it possible to unregister a led classdev object in a safe way
during a suspend/resume cycle.

Signed-off-by: Rafael J. Wysocki <rjw at sisk.pl>
---
 drivers/leds/led-class.c |   13 +++++++++----
 include/linux/leds.h     |   10 +++++++++-
 2 files changed, 18 insertions(+), 5 deletions(-)

Index: linux-2.6.24-rc8-mm1/drivers/leds/led-class.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/leds/led-class.c
+++ linux-2.6.24-rc8-mm1/drivers/leds/led-class.c
@@ -137,12 +137,14 @@ err_out:
 EXPORT_SYMBOL_GPL(led_classdev_register);
 
 /**
- * led_classdev_unregister - unregisters a object of led_properties class.
+ * __led_classdev_unregister - unregisters a object of led_properties class.
  * @led_cdev: the led device to unregister
+ * @suspended: indicates whether system-wide suspend or resume is in progress
  *
  * Unregisters a previously registered via led_classdev_register object.
  */
-void led_classdev_unregister(struct led_classdev *led_cdev)
+void __led_classdev_unregister(struct led_classdev *led_cdev,
+				      bool suspended)
 {
 	device_remove_file(led_cdev->dev, &dev_attr_brightness);
 #ifdef CONFIG_LEDS_TRIGGERS
@@ -153,13 +155,16 @@ void led_classdev_unregister(struct led_
 	up_write(&led_cdev->trigger_lock);
 #endif
 
-	device_unregister(led_cdev->dev);
+	if (suspended)
+		device_pm_schedule_removal(led_cdev->dev);
+	else
+		device_unregister(led_cdev->dev);
 
 	down_write(&leds_list_lock);
 	list_del(&led_cdev->node);
 	up_write(&leds_list_lock);
 }
-EXPORT_SYMBOL_GPL(led_classdev_unregister);
+EXPORT_SYMBOL_GPL(__led_classdev_unregister);
 
 static int __init leds_init(void)
 {
Index: linux-2.6.24-rc8-mm1/include/linux/leds.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/leds.h
+++ linux-2.6.24-rc8-mm1/include/linux/leds.h
@@ -59,7 +59,15 @@ struct led_classdev {
 
 extern int led_classdev_register(struct device *parent,
 				 struct led_classdev *led_cdev);
-extern void led_classdev_unregister(struct led_classdev *led_cdev);
+extern void __led_classdev_unregister(struct led_classdev *led_cdev, bool sus);
+static inline void led_classdev_unregister(struct led_classdev *lcd)
+{
+	__led_classdev_unregister(lcd, false);
+}
+static inline void led_classdev_unregister_suspended(struct led_classdev *lcd)
+{
+	__led_classdev_unregister(lcd, true);
+}
 extern void led_classdev_suspend(struct led_classdev *led_cdev);
 extern void led_classdev_resume(struct led_classdev *led_cdev);
 



From rjw at sisk.pl  Fri Jan 25 01:31:49 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Fri, 25 Jan 2008 01:31:49 +0100
Subject: [PATCH -mm 2/5] Misc: Add possibility to remove misc devices during
	suspend/resume
In-Reply-To: <200801250127.21966.rjw@sisk.pl>
References: <200801250127.21966.rjw@sisk.pl>
Message-ID: <200801250131.50924.rjw@sisk.pl>

From: Rafael J. Wysocki <rjw at sisk.pl>

Make it possible to unregister a misc device object in a safe way
during a suspend/resume cycle.

Signed-off-by: Rafael J. Wysocki <rjw at sisk.pl>
---
 drivers/char/misc.c        |   13 +++++++++----
 include/linux/miscdevice.h |   10 +++++++++-
 2 files changed, 18 insertions(+), 5 deletions(-)

Index: linux-2.6.24-rc8-mm1/include/linux/miscdevice.h
===================================================================
--- linux-2.6.24-rc8-mm1.orig/include/linux/miscdevice.h
+++ linux-2.6.24-rc8-mm1/include/linux/miscdevice.h
@@ -43,7 +43,15 @@ struct miscdevice  {
 };
 
 extern int misc_register(struct miscdevice * misc);
-extern int misc_deregister(struct miscdevice * misc);
+extern int __misc_deregister(struct miscdevice *misc, bool suspended);
+static inline int misc_deregister(struct miscdevice *misc)
+{
+	return __misc_deregister(misc, false);
+}
+static inline int misc_deregister_suspended(struct miscdevice *misc)
+{
+	return __misc_deregister(misc, true);
+}
 
 #define MODULE_ALIAS_MISCDEV(minor)				\
 	MODULE_ALIAS("char-major-" __stringify(MISC_MAJOR)	\
Index: linux-2.6.24-rc8-mm1/drivers/char/misc.c
===================================================================
--- linux-2.6.24-rc8-mm1.orig/drivers/char/misc.c
+++ linux-2.6.24-rc8-mm1/drivers/char/misc.c
@@ -232,8 +232,9 @@ int misc_register(struct miscdevice * mi
 }
 
 /**
- *	misc_deregister - unregister a miscellaneous device
+ *	__misc_deregister - unregister a miscellaneous device
  *	@misc: device to unregister
+ *	@suspended: to be set if the function is used during suspend/resume
  *
  *	Unregister a miscellaneous device that was previously
  *	successfully registered with misc_register(). Success
@@ -241,7 +242,7 @@ int misc_register(struct miscdevice * mi
  *	indicates an error.
  */
 
-int misc_deregister(struct miscdevice * misc)
+int __misc_deregister(struct miscdevice *misc, bool suspended)
 {
 	int i = misc->minor;
 
@@ -250,7 +251,11 @@ int misc_deregister(struct miscdevice * 
 
 	mutex_lock(&misc_mtx);
 	list_del(&misc->list);
-	device_destroy(misc_class, MKDEV(MISC_MAJOR, misc->minor));
+	if (suspended)
+		destroy_suspended_device(misc_class,
+					MKDEV(MISC_MAJOR, misc->minor));
+	else
+		device_destroy(misc_class, MKDEV(MISC_MAJOR, misc->minor));
 	if (i < DYNAMIC_MINORS && i>0) {
 		misc_minors[i>>3] &= ~(1 << (misc->minor & 7));
 	}
@@ -259,7 +264,7 @@ int misc_deregister(struct miscdevice * 
 }
 
 EXPORT_SYMBOL(misc_register);
-EXPORT_SYMBOL(misc_deregister);
+EXPORT_SYMBOL(__misc_deregister);
 
 static int __init misc_init(void)
 {



From mb at bu3sch.de  Fri Jan 25 11:13:30 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 25 Jan 2008 11:13:30 +0100
Subject: [PATCH -mm 5/5] b43: Avoid unregistering device objects during
	suspend
In-Reply-To: <20080125074746.GC4134@ucw.cz>
References: <200801250127.21966.rjw@sisk.pl> <200801250137.34275.rjw@sisk.pl>
	<20080125074746.GC4134@ucw.cz>
Message-ID: <200801251113.31325.mb@bu3sch.de>

On Friday 25 January 2008 08:47:46 Pavel Machek wrote:
> On Fri 2008-01-25 01:37:33, Rafael J. Wysocki wrote:
> > From: Rafael J. Wysocki <rjw at sisk.pl>
> > 
> > Modify the b43 driver to avoid deadlocking suspend and resume,
> > which happens as a result of attempting to unregister device objects
> > locked by the PM core during suspend/resume cycles.  Also, make it
> > use a suspend-safe method of unregistering device object in the
> > resume error path.
> > 
> > Signed-off-by: Rafael J. Wysocki <rjw at sisk.pl>
> > Acked-by: Michael Buesch <mb at bu3sch.de>
> 
> Maybe we should have global suspend_in_progress (or maybe system_state
> == suspending?) and automatically switch to schedule_removal() while
> it is set?
> 

That would be great, from my perspective :)

-- 
Greetings Michael.


From mb at bu3sch.de  Fri Jan 25 12:15:07 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 25 Jan 2008 12:15:07 +0100
Subject: [PATCH stable 2/3] b43: Drop packets we are not able to encrypt
Message-ID: <200801251215.08164.mb@bu3sch.de>

We must drop any packets we are not able to encrypt.
We must not send them unencrypted or with an all-zero-key (which
basically is the same as unencrypted, from a security point of view).

This might only trigger shortly after resume before mac80211 reassociated
and reconfigured the keys.

It is safe to drop these packets, as the association they belong to
is not guaranteed anymore anyway.
This is a security fix in the sense that it prevents information leakage.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

This patch is upstream inside of the netdev tree.


Index: linux-2.6.24/drivers/net/wireless/b43/dma.c
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43/dma.c	2008-01-25 11:48:25.000000000 +0100
+++ linux-2.6.24/drivers/net/wireless/b43/dma.c	2008-01-25 11:48:31.000000000 +0100
@@ -1122,9 +1122,11 @@ static int dma_tx_fragment(struct b43_dm
 	memset(meta_hdr, 0, sizeof(*meta_hdr));
 
 	header = &(ring->txhdr_cache[slot * sizeof(struct b43_txhdr_fw4)]);
-	b43_generate_txhdr(ring->dev, header,
+	err = b43_generate_txhdr(ring->dev, header,
 			   skb->data, skb->len, ctl,
 			   generate_cookie(ring, slot));
+	if (unlikely(err))
+		return err;
 
 	meta_hdr->dmaaddr = map_descbuffer(ring, (unsigned char *)header,
 					   sizeof(struct b43_txhdr_fw4), 1);
@@ -1219,6 +1221,13 @@ int b43_dma_tx(struct b43_wldev *dev,
 	B43_WARN_ON(ring->stopped);
 
 	err = dma_tx_fragment(ring, skb, ctl);
+	if (unlikely(err == -ENOKEY)) {
+		/* Drop this packet, as we don't have the encryption key
+		 * anymore and must not transmit it unencrypted. */
+		dev_kfree_skb_any(skb);
+		err = 0;
+		goto out_unlock;
+	}
 	if (unlikely(err)) {
 		b43err(dev->wl, "DMA tx mapping failure\n");
 		goto out_unlock;
Index: linux-2.6.24/drivers/net/wireless/b43/xmit.c
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43/xmit.c	2008-01-25 11:48:25.000000000 +0100
+++ linux-2.6.24/drivers/net/wireless/b43/xmit.c	2008-01-25 11:48:31.000000000 +0100
@@ -177,7 +177,7 @@ static u8 b43_calc_fallback_rate(u8 bitr
 	return 0;
 }
 
-static void generate_txhdr_fw4(struct b43_wldev *dev,
+static int generate_txhdr_fw4(struct b43_wldev *dev,
 			       struct b43_txhdr_fw4 *txhdr,
 			       const unsigned char *fragment_data,
 			       unsigned int fragment_len,
@@ -235,7 +235,15 @@ static void generate_txhdr_fw4(struct b4
 
 		B43_WARN_ON(key_idx >= dev->max_nr_keys);
 		key = &(dev->key[key_idx]);
-		B43_WARN_ON(!key->keyconf);
+
+		if (unlikely(!key->keyconf)) {
+			/* This key is invalid. This might only happen
+			 * in a short timeframe after machine resume before
+			 * we were able to reconfigure keys.
+			 * Drop this packet completely. Do not transmit it
+			 * unencrypted to avoid leaking information. */
+			return -ENOKEY;
+		}
 
 		/* Hardware appends ICV. */
 		plcp_fragment_len += txctl->icv_len;
@@ -352,16 +360,18 @@ static void generate_txhdr_fw4(struct b4
 	txhdr->mac_ctl = cpu_to_le32(mac_ctl);
 	txhdr->phy_ctl = cpu_to_le16(phy_ctl);
 	txhdr->extra_ft = extra_ft;
+
+	return 0;
 }
 
-void b43_generate_txhdr(struct b43_wldev *dev,
+int b43_generate_txhdr(struct b43_wldev *dev,
 			u8 * txhdr,
 			const unsigned char *fragment_data,
 			unsigned int fragment_len,
 			const struct ieee80211_tx_control *txctl, u16 cookie)
 {
-	generate_txhdr_fw4(dev, (struct b43_txhdr_fw4 *)txhdr,
-			   fragment_data, fragment_len, txctl, cookie);
+	return generate_txhdr_fw4(dev, (struct b43_txhdr_fw4 *)txhdr,
+				  fragment_data, fragment_len, txctl, cookie);
 }
 
 static s8 b43_rssi_postprocess(struct b43_wldev *dev,
Index: linux-2.6.24/drivers/net/wireless/b43/xmit.h
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43/xmit.h	2008-01-25 11:48:25.000000000 +0100
+++ linux-2.6.24/drivers/net/wireless/b43/xmit.h	2008-01-25 11:48:31.000000000 +0100
@@ -82,7 +82,7 @@ struct b43_txhdr_fw4 {
 #define  B43_TX4_PHY_ANT1		0x0100	/* Use antenna 1 */
 #define  B43_TX4_PHY_ANTLAST	0x0300	/* Use last used antenna */
 
-void b43_generate_txhdr(struct b43_wldev *dev,
+int b43_generate_txhdr(struct b43_wldev *dev,
 			u8 * txhdr,
 			const unsigned char *fragment_data,
 			unsigned int fragment_len,


From mb at bu3sch.de  Fri Jan 25 12:11:45 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 25 Jan 2008 12:11:45 +0100
Subject: [PATCH stable 1/3] b43: Fix suspend/resume
Message-ID: <200801251211.45980.mb@bu3sch.de>

This patch makes suspend/resume work with the b43 driver.
We must not overwrite the MAC addresses in the init function, as this
would also overwrite the MAC on resume. With an all-zero MAC the device
firmware is not able to ACK any received packets anymore.
Fix this by moving the initializion stuff that must be done on init but
not on resume to the start function.
Also zero out filter_flags to make sure we don't have some flags
from a previous instance for a tiny timeframe until mac80211 reconfigures
them.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

This patch is upstream inside of the netdev tree.


Index: linux-2.6.24/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43/main.c	2008-01-25 11:48:26.000000000 +0100
+++ linux-2.6.24/drivers/net/wireless/b43/main.c	2008-01-25 11:48:28.000000000 +0100
@@ -3395,8 +3395,6 @@ static int b43_wireless_core_init(struct
 	b43_bluetooth_coext_enable(dev);
 
 	ssb_bus_powerup(bus, 1);	/* Enable dynamic PCTL */
-	memset(wl->bssid, 0, ETH_ALEN);
-	memset(wl->mac_addr, 0, ETH_ALEN);
 	b43_upload_card_macaddress(dev);
 	b43_security_init(dev);
 	b43_rng_init(wl);
@@ -3493,6 +3491,13 @@ static int b43_start(struct ieee80211_hw
 	int did_init = 0;
 	int err = 0;
 
+	/* Kill all old instance specific information to make sure
+	 * the card won't use it in the short timeframe between start
+	 * and mac80211 reconfiguring it. */
+	memset(wl->bssid, 0, ETH_ALEN);
+	memset(wl->mac_addr, 0, ETH_ALEN);
+	wl->filter_flags = 0;
+
 	/* First register RFkill.
 	 * LEDs that are registered later depend on it. */
 	b43_rfkill_init(dev);


From mb at bu3sch.de  Fri Jan 25 12:20:20 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Fri, 25 Jan 2008 12:20:20 +0100
Subject: [PATCH stable 3/3] b43: Fix dma-slot resource leakage
Message-ID: <200801251220.20332.mb@bu3sch.de>

This fixes four resource leakages.
In any error path we must deallocate the DMA frame slots we
previously allocated by request_slot().
This is done by storing the ring pointers before doing any ring
allocation and restoring the old pointers in case of an error.

Signed-off-by: Michael Buesch <mb at bu3sch.de>

---

This patch is upstream inside of the netdev tree.


Index: linux-2.6.24/drivers/net/wireless/b43/dma.c
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43/dma.c	2008-01-25 11:48:31.000000000 +0100
+++ linux-2.6.24/drivers/net/wireless/b43/dma.c	2008-01-25 11:48:34.000000000 +0100
@@ -1106,7 +1106,7 @@ static int dma_tx_fragment(struct b43_dm
 {
 	const struct b43_dma_ops *ops = ring->ops;
 	u8 *header;
-	int slot;
+	int slot, old_top_slot, old_used_slots;
 	int err;
 	struct b43_dmadesc_generic *desc;
 	struct b43_dmadesc_meta *meta;
@@ -1116,6 +1116,9 @@ static int dma_tx_fragment(struct b43_dm
 #define SLOTS_PER_PACKET  2
 	B43_WARN_ON(skb_shinfo(skb)->nr_frags);
 
+	old_top_slot = ring->current_slot;
+	old_used_slots = ring->used_slots;
+
 	/* Get a slot for the header. */
 	slot = request_slot(ring);
 	desc = ops->idx2desc(ring, slot, &meta_hdr);
@@ -1125,13 +1128,19 @@ static int dma_tx_fragment(struct b43_dm
 	err = b43_generate_txhdr(ring->dev, header,
 			   skb->data, skb->len, ctl,
 			   generate_cookie(ring, slot));
-	if (unlikely(err))
+	if (unlikely(err)) {
+		ring->current_slot = old_top_slot;
+		ring->used_slots = old_used_slots;
 		return err;
+	}
 
 	meta_hdr->dmaaddr = map_descbuffer(ring, (unsigned char *)header,
 					   sizeof(struct b43_txhdr_fw4), 1);
-	if (dma_mapping_error(meta_hdr->dmaaddr))
+	if (dma_mapping_error(meta_hdr->dmaaddr)) {
+		ring->current_slot = old_top_slot;
+		ring->used_slots = old_used_slots;
 		return -EIO;
+	}
 	ops->fill_descriptor(ring, desc, meta_hdr->dmaaddr,
 			     sizeof(struct b43_txhdr_fw4), 1, 0, 0);
 
@@ -1149,6 +1158,8 @@ static int dma_tx_fragment(struct b43_dm
 	if (dma_mapping_error(meta->dmaaddr)) {
 		bounce_skb = __dev_alloc_skb(skb->len, GFP_ATOMIC | GFP_DMA);
 		if (!bounce_skb) {
+			ring->current_slot = old_top_slot;
+			ring->used_slots = old_used_slots;
 			err = -ENOMEM;
 			goto out_unmap_hdr;
 		}
@@ -1159,6 +1170,8 @@ static int dma_tx_fragment(struct b43_dm
 		meta->skb = skb;
 		meta->dmaaddr = map_descbuffer(ring, skb->data, skb->len, 1);
 		if (dma_mapping_error(meta->dmaaddr)) {
+			ring->current_slot = old_top_slot;
+			ring->used_slots = old_used_slots;
 			err = -EIO;
 			goto out_free_bounce;
 		}


From rjw at sisk.pl  Fri Jan 25 12:45:14 2008
From: rjw at sisk.pl (Rafael J. Wysocki)
Date: Fri, 25 Jan 2008 12:45:14 +0100
Subject: [PATCH -mm 5/5] b43: Avoid unregistering device objects during
	suspend
In-Reply-To: <200801251113.31325.mb@bu3sch.de>
References: <200801250127.21966.rjw@sisk.pl> <20080125074746.GC4134@ucw.cz>
	<200801251113.31325.mb@bu3sch.de>
Message-ID: <200801251245.16170.rjw@sisk.pl>

On Friday, 25 of January 2008, Michael Buesch wrote:
> On Friday 25 January 2008 08:47:46 Pavel Machek wrote:
> > On Fri 2008-01-25 01:37:33, Rafael J. Wysocki wrote:
> > > From: Rafael J. Wysocki <rjw at sisk.pl>
> > > 
> > > Modify the b43 driver to avoid deadlocking suspend and resume,
> > > which happens as a result of attempting to unregister device objects
> > > locked by the PM core during suspend/resume cycles.  Also, make it
> > > use a suspend-safe method of unregistering device object in the
> > > resume error path.
> > > 
> > > Signed-off-by: Rafael J. Wysocki <rjw at sisk.pl>
> > > Acked-by: Michael Buesch <mb at bu3sch.de>
> > 
> > Maybe we should have global suspend_in_progress (or maybe system_state
> > == suspending?) and automatically switch to schedule_removal() while
> > it is set?
> > 
> 
> That would be great, from my perspective :)

Let's see how many drivers are going to need that.  If there's more than a
couple, it will certainly make sense to have a global variable like this.

Thanks,
Rafael


From stefano.brivio at polimi.it  Fri Jan 25 14:24:05 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Fri, 25 Jan 2008 14:24:05 +0100
Subject: [PATCH stable 1/4] b43legacy: fix PIO crash
Message-ID: <20080125142405.00429ede@morte>

Fix the crash reported below, which seems to happen on bcm4306 rev. 2 devices
only while using PIO:

Oops: 0000 [#1] PREEMPT
Modules linked in: b43(F) rfkill(F) led_class(F) input_polldev(F) arc4 b43legacy mac80211 cfg80211 i915 drm snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device ohci1394 ieee1394 ssb pcmcia snd_intel8x0m ehci_hcd uhci_hcd evdev

Pid: 0, comm: swapper Tainted: GF	(2.6.24st3 #2)
EIP: 0060:[<f90f667b>] EFLAGS: 00010002 CPU: 0
EIP is at b43legacy_pio_handle_txstatus+0xbb/0x210 [b43legacy]
EAX: 0000049b EBX: f11f8044 ECX: 00000001 EDX: 00000000
ESI: f1ff8000 EDI: 00000000 EBP: f11f8040 ESP: c04f4ef4
 DS: 007b ES: 007b FS: 0000 GS: 0000 SS: 0068
Process swapper (pid: 0, ti=c04f4000 task=c0488300 task.ti=c04b8000)
Stack: f90f2788 c05009f0 c0500900 000010f7 f1053823 c04f4f24 dfb8e800 00000003
       f1368000 00000007 00000296 f90f1975 00001000 010c0800 01000000 00000007
       f90f6391 f11f8000 00000082 c04f4f4a 00000000 00004fd0 10f70000 8c061000
Call Trace:
 [<f90f2788>] b43legacy_debugfs_log_txstat+0x48/0xb0 [b43legacy]
 [<f90f1975>] b43legacy_handle_hwtxstatus+0x75/0x80 [b43legacy]
 [<f90f6391>] b43legacy_pio_rx+0x201/0x280 [b43legacy]
 [<f90e4fa3>] b43legacy_interrupt_tasklet+0x2e3/0x870 [b43legacy]
 [<c0123567>] tasklet_action+0x27/0x60
 [<c01237b4>] __do_softirq+0x54/0xb0
 [<c010686b>] do_softirq+0x7b/0xe0
 [<c01457c0>] handle_level_irq+0x0/0x110
 [<c01457c0>] handle_level_irq+0x0/0x110
 [<c0123758>] irq_exit+0x38/0x40
 [<c0106953>] do_IRQ+0x83/0xd0
 [<c011812f>] __update_rq_clock+0x4f/0x180
 [<c0104b4f>] common_interrupt+0x23/0x28
 [<c011007b>] wakeup_code+0x7b/0xde
 [<c02b1039>] acpi_processor_idle+0x24a/0x3c9
 [<c01025c7>] cpu_idle+0x47/0x80
 [<c04b9ad5>] start_kernel+0x205/0x290
 [<c04b9360>] unknown_bootoption+0x0/0x1f0
 =======================
Code: 0f 00 00 81 fb ff 00 00 00 0f 87 36 01 00 00 8d 04 db 85 ff 8d 6c c6 40 8d 5d 04 0f 85 ef 00 00 00 fe 4e 0e 0f b7 46 0c 8b 53 04 <8b> 4a 50 29 c8 83 e8 52 66 89 46 0c 8b 54 24 14 80 7a 0b 00 74
EIP: [<f90f667b>] b43legacy_pio_handle_txstatus+0xbb/0x210 [b43legacy] SS:ESP 0068:c04f4ef4
Kernel panic - not syncing: Fatal exception in interrupt

Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
---
Index: linux-2.6.24/drivers/net/wireless/b43legacy/pio.c
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43legacy/pio.c
+++ linux-2.6.24/drivers/net/wireless/b43legacy/pio.c
@@ -486,6 +486,9 @@ void b43legacy_pio_handle_txstatus(struc
 	queue = parse_cookie(dev, status->cookie, &packet);
 	B43legacy_WARN_ON(!queue);
 
+	if (!packet->skb)
+		return;
+
 	queue->tx_devq_packets--;
 	queue->tx_devq_used -= (packet->skb->len +
 				sizeof(struct b43legacy_txhdr_fw3));


-- 
Ciao
Stefano


From stefano.brivio at polimi.it  Fri Jan 25 14:26:21 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Fri, 25 Jan 2008 14:26:21 +0100
Subject: [PATCH stable 2/4] b43legacy: fix suspend/resume
Message-ID: <20080125142621.0d240fd8@morte>

This patch makes suspend/resume work with the b43legacy driver.
We must not overwrite the MAC addresses in the init function, as this
would also overwrite the MAC on resume. With an all-zero MAC the device
firmware is not able to ACK any received packets anymore.
Fix this by moving the initializion stuff that must be done on init but
not on resume to the start function.
Also zero out filter_flags to make sure we don't have some flags
from a previous instance for a tiny timeframe until mac80211 reconfigures
them.

This patch by Michael Buesch has been ported to b43legacy.

Cc: Michael Buesch <mb at bu3sch.de>
Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
---
Index: linux-2.6.24/drivers/net/wireless/b43legacy/main.c
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43legacy/main.c
+++ linux-2.6.24/drivers/net/wireless/b43legacy/main.c
@@ -3215,8 +3215,6 @@ static int b43legacy_wireless_core_init(
 	b43legacy_shm_write16(dev, B43legacy_SHM_SHARED, 0x0414, 0x01F4);
 
 	ssb_bus_powerup(bus, 1); /* Enable dynamic PCTL */
-	memset(wl->bssid, 0, ETH_ALEN);
-	memset(wl->mac_addr, 0, ETH_ALEN);
 	b43legacy_upload_card_macaddress(dev);
 	b43legacy_security_init(dev);
 	b43legacy_rng_init(wl);
@@ -3311,6 +3309,13 @@ static int b43legacy_start(struct ieee80
 	int did_init = 0;
 	int err = 0;
 
+	/* Kill all old instance specific information to make sure
+	 * the card won't use it in the short timeframe between start
+	 * and mac80211 reconfiguring it. */
+	memset(wl->bssid, 0, ETH_ALEN);
+	memset(wl->mac_addr, 0, ETH_ALEN);
+	wl->filter_flags = 0;
+
 	mutex_lock(&wl->mutex);
 
 	if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {


--
Ciao
Stefano


From stefano.brivio at polimi.it  Fri Jan 25 14:29:50 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Fri, 25 Jan 2008 14:29:50 +0100
Subject: [PATCH stable 3/4] b43legacy: drop packets we are not able to encrypt
Message-ID: <20080125142950.3146020a@morte>

We must drop any packets we are not able to encrypt.
We must not send them unencrypted or with an all-zero-key (which
basically is the same as unencrypted, from a security point of view).

This might only trigger shortly after resume before mac80211 reassociated
and reconfigured the keys.

It is safe to drop these packets, as the association they belong to
is not guaranteed anymore anyway.
This is a security fix in the sense that it prevents information leakage.

This patch by Michael Buesch has been ported to b43legacy.

Cc: Michael Buesch <mb at bu3sch.de>
Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
---
Index: linux-2.6.24/drivers/net/wireless/b43legacy/dma.c
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43legacy/dma.c
+++ linux-2.6.24/drivers/net/wireless/b43legacy/dma.c
@@ -1181,9 +1181,11 @@ static int dma_tx_fragment(struct b43leg
 
 	header = &(ring->txhdr_cache[slot * sizeof(
 			       struct b43legacy_txhdr_fw3)]);
-	b43legacy_generate_txhdr(ring->dev, header,
+	err = b43legacy_generate_txhdr(ring->dev, header,
 				 skb->data, skb->len, ctl,
 				 generate_cookie(ring, slot));
+	if (unlikely(err))
+		return err;
 
 	meta_hdr->dmaaddr = map_descbuffer(ring, (unsigned char *)header,
 				       sizeof(struct b43legacy_txhdr_fw3), 1);
@@ -1282,6 +1284,13 @@ int b43legacy_dma_tx(struct b43legacy_wl
 	B43legacy_BUG_ON(ring->stopped);
 
 	err = dma_tx_fragment(ring, skb, ctl);
+	if (unlikely(err == -ENOKEY)) {
+		/* Drop this packet, as we don't have the encryption key
+		 * anymore and must not transmit it unencrypted. */
+		dev_kfree_skb_any(skb);
+		err = 0;
+		goto out_unlock;
+	}
 	if (unlikely(err)) {
 		b43legacyerr(dev->wl, "DMA tx mapping failure\n");
 		goto out_unlock;
Index: linux-2.6.24/drivers/net/wireless/b43legacy/pio.c
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43legacy/pio.c
+++ linux-2.6.24/drivers/net/wireless/b43legacy/pio.c
@@ -181,7 +181,7 @@ union txhdr_union {
 	struct b43legacy_txhdr_fw3 txhdr_fw3;
 };
 
-static void pio_tx_write_fragment(struct b43legacy_pioqueue *queue,
+static int pio_tx_write_fragment(struct b43legacy_pioqueue *queue,
 				  struct sk_buff *skb,
 				  struct b43legacy_pio_txpacket *packet,
 				  size_t txhdr_size)
@@ -189,14 +189,17 @@ static void pio_tx_write_fragment(struct
 	union txhdr_union txhdr_data;
 	u8 *txhdr = NULL;
 	unsigned int octets;
+	int err;
 
 	txhdr = (u8 *)(&txhdr_data.txhdr_fw3);
 
 	B43legacy_WARN_ON(skb_shinfo(skb)->nr_frags != 0);
-	b43legacy_generate_txhdr(queue->dev,
+	err = b43legacy_generate_txhdr(queue->dev,
 				 txhdr, skb->data, skb->len,
 				 &packet->txstat.control,
 				 generate_cookie(queue, packet));
+	if (err)
+		return err;
 
 	tx_start(queue);
 	octets = skb->len + txhdr_size;
@@ -204,6 +207,8 @@ static void pio_tx_write_fragment(struct
 		octets--;
 	tx_data(queue, txhdr, (u8 *)skb->data, octets);
 	tx_complete(queue, skb);
+
+	return 0;
 }
 
 static void free_txpacket(struct b43legacy_pio_txpacket *packet,
@@ -226,6 +231,7 @@ static int pio_tx_packet(struct b43legac
 	struct b43legacy_pioqueue *queue = packet->queue;
 	struct sk_buff *skb = packet->skb;
 	u16 octets;
+	int err;
 
 	octets = (u16)skb->len + sizeof(struct b43legacy_txhdr_fw3);
 	if (queue->tx_devq_size < octets) {
@@ -247,8 +253,14 @@ static int pio_tx_packet(struct b43legac
 	if (queue->tx_devq_used + octets > queue->tx_devq_size)
 		return -EBUSY;
 	/* Now poke the device. */
-	pio_tx_write_fragment(queue, skb, packet,
+	err = pio_tx_write_fragment(queue, skb, packet,
 			      sizeof(struct b43legacy_txhdr_fw3));
+	if (unlikely(err == -ENOKEY)) {
+		/* Drop this packet, as we don't have the encryption key
+		 * anymore and must not transmit it unencrypted. */
+		free_txpacket(packet, 1);
+		return 0;
+	}
 
 	/* Account for the packet size.
 	 * (We must not overflow the device TX queue)
Index: linux-2.6.24/drivers/net/wireless/b43legacy/xmit.c
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43legacy/xmit.c
+++ linux-2.6.24/drivers/net/wireless/b43legacy/xmit.c
@@ -181,7 +181,7 @@ static u8 b43legacy_calc_fallback_rate(u
 	return 0;
 }
 
-static void generate_txhdr_fw3(struct b43legacy_wldev *dev,
+static int generate_txhdr_fw3(struct b43legacy_wldev *dev,
 			       struct b43legacy_txhdr_fw3 *txhdr,
 			       const unsigned char *fragment_data,
 			       unsigned int fragment_len,
@@ -252,6 +252,13 @@ static void generate_txhdr_fw3(struct b4
 			iv_len = min((size_t)txctl->iv_len,
 				     ARRAY_SIZE(txhdr->iv));
 			memcpy(txhdr->iv, ((u8 *)wlhdr) + wlhdr_len, iv_len);
+		} else {
+			/* This key is invalid. This might only happen
+			 * in a short timeframe after machine resume before
+			 * we were able to reconfigure keys.
+			 * Drop this packet completely. Do not transmit it
+			 * unencrypted to avoid leaking information. */
+			return -ENOKEY;
 		}
 	}
 	b43legacy_generate_plcp_hdr((struct b43legacy_plcp_hdr4 *)
@@ -344,16 +351,18 @@ static void generate_txhdr_fw3(struct b4
 	/* Apply the bitfields */
 	txhdr->mac_ctl = cpu_to_le32(mac_ctl);
 	txhdr->phy_ctl = cpu_to_le16(phy_ctl);
+
+	return 0;
 }
 
-void b43legacy_generate_txhdr(struct b43legacy_wldev *dev,
+int b43legacy_generate_txhdr(struct b43legacy_wldev *dev,
 			      u8 *txhdr,
 			      const unsigned char *fragment_data,
 			      unsigned int fragment_len,
 			      const struct ieee80211_tx_control *txctl,
 			      u16 cookie)
 {
-	generate_txhdr_fw3(dev, (struct b43legacy_txhdr_fw3 *)txhdr,
+	return generate_txhdr_fw3(dev, (struct b43legacy_txhdr_fw3 *)txhdr,
 			   fragment_data, fragment_len,
 			   txctl, cookie);
 }
Index: linux-2.6.24/drivers/net/wireless/b43legacy/xmit.h
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43legacy/xmit.h
+++ linux-2.6.24/drivers/net/wireless/b43legacy/xmit.h
@@ -76,7 +76,7 @@ struct b43legacy_txhdr_fw3 {
 
 
 
-void b43legacy_generate_txhdr(struct b43legacy_wldev *dev,
+int b43legacy_generate_txhdr(struct b43legacy_wldev *dev,
 			      u8 *txhdr,
 			      const unsigned char *fragment_data,
 			      unsigned int fragment_len,


--
Ciao
Stefano


From stefano.brivio at polimi.it  Fri Jan 25 14:32:00 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Fri, 25 Jan 2008 14:32:00 +0100
Subject: [PATCH stable 4/4] b43legacy: fix DMA slot resource leakage
Message-ID: <20080125143200.4a77d304@morte>

This fixes four resource leakages.
In any error path we must deallocate the DMA frame slots we
previously allocated by request_slot().
This is done by storing the ring pointers before doing any ring
allocation and restoring the old pointers in case of an error.

This patch by Michael Buesch has been ported to b43legacy.

Cc: Michael Buesch <mb at bu3sch.de>
Signed-off-by: Stefano Brivio <stefano.brivio at polimi.it>
---
Index: linux-2.6.24/drivers/net/wireless/b43legacy/dma.c
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43legacy/dma.c
+++ linux-2.6.24/drivers/net/wireless/b43legacy/dma.c
@@ -1164,7 +1164,7 @@ static int dma_tx_fragment(struct b43leg
 {
 	const struct b43legacy_dma_ops *ops = ring->ops;
 	u8 *header;
-	int slot;
+	int slot, old_top_slot, old_used_slots;
 	int err;
 	struct b43legacy_dmadesc_generic *desc;
 	struct b43legacy_dmadesc_meta *meta;
@@ -1174,6 +1174,9 @@ static int dma_tx_fragment(struct b43leg
 #define SLOTS_PER_PACKET  2
 	B43legacy_WARN_ON(skb_shinfo(skb)->nr_frags != 0);
 
+	old_top_slot = ring->current_slot;
+	old_used_slots = ring->used_slots;
+
 	/* Get a slot for the header. */
 	slot = request_slot(ring);
 	desc = ops->idx2desc(ring, slot, &meta_hdr);
@@ -1184,8 +1187,11 @@ static int dma_tx_fragment(struct b43leg
 	err = b43legacy_generate_txhdr(ring->dev, header,
 				 skb->data, skb->len, ctl,
 				 generate_cookie(ring, slot));
-	if (unlikely(err))
+	if (unlikely(err)) {
+		ring->current_slot = old_top_slot;
+		ring->used_slots = old_used_slots;
 		return err;
+	}
 
 	meta_hdr->dmaaddr = map_descbuffer(ring, (unsigned char *)header,
 				       sizeof(struct b43legacy_txhdr_fw3), 1);
@@ -1208,6 +1214,8 @@ static int dma_tx_fragment(struct b43leg
 	if (dma_mapping_error(meta->dmaaddr)) {
 		bounce_skb = __dev_alloc_skb(skb->len, GFP_ATOMIC | GFP_DMA);
 		if (!bounce_skb) {
+			ring->current_slot = old_top_slot;
+			ring->used_slots = old_used_slots;
 			err = -ENOMEM;
 			goto out_unmap_hdr;
 		}
@@ -1218,6 +1226,8 @@ static int dma_tx_fragment(struct b43leg
 		meta->skb = skb;
 		meta->dmaaddr = map_descbuffer(ring, skb->data, skb->len, 1);
 		if (dma_mapping_error(meta->dmaaddr)) {
+			ring->current_slot = old_top_slot;
+			ring->used_slots = old_used_slots;
 			err = -EIO;
 			goto out_free_bounce;
 		}


--
Ciao
Stefano


From dgraselli at gmail.com  Sat Jan 26 09:16:21 2008
From: dgraselli at gmail.com (Diego Graselli)
Date: Sat, 26 Jan 2008 06:16:21 -0200
Subject: b43-phy0 ERROR: Cannot request IRQ-0
Message-ID: <479AEC55.6060705@gmail.com>

Hello, I can't get my wireless work. I've followed all steps as
http://linuxwireless.org/

My laptop : compaq f565la with ubuntu 7.10

lspci |grep road
    03:00.0 Network controller: Broadcom Corporation BCM94311MCG wlan
mini-PCI (rev 02)

uname -a
    Linux chaca-laptop 2.6.22-14-generic #1 SMP Tue Dec 18 08:02:57 UTC
2007 i686 GNU/Linux


cd compat-wireless-2.6
make
#install the firmware v010
sudo make install
sudo make unload
sudo make load
dmesg
[  165.504178] PCI: No IRQ known for interrupt pin A of device
0000:03:00.0. Please try using pci=biosirq.
[  165.504192] PCI: Setting latency timer of device 0000:03:00.0 to 64
[  165.655214] ssb: Sonics Silicon Backplane found on PCI device
0000:03:00.0
[  165.666851] b43-phy0: Broadcom 4311 WLAN found
[  165.758062] phy0: Selected rate control algorithm 'simple'
[  166.886967] b43-phy0 ERROR: Cannot request IRQ-0
[  171.204366] b43-phy0 ERROR: Cannot request IRQ-0
[  195.505238] b43-phy0 ERROR: Cannot request IRQ-0
[  219.797575] b43-phy0 ERROR: Cannot request IRQ-0
[  244.105893] b43-phy0 ERROR: Cannot request IRQ-0http://linuxwireless.org/
[  268.410229] b43-phy0 ERROR: Cannot request IRQ-0
[  392.723410] b43-phy0 ERROR: Cannot request IRQ-0
[  517.058830] b43-phy0 ERROR: Cannot request IRQ-0
[  554.873297] tun: Universal TUN/TAP device driver, 1.6
[  554.873301] tun: (C) 1999-2004 Max Krasnyansky <maxk at qualcomm.com>
[  554.874270] tun0: Disabled Privacy Extensions
[  641.488758] b43-phy0 ERROR: Cannot request IRQ-0
[  765.787435] b43-phy0 ERROR: Cannot request IRQ-0
[  890.171976] b43-phy0 ERROR: Cannot request IRQ-0

I've tried boot with 'pci=biosirq' and 'pci=irqpool' but dmesg said the same

Thanks a lot,
Diego


From stefano.brivio at polimi.it  Sat Jan 26 12:01:18 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Sat, 26 Jan 2008 12:01:18 +0100
Subject: b43-phy0 ERROR: Cannot request IRQ-0
In-Reply-To: <479AEC55.6060705@gmail.com>
References: <479AEC55.6060705@gmail.com>
Message-ID: <20080126120118.27fb93b5@morte>

On Sat, 26 Jan 2008 06:16:21 -0200
Diego Graselli <dgraselli at gmail.com> wrote:

> [  890.171976] b43-phy0 ERROR: Cannot request IRQ-0
> 
> I've tried boot with 'pci=biosirq' and 'pci=irqpool' but dmesg said the same

I suggest that you should tell your BIOS that you are using a PnP aware OS.
In case your BIOS configuration doesn't allow you to set this, maybe a BIOS
upgrade could help.


--
Ciao
Stefano


From mb at bu3sch.de  Sat Jan 26 13:54:52 2008
From: mb at bu3sch.de (Michael Buesch)
Date: Sat, 26 Jan 2008 13:54:52 +0100
Subject: [PATCH stable] b43: Reject new firmware early
Message-ID: <200801261354.52659.mb@bu3sch.de>

We must reject new incompatible firmware early to avoid
running into strange transmission failures.

The current development tree supports newer firmware revisions.
These revisions cause strange failures on the stable 2.6.24 kernel.
Add a check to avoid confusing users a lot.

Signed-off-by: Michael Buesch <mb at bu3sch.de>


Index: linux-2.6.24/drivers/net/wireless/b43/main.c
===================================================================
--- linux-2.6.24.orig/drivers/net/wireless/b43/main.c	2008-01-25 11:50:05.000000000 +0100
+++ linux-2.6.24/drivers/net/wireless/b43/main.c	2008-01-26 13:25:07.000000000 +0100
@@ -1800,6 +1800,18 @@ static int b43_upload_microcode(struct b
 		err = -EOPNOTSUPP;
 		goto out;
 	}
+	if (fwrev > 351) {
+		b43err(dev->wl, "YOUR FIRMWARE IS TOO NEW. Please downgrade your "
+		       "firmware.\n");
+		b43err(dev->wl, "Use this firmware tarball: "
+		       "http://downloads.openwrt.org/sources/broadcom-wl-4.80.53.0.tar.bz2\n");
+		b43err(dev->wl, "Use this b43-fwcutter tarball: "
+		       "http://bu3sch.de/b43/fwcutter/b43-fwcutter-009.tar.bz2\n");
+		b43err(dev->wl, "Read, understand and _do_ what this message says, please.\n");
+		b43_write32(dev, B43_MMIO_MACCTL, 0);
+		err = -EOPNOTSUPP;
+		goto out;
+	}
 	b43dbg(dev->wl, "Loading firmware version %u.%u "
 	       "(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\n",
 	       fwrev, fwpatch,


From larry.finger at lwfinger.net  Sat Jan 26 17:36:53 2008
From: larry.finger at lwfinger.net (Larry Finger)
Date: Sat, 26 Jan 2008 09:36:53 -0700
Subject: b43-phy0 ERROR: Cannot request IRQ-0
In-Reply-To: <479AEC55.6060705@gmail.com>
References: <479AEC55.6060705@gmail.com>
Message-ID: <479B61A5.1030803@lwfinger.net>

Diego Graselli wrote:
> Hello, I can't get my wireless work. I've followed all steps as
> http://linuxwireless.org/
> 
> My laptop : compaq f565la with ubuntu 7.10
> 
> lspci |grep road
>     03:00.0 Network controller: Broadcom Corporation BCM94311MCG wlan
> mini-PCI (rev 02)

The rev 02 BCM94311 cards will not be supported by mainline kernels until 2.6.25-rc1. To use this
card, you will need to use the kernels in the everything branch of the wireless-2.6 git tree, or the
2.6.24 kernel patched with http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2.

Larry



From stefano.brivio at polimi.it  Sat Jan 26 17:40:23 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Sat, 26 Jan 2008 17:40:23 +0100
Subject: b43-phy0 ERROR: Cannot request IRQ-0
In-Reply-To: <479B61A5.1030803@lwfinger.net>
References: <479AEC55.6060705@gmail.com>
	<479B61A5.1030803@lwfinger.net>
Message-ID: <20080126174023.5d055ebf@morte>

On Sat, 26 Jan 2008 09:36:53 -0700
Larry Finger <larry.finger at lwfinger.net> wrote:

> Diego Graselli wrote:
> > Hello, I can't get my wireless work. I've followed all steps as
> > http://linuxwireless.org/
> > 
> > My laptop : compaq f565la with ubuntu 7.10
> > 
> > lspci |grep road
> >     03:00.0 Network controller: Broadcom Corporation BCM94311MCG wlan
> > mini-PCI (rev 02)
> 
> The rev 02 BCM94311 cards will not be supported by mainline kernels until 2.6.25-rc1. To use this
> card, you will need to use the kernels in the everything branch of the wireless-2.6 git tree, or the
> 2.6.24 kernel patched with http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2.

I take that he's using the compat package, which is synced to wireless-2.6
tree.


-- 
Ciao
Stefano


From celejar at gmail.com  Sun Jan 27 06:16:02 2008
From: celejar at gmail.com (Celejar)
Date: Sun, 27 Jan 2008 00:16:02 -0500
Subject: resuming from suspend to disk not working with b43
In-Reply-To: <200801240018.00930.rjw@sisk.pl>
References: <20080122204504.854f41a5.celejar@gmail.com>
	<200801231600.16275.rjw@sisk.pl>
	<20080123152736.c3a0833b.celejar@gmail.com>
	<200801240018.00930.rjw@sisk.pl>
Message-ID: <20080127001602.02693633.celejar@gmail.com>

On Thu, 24 Jan 2008 00:18:00 +0100
"Rafael J. Wysocki" <rjw at sisk.pl> wrote:

> On Wednesday, 23 of January 2008, Celejar wrote:
> > On Wed, 23 Jan 2008 16:00:15 +0100
> > "Rafael J. Wysocki" <rjw at sisk.pl> wrote:
> > 
> > > On Wednesday, 23 of January 2008, Celejar wrote:
> > > > Hi,
> > > 
> > > Hi,
> > >  
> > > > I know there's an ongoing long thread about suspend in b43, but
> > > > the technical level has been above me, and I don't know if anything
> > > > there is relevant to me.
> > > > 
> > > > When I suspend to disk ('s2disk' from uswsusp), the resume fails if b43
> > > > is loaded.  The screen stays blank, although I see a cursor flashing.
> > > > 'modprobe -r b43' before suspending makes the resume work fine, but if I
> > > > subsequently load b43 after the resume the machine freezes.
> > > 
> > > Hm, I use b43 w/ s2disk on a regular basis and it works, but openSUSE has a
> > > userland suspend hook that disables NetworkManager before  a suspend.
> > > 
> > > > I am using Debian Sid, b43 from vanilla kernels from kernel.org (2.6.24
> > > > isn't in Debian yet).  I have had this problem with -rc4 and -rc8. the
> > > > only two I've tried.  HW is a 4318 Air Force One, in an Acer Aspire
> > > > 3690-2672.  Is there any debugging info I can provide?  Is this a known
> > > > problem?  Is there anything I should try?
> > > 
> > > Please try to switch off the interface before suspend without unloading the
> > > module.
> > 
> > I did 'ifdown eth0' followed by 'ifconfig eth0 down'; I assume that's
> > what you meant.  I do have some sort of HW switch, but I never touch it.
> > 
> > The machine came up okay.  'ifconfig -a' shows eth0 (unconfigured), but
> > 'ifup eth0' and even 'ifconfig eth0 up' returns 'SIOCSIFFLAGS: no such
> > device.  lsmod shows that b43 is still there.  When I then did
> > 'modprobe -r b43' followed by 'modprobe b43', the machine froze - no
> > screen output after the module insertion.
> 
> When 2.6.24 is out, please test it, but make sure you don't set
> USB_OHCI_HCD_SSB.

Tested with 2.6.24 (vanilla from kernel.org); same problems
(USB_OHCI_HCD_SSB not set). 

> Thanks,
> Rafael

Celejar
--
mailmin.sourceforge.net - remote access via secure (OpenPGP) email
ssuds.sourceforge.net - A Simple Sudoku Solver and Generator



From dgraselli at gmail.com  Mon Jan 28 23:04:54 2008
From: dgraselli at gmail.com (Diego Graselli)
Date: Mon, 28 Jan 2008 20:04:54 -0200
Subject: b43-phy0 ERROR: Cannot request IRQ-0
In-Reply-To: <20080126174023.5d055ebf@morte>
References: <479AEC55.6060705@gmail.com>	<479B61A5.1030803@lwfinger.net>
	<20080126174023.5d055ebf@morte>
Message-ID: <479E5186.8060106@gmail.com>

Stefano Brivio escribi?:
> On Sat, 26 Jan 2008 09:36:53 -0700
> Larry Finger <larry.finger at lwfinger.net> wrote:
>
>   
>> Diego Graselli wrote:
>>     
>>> Hello, I can't get my wireless work. I've followed all steps as
>>> http://linuxwireless.org/
>>>
>>> My laptop : compaq f565la with ubuntu 7.10
>>>
>>> lspci |grep road
>>>     03:00.0 Network controller: Broadcom Corporation BCM94311MCG wlan
>>> mini-PCI (rev 02)
>>>       
>> The rev 02 BCM94311 cards will not be supported by mainline kernels until 2.6.25-rc1. To use this
>> card, you will need to use the kernels in the everything branch of the wireless-2.6 git tree, or the
>> 2.6.24 kernel patched with http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2.
>>     
>
> I take that he's using the compat package, which is synced to wireless-2.6
> tree.
>
>
>   
 Thanks for your soon reply, but I compiled 2.6.24 kernel patched with http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2, and then compiled and unloaded and loaded compat-wireless-2.6, and when I see syslog, see the lines 

b43-phy0 ERROR: Cannot request IRQ-0
b43-phy0 ERROR: Cannot request IRQ-0
b43-phy0 ERROR: Cannot request IRQ-0

The wlan link become blue twice and then become orange again.
 






From larry.finger at lwfinger.net  Tue Jan 29 03:43:23 2008
From: larry.finger at lwfinger.net (Larry Finger)
Date: Mon, 28 Jan 2008 19:43:23 -0700
Subject: b43-phy0 ERROR: Cannot request IRQ-0
In-Reply-To: <479E5186.8060106@gmail.com>
References: <479AEC55.6060705@gmail.com>	<479B61A5.1030803@lwfinger.net>	<20080126174023.5d055ebf@morte>
	<479E5186.8060106@gmail.com>
Message-ID: <479E92CB.5060108@lwfinger.net>

Diego Graselli wrote:
> Stefano Brivio escribi?:
>> On Sat, 26 Jan 2008 09:36:53 -0700
>> Larry Finger <larry.finger at lwfinger.net> wrote:
>>
>>   
>>> Diego Graselli wrote:
>>>     
>>>> Hello, I can't get my wireless work. I've followed all steps as
>>>> http://linuxwireless.org/
>>>>
>>>> My laptop : compaq f565la with ubuntu 7.10
>>>>
>>>> lspci |grep road
>>>>     03:00.0 Network controller: Broadcom Corporation BCM94311MCG wlan
>>>> mini-PCI (rev 02)
>>>>       
>>> The rev 02 BCM94311 cards will not be supported by mainline kernels until 2.6.25-rc1. To use this
>>> card, you will need to use the kernels in the everything branch of the wireless-2.6 git tree, or the
>>> 2.6.24 kernel patched with http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2.
>>>     
>> I take that he's using the compat package, which is synced to wireless-2.6
>> tree.
>>
>>
>>   
>  Thanks for your soon reply, but I compiled 2.6.24 kernel patched with http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2, and then compiled and unloaded and loaded compat-wireless-2.6, and when I see syslog, see the lines 
> 
> b43-phy0 ERROR: Cannot request IRQ-0
> b43-phy0 ERROR: Cannot request IRQ-0
> b43-phy0 ERROR: Cannot request IRQ-0
> 
> The wlan link become blue twice and then become orange again.

I'm sorry that I mislead you earlier. Your original kernel was loading the driver just fine, as is
the patched one. You have some kind of BIOS problem that is preventing the routing of IRQ's. Please
look carefully at the output of the 'dmesg' command and try all the things it suggests.

Larry



From stefano.brivio at polimi.it  Tue Jan 29 12:02:18 2008
From: stefano.brivio at polimi.it (Stefano Brivio)
Date: Tue, 29 Jan 2008 12:02:18 +0100
Subject: b43-phy0 ERROR: Cannot request IRQ-0
In-Reply-To: <479E5186.8060106@gmail.com>
References: <479AEC55.6060705@gmail.com> <479B61A5.1030803@lwfinger.net>
	<20080126174023.5d055ebf@morte> <479E5186.8060106@gmail.com>
Message-ID: <20080129120218.7895e425@morte>

On Mon, 28 Jan 2008 20:04:54 -0200
Diego Graselli <dgraselli at gmail.com> wrote:
   
>  Thanks for your soon reply, but I compiled 2.6.24 kernel patched with http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2, and then compiled and unloaded and loaded compat-wireless-2.6, and when I see syslog, see the lines 
> 
> b43-phy0 ERROR: Cannot request IRQ-0
> b43-phy0 ERROR: Cannot request IRQ-0
> b43-phy0 ERROR: Cannot request IRQ-0
> 
> The wlan link become blue twice and then become orange again.

Did you even try what I suggested?


--
Ciao
Stefano


From pex at arcor.de  Tue Jan 29 16:44:24 2008
From: pex at arcor.de (peX)
Date: Tue, 29 Jan 2008 16:44:24 +0100
Subject: Cannot get BCM94311MCG working with 2.6.24
Message-ID: <1201621464.7049.0.camel@lapi>

Hi,

I'm using Ubuntu 7.10 with 2.6.24 kernel

lspci:
Network controller: Broadcom Corporation BCM94311MCG wlan mini-PCI (rev
02)

I patched the kernel with this
http://linuxwireless.org/download/b43/patch_2.6.24_for_4311_2
but wlan still won't work.

iwconfig
lo        no wireless extensions.

eth0      no wireless extensions.

ifconfig
same

dmesg | grep ssb
[   22.099687] WARNING: at drivers/ssb/main.c:883
ssb_tmslow_reject_bitmask()
[   22.099698]  [<f88f88cb>] ssb_tmslow_reject_bitmask+0x4b/0x60 [ssb]
[   22.099707]  [<f88f9201>] ssb_device_is_enabled+0x11/0x40 [ssb]
[   22.099714]  [<f88fb849>] ssb_pcicore_init+0x19/0x60 [ssb]
[   22.099720]  [<f88f86d7>] ssb_attach_queued_buses+0xd7/0x280 [ssb]
[   22.099726]  [<f88fa836>] ssb_pci_xtal+0x186/0x240 [ssb]
[   22.099733]  [<f88fa14b>] ssb_pci_get_invariants+0x10b/0x310 [ssb]
[   22.099739]  [<f88f8ca2>] ssb_bus_register+0x172/0x1c0 [ssb]
[   22.099745]  [<f88fa040>] ssb_pci_get_invariants+0x0/0x310 [ssb]
[   22.099754]  [<f88f8dba>] ssb_bus_pcibus_register+0x2a/0x60 [ssb]
[   22.099766]  [<f88faa5c>] ssb_pcihost_probe+0x6c/0xa0 [ssb]
[   22.099801]  [<f88ce04a>] ssb_modinit+0x4a/0x80 [ssb]
[   22.099900] ssb: Sonics Silicon Backplane found on PCI device
0000:10:00.0
[  136.169346] WARNING: at drivers/ssb/main.c:883
ssb_tmslow_reject_bitmask()
[  136.169369]  [<f88f88cb>] ssb_tmslow_reject_bitmask+0x4b/0x60 [ssb]
[  136.169381]  [<f88f9201>] ssb_device_is_enabled+0x11/0x40 [ssb]
[  136.169388]  [<f88fb849>] ssb_pcicore_init+0x19/0x60 [ssb]
[  136.169395]  [<f88f86d7>] ssb_attach_queued_buses+0xd7/0x280 [ssb]
[  136.169401]  [<f88fa836>] ssb_pci_xtal+0x186/0x240 [ssb]
[  136.169409]  [<f88fa14b>] ssb_pci_get_invariants+0x10b/0x310 [ssb]
[  136.169417]  [<f88f8ca2>] ssb_bus_register+0x172/0x1c0 [ssb]
[  136.169423]  [<f88fa040>] ssb_pci_get_invariants+0x0/0x310 [ssb]
[  136.169440]  [<f88f8dba>] ssb_bus_pcibus_register+0x2a/0x60 [ssb]
[  136.169455]  [<f88faa5c>] ssb_pcihost_probe+0x6c/0xa0 [ssb]
[  136.169503]  [<f891804a>] ssb_modinit+0x4a/0x80 [ssb]
[  136.173552] ssb: Sonics Silicon Backplane found on PCI device
0000:10:00.0

whats wrong ?
maybe someone can help me
thx



